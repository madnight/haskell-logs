00:00:21 <stepcut> i couldn't figure out why both netscape and ie could not open the thesis.pdf ... but then I realized I don't have acrobat installed
00:00:36 <demoncrat> the pdf pages are upside down
00:00:49 <wli> why is there so much interest in Java?
00:00:56 <wli> Are people actually using it?
00:01:10 <demoncrat> wli - i'm hoping to get away from it as soon as possible
00:01:36 <wli> I sure as hell don't use it (I run on the bare metal)
00:01:58 <demoncrat> most of the E system, which i want to use, is currently in java
00:02:21 <wli> what's the e system?
00:02:22 <demoncrat> i wish i'd stuck to my guns and done a from-scratch reimplementation
00:02:36 <demoncrat> http://erights.org - language for distributed programs
00:07:11 <stepcut> lilith: looks like a cool thesis. I am trying to retarget plscheme for the flash VM (for fun)
00:07:12 <Lilith> it's a postscript problem :)
00:07:29 <Lilith> the pdfs were generated from my postscript files
00:07:35 <demoncrat> ah
00:07:46 <demoncrat> what's the flash vm like?
00:08:17 <stepcut> very limited
00:08:27 <stepcut> I still am not sure how to do lists
00:09:03 <stepcut> but macromedia recently released a 200 page document on .swf which includes all the VM opcodes
00:09:29 <Lilith> cool
00:09:42 <Lilith> stepcut: have you got the url?
00:10:12 <stepcut> http://www.macromedia.com/software/flash/open/licensing/fileformat/
00:10:24 <wli> I'd think VLIW machine models would be more interesting, esp. given the whole purity affair.
00:10:39 <stepcut> there is some license you have to agree to before you can d/l the spec, but its pretty tame 
00:11:27 <Lilith> yeah
00:11:31 <wli> e.g. ia64
00:11:48 <wli> Java is yet another stack machine, but one that doesn't fit well.
00:11:49 * Lilith thinks most flash usuage sucks
00:12:05 <Lilith> wli: the whole purity affair?
00:12:19 <Lilith> why?
00:12:39 <wli> Lilith: extreme freedom to reorder operations
00:12:46 <stepcut> yeah, but if I can get plscheme to compile to the flasm VM, then I can port plscheme itself, and have a flash page that runs scheme code. :)
00:13:28 <stepcut> you can do some interesting stuff with swf, but the flash program and actionscript make my head hurt
00:13:48 <wli> Lilith: and unravel things, too
00:13:58 <Lilith> stepcut: yeh well..i just think flash is overly abused 
00:14:10 <wli> that and passing $gp with function descriptors makes escaping variable records super-easy
00:14:10 <demoncart> my own effort at a portable vm was pretty low-level... didn't want to build in an object model, etc.
00:14:38 <stepcut> Lilith: definately
00:15:19 <Lilith> see, i can;t even download the specs without having to view flash
00:15:22 <Lilith> how sucky is that
00:15:54 <stepcut> lilith: yeah, that was pretty obnoxious, but atleast their flash page works with their linux plugin
00:16:44 <wli> demoncart: my last attempt ended up looking like MIPS R2K
00:16:51 * stepcut goes to bed
00:17:00 <Lilith> it's so annoying if you're running a term-based browser
00:17:09 <demoncart> i think i remember that one
00:17:27 <stepcutSLEEP> lilith: :(
00:17:40 <wli> Actually I think it may have been exactly R2K =)
00:17:45 <demoncart> heh
00:17:48 <demoncart> later stepcut
00:18:03 <wli> the userspace parts anyway
00:18:25 <demoncart> i didn't want to imitate a risc machine exactly because of code size, possibility of random jumps, etc.
00:18:44 <wli> demoncrat: what kind of machine did you make?
00:19:00 <demoncart> it was sort of in between a programming language and a machine language
00:19:26 <wli> eh? how's that?
00:19:26 <demoncart> http://www.accesscom.com/~darius/software/idel/index.html - you might've seen it already
00:20:06 <wli> aha
00:20:07 <wli> froth?
00:20:13 <demoncart> right - had to change the name
00:20:31 <demoncart> programs are a set of extended basic blocks, more or less
00:21:05 <demoncart> with tail calls and a stack
00:21:29 <demoncart> which is required to have static stack effects
00:22:31 <wli> I had a thought of making a virtual machine with 32-bit register numbers so things wouldn't have to do register allocation.
00:22:37 <demoncart> heh
00:22:46 <demoncart> that's pretty much the motivation for using a stack instead of registers
00:23:58 <demoncart> the other one was that you can combine ops into macro-ops more easily
00:24:34 <wli> I've since figured out how to unfold stack machine code into 3-address-code so it may end up being a tradeoff between needing additional passes for native code translation vs. the size of the virtual machine code.
00:24:46 <demoncart> yeah
00:25:02 <demoncart> i still haven't got to the native compiler for it
00:25:25 <wli> hell, I'd just generate C or C--
00:25:37 <demoncart> i'm thinking of trying out tcc
00:25:54 <wli> tendra?
00:26:02 <demoncart> no, something new
00:26:03 <wli> or tinycc?
00:26:07 <demoncart> right
00:26:13 <demoncart> i think
00:26:37 <demoncart> yeah, that's it
00:29:51 <wli> register allocation and instruction scheduling is hard, unrewarding, and a rat's nest of software patents....
00:30:23 <demoncrat> if there's a good enough dynamic code generation library, i'd love to use it
00:30:43 <demoncrat> ideally something that could do staged code generation
00:31:05 <wli> there probably won't be until the patents expire =(
00:31:28 <demoncrat> patents suck.  i saw a sun patent on 3 lines of assembly code once.
00:31:43 <demoncrat> that had already been published in a well-known paper.
00:32:10 <demoncrat> in an appendix of examples, with about a paragraph of commentary.
00:32:36 <demoncrat> vs. patent with dozens of pages
00:33:40 <wli> the software patents I've seen going around suggested to me that they were on the order of programming textbook problems
00:34:13 <demoncrat> yeah.  this one was actually a clever 3 lines of code, amazingly enough.  too bad they weren't new.
00:34:46 <wli> well
00:34:59 <demoncrat> for them, i mean :)
00:35:41 <wli> If I filed a software patent for every remotely original idea I threw into an otherwise non-noteworthy kernel hack I'd spend the vast majority of my time doing patent paperwork
00:36:02 * demoncrat nods
00:36:20 <wli> (probably likewise for anyone who actually writes code)
00:36:58 <wli> So does space compression for virtual machine code actually matter?
00:36:59 <demoncrat> actually i saw an amusing business-methods patent today -- www.lovingvoice.com
00:37:49 <wli> there's always a stupider patent
00:37:53 <demoncrat> not as much as avoiding all the other inefficiencies that make java startup take so long
00:38:01 <wli> right down to M$ patenting shite UNIX did in 1973
00:38:12 <wli> in 1997
00:39:04 <demoncrat> also i think being able to stream code in could be important
00:39:42 <demoncrat> esp. for mobile devices
00:40:03 <wli> but is codesize actually significant? does it get large?
00:40:35 <wli> (say, for streaming apps)
00:40:38 <demoncrat> i wouldn't trade it off aggressively against simplicity
00:41:02 <demoncrat> but, for example, if you want to use it for a compression format it can't have too much built-in overhead
00:41:38 <demoncrat> as i see it
00:41:57 <demoncrat> of course, any crap can take off if it's positioned right
00:42:43 <wli> some guy on OFTC suggested ELF as a method for distributed app linking
00:42:54 <demoncrat> oftc?
00:43:07 <wli> alternative IRC network to freenode/OPN
00:43:15 <demoncrat> my main objection to elf is its complexity
00:43:34 <demoncrat> actually mobile code could give you a new approach to linking - make linkers turing-complete
00:43:39 <wli> What's complex about ELF?
00:43:46 <demoncrat> have the code itself run the linking process
00:44:11 <demoncrat> well, from my reading of levine's book it has about a zillion record types
00:44:21 <demoncrat> though it's been a while
00:44:51 <wli> record types as in program headers and GOT entries and so on?
00:45:15 <demoncrat> yes, though i don't even remember GOT - global object table?
00:45:23 <wli> global offset table
00:45:30 <demoncrat> oh
00:46:04 <demoncrat> i seem to remember a bunch of things stuck in to handle different instruction formats where they needed fixups
00:46:13 <wli> relocation types
00:46:37 <demoncrat> more stuff to support dynamic linking & shared libraries
00:47:02 <wli> they're pretty much required for all formats
00:47:24 <wli> well, barring absolute code
00:47:39 <wli> (which is bad for dynamic linking)
00:47:48 <demoncrat> perhaps we could make an object file be just a program that takes other programs as inputs
00:47:51 <demoncrat> like an ml functor
00:48:02 <wli> thing is
00:48:25 <wli> occurrences of the arguments in the body of a functor are just like the places where relocations need to be done
00:48:52 <demoncrat> right - but the `format' only needs to give mechanisms, not special support for every processor etc.
00:49:32 <demoncrat> i haven't really thought this through - there might be nothing to it
00:49:44 <demoncrat> but it seems like it'd mesh nicely with ideas in generative programming
00:49:58 <demoncrat> get rid of the extra linker hacks for templates, etc.
00:50:26 <wli> relocations aren't a big deal. It basically reduces the problem of shoving addresses from dynamic objects into case analysis and precomputed points in need of fixups
00:51:13 <demoncrat> norman ramsey had a paper where he derived relocation record formats from closures
00:52:47 <demoncrat> so you can get to that pretty much automatically... i'm agreeing that they're not a big deal, it just seems like the set of variations needed is open-ended
00:56:06 <wli> well, one way is to do everything as PIC or PIC-like so you end up basically getting a thunk for data relocations that falls through a GOT entry initialized to a data reference fixup handler and going through fixup handlers for functions just like dynamic linking in all cases.
00:56:56 <wli> not much magic
00:57:07 <demoncrat> that'd be a simple approach
00:57:15 <wli> might be related to closure-related stuff
00:57:20 <demoncrat> yeah
00:57:57 <wli> PIC isn't free, but it's definitely cheaper on real machines (i.e. non-x86 FPOS's)
00:58:27 <demoncrat> the closure stuff here is a compiled representation of the fixup operations - so the object file is small even though the fixups are conceptually expressed directly as low-level operations
00:59:08 <wli> it has overheads
01:01:03 <demoncrat> if your code when it's dynamically linked can run its own linkage code to combine modules before running - they could do static-linking-type optimizations within their new boundary
03:12:36 <thornber> I was wondering if anyone can give me a quick hand with classes ...
03:13:00 <thornber> I have a class Heap in its own module that exports some methods including 'insert' and 'merge'
03:13:14 <thornber> and then have another module that contains a LeftistHeap
03:13:39 <thornber> to use the 'insert' 'merge' methods do I have to export them from the LeftistHeap module as well ?
04:12:17 * Riastradh hrumphs.
06:18:13 <saz> is there a /w 4
06:18:15 <saz> oops
06:22:21 <socrates2> is there a mechanism in haskell which enables you to simplify functions which would otherwise use a lot of else if's?
06:23:44 <thornber> you know about guards ?
06:25:59 <socrates2> thornber: no.
06:26:09 <steveh> :)
06:26:14 <steveh> welcome back socrates2 :)
06:26:20 <SyntaxPolice> does anyone know if you can't bootstrap ghc6 from 5.04.2?
06:26:42 <thornber> socrates2: foo a | (<cond on a>) = expr
06:26:55 <thornber>                         | (<cond on a>) = expr
06:26:56 <thornber> etc
06:27:36 <steveh> http://www.haskell.org/tutorial/patterns.html
06:27:39 <socrates2> thanks
06:27:59 <steveh> see after "The other twist to this set of rules is that top-level patterns may also have a boolean guard , as in this definition of a function that forms an abstract version of a number's sign" socrates2
06:28:15 <socrates2> yeah
06:28:20 <steveh> similarity to existing mathematical notation is of course purely coincidental.
06:28:41 <thornber> 4.1
06:29:25 <steveh> the alternative is "case foo of ... "
06:30:17 <steveh> except that will be just as longwinded as if-else I'd think
06:30:53 <thornber> steveh: did you see my question from this morning regarding classes ?
06:31:08 <steveh> heh I am no expert but I'll scroll back :)
06:32:11 <steveh> that's an excellent question that I don't know the answer to offhand but can probably check.
06:33:02 <thornber> I think I've done something stupid, but whenever I try and use the merge fn I get undefined variable
06:34:21 <steveh> thornber: It looks like you have to explicitly export them again
06:34:33 <thornber> trying ...
06:35:04 <steveh> at least, I can't access symbols in a module not directly loaded by Main.hs but by something that Main.hs imports...
06:35:15 <steveh> That makes sense I think
06:36:31 <steveh> ok, here's what I observe:
06:36:58 <steveh> Module C imports module B, which exports a function f and imports module A
06:37:08 <steveh> If I :load C, I can use f
06:37:18 <steveh> but I can't use g, which is defined in A
06:37:37 <steveh> That what you are looking for?
06:37:44 <thornber> I think I'm getting a name clash on 'insert', which is why exporting didn't work this morning
06:37:51 <steveh> that's quite likely
06:37:54 <thornber> so I think you're right, thanks
06:38:18 <steveh> aha!
06:38:19 <steveh> however
06:38:31 <steveh> if I specify the namespace, I can get at function g
06:38:41 <steveh> so let x = g comes up with "not in scope"
06:38:46 <steveh> but let x = A.g works.
06:38:51 <thornber> ah, useful
06:39:09 <steveh> if you really like the name "insert" you should probably qualify it :)
06:39:11 <thornber> makes sense too, I hate asking silly questions
06:39:27 <steveh> @prelude insert
06:39:27 <thornber> I've appended 'H' to all the class methods now
06:39:28 <steveh> :)
06:39:29 <lambdabot> *** "insert" prelude "Haskell Standard Prelude Dictionary": text follows
06:39:31 <lambdabot> insert
06:39:33 <lambdabot>   insert ::  (Ord a) => a -> [a] -> [a]
06:39:35 <lambdabot>   insert                   = insertBy compare
06:39:39 <steveh> that's ok, I've asked far sillier
06:39:39 <steveh> :)
06:44:17 <Darius> thornber: qualification is underused.  I'd leave it as insert
06:44:45 <thornber> Darius: ok, I'll change it back
06:45:20 <Darius> Then you get Heap.insert, and you may also have List.insert, Set.insert, instead of insertS,insert,insertSet, that most do now.
06:45:50 <thornber> eg, insertFM
06:45:53 <thornber> y
06:47:28 <steveh> Darius: good point -- is there a reason that you know of that qualification is underused?
06:48:37 <Marvin--> steveh: well, it doesn't really play nice with operators
06:50:55 <thornber> Marvin--: how do you mean ?
06:51:09 <Darius> P.. is (.) qualified
06:53:13 <Darius> Personally, I'd doubt the reason is operators. I don't know what the reason is, it is a bit "easier" for the implementor/user, but it defeats the namespace system Haskell provides.
06:54:36 <Darius> As a related note, you can import modules multiple times, with different(no) qualification, hiding different things, etc.
06:55:01 <Marvin--> yeah
06:55:07 <thornber> that's useful
06:55:18 <Marvin--> myself I prefer the way it works in python, where 'import M' doesn't clutter your namespace automagically
06:55:34 <Darius> So you could do import MyHeap hiding (<->) as Heap;import MyHeap (<->)
06:56:02 <Marvin--> Darius: you don't even need the hiding.. I'd import qualified MyHeap as Heap ; import MyHeap (<->)
06:56:43 <Darius> true, but it seems pointless to have Heap.<->
06:56:58 <steveh> hmm
06:57:29 <Darius> You should (I need to do this in EvalModule *hangs head*) import/export exactly what you need.
07:00:24 <Marvin--> I usually do that
07:00:57 <Marvin--> unless the module is really small, like when I import Control.Monad.State
07:01:51 <Darius> If I get Claus' vim Haskell mode working I can have full export/import lists in a couple of keystrokes.
07:02:43 * steveh ordered the Okasaki book yesterday
07:03:01 <steveh> and fascinatingly enough Hudak's Multimedia book is in our metropolitan library system.
07:03:26 <steveh> soon it will be in my hands :-)
07:03:41 * shapr boings
07:03:57 <thornber> steveh: Okasaki is excellent
07:04:40 <steveh> thornber: I perused an online version I found -- I think it was more his thesis that he later expanded to the book... very clearly written, now it remains for me to understand it :)
07:07:01 <thornber> I made the mistake of missing the Numerical Representations chapter on first reading, thinking that I didn't want to represent numbers - very stupid
07:08:16 <Darius> Woo, my stage1 compiler can make executables
07:08:33 <shapr> Darius: ghc6?
07:08:46 <Darius> CVS
07:08:51 <shapr> w00
07:09:11 * Marvin-- grumbles at the gmap stuff in ghc6
07:09:21 <SyntaxPolice> shapr: !
07:09:37 <socrates2> how do you write an 'or' in haskell
07:09:42 <socrates2> ?
07:10:08 <socrates2> filter (=='a' || == 'b') ls
07:10:11 <socrates2> ?
07:10:14 <Marvin--> socrates2: no
07:10:26 <SyntaxPolice> || is or
07:10:26 <Marvin--> =='a'  isn't a Bool, || takes Bools as arguments
07:10:38 <Igloo> Hmmm, it should really be in a class
07:10:40 <Darius> there is also, or for the Lispy way
07:10:50 <Igloo> Except then you'd have to define it for all functions, so it wouldn't work
07:11:19 <socrates2>  filter ((=='a') || (== 'b')) ls
07:11:20 <Marvin--> Igloo: hmm, well, (||) :: (a -> Bool) -> (a -> Bool) -> a -> Bool  would work, wouldn't it?
07:11:20 <socrates2> ?
07:11:28 <Marvin--> socrates2: you didn't read what I said
07:11:35 <Marvin--> @type (||)
07:11:36 <lambdabot> (||) :: Bool -> Bool -> Bool
07:11:42 <Darius> with f || g x = f x || g x
07:11:43 <Marvin--> @type (=='a')
07:11:43 <lambdabot> flip (==) 'a' :: Char -> Bool
07:11:48 <Igloo> Marvin: Yes, but you couldn't use it for both that and Bools
07:12:03 <socrates2> so what can you do?
07:12:23 <socrates2> I want to check for a's, i's and u's
07:12:37 <socrates2> do i have to write filter out three times?
07:12:40 <Marvin--> socrates2: you can use a lambda abstraction, or you can rewrite it in another way
07:13:12 <socrates2> conston ls = (a,b) ls
07:13:12 <socrates2>               where a = length (filter (=='a'|| ==)
07:13:12 <socrates2>                     b = (length ls) - a    
07:13:19 <socrates2> thats what i have so far
07:14:53 <socrates2> i will try a list comprehesion
07:15:01 <Marvin--> Igloo: grmbl, why doesn't Data.Generics have Data instances for tuples?
07:15:08 <Igloo> No idea
07:15:15 <Marvin--> or Int for that matter!
07:15:44 <Marvin--> Igloo: anyway, now that you're here, maybe you can help me ;)
07:16:01 <Marvin--> I'm playing some more with this since it's available in ghc 6
07:16:22 <Marvin--> trouble is that I have this function, if I give it a type signature I get an error, if I don't give it a type signature, I get another error
07:16:30 <Igloo> :-)
07:16:33 <Igloo> What function?
07:16:53 <Marvin--> it's pretty similar to what you helped me with before
07:16:59 * Igloo should point out that all I've ever done with it is the thing with you, so it's not like I'm an expert or anything  :-)
07:17:35 <Marvin--> Igloo: maybe not, but you got it to work, so you're obviously more skilled with it than me :P
07:17:37 <Igloo> And I might be about to have a meeting
07:17:41 <Marvin--> dang
07:18:09 <Igloo> Is the function, sig and errors on the web somewhere?
07:18:24 <Marvin--> let me do some copy&pasting
07:19:15 <Darius> HaskellIrcPastePage
07:20:55 <Marvin--> it's the mismatched contexts bug
07:21:30 <Marvin--> http://193.11.232.159:8080/gen.hs for full code (which is unfinished...), the error messages are in a comment
07:22:02 <shapr> hi SyntaxPolice!
07:22:06 * shapr sproings
07:22:12 <shapr> wow, 62 clients
07:22:14 <shapr> yay!
07:22:22 <Marvin--> /kick shapr
07:22:25 <Marvin--> whoops :)
07:22:43 <shapr> :-P
07:22:55 <shapr> Marvin--: trying to stage a coup, eh?
07:23:02 * Marvin-- coughs delicately
07:23:14 <Igloo> Marvin: You know the second line of fooD will never be used, right?
07:23:21 <Marvin--> Igloo: yes
07:23:44 <shapr> Igloo: will Heffalump come back at some point?
07:25:09 <Igloo> Looks like a bug to me
07:25:16 <Igloo> shapr: Dunno
07:25:23 <Igloo> I think he found it too distracting  :-)
07:25:32 <shapr> :-/
07:25:34 <Marvin--> aww
07:25:54 <Marvin--> Igloo: hmm, wonder how to trim down the code while still preserving the problem
07:27:08 <Igloo> Marvin: Did Simon fix the previous bug?
07:27:35 <shapr> I want to read the eval/apply paper today.
07:27:37 <Marvin--> Igloo: the other mismatched contexts bug? I don't know, let me check
07:29:25 <Marvin--> apparently not
07:29:54 <Marvin--> but there, at least, it works to comment out the type signature!
07:30:41 <Igloo> I suspect at least half of this is the same bug then
07:31:57 <Marvin--> that's what I was thinking too
07:32:00 <shapr> stepcutSLEEP: read the HaskellDB paper
07:32:01 <Marvin--> which is why I tried to comment it out! :)
07:32:15 <shapr> does anyone know if there's a specific license for HaskellDB?
07:32:32 <shapr> I haven't been able to find one, dunno if that's just me.
07:32:35 <Marvin--> heh, my mousepad seems to confuse my new optical mouse
07:34:29 <Marvin--> Igloo: maybe I should write a mail to g-h-u
07:34:47 <Darius> Marvin--: how's the mouse working out for you?
07:35:06 * shapr prefers optical trackballs
07:35:12 <Marvin--> Darius: really nice so far, cordless + optical
07:35:29 <SyntaxPolice> shapr: is the haskell wiki a part of the inter-wiki thing that I don't really understand?
07:35:35 <Marvin--> not to mention that my old mouse was so old that it didn't even have a scroll wheel :P
07:35:58 <Marvin--> wonder if I can get a separate receiver to use with the laptop
07:36:03 * Igloo doesn't think the c2hs Makefile docs coincide with reality very much
07:36:03 <shapr> SyntaxPolice: which one? purl.org or InterWiki ?
07:37:04 <SyntaxPolice> looks like interwiki, the one that advogato uses. whats the diff?
07:37:32 <shapr> purl.org is a permanent url that does redirection
07:37:48 <shapr> InterWiki links are built into the version of MoinMoin
07:38:09 <shapr> InterWiki lets you make links like WardsWiki:ShaeErisson
07:38:20 <shapr> amusingly, so does my irc client :-)
07:38:52 <Marvin--> now, the real question is, will this mouse make me better at War3? :P
07:38:54 <shapr> the default InterWiki entries come with whichever MoinMoin installation you're using.
07:38:54 <SyntaxPolice> hehe
07:39:00 <Marvin--> .oO(signs point to yes)
07:39:22 <cale> heh
07:40:19 * tmoertel looks back at IRC log . . .
07:40:30 <tmoertel> Marvin--: what's wrong with gmap in GHC 6 ?
07:40:52 <Marvin--> tmoertel: http://193.11.232.159:8080/gen.hs
07:41:18 <cale> I wonder whether anyone down at parc has done more research into UI design for mouse/trackball combinations. (i.e. 2 pointers for one user)
07:42:19 <tmoertel> Marvin--: there's always Strafunski-DrIFT   ;-)
07:43:20 <Marvin--> tmoertel: I had a similar problem with Strafunski's gmap distribution
07:43:35 <SyntaxPolice> shapr: OK, thanks.
07:44:01 <shapr> SyntaxPolice: best solution would be to put the purl.org link into the canonical MoinMoin wiki
07:44:25 <shapr> then HaskellWiki:IsaacJones should work from any MoinMoin wiki distro created after
07:45:20 * tmoertel needs tea, tea, tea . . . and goes to make it
07:45:35 * shapr ingests stimulants, stimulants, stimulants!
07:45:55 <shapr> amusingly, stimulants keep me from bouncing.
07:46:29 <Marvin--> and coffee relaxes me :-)
07:48:45 <Marvin--> Igloo: hrrm, I don't quite see how I will get the damn thing to recurse at all since fooD will never return Nothing :-/
07:49:14 <Marvin--> maybe I can just use everywhere instead
07:49:28 <Igloo> Marvin: I assumed the idea was that it would recurse for all other datatypes but you were handling that one specially
07:49:55 <Marvin--> Igloo: but mkM falls back to 'return' if the casting fails, so how would I get a Nothing?
07:51:01 <Igloo> Huh?
07:51:33 <Igloo> If the casting fails it should fail, which is Nothing in the Maybe Monad
07:51:56 <Marvin--> mkM f = case cast f of
07:51:57 <Marvin-->           Just g  -> g
07:51:57 <Marvin-->           Nothing -> return
07:53:15 * Igloo tries to remember how this works
07:54:56 <Marvin--> say I have  f :: Bool -> Maybe Bool ; f _ = Just True, then  mkM f "foo"  will return Just "foo", not Nothing
07:55:24 * Marvin-- is seriously wondering how this worked in "our" previous example
07:56:32 <Marvin--> maybe that one worked because it only had two data types, and we had a traversal function for each?
07:56:36 <Igloo> I'm sure it made sense at the time
07:56:43 <Igloo> Could be
07:56:47 <Marvin--> no, wait, both were traversals for Exp
07:57:22 <Igloo> OK, I certainly believe my hack using casts worked
07:57:41 * Igloo goes back to the mkM one from Ralf
07:57:50 <Marvin--> are you saying that the one Ralf sent does something else?
07:58:19 <Igloo> Was there any evidence that hsi one was actually traversing Decs?
07:58:40 <tmoertel> Chilli: are you building GHC 6 RPMs ?
07:58:48 <Igloo> Oh, wait, the Exp one has an explicit traversal for Decs
07:59:00 <Igloo> So it didn't need to be handled there
07:59:05 * tmoertel wonders if he should start a build process
07:59:52 <Marvin--> Igloo: hrrm, so that one will only work if passed an Exp in the top level function, not a Dec?
08:00:10 <Igloo> Could well be  :-)
08:00:24 <Marvin--> interesting, that sure is the case
08:00:27 <Marvin--> D'oh! :)
08:00:50 <Marvin--> hrrrm... so how to make a cut-off traversal
08:00:54 <Igloo> OK, so what's to stop you making a new mkM that uses const Nothing instead of return?
08:01:07 <Marvin--> nothing, I guess... ivil
08:02:46 <Marvin--> hrrrm, still fails for a very simple example (Bind "f" (Let [Bind "g" Con] Con))
08:03:26 <Marvin--> well, that's 'cause we don't have the initial state we want, I guess
08:04:10 <Marvin--> with Bind "f" (Let [Bind "g" (Let [Bind "h" Con] Con)] Con) I get  f, g, and g_h
08:04:34 <Marvin--> this certainly got hairier :-(
08:07:17 <Marvin--> hmm, I wonder where I put the mail you forwarded
08:08:32 <Marvin--> huh, in my studies folder, wonder why
08:09:20 <Igloo> Isn't it effeectively just a tiny change to mkM?
08:10:01 <Marvin--> well, the code still doesn't work for the second-level binds
08:10:15 <Marvin--> Bind "f" (Let [Bind "g" (Let [Bind "h" Con] Con)] Con)  should give me f, f_g and f_g_h, not f, g and g_h
08:10:28 <Marvin--> since it's the Let code that updates the state
08:10:58 <Marvin--> but fact remains is that what Ralf sent is totally broken in that it can't use mkM
08:11:59 <Marvin--> maybe I should just send a mail to Ralf
08:16:21 <mattam_> I'd like to construct a string of i ' ', is there something better than : (map (\x -> ' ') (enumFromTo 0 i)) ?
08:16:53 <Igloo> replicate i ' '
08:17:03 <mattam> thanks
08:17:35 <mattam> i hope you don't bother telling me the prelude from time to time ?
08:17:41 <Igloo> map (\_ -> ' ') [1..i] is also nicer, not to mention correct, as is map (const ' ') [1..i]
08:17:43 <shapr> @prelude replicate
08:17:46 <lambdabot> *** "replicate" prelude "Haskell Standard Prelude Dictionary": text follows
08:17:46 <lambdabot> replicate
08:17:46 <lambdabot>   replicate ::  Int -> a -> [a]
08:17:46 <lambdabot>   replicate n x     = take n (repeat x)
08:17:49 <Darius> well even using your earlier code enumFromTo i j == [i..j]
08:20:10 <mattam> i wasn't sure one could write intervals using variables
08:20:26 <mattam> that's nice
08:20:43 <Darius> You can write it using expressions
08:21:43 <Darius> The ether syntaxes are [i..] [i,j..] and [i,j..k]
08:24:55 * steveh has a question about haskell vs. lambda calculus...
08:25:28 <steveh> @get-definition Y
08:25:29 <lambdabot> Y = \f.U(\g.f(U g))
08:25:34 <steveh> @get-definition U
08:25:34 <lambdabot> U = \f. f f
08:26:20 <steveh> "f f" is not allowable in Haskell because it cannot be typed ... yet presumably the Haskell compiler still used the Y combinator to do recursion?
08:26:45 <shapr> I have often wondered about the details of the supercombinators in GHC
08:26:54 <Marvin--> steveh: in the semantic models, yes, in the implementation I suspect that'd be really inefficient
08:27:15 <steveh> hmm
08:27:37 <steveh> does the semantic model having that property allow a greater range of tail recursion optimization?
08:27:52 <shapr> I'd like to see a language where everything can be boiled down to lambda calculus, but you also get a set of supercombinators to use when making interactive or compiled binaries.
08:28:44 <steveh> I can see how for practicality's sake one wouldn't want to take the abstraction of recursion all the way down to that level, at least from a layperson's point of view
08:28:47 <shapr> I've read that Parsec does left-factoring of a parser and other internal optimizations, could you apply the same ideas to a language that lets you see all the combinators that make up each function?
08:28:56 <steveh> but I'm wondering why it's sitting here in this book :-)
08:31:10 <shapr> guten abend Dark-Star
08:31:28 <Dark-Star> hi
08:31:28 <steveh> I wrote out the first dozen or so reductions of fact 5 to try to understand how the y combinator works, since no language I have installed will let me do \f.f f
08:32:22 <steveh> I'm glad I at least pretended that numbers, if/then, *, and == were all written out in LC as well :)
08:32:30 <Marvin--> steveh: :P
08:32:33 <steveh> or I would probably just be finishing the first reduction now..
08:32:59 <steveh> at least it looked like it was coming out okay
08:33:38 <steveh> it looked like (5 * (4 * ( ... )))) 3)))
08:33:39 <steveh> :)
08:34:15 <Marvin--> Igloo: I CC:ed the mail to you, does it make any sense at all or do I just come off as very very confused? :)
08:34:39 <Darius> @type let y f = f (y f) in y
08:34:40 <lambdabot> let {y (f $0 (0 (f (y f))) $0) $0 $0} in y :: (a -> a) -> a
08:35:01 * Darius may add reduction traces to lambdabot.
08:35:18 <Igloo> Marvin: I think it makes sense, but then I've been following here  :-)
08:35:21 <steveh> Darius: :) I was looking for that and decided "aah I'll just do it myself"
08:35:25 <Marvin--> Igloo: point
08:35:47 <steveh> Darius: I found one place on the web that does traces of pure LC but it's PURE pure, no numbers and operators really
08:36:02 <Igloo> Is that lambdabot output broken?
08:36:16 <Darius> I don't know what is going on with @type
08:36:35 <shapr> something is broken
08:36:45 <Marvin--> well, it's what hugs says
08:36:54 <Marvin--> Prelude> :t let y f = f (y f) in y
08:36:54 <Marvin--> let {y (f $0 (0 (f (y f))) $0) $0 $0} in y :: (a -> a) -> a
08:36:55 <Igloo> let {...} in y :: (a -> a) -> a for m
08:36:56 <Igloo> e
08:36:59 <shapr> each @type call leaves zombie processes as well
08:37:12 <Marvin--> shapr: that's worse
08:37:14 <Igloo> What version of hugs, Marvin?
08:37:31 <Marvin--> Igloo: Debian sid
08:37:35 <Darius> Marvin--: Okay, I don't have hugs installed.  I was wondering if it used Hugs or no. (I thought it did)
08:37:40 <Marvin--> (i.e. 98.200211-3)
08:37:40 <shapr> I think I'll write a @haddock plugin
08:37:55 <Igloo> What does it say when you start it?
08:38:12 * Igloo suspects Dec 2002 is later anyway which is what I have, so it seems fixed
08:38:17 <Marvin--> uhh... a lot?  Version: November 2002
08:38:25 <Igloo> Right, yeah
08:38:26 <steveh> afk
08:38:34 <Marvin--> Igloo: you *could've* guessed that from the version ;)
08:38:57 <mattam> any portable newline character in haskell ?
08:39:11 <Marvin--> I think '\n' is supposed to be portable
08:39:11 <Igloo> Well, it doesn't necessarily map nicely
08:41:19 <Marvin--> I'm starved, time to eat
08:43:26 <stef_> what are NONE, SOME in sml?
08:44:38 * stef_ reading "programming in ML" and don't quit get it. worse, he has no idea of what he does not get
08:44:56 <shapr> yay, 64
08:45:17 <shapr> I want a watermark plugin for lambdabot 
08:45:24 <Darius> shapr it was 66 (maybe up 68) yesterday.
08:45:31 <shapr> wow cool!
08:45:51 <shapr> does that mean we have twelve people talking now? ;-)
08:46:11 <tic> 13
08:46:16 <shapr> w00
08:46:20 <Darius> You could extend @state a little to keep track.
08:46:24 <shapr> good idea
08:46:50 <Darius> Uh, though you'd have to get notifications of people entering/leaving.
08:47:33 <shapr> that's probably a good idea anyway
08:47:45 <shapr> many of those methods don't exist, or don't work
08:47:52 <shapr> that's why @topic has so much trouble
08:47:55 <stepcutSLEEP> stef: I think NONE and SOME are like NOTHING and JUST in haskell
08:48:15 <shapr> stepcutSLEEP: hey, have you seen HaskellDB?
08:49:05 <shapr> HaskellDB already does the sort of thing you're doing with MySQL
08:49:09 <stepcut> yes, I am using it as the basis of my mysql interface for ghc. Unfortunately, haskellDB uses extensible records, which are not supported in hugs
08:49:15 <stepcut> s/hugs/ghc
08:49:21 <socrates2> any ideas on how to make a function, which you give a String, and it will give you every combination of the chars in the string
08:49:22 <socrates2> ?
08:49:44 <shapr> the author of HaskellDB recently said there was a way to get around it with ... MPTC I think
08:50:04 <stepcut> is the author ever on this channel?
08:50:05 <stef_> set[cutSLEEP: I don't know Haskell, I intend to learn it. But this forum is good to answer about sml :)
08:50:23 <shapr> stepcut: nah, he's writing his PhD thesis.
08:50:50 <shapr> though the same guy also wrote Parsec, DData, GIO, Port, and some other stuff.
08:51:04 <stef_> anyway when I will have wrapped my mind around all this functional style, haskell will probably be a piece of cake
08:51:13 <shapr> stef_: be careful, it's addictive ;-)
08:51:29 <shapr> most days, I don't want to go back to my paying Python work.
08:51:43 <Darius> Haskell would force you to be more functional than SML
08:51:52 <stef_> it has to be a strong drug to make me quit my 15 years Perl habit
08:52:57 <stef_> I will not bite the Python bait. :)
08:52:59 <stepcut> stef: NONE and SOME are used if you have a function that usually returns a value, but occasionally can't for some reason. When there is a value to return you say (SOME value) and when there isn't you return NONE
08:53:22 <shapr> stef_: yes, I have not bitten the Perl bait ;-)
08:53:46 <shapr> since this is neither #python nor #perl
08:53:58 <stepcut> shapr: thanks for the info, perhaps I will drop him an email
08:54:07 <stef_> I will not defend Perl5 anyway. It is time to move forward.
08:54:19 <shapr> personally, I want firm typing.
08:54:43 <shapr> stepcut: I've forgotten what he said about getting around TREX on GHC, I'll see if I can find it...
08:54:45 <stef_> personnally, I want the option to have firm typing
08:55:48 <shapr> firm typing is static where it can be found, dynamic where it cannot be found, and rejection of statically provably wrong programs.
08:56:24 <stef_> exactly
08:57:02 <socrates2> Anyone have any answer to my question?
08:57:08 <socrates2> Anyone have any answer to my question?
08:57:21 <shapr> socrates2: repeating your question won't help
08:57:26 <shapr> er repeating your msgs
08:57:29 <shapr> sorry
08:57:38 <shapr> it usually just irritates people to repeat lines.
08:57:45 <stef_> boy after 3 weeks, amazon.uk have not yet dispatched me "Definition of Standard ML" and  "Compiling with Continuations"
08:57:48 <socrates2> shapr: that was a slip
08:57:51 <socrates2> im sorry
08:58:02 <shapr> hi hal
08:58:05 * shapr wins today
08:58:05 <hdaume> hi=
08:58:08 <hdaume> :)
08:58:10 <stef_> I note that socrates2 has trouble to establish socratic dialogs.
08:58:14 * shapr bounces
08:58:26 <shapr> socrates2: have you tried to write code that does that?
08:59:44 <shapr> socrates2: thing is, that sounds like homework, and for ethical reasons we can't give much help with homework.
09:01:02 <shapr> socrates2: I would suggest you start from a recursive length function, and see if you can turn it into the permutations function you want.
09:04:34 <shapr> hi Arnia 
09:04:40 <Arnia> Hey shapr
09:05:19 <shapr> wassup?
09:05:41 <Arnia> Thinking about the application arrow
09:09:41 * steveh wonders if all of socrates2's homework is due now at the end of the term
09:13:34 <Lilith> heh
09:14:11 <shapr> one thing about spoken/programming language classes, you can't cram it all in at the end of the term.
09:14:13 <shapr> Well, I couldn't.
09:14:32 * steveh tried with a spanish class once
09:14:33 <steveh> :)
09:14:37 <steveh> that went ok
09:14:49 <steveh> the same strategy with upper-level probability failed miserably
09:14:59 <shapr> I nearly failed French the before discovering how much consistent effort was required.
09:15:37 <steveh> well, I had 5 years of spanish in HS
09:15:59 <steveh> When I took Russian I was on the ball
09:16:15 <shapr> I've usually been able to get good grades on tests by going over stuff the night before, as long as I listened in class occasionally.
09:17:12 <steveh> for philosophy and computer classes that method worked for me
09:17:24 <steveh> abstract algebra however was an entirely different story
09:17:51 <steveh> but I passed!
09:17:59 <steveh> A big ol' P on my transcript!
09:17:59 <steveh> :)
09:18:04 <shapr> yay!
09:19:16 <steveh> i'm glad I don't have to know  if that was a C or a D in reality
09:19:28 <steveh> in fairness it should be a D, but numerically it was probably a C
09:19:39 <steveh> since I didn't have much trouble with the first part
09:19:46 <Lilith> heh
09:19:57 <steveh> somewhere around the transition between rings and fields I got lost
09:20:04 <steveh> Zorn's lemma or somesuch
09:20:31 <steveh> the fairness part comes in because I already knew about groups and algebra in general from a number theory course :)
09:20:38 <Lilith> some classes are easier to cram for then others
09:20:47 <steveh> so given the actual material learned in that class I probably deserved a D
09:20:47 <steveh> :)
09:23:31 <steveh> in truth I can't remember what zorn's lemma had to do with anything there though
09:23:43 <shapr> it sounds like someone's evil pet.
09:23:48 <steveh> i just remember someone using it in a proof and me going ... "ooooohhhkaaaaaayyy...."
09:23:57 <shapr> Steve's Lamb
09:23:58 <shapr> but evil.
09:24:21 <steveh> hehe
09:24:40 <shapr> Lilith: what types of classes are easy to cram for?
09:24:58 <steveh> psych
09:25:00 <steveh> :)
09:25:02 <steveh> cultural anthro
09:25:06 <shapr> For me, any class based on a heuristic, I can just learn the heuristic and the basic directions to interpolate, and I'm done.
09:25:26 <Lilith> shapr: that sounds like fun
09:25:33 <Lilith> steveh: which university are you in?
09:25:45 <Lilith> shapr: comp sci classes
09:25:47 <steveh> Lilith: I graduated a year ago, looking to go back :)
09:25:55 <shapr> yah, CS is heuristic based.
09:26:00 <steveh> Lilith: went to Case Western Reserve in Cleveland OH
09:26:06 <Lilith> ah
09:26:10 <steveh> not sure where I want to go to grad school
09:26:22 <shapr> I suck at classes where I have to absorb and reguritate huge amounts of unrelated info.
09:26:31 <Lilith> to get a good grade in math class, had to do consistent work
09:26:34 <Lilith> to just pass is easy
09:26:49 <steveh> Lilith: That's been my experience too.
09:26:59 <Lilith> beginner language classes are easy to cram for
09:26:59 <shapr> I've taken very few math classes
09:27:00 * steveh was a double major so had trouble dividing his attention properly
09:27:08 <shapr> what were your majors?
09:27:08 <Lilith> intermediate to advanced ones are hard
09:27:14 <steveh> CS and philosophyu
09:27:17 * andersca bounces
09:27:18 <steveh> philosophy, rather
09:27:19 * shapr boings
09:27:32 <andersca> today I MUDded for the first time
09:27:35 <shapr> andersca: hey, any good info on places to stay for ICFP?
09:27:38 <shapr> andersca: RUN AWAY
09:27:48 <shapr> I spent way too many years muddingb.
09:27:50 <steveh> andersca: aah, figured you don't need a social life anymore? :)
09:27:50 <shapr> mudding
09:27:59 <andersca> steveh: more like "I've never had one"
09:28:03 <steveh> aaah
09:28:11 * steveh likes towers.angband.com 9999
09:28:12 <shapr> code is better than being a Wizard on a MUD.
09:28:18 <steveh> very by-the-book Tolkien world
09:28:20 <steveh> and huge
09:28:26 <Lilith> heh
09:28:27 * shapr used to have several Heroes on lostsouls.org
09:28:34 * Lilith will just stick to nethack
09:28:42 <andersca> I'm playing on sharune.no-ip.com
09:28:44 * steveh plays angband over nethack, too.
09:28:46 * andersca is a Gnome there
09:28:50 <steveh> I'm a purist.
09:28:53 * Marvin-- reboots to try out War3 with his new mouse
09:28:57 <shapr> uh oh
09:29:02 <Lilith> heh
09:29:11 <Lilith> only because i'm a tolkien fan
09:29:11 * steveh ponders playing SC
09:29:15 <steveh> that game never gets old.
09:29:29 <shapr> war3 is spiffier than SC imho.
09:29:38 <steveh> my computer can't run it
09:29:49 <steveh> plus I played it on my sister's machine and wasn't all that impressed :)
09:30:17 <shapr> the heroes part is very cool.
09:30:21 <steveh> if they're going to increase the necessity of micromanagement they should just do away with the buildings entirely
09:30:23 <shapr> it's what makes the difference
09:30:24 <steveh> like Myth
09:30:27 <steveh> now that's a game! :)
09:30:38 <Lilith> hmm
09:30:42 <Lilith> i hate acroymns 
09:31:01 <shapr> iha
09:31:05 <steveh> the big thing that ruins SC for me is the existence of the "fastest" speed setting, which everyone naturally uses...
09:31:19 <shapr> whyso?
09:31:20 <steveh> it's just not possible to counter certain things at that speed
09:31:42 <steveh> that's why queens and ghosts are ridiculously underused
09:31:48 <steveh> even though they have useful spells
09:32:17 <shapr> war3 gives many spells autocast
09:32:31 * Lilith is bored
09:32:46 <steveh> well, maybe SC2 will be the best of both worlds
09:34:39 <shapr> Lilith: memepool.com
09:38:36 <Lilith> has anyone tried out nationstates.net?
09:41:29 <Lilith> heh. this is awesome
09:43:50 <shapr> ?
09:46:32 * Igloo is battling make
09:47:36 * shapr is making battle
09:47:38 <Lilith> http://unpythonic.net/~jepler/cgi-bin/rottenflesh.cgi
09:47:46 <shapr> ohno
09:47:53 <shapr> I know that guy.
09:47:59 <shapr> and that url
09:48:06 <shapr> Lilith: are you cruzing memepool?
09:48:13 <shapr> 'tis a dangerous place.
09:48:19 <shapr> I found MC Frontalot on memepool.
09:48:30 <shapr> http://www.frontalot.com/
09:50:18 <Lilith> shapr: yep
09:50:36 <Lilith> rottenflesh is just so my type of humour
09:51:55 <Lilith> shapr: doesn't particularly excite me
10:08:20 <cale> There's an awful lot of countries at nationstates.net.
10:08:37 <Lilith> yeah :)
10:08:42 <Lilith> it gets boring after a while
10:09:06 <Lilith> (mine's f00bar)
10:09:11 <cale> The United Nations has 37,106 member nations and 2545 Regional Delegates.
10:12:45 <keverets> ooh, that's nice : perms [] = [[]] ; perms xs = [ x:ps | x <- xs, ps <- perms (xs\\[x]) ]
10:13:18 <shapr> hi keverets 
10:13:25 <keverets> hi shapr
10:13:36 <cale> I wrote something similar to that not so long ago (perms)
10:13:49 <keverets> my version was no where near as compact.
10:13:50 <shapr> keverets: are you learning Haskell?
10:13:56 <cale> As in, 5 minutes ago.
10:14:01 <keverets> shapr: attempting to, yup.
10:14:29 <shapr> keverets: welcome to #haskell
10:14:37 <keverets> cale: how'd yours go?
10:14:40 <shapr> Have you already seen
10:14:43 <shapr> @fact learning
10:14:44 <lambdabot> http://www.haskell.org/learning.html
10:14:52 <keverets> shapr: thanks for the welcome ... seems like an interesting channel.
10:15:03 <cale> perms (x:xs) = [(take n ys) ++ [x] ++ (drop n ys) | ys <- (perms xs), n <- [0 .. length xs]] -- a little less compact
10:15:04 <shapr> Do you have any specific questions?
10:15:20 <keverets> I was peeking around haskell.org, but didn't hit that page specifically.
10:15:23 <shapr> hej Marvin-- 
10:15:42 <keverets> no particular questions yet, still going through craft2e, and soe.
10:15:46 <Marvin--> hejhej
10:15:53 <shapr> keverets: oh, you have both?
10:16:00 <keverets> shapr: on loan, yes.
10:16:03 <shapr> nice
10:16:21 <shapr> I learned from craft, but I've heard SOE is better overall.
10:16:31 <shapr> I've actually become convinced of that recently.
10:16:37 <shapr> Marvin--: well? does it help?
10:16:40 <keverets> anyone here using hircules?  I couldn't get it to compile (still tracking down why)...
10:17:03 <keverets> shapr: SOE seems to have a better (for me) discussion of monads, but I'm still fuzzy on them.
10:17:19 <shapr> hircules is based on lambdabot, so I can probably help you
10:18:04 * Lilith considers writing a plugin for lambdabot
10:18:05 <keverets> excellent... I'll try again a bit later (in the middle of something atm), and ask you about it then.
10:18:10 <Marvin--> shapr: it's much smoother now... playing on hard is..hard though
10:18:11 <shapr> sure
10:18:26 <shapr> Lilith: oh, what plugin?
10:18:46 <Lilith> search? 
10:18:56 <Lilith> or the other pet project i was looking at before :>
10:19:35 <shapr> ?
10:20:16 <Lilith> search on google?
10:20:20 <shapr> oh
10:20:32 <shapr> unless you do html scraping, that'll require SOAP
10:20:39 <shapr> html scraping would be easiest.
10:25:10 <Lilith> hmm yeah
10:25:30 <Marvin--> there doesn't happen to be a way to get google results in rdf?
10:25:36 <Marvin--> that'd be neat
10:25:51 <shapr> whoa, nifty stuff happening in haskell-libs cvs
10:25:54 * shapr bounces happily
10:26:26 <Marvin--> shapr: ?
10:26:50 <shapr> check out the new top-level dir
10:27:00 <Darius> @fact source
10:27:00 <lambdabot> http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/lambdabot/
10:27:07 <Marvin--> which one?
10:27:10 <shapr> Unstable
10:27:26 <Marvin--> oh, I have update -dP in my .cvsrc
10:27:34 <Marvin--> so empty directories are pointless
10:27:49 <shapr> http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/
10:28:06 <Lilith> oh
10:28:12 <Lilith> the eval module?
10:28:47 <Lilith> bah
10:28:55 <Lilith> i can never seem to compile ghc from cvs :p
10:29:05 <shapr> Lilith: there's a new Unstable dir at the top-level of the haskell-libs sf.net project, mostly because of a discussion that's been happening on libraries@h.o
10:29:11 * Darius has high hopes for this build.
10:29:34 <Marvin--> shapr: having empty directories in cvs is pointless
10:29:42 * shapr shrugs
10:29:43 <shapr> talk to Peti
10:29:50 <Marvin--> shapr: because the normal meaning of empty directory in cvs is deleted directory
10:29:53 <shapr> I want to test darcs anyway
10:30:02 <shapr> useful info, I'll remember that.
10:30:06 <Lilith> hmm
10:31:01 <Lilith> which ones?
10:31:04 * Lilith blinks
10:31:16 <shapr> which ones what?
10:31:49 <Lilith> i don't see anything of interest
10:32:43 * Lilith decides she's sufficiently bored and embarks on her erlang assignment
10:33:26 <Lilith> incidentally, what's  a "Bad interface file"?
10:33:42 <shapr> for erlang or haskell?
10:33:46 <Lilith> haskell
10:34:03 <Lilith> my attempts at building ghc from cvs has failed once again
10:34:05 <Lilith> hmm
10:34:08 <shapr> probably means ghc5.foo is trying to read a .hi file created by ghc5.bar
10:34:46 <Lilith> that makes sense
10:35:35 <mattam> is there a function using Maybe like 'findFirst [a] -> (a -> Maybe b) -> Maybe b' returning the first Just value found ?
10:36:04 <Darius> @type find
10:36:12 <Darius> @prelude find
10:36:12 <mattam> no
10:36:14 <lambdabot> *** "find" prelude "Haskell Standard Prelude Dictionary": text follows
10:36:14 <lambdabot> find
10:36:14 <lambdabot>   find ::  (a -> Bool) -> [a] -> Maybe a
10:36:14 <lambdabot>   find p                   = listToMaybe . filter p
10:36:31 <mattam> i want different types
10:38:27 <mattam> @prelude listToMaybe
10:38:29 <lambdabot> *** "listToMaybe" prelude "Haskell Standard Prelude Dictionary": text follows
10:38:29 <lambdabot> listToMaybe
10:38:29 <lambdabot>   listToMaybe ::  [a] -> Maybe a
10:38:29 <lambdabot>   listToMaybe []         = Nothing
10:38:29 <Darius> I don't think there is a premade version, but making it would be easy
10:38:30 <lambdabot>   listToMaybe (a:as)     = Just a
10:39:20 <mattam> hmmm, maybe using lazy eval will still be optimal
10:39:39 <Darius> \y.flip find (isJust . f)
10:39:54 <Darius> er no flip 
10:40:58 <Darius> @type mapM
10:40:59 <lambdabot> mapM :: Monad a => (b -> a c) -> [b] -> a [c]
10:42:05 <Darius> do (a:_) <- mapM func list; return a
10:43:14 <Darius> or maybe mconcat
10:43:48 <Darius> @prelude mconcat
10:43:50 <lambdabot> No match for "mconcat".
10:45:23 <mattam> how do you write lambda's of tuples (fun (x,y) in ML) ?
10:45:54 <Darius> \(x,y) -> ...
10:45:58 <Darius> @prelude msum
10:46:01 <lambdabot> *** "msum" prelude "Haskell Standard Prelude Dictionary": text follows
10:46:01 <lambdabot> msum
10:46:01 <lambdabot>   msum ::  MonadPlus m => [m a] -> m a
10:46:01 <lambdabot>   msum              = foldr mplus mzero
10:46:26 <mattam> thanks
10:46:27 <Darius> msum . map f
10:46:59 <Marvin--> aaahaa... I didn't know of the ext* family of functions
10:50:42 <Darius> mattam: \l f -> msum $ map f l should have the behavior you want (and then some)
10:52:06 <Marvin--> Heh, Ralf Lämmel is really enthusiastic
10:52:22 <Darius> or even more general \l f -> msum $ fmap f l
10:52:33 <Darius> (Haskell is obscene)
10:54:12 <mattam> he
10:54:20 <Marvin--> Darius: we prefer "cute" :P
10:55:31 * shapr laughs
10:58:40 <Darius> It can be used by a parallelism monad over a language AST getting concurrent searching that returns all the answers or the first thread that wins or it can be used with the Maybe monad over a list.
10:59:46 <Marvin--> Darius: I'd use liftM instead of fmap though, since you're in MonadPlus anyway
11:00:29 <Darius> er yes it needs to produce a list :(
11:00:39 <Darius> Oh well, that's what folds are for.
11:01:53 <Darius> ah well, so it's just (msum .) . flip map
11:02:25 <Marvin--> er, not (msum .) . flip liftM?
11:02:27 <Igloo> Marvin: Yeah - I like "I played with sample terms and I almost got mad because [...]"  :-)
11:02:32 <hdaume> if i have a file containing my last name ("Daum\'e", with the proper accent) and then read it in using readFile, the string I get is "Daum\233"...anyone know how to get this to @show@ properly?
11:02:56 <Marvin--> Igloo: yes indeed :)
11:03:04 <Igloo> hdaume: putStr
11:03:06 <Darius> @type liftM
11:03:17 <Darius> @prelude liftM
11:03:19 <lambdabot> *** "liftM" prelude "Haskell Standard Prelude Dictionary": text follows
11:03:19 <lambdabot> liftM
11:03:19 <lambdabot>   liftM ::  (Monad m) => (a -> b) -> (m a -> m b)
11:03:19 <lambdabot>   liftM f           = \a -> do { a' <- a; return (f a') }
11:03:35 <Marvin--> Darius: it's just like fmap
11:03:56 <Marvin--> Darius: since all monads are functors
11:03:57 <Darius> aye, but msum takes a list, so it would just be map.
11:04:18 <hdaume> Igloo: that doesn't work for me....using show, i get '\233', using 'putStrLn x', I get '\351' :)
11:05:16 <Igloo> Prelude> putStrLn "foo\233bar"
11:05:17 <Igloo> fooébar
11:05:26 <Marvin--> hdaume: locale problem?
11:05:37 <hdaume> Igloo: when i do that, i get foo\351bar printed :)
11:05:54 <Igloo> hdaume: Well, I don't in either ghci nor hugs
11:06:00 * shapr boings
11:06:12 * Marvin-- gets a space instead since his terms are in utf-8 mode :P
11:06:32 <hdaume> Igloo: it works for me in 5.04 but not 6.0 :)
11:06:47 <Igloo> Works for me in 6.1
11:07:07 <Igloo> And 6.0
11:07:18 <Darius> hdaume: Are both of those GHC's binary dists?
11:07:21 <hdaume> hrm...no, it works for me in the shell ghci, but ... hrm...let me investigate
11:07:34 <hdaume> now it's working in 6.0 shell....
11:07:52 <Marvin--> "shell" ghci?
11:08:28 <shapr> I've heard about shell libs of some sort, anyone know what it is?
11:08:31 <hdaume> as opposed to in emacs
11:08:36 <Marvin--> hdaume: oh
11:09:11 <hdaume> aaaaargh!  the following code is no longer valid?!?!?!?!?   "putStrLn$show 5"?????
11:09:36 <shapr> hdaume: TH
11:09:43 <Darius> shapr: There should be a message in the haskell@haskell.org mailling list archives.
11:09:44 <shapr> any $ without a space after it is TH
11:10:00 <hdaume> shapr: yeah, i noticed :)
11:10:09 <hdaume> well that breaks a lot of my programs :)
11:10:21 <shapr> yah, I had much excitement converting lambdabot 
11:10:24 <hdaume> is there a -fno-th option?  :)
11:10:26 <shapr> heh
11:10:28 <shapr> not that I know of
11:10:32 <shapr> Darius: thanks
11:10:39 * Darius always uses ' $ ' same as with .
11:11:38 <Igloo> Just don't use -fglasgow-exts and you should be fine
11:11:52 <Darius> haha
11:12:09 <hdaume> :) i don't think that'll work :)
11:12:20 <Igloo> The only reason I use it is because I'm working with TH  :-)
11:12:38 * hdaume needs mptcs
11:13:08 <Marvin--> is there a pedantic flag to ghc that only ever allows haskell 98?
11:13:28 <Igloo> Mmmm
11:13:35 * Igloo does lots of lovely evil things with make
11:13:58 <Marvin--> make is nice
11:14:29 <Igloo> No it isn't
11:14:45 <Marvin--> compared to some of the alternatives it sure is
11:14:49 <Igloo> You only have to look at how variables work to see that
11:15:20 <Darius> Marvin--: won't no -fglasgow-exts (or even -fno-glasgow-exts if it exists) accomplish that
11:15:37 <Igloo> In fact, the only reason I've had to do my evil things is because variables aren't lexically scoped and you get the final value, not the value at the point of use
11:15:38 <Marvin--> Darius: you can still import modules from the hierarchial libraries
11:16:11 * Marvin-- looks at the tangled web that is tempfile.py
11:16:13 <Darius> Yeah, that would be pedantic.
11:20:15 <Marvin--> oh look, Volker's replied
11:25:00 * hdaume fixed it :)
11:26:13 <SyntaxPolice> Marvin--: and?
11:31:42 <cale> I wonder when ghc6 will show up in debian.
11:33:34 <shapr> cale: I think we have several debian package maintainers on this channel.
11:33:50 <shapr> though I haven't seen the ghc5 package maintainer around in many weeks.
11:41:19 <Marvin--> SyntaxPolice: "I implemented the FFI to mkstemp in the regular style that is used throughout the entire Posix tree, so there should be no problem in licensing issues."
11:41:21 <Marvin--> eh?
11:42:17 <Marvin--> I don't see how that not makes it a licensing issue
11:46:28 <Igloo> He might mean he wrote it himself
11:47:07 <Marvin--> then why does he go on with "I filled out the copyright line in reflex, I can put there anything else if you like."?
11:47:27 <Igloo> Hmm
11:47:32 * Igloo vanishes
11:48:15 <Marvin--> argh, evolution and gpg really don't play nice
11:48:25 * Marvin-- grumbles at encrypted mails
11:51:04 <andersca> it's supposed to work(tm)
11:52:20 <Marvin--> I'm pretty damn sure I entered the passphrase right this time, and I don't know how to make it forget it
12:10:33 <shapr> um
12:10:58 <shapr> I haven't played with hierarchial libs yet, does the source file itself have to declare the entire name of this module?
12:11:17 * shapr tries
12:11:30 <Darius> If you mean module Foo.Bar where, then yes.
12:11:46 <shapr> I've just realized I don't like that.
12:12:10 <Darius> As far as the report is concerned the hierarchical libraries extension is just allowing '.' in module names.
12:12:15 <shapr> oh
12:12:32 <shapr> so, if I put module Bar into directory Foo/ does that work the same way?
12:13:13 <shapr> if "module Bar" is in Foo/Bar.hs can I import Foo.Bar ?
12:13:23 <Darius> As far as the compilers are concerned, module Foo.Bar should be in Foo/Bar.(l)hs I'm pretty sure
12:13:39 <shapr> ahh
12:13:49 <shapr> ok
12:16:10 <shapr> whoa
12:16:14 <shapr> interesting
12:17:18 <shapr> very weird
12:18:25 <shapr> it looks like each module has to explicitly know where it is in the hierarchy
12:24:55 <cale> until (\z -> (negate z) == z) (\x -> x - 1) (-2147483600::Int) -- seems like Int has two values with signum 0. :)
12:27:11 <SyntaxPolice> Marvin--: sounds like he implemented it himself and is willing to give you credit.
12:28:01 <SyntaxPolice> cale: I emailed the maintainer of ghc5 to ask him about 5.04.3 and ghc6.
12:28:08 <SyntaxPolice> (so don't everyone go emailing him :)
12:28:20 <cale> cool, thanks.
12:29:21 <mattam> is there a way to add bindings in the toplevel hugs interpreter for tests smthg like a = 1 ?
12:29:48 <Darius> cale: all 2's complement integers do that.  negate == ~x+1.  ~0x8000+1 == 0x7FFF+1 == 0x8000
12:29:54 <cale> yeah
12:30:22 <Darius> mattam not in the interpreter.  You can load a file with the bindings.
12:30:23 <cale> and it seems okay anyway, since Int is really just a model of Z/(2^n)Z for some n.
12:30:57 <mattam> humm... ok
12:31:11 <Darius> Hugs has an :e option that will open a file using your $EDITOR
12:31:18 * Darius is pretty sure.
12:31:20 <cale> mattam - ghci seems to allow bindings.
12:31:26 <Darius> You can use GHCi instead
12:31:28 <cale> although it doesn't have :e
12:31:39 <Darius> cale: :!vim foo.hs
12:31:45 <cale> ah
12:31:55 <Darius> and you can define your own :cmds
12:31:59 <cale> still, not quite as convenient.
12:32:02 <cale> okay
12:33:46 <cale> any way to refer to the presently open file in !cmds?
12:34:33 <Darius> Perhaps, I haven't read the GHCi userguide.
12:38:30 <cale> maybe I could just wrap a shell script around it to set up an environment variable so that I can use getEnv to get the filename.
12:39:32 <Darius> I believe :e opens the last file opened with :e, so unless you had it set an environment variable it wouldn't be the same behavior as Hugs.
12:40:56 <Marvin--> shapr: yes, there's been discussion about that recently on libraries@haskell.org I think
12:41:43 <cale> Yeah, but I generally don't want that behaviour anyway, though I could probably define an extra :sete or something to do that. :)
12:51:13 <stef_> hum, I tries an sml example straight from the doc and it fails :(
12:51:15 <stef_> - fun constantly a k = k ;
12:51:16 <stef_> val constantly = fn : 'a -> 'b -> 'b
12:51:16 <stef_> - val f = constantly 3 ;
12:51:16 <stef_> stdIn:23.1-23.21 Warning: type vars not generalized because of
12:51:16 <stef_>    value restriction are instantiated to dummy types (X1,X2,...)
12:51:17 <stef_> val f = fn : ?.X1 -> ?.X1
12:51:18 <stef_> - f 4 ;
12:51:27 <stef_> stdIn:24.1-24.4 Error: operator and operand don't agree [literal]
12:51:28 <stef_>   operator domain: ?.X1
12:51:28 <stef_>   operand:         int
12:51:28 <stef_>   in expression:
12:51:28 <stef_>     f 4
12:51:40 <Darius> Hmm you could probably make a :declare command to get something like :declare data Tree a = Leaf | Branch (Tree a) a (Tree a)
12:53:25 <stef_> sorry I was confused
12:54:08 <Smerdyakov> I am also sorry that you are confused.
12:54:18 <shapr> not me
12:54:48 <stef_>   constantly 3  4;
12:54:49 <stef_> val it = 4 : int
12:54:54 <stef_> works fine
12:55:17 <stef_> probably
12:55:19 <stef_> - val f = constantly 3 ;
12:55:27 <stef_> does not mean what I expect
12:57:37 <Smerdyakov> What is constantly, and what did you expect?
12:58:20 <Darius> Smerdyakov: the type of constantly is 'a -> 'b -> 'b.  That only leaves two options.
12:58:58 <Smerdyakov> I pick loop forever. :-)
12:59:18 <Smerdyakov> That's an odd function. What's the purpose of the 'a?
12:59:26 <Darius> I'm thinking, though, that stef_ either miscopied it or misread it.
13:00:05 <stef_> brb, emergency on other channel
13:00:07 <Darius> @type let k x y = x;i x = x in k i
13:00:30 <Darius> @type let {k x y = x;i x = x }in k i
13:00:39 <Darius> oh yeah.
13:26:36 <mattam> Heh guys, i wrote my first haskell module! Does it have to look like this ? http://mattam.ath.cx/cvsview/devel/haskell/tries/tries.hs Is there some style choices available to avoid very long lines ?
13:27:47 <shapr> mattam: I often put the first = in a function on the next line
13:29:36 <mattam> and for case ... of ?
13:29:37 <cale> Is there a setEnv for haskell?
13:29:54 <Marvin--> yes
13:36:27 <cale> hrm it doesn't seem to...
13:39:13 <Marvin--> hmm
13:39:42 <Darius> mattam: typically it's case foo of\n\tCon1 a -> b\n\tCon2 c -> d
13:39:57 <Darius> of starts a layout block
13:40:46 <stef_> back
13:40:59 <mattam> yes, but the tab is fixed size isn't it ?
13:42:18 <stef_> I expected - "val f = constantly 3 ;" to return me a constatn function
13:42:39 <Darius> The patterns need to line up is all, tabs or no shouldn't make a difference. (I personally don't use tabs)
13:42:53 <Darius> stef_: look at your definition of it.
13:43:27 <Darius> mattam: also isJust is defined in module Maybe (Data.Maybe for heirarchical libs)
13:44:53 <stef_> what is the meaning of ?.X1
13:46:16 <mattam> k
13:46:52 <Darius> mattam: You also use case a lot. I rarely use it.  I try to get as much done with patterns and often define auxilary functions to do more pattern matching or use HOFs.
13:47:39 <Darius> However, there are two styles.  The expression style using let and case a lambda, and the declarative style using where pattern matching and having the parameters on the lhs.
13:47:59 <Darius> And then there's point-free style.
13:48:19 <stef_> ... and pointless humor.
13:48:37 <mattam> hey, i'm a match ... with fanatic :)
13:48:56 <mattam> HOFs ?
13:49:06 <shapr> wow - http://jpbrown.i8.com/cubesolver.html
13:49:40 <Darius> Higher-order functions.  foldr/foldl/map etc. can cut down a LOT of code.
13:50:00 <mattam> k
13:50:23 <mattam> i didn't see where i could use them here
13:54:21 <Darius> They're ubiquitous.  You'll have to get used to seeing them and where you can use them.
13:54:52 <Darius> Also get familiar with the prelude and standard libraries.  There are a lot of functions which capture generic operations in it.
13:56:38 <mattam> well, i know map and fold, but where would you use them in my code ?
13:57:17 <mattam> for sure i must have missed some Prelude stuff
13:57:18 <Darius> There's also unfoldr, zip, zipWith, unzip that capture generic patterns of recursion.
13:57:43 * shapr explorbs
13:57:50 <Darius> Many list operations can probably be rewritten as folds or something close.
13:58:00 <shapr> @get-definition map
13:58:06 <shapr> oof
13:58:26 <Darius> You can also define folds for any data structure so you could probably rewrite chunks of your code as a fold over the Trie structure.
13:58:58 * shapr swears at his ISP
13:59:17 <cale> The things people do with LEGO these days. :)
13:59:25 <shapr> @get-definition map
13:59:26 <lambdabot> map = \f.foldr (\x y.f x:y) []
14:00:41 <mattam> that would imply searching the whole structure which i don't want
14:00:49 <mattam> or need
14:03:06 <cale> map f (x:xs) = f x : map f xs
14:03:40 <cale> I suppose that if you're searching for something then map won't hurt as it will be applied lazily.
14:04:02 <cale> At least if that has any bearing on what you're talking about :)
14:04:34 <Darius> mattam: Haskell is lazy
14:04:57 <Darius> @eval foldr const undefined $ from 1
14:04:58 <lambdabot> 1
14:05:06 <shapr> and so am I
14:05:33 <stef_> @get-definition foldr
14:05:34 <lambdabot> foldr = \c n l.if null l then n else c (head l) (foldr c n (tail l))
14:06:05 <Darius> @eval foldl (\l c.if head l == c then tail l else []) "abcde" "abc"
14:06:06 <lambdabot> de
14:06:10 <Darius> @eval foldl (\l c.if head l == c then tail l else []) "abcde" "abcy"
14:06:10 <lambdabot> []
14:06:18 <Darius> @eval foldl (\l c.if head l == c then tail l else []) "de" "abcy"
14:06:18 <lambdabot> head of empty list
14:06:33 <Darius> may want to check null too :P
14:06:52 <Darius> In haskell you'd use pattern matching as well.
14:08:06 <mattam> Can I ask you how would you write the insert or delete Darius ?
14:09:20 <mattam> i don't see how it could be the same thing (using lazyness) to use fold/map/etc or my recursive function
14:11:50 * shapr boings
14:12:08 * shapr sings Mr. Rogers songs.
14:12:45 <Marvin--> wow, they sure had me fooled
14:12:49 * Marvin-- is watching Wild Things
14:13:01 <shapr> the movie?
14:13:04 <Marvin--> yeah
14:13:06 <shapr> any good?
14:13:15 <Marvin--> I was kinda wondering what the rest of the movie was going to be about
14:13:21 <Marvin--> ...interesting story
14:13:29 <Marvin--> and totally unmotivated threesome sex scenes
14:13:30 <shapr> worth renting?
14:13:34 <Marvin--> no :)
14:13:34 <shapr> er
14:13:37 <shapr> ok then :-)
14:13:50 <Marvin--> did you see Fight Club yet?
14:13:59 <shapr> nope
14:14:01 <shapr> still not
14:14:07 <Marvin--> rent that :)
14:14:16 <keverets> but don't talk about it.
14:14:50 <Marvin--> and *don't* talk about it
14:14:54 <mattam> never talk about it
14:17:02 <Marvin--> aaaaand now for the predictable murder
14:17:13 <cale> :)
14:17:31 <Marvin--> well, predictable since I got past the first story twist anyway
14:17:32 * Riastradh hmms.
14:18:13 * Riastradh finally decided to teach an introductory Haskell course over the summer -- but now he needs a course description.
14:18:26 <Marvin--> Riastradh: isn't that kinda in a hurry? :)
14:18:33 <Riastradh> ?
14:18:39 <stepcut`> how about 'haskell -- it kicks ass'
14:18:43 <Marvin--> it's summer pretty soon
14:18:57 <Riastradh> Well, yeah...the application is due today.
14:19:10 <Marvin--> so you're in a hurry
14:19:19 <cale> How do I set an environment variable from Haskell?
14:19:24 <Riastradh> But I've got several hours.
14:19:40 <stepcut`> cale: what version of haskell ?
14:19:48 <stepcut`> cale: ghc 6.0 has functions for doing that...
14:19:53 <Marvin--> Riastradh: heh, you sound like Koen about writing articles "but we've got several days"
14:20:02 <Riastradh> Er, ok.
14:20:06 <cale> "Haskell: It puts the Funk in Funktion -- Learn it!"
14:20:25 <cale> stepcut`: ghc-5.04.2
14:21:10 <stepcut`> http://haskell.cs.yale.edu/ghc/docs/6.0/html/unix/System.Posix.Env.html
14:21:27 <Marvin--> I could've sworn ghc 5.04 had it too
14:21:36 <cale> ah, much more than System.Environment
14:21:57 <stepcut`> Marvin: beats me, I just remembered seeing that stuff when looking at the 6.0 docs
14:22:08 <stepcut`> maybe its in 5.04 too
14:22:19 <Riastradh> So, er, no one here will help me with an introductory Haskell course description?
14:22:28 <cale> Could not find interface file for `System.Posix.Env'
14:22:36 <shapr> -package posix ?
14:22:57 <shapr> yay, rrt2 time...
14:23:27 <Marvin--> ah, right, it's in hslibs in 5.04
14:23:29 <Marvin--> Riastradh: heh
14:23:41 <Marvin--> Riastradh: how long is it? Do you have any plans for what you want to cover?
14:23:55 <Riastradh> Marvin - How long is the course or the description?
14:24:03 <Marvin--> Riastradh: the course
14:24:14 <Riastradh> Eight classes, I believe.
14:25:23 <Marvin--> hm, how much do you intend to cover?
14:25:29 <Riastradh> As much as I can.
14:26:02 <Marvin--> well I guess it depends on what you expect of the students...
14:28:13 <cale> hmm... there's GHC.Posix, but it doesn't seem to have anything to do with environment variables in it.
14:28:25 <cale> there's no System.Posix
14:28:42 <Marvin--> cale: try -package posix and import Posix
14:29:02 <cale> okay
14:34:01 <cale> yeah, that seems to have done it - at least, it's exporting something called setEnvVar, so that should work.
14:37:31 * Riastradh 's introduction to Scheme course description stunk and he doesn't want to make that mistake again.
14:38:10 <Marvin--> LOL, I'm wondering how many were in on the conspiracies in this movie
14:39:38 <cale> Riastradh: what background should the students taking it have?
14:41:18 <Riastradh> cale - Experience with one or two other languages, preferrably somewhat functional languages.
14:43:03 <Marvin--> Riastradh: ah, then you could put a pretty decent pace on it
14:45:12 <cale> Where do you expect to start? I suppose Haskell's syntax would be important, but after that? I suppose you might be able to skip standard functional programming things, teach about lazy structures, monads, etc.
14:50:04 <Riastradh> I'll probably start with functions, as I did with my Scheme course.
14:51:02 <Riastradh> Then probably types.
14:55:29 <cale> Of course, the real way to get everyone to show up is to put "There will be free ice cream at the end of the course for those who have attended the lectures.", but I suppose the best thing to do is to put in maybe a paragraph of Haskell advocacy followed with a description of the material you'll be covering and optionally covering.
14:57:16 <keverets> s/ice cream/beer/
14:57:25 <cale> both.
14:57:34 <keverets> even better (but not together)
14:59:21 <Marvin--> beer ice cream?
15:02:05 * Darius remembers that it has gotten quiet.
15:02:16 * Darius stares at the steaming GHC6.1.
15:06:55 * cale runs ghc in Matrix-mode with ghc -fno-spoon
15:07:44 <Marvin--> oooh
15:07:56 <Marvin--> don't forget to set your terminal to green-on-black
15:09:04 <Marvin--> I think it's time to get to sleep, I gotta get up in five hours if I don't want to miss the eclipse
15:09:48 <shapr> five hours?
15:09:52 <shapr> what time is the eclipse?
15:10:13 <andersca> I don't think you can see it in boden
15:10:14 <andersca> :)
15:10:25 <shapr> really?
15:10:39 <Marvin--> uh, I'd be highly surprised if you couldn't
15:11:02 <shapr> what time?
15:11:14 <Marvin--> the eclipse is between half past four and half past six with maximum at half past five
15:11:21 <Marvin--> (roughly)
15:11:31 <shapr> nifty
15:11:43 <Marvin--> 90% coverage here in Göteborg :-)
15:16:51 <Riastradh> What does ~ do in pattern matching?
15:18:07 <Darius> It lazily matches.
15:18:32 <Darius> \(x:xs) 
15:19:53 <Darius> (\(x:xs) -> 5) [] is an error, (\ ~(x:xs) -> 5) [] isn't.
15:20:33 <Riastradh> So what does 'swap ~(x,y) = (y,x)' do?
15:20:37 <Riastradh> Or why is there a tilde there, rather.
15:21:19 <Darius> To add laziness, i.e. to avoid forcing something that needn't.
15:21:36 <Riastradh> But you're going to have to grab x and y there anyways.
15:21:54 <Riastradh> Or does that mean that x and y aren't forced, while the tuple is?
15:23:09 <cale> I'd think it'd just be the tuple, with x and y moved without evaluation.
15:26:33 <Igloo> It's useful when you have something like   foo x ~(y, z) = if x then y + z else 0   and you know that the second argument will really be a tuple if x is True
15:28:07 * Riastradh thinks an understanding of arrows just clicked in his brain.
15:30:58 <elmex> love = Maybe love  hmm... isn't it?
15:31:29 <Darius> Maybe is a type constructor
15:31:39 <elmex> yes...i just noticed that too
15:33:52 <cale> yeah, and if you change it so it's love = Just love, you get an infinite type, so that won't work either.
15:52:10 <Darius> Here's a context that seems to distinguish them.  let p = swap p in case p of (x,y) -> 5
16:09:48 <Igloo> Grrr, who said make was nice?
16:10:40 <Darius> Marvin--, but he ran away.
16:10:48 <Igloo> Typical  :-)
16:11:48 <Darius> Hmm, something seems wrong with the ghc make install.
16:17:29 <Igloo> Euch, I think I remember something like this from earlier make fun. It ignores a %.o:: %.d rule if the .d file doesn't already exist
16:20:12 * Riastradh doesn't understand how ArrowLoop works.
16:20:23 <Riastradh> Or how one might use it.
16:25:06 <Riastradh> Anyone...?
16:25:40 <Igloo> Not looked at arrows
16:26:09 <esap> riastradh: you need to think about data flows to understand it.
16:27:33 <Riastradh> Could you give me an example of using it, first?
16:29:43 <esap> riastradh: loop (arr (\ (a,b) -> (a+b,a)))
16:31:00 <Riastradh> And what would that do?
16:35:03 * esap is just thinking about what that actually does :-)
16:35:25 <Riastradh> Heh.
16:36:00 <esap> It somewhat depends on what is described for the base arrow, of course. But the idea is, that you feed back first component of the pair to the second argument, and compute a sum.
16:37:36 <esap> That is, for input (a,b), it first feeds back 'a' to 'b' and then computes the sum. So I'd say this multiplies its argument by two
16:39:17 <Darius> Congratz esap.
16:40:00 <Darius> (loop (arr (\ (a,b) -> (a+b,a))) :: Int -> Int) 5 ==> 10
16:40:50 <Riastradh> OH!
16:41:06 <esap> One interesting thing about this loop combinator is that "loop (arr (\ (x,y) -> (y,x)))" is identity.
16:41:16 <Riastradh> It returns (a+b,a) lazily, and then the snd of that tuple is b.
16:41:25 * Riastradh gets it!
16:41:34 <Riastradh> Arrows are cool, as is laziness.
16:42:51 <Riastradh> But how does it relate to looping?
16:42:59 <cale> Does there exist a combinator L in terms of S and K such that L x (...) is equivalent to \x -> (...)? That is, it preforms replacement in the same manner as lambda. Does anyone know how to write down such a combinator?
16:43:46 <Riastradh> Er, I don't think you can.
16:44:14 <esap> riastradh: well, you can try: loop (arr (\ (a,b) -> (a,a+b))). This is very similar to the previous one, but it behaves quite differently.
16:44:57 <Riastradh> (loop (arr (\(a,b) -> (a,a+b)))) 5 --> 5
16:44:58 <esap> hmm.. actually, I miswrote that, it's not an infinite loop :-)
16:45:13 <Riastradh> a+b is never evaluated there, is it?
16:45:34 <Darius> It isn't needed.
16:45:40 <esap> try: loop (arr (\(a,b) -> (a+b,a+b)))
16:45:47 <Riastradh> Right, because b is never used in the fst of the returned tuple.
16:46:08 <Riastradh> Yeah, that infinitely loops, because the snd depends on the fst and the fst depends on the second.
16:53:18 <esap> The looping combinator is more useful if you also use delay. Then you can manipulate sequences of values that depend on previous elements of the sequence.
16:53:25 <Riastradh> delay?
16:54:50 <Darius> loop (arr (\(a,b) -> (a:b,a:b))) :: Int -> [Int]
16:54:51 <esap> In one of the papers there was a class ArrowCircuit with one operation 'delay' with type delay :: b -> a b b, which will return its _previous_ input (or the argument, if none).
17:33:16 <cale> I'm having a small problem with a combinator evaluator I wrote the other day. I'm making up a library of definitions for it, and can't seem to get a multiplication for numbers that works the way I want it to...
17:34:25 <cale> `b [x][y] works, but it doesn't put the result in the same form as the numbers are defined (s `b)^n 0
17:35:34 <cale> Which is important, since after expanding variables and reducing the expression, my program will contract variables it knows, and it'd be nice if `*`2`3 would result in `6.
17:36:08 <cale> (backtick is just variable reference, s and k are the only primitives)
17:40:56 <cale> hmm...
18:04:35 <cale> @eval ((S(K((S((S(KS))K))((S((S(KS))K))(K((SK)K))))))((S((S(KS))K))((S((S(KS))K))((S((S(KS))K))(K((SK)K))))))
18:04:35 <lambdabot> <<EM Dynamic -> EM Dynamic>>
18:04:58 <cale> @eval ((S(K((S((S(KS))K))((S((S(KS))K))(K((SK)K))))))((S((S(KS))K))((S((S(KS))K))((S((S(KS))K))(K((SK)K)))))) (\x. x+1) 0
18:04:59 <lambdabot> unbound variable: KS
18:05:15 <cale> @eval ((S(K((S((S(K S))K))((S((S(K S))K))(K((S K)K))))))((S((S(K S))K))((S((S(K S))K))((S((S(K S))K))(K((S K)K)))))) (\x. x+1) 0
18:05:15 <lambdabot> 6
18:05:50 <cale> @eval ((S((S(K S))K))((S((S(K S))K))((S((S(K S))K))((S((S(K S))K))((S((S(K S))K))((S((S(K S))K))(K((S K)K)))))))) (\x. x+1) 0
18:05:50 <lambdabot> 6
18:06:04 <cale> is one of those not in normal form?
18:08:03 <Riastradh> Any instance of (S (K p) (S K K)) can be reduced to (K p); any instance of (S (K p) (K q)) can be reduced to (K (p q)).
18:08:42 <cale> ah, okay - I'll implement those rules.
18:09:13 <Riastradh> (S (K p) (K q)) is the SKI-transformed version of \x. f y where x occurs free in neither f nor y.
18:09:32 <Riastradh> (so you can ignore x completely and use (K f y))
18:10:03 <Riastradh> Er, whoops, it's not (S (K p) (S K K)) ==> (K p); it's ==> p.
18:10:06 <Riastradh> That's eta-reduction.
18:16:26 <Riastradh> If you introduced B and C, too, you could reduce (S (K f) g) to (B f g) and (S f (K g)) to (C f g), or maybe it's vice versa.
18:16:29 <Riastradh> @get-definition B
18:16:30 <lambdabot> B = \f g x. f (g x)
18:18:10 <cale> Well, B is a variable, and it will expand and then contract (hopefully correctly) -- but perhaps I might implement those on expanded versions for efficiency.
18:22:20 <seth> Has anyone here used ghc on the Mac, either in osx or os9?
18:22:52 <Riastradh> I do.
18:43:46 <cale> yeah, B and C already reduce to those things. - `b`2`3 is still /= `6 though.
18:44:12 <cale> It's functionally equivalent to 6, but it doesn't end up reducing the same way.
18:46:04 <cale> also `i and `1 don't reduce to the same thing - `i = ((SK)K) and `1 = ((S((S(KS))K))(K((SK)K)))
18:47:00 <cale> `0 = (k `i), `succ = s `b, and `1 = `succ `0
18:52:23 <cale> I wonder whether just reducing  ((S((S(KS))K))(K((SK)K))) to ((SK)K) in this case would work...
18:52:41 <cale> though that seems ugly.
18:53:24 <cale> @eval ((S((S(K S))K))(K((S K)K))) 42
18:53:25 <lambdabot> <<EM Dynamic -> EM Dynamic>>
18:53:51 <cale> @eval ((S K)K) 42
18:53:51 <lambdabot> 42
18:53:55 <cale> hrm
18:54:10 <cale> something wrong with that.
18:54:38 <cale> @eval  ((S((S(K S))K))(K((S K)K))) (\x. x+1) 41
18:54:38 <lambdabot> 42
18:55:04 <cale> @eval ((S((S(K S))K))(K((S K)K))) (I) 42
18:55:04 <lambdabot> 42
18:56:10 <cale> @eval ((S((S(K S))K))(K((S K)K))) (\x y z. (x,y,z)) 1 2 3
18:56:11 <lambdabot> (line 1, column 40):
18:56:11 <lambdabot> unexpected ","
18:56:11 <lambdabot> expecting letter or digit, var, "head", "tail", "null", bool, num, character, "[", string, "(", operator, simple term or ")"
18:56:40 <cale> @eval ((S((S(K S))K))(K((S K)K))) (\x y z. [x,y,z]) 1 2 3
18:56:41 <lambdabot> [1, 2, 3]
18:57:10 <cale> funny, it's like I except that it requires 2 parameters.
18:57:45 <cale> @eval ((S((S(K S))K))(K((S K)K))) 42
18:57:46 <lambdabot> <<EM Dynamic -> EM Dynamic>>
18:57:54 <cale> it's K
18:57:56 <cale> no
18:58:12 <cale> It still doesn't ignore its second param.
18:58:44 <cale> @eval (\x y. x y)
18:58:45 <lambdabot> <<EM Dynamic -> EM Dynamic>>
18:58:52 <cale> @eval (\x y. x y) 42
18:58:52 <lambdabot> <<EM Dynamic -> EM Dynamic>>
18:59:00 <cale> @eval (\x y. x y) 42 42
18:59:00 <lambdabot> type error
18:59:10 <cale> @eval (\x y. x y) (\x. x) 42
18:59:10 <lambdabot> 42
18:59:26 <cale> yeah, it's (\x y. x y)
18:59:31 <Riastradh> Is there a parser combinator library using arrows?
19:00:57 <cale> hmm... so eta reduction isn't being finished?
19:08:55 <cale> hmm - I think that perhaps just converting any instance of (S K a) to (S K K) might help
19:11:39 <cale> nope...
19:31:18 <cale> Well, I finally got something that works by finding a combinator J p z x y = x (p y) z
19:31:37 <cale> then using J + 0 as a definition for *
19:32:14 <Riastradh> Are you using Church numerals?
19:32:20 <cale> yeah
19:33:15 <cale> the only primitives are S and K (and strings that cannot be manipulated)
19:33:34 <Riastradh> Multiplication is just C.
19:33:49 <Riastradh> \x y. \f. x (y f)
19:33:56 <Riastradh> \x y. C x y
19:34:07 <cale> er, that's B, I think.
19:34:18 <Riastradh> No.
19:34:20 <cale> and that's what I was just struggling with.
19:34:24 <Riastradh> lambdabot has it backwards.
19:34:33 <Riastradh> @get-definition B
19:34:34 <lambdabot> B = \f g x. f (g x)
19:34:40 <Riastradh> Oh wait, no, lambdabot has got it right.
19:34:41 <cale> def b s(ks)k
19:34:45 <Riastradh> @get-definition C
19:34:45 <lambdabot> C = \f x y.f y x
19:35:09 <Riastradh> Yes, that's right.
19:35:17 <Riastradh> No, that's wrong.
19:35:24 <cale> `b[a][b][c]
19:35:24 <cale> ([a]([b][c]))
19:35:26 <Riastradh> Wait, that's right, I'm wrong.
19:35:27 <cale> anyway
19:35:39 <Riastradh> \x y. B x y
19:35:45 <cale> I've seen conflicting definitions all over the place for B and C.
19:35:57 <cale> anyway - that was my problem earlier.
19:35:58 <Riastradh> lambdabot has got it right.
19:36:01 <Riastradh> B is composition; C is flip.
19:36:33 <cale> it seems that the combinator representing \x y. x y won't reduce to I.
19:36:41 <Riastradh> Yes it will.
19:36:44 <Riastradh> Eta-reduce that -- get \x. x.
19:36:45 <Riastradh> That's I.
19:36:46 <cale> It should.
19:37:07 <cale> Yeah, but for some reason the rules I'm applying aren't working to do that.
19:37:14 <Riastradh> Perhaps your rules are wrong, then.
19:37:18 <cale> yeah
19:37:27 <Riastradh> You've got it as:  (S (K p) I) =transforms=> p
19:37:29 <Riastradh> Right?
19:37:50 <cale> yeah - I think you mentioned that earlier and I added it.
19:37:57 <cale> hang on, my mouse died.
19:38:01 <cale> bbias
19:39:09 <cale> back
19:39:12 <cale> don't know what happened there
19:39:28 <cale> I'll paste the rules I'm using for apply.
19:39:55 <Riastradh> I erroneously mentioned that it transformed to K p, and then corrected myself.
19:40:07 <cale> apply (P (P S (P K x)) (P (P S K) K) ) = x 
19:40:15 <Riastradh> What's P?
19:40:16 <cale> (P x y) = (x y)
19:40:20 <Riastradh> Oh.
19:40:32 <cale> It's my Paren data constructor.
19:40:38 <cale> apply (P (P S (P K x)) (P K y)) = (P K (P x y))
19:40:46 <cale> apply (P (P S K) x) = (P (P S K) K)
19:40:48 <Riastradh> Hmm.
19:40:52 <cale> apply (P (P K x) y) = x 
19:40:59 <cale> apply (P (P (P S x) y) z) = P (P x z) (P y z) 
19:41:02 <Riastradh> Perhaps your beta-reducer is broken.
19:41:05 <cale> apply (P x y) = (P (apply x) (apply y))
19:41:11 <cale> apply x = x
19:42:05 <Riastradh> Er, do you even beta-reduce?
19:42:11 <Riastradh> Oh, I see.
19:42:16 <cale> ?
19:42:50 <cale> I've basically picked up all I know in the last few days reading various web pages.
19:43:44 <cale> Isn't beta-reduction just the S and K rules there?
19:44:19 <cale> reduce = until (\x -> x == apply x) apply
19:46:58 <inkedmn> howdy all
19:47:22 <Riastradh> Hi.
19:47:28 <inkedmn> having a problem...
19:47:39 <inkedmn> going through Yet Another Haskell Tutorial
19:48:29 <inkedmn> working on the exercise that wants me to get numeric input from the user repeatedly and, once the user enters zero, spit out the sum of everything else they entered
19:48:59 <inkedmn> here's what i've got:
19:49:00 <inkedmn> askForNum = do
19:49:01 <inkedmn>     putStrLn "Enter a number: "
19:49:01 <inkedmn>     num <- getLine
19:49:01 <inkedmn>     if num == 0
19:49:02 <inkedmn>         then return []
19:49:05 <inkedmn>       else do
19:49:08 <inkedmn>           total <- askForNum
19:49:10 <inkedmn>           return (num:total)
19:49:30 <inkedmn> now, this is mostly a ripoff of a function earlier in the chapter
19:49:39 <Riastradh> It doesn't spit anything out.
19:50:06 <inkedmn> hmm...
19:50:20 <Riastradh> An accumulator-based loop would be much easier to write than a linear recursive function.
19:50:58 <inkedmn> hmm
19:51:46 <Riastradh> askForNum = askForNum' sum
19:51:47 <inkedmn> not really sure what an accumulator-based loop is...
19:51:49 <Riastradh>   where
19:52:02 <Riastradh>     askForNum' sum = do ...
19:52:10 <Riastradh>       if num == 0
19:52:33 <Riastradh>         then putStrLn ("The sum was: " ++ show sum)
19:52:35 <Riastradh> ...
19:52:39 <Riastradh> Fill in the '...'s.
19:52:44 <inkedmn> ah, ok
20:00:37 <inkedmn> Riastradh: almost got it, i think...
20:01:54 <inkedmn> just trying to figure out how to increment 'sum'
20:02:02 <inkedmn> (assuming the user doesn't enter 0)
20:02:18 <Riastradh> Call askForNum' with (sum + num).
20:02:26 <inkedmn> ah, sweet
20:04:56 <inkedmn> hmm...
20:05:02 <inkedmn> i'm doing something wrong
20:05:09 <inkedmn> syntax error
20:05:19 <Riastradh> Paste the code.
20:05:35 <inkedmn> askForNum = askForNum' sum
20:05:36 <inkedmn>   where
20:05:36 <inkedmn>     askForNum' sum = do
20:05:36 <inkedmn>       putStrLn "Enter a number:"
20:05:36 <inkedmn>       num <- getLine
20:05:38 <inkedmn>       if num == 0
20:05:40 <inkedmn>         then putStrLn ("the sum was: " ++ show sum)
20:05:43 <inkedmn>       else 
20:05:45 <inkedmn>         askForNum' (num + sum)
20:05:52 <inkedmn> maybe "else do"?
20:06:07 <Riastradh> I'd put the 'else' in the same column as the 'then.'
20:06:30 <Riastradh> And the call to askForNum' on the same line as the 'else.'
20:07:44 <inkedmn> hmm, now i'm getting type errors
20:07:45 <inkedmn> i think the getLine reads in a char
20:07:58 <Riastradh> Oh, yeah.
20:08:06 <Riastradh> numStr <- getLine
20:08:12 <Riastradh> let num = read numStr
20:08:18 <inkedmn> ah, heh, cool
20:08:21 <Riastradh> (put that in the place of 'num <- getLine')
20:09:56 <inkedmn> ERROR "/code/haskell/code/Num.hs":5 - Unresolved top-level overloading
20:09:56 <inkedmn> *** Binding             : askForNum
20:09:56 <inkedmn> *** Outstanding context : (Num b, Num ([b] -> b), Read ([b] -> b))
20:10:09 <inkedmn> hmm...
20:12:02 <cale> It definitely seems like something is going wrong with eta-reduction, but I have no idea how to correct it:
20:12:08 <cale> `b`2`3[f][x]
20:12:08 <cale> ([f]([f]([f]([f]([f]([f][x]))))))
20:12:12 <cale> `6[f][x]
20:12:13 <cale> ([f]([f]([f]([f]([f]([f][x]))))))
20:12:18 <cale> `b`2`3
20:12:18 <cale> ((S(K`2))`3)
20:12:23 <cale> `6
20:12:23 <cale> `6
20:14:41 <cale> How do I eta-reduce expressions of the form ((S(Kx))y)?
20:15:01 <cale> or why isn't this being taken care of?
20:28:41 <cale> Hmm, that seems to go to (\z. x (y z))
20:30:55 <cale> which makes sense, because that's B x y
20:31:15 <cale> hrm
20:31:40 <cale> well, maybe it's not eta-reduction?
20:32:56 <cale> Riastradh: Is it okay to be doing eta and beta reduction in the same step, or should I make multiple passes?
20:32:58 * inkedmn wishes he could help
20:34:19 <cale> inkedmn: did you manage to fix that unresolved top-level overloading problem fixed?
20:34:31 <inkedmn> cale: not yet, waiting for a reply on usenet now :)
20:34:35 <inkedmn> not sure what else to do
20:35:01 <cale> do a /query on me and paste the code in question and I'll see if I can pick it out.
20:35:09 <inkedmn> a /query?
20:35:15 <inkedmn> never done that, is it like a /msg?
20:35:20 <cale> yeah
20:35:24 <inkedmn> ah, ok
20:35:27 <cale> it just opens a /msg window
