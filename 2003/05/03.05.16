00:13:33 <alanl> hello
00:14:21 <saz> hello
01:59:04 <delYsid> hmm, Hircules, another GUI only hack.
01:59:08 <delYsid> :(
02:51:26 <Akasha> hi andre
02:53:48 <o3> hi
03:02:33 <thornber> hi
03:02:56 <thornber> I'm just experimenting with haskell
03:03:00 <thornber> I've defined:
03:03:27 <thornber> eSeries = [1.0 / fromInteger(fact n) | n <- [0..]]
03:03:52 <thornber> is there an elegant way to pull the first n terms off this list that are greater than x
03:05:23 <o3> ejt: take n (filter (> x) eSeries))
03:05:24 <dennisb> ejt: take a look at filter and take (both are in the prelude)
03:05:41 <ejt> but wont that try and filter the infinite list ?
03:05:53 <dennisb> ejt: sure, and it works!
03:06:10 <o3> ejt: it will terminate because haskell will only generate the numbers on demand
03:06:21 <ejt> hmm, I know the numbers get smaller
03:06:42 <dennisb> haskell is lazy language, which makes it work (like o3 said)
03:06:44 <o3> it doesn't matter, the list itself doesn't have to finish
03:06:47 <ejt> so there may never be 'n' numbers
03:06:53 <o3> you can do "take 10 [1..]
03:07:10 <o3> and it'll give you [1..10], and terminate properly
03:07:26 <ejt> I don't know 'n'
03:07:35 <ejt> I'm trying to avoid defining something like:
03:07:44 <ejt> significantPrefix :: limit [Num] -> [Num]
03:07:44 <ejt> significantPrefix limit (x:xs) | x < limit = []
03:08:01 <ejt>  | otherwise = x : significantPrefix r xs
03:08:28 <dennisb> there are other nice functions in the prelude, like takeWhile
03:08:36 <ejt> aha !
03:08:42 <dennisb> the prelude is good reading!
03:09:09 <ejt> y, I've skimmed it a couple of times, waiting for the new edition of the book to come out
03:09:10 * dennisb got to go, bye
03:09:10 <o3> ah, now i see what you mean
03:10:17 <ejt> y, takeWhile is very similar to significantPrefix (except more general)
03:14:49 <alanl> hello
03:14:55 <ejt> hi
03:15:33 <alanl> does anyone know if the code examples from the Introduction to Functional Programming using haskell availble online?
03:16:41 <ejt> author ?
03:17:32 <alanl> richard bill
03:17:34 <alanl> bird i mean
03:19:19 <ejt> google doesn't throw anything up
03:20:51 <alanl> i know..:-)
03:21:02 <ejt> sorry, not helpful
03:21:41 <alanl> no worries...will ask on the mailing list. so who are you?
03:22:57 <alanl> ie tell me about yourself
03:23:48 <ejt> just someone trying to learn haskell, 15 years of procedural mindset to lose
03:24:22 <alanl> ouch
03:24:38 <alanl> well haskell can be amazingly IO-like 
03:25:58 <alanl> so what is your motivation to change?
03:26:29 <ejt> I have some projects in mind that need a higher level language than C
03:26:41 <reltuk> I was under the impression haskell as pure functional most of the time
03:27:40 <ejt> all: is there a cartesian product fn in the prelude ?
03:28:13 <ejt> eg. cProduct [1, 2] [3, 4] = [(1,3),(1,4),(2,3),(2,4)]
03:28:20 <ejt> (this is different from zip)
03:28:54 <alanl__> damn bitchx
03:29:48 <alanl__> haskell is pure in the sense that it is referentially transparent
03:30:01 <alanl__> but it has monads so it can do IOish like stuff
03:30:59 <o3> cProduct list1 list2 = [ (e1, e2) | e1 <- list1, e2 <- list2 ]
03:33:13 <ejt> :) thanks, I'm being stupid
03:34:15 <alanl__> how are you finding haskell ejt then? 
03:34:37 <alanl__> you must admit strong typing is a good thing
03:34:53 <o3> ejt: naw :)
03:35:13 <ejt> it's very beautiful, but I'm still at the clumsy stage
03:35:46 <ejt> which is why it's helpful having people point out the elegant ways to do things
03:37:32 <alanl__> well I guess I haven't been polluted by C too much and I tend to avoid pointers whenever possible
03:37:50 <alanl__> do you know about higher order functions ejt?
03:37:55 <ejt> C has its place
03:38:01 <ejt> alanl__: y
03:40:05 <alanl__> just wondering, HoF is what makes functional languages in general cool
03:40:37 <alanl__> kissing fencepost errors goodbye is a good thing
03:40:45 <ejt> I've read things like Okasaki and Peyton Jones, I know the theory
03:40:59 <ejt> it's just that I'm putting it into practise for the first time now
03:45:13 <alanl__> ic. greencard should interest you as well
03:45:28 <o3> s/greencard/c2hs/ ;)
03:45:44 <o3> alanl__: you should at least advocate technologies from our own uni 8)
03:45:44 * ejt looks
03:46:03 <o3> (and, honestly, c2hs's syntax is much nicer than greencard's)
03:46:50 <ejt> k, that's a C binding generator
03:46:59 <ejt> has anyone used the openGL bindings ?
03:47:12 <o3> nod, i have
03:47:17 <o3> they work well
03:47:27 <ejt> k, I might try that then
03:47:35 <o3> google for hopengl tutorial
03:47:46 <ejt> presumably all C functions are treated as IO ?
03:47:51 <o3> there are at least one or two good ones around (i learnt from them)
03:47:56 <o3> ejt: no, they don't have to be
03:48:05 <ejt> but gl is ?
03:48:12 <o3> mostly IO, yeah
03:48:25 <o3> but there are some purely functional c functions out there (think math library -- sin, cos)
03:48:28 <alanl__> you can use unsafeIO but your are telling haskell that your C import has no side effects
03:49:05 <alanl__> are you from unsw o3?
03:49:13 <o3> indeed
03:49:48 <alanl__> do I have to guess who you are o3?
03:50:01 <o3> andrep
03:50:49 <ejt> alanl__: whois is useful
03:51:33 <alanl__> so what are you doing with chilli o3?
03:51:49 <alanl__> btw chilli is one of the haskell godes
03:51:54 <alanl__> s/godes/gods
03:51:54 <o3> objective-c to haskell binding
03:52:51 <alanl__> do you know why hat isn't working on the cse network?
03:53:15 <o3> haven't tried hat at cse yet, hang on
03:53:24 <o3> what's the error message?
03:53:33 <alanl__> ghc-5.04: unknown package name: hat
03:53:33 <o3> and which ghc are you using?  the normal one in /usr/local?
03:53:43 <alanl__> i'm using the local one
03:54:56 <o3> where is the hat executable you are you using?
03:55:42 <alanl__>   /home/pls/bin
03:56:22 <alanl__> cd /home/pls/bin
03:56:22 <alanl__> ls
03:56:30 <alanl__> oops...wrong window :-)
04:00:48 <o3> alanl__: use ~pls/bin/ghc and it should work now
04:00:50 <o3> i think i just fixed it up
04:02:03 <o3> yep, all good now
04:05:58 <alanl__> hello?
04:06:53 * ejt waves
04:07:08 <o3> alanl__: use ~pls/bin/ghc and it should work now
04:12:55 <alanl__> trying to tell hmake where to find the proper ghc
04:14:35 <alanl__> okay...works good now..thanks
04:22:04 <alanl__> what has been the hardest thing to adjust to in haskell ejt?
04:55:53 <alanl__> how can you have functions with no formal arguments on the LHS?
04:56:05 <alanl__> eg. zipp = uncurry zip
05:11:08 <o3> alanl__: sorry, are you asking why that why works?
05:12:26 <o3> why that works, even
05:17:00 <alanl__> yes...how does the compiler know which argument to bind to where?
05:19:33 <o3> do you know what partial applications are?
05:22:35 <alanl__> not really
05:28:03 <delYsid> map (+1) [1,2,3]
05:28:41 <delYsid> in this example, the partial application is (+1), i.e., you apply + to one of its arguments, resulting in a function which takes one arg
05:29:12 <ejt> but the 1 is taken to be the first argument, even though it is to the right of the infix operator ?
05:29:26 <ejt> ie. can I do:
05:29:33 <ejt> foo :: a -> b -> c
05:30:08 <ejt> map (`foo` an_instance_of_b) [as]
05:30:09 <ejt> ?
05:30:42 <Igloo> Yes
05:30:58 <o3> hmm, pseudonym not here
05:31:20 <o3> i wonder why people just didn't answer '(+)' for the paul graham acculumator problem
05:31:23 <ejt> say foo took three args, how would I take a slice on the last arg ?
05:31:38 <Igloo> With a lambda
05:32:03 <ejt> of course, thanks
05:32:20 <ejt> o3 are you marking problem sheets then ?
05:32:32 <o3> no :)
05:33:52 <delYsid> gah, MoinMoin is very inaccessible
05:33:53 <o3> see http://www.haskell.org/hawiki/PaulGrahamAccumulatorProblem
05:33:57 <delYsid> "Deletions are marked like this.
05:34:00 <delYsid> Additions are marked like this."
05:34:07 <delYsid> What a piece of useless info
05:34:13 * ejt discovers the 'any' function :)
05:34:57 <delYsid> ejt: there is 'all' too
05:35:15 <ejt> y, saw that
05:35:26 <alanl__> moinmoin?
05:35:54 <o3> alanl__: well, you can have a function called, say, plusTwo
05:35:57 <o3> which looks like
05:36:10 <ejt> but it's not an 'accumulator' ?
05:36:15 <o3> plusTwo = (+) 2
05:37:08 <o3> alanl__: say the type of (+) is :: Int -> Int -> Int.  if you write '(+) 2', you've "filled in" one of the arguments, so now the type is :: Int -> Int
05:37:25 <o3> when you don't fill in all the arguments required to a function, that's partial application
05:37:49 <o3> and that then returns you a new function which you can do whatever you like with
05:38:21 <o3> ejt: what do you mean?
05:38:37 <ejt> (+2) doesn't solve the accumulator problem you pointed me to
05:39:07 <o3> why?
05:39:41 <ejt> because it doesn't accumulate, they wan't to change the state inside the fn
05:40:48 <o3> i don't understand.  doing +2 doesn't change the state of the + function
05:41:15 <ejt> they want the 'n' that is inside the fn to increase
05:43:08 <o3> i think i see what you mean
05:43:20 <o3> i don't see how some of the other langs on the page doing that, though.  eg
05:43:20 <o3> Lisp: Common Lisp     (defun foo (n) 
05:43:21 <o3>                         (lambda (i) (incf n i)))
05:43:24 <ejt> (I would have no idea how to write this)
05:43:41 <ejt> o3: y
05:48:54 <o3> i don't think that "incrementing" the internal state of a thing is necessary, at least not what his examples show
05:49:47 <o3> it's not haskell's fault that it doesn't need to have an internal state to solve the problem ;)
05:50:38 <ejt> agreed, it's interesting that he's had to resort to imperative style (IO) to do it
05:50:55 <o3> no, but the point is that it doesn't
05:51:07 <o3> the + function _is_ an accumulator, effectively
05:51:24 <o3> it just does it by partial application
05:51:37 <ejt> let me finish what I'm doing then I'll have a play
05:52:05 <o3> if you want to meet the strict definition of the problem, then we have you write a function that takes a number n
05:52:13 <o3> so instead of +, just partially apply it with n.  ie
05:52:35 <o3> foo :: Int -> (Int -> Int)
05:52:40 <o3> foo n = (+) n
05:52:56 <ejt> I admit the problem is written badly, but you can't ignore the stuff in brackets:
05:52:59 <o3> but that's exactly the same as (+)
05:53:26 <ejt> "(That's incremented by, not plus.  An accumulator has to accumulate)
05:53:55 <o3> i didn't get the distinction between incremented and +
05:55:29 <ejt> he wants the internal variable incremented
05:55:56 <ejt> so subsequent calls with the same argument will _not_ give the same answer
05:57:37 <o3> ah!
05:57:43 <o3> now i understand, thank you
05:57:50 <o3> that's been bugging me for a while
05:57:54 <ejt> :)
05:58:36 <ejt> that page should be updated with a better definition + example of use
06:03:46 <ejt> this language is great :)
06:05:11 <ejt> does anyone have style comments on this:
06:05:19 <ejt> isCubeSum :: Integer -> Integer -> Bool
06:05:20 <ejt> isCubeSum _ 0 = True
06:05:20 <ejt> isCubeSum 0 _ = False
06:05:20 <ejt> isCubeSum c n = any (isCubeSum (c - 1)) (map (n-) (takeWhile (<= n) cubes))
06:05:55 <ejt> answer = take 2 (filter (not . isCubeSum 8) [1..])
06:06:09 <ejt> answer takes several seconds to calc in ghci
06:07:54 <alanl__> whats the difference between newtype and just type?
06:08:37 <alanl__> or is newtype == data?
06:08:54 <Smerdyakov> I think HaWiki answers that.
06:09:02 <delYsid> terminology question: a list with just one element is called ? (singelton?)
06:09:32 <delYsid> alanl__: Newtype can only be used with constructors which have only one element
06:09:47 <delYsid> like newtype MyT = MyT Int
06:09:50 <delYsid> vs.
06:10:00 <delYsid> data MyT = MyT Int Int
06:10:01 <o3> alanl__: type is just a type synonym
06:10:22 <o3> e.g. "type Dollars = Int" means that you can use Dollars in any place an Int would be required
06:10:58 <alanl__> ah....thanks! 
06:11:10 <o3> newtype effectively makes a brand new type which cannot be used in the place of the old type, e.g. if you did "newtype Dollars = Dollars Int", then the type signature ":: Dollars -> Int" is not the same as ":: Int -> Int"
06:12:08 <o3> but you need to tell haskell the difference between Dollars and Int -- is 5 of type Dollars, or of type Int?  which is why you also have the Dollars constructor
06:12:09 <delYsid> but you can define instances for newtype, which you can't do with type synonyms
06:12:41 <o3> evening marvin
06:13:06 <delYsid> ie.e. instance Show Dollars where show (Dollars x) = '$' : (show x)
06:13:27 <alanl__> its just I've always used data...haven't seen newtype used ...
06:13:41 <Marvin--> o3: afternoon o3 :)
06:13:43 <o3> alanl__: the most useful place for newtype is the FFI, i think
06:13:50 <delYsid> I've been told that newtype is in some cases faster.
06:14:13 <o3> newtype's only ever used for typechecking purposes, i think
06:14:28 <o3> hmm, not completely true
06:14:58 <delYsid> o3: If it is not faster, why would one actually need it then? since data does the same thing
06:15:03 <o3> i never bother with newtype unless i'm using the ffi 8)
06:15:49 <Marvin--> for some reason, newtype is optimized in some way
06:15:56 <alanl__> i'm guessing its for compatibility purposes
06:16:05 <Marvin--> I don't see why data F = F T can't be optimized in the same way though
06:16:07 <o3> here tis
06:16:08 <o3> http://www.haskell.org/hawiki/NonTrivialTypeSynonyms?action=highlight&value=newtype
06:16:09 <Marvin--> maybe it's a semantic difference
06:16:24 <o3> damn semantics
06:17:07 <Marvin--> ah, right, it affects the behaviour of _|_
06:17:48 <alanl__> so is newtype strict then?
06:19:15 <o3> cool!  http://www.digibarn.com/collections/posters/tongues/
06:19:19 <Igloo> newtype is just a figment of the typechecker's imagination
06:19:20 <o3> (it has haskell on there, thankfully :)
06:20:05 <Marvin--> so in a sense, newtype is exactly the same thing as restricted type synonyms?
06:20:13 <Igloo> So F _|_ and _|_ if F constructs a newtype are indistinguishable because the F doesn't really exist
06:20:31 <Igloo> WDYM by "restricted"?
06:21:32 <Marvin--> type T = T' in f, g, ...
06:21:53 <Igloo> I still don't follow
06:22:36 <Igloo> It's the same as a type synonym in terms of code generated but the type checker knows it is different
06:22:53 <ejt> I presume Marvin means that if you have foo :: Integer, then define a newtype myInt = Integer, you will not be able to pass a myInt into foo ?
06:23:15 <ejt> s/foo :: Integer/foo :: Integer -> a/
06:23:39 <Igloo> newtype myInt = MyInt Integer, and no, you can't pass one to something expecting an Integer
06:24:04 <Igloo> Nor can you pass an Integer to something expecting a MyInt
06:24:14 <o3> newtype MyInt = MyInt Integer :D
06:24:37 <Igloo> Ooops, yes  :-)
06:25:35 <Marvin--> Igloo: when you say "type T = T' in f, g, h" the T' is only exposed to the functions f, g, h, for other functions it's a black box
06:26:18 <Igloo> But f g and h wouldn't know it was just a synonym either
06:27:11 <o3> has anybody here checked out clean?
06:27:46 <Marvin--> Igloo: I don't think ghc supports this notation, but hugs -98 does
06:28:12 <Igloo> Oh, I see, it's a Haskell extension
06:28:32 <Marvin--> yes
06:28:35 <Marvin--> sorry
06:28:54 <Igloo> That sounds quite handy for when you want an ADT that is really just a list or something
06:29:04 <Marvin--> instead of saying  newtype Var = Var String,  I can say   type Var = String in newVar, showVar, ...'
06:29:09 <Marvin--> -'
06:29:38 <Marvin--> Igloo: indeed
06:30:13 <Marvin--> it's a bit cumbersome to instantiate classes, but you can do it, in the case of show; instance Show Var where show = showVar
06:30:58 <Marvin--> a whole lot easier to implement bind for a shallow embedding monad ;)
06:32:08 <Marvin--> type StateM s a = s -> (s,a) in bindStM, returnStM
06:32:24 <o3> hmm
06:32:29 <o3> stupid monomorphism restriction
06:32:32 <Marvin--> o3: heh
06:32:36 <Marvin--> join the club
06:37:59 <o3> if you have a function 'foo :: MyTypeClass c => c -> ...", is there anyway to declare that the type of an expression inside that function will be that same type variable c?
06:38:42 <Marvin--> I don't think so :/
06:38:45 <o3> so if you pass foo something of type MySpecificInstance, then you can force the type of an expression inside that function to also be MySpecificInstance?
06:39:01 <o3> i was playing around with scoped typed variables (ghc extension), but they didn't seem to do it
06:39:48 <Marvin--> I guess a hack would be to add an unused function that takes two c:s and you pass it an argument and something else
06:40:43 <o3> something else of the same type, you mean?
06:41:57 <Marvin--> yes
06:42:20 <o3> the problem is that the type of my foo function is :: MyTypeClass c => c; i.e. it takes in no arguments, and i deduce the exact type by forcing the type with 'foo :: MyInstance1' or 'foo :: MyInstance2' when it's used
06:43:43 <o3> so i can't actually pass it an argument of the same type because i don't know what type i'm dealing with.  the only thing i know is that the type variable c will be fixed, and i want to pass that information to the function i'm calling in foo so i don't get a free type variable
06:46:26 <Marvin--> ah
06:48:53 <o3> mailing list time, i think
06:49:11 <o3> or maybe i'll just wait for Chilli :)
06:49:22 * Marvin-- ponders if something could be done with cast ;)
06:58:09 <SyntaxPolice> good morning #haskell :)
06:58:45 <o3> Marvin--: err, cast?
07:00:42 <Marvin--> o3: never mind :)
07:01:03 <o3> Marvin--: sounds like it should be called unsafeCast ;)
07:01:17 <Marvin--> o3: there is an unsafeCoerce
07:01:33 <Marvin--> o3: using Typeable, a reasonably type safe cast can be implemented
07:02:11 <ejt> is there a simple symbolic math package for haskell ?
07:07:54 <alanl__> no really :-(
07:21:25 <alanl__> whats the eqivilent of done in H98?
07:21:46 <Igloo> done?
07:22:15 <alanl__> apparently its the donothing command
07:22:22 <alanl__> in Haskell 1.3
07:23:33 <Igloo> What type does it have?
07:23:52 <esap> how about the hWaitForInput?
07:24:33 <alanl__> don't worry....i found it ...it was just return ()
07:24:42 * alanl__ hits myself
07:25:07 <esap> oh, it was not supposed to _wait_ while doing nothing :-)
07:25:25 <alanl__> does anyone know what the * means when I load a module in GHCi?
07:25:45 <Marvin--> kinds
07:26:00 <Marvin--> oh, wait, you mean the Foo*> ?
07:26:05 <Marvin--> er, *Foo>
07:26:28 <alanl__> yes
07:26:57 <Marvin--> hrrm, I have known that, but I forgot
07:31:48 <kosmikus> I think it means that the module is interpreted
07:33:29 <kosmikus> correction (but I am still not sure): the * means that all entities of the module are in scope, not just the ones declared for export; the * only works for interpreted modules
07:34:12 <alanl__> the ghc manual seems to concur on that..
07:36:10 <esap> I guess it's not possible to partially apply a function type constructor?
07:36:38 <jak> who not
07:36:41 <jak> why not? 
07:36:52 <kosmikus> yes, should be possible
07:37:26 <esap> Hmm... I tried to define it as an instance of a class and it didn't work (parse errors).
07:37:40 <esap> instance ExceptionMonad (a ->) where ...
07:37:51 <Marvin--> I think you need  ((->) a)
07:38:02 <esap> Also tried that one, same result.
07:38:05 <Marvin--> hrm
07:38:16 <kosmikus> it's not Haskell 98
07:38:30 <kosmikus> I mean the instance declaration
07:38:46 <esap> oh actually, was not the same result :-)
07:39:13 <esap> it said "variable not in scope: a" hmm.. I guess that was another problem.
07:40:36 <esap> so got it fixed, had a stray reference to 'a' from the definition of the methods.
07:41:35 <Marvin--> heh
08:22:33 <alanl__> does anyone know of a good tutorial for monads?
08:44:54 <Smerdyakov> I'm sure HaWiki references some. Did you look?
08:50:28 <Marvin--> alanl__: my favourite is probably  http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm
08:52:26 <Akasha> Marvin--: funky! :-)
08:53:06 <n0^1>  "what the hell are monads"
08:53:20 <Marvin--> yeah, wth is good too
08:53:23 <n0^1> and the beginning of "yet another tutorial"
08:53:45 <n0^1> "yet another haskell tutorial", sorry
08:54:49 <Akasha> heh
08:55:00 <Akasha> "Monads for the Dazed and Confused"
10:33:31 <tmoertel> @web1913 tuple
10:33:34 <lambdabot> No match for "tuple".
10:33:40 <tmoertel> @all-dicts tuple
10:33:41 <lambdabot> *** "TUPLE" foldoc "The Free On-line Dictionary of Computing (09 FEB 02)"
10:33:41 <lambdabot> TUPLE
10:33:41 <lambdabot>    Toyohashi University Parallel Lisp Environment.  A parallel
10:33:42 <lambdabot>    Lisp based on KCL.
10:33:46 <lambdabot>    ["Memory Management and Garbage Collection of an Extended
10:33:48 <lambdabot>    Common Lisp System for Massively Parallel SIMD Architecture",
10:33:50 <lambdabot> [there's @more]
10:33:55 <tmoertel> @more
10:33:55 <lambdabot>    Taiichi Yuasa, in Memory Management, IWMM92, Springer 1992,
10:33:55 <lambdabot>    490-507].
10:33:58 <lambdabot>    (1994-11-08)
10:34:07 <lambdabot> *** "tuple" foldoc "The Free On-line Dictionary of Computing (09 FEB 02)"
10:34:08 <lambdabot> tuple
10:34:10 <lambdabot> [there's @more]
10:34:11 <tmoertel> @more
10:34:15 <lambdabot>    In {functional language}s, a data object containing two or
10:34:16 <lambdabot>    more components.  Also known as a product type or pair,
10:34:18 <lambdabot>    triple, quad, etc.  Tuples of different sizes have different
10:34:20 <lambdabot>    types, in contrast to lists where the type is independent of
10:34:22 <lambdabot>    the length.  The components of a tuple may be of different
10:34:24 <lambdabot>    types whereas all elements of a list have the same type.
10:34:26 <lambdabot>    Examples of tuples in {Haskell} notation are (1,2),
10:34:28 <lambdabot>    ("Tuple",True), (w,(x,y),z).  The degenerate tuple with zero
10:34:30 <lambdabot> [there's @more]
10:34:31 <tmoertel> @more
10:34:32 <lambdabot>    components, written (), is known as the unit type since it has
10:34:34 <lambdabot>    only one possible value which is also written ().
10:34:38 <lambdabot>    The implementation of tuples in a language may be either
10:34:40 <lambdabot>    "{lifted}" or not.  If tuples are lifted then (bottom,bottom)
10:34:42 <lambdabot>    /= bottom and the evaluation of a tuple may fail to terminate.
10:34:44 <lambdabot>    E.g. in Haskell:
10:34:48 <lambdabot>    	f (x,y) = 1    -->    f bottom = bottom
10:34:50 <lambdabot> [there's @more]
10:34:54 <tmoertel> @more
10:34:54 <lambdabot>    			      f (bottom,bottom) = 1
10:34:56 <lambdabot>    With lifted tuples, a tuple pattern is refutable.  Thus in
10:34:58 <lambdabot>    Haskell, {pattern matching} on tuples is the same as pattern
10:35:00 <lambdabot>    matching on types with multiple constructors ({algebraic data
10:35:02 <lambdabot>    type}s) - the expression being matched is evaluated as far as
10:35:04 <lambdabot>    the top level constructor, even though, in the case of tuples,
10:35:06 <lambdabot>    there is only one possible constructor for a given type.
10:35:10 <lambdabot> [there's @more]
10:35:13 <Marvin--> tmoertel: hey, stop wasting my bandwidth ;)
10:35:28 <tmoertel> Marvin--: are you running this instance of lambdabot ?
10:35:56 <Marvin--> tmoertel: no, but I'm getting a lot of output :) it communicates perfectly well over /msg
10:36:14 <tmoertel> Marvin--:  right you are. sorry
10:40:12 <o3> wow, 3 replies in 10 minutes
10:40:19 <o3> rock
10:41:41 <ham[chan]> hiho
10:42:52 <ham[chan]> how can i model an 'if' like in sequential programming languages in haskell without using the keywork if in the function right away?
10:43:13 <tmoertel> why would you want to do that ?
10:43:44 <ham[chan]> cause i try to think what an if mathematecally is
10:43:54 <mattam> hi!
10:44:50 <ham[chan]> or is if also an atomic operation like + in math?
10:44:54 <tmoertel> ham[chan]: take a look at section 3.6 of the Haskell 98 Report: http://www.haskell.org/onlinereport/exps.html
10:45:16 <ham[chan]> k thx
10:45:16 <mattam> i'm searching for the documentation of haskell-mode indent module for emacs. Apparently Guy Lapalme (the author) wrote a paper on it but I can't find it
10:47:32 <ham[chan]> and how would i do that if in a category?
10:47:49 <mattam> or maybe someone could explain me how it works ?
10:48:02 <wli> do it in the category of allegories? =)
10:48:29 <ham[chan]> i meant 1. the if has to be evaled as a functor probaply and at the time you are at the object \
10:48:36 <ham[chan]> allegories?
10:49:18 <tmoertel> mattam: Have your tried "C-h m" from within haskell-mode ?
10:50:28 <mattam> nope, thanx 
10:51:31 <tmoertel> mattam: see http://www.iro.umontreal.ca/~lapalme/layout/
10:52:20 <mattam> there is no documentation there just the abstract
10:52:42 <tmoertel> true, indeed
11:10:00 <tipo_discreto> hello, just a question:
11:11:18 <tipo_discreto> how would a pure functional language such as Haskell resolve a typical dynamic programming problem without exponential time execution?
11:11:43 <tipo_discreto> i'm not into functional programming, i'm curious
11:12:23 <Jolta> dynamic programming problem?
11:12:29 <Jolta> please explain
11:12:32 <Riastradh> You'll need to be -MUCH- more specific.
11:12:41 <tipo_discreto> like the typical coins problem
11:13:14 <tipo_discreto> you know, problems that are naturally expressed as recursive problems, but that take exponential time to resolve without using matrices
11:14:44 <Igloo> Laziness would be a win there
11:14:49 <Riastradh> Um, you could always transform it into CPS, which is easily done explicitly with any functional language or implicitly with monads.
11:15:03 <tipo_discreto> CPS?
11:15:07 <Igloo> Just put the definition of each cell in an array, ask for the final answer cell and it should all work out nicely
11:15:09 <Riastradh> Continuation-Passing Style.
11:15:38 <tipo_discreto> well, i think i'll need a book about functional programming?
11:15:56 <tipo_discreto> Igloo, that is interesting
11:16:13 <tipo_discreto> very interesting!
11:18:02 <tipo_discreto> but i thought that pure functional languages don't admit assignment
11:18:29 <Riastradh> They don't.
11:18:56 <tipo_discreto> so what about cells and arrays?
11:18:57 <delYsid> ahhhhh, moveLine in Move.hs is CPS, didnt even realize that
11:19:07 <Riastradh> What about them?
11:19:22 <tipo_discreto> you can't do what Igloo says
11:19:30 <Riastradh> Why not?
11:19:56 <tipo_discreto> so you can create an array with an implicit definition for each cell?
11:20:38 <tipo_discreto> but still you need a command, i just don't get the point
11:20:46 <Jolta> I think tipo_discreto needs an example. Anyone have one?
11:21:04 * Riastradh is really confused by tipo_discreto's vagueness; specification, please!
11:21:12 <Igloo> You want something like   let x = listArray [ (i, f i) | i <- indicies ] in x ! (bottom, right) where f is defined in terms of x ! ...
11:21:49 <tipo_discreto> exactly
11:22:11 <tipo_discreto> thanks Igloo
11:22:48 <tipo_discreto> well, i feel better now, hehe, thanks a lot for your time :)
11:30:10 <Jolta> Hm. he was easily satisfied.
11:33:12 <Riastradh> Igloo, you don't need a lazy language to do that.
11:33:30 <Riastradh> Oh, wait, er, maybe you do.
11:33:43 <Riastradh> I realised the -moment- I hit 'return' there that you do.  Grr.
11:33:56 * Riastradh waves his fist at the universe.
11:33:59 <Igloo> Well, laziness probably isn't actually essential
11:34:28 <Igloo> It means you don't have to worry about the order, and some problems may not compute everything
11:34:36 <Igloo> The essential part is that the work only gets done once
11:35:30 <Igloo> I can't think of the name of the updating-the-suspension-location-with-the-value idea, though
11:37:06 * Igloo goes to cook
11:37:36 * pesco had cooked ioctl for dinner
11:38:12 * Smerdyakov has cooked Unix for dinner.
11:38:35 <pesco> I like my Unix frozen.
11:38:41 <pesco> And my sockets raw.
11:49:46 <Jolta> > >Cronflakes.
11:49:46 <Jolta> > Part of your regularly scheduled breakfast.
11:49:46 <Jolta> Ack!  I've been Unixed, and I can't get out.
11:49:46 <Jolta>           -- Jamie Bowden & Mike Kozlowski
11:53:18 <tic> hehe
12:25:53 <Jolta> hm, things are slow.
12:25:59 <Jolta> random quote:
12:26:02 <Jolta> "Recursion: see 'Recursion'" is a very old joke. It's also a stinking lie.
12:26:02 <Jolta> The correct definition is: Recursion: If you know what recursion is, just
12:26:02 <Jolta> remember the answer. Otherwise, locate someone who is standing closer to
12:26:05 <Jolta> Douglas Hofstadter than you are, and ask him/her what recursion is.
12:26:05 <Jolta> 	-Andrew Plotkin
12:27:56 <wli> that's silly
12:27:58 <Smerdyakov> Tehe
12:28:51 <Jolta> yep
12:29:00 <Jolta> tha's the point, you know
12:29:32 <Jolta> it's also correct, in a silly fashion
12:30:11 <wli> in a binding group where f_1 x_1,1 ... x_1,n = E_1 ; f_i x_i,1 ... x_i,n = E_i ... make a graph with vertices at the f_i and arcs between f_i and f_j if f_j appears as a free variable in E_i; if the graph is not acyclic it's recursive
12:31:03 <Smerdyakov> OK, wli.
12:31:37 <wli> s/between f_i and f_j/from f_i to f_j/
12:31:53 <Smerdyakov> OK, wli.
12:32:28 <Smerdyakov> I think your insistence that the bound things be functions is needlessly complicating.
12:33:04 <Smerdyakov> I guess you could just make n 0, but you could just as well leave out the parameters!
12:33:30 * Verbed suggests #trivia
12:34:06 * Smerdyakov suggests Verbed.
12:34:58 <Verbed> I suppose we need #trivia to suggest Smerdyakov now.
12:35:21 <Verbed> The IRC protocol should take situations like this into account :)
12:35:42 <Smerdyakov> I bet your IRC client wouldn't balk if the server told it that #trivia had sent to this channel.
12:35:54 <wli> f = ([0,1]++) . zipWith (+) f $ tail f
12:37:09 <Verbed> Smerdyakov: Agreed, the # prefix is probably just a convention that most servers follow.
12:37:41 <wli> no, it's specified; # prefixes a globally visible channel, & prefixes a channel only visible on one server, and so no
12:38:05 <Verbed> Specified in what?
12:38:17 <wli> IRC RFC's
12:40:22 <Smerdyakov> Yes, but do you think your client would take the time to verify server messages like that?
12:40:45 <wli> to properly implement the protocol yes
12:40:58 <Verbed> Why would a client need to verify it?
12:45:57 <Smerdyakov> wli, the protocol prescribes error responses from the client for messages from channels?
12:46:05 <wli> yes
12:46:16 <Smerdyakov> How odd.
12:46:19 <wli> there are error returns possible for every message a client can send
12:46:23 <Smerdyakov> Nono
12:46:27 <Smerdyakov> Messages that a SERVER can send.
12:46:43 <wli> no not from clients
12:46:44 <Smerdyakov> If a SERVER tells you that #trivia has sent "hello" to #haskell, I don't recall reading about a defined behavior.
12:46:54 <Smerdyakov> So... "<wli> to properly implement the protocol yes" doesn't seem to be right.
12:46:57 <wli> clients don't respond to such messages
12:47:09 <wli> I was answering what appeared to be a different question
12:47:13 <Smerdyakov> I know.... I've written IRC bots like everyone else :P
12:47:23 <esap> Hmm.. Is there some GHC or H98 library that defines instance for Monad ((->) a)?
12:47:47 <wli> MonadReader
12:48:02 <esap> wli: ok thanks.
12:53:54 <wli> hmm what would an arbitrary 3-term recurrence be
12:56:48 <wli> well ([a0,a1]++) would be the first part
12:56:53 <wli> if a(n+1) = q*a(n) + r*a(n-1) + s then instead of (+) you'd have
12:57:34 <wli> (\prev curr -> q*curr + r*prev + s)
12:58:08 <wli> so for a(n+1) = 3*a(n) + 2*a(n-1) + 1 with a(0) = 1 and a(1) = 2
12:58:50 <wli> Prelude> let f = ([1,2]++) . zipWith (\prev curr -> 3*curr + 2*prev + 1) f $ tail f in take 10 f
12:58:50 <wli> [1,2,9,32,115,410,1461,5204,18535,66014]
12:58:57 <wli> to generalize:
13:02:13 <wli> Prelude> let f q r s x0 x1 = let xs = f q r s x0 x1 in ([x0,x1]++) . zipWith (\prev curr -> q*curr + r*prev + s) xs $ tail xs in take 10 $ f 3 2 1 1 2
13:03:09 <wli> could be useful for function series expansion via Gaussian quadrature
13:08:33 <wli> an arbitrary n-term recurrence would be interesting
13:29:30 <wli> Prelude> let { transpose [] = [] ; transpose [x] = [x] ; transpose (x:xs) = (head x : map head xs) : (tail x : map tail xs) } in let f coefs vals = let xs = f coefs vals in vals ++ map sum (transpose (take (length coefs - 1) (tail $ List.inits xs))) in ()
13:29:38 <wli> but that transpose isn't lazy enough
13:36:22 <wli> let { transpose [] = [] ; transpose [x] = [x] ; transpose (x:xs) = (head x : map head xs) : (tail x : map tail xs) } in let f coefs vals = let xs = f coefs vals in vals ++ map sum (transpose (take (length coefs - 1) (map (flip drop $ xs) [0..]))) in take 10 $ f [1,1,0] [0,1]
13:36:29 <wli> [0,1,1,Interrupted.
13:43:58 <wli> Prelude> let transpose xs = map head xs : transpose (map tail xs) in let f coefs vals = let xs = f coefs vals in vals ++ map ((+ last coefs) . sum) (map (zipWith (*) coefs) $ transpose (take (length coefs - 1) (map (flip drop $ xs) [0..]))) in take 10 $ f [1,1,0] [0,1]                                               
13:43:59 <wli> [0,1,1,2,3,5,8,13,21,34]
13:47:57 <wli> something's off
13:49:59 <wli> zipWith (*) coefs is off
13:55:03 <wli> Prelude> let { transpose [] = [] ; transpose [x] = [x] ; transpose xs = map head xs : transpose (map tail xs) } in let f coefs vals = let xs = f coefs vals in vals ++ map ((+ last coefs) . sum) (map (zipWith (*) (tail $ reverse coefs)) $ transpose (take (length coefs - 1) (map (flip drop $ xs) [0..]))) in take 10 $ f [3,2,1] [1,2]
13:55:04 <wli> [1,2,9,32,115,410,1461,5204,18535,66014]
13:55:16 <wli> Prelude> let f q r s x0 x1 = let xs = f q r s x0 x1 in ([x0,x1]++) . zipWith (\prev curr -> q*curr + r*prev + s) xs $ tail xs in take 10 $ f 3 2 1 1 2          [1,2,9,32,115,410,1461,5204,18535,66014]
13:55:23 <wli> there we go
13:55:27 <wli> arbitrary n-term recurrence
14:05:36 <wli> okay, looks like this now:
14:05:37 <wli> recurrence coefs vals = 
14:05:37 <wli>                 vals ++ [last coefs + sum zs | zs <- map coefSum $ transpose ys]
14:05:37 <wli>         where 
14:05:37 <wli>                 xs = f coefs vals
14:05:37 <wli>                 n = length coefs - 1
14:05:38 <wli>                 coefSum = (last coefs +) . sum . map (zipWith (*) coefs)
14:05:40 <wli>                 ys = take n [drop k xs | k <- [0..]]
14:05:42 <wli>                 transpose xs = map head xs : transpose (map tail xs)
14:13:55 <wli> swap = uncurry . flip . curry $ id
14:13:58 <wli> hmm
14:14:03 <wli> how pointless can it be? =)
14:18:04 <wli> okay got a guard to make sure length coefs /= length vals + 1 is flagged properly
14:23:03 <wli> changed the calling conventions
14:43:24 <tic> hey guys
14:43:29 <tic> anyone alive?
14:43:45 <tic> hm, nevermind.
14:44:05 * esap is almost asleep.
14:47:00 <tic> is there a good find :: [a] -> a -> a?
14:47:07 <tic> (find an item in a list)
14:48:40 <tic> hm.. List has one
15:01:49 <tic> but
15:01:56 <tic> now I could need some hep
15:01:56 <tic> help
15:02:01 <tic> I want to do something like:
15:02:26 <tic> filter (fst . == "moo") [("moo",1), ("boing", 2")]
15:02:40 <tic> but I don't know the proper syntax for adding together fst and ==
15:03:00 <Riastradh> (fst . (=="moo")) maybe?
15:03:12 <Igloo_> Other way round
15:03:21 <Riastradh> Oh, yeah.
15:03:42 <Igloo_> You might actually want   lookup "moo" [("moo",1), ("boing", 2")]   though
15:03:49 <tic> ah
15:03:55 <tic> what does lookup do?
15:04:00 <tic> I use find at the moment.
15:04:10 <Igloo_> @type find
15:04:22 <tic> hrm?
15:04:22 <Riastradh> @type lookup
15:04:24 <lambdabot> lookup :: Eq a => a -> [(a,b)] -> Maybe b
15:04:31 <tic> ah
15:04:33 <tic> that's even nicer.
15:04:33 <tic> thanks
15:04:43 <tic> where's lookup defined?
15:04:44 <tic> list?
15:04:49 <Riastradh> The prelude, I assume.
15:04:52 <Riastradh> @prelude lookup
15:04:53 <lambdabot> *** "lookup" prelude "Haskell Standard Prelude Dictionary": text follows
15:04:53 <lambdabot> lookup
15:04:53 <lambdabot>   lookup ::  Eq a => a -> [(a,b)] -> Maybe b
15:04:53 <lambdabot>   lookup k []       = Nothing
15:04:54 <lambdabot>   lookup k ((x,y):xys)
15:04:56 <lambdabot>         | k==x      = Just y
15:04:57 <tic> nice
15:04:58 <lambdabot>         | otherwise = lookup k xys
15:06:33 <tic> schweet.  Thanks a lot.
15:06:55 <wli> lookup k xs = case filter ((==k) . fst) xs of { [] -> Nothing ; (x:_) -> Just . snd $ x }
15:41:28 * esap would usually not use '.' and '$' in the same expression without parenthesis. Maybe I should learn their precedence :-)
15:41:46 * Riastradh used $ way too much for a while.
15:42:00 <Riastradh> Although in that case I would use . and $.
15:42:16 <Riastradh> Er, no, I wouldn't.
15:42:24 <Riastradh> I'd use parentheses there -- Just (snd x).
15:43:01 <Riastradh> But if it were something like:  a . b . c $ e  then I would write it like that, not with parentheses.
16:36:58 <Riastradh> @yow
16:36:58 <lambdabot> Look into my eyes and try to forget that you have a Macy's charge card!
16:39:05 <jewel> what is the signficance of "Just y"
16:39:36 <Riastradh> 'Significance?'
16:39:39 <Riastradh> Rephrase, please.
16:39:50 <jewel> why is "Just" there?
16:40:00 <Riastradh> Because that's what the value is -- 'Just y'.
16:40:04 <Igloo> It's a constructor
16:40:05 <Riastradh> 'Just y' is not the same as 'y'.
16:40:07 <Riastradh> Zigackly.
16:40:09 <Igloo> Makes a Maybe a
16:40:24 <Darius> @type Just
16:40:24 <lambdabot> Just :: a -> Maybe a
16:40:33 <jewel> Right
16:41:09 <Riastradh> @type Nothing
16:41:10 <lambdabot> Nothing :: Maybe a
16:41:13 <jewel> And the code that is calling the lookup method, it needs to accomodate this maybe-ness ..., it has to handle the Nothing case?
16:41:21 <Riastradh> Yes.
18:13:54 <Riastradh> Whoa, new graphic on haskell.org.
18:27:14 <witten> cool
18:36:03 <esap> Hmm.. what do you think about the following interface, could that work better with arrows than current monads? class StrictMonad a req act where { returnS :: a (req result) (cmd result) ; (>>>=) :: cmd input -> (a (req input) (cmd output)) -> cmd output }
18:43:22 <Riastradh> Er, why not just use arrows?
18:45:14 <esap> Because arrows do not explicitly represent 'req' or 'cmd', and you want some operations to manipulate those as well.
18:46:18 <esap> The idea behind that interface is that you can think that as an interface to a kind of "natural transformation" n: req -> cmd
18:48:32 <esap> hmm. I think it should actually read "class StrictMonad a req cmd where ..."
19:25:50 <alanl__> ::/quit
19:51:08 * wli ponders a line buffering API
19:52:26 <wli> (for file storage, not terminals)
19:53:32 <wli> well
19:53:37 <wli> there'd be a block buffering API there, too
19:53:58 <wli> line -> block -> writeout
19:54:06 <wli> line <- block <- readin
19:57:20 <wli> keep a line index around
20:00:27 <wli> 16KB blocks sound perfect
22:10:09 <jdrake_> how fast is haskell? Say when comparing it with graphical or video operations in a regular C compiler? 
22:10:56 <wli> property of compilers, not languages
22:12:15 <jdrake_> the concern of mine, is if it would be worth learning about haskell to do what I want to do and not end up with a slow program at the same time
22:12:35 <wli> depends on what you're doing
22:12:55 <wli> Haskell is the fastest when the compiler is able to prove important things about the program
22:13:10 <jdrake_> i am looking at doing things with video files
22:13:38 <wli> current compilers don't do anything special for that
22:13:51 <jdrake_> for example, taking an avi file and reencoding it to another form
22:13:56 <wli> it's mostly data structure -related stuff where the compiler can prove interesting properties
22:14:03 <jdrake_> or apply a filter onto it
22:14:22 <jdrake_> an avi file is definately a data structure related item
22:14:25 <wli> aside from looking sexy as source haskell doesn't do anything special
22:14:33 <wli> not quite as I mean it
22:14:48 <jdrake_> are there (free) compilers that compile to native code?
22:14:53 <wli> data structure manipulations, say, where the compiler can prove large things are equal
22:14:55 <wli> yes
22:14:56 <wli> three
22:15:06 <wli> nhc, ghc, and hbc
22:15:22 <jdrake_> any that happen to convert directly to C or use similar to a gcc backend
22:15:35 <wli> ghc has an option to do that
22:15:41 <wli> nhc I'm not sure about
22:15:47 <wli> hbc does not
22:15:55 <jdrake_> i am looking to compile to ppc
22:15:57 <wli> I think nhc may work like that all the time now that I think of it
22:16:40 <o3> jdrake_: linux/ppc?
22:16:44 <jdrake_> nope
22:16:48 <wli> I basically use it for stuff where I want to write code quickly and not barf my guts out about the way it looks
22:16:53 <o3> which OS?
22:16:58 <jdrake_> looking on the site it looks like 'nhc98' outputs to what I need
22:16:59 <jdrake_> mac
22:17:02 <o3> ghc is the most optimising compiler around
22:17:19 <o3> it's available for mac os x
22:17:27 <o3> (haskell compiler, that is :)
22:17:28 <jdrake_> that might be the best then
22:18:43 <jdrake_> how long would it take on average to learn how to use haskell?
22:19:15 <o3> jdrake_: it really depends on what you want to do.  if you want blistering speed and you're working on some very innately hard algorithms, haskell is a great choice
22:19:44 <o3> jdrake_: if the stuff you want to do is more mundane and are willing to give up haskell's expressiveness, i always vouch for C/C++
22:19:51 <jdrake_> maybe the better question is what does haskell not good at
22:19:53 <wli> I already knew SML and Lisp so it was pretty much instantaneous
22:20:25 <jdrake_> the first look at the document with quicksort algorithm kind of lost me on first glance
22:20:27 <o3> jdrake_: well, it takes a while to learn it
22:20:30 <wli> manipulating raw virtualspace
22:21:01 <o3> part of the problem is that there aren't many good tutorials about it if you're an imperative-style prorgammer
22:21:22 <o3> and then it takes longer to to understand it well enough to really coax the speed out of it that you're looking for
22:21:26 <jdrake_> i think imperatively
22:21:35 <wli> then you're in trouble
22:21:49 <o3> jdrake_: if your avi program is a hobby, use haskell, it'll be fun :)
22:21:57 <o3> and rewarding, too
22:21:59 <jdrake_> when I want to do something in programming, I can literally visualize the solution in an imperative way
22:22:29 <jdrake_> i am not a professional programmer, and I have decided I do not want to be one (where are the jobs?)
22:24:15 <o3> well, learning functional programming is very useful -- you'll start finding that your imperative programs will start to be written in a functional style after you learn it
22:25:07 <jdrake_> i once started making this xml parser (it was a short lived project) that I was going out of my way to do recursive function calls instead of loops. I actually did get some of them doing it too
22:25:43 <wli> probably not a good idea in C
22:25:57 <wli> (or C++)
22:26:02 <jdrake_> on the about haskell page, I sort of understand what it is saying but it still seems very alien
22:26:27 <jdrake_> it looks more like something I would see in math class than in a programming class
22:26:34 <wli> yep
22:27:31 <jdrake_> with those two examples, the C quicksort and the haskell, which one would probably be faster?
22:28:34 <wli> depends
22:29:10 <wli> neither ghc, nhc, nor hbc (well, that's actually for a fairly old version of haskell) could beat gcc for that (AFAICT)
22:31:44 <o3> jdrake_: i like to think of it this way
22:31:48 <o3> a computer is a state machine
22:32:13 <o3> if you want absolute, 100%, no-holds-barred sacrifice-everything-else speed, nothing is going to give you better performance than hand-tuned c/asm
22:32:33 <o3> ... at least -- if the problem you're tackling is easy to understand
22:33:02 <o3> where haskell really gets a speed advantage over imperative langauges is on really hard problems, which innately hard algorithms
22:33:06 <jdrake_> it should be relatively easy to understand until the gritty parts come in (like how certain filters work)
22:33:09 <o3> and also in parallelisation
22:33:37 <jdrake_> does it do this parallelism automatically?
22:34:14 <o3> e.g. we had a first year student at our uni write a program to do optimal travelling salesman stuff using a fairly complex algorithm, and it ran under 2 seconds
22:34:31 <o3> it would have been absolute hell to try to program that in c (or in an imperative language)
22:34:55 <jdrake_> i am not framiliar with the details of the travelling salesman, only hearing of it
22:35:30 <o3> so when the problem gets too hard, haskell allows you to express the algorithm better, and then the compiler can take over
22:35:32 <wli> most of the speed that's "lost" is because disgusting representation twiddling crap that has no serious value in the general case
22:35:44 <dennisb> of course haskell is always going to be slower then C/Asm, but so is practically all other languages. Haskell is still very fast, people are programming Perl, Python and other languages that is way slower
22:35:49 <wli> s/because/because of/
22:36:07 <o3> jdrake_: some parallelisation is done automatically, depending on what compiler you are using
22:36:10 <wli> I use Haskell for scripting too.
22:36:23 <o3> but functional programming lends itself to parallisation better than imperative does (e.g. witness the success of erlang)
22:36:32 <jdrake_> the other option i would have is ruby, but I know from my python experience with opengl that ruby wouldn't be very good
22:37:00 <wli> I'd love to see a balls-out instruction-level parallel Haskell compiler for ia64
22:37:12 <wli> 128 registers
22:37:12 <o3> jdrake_: unless you absolutely _require_ 100% speed (which you almost never do these days, unless you're doing systems work), i'd say c is a bad choice
22:37:26 <wli> o3: that's actually not for speed
22:37:50 <o3> true
22:37:59 <dennisb> As I see it speed is no problem for haskell, the biggest problem is that there is some bindings to libraries missing
22:38:07 <wli> o3: that's for atomicity, extremely strict control over memory usage, routine manipulation of raw memory, and primitives for privileged instructions
22:38:15 <o3> although i was trrying to say that systems work generally requires more speed than your average desktop app :)
22:38:18 <jdrake_> o3, the reason why I wouldn't want to do it in C (actually objective C specifically) is because of the problems (some enumerated in the about haskell document)
22:39:12 <o3> well, haskell (with ghc) is fast enough, put it that way
22:39:20 <wli> o3: systems programming is _very_ highly constrained; a language implementation needs facilities and must avoid certain behaviors
22:39:26 <o3> it's pretty rare you'll have to sit down and hand-tweak things
22:39:54 <jdrake_> but I can always write some C stuff if I need to plug it in somewhere
22:39:57 <o3> wli: nod, i completely agree.  you're preaching to the choir :)
22:40:00 <wli> bounded stack and critical sections where it's not possible to block waiting for memory are the two largest ones that higher-level languages can't cope with.
22:40:32 <dennisb> for low level video stuff ?ot even C is enough, you have to program assembler to get speed out of MMX/SSE and whatever it's called
22:41:11 <wli> dennisb: those could in principle be generated by a compiler
22:41:20 <dennisb> could but isn't
22:41:27 <wli> yes in principle
22:41:35 <jdrake_> my processor doesn't use MMX or SSE or any other vectorizing unit 
22:42:32 <o3> well, i don't think ghc will have support for ppc altivec anytime soon :)
22:43:23 <jdrake_> i searched for haskell on chapters.ca and the only book in the list that was any bit related was a 1988 book
22:43:35 <wli> jdrake: try amazon.com
22:44:33 <jdrake_> amazon isn't any good, i am not going to pay duty on any books i order
22:45:57 <wli> amazon.ca?
22:46:00 <o3> jdrake_: if you wait a month, my objective-c/haskell binding should be finished by then :)
22:46:13 <jdrake_> i found this one: "The Haskell School of Expression: Learning Functional Programming through Multimedia "  for $33.56 (sale)cdn
22:46:22 <jdrake_> o3, i am nto in any hurry :-)
22:48:07 <o3> well, it better be finished by then, or i'm going to get a rather bad thesis mark
22:49:16 <jdrake_> well i will look at stuff online then think about getting a book
22:51:11 <jdrake_> does haskell do anything with objects?
22:53:06 <o3> jdrake_: it's not OO, if that's what you mean
22:53:47 <jdrake_> say with your objective-c binding, how would you do stuff with the objc objects
22:55:06 <o3> you just send objects messages, e.g. with a msgSend function "msgSend someObject (theMessage)" instead of [someObject theMessage]
22:57:15 <jdrake_> so you might as well be calling the objective c runtime itself?
22:57:53 <o3> that's what it does
22:58:01 <o3> unfortunately, that's the easy bit :)
22:58:09 <jdrake_> how about [mydictionary setObject: @"hello" forKey: @"helloagain"]
22:58:35 <jdrake_> (being that it is a specific example that doesn't actually fit very well normally in other languages
22:59:28 <o3> at the moment, that would look something like "mydictionary # setObject ("hello", "helloagain")" (or maybe setObject_forKey instad of just setObject, which is the way the python/lua/ruby objc bindings work)
23:00:21 <jdrake_> interesting
23:00:41 <o3> although when haskell gets a new records implementation, you should be able to write "mydictionary # setObject "hello" { forkey="helloagain" }"
23:01:18 <jdrake_> how would one program a gui in haskell? gui doesn't exactly seem like a math equation to me
23:03:40 <o3> you can do things imperatively in haskell using something called an IO type
23:04:17 <Akasha> jdrake_: there's gtkhs
23:06:06 <jdrake_> does ghc come with an immediate mode where I can input things into it sort of like irb from ruby or python?
23:06:16 <jdrake_> i guess ghci would do that
23:07:55 <Akasha> you mean an interpreter? 
23:08:01 <Akasha> there's ghci/hugs
23:08:29 <jdrake_> yes, something that I can put in some code and test it without making a program for it (which I don't know how to do yet)
23:09:12 <Akasha> jdrake_: www.haskell.org ...there's a section on tools and stuff that you might be interested in looking at
