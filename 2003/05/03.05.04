00:00:51 <seth_> Never mind, just a build sequence problem.
00:53:13 <archie_sihir> where can i find a hands on tutorial for nhc98 ?
01:09:51 <delYsid> hmm, the owner of haskell.de would like to get rid of it
01:10:59 <archie_sihir> delYsid: get rid of what ?
01:11:09 <delYsid> the domain
01:11:35 <archie_sihir> hmmm
01:33:34 <seth_> I'm having trouble figuring out how to code a call to emptyFM (Data.FiniteMap)
01:43:14 <delYsid> hmm?
01:44:39 <delYsid> emptyFM :: FiniteMap key elt
01:48:22 <seth_> delYsid: Yes, I saw that.  My problem was in a different part, I misinterpreted the message.  It is working, or at least it is compiling, now.  :)
02:47:23 <Arnia> shapr: You about?
03:03:23 <seth_> Anyone know an easy way to display a thread id?  The docs list a Show instance for it, but the compiler doesn't like my attempt to show it.
03:06:39 <seth_> never mind, it was IO threadid and I had to get it to threadid.
03:06:56 <elmex> hm, wait, that is done by >>= 
03:07:06 <elmex> >>= \id -> isn't it?
03:07:12 <seth_> right
03:07:28 <seth_> myThreadId >>= \id -> putStrLn (show tid)            for example
03:08:06 <Arnia> Have something against do notation? ;)
03:08:23 <elmex> Arnia: hm
03:08:23 <seth_> I find the combinators easier to follow, although I think I'm the only one.
03:08:35 <delYsid> me too!
03:08:46 * delYsid dislikes do-notation, its confusing, and hiding the real thing
03:08:47 <elmex> well, the do notation doesn't make it obvious that there are actions
03:09:03 <seth_> anyway, what's wrong with the combinator notation?
03:09:20 <elmex> seth_: maybe some people dislike writing >> and that all time
03:09:31 <seth_> I find it easier to unravel the types, and respond to the compiler's messages, with the combinators because as delYsid says it makes things explicit.
03:09:54 <seth_> Maybe when I understand things better I'll have fewer problems using do
03:10:09 <Arnia> I find do easier to read... I can infer the combinators in my head with no problems.
03:11:07 <seth_> I'm not facile enough yet with the combinators to see it quickly in my head.
03:11:35 <elmex> well, do notation is still easy...
03:11:55 <seth_> I'm not telling anyone not to use do
03:12:04 <seth_> Not that it would matter if I did  :)
03:12:25 <elmex> i started yesterday with all that IO stuff and i don't care about do or >>. only that i like things more explicit with >>
03:24:09 <elmex> can i invoke ghci like a normal interpreter and tell it to run main ?
03:24:41 <seth_> elmex: yes
03:24:47 <seth_> or do you mean automatically run main
03:24:54 <seth_> I think so but I'm not 100% sure.
03:25:14 <seth_> You can point it at a script and let that script do nothing but run main
03:25:15 <elmex> yes, run main
03:25:31 <elmex> hm, ok... but i guess, it's not vry fast, is it?
03:25:40 <seth_> compared to what?
03:31:46 <elmex> hmm, compared to compiled version?
03:32:01 <elmex> is building ghc by hand a clever idea?
03:36:17 <seth_> I build ghc, but I just install the binaries, download the source, and build the source.  Nothing to it.
03:36:51 <seth_> the interpreter version will generally be slower.  But, ghci is capable of loading in compiled code, so if only main and a small amount of code is interpreted, the speed is about the same.
03:37:08 <delYsid> hmm, I dont like this code...
03:37:09 <delYsid> getVars :: [String] -> ([Var],[String])
03:37:09 <delYsid> getVars s = let (_,r,rs) = gv (s,[],[]) in (r,reverse rs)
03:37:09 <delYsid>  where
03:37:10 <delYsid>  gv (("variable":var:xs),r,rs) = gv (xs,Var var Empty : r,rs)
03:37:10 <delYsid>  gv (a:xs,r,rs) = gv (xs,r,a:rs)
03:37:11 <delYsid>  gv ([],r,rs) = ([],r,rs)
03:37:19 <delYsid> can anyone suggest a nicer idiom?
03:38:41 <seth_> you like dense code.  :)
03:38:45 <elmex> hm, if i can unwind my brain maybe
03:41:54 <elmex> what is that code about?
03:42:03 <elmex> my brain is messdup
03:42:15 <seth_> he's handling command line arguments
03:42:29 <delYsid> heh
03:42:32 <elmex> thats called getARgs
03:42:34 <elmex> getArgs
03:42:54 <delYsid> given some list like ["variable","a","blah","variable b","..."], extract all those variable definitions, and return the list filtered
03:44:26 <elmex> hmm... whatever you say
03:46:31 <elmex> why does compiling with ghc take so long?
03:46:38 <elmex> gcc is so much faster ;)))
03:47:07 <seth_> it is quite slow, that's true.  but it is doing a lot.  remember that it calls gcc to compile the code that it generates.
03:47:51 <elmex> hm, ok
03:48:57 <Arnia> ghc also does lots of clever passes :)
03:49:57 <elmex> hmm, ok
03:50:26 <elmex> pass 345. check whether windows is installed on this machine pass 346. delete windows
03:50:26 <seth_> anyone remember a function to do nothing for a while, like sleep or nap in C?
03:50:44 <elmex> seth_: posix.sleep ?
03:50:53 <elmex> seth_: threadWaitDelay?
03:51:08 <seth_> I'll check those.  
03:51:10 <elmex> 2nd for concurrent
03:51:17 <elmex> threadDelay 
03:51:27 <elmex> it's only for concurrent stuff
03:51:32 <elmex> but posix has sleep
03:52:02 <seth_> O
03:52:23 <seth_> I've got threads in the program; by the way it is threadDelay, according to the docs.
03:52:35 <elmex> yes, i corrected my self up there
03:53:26 <seth_> oh, sorry, didn't see it.
03:53:57 <elmex> never mind, i'm using it for genrating regular timeouts in my client
03:54:10 <elmex> btw. how is the genral way to make loops in haskell?
03:56:04 <seth_> elmex: there is code to simulate a while loop in the thompson book
03:56:21 <elmex> thompson ?
03:56:23 <seth_> but in general you don't have and you don't (in theory) need loops.
03:56:31 <seth_> Craft of Functional Programming
03:56:35 <seth_> Simon Thompson
03:57:02 <elmex> hm, is it for free online readable?
03:57:41 <seth_> don't think so, but I'm not sure.
03:58:01 <Arnia> Loops are evil and should be punished
03:58:23 <elmex> and how to do a loopisch behavior?
03:58:33 <seth_> recursion
03:58:40 <elmex> oh
03:58:45 <elmex> so i'm doing that all time
03:58:50 <delYsid> is there something like isDigit, for strings?
03:58:59 <seth_> yes, in Data.Char
03:59:03 <delYsid> so that one could easily convert a string to an integer?
03:59:31 <seth_> for that you use  (read str) :: Int
03:59:42 <delYsid> ah
03:59:52 <delYsid> but how do I test, if read would succeed?
03:59:54 <seth_> you could use the methods in Data.Char to verify that all the characters are digits, for example.  Like C isdigit
04:00:07 <seth_> delYsid: run it and handle the exception
04:01:04 <seth_> any way to print a stack trace from within a function?
04:03:31 <elmex> why doesn't this work:
04:03:32 <elmex>                      threadDelay 1000000 >>
04:03:32 <elmex>                      sendLines sock $x + 1
04:03:39 <elmex>     Probable cause: `sendLines' is applied to too few arguments in the call
04:04:19 <seth_> try parentheses around $x + 1
04:04:30 <elmex> yes, they work. but why?
04:04:52 <seth_> precendence rules.  I'd have to study it to figure out, _really_, why.
04:05:09 <elmex> if i use do and not >> then it works
04:05:53 <seth_> then likely something is an IO Whatever, instead of a Whatever
04:05:56 <seth_> without the do
04:06:57 <elmex> well. it was the precendence stuff
04:09:32 <elmex> i'm really impressed how well this works...
04:10:41 <elmex> but i have to read about datastructures now...
04:10:45 <seth_> I've found that once you convince the compiler to accept it, it works, and almost always the way you intended it to work.
04:11:04 <seth_> elmex: try to get a copy of Okasaki's book on data structures for functional languages.
04:11:35 <elmex> hmm
04:12:55 <elmex> Purely Functional Data Structures  
04:12:56 <elmex> Chris Okasaki
04:12:57 <elmex> ?
04:14:24 <seth_> right
04:14:45 <elmex> i'm soooo out of money
04:15:21 <seth_> elmex: then check the docs for Edison, which aren't as good but are about the same material.
04:15:32 <elmex> Edison?
04:16:21 <seth_> there is a link to it somehwere on the haskell site.
04:16:35 <seth_> It's a haskell library of the structures described in Purely Functional
04:17:11 <elmex> well, i don't need a book special on datastructures. i need something about functional programming first
04:17:58 <delYsid> heh, this Forth module is fun
04:18:27 <delYsid> trans ("begin":xs) = While (trans (takeWhile (/="while") xs))
04:18:28 <delYsid>                            (trans (takeWhile (/="repeat")
04:18:28 <delYsid>                                    (tail (dropWhile (/="while") xs)))) :
04:18:30 <delYsid>                      trans (tail (dropWhile (/="repeat") xs))
04:20:19 <elmex> Haskell:the Craft of Functional Programming is 54,79 euro... it's food for half a month
04:25:25 <seth_> computer books are _very_ expensive.
04:25:32 <elmex> i know
04:25:45 <elmex> and living alone in my own appartment is _very_ expensive too
04:28:34 <seth_> $55 is relatively low, believe it or not.
04:28:48 <elmex> it's not really
04:28:59 <elmex> my other books are around $45
04:29:46 <elmex> hehe, i will write my boss some e-mail and ask him for that book
04:29:55 <elmex> 'i need that to program our cgis in perl'
04:30:18 <seth_> sounds reasonable to me
04:30:51 <elmex> it is
04:31:12 <elmex> a friend told me, he learned a lot from programming in haskell before he came to perl
04:34:49 <seth_> learn python and/or ruby, perl is about the ugliest language there is.
04:35:13 <elmex> python sucks
04:35:19 <seth_> better than perl
04:35:26 <elmex> perl is about the best languages ever
04:35:41 <seth_> you can't be serious
04:35:49 <elmex> i am
04:35:53 <elmex> i coded so much in perl
04:35:59 <seth_> I've never talked to anyone who knows perl and python who likes perl better.  never.
04:36:05 <delYsid> er
04:36:16 <delYsid> I know both, and dislike Python
04:36:20 <seth_> why?
04:36:31 <delYsid> I just dont like it
04:36:44 <seth_> that's not a terribly good way to make decisions
04:36:51 <seth_> what don't you like about it?
04:37:22 <delYsid> hmm, most of what I dislike is its indentation rule
04:37:25 <elmex> perl is just my language
04:37:40 <seth_> delYsid: the indentation is very similar to Haskell.
04:37:50 <seth_> elmex: you really should look at alternatives.
04:38:12 <elmex> seth_: well, i looked at ruby
04:38:15 <Marvin--> seth_: one difference is that you can override haskell's indentation though
04:38:27 <seth_> Marvin--: that's true.
04:38:36 <elmex> but ruby didn't really seemed to be an alternativ to perl
04:38:45 * shapr succeeds in building ghc 5.05
04:38:46 * shapr cheers
04:38:54 <seth_> elmex: I'm not a ruby advocate, but there is nothing you can do in perl that you can't do in ruby
04:39:12 <shapr> I like Python
04:39:16 <elmex> there is nothing you can do in ruby that you can't do in perl
04:39:17 <delYsid> seth_: except that it will surely take a little longer :)
04:39:35 <elmex> there is nothing you can do in perl you can't do in raw machine code
04:39:43 <seth_> elmex: for that matter there is nothing you can do in Haskell that you can't do in cobol.  Come to think of it, Cobol is actually a lot like perl.
04:39:53 <shapr> oy
04:39:56 <seth_> :)
04:40:01 <shapr> @fact java
04:40:01 <lambdabot> Java is the COBOL of the future --Shae Erisson
04:40:01 <lambdabot> -DONE-
04:40:16 <delYsid> languageWars!
04:40:17 <seth_> shapr: I hadn't seen that one.  :)  Interesting quote.
04:40:28 <shapr> hi Raystorm 
04:40:35 <Raystorm> hi
04:40:39 <seth_> Actually perl is the only language that I really don't like.  Other than rpg and cobol.
04:40:41 <shapr> seth_: I said it before Paul Graham did :-)
04:40:43 <Raystorm> is this a room to cry for help in?
04:40:55 <shapr> Raystorm: you can cry, but we'll just make fun of you unless you ask a question.
04:41:02 <Raystorm> ok
04:41:09 <shapr> if you ask a question we'll try to help you.
04:41:18 <Raystorm> i just downloaded and installed Bo2k
04:41:24 <seth_> shapr: is there any way to print a stack trace in Haskell?  I have a function being called and I need to know where it is called from.
04:41:35 <shapr> seth_: I think hat can do that
04:41:42 <shapr> Raystorm: what's bo2k ?
04:41:46 <Raystorm> but when i try to run the server configuration it tells me bo2k.exe is not a valid server file
04:41:49 <seth_> shapr: thanks. I'll download it and play.
04:42:16 <seth_> goodnight all
04:42:17 <Raystorm> iim running windows xp pro on a P4 if that makes a difference
04:42:32 <shapr> Raystorm: are you sure you're asking a #haskell question?
04:42:37 <opet> Raystorm: that's not very haskell related, is it?
04:42:39 <Raystorm> Back oriffice 2000
04:42:54 <shapr> Raystorm: I think you should get a life
04:42:54 <Raystorm> im lost
04:43:02 <opet> Raystorm: I expect bo2k doesn't work on windows xp, anyway
04:43:17 <shapr> Raystorm: crackers are not welcome here
04:43:19 <seth_> shapr: maybe you know something about this.  I have a main that calls another function, and from this other function threads are started.  The thread starting function never returns (intentionally).  However main is rexecuted.
04:43:29 <Raystorm> sorry
04:43:34 <seth_> what's bo2k?
04:43:36 <Raystorm> im not trying to crack anything
04:43:40 <shapr> back orifice 2000
04:43:47 <shapr> Raystorm: what are you trying to do then?
04:43:48 <delYsid> backdoor thingy
04:44:02 <seth_> yes, let's banish any such discussion.
04:44:09 <elmex> hm, why not write a OS in haskell?
04:44:14 <shapr> elmex: sounds like fun to me
04:44:16 <seth_> shapr: any idea on my re-executed main?
04:44:22 <shapr> seth_: no, that's a new one
04:44:35 <Raystorm> its a remote administration tool for networks(or can be) and im a network admin in training and wanted to learn more about it and play with it on my pc
04:44:37 <elmex> shapr: well, not like i know anything about OS programming or haskell yet ;)
04:44:54 <delYsid> Raystorm: haha, and play somewhere else
04:44:55 <Raystorm> ttyl
04:44:58 <shapr> Raystorm: try remote desktop or vnc then, those are legal remote access tools
04:45:04 <seth_> I have a putStrLn in the called function, and it is only called from main, so I don't think it is spurious.  However, a putStrLn call within main doesn't happen twice.
04:45:15 <shapr> not that I believe that guy
04:45:24 <seth_> It's a listen(), and the second invocation fails (of course) because it is the same ip/port.
04:46:02 <seth_> I'll try to trap the exception.
04:48:48 <shapr> most of the threading I've done has been in lambdabot
04:49:13 <shapr> you may learn something from reading the lambdabot sources, specifically IRC.hs around line 137
04:49:26 <seth_> where can I get the sources?
04:49:30 <shapr> @fact source
04:49:31 <lambdabot>  http://sf.net/projects/haskell-libs/, http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/lambdabot/
04:49:31 <lambdabot> -DONE-
04:50:11 <Marvin--> wtf was this guy up to? does he just randomly enter channels and ask for help??
04:50:23 <Marvin--> I mean... *come on*
04:50:44 <seth_> Marvin--: I'll bet he does.  :)
04:51:04 <seth_> shapr: looking at that source.  thanks.  This will take a while.
04:52:57 <seth_> If I'm inside a do, and I need a value without removing the IO from it, what do I do?  Can I put a let in the middle of a bunch of do statements?
04:54:18 <shapr> you can
05:07:56 <delYsid> shapr: hey, you gave me an url which described using state monads for writing evaluators... do you still have that link?
05:08:30 <delYsid> ah, nm, found it
05:15:39 <Marvin--> state monad for keeping track of variable states?
05:15:46 <delYsid> yup
05:16:30 <Marvin--> when I've written evaluators for imperative languages, I've found it easier to explicitly pass around the state, especially with shadowing variables
05:17:13 * delYsid is _trying_ to write Forth.hs
05:45:19 <Igloo> Does anyone know how to write an unboxed double?
05:47:09 <Igloo> Hmmm, think I need to use float2Double#
05:57:55 <Janni> hi
05:59:33 <fabs> hey
06:01:47 <Janni> I'm trying to implement RIPEMD-160 (Hash-algorithm). But there is s.th. I don't understand: "It is assumed that the message after padding consists of t 64-byte blocks, each of which is converted to a 16-word block using a Little-endian convention." The padding into 64 byte blocks thing is clear. But I don't know how to convert them into 16-byte blocks? Can anybody tell me how to do that or does this phrase not offer enough information? *confused*
06:03:27 <Igloo> I'd suggest finding an implementation is the easiest way to be sure about what it means
06:04:37 <Igloo> The only thing that doesn't specify is the order of bits in bytes I think
06:05:36 <Janni> I mixed up "16-word" and "16-byte" block, btw...
06:07:02 <Igloo> Ah  :-)
06:07:36 <Janni> Ah, now I get it. I have to divide a 64-byte/512-bit block into 32 16-bit words. Could this be correct?
06:09:18 <Igloo> 16 32bit words
06:09:55 <Janni> Err... Does "16-word block" mean 16 words?
06:10:10 <Igloo> That's how I'd read it
06:10:21 <Marvin--> Janni: well, how do you read "64-byte block"?
06:10:24 <Igloo> I think 32bit words are more likely, too
06:10:41 <Janni> Yeah, I think you're right
06:11:06 <Janni> Janni: A block which contains 64 bytes...
06:11:36 * Janni is soliloquizing
06:12:12 <Marvin--> Janni: so a "16-word block" would then be a block which contains 16 words, wouldn't it?
06:12:56 <Janni> Yes, ok
06:41:44 <shapr> Radek_MOB: what's the MOB mean?
07:31:00 <elmex> master of bloedheit?
07:52:13 <shapr> what's a bloedheit?
07:52:21 <elmex> never mind ;)
07:57:27 * shapr boings
07:59:42 <Igloo> :-)
08:04:35 <shapr> hi Igloo, what's up?
08:05:50 <Igloo> Snooker. And paper writing.
08:06:27 <shapr> snooker is somewhat like pool in the USA, yes?
08:06:58 <Igloo> In that it has a table, pockets, cue and balls, yes
08:08:06 <Marvin--> Igloo: you're watching the final too? :)
08:08:33 <Marvin--> pool... is that 8-ball?
08:08:39 <Igloo> Yup
08:08:41 <o3> shapr: snooker's the game with lots of red balls and some coloured ones
08:08:42 <Marvin--> (8 balls per player + black)
08:08:56 <o3> pool's what marvin just said :)
08:09:21 <Marvin--> yes, snooker has 15 red balls, one yellow, green, brown, blue, pink and black
08:09:43 <Igloo> Snooker is set up like http://www3.sympatico.ca/eric.perreault/img/snooker.gif. On your turn you must repeatedly pot { red then any other colour } while there are reds left, then yellow, green, brown, blue, pink, black. Reds are worth 1, colours increasing in the order you pot them at the end
08:10:04 <Igloo> Oh, and potted colours get respotted
08:10:20 <shapr> respotted? taken out of the pockets and put back on the table?
08:10:24 <Igloo> Yup
08:10:25 <Marvin--> yes
08:10:32 <Igloo> On the white dot on teh table marking its position
08:11:03 <Marvin--> I haven't played snooker (played some 8-ball and 9-ball though) but I stumbled onto eurosport covering the championships.. fun to watch :)
08:11:17 <shapr> do you have to hit one red for each other color ball? or one red before any number of other color balls?
08:11:26 <Marvin--> yes
08:11:28 <Marvin--> no
08:11:29 <Igloo> red, colour, red, colour
08:11:30 <Marvin--> :)
08:11:39 <shapr> Igloo: hey, maybe we can find a snooker table in Uppsala
08:11:44 <shapr> FoS ;-)
08:12:04 <Igloo> I get the impression that's unlikely outside of the UK
08:12:27 * Igloo has never played snooker on a table more than 1m long, and only pool a handful of times
08:12:28 <shapr> oh! hopefully I'll be able to bring my unicycle for faster transport
08:12:36 <Igloo> :-)
08:12:39 <Igloo> Can you ride it yet?
08:12:44 <shapr> no, not yet
08:12:58 <Marvin--> Igloo: heh
08:13:01 <shapr> but I can move along while holding onto a wall
08:13:06 <Marvin--> snooker tables are larger than pool tables, aren't they?
08:13:14 <shapr> I want to be able to do contact juggling while unicycling ;-)
08:13:14 <Igloo> Well, they vary in size
08:13:14 <Marvin--> and smaller damn pockets
08:13:43 <Igloo> shapr: So faster transport when following a wall?  :-)
08:13:55 <shapr> yah, so far :-)
08:14:45 <Marvin--> Igloo: there are snooker tables in Stockholm, and a few in Göteborg, I don't know about the rest of Sweden
08:15:17 <Igloo> Snooker is more my sort of game - you can't lose automatically by potting the wrong ball  :-)
08:15:19 <Marvin--> "fuck ken dorhety hes only a thick fucker from dublin and cant play snooker to save himself" <- from the forum on eurosport.com *lol*
08:15:32 <Igloo> :-)
08:15:34 <Marvin--> Igloo: it's damn hard though, from what I've understood
08:15:46 <Marvin--> at least the defensive play
08:16:32 <Igloo> But you won't be playing great players so won't have to contend with escaping from snookers much
08:16:46 * Marvin-- ponders mailing the swedish commentator and asking about snooker tables in sweden
08:17:00 * Igloo thinks I'd be impressed with myself if I could make breaks over 9, though
08:17:02 <Marvin--> wonder if that'll irritate him, he's already answered it at least once :)
08:17:08 <Marvin--> Igloo: same here :)
08:17:51 <Marvin--> Paul's Billiards here in Göteborg has at least one snooker table, maybe I should go try it
08:18:23 <Marvin--> drag along a few friends saying "let's shoot some pool" and then see if they can make heads or tails out of snooker :P
08:18:31 <Igloo> :-)
08:18:49 * Igloo would be up for it, or pool, at ICFP assuming I get to go
08:19:16 <Marvin--> Igloo: Uppsala is somewhat far from Göteborg though :)
08:19:22 <o3> Igloo: hehe, my dad used to be singapore snooker/billiards champion
08:19:33 <opet> is the snooker final on now?
08:19:35 <o3> Igloo: unfortunately i haven't inherited much of his abilities
08:19:46 <Marvin--> "Did you mean: snowboard uppsala"  nnno, not really, bad google
08:19:49 <Marvin--> opet: yes
08:20:06 <opet> bugger
08:20:10 <opet> I thought it was later
08:21:02 <Igloo> Cool
08:21:31 <Marvin--> I guess we can interpret that as no snooker tables in uppsala
08:22:09 <archie_sihir_> is there a concept of OO in nhc98?
08:22:09 <Marvin--> but there are definitely pool tables
08:24:59 <opet> actually, damn the snooker
08:25:11 <opet> it's taken over bbc2 so they're not showing 24 tonight
08:26:40 * Marvin-- is watching snooker
08:26:49 <Marvin--> s/$/ on eurosport/
08:39:52 <Marvin--> watching these guys play defensively is...somewhat incredible
08:41:06 <opet> Marvin--: did you see the big game yesterday?
08:41:39 <Marvin--> opet: which one? there were two semifinals yesterday, wasn't there?
08:41:48 <opet> yeah
08:42:00 <Marvin--> I saw snatches of both
08:42:16 <opet> the one where hunter failed to win quite impressivly (sp?)
08:42:19 <Marvin--> Doherty - Hunter was fun
08:42:30 <opet> yeah
08:43:09 <opet> very exciting :)
08:47:17 * tmoertel enjoys some tea
08:54:12 <ham[let]> hiho
08:54:21 <tmoertel> hello
08:54:47 <ham[let]> anyone familiar with category theory?
08:55:08 <ham[let]> cause i got a problem with FP and the cartesian product
08:55:18 <esap> what is the problem?
08:55:26 <ham[let]> think that you got two objects
08:55:37 <ham[let]> |R -> |Rx|R <- |R
08:55:51 <ham[let]> how can this be done in FP with the edges as functions?
08:56:53 <esap> is that supposed to be the ordinary product diagram?
08:57:04 <esap> what is the meaning of '|R' in that?
08:57:14 <ham[let]> some real number
08:57:17 <Janni> re
08:57:22 <ham[let]> could be an arbitrary object though
08:59:00 <ham[let]> for example if i want to multiply two numbers with one edge
08:59:13 <ham[let]> i need to get somthing like the CP over them
08:59:29 <ham[let]> and then define a function which multilpies a tuple
08:59:38 <shapr> microsoft windows is extreme evil
08:59:54 * shapr tries to express days of frustration over one insoluble error
09:00:02 <esap> ham[let]: ok. The product diagram is normally written like this: A <-- AxB --> B, where the arrows are 'fst' and 'snd'.
09:00:26 <ham[let]> esap thats the other way around thats what id call projection
09:00:41 <esap> ham[let]: ok, you want coproduct?
09:00:43 <ham[let]> i need the join of these objects
09:00:45 <ham[let]> yes
09:01:33 <Smerdyakov> The join of... two functions?
09:01:42 <ham[let]> no of two symbols
09:01:45 <esap> ham[let]: hmm.. in a coproduct, the arrows represent constructors. I'm not quite sure what you are trying to do.
09:01:47 <ham[let]> FP like
09:02:14 <ham[let]> esap but how would they function together?
09:02:35 <Smerdyakov> ham[let], what is a "symbol" here?
09:02:36 <ham[let]> i mean one of the two functions would have to hace access to the other
09:02:49 <ham[let]> Smerdyakov any object you can think of
09:03:07 <Smerdyakov> ham[let], well, I'm afraid you can't define meaningful operations on "any object you can think of" in Haskell!
09:03:28 <ham[let]> esap you understand what i mean dont you?
09:03:47 <ham[let]> Smerdyakov sry im a really bad explainer
09:03:50 <esap> ham[let]: the basic coproduct for two functions f : A -> C and g: B -> C is an object A + B such that   A <-in1- A+B -in2-> B and A+B --[f,g]--> C
09:05:20 <esap> ham[let]: in1 and in2 are the constructors, and [f,g] stands for the case construct.
09:06:00 <ham[let]> hmm sec
09:06:09 <esap> no wait, I got a couple of arrows backwards.
09:06:18 <ham[let]> yes i thoght so :)
09:06:31 <esap> ham[let]: the basic coproduct for two functions f : A -> C and g: B -> C is an object A + B such that   A -in1-> A+B <-in2- B and A+B --[f,g]--> C
09:07:25 <ham[let]> ok so i need some basic functor over any category which cooks these functions together?
09:07:41 <ham[let]> esap do you know any good read about that?
09:08:07 <esap> ham[let]: for the basic stuff, read 'Hillman: Categorical primer'
09:08:32 <ham[let]> esap is it a book or some online paper?
09:08:50 <esap> ham[let]: what are you using the functor for?
09:09:18 <ham[let]> esap but what if i got a commutiong diagram i wouldnt "add" these two fns together would i?
09:09:19 <esap> ham[let]: online paper, http://citeseer.nj.nec.com/487012.html
09:09:32 <ham[let]> esap to construt the overall constructor
09:09:45 <ham[let]> cool thx
09:10:05 <esap> ham[let]: what is "the overall constructor", do you mean a combination of 'in1' and 'in2' or something?
09:10:12 <Marvin--> wow, he potted the black, impressive... I thought he'd snooker instead
09:10:17 <ham[let]> esap yes
09:12:23 <esap> ham[let]: maybe you think of the unit of adjunction in _+_ -| Delta(_) [where delta : A -> AxA is the copying functor] or something, that would be (in1,in2)
09:13:34 <ham[let]> esap the function goes in the direction of the arrow right?
09:13:47 <esap> ham[let]: which function?
09:14:00 <ham[let]> esap page 15 in the paper you gave me
09:14:07 <ham[let]> the product you told me
09:14:21 <ham[let]> is it spliting up an object?
09:14:57 <ham[let]> X<-mu-Z-nu->Y
09:15:50 <esap> ham[let]: the product P represents a tuple (mu,nu).
09:16:33 <esap> ham[let]: but still I'm not sure which function you talk about.
09:17:16 <ham[let]> esap sec
09:17:20 <Marvin--> bah, bloody eurosport
09:19:04 <ham[let]> esap hmm what does the product do then?
09:19:17 <ham[let]> is it like splitting up tuples?
09:19:51 <ham[let]> and the coproduct joins it?
09:20:21 <esap> ham[let]: no, the product (P in the diagram) represents a tuple. The 'pi_X' and 'pi_Y' operations are the product projections. Z is the context.
09:21:13 <esap> ham[let]: the product projections obviously project the tuple elements.
09:21:48 <ham[let]> esap (X,Y) = Z     Z-mu->X right?
09:22:20 <esap> ham[let]: no, (X,Y) = P.
09:22:34 <ham[let]> oh sry yes
09:22:46 <ham[let]> and then pi_X
09:22:49 <ham[let]> ok got that
09:22:59 <ham[let]> ok then from the start i need the colimit
09:22:59 <esap> ham[let]: the mu and nu are the data needed to construct a tuple.
09:23:25 <ham[let]> and if im not mistaken then i need two constructors
09:23:46 <esap> ham[let]: for a coproduct, yes, you have two constructors.
09:24:02 <esap> ham[let]: for a product, you only have one constructor.
09:24:10 <ham[let]> ok and the function i was referring to was that [f,g] you were mentioning above
09:24:54 <ham[let]> cause how would i run the program other wise?
09:25:04 <esap> ham[let]: yes, that is the case construct, a.k.a. case(f,g). which takes a coproduct (A+B) and uses either f or g to it based on what constructor it was constructed with.
09:26:26 <ham[let]> esap but i want to construct a tuple of both
09:27:22 <ham[let]> esap do you have dotty?
09:27:49 <esap> ham[let]: yes.
09:28:07 <ham[let]> esap can i send you a graph i think that would help a lot
09:28:38 <esap> ham[let]: ok.
09:28:53 <ham[let]> k
09:29:14 <ham[let]> can you accept it?
09:41:48 <esap> \msg ham[let] I don't understand the relationship between 'product vector 1 3' and 'product 1 3'. What is the intent there?
09:42:21 <esap> sorry.
09:54:42 <Janni> Is there a predefined function like this? (Didn't find a better unused name)
09:54:43 <Janni> group _ [] = []
09:54:43 <Janni> group n xs = take n xs : apportion n (drop n xs)
09:54:55 <Janni> s/apportion/group
09:55:08 <Marvin--> I'd use splitAt instead
09:55:16 <Marvin--> and a recursive function for applying splitAt
09:56:21 <Marvin--> I had a splitter function :: (a -> (b,a)) -> a -> [b]  that I used for precisely these things
09:59:18 <Janni> This solution is a bit nicer, but also a bit slower:
09:59:23 <Janni> group' _ [] = []
09:59:23 <Janni> group' n xs = left : group' n right where (left,right) = splitAt n xs
10:00:15 <Marvin--> using splitAt is slower? I wouldn't have expected that
10:00:41 <Marvin--> wonder what the impact of the tuple is, maybe you could try using unboxed values
10:01:09 <Janni> (365096 reductions, 574147 cells, 2 garbage collections) vs (354120 reductions, 469166 cells, 1 garbage collection)
10:01:48 <Janni> @fact unboxed values
10:01:48 <lambdabot> set unboxed to values
10:01:48 <lambdabot> -DONE-
10:02:00 <Marvin--> heh
10:02:08 * Marvin-- bonks lambdabot
10:02:16 * Janni bonks himself
10:02:31 <Riastradh> @fact delete unboxed
10:02:32 <lambdabot> deleted unboxed
10:02:32 <lambdabot> -DONE-
10:02:32 <Darius> Janni: That probably is the tuple, and it'd likely get optimised away
10:03:17 <Darius> also the name group is used in module List already
10:04:45 <Janni> Yeah, I know. I don't need a fast version of the function right now... I'm off for dinner.
10:05:57 <Marvin--> whoops, I got a ghc panic
10:09:59 <Marvin--> I like the definition of length in ghc, it's full of #:s
10:11:30 <Igloo> You mean unboxed stuff?
10:12:01 <Marvin--> yeah
10:12:21 <Marvin--> len (_:xs) a# = len xs (a# +# 1#)
10:12:57 <Igloo> *nod*
11:15:51 <opet> what are unboxed types?
11:16:46 <Igloo> Just values, no indirection to the heap or anything
11:17:25 <opet> oh okay
11:30:22 <Janni> Is there a program that translates imperative code into functional code? I have a loop for example that exchanges a lot of values between the variables and I want to know what value the variable has after the loop has finished...
11:31:28 <seth_> there are ways to do that, but I don't know of anything that automates such translations.
11:32:02 <Janni> It wouldn't be hard to write such a program, I guess. It's only substitution...
11:32:25 <Smerdyakov> It's pretty easy to do.
11:32:38 <Smerdyakov> You just define a substitution semantics for the imperative program like you do for Haskell.
11:32:42 <Smerdyakov> And chug your way along =)
11:32:53 <Smerdyakov> With an extra state passed along at each stage with variable values.
11:33:31 <delYsid> hmm, is there a takeWhile which gives me the first matching element too?
11:33:50 <delYsid> er, first not matching value
11:42:10 <Darius> SSA
12:08:49 * opet blinks
12:09:08 <opet> is the room meant to be -t?
12:12:27 <seth_> what's -t?
12:14:32 <lament> opet: Most channels on freenode are -t
12:14:41 <lament> opet: because people who inhabit them are, in general, not morons
12:15:40 <opet> lament: I guess I'm used to more moronic irc networks, then :)
12:16:08 <lament> Most people are.
12:17:17 <Riastradh> Most people are moronic, in fact.
12:18:59 <Smerdyakov> Channels only become +t when populated by immature, power-hungry folk.
12:19:08 <lament> Yeah, like #C :|
12:19:20 <Smerdyakov> #C of EFNet is a good example.
12:19:24 <Smerdyakov> I bet #c here isn't much better.
12:19:43 <ham[star]> bye
12:19:44 <lament> Actually, I'm just kidding. Some retard set +t in #c - lilo, probably
12:20:16 <lament> but yes, efnet #c is pure evil
12:20:30 <lament> but then it's efnet, what would you expect :)
12:20:38 <Marvin--> lament: there are plenty of morons on feenode too
12:20:47 <Marvin--> lament: I think you just mentioned one ;)
12:27:41 <Igloo> SyntaxPolice?
12:28:27 <Marvin--> yay, Doherty won another frame, now it's just 7-2 to Williams ;)
12:28:50 <dennisb> Marvin--: Aah, snooker. That is fun
12:30:00 <Marvin--> dennisb: haven't played it, but I enjoy watching it
12:30:07 <Igloo> Oh, I didn't know free balls kept their status past the shot
12:30:18 <dennisb> Marvin--: same with me!
12:30:23 <Marvin--> Igloo: I didn't quite follow that either
12:30:51 * Igloo thinks about that again and wonders if the commentator was talking rubbish
12:31:15 <Marvin--> well, he was allowed to play on yellow, so...
12:31:30 <Igloo> Who was when?
12:31:53 <Igloo> I understand the yellow was a red for Ken, I just don't see why he couldn't have snookered behind it
12:32:42 * esap doesn't watch any sports that need commentators to remain interesting.
12:32:48 <Igloo> Have you got John Virgo and someone commentating?
12:33:05 <Marvin--> "It is a foul should the cue ball fail to first hit, or be snookered by, the free ball."
12:33:10 <Marvin--> no, I've got a Swedish guy on eurosport commentating
12:33:26 <Igloo> Ah, right, that makes sense
12:34:06 <Marvin--> to which there's also an exception - when only the pink and black remain
12:35:22 <Igloo> Ah, that's sensible
12:35:24 <opet> snooker commentators are all pretty bad
12:35:28 <opet> what can you say?
12:35:46 <opet> "ooh, he should have potted that" "that's the pink potted"
12:35:55 <Marvin--> "tricky situation, this"
12:36:23 <Marvin--> the Swedish commentator is pretty quiet, but he tells amusing anecdotes and stuff
12:36:47 <Marvin--> and he explains the rules every day or so :P
12:36:48 <Igloo> They talk about shot choices available, spin and stuff
12:36:57 <Igloo> lol
12:37:11 <Marvin--> hey, Sweden's not a snooker country you know :)
12:37:35 <Marvin--> he usually starts with "now all of you viewers who've been around for a few days are going to groan, because I'm going to quickly explain the rules again..."
12:37:39 * Igloo has no idea of the rare rules, like the above. I wouldn't know where to put a ball if its spot was covered, for example
12:37:55 <Marvin--> Igloo: me neither, "another spot" is the best I can do ;)
12:38:11 <Igloo> I don't remember there having been so many free balls in previous years, or even matches
12:38:52 <Marvin--> "If a color's spot is occupied , it is placed on the spot of the highest value color that is unoccupied. If all spots are occupied, the color is spotted as close as possible to its original spot on a straight line between its spot and the nearest point on the top cushion."
12:39:13 <Igloo> Which end's the top?
12:39:44 <Igloo> If they tried I'm sure they could fill all of the above, anyway
12:40:01 <Igloo> Probably only needs 3 or 4 well placed reds
12:41:08 <Marvin--> I think the baulk line is at the "bottom" cushion, so I guess the black's cushion is the top cushion :)
12:42:59 <Igloo> Maybe only 2 then
12:43:09 <Igloo> If I was a pro I'd try to do that
12:43:17 <Marvin--> what do you mean?
12:43:47 <Igloo> Oh, I read it wrong - it can be bottom cushion side of its spot
12:43:56 <Igloo> That makes it harder  :-)
12:44:01 <Marvin--> yes ;)
12:45:10 <Marvin--> poor Ken
12:45:24 <Igloo> Although that does mean that if another ball is on its spot then there are 2 equidistant points
12:45:41 <Marvin--> bleh :)
12:45:53 * Igloo isn't convinced my first reading wasn't right given what I've seen them do in the past
12:46:30 <Marvin--> I've only seen it once, and then there wasn't really a choice
12:46:45 <Igloo> Does anyone know how you solve the collision of 2 balls, BTW? Conservation of momentum and energy only gives you 3 equations
12:46:45 <Marvin--> but sure, non-mathematically, the sentence is highly ambigous
12:47:22 <Igloo> (on a plane)
12:49:13 <Riastradh> @yow
12:49:14 <lambdabot> Yow!!  "Janitor trapped in sewer uses ESP to find decayed burger"!!
12:49:14 <lambdabot> -DONE-
12:50:03 <Marvin--> I repeat, poor Ken :)
13:00:09 <seth_> hello, all.  I have a program, involving monads, that works, but if I change something it stops working.  The problem is that the behavior seems backward to me, so perhaps I have an incorrect assumption about how monads work.
13:00:27 <seth_> I have two functions, both monadic, the second called by the first.
13:00:49 <seth_> In the first I call a function that returns IO Socket.
13:01:03 <seth_> In the second function I use the IO Socket, and so I pass it in as a parameter.
13:01:40 <Marvin--> you should probably pass the Socket instead
13:01:44 <seth_> Now, in the configuration that works, I change the IO Socket to a Socket (with a combinator), pass the Socket to the second function, and use returnIO to turn it back into an IO Socket.
13:01:53 <seth_> Yes, that's what I'm doing.
13:02:01 <seth_> and that's what I don't understand.
13:02:17 <seth_> Why does it work when I pass it as IO Socket and use returnIO on it, but it doesn't work if I pass IO Socket?
13:02:30 <seth_> sorry, pass it as Socket
13:02:34 <seth_> and use returnIO on it
13:03:09 <seth_> So it is returned from the socket library as IO Socket, I turn it into Socket, pass it, and turn it _back_ into IO Socket.
13:03:57 <Marvin--> what do you mean use returnIO on it?
13:04:03 <seth_> Marvin--: you obviously know the answer :) as you said "you should pass a Socket".
13:04:31 <Marvin--> but why do you need to turn it back into an IO Socket?
13:04:41 <Marvin--> (just 'return' works too, btw)
13:04:47 <seth_> To pass it to another function that takes an IO Socket
13:05:06 <Marvin--> that function should probably take a Socket too ;)
13:05:13 <seth_> I know, but then why does returnIO exist?
13:05:27 <seth_> Marvin--: ok, but I need to understand why it should be Socket and not IO Socket
13:05:33 <Marvin--> I don't know why returnIO exists, it's equal to return as far as I know
13:05:37 <Marvin--> well, except that it's not overloaded
13:05:48 <Darius> Probably so ffi details can be separate from instance Monad IO
13:05:54 <seth_> there are a bunch of returnXX's defined for various monads.
13:05:58 <seth_> Oh, ok.
13:06:02 <Igloo> Is it standard? GHC might need a non-overloaded function for implementatino reasons
13:06:07 <seth_> back to passing a Socket or an IO Socket.
13:06:12 <seth_> Igloo: I don't know.
13:06:24 <Igloo> Are these short functions?
13:06:27 <Marvin--> seth_: IO is the nuisance that the "pure" part of "pure functional language" forces on us
13:06:50 <Marvin--> seth_: I could turn it around, "why pass around IO Socket when you can pass around Socket instead?"
13:06:52 <seth_> Marvin--: I know, but I don't see how passing IO Socket is "wrong" in any way.
13:07:25 <seth_> Marvin--: well, because transforming things for no reason would seem to be a bad idea.  Why does the library function _return_ IO Socket instead of Socket.
13:07:33 <Marvin--> seth_: I wouldn't say it's wrong. unnecessary, yes. silly, yes. dumb, perhaps :)
13:07:46 <Marvin--> seth_: because it's not a pure function
13:07:47 <esap> IO Socket means "command returning Socket". There are situations where you want to pass commands, but usually you don't.
13:07:55 <Marvin--> seth_: creating a socket is not a pure mathematical function
13:08:29 <seth_> Marvin--: and, being not a pure mathematical function, why should _I_ then, in my code, remove the IO qualifier?
13:08:45 <Marvin--> seth_: because you want to use the socket
13:08:58 <Marvin--> seth_: the IO part is sort of a container that ensures you cannot do anything *stupid* with it
13:09:17 <seth_> Marvin--: Yes, so why should I remove it and give myself the opportunity to do something stupid with it?
13:09:40 <Marvin--> seth_: no, you don't understand, the only way to "remove" the IO part is *within* the IO monad, where it's impossible to do anything stupid with it
13:09:52 <Marvin--> outside the IO monad, you cannot remove it
13:10:01 <Darius> using unsafePerformIO would be doing something stupid with it
13:10:19 <Marvin--> Darius: hush now, don't complicate matters even more :)
13:10:35 <seth_> Actually, I can _only_ use unsafePerformIO on IO Socket, not on Socket
13:11:04 <seth_> And why is removing the IO with a combinator less stupid than removing it with unsafePerformIO?
13:11:23 <esap> seth: because those combinators are designed to work correctly.
13:11:24 <Darius> okay then more accurately using the Socket you get with unsafePerformIO would be doing something stupid
13:11:51 <seth_> esap: that doesn't make sense.  Once I have a Socket, the combinator has no control over what I do with it.
13:12:06 <Darius> But it controls how you get it
13:12:24 <Darius> (or in this case the most important thing is when)
13:12:29 <esap> seth: sure it has. It uses a different type for different things. Sockets can only be used to do operations that are good for sockets.
13:12:40 <Igloo> seth: To actually do anything you need a Socket. While in the IO monad you can get a socket from a computation that resturns one
13:12:43 <seth_> And aren't we supposed to think in terms of type transformations, so that IO Socket -> Socket is what matters, and not what methods are called?
13:12:54 <Marvin--> seth_: the combinator (>>=) is part of the definition of the monad, unsafePerformIO is not
13:13:03 <seth_> Igloo: that doesn't explain why I should remove the IO before I need to.
13:13:12 <Igloo> Wrapping it up as a computation and passing it as an IO Socket to something that immediately unwraps it is just pointless
13:13:25 <Marvin--> seth_: look at it this way, you're not actually removing the IO, you're lifting your function inside the IO
13:13:27 <seth_> Marvin--: hmm., they are both described in the IO Monad docs.
13:13:37 <seth_> Marvin--: why does it matter _when_ I do that?
13:14:00 <Igloo> If it's already an IO Socket then there's no reason apart from style to have your function be passed a Socket
13:14:18 <seth_> Igloo: but it works in one case and doesn't work in the other case.
13:14:26 <seth_> Is that a bug?
13:14:36 <Igloo> I can't comment on that without seeing the code
13:14:37 <Darius> Because with the IO monad you are programming imperatively, so the when is crucial.
13:14:54 <Marvin--> seth_: let's drop the IO Socket thing, and use a random number generator as example instead. 'rnd :: IO Int', here it does very much matter where you do the lifting
13:15:01 <Marvin--> seth_: because every time you lift, it will generate a new random number
13:15:10 <Igloo> But evaluation order will be different which might explain it
13:15:19 <seth_> Marvin--: so what?  The question isn't how many times I lift, it is _when_ I lift
13:15:37 <seth_> Igloo: then it isn't safe, even if I avoid unsafePerformIO
13:16:14 <Marvin--> seth_: but that's the thing, state monads *are* sensitive to ordering
13:16:30 <Marvin--> seth_: heck, the IO monad is *meant* to implement an imperative sub-language
13:16:30 <Igloo> Oh, wait, are you passing the creation function or actually wrapping a value with return?
13:16:43 * Igloo would need to see the code to help further
13:17:04 <seth_> Igloo: I'm either passing the IO Socket returned from the Network.Socket module, or I'm passing Socket from that same returned value.
13:17:40 <seth_> I need to know why the results are different when I pass the IO Socket and lift it, compared to lifting it and passing the Socket
13:17:52 * Igloo would need to see the code to help further
13:18:31 <seth_> It's quite short.  should I paste it?
13:19:04 <Igloo> If it's < about 5 lines, yes
13:19:14 <seth_> although, it won't tell you anything.  I'm calling Socket, then either passing the returned value, or doing >>= to get Socket, and then passing that value.
13:19:36 <Igloo> "calling Socket" doesn't mean anything to me
13:19:47 <seth_> Igloo: it's a function in Network.Socket
13:19:54 <Igloo> Oh no it isn't
13:20:00 <Igloo> socket might be?
13:20:07 <seth_> Yes, you are correct.
13:20:09 <seth_> socket
13:20:25 <seth_> but please, let's talk about what's happening and not quibble about the words.  You knew I meant socket
13:20:47 <Igloo> I didn't, I thought you might be confused - I didn't know there was a socket function
13:20:54 <seth_> Marvin--: can you explain why it matters that I lift and then pass Socket, compared to passing Socket and lifting?
13:20:59 <Igloo> What do you mean by "returned value"? A Socket or an IO Socket?
13:21:19 <seth_> Igloo: it returns IO Socket.  As far as I know, there are no library functions that return Socket
13:21:33 <seth_> Plus, how could I lift Socket?
13:21:56 <Igloo> And which one doesn't work?
13:22:04 <Igloo> The former presumably?
13:22:11 <seth_> It doesn't work if I pass IO Socket to the function and lift it.
13:22:17 <seth_> It works if I lift it and pass Socket
13:23:28 <Igloo> Right, so if you have foo :: IO Socket -> IO a and foo x = do y <- z; z <- x   then y and z may be different as socket can return different things each time
13:23:54 <Igloo> I though't you'd done x <- socket; foo (return x) in which case they'd both give the same value as the result has already been computed
13:24:22 <Igloo> But if you'd done that then you may as well not bother with the return and just pass it as a Socket
13:24:52 <seth_> Igloo: No, I didn't turn it into a Socket and turn it back into an IO Socket and pass it.  I'm not that confused.
13:24:56 <Igloo> (which is what using >>= is equivalent to)
13:25:16 <seth_> But I still don't understand why, when it is only lifted once, if matters whether it is lifted in the calling function or the called function.
13:25:21 <Igloo> OK, I just got confused by the return talk earlier
13:25:51 <Igloo> socket doesn't return a "socket" (the english meaning of the word)
13:26:17 <seth_> Igloo: socket returns IO Socket
13:26:20 <Igloo> socket is a computation that will return a new "socket" each time you ask it to compute one
13:26:31 <Igloo> Don't think about it like that
13:26:31 <seth_> Right, but socket is only called once
13:26:46 <Marvin--> just like the system call actually :)
13:26:59 <Igloo> But what you bind it to in foo is the same as socket
13:27:09 <Igloo> So if x is computed twice then socket is computed twice
13:27:26 <seth_> nothing is computed twice, as far as I can see.
13:27:37 <seth_> Where is any duplicated computation in:
13:28:02 <seth_> bar sock = sock >>= \s -> accept s
13:28:16 <seth_> foo = bar socket .....
13:28:25 <seth_> ?
13:29:02 <Igloo> That looks OK to me
13:29:20 <seth_> So if it doesn't work, it is a bug?
13:29:28 <Igloo> What are the symptoms again?
13:29:29 <esap> the argument name is just somewhat misleading.
13:29:48 <seth_> esap: the names are just ireelevant dummies
13:30:10 <dennisb> seth_: I havn't followed all the above, but the sock that you pass into bar is the computation that when invoked creates a socket for you
13:30:25 <seth_> dennisb: yes, so why doesn't it work?
13:30:46 <Igloo> seth: How doesn't it work?
13:30:59 <esap> seth: where does 'foo' get that socket?
13:31:09 <seth_> A call the preceeds the call to socket() is executed twice
13:32:02 <esap> seth: is that referring to the library function or some local variable?
13:32:05 <Igloo> seth: Huh?
13:32:23 <seth_> esap: socket() you mean?  That is Network.Socket's socket function
13:32:31 <esap> seth: ok.
13:32:36 <seth_> Igloo: that's what I said, also, Huh?
13:32:59 <Igloo> I don't understand what is executed twice
13:33:14 <dennisb> seth_: if you create a small example that shows the problem that we can run i'm sure we can help
13:33:17 <seth_> Igloo: a call to listen() on a completely different Socket
13:33:41 <Igloo> I listen() a Haskell function or a syscall?
13:33:43 <seth_> dennisb: I'll see if I can make a small example.  I have the code that demonstrates the problem.
13:33:54 <seth_> Igloo: listen is another call in Network.Socket
13:34:25 <seth_> I wouldn't think that any programming error should result in a duplicate call to a function
13:34:43 * Igloo still thinks we need to see the code
13:35:02 <Igloo> (well, more of it)
13:35:16 <seth_> I'll see if I can duplicate it with a smaller program.
13:35:26 <Darius> it would'nt.  for a function.  I don't know why you'd think the same for a computation.  You call free(x) twice in C and you program crashes.
13:35:34 <Marvin--> seth_: "call" is a tricky concept in haskell
13:35:43 <seth_> Darius: right, but nothing is called twice
13:35:58 <seth_> and passing the IO Socket as Socket eliminates the problem.
13:36:13 <seth_> I can't see how passing an IO Socket causes an additional call.
13:36:30 <Darius> I misread what you, wrote.
13:37:16 <Marvin--> I'm having a hard time keeping up, I'm trying to watch Snooker, eat dinner and listen to Apocalyptica too :)
13:37:22 <esap> seth: do you have two uses of the socket?
13:37:27 <seth_> esap: no
13:37:29 <Darius> Though, reading it again it makes less sense.  Writing free(x);free(x); is a program error that results in a duplicate call to a function, as is say using unsafePerformIO
13:38:10 <seth_> Darius: correct, but I have no calls to unsafePerformIO.
13:39:51 <Darius> (actually unsafePerformIO is worse by making something not called at all)
13:40:16 <Darius> That doesn't mean you couldn't fall prey to any other error equivalent to the first.
13:40:53 <seth_> Darius: show me an error that can cause a function to be called twice because I lift IO Socket in a different place.  Not lift it an addition _time_, lift it in a different _place_
13:44:04 <dennisb> what does it mean to lift IO socket? for me lift is something you do to convert an operation into a monadic operation
13:44:30 <Darius> mapM (readSocketProperty iosocket) props
13:44:35 <seth_> dennisb: I was using Marvin--'s term, maybe lift isn't the right term.  I convert it from IO Handle to Handle
13:45:22 <esap> there is no operation to convert IO Handle to Handle (except unsafePerformIO).
13:45:24 <Marvin--> seth_: no you don't, you don't convert it at all
13:45:43 <seth_> Marvin--: ok, I use >>= on it and the compiler says it is now type Socket
13:45:47 <Marvin--> seth_: >>= is called "bind", because you bind the result of a computation to a variable, passed to the second computation
13:46:16 <seth_> Marvin--: ok, but the point here is not to discuss terminology, it is to figure out why the behavior changes.
13:46:37 <seth_> Darius: I don't have readSocketProperty in any library
13:47:20 <Darius> That was an example function.  The idea being to read a bunch of properties from someone connected to a socket
13:48:49 <Darius> doing: do socket <- openASocketToSomeone;mapM (readProperties socket) props; is one thing
13:49:29 <dennisb> There is not way to solve this without some actual code to talk about
13:49:32 <Darius> doing: let iosocket = openASocketToSomeone in mapM (readProperties iosocket) props; is another
13:49:52 <Darius> with a slightly different definition of readProperties
13:49:55 <seth_> Darius: but that has no relation to what we are talking about.
13:50:02 <seth_> dennisb: here is the code:
13:50:26 <seth_> bar s = accept s
13:50:38 <seth_> foo = socket >>= \s -> bar s
13:50:40 <seth_> That works
13:50:43 <seth_> This doesn't work:
13:50:53 <seth_> bar s = s >>= \ss -> accept ss
13:51:01 <seth_> foo = bar (socket ...)
13:51:23 <esap> what is ...?
13:51:27 <Marvin--> seth_: and what is it that's called twice?
13:51:33 <dennisb> I want to run it
13:51:51 <seth_> a call to listen on a completely different socket
13:52:15 <seth_> I'm coding up what I hope is a minimal program that has the same problem.
13:53:08 <Marvin--> good
13:53:56 <seth_> I can send you the large program but that would be a waste of your time if I can make a smaller one with the same problem.
13:54:08 <esap> seth: you mean you have something like: foo = bar (socket >>= \s -> accept s2) ?
13:54:36 <seth_> esap: no, the accept is invoked in a called function, not the same function
13:55:07 <seth_> esap: and the calling function is more complicated as you can't call accept on a socket that you haven't called bind and listen on
13:55:15 <seth_> but that's the general idea
13:55:37 <dennisb> seth_: if you can put the code on a webpage or something I (and other) can take a look
13:56:15 <seth_> dennisb: I will either put a small program, or the bigger one, on the page.  I don't want to waste your time wading through a few hundred lines of code that is probably not germain to the problem.
13:56:46 <Darius> Then put comments near the code you believe to be
13:56:59 <dennisb> if I look at your fragments above there is something I can say about bar
13:57:11 <dennisb> the first bar takes a created socket and runs accept on it
13:57:31 <dennisb> the second bar creates a new socket and runs accept on it
13:57:57 <dennisb> Maybe you have a similar "problem" somewhere else in the code
13:58:06 <seth_> But isn't it true that in all that changes is whether the socket is created in foo, or whether it is created in bar?  Which isn't a problem?
13:58:47 <Darius> It depends on the context
13:58:55 <seth_> Why?
13:59:01 <Darius> That's the problem with imperative code
13:59:03 <dennisb> I'm saying that maybe you have some other function that you use on the socket, surely you don't just run bar on it?
13:59:34 <esap> if you use bar twice, then there is a difference in behaviour.
13:59:37 <seth_> dennisb: I create it, run bind, listen, and then pass it to bar and run accept
13:59:47 <seth_> esap: but I _don't_t use bar twice.
14:00:18 <seth_> esap: and if I use bar twice it would be just as much an error regardless of whether I pass Socket or IO Socket
14:01:06 <Darius> just post your code now.  While you work on a simpler example others can look at it.
14:01:37 <seth_> OK, I'll find a place to post it.
15:58:35 <seth_> I know the syntax to override layout with do, as in  do { a; b; c; }.  What is the corresponding syntax for normal (that is, not do) code?
15:59:05 <Riastradh> a >> (b >> c)
15:59:40 <seth_> Riastradh: the parentheses, you mean?
16:00:02 <kawfee> seth_: for what?
16:00:04 <Riastradh> ?
16:00:30 <seth_> In a let, for example, or any other multi-line situation
16:00:38 <Riastradh> Oh.
16:00:40 <Riastradh> do a
16:00:43 <Riastradh>    b
16:00:44 <Riastradh>    c
16:00:47 <Riastradh> That, you mean?
16:00:51 <kawfee> let { bindings } in {exp }
16:01:05 <kawfee> of course you need correct indentation
16:01:17 <seth_> kawfee: do you separate the bindings with ;, as with do { a; b; c; }?
16:01:33 <Riastradh> let a = b
16:01:35 <Riastradh>     c = d
16:01:37 <Riastradh>     e = f
16:01:38 <Riastradh> in g
16:01:48 <seth_> Riastradh: that is with layout.  I'm asking how to override layout
16:01:48 <kawfee> there is another way to do it in a let, but yes I think you can just do it with ;
16:02:03 <kawfee> seth_: why do you want to overide layout?
16:02:06 <seth_> kawfee: ok, one way is enough for me.
16:02:10 * Riastradh was a little confused as to your question.
16:02:15 <kawfee> seth_: try it and see if it works
16:02:18 <seth_> kawfee: just because it gets hard to read at times.
16:02:23 <Riastradh> let { a = b; c = d; e = f} in g
16:02:26 <seth_> mostly with do, but it is nice to know
16:02:36 <kawfee> seth_: I actually find indentation easier to read than ; ; ; 
16:02:59 <seth_> kawfee: mostly, yes, but if you have do, and then an if/then/else, and another do, etc., it can get messy
16:03:01 <kawfee> it's harder to read code that isn't indented
16:03:16 <kawfee> seth_: not really
16:04:04 <seth_> kawfee: "hard" isn't definable, anyway, but sometimes I prefer if (whatever) do {a;b;c;} else do{g;h;i;}
16:04:22 <seth_> I left out the then, but you know what I mean
16:14:50 <seth_> is there an exit() function?  I want to set the return code (to the O/S) from the main of an executable
16:16:27 <Marvin--> there's an exitWith function somewhere
16:16:35 <Marvin--> System perhaps
16:18:04 <delYsid> import System.Exit
16:18:08 <delYsid> exitWith
16:18:40 <seth_> thanks.  I looked in system but I didn't check for System.whatever
16:22:11 <kawfee> seth_: sure it is, I didn't define hard, I defined harder which is defined in terms of hard, so whatever you find hard, the increased level of difficulty that makes it harder is my def
16:23:09 <seth_> kawfee: :)
16:23:13 <Marvin--> fuck
16:23:26 <seth_> Marvin--: hmm?
16:23:34 <Marvin--> oh, sorry, wrong channel
16:23:38 * Marvin-- is having problems with libparted
16:23:58 <seth_> Marvin--: oh, I thought you meant you were in #porn or something
16:24:09 <Marvin--> seth_: no :)
16:24:20 <Marvin--> does #porn actually exist?
16:24:30 <Marvin--> .oO(you'd think it'd be called #pr0n on this network...)
16:28:20 <seth_> Marvin--: I have no idea.  I haven't looked.
21:04:59 <flippo> @yow
21:04:59 <lambdabot> My Aunt MAUREEN was a military advisor to IKE & TINA TURNER!!
21:04:59 <lambdabot> -DONE-
21:43:56 <seth_> @yow
21:43:57 <lambdabot> WHY are we missing KOJAK?
21:43:57 <lambdabot> -DONE-
22:16:35 <dennisb> seth_: did you solve your problem?
22:17:02 <seth_> dennisb: well, yes and no.  I can provoke it by doing extra returnIO calls, but I'm not sure what that means.
22:17:29 <seth_> dennisb: because there are times when I _have_ to do the extra returnIO calls.
22:18:33 <dennisb> thinking back on you example: bar s = s >>= \ss -> accept ss
22:18:42 <dennisb> I don't see how you even can use that
22:19:05 <seth_> dennisb: Why not?
22:19:45 <dennisb> as long as you pass in a IO Socket you got from say socket at least
22:20:04 <dennisb> it will always create a new socket and do accept on, and then that socket is lost and you can refer to it again
22:20:07 <seth_> oh, if you mean you can't do an accept call after socket, I said this morning that I had omitted the bind and listen calls
22:20:27 <seth_> to explain it, but of course for the code to work you need bind and listen
22:20:57 <seth_> dennisb: no, that isn't how tcp works.  You create a socket, bind it, listen, then call accept repeatedly on that socket.
22:21:01 <dennisb> unless what you pass in is just a wrapped up socket in a return that always returns the same socket. But that is probably not the kind of IO Socket you pass in
22:21:39 <dennisb> but how do you call accpet repeatadly? if you use bar it will create a new socket each time
22:21:47 <seth_> dennisb: there is only one kind of IO Socket.  In any event, you call, in sequence, in Network.Socket, socket(), bind(), listen(), and then you repeatedly call accept.
22:22:12 <seth_> dennisb: according to the docs, you can make those calls.  They exist in the library for some reason.
22:22:54 <seth_> since you don't have loops, you had better be able to pass the listen socket across function boundaries
22:23:57 <dennisb> but with that bar you don't pass around a socket but a socket producer
22:24:15 <seth_> dennisb: since that is the only thing that the library returns, I'm stuck with it.
22:24:41 <seth_> and there is no way to return the socket, not part of IO Socket.
22:24:42 <dennisb> something of type Socket you can passaround and use in many places, something of type IO Socket is a socket creator that you can pass around and each time you do s >>= you use the creator to create a new socket
22:24:46 <seth_> Well, there is a way, unsafePerformIO
22:25:03 <seth_> dennisb: but you can't _return_ something of type Socket.
22:25:13 <dennisb> you don't have to
22:25:46 <seth_> dennisb: How can I pass it around if I don't have it?
22:26:03 <dennisb> you write functions that have type: Socket -> .... -> IO ....
22:26:40 <seth_> That's how I pass it _into_ something.  So I suppose I can strip the IO, pass it in, and then the next time again strip the IO, and pass it in, but I can't imagine that it would actually work.
22:26:42 <dennisb> lets call that function foo, then: do { s <- create_socket_function; foo s; foo s; }
22:26:57 <dennisb> now you sent s (of type Socket) to foo twice
22:27:13 <seth_> dennisb: you are looking at the wrong end.  We are talking about how I _get_ the Socket to pass to foo, not how to pass the Socket to foo
22:27:25 <dennisb> lets pretend that foo reads one character from the socket or something, this will read two charactes from the same socket
22:27:33 <seth_> dennisb: forget foo.  that's not the problem.
22:27:37 <seth_> back up.
22:27:49 <dennisb> the example above does pass the socket to foo
22:27:52 <seth_> you have a library function.  that library function returns IO Socket.  That is given
22:28:08 <seth_> dennisb: you are missing the point.  Of course, if I have the Socket, I can pass it.  But I don't have it.
22:28:08 <dennisb> yes, that is the create_socket_function in my example, it has type ..... -> IO Socket
22:28:15 <dennisb> you are missing the point
22:28:21 <seth_> right, so it returns IO Socket, right?
22:28:34 <seth_> right?
22:28:34 <dennisb> yes, and s has thus type Socket
22:29:03 <seth_> So, I can use a combinator to turn it into a Socket, and call foo.
22:29:15 <dennisb> yes
22:29:16 <seth_> But, the next time I want to call foo, I have to do that operation again.
22:29:20 <dennisb> that is what >>= do
22:29:23 <seth_> applying the combinator
22:29:34 <seth_> so, in both cases, I'm starting with IO Socket.
22:30:03 <seth_> And I contend that it makes absolutely not difference whether I apply the combinator and pass a socket, or pass an IO Socket and apply the combinator.
22:30:08 <seth_> s/not/no/
22:30:28 <dennisb> if s in the example above had the type IO Socket (which it doesn't) then foo you have got a socket creator and inside would have created a new socket for each call
22:30:56 <dennisb> you have to send around the one created socket, not the socket creator that creates a new socket each time
22:31:16 <seth_> or, before I make the call I do the same thing to IO Socket that foo would do to IO Socket, so what's the difference.  Are you saying that the fact that I pass the parameter causes a socket to be created?
22:31:40 <seth_> In both cases I start with an IO Socket and end with a Socket.  So, if that creates a socket, it should create a socket regardless of whether I do it before or after I call foo
22:32:27 <dennisb> something of IO Socket is not the same thing a Socket,
22:32:36 <seth_> I know that.  Listen.
22:32:40 <dennisb> something of type IO Socket does not mean that it has created a socket
22:32:49 <seth_> In BOTH cases, you start with IO Socket.  If that is not true, explain why not.
22:34:13 <dennisb> it obvious that if you send foo a socket creator instead of a socket then foo will use that creator to create a new socket. If you call it twice it will of course create two sockets
22:34:42 <seth_> dennisb: then it is obvious that when I have an IO Socket in the calling function and I transform it twice into a Socket, I will create two sockets.
22:35:13 <dennisb> yes
22:35:26 <seth_> which is what I've been saying all along.  There is no difference.
22:35:53 <seth_> Because I can _call_ another function with a Socket, but I _can't_ return a Socket.
22:35:55 <dennisb> there is, because then you can send one of these two sockets to foo twice and foo would both times work on the same socket
22:36:24 <seth_> dennisb: if there are two separate sockets, we are already dead
22:36:54 <seth_> I guess I'll have to do something with threads, to avoid having to wrap the Socket in IO
22:37:54 <seth_> Then I can keep the Socket across a tail recursive call.
22:38:34 <dennisb> you need to learn about IO
22:38:55 <seth_> No, I need to figure out how to do IO in Haskell.  I've been doing IO for forty years.
22:39:09 <seth_> I _know_ how sockets work.
22:39:38 <dennisb> I'm of course talking about the haskell IO (type IO ....)
22:39:58 <seth_> You aren't seeing my point, so I guess I'm not being clear.
22:40:17 <seth_> You have some code, and that code has a Socket, which it obtained by applying a combinator to an IO Socket.
22:40:21 <dennisb> you don't ever need to return a Socket
22:40:34 <seth_> listen.
22:41:04 <seth_> this code can do only one of two things.  It can call another function passing Socket (or use Socket directly in it's body), or it can return IO Socket.
22:41:36 <seth_> So, the _only_ way to keep that socket, over the life of the program, is to spawn a thread that wakes up when that Socket has to be used.
22:42:12 <dennisb> no, you can write a tail recursive function of type Socket -> IO ()
22:42:32 <seth_> dennisb: that's case one, using the Socket on a call to another function
22:42:49 <seth_> Two cases, calling a function passing Socket, or returning IO Socket
22:44:06 <seth_> So, if I need the Socket, but I need to use it later in the program, I'll have to sleep a thread
22:46:39 <dennisb> it's not true, you don't have to do that just to keep a socket around (if that is what you say)
22:47:08 <dennisb> you can just write a recursive function of type Socket -> IO () to be your "main" function
22:47:49 <dennisb> it will call itself over and over with the same socket, during the lifetime of the program
22:48:23 <seth_> dennisb: that's exactly what I said, in effect.  The program has dozens of sockets, so each socket will need its own thread.
22:48:33 <seth_> there is only one main
22:48:47 <seth_> so you would be right in a toy program with only one connection, but not in a real program.
22:48:49 <dennisb> no, you can then write a recursive function [Socket] -> IO () and do select
22:49:22 <dennisb> so you keep around many sockets, do select, and so on. Just like in C, in one thread
22:49:32 <seth_> no one has been able to show me any way to do select in haskell.
22:50:11 <seth_> although several have suggested that I do an ffi for it.
22:51:10 <seth_> that's the obvious solution, I started asking about that days ago.
22:51:16 <dennisb> there is a select somewhere in the ghc libs, i've used it
22:51:39 <seth_> I would be most appreciative if you can show me where.  I've grepped both the docs and the source.
22:52:08 <dennisb> I'll take a look
22:52:20 <seth_> Maybe I can stuff the socket in an MVar
22:59:32 <dennisb> seth_: http://www.haskell.org/ghc/docs/latest/html/hslibs/select.html
23:00:23 <dennisb> This is from the old lib doc, I'm not sure where it ended up after they restructured the libs in the newest ghc, but the old is still usable I think
23:00:41 <dennisb> import Socket should work
23:00:48 <seth_> I'll try it, thanks.
23:00:56 <dennisb> import Select I mean
23:01:07 <seth_> right
23:02:20 <dennisb> it works on Handles, but there is probably a way to fix that for sockets
23:02:43 <seth_> I hope so.  There is a method to convert a socket to a handle, but I'm not sure about the ramifications
23:03:49 <dennisb> well, you get a handle when you do accept
23:04:17 <seth_> no, you get another socket
23:05:06 <dennisb> aha, it depends on what level you work on
23:05:32 <seth_> unfortunately for this task I have to work at the socket level.  Otherwise the socket level entity message is lost.
23:05:33 <dennisb> in Network there are higher level versions that you can use, for example: accept :: Socket -> IO (Handle, HostName, PortNumber)
23:06:14 <seth_> I can't use those, though, I lose necessary semantics
23:06:21 <dennisb> But I assume that is just implemented on top of the functions in Socket
23:06:39 <seth_> yes, but as I said you lose the message boundaries
