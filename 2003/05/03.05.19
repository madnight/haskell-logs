00:00:08 <seth_> jdrake: Why don't you give us a small program that you would like to write, and we can talk about how you would do it.
00:00:11 <shapr> yah!
00:00:53 * Lilith wonders if there's any propaganda on "why use haskell"
00:01:11 <seth_> Lilith: because I said so !!!
00:01:29 <shapr> Lilith: John Hughes wrote a great brief about it
00:02:02 <jdrake> maybe not something i would specifically like to write, as I am not sure what I want right now. But something that would start off... how about something that searches for prime numbers and prints out the ones it finds, and perhaps prints out the current number it is going through.
00:02:47 <jdrake> that sort of thing I can invision a nasty for loop..., or a recursive piece
00:02:47 <Lilith> i wonder how much i should put in my slides
00:02:51 <seth_> jdrake: ok, if you are printing, you are using the IO monad.
00:03:20 <Darius> just make a lazy list of primes and print them out
00:03:23 <seth_> jdrake: you can do this (for example):  putStrLn ("current value is " ++ (show val))
00:03:53 <seth_> Darius: that is not a good place to start.
00:04:58 <Lilith> seth_: why not?
00:05:21 <seth_> because you are asking him to tackle, at the same time, construction of a lazy list and learning how to print.
00:05:33 <Darius> print the_list?
00:05:48 <seth_> Darius: if he types in "print the_list" nothing will happen.
00:05:53 <seth_> Darius: so be serious.
00:06:09 <Darius> if he defines the_list first, plenty will happen
00:06:17 <seth_> Really, this is the most helpful channel I know, but you guys have _no_ idea where a person new to functional programming starts.
00:06:20 <wli> monads are just wrappers for continuation-passing
00:06:25 <Lilith> could just run ghci, hugs
00:06:32 <jdrake> seth_, you are putting in a single statement, not really a program sort of thing that can form a basis
00:06:35 <seth_> Darius: exactly, but as it stands that advise is confusing and useless.
00:06:37 <Lilith> i think one could learn how to do the primes sieve first
00:06:53 <wli> look at the types:
00:06:54 <wli> Main> :type (>>=)
00:06:54 <wli> forall m a b. (Monad m) => m a -> (a -> m b) -> m b
00:06:55 <Lilith> and then use hugs or ghci to see some output
00:06:57 <seth_> jdrake: that was how to do one thing, print the status line.  It is one of the things you need to know.
00:07:05 <Darius> seth_: I was showing that printing out the list is trivial.
00:07:09 <wli> m a is an action producing a that cannot be examined directly
00:07:13 <seth_> Lilith: only if one already knows how a primes sieve works.
00:07:25 <seth_> Darius: but that's the point, it is _not_ trivial.
00:07:36 <wli> (a -> m b) is the continuation, which in turn produces an action producing b that cannot be examined directly
00:08:05 <Lilith> going straight to monads isn't particularly trivial either
00:08:30 <wli> basically the type system is expressive enough to allow the stuff to typecheck
00:08:42 <seth_> Lilith: true, but another mistake I believe is frequently made is that monadic code is delayed, which results in someone not having the basic building blocks to do _anything_ at all.
00:08:58 <seth_> Lilith: you can't do hello, world without monads.
00:10:15 <seth_> All you folks know more about Haskell than I do, but I know a lot more about what confuses a newcomer than you do.
00:10:21 <seth_> :)
00:10:28 <Lilith> seth_: uhm. why is "hello, world" so important?
00:10:30 <Darius> we were never newcomers?
00:10:42 <Lilith> seth_: not really. i remember what it's like to be a first year haskell kid
00:11:13 <seth_> Lilith: my point is that here, as in so many things, it is easy to forget what is initially confusing.
00:11:21 <seth_> Lilith: or perhaps I was just more confused than you were.  :)
00:11:31 <Lilith> A smaller "semantic gap" between the programmer and the language.
00:11:35 <jdrake> arguing isn't productive, and won't resolve a single thing
00:11:37 <Darius> seth_:  Different people find different things confusing
00:11:37 <Lilith> ^ hey, can anyone tell me what that is?
00:11:50 <seth_> jdrake: this isn't arguing, it is a technical discussion.
00:12:06 <wli> I'm having trouble getting something past the type system atm also
00:12:12 <seth_> Lilith: the "semantic gap", you mean?
00:12:21 <seth_> wli: what?
00:12:26 <Lilith> seth_: i think looking at output with ghci/hugs helps
00:12:28 <Lilith> seth_: yes
00:12:28 <jdrake> seth_, technical discussion is just another name for argument :p
00:12:34 <wli> seth: some garbage with multiparameter typeclasses
00:12:36 <seth_> Lilith: definitely looking at output helps.
00:12:58 <Lilith> that's how i was taught to program in haskell anyway
00:13:01 <seth_> Lilith: I don't know what he means by that either, exactly.
00:13:03 * Lilith points to Chilli
00:13:51 <Lilith>  Why Use Haskell?
00:13:51 <Lilith> Writing large software systems that work is difficult and expensive. Maintaining those systems is even more difficult and expensive. Functional programming languages, such as Haskell, can make it easier and cheaper.
00:13:51 <Lilith> Haskell, a purely functional programming language, offers you:
00:13:51 <Lilith>     * Substantially increased programmer productivity (Ericsson measured an improvement factor of between 9 and 25 in one set of experiments on telephony software).
00:13:52 <Lilith>     * Shorter, clearer, and more maintainable code.
00:13:54 <Lilith>     * Fewer errors, higher reliability.
00:13:56 <Lilith>     * A smaller "semantic gap" between the programmer and the language.
00:13:58 <Lilith>     * Shorter lead times. 
00:14:01 <Lilith> Haskell is a wide-spectrum language, suitable for a variety of applications. It is particularly suitable for programs which need to be highly modifiable and maintainable.
00:14:04 <Lilith> Much of a software product's life is spent in specification, design and maintenance, and not in programming. Functional languages are superb for writing specifications which can actually be executed (and hence tested and debugged). Such a specification then is the first prototype of the final program.
00:14:05 <seth_> Lilith: I suppose he is alluding to the similarily between the way algorithms are typically described and Haskell code.
00:14:06 <jdrake> Lilith, please no
00:14:08 <Lilith> Functional programs are also relatively easy to maintain, because the code is shorter, clearer, and the rigorous control of side effects eliminates a huge class of unforseen interactions.
00:14:12 <Lilith> ^ does this make sense to you?
00:14:23 <Lilith> (sorry for the paste)
00:14:39 <seth_> Lilith: that last sentence, about side effects, absolutely makes a _lot_ of sense.
00:14:52 <Lilith> most pseudocode are written imperative style
00:14:53 <Lilith> hmm
00:15:10 <seth_> Lilith: it means that it is fundamentally impossible to look at imperative code and know what it will do.
00:15:44 <Darius> seth_: no, not that bad, you have to merely look at all of it at the same time
00:16:02 <seth_> Darius: in real life situations that is not possible.
00:16:22 <wli> I honestly care little about program safety or maintainability metrics. _I_ want the biggest hammer possible to attack problems with and (you guessed it) super-duper-high-level languages are like the freaking Mjolnir or something.
00:16:24 <jdrake> seth_, not all imperative code is written in perl :-)
00:16:29 <Darius> the practical consequences are about the same (to continue)
00:16:53 <seth_> jdrake: that's true.  :)  However, he is talking about the lack of determinism.
00:17:19 <Darius> Anyway, jdrake, what's (more) specifically your question, how to do IO in Haskell, or how to program Haskell in general?
00:17:52 <jdrake> how to write the program i was talking about would be a good start
00:18:13 <jdrake> i am getting a single function can be used for the prime number thing
00:18:30 <wli> why a function when a simple list suffices?
00:18:47 <jdrake> wli, show me...
00:18:55 <Darius> jdrake: a good start for what IO in Haskell or Haskell in general?  It's not really for the first.
00:19:30 <Lilith> meh
00:19:32 <wli> Main> let { primes = 2:3:5:[ p | p <- [7,9..], all (\q -> p `mod` q /= 0) [q | q <- (takeWhile (<=(ceiling . sqrt . fromInteger $ p)) primes) ] ] } in take 20 primes
00:19:32 <wli> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
00:19:42 <Lilith> shapr: did you mean "why functional programming matters"?
00:20:11 <jdrake> wli, that is scary
00:20:41 <Lilith> heh
00:20:43 <Lilith> wli: that's kinda scary for a beginner
00:21:05 <seth_> jdrake: no reason not to make a function.
00:21:27 <d33p> haskell is pretty ugly
00:22:18 <jdrake> seth_, i am going to try to write something (not in haskell directly mind you), and maybe it will resemble something that might work
00:22:24 <seth_> d33p: it is not, necessarily.
00:22:41 <Darius> [20:24] <tic_> though, haskell code is art.
00:22:41 <Darius> [20:25] <tic_> it's so beautiful
00:22:48 <seth_> d33p: it can be quite elegant.  If you don't try to produce the minimal code and instead produce readable code.
00:22:53 <d33p> seth_: my point was its not the most elegant language to read 
00:23:06 <jdrake> haskell = functional perl?
00:23:18 <d33p> perl - gross.
00:23:23 <seth_> d33p: You can write readable code.  And that should be a goal.  People tend to show off their command of the syntax instead.
00:24:04 <d33p> i see
00:24:06 <wli> Lilith: I say be flashy with Haskell's immense power; hiding it makes the stuff look mysterious.
00:25:08 <Darius> wli's example would probably be more comprehensible if it weren't all on one line
00:25:18 <seth_> wli: no, code like that scares people away.  And I won't accept anything like that from someone who works for me.
00:25:34 * Lilith laughs
00:26:06 <Darius> also Haskell does things in ways that most programmer's aren't used to, e.g. (ceiling . sqrt . fromInteger)
00:26:07 <jdrake> seth_, like the person who tries to obfuscate to make them invaluable later on because only they can understand it? (and thus gets fired after their first few lines of code)
00:26:21 <jdrake> which i don't understand how that function composition works
00:26:29 <seth_> jdrake: kind of like that.  Although the motivation here is different.
00:26:46 <Lilith> hrm
00:26:53 <Lilith> no karma for writing thesis slides
00:26:59 * Lilith creeps away
00:27:27 <wli> well at least I used \q -> p `mod` q /= 0 instead of (/=0) . mod p
00:27:43 <jdrake> how would you have a list an iterate over the elements?
00:27:51 <wli> jdrake: map
00:28:07 <wli> jdrake: or unfoldr
00:28:21 <seth_> jdrake: map, but you might want to code it first, recursively using list patterns.
00:28:52 <jdrake> list patterns?
00:29:02 <seth_> jdrake: things like (x:xs)
00:29:19 <jdrake> i do know of the x:xs thing
00:29:25 <seth_> jdrake: things like    foo [] = something
00:29:36 <seth_>     foo (x:xs) = do something with x, foo xs
00:31:17 <wli> consider qsort [] = [] ; qsort (x:xs) = qsort lo ++ [x] ++ qsort hi where (lo, hi) = partition (<=x) xs
00:31:39 <wli> [] is the empty list case
00:31:51 <wli> (x:xs) is the nonempty list case, and binds the head to x and the tail to xs
00:32:03 <jdrake> i remember that example and only understand it partly, but that is because I do not remember any of the sorting I ever learned
00:32:05 <seth_> wli: that's a _much_ better example for a newcomer.
00:32:36 <seth_> jdrake: the qsort is fairly simple.  an insertion sort is even simpler, so you might check an example of that.
00:35:00 <cfork> hello hello
00:35:16 <wli> isort [] = [] ; isort (x:xs) = insert x (isort xs) where insert x xs = lo ++ [x] ++ hi where (lo, hi) = partition (<x) xs
00:35:55 <cfork> Can I write a non-accumulative recursive function to work out the highest common factor of two arguments?
00:36:58 <cfork> or will I need a 3rd argument to act as an accumulator?
00:36:58 <wli> m `gcd` n | m < n = n `gcd` m
00:37:25 <wli> | n == 0 = m
00:37:35 <wli> | m == 0 = n
00:37:40 <jdrake> wli, in your line before with \q how does q actually get a value from outside?
00:38:06 <Darius> @type all
00:38:07 <lambdabot> all :: (a -> Bool) -> [a] -> Bool
00:38:20 <wli> | otherwise = m `gcd` (n `mod` m)
00:38:57 <cfork> I guess what I'm looking for is simply gcd itself, in Prelude :)
00:39:14 <Darius> @prelude gcd
00:39:16 <lambdabot> *** "gcd" prelude "Haskell Standard Prelude Dictionary": text follows
00:39:16 <lambdabot> gcd
00:39:16 <lambdabot>   gcd ::  Integral a => a -> a -> a
00:39:16 <lambdabot>   gcd 0 0         = error "Prelude.gcd: gcd 0 0 is undefined"
00:39:17 <lambdabot>   gcd x y         = gcd' (abs x) (abs y)
00:39:19 <lambdabot>   		  where gcd' x 0 = x
00:39:21 <lambdabot>   			gcd' x y = gcd' y (x `rem` y)
00:39:30 <cfork> wow, excellent bot!
00:39:51 <wli> okay I had a bogon =)
00:39:52 <jdrake> that all thing doesn't tell me anything
00:40:29 <Darius> all is a higher-order function, it takes a function as it's first argument.  All gives q it's value
00:40:58 <jdrake> and where does all get its value
00:41:19 <Darius> It's applied to a list
00:54:03 <wli> Hmm
00:54:18 <wli> how to make it generalizable over rational functions
00:56:42 <wli> they could be recurrences in R[x] for polynomials not depending on n
00:57:11 <wli> they could be recurrences in (R[n])[x] for polynomials depending on n in a polynomial fashion
00:57:31 <wli> they could be recurrences in (R(n))[x] for polynomials depending on n via rational functions...
01:00:35 <wli> (R is a mostly arbitrary ring, perhaps constrained to a division ring for R(n))
01:06:19 <jdrake> have you ever seen this character? http://members.rogers.com/jpt.d/friend.jpg
01:17:23 <jdrake`sleep> can haskell, be made into art? http://www0.us.ioccc.org/2001/cheong.c
01:20:12 <wli> Legendre functions need rational functions of n, Hermite only need polynomials; getting a typeclass to generalize this looks painful
01:21:11 <wli> Apery numbers also need rational functions of n
01:24:44 <Darius> jdrake: iohcc.mgoetze.net particularly Pseudonym's example
01:57:27 <cfork> shapr, did you write a Banana encoding thing for Haskell?
01:57:33 <cfork> ie Twisted?
02:42:14 <cfork> hrmm can't get this lambdabot to work
03:05:49 <shapr> cfork: y0
03:06:00 <shapr> cfork: yes, I wrote part of TwistedHaskell
03:16:59 <reltuk> What's TwistedHaskell?
03:20:46 <Riastradh> A port of the Twisted framework to Haskell.
03:22:39 <cfork> hihi
03:23:11 <cfork> hmm I can't get lambdabot to work
03:23:28 <Riastradh> What isn't working about it?
03:24:30 <cfork> Running reader loop...
03:24:38 <cfork> Exception: end of file
03:24:49 <cfork> hGetChar
03:24:53 <cfork> socket: 52
03:26:14 <cfork> I really don't know what it could be
03:26:47 <Riastradh> It means that the socket received an EOF.
03:28:04 <cfork> yes
03:28:13 <cfork> but that doesn't help me :(
03:29:07 <cfork> I mean in trying to fix it
03:34:03 <Marvin--> shapr: random thought, maybe we should have a @fact for listing who's going to HW2003?
03:34:10 <shapr> good idea
03:34:59 <cfork> hmm, I really have no idea about debugging in Haskell
03:35:18 <cfork> How would I go about trying to find out why lambdabot isn't working I wonder..
03:35:22 <shapr> cfork: try running the executable again
03:35:28 <cfork> done that :)
03:35:31 <Marvin--> argh
03:35:34 <Marvin--> god I hate icq
03:35:39 <cfork> not as bad as msn
03:35:52 <cfork> I tend to turn it off as I'm sick of spam messages
03:35:53 <shapr> cfork: have you changed the BotConfig.hs values?
03:35:57 <cfork> yep
03:36:09 <Marvin--> shapr: should we just call the factoid HW2003?
03:36:20 <shapr> Marvin--: sure, as soon as I ressurect @fact
03:36:24 <Marvin--> shapr: oh :)
03:37:03 <cfork> I suspect if I try it on the Linux computer it will work fine
03:37:15 <cfork> but surely I can make it work on this one
03:37:17 <shapr> cfork: Darius has used lambdabot on win32
03:37:26 <Marvin--> wonder if gaim works
03:37:33 <cfork> he didn't mention any wierd eof from socket?
03:37:51 <shapr> nope
03:37:59 <shapr> I've gotten that sometimes though
03:38:11 <shapr> but I don't remember how I fixed it.
03:38:41 <cfork> does lambdabot work on any haskells besides ghc?
03:39:19 <shapr> not at the moment
03:39:25 <shapr> it requires GHC specific extensions.
03:39:53 <shapr> cfork: I'd suggest you check to see if a simpler network program works with your GHC, maybe http://kungens.kemi.fi/~shae/src/haskell/Echo2.hs
03:42:20 <cfork> can't find module MVar
03:42:35 <shapr> are you using -package concurrent ?
03:42:41 <cfork> nope
03:42:54 <shapr> the top few lines of that .hs file tell you how to build it.
03:43:02 <cfork> ah :)
03:45:02 <cfork> Compiles fine, but when run: Fail: does not exist Action: getProtocolByName
03:45:08 <shapr> hm
03:45:24 <cfork> no such protocol entry
03:48:06 <cfork> ssock <- listenOn ((PortNumber portnum) :: Network.PortID)
03:48:11 <cfork> fails on that line
03:49:14 <shapr> that's strange
03:49:22 <shapr> it shouldn't be trying to get that protocol by name.
03:50:08 <shapr> which version of GHC do you have installed?
03:50:31 <cfork> 5.04.3
03:52:22 <cfork> hmm I guess I should just forget about it
03:53:06 <shapr> sorry, they both work fine here :-/
03:53:18 <cfork> :)
03:53:19 <shapr> I can't immediately see why they're not working on win32
03:53:40 <shapr> I would guess the getProtocolByName is trying to look into your /etc/protocols files for the number
03:53:50 <shapr> but it shouldn't be doing that
03:54:24 <cfork> there isn't some debugger to go thru line by line?
03:54:39 <shapr> you can try buddha or hat
03:55:24 <wli> As the imperative concept of debugger is not meaningful for lazy languages declarative ones are used.
03:55:43 <shapr> yah, truly
03:56:31 <Riastradh> Could you not have a step-by-step continuation tracer?
03:56:36 <cfork> its nice to get stack traces telling you where the error is :) I'll try hat and buddha
03:56:37 <shapr> Riastradh: write it!
03:56:38 <wli> yes
03:56:46 <wli> it's not meaningful
03:56:48 <shapr> cfork: thing is, stack traces from GHC won't help you at all
03:56:56 <Riastradh> Bah!  Stack?  That's for silly people who don't use CPS!
03:57:25 <shapr> Haskell is specifically about not specifying order so that the compiler can optimize in many ways that procedural languages would not allow.
03:58:44 <Riastradh> shapr - I haven't the faintest idea how to write a continuation tracer, though, especially since I haven't the faintest idea how GHC's internals with continuations work.
03:58:48 <wli> there is in principle a stack of things being forced to be evaluated
03:58:49 <shapr> cfork: there are ways that you can insert debug/print statements 'directly' into the code, sometimes the print statements you would expect to happen 'later' actually print out first. it's very bizarre.
03:59:28 <wli> i.e. the spine
03:59:42 <cfork> mkay
03:59:42 <cfork> brb
04:01:57 <wli> I'm actually unsure if the spine is 1:1 with the evaluation stack
04:04:03 <cfork> hmm
04:04:19 <cfork> trying to install ghc on my linux- I take it I need a haskell to bootstrap it
04:04:25 <wli> but the evaluation stack is absolutely not a clear indicator of what's being executed
04:05:07 <shapr> cfork: which linux distro are you using?
04:05:11 <wli> it's also difficult to correlate to source IIRC
04:05:30 <cfork> shapr: archlinux
04:05:43 <shapr> don't know much about it
04:06:37 <wli> it'd be _moderately_ useful
04:06:48 <wli> (once correlated to source)
04:07:34 <cfork> now this is odd.. the capitalisation of my keyboard was randomising
04:08:14 <shapr> cool!
04:08:24 <cfork> I Am TYPING WITHOUT SHIFT
04:08:28 <cfork> OR CapS LOCK
04:08:46 <shapr> lovely
04:08:59 <cfork> I have absolutaly no idea whats going on...
04:17:03 <shapr> cfork: sounds like you have both linux and windows installed, but you're currently more comfortable with windows
04:17:23 * shapr is guessing
04:17:24 <cfork> heh, actually I use custom-University software
04:17:26 <shapr> oh
04:17:33 <cfork> which runs on windows
04:17:43 <shapr> have you tried wine or winex?
04:18:00 <cfork> hmm I have in the past
04:19:23 <cfork> I'll forget about lambdabot for now, and give it a try when the next version of ghc comes out
04:19:45 <wli> I'd like a deb of a more recent ghc
04:20:29 <shapr> me to
04:20:42 <cfork> To get large files (eg ghc binary dist), I have to actively request it to be mirrored
04:20:45 <shapr> cfork: I'll see if I can get lambdabot running on my woman's win98
04:20:53 <cfork> mkay
04:22:05 <shapr> I could file a wishlist bug for ghc5
04:22:22 <shapr> oh, it already has one.. 51 days old
04:23:55 <cfork> hmm?
04:24:21 <cfork> bug report already filed?
04:24:47 <shapr> cfork: we're talking about debian linux ghc5
04:25:45 <Kokko> hello
04:25:45 <cfork> oh
04:26:01 <cfork> hi, Kokko
04:27:57 <shapr> bonjour Kokko
04:28:01 <shapr> comment ça va?
04:28:03 <Kokko> bonjour
04:28:05 <Kokko> tres bien
04:28:19 <Marvin--> @listmodules
04:28:19 <lambdabot> I have the following modules installed: ["chess","dict","eval","fortune","hello","karma","more","state","system","topic","type","yow"]
04:28:40 <shapr> Kokko: Haskell questions?
04:28:50 <Kokko> in fact
04:28:56 <shapr> Kokko: Weren't you writing an SDL binding for Haskell?
04:29:03 <Kokko> yes
04:29:05 <shapr> aha
04:29:05 <Kokko> I was
04:29:38 <Kokko> I'm trying currently with the Head branch 
04:29:54 <Kokko> to compile my binding
04:30:03 <cfork> Darius, I don't suppose you are alive?
04:30:22 <shapr> Kokko: is it working?
04:30:23 <Kokko> but it is less good than the other binding for sdl
04:30:23 <Riastradh> No, Darius died a few hours ago from severe Haskell overdose.
04:30:30 <Kokko> not for the moment
04:30:46 <Kokko> In fact, I am trying to find a conenient way of binding
04:30:50 <shapr> Riastradh: heh
04:30:53 <Kokko> the #define for keymap in SDL
04:31:25 <Kokko> Does anybody know how -M works with recent GHCs ?
04:31:46 <shapr> what's recent? 5.04 ? 5.05 ?
04:31:59 <Kokko> 5.04
04:32:01 <Kokko> .3
04:32:12 <shapr> what does -M do? :-)
04:32:20 <Kokko> I can't find this option in the user's guide
04:32:48 <Kokko> -M is creating dependencies, something like that, isn't it?
04:32:57 <shapr> oh yah
04:33:01 <wli> I want 5.05
04:33:09 <shapr> wli: it's cool :-)
04:33:28 <shapr> wli: want me to tjz my source dir and send it to you?
04:33:46 <wli> source won't help
04:33:54 <wli> my currently installed ghc can't compile any ghc
04:33:57 <wli> for reasons unknown
04:34:04 <shapr> I built 5.05 with 5.04.2 from debian/unstable
04:34:08 <wli> which is why I want a binary
04:34:11 <shapr> oh
04:34:14 <wli> I'm not using 5.04.2
04:34:17 <shapr> I see
04:34:27 <Marvin--> shapr: debian gnu/unstable? ;)
04:34:27 <wli> maybe I have to upgrade twice to get there.
04:34:39 <shapr> Marvin--: yah, something like that
04:35:30 <shapr> Marvin--: hej, hur säger du web development på svenska? web mjuk-something ?
04:35:43 <tic_> web-programmering.
04:35:59 <shapr> ah, what's the mjukvaru-something?
04:36:00 <Marvin--> shapr: webbutveckling
04:36:05 <Marvin--> tic_: argh
04:36:19 <Marvin--> shapr: mjukvara == software?
04:36:22 <shapr> ah yes
04:36:23 <tic_> yup.
04:36:30 <tic_> Marvin--, well, true.
04:36:40 <shapr> mjukvaru utveckling is software development?
04:36:42 <tic_> Marvin--, I don't like the idea of "development" and "web" together at all. :)
04:36:44 <Marvin--> "vad gör du?" "jag kodar html"
04:36:47 <tic_> shapr, mjukvaruutveckling
04:36:50 <tic_> Marvin-- , :D
04:36:51 <Marvin--> shapr: yes, but mjukvaruutveckling
04:36:51 <tic_> shapr, but yeha.
04:36:58 <Marvin--> shapr: skrivihop.nu ;)
04:37:00 <tic_> Marvin--, smurf!
04:37:36 <shapr> tack
04:38:24 <cfork> hmm if anyone else got lambdabot going on windows ghc, let me know
04:39:00 <wli> just run linux or *BSD
04:40:02 <cfork> wli: I'm have to go thru a whole rigmarole to get large files, as I live in Australia :(
04:40:11 <cfork> with our capped internet
04:40:31 <cfork> In other words, I am waiting for ghc binary to be mirrored
04:40:43 <shapr> cfork: can you organize a mirror proxy service?
04:40:55 <cfork> hmm?
04:41:26 <shapr> as in, can you get together with a bunch of other people and organize a local mirror for that sort of stuff?
04:41:40 <shapr> what about the .au mirror of sourceforge? might it have the latest ghc5 for windows?
04:43:05 <wli> minimal linux distros fit on floppies =)
04:43:38 <cfork> On Telstra (Australia's main ISP), you get tiny amounts of bandwidth
04:43:42 <cfork> except on free sites
04:44:01 <cfork> free sites include a file library, for which you can request files
04:44:46 <wli> sorry your ISP sucks, move somewhere there's a better one
04:45:06 <cfork> heh. there is no real uncapped ISP (broadband) in Australia
04:45:14 <cfork> We pay through the nose to get data from America
04:45:19 <wli> move out of australia =)
04:45:39 <Marvin--> sounds like australia is broken
04:45:43 <cfork> nah :) best country in the world mate :)
04:45:43 <Marvin--> well, we already knew that, but...
04:46:40 <cfork> its not broken as such...
04:46:56 <cfork> Telstra is by far the most profitable telecommunications company in the world
04:47:06 <Marvin--> because they screw their customers :)
04:47:14 <cfork> well, yes
04:47:25 <shapr> cfork: so organize a satellite feed
04:47:31 <cfork> ?
04:47:40 <cfork> satellite is much more expensive than ADSL
04:48:04 <shapr> even uncapped?
04:48:29 <cfork> satellite isn't uncapped!
04:49:06 <reltuk> move to an American university...they have obscene bandwidth
04:49:06 <shapr> can you get a satellite feed that's not connected to Telstra?
04:49:12 <Marvin--> hahaha
04:49:17 <reltuk> even with all the college kids downloading/uploading music all the time
04:49:19 * Marvin-- reads funny quotes from Twisted.Quotes
04:49:28 <shapr> Marvin--: hey I'm in there too!
04:49:39 <Marvin--> shapr: I know, I just read your jdk1.4/mach quote
04:49:44 <shapr> oh, heh :-)
04:49:46 <tic_> Marvin--, dtek student?
04:49:55 <wli> jdk1.4 is ported to mach?
04:50:12 <cfork> "In Australia we are paying the cost of Americans accessing our content,"
04:50:25 <shapr> <shapr> itamar: I've heard jdk1.4 is using a modified version of the mach kernel...
04:50:25 <shapr> <itamar> hahahahah
04:50:25 <shapr> <itamar> you're kidding, I hope
04:50:25 <shapr> <shapr> itamar: see, YOU'RE NOT SURE
04:50:25 <Marvin--> tic_: no, computer science @GU
04:50:30 <cfork> "At the moment we are subsidising Americans' use of the Internet"
04:50:34 <tic_> Marvin--, ah, doh.  
04:53:36 <shapr> hola kl4rk 
04:53:41 <kl4rk> enas
04:54:04 <Kokko> have someone here ever used Yampa?
04:54:07 <shapr> me me!
04:55:47 <Kokko> is that good?
04:55:55 <shapr> Yampa is spiffy
04:56:04 <shapr> kl4rk: learningHaskell?
04:56:09 <Kokko> what do you mean by spiffy?
04:56:10 <shapr> kl4rk: have questions that need answering?
04:56:13 <kl4rk> yes
04:56:31 <kl4rk> lots of querstions hehe
04:56:34 <shapr> Kokko: spiffy means to me, something of pleasing and/or surprising amounts of quality
04:56:45 <Kokko> ok
04:56:52 <Kokko> it seems very good to me yampa
04:56:56 <shapr> I agree
04:57:01 <Kokko> but as I am not able of compiling HGL
04:57:10 <Kokko> I can't test very much
04:57:15 <shapr> I can probably help you with that, but not right now
04:57:28 <shapr> I have to go to a doctor's appointment in a bit.
04:57:33 <Kokko> ok
04:58:08 <Kokko> I read papers on yampa and arrows, it seems, as youy say, spiffy
04:58:15 * shapr grins
04:59:22 <cfork> kl4rk: Ask me the questions, Bridge Keeper. I am not afraid.
04:59:43 <kl4rk> thx
05:00:01 <kl4rk> i'm trying to figgure out what to ask first : )
05:01:24 <cfork> Just when your ready :) The inhabitants of this channel range from smart people, to "learning", like me :)
05:02:17 <Kokko> there are even people not able to use configure/make, likeme
05:02:18 <Kokko> :)
05:33:48 <Igloo> Umm diddle
05:34:06 <cfork> ?
05:34:18 <Igloo> I hate trying to make references
06:14:55 <cfork> hmm trying to write a function that takes 2^n
06:15:03 <cfork> but based on the oddness or evenness of n
06:20:23 <kosmikus> cfork: yes?
06:22:11 <cfork> kosmikus: heh nm, just an exercise in a textbook
06:22:30 <cfork> (no, I'm not taking haskell atm, just trying to learn it)
06:22:47 <tic_> kosmikus, http://www.dtek.chalmers.se/~tic/cgi-bin/ptc-lab4/Main.cgi -- works now
06:23:02 <tic_> kosmikus, esp. the "sök efter..." stuff. (search)
06:23:08 <kosmikus> tic_: great
06:23:12 <tic_> http://www.dtek.chalmers.se/~tic/cgi-bin/ptc-lab4/Search.cgi
06:23:15 <tic_> kosmikus, yup. ): 
06:23:15 <tic_> :)
06:23:23 <tic_> kosmikus, took me a while to realize how I should do it in Haskell.
06:23:40 <tic_> kosmikus, I usually think of problems as "do much in one chunk", whereas Haskell is "do little in many chunks"
06:24:33 * kosmikus just checks tic_'s program ...
06:24:55 <kosmikus> cfork: what's the problem?
06:26:02 <cfork> kosmikus: I don't understand what this exercise question is asking- it wants me to write a function to return 2 squared by n, but using the fact that 2^n = 2^(2*m+1) if n is odd
06:26:18 <cfork> 2^n is fine.. but the odd even thing
06:26:19 <kosmikus> tic_: looks good
06:26:36 <tic_> thanks. :)
06:27:27 <kosmikus> cfork: the idea is that it is more efficient because you minimize the number of multiplications
06:28:47 <kosmikus> for instance, if I want to compute 2^5, then 2*2*2*2*2 are four multiplications ...
06:29:10 <kosmikus> ... whereas (2^2)^2 * 2 are only three.
06:30:08 <cfork> ok
06:37:12 <syntax-laptop> good morning all
06:38:01 <kosmikus> good afternoon, syntax-laptop 
06:39:56 <syntax-laptop> I thought it was always morning on IRC :)
06:43:35 <kosmikus> okay, then :) good morning, syntax-laptop
06:44:00 * d-bug wonders how the new matrix game can have graphics like this: http://members.shaw.ca/nervx/matrixcar.jpg
06:47:53 <tic_> hahaha
06:48:55 <reltuk> it probably has something to do with the fact that it runs on so many consoles
06:49:18 <reltuk> but that tire is outright embarassing
06:49:24 <d-bug> reltuk: but PSX and N64 are not among those
06:50:02 <d-bug> it's probably just a bug in the matrix, or that the matrix doesn't know what "round" :)
07:03:48 <o3> there is no round!
07:04:00 <o3> round is just an abstract figment of our imaginations
07:04:25 <ejt> hi all, more stupid questions ...
07:04:55 <ejt> can I acccess tuples using an index ?
07:05:33 <tmoertel> d-bug: its because the road is made up of linked catenaries ?
07:06:19 <tmoertel> d-bug: http://home.att.net/~mathtrek/muse0299.htm
07:07:53 <o3> ejt: hmm, no functions to do that in the prelude
07:08:07 <o3> but you could write some functions to do it
07:08:16 <ejt> hmm
07:08:25 <ejt> lets say I'm writing a chess prog.
07:08:47 <ejt> in C I would just represent the board as 8, 8 element rows
07:09:00 <ejt> would you still do this in haskell ?
07:09:15 <ejt> or is there another idiom I'm missing ?
07:10:09 <syntax-laptop> o3: as far as I know, you can't write a function general enough to index a touple. What would its type be?
07:10:42 <d-bug> tmoertel: interesting :)
07:10:45 <tmoertel> syntax-laptop: you can if the number of elements in the tuple is fixed
07:10:57 <tmoertel> syntax-laptop: (or, if you're using template haskell)  ;-)
07:11:06 <o3> syntax-laptop: hmm, you definitely can in template haskell
07:11:17 <o3> or define a typeclass
07:13:22 <syntax-laptop> I don't know template haskell :) Of course I realize that you could write something if the num elements is fixed, wihch is what I meant by 'general enough' :)
07:13:30 <syntax-laptop> out of curiosity, how would one do it in template haskell?
07:14:59 <syntax-laptop> o3: is there some way a typeclass would prevent you from having to enumerate an infinite number of cases?
07:15:27 <syntax-laptop> ejt: you can do such a thing more cleanly with lists in Haskell98.
07:15:29 <o3> syntax-laptop: no, but i don't think GHC has support for more than 63 things in a tuple anyway
07:15:32 <o3> (that's just getting silly)
07:15:51 <o3> you could also get hardcore and use lists, and use phantom types to ensure that your lists are always 8 elements long
07:15:57 <tmoertel> syntax-laptop: see the example in "Template metaprogramming for Haskell": http://research.microsoft.com/Users/simonpj/papers/meta-haskell/
07:16:00 <ejt> syntax-laptop: k, I'll try with lists :)
07:16:02 <syntax-laptop> ejt: you can use the (!!) operator: [1..10] !! 3 => 4
07:16:07 <o3> ejt: i'd just use a list
07:16:27 * ejt scales the problem down tonaughts and crosses (tic-tac-toe)
07:17:34 <tmoertel> syntax-laptop: the example is for zipN, but you'll get the point
07:18:45 <syntax-laptop> I'll check that out.
07:25:37 <pesco> All Hail.
07:26:06 <CowGirl> syntax-laptop.....are u running linux??
07:28:10 <syntax-laptop> CowGirl: yes. I'm running Debian GNU / Linux.
07:28:43 <CowGirl> what kinda of laptop??...what are the specs???  i want to install mandrake or redhat on my gateway..
07:29:05 <norpan> let's build license information into the type system for haskell!
07:29:10 <syntax-laptop> CowGirl: I have a gateway 450x
07:29:12 <CowGirl> did look up compatibility on the internet....was some info...but just wondering what an actually user says about it?
07:29:36 <norpan> with subtyping relations MIT/X11 < LGPL < GPL and so on L:)
07:29:52 <CowGirl> mines an SL 9100....bought it 1997... u know if thats compatible??
07:30:51 <CowGirl> i mean will either mandrake or redhat run on a 266mhz mmx,  64mb, 8 gig hd
07:31:09 <CowGirl> with minimal problems?
07:31:37 <syntax-laptop> CowGirl: I would suspect GNU / Linux would run well on a machine like that, if a little slow. you might try www.google.com/linux
07:32:31 <CowGirl> ok...i think it should be fine.  what about if the hard drive was 4 gig..with only windows loaded on it, and no other software??  i have a second hard drive..
07:32:57 <CowGirl> will 4 gig be enough?? on the same machine?
07:34:50 <syntax-laptop> 4 gigs is enough to run GU/Linux.  I used to split a 3 gig hard drive between mac OS and Linux.
07:35:54 <CowGirl> ok....thanx...think i will give them ago then....just wanted to make sure!
07:37:54 <syntax-laptop> 8 gigs would be better of course  :)
07:41:51 <cfork> actually 1.44 meg is enough to run a quite functional Linux system :)
07:42:36 <syntax-laptop> cfork: have you seen knoppix? It runs live from a CD.  Pretty neat :)
07:43:42 <CowGirl> the 8 gig hd has all my files that i need, and is the main hd,  the 4 gig is just a spare, dont want to risk losing anything...so will try it out on 4 gig first
07:43:48 <CowGirl> so i know what im doing
07:45:44 * shapr boings
07:45:55 <andersca> shaprrrrr
07:46:04 <shapr> y0 andersca 
07:46:07 <shapr> g'day Lilith 
07:46:22 <Lilith> hullo shapr
07:46:33 <Igloo> I hate everyone!
07:46:40 <shapr> Igloo: that's okay, we love you anyway.
07:46:46 * shapr hugs Igloo 
07:47:04 <Lilith> awwrr
07:47:43 <shapr> Igloo: can I help you make references?
07:48:45 <Igloo> No
07:49:02 <shapr> ok
07:49:05 <shapr> something else I can do?
07:49:31 <Igloo> Hunt down researchers who don't have correct bibtex entries on their webpages and kill them off, one by one
07:49:59 * shapr writes a lambdabot plugin to do that
07:50:24 <shapr> they shall forever be denied access to the intarweb!
07:50:36 <Lilith> heh
07:50:49 <Lilith> haskell.org needs a search engine
07:50:52 <shapr> yah
07:50:53 <Igloo> But then they will *never* be able to give me bibtex entries!
07:51:03 <shapr> Igloo: but... if they're dead... that won't help either.
07:51:22 <shapr> maybe the lambdabot plugin should make automated calls and emails to them until they correct their bibtex entries?
07:51:30 <Igloo> Details, details
07:51:40 <shapr> Yes, I can see it now... bibtex spam!
07:52:00 <shapr> Lilith: quick, write one...
07:52:17 * Lilith blinks
07:52:19 <shapr> actually, I could probably write a cheesy search engine based on the mailing list search plugin
07:52:26 * Igloo will work on references earlier next time so I have time to e-mail people. I didn't realise what hell it was
07:52:26 * shapr thinks about it...
07:52:37 <Lilith> well, you could use the google API
07:52:40 <Lilith> i was thinking about it
07:52:55 <Lilith> but i figure now isn't a good time to procrastinate ;-)
07:53:18 <shapr> I'm on the path towards a google plugin for lambdabot 
07:53:23 <shapr> but it'll be a few weeks at least
07:53:31 <shapr> I'm going to SOAP via XML-RPC
07:53:39 <shapr> probably with the HXmlToolbox
07:54:23 * Lilith counts 2 buzzwords on the same line
07:54:46 <pesco> shapr: Interesting, Google has a SOAP interface?
07:54:52 <pesco> What does SOAP stand for?
07:54:59 <Lilith> ok. i was going to write a generic search function based on infobot
07:55:00 <shapr> simple object application procotocl
07:55:01 <andersca> simple object access protocol
07:55:04 <shapr> oh
07:55:04 <andersca> oh, right
07:55:06 <andersca> shapr wins
07:55:06 <shapr> access
07:55:10 <shapr> did I?
07:55:14 <shapr> @jargon soap
07:55:17 <lambdabot> No match for "soap".
07:55:17 <syntax-laptop> shapr: are you finally writing me an xml-rpc for Haskell?
07:55:23 <shapr> syntax-laptop: yes, finally :-)
07:55:30 <syntax-laptop> shapr: woohoo!
07:55:31 <shapr> syntax-laptop: haxml couldn't do it, but HXmlToolbox can
07:55:50 <andersca> woo, it's access :)
07:55:56 <syntax-laptop> shapr: thats good.  I'm going to write some advogato junk in Haskell for managing diaries when you do that :)
07:56:02 * shapr gives the gold star to andersca 
07:56:10 <shapr> syntax-laptop: oh, excellent
07:56:19 <pesco> Now what's the relation between SOAP and XML-RPC?
07:56:20 <shapr> does livejournal have an xmlrpc or soap connection?
07:56:33 <shapr> pesco: xmlrpc is dead simple, and about as useful
07:56:44 <shapr> soap is a lot more complicated, but more useful
07:56:51 <pesco> Aha.
07:57:01 <shapr> they're both wannabe ASN.1-style formats that use XML instead of bit-level encoding.
07:58:16 <shapr> have you guys seen mark carroll's licensing post on haskell@haskell.org ?
07:58:36 <pesco> What's the advantage of XML over ASN.1 et al?
07:58:50 <shapr> you can use notepad on XML?
07:59:07 <pesco> Er.
07:59:32 <shapr> it's probably great if you're trying to debug a protocol by looking at the packets that go by on the wire
07:59:46 <shapr> ASN.1 has an XML encoding, namely XER
08:00:10 <pesco> WHY? Why does everything need XML?
08:00:12 <shapr> it's also for debugging, since asn.1 is very difficult to understand
08:00:29 <shapr> pesco: have you read The Pragmatic Programmer?
08:00:30 * syntax-laptop looks at mark carroll's post, then looks across the room at mark carroll
08:00:39 <shapr> syntax-laptop: you *know* mark carrol?
08:00:40 <pesco> shapr: No, what does it say?
08:01:07 <shapr> pesco: one section talks about the power of human readable text in programming.
08:01:28 <syntax-laptop> shapr: I work w/ mark.
08:01:43 <shapr> I think the two strong points of XML are that it's both human and computer readable, and that it's totally tree structured.
08:02:01 <pesco> shapr: Ok, I see.
08:02:06 <shapr> the 'formatted/typed' part where it corresponds to a DTD or XSchema can also be nice.
08:02:33 <shapr> pesco: thing is, that means there are lots of application domains where XML totally sucks ass
08:02:39 <shapr> sadly, many people have not realized that.
08:02:44 <pesco> heh
08:02:47 <shapr> syntax-laptop: cool :-)
08:03:01 <shapr> I have an interesting reply to mark's licensing post.
08:03:15 <syntax-laptop> shapr: what do you think about the post?
08:03:28 <shapr> I think there's a way to satisfy both hats with GPL
08:03:36 <pesco> I'm going to write a CDR (I think that's the name) codec so I can talk to CORBA objects.
08:03:43 <shapr> namely, "Software is a service"
08:03:51 <shapr> IDL?
08:03:55 <shapr> IIOP?
08:04:16 <shapr> syntax-laptop: hey, does mark carrol show up here on #haskell?
08:04:47 <pesco> IDL -> Types -> Values -> CDR encoded Values -> IIOP messages
08:05:00 <shapr> oh, I know nothing about CDR
08:05:36 <pesco> IIRC it's pretty much like ASN.1 - does that make sense?
08:05:44 <shapr> sounds like xmlrpc would fit into the CDR level, and soap would fit into the IDL level
08:06:02 <shapr> I'll look up CDR at some point and find out.
08:06:04 <shapr> hi jak 
08:06:25 <jak> hi shapr
08:06:29 <syntax-laptop> shapr: I'll be interested to read your post.  I think the GPL can encourage a company to modularize their code and release pieces that can be broken apart from the core.
08:06:35 <syntax-laptop> shapr: no, mark doesn't hang out here.
08:06:46 <shapr> syntax-laptop: sounds like you have more to say about that than I do..
08:07:02 <shapr> I'm not sure where to go after saying "Software as a service means the GPL satisfies both hats"
08:07:12 <syntax-laptop> mark & I partitino ourselves thusly: I hang out on #haskell and read slashdot, he reads newsgroups and mailinglists more carefully.
08:07:24 <shapr> heh
08:07:27 <syntax-laptop> then we chat over the coffee press and tell eachother the interesting stuff.
08:07:30 <shapr> neat
08:07:46 <shapr> I thought mark carroll was a big lisp guy?
08:07:57 <shapr> I'm not sure of that though.
08:08:02 <syntax-laptop> no. you might be thinking of another OSU guy, cmcurtin.
08:08:06 <shapr> maybe so
08:08:19 <shapr> scheme maybe?
08:08:24 * shapr shrugs
08:08:28 * syntax-laptop shrugs too
08:08:53 <pesco> Oh, how I love reading OMG specs.
08:08:57 <andersca> ugh
08:08:59 <andersca> :)
08:09:37 <pesco> grmbl... *flaps open some huge PDF*
08:10:06 <shapr> Marvin--: hey, doesn't python dist-utils include licensing?
08:21:11 <andersca> ok
08:21:17 <andersca> time to switch alt and alt gr
08:21:21 <andersca> how do I reprogram that shapr
08:21:42 <shapr> xkeycaps -kbd kinesis
08:22:40 <andersca> can't I do it in the hardware?
08:22:55 <Lilith> ooh
08:23:13 <shapr> andersca: yes, I think so
08:23:26 <Lilith> one learns something new everyday
08:23:38 <shapr> but one of my kinesis keyboards doesn't have any memory, so I haven't tried that.
08:23:42 <andersca> woohoo, it works
08:23:44 <shapr> Lilith: what did you learn?
08:24:04 <Lilith> shapr: that xkeycaps exist. i usually use xmodmap
08:24:09 <shapr> oh
08:24:15 <shapr> xmodmap is a bit more manual
08:24:21 <shapr> but xkeycaps outputs xmodmap files
08:25:04 <Lilith> shapr: did you say you wanted my job? you can have it
08:25:12 <Lilith> </just joking>
08:25:13 <shapr> sadly, I can't
08:25:16 <pesco> xkeycaps, yet another cool program by jwz.
08:25:18 <shapr> I doubt they allow teleworkers ;-)
08:25:59 <shapr> Lilith: I've seen some GHC to JVM bytecode stuff in the GHC cvs HEAD, is that related to what you're doing?
08:27:54 <Lilith> shapr: whereabouts?
08:28:59 * Lilith is reading papers on thunks now. yay
08:33:16 <Lilith> oh
08:33:19 <Lilith> i see
08:35:09 <Lilith> yes
08:42:52 <shapr> Lilith: so that's where your code will show up?
08:43:10 <Lilith> i...suspect so
08:43:11 <shapr> I thunk about it carefully ;-)
08:43:14 * shapr grins
08:43:20 <shapr> I always thought thunk was a silly word.
08:44:04 <Logan> Who'dathunkit?
08:44:10 * shapr snickers
08:44:28 <Lilith> shapr: i don't really know. right now it's separate. so it depends on what manuel says
08:46:04 <o3> complexity sucks
08:46:17 <shapr> simplicity can be fun
08:46:35 <o3> or rather, managing complexity sucks
08:46:38 <shapr> I try to balance out my thoughts of monads and arrows by playing with ballbearings
08:47:00 <o3> (and if anybody is going to mention hofstadter, bite me)
08:53:01 <o3> simon peyton-jones is a legend
08:53:12 <shapr> in more ways than one ;-)
08:54:01 <Lilith> shapr: how'd you know, eh?
08:54:17 <shapr> what, about SPJ?
08:54:23 <o3> how on earth does he find the time to work on ghc, do talks, respond to all haskell mail and write papers all at once
08:54:23 <Lilith> o3: hofstadter. (byte me!)
08:54:31 <shapr> o3: truly, he can't possibly sleep.
08:54:48 <Segora> shapr: Maybe he's the first true AI? ;)
08:54:52 <shapr> heh, maybe so.
08:55:07 <shapr> I'm beginning to think I spend too much time on IRC...
08:55:19 <shapr> I have ops on #haskell, #python, #java, and #emacs
08:55:25 <shapr> and a few other channels
08:55:55 * Lilith groans
08:56:01 <o3> shapr: no #perl?  you loser!
08:56:10 <shapr> last time I joined a #perl channel I got banned.
08:56:15 <Lilith> deadline bot
08:56:17 <o3> and where's #intercal
08:56:21 <Lilith> shapr: hehe. how come?
08:56:29 <shapr> admittedly, that was also the first time I joined a #perl channel
08:56:38 <reltuk> shapr : what'd you do?   :-p
08:56:42 <shapr> so immediately after that I joined #python for the first time
08:56:44 <Lilith> #erlang is a damn boring channel
08:56:44 <shapr> and also got banned
08:57:06 <shapr> reltuk: no one was saying anything, so I said hello in twelve languages
08:57:25 <shapr> oh, on #perl I asked which editor gave me syntax highlighting for perl
08:57:34 <shapr> so they said real men don't need colors and /kb'ed me
08:57:49 <tmoertel> shapr: what?  that's not the Perl Way
08:57:55 <tmoertel> sad
08:58:04 <reltuk> haha
08:58:06 <shapr> well, it convinced me I didn't want to join that community
08:58:16 <Segora> shapr: ah, now we know where all those useless 'HTML programmers (yuck)' hang out. ;)
08:58:18 <tmoertel> I guess that's why I don't write as much Perl as I used to.
08:58:37 <shapr> sadly, the Python community is slowly moving in the same direction.
08:58:52 <shapr> the Haskell community is totally free of that so far.
08:58:53 <o3> shapr: /msg #perl i was actually looking for realtime syntax highlighting for cat (as in 'cat > foo'), but never mind, you're obviously all too hardcore for me
08:59:00 <reltuk> Ruby's great (the community is still great too)
08:59:23 <Lilith> too many damn languages
08:59:27 <Lilith> and too many suck
08:59:44 <reltuk> can't help the fact that some/most suck :-p
08:59:50 <o3> s/languages/forall. a/
09:00:00 <o3> s/languages/forall. a => a/
09:00:01 <o3> even
09:00:08 <o3> or, err
09:00:11 <o3> no, the first one was right
09:00:17 * o3 frowns
09:00:20 <shapr> I like the Haskell community, it's small, intelligent, and friendly.
09:00:24 <Lilith> you want that v sign
09:00:44 <Lilith> v with a horizontal bar, that will do ya
09:00:54 <o3> i should get a native mac os x irc client just so i can write a proper forall character
09:01:06 <shapr> o3: tried hircules?
09:02:15 <shapr> so, I've decided the secret to finding programmers worth knowing is to find the smaller communities where you can really get to know people, and then keep track of those people when the communities change.
09:02:17 <o3> not yet :).  thesis due in a few weeks, no time to muck around
09:02:19 <Lilith> hehe
09:02:40 <o3> i even gave up seeing matrix on the weekend so i could work on it
09:02:41 * Lilith counts down
09:02:46 <Lilith> o3: wow. good boy
09:02:51 <shapr> yah, I'm impressed.
09:02:59 <Lilith> i'm swimming in papers now
09:03:15 <Lilith> anyone want to read my not quite existent slides?
09:03:16 <Lilith> :>
09:03:19 <tmoertel> it's better than drowning   ;-)
09:03:20 <shapr> me me!
09:04:29 <Lilith> do you want to see the .tex or the .ps file 
09:04:42 <shapr> .ps I guess, since I know nothing about LaTeX
09:05:38 <shapr> 56 clients connected...
09:05:45 <shapr> we still haven't gone over 60 while I've been here
09:05:49 * shapr is hopeful
09:06:39 <shapr> kl4rk: you said you had questions, have you found answers? Do you still have unanswered questions?
09:06:52 <o3> Lilith: send over
09:06:55 <tmoertel> I have at least one friend whom I have convinced to investigate Haskell.  Maybe he'll show up on #haskell someday.
09:07:07 <shapr> yay!
09:07:21 <shapr> tmoertel: We'll send you another edition of the IvoryTower
09:07:26 * shapr grins
09:07:48 <kl4rk> by now i found my answers trying to think what to ask
09:07:51 <o3> speaking of haskell advocacy, this is best advocacy yet i've seen for strong typing (to a programmer who's only used regular programming langs like c/perl/python): http://perl.plover.com/yak/typing/typing.html
09:08:13 <tmoertel> shapr: "Opening December 2003: Lord of the Rings:  The Ivory Tower"
09:08:21 <shapr> heh
09:08:33 <kl4rk> i'm very surprised for your interest. if all communities where like that the world would be better i think.
09:08:39 <shapr> tmoertel: I was making a joke about .. The Watchtower (?)
09:09:07 <shapr> kl4rk: I think Haskell is great, I'm ready to put in effort to show you why I think that.
09:09:28 <Lilith> ok
09:09:30 <tmoertel> kl4rk: (And that's not just shapr's lack of caffeine talking, either.)
09:09:36 <Lilith> http://www.cse.unsw.edu.au/~shuyingw/haskell/thesisA.ps
09:09:44 <shapr> tmoertel: hey, I just got some coffee ;-)
09:09:51 <Lilith> you know how crap it is when it's got lots of blanks
09:10:07 <o3> Lilith: chaksem used.  +1 mark!
09:10:16 <shapr> chaksem?
09:10:24 <Lilith> o3: handwaving +1 mark! *grin*
09:10:36 <Lilith> shapr: chilli's seminar style
09:10:39 <shapr> oh!
09:10:40 * shapr laughs
09:11:20 <o3> Lilith: slide 8, s/Steward/Stewart/, i think
09:11:26 <o3> yep,
09:11:30 <Lilith> pity nick and sarah's using different OSes though
09:11:37 <Igloo> I used that for my first talk, but I think I decided I liked prosper better for the second one
09:11:54 <Lilith> ah. prosper isn't too bad either
09:12:05 <Igloo> I can't remember why now
09:12:20 <Lilith> Igloo: more fancy stuff?
09:12:37 <Lilith> oh
09:12:41 <shapr> Lilith: there's implementations, should be "there are implementations"
09:12:45 <Igloo> Possibly
09:12:51 <shapr> Lilith: that's page 3
09:12:57 <Lilith> if anyone's interested in silly little haskell programs i wrote ages ago, it's in /haskell
09:13:11 * tmoertel likes FoilTeX + TeXPower
09:13:24 <shapr> I think it's unforeseen on page 4
09:16:20 <tmoertel> Lilith: Also on 3, you might want to capitalize all of the words that start bullets, for parallelism.
09:16:46 <shapr> on page 8, I would suggest you line up the numbers on the left.
09:16:47 <Lilith> hmm
09:16:53 <Lilith> this .NET thing is very confusing
09:17:59 <shapr> ?
09:18:04 <reltuk> .NET's pretty straightforward
09:18:40 <tmoertel> Lilith: On slide 3, onsider moving the "Why Haskell?:" heading and the point beneath it to the following slide, so that all of the related points are together.
09:18:50 <shapr> Lilith: since I'm a fan of XP, I'd start with implementation, and then refactor as unit tests for benchmarking were added
09:18:52 <tmoertel> s/onsider/consider/
09:19:29 * Lilith blinks
09:19:47 * Lilith cannot parse shapr's sentence
09:19:53 <Lilith> more coffee in order i think
09:20:11 <shapr> I'm looking at page 11, and thinking what sort of timeline I would put down.
09:20:19 <shapr> under "Roadmap"
09:20:37 <Lilith> ah right
09:20:47 <shapr> sorry, I'm not being clear :-)
09:21:21 <shapr> Lilith: this is great, when do we get to see an updated version?
09:21:32 <shapr> I can barely wait to use your code! =-)
09:21:38 <Lilith> shapr: soon. about 5/6 am Sydney time i hope
09:21:38 * shapr bounces excitedly
09:21:41 <shapr> heh, ok
09:21:42 * Lilith crosses fingers
09:21:49 <o3> Lilith: oo, burning the midnight oil
09:22:20 <Lilith> o3: got to. or you guys should pay me tomorrow for doing standup comedy
09:22:29 * shapr snickers
09:23:59 <Lilith> i'm not sure about point -> .NET only runs on Windows, whereas the JVM runs on more platforms
09:24:13 <Lilith> since i know that ximian's working on an open source version 
09:25:12 <o3> you could just say that java is a more mature platform, perhaps
09:25:15 <Segora> Lilith: well, there are a lot more JVM implementations than CLR ones
09:25:32 <o3> + there are OSS implementations (e.g. kaffe)
09:25:45 <o3> which may make doing your work easier
09:25:58 <Lilith> true
09:26:11 <Segora> there are more libraries easily available
09:26:22 <Lilith> least i dont have to work in an M$ environment
09:26:35 <Marvin--> shapr: yes, there's a license argument to the setup function, but it's only meant to be sort of license="LGPL" or similar
09:26:59 <Marvin--> well, there won't be any article writing
09:27:03 <Marvin--> a relief, in some way
09:27:06 <Segora> .. and of course (if you're in Europe or the U.S.) the patently weird way of destroying innovation: Software Patents.
09:27:22 <shapr> right, microsoft has patents on some very basic parts of .NET
09:27:33 <shapr> meaning that they could rip the heart out of MONO whenever they felt like it.
09:27:57 <Lilith> shapr: i doubt they'd do that. it doesn't make business sense 
09:28:19 <Segora> .. which brings me to the idea of p2p version control ;)
09:28:23 <shapr> it does maintain their monopoly
09:28:40 <Lilith> well, they could simply buy out ximian 
09:28:47 <shapr> how is that different?
09:28:58 <Marvin--> look at SCO ;)
09:29:08 <Marvin--> "you're infringing, buy us, buy us!"
09:29:09 <reltuk> they didn't buy SCO
09:29:17 <Marvin--> no, but that's what SCO wants
09:29:32 <reltuk> but the source codes already out there...they have to cry patent if they want to stop it
09:29:50 <o3> Marvin--: read the article on MS 
09:29:50 <reltuk> buy Ximian wouldn't fix the problem...they can't close derivative work
09:29:54 <o3> maybe buying SCO?
09:30:32 <o3> then simonpj and simonmar can use SCO technology to take GHC into the future!
09:30:57 <shapr> yay!
09:31:04 <shapr> GHC can have its own kernel!
09:31:16 <Marvin--> a mach kernel, like java! ;)
09:31:20 <Lilith> ugh
09:31:27 <Segora> interesting question: who do they sue if the code in question is the result of serveral changes to the code base with no single change infringing the patent?
09:31:52 <shapr> Marvin--: hah
09:31:56 <Segora> (provided that every single change comes from different people in different jurisdictions)
09:32:06 <shapr> Segora: distributors
09:32:17 <shapr> just make it illegal to own or ditribute that code
09:32:21 <Marvin--> you sue the collective! everybody know that free software is just like the borg
09:32:25 <tmoertel> Segora: they sue rich companies that *use* the code.
09:33:36 <Segora> tmoertel: that won't be easy if the companies in question don't distribute the code but only use it internally
09:33:46 <Lilith> beh.
09:33:57 <Lilith> o3: know where the sample thesis slides are?
09:35:03 <Segora> nevertheless... Your genes will be patented. Resistance is futile.
09:35:18 <o3> which ones, Lilith?
09:35:29 <shapr> someone went into the patent office a few years back and tried to patent their own genome so that companies couldn't clone them.
09:35:40 <Segora> interesting
09:35:49 <Lilith> o3: oh. looking at past disy slides
09:36:00 <Lilith> need inspiration
09:36:25 <Segora> shapr: what about derivative work? can my parents sue me over their patented genes? ;)
09:36:34 <shapr> bizarre thought
09:37:41 <andersca> I wonder if I could get a coffee machine in my room
09:37:44 <shapr> yes!
09:37:46 <shapr> do it!
09:38:09 <Lilith> should i put project goals under overview or should i scrape overview altogether?
09:38:21 <Marvin--> http://www.ubersoft.net/comics/hd20030424.png and http://www.ubersoft.net/comics/hd20030425.png are good :)
09:38:35 <Segora> shapr: you play the dark angel on the left side? ok, then I should say: No, don't! It will ruin your stomach, your temper and in the end, your life... ;)
09:38:58 <o3> grrr, just deleted some useful code.  i really should start using cvs
09:39:10 <Lilith> o3: yes! or subversion
09:39:10 <shapr> o3: or darcs
09:39:11 <Marvin--> o3: or something better
09:39:14 <shapr> darcs!
09:39:16 <Lilith> or darcs
09:39:17 <Lilith> heh
09:39:28 <o3> 8)
09:39:36 <Lilith> cvs sucks
09:39:40 <shapr> yes it does.
09:39:56 <shapr> ok, time to put up a darcs host here...
09:39:57 <Marvin--> the advantage of cvs is that it's been around for a long time, I've heard people having problems with svn
09:39:58 * shapr installs
09:40:00 <Marvin--> darcs I haven't tried
09:40:18 <Lilith> Marvin--: svn has mixed reviews
09:40:33 <Marvin--> I think Branden had problems stuffing XFree and his debian packaging of it in svn
09:40:40 <Lilith> i haven't tried svn nor darcs, so i've no basis for comparison
09:40:52 * syntax-laptop uses svn
09:40:59 <syntax-laptop> I like it.
09:41:08 <syntax-laptop> if you're worried about deleting useful code... RCS works fine :)
09:41:21 <Marvin--> I have svn installed (apt-get is your friend...) but I've never gotten around to test it
09:41:22 <syntax-laptop> I want to try darcs though.
09:41:31 <Lilith> heh
09:41:37 <Lilith> or use emacs saving mode!
09:41:39 <Lilith> :-)
09:41:45 <Marvin--> what I really dislike about cvs is that it's... rcs... it can't handle directories
09:41:58 <syntax-laptop> #svn is a good place for questions, btw
09:42:02 <shapr> I want a version control system that's smart enough to keep track of code when I refactor
09:42:20 * Lilith looks balefully at a whole bunch of *.*~xx~ files
09:42:25 <Marvin--> shapr: you mean track movement of code between files?
09:42:31 <shapr> sure, if it's the same code
09:42:37 <Segora> shapr: you want version control on intermediate representations? ;)
09:42:38 <shapr> Lilith: I can tell you how to fix that :-)
09:42:42 <shapr> Segora: YES
09:42:45 <shapr> absolutely
09:42:52 <Segora> interesting
09:42:58 <Lilith> shapr: i know. i changed the default .emacs file myself
09:43:03 * o3 worships the Haskell typechecker
09:43:06 <Lilith> it's my form of RCS :>
09:43:14 <Igloo> shapr wants IP  :-)
09:43:17 <o3> i just refactored around all my code, and it worked first go after it compiled
09:43:21 <shapr> like Charles Simonyi's Intentional Programming 
09:43:27 <shapr> Igloo: exactly
09:43:37 <Lilith> hmm
09:43:53 <Marvin--> Igloo: I thought you meant intellectual property seing as we'd just talked about SCO, you had me confused there
09:43:59 <shapr> pseiko: hey, have you seen the 2001 oo-haskell paper by SPJ and someone else?
09:44:01 <Igloo> Heh
09:44:01 <Lilith> shapr: i gave up trying to read all those after taking a mandatory class that purported to teach that sort of thing
09:44:16 <shapr> read all those what?
09:44:23 <Marvin--> now let's see if I can repair these examples *grmbl*
09:44:37 * shapr installs darcs
09:44:37 <Lilith> stuff like XP and IP and Scrum and whatever else
09:44:50 <Lilith> i was just very turned off by it
09:44:54 <shapr> I never took any classes about those
09:45:09 <Lilith> i have to to get my degree
09:45:11 <shapr> XP is great and immediately useful, IP is very cool and nifty
09:45:24 <shapr> IP is not immediately useful
09:46:02 <Segora> overload... IPv4 and v6 are indeed useful ;)
09:46:29 <shapr> right, Simonyi's Intentional Programming is not immediately useful, since the system was never released.
09:46:47 <Marvin--> what's intentional programming? DWIM programming? :)
09:46:57 <shapr> Simonyi *did* leave his position as head of MS Research to start a company that focusses on his IP
09:47:13 <shapr> IP is something like .NET, but much spiffier
09:47:24 * o3 is dubious about anybody who invented hungarian notation
09:47:26 <shapr> heh
09:47:36 <o3> (that's a serious comment)
09:48:03 <shapr> Marvin--: an 'intent' is something like an algorithm, it's a non-language specific concept that the programmer is writing an executable version of...
09:48:37 <shapr> the idea of IP was that I could write Haskell, and it would be stored in the version control system in an intermediate AST
09:48:41 <reltuk> IP is spiffier than .NET?  For a no-thrills imperative language with rapid development capabilities, .net is actually pretty good
09:48:46 <shapr> then you could view that AST as Python, and edit the code I had written.
09:49:13 <reltuk> interesting...that is pretty bloody spiffy
09:49:32 <shapr> basic idea: version control on the intermediate AST, source language is just a 'viewer' for the AST
09:49:42 <Lilith> hmm
09:49:47 <reltuk> IL is actually high level enough that you can get really normal C#/VB.net code out of it...probably other .net languages as well
09:49:51 <Lilith> that is a pretty interesting idea
09:49:54 <reltuk> but you loose local variable names
09:50:40 <shapr> I think emacs needs to evolve along the same lines, don't edit text, edit an AST. That would allow you to write multilingual 'scripts' in your editor.
09:50:50 <Segora> .. and if the AST is generated from a very high level representation (say, three lines of Haskell), it could be less than useful to view it as python source. ;)
09:51:11 * Lilith wonders who it was who asked about Haskell->.NET
09:51:20 * Lilith just dug up a paper on it
09:51:37 <shapr> Segora: yah, that's true. I tried for a long time to get hold of an IP system, but the project got killed at MSR.
09:51:59 <reltuk> if you had to put the following languages in an order in which they should be learned starting now, what would it be:  ocaml, haskell, scheme/common lisp
09:52:24 <shapr> haskell, scheme, ocaml, common lisp
09:52:25 <reltuk> for someone coming from a purely imperative background
09:52:27 <shapr> :-)
09:52:30 <Segora> shapr: A system that (semi-)automagically identifies interesting structures in the program could be very useful, on the other hand.
09:52:55 <shapr> Segora: that's been done also, Ivan Moore III wrote an autorefactoring program called Guru for the Self language.
09:53:18 <reltuk> dude, that autorefactoring research is awesome
09:53:18 <shapr> in that case, you do something along the lines of LZW compression on the AST
09:53:51 <reltuk> shapr : haskell's that good, eh?
09:53:55 <shapr> Is that the same thing as CSE in Haskell?
09:54:04 <shapr> reltuk: I could be slightly biased ;-)
09:54:20 <Segora> shapr: analyze foo.cc -> "Looks like this should be modelled as MVC. Rewrite? [Y/n]" *g*
09:54:29 <shapr> hehe
09:54:45 <shapr> I very much want a refactoring browser for Haskell
09:54:47 <reltuk> lol
09:55:05 <shapr> from the stories I've read about refactoring browsers, it would change the way my applications evolve.
09:55:30 <Lilith> what do you mean by refactoring browsers?
09:55:45 <Segora> echo "Make an interesting game with lots of spiffy graphics" >game.en_US ; do_what_i_mean -o game game.en_US
09:55:56 <shapr> Lilith: you know about refactoring?
09:55:59 <andersca> wokka wokka wokka
09:56:14 <Lilith> shapr: no. 
09:56:40 <shapr> ok, refactoring is changing the code without changing what it does
09:56:41 <reltuk> Ralph Johnson, a prof at my school, did a lot of work on the first refactoring browser ever created (it was for Smalltalk...).  He's real nice, offered to get me in on his research team
09:57:01 <shapr> yes, Johnson and Brant wrote the first refactoring browser
09:57:24 <shapr> I've read Brant's thesis, and ... Opdyke(?) did the groundwork in C or C++, I forget which.
09:57:29 <Marvin--> what does a refactoring browser do?
09:57:36 <Marvin--> andersca: wakka wakka wakka
09:57:41 <reltuk> but I was under the impression that refactoring was pretty underexplored in non-OO systems
09:58:17 <shapr> a single refactoring could be "raise method" that would move a method from a subclass to a superclass
09:58:34 <reltuk> Marvin-- : it allows you to restructure the structure of your program...like move variables and redefine functions...it helps you rewrite parts of your program to be more "correct" without breaking the program
09:58:46 <shapr> right, "renamed variable" is a good one
09:58:56 <shapr> on first thought, why not use a regex?
09:59:15 <shapr> thing is, a regex won't always find everything
09:59:23 <reltuk> the idea behind refactoring is that if you make a really big change all at once, you're going to screw something up
09:59:25 <shapr> and it'll change comments, which you don't really want.
09:59:30 <reltuk> but if you make a whole bunch of little changes, they add up
09:59:36 <reltuk> and you can keep everything in order while you're doing it
09:59:57 <shapr> so a refactoring browser turns all of your code into an AST, then you make behaviour-preserving changes to the AST, and turn the AST back into source.
10:00:34 <shapr> I started work on a Python refactoring browser once long ago, but only got to the point of turning Python source into an AST and back into source.
10:00:55 <shapr> Phil Dawes picked up the project, and has done quite well with it.
10:02:13 <reltuk> shapr : linkity link link?
10:02:23 <shapr> in Brant's thesis, he defines 'behaviour-preserving' as "all your unit tests still pass"
10:02:45 <shapr> one of the neat metaphysical issues he skips over is that unit tests are the real specification of an application
10:03:05 <shapr> reltuk: http://bicyclerepair.sf.net/
10:03:21 <shapr> Lilith: oh there's a good explanation of refactorings and a refactoring browser on that page
10:03:46 <shapr> I wrote the page :-)
10:06:12 <Lilith> shapr: that's a kinky name for a project
10:07:17 * Marvin-- laughs evilly
10:07:26 <andersca> jolta|afk: saw you in spionen
10:09:36 <Marvin--> dammit, quickcheck is too good
10:10:31 <jolta> andersca: Seems like I'm the only one who didn't. =)
10:10:55 <reltuk> ok, so haskell is first on the list...
10:11:03 <reltuk> is there a good free haskell book?
10:13:48 <Lilith> reltuk: http://www.haskell.org/bookshelf/
10:14:25 <Lilith> read "A Gentle Introduction to Haskell" after you've had a feel for it
10:14:39 <Lilith> it's imho, anything but gentle for a beginner
10:14:44 <Marvin--> damn damn damn, why doesn't E work this out
10:15:09 <seth_> E?
10:15:26 <Marvin--> it's a FOL prover
10:16:13 <Marvin--> okay, so this wasn't a good bug
10:16:19 <Marvin--> quickcheck didn't find it, but my program didn't either *cough*
10:19:05 <jolta> Marvin--: What, being as good as QuickCheck isn't good enough for you? =)
10:19:29 <Marvin--> jolta: no, the whole point of my degree project is to be better than quickcheck, dammit
10:19:43 <shapr> hi tetryl 
10:20:06 <jolta> Marvin--: I know, just teasing. =)
10:21:06 <reltuk> oops, I picked up a book on gopher
10:21:10 <reltuk> gofer even  :-p
10:21:11 <shapr> heh
10:28:31 <tetryl> hi shapr
10:28:41 <shapr> tetryl: how's life?
10:29:31 <tetryl> shapr: JScript life.. :-(
10:30:18 <shapr> yow
10:30:25 <tetryl> at work
10:30:28 <andersca> M-x yow
10:30:35 <shapr> are you doing JScript in server-side ASP?
10:30:36 <shapr> @yow
10:30:36 <lambdabot> Wow!  Look!!  A stray meatball!!  Let's interview it!
10:30:40 <andersca> whee
10:30:51 <tetryl> yep
10:31:02 <shapr> too much fun :-)
10:31:15 <shapr> have you investigated HaskellScript?
10:31:52 <shapr> would you be allowed to use it?
10:32:57 <tetryl> oops! i've forgot that.
10:34:02 <tetryl> i should make an offer to my boss.
10:36:44 <kl4rk> very stupid question, but it's wasting me lots of time: i have a module in a file, how can i use it from another module on another file? i'm using hugs.
10:37:22 <Lilith> import <module name>
10:37:28 <kl4rk> doh
10:37:30 <kl4rk> thanks
10:38:15 <reltuk> does haskell-mode work for emacs?
10:38:36 <Lilith> reltuk: yes
10:38:55 <shapr> yes, it's great
10:39:08 <reltuk> I get: File mode specification error: (void-function turn-on-decl-scan) in *Messages*
10:39:17 <reltuk> and font-locking doesn't work...
10:40:07 <reltuk> oh, n/m...obviously supposed to be turn-on-haskell, etc.
10:40:20 <reltuk> schwing, it's beautiful  :-p
10:41:13 <shapr> http://kungens.kemi.fi/~shae/src/elisp/shae-haskell.el
10:42:49 <shapr> hi Roooz 
10:42:59 <Roooz> hi
10:43:07 <shapr> are you learning Haskell?
10:43:27 <Roooz> not right now, used to
10:43:46 <shapr> looking for other Haskell users?
10:44:10 <Roooz> not sure, what do u mean
10:44:29 <shapr> just wondering why you're here on #haskell
10:45:04 <Roooz> i just was bored, i pologize :)
10:45:25 <shapr> no worries
10:45:41 <shapr> If you'd like to learn more about Haskell, I can give you some urls
10:45:41 <Roooz> did u find something esp. interesting in the community report?
10:47:00 <Roooz> I think i have the usual urls..thx
10:47:04 <shapr> ok
10:47:11 <shapr> Yes, I thought hircules was very cool.
10:47:13 <shapr> have you seen it?
10:47:58 <Roooz> I haven't read it all, just skipping pages
10:48:00 <Roooz> no
10:48:09 <Roooz> a new project?
10:48:55 <Roooz> what's it about?
10:49:05 <Roooz> oh,irc..
10:49:06 <shapr> it's about an irc client written in Haskell.
10:49:39 <Roooz> ah,have u tried it
10:50:22 <shapr> no, not yet.
10:50:30 <shapr> I've been having trouble compiling gtk2hs with ghc5.05
10:51:36 <Roooz> got to run, thx for the chat
10:51:52 <shapr> sure, have fun.
10:54:31 <reltuk> shapr : I saw the bookshelf at haskell.org, but there's a lot of references.   How does the poor man learn Haskell?
10:54:47 <reltuk> You think gentle introduction is best?
10:57:38 <shapr> hm
10:57:53 <shapr> I tried to start with the gentle intro, felt like a brickbat to me.
10:58:07 <shapr> but then, I've never been a math guy, nor did I have much FP experience beforehand.
10:58:36 <shapr> if you have both math and cash, get Hudak's book. If you have cash but not math, get Thompson's book.
10:58:52 <Lilith> shapr: i quite liked my textbook
10:58:59 <shapr> If you have no cash, start with YAHT (yet another haskell tutorial) by Hal Daumé et al, and then try the Gentrle Intro
10:59:08 <shapr> Lilith: do you have Chilli's book?
10:59:25 <Lilith> shapr: nope. but i have his lecture notes 
10:59:41 <shapr> which textbook do you have?
11:00:03 <Lilith> thompson's
11:00:12 <kosmikus> hm. I like Bird better than both Hudak and Thompson -- but then again, I guess I am a math guy ...
11:00:18 <Lilith> i'm trying to sell it off without success
11:00:41 <Lilith> kosmikus: oh yes. i heard Bird's good, but i've never seen the book
11:00:47 <shapr> neither have I
11:00:59 <shapr> reltuk: does that help you any?
11:01:11 <shapr> reltuk: have you already seen http://www.haskell.org/learning.html ?
11:02:29 <reltuk> hehe, I'm trying yaht and then gentle intro
11:02:55 <Lilith> hmm
11:03:11 * Lilith decides that Garbage makes bad thesis making music
11:03:16 <shapr> I'd also recommend trying to write some code everyday, and ask quetsions here on #haskell
11:03:23 <shapr> Lilith: The Crystal Method is much better.
11:03:46 <Lilith> shapr: got mp3s somewhere?
11:03:55 <reltuk> I think if I can learn Haskell, all the other functional languages on the radar will be relatively easy
11:04:00 <shapr> reltuk: I strongly agree.
11:04:32 <shapr> Lilith: nah, I don't do copyrighted media swapping (unless explicitly allowed)
11:05:09 <Lilith> shapr: good guy. i do it because i'm a broke student
11:05:28 <shapr> I do have a bunch of CDs
11:09:12 <saz> Lilith: you're still awake!
11:09:20 <Lilith> saz: so are you!
11:09:27 <saz> no, I just woke up
11:09:51 <Lilith> ah alright. i have to finish my thesis slides
11:09:59 <Lilith> or risk doing standup comedy later today
11:10:04 <saz> hehe
11:10:09 <saz> when's the presentation?
11:10:15 <Lilith> 3pm
11:10:24 <Lilith> it's during my group meeting
11:10:25 <saz> standup comedy is a lot more fun than a thesis presentation, i'm sure
11:10:28 <Lilith> (so don't turn up)
11:10:29 <saz> they'd appreciate it
11:10:30 * shapr grins
11:11:02 <saz> Lilith: hehe... that's anticlimactic
11:11:21 <Lilith> saz: awwrr. come next week for the real thing
11:11:23 <Lilith> or don't come
11:11:27 <Lilith> i'm scared of audiences
11:11:43 <o3> ok, night *
11:11:43 <shapr> Lilith: just remember, they're often more scared of you
11:11:53 <Lilith> night, o3
11:11:57 <saz> g'night o3
11:12:00 <saz> or morning rather
11:12:04 <shapr> heh
11:12:43 <saz> Lilith: surely, you can't be scared of me!
11:12:49 * reltuk explodes when he gets to "User defined types"
11:13:06 <shapr> reltuk: want some examples?
11:13:14 * saz grins and prepares questions :-P
11:13:18 <Lilith> saz: well, not scared of you per se, just petrified of presentations
11:13:19 <Lilith> :p
11:13:40 <Lilith> presentations are agony to me, that's why i don't teach
11:13:41 <reltuk> shapr : sure   :)
11:14:07 <shapr> reltuk: type Vector = (Int,Int)
11:14:09 <Lilith> if we had video conferencing, all would be good, i'm sure
11:14:26 <saz> Lilith: i'd feel a bit silly with video conferencing
11:14:28 <shapr> er, lemme try that to make sure it'll work
11:14:37 * saz used to be petrified of presentations
11:14:44 <shapr> I still am
11:14:46 <saz> then i started teaching
11:14:49 <reltuk> haha, I don't know enough to write something to test it anyway   ;)
11:14:49 <shapr> wow
11:15:16 <shapr> reltuk: in short, user defined datatypes are made up of other datatypes (or themselves)
11:15:31 <Lilith> yeah
11:15:41 <Lilith> it's a bit like enum or typedef
11:16:03 <reltuk> I think the fact that it's like enum *and* typedef is throwing me off...
11:16:03 <shapr> reltuk: so you can make mnemonic aliases like "data Point = (Int,Int)"
11:16:29 <Lilith> hmm
11:16:37 <Lilith> what's the difference between data and type?
11:16:45 * Lilith thinks
11:16:59 <Lilith> hrm
11:17:01 <reltuk> and then there's type constructors and data constructors
11:17:05 <Lilith> better get back to thesi
11:17:12 <reltuk> so a significant example they give is data Tree a             = Leaf a | Branch (Tree a) (Tree a) 
11:17:16 <Riastradh> type is for type synonyms; data is for ADTs.
11:17:25 <kosmikus> shapr: should be "type Point = (Int,Int)"
11:17:43 <shapr> reltuk: enumerated types look like "data Seasons = Winter | Summer | Spring | Fall"
11:18:10 <reltuk> and then I can match on the enumerations
11:18:11 <shapr> parameterized types look like "data Foo a = FooConstructor a a"
11:18:11 <Riastradh> 'type Point = (Int, Int)', or 'data Point = Point Int Int', or 'newtype Point = Point { getCoords :: (int, int) }'
11:18:23 <shapr> oh, I gotta go.. I'll be back later.
11:18:36 <reltuk> adios shapr, thanks for help
11:18:43 <shapr> sure, np
11:18:45 <reltuk> I haven't seen newtype yet...
11:18:47 * Riastradh can stay and help explain a bit if necessary.
11:18:52 <Riastradh> OK, ignore the newtype declaration I showed, then.
11:18:59 <reltuk> but in the Tree example above
11:19:07 <reltuk> does that define new types of Tree, Leaf and Branch
11:19:15 <Riastradh> ...should be:  data Tree a = Leaf a | Branch (Tree a) (Tree a)
11:19:18 <reltuk> or does like...Leaf(3) *make* a Tree?
11:19:21 <Riastradh> (you forgot the = sign)
11:19:37 <Riastradh> Tree is a type.
11:19:44 <Riastradh> Leaf is like a function that returns a value of the type Tree.
11:20:01 <Riastradh> Branch is like Leaf.
11:20:07 <reltuk> but I can match a leaf or a branch...?
11:20:24 <Riastradh> Yes, because they're not like ordinary functions in that they're called 'constructors' and they work with the pattern matching system.
11:20:52 <reltuk> ok...data types don't work with the pattern matching system...just constructors, right?
11:20:58 <Riastradh> Correct.
11:22:10 <reltuk> so the constructors use datatypes for their "values"...like (Tree a)(Tree a)...but datatypes don't show up in any actual code
11:22:12 <reltuk> just constructors
11:22:29 <Riastradh> Right.
11:22:46 <reltuk> awesome...and what's the ()() syntax?
11:23:03 <reltuk> they just match on Branch left right...
11:23:23 <Riastradh> data Tree a = Leaf a | Branch (Tree a) (Tree a)
11:23:33 <Riastradh>                               ^^^^^^^^^^^^^^^^^ This bit?
11:23:57 <reltuk> yeah
11:24:10 <reltuk> sorry for being ambiguous
11:24:46 <Riastradh> The parentheses just make it clear that branches contain trees -- if you wrote:  ... | Branch Tree a Tree a   that looks more like Branch contains four fields, a Tree, an a, a Tree, and an a.
11:24:57 <Riastradh> And in fact it would be parsed that way by the compiler.
11:25:29 <Riastradh> The compiler would put on a sad face, then, and say that your program sucks because it doesn't realise that you mean Branch (Tree a) (Tree a).
11:25:45 <reltuk> lol
11:26:17 <Riastradh> Are you all cleared up now?
11:26:18 <reltuk> if Tree is just a datatype, not a constructor, how does it (or more correctly, how do I) know that Tree needs to be defined with another type as well?
11:26:26 <Riastradh> Rephrase, please.
11:27:02 <reltuk> well like, it needs an 'a'...
11:27:17 <reltuk> we know that because Leaf needed an a?
11:27:58 <Riastradh> Have type parametres been explained to you at all yet?
11:28:19 <reltuk> I think A Gentle Introduction is a bit backwards  :-p
11:28:31 <reltuk> it explained a and polymorphism
11:29:19 <Riastradh> OK, so...Tree is polymorphic in that you can have Trees of integers, Trees of more Trees, Trees of lists, or anything.
11:29:33 <reltuk> right, I got that
11:29:57 <reltuk> but we know we have to do (Tree a)  <--- that a belongs there, just because Leaf needs an a?
11:30:11 <Riastradh> The way the compiler knows what values the Trees contain is by the 'type parametre' -- 'Tree Int' passes the parametre Int to Tree, just like you might pass an argument to a function, and then you can have leaves of integers, or branches of more 'Tree Int's.
11:30:20 <kosmikus> some people call "Tree" a "constructor" as well -- however, there is a very important difference between a "type constructor" such as "Tree" which is a "function" that takes a type argument to another type, and a "value constructor" such as Leaf, which is a function that creates a _value_ of a type
11:31:02 <reltuk> ahhh, excellant
11:31:12 <reltuk> thanks...I'm sure I sound retarded  :-p
11:32:34 <Riastradh> reltuk, perhaps, but it's good that you're asking questions before you realise that you don't understand.
11:32:41 <Riastradh> If you don't understand the basics you'll never get anywhere.
11:46:00 <chichi> simp
11:46:12 <chichi> ls -l <people>
11:49:09 <andersca> re jolta
11:50:13 <jolta> andersca: Yes?
11:50:26 <andersca> uhm, re is short for "re-hi"
11:50:27 <andersca> :)
11:51:09 <jolta> andersca: Ah, didn't know that one. :)
11:55:27 <Lilith> yes!
11:55:30 <Lilith> bed time
12:42:44 <syntax-laptop> hi :) anyone using hat / ghc / debian?
12:48:57 <syntax-laptop> or hat / nhc / debian?
12:51:02 <buggs> better ask your question than making a poll ;)
12:51:32 <syntax-laptop> well, it doesn't seem to work at all AFAICT, so I guess the question would be "if so, how?" :)
12:55:27 <buggs> works for me
12:55:42 <syntax-laptop> buggs: in sid?
12:56:02 <buggs> nopes woody
12:57:17 <syntax-laptop> I see.  I think it used to work for me in woody, except for not having MPTC... now it seems to be misconfigured for both nhc and ghc; ghc complains that there's no "hat" package, nhc complains that it can't find PreludeBasic.
14:09:58 <tic_> jolta, lever du?
14:11:23 <jolta> jepp
14:11:31 <jolta> fast jag läser inte alltid
14:15:24 <tic_> oki
14:15:27 <tic_> jolta, blir det arvika?
14:16:09 <jolta> tic_: borde inte vara några problem. Jag får veta på onsdag
14:16:23 <tic_> jolta, gräjt. bil bokad, jag har semester.
14:16:26 <tic_> jolta, ska bara köpa biljett
14:16:51 <jolta> tic_: ok. I'll have to get a ticket too
14:17:15 <tic_> jess.
14:17:47 <Riastradh> What's that $ doing there?
14:18:02 <Riastradh> And why didn't he eta-reduce it?
14:21:30 <Igloo> Maybe he forgot to use -O
14:33:11 <reltuk> what's the hook to turn on ghc in haskell-mode?
14:33:49 <reltuk> brb
14:35:41 <jolta> reltuk: you mean emacs?
14:35:54 <jolta> M-x haskell-mode
14:37:25 <reltuk> I fixed it...needed ghci instead of ghc
14:38:18 <jolta> I was going say ghc is always in haskell-mode, but I see what you mean now. =)
14:44:25 <syntax-laptop> can someone who uses hat tell me why a hat would fail to create executable code for the simple program: "main = putStr (show $ 4 ^ 2)"
14:44:44 <syntax-laptop> it fails while ghc tries to compile the instrumented code.
15:49:15 <shapr> hi
15:50:59 * shapr boings
15:58:00 <Igloo> What's up, shapr?
15:58:10 <shapr> just life
15:58:44 <shapr> sugar and stimulants
15:58:51 <shapr> and things to do that pay money
16:00:55 <Igloo> Well, better than not having things to do that pay money I guess
16:01:07 <shapr> that's true
16:02:29 <shapr> what's up with you?
16:02:34 <shapr> have you passed the slough of despair?
16:04:20 <Igloo> No. I don't think I can really do anything before Tuesday afternoon when I might be able to meet Oege. Then I'll be tweaking layout until Wedesday afternoon when I'll send them off I think
16:05:09 * shapr wonders if other people on #haskell have read pilgrim's progress
16:05:17 <Igloo> Who?
16:05:49 <shapr> it's a religious text from some centuries ago
16:06:07 <Igloo> Oh
16:06:20 <shapr> probably not common reading :-)
16:06:50 <shapr> the slough of despair was one of the places the pilgrim almost got stuck at
16:07:44 <Igloo> OK, why has GHC stopped understanding TH syntax?
16:07:56 <wli> maybe they backed out TH?
16:08:44 <shapr> yikes
16:08:46 <shapr> I hope not
16:09:35 * Igloo sighs and starts a clean build
16:09:48 <Riastradh> TH?
16:09:55 <shapr> template haskell
16:10:13 <Riastradh> What's that?
16:10:25 <wli> I still need to figure out how to get a valuation function usable across multiple rings
16:12:15 <shapr> Riastradh: template haskell is the new spiffy compile-time macro system
16:12:26 <Riastradh> But it's now so old that GHC doesn't support it?
16:12:43 <shapr> no, it's almost exactly a year old
16:12:49 <shapr> and actively developed
16:13:52 <Riastradh> I was being a little sarcastic.
16:15:11 <shapr> ah
16:43:07 <tmoertel> at least TH *will* be in GHC 6.0: http://haskell.org/pipermail/cvs-ghc/2003-May/017515.html
16:48:59 <tmoertel> Pseudonym: thanks for the link to Hinze's "Weaving a Web" paper a few days back.  That was a fun read.
16:49:19 * tmoertel wonders if there is an online, comprehensive list of functional pearls
16:49:25 <Pseudonym> No problem.
16:49:29 <Pseudonym> As far as I know, there isn't.
16:49:42 <Pseudonym> I thought you'd like it.  So, written any code?
16:50:04 <tmoertel> No.  But it's filed away for potential use.
16:50:15 <Riastradh> Functional 'pearls?'
16:50:21 <tmoertel> (You know, paying work comes first and all.)
16:50:28 <Pseudonym> True.
16:51:19 <Pseudonym> Riastradh: It comes from the Jon Bentley "Programming Pearls" columns/books.
16:51:30 <Pseudonym> I believe he coined the term.
16:51:33 <Riastradh> What is a 'pearl' in this case?
16:51:44 <tmoertel> Riastradh: Elegant solutions to interesting problems. 
16:51:54 <Pseudonym> And, if possible, practical problems.
16:52:05 <Riastradh> 'Practical?'  What the heck does -that- mean!?
16:52:09 * Pseudonym laughs
16:52:34 * tmoertel has both of Bentley's original Programming Pearls volumes and the newer combined book.
16:52:50 <Pseudonym> Well, one of the first functional pearls I remember from JFP (i.e. about the time I started reading JFP) was the paper on bounded balance binary trees.
16:53:00 <Pseudonym> Which is now in FiniteMap.
17:34:29 <Igloo> Urgle. It's not my week.
17:37:56 <Pseudonym> It's only just begun, too.
17:42:52 <shapr> hi Pseudonym 
17:48:55 <Pseudonym> G'day.
18:22:08 <Riastradh> @yow
18:22:09 <lambdabot> Yow!  We're going to a new disco!
18:24:52 <cfork> Telstra must really hate me..
18:34:54 <Pseudonym> Don't feel singled out.  Telstra hates everyone.
18:36:00 <cfork> Ah. I'm glad.
18:48:43 <cfork> urgh. its quite a pain to get ghc going
18:49:25 <cfork> my version of glibc is apparently too new for the binary on www.haskell.org/ghc
18:59:59 <seth_> cfork: I've used it with the latest glibc
19:01:53 <cfork> Whenever I try and compile something with ghc, I get (in libHSrts.a) undefined reference to __ctype_b
19:03:09 <cfork> RtsFlags.o
19:04:19 <cfork> My computer and ghc really don't seem to mix :(
19:06:08 <cfork> glibc 2.3.1
19:12:28 <cfork> Hmm.. I'm gonna have to give up on ghc :(
19:13:02 <seth_> cfork: that is quite odd.  which distribution are you using? (of the o/s?)
19:13:32 <cfork> archlinux
19:14:25 <seth_> I haven't heard of that one.  You would have less difficulty with a more mainstream distribution.
19:15:31 <cfork> actually I'd much rather keep it as it is, and just forget about ghc
19:18:28 <Pseudonym> Actually I'd much rather have it less painful to build ghc.
19:18:37 <Pseudonym> :-)
19:18:42 <cfork> from C sources
19:18:44 <cfork> heh
19:18:54 <Pseudonym> Even from Haskell sources.
19:19:24 <Pseudonym> Though yes, GHC source distros should come with C source.
19:19:27 <cfork> in windows, ghc was trying to open /etc/protocols
19:19:43 <cfork> ^^
19:20:05 <Pseudonym> Yeah, there's probably a good reason for that.
19:20:09 <cfork> eh?
19:20:11 <Pseudonym> The BSD socket library probably wants it.
19:20:27 <Pseudonym> For some unknown reason.
19:21:03 <cfork> anyway, I'll steer clear of ghc for now.. I haven't had any luck with it at all
19:21:50 <Pseudonym> Personally, I think packaging is the Linux equivalent of DLL hell.
19:23:31 <cfork> probably
19:24:53 <cfork> It seems to be impossible to have both a really nice language, and a perfect implementation
19:25:07 <Pseudonym> There is no "perfect".
19:25:21 <Pseudonym> Although GHC could do with some cleanups.
19:26:28 <ozone> ghc's a pretty remarkable piece of work
19:27:01 <ozone> (then again, i think gcc is a remarkable piece of work :)
19:27:51 <cfork> hmm so whats the next best haskell implementation? (in your opinions, of course)
19:28:19 <Pseudonym> That depends.  Do you want non-H98 features?
19:28:46 <Pseudonym> For example, are multi-parameter type classes and fundeps important to you?
19:29:00 <Pseudonym> If not, probably NHC.  Otherwise probably hugs, though hugs isn't a compiler.
19:29:20 <Pseudonym> I haven't used HBC, so I can't really comment on that.
19:30:39 * ozone ickserv identify zxcmn7
19:30:39 <ozone> hmm
19:30:50 * Pseudonym knows ozone's password!
19:30:54 <ozone> grr
19:30:59 * ozone whacks irc client
19:33:22 <seth_> I never use any of the package managers.  If you try and install packages, then no wonder you have problems with ghc.
19:33:25 * ozone grumbles as he changes his universal nickserv password
19:34:11 <Pseudonym> Oh, I find Debian works so long as you don't mind a three-year old version.
19:34:29 <seth_> Pseudonym: that's true, but I mind, at least slightly.  :)
19:34:44 * Pseudonym grins
19:34:45 <Pseudonym> I do too.
19:34:48 <seth_> Pseudonym: but the thing is so simple to install from the binary tar'd up thing.
19:34:57 <Pseudonym> Yeah, true.
19:35:09 <cfork> I've gone through many distributions.. the only thing I've noticed is that they are all pretty much the same
19:35:30 <seth_> mostly.  some break a few extra things.
19:35:34 <cfork> yep
19:35:54 <Pseudonym> I've found one difference which really helps on some systems, and makes no difference on others.
19:36:18 <Pseudonym> That's the ability to get the latest "security fixed" version of everything with one command.
19:36:32 <Pseudonym> If you've got a machine which isn't behind a firewall, this is important.
19:36:45 <Pseudonym> For my desktop machine, it's not important and, I agree, pretty much everything is the same.
19:36:57 <Pseudonym> For my colocated server, I wouldn't want to be without it.
19:37:09 <Pseudonym> But I don't do Haskell dev on my server.
19:37:14 <seth_> yes, but even in that case, you are relying on the package manager to do it correctly, not only this time but the next time and the time after that.
19:37:32 <Pseudonym> For the small number of jobs the server has to do, I think it's sufficient.
19:37:53 <cfork> I'm behind a pretty good firewall, so I have some really old, probably unsafe, programs
19:38:04 * Pseudonym nods
19:38:13 <Pseudonym> My point is: Different machines have different needs.
19:38:21 <Pseudonym> Packaging is precisely the right solution for some machines.
19:38:27 <Pseudonym> And pretty useless for others.
19:38:54 <cfork> I also like it when things work without hassle :)
19:39:02 <Pseudonym> That's always good.
19:39:06 <cfork> Like Python librarys, with distutils :)
19:39:08 <seth_> true, but that is orthogonal to the issue of whether the package manager works reliably at all.
19:40:33 <Pseudonym> Well that's just a quality issue.
19:40:57 <Pseudonym> The package management software itself has to be efficient and robust, plus also the packages need to work together well.
19:41:09 <Pseudonym> That's mostly a quality management problem.
19:41:24 <seth_> true, but you aren't working with the idea of a package manager, you have to work with a particular package manager, and in my view none of them are acceptable.
19:41:54 <Pseudonym> That depends on your acceptance criteria.
19:42:20 <Pseudonym> I think many of them are "acceptable" for the acceptance criteria of my colocated server.
19:42:25 <Pseudonym> :-)
19:43:26 <Pseudonym> Lunch.
19:43:28 <Pseudonym> BBL
22:07:18 <Darius> ooo, optimized bit-reversal permutation of a list, I could use that
22:07:28 <wli> FFT?
22:09:17 <Darius> aye
22:10:31 <Pseudonym> Optimised?
22:11:19 <Darius> I'm reading "Program Optimisation, Naturally" by Birds, Gibbons, and Jones
22:11:34 * Pseudonym nods
22:16:18 <Pseudonym> In principle it's really easy.
22:16:23 <Pseudonym> Especially in Haskell.
23:06:11 <Pseudonym> Darius, as a matter of interest, what language is this optimised bit-reversal in?
23:07:21 <Darius> Haskell
23:07:26 <Pseudonym> Cool.
23:08:38 <Pseudonym> I'm curious how it compares with mine, though.
23:08:46 <Pseudonym> http://www.nomorepasting.com/paste.php?pasteID=3545
23:12:35 <Darius> I made www.haskell.org/hawiki/HaskellIrcPastePage for pasting stuff
23:12:35 <Pseudonym> Useful.
23:13:07 * Pseudonym pastes it there
23:14:32 <Darius> [[DateTime]] didn't do quite what I was expecting, so there is very little reason to bother with it
23:14:41 <Pseudonym> Oh, it's the current DateTime.
23:14:43 <Pseudonym> Bleh.
23:15:35 <Darius> It'll be nice when HaWiki does syntax hilighting
23:15:39 * Pseudonym nods
23:44:20 <seth_> Anyone run into emacs locking up when you change fonts, in Haskell mode?  Might not have anything to do with haskell mode per se, as I am always in haskell mode (lately) in emacs.
