00:29:53 <Pseudonym> Night all.
00:41:44 * Marvin-- screams in frustration
01:12:16 <Marvin--> phew
01:13:39 <Marvin--> writing haskell programs without overloading and higher order functions is a PITA
02:28:27 <delYsid> hmm, anyone interested in hOpenAL?
02:32:44 * delYsid plays GMA Tank Commander this weekend and has a real urge to create a free game in that spirit... (www.gmagames.com)
02:32:54 <delYsid> s/plays/played/
02:34:17 * seth_ is away: Off to the glue factory
04:10:30 <Marvin--> oh dear this code is scary
04:19:50 * Marvin-- tries to wrap his head around gmap
04:59:18 <shapr> y0 y0
04:59:47 <Marvin--> damn DMR
05:00:05 <andersca> not UMR
05:00:05 <andersca> ?
05:00:52 <wli> what's gmap?
05:00:56 <Marvin--> Dreaded Monomorphism Restriction
05:01:28 <Marvin--> wli: scary stuff
05:01:42 <shapr> http://www.cs.vu.nl/Strafunski/gmap/
05:01:49 <Marvin--> http://www.cs.vu.nl/Strafunski/gmap/
05:01:51 <Marvin--> bah!
05:01:59 <shapr> :-)
05:04:00 <wli> well I'm looking at it
05:04:57 <wli> where's the hairy part?
05:05:41 <Marvin--> using it :/
05:05:44 * shapr wonders if the mane function is the hairy part
05:06:05 <Marvin--> I'm trying to write a function that traverses an AST and collects a certain type of expressions along with a depth indicator
05:06:19 <Marvin--> I think I need coffee
05:06:35 <Marvin--> there's a monadic example with the source code, but I don't want to print the damn things, I want to collect them
05:15:24 <Marvin--> grr... I guess I really want a transformation, but I need to change both declarations and expressions "at the same time" and I don't know how to do that
05:15:54 * shapr doesn't know either
05:17:13 <Marvin--> what I *really really* want to do is magically float all let-bound declarations to top level and rename the functions :-)
05:17:34 <shapr> can you use TH for that?
05:17:35 <Marvin--> maybe that'd be a [Decl] -> [Decl] transformation, but then I don't see how it would be different from the non-gmap code I already have
05:18:08 <Igloo> I'd first give every bound variable a unique name and then do the floating
05:18:46 <Marvin--> the naming kinda depends on the floating though... if I have  f x = let g y = e1 in e2  I want to rename g to f_g when I float it
05:19:04 <Marvin--> and I may need to give g extra patterns (f's x)
05:20:01 <Igloo> Oh, I see, you want useful names too
05:20:19 <Igloo> You could still do that as a separate pass first, though
05:20:20 <Marvin--> yes :)
05:20:23 <Marvin--> I guess
05:20:42 <Marvin--> but I have to rename in both declarations and expressions
05:20:58 <Igloo> Yes
05:21:48 <Marvin--> in my non-gmap code I collect the names of the declarations in a let as I traverse inward... I don't *quite* understand how to do that with gmap :)
05:22:56 <Igloo> Where's the code you have?
05:23:23 <Marvin--> it's hidden deep within lots of other crap, gimme a sec and I'll see if I can filter out some line noise from it
05:25:27 <Marvin--> http://193.11.232.159:8080/Foo.hs   it's very unfinished, I was hoping to use gmap instead
05:25:40 <Igloo> Oh, sorry, I meant the gmap example code
05:25:58 <Marvin--> I don't really *have* any
05:26:06 <Marvin--> I'm just toying around with it
05:26:15 <Igloo> Didn't you mention a monadic example above?
05:26:49 <Marvin--> oh, that's the one from the source distribution of gmap
05:27:12 <Marvin--> http://193.11.232.159:8080/GMapTest.hs  <- that's what I've written by now
05:28:44 <Marvin--> ghci -fglasgow-exts -fallow-overlapping-instances -fallow-undecidable-instances  is kinda scary :)
05:29:16 * Igloo gets the source distribution
05:30:11 <wli> why?
05:30:21 <Igloo> Which file is it?
05:30:36 <shapr> y0 delYsid 
05:30:42 <shapr> wassup?
05:30:42 <delYsid> yo shapr 
05:30:53 <delYsid> shapr: trying to grok OpenAL
05:31:20 <shapr> nifty, having any success?
05:31:23 <delYsid> www.gmagames.com/gtc002.exe (danger, windows file), I want to write something like that for Linux one day....
05:31:31 <delYsid> shapr: only barely so
05:31:54 <Marvin--> Igloo: examples/haskell/Main.hs
05:32:03 <shapr> delYsid: what does it do?
05:32:10 <wli> isn't there a -fno-monomorphism-restriction or something?
05:32:34 <delYsid> shapr: Its a real time, 3d audio only game, where you command a tank and eliminate enemies.
05:32:40 <Igloo> Marvin: I don't have one of them
05:33:00 <Igloo> Oh, I didn't actually want the link titled "Source distribution"
05:33:05 <Marvin--> Igloo: huh... I've got gmap-4.0/...
05:33:06 <shapr> delYsid: sounds awesome
05:33:17 <Marvin--> Igloo: I downloaded it yesterday, I've forgotten what it said! :)
05:33:22 <delYsid> shapr: it is, same guy wrote "Shades of Doom" which is basicly doom, without video
05:33:46 <Marvin--> Igloo: ah, right, you want the non-DrIFT version
05:34:03 <Igloo> Yeah, I worked that out having read it properly  :-)
05:34:04 <delYsid> works amazingly well, downside, its not open source, so we're kind of stuck with the imagination, and willingness to extend of the original author.
05:34:14 <Marvin--> Igloo: ;)
05:34:36 <Marvin--> delYsid: prod him into releasing the source then!
05:34:58 <delYsid> Marvin--: erm, selling games like this is his living.
05:35:03 <Marvin--> delYsid: oh
05:35:04 <delYsid> I strongly doubt I can convince him.
05:35:15 <delYsid> OTOH, its ActiveX dependent anyway, so I couldnt really use it
05:35:27 <Marvin--> delYsid: since it was downloadable I thought it was beer-free anyway
05:35:39 <Marvin--> delYsid: though I did get a 404 on your link
05:35:39 <delYsid> its a demo
05:35:42 <Marvin--> aha
05:35:45 <delYsid> level one is fully playable
05:35:53 <delYsid> for everything else, you'll have to raise about $70
05:36:01 <Marvin--> eep
05:36:04 <delYsid> oh
05:36:08 <delYsid> www.gmagames.com
05:36:14 <delYsid> I may have gotten the direct link wrong...
05:36:25 <Igloo> Ah, so the idea here is that the g* functions are generated automatically by DrIFT?
05:36:34 <Marvin--> Igloo: yeah, I guess
05:36:51 <Marvin--> Igloo: but since I don't have DrIFT I wrote my own that I *think* are correct
05:36:59 <Marvin--> Igloo: since I consider the strings in my data types to be leaves
05:37:09 <Marvin--> but maybe that's a mistake
05:37:34 <shapr> delYsid: do you have any working OpenAL code yet?
05:37:41 <Marvin--> what's OpenSL?
05:37:42 <Marvin--> er, AL
05:37:46 <Marvin--> damn keyboard
05:37:47 <shapr> delYsid: have you checked out the programming linux games book?
05:37:56 <shapr> Audio Layer I think
05:38:13 <Marvin--> oh
05:38:18 <shapr> I think loki developed it
05:38:31 <shapr> yes, I thought so
05:38:33 <shapr> http://www.openal.org/home/
05:38:42 <Igloo> Does mkM basically turn the function into a class that does nothing for anything of the wrong type?
05:39:23 <Igloo> Ah, and the reason it needs the scary flags is presumably because it has an instance for type tyvar which overlaps with the one you specified
05:39:49 <Marvin--> yes, that's what I figured (re the flags)
05:39:55 <Igloo> So don't you just want 2 mkM lines, one for decs and one for expressions?
05:39:57 <Marvin--> re the mkM/mkQ/mkT.. I can't say that I understand it!
05:40:10 <Marvin--> but I don't want it monadic...
05:40:28 <Marvin--> mkQ is for non-monadic queries, mkT for non-monadic transformations and mkM for monadic transformations
05:41:03 <Marvin--> I guess the safe casting takes care of not applying the wrapped function to the wrong things
05:41:04 <Igloo> But non-monadic queries are presumably really Maybe monad queries
05:41:43 <Marvin--> the maybe s (flip (:) s) ..  thing is stolen directly from the Main.hs file... *cough*
05:42:00 <shapr> delYsid: what docs are you starting with?
05:42:02 * Igloo is still looking at Main.hs
05:42:11 * Igloo looks at what you've done
05:42:24 <Marvin--> maybe you shouldn't :)
05:43:12 <Igloo> OK, so s is the state and x is the tree
05:43:53 <Igloo> So you need to update s to add a mapping for variable name to renamed variable name, which is similar to what you have, if it's a decl that binds something
05:45:23 <Igloo> And then gmap (foo s') x should collect all the mappings, so then the problem is to rewrite vars. Does that make sense?
05:45:45 <Marvin--> I'm not following
05:45:57 <Igloo> And I think you can probably make an ' in the same way
05:45:59 <Igloo> OK
05:46:39 <Igloo> s :: (String, [(String -> String)]); s = (prefix, mapping) OK?
05:47:07 <Marvin--> wait, let's do one thing at the time
05:47:17 <Marvin--> first I want to un-IO foo
05:47:42 <Igloo> OK, can you say foo s x = gmap (foo s) x?
05:47:50 <Igloo> Which should be the identity?
05:48:38 <Igloo> Ah, looks like I mean gmapQ. Although we might want gmapT.
05:48:40 <Marvin--> gmapT or gmapQ? :)
05:48:54 <Igloo> I'm not yet clear why both are needed
05:49:22 * Igloo skims through the paper
05:49:46 <Marvin--> in the case of  foo s x = gmapX (foo s) x  the typing will only accept gmapT
05:49:54 <Marvin--> I mean, what's an identity query anyway?
05:50:09 <Igloo> OK, let's use that then  :-)
05:50:20 <Igloo> Oh, I see, right, definitely T then
05:50:28 <Igloo> OK, does that compile and do nothing?
05:50:40 <Igloo> (well, act like id)
05:51:00 <Marvin--> let me derive Eq :)
05:51:17 <Marvin--> yes, foo [] ex2 == ex2
05:51:20 <Igloo> Pah, define it with gmap  :-)
05:51:26 <Igloo> OK, excellent
05:51:36 <Igloo> Now suppose s is as above
05:51:45 <Marvin--> (or rather, bar [] ex2)
05:51:47 <Marvin--> anyway
05:52:13 <shapr> does SDL include an OpenAL binding? or is it separate?
05:52:29 <Marvin--> hrrm, wait a sec, what's the prefix and what's the mapping in your s?
05:52:32 * Igloo thinks
05:52:44 <Igloo> Prefix is the function name prefix to use in new mappings
05:52:59 <Marvin--> hrrm...
05:53:29 <Marvin--> so in the case of  g x = let f y = ... in ...   s = ("g",xs)  but what are the elements in xs?  "f" -> "g_f"?
05:53:51 <Igloo> Yes (sorry, got distracted)
05:54:01 <Marvin--> I don't quite see the need for the function
05:54:08 <Marvin--> functionS!
05:54:14 <Igloo> "g_" actually
05:54:19 <Igloo> What functions?
05:54:25 <Marvin--> [String -> String]
05:54:35 <Igloo> Because we need to rewrite vars according to them
05:54:36 <Igloo> Don't we?
05:54:55 <Marvin--> but won't the function just be (prefix++) ?
05:55:15 <Marvin--> and  prefix  would be altered as we traverse the tree
05:56:08 <Igloo> Will prefix++ always be right with nested lets?
05:57:02 <Marvin--> with nested lets the prefix should change...   g x = let f1 y = (let f2 z = e1 in e2) in e3  =>  g x = e3 ; g_f1 y = e2 ; g_f1_f2 z = e1
05:57:20 * shapr gets responses to his HXmlToolbox feedback
05:57:39 <Igloo> It's the rewritings in e1, e2, e3 I'm worried about
05:57:58 <Marvin--> Igloo: yes, me too
05:58:19 <Marvin--> but isn't it a typical "substitute free occurrences of ..."?
05:58:48 <Igloo> Yes, but will the prefix be right at the point of substitutions?
05:58:52 <Igloo> Ah, no, it won't
05:58:57 <Marvin--> uh, well, that's what I'm worried about
05:59:18 <Igloo> let f = e1 in 1 + (let g = f 2 in 3)
05:59:24 <Igloo> f should be f, not g_f
05:59:35 <Marvin--> yes
05:59:42 <Igloo> So the mappingis needed, right?
05:59:49 <delYsid> shapr: www.openal.org
05:59:50 <Marvin--> I don't see how the list of mappings help though
05:59:53 <delYsid> i.e., the spec
06:00:17 <Igloo> Because when you see the f decl you put ("f", "f") in the list of mappings which you will then call lookup on
06:00:37 <Igloo> Actually ("f", prefix ++ "f"), but prefix = "" at that point
06:01:01 <Marvin--> oh, you didn't mean (String -> String) you meant (String, String)
06:01:28 <Igloo> Oh, sorry, yes, didn't notice you misunderstanding earlier
06:01:54 <Marvin--> I mean, [(String, String)]  and  String -> String  both make sense... [String -> String] doesn't... :)
06:02:18 <Igloo> Well, you could fold it, but anyway  :-)
06:02:41 <Igloo> OK, so actually you need to return (a, mapping) I think
06:02:42 <Marvin--> right so I've got data State = State { prefix :: String, mapping :: [(String,String)] }
06:03:02 <Igloo> Oh no you don't
06:03:08 <Marvin--> I don't? damn
06:03:14 <SyntaxPolice_> good morning
06:03:21 <Marvin--> SyntaxPolice: no :) I'm totally lost :)
06:03:27 <Igloo> I mean you only need to return a, not that your state is wrong
06:03:35 <Marvin--> oh, phew
06:04:21 <Igloo> OK, so you want something similar to isHsFunBind for the state changes
06:04:31 <Igloo> Actually you want 2 of them, one that updates the prefix and one that doesn't
06:04:54 <Igloo> Hmmm, I'm not sure how you use the right one in the right branch, though
06:05:17 <Marvin--> maybe I should just drop this idea and keep writing on my silly recursive function
06:05:32 <Igloo> Ah, the whole body of the function should be a case on the result of the query I think
06:05:50 <Marvin--> which is "the function" right now?
06:06:08 <Marvin--> and we've still not written any queries, only an identity transformation...
06:06:16 <Igloo> OK, we did have
06:06:17 <Igloo> foo s x = gmap (foo s) x
06:06:20 <Igloo> Now we want
06:06:31 <Igloo> foo s x = case s1 of
06:06:45 <Igloo>     Nothing -> gmap (foo s) x
06:07:11 <Igloo>     Just x' -> x'
06:07:15 <Marvin--> gmapT?
06:07:22 <Igloo>   where s1 = doBind s x
06:07:24 <Igloo> Yes, sorry
06:07:41 <Igloo> doBind :: State -> Dec -> Dec
06:07:51 <Igloo> doBind :: State -> Dec -> Maybe Dec
06:08:56 <Igloo> doBind (pref, mapping) (Bind f e exp) = Bind (pref ++ f) (gmapT mapping1 e) (gmapT mapping2 exp)
06:08:57 <Marvin--> and that would be a function that in turn uses a transformation on the expression?
06:09:34 <Igloo> doBind (pref, mapping) (Bind f e exp) = Bind (pref ++ f) (gmapT (pref ++ f ++ "_", mapping' e) (gmapT (pref, mapping') exp)
06:09:54 <Igloo>   where mapping' = (f, pref ++ f)
06:09:56 <Marvin--> where'd the Maybe go?
06:10:04 <Igloo> Oh, I lost it  :-)
06:10:12 <Igloo> It always returns Just (what I said)
06:10:15 <Marvin--> yeah
06:10:48 <Marvin--> wait wait wait, the 'e' here is my list of patterns, they don't need transforming
06:10:57 <Igloo> If I'm right that should rename the bound names in decls correctly but not deal with vars
06:11:02 <Marvin--> I have  DFun f ps e
06:11:35 <Igloo> By "Bind f e exp" I meant   let f = e in exp
06:11:42 <Marvin--> oh
06:11:48 * Marvin-- grumbles
06:11:52 <Igloo> If you have patterns then it'd get a bit more complex
06:11:58 <Marvin--> that's my ELet, which is in Exp, not in Decl
06:12:14 <Marvin--> never mind the patterns, I only need to rename the function variables
06:12:30 <Marvin--> (and they're easily found as I have   EFun String [Exp] | EVar String | ...
06:12:33 <Igloo> Oh, yes, I haven't really been talking about decls have I
06:12:46 <Marvin--> damn straight you haven't, you're confusing me :)
06:12:52 <Igloo> Sorry  :-)
06:12:57 * Igloo will shut up if you'd prefer
06:13:54 <Marvin--> I think I'll need one function for Decl and one for Exp, and both wrapped in mkT
06:14:26 <Igloo> It's just made slightly more complex as you have lists of Decls rather than a single binding
06:15:06 <Marvin--> yes, I have letrecs really
06:15:32 <Marvin--> which is what I missed in my first implementation of this damn transformation
06:15:54 <Marvin--> but I think I'll drop the gmap idea and try to get something done instead
06:15:58 <Marvin--> I may revisit this later
06:16:01 <Igloo> Heh, OK
06:16:01 <Marvin--> thanks for your help
06:16:11 <Igloo> np
06:16:18 * Igloo may try to find time to play later
06:16:46 <shapr> good morning SyntaxPolice
06:17:00 <shapr> hey, I think xml-rpc could be done with HXmlToolbox
06:17:19 <Marvin--> ick
06:17:54 <shapr> I want to call hws-wp from Zope :-)
06:19:04 <Marvin--> ELUNATIC
06:19:12 * shapr laughs
06:19:20 <Marvin--> you have to succeed with a SAN roll to continue
06:21:02 * Marvin-- is fearful of his own SAN rolls too
06:21:11 <shapr> hey, you wrote hws-wp
06:21:20 <shapr> that's gotta cost you a coupla SAN points
06:21:25 <Marvin--> so I did
06:21:29 <Igloo> SAN?
06:21:33 <Marvin--> Igloo: SANity
06:21:42 <Igloo> Oh, how dull
06:21:43 <shapr> Igloo: from the game "Call of Cthulhu"
06:21:47 <Marvin--> Igloo: you have to make SAN rolls in cthulu all the time
06:21:56 <Igloo> Ah, OK
06:22:01 <shapr> where the whole point is to try to drive out the demonic influences without going insane.
06:22:04 <Igloo> What sort of game is it?
06:22:09 <Marvin--> roleplaying
06:22:22 <shapr> it's set in the early 1900s, indiana jones style
06:22:27 <shapr> well, HP Lovecraft styl
06:22:39 <Marvin--> Lovecraft is all it is :)
06:22:41 <shapr> since he wrote everything there is to read about the Cthulhu mythos
06:22:50 <Igloo> Oh well
06:22:58 <shapr> Shub-Niggurath, Nyarlathotep, etc
06:23:15 * Marvin-- fondly thinks back to a convention a few years ago where he played some free-form Cthulu with some friends in the middle of the night
06:23:22 <Marvin--> that wasn't really sanity-preserving in itself
06:23:46 <Marvin--> we skipped all the die rolling altogether, and didn't have any character sheets, it was all very free-form
06:23:56 <shapr> that's really the best way to do it
06:23:58 <Marvin--> oh yes
06:24:18 <shapr> Igloo: for years I've been talking about technologies in terms of their SAN point gain or loss.
06:24:21 <Marvin--> heh, the GM gave us all a trait we should try to act on during the session
06:24:27 <shapr> Python gives SAN points, Java takes them away.
06:24:38 <Marvin--> though I didn't get a trait, I got a car instead :P
06:24:44 <Lilith> what's SAN?
06:24:46 <shapr> yay!
06:24:49 <shapr> Lilith: SANity
06:24:51 <Marvin--> <Marvin--> Igloo: SANity
06:25:25 <shapr> <Marvin--> <Marvin--> Igloo: SANity
06:25:32 * shapr gets into the spirit of repasting
06:25:33 <Lilith> ah
06:25:41 <shapr> nyehowma Lilith 
06:25:45 <Marvin--> shapr: the frame story was that we went to visit the uncle of one of us during the halloween break (we were students)
06:25:57 <Marvin--> shapr: mysterious things Happened :)
06:25:58 <Lilith> what do you mean by sanity points?
06:26:13 <Lilith> shapr: hao :-)
06:26:24 <shapr> Lilith: in the game "Call of Cthulhu" if your sanity points drop to zero, you go insane and can no longer play your character
06:26:27 <Marvin--> shapr: and we were all very suspicious of each other, which was very fun :) and most of all we were suspicious about Karl since it was his uncle :)
06:27:26 <shapr> that makes sense
06:27:55 <shapr> Lilith: I claim that professional software development is a lot like playing Call of Cthulhu
06:28:03 <Lilith> shapr: oh. i was just wondering what you meant by "Python gives SAN points, Java takes them away."
06:28:15 * Lilith blinks
06:28:19 <Lilith> i see now :-)
06:28:40 <Lilith> I think Zope takes away SAN points then :-)
06:28:50 <shapr> well, it's sort of even
06:28:55 <shapr> if you need Zope help, ask me
06:29:37 * Marvin-- has found that Haskell can both give and take SAN
06:29:52 <Marvin--> writing Haskell can be both, and reading Haskell can definitely be both :)
06:29:54 <shapr> Zope uses Python, so it increases SAN, but it's totally against unit testing, so it takes away SAN
06:30:25 <Lilith> the Zope interface drove me crazy
06:30:38 <Lilith> but then so did trying to design pdf documents in python :-)
06:30:49 <shapr> oh, did you use reportlab?
06:30:55 <Lilith> yes
06:31:02 <shapr> I use XEmacs to edit zope stuff
06:31:24 <shapr> if you're an emacs user, I can tell you how that works.
06:31:42 <Lilith> sure :-) 
06:31:43 <opet> shapr: what don't you use emacs for..? :)
06:31:52 <Lilith> opet: nothing probably :-)
06:31:55 <shapr> imho, ZPT is much simpler than DTML, since ZPT doesn't change the DTD
06:32:04 * shapr tries to think of a good answer
06:32:27 <delYsid> @fact SAN
06:32:27 <lambdabot> Sorry, I don't know the command "fact", try "lambdabot: @listcommands"
06:32:31 <Lilith> i hope you're not one of those people who do everything in emacs :-)
06:32:40 <delYsid> I am!
06:32:41 <shapr> who, me?
06:32:48 <shapr> yah, delYsid taught me everything I know
06:32:53 <shapr> he's the expert.
06:32:59 <delYsid> hehe, that is a too general sentence :)
06:33:00 <shapr> I'm just a user.
06:33:04 * shapr grins
06:33:12 <Lilith> that's pretty scary :-)
06:33:39 <delYsid> Emacs is the center of my data-gathering universe
06:33:44 <shapr> I have written some elisp modules, but I'm not very good at it.
06:33:48 <delYsid> I'm using ERC Version 4.0 $Revision: 1.519 $ with Emacs 21.3.50.3!
06:33:50 <shapr> delYsid wrote most of the IRC client I'm using.
06:33:53 <shapr> I'm using ERC Version 4.0 $Revision: 1.526 $ with XEmacs 21.4 (patch 12) "Portable Code" XEmacs Lucid!
06:33:59 <shapr> g'day Cowgirl 
06:34:04 <Cowgirl> hey!
06:34:06 <Cowgirl> how are u?
06:34:13 <shapr> doing well, how are you?
06:34:29 <shapr> has your computer walked the plank yet?
06:34:30 <Igloo> Bah, gmap fails to build with CVS GHC
06:35:12 <delYsid> pffft, this heat is killing me
06:35:16 <Cowgirl> im fine.....given up on the colors.....will reinstall xemacs i think
06:35:19 <Cowgirl> when i get the chance
06:35:23 <shapr> I wrote an elisp module to control xmms via xmms-shell
06:35:30 <shapr> Cowgirl: I think that will help
06:35:48 <shapr> Cowgirl: I'd suggest installing into a directory like C:\xemacs\
06:35:49 * delYsid aquires an evil grin
06:36:01 <delYsid> yah, XEmacs is like Windows, a reinstall cures it
06:36:06 <delYsid> deletion cures it even more :)
06:36:08 <Lilith> emacsOS. that's so evil :-)
06:36:12 <Igloo> Marvin: Did make just work for you?
06:36:15 <shapr> specfically not under "C:\Program Files" because the space in the dir makes life difficult
06:36:35 <shapr> the downside of xmms is that it requires X, so I'm trying to rewrite my module to work with alsaplayer
06:36:38 <Cowgirl> yeah......to uninstall it, is there a uninstall file??
06:36:44 <Cowgirl> cant remember seeing one
06:36:46 <Igloo> Oh, actually, it's probably the make brokenness
06:36:57 <delYsid> shapr: use ecasound.el :)
06:37:03 <shapr> Cowgirl: Start -> Settings -> Control Panel -> Uninstall Software -> XEmacs
06:37:11 <shapr> delYsid: can that play FLACs ?
06:37:26 <Cowgirl> ok, thought so, didnt remember seeing it
06:37:30 <delYsid> :/ not yet.
06:37:39 <delYsid> but its on Kai's todo list
06:37:40 <shapr> Cowgirl: not sure it'll be there, but it's good place to look
06:38:42 <wli> I've not been having luck with cvs ghc
06:39:18 <wli> seems to be some kind of codegen error in Binary.hs
06:39:56 <wli> which leads me to suspect I've got a bug in my version of ghc
06:40:08 <wli> (the one used to bootstrap cvs with)
06:41:11 <wli> which is just 5.02 built with more ways than debian builds by default
06:43:02 <Cowgirl> cant find any uninstall for xemacs, not in control panel, or its own folder
06:43:10 <Cowgirl> anyone know how to uninstall it?
06:43:36 <delYsid> Shift-DEL on the directory?
06:44:43 <Cowgirl> yeah, but that could delete some .dll files used by windows
06:45:00 <Cowgirl> and that wouldnt remove registry entries would it?
06:45:02 <delYsid> how so?
06:45:19 <delYsid> I doubt XEmacs needs a registry entry...
06:45:23 <delYsid> but I honestly dont know
06:45:55 <Cowgirl> i remember i deleted a game once and somehow deleted Rundll32   had to reinstall windows!
06:46:11 <delYsid> heheh, good girl
06:46:35 <Cowgirl> u know how programs install files not only in its own directory, but also in windows.
06:47:00 <delYsid> sure, but Shift-DEL on that directory shouldnt delete any completely unrelated .dlls, should it?
06:47:04 <Cowgirl> dont know how i deleted rundll32 though, never done it that way since then, deleting the whole folder
06:47:13 <Cowgirl> i got no idea
06:47:24 <Cowgirl> whats the difference between that and just hitting delete??
06:47:53 <delYsid> it dumps the files, without moving them into trashcan
06:48:06 <delYsid> i.e., what DEL should do by default.
06:48:51 <Cowgirl> so u cant recover them??  like recycle bin does??
06:49:00 <delYsid> yup
06:49:32 <Lilith> delYsid: don't you wish you had that functionality sometimes though? when you do rm -rf * by accident? ;)
06:49:47 <wli> ISTR hearing of something like mod_haskell this person's asking about
06:49:47 <delYsid> Lilith: I dont do that
06:50:14 <Cowgirl> i'll try and find out if theres a better way, too many times i have deleted a whole folder, never a happy ending!
06:50:34 <Cowgirl> i need the HD space to!
06:51:07 <delYsid> Lilith: I am one of those guys who hate redhat's default, i.e., you need to specify -f with rm
06:51:12 <wli> I'm not even sure what mod_perl does
06:51:26 <delYsid> If I fucking want to delete something, this fucking computer shouldnt ask me if I'm sure!
06:51:46 <Cowgirl> what if u hit delete by accident?? :)
06:52:21 <delYsid> Cowgirl: Doesn't happen that often, since I spend approx. 1% of my computer time infront of a Windows box
06:52:27 <Cowgirl> i deleted 400 mp3s once....lost them all! 
06:52:42 <Igloo> Oh, drift makes Typeable instnaces too so my guess as to why it needed overlapping instances was wrong
06:52:50 <Lilith> heh
06:52:55 <Lilith> that's why i use zsh.
06:53:05 <Lilith> it does that for me by default
06:53:08 <delYsid> yay, zsh!
06:53:41 <delYsid> I use zsh because of its kick-ass completion :)
06:54:24 * delYsid realizes how far he is OT and vanishes
06:56:22 <wli> I use zsh b/c hte editing lets me type and edit commands better than ksh (which in turn does better than bash/tcsh/etc.)
06:56:32 <wli> that and I can't get a real ksh
06:58:08 <Lilith> hmm
06:58:17 * Lilith was a bash weenie before she saw the light
07:04:08 <Cowgirl> whats the command to run GHCI in xemacs...
07:04:51 <shapr> I luv zsh
07:04:54 <shapr> it rocks
07:08:41 * mgoetze agrees fully with shapr
07:09:00 <mgoetze> (especially when emacs keybindings are disabled, hrhr)
07:09:56 <shapr> :-P
07:12:34 * mgoetze has his own set of fully customized zsh keybindings
07:15:16 <delYsid> Cowgirl: Load up a .sh file, M-x turn-on-haskell-ghci RET
07:15:19 <delYsid> C-c C-l
07:15:26 <delYsid> s/sh/hs/
07:17:28 <Cowgirl> thanx :)
07:17:38 <Cowgirl> u mean .hs file though?
07:17:52 * shapr boings
07:18:15 <Igloo> Are any gmap people around?
07:20:10 <Marvin--> Igloo: heh, did I trick you into playing with it? :)
07:20:55 <Igloo> It was on my list anyway  :-)
07:21:29 <Igloo> I can see how it would work if I had a function a -> Foo, but with a -> a I don't see how I use mkQ
07:21:51 <Marvin--> but isn't that the point? You use mkT with a -> a, and mkQ with a -> Foo
07:22:33 <Igloo> I only want to transform for a specific type, though
07:22:53 <Marvin--> "A generic query has a type of the following form: forall a. Term a => a -> R  Here R is some fixed result type."
07:23:22 <Igloo> That could explain my problem
07:23:50 <Igloo> OK, so how do I say foo :: a -> a unless a == Exp in which case do this instead?
07:24:15 <Igloo> I could probably write it differently, actually
07:24:46 <Marvin--> I think you need a different transformation function T -> T for every type T you're interested in
07:25:22 <Marvin--> I mean, you can't very well pattern match on "a unless a is Exp" anyway
07:26:04 * Marvin-- thinks his new renaming function works
07:26:05 <Igloo> Well, that's what mkQ does...
07:26:38 <Marvin--> no, mkQ takes a function   T1 -> T2  and turns it into a  forall a. a -> T2  function, doesn't it? and uses safe casts to figure out when it should be applied
07:26:52 <Igloo> Well, it boils down to the same thing
07:27:13 * Igloo looks unconvinced I can write this after all
07:27:34 <Igloo> Oh, maybe I can
07:28:13 <Marvin--> maybe it does, I don't quite understand it
07:29:25 <Igloo> I don't think it can be done without using casts that I know will succeed, though
07:30:24 <shapr> yargh
07:31:19 <Marvin--> I think I got my renaming function to work now, anyway
07:31:26 <Marvin--> Igloo: on your example too
07:31:56 <Igloo> On my example?
07:32:07 <Marvin--> <Igloo> let f = e1 in 1 + (let g = f 2 in 3)
07:32:12 <Igloo> You aren't using gmap though, right?
07:32:15 <Marvin--> no
07:32:25 <Marvin--> but now that I have working code, maybe I can convert it to using gmap :)
07:32:41 <Marvin--> or maybe I should get my head examined
07:33:17 * Igloo gets confused by errors
07:34:22 * Marvin-- does the working code dance
07:34:50 <Igloo> Oh, I need to be able to say Term Exp I think. But it should already know that. Confused.
07:35:06 <Igloo>     Mismatched contexts
07:35:06 <Igloo>     When matching the contexts of the signatures for
07:35:06 <Igloo>       gEnvTraversal :: forall a. (Term a) => State -> a -> a
07:35:06 <Igloo>       do_let :: State -> Exp -> Maybe Exp
07:35:06 <Igloo>     The signature contexts in a mutually recursive group should all be identical
07:35:09 <Igloo>     When generalising the type(s) for gEnvTraversal, do_let
07:35:12 <Igloo> Any ideas?
07:35:41 * Marvin-- boggles
07:35:48 <Marvin--> Igloo: no?
07:36:25 <Igloo> I'll try moving the cast into do_let
07:36:31 <Marvin--> jolta: http://www.cs.vu.nl/Strafunski/gmap/
07:36:41 <Marvin--> Igloo: damn, are you still working on my problem?
07:36:51 <Igloo> Yes
07:37:14 <Marvin--> not...not that I don't appreciate it, but...why? :)
07:37:14 * Igloo giggles having noticed "Just $ fromJust $ "
07:37:21 <Igloo> Because I want to be able to do it
07:37:24 <Marvin--> oh
07:37:32 <Marvin--> as good a reason as any, I guess
07:37:32 <jolta> Marvin--: oooh, rank-2 polymorphism.
07:37:41 <Igloo> OK, that compiles
07:37:42 <Marvin--> jolta: oh yes
07:37:46 <tmoertel> Igloo: did you look at everywhereBut ?
07:38:13 <Igloo> No - maybe I should read the docs  :-)
07:38:21 <Igloo> But this is working now so I'll work with it and read later
07:38:25 <Marvin--> tmoertel: ouch
07:38:48 <tmoertel> sometimes the docs containg the Good Stuff ;-)
07:39:08 <wli> I thought rank 2 type inference was undecidable
07:39:23 <wli> maybe it's by explicit decl only
07:39:36 <tmoertel> wli: yup, you must annotate
07:40:59 <tmoertel> f g (x,y) = (g x, g y)
07:41:54 <tmoertel> f id ('a', "hi") ----> doesn't type check
07:41:58 <tmoertel> however,  f2 :: (forall a. a->a) -> (b, c) -> (b, c)
07:42:12 <tmoertel> f2 g (x,y) = (g x, g y)
07:42:30 <tmoertel> f2 id ('a', "hi") ----> ('a', "hi")
07:43:12 * tmoertel needs coffee
07:46:47 * shapr cheers for unit testing
07:46:57 <shapr> I have been saved sooo many hours of debugging
07:48:06 * shapr needs more coffee
07:49:15 <shapr> today's useful emacs trivia: bind zap-to-char to C-z to make life easier
07:53:56 <tmoertel> (unless you also use Windoze, in which case you'll accidently hit C-z a few times thinking it is Undo)
07:54:10 * shapr grins
07:54:35 * tmoertel thinks that he missed a joke somewhere, owing to lack of caffeine
07:55:18 <shapr> I was just thinking of someone zapping a bunch of text and then trying to undo it
07:55:22 <shapr> and then zapping again
07:56:15 <shapr> <skreech> If MS had bought Nintendo then Pikachu could be an MS Office Assistent.
07:56:15 <shapr> <shapr> paperclippachu, irritation attack!
07:56:15 <shapr> <shapr> paperclippachu, window close immunity!
07:59:48 <Igloo> Marvin: I think I've got it working
08:00:57 * shapr bounces happily
08:01:07 <Marvin--> Igloo: cool! Could you mail me the code?
08:01:26 <Marvin--> or put it up somewhere on the web
08:04:18 <Igloo> http://urchin.earth.li/~ian/gmap/
08:04:52 <Igloo> If you find any bugs, make any improvements or find a way to get rid of the nasty casts I'm interested
08:04:54 <Marvin--> .ds as in DrIFT?
08:04:58 <Igloo> Yes
08:05:03 * Marvin-- grumbles
08:05:04 <Igloo> Do you want the generated files?
08:05:07 <Marvin--> yes, please
08:05:35 <Igloo> Datatypes.hs is there too now
08:10:39 <baha> hi anybody here?
08:11:20 <Igloo> No
08:11:59 <Marvin--> Igloo: yeah those explicit casts look nasty
08:12:20 <baha> how'd u go about writing a set dimensioned text based board recursively?
08:14:33 <o3_> dang, ghc head doesn't build
08:15:01 <mgoetze|away> o3_: try the tail :)
08:15:21 <o3_> hmm, don't think i want to build everything except the latest version ... it would take a while ;)
08:16:58 * o3_ reruns configure with --disable-hopengl and tries again
08:17:06 <o3_> hey, my nickname's spelt wrong
08:17:32 <baha> anybody here feeling helpful today?
08:18:25 <o3> i'm usually not, but i'll try :)
08:18:44 <delYsid> a "set dimensioned text based board" ?
08:19:11 <baha> yeh
08:19:20 <baha> so ur given dimension m x n
08:19:23 <baha> board would be like
08:19:27 <baha> 1 ooo
08:19:29 <baha> 2...
08:19:31 <baha> i mean
08:19:33 <baha> it should be:
08:19:34 <baha> 1 ooo
08:19:38 <baha> 2 ...
08:19:40 <baha> 3 xxx
08:19:41 <delYsid> tictactoe you mean...
08:19:48 <baha> whats that mean?
08:19:52 <delYsid> I have TicTacToe.hs here if it is of any help for you...
08:20:02 <baha> where can i DL it? :)
08:20:08 <delYsid> wait
08:20:12 <baha> i jus would like how'd u go about doing this recursively
08:20:23 <baha> since the size, ie. cols n rows can be different
08:20:24 <delYsid> I dunno what recursion has to do with that
08:21:01 <baha> pm
09:26:15 <shapr> hi sharevari 
09:26:42 <sharevari> hello, is there any discussion going on here?
09:26:46 <shapr> sharevari: yes, lots
09:26:53 <shapr> but nothing at this moment
09:26:56 <sharevari> haven't noticed any in the last hour... ;)
09:26:58 <shapr> sharevari: do you have any questions?
09:27:12 <shapr> sharevari: look at the channel logs, you'll see we have lots
09:27:15 <sharevari> well, yeah, having a bit of trouble with io...
09:27:31 <shapr> I'm going shopping for a few mins, but I'll be right back
09:27:47 <shapr> if you ask your question, someone else may be able to help you also
09:27:53 <sharevari> ok, thanks
09:28:03 <shapr> back in twenty mins
09:35:47 <dennisb> sharevari: so, what's the question?
09:36:18 <sharevari> hello dennis, ok let me try to explain
09:36:25 <dennisb> sure
09:36:45 <sharevari> i have a big function exec with different patterns it can match
09:36:58 <sharevari> the definition for one of these patterns needs to print a value
09:37:04 <sharevari> but it's the only one that does
09:37:16 <sharevari> so, i want to be able to do io only in there but can't...
09:37:35 <dennisb> ok, but the function must have exact one return type, so all branches need to have the same type
09:38:01 <sharevari> yep, i know. i'm thinking the main needs to return IO a but this creates lots of difficulties
09:38:23 <dennisb> what type do you want the function to have?
09:38:50 <sharevari> right, it's a bit involved. function decl looks like this:
09:38:57 <sharevari> exec :: Com -> (Env Int, Env Com) -> (Env Int, Env Com)
09:39:06 <sharevari> where Com and Env are types I've defined
09:39:17 <dennisb> yes, main must always be of type IO 
09:39:29 <sharevari> type Env a = [(String, a)]
09:39:36 <dennisb> Ok, that function can not do any IO
09:39:46 <sharevari> it's basically an interpreter for a very simple language
09:39:54 <sharevari> that executes statements
09:40:04 <dennisb> if it should do IO then the type needs to be: exec :: Com -> (Env Int, Env Com) -> IO (Env Int, Env Com)
09:40:20 <sharevari> yeah, true
09:40:32 <dennisb> the result is an IO-computation that returns a tuple (Env Int, Env Com)
09:41:03 <sharevari> it's just that exec needs to return the tuple (Env Int, Env Com) without the IO for it to work
09:41:16 <dennisb> well, then it can't do any IO
09:41:31 <dennisb> I think you can make it work even with IO (Env Int, Env Com
09:41:33 <dennisb> )
09:41:35 <sharevari> yeah i've got into a bit of a dead end...
09:42:00 <sharevari> one line for example:
09:42:00 <sharevari> exec (Seq c1 c2) env          = (exec c2 (exec c1 env))
09:42:02 <dennisb> how do you call this function?
09:42:28 <sharevari> this executes a sequence of statements and returns the new environment
09:42:37 <dennisb> aha, that will of course not work when the type has changed
09:43:04 <sharevari> and i can't see a way of incorporating io...
09:43:31 <dennisb> remember that any of the two calls to exec can do some IO, and since haskell is a lazy language you don't know in what order the two exec calls will execute. Then you can get the output in any order
09:43:48 <sharevari> right
09:43:58 <dennisb> what you need to do is to use do-notation to call the exec functions in the correct order
09:44:16 <dennisb> IO shall always be ordered by the programmer
09:44:33 <dennisb> Have you used do-notation?
09:44:35 <sharevari> ok, but most of the branches do not use any io at all
09:44:59 <sharevari> should i just perform the calculations with do and then return the tuple with return?
09:45:06 <dennisb> well, then they will probably just be .... = return (some big expression)
09:45:14 <dennisb> yes
09:45:23 <dennisb> yes, return a tuple of course
09:45:33 <sharevari> and then i'll make the second argument to exec be an IO (Env Int, Env Com)?
09:46:03 <dennisb> No, I don't think you need that
09:46:04 <sharevari> would that be the right way to go?
09:46:16 <sharevari> but how else can i feed them into each other?
09:46:26 <dennisb> that's what do-notation lets you do
09:46:45 <dennisb> (or >>= notation, but do is nicer)
09:49:03 <dennisb> should I write some example using do-notation?
09:52:06 <norpan> hej dennisb 
09:52:11 <dennisb> seems like you either got tired or are trying yourself, the later is of course good!
09:52:16 <dennisb> norpan: hello
09:52:19 <dennisb> what's up?
09:52:28 <norpan> working
09:52:35 <norpan> getting stupid warnings from ghc
09:52:40 <dennisb> aah, the old working trick
09:53:00 <dennisb> there are no stupid warnings
09:53:03 <dennisb> just stupid code
09:53:27 <norpan> no
09:53:31 <norpan> i use the ffi
09:53:41 * shapr boings
09:53:50 <norpan> and i include the header files using the fli syntax
09:54:06 <norpan> this means ghc adds the header files to the intermediate .hc files
09:54:24 <norpan> in my .h file i have functions declared as const char *function
09:54:30 <norpan> because they return static strings
09:54:36 <dennisb> ok
09:54:49 <norpan> but the ghc code generator assigns them to pointers not declared const
09:54:52 <norpan> hence warnings
09:55:02 <norpan> even though it's not modified of course
09:55:10 <dennisb> ok, some warnings are stupid then :-)
09:55:37 <dennisb> I wonder why I'm connected to an australian freenode node
09:55:52 <dennisb> ok, we lost him over to the other side...
09:57:03 <dennisb> it's kind of stupid to send messages to australia and back when talking to norpan who is in the same city :-)
09:57:29 <norpan> dennisb: i'm using an italian node
09:57:30 <dennisb> The lost son is back again!
09:57:32 <sharevari> hello dennis, still there?
09:57:37 <dennisb> sure
09:57:44 <sharevari> ah, my isp decided to disconnect me for some reason!
09:57:49 <sharevari> had to reset my cable modem...
09:57:56 <dennisb> np
09:58:21 <dennisb> now the question is where I lost you
09:58:28 <sharevari> thanks for the help so far, really appreciate it, think i might have missed something earlier, you saud i didn't need to make the second arg IO...
09:58:43 <dennisb> yes, you should use do-notation
09:58:52 <sharevari> yeah, i understand that
09:59:09 <sharevari> but it will still return something of type IO (Env Int, Env Com)
09:59:12 <dennisb> it lets you perform a computation and geting the raw value out so you can send it to another IO-computation
09:59:48 <sharevari> the raw value? i thought that was impossible? it's always IO rawvalue, isn't it?
09:59:59 <dennisb> lets take a small example, do you know about readFile?
10:00:07 <dennisb> it has type: FilePath -> IO String
10:00:13 <sharevari> erm, not really, i know about screen io...
10:00:27 <dennisb> of course, after you have read in the file you want to use the String (not the IO String)
10:00:37 <sharevari> yeah ok i'm with you
10:00:58 <dennisb> lets say we wants to print out the length of that string. So we write a function of type String -> IO ()
10:01:09 <dennisb> it takes the string, and does som output
10:01:14 <sharevari> and then you do x <- length s ?
10:01:20 <dennisb> plen x = print (length x)
10:01:34 <dennisb> plen :: String -> IO ()
10:02:04 <dennisb> so now we have one function that produces and IO String and one that wants just the String as input to produce some more IO
10:02:18 <sharevari> yep, ok
10:02:44 <dennisb> so, how do we combine these. We can't write: plen (readFile "/tmp/foo.txt")
10:02:55 <dennisb> then it would complain that String is not the same as IO String
10:03:22 <dennisb> this is where you use do. you write: do { str <- readFile "/tmp/foo.txt"; plen str }
10:03:42 <sharevari> ok, i see. that makes sense.
10:03:52 <dennisb> readFile "/tmp/foo.txt" has type IO String, therefor str has type String
10:04:19 * delYsid prefers readFile "/tmp/foo.txt" >>= plen
10:04:33 <dennisb> you can do the same thing with exec to get out the tuple that you send into the next exec
10:04:33 <sharevari> so i should rewrite my current code (which is non-IO) with do statements?
10:04:50 <dennisb> thus the second argument can be just a tuple and not a IO tuple
10:04:54 <dennisb> yes
10:05:09 <sharevari> ok, i will try that.
10:05:36 <sharevari> i was just hoping i shouldn't have to as i've got everything working apart from the print statement written without do... ;)
10:05:45 <dennisb> or using >>= which is the same thing as do but which is a more primitive syntax
10:05:50 <dennisb> well, there is no other way
10:06:06 <dennisb> you can not do IO unless your functions returns something of type IO ...
10:06:51 <delYsid> and then you'll find functions like "trace" which totally destroy your believe in a perfect world :)
10:06:55 <sharevari> yeah true. when i started i made the wrong assumption that i could just deal with the IO in the exec (Print x) env branch, that's where I went wrong...
10:07:14 <dennisb> and also, you really need to order the IO in some way, we cant just have string being outputed in any order
10:07:57 <dennisb> sharevari: you can probably still keep the main structure of the functions, so it shouldn't be that hard to add some return here and there
10:08:35 <dennisb> delYsid: now, don't destory the nice and pure world for him
10:08:52 <sharevari> you're probably right, it's mainly the 10-line implementation of for loops that i just got working that i'm worried i will rip to pieces again. ;)
10:08:59 <dennisb> there are ugly hacks that one can use, but they are really ugly and unsafe so lets not...
10:09:08 <sharevari> as for perfect world, i'd never believe in such a thing, don't worry!
10:09:19 <dennisb> :-)
10:09:50 <sharevari> thanks a lot for you help!
10:10:00 <sharevari> are there always knowledgeable people hanging around here?
10:10:04 <dennisb> I guess all your statements will have to deal with IO, the expression can probably do without
10:10:19 <dennisb> always. always!
10:10:37 <sharevari> fantastic :)
10:10:48 <dennisb> we have no life
10:11:33 <sharevari> :) it always comes as such a pleasant surprise when you get random strangers on the internet helping you with your problems. anyway, i'm off to try your suggestions.
10:53:48 * shapr sings happily
11:02:27 <grem> hey shapri have a quick question...
11:03:34 <grem> newMVar >>= \ data_var     where do i go to find a list of the operators like >>= and what they do?
11:04:03 <grem> also the \ data_var is that the same as \data_var or is the \ and operator also?
11:05:12 <Igloo> \ x and \x are the same
11:05:28 <Igloo> And the standard prelude, or the report (at haskell.org/definition IIRC)
11:05:46 <grem> Igloo: so its an anonymous function definition then?
11:06:05 <delYsid> a lambda
11:06:14 <Igloo> Yes
11:06:15 <grem> delYsid: thats what i meant
11:07:13 <delYsid> do { data_var <- newMVar; ... } -- the same thing
11:07:25 <delYsid> i.e., >>= and do-notation are tightly related
11:07:53 <grem> delYsid: ah, i think i understand
11:10:06 <grem> so newMVar >>= \data_car -> net MVar >>= \ack_var -> put MVar ack_car() >> return (data_var, ack_var) --Could be rewritten as what?
11:10:25 <grem> the net MVar is suppose to be newMVar
11:11:52 <Smerdyakov> That didn't look like very useful code.... you through away the result of the first newMVar.
11:11:53 <delYsid> do { data_car <- newMVar; ack_var <- newMVar; putMVar ack_car; return (data_var, ack_var) }
11:11:55 <delYsid> I think
11:11:58 <Smerdyakov> s/through/threw
11:12:55 <Smerdyakov> Unless I misunderstood association of the operators, that is.
11:12:56 <grem> Smerdyakov: the data_var is returned, that is what the firse newMVar is suppose to be, not data_car, but data_var
11:13:10 <Smerdyakov> I guess I did mess up the association =)
11:14:46 <grem> is there an advantage to doing it with >>= instead of the do notation?
11:14:55 <delYsid> personal preference
11:15:08 <delYsid> oh, well, maybe if you already have a function which takes on arg...
11:15:10 <delYsid> then you can do
11:15:16 <delYsid> something >>= that-other-function
11:15:25 <delYsid> which in do notation you'd need to write 
11:15:46 <delYsid> do { some_var <- something; that-other-function some_var }
11:16:43 <grem> delYsid: i seem to understand the do alot better, i will stick with do for now
11:19:31 <delYsid> hm
11:38:31 <shapr> hi pesco 
11:45:57 --- mode: adams.freenode.net set +n
11:45:58 <Janni> n'evening!
11:46:57 <shapr> y0 Janni 
11:54:13 <sharevari> i'm back again, i've got stuck. :( anyone willing to help?
12:04:02 <Riastradh> What's your question?
12:08:21 * Riastradh pokes sharevari.
12:20:46 <tmoertel> SM+SPJ's "Making a fast curry: Push/enter vs eval/apply for higher-order languages" is a fun read: http://research.microsoft.com/~simonpj/papers/eval-apply/
12:21:24 * tmoertel notes that eval/apply will be used in forthcoming GHC versions
12:23:28 <tmoertel> in the benchmarks, the authors observe that switching from p/e to e/a in GHC increased memory reads by about 1% but reduced writes by about 5%
12:24:30 <tmoertel> but, by and large, the two methods yield similar run-time characteristics
12:27:10 <tmoertel> what makes e/a the win is that it reduces the need for certain kinds of complexity that creep into high-performance runtimes for p/e
12:27:53 <tmoertel> e/a is also easier to implement in terms of a portable assembly language (e.g., C--)
12:29:08 <tmoertel> yay! the new HC&A Report is out: http://www.haskell.org/communities/
12:31:01 <sharevari> sorry Riastradh, managed to solve it now.
13:02:33 <Igloo> Gah! Just realised IOHCC results should have been in HC&A
13:19:01 <Marvin--> HC&A?
13:26:40 <tmoertel> where are the IOHCC results ?
13:30:41 <Igloo> http://www.haskell.org/communities/05-2003/html/report.html
13:30:51 <Igloo> And nowhere TTBOMK  *prods shapr*
13:43:04 <Marvin--> Igloo: oh, you were replying to me, I thought you were replying to tmoertel, you had me really confused there
13:50:52 <grem> i am trying to compile an example in the Gentle introduction to haskell but i get an error saying The last statement in a 'do' construct must be an expression 
13:51:07 <grem> the line it errors on is                   if c == '\n'
13:51:31 <grem> getLine_     =  do c <- getChar                  if c == '\n'            then return ""
13:51:40 <grem> getLine     =  do c <- getChar
13:51:40 <grem>                   if c == '\n'
13:51:40 <grem>                        then return ""
13:53:09 <Marvin--> are you sure the if is aligned with the c in c <- getChar?
13:53:37 <grem> Marvin--: it was one space off... thanks
13:53:54 <grem> Marvin--: its so damn picky
13:55:27 <Marvin--> grem: you can override the layout rule by saying  do { c <- getchar ; if c == '\n' then ... }
13:55:45 <Marvin--> grem: but it's not any more picky than e.g. Python
13:55:52 <grem> Marvin--: does it have to be all on the same line?
13:56:32 <Marvin--> grem: no, if you use { ... ; ... ; ... } you can place your spaces any way you like
13:56:51 <Riastradh> do {
13:56:55 <Riastradh>             foo;
13:56:56 <Riastradh>  bar;
13:57:01 <Riastradh>      baz;quux}
13:57:04 <Riastradh> will work.
13:58:09 <grem> Riastradh: so do ; go after everything ... even if statments and such?
13:58:29 <Riastradh> Yes, I believe -- ; separates 'do' clauses.
14:05:31 <Marvin--> grem: not after statements, between, that's the real difference
14:05:37 <Marvin--> grem: it's like good ol' pascal
14:05:56 <grem> Marvin--: I wasn't programming when that was in ;) i'm too young ;)
14:06:23 <grem> Marvin--: so in the getLine     =  do c <- getChar
14:06:23 <grem>                   if c == '\n'
14:06:23 <grem>                        then return ""
14:06:23 <grem>                        else do l <- getLine
14:06:23 <grem>                                return (c:l)
14:06:32 <grem> where would they go?
14:07:22 <pesco> I started programming just when Pascal had started to go out of style so far as to cause them to drop the Pascal course.
14:07:58 * Igloo reads GenericLib.hs
14:08:10 <pesco> Forcing me to take the C course, ignoring next to everyone telling me, it would be too hard to begin with.
14:08:48 <grem> C - I've never learned that, but i did get C++ and Java... now haskell is my learning task
14:08:54 <pesco> Some years later when we had a couple of lessons in Pascal in school I suddenly felt lucky that I'd never touched it.
15:24:10 <shapr> it's midnight, but it looks like evening
15:27:39 * Igloo prods shapr again (IOHCC)
15:27:43 <shapr> oy
15:27:44 <shapr> right
15:28:16 <Igloo> I realised up a bit that we should have got it into HC&A  :-(
15:29:52 <shapr> hrm
15:30:17 <shapr> ah
15:34:36 <shapr> Igloo: ok, check it out.
15:35:51 <Igloo> I'm sure it's fine
15:36:30 <shapr> ok, I'll announce it on the list.
15:40:53 --- topic: set to '["mo' nads than you","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","Order Haskell 98 Report in Hardcopy - http://titles.cambridge.org/catalogue.asp?isbn=0521826144","HaWiki - http://www.haskell.org/hawiki/","0th IOHCC Results - http://iohcc.mgoetze.net/winners.html"]' by shapr
15:41:05 <shapr> 0th IOHCC Results! http://iohcc.mgoetze.net/winners.html
15:41:16 <shapr> mgoetze: thanks for hosting the webspace and the mailing list.
15:41:30 <Igloo> Huzzah!
15:41:38 <mgoetze> shapr: oh, i'm honored i could help :)
15:43:00 <shapr> I'm sending a mail to haskell@haskell.org also.
15:43:53 <grem> when trying to do    main = forkIO (write 'a') >> write 'b'
15:43:54 <grem>      where write c = putChar c >> write c
15:44:07 <grem>  i get     Illegal signature in pattern: IO GHC.Base.() main
15:44:10 <shapr> grem: see the IOHCC Results!
15:44:10 <shapr> er
15:44:18 <shapr> no that won't fix your problem ;-)
15:44:30 <grem> shapr: what is IOHCC?
15:45:31 <Riastradh> International Obfuscated Haskell Code Contest.
15:46:51 <shapr> Malcolm Wallace's Remorse entry is very funny.
15:47:12 <shapr> oh, I wish all the entries had won prizes, some are very cool
15:47:45 <shapr> Pseudonym's entry is very nifty
15:47:55 <shapr> I'd never thought to encode state in the sources quite like that.
15:48:17 <shapr> It's like a state monad version of a quine 
15:48:31 <shapr> @wn1913 quine
15:48:31 <lambdabot> Sorry, I don't know the command "wn1913", try "lambdabot: @listcommands"
15:48:37 <shapr> @jargon quine
15:48:39 <lambdabot> *** "quine" jargon "Jargon File (4.3.0, 30 APR 2001)"
15:48:39 <lambdabot> quine /kwi:n/ n. [from the name of the logician Willard van Orman
15:48:39 <lambdabot>    Quine, via Douglas Hofstadter] A program that generates a copy of its
15:48:39 <lambdabot>    own source text as its complete output. Devising the shortest possible
15:48:40 <lambdabot>    quine in some given programming language is a common hackish amusement.
15:48:41 <lambdabot>    (We ignore some variants of BASIC in which a program consisting of a
15:48:44 <lambdabot>    single empty string literal reproduces itself trivially.) Here is one
15:48:46 <lambdabot>    classic quine:
15:48:47 <lambdabot> [there's @more]
15:49:25 <grem> shapr: any idea whats with the    Illegal signature in pattern: IO GHC.Base.() main?
15:50:17 <shapr> no, I haven't done anything with threading yet, sorry.
15:50:25 <shapr> can you start and run one thread?
15:51:42 <grem> shapr: the error happens when i try to load it into the GHCI...
15:51:51 <grem> it doesn't do anything then
15:51:51 <shapr> ah
15:52:07 <shapr> can you compile it?
15:52:13 <shapr> ghc --make Foo.hs
15:52:31 <grem> well i would have to use -package concurrent right?
15:52:43 <shapr> I think so
15:53:05 <grem> main.hs:11:
15:53:05 <grem>     Illegal signature in pattern: IO GHC.Base.() mai_n
15:53:05 <grem>         Use -fglasgow-exts to permit it
15:53:37 <shapr> you got an underscore in mai_n like that?
15:54:45 <grem> i did, but i don't now
15:54:57 <grem>     Illegal signature in pattern: IO GHC.Base.() main
15:55:10 <grem>         Use -fglasgow-exts to permit it
15:55:11 <grem> thats what i get now ;)
15:55:31 <grem> i got it... NM
15:55:36 <shapr> what was it?
15:55:41 <grem> indentation
15:55:46 <shapr> oh
15:55:51 <grem> :( It takes some getting used to
15:56:02 <shapr> I came from Python to Haskell, so it feel natural to me :-)
15:56:15 <shapr> I would strongly recommend you always use spaces, never tabs
15:56:26 <shapr> (setq-default indent-tabs-mode nil)
15:57:38 * esap doesn't much know python. Yield is a nice feature though.
15:57:39 <grem> shapr: should i have (add-hook 'haskell-mode-hook 'turn-on-haskell-indent) in there?
15:57:39 * mgoetze likes tabs
15:58:10 * esap uses simple-indent.
15:58:51 <shapr> (add-hook 'haskell-mode-hook 'turn-on-haskell-font-lock)
15:58:51 <shapr> (add-hook 'haskell-mode-hook 'turn-on-haskell-decl-scan)
15:58:51 <shapr> (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
15:58:51 <shapr> (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
15:59:23 <shapr> and turn-on-haskell-hugs or turn-on-haskell-ghci depending on your preference
15:59:43 <shapr> esap: python is nice, but yield irritates me..
15:59:53 <wli> goddammit
15:59:56 <esap> shapr: heheh :-)
15:59:56 <wli> I should have entered
15:59:57 <shapr> personally I think python 1.5 was the golden age
16:00:13 <esap> shapr: what's wrong with yield?
16:00:13 <shapr> wli: we'll have another one
16:00:16 <shapr> hopefully soon
16:00:33 <grem> shapr: The indent does funky things for me, it indents too far after some statements.
16:00:35 <wli> never mind 
16:00:41 <wli> I wouldn't have gotten anywhere
16:00:42 <grem> i will try the simple indent
16:00:54 <shapr> grem: hit it multiple times to get back to where you were
16:01:37 <esap> the reason I use simple-indent is that I never got the '>' style literate stuff working with the ordinary indent.
16:02:46 <shapr> esap: using literate-haskell-mode right?
16:03:17 <esap> shapr: yes.
16:03:22 <grem> shapr: is there anyway i can tell the ghci that when i load a file it should do a :set -package concurrent?
16:04:20 <shapr> grem: put it into your .ghci
16:06:42 <grem> shapr: in my ~/?
16:07:03 <shapr> yup
16:07:16 <shapr> bah, I have to wake up in six hours
16:07:40 <Logan> I love yield. :P
16:08:13 <shapr> it just seems cheesy
16:08:49 <esap> I think a problem with yield is the interface, not the concept.
16:09:14 <shapr> yah, I agree
16:11:01 * shapr goes to sleep
16:11:06 <grem> Where is the best place to go to look up what keywords do aka _where_ keyword
16:11:42 <esap> grem: www.haskell.org, I'd say.
16:12:17 <grem> esap: i gathered that, but i can't find a sytax layout of where... 
16:14:34 <esap> grem: in the language definition, see section 9.3 (or 2.7)
16:17:44 <grem> esap: that doesn't say what the keyword _where_ does
16:19:45 <esap> grem: if you look at the syntax, you'll see that many declarations use it. Then there is a separate chapter for declarations [chapter 4]
16:21:30 <grem> esap: so i just have to read all the definitions and guess at the meaning?
16:22:59 <esap> grem: no, the meaning is also described.
16:24:07 <esap> grem: but if you want a cross-reference from a keyword to its meaning, I guess the table of contents is the best there is.
16:25:41 <grem> ok... in the do{stmt; stmt;} syntax how do i know where the ; go? i have main = do {forkIO (write 'a'); write 'b'
16:25:41 <grem>           where write c = putChar c; write c}
16:26:59 <grem> i get an error on the line with the where
16:28:29 <esap> grem: I guess you need { after the where and } before the next ;. And the scope of the where in that case is quite limited (you should put it after the closing '} of the do.
16:30:32 <esap> grem: main = do { forkIO (write 'a'); write 'b'; } where { write c = putChar c; write c }  is one way [I didn't test that :-)]
16:31:39 <grem> main = do {forkIO (write 'a'); write 'b';}
16:31:39 <grem>        where{write c = putChar c; write c}
16:31:47 <grem> is what i have and i get an error
16:31:54 <grem> main.hs:11: parse error on input `;'
16:32:03 <grem>  parse error on input `}'
16:32:09 <grem> sorry thats the error, the 2nd one
16:32:26 <esap> grem: add ';' before the last '}'
16:32:40 <grem> then i get the 1st error i posted
16:32:57 <grem> *smile* i tried that 
16:33:30 <grem>    main = forkIO (write 'a') >> write 'b'
16:33:31 <grem>      where write c = putChar c >> write c
16:33:34 <grem> that is the working code
16:37:16 <esap> grem: oh you have forgotten 'do' from the definition of 'write'.
16:38:31 <grem> so the where needs to be encapsalated inside the do?
16:38:53 <esap> grem: no, ... where { write c = do { putChar c ; write c ; }}
16:40:10 <grem> yep, it works that way
16:53:22 <grem> int this type def why does the first one say MVar a, and the second one is MVar() ?
16:53:29 <grem> type CVar a = (MVar a, MVar())
16:54:20 <esap> grem: the argument to MVar describes the type of the contained element. () is a type that contains only the element ().
16:55:25 * grem is confused by that
16:56:27 <esap> the name of the element is the same as its type. write ':info ()' in ghci.
16:56:58 <grem> ok
16:58:16 <grem> so the first MVar and the second one aren't the same?
16:58:29 <grem> they have different types of data inside them?
16:58:30 <esap> it's sometimes somewhat confusing that types and type constructors can have names that are written in the same way.
16:58:35 <esap> grem: right.
16:59:00 <grem> esap: so the 2nd one has a MVar inside it (hence the ()) ?
16:59:52 <esap> grem: the 2nd has an () inside it.  An 'MVar ()' is a synchronizing variable with an object of type () inside it.
17:00:16 <grem> ok, what does the first one have inside it then? 
17:01:00 <esap> grem: it has an object of type 'a'. ['a' stands for a type variable, that is, you can give that type as argument to CVar.
17:01:57 <esap> grem: small letters in types denote type variables (also known as 'universally quantified type variables')
17:02:05 <grem> so when i create a new CVar i will have 2 MVars, one of type a, which is specified when i call newCVar and one of type ()?
17:03:05 <esap> grem: right.
17:03:37 <grem> esap: what can be stored in a () object? and whats the advantage of having the 2nd MVar hold a ()?
17:04:16 <esap> grem: an MVar can be empty, so an MVar () is basically a concurrent variable with either () or it's empty.
17:04:42 <grem> so its like creating an empty object?
17:05:00 <grem> the first one has something in it, and the 2nd one is empty..?
17:05:25 <esap> grem: there are two ways to construct an MVar ():  'newEmptyMVar' is the first way, and 'newMVar ()' is the second way.
17:07:15 <Smerdyakov> I want... empty!
17:08:19 <grem> esap: Ah, i see, so putMVar ack_var () would then put the ack_var into the ()?
17:08:50 <esap> grem: no, it would put '()' into 'ack_var' :-)
17:09:00 <grem> esap: DOH! ;)
17:09:29 <grem> ok, i think i get it
17:10:14 <grem> a line like newMVar >>= \data_var ->      can be translated into this data_var <- newMVar .... correct? or no?
17:10:38 <esap> grem: correct.
17:10:52 <esap> grem: of course you need the 'do' around that.
17:12:04 <grem> newCVar=do{
17:12:05 <grem>     data_var <- newMVar;
17:12:05 <grem>     ack_var <- newMVar;
17:12:05 <grem>     putMVar ack_var ();
17:12:05 <grem>     return (data_var, ack_var)}
17:12:10 <grem> should that work?
17:13:06 <esap> grem: yes, I guess it should.
17:17:28 <esap> grem: oh actually, you need to give the initial value to newMVar.
17:17:46 <esap> grem: or you could use newEmptyMVar.
17:18:46 <grem> how would i give an initial value to newMVar ?
17:19:38 <grem> the way the person originally had it was newMVar >>= \data_var ->
17:20:36 <esap> grem: hmm... if you read http://www.haskell.org/ghc/docs/latest/html/base/Control.Concurrent.MVar.html it says that newMVar requires one argument.
17:21:41 <esap> grem: that is,   ack_var <- newMVar ()  will already initialize the newly created MVar with the value ().
17:22:17 <grem> so would the above one work then?
17:22:19 <grem> the way the person originally had it was newMVar >>= \data_var ->
17:22:26 <esap> grem: I would assume 'newMVar >>= \data_var -> ..." is a type error.
17:22:34 <grem> ah
17:23:00 <grem> Well its out of the Concurrent haskell postscript file
17:23:21 <esap> grem: oh, maybe that one uses a different definition of newMVar than ghc.
17:24:34 <grem> how do i comment out a block of code?
17:24:45 <grem> newCVar=
17:24:45 <grem>         newMVar >>= \data_var ->
17:24:45 <grem>         newMVar >>= \ack_var ->
17:24:45 <grem>         putMVar ack_car () >>
17:24:45 <grem>         return (data_var, ack_var)
17:24:55 <grem> that is what was originally in the document
17:25:09 <esap> grem: '--' creates a comment to end of line.
17:25:21 <grem> what about multi line?
17:25:38 <esap> grem: yes, the concurrent haskell paper has 'newMVar :: IO (MVar a)'. GHC docs have 'newMVar :: a -> IO (MVar a)'.
17:26:18 <grem> esap: which is right?
17:26:25 <esap> grem: {-  -}  IIRC, I rarely use those, since I normally use literate programming style.
17:26:46 <esap> grem: well I guess both are right, they're just different.
17:29:13 <grem> a return type of IO() is like void?
17:29:46 <esap> grem: yes, roughly.
17:30:12 <esap> grem: I think 'newEmptyMVar' from GHC corresponds to 'newMVar' from the concurrent haskell paper.
17:30:42 <grem> esap: ok, i think i'm starting to learn here... this is my first functional language, and i've never dealt with lambda calculas either, so this is a bit overwhelming
17:32:27 <esap> grem: Haskell is much stricter than other languages, you have to say what you mean or it will not get past the compiler. This is the major reason why I prefer Haskell.
17:32:49 <grem> esap: strict is good, cuts down on lasting bugs and crashes
17:34:15 <esap> grem: right. I once had my code broken for a month such that it didn't compile due to type errors. Once it compiled, it just worked. I wouldn't even dream of that kind of thing in other languages.
17:35:01 <Riastradh> What about other strictly typed languages like OCaml?
17:35:27 <esap> riastradh: I don't know, never tried OCaml. Maybe it works as well :-)
17:38:18 <esap> riastradh: actually, I think I looked OCaml at some point, but then didn't continue that due to some reason (I can't remember what)
17:38:29 <Riastradh> Probably due to the syntax.
17:40:16 <esap> maybe it was my overall feeling that I already knew ML, and I didn't see much difference :-)
17:42:05 * esap is not sure that feeling was correct, though :-)
19:15:05 * tmoertel is going into coma owing to ice-cream overload
19:16:44 <Pseudonym> Can that put you in a coma?
19:17:11 <tmoertel> metaphorically speaking, yes, because I feel quite sluggish now
19:17:53 <tmoertel> ;-)
19:17:59 <Pseudonym> :-)
19:18:08 * Pseudonym can do that without ice cream
19:18:32 <tmoertel> oh yes, so can I, but *with* ice cream, it's much more enjoyable
19:29:03 <Pseudonym> True.
19:30:09 <Riastradh> What about with large doses of things very psychadelic?  I think that would be more fun than just ice cream.
19:30:41 <Pseudonym> That's more dangerous, though.
19:30:49 <Pseudonym> Sluggish is good.  Coma not so good.
19:31:06 <Riastradh> Enough ice cream to make you burst is more dangerous than a milligram of LSD.
19:31:22 <Pseudonym> Is a milligram a "large dose"?
19:31:50 <Riastradh> A milligram of LSD is enough to make you find the religion of the Pink Elephant and have very interesting bicycle rides for several hours.
19:33:43 <Pseudonym> Shows you how much I know.
21:45:48 <Pseudonym> Whose turn to talk?
22:22:17 <tmoertel> Talk? about what?
22:22:28 <Pseudonym> I dunno.
22:22:34 <Pseudonym> This is supposed to be a chat thingy.
22:23:32 <tmoertel> How about those lambdas?  They sure are handy.
22:24:47 <tmoertel> I sure wish that hyphens were legal in identifiers.
22:25:09 <tmoertel> i-like-this-better thanCamelCase
22:25:29 <Pseudonym> You could use underscores.
22:25:40 <Pseudonym> what_do_you_think_of_this
22:26:04 <Pseudonym> They kinda look like spaces if you crop appropriately.
22:26:15 <tmoertel> underscores are problematic in contexts where hyperlinks can also exist, i.e., in these times, everywhere
22:26:43 <tmoertel> any idea of when GHC 5.06 will be released ?
22:28:52 <Pseudonym> Nope.
22:33:55 * tmoertel just finished a project and is looking for somehting fun to program for a few days, till the next project finds me
22:43:55 <Pseudonym> Want something to do?
22:45:09 <Pseudonym> http://www.informatik.uni-bonn.de/~ralf/publications/TheWeb.ps.gz
22:45:15 <Pseudonym> Implement it.
22:45:29 <Pseudonym> I dunno how "fun" you'd find it.
23:09:34 <Pseudonym> @yow
23:09:35 <lambdabot> RHAPSODY in Glue!
