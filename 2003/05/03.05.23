00:06:49 <Pseudonym> Thanks for the paper.
00:54:45 <Pseudonym> Bye all.
01:02:57 <Marvin--> haha
01:03:20 <Marvin--> neato
01:03:46 <andersca> hm?
01:04:41 * andersca boings
01:05:46 <Marvin--> I was working on inlining case expressions instead of creating help functions, hoping it would speed up the proofs
01:05:51 <Marvin--> nnno, not really
01:06:15 <Marvin--> when I started working on it, it took 5s to prove the bug, with the case inlining it seems to take 17m
01:06:18 <Marvin--> *ouch*
01:06:31 <andersca> ugh
01:06:32 <andersca> what is the bug?
01:08:17 <Marvin--> oh, just a bug I introduced on purpose to test the system
01:09:26 <Marvin--> hrrrm, so I wonder how to improve this *cough*
01:15:28 <Marvin--> heh, I got a mail from Koen with subject "Duh"
01:16:02 <andersca> what does it say?
01:16:05 <andersca> is it secret stuff
01:21:56 <Marvin--> nah, he wanted to know if I knew the secret flags to eprover to make it run fast instead of the default mode which is slow
01:22:23 <Marvin--> (I didn't, but Stephan Schulz, the author of eprover, had told me yesterday)
01:34:27 <Marvin--> hrrm, I need a new mouse
01:34:29 <Marvin--> what should I get?
01:34:52 <andersca> I dunno
01:34:55 <andersca> I have a coordless logitech
01:37:10 <Darius> I have a cordless logitech, but a cordless optical mouse would be cool.  (It's annoying cleaning the ball)
01:37:59 <Marvin--> exactly, I'm pondering getting a cordless optical
01:38:12 <Marvin--> they seem quite expensive though
01:38:13 <dennisb> coordless is good, all though I have to change batteries every 2-3 weeks
01:38:35 <Marvin--> http://www.computercity.se/Product/viewLargeImage.aspx?itemName=MX700&fileName=images/articles/6/SE68499.jpg
01:38:45 <Darius> Ah yeah, that's another problem.  Though 2-3 weeks seems excessive.
01:38:59 <dennisb> it's an optical version, but I have reloadable batteries so it's not a problem
01:39:14 <Marvin--> yeah, I've got rechargable batteries as well, so that shouldn't be that much of a problem
01:39:16 <dennisb> Well, I might use the computer more then the avarage user
01:39:58 <Darius> I guess the optical makes a significant difference.  I think my mouse uses less battery power than my guitar tuner.
01:40:07 <Marvin--> heh
01:40:18 <Marvin--> are they heavy? cordless mice I mean
01:40:21 <dennisb> I just keep an extra pair of batteries ready all the time. The keyboard however on the same kind of rechargable batteries lasted about 6 months
01:40:22 <Marvin--> what with batteries and stuff
01:40:55 <Darius> My cordless (not optical) is lighter (or as light as) than most of the corded mice I've used.
01:41:14 <Marvin--> okay
01:41:33 <Marvin--> ah well, I have to go fiddle on the test mice anyway, looking at pictures is kinda pointless
05:32:00 * Marvin-- is confused
05:40:33 * kosmikus is confused because Marvin-- is confused but does not tell why
05:41:07 <Marvin--> kosmikus: I'm pondering let expressions in terms of first order logic
05:41:48 <kosmikus> ah
05:42:06 <Marvin--> I'm guessing it would be something like, f x = let g y = e1 in e2  is represented as   forall x . (forall y . g(y) = e1) -> f(x) = e2
05:42:31 <Marvin--> so, simplifying, I'd have  forall x . exists y . g(y) /= e1 | f(x) e2
05:42:43 <Marvin--> er, f(x) = e2
05:43:18 <Marvin--> but that seems weird to me, as it would mean that y would depend on x
05:46:04 <kosmikus> I see -- but is that really so bad?
05:46:16 <Marvin--> I don't know
05:46:31 <Marvin--> whic is why I'm confused ;)
05:46:35 <Marvin--> which
05:47:47 <wli> woops =)
05:48:03 <wli> Main> :type let x0 = ((),()) in let x1 = (x0,x0) in let x2 = (x1,x1) in let x3 = (x2,x2) in let x4 = (x3,x3) in let x5 = (x4,x4) in let x6 = (x5,x5) in let x7 = (x6,x6) in let x8 = (x7,x7) in let x9 = (x8,x8) in let x10 = (x9,x9) in x10
05:48:40 <Marvin--> oh what fun
05:48:50 <kosmikus> Marvin--: to me it sounds reasonable
05:48:55 <wli> the results are too large to paste =)
05:49:41 <wli> whoa
05:49:47 <wli> RSS of 37MB from that
05:49:49 <Marvin--> kosmikus: I guess... I mean, the forall x has to be top-level because it has to bind inside e1 too
05:49:59 <Marvin--> RSS?
05:50:05 <wli> Resident Set Size
05:56:27 <kosmikus> Marvin--: yes, and that is exactly why the y _can_ depend on the x, because the whole function g is "indexed" by x ...
05:57:40 <Marvin--> kosmikus: point
06:01:34 <Darius> Scheisse!
06:02:08 <Marvin--> I'm on a hiiiiiighway to heeeellll
06:07:39 <Darius> and wli, you don't need a new let for each variable: :type let x0 = ((),());x1 = (x0,x0);x2 = (x1,x1);x3 = (x2,x2);x4 = (x3,x3);x5 = (x4,x4);x6 = (x5,x5);x7 = (x6,x6);x8 = (x7,x7);x9 = (x8,x8);x10 = (x9,x9) in x10
06:07:42 * shapr looks at his heel
06:08:39 <wli> Darius: yes I was being silly
06:08:50 <shapr> hm, lambdabot is using 336mb of ram
06:09:40 <Darius> @eval undefined
06:09:41 <lambdabot> out of fuel - use @resume to continue
06:12:58 <wli> shapr: is all that actually in use?
06:14:30 <shapr> I dunno
06:14:32 <shapr> hi fridge
06:14:41 <shapr> wli: oh, you mean swapped in?
06:14:43 <wli> it sounds like something's gone wrong
06:14:50 <shapr> 321mb swapped in
06:14:55 <wli> well (1) swapped in (2) in active use by the program
06:15:18 <shapr> How can I tell if it's in active use by the program?
06:15:28 <wli> heap profiler
06:16:23 <Igloo> Are there any large datastructures in it or are they all in the DB?
06:16:59 <shapr> I can't think of any large datastructures in lambdabot 
06:17:40 <Darius> It's probably eval module.  Evaluating fact 100 with the joy evaluator got it up to 700MB(?) last time.
06:17:54 <shapr> I wonder why that happens.
06:17:58 <Darius> The thing is it doesn't seem to be reclaiming the memory.
06:18:07 <shapr> lambdabot: @quit
06:18:29 <Darius> On Windows I get the memory back when a new program needs it.
06:18:53 <Darius> shapr: how much memory do you have installed and how much is in use by all programs?
06:19:03 <Igloo> Anyone got a URL to the code handy?
06:19:38 <shapr> 512mb installed 
06:19:51 <shapr> usually I have a few mb free
06:20:21 <Marvin--> dennisb: where is "bussen"? Is that the conference room on the fourth floor of MC?
06:20:44 <dennisb> Marvin--: yes
06:20:50 <dennisb> outside the lunchroom
06:20:57 <Marvin--> right
06:21:04 <Darius> Eval module -is- inefficient as heck, but I don't think it's has a space leak between executions except for the support for @resume.
06:21:05 <shapr> Igloo: lambdabot sources are here http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/lambdabot/
06:21:17 <Marvin--> Koen wanted me to go to the cover meeting on Monday morning, just thought it'd be good to know *where* ;)
06:21:23 <wli> well that could already be enough
06:21:27 <Darius> But that should be covered by @eval undefine
06:21:31 <shapr> ok, lambdabot is using 3mb
06:21:32 <wli> what @resume events could be pending?
06:21:33 * Igloo wonders how darcs makes the inverse of a token substitution patch
06:21:49 <wli> shapr: @eval undefined took it down to 3MB from 336MB?
06:21:56 <shapr> no, restarting it did
06:22:04 <wli> oh
06:22:20 <wli> well restarting it with a heap profiler might help
06:22:26 <shapr> @eval joy "5 [[pop 0 =] [pop pop 1] [[dup 1 -] dip x *] ifte] x"
06:22:30 <lambdabot> [120]
06:22:44 <shapr> ah, 13mb more now used
06:23:07 <shapr> @eval undefined
06:23:07 <lambdabot> out of fuel - use @resume to continue
06:23:16 <shapr> 2mb more
06:23:18 <wli> does it use less RAM now?
06:23:18 <shapr> hmm
06:23:23 <shapr> no, more
06:23:24 <Darius>  @eval undefined won't make a difference here
06:23:28 <wli> okay that's bad
06:23:34 <shapr> oh
06:24:02 <shapr> yup, time for heap profiling
06:24:06 <Darius> @eval undefined will change the IORef holding the continuation to one holding the continuation of undefined
06:24:07 <lambdabot> out of fuel - use @resume to continue
06:24:20 <Darius> which should be relatively small
06:24:24 <shapr> right
06:24:32 <Darius> If it finishes, then there is no continuation.
06:24:39 <shapr> ok
06:24:46 <shapr> so it's not the continuation itself
06:25:08 <shapr> @yow
06:25:09 <lambdabot> .. If I cover this entire WALL with MAZOLA, wdo I have to give my
06:25:09 <lambdabot>  AGENT ten per cent??
06:25:12 <shapr> @fortune
06:25:12 <lambdabot> "Shelter," what a nice name for for a place where you polish your cat.
06:25:33 <shapr> hm
06:25:37 <shapr> @yow
06:25:37 <lambdabot> Now I'm telling MISS PIGGY about MONEY MARKET FUNDS!
06:25:42 <Darius> The leak would be when something doesn't finish.  Then -everything- held will be held until it's @resume'd and finishes.
06:25:53 <Darius> or another expression doesn't finish
06:25:55 <dennisb> Marvin--: seems like a good idea, yes. What meeting is that?
06:26:03 <Marvin--> dennisb: cover
06:26:41 <dennisb> Hmm, I misread you last sentense
06:26:50 <shapr> Darius: It looks to me like every module call expands memory usage by a few kbytes
06:26:55 <Darius> However, the only result of a completed expression is a string that is almost certainly evaluated (it's what is sent).
06:27:05 <dennisb> I read it that koen was away and you was going to cover for him. Now, what is cover?
06:27:26 <Marvin--> oh, heh, no
06:27:50 <dennisb> Is it the name of the quickcheck-testings-work-stuff?
06:27:53 <Marvin--> http://dilbert.cs.chalmers.se/Cover/
06:27:54 <Marvin--> yews
06:28:05 <Marvin--> COmbining VERification methods
06:28:28 <shapr> how do you say "cover for you" in swedish anyway?
06:28:43 <dennisb> Marvin--: yes, I know about it. I just forgot about the name
06:28:56 <Marvin--> dennisb: right
06:29:20 <Marvin--> shapr: I don't think there is a corresponding phrase in Swedish... well, not a non-military one anyway
06:29:41 <Marvin--> (but that'd be "cover me", never mind)
06:30:08 <Darius> shapr: about the the few KB and even the 13MB, you will only get the memory back when the RTS GCs and (perhaps) when Linux reclaims it.
06:30:39 <Marvin--> shapr: try running eprover again, that'll use some memory :-P
06:30:44 <shapr> heh
06:31:01 <shapr> the memory lambdabot was using wouldn't swap out
06:31:11 <shapr> other apps were being swapped out instead
06:31:42 <wli> that's because things that are running are given an unfair advantage
06:31:57 <wli> i.e. runtime is confused with memory usage
06:32:38 <wli> I'm going to look into fixing this later.
06:34:29 <Darius> There is one thing I can do to lessen the problem, though it slightly (perhaps for better or worse) changes the semantics; however, it doesn't seem like it would make a difference here.
06:34:49 <shapr> I wonder if it's the module calling code
06:35:17 <shapr> or somehow related
06:36:17 <shapr> Darius: how would it change the semantics?
06:36:31 <wli> get the heap profiler on it
06:36:34 <wli> stop guessing
06:36:36 <shapr> yah, I think so
06:36:59 * shapr notices some new nicknames
06:37:07 <dennisb> Marvin--: the reson I misunderstands sometime is because I dont read with you write. I just see some keywords and guesses. So I saw: cover koen in "bussen" :-)
06:37:09 * dennisb is lazy
06:37:10 <shapr> hi steveh, are you new around here?
06:37:23 <Marvin--> dennisb: heh
06:37:43 <dennisb> read what you write, i intended to write of course. I almost use the same system when I write
06:38:42 <Darius> The change would clear the continuation ref after each successful expression.  This would be good if there's an expression waiting to be @resume'd that takes a lot of memory.
06:38:48 <shapr> dennisb: you just need to improve your brain to text compiler a bit ;-)
06:39:21 <Darius> Right now the current behavior is that you can always resume the last unfinished expression even if you had successfully evaluated expressions in between.
06:39:50 <Darius> @eval sum $ take 1000 $ from 1
06:39:51 <lambdabot> 500500
06:39:55 <shapr> I see
06:39:57 <Darius> @eval sum $ take 2000 $ from 1
06:39:59 <lambdabot> 2001000
06:40:03 <Darius> @eval sum $ take 3000 $ from 1
06:40:06 <lambdabot> 4501500
06:40:18 <Darius> @set-fuel 10
06:40:19 <lambdabot> fuel set to 10
06:40:25 <Darius> @eval take 10 $ from 1
06:40:26 <lambdabot> out of fuel - use @resume to continue
06:40:30 <Darius> @eval 5
06:40:30 <lambdabot> 5
06:40:32 <Darius> @resume
06:40:32 <lambdabot> out of fuel - use @resume to continue
06:40:33 <Marvin--> Darius: sounds like a reasonable change
06:40:33 <Darius> @resume
06:40:33 <lambdabot> out of fuel - use @resume to continue
06:40:34 <Darius> @resume
06:40:34 <lambdabot> out of fuel - use @resume to continue
06:40:49 <Darius> @set-fuel 1000
06:40:49 <lambdabot> fuel set to 1000
06:40:50 <Darius> @resume
06:40:50 <lambdabot> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
06:41:53 <Darius> shapr: The thing is I can't see this being the problem as @eval undefined would clear it as would it successfully ending itself.
06:42:09 <steveh> shapr: yes, I'm new around here :)
06:42:41 <shapr> steveh: learning Haskell? or just looking for other users?
06:42:47 <shapr> Darius: yah, I agree
06:43:21 <steveh> both, trying to get some ideas for something nontrivial to do in Haskell
06:43:43 <shapr> well, it's been a common pasttime to write lambdabot plugins...
06:43:49 <wli> I'm still trying to figure out the frigging valuation ring multiparameter typeclass crud
06:43:50 <shapr> though I guess that depends on your idea of nontrivial
06:43:52 <steveh> hehe
06:44:31 <steveh> something that's more than a couple hundred lines? and/or something that someone would find useful
06:45:26 <Darius> "more than a couple hundred lines" can be quite a bit of Haskell.  The ratios of Haskell to, say, C++ are commonly between 2-10.
06:45:45 <steveh> well, I was using my last little exercise as a benchmark
06:45:45 <shapr> yah, you may want to stick with fifty to a hundred lines :-)
06:45:46 <Darius> So a "couple hundred lines" of Haskell could be a "couple thousand lines" of C++.
06:46:01 <steveh> it's a binary search tree :-P
06:46:31 <steveh> ow
06:46:46 <steveh> and actually I just realized I was using the line count including literate comments
06:46:50 <steveh> it's probably <100 without those
06:46:51 <steveh> :)
06:47:09 <wli> steveh: binary search trees are typically small amounts of code in Haskell too
06:47:52 <steveh> I also don't know if I am grasping the idioms entirely
06:48:03 <steveh> aside from a little bit of Lisp, I'm an FP neophyte as well
06:48:35 <Darius> EvalModule comes to 803 by sloccount though, and 1134 by wc *.hs.
06:48:52 * shapr checks the entire lambdabot sloccount
06:49:15 <Darius> (that includes some not checked in and unrelated files though)
06:50:27 <Darius> 177 wc lines are not checked in/unrelated. 145 are tests.hs
06:50:42 <shapr> including some of my own not checked in and unrelated, 2,292 lines of code
06:51:16 <shapr> nifty
06:51:31 <steveh> looking at my code, wanting delete functionality made a lot of work for me
06:51:42 <shapr> do you have your code online somewhere?
06:52:08 <steveh> but anyway, I'm looking for something a little meatier but I don't think I have the time or wherewithal to start a larger project from scratch
06:52:13 <steveh> I can have it online in 2 secs
06:52:23 <steveh> comments would be great
06:52:31 <shapr> I'd like to see if it you don't mind
06:53:44 <steveh> I think I could use some good information about when to specify arguments, etc
06:54:15 <steveh> I am accustomed to imperative languages so I don't think to return functions as results of functions in general
06:54:17 <steveh> http://mulder.homeunix.net/~steve/BSTDict.lhs
06:55:03 <steveh> i also might have some amusing misconceptions about haskell's evaluation process -- getting it to work on larger datasets without crashing took some trial and error
06:55:10 <steveh> with strictness operators and things like that
06:56:41 <steveh> and yes, I started programming this before I had heard of FiniteMap
06:56:42 <steveh> :)
06:58:27 <Darius> You don't need to use record syntax for construction
06:58:49 <steveh> you mean with the fields named?
06:59:11 <steveh> initially I found that easier to read but I know it's optional
06:59:22 <Darius> okay, just making sure
07:03:27 <steveh> yeah, without deletion this would have been cake
07:03:35 <steveh> I think the last half is all to support deletion
07:03:37 <steveh> :)
07:05:50 <Darius> you recalculate getSubTree a lot in dictDelete
07:06:22 <steveh> good point
07:07:02 <steveh> will haskell always re-evaluate it, even if it can't change?
07:08:25 <Darius> In this case, it's whether the compiler optimizes it or not.
07:09:22 <steveh> a better way would be to add a symbol like "targetTree" to the where clause, set to (getSubTree tree key) ?
07:09:34 <steveh> and swap out everywhere else?
07:09:55 <Darius> yes.  This will definitely result in only a single evaluation.
07:10:23 <steveh> thanks :)
07:10:40 <Darius> You have two completely superfluous sets of parentheses in the file as well.
07:10:54 <steveh> that would be lisp talking
07:10:56 <steveh> which ones?
07:11:23 <Darius> foldl (insert) (...); the ones around insert are utterly meaningless.
07:11:45 <steveh> ahh, you know what that might be?
07:11:53 <Darius> and in treeMin you don't need them around Node a b
07:11:56 <steveh> examples are always foldl (+) (...)
07:12:03 <steveh> you need them around +, right
07:12:05 <steveh> ?
07:12:10 <Darius> yes
07:12:16 <steveh> that must be it then
07:12:23 <Darius> otherwise it will think foldl plus (...)
07:13:11 <Darius> er Node a b on the right side, the left does need them.
07:13:21 <steveh> is this what you mean in treeMin? treeMin (Node e Nil r) = (Node e Nil r)
07:13:35 <Darius> yes
07:13:37 <steveh> ok
07:14:03 <steveh> I have no idea why those are there...
07:15:47 <Darius> In dictDelete numChildren is a pretty corny way of doing what you want.  Still using that setup, you never need the 0 and 1 cases, so you could just make numChildren (renamed) return True or False.
07:17:15 <Darius> I'd probably use a helper function that was passed getSubTree tree key that pattern matched and did whatever from there rather than use a guard.
07:19:08 <steveh> hmm
07:19:55 <Darius> hmm, perhaps I would use a guard
07:20:15 <steveh> better would be to test for two children first, rather than what I have. would (Node _ Node Node) do what I want?
07:20:29 <steveh> that way I can not bother specifying the other patterns
07:20:45 <steveh> since all I need to know is whether there are two children
07:21:05 <steveh> this is a rather literal coding of the CLR pseudocode :)
07:21:10 <Darius> Yes, yes, that would work (with different syntax), I wasn't thinking.
07:22:40 <Darius> e.g. untested
07:22:41 <Darius> > dictDelete tree key = dictDelete' (getSubTree tree key) =
07:22:41 <Darius> >     where dictDelete (Node _ (Node _ _ _) (Node _ _ _) = replaceEntry ...
07:22:41 <Darius> >           dictDelete _ = spliceKey
07:22:53 <Darius> er (add a ' to those)
07:23:00 <steveh> right
07:23:32 <Darius> and you can pattern match thisEntry and co.
07:24:12 <Darius> (or maybe just thisEntry)
07:25:45 <steveh> do you mean where it is used in replaceEntry?
07:25:57 <steveh> rather, the call to replaceEntry
07:26:51 <Darius> thisEntry is entry (getSubTree tree key), you can get that with (Node thisEntry (Node _ _ _) (Node _ _ _)) = 
07:27:12 <Darius> as we are passing (getSubTree tree key) to dictDelete'
07:27:37 <steveh> aaah, OK
07:27:46 <Darius> I'd have to look at treeSucc for the others
07:28:23 <shapr> g'day Lilith 
07:29:08 <Lilith> allo shapr
07:31:30 <andersca> yo jolta
07:31:55 <Jolta> hi!
07:32:18 <Jolta> guess if Iäm relieved now the D3-project is handed in...
07:32:31 <Jolta> that's "I'm"
07:32:34 <andersca> woo
07:33:24 <Jolta> yep.
07:33:51 <Jolta> is shapr around?
07:35:56 <andersca> shapr is always around
07:35:57 <Jolta> how did that "fact" thing work with the LambdaBot?
07:36:10 <Jolta> andersca: yet he's not answering...
07:36:31 <andersca> @fact haskell
07:36:31 <lambdabot> Sorry, I don't know the command "fact", try "lambdabot: @listcommands"
07:36:34 <andersca> hmm
07:36:39 <andersca> @listcommands
07:36:40 <lambdabot> I react to the following commands: ["all-dicts","board","define","definitions","del-definition","devils","dict","dict-help","dump","easton","echo","elements","eval","flip-board","foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","more","msg","part","ply","prelude","quit","reset-chess","resume","set-fuel","state","topic-cons
07:36:49 <Darius> fact is off until shapr imports the old data
07:36:52 <Jolta> aha
07:36:53 <andersca> ah
07:37:02 <Jolta> so it's a "new" bot?
07:37:14 <Lilith> @set-fuel
07:37:14 <lambdabot> not enough privileges
07:37:28 * Marvin-- ponders F#
07:37:52 * Darius ponders Gb
07:37:54 <Jolta> Hm. F#? MS Fortran? =)
07:38:04 <Marvin--> no
07:38:12 <andersca> F# is neat
07:38:14 <andersca> (I think)
07:38:17 <Marvin--> they're embrace-and-extending O'Caml for .NET
07:38:25 <steveh> brb
07:38:34 <Jolta> oh, that sounds kinda neat
07:38:40 <Marvin--> I'm curious what people at MSresearch are working on it, the web pages don't seem to mention it
07:38:48 <Darius> ah yes I've heard of that.
07:38:53 <Jolta> one wonders why the letter F, though
07:39:02 <Darius> functional maybe.
07:39:14 <Darius> Though OCaml isn't exactly the poster child of FP
07:39:29 <Marvin--> probably F as in functional, yes
07:39:36 <Marvin--> sheesh, it doesn't even have functors
07:39:44 <steveh> Darius: nor is C++ the poster child of OO :)
07:40:05 <Darius> steveh: but C# isn't OO#
07:40:36 <Jolta> isn't c# more like Java# in that regard?
07:40:57 <steveh> Darius: good point, maybe they didn't think they could get away with OCAML# ? :0
07:41:01 <Marvin--> "Purely functional languages like Haskell are excellent within certain niches, but unfortunately some simple programming exercises can quickly turn into problems that require a PhD. to solve." heh
07:41:20 <andersca> microsoft are adding type polymorphism to the next version of their runtime
07:41:29 <Darius> oh no!  I need a PhD!
07:41:33 <steveh> Marvin--: what's that from?
07:41:38 <Marvin--> well, Java is getting parametric polymorphism too
07:41:41 <Marvin--> http://research.microsoft.com/projects/ilx/fsharp.htm
07:41:50 <Darius> Java should have had that to begin with
07:42:14 <steveh> "We're sorry, sir, but you can no longer use Haskell until you have at least passed your quals/"
07:42:18 <andersca> Marvin--: although not in the VM
07:42:27 <andersca> .NET does type specialization jit
07:42:33 <Marvin--> cool
07:42:55 <andersca> which means you don't have to generate one class for every type instance
07:43:08 <Darius> I'd like to see some of these simple programming exercises.
07:43:17 <andersca> you can also constrain the types used
07:43:56 <Marvin--> gaaah, where are the links to white papers on F#?! Surely there are white papers on it!?
07:44:02 <steveh> hashtables
07:50:10 <Darius> hashtables require a PhD to do in Haskell?
07:50:48 <Marvin--> in-place hash tables are kinda tricky
07:50:51 <Jolta> Darius: I wouldn't know, I've never tried...
07:51:49 <thornber> we should have programming contests, haskell vs C++, haskell vs Perl etc
07:52:28 <Marvin--> like the icfp contest, you mean?
07:52:31 <Darius> ICFP (the contest) is open to all languages.
07:52:38 * thornber googles
07:52:59 <Darius> A C entry got 2nd or maybe 1st in 2001(?)
07:54:12 <shapr> yes, I'm always around :-)
07:54:26 <Igloo> Sometimes I'm a triangle
07:54:27 <Darius> he's just very slow
07:54:34 <shapr> right, memory leaks ;-)
07:54:37 <thornber> looks like ocaml won last year, is that functional ?
07:54:50 <Lilith> use valgrind!
07:54:57 <Darius> Depends on your definition, but most say yes.
07:54:58 * andersca gaboings
07:55:02 * shapr valgrinds his brain
07:55:17 * shapr kasplats
07:55:20 <Lilith> :)
07:55:23 <Igloo> valgrind won't be much help unless it's a GHC GC bug
07:55:30 <Jolta> shapr: just thought you'd like to know that the report on HaskellWars was released last night.
07:55:32 <shapr> yay!
07:55:40 <shapr> Jolta: where's the code?
07:55:41 <Lilith> HaskellWars?
07:55:43 <Jolta> shapr: www.haskellwars.com, if anyone has forgotten. =)
07:55:54 <shapr> the video is great
07:56:15 <Jolta> Lilith: "Haskell Wars is a "non-interactive" computer game, where the user constructs and controls a battle robot." <- from the abstract
07:56:24 <shapr> Jolta: you used arrows didn't you?
07:56:37 <Jolta> Lilith: of course, robots are written in an embedded language in Haskell
07:56:57 <Jolta> shapr: Well, in a sense. We used Yampa, which is Arrow-based
07:57:01 <thornber> heh, I remember a C competition similar to haskellwars about 5 years ago
07:57:07 <thornber> I wasted so much time doing that
07:57:13 <Lilith> is there one that can power lego?
07:57:23 <shapr> oh, good idea
07:57:30 <shapr> port the nhc98 runtime to legoOS
07:57:36 <Jolta> Lilith: no, our implementation deals with simulated robots only. =)
07:57:41 * Lilith has a lego mindstorm set here
07:57:50 <shapr> I gave my lego mindstorms to my uncled
07:57:56 <shapr> "uncle"
07:57:59 * shapr can't type today
07:58:17 <Jolta> Lilith: But you'll have trouble fitting an ion cannon on Lego. ;-)
07:58:33 <shapr> Lilith: I've heard there are one or two alternate OSes for mindstorms, is there a good summary site?
07:58:42 <Lilith> shapr: yes
07:58:47 * Darius wishes MechWarrior II would work
07:58:51 <Lilith> oh. this is sick
07:58:53 <shapr> Darius: why doesn't it?
07:59:05 * Lilith thinks a gay version of LOTR is sick
07:59:15 <Darius> It's too old.  I can probably get it to work in DOS.
08:00:05 <Jolta> Darius: That was a very good game. Istr playing it in Win98, though...
08:00:05 <shapr> dosemu!
08:01:15 <Marvin--> Lilith: eh?
08:01:36 <Jolta> Lilith: reading slash fiction, eh?
08:01:50 <Lilith> shapr: http://www.crynwr.com/lego-robotics/ <- that's my reference site
08:02:38 <Lilith> shapr: a number of the links are worth checking out
08:02:46 <Lilith> i know of at least 2 OSes for the mindstorms
08:02:56 <Lilith> Jolta: no. just some link someone posted
08:06:59 * steveh is back
08:09:33 <shapr> re steveh 
08:10:20 <steveh> re
08:11:38 * shapr tries to import the @fact data
08:22:38 <Darius> make distclean *sigh*
08:23:05 <shapr> whee
08:23:09 <shapr> you rebuilding 5.05 ?
08:23:50 <Darius> It's seemingly 6 now, but yes I'm rebuilding GHC, however the make distclean is me throwing away all the building I just did
08:25:10 <shapr> gee, I like the GHCi ascii art
08:25:46 <steveh> mmm BSD
08:26:32 <shapr> a licensing library that worked like SPJs Financial instrument library would be nifty
08:26:44 <shapr> steveh: do you use BSD?
08:28:01 <shapr> I think footnote 1) from alastair reid's licensing email is worth quoting
08:28:32 <steveh> yes, I've been using FreeBSD since about 4.1
08:28:36 <steveh> nice system
08:28:44 <steveh> been using the ol' Mac more and more lately, though
08:30:14 <shapr> I used win32 for many years, and then switched to linux 
08:30:23 <shapr> yay
08:30:41 <shapr> I prefer open source OSes
08:30:56 <steveh> I should get another machine to install Linux on... I want to do something similar to the Linux From Scratch thing
08:31:06 <steveh> figure the best way to pick things up is to do it all yourself
08:31:48 <andersca> I'd rather get real work done
08:32:00 <shapr> I think it's good to learn by doing it all yourself
08:32:21 <steveh> andersca: if you know of any place I can get real work, I'm all ears :)
08:32:24 <shapr> after which I'd suggest switching to a setup that increases your speed of change.
08:32:44 <andersca> I don't quite get this obsession with knowing what your system is doing
08:32:54 <andersca> I'm busy with knowing what _I_ am doing
08:33:29 <steveh> the difference between drivers and auto tinkerers perhaps?
08:33:41 <shapr> I'm a tinkerer, always will be
08:33:58 <shapr> trying to squeeze a bit more performance from my system, or my code.
08:34:00 <steveh> I like to tinker with computers but I don't care about cars, for example
08:34:17 <shapr> I used to work on cars way too much, now I don't own one.
08:34:29 <fridge> I like to tinker with things that I know won't cost me wads of money if I stuff it up
08:34:43 <steveh> fridge: Good point.
08:34:44 <shapr> yah, breaking a transmission sucks
08:35:04 <shapr> on the good side, the expensive part of cars before the 90s is just labor
08:35:25 <shapr> my '65 mustang had one belt that went around three pulleys
08:36:02 <shapr> hi fridge, are you learning Haskell?
08:36:22 <fridge> yeah
08:36:29 <shapr> have any questions?
08:36:43 <fridge> nope, just gonna lurk and try and glean useful tidbits
08:36:58 <steveh> fridge: that's my strategy too :)
08:37:07 <steveh> fridge: do you know other functional languages?
08:37:10 <thornber> fridge: ghci has better error messages, that's my tip
08:37:32 <shapr> my tip is http://www.haskell.org/learning.html to start with
08:37:39 <fridge> steveh: no, haskell is to be my first introduction to the concept
08:38:05 <fridge> I looked at a few functional languages, haskell looked as good as any
08:38:17 <steveh> all I had was a little bit of LISP -- I liked it better than my classmates did.
08:38:46 <thornber> what other lazy functional langs are there ?
08:38:53 <shapr> I started learning Haskell because it was rumored to be the 'most functional' of the languages, and I wanted to learn about function progarmming specifically.
08:38:57 <shapr> urf, programming
08:39:59 <shapr> Is Clean lazy?
08:40:07 <Darius> yes
08:40:28 <wli> Clean and Miranda I think
08:40:42 <wli> maybe Hope but I'm not 100% sure
08:40:47 <Darius> LML
08:40:52 <wli> sorry yes of course
08:40:57 <wli> hbc used that
08:41:04 <steveh> speaking of lazy, can someone help me understand exactly what my trial-and-error strictness operators did? All I know is that I'd get overflows without them, given a large data set
08:41:04 <Darius> shapr: that's more or less why I started learning Haskell
08:41:19 <thornber> wli: thx
08:41:52 <wli> thornber: surprised to see you here; doing app-level stuff with this or just generally curious?
08:42:00 * Darius needs to hack his registry to have a "Open with Vim" menuitem
08:42:01 <steveh> hmm, actually I guess I ended up only making one thing strict... I remember randomly putting in $ 's everywhere, felt like I was programming Perl for a bit
08:42:18 <Darius> you mean $!?
08:42:26 <steveh> yeah, typo
08:42:58 <thornber> wli: it's something I've always been interested in, I've recently found an excuse to do it for work though :)
08:43:20 <thornber> wli: trying to write some modelling code for cluster algs
08:43:23 * shapr wonders if more kernel hackers will be visiting #haskell
08:43:29 <steveh> this code is about 3 months old and haven't looked at it in a bit
08:43:59 <shapr> hi hal
08:44:01 * shapr wins today!
08:44:01 <hdaume> morning folks
08:44:02 <Darius> steveh: the only strictness annotation I see is the one in the Node datatype
08:44:12 <wli> thornber: I pretty much use it as a perl replacement for practical stuff so I probably can't help much on the system interface side.
08:44:37 <hdaume> damn
08:44:40 * shapr grins
08:44:48 <Darius> er BSTDict
08:44:55 <shapr> steveh: sometimes I understand the difference, sometimes I don't
08:45:03 <steveh> Darius: yes, that's right. I remember putting the strictness operator in a few other places before settling on that one
08:45:14 <steveh> is my explanation in the comments spot-on?
08:45:31 <shapr> steveh: most of what I learned about lazy vs. strict in Haskell was from http://www.iro.umontreal.ca/~lapalme/Algorithms-functional.html
08:46:07 * thornber is still digesting Okasaki's chapters on lazy e.
08:46:12 <steveh> shapr: oh that is excellent
08:46:35 <steveh> shapr: trying to figure out how to write the algorithms in CLR can be very taxing on the brain
08:46:49 <steveh> sorry, write the CLR algorithms in a functional language
08:47:21 * steveh has a decrepit book about Haskell, actually.
08:47:27 <shapr> I haven't read Okasaki's book yet, but it's on my to-purchase list
08:47:29 <shapr> which book?
08:47:31 <steveh> I picked it up at Microcenter, if you can believe it
08:47:44 <shapr> what's microcenter?
08:47:52 <steveh> An Introduction to Functional Programming Systems Using Haskell
08:48:01 <steveh> shapr: large computer retail store chain
08:48:03 <shapr> oh, is that the Bird and de Moore book?
08:48:08 <steveh> the stores are large, not the chains.
08:48:21 <steveh> the author is A J T Davie
08:48:33 <steveh> (C) 1992
08:48:35 <shapr> I've haven't lived in the states for a few years, so...
08:48:43 <shapr> wow, I don't think I've heard of that one.
08:49:15 <shapr> is it any good?
08:49:25 <steveh> I think if I were more comfortable thinking of things as lambda calculus, programming in Haskell would be easier
08:49:44 <steveh> shapr: surprisingly yes, though many of its Haskell-specific things are dated.
08:50:04 <steveh> shapr: it's quite dense, from the "Cambridge Texts in Computer Science"
08:50:09 <Darius> Yeah, what version of Haskell does it target?
08:50:32 <steveh> hmm
08:50:39 <steveh> whatever Haskell was described in Hudak91
08:50:52 <steveh> doesn't make a version number reference
08:51:03 <steveh> aah
08:51:14 <steveh> bibliographies are a wonderful thing : Haskell Version 1.1
08:51:30 <shapr> oh, I have to show off Heffalump's pin-ups --> http://kungens.kemi.fi/~shae/h98/
08:52:18 <shapr> steveh: that's nifty, I'll see if I can find a copy
08:52:52 <steveh> is that computer running emacs on win32?
08:53:07 <shapr> I think so
08:53:12 <shapr> very likely so
08:53:15 <steveh> :)
08:53:19 <shapr> that's Haskell code in the buffer of course
08:53:27 <steveh> naturally!
08:55:03 * steveh needs to go back to school.
08:55:05 <shapr> me too
08:56:50 <steveh> undergrad didn't hit the functional languages very hard.
08:57:35 * delYsid says Goodbyte to Haskell for the next few months
08:57:42 <delYsid> s/byte/bye/
09:04:47 <Darius> doh
09:11:10 <Lilith> ooh
09:11:15 <Lilith> i've got that book
09:11:43 <steveh> which?
09:12:21 <Lilith> algorithms in haskell
09:12:32 <steveh> do you like it?
09:12:41 <Lilith> thin purple colored book
09:12:44 <Lilith> not too bad
09:15:09 <steveh> I don't know why, but I work with books a lot better than online tutorials or references
09:16:52 <fridge> same
09:17:11 <fridge> I find its mostly because black ink on paper is a lot easier on my eyes than a screen
09:17:11 <steveh> the only issue is books are expensive :-P
09:17:11 <steveh> '
09:17:28 <Darius> stevenh: how large does the data set need to be to overflow it? and what expression caused the problem?
09:17:48 <steveh> I think flipping to an index fits better in my workflow than switching back and forth from browser windows constantly
09:18:26 <fridge> If someone made a screen a4 in size, with an insane DPI resolution and possessing the light properties of paper, they'd have a ripper product
09:18:27 <steveh> Darius: give me a few minutes, but the data set didn't need to be all that large (10,000 elements perhaps)
09:19:07 <Darius> GHCi is working on 10,000 elements right now, but it's slow going because building GHC is eating all my memory
09:19:24 <steveh> Darius: is that w/o strict?
09:19:31 <Darius> yes
09:19:44 <Darius> It's printing them as it goes
09:22:15 <steveh> http://mulder.homeunix.net/~steve/FreqTable.lhs is another module that uses BSTDict
09:23:00 <steveh> but then you will need http://mulder.homeunix.net/~steve/Count.lhs I guess
09:23:17 <steveh> with the strictness operator it handles huge files pretty well
09:23:24 <steveh> as far as reading in text and counting words
09:23:50 <steveh> tried it on a 15M file as I recall
09:26:10 <steveh> the driver program I used is http://mulder.homeunix.net/~steve/Main.lhs
09:26:22 <steveh> i'm sure some of the functions there can be optimized
09:26:41 <steveh> plus I hardcoded the filename in that version
09:27:03 <steveh> ah!
09:27:08 <steveh> there's another strictness operator
09:27:15 <steveh> foldl' f a (x:xs) = (foldl' f $! f a x) xs
09:27:57 <steveh> i think I got that from a site somewhere, but I still don't understand how it operates vs. regular foldl
09:29:18 <steveh> i stopped work on this at some point since it was hard to get excited about reimplementing a shell-prompt one-liner :)
09:29:52 <hdaume> steveh: if you think about foldl as maintaining a state (the accumulator), then foldl' ensure that the state is always evaluate at each call, rather than foldl, which will build up a large function.
09:30:36 <hdaume> for instance, foldl (+) 0 [1,2,3] => foldl (+) (0+1) [2,3] => foldl (+) (0+1+2) [3] ...; while foldl' (+) 0 [1,2,3] => foldl' (+) 1 [2,3] => fold' (+) 3 [3] => ...
09:31:08 <steveh> I think I see what you mean...
09:31:28 <steveh> do you find it the case that lazy evaluation often causes issues like this?
09:31:44 <hdaume> "issues like this" = ?
09:31:55 <wli> no
09:32:03 <wli> foldl isn't a real problem anyway
09:33:08 <steveh> sorry, discussing a little exercise I have written -- basically without a strictness operator in a constructor I am using, code which calls that constructor is slow and overflows available space
09:33:31 <steveh> > data (Ord a) => BSTDict a b = 
09:33:32 <steveh> >     Nil | Node {entry :: (a,b), left, right :: !(BSTDict a b)}
09:33:54 <steveh> without that ! I think it doesn't scale well at all
09:34:35 <steveh> just wondering if I picked the right way out or if there's something in Haskell I don't understand yet
09:34:39 <wli> Best to use a B-tree
09:34:57 <wli> for cache reasons
09:35:46 <steveh> using haskell arrays as the elements of each node?
09:35:55 <wli> yeah
09:35:58 <steveh> hmm hmm
09:36:09 <wli> if you're storing strings there are other tricks to do
09:36:34 <steveh> the original associative set was pretty generic
09:36:55 <wli> which is fine
09:37:00 <steveh> basically I started this to learn haskell, so the first iteration was specialized to counting words
09:37:16 <steveh> then I kept abstracting things out
09:37:16 <wli> strings and/or variable-length structures merely have other techniques available
09:37:20 <steveh> right
09:37:59 <shapr> man, the ghci figlet thread on the mailing lists is *funny* !
09:38:14 <steveh> so using a btree would minimize the number of nodes I construct, so I could get away with being lazy, is the theory?
09:38:20 <shapr> ghci|figlet is very amusing
09:38:31 <wli> shapr: well I tried to be funny
09:38:55 <shapr> wli: your post was very amusing
09:39:13 <shapr> What is this I see in my crystal ball? Could it be monadic figlet
09:39:13 <shapr> combinators with sequent calculus and commutative diagram packages? =)
09:39:15 * shapr laughs
09:40:04 <shapr> y0 Logan 
09:40:45 <wli> Okay good to know I'm not so far over the edge I can't even crack a joke anymore.
09:41:27 <shapr> does kernel hacking twist reality?
09:41:34 <wli> yes
09:41:46 <Igloo> Did you find the cause of the leak, shapr?
09:41:53 <shapr> Igloo: nope, I got distracted...
09:42:01 <Igloo> Ah, OK  :-)
09:44:49 <steveh> afk
10:46:52 <andersca> re Jolta
10:46:56 <Jolta> re
10:47:25 <Jolta> hm, just noticed the archive avaliable on our web page is broken.
10:48:07 <Jolta> or, semi-broken
11:02:59 <andersca> I read the robot tutorial
11:05:28 <Jolta> andersca: So, what did you think?
11:05:34 <andersca> cool stuff!
11:06:46 <Jolta> does it look awkward? We haven't actually tested it very much on others thant ourselves
11:07:26 <Jolta> i'm not sure how the average programmer would approach it
11:09:46 <Jolta> hi Marvin--!
11:09:55 <andersca> don't forget the star treff tomorrow
11:11:24 * Marvin-- is watching a Norwegian show on TV
11:15:12 <Marvin--> a Norwegian show about Sweden, which is very fun :P
11:16:08 <andersca> http://www.freakyfonts.de/
11:18:27 <elmex> shapr: hmm... i'm beginning to use State from Control.Monad.State...
11:18:46 <elmex> it's still a bit magic
11:20:12 <Marvin--> just wait 'til you look at ContT ;)
11:20:22 <elmex> :(
11:20:54 <elmex> State is a Monad itself, isn't it?
11:21:14 <elmex> just passing some State through some functions
11:22:17 <Marvin--> yes
11:23:36 <elmex> and how do i write my own State modifying functions? something like: state_mod_func = State ( \s -> ((), do_some_funky_stuff_with_state s) ) ?
11:23:56 <elmex> is that the correct way, or is there some easier way to get the state for using it?
11:24:06 <Marvin--> do you want to create your own state monad, or just a function in the C.M.State monad?
11:24:11 <hdaume> elmex: use 'get' and 'put'
11:24:42 <elmex> hdaume: yes. i know put. but i somehow am curious what 'm' in get :: m s means
11:24:54 <Marvin--> elmex: look at the implementation
11:25:14 <elmex> Marvin--: ok, ouch ;)
11:25:17 <elmex>         get   = State $ \s -> (s, s)
11:25:22 <Marvin--> elmex: it isn't all that hard, really
11:25:22 <elmex> *G* ok, thanks a lot
11:25:32 <elmex> Marvin--: indeed
11:28:04 <elmex> coool
11:28:31 <Marvin--> Monads for the Working Haskell Programmer is a good introduction to state monads too
11:28:34 <elmex> get >>= \s -> put (s + i) 
11:28:37 <elmex> Marvin--: i used that
11:28:54 <hdaume> elmex: there's also just 'modify (\s -> s+i)'
11:28:56 <elmex> Marvin--: i first build my own state monad from it, and then went over to State
11:29:13 <elmex> Marvin--: oh, havent seen it... 1 sec
11:30:04 <elmex> cool, i love this ;)
11:32:13 <Marvin--> s/Marvin--/hdaume/ the last time, I think :)
11:32:23 <Marvin--> modify (+i)  is even neater :)
11:32:24 <elmex> oh uhm ok]
11:32:26 <elmex> ;))
11:32:57 <elmex> gets is some util function to convert the type of the state and return it?
11:34:07 <Marvin--> yeah
11:34:17 <elmex> like:
11:34:18 <elmex> strbla :: State Int String
11:34:18 <elmex> strbla = gets (show)
11:34:25 <Marvin--> gets f  is the same thing as  liftM f get
11:34:35 <elmex> lift?
11:34:48 <Marvin--> @type liftM
11:34:52 <Marvin--> bah
11:35:02 <Marvin--> liftM :: (Monad m) => (a1 -> r) -> m a1 -> m r
11:36:09 <Marvin--> same thing as fmap, really
11:36:20 <elmex> hey, don't confuse me ;))
11:36:24 <Marvin--> @type fmap
11:36:25 <lambdabot> fmap :: Functor a => (b -> c) -> a b -> a c
11:36:51 <Marvin--> the Functor class only contains fmap
11:37:06 <Marvin--> and all monads are functors
11:37:10 <elmex> ah
11:37:25 <elmex> i'm still trying to figur liftM out
11:37:48 <Marvin--> lists are functors too:  instance Functor [] where fmap = map
11:38:10 <Marvin--> (coincidentally, lists are monads too)
11:38:58 <Marvin--> liftM is pretty basic...  liftM f m = do { x <- m ; return (f x) }
11:39:53 <elmex> and what does it do?
11:40:16 <elmex> it converts the values in the monads?
11:40:57 <andersca> yeah, liftM is really useful
11:41:03 <Marvin--> it applies a function to the value "inside" the monadic value
11:41:23 <Marvin--> it "lifts" function application into the monad
11:41:59 <elmex> ah... so i could write some IO Int -> IO String by 'liftM show' ?
11:42:08 <Marvin--> yep
11:42:16 <Marvin--> that's what it's for
11:42:18 <elmex> hey, i guess i got it
11:42:50 <elmex> soo.. after this i'm going over to that StateT thing :)
11:43:35 <elmex> StateT does carry some other monad with it, oesn't it?
11:43:47 <hdaume> elmex: right
11:43:48 <Marvin--> yes
11:43:52 <Marvin--> the T stands for "transformer"
11:44:00 <Marvin--> it takes a monad and turns it into a state monad
11:44:07 <Marvin--> or rather, puts a state monad "on top" of it
11:44:17 <elmex> ah, yes, cool
11:44:53 <Marvin--> the interesting thing is that you can stack several of them, and lift operations to the right levels with the lift function
11:45:04 <Marvin--> (Control.Monad.State in ghc)
11:45:08 <Marvin--> er
11:45:11 <Marvin--> Control.Monad.Trans, sorry
11:45:29 <elmex> ah, ok... but let me first construct some example for StateT
11:48:05 <hdaume> elmex: chapter 9 of http://www.isi.edu/~hdaume/htut talks about StateT...you might find it useful
11:48:41 <elmex> is that yet another haskell tutorial? that think that i have in some printed version under my chair?
11:49:06 <hdaume> elmex: yeah....though there have been a lot of changes in the past few weeks
11:49:38 <elmex> i printed it just 1 1/2 weeks ago
11:49:55 <hdaume> i couldn't tell you :)....see if it has a section on state transformers :)
11:51:08 <elmex> doesn't look so ;)
11:51:14 <elmex> err... seem
11:53:39 <Marvin--> you writing a book, hal? :)
11:54:00 <elmex> hdaume: it has the caption ;)
11:54:09 <elmex> but no text :)
11:56:26 <hdaume> hehehe, the new version has the text :)
11:56:27 <elmex> hdaume: btw. i wanted to tell you, that i really liked that tutorial
11:56:29 <hdaume> Marvin--: i guess
11:56:32 <hdaume> elmex: cool, thanks
11:57:09 <elmex> hdaume: it was exactly what i searched, after reading 'gentle introduction' and some other texts...which didn't really gave me much clue
11:57:23 <Marvin--> hdaume: I'm reading the Monads chapter right now, it looks excellent
12:00:30 * esap blinks.
12:04:51 <elmex> wow... let me read it :)
12:04:54 <elmex> (away)
12:06:58 <elmex> well, oh. i'mstill missing some type-knowledge... better learn about that first... but before i do that , i will take some bath :)
12:08:48 <elmex> where is the waterproof tablet computer, with linux and wavelan ?
12:35:10 <Segora> elmex: there -> http://www.army-technology.com/contractors/computers/pei2/
12:35:44 <Segora> (ok, maybe you'd have to install linux to fill the spec *g*)
12:43:19 <Darius> "One suggestion would be a real-time strategy computer game (in the spirit of Command&Conquer) where the behavior of each unit on the battlefield is controlled by a signal function."
12:43:28 <Darius> hmm, where is that from? ;)
12:44:01 <jolta|afk> Darius: Hm. Yes, that does sound familiar. =)
12:44:28 * Jolta wonders if anyone has actually tried to install the game yet
12:44:45 * Jolta doubts it works very well atm
12:48:43 <Jolta> reading the source code is the fun part of any good game anyway. ;-)
12:49:00 <Darius> Go OSS!
12:49:04 <tez> What's the other part anyway?
12:49:31 <Darius> I've downloaded it does that help :P.  Of course, I only have 64MB installed ...
13:31:02 <esap> Uhuh, microsoft is trying to conquer the world with an ML-clone. Hmm..
13:31:29 <elmex> esap: huh?
13:31:42 <elmex> owaml? :)
13:32:01 <esap> http://developers.slashdot.org/article.pl?sid=03/05/23/1217233&mode=flat&tid=109&tid=126&tid=156&tid=187
13:33:07 <hdaume> F# is pretty much just OCaml
13:33:26 <esap> So is it just an implementation of OCaml then?
13:33:35 <hdaume> more or less
13:33:57 <elmex> what is ocaml btw?
13:34:04 <hdaume> though i must admit i'm not too up to speed on f#, but heard of it a few months ago and at that time at least it pretty much was ocaml for .net
13:34:08 <hdaume> elmex: caml.inria.fr
13:34:17 <hdaume> elmex: it's an ML variant that has OO
13:34:47 <elmex> hdaume: what is ML? :)
13:35:05 <hdaume> elmex: it's a strict functional language
13:35:15 <elmex> hdaume: strict means?
13:35:19 <hdaume> not lazy
13:35:23 <elmex> oh, ok
13:35:40 <hdaume> it's basically strict haskell with worse syntax and without type classes
13:35:52 <hdaume> but ocaml has oo to make up for it
13:36:12 <hdaume> it also has these things called structures and functors which solve sort of the same problems that classes do in haskell
13:36:36 <elmex> hm....
13:37:29 <elmex> i have felt some ... comercial touch on ocaml... somehow...
13:38:46 <Riastradh> Commercial??
13:39:56 <elmex> ah. hm... i mean... 'closed source touch' ;)
13:40:04 <Riastradh> OCaml is all open source.
13:40:15 <elmex> yes
13:40:44 <elmex> is it free software too?
13:40:52 <hdaume> yes
13:41:04 <elmex> hmm
13:41:05 <esap> elmex: "[Caml] is developed and distributed by INRIA (the main French research institute for computer science)" and "Caml is freely available, and highly portable...". See http://caml.inria.fr/FAQ/general-eng.html
13:41:21 <elmex> ah
13:41:34 <elmex> i guess, i will use haskell :)
13:41:40 <elmex> (the name is cooler ;)
13:42:27 <esap> That is not a good criterion to choose a language.
13:42:38 <elmex> indeed
13:43:34 <esap> But I guess it illustrates how important finding a good name is.
13:43:56 <elmex> *g* not really. i wasn't serious :)
13:44:15 <elmex> but some friend recommended me to learn some haskell....
13:45:24 * Riastradh thinks finding a good name is very important.
13:45:43 <elmex> like brainfuck
13:45:44 * esap is actually looking for a name for my programming language :-)
13:45:57 * Riastradh decided on 'Cloak' for his language.
13:46:12 <Riastradh> Originally it was 'gloop,' and you wouldn't want to be writing code in that, would you?
13:46:38 <esap> I think *oop is already over-used.
13:46:55 <Riastradh> The '-oop' suffix had nothing to do with the acronym OOP, by the way.
13:46:56 <Darius> I think gloop is taken (kind of)
13:47:34 <elmex> i once used 'squash' for my interpreted language...
13:47:51 <elmex> but that project died before it was born ;)
13:48:00 <Riastradh> It got an abortion!
13:48:09 <elmex> *G* 
13:48:13 <Riastradh> Watch out for right-wing nuts and catholics.
13:48:24 <elmex> rofl
13:48:45 <Darius> http://www.c2.com/cgi/wiki?BloopFloopandGloop
13:51:15 <Darius> anyways the less blatantly known names from Norse mythology generally produce decent results as far as interesting names go
13:51:37 <elmex> ah, yes. i bought that book about those languages
13:51:49 <elmex> Goedel,Escher,Bach
13:53:07 <esap> GEB is a good book.
13:53:34 <elmex> indeed... but i just finished that MU thingie and begun with --p--g---- ;)
14:06:05 * tmoertel just tentatively named an inside-out markup language PXSL -- "pixel"
14:08:06 <esap> What does that acronym stand for?
14:08:28 <tmoertel> esap: Parsimonious XML-Substitute Language   ;-)
14:09:02 <esap> That's actually why I don't like acronyms as names.
14:10:04 * tmoertel thinks he just locked up a remote server -- just his luck
14:13:06 * esap 's best proposal for the name of my language is 'symmetry', and I don't like it.
14:13:30 <Riastradh> Ewww.
14:13:55 * esap is open to suggestions for a better name :-)
14:13:57 <Darius> What does your language do?  what's different about it?
14:14:47 <esap> It combines lots of paradigms, but is still very simple.
14:16:03 <esap> It also is very much based on duality and inverses (that's why I considered that name :-)
14:17:13 <esap> oh and I guess the control operator is one difference to what you'd ordinarily expect.
14:18:25 <Darius> Janus comes to mind with that
14:19:26 <esap> Janus?
14:20:04 <Darius> http://www.meridiangraphics.net/janus.htm
14:21:09 <esap> Google finds too many programming language references with that name, so I'd consider that already used.
14:21:25 <Darius> Yeah, I'd imagine
14:22:02 <Darius> I wasn't sure if it was taken for a programming languagu specifically but I'm sure there's a company and I think some software system
14:22:22 <Verbed> I often pick a random word from Finnegans Wake.
14:22:47 <Verbed> Darius: I know of a financial company and an international film company which may not still be around.
14:23:24 <Darius> The financial company is the one I'm aware of.
14:24:14 * esap has also tried lots of names starting with 'co-' [from category theory], but found no good ones.
14:24:45 <Verbed> Virtually all of the Criterion Collection DVD Movies that I've seen have a Janus logo at the beginning of the picture..
14:25:58 <wli> cocone?
14:26:35 <wli> cobraid?
14:26:55 <wli> cofunctor?
14:27:01 <esap> I think I should choose a name I understand what it means :-)
14:27:03 <Verbed> cockroach
14:27:15 <wli> there is no kroach =)
14:27:25 <wli> esap: comonad?
14:27:26 <esap> I considered things like 'co-axial'
14:27:42 <Verbed> Shame, really.
14:28:31 * esap has no way of knowing which words sound right in english.
14:28:35 <wli> coprime?
14:30:03 <Verbed> Finnegans Wake, Penguin, Page. 370: oddstodd
14:30:27 <esap> Do you think those sound like names of a programming language? To me, it sounds too mathematical [to be attractive for the right kind of people]
14:30:53 <Darius> No, and I don't think your going to find many that do
14:31:02 <wli> esap: If sounding mathematical makes it unattractive to a kind of people they aren't the right kind. =)
14:31:28 <esap> wli: no, I mean, I want it to _also_ sound right to people that do not understand category theory :-)
14:32:53 <esap> wli: preferably something with many meanings that all sound right and where different people understand just the "right" meaning to make it sound good to them :-).
14:33:26 <Darius> it's not that they are mathematical, it's that they don't sound like names
14:33:29 <Darius> cotriple?
14:33:46 <Verbed> I prefer poetic or creatively nonsensical names.  They provide a poignant contrast to the 'rigidity' of programming languages.
14:34:11 * esap doesn't agree that programming languages are rigid.
14:34:34 <wli> Verbed: Weialallaleiawalallaleialalla?
14:34:43 <esap> wli: heh
14:34:46 <Verbed> I enclosed it in quotes because I just couldn't find the right word.
14:35:04 <Verbed> wli: I'd skip that one.
14:35:06 <Darius> I prefer interesting subtle names that even without catching the connections still have a nice sound.
14:35:18 <Verbed> You could try a thunderword.
14:35:34 <Darius> Blitzwort?
14:35:42 <wli> I like stark, austere names, that sound even bleaker than the current .us economy.
14:35:45 <wli> Verbed: Da?
14:36:07 <Verbed> http://www.robotwisdom.com/jaj/fwake/thunder.html
14:36:31 <Verbed> Although, it'd probably get abbreviated :)
14:37:04 <esap> Maybe create a recursive acronym from one of those, would that give a good name? 
14:38:13 <Riastradh> Bah, recursive acronyms!
14:38:17 <Darius> Why don't you pick a word from category theory, translate it to japanese and use that
14:38:44 <Darius> Riastradh: I was thinking of saying: *blech* recursive acronyms
14:39:06 <esap> you think recursive acronyms are overused? :-)
14:39:06 <wli> wlish
14:39:54 <wli> Need it to be unicode so \lambda is directly renderable
14:41:29 <Darius> The problem with recursive acronyms is that people who use them think they are clever and witty when they are mundane and boring
14:41:35 <hdaume> how about just kansuu (function in japanese ^_^)
14:41:49 <Darius> see, it works
14:42:06 <Riastradh> Kansuu is a much cooler name than 'symmetry.'
14:42:10 <esap> hmm.. that is clearly the best name I've found so far :-)
14:42:17 <Darius> (well, maybe not for a Japanese speaker)
14:43:28 <esap> hmm.. the japanese for 
14:43:45 <esap> hmm.. the japanese for 'dual' is dyuary. Would that sound right?
14:44:12 <Darius> I also got nigenteki
14:44:26 <Darius> and nigenron for dualism
14:44:28 * esap misspelled it :-( dyuaru.
14:47:11 <esap> most of the japanese words sound too weird to be useful.
14:48:15 <hdaume> most japanese words in cs and math are just english put into their phoentics.   dyuaru is just a transliteration of "dual"
14:48:18 <esap> "shubiikkanshita" means consistent. sounds like one of the thunderwords.
14:54:11 * Darius is entertained by the Japanisation (or however you say Americanized but for Nihon), of English words: tankuburi-jingu
14:56:41 <Darius> tanpuku has an interesting denotation according to this, simplicity and complexity, singular and plural
14:57:31 * esap wouldn't like the name to sound like a contradiction in terms :-9
14:57:53 <wli> I'll settle for comonad
14:58:27 <wli> or actually plurisubharmony sounds interesting
15:18:20 <Verbed> Absurdly disjointed names are fun too.
15:19:00 <Verbed> Like.. 'Fishmonger', where the project has absolutely no recognizable association with fishmongering.
15:20:30 <Verbed> It's like a painting of a Campbell's soup can :)
15:31:12 <elmex> i want to programm an AI 
15:31:18 <elmex> s/mm/m/
15:32:43 <esap> I think there is a saying that AI is defined as something "which we cannot yet do". So this would mean that AI is impossible to implement.
15:33:47 <elmex> esap: 'not yet'
15:34:18 <elmex> esap: but i still want to do it, even if it's not possible (yet)
15:35:25 <Darius> no one is stopping you, go ahead
15:35:33 <elmex> Darius: ok
15:35:46 <elmex> first i will study compute science 
15:35:52 <elmex> and some math
15:37:21 <esap> I think the idea behind that saying is that once something becomes feasible to implement, it is already considered too trivial to be called AI.
15:37:41 <esap> Like the chess programs from some time ago :-)
15:38:19 <elmex> hm... chess programs are very simple... but a program, wihch plays Go well is harder :)
15:38:37 <esap> ok, so do you define AI as "can play go"? :-)
15:38:40 <Darius> bah, games of perfect information are not the way to go.
15:38:45 <elmex> esap: no
15:39:04 * Darius is more of a connectionist as far as this goes.
15:39:34 <elmex> well, i just want to have something, which acts like being conscous
15:45:16 <esap> btw, what is wrong with games of perfect information? everybody says they are too weak to model anything useful, but I don't know enough to understand that argument.
15:46:24 <esap> You could say lambda calculi are perfect information games?
15:48:10 <Darius> I'm not complaining about their capabilities of modeling, I'm complaining about using them as a test for AI
15:48:35 <Darius> Mostly that seems to generate expert system type AI's
15:49:21 <esap> oh ok.
15:49:46 <esap> Actually, that might be the same argument I've heard many times [but not understood the context].
15:51:54 <elmex> hm, i want an AI, that knows how to play Go, Chess and likes to listen to music and discussing with people about all that.
15:52:14 <elmex> it should be able to understand text, and read texts, and interpret them
15:52:51 <esap> Hmm.. OTOH, I think perfect information games can deal with uncertainty [by modelling it, that is to know which parts of information are known and which are not, and then not make any assumptions about the unknown parts].
15:53:45 <esap> So it's not that clear whether perfect information games are insufficient to describe AI.
15:53:47 <steveh> elmex: would you accept an AI that did those things poorly? :)
15:54:36 <elmex> steveh: it should do that in some way, which is compareable to the skills of the programmer
15:54:37 <Darius> I know people who do all those things poorly.
15:55:09 <elmex> steveh: it should have some king of 'free will' (whatever that is ;)
15:55:36 <Darius> elemx: you forgot 'like' (whatever that is)
15:55:37 <steveh> it might behoove us to figure out what that is if we want to imbue a computer with it :)
15:55:51 <Darius> what's a qualitative measure of 'liking' something?
15:56:02 <Darius> er quantitative
15:56:23 <steveh> biochemically no different than eating large quantities of chocolate
15:57:15 <esap> I think "liking" is a higher-order temporal predicate.
15:57:29 <Darius> I know people that are allergic to chocolate, that would have interesting results.  Anyways, there is no biochemical response in an AI.
15:58:04 <elmex> AI don't have to be a simulation of the human body, do they?
15:59:01 <Darius> No, that's not an explicit requirement.
15:59:06 <steveh> it seems to me that in humans all thoughts and emotions are biological processes -- the question is whether the biology can be removed and have something meaningful remain.
15:59:28 <Darius> However, imitating Mother Nature gives fruitful results.
15:59:40 <esap> steveh: why do you need to start from humans to define AI?
15:59:54 <steveh> also, is there More Than One Way To Do It?
15:59:54 <esap> It's called "artificial" for a reason, I guess :-)
16:00:02 <Darius> As that's the only intelligent system, that's the only measure we have.
16:00:05 <steveh> esap: presumably because they are still our only benchmark for intelligence.
16:00:14 <Darius> (recognized intelligent)
16:00:17 <steveh> Darius beat me to it :)
16:01:50 <esap> steveh: that just means that intelligence is not a good attribute to benchmark. You need something that you can define for all attempts. It's no good if you create a great AI, but you cannot determine if it's AI, because your definition of benchmark does not include it.
16:02:42 <steveh> esap: perhaps intelligence is like pornography and we will know it when we see it.
16:02:47 <Darius> esap: It's not that intelligence is or is not a good attribute to benchmark, it's that we don't know what it is even as applied to us.
16:02:52 <Darius> steveh: exactly
16:03:00 <Darius> that's the test for now
16:04:03 <steveh> there probably needs to be more cross-disciplinary stuff with the touchy-feely psych and philosophy departments to get AI rolling some more. Now it seems like a lot of departments are just messing with robots and things.
16:04:06 <elmex> is intelligence applied to us?
16:04:36 <Darius> as the word is applied to us
16:05:11 <elmex> :-)
16:05:19 <esap> I'm not sure I want to see AI "rolling some more"
16:05:30 <steveh> esap: watched the matrix movie, have you?
16:05:32 <Darius> esap: CBN -> GNR
16:05:49 <esap> steveh: sure.
16:05:50 <elmex> if we simulate a human with all that intelligence and everything, we will look at it, and laught, because it acts so stupid
16:06:38 * steveh ponders starting the Tyrell Corporation ...
16:07:07 <steveh> Has anyone here done any serious work in AI?
16:07:19 * steveh has always been interested.
16:07:23 <esap> those chess programs I guess were serious work.
16:07:25 <Darius> I think some people on this channel have, but not me
16:07:33 <Verbed> I wrote a simple neural network once :P
16:09:15 <steveh> the AI people at my school were more old-school, we did symbolic and search kinds of things
16:10:03 <elmex> btw. if i have smoe StateT Int IO a how do i use the IO monad from that State monad?
16:10:15 <Verbed> I pursued neural networks autodidactically and found an excellent introduction.
16:10:33 <steveh> Verbed: what's it called?
16:10:34 <elmex> Verbed: really? cool
16:10:43 <Darius> liftIO
16:10:44 <Verbed> Fundamentals Of Neural Networks: Architectures, Algorithms and Applications by Laurene Fausett
16:10:49 * steveh is autodidacting Haskell
16:10:51 <steveh> :)
16:10:56 <Verbed> :)
16:11:06 * Darius autodidacts everything pretty much
16:11:11 <Verbed> Which was the second book I purchased on the subject.
16:11:12 * elmex too
16:11:41 <Verbed> The first, a 900 page monstrosity was far too technical for me to understand.
16:11:53 <Verbed> It was mostly a concentration of mathematical formulas.
16:13:12 <steveh> well, at least it was 900 pages...the ones you have to watch out for are the slim $80 volumes.
16:13:26 * steveh shudders at the thought of his abstract algebra text.
16:14:25 <Verbed> http://www.amazon.com/exec/obidos/ASIN/0133341860/qid=1053731643/sr=2-2/ref=sr_2_2/103-6230244-0295814
16:14:32 <Verbed> Wow, I probably paid $120 for it too.
16:17:39 <steveh> there sure are a lot of idlers on #haskell
16:18:07 <Darius> It's 1am (I think) in Sweden
16:18:26 <Darius> Much later(earlier) in Australia
16:18:55 <steveh> where are the majority of #haskellers located?
16:19:08 <Darius> Seemingly Europe
16:19:13 <steveh> interesting
16:19:28 <Darius> It's 7pm where I am (east coast America)
16:19:35 <Igloo> And .au
16:19:39 <steveh> same here, I'm in the midwest
16:19:40 <Igloo> Same on the lists
16:20:25 * steveh noticed the wiki on haskell.org got a recent overhaul
16:20:36 <steveh> I remember last year looking at it and not finding much
16:20:48 <elmex> it's 01:20 here (CET)
16:28:58 <elmex> gn8
16:51:01 <jao_>  /quit
21:17:47 <stratocaster> Got a beginner question about type signatures, in case anybody's in the mood:
21:17:54 <stratocaster> somefunc x = x * 2
21:18:02 <stratocaster> otherfunc = \x -> x * 2
21:18:29 <stratocaster> First is "forall a. (Num a) => a -> a
21:18:38 <stratocaster> Second is Integer -> Integer
21:19:04 <stratocaster> what is that constrains the second way of declaring the function to Integer, where the first will deal with, say floats?
21:21:35 <stratocaster> I can see that there's, I guess, another level of abstraction ("indirection"?) in the second way..
21:22:00 <stratocaster> doing "yetanotherfunc = somefunc" also gives a type of "Integer -> Integer"
21:27:12 <stratocaster> and ":t \x -> x * 2" within ghci is "forall a. (Num a) => a -> a". 
21:28:58 <stratocaster> but "binding" that function to a variable/name reduces it to Integer -> Integer... is there a simple answer why, or should I just forget about it?
21:41:29 <tez> Are you using hugs in the firt case?
21:42:07 <stratocaster> yea, I've tried under hugs and ghci, they show the same signatures
21:44:15 <tez> That *is* weird.
21:48:34 <stratocaster> even if I take out the "2", and do, say:
21:48:38 <stratocaster> foo = x * x
21:48:43 <stratocaster> bar = \x -> x * x
21:48:56 <stratocaster> foo is "Num a => a -> a"
21:49:03 <stratocaster> and bar is "Integer -> Integer"
21:49:48 <tez> Hmm.
21:50:23 <tez> You'll have to wait will someone who knows more about the type inference than I do gets up.
21:51:17 <stratocaster> no worries, just seemed odd to me.
21:51:29 <stratocaster> but then, most of this does
21:52:15 <Chipaca> hi all
21:52:25 <tez> This particular behavious *is* odd...
21:52:28 <tez> Hi
21:53:00 <Chipaca> is there any way to make hugs run something automatically on startup?
21:53:38 <Chipaca> duh, man hugs, sorry
21:53:43 <Chipaca> it's late :(
21:56:04 <tez> stratocaster: You can still explicitly tell hugs the type of otherfunc.
21:58:00 <stratocaster> yea, I could change it to say, "Fractional" or something. But I can't use a class like Num, though, can I?
21:58:52 <tez> You say:
21:59:08 <tez> otherfunc :: Num a => a -> a
21:59:34 <tez> (just like somefunc, of course)
22:00:06 <stratocaster> oh duh, that does work
22:00:14 <stratocaster> i must've typoed when I tried
22:00:19 <tez> lol
22:00:20 <stratocaster> cool
22:13:46 <tez> stratocaster: You still there?
22:16:54 <stratocaster> yea
22:17:56 <tez> I just discovered the weird type inference behavious is caused by the Dreaded Monomorphism Restriction (tm).
22:18:55 <tez> http://www.haskell.org/onlinereport/decls.html (go to section 4.5.5)
22:19:09 <tez> That explains it,
22:19:09 <tez> .
22:19:45 <stratocaster> cool, thanks. pulled up a section from the "gentle introduction" on google, too using those keywords
22:20:01 <tez> Ah
22:23:57 <stratocaster> pretty heavy stuff
22:24:32 <tez> Yeah, but it's good practice to try to explicitly declare all types anyway.
22:28:07 <cale> Yeah, you can turn the monomorphism restriction off in GHC, if you'd like though, by using -fno-monomorphismrestriction.
22:28:23 <stratocaster> yea, I have been trying to do so so far, but I have mostly only written functions that work on asingle type
22:32:05 <stratocaster> oh yea, tez, they give exactly the same example just before section 4.6
22:32:28 <stratocaster> well, with "f x y = x + y"
22:33:41 <stratocaster> is that flag specific to a ghc version cale? I have 5.04.3
22:35:38 <cale> It's in all the version 5's that I've seen.
22:43:19 <stratocaster> well, thanks for the help guys. this was bugging me.
