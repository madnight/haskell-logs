01:27:29 <basti_> hi
01:29:47 <andersca> hello basti_
01:30:22 <basti_> hi andersca
01:30:22 <basti_> :)
01:44:48 <andersca> morning marvin
01:45:11 <basti_> hi Marvin--
01:45:44 <Marvin--> morning
01:49:04 * Marvin-- laughs at today's GPF comic
01:49:17 <basti_> gpf?
01:49:28 <Marvin--> www.gpf-comics.com
01:50:15 <basti_> ;)
01:50:15 <basti_> *g*
01:53:47 <Lilith> heh
02:01:01 <Lilith> hi cowgirl
02:01:38 <Cowgirl> hi
02:29:53 <nqn> hi, wli
02:30:07 <wli> re re re
02:30:24 <nqn> you know, I'm ashamed of my uni
02:30:30 <wli> how so?
02:30:38 <mgoetze> wli: it's in australia, probably
02:31:15 <Lilith> mgoetze: heh. :-)
02:31:43 <nqn> but so many students there are losers
02:32:14 <mgoetze> nqn: do they use ... windows? :-O
02:33:07 <nqn> hey, I use windows
02:33:19 <wli> shame on you
02:33:21 <basti_> I do too
02:33:27 <mgoetze> ugh
02:33:30 <basti_> its a nice terminal platform
02:33:31 <nqn> nothing wrong with windows when you need a temporary lobotomy
02:33:34 <mgoetze> i'm surrounded by windows users
02:33:35 * mgoetze runs
02:33:42 <nqn> basti:  it's an awful terminal platform
02:33:46 <mgoetze> basti_: terminal? whatcha gonna connect to?
02:33:49 <basti_> of course all the important stuff is on a linux machine :)
02:33:50 <nqn> it's a nice online gaming platform
02:34:01 * nqn refrains from saying 'ewwww, linux'
02:34:06 <nqn> wait, did I say that aloud?
02:34:13 <wli> I don't know I just make the kernel work on 64GB x86en
02:34:16 <basti_> i use my windows system like one would use a graphics terminal
02:34:22 <mgoetze> nqn: no, it's a crappy online gaming platform, but all the online games are written for it anyway.
02:34:26 <wli> (linux kernel)
02:34:39 <nqn> mgoetze:  that's possibly true
02:34:45 <basti_> I think for basic tasks windows can be pretty quick
02:35:02 <nqn> X is no better, though
02:35:06 <basti_> and I do nothing more but basic tasks... chatting, mail, web, ftp, ssh...
02:35:17 <wli> I hack the kernel
02:35:19 <wli> no kernel source
02:35:24 <wli> not interested
02:35:35 <basti_> ?
02:35:35 <mgoetze> basti_: i'm sure i can do pretty much any basic task quicker than someone else if that other person had to use windows for it
02:35:43 <basti_> *laugh*
02:35:49 <basti_> of course
02:35:58 <wli> main = getArgs >>= mapM_ (\file -> sequence_ . zipWith writeFile (map (((reverse . takeWhile (/= '/') . reverse $ file)++).("-"++).show) [1..]) . splatterHunks =<< readFile file)
02:35:59 <wli> splatterHunks = map unlines . concatMap (\s -> map ((++) (take 3 s)) (splitList "@@" s)) . splitList "diff" . lines
02:35:59 <wli> splitList prefix ss = [[s | (k, s) <- ss', m <= k, n > k || n <= 0] | (m,n) <- let ss'' = [j | (j,s) <- ss', prefix `isPrefixOf` s] in zip ss'' (tail ss'' ++ [-1])] where ss' = zip [0..] ss
02:36:03 <wli> hmm
02:36:07 <basti_> I dont doubt that there are ways to interface quicker
02:36:09 <wli> maybe my style is a bit terse
02:36:16 <basti_> wli: maybe yes ;)
02:36:31 <basti_> what does ' do?
02:36:34 <mgoetze> nqn: if you're implementing an online game via remote-displaying things with the X11 protocol, you have some serious brain damage, yes
02:36:58 <nqn> er, nothing
02:37:00 <Darius> wli: why do you use sections some times but not others?
02:37:06 <wli> ' either introduces a character literal or is a suffix to a name
02:37:17 <basti_> as a suffix i mean
02:37:23 <wli> Darius: depends on which one is shorter
02:37:25 <nqn> it denotes that the programmer is a maths geek
02:37:37 <Darius> and a list comprehension may be able to take out those maps.
02:37:47 <ludde> does ghc have something similar to C's #include (when compiling without -cpp)
02:37:49 <basti_> is it "+1"?
02:37:54 <Darius> when is a section longer?
02:38:02 <nqn> no
02:38:03 <wli> ludde: no
02:38:27 <wli> Darius: basically when there's no chance to use it for a composition pipeline
02:38:29 <Darius> GHC 5.05 has TH, though that's quite a bit different, what's wrong with CPP (besides the obvious)
02:41:37 <nqn> is it possible to do lisp-style macros in haskell?
02:41:48 <wli> not that I know of
02:42:06 <Darius> map ((++) (take 3 s)) == map (take 3 s++) -- for the section
02:42:51 <nqn> darius:  can you explain the latter syntax?
02:43:21 <Darius> It's a section like (1+).  Function application always binds tightest.
02:43:23 <wli> sure I'll buy that
02:43:57 <nqn> oh.  I don't understand sections.
02:44:13 <Darius> (1+) = (\x -> 1+x)
02:44:15 <wli> nqn: partially applied infix operators
02:44:47 <nqn> okay
02:46:47 <nqn> hmmm
02:47:10 <nqn> I find the syntax not using sections clearer
02:48:46 <wli> hmm
02:49:44 <seth> I have an enumerated type I created with the data statement.  How do I make this a member of the ord class?
02:49:58 <Darius> derive ord
02:49:59 <wli> deriving Ord
02:51:00 <seth> Don't I also have to write a compare function?
02:51:27 <Darius> wouldn't it just be a bunch of boilerplate?  That's what derive handles.
02:51:32 <seth> Or I'llk get No instance for (Eq Whatever)  ?
02:51:50 <shapr> hi wli, long time no see, how's life?
02:51:57 <Darius> If you do then derive Eq too
02:51:58 <seth> Darius: no, it won't work unless the elements of the enumeration are members of class Eq
02:52:55 <shapr> goood morning #haskell!
02:52:57 <seth> How do I derive two classes?  I tried two deriving lines, deriving class1, class2, and driving class1 class2 and they all are parse errors
02:53:09 <Darius> derive (Eq,Ord)
02:53:10 <shapr> seth: deriving ( Foo, Bar )
02:53:13 <Darius> er deriving
02:53:16 <seth> ok, thanks.
02:53:26 * shapr thinks deriving ( Miss, Daisy )
02:54:02 <Lilith> that's a pretty old movie
02:54:32 <shapr> it's not older than that louis armstrong movie
02:55:23 <wli> I want to use something like a reader monad to thread context through scope; thing is I basically don't understand the MonadReader bit
02:55:49 <Darius> What about it do you not understand?
02:56:17 <wli> basically how to locally add definitions for a nested scope with it
02:56:46 <Darius> use local (addDefn newDef) nestedComputation
02:57:32 <Darius> local :: (MonadReader e m) => (e -> e) -> m a -> m a
02:57:40 <wli> hmm
02:57:58 <wli> that would appear to do it at first glance
02:58:55 <wli> I'll bet it was b/c I was using ((->) t) as the functor
03:00:03 * elmex (if the monad is chasing you, raise an exception)
03:00:03 <Darius> ((->) t) aka (t->) is an instance of MonadReader I believe
03:00:35 <wli> (t->) doesn't parse which is why MonadReader.lhs uses ((->) t)
03:00:56 <wli> (last I checked anyway)
03:03:24 <Darius> Well, Reader.hs uses ((->) r), but (r->) seems to parse for me
03:03:35 <wli> might have been fixed recently
03:03:51 <wli> could be my imagination
03:06:58 <wli> so for a local binding w/an FM it'd be check (Let (var, val) letBody) = local (\m -> addToFM var val) (check letBody) or something?
03:07:03 <wli> er
03:07:13 <wli> so for a local binding w/an FM it'd be check (Let (var, val) letBody) = local (\m -> addToFM var val m) (check letBody) 
03:07:18 <wli> one more time
03:07:25 <wli> \m -> addToFM m var val
03:09:37 <Darius> That should be correct
03:13:14 <Darius> Also asks may be convenient in other parts (if you haven't already noticed it).  Combined with do notations sugar for binding it gets pretty convenient.
03:14:19 <wli> well
03:14:22 <wli> you have inference rules
03:14:29 <wli> asks should come up there
03:15:49 <Darius> E.g. Just val <- asks (flip lookupFM var);  If you are in a monad that handles failure (Error/NonDeterminism) then if the pattern match fails, it'll e.g. throw an exception.
03:16:49 <Darius> (an exception in the monad, not a "real" exception)
03:18:19 <wli> yeah I can deal with that
03:21:48 <elmex> is recursion in haskell cheaper than in other languages, like C, Perl, Java(?) ?
03:22:35 <Darius> Theoretically, no.  Practically, yes for the languages you listed.
03:22:57 <elmex> haskell?
03:22:59 <Darius> Or at least it's implementation dependent
03:23:50 <Darius> Yes Haskell.  Optimizing recursion is pretty important, whereas many C compilers don't do tail-call optimization.
03:24:10 <wli> tailcall optimization is tricky in C
03:24:40 <elmex> which direction of recursion is better in haskell? left or right? :)
03:25:10 <wli> there's no distinction between them AIUI
03:25:16 <elmex> ok
03:25:54 <elmex> aw.. well.. right: funcA ++ funcB <=> (++) funcA funcB .... so its tail
03:26:22 <wli> elmex; you do realize that haskell is pure?
03:26:30 <Marvin--> wli: heh, I remember in our mud code (written in C, back in the ol' days) some functions ended with a "dummy();" call with the comment "Some compilers like to change the last call in a function to a jmp, this messes up debugging to no end"
03:27:01 <Darius> Marvin--: They shouldn't do it with debugging flags set!
03:27:10 <Marvin--> Darius: exactly
03:27:11 <Darius> That'd just be messed up.
03:27:12 <elmex> wli: i do
03:27:25 <elmex> wli: it's so pure, like a virgin ;)
03:27:27 <wli> elmex: i.e. calls can be freely reordered
03:27:35 <wli> hmm
03:27:38 <wli> a MUD sounds like fun
03:27:41 <Marvin--> Darius: remember that this was an old open source mud that used to run on a gazillion of unices on a gazillion of architectures :)
03:28:14 <Marvin--> well, the mud code base was open source, ours was extended of course
03:28:21 <wli> abermud?
03:28:51 <Marvin--> ours was based on ROM 2.something which was based on something that was based on DIKU something
03:29:02 <wli> okay diku then
03:29:30 <elmex> is there a mud written in haskell?
03:29:39 <Marvin--> not that I know of, would be fun to try though
03:29:46 <elmex> ;)
03:29:47 <wli> not yet that I know of =)
03:30:00 <Marvin--> but I think a dynamic language like python would be more suitable
03:30:05 <Marvin--> at least if you want LP-style dynamics
03:30:15 <elmex> lp?
03:30:22 <Marvin--> LPMud
03:30:35 <Marvin--> their mud was basically a C interpreter
03:30:40 <elmex> uh
03:30:45 <Marvin--> or rather, LPC interpreter
03:30:51 <Marvin--> C + basic object orientation, niftier types et.c.
03:31:09 <elmex> yes, but you could write the interpreter in haskell then...
03:31:24 <Marvin--> yes, but the good thing with python is that you get the interpreter for free...
03:31:27 * shapr receives his instructions
03:31:29 <wli> I'd think a logic language would make the most sense
03:31:47 <wli> there are certain low-level database mechanics
03:31:49 <shapr> yay, more xml processing
03:31:59 <elmex> logic language?
03:32:01 * Marvin-- boggles at the task of implementing a mud in prolog
03:32:19 <shapr> wli: hey, have you seen lambdabot?
03:32:20 <wli> yes a logic language
03:32:28 <wli> no I've not seen lambdabot
03:32:31 <shapr> @yow
03:32:32 <lambdabot> Today, THREE WINOS from DETROIT sold me a framed photo of
03:32:32 <lambdabot>  TAB HUNTER before his MAKEOVER!
03:32:35 <shapr> @listmodules
03:32:36 <lambdabot> I have the following modules installed: ["chess","dict","eval","fortune","hello","karma","more","state","system","topic","type","yow"]
03:32:52 <shapr> it's in the haskell-libs sourceforge project
03:33:01 <shapr> easy to write plugins :-)
03:33:10 <Darius> My admittedly limited experience with prolog makes me shudder at implementing most things in it.  Perhaps I should check out Goedel or Curry.
03:33:44 <wli> They make a lot of sense for doing logic things in
03:34:16 <elmex> ?
03:34:24 <wli> haskell-libs.sf.net shows garbage
03:34:27 <Marvin--> uh, speaking of MonadReader, btw... How is  asks f  any different from  liftM f ask  ?
03:34:40 <shapr> wli: http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/lambdabot/
03:35:22 <shapr> Jens Petersen is writing a gtk2 IRC client based on the lambdabot code
03:35:27 <andersca> cool
03:35:51 <shapr> andersca: hey, what's the eta for funkilus?
03:36:01 * shapr wonders if that's eta expansion
03:36:17 <Marvin--> shapr: *groan*
03:36:19 <andersca> I dunno, I might do another project
03:36:21 <wli> well that's easy
03:36:23 * shapr snickers
03:36:23 <Marvin--> shapr: more like eta expectation
03:36:37 <wli> eta expansion is \x -> f x ==> f
03:36:37 <shapr> andersca: what's the other project?
03:36:45 <andersca> shapr: .mod player
03:36:49 <shapr> nifty :-)
03:37:00 * Marvin-- is busy enough with debian-installer and his degree project :-/
03:37:02 <andersca> I thought you could do some nice things with lazy evaluation there
03:37:30 <shapr> wli: is that the same as const f ? 
03:37:44 <Marvin--> andersca: what, it wouldn't play anything before the user decides to listen? :-)
03:37:54 <wli> shapr: no
03:37:57 <Marvin--> shapr: no
03:38:01 <shapr> what does the ==> mean?
03:38:12 <wli> shapr: ==> is "transforms to"
03:38:18 <Marvin--> shapr: \x -> f x  is a function that applies f to something, f is also a function that applies f to something
03:38:58 <shapr> oh, I think I understand that.
03:39:33 <shapr> replace f with a function that takes an argument and applies f to that argument
03:40:46 <Marvin--> well, eta expansion is in the other direction
03:41:21 <shapr> apply f to an argument, replace f with the result?
03:41:29 <wli> what exactly does the chess module do?
03:41:33 <shapr> @board
03:41:34 <lambdabot>  r n b q k b n r
03:41:34 <lambdabot>  p p p p p p p p
03:41:34 <lambdabot>  - - - - - - - -
03:41:34 <lambdabot>  - - - - - - - -
03:41:34 <lambdabot>  - - - - - - - -
03:41:35 <lambdabot>  - - - - - - - -
03:41:37 <lambdabot>  P P P P P P P P
03:41:39 <lambdabot>  R N B Q K B N R
03:41:41 <shapr> @listcommands chess
03:41:42 <lambdabot> Module chess provides the following commands: ["ply","reset-chess","validmoves","board","flip-board"]
03:41:54 <Marvin--> shapr: no, eta expansion is replacing  \x.f x  with  f
03:42:01 <shapr> chess has per-channel and per-user boards as well
03:42:09 <Marvin--> shapr: they're the same thing, both are functions
03:42:19 <ddarius> reduction
03:42:34 <Marvin--> right, sorry
03:42:57 <shapr> that's eta reduction?
03:43:06 <andersca> when you do stuff faster
03:43:11 <andersca> thus reducing the ETA
03:43:13 <ddarius> expansion is the other way
03:44:14 <shapr> andersca: hehh
03:44:30 <shapr> ok, I think I understand it now, thanks.
03:45:03 <wli> hmm
03:45:33 <shapr> wli: some of the lambdabot modules are disable since I've recently given away my database host
03:45:56 <wli> suppose one's accessing a database
03:46:06 <wli> say
03:46:19 <ddarius> '@fact' has had a face lift and is now written 'shapr:'
03:46:25 <wli> you've got /dev/sd[f-s] which are database bits
03:46:32 * shapr grins
03:46:42 <wli> and you want to do sys_remap_file_pages()
03:46:49 <shapr> what's sd[f-s] ?
03:46:56 <wli> actually
03:47:00 <wli> there isn't even an mmap()
03:47:57 <wli> sysv sems, msgs, and so on are missing
03:50:18 <shapr> ?
03:51:24 <Janni> Morning!
03:51:29 <shapr> g'mornin Janni 
03:51:37 * Janni is back from his 7 hours sleep
03:51:51 <Janni> But it was too short, somehow...
03:52:46 <Janni> How can I make hugs do decent line-buffering on getLine/(hGetLine stdin)?
03:53:30 <Janni> getLine just isn't line-buffered and hGetLine stdin doesn't show the inputted characters..
03:56:16 <wli> you need terminal echo etc.
03:57:37 * shapr writes bunches of XML processing rules
03:57:42 <shapr> HXmlToolbox is quite powerful
03:57:50 <wli> 5.19.6. Terminal control
03:57:50 <wli>   hIsTerminalDevice :: Handle -> IO Bool
03:57:50 <wli>   hSetEcho          :: Handle -> Bool -> IO ()
03:57:50 <wli>   hGetEcho          :: Handle -> IO Bool
03:57:55 <shapr> though it's a bit non-intuitive at first
03:58:03 <Janni> wli: thx!
03:59:52 <Janni> wli: Err... I can't find those commands within the Hugs modules...
04:00:05 <wli> they aren't in hugs, they're ghc extensions
04:00:36 <Janni> But this terminal echoing problem doesn't occur with GHC(i), but only with hugs.
04:03:05 <wli> oh
04:03:09 <wli> not sure what hugs is doing wrong then
04:05:39 <wli> hmm
04:05:45 <wli> okay I've got a sizeable wishlist
04:05:51 <shapr> for what?
04:06:08 <wli> shapr: basically OS facilities I want interfaces for
04:06:28 <shapr> nifty
04:07:00 <wli> shapr: basically mmap(), remap_file_pages(), futexes, and SMP-capable threading.
04:07:28 <shapr> there's not an interface to SMP-capable threading?
04:07:36 <wli> shapr: Concurrent doesn't do it
04:07:45 <wli> shapr: oh, sysv stuff too
04:07:46 <shapr> it can with --enable-threaded-runtime-system
04:08:00 <wli> shapr: really? the docs are out-of-date then
04:08:03 <shapr> the ghc5 deb doesn't have --enable-threaded-runtime-system because then OpenGL fries
04:08:23 <shapr> GLUT absolutely requires that the same OS threads talks to it at all times
04:08:45 <shapr> ghc5 runtime system uses coroutines internally, and they pick any handy OS thread from a pool
04:09:05 <wli> shapr: well that's how kernels work
04:09:14 <shapr> ?
04:09:22 <shapr> I don't know much about kernels.
04:10:01 <shapr> I've ended up building my own ghc 5.05 from CVS
04:10:39 <shapr> I'm not quite brave enough to try running it on linux 2.5, even though I've heard 2.5 has great SMP improvements over 2.4
04:10:52 <wli> shapr: lots of coroutines in a big pool, each cpu grabs a coroutine out of the pool to run whenever one coroutine says "okay stop running me"
04:11:04 <shapr> wli: random question, do you know if it would speed up my SMP kernel to give it -march=athlonmp on my dual Athlon MP?
04:11:16 <wli> i.e. not much difference between a userspace and kernelspace thread scheduler
04:11:21 <shapr> oh, that's nifty
04:11:37 <wli> shapr: it should be done with kernel configuration options anyway
04:11:53 <shapr> kernel config allows -march=athlon
04:12:10 <wli> shapr: I doubt it will make much difference
04:12:10 <elmex> building ghc failed for me
04:12:11 <shapr> well, menuconfig...
04:12:20 <shapr> wli: that's what I wanted to know, thanks.
04:12:37 <shapr> elmex: are you building from the fptools cvs?
04:12:44 <elmex> shapr: i do
04:13:03 <shapr> I had some problems earlier, but my checkout from last week worked just fine.
04:13:03 <elmex> wait, i'm just doind make again, most things have been build
04:14:06 <shapr> wli: out of interest, what's the largest number of CPUs in a single box that you've booted linux on?
04:14:14 * Darius is rebuilding 5.05. Yay! I get to find all the little path issues again!
04:14:20 <wli> shapr: 32
04:14:26 * shapr drools
04:14:42 <wli> shapr: run on 16 most days
04:15:17 * shapr continues to drool
04:15:25 <shapr> well, hopefully my next box will have 4
04:15:32 <wli> not as exciting as you might think
04:16:04 <wli> I'm thinking about buying a fresh box.
04:16:08 <Janni> shapr: For personal use?
04:16:15 <shapr> Janni: yah, of course :-)
04:16:31 <wli> been looking at some 4x physical P4 mobos
04:16:34 <shapr> my dual 1.5GHz box is for web development ;-)
04:16:42 <wli> i.e. 8x logical
04:16:45 <wli> 32GB max RAM
04:16:47 <Janni> Uhhh. I don't know why I should get s.th. better than my Athlon-500...
04:17:10 <wli> mostly I need more RAM
04:17:16 <shapr> yah, I need more ram also
04:17:19 <Janni> shapr: Then you must also be using Windows
04:17:23 <shapr> Janni: no way
04:17:57 <shapr> J2EE development nearly requires that sort of hardware :-/
04:18:17 <shapr> if you're running the server locally
04:22:05 <wli> newQSemN    :: Int   -> IO QSemN  
04:22:05 <wli> signalQSemN :: QSemN -> Int -> IO () 
04:22:05 <wli> waitQSemN   :: QSemN -> Int -> IO ()
04:22:17 <wli> these aren't adequately described in the docs
04:22:35 <shapr> you could contribute better docs
04:22:50 <wli> I have to know the answer(s) to do that
04:22:52 <shapr> SyntaxPolice wrote some docs for the Control.Monad part of the tree
04:22:54 <shapr> oh, ok
04:23:00 <shapr> yah, I understand that.
04:23:17 <shapr> several functions in the Prelude really need docs and examples too
04:23:53 <Darius> There's a decent reference in the Haskell bookshelf for the prelude functions (it's incomplete right now)
04:26:23 * Janni is doing some code cosmetics on his Mastermind-program before making it a lambdabot module.
04:26:26 * shapr discovers more useful XML filters
04:26:33 * shapr cheers for HXmlToolbox
04:26:56 <Janni> But I'm wondering, what features it should have. Maybe a Top10-list?
04:27:13 <shapr> I'd start with "plays mastermind"
04:27:19 <shapr> and then make it a lambdabot plugin
04:27:25 <shapr> and then add more features once that works
04:28:18 <elmex> shapr: does it have XSLT ?
04:28:23 <Janni> OK. But how should it play mastermind? One game, that everybody could participate, or starting one for every user?
04:28:43 <shapr> elmex: not yet, but the built-in combinators are far more powerful than XSLT
04:28:57 <elmex> shapr: but XSLT is a standart
04:29:05 <shapr> Janni: the first version of the plugin should have one game that everybody participates in
04:29:08 <shapr> elmex: so is windows ;-)
04:29:19 <shapr> and ms.doc
04:29:27 <elmex> shapr: but windows and ms.doc is broken
04:29:32 <shapr> yes, exactly
04:29:49 <shapr> I've written a bit of XSLT, it can be a real pain in the butt.
04:30:21 <elmex> yes
04:30:40 <elmex> lambdabot: @karma+ shapr
04:30:40 <shapr> change all tagnames from <text:p> to <p> "processTopDown (seqF [replaceQName "p",replaceAttrs []] `when` isTag "text:p")"
04:30:41 <lambdabot> shapr's karma has been incremented.
04:31:06 <shapr> oh, and the replaceAttrs changes the attribute list to an empty list
04:31:48 <shapr> I've built a list of transforms like that
04:31:58 <shapr> now I just stuff the xml sources into that list of filters
04:32:17 <Darius> @karma+ lambdabot
04:32:17 <lambdabot> lambdabot's karma has been incremented.
04:32:30 * shapr grins
04:32:34 <shapr> @karma lambdabot 
04:32:34 <lambdabot> lambdabot has a karma of 1
04:32:50 <lambdabot> @karma+ lambdabot 
04:34:00 <lambdabot> You can't change your own karma, silly.
04:34:11 <elmex> @karma shapr
04:34:11 <lambdabot> shapr has a karma of 2
04:34:15 <elmex> @karma elmex
04:34:15 <lambdabot> You have a karma of 0
04:34:23 <elmex> :((
04:34:30 <shapr> @karma+ elmex 
04:34:30 <lambdabot> elmex's karma has been incremented.
04:34:32 * shapr grins
04:34:37 <elmex> :)
04:34:45 <shapr> the karma isn't saved when lambdabot shuts down
04:34:54 <shapr> it's on the TODO list though
04:35:06 <elmex> ?!
04:35:18 <shapr> elmex: wanna fix it?
04:35:41 <elmex> shapr: hmm, is there any db for ha04:35:43 <elmex> gdbm?
04:35:52 <shapr> lambdabot is using postgresql
04:36:14 <shapr> with the bindings from http://sf.net/projects/htoolkit/
04:36:22 <elmex> i don't know postgresql
04:36:24 <shapr> HToolkit also has odbc and mysql bindings
04:36:41 <shapr> imho, postgresql is the best open source db
04:38:58 <elmex> why? mysql is free software
04:39:11 <shapr> until recently, mysql didn't have transactions
04:39:19 <wli> shapr: is there a unix haskell lib for postgresql?
04:39:23 <shapr> that's like having a filesystem without journaling!
04:39:34 <shapr> wli: yes, at http://sf.net/projects/htoolkit/
04:39:45 <shapr> it's a bit of a pain to build, but someone helped me
04:39:51 <shapr> I've filed patches
04:40:54 <shapr> wli: FactModule.hs in the lambdabot cvs tree uses the HToolkit pg binding
04:40:57 <wli> shapr: what's out there in the way of generic protocol stuff?
04:41:28 <wli> shapr: SMTP? IMAP? IRC?
04:41:28 <shapr> imho, HaskellDB should become the standard DB-API for Haskell
04:41:41 <wli> does HaskellDB work on unix?
04:41:45 <shapr> nope
04:42:01 <shapr> HaskellDB currently requires Hugs and odbc on windows
04:42:20 <shapr> someone added MySQL support to it at one point, but has told me he cannot release that code
04:42:21 <wli> shapr: the project hasn't released any files
04:42:36 <shapr> yah, I'm using the sources from cvs
04:42:55 <wli> what should I put CVSROOT=
04:43:04 * shapr looks
04:43:29 <shapr> you mean --> :pserver:anonymous@cvs.sourceforge.net:/cvsroot/htoolkit 
04:43:29 <shapr> ?
04:44:01 <shapr> HaskellDB requires Hugs' TREX support, which gives extensible records
04:44:20 <shapr> the author of HaskellDB said there's a way it could be ported to GHC, but I haven't had to follow up on that.
04:44:31 <wli> $ cvs co htoolkit
04:44:31 <wli> cvs server: cannot find module `htoolkit' - ignored
04:44:31 <wli> cvs [checkout aborted]: cannot expand modules
04:45:14 <shapr> I think there are enough people interested in HaskellDB to get a development/porting effort started
04:45:17 <shapr> http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/htoolkit/
04:45:48 <shapr> I've emailed the author, asking for a license for HaskellDB
04:45:51 <shapr> but haven't heard a response yet.
04:45:52 <Janni> shapr: Is there some documentation on how to write lambdabot-plugins or will I have the honour of having to look at the sources?
04:46:08 <shapr> Janni: look at the sources, first look at @hello, then at @state
04:46:08 <shapr> @hello
04:46:09 <lambdabot> Hello world. 
04:46:13 <shapr> @hello We are receiving you.
04:46:14 <lambdabot> Hello world. We are receiving you.
04:46:16 <shapr> @state
04:46:16 <lambdabot> sloff
04:46:20 <shapr> @state blah
04:46:22 <wli> ls
04:46:23 <shapr> @state bip
04:46:23 <lambdabot> blah
04:46:42 <wli> how do I build it?
04:47:04 <shapr> wli: patch the autoconf file and then autoconf && ./configure && make
04:47:05 <wli> error:
04:47:05 <wli>  could not find 'HsFFI.h'
04:47:10 <shapr> hrm
04:47:48 <wli> $ autoconf
04:47:48 <wli> autoconf: Undefined macros:
04:47:48 <wli> configure.in:182:    AC_COMPILE_IFELSE(
04:48:31 <shapr> add AC_PREREQ(2.53)
04:48:36 <shapr> just under the AC_INIT line
04:48:40 <shapr> I think that'll fix it.
04:48:53 <wli> shapr: um
04:48:59 <wli> shapr: there are control characters all over it
04:49:04 <shapr> ??
04:49:14 <wli> shapr: ^M's at the end of every line
04:49:18 <shapr> weirdness
04:49:25 <shapr> using HToolkit/configure.in ?
04:49:31 <Darius> That's CRs
04:49:36 <wli> shapr: yeah
04:50:01 <shapr> I don't see them
04:50:13 <shapr> oh, yes I do
04:50:22 <shapr> even so, it works for me
04:50:33 <wli> shapr: want a patch?
04:50:46 <Darius> It is (got downloaded) as a DOS text file.
04:50:47 <shapr> for configure.in ?
04:51:00 <wli> shapr: yep
04:51:03 <shapr> I should really persuade them to add me as developer ;-)
04:51:13 <shapr> then I could apply all these patches
04:51:15 <shapr> wli: yes, please
04:52:23 <wli> shapr: DCC'd
04:53:01 <shapr> my client doesn't do dcc at the moment, could you email it?
04:53:11 <shapr> shae at ScannedInAvian dot  com
04:53:15 <wli> sure
04:53:20 <shapr> thanks
04:53:52 <wli> $ nice -19 make -j4 depend
04:53:52 <wli> /usr/local/bin/hsc2hs Database/ODBC/HSQL.hsc -Iincludes 
04:53:52 <wli> /usr/local/bin/hsc2hs Database/PostgreSQL/HSQL.hsc -Iincludes 
04:53:52 <wli> HSQL.hsc:47:22: libpq-fe.h: No such file or directory
04:53:52 <wli> HSQL.hsc:48:22: postgres.h: No such file or directory
04:54:08 <wli> /j #debian-devel
04:54:18 <shapr> ah
04:54:34 <wli> /msg apt find postgres.h
04:54:36 <wli> ergh
04:55:05 <shapr> yah, you need to install the postgres dev package
04:55:40 <shapr> I had to change "mkSqlType (#const ZPBITOID)	   	size = SqlBit size" to "mkSqlType (#const BITOID)	   	size = SqlBit size" in the HSQL.hsc
04:55:51 <shapr> like I said, a pain to build
04:56:29 <Darius> c2hs
04:56:30 <Darius> ?
04:57:08 <shapr> postgresql bindings in htoolkit
04:57:33 <wli> hmm
04:58:10 <Darius> yeah, I was wondering if it was using c2hs, but there is another tool that uses #const like that.  (In fact, I'm not even sure if c2hs uses it like that)
04:58:19 <shapr> I think that's c2hs
04:58:24 * shapr checks the Makefile
04:58:40 <shapr> looks like it is
05:00:02 <Igloo_> hsc2hs supports a #const - it's on the TOOD list for c2hs
05:00:10 <shapr> oh
05:00:53 <wli> $ nice -19 make CPPFLAGS=-I/usr/include/postgresql -j4 depend
05:00:53 <wli> /usr/local/bin/hsc2hs Database/ODBC/HSQL.hsc -Iincludes -I/usr/include/postgresql
05:00:53 <wli> /usr/local/bin/hsc2hs Database/PostgreSQL/HSQL.hsc -Iincludes -I/usr/include/postgresql
05:00:53 <wli> HSQL.hsc:48:22: postgres.h: No such file or directory
05:00:53 <wli> HSQL.hsc:49:29: catalog/pg_type.h: No such file or directory
05:02:03 <shapr> postgres.h is under -I/usr/include/postgresql/server
05:02:17 <shapr> I don't remember how to fix that one
05:02:28 * shapr diffs the dir
05:02:46 <wli> In file included from HSQL.hsc:44:
05:02:46 <wli> includes/HSQLStructs.h:18: syntax error before "SQLULEN"
05:02:46 <wli> includes/HSQLStructs.h:18: warning: no semicolon at end of struct or union
05:04:00 <shapr> the two changes I mentioned are the only changes I made
05:04:17 <wli> /last shapr 999
05:04:20 <shapr> I did have to run "make -k" a few times to get around dependency problems in the Makefile
05:05:13 <wli> where are you getting SQLULEN from?
05:05:54 <shapr> HToolkit/Database/ODBC/HSQL.hsc:type SQLULEN      = SQLINTEGER
05:06:06 <shapr> err
05:06:07 <wli> that's a Haskell version
05:06:11 <wli> I see i tin C
05:06:22 <wli> hmm
05:06:26 <wli> I'm barfing on hierarchical libs
05:06:32 <shapr> HToolkit/includes/HSQLStructs.h:                SQLULEN ColumnSize;
05:06:33 <shapr> ?
05:06:41 <wli> yeah that's the one
05:07:20 <wli> shapr: what's the latest ghc5 deb?
05:07:25 <wli> I have 5.02.2-1
05:07:40 <shapr> 5.04.2 is the latest in debian/unstable
05:07:50 <shapr> I've built my own 5.05 so I can play with TH and mdo
05:08:17 <wli> shapr: can one do a cvs update in the debian build dir?
05:08:18 <Darius> Have you found anything needing mdo?
05:08:50 <shapr> Darius: the module initialization happening after connection in lambdabot 
05:09:00 <shapr> wli: I don't know
05:09:17 <shapr> would be handy if it works
05:10:35 <shapr> hi saz 
05:10:43 <saz> hi!
05:10:50 <shapr> what's up?
05:11:07 <saz> erm, nothing :)
05:11:19 <wli> /des #haskell tries it
05:11:24 * wli tries it
05:11:26 <shapr> are you learning Haskell?
05:14:06 <elmex> hsSyn/Convert.lhs:262: Data constructor not in scope: `IntPrim'
05:14:09 <wli> shapr: do I need to update to a specific branch? ghc/VERSION still says 5.02
05:14:16 <elmex> still doesn't compile
05:14:32 <shapr> wli: I don't know. Igloo_ knows more about dealing with GHC CVS than I do.
05:15:16 <Darius> There is some stuff happening with TH about that, if Igloo's still on he would be able to best tell you the situation.
05:16:53 <wli> cvs [server aborted]: no such tag ghc-5-05
05:17:05 <wli> well ghc-5-04 exists
05:17:24 <elmex> is there some special trcik about compiling ghc cvs?
05:17:30 <elmex> (fptools)
05:17:42 <wli> not really
05:18:13 <wli> well let's see what cvs update -r HEAD does
05:24:22 <Janni> Is there a way, to do s.th. like import X,Y,Z. I want to outdo Perl with Haskell in the ultrashort code discipline (there is really a chance with my Mastermind game). Someone posted a Perl solution in 4 line a 78 characters. If I could do import X,Y,Z somehow, I'd do it in 3 lines!
05:24:33 <wli> okay HEAD seems to have the most recent changes logged in cvs-ghc
05:25:04 <shapr> Janni: have you tried import (X,Y,Z) ?
05:25:56 <Janni> Doesn't work
05:26:10 <wli> shapr: what other options are good to build with besides --enable-threaded-runtime-system?
05:26:14 <shapr> you could do import X;import Y;import Z
05:27:08 <Janni> Yeah, that's what I have right now, but I'm importing 5 modules. That's almost one line
05:27:08 <shapr> wli: I can't think of anything else.
05:27:40 <Janni> Well, I could cheat a bit. hugs doesn't need an "import Char" for using digitToInt
05:27:41 <shapr> Janni: or you could get extra cheesy and import all of those modules in another file, and then import the other file
05:27:49 <Janni> though GHC does
05:28:11 <Darius> wli: examine the mk/build.mk.sample
05:28:19 <Darius> and related .mk files
05:28:23 <Janni> shapr: nope. The deal is, to get it all in a mail/news-article signature, I guess
05:28:29 <wli> is current 5.05.1?
05:29:07 <shapr> current is 5.04.3
05:29:12 <Darius> If you've checked out from HEAD, it's the latest there is.
05:29:35 <shapr> much like 2.4 is current linux, but 2.5 has the fun
05:29:40 <shapr> same with .04 vs .05
05:29:54 <wli> shapr: I thought you said you were using 5.05
05:29:58 <shapr> I am
05:30:24 <shapr> wli: do you use 2.5 on your machines?
05:30:32 <shapr> (linux kernel)
05:30:39 <Janni> Oh, well, I realised, I can get rid of 3 imports, because I deleted the input error checking functions
05:30:43 <wli> shapr: yes
05:31:02 <shapr> is 2.5 stable enough for a non-kernel-developer to use?
05:31:27 <wli> shapr: depends on if a driver you use broke recently
05:31:32 <shapr> oh
05:35:57 <wli> shapr: the kernel is never really stable, it's mostly "when are certain risks allowed to be taken?" and "which subset of the drivers works (including compiling!) this release?"
05:36:19 <shapr> that makes sense for development versions.
05:36:36 <wli> shapr: basically areas that affect everyone all the time are the bits that get new changes during a development version
05:36:43 <wli> gcc -O    -c sgmlverb.c -o sgmlverb.o
05:36:43 <wli> <stdout>:524:25: macro "yywrap" passed 1 arguments, but takes just 0
05:40:42 <wli> make[1]: Entering directory `/share/projects/kernel/hacking/holomorphy/ghc/ghc5-5.02.2/ghc/docs/set'
05:40:42 <wli> make[1]: *** No rule to make target `maintainer-clean'.
05:40:58 <shapr> scary
05:41:16 <shapr> I just checked out the fptools tree and did configure && make in there
05:41:28 <shapr> of course.. it didn't work the first seven or eight times...
05:43:29 <Janni> Yah! I did it! Who's da m4n, who's d4 M4n!!!11
05:43:31 <Janni> import Random;import List;d=map digitToInt;p=putStrLn;h s i=['*'|(x,y)<-p,x==y
05:43:31 <Janni>  ]++replicate(l t-l(t\\j))'+'where(j,t)=unzip[(x,y)|(x,y)<-p,x/=y];p=zip i s
05:43:31 <Janni> m=sequence[randomRIO(1::Int,6)|_<-[1..4]]>>=n 0>>= \x->p$"Tries: "++show x;
05:43:31 <Janni> l=length;n a s=do i<-getLine;if d i==s then return a else p(h s$d i)>>n(a+1)s
05:43:41 <shapr> Janni: nifty!
05:43:54 <Darius> Sam's da man!
05:44:00 <Janni> Exactly ;)
05:44:46 <Janni> If anybody tries out that program, use hugs. The input should be 4 characters of digits per line
05:45:16 <Janni> Err... the digits between 1 and 6
05:46:25 <Janni> Output: Every '*' is a correct guess at the correct position. Every '+' is a character occuring somewhere else. The output doesn't have any order
05:46:49 <Darius> makes me want to tinker on my 256 byte raytracer.  I could cut off a significant chunk if I give up the dream of some extensibility.
05:47:02 <Janni> Err.. and "m" is the main function
05:47:25 <Marvin--> Janni: isn't it required that it should be called 'main'?
05:47:37 <Darius> It's run in an interpeter
05:47:57 <Marvin--> oh, it requires hugs
05:48:02 <Marvin--> (or you'd need to import Char as well)
05:48:18 <Janni> Marvin: I just renamed 'm' as 'main'. Then the line takes exactly 78 characters
05:48:49 <Marvin--> Janni: if it should work in ghci, you need import Char too
05:49:35 <Darius> you can cut off a space between >>= \x->p$"Tries...
05:49:39 <Marvin--> what's it supposed to do anyway? :)
05:49:48 <Janni> I know. Trying to get in in there
05:49:58 <Janni> Marvin: Do you know the mastermind game?
05:50:03 <Janni> Darius: No, doesnt' work then
05:50:07 <Marvin--> Janni: aha, yes
05:50:21 <Darius> It doesn't?
05:50:28 <Darius> oh
05:52:09 <Marvin--> Tries: 4
05:52:15 <Marvin--> bah, damn typo, or it would've been 3
05:52:36 <Janni> Yes, with hugs, you can't use backspace
05:53:13 <Janni> And the program doesn't do input error detection. takes too much space
05:53:20 <Marvin--> :)
05:55:25 <Janni> It'd be just "import Random;import List;d=map digitToInt;p=putStrLn;h s i=['*'|(x,y)<-p,x==y
05:55:25 <Janni>  ]++replicate(l t-l(t\\j))'+'where(j,t)=unzip[(x,y)|(x,y)<-p,x/=y];p=zip i s
05:55:25 <Janni> m=sequence[randomRIO(1::Int,6)|_<-[1..4]]>>=n 0>>= \x->p$"Tries: "++show x;
05:55:25 <Janni> l=length;n a s=do i<-getLine;if d i==s then return a else p(h s$d i)>>n(a+1)s
05:55:28 <Janni> oops
05:55:42 <Janni> This would be the input correction: "if l i==4&&any(inRange('1','6'))i then p"Invalid input">>n a s else ..."
05:56:00 <Janni> s/correction/error detection/
05:56:13 <Marvin--> nahhhh, too obvious
05:56:31 <Darius> bah, my raytracer uses code as constants.  (that makes it a real pain to change -anything-)
05:56:33 <Marvin--> let c = chr and use that to convert from ints instead :-)
05:56:37 <wli> hmm
05:57:06 <Darius> m=mapM (\x->randomRIO(1::Int,6) [1..4] seems a few chars shorter
05:57:16 <Darius> er add a )
05:57:19 <Janni> Marvin: I'd have to import Char then
05:57:30 <Darius> and you can probably remove some whitespace
05:57:34 <Janni> Darius: yes, cool
05:57:48 <Darius> uh, and test that it works ;)
05:57:49 <Marvin--> Janni: in non-hugs you still need it :-/
05:57:54 <Marvin--> Janni: this code isn't haskell98
05:58:11 <Darius> It may need Monad though :(
05:58:12 <wli> aha
05:58:22 <wli> ghc/docs/set/ is empty
05:58:23 <Janni> OK. Maybe after using Darius' solution I'll get "import Char" in there
05:58:36 <Marvin--> mapM is in the Prelude
05:58:36 <Janni> Then it'd be Haskell98, wouldn't it?
05:58:41 <Marvin--> yes
05:59:29 <Darius> set is Edison I think.  You can find the docs on the GHC site, but Edison isn't maintained anymore (at least under that name)
05:59:50 <wli> well the emptiness of the dir is causing build failure
06:00:35 <wli> fixed it by dropping a mostly-empty makefile in there
06:02:26 <Janni> Darius: You save 4 characters :)
06:02:31 <Janni> s/save/saved
06:02:55 <Darius> z|z@(x,y)<-p,x/=y -- 2 more
06:03:41 <dennisb> Janni: Nice program!
06:03:53 <Janni> Ah, yeah. Didn't think about that syntax element. thx :)
06:04:03 * dennisb just played a couple of times
06:04:19 <Janni> Dennisb: The normal/nice version will be a lambdabot module
06:04:25 <dennisb> you can drop the ::Int also, it should default to Int, shouldn't it
06:04:41 <Darius> Integer is the default default
06:04:50 <dennisb> It works, but I'm not sure if it's defaulting or some other thing forcing it
06:05:00 <Janni> Ah yes, didn't work before. But now after some changes...
06:05:49 <wli> Janni: what's it do?
06:05:59 <Janni> wli: Mastermind game
06:06:23 <Janni> I wrote how to use it a few "pages" above
06:06:58 <Marvin--> oh my god, I'd forgotten how much fun this game is
06:07:06 <Marvin--> just using 1-6 is kinda weenie though, use 1-9 :-)
06:07:09 <elmex> ghc-cvs doesn't compile
06:07:34 <elmex> i give up
06:07:55 <Darius> *sigh* GHC ran out of memory.  Oh well, I have memory and CPU for SC2 now
06:08:10 <wli> things look like they're getting further now
06:11:12 <shapr> g'day Cowgirl 
06:11:36 <Cowgirl> hey
06:11:40 <Cowgirl> how are u :)
06:11:46 <shapr> doing well, how are you?
06:11:52 * o3 scratches head
06:12:04 <o3> has anybody played around with "Tcon Arrow" in template haskell?
06:12:20 <Cowgirl> not bad,  little tired...worked
06:12:27 <Cowgirl> heading off to bed soon
06:12:51 <Cowgirl> u got ur work done??
06:13:02 <Darius> o3: I probably have.
06:13:25 <o3> Darius: i'm trying to get a declaration working, and it's not.  *puzzled*
06:13:40 <shapr> Cowgirl: nah, not yet, getting close. Make any progress with XEmacs?
06:14:04 <Cowgirl> no,  think i have given up on that, tried a few things, but still no colors!
06:14:09 <o3> Darius: it's giving me a
06:14:10 <o3> "Type constructor or class not in scope: `->'
06:14:13 <o3> error
06:14:16 <wli> make: *** genapply: No such file or directory.  Stop.
06:14:20 <o3> when i try to use (Tcon Arrow)
06:15:16 <Lilith> Cowgirl: Options->Syntax Highlighting?
06:15:38 <Cowgirl> tried that....still nothing
06:15:53 <Cowgirl> only thing that changes color is " " anything in them is green
06:15:54 <Cowgirl> and thats it
06:15:56 <shapr> the problem with Cowgirl's XEmacs is that it can't find haskell-mode.el
06:16:12 <shapr> Cowgirl: have you searched your drive for haskell-mode.el ?
06:17:37 <Cowgirl> just do find.....haskell??
06:17:41 <Cowgirl> i'll try now
06:17:51 <shapr> look for a file named haskell-mode.el
06:17:57 <wli> I wonder if there will be an editor written in Haskell
06:18:15 <shapr> I'd love to work an emacs written in Haskell
06:18:47 <Cowgirl> found haskell-mode.el
06:18:49 <Cowgirl> in.....
06:18:56 <shapr> Michael Sperber wrote some scheme code to automatically port elisp to maintainable scheme (with one limitation) and Ashley Yakeley wrote HScheme, a scheme interpreter in Haskell
06:18:58 <Lilith> wli: i think there is one somewhere
06:19:07 <Cowgirl> C:\Program Files\XEmacs\lib\xe...\haskell-mode-1.44
06:19:26 <Cowgirl> Lilith...that was a bad idea going in the compsoc room
06:19:28 <Cowgirl> did u read it?
06:19:50 <o3> Cowgirl: download the ghci4xemacs installer
06:20:04 <shapr> o3: there is one of those?
06:20:14 <Darius> o3: it's only a problem if you splice, right?
06:20:19 <wli> WARNING: error while reading directory ndpFlatten
06:20:20 <wli> main/HscMain.lhs: can't locate import `Flattening'
06:20:24 <o3> Cowgirl: http://www.cse.unsw.EDU.AU/~andrep/ghci4xemacs/GHCI4XEmacs-1.05.exe
06:20:24 <Cowgirl> i got that somewhere
06:20:36 <shapr> wli: oh that's in HEAD now?
06:20:37 <o3> if it doesn't work, tell me
06:20:42 <shapr>  I must update!
06:20:48 <Lilith> Cowgirl: yeah
06:20:49 <wli> shapr: what is it?
06:21:05 <shapr> wli: the data parallel array flattening code
06:21:12 <shapr> it's been in a branch forever
06:21:17 <Cowgirl> Lilith....was i wrong to ask there for help?
06:21:22 <o3> Darius: yep, that's right
06:21:54 <Lilith> Cowgirl: not really. they just didn't like answering questions regarding your code. 
06:22:19 <Lilith> Cowgirl: and they're not very friendly tonight. (not that they are usually friendly in the first place)
06:22:25 <o3> Darius: i suspect a ghc bug
06:22:27 <shapr> wli: at some point the ndp code will allow transparent data parallelization via SMP or MPI
06:22:52 <shapr> right now it only does the array flattening transformation (via warm fusion I think?)
06:22:56 <Cowgirl> Lilith are u a tutor??
06:22:57 <Darius> o3: that's what I'm leaning toward.  It seems obvious what is wrong
06:23:11 <wli> shapr: well ndpFlatten is empty atm
06:23:17 <Lilith> Cowgirl: no
06:23:19 <shapr> ah, ok
06:23:29 <Cowgirl> what do u do at unsw then??
06:23:30 <shapr> I tutor myself all the time ;-)
06:23:31 <wli> shapr: and the compile is barfing b/c something's trying to import a Flatten module
06:23:37 <shapr> wli: that sucks :-(
06:23:40 <o3> Darius: obvious?  8)
06:24:10 <wli> oh
06:24:12 <wli> I need ways
06:24:21 <shapr> maybe another ndp release is planned for HW
06:24:24 <shapr> that would be spiffy
06:24:40 <Lilith> shapr: i don't know that self tutelage counts ;-)
06:24:41 <Darius> o3: It seems that internally -> isn't qualified as "GHC.->" or "GHC:->" or "GHC.Base:->" or whatever.
06:25:00 <o3> Darius: oh.  would it be possible just to fix it by editing THSyntax or DsMeta?
06:25:05 <Lilith> bah. cvs problems
06:25:31 <shapr> @wn1913 tutelage
06:25:32 <lambdabot> Sorry, I don't know the command "wn1913", try "lambdabot: @listcommands"
06:26:01 <shapr> @web1913 tutelage
06:26:04 <lambdabot> *** "Tutelage" web1913 "Webster's Revised Unabridged Dictionary (1913)"
06:26:06 <lambdabot> Tutelage \Tu"te*lage\, n. [L. tutela protection, fr. tutus safe,
06:26:08 <Darius> o3: it would be DsMeta not THSyntax.  It may not be that, I'm going to try some things.
06:26:08 <lambdabot>    fr. tueri to watch, defend. Cf. {Tuition}.]
06:26:10 <lambdabot>    1. The act of guarding or protecting; guardianship;
06:26:12 <lambdabot>       protection; as, the king's right of seigniory and
06:26:14 <lambdabot>       tutelage.
06:26:14 <shapr> wow, that's a real word.
06:26:18 <Janni> Yay! _Finally_ I got it into 4 lines a 78 characters. Phewww! :)
06:26:18 <shapr> I learned something.
06:26:18 <lambdabot>             The childhood of the European nations was passed
06:26:18 <Janni> import Random;import List;import Char;main=mapM(\x->randomRIO(1,6))[1..4]>>=n
06:26:19 <Janni>  0>>= \x->p$"Tries: "++show x;d=map digitToInt;p=putStrLn;h s i=['*'|(x,y)<-p,
06:26:19 <Janni>  x==y]++replicate(l t-l(t\\j))'+'where(j,t)=unzip[z|z@(x,y)<-p,x/=y];p=zip i s
06:26:19 <Janni> l=length;n a s=do i<-getLine;if d i==s then return a else p(h s$d i)>>n(a+1)s
06:26:20 <lambdabot> [there's @more]
06:26:36 <shapr> Lilith: nifty word
06:26:45 <Janni> Now it's Haskell98 compliant and compiles with ghc...
06:26:55 <shapr> and no one can read it ;-)
06:26:56 * Janni smacks Darius on the cheek ;)
06:27:06 <o3> Darius: thanks
06:27:08 <wli> shapnr: know of a list of ways?
06:27:14 <shapr> wli: huh?
06:27:24 <shapr> ways?
06:27:27 <Janni> shapr: That's the purpose. It could be even worse (but only a little bit)
06:27:52 <wli> shapnr: WAYS = p (which I don't care about too much)
06:27:56 <Darius> wli: look in the .mk files.  I think config.mk has info
06:28:13 <Darius> wli: there are a bunch, like 10
06:28:30 <shapr> oh, the .mk stuff
06:28:43 <shapr> I went for "careful" rather than "speedy"
06:28:50 <shapr> but I don't remember the process.
06:29:27 <Darius> I went for speedy compile though with -O (no p way, I'm not building it twice! [or rather 4 times!])
06:29:34 <Lilith> shapr: i meant "   3.  The state of being under the direction of a guardian or tutor."
06:29:50 <Lilith> (dictionary.com)
06:30:02 <wli> okay added s in there for SMP threads
06:30:17 <shapr> @wn tutelage
06:30:19 <lambdabot> *** "tutelage" wn "WordNet (r) 1.7"
06:30:19 <lambdabot> tutelage
06:30:19 <lambdabot>      n 1: teaching pupils individually (usually by a tutor hired
06:30:19 <lambdabot>           privately) [syn: {tuition}, {tutorship}]
06:30:19 <lambdabot>      2: attention and management implying responsibility for safety;
06:30:22 <lambdabot>         "he is under the care of a physician" [syn: {care}, {charge},
06:30:23 <lambdabot>          {guardianship}]
06:31:02 <shapr> the DictModule is fun
06:31:45 <Darius> o3: what does your generated declaration pretty-print as?
06:32:53 <Lilith> hmm. i've got an old tree of fptools. i wonder why cvs has issues updating it
06:32:59 <o3> Darius: good question.  i'll get back to you in a few minutes -- finishing a game of tetrinet right now :D
06:33:16 <Lilith> hehe
06:33:24 * Lilith whaps o3
06:34:03 <Lilith> not that i should talk, since i've been nethacking
06:34:50 <Darius> dammit, I need to pl... uh, test (yes, that's it), test SC2 already
06:35:23 <shapr> SC2?
06:35:28 <shapr> starcraft 2?
06:35:41 <shapr> I've been invited to play warcraft III today
06:35:44 <Lilith> Darius ;)
06:35:45 <shapr> but I have to finish this code first :-/
06:35:50 * shapr hacks quickly
06:35:55 <Darius> Psh.  A game much better than StarCraft 2 could ever be.
06:36:07 <shapr> I can't seem to figure out how to work the modifyNode function
06:36:14 * shapr gets frustrated
06:36:35 <Smerdyakov> Play instead: Worms: Armageddon!
06:36:41 <Cowgirl> how do i run ghci in xemacs??
06:36:48 <Cowgirl> i have moved on from color coding...im over it!
06:37:07 <shapr> Cowgirl: if you have haskell-mode.el loaded, and your buffer is in haskell-mode, just C-c C-l
06:37:11 * shapr makes a screenshot
06:37:20 <o3> dammit
06:37:21 <o3> one more game
06:37:25 <o3> i've lost about 7 in a row
06:37:50 <Lilith> heh
06:37:55 <Lilith> hmm
06:38:01 <Lilith> why is it taking such a long time
06:38:06 * Lilith whaps cvs
06:38:59 <shapr> ghci screenshot --> http://kungens.kemi.fi/~shae/ghcisshot.png
06:39:11 <shapr> and yes, I'm aware how most people love my XEmacs color-theme
06:39:33 <Cowgirl> bugger that to!
06:39:50 <shapr> I doubt XEmacs would appreciate that.
06:39:58 <Cowgirl> lol
06:40:24 <Lilith> shapr: ugh. :-)
06:41:17 <Marvin--> shapr: good god
06:41:24 <shapr> Cowgirl: did you search your drive for a file specifically named haskell-mode.el ?
06:41:36 <Cowgirl> yeah
06:41:40 <Cowgirl> found it
06:41:48 <wli> I could probably do a Haskell clone of ed(1) in a couple of hours.
06:42:17 <shapr> Cowgirl: ok, try M-x load-file <enter> C:\program files\xemacs\lib (wherever the file is) <enter>
06:42:24 <shapr> that might manually load the elisp file
06:42:27 <shapr> I hope so
06:42:48 <Darius> main = mfix (getLine>>putStrLn "?">>)
06:42:49 <shapr> the problem is your load-path, but I can't figure out exactly what's wrong
06:42:55 <shapr> Darius: hehe
06:42:56 <wli> okay something is actually trying to use Flattening.lhs
06:43:30 <shapr> Darius: oh this time I took your advice about captioning the screenshot
06:43:35 <o3> phooey!
06:43:53 <Darius> o3: what (->) -> a b?
06:44:02 <Darius> or you lost again?
06:44:10 <o3> no, i lost again :(
06:44:12 * shapr snickers
06:44:24 <o3> she had three switch fields, about five blockquakes, a few bombs ... no fair
06:44:39 <o3> anyway :)
06:44:40 <o3> back to this
06:45:28 * Darius looks at screenshot.
06:45:39 <Darius> shapr: you've really gotta listen to something else.
06:46:06 * shapr laughs
06:46:11 <shapr> yah yah
06:46:26 * o3 looks and screenshot and goes colourblind
06:46:29 <o3> s/and/at/
06:46:32 * shapr snickers
06:46:38 <shapr> no one likes my color-theme :-)
06:48:26 <o3> Darius: 
06:48:26 <o3> *PrintFTH> pprDec pfthd
06:48:27 <o3> Loading package haskell98 ... linking ... done.
06:48:27 <o3> Loading package haskell-src ... linking ... done.
06:48:27 <o3> foreign import ccall unsafe "printf" printF :: CString (->) Int
06:48:39 <o3> (don't ask about the function :)
06:48:55 <Cowgirl> shapr, says it loaded it
06:49:16 <shapr> Cowgirl: yay, now try M-x haskell-mode on a .hs file
06:49:42 <shapr> any improvement?
06:49:54 <Darius> o3: Hmm, how do you build CString (->) Int?
06:50:21 <wli> is there a Haskell curses binding yet?
06:50:35 <shapr> several, but not a generalized one that I know of
06:50:45 <shapr> would be a good idea though
06:50:48 <wli> shapr: oh? what's not generalized?
06:50:50 <o3> Darius: /msg'ing
06:51:01 <shapr> wli: I think I've seen or heard of seven different curses bindings
06:51:07 <shapr> usually for a specific application
06:52:22 <Cowgirl> says it cant open it!!
06:52:25 <Cowgirl> haskell-mode
06:52:37 <o3> Cowgirl: did you try installing ghci4xemacs?
06:52:56 <wli> shapr: one thing that kind of sucks about the C curses stuff is that it's not threaded _at all_
06:53:00 <Cowgirl> it says it cant find xemacs
06:53:05 <Cowgirl> but i put it in the directory
06:53:17 <o3> what version of xemacs are you using?
06:53:41 <Cowgirl> 21.4
06:53:43 <wli> shapr: if I knew anything about the stuff I'd suggest some kind of interpretation of termcap/terminfo in Haskell itself
06:55:54 <shapr> Cowgirl: something seriously weird happening there, it sounds like you've loaded the haskell-mode file, and yet, it can't find it...
06:56:14 <Cowgirl> we'll just leave it
06:56:24 <Cowgirl> cause my sanity is going out the window!!
06:56:33 <shapr> and in the linux ;-)
06:56:46 <Cowgirl> :)
06:56:49 <Cowgirl> i got to get linux
06:56:59 <shapr> linux - windows = sanity
06:57:05 <shapr> orsomething like that
06:58:29 <o3> Cowgirl: grab the latest version of xemacs, as suggested by the ghci4xemacs installer
06:59:39 * Lilith wonders about shapr's equation
07:00:22 <shapr> I would also suggest installing into c:\xemacs\ or so, it's much easier to deal with directories without spaces and with names less than 8 chars long (for windows at least)
07:00:37 <Darius> linens - windows = cold winter nights
07:00:38 <shapr> Lilith: ok, what about "user + linux - windows = sanity" ?
07:00:48 * shapr shivers
07:01:14 <wli> if the terminfo format were documented somewhere that would be a good start
07:01:17 <Marvin--> yay, I managed to fix a bug in cdebconf by reading the perl debconf source
07:03:33 <wli> basically all it is is a list of the movement and character whatever primitives available to work with
07:04:57 <wli> the genapply stuff looks like it all got removed codewise but not from the build system
07:05:31 * shapr wishes he could bind the venetian blinds to an emacs keybinding
07:10:06 <wli> Prologue junk?: sgJC_ret:
07:10:06 <wli>         movl    $0, (%esp)
07:10:06 <wli>         movl    $0, 4(%esp)
07:10:12 <wli> I think I'm in trouble =)
07:11:59 <shapr> yow
07:12:13 <shapr> @yow
07:12:14 <lambdabot> Tex SEX!  The HOME of WHEELS!  The dripping of COFFEE!!  Take me
07:12:14 <lambdabot>  to Minnesota but don't EMBARRASS me!!
07:19:56 * shapr bounces happily
07:20:45 <wli> you know what
07:20:48 <shapr> what?
07:20:56 <shapr> it compiled?
07:21:01 <wli> that's garbage code emitted by the supposedly stable ghc that's being used to bootstrap the stuff
07:21:10 <shapr> yikes
07:21:47 <wli> I think it's safe to say I've banged my head against HEAD and lost.
07:21:58 * shapr grins
07:24:19 <wli> the point of the exercise was to get a recent enough version of ghc to compile the HToolkit bits with
07:24:33 <shapr> oh
07:24:38 <shapr> in that case, you can use the ghc5 debs
07:24:51 <wli> They're ghc5.02
07:25:05 <shapr> the ones from unstable should work
07:25:11 <shapr> they're 5.04.2
07:25:34 <wli> hmm
07:25:40 <wli> testing only has 5.02
07:25:45 <wli> it _should_ be more recent
07:34:40 * shapr bounces
07:37:17 <Darius> hey look what I found in the logs picking a random day (3.04.18):
07:37:17 <Darius> 08:47:00 <shapr> hroptatyr: I'll fix the @fact module to use a flat file tomorrow
07:37:29 <shapr> yah yah ;-)
07:37:51 <shapr> I shouldn't give hard fast deadlines for my fun code
07:38:08 <Vincenz> eurgh, my head
07:38:24 <shapr> Vincenz: too many side-effects? ;-)
07:38:28 * shapr grins
07:38:44 <Vincenz> too many beers and a long island ice tea to finish off
07:38:59 <shapr> see what side-effects will get you?
07:39:05 <Vincenz> side-effects?
07:39:20 <shapr> if your beer had referential transparency....
07:39:42 <Vincenz> oh
07:39:51 * Vincenz JUST gets what you mean by side-effects
07:39:54 * shapr grins
07:40:03 <Vincenz> now you see how bad it is to drink too much and go to sleep at 10 am
07:40:08 <shapr> yas
07:40:09 <shapr> yes
07:40:37 <Vincenz> no, I stayed out till 6 am, reasonable hour
07:43:47 <Riastradh> shapr, no beverage has referential transparency: your stomach will always have to be mutated.
07:45:06 <shapr> it's true
07:45:20 <Vincenz> nothing in this world has referential transparency
07:45:55 <Riastradh> What about the Lambda-Calculus?
07:46:04 <Vincenz> I was speaking OF THIS WORLD
07:46:08 <Vincenz> tangible things
07:46:27 <Marvin--> Vincenz: spoilsport
07:46:30 <Riastradh> Are all forms of mathematics, and philosophy, and psychology, and things like that all intangible?
07:46:39 * kawfee bounces
07:46:44 <Vincenz> they're a) not of this world b) not tangible c) human inventions
07:46:57 <Vincenz> they're cleaned up isomorphisms of this world which is too icky to handle
07:47:40 * shapr splashes
07:49:21 * Vincenz 's philosophy side comes up as he wakes from the headache slumber of alcohol
07:49:53 <wli> shapr: did you say --enable-threaded-runtime-system breaks opengl?
07:50:12 <Vincenz> nvidia drivers are not thread-safe
07:50:12 <Vincenz> meaning
07:50:33 <Vincenz> if differennt threads use opengl, you have to make sure yuo synchronize it yourself, or at times your card may hang as long as 12 seconds
07:50:34 <Vincenz> !
07:51:20 <Vincenz> mileage may vary
07:51:34 <Vincenz> so I assume that by enabling threaded runtime system, this stuff will happen
07:51:50 <wli> I haven't the foggiest idea.
07:51:57 <wli> I don't intend to actually use the OpenGL bits
07:52:35 <shapr> wli: yes, --enable-threaded-runtime-system breaks HOpenGL
08:04:20 <wli> 5.04 is dying with the same error
08:07:57 <wli> well one really easy thing to do is to collect the terminfo 
08:08:05 <wli> then know what the basic operations are
08:08:47 <wli> then implementing slightly higher-level operations on top of them in ways that depend on what's available
08:09:34 <wli> I can probably get away with relatively low-level stuff.
08:10:52 <wli> I know vt100 codes
08:11:16 <wli> so Prologue junk?: sgHw_ret:
08:11:16 <wli>         movl    $0, (%esp)
08:11:16 <wli>         movl    $0, 4(%esp)
08:11:53 <kawfee> wli: hi
08:13:14 <shapr> no idea what that means
08:13:32 <wli> it's confused about function prologues
08:13:47 <wli> probably some optimization options I gave it that confused it
08:14:54 <wli> doh
08:14:59 <wli> I already wrote some chunks of it
08:15:19 <shapr> of the curses binding?
08:15:36 <wli> shapr: no, low-level terminal control stuff
08:17:47 <wli> shapr: if I write a driver interface and a vt100 driver do you think ppl would be able to do things with it?
08:18:58 <ddarius> you know you are a coder to a pathetic degree when you're entertained by your -own- comments.
08:20:44 <shapr> wli: I don't know
08:21:06 <shapr> I know many people show up here wanting a standardized curses binding
08:21:25 <wli> e.g. class Monad m => VT m t where { vtGetSize t :: m (Int, Int) ; vtSetSize t Int Int :: m () ; vtSeek t Int Int :: m () ; vtGetChar :: t -> m Char ; vtPutChar t Char -> m () ; vtGetAttr :: t -> m VTAttr ; vtSetAttr t VTAttr -> m () }
08:21:58 <wli> okay
08:22:04 <wli> 5.04 looks hopeless
08:23:17 <Riastradh> ddarius, it's the hackers' syndrome of hating every other programmers' code -- including your own code that you wrote six months ago.
08:23:29 <Riastradh> Except in this case it's finding every other hackers' comments amusing.
08:24:16 <shapr> that's a hackers' syndrome?
08:24:28 <shapr> I surely hate code I wrote more than six months ago.
08:24:47 <shapr> it's so obvious how it could be improved.
08:25:02 <ddarius> 7 months (Oct 13.) 
08:25:09 <shapr> aha
08:25:47 <elmex> well, and what to do about my broken ghc build?
08:25:52 <ddarius> And it certainly isn't obvious how it could be improved without rewriting the whole thing, in which case it is.  The code itself is humorous, if you're twisted like me.
08:26:04 * shapr grins
08:26:43 <ddarius> The code is both horrible and wonderful.
08:32:03 <elmex> why can't i build ghc cvs ? i updated it just some hours ago...
08:32:53 <shapr> ghc cvs doesn't always work
08:33:00 <elmex> well, never?
08:33:07 <wli> I discovered that quickly
08:40:03 <elmex> but but... i want ghc from cvs *waaaa* *sob*
08:40:16 <shapr> yah, I understand
08:40:21 <shapr> but I don't have a good solution :-/
08:40:28 <shapr> elmex: I just tried every few days until one built
08:40:32 <shapr> now I'm holding onto it for dear life 
08:40:36 <shapr> mine mine!
08:40:48 <shapr> hi duffy666 
08:40:55 * elmex sobs
08:40:56 <duffy666> hi all :)
08:40:59 * Darius is building a new one. My old one is like a month old.
08:41:33 <duffy666> i wrote my first lines of haskell yesterday. i love it :)
08:41:49 <elmex> yea
08:41:57 <elmex> lambdabot: @karma+ haskell
08:41:58 <lambdabot> haskell's karma has been incremented.
08:42:15 <Darius> I more or less immediately stopped programming C++ after I started Haskell.
08:42:27 <Darius> @karma lambdabot
08:42:27 <lambdabot> lambdabot has a karma of 1
08:42:34 <elmex> @karma elmex
08:42:34 <lambdabot> You have a karma of 1
08:42:38 <elmex> :((
08:42:46 <elmex> !!
08:43:34 <elm3x> @karma+ elmex
08:43:34 <lambdabot> elmex's karma has been incremented.
08:43:36 <shapr> heh
08:43:45 <elm3x> @karma+ elmex
08:43:45 <lambdabot> elmex's karma has been incremented.
08:43:48 <elmex> =-))
08:44:04 <elmex> @karma elmex
08:44:05 <lambdabot> You have a karma of 3
08:44:09 <elmex> *happy*
08:44:31 <duffy666> Which editor do you use? The thing is... i dont like XEmacs...
08:44:37 <Darius> I use vim
08:44:39 * Riastradh uses Emacs.
08:44:47 <elmex> I use vim
08:44:49 <Riastradh> GNUmacs, that is.
08:44:58 <elmex> lambdabot uses vim too
08:45:07 <elmex> duffy666: use joe ;)))
08:45:13 <Darius> or ed!
08:45:16 <shapr> xemacs!
08:45:17 <lambdabot> No I don't, you dolt, elmex!
08:45:22 <shapr> I luv XEmacs!
08:45:24 <duffy666> k. i use MED :)
08:45:30 <elmex> use sex
08:45:38 <shapr> XEmacs is even my irc client.
08:45:50 <lambdabot> I really use Haskell's IO module to do all my editing.
08:46:00 <shapr> that bot is smarter than I am
08:46:06 <Janni> Oh, I thought shapr was using a Unix-like OS...
08:46:24 <shapr> Janni: Linux a library that emacs uses to communicate with Intel hardware.
08:46:25 <Riastradh> Who needs UNIX when you've got Emacs?
08:46:27 * shapr grins
08:47:02 <Darius> Riastradh: Indeed. (Why Darius uses vim)
08:47:22 <shapr> I've had so much fun customizing emacs that I now have 1347 lines of startup files.
08:47:34 <duffy666> *argh*
08:48:17 <shapr> on the good, side I seriously doubt any other irc client has Haskell source support
08:48:25 <Janni> shapr: _Now_ I understand, why you need 4 Pentium 4s...
08:48:47 <shapr> :-P
08:49:04 <Janni> How long does Emacs take to boot?
08:49:12 <shapr> hey, I have just barely over 200 files open right now
08:49:32 <shapr> Janni: several seconds actually
08:49:59 <shapr> but then, it's opening all the files I had open before, checking my mail, connecting to irc, opening the emacs shell, etc etc
08:51:53 <duffy666> , cooking coffee, sending flowers to your girlfriend, paying your phonebill.... ;)
08:52:29 <shapr> actually, emacs can do some very complex math
08:52:39 <shapr> taylor series, complex derivatives, etc
08:52:40 <Darius> In fact, shapr is just a large set of scripts in XEmacs.
08:52:48 <shapr> no! I've been discovered!
08:53:14 * shapr quickly ports the elisp engine to run on raw NUMA hardware and buys a 64 CPU machine
08:53:46 <wli> shapr: how's that look?
08:53:52 <wli> shapr: should be enough to build things on
08:54:08 <shapr> what, 64 cpus?
08:54:14 <wli> shapr: no
08:54:17 <shapr> it'd be great if the elisp engine were multi threaded :-|
08:54:23 * shapr grins
08:54:48 <shapr> wli: how does what look?
08:55:11 <wli> *** Sent DCC SEND request (VT.hs 1252) to shapr
08:57:15 <wli> woops
08:57:16 <wli> mistitled
08:57:40 <wli> hmm
08:57:48 <wli> I can probably do better
08:59:18 <wli> shapr: the basics are set the attributes, seek to positions, and squirt out characters
08:59:59 <shapr> sounds useful
09:00:13 <wli> shapr: this is generalizable
09:00:49 <wli> shapr: one can write special drivers for different terminal types to do these things more efficiently (actually you'd need to enrich things to make it more efficient)
09:00:54 <wli> shapr: _or_
09:01:18 <wli> shapr: you can have a complex layer with the commands assembled from terminfo data on the fly
09:01:19 <ham[let]> can anyone explain to me the idea of an arrow category?
09:01:58 <shapr> commands assembled on the fly would be very nifty
09:02:02 <wli> shapr: I basically am totally uninterested in efficiency; I just want something I can hide behind and say "sure, this could work on more tty's than that"
09:02:14 <wli> shapr: well, assembly on the fly is the way terminfo works
09:02:21 <Janni> part * bbl
09:03:06 <wli> shapr: there are a buttload of "capabilities" or "attributes" the things can have that need a lot of special casing
09:03:22 <Darius> The objects are arrows, the arrows are pairs of arrows such that.  [f : A -> B] - (g:A->C,h:B->D) -> [i : C -> D]
09:03:25 <wli> shapr: for mine own part I could care less about working on a line printer =)
09:03:42 <shapr> heh
09:04:10 <Darius> I.e. an arrow in an arrow category turns some arrow in the base category into another arrow in the base category
09:04:46 <ham[let]> Darius but hmm so there is nothing really special about that
09:05:09 <ham[let]> its just a functor only applying on morphisms right?
09:10:44 <duffy666> bye all! 
09:21:38 <Darius> I don't see it as a functor.  At best it's an endofunctor or an internalization of a functor.  To show that you'd need to show the functor laws hold.
09:24:58 <Darius> A functor takes a whole category to another (possibly the same) category
09:25:20 <Darius> Any individual arrow in the arrow category would simply take a single arrow to a single arrow
09:26:27 <Darius> However, the whole arrow category together might be a way to represent what endofunctors can be built, but it likely needs more structure.
09:26:46 <Darius> Or I may just not know what I'm talking about :)
09:31:31 <Darius> You may also want to look at Comma categories which are a generalisation of the arrow category (arrow category == (Id,Id)) if I'm not mistaken
09:31:56 <Jolta> anyone watching the hockey final?
09:32:15 <Marvin--> yah
09:32:37 <Jolta> I guess alla the swedes here would be, at least. Any canadians hockey fans?
09:33:34 <Marvin--> huh, 4-4 in the sudden death? that was a rule I didn't know
09:40:05 * tmoertel needs caffiene
09:41:11 <ham[let]> Darius thx
10:03:17 <Marvin--> dang
10:09:29 <wli> well
10:09:33 <wli> IRC is kind of grotty
10:09:38 <wli> IMAP would be far cleaner
10:10:39 <wli> parsing and generating basic commands and replies seems to be the thing to do
10:10:45 <wli> and that's basically parroting the spec
10:13:42 <wli> this looks mostly like large case analysis
10:14:01 <wli> IMAP was pretty easy too
10:15:17 * tmoertel finally obtains caffiene in the form of congou keemun tea
10:15:53 <wli> shapr: IRC.hs incoming
10:22:54 <wli> geeze looking at the IRC protocol spec impresses me wrt. how crappy the protocol is
10:22:54 <tmoertel> shapr: thanks for plugging Haskell XML Toolbox!  I didn't know any Haskell-based XML toolkit had namespace support.   Woohoo!
10:27:30 <dennisb> Marvin--: I think that NHL started to use that rule this year
10:29:17 <Marvin--> dennisb: apparently they also started to use the rule that after half the match is played, no more rules will be followed
10:32:24 <dennisb> Marvin--: that is probably something in tjeckia (or whatever that country is called in english)
10:33:08 <wli> is there async DNS for Haskell yet?
10:49:00 <flippo> ArauKo is back to advertising his lame channels
10:50:43 <wli> is no one else working on protocols?
10:53:39 <wli> I wonder what the best method of dealing with protcols is
10:54:05 <wli> I think data -based stuff is the right way to go
10:54:35 <wli> i.e. something else drives the io
10:55:17 <wli> the protocol module just tries to encode/decode
10:57:43 <esap> protocols should have layered architecture.
11:14:39 <wli> esap: well most protocols are working on top of layers handled by the kernel already
11:14:45 <wli> esap: so it's mostly parsing etc.
11:15:05 <wli> parsing and message generation
11:18:22 <esap> wli: true, the lowest layer is usually something that just sends/receives raw data. The layers provide easy access to message contents (or to a whole sequence of messages).
11:18:46 <wli> esap: thing is
11:18:54 <wli> esap: protocols are basically typed
11:19:19 <wli> esap: so you get a different "tag" with each message formation
11:19:27 <wli> esap: same for replies
11:19:55 <wli> esap: you get replies of different arities and so on
11:20:10 <wli> esap: how to hide this...
11:21:17 <esap> wli: right, it depends on the pattern of usage. You should have some kind of state machine that tracks the messages. The whole state machine can provide high-level interface to whole sequences of messages.
11:21:43 <wli> esap: so large case analysis for receive side
11:21:54 <wli> esap: what about send-side?
11:22:06 <wli> esap:  different procedures for different message types?
11:22:24 <esap> wli: different procedures for different sequences of messages.
11:22:42 <wli> esap: automatic sequencing is fine sure
11:23:01 <wli> esap: but messages seem to more commonly occur one-by-one in higher-level protocolss
11:23:14 <wli> esap: e.g. IRC does PRIVMSG in one shot
11:23:50 <wli> IMAP does LOGIN in one shot
11:24:31 <esap> wli: if messages occur one-by-one, then you haven't yet gone to that high level of abstraction. The lower layers handle contents of one message (provide abstraction for that), then once the individual messages have been abstracted to very simple operations, then you start abstracting sequences of messages.
11:24:52 <wli> esap: top-to-bottom
11:24:57 <wli> esap: someone does /nick wli
11:25:04 <wli> esap: this becomes : NICK wli
11:25:11 <wli> esap: that's one shot
11:25:36 <wli> esap: /msg #haskell foo bar snoo becomes : PRIVMSG #haskell foo bar snoo
11:25:47 <wli> PRIVMSG can't span IRC packets
11:25:49 <wli> etc.
11:26:33 <esap> wli: sure, that's how the low levels work [even /nick is quite low level. Consider a bot that needs to respond to complex queries.
11:27:05 <Igloo_> It becomes PRIVMSG #haskell :foo bar snoo   doesn't it?
11:27:09 <wli> esap: what would be a complex query?
11:27:38 * shapr returns
11:27:49 <wli>     message    =  [ ":" prefix SPACE ] command [ params ] crlf
11:27:49 <wli>     prefix     =  servername / ( nickname [ [ "!" user ] "@" host ] )
11:27:49 <wli>     command    =  1*letter / 3digit
11:27:49 <wli>     params     =  *14( SPACE middle ) [ SPACE ":" trailing ]
11:27:54 <wli> : #
11:28:10 <wli> : #haskell PRIVMSG foo bar snoo?
11:28:21 <wli> no
11:28:29 <wli> : PRIVMSG #haskell foo bar snoo
11:29:18 <Riastradh> No, not that, either, wli.
11:29:35 <esap> wli: well something that interacts with end-users, like first asks someone a question, then when he replies, behaves according to the answer.
11:29:38 <wli> Riastradh: do tell
11:29:48 <Riastradh> :wli!wli@holomorphy.com PRIVMSG #haskell :foo bar snoo\r\n
11:30:01 <wli> Riastradh: looks good
11:30:33 <wli> the EBNF is b0rked
11:30:40 <Riastradh> No, it's not.
11:31:00 <wli> no
11:31:14 <wli> params wants a :
11:32:37 <Riastradh> To be a little more precise, the client sending '/msg #haskell foo bar baz' would send 'PRIVMSG #haskell :foo bar baz\r\n' to the server; the server would then send back to all the other clients in #haskell ':wli!wli@holomorphy.com PRIVMSG #haskell :foo bar baz\r\n' (if wli sent it in the first place).
11:33:10 <wli> that's fine
11:33:24 <wli> it's just the protocol
11:33:33 <Riastradh> I ask you now to explain how the EBNF is b0rken.
11:33:55 <wli> Riastradh: it isn't
11:34:04 <wli> Riastradh: I missed the : in params
11:34:10 <Riastradh> Oh, ok.
11:35:35 <shapr> tmoertel: I can't figure out how to wrap and unwrap tags
11:35:43 <shapr> tmoertel: you wouldn't happen to know how, would you?
11:36:14 <wli> stackable protocols would be good
11:36:50 <Janni> Back from dinner...
11:37:58 <shapr> wli: Arnia and I have been talking about a vaporware framework based on arrows
11:38:25 <shapr> that would allow stackable protocols, etc
11:39:20 <wli> shapr: I'm hard ehnough pressed for time I won't be able to carry out redesigns
11:39:33 <shapr> heh
11:39:57 <shapr> wli: when I'm done with my XML work, I'll have time to look at the code you've sent me
11:40:22 <wli> shapr: it's all braindead
11:41:32 <wli> shapr: the IRC bits are literally nothing more than data Foo = ... for all the numeric replies
12:07:39 * shapr bounces spamodically
12:14:08 <wli> So I'm trying to figure out how to translate ordinary language code to 3 address intermediate code
12:14:22 <wli> I'm thinking
12:14:36 <wli> the environment holds locations where intermediate results are computed
12:15:06 <wli> and as we go through a let e = exp in foo
12:15:25 <wli> we do [e/loc e]foo
12:16:56 * shapr begins to understand all the weird types floating around in HXmlToolbox
12:20:41 <wli> I foresee 3AC as a dag and 3AC after a topological sort
12:23:20 <wli> the trick comes with loops
12:24:05 <wli> it all falls down when control flow enters the picture
12:24:59 <esap> wli: is it not possible to avoid loops beforehand?
12:25:11 <wli> nope
12:26:30 <wli> at the very least understanding of loops is needed to avoid the back end (a C compiler) from barfing on tail recursion
12:29:05 <esap> wli: I usually avoid loops by first treating the whole loop as a single black box, then handle the internals of that black box using a separate mechanism that splits the loop into two parts. Might not be simple enough for your purposes though.
12:29:41 <shapr> it seems to me that functions should always be named subjectOperation stringSplit qnameModify
12:29:48 <shapr> functions like modifyQName really bug me
12:29:59 <shapr> hoi lodewijk 
12:30:10 <lodewijk> hi
12:30:15 <shapr> hoe gaat?
12:30:27 <shapr> (not that I can anything else in dutch)
12:30:34 <wli> shapr: I'm trying to be relatively thin about things
12:30:41 <lodewijk> shapr: so-so, I'm trying to understand monads :)
12:30:45 <wli> but anyway
12:30:49 <shapr> lodewijk: you and everyone else ;-)
12:31:06 <shapr> lodewijk: somedays I think I understand them, at least enough to use them easily
12:31:11 <shapr> somedays I'm just totally lost.
12:31:14 <wli> the trick is that loops arise from things that aren't written as such
12:31:56 <shapr> lodewijk: I can recommend two urls to improve your understanding of Monads...
12:32:03 <esap> wli: Can you still identify the places that generate loops?
12:32:03 <lodewijk> shapr: that would be great.
12:32:24 <wli> sorry
12:32:30 <wli> not from things that arne't written as such
12:32:42 <shapr> http://www.dcs.gla.ac.uk/~nww/Monad.html and http://www.cs.fit.edu/~satkin/monads.html
12:32:51 <wli> loops violate SSA
12:33:18 <wli> and need tailcalls to remove multiple assignment from
12:33:24 <wli> where tailcalls aren't available
12:33:29 <shapr> noel recently moved websites, so the first one takes awhile to forward
12:33:41 <wli> the same internal identifier is also used
12:33:56 * Riastradh really liked the 'What the Hell are Monads?' one.
12:34:05 <shapr> is there someway to initialize a record without having to specify empty fields?
12:34:12 <lodewijk> ah, great, the second site has examples. I have a stack of papers here with snippets of code here and there but little working code to prod and play with
12:34:25 <shapr> I'd like do Record { field = "value" } and ignore the others
12:34:57 <shapr> oh, I could start with a totally empty record like "eRecord = Record { field1 = "", field2 = "" }"
12:35:07 <shapr> and use that as a 'constructor'
12:35:08 <tic> is this type of construct possible to do inside main in the do{...} block? if (files /= []) then (data <- readFromFiles) else (data <- readFromStdin)
12:35:50 <shapr> tic: try  "data <- if (files /= []) then readFromFiles else readFromStdin "
12:36:42 <shapr> unlike other languages, things 'evaluate' in Haskell
12:37:57 <Riastradh> How do you transform
12:38:07 <tic> shapr, neat! thanks!
12:38:09 <esap> wli: my compiler project is not even close to producing intermediate code, so I guess I haven't yet got to the hard problems w/ recursion :-)
12:38:24 <wli> if files /= [] then readFromFiles else readFromStdin
12:38:37 <Riastradh> do { if (files /= []) then (data <- readFromFiles) else (data <- readFromStdin); ... }
12:38:41 <Riastradh> to a usage of >>=?
12:38:41 <shapr> tic: if you think about the stuff on the right hand side of <- it 'turns into' or the other
12:39:03 <Riastradh> do { data <- if (files /= []) then readFromFiles else readFromStdin; ... }
12:39:06 <Riastradh> transforms to:
12:39:24 <Riastradh> (if (files /= []) then readFromFiles else readFromStdin) >>= \data -> do ...
12:39:30 <tic> aha.
12:39:31 <tic> thanks.
12:39:44 <wli> esap: well
12:39:51 <Riastradh> ...while what you were trying to do can't transform to a usage of >>=.
12:40:02 <wli> esap: I'm generally ignoring syntax
12:40:05 <tic> Riastradh, yeah.
12:40:22 <wli> esap: I just define the AST as a data type and forget about it
12:40:36 <tic> Riastradh, assignment in programming class; I usually code Python.
12:40:49 <wli> esap: I'm mostly shooting for a "cleaned up C" with sane syntax and a module calculus
12:41:07 <Riastradh> tic - Well, duh -- there's your problem: your being used to Python!
12:41:20 <esap> wli: heh, I've been designing the AST for a long time now. I have quite strict requirements for it though.
12:41:46 <tic> Riastradh, yeah, I know. :)
12:41:55 <tic> Riastradh, still, that's better than being used to C ;)
12:41:59 <wli> esap: different
12:42:12 <Riastradh> tic - Yeah, but not that much better.
12:42:17 <shapr> I came from Python to Haskell.
12:42:20 <wli> esap: I define AST as the source language and make up hte syntax later
12:42:29 <tic> I was tutored by the great J. Hughes! :)
12:42:35 <shapr> tic: seriously?
12:42:50 <Riastradh> Did he teach you about arrows?
12:42:58 <shapr> yah, I was gonna ask that
12:43:03 <esap> wli: Well, my approach is more like I first do the AST and the type checker, then think about syntax.
12:43:10 <tic> Rafterman, nope.
12:43:13 <tic> shapr, yeah
12:43:15 <shapr> I want an arrows mailing list so I can ask stupid questions and get answers
12:43:16 <tic> he's a prof at Chalmers 
12:43:22 <shapr> as it is, I just have stupid questions.
12:43:29 <wli> esap: not so far from what I'm doing
12:43:34 <Riastradh> shapr, tell Hughes to come here.
12:43:39 <shapr> Riastradh: I have! several times!
12:43:40 <tic> maybe I'll learn about arrows in the Advanced Functional Programming clas.s
12:43:41 <tic> class.
12:43:45 <wli> esap: concrete syntax isn't even in the picture yet
12:43:51 <shapr> he's replied "I really need to visit there"
12:43:54 <shapr> but it hasn't happen.d
12:43:57 <Riastradh> tic - Where's this 'Chalmers' thing?
12:44:01 <tic> what are arrows anyway? I read a paper by Hughes, but wouldn't understand.
12:44:07 <Riastradh> Darn.
12:44:09 <tic> Riastradh, Chalmers University of Technology in Gothenbourg, Sweden.
12:44:12 <shapr> Riastradh: on the other hand, Simon&Simon visited here once
12:44:18 <wli> I'm not sure what arrows are either
12:44:22 <Riastradh> I was hoping he'd taught you, so that you would understand and could explain them to us.
12:44:27 <esap> wli: well I would assume that once the AST is correctly designed, the rest of the syntax is pretty trivial [syntactic sugar being the hardest part]
12:44:37 <shapr> hey, I could ask J Hughes to give an IRC seminar on arrows!!
12:44:38 <Jolta> tic: arrows are only briefly touched at in the AFP course
12:44:41 <tic> Riastradh, hehe.  I'm a first-year CS student; that was the first language we learned.
12:44:46 <tic> Jolta, doh
12:44:57 <tic> Jolta, did you take it?
12:44:59 <Riastradh> tic, bug him about teaching them more.
12:45:04 <Jolta> tic: it mainly focuses on designing monadic libraries
12:45:11 <wli> esap: most of it boils down to not having tailcalls natively in C
12:45:12 <Riastradh> Tell him that the class popularity will soar if he teaches them.
12:45:13 <shapr> we want more arrows!
12:45:20 <basti_> <- <-
12:45:21 <Jolta> tic: yes, didn't actually finish the project, though
12:45:25 <tic> but what are arrows?
12:45:32 <tic> Jolta, m'kay, how come? 
12:45:32 <shapr> basti_: actually they look like <- myarrow -<
12:45:35 <Riastradh> They're long rods with feathers at one end and a pointy tip at the other.
12:45:37 <basti_> oh
12:45:37 <basti_> ;)
12:45:54 <shapr> arrows -> http://www.haskell.org/arrows/
12:45:55 <esap> wli: I've understood C is not a simple language to generate. Never tried that though.
12:45:56 <wli> esap: I need tailcalls native
12:46:16 <Jolta> Riastradh: I doubt "class populatiry will soar", since no one knows what arrows are. =)
12:46:31 <wli> esap: depends 100% on quality of code
12:46:31 <Riastradh> Jolta, hey, I never said he had to be -honest-.
12:46:37 <shapr> the only thing I've discovered about arrows so far is that they can constrain input and output types differently, and statically. You don't have to call them to know some stuff about them.
12:46:38 <Jolta> besides, Hughes hasn't taught the class in ... what, 4 years now?
12:46:57 <wli> esap: simple to make _something_ work, very complicatedd to make work optimally
12:47:08 <tic> Jolta, seriously?
12:47:13 <tic> Jolta, hasn't anyone taken the class lately?
12:47:20 <wli> esap: I'm shooting for much lower
12:47:32 <Jolta> shapr: you wanted to see our HaskellWars project when it was done, right? We'll be handing it in on the 22:nd
12:48:03 <wli> esap: I'm shooting for a C front end to something slightly more modular and that has tailcalls
12:48:03 <Jolta> tic: of course they have, but Koen Claessen has been teaching it!
12:48:07 <shapr> Jolta: cool!
12:48:20 <tic> Jolta, ah, bleh.  I want Hughes! ;
12:48:21 <tic> ;D
12:48:31 <wli> esap: where tailcalls are needed for operational reasons
12:48:42 <Jolta> tic: you want Hughes, you'll get all you can stand and more in "topics in computer languages"
12:48:55 <andersca> I'm taking that course next semester
12:49:03 <Jolta> tic: very interesting guest lectures, too
12:49:05 <tic> Jolta, oh?  is it called that?
12:49:19 <tic> Jolta, D2, D3?
12:49:21 <wli> esap: I do very low-level programming
12:49:23 <Jolta> tic: yes, "specialkurs i datorsprk"
12:49:41 <wli> esap: operational concerns are paramount
12:49:53 <wli> esap: _but_
12:50:07 <tic> Jolta, optional class?
12:50:13 <wli> esap: modularity greater than C provides is also so
12:51:04 <wli> esap inline assembly will be needed soon
12:51:23 <shapr> hi nibro 
12:51:36 <shapr> yay, 57 on the channel
12:51:36 <nibro> hi shapr =)
12:51:42 <shapr> we might break sixty today!
12:51:52 <shapr> nibro: how's the code treating you?
12:52:02 <nibro> someone said there was talk about arrows here so I couldn't resist it =)
12:52:14 <shapr> not talk, just wonderment
12:52:21 <shapr> nibro: do you understand arrows?
12:52:21 <nibro> just fine, thank you... but I'm getting tired of bugs
12:52:22 <esap> wli: my compiler tries to do very high-level things using very low-level primitives. Sounds a bit contradictory, but I guess it's possible :-)
12:52:50 <nibro> shapr: somewhat, I know how to use them at least, I wouldn't try making my ownat this point
12:52:50 <shapr> nibro: use QuickCheck! You can't even plead the Not Invented Here syndrome about it!
12:53:01 <shapr> ohh, someone who knows how to use arrows!
12:53:06 <wli> esap: I just need a saner language than C
12:53:15 <shapr> quick! grab and interrogate!
12:53:18 <nibro> hehe, whaddya wanna know 'bout it?
12:53:25 <shapr> well
12:53:50 <shapr> I want to know how to design my own, really.
12:53:50 <esap> wli: I think there was some C-alike intended to be used as an intermediate language.
12:53:53 <shapr> I have two projects in mind
12:54:07 <nibro> haskell StarCraft? =)
12:54:14 <shapr> one of them is a real-time strategy game...
12:54:17 <shapr> er, how did you know?
12:54:30 <wli> esap: it's not an IR
12:54:40 <Darius> esap: C--?
12:54:41 <wli> esap: it's supposed to be something to program in
12:54:42 <nibro> you told me =)
12:54:45 <shapr> the other is a framework to integrate multiple protocols
12:54:47 <shapr> nibro: oh
12:55:15 <shapr> nibro: my first question, can hmake be set up to automagically turn .as files into .hs files and then call ghc?
12:55:18 <esap> darius: yea, I think it was that.
12:55:39 <shapr> my second question, do you know how to use the rpSwitch combinator from the Yampa Continued paper?
12:56:06 <nibro> shapr: 1) wouldn't know, I guess so but I haven't been able to, we use the arrowpp manually
12:56:10 <Jolta> heh... i remember Henrik mentioning that one
12:56:19 <wli> esap: basically the whole portable asm bit cleaned up so it's sane in general and with some modularity forcibly thrust upon it
12:56:19 <shapr> do you think the Yampa signal function arrows and the rpSwitch combinator would be good for modeling units on a battlefield?
12:56:47 <nibro> shapr: 2) not of the top of my head, I did understand it when Henrik Nilsson explained it, but I've never used it, so...
12:56:58 <nibro> shapr: yes, I truly do
12:57:03 <Jolta> shapr: I think they are good for modeling combat robots... =)
12:57:20 <Jolta> shapr: by extension, I think yes, same as nibro
12:57:25 <shapr> nifty :-)
12:57:44 <wli> esap: dumping out C is good to debug kernel code with synchronization bugs
12:57:50 <nibro> shapr: you ought to try our HaskellWars, we're holding a presentation about it on tuesday so after that the system should be at least alpha-testable =)
12:58:03 <shapr> cool!
12:58:16 <wli> esap: which is why I want C front end stuff going
12:58:43 <wli> esap: we're not talking about functional programming with bananas, lenses, envelopes, and barbed wire
12:59:01 <wli> esap: we're talking about down and dirty butt ugly driver hacking horrors from Hell
12:59:33 <wli> esap: needs to work very much like C
12:59:44 <shapr> rusty barbed wire...
12:59:48 <shapr> tetanus
12:59:53 <shapr> yay
12:59:53 <esap> wli: heh, sounds fun.
12:59:53 <wli> esap: braindead translation straight to C (even observable as C) is perfect
13:00:30 <wli> esap: I just have to get a goddamn translation straightened out
13:01:57 <wli> esap: I want SML-style higher-order modules
13:02:10 <wli> esap: and type classes for structured overloading
13:02:48 <esap> wli: oh btw, reminds me of something I thought about modules. I think there is a great connection between "closed" modules and "open" namespaces (a'la C++).
13:03:10 <wli> esap: Module-level stuff is critical
13:03:20 <wli> esap: well thing is
13:03:33 <esap> wli: you are not doing recursive modules, are you? :-)
13:03:34 <wli> esap: namespaces in C++ can't be parametrized
13:03:53 <wli> esap: i.e. there is no equivalent of functorial programming
13:04:21 <tic> this line wouldn't quite work in hugs: theData <- if (files /= []) then (mapM readFile files) else (hGetContents stdin)
13:04:26 <shapr> can I do `op` with a three arg function?
13:04:29 <tic> does anyone know off-hand what might be wrong?
13:04:43 <wli> shapr: the op yields a function result
13:04:54 <shapr> hm, good point, thanks.
13:05:15 <esap> wli: right, but I mean a closed module is something with a well-defined interface it uses to communicate with the outside world. In contrast, there is no such thing as a "interface" to a namespace. However, namespaces have something very similar, that is, the set of symbols it uses.
13:05:23 <wli> esap: parametrized modules are a big deal
13:05:26 <wli> esap: right
13:05:34 <Darius> tic: probably the compiler
13:05:49 <wli> esap: the functorial style basically rules out closed modules
13:05:51 <Darius> or is it giving the wrong result?
13:06:03 <tic> Darius, it's complaining about it not working.. wait.
13:06:11 <tic> oh.
13:06:16 <tic> or..
13:06:24 <esap> wli: hmm.. why does the functorial style rule out closed modules?
13:06:44 <tic> Darius, hGetContents stdin returns a String, mapM readFile files seems to return a [String]
13:07:18 <wli> esap: functors take either a type or a closed term as a parameter adn generate a specific module instance
13:07:45 <esap> wli: yes, but the module instance they generate is closed, is it not?
13:08:04 <wli> esap: to be able to import it yes
13:08:35 <wli> only closed module instances can be imported
13:08:44 <esap> wli: so the functorial style is just "functions returning modules", in essence?
13:08:51 <wli> though module parameters can be used for it
13:09:04 <wli> esap: Almost
13:09:45 <wli> esap: one can pass parameters of the importing module to "close" the module being imported
13:09:49 <wli> i.e.
13:10:44 <nibro> tic: you wouldn't be doing laboration for the d1ptc course at chalmers by any chance? =)
13:11:14 <esap> wli: I've thought about that modules should really contain two independent 'interfaces', one that is like namespaces, and another that is closed. When you extend such a module, you would introduce another 'closed' interface around the 'open' namespace.
13:11:24 <tic> nibro, who, me? ;)
13:11:34 * tic places his data in a list
13:11:49 <nibro> tic: heh, I correct them you know... ;)
13:12:27 <tic> nibro, oh, sweet. :)
13:12:37 <tic> nibro, just not mine, I think?
13:12:40 <tic> nibro, mine's d99andy
13:12:49 <nibro> correct, I don't correct yours
13:12:51 <tic> my tutor whatever.
13:12:52 <tic> yah
13:12:52 <tic>  :)
13:12:53 <tic> well
13:13:01 <tic> so maybe you could help me out? ;)
13:13:09 <nibro> sure, what's the problem
13:13:16 <tic> theData <- if (files /= []) then (mapM readFile files) else (hGetContents stdin)
13:13:30 <tic> mapM readFile files returns a [String], hGetContents stdin returns a [String]
13:13:31 <tic> err
13:13:32 <tic> a String
13:13:39 <tic> the problem is that I want it to be a [String]
13:13:43 <esap> wli: the idea being that you have a "space" that you can extend, and you could introduce fences to that space that would delimit different kinds of functionality. The fences would the only way to 'use' the functionality.
13:13:46 <tic> but that doesn't seem possible as it's trapped inside a IO
13:13:58 <nibro> do you know the >>= operator?
13:14:17 <tic> nibro, nope, I'm happy with do {....} ;)
13:14:32 <tic> I find the syntax pretty awkward.
13:14:34 <wli> esap: consider a functor taking a functor as an argument
13:14:52 <nibro> tic:  theData <- if (files /= []) then (mapM readFile files) else (do { d <- hGetContents stdin; return [d]})
13:14:56 <tic> nibro, is there an easy way of solving my problem without rewriting my entire main to >>= format
13:15:00 <tic> oh
13:15:02 <tic> thanks!
13:15:38 <nibro> I would prefer this though:
13:15:40 <nibro>  theData <- if (files /= []) then (mapM readFile files) else (hGetContents stdin >>= \d -> return [d])
13:15:49 <tic> yeah
13:15:51 <tic> that seems nicer
13:16:01 * tic uses the latter approach
13:16:52 <nibro> tic: I see no harm in giving it to you, I'm sure you would have solved it anyway... sooner or later =)
13:17:05 <tic> nibro, yup.. :)
13:17:20 <nibro> tic: ... though maybe not as a one-liner ;)
13:17:41 <tic> nibro, neh, exactly.  like i said before, I'm a python coder at heart. 
13:18:04 <nibro> tic: well, welcome to a better world =)
13:18:20 <tic> nibro, hehe. dunno about that exactly, a lot of stuff is still a lot easier to solve in Python, I think.
13:18:29 <nibro> tic: off course I'm biased, what did you expect... ;)
13:18:39 <tic> nibro, sure, list processing and so on is better in Haskell, but Python has a lot of Haskellish features
13:18:42 <nibro> tic: only because you know it
13:19:09 <tic> nibro, take something like parsing the command line and see what the user said
13:19:23 <tic> nibro, store it in a global variable and let the program act on that later on.
13:19:29 <tic> nibro, instead of sending the value around.
13:19:51 <ham[let]> bye
13:20:30 <nibro> tic: System.Console.GetOpt... but I don't recommend you to use it for this lab
13:20:50 <nibro> well, if you're used to an imperative style, sure you like global variables
13:20:57 <dennisb> the problem is to send the values around
13:21:36 * esap thinks imperative programming should not include global variables.
13:21:44 <dennisb> still, there are tricks like hidden arguments (not in haskell, but in ghc)
13:22:11 <tic> yeah
13:22:16 <tic> but that's essentially a global variable. :)
13:22:19 <nibro> dennisb: how stable is the implicit args implementation in ghc?
13:22:29 <tic> I don't really use global variablesl in Python either, I use a singleton. ;)  but that's essentially the same thing.
13:22:40 <esap> hidden arguments are not at all like global variables, I think.
13:22:40 <dennisb> nibro: who knows... I've just used it in toy programs
13:23:04 <dennisb> I usually hides these things in a monad anyway
13:23:26 <nibro> dennisb: I've just heard that doing such an implementation has conceptual problems, haven't tried using it yet though
13:23:28 <dennisb> esap: no, but in this case there is no need to update the values
13:23:36 <tic> nibro, perhaps you know something about how to read from stdin the easiest way? ^D doesn't seem to stop hGetContents...
13:23:40 <nibro> dennisb: aye, I do to
13:23:47 <Darius> with a little unsafePerformIO magic, you can get your global variable
13:24:02 * dennisb refuses to use unsafePerformIO
13:24:04 <nibro> tic: well, getContents is what you really want to use
13:24:25 * nibro also refuses unless I can guarantee purity
13:24:33 <Darius> dennisb: I do too for the most part (except for soon where it is officially meant to be used, FFI)
13:25:03 <tic> nibro, a-ha.
13:25:34 <Darius> I used the global variable trick for a Haskell function that was being called from C (or rather two such functions)
13:36:36 * shapr grumbles at HXmlToolbox
13:41:33 <Darius> arbitrary-horribly-undereducated-change-to-some-other-person's-code time
13:44:11 <shapr> ?
13:49:27 <Darius> Well, it doesn't seem to crash anymore.  That's a plus.
14:05:56 <shapr> I must be doing this wrong... it couldn't really be this complicated
14:13:04 * shapr grumbles
14:13:31 * seth_ is away: Off to the glue factory
14:13:34 <Darius> poor DOGI's
14:13:35 <Igloo> What's the problem?
14:14:11 <shapr> atm, trying to figure out how to get rid of a tag but leave its child nodes with HXmlToolbox
14:15:49 <shapr> hi grem 
14:15:58 <grem> shapr: hello
14:16:01 <shapr> grem: learning Haskell?
14:16:19 <grem> just starting to yes
14:16:30 <shapr> have any questions?
14:17:26 <grem> yes, in ghci i am trying to define a function... is there a keyword i am missing?  i trid functionname :: Integer -> Ingeger ... but it says functionname not defined
14:17:47 <shapr> you can't give type signatures in ghci
14:17:56 <shapr> you need to write the function into a file, and then load the file.
14:18:05 <shapr> you can define some things in ghci
14:18:18 <grem> but not functions?
14:18:26 <shapr> you can sort of define functions
14:18:44 <grem> meaning?
14:18:46 <shapr> *Main> let x = (\x -> x + 1)
14:18:46 <shapr> *Main> x 5
14:18:46 <shapr> 6
14:18:53 <Igloo> You can say let foo :: type; foo = whatever
14:18:58 <shapr> oh, you can?
14:18:59 <shapr> nifty
14:19:34 <shapr> grem: it's probably easier to put your code into a file and load that file into ghci
14:19:41 <shapr> grem: are you using emacs or vim?
14:19:56 <grem> emacs is GOD :)
14:20:12 <shapr> I'll take that as a yes.
14:20:22 <grem> hehe
14:20:36 <tez> Yes, invoked via M-x god-mode
14:20:51 <shapr> assuming you're using haskell-mode, and that you've done M-x turn-on-haskell-ghci, you can hit C-c C-l to load the current Haskell buffer into ghci
14:22:11 <grem> shapr: there isn't a turn-on-haskell-ghci...
14:22:54 <shapr> grem: do you have haskell-mode installed and loaded?
14:23:26 <shapr> you may need to manually load haskell-ghci via M-x load-library (assuming it's on your load-path)
14:24:05 <grem> shapr: its probably not installed
14:24:14 <shapr> ah
14:25:03 <grem> shapr: where can i download it from?
14:25:19 <shapr> http://www.haskell.org/haskell-mode/
14:25:59 <Darius> I am victorious!  I think in both the game and programming worlds.
14:26:18 <shapr> Darius: yay!
14:26:21 <shapr> what have you won?
14:26:38 <Darius> A version of SC2 that doesn't crash!
14:27:12 <shapr> what's SC2?
14:27:18 <Darius> sc2.sf.net
14:27:42 <shapr> nifty
14:28:26 <Igloo> Did IOHCC results get announced yet?
14:28:57 <shapr> er, no?
14:29:47 <jolta> shapr: the world is holding its breath, you know...
14:30:09 <Igloo> What are we waiting for?
14:30:10 * shapr feels the vacuum
14:30:21 <shapr> Igloo: me :-)
14:30:41 <Igloo> Ah  :-)
14:31:01 <jolta> shapr: is it only you, though?
14:31:04 <shapr> I can't do it right now :-/
14:31:18 <shapr> hopefully in an hour or so
14:31:21 <jolta> shapr: shame. i'll have to manage somehow
14:31:31 <jolta> oh, an hour? cool!
14:32:50 <Darius> how the heck do you -browse- the bug reports with Bugzilla.
14:35:58 <grem> shapr: i don't have a .emacs file... where is the one that is used across the entire system?
14:36:16 <shapr> grem: are you using windows or linux?
14:36:25 <grem> shapr: linux
14:36:26 <shapr> or something completely different?
14:36:44 <shapr> grem: you can create your own personal .emacs in your home directory
14:37:02 <shapr> there's not a default .emacs file, though samples do come with most emacs installations.
14:37:12 <grem> shapr: i know, but won't i want to copy the one that it is using now?
14:38:00 <shapr> if you don't have one in your home dir, it probably isn't using one.
14:40:16 <grem> shapr: ok, it works now, if i want to add mouse-wheel-mode to my .emacs file how would i do that?
14:40:51 <shapr> (mwheel-install)
14:41:36 <grem> shapr: good deal, thanks
14:42:20 <grem> shapr: thanks
14:43:23 <grem> shapr: one last thing, it tries to run hugs when i do C-c C-l
14:43:29 <Darius> *sigh* why do you need to be authenticated to report a bug?
14:44:09 <shapr> grem: try M-x turn-on-haskell-ghci
14:44:35 <grem> shapr: i got it...
14:44:40 <grem> i'm learning ;)
14:44:45 <shapr> for long-term effectiveness,
14:44:46 <shapr> (add-hook 'haskell-mode-hook 'turn-on-haskell-font-lock)
14:44:46 <shapr> (add-hook 'haskell-mode-hook 'turn-on-haskell-decl-scan)
14:44:46 <shapr> (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
14:44:46 <shapr> (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
14:45:27 <grem> shapr: a ; is a comment in lisp?
14:45:57 <Riastradh> ; starts a single-line comment.
14:48:13 <Riastradh> @yow
14:48:14 <lambdabot> TAPPING?  You POLITICIANS!  Don't you realize that the END of the
14:48:14 <lambdabot>  ``Wash Cycle'' is a TREASURED MOMENT for most people?!
15:24:46 <grem> whats the advantage/disadvantage of defining a function like add x y vs. add (x,y)?
15:25:01 <Riastradh> The former is curried; the latter takes a tuple argument and deconstructs it when you call it.
15:26:00 <grem> Riastradh: so it makes no difference which way i do it?
15:26:15 <Riastradh> If you always call it with both arguments, no.
15:26:24 <Riastradh> But there is the advantage of easy partial application with currying.
15:26:54 <grem> Ah, i read about that, but didn't fully understand it...
15:27:36 <Igloo> It is nicer to do    map (add 5) [1,2,3]    than    map (\x -> add (5, x)) [1, 2, 3]
15:30:55 <Riastradh> f g x = ...
15:30:57 <Riastradh> is the same as:
15:31:05 <Riastradh> f = \g -> \x -> ...
15:31:33 <Riastradh> Or, in other words, f is a function that returns another function, and so on and so forth, until it accumulates all the arguments it needs and does all its processing.
15:33:22 <grem> hmmmm....
15:34:03 <Riastradh> That way you can apply it once, and get a function that hasn't accumulated all its arguments yet, so you can pass a half-applied function around, which is less cumbersome than using lambda all the time.
15:36:20 <grem> so lets say we have the add function which add x y = x+y ... then i have a function called inc = add 1... so then if i do let a = 1 i could do inc a? and it would return 2?
15:36:40 <grem> what does add essentially do since it only has 1 arg
15:36:41 <grem> ?
15:37:05 <Riastradh> add returns \y -> x + y, where x is bound to 1, which is what you originally called it with.
15:37:06 <tez> yeah, that's correct.
15:37:26 <Riastradh> let { add x y = x + y; inc = add 1; a = 0 } in inc a  -- returns 1
15:37:52 <Riastradh> Oops, I probably just confused you.
15:38:00 <Riastradh> let { add x y = x + y; inc = add 1; a = 1 } in inc a  -- returns 2
15:38:11 <Riastradh> ...to use the same example as you used.
15:39:15 <grem> i understand that it works, but i don't understand how the curried add function works.  what is \y?
15:39:37 <Smerdyakov> You haven't seen an anonymous function before?
15:40:27 <grem> in other languages i've never dealt with anything like curried functions.
15:40:37 <Smerdyakov> I'm not asking about curried functions.
15:40:55 <Smerdyakov> I'm asking if you've ever seen an expression like (\x -> something) before.
15:41:03 <tez> If you want, you can read "\y -> y + 2" as a function that takes one argument, call it y, and adds 2 to it.
15:41:24 <Riastradh> If you've ever done anything with Lisp, read it as (lambda (y) (+ y 2)).
15:41:41 <Smerdyakov> Lispers can't read. Everyone knows that.
15:42:12 <Riastradh> Sure they can -- they've even got READ built into the language!
15:42:24 * shapr grins
15:42:51 <grem> i've programmed in Java and C++... no Lisp
15:42:52 * shapr learns the "erase XML from everyone's memory" spell
15:43:15 <Riastradh> grem, how about Python?
15:43:22 <shapr> grem: you'll have a blast :-)
15:43:39 <shapr> grem: your mind will be stretched, and you'll learn new ways of programming.
15:43:40 <grem> i started to learn python, my boss then put this project on me with haskell :)
15:44:05 <Riastradh> How about Ruby?
15:44:10 <Riastradh> Or even Perl?
15:44:16 <shapr> grem: you're getting paid to write Haskell?
15:44:19 <shapr> where do you work/
15:44:19 <shapr> ?
15:44:43 <grem> For a small company, actually i work for seth_ ... he's idle in here now ;)
15:44:57 <shapr> oh, nifty
15:45:09 <Smerdyakov> Hm.... isn't seth_ the one who's had some very basic problems with Haskell recently? =)
15:45:25 <shapr> Smerdyakov: yes, but he also learns fast ;-)
15:45:43 <grem> he's been writing some things in it also... he's a REALLY fast learner...
15:46:00 <Riastradh> grem, oooh, are they hiring?
15:46:13 <grem> Riastradh: no, sorry :(
15:46:31 <Smerdyakov> What project are you working on in Haskell?
15:47:32 <grem> its a networking project, its goign to be a network daemon that listens for connections
15:48:24 <tez> Ah, like a light bulb that lights up.
15:49:25 <grem> tez: i don't feel like typing for six years trying to describe it... 
15:50:39 <shapr> grem: any other questions about learning Haskell?
15:51:26 <grem> I am just confused about the curried functions right now...
15:51:46 <Smerdyakov> First step is to go back and read the part you skipped about anonymous functions :P
15:52:19 <grem> Smerdyakov: i'm reading about lambda abstractions right now
16:14:11 <grem> where would i find more info on lambda abstractions?
16:14:24 <Riastradh> Church's writings.
16:14:34 <grem> ?
16:14:43 <Riastradh> The stuff that Alonzo Church wrote.
16:14:51 <shapr> lambda calculus came from his writings, I tihnk
16:15:16 <grem> ok, more about lambda abstactions in relation to haskell
16:17:07 <Riastradh> The Lambda-Calculus relates to any language with lambda abstractions.
16:19:52 <grem> Is there a network programming tutorial for haskell?
16:20:40 <Smerdyakov> grem, what is it about them that you want to know?
16:20:46 <Smerdyakov> grem, (about lambda abstractions)|
16:21:56 <grem> Smerdyakov: i just wanted to read more about them, gain a better understanding of them... They still seem a little fuzzy to me
16:23:48 <grem> so a \x is basicly like saying the anonymouse function x?
16:24:16 <Smerdyakov> x is the function parameter.
16:24:18 <Smerdyakov> Whenever you write:
16:24:22 <Smerdyakov> myfunc x = something
16:24:26 <Smerdyakov> This is just shorthand for
16:24:29 <Smerdyakov> myfunc = \x -> something
16:24:48 <Smerdyakov> Every function in Haskell has exactly one parameter.
16:25:58 <grem> Smerdyakov: any function in haskell can be called with one parameter?
16:27:02 <Smerdyakov> Yes.
16:27:17 <Smerdyakov> There is no other way to call a function, since they all have exactly one parameter.
16:27:44 <lament> what about those that have exactly zero? :)
16:27:55 <Smerdyakov> Those aren't functions....
16:28:42 <Smerdyakov> This follows the standard mathematical description of a function. I don't know if you're familiar with it, grem.
16:29:58 <grem> Smerdyakov: yes i am familiar with mathmatical functions
16:31:26 <Smerdyakov> OK. That's what Haskell functions are.
16:31:36 <Smerdyakov> There are no "side effects," so the analogy is pretty exact.
16:32:51 <grem> so if there are multiple arguments passed in they are all defined as functions inside the other functions? like the add 1 or add 1 2?
16:37:15 <shapr> huh?
16:37:22 <shapr> oh
16:37:49 <shapr> myAdd x y = x + y
16:38:06 <shapr> takes one number, returns a new function
16:38:20 <shapr> the new function takes a number and returns a number
16:38:45 <shapr> grem: in Church's lambda calculus, even numbers were defined as functions.
16:41:52 * Pseudonym yawns
16:41:55 <shapr> y0 Pseudonym 
16:41:59 <Pseudonym> G'day.
16:42:19 <Pseudonym> Question.  We've seen a few examples of constructing Peano numbers in the type system.
16:42:26 <Pseudonym> Has anyone tried the full integers?
16:44:10 <lament> doesn't sound too hard
16:44:26 <Pseudonym> I only want to handle equality, too.
16:45:36 <Pseudonym> The easiest way to construct integers is to use a pair of Peano numbers.
16:46:01 <Pseudonym> where (m1,n1) == (m2,n2) iff m1+n2 == m2+n1
16:46:10 <Pseudonym> Trouble is, that requires addition.
16:53:52 <shapr> hi fc
16:54:13 <fc> hey.
16:54:19 <shapr> learning Haskell?
16:55:13 <Smerdyakov> Pseudonym, so what's a representation of 1 and a representation of -1?
16:55:21 <fc> yeah ... great langauge!
16:55:30 <fc> s/langauge/language
16:55:39 <shapr> fc: have any questions?
16:56:15 <fc> no
16:56:35 <fc> at least, not yet ;)
16:56:36 <shapr> ok, if you think of any, feel free to ask.
16:56:45 <Pseudonym> Well, representations aren't unique.
16:56:48 <fc> thanks!
16:56:56 <Pseudonym> But, for example, (5,4) might be one representation of 1.
16:57:05 <Pseudonym> and (102,103) might be a representation of -1
16:58:24 <Smerdyakov> Pseudonym, is (206,0) a representation of 206?
16:58:30 <Pseudonym> Yes.
16:58:39 <Smerdyakov> Pseudonym, then, by your definition of equality, 206 == -1 ....
16:58:45 <Pseudonym> No.
16:58:50 <Smerdyakov> Oops
16:58:52 <Smerdyakov> I missed.
16:58:53 <Smerdyakov> Hehe
16:59:19 <Pseudonym> I love the emphasis on the posessive.
16:59:23 <Pseudonym> Accoring to YOUR definition...
16:59:35 <Pseudonym> :-)
17:00:19 <lament> what about using Zero | Succ Num | Pred Num ?
17:00:20 <Smerdyakov> OK, so what's wrong with requiring addition?
17:00:43 <Pseudonym> How do you implement it in the type system?
17:00:44 <lament> although that's probably too evil.
17:00:55 <Pseudonym> How do you get both addition and equality?
17:01:06 <Pseudonym> I think you need a unique representation of every integer.
17:01:25 <Pseudonym> BTW, I need addition anyway. :-)
17:01:37 <Pseudonym> OK, here's my application:
17:02:01 <Pseudonym> I want to work in physical units, like metres, seconds, kilograms, coulombs etc.
17:02:07 <Smerdyakov> You add one number to another by using primitive recursion on the first to add successor to the second.
17:02:23 <Pseudonym> Yes, but then implementing equality is the hard part.
17:02:52 <Pseudonym> It's straightforward in Peano numbers.
17:02:56 <Pseudonym> Because representations are unique.
17:03:10 <Pseudonym> In this representation of integers it's much harder.
17:03:20 <Pseudonym> Let me explain what I'm trying to do. :-)
17:03:36 <Pseudonym> OK, so conceptually a "length" is just a scalar, like a Double.
17:03:49 <Pseudonym> So is "time", and so is "acceleration".
17:03:59 <Pseudonym> At the level of the type system I want them to be different.
17:04:23 <Smerdyakov> But.... all you need is equality testing of natural numbers, and then your integer test is trivial.
17:04:31 <Smerdyakov> Right?
17:04:33 <Pseudonym> OK, implement it in the type system.
17:04:36 <Pseudonym> Go ahead.
17:04:47 <Pseudonym> Writing a Haskell function to do it is easy.
17:04:51 <Pseudonym> But I want to do it all in types.
17:05:09 <lament> <Pseudonym> I want to be a masochist.
17:05:13 * Pseudonym laughs
17:05:22 <Pseudonym> See, I want a type like this:
17:05:22 <Smerdyakov> OK.... so it's simple enough to write a function that checks if a natural is 0 or not.
17:05:29 <Smerdyakov> If they're both 0, then you return true.
17:05:36 <Smerdyakov> Otherwise, if either one is 0, then return false.
17:05:43 <Pseudonym> No, no, no!
17:05:46 <Smerdyakov> ?
17:05:46 <Pseudonym> I don't want a _function_.
17:05:54 <Pseudonym> I want something implemented entirely in types.
17:06:02 <Pseudonym> Writing a function is easy.
17:06:21 <Smerdyakov> Doesn't the type system have primitive recursion, if you can implement +?
17:06:31 <Pseudonym> Yes, it does.
17:06:37 <Smerdyakov> If the type system implements the simply typed lambda calculus, then I'm fine so far.
17:06:48 <Pseudonym> In fact, the type system is Turing-complete if you -fallow-undecidable-instances and -fallow-overlapping-instances.
17:07:14 <Pseudonym> In fact, I don't think you even need overlapping instances.
17:07:28 <Smerdyakov> OK. So then what's wrong with what I said so far?
17:07:40 <Pseudonym> Nothing wrong so far.
17:07:52 <Smerdyakov> <Pseudonym> No, no, no!
17:08:03 <Smerdyakov> I guess the problem is that when I said "function," you thought I meant "Haskell function" =)
17:08:04 <Pseudonym> I thought you were heading down the wrong track.
17:08:07 <Pseudonym> Yes. :-)
17:08:09 <Pseudonym> OK, go on.
17:08:28 <Pseudonym> With you so far.  I can even write a typeclass which enforces the constraint that two Peano numbers are equal.
17:08:58 <Smerdyakov> So then.... what's the problem?
17:09:30 <Smerdyakov> Anyway, to continue, you can write the predecessor function and recurse as needed until something hits 0.
17:09:46 <Pseudonym> Right.
17:09:58 <Smerdyakov> So... why am I telling you this, if you already solved the problem?
17:10:05 <Pseudonym> Hmmm.
17:10:12 <Pseudonym> I guess I should try implementing it and see if it works.
17:10:26 <Pseudonym> I seem to recall a serious problem with this approach some time late last night.
17:10:32 <Smerdyakov> If you have the simply typed lambda calculus, there's no question of if it works or not. :P
17:10:53 <Smerdyakov> I've done it in constructive logic class.
17:13:36 <Pseudonym> Oh, I get it.
17:13:38 <Pseudonym> You need fundeps.
17:13:39 <Pseudonym> Duh.
17:13:41 <Darius> See SimulatingDependentTypes on HaWiki and Fun with Functional Dependencies.  It's pretty straightforward to convert Haskell code to Haskell type system code.
17:13:45 <Smerdyakov> fundeps?
17:13:49 * Pseudonym nods.
17:13:56 <Pseudonym> class PeanoAdd l r n | l r -> n
17:14:02 <Darius> You need fundeps or you'll have horrible ambiguity errors.
17:14:19 <Smerdyakov> Oh, I gotcha.
17:14:23 <Darius> fundeps are like the in/out "type" of a logical relation
17:14:39 <Darius> I.e. PeanoAdd (in l) (in r) (out n)
17:14:52 <Pseudonym> instance PeanoAdd PeanoZero r r
17:14:53 <Pseudonym> instance (PeanoAdd l r n) => PeanoAdd (PeanoSucc l) r (PeanoSucc n)
17:14:59 <Pseudonym> Makes perfect sense now.
17:16:18 <Pseudonym> Right.  Fundeps are the "mode".
17:16:29 <Darius> Exact equality is simple, but requires undecidable instances.  class Equal a b;instance Equal a a
17:16:30 * Pseudonym should have realised this as an ex-Mercurian
17:16:41 <Pseudonym> class PeanoEqual m n
17:16:41 <Pseudonym> instance PeanoEqual PeanoZero PeanoZero
17:16:42 <Pseudonym> instance PeanoEqual (PeanoSucc n) (PeanoSucc n)
17:17:07 <Darius> which is an instance (the pattern) of Equal
17:17:56 <Pseudonym> class WholeEqual m n
17:17:56 <Pseudonym> instance (PeanoAdd m1 n2 p, PeanoAdd m2 n1 p)
17:18:03 <Pseudonym>      => WholeEqual (Whole m1 n1) (Whole m2 n2)
17:18:06 <Pseudonym> Ta da.
17:19:44 <Pseudonym> It even compiles.
17:32:42 * shapr boings
17:33:01 * shapr vibrates steadily
17:33:02 <Pseudonym> Almost got this implemented.  Just need to do the "Num" class for proof of concept.
17:33:32 <Pseudonym> Oh, crap.
17:33:34 * Pseudonym hmmms
17:33:36 <shapr> ?
17:33:55 <Pseudonym> The Num typeclass screws up my types.
17:33:59 * Pseudonym has always hated this
17:34:13 <Pseudonym> (*) :: (Num a) => a -> a -> a
17:34:21 <Pseudonym> Because I want, for example:
17:34:29 <Pseudonym> (*) :: Velocity -> Time -> Length
17:34:51 <Smerdyakov> That's not Num anymore!
17:34:56 <Pseudonym> I know.
17:35:11 <Pseudonym> IMO, Num should be refactored.
17:35:15 <Smerdyakov> I mean, it doesn't even make sense to consider that an operations on numbers.
17:35:26 <Pseudonym> No, of course not.
17:35:28 <Pseudonym> I want:
17:35:39 <Pseudonym> class Mult l r n | l r -> n
17:35:41 <Pseudonym> where
17:35:48 <Pseudonym>     (*) :: l -> r -> n
17:35:52 <Pseudonym> and in the special case:
17:35:59 <Pseudonym> class (Mult n n n) => Num n where
17:36:09 <Pseudonym> And so on for every other numeric operator.
17:36:31 <Pseudonym> A very common thing that people want is:
17:36:36 <Pseudonym> (*) :: Matrix -> Vector -> Vector
17:48:50 <Pseudonym> Hmmm.
17:48:55 <Pseudonym> Don't like this formulation at all.
17:49:22 <Pseudonym> I want integers with unique representations.
17:49:36 <Pseudonym> Oh.
17:49:37 <Pseudonym> Hmmm.
17:57:49 <Darius> (SignBit,Nat), then you only have to worry about zero.
17:58:33 <Pseudonym> I've got it now.
17:58:40 <Pseudonym> I actually need this:
17:58:46 <Pseudonym> class WholeUniqueRep m n | m -> n
17:58:47 <Pseudonym> instance WholeUniqueRep (Whole Peano0 Peano0)
17:58:47 <Pseudonym> instance WholeUniqueRep (Whole (PeanoSucc m) Peano0)
17:58:47 <Pseudonym> instance WholeUniqueRep (Whole Peano0 (PeanoSucc n))
17:58:49 <Pseudonym>                         (Whole Peano0 (PeanoSucc n))
17:58:52 <Pseudonym> instance (WholeUniqueRep (Whole m n) uniq) =>
17:58:57 <Pseudonym>      WholeUniqueRep (Whole (PeanoSucc m) (PeanoSucc n)) uniq
17:59:01 <Pseudonym> Er...
17:59:09 <Pseudonym> Basically, you need a concept of "unqiue representations".
17:59:14 <Darius> The equivalence class.
17:59:18 <Pseudonym> Right.
17:59:25 <Pseudonym> No.,
17:59:32 <Pseudonym> Equivalence is not the same thing.
17:59:42 <Pseudonym> You need each Whole number to map into a unique Whole number.
18:00:56 <Pseudonym> See, I want this:
18:01:00 <Darius> If the equivalence classes are countable, then that would still hold.
18:01:13 <Pseudonym> Yes, but I want this for convenience.
18:01:18 <Pseudonym> I want to be able to say:
18:01:21 <Pseudonym> f :: A -> B -> C
18:01:22 <Pseudonym> not:
18:01:37 <Pseudonym> f :: (Equivalent a A, Equivalent b B, Equivalent c C) => a -> b -> c
18:02:02 <Darius> Intensional equality
18:02:08 * Pseudonym nods
18:04:30 <Pseudonym> Hrm.
18:04:49 <Pseudonym> This should work without the type declaration.
18:21:34 <Pseudonym> Woohoo!  It works!
18:21:37 * Pseudonym will check this in
18:22:53 <Darius> What works and check into what?
18:23:04 <shapr> a hotel?
18:23:06 <Darius> What as in the details
18:23:22 <Pseudonym> I'll check it into haskell-libs and you can see for yourself.
18:23:48 <shapr> yay
18:23:51 <shapr> check-in !
18:24:03 <Darius> ack, I need to kill some aliens quickly
18:24:21 <shapr> kill kill!
18:24:30 * shapr finds the solution via voodoo coding
18:24:47 * shapr wonders whether chicken blood washes off monitors easily
18:27:20 <Pseudonym> OK, it's in /physics
18:27:44 <Pseudonym> Peano.hs is the natural numbers, Whole.hs is integers, then PhysicalUnit.hs is physical units.
18:28:09 <Pseudonym> Well that was fun.
18:28:27 <shapr> so, now that I can this new trick with XML tags, I wonder how it works.
18:28:44 <shapr> (processBottomUp ((this /> this) `when` isTag "a"))
18:33:39 <Darius> Damn Chmmr.  My Mycon wasn't a glorious hero this time.
18:34:33 <grem> Where would I find info on network programming in haskell?
18:35:04 <shapr> grem: if you can get hold of the ghc sources, lots of spiffy network testing code comes with it.
18:35:09 <shapr> grem: you could check the lambdabot sources
18:35:14 <shapr> @hello
18:35:15 <lambdabot> Hello world. 
18:35:34 <grem> @socket 
18:35:35 <lambdabot> Sorry, I don't know the command "socket", try "lambdabot: @listcommands"
18:35:42 <shapr> grem: http://kungens.kemi.fi/~shae/src/haskell/Echo2.hs
18:35:44 <lambdabot> ...hello cruel world, even.
18:35:47 <shapr> that might be helpful
18:35:52 <grem> @listcommands
18:35:53 <lambdabot> I react to the following commands: ["all-dicts","board","define","definitions","del-definition","devils","dict","dict-help","dump","easton","echo","elements","eval","flip-board","foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","more","msg","part","ply","prelude","quit","reset-chess","resume","set-fuel","state","topic-cons
18:35:55 <shapr> lambdabot: hardy har
18:35:55 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
18:37:11 <Pseudonym> @karma
18:37:11 <lambdabot> I can't find the karma of nobody.
18:37:16 <Pseudonym> @karma shapr
18:37:17 <lambdabot> shapr has a karma of 2
18:37:25 <Pseudonym> @karma lambdabot
18:37:26 <lambdabot> lambdabot has a karma of 1
18:37:26 <grem> @karma grem
18:37:26 <lambdabot> You have a karma of 0
18:37:29 <lambdabot> But only because of some people who easily worship.
18:37:38 <lambdabot> (about shapr's karma, that is)
18:37:44 <shapr> eh?
18:37:49 <shapr> what?
18:37:50 <grem> hehe
18:37:52 <Pseudonym> @karma Pseudonym
18:37:52 <lambdabot> You have a karma of 0
18:37:55 * Pseudonym woohoos
18:37:59 <shapr> @karma+ Pseudonym
18:38:01 <lambdabot> Pseudonym's karma has been incremented.
18:38:02 <flippo> @karma+ shapr
18:38:02 <lambdabot> shapr's karma has been incremented.
18:38:10 <shapr> I have karma!
18:38:11 <shapr> hi flippo 
18:38:19 <flippo> shapr: howdy 
18:38:34 <shapr> wassup?
18:38:45 <grem> @karma+ seth_
18:38:45 <lambdabot> seth_'s karma has been incremented.
18:38:48 <grem> hehe
18:38:50 * shapr grins
18:38:57 <shapr> grem: brown-nosing? ;-)
18:39:00 <flippo> I've begun Thomson.  Very pleasant reading.
18:39:04 <grem> shapr: never ;)
18:39:09 <shapr> flippo: yay!
18:39:25 <flippo> shapr: the bookstore found a copy, even though it is not back in print yet
18:40:00 <shapr> spiffy
18:40:06 <shapr> how far have you gotten?
18:40:30 <flippo> shapr: the book is a bit more elementary than I expected.  The first four chapters haven't challenged me yet
18:40:59 <flippo> shapr: but maybe it's just getting warmed up
18:41:26 <shapr> I found it fun and easy going till I hit monads.
18:42:03 <Riastradh> I found monads fun and easy the moment I finished 'What the Hell are Monads?'.
18:42:28 <grem> shapr: where in the source is the stuff on networking?
18:42:44 <shapr> grem: did you look at the Echo2.hs url I pasted?
18:42:53 <grem> ya
18:43:05 <grem> i understand _most_ of it ...
18:43:24 <shapr> grem: so make it do something different...
18:43:45 <flippo> It's funny that haskell has both ^ and **
18:43:58 <flippo> and they mean different things
18:44:05 <Pseudonym> I think it makes sense.
18:44:15 <shapr> one of my learning heuristics is "play with working code till it breaks, fix it, understand why it broke and why that fixed it, repeat till enlightened"
18:44:16 <Darius> and ^^ 
18:44:20 <Pseudonym> No different from '%' vs 'mod'.
18:44:36 <shapr> and the ever famous cat operator =^.^=
18:44:56 <flippo> that one looks cute
18:45:26 <shapr> I'm looking forward to unicode source files
18:45:34 <Darius> "foo" =^.-= "bar" =^.^= "baz"
18:45:40 * shapr laughs
18:45:49 <shapr> cat and concat?
18:46:22 <shapr> then there's the cool sunglasses operator  OO
18:46:46 <Darius> hmm, I want the logical negation
18:46:57 <grem> shapr: when i tried to run it in ghci i got a can't find module 'Network'
18:46:58 <shapr> I want the illogical negation
18:47:12 <shapr> grem: put ":set -package network" into ghci
18:47:13 <Pseudonym> I want the emotional negation.
18:47:14 <Darius> -package network
18:47:24 <Darius> oh, GHCi
18:48:01 <flippo> weird I can't get 2.**3. to evaluate in the hugs interpreter.  2^3 works fine.
18:48:30 <Darius> @type (**)
18:48:31 <lambdabot> (**) :: Floating a => a -> a -> a
18:48:34 <Darius> @type (^)
18:48:35 <lambdabot> (^) :: (Num a, Integral b) => a -> b -> a
18:48:39 <Darius> @type (^^)
18:48:39 <lambdabot> (^^) :: (Fractional a, Integral b) => a -> b -> a
18:49:17 <flippo> it likes 2.0 but not 2.
18:49:27 <flippo> never noticed that before
18:49:49 <Darius> you could replace (.)
18:50:08 <flippo> it thought . was an operator
18:50:16 <Darius> hmm, that still wouldn't explain it all the way
18:50:17 <Darius> it is
18:50:29 <flippo> > 2. ** 3
18:50:30 <Pseudonym> (.) is the cartoon eye operator
18:50:30 <flippo> ERROR - Syntax error in expression (unexpected symbol "**")
18:50:30 <Darius> so is -->, <|>, *
18:51:07 <shapr> I think the multi-part operators are great fun
18:51:19 <shapr> <- myarrow -<
18:51:25 <grem> shapr: even after i do -package lang -package concurrent -package network in ghci i still get an unknown socket error
18:51:29 <Darius> -->, this one is somewhat evil.  Vim doesn't handle it right.
18:51:30 <shapr> HXmlToolbox has a cute one...
18:51:40 <Darius> At least with my syntax highlighting
18:51:46 <shapr> grem: tell me more about the error
18:52:10 <grem> shapr: i got it.. i did -package network, but not -package net ...
18:52:16 <shapr> ah
18:52:16 <shapr> ok
18:54:13 <grem> shapr: once i load the module into ghci how can i execute the main?
18:55:05 <Darius> main
18:55:45 <shapr> yup
18:55:57 <grem> Prelude Main> main
18:55:57 <grem> <interactive>:1: Variable not in scope: `main'
18:56:41 <shapr> should be in scope
18:57:11 <grem> *shrug*
18:57:12 <Darius> :l it
18:57:15 <Darius> not :mod it
18:57:32 <shapr> ah, good point
18:57:54 <grem> Prelude> :l Echo2.hs
18:57:54 <grem> Skipping  Main             ( Echo2.hs, ./Echo2.o )
18:57:54 <grem> Ok, modules loaded: Main.
18:57:54 <grem> Prelude Main> main
18:58:07 <grem> same error
18:58:50 <shapr> grem: try doing :m first
18:58:56 <shapr> and then :l Echo2.hs
18:59:28 * shapr touts unit testing as a gift from god
18:59:32 <Darius> Pseudonym: physics is kick-ass
18:59:48 <Pseudonym> You like it?
18:59:51 <grem> shapr: still no go... 
19:00:05 <Pseudonym> I think I like type system metaprogramming.
19:01:49 <Darius> There's a whole thread on it on c.l.f, where I end up being pretentious and patronizing.  I can see pretentious, I don't see patronizing.
19:02:16 <shapr> grem: same error?
19:02:20 <Pseudonym> Don't worry your pretty little head about it.
19:03:05 <Darius> I don't.  I've been called worse, on other forums.
19:03:05 <shapr> usenet is about those in the know talking to those who don't know, and nothing being communicated ;-)
19:03:27 <grem> shapr: yep
19:03:28 <Pseudonym> Actually, it is possible to find correct information on usenet.
19:03:34 <Pseudonym> The secret is to post wrong information.
19:03:38 * shapr grins
19:03:45 <Darius> You get through to some or else everyone would give up quickly
19:03:46 <shapr> then you are corrected and reviled
19:04:16 <shapr> Darius: no way, look at topmind... 99% of usenet users thinks he's on drugs, but he's been posting for years
19:04:33 <Darius> Unfortunately, those who that aren't get-throughable are vast and many.
19:05:25 <Pseudonym> And unlike a weblog site, you can tell who is not get-througable.
19:05:30 <Darius> Some days it's frustrating.  Here's a not so good day for me (though because of other people who don't know what they are talking about):
19:05:35 <Pseudonym> On a weblog site, you can pretend that you've explained things to someone.
19:05:35 <shapr> believe it or not, I'm in need of a win32 ghc
19:05:45 <Pseudonym> shapr, I'm shocked.
19:05:55 <shapr> me too
19:05:57 <Pseudonym> I hope it's for a client.
19:06:01 <shapr> it is =)
19:06:06 <Pseudonym> Oh, that's all right then.
19:06:11 <shapr> I'm being paid for the code I'm writing atm
19:06:22 <Pseudonym> Taking over the world by installments is acceptible.
19:06:34 <shapr> yes, monthly installments
19:06:39 <Pseudonym> Or even acceptable.
19:06:59 <shapr> for just 9.95 a month.. you too can get XML transformation code written in Haskell!
19:07:01 <Pseudonym> Eventually, "acceptible" will be an acceptible spelling.
19:07:25 <shapr> HXmlToolbox is powerful enough that I think my clients will stop trying to use Java to do this stuff.
19:08:38 <Riastradh> shapr, but Haskell doesn't have other buzzwords revolving around it, like 'object-oriented.'
19:08:48 <Darius> http://www.programmersheaven.com/c/MsgBoard/read.asp?Board=3&MsgID=163897&Setting=A9999F0001
19:08:52 <shapr> my 54 lines of Haskell are taking the place of several hundred lines of Java, Javascript, XSLT, etc
19:09:07 <shapr> Riastradh: it does have the cheaper buzzword
19:09:13 <Riastradh> Though maybe if you used terms like 'referential transparency,' 'monadic computation,' 'anonymous lambda abstraction,' and so on, they could turn into buzzwords.
19:09:35 <Darius> or 'warm fuzzy computation'
19:09:40 <shapr> I still think we should rename combinators
19:09:45 <shapr> call them Chickens instead
19:10:22 <Riastradh> Someone on c.l.scheme suggested renaming 'higher-order' functions to make them more appealing to PHBs, and proposed the name 'titanium' functions; and then, for continuations, to be more exotic, 'yttrium functions.'
19:10:30 <seth_> the docs for Network talk about a function installHandler in Posix.  Does anyone know where that lives?  Or do I go to the old library?
19:10:47 <shapr> also, my 54 lines make a standalone executable.... when it come to making Java byetcode run somewhere other than the system it was written on, stuntment are required.
19:10:52 <grem> seth_: you're alive... check this out ...
19:10:52 <Pseudonym> Darius: There's one issue you didn't spot in that code.
19:10:58 <grem> @karma seth_
19:10:58 <lambdabot> seth_ has a karma of 1
19:11:09 <seth_> grem: is that good or bad?
19:11:11 <shapr> Riastradh: that would probably work
19:11:13 <Pseudonym> endl on std::cout is useless, because it's auto-flushing on "\n".
19:11:23 <grem> good, shapr thinks i'm brown nosing...
19:11:26 <shapr> seth_: depends on whether you take the true Hindu viewpoint on karma
19:11:33 <Pseudonym> Prefer std::cout << "\n" rather than std::cout << endl
19:11:37 <Riastradh> Maybe 'osmium combinatorial functions' instead of just 'combinators.'
19:11:43 <seth_> grem: shapr may be right, but fortunately I'm immune to such tactics
19:11:49 * shapr laughs
19:12:01 <grem> seth_: I bet :)
19:12:20 <grem> seth_: i got you a porshe today, is that good brown nosing?
19:12:32 <seth_> grem: depends.  a 911?
19:12:41 * grem nods
19:12:43 <Pseudonym> I feel your pain, though, Darius.
19:13:38 <Darius> Yeah, but I prefer endl, easier to type ;) and no significant difference in this case.
19:13:44 <Pseudonym> True.
19:13:55 <grem> seth_: but in all seriousness, i am trying to learn some of this haskell stuff.  I'm looking at a socket program that uses threads... Needless to say i am slightly confused.
19:14:00 <shapr> Darius: http://c2.com/cgi-bin/wiki?SetTheBozoBit
19:14:11 <Pseudonym> I often berated students for it, though.  In C, calloc() is almost never what you want.  In C++, endl is almost never what you want.
19:14:22 <grem> Where is the information on the functions that come in with the import packages?
19:14:24 <seth_> grem: don't try to tackle threads and sockets at the same time.  Just play with threads first.
19:14:33 <Darius> True.
19:14:57 <seth_> grem: they are on the ghc site.  Also you can download the html's to your local disk, which I recommend.
19:14:58 <Pseudonym> I guess it is a matter of preference if there's no performance issue.
19:15:13 <grem> seth_: I have slightly bad news also... I can't rent a car... I'm too young
19:15:40 <seth_> grem: I figured.  we'll figure something out.
19:15:58 <grem> ya, i will call you tomorrow or talk to you online.. something
19:16:14 <seth_> grem: here is a good link:  http://www.haskell.org/onlinelibrary/
19:17:12 <grem> seth_: where can i find the API to download?
19:17:46 <seth_> grem: look on the ghc page.  there is a link there.
19:18:07 <grem> seth_: under documentation?
19:18:25 <seth_> grem: I think so.  look around, you'll find it.
19:25:58 <grem> seth_: I'll look around, be back later
19:31:55 <seth_> I want to use something from the old libraries.  Specifically, something in the Posix Process Primitives package.  What do I import?
19:32:59 <shapr> I'd guess -package posix and import Posix
19:35:09 <seth_> ok.  I tried import Posix, but not with -package posix.
19:47:56 * shapr bounces happily
19:52:40 <shapr> yay
19:52:44 <shapr> code is done for the day
19:58:06 * shapr goes to sleep
