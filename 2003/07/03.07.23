00:39:44 <pepitoelprisas> hey
00:41:20 <pepitoelprisas> a have a little question
00:42:17 <pepitoelprisas> someone know what do this function
00:42:18 <pepitoelprisas> code9 = do "A"	 	
00:42:19 <pepitoelprisas> ++
00:42:19 <pepitoelprisas> 	 do
00:42:19 <pepitoelprisas> 	 k<-"BBB"
00:42:19 <pepitoelprisas> 	 do return "CC"
00:42:20 <pepitoelprisas> 	 do "D"
00:42:29 <pepitoelprisas> without run it?
00:45:49 <adept> pepitoelprisas: i suppose it just makes compiler cry? :)
00:45:54 <earthy> err... is that indentation correct? :)
00:46:14 <pepitoelprisas> not
00:47:11 <reffie> hi
00:47:12 <pepitoelprisas> but if was for copy-paste ;)
00:47:20 <pepitoelprisas> hi
00:48:31 <pepitoelprisas> dont copile, only try to think what is the output
00:48:41 <adept> pepitoelprisas: me bad. I forgot that lists are monads too :(
00:49:04 <pepitoelprisas> lol
00:49:31 <adept> pepitoelprisas: so it returns "AD", right?
00:50:13 <pepitoelprisas> it was what i thought
00:50:18 <pepitoelprisas> but not
00:51:10 <pepitoelprisas> and i dont know why
00:52:58 <adept> pepitoelprisas: wait a sec. It will be "ADDD", right?
00:53:08 <pepitoelprisas> yes :)
00:53:14 <adept> pepitoelprisas: neat :)
00:53:46 <pepitoelprisas> but why iterate "do" sentence?
00:55:30 <adept> pepitoelprisas: think about k <- "BBB" line... rewrite it without do-notation. What will you get?
00:56:33 <ddarius> Or you could just write the latter part as a list comprehension (assuming you have a decent grasp of them)
00:57:20 <pepitoelprisas> but how would be it without do-notation?
00:57:50 <ddarius> Do you know the translation of do notation into >>= and return?
00:58:18 <pepitoelprisas> not, i´m a beguiner
00:59:42 <pepitoelprisas> any tutorial that explain it?
00:59:54 <earthy> what you wrote would be translated into  return ("A" ++ ("BBB" >>= \k -> (return "CC") >>= "D")); IIRC
01:00:38 <earthy> but I may *very* well be wrong
01:01:17 <ddarius> The outer return is unnecessary, also this (the original) code doesn't use a very consistent view.
01:02:07 <ddarius> (More) Consistently monadic (minus mplus) it would be return 'A' ++ do k <- "BBB";return "CC";return 'D'
01:02:38 <ddarius> (as well as removing the many superfluous do's)
01:03:04 <pepitoelprisas> but if you do it you have 2 returns
01:03:17 <pepitoelprisas> why is executed the 2º return?
01:03:35 <ddarius> return in Haskell doesn't mean the same thing as return in C (or similar languages).
01:03:49 <ddarius> By the way what other programming experience (if any) do you have?
01:04:49 <pepitoelprisas> c,c++,java,lisp,clips
01:05:06 <pepitoelprisas> but now i´m learnng this language
01:05:39 <adept> ddarius: taking into account that do { return "CCC" } doesnt do anything useful here, whole code could be reduced to :
01:05:43 <pepitoelprisas> then what do exactly return sentence?
01:05:45 <adept>  code9' = do {"A"} ++ do {"BBB" >>= \k ->  "D"}
01:06:00 <adept> pepitoelprisas: do you know what a monad is?
01:06:55 <adept> pepitoelprisas: "return" has type "return :: forall m a. (Monad m) => a -> m a", so it just "lifts" value into (some) monad m, in this case it's list monad
01:07:01 * earthy wonders why the do return "CC"   disappears in the semantics...
01:08:01 <earthy> oh, wait... the lifted "CC" is then bound without name to the "D", which is the same as "D"...
01:08:32 <adept> earthy: your code is wrong. not "(return "CC") >>= "D"", but ">> "D"" ...
01:08:51 <pepitoelprisas> :o, now i see
01:09:05 <earthy> adept: yea, I realised. or   (\foo -> "(return "CC")) >>= "D"
01:09:10 <ddarius> adept: first 'do { return "CCC" }' can be written 'return "CCC"', next, 'return "CCC"' is definitely not equivalent to ''
01:09:35 <pepitoelprisas> and what do exactly ">>=" operator?
01:09:43 <ddarius> Or did you mean the particular return "CC" from the original
01:10:04 <adept> ddarius: yes, that particular (return "CC)
01:10:12 <earthy> pepitoelprisas: it binds two monads of the same type together, injecting info
01:10:34 <earthy> (once again, if I understand correctly)
01:11:00 <pepitoelprisas> if the monads were strings ">>=" concat them
01:11:01 <pepitoelprisas> ?
01:11:08 <earthy> (please correct me if I don't, I'm sure I don't completely grasp monads)
01:11:15 <ddarius> adept: well I was going to get to that, or let others get to it ;)
01:11:15 <earthy> not quite
01:11:41 <adept> pepitoelprisas: from the base libraries "m >> k      = m >>= \_ -> k" 
01:12:25 <adept> pepitoelprisas: no, does not concat. Look " f >>= \x -> g(x)" is equal to "do { x <-g; g(x)}". Does it helps?
01:12:28 <earthy> see how wrong I can be. ;)
01:13:06 <ddarius> x <- f
01:13:17 <adept> ddarius: yes, thanks.
01:13:34 <adept> pepitoelprisas: So, " f >>= \x -> g(x)" is equal to "do { x <- f ; g(x) }"
01:13:58 <dennisb> instance  Monad []  where
01:13:58 <dennisb>     m >>= k          = concat (map k m)
01:13:58 <dennisb>     return x         = [x]
01:14:16 <andersca> hi dennisb!
01:14:21 <dennisb> hello
01:14:56 <pepitoelprisas> i think i need read other tutorial :S
01:15:04 <reffie> :@
01:15:52 <pepitoelprisas> adept: what tutorial do you recomend me?
01:16:04 <dennisb> pepitoelprisas: most people can use haskell without ever using do-notation for lists, as a beginner just use the do for IO (but keep in mind it can be used for other things)
01:16:53 <pepitoelprisas> my problem is that i dont understand the monads
01:17:03 <reffie> no one does :P
01:17:11 <pepitoelprisas> lol
01:17:20 <pepitoelprisas> 4[adept4] yes
01:17:26 <adept> pepitoelprisas: "monads for the working programmer", 'tackling the awkward squad" in the first place
01:17:28 <dennisb> monads is easy to understand for a programmer, it's just a very simple class
01:18:00 <pepitoelprisas> but
01:18:09 <adept> pepitoelprisas: especcialy "tackling ..." was helpfull for me, if i havent forgot everything :)
01:18:33 <dennisb> then you can use if for a lot of things, and you can think about it in a mathematical way. But you can use integers with +, *, and others without knowing all about algebra
01:18:34 <pepitoelprisas> ok thx
01:19:07 <dennisb> one can use monads even if you don't know all about it
01:19:08 <ddarius> For Haskell in general, I'd recommend reading The Gentle Introduction which is quick but decent, and Yet Another Haskell Tutorial seemed fairly sizeable when I skimmed it.
01:19:49 <ddarius> dennisb: Indeed using the IO monad is as straightforward as programming in most languages.
01:20:03 * earthy thinks he is braindamaged due to having learned Clean's Uniqueness Typing first.
01:20:41 <adept> pepitoelprisas: in general, look through "Using Monads" on http://www.haskell.org/bookshelf/
01:20:45 <earthy> all that monad stuff seems extremely awkward to me.
01:22:07 <pepitoelprisas> Tackling the Awkward Squad:
01:22:07 <pepitoelprisas> monadic input/output, concurrency, exceptions, and
01:22:07 <pepitoelprisas> foreign-language calls in Haskell
01:22:08 <pepitoelprisas> thx adept :D
01:22:08 <ddarius> From what (little) I know of Clean, uniqueness typing seems to be a (not completely) orthogonal concept to monads.
01:22:15 <dennisb> There is "just" 2 things to know about it. do is tranlated to an expression with >>= between all the parts. The >>= is overloaded so it can a be different function in different contexts. Above I pasted in the definition of >>= for lists
01:22:51 <dennisb> The translation from do to >>= is something one just have to learn
01:23:31 <pepitoelprisas> i have read some tutorials but they dont explain good what is a monad or how to use do-return
01:23:34 <ddarius> dennisb:  The tone of that last sentence makes it sound as if it were difficult.
01:23:39 <pepitoelprisas> they only use it for IO
01:23:41 <dennisb> not at all
01:23:59 <earthy> ddarius: it is. it's just that most of the justifications for monads disappear due to uniqueness typing
01:24:12 <adept> pepitoelprisas: then "How to declare the imperative" is for you, if i'm not mistaken once again
01:24:20 <dennisb> it's just something that you can't see when looking at the code, for a start you have to know that there is a translation
01:24:32 <earthy> thus allowing you to simple annotate stuff with `this is unique' and further writing in a fully functional style
01:25:46 <pepitoelprisas> adept: sorry for my english :(
01:25:47 <adept> earthy: do the allow you to get read of a state transformers as well? ;)
01:25:49 <dennisb> For IO the operation >>= is a sequence operator that makes the operation on the left happen before the operation on the right. It's important when you print characters that they don't come out in some random order, same thing for all other IO
01:26:01 <adept> adept: mine isn't better, i'm sure :)
01:26:38 <earthy> adept: well, :) you can program using different idioms
01:27:58 <adept> earthy: i'm just trying to undermine your "most of the justifications for monads disappear" statement ;)
01:28:27 <ddarius> Indeed, I was just about to comment on that.
01:29:26 <ddarius> About the only thing I readily see uniqueness typing replacing is the state/IO monad and even then you may still want monads to handle the plumbing for you.
01:30:14 <pepitoelprisas> some other manual that explain monad-do-return without use IO?
01:30:50 <adept> pepitoelprisas: anything on state transformers you'll happen to come across
01:31:00 <earthy> adept: *most*, not all. :)
01:31:55 <ddarius> earthy: I'd still say there are many benefits to monads still remaining even in the cases where the functionality overlaps with uniqueness typing, obviously all remain where it doesn't.
01:34:34 <pepitoelprisas> what exactly do "\_ -> k"? what is the input param of the function?
01:34:50 <earthy> pepitoelprisas: it dumps the input param (that's the _)
01:35:24 <earthy> ddarius: yes, but the *main* justification that people seem to give for using monads is that it allows you to deal with I/O and state stuff
01:36:09 <earthy> whereas uniqueness typing is a good alternative for that
01:36:30 * earthy has thought about adding uniqueness typing to haskell and what it would allow
01:36:47 <earthy> no longer would the IO monad have to be fully opaque: you'd be able to open it up :)
01:36:59 <adept> pepitoelprisas: "f >>= \xxx -> ..." binds _name_ xxx to whatever result f has. This name will be usable in the "..." block. If name is "_", then result is just sent to local analog of /dev/null :)
01:38:12 <pepitoelprisas> ./dev/null = screen?
01:38:43 <earthy> pepitoelprisas: ever heard of the term bitbucket?
01:38:45 <ddarius> earthy: Even in the particular case of IO/State I still think monads provide benefits that uniqueness typing doesn't (without effectively recreating monads).
01:39:08 <ddarius> (significant benefits to be more precise)
01:39:19 <earthy> such as? :)
01:39:33 <pepitoelprisas> earthy: not
01:39:40 <dennisb> pepitoelprisas: you know about function syntax? Like this: \a -> a+1
01:40:11 <ddarius> The small one before was hiding the plumbing which is a double-edged sword but (I think) beneficial more times than not.
01:40:14 <earthy> pepitoelprisas: it's where bits go when they die. :) (/dev/null == bitbucket == a device that can swallow any amount of bits and makes 'm disappear)
01:40:14 <pepitoelprisas> yes, a function that take one param a return the increment of the param
01:40:56 <dennisb> pepitoelprisas: good. Then this function \a -> 1, it always returns 1 and doesn't use the a. So why do we need to name the argument a. Well, we don't. We can write it \_ -> 1
01:40:58 <adept> pepitoelprisas: so "\_ -> x" is a 1-ary function (with 1 arg) that doesnt care about param (doesnt use it) and just returns x
01:41:00 <earthy> ddarius: I can see that use, yes.
01:41:47 <ddarius> A larger one is that since the monadic operations are abstracted away, you aren't tied to any particular monad.  So if I need a counter I have 'MonadState Int m =>'  and if someone wants to use another monad everything still works.
01:42:09 <ddarius> (assuming it's an instance of MonadState)
01:42:18 <pepitoelprisas> and then what is the value of "x"?
01:42:22 * earthy ponders
01:43:14 <dennisb> pepitoelprisas: it can be anything, in my example x was 1
01:43:15 <ddarius> I don't know how (if at all) Clean programmers handle these issues in general (without effectively recreating monads )
01:43:18 <earthy> so, what you're effectively arguing is that the actual implementationdetail of how a counter is implemented is abstracted away: it could be an int, but it could just as well be a list accumulating every element, if that is beneficial to you ?
01:43:33 <earthy> Clean has monads, that's not the point. :)
01:43:47 <earthy> I just wasn't taught them back in the day
01:44:12 <pepitoelprisas> "\_ -> x"?
01:45:01 <ddarius> earthy: No, I'm saying I can write code that uses an Int counter, but will work with a ReaderT Env (State Int), say, with no changes.  In explicit state passing style I don't (immediately) see how to do this.
01:45:21 <earthy> pepitoelprisas: \ is the function abstractor. _ is the argument. x is the result. x does not use _.
01:45:38 <pepitoelprisas> yes but x dont have a value
01:45:51 <dennisb> yes, x was just an example, change it to something with a value
01:46:02 <dennisb> (like the 1 in my example)
01:46:04 <pepitoelprisas> ahhh ok :)
01:46:05 <earthy> ddarius: thereby making your counter persistent, or what?
01:46:25 * earthy is starting out on haskell, btw
01:49:08 <ddarius> earthy: thereby making my code more general, I just label my functions with what features they need, if someone wants to use it with a monad that also supports other features beyond what I need my code will work without change.  Using explicit state passing, I'd have to change my code to get it to work with say, continuation passing style.
01:49:31 <earthy> ah, check
01:49:55 <ddarius> earthy: You are also right from before that it abstracts away from the particular implementation of "state effect" which has good sides and bad sides.
01:50:13 <earthy> (sorry, you keep speaking in abstract terms and I keep trying to add concrete examples and therefore we tend to misunderstand eachother)
01:51:10 <earthy> ddarius: the main bad side that I see is that suddenly you *have* to rely on a compiler having a correct implementation of things
01:52:44 <ddarius> But you can write your own monads, though this will never be as effective as compiler support.
01:58:09 * earthy ponders once again
01:59:13 <earthy> let me sketch what I want to do
01:59:39 <earthy> I want to build the software on a computer system, *all* the software on a computer system, using a functional language
01:59:54 <earthy> this includes drivers for hardware and such.
02:00:29 <earthy> now, to do this, I need significant control over how exactly things are laid out in memory, and dealt with
02:00:58 <earthy> thus, I want the language to allow me to specify that.
02:01:12 <earthy> with the IO monad as it currently is in Haskell I don't get to do that.
02:01:19 <earthy> that is my main gripe. :)
02:01:43 <earthy> other than that I'm all for it... ;)
02:04:05 <ddarius> For that level of control you'd have to implement the compiler yourself, so you have as much control over how IO works as you need ;)  However, I'm not sure how uniqueness typing achieves this (or how the IO monad fails).
02:05:17 <earthy> ddarius: I don't have to implement a C compiler myself if I want to do such things...
02:05:36 <earthy> but that's a cop-out. the problem is that the IO monad cannot be pulled apart
02:06:26 <earthy> thus you are completely stuck with whatever the implementation provides you in the way of dealing with state and such
02:06:49 <earthy> with uniqueness typing, you could simply pull the memory out of the world and deal with that
02:09:20 <ddarius> How do you mean "pull the memory out" or alternatively, what's wrong with an getMemory IO operation?  I'm pretty sure uniqueness typing and the IO monad are implemented conceptually the same way, the passing around of a "meaningless" token, which I imagine is optimized away in the actual code.
02:09:39 <earthy> myeah.
02:10:47 <ddarius> The only thing the IO monad does is hide the passing of the token, the only benefit that uniqueness typing provides on that account would have to come from having explicit access to the token.
02:10:49 <earthy> but for the fact that in the IO monad the `meaningless' token has to stay under the monad and you therefore cannot fork dealing with separate parts of IO
02:11:10 <earthy> thus, in clean:
02:11:19 <earthy> main :: World -> World
02:11:38 <earthy> (pseudocode, obviously)
02:12:05 <Heffalump> well, if you view IO as ST World, then in Haskell, main :: World -> ((), World)
02:12:18 <earthy> yeah
02:13:43 <earthy> main w = (do_something_with_the_filesystem (getFileSystem w), do_something_with_the_screen (getScreen w))
02:13:54 <earthy> (I need to recheck this stuff...)
02:16:07 <ddarius> Are these supposed to be concurrent?  If not then do fs <- getFileSystem; a <- do_sthn_fs fs; screen <- getScreen; b <- do_sthn_screen; return (a,b) does the same, and with concurrency the forkIO can do it as well.
02:16:35 <earthy> ddarius: they are supposed to be collaterally executed
02:17:00 <earthy> up to the implementation to either interleave them or sequence them or run them in parallel
02:21:25 <Heffalump> how do you guarantee clean separation, given that there might be devices in the filesystem that write to the screen?
02:21:54 <ddarius> earthy: Is that the standard behavior (or even acceptable behavior) in Clean for code like that?  And wouldn't the potential for concurrency be something you'd definitely not want to be implementation defined (in general with side-effects, and specifically if you were working on an OS say)
02:22:16 <earthy> ddarius: it is acceptable behaviour
02:22:35 <earthy> ddarius: on a multiprocessor machine I'd expect things to run in parallel
02:22:56 <earthy> (note: this is based on 7 year old to 8 year old knowledge, it may well have changed :))
02:23:14 <earthy> heffalump: you don't. >:) at least, they didn't, back then.
02:23:38 <Heffalump> ah :-)
02:24:48 <ddarius> earthy: If that's acceptable and I'm assuming that the two functions can manipulate the things they recieve in a side-effecting manner, than that would break purity.
02:25:12 * earthy nods
02:25:27 <Heffalump> actually, I don't quite see how
02:25:46 <Heffalump> there's no problem in IO with concurrency, why would there be in uniqueness typing?
02:26:32 <Heffalump> (assuming the uniquness value is opaque and doesn't admit equality tests)
02:26:36 <earthy> heffalump: there's this thing in uniqueness typing where you can drop the unique annotation, but then you can no longer modify the uniquely annotated object.
02:27:43 <earthy> however, in parallel to that a thread might be running that still *does* have a unique annotation to the object. it can modify that object and then if you read from it, you get a different result
02:28:26 <Heffalump> so without the uniqueness type you can read but can't write?
02:28:39 <Heffalump> but there might also in parallel be another process that modifies a file
02:29:02 * earthy nods
02:29:05 <earthy> IIRC, once again
02:29:35 <Heffalump> I don't see how any of this violates referential transparency, if you can't observe equality of uniqueness tokens
02:29:40 * earthy thinks about it... that is actually expected behaviour for files. ;)
02:29:44 <earthy> heffalump: exactly.
02:30:05 <earthy> well, there aren't uniqueness tokens as such.
02:30:06 <Heffalump> so where's the impurity that seemed to be being discussed above?
02:30:13 <Heffalump> well, implicit ones
02:30:23 <Heffalump> from the point of view of the language semantics there are
02:30:38 <earthy> nope. the object has a restriction on it
02:30:49 <Heffalump> oh, right, sorry
02:33:31 <earthy> I think the thing is that uniqueness typing is a direct hint to the compiler `look, tosh, you can destructively update this thingamajig, as it's unique, see?' whereas with the monad approach that is fully implicit
02:33:42 <earthy> thus the compiler has to do more work with monads
02:34:08 <Heffalump> but I'd imagine IO is implemented like ST
02:34:16 <Heffalump> where you have exactly the same hint
02:34:28 * earthy nods
02:35:02 <ddarius> (In GHC IO -is- ST last I looked, if I'm not completely crazy.  Specifically, ST RealWorld#)
02:35:42 <Heffalump> yeah, I thought it might be
02:35:59 <Heffalump> the only reason I didn't claim it was is that it probably didn't start out that way, since ST is newer than IO
02:36:29 * Heffalump wonders how often unsafeIOtoST gets used
02:37:06 <earthy> so am I right in assuming that if you were so inclined you *could* change ghc so that the IO monad is no longer fully opaque but that you can pull out single files and then transform them under ST?
02:37:36 <Heffalump> I don't think so.
02:37:44 <Heffalump> remember the type of runST
02:37:46 <earthy> and even allow you to pull single files out of ST and then only be allowed to read?
02:37:53 <earthy> @type runST
02:38:05 <earthy> (what, lambdabot sick?)
02:38:12 <Heffalump> it's still my version running
02:38:55 <Heffalump> where is @type implemented?
02:38:56 <ddarius> I still don't see what having explicit access to the token gives you.  You can only do to it what operations the implementation provides, which looks equivalent to the primitive IO operation a Haskell implementation provides.
02:39:30 <ddarius> @type calls Hugs and doesn't load any modules so runST wouldn't work anyways.
02:39:48 <Heffalump> the trouble about making something external into an ST operation is that runST really does generate a pure functional result
02:39:48 <ddarius> (Though it could say something to that effect rather than nothing)
02:40:04 <Heffalump> ddarius: where's it implemented?
02:40:19 <earthy> interesting. my hugs barfs on loading ST.hs
02:40:23 <ddarius> There should be a TypeModule (I think that's what it's called)
02:40:35 <Heffalump> ah, yes, got it
02:41:29 <earthy> heffalump: but then you'd no longer be allowed to write, as it's not under ST anymore...
02:41:30 <Heffalump> @type foldr
02:41:30 <lambdabot> foldr :: (a -> b -> b) -> b -> [a] -> b
02:41:52 <Heffalump> earthy: even just reading inside ST would be a problem
02:42:08 <Heffalump> runST readFromFile should be a pure Haskell value
02:42:20 <Heffalump> but two different invocations could give different results
02:42:28 <earthy> no, reading would be allowed without having ST... as it is (IIRC) without uniqueness annotation in Clean
02:42:43 <Heffalump> well, that would violate purity
02:42:52 <Heffalump> whether or not you require ST, it would violate purity
02:43:35 <earthy> okay, back to reading chapter 4.3 of the Clean Book
02:44:19 <Heffalump> oh yes, what I was saying about equality tests is rubbish
02:44:21 <earthy> I'm probably missing one important detail, and it's nagging at the back of my brain.
02:44:44 <Heffalump> if you can do things in purely functional code, then you can guarantee equality of things simply by copying the same thing
02:44:51 * earthy nods
02:45:03 <Heffalump> and in purely functional code, that means you can break referential transparency
02:45:47 <earthy> which Clean doesn't really allow you to do, afaik
02:46:04 <Heffalump> but you just said you can remove uniqueness types if you only read?
02:46:18 * Heffalump thinks that breaks referential transparency
02:46:23 <pepitoelprisas> look this
02:46:24 <pepitoelprisas> http://www.willamette.edu/~fruehr/haskell/evolution.html
02:46:31 <Heffalump> is that the factorial thing?
02:49:32 <earthy> yes, it is
02:53:03 <ddarius> pepitoelprisas: is there any particular reason we are looking at this?  I imagine many here have seen it and it is readily linked from haskell.org.
02:54:17 <pepitoelprisas> then sorry, i only found it, and it seen me interesant
03:07:35 * d33p is away: bizness
03:14:11 <earthy> see... I lost a tiny detail.
03:14:18 <earthy> important though. :)
03:14:48 <earthy> once you've dropped the uniqueness property of an object, you can then no longer modify it *ever*
03:15:35 <earthy> thus, if you have (say) two threads, and you lose the uniqueness property of an object in one of the two threads, that loss is propagated back up to the start of the program and therefore you lose it in the other thread as well
03:16:02 <earthy> which fixes referential transparency :)
03:21:47 <earthy> (as the *result* needs to be unique for a uniqueness property to hold)
03:44:30 <Heffalump> errm, but still another process could modify the file
03:50:49 <earthy> heffalump: yes. *so*? You're fucked in that sense *anyway*
03:54:20 <Heffalump> earthy: well, not in Haskell...
03:54:31 <Heffalump> cos the *read* has to be in the IO monad too
04:02:35 <earthy> heffalump: yes, but even in haskell, 2 reads from the same file don't guarantee identical data
04:03:24 <earthy> not even 2 reads from the same file at the same position
04:03:32 <earthy> even *if* there is no write in between
04:03:36 <Heffalump> earthy: I know that, but the result of a read is IO String, not String
04:03:45 <Heffalump> you appear to be saying that in Clean it can be String
04:05:23 <earthy> the type for freadc is u:File -> (Bool, Char, u:File)  in clean
04:05:59 <Heffalump> but didn't you say you can lose the u: if you're just reading?
04:06:09 <earthy> yes.
04:06:36 <earthy> (the u: is `optionally unique', by the way)
04:06:42 <kosmikus> this is strange indeed
04:08:11 <Heffalump> so I can write the function readtwice :: u:File -> (Char,Char) like this: readtwice f = (mid $ freadc f,mid $ freadc f) ?
04:08:20 <Heffalump> (where mid (_,a,_) = a)
04:09:26 <earthy> heffalump: yes. but you'd be reading the exact same character, as the f's are identical
04:09:48 <earthy> (and the current position of the file is part of the File object and can not be modified directly)
04:10:20 <kosmikus> it seems that the complete state of the file is encapsulated in the File object
04:10:30 <earthy> that's why the freadc returns a new File object
04:10:36 <kosmikus> yes, ok
04:10:37 <earthy> exactly
04:12:38 <kosmikus> so the only thing that is done differently if the File pointer is unique is that the system does not create a new File object with the modified position in it, but rather destructively updates the unique File object
04:12:46 <Heffalump> but what if the file changes inbetween the two reads?
04:13:18 <kosmikus> Heffalump: I'd guess it is Clean's responsibility to cache the first result
04:13:45 <Heffalump> hmmm.
04:14:03 <Heffalump> that sounds like a huge space leak waiting to happen...
04:14:37 <earthy> actually, Clean is a graph-reduction language
04:15:56 <Heffalump> what difference does that make?
04:16:14 <earthy> so both freadc's read from the exact same File object and the exact same buffer
04:16:36 <earthy> and unless both freadc's have been reduced, the buffer cannot be freed
04:17:56 <kosmikus> still -- the risk of a huge space leak remains
04:18:29 <Heffalump> actually, that's probably inevitable in any lazy language for that code, thinking about it
04:18:35 <kosmikus> but I guess you're encouraged to use unique files anyway
04:18:54 <kosmikus> yes -- if you want that functionality, you have to pay the price
04:19:00 <earthy> indeed
04:29:00 <ask_hell> hey
04:29:11 <ask_hell> what does the operator +++ mean ?
04:31:04 <dark> Depends on how it's defined... it's not in the Prelude.
04:32:21 <ask_hell> so it is imported ? I have "import ParseLib"
04:32:24 <ask_hell> from hugs
04:33:31 <dark> Then it's probably from there, in which case I don't know what it means :)
04:33:33 <Heffalump> it'll be from the parser, yes
04:33:38 <Heffalump> I think it's some kind of choice operator
04:44:59 <earthy> p +++ q            = first (p `mplus` q)
04:45:33 <earthy> that certainly corroborates the choice operator interpretation :)
04:45:55 <ask_hell> right
05:29:30 <shapr> hi!
05:29:45 <saz> hi!
05:29:51 <shapr> what's up?
05:30:07 <saz> not a whole lot
05:37:35 * shapr bounces cheerfully
05:41:04 * Igloo bounces a bit too
05:41:47 <shapr> hi Igloo, what's up?
05:42:07 <Igloo> GHC compilation and failed-compilation mainly  :-)
05:42:17 <shapr> oos
05:42:18 <shapr> oops
05:42:26 <shapr> now that I have a colo box
05:42:36 <shapr> I wonder if I can set up a darcs repo for #haskell to try out
05:43:13 <shapr> aha, pushable repos
05:43:18 <Igloo> You could try moving haskell-libs to it
05:43:23 <shapr> yes, I'd like to
05:50:27 <Heffalump> hi shapr
05:50:34 <Heffalump> shall I kill off my lambdabot?
05:51:04 * Heffalump thinks that darcs could do with more testing before we try to use it for something real
05:51:29 <shapr> lambdabot: @yow
05:51:30 <lambdabot> Yow!  I forgot my PAIL!!
05:51:33 * shapr cheers
05:51:42 <Heffalump> my one doesn't have @fact
05:51:56 <shapr> have you tried building HToolkit?
05:52:02 <Heffalump> nope
05:52:11 <Heffalump> I can't really be bothered getting stuff like that working, it's not what I'm playing with atm
05:52:20 <Heffalump> I just put my one on cos yours wasn't here and neither were you
05:52:20 <shapr> what are you playing with?
05:52:35 <Heffalump> at the moment, stopping it dying when it loses connection to the IRC server
05:52:44 <shapr> ah, resumable connection?
05:52:49 <Heffalump> I checked in the catching exceptions stuff last night
05:52:52 <shapr> yay
05:52:54 * shapr cvs up
05:53:04 * Heffalump kills off his one
05:54:52 <shapr> soon I'll have it running on the colo box, and then I won't have to worry about my machine overheating
06:00:10 <shapr> I usually use -O2 -fvia-C you think that makes any significant difference?
06:00:29 <Heffalump> no idea
06:00:33 <Heffalump> I thought -fvia-C slows it down
06:01:22 <shapr> I thought it made it faster
06:01:31 <Igloo> -O2 implies -fvia-C
06:01:46 <shapr> oh
06:03:00 <Heffalump> oh, ok
06:03:46 <shapr> I'd like to have some sort of @version command that includes build time
06:03:55 <shapr> @yow
06:03:55 <lambdabot> My pants just went to high school in the Carlsbad Caverns!!!
06:04:00 <shapr> @fact yow
06:04:01 <lambdabot> Nothing
06:04:15 * Heffalump tries to think of something apart from emptying the topic that'd cause an error
06:04:37 <shapr> @ply e2
06:04:37 <lambdabot> not a valid move
06:04:40 <shapr> @ply e2 e3
06:04:41 <lambdabot> ../chess/Move.hs:72: Non-exhaustive patterns in function conv
06:04:47 <shapr> tada
06:04:59 <Heffalump> previously it'd have died at that point?
06:05:11 <shapr> yup
06:05:13 <Heffalump> cool.
06:05:59 <shapr> yes, this means I can finally track down the Prelude.head error
06:06:02 * shapr dances cheerfully
06:06:05 <Heffalump> which error?
06:06:25 <shapr> it's the reason lambdabot has been so flaky lately
06:06:39 <Heffalump> did you read the checkin message, btw?
06:06:45 <shapr> just a bit so far
06:06:54 <Heffalump> essentially errors will be reported in one of two places
06:07:09 <Heffalump> either in response to the command, if it was caused by one
06:07:13 <Heffalump> or on the console, if not
06:07:26 <shapr> oh, I see
06:07:27 <shapr> nifty
06:07:31 * Heffalump goes for lunch
06:07:34 <shapr> thanks Heffalump 
06:07:38 * shapr bounces
06:11:27 <shapr> oh, HToolkit 1.0 released
06:11:28 <shapr> yay
06:12:12 <Heffalump> what is HToolkit?
06:12:17 * Heffalump really goes for lunch, though :-)
06:12:19 <shapr> heh
06:12:42 * shapr boings happily
06:12:47 <shapr> @fact htoolkit
06:12:48 <lambdabot> Nothing
06:12:50 <shapr> @fact htoolkit http://htoolkit.sourceforge.net/
06:12:51 <lambdabot> set htoolkit to http://htoolkit.sourceforge.net/
06:13:41 <shapr> seems HToolkit is by Krasimir Angelov, the guy who ported Clean's ObjectIO to Haskell on win32
06:14:06 <shapr> says HToolkit came from finding out that ObjectIO is very bound to win32, and wanting something that wasn't
06:15:01 <shapr> http://htoolkit.sourceforge.net/screenshots.html
06:15:54 <shapr> seems the sf.net cvs server is having trouble
06:16:25 <shapr> Heffalump: I think running a mirror of haskell-libs is a good darcs test, what do you think?
06:16:41 <earthy> The installation of wxWindows is finished.
06:17:02 <earthy> okay, that sets my baseline for wxHaskell. :)
06:17:07 <shapr> cool, lambdabot has nearly reached its six month anniversary
06:17:39 --- topic: set to '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","http://haskell.org/~petersen/rpms/","lots of cool debs in the haskell-experimental archive - see http://haskell.org/hawiki/DebianUsers","HToolkit 1.0 - http://htoolkit.sf.net/"]' by shapr
06:18:13 --- topic: set to '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","http://haskell.org/~petersen/rpms/","lots of cool debs in the haskell-experimental archive - see http://haskell.org/hawiki/DebianUsers","HToolkit 1.0 - http://htoolkit.sf.net/","wxHaskell 0.1 - http://wxHaskell.sf.net/"]' by shapr
06:40:18 <SyntaxPolice> mornin
06:40:35 <shapr> g'mornin SyntaxPolice 
06:41:04 <earthy> g'maen SP
06:43:15 <shapr> hoi reffie 
06:44:27 <reffie> hej
06:44:34 <SyntaxPolice> hihi
06:44:44 <shapr> reffie: talar du svenska?
06:45:49 <reffie> no :P
06:45:57 * reffie is italian
06:46:01 <shapr> oh, nifty
06:46:08 <reffie> :)
06:46:27 <shapr> spraakt u nederlands?
06:46:36 <shapr> not that I do :-)
06:46:38 <earthy> s/spraakt/spreekt/
06:46:47 <reffie> ik hou van jou..
06:46:56 <earthy> alleen van jou...
06:47:50 <earthy> (sorry, I'm dutch. :))
06:48:12 <shapr> it's okay, I'm a US citizen
06:48:16 <earthy> no parlo italiono. :)
06:48:30 <earthy> err.. italiano. :)
06:48:33 <shapr> there must be a better word than "american" since that could apply to any citizen of north or south america
06:48:49 <earthy> i jag ne talar svenska
06:49:11 <earthy> USAnian
06:49:12 <shapr> jag talar inte svenska
06:49:21 * Heffalump appears
06:49:24 <shapr> poof
06:49:32 <earthy> that's what I meant. :)
06:49:50 <earthy> it's just that I'm learning french at the moment that I tend to start *really* mixing things up :)
06:49:58 <shapr> c'est bien
06:50:09 <shapr> j'aime les française
06:50:21 <earthy> ah, mais oui. la langue est tres tres belle.
06:50:40 <shapr> aussi les française est tres tres jolie
06:50:43 <Heffalump> France annoys me.
06:50:58 <shapr> j'habite avec une française
06:51:01 <earthy> et, car je veux fair vacances en france, tres practicabl
06:51:02 <earthy> +e
06:51:14 <shapr> je suis d'accord
06:51:16 <earthy> shapr: did that too for about a year. ;)
06:51:20 <shapr> heh
06:51:26 <shapr> I've been doing it for four
06:51:28 <earthy> unfortunately, she spoke fluent german. :)
06:51:34 <shapr> so does mine
06:51:42 <Heffalump> they keep letting their lorry drivers or dock workers illegally blockade ports and things
06:51:44 <earthy> so my german improved rather more than my french. ;)
06:52:04 <shapr> mine prefers to speak english as much as possible
06:52:26 <shapr> quelle dommage
06:52:48 * shapr fights Python
06:52:59 <shapr> I'd rather be writing Haskell.
06:52:59 * earthy doesn't anymore
06:53:10 <earthy> Python is a pain
06:53:17 <earthy> beyond a certain size of program
06:53:18 <shapr> I like Python mostly
06:53:26 <earthy> `mostly'. :)
06:53:32 <shapr> but the more I learn about Haskell, the more I prefer it.
06:54:20 <shapr> I wish I could do all my webdev work in Haskell.
06:55:06 <reffie> i like ruby.
06:55:38 <shapr> I like significant whitespace
06:55:43 <shapr> and I like functional languages
06:56:01 <dark> shapr: I'm doing mine in PHP :)  What libraries to you use for it?
06:56:06 <reffie> ruby is great to do quick stuff..
06:56:18 <reffie> i mean: to do stuff quickly
06:56:30 <shapr> dark: at the moment I use Zope (written in Python) for 99% of my web work
06:57:06 <dark> shapr: And when you use Haskell?
06:57:22 <dark> Main reason I'm using PHP right now is that I'm using an existing GPLed project as a basis and it's in PHP.
06:57:34 <dark> But rewriting the whole thing in Haskell might be an option :)
06:57:36 <shapr> I've used the CGI library with Hugs some, but I want to use WASH
06:57:57 <dark> I'm going to need bigtime database access.
06:58:26 <shapr> HToolkit has working postgresql bindings for Haskell
06:58:35 <dark> Also, it's going to be extremely stateful, not sure if Haskell will be suited :)  But it'd get rid of my main annoyance with PHP: having to do tricks to make sure that the HTTP headers are output before any text is.
06:58:45 <shapr> I do wish HaskellDB were ported to GHC though
06:58:59 <shapr> lambdabot uses postgresql
06:59:01 <shapr> @fact htoolkit
06:59:02 <lambdabot> http://htoolkit.sourceforge.net/
06:59:14 <dark> Ah but I can just feel the thundering horde of mysql weenies that will descend upon my code as soon as I make it depend on postgres.
06:59:29 <shapr> htoolkit has odbc/pg/mysql bindings
06:59:31 <dark> Already the ground shakes a bit.
06:59:35 <shapr> though I've only tried the pg binding
06:59:37 <dark> Oh, that's cool then :)
06:59:58 <shapr> the best solution would be HaskellDB running on top of HToolkit
07:00:07 <dark> Any way to get persistent connections?
07:00:34 <dark> It's going to be a game so there will definitely be fanatics clicking away at 20 hits per second or something.
07:01:10 <shapr> only way to make persistent connections is to carry the Connection around in a state monad
07:03:20 <Heffalump> or use a Reader monad if you only need to distribute it downwards
07:04:11 <shapr> ?
07:04:24 <shapr> what's a Reader monad?
07:04:39 <Heffalump> like a State monad, but with no update ability
07:04:43 <shapr> oh
07:04:48 <shapr> a read-only state monad
07:04:50 <shapr> that's spiffy
07:05:01 <Heffalump> lambdabot uses one
07:05:27 <shapr> yes it does
07:06:02 <shapr> maybe per-module state should be moved around to have some Reader  state
07:17:00 <shapr> hi atom-z 
07:17:03 <shapr> hello philiKON 
07:17:07 <philiKON> hi
07:17:13 <shapr> what do you know about Haskell already?
07:17:15 <atom-z> does haskell have GUI libs?
07:17:27 <atom-z> shapr: that people say i should be using it :)
07:17:27 <shapr> atom-z: yes, wxHaskell 0.1 was announced today
07:17:28 <philiKON> shapr: it's a functional language :)
07:17:36 <shapr> good answers :-)
07:17:38 <philiKON> with a quite mathematical notation
07:17:51 <shapr> yah, it is
07:17:56 <atom-z> shapr: what about GTK, winapi?
07:18:01 <shapr> that's mostly because of referential trasparency and algebraic datatypes
07:18:03 <philiKON> e.g. list comprehension (forgive me when i use the wrong term here)
07:18:04 <shapr> atom-z: yes, those also
07:18:13 <shapr> that's the right term
07:18:22 <philiKON> atom-z: wxWindows uses gtk on unix and win32 on windows
07:18:37 <philiKON> shapr: how does it compare to common lisp?
07:18:42 <shapr> there's also gtk+hs and gtk2hs which are gtk1.x and gtk2.x bindings
07:18:54 <shapr> philiKON: common lisp isn't purely functional, and it's also really huge :-)
07:19:00 <atom-z> philiKON: yeah but wxwindows isnt very good
07:19:10 <shapr> atom-z: http://www.haskell.org/libraries/#guigs
07:19:22 <philiKON> shapr: yeah, 1100 symbols or so.
07:19:31 <philiKON> so haskell is purely functional? no OO?
07:19:56 <shapr> purely functional means 'function' in the mathematical sense
07:20:03 <shapr> for each input, you must return the same output
07:20:14 <shapr> every call to a function can be replaced by the result of that call
07:20:29 <philiKON> so it's good for math
07:20:33 <shapr> it is
07:20:38 <shapr> it's also good for IRC bots
07:20:39 <shapr> @yow
07:20:40 <lambdabot> Yow!  Now we can become alcoholics!
07:20:51 <kosmikus> atom-z: what's the problem with wxWindows?
07:21:04 <Igloo> shapr  :-)
07:21:11 <shapr> philiKON: have you used map, filter, reduce, lamdba in Python?
07:21:21 <philiKON> shapr: yes
07:21:31 <shapr> Haskell is much further in that same direction
07:21:51 <atom-z> kosmikus: its somewhat bloated. it doesnt use the gtk+ treeview widget, it uses its own for example (iirc)
07:21:57 <shapr> referential transparency is the real name of the "works like an equation" concept
07:22:00 <philiKON> shapr: i get it
07:22:04 <philiKON> (i think)
07:22:13 <shapr> I wonder if @eval is being happy today
07:22:23 <shapr> @eval map (\x . x + 1) [1,2,3]
07:22:24 <lambdabot> [2, 3, 4]
07:22:39 <shapr> @eval map (+ 1) [1,2,3]
07:22:39 <lambdabot> (line 1, column 6):
07:22:39 <lambdabot> unexpected "+"
07:22:39 <lambdabot> expecting simple term
07:22:40 <kosmikus> atom-z: but in turn it supports more platforms, doesn't it?
07:22:42 <shapr> fooey
07:22:44 <philiKON> cool. wee need that for pyn
07:23:06 <kosmikus> and it seems to be in active development, so there are chances that it will improve
07:23:08 <shapr> philiKON: referential transparency gives you partial application, meaning you can fill in any argument of a function, and then use that function for other stuff
07:23:11 <atom-z> kosmikus: gtkmm works on the platforms i code for :)
07:23:55 <shapr> philiKON: this is the first module I wrote: http://kungens.kemi.fi/~shae/src/haskell/Mandelbrot-0.1.hs
07:24:31 <shapr> philiKON: some exciting features of Haskell are, no loops, no variables (only single assignment 'constants'), no side-effects
07:24:51 <atom-z> shapr: thats unlike any code i've seen before
07:24:51 <shapr> you can still write loops with recursion though
07:25:07 <shapr> atom-z: it's good for brain stretching
07:25:08 * Heffalump wonders in what way those are features.
07:25:35 <shapr> length [] = 0
07:25:46 <shapr> length (x:xs) = length xs + 1
07:25:53 <atom-z> shapr: yeah, but what makes it better than other languages?
07:26:10 <shapr> atom-z: more abstraction
07:26:13 <dark> atom-z: In my opinion, its expressive type system.
07:26:13 <Igloo> Laziness, elegance, syntax
07:26:18 <shapr> you can write at a higher level
07:26:33 <dark> atom-z: I often find that after I fix all the type errors (which the compiler warns abount), my program also works correctly :)
07:26:38 <shapr> atom-z: you get all the benefits of Python with all the benefits of C
07:26:42 <o3_> atom-z: executive summary: do more stuff in less lines
07:26:52 <shapr> yah, more stuff in less lines, I like that.
07:27:06 <o3_> plus, strong type checking + type inference -> catch bugs far earlier before compilation, rather than after
07:27:16 <shapr> atom-z: have you written C or Java?
07:27:33 <dark> shapr: All the benefits of C?  I wouldn't go that far.  We wouldn't need FFI in that case :)
07:27:41 <atom-z> i wouldnt say those languages are in the least similar, but i code in C all the time
07:27:46 <shapr> well, that's true.. many of the benefits of C
07:27:59 <dark> Suddenly I have visions of Hinux.
07:28:18 <o3_> shapr: http://www.perl.com/pub/a/2000/12/advocacy.html
07:28:20 <shapr> atom-z: Haskell does static typing like C, but 95% of the time, it can figure out the types for itself
07:29:08 <shapr> I call it 'compile time dynamic typing' but people complain about that :-)
07:29:08 <kosmikus> C does not have static typing
07:29:13 * kosmikus hides
07:29:21 * shapr grins
07:30:08 <shapr> hm, I should port some Python code to Haskell, that would be a good comparison maybe
07:30:19 <atom-z> yeah
07:30:32 <shapr> one feature of Haskell is lazy evaluation
07:30:57 <shapr> basically, something isn't evaluated until I actually use it
07:31:07 <shapr> that lets you work with infinite sequences, like [1..]
07:31:14 <shapr> which is the set of all Integers starting with 1
07:31:15 <atom-z> in terms of speed thats probably not a good thing
07:31:35 <shapr> it's a tradeoff in my experience, sometimes it's faster, sometimes it's slower
07:31:46 <atom-z> faster than what?
07:31:53 <shapr> for example, "head (filter (> 5) [1..])"
07:31:57 <shapr> couldn't be done in Python
07:32:11 <shapr> because the filter would try to run on every item of the infinite sequence
07:32:24 <shapr> head pulls out the first item of its argument
07:32:44 <atom-z> yeah but in python you would use an array
07:32:49 <atom-z> err list
07:32:53 <shapr> since everything happens 'on demand' only [1,2,3,4,5,6] is ever evaluated
07:32:55 <philiKON> re
07:33:46 <shapr> atom-z: for more brain twisting stuff, there's "fib = 1 : 1 : zipWith (+) fib (tail fib)"
07:33:57 <atom-z> ok tell me what that does
07:34:03 <shapr> you can construct an infinite list of your own with "ones = 1 : ones"
07:34:18 <dark> atom-z: Comparing compiled Haskell to interpreted Python is not very useful anyway :)
07:34:39 <shapr> there's something called the "credit card transformation" where you can use the name you're just defining
07:35:07 <shapr> everytime the list named "ones" looks for the next item, it looks at its own definition and returns another 1
07:35:24 <shapr> with this "fib = 1 : 1 : zipWith (+) fib (tail fib)"
07:35:27 <philiKON> shapr: wow, it really is like math. infinite sequences...
07:35:37 <shapr> the first two items of the sequence are [1,1
07:35:59 <shapr> the third item is the result of adding together the first and second items
07:36:09 <shapr> [1,1,2
07:36:10 * SyntaxPolice dances around
07:36:20 <atom-z> if i need to write a program to calculate something... i think i know what to use :)
07:36:24 <shapr> the fourth item is the result of adding the second and third items
07:36:29 <SyntaxPolice> shapr: is ones tail of jones?
07:36:38 <shapr> heh
07:36:44 <shapr> must be
07:37:16 <shapr> atom-z: once you see algebraic datatypes, I think you'll wish for them in Python :-)
07:37:36 <atom-z> algebraic data types?
07:37:36 <shapr> data Seasons = Winter | Summer | Fall | Spring
07:37:52 <shapr> that's a boring enumerated type, probably looks like some C you've done
07:38:04 <atom-z> yeah:
07:38:24 <shapr> hm
07:38:28 * shapr looks for a good tree type
07:38:51 <shapr> someone suggest a good algebraic tree type?
07:39:03 <andersca> rbtrees
07:39:04 <andersca> ?
07:39:08 <shapr> sure, anything
07:39:12 <dark> data Tree a = Empty | Tree a (Tree a) (Tree a)
07:39:31 <shapr> yah, that's nice
07:39:51 <dark> That's pretty much what a FiniteMap looks like, except that FiniteMap also has a size field.
07:40:04 <shapr> FiniteMap = dictionary in Python
07:41:05 <shapr> so, I pasted that Tree into a buffer, and dropped the buffer into GHCi
07:41:09 <shapr> *ProtoTree> Tree 1 (Empty) (Empty)
07:41:09 <shapr> Tree 1 Empty Empty
07:41:19 <dark> Note that the "a" here can be any type, so for example a "Tree Integer" is a tree of integers and a "Tree [Char]" is a tree of strings.
07:41:55 <shapr> *ProtoTree> Tree "ab" (Tree "bc" (Empty) (Empty)) (Tree "cd" (Empty) (Empty))
07:41:55 <shapr> Tree "ab" (Tree "bc" Empty Empty) (Tree "cd" Empty Empty)
07:42:00 <dark> GHCi figured out that shapr's tree was a tree of integers because he used a "1" there :)
07:42:15 <shapr> right, I didn't have to tell it the types, it figured it out for itself
07:42:36 <shapr> algebraic types are really nice when you want to describe the 'shape' of some data
07:42:59 <shapr> Binary trees, XML trees, Cons lists, lots of good stuff
07:43:31 <shapr> philiKON, atom-z: any questions so far?
07:43:45 <atom-z> are they like structs?
07:43:49 <philiKON> shapr: sorry, writing mails :)
07:44:14 <shapr> atom-z: I haven't used C very much, so I can't effectively compare them.
07:44:21 <atom-z> ic
07:44:21 <shapr> but I think they're similar
07:44:23 <philiKON> agebraic data types are cool
07:44:47 <dark> atom-z: A simple type with one constructor is like a struct.  Types like "Tree Int" are more like unions.
07:45:07 <atom-z> dark: ic
07:45:36 <atom-z> dark: so only one part of a Tree Int can be used at any one time?
07:45:52 <shapr> you mean one branch or the other?
07:45:58 <dark> atom-z: Hmm... it's more that every value of type Tree Int is either an Empty or a Tree.
07:46:06 <atom-z> ic
07:46:49 <shapr> lesse, I could talk about partial application, typeclasses, ease of defining new operators..
07:47:11 <dark> shapr: function types?
07:47:15 <shapr> oh, fold, scan, until, iterate, and fun stuff like that
07:47:28 <shapr> you mean add :: Int -> Int -> Int ?
07:47:46 <shapr> it's a good place to start to talk about partial application
07:48:00 <atom-z> haskell has a really odd syntax
07:48:11 <shapr> atom-z: if you want to give an explicit type to a function, you could say:
07:48:17 <shapr> add :: Int -> Int -> Int
07:48:23 <shapr> and the function body could be
07:48:27 <shapr> add x y = x + y
07:49:17 <shapr> since Haskell is somewhate based on typed lambda calculus, under the hood, every function takes one argument and returns one argument
07:49:24 <atom-z> whats def(x,y):\n\treturn x + y in haskell
07:49:49 <shapr> atom-z: what function name?
07:49:59 <philiKON> add
07:50:02 <atom-z> yeah
07:50:06 <shapr> it's just what I wrote above
07:50:10 <shapr> add x y = x + y
07:50:13 <philiKON> isn't that what you just typed?
07:50:15 <philiKON> yeah
07:50:29 <shapr> or if you like using anonymous functions: (\x y -> x + y)
07:50:34 <atom-z> whats the add :: Int -> Int -> Int bit though?
07:50:35 <philiKON> and add :: Int -> Int -> Int is the declaration for the type system?
07:50:48 <shapr> atom-z: that's an explicit type signature, as you would have in C or Java
07:51:01 <philiKON> cool
07:51:14 <shapr> it's rarely necessary, but it's sometimes useful to check if you really do understand the code
07:51:17 <philiKON> atom-z: can you explain that part for part?
07:51:20 <philiKON> err, shapr
07:51:23 <shapr> sure
07:51:29 <philiKON> add is the function name
07:51:32 <shapr> right
07:51:41 <Igloo> You should always use type sigs as it gives saner errors
07:51:43 <philiKON> :: is somekind of delimiter i presume
07:51:47 <shapr> the function takes two Ints and returns one Int, yes?
07:51:55 <Igloo> :: is pronounced "has type"
07:51:55 <atom-z> yeah
07:52:01 <philiKON> Igloo: ok
07:52:13 <philiKON> add has type and then three times Int... hmm
07:52:22 <shapr> two Int in, one Int out, right?
07:52:22 <philiKON> the first two are parameters, the last one what is returned?
07:52:25 <shapr> yup
07:52:30 <Arnia> Hey shapr
07:52:32 <shapr> hi Arnia
07:52:32 <Igloo> Int -> Int -> Int is equivalent to Int -> (Int -> Int)
07:52:35 <philiKON> but they are concatenated with the same syntax
07:52:41 <shapr> philiKON: yes, with good reason
07:52:43 <philiKON> Igloo: ok, make ssense
07:52:43 <atom-z> shapr: what's ->?
07:52:44 <Igloo> so add takes an Int and returns (a functino that takes an Int to an Int)
07:52:53 <atom-z> Igloo: ah ic,
07:53:05 <dark> atom-z: a -> b is the type of a function from a to b.
07:53:07 <andersca> shapr: haskell doesn't have an xmlrpc implementation
07:53:09 <andersca> shapr: fix fix :)
07:53:11 <Igloo> e.g., add 3 :: Int -> Int  takes an Int and returns an Int (3+whatever)
07:53:12 <shapr> andersca: soon soon :-)
07:53:32 <dark> atom-z: So -> is a type constructor :)
07:53:42 <shapr> in lambda calculus, every function takes one argument and returns one argument
07:53:43 <philiKON> k
07:53:48 <shapr> under the hood, Haskell does the same thing
07:53:49 <Arnia> shapr: I'm going to start on AppArrow later in the week :)
07:53:50 <dark> atom-z: Just like Tree was a type constructor (where Tree a is a tree of a)
07:53:53 <shapr> Arnia: yay :-)
07:54:20 <shapr> add :: Int -> Int -> Int is actuall add :: Int -> (Int -> Int)
07:54:34 <dark> I notice that having three people explain things tends to get confusing :)
07:54:38 <shapr> heh, truly
07:54:48 <shapr> the add function takes one Int, and returns a new function
07:54:56 <atom-z> shapr: ic
07:55:06 <shapr> that new function takes a second Int, and returns the result
07:55:12 <Arnia> shapr: Explain partial application ;)
07:55:18 <shapr> Arnia: yah, I'm trying to :-)
07:55:24 <Igloo> dark: At least we aren't disagreeing with each other  :-)
07:55:24 <atom-z> uhoh... add :: Int -> (Int -> Int) is actually returning a function
07:55:47 <shapr> atom-z: you can do the same thing in Python, it's just very rarely done
07:56:03 <shapr> I've done it in some database sorting code I wrote, where I create new filter functions at runtime
07:56:11 <atom-z> heh cool
07:56:21 <dark> So (add 1) returns a function that adds 1 to things.
07:56:22 <philiKON> shapr: yeah, but it's not very consistent in python
07:56:23 <shapr> in haskell it means you get to do "addOne = add 1"
07:56:47 <shapr> I like to use partial application like making an object instance sometimes
07:57:01 <shapr> addOne = add 1 ; map addOne [1,2,3,4]
07:57:05 <atom-z> and then later on you fully define add to return the result of an addition?
07:57:48 <shapr> you can use existing built-in Haskell code like this: map (+ 1) [1,2,3,4]
07:58:06 <shapr> there's almost no difference between operators and functions in Haskell
07:58:07 <philiKON> shapr: one thing that is a p.i.t.a. in python is for example a function that will take a number and returns a function that, when invoked with a number, will add this number to the previously given number
07:58:35 <shapr> philiKON: yah, it's not easy, but it's possible
07:58:51 <Arnia> I've found Python and Haskell skills tend to go together quite well :)
07:58:55 <philiKON> shapr: you'll have to write a class that implements __call__
07:58:56 <shapr> yah, I agree
07:59:12 <shapr> philiKON: nah, just three or four lines
07:59:31 <philiKON> class bla:
07:59:36 <shapr> def makeAdder(y): return lambda x:x + y
07:59:36 <philiKON>   def __init__(self, num):
07:59:45 <philiKON>     self.num = num
07:59:53 <philiKON>   def __call__(self, num):
07:59:58 <philiKON>     self.num += num
08:00:01 <philiKON>     return num
08:00:24 <Arnia> philiKON: A lot of us are python fans as well here :)
08:00:30 <shapr> what about the one line I wrote? build and return a new function?
08:00:37 <philiKON> Arnia: i know you :)
08:00:57 <philiKON> shapr: fair enough. i forgot to ask the requirement that the internal counter is increased :)
08:01:16 <reffie> ruby forever :P
08:01:19 <shapr> heh
08:01:30 <hdaume> morning folks :)
08:01:32 <shapr> hi hal
08:01:34 <reffie> hi
08:01:41 <shapr> hi sh1mmer
08:01:47 <sh1mmer> afternoon
08:02:20 <Arnia> And NN extends its influence to embrace another channel on Freenode ;)
08:02:24 <shapr> philiKON, atom-z: any questions? want to try an introductory tract er, tutorial? ;-)
08:02:29 <philiKON> omg, half of #zope is in #haskell :)
08:02:30 <shapr> NN?
08:02:38 <philiKON> shapr: yeah, tutorial would be cool
08:02:55 <shapr> I like Hal's tutorial
08:03:02 <shapr> @fact yaht
08:03:03 <lambdabot> Nothing
08:03:04 <shapr> hrm
08:03:16 <earthy> okay, wxHaskell does *not* like wxWindows 2.2 ;)
08:03:18 <Arnia> shapr: Mine and sh1mmer's business
08:03:28 <shapr> @fact yaht http://www.isi.edu/~hdaume/htut/
08:03:29 <lambdabot> set yaht to http://www.isi.edu/~hdaume/htut/
08:03:31 <earthy> neither does it like wxWindows 2.4.1 without drag'n'drop
08:03:40 <shapr> @fact yaht Yet Another Haskell Tutorial
08:03:41 <lambdabot> set yaht to Yet Another Haskell Tutorial
08:03:51 <shapr> Arnia: ah, cool
08:03:52 <earthy> did hal fix his download link yet?
08:03:56 <hdaume> yes :)
08:04:08 <earthy> 'kay :)
08:04:14 <shapr> I want commit privs on YAHT again...
08:04:40 <shapr> philiKON: imho, the best way to learn Haskell is to read the tutorial and ask questions here on #haskell
08:04:49 <shapr> lots of smart knowledgable people here
08:05:34 <philiKON> shapr: sure
08:05:55 <shapr> if you have any questions, or want further info about getting started, ask me
08:06:36 <shapr> hej Marvin-- 
08:06:39 <philiKON> i'm sure i iwll
08:06:55 <philiKON> going to uni for physics in october...
08:07:04 <shapr> yay
08:07:15 <shapr> there's some nifty physics code in haskell-libs
08:07:16 <philiKON> loads of applications there
08:07:21 <philiKON> yay
08:07:47 <Marvin--> hello
08:07:51 <atom-z> shapr: thanks for the intro. i'll probably be using haskell for maths stuff in the future :)
08:07:55 <shapr> oh, local tourist attractions are the CVS tree of http://sf.net/projects/haskell-libs/ where lambdabot and many other nifty bits of code stay
08:08:04 <Arnia> philiKON: and such systems as AFRP allow wonderfully natural modelling techniques
08:08:12 * Marvin-- + coworker have gotten lots of work done on the full text search today :)
08:08:13 <shapr> atom-z: it's also good for other stuff, I'd be happy to show you ;-)
08:08:32 <shapr> Marvin--: cool, when's the release party?
08:09:16 <atom-z> shapr: what other stuff is it good for?
08:09:39 <shapr> atom-z: I wrote a crappy bayesian spam filter in 127 lines of code
08:09:55 <shapr> the mailing search plugin for lambdabot was about the same size
08:10:13 <shapr> though it uses too much ram to leave it turned on all the time
08:10:18 <shapr> I need to optimize that plugin
08:10:23 <shapr> @listmodules
08:10:23 <lambdabot> I have the following modules installed: ["base","chess","dict","eval","fact","hello","karma","more","quote","seen","state","system","topic","type"]
08:10:54 <shapr> oh, there's a chess game, a lambda calculus interpreter, a fortune viewer, and a karma plugin for lambdabot 
08:11:31 <shapr> I've used Haskell for XML processing, it's not as good as Python yet, though the equivalent Haskell code was a lot shorter
08:12:51 <shapr> atom-z: you might find the libraries list interesting: http://www.haskell.org/libraries/
08:13:04 <Marvin--> shapr: heh, not for a long time
08:13:10 <earthy> @topic
08:13:11 <lambdabot> Sorry, I don't know the command "topic", try "lambdabot: @listcommands"
08:13:26 <earthy> owh, modules, not commands. deuh.
08:14:53 <shapr> @listcommands topic
08:14:54 <lambdabot> Module topic provides the following commands: ["topic-tell","topic-cons","topic-snoc","topic-tail","topic-init"]
08:17:34 <shapr> philiKON, atom-z: there are lots more resources here: http://www.haskell.org/learning.html
08:20:45 <shapr> oh, sven panne is merging the latest HOpenGL into GHC HEAD
08:20:49 <shapr> I wonder if that means NURBS
08:21:05 <Igloo> Do you not mean HEAD to STABLE?
08:21:14 <shapr> er
08:21:19 <Igloo> AFAIK HEAD *is* the latest HOpenGL
08:21:22 <shapr> what's the difference?
08:21:26 <shapr> oh, I see
08:21:29 <shapr> I think
08:21:44 <Igloo> HEAD is development, STABLE is where releases are made from. They are CVS branches
08:22:42 <shapr> ah, I see
08:22:46 <shapr> yes, I meant STABLE
08:22:55 <Riastradh> Does GHC come with the Haddock sources?
08:23:13 <Igloo> They aren't in the tarball, but they are in the same CVS repo
08:23:15 <shapr> you mean GHC source tarballs?
08:24:00 <Riastradh> Ah, nevermind.
08:27:09 <Marvin--> <CaffieneHead>  We have enough youth. What we need is a fountain of smart.
08:27:17 <Marvin--> note to self: reading irc quotes is bad for your productivity
08:28:30 * shapr rewrites a few PythonScripts
08:28:37 <shapr> @fortune
08:28:38 <lambdabot>   I marvel at the strength of human weakness.
08:29:06 <Riastradh> @yow
08:29:07 <lambdabot> Used staples are good with SOY SAUCE!
08:32:30 <Marvin--> "In GOT CCG, characters die very easily ? some would say, more easily than in the books (which I find deliciously ironic)."
08:32:47 * Igloo bounces
08:38:34 <Marvin--> looks like it isn't raining at this exact moment, better go home :)
08:39:00 <Marvin--> no, wait, still pouring down :-/
08:40:54 * shapr boings
08:44:56 <dark> Marvin: Umm, so what's GOT?
08:46:01 <Igloo> Game of Thrones or something
08:46:22 <Igloo> A Collectible Card Game
08:55:43 <adept> bb
09:03:39 <shapr> oy, I wish I had partial application in Python
09:04:17 <andersca> can't you do it with lambda?
09:04:32 <andersca> you can, but it won't be like haskell :)
09:10:16 <shapr> I have a list of objects and a list of conditions
09:10:36 <shapr> for each condition, filter the lits of objects
09:10:41 <shapr> or maybe, use a real database
09:12:12 <Igloo> Bother, I think SM will have gone home
09:12:56 <Heffalump> who?
09:13:02 <Igloo> Simon Marlow
09:36:17 <Igloo> Oh, looks like I was wrong
09:36:22 * Igloo praises SM
09:57:02 * shapr headbangs to Nine Inch Nails
09:57:18 <andersca> Hurt is the best song
09:59:34 <shapr> my favorite is "Eraser (Denial, Realization)" from "Further Down the Spiral"
09:59:52 <shapr> @fortune
09:59:53 <lambdabot> 	One day it was announced that the young monk Kyogen had reached
09:59:53 <lambdabot> an enlightened state.  Much impressed by this news, several of his peers
09:59:53 <lambdabot> went to speak with him.
09:59:53 <lambdabot> 	"We have heard that you are enlightened.  Is this true?" his fellow
09:59:53 <lambdabot> students inquired.
09:59:53 <lambdabot> 	"It is", Kyogen answered.
09:59:55 <lambdabot> 	"Tell us", said a friend, "how do you feel?"
09:59:57 <lambdabot> 	"As miserable as ever", replied the enlightened Kyogen.
10:00:10 <shapr> @listmodules
10:00:10 <lambdabot> I have the following modules installed: ["base","chess","dict","eval","fact","hello","karma","more","quote","seen","state","system","topic","type"]
10:00:16 <shapr> @seen shapr
10:00:17 <lambdabot> shapr is in #widian, "#haskell" and #joy
10:00:31 <shapr> @seen philikon
10:00:32 <lambdabot> I haven't seen philikon
10:00:37 <shapr> @seen philiKON
10:00:38 <lambdabot> I saw philiKON leaving #haskell 1658 seconds ago
10:01:42 <shapr> @seen polli
10:01:43 <lambdabot> polli is in #haskell and #joy
10:02:39 <Riastradh> It should case insensitively compare nicks.
10:02:56 <atom-z> shapr: how does ocaml compare to haskell?
10:03:43 <shapr> atom-z: OCaml is not purely functional, though it's closer than most. It doesn't have typeclasses (I think that's true) and is rumored to produce faster executable than Haskell
10:03:55 <Riastradh> OCaml has a yuckier syntax, faster compilers, an object system, no typeclass system, a better module system, imperative features, and faster compilers.  (oh, did I mention faster compilers? -- OCaml's compilers rival pretty much everything but straight, hand-optimized C)
10:04:59 <shapr> imho, expressiveness is the most important factor for any language
10:05:08 <atom-z> Riastradh: whats the source of info for the speed of ocaml?
10:05:27 <phubuh> doug bagley's shootout :-)
10:05:29 <Riastradh> atom-z, the Great Language Shootout, and simply watching how fast OCaml programs are.
10:05:31 <dark> I remember not liking the license of the ocaml compiler in Debian.
10:05:46 <atom-z> shapr: i was thinking of learning ocaml as sort of a 'transitional' language
10:05:48 <shapr> oh, OCaml is also strict, isn't it?
10:05:54 <Riastradh> Ah, yes, OCaml is strict.
10:06:09 <shapr> atom-z: personally, I'd recommend diving straight into Haskell
10:06:19 <phubuh> so would i
10:06:20 <Riastradh> OCaml's type system is quite a bit more limited than Haskell's with -fglasgow-exts.
10:07:03 <dark> Riastradh: It should use irc-case-insensivity, which treats several symbols as equal.
10:07:04 <atom-z> Riastradh: the Great Language Shootout uses GCC and G++ as the compilers, but they arent particularly fast. it'd be nice to see how say, icc shapes up
10:07:31 <shapr> also, the Great Language Shootout was using a much older version of GHC
10:07:36 <Riastradh> atom-z, trust me, OCaml's compiler is _fast_.
10:07:46 <Riastradh> Even the bytecode compiler and interpreter.
10:08:06 <atom-z> Riastradh: not saying it isnt, just stating that C and C++ may not be as slow as you think
10:08:49 <Riastradh> atom-z, C and C++ have slow development times, which is much more important, so their slight _execution_ speed is made up for by their slow _development_ speed.
10:09:19 <steveh> i believe all the compilers in the shootout are freely available
10:09:26 <steveh> if you ask me that's a good criterion to keep
10:09:44 <atom-z> steveh: yeah i suppose icc is abit pricy :|
10:11:04 <hdaume> yes, but if you're writing numerical code in ocaml, you might as well write it in C.  in order to get good speed you need to write uber-imperative code
10:11:04 <hdaume> (http://pauillac.inria.fr/ocaml/numerical.html)
10:11:18 <hdaume> (the url always makes me laugh)
10:11:51 <atom-z> Riastradh: ok... i like fast code, how fast are the development times in ocaml (compared to C (assuming you know C very well))
10:12:19 <hdaume> atom-z: probably slower than using Haskell + FFI  (i know, i'm not Riastradh)
10:12:32 <Riastradh> OCaml beats the crap out of C in terms of development times -- most languages do, in fact.
10:12:49 <hdaume> (though i should say that for my very speed intensive apps, i use ocaml)
10:12:51 <atom-z> yeah but i was hoping for an example
10:13:18 <Riastradh> C's manual memory management causes a lot of the slow development times.  Using the Boehm GC will hurt execution times, because it's really not a great GC.
10:13:49 <atom-z> there are things like auto_ptr though
10:14:07 <atom-z> and various goodies in boost
10:14:07 <atom-z> but thats C++
10:14:30 <Riastradh> -- which OCaml already creams, at least with g++.,
10:15:15 <shapr> in my experience, code is more likely written if it only takes a few lines to write it
10:16:26 <atom-z> why do languages such as ocaml and haskell not seem to get taught in schools (for the most part)?
10:16:36 <shapr> Haskell is taught in several schools
10:17:01 <shapr> several colleges in .au, some in the .uk, some in .se that I know of
10:17:10 <phubuh> chalmers, a university here in sweden, teaches Haskell before anything else, iirc
10:17:11 <shapr> at least, that's where we've gotten homework questions :-)
10:17:12 <atom-z> perhaps but it doesnt get as much coverage as Java
10:17:18 <atom-z> (not that i like java)
10:17:19 <hdaume> atom-z: you are in US?
10:17:25 <atom-z> hdaume: no. UK
10:17:40 <shapr> Haskell's advertising budget is smaller than Java's
10:17:46 <atom-z> true
10:17:48 <Riastradh> Scheme is taught in even more schools.
10:17:51 <hdaume> atom-z: ah.  my impression is that FPLs are taught much more outside of US than within
10:18:19 <atom-z> hdaume: at my local uni, i dont think anyone's even heared of it
10:18:27 <Riastradh> What about Scheme?
10:18:39 <atom-z> i dunno, i dont know what that is
10:18:45 <shapr> oh, Luleå uni teaches Haskell, I live half an hour away
10:18:48 <Riastradh> It's another functional language.
10:18:52 <atom-z> ic
10:19:12 <hdaume> surely Lisp, though :)
10:19:14 <atom-z> is it worth learning too?
10:19:17 <Riastradh> Yes.
10:19:22 <atom-z> hdaume: quite probably lisp
10:19:30 <Riastradh> MIT, for example, ensures that all freshmen take 6.001, the SICP course, which uses Scheme.
10:19:47 * atom-z is pondering which language to learn: lisp,haskell,ocaml or (now) scheme
10:19:54 <hdaume> CMU has a similar course (though sophomore, and it uses SML, not surprising)
10:19:55 <Riastradh> Scheme is a Lisp.
10:20:00 <atom-z> ic
10:20:04 <hdaume> i'd say learn haskell or ocaml
10:20:06 <phubuh> hey, that's great! my brother hates functional languages, and he's going to luleÃ¥ uni :-)
10:20:08 * Riastradh suggests learning Scheme as your first Lisp.
10:20:42 <Riastradh> I think that Scheme is a lot easier to learn than either Haskell or OCaml, too -- but it's up to you to decide.
10:20:49 * Riastradh hands atom-z a three-sided die in case he can't decide.
10:21:00 <atom-z> hehe
10:21:09 <Riastradh> Or four-sided if you consider SML, too.
10:21:22 <phubuh> i found scheme very easy to learn, while OCaml and Haskell confused me a lot
10:21:37 <atom-z> i'll probably learn haskell, as you people are helpful and i'm gonna have lots++ of questions about things if its my first FPL
10:21:55 * Riastradh points out that #scheme is helpful, too.
10:22:08 <hdaume> atom-z: and there exists a very good haskell tutorial out there too :)
10:22:10 * hdaume blushes
10:22:11 <Riastradh> #ocaml and #sml are pretty idle, most of the time.
10:22:12 <shapr> see, I think you should learn them all, starting with Haskell
10:22:17 <atom-z> hdaume: where?
10:22:22 * Riastradh whacks hdaume -- blatant self-promotion, eh?
10:22:23 <shapr> yes, hdaume wrote that tutorial
10:22:27 <shapr> @fact yaht
10:22:28 <lambdabot> http://www.isi.edu/~hdaume/htut/, Yet Another Haskell Tutorial
10:22:37 <hdaume> Riastradh: id on't know what you're talking about ;)
10:22:44 <Riastradh> http://mitpress.mit.edu/sicp/ and http://www.htdp.org/ are good reads, too.
10:22:49 <atom-z> ic
10:22:51 <atom-z> thanks
10:22:55 <Riastradh> And you should read both of those textbooks I just mentioned _anyways_, regardless of what you learn first.
10:22:59 * Heffalump tries to work out how to make lambdabot handle quitting gracefully
10:23:09 <shapr> Heffalump: oh, good idea
10:23:43 <Heffalump> I've got it restarting the connection when that dies, but now I need to find a way to cut through that when we actually *want* to quit :-)
10:23:57 <shapr> mm, reconnect
10:24:03 <shapr> that's been on the TODO list for sometime
10:24:38 <shapr> Heffalump: you have to add yourself to the AUTHORS list also
10:24:43 <Heffalump> yeah, I'll do that
10:25:06 <atom-z> i assume that all FPU's have sockets classes (or whatever they're called) etc?
10:25:20 <atom-z> well... the fpu's we talked about anywya
10:25:37 <Riastradh> atom-z, GHC has a network library...most Scheme implementations have socket interfaces...OCaml does...I'm not sure about SML.
10:25:41 <Riastradh> (SML probably does)
10:25:46 <Heffalump> the problem is that when the connection gets closed, the reader/writer threads deliver an exception to the main thread
10:25:46 <Riastradh> (GHC is a Haskell compiler)
10:25:57 <atom-z> Riastradh: ah ok
10:26:09 <shapr> there's also Hugs, a Haskell interpreter
10:26:09 <phubuh> FPUs? :-)
10:26:18 <shapr> Functional Programming Units?
10:26:22 <Heffalump> normally the correct response to that exception is to reconnect, but not if we're trying to quit
10:26:38 <hdaume> SML does :)   (in fact, bob harper has built an entire tcp/ip stack in SML)
10:26:46 <shapr> Heffalump: global quit state?
10:26:57 <Heffalump> in which monad?
10:27:00 <phubuh> lambdabot is written in Haskell, atom-z
10:27:02 <shapr> hm
10:27:16 <atom-z> FPL's sorry
10:27:21 * hdaume is off to a talk
10:28:06 <atom-z> ok, well thanks everybody. i'm gonna go and learn a FPL now (dunno which) :)
10:28:09 <shapr> yay
10:28:13 <phubuh> whee
10:28:21 <shapr> I promise you'll enjoy it :-)
10:30:31 <phubuh> gu?
10:30:56 <phubuh> ah, gÃ¶teborgs universitet
10:31:08 <Heffalump> who are the people who are currently strongly involved in lambdabot development? i.e. the ones who might want to discuss reasonably significant architectural changes before I commit them?
10:31:21 <shapr> hi Marvin-- 
10:31:31 <shapr> Heffalump: come to #joy
10:31:39 <Heffalump> isn't joy a programming language?
10:31:42 <shapr> yes
10:31:46 <shapr> but no one ever showed up
10:31:48 <Riastradh> #joy _was_ the channel for that.
10:31:53 <Heffalump> ahh.
10:31:55 <shapr> so we turned it into #lambdabot
10:32:02 <shapr> or we could talk it about here as well
10:32:07 <shapr> actually, that's probably better
10:32:17 <Heffalump> well, it's less likely to get lost in scrollback there
10:32:20 <shapr> that's true
10:32:24 <shapr> since #joy isn't logged
10:32:38 <shapr> er wait
10:32:43 <shapr> the other way around
10:33:04 <shapr> I think it would be better here because then I can go look at the logs and see what someone said if I can't remember details
10:33:10 <Igloo> You're all mad!
10:33:17 <shapr> as a hatter
10:33:32 * shapr throws white rabbits at Igloo 
10:33:48 * Riastradh plays the Jefferson Airplane song 'White Rabbit' into the channel.
10:33:54 <Igloo> Red rabbits taste better
10:33:57 <shapr> really?
10:34:02 <shapr> what's the difference?
10:34:22 <Igloo> I was making it up - do red rabbits exist?
10:34:37 <shapr> they have red squirrels, why not red rabbits?
10:34:43 * Marvin-- recalls a certain dicussion on slashdot about what colour SchrÃ¶dinger's cat gets when travelling in light speed
10:34:59 <Marvin--> the answer was "red, plenty of red"
10:35:21 <shapr> Heffalump: I suspect I'm the most strongly involved lambdabot developer, but you could post to haskell-libs-developers if you want feedback from more people.
10:35:27 <Arnia> From which direction are you looking
10:37:45 <shapr> lambdabot is a code toy so if you're doing something fun/useful with/to lambdabot, keep doing it.
10:41:20 * Heffalump is currently failing to find a good way of doing it :-)
10:41:38 * Heffalump decides to go home and think about it on the way
10:42:16 <shapr> yes, I think this calls for warcraft! yay!
10:42:36 <Marvin--> bought it yet?
10:42:42 <shapr> Marvin--: no, but I'm reallly close
10:42:45 <Marvin--> heh
10:43:05 <shapr> my friend bought more ram and a better graphics card, so hopefully we'll have less lag today
10:43:38 <Marvin--> heh
10:43:47 * shapr runs off to play warcraft 3
10:43:50 <shapr> bbl
10:43:52 <Marvin--> I tried playing some 2v1 (with a computer, to see what they do, and stuff)
10:43:59 <shapr> oh how did it go?
10:44:24 <Igloo> Aha, reply from Chris Okasaki with a bug fix
10:44:43 <dark> http://heim.ifi.uio.no/~enag/lugm-time.html is pretty interesting.  "The long, painful history of time".
10:44:54 <Marvin--> well, it was too easy of course
10:45:20 <Marvin--> I think I need to turn down the graphics detail to get better micro, my heroes die way too easily :-/
10:45:35 <shapr> well, I have to go try with the new hardware...
10:45:37 * shapr zooms off
10:51:43 <phubuh> hey, what happened to the functional wankery thread on arstechnica? :-(
10:52:32 <atom-z> can i do this in haskell:
10:52:46 <atom-z> function x y z = x*y*z?
10:53:00 <phubuh> yup
10:53:05 <Riastradh> Yes -- but not in the REPL (e.g., in the hugs or GHCi interaction).
10:53:17 <Heffalump> you can do it in ghci
10:53:22 <Heffalump> let function x y z = x*y*z
10:53:34 <atom-z> what about:
10:53:44 <atom-z> let result = function 1 2 3
10:53:50 <Riastradh> In GHCi, yes.
10:53:50 <atom-z> will that do what i expect?
10:54:16 <Igloo> Yes
10:54:25 <atom-z> neato. thanks
11:00:49 <xkb> hi.. does anyone here have "The Fun of Programming"
11:00:52 <xkb> the book that is
11:01:45 <xkb> And if you have, what do you think of it
11:02:01 <xkb> At first glance it looks like a collection of research papers
11:02:07 <xkb> like SLNCS
11:02:35 <Igloo> I have, but I haven't read it yet
11:03:01 <Igloo> I think it's a bit more reader friendly than the average paper, though
11:03:23 <Igloo> Heff is probably a better person to ask than me
11:03:57 <xkb> ah ok
11:04:12 <xkb> The topics look good to me in any case
11:11:30 * Marvin-- has only read the QC chapter
11:26:47 <Arnia> Gun shots in the NYC city hall during a council meeting... talk about heated argument
12:39:08 <Heffalump> how evil is making an exception monad transformer all of whose operations catch exceptions from the underlying monad (IO, a few layers down) and wrap them up in its own exception type?
12:42:09 <hdaume> Heffalump: why?
12:43:50 <hdaume> as in: why are you doing this?
12:43:59 <Heffalump> what I've got (roughly) is ExceptionT (StateT IO)
12:44:34 <Heffalump> well, the ExceptionT doesn't matter for my reasons - let's just say that it's StateT IO
12:45:11 <Heffalump> suppose I have a fairly large computation, and that somewhere in the middle of it an IO exception gets thrown.
12:45:38 <Heffalump> around that computation is an exception handler, which catches it
12:45:54 <hdaume3> sorry, got disconnected
12:46:03 <Heffalump> but, crucially, the state in the StateT has been unwound back to the point where the computation started
12:46:08 <Heffalump> which bits did you see?
12:46:24 <hdaume3> all i got was the first and last line
12:46:59 <Heffalump> the bottom of http://tunes.org/~nef/logs/haskell/03.07.23 has the rest
12:47:13 <Heffalump> that way you can read it in the right order without getting confused :-)
12:47:42 <hdaume3> ah
12:47:45 <hdaume3> okay, continue :)
12:48:02 <hdaume> so you basically want to prevent the StateT from getting unwound?
12:49:13 <Heffalump> yep.
12:49:29 <hdaume> cool : )
12:49:36 <Heffalump> if I stick an ExceptionT type thing around the outside, exceptions thrown by that won't cause the state to be unwound
12:50:10 <hdaume> right
12:51:32 <Marvin--> I don't think it sounds too insane? I think it sounds like a good idea
12:51:44 <Heffalump> ok :-)
12:51:49 <Heffalump> I just need to think it through to be sure it'll work.
12:52:49 * Heffalump finds the back of an envelope, it's guaranteed to work now
12:54:21 <Marvin--> I've always liked napkins
12:56:05 * Marvin-- ponders QuotesPage
12:56:12 * Marvin-- groans at the latest addition to it
12:56:27 <andersca> where is it
12:57:13 <Marvin--> http://www.haskell.org/hawiki/QuotesPage
12:59:01 <hdaume> hehe, i think that's funny
12:59:58 <Marvin--> sure
13:00:39 <Marvin--> doesn't stop me from groaning though
13:01:12 <hdaume> true
13:01:23 <Heffalump> which bit
13:01:23 <Heffalump> ?
13:02:08 <Marvin--> the last quote
13:02:09 <Riastradh> HEY!  Someone misquoted the monad vs comonad dual!
13:02:12 <Riastradh> Duel, even.
13:02:19 <Marvin--> it's misquoted as well?
13:03:04 * Heffalump thinks bad jokes like that are best left ephemeral :_)
13:03:06 <Heffalump> s/_/-/
13:03:55 * Igloo looks at the spellcheck page and wonders if it starts off with any words at all
13:04:58 <Igloo> Anyway, I've added the most important omission now  :-)
13:05:12 <Marvin--> Riastradh: pun intended?
13:05:22 <Riastradh> No, actually.
13:06:21 <Marvin--> so, what's misquoted about the dua^Hel?
13:06:41 <Riastradh> There was a lot more, if I remember correctly.
13:06:56 <SyntaxPolice> I noticed someone cut out my "I see your swarts is as big as mine" spaceballs reference
13:06:58 <SyntaxPolice> ;)
13:07:57 <Marvin--> SyntaxPolice: kinda off topic though
13:08:22 <Riastradh> And someone left out shapr saying something like:
13:08:30 <Riastradh> * shapr waves it around and makes boooov boooov noises
13:08:33 <SyntaxPolice> I don't see how a spaceballs reference to battling with lightsabers can be off topic
13:08:43 <Riastradh> They're monads and comonads, not lightsabres!
13:08:44 <Marvin--> Riastradh: all right, that would've made sense to include
13:08:58 <Marvin--> Riastradh: so edit it, it's a wiki
13:09:08 <Igloo> Am I missing something or is the second line of this pointless:
13:09:09 <Igloo>         /usr/bin/install -c -m 644     $i /home/igloo/ghc6/new/ghc6-6.0/debian/tmp/usr/lib/ghc-6.0; \
13:09:12 <Igloo>         : /home/igloo/ghc6/new/ghc6-6.0/debian/tmp/usr/lib/ghc-6.0/`basename $i` ;; \
13:09:34 <Marvin--> ":" is a pass statement, yes :)
13:14:46 <dark> Igloo: Might be something like $(STRIP) which gets replaced with a no-op if you're not stripping.
13:15:46 * Marvin-- ponders having a wee nippie
13:15:52 <Igloo> *nod*
13:15:57 <Igloo> Ta
13:16:43 <Heffalump> my mouse pointer was in the wrong place just then, and I thought Marvin said "ponders having a wee nipple".
13:17:23 <Marvin--> um
13:17:29 <Marvin--> weeell
13:17:45 * Marvin-- laughs at some lines from the movie
13:18:25 <Marvin--> "Mick Jagger never wanted his wife on stage!" "Well, screw him!" "Already have!"
13:21:12 <Marvin--> Heffalump: what I did mean was "time for a whisky"
13:21:38 <andersca> hmm, a cognac would be nice
13:22:14 <Heffalump> yes, I guessed that after I moved the mouse and read what you did say :-)
13:22:19 <Marvin--> :)
13:22:41 <dark> Sounds good, actually.  Alcohol and code go so well together.
13:23:02 <Marvin--> I'm not coding, I'm still signing keys :P
13:23:50 <Marvin--> maybe I shouldn't do that with alcohol, actually :9
13:24:02 <Marvin--> "yeeeah, thisch isch crrect!!"
13:24:37 <reffie> yeah
13:38:57 <SyntaxPolice> Marvin--: "I could write a program to compare all these fingerprints! The one on the keys should match the one on the keyring!"
13:44:11 <Marvin--> heh
13:47:03 <reffie> heh
14:10:21 <Marvin--> http://people.debian.org/~mjb/talks/debconf3/html/slide_31.html
14:16:24 <SyntaxPolice> Marvin--: great slideshow
14:16:36 <Marvin--> yeah, one of the "serious" presentations at debconf :)
14:17:01 <Marvin--> "And, lo, a great and menacing voice rose from the depths, and with great wrath and vehemence its voice boomed across the land...
14:17:08 <SyntaxPolice> so debconf was fun? From reading the mailing list, I would guess it would be mostly like a large scale knife fight
14:17:09 <Marvin--> "tehehehehehe... that *tickles*!"
14:17:19 <Marvin--> large scale knife fight?
14:17:38 <Marvin--> debcamp was a blast, debconf was mostly a series of presentations and talks, but fun
14:17:50 <SyntaxPolice> you know. hundreds of people who hate eachother locked in a hotel conference room with knives and no food
14:18:04 <Marvin--> oh there was plenty of food, thanks to HP
14:18:19 <SyntaxPolice> oh OK
14:18:30 * SyntaxPolice looks through the slides again
14:29:39 <Marvin--> heck, even Branden was nice ;)
16:31:08 <Igloo> Yay, I think I have ghc6-threaded working
17:19:29 <Igloo> SyntaxPolice: You around?
17:20:34 <Heffalump> how's the sparc port?
17:20:42 <Heffalump> or alpha or whatever you were doing
17:21:29 <Igloo> I think it should work now, but 6.0.1 is going to be released tomorrow I think so I'm going to start from there. That also has the advantage that I shouldn't need such a chain of hacks to get it to work.
17:21:56 <Igloo> Hopefully if that works then 2 or 3 more will be easily possible
17:23:35 <Igloo> Hi Pseudonym
17:23:42 <Pseudonym> G'day.
17:28:38 <Igloo> I should have looked for a 32bit arch - then I might have had something working by now  :-)
17:28:50 <Heffalump> that'd be pretty good, it'd unbreak loads of Haskell stuff on random arches
17:29:03 <Igloo> Yeah
17:29:45 <Igloo> I got as far as installing bochs with a plan to install the HURD on it to try to fix hugs, but then I got confused as to how exactly you install the HURD onto bochs
19:12:03 * Igloo goes to bed before Heff and others start distracting my with interesting stuff again  :-)
19:14:26 <Riastradh> Oh, Igloo, I just had a cool idea!
19:29:10 <Smerdyakov> It involves.... legos!
19:38:20 <Ribs-san> !rules
19:38:25 <Ribs-san> !list
19:39:34 <Riastradh> ...
23:37:41 <reffie> it's raining!
23:38:55 <Pseudonym> So it is.
23:39:09 <phubuh> is not!
23:39:32 <phubuh> it's sunny and rather pleasant up here.
23:40:00 <reffie> i think it stopped raining
23:40:08 <reffie> it hasn't rained for months, here
23:40:11 <phubuh> oh. that'd explain it.
23:40:16 <phubuh> where's here?
23:40:36 <reffie> Rome, Italy
23:40:56 <phubuh> nice
23:41:03 <Pseudonym> Here it's been raining for a week.
23:41:08 <reffie> :/
23:42:28 <phubuh> it's been untolerably hot here for a week or so
23:42:49 <phubuh>     where here = sandviken, sweden
23:43:59 <Pseudonym> How hot does it get in Sweden?
23:45:27 <phubuh> take-your-pants-off-hot!
23:45:39 <phubuh> i'm not really sure, i'm awful with temperatures
23:46:13 <Strike> not as hot as it does here, I'll bet ;)
23:47:02 <phubuh> where are you?
23:48:08 <Strike> Texas :)
