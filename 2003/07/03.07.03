00:42:16 <earthy> moin
02:04:54 * Marvin-- boggles at tradition.se
02:05:12 <Marvin--> War3:FT costs 329 SEK, War3+War3:FT costs 399 SE
02:05:14 <Marvin--> K
02:05:17 <Marvin--> talk about campaign price
03:48:01 <Heffalump> morning.
03:48:55 <Marvin--> afternoon :)
03:49:20 <Marvin--> I'm reading icfp2003 writeups, and it seems like a lot of people used manual or semimanual methods :-/
03:52:03 <Marvin--> I guess we should write up something too, "Mistake number 1: going for full automation" :)
03:53:20 <Marvin--> "The simulator on the web is in C++, run by a CGI script in PERL. We made (at least) a Haskell version also. The email address collection was written in OCaml, the support system in Haskell using Wash/CGI, and the submission server in Erlang using Yaws."  haha
04:00:29 <Heffalump> we went for full automation but essentially abandoned part of it of Monday
04:00:39 <Heffalump> though many of our routes originated with fully automated ones
04:03:06 <Marvin--> "Mistake number 2: not thinking of Bezier curves" ;)
04:03:16 <Heffalump> heh :-)
04:03:27 <Heffalump> I'm not really sure they were ideal, but I don't know what would be better.
04:03:59 <Marvin--> with well placed way points I think they can be very good
04:04:41 <Marvin--> you have code for curve fitting, right? (Taking a (parameterized?) curve and producing a sequence of car commands that will follow it closely)
04:06:44 <Heffalump> yeah.
04:06:55 <Heffalump> I was quite pleased with that bit of it.
04:07:06 <Heffalump> I don't entirely know why our car was so far off the pace overall, though.
04:07:21 <Heffalump> part of it would be that our racing line sucked
04:07:47 <Marvin--> heh
04:08:09 <Marvin--> where was the code, again? I'm very curious about the curve fitting part, since I was thinking a lot about it during the contest but never got any code written
04:08:53 <Heffalump> http://web.comlab.ox.ac.uk/oucl/research/areas/progtools/icfpcontest/2003/Driver.hs
04:10:05 <Marvin--> great, uncommented code .-)
04:10:15 <Heffalump> what do you expect? :-)
04:10:23 <Marvin--> uncommented code :)
04:10:31 <Marvin--> any place in particular in the file that I should be looking at?
04:10:37 <Heffalump> the top level function is drive
04:10:44 <Heffalump> which calls drive'
04:11:16 <Heffalump> which basically uses the list monad for backtracking through the tree of possibilities created by drivestep
04:11:37 <Marvin--> map (\(cs,s) -> (cs,s))
04:11:38 <Marvin--> hmm
04:11:45 <Heffalump> there's a good reason for that, honest :-)
04:11:54 <Heffalump> it started out as map (\(cs,s) -> (reverse cs,prodscore s))
04:11:58 <Heffalump> but simplified over time
04:12:01 <Marvin--> heh
04:12:14 <Heffalump> type OurState = (State,BezierState)
04:12:17 <Marvin--> started out as an accumulated parameter?
04:12:31 <Heffalump> State is the state of the simulator, and BezierState is the state of the curve following code
04:12:44 <Marvin--> aiiih, you use n+k patterns, DIE
04:12:50 <Heffalump> the list of commands was originally built up in reverse order by the commented version of drive'
04:12:59 <Heffalump> I like n+k patterns
04:13:08 <Heffalump> they're a specialised form of views, which are also good things
04:13:23 <Marvin--> until we have views, though, they're just broken
04:13:49 <Heffalump> not at all, they're just a specialised version that lots of people want
04:14:09 <Heffalump> like foldr-build optimisation is a specialised version of GHC rewrite rules
04:14:30 <Heffalump> anyway, I'm not going to defend them any more, you don't have to like them to read our code :-)
04:15:27 <Marvin--> phew ;)
04:15:54 <Heffalump> the floattoqint and qinttofloat stuff is all used in really nasty ways cos I was in a hurry
04:16:32 <Heffalump> how much do you know about bezier curves?
04:18:37 <Marvin--> not much at all, but I was looking at it two days ago
04:19:00 <Marvin--> eh, in drivestep, what's the purpose of the first coordinate of the tuples in the lists?
04:19:21 <Heffalump> oh, that's old
04:19:29 <Heffalump> not used any more, we just didn't rip it out
04:19:46 <Marvin--> so it's just the lists-in-lists that are significant?
04:19:47 <Heffalump> the original idea was to allow the car to stray more from the path if it was going to go faster as a result
04:19:49 <Heffalump> yep.
04:20:07 <Heffalump> the idea is to choose one turning option for each of accelerating, braking and coasting
04:20:27 <Heffalump> so backtracking only happens over speed choices, never over turning choices, if that makes sense
04:22:07 <Marvin--> it makes sense, but I don't understand how
04:22:36 <Heffalump> well, the result of drivestep is a list of choices that will be used for backtracking
04:22:44 <Marvin--> yah
04:22:55 <Heffalump> those choices only ever contain a maximum of one accelerate command, one brake command and one do-nothing command
04:23:24 <Heffalump> because bestfilter picks the best option from the pov of curve following from each list
04:23:58 <Marvin--> eh, not quite following, can you give an example of a valid and an invalid return value?
04:24:19 <Heffalump> for drivestep?
04:24:42 <Heffalump> [(AccelerateLeft,...),(Brake,...),(TurnLeft,...)] would be valid
04:25:06 <Heffalump> so would [(AccelerateLeft,...),(Brake,...),(TurnRight,...)], although it's unlikely to happen
04:25:19 <Heffalump> [(Accelerate,...),(AccelerateLeft,...),...] is invalid
04:25:23 <Marvin--> ahh
04:33:11 <Marvin--> uhm, so you're using a nondeterministic monad for backtracking, but where do you fail?
04:33:47 <Heffalump> drivestep can return an empty list
04:34:09 <Heffalump> bestfilter has a threshold parameter that causes drivestep to reject any options which would send it too far off the path
04:34:19 <Marvin--> ah
04:34:21 <Heffalump> so if there's no options at all it has to backtrack
04:34:50 <Heffalump> in practice if we see excessive backtracking we observed that it never really finds its way out - hence the trace statements in drive' for keeping an eye on it
04:35:04 <Marvin--> heh
04:35:05 <Heffalump> we just manually killed it and tuned stuff when it got stuck
04:45:03 <Marvin--> I'm not overly fond that this problem encouraged manual solutions :-/
04:48:23 <Heffalump> yeah, neither were we
04:49:56 <Marvin--> sure, we got to write lots of cool code, but it's annoying when you don't have *anything* to show for after three days
04:51:32 <Marvin--> how did you construct the bezier curves?
04:53:27 <Heffalump> we found some C on the net
04:53:37 <Heffalump> http://www.research.att.com/sw/tools/graphviz/packages/spline-o-matic/
04:54:01 <Heffalump> the straight line finder bit didn't work too well, so for many of the graphs we constructed those manually
04:54:06 <Heffalump> but we always used that for the beziers
04:55:56 * Marvin-- ponders how to compile the damn thing
04:56:26 <Heffalump> oh, that took a while.
04:56:31 <Heffalump> if you mean spline-o-matic
04:56:47 <Heffalump> I can give you a copy of our entire tree if you like, but I don't promise it'll be easy to use :-)
04:58:10 <Marvin--> sure, I'll look at it when I get home from work *cough*
04:58:30 <Heffalump> ok, I'll stick it on the web somewhere after lunch
05:45:42 * kosmikus just officially added darcs to Gentoo
05:52:45 <jlouis_> does darcs have any security features?
05:56:06 <kosmikus> I haven't used darcs (yet) myself, so others might be more knowledgeable ...
06:08:12 <jlouis_> it has gpg signing. That is ok
06:15:27 <Heffalump> is it really usable for real VC yet?
06:15:44 <Heffalump> I guess they use it for itself, so it can't be /too/ bad, but it seems quite buggy from what I've seen of the mailing lists
06:25:51 <Shamino> :)
06:25:56 <jlouis_> I dunno, I use OpenCM for most work
06:29:18 <Shamino> someone knows how to check if a list is in another list ?
06:30:30 <Shamino> [a] -> [a] -> Bool
06:30:36 <shapr> elem
06:30:41 <shapr> @type elem
06:30:42 <lambdabot> elem :: Eq a => a -> [a] -> Bool
06:30:45 <Shamino> and i would use it like ?
06:30:54 <Shamino> lister (a:as) (b:bs) = (a:as) elem (b:bs) ???
06:31:01 <Igloo> any (xs `isPrefixOf`) (tails ys)
06:31:18 <Shamino> mhhhhh
06:31:36 <Shamino> what mean sis prefixOf
06:42:03 <shapr> Shamino: do you know the word prefix?
06:42:33 <shapr> do you have a dictionary handy?
06:43:38 <Shamino> the word in front of something
06:43:55 <Shamino> prefix infix postfix
06:43:57 <shapr> right
06:43:59 <shapr> but not only word
06:44:04 * andersca bounces
06:44:06 <shapr> just "thing in front"
06:44:08 * shapr boings
06:44:34 <Shamino> so still dot understand igloo
06:46:21 <Igloo> Shamino: Do you know what "tails ys" means?
06:48:48 <Shamino> yes 
06:48:57 <Shamino> everything but the first element of ys
06:49:06 <Igloo> No, that's tail
06:49:19 <Igloo> List> tails "foobar"
06:49:19 <Igloo> ["foobar","oobar","obar","bar","ar","r",""]
06:49:25 <Shamino> aaaaaaaa k
06:49:39 <Igloo> so if any of them begins with xs then xs is in ys
06:50:40 <Shamino> so
06:58:31 <Igloo> shapr: http://people.debian.org/~igloo/ghc5-2003-07-03-1/
06:59:07 <Igloo> Let me know if it's broken and add it to the topic if you want
07:00:43 <Heffalump> is Shamino just trying to get homework done, or what?
07:01:49 <dark> Greetings
07:02:08 <Igloo> 'ello stranger
07:02:14 <dark> Hmm, the channel seems bigger :)
07:04:44 <SyntaxPolice> mornin
07:05:02 * dark is running into bug#195225.
07:05:43 * Marvin-- hath returned
07:05:58 <Igloo> Use http://people.debian.org/~igloo/ghc5-2003-07-03-1/
07:06:00 <Marvin--> dark: yeah, that's very common
07:06:03 <Igloo> And tell me if it still happens
07:07:27 <Heffalump> hi dark
07:07:32 <dark> Hello :)
07:07:51 <dark> I've been away hacking on linux, but I got fed up with C for a while so I'm back :)
07:08:01 <dark> But now I've forgotten everything about Haskell.
07:08:35 <Igloo> I envy you - you have the joy of discovering it all over again  :-)
07:09:08 <dark> Igloo: I thought that was the _hard_ part :)
07:09:10 <SyntaxPolice> ah, those beautiful first few days...
07:10:32 * Igloo goes into comlab
07:10:52 <dark> I guess this is where I find out if my old Haskell code is readable as well as writeable.
07:11:01 <Heffalump> eek, scary
07:11:11 <Heffalump> an Igloo and a tfm in Comlab on the same day, though at different times
07:11:39 <dark> What's a tfm?
07:11:47 <dark> Igloo: Your version seems to have fixed it.
07:11:50 <Heffalump> another beast that is rarely seen in comlab.
07:14:14 <Marvin--> dark: I guess the Kama Sutra qualifies as "TFM" for example ;)
07:14:21 <Heffalump> lol
07:14:50 <Heffalump> this tfm is http://web.comlab.ox.ac.uk/oucl/people/tristam.fenton-may.html
07:15:59 * Marvin-- grins as the haskell mail box starts getting new mails again, for some reason it didn't get many during the weekend :)
07:18:27 <Heffalump> :-)
07:19:14 <Marvin--> man it's pouring down outside
07:19:53 <Marvin--> guess I'll just have to stick around work a while longer, then
07:20:40 <Heffalump> oh, I was going to make you a tarball
07:22:03 <Marvin--> well, I'm still at work, but I can still download the tarball
07:22:24 <Heffalump> there's all sorts of crap in it, so it's a bit big
07:22:50 <Heffalump> http://musketeer.comlab.ox.ac.uk:81/~ganesh/engineroom.tar.gz (we were Team Engine Room)
07:22:51 <Marvin--> *shrug* I've got ph4t pipes you know
07:23:18 <Marvin--> 16:23:09 (905.78 KB/s) - `engineroom.tar.gz' saved [1607386/1607386]
07:23:45 <Heffalump> nice :-)
07:24:07 <Marvin--> note to self: student network connections are way faster during summer :-P
07:24:17 <andersca> indeed
07:26:08 <tic> neat.
07:26:17 <tic> didn't know everyone went hemhem
07:26:42 <Marvin--> is hemhem a nation-wide expression among students?
07:26:46 <andersca> Marvin--: ype
07:26:46 <andersca> yep
07:26:55 <tic> :)
07:30:24 <SyntaxPolice> here's something I always forget; why can't I do this:
07:30:27 <SyntaxPolice> data (Num a) => ANumber = ANumber a
07:30:42 <SyntaxPolice> or something like that; isn't (Num a) a "context" ?
07:30:49 <Heffalump> what should a be when you create a value of type ANumber?
07:30:59 <Heffalump> you can do it with an exists
07:31:13 <SyntaxPolice> hm. don't understand your question
07:31:31 <Heffalump> oh, no I see how you'd answer my question.
07:31:45 <Heffalump> The real answer to your question is that you need an existential qualifier on a (which is not Haskell 98)
07:32:49 <Heffalump> data ANumber = ANumber (exists a . (Num a) => a) IIRC.
07:32:55 <Heffalump> but I probably don't RC
07:33:41 <SyntaxPolice> ok/me reads good explanation here:
07:33:43 <SyntaxPolice> http://haskell.cs.yale.edu/ghc/docs/latest/html/users_guide/type-extensions.html#EXISTENTIAL-QUANTIFICATION
07:34:43 <shapr> afaiu, --enable-threaded-runtime allows ghc's concurrent to use OS threads, and thereby SMP. Is that correct?
07:34:59 <Heffalump> another way of answering your question is to ask whether "ANumber 5" and "ANumber 5.0" have the same type
07:35:23 <SyntaxPolice> Heffalump: I see.
07:35:43 <Heffalump> by your definition, they do, but that doesn't really make sense
07:36:07 <Heffalump> with the existential quantification, they do, but there's also a dictionary with each value giving some operations you can do with them
07:37:11 <Heffalump> essentially, leaving out the a on the LHS ANumber means that the static type checker can no longer keep track of what kind of ANumber you have, because you've told it to throw that information away
07:37:14 <Marvin--> is 'exists' in ghc 6 or cvs or not at all?
07:37:27 <Heffalump> it's been in GHC for ages
07:37:31 <Heffalump> I might mean forall.
07:37:42 <Marvin--> I mean, I remember talk about it, but I thought the current syntax was data ANumber = forall a. Num a => ANumber a
07:37:44 <Heffalump> (which comes down to the same thing, it's just a question of where you put it)
07:38:01 <Marvin--> yeah, duality
07:38:01 <Heffalump> yes, I was just wrong in what I said above about the correct syntax
07:47:08 <Igloo> dark: Cool, ta
07:51:04 <Marvin--> Heffalump: I fail to see how this tarball helps me compile the spline-o-matic thingy
07:51:50 <Marvin--> omg, you actually have a 'ui' and a 'model' package for the java gui thingy, and you wrote it *during the contest*? What are you, perverts?
07:52:24 * shapr grins
07:56:30 <Igloo> Marvin: The local Java/OOP expert did that while the FPers did the real problem  :-)
07:56:52 <Marvin--> I still think it sounds like time wasted
07:57:48 <Igloo> I turned out we used my ~10 line perl script (overlay.pl) most of the time, but there were a few times when we wanted to zoom right in on a trace to see how smooth it was and how close we were staying to the real spline when it came in handy
07:59:08 <Marvin--> but separate packages?! sheesh
07:59:29 <Igloo> We just left him to it
08:01:09 <Marvin--> see, java programmers do all these horrible things when you leave them alone
08:01:11 * Marvin-- shivers
08:01:37 <earthy> just like countries that start talking to themeselves (such as israel)
08:02:16 <dark> Marvin: You mean, like... write in Java?
08:02:33 <earthy> Java the virtual machine language isn't *too* bad...
08:03:19 <Marvin--> dark: that too
08:03:56 <earthy> but, yeah, Java seems to have taken the cop-out approach to developing software.
08:05:34 * earthy ponders
08:06:25 <shapr> how can I find the list of functions defined in a package?
08:06:33 <shapr> I'm trying to test the HOpenGL packages
08:07:25 <Igloo> You could look in the library docs on haskell.org/ghc/
08:07:32 <Marvin--> you can use :b on a module...
08:07:36 <earthy> or just read the source.
08:07:47 <earthy> marvin--: that's assuming hugs?
08:07:53 <Igloo> If you get a small test program can I have a copy please?
08:07:56 <shapr> sure
08:08:11 <shapr> Marvin--: I don't know which module to import, that's part of the problem
08:08:23 <Marvin--> earthy: ghci can do it too
08:08:32 <earthy> yeah, I just noticed. nice hint.
08:08:41 <shapr> oof
08:08:47 <shapr> Prelude> :set -package GLUT
08:08:47 <shapr> Loading package OpenGL ... linking ... /usr/lib/ghc-6.0/HSOpenGL.o: unknown symbol `GET_PROC_ADDRESS'
08:08:47 <shapr> ghc-6.0: panic! (the `impossible' happened, GHC version 6.0):
08:08:47 <shapr> 	can't load package `OpenGL'
08:09:40 <Igloo> Ah, that sounds like the thing I hacked just to make it compile - I guess should fix it properly  :-)
08:09:42 <SyntaxPolice> hi shapr
08:09:45 <shapr> hi SyntaxPolice 
08:09:59 <earthy> do I want to know why there's tuple types up to 38-ary tuples?
08:10:05 <earthy> defined in the haskell Prelude?
08:10:08 <SyntaxPolice> OK so one of these is OK, and one isn't:
08:10:10 <SyntaxPolice> data ANumber = forall a. Num a => ANumber a Int
08:10:10 <SyntaxPolice> data ANumber' = forall a. Num a => ANumber' {anum::a,
08:10:10 <SyntaxPolice> 					     anint::Int}
08:10:36 <earthy> syntaxpolice: is the latter ok? :)
08:10:40 <SyntaxPolice>   Can't combine named fields with locally-quantified type variables
08:10:40 <SyntaxPolice>     In the declaration of data constructor ANumber'
08:10:40 <SyntaxPolice>     In the data type declaration for `ANumber''
08:10:45 <SyntaxPolice> no, the latter is broken :(
08:10:48 <shapr> Igloo: same happens for both GLUT and OpenGL in ghci
08:10:49 <earthy> odd.
08:11:11 <shapr> they may still compile though
08:11:14 * shapr tries
08:11:21 <earthy> anyway, time to go get home
08:11:38 <SyntaxPolice> l8r earthy
08:12:04 <Igloo> I doubt it
08:12:27 * Igloo is just looking to see what the correct fix is, but then it'll be a couple of hours to build (assuming I get it right)
08:14:21 <Marvin--> time to go home
08:22:53 <shapr> Igloo: how do I find out which importable modules are in those packages?
08:23:32 <Igloo> shapr: Compiling hopefully-fixed packages now
08:23:45 <shapr> ok
08:24:35 <Igloo> One way is to see what .hi files there are listed by dpkg -L ghc6-prof
08:24:38 * SyntaxPolice notes that a haskell-experamental apt-source at monk.debian.net is almost ready
08:24:39 <shapr> ah
08:24:43 <Igloo> There may be a flag you can pass to ghc, I'm not sure
08:24:52 <Igloo> Cool
08:25:01 <SyntaxPolice> sometimes I get carried-away with hyphens
08:25:11 <Igloo> :-)
08:25:45 <dark> Hmm... is there a tool viewing a collection of modules as a tree?
08:25:45 * Igloo might make a pure-stable chroot and backport ghc to stable for it
08:25:54 <dark> I'm trying to get a sense of what imports what.
08:26:00 <shapr> DARK!
08:26:03 * shapr pounces!
08:26:10 <dark> shapr: Hello :)
08:26:13 <shapr> hiiii!
08:26:38 <shapr> long time no see, how's life?
08:26:44 <SyntaxPolice> Igloo: that would be real nice of you
08:26:54 <dark> shapr: I've been hacking on linux :)
08:26:57 <shapr> yay
08:26:57 * SyntaxPolice has to read docs on mini-dinstall
08:27:03 <shapr> did you end up writing a filesystem?
08:27:08 <dark> But now I'm trying to make sense of my old haskell code.
08:27:19 <shapr> uncc?
08:27:35 <dark> shapr: Sort of... I can mount it and list empty directories :)  I wanted to take a break from C before deciding how to do indexed directories.
08:27:38 <shapr> I haven't gotten around to pulling your FTP code out of your SCCS
08:27:55 <shapr> speaking of SCCSs written in Haskell, have you seen darcs?
08:28:00 <dark> shapr: I'm looking at Mage again.  Taking a break means games :)
08:28:06 <shapr> yes, Mage is nifty
08:28:36 <shapr> and I've learned lots about path-finding in the last few days.
08:28:53 <dark> "darcs"?  Maybe I should complain about the name :)
08:29:24 <shapr> I think you'll like the theory of patches
08:29:36 <shapr> I still think darcs would be a good candidate to plug into a refactoring browser
08:29:53 <shapr> then you could keep track of code past refactorings
08:29:54 <dark> Mage could use improved pathfinding, it still takes several seconds to generate a level :)
08:30:33 <Igloo> How does creating a level work?
08:30:53 <Igloo> Oh, I have the idea that mage is a nethack sort of thing - is that right?
08:31:26 <dark> "... I have looked at patches as being analogous to the operators of quantum mechanics"
08:31:30 <shapr> Igloo: btw, the -package stuff may not work, but hierarchical imports seem to be doing something
08:32:01 <dark> Igloo: Yeah, it's inspired mostly by Crawl.  Well, it will be, once it does something interesting :)
08:32:57 <Igloo> Oh, interesting
08:33:08 <Igloo> Has it actually successfully linked something?
08:33:11 <dark> Igloo: It currently only generates "cave" levels, which work by creating a random "solidity" grid, smoothing it, and then using that to decide which parts are open and which parts are rock.  Then it uses A* to make doors such that all parts of the cave are connected.
08:33:29 <shapr> Igloo: no, but it's complaining about mismatched types when I try to compile, so something is happening.
08:33:42 <shapr> it does link when it's only imports, no actual code.
08:34:25 <Igloo> Actually, you might be OK as long as you don't use the exact symbol anyway
08:34:27 <shapr> A* is nifty.
08:34:51 <dark> These door-making paths are pretty much worst case for A*, though, since they'll always have to go through walls at some point.
08:35:12 <dark> I'm using the pathfinder to find "logical" places to make doors.
08:36:24 * shapr imports every HOpenGL module, hoping to find these types
08:37:41 <shapr> yay, I found some.
08:38:25 <Igloo> lol
08:38:26 <shapr> when I import Graphics.Rendering.OpenGL.GL, I expected to get everything exported from all the submodules.
08:38:30 <shapr> should I expect that normally?
08:39:37 <Igloo> dark: Perhaps it would be better to find reachable sets and then join close ones?
08:40:04 <Heffalump> igloo: can't you use pbuild to do that?
08:40:08 <Igloo> Or is that effectively what you mean?
08:40:15 <Heffalump> (build GHC debs in a pure-stable chroot)
08:41:06 <Igloo> I'd prefer to just have the chroot lying around and to work inside it by hand
08:41:36 <Igloo> Although the description implies it leave it around anyway, so I don'tsee what the difference is
08:43:26 <dark> Igloo: Hmm, do you know a fast way to determine which are "close"?
08:44:35 <dark> I already split the spaces up into contiguous sets and then connect them until there's only one left.
08:44:51 <Igloo> Bounding square would give you a good first approximation. How fast you could do it would depend on the shapes I think
08:46:02 <dark> A first approximation would probably be good enough.
08:46:54 <dark> Hmm... I just realized that starting the path in the smallest space will probably make it faster.  A* will quickly map out its starting space before it starts trying walls.
08:47:41 <dark> Oh... apparently I've realized that before, since the current code does that :-)
08:47:45 <Igloo> :-)
08:51:46 <shapr> seems that the HOpenGL tutorial by Andre Furtado is outdated
08:51:56 <shapr> looks like variables names have changed
08:53:24 <dark> shapr: darcs is indeed interesting.
08:54:16 <shapr> what do you think about in-repository refactoring?
08:57:28 <Igloo> Urgle?
08:57:30 <Igloo>   Extend type defaulting in GHCi so that
08:57:30 <Igloo>         ghci>  []
08:57:30 <Igloo>         []
08:57:30 <Igloo>   works.  Suggested by Ralf Hinze.
08:57:37 * Igloo wonders what's going on there
08:58:04 <shapr> just like Num defaulting, yah?
08:58:25 <Igloo> But what type has it defaulted to?
08:58:29 * Igloo looks at the changes
08:58:30 <shapr> that's a good question.
08:58:57 <shapr> aha, GLUT is a separate library in the fptools tree.
08:59:02 <Igloo> Maybe it's special-cased for []
08:59:08 * SyntaxPolice bounds around shapr
08:59:28 <shapr> maxBound (undefined :: Shapr)
08:59:51 * shapr boings around SyntaxPolice 
09:00:57 <shapr> hi hal
09:01:26 <Igloo> Oh, it changes it to defaulting to the first in the list if either Num a or Show a is in the context
09:01:33 <hdaume> hi
09:01:48 <shapr> Igloo: could I request having GLUT also in ghcN-hopengl ?
09:01:53 <jlouis_> hello hdaume 
09:02:32 <Igloo> Oh, err, *goes to look*
09:02:39 <dark> Cool, token-replace patches.
09:02:50 * Igloo wonders if it really does mean ghci only, in which case you could probably make a program that worked in ghci but not in ghc
09:02:58 <dark> shapr: What do you mean with in-repository?
09:03:22 <shapr> Igloo: that would be bizarre.
09:03:36 <hdaume> anyone know how to get ispell to skip my \begin{code} ... \end{code} blocks?
09:03:56 <shapr> add it to your personal dictionary? :-)
09:03:59 <Igloo> shapr: So you want libraries/{GLUT,OpenGL} instead of only the latter?
09:04:06 <SyntaxPolice> sounds like something haskell-mode should handle
09:04:12 <SyntaxPolice> but I don't know much about that 
09:04:15 <hdaume> shapr: no, i want to skip the whole block, not just the tags
09:04:41 <Igloo> Turn it inside-out and unlit it?  :-)
09:04:50 <shapr> Igloo: yes, GLUT is used in the examples, it seems to be the windowing part of OpenGL (?)
09:05:16 <Igloo> It's a layer on top of OpenGL
09:05:21 <shapr> dark: yah, extend the token-replace patch idea, and you get refactor patches.
09:05:31 * Igloo will have a look once this build has finished
09:05:49 <shapr> Igloo: thanks for all this package work, I greatly appreciate it :-)
09:07:38 <shapr> hopengl debs are spiffy
09:07:51 <shapr> I just wish threaded-runtime and hopengl weren't mutually exclusive.
09:09:03 <Igloo> Hmmm, it looks like it is being built, just not installed
09:10:13 <shapr> bonjour mattam
09:10:54 <Igloo> Bah, X has started splurting on my screen again. That can't be a good sign.
09:13:09 * Igloo resists building 4.3...for now
09:40:57 * shapr boings
09:41:24 * Igloo bounces
09:48:38 <xkb> yikes.. ocaml mailing list going mad
09:49:00 <hdaume> xkb: yeah, it's quite frustrating
09:49:06 <Igloo> ?
09:49:06 <shapr> spam?
09:49:14 <xkb> hdaume : yeah.. I just blocked it on the mail server
09:49:26 <xkb> shapr : no spam.. it keeps repeating messages
09:49:30 <shapr> that sucks
09:49:49 <xkb> yeah..
09:49:55 <xkb> esp If u have to per per usage
09:50:00 <xkb> (of bandwidth)
09:50:06 <shapr> yuk
10:02:38 <dark> shapr: You realize that I will now have to manage my phasefs code with darcs :)
10:02:59 <hdaume> phasefs?
10:03:39 <dark> hdaume: I'm working on a phase tree filesystem for linux.
10:04:11 <dark> Currently I have mkfs, mount, and readdir working... but readdir only on directories that are empty :)
10:04:31 <dark> I got a bit stuck trying to decide how to do indexed directories.
10:04:41 <Igloo> That's a pretty small value of "working"  :-)
10:04:50 <dark> Which is ironic, since that doesn't have much to do with phase trees.
10:05:09 <dark> Igloo: But it means that most of the _design_ is done :)
10:05:27 <hdaume> that's cool
10:05:34 <hdaume> how long have you been working on this?
10:07:05 <dark> hdaume: Difficult to tell... I've been thinking about it for a while.  But I started writing actual code about eight weeks ago.  Then I got stuck about two weeks ago.
10:07:42 <hdaume> ah
10:08:13 <dark> I haven't worked up the courage to tell Daniel Phillips about the project yet, because that would make it official :)
10:10:09 <Igloo> Hmm, ghc5 built faster than ghc6 despite the fact that I think it build all the libraries twice
10:11:25 <hdaume> i blame TH :)
10:11:37 <xkb> What are phase 3 trees?
10:13:57 <Igloo> :-P
10:14:26 <xkb> euh minus the 3
10:14:26 <xkb> :D
10:14:49 <hdaume> xkb: google.com/search?p=phase+tree
10:14:56 <hdaume> erm, ?q=, rather :)
10:15:21 <dark> xkb: The full name is really "phase tree filesystem".  It's a filesystem where all the data is organized as a tree with a single root, and updates are batched in phases.  Each phase writes only into space unused by the current tree, and then atomically commits a new root.
10:15:53 <xkb> ah
10:15:55 <dark> The grand idea is to reinstate the power switch as a valid way to turn off your computer :-)
10:16:07 <xkb> Ill google for more detail :D
10:16:23 <hdaume> dark: imagine that :)
10:16:27 <dark> xkb: Look for "Daniel Phillips" and "tux2-dev" as well.
10:17:05 <xkb> I what ways is this different from say ReiserFs 2?
10:17:21 <dark> hdaume: With phase tree filesystems, and a Linux BIOS, I can get back the joy I had with the TRS-80 :)
10:18:23 <dark> xkb: Well, I don't know much about reiserfs.  But the phase tree filesystem uses uniform-depth trees, not balanced trees.
10:19:10 <Igloo> uniform depth meaning what exactly?
10:20:51 <dark> Igloo: All leaf nodes are at the same distance from the root.  Growing the tree is done by adding another indexing level.
10:21:41 <Igloo> That's either true of balanced trees or within epsilon of it, depending on what the definition is
10:23:28 <dark> Igloo: the mechanisms are different.  Indexing these trees relies on the leaves being numbered; the leaves are not compared to each other.  So you never have to rebalance, you just have to know what your highest leaf number is and what the branching factor is.
10:23:59 <Igloo> OK, fixed GHC 6 debs are at http://people.debian.org/~igloo/ now, debs with glut will be along in another couple of hours
10:24:13 <dark> It works fine for block and inode tables, but not so fine for filenames, which is why I'm having difficulty deciding how to do indexed directories :)
10:27:13 <shapr> @prelude iterateUntil
10:27:16 <lambdabot> No match for "iterateUntil".
10:27:45 <ddarius> takeWhile p $ iterate f z
10:27:52 <shapr> ah, thanks :-)
10:28:13 <shapr> I've been fighting with a recursive scanr thingy, and realized something like iterateUntil would be simpler
10:28:33 <ddarius> There may be something that does iterateUntil, is until it.
10:28:37 <ddarius> @prelude until
10:28:38 <lambdabot> *** "until" prelude "Haskell Standard Prelude Dictionary": text follows
10:28:38 <lambdabot> until
10:28:38 <lambdabot>   until ::  (a -> Bool) -> (a -> a) -> a -> a
10:28:38 <lambdabot>   until p f x     = if p x then x else until p f (f x)
10:29:01 <ddarius> that should do it.
10:29:10 <ddarius> except it doesn't return a list...
10:29:18 <shapr> right
10:29:32 <shapr> and I wanted scanr output, not foldr output
10:29:54 <shapr> now I want to do this recursively
10:29:55 * shapr thinks
10:30:33 <shapr> this is a spiffy definition of iterateUntil
10:30:37 * shapr adds it to his tools
10:30:41 <dark> brb, shopping
10:31:04 <shapr> hi peti!
10:31:14 <shapr> how are ya?
10:31:15 <peti> Hi. Can anyone recommend a good introductionary book about denotional semantics?
10:31:22 <shapr> gutentag, wie geht es?
10:31:29 * shapr pretends to speak german
10:31:31 <peti> shapr! I'm fine, thanks. How are you?
10:31:45 <shapr> I'm writing Haskell code, so I'm cheerful.
10:31:52 * peti points out that "Alter Schwede!" is a very common idiom in German. :-)
10:32:00 <shapr> what does it mean?
10:32:07 <shapr> become swedish?
10:32:10 <peti> shapr: "Old Swede!" *grin*
10:32:16 <shapr> ah
10:32:52 <shapr> hm, someone recommended a book about that to me recently
10:32:54 <peti> shapr: It's an exclamation in the context of being impressed with somebody.
10:32:56 * shapr looks
10:33:05 <peti> shapr: No kidding. ;-)
10:33:33 <Marvin--> woohoo, someone using Sweden and/or Swede in positive terms!
10:34:00 <shapr> looks like I didn't save the recommendation, oops
10:34:03 <hdaume> Marvin--: what?  does that put you one step above the french?
10:34:09 * peti thinks Swedes have a very good reputation in Germany, much as most of the northern countries are appreciated very much here.
10:34:26 <peti> Mostly they're famous for the drinking, though. :-)
10:34:28 <Marvin--> hdaume: yup!
10:34:53 <h> http://zolo.freelsd.net/~sts/ICFP03/greet.html
10:35:01 <shapr> finns drink more than swedes in my experience.
10:35:03 <hdaume> Marvin--: i heard a terrible joke a little while ago..."why are the streets in paris lined with trees?"
10:35:05 <peti> shapr: I fear I probably won't make it to Stockholm in August. :-(
10:35:10 <shapr> aww :-(
10:35:13 <hdaume> Marvin--: "because german soldiers like the march in the shade"
10:35:13 <hdaume> :)
10:35:17 <peti> Too many obstacles.
10:35:51 <shapr> maybe next year they'll have it in .de
10:35:57 * peti 's impression is that the alcohol is way too expensive in either Sweden or Norway to drink much of it. :-)
10:36:16 <Marvin--> peti: we prioritize!
10:36:19 <shapr> I don't buy alcohol enough to know the difference.
10:37:00 * peti stopped drinking pretty much a few years ago. Once you're older than, say, 18, it loses part of its appeal.
10:37:26 <peti> But every now and then I enjoy a few beers quite thoroughly. :-)
10:37:56 <Marvin--> heck, I don't drink heavily either
10:38:04 * Marvin-- was out drinking beer with moshez yesterday
10:38:16 <peti> Anyway, looks like noone knows a book about denotional semantics? A pity ...
10:38:26 <shapr> I started drinking when I was 22, I was really sick, and I got this really amazing hangover where it felt like my head was being pinched off of my neck.
10:38:38 <shapr> I never felt like repeating the experienc.
10:39:10 <shapr> though I have learned that a beer on friday evening is a nice thing.
10:39:27 <peti> shapr: Yeah, the hangovers are what keeps me from drinking much alcohol. When I was 18, I could drink _several_ beers (and other stuff) and could still get up the next morning. These days, I'm sick for two or three days after a big party ...
10:39:31 <shapr> peti: if I find those book recommendations, I'll mail them to you.
10:39:43 <shapr> yuck, several days
10:39:58 <peti> shapr: OK, thanks!
10:40:26 <Marvin--> in my book it's all right to get drunk occasionally, as long as you're not too drunk, you know, so you can snap to it if something happens
10:40:46 <Marvin--> that said, I probably don't get that drunk more than once or twice a year
10:40:56 <peti> Marvin--: Agreed. I _hate_ it when people are so drunk that they start to get weird, or even aggressive.
10:40:59 <Marvin--> I don't particularly like hangovers either :)
10:41:01 <keverets> What's the best way to read in a directory structure in GHC?  Posix package and openDirStream/readDirStream or something else?
10:41:05 <shapr> hm, can I scanr a string through a bunch of functions?
10:41:33 <Marvin--> however, I'm fairly large (1.93 tall) so I can drink a fair amount of beer without getting really really drunk
10:41:35 <peti> keverets: System.Directory.getDirectoryContents
10:41:45 <Marvin--> whereas moshez was starting to get funny after two beers yesterday :-P
10:41:46 <shapr> Marvin--: how heavy?
10:41:49 <keverets> peti: thanks!
10:42:11 <Marvin--> shapr: good question, haven't checked for a long while, perhaps 80kg or so?
10:42:15 <shapr> I'm 1.76 and 100 kilos
10:42:32 <shapr> I claim wide-shoulders, not roundness ;-)
10:42:33 <Marvin--> 100 thousand? ;) *ducks*
10:42:38 <shapr> :-P
10:42:53 <shapr> yes, 100 thousand grams.
10:42:57 <peti> keverets: Or, if you want to read the whole tree, you might be interested in <http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/*checkout*/haskell-libs/Unstable/Peti/ReadDirHier.hs?rev=HEAD&content-type=text/plain>.
10:43:06 <Marvin--> I remember writing that on a maths test in school when I was something like 13 years old
10:43:07 <shapr> oh, I haven't seen that one
10:43:10 * shapr cvs up
10:43:42 <Marvin--> The question was phrased badly and used 'kilos' instead of 'kg' so I wrote a comment about that and got a "wiseass" (though nicer, I was 13, remember :P) comment back from the teacher :-)
10:43:51 <shapr> heh
10:43:57 <shapr> early geek behaviour
10:44:02 <Marvin--> yup
10:44:10 * peti wishes the world could finally agree on the metric system. :-)
10:44:12 <shapr> yah, I corrected my teachers too.
10:44:16 <Marvin--> actually, I think it was about when I was 13 that I started programming Pascal
10:44:30 <shapr> I started with BASIC when I was 12
10:44:35 <shapr> sinclair something
10:44:36 <keverets> peti: I'm still learning, so it's good to see that the types I made are almost identical to the ones you used.
10:44:40 <shapr> spectrum maybe?
10:45:02 <shapr> is there a 'reverse' scanr?
10:45:03 <Marvin--> shapr: have you checked tradition.se recently?
10:45:03 <peti> keverets: Ah, good. That re-inforces my design decisions. :-)
10:45:11 <SyntaxPolice> lalala
10:45:12 <shapr> where I can throw a value through a list of functions?
10:45:18 <shapr> SyntaxPolice: good music?
10:45:18 <Marvin--> shapr: 329 sek for WC3:FT, 399 sek for WC3 + WC3:FT
10:45:24 <peti> shapr: map?
10:45:26 <shapr> Marvin--: I'm sorely tempted
10:45:35 <SyntaxPolice> shapr: no, not yet. but soon...
10:45:44 <Marvin--> shapr: WC3:FT is still number one on the top sales list, WC3 + WC3:FT is number three :-P
10:45:45 <shapr> peti: but I want foldr/scanr behaviour
10:46:00 <SyntaxPolice> I got a wireless card that doesn't work w/ my kernel, but may work w/ wlan-ng, but ng seems unstable :(
10:46:05 <shapr> but I swore a solemn oath to never buy win32 software again
10:46:08 <shapr> and I've held out for years!
10:46:17 <Marvin--> shapr: but you happily play on someone else's computer
10:46:18 <peti> shapr: You want to apply a list of functions to a value and get what? A list of results? Or one result for all of them?
10:46:19 <shapr> which card? what chipset?
10:46:33 <Marvin--> shapr: sounds kinda hypocritical to me
10:46:34 <shapr> peti: a list of results
10:46:40 <shapr> Marvin--: yah, probably so.
10:46:56 <SyntaxPolice> I don't know ATM; I did a bunch of research last night, but I was looking at the wrong card most of the time...
10:46:59 <SyntaxPolice> actually, I can find it...
10:47:03 <peti> shapr: map (\x -> x "constant") [ id, id, id ]?
10:47:18 <shapr> SyntaxPolice: what does 'lspci -v' as root give you?
10:47:24 <ddarius> peti: I can point you at some lecture notes on denotational semantics, an online book on various semantics (operational,axiomatic,denotational,action), and another on language design with a section on denotational semantics.
10:47:29 <SyntaxPolice> tada: http://www.microcenter.com/single_product_results.phtml?product_id=0159213
10:47:37 <ddarius> @type scanl
10:47:39 <lambdabot> scanl :: (a -> b -> a) -> a -> [b] -> [a]
10:47:44 <SyntaxPolice> shapr: don't know ATM, don't have it w/ me.
10:47:47 <shapr> ok
10:47:51 <SyntaxPolice> the wavelan module might work, but I get errors when trying to load it.
10:47:54 <shapr> @type scanr
10:47:54 <lambdabot> scanr :: (a -> b -> b) -> b -> [a] -> [b]
10:47:58 <shapr> huh
10:48:07 <SyntaxPolice> shapr: but if you know about this kinda stuff, I'll harass you later today :)
10:48:16 <peti> ddarius: Please do! :-)
10:48:32 <shapr> SyntaxPolice: not about wireless cards specifically, just how to find chipsets and drivers for linux
10:48:35 <SyntaxPolice> I guess SMC provides linux drivers sometimes
10:50:57 <SyntaxPolice> shapr: cool. i'll see what I can find.
10:51:28 <shapr> scanr "a" [(++ "b"),(++ "c")] --> ["ab","abc"]
10:51:36 <shapr> that's what I'm trying to do.
10:52:13 <shapr> hm
10:54:37 <shapr> oh, I see how scanl is useful
10:55:08 <ddarius> peti: http://www.cl.cam.ac.uk/Teaching/1998/DenoSema/dens.ps.gz  http://www.cs.uiowa.edu/~slonnegr/plf/Book/  ftp://ftp.aw.com/cseng/authors/finkel/apld (specifically chapter 10 of the last)
10:56:13 <shapr> yay
10:56:26 <shapr> scanl (\x y -> y x) "a" [(++ "b"),(++ "c")]
10:56:34 <shapr> ddarius: thanks :-)
10:58:08 <Igloo> What are you actually doing, shapr?
10:58:27 <shapr> I'm doing lazy key promotion for a spam filter
10:58:42 <Heffalump> you what?
10:58:54 <peti> shapr: Which spam filter?
10:59:03 <shapr> peti: the one in haskell-libs
10:59:13 <shapr> that doesn't work very well :-)
10:59:30 <peti> Bah. Use mapSoN instead. :-)
11:00:02 <shapr> huh?
11:00:16 <shapr> oh,
11:00:21 <shapr> but I want to write my own.
11:00:57 <peti> shapr: Fair enough. :-)
11:01:04 <shapr> Heffalump: key promotion is where you start searching for FREE!!! and then look for FREE!! and then FREE!,FREE,Free,free]
11:01:18 <shapr> hey, you wrote mapSoN
11:01:29 <shapr> is it written in Haskell?
11:01:30 * shapr looks
11:01:32 * peti is doing lazy key promotion as well. :-)
11:01:41 <peti> shapr: C++, unfortunately. 
11:01:42 <shapr> oh, C++
11:01:48 <peti> shapr: I was young, I needed the money. *grin*
11:01:51 <shapr> heh
11:03:46 <shapr> so, my key promotion will be takeWhile (/=[]) $ scanl (\x y -> y x) [iterateUntil (/=) transform1,iterateUntil (/=) transform2]
11:03:52 <xkb> peti : books about den semantics: "The formal semantics of Programming languages", Winskel and "Semantics with Applications, A formal introduction" by Nielson also Semantics of Programming languages, structures and techniques" by ?? (MIT)
11:04:09 <shapr> Heffalump: that was slightly wrong, but you get the idea
11:04:10 <peti> xkb: Thanks!!
11:04:13 <xkb> yw
11:04:40 * shapr runs off to be social for a bit, bbl
11:04:41 <Heffalump> right, yeah
11:04:42 <Heffalump> bye
11:05:16 <ddarius> shapr: (not . null)
11:06:07 <ddarius> okay, in this case there's no difference
11:06:26 <xkb> whats the syntax of the lambdabot?
11:06:31 <xkb> \ for lambda?
11:06:47 <xkb> like \x.x+x ?
11:07:17 <ddarius> @eval (\x.x+x) 5
11:07:18 <lambdabot> 10
11:07:29 <xkb> aha
11:07:34 <xkb> you need to eval :D
11:07:54 <xkb> Does it know combinators allready?
11:07:58 <xkb> like Y, I etc?
11:08:32 <xkb> hmm.. darn  gotta get back to learning again
11:08:35 <xkb> cya l8r
12:02:42 <elmex> hm
12:02:56 <elmex> what to do about readline when building ghc6 ?
12:04:33 <elmex> my life sucks
12:06:12 <peti> elmex: What's the problem with ghc?
12:06:35 <elmex> none
12:06:40 <elmex> ghc is fine, but i suck
12:06:54 <elmex> i can't compile haskell on the fly
12:06:54 <peti> No, I meant, I can help you some way?
12:07:03 <peti> ghci doesn't work?
12:07:07 <elmex> peti: no, got the problem. but thanks!
12:07:14 <peti> OK.
12:07:53 <elmex> peti: i mean, i look at the source, but compiling it down to machincode takes me very long... doing it in my brain and all. you know?
12:14:13 <peti> elmex: Then perhaps your brain uses an old CPU? Mine runs on Haskell directly.
12:14:19 <peti> Albeit only Haskell 98.
12:14:22 <xkb> lol
12:14:22 <peti> *sigh*
12:14:35 * peti wishes he could do existencial data types already.
12:16:18 <peti> Well, I can say I have mastered the "lazy" part of Haskell pretty good, at least. :-)
12:16:27 * Riastradh recompiles peti with GHC -fglasgow-exts.
12:16:41 <peti> Riastradh: Thanks. ;-))
12:16:50 <elmex> peti: lazy?
12:16:55 <elmex> peti: what is lazy?
12:17:03 * peti is. :-)
12:17:08 <elmex> ;)))
12:17:19 <dark> peti: I do my dishes that way.
12:17:20 <peti> I'm only just learning everything when I need it. Like, three weeks to the exam. :-)
12:17:51 <peti> I just don't evaluate my knowledge, so to speak. :-)
12:17:59 <dark> "Today's lecture is about lazy evaluation.  Are there any questions?"
12:18:10 <peti> *hehe*
12:19:02 <peti> If I'm ever going to become a professor, I'm going to use _that_ line. :-)
12:19:06 <kenikov> Is there a good GUI compiler/interpretor for Haskell on Mac OS X, that I do not need to compile myself or run from the Command Line?
12:19:29 <peti> kenikov: Hugs? I think it works under Mac OS.
12:19:49 <Riastradh> OS X and GHC both run on OS X.
12:19:51 <Riastradh> Er.
12:19:56 <Riastradh> Hugs and GHC both run on OS X.
12:20:02 <Riastradh> That's quite a typo there!
12:20:08 <kenikov> Without use of COmmand Line?
12:20:18 <peti> kenikov: And you should find binary packages on the homepage, I think.
12:20:35 <Riastradh> Er.  You can install GHC and Hugs with a package, but why don't you want to use the commandline?
12:20:40 <peti> kenikov: Hugs itself is command line oriented. But that's the best way to use it, really.
12:21:05 <Riastradh> OK, you can run it from Emacs, which technically wouldn't be commandline as long as you don't run Emacs in a console.
12:21:26 <d33p> Riastradh: how do you run it in emacs?
12:21:38 <kenikov> I would like to run it from OS X.  Like I do for Python IDE 222
12:21:56 <Riastradh> M-x haskell-ghci-load-file   <- with the current buffer being a Haskell buffer, if I want to use GHCi; otherwise, C-c C-l for Hugs.
12:22:51 <peti> d33p: http://www.haskell.org/haskell-mode/
12:23:20 <peti> kenikov: Didn't someone just release qt for OS X?
12:23:32 <kenikov> Don't know.  I am looking for Hugs right now. 
12:23:33 <peti> kenikov: Then you can run it on Mac OS natively.
12:23:40 <kenikov> I will probably download it if I can run it without Command Line
12:24:30 <Riastradh> I'm fairly sure there's a binary distribution with a package installer, and you can run Hugs through Emacs.
12:24:43 <kenikov> Blah.  EMacs.
12:24:45 <peti> No, I mean that with the new qt library X11 is basically available under Mac OS, API-wise. Then _any_ X11 program can be run without the command line.
12:24:59 <Riastradh> What's wrong with Emacs?
12:25:17 <peti> Nothing. Just a thought ...
12:25:26 * Riastradh was addressing kenikov.
12:25:33 <peti> Ah. :-)
12:26:18 <kunphuzil> Can you have a list of functions?
12:26:34 <peti> kunphuzil: Sure.
12:27:50 <kunphuzil> Yeah, Emacs ownz ;)
12:28:46 <kunphuzil> do lists allow strings?
12:28:57 <kunphuzil> er, 
12:29:13 <kunphuzil> lists do not allow mixed types? 
12:29:38 <kunphuzil> i.e. ["string",2] returns an error
12:29:56 <tez> Yeah, only homogeneous lists.
12:30:13 <peti> kunphuzil: All elements of the list must have the same type.
12:30:53 <kunphuzil> oh ok
12:32:17 <peti> kunphuzil: If you want to have different types in one list, you'll often find that you really want to express them as tuples or data types instead.
12:32:40 <kunphuzil> ah yeah
12:32:41 <peti> kunphuzil: Like [(String, Int)], etc.
12:33:32 <kunphuzil> ok
12:33:38 <kunphuzil> yeah, i guess i forgot
12:34:03 <peti> kunphuzil: You're just learning the language?
12:34:26 <kunphuzil> yeah
12:34:57 <peti> kunphuzil: Then let me tell you this from recent experience: At first, Haskell is a bitch. But after a month, you'll _love_ it. :-)
12:35:28 <tic> peti, I think it's just a lot of language wrestling :)
12:35:50 <elmex> yea
12:35:51 <kunphuzil> Heh, yeah i think i am past the bitch stage ;)
12:35:55 * Igloo is an idiot
12:36:00 <elmex> i began haskell 2 months ago
12:36:08 <peti> I don't know ... At some point it made *snap* and then I realized how simple everything really is. 
12:36:10 <elmex> its like having sex with your computer
12:36:11 <Igloo> I forgot to make the trivial fix to GHC6 to fix the reported bug before rebuilding
12:36:19 <kunphuzil> er, well for a while reading the tutorials i was getting angry, picking it back up again
12:36:22 <elmex> peti: exactly!!
12:36:30 <peti> Whereas in other languages, such as C++, you'll snap trying to cope with how the language is getting more complicated the more you learn.
12:36:44 <elmex> hehe
12:36:46 <tic> bleh for C++
12:36:50 <tic> yay for Python! :)'
12:37:01 <elmex> ...
12:37:11 * peti programmed C++ for 5 years, and then somebody comes along and invents template meta programming.
12:37:12 <Igloo> Oh well, I don't want to do another upload for ~4 days anyway
12:37:17 <mattam_> it's a scripting language... not anyware near haskell or C++
12:37:24 <peti> I thought I'd go mad. :-)
12:37:26 <mattam_> anywhere even
12:38:27 <tic> met, uhh?
12:38:30 <tic> mattam, uhh?
12:38:38 <tic> mattam, so you say Python can't be compared to C++?
12:38:43 <mattam> yes
12:38:51 <tic> what a weird thing to say
12:39:10 <mattam> well, i think you'll go nowhere comparating them
12:39:14 <tic> hehe
12:39:22 <tic> mattam, have you actually _used_ Python?
12:39:25 <mattam> yes
12:39:30 <peti> mattam: I think Python is pretty popular with the C++ crowd. (See Boost.Python for instance.)
12:40:03 <tic> mattam, and you still think Python's just a scripting language that can't at all be compared to Python?  Let me ask you, what did you do with Python?
12:40:07 <mattam> yes, it's very nice to add _scripting_ so easily 
12:40:48 <tic> mattam, where did you find tuples, dictionaries, slices, hash, powerful syntax, among others, in C++?
12:41:02 <mattam> i did a little converter for sound files, a 'sort of p2p' client/server (using fnorb)
12:41:05 <tic> mattam, or the dynamic object system? (granted a language feature)
12:41:05 <jlouis> fighting over Python now?
12:41:18 <mattam> a Twisted XML app 
12:41:32 <peti> tic: Well, the STL in C++ had most of these, actually.
12:42:04 <tic> peti, sure, but is it really as easy to use and read as in Python?
12:42:05 <jlouis> ''Python is written in C++, therefore C++ must be better than Python''
12:42:13 <mattam> I say they're so completely different in terms of language features that you should not 'compare' them this way
12:42:15 <jlouis> dont quote me on that
12:42:21 <peti> tic: IMHO, yes, they are. Plus, they are type safe.
12:42:54 <tic> peti, type safe schmype safe =) that's because the language itself is statically typed.
12:43:15 <mattam> schmype ?
12:43:37 <tic> "type safe, schmype safe". I was mocking his statement.
12:43:39 <peti> Let's agree on this: Both languages are equivalent to a Turing machine.
12:43:44 <tic> peti, that's true. :)
12:43:46 <shapr> yay, turing
12:44:20 <shapr> I like both kinds of programming.
12:44:39 * SyntaxPolice gave up on language wars
12:44:43 <mattam> peti: well, that doesn't count as a comparison factor for programming language
12:44:47 <mattam> s
12:45:05 <peti> mattam: Well, at least it would be newsworthy, if you'd find two language where it did.
12:45:09 <peti> :-)
12:45:48 <peti> mattam: I don't know Python very well, so I cannot really argue about it.
12:45:52 <tic> peti, wouldn't that be e.g. haskell vs python?
12:45:57 <tic> turing vs maths
12:46:16 <peti> tic: A turing machine can express lambda calculus just fine. :-)
12:46:47 <tic> peti, *hmm* but haskell can't... doh. it can as well. :)
12:47:20 <peti> tic: Well, that's one thing Python has over Haskell: eval.
12:47:59 <elmex> that's one thing Python has over asm: eval
12:48:06 <Heffalump> do you know any compiled languages that have eval?
12:48:19 <elmex> Heffalump: thats it ;)
12:48:33 <peti> Heffalump: Good point. :-)
12:48:41 <elmex> we have got hugs
12:48:42 <mattam> Heffalump: lisp doesn't ?
12:48:45 <shapr> actually, Haskell has eval.
12:48:55 <peti> Haskell has the Hugs server.
12:48:56 <elmex> shapr: hugs?
12:49:03 <shapr> Template Haskell is one step past eval
12:49:08 <shapr> sort of :-)
12:49:11 <elmex> shapr: ??
12:49:18 <Heffalump> no, TH is weaker than eval purely in terms of language semantics
12:49:23 <peti> shapr: Indeed, _that_ is eval on steroids. :-)
12:49:34 <shapr> ah, but think of Template Haskell and runtime loading.... mmmm
12:49:37 <elmex> where to read about template haskell??
12:49:40 <shapr> the ultimate interpreter
12:49:44 <Heffalump> that's still weaker than eval.
12:49:56 <peti> Heffalump: Well, you have access to the IO monad ...
12:50:12 <peti> Heffalump: The machine is all yours in Template Haskell.
12:50:12 <Heffalump> ok, equivalently powerful, but much more hassle
12:50:33 <peti> Heffalump: It's just a different mechanism, I guess. But a cool one.
12:51:11 <peti> elmex: http://research.microsoft.com/~simonpj/papers/meta-haskell/
12:51:19 <elmex> microsoft?????
12:51:21 <elmex> eeeekk
12:51:38 <jlouis> elmex: yes
12:51:42 <elmex> WHY???
12:51:43 <mattam> don't be afraid, they don't sell it
12:51:44 <peti> elmex: Without Simon, there wouldn't be much left of the language, I fear.
12:51:51 <elmex> ok
12:51:57 <jlouis> the ''research'' is the key
12:52:25 <elmex> cool
12:52:30 <elmex> and ghc know how to do it?
12:52:39 <peti> elmex: Yes. 6.0 has it.
12:53:04 <elmex> i'm just compiling 6
12:53:31 <elmex> how to view ps ?
12:53:37 <elmex> gs is too small ;((
12:53:40 <mattam> gv
12:53:46 <mattam> ghostview
12:53:56 <peti> elmex: You can tell gs to zoom. Should be in the man page.
12:54:18 <mattam> ggv for gnome and kghostview for kde too
12:54:45 <peti> Or AcrobatReader.
12:54:49 <peti> *grin*
12:54:51 <elmex> i don't have gnome or kde
12:55:09 <elmex> i'm using twm on work and blackbox at home
12:55:54 <mattam> so gv/ghostview is the way I think
12:56:11 * peti has to go ... By everyone!
12:58:26 <elmex> i want to have eval in haskell. that would be like a multi-orgasm ;)
13:04:58 <kunphuzil> eval? what is that?
13:05:57 <hdaume> kunphuzil: eval "5+3" would be 8
13:06:22 <kenikov> Riastradh: I just don't like how emacs is run from the terminal.  I prefer textedit or notepad or BBEdit
13:07:03 <kunphuzil> kenikov: there is emacs for XWindows 
13:09:23 <kunphuzil> http://devusb.us/~kunphuzil/images/emacs.png
13:09:51 <kunphuzil> that is not XEmacs either
13:10:44 <elmex> and how is compile-time meta-programming able to do something like eval ?
13:12:36 <jlouis> I do not like eval
13:12:54 <hdaume> elmex: i don't think it is
13:13:05 <elmex> ok
13:13:10 <hdaume> jlouis: i agree :), though there are certain situtations where it would be nice
13:13:57 <elmex> why did they do such a fuzz about it then?
13:15:01 <hdaume> elmex: i think because in (non-compiled) languages like lisp, eval is very prevalent...it's easy to implement because you're interpreting anyway...it's nice when you want to have some sort of language built in to your system but don't want to write a lexer/parser/interpreter for it
13:15:48 <jlouis> though the loss of compilation is exactly what you wil loose
13:16:10 <jlouis> I do not think it is for speeding up computation they want it
13:16:11 <hdaume> exactly.  basically you won't be able to do any compilation anymore if you have eval
13:16:21 <elmex> hm
13:16:26 <elmex> ideed
13:16:50 <elmex> well... i don't really miss eval anyway
13:16:54 <hdaume> at least if you have an eval which can "touch" your variables, as in 'let x = 5 in eval "x+2"'
13:17:01 <elmex> i like haskell as compiled language VERY much
13:17:03 <Igloo> Lisp interpreters can compile code (not sure to what) for faster execution
13:17:04 <jlouis> Now I would prefer to see a partial evaluator for Haskell instead. That would really be nice to have
13:17:27 <hdaume> if you don't let eval look at your variables, then it's not bad
13:17:32 <hdaume> but perhaps not as useful
13:17:49 <elmex> hmm
13:17:57 <elmex> well.we will see what future brings
13:18:04 <jlouis> maybe a JIT compiler could compile the things around the eval and intepret the eval
13:18:32 <hdaume> jlouis: perhaps
13:20:37 <jlouis> Hmm, I need to think about that
13:23:50 <Igloo> Ah, from the hugs commit it looks like [] only works at the prompt, not within a program
13:24:38 <Heffalump> what did they do?
13:25:00 <Igloo> You can type [] at the ghci and hugs prompts and it'll display []
13:25:07 <Heffalump> IM how
13:25:07 <Igloo> And similarly [] == [], [] < []
13:25:31 <Igloo> It adds Show, Eq, Ord and maybe others to the list of things that cause defaulting according tothe default list
13:25:45 <Heffalump> "cause defaulting"?
13:25:54 <Igloo> Like how Num does in H98
13:26:19 <Heffalump> ah
13:28:30 <elmex> i need a better CPU 1400 mhz are soooo slow...
13:28:46 <elmex> something around 1400 ghz would be cool
13:34:37 <elmex> some CPU which works around 4.6*10^14 Hz would be cool too
13:35:02 <Igloo> What's special about that?
13:36:57 <tic> uhm
13:36:58 <elmex> freq of red light(afaik)
13:37:01 <tic> I have a P3-550
13:37:06 <tic> I don't think your CPU is too slow. :)
13:37:15 <tic> plus, I only have a 4200 RPM IDE drive
13:37:28 <elmex> hm, my ghc building takes now around 1 hour?
13:38:14 <Igloo> Is that a stage 2 build with profiling?
13:38:28 <elmex> ??? i dont know
13:38:38 <elmex> just downloaded ghc6 -> configure -> make
13:39:01 <Igloo> Hmmm, think it should be then. Takes me nearer 2 I think, though
13:39:02 <Heffalump> since when has ghci defaulted []?
13:39:15 <Igloo> A few hours ago
13:39:20 <Heffalump> ah
13:39:59 <elmex> do i really have to build it myself? its pain ;((
13:40:16 <ddarius> What OS are you using?
13:40:23 <elmex> linux
13:40:28 <elmex> x86
13:40:55 <Igloo> What distro?
13:41:15 <Igloo> You could always unpack the debs by hand, anyway, if the libraries matched
13:41:22 <elmex> hm....
13:41:23 <Igloo> Or the binary tarball or RPMs on the GHC download page
13:41:37 <Igloo> But you want to be using Debian anyway  :-)
13:41:38 <elmex> is that a build with ghci?
13:41:41 <Igloo> Yup
13:41:46 <elmex> and all libs?
13:41:52 <Igloo> Yup
13:42:09 <Igloo> Well, not quite all - stuff that isn't built by default like objectio isn't included
13:42:16 <elmex> ok
13:42:29 <elmex> if i'mable to download it, i will build it myself
13:42:49 <Igloo> So what distro /are/ you using?
13:42:56 <elmex> debian
13:44:07 <Igloo> Oh, OK - if you care about opengl libs then get debs from http://people.debian.org/~igloo/ (unstable only currently)
13:44:23 <Igloo> Otherwise just install ghc6 - again unstable only
13:44:36 <elmex> hm
13:45:08 <elmex> no, i want to install it to a special place... i don't really feel comfortable with debian (or any packaging distro).... 
13:45:29 <Igloo> Fair enough  :-)
13:47:27 <elmex> those packaging systems take too much control from me... i feel like loosing too much control over my system... i want to have at least the complete control over ghc
13:48:23 <Heffalump> dpkg -r gives you lots of control
13:48:41 <Heffalump> except when it flat-out refuses to remove a package
13:48:58 <elmex> ;)
13:49:05 <Heffalump> (does it have a no scripts option?)
13:50:29 <elmex> i'm not familiar with debian much...i'm only using it, because it's less bad than others... and for some simple packages like gtk or ssh and all those base stuff it's very fine
13:51:31 <Igloo> I think so
13:51:42 <Igloo> You can alway delete them from /var/lib/dpkg/info  :-)
13:51:47 <Heffalump> ick :-)
13:52:39 <dark> Igloo: Remember elegance!  Put an exit 0 at the top instead.
13:52:42 <elmex> i have a very nice linking-script in my /opt/ dir... works now for years very fine
13:53:07 <elmex> hm... why is there a Select module for haskell?
13:56:09 <Igloo> dark: If you like, but they're about to be deleted by dpkg anyway  :-)
13:59:54 <Heffalump> only if you do --purge, surely?
14:00:00 <Heffalump> I was about to say what you did before I realised that.
14:00:19 <Igloo> Really?
14:00:32 <Igloo> Oh, so you can purge after removing?
14:00:32 <Heffalump> well, if you're not doing that, it needs the postrm script for when you do
14:00:36 <Heffalump> yes
14:00:42 <Heffalump> of course you can
14:01:19 <Igloo> Yeah, fair enough
14:07:07 * hdaume is off for the long weekend. hooray independence. boo england!
14:07:30 <SyntaxPolice> woohoo!
14:07:37 <hdaume> later guys
14:07:58 <dark> Enjoy your life, liberty, and pursuit of happiness.
14:09:57 * Heffalump hung a Union Jack on his office door on Independence Day when I was in Redmond
14:11:57 <cale> Remember, you can't make a freedom omelette without breaking some international law eggs.
14:12:14 <elmex> lol
14:22:30 * stefp reach for his eggs.
14:24:33 * elmex touches /dev/eggs
15:24:21 <Riastradh> kenikov, Emacs needn't be run in a console.
15:24:39 <kenikov> oh
15:26:20 <Riastradh> It can be run in X11 (though you'll have to compile Emacs again with X support; the OS X distribution doesn't come with it), or use the Carbon port.
15:26:29 <Riastradh> Er, or be run using the Carbon port, even.
15:29:15 <Riastradh> But why don't you want to use the commandline, anyways?
15:31:12 <SnoopDoggy> Because, it's nonsense.  Why should I?  If I want to type in commands I would of stuck with DOS
15:31:35 <Riastradh> That's, uh, not exactly great logic.
15:31:51 <SnoopDoggy> It is awesome logic, thus the majority of us don't type in commands anymore
15:32:28 <Riastradh> I don't see the logic in it at all -- DOS used commands, therefore, commandlines are suited only to DOS.
15:33:30 <SnoopDoggy> The point that the percent of people that use DOS is so low, because typing in Commands is obsolete.
15:33:48 <Riastradh> How is it obsolete?
15:34:08 <Riastradh> Because DOS is old, therefore everything associated with DOS is obsolete
15:34:08 <Riastradh> ?
15:34:51 <SnoopDoggy> No.  Typing commands is stupid.  Why type it anymore in a big black screen when you can simply click?
15:35:29 <Riastradh> Why click over and over again when you can type into a terminal and get the job done faster?
15:35:34 <Riastradh> The logic works both ways.
15:35:34 <SnoopDoggy> If I am correct, you own a Mac.  And it was Mac users who quoted in saying typing in commands was obsolete, useless and PC users who claimed "Real Men typed commands"
15:36:00 <Heffalump> The claims of some Mac users are not the opinions of all.
15:36:05 <Riastradh> Generalization?  Where?!
15:37:13 <Riastradh> There was also this Mac user that said Python is better (that Mac user being you), so I must share that opinion...I wonder why I never use Python and often show an intense dislike towards it.
15:39:36 <Riastradh> Yes, I own a Mac.  All but one of my many computers are Macs, in fact.  And all but -two- run no GUI at all, simply MkLinux or Yellow Dog Linux.
15:40:12 <SnoopDoggy> YD Linux is GUI.
15:40:23 <Riastradh> Um.
15:40:24 <Riastradh> No.
15:40:31 <Riastradh> There is no GUI installed on any one of them.
15:41:37 <Riastradh> I guess I must be an x86 user if I don't use a GUI, huh?
15:42:28 <Riastradh> But hey...I don't ever use the x86 piece of trash in my basement!
15:43:04 <andersca> please stop trolling, Riastradh
15:43:15 * Riastradh isn't trolling.
15:43:18 * Riastradh is being sarcastic.
15:43:51 <SnoopDoggy> Riastradh: So, what if there isn't a GUI installed on them.  Yellowdog still has GUI.  I am looking at a screenshot of it right now.
15:43:55 <SnoopDoggy> And I see a perfect GUI
15:44:20 <Riastradh> Gah, just because you -CAN- run a GUI on Yellow Dog doesn't mean that I -DO- run one.
15:44:21 <Heffalump> but he said that his computer runs no GUI, not that YD Linux has no GUI
15:44:51 <Riastradh> I also -could- conceivably run X11 on the MkLinux box -- but I choose not to.
15:44:51 <SnoopDoggy> Heffalump: 	<SnoopDoggy>	YD Linux is GUI.
15:44:52 <SnoopDoggy> 	<Riastradh>	Um.
15:44:52 <SnoopDoggy> 	<Riastradh>	No.
15:45:12 <Riastradh> Yellow Dog Linux is a distribution of Linux, and -not- a GUI.
15:45:26 <Riastradh> It may -contain- a GUI, yes, but it is itself -not- a GUI.
15:45:49 <Riastradh> And I do not run that GUI.
15:46:07 <SnoopDoggy> But it has a GUI, so it is Graphical User Interface, if it HAS one.
15:46:09 <Riastradh> By your [il]logic, I must be an x86 user, not a Mac user.
15:46:24 <ddarius> and a heart
15:46:27 <Heffalump> I have a computer, does that mean I am one?
15:46:29 <Riastradh> All mammals are fur.
15:46:35 <Riastradh> No, wait, they -have- fur.
15:46:38 * Heffalump tries to stop laughing.
15:46:40 <Riastradh> See the difference?
15:46:49 <Riastradh> Heffalump, well, I dunno about you...
15:47:05 <Heffalump> OI!
15:47:07 <Heffalump> :-p
15:47:15 <Riastradh> OI only if you use comonads.  Weirdo.
15:47:32 <SnoopDoggy> Heffalump: Your inane comments aren't helping Riastradh's case.
15:47:45 <Heffalump> oh, silly me
15:47:46 <Riastradh> SnoopDoggy, your comments in general aren't helping your case.
15:47:50 <Igloo> I'm sure any decent definition of a computer precludes it making mistakes
15:47:50 <SnoopDoggy> If Yellowdog Linux has a Graphical User Interface, then it is a GUI
15:47:58 <Riastradh> OK, let me say again:
15:48:01 <Riastradh> All mammals are fur.
15:48:05 <Riastradh> No, wait, they -have- fur.
15:48:07 <Riastradh> See the difference?
15:48:09 <Heffalump> riastradh: just ignore him, please :-)
15:48:22 <Heffalump> funny as he is, this could become tedious quite quickly
15:48:25 <Igloo> SnoopDoggy: They make it a bit easier to laugh at you, though
15:49:13 <SnoopDoggy> Igloo: No, it makes it easier for me to laugh at Heffalump's lack of intelligence and his quality of debates behind the safety of my computer.
15:50:23 <Heffalump> Without wishing to sound swollen headed, I'd be surprised if many people that have talked to me for any length of time thought I was stupid.
15:50:24 <Riastradh> andersca, if -anyone-'s trolling here, it's SnoopDoggy.
15:50:32 <andersca> garh
15:50:33 <andersca> Riastradh: sorry
15:50:46 <andersca> Riastradh: that comment was directed at him
15:50:49 <Riastradh> Oh, heh.
15:50:53 <Riastradh> That makes a bit more sense.
15:50:57 <andersca> :)
15:50:58 <andersca> sorry
15:51:09 <SnoopDoggy> Heffalump: Maybe they didn't want to hurt your feelings? 
15:51:11 <Riastradh> SnoopDoggy, you see, the verbs 'to be' and 'to have' aren't exactly the same.
15:51:16 <SnoopDoggy> Nothing hurts more than the "truth"
15:51:29 <Heffalump> SnoopDoggy: that's a possibility, yes.
15:51:35 <Riastradh> Now, failing personal insults are not going to help your argument that 'to be' and 'to have' mean the same thin.
15:51:36 <SnoopDoggy> Riastradh: Don't correct my english you dumbass.  You are probably some inane American.
15:51:38 <Riastradh> Thing, even.
15:51:51 * Heffalump wonders what country SnoopDoggy is from
15:51:54 <Riastradh> OK.
15:51:59 <Riastradh> Avoir n'est pas etre.
15:52:04 <Riastradh> Better?
15:52:06 <Heffalump> lol
15:52:33 <Heffalump> is gar3-p360.st6wa.ip.att.net likely to be in the US?
15:53:20 <Riastradh> 'Avoir un GUI' n'est pas 'etre un GUI.'
15:53:37 <Heffalump> aww, leave the poor thing in peace, it's happy like it is
15:53:43 <Riastradh> 'To have a GUI' is not 'to be a GUI.'
15:55:29 <Heffalump> hmm. Is there any easy way to cope with both systems that have QuickCheck and those that have Debug.QuickCheck?
15:56:25 <Igloo> import QuickCheck as Q and Debug.QuickCheck as DQ? Or do I misunderstand?
15:56:50 <Heffalump> I want to import stuff from the quickcheck module, but I don't know what it'll be called
15:57:04 <Igloo> huh?
15:57:20 <Igloo> How do you plan to call it then?
15:57:20 <ddarius> I believe he is trying to write portable code.
15:57:31 <Igloo> Oh, I see
15:57:31 <Heffalump> what ddarius said.
15:57:57 <Igloo> I imagine you could do it with cpp
15:58:01 <Heffalump> hmm.
15:58:03 <Heffalump> maybe not
15:58:22 <Heffalump> I'll just import QuickCheck and make a comment that it needs changing
15:58:42 <dark> Riastradh: To be precise, he said "is GUI", not "is a GUI".  Probably using GUI as an adjective.
15:59:03 <Heffalump> hmm, can it be used as such?
15:59:12 <dark> Heffalump: apparently. :)
15:59:24 <Heffalump> ah, yes, he has perfect English, so it must be
15:59:28 <dark> I've seen people say "A GUI interface".
15:59:28 <Heffalump> how silly of me
15:59:32 <Heffalump> lol
15:59:54 <dark> Then again, I have seen NMB advertise itself as "The Dutch NMB Bank".  Guess what the N and B stand for.
15:59:58 <ddarius> dark: heard many people say, a GUI Linux?
16:00:10 <dark> ddarius: Only if they spilled syrup on it.
16:00:34 <Igloo> That probably works better if you know the Dutch for Dutch
16:00:47 <Heffalump> Nederlandsomething
16:00:50 <dark> Igloo: Yeah... but ".nl" is a clue :)
16:02:02 * Igloo thinks Holland when you say Dutch, but my geography isn't up to much
16:02:08 <Igloo> s'all foreign to me
16:02:23 <Heffalump> I'll tell Oege you said that.
16:02:29 <dark> Holland is the province that conquered the other provinces, which is why people can be touchy about it :)
16:03:39 <Igloo> Ah, so Holland is a subset of the Netherlands?
16:03:53 <Heffalump> They're all Spanish anyway.
16:04:09 <dark> Yeah.  It's split into two provinces (north and south holland), and the contain Amsterdam, Rotterdam, and The Hague.
16:04:29 <dark> I think the Amsterdam angle is how the rest of the world started calling the whole thing "Holland".
16:04:45 * Igloo looks at a map and wonders if Andorra is a country
16:04:45 <dark> After all, most dutch sailors would introduce themselves as being from Holland.
16:04:54 <Heffalump> yes, it is
16:05:04 <Igloo> It looks microscopic
16:05:19 <Heffalump> It's not microscopic in real life.
16:05:50 <dark> It has some sort of weird halfway status in the EU, IIRC.
16:05:59 <Igloo> Oh, I can zoom in on it. Looks like a 10mile radius?
16:06:09 <Heffalump> probably
16:06:20 <dark> Liechtenstein is another tiny one.  At some point it was for rent for the summer.
16:06:52 <dark> Luxemburg was just large enough to be treated as a full country :)
16:07:00 <Strike> Andorra is even tinier than Netherlands, maybe not tinier than Liechtenstein
16:07:06 <dark> It even has its own euro coins, which everyone tries to collect.
16:07:27 <Igloo> Liechtenstein looks about 4x15
16:07:50 <Igloo> If I find one any smaller I think I'll declare my backgarden to be a country
16:07:55 <dark> Monaco?
16:08:07 <dark> There are probably some island countries that are smaller.
16:08:14 <Strike> Vatican City :)
16:08:14 <Heffalump> but your back garden has not been independent for at least 1000 years
16:08:19 <Heffalump> probably at least 2000 years
16:08:20 <Igloo> Islands have an excuse
16:08:33 <Strike> San Marino is pretty tiny too
16:08:35 <dark> Some islands are slowly sinking, they can't help being small.
16:08:59 <dark> NL has some islands that move around.
16:09:02 <Igloo> Continue like that and they won't be able to help being wet
16:35:19 <ddarius> I think I found a relatively convenient way to do "typecase" with Dynamics.
16:47:07 <ddarius> Hmm, SyntaxPolice if you haven't already fixed your random number problem, you may want to look at (linear) implicit parameters if GHC extensions are acceptable.
16:50:07 <Heffalump> oh, yes, I forgot them
16:50:11 <Heffalump> but they do infect the type still
16:51:29 <ddarius> but it shouldn't require significant code restructuring as using a monad would (at least from the little I know about them)
17:01:46 <Heffalump> true.
17:39:47 --- topic: set to '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","ghc rpms: http://haskell.org/~petersen/rpms/ghc/","arrows preprocessor pre-debs: deb http://urchin.earth.li/~ganesh/apt/ unstable/"]' by Pseudonym
18:02:05 <dark> Hmm. I wonder if I could make ghc warn me if a data declaration has a constructor that I never use.
18:02:39 <dark> I guess it does normally warn, but I want it to warn across export/import boundaries, if I tell it that this is the whole program :)
18:03:51 <Pseudonym> Why would you want that?
18:04:06 <Pseudonym> Note, incidentally, that if you derive anything, you do implicitly use it.
18:05:11 <Heffalump> well, Eq, Ord, Show etc just pattern match on it, they don't ever construct values of that type
18:05:21 <Heffalump> Read, Enum, etc do the latter
18:05:25 <Pseudonym> I thought that counted as "use".
18:05:40 <Pseudonym> Or did I miss something?
18:05:53 <ddarius> dark you could grep 
18:06:03 * ddarius the closet Luddite.
18:06:04 <Igloo> The point it that if you have data Foo = Bar | Baz and you never make a Baz then you probably have a bug
18:06:15 <Igloo> The fact you can consume one is irrelevant really
18:06:31 <Pseudonym> Well in general it's an unsolvable problem, of course.
18:06:47 <dark> Pseudonym: I mean use of the constructor, yes.
18:06:56 <Pseudonym> For example:
18:07:02 <Pseudonym> data Foo = Bar Int | Baz Int
18:07:07 <Pseudonym> inc (Bar x) = Bar (x+1)
18:07:12 <Pseudonym> inc (Baz x) = Baz (x+1)
18:07:14 <dark> ddarius: I have a large number of identifiers :)
18:07:19 <Pseudonym> Here you construct a Baz.
18:07:24 <Pseudonym> But you need a Baz first.
18:07:50 <dark> Pseudonym: hmm, indeed.  
18:08:12 <dark> I didn't think of that because the type I'm worried about has a _long_ list of nullary constructors :)
18:08:23 <Pseudonym> Oh, I see.
18:08:24 <Pseudonym> Hmmm.
18:08:29 <Pseudonym> Yes, grep. :-)
18:08:33 <Pseudonym> Or, in your case, egrep.
18:08:57 <dark> Specifically it's in my Language module, I have one constructor per word that I support.  I'd like to be able to prune unused ones, to save translation effort later.
18:09:06 <Pseudonym> egrep -f in very particular.
18:09:15 <dark> All of them are used in pattern matches, in the individual language modules :)
18:09:28 <dark> But I guess I could leave Language/* out of the grep.
18:30:45 <Pseudonym> Interesting.  The Greek work *tupos*, from which we get "type", originally meant a blow or the effect of a blow or pressure.
18:31:18 <dark> We still "hit" keys :)
18:33:11 <Riastradh> I prefer punching keys.
18:33:25 <ddarius> Pseudonym: that makes perfect sense
18:33:39 <Pseudonym> Yes, it does.
18:33:54 <Pseudonym> It then came to mean the impression of a seal or a mould.
18:34:05 <Pseudonym> And from there it came to mean "form" as we know it today.
18:34:35 * Pseudonym is writing the "Type" page for the wiki and thought he'd check up on the etymology
19:35:49 <shapr> whee
19:37:48 <dark> I'm going to bed :)
19:38:00 <shapr> yay, bed
19:38:13 <shapr> I should try that.
19:38:31 <dark> I've been adding a "help" command to Mage.  But because I'm running the command descriptions through my language module as imperative sentences, I get help that shouts "Open a door!  Go north!  Go south!" at me :)
19:38:58 <shapr> heh
19:39:02 <shapr> that's funny
19:39:38 <dark> I guess I can fix it by adding a sentence_fragment method.
19:40:19 * Igloo gets buried in opengl and starts to think the solution is either to ignore it until 6.2 or to copy the new library across
19:40:23 <dark> I also have a feeling it might be better to just write these help texts as files :)  But then they won't auto-adjust if the user remaps keys.
19:41:12 <dark> Anyway... bed!
19:41:17 <shapr> g'night dalor
19:41:20 <shapr> arf
19:41:33 <shapr> Igloo: huh?
19:43:38 <Igloo> shapr: I'm getting "unknown symbol `glActiveTexture'" from ghci -package GLUT that looks fixed in the CVS version - I could copy the fix across, but I'm wondering how many more there will be afterwards
19:43:46 <Igloo> Maybe I should mail Sven
19:44:32 <shapr> yes, good idea.
19:51:25 <steveh> oh sweet
19:51:35 <steveh> there's a windows and linux version of bolo
19:51:36 <steveh> :)
19:51:42 <shapr> what's bolo?
19:52:15 <steveh> the original RTS game
19:52:15 <steveh> :)
19:52:30 <steveh> it was for mac in the late 80s/early 90s
19:52:45 <steveh> you pilot a tank and try to take over bases on a map
19:52:49 <steveh> build walls, boats,
19:52:55 <steveh> capture automated pillboxes
19:53:06 <steveh> http://www.winbolo.com
19:55:57 <steveh> check out those system requirements!
19:55:58 <steveh> ;)
19:56:14 <steveh> System Requirements:
19:56:14 <steveh> * Windows 95/98/NT4(SP5+)/2K
19:56:14 <steveh> * 8Mb of RAM
19:56:14 <steveh> * DirectX 3 or greater
19:56:14 <steveh> * Display capable of 16 bit colours or greater
19:56:20 <shapr> wow, rough
19:56:59 <steveh> that game and Marathon were common illicit materiel on my high school's computers...
19:57:23 <shapr> I loved NetTrek
19:57:30 <steveh> the admin would delete one copy and 3 more would take its place
19:57:34 <shapr> on the Mac network we had
19:57:45 <steveh> bolo whomps nettrek
19:57:50 <steveh> no comparison :)
19:58:59 <Riastradh> Yay, I scared him off!
19:59:03 <shapr> yay
19:59:27 * Riastradh wonders how someone could be so stupid as to claim that a Linux distribution is a GUI.
19:59:37 * shapr shrugs
20:00:31 <ddarius> No, a Linux distribution is GUI
20:00:43 <steveh> I like http://www.lgm.com/bolo/intro/ as well
20:00:46 <steveh> cute description
20:47:25 <Pseudonym> Is it done to wish people a happy local independence day in the US?
20:47:42 <Pseudonym> Or do you just greet people with "No taxation without representation" or something?
