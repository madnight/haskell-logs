00:25:11 <Marvin--> "[the New Zealand Government] is the seventh government outside the US to be granted controlled, free access to Windows' source code"
00:25:28 <Marvin--> isn't that sort of a contradiction in terms?   *controlled* *free*?
00:27:06 <reffie> i think it means that they can't see all of it
00:28:04 <Marvin--> so how is it "free"?
00:28:33 <vegai> they can check the source code of Solitaire
00:28:34 <reffie> "free" as in "free beer"
00:29:22 <Marvin--> If I'm concerned about micros~1's quality of code, and say "unless you let me see the source code, I won't buy this thing" and they say "sure, we'll let you see some, but not all, and under an NDA of course", isn't that a reason to be *more* suspicious?
00:29:57 <reffie> i don't think so
00:30:03 <vegai> you don't?
00:30:06 <Marvin--> gpg: key 9C04F456: "Martin Sjögren <sjogren@debian.org>" 4 new signatures
00:30:07 <Marvin--> yay
00:30:22 <reffie> yay?
00:30:36 <Marvin--> signatures from the ksp are coming in :-)
00:32:31 <reffie> ah
00:33:07 <Marvin--> but please tell me why it shouldn't make me *more* concerned that micros~1 - even under pressure - won't reveal some of its source code while revealing other parts of it, under a strict NDA?
00:35:16 <vegai> they can't find their source code
00:35:53 <vegai> "We would've refactored the whole kernel, but we lost the source code in 1998"
00:36:20 <Marvin--> heh
00:37:36 <Marvin--> hmm, now should I write this crap in C or C++... yuck
00:38:48 <reffie> what crap?
00:39:31 <Pseudonym> Some of Microsoft's source code isn't theirs.
00:40:00 <Marvin--> I need some unicode normalization stuff, and python doesn't have it, so I'll have to interface with e.g. libicu
00:40:01 <Pseudonym> They bought it from someone else and can't show it without permission.
00:40:10 <Pseudonym> Oh, good.  libicu
00:40:21 <Pseudonym> That'll keep you going for about three years.
00:40:22 <Marvin--> problem is that their C API is ghastly, and C++ is...ghastly on its own
00:40:49 <Marvin--> Pseudonym: :) yeah, it's sort of...large... hopefully I'll only need a few lines
00:41:09 <Marvin--> I'm hackishly using normalization to get an ascii approximation of a unicode string *cough*
00:42:01 <reffie> why is c++ ghastly?
00:42:36 <Marvin--> it's just way too big, has way too many features and hacks
00:43:15 <Marvin--> there are too many ways to write the same thing... I've seen C++ files maintained by multiple people -- without having a style guide, heh
00:44:37 <Pseudonym> Well that's bad engineering, not bad language.
00:44:57 <Marvin--> yes and no, it's much worse in C++ than in any other language I've seen
00:44:59 <Pseudonym> I used to use all the same arguments against C++ until I wrote my first nontrivial program in C++.
00:45:20 <reffie> Marvin-- is it even worse than perl? :P
00:45:33 <Marvin--> reffie: afaict, yes
00:45:47 <reffie> heh.
00:45:54 <Pseudonym> I would strongly disagree with this.
00:46:05 <reffie> yeah
00:46:14 <Pseudonym> I know it's not done to defend C++ on a declarative programming channel, but that just shows what kind of person I am.
00:46:18 <Pseudonym> (i.e. suicidal)
00:47:10 <Pseudonym> C++ is a big language, but it's not so big that one person can't understand it.
00:47:21 <Marvin--> I think my biggest beef is the very ad hoc operator overloading
00:47:30 <Pseudonym> OK, that's a fair comment.
00:47:35 <Marvin--> I mean, overloading '='? Hello? I don't even know what assignment does? Eep?
00:47:51 <Pseudonym> It's no worse than overloading == in Haskell.
00:48:03 <reffie> indeed
00:48:09 <Marvin--> no, because == is by definition deep equality
00:48:14 <Marvin--> and you don't have to worry about allocation
00:48:23 <Pseudonym> No, == is by definition _semantic_ equality.
00:48:37 <Marvin--> with '=' overloaded, I never know if I'll get a copy or a reference to the same object
00:48:40 <Marvin--> fair enough
00:48:58 <Pseudonym> You can make a version of == which isn't, for example, transitive, and Haskell won't complain.
00:49:08 <Pseudonym> It will get its revenge later, of course.
00:49:14 <Marvin--> of course
00:49:22 <Marvin--> but it won't interfere with reference counting
00:49:30 <Pseudonym> That's true.
00:49:39 <Marvin--> I also dislike having both pointers and references(?)
00:49:45 <Marvin--> that & thingy
00:49:47 <Heffalump> Pseudonym: deepSeq is exactly what I did get it to do :-)
00:49:57 <Pseudonym> Heffalump: :-)
00:50:07 <Pseudonym> Well, most C++ programmers hate pointers too.
00:50:12 <Pseudonym> They usually don't use 'em.
00:50:18 <reffie> pointers are fine
00:50:42 <Pseudonym> Pointer arithmetic is evil.
00:50:51 <Pseudonym> It's occasionally a necessary evil, but it's still evil.
00:51:09 <Pseudonym> As for assignment... fact is that too many C++ programmers are still reading books dating from 1995 or so.
00:51:14 <Marvin--> references make me confused, just like Ada's inout parameters, and Pascal's var parameters
00:51:23 <Pseudonym> People who really program in C++ know full well that most objects don't need an assignment operator.
00:51:35 <Marvin--> can't you even overload dereference? '*foo'?
00:51:45 <Pseudonym> Yes you can./
00:51:47 <reffie> you can
00:51:50 <Pseudonym> Which is good.
00:51:51 * Marvin-- shudders
00:52:01 <Marvin--> yes! Let's overload pointers even more!
00:52:09 <Pseudonym> No, let's _avoid_ pointers.
00:52:15 <reffie> it's to make iterators
00:52:16 <Pseudonym> Use the syntax for things which aren't pointers.
00:52:18 <reffie> and stuff
00:52:35 <Pseudonym> It'd be nice to write *ref in Haskell rather than readIORef ref
00:52:36 <reffie> at least that's what i use it for.
00:53:04 <Pseudonym> Iterators, smart pointers, weak references... * is useful for all of them.
00:54:16 <Pseudonym> The main problem with C++, IMO, is that too many people treat it as an "improved C".
00:54:34 <Pseudonym> Which is rubbish.  C was never very good to begin with, except by comparison with PDP7 assembly language.
00:54:43 <Marvin--> heh
00:54:52 <Marvin--> there was a guy at debcamp who was trying to get an old PDP-7 to run
00:55:11 <Pseudonym> We had two PDP-8s, neither of which work, when I was doing honours.
00:55:21 <Pseudonym> We offered to try to make a working one out of them both.
00:55:25 <Pseudonym> The department said no.
00:55:54 <Pseudonym> I think that if we managed to get a working PDP-8, it would be repurposed for first years to use. :-)
00:56:24 <Marvin--> heh
00:56:40 <Marvin--> gah, unstable 'file' doesn't recognize debian changelogs
00:56:47 <Marvin--> changelog: \ \<!DOCTYPE\ html      broken HTML document text
00:56:50 <Marvin--> is that so? :-/
00:59:16 <Marvin--> the PDP-7 had an analog uptime counter, very cute :-)
01:01:59 <Marvin--> hooray, policy finally dictates that changelogs should be UTF-8
01:03:29 * Pseudonym crawls along with Adobe Illustrator over an rdesktop connection
01:03:40 <Pseudonym> Almost makes me want to install Windows.
01:03:41 <Pseudonym> Almost.
01:04:30 <Pseudonym> Another problem with C++ is that you need a decent amount of scaffolding before it's ready for your personal use.
01:04:42 <Pseudonym> Which isn't so much of a problem now that we have boost.
01:04:57 <reffie> boost?
01:05:04 <Pseudonym> boost.org
01:05:16 <Pseudonym> If you're programming C++ and you don't have boost, shame on you.
01:08:33 <reffie> heh
01:09:21 <Pseudonym> Seriously, boost's nicest thing is its pedigree.  It was started by members of the C++ standards committee as a testing ground for stuff they want in the next standard.
01:09:55 <Pseudonym> Also, it is basically a library of stuff that every development site has implemented separately and privately.
01:12:10 <Pseudonym> The trippiest thing is Spirit, which is an unlimited lookahead LL parser implemented entirely in the template system.
01:12:14 <Pseudonym> Someone should do this in TH.
01:12:26 <Pseudonym> This "someone", of course, being not me.
01:14:34 <reffie> TH?
01:14:52 <reffie> Template Haskell?
01:15:00 * Pseudonym nods
01:15:24 <Pseudonym> FINALLY
01:15:26 * Pseudonym sighs
01:15:44 <Pseudonym> Building patch CDs is boring and unnecessarily frustrating.
01:15:50 <Pseudonym> But I have conquered it!
01:16:04 <Marvin--> an LL parser implemented in the template system? GOOD GOD THAT'S NASTY
01:16:12 <Pseudonym> It's fast, though.
01:16:13 <Marvin--> See, that's why I don't use C++
01:18:38 <Pseudonym> Actually, I think this is the way languages are going.
01:18:42 <Pseudonym> They're going higher and wider.
01:18:53 <Pseudonym> Template metaprogramming, TH etc are "higher".
01:19:06 <Pseudonym> It's better, actually, than having a whole suite of tools like yacc and lex.
01:19:15 <Pseudonym> Which may not work well together.
01:23:04 <reffie> what license is this boost thing using?
01:23:52 <Marvin--> I wonder if I can hackishly just use PyUnicode_AsUnicode to get to the internal buffer that most likely is an array of wchar_t... the python source code says I can... hmm...
01:24:34 <Marvin--> seeing as PyUnicode_AsWideChar only does memcpy
01:25:00 <Pseudonym> boost mostly uses MIT-style
01:25:08 <Pseudonym> There's one which uses old BSD-style, which is the regex engine.
01:25:34 <Pseudonym> So don't use the regex engine if you're doing GPL stuff.
01:26:35 <reffie> brrr gpl
01:26:40 <Pseudonym> :-)
01:26:51 <Pseudonym> In that case you should be happy with it.
01:27:14 <Pseudonym> Remember that half of this is intended for standardisation, so it's very liberally licensed.
01:27:48 <Marvin--> all right, that code in python has been the same since March 2000, I think it's safe to say it won't change in python 2.2 or 2.3
01:30:05 <Pseudonym> And now, time for me to go home.
01:30:17 <Pseudonym> Night everyone.
01:41:31 <shapr> oy
01:42:00 <earthy> vey.
01:56:52 <Marvin--> welcome back Heff
02:33:55 <ask_hell> hi
02:34:02 <Heffalump> hi
02:35:11 <ask_hell> why is there no operator here ?
02:37:50 <Heffalump> no idea
02:37:57 <Heffalump> never really been a need for one, I think
02:38:16 <Heffalump> I think a few of us can get ops if we need them, but personally I've completely forgotten how :-)
02:38:20 <ask_hell> Good to hear that :)
02:39:10 --- mode: ChanServ set +o Heffalump
02:39:18 <Heffalump> oh, like that :-)
02:39:27 <ask_hell> lol
02:39:51 --- mode: Heffalump set -o Heffalump
02:39:57 <ask_hell> :)
02:40:07 <ask_hell> the principle of equality
02:40:24 <Heffalump> well, so I don't look like the channel's big boss man :-)
02:40:57 <ask_hell> I like the attittude :)
02:42:25 <earthy> err, well, err. ;)
02:43:21 <ask_hell> come on earthy, tell us what you want to say.. don't be afraid.. :)
02:45:22 <earthy> I've seen two ways of dealing with ops on channels
02:45:34 <earthy> 1: basically none at all
02:45:39 <earthy> 2: everyone gets 'em
02:46:39 <earthy> (where 1 may be made somewhat more agreeable due to friendly server ops...)
02:50:28 <Heffalump> earthy: and your point is? :-)
02:51:31 <reffie> mmm
02:51:38 <reffie> what do you guys think of ocaml?
02:54:43 * Heffalump hasn't used it for years
03:06:04 <reffie> why not?
03:06:53 <earthy> heffalump: none. :)
03:07:03 * earthy has only used ocaml to compile Coq with...
03:07:53 <Heffalump> had no reason to
03:08:16 <ask_hell> "Type error in application" <-- I have this error and know why that happen. I just don't know what to replace with
03:14:21 <kosmikus> ask_hell: you obviously try to apply a function to something which does not have the correct type. As long as I don't have more information, I'd suggest: either change the function that you use, or change the argument you apply it to.
03:15:59 <ask_hell> the line ... is "| otherwise"
03:17:51 <kosmikus> what's on the right hand side of the "| otherwise" ?
03:18:18 <kosmikus> you said that you know why the error occurs; what do you think the problem is?
03:19:11 <ask_hell> The types are different
03:19:28 <ask_hell> what appears in the error message..
03:19:41 <ask_hell> but the line .. itself has only "| otherwise"
03:20:56 <earthy> that explains then. :)
03:21:21 <earthy> (the empty string or the otherwise is obviously wrongly typed)
03:23:12 <kosmikus> the line of the type error message is obviously not the line where the error really is
03:23:22 <kosmikus> what's after the "| otherwise" ?
03:24:55 <ask_hell> check :: [a] -> [a]
03:25:21 <earthy> ask_hell: something's missing.
03:25:42 <earthy> the return value for the otherwise-case of the function being defined
03:27:02 <kosmikus> yeah, I'm suprised that you don't get a syntax error ...
04:40:32 <pepitoelprisas> jeeeeloooooou
04:41:53 <ask_hell> hi
04:44:36 <pepitoelprisas> i have some question that i dont understand
04:45:53 <pepitoelprisas> someone can help me with this?
04:46:06 <kosmikus> just ask
04:46:14 <pepitoelprisas> ok thx
04:46:23 <pepitoelprisas> prueba :: Integer
04:46:41 <pepitoelprisas> prueba = do j<-3
04:46:50 <pepitoelprisas> return j
04:47:32 <pepitoelprisas> i am a newbe in this language
04:48:25 <kosmikus> this is incorrect :)
04:48:29 <kosmikus> what are you trying to do? what's the question?
04:49:23 <pepitoelprisas> it is only a function that return a constant value
04:50:11 <kosmikus> okay, then write
04:50:13 <kosmikus> prueba :: Integer
04:50:16 <kosmikus> prueba = 3
04:50:24 <pepitoelprisas> yes :)
04:50:55 <pepitoelprisas> but i am trying the use of "do" and "return" keywords
04:51:04 <kosmikus> why?
04:51:24 <pepitoelprisas> to learn how they work
04:52:13 <kosmikus> how much a newbie are you?
04:52:50 <pepitoelprisas> it is courious because this works
04:52:50 <pepitoelprisas> prueba :: [Integer]
04:52:50 <pepitoelprisas> prueba = do d <-[3]
04:52:50 <pepitoelprisas> return d
04:53:06 <pepitoelprisas> only a week
04:53:17 <pepitoelprisas> i know a bit of Lisp
04:53:27 <kosmikus> okay
04:54:03 <kosmikus> well, as I said before, you usually don't need to use "do" or "return" in functions, unless it involves IO
04:54:04 <pepitoelprisas> the problem is why i need use a list
04:54:19 <kosmikus> but anyway, I'll try to explain briefly
04:54:37 <pepitoelprisas> ok thx
04:54:41 <pepitoelprisas> :D
04:54:52 <kosmikus> the "do" construct always evaluates to something that belongs to a so-called "monad"
04:55:00 <kosmikus> don't be scared by the name "monad" :)
04:55:12 <kosmikus> lists, for example, are a monad
04:55:17 <kosmikus> IO actions are too
04:55:33 <kosmikus> normal numbers (like integers) are not ...
04:57:08 <pepitoelprisas> and what about return?
04:57:18 <kosmikus> most programmers only need monads for IO in Haskell
04:57:20 <pepitoelprisas> it allways return a "monad"?
04:57:35 <kosmikus> yes, return is a function that "injects" a value into a monad
04:57:53 <kosmikus> so in the context of lists, "return x" is the same as "[x]"
04:58:17 <kosmikus> and in the context of IO actions, "return x" is the same as the action that does not perform any IO, but evaluates to x
04:58:38 <pepitoelprisas> monad = package (in other languages)?
04:59:02 <kosmikus> no, it is something like a mathematical structure
04:59:15 <kosmikus> you can see it as a data structure that provides specific operations
04:59:44 <pepitoelprisas> like a "class" in java :D
05:00:02 <kosmikus> in essence, a monad defines how to bind a value of the monad type to a variable, like in "d <- [3]", and how to inject normal values into the monad, like in "return d"
05:00:26 <kosmikus> a bit like it; in fact, "Monad" is a type class in Haskell
05:01:02 <kosmikus> so it's a specific class
05:01:35 <pepitoelprisas> can i use more monad´s in a function?
05:01:52 <pepitoelprisas> prueba :: Monad1 Monad2 ...?
05:02:34 <kosmikus> In theory, yes. You can combine multiple monads, or use them in different places of one function definition. You just have to find applications for it.
05:02:59 <pepitoelprisas> i am going to try
05:03:36 <kosmikus> you're welcome to, but maybe you should read an introduction to monads in Haskell first
05:04:21 <vegai> OT: what would be the best way to look at pdf and ps-files in tty?
05:04:22 <kosmikus> it is certainly not the easiest concept of the language
05:04:43 * earthy coughs
05:04:46 <kosmikus> vegai: ps2ascii, or something like that?
05:05:00 <earthy> kosmikus ought to be a brit, the way he plays with understatements. :)
05:05:02 <vegai> best way as in best-looking way
05:05:11 <vegai> yes, that works. I was wondering if there's something better
05:05:18 <earthy> vegai: nope.
05:05:23 <vegai> perhaps something using aalib? =)
05:05:38 <vegai> ...probably not
05:06:03 <kosmikus> hmm, doesn't ghostscript support aalib? I remember I've hear something like that ...
05:06:08 <kosmikus> s/hear/heard
05:06:10 <earthy> vegai: PS has this little problem that it basically only specifies what dots on a page to blacken
05:06:22 <vegai> auch
05:06:30 <earthy> the fact that you can get readable text out of it is only due to convention
05:06:53 <vegai> hmm, what kind of black magic does ps2ascii use then?
05:07:07 <vegai> gs. Ah. =)
05:07:18 <kosmikus> well, it only works for files containing text
05:07:45 <earthy> vegai: `hmmm. this looks like a string in roughly that position... let's guess that the encoding the font used to render the string is identical to the encoding the tty has and simply output the string'
05:08:13 <vegai> aye
05:08:20 <kosmikus> earthy said it in a much better way ...
05:08:33 <earthy> aalib would be better, but you'd have to scroll like mad to get anything resembling readable text
05:08:46 <vegai> or have an insane text-display
05:09:03 <earthy> well, yeah, but then you'd be better off just bitmapping...
05:09:17 <vegai> tty1: 2048x1024 ;) I wish...
05:09:31 <earthy> vegai: I don't.
05:10:26 <earthy> (unless it's also roughly5m x  2.5m large)
05:10:33 <earthy> (those are meters :))
05:13:47 <pepitoelprisas> i have tried to use a monad like IO
05:13:56 <pepitoelprisas> but it dont works
05:13:58 <pepitoelprisas> prueba :: IO [Integer]
05:13:58 <pepitoelprisas> prueba = do d <-[3]
05:13:58 <pepitoelprisas> print d
05:13:58 <pepitoelprisas> return d
05:15:28 <vegai> you need to separate actions with ; iirc
05:15:36 <Marvin--> pepitoelprisas: try 'let d = 3' instead of 'd <- [3]'
05:15:58 <vegai> Marvin--: he won't need monadic stuff then ;-)
05:16:22 <Marvin--> 'd <- [3]' unifies the types to the list monad, but print unifies to the IO monad, and you can't have two different monads in the same do expression
05:17:20 <pepitoelprisas> then how you will do it?
05:17:44 <vegai> why do you need to do this?
05:18:03 <Marvin--> I don't see why you want to use 'd <- [3]' at all, if you just want d to refer to 3, write 'let d = 3'
05:18:15 <Marvin--> do let d = 3 ; print d ; return d
05:18:47 <pepitoelprisas> but let and do not is the same?
05:19:10 <pepitoelprisas> it is only for
05:19:12 <vegai> it's the syntactic sugar in <- that confuses you. It is not quite like =
05:19:59 <pepitoelprisas> i think it is the asignation operator
05:20:04 <Marvin--> no
05:20:33 <Marvin--> do x <- e1 ; e2   is syntactig sugar for   e1 >>= \x -> e2
05:20:33 <pepitoelprisas> ok
05:20:40 <vegai> it's something much more sinister ;-/ 
05:20:48 <Marvin--> there is no "assignment operator" in haskell
05:23:31 <pepitoelprisas> I will read the manual again
05:24:46 <pepitoelprisas> thx for all
05:26:25 * Marvin-- drools over World of Warcraft
05:38:46 <pepito|studying> someone knows a good tutorial of haskell?
05:39:05 <pepito|studying> with some examples and so ... :)
05:39:19 <xkb> I know a good book
05:39:32 <xkb> The haskell school of expression
05:40:26 <kosmikus> Try the "Learning Haskell" page at http://www.haskell.org/learning.html
05:44:06 <pepito|studying> The Haskell School of Expression:
05:44:06 <pepito|studying> Learning Functional Programming through Multimedia
05:44:06 <pepito|studying> by Paul Hudak, Yale University
05:44:16 <pepito|studying> sound interessant
05:51:23 <earthy> and then there's hal daume's tutorial which is good as well
05:51:50 <pepito|studying> in the same page?
05:52:17 <earthy> yup. the `Yet Another Haskell Tutorial'
05:55:37 <pepito|studying> yeah, it seen a good tutorial
05:55:40 <pepito|studying> :D
05:57:08 <reffie> books are too expensive
05:57:17 <earthy> not really
06:35:40 <Marvin--> ello shapr
06:35:46 <shapr> hej Marvin-- 
06:35:48 <shapr> wassup?
06:36:37 <Marvin--> still working on the indexing thingy
06:36:43 <Marvin--> trying to figure out how to make it work
06:36:49 <shapr> we just colocated our first box, yay!
06:37:30 <Heffalump> shapr: what's the protocol on checking in stuff to haskell-libs (lambdabot in particular)?
06:37:38 <shapr> Heffalump: "be nice"
06:37:56 <shapr> that's the extent of the rules for haskell-libs 
06:38:17 <shapr> meaning, if you want to check in a Makefile, go for it
06:38:33 <shapr> if you find ways of fixing things, go for it
06:38:36 <Heffalump> I want to check in my exception handling code (once I fix a few more things about it)
06:38:42 <shapr> I prefer collective code ownership
06:38:45 <shapr> it's a cvs-wiki
06:42:39 <SyntaxPolice> good morning
06:42:44 <shapr> goood morning SyntaxPolice!
06:43:07 <shapr> wow, 700kB/s on my newly colocated box
06:43:13 * shapr bounces happily
06:43:14 <Heffalump> whats the colocated box doing?
06:43:27 <shapr> apt-get -ufdy dist-upgrade at the moment
06:43:40 <Heffalump> what's it for?
06:43:45 <shapr> it's destined to run many Zope sites for clients
06:44:06 <shapr> but I think I can make space for Haskell related projects
06:44:18 <Heffalump> where's it hosted?
06:44:24 <shapr> interact.se
06:44:30 <shapr> next city over
06:45:14 * Heffalump fails to read Swedish and the English co-location page doesn't work
06:45:26 <shapr> oh it doesn't??
06:45:34 <Heffalump> you get 10GB/month for 12000 SEK/year?
06:46:00 <shapr> um
06:46:48 <shapr> I think that's right
06:47:04 <Heffalump> I think I prefer urchin's deal :-)
06:47:15 <shapr> how expensive is urchin?
06:47:25 * juhp tries to build wxHaskell
06:47:33 <juhp> "unix-gtk: if you want to use the GTK2 toolkit, you need to configure without unicode support since the wxc can not handle unicode."
06:47:34 <Heffalump> £58.50/month for 40GB
06:47:38 <shapr> juhp: if you get it working, I want to play too!
06:47:41 <juhp> what da...?
06:49:37 <Marvin--> juhp: gtk2 without unicode support kinda...sucks
06:50:07 <juhp> reminds me i have some lambdabot fixes to check in too...
06:50:16 <juhp> Marvin--: yeah :-\
06:50:55 <shapr> hi alan
06:51:22 <shapr> looking for Haskellers?
06:51:27 <alanl> hello....does anyone know of a good writeup for haskell modules....? or I may have to write one myself
06:51:43 <shapr> what sort of writeup?
06:52:06 <alanl> something that a newbie can understand....(first year)
06:52:10 <Heffalump> juhp: what kind of fixes?
06:52:33 <shapr> alanl: what's your questions?
06:53:19 <alanl> I was marking an assignment and was shocked by the number of ppl who don't understand how to import/export modules
06:53:22 <juhp> Heffalump: i forget :)
06:53:37 <dark> alanl: How do they get it wrong?
06:53:47 <shapr> alanl: I learned from Thompson's Craft book, it's pretty straightforward
06:53:49 <shapr> hi Arnia
06:54:36 <alanl> like not exporting their ADTs, importing stuff we told them not to import...stuff like that
06:55:43 <shapr> I should post the 'rules' of haskell-libs to the mailing list, when I get around to it.
06:55:57 <Arnia> Hi shapr
06:56:21 <dark> Rule #5: if a module doesn't send you flowers on valentine's day, break off the engagement.
06:57:05 * shapr snickers
06:57:35 <shapr> alanl: I think the module import/export rules could be covered in less than a page
07:02:01 <alanl> whoever can understand the condensed version doesn't really need it! 
07:02:43 <shapr> maybe if you had each rule and one or two demo modules for that rule?
07:03:20 <alanl> so it looks like i'll have to do some writing.....:-(
07:03:49 <shapr> alanl: put on the HaWiki
07:03:52 <shapr> then we can all work on it
07:04:18 <shapr> Heffalump: truly, something is broken about lambdabot at the moment
07:04:28 <shapr> I think the new plugin system may have changed something else
07:04:56 <alanl> will do....has managed to get gtk2hs/ihaskell working?
07:05:14 <shapr> works for me
07:05:17 <shapr> though I had some help from juhp 
07:05:40 <Heffalump> shapr: in what way?
07:05:55 <shapr> I keep getting Prelude.head exceptions
07:05:56 <Heffalump> I've fixed the problems I was mentioning yesterday (with Pseudonym's help)
07:06:01 <Heffalump> when you do what?
07:06:08 <shapr> nothing, when it just runs for awhile
07:06:15 <Heffalump> oh, I don't :-)
07:06:26 <shapr> oh, I can run lambdabot from the colocated box! yay!
07:06:39 <vegai> colocated?
07:06:40 <shapr> finally, a stable platform for lambdabot
07:06:43 <vegai> oh... co-located ;D
07:06:44 <vegai> sorry
07:07:01 <shapr> I was a sysadmin at an ISP for awhile
07:07:13 <shapr> so bread and colo seem to be equally common words to me :-)
07:08:10 <vegai> heh
07:09:57 <dark> There was a long argument on K5 once that concluded that the proper spelling is actually "collocated".
07:10:21 <dark> The language is likely to change on that point, though :-)
07:10:30 <shapr> proper spelling is not my forté, and it's easier to type "colo"
07:12:21 <reffie> k5 sucks :P
07:14:40 * SyntaxPolice sips coffee
07:20:31 <shapr> silly question, couldn't hygienic macros be the basis of a refactoring browser?
07:20:44 <shapr> Riastradh: psst, you awake?
07:22:49 <earthy> shapr: come again?
07:22:55 <reffie> hygienic macros?
07:24:03 <shapr> I was just ruminating on the "how to design a language for ease of refactoring" thread on the pragmatic programmer's mailing list
07:24:18 <shapr> I think the solution is "make it easy to operate on the parse tree"
07:24:19 <earthy> ah
07:24:25 <earthy> yes.
07:24:28 <shapr> and I realized that hygienic macros in scheme really do that.
07:24:48 <shapr> but I haven't used them, so I wondered if they let you spit out the source from the macro, or only execute it.
07:25:14 <earthy> shapr: look into Eelco Visser's Strategic Programming stuff, if you haven't yet
07:25:29 <shapr> isn't he part of the MetaEnvironment project?
07:25:38 <shapr> and the Stratego language project also?
07:25:53 <earthy> yep
07:26:08 <shapr> I wish metaenvironment debs actually worked :-)
07:26:48 <earthy> well, I'm not sure about the MetaEnvironment stuff, but I am about the Stratego stuff
07:28:11 <shapr> stratego is spiffy
07:29:58 <shapr> SyntaxPolice: what email addy are you using on friendster?
07:35:05 <SyntaxPolice> friendster usually doesn't work for me :(
07:36:20 <shapr> why not?
07:36:43 <SyntaxPolice> it says there's too much traffic
07:36:56 <shapr> maybe the euro server isn't so busy
07:36:57 * earthy larts the X11R6.3 present on his solaris system
07:37:07 <shapr> or maybe just euro hours aren't so busy
07:38:13 <SyntaxPolice> what happened to the list of cookie sites in galeon anyway?
07:39:17 <shapr> I use mozilla-firebird nowadays
07:47:11 <shapr> how do I change the ratio of mouse to pointer movement in X?
07:52:08 <shapr> hi saz 
07:52:26 <saz> hi shapr :)
07:52:32 <reffie> are monads like .. streams?
07:53:07 <shapr> reffie: have you done any OOP stuff?
07:53:14 <reffie> yes
07:53:15 <shapr> you know class, instance, inheritance?
07:53:19 <reffie> yes.
07:53:44 <shapr> so, you know the basic idea of an object is that it's a common interface to useful code on the inside of the object
07:53:58 <shapr> even if the code inside changes, your interface stays the same
07:54:20 <reffie> yes.
07:54:42 <shapr> so, monads are also a way to hide details that you don't care about
07:54:50 <shapr> they're just another abstraction like objects
07:55:17 <Heffalump> hmm.
07:55:30 <shapr> Heffalump: don't think so?
07:55:42 <Heffalump> type classes are an abstraction like objects
07:55:49 <reffie> i thought they were some kind of sequence
07:55:50 <Heffalump> monads are a specific kind of type class that happen to be quite useful
07:56:44 <shapr> hej phubuh 
07:57:00 <phubuh> hej hej shapr
07:59:01 <kosmikus> shapr, Heffalump: I don't think that your two views are mutually exclusive
07:59:47 <shapr> I see monads as conducive to building pipelines
08:00:23 <shapr> and objects as conducive to addressing stuff, whether that's commands or data
08:02:33 <shapr> but I could be wrong
08:02:45 <shapr> kosmikus: how would you describe monads?
08:03:25 <shapr> I remember trying to explain OOP to a COBOL programmer once, I ended up saying "functions that you call with values, and they keep those values all the time"
08:03:37 <shapr> it's hard to describe the statefulness of OOP to a purely procedural programmer
08:04:12 <dark> Doesn't COBOL have modules?  You could approach it from that side.
08:04:26 <shapr> but objects aren't modules
08:04:41 <shapr> you don't really get multiple instances of modules
08:05:00 <shapr> the idea of functions that loop and always hold their value seemed to work for him
08:05:59 <shapr> nowadays I say "the blueprint of a house is directions to construct a house, but is not an actual house"
08:06:12 <shapr> "but you can make many houses from those instructions"
08:06:28 <shapr> I don't yet have a similar way to describe monads, any suggestions?
08:10:37 <dark> All I know about monads is that they let me pretend Haskell is procedural :-)
08:10:41 <shapr> hi hal
08:10:45 <hdaume> hi
08:10:53 <shapr> you coming to ICFP?
08:11:12 <hdaume> nope
08:11:15 <shapr> aw
08:11:42 * Riastradh is awake.
08:11:43 <SyntaxPolice> :(
08:11:46 <shapr> g'mornin Riastradh 
08:12:21 <Riastradh> What did you want to ask of me?
08:12:49 <Riastradh> Or inform me of, I suppose.
08:13:41 <shapr> can you get the source back from a bunch of hygienic macros?
08:13:51 <Riastradh> In what language?
08:13:59 <shapr> scheme
08:14:10 <Riastradh> In what implementation, and at what phase?
08:14:15 <shapr> heckifIknow
08:14:15 <kosmikus> shapr: I don't know. I usually say "some abstract thing that may produce value(s) of type a". I usually mention non-determinism, exceptions and state as the fundamental applications. But in fact, many people have slightly different views of monads, and I think that is perfectly okay.
08:14:23 <Riastradh> I can't say, then.
08:16:55 <Heffalump> fundamentally they are about sequencing side-effecting computations, IMO - but "side-effecting" can be as varied as non-determinism and exceptions
08:18:03 <Riastradh> Hmm.  I just thought of this: if monads are constructors, and comonads are destructors, wouldn't arrows be a combination of both?
08:18:12 <shapr> sure, arrows are transformers
08:18:38 <shapr> Arrow a b c is an Arrow from b to c
08:18:57 <Heffalump> in what way are monads constructors?
08:19:02 <Riastradh> Why do people bother with monads or comonads, then, if arrows are a generalization of either?
08:19:06 <shapr> they're type constructors
08:19:14 <Heffalump> so are arrows and comonads
08:19:21 <Heffalump> riastradh: monads have been around longer
08:19:27 <Heffalump> and are easier to understand
08:19:32 <shapr> I dunno about that
08:19:35 <shapr> I think arrows are simplest
08:19:35 <Heffalump> you don't have to prove as many laws to be sure you have a monad :-)
08:19:39 <Riastradh> Heffalump, a monad m may construct a value for a function f in 'm >>= f', but you may only construct and give the result to f, and you may never destruct.
08:19:40 <shapr> heh, that's true
08:19:43 <Heffalump> shapr: go on then, what are the arrow laws?
08:19:55 <Heffalump> riastradh: true, I guess
08:19:56 <shapr> have you seen my quote about arrows on the QuotePage ?
08:20:09 <shapr> there are two flavors of arrows, pure and impure
08:20:20 <Riastradh> With comonads, it's the other way around -- they destruct, but you can never get something _to_ destruct -- you can never construct them.
08:20:31 <shapr> pure arrows can come from lifted functions, and are equivalent to monads (I think)
08:20:37 <Heffalump> shapr: no.
08:20:40 <shapr> oh well
08:20:43 <shapr> @fact arrows
08:20:45 <shapr> oops
08:20:47 <shapr> bad 'bot
08:21:07 <shapr> Heffalump: have you checked in your fixes?
08:21:16 * shapr cvs up
08:21:35 <Heffalump> arrows that have an a (a b c,b) c operation are monads
08:21:37 <Heffalump> shapr: nope, sorry
08:21:41 <Heffalump> they're not done yet
08:21:50 <shapr> ok
08:22:23 <Riastradh> Heffalump, i.e. arrows that support 'app'.
08:22:44 <shapr> I won't understand arrows till I actually use them for awhile
08:22:51 <Heffalump> riastradh: yeah.
08:22:58 <Heffalump> anyone know if comonads actually are arrows?
08:23:29 <Riastradh> Probably -- they probably have to support 'a b (a b c,c)' or something.
08:23:41 <Riastradh> Er, no, not quite that.
08:24:03 <kosmikus> I'd be very surprised if they would not be, because co-arrows are arrows again (quite trivially), and monads are arrows ...
08:24:22 <Heffalump> what's the co-arrow <=> arrow isomorphism?
08:24:34 <Heffalump> in fact, what is a co-arrow? :-)
08:25:42 * Riastradh wishes John Hughes were a frequenter of this channel.
08:25:46 <kosmikus> I'd expect that if a b c is an arrow, that a c b is the corresponding co-arrow. But I may be wrong, because, after all, Haskell arrows are not exactly the same as CT arrows
08:25:46 <shapr> so do I
08:27:11 <dark> Nah, he'd get distracted chatting with us instead of doing useful things :)
08:27:20 <shapr> possibly
08:27:52 <Heffalump> they're not really anything like CT arrows, are they?
08:29:29 <Riastradh> CT arrows?
08:29:34 <Riastradh> Oh, category theory arrows.
08:29:47 <Riastradh> Argh, there are too many kinds of arrows -- Haskell arrows, category theory arrows, water's arrows...
08:29:55 <kosmikus> I'd still expect that there is a category where Haskell arrows are arrows. But my understanding of Haskell arrows is not deep enough. Didn't Ross say something about this in his FOP article?
08:29:55 <Riastradh> ..._real_ arrows...
08:30:18 <Riastradh> ...arrows that point to things, arrows that you shoot...
08:31:00 <Riastradh> Can't we come up with a _new_ name?
08:31:00 <dark> Not to forget Iraq's Yellow Arrows of Mass Destruction.
08:32:30 <shapr> huh?
08:32:59 <shapr> Riastradh: John Q. Programmer is scared of the name Monad, those that have heard the word at least
08:33:06 <shapr> so I think Arrow was a good choice
08:33:40 <Heffalump> having read the section of Ross's FOP chapter, it's not at all clear to me how anything other than (->) could be an instance of Category and still make sense as a category.
08:34:03 <shapr> I should order FoP, and H98 Report too
08:35:23 <Riastradh> FoP?
08:35:36 <shapr> Fun of Programming
08:35:37 <shapr> @fact fop
08:35:40 <lambdabot> Nothing
08:35:45 <shapr> @fact fop Fun of Programming
08:35:46 <lambdabot> set fop to Fun of Programming
08:35:59 <Riastradh> No, fop is Oscar Wilde!
08:36:07 <Riastradh> I doubt FoP is very foppish.
08:36:07 <Heffalump> I'd tell you the webpage, but I haven't finished writing it yet ;-)
08:36:35 <Heffalump> http://www.palgrave.com/catalogue/catalogue.asp?Title_Id=0333992857 is where the book is.
08:37:17 <shapr> re Arnia
08:41:43 <shapr> Arnia: I want pHlone :-)
08:44:50 <shapr> re hal
08:45:32 <hdaume> :)
08:45:38 <hdaume> stupid windows updates
08:46:20 * Riastradh hugs his Macs.
08:47:02 * shapr hugs Debian
08:47:09 <shapr> Riastradh: do you use fink?
08:47:23 <Riastradh> I used to, but I haven't needed it for anything lately.
09:24:04 <Igloo> SyntaxPolice: The HE repo is now listed on the GHC download page
09:29:42 <SyntaxPolice> Igloo: sweet!
09:30:24 * Igloo gets around to looking at my diffs with and without threaded-rts and finds that all the object files are differing because they have the temp filenames in them. Bah.
09:30:43 <shapr> huh?
09:30:50 <SyntaxPolice> Igloo: your name is linked to an email address which has a typo
09:31:06 <Igloo> I know - SM has commited a fix but apparently hasn't checked it out yet
09:31:20 <shapr> Igloo: you timed threaded-rts and not on an SMP box?
09:31:50 <Igloo> shapr: I built it with and without threaded rts hoping that diff -uR would tell me which files had changed, but it's picking up millions of files because of things like
09:31:54 <Igloo> -0000b390  06 00 00 00 12 00 01 00  00 67 68 63 32 33 33 37  |.........ghc2337|
09:31:54 <Igloo> -0000b3a0  33 2e 68 63 00 5f 6d 6f  64 75 6c 65 5f 72 65 67  |3.hc._module_reg|
09:31:54 <Igloo> +0000b390  06 00 00 00 12 00 01 00  00 67 68 63 32 33 35 33  |.........ghc2353|
09:31:54 <Igloo> +0000b3a0  38 2e 68 63 00 5f 6d 6f  64 75 6c 65 5f 72 65 67  |8.hc._module_reg|
09:31:58 <shapr> ah, I see
09:32:45 <Igloo> I'l mail the list in a sec - I'm hoping I just need to rebuild ghc (and maybe ghci) itself
09:33:13 * shapr cackles evilly
09:33:15 <Igloo> Oh, I should ask about making it a +RTS flag too if it isn't already
09:33:19 <shapr> Debian will be *THE* Haskell distro
09:34:33 <kosmikus> well, I plan to make Gentoo *the* Haskell distro, too, but not today ;)
09:34:45 <Riastradh> What if I don't want to use Linux?
09:34:57 <tic> then use BeOS
09:35:00 <Igloo> Oh, neat, I spotted a commit that looked like it might be to fix cross-porting from SM and he's just updated cross-port itself
09:35:17 <Riastradh> tic, I would, but it was cancelled many years ago, and Apple decided to buy NeXT instead of Be.
09:35:24 * Igloo laughs at kosmikus, Riastradh and tic and with shapr  :-)
09:35:37 <tic> hmm
09:35:47 <tic> it seems this IRC client wasn't cancelled at least.
09:35:50 <Igloo> Anyway, Debian isn't Linux only (honest!)
09:35:53 <tic> gosh, I'm lucky :P
09:35:55 <shapr> that's true
09:35:58 <shapr> Debian is also HURD
09:36:00 * SyntaxPolice does the debian dance
09:36:02 <tic> Igloo, sure, you can use Debian Solaris.  :)
09:36:03 <Igloo> Although that said not even hugs builds on HURD yet
09:36:08 <shapr> is there Debian Darwin?
09:36:16 <tic> there's apt for OS X
09:36:24 <shapr> yah, I've heard of fink
09:36:28 <Igloo> There's also BSD stuff being done, but I'm not sure what stage it's at
09:36:43 <Igloo> Are you a C coder, Syn?
09:37:56 <SyntaxPolice> Igloo: I can program in C, I'm more of a C++ guy, though.
09:38:06 * Riastradh bazooka barfs at SyntaxPolice.
09:38:19 <Igloo> Ah, so it's reasonable to harass you about the MAXPATHLEN stuff then  :-P
09:38:22 * Igloo gd&r
09:38:43 <shapr> what's GD&R?
09:38:58 <Igloo> grins, ducks and runs
09:38:59 <SyntaxPolice> Igloo: um. yes, probably what are you talking about? :)
09:39:19 <Igloo> I'm *sure* we've talked about it before - hang on a tick
09:39:44 <SyntaxPolice> is it the hugs doesn't build on hurd problem?
09:39:47 <Igloo> Yup
09:40:20 <SyntaxPolice> for some reason, ross doesn't want to fix it but I guess I could just do it.
09:40:25 <SyntaxPolice> well
09:40:35 <SyntaxPolice> he wants to fix it, but he doesn't want the bandaid thats in the debian BTS
09:40:39 <Igloo> He seemed to think it was complex, but looking back I can't think why
09:41:24 <Heffalump> SyntaxPolice: btw, what is the purpose of the "experimental" part of haskell-experimental?
09:41:25 <SyntaxPolice> its kinda sad that bill said "great, I'll patch it!" two years ago
09:41:29 <Igloo> Unless I am missing something you can replace char foo[n] in a function by mallocing it at the start of the function and freeing it at the end. And if it's global you just malloc it at startup
09:41:33 <SyntaxPolice> Heffalump: umm. ask Igloo ;)
09:41:55 <SyntaxPolice> Heffalump: probably no purpose
09:41:59 * Igloo splutters - it's your repo!  :-)
09:42:00 <dark> Igloo: Remember that "at the end" is anytime you return, which can be anywhere in the function :)
09:42:13 <SyntaxPolice> Igloo: yeah, I'll look at it sometime, but probably not beofre ICFP :)
09:42:27 <Igloo> I'd use it for new versions of packages which exist in stable/unstable/testing in either Debian or HE which you think are likely to break horribly
09:42:57 <SyntaxPolice> I'm inclined to take Igloo's advice about the repository since its mostly his packages in there, and I don' thjave any better ideas.
09:43:00 <Igloo> dark: Hmmm, true, but doing a hacky correct solution shouldn't be hard
09:43:08 <Igloo> That comes awfully close to an oxymoron
09:43:14 <Igloo> lol
09:43:32 * SyntaxPolice hopes Igloo doesn't mean "I" oxymorons with "better ideas" ;)
09:43:45 <Igloo> No, hacky and correct
09:43:48 <SyntaxPolice> heehe
09:44:04 <SyntaxPolice> you can put a patch in the BTS if you want, but I'll look at this Real Soon Now.
09:44:05 <Igloo> It's correct in the sense that putting an artificial limit on is Wrong, but still hacky
09:44:07 <SyntaxPolice> but I'm off to lunch. ttyl
09:44:25 <SyntaxPolice> upstream will probably fix it
09:44:32 <SyntaxPolice> I'll ask 'em about it again.
09:46:03 <Igloo> I might have a look in the next few days to see if it's trickier than I think it should be for some reason, so I'd suggest holding off till then
09:49:17 <Igloo> shapr: Presumably a Haskell program can't know if it's using a threaded-rts, so I can't write a test program for it?
09:50:20 <shapr> I don't see how you could know.
09:50:29 <shapr> but I haven't checked GHC docs for that
09:50:30 * shapr looks
09:50:39 <Heffalump> what does threaded-rts do?
09:51:13 <shapr> it allows GHC to use OS threads for Concurrent stuff
09:51:29 <shapr> basically, I could use both CPUs for a single Haskell program
09:51:31 <Heffalump> oh, right, yes
09:51:51 <Heffalump> isn't it mainly for having a thread to block on things?
09:52:02 <Heffalump> or does it actually lead to parallel computation?
09:52:25 <shapr> afaik, it's for actual parallel computation
09:53:16 <Heffalump> got a URL/
09:53:16 <shapr> the only concurrent but not parallel specific RTS option is -C <microseconds>
09:53:20 <Heffalump> s#/#?#
09:53:50 <shapr> Heffalump: look in Control.Concurrent
09:53:55 <Heffalump> in GHC6?
09:54:05 <Heffalump> i.e. in the release version?
09:54:21 <shapr> I think so
09:54:32 <shapr> Concurrent has been around for a long time
09:54:44 <shapr> it seems closely related to the PVM parallel support
09:56:02 <shapr> section 4.19.16 has -smp 
09:56:10 <shapr> as an RTS option
09:56:11 <shapr> hm
09:56:13 <Heffalump> that doesn't mention anything about OS threads (the Control.Concurrent docs)
09:56:32 <shapr> well, the GHC docs said that's the place to look
09:56:38 * shapr googles
09:57:10 <shapr> hm, interesting: http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm/rts-libs/multi-thread.html
09:59:00 <Heffalump> AFAICT Concurrent Haskell can't do parallel execution at all.
09:59:26 <Heffalump> I can't find any documentation for what -smp does.
09:59:29 <shapr> I think it can with threaded-runtime
09:59:36 <shapr> I'm 99% sure of it.
10:00:09 <shapr> though this sentence instills doubt:
10:00:09 <shapr> "Only in an SMP build will there be multiple capabilities, for the threaded RTS and other non-threaded builds, there is only one global capability, namely MainCapability."
10:00:42 <Heffalump> " Invariant: only one OS thread is allowed to execute code inside of the GHC runtime system."
10:01:16 <shapr> hrm
10:01:24 <shapr> my doubt is increasing.
10:01:34 * Heffalump pokes Igloo
10:01:40 <Heffalump> Igloo knows everything.
10:01:46 <shapr> truly
10:01:52 * shapr pokes guru Igloo 
10:02:36 * Igloo hasn't played with the concurrency stuff if that's what I'm being poked about
10:02:39 <shapr> after rereading this page, it looks like many FFI calls can be pending with threaded-runtime
10:03:03 <shapr> chilli: hellloooo
10:03:08 <shapr> I could email Chilli
10:03:14 <shapr> or ask on h@h.o
10:03:15 <Igloo> But ISTR not being convinced that what shapr said about 2 CPUs meaning it would compute twice as fast when reading the docs
10:03:26 <Heffalump> I'm fairly sure it doesn't.
10:03:31 <shapr> dang
10:03:43 <shapr> well, I'm not totally convinced it doesn't, so I'll ask
10:03:47 <Heffalump> I more want to know what threaded-rts does.
10:03:52 <shapr> actually, ghc-users is best for this probably
10:04:31 <Igloo> Hmm, some files are different sizes. That can't be good.
10:06:42 <shapr> Heffalump: what about this: http://www.dcs.gla.ac.uk/mail-www/glasgow-haskell-users/msg00796.html
10:06:59 <shapr> specifically "only a small number of OS threads can be "inside" and running Haskell threads at any one time."
10:07:59 <Heffalump> that's 4 years out of date
10:08:07 <shapr> yah, I'm looking at some 2003 mails now
10:08:16 <Heffalump> but it clearly says that they'd have to reimplement stuff to make the quantity be more than 1
10:08:24 <Heffalump> and that multithreading the GC would be major effort
10:09:47 <shapr> this seems to be the start of the whole HOpenGL discussion: http://www.mail-archive.com/ffi@haskell.org/msg01166.html
10:09:52 <shapr> or somewhere close
10:10:16 <shapr> aha
10:10:20 <shapr> http://www.mail-archive.com/ffi@haskell.org/msg01109.html
10:10:23 <shapr> that's what I wanted to find
10:12:24 * shapr reads "A semantics for foreign threads" by The Haskell FFI Team, May 6th 2003
10:32:22 <shapr> hej andersca 
10:32:31 <andersca> hej
10:47:16 <ask> hi
10:47:21 <Riastradh> Hi.
10:49:41 <ask> Hugs gives different errors when I run the same file with different extensions, for example, source.txt and source.hs
10:50:13 <Heffalump> it infers what kind of file it is from the extension
10:51:28 <ask> hey esap
10:51:40 <esap> Hi
11:02:25 <ask> I suppose if the the code has no errors both extensions will work correct, right ?
11:02:38 <Heffalump> I don't think so, no.
11:02:42 <Heffalump> I think you need .hs
11:53:57 <Riastradh> Ashley Yakeley responded!
11:54:13 <Riastradh> It's apparently quite readable, but he's doubtful that it will stay that way after a few washings.
11:54:46 <Riastradh> -- though since CafePress delivers them pre-washed, that's good enough for me!
11:56:22 <SyntaxPolice> Riastradh: so whats the deal, are you bringing some to ICFP?
11:56:24 <shapr> that's good to hear
11:57:05 <Riastradh> SyntaxPolice, I don't think I'll be able to go to the ICFP.
11:57:14 <SyntaxPolice> :(
11:57:26 <Riastradh> There's about a 5% chance that I might go.
11:57:34 <Heffalump> can SyntaxPolice bring some instead? :-)
11:58:37 <SyntaxPolice> Heffalump: I would think that is a good idea if I weren't SyntaxPolice :)
11:59:26 <shapr> hi ddarius 
11:59:37 <Heffalump> hehe :-)
12:03:07 <shapr> hi adept 
12:03:21 <adept> shapr: 
12:03:44 <shapr> bonjour emu
12:04:46 <Igloo> Heff: Are you interested in one?
12:05:02 <adept> hello ppl. I have a problem at hand which seems quite generic, I seem to have a solution for it, and just want to verify that my approach is a widely used one ...
12:06:12 <shapr> adept: what is it?
12:07:07 <Igloo> Bah, now I can't get to http://www.eecs.usma.edu/Personnel/okasaki/ from comlab either
12:07:23 <adept> ... So. I have a complex datatype (well, set of them) (definition of ASN.1 module, to be exact), and I want to perform various "map"s and "filter+map"s on instances of this datatype. As far as i understand, I should either write recursive top-down functions for each processing case, or I should invest my time into generic programmin and take a look at Strafunski. Am i right?
12:08:02 <Heffalump> igloo: yes
12:08:07 <shapr> are you using Dominic Steinitz's ASN.1 Haskell code?
12:08:22 <shapr> just idly curious :-)
12:08:56 <shapr> Igloo: works for me
12:09:04 <Igloo> Ah, it just took ages for me
12:09:35 <adept> shapr: wow, is some ASN.1-related code for Haskell available?
12:09:39 <shapr> I think so
12:09:55 <adept> shapr: I haven't found one, so wrote parser myself.
12:10:02 <shapr> yow
12:10:11 <shapr> Dominic wrote an LDAP client
12:10:13 <jlouis> ah, the do-it-yourself style. Always a fun way :)
12:11:45 <adept> hmmm... go to google, search for "Haskell AND (LDAP OR ASN.1)". First one to get some code usable for generic ASN.1 parsing/processing, gets a free beer from me ;)
12:12:26 <shapr> well, locate finds some
12:12:32 <shapr> I dunno about generic
12:13:37 <adept> shapr: whats "locate" ?
12:13:59 <shapr> it's a standard unix utility :-)
12:14:20 <adept> shapr: is that code available? ;)
12:14:26 <shapr> I assume you're Dmitry Astapov?
12:14:59 <shapr> at least, someone with "adept" in their email address was asking for ASN.1 code on the haskell mailing list
12:15:00 <adept> shapr: yep
12:15:15 <adept> shapr: yep, almost two years ago :)
12:15:25 <shapr> right, you got a response from Dominic Steinitz
12:15:41 <shapr> I got this code from him, but he's done much more work on it since then
12:16:01 * adept beats himself with cluestick ...
12:16:17 <adept> shapr: of course I remember! 
12:17:14 <shapr> I don't know if I'm allowed to redistribute this code...
12:17:15 <adept> shapr: well, in the form I got it from him that time, code hase BER encoder/decoder and primitives for constructing BER-encode/decode-able datatypes from scratch. No parser, but pre-made module for LDAP
12:17:22 <shapr> right
12:17:40 <jlouis> come....on...box.... compile..... you laze dog!
12:17:47 <jlouis> (Having fun with MLton ;)
12:17:58 <Heffalump> :-)
12:18:01 <jlouis> it even outputs lazy the wrong way, hehe
12:18:28 <Igloo> ?
12:18:29 <jlouis> when you miss seperate compilation, you will get your RAM eaten pretty fast when compiling a 100k line app
12:18:44 <adept> shapr: I have Siemens MSC (mobile switching centre) whose call data records are ber-encoded and described with 1500+ lines of ASN.1 layout. I want to parse it, produce datatypes from it, and the encode/decode/process records
12:18:55 * Heffalump debugs with Moscow ML
12:19:04 <jlouis> Heffalump: understandable, me too :)
12:19:27 <shapr> adept: yow, scary
12:20:34 <shapr> there's nothing like HaXML to turn ASN.1 spec into datatypes
12:20:41 <shapr> would be nice though
12:20:57 <xkb> Could someone give an estimation of the costs of going to ICFP?
12:21:19 <shapr> xkb: do you live nearby?
12:21:28 <xkb> oh.. forgot that: Im dutch
12:21:35 <xkb> so.. not really nearby
12:21:36 <adept> shapr: well, now my code parses the whole thing (i took parses from Sablotron and reworked for Parsec) and I get a huge load of data structures. I want to pick one (topmost) and produce datatype def from it... Aha! HaXML! It uses drift as a Strafunski do, right?
12:21:49 <Heffalump> xkb: are you a student?
12:21:53 <xkb> yeah
12:22:05 <Heffalump> Igloo can probably provide a reasonable estimate in UKP, then.
12:22:08 <shapr> I don't know how HaXML works
12:22:09 <Heffalump> since he had to make a budget
12:22:18 <Heffalump> and it's probably about equivalent flight costs
12:22:23 <Igloo> I think about 900UKP for me
12:22:39 <xkb> hmmm.. are you flying from heathrow?
12:22:45 <xkb> or however you spell that :)
12:22:45 <Heffalump> yeah.
12:22:51 <shapr> but you could make a quick and cheesy solution by going the way of HXmlToolkit, meaning you would create just the basic ASN.1 types
12:22:52 <SyntaxPolice> hmm. where did adept get the cluestick to beat himself with?
12:22:55 <Heffalump> flights costing about £150
12:23:03 <shapr> SyntaxPolice: I think lambdabot has been holding on to it
12:23:15 <SyntaxPolice> ahh
12:23:19 <xkb> hmm.. I dont think I can get that kind of money from my sponsors :(
12:23:29 <xkb> perhaps I should phone my parents :P
12:23:32 <shapr> :-)
12:23:51 <xkb> I do have some family in sweden
12:23:51 <Heffalump> the biggest cost is hotel, I think, where you could potentially also make the biggest saving
12:24:11 <xkb> Hmm is Uppsala near stockholm?
12:24:15 <shapr> yes, it's close
12:24:21 <adept> SyntaxPolice: I always have one available when I'm into something new ;)
12:24:22 <shapr> 40mins by bus, I think.
12:24:28 <xkb> hmm.. perhaps I could stay there..
12:24:40 <Heffalump> the international airport for Stockholm is apparently closer to Uppsala than Stockholm
12:24:43 <Igloo> Hmm, I don't think we actually know how much the hotel is costing yet
12:24:50 <SyntaxPolice> adept: :)
12:24:56 <Heffalump> igloo: we got Hotel Uppsala, didn't I send you that email?
12:25:02 <shapr> Igloo: double room for Hotel Uppsala is 930 SEK, single is 500 SEK I think
12:25:06 * shapr checks
12:25:09 <Heffalump> 500? no.
12:25:13 <Heffalump> 800ish IIRC.
12:25:14 <Igloo> Yeah, but I don't know how many UKP it will cost
12:25:14 <shapr> no, 825
12:25:26 <Heffalump> can't you work xe.net for yourself? :-)
12:25:39 <adept> SyntaxPolice: at work, we actually have large inflatable hammer toy which is almost 1.5m tall :)
12:25:54 <Igloo> Yes, but the fees etc will be reasonable with that large a payment won't they?
12:25:59 <shapr> I have a double room with a programming enforcer
12:26:27 <xkb> hmm Im off phoneing and calculating
12:26:46 <SyntaxPolice> adept: what do you use that for?
12:26:59 <Igloo> shapr: You and bea?
12:27:01 <shapr> expressing frustration?
12:27:10 <adept> SyntaxPolice: as a cluebat, of course :)
12:27:10 <shapr> Igloo: nah, someone from this channel
12:27:17 * shapr pretends to be mysterious
12:27:18 <Igloo> Ah, right
12:27:53 <Heffalump> igloo: yes, so what's the problem?
12:28:34 <Igloo> Oh, does xe.net take that into account then?
12:28:57 * Igloo thought it varied depending on the bank/postoffice/whatever you used so didn't think that was possible
12:29:13 <Heffalump> no, it uses midpoints
12:29:25 <Heffalump> but as you said above, the fees will be reasonable
12:29:39 <Heffalump> OIC, you meant "sizable".
12:29:40 <Igloo> Oh, by reasonable I meant reasonably large
12:29:45 <Heffalump> they'll be a reasonably small percentage.
12:30:00 <adept> shapr: google does not know about HXmlToolkit :( can you give more details pleeeese? ;)
12:30:03 <Igloo> I guess 1% is only a few quid
12:30:25 <shapr> @fact hxmltoolbox
12:30:26 <lambdabot> Nothing
12:30:28 <shapr> @fact hxmltoolkit
12:30:28 <lambdabot> Nothing
12:30:29 <shapr> hrm
12:30:45 <shapr> @fact hxmltoolbox http://www.fh-wedel.de/~si/HXmlToolbox/
12:30:46 <lambdabot> set hxmltoolbox to http://www.fh-wedel.de/~si/HXmlToolbox/
12:31:13 <shapr> adept: the only reason I mention HXmlToolbox is that it does not map to complex types, but instead to node and tree types
12:32:03 <shapr> the HaXML approach to ASN.1 would create a separate type for every name in the ASN.1 spec
12:32:28 <Igloo> That's 150 + 316 + 170 + food+buses then I think
12:32:43 <shapr> the HXmlToolkit approach would parse the ASN.1 into nested types of OID, ANY, OCTET (I've forgotten all the types)
12:32:51 <Igloo> Which should be quite a bit under 900, actually
12:34:15 <adept> shapr: well... it could be a way to produce a quick hack, but besides datatypes I want to get encode/decode functions, and I want all of them (datatype, encoder, decoder) to check constraints specified in ASN.1 spec. So I guess that HaXML is a way to go ... (hmm.. I'm reading "Scrap your boilerplate" now and generic data type traversals look exactly like thing I want ;)
12:34:58 <shapr> on the other hand, I found it much easier to work with HXmlToolbox since its validation step is completely separate
12:36:28 <shapr> I can see the advantages of enforced constraints, especially in ASN.1
12:37:09 <adept> ...especially when buggy HW emits 6 timestamps in one record, f.e. ;)
12:37:29 <shapr> Igloo, Heffalump: I've been thinking that QuickCheck needs some way to specify 'anti-cases'
12:37:34 <dark> As long as it's not 6 different ones...
12:37:57 <shapr> part of unit testing is to check that failing input doesn't explode the whole program
12:38:11 <adept> dark: in fact, they are different. what's worse - spec allows to have up to 3 of them ;)
12:38:48 <shapr> any thoughts on anticases?
12:47:53 <Igloo> Isn't that just forAll generator_bad_input $ \in -> f in == Nothing?
12:49:06 <shapr> hm
12:51:12 <shapr> Igloo: when you put it that way...
12:51:16 <shapr> it's so much simpler.
13:00:37 <Heffalump> by anti-cases you mean specific exclusions for known failures?
13:05:32 <shapr> no, I was thinking of using the same generator to test for valid and invalid inputs
13:07:44 <shapr> any recommendations for a simple dns server in debian?
13:08:37 <phubuh> some people i know love djbdns, but it's written by djb :-/
13:08:43 <Riastradh> djb?
13:08:59 <shapr> d bernstein?
13:09:00 <phubuh> something something bernstein, http://cr.yp.to/
13:09:03 <phubuh> yup
13:09:32 * Heffalump thinks BIND is quite simple.
13:09:39 <Heffalump> what do you actually need to do?
13:09:39 <phubuh> actually, i don't know if it's in debian, since it's not very free
13:09:56 <shapr> Heffalump: just want to admin my own domain
13:10:14 <phubuh> debian does have djbdns-installer - Source only package for building djbdns
13:10:16 <Heffalump> phubuh: seems like there's source only pacakges
13:10:31 <Heffalump> shapr: BIND is pretty easy to setup, IMO.
13:10:43 <phubuh> yeah
13:10:44 <shapr> and get my dynamic DSL ip to reverse resolve to a ScannedInAvian address also
13:10:46 <shapr> ok, I'll try it.
13:10:58 <shapr> it's been five years since I used it...
13:11:13 <Heffalump> errm, you can't control reverse resolution
13:11:22 <Heffalump> unless you own the IP space, which is highly unlikely...
13:11:23 <shapr> oh
13:11:26 <shapr> oh well
13:11:36 <phubuh> one thing i hate about bind is that i can't make phubuh.org a cname to my dyndns account :-/
13:12:04 <Heffalump> what limitation prevents you?
13:12:08 <shapr> hello again hal
13:12:19 <hdaume> network is being very flakey today
13:12:30 <shapr> the particles are colliding.
13:12:57 <phubuh> i can cname, say, www.phubuh.org, but not phubuh.org
13:13:23 <Heffalump> phubuh: why does BIND not let you?
13:13:34 * Heffalump can sort of imagine why, given that phubuh.org needs to have NS records too
13:13:46 <Heffalump> and a CNAME is a sort of global alias
13:13:53 <Heffalump> shapr: they do that a lot at M$
13:14:41 <Heffalump> well, the sexchange servers do, anyway.
13:14:48 <phubuh> i'm totally clueless when it comes to dns, and i have to fix my configuration file before trying the cname again to get the exact error
13:14:58 <phubuh> phubuh.org.        IN MX 10 phubuh-igloo.ath.cx.
13:15:04 <phubuh> nslint: name referenced without other records: phubuh-igloo.ath.cx.
13:15:58 <Heffalump> that's a warning about lack of glue, I think.
13:16:05 <Heffalump> does nslint claim it's an error?
13:16:43 <phubuh> well, granitecanyon's web interface won't let me get past it
13:17:58 <Heffalump> our setup gives lots of nslint warnings like that
13:18:25 <Heffalump> ask granitecanyon if they can relax that warning
13:25:31 <earthy> the problem is mostly that one *can*not* have multiple records for a name that has a CNAME record
13:26:07 <earthy> that *name* is taken to be synonymous to another name in the DNS
13:47:48 <Heffalump> GRRRRRRRRRRRRRRRRRRR!
13:48:37 <o3_> grr?
13:49:03 <Heffalump> why does instance MonadError IOError IO exist?
13:49:12 <Heffalump> when it could so easily be instance MonadError Exception IO
13:49:31 <hdaume> Heffalump: i don't know.
13:51:05 <Heffalump> and I can't even hide the bloody thing :-)
13:52:29 <hdaume> :)
13:52:53 <Marvin--> I've been wondering about that... you can hide classes, but how *do* you hide instances? :-/
13:52:59 <Heffalump> you can't.
13:53:03 <Heffalump> that's the problem
13:53:27 <Heffalump> it kind of makes sense, all hell could break loose if you could
13:55:56 <Marvin--> I guess
13:57:38 <o3_> hmm.  anybody here who are going to ICFP/PLI and want to take me clubbing in uppsala? :)
13:58:05 <Heffalump> can't you take yourself clubbing? :-)
13:58:20 <o3_> sure, but tis always more fun with other people
13:58:27 * Heffalump doesn't like clubbing, sorry
13:59:57 * Marvin-- doesn't like clubbing either
14:00:00 <Marvin--> pubbing is fine though :)
14:00:04 <Heffalump> yeah.
14:00:10 <Heffalump> isn't alcohol really expensive, though?
14:00:23 <Marvin--> well...yes
14:00:44 <Marvin--> we kinda get used to it though :)
14:00:50 * Marvin-- is still signing keys
14:00:56 <jlouis> I am clubbing... ahem Juggling with clubs
14:01:04 <jlouis> not in uppsala though :(
14:01:16 <Marvin--> oh..my..god.. now that's a young Nicholas Cage...scary
14:01:25 <Igloo> How much is a pint of lemonade?
14:01:37 * Marvin-- happened to flip over to "Fast Times at Ridgemont High" on TV *shudder*
14:01:39 <earthy> igloo: depends. british or american pint? :)
14:02:08 <Marvin--> Igloo: I don't know, I don't drink lemonade :)
14:02:10 <Heffalump> how much is a pint of beer?
14:02:14 <Igloo> I almost added a "(or whatever you have over there" to it  :-)
14:02:16 <earthy> (roughly half a litre either way, but americans get the lousy deal: 0.48 litres whereas brits get the better deal at about 0.6 litres)
14:02:29 <earthy> (b'sides: GNU units is your *friend*)
14:03:35 <Marvin--> a pint of beer at my favourite pub here in GÃ¶teborg (which is admittedly a bit expensive) is 50 SEK, which is about 5 euros
14:03:52 <Heffalump> oh, that's ok.
14:03:59 <Heffalump> 50% more than the UK, maybe.
14:04:07 <Heffalump> I don't drink much anyway :-)
14:04:26 <earthy> marvin--: which size pint? american or british? :)
14:05:04 <Marvin--> I'd guess British since it's supposedly an Irish pub :)
14:05:08 <Heffalump> lol
14:05:11 <Igloo> Swedish, duh  :-)
14:05:21 * Heffalump has drunk at an Irish pub in Tokyo, that was weird.
14:05:24 * earthy grins
14:06:07 <Marvin--> they serve lager in 50cl and ale in pints
14:06:39 <earthy> marvin--: and you wouldn't be able to tell if you get more ale than lager? :)
14:07:01 <Marvin--> earthy: after three pints of ale when I start working my way through the lagers? Get real :)
14:07:36 <earthy> I don't know your intake limits. ;)
14:08:22 <Marvin--> I get a bit tipsy after three pints, at least to the point where I don't care about whether the pints are American or British ;)
14:08:58 <earthy> ah, you don't care about 10% difference in what your money buys you? :)
14:09:11 <earthy> in that case, I have a very good offer for you... :)
14:09:26 <earthy> special price, for a special friend. :)
14:10:05 <Marvin--> heh
14:10:43 <Marvin--> spezial prize for joo
14:17:02 <o3_> ok, 7:15am, time to sleep
14:17:04 <o3_> night all!
14:17:35 <Marvin--> stop using those crazy 12 hour times, sheesh :)
14:17:58 <earthy> hmmm. yeah, that'll be in 8 hours.
14:18:09 <earthy> good time to go to bed, as that is when I want to get up. ;)
14:18:30 <Marvin--> I'm thinking the same thing
14:18:38 <Marvin--> bleh, I still have 60+ keys to sign
14:18:46 <Heffalump> big party
14:19:12 <Marvin--> 120 people or so
14:19:49 <Marvin--> heck, this is Debian people, of course we're anal about gpg signing
14:20:38 <jlouis> hehe
14:21:49 <Marvin--> I don't think I've ever had my passport more carefully checked :)
14:22:24 <earthy> ;)
14:22:27 <earthy> g'night all
14:37:03 <dark> Marvin: At least now you know it's your real password :)
14:37:08 <dark> Er, passport.
14:37:20 <dark> Sorry... I'm writing login code right now :)
14:38:34 <Heffalump> hmm, just as I start building one myself...
14:40:12 <Igloo> HA distributed lambdabots?  :-)
14:40:14 <Marvin--> dark: heh
14:41:04 <Marvin--> well, I'm off to bed
14:45:18 <phubuh> i'm doing the exercises from chalmer's university to teach myself haskell. one of the problems is this: assume a function sales :: Int -> Int. write a function zeroWeeks :: Int -> Int that returns the number of weeks in 0..n for which sales returns 0
14:45:40 <phubuh> it's a very easy exercise, but my solution is so ugly
14:45:44 <phubuh> zeroWeeks n = sum $ map boolToInt $ map (== 0) $ map sales [0 .. n]
14:45:44 <phubuh>     where boolToInt False = 0
14:45:44 <phubuh>           boolToInt True  = 1
14:45:59 <Heffalump> try a list comprehension
14:46:21 <phubuh> ah, of course! list comprehensions are so awesome, but i keep forgetting they're there
14:46:36 <dark> Using filter would also make it much simpler.
14:46:51 <Heffalump> oh yes, length . filter id
14:47:08 <Heffalump> oh, no need for that either, just length.
14:49:43 <phubuh> zeroWeeks n = length (filter (== 0) (map sales [0 .. n]))
14:50:04 <dark> That's a lot better.
14:50:38 <Heffalump> and as a list comprehension?
14:50:53 <dark> Hmm... a list comprehension could be even simpler, but it wouldn't be pointless.
14:51:03 <Heffalump> :-)
14:51:16 <Heffalump> the word you're looking for is pointfree.
14:51:28 <dark> Ah, of course :-)  How silly of me.
14:52:07 <dark> I guess the current zeroWeeks is already disqualified because of the n.
14:52:42 <Heffalump> you could probably fix that by using whatever the underlying thing that does 0 .. n is
14:52:52 <dark> enumFrom or something.
14:52:55 <Heffalump> yeah
14:53:02 <phubuh> pointfree?
14:53:05 <Heffalump> enumFromTo probably
14:53:21 <Heffalump> zeroWeeks = length . filter (==0) . map sales . enumFromTo 0
14:53:31 <phubuh> zeroWeeks n = length [x | x <- [0 .. n], sales x == 0]
14:53:36 <Heffalump> phubuh: so called because there's no "point", i.e. value involved
14:53:46 <phubuh> ah, i see
14:54:08 <Riastradh> Is there no filterMap?
14:54:10 <Heffalump> igloo: did you commit that Makefile of yours?
14:54:34 <hdaume> Riastradh: there's foldr :)
14:54:35 <Igloo> No, feel free to
14:55:15 <dark> phubuh: The comprehension looks right to me, but I'm only me :)
14:55:57 <phubuh> it does work
14:56:13 <phubuh> oh, you mean it looks like the right way to do it?
14:56:42 <dark> phubuh: No, just that it looks correct.
14:56:51 <phubuh> oh, okay. that it is.
14:58:10 <dark> I don't think foldr will simplify this.  You get fewer functions in the chain, but a more complicated folding function.
14:58:21 <hdaume> dark: agreed
14:58:23 <Riastradh> zeroWeeks = length . filterMap (justIf (==0) . sales) . enumFromTo
14:58:31 <Riastradh> ...where justIf is defined as:
14:58:57 <Riastradh> justIf f x = if f x then Just x else Nothing
14:59:36 <Heffalump> I think it was nicer like it was before
14:59:41 <hdaume> filterMap is called mapMaybe, actually
14:59:47 <hdaume> (just occurred to me that this is the same thing)
15:00:21 <Riastradh> Oh, ok.
15:02:18 <Riastradh> Bah!  The one with 'filter' and 'map' is shorter.
15:04:27 <dark> You might be able to avoid introducing ifJust by using the Maybe monad :-)
15:05:14 <Riastradh> dark, how? -- you need to _make_ the Maybe in the first place, which is what justIf does.
15:08:30 <dark> zeroWeeks = length . mapMaybe (\a -> guard (sales a == 0) >> return a) . enumFromTo 0
15:08:41 <dark> I guess it's longer than just using if then else :)
15:09:05 <dark> More obscure, though!
15:09:07 <hdaume> and since mapMaybe forces it into the Maybe monad, there's really not much purpose to using the more general functiosn :)
15:09:34 <Riastradh> And you've got a lambda!
15:09:56 <phubuh> does that make it non-pointfree?
15:09:56 <dark> Yeah I was hoping those could be avoided :)  But the >> operator made it hard to leave the a off the return.
15:28:42 <phubuh> does the prelude define a sorting function that takes a predicate?
15:29:21 <esap> no, but List module does (sortBy)
15:29:31 <phubuh> thanks!
15:31:52 <hdaume> back to the mapMaybe discussion, concatMap and mapMaybe are both really the same function.  why don't we just have a joinMap function?
15:34:00 <Heffalump> shapr: lambdabot fixes checked in
15:34:49 <esap> hdaume: if you go that path, you have to generalize a lot of functions (e.g. sequence)
15:35:56 <ddarius> hdaume: as for concatMap I presuming it's more efficient then concat . map, or were you suggesting a typeclass?
15:36:20 <hdaume> ddarius: MonadPlus is sufficient
15:36:42 <ddarius> So add joinMap as a method of MonadPlus?
15:36:44 <hdaume> esap: true, but this wouldn't really work for sequence.
15:37:19 <Riastradh> joinMap f = concat . filter (==mzero) . map f
15:37:27 <Riastradh> Is that what you're talking about?
15:37:56 <hdaume> no, just join . map
15:37:59 <Riastradh> Oh.
15:38:03 <Riastradh> @prelude join
15:38:08 * Riastradh arghs.
15:38:10 <ddarius> ==mzero would be a pretty bad idea
15:38:12 <Riastradh> shapr, bring lambdabot back!
15:38:13 <hdaume> yes :)
15:38:20 <hdaume> join :: Monad m => m (m a) -> m a
15:38:23 <hdaume> erm, MonadPlus m
15:38:38 <ddarius> (>>= id)
15:38:43 <hdaume> join = foldr mplus mzero or something
15:38:59 <hdaume> but not foldr :)
15:39:34 <hdaume> oh yeah, nm :)
15:39:38 <hdaume> i guess you don't need mplus to do that
15:39:48 * hdaume is very tired...only got 5 hours of sleep last night
15:39:59 <hdaume> but still, i think joinMap instead of mapMaybe and concatMap makes sense in this case
15:40:30 <ddarius> indeed, as join is the typical function when categorists talk of monads.
15:40:38 <hdaume> yes :)
15:40:46 * esap usually uses class (Functor f) => Sequencable f where { sequenceS :: (Monad m) => f (m a) -> m (f a) }.
15:41:20 <ddarius> esap: that was the class I needed a long time back for an example.
15:43:00 <lambdabot> I am but a poor imitation of shapr's lambdabot
15:43:17 <lambdabot> But I am harder to break :-)
15:43:31 <ddarius> esap: there a sequenceS_ to?  And this as an example where Haskell's typeclasses fail, I'm pretty sure.
15:44:06 <ddarius> (not fail in a hard way, but conceptually)
15:44:13 <esap> ddarius: well I've never found use for sequence_ either, so no I don't use that....
15:44:56 <Heffalump> it's good if you have a list of IO () actions
15:44:58 <Heffalump> or similar
15:45:48 <ddarius> sequence_ with list comprehensions give you something like a for-loop pretty compactly.
15:45:56 <Heffalump> ICK!
15:46:06 <Heffalump> our first years try to do that kind of thing
15:46:15 <Heffalump> (the ones that have experience of imperative programming)
15:47:02 <jlouis> ...but...I *want* my for-loops
15:47:06 <pesco> Heffalump: You mean in cases where a for-loop really isn't the right tool?
15:47:11 <Heffalump> pesco: yeah.
15:47:20 <ddarius> Don't worry, I've only done it for some code that was -meant- to be imperative-y.
15:47:27 <Heffalump> I accept that in an IO context it's quite likely to be a reasonable idea :_0
15:47:27 <esap> Well I rarely use imperative style in Haskell anyway, so that might explain why I don't see much use for sequence_.
15:47:30 <Heffalump> s/_0/-)/
15:48:08 <pesco> I think I used sequence $ flip map [0..n] $ (\i -> do ...) once.
15:48:30 * esap doesn't consider monads to be imperative style, unless you use assignment.
15:48:46 <ddarius> It was the IO monad with mutable arrays.
15:52:06 <hdaume> pesco: you could have used mapM :)
15:52:23 <pesco> True, but I think I only found that function later.
15:52:31 <hdaume> ah
15:53:02 <pesco> And I think sequence flip map sounds nice.
15:53:23 <pesco> Not as great as recip . exp . succ . negate of course, though.
15:54:09 <pesco> Which no longer works with GHC unfortunately because succ /= (+1) for Floats.
15:54:53 <pesco> Or rather, it didn't give the effect I wanted any more, so I had to change that wonderful line. :(
16:08:58 <Heffalump> wb
16:52:54 <phubuh> what's the most elegant way to get [a x, a $ a x, ...] until the value of it is []?
16:53:07 <Heffalump> the value of what?
16:53:15 <Heffalump> is a :: [a] -> [a] ?
16:54:54 <phubuh> so if a was tail and x was [1, 2, 3, 4], i'd get [[2, 3, 4], [3, 4], [4]]
16:55:12 <Heffalump> take a look at takeWhile and iterate
16:55:25 <phubuh> thanks :-)
16:58:06 <phubuh> takeWhile (/= []) (tail $ iterate tail [1, 2, 3, 4])
16:58:17 <Heffalump> yeah
16:58:24 <phubuh> thanks again
16:58:40 <Heffalump> you might prefer not . null to /= []
16:58:54 <phubuh> ah
16:58:56 <Heffalump> if you ever change from Int/Integer to some type that doesn't support Eq, you'll need it that way
17:10:00 <phubuh> can i get the ugly x out of this? rotate x = reverse $ map edge $ takeWhile (not . null) $ iterate subTriangle x
17:12:14 <Heffalump> yes, just change the $s to .s
17:12:17 <Heffalump> and remove the xs
17:12:40 * Heffalump is not really convinced it's ugly, though :-)
17:12:46 * Riastradh is.
17:12:51 <Heffalump> there's a reason dark called it pointless style :-)
17:13:03 <Riastradh> rotate = reverse . map edge . take (not . null) . iterate subTriangle
17:13:21 <phubuh> oh, of course! *smacks himself in the forehead*
17:21:42 <Heffalump> 'lo
17:21:48 <Pseudonym> G'day.
17:21:58 <Pseudonym> Exceptions all caught now?
17:22:00 <Heffalump> you know you were saying that PING PONG is supposed to be fast path?
17:22:07 <Pseudonym> Yes.
17:22:10 <Heffalump> yep (well, all the ones I want to catch)
17:22:19 <Heffalump> is there any reason not to use ungetsChan instead of writeChan for the PONGs?
17:23:01 <Pseudonym> The fact that I have no clue what ungetsChan does might have something to do with it.
17:23:02 <Heffalump> IM unGetChan.
17:23:12 <Pseudonym> Or that
17:23:13 <Heffalump> "Put a data item back onto a channel, where it will be the next item read."
17:23:20 <Pseudonym> Interesting.
17:23:24 <Heffalump> the "back onto" bit is slightly worrying, of course
17:24:00 <Pseudonym> The only thing I can think of is that you may end up in the situation where two PINGs arrive quickly and they're responded to out of order.
17:24:10 <Pseudonym> But it'd have to be a heavily loaded client or an evil server.
17:24:18 <Heffalump> does it matter if they are?
17:24:22 <Pseudonym> I don't know.
17:24:35 * Heffalump --> test
17:24:38 <Igloo> I think you'd have been timed out in practice if that happened
17:24:54 <Heffalump> most servers only time you out when you don't respond to the second PING
17:25:01 <Pseudonym> Here's all the RFC says:
17:25:03 <Pseudonym>  Any client which receives a PING message must respond to <server1>  (server which sent the PING message out) as quickly as possible with an appropriate PONG message to indicate it is still there and alive.
17:25:04 <Igloo> Ah, OK
17:25:32 <Igloo> Testing doesn't tell you if it works in general
17:25:37 <Pseudonym> Right.
17:25:45 <Heffalump> no, but it provides a good idea of what the practical situation is
17:25:54 <Pseudonym> Because a) no server is going to send PINGs out that quickly, and b) server behaviour is undefined if that happens.
17:26:34 <Heffalump> oh, and I've noticed lambdabot tends to slow down if it was going to say lots at once, but there doesn't seem to be any explicit output queue - am I missing something?
17:26:37 <Pseudonym> I interpret "as quickly as possible" to involve a certain latitude.
17:26:59 <Pseudonym> Heffalump: I think the only output queue is the write channel.
17:27:15 <Pseudonym> It could be soemthing to do with buffering and waiting for the string to get fully evaluated.
17:27:21 <Igloo> You could have a second queue just for pongs and change the main queue to be Maybe whateveritis. Then test the pong queue for empty any time before you'd otherwise read from the main queue  :-)
17:27:24 <Pseudonym> Or might not.
17:27:32 <Heffalump> igloo: well, I was thinking of something like that
17:27:39 <Pseudonym> Igloo: Or you could stick with what we have. :-)
17:27:44 <Heffalump> but I'm not sure how to test it for empty
17:27:51 <Heffalump> oh, sorry, you can
17:27:52 <Igloo> isEmptyChan or similar, no?
17:27:57 <Heffalump> yeah.
17:27:59 <Heffalump> I missed that
17:28:15 <Pseudonym> Can you wait on multiple channels?
17:28:18 <Heffalump> Pseudonym: well, I'm a bit worried that it could start to matter as the bot gets busier.
17:28:33 <Heffalump> oh, not without polling
17:28:37 <Igloo> Anyway, I wasn't being serious - coding for something that won't happen in practise to fix behaviour that isn't defined to be wrong with a lot of added complexity seems like overengineering to me
17:28:38 <Pseudonym> I think that as the bot gets busier, the best approach is to introduce more threads.
17:28:56 <Heffalump> IM busier in terms of output to the server
17:29:03 <Heffalump> I don't quite see how more threads would help with that
17:29:19 <Pseudonym> I thought you meant in terms of computrons expended per request.
17:29:20 <Heffalump> I suppose a thread that explicitly managed flood control/output queuing would
17:29:27 <Igloo> ircWrite should probably rate limit really
17:29:34 <Pseudonym> Possibly, yes.
17:29:58 <Heffalump> anyway, my next project is to make it deal nicely with the connection going away
17:30:08 <Pseudonym> Yes, I'd appreciate that.
17:30:28 <Pseudonym> I didn't like the error message you get when you quit when I originally wrote it.
17:30:36 <Pseudonym> But it worked. :-)
17:30:41 <Heffalump> :-)
17:30:47 <Heffalump> the quick hack is always good to get started
17:30:53 <Pseudonym> Absolutely.
17:30:57 <Heffalump> and the design is nice enough that stuff like this is easy enough to add
17:31:23 <Pseudonym> I'd also appreciate it if someone would get CTCP working.
17:31:33 <Pseudonym> There's some interesting stuff you could do with CTCP.
17:32:35 <Pseudonym> At the very least, we should probably respond to CLIENTINFO requests.
17:32:35 <Heffalump> I wonder if freenode is ever going to ping that client.
17:32:44 <Pseudonym> Give it a minute.
17:32:48 <Heffalump> I did
17:32:53 <Pseudonym> Some servers only PING if there's no actual activity.
17:33:04 <Heffalump> it's been sitting there not on a channel and not doing anything since we had the conversation above
17:33:10 <Pseudonym> Ah.
17:33:13 <Igloo> Most ping as soon as you connect to detect spoofers
17:33:15 <Riastradh> Freenode hardly ever pings at all.
17:33:21 <Heffalump> I only made it join to check it was still alive
17:33:40 <Heffalump> igloo: yeah, freenode doesn't
17:33:41 <Riastradh> Its ping timeout is something like half an hour.
17:33:46 * Heffalump gives up on freenode and tries oxirc
17:34:06 <Pseudonym> If you have your own box, I suggest installing an irc daemon on it.
17:34:11 * Pseudonym found that invaluable
17:34:15 * Igloo woneders what's to stop you using the attacks that prevents then
17:34:23 <Pseudonym> They're nasty to configure, though.
17:34:25 <Igloo> OxIRC is roughly that
17:34:27 <Heffalump> I partly run an IRC network already :-)
17:34:44 <Pseudonym> There you go. :-)
17:34:56 <Pseudonym> It'd be helpful if it's one that you can safely destroy, though.
17:35:03 * Riastradh points at evdev.ath.cx for a test server you may use.
17:35:08 <Heffalump> if the server gets destroyed by my client misbehaving, I'd be worried
17:35:22 <Pseudonym> It's not so much destroying the server.
17:35:25 <Riastradh> Oh, wait, duh, you already have a server.
17:35:31 <Pseudonym> I was worried that it might start flooding or spamming.
17:35:46 <Heffalump> I wouldn't put it on an inhabited channel
17:35:47 <Igloo> That's fine if you keep it out of interesting channels
17:35:57 <Heffalump> if it randomly started spamming people with msgs, I'd be quite surprised, but I'm sure they'd forgive me
17:36:09 <Heffalump> arse, OxIRC pings don't have identity!
17:36:17 <Igloo> :-)
17:36:19 <Heffalump> well, the inital PING does, but the rest just use the server name
17:36:36 * Igloo adds OxIRC to my recently-started list of networks to spoof on  :-)
17:36:38 <Igloo> Ah, right
17:36:47 <Heffalump> igloo: spoof what on?
17:37:02 <Igloo> spoof hostname on
17:37:10 * Heffalump points out that Igloo has root on a machine that's trusted as an IRC server
17:37:27 <Igloo> Yeah, but that wouldn't be any fun
17:37:29 <Heffalump> how does the lack of identity in PINGs help you spoof hostname?
17:37:38 <Pseudonym> Haskell: Taking over the world, one IRC server at a time.
17:37:42 <Igloo> I can't remember off-hand how you deal with TCP sequence numbers, actually
17:37:52 <Heffalump> ahh, right.
17:37:59 <Heffalump> making a connection completely blind.
17:38:04 <Igloo> Yeah
17:38:43 <Igloo> Maybe you rely on them being monotonic or something, but even that can't be predictable with real IRC server volumes
17:38:53 <Igloo> Not monotonic, increasing by 1 each time
17:39:26 <Heffalump> which sequence numbers do you need to know?
17:40:08 <Igloo> I was going to say you need to ACK the packets it sends, but maybe you don't thinking about it
17:41:41 <Heffalump> oh, yes, you do
17:42:17 <Igloo> Why? Do you have to ack the syn/ack for the connectino to be established or something?
17:42:42 <Heffalump> yes
17:42:52 <Heffalump> it's not called a three-way handshake for nothing :-)
17:43:17 <Igloo> Ah, OK. Maybe OSes (used to) increase the starting sequence number of each connection by 1 or something
17:43:29 <Pseudonym> By a prime number, possibly.
17:43:40 * Igloo tries to remember which arch I was going to try to get GHC compiled on next and which Debian machine runs it
17:43:46 <Pseudonym> Or using a weak RNG, like a linear congruential one.
17:45:28 <Heffalump> are you going to bootstrap from hc?
17:45:37 <Heffalump> or cross compile?
17:45:50 <Igloo> Bootstrap from hc
17:49:19 * Igloo once again looks annoyed at db.debian.org being broken
17:52:11 <Riastradh> @fact monads
17:52:12 <lambdabot> Sorry, I don't know the command "fact", try "lambdabot: @listcommands"
17:52:18 <Riastradh> Huh?
17:52:48 <Igloo> I think ghc6-compiled LBs don't have it because there aren't database bindings
17:53:26 <Igloo> It's an imposter anyway so doesn't have the info
17:53:33 <Riastradh> Argh, it _still_ uses databases?
17:53:54 <Igloo> Errr, that seems like a sensible way to store tables of information?
17:54:01 <Heffalump> it's my lambdabot, since shapr's has gone walkies
17:54:29 <Riastradh> Igloo, um, how about on a Berkeley DB file? or on a plaintext file on the filesystem? or in a directory with a file for every term?
17:55:08 <Igloo> The first one might be a better choice, although if you want a "real" databse for anything then you may as well stick everything in it. You'd still need bindings, though.
17:55:37 <Heffalump> it's a shame that @prelude works by connecting to Tom Moertel's web page.
17:55:51 <Igloo> ?!
17:56:03 <Igloo> There's even a Haskell parser in GHC!
17:56:24 <Heffalump> it uses a dict module
17:56:35 <Igloo> Oh, right
17:56:50 <Igloo> Do you really mean web page then?
17:57:07 <Igloo> Oh, I guess an HTTP module existed and dict didn't; I can't believe it's a complex protocol, though
17:57:09 <Heffalump> no.
17:57:17 <Igloo> Ah, OK
17:57:20 <Heffalump> I meant dict server, I just didn't realise it.
18:08:20 * Igloo mutters
18:17:19 <Igloo> Hmmm, I hope bootstrapping from HCs won't require happy
18:18:39 <Igloo> Ah, no, good
18:30:01 <Leimy> wooh
18:30:15 <Riastradh> Hi.
18:30:18 <Leimy> lo
18:30:19 <Leimy> :)
18:30:38 <Leimy> I installed the ghc package... can't find ghc :)
18:30:51 <Riastradh> It's not in /usr/local/bin/ghc?
18:30:52 <Igloo> What OS/distro?
18:30:57 <Leimy> OS X
18:31:06 <Igloo> Oh, no idea then  :-)
18:31:12 <Riastradh> You'll probably want to run ghci, though.
18:31:14 <Leimy> it is indeed
18:31:16 <Leimy> just not in my path
18:31:17 <Leimy> :)
18:31:24 <Leimy> ye[
18:31:27 <Leimy> er yep
18:31:28 <Riastradh> ghci is the REPL; ghc is the compiler.
18:31:42 <Leimy> yeah... I got that far in the tutorial :)
18:32:03 * Igloo gets a whole 4 lines into configure before it complains about sparc64-unknown-linux-gnu
18:32:08 <Riastradh> OK -- I've never read hdaume's tutorial, you see, so I don't know what it talks about first or anything.
18:32:14 <Heffalump> oh, that's how far I got too
18:32:17 <Leimy> hah
18:32:18 <Leimy> ok :)
18:34:42 <Igloo> Ah, it knows about alpha*-unknown-linux. Maybe I should try that first.
18:34:58 <Heffalump> ISTR I got as far as building a binary that segfaulted.
18:35:39 * Igloo hits an alpha first time - woo!
18:35:43 <Igloo> Oh, one with more RAM would be good
18:36:07 <Igloo> Heff: What did you do - guess at what it should be and see what happens?
18:36:46 <Heffalump> I think so, yes
18:37:13 <Heffalump> I think I must have deleted my attempts due to lack of space on compsoc, sadly
18:38:14 <Riastradh> Leimy, and ask _any_ questions at all you have about Haskell -- _especially_ basic ones, as if you don't understand basic stuff, there's _no_ way you'll get further.
18:38:56 <Leimy> i see
18:39:02 <Leimy> you doubt my prowess :)
18:39:03 <Leimy> :)
18:39:26 * Igloo tries that with ia64's entry and the obvious sed
18:39:30 <Riastradh> No, not at all -- but I really hate when people ask lots of advanced questions and it becomes obvious they didn't previously ask the right basic questions.
18:39:39 <Leimy> I see :)
18:40:00 <Leimy> well... for one... I am doing what I can to not bring any baggage about other languages in when looking at Haskel
18:40:17 <Leimy> in fact... I am trying to think of things that might make good analogies
18:40:21 <Riastradh> Unless you have baggage from Scheme or ML or Erlang or some other functional language.
18:40:28 <Leimy> heh
18:40:42 <Leimy> non-destructive update is what I would call "non-mutable data"
18:40:55 <Leimy> but... haskell doesn't think about the data until the last minute it seems
18:41:01 <Leimy> it evaluates very late :)
18:41:11 <Leimy> which is great actually
18:41:30 <Riastradh> It's interesting, though at times it's _really_ annoying -- like when reading from a file.
18:41:55 <Riastradh> Suppose you open a file foo, and get its contents -- Haskell might not actually read the file until after someone has deleted it.
18:42:11 <Leimy> that's bad :)
18:42:16 <Leimy> you can't "fail early"
18:42:27 <Leimy> failing early is an important factor in a user experience
18:42:40 <Leimy> like... say you are doing a network configuration application
18:42:46 <Leimy> and the user enters a bunch of bogus data
18:42:51 * Riastradh prefers having by default be strict, and have a nice and concise syntax for laziness.
18:43:02 <phubuh> it's not that it doesn't fail early, it's that it breaks lately
18:43:06 <Leimy> if you can't evaluate that something is bogus early ... you may waste a lot of time crunchin on bad stuff
18:43:10 <Leimy> phubuh: right :)
18:43:14 <Leimy> similar idea :)
18:43:24 <Riastradh> Of course, you _can_ use strict stuff, but then you might end up with lots of exlamation marks all over your program.
18:43:35 <Leimy> so what :)
18:43:43 * Leimy waits to see what its like
18:43:50 <Heffalump> or lots of unnecessary tree walks from liberal use of deepSeq
18:44:58 <Leimy> well.. it reminds me of what a good professor once told me about C++... "you get enough rope to shoot yourself in the foot"
18:45:07 <Leimy> lots of flexibility at the price of not knowing the side effects
18:45:30 <Igloo> Presumably the file is opened so on UNIXs at least you'll still be able to read from the file unless someone truncates it
18:45:55 <Leimy> sure... on UNIX the last unlink destroys it
18:45:59 <Leimy> its like a reference count
18:46:07 <Leimy> well... *is* :)
18:49:37 <Leimy> does haskell have a cdr?
18:49:45 * Leimy sees that fst is like car somewhat
18:49:48 <Heffalump> tail
18:49:51 <Leimy> ah
18:49:52 <Heffalump> no, head is like car
18:49:57 <Igloo> fst and snd, head and tail
18:50:06 <Leimy> I see
18:50:08 <Heffalump> fst and snd are just for (static, heterogenous) two element tuples
18:50:18 <Heffalump> head and tail are for (dynamic, homogenous) lists
18:50:28 <Leimy> snd (fst ((1,'a'),"foo"))
18:50:34 <Leimy> oh... I see :)
18:59:55 <phubuh> fst *is* like car somewhat, since lists in lisp are defined as pairs
19:00:24 <phubuh> (car '(foo . bar)) == 'foo, and fst (Foo, Bar) == Foo
19:00:54 <phubuh> (car '(foo bar baz)) == 'foo, but fst [Foo, Bar, Baz] is a type error
19:00:57 <Leimy> is this legal?  "hello " ++ "world"
19:01:00 <steveh> er
19:01:01 <phubuh> yup
19:01:07 <Leimy> doesn't seem to work here
19:01:19 <phubuh> Main> "hello " ++ "world"
19:01:19 <phubuh> "hello world"
19:01:33 <Leimy> oh... nevermind
19:01:36 * Leimy can't type or read
19:02:03 <Heffalump> phubuh: ok, but Lisp is untyped, so you can do that
19:02:15 <phubuh> '(foo bar baz) is kind equivalent to (Foo, (Bar, (Baz, ())))
19:02:23 <Heffalump> and if you look at the actual structure of a Haskell list, it really is nested in the same way
19:02:41 <Heffalump> [1,2,3] = 1 : ( 2 : ( 3 : []))
19:02:51 * Pseudonym ahems
19:02:55 <Pseudonym> Lisp is _dynamically_ typed.
19:03:38 <Heffalump> ok, ok :-)
19:04:01 <Pseudonym> I don't know if it's "strongly" typed or not.  I don't think anyone knows that.
19:04:02 <Heffalump> so it gives an error at runtime rather than segfaulting
19:04:06 <Pseudonym> Right.
19:04:17 <Riastradh> 'Strong' and 'weak' typing is very vague.
19:04:47 <steveh> a strongly typed language is one in which a type error cannot go undetected by the computer
19:04:54 <Riastradh> Dynamic vs static, safe vs unsafe, and explicit vs inferred all make sense.
19:04:58 <steveh> it can be detected at compile time or at run time
19:05:13 <Riastradh> Ah, ok.
19:05:20 <steveh> technically very few languages are strongly typed
19:05:27 <steveh> since they have explicit casts
19:05:32 <Leimy> hmm
19:05:34 <Riastradh> Er.
19:05:43 <Leimy> so 5 ** 2 is 25.0 but 5 * 5 is 25
19:06:16 * Riastradh thinks it's a little better to say safe vs unsafe when referring to whether or not a type error can go uncaught.
19:06:17 <Leimy> well casts in C++ can be made to be constructors
19:06:18 <Igloo> Roughly speaking
19:06:25 <steveh> explicitly casting something to provoke a type error is a way to violate the notion of a "Strongly typed" language
19:06:26 <Pseudonym> Maybe we should invent the term "firmly typed" for a language where only casts can fail at run time.
19:06:26 <Heffalump> Leimy: yeah, there's two different operators at play
19:06:30 <Leimy> right
19:06:36 <steveh> Pseudonym: hey, not a bad idea :)
19:06:41 <Leimy> you can have operator int () :)
19:06:44 <Igloo> 5 ^ 2 is 25 too
19:06:47 <Leimy> etc
19:06:52 <Riastradh> Leimy, yeah, Haskell's numeric system needs to be changed about.
19:07:05 <Pseudonym> Riastradh: You don't say!
19:07:20 <steveh> hum
19:07:22 <Igloo> Riastradh: You don't think ** should exist?
19:07:24 <Heffalump> ** is the floating point version - Floating a => a -> a -> a (or if you prefer, Float -> Float -> Float)
19:07:34 * steveh wonders how many iterations Haskell will go through before settling down...
19:07:50 <Riastradh> Igloo, no, it's not that.
19:08:00 <Leimy> so the operation is causing it to become a new type?
19:08:07 <Leimy> why not yield the type I provided?
19:08:10 <Riastradh> It's the stuff about Num vs Mul and Div and Add and Sub and stuff, for example.
19:08:27 <Igloo> Leimy: "the type I provided"?
19:08:39 <Heffalump> Leimy: the type of the second argument you provided was Int, right?
19:08:40 * Leimy forgets the laziness
19:08:41 <Igloo> Riastradh: Ah, OK, the way you worded it I thought it followed on from that line
19:08:44 <Heffalump> what if you'd provided (-1) ?
19:09:15 <Leimy> 5 ** 5
19:09:16 <Pseudonym> steveh: How many languages have settled down?
19:09:18 <Leimy> aren't those ints?
19:09:23 <Pseudonym> Apart from dead ones.
19:09:25 <Riastradh> Leimy, try not to think about the stuff that (**) returns, what with the Floating a => stuff -- once you learn about typeclasses, _then_ think about it.
19:09:27 <Heffalump> Leimy: yes
19:09:29 <steveh> Pseudonym: I'd say C is pretty well settled down :)
19:09:35 <Riastradh> Pseudonym, CL? -- its standard hasn't changed in twenty years.
19:09:40 <steveh> CL is another
19:09:45 <Pseudonym> steveh: There's a new standard coming out RSN.  C9X.
19:09:56 <Pseudonym> steveh: Do you mean CLtL1 or 2?
19:09:58 <Leimy> hell C++0x
19:10:00 <Pseudonym> Or did you mean CLOS?
19:10:06 <Leimy> and no one has C++98 yet :)
19:10:13 <Leimy> well... I think Comeau does
19:10:26 <Leimy> C99 exists
19:10:32 <steveh> Pseudonym: Notice how C99 is 10 after C89. :)
19:10:33 <Leimy> has for a while :)
19:10:40 <Pseudonym> steveh: True!
19:10:52 <Pseudonym> steveh: The point is that not even C and CL have settled.
19:10:55 <Riastradh> How about Smalltalk? Objective-C?
19:11:10 <steveh> They are relatively settled
19:11:12 <Pseudonym> Riastradh: Are they standardised?
19:11:14 <Leimy> TCL
19:11:19 <steveh> settled != stagnant
19:11:51 <steveh> or /= I suppose on this channel ;)
19:12:10 <Riastradh> Pseudonym, Objective-C doesn't have a standard, but there's really only one implementation of it (POC doesn't count), and the language it implements hasn't changed in many, many years.
19:12:20 <Leimy> do I have to do something special to get map toUpper to work?
19:12:22 <Pseudonym> OK, one implementation doesn't count.
19:12:23 <Igloo> Bah, it wants a ghc-pkg-inplace
19:12:32 <Riastradh> Leimy, ':l Char'
19:12:33 <steveh> Riastradh: oooooh, David Stes would be PISSED. :)
19:12:35 <Riastradh> Er, no.
19:12:38 <Pseudonym> A single stagnant implementation isn't really "settling".
19:12:38 <Riastradh> :m +Char
19:12:41 <Riastradh> ...since you're using GHC.
19:12:58 <Riastradh> steveh, yeah, he's _always_ pissed, because of Apple's and Cocoa's mere existence.
19:12:59 <Leimy> Riastradh: I presume that is "load" :;
19:13:02 <Leimy> er :l
19:13:17 <Riastradh> Short for load, but don't use it -- use :m +Char
19:13:24 * Riastradh thought you were using hugs for a moment.
19:13:25 <steveh> Riastradh: Well, it serves them right for corrupting the language!
19:13:56 <Leimy> I presume that "pollutes namespaces?"
19:14:00 <Riastradh> It serves them _what_?  One idiot continually flaming on c.l.objective-c?
19:14:01 <Leimy> assuming there is some stuff
19:14:20 <steveh> Riastradh: I am being facetious :)
19:14:33 <Riastradh> Leimy, it doesn't matter, as this is just a REPL.
19:14:36 <steveh> I haven't looked on that newsgroup in 2 years
19:14:40 <Riastradh> Heh.
19:14:40 <steveh> glad to see nothing changed.
19:14:41 <steveh> :)
19:14:41 <Leimy> oh
19:14:44 <Leimy> DUH
19:15:13 <steveh> David Stes is a net.kook, no doubt
19:15:22 * Heffalump sings praises to monad transformers
19:15:35 * Riastradh shoots an arrow at Heffalump.
19:15:53 * Heffalump deflects it with a handy application
19:15:56 <Riastradh> Take that, you user of obsolete, decrepit technology called 'monads!'
19:15:57 * Leimy gets hit in the monads
19:16:18 * Leimy assumes its based on Leibniz
19:16:22 <Leimy> "Monads don't have windows"
19:16:34 * Riastradh shoots several more arrows at Heffalump, all of which support 'app' quite nicely, going right through Heffalump's application defences.
19:16:38 <Leimy> they are atomic elements that have no effect :)
19:16:47 <Leimy> but clearly exist to do something
19:16:49 <Leimy> its whacky!
19:17:00 * Heffalump turns Riastradh's arrows into monads and applies his transformers
19:17:05 <Leimy> foldr is a list reduction operation
19:17:13 * Leimy sees a parallel cluster haskell in the future
19:17:14 * Riastradh comonadifies Heffalump!
19:17:45 * Riastradh combines the power of monads and comonads into an arrow and then lets off another flaming arrow at Heffalump, piercing him through the heart!
19:17:45 <steveh> Leimy: wow, someone else who sees these guys go on about "monads" and thinks, "hey, leibniz wasn't all that great..."
19:17:52 <steveh> :)
19:18:02 <Pseudonym> Oh, no, Heffalump isn't referentially transparent!
19:18:09 <Heffalump> AM TOO!
19:18:12 * Leimy had 18 credits of Philosophy in college
19:18:17 <Pseudonym> Every time you call him, someone else appears!
19:18:26 * steveh double majored in CS and Philosophy
19:18:30 <Riastradh> Begone from this sacred, pure channel!
19:18:39 <steveh> that's only a bit more than 18 credits I think :)
19:18:42 * Leimy wants to get a philosophy degree one day
19:18:55 * Leimy might move to Arizona
19:19:06 <steveh> Leimy: eh, it's not all that. no one is pounding on my door to ask my opinion on things :)
19:19:10 <Leimy> there is a really good Philosophy department at the University of Arizona
19:19:23 <Riastradh> People are actually _in_ Arizona?
19:19:28 <Riastradh> I thought it was a bunch of sand.
19:19:36 <Leimy> steveh: Steve Martin the comedian majored in Philosophy
19:19:39 <Leimy> and he had this to say about it
19:19:40 <Riastradh> Along with some cacti and rocks.
19:19:40 * Pseudonym is sure a parallel cluster Hakell is probably banned by the Geneva Convention
19:20:10 <Riastradh> But the Haskell Workshop is in Sweden, not Switzerland, so HAH!
19:20:12 <Leimy> "In college you learn enough to pass the tests and then forget it all... in Philosophy you learn enough to pass the tests then remember just enough to fuck you up for the rest of your life"
19:20:13 <Pseudonym> Actually, steveh, I would like your opinion on something.
19:20:34 <Pseudonym> Are there any philosophers actually left?  Or do they all just write commentaries on other philosophers?
19:20:57 <Leimy> that's a good question actually :)
19:21:07 <Riastradh> The last one died several thousand years ago -- 'I drank _WHAT_!?'
19:21:14 <Leimy> if you don't mind my answering....
19:21:18 <Pseudonym> Go for it.
19:21:38 <Pseudonym> There are some philosophers left in History and Philosophy of Science, I'm pretty sure.
19:21:53 <steveh> Pseudonym: :) Well, it's not as if earlier philosophers didn't write mostly commentaries, either... many of the more original present-day philosophers have died rather recently
19:22:14 <Leimy> I would say that philosophy has taken new directions... people study the past philosphers of both Western and Eastern origins for "historical reasons".   Modern philosophy is very much alive in the process of strange areas like Quantum Physics and even areas like Biology
19:22:35 <steveh> Rorty's still kicking it, though...
19:22:42 <Leimy> if you think of it as the father of all thought and science beyond "shit happens becuase it does... or magic or religious reasons..."  
19:22:59 <Leimy> steveh: do you consider Ayn Rand to be a philosopher?
19:23:05 <steveh> And there's plenty of ... creativity ... in feminist thought...
19:23:09 <Pseudonym> Well, I see philosophy as the area of human endeavour where we try to clarify what we think we know.
19:23:24 <Pseudonym> steveh: True, and other trendy PC-like areas, like animal rights.
19:23:26 <steveh> Leimy: I suppose she is, but I don't think she was a very well-informed one.
19:23:30 <Leimy> well. the word itself means "love of knowledge"
19:23:50 <steveh> Leimy: Rand is what happens when philosophers _don't_ spend most of their time commenting on other philosophers' ideas.
19:23:51 <Leimy> so anyone who is curious about "breaking the mold" in my opinion is in that category.
19:23:52 <Pseudonym> "love of wisdom"
19:23:58 <Pseudonym> sophia == wisdom
19:24:03 <steveh> retreading old ground rather dogmatically...
19:24:06 <Pseudonym> science == knowledge
19:24:12 <Leimy> hmmm
19:24:19 * Leimy has to double check that but ok :)
19:24:21 * Pseudonym doesn't know much about philosophy, but knows his Attic Greek
19:24:36 <steveh> scientia
19:24:45 <Pseudonym> Yeah.
19:24:48 <Leimy> Thales for instance...
19:24:49 <steveh> that's a latin term ;)
19:24:54 <Leimy> he predicted an eclipse
19:24:58 <steveh> episteme would be the greek
19:25:05 <Leimy> that was considered perhaps the birthdate of western philosophy
19:25:15 <Pseudonym> I think it might actually be a borrowed term.
19:25:31 <Pseudonym> Let me check.
19:25:56 <Pseudonym> Ayn Rand, I think, had the problem that she had ideas but no method.
19:26:08 <Leimy> so it was like Existentialism :)
19:26:11 <Pseudonym> She knew a lot about what she liked, but not a lot about philosophy.
19:26:16 <Leimy> mostly art.... an expression of the human condition
19:26:22 <Riastradh> Existential types!
19:26:24 <Pseudonym> Which doesn't make her wrong, just not very rigorous.
19:26:28 <Leimy> right
19:26:32 <steveh> Pseudonym: which is why it's good to spend a lot of time with the ideas of others :)
19:26:47 <Pseudonym> Yes, definitely.
19:27:00 * Pseudonym is reminded of the Henry Baker quote about Unix
19:27:05 * Leimy had a professor in college who was very good at arguing both sides in "Philosophy of Religion"
19:27:17 <Leimy> atheistic and theistic
19:27:26 <Pseudonym> And, of course, there's fertile new ground in moral philosophy.
19:27:29 <Leimy> yet he is an ordained minister
19:27:39 <Leimy> moral philosophy is interesting
19:27:42 <Pseudonym> Leimy: That's actually not a surprise.
19:27:43 <Leimy> Ethics
19:27:58 <Leimy> Pseudonym: really?  I would have suspected he be a bible pounder
19:28:02 <Pseudonym> Being an ordained minister is not an a priori impediment to being a good academic.
19:28:03 <steveh> Pseudonym: some of it is inspired by old ideas though ... virtue ethics, moral sympathy, and the like ...
19:28:36 <Pseudonym> I used to live at a college where there were a lot of theology academics.
19:28:42 <Pseudonym> They were some of the most open-minded people I ever met.
19:28:45 <Leimy> I think in the end.. philosophy is more about the questions than the answers
19:28:59 <steveh> no one can out-academic the Jesuit order
19:29:05 <Pseudonym> So is modern theology, actually.
19:29:09 * Heffalump had a lot of fun arguing for religion with someone who's just as rabidly atheistic as I am
19:29:10 <Pseudonym> About questions rather than answers.
19:29:16 <Pseudonym> Unless you're in the bible belt, of course.
19:29:28 <steveh> Pseudonym: which is rapidly being widened....
19:29:45 <Pseudonym> I take it as a sign that christianity is finally growing up.
19:29:48 <Heffalump> yes, I hear it reached the White House 2 1/2 years ago
19:30:00 * Leimy doesn't see modern theology as being about the questions...
19:30:16 <Leimy> I think they say the questions "have no answer" and tough shit if you don't like it
19:30:35 <steveh> Leimy: oh, they have an answer. it's just faith.
19:30:48 <Leimy> which is as good as "magick" or "it just happens"
19:30:51 <steveh> depends on the theologian really
19:30:52 <Leimy> or "because" 
19:30:55 <Pseudonym> Yup, you're right.  Science is not a borrowed word.
19:31:12 <steveh> it comes from the root "to cut"
19:31:19 <steveh> a la scissors and schism
19:31:32 <Pseudonym> Maybe it's just where I am.  There's less conservatism and fundamentalism around these parts.
19:31:38 <steveh> Pseudonym: where are you?
19:31:44 <Pseudonym> Australia
19:31:47 <steveh> oh!
19:31:51 * Leimy lives in Mississippi
19:31:54 <steveh> that makes things much different
19:31:56 <Leimy> but I am from Pennsylvania
19:32:06 <Leimy> mother was Catholi
19:32:07 <Leimy> c
19:32:09 <steveh> iirc your major right-wing party is called the Liberal party
19:32:13 <Pseudonym> Australia is a very postmodern place.
19:32:13 <steveh> that's just bass ackwards
19:32:17 <Leimy> father was Lutheran... stepdad is Methodist
19:32:29 <Pseudonym> steveh: Yes.  But you've got to realise that it's not really "right-wing" as Americans understand it.
19:32:32 <Leimy> and I went fundamental pentocostal once :)
19:32:38 <Leimy> now I am mostly agnostic
19:32:42 <Pseudonym> It's further right than the "left-wing" party.
19:32:45 <steveh> at least in America, where Bush 41 got elected by saying his opponent was "the dreaded l-word, liberal"
19:32:46 <Leimy> and living with an atheist girlfriend
19:32:49 <Leimy> figure that out
19:32:56 <Pseudonym> But actually both major parties are centrist.
19:33:19 <Leimy> its best to appear that way isn't it?
19:33:26 <Leimy> yet look at Bush's policies
19:33:29 <Pseudonym> It's just that one of them listens to the trade union lobbys and the other listens to the small business lobbies.
19:33:29 <steveh> Pseudonym: of course, but it's still kind of amusing. in the united states just about every politician is running like a cockroach under a refrigerator from the word "liberal"
19:33:36 <Pseudonym> yeah.
19:33:41 <Pseudonym> Here we use the term "small-l liberal".
19:33:50 <steveh> here you've got a party naming itself liberal, and it's the more conservative one :)
19:33:51 <Leimy> tax cuts didn't help the economy at all
19:33:58 <Pseudonym> Right!
19:34:00 <Leimy> 600 bucks 
19:34:10 <Leimy> i wish they would have kept it
19:34:25 <Leimy> and kept those government programs and areas that gave people jobs
19:34:25 <Pseudonym> Uh oh.  We're onto politics now.
19:34:33 <Leimy> stupid programming languages
19:34:37 <Leimy> with their Monads
19:34:38 <Leimy> :)
19:34:38 <steveh> so about that referential transparency...
19:34:49 <steveh> Leimy: There's always Scheme.
19:34:50 * Leimy goes to try to finish reading Dune :)
19:34:55 <Leimy> steveh: HAH :)
19:34:55 * Pseudonym was about to invoke Godwin's Law just in case
19:35:05 * Leimy hasn't given up on haskell yet...
19:35:10 <Leimy> i like languages.
19:35:15 <Pseudonym> Me too.
19:35:24 <steveh> Leimy: Haskell is kind of "ivory-tower academic wankerage," to use a phrase from arstechnica's forums :)
19:35:26 <Leimy> interesting ways to express problem solutions are of ... erm.... interest?
19:35:27 <Pseudonym> My CV has about 40 odd languages on it.  I can't get enough.
19:35:30 <steveh> but it is damn expressive
19:35:48 <phubuh> steveh: ugh, that thread is so horrible.
19:35:49 <Pseudonym> steveh: I've made it my mission in life to get practical concerns drummed into the people who control Haskell.
19:35:59 * Leimy must remember the ivory-tower academic wankerage
19:36:21 <Leimy> Aspect Oriented Haskell
19:36:27 <steveh> Pseudonym: that's not a bad mission, really...
19:36:31 <Pseudonym> Yeah.
19:36:33 <Leimy> ok... that's it for me...
19:36:36 <Pseudonym> I don't mean "sell out".
19:36:37 <Leimy> goodnight
19:36:41 <Pseudonym> Night.
19:36:55 <steveh> phubuh: heh, I like how people who like FPL are vociferously defending them from people who know nothing (and hence whose opinions are irrelevant)
19:37:14 <Pseudonym> To continue a rant from yesterday...
19:37:33 <Pseudonym> OK, steveh, see what you think of this:
19:37:37 <Pseudonym> http://catb.org/~esr/writings/taoup/html/ch07s03.html#id2924091
19:37:54 <Heffalump> Pseudonym: I appear to have found myself replacing the IRC monad with one that applies just to code that doesn't expect there to be a live connection; do you think this is a bad idea?
19:38:02 <Heffalump> (since it's going to end up being quite invasive...)
19:38:27 <Pseudonym> Hmmm.
19:38:37 <Pseudonym> Where are you using this?
19:38:44 <steveh> "threads -- threat or menace?"
19:38:57 <steveh> first of all that's not a very expansive set of choices, but I guess that's the point
19:38:58 <steveh> :)
19:39:07 <Pseudonym> Right.
19:39:15 <Heffalump> well, it started when I decided to split up ircMain into an init section and a signon + mainloop section
19:39:23 * Pseudonym nods
19:39:26 <cleverdra> "concurrency -- beacon of heaven or best idea since sliced bread?"
19:39:29 <Heffalump> so that runIrc can run init once, and signon + mainloop each time it reconnects
19:40:00 <Heffalump> so I switched around the StateT and ReaderT in the IRC type so that ReaderT is on the outside
19:40:15 <Pseudonym> Heffalump: Simple solution.  Do what you want. :-)
19:40:19 <Heffalump> and then realised I wanted to run init at a point where I wouldn't have a ReaderT :-)
19:40:23 <Heffalump> ok :-)
19:40:32 <steveh> weeel
19:40:37 * Heffalump gets worried about treading on other people's toes
19:41:21 <Pseudonym> If it helps you any, they're not my toes.
19:41:31 * Pseudonym hasn't committed anything in some months
19:41:50 <Pseudonym> Actually, I don't think I've touched any code since it was checked in.
19:42:04 <Heffalump> do you know whose toes they are? polli's?
19:42:08 <steveh> personally I'd like to see more data than just two quotes in this little essay
19:42:17 <Pseudonym> Polli's or shapr's, I think.
19:42:29 <Heffalump> oh well, shapr seemed to think I should do what I wanted, within reason
19:42:39 <Pseudonym> steveh: When I read this, I see "well I've never found a use for them, so they're useless".
19:42:53 <steveh> and if the choice is between posix threads and coming up with a custom implementation of concurrency, I'll take the posix
19:42:58 <steveh> at least that has a chance of being portable
19:43:41 <steveh> and I am almost positive that threads will still provide measurable performance advantages over processes in many places where threads are used
19:44:30 <steveh> I know when I approach concurrency I start with processes in mind and see if it scales all right, if not I switch to threads
19:44:31 <Pseudonym> steveh: Yes and no.  Threads are almost always slower on uniprocessor machines.
19:44:45 <steveh> slower than processes?
19:44:59 <Pseudonym> Slower than event-driven polling loops.
19:45:06 <steveh> oh
19:45:08 <steveh> well yes
19:45:10 <cleverdra> steveh - are you somehow reading 'concurrency' as 'using OS processes'?
19:45:28 <Pseudonym> The thing that ESR doesn't get is that threads are hard for a very good reason.
19:45:31 <cleverdra> steveh - I had Erlang and Concurrent Haskell more in mind.
19:45:36 <Pseudonym> They're a solution to hard problems.
19:45:50 <Pseudonym> If the problem is largely separable, you have processes.
19:46:05 <Pseudonym> If the tasks are fine-grained and effectively sequential, you have event-driven polling.
19:46:09 <steveh> cleverdra: I saw "To add insult to injury, threading has performance costs that erode its advantages over conventional process partitioning.  While threading can get rid of some of the overhead of rapidly switching process contexts, locking shared data structures so threads won't step on each other can be just as expensive."
19:46:14 <Pseudonym> If neither of these are true, you have a hard concurrency problem.
19:46:16 <steveh> and presumed he wanted to compare them
19:46:50 <Pseudonym> The classic example is a database server.
19:46:58 <Pseudonym> You have multiple connections working on shared data.
19:47:11 <Pseudonym> Threading is almost always the most appropriate solution.
19:47:28 <Pseudonym> Oh, and the shared data is separable.
19:47:35 <Pseudonym> So the problem isn't effectively sequential.
19:47:50 <cleverdra> and on a totally different planet from where Pseudonym is shining his light, you have Erlang literature and programming methodology.  It's also interesting.
19:47:59 <Pseudonym> Right.
19:48:22 <Pseudonym> Erlang, of course, effectively gives you multiple processes.
19:48:31 <Pseudonym> But with almost no OS overhead.
19:48:59 <Pseudonym> Threads are almost always the right solution for real-time or very very fault-tolerant systems.
19:49:51 <steveh> Pseudonym: but ... that can't be! Our choices are clear: either they are threats or they are menaces
19:50:00 <Pseudonym> Right.
19:50:06 <Pseudonym> So you had the same impression I got. :-)
19:50:48 <cleverdra> url?
19:51:21 <Pseudonym> http://catb.org/~esr/writings/taoup/html/ch07s03.html#id2924091
19:52:28 <Pseudonym> Lunch.
19:54:37 <Igloo> Woo! I've finally got to the stage where something's actually being compiled
19:54:50 <Igloo> Oh, but it's broke
19:59:27 <Igloo> configure is far too slow. Maybe I should hack it to not rerun so much
20:13:15 * Igloo runs into "ghc-asm: don't know how to mangle assembly language for: sparc64-unknown-linux" and decides to resume the hunt for nice alpha machines first
20:18:41 <Heffalump> are you expecting it to be able to mangle assembly for them, then?
20:18:59 <Igloo> configure knows about them
20:19:20 <Igloo> And ghc-asm did too I think
20:19:27 <Heffalump> I'm sure I got a binary on sparc somehow, but it might have involved compiling with GHC 4
20:23:59 <Igloo> Bah! Unrecognised platform: alphaev67-unknown-linux-gnu
20:25:28 <Igloo> Ah, it's just the -gnu bit, so it'll be fine when it gets normalised
20:27:38 <Igloo> Ho humm
20:27:39 <Igloo> as    -o Control/Concurrent.o Control/Concurrent.s
20:27:39 <Igloo> Control/Concurrent.s: Assembler messages:
20:27:39 <Igloo> Control/Concurrent.s:8: Error: unknown pseudo-op: `.rdata'
20:31:13 <Heffalump> hmm, lambdabot can now recover from being disconnected
20:31:27 <Heffalump> unfortunately, it refuses to stop doing so even when told to
20:32:31 * Heffalump goes to bed instead of fixing it, since there's a conceptual issue involved
