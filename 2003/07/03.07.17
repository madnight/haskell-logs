02:37:53 * Heffalump wonders if anyone who knows Uppsala is around
02:43:15 <o3> ^Uppsala^Stockholm
02:43:57 <Heffalump> ?
02:44:36 <o3> looking for somebody who knows about stockholm :)
02:44:45 <Heffalump> ah :-) I need to know if it's feasible to get from wherever PLI is to Arlanda airport in 90 minutes.
02:45:14 <o3> <- off to basketball
02:45:16 <o3> seizures!
02:45:37 <Heffalump> seizures?
02:45:42 <Marvin--> seizures?
02:45:48 <o3> == see yas!
02:45:52 <o3> (yes, yes, it's lame :)
02:45:54 <Marvin--> er
02:45:56 <Marvin--> yes
02:46:21 <Heffalump> to it being feasible?
02:46:29 <Marvin--> no, to being lame ;)
02:46:30 <Heffalump> o3: oh dear ;-)
02:46:40 <Marvin--> I have no idea about the feasibilities
02:48:37 <Heffalump> what's the usual time in advance you need to checkin for international flights?
02:49:18 <Marvin--> couldn't tell you, since I've never ever flown :)
02:49:53 <Heffalump> ok :-)
03:05:20 <xkb> hmm.. What does Wadler mean when he says "Call by value is dual to call-by-name"
03:07:13 <Marvin--> I don't know, I didn't read the paper
03:08:22 <Heffalump> something to do with logical duality
03:16:00 <xkb> Ill look up the paper
03:16:30 <xkb> normally checkin time is about 2 hours pre-flight
03:16:32 <xkb> :D
03:16:43 <Heffalump> hmm.
03:17:14 <Heffalump> HW finishes at 6, flight takes off at 8:55
03:17:15 <xkb> however.. Its often also possible to check-in 1 hour pre-flight
03:17:38 <xkb> 2 hours is according to regulations 
03:17:49 <xkb> At least, here at schiphol it is
03:24:16 <xkb> The program of ICFTP looks nice
03:28:33 <earthy> heffalump: that's a very tight schedule. However, you're flying inside EU, that makes at a bit less aggravating
03:28:45 * earthy has done 45 minute pre-flight checkin for flights to the UK
03:29:09 <Heffalump> hmm.
03:29:23 <earthy> but that's no longer the case, due to `terrorism'
03:29:33 <earthy> but 1h30m should suffice
03:29:37 * Heffalump waits for Igloo to get up to see what he thinks
03:30:13 <Igloo> I'm up
03:30:26 <Heffalump> well, read my email then :-p
03:32:25 <Igloo> How long does it take to get to the airport in theory? And is there a HW timetable yet?
03:32:50 <xkb> Im curious, what is HW?
03:32:55 <xkb> Haskell Workshop?
03:32:56 <Heffalump> HW finishes at 6pm.
03:32:57 <Heffalump> yeah
03:33:00 <xkb> nice
03:33:10 <Heffalump> and the bus takes 30-35 mins, and leaves every 30 mins
03:33:16 <Heffalump> and looks to be 20 mins walk from where PLI is
03:39:40 <earthy> Heffalump: that sounds like in theory you're almost fucked for that 20:55 flight
03:39:59 <Heffalump> yeah, I was just coming to that conclusion
03:40:06 <Heffalump> I don't really fancy the stress of trying to make it
03:40:08 <earthy> unless you take a taxi or someone is so nice to drop you off at the airport
06:05:30 <Heffalump> happy birthday
06:05:34 <o3> re
06:05:41 <o3> ooh, happy birthday
06:15:48 <mgoetze|birthday> thanks :)
06:50:50 <shapr> good morning #haskell!
06:50:59 <phubuh_> hey shapr
06:51:16 <shapr> hi phubuh_, what's up?
06:51:18 * Marvin-- is reading Larry Wall's state of the onion speech
06:51:42 <phubuh_> not much, i just woke up myself
06:52:03 <shapr> I've gotten much better at unicycling lately
06:52:19 <SyntaxPolice> allo
06:52:24 <shapr> hy SyntaxPolice!
06:52:35 <SyntaxPolice> hihi
06:53:13 <phubuh_> unicycling is pretty awesome
06:53:14 <o3> sup shapr
06:53:40 <shapr> y0 o3 
06:54:05 <shapr> yes, unicycling is very cool
06:54:09 <phubuh_> hey syntax, i couldn't even get buddha to compile -- the makefiles didn't have proper dependencies, i think
06:54:12 <shapr> it's very zen
06:54:17 * Heffalump wonders if phubuh managed to sort out going to PLI
06:54:58 <SyntaxPolice> phubuh_: :(
06:55:55 <phubuh_> i realized it collides with school :/
06:56:39 <Heffalump> :(
06:57:27 <o3> phubuh_: can school give you an exemption?
06:59:30 <phubuh_> probably, but i wouldn't want to miss the first few days of high school, and i don't think my mother would be too happy about it either
06:59:34 <mgoetze|birthday> Marvin--: there's a new one?
07:00:44 <Marvin--> mgoetze|birthday: number 7
07:01:23 <o3> phubuh_: good point
07:01:27 <mgoetze|birthday> hm, i'll have to read that then
07:01:52 <o3> Heffalump: btw, check in usually 2 or 2h30m before flight leaves for international flights
07:01:59 <o3> (can't remember if it was you who asked :)
07:02:04 <mgoetze|birthday> bwahaha
07:02:09 <Heffalump> yes, it was
07:02:16 <Heffalump> I was hoping Swedish airports were nice about such things
07:02:22 * mgoetze|birthday usually shows up 45 minutes before the plane takes off
07:02:35 <Heffalump> I know people who do that, but I don't think I could handle the stress.
07:02:49 <o3> mgoetze|birthday: well, i'm trying to give _correct_ advice here, not what i actually do ;)
07:02:59 <mgoetze|birthday> :P
07:03:02 <Heffalump> :-)
07:03:06 <Marvin--> since I've never flown, can someone tell me why you're supposed to check in two hours before the flight leaves?
07:03:09 <shapr> it's stressful to check in early?
07:03:11 <o3> i checked in about 6 minutes before an international flight once
07:03:17 <shapr> Marvin--: because there's so much redtape
07:03:21 <Heffalump> Marvin--: because it gives them plenty of time to mess you around, then
07:03:32 <o3> it's actually quite efficient because you go through a special queue etc etc.  saves quite a lot of time ;)
07:03:36 <shapr> yah, I'll go with Heffalump on that
07:03:56 <Heffalump> they can stick you in a large queue and not have to worry about the queue getting very large
07:03:57 <shapr> I missed my first flight to europe, but could have made it on time if the chick at the front desk hadn't purposefully held me up
07:03:58 <Marvin--> redtape?
07:04:05 <Heffalump> checking in, essentially
07:04:10 <Heffalump> plus getting your baggage loaded
07:04:16 <o3> Marvin--: IMHO, just in case stuff goes wrong, really
07:04:24 <Heffalump> in theory it can all be done in 20 minutes, but not for an entire planeload of passengers
07:04:33 <shapr> also, when getting a replacement ticket, the french girl behind the counter called me several insulting things in french, assuming I didn't understand what she was saying.
07:04:36 <Heffalump> they let the business/first class passengers check in later generally, too
07:04:50 <mgoetze|birthday> shapr: lol
07:04:56 <o3> shapr: how many languages do you speak?
07:05:08 <o3> and will i be seeing you at PLI/ICFP?
07:05:13 <shapr> I'll be there, will you?
07:05:13 <Heffalump> o3: so you are coming?
07:05:17 <o3> wait, i think i've asked you that before.  nevermind :)
07:05:29 <o3> Heffalump: yeah, unless my paper is a complete piece of utter crap, i'll be there :)
07:05:38 <Heffalump> who determines whether it is or not?
07:05:41 <shapr> o3: I only speak english really, but I took french in college, I'm learning swedish, and I've learned some finnish, some dutch, some german
07:05:42 <o3> looking around at hotels in uppsala right now.  i _so_ want one with a sauna :(
07:05:49 <o3> Heffalump: Chilli, really
07:05:51 <shapr> enough to eavesdrop at least
07:05:55 <shapr> saunas rock :_)
07:06:03 <Heffalump> don't you have to register soonish?
07:06:27 * Heffalump bounces at the huuge #haskell meet.
07:06:32 <shapr> yah!
07:06:32 <o3> shapr: i was in finland in 1997, went into a sauna there, and i think that's spoiled me for the rest of my life.  no other sauna is quite the same
07:06:41 <shapr> hi d33p 
07:06:46 <shapr> yah, saunas are addictive
07:06:54 <Heffalump> o3, Igloo, shapr, Heffalump, kosmikus, who else?
07:06:55 <d33p> hey shapr.. how are you
07:06:55 <shapr> showers and baths just don't get people so clean
07:07:00 <o3> Heffalump: probably have to register soon.  i'll let chilli worry about those details ;)
07:07:08 <shapr> Smerdyakov: you going to ICFP?
07:07:21 <o3> Heffalump: +Chilli
07:07:23 <Heffalump> I think he is, but I'm not certain.
07:07:37 <Heffalump> o3: oh, cool, he's not too busy then? :-)
07:07:56 <shapr> who else is going to ICFP?
07:08:04 <o3> Heffalump: he's definitely going
07:08:05 <mgoetze|birthday> pas moi
07:08:18 <shapr> pourquoi pas?
07:08:23 <shapr> c'est tres chouette!
07:08:37 <mgoetze|birthday> je n'ai beaucoup d'argent :)
07:08:45 <shapr> ah, quelle dommage
07:09:09 <Heffalump> je ne comprend pas le mot "chouette"
07:09:19 <Heffalump> comment dit-on ca en anglais?
07:09:28 <shapr> "cool" :-)
07:09:32 <mgoetze|birthday> dit-on?
07:09:33 <Heffalump> ah :-)
07:09:37 <Heffalump> "does one say"
07:09:39 <shapr> but it's an old word, so it's more like "groovy"
07:09:47 <mgoetze|birthday> i thought dit-en
07:09:48 <shapr> or something comparable from the sixties
07:09:58 <Heffalump> don't think so
07:10:01 <shapr> nah, "dit-on" "says one"
07:10:08 <shapr> as in "How does one say this"
07:10:12 <mgoetze|birthday> ah, that on
07:10:16 <Heffalump> yeah.
07:10:19 <shapr> yup, it's really short for "one person"
07:10:34 <mgoetze|birthday> on y dit comment? comme ca :)
07:10:55 <mgoetze|birthday> ok, time to stop butchering the french language
07:10:58 <shapr> heh
07:11:02 <shapr> I'm not much good at french either
07:11:02 <mgoetze|birthday> and do some birthday-type things instead
07:11:09 <shapr> happy birthday mgoetze!
07:11:13 <shapr> how old are you?
07:11:17 <mgoetze|birthday> 20 :)
07:11:34 * Heffalump is definitely old.
07:11:44 <mgoetze|birthday> don't worry about it
07:11:50 * earthy pulls another grey hair
07:11:56 <mgoetze|birthday> i'll be old soon enough as well
07:21:14 * SyntaxPolice sips coffee
07:23:23 * earthy sticks with tea
07:24:13 * Marvin-- sticks to his t-shirt, damn it's hot
08:59:04 * esap would like everyone to comment on http://www.haskell.org/hawiki/ControlOperation.
09:02:18 <hdaume> can someone translate this form me?  "Sorry, ik was het compleet vergeten. Ik zal deze week nog wat opsturen."
09:02:53 <Marvin--> my Dutch is a bit rusty :)
09:03:01 <hdaume> not as rusty as mine :)
09:03:26 <hdaume> (i figured i'd have a better chance asking on this channel than anywhere else though :P)
09:03:37 <Heffalump> the Dutch are everywhere, but apparently not when you actually need them ;-)
09:04:49 <hdaume> apparently :)
09:06:03 <Marvin--> apparently, my Dutch friend just logged off jabber
09:08:32 * shapr boings
09:09:14 <shapr> sorry I was a complete vergeten(?) I zal(?) this week enough wat(?) opsturen(?)
09:09:34 <shapr> or maybe I was completely vergeten
09:13:00 <hdaume> too bad it wasn't swedish :)
09:13:28 <Heffalump> hdaume: you coming to ICFP, btw?
09:13:49 <shapr> aha, http://dictionaries.travlang.com/DutchEnglish/dict.cgi?query=vergeten&max=50
09:15:02 <shapr> "sorry, I completely forgot, I shall this week send it"
09:15:36 <hdaume> shapr: awesome, thanks
09:15:49 <shapr> google is worth 50 IQ points ;-)
09:15:54 <hdaume> Heffalump: nope...too expensive :)
09:16:00 <shapr> I just googled for dutch dictionary english
09:17:11 <shapr> I realize HaWiki would have use for a citeseer macro
09:17:14 <Marvin--> bbq time
09:17:24 <shapr> we just had noodles and cheese
09:17:37 <shapr> that's one of my favorite foods, now that I have access to spiffy eurocheese
09:22:29 <hdaume> ugh.  i just realized HAllInOne loops on recursive modules.  i was *positive* it wouldn't do this.  grrr....
09:22:51 <shapr> I think it's a great name :-)
09:23:01 <hdaume> :) my friend came up with it :)
09:23:47 <shapr> it's very punny... as a Haskell app, it should start with H, and since you wrote it, it should have Hal in there somewhere.
09:23:54 <hdaume> yup
09:26:36 * esap would like comments on the code at http://www.haskell.org/hawiki/ControlOperation
09:29:12 <hdaume> esap: yikes
09:29:22 <hdaume> that scares me :)
09:29:46 <esap> Hehe, it is intended to simulate something that is very hard to simulate without having it as a primitive.
09:30:03 <hdaume> i see
09:31:53 <shapr> hej andersca 
09:31:59 <andersca> hejhej
09:32:08 <shapr> hur är det med dig?
09:32:20 <andersca> bara bra
09:32:23 <andersca> jag ska fiska snart
09:32:33 <shapr> you're going fishing?
09:32:45 <andersca> ja
09:32:52 <shapr> kul
09:33:20 <shapr> min familj älskar att fiskar, bara mig är inte samma
09:39:09 <phubuh> you're so cute when you speak swedish, shapr :-)
09:39:17 <shapr> :-P
09:39:25 <andersca> I have like 3000 unread mails
09:39:32 <shapr> neat
09:42:14 <phubuh> is there a lex-like tool that generates haskell?
09:42:46 <phubuh> err, flex-like
09:43:03 <shapr> there's BNFConv
09:44:38 <hdaume> isn't there something called "ALex"?
09:45:26 <shapr> http://www.syntaxpolice.org/~ijones/alex/
09:45:29 <phubuh> ooh, haskell.org/libraries seems pretty comprehensive. i couldn't find anything on the wiki :-)
09:45:30 <phubuh> thanks!
09:45:32 <shapr> too easy
09:45:41 <shapr> :-)
09:58:01 * shapr boings cheerfully
10:10:49 <hdaume> HAllInOne is fixed (again)  :)
10:11:24 <elmex> ?
10:11:28 <elmex> whtatsthat?
10:11:32 <hdaume> (there was a bug with recursive modules)
10:11:43 <hdaume> http://www.isi.edu/~hdaume/HAllInOne
10:13:14 <elmex> ah, aehm
10:13:56 <elmex> hdaume: is that a serious thing? what is it good for? aren't multiple modules good?
10:19:11 <hdaume> elmex: ask Marvin-- :)
10:19:45 <elmex> ok
10:19:53 <hdaume> elmex: i think a lot of people want it because then when they're implementing their little research systems they only need to worry about working with one file, rather than having to do import chasing (which is really hard)
10:20:03 <hdaume> elmex: for a program i'm working on, that's why i wanted it
10:20:26 <elmex> hdaume: hm, but doesn't the structure get lost?
10:20:42 <elmex> i like modules, because they seperate concepts
10:20:50 <elmex> (or can be used to do that)
10:21:12 <hdaume> sure :)...it's probably possible to write an UnHAllInOne such that (UnHAllInOne . HAllInOne) ~= id
10:21:24 <elmex> lol
10:21:33 <elmex> in dont think so
10:21:41 <shapr> also, HAllInOne gets around stuff like split-objs
10:21:51 <hdaume> elmex: i don't think anyone would use it by itself.  i think it would usually be combined with some other program processor
10:21:52 <elmex> ?
10:22:01 <shapr> hdaume: does it only import the pieces that are directly used?
10:22:01 <elmex> hm
10:22:42 <shapr> afaiu, GHC makes an .o file for an entire module at once, so binaries will be noticeably smaller with HAllInOne
10:22:48 <hdaume> elmex: for instance, if you want to write a research compiler, usually you just want to assume you're working with one module (otherwise your compiler will be 50% file chasing)...this makes it easier
10:23:03 <hdaume> shapr: and compile 10000* more slowly
10:23:06 <hdaume> ;)
10:23:22 <elmex> hm, i would like to know more aout parsing, because i wanted to implement some small and nice script language in it
10:23:25 <hdaume> shapr: though it's possible you could get much better generated code
10:23:30 <elmex> something to toy around with
10:23:34 <shapr> yes, you usually would get better code
10:23:36 <Heffalump> hdaume: have you done any measurements of this, OOI?
10:23:50 <hdaume> Heffalump: no, but i plan to
10:23:56 <shapr> GHC does some optimizations only inside a single module
10:23:59 <hdaume> OOI = ?
10:24:04 <shapr> hdaume: have you tried it on GHC?
10:24:13 <hdaume> presumably inlining alone would buy you a lot
10:24:17 <shapr> oh, no -fglasgow-exts, nm
10:24:17 <hdaume> shapr: ahahah, no
10:24:19 * shapr grins
10:24:22 <hdaume> shapr: GHC usese -fglasgow-exts
10:24:26 * SyntaxPolice bounces around
10:24:32 * shapr boings happily
10:24:33 <shapr> SyntaxPolice: yay!
10:24:39 <hdaume> maybe nhc would be a candidate
10:24:46 <Heffalump> "out of interest"
10:24:55 <shapr> I forget which optimizations are limited to in-module
10:24:56 <hdaume> but compiling that beast as a single module would take a year and a half :)
10:25:07 <shapr> some strictness and specialization stuff, I think
10:25:20 <shapr> what, GHC? or nhc?
10:25:40 <hdaume> shapr: yeah, if you change the signature to 'module Main(main) where...', it could probably do a lot of specialization it wouldn't otherwise do
10:25:45 <hdaume> well, either, but i meant nhc
10:25:58 <hdaume> okay i'm off to a talk :)
10:26:02 <shapr> have fun
10:26:10 <shapr> I wonder...
10:26:23 <Heffalump> are M$ paying you to do this, or is it just spare time?
10:26:24 <shapr> I wonder if ghc --make is threaded
10:26:26 <hdaume> ...and it's superior to GHC because it can (supposedly) deal with mutually recursive modules without having to build stupid helper files :)
10:26:28 <hdaume> Heffalump: spare time
10:26:37 <Heffalump> pity ;-)
10:26:43 <hdaume> usually while i'm waiting for other things to run :)
10:26:54 <hdaume> okay i'm really off now....later guys
10:26:58 <shapr> cya
10:26:58 <Heffalump> bye
10:41:34 <earthy> hey, a hdaume who want to fix the URLs from http://www.isi.edu/~hdaume/htut
10:41:42 <earthy> +s
10:42:39 <earthy> (the redirection the `registration' stuff does is broken)
10:48:29 <elmex> hdaume: :)
10:49:09 <elmex> hdaume: whats Affiliation?
10:49:40 <earthy> elmex: university/research group/employer
10:49:51 <elmex> but i'm in none of that
10:49:59 <earthy> are you affiliated with one? :)
10:50:14 <elmex> hm, i don't think so
10:50:21 <earthy> then put in `none' :)
10:50:47 <earthy> I feel strongly that I will buy a new computer today
10:50:56 <elmex> 'or the server has been instructed not to let you have it. '
10:51:04 <elmex> bad server
10:51:17 <elmex> thats not a nice server
10:51:18 <Heffalump> elmex: what are you trying to do?
10:51:27 <earthy> elmex: nope, the redirect URL is broken. there should be a /htut/ between the ~hdaume and the filename
10:51:28 <elmex> Heffalump: get that tutorial
10:51:56 <earthy> (fill it in by hand and the file comes)
10:52:31 <Heffalump> http://www.isi.edu/~hdaume/htut
10:52:37 <Heffalump> /tutorial.pdf
10:52:39 <Heffalump> is the correct URL
10:52:44 <earthy> exactly
10:56:05 <Heffalump> oh, you said that, sorry.
10:56:16 * Heffalump tries to concentrate :-)
10:56:17 <elmex> k
11:27:06 <earthy> !sigh
11:27:19 <earthy> 656 euro's is basically nothing at all ;)
11:27:29 <earthy> given the amount of compute power it buys you ;)
11:44:04 <esap> Heh, how do you figure it's possible to get the error "Could not deduce (Num c) from the context () arising from the literal '1'"?
11:44:15 <hdaume> (1 :: Int)
11:44:30 <hdaume> or did i miss conversation?  :)
11:44:37 <hdaume> (btw, i fixed the htut error)
11:44:46 <esap> then I get "cannot unify the type-signature variable 'c' with the type 'Int' :-)
11:45:01 <hdaume> can you post what gives you this?
11:45:56 <esap> control (\nx -> if False then (1 :: Int) + coapp "foo" nx else coapp "bar" nx), where control :: (forall c. Nega n -> c) -> n and coapp :: n -> Nega n -> bot  [those are in a class that binds 'n']
11:46:34 <hdaume> can't you just say 'forall c . Num c => ...'
11:47:03 <esap> no, because then I can't implement it. My bottom does not have such constraints :-)
11:47:29 <hdaume> my bottom has *lots* of constraints :)
11:47:43 <hdaume> hrm.
11:47:56 <hdaume> (undefined :: Num c => c) wouldn't work?
11:47:57 * esap uses  type Nega x = (forall c. x -> c)
11:47:59 <Heffalump> bit of a tight-arse, are you? :-)
11:50:13 <esap> ok, maybe I could restrict the universal quantification, but I'd guess then I'd also have to restrict the negation operation. 
11:51:37 <esap> here are the important parts: control :: Nega (Nega String) -> String    control f = unsafePerformIO $ catch (evaluate $ f (\msg -> throw . IOException . userError $ msg)) (\ (IOException e) -> return $ ioeGetErrorString e)
11:52:00 <esap> coapp :: String -> Nega (Nega String), coapp x f = f $! x
12:03:40 * esap put that thing to http://www.haskell.org/hawiki/ControlOperation, I hope it still compiles.
12:16:02 <SyntaxPolice> so what does a rapid beeping tone mean for a swedish phone number?
12:17:16 <esap> In finland, it means the person you're calling is talking with someone else.
12:17:23 <phubuh> yeah, that's the busy tone
12:17:49 <SyntaxPolice> hm. I'm trying to call hotel uppsula, but it was busy for much of yesterday too :(
12:18:01 <SyntaxPolice> don't they have voicemail or something in sweden ;)
12:19:55 <phubuh> +46-18 495 23 11 is their fax number
12:20:19 <phubuh> you do mean "scandic hotel uppsala nord", right?
12:21:52 <phubuh> wait, scandic hotel has two hotels in uppsala, how confusing
12:25:08 <SyntaxPolice> what time is it there right now?
12:25:53 <phubuh> 21:25
12:57:29 <jlouis> hrmf, how do I get a non-monad function lifted into the monad?
12:57:59 <jlouis> foo :: String -> String should be converted to foo :: IO String -> IO String or similiar
12:59:47 <SyntaxPolice> liftM
13:00:01 <SyntaxPolice> in Control.Monad
13:00:08 <jlouis> thanks, that helped
13:00:14 <hdaume> or 'return . foo'
13:01:03 <jlouis> At least I know what I need to do :)
13:03:54 <jlouis> liftM is what I need
13:08:28 <jlouis> return . foo has wrong type :)
13:09:44 <hdaume> really?
13:10:25 <hdaume> *Foo> :t foo
13:10:25 <hdaume> foo :: String -> String
13:10:25 <hdaume> *Foo> :t return . foo
13:10:25 <hdaume> return . foo :: forall m. (Monad m) => String -> m String
13:10:25 <hdaume> *Foo> 
13:10:41 <Heffalump> (return.) == liftM, right?
13:11:53 <Heffalump> oh, no
13:12:01 <Heffalump> liftM :: (a -> b) -> (m a -> m b)
13:12:04 <hdaume> no, cuz liftM makes it m String -> m String :)
13:12:07 <hdaume> i just noticed
13:13:31 <hdaume> you want '((return . foo) >>=)'
13:13:32 <hdaume> :)
13:18:25 <SyntaxPolice> FYI from ghc's library:
13:18:26 <SyntaxPolice> liftM f m1              = do { x1 <- m1; return (f x1) }
13:18:26 <SyntaxPolice> liftM2 f m1 m2          = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
13:18:26 <SyntaxPolice> liftM3 f m1 m2 m3       = do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }
13:18:32 <SyntaxPolice> (etc :)
13:18:45 * SyntaxPolice wonders if someone used an emacs macro to do that :)
13:19:53 <hdaume> sometimes i really just wish there were liftM17
13:23:22 <Heffalump> yeah, the lack makes all our lives harder
13:23:58 <hdaume> i don't think i've ever used any of those functions for n > 2
14:11:06 <kunphuzil> Can someone suggest a simple task/program for me to try and code? 
14:12:11 <Heffalump> what kind of code do you want to write?
14:12:30 <Heffalump> really functional stuff, or stuff that uses Haskell for some real-world problem?
14:12:41 <Heffalump> (the two do sometimes overlap, of course ;-)
14:13:14 <kunphuzil> the former i guess
14:13:29 <Heffalump> how big do you want it to be?
14:13:56 <kunphuzil> relatively small i guess
14:14:05 <kunphuzil> just something to get me going
14:14:20 <Heffalump> write a function to sort a list
14:14:34 <Heffalump> if that's too easy, write one to generate all possible permutations of a list
14:15:05 <Heffalump> if that's too easy too, then do the same thing, but avoiding generating duplicate results even if the input list has duplicates
14:15:23 <kunphuzil> sorting a list into what? alphabetical order?
14:15:43 <Heffalump> write a function of type Ord a => [a] -> [a]
14:15:52 <Heffalump> where the output list is sorted with respect to the Ord instance of a
14:16:39 <kunphuzil> excuse my stupidity, but huh? :/
14:16:55 <kunphuzil> maybe an example input -> output would help
14:16:57 <Heffalump> do you know about type classes?
14:18:44 <kunphuzil> sort of
14:18:59 <jlouis> qsort (x:xs) = elements_greather_than_x ++ [x] ++ elements_less_than_x
14:19:00 <jlouis>   where
14:19:01 <jlouis> ...
14:20:31 <kunphuzil> I see
14:25:56 <kunphuzil> qsort (x:xs) = less_x ++ [x] ++ greater_x
14:25:56 <kunphuzil>    where less_x = filter (<x) xs
14:26:05 <kunphuzil>          greater_x =  filter (>=x) xs
14:26:25 <phubuh> you need some more recursion
14:26:31 <kunphuzil> that was kind of simple, but i had some help. 
14:26:32 <kunphuzil> oh
14:26:39 <kunphuzil> well, it works..
14:26:45 <hdaume> no it doesn't :)
14:26:59 <kunphuzil> Main> qsort [2,4,6,1,10]
14:26:59 <kunphuzil> [1,2,4,6,10]
14:27:01 <hdaume> qsort [5, 3,2,1, 8,7,6]
14:27:28 <jlouis> kunphuzil: you have the divide-step, you will need the conquer step too (which I forgot, hehe)
14:27:29 <phubuh> your less_x and greater_x are already sorted in that example, kunphuzil
14:28:04 <kunphuzil> Main> qsort [10,1,2,8]
14:28:06 <kunphuzil> [1,2,8,10]
14:28:22 <phubuh> still, the less_x is sorted. try hdaume's list :-)
14:28:22 <hdaume> kunphuzil: just do mine.  again those are sorted
14:29:06 <kunphuzil> i tried it and yes it doesn't work. but 1) i don't see what you mean by mine is already sorted and 2) how does recursion fix this?
14:29:35 <hdaume> when you call qsort [10,1,2,8], then 'filter (<10) [1,2,8]' is [1,2,8] and this is sorted
14:29:43 <hdaume> mine doesn't work with the code you posted
14:30:03 <hdaume> qsort [10, 2, 1] won't even work
14:30:12 <hdaume> because [2,1] isn't sorted
14:31:47 <phubuh> quicksort works by dividing the list and sorting both of the sublists
14:31:57 <phubuh> you're forgetting one of those steps :-)
14:32:49 <kunphuzil> qsort (x:xs) = qsort less ++ [x] ++ qsort greater
14:32:49 <kunphuzil>    where less = filter (<x) xs
14:32:51 <Heffalump> I was actually expecting you to write insertion sort or similar when I suggested the problem.
14:32:57 <Heffalump> but yeah, that's right
14:33:01 <kunphuzil>        greater = filter (>=x) xs
14:33:18 <Heffalump> do you have a qsort [] ?
14:33:24 <kunphuzil> i get an error when running that against hdaume's list
14:33:28 <kunphuzil> Program error: {qsort instOrd_v27 []}
14:33:34 <Heffalump> that's why you get an error :-)
14:33:38 <hdaume> you need a base case
14:33:43 <kunphuzil> hdaume: what is insertion sort? 
14:33:47 <kunphuzil> hdaume: oh ok
14:34:16 <hdaume> insertion sort basically looks like: take the first element off, sort the rest of the list, then insert that first element into the appropriate place
14:34:35 <Heffalump> you should first write insert x xs, which takes an xs that is sorted, and inserts x into it
14:34:47 <hdaume> except you shouldn't call it insert :)
14:34:52 <hdaume> my_insert would work better :)
14:34:55 <Heffalump> ok :-)
14:35:42 <kunphuzil> heh, yeah
14:35:44 <kunphuzil> ok
14:44:25 <kunphuzil> hmm
14:49:29 <phubuh> qsort is O(n^2) on linked lists; you might want to try implementing merge sort, which is O(N log N)
14:51:35 <Heffalump> "linked"?
14:51:38 <Heffalump> DYM sorted?
14:52:07 <phubuh> nope, i mean linked list as opposed to array
14:52:23 <ibid> phubuh: why would it be quadratic?
14:53:01 * Heffalump doesn't see why either
14:53:02 <ibid> partition is linear, and so is concatenation
14:53:32 <jlouis> qsort is n**2 in worst case, though n lg n in the average case
14:53:53 <ibid> jlouis: yeah, but that's independent of whether we are dealing with an array or a list
14:54:02 <jlouis> indeed
14:54:19 <phubuh> hmm, indeed. what am i thinking?!
14:54:37 <jlouis> it is also an exchange-based sort, rather hard to get effective on a linked list
14:54:56 <jlouis> ok, I need sleep, before I make more errors...
14:55:13 <ibid> jlouis: the main thing is that list qsort is not constant space
14:55:23 <ibid> jlouis: array qsort can be
14:55:48 <ibid> how is qsort exchange-based? :-)
14:56:11 <Heffalump> it should be exchange based.
14:56:23 <Heffalump> a sane imperative implementation is
14:56:41 <ibid> a sane array-based implementation is, you mean :-)
14:56:50 <Heffalump> well, yes :-0
14:56:55 <Heffalump> s/0/)/
14:57:48 <ibid> the main disadvantage of not doing it exchange-basedly is that you need O(n log n) scratch space
14:58:19 <Heffalump> well, if you don't have destructive update, you're bound to need nlog n space.
14:58:36 <ibid> not really
14:58:55 <ibid> well, yes
14:59:08 <ibid> (assuming you want to preserve time efficiency)
14:59:16 <ibid> um
14:59:30 <ibid> hm, no, actually
15:00:41 <ibid> it seems to me that any allocation beyond 2n is going to be garbage
15:00:51 <ibid> but my head hurts :-)
15:00:56 <ibid> i should, too, go to bed
15:00:59 <Heffalump> any allocation beyond n will be garbage.
15:01:12 <Heffalump> but sorting without destructive updates is bound to need it, unless I'm really confused
15:01:50 <ibid> assuming arrays, you will need at least 2n space (you cannot reclaim the first array before copying the data)
15:02:01 <hdaume> Heffalump: it's possible that the original node could be GC'd as you add it into the new place, in which case you'd need N+1 storage
15:02:11 <Heffalump> oh, sure, sorry
15:02:51 * ibid notes that the statement that qsort is O(n^2) is correct even in average ;-)
15:02:55 * ibid grins evilly
15:03:03 <ibid> (even with arrays)
15:05:05 <ibid> (we often treat O contrary to its definition.  O is upper bound only, unless my headache makes me misremember stuff:-)
15:05:27 <Heffalump> :-)
15:05:28 <hdaume> ibid: correct :)
15:05:44 <hdaume> Theta is the exact bound
15:06:13 <ibid> i dislike the term "exact" in this context :-)
15:06:27 <ibid> i'd rather think of it as "both upper and lower bound" :-)
15:06:27 <hdaume> asymptotically exact :)
15:07:24 <Heffalump> asymptotic bounds are all bollocks anyway, on any real computer any algorithm you give me is O(infinity).
15:07:40 <ibid> um, O(1)
15:07:45 <ibid> if it is an algorithm ;-)
15:07:57 <ibid> (algorithm terminates on all inputs)
15:08:18 <Heffalump> no, O(infinity), because if I ramp up n high enough you can't run it on any real computer.
15:08:52 <ibid> if you think of it that way, then no computer can implement an algorithm ;-)
15:09:08 <Heffalump> I'm just going by the precise definition of asymptotic bounds.
15:09:28 <ibid> i'm just going by the traditional definition of algorithms :-)
15:09:35 <ibid> (specifically, knuth's)
15:09:45 <Heffalump> what is that?
15:10:02 <ibid> see TAOCP vol 1, first pages
15:10:07 <Heffalump> don't have it
15:10:08 <ibid> i don't have a copy handy
15:10:13 <Heffalump> ok :-)
15:10:16 <ibid> (it's at work and i'm not)
15:11:07 <ibid> basically, an algorithm is a set of instructions to compute a function that 1) has input 2) has output 3) is finite 4) always terminates 5) is correct [assuming i remember correctly]
15:11:25 <ibid> ah yes, 6) is precise
15:13:13 <ibid> but i'm off to bed
15:13:18 <ibid> bbl
15:14:28 <arguile> From TAoCP:
15:14:33 <arguile> 1: Finiteness
15:14:57 <arguile> 2: Definiteness (each step precisely defined...)
15:15:04 <arguile> 3: Input
15:15:09 <arguile> 4: Output
15:15:22 <arguile> 5: Effectiveness
15:16:48 <hdaume> i disagree with 1 :)
15:16:54 <hdaume> and (hence) 4
15:34:07 <earthy> hdaume: how would you describe an infinite algorithm?
15:34:25 <tez> Yes, the term 'non-terminating algorithm' would be a little wierd to define, I suppose.
15:34:34 <tez> weird
15:35:09 <hdaume> earthy: a web server
15:51:41 <earthy> hdaume: a web server consists of two terminating algorithms, continuously exchanging places
15:52:11 <earthy> or of an eventloop repeatedly executing finite algorithms
15:53:14 <hdaume> i still maintain that's an algorithm.  but if you don't like it, how about something which computes pi?
15:53:20 <earthy> the problem with allowing non-finite processes to be algorithms is that you then allow processes with no distinguishable result to be algorithms.
15:53:37 <hdaume> (and prints it out one digit at a time)
15:53:59 <earthy> hdaume: interesting.
15:54:11 <phubuh> using earthy's logic, that would be an algorithm to compute a single digit of pi, repeatedly executed by a loop
15:54:12 * earthy ponders and makes another note
15:54:19 <earthy> phubuh: :)
15:55:04 <earthy> anyway, it's much much too late to be pedantic ;)
15:55:08 <hdaume> :)
15:55:22 <phubuh> :-)
15:55:48 * earthy doesn't consider Knuth to be god, but disagreeing with him takes gusto and *loads* of argumentation :)
15:55:59 <hdaume> sure :)
15:56:10 <earthy> (well, not necessarily the latter, as the check in my deskdrawer proves ;))
15:56:25 <hdaume> i mean, you can make the definition he gives and then you have to backpedal a bit on things, or you can leave out condition 1 and you probably have to backpedal on other things
15:56:39 <earthy> yeah
15:58:09 <earthy> you'd have to add something to the tune of `delivering partial results in finite time'
15:58:15 <hdaume> yes
15:58:26 <hdaume> which would be under his "output" category
15:58:34 <earthy> but that sounds extremely hackish
15:59:11 <hdaume> because i assume what he wants to do is be able to define Alg1 = Alg2.  he requires finiteness so he can do this.  otoh, you could just say, for all time t1, exists t2 such that Alg1[t1] = Alg2[t2], or some such
16:00:18 <earthy> but you'ld come to an algorithm being a set instructions to compute a function that 1. is definite, 2. has input, 3. provides output within finite time 4. is effective
16:02:39 <earthy> hdaume: that is too restrictive. but, if you put it as  forall time t1 there is a time t2 such that the sum output over all p<t1 of Alg[p] = the sum output over all q<t2 of Alg2[q]
16:03:02 <earthy> that'd be acceptable for defining observational equality
16:03:35 <hdaume> i don't buy the 'in a loop' argument for the following reason: consider a program which outputs some function on previous outputs, perhaps [1,2,3,6,10,...] (but not this simple -- assume this function doesn't have a closed form solution).  now, there's an obvious algorithm to do this which takes constant time at each step.  but if you write an algorithm to compute the nth position, this will take O(n) time.  you clearly want to be able to sa
16:03:53 <Heffalump> you got cut off
16:03:57 <Heffalump> at "to be able to sa"
16:04:00 <hdaume> oh
16:04:05 <hdaume> you clearly want to be able to say that one is better than the other.
16:04:31 <hdaume> if you use the 'in a loop' argument, you can't consider the "faster" one to even be an algorithm
16:05:00 <earthy> ah, yes. but then the program that takes constant time can be represented as a loop over a second algorithm, akin to the first, but with the accumulator as extra argument...
16:05:42 <earthy> or am I now wholly mistaken?
16:05:54 <hdaume> sure, but it's still not an algorithm
16:06:15 <earthy> hdaume: nope, but it'd still be a looped algorithm
16:06:26 * earthy needs to reread his primitive recursion theory
16:07:07 * earthy needs to sleep even more... the alarm goes off in 5h
16:07:28 <earthy> night all
16:07:33 <hdaume> g'night
