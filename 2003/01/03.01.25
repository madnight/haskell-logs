00:41:30 <eivuokko> I must be doing something completely wrong when building ghc head in windows.  First it tries to build files in wrong order and, if I compile them by hand, then it dies somehow on dependency scan, not finding script or so.  Any hints?
06:09:32 <Janni> hi all.
06:10:06 <Marvin--> hello
07:10:21 <rublik> hi
07:33:46 <molar> hello anyone know anything about the pi-calculus?
07:34:21 <Janni> molar: either you want to calculate PI or i don't have a clue
07:34:36 <molar> latter :p
07:34:49 <molar> thanks anyway
07:34:52 <Janni> as i thought :)
07:36:31 <Smerdyakov> Well, I KNOW people who know something about it.
07:36:37 <Smerdyakov> But I don't think they're here ;-)
07:37:06 <molar> ok :(
07:37:29 <Janni> molar: what's it about?
07:37:45 * Janni just wants to know, _what_ you are talking about
07:38:59 <molar> definition of communication within processes
07:39:15 <Smerdyakov> I've seen a semantics for CML.
07:39:19 <Smerdyakov> I think it's probably similar.
07:39:20 <molar> mobility of communication links
07:40:11 <molar> I think so
07:41:46 <Smerdyakov> So did you have a question about it?
07:42:31 <molar> if x(y) means receive name y along x
07:42:44 <molar> and xbar<y> means send name y along x
07:43:27 <molar> then x(y).ybar<z> can be changed into x(w).wbar<z> by alpha-conversion,
07:43:48 <molar> i.e. replacing name y with name w
07:44:02 <molar> I understand that
07:44:04 <molar> but,
07:44:05 <Janni> sounds like lamba
07:44:11 <Janni> s/lamba/lambda
07:45:02 <molar> x(y).ybar<z> cannot be changed into x(z).zbar<z> by alpha converison
07:45:05 * Janni thinks of it as a specialisation of the lambda-calulus, but in fact has no clue
07:45:23 <molar> i.e. it is not okay to replace name y with name z but I dont understand why
07:45:39 <molar> I was guessing it is not possible to send name x along name x
07:45:44 <molar> but I wasnt sure
07:46:14 <molar> yep I think it has some relationship with the lambda calculus
07:46:17 <Smerdyakov> Simple answer
07:46:26 <Smerdyakov> z is a free variable.
07:46:47 <Smerdyakov> In the change you suggest, you "capture" the variable z, and lock out the variable bound _outside_this_expression_ that it originally meant.
07:47:34 <Smerdyakov> Remember, in general, you can only alpha-vary variables bound in the expression you are considering.,
07:49:26 <molar> ok I understand. silly me
07:49:33 <molar> I knew that rule all along
07:50:50 <Smerdyakov> =)
08:01:30 <Marvin--> molar: what's the "bar" part?
08:01:38 <rublik> :)
08:02:03 * Marvin-- recognizes the syntax from a course in programming language semantics
08:02:09 <Smerdyakov> Marvin--, I'd guess it denotes drawing a line over the variable name, to indicate sending instead of receiving.
08:02:23 <Marvin--> ahhhh, right you are
08:02:32 * Marvin-- is too much of a hacker and always associates "bar" with "foo"
08:03:00 <andersca> and baz
08:03:03 <Marvin--> yup
08:03:17 <molar> yep
08:03:22 <molar> thats what I meant by bar
08:03:49 * Marvin-- tries to remember how to write that in LaTeX
08:06:38 <Marvin--> ah, \overline
08:06:57 <Marvin--> so you've got  \overline{x}<y> :)
08:08:30 <molar> :)
08:09:42 <Marvin--> whoa, this manual is thick
08:09:46 * Marvin-- bought a laptop today
08:21:48 <molar> i'm off now
08:21:54 <molar> thanks for everyones help
08:21:54 <molar> bye
09:59:39 * shapr bounces
10:02:19 <johs> Evening.
10:02:25 <shapr> hiya
10:02:29 <shapr> what's up?
10:05:09 <johs> I thought I'd just come here and nag you a bit.
10:06:07 <johs> The thing is, I don't quite understand how Haskell is "purely functional", when you have imperative constructs.
10:06:20 <Smerdyakov> You don't.
10:06:42 <Smerdyakov> Machine state is implicitly passed around as a hidden parameter.
10:06:52 <Smerdyakov> At least, for IO...
10:06:58 <Smerdyakov> I don't know about those imperative variables =)
10:07:04 <Smerdyakov> Maybe they need to be in IO
10:07:59 <johs> So it's just passing World around, really?
10:08:23 <shapr> yup
10:08:25 <shapr> exactly
10:08:38 <johs> Clever.
10:08:39 <shapr> happily, the world can be updated in place
10:08:41 <Smerdyakov> shapr, do imperative variable access functions have IO types?
10:08:55 <shapr> Smerdyakov: what do you mean?
10:08:57 <shapr> like what?
10:09:19 <Smerdyakov> Do the types of whatever values you use to create and access imperative variables have IO in them?
10:09:36 <shapr> what do you mean by imperative variables?
10:10:10 <Smerdyakov> "MVars"?
10:10:10 <shapr> can you show me an example?
10:10:24 <shapr> I thought MVars had to do with concurrency?
10:10:33 <Smerdyakov> Not sure
10:10:41 <Smerdyakov> I just thought I saw something like ML ref's in Haskell somewhere.
10:10:54 <shapr> what do ML refs do?
10:11:09 <Smerdyakov> They're just like variables in tradtional imperative languages.
10:11:10 <shapr> heffalump knows about both Haskell and ML, he's probably the best person to talk to about this.
10:11:26 <shapr> oh, you can modify them in-place?
10:11:46 <Smerdyakov> Yes
10:11:48 <shapr> strictly speaking (ha ha), you don't have that in Haskell
10:12:06 <tWip> don't IORefs do just that?
10:12:10 <shapr> sure they do
10:12:23 <shapr> there are update in place variables
10:12:23 <Smerdyakov> tWip, so what I asked originally was: are these things constrained by their types to be in IO?
10:12:30 <Smerdyakov> tWip, and the name suggests that they are?
10:12:36 <shapr> and they don't have to be IO, but iirc, they do have to be some kind of monad
10:12:47 <Smerdyakov> Why called IORef, then? =)
10:13:15 <shapr> I'm pretty sure some of the arrays can be updated in place, as long as it's safe to do so.
10:13:24 <shapr> safe meaning, "does not violate referential transparency"
10:13:53 <Smerdyakov> That's not cool!
10:14:24 <tWip> why no?
10:14:28 <tWip> +t
10:15:05 <Smerdyakov> Makes it not purely functional, unless I misunderstand what shapr said.
10:15:59 <Smerdyakov> shapr, did you mean you can do this if you can localize the code that can reference the array and essentially just rebind the array variable?
10:16:03 <shapr> er, what part isn't pure?
10:16:08 <shapr> Smerdyakov: yes
10:16:11 <Smerdyakov> OK
10:16:25 <Smerdyakov> Typechecking such code sounds undecidable to me....
10:16:44 <shapr> I dunno, I've just heard people discussing in-place updates to such arrays.
10:16:52 <shapr> I haven't done it myself....
10:17:12 <Smerdyakov> OK
10:17:14 <shapr> I do know it's been discussed on haskell and haskell-cafe mailing lists
10:17:28 <shapr> so if you want specific details, that's a good place to look
10:17:40 <Smerdyakov> Allrighty
10:17:54 <Smerdyakov> I know there was a paper on pure functional arrays at ICFP 2002 =)
10:18:04 <Smerdyakov> But it used funky tree structures, I think
10:18:31 <shapr> which paper?
10:19:38 <Smerdyakov> "Bootstrapping One-sides Flexible Arrays", Ralf Hinze
10:19:45 <Smerdyakov> sides -> sided
10:19:48 <johs> I'm going to learn Haskell just because I find it so weird.
10:20:04 <shapr> I'm learning Haskell because I find it so gorgeous
10:20:06 <Smerdyakov> johs, maybe you want to learn ML if you prefer more practicality ;-)
10:20:16 <johs> I know OCaml.
10:20:21 <Smerdyakov> Huzzah!
10:20:48 <johs> Which is okay.
10:20:59 <johs> My favorite is Common Lisp, though.
10:21:04 * Smerdyakov punches johs.
10:21:25 * johs raises an eyebrow at Smerdyakov.
10:21:30 <Smerdyakov> ;)
10:21:52 <Smerdyakov> If you like CL better, you haven't used ML enough to learn it! :P
10:22:00 <tWip> I'm still not quite sure that I like using indentation for semantics... lisp wins in that respect...
10:22:15 <Smerdyakov> tWip, not over ML...
10:22:30 <tWip> but over haskell...
10:22:40 <tWip> don't know ML so can't say about it...
10:23:36 <Smerdyakov> It's pretty much true that ML is Haskell with strict evaluation and all the things trapped inside monads set free. =)
10:23:57 <johs> Smerdyakov: ML doesn't have macros. Or at least OCaml didn't.
10:24:12 <johs> Smerdyakov: (Yes, I know, ocamlp4.)
10:24:14 <Smerdyakov> johs, that's true, and we see that as an advantage =)
10:24:23 <johs> Pf.
10:24:45 <Smerdyakov> The less complex the language, the better you and your compiler can understand it!
10:25:24 <argv[0]> i'm sorry to interrupt you guys. I'm learning haskell for about a year in one university course. What haskell mailing-lists are around, and what can/should I subscribe?
10:25:27 <johs> Assembler is simple.
10:26:18 <tWip> punch cards are even more simple... still not a lot of ppl use those for coding
10:26:34 <Smerdyakov> johs, yes, you have to have a balance between simplicity and complexity =)
10:26:41 <johs> I did a simple parser in OCaml, by the way, and once I had satisfied the compiler, wrt some type errors, it worked perfectly on the first run. That was kind of fun.
10:26:42 <det> you gusy like Ocaml better than haskell ?
10:26:59 <shapr> argv[0]: haskell@haskell.org haskell-cafe@haskell.org 
10:27:01 <johs> det: I don't really know Haskell, so I don't know.
10:27:02 <Smerdyakov> argv[0], someone just told me about some :P
10:27:10 <shapr> argv[0]: I'll get the mailing list url for you.
10:27:18 <johs> You can read it on GMane.
10:27:26 <shapr> http://haskell.org/mailinglist.html
10:27:33 <Smerdyakov> det, I'd rather use Haskell if efficiency didn't matter, but I'll use ML now, with the current state of compilers.
10:27:39 <johs> Then you won't have to subscribe and shit.
10:27:40 <shapr> that url leads to a partial list of mailing lists
10:27:50 <johs> (http://www.gmane.org/)
10:28:11 <shapr> Smerdyakov: if you need efficiency, you can always wrap a C lib in Haskell
10:28:29 <det> Smerdyakov: is O'caml much faster than haskell ?
10:28:43 <det> Smerdyakov: and does Ocaml have the equivalent of type classes ?
10:29:38 <johs> The OCaml compiler makes fairly fast code.
10:29:42 <argv[0]> tanks =)
10:29:51 <shapr> det: OCaml is faster than haskell that much I know.
10:30:05 <johs> shapr: Faster than GHC and Hugs, you mean?
10:30:18 <shapr> Hugs is an interpreter, so it's not blazingly fast
10:30:23 <johs> I know.
10:30:34 <Smerdyakov> I don't know of any ML's with type classes.
10:30:39 <shapr> GHC is an excellent compiler, it makes really fast Haskell programs.
10:30:41 <johs> My point is just that in theory, someone _could_ make a Haskell-compiler that rivalled the OCaml-compiler, right?
10:30:53 <johs> Or is it not feasible?
10:30:57 <Smerdyakov> Both ocaml and MLton produce code that often surpasses gcc C++ output in efficiency.
10:30:58 <shapr> probably so
10:31:07 <det> johs: It probally depends on lazy evaluation
10:31:19 <det> shapr: how does ghc compare with ocamlc ?
10:31:21 <shapr> yah, the lazy evaluation is one of the major slowdowns.
10:31:25 <shapr> det: I don't know. 
10:31:39 <johs> det: There are some benchmarks on The Great Computer Language Shootout.
10:31:43 <johs> det: Google for it.
10:31:46 <shapr> I've read that OCaml code of a similar algorithm averages about 200% of the C code
10:32:01 <Smerdyakov> shapr, not in the Shootout
10:32:20 <Smerdyakov> shapr, perhaps he used bad, unrepresentative examples
10:32:23 <shapr> I think that GHC output is something like 700% of C, though this is a vague memory.
10:32:43 <johs> I the shootout, OCaml is nearly as fast as GCC.
10:32:44 <shapr> Smerdyakov: well, the shootout has really old code, takes a bit of hacking to get the Haskell code to work.
10:32:50 <johs> And mlton too.
10:33:06 <Smerdyakov> OCaml and MLton get between 100% and 101% of the speed of C over those tests :P
10:33:12 <johs> Haskell is beaten by... Python. :)
10:33:19 <johs> (Haskell -> ghc)
10:33:24 <tWip> really?
10:33:27 <shapr> in my opinion, you should write code in the language that you love, and if you really need speed, wrap a C lib, or write a C lib to wrap.
10:33:55 <shapr> discussions about speed aren't really that important.
10:34:05 <Smerdyakov> It's icky to have to use a non-typesafe language just to get acceptable speed.
10:34:20 <shapr> well
10:34:22 <johs> Mm.
10:34:25 <shapr> them's the breaks :-)
10:34:29 <Smerdyakov> Not really.
10:34:41 <Smerdyakov> You could, for example, write speed critical portions in SML or OCaml.
10:34:46 <Smerdyakov> And use Haskell for the rest.
10:35:02 <det> does Haskell have a FFI for ocaml ?
10:35:08 <shapr> but, if you're going to rewrite for speed, why not use C?
10:35:16 <johs> (By the way, CMUCL (Common Lisp-compiler) scores quite well on the shootout too.)
10:35:22 <Smerdyakov> shapr, if ML compilers produce code just as fast, then why use C?
10:35:37 <Smerdyakov> johs, it's not up with the big boys :P
10:35:49 <johs> Smerdyakov: Yes it is.
10:35:56 <johs> Smerdyakov: 6th place.
10:36:10 <johs> Smerdyakov: Just behind g++ and smlnj.
10:36:15 <shapr> in any case, profiling and abstraction changes will always improve your code more than porting.
10:36:32 <Smerdyakov> johs, yes, defeated by every native code ML compiler ;-)
10:36:45 * shapr sighs
10:36:52 <johs> Smerdyakov: Yeah, yeah.
10:37:09 <shapr> so, anyone wanna write some Haskell code?
10:37:15 <shapr> :-P
10:37:21 <Smerdyakov> shapr, OK
10:37:22 <Smerdyakov> 0
10:37:23 <johs> Smerdyakov: But it's a bit of an achievement, considering Lisp is a dynamic language, as opposed to the static languages that beats it.
10:37:32 <Smerdyakov> johs, yup, it's not down by much.
10:37:40 <shapr> SSmerdyakov: I wanna write an SMTP.hs, you interested?
10:37:59 <Smerdyakov> johs, I think the REAL show-stopping advantage in using ML over Lisp is in development time saved, for single people and for others trying to understand others' code and interfaces.
10:38:12 <shapr> oy
10:38:13 <Smerdyakov> shapr, nope, already working on a web server in SML :P
10:38:14 <shapr> vei
10:38:18 <shapr> Smerdyakov: ok
10:38:32 <shapr> there's a nice web server written in Haskell, even has support for Apache style plugins.
10:38:37 <johs> Smerdyakov: I'm not going to bother getting into an argument.
10:38:51 <whee> erlang also makes a great language for web servers
10:39:08 <shapr> if you feel like extolling the virtues of Haskell, this is a good place to do it.
10:39:09 <Smerdyakov> "A web server" is a short description. It hosts templates written in a ML-like language that is safe to let various people use in their own personal sites.
10:39:10 <johs> Smerdyakov: Maybe some other day.
10:39:20 <shapr> if you wish to extol the virtues of ocaml or lisp... there are other places to do it.
10:39:37 <johs> shapr: Exactly.
10:39:52 <shapr> :-)
10:39:59 <whee> shapr: get me a working CVS GHC compiler :)
10:39:59 <johs> Although where is it appropriate to have a language war?
10:40:04 <Smerdyakov> Well, the "show-stopping advantage" above is shared with Haskell, soooo....
10:40:11 <shapr> johs: somewhere else :-P
10:40:12 <johs> :)
10:40:14 * shapr grins
10:40:26 <shapr> whee: for what OS?
10:40:31 <whee> OS X.
10:40:33 <shapr> I've built from CVS quite a few times.
10:40:33 <shapr> oh
10:40:49 <whee> I've given up on  using ghc until it actually works, heh
10:41:04 <shapr> I really do want a Template Haskell snapshot.. I'm desperate to play with the new macro system.
10:41:08 <whee> which won't be until an official release with TH :\
10:41:13 <shapr> yah, really
10:41:25 <shapr> the Simons have said they could push one out the door if we all really want it.
10:41:29 <johs> shapr: Macros, eh? :)
10:41:30 <shapr> I think we should ask for it!
10:41:47 <shapr> johs: yah!
10:41:50 <shapr> very cool stuff.
10:41:52 * johs chuckles.
10:42:00 <shapr> Simon PJ has a paper about it on his website.
10:42:16 <det> shapr, what is template haskell ?
10:42:28 <Smerdyakov> Simon PJ does not come across as a very easy person to get along with ;)
10:42:31 <shapr> det: in short, it's a macro system.
10:42:42 <johs> Simon PJ seems clever. I'm scoring him up in Gnus.
10:42:47 <shapr> Smerdyakov: even so, I'd have to be at least triplets to get close to his brain :-)
10:42:48 <whee> johs: wolfgang wrote full cocoa bindings using TH, in a 16kb bz2
10:43:02 <whee> it's going to be great if people actually use TH
10:43:06 <shapr> oh they will
10:43:09 <shapr> no doubt about that
10:43:21 <det> oh, I don't like macros much
10:43:29 <johs> det: Wimp.
10:43:33 <shapr> there are quite a few research languages that have been implemented as Haskell preprocessors
10:43:52 <shapr> many of them will be Haskell native once TH is in standard GHC
10:43:59 * shapr can think of about six
10:44:02 <det> whee, what doesn't work about ghc ?
10:44:54 <johs> Bye.
10:45:45 <shapr> time for coding, page me if you need something
10:46:02 <det> shapr, coding what ?
10:46:11 <det> shapr: code me a top hat
10:46:16 <det> shapr: I've always wanted one
10:51:41 <shapr> det: just hacking up an smtp lib
10:52:04 <shapr> det: haskell already has a hat... though it's not yet top.
10:55:35 <shapr> det: have you tried any code in Haskell yet?
10:57:16 <whee> det: ghci and TH don't work whenever I build recent CVS
10:57:33 <whee> it appears to be a library loading problem
10:57:42 * shapr updates his local ghc cvs
10:58:02 <whee> so GHC is pretty useless to me until I get working TH support somehow :\
10:59:15 <shapr> whee: we could ask for a working TH release, even if it's just beat
10:59:17 <shapr> er, beta
10:59:26 <shapr> or you could ask wolfgang
11:02:22 <shapr> man, I hope I don't mangle my email with this...
11:05:00 <det> shapr, got to go, bye
11:05:09 <shapr> cya
11:09:53 * shapr hrms
11:15:12 <shapr> isn't there already an RFC822.hs somewhere?
11:22:16 <shapr> what's a literal gap?
11:23:57 --- topic: set to '["mo' nads than you", "We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/", "Gtk+HS 0.14.10:  http://www.cse.unsw.edu.au/~chak/haskell/gtk/","HWS-WP: http://www.dum.chalmers.se/~marvin/hws-wp/", "HaskellWiki resurrected", "HaSDL: http://www.xs4all.nl/~dark/hasdl-0.1pre7.tar.gz","New HTk release http://www.informatik.uni-bremen.de/htk/", "Tallest dwarf in Moria"]' by shapr
11:24:56 * shapr bounces happily
11:29:55 <shapr> truly, smtp is simple
11:33:07 <andersca> you know what the s stands for, right? :)
11:33:16 <shapr> yep :)
11:33:41 <whee> heh
11:48:29 * shapr hrms more
12:04:06 * shapr bounces happily
12:04:16 <shapr> sockets are buffered by default
12:10:18 <shapr> this is good to know.
12:29:39 <shapr> yay, I can send a static message
12:29:54 <shapr> now to refactor some static stuff out into args
12:31:59 <steele> hi
12:32:20 <shapr> hiya
12:32:39 * shapr codes happily
12:32:49 <shapr> do you need some haskell help?
12:34:04 <shapr> I wish haskell-mode had something like c-style for haskell
12:36:15 <steele> shapr: not at the moment ;)
12:36:19 <whee> emacs, eww :)
12:36:25 <shapr> hey, I like emacs.
12:48:34 <jadrian> hi
12:48:40 <shapr> hi jadrian 
12:48:44 <jadrian> hello shapr
12:48:47 <shapr> what's up?
12:48:58 <jadrian> eh not much
12:48:59 <jadrian> you?
12:49:32 <shapr> hacking on SMTP.hs
12:49:45 <jadrian> nice 
12:49:55 <shapr> it's ugly, but it sort of works.
12:50:39 <shapr> have you seen MIME or RFC822 modules for Haskell anywhere?
12:50:49 <jadrian> isn't it supposed to be pretty when you do it in haskell...?
12:51:19 <shapr> it will be pretty :-)
12:51:25 <jadrian> nope... never seen one.
12:51:25 <shapr> ugly code can happen in any language
12:51:28 <jadrian> ah ;)
12:51:55 <shapr> I'm happy it works.
12:52:01 <shapr> I want all the libs I have in Python
12:52:19 <shapr> otherwise I end up using Python in my daily tasks instead of Haskell
12:52:41 <jadrian> :)
12:53:24 * jadrian never tried python
12:53:56 <andersca> you should
12:53:57 <andersca> it rocks
12:54:16 <jadrian> shapr: was looking at the logs, what is that c-style for emacs you were talking about?
12:54:32 <shapr> http://kungens.kemi.fi/~shae/src/haskell/SMTP.hs
12:54:33 <jadrian> andersca: been told its nice, but no time for it now...
12:54:40 <shapr> snicker at my ugly code!
12:54:45 <shapr> actually, any comments wolud be appreciated.
12:54:59 <shapr> jadrian: I was just wishing for such a thing, I don't think it exists.
12:55:22 <jadrian> shapr: yes I know, but what is it? 
12:55:33 <jadrian> shapr: the c-style, what does it does?
12:55:38 <shapr> c-style in emacs lets you change your indentation style
12:55:44 <jadrian> oh
12:55:47 <shapr> gnu, k&r, etc
12:55:58 <jadrian> I didn't know such a thing existed, got to check it out
12:56:22 <shapr> so you could specify whether you want lines following do to be indented at the same level
12:56:29 <shapr> or just after the do, etc
12:56:57 * steele is just looking at haskell-indent.el since he doesn't like the let .. in indentation
12:57:03 <jadrian> there are many flaws in the haskell mode for emacs, the indentation could be improved a lot
12:57:11 <shapr> even so, it does work
12:57:28 <jadrian> steele: yes, that one always drives me nuts
12:57:42 <jadrian> I try to avoid lets but now I got to used them because of implicit parameters
12:57:43 <shapr> you can use where, they're equal now
12:58:09 <steele> shapr: there are some good ideas in it, but there are many flaws
12:58:25 <jadrian> you can't use where with implictit patameters.. (5.04)
12:58:36 <shapr> I haven't tried implicit params
12:59:05 <jadrian> I can't do without them...
12:59:48 <jadrian> they are very usefull in many situations
13:00:32 <jadrian> imagine you have in some textbook a few formulas like:
13:00:57 <jadrian> (w+e)*y - sqr(t)
13:01:12 <jadrian> (2*w)-e
13:01:14 <jadrian> etc
13:01:33 <jadrian> opss I meant
13:01:38 <jadrian> delta = (w+e)*y - sqr(t)
13:01:54 <jadrian> epsilon = (2*w)-e
13:02:47 <jadrian> and w,e,y etc are not constants, they depend on some inicial input
13:03:39 <shapr> ok
13:03:40 <jadrian> it is very handy to be able to, at a given point, fix those calculated values as constants in a given context
13:03:48 <shapr> that does sound handy
13:04:45 <jadrian> yeap
13:06:27 * shapr looks for RFC822 and MIME modules for Haskell
13:06:32 <shapr> or any email related code for Haskell
13:06:45 <Smerdyakov> Execute 'mail' :P
13:07:05 <shapr> that much I can probably do.
13:07:14 <Smerdyakov> That's what I do in my aforementioned thing.
13:07:38 <shapr> that won't work on win32
13:08:10 <Smerdyakov> Who cares about Win32? =) You can get command line mail programs for Windows.
13:08:17 <shapr> I can barely wait till we get a site up where I can keep a list of the available Haskell libs
13:08:23 <shapr> and local cached copies.
13:11:18 <shapr> it's hard to google for a haskell rfc822 lib
13:14:48 <gdsx> shapr: what's rfc822?
13:15:52 <eivuokko> email specs
13:18:58 <jadrian> hmmm isn't (->) a type constructor?
13:20:27 <shapr> in which context?
13:21:09 <jadrian> context?
13:21:20 <jadrian> oh
13:21:26 <jadrian> Int->Int
13:21:31 <jadrian> a->b
13:21:41 * shapr isn't sure
13:22:00 <shapr> it means "a function that takes one argument and returns another argument"
13:22:14 <jadrian> I'm pretty sure it is... I've seen instance declarations for (->a)
13:22:24 <jadrian> or something like that
13:26:59 <shapr> I'm positive I've seen an rfc822 parser for haskell somewhere...
13:27:37 <shapr> I guess I'll write my own.
13:32:40 <jadrian> bbl
13:35:22 <shapr> what's the most highly recommended parser generator for Haskell?
13:35:23 <shapr> Parsec?
13:35:29 <andersca> I like happy
13:35:53 * shapr looks at happy
13:42:22 <shapr> is there any major difference between happy and parsec?
13:43:43 <det> happy is a parser generator where parsec is a monadic parser combinators library
13:43:51 <shapr> good point.
13:45:56 <det> I think I am beginning to understand monads
13:46:02 <shapr> cool!
13:46:10 <shapr> can you explain them to me? :-)
13:46:26 <det> *beginning* to :p
13:46:38 * shapr grins
13:46:59 <det> haskell is a very fun language indeed
13:47:10 <shapr> I strongly agree.
13:47:11 <det> I want to write a 2d game in it using HOpenGL
13:47:22 <shapr> wanna help me with SMTP.hs? ;-)
13:47:23 <det> I love haskell type classes
13:47:28 <shapr> I do too
13:47:47 <det> shapr: write a 2d game with me!
13:47:55 <shapr> um. 
13:47:58 <shapr> ok
13:48:05 <det> shapr: I want to clone uniball
13:48:09 <shapr> what's that?
13:48:17 <det> simple windows game
13:48:21 <shapr> never heard of it
13:48:31 <det> yeah, doubt anyone has
13:48:39 <det> it's multiplayer
13:48:55 <shapr> sounds nifty
13:48:56 <det> you fly around in a ship and shoot a ball in a goal basicly
13:49:09 <det> and try to stop the other people from scoring
13:49:28 <det> and do alot of bouncing the ball off of walls
13:49:52 <shapr> sounds a bit like descent
13:50:00 <det> and it sucks to play on a slow connection because the client is something of a dumb terminal :)
13:50:17 <shapr> http://www.uniball-central.com/sshots/fullsize/subzero.gif
13:50:29 <shapr> looks like subspace, the old topdown multiplayer game
13:50:59 <det> I was playing subspace a couple says ago :)
13:51:04 <det> days even
13:51:23 <shapr> I played the beta, before it was fully released...
13:51:24 <det> well, now it is called continuum
13:51:29 <shapr> when only a few people were on
13:51:34 <shapr> I used to rule the world :-P
13:51:34 <det> when it was called sniper ? :)
13:51:42 <det> subspace is alot of fun
13:51:47 <shapr> 1992?
13:51:50 <shapr> does that sound right?
13:51:54 <det> I don't remember
13:52:02 <det> a little early I think
13:52:28 <shapr> so, uniball is space soccer?
13:52:37 <det> but that screenshot is wayy to many people, normally games have 4-6 people
13:52:51 <det> there are different game types
13:53:07 <det> but basicly arena soccer with a computer goalie
13:53:18 <shapr> sounds neat
13:53:51 <det> nice simple game that is alot of fun
13:54:06 <det> I would like to improve on the problems it suffers from lag
13:54:38 <det> like nice prediction stuff
13:55:05 <shapr> ipv6 support, so you can do bittorrent kind of speed-ups
13:55:23 <det> how does bittorrent do speedups ?
13:56:01 <shapr> with bittorrent, if two clients are downloading, they each only ask for half the packets, and get the other packets from each other
13:56:19 <shapr> basically, crappy ipv6 multicasting
13:56:21 <shapr> sort of
13:56:26 <det> that's strange
13:56:50 <shapr> it's nice because no matter how many clients are downloading, it's not very heavy on your bandwidth
13:57:01 <eivuokko> Hum.  Why do you need ipv6 for that?
13:57:05 <shapr> it's a centralized peer to peer download system, as silly as that sounds
13:57:13 <det> with the current state of obtaining a ipv6 address, however that would lead to too many slowdown where it counts the most (ping)
13:57:19 <shapr> eivuokko: you don't need it for bittorrent, but you would for real multicasting
13:57:40 <eivuokko> shapr, that sounds more reasonable :)
13:57:57 <shapr> det: have you seen fungen and hasdl?
13:58:07 <det> I looked at fungen
13:58:14 <det> didnt really like the design
13:58:16 <shapr> hasdl is an SDL binding
13:58:34 <det> but I am sure there is useful code to be stolen nonetheless :)
13:58:40 <det> paticulary collision detection
13:58:42 <shapr> I'm sure :-)
13:58:52 <det> that stuff is never any fun
13:58:59 <shapr> I'd like to rip off the Yampa code and use it.
13:59:04 <shapr> that would be *cool*
13:59:06 <det> Yampa ?
13:59:12 <shapr> ohh, yampa is awesome :-)
13:59:14 * shapr gets url
13:59:26 * det looks
13:59:34 <shapr> http://haskell.cs.yale.edu/yampa/
13:59:40 <det> "Functional reactive programming with arrows" .. hrmm
13:59:43 <shapr> yop
13:59:51 <shapr> you gotta see the demo
14:00:00 <shapr> when you see the robots playing soccer...
14:00:05 <det> I think I might prefer programming in haskell over python
14:00:11 <shapr> I do
14:00:13 <det> thought I havent written anything yet :)
14:00:16 <shapr> heh
14:00:24 <shapr> you really want to write some stuff first
14:00:35 <shapr> things work differently in ways you might not expect
14:00:35 <shapr> for example...
14:00:54 <shapr> head $ filter (> 5) [1..]
14:01:00 <shapr> is not something you would ever do in Python
14:01:26 <shapr> but it's quite nice in Haskell
14:01:27 <det> well, I understand FP stuff decently
14:01:46 <shapr> lazy evaluation is really trippy
14:01:53 <shapr> as someone recently said on this channel
14:02:00 <det> that's the one thing that I dont really like of haskell
14:02:07 <shapr> I really do like it.
14:02:14 <shapr> you can do some amazing tricks with it.
14:02:55 <det> what is reactive programming ? Like, what is Yampa *for* ?
14:03:09 <det> an event library ?
14:03:10 <andersca> qsort [] = []
14:03:10 <andersca> qsort (x:xs) = qsort (filter (< x) xs) ++ (x:qsort(filter (>= x) xs))
14:03:12 <shapr> there's a paper, and a demo
14:03:13 <andersca> that's nice :)
14:03:27 <shapr> det: yah, kind of an event library.
14:03:47 <shapr> event libs act weird in a functional language, especially lazily evaluated
14:03:53 <shapr> you can have space leaks
14:04:17 <shapr> which just means you don't know when to let go of something, because the runtime system can't be sure you're done with it.
14:04:54 <shapr> space leaks in Haskell can get very weird and confusing, because the run time system doesn't see the code at all like we do.
14:05:00 <det> oh, the lazyiness hold references to functions behind the scenes, YUCK
14:05:08 <shapr> happily, profiling tools exist
14:05:17 <shapr> det: sometimes that's really good.
14:05:24 <det> yampa robotics libray, hrmm
14:05:35 <det> shapr: when it is helpful, it could be explicit :p
14:05:40 <shapr> at the very least, it would be a good way to write an AI for Huniball
14:05:55 <shapr> HunnyBall? :-)
14:06:23 <shapr> I like lazy evalution so far.
14:07:16 <det> HoneyBall, you play in a big honeycomb!
14:10:49 <shapr> :-)
14:11:04 <det> shapr: have you written anything in haskell ?
14:11:10 <shapr> some
14:11:30 <shapr> http://kungens.kemi.fi/~shae/src/haskell/
14:11:32 <Smerdyakov> What's this? Big Mr. shapr can't just answer "yes" to that question? =D
14:12:02 <shapr> Smerdyakov: just that I haven't written anything that anyone else is using.
14:12:29 <det> shapr: ever finish Jelly.hs? :)
14:12:36 <shapr> det: nah, never did.
14:12:42 <shapr> it's on my todo list :-)
14:14:01 <shapr> det: you want to work on it with me?
14:14:05 <det> <smkl> if you had type "data S a = Self | Elem a" and "data E a = E a | L [E a]" then you could have "conv x [] = []; conv x (Self:tl) = L x : conv x tl; conv x (Elem a:tl) = E a : conv x tl; convert x = y where y = conv y x"
14:14:14 <det> shapr: head exploding
14:14:30 <det> shapr: definately!
14:14:32 <shapr> det: it's just about something called "tying the knot"
14:14:44 <det> shapr: oh Jelly, out of my league :)
14:15:24 <det> if you can't have a list that contains itself then what is ones = 1 : ones ?
14:15:32 <shapr> http://haskell.org/wiki/wiki?TyingTheKnot
14:15:39 <shapr> exactly
14:16:48 <det> that's the kind of trickery that turns me off to lazy evaluation :)
14:17:03 <eivuokko> Huh.
14:17:13 <eivuokko> That's cool about lazy evaluation :)
14:19:00 <det> right :)
14:20:02 <det> I wonder if Jell.hs is even possible
14:20:13 <shapr> it's possible
14:20:21 <shapr> just going to be exciting :-)
14:20:32 <det> what about list of arbitrary types ?
14:20:46 <det> how do you type that ?
14:21:09 <shapr> you don't
14:21:21 <det> I guess the application using jelly would have to
14:21:24 <shapr> you get one of two things
14:21:34 <shapr> either, JellyType which is a unification type
14:22:04 <shapr> or you stick your native Haskell datatypes into a thread that translates into Jelly style encoded types and sends them onto the wire
14:22:16 <shapr> I prefer the second solution, but the first is easier to deal with in some ways.
14:22:27 <det> I mean, how to unmarshal :)
14:22:54 <det> but ..
14:22:56 <shapr> if it's a unification type, it's really easy
14:23:07 <shapr> if you go native, you have to match 'em up.
14:23:19 <det> a thread ?
14:23:20 <shapr> in some cases, that would mean creating native types like PythonModule
14:23:51 <shapr> yah, effectively a separate server that hides the marshalling from you.
14:24:03 <shapr> just pretends to be a network socket with some extra knobs
14:24:09 <Marvin--> evening
14:24:13 <det> hrmm, haskell FFI to python via C
14:24:20 <shapr> good evening mr sjögren
14:24:21 <shapr> how are you?
14:24:34 <shapr> det: too cheesy, and requires python on the same system.
14:24:48 <det> shapr: unrelated to Jelly, I mean
14:24:59 <shapr> oh, ok
14:25:13 <Marvin--> a bit tired
14:25:29 * Marvin-- goes to pat his laptop :P
14:25:44 * shapr hacks away on SMTP.hs
14:26:10 * andersca hacks away on D-BUS
14:26:50 <shapr> what's D-BUS?
14:27:32 <andersca> http://www.freedesktop.org/software/dbus/
14:27:36 <det>  <Pseudonym> Lazy evalution is really, really trippy.
14:27:39 <det> :p
14:28:00 <shapr> yep :-)
14:28:00 <Marvin--> andersca: new name for fdmb?
14:28:04 <andersca> Marvin--: yep
14:28:07 <andersca> D-BUS is way cooler ;)
14:28:10 <Marvin--> andersca: why? :)
14:28:13 <Marvin--> ohj
14:28:16 <Marvin--> -j
14:28:29 <andersca> there are so many jokes about it
14:28:41 <shapr> how does D-BUS compare to ToolBus, and that other thing that UniForM is using?
14:28:44 <Marvin--> bahhh, why doesn't my firewall script log anything?! :(
14:28:50 <andersca>  /* Here we tell the bus driver that we want to get off. */
14:28:50 <andersca>   bus_driver_remove_connection (connection);
14:28:53 <shapr> Marvin--: because you're not really on the internet.
14:29:00 <Marvin--> shapr: oooh
14:29:04 <shapr> Marvin--: you're in *THE MATRIX*
14:29:22 <shapr> take the stripey pill!
14:30:31 <shapr> Smerdyakov: plus, I've been losing weight lately, so I'm not that big anymore :-P
14:31:03 <det> shapr: give some of that weight to me!
14:31:12 <shapr> det: how much do you weigh?
14:31:16 <Marvin--> ${IPTABLES} -t filter -A INETIN -j LOG; ${IPTABLES} -t filter -A INETIN -j ${DROP} <- doesn't that look right?
14:31:25 <det> shapr: 125
14:31:27 <shapr> I'm 210 or so
14:31:36 <shapr> det: how tall?
14:31:41 <det> 5'9"
14:31:42 <shapr> I'm 5' 10"
14:31:55 <Marvin--> heh, I have no idea how long ago it was that I checked my weight
14:32:06 <shapr> happily, I have enough shoulder width for two people
14:32:12 <shapr> so I don't look overweight.
14:32:15 <Marvin--> probably something like 80-85
14:32:29 <det> Marvin--: how tall are you ?
14:32:40 <shapr> I'm 95 kilos
14:33:22 <det> shapr: does haskell have sockets? async ?
14:33:24 <Marvin--> det: 1.92-1.93 or so
14:33:42 <det> Marvin--: wahhh, I am too stupid to convert
14:33:44 <shapr> det: does have sockets, don't think there are callback sockets.
14:33:51 <Marvin--> det: apt-get install units :P
14:34:10 <Marvin--> You have: 1.92m
14:34:10 <Marvin--> You want: foot
14:34:10 <Marvin-->         * 6.2992126
14:34:10 <Marvin-->         / 0.15875
14:34:13 <det> Marvin--: I sold my computer for food, so I am stuck on someone elses windows machine, wahhh
14:34:18 <det> Marvin--: no more apt for me
14:34:22 <whee> I never understood the output of units.
14:34:32 <shapr> det: you seriously sold your PC for food?
14:34:42 <Marvin--> det: ouch
14:34:43 <det> for moeny -> buy food ->eat
14:34:58 <shapr> er, so... why are you learning a new language? why don't you go out and work a bunch of hours?
14:35:08 <shapr> I'd think I'd rather starve than lose my PC....
14:35:12 <shapr> of course, my stomach disagrees.
14:35:21 <det> shapr: I require alot of food :)
14:35:54 <shapr> I make a decent amount of money writing Python and Java
14:35:56 <shapr> you can too
14:36:13 <det> tell me how!
14:36:20 <shapr> get some Zope contracting work
14:36:26 <shapr> worked for me.
14:36:28 <det> I dont know java!
14:36:34 <det> boohoo
14:36:41 <shapr> java is like C, with a little less braindeath involved.
14:36:48 <shapr> and a lot more manic insanity
14:36:51 <det> I know C, hooray!
14:37:01 <det> manic insanity, boohoo
14:37:12 <shapr> seriously, java jobs are very common.
14:37:52 * Marvin-- is going to write a javalette compiler
14:37:57 <shapr> can't you work for ninjaneering?
14:38:41 <shapr> hey Marvin--, you know of a MIME or RFC822 module for Haskell?
14:38:54 <det> 3 jobs in nevada on dice for Las Vegas
14:38:57 <det> for java
14:39:18 <shapr> oh, you're in vegas...
14:39:26 <det> yeah
14:39:50 <shapr> yes, look for java jobs, and bring your C, Python, and SQL based experience.
14:40:03 <det> right, SQL
14:40:11 <shapr> you know SQL?
14:40:13 <Marvin--> shapr: no, not that I know of
14:40:15 <det> no :)
14:40:46 <shapr> det: it's pretty easy. took me a very short amount of time to figure it out.
14:41:03 <det> I imagine so
14:41:16 <det> shapr: I know what I need!
14:41:20 <shapr> det: what?
14:41:26 <det> shapr: psychoactive meds!
14:41:30 <shapr> hrm
14:41:31 <shapr> I dunno
14:41:35 <det> shapr: my address is ..
14:41:42 <shapr> I'm not sending you my meds!
14:41:51 <shapr> they're MINE.
14:41:59 <shapr> :-P
14:42:01 <det> shapr: muahaha, I was gonna SELL THEM :p
14:42:11 <shapr> no way d00d. mine!
14:43:08 <Marvin--> o.O
14:43:10 <Marvin--> this is getting bizarre
14:43:26 <whee> heh.
14:43:49 <shapr> has anyone written an rfc822 parser before?
14:44:18 <Marvin--> not standards-compliant ones... only parsers for  'something: something'-lines :)
14:44:37 <shapr> I guess I could go worse is better.
14:45:26 <shapr> is there an ABNF parser for Haskell?
14:45:37 <Marvin--> ABNF?
14:45:56 <shapr> seems that rfc2822 has its rules in formal ABNF syntax.
14:46:07 <shapr> no, I don't know what it is :-)
14:46:09 <det> most things do
14:46:23 <shapr> oh
14:46:35 <shapr> This standard uses the Augmented Backus-Naur Form (ABNF) notation
14:46:35 <shapr>    specified in [RFC2234] for the formal definitions of the syntax of
14:47:00 <det> http://www.cs.chalmers.se/~aarne/BNF/
14:47:13 <shapr> aha!
14:47:17 <shapr> thanks det!
14:50:34 <det> I guess you could just tokenize the BNF and write combinators for all the BNF operations also
14:52:52 <Marvin--> well, I know what the BNF converter is (we use it in the compiler construction course, Aarne is teaching it)... is ABNF what Aarne calls Labelled BNF?
14:53:15 <det> no
14:53:18 <Marvin--> or what's the difference between ABNF and BNF?
14:53:20 <shapr> they seem different
14:53:21 <det> ABNF is Augmented BNF
14:53:29 <det> Augmented somehow
14:54:01 <det> Over the years, a modified version of Backus-Naur Form
14:54:01 <det>    (BNF), called Augmented BNF (ABNF), has been popular among many
14:54:02 <det>    Internet specifications. 
14:54:13 <shapr>    The differences between standard BNF and ABNF involve naming rules,
14:54:13 <shapr>    repetition, alternatives, order-independence, and value ranges.
14:54:37 <det> shapr: I was just pasting that :)
14:56:52 <shapr> :-)
14:57:36 <det> shapr: I think Jelly.hs would be a great learning experience
14:57:45 <shapr> yah, I agree.
14:58:06 <shapr> though tonight I'm focussing on email libs.
14:59:00 <det> for any paticular reason ?
14:59:25 <shapr> I wanted something I could finish this weekend.
14:59:30 <shapr> and something I would use.
14:59:38 <det> ahh
14:59:40 <shapr> SMTP.hs is ugly, but usable.
15:03:11 <shapr> yow, MIME looks like it's not a weekend project.
15:04:37 <shapr> actually, maybe it's only scary if I'm trying to encode audio/image/etc
15:07:47 <liiwi> shaprrr
15:08:58 <Marvin--> MIME is really really scary
15:11:21 <shapr> hi liiwi 
15:11:27 <shapr> Marvin--: you've done MIME stuff?
15:11:41 <Marvin--> no, but I know Boyd has, and he can curse :)
15:12:10 <Marvin--> once he got into a tirade about MIME and I lost count of how many times he used the word "horrible"
15:15:19 <Marvin--> hrrm, I wonder how long this battery lasts
15:27:46 <shapr> hey, Marvin-- if you haven't tried Munchkin from steve jackson games.. YOU MUST TRY IT.
15:27:51 <shapr> I played it last night for the first time
15:28:08 <shapr> we played it for ... I think six hours straight.
15:28:24 <shapr> because we wanted to keep playing so much
15:28:46 <shapr> finally at 4am we collapsed from the combination of alcohol, sauna, and sheer backstabbing treachery
15:29:23 <shapr> Marvin--: http://sjgames.com/munchkin/game/
15:29:28 <shapr> this is such a great game.
15:29:50 <Marvin--> yeah, Munchkin is a good game :)
15:30:18 <shapr> oh, you've played it :-)
15:30:24 <shapr> I'm so addicted.. I want the expansions!
15:30:31 <Marvin--> heh
15:30:41 <Marvin--> have you played Chez Geek?
15:30:44 <shapr> yes, lots
15:30:48 <shapr> I like Munchkin better.
15:30:56 <shapr> we have chez dork and chez geek 2 also
15:31:03 <shapr> we have lots of games
15:31:18 <shapr> I'm most fond of the looneylabs stuff
15:31:32 <Marvin--> CheapAss games have quite a few nice games too
15:31:49 * esap just plays go and nethack.
15:32:16 <shapr> haven't heard of them
15:32:38 <shapr> esap: I prefer games with other humans involved, and in the same room if possible.
15:32:47 <Marvin--> they've got for example the wondeful game Kill Dr Lucky :)
15:33:04 <esap> go is a board game.
15:33:06 <Marvin--> http://www.cheapass.com/products/index.html
15:33:32 <Marvin--> I'm very curious of FALLING
15:33:41 <Marvin--> Playing Time: 2 minutes or less
15:33:50 <Marvin--> last one to hit the ground wins :)
15:34:06 <shapr> heh
15:34:25 <Marvin--> it's a real-time card game with a dealer
15:34:45 * esap doesn't like games where the success depends on chance.
15:34:58 <esap> oh except nethack :-)
15:35:18 <shapr> esap: check out the looneylabs games then
15:35:55 <shapr> we've gotten together twice to play games, I hope this to be a regular occurrence
15:36:22 <shapr> we've got two from Lulea and two from Boden, so we're alternating locations
15:36:23 <Marvin--> shapr: tetrinet?
15:36:43 <shapr> hmmm
15:36:52 <shapr> I'm tempted to keep coding...
15:36:54 <shapr> oh ok :-)
15:36:58 * shapr gives in so easily
15:37:03 <Marvin--> ;)
15:37:06 <esap> Heh, this weekend, there is a go tournament in Tampere, about 30 people or so there.
15:42:57 <esap> Hmm.. ok, here's a haskell question: Does everyone here also get the effect that you start to modify some piece of code and it might take very long time to get it to work [that is, a lot of dependencies]. What would be the best way to avoid unnecessary dependencies?
15:44:06 <tWip> not modifying it? ;)
15:44:39 <esap> heh, right. But it's not that easy if you want to do something new with it. Mostly I get this problem with algebraic datatypes.
15:45:00 <esap> I want to add a new alternative, and I need to change half of the program.
15:47:15 <tWip> I can't picture that kind of scenario... or I just don't get the question. Doesn't polymorphism help when adding new types.
15:47:44 <esap> well yes, to some extent it does.
15:49:27 <esap> But it's still not that easy. I have many interfaces in the system (which is actually a compiler). When I change the parse tree, most instances of those interfaces need to change.
15:51:38 <esap> What I have tried to do is to split the data structure to small parts. And it helps a bit, but the whole structure still seems too unstable.
15:53:10 <tWip> Change the parse tree meaning you're adding different types of elements under some branches?
15:53:57 <esap> yes, or change an existing type [due to found a problem with it]
15:55:14 <tWip> maybe there's no easy way around it... short of leaving types very generic.
15:55:32 <tWip> which might be a bit useless in a compiler
15:57:10 <esap> One of the thing I was able to do was I could write constructor and pattern matching functions to abstract more complex combinations of nodes of the parse tree.
15:58:15 <esap> then these would avoid some of the work. But even the instance declarations take too much time to change.
15:58:43 <tWip> there's no way to escape growing complexity... 
15:59:18 <esap> Heh, this thing is not even very complex, I'd say for what it intends to do.
16:00:20 <esap> My compiler has exactly 11 alternatives in its parse tree, and it can represent most of standard features of functional languages.
16:01:44 <tWip> nice talking, but the bed is beckoning me to sleep in it :)
16:02:16 <esap> :) yea, me too :-)
16:04:49 <shapr> suckage
16:35:21 * shapr decides to try Parsec first
16:40:16 <liiwi> shapr: the game?
16:40:25 <shapr> nah, RFC822 parser
16:40:46 <shapr> if you mean gtetrinet, there were some evil people on...
16:40:52 <shapr> marvin-- and I got creamed
16:41:07 <liiwi> naw, I've stayed away from tetrinet
16:41:12 <shapr> it's evil 
16:41:13 <shapr> but fun
16:56:15 <liiwi> shapr: dark & gf and part were here. We watched couple first parts of Lexx. Wish you and bea had been here too.
16:56:37 <shapr> sometime when we're in Helsinki :-)
16:56:42 <shapr> sounds like fun to me
16:56:54 * shapr tries to figure out how to use Parsec for larger things
17:01:34 * shapr tries to map parsec combinators onto bnf 
17:03:50 * shapr sees the glimmerings of understanding
17:08:19 <shapr> silly question... are there any parts of the standard GHC libs that can't be imported at the same time?
17:14:04 <liiwi> imported in roughly same sense as in perl or python?
17:14:59 <shapr> yup
17:15:16 <shapr> the emacs java dev environment has a neat feature, "find class"
17:15:42 <shapr> it starts up the beanshell, and looks in the classpath for that class
17:15:56 <shapr> I just realized that with the new info command, I can probably do the same with haskell-mode
17:16:22 <shapr> for some things at least
17:17:49 <shapr> oh, maybe that only works for the currently loaded file :-/
17:29:20 * shapr blinks wonderingly
17:41:54 <liiwi> spaces, namespaces, excutionspaces, paths, scopes
17:42:02 <shapr> wheee
17:42:09 <shapr> it's always so exciting
17:44:09 * shapr tries to remember how to construct a Record with some data already filled in....
17:47:21 <shapr> are records h98?
