01:47:51 <steele> g'morning
02:59:28 <shapr> good morning #haskell
02:59:40 <shapr> how's the code treating you?
03:00:47 <aquacable> anyone here able to help me?
03:01:10 <aquacable> I have a few tuples
03:01:20 <aquacable> and I want to merge the first to if they are the same
03:01:38 <aquacable> and go on from the newly generated tuple:rest of tuples
03:01:47 <aquacable> and if they weren't the same
03:02:09 <aquacable> I want x: merge y:xs
03:02:20 <aquacable> zetsamen :: [Regel] -> [Regel]
03:02:21 <aquacable> zetsamen [] = []
03:02:21 <aquacable> zetsamen (x:[]) = [x]
03:02:21 <aquacable> zetsamen (x:y:xs) = resultaat
03:02:21 <aquacable> 			where
03:02:21 <aquacable> 			zelfde = isZelfde x y
03:02:23 <aquacable> 			samen = if zelfde then (2001, (maand x), (project x), ((uren x) + (uren y))) else y
03:02:25 <aquacable> 			zetsamen (samen:xs) -- als zelfde
03:02:29 <aquacable> 			x:(zetsamen y:xs) --als niet zelfde
03:02:33 <aquacable> but I can't get the syntax right
03:03:02 <aquacable> :'(
03:03:06 <aquacable> guess everyone is asleep
03:03:10 * shapr awakens suddenly
03:03:32 * shapr look at the code
03:03:51 <shapr> um
03:03:53 <shapr> nub ?
03:04:11 <shapr> are you saying you want the same behaviour as the uniq program in unix?
03:04:26 <aquacable> I have no idea of what that does
03:04:30 <aquacable> but sounds good
03:04:32 * Jerub laughs
03:04:39 <aquacable> but I don't want completly unique
03:05:02 <shapr> g'mornin Jerub, wassup?
03:05:05 <aquacable> just year, project, _
03:05:14 <aquacable> hours don't have to be the same
03:05:28 <aquacable> that's how I merge
03:05:30 <aquacable> add hours
03:05:31 <shapr> aquacable: my dutch is microscopic, so I don't really understand what your code says.
03:05:39 <aquacable> hmm
03:05:47 <aquacable> I have a tuple
03:05:56 <aquacable> year, month, project, hours
03:05:58 <shapr> ok
03:05:59 <aquacable> year = int
03:06:03 <aquacable> month = int
03:06:04 <shapr> ohh I get
03:06:08 <aquacable> project = string
03:06:12 <aquacable> hours = int
03:06:23 <aquacable> now I have an array with tuples
03:06:28 <aquacable> x:y:xs
03:06:31 <aquacable> if x ==y
03:06:38 <aquacable> then merge x with y
03:06:45 <aquacable> and start over again
03:06:49 <aquacable> if x!=y
03:06:59 <aquacable> xkb: merge y:xs
03:07:20 <aquacable> that would be it roughly
03:07:34 <aquacable> but I have no idea of write more commands in a if
03:07:35 <Jerub> shapr: Whats up is I think my linux machine just shat itself.
03:07:37 <aquacable> only know
03:07:42 <shapr> Jerub: how so?
03:07:47 <aquacable> if boolean statement then other statment
03:07:48 <shapr> aquacable: so write ~= then
03:07:55 <aquacable> ~=?
03:07:55 <Jerub> shapr: I was going to ask you about if you knew any SQL/Haskell libs.
03:08:01 <aquacable> shapr: pls explain
03:08:03 <shapr> Jerub: only for win32 :-/
03:08:16 <shapr> Jerub: I've been pining for a postgresql Haskell binding
03:08:21 <shapr> very much want
03:08:58 <aquacable> shapr: what's ~=
03:09:05 <shapr> aquacable: write a function that takes two tuples, and returns a list of one tuple merged, or two tuples unmerged
03:09:15 <shapr> erm
03:09:17 <shapr> actually
03:09:35 <shapr> this sounds like a job for a parsing monad, you do monads?
03:10:07 <shapr> aquacable: so, what it sounds like to me is that you have a list of time spent on projects
03:10:09 <aquacable> nope
03:10:15 <aquacable> have no idea f what a monad is
03:10:23 <shapr> you want to merge the tuples if you can, for obvious reasons
03:10:26 <aquacable> shapr: exactly
03:10:33 <shapr> so you sort the list, and merge the ones that can be merged
03:10:37 <aquacable> yes
03:11:08 <aquacable> you're idea of writeing a function that returs a list of 1 or 2 tuples did me no good
03:11:11 <aquacable> I tried that
03:11:14 <aquacable> but it differs
03:11:15 <shapr> what happened?
03:11:27 <aquacable> merge x:y:xs
03:11:48 <shapr> what was the problem?
03:11:50 <aquacable> if x ==y
03:11:53 <aquacable> then
03:11:58 <aquacable> merge x y
03:12:04 <aquacable> oeps
03:12:05 <shapr> you need to write your own ==
03:12:05 <aquacable> wait
03:12:13 <aquacable> merge x : y : xs
03:12:16 <aquacable> if x ==y
03:12:23 <aquacable> then puttogether x y
03:12:33 <aquacable> merge the newly put together tuple
03:12:39 <aquacable> else
03:12:51 <aquacable> x : merge y:xs
03:13:08 <aquacable> with the function you want me to write I don't know if I should add the x in front
03:13:48 * shapr thinks carefully
03:14:04 <shapr> there's a cheesy way to do it
03:14:11 <shapr> but the real non-cheesy way is to use a parsing monad
03:14:15 <aquacable> shapr: but you understand what I mean?
03:14:19 <shapr> yes, I understand.
03:14:21 <aquacable> okay
03:14:27 <aquacable> do you wanna explain monads?
03:14:33 <aquacable> or do I have to read about it somewhere?
03:14:39 <shapr> I don't understand monads enough to explain them really
03:14:47 <shapr> I can kind of use them though
03:14:50 <aquacable> it will at least be a start
03:15:00 <shapr> well, here's the ugly way:
03:15:25 <shapr> grab two items, compare their project/month/etc but not hours parts
03:15:43 <aquacable> yes
03:15:48 <shapr> if the non-hour parts match, merge them, and put the merged result into a new list you're recursively building
03:15:49 <aquacable> function same at my code :)
03:15:58 <shapr> keep doing that
03:16:05 <aquacable> haha
03:16:09 <shapr> the reason it's ugly is that you can't merge three in a row
03:16:10 <aquacable> that would do it
03:16:18 <aquacable> that doesn't matter
03:16:22 <aquacable> at long as it gets done
03:16:31 <aquacable> it saves me lots of time
03:16:33 <shapr> you'd have to check if the list was changed each time through
03:16:44 <shapr> because if the list were changed, you'd need to go through it again
03:17:03 <aquacable> so how do I do that?
03:17:07 <shapr> even if the list weren't changed, you'd still need to go through the list again, starting with the second argument
03:17:24 <shapr> only then would you be sure you had everything merged
03:17:25 <aquacable> yes
03:17:27 <aquacable> I know
03:17:29 <aquacable> :)
03:17:47 <aquacable> nevermind I know :)
03:17:49 <aquacable> I think
03:17:51 <shapr> the reason monads are cool is that they can take the first two, try to merge them, and then *put them back* if they can't be merged
03:17:54 <aquacable> gonna try it again
03:18:02 <shapr> then you can skip the first item, and try it again.
03:18:03 <aquacable> aah
03:18:08 <shapr> parsing monads are awesome.
03:18:10 <aquacable> need to learn monads then
03:18:18 <shapr> yes, they're very powerful
03:18:57 <aquacable> I don't like this lang
03:19:00 <shapr> really?
03:19:01 <shapr> I love it
03:19:10 <aquacable> only reason I'm using it is stupid school want me to learn it
03:19:14 <aquacable> bleh
03:19:24 <lament> aquacable: what languages do you like?
03:19:24 <aquacable> you can make my projects over a few days :P
03:19:27 <aquacable> java
03:19:28 <aquacable> c
03:19:30 <shapr> aquacable: I promise you this, whether you like Haskell or not, it will improve your programming skill.
03:19:31 <aquacable> dunno
03:19:34 <lament> heh
03:19:35 <aquacable> stuff like that
03:19:47 <aquacable> shapr: how so?
03:19:51 * lament wonders what is there to like about Java and C
03:20:07 <shapr> because Haskell needs a different way of thinking if you want to write programs in it
03:20:12 <lament> aquacable: My guess is you only like them because you learned them first.
03:20:16 <shapr> and that way of thinking is sometimes the best way to do things in Java and C
03:20:24 <shapr> but you wouldn't know that unless you've used Haskell.
03:20:46 <shapr> I would say the same for Prolog
03:20:47 <aquacable> lament: I understand thenm
03:20:50 <aquacable> that's why I like them
03:20:58 <aquacable> I hate how this is layout sensative
03:21:01 <shapr> when you understand Haskell, you might like it also.
03:21:15 <shapr> Python is very much like Java, and is also layout sensitive
03:21:21 <aquacable> shapr: I liked prolog better than this
03:21:22 <lament> shapr: DIE
03:21:37 <shapr> lament: from the Haskell perspective, Python and Java are similar :-)
03:21:45 <Marvin--> The D language looks neat
03:21:56 <aquacable> lament: what does haskell teach me?
03:21:59 <aquacable> recursive writing??
03:22:05 <lament> shreya: from the haskell perspective, all other languages are similar :)
03:22:16 <lament> Marvin--: the D language looks like a load of crap
03:22:24 <lament> err, s/shreya/shapr
03:22:35 <shapr> aquacable: recursion is one tool, also higher order functions, and a few other tools
03:22:37 <lament> aquacable: Haskell teaches you _programming_, among other things
03:22:39 <Marvin--> lament: how so?
03:22:41 <shapr> such as referential transparency
03:22:48 <aquacable> lament: and c doesn't?
03:22:56 <lament> aquacable: By itself, not really.
03:22:59 <aquacable> refer what?
03:23:02 <shapr> aquacable: oh, I know a better solution
03:23:03 <lament> Marvin--: I don't see any reason for it to exist
03:23:13 <shapr> pattern matching can fix that problem I think
03:23:18 <aquacable> shapr: ?
03:23:32 <Jerub> further to our discussion about php the other day, referential transparency is on of the things sorely missing from most php code.
03:23:39 <ustenzel> Marvin--: D is useless, it's already there, under the name of Eiffel.
03:23:49 <Marvin--> ustenzel: okay, I haven't used Eiffel
03:23:51 <shapr> aquacable: I just realized there's a much simpler solution
03:23:57 <aquacable> shapr: aah okay
03:23:57 <lament> Right, except Eiffel doesn't try to look like C++
03:24:02 <Jerub> I've seen eiffel, didn't actually learn it.
03:24:03 <lament> Which makes it a better language overall :)
03:24:06 <Jerub> it looked like alot of work.
03:24:07 <aquacable> cause I can't tink of a way you just explained
03:24:15 <aquacable> the minute I'll say result = first awnser
03:24:23 <aquacable> then It wil stop the recursion...
03:24:32 <Marvin--> I don't mind the syntax, it's just...syntas
03:24:48 <lament> Marvin--: but things like *gasp* unions...
03:25:06 <shapr> aquacable: still processing
03:25:14 <aquacable> processing?
03:25:24 <shapr> the code bits are flying around in my head and rearranging themselves
03:25:31 * aquacable was thinking of using some tool to convert a c souorce code to haskell :P
03:25:34 <Marvin--> lament: what about them? probably left around for C programmers
03:25:35 <shapr> I know there's a better solution, but I need to work out the details
03:25:37 <aquacable> but that would be cheating :P
03:25:38 <lament> Marvin--: exactly
03:26:10 <lament> aquacable: You'd have to write such a tool
03:26:17 <lament> aquacable: Feel free to do it.
03:26:28 <aquacable> lament: I think I saw one in my ports collection
03:26:36 <Marvin--> Will compiled eiffel give me small enough binaries to write programs to go onto floppies? :)
03:26:50 <shapr> aquacable: merge (x:y:zs) if (fst canMerge ) then merge ((snd canMerge):zs) else merge y:zs
03:26:51 <shapr> aquacable: see?
03:27:01 <ustenzel> Marvin--: Maybe.  Would D?
03:27:07 <Marvin--> ustenzel: I don't know
03:27:10 <shapr> aquacable: that's a halfway to a monad by the way
03:27:11 <aquacable> Port:   hs-c2hs-0.10.17
03:27:11 <aquacable> Path:   /usr/ports/devel/hs-c2hs
03:27:11 <aquacable> Info:   C->Haskell, an Interface Generator for Haskell
03:27:32 * Marvin-- tries to find a Debian package for an eiffel implementation
03:27:41 <aquacable> shapr: hmm
03:27:46 <aquacable> looks good...
03:27:47 <shapr> aquacable: canMerge is a helper function that returns a tuple
03:27:52 <shapr> the first part of the tuple is a Bool
03:28:07 <shapr> the second part is .. I guess it's a list of [Project]
03:28:35 <shapr> zero length if the first part of the tuple is False
03:28:42 <shapr> one length if it's True
03:28:45 <shapr> make sense?
03:28:46 <aquacable> shapr: wait
03:28:51 <aquacable> this is actual source code?
03:28:58 <aquacable> fst exists?
03:29:08 <shapr> yah sure
03:29:20 <aquacable> ooh, okay...
03:29:31 <aquacable> and canmerge is an existing function?
03:29:32 <shapr> you need to stick head in there to get the Project out of the [Project]
03:29:36 <aquacable> or one I should create?
03:29:36 <shapr> no, I made that up
03:29:38 <shapr> you need to write it
03:29:48 <shapr> c'mon, you don't want me to do *all* of your homework ;-)
03:30:01 <aquacable> no
03:30:09 <aquacable> I'm just trying to understand what you wrote :)
03:30:17 <aquacable> don't want you to write the code :)
03:30:30 <shapr> what I wrote is about half the code I think
03:30:51 <aquacable> yeah I know
03:31:00 <aquacable> fst only works on tuples?
03:31:04 <shapr> yup
03:31:19 <shapr> head is for lists
03:31:29 <shapr> mainly because tuples are a type
03:31:30 <aquacable> cool
03:31:32 <aquacable> yeas
03:31:35 <aquacable> thought so :)
03:31:36 <shapr> and lists aren't
03:32:57 <aquacable> need to brain this out
03:33:05 * aquacable is a bit slow somethimes :P
03:33:35 <aquacable> hmm
03:33:43 <aquacable> I need to give parameters to canmerge :)
03:33:59 <aquacable> or wait
03:34:06 <aquacable> I'll me a tuple called canmerge :)
03:39:47 <aquacable> sh
03:39:49 <aquacable> shapr: 
03:39:56 <aquacable> I think I got it
03:40:09 <aquacable> zetsamen :: [Regel] -> [Regel]
03:40:09 <aquacable> zetsamen [] = []
03:40:09 <aquacable> zetsamen (x:[]) = [x]
03:40:09 <aquacable> zetsamen (x:y:xs) = resultaat
03:40:09 <aquacable> 			where
03:40:10 <aquacable> 			zelfde = isZelfde x y
03:40:12 <aquacable> 			samen = if zelfde then (2001, (maand x), (project x), ((uren x) + (uren y))) else y
03:40:14 <aquacable> 			canMerge = (zelfde, samen)
03:40:16 <aquacable> 			resultaat = if (fst canMerge ) then zetsamen ((snd canMerge):xs) else x:(zetsamen y:xs)
03:40:22 <aquacable> but I thikn I can leave out the else
03:40:54 <aquacable> and I can leave out the tuple like this
03:41:01 <aquacable> or am I making some think error?
03:43:40 <aquacable> shapr: ??
03:43:56 <aquacable> zetsamen :: [Regel] -> [Regel]
03:43:56 <aquacable> zetsamen [] = []
03:43:56 <aquacable> zetsamen (x:[]) = [x]
03:43:56 <aquacable> zetsamen (x:y:xs) = resultaat
03:43:56 <aquacable> 			where
03:43:57 <aquacable> 			zelfde = isZelfde x y
03:43:59 <aquacable> 			samen = if zelfde then (2001, (maand x), (project x), ((uren x) + (uren y)))
03:44:01 <aquacable> 			--canMerge = (zelfde, samen)
03:44:03 <aquacable> 			resultaat = if (zelfde) then zetsamen (samen:xs) else x:(zetsamen y:xs)
03:44:05 <aquacable> think this will do.
03:44:10 <aquacable> thanks for everything
03:48:56 <aquacable> ARGH
03:48:58 <shapr> er, sorry
03:48:58 <aquacable> layout error
03:49:00 <shapr> I was afk
03:49:04 <aquacable> no prob
03:49:07 <aquacable> see the cod eabove
03:49:12 <shapr> are you using vi or emacs to do your indentation?
03:49:19 <aquacable> kwrite
03:49:32 <shapr> does it have a haskell mode?
03:49:40 <aquacable> didn't see it
03:49:57 <aquacable> nope
03:50:01 <aquacable> no haskell mode
03:50:05 <shapr> in my opinion, you'll have very few layout problems if you use an editor that has intelligent indentation
03:50:08 <aquacable> does vi have one?
03:50:11 <shapr> I think so
03:50:19 <shapr> I'm an emacs users
03:50:19 <aquacable> how do I enable it :P
03:50:20 <shapr> user
03:50:23 <aquacable> bleh
03:50:24 <shapr> but several people here use vi
03:50:25 <aquacable> okay
03:50:34 <shapr> so they can help you (if they're here/awake)
03:50:54 <aquacable> shapr: nah
03:50:57 <aquacable> let me try emacs
03:51:00 <shapr> ok
03:51:46 <aquacable> (1) (error/warning) Error in `post-command-hook' (setting hook to nil): (void-variable imenu--index-alist
03:51:48 <aquacable> ??
03:52:02 <shapr> sounds like imenu is being pissy
03:52:07 <shapr> not sure why
03:52:21 <shapr> what linux distro, flavor and version of emacs are you using?
03:53:10 <aquacable> xemacs
03:53:19 <shapr> 21.4 ?
03:53:25 <aquacable> 21.1
03:53:28 <shapr> ok
03:53:33 <shapr> which linux?
03:54:05 <shapr> debian? suse? red hat?
03:54:07 <shapr> mandrake?
03:54:07 <aquacable> FreeBSD 4.7-STABLE
03:54:09 <shapr> ah
03:54:10 <shapr> I see
03:54:12 <aquacable> UNIX
03:54:15 <aquacable> sorry
03:54:22 <aquacable> I did a /exec uname -rs
03:54:25 <aquacable> forgot the -o
03:54:35 <shapr> Linux thunderbird 2.4.20 #1 SMP Sat Jan 4 03:20:10 CET 2003 i686 unknown unknown GNU/Linux
03:54:43 <aquacable> I did a /exec uname -a
03:54:49 <aquacable> FreeBSD CABLE.kvz.local 4.7-STABLE FreeBSD 4.7-STABLE #3: Thu Jan  9 11:44:47 CET 2003     root@:/usr/obj/usr/src/sys/MYKERNEL  i386
03:55:01 <aquacable> anyways
03:55:10 <shapr> yah, anyways
03:55:11 <aquacable> I tried tabbing again
03:55:13 <aquacable> same error
03:55:39 <shapr> the buffer is in haskell-mode ?
03:56:05 <shapr> oh, you may be able to fix that error by hitting M-x load-library <enter> imenu <enter>
03:56:16 <shapr> not sure about that though
03:56:36 <aquacable> can I dcc it to you
03:56:40 <aquacable> just look at the layout
03:56:52 <shapr> my irc client doesn't have dcc yet
03:56:58 <aquacable> bleh
03:57:00 <aquacable> hold on
03:57:01 <shapr> but if you put online somewhere I'll look at it
03:57:05 <shapr> I'm using ERC Version 3.0 $Revision: 1.357 $ with XEmacs 21.4 (patch 10) "Military Intelligence" XEmacs Lucid!
03:57:12 <shapr> my irc client is emacs :-)
03:57:21 <shapr> dcc support is working in gnu emacs, but not yet in xemacs
03:57:39 <aquacable> cable.its-s.tudelft.nl/~aquacable/opdr2.hs
03:58:20 * shapr pokes JerubBaal with some refentially transparent PHP source
03:58:23 <aquacable> shapr: do a view source
03:58:34 <shapr> aquacable: yah, I can drive a web browser ;-)
03:58:37 <aquacable> then  you 'll hopeflly see it in your own editor
03:58:46 <aquacable> with linenumbering :)
03:58:59 <aquacable> ERROR "./opdr2.hs":105 - Syntax error in expression (unexpected `;', possibly due to bad layou
03:59:15 <JerubBaal> shapr: its possible - but hard to convince php coders to do.
04:00:01 <shapr> truly
04:00:15 * shapr looks at the code
04:00:42 * aquacable still wonders what he's learning from haskell except how to get a headache from layout errors
04:01:26 <JerubBaal> aquacable: learning haskell was a very positive thing for my coding in other languages.
04:01:35 <shapr> well, one thing I'd suggest is incremental developement ;-)
04:01:47 <JerubBaal> it taught me alot about how good code should funktion
04:01:51 <shapr> as in, test one piece at a time
04:01:53 <shapr> heh, funktion
04:02:02 <aquacable> JerubBaal: I was taught hat too
04:02:03 <aquacable> in c
04:02:04 <aquacable> java
04:02:06 <aquacable> and stuff
04:02:09 <shapr> #haskell, we put the Funk in Funktion
04:02:39 <shapr> aquacable: there is still much further to go
04:03:00 <shapr> for everyone
04:03:12 <aquacable> yes I know I still have alot to learn
04:03:15 <shapr> me too!
04:03:23 <aquacable> but this is just not teaching me anything
04:03:30 <aquacable> I see it like learning another language
04:03:32 <shapr> it can teach you much, really
04:03:34 <aquacable> no other technices
04:03:39 <shapr> ok, open up ghci
04:03:40 <aquacable> just different way of writing stuff
04:03:47 <aquacable> ghci?
04:03:50 <JerubBaal> wow.
04:03:53 <aquacable> shapr: did you see the layout error?
04:04:00 <shapr> aquacable: yes, but I'm having trouble tracking it down
04:04:02 <JerubBaal> aquacable: don't the types give you wood?
04:04:12 <aquacable> wood?
04:04:23 <shapr> heh, that's a colloquialism for an erection ;-)
04:04:41 <aquacable> girls only give me a hard on if that's what you're asking :P
04:04:59 <aquacable> wait
04:05:02 <aquacable> that came out wrong
04:05:10 <aquacable> only girls give me a hard on
04:05:14 <shapr> aquacable: if I were you, I'd pull each of these "where" functions out into separate functions and test them
04:05:16 * JerubBaal loves types in haskell.
04:05:29 <shapr> figuratively speaking, I agree with JerubBaal
04:05:32 <aquacable> shapr: this is not a error, just a layout...
04:05:33 <aquacable> bleh
04:05:37 <shapr> literally, I agree with aquacable  :-)
04:05:44 * JerubBaal laughs
04:05:48 <pesco> Good day.
04:05:52 * pesco waves to shapr
04:05:53 <shapr> hi pesco!
04:05:54 <shapr> how was the party?
04:05:59 <pesco> Nice!
04:06:27 <JerubBaal> shapr: I finally managed to understand my lecturer's thesis!
04:06:34 <shapr> wow, cool! what's the thesis about?
04:07:14 <JerubBaal> shapr: through some very funky (and simple) monadic functions and such, he was able to do completely generic parsing. From an ambiguous grammar being able to parse a language without any further help.
04:07:19 <shapr> oh, I found it
04:07:28 <shapr> aquacable: if statement always has three parts
04:07:34 <aquacable> if else?
04:07:35 <shapr> if ... then ... else ...
04:07:37 <aquacable> aah
04:07:38 <aquacable> okay
04:07:58 <shapr> aquacable: if you still have it in emacs, hit C-c C-l in the buffer
04:08:07 <shapr> that should try to load that file into ghci (or hugs)
04:08:23 <shapr> if it doesn't do anything, hit M-x turn-on-haskell-ghci
04:08:26 <shapr> and then try it
04:08:46 <shapr> JerubBaal: wow, nifty
04:08:51 <aquacable> nah
04:08:51 <shapr> *and* you understand it!
04:08:54 <aquacable> I closed emacs
04:08:58 <shapr> oh, too bad :-)
04:09:03 <aquacable> it's NON-user friendly :)
04:09:16 <JerubBaal> shapr: well, I had help, and don't understand monads, but it was very very nifty.
04:09:27 <shapr> one nice feature about emacs is that I can hit C-c C-l and load a file into ghci or hugs immediately
04:09:36 <shapr> then I see typos etc right then
04:09:36 <JerubBaal> mmm
04:09:37 <JerubBaal> its nice.
04:09:47 <JerubBaal> like vim's quickfix.
04:09:49 <aquacable> ARGH
04:09:52 <aquacable> have an error
04:09:57 <shapr> if you read meijer's paper on monadic parsing, your life will be easier.
04:10:11 <shapr> monads are somehow obvious while reading that paper.
04:10:24 <aquacable> yay
04:10:31 <aquacable> error was no ()
04:10:32 <aquacable> bleh
04:11:25 <shapr> oh cool
04:11:33 <shapr> Haskell SQL stuff on the haskell mailing list
04:11:54 <pesco> shapr: Where do I go on the Web to learn Python?
04:12:03 <JerubBaal> shapr: Haskell SQL + Haskell CGI == Viable Haskell Web Applications
04:12:07 <shapr> truly
04:12:13 <shapr> Haskell CGI is already there
04:12:24 <shapr> Thiemann's WASH and Sjögren's HWS-WP
04:12:25 <JerubBaal> but its not viable.
04:12:26 * JerubBaal looked at it.
04:12:31 <JerubBaal> best I can do is cookies.
04:12:47 <shapr> I really like Sjögren's HWS-WP
04:12:52 <shapr> have you looked at it?
04:12:53 <JerubBaal> and flatfiles.
04:13:28 <shapr> Marvin--: any idea if HWS-WP will get further development?
04:13:31 * JerubBaal is getting good at google.com/search?q=searctherm while konq is slightly broken.
04:13:37 <JerubBaal> shapr: I'll google it and tell you.
04:13:47 <Heffalump> I think he said he probably wouldn't do any more
04:13:51 <shapr> url is in the topic
04:14:02 <shapr> oh, ok
04:15:08 <JerubBaal> shapr: can't find a url for Sj
04:15:10 <aquacable> wow
04:15:15 <aquacable> it works I think...
04:15:25 <aquacable> now to format the layout
04:16:29 <shapr> Jerub: Martin Sjögren, aka Marvin--
04:16:46 <shapr> http://www.dum.chalmers.se/~marvin/hws-wp/
04:17:59 <JerubBaal> right. I have seen it.
04:21:29 <aquacable> there is no such thing as a for loop right?
04:21:34 <shapr> sure there is
04:21:38 <shapr> recursion + if
04:21:39 <aquacable> in haskell?
04:21:51 <aquacable> I want to write a
04:21:53 <shapr> same thing
04:22:09 <aquacable> for(int =1;i<=12;i++){
04:22:23 <shapr> you can do that with a recursive function that uses if.
04:22:33 <aquacable> shapr: hmm?
04:22:39 <aquacable> ooh
04:22:43 <aquacable> I know what you mean :)
04:22:45 <aquacable> thanks
04:22:49 <shapr> sure
04:24:03 <Igloo> Well, I'd use pattern matching personally
04:24:28 <Igloo> Oh, I guess that depends on what exactly is inside the loop. But probably.
04:25:21 <aquacable> do you think the teachers will be mad if I just write it 12 times :P
04:25:29 <lament> Yes.
04:27:02 <aquacable> :)
04:27:11 <aquacable> *thinking*
04:30:41 <Igloo> Oh, there's nothing wrong with using if - if you understand that then do it that way  :-)
04:31:19 <aquacable> how does one compare?
04:31:34 <aquacable> if ((getmonth x) == 2)
04:31:37 <aquacable> does this work?
04:31:42 <aquacable> or do I write a function
04:31:43 <Igloo> Yes
04:31:46 <aquacable> isfeb
04:31:50 <aquacable> okay
04:33:30 <aquacable> and a enter = "\n" ??
04:34:31 <Igloo> Yeah
04:37:03 <Marvin--> shapr: I don't have the time. If you're interested, go ahead and mangle it anyway you like :)
04:44:00 <shapr> ok, thanks
04:50:19 <aquacable> DAMNIT!!!!
04:50:22 <aquacable> I feel stupid
04:50:24 <aquacable> argh
04:50:28 <aquacable> darn
04:51:11 <shapr> it takes time to work through it, but you can do ti
04:52:00 <aquacable> I know I can
04:52:06 <aquacable> I even know what I did wrong
04:52:08 <aquacable> but damn
04:52:10 <aquacable> bleh
04:52:17 <Igloo> :-)
04:52:34 <shapr> aquacable: see, your brain is in the right shape to think about C code
04:52:41 <shapr> but the right shape for Haskell code is a different shape
04:53:21 <aquacable> shapr: I see the reason why you took your nick :)
04:53:30 <aquacable> shapr: check the page :)
04:53:50 <shapr> er, interesting connection
04:53:54 <aquacable> I printed all of the month (first month)
04:53:56 <shapr> correct connection by the way
04:53:59 <shapr> I see things as shapes
04:54:06 <aquacable> correct connection?
04:54:06 <JerubBaal> bending of the mind is a common theme.
04:54:07 <aquacable> huh?
04:54:29 <shapr> yah, I have shapr as a nickname because I think of concepts as 3D shapes.
04:54:32 <JerubBaal> its why they teach maths to students. Not so they'll remember maths, so they can pick up what they need when they actually use it.
04:54:37 <aquacable> .me is starting to believe you guys watched to much matrix :)
04:54:52 <shapr> I got the nick shapr in 1991 or so
04:55:21 <shapr> http://sourceforge.net/projects/htoolkit/
04:55:29 <shapr> mysql, postgresql, etc at that SF project
04:55:30 <shapr> dunno if it works
05:01:15 <aquacable> argh
05:01:19 <aquacable> I'm going crazy
05:01:59 <JerubBaal> you are crazy
05:02:04 <aquacable> I need to drop the lines I already printed
05:02:11 <aquacable> hmmm
05:02:39 <aquacable> drop 2 [3..5] would this make [5]?
05:03:01 <Igloo> Yes (you can try such things in hugs/ghci)
05:13:40 <shapr> aquacable: yes, you must try hugs and ghci
05:14:25 <aquacable> hey
05:14:27 <aquacable> I'm done
05:14:32 <shapr> yay
05:14:40 <aquacable> but I still hae one prob
05:14:40 <shapr> now, wasn't that easier than you thought?
05:14:49 <aquacable> soem project names are longer than others
05:15:00 <aquacable> yeah, it's fairly easy
05:15:08 <aquacable> but not my fav way of writing stuff :P
05:15:13 <aquacable> anyways
05:15:22 <shapr> I found it difficult when I first started
05:15:33 <aquacable> how do I make a string of length 20
05:15:34 <shapr> but it has become my favorite way of doing things
05:15:40 <shapr> do you have hugs or ghci installed?
05:15:44 <aquacable> %cat uitvoer.txt
05:15:45 <aquacable> Juni 2001
05:15:45 <aquacable>   Multimedia            1
05:15:45 <aquacable>   Programmeeronderwijs          12
05:15:49 <aquacable> this is my output
05:15:53 <aquacable> I got hugs
05:16:04 <aquacable> anyways
05:16:13 <aquacable> can't I get the 1 a few tabs further?
05:16:17 <shapr> sure
05:16:20 <shapr> tell me how ;-)
05:16:23 <aquacable> I did 2 tabs after every name...
05:16:32 <aquacable> telll you how what?
05:16:34 <aquacable> yes
05:16:38 <aquacable> you can tell me how :)
05:16:43 <shapr> no, you tell me how :-)
05:17:00 <shapr> how would you do it in C?
05:17:13 <aquacable> stringbuffer in c
05:17:32 <shapr> but, how would you line up the numbers after project names of different lengths?
05:17:45 <aquacable> you write from back to fron
05:18:03 <aquacable> string s = "" + projectname
05:18:11 <aquacable> and then you can write from back to front
05:18:16 <Marvin--> that's not C :)
05:18:19 <aquacable> at least in java I could
05:18:23 <aquacable> bleh
05:18:25 <aquacable> I dunno
05:18:32 <aquacable> but something like that
05:18:51 <aquacable> and I think there was a overwrite the string at position n
05:19:04 <aquacable> "hi there"
05:19:14 <aquacable> and you could write from 4
05:19:17 <aquacable> hi
05:19:21 <aquacable> it would make
05:19:35 <aquacable> "hi thire
05:19:42 <aquacable> get it?
05:19:56 <aquacable> I think there was a function like that somewhere in some lang
05:20:10 <shapr> hey Arnia
05:20:14 <shapr> hi ustenzel
05:20:24 <Arnia> shapr: heya
05:20:28 <shapr> god moron Marvin-- ;-)
05:20:48 <Marvin--> who're you calling a moron? :)
05:20:57 <shapr> er, is that god morgon?
05:21:00 <Marvin--> yes
05:21:02 <shapr> whoops
05:21:04 <Marvin--> :)
05:21:13 <shapr> I always see "hello, my good moron"
05:21:20 <shapr> very confusing and amusing
05:21:28 <shapr> there's a brand of orange juice named that
05:21:45 * Arnia needs industrial strength caffeine
05:21:54 <shapr> Arnia: methylphenidate?
05:22:06 <Marvin--> in most dialects you don't pronounce the g, it sounds more like a double r, "morron" or even "morrn" skipping the o :)
05:22:06 <pesco> *G*
05:22:30 <andersca> shapr: haha
05:22:34 <andersca> shapr: I'm drinking that juice now
05:22:38 <Arnia> shapr: I was thinking something stronger
05:22:48 <shapr> stronger than methylphenidate??
05:22:53 <shapr> whoa
05:22:56 <Marvin--> eep
05:23:16 * shapr thinks
05:23:25 <shapr> dextroamphetamines are stronger.
05:23:46 <Arnia> shapr: I don't care about the paranoia. I know they're out to get me
05:23:57 <shapr> hahah
05:24:09 <aquacable> shapr: so any suggestions?
05:24:15 <shapr> aquacable: don't do amphetamines.
05:24:18 <shapr> oh, you mean about the code?
05:24:22 <aquacable> yes
05:24:41 <Arnia> I drink 6 litres of Diet Coke a day... I get fairly significant caffeine withdrawal symptoms
05:25:14 <Marvin--> "you'd also be paranoid if they were out to get you!"
05:25:35 <shapr> aquacable: find the max project name length, then "take (max + 1)" from this project name ++ an infinite list of spaces
05:25:59 <shapr> Arnia: dude, you should get tested for attention deficit disorder.
05:26:15 <shapr> seriously.
05:26:42 <Heffalump> you should just drink less caffeine :-)
05:26:44 <shapr> only people I know who drink that much caffeine get a "yes" on that test.
05:27:30 <Marvin--> 6 litres is quite..eh..a lot
05:27:40 <Arnia> shapr: What's the relation? I drink a lot of caffeine cos I like being able to keep on doing things... I drink much less when I'm at uni.
05:27:47 <Heffalump> I probably don't drink that much in a year
05:27:48 * Marvin-- doesn't drink coke at all
05:27:59 <Heffalump> (coke, that is)
05:28:05 <Marvin--> granted, I drink at least three cups of coffee a day
05:28:29 <shapr> Arnia: in my experience, most people can keep on doing things without caffeine.
05:29:00 <JerubBaal> Caffeine is generally something that can either be used, or used badly in my experience.
05:29:09 <JerubBaal> I view 6 litres of diet coke a day as 'used badly'
05:29:27 <shapr> Arnia: I could go into great detail... dunno how much info you want :-)
05:29:55 <Arnia> The water down in Bucks tastes like shit, I'm diabetic and need more fluids. I can't stand the water and I don't like squash, so what do I drink?
05:29:57 <JerubBaal> Limiting caffeine then using a significant (i.e. 1 can of coke) amount when you need it can have more dramatic effects than continual use.
05:30:14 <Igloo> Apple juice?
05:30:18 <Arnia> I don't want dramatic effects... I just want something to drink.
05:30:21 <Arnia> I'm diabetic
05:30:32 <Arnia> Apple juice would be a bad idea...
05:30:37 <JerubBaal> continual use often leads to the adrenal gland being overworked, making it practically ineffective.
05:30:40 <Igloo> Oh, OK
05:31:14 <Marvin--> mineral water?
05:31:43 <shapr> Arnia: well, think about what I said. http://c2.com/cgi-bin/wiki?AttentionDeficitDisorder
05:32:30 <Arnia> shapr: Hmm
05:33:08 <shapr> note that I wrote a significant portion of that page, so it's biased viewpoint ;-)
05:33:13 <Arnia> What's the point? I like how I think, I actually come up with things
05:33:55 <shapr> yah, I agree.
05:34:02 <Arnia> shapr: I have temporal lobe epilepsy too which can give a similar sort of randomness.
05:34:12 <Arnia> I'm happy who I am ;)
05:34:15 <shapr> interesting
05:34:28 <Janni> hi
05:34:31 <Arnia> Hiya
05:34:32 <shapr> I've often suspected some sort of connection or anti-connection betwen epilepsy and ADD
05:34:34 <shapr> hi Janni
05:35:12 <Arnia> shapr: But I refuse to take any drugs cos they all have terrible side-effects for me that are worse than the occasional absences or deja vu that are my symptoms
05:35:32 <shapr> caffeine is a drug.
05:36:13 <Arnia> shapr: I mean epilepsy drugs... they're awful and I know how useless they are
05:36:46 <shapr> petit mal abscences aren't really a problem
05:36:50 <shapr> grand mal seizures are
05:36:52 <Arnia> shapr: One of them, when I took it, removed my ability to understand language and made me angry and impulsive
05:36:56 <shapr> yikes
05:37:01 <shapr> very scary
05:37:50 <shapr> I took Paxil for awhile, didn't like it much.
05:37:54 <Arnia> Yes. After that I refuse to even see a doctor. I prefer the absences (which are really just me coasting into my own head and thoughts) to the side-effects
05:38:07 <Arnia> Prozac and Seroxat are the drugs of hell :(
05:38:18 * shapr tries to dodge the european "americans take too many drugs" stereotype
05:38:39 <Janni> Arnia: what is this deja vu symptom you have. is it like you think a scene already happened before?
05:39:23 <shapr> is there already an MS Excel style CSV parser for Haskell somewhere?
05:39:37 <Arnia> Janni: Yes, only its more than that. Its a feeling that you can remember what is GOING to happen. Its very scary and I generally go and sit down when that happens.
05:39:38 <shapr> shouldn't be too hard to put one together, just wondered if something already exists.
05:40:11 <Janni> Arnia: somehow i know that feeling. but it's very rare (once in two months) but i find it quite fascinating :)
05:40:12 <aquacable> +
05:40:16 <shapr> aquacable: -
05:40:21 <aquacable> oeps
05:40:28 <Arnia> Janni: Both symptoms are caused by information overload on the three channels between the two hemispheres.
05:40:33 <Janni> but i guess thats normal if its not exessive (as with you perhaps)
05:41:03 <Janni> "thre channels between the two hemispheres". don't know what that should be...
05:41:18 <shapr> corpus collosum(sp?)
05:41:29 <shapr> the part that joins the two halves of the brain
05:41:37 <Janni> ah ok.
05:41:44 <Janni> hemispheres in that context...
05:41:44 <Arnia> Janni: You have two hemispheres in the brain, left and right, and they are linked by the corpus callosum which has three channels (one large, two smaller).
05:41:55 <Janni> ok
05:42:15 * shapr wonders which half of his brain does Haskell
05:42:21 <Heffalump> the big one
05:42:23 <Heffalump> clearly
05:42:39 <Janni> Arnia: i think everybody has this deja vu experinces from time to time. is this always a result of this overload?
05:42:41 <shapr> sometimes I look at my code and think it must be the small half ;-)
05:43:52 <Arnia> Janni: Yes. Its caused when a memory track is laid down in both halves of the brain (as usual) only out of sync so one track is laid down slightly earlier (perhaps due to extra processing, or due to the syncronisation signal between the two halves being lost)
05:44:31 <Janni> and how often does that happen to you?
05:44:34 <shapr> aha, csv parser http://www.xoltar.org/
05:45:13 <shapr> sounds like cache coherency error in SMP
05:45:17 <Arnia> Janni: Once a month or so... generally accompanied by a bit of dizziness
05:47:35 <Janni> Arnia: i'm interested, because I have this too. (maybo once a month also) but i regard it as an interesting experinence every time. i have the feeling i can look about one or two seconds into the future for about 5 seconds. i could think of it as a fearful experince if it is more extreme...
05:48:15 <Janni> by thinking of it. its not one or two seconds but only about 1/2 to 1 second...
05:48:22 <aquacable> hey
05:48:27 <shapr> hi
05:48:31 <Janni> hello
05:48:36 * shapr grins
05:48:40 <aquacable> what does data (ord a, eq b) => Tabel a b mean???
05:48:46 <aquacable> ord = Ord
05:48:46 <shapr> oh no! not that!
05:48:54 <shapr> er
05:49:05 <shapr> actually it means that a has to be an instance of the typeclass Ord
05:49:14 <shapr> and that b has to be an instance of the typeclass Eq
05:49:23 <aquacable> okay
05:49:43 <shapr> you know about typeclasses?
05:51:01 <shapr> cute: http://www.xoltar.org/languages/haskell/skinning_haskell.html
06:01:34 <Janni> is there a way to define a character set datatype in haskell?
06:02:01 <Janni> or is everything iso-8859-1?
06:02:21 <shapr> Unicode is part of the standard... sort of
06:02:34 <shapr> there's a big discussion about that, even a Unicode mailing list
06:03:02 <Arnia> There is ALWAYS a unicode mailing list
06:03:33 <Janni> shapr: ok. but i want to fullfill a specification, which defines data transfer with a special charset. and a character set datatype was practical...
06:04:09 <shapr> I don't think there's a predefined charset datatype.
06:04:17 <shapr> I haven't heard of it, at least.
06:04:33 <shapr> Arnia: sorry to bug you so often... but.. do you know when the plone site will be up?
06:04:37 * shapr bounces
06:04:43 <shapr> I'm looking forward to that.
06:04:44 <Janni> shapr: i know there isn't one. i'm thinking of creating one, but i think it isn't possible
06:05:12 <shapr> why not?
06:05:20 <Arnia> shapr: I can create a default skinned, undomained one now if you want
06:05:38 <shapr> sure!
06:05:47 <Janni> shapr: how would you define it? data myCharSet = 'a' | .. | 'z' doesn't work
06:05:49 <Arnia> But I think I'll wait until tommorrow when I'm back in Durham on my own computer and have created a skin ;)
06:05:56 <shapr> Arnia: ok, sounds good.
06:06:09 <shapr> swedish classes start again tomorrow...
06:06:22 <Janni> i think i'll create an alias for string and when converting from real string to that datatype i'll do the error checking / converting...
06:07:41 <Marvin--> shapr: having fun? :)
06:07:50 <shapr> yup
06:08:01 <shapr> swedish is very much easier than finnish.
06:08:15 <shapr> to the point that I can watch swedish kids shows and get most of the jokes.
06:08:21 <Janni> really? i i thought it was almost the same...
06:08:46 <shapr> finnish is somewhat related to estonian, and they're both distantly related to hungarian
06:09:12 <shapr> swedish is a lot like a mix of dutch and german with some anglosaxon sprinkles. (just my opinion)
06:09:59 <Marvin--> Janni: quite different branches
06:10:30 <shapr> jag är i bast - I'm in the sauna
06:10:41 <shapr> minä olen saunassa - I'm in the sauna - finnish
06:10:44 <Marvin--> Swedish is germanian... Now I can't remember the branch that Finnish belongs to
06:10:48 <Marvin--> shapr: bastun
06:10:49 <shapr> finno-ugric
06:10:54 <shapr> oh, right bastun
06:11:38 <shapr> makkarani paistettu saunassa - my sausage roasts in the sauna - finnish
06:11:47 * shapr doesn't remember the swedish word for sausage
06:12:26 <JerubBaal> you could rpobably pick it up from the chef on the muppets
06:12:29 <shapr> heh
06:12:35 <shapr> export LOCALE=se_CHEF
06:12:52 <Marvin--> *sv*
06:12:55 <shapr> swedish really did sound like that when I was living in Finland.
06:12:57 <shapr> oh, right
06:13:01 <Marvin--> se is same
06:13:14 <Marvin--> er, now I don't remember what it's called in English, samish perhaps :)(
06:13:14 <shapr> nowadays finnish sounds like a bored college professor's monotone.
06:13:25 <shapr> it's weird how viewpoints change.
06:13:57 <shapr> I really enjoy swedish.
06:14:19 <Marvin--> well, the way the Chef talks isn't all that far from the dialect of the poor guy who the Chef mocks :)
06:14:27 <shapr> which dialect is that?
06:14:42 <Marvin--> I don't recall, somewhere in Dalarna I think
06:15:30 * shapr suddenly wishes he kept code and/or specification docs in CVS alongside the code he writes
06:16:22 <JerubBaal> shapr: mm - that same call has *almost* driven me to dig up noweb
06:16:36 <shapr> what's noweb?
06:17:16 <JerubBaal> shapr: I'm planning to go along a bit of an eXtreme Programming approach, numbering user stories/tasks/tests and putting them in my comments.
06:17:25 <shapr> spiffy idea
06:17:27 <JerubBaal> noweb == literate programming utility.
06:17:45 * Marvin-- specializes in illiterate programming
06:17:48 <JerubBaal> allows you to have documentation and code in the same place.
06:17:48 <shapr> I've been trying to persuade the emacs-wiki.el maintainer to turn it into an emacs minor mode
06:17:58 <JerubBaal> compile it once, creates source, compile it again, creates documentation with code inset.
06:18:14 <JerubBaal> uses HTML or LaTeX
06:18:43 <shapr> I haven't tried the Haskell LaTeX literate stuff. I do like the bird track literate stuff.
06:19:19 <Arnia> Once I've written it, CurriedFunk will have a copy of my XP project management system
06:19:42 <shapr> cool!
06:19:50 * shapr likes XP
06:20:02 <Janni> i'm a fan of self explaining code (whenever it works)
06:20:24 <Janni> but often results in long function names
06:20:33 <Arnia> You'll love this system then. It really benefits from using Plone. Its just taking time to write and uni work has priority
06:21:32 <shapr> M-/ is good for long names
06:39:57 <Janni> corecod: i like them raw :)
06:40:10 <Janni> sorry
06:40:32 <Janni> wrong channel, again...
06:41:18 <JerubBaal> Janni: Self explaining code rocks.
06:42:19 <Janni> JorubBaal: i got the approach from a style guide for the OOP language Eiffel and used it with Eiffel
06:42:41 * JerubBaal hates code where the comments obscure meaning.
06:43:16 <Janni> JerubBaal: often the comments are just superfluous
06:43:54 * Janni is looking for that style guid (it's really good, also not for Eiffel programmers)
06:44:26 <Janni> btw: Eiffel should be first choice for imperative OOP (besides Ada)
06:45:00 <Janni> but i don't like Ada so much
06:48:54 <Janni> s/also not/not only (tsss...)
06:55:17 <Janni> if someone's interested: http://archive.eiffel.com/doc/manuals/language/style/style.pdf
06:56:07 <shapr> <Erwin>  "All power is derived from the barrel of a Gnu."
06:56:07 <shapr> <Erwin>                  - Mao Tse Stallman
06:56:10 <shapr> just seen on #emacs
06:59:14 <Arnia> lol :)
07:09:57 <Heffalump> lol
07:35:55 <shapr> hi cinema
07:36:05 <shapr> bonjour
07:36:28 <cinema> bonjour shapr
07:36:36 <shapr> comment ça va?
07:37:28 <shapr> cinema: are you learning Haskell?
07:37:29 <cinema> J'avance très lentement en Haskell, mais dans la bonne direction
07:37:38 <shapr> je suis d'accord :-)
07:37:42 <cinema> yes, slowly but surely
07:38:08 <shapr> do you have any questions?
07:38:29 <cinema> I begun writing an Haskell interface to Berkeley DB
07:38:41 <shapr> oh neat
07:39:13 <cinema> In fact I'd like to use Berkely DB as a way to store persistent Haskell objects
07:39:28 <shapr> sounds good.
07:40:16 <cinema> But serialising Haskell objects is not really widely used, and does ,not seem to be part of the libraries
07:41:05 <shapr> you could define a new typeclass
07:41:40 <cinema> Probably the best way to do so
07:41:49 <shapr> also
07:42:07 <shapr> you may be able to have a standard way of deriving that new typeclass with Template Haskell
07:42:20 <ustenzel> cinema: i tried that, too.  and indeed serialization was the point where i got stuck.
07:42:20 <ustenzel> there is a binary library for NHC; NHC even derives the binary instance.
07:42:29 <ustenzel> i hear it has been ported to ghc (without the derivation, of course).
07:42:55 <Igloo> What do you mean by "object"?
07:42:57 <cinema> I've seen a paper by Malcolm Wallace on this
07:43:32 <cinema> Sorry I didn't mean object, but data type
07:44:12 <Igloo> Is it something you can derive Read and Show on?
07:44:24 <cinema> I'd be happy to learn and use Template Haskell. I'm not sure it is so easy, though
07:45:16 <cinema> Igloo, the idea is really to extend Show and Read to something more time and space efficient
07:45:39 <cinema> This exists natively in Java
07:46:33 <Igloo> Oh, well TH would allow you to write the code once you had decided on an encoding
07:47:37 <cinema> so I'll have to 1) write the code for a case 2) leran TH and use it to genralize the code
07:48:16 <cinema> seems boredom is far from me for numerous months...
07:48:19 <Igloo> First you need to decide no an encoding
07:49:17 <cinema> yes. And probably find a good example (several different datatypes with dependencies betweend them)
07:49:31 <Igloo> Will you assume Int is 32 bit?
07:50:16 <cinema> well, to begin, Int = 32 bits seems a good assumption to me
07:51:40 <ustenzel> Bad assumption... Int32 is 32 bits, Int is at least 30 bits, probably much more.
07:51:59 <Igloo> 29 IIRC
07:52:24 <Igloo> And it is generally 32
07:52:56 <ustenzel> Might be.  But i guess, implementations with 64bits per int are not that far away.
07:53:12 <cinema> well 64 bits is 'long long' in C, and not that easy to use
07:54:19 <ustenzel> no, long long in C99 is at least 64 bits.
07:55:37 <cinema> It's true I'm working on Linux x86 and there are other platforms. But let's keep the problem simple
07:56:58 <ustenzel> and the solution unportable.  your choice :)
07:57:41 <ustenzel> you could use a universal encoding, like XDR or PER for ASN.1
07:57:50 <ustenzel> or use the fixed-width integers.
07:58:02 <cinema> OK, I'll go in the process of learning TH. By thes time, every computer will probably be 64 bits
07:58:40 <cinema> What is XDR & PER ? seems interesting
07:58:46 <Igloo> It needs to cope with any H98 datatype
07:58:51 <Igloo> (ultimately)
07:59:35 <ustenzel> XDR is eXternal Data Representation, the encoding uses by corba.  doesn't have an arbitrary large integer, but has sequences of arbitrary length.
08:00:40 <ustenzel> ASN.1 is the abstract syntax notation used for the OSI protocol family, which PER is a compact encoding for.  ASN.1 provides something like Integer in Haskell.
08:01:06 <cinema> Thanks ustenzel. I'll have to look at that
08:01:18 <Marvin--> I thought it was DER?
08:01:36 <Marvin--> I've seen DER mentioned a zillion times in my journeys into OpenSSL land
08:03:30 <ustenzel> the first encoding was BER (basic).  BER gives the encoder some freedom, making it unsuitable for cryptography.  So DER (distinguished) was defined, where any structure has exactly one code.
08:03:56 <ustenzel> PER came later, it omits some information that can be inferred, making it more compact and less robust.
08:04:25 <Marvin--> oh
08:28:52 <doido> 4DusK 2001 EclypsE+ 12[Win32] [mIRC 5.91]
10:08:13 <Janni> hi
10:08:45 <Janni> hi
10:09:08 <Marvin--> 2xhi to you too
11:05:02 <dmakalsky> Hi Everyone
11:05:20 <dmakalsky> I usually hang out in #eiffel
11:05:44 <dmakalsky> and I was wondering if you can tell me more about haskell
11:05:50 <dmakalsky> Is it at all similar to eiffel?
11:11:13 <Janni> dmakalsky: hey, you just found the perfect guy to talk about it. my first to languages are Haskell and Eiffel :)
11:11:43 <Janni> dmakalsky: to disappoint you at first: they are not a bit similar
11:12:49 <Janni> as haskell is my favour functional language, Eiffel is my favourite under the imperative OO languages
11:18:08 <dmakalsky> oh, so haskell is lispish?
11:18:42 * Arnia spits in the general direction of lisp ;)
11:19:31 <dmakalsky> hey, sorry
11:19:38 <dmakalsky> I don't want to start any battles!
11:19:47 <dmakalsky> I am just ignorant of haskell
11:20:25 <Arnia> Np... its just something I feel compelled to do now ;)
11:20:59 <Janni> dmakalsky: it's functional. you must/may program in a complete different/{more productive}/{more abstract} way
11:21:24 <dmakalsky> interesting...
11:22:21 <Arnia> I'd say its less abstract... your program can be closer to the problem domain
11:22:27 <Janni> if you want to learn it (i recommend to learn s.th. about FP (and i'd take haskell)): http://www.cs.ou.edu/cs1323h/textbook/haskell.shtml
11:22:39 <dmakalsky> I have always preferred imperative languages, especially eiffel due to the fact that I prefer having the compiler catch most errors rather than a debugger
11:23:14 <whee> the compilers of functional languages typically catch much more than others
11:23:28 <dmakalsky> are there any good IDEs for haskell?
11:23:35 <dmakalsky> whee: how do you figure?
11:24:00 <Arnia> dmakalsky: the type system is wonderful :)
11:24:03 * Janni wonders why everybody asks about IDEs at first
11:24:05 <whee> the type systems are usually more advanced, so the compiler would get all of those
11:24:21 <dmakalsky> Janni: I am building IDEs... that's why :P
11:24:58 <Janni> well, i don't know, i hate IDEs and GUI-creating
11:26:14 <Janni> i love vim and algorithms :)
11:26:36 <dmakalsky> I see
11:26:46 <Arnia> Shall we quote a quicksort?
11:26:54 <Janni> yea, do it?
11:26:54 <dmakalsky> go for it
11:27:00 <Janni> s/?//
11:27:15 <Arnia> qsort :: [a] -> [a]
11:27:15 * whee gets a mop
11:27:22 <Arnia> qsort [] = []
11:27:40 <Arnia> qsort (x:xs) = qsort lt_x ++ [x] ++ qsort gt_x
11:27:55 <Janni> dmakalsky: waiting for more? :)
11:28:03 <Arnia>     where lt_x = [ y | y <- xs, y < x]
11:28:23 <Arnia>          gt_x = [ y | y <- xs, y >= x]
11:28:34 <Arnia> And that's it
11:29:23 <dmakalsky> interesting, but I need to figure out the syntax
11:29:49 <Janni> dkf: the first line (type signature) can even be deleted. the compiler/interpreter can guess the most general possible type be itself
11:30:05 <Janni> by itself
11:32:23 <dmakalsky> well thanks for piquing my interest in haskell
11:32:36 <dmakalsky> I will check it out further ... I bookmarked the URL
11:32:46 <dmakalsky> and I will be back to bug you all later
15:03:32 <lebowski> any of you lot here use isabelle/hol?
15:03:41 <lebowski> I know that's slightly off topic, but worth a shot
15:03:52 <Heffalump> I've used it briefly, but I doubt I can help with anything.
16:49:59 <kunphuzil> inkedmn: i have dialup earthlink too.. does it suck at that end as well?
16:50:20 <inkedmn> actually, it's not bad here
16:50:47 <inkedmn> i generally get between 48-50kb/s, and i stay connected for several hours most of the time
16:50:50 <inkedmn> usually without interruption
16:51:00 <kunphuzil> a lot of times my modem appears to be connected, but no activity
16:51:21 <kunphuzil> how do you get so much? you are dialup?
16:51:40 <kunphuzil> i get 5kb/s
16:52:38 <inkedmn> i get 48-50 kiloBITS per second :)
16:52:47 <inkedmn> my dl speed is usually about 4-4.5kb/s
16:52:55 <inkedmn> sorry for the confusion :)
16:53:15 <kunphuzil> oh, i see. ok
16:53:56 <kunphuzil> i am switching to cable modem on tuesday :)
16:55:34 <inkedmn> yeah, we're getting cable her soon, not sure exactly when
16:55:42 <inkedmn> but the wife said i could get it, so i'm getting it :)
16:56:15 <kunphuzil> hehe
16:57:58 <inkedmn> man, i'm seriously turning into a chess addict
16:58:07 <inkedmn> been playing every night for the past week
16:58:33 * Heffalump is still vaguely up for a game if you want
16:59:00 <inkedmn> definitely :)
16:59:15 <inkedmn> www.gameknot.com is where i've been playing
17:00:19 * Heffalump registers for an account
17:00:57 <Heffalump> ok, I'm eleganesh
17:01:14 <Heffalump> let me know what to do next :-)
17:01:16 <inkedmn> ok, i'll challenge you
17:02:00 <inkedmn> you want white or black?
17:02:07 <Heffalump> don't mind. How good are you? :-)
17:02:18 <inkedmn> well, i'm 1-13-1 :)
17:02:28 <Heffalump> wins-draws-losses?
17:02:29 <inkedmn> wins-losses-draws
17:02:39 <Heffalump> ah.
17:02:49 <Heffalump> I'll be black then :-)
17:02:51 <inkedmn> so, i'm pretty new at it, you'll probably hand me my own ass before it's all over :)
17:02:52 <inkedmn> ok
17:02:56 <Heffalump> it's ages since I've played though
17:03:04 <Igloo> Is it possible for me to watch?
17:03:07 <Heffalump> and I've never been particularly good, but I'm not horribly bad either
17:03:41 <inkedmn> Igloo: yes, i'll link you in a sec
17:03:41 * Heffalump accepts the challenge
17:03:53 <inkedmn> Igloo: http://gameknot.com/chess.pl?bd=552545
17:04:06 <kunphuzil> Has anyone ever played "Hounding the Fox" ?
17:04:10 <Heffalump> will it automatically refresh?
17:04:14 <inkedmn> no
17:04:42 <kunphuzil> Hounding the Fox is cool and simple (also played fast, so real fun) game
17:04:43 <inkedmn> after you move, it will take you back to "My Games" or, if it's your turn in another game, it will take you there
17:04:55 <Heffalump> right, yes
17:05:23 <Igloo> Hmmm, I want a "see next move" link really
17:05:30 <Igloo> That I could just reload if there wasn't one yet
17:06:25 <Igloo> Is 3 days per move the maximum allowed?
17:06:29 <Heffalump> I think so, yes
17:06:36 <inkedmn> no
17:06:40 <Heffalump> oh
17:06:42 <kunphuzil> wow, that is a lot of time
17:06:42 <inkedmn> you can have up to 14 days per move
17:06:47 <kunphuzil> !!!
17:06:51 <inkedmn> heh, yeah
17:07:08 <inkedmn> i usually play a game until it's over (unless i have to work/leave)
17:10:37 <Igloo> Ah, the analyze mode refreshes sensibly, although it jumps to the current position
17:11:13 <inkedmn> the "wait your turn" function is pretty cool, pops up the main window when it's your turn in any of your games
17:12:02 <inkedmn> my one and only draw was last night, it was a heartbreaker, to be sure
17:12:08 <inkedmn> almost hit the 50 move rule
17:12:46 <inkedmn> i was lucky to pull off a stalemate
17:12:54 <Heffalump> 50 move rule is a draw too though
17:15:12 <inkedmn> i know, i was just pointing out that the game was REALLY long :)
17:15:18 <Heffalump> right :-)
17:22:52 <Igloo> Was anyone else really disappointed to see the white bishop go below the board not above it?
17:23:08 <Heffalump> why?
17:23:51 <Igloo> Well, you put the pieces you take at your end of the board
17:24:15 <inkedmn> if it were that way, i think it would require more scrolling...
17:24:33 <Heffalump> oh, true
17:24:50 <Igloo> Ah, all fits in my window here
17:47:39 <Heffalump> inkedmn: sorry :-)
17:48:12 <inkedmn> WOW
17:48:25 <inkedmn> VERY nice job, my friend :)
17:48:37 <Heffalump> you kind of walked right into that checkmate
17:48:54 <inkedmn> newbies have a tendency to do that :)
17:49:28 <Heffalump> you need to think more carefully about what your opponent's moves are aimed at
17:49:40 <Heffalump> (and be careful about exposing pieces like you did with your knight)
17:52:49 <inkedmn> told you you'd hand me my ass :)
17:55:47 <Heffalump> well, the quick checkmate was convenient for me, but once you went two pieces down you were basically finished unless I did something stupid
19:01:45 <Jerub> I want to scream.
19:01:59 <Jerub> I'm a computer scientist trapped in a web monkey's body :(
19:02:21 <Heffalump> do your web monkeying in Haskell
19:02:21 <Igloo> :-(
19:03:07 <Igloo> Doe anyone know of a natural semantics for Haskell?
19:06:00 <emu> a natural semantics?
19:07:48 <Igloo> Ermmm, formal description of the language, basically
19:09:45 <emu> try the standard?
19:11:08 <Igloo> Natural semantics are a specific form of formal description, and teh standard is a lot less formal
19:11:43 <emu> hrm
19:11:47 <emu> was just a guess on my part
19:12:21 <emu> if there exists such a thing, then it should be linked from haskell.org
19:12:27 <emu> much like SML has a link to a book
19:16:57 <Jerub> Heffalump: I want to, I really want to.
19:17:10 <Jerub> Heffalump: I need good apache/linux/mysql intergration first.
19:17:23 <Jerub> shapr gave me a url the other night that might provide what I want - so I'll see.
19:18:27 <Pseudonym> Igloo: The place to start is the Peyton Jones "Implementation of Functional Programming Languages" book.
19:18:41 <Pseudonym> It's not Haskell, but it has lots of denotational semantics in it.
19:19:14 <Pseudonym> I think the problem is that Haskell is deliberately under-specified in the operational semantics department.
19:19:28 * Jerub laughs
19:19:42 <Jerub> Pseudonym: I'd tend to agree with you.
19:19:47 <Igloo> I don't think I want denotational semantics
19:20:56 * Igloo wonders how much of the type system I can brush under the carpet
19:21:45 <Pseudonym> Oh, the static semantics are well-defined.
19:22:06 <Pseudonym> But if you want to stick with vanilla H98, you can avoid a lot of the awkward squad.
19:22:16 * Arnia loves typesystems
19:23:04 <Jerub> mmmtypes.
19:23:30 <Igloo> Well, I will possibly be heading somewhere resembling a dynamically typed Haskell
19:23:41 <Jerub> My dream language is haskell types, pythonesque programming with relational operations as part of the language.
19:23:51 * Arnia blink *does not compute*
19:24:20 <Igloo> Or statically typed on demand, maybe
19:24:20 <Pseudonym> So you want something like Goedel.
19:24:26 <Arnia> Why would you want dynamic types? The HM typesystem catches so many bugs and allows reasoning
19:24:38 <Jerub> I see no reason for dynamic types.
19:24:39 * Igloo tries to think if that is any different
19:24:58 <Jerub> Eq a => a -> a makes so much sense!
19:25:05 <Pseudonym> Logic language (so you have a deductive database query language for free), H-M types, but impure so you get imperative programming too.
19:25:28 <Igloo> Arnia: Thinking about the gradual production of code with TH
19:25:53 <Arnia> Jerub: Types are contracts. The compiler can catch breakings of the contract
19:25:59 <Arnia> Igloo: TH?
19:26:03 <Igloo> Template Haskell
19:26:10 <Pseudonym> Arnia: It's rare, but in any nontrivial program, using any decent type system, you occasionally want to break it.
19:26:20 * Igloo realises another bug in my thought processes - bother
19:26:21 <Pseudonym> Haskell's Dynamic type does pretty much what I want.
19:27:20 <Igloo> Right, time for bed
19:27:41 <Pseudonym> Night.
19:28:02 <Igloo> g'night
19:30:21 <emu> Igloo: you might want to take a look at Dylan
19:31:30 <emu> Arnia: contracts can be a drag ;)
19:32:05 <Arnia> I like em... keeps me sane. Less to worry about.
19:35:09 <Jerub> if you think contracts are a drag, walk in my shoes for a while.
19:35:19 <Jerub> php is dynamically, loosely typed.
19:35:25 <emu> php is just shit ;)
19:35:35 <emu> i wouldn't use it to compare
19:35:37 <Pseudonym> PHP isn't a real language.
19:35:52 <Pseudonym> It's Turing-complete, but then so is csh.
19:36:08 <Jerub> I know, which is why I'm so interested in haskell+apache.
19:36:24 <emu> just cuz php is shit doesn't mean that dynamic typing is shit
19:36:29 <Pseudonym> True.
19:36:36 <Pseudonym> Perl and Python are both fine scripting languages.
19:36:42 <emu> and pretty shitty too
19:36:45 <Arnia> emu: I just don't see why people get so hyped about dynamic typing
19:36:49 <Arnia> emu: I like python...
19:36:51 <Pseudonym> emu: They're better than PHP.
19:36:56 <emu> if all you use is perl and python, I can understand why you wouldn't see it
19:37:01 <Jerub> Pseudonym: perl doesn't even have a grammer. I refuse to call it a language.
19:37:14 <Pseudonym> Jerub: English doesn't either.
19:37:19 <o3> Jerub: dynamic typing is very useful in many situations
19:37:33 <emu> perl and python have no decent mechanisms for recovering from stupid errors
19:37:35 <o3> Jerub: you can do things like add new capabilities to the program on-the-fly
19:37:37 <Pseudonym> emu: This is #haskell.  It's fairly safe to say "all" we use isn't perl and python.
19:37:52 <emu> Pseudonym: on the dynamic typing side, is the unspoken qualification
19:37:56 <Jerub> My issue with dynamic typing is the tendancy for errors to occur at a later time after an incorrect type has been passed into an object or set of functions, that breaks something you've not interacted directly with.
19:37:56 <emu> I know you use haskell ;)
19:38:36 <o3> Jerub: so be careful and trap those errors.  since haskell has an explicit dynamic type, you know whether exceptions will be thrown if you try various things with the type (like coerce it to a type class or whatever)
19:38:42 <Pseudonym> Perl and python both fit into their respective niches quite nicely.
19:38:58 <emu> I'm just saying, if you're going to compare it, compare it against a language with decent support for dynamic typing and runtime error recovery
19:39:08 <Pseudonym> I'm not convinced that PHP even has a niche.
19:39:17 <Jerub> o3: Sorry, the continuation of that sentence is, but haskell's types are really lovely.
19:39:18 <o3> dynamic type allows plenty of great new things to happen, just like dynamic loading and dynamic binding
19:39:44 <Jerub> Pseudonym: web programming. Its actually got quite a large niche there. quick and dirty web applications.
19:39:51 <o3> Jerub: that's completely non-related to whether dynamic types suck or not
19:40:10 <Pseudonym> Jerub: I don't believe there's a task in PHP which could not be better done in Perl or Python.
19:40:11 <emu> for example, CL.  or Dylan, which has some of the optional static typing features that Igloo was asking about.
19:40:16 <Pseudonym> That's what I meant.
19:40:21 <Jerub> Pseudonym: I agree.
19:40:36 <emu> Smalltalk too
19:40:57 <Pseudonym> And Erlang, for that matter.  I certainly agree with you here.
19:40:59 * o3 steps away from language-elitist land
19:41:14 <emu> if you compare perl and haskell, of course haskell's gonna look better. it's sane.
19:41:25 <Pseudonym> emu: That depends.
19:41:47 <Pseudonym> Shell scripts don't look so good in Haskell.
19:41:55 <Pseudonym> They look fine in Perl.
19:42:18 <emu> well, perl is a glorified shell scripting language
19:42:22 <Pseudonym> Quite.
19:42:27 <Jerub> emu: yes.
19:42:30 <Jerub> much glory.
19:42:38 <emu> gorified
19:42:46 <Pseudonym> It was originally a union of shell scripts, awk and sed.
19:43:03 * Arnia caused similar reactions on #python last night
19:43:06 <Pseudonym> Sometimes, Perl (or Python) is exactly what you need.
19:43:10 <Arnia> This is getting to be a bad habit :/
19:43:16 * Pseudonym shrugs
19:43:18 <emu> I'm sure if someone put some time into it, they could make Haskell useful for shell scripting too
19:43:35 <Pseudonym> Perhaps.
19:43:37 <Jerub> emu: a nice standard lib for shell scripting tasks would be nice.
19:43:43 <Pseudonym> I doubt it, though.
19:43:49 <Pseudonym> Haskell is an application development language.
19:43:58 <Jerub> heck, I can think of some of the functions that would put perl to shame.
19:44:13 <o3> sigh, you guys are completely missing the point.  good luck convincing them, Pseudonym :)
19:44:15 <o3> -> lunch
19:44:18 <Pseudonym> :-)
19:44:37 <Pseudonym> See, o3 agrees with me.  So I must be right.
19:44:49 <Jerub> ;)
19:44:52 <emu> oh how wrong i was (what am I supposed to be wrong on, again?)
19:45:01 <Jerub> not that I think they should exist, but heck.
19:46:23 <Pseudonym> Last time I updated my resume, I came out at about 45 languages to varying degrees of fluency.
19:46:40 <Jerub> thats - a fair few.
19:46:42 <Pseudonym> I can think of areas where I would prefer any one of them.
19:46:57 <Pseudonym> That is, for each language, I can think of an area where I would prefer that one.
19:47:02 <Pseudonym> With a few exceptions.
19:47:12 * Pseudonym coughs... php... coughs again...
19:47:38 <Jerub> Pseudonym: I only use php becuase I'm paid to - please don't judge me.
19:47:45 * Arnia beats PHP with a stick
19:47:47 <Pseudonym> Oh, I don't.
19:48:01 <Pseudonym> I just want you to know that I share your pain.
19:48:02 <emu> what you do then is write code to output PHP
19:48:06 <Pseudonym> Or I did once.
19:48:13 <Pseudonym> Never again.
19:48:15 <emu> sorta like what you do for Java
19:48:56 <Pseudonym> Pascal is another one that, while useful once, I'd say was obsolete.
19:49:11 <Jerub> emu: java or javascript
19:49:18 * Jerub has written scripts that create javascript many a time.
19:49:25 <Pseudonym> If you're tempted to use Pascal, you're almost always better off using Modula-3, Delphi, Ada or Oberon instead.
19:49:31 <Jerub> But then again, I've seen some crazy shit.
19:50:00 <emu> both
19:50:06 <Jerub> I've seen php used (by an academic teaching kids) to generate C code to do fractal terrain with POVray
19:50:15 <Pseudonym> Triple yuck.
19:50:23 <Pseudonym> PHP, C, POV-Ray.  The unholy trinity.
19:50:44 <Arnia> Was he trying to scar the kids? :)
19:50:51 <Jerub> He succeded with one.
19:51:00 <Jerub> I'm going to be teaching those kids this year again actually.
19:51:39 <Arnia> meh
19:51:57 * Pseudonym slices POV-Ray in two wi' breadknife and dances about on its grave singing "hallelujah"
19:52:12 <Jerub> I'm going to  (hopefully) be teaching a 'robot' programming language. Only a basic kernel language "Move foward", "Turn left", "When I say XXXX I mean <list of instructions>" "Remember that XXXX is <aritmatic expression>"
19:52:19 <Jerub> and I'm going to need an if/then/else as well.
19:52:34 * Pseudonym shudders... LOGO...
19:52:35 * Jerub hasn't thought about it enogh yet.
19:52:57 <Pseudonym> Actually, you could try something based on PostScript.
19:53:04 <emu> Forth!
19:53:10 * emu hums innocently
19:53:21 <Jerub> emu: we taught forth 2 years back, the attention span was too low.
19:53:33 <emu> you overflowed their stacks
19:53:38 <Jerub> pascal and C have also been failures, but not so dramatic.
19:54:00 <Jerub> java was attempted and had much enthusiasm (coding fighting robots has that effect) but was too technical.
19:54:13 <emu> what exactly are you looking for?
19:54:43 <Jerub> something I can throw at 30 kids for a total of 8 hours over the course of a week that has enough 'wow' to keep them involved.
19:55:09 <emu> How about Squeak?
19:55:59 <Jerub> I've heard about squeak, I think I saw it a while back
19:59:17 <Pseudonym> AP/L
19:59:22 * Pseudonym hides
19:59:31 <Pseudonym> Oh, I know!  JCL!
19:59:49 <Pseudonym> I guess you could try Prolog.
20:00:22 <Pseudonym> 8 hours should be perfect.  Any more than that and they might cotton on to the fact that it's pretty useless.
20:00:48 * Arnia is still impressed with unification parsers in prolog though
20:01:01 <Pseudonym> This is true.
20:01:11 <Pseudonym> Unification parsers are very cool.
20:01:38 <Pseudonym> Mind you, I know of one particular product which produced the helpful message: "Your program contains one or more syntax errors."
20:02:14 <Arnia> The brain probably uses a unification system (Jackendoff 2002)... they're my favourite area of computer science and AI.
20:02:43 <Pseudonym> I'm more of a Schankian.
20:02:49 <Pseudonym> I think the brain is case-based.
20:03:59 <Arnia> Ugh... I can't think seriously about Schank. His semantics seem too arbitrary for my liking. Jackendoff's are based on observations about what the brain can do and what is evolutionarially useful.
20:06:29 <Pseudonym> I think Schank is working at a higher level.  His work _is_ based on observations, such as the way that humans repair their reasoning should it fail.
20:06:51 <Jerub> Pseudonym: isn't it APL/J ?
20:07:11 <Pseudonym> I wrote a paper for a linguistics class on computational prototype categorisation once.
20:07:38 <Pseudonym> Unification-based models might help there, but you still need some way to decide what patterns are the most likely.
20:07:41 <Pseudonym> i.e. case-based reasoning
20:08:34 <Pseudonym> Jerub: That might be one implementation.
20:08:45 <Pseudonym> I've always spelled it AP/L.  Mind you, I can't read it or write it.
20:09:34 <Arnia> pseudonym: In which case its just a grouping mechanism of a lower level conceptual semantics
20:10:22 <Pseudonym> What unification models don't model, or didn't model last time I looked (which was seven or so years ago) was learning.
20:10:35 <Pseudonym> Things have no doubt moved along since then.
20:14:26 * Arnia likes cognitive science ;)
20:14:45 <Jerub> Pseudonym: J is a language that works with APL iirc.
20:15:56 <Pseudonym> Oh, OK.
20:16:23 <Pseudonym> I used to like cognitive science.
20:16:35 <Pseudonym> It got a bit too messy.
20:16:40 <Pseudonym> Formal languages are so much easier.
20:17:00 <Pseudonym> Besides, if I want messy there's always graphics.
20:17:22 <Arnia> pseudonym: lol, it helps that Ray Jackendoff is the scientist I admire most :)
20:17:34 <Pseudonym> :-)
20:18:20 <Arnia> pseudonym: Any man who can keep his eye on the big picture, the details and getting the message across all at the same time has to be good :)
20:18:31 <Pseudonym> Seriously, has anyone working in unification done anything with learning yet?
20:18:45 <Pseudonym> It seemed to me that this was the biggest problem at the time.
20:19:02 <Pseudonym> Unification was a good _description_ tool, but it didn't seem a plausible model.
20:19:17 <Arnia> Umm... I'm doing some research into it, but I don't know if there is much other research.
20:19:23 <Pseudonym> OK.
20:19:28 <Pseudonym> Well, keep me posted. :-)
20:19:49 <Pseudonym> And, of course, the $64k question: Are you doing it in haskell?
20:20:00 <Pseudonym> :-)
20:20:05 <Arnia> Will do. Its the search for a generalisation algorithm that is occupying my time :)
20:20:16 <Arnia> Pseudonym: of course :)
20:20:21 <Pseudonym> Oh, good.
20:20:33 <Pseudonym> If you're interested, I have a logic programming monad transformer with soft cut.
20:20:47 <Arnia> Yeah, I'm interested :)
20:20:57 <Pseudonym> I keep meaning to add trailing some time so it works with constraint solving systems.
20:21:24 <Pseudonym> It doesn't support logic variables, just nondeterministic flow of control, negation-as-failure and soft cut.
20:21:47 <Arnia> Thats good for a start... do you know of any repair strategy algorithms for unification systems?
20:22:11 <Heffalump> Swierstra has a paper on that, doesn't he?
20:22:17 <Pseudonym> Sorry, don't know.
20:22:23 <Pseudonym> As I said, it's been 7 or so years.
20:22:25 <Heffalump> certainly on good error reporting
20:23:07 <Pseudonym> http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/hfl/hfl/mtl/
20:23:12 <Pseudonym> You'll need all three modules.
20:23:19 <Arnia> I've been meaning to read those papers for a while.
20:23:20 <Arnia> Thanks
20:24:15 <Arnia> Being a 2nd year, working on Plone and trying to have a social life is an impedement to research :)
20:24:31 <Pseudonym> There's your problem.  You're trying to have a life.
20:25:28 <Arnia> Pseudonym: And starting early doesn't help... I'm only 19, I want to do too many things :)
20:25:55 <Pseudonym> I'm 29 and I do too.
20:26:23 <Pseudonym> At least I've had a chance to do some of them.
20:26:42 <Arnia> Pseudonym: Never sleeping gives me more time ;)
20:26:50 <Pseudonym> I've been a programming language researcher, I've worked in visual effects...
20:27:01 <Arnia> Cool life :)
20:27:02 <Pseudonym> There's still time to write an operating system.
20:27:12 <Arnia> A functional one ;)
20:27:16 * Pseudonym laughs
20:27:26 <Pseudonym> I actually started it once.
20:27:29 * Arnia is curious to see a functional OS... if such a thing makes sense ;)
20:27:32 <Pseudonym> It booted and scanned for PCI devices.
20:27:47 <Pseudonym> Actually, I'm thinking of a minimal microkernel OS.
20:27:54 <Pseudonym> Based on QNX and L4.
20:28:10 <Arnia> Continue, please... I believe the brain is a functional computer in style :)
20:28:21 <Pseudonym> Oh. :-)
20:28:23 * Arnia wants functional hardware
20:28:32 <Pseudonym> Well, it won't be functional, really.
20:28:36 <Pseudonym> Not pure.
20:28:47 <Pseudonym> Though I do believe that the OS should not be "foreign".
20:29:00 <Pseudonym> That is, the OS interface should be abstract, not a C API.
20:29:19 <Arnia> I once had the idea of how to build a functional computer... I'm trying to remember bits of it now...
20:29:41 <Pseudonym> Well there's the Symbolics Lisp machine, and there's the SKIM machine.
20:30:30 <Arnia> I think it relied on combinators yes...
20:30:50 <Arnia> All you need is one bit, S and K, don't you?
20:31:08 <Pseudonym> Well, it depends how efficient you want it.
20:31:28 <Pseudonym> You really want basic data types, and combinators up to S', C' and B*.
20:31:31 <Pseudonym> Oh, and Y.
20:32:17 <Pseudonym> In fact, S and K can be defined in terms of one combinator.
20:32:23 <Pseudonym> Unfortunately, it's not a supercombinator./
20:32:46 <Arnia> I'm imagining being able to make combinator processors very very small and having millions on a chip using single bits to represent S and Ks
20:37:51 <Arnia> Massively parallel system :)
20:38:11 <Pseudonym> You need a) pointers and b) a garbage collector.
20:38:43 <lament> Arnia: having S and K is not enough
20:38:54 <lament> Arnia: there's also the application operation :)
20:39:02 <Pseudonym> Oh, good point.
20:39:13 <lament> you CAN have a language with two symbols
20:39:34 <lament> s/language/lambda-calculus dialect
20:39:38 <Arnia> How many symbols would be required?
20:39:48 <lament> but those wouldn't be quite as simple
20:40:13 <lament> regular lambda calculus has four symbols, of which one is not needed
20:40:17 <lament> iota and jot have two symbols each
20:40:29 <lament> s/lambda calculus/combinatory logic
20:40:35 <o3> re
20:40:35 <Arnia> :)
20:41:05 * Arnia shouldn't be distracted from generalisation algorithms :)
20:42:12 <lament> A combinatory-logic computer is fairly easy to built with two stacks
20:42:21 <lament> *build
20:42:42 <lament> one stack for the remainder of the program, another for the current operand
20:43:10 <Arnia> I was thinking of a way to make it parallel though
