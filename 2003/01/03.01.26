02:48:28 <steele> hi
03:33:08 <shapr> hiya
03:41:18 * shapr bounces happily
03:41:27 <shapr> okay, time to make this rfc822 parser work
03:41:51 * shapr drinks coffee to jumpstart his brain
03:42:41 <eivuokko> I'm going to give up trying to compile that ghc cvs in windows. :|
03:42:57 <eivuokko> Any idea when those template features will be in a release?
03:42:57 <shapr> did you ask on the ghc-users list?
03:43:10 <eivuokko> I didn't
03:43:31 <shapr> iirc, Simon PJ said a TH version could be released if enough people want one.
03:44:22 <shapr> I can probably get a Linux TH compiled, if that interests you
03:45:35 <eivuokko> Well, I could try that myself.  I just prefer using my preset editors and stuff and not using someone else's computer.
03:45:52 <shapr> ok
03:46:38 <eivuokko> It's not that important to use it ;)
03:47:18 <shapr> feeling bored? want to work on RFC822? ;)
03:49:02 * shapr hacks up HUnit tests
03:49:13 <eivuokko> Sorry no.  Two things : I'm not too good with haskell types and I've made email software before - it's hard to make working solutions. ;)
03:49:40 <shapr> I'm just trying to make something that can send emails from Haskell.
03:49:59 <shapr> SMTP.hs doesn't handle errors or anything, it's just barely enough to send mail
03:52:07 <eivuokko> Hmmm.  What will that ghc build try if I got no happy or ghc in path?
03:52:54 <shapr> you have to have at least ghc 4.08 in your path if you have only source
03:53:04 <eivuokko> If you want to send mails, that's pretty easy.  Just build up header and so?
03:53:23 <eivuokko> Okay.  configure just didn't stop on it ;)
03:53:24 <shapr> sure, but I'm learning how to build up headers :-)
03:55:10 <eivuokko> How do you usually organise bigger builds with ghc?  Do you make or such tool or does it include somekind of automatic build?
03:55:27 <shapr> it includes an automatic build system
03:55:36 <shapr> well, sort of
03:55:46 <shapr> do you mean building GHC? or using it to build a large Haskell system?
03:55:54 <eivuokko> Do the dependencies work, or do they work as well as in java?
03:56:09 <eivuokko> Building a haskell system/multiunit application.
03:56:17 <shapr> build depends don't work so well in Java =)
03:56:19 <eivuokko> Dunno what you call "translation unit".
03:56:26 <eivuokko> Yes, that was the point ;)
03:56:47 * shapr grins
03:57:11 <shapr> most people use Makefiles with explicit dependencies
03:57:19 <shapr> but I prefer to use hmake
03:58:25 <eivuokko> Hum.
03:58:31 <eivuokko> Does it do dependency scans?
03:58:36 <shapr> I haven't written any large apps though, so maybe a Makefile is required for really large systems.
03:59:21 <eivuokko> Well, I'm just wondering whetever I should write scons (make replacement) tool  description (and scanner?).
03:59:22 <shapr> yes, hmake does dependency scans
03:59:24 <shapr> it's pretty spiffy
03:59:43 <shapr> you should check out hmake before trying to rewrite scons
04:00:41 <shapr> on the other hand, Igloo once looked at all of the build tools, he may have come up with a more well informed conclusion about build tools in the Haskell world.
04:00:58 <eivuokko> hmake - not a windows program? ;)
04:01:20 <shapr> it's a haskell programs, should run wherever haskell does.
04:09:21 <eivuokko> How hard is it to do the dependency scan for haskell sources?
04:09:46 <shapr> I think hmake just looks at the import lines and tracks down each of those modules, and looks at their import lines
04:10:02 <shapr> then once it has everything, it build the depends
04:10:07 <shapr> or it complains if something is missing
04:13:04 <eivuokko> It doesn't build under msys and I don't feel like trying to port it.
04:13:08 <shapr> what's msys?
04:13:44 <shapr> ghc itself also has some dependency stuff built in
04:13:52 <eivuokko> Sort of cygwin.  www.mingw.org  The point is that it would make it so that it uses normal windows path instead of cygwin ones.
04:13:55 <shapr> so if you have Foo.hs you can say "ghc --make Foo"
04:15:11 <eivuokko> I guess I just happily continue my little haskell experiments with hugs or something ;)
04:15:16 <shapr> ok :-)
04:15:24 <shapr> there are binary distributions of ghc
04:15:43 <shapr> there are probably binary packages of hmake also
04:15:49 <shapr> hugs is a good thing
04:16:00 <eivuokko> I didn't find hmake.  And I do have latest ghc release.
04:16:01 <shapr> oh, hugs runs on the sharp zaurus =)
04:16:03 <shapr> I want that.
04:16:37 <shapr> http://www.cs.york.ac.uk/fp/hmake/
04:16:59 <shapr> doesn't have windows binaries on the page :-(
04:17:01 <eivuokko> No binaries for windows.
04:17:23 <eivuokko> I did try to build it already ;)  I'd have used binaries if it's possible :)
04:17:24 <shapr> I'm using debian linux, so I just do "apt-get install hmake"
04:24:14 <eivuokko> Do you people often read haskell report?  It seems quite a lot more cryptic than standards or specs I've read?
04:24:53 <shapr> I do wish it included more examples
04:25:02 <shapr> but I think most reports are about as cryptic
04:27:10 <shapr> any Parsec users here?
04:27:17 <shapr> I'm trying to figure out notFollowedBy
04:42:46 * shapr tries to figure out how to do unit tests on Parsec parsers
04:46:37 * shapr tries to remember how to pull Left and Right stuff out of an Either
04:46:57 <shapr> oh, I use a case statement... 
04:47:02 <shapr> riiight, now I remember
04:47:26 <shapr> gee, I need to make that simpler to stick into a unit test.
04:50:27 <shapr> can someone explain what the difference is between try and option in Parsec?
04:53:14 <shapr> has anyone done unit testing with Parsec?
04:57:55 <shapr> how do I do an assertion on an Either type?
05:10:04 <shapr> %-/
05:11:16 <shapr> hrm
05:11:23 <shapr> "cr not lf" ~: (Right "abc") ~=? (test_run text "abc\r\ndef"),
05:11:25 <shapr> that gives me
05:11:34 <shapr>     No instance for (Eq ParseError)
05:11:34 <shapr>     arising from use of `~=?' at /home/shae/src/haskell/RFC822.hs:30
05:11:41 <shapr> is there a better solution? 
05:12:10 <shapr> how should I be looking into the "Either ParseError [Char]" that is return from the test on the right side of that line?
05:17:28 * shapr tries to make ParseError an instance of Eq
05:19:49 <shapr> hrm, what's the ! in a data constructor mean? strictness or something?
05:24:54 <shapr> wow, that seems to have worked.
05:25:00 <eivuokko> That's what report says.  I don't understand the explanation, though.
05:25:08 <shapr> where does the report say that?
05:25:18 <shapr> I couldn't find it with a quick look
05:25:24 <eivuokko> end page 43, page 42
05:25:33 <eivuokko> It's the diffrence between $and $!
05:25:50 <shapr> oh, but that's for function application strictness
05:25:51 <eivuokko> But I only used $ and . to bind funcs.
05:25:58 <shapr> I think using ! in a data constructor means something else
05:26:07 <eivuokko> No, that's for types. See yourself.
05:26:13 <eivuokko> Or I can paste.
05:26:13 <shapr> ok..
05:26:29 <shapr> I'll look, I have it open in a browser.
05:26:42 <shapr> er, what section number is that?
05:26:51 <eivuokko> 4.2.1
05:26:58 <eivuokko> end of it, pages 43 and 42
05:27:32 <shapr> oh, I see
05:27:45 <shapr> thanks
05:27:56 <eivuokko> Can you explain $ and $! ?
05:28:04 <shapr> sure
05:28:17 <eivuokko> $ I've used to bind funcs together
05:28:20 <shapr> function application binds most tightly
05:28:29 <shapr> but you can make it bind least tightly with $
05:28:37 <shapr> in that case it can replace parentheses
05:28:46 <eivuokko> Yea, that's how I used it.
05:29:03 <shapr> for $! I think it means "don't do this lazily"
05:29:11 <shapr> "evaluate everything now"
05:30:10 <eivuokko> Thx.
05:30:16 <shapr> where is $! mentioned in the report?
05:30:17 <eivuokko> I'll make some testing with it.
05:30:32 <eivuokko> It's defined in 6.2, I just try to decipher it now.
05:31:51 <shapr> ah, yes..
05:32:00 <shapr> $! can be used to force evaluation
05:32:13 <eivuokko> And then I need to understand how that applies to datatypes ;)  Kinda fun this haskell.  Applying typed lambda calculus into programming.
05:32:23 <shapr> yah, it's very spiffy :-)
05:39:27 <eivuokko> I guess this is a bit stupid, but.... Do you actually get to work with haskell?  I mean like paying job that allows(requires!) coding in haskell?
05:39:43 <shapr> there aren't very many
05:39:47 <shapr> there are some though
05:39:58 <shapr> galois-connections in Portland, Oregon
05:40:15 <shapr> SyntaxPolice is hiring US Citizens that want to move to Ohio to write in Haskell
05:40:28 <shapr> it's not too hard to get an academic position doing research in Haskell
05:41:04 <shapr> I'm a contract programmer, some of my clients give me work to do where they don't care about the language or system used, just how quickly it is doen
05:41:07 <shapr> done
05:41:17 <eivuokko> Yea.
05:41:22 <shapr> I haven't been paid for Haskell work yet, but I will be :-)
05:41:38 <shapr> that's why I'm working on these libraries, so I can use them for client work.
05:41:41 <eivuokko> Poor bastard that has to maintain it later (and doesn't know haskell) ;)
05:41:55 <shapr> well, if someone else is going to maintain it, I won't write it in Haskell.
05:42:18 <shapr> much of my code is becoming service oriented though
05:42:31 <shapr> like "write something to suck this private news server into a database"
05:42:44 <shapr> and they want that done once a year.
05:43:39 <eivuokko> That doesn't sound like it would matter too much what you use (from any point of view, except db interfaces, maybe).
05:44:02 <shapr> I know that Alistair Reid runs Reid Consulting in the UK, which specializes in Haskell.
05:44:25 <shapr> so I assume there is Haskell business out there.
05:44:43 <shapr> I just need to be able/prepared to do anything in Haskell that I can do in any other language.
05:45:28 <shapr> yes, for services, my clients don't care what I use, as long as it's done well and quickly.
05:45:56 <Smerdyakov> Mr. Stinky Capitalist Face Man
05:46:02 <shapr> I think contract software services are becoming much more popular.
05:46:17 <shapr> Smerdyakov: Mr. Doesn't Like To Eat Food Man ;-)
05:46:21 <Smerdyakov> I think anti-capitalism is becoming more popular :P
05:46:40 <shapr> I like having money for food and hardware.
05:46:58 <shapr> and I just figured out how to unit test my Parsec parsers, yay!
05:47:14 <shapr> this should get my RFC822 parser done faster.
05:47:33 <eivuokko> Heh.
05:47:35 <shapr> hi Marvin--!
05:47:45 <Marvin--> afternoon
05:47:52 <shapr> how ar ya?
05:48:19 <Marvin--> just came home from seeing a movie
05:48:22 <Marvin--> well, documentary actually
05:48:27 <shapr> good movie?
05:48:36 <shapr> bra filmen? :-)
05:48:44 <Marvin--> s/en// :)
05:48:52 <shapr> whoops
05:48:52 <Smerdyakov> I guess you also like having billions of people around the world slave away so you can have food and hardware, shapr?
05:49:07 <shapr> Smerdyakov: hm, sounds good to me.
05:49:15 <shapr> I like eating and coding.
05:49:20 <Marvin--> Michael Moore's newest documentary, Bowling for Columbine
05:49:35 <Smerdyakov> OK, just don't complain when sensible people stop you from being able to live your current life, shapr :P
05:49:45 <shapr> Smerdyakov: ok.
05:50:17 <shapr> Marvin--: I've heard of it, you like it?
05:50:25 <Marvin--> it was very very good
05:50:40 <shapr> cool, I'll add it to my list of things to see.
05:51:03 <Marvin--> you should've come to the film festival :)
05:51:28 <Marvin--> There's something special about seeing movies in the morning :P
05:52:05 <shapr> when is the film festival?
05:52:29 <andersca> is it now?
05:53:33 <shapr> yow...
05:53:35 <shapr> ghc-5.04.2: fatal error: scavenge_stack: weird activation record found on stack: 0
05:53:37 <shapr> boom
05:54:04 <eivuokko> Seems pretty ordinary number to me.
05:54:09 <shapr> heh
05:54:18 <shapr> truly, zero is not unusual
05:54:27 <shapr> ghci sure didn't like it though.
05:54:57 <eivuokko> I didn't understand those ! for constructors.  What's the point?
05:55:12 <shapr> eivuokko: you can't tie the knot if you use !
05:55:35 <eivuokko> Okays.  I somehow fucked my tests then.  I'll redo.
05:55:37 <eivuokko> Thx.
05:55:38 <shapr> in some cases, you don't want to tie the knot, you want to make sure you have valid data all the way down.
05:55:43 <shapr> at least, that what I think :-)
05:55:55 <shapr> Marvin-- and andersca probably know more than I do about it.
05:56:15 <Marvin--> the film festival is 24/1 - 3/2 ;)
05:56:28 <shapr> also, strictness in constructors can save you from space leaks sometimes
05:56:44 <shapr> eivuokko: hey, if you put up your test examples, I'd love to see 'em
05:57:00 <shapr> eivuokko: you could put them on the HaskellWiki if you want more people to look at them.
05:57:16 <shapr> is there some cheesy way to subtract the contents of one list from another?
05:57:23 <shapr> maybe something in List?
05:57:34 <Smerdyakov> SML has ListPair.map :P
05:58:23 <shapr> yah, but I'm asking for Haskell
05:59:09 <eivuokko> Hmmm, I'll consider it if I come up to understand this stuff.
05:59:22 <shapr> ah, what's intersect and intersectBy 
06:01:52 <shapr> does anyone know what intersectBy does?
06:02:27 <Marvin--> I'm guessing intersectBy takes an equality relation
06:02:49 <Marvin--> and...well...takes the intersection of two lists under that relation?
06:03:02 <shapr> yah, it takes (a -> a -> Bool) for the first arg, and then two lists
06:03:12 <Marvin--> then I think it's a good guess ;)
06:03:20 <shapr> ohh, so you can use stuff other than Eq for the intersection?
06:03:32 <Marvin--> yes
06:03:35 <shapr> neat
06:03:35 <Marvin--> I guess :)
06:03:40 * shapr tries
06:03:41 <Marvin--> like sortBy and nubBy
06:03:59 <shapr> spiffy!
06:04:34 <shapr> I don't understand why it works this way though...
06:04:51 <shapr> intersectBy (==) [1,2,3] [3,4,5]
06:04:51 <shapr> [3]
06:04:54 <shapr> intersectBy (/=) [1,2,3] [3,4,5]
06:04:55 <shapr> [1,2,3]
06:05:38 <Marvin--> uhmm... passing in something that's not an equivalence relation is sure to produce some funky behaviour
06:05:48 <shapr> what's an equivalence relation? :-)
06:05:53 <shapr> can you give me an example?
06:06:06 <eivuokko> equality he said, I think.
06:06:17 <eivuokko> oh and now he said equivalenve.
06:06:21 <eivuokko> Sorry for the noise :)
06:06:30 <shapr> so, what else could I put in there?
06:06:44 <shapr> eivuokko: hey, we're all trying things out :-)
06:06:52 <shapr> jumping in and talking is always good imho
06:06:57 <Marvin--> an equivalence relation is a reflexive, transitive (and associative?) relation
06:07:07 <shapr> ok.
06:07:10 <shapr> like what? :-)
06:07:14 <Marvin--> R is reflexive if xRx
06:07:28 <Marvin--> R is transitive if xRy & yRz implies that xRz
06:07:36 <shapr> ok
06:07:39 <Marvin--> == is both reflexie and transitive, /= is neither :)
06:07:44 <shapr> yah, I see
06:08:07 <shapr> so, what else is reflexive, transitive, and not (==) ?
06:08:17 <eivuokko> It's usefull mostly for multifield types, I think.
06:08:31 <shapr> oh, so you can sort tuples by their second field or something?
06:08:39 <shapr> well, intersect them :-)
06:08:49 <eivuokko> That's my guess.  That's how we use that stuff in c++.
06:09:07 <Marvin--> shapr: >= and <= are reflexive and transitive, but they're not equivalence relations... oh of course, they have to be commutative (xRy <=> yRx) which <= and >= aren't
06:09:29 <shapr> Marvin--: this is neat, entirely new stuff for me :-)
06:09:30 <shapr> thanks!
06:09:36 * shapr writes lots of notes
06:09:37 <Marvin--> you're lacking formal education ;)
06:09:44 <shapr> yah, I know
06:09:47 <Marvin--> this is first-year maths at universities
06:09:56 <shapr> I haven't had first year maths.
06:10:04 <Marvin--> exactly
06:10:22 <shapr> I really want to go to luth.se and get a CS degree.
06:10:25 <shapr> I bet I could learn lots.
06:10:36 <Marvin--> I think umu is better
06:10:39 <shapr> I bet I'll irritate the crap out of every teacher who gets close to me.
06:10:55 <shapr> Marvin--: they do distance learning?
06:10:59 <shapr> umu is far from boden
06:11:49 <shapr> Marvin--: thanks, I'll check into umu
06:12:00 <Smerdyakov> How old are you, shapr?
06:12:10 <Marvin--> I don't know, and I know it's far
06:12:11 <shapr> Smerdyakov: older than you I'm sure. :-P
06:12:14 <shapr> I'm thirty one years old.
06:12:40 <shapr> Smerdyakov: and I've had CS 101! w00
06:12:52 <shapr> Smerdyakov: how old are you?
06:12:54 <Smerdyakov> Did you drop out of university during your younger years?
06:12:55 <Smerdyakov> 21
06:13:03 <eivuokko> What's CS 101?
06:13:17 <shapr> Smerdyakov: yah, insurance company refused to pay medical bills and I used my tuition to pay the bills.
06:13:21 <Smerdyakov> eivuokko, I just have to tell you: Finland has the best names on the planet :D
06:13:32 <shapr> eivuokko: it's where they say "this is a computer, that's the button where you turn it on"
06:13:45 <eivuokko> shapr, oh.
06:14:00 <eivuokko> Smerdyakov, now you did it.  Could you tell me the meaning too? ;)
06:14:03 * Marvin-- goes to the supermarket to buy food
06:14:07 <shapr> I learned on IBM XTs. We wrote ROM BASIC programs.
06:14:20 <Smerdyakov> eivuokko, nope. I just knew as soon as I read it, since I used to play on the BATMUD ;-)
06:14:33 <shapr> it means no vuokko
06:14:40 <shapr> but I don't know what vuokko is
06:14:44 <eivuokko> Oh, my nick?
06:14:52 <Smerdyakov> Yes.
06:14:59 <Smerdyakov> Why did you _think_ I said it? =)
06:15:10 <shapr> minä ei ole suomi.
06:15:11 <eivuokko> Dunno ;)
06:15:25 <shapr> makkarrani paistettu saunassa
06:15:27 <eivuokko> I just didn't realize someone would make indirect joke about it.
06:15:50 <Smerdyakov> It's not a joke. I really think Finnish names are spiffy.
06:16:10 <shapr> finnish is a hard but nifty language.
06:16:14 <eivuokko> Do you know what vuokko is?
06:16:20 <Smerdyakov> No!
06:16:23 <shapr> nah, I can't remember.
06:16:26 <Smerdyakov> Is it something obscene? =D
06:16:26 <eivuokko> It's a flower, anemone.
06:16:30 <Smerdyakov> Oh ;-)
06:16:32 <shapr> oh, neat!
06:16:39 <eivuokko> It happens to be my realname, of course.
06:16:49 <shapr> so that means anemonous?
06:16:59 <Smerdyakov> Hm. I think a kid growing about named flower might have some troubles from the other kids ;-)
06:17:03 <Smerdyakov> s/about/up
06:17:37 <shapr> anemonymous - an nameless sea flower
06:18:13 * shapr runs out of coffee, must make more
06:19:31 <Marvin--> tcp        0      0 sjogren.ostkupan.s:9999 sjogren.ostkupan.:32891 ESTABLISHED 25559/ash
06:19:32 <Marvin--> wtf?!
06:20:14 <eivuokko> Nah, I never had probs with my lastname.  Anemone is actually a family of flowers, btw.
06:21:14 <Smerdyakov> FYI: "first name" and "last name" are said with two separate words in English
06:21:38 <Smerdyakov> Same with "real name"
06:22:01 <eivuokko> Thank you.  Sorry to rape the language.
06:22:33 <shapr> Marvin--: ash is talking to itself?
06:22:35 <Smerdyakov> Heh. I just thought you'd like to know for future reference. You have the usual impeccable Scandanavian English in most respects.
06:23:15 <Marvin--> shapr: no, I just remembered that I have an aptproxy running on 9999
06:23:28 <shapr> so, what's the easy way to remove all occurences of one list from another list?
06:23:54 <Marvin--> er
06:23:59 * shapr looks for disjunction
06:24:14 <Marvin--> do you mean you want  [1,2,3,4,5] `foo` [1,2] == [3,4,5]?
06:24:23 <shapr> nah, I want all items from list a removed from list b
06:24:27 <Smerdyakov> Filter on the negation of membership
06:24:29 <shapr> good point
06:24:35 * shapr tries that
06:24:55 <Marvin--> shapr: isn't that exactly what my foo does? It removes all elements in the second list from the first list
06:24:57 <shapr> I was hoping for a Prelude function, but I'll do it that way :-)
06:25:05 <Marvin--> if that's what you want, there's \\ in List
06:25:14 <shapr> Marvin--: no, your foo may require contiguous ranges :-)
06:25:31 <shapr> for example, [1..5] `foo` [1,3] may not work
06:25:31 <Marvin--> shapr: it was a simplistic example
06:25:35 <shapr> yah, ok :-)
06:25:52 <shapr> in that case, yes, that's what I want.
06:26:18 <Marvin--> List> "foobar" \\ "or"
06:26:18 <Marvin--> "foba"
06:26:21 <shapr> nice, that's exactly it
06:26:26 <Marvin--> hmm, it just removed one of the o:s
06:26:33 <shapr> yah, it's not set ops
06:26:37 <Marvin--> yeah
06:26:40 <shapr> you have to nub them first
06:26:46 <Marvin--> probably
06:27:02 <shapr> that makes it more flexible imho
06:27:15 <shapr> since it only removes the first occurance
06:40:11 <shapr> yay, another unit test passes.
07:00:42 <shapr> what's the difference between option and try in Parsec?
07:04:30 <eivuokko> optional is normal way to add to the grammary and try is for error reporting, maybe?  (I dunno anything about parsec)
07:04:52 <shapr> hm, good idea...
07:05:39 <eivuokko> For (complex) grammars it's (often) usefull to have error reporting built (partly) inside it so that it tries whetever some common error scheme occurs, I think.
07:07:49 <shapr> Exception: Text.ParserCombinators.Parsec.Prim.many: combinator 'many' is applied to a parser that accepts an empty string.
07:07:51 <shapr> wheee
07:08:17 <eivuokko> lol, Nice matching cabability ;)
07:08:22 <Smerdyakov> Hm, how does it now it accepts an empty string?
07:08:27 <shapr> good question.
07:08:40 <Smerdyakov> I thought empty string accepting of context free grammars was undecidable, or something like that =)
07:08:47 <shapr> heck if I know
07:09:38 <shapr> I think it means I need to refactor the parsers somehow.
07:10:27 <Smerdyakov> Hm, it might just be NP complete or something. For some reason, I think I've heard that it's hard. =)
07:10:54 <shapr> see the ugly current code: http://kungens.kemi.fi/~shae/src/haskell/RFC822.hs
07:10:56 <eivuokko> If it's rfc822, character : shouldn't prolly be optional or something like that.
07:11:07 <shapr> I'm just doing quoted string right now
07:11:20 <shapr> oh, I see
07:11:29 <shapr> I think
07:13:07 <shapr> something wrong with linear_white_space I think
07:13:39 <Smerdyakov> That's where I live.
07:13:48 <shapr> in linear white space?
07:14:13 <shapr> hi lament 
07:14:50 <Smerdyakov> Yah
07:15:02 <shapr> Smerdyakov: what's it like there?
07:15:04 <lament> hi.
07:15:09 <Smerdyakov> Very white
07:15:16 <shapr> makes sense
07:16:16 <Smerdyakov> My ML dynamic web page server is really cool. It recompiles itself with dynamic page code added in and restarts =)
07:16:40 <shapr> should I mention that GHC can do you runtime loading of modules?
07:16:56 <Smerdyakov> Maybe you should mention how slow GHC code is :P
07:17:10 <shapr> much faster than typing it by hand.
07:18:39 <Smerdyakov> Than typing what?
07:19:34 <lament> hee
07:20:44 <shapr> typing the web pages by hand
07:21:42 <shapr> ah, I think I found the problem
07:21:58 <Smerdyakov> Heh
07:22:14 <Smerdyakov> Typing all the possible web pages that can be generated by one script is also impossible ;-)
07:22:36 <shapr> yup
07:22:56 <shapr> point being that compared to typing, the speed differences between Haskell and ML are insignificant.
07:23:34 <Smerdyakov> Untrue
07:23:40 * shapr sighs
07:23:42 <Smerdyakov> Web page users would notice a significant slowdown.
07:23:52 <shapr> I disagree, but I don't really want to argue about it.
07:24:07 <Smerdyakov> Benchmark results really aren't going in your favor :P
07:24:18 <shapr> whatever dude.
07:24:20 <eivuokko> Btw, do you mean compiling or generated code speed?
07:24:27 <Smerdyakov> Generated code speed
07:24:50 <shapr> Smerdyakov: why are you on the #haskell channel if you think ML is superior?
07:25:15 * Smerdyakov raises an eyebrow.
07:25:21 <Smerdyakov> I think ML is superior when execution speed is important.
07:25:39 <shapr> do you think Haskell is better than ML in other situations?
07:25:54 <Smerdyakov> There is often a noticeable delay in dynamically generating pages. In one benchmark I saw, ghc generated code almost twice as slow as MLton.
07:26:08 <Smerdyakov> Sooo... I would expect a 2xnoticeable delay =)
07:26:19 <shapr> two microseconds rather than one?
07:26:33 <Smerdyakov> No, in human-detectable second fractions.
07:27:10 <Smerdyakov> I also really haven't used Haskell, and I'm quite familiar with ML.
07:27:18 <shapr> I see.
07:28:54 <shapr> you could improve GHC such that it generates code that is as fast as the ML compilers.
07:29:14 <Smerdyakov> Probably not... you could probably get very close, though =)
07:29:41 <Smerdyakov> You really can't get around some extra overhead from lazyness.
07:29:57 <lament> just wait for quantum computers!
07:29:59 <shapr> well, prove it to me and I'll believe you.
07:30:03 <shapr> in the meantime, I don't.
07:30:47 <shapr> but if you have any haskell question I'd be happy to help you =)
07:30:52 <Smerdyakov> shapr, decidablity issues prevent you from knowing how lazy evaluation will work ahead of time.
07:31:07 <shapr> Smerdyakov: wanna help me with RFC822.hs?
07:31:10 <Smerdyakov> shapr, sooo... there will be situations where you have to keep these extra suspensions around.
07:31:36 <Smerdyakov> I already declined that offer :P
07:31:56 <Smerdyakov> Like I said: use command line mail clients ;)
07:34:12 <eivuokko> I thought I saw "forall" in somewhere, but I can't find it in report, what is it?
07:37:26 <Smerdyakov> Universally quantified types?
07:37:50 <shapr> yah, I think I've heard that in connection with forall
07:38:26 <Smerdyakov> Probably gives you polymorphism where not all quantifiers are "at the front of the type"
07:38:54 <Smerdyakov> Like (forall a . a -> a) -> (forall a . a -> a) instead of forall a. ((a -> a) -> (a -> a))
07:39:24 <Smerdyakov> The latter is what you get when you just include free variables in types.
07:40:25 <Marvin--> and the scariest example is, of course ST :)
07:40:26 <Smerdyakov> (The above does not pretend to be Haskell notation.)
07:40:32 <Marvin--> runST :: (forall s . ST s a) -> a
07:40:47 <Smerdyakov> Oh, did I have it right? =)
07:40:52 <Marvin--> yeah
07:41:15 <eivuokko> I am sorry.  I didn't truly understand.  Is there definition somewhere or could you tell me a bit more.  (What's the net effect?)
07:41:16 <Marvin--> I think it's called "rank 2 polymorphism"
07:41:19 <Smerdyakov> Ah. I guess there are only so many ways people put typed lambda calculus syntax into a programming language =)
07:41:37 <Smerdyakov> eivuokko, here's an easy example
07:41:38 <Marvin--> (lunch)
07:41:52 <Smerdyakov> Here's a boring Haskell function
07:42:01 <Smerdyakov> alwaysOne _ = 1
07:42:12 <Smerdyakov> I think it has type (a -> Int) or something like that
07:42:28 <Smerdyakov> So what if we want someone else to return this function?
07:42:37 <Smerdyakov> alwaysOneReturner _ = alwaysOne
07:42:46 <Smerdyakov> So alwaysOneReturner :: a -> b -> Int
07:43:02 <Smerdyakov> The catch is, you have to decide which types to assign to a and b each time you call alwaysOneReturner!
07:43:05 <Smerdyakov> So you can't do:
07:43:12 <Smerdyakov> alwaysOne' = alwaysOneReturner 8
07:43:25 <Smerdyakov> alwaysOne' 8
07:43:25 <eivuokko> Okey, cool.
07:43:29 <Smerdyakov> alwaysOne' ""
07:43:37 <Smerdyakov> Because you have to pick a value of b with the first call.
07:43:53 <Smerdyakov> If you have general universal quantification, you can make the type of alwaysOneReturner:
07:44:00 <Smerdyakov> a -> (forall b . b -> Int)
07:44:04 <Smerdyakov> And then that code works fine
07:44:25 <eivuokko> Why can't I find it in report then?
07:44:33 <eivuokko> Thx, Smerdyakov :)
07:49:55 --- topic: set to '["mo' nads than you", "We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/", "new  #sml channel for all your ML topics", "Gtk+HS 0.14.10:  http://www.cse.unsw.edu.au/~chak/haskell/gtk/","HWS-WP: http://www.dum.chalmers.se/~marvin/hws-wp/", "HaSDL: http://www.xs4all.nl/~dark/hasdl-0.1pre7.tar.gz","New HTk release http://www.informatik.uni-bremen.de/htk/", "Tallest dwarf in Moria"]' by shapr
07:53:37 <shapr> forall isn't H98 I think
07:53:58 <shapr> the Report specifies the "Haskell 98" standard
07:54:44 <shapr> some of the stuff that GHC can do isn't H98, and can't be emulated by H98
07:56:02 <eivuokko> Too bad.  I'll read ghc user manual then, I guess.
07:58:49 <shapr> http://www.cs.ukc.ac.uk/research/groups/tcs/fp/Refactor/surveys/haskell-editors-July-2002-summary.txt
07:58:52 <shapr> er, wrong chan
08:02:57 * shapr fights the whitespace
08:03:02 <shapr> hi argv[0] 
08:03:08 <argv[0]> hi guys
08:03:15 <argv[0]> hello, shapr 
08:03:27 <shapr> what's up?
08:04:39 <argv[0]> thursday i'll operating systems exam... i'm starting to be bored by all the page fault algorithms.. besides thats, everything is cool =)
08:05:19 <shapr> I've been staring at RFC822.hs far too long.
08:05:44 <shapr> hm, which op in HUnit does the assertNotEqual?
08:06:01 <argv[0]> an .hs RFC? what's that? (probably a dumb question)
08:06:14 <shapr> I'm working on an RFC822 parser in Haskell
08:06:19 <shapr> I'm using Parsec
08:06:32 <shapr> parser combinators are nifty
08:07:29 <argv[0]> i had parsing test last friday.. that went really wrong
08:07:41 <Smerdyakov> Ew, parsing test?
08:07:44 <Smerdyakov> For what class?
08:08:07 <argv[0]> programation methods III
08:08:18 <shapr> parsing is neat, though confusing at first
08:08:19 <argv[0]> the main subject is automatons and such things
08:08:33 <argv[0]> in the end we get a glimpse at parsing
08:08:34 <shapr> oh, did you do regexes, DFAs, etc?
08:08:43 <argv[0]> yep
08:08:49 <shapr> sounds like fun
08:09:13 <argv[0]> its fine, but wasn't expecting the parsing part that hard. oh well...
08:09:30 <Smerdyakov> "Programation Methods"?
08:09:39 <argv[0]> didn't count mutch anyway
08:09:43 <Smerdyakov> Must be a mistranslation =)
08:09:54 <argv[0]> probably, my english is rather poor =)
08:10:23 <shapr> argv[0]: where are you?
08:10:30 <shapr> spain?
08:10:31 <argv[0]> Portugal
08:10:34 <shapr> ah
08:10:36 <shapr> ok
08:11:06 <shapr> written any Haskell lately? :-)
08:11:51 <argv[0]> sure... the ER, DFA and NDFA study is haskell based
08:12:11 <shapr> nice
08:12:18 <shapr> have any dfa code we can look at?
08:12:32 <Smerdyakov> shapr, why are you so into asking people for code? =)
08:12:40 <shapr> um, I like cod.
08:12:41 <shapr> code.
08:12:57 <argv[0]> do you know AT&T Graphviz tool?
08:13:02 <shapr> or maybe I just like writing code.
08:13:05 <shapr> yah, I know it.
08:14:02 <argv[0]> your work was to make a tool to translate ER, DFA and NDFA to graphic representations
08:14:09 <argv[0]> our work, sorry =)
08:14:17 <shapr> cool!
08:14:37 <Smerdyakov> argv[0], Graphviz is the best =)
08:14:52 <Smerdyakov> argv[0], I have just used it for an assignment for a class like yours, except we don't do any programming.
08:14:57 <argv[0]> with things like beautifyDFA and minizeDFA which gave a few work 2 do
08:16:13 <argv[0]> you can pick on my work report at http://paulo.homelinux.net/~paulo/lesi
08:16:28 <argv[0]> it's in Portuguese, but still you get see the code and the outputs 
08:18:02 <shapr> very nice
08:18:33 <shapr> pretty pictures
08:18:41 <shapr> I'll read the code when I have time, thanks :-)
08:18:46 <Smerdyakov> Oooo, it crashed GhostScript =
08:19:13 <argv[0]> weird
08:19:24 <shapr> works here
08:20:04 <argv[0]> i just putted there the pdf version, try that one
08:20:30 <argv[0]> pages 10/11 have a few output examples
08:20:54 <argv[0]> 11/12 i mean
08:23:22 * shapr fights with Parsec error comparison
08:27:33 <shapr> any other HUnit users here?
08:27:42 <shapr> trying to figure out assertNotEqual
08:38:13 <shapr> oh, I see!
08:38:16 <shapr> weird
08:42:45 <shapr> well, let's see if the users list is any help.
08:48:00 <shapr> hrm
08:48:26 <shapr> I want to steal parts of the TokenParser without changing all of the interfaces of my code to TokenParser
08:51:36 <shapr> oh, it's a type synonym
08:56:13 * shapr wonders if it's simpler to switch entirely to TokenParser
09:27:05 <shapr> gwahr
09:27:10 <shapr> any Parsec users here?
09:27:19 <whee> I've used parsec for some things
09:27:33 <shapr> qt <- option "" (choice [quoted_pair, qtext])
09:27:46 <shapr> quoted-string = <"> *(qtext/quoted-pair) <">
09:28:09 <whee> and I have no idea what that does :)
09:28:48 <shapr> it says that a quoted string is made up of a bunch of qtext or quoted char matches
09:29:22 <shapr> I just can't figure out how to match zero or more (choice [qtext, qchar]) and return it in one variable
09:29:25 <shapr> do you know how?
09:30:14 <shapr> I wonder if I should be using try
09:30:41 <whee> oh
09:31:16 <whee> what about using many or one of those functions
09:34:07 <shapr> hi lazycode 
09:34:36 <shapr> already a Haskell user?
09:36:25 <whee> graphviz sure looks like tons of fun :)
09:36:48 <shapr> hIDE is using graphviz to generate nifty graphs of Haskell source code
09:38:01 <eivuokko> Hmmmm.  Is do added to the language just for the monads?
09:38:12 <shapr> yup
09:38:29 <shapr> it's just sugar for >>= or >>
09:42:09 <shapr> ohhh
09:42:11 * shapr sees the problem
09:42:16 <shapr> many changes the return type
09:43:53 <shapr> hm, so... how do you combine option and many?
09:45:06 <whee> what do you have option for?
09:45:18 <shapr> because the quoted string can be empty
09:45:26 <whee> many will match 0 or more entries of something
09:45:33 <whee> so if it's empty, it just won't do anything
09:45:36 <shapr> oh
09:45:39 <shapr> excellent point
09:45:50 <whee> you use many1 if you want to have at least one of something
09:45:58 * shapr tries that
09:47:54 <shapr> oh, this is where it exploded before..
09:47:58 <shapr> *** Exception: Text.ParserCombinators.Parsec.Prim.many: combinator 'many' is applied to a parser that accepts an empty string.
09:49:06 <shapr> I must be doing something wrong.
09:50:02 <whee> you have qt <- choice [quoted_pair, qtext]?
09:50:13 <shapr> qt <- many (choice [quoted_pair, qtext])
09:50:27 <whee> and what does qtext match?
09:50:51 <shapr> qtext = many (oneOf (chars \\ (cr_char : "\"\\")))
09:51:31 <shapr> http://kungens.kemi.fi/~shae/src/haskell/RFC822.hs
09:51:55 <shapr> I realize I'm a Parsec newbie, maybe I'm doing something obviously wrong.
09:53:46 <whee> oh
09:53:51 <shapr> ?
09:53:54 <whee> try using many1 for qtext
09:53:56 <shapr> you see something?
09:54:15 <shapr> !
09:54:16 <shapr> !!
09:54:20 * shapr hugs whee 
09:54:24 <shapr> thank you so much!
09:54:24 <shapr> w00
09:54:29 <whee> heh
09:54:36 * shapr bounces happily
09:54:55 <shapr> yay!
09:55:04 <shapr> I am in your debt
09:58:01 <Marvin--> "How and Why E Works!  (or - Hand-optimized Z80 assembly code)"
09:58:09 <Marvin--> what kind of alternate title is that? :)
09:58:18 <shapr> 100% evil
09:59:32 <shapr> oh, I see why many changes the signature
09:59:35 <shapr> duh
09:59:50 <Marvin--> $ eprover --help | wc -l
09:59:50 <Marvin-->     449
09:59:50 <Marvin--> eep!
09:59:59 <shapr> haha
10:04:25 <Marvin--> # Proof found!
10:04:32 <shapr> yay
10:04:37 <Marvin--> right, and a very parser-friendly output too...NOT :(
10:07:38 <Marvin--> I think I need to read up on this Skolem fellow
10:07:43 <shapr> hrm, it fails trying to parse a quoted escaped backslash
10:07:45 <shapr> I wonder why.
10:07:57 <shapr> I'm pretty sure that should be legal.
10:10:21 * shapr is confused
10:20:01 <whee> bah
10:20:24 <shapr> ?
10:20:30 <shapr> what's up?
10:20:43 <whee> just a general "bah" :)
10:20:47 <shapr> heh, ok
10:21:09 <shapr> I should probably extend this to an rfc2822 after I'm done with rfc822
10:21:12 <whee> just my realization that xfig and xcircuit are a pain to work with :\
10:21:21 <shapr> haven't tried either
10:22:13 * Marvin-- tries to make heads or tails of E
10:22:30 <Marvin--> he says that goal clauses are negated since this is refutational theorem proving
10:22:59 * shapr blinks cluelessly
10:23:06 <Marvin--> and if you negate \all X . f(i(X), X) = e you get \exists X . ~ f(i(X), X) = e, right?
10:23:34 <shapr> I have no idea
10:23:36 <Marvin--> skolemize that, and you get ~ f(i(a), a) = e...
10:23:43 <Smerdyakov> Yes, Marvin--.
10:24:04 <shapr> I think I've run across something weird though.
10:24:04 <Marvin--> so why does the file say  "<- f(i(a), a) = e."?
10:24:13 <shapr> it looks like this parser doesn't consume the input when it should.
10:24:58 <Smerdyakov> I don't know what that syntax is.
10:25:17 <Marvin--> "<-" just means that this is a goal, I think
10:25:53 <Marvin--> but anyhow, to me it feels like the written goal is the direct opposite of what I feel it should be, so I wonder where I go wrong
10:25:54 <Smerdyakov> What makes you think this file will have it already negated?
10:26:13 <Marvin--> "As goal clauses are negated in refutational theorem proving, all-quantified variables are turned into skolem constants"
10:26:31 <Smerdyakov> Yes, and my question still stands.
10:26:45 <Smerdyakov> If this is meant as a human-convenient input file, it would probably not have the negations performed.
10:27:50 <Marvin--> it also says that an alternative way of writing this is   ~f(a,i(a)) = f(i(a),a).
10:28:26 <Smerdyakov> Do you have particular algebraic rules for f and i that allow you to conclude that?
10:28:31 <Marvin--> which would translate to ~ \all X . f(X,i(X)) = f(i(X),X).
10:28:54 <Marvin--> oh, sorry, this is a group theoretical example, where i is the right inverse function
10:29:07 <Marvin--> so f is associative and I want E to prove that i also is the left inverse
10:29:10 <Smerdyakov> OK
10:29:32 <Marvin--> but in any case, the above clause sure looks negated to me...
10:30:01 <Smerdyakov> Yes, because that's the actual formula you want proven....
10:30:47 <Smerdyakov> And, unless there are other assumptions you have, it sure doesn't look like the second formula you gave is equivalent to i being a left and right inverse.
10:31:19 <Smerdyakov> I would think you can have different equivalence classes of values such that they all agree on f(X, i(X)) = f(i(X), X) within them, but not over the whole set.
10:31:38 <Marvin--> hmm
10:32:51 <Smerdyakov> I mean, just make i the indentity and all you have a trivial statement =)
10:34:24 <Marvin--> uh, a negated trivial statement, you mean
10:34:49 <argv[0]> hey guys, try to open www.google.com
10:35:02 <shapr> argv[0]: works for me
10:35:34 <argv[0]> i get a complete diferent output
10:35:38 <Marvin--> me too
10:35:41 <Marvin--> works, that is
10:35:42 <shapr> ?
10:35:55 <whee> works for me too D:
10:35:57 <argv[0]> it shows me a webpage with some router statistics
10:36:08 <Marvin--> err
10:36:10 <argv[0]> www.openusenet.org
10:36:10 <argv[0]> DIABLO statistics for feeder1-1.proxad.net (Top1000 3)
10:36:10 <argv[0]> Newsfeed Contact: NewsMaster
10:36:11 <shapr> argv[0]: maybe you have a transparent proxy in the way
10:36:11 <argv[0]> Generated on 20030126 1401 by feeder-stats v4.005. Copyright © 2002 The Diablo Project. 
10:36:22 <shapr> or a confused dns server somewhere
10:36:33 <shapr> more likely
10:36:35 <argv[0]> I do, but the problem seems to be from other thing
10:37:13 <argv[0]> i don't think people at google use Windows.. i'm talking about the new mssql problem
10:37:22 <shapr> ohh
10:37:28 <shapr> the mssql worm?
10:37:35 <argv[0]> yes
10:37:44 <argv[0]> the worm, since the problem is old :)
10:37:47 <shapr> what does that have to do with you not getting to google?
10:38:34 <argv[0]> the kind of statistics I get on the page seems to do with some graphics I saw analysing the problem, just that :)
10:38:54 <Smerdyakov> Marvin--, are you sure the "alternative way of writing it" doesn't assume the truth if the previous version, and in fact prove a different fact?
10:39:04 <shapr> aha, I found the bug.. it was a braino
10:39:23 <shapr> it does lead to an interesting question though...
10:39:35 <shapr> how should you interpret "\" ?
10:39:36 <Marvin--> Smerdyakov: they express the same thing, since  f(X,i(X)) = e  is given
10:39:50 <whee> shapr: as an operator?
10:39:56 <whee> that's how I would handle it :)
10:39:56 <shapr> whee: nah, as a quoted string
10:40:00 <shapr> I think it should be an error
10:40:04 <whee> oh
10:40:08 <Smerdyakov> Marvin--, ah. I don't think you've said that before.
10:40:16 <shapr> oh, wait...
10:40:17 <whee> that'd definately be an error
10:40:26 <shapr> since \ is one of the legal chars
10:40:28 <Marvin--> Smerdyakov: I did say that i was defined as the right inverse... sorry if that was unclear
10:40:38 <shapr> doesn't that mean it should be handled as a normal backslash?
10:40:43 <shapr> or should it?
10:40:46 <whee> \\ would be a normal backslash
10:40:59 <Smerdyakov> Oh, I see it.
10:41:00 <Marvin--> f(X,e)=X.
10:41:00 <Marvin--> f(X,i(X))=e.
10:41:00 <Marvin--> f(f(X,Y),Z)=f(X,f(Y,Z)).
10:41:00 <shapr> yah, I agree.
10:41:00 <Marvin--> those are given
10:41:02 <whee> if I were implementing how \ is handled, I'd have it be an operator that operates on  characters
10:41:13 <shapr> whee: yah, I see what you mean.
10:41:19 <whee> so that way it would be handled correctly as an error
10:41:28 <shapr> yah, makes sense to me.
10:45:04 <Marvin--> heh, this is a monster
10:45:15 <Marvin--> f(Y, f(f(Y, f(f(Y, Y), f(X, Z))), f(Z, f(Z, Z)))) = X.
11:13:05 <Segora> hi
11:13:09 <shapr> hiya
11:13:49 <Segora> do head <- lotsOfStuffToLearn; return home
11:14:00 <shapr> truly
11:14:03 <Segora> *g*
11:14:16 <shapr> today is Parsec day for me.
11:14:24 <Segora> Parsec's nice.
11:14:30 <shapr> I hope I can get this RFC822 parser done today.
11:14:44 <Segora> I played around with it a while ago (parsing IRC protocol)
11:14:49 <shapr> heyyy
11:14:55 <shapr> you have an irc protocol parser?
11:14:58 <shapr> I want a copy!
11:15:09 <shapr> I've been wanting to write an IRC bot in Haskell
11:15:17 <Segora> well, it's just an experiment. wait, i'll put it on webspace.
11:15:22 <shapr> ok!
11:15:24 * shapr bounces excitedly
11:15:36 <whee> gah, parsing irc sucks
11:15:51 <whee> I had fun doing that in erlang. I hate the protocol :)
11:16:05 <shapr> do you have an erbot?
11:16:53 <whee> yes, I wrote an erlang irc bot earlier this month
11:17:03 <shapr> neat
11:17:07 <Segora> sh.. the code is on a machine that's currently offline
11:17:11 <shapr> do you have the source online?
11:17:26 <whee> if you'd like, I'll put it on my httpd
11:17:31 <shapr> Segora: I'd very much like to get hold of the code when you get hold of it again.
11:17:32 <shapr> whee: yah sure.
11:17:54 <Segora> shapr: send a reminder mail to gefla@pond.sub.org, i'll put it online and reply with a notification
11:18:12 <Segora> ok?
11:19:29 <whee> shapr: http://smaerty.ath.cx/crusbot/src/ not that it'll help you much :)
11:20:33 <Segora> whee: do you know of manderlbot?
11:20:38 <whee> yes
11:20:47 <whee> I had looked at that first, but I disliked the overall structure
11:20:52 <shapr> Segora: will do, thanks
11:20:53 <Segora> ah
11:20:57 <whee> it seemed to reinvent the wheel a couple times
11:21:31 <Segora> at first glance, your code seems well integrated in OTP
11:22:06 <whee> I use gen_event for most of the communication between processes
11:22:36 <whee> it was my first actual erlang project, written a couple days after I had "learned" the language :)
11:24:25 <Segora> the irc_handlers module could be remodeled to use one of the standard behaviours (gen_server maybe)
11:24:51 <whee> yeah, it really should be gone and merged into the supervisors
11:25:02 <whee> I wrote that before remembering that you can dynamically add processes to a supervisor
12:03:46 * shapr returns for more code
12:04:05 <shapr> ok, time for round 2
12:04:29 <shapr> whee: did you do any recursive parsers in Parsec?
12:04:56 <shapr> I've just realized that rfc822 needs recursive comment parsing, and that changes my Parser types
12:05:00 * shapr hrms
12:07:17 <whee> I haven't done any recursive, no
12:08:52 <shapr> I must learn Erlang at some point.
12:09:54 <whee> indeed, you must :)
12:10:25 <shapr> it'd be especially nice to use Luke Gorrie's shbuf for shared code editing on irc
12:11:06 <Smerdyakov> Luke Gorrie makes me worrie.
12:11:36 <shapr> why?
12:11:48 <Smerdyakov> Funny joke with name
12:11:50 <shapr> oh
12:11:54 <Smerdyakov> Spelling humour
12:11:55 <Smerdyakov> Laughter
12:11:57 <Smerdyakov> Merriment
12:12:07 <shapr> luke is pretty smart.
12:12:27 <shapr> likely Simon PJ quality
12:15:43 <whee> luke shows up in #erlang every once in a while
12:16:31 <shapr> when luke first learned about wikis, he liked the idea, so he wrote a scheme interpreter in javascript, and stuck it together with a wiki
12:16:39 <shapr> I think it took him a week.
12:16:53 <whee> heh
12:17:48 <Smerdyakov> I think there is way too much people worship in academia, personally.
12:18:06 <shapr> Smerdyakov: be that as it may, neither I nor Luke are in academia.
12:18:21 <shapr> I do owe him a beer.
12:18:31 <Smerdyakov> You're ancillary academicians if you enter the ICFP contests, however ;-)
12:18:43 <shapr> hey, what'd you call me?
12:18:45 * shapr is joking
12:21:06 <shapr> Smerdyakov: for me, it's a lust for higher levels of understanding
12:21:24 <shapr> and I realize that some people are higher level than I am.
12:21:48 <Smerdyakov> I think a lot of people in the research community love to drop other people's names in hopes of having their own dropped some time. =)
12:23:06 <shapr> Smerdyakov: well, what's your name?
12:23:16 <shapr> I'll drop it regularly if it makes you feel better :-)
12:23:53 <Smerdyakov> :P
12:23:58 <shapr> I'm an ircademic.
12:24:01 * shapr snickers
12:24:12 <Smerdyakov> I'm saying that it's BAD and pointlessly egotistic to do that.
12:24:19 <shapr> oh. ok.
12:24:30 <shapr> well, if I see someone doing that, I'll say that to them.
12:24:33 <shapr> hi Heffalump!
12:24:35 <Heffalump> 'lo
12:24:38 <shapr> wassup?
12:24:42 <Heffalump> not much
12:24:50 <Heffalump> the great Internet wibble knocked me off and I didn't notice again
12:25:18 <shapr> hey, there's a new #sml channel, just started today
12:25:53 <shapr> have you used Parsec? want to glance at my RFC822.hs mess and tell me how it could be improved?
12:26:23 <Heffalump> I haven't, sorry
12:26:26 <Heffalump> bit busy atm too
12:26:28 <shapr> ok
12:26:31 <shapr> no worries :-)
12:26:38 * shapr keeps on hackin
12:29:06 * Marvin-- sighs in the general direction of the mplayer developers
12:31:14 <shapr> Marvin--: they still fighting?
12:36:39 <shapr> hi det 
12:38:31 <det> hello.
12:38:39 <shapr> what's up?
12:41:10 <det> not much :)
12:41:15 <det> ever finish your smtp stuff ?
12:41:25 <shapr> yah
12:41:30 <shapr> working on rfc822 today
12:41:35 <shapr> http://kungens.kemi.fi/~shae/src/haskell/RFC822.hs
12:41:37 <shapr> mostly working
12:41:54 <shapr> http://kungens.kemi.fi/~shae/src/haskell/SMTP.hs
12:42:06 <shapr> both of them ugly
12:42:12 <shapr> SMTP.hs is very minimally functional
12:42:41 <det> do all modules have "module Main where"
12:42:51 <shapr> no
12:42:58 <shapr> only main modules ;-)
12:43:22 <det> what is a Main module ? :)
12:43:34 <shapr> well
12:43:38 <det> something that has  a main = ?
12:43:40 <shapr> yup
12:43:48 <shapr> and when you run ghc on it, it creates a binary
12:43:56 <det> is YYY lik e XXX ?
12:44:08 <shapr> YYY means "an improvement that could happen"
12:44:15 <shapr> XXX means "this sucks, and needs to be fixed"
12:44:29 <shapr> somewhere between sucks bad to completely broken
12:45:22 <det> ZZZ means I shouldn't have written this in perl ?
12:45:27 * shapr laughs
12:45:29 <Heffalump> :-)
12:46:04 <shapr> det: ok, I just uploaded the latest version of SMTP.hs
12:46:15 <shapr> it's now module SMTP where
12:46:16 <det> http://kungens.kemi.fi/~shae/src/haskell/Mandelbrot6.hs
12:46:19 <det> looks neat
12:46:37 <shapr> yah, something else I wrote
12:46:56 <shapr> with lots of help from dennisb, Heffalump, and xbill
12:47:02 <shapr> first thing I wrote even.
12:47:03 <Smerdyakov> I thought xbill was a program!!
12:47:12 <shapr> xbill is also an irc nickname
12:47:17 <Smerdyakov> TYPE ERROR
12:47:20 <shapr> same person who goes by wli
12:48:01 <det> is it possible to have an eval in haskell ?
12:48:21 <det> for like a gaming console or something ?
12:48:37 <det> I mean with a ghc binary
12:48:42 <det> maybe with ghci linked in ?
12:48:50 <shapr> yah, you could always use ghci
12:49:16 <shapr> still not exactly eval though
12:49:22 <det> could you mix the two?
12:49:51 <shapr> yah, you could mix ghc and ghci
12:50:05 <det> I wonder how much bbigger ghci would make it
12:50:07 <shapr> you may want to look at the runtime loading stuff for GHC
12:56:25 * shapr wonders how to mix'n'match parsers with different result types
12:56:43 <Smerdyakov> Ever used combinator parsing?
12:56:50 <Smerdyakov> Or, parser combinators? =)
12:56:54 <shapr> I am using combinator parsing.
12:56:58 <Smerdyakov> Hooray
12:57:02 <shapr> even so
12:57:13 <Smerdyakov> You do realize they're very inefficient and have bad error reporting, right? ;-)
12:57:34 <shapr> not particularly important to me.
12:57:48 <shapr> if it works, I'll be cheerful.
12:58:01 <shapr> if I need to rewrite it in Happy lateron, that's okay with me.
12:59:33 <Heffalump> shapr: why do you want to mix parsers with different result types?
13:00:27 <shapr> 	Expected type: GenParser Char st Char
13:00:27 <shapr> 	Inferred type: GenParser Char st [Char]
13:00:47 <shapr> I've just realized that some of my parser combinators return Char, and some return [Char]
13:00:53 <shapr> and now I want to mix them into a choice combinator
13:00:56 <Heffalump> ok, and you always want [Char] ?
13:01:01 <Heffalump> is there a <$> combinator?
13:01:05 <shapr> umm
13:01:06 * shapr looks
13:01:22 <Heffalump> you probably want "wrap <$> foo" where foo is a parser producing a Char and wrap x = [x]
13:01:30 <Smerdyakov> There should be a general combinator to take a parser returning type a, and a function a -> b, and give you a parser returning b.
13:03:35 <steele> Smerdyakov: parsec doesn't seem bad for LL(k)
13:03:40 <shapr> Heffalump: what should the <$> do?
13:03:56 <Heffalump> what Smerdyakov said
13:04:14 <shapr> oh, ok
13:05:52 <Smerdyakov> steele, OK. I think it's generally hopeless if you try to implement the combinators inside Haskell, unless you have a very smart optimizing compiler that decides to build parsing tables :D
13:07:03 <shapr> Smerdyakov: I think parsec left factors itself
13:07:06 <shapr> or something like that
13:07:16 <shapr> I can't find the <$> combinator in the parsec docs
13:07:21 <shapr> or anything approaching it.
13:07:43 <Smerdyakov> I don't believe you, shapr =)
13:07:51 <shapr> Smerdyakov: not saying it doesn't exist.
13:07:54 <shapr> just that I can't find it in the docs.
13:08:02 <det> haha
13:08:25 <det> The first discovery I'd like to present here is an algorithm for lazy evaluation of research papers. Just write whatever you want and don't cite any previous work, and indignant readers will send you references to all the papers you should have cited. I discovered this algorithm after ``A Plan for Spam'' [1] was on Slashdot.
13:09:05 <shapr> det: yah, that's a great quote
13:11:08 <Heffalump> oh, it might be you're supposed to do things monadically
13:11:19 <shapr> ?
13:11:31 <Heffalump> in which case "mapM wrap" will do what you want
13:11:37 <shapr> um, ok.
13:11:46 <Heffalump> or indeed just use `mapM` in place of <$> as above
13:11:52 <shapr> I'll try that, thanks.
13:16:02 <shapr> ok, so (oneOf ['a'..'z']) should become mapM (\x -> [x]) (oneOf ['a'..'z']), right?
13:18:25 <shapr> Couldn't match `[a]' against `CharParser st Char'
13:22:10 <shapr> hrm
13:23:08 <Heffalump> umm
13:23:20 <shapr> http://www.cs.uu.nl/people/daan/papers/parsec.html
13:23:22 <Heffalump> does oneOf ['a'..'z'] parse ?
13:23:26 <Heffalump> IM typecheck
13:23:40 <shapr> should work fine
13:24:16 <shapr> but the problem is that the other items in the list return strings
13:24:27 <shapr> oneOf returns Char
13:24:34 <Heffalump> what's the type of oneOf ['a'..'z'] ?
13:24:37 <shapr> linear_white_space returns [Char]
13:24:58 <shapr> GenParser Char st Char
13:25:28 <shapr> *RFC822> :t linear_white_space
13:25:28 <shapr> forall st. GenParser Char st [Char]
13:26:26 <shapr> *RFC822> :t (oneOf ['a'..'z'])
13:26:26 <shapr> forall st. CharParser st Char
13:26:50 <shapr> Heffalump: if you're busy, don't worry about it.
13:27:19 <Heffalump> is CharParser an instance of Monad?
13:27:30 <Heffalump> IM CharParser a, actually
13:28:24 <det> shapr, yay, someone replied to my haskell-list thread and apparently my idea wasnt crazy
13:28:27 <shapr> type CharParser st a    = GenParser Char st a
13:28:43 <shapr> it's just a model. er, type synonym :-)
13:32:49 <shapr> det: yay!
13:33:18 <det> gtg for a little bit
13:33:19 <det> bbiab
13:33:22 <det> bye
13:33:22 <shapr> I wonder if I should try to factor out the matches to get the types right
13:33:23 <shapr> bye
13:34:46 * shapr tries to factor the matching
13:35:55 <shapr> I wish I could lift the parsers somehow.
13:36:14 <shapr> lift the type that is
13:38:56 <Smerdyakov> Do some manual labor.
13:39:00 <Smerdyakov> You'll be lifting parsers in no time.
13:39:02 <shapr> heh
13:39:04 * shapr laughs
13:46:10 <shapr> Smerdyakov: do you know how to do it?
13:50:39 <Smerdyakov> Not sure what you're saying, and probably not interested at the moment ;-)
13:50:50 <shapr> ok
14:04:31 * shapr wonders
14:09:00 <shapr> ya know..
14:09:08 <shapr> I could just change the return type entirely for everything.
14:09:22 <Heffalump> ugh, no
14:09:27 <Heffalump> I'm sure mapM or something like it is the answer
14:09:45 <Heffalump> there must be some Monad instances hanging around here, from what I can tell from the docs
14:09:50 <shapr> I was thinking creating an RFC822 record
14:10:10 <shapr> and having every combinator update or merge records
14:10:21 <shapr> then I don't have to screw around with the return type.
14:10:28 <shapr> what do you think?
14:13:32 <det> blah, some pdfs view terribly on this computer
14:16:32 <det> and there is no way to change the font :(
14:16:42 <shapr> :-(
14:19:09 <shapr> I'll be back after one episode of st:tng
14:19:20 <shapr> this code is frustrating me...
14:19:21 <det> adobe's online pdf->html tool did a nice job of converting it into random garbage
14:19:27 <shapr> det: heh :-)
14:21:15 <det> shapr, have fun
14:28:05 <Heffalump> shapr: no, changing the return type is probably the right thing to do
15:06:00 <det> Is anyone familiar with arrows ?
15:07:01 <Heffalump> define "familiar"
15:09:55 <det> well, they seem alot like "lambda" to me
15:11:43 <Heffalump> well, they're not :-)
15:12:02 <Heffalump> well, I suppose they're a generalisation of functions, so in one sense they are.
15:17:13 <det> or maybe lambda is like the Arrow classes arr
15:17:23 <Heffalump> not exactly
15:17:32 <Heffalump> arr just lifts a function into an Arrow type
15:17:51 <det> true
15:18:28 <det> but maybe arr could be primitive like lambda and replace lambda ?
15:20:05 <Heffalump> no, how would you make a function in the first place?
15:20:27 <det> I've come accross a few papers today talking about languages with just Monads
15:20:34 <Heffalump> like?
15:20:51 <Heffalump> if you can define a function, you effectively have lambda
15:21:01 <Heffalump> lambda is just convenient syntax for making anonymous functions
15:21:28 <det> ok, that's what I mean, arrows seem alot like functions :)
15:21:33 <andersca> functions is just convenient syntax for naming lambda functions :)
15:22:06 <det> yes.
15:22:17 <Heffalump> arrows are a generalisation of functions (in one way), I said that.
15:22:33 <det> in which? which ways arent they ?
15:23:26 <det> maybe I should learn some category theory
15:24:00 <Heffalump> IM they are one possible generalisation of functions.
15:24:02 <Heffalump> I wouldn't bother.
15:24:04 <shapr> yeehaa
15:24:15 * shapr bounces
15:25:07 <det> Heffalump: not a fan of category theory? or just not to apply to haskell ?
15:25:16 <shapr> det: arrows are like monads, but they also have static type info included
15:26:05 <Heffalump> det: it's ok, but I think if you go down that route just to get a better understanding of Haskell you probably won't have much success
15:26:06 <shapr> wow, Daan Leijen (author of Parsec) responded in less than the 45 minutes it took for me to watch a star trek episode.
15:26:10 <shapr> impressive
15:26:11 <Heffalump> (but I only know a limited amount)
15:26:30 <shapr> he wrote a <$> for me!
15:26:32 <shapr> neato!
15:26:58 <Heffalump> what's the definition?
15:27:06 <shapr> (<$>) :: (a -> b) -> Parser a -> Parser b
15:27:06 <shapr> f <$> p   = do{ x <- p; return (f x) }
15:27:34 <det> Heffalump: oh, yes, just in the past day I've come accross alot of ctegorical stuff and find it very interesting, I didnt mean to apply towrds haskell :) (I know VERY little math myself)
15:27:53 <shapr> I wrote about the <$> you mentioned in my email to him.
15:28:32 <shapr> oh this is great...
15:28:37 <shapr> I gotta see if this fixes it
15:28:42 * shapr bounces excitedly
15:29:32 <shapr> det: from what I've read, Arrows are very powerful things
15:30:07 <shapr> det: read John Hughes paper "Generalizing Monads To Arrows"
15:30:11 <shapr> it's great.
15:30:14 <det> shapr: they are apparently the base functionish concept from category theory, so I would imagine so :)
15:30:21 <shapr> It also took me several weeks to work through, but well worth it.
15:30:39 <det> how many pages is it? mayb I will print it
15:30:52 <shapr> hrm, I don't remember
15:30:54 * shapr looks
15:30:55 <Heffalump> 40ish
15:31:04 <Heffalump> you need access to Science of Computer Programming though
15:31:09 <Heffalump> or you can download the draft from his webpage
15:31:36 <shapr> yah, forty one exactly
15:31:48 <shapr> the draft is what I've read
15:32:05 <shapr> the only downside being that the syntax was changed in the actual paper (from what I've heard)
15:32:34 <det> shapr: I was hoping it would reveal the ultimate answer!
15:32:39 <shapr> det: I think it does.
15:32:43 <det> shapr: but I guess it's a page short
15:32:44 <det> oh no
15:32:45 <shapr> I just haven't understood the answer yet.
15:32:47 <det> that was very bad
15:32:49 <det> kick me
15:32:56 <shapr> ?
15:33:05 <shapr> ohhhh
15:33:07 <shapr> arrghh
15:33:11 <shapr> the horror =)
15:33:15 * shapr falls over laughing
15:33:37 <shapr> det: bad bad joke, very funny too =)
15:34:04 <shapr> Heffalump: does that definition of <$> look good to you?
15:35:49 <det> why can't you just do: return f p ?
15:36:12 <Heffalump> oh, DUH
15:36:13 <det> or even return wrapped in do notation if that is neccesary
15:36:16 <shapr> Heffalump: huh?
15:36:18 <Heffalump> yes, that's the one I intended to tell you.
15:36:28 <Heffalump> I just got confused and told you mapM instead, cos I'm an idiot :-)
15:36:32 * shapr is lost
15:36:44 <shapr> oh
15:36:46 <shapr> I get it.
15:36:58 <shapr> I still don't understand the mapM thingy, but I understand <$>
15:37:05 <Heffalump> I meant fmap, really, but I'm not sure if there's an automatic instance of Functor for Monads.
15:37:22 <shapr> I think there is... 
15:37:25 <shapr> not positive though
15:37:28 <shapr> det: show me
15:37:40 <det> shapr: show you what ?
15:37:50 <shapr> det: why I can't do return f p
15:38:05 <shapr> actually, I think I see why
15:38:09 <shapr> do you? :)
15:38:10 <Heffalump> yes, I think you could have used fmap.
15:38:17 <Heffalump> I should have just told you that and saved a whole lot of time :-)
15:38:20 <shapr> he also shows this
15:38:29 <shapr> foo  = do{ c <- someChar; return [c] } <|> someString
15:38:43 <shapr> that's pretty simple.
15:39:09 <det> shapr: I don't understand why you have to bind c to someChar instead of just using someChar
15:39:29 <Heffalump> det: look at the types
15:39:32 <shapr> someChar  :: Parser Char
15:40:46 <det> does that exract the char of the prser ?
15:41:04 <shapr> sort of...
15:41:13 <shapr> it means it's a Parser that return a Char
15:41:17 <shapr> well
15:41:23 <shapr> not exactly
15:41:38 <shapr> a monad is a parameterised type
15:42:06 <shapr> so a Parser monad can be stuck onto Char, [Char], or anything else
15:43:04 <shapr> I guess it means yes =)
15:43:18 <det> :)
15:43:25 <shapr> man, no one should get me to explain monads to them, I'd just make it worse.
15:44:04 <shapr> happily, this <$> combinator fixes several problems I've been having.
15:45:27 <Heffalump> det: "return f p" won't work because:
15:45:33 <det> it's wierd to see the word happily in a sentence without squish these days
15:45:40 <Heffalump> return is of type Monad m => a -> m a
15:45:45 <shapr> det: heh
15:45:46 <Heffalump> p is of type m a
15:45:51 <Heffalump> and f is of type a -> b
15:46:17 <Heffalump> so return f is of type Monad m => m (a -> b)
15:46:23 <Heffalump> which you can't apply to something of type m a
15:47:01 <det> oh.
15:47:12 <Heffalump> likewise, you can't do return (f p)
15:47:20 <Heffalump> because p is of type m a and f is of type a -> b
15:47:23 <Heffalump> so f p is type incorrect.
15:47:50 <Heffalump> what you can do is p >>= (\a -> return (f a))
15:48:05 <Heffalump> but do { a <- p ; return (f a) } is just syntactic sugar for precisely that.
15:48:31 <Smerdyakov> The short version is: you need to explicitly give all IO to be performed in order ;-)
15:49:14 <shapr> wow, this works.
15:49:20 <shapr> hot dam
15:49:23 * shapr bounces furiously
15:49:37 <shapr> I need a new chair >:-(
15:49:40 <shapr> too much bouncing
15:49:41 <Heffalump> Smerdyakov: s'not IO
15:50:28 <Smerdyakov> Heffalump, er, replace with name of monad :P
15:50:40 <shapr> det: the way I understand it, a monad represents an action.. sort of like a party popper.
15:50:52 <shapr> unless you pull the string, you don't get anything out of it.
15:50:56 * shapr grins
15:55:29 <det> _now_ I understand :)
15:55:53 <shapr> it was the party popper analogy, right?
15:56:02 <shapr> that's the real secret ;)
15:57:08 <whee> I'm scared now.
15:57:14 <shapr> ?
15:57:20 <shapr> you don't like party poppers?
15:57:57 <whee> next thing I know you'll be relating parser combinators to legos :)
15:58:09 <shapr> actually
15:58:21 <shapr> I've been saying combinators are lego for many months.
15:58:26 * whee runs
15:58:30 <shapr> hey, did you already know that?
15:58:31 <shapr> :-P
15:58:52 <shapr> much niftier than lego though
15:59:02 <shapr> I want to play with some Arrow combinators
15:59:08 <shapr> mmm, lust for power... mmm
16:00:13 <Smerdyakov> Every thought about doing something to advance the quality of life of the human race in general? =)
16:00:24 <shapr> hey, it makes *me* feel better.
16:00:27 <shapr> I'm a human.
16:01:30 <whee> okay, graphviz is having major problems handling my 3000+ node graphs. blah
16:01:31 <det> shapr: of course it was the party popper analogy, they were just spouting unparsable nonsense!
16:01:38 * shapr snickers
16:04:52 <argv[0]> bye all
16:05:03 <shapr> cya
16:18:21 <shapr> w00, neat
16:34:25 <shapr> hm, I didn't know rfc822 specified source routing
16:37:24 <Heffalump> for email?
16:37:28 <shapr> yup
16:37:28 <Heffalump> ! paths
16:37:31 <shapr> nope
16:37:35 <shapr> that's uucp I think
16:37:39 <Heffalump> no sensibly configured email server accepts them any more
16:37:43 <shapr> this uses domain names separated by @ chars
16:37:43 <Heffalump> oh, maybe in %s then
16:37:52 <Heffalump> umm, ok
16:37:59 <shapr> weird, eh?
16:37:59 <Heffalump> well, whatever it is noone accepts them :-)
16:38:04 <shapr> yah, I believe it.
16:38:07 <Heffalump> not really, source routing used to make a lot of sense
16:38:11 <Heffalump> then security became an issue
16:38:16 <shapr> maybe I should have started with rfc2822 :-)
16:39:17 <shapr> er, maybe it's @domain,domain,domain
16:39:19 <shapr> hrm
16:39:23 <shapr> with a colon at the end.
16:39:24 <shapr> something like that.
16:39:32 <Heffalump> are you /sure/ it doesn't have % or !s?
16:39:51 <shapr> yup
16:40:36 <Heffalump> hmm, ok
16:40:44 <shapr> http://www.faqs.org/rfcs/rfc822.html - section 6.1
16:41:16 <shapr> 6.2.7 gives source routing details (don't do it)
16:41:46 <shapr> the # means a comma separated list, according to the first part of the rfc
16:42:40 <shapr> yow, # lists are weird
16:45:10 <shapr> foo,,,,bar is the same as foo,bar
16:55:31 <shapr> these lists are getting way deep
16:55:39 <shapr> maybe I should go ahead and switch to a record
17:08:55 <shapr> geez, three sections to go
17:08:59 <shapr> rfc822 is larger than I thought
17:09:38 <shapr> section 3 and section 6 pass all their unit tests, but still leaves section 4 and 5, and the date parsing.
17:09:43 <shapr> the date parsing stuff looks way picky.
17:10:24 <shapr> oh, section 5 is date parsing
17:10:30 <shapr> so, only two sections left
18:24:23 * shapr gives up and goes to sleep
20:19:29 <dennisb> I havn't read all the things you have written so maybe it has already been said, but there are parser combinators written in haskell that builds parser tables on the fly and that are really efficient
20:24:25 <dennisb> Doaitse Swierstra has developed some very advanced parser combinators that use little memory, is fast (they build tables) and should give good error messages
20:27:14 <dennisb> Here is a link: http://www.cs.uu.nl/groups/ST/Software/UU_Parsing/index.html
20:30:56 <dennisb> Still, I'm quite happy(!) using parsec, I get the line and column where the error is, what else do one need
