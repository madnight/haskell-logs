00:38:48 <simon-> I'm reading the gentle introduction to haskell and a question struck my mind regarding 'lazy functions'...
00:39:30 <simon-> are they just referred to being lazy if they happen to be 'static' (in the form that they don't relate to their function arguments)
00:40:56 <simon-> ah, never mind. it was explained a few paragraphs below
04:48:14 <shapr> hi Nurbs 
04:48:21 <shapr> you do 3d modelling?
05:44:57 <shapr> I'm still not sure what to do with the stuff returned from these parsing combinators.
05:45:12 <shapr> one of the parsec examples is a calculator
05:45:24 <shapr> in that case it's easy enough to read the numbers
05:45:46 <shapr> but I don't know what kind of detail I should return from email headers
05:47:12 <Igloo> A function of type String -> [String]  ===  (Header -> [Content])?
05:47:34 <shapr> hm
05:48:02 <shapr> well
05:48:29 <shapr> I should probably start with a Message record
05:48:31 <shapr> and work my way down
05:48:53 <shapr> I don't know whether to make datatypes for Atom and such, as described in the rfc
05:49:08 <shapr> because I don't know what people would want to do with the header data
05:49:32 <shapr> I guess I need user stories
06:23:41 <shapr> hi Marvin-- 
06:25:06 <Marvin--> hello
06:29:24 <SyntaxPolice> morning.
06:30:11 <shapr> what's up?
06:32:04 <Marvin--> working with the Javalette parser
06:32:16 <shapr> wheee
06:32:37 <Marvin--> http://www.mdstud.chalmers.se/~md9ms/Javalette.cf
06:33:21 <shapr> I don't have permission to access that
06:33:45 <Marvin--> dang
06:34:36 <Marvin--> try again
06:35:13 <shapr> aha
06:35:14 <Marvin--> I made a hard link instead of a symlink ;)
06:35:50 <shapr> hey Marvin--, SyntaxPolice is heading up a new conspiracy...
06:36:00 <shapr> debian@haskell.org or maybe haskell-debian
06:36:27 <Marvin--> I think we should have debian-haskell@lists.d.o instead :P
06:37:01 <shapr> well, no argument there
06:37:10 <shapr> but I didn't know who to contact
06:37:24 <shapr> and we did know who to contact for @haskell.org
06:37:34 <Marvin--> we'd file a wishlist bug on the pseudo package lists.debian.org
06:37:42 <shapr> oh
06:37:46 <shapr> didn't know that
06:37:46 <SyntaxPolice> shapr, Marvin--, I guess it could go either way... Simon Marlow would rather not create a new list, though he said he would if we wanted him to.  He said that some people feel that there are too many lists with no one posting on them.'
06:38:06 <shapr> yah, I can understand that
06:38:25 <shapr> it's a list about package haskell libs into debian, I think it should be at lists.d.o
06:38:26 <Marvin--> SyntaxPolice: feels like that would be the obvious response from Debian's listmasters too
06:38:39 <shapr> you think they'd say the the same thing?
06:38:44 <Marvin--> but it would be nice to do some real coordinating for packaging policy
06:39:02 <SyntaxPolice> hmm... the problem is that I want it to actually turn into a more general solution for 3rd party libraries, but the initial discussion will be focused around Debian.
06:39:14 <shapr> well SOMEONE CREATE A LIST ALREADY
06:39:18 <Heffalump> just post it to haskell@ and wait till people get pissed off then.
06:39:21 * shapr bounces up and down with frustration
06:39:24 <SyntaxPolice> the firs tpart isn't interesting to the Haskell community, the 2nd part isn't interesting to the Debian community.
06:39:26 <shapr> Heffalump: excellent suggestion!
06:39:28 <Heffalump> I think the argument that dead lists are bad is valid.
06:39:28 <SyntaxPolice> we could use Library@h.o
06:39:33 <Marvin--> Heffalump: nice, let me go subscribe... :)
06:39:36 <Heffalump> yeah, possibly that.
06:39:41 <shapr> libraries@haskell.org it is
06:39:44 <SyntaxPolice> OK :)
06:39:45 <Heffalump> whatever's most appropriate of what already exists
06:39:46 <shapr> I'm posting RIGHT NOW
06:39:48 * SyntaxPolice subscribes
06:39:57 <Heffalump> and TBH it'll probably just be a discussion that flares up for a while then dies down
06:40:34 <SyntaxPolice> Heffalump: I don't know what TBH means, but I do expect that it'll be sort of temporary.
06:40:44 <Marvin--> are we agreed on using libraries@h.o?
06:41:20 <SyntaxPolice> yeah.
06:41:32 <SyntaxPolice> I could give simonMar a heads up, but I'm sure its fine. we could post there now.
06:41:36 <shapr> yes
06:41:46 * shapr is impatient today
06:41:48 <SyntaxPolice> hehe
06:42:31 <Marvin--> libraries@h.o doesn't exactly strike me as a high-volume list
06:42:41 <SyntaxPolice> right.
06:42:52 <Heffalump> to be honest
06:43:33 <shapr> Heffalump: maybe
06:52:34 <SyntaxPolice> shapr: so were you going to post something?  An announcement to haskell{-cafe}?
06:53:15 <shapr> no, I was just going to post questions about packaging to libraries@haskell.org
06:53:24 <shapr> and see what happened
06:53:42 <shapr> but I got distracted and haven't sent the mail yet.
06:53:49 <SyntaxPolice> OK. Once the discussion gets going I'll post something and maybe email other debian maintainers who do Haskell stuff.
06:53:58 <SyntaxPolice> are we agreed on the basic problems w/ packaging?
06:54:47 <shapr> well, there are problems :-)
06:55:52 <Marvin--> I'm not, because I don't know anything about it yet ;)
06:56:00 <SyntaxPolice> So I see two basic approaches, a kind of registry system that supposedly elisp has where libraries say "Here I am!" and whatever compilers are installed go and compile those libraries....
06:56:18 <SyntaxPolice> OTOH, when a new library is installed, or when a new compiler is installed, registered libraries get recompiled.
06:56:47 <Marvin--> I wonder if it isn't easier to have  foo-ghc5 and foo-hugs packages
06:56:51 <SyntaxPolice> Another idea is to make different packages for each binary system (hugs, ghc, nhc)
06:56:55 <SyntaxPolice> like marvin just said :)
06:57:01 <Marvin--> ;)
06:57:25 <SyntaxPolice> but then we're still left w/ the problem that I don't think even different versions of ghc5 are binary compatable, and we'd have to recompile the libraries, or make them depend on a _specific_ version of ghc.
06:57:40 <SyntaxPolice> but maybe someone can correct me if I'm wrong about that?
06:58:18 <shapr> ok, sent a starter email
06:58:22 <SyntaxPolice> Coo
06:58:45 <shapr> oh, I forgot that ghc4 and ghc5 are available in debian
06:59:17 <shapr> and ghc4 and happy are both build-depends for raw bootstrapping from source.
06:59:22 <shapr> bootstrapping ghc5 that is
07:00:09 <Marvin--> is ghc4 still in Debian?
07:00:28 <SyntaxPolice> yep
07:02:36 <shapr> I should add the build-depends stuff
07:02:49 <shapr> SyntaxPolice: replied with more details yet? :-)
07:02:59 <SyntaxPolice> no, I'm still working on subscribing actually...
07:03:04 <shapr> oh, ok
07:04:06 <Marvin--> time to go home
07:04:12 <shapr> yay, home
07:09:52 <hennker> hiho
07:10:40 <shapr> hiya
07:18:17 <hennker> hrhr, just read a log. a irclib.hs would be very nice, indeed =)
07:20:46 <shapr> Segora sent me an experiment into irc protocol parsing with parsec
07:20:54 <shapr> it's under BSD license, would you like me to forward it to you?
07:21:34 <hennker> thanks, but i really am quite a novice to haskell
07:21:36 <Janni> hello, all.
07:21:42 <hennker> hiho 
07:22:40 <Janni> btw: are there real haskel experts here? who were really productive with haskell (making money with it?)
07:22:53 <shapr> I think there are only a few who make money with Haskell
07:23:05 <shapr> three companies that I know of
07:23:20 * SyntaxPolice makes money w/ haskell, but is not necessarily a real expert :)
07:23:42 <Janni> SyntaxPolice: what are you programming? (interested)
07:23:43 <hennker> you're just chasing syntax-criminals? :D
07:24:13 <SyntaxPolice> hennker: yes. strong type systems are good for that ;)
07:24:20 * shapr grins
07:24:25 <hennker> eheh
07:24:27 <SyntaxPolice> Janni: you cna read about the technology at http://www.aetion.com 
07:24:32 <shapr> Haskell :: Justice
07:24:33 * jewel waits for the handcuffs to come out
07:24:38 <shapr> hi jewel!
07:24:39 <hennker> hrhrhr
07:24:39 <SyntaxPolice> we're actually looking for a US Citizen to hire in the next few months.
07:24:48 <Janni> are there any good free haskell programs? (and i mean _program_, not another library for haskell)
07:24:59 <shapr> SyntaxPolice: too bad I'm not willing to move back the states ... <sigh>
07:25:08 <SyntaxPolice> shapr: where are you again? The netherlands?
07:25:14 <shapr> nah, northern sweden.
07:25:18 <SyntaxPolice> ah OK.
07:25:20 <shapr> 800km up
07:25:58 <shapr> SyntaxPolice: if you need any contract work done, I'm very interested ;-)
07:26:26 <shapr> Janni: I know of galois connections in portland, oregon, usa; reid consulting in the UK
07:26:33 <shapr> and aetion.com in Ohio?
07:26:42 <SyntaxPolice> shapr: I'll pass that on.  Yeah, we're in Ohio.
07:26:53 <shapr> yes, ohio
07:27:12 <hennker> SyntaxPolice: i guess you are developing not a single product, but specialised stuff for every customer?
07:27:36 <hennker> i think i don't get the description of your field of work ;)
07:27:37 <shapr> I also know that flightlab.com uses Haskell for some stuff
07:27:39 <Janni> hennker: just have a look at the page
07:27:57 <SyntaxPolice> hennker: the idea (I think) is to build engines that are very general and then make money from specializing them.
07:28:18 <hennker> k
07:28:28 <SyntaxPolice> hennker: not sure what you mean in particular about field of work, but we're interested in exploring large decision spaces to help in design or other kinds of decision making.
07:28:56 <hennker> uhm, when i think more about it, i think i get it
07:29:22 <shapr> Janni: there are apps written in Haskell, though not many large apps.
07:29:24 <SyntaxPolice> hennker: its a littl ehard to get the brain around, believe me.  And its widely applicable, so its hard to pin it down to anything in particular.
07:29:37 <shapr> I know the BlueCode compiler is written in Haskell
07:29:39 <hennker> yep, i think that was my prob in the first place
07:29:55 <shapr> seems that Haskell is becoming popular for hardware design tools.
07:29:56 <hennker> sounds interesting, though
07:30:19 <SyntaxPolice> it is fun work :)
07:31:22 <Smerdyakov> SyntaxPolice, what entity is paying people to do this?
07:33:12 <SyntaxPolice> Smerdyakov: we have government contracts at the moment.  We really want to be more commercial, though.  At the moment as you mgiht guess, government contrats are easier to come by.
07:33:15 <jewel> The US military-industrial complex isn't everybody's friend these days
07:33:23 <SyntaxPolice> jewel: yeah :(
07:33:50 <Heffalump> I think the vast majority of commercial use of Haskell is by ex-academics
07:34:01 <Heffalump> (e.g. Galois, Sandburst, etc)
07:34:10 <Heffalump> SyntaxPolice may be an exception, of course :-)
07:34:39 <Smerdyakov> SyntaxPolice, OK, so you're a bunch of progressive developers who started a contract group?
07:34:51 <SyntaxPolice> shapr: I sent out another email to libraries.
07:35:23 <SyntaxPolice> Heffalump: we have two professors on our staff, and the research is out of the university that we're loosly tied to.  We're tryign to commercialize academic research.
07:35:45 <SyntaxPolice> Smerdyakov: I don't know what you mean by 'progressive' or 'contract group' :)
07:36:21 <Smerdyakov> "Progressive": not afraid to think, "contract group:" group of people who work together to provide the feeling of "professionalism" that a lot of customers like
07:36:37 <Smerdyakov> .. and make a living off of "contract jobs"
07:36:53 <Smerdyakov> Forgive me for having limited experience with commercial employment and never intending to ever have any more =)
07:37:08 <Heffalump> SyntaxPolice: ah :-)
07:37:36 <hennker> *g*
07:37:36 <SyntaxPolice> Smerdyakov: sounds great :) Yeah, that is pretty much us, at least right now.  I think we want to grow a lot, but I don't think we're going to be able to sell software "off the shelf" soon, since each use fo the software is very specific.
07:38:41 <Smerdyakov> SyntaxPolice, don't do it!! Use extra profits to make free software!
07:39:28 <SyntaxPolice> Smerdyakov: hehe :) We are really hoping to eventually be able to have some people who work full time on free software.
07:39:37 <Smerdyakov> And you don't feel any moral issues with directly producing things requested by a fascist government?
07:39:59 <SyntaxPolice> Esp haskell.  ATM I'm spending some time working on figuring out a sane way to package libraries for Haskell stuff.
07:40:54 <SyntaxPolice> Smerdyakov: I don't think its a fascist government, but I don't really like contracting for the government, no, esp the military.
07:41:12 <Heffalump> I think calling Dubya's lot fascist is a bit extreme
07:41:16 <Smerdyakov> Hm
07:41:17 <Smerdyakov> fascism: n : a political theory advocating an authoritarian hierarchical government (as opposed to democracy or liberalism)
07:41:18 <shapr> I'd like to see a regularly updated haskell package/library list 
07:41:29 <shapr> I could just create a cheesy one on the wiki until someone sets up something real
07:41:32 <SyntaxPolice> shapr: that would be a nother good First Step :)
07:41:40 <whee> hooray, ghci works now :))))))
07:41:44 <Smerdyakov> How does this not fit the "new" executive branch powers, general economic/social class structure, etc.?
07:41:45 <shapr> whee: yay!
07:42:14 <whee> I'll have to try the cocoa bindings later, but they should work as well
07:42:28 <hennker> haskell for cocoa?
07:42:39 <hennker> whatwhywhere? :)
07:42:41 <Janni> Smerdyakov: the definition of fascims is much more complex
07:42:45 <whee> yes, wolfgang has cocoa bindings that use TH
07:42:58 <hennker> TH?
07:42:58 <SyntaxPolice> Smerdyakov: If only people who agreed with the government worked for the government, then nothing would ever change.
07:43:02 <whee> template haskell
07:43:24 <Heffalump> wolfgang? cocoa?
07:43:25 <Smerdyakov> SyntaxPolice, you're suggesting that things change because of effort "from the inside"
07:43:43 <hennker> whee: ah, don't know of. but sounds cool
07:43:44 <Smerdyakov> SyntaxPolice, I'm not aware of any cases where the prime motivation for lasting reform came anywhere but from mass protests, direct action,etc.
07:43:47 <Heffalump> surely in the US the way to change the government is to vote it out, not to join it
07:44:04 <Smerdyakov> Heffalump, no. The way is to make things hot for the people who want to exploit the others.
07:44:31 <Smerdyakov> Heffalump, the electoral mechanisms in the US are constructed to prevent changing the status quo. They were meant to be so from the beginning. We don't even have direct election of presidents.
07:44:50 <shapr> soooo
07:45:05 <shapr> any package registry ideas other than a wiki page?
07:45:10 <SyntaxPolice> I'm not talking about working only from the inside, and I'm not talking about not voting and not protesting.  But understanding things from the inside makes you better at working to change them from the outside.
07:45:26 <SyntaxPolice> shapr: you mean a library pool type thing?
07:45:32 <shapr> SyntaxPolice: some kind of listing
07:45:59 <Heffalump> in what way are the mechanisms constructed to prevent change? Because the electoral college votes are chosen per state on a FPTP basis?
07:46:15 <shapr> features I'd like to see: compatibility (hugs,ghc,nhc,helium), last updated, required libs
07:46:16 <SyntaxPolice> shapr: someone sugggested a sourceforge category.
07:46:24 <shapr> oh, and local cached copies of the libs
07:46:26 <SyntaxPolice> though I dno't really understand that.
07:46:35 <SyntaxPolice> (never used sourceforge much)
07:46:36 <Heffalump> If you're going to say it's because of funding, I'd argue that people who are easily swayed by commercials deserve all they get.
07:47:24 <Heffalump> (not that I don't think the whole lobbying/campaign contributions system isn't corrupt)
07:48:22 <shapr> SyntaxPolice: it might help when looking for haskell stuff on sf.net
07:48:26 <shapr> but not anywhere else.
07:48:53 <shapr> I like your idea of adding support for ghc-pkg etc to hmake
07:49:31 <SyntaxPolice> yeah, it would be neat to use Simon Marlow's idea of a system that would create tarballs, or whatever.
07:49:50 <SyntaxPolice> a fairly standard makefile or whatever... 
07:50:34 <shapr> yah, python has distutils
07:50:42 <SyntaxPolice> what does that do?
07:51:22 <shapr> it's a now standard python lib that can be called with "python setup.py" in the new library dir
07:51:47 <shapr> and it compiles c & python source, installs, does setup
07:59:04 <SyntaxPolice> I see.
08:45:44 * shapr hrms
08:45:49 <shapr> I bet there's a simpler way to do this.
08:46:00 <eivuokko> Isn't there always?
08:46:07 <shapr> yes, I think so.
08:46:35 <shapr> I should probably define a hash_list combinator 
08:46:43 <shapr> would make my life easier.
08:46:55 <shapr> hi eivuokko, what's up?
08:47:39 <eivuokko> Hi, nothing much.  You?
08:47:46 <shapr> still hacking on my rfc822 parsers
08:47:50 <shapr> er, singular
08:47:52 <shapr> I have much to learn.
08:48:26 <eivuokko> Fun :)
08:48:27 <shapr> I think my current approach is incorrect, but I'm nearly finished with it, so I'm trying to go ahead and complete it before ripping it apart.
08:49:02 <eivuokko> Incorrect, in what way?
08:49:13 <shapr> I'm using Parsec to write an rfc822 parser
08:49:18 <eivuokko> Yup.
08:49:20 <shapr> write now each piece returns a list of list of lists
08:49:35 <shapr> I think I should probably make useful datatypes instead of returning lists of strings.
08:49:49 <shapr> I suspect my Python instincts encouraged me to return a list of strings.
08:50:36 <eivuokko> I don't understand what's bad in lists (or strings).
08:50:53 <shapr> one combinator is "choice"
08:51:01 <SyntaxPolice> shapr: I sent an email to the hmake author :)
08:51:13 <shapr> so I can say something like "choice [subject_field,message_id_field]"
08:51:50 <shapr> but the problem with that is that many of these fields return list of different depths, meaning I have to wrap the shallow lists to get the same types.
08:52:18 <shapr> as I approach the top level definition, my unit tests are beginning to look like ugly lisp
08:52:38 <shapr> "references_field1" ~: (Right [[[[["References:"]]]],[[[["foo"]],[["@"]],[["bar"]]]]])
08:52:42 <eivuokko> Hmmm.
08:53:00 <shapr> SyntaxPolice: cool! I hope the hmake guy has some light to shed on the situation.
08:53:33 <shapr> so it seems like it'd be less trouble for me to have data Message = Message [Field]
08:53:49 <shapr> and Field = Subject_Field | Message_ID_Field | ...
08:54:05 <shapr> or would it?
08:54:06 <shapr> I'm not sure.
08:54:40 <shapr> this is the first parser of any real depth I've written.
08:55:23 <shapr> eivuokko: have you learned anything interesting about monads other than IO?
08:56:57 <eivuokko> Interesting yes, new, a little.  But mainly because I don't understand how _||_ (bottom?) affects evaluation.  Of course it's pretty hard to understand all the examples because it's not easy to see all monadic operations.
08:57:27 <SyntaxPolice> shapr: sorry to sort of join in this late.  Have you thought of using Happy to parse this?
08:59:18 <shapr> SyntaxPolice: I have, but I'm more familiar with Parsec, and I thought this would be simpler than it is...
08:59:44 <shapr> I think I'll try Happy for the next parser I write.
09:03:12 <shapr> has anyone tried both Parsec and Happy?
09:03:17 <shapr> I wonder how they compare.
09:10:50 <SyntaxPolice> is parsec a part of CTK by chance?
09:10:58 <SyntaxPolice> I should really know more about this than I do.
09:11:31 <shapr> hrm, I don't know... I don't think so
09:11:32 * shapr looks
09:11:52 <SyntaxPolice> shapr: I emailed two Debian maintainers who I had excuses to email anyway and asked them to join the discussion on Libraries :)
09:11:55 <shapr> no, it's not.
09:12:08 <shapr> ctklight is separate (and a debian package we should look at)
09:12:52 <shapr> SyntaxPolice: excellent!
09:15:17 <SyntaxPolice> I see.
09:18:27 <shapr> Parsec is a bunch of parser combintors. It was written by Daan Leijen.
09:18:47 <shapr> seems that CTKLight is a streamlined version of CTK
09:21:25 <shapr> hi e!
09:21:28 <e> helo :)
09:21:33 <shapr> haven't seen you on this network in a loooong time.
09:21:45 <e> me neither :)
09:22:06 <shapr> wanna see the code I'm working on at the moment?
09:22:14 <e> sure
09:22:19 <shapr> http://kungens.kemi.fi/~shae/src/haskell/RFC822.hs
09:22:46 <shapr> e: have you looked at haskell?
09:23:28 <e> yumm, headers
09:23:47 <shapr> I grabbed the bnf specs out of rfc822 and pasted them in
09:23:53 <shapr> now I'm filling them in, piece by piece
09:23:54 <e> i have had a look repeatedly but never got around to get started programming
09:24:14 <shapr> with included unit tests of course
09:24:44 <e> there's a lot of mail out there that is not to really spec :/
09:24:48 <shapr> I'm into email tools at the moment, but there's an irc bot looming on the horizon.
09:25:19 <shapr> I hope to fix this library as I find bugs in it.
09:25:34 <shapr> I want to update it to rfc2822 after I've completed rfc822 compliance.
09:25:51 <SyntaxPolice> shapr: check out this link.  Its a CGI I wrote a few months ago in Haskell.  Maybe I could alter it to build a new and improved list of libraries for Haskell. http://opensource.cis.ohio-state.edu/FreeSoftwareOSU/
09:25:53 <e> return [[[p]],[[[[":"]]]],mb,[[[[":"]]]]]
09:26:02 <e> lots of pretty braces :)
09:26:10 <shapr> e: yah, I'm returning lists... I should really switch to real datatypes
09:26:35 <shapr> e: something like Message = Message [Field] ; Field = Subject_Field | From_Field
09:26:58 <shapr> then the return statements would just construct a type with the strings rather than those immense lists.
09:27:10 <SyntaxPolice> (click "see free software" to see the web page it produces)
09:27:40 <shapr> SyntaxPolice: looks good!
09:28:01 <shapr> e: how's the big city treating you?
09:28:08 <e> what are some of the more popular pieces of software that are written in haskell?
09:28:31 <shapr> GHC is the most popular Haskell compiler, it's written in Haskell.
09:28:36 <e> shapr: good, good. though i was in helsinki last week, visiting tuuli and checking out the artichoke film festival
09:29:03 <shapr> SandStar? wrote the BlueSpec compiler in Haskell, it's for hardware design
09:29:17 <e> shapr: are there any "end user" programs?
09:29:35 <shapr> well, there's this list: http://haskell.org/practice.html
09:29:47 <shapr> there's a web server in haskell
09:30:03 <shapr> recently extended by marvin-- to add apache style loadable modules
09:30:47 <shapr> e: are you going to come visit me in Boden for more PairProgramming? :-)
09:31:03 <e> shapr: how does one get from oulu to boden?-)
09:31:16 <e> i guess by bus might be good
09:31:25 <shapr> might be shorter to go by ferry :-)
09:32:11 <shapr> SyntaxPolice: do you have the source for that CGI available?
09:32:21 <e> i'm not sure there are any that go from oulu
09:33:25 <shapr> e: there's some other stuff I've written in that web dir. Mandelbrot.hs was my first try at Haskell.
09:34:14 <shapr> what kind of stuff are you into lately?
09:34:25 <SyntaxPolice> shapr: yeah. I can dig up that source code.
09:34:34 <shapr> there's an LDAP client with some decent ASN.1 support in Haskell.
09:34:55 <shapr> iirc, it only does BER encoding, no DER
09:35:02 <shapr> but looked easy to extend.
09:35:12 <e> shapr: i see you've started on banana :)
09:35:18 <shapr> yes, banana.hs works fine
09:35:22 <shapr> but Jelly is a pain
09:35:33 <e> i wonder what sort of stuff i'm into
09:35:35 <shapr> I really need to figure out how to make my own monads to finish Jelly
09:36:15 <shapr> I think the same sort of problems would be present in an irc protocol lib
09:36:18 <shapr> though much simpler
09:36:18 <e> my programming has been pretty practical and ad hoc lately. i wrote some python code to do network access control for this wlan we are building
09:36:41 <e> python daemon manipulating openbsd briding packet filter rules after you authenticate over https 
09:36:45 <eivuokko> Jelly?
09:36:50 <e> and that sort of stuff. not really big programming projects.
09:37:02 <shapr> eivuokko: Twisted.Spread support, see twistedmatrix.com
09:37:06 <liiwi> It's e
09:37:15 <e> hello liiwi
09:37:15 <shapr> Twisted is a server framework written in Python
09:37:34 <eivuokko> Yup.
09:38:24 <shapr> e: do you have an idea for something you'd like to write in Haskell?
09:38:30 <liiwi> e: I've been thinking about something similar for few linux iptables firewalls.
09:38:31 <e> shapr: mostly non-code stuff. eg today there was some rack mounting and unpacking of sun servers and talking to a guy who wanted to come write his doctoral thesis with us and doing all sorts of infrastructure setup for the wlan network
09:38:54 <shapr> someone's writing an iptables script in Haskell...
09:38:57 <shapr> I forget who
09:39:16 <shapr> I thought the idea of using the type system to prove certain properties about an iptables setup was really neat
09:39:20 <SyntaxPolice> shapr: www.syntaxpolice.org/~ijones/FreeSoftwareOSU.tgz
09:39:25 <shapr> yay!
09:39:26 * shapr downloads
09:39:38 <liiwi> basically I need something to replace Ferm
09:39:45 <SyntaxPolice> that was one of the first Haskell programs I wrote, so don't make fun of me :)
09:40:07 <shapr> SyntaxPolice: I won't, you should see my early Haskelly code :-)
09:40:18 <e> liiwi: well, i figure most wlans and ethernet switches will support 802.1x soon and that'll be sufficient for most stuff
09:40:30 <shapr> I remember desperately trying to figure out how to make a while loop...
09:40:35 <SyntaxPolice> hehe
09:40:38 <e> at least the cisco wlan access points can switch you to different virtual lans based on your credentials
09:40:57 <e> then you can just have static firewall rules for different virtual lans
09:41:01 <liiwi> vlans are unreliable and exploitable
09:41:23 <e> tell me more
09:42:04 <liiwi> never ever have a machine keeping cables separated
09:42:06 <SyntaxPolice> shapr: I didn't write CGI.lhs, by the way
09:42:19 <shapr> isn't that by Sven Panne or so?
09:42:21 <e> liiwi: like a firewall?-)
09:42:43 <shapr> ah, yes.. that's Panne's version of Meijer's CGI.lhs
09:43:16 <liiwi> e: I'm waiting for the day when someone brains exploit to get to remote machines through power cables.
09:44:29 <e> heh.
09:45:24 <e> but i don't see anything badly wrong with vlans security wise as long as you don't configure all the ports to be trunk ports :)
09:46:35 * shapr fights the type system
09:46:45 <liiwi> all you have to do is to crash the switch mildly, and you have all vlans
09:47:19 <eivuokko> Is there somekind of compiletime reflection system in haskell, or how would you write the jelly for haskell? (I suppose you were talking about haskell objects)
09:48:14 <shapr> SyntaxPolice: looks like it'd be easy to hack this into a simple input form
09:48:15 <Janni> shapr: you must not fight it. you control it. only in total harmony with it you can unfold. you must become one within it!
09:48:31 <Janni> +must
09:48:43 <e> liiwi: is it easier to make switches "crash midly" and do what you want in that way than eg firewalls or radius servers?
09:48:47 <Heffalump> eivuokko: Template Haskell is the compiletime reflection system
09:48:49 <shapr> foldr1 [shapr,haskell,hindley_milner_type_system]
09:49:00 <Heffalump> but it's only just being developed/implemented now, so expect rough edges etc (and you need to use GHC CVS)
09:49:19 <eivuokko> Heffalump, yea.  But that's just ghc extension, isn't it.
09:49:25 <Heffalump> yes
09:49:48 <liiwi> e: especially with ciscos
09:49:59 <eivuokko> Heffalump, I know what it is, it's the reason for my current interest in haskell.  Unfortunately I cannot get ghc head compiled in windows.
09:50:14 * liiwi welcomes pyrad
09:50:16 <shapr> eivuokko: I was thinking of two possible solutions, either unify everything into JellyType, or play with native Haskell types, and send them to a function that pretends to be a socket, but invisibly does all the de/encoding 
09:50:35 <e> liiwi: is this publically discussed somewhere i could take a look?
09:50:54 <shapr> eivuokko: I'm not sure how the invisible codec would work, but it would be a far better solution.
09:51:03 <Heffalump> eivuokko: ah :-(
09:51:14 <Heffalump> have you tried asking advice from the person that makes the binary packages for windows?
09:51:28 <liiwi> e: google 'exploit cisco vlan'
09:51:41 <SyntaxPolice> shapr: what do you mean about a simple input form?
09:52:09 <SyntaxPolice> you mean it would be easy to hack it into something for the libraries? Or do you mean to chanage the way the over-all design works?
09:52:10 <shapr> SyntaxPolice: er, sorry, incomplete thought...
09:52:17 <liiwi> e: cisco released bunch of docs about lan security stuff some time a go
09:52:20 <eivuokko> Heffalump, I was considering it (and I didn't even write to the ghc users list).  Just felt that I'll try it again next weekend and then bother those guys.
09:52:42 <liiwi> e: about arp spoofing and stuff like that
09:52:48 <shapr> SyntaxPolice: what you wrote would be great for a haskell lib directory.
09:52:58 <shapr> not sure how you'd update records though
09:53:03 <eivuokko> Heffalump, I need to learn a bit more of haskell before using it, also.  So no hurry :)
09:53:07 <Heffalump> heh :-)
09:53:15 <shapr> hi argv[0] 
09:53:35 <e> liiwi: thanks, reading about it now.
09:53:36 <argv[0]> hello ppl
09:53:38 <argv[0]> hi shapr
09:53:42 <SyntaxPolice> shapr: yeah, there' sno good interface to update a record.  The thing to do would be to delete it and reenter it into the form.
09:54:07 <SyntaxPolice> Without getting accounts and passwords mixed into it, I don't know how to let the users reenter their own information
09:54:23 <shapr> SyntaxPolice: or use project name as the key in a Finite Map
09:54:24 <SyntaxPolice> we could have a "replaces entry number XXX" thing which the admin cna approve.
09:54:26 <SyntaxPolice> yeah
09:54:30 <SyntaxPolice> or project name.
09:54:47 <SyntaxPolice> I"m thinking of building a GUI for the approval process.
09:54:55 <shapr> I'd start wiki-style, leave it totally open to entry and info replacing
09:55:11 <shapr> then if someone screws around with it, come back and add approval
09:55:14 <SyntaxPolice> thats probably a good idea really... skipping the approval step?
09:55:58 <shapr> it would be simpler
09:56:18 <shapr> we don't even know if it really requires approval, no one has tried to put in bad info :-)
09:56:28 <shapr> I'm a great fan of YAGNI
09:56:35 <e> liiwi: well, there was one bug in a cisco router in 1999, i would not say this counts against vlans too badly
09:56:43 <SyntaxPolice> we could populate the first version with the stuff thats already on the libraries page (the stuff that works)...
09:56:55 <SyntaxPolice> add the ideas of categories and replacing existing entries
09:57:14 <shapr> sounds good to me
09:57:20 <e> there did not seem to be other vlan hopping bugs in the bugtraq archive
09:57:30 <SyntaxPolice> hmm... I'm going to lunch.  I'll maybe start hacking on this when I get back, so send me an email if you have any great ideas :)
09:57:30 <e> let's see what the atstake paper says.
09:57:33 <SyntaxPolice> or if you want to help hack on it.
09:57:51 <shapr> SyntaxPolice: ok, I'll probably work on it tomorrow, I want to keep on rfc822 today..
09:57:58 <SyntaxPolice> ok cool. ttyl
09:58:31 <e> the atstake paper seems to have mostly good things to say
10:02:38 * shapr gets hungry also
10:03:21 <shapr> e: thought of something you want to write in Haskell?
10:05:10 <e> shapr: well, i occasionally have daydreams about writing something like the syntax testing thingy we currently have at ouspg, only better of course :)
10:05:23 <e> i've decided it would be better to do it in either lisp or haskell
10:05:34 <shapr> what sort of syntax testing does it do?
10:05:53 <e> since it's mostly compiler-ish stuff (syntax trees and such)
10:06:39 <e> it doesn't do much any on its own :) you feed it bnf and write rules and give it a hand in generating the anomalies and then you hope to break stuff
10:07:11 <e> there are links to papers and slides and a thesis on it on our web page.
10:07:23 <shapr> got an url?
10:07:49 <e> http://www.ee.oulu.fi/research/ouspg/
10:07:50 <shapr> I know there's a bnf to Happy converter than Marvin-- is thinking of packaging for Debian
10:08:30 <shapr> protos?
10:08:34 <e> yep
10:08:43 <shapr> oh, synax testing
10:09:17 <shapr> is this software open source?
10:09:37 <e> nope
10:09:40 <shapr> oh
10:09:55 <shapr> the bnf stuff should be pretty easy
10:10:09 <shapr> I have no idea what's involved in looking for anomalies...
10:10:12 * shapr thinks
10:10:16 <e> yeah, bnf is definitely not the issue ;)
10:10:26 <shapr> oh, yes I do!
10:10:35 <shapr> you could easily use QuickCheck to crack that problem.
10:10:44 <shapr> it's almost exactly what you're talking about.
10:10:44 <e> it does not look for anomalies, it generates anomalous protocol messages
10:10:51 <shapr> right, I understand.
10:11:08 <shapr> I think :-)
10:11:29 <shapr> yes, you should look at QuickCheck.
10:11:42 <e> you just tell it how you'd want to anomalise different bits in the protocol and then it goes off and generates suitable messages 
10:11:47 <shapr> http://www.math.chalmers.se/~rjmh/QuickCheck/
10:12:28 <e> most of the work is in doing stuff that i suspect there are no libraries for
10:12:49 <shapr> I'd write a BNF to Arbitrary converter
10:13:30 <e> i thought i'd start with the nontrivial parts and then add a bnf parser later if i get some of the code working
10:13:35 <shapr> if you want to write your own generators for instances of complex datatypes, you write something that fits the Arbitrary typeclass in QuickCheck.
10:15:22 <e> hmm
10:15:29 <e> i will look at this QuickCheck
10:15:41 <shapr> I have a ten line example of an Arbitrary instance, it creates random Board instances for the icfp2002 contest
10:15:51 <e> cool
10:15:52 <shapr> I'll stuff the whole module onto kungens...
10:16:49 <shapr> http://kungens.kemi.fi/~shae/src/haskell/Tests.hs
10:17:04 <shapr> that's just the testing code, doesn't include the whole client
10:18:12 <e> thanks 
10:18:32 <shapr> sure, if you have any questions about QuickCheck or Haskell, I'm happy to talk about them
10:18:45 <shapr> I'm a great fan of QuickCheck, I wish I had it in every language I use.
10:19:04 <shapr> I also wish I could figure out how to merge it with unit-test-first coding...
10:19:14 <e> so these properties that define what the cases look like, they are functions?
10:19:38 <shapr> yup
10:20:24 <shapr> once you get into more complex cases, you write an instance of Arbitrary, which says how to generate a test case for a certain type
10:20:36 <shapr> that's why I suggested a BNF to Arbitrary converter
10:20:40 <e> nice
10:21:09 <e> it looks like it does a little subset of what our tool does
10:21:10 <shapr> once you've written that, it'll take you very little time to start generating completely random cases to send 
10:21:57 <shapr> what sort of stuff does your tool do?
10:22:44 <e> well
10:23:18 <e> let's take a syntax that can have an arbitrary number of letters 'a' or 'b', and nothing else
10:23:25 <e> that is quite a simple syntax
10:24:01 <e> so you'd have a grammar like <letter-a> = 'a', <letter-b> = 'b'
10:24:18 <e> <my-syntax> = 0..n x (<letter-a> | <letter-b>)
10:24:57 <e> then i could tell it to generate all possible messages that fit that grammar, but it would not be terribly useful
10:26:00 <e> normally then you might want to add some simple anomalies like add a 'c' somewhere, so you'd write an anomaly where you say 'replace <my-syntax>.0 by (<old-value> | <letter-c>)'
10:26:56 <e> then you would want to limit what sort of messages it generates, and you would select for this test group only certain messages that match some rule
10:27:29 <e> then you can write rules that manipulate the grammar or the current message in different ways
10:27:41 <e> it gets rather involved but this is the extreme simplification :)
10:28:12 <e> if you want to know more, rauli's thesis on the web page might be good reading
10:28:18 <shapr> I'll check it out.
10:28:51 <e> if you're testing binary protocols, you write rules to do suitable padding and byte order conversions and maybe asn.1 encoding/decoding etc
10:30:12 <shapr> how would you need to extend quickcheck to get something similar to what you have?
10:30:50 <shapr> interactive control of the frequency of generating stuff?
10:30:55 <e> i suspect i would have to read it first
10:31:07 <e> it is not really interactive with our tool either
10:31:25 <e> actually it is not really "our" tool - the development is in a spinoff company currently
10:32:02 <e> but most of the employees are in the project so it's not really a big hurdle, just mentioned it to avoid misconceptions :)
10:32:13 <shapr> right
10:34:19 <shapr> do you get to make these cool graphs in the syntax tool?
10:34:31 * shapr is looking at the thesis
10:35:06 <shapr> I wonder if garbage testing would be a good feature to add to QC.
10:35:49 <e> what's the license on this QuickCheck thingy?
10:36:17 <shapr> probably lGPL or BSD
10:37:34 <shapr> License     :  BSD-style (see the file libraries/base/LICENSE)
10:38:24 <e> oh, so few lines of code
10:38:26 <e> pretty :)
10:38:49 <shapr> yah, it's good stuff
10:39:02 <shapr> there's a new version out for monadic testing
10:39:27 <shapr> which you'll probably want if you wish to directly inject test cases from quickcheck into systems you're working with.
10:40:07 <e> nah, i'll just be doing thinking and reading for a long time
10:40:36 <shapr> ok
10:40:46 <shapr> sounds like a fun thing to write
10:54:12 <kawfee> you guys are still talking...
10:55:16 <shapr> e: neat stuff
10:55:46 <shapr> e: I just skimmed the thesis, it looks like the general idea is "try to get out of the FSM"
10:56:27 <shapr> is it normal to build a simulation grammar from a BNF spec?
10:56:36 <shapr> I've seen the messages themselves defined in BNF
10:56:49 <shapr> but I don't think I've seen an FSM defined in BNF.
10:56:59 <shapr> then again, I've never implemented any network protocols.
10:57:01 <e> i don't think there are too many other people doing this stuff
10:57:52 <shapr> it would seem that RFCs would use some sort of FSM specification.
10:58:02 <e> hmm?
10:58:31 <shapr> it would make sense for network protocol RFCs to give an FSM spec like this
10:58:36 <e> oh
10:58:52 <e> yeah, you could design protocols like that
10:59:25 <shapr> would make sense.
11:00:56 <e> for modeling state i think there are better tools
11:01:02 <e> eg spin
11:01:03 <shapr> like what?
11:01:16 <shapr> don't think I've heard of it.
11:01:32 <e> http://spinroot.com/spin/Man/index.html
11:02:40 <shapr> neat!
11:04:46 <shapr> e: well, if you have more questions, ask me..
11:04:52 <shapr> in the meantime, back to rfc822
11:04:56 <e> yeah
13:18:22 <WaSTeD_AwAY> sup all
13:45:24 * Marvin-- curses at civ3
13:46:52 <eivuokko> Did you lose?
13:47:14 <Marvin--> I stopped playing in disgust
13:47:46 <Marvin--> I was massing my roman legions near the aztec border to go in and wipe them out, when suddenly the city they were in deposed my governor and went over to their side
13:47:52 <Marvin--> so I lost all the troops *mutter*
13:48:11 <eivuokko> Haha.
13:55:56 <hdaume> hi all
14:49:02 <shapr> hi hal
14:50:12 <Marvin--> hey hdaume, shapr
14:50:43 <shapr> hi Marvin-- 
14:50:56 <shapr> that's a good point that you mention about haskell compilation
14:51:18 <shapr> I hadn't thought about that.
14:51:30 <Marvin--> I've used ghc -O and ghci on slow ultrasparcs at chalmers, oh I know ;)
14:52:06 <shapr> most of my exposure to ghc has involved my dual 1.5GHz =)
14:52:36 <Marvin--> eek
14:53:02 <shapr> it's my web development machine ...
14:53:19 <Marvin--> suddenly, I want a web development machine
14:53:25 * shapr snickers
14:53:54 * Marvin-- is kinda happy about his new Acer 1300XC though :)
14:54:27 <shapr> what kind of machine is it?
14:54:35 <shapr> I know nothing about Acer...
14:54:58 <Marvin--> Athlon XP 1600+, 256M ram
14:55:05 <shapr> mmm, nice!
14:55:23 <Marvin--> very :) I've been practicing using the pointer pad by playing civ3 ,)
14:55:32 <whee> needs more ram, though :P
14:55:47 <Marvin--> it's enough
14:56:02 <andersca> Marvin--: it's a regular pad, right?
14:57:01 <Marvin--> yeah, I guess? What's an irregular like? :)
14:59:53 <andersca> Marvin--: I dunno
15:00:06 <andersca> Marvin--: anyway, try not to use it too much, especially clicking by tapping on it really hurts your fingers :/
15:00:22 <Marvin--> andersca: oh dear
15:00:50 <Pseudonym> This is a touchpad?
15:01:31 <Pseudonym> Damn there are way too many things I want to do.
15:02:21 <Marvin--> I've been wanting a laptop for half a year now :)
15:02:47 <andersca> laptops rock
15:03:39 <Pseudonym> I don't think they do.
15:04:15 <Pseudonym> The screens are too small, the batteries run out too fast, you can't upgrade 'em and they cost too much for the computing grunt you get.
15:04:43 <shapr> but they sure are portable
15:04:47 <Pseudonym> And I like optical mice, what can I say>?
15:04:54 <shapr> and you can code outside
15:04:56 <Marvin--> plug in a mouse
15:05:06 <shapr> and you can code on the train
15:05:09 <shapr> and on the bus
15:05:17 <shapr> and on the plane
15:05:21 <whee> batteries don't run out too fast, depends on what kind you get
15:05:26 <whee> I get ~5-6 hours on mine
15:05:29 <Marvin--> a laptop with a 17" screen wouldn't be very handy ;)
15:05:43 <shapr> on the other hand, I don't travel much
15:05:49 <Marvin--> I get somewhere around 4 hours on full burn, no power saving at all
15:06:22 <Marvin--> how hard is it to configure acpi on linux?
15:06:22 <shapr> so I blew my money on a dual Athlon MP 1.5 GHz that heats our house, and has a victorian decorative ironwork case
15:06:31 <shapr> not very hard
15:06:38 <shapr> but it's not guaranteed to work 
15:06:44 <Pseudonym> Assuming it's not a crowded train/bus.
15:06:44 <Pseudonym> I see what you mean, but give me a book any day.
15:06:45 <Pseudonym> If you're on a trans-Pacific flight, for example, laptop batteries are useless.
15:06:46 <Pseudonym> Ooh.
15:06:46 <Pseudonym> Where can you get those cases?
15:06:59 <Marvin--> I mean, I want maximum power saving...
15:07:00 <Pseudonym> Or were you referring to your house?
15:07:21 <det> Is it common for ghc not to compile under sygwin ?
15:07:23 <shapr> Pseudonym: heh, actually I have a chieftec case, which should have victorian ironwork, but doesn't
15:07:24 <Pseudonym> The problem, I think, is that laptops are too grunty.
15:07:28 <det> s/syg/cyg/
15:07:36 <whee> grunty?
15:07:36 <Pseudonym> If all I want to do is code, all I need is enough to run an editor and a single compiler.
15:07:47 <Pseudonym> I'd be happy with a 120MHz pentium.
15:07:49 <whee> grab an ibook then :)
15:07:50 <Pseudonym> And it wouldn't drain the batteries.
15:08:03 <det> I get test: 504: unknown operand
15:08:13 <shapr> Pseudonym: http://www.chieftec.com/products/dragon/da01wd.htm
15:08:13 <det> and 500 and 504 again
15:08:17 <shapr> but I have it in black
15:08:39 <shapr> Pseudonym: chieftec has a new line of burnished aluminum cases, I bet that would be gorgeous
15:08:46 <shapr> and probably improve your sound quality too
15:09:14 <shapr> det: ghc and cygwin are an exciting combination, check the ghc-users list
15:09:20 <whee> aluminum cases own, I love my lian-li
15:09:29 <whee> great for getting rid of heat
15:11:33 <shapr> I've tried to write code on my palm III with keyboard, and then compile when I get home
15:11:42 <shapr> but it's not really worthwhile
15:12:30 <Pseudonym> Very pretty.
15:12:30 <Pseudonym> However, my machines tend to operate with no case most of the time.
15:12:30 <Pseudonym> And when they do, the case tends not to be screwed on.
15:12:30 <Pseudonym> You never know when I'm going to need to swap over some ram from one to another.
15:12:48 * Pseudonym nods
15:13:22 <Pseudonym> When I had a palm, I mostly just played chess.
15:13:26 <Pseudonym> And lost.
15:13:28 <Pseudonym> A lot.
15:14:02 <Pseudonym> I've never been that good at it, but losing to a palm pilot is somewhat humbling.
15:14:09 <Marvin--> heh
15:15:25 <shapr> hah
15:15:40 <shapr> I use mine to take notes in swedish class
15:15:51 <shapr> now that I have a keyboard, I've been thoroughly tempted to use that in class
15:16:07 <shapr> but I'm kind of worried whether that'll upset people
15:16:34 <shapr> when I was in highschool, I discovered it's easier to write from right to left if you're left handed.
15:16:52 <shapr> that didn't go over well with my teachers though.
15:19:03 <shapr> I bet a keyboard would be the same kind of thing.
15:33:34 <Marvin--> time to sleep
15:36:42 <shapr> hiya Arnia 
15:37:27 <Arnia> Hey *swears at C++*
15:38:53 <shapr> hey, any word on the plone site? :-)
15:39:24 <Arnia> When my workload eases up... I just got snowed under by my department :(
15:39:34 <shapr> ok
15:40:09 <Arnia> I'm using Plone to do a project for it though.
16:09:21 * shapr reads http://www.pragmaticprogrammer.com/talks/HowToKeepYourJob/HowToKeepYourJob.htm
16:12:39 <Arnia> Oh?
16:13:11 <shapr> interesting
16:13:35 <det> HOpenGL won't work with hugs ?
16:13:43 <shapr> don't think so
16:13:47 <shapr> er, it might....
16:13:54 <det> suck
16:13:57 <shapr> since Hugs supports the FFI just as well
16:14:04 <shapr> but I *know* it works with GHC
16:14:21 <det> If onlt HOpenGL compiled >:|
16:14:22 <det> err
16:14:25 <det> ghc compiled
16:14:42 <shapr> det: aren't there binary downloads for cygwin?
16:15:08 <det> don't know if they are for cygwin , but it is 35 meg compared to 4 meg for source
16:15:23 <det> I am going to download it tonoght
16:15:27 <shapr> ok
16:16:17 <Smerdyakov> shapr, oh dear. Capitalism dependent advice is worse than no advice. :P (w.r.t. to URL you posted)
16:18:04 <steele> det: 35 meg? the freebsd package is just 15 meg
16:18:14 <shapr> Smerdyakov: I like having an income.
16:19:07 <whee> :)))))
16:19:19 <det> steele: the windows package has _everything_
16:19:20 <Smerdyakov> So live on a farm, or go back to school and become a researcher doing hopelessly impractical stuff =)
16:19:24 <whee> TH works. Wolfgang's cocoa bindings work. hooray.
16:19:46 <det> steele: maybe the freebsd package splits some stuff into other packages or doesn't compile some option stuff
16:19:55 <shapr> Smerdyakov: I'm not even picky about practical.
16:20:09 <shapr> Smerdyakov: I want an income, and I want to write code.
16:20:29 <Pseudonym> I don't necessarily want an income.
16:20:39 <Smerdyakov> Yeah, I just want to live happily.
16:20:50 <Pseudonym> I want to eat, I want my family to eat, and I want sufficient equipment so I can code.
16:20:53 <Smerdyakov> "Economists" who start everything from the basis of "money" are so full of it.
16:21:04 <Pseudonym> "Money" is just an abstraction.
16:21:14 <Smerdyakov> Hey, question for the channel on the semantics of IO monads.
16:21:19 <Pseudonym> Abstracted barter.
16:21:29 <shapr> Pseudonym: fair enough
16:21:32 <shapr> food and hardware
16:21:33 <Arnia> Money is a denotation onto the domain of power
16:21:46 <Smerdyakov> It seems like every primitive operation needs to be described as "random stuff happens to the state, and then something you asked for happens." Is that correct?
16:22:00 <Pseudonym> Kind of.
16:22:10 <Smerdyakov> Sounds onerous for proving anything
16:22:34 <Pseudonym> It's often best to think of IO as a script.
16:22:42 <Pseudonym> "Here's what I want you to do."
16:22:43 * Arnia thinks about abstracting maths as a denotation of itself and promptly vanishes in a puff of logic
16:22:56 <Pseudonym> "If you give me this, here's what I want you to do with the result."
16:23:12 <shapr> Arnia: hah :-)
16:23:43 <Arnia> shapr: I'm becoming quite enthralled with denotational systems. Types as denotation ;)
16:23:47 <Pseudonym> I don't think of the IO monad as encoding a state.
16:24:05 <Pseudonym> I think of it as a script for the state to execute.
16:24:19 --- topic: set to '["mo' nads than you", "We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/", "buddha debugger 0.4 http://www.cs.mu.oz.au/~bjpop/buddha/", "new  #sml channel for all your ML topics", "Helium 1.0 - Haskell for Students http://www.cs.uu.nl/~afie/helium/index.html", "New HTk release http://www.informatik.uni-bremen.de/htk/", "Tallest dwarf in Moria", "food and hardware"]' by shapr
16:24:24 <Smerdyakov> Pseudonym, nonetheless, you need to give it a normal functional interpretation at some point....
16:24:29 <shapr> Arnia:  what does that mean?
16:24:42 <steele> det: i see, there is an extra package for all docs
16:24:43 <Pseudonym> You don't need to give whatever calls "main" a functional interpretation.
16:24:56 <Smerdyakov> Hm. I see what you mean.
16:25:01 <Pseudonym> Everything under "main", you do.
16:25:08 <Arnia> shapr: I want to view types as the most general description of a denotation of an abstract concept
16:25:26 <shapr> Arnia: um, like what? can you give me an example?
16:25:26 <Pseudonym> Arnia: So basically, types are meta-meta-meta-data?
16:25:55 <shapr> is this like the Simon PJ paper where he used the Hindley-Milner type system to prove that enron was worth nothing?
16:26:15 * Pseudonym wonders how far up the meta-levels go before we leave maths and enter fuzzy natural language
16:26:35 <Arnia> shapr: Anything which fulfils a type can be called an object of the denotation of the type
16:26:39 * Pseudonym drops the open tin labelled "worms" and runs like hell
16:26:51 <Arnia> Pseudonym: You know exactly where I get my inspiration ;)
16:26:54 <shapr> Pseudonym: and remember, I have emacs, so I can open that can.
16:27:00 * Pseudonym laughs
16:27:29 <Arnia> Its my answer to that question I was posed earlier in the week
16:28:10 <Arnia> Types are nothing more than generalised description of the denotation of an abstract concept
16:28:21 <Pseudonym> I'm trying to envisage the object of the denotation of the type of the book of the film.
16:28:49 <Arnia> The type of Ones is just those features held in common by all objects that denote the abstract concept of /one/
16:29:23 <Pseudonym> You know, you could make a type system based on case-based reasoning.
16:29:24 * Arnia drops a denotation of the fixed point operator of #haskell and runs
16:29:54 <Pseudonym> You specify the features and let the compiler work out the type relationships.
16:30:00 <Arnia> Pseudonym: Probably, but I'm more interested in my type system atm ;)
16:30:05 <Pseudonym> :-)
16:30:08 <Arnia> Might be nice to look at...
16:30:10 <Pseudonym> I'm not saying this idea is a good one.
16:30:36 <det> does ghc contain HOpenGL yet?
16:30:40 <Arnia> You never know if you never try
16:31:05 <shapr> det: nope, it's separate
16:31:11 * Pseudonym will probably never know, then
16:32:06 <Arnia> I think I'm gonna try... I have reason to believe that my department is going to give Zhauhi Luo and Paul Callghan more funding for type theory research soon :)
16:32:10 <Smerdyakov> det, why would you want it to "contain" such a library?
16:32:28 <Pseudonym> The world needs a lot more type theory research.
16:32:30 <Smerdyakov> Arnia, where are you?
16:32:47 <Arnia> University of Durham
16:33:04 <Arnia> I like type theory... dunno why exactly...
16:33:38 <Pseudonym> I respect anyone who can handle all the sequent calculus.
16:33:47 <Pseudonym> I know it's not for me, though.
16:34:33 <Arnia> Its weird, cos its hard to find a way into the subject. I'm finding that Luo seems to have the same academic interests as I do though, which is nice :)
16:34:52 <Arnia> And Paul is such a nice guy...
16:35:46 <det> Smerdyakov: because I am surte cygwin isn't gonna wan't to compile it
16:36:05 <Smerdyakov> Arnia, it's not hard if you go to a school with many people working on it :P
16:37:18 <Arnia> Well, Durham does have quite a few but finding them is tough. They're all postgrads and I'm an undergrad and they're hidden away somewhere ;)
16:37:51 <Smerdyakov> Well, transfer to CMU. :P
16:38:02 * Arnia wonders about the philosophical implications of denoting someone else
16:38:34 <Arnia> I prefer a degree to a souped up A level ;)
16:38:43 * Smerdyakov arches an eyebrow.
16:38:45 <Smerdyakov> Huh?
16:39:22 <shapr> I just wanna learn stuff.
16:39:33 <Pseudonym> I'm with shapr on that one.
16:39:46 <Pseudonym> Stuff is interesting.
16:39:50 <Arnia> I have a good library here, it just takes patience... and I do have Paul and Luo who like chatting with me
16:40:06 <Smerdyakov> Arnia, but what did you mean by your previous statement?
16:40:11 <Arnia> So I'm not isolated, they're just trying me with a baptism of fire or something :)
16:40:45 <shapr> I'd like to take some classes because I'm missing some groundwork
16:40:48 <Arnia> Its a standard comment in Durham about US degrees... a joke, don't worry about it
16:40:58 <shapr> but all in all, it doesn't bother me that I have no degree, no formal education.
16:41:09 <Smerdyakov> OK. I've never heard of Durham before in my life. :P
16:41:38 * Arnia shrugs
16:42:13 <shapr> they teach stuff at durham.
16:42:24 * Pseudonym has heard of Durham
16:42:37 <malc> they are kissing the girls there too
16:42:40 <malc> and have the bull
16:42:45 <Arnia> Lectures are optional... you're meant to learn on your own. We're grownups now ;)
16:42:55 <Pseudonym> It's that way in most universities,
16:43:00 * Heffalump has never been to Durham, but suspects it's nicer than Pittsburgh, this not being hard :-)
16:43:05 * shapr laughs
16:43:19 <Pseudonym> You don't have to turn up, but if you are having trouble and you haven't turned up, expect no sympathy.
16:43:26 <shapr> the US uni I went to, if you didn't show up at lecture, you failed.
16:43:38 <shapr> I didn't like that, as my learning process is less structured than most.
16:43:41 <det> Arnia: at least we have guns, who needs proper education when you have gunes, really ?
16:43:50 <Pseudonym> That's true.
16:43:59 <Pseudonym> If you need to know something, threaten someone else until they tell you.
16:44:02 <Arnia> Yep. Although I never turn up cos if I did I'd be MORE confused... I find my lecturers quite good at that. I prefer books
16:44:14 <Pseudonym> That way, you don't need none of that book learnin'.
16:44:51 <Arnia> Durham is scarily beautiful... I love it up here in Geordieland ;)
16:45:19 <Heffalump> I've seen uglier places than Pittsburgh.
16:45:22 <Heffalump> But not often.
16:45:35 <Arnia> I'm glad I'm at Durham then?
16:45:45 <Arnia> s/?/;)
16:45:46 <Pseudonym> My parents, as previously mentioned, currently live in Bedford.
16:45:54 <Pseudonym> Is that uglier than Pittsburgh?
16:46:01 <Arnia> I come from Buckinghamshire
16:46:11 <Arnia> So I can sympathise ;)
16:46:20 <Smerdyakov> Pittsburgh actually isn't really "ugly"
16:46:20 <Pseudonym> I envisage my mother driving a bus to work.
16:46:25 <Smerdyakov> Just not "hapenning" :P
16:46:32 <Arnia> Is CMU in Pittsburgh?
16:46:38 <Smerdyakov> And very "cold" and "prone to precipitation" :P
16:46:45 <Smerdyakov> Yes.
16:47:02 <Pseudonym> Kind of like Edinburgh, then.
16:47:16 <Pseudonym> Or Hobart.
16:47:44 <Arnia> A friend of mine decided to go to Edinburgh to get pissed the other night on the spur of the moment and woke up in a hotel on Royal Mile
16:48:04 <Arnia> Even from Newcastle/Durham its still quite a trek ;)
16:48:38 <Pseudonym> I've never understood this, but then Australia is a big place.
16:48:55 <Pseudonym> If you stay within Britain it is by definition _not_ "quite a trek".
16:49:25 <Arnia> I don't like big places...
16:50:45 <shapr> move to sealand
16:50:47 <Smerdyakov> I'll take good people over good location any day =)
16:50:54 <shapr> yah, people
16:52:05 <Arnia> Durham is full of sweet, cheerful, intelligent and interested people... its great. Its just postgrads seem to spend most of their time in a reverie of their own thoughts and are only seen when they're in one of the college bars pissed out of their skulls ;)
16:52:48 <Smerdyakov> UK colleges.... very strange
16:53:09 <Arnia> Well, only Durham, Oxford and Cambridge have them...
16:53:21 <Smerdyakov> Yet more opportunity to encourage people to form groups and think of themselves as different and better than others because of random assocations =D
16:53:49 <shapr> Binkley: hi!
16:54:00 <Arnia> Not really... it means I know lots of people with other interests to me who don't do my course and are friends, good friends.
16:54:10 <Arnia> More interesting to get different perspectives.
16:54:32 <Smerdyakov> And what of "meeting people without relying on formal traditions" :P
16:54:47 <Binkley> hello
16:55:14 <shapr> Binkley: new to haskell? long time user?
16:55:23 <Arnia> The larger the group, the harder that becomes. I know my friends here cos I've met them in the bar
16:55:44 <Arnia> In a small group that is more managable and stable so chances of recontact are higher
16:55:45 <Smerdyakov> Social situations organized around drug use are another thing I despise.
16:55:46 <Pseudonym> Alcohol is always a good way to help you pretend that you're enjoying the company of whoever you're with.
16:56:04 <Arnia> I don't drink very often
16:56:09 <Binkley> I've been using it for 3 years or so
16:56:22 <Smerdyakov> Binkley, are you a grad student?
16:56:27 <Binkley> Yeah, at UC Berkeley
16:56:31 <Arnia> Pubs in the UK aren't about drinking so much as talking with people
16:56:31 <Smerdyakov> Binkley, with whom do you work?
16:56:41 <shapr> uh oh
16:56:43 <shapr> he said whom
16:56:45 * Pseudonym notes the juxtaposition of talk of social situations centred around drugs and the description of a "long time Haskell user"
16:56:48 <shapr> can't be a native english speaker
16:57:04 <Binkley> Alex Aiken, but that's sort of a coincidence... he was the only one who was willing to support me in working on functional languages
16:57:20 <Binkley> as you might be able to tell, I've found that Berkeley isn't the best place to do that sort of work
16:57:35 <Smerdyakov> Binkley, ah. I've applied to Berkeley to work in that general area, with the same general group of people.
16:57:45 <Smerdyakov> Binkley, I'll at least visit if I get accepted. =)
16:58:04 <Binkley> "that general area" = FP, or PL in general?
16:58:21 <Smerdyakov> PL/compilers in general, with a hope to focus on FP
16:58:25 <det> shapr, where do you live again ?
16:58:39 <Binkley> for PL in general it's great, for FP, not great
16:58:51 <Binkley> the focus is really on type-based analyses for C and such languages
16:59:16 <Smerdyakov> Yes, I noticed, but I've heard good things about Necula and Aiken, so.. *shrug*
17:00:01 <shapr> det: I live in northern sweden, why?
17:00:02 <Binkley> they're all good people, but if you're sure you want to do FP, I wouldn't recommend it
17:00:08 <Smerdyakov> I'm not sure.
17:00:12 <shapr> det: where do you live?
17:00:21 <Smerdyakov> I want to work on systems that allow people to use FP languages better.
17:00:22 <Binkley> I came here because I wasn't sure what I really wanted to do, but I wish I had gone someplace where there was *something* I knew I'd be interested in
17:00:29 <Binkley> Me too
17:00:43 <Binkley> well, hey, if you come here, we could start our own research group :P
17:00:50 <Smerdyakov> I think Cornell is my first choice at the moment.
17:00:58 <det> shapr: Las Vegas, I was under the impression that you lived in the US and then I just remembered you lived overseas
17:01:02 <Binkley> yeah, Cornell seemed really good when I was looking at schools
17:01:05 <det> shapr, why did you move to sweden ?
17:01:12 <Binkley> but I visited there in late March and it was snowing, so that kind of put me off
17:01:16 <shapr> det: well, I didn't like finland so much you see...
17:01:18 <Smerdyakov> CMU might be my first choice if I weren't already here. =)
17:01:25 <Binkley> heh
17:01:34 <shapr> det: and I moved to finland because I met this woman on ICQ....
17:01:40 <shapr> and now I'm here.
17:01:52 <det> shapr, what happened with bea ?
17:01:53 * Pseudonym made the woman move to him
17:01:54 * Arnia is happy at Durham ;)
17:01:55 <Smerdyakov> shapr, hooray for ICQ!
17:02:00 <shapr> Pseudonym: smart man
17:02:11 * Arnia has made someone move from Australia ;)
17:02:22 <shapr> actually, she said that was a viable option, for her to move to alabama
17:02:23 <argv[0]> bye all
17:02:32 <Pseudonym> I made her move _to_ Australia, so it looks like it evens out.
17:02:33 <shapr> but I had a crappy job, and she was running her own company.
17:02:45 <Smerdyakov> Binkley, how long have you been a grad student? (PhD, right?)
17:02:57 <det> shapr, what was wrong with finland and how do you like sweden ?
17:03:03 <Binkley> Yeah, PhD -- I'm only a second-year
17:03:21 <Smerdyakov> Binkley, where were you before?
17:03:27 <Binkley> I went to Wellesley for undergrad
17:03:32 <Binkley> yeah, not the biggest CS school in the world
17:03:42 <shapr> Binkley: what sort of FP stuff are you interested in? 
17:04:05 <Binkley> right now i'm working on type-inference-based deforestation
17:04:06 * Arnia wishes he wasn't a second year undergrad
17:04:13 <Smerdyakov> Binkley, do we have an Inside Agent there spreading the Statically Typed Functional Programming word? =)
17:04:16 <Binkley> basically, i'm interested in making the world safe for functional languages
17:04:17 <Arnia> Only one more year of spoon feeding
17:04:17 <Binkley> Heh
17:04:21 <Binkley> yes, indeed, Lyn Turbak
17:04:22 <Heffalump> hi Binkley
17:04:27 <Binkley> hey
17:04:50 <Smerdyakov> Is deforestation a simplifying transformation on programs?
17:05:06 <Binkley> Yeah, it's an optimization to eliminate intermediate lists, or trees -- hence the name
17:05:10 <Pseudonym> Actually, one of my goals some time is to investigate language-neutral operating systems.
17:05:11 * Heffalump was about to ask Binkley who s/he was, but then had it confirmed by the above :-)
17:05:15 <shapr> det: the part of finland I was in was extremely tribal, to the point of people not being accepted unless their family was multiple generations of resident
17:05:27 <Pseudonym> Making the world safe for functional languages includes not requiring it to be "foreign".
17:05:32 <Binkley> Yeah, I figured out who you were as well...
17:05:35 <shapr> det: sweden is much much more accepting, people actually walk up and talk to me in public!
17:05:49 <shapr> Binkley: oh oh, do you know who I am?
17:05:52 <Binkley> what do you mean by "foreign"
17:06:05 <Binkley> shapr: other than what's in your /whois info, no...
17:06:14 <Pseudonym> I mean that high-level languages require having a C environment around.
17:06:14 <shapr> well, ok
17:06:19 <det> shapr, that's the impression I get from .se people on IRC, very friendly
17:06:22 <Binkley> Oh, ok
17:06:26 <shapr> det: I think it's warranted.
17:06:31 <Binkley> yeah, the dependence on C definitely bites
17:06:37 <Pseudonym> And OS calls happen trhough some kind of "foreign function" (where "foreign" means "C") interface.
17:06:42 <Pseudonym> Unix == C virtual machine
17:07:17 <Smerdyakov> Pseudonym, yup. I'd like to make an OS with a standard lambda calculusy type system, global garbage collected heap, etc..
17:07:26 <det> shapr: that's what I went through in seattle, people were very nice and it throroughly confused me
17:07:54 <Heffalump> why was det in Seattle?
17:07:54 <det> Smerdyakov: so would I!
17:07:56 <Smerdyakov> Pseudonym, probably integration with certified code stuff to make it thesis-worthy =)
17:08:40 <det> Smerdyakov: but the trick is first to implement it on linux and gain popularity ;-)
17:08:52 <det> Heffalump: job
17:08:58 <shapr> det: truly
17:09:07 <det> Heffalump:couple years ago
17:09:11 <Heffalump> ah (Seattle's the only bit of the US I've spent any significant amount of time in)
17:09:14 <Pseudonym> Well I don't want the OS to be functional-specific either.,
17:09:24 <Pseudonym> Neutral means neutral.
17:09:27 <shapr> Heffalump: where in seattle?
17:09:41 <Heffalump> shapr: place called Redmond. Doubt you'd ever have heard of it ;-)
17:09:48 <shapr> you could write the OS on top of Daan's Lazy Virtual Machine.
17:09:56 <shapr> Heffalump: oh, duh, I remember...
17:10:01 <Heffalump> :-)
17:10:04 <det> Heffalump: Redmond was very .. interesting
17:10:15 <Heffalump> det: when were you there? And what group?
17:10:23 <Heffalump> if you're also implying you worked there, that is
17:10:23 <shapr> yah, LVM... and moon.com
17:10:26 <Smerdyakov> Pseudonym, I didn't say "functional specific"... but pretty much everything else seems to be encodable in lambda calculus style with minimal fuss.
17:10:34 <det> Heffalump: 2 years ago, group ?
17:10:41 <shapr> we could call the OS language something spicy... like... Cafe
17:11:04 <det> shapr: my OS is going to be called Flip
17:11:06 * Arnia wants a functional computer *sulks*
17:11:13 <det> shapr: unless it is already taken
17:11:13 <shapr> Arnia: me too
17:11:15 <Pseudonym> Smerdyakov: True.  I eas actually thinking of something like the pi calculus.
17:11:21 <Smerdyakov> The point is to have a standard type system/encoding with enough power to let you use the types of interfaces you want, defining them in a standard way for the OS/.
17:11:32 <shapr> I still like Janni's idea of CHaOS
17:11:47 <shapr> something Haskell OS
17:12:09 <Smerdyakov> Yes. Does Haskell have any concurrency library/whatever as cool as CML? =)
17:13:01 <shapr> what's CML?
17:13:02 <Binkley> concurrent haskell exists, but I don't know how cool it is...
17:13:11 <Smerdyakov> CML is Concurrent ML.
17:13:23 <det> shapr, I don't think haskell would make the best OS, it need to be a little lower level, no lazy evaluation,  no type classes, and haskell could be implemented on top of that
17:13:40 <Smerdyakov> Very functionalish concurrency system based on first class asynchronous communication/timing/etc. events
17:13:56 <Pseudonym> Someone has been working on an ML-based OS.
17:14:00 <Smerdyakov> Probably would work very smoothly as a monad.
17:14:02 <Pseudonym> That seems quite reasonable.
17:14:03 <shapr> det: you read about the STG yet?
17:14:06 <Smerdyakov> Pseudonym, you mean "Hello"?
17:14:08 <emu> Concurrent Markup Language
17:14:13 <Pseudonym> I don't know.
17:14:15 <emu> the next step after XML!
17:14:16 * Pseudonym can't remember
17:14:16 <det> shapr: nope, what's that ?
17:14:24 <shapr> det: spineless tagless G-machine
17:14:31 <Smerdyakov> Pseudonym, the only one I know was a now-abandoned masters thesis at University of Hawaii
17:14:57 <Smerdyakov> Pseudonym, and it supported one single threaded program running at once
17:15:05 <Smerdyakov> Pseudonym, it was "just" SML/NJ hacked to run without an OS
17:15:08 <det> shapr: that's what I call my ex-gf
17:15:33 <shapr> :-)
17:16:04 <emu> there's one based on OSKit I think
17:16:15 <emu> probably that
17:16:18 <Smerdyakov> Oh, and I heard about something partly using OCaml and partly using Lisp, I think.
17:16:31 <Pseudonym> emy: That's the one.
17:16:35 <Arnia> I'm trying to get a copy of Luo's book. The library copy is out until end of May on a research loan :(
17:16:39 <Smerdyakov> emu, do you have a URL?
17:16:58 <emu> no
17:17:04 <Smerdyakov> emu, a name? =)
17:17:18 <emu> maybe cliki.tunes.org has it listed
17:17:32 <shapr> det: manuel chakravarty is working on data parelellism
17:17:37 * Smerdyakov glowers. Tunes...
17:17:46 <Smerdyakov> I was surprised to see logs for this channel hosted on a tunes server.
17:17:52 <shapr> I think that has the most promise for transparently paralell programs
17:18:09 <shapr> Smerdyakov: they just dropped by and asked if we wanted it logged.
17:18:27 * emu points at clog
17:18:39 <Pseudonym> http://www.ai.mit.edu/projects/express/
17:18:41 <Pseudonym> I think that's the one.
17:18:45 <Smerdyakov> Pseudonym, LOL
17:18:45 <emu> it's run by Tril, I guess
17:18:49 <Smerdyakov> Pseudonym, that's ultra dead.
17:19:15 * Pseudonym didn't say it was recent
17:19:23 <Smerdyakov> Pseudonym, I think Olin Shivers was the only person ever working on it, and he now does "mostly Lisp stuff," I think
17:19:28 <Pseudonym> I said "has been working on".
17:19:52 <det> shapr, I was thinking that you might be able to accomplish that by have the compiler insert calls toa main loop closure
17:20:11 <Pseudonym> I still think it sounds like a good project.
17:20:34 <Pseudonym> One problem with using more advances languages for OS kernels is the issue of resource cleanup.
17:20:36 <det> Is there any way better than google for locating papers ?
17:20:45 <Pseudonym> det: Try citeseer.
17:20:47 <Arnia22> Researchindex
17:20:48 <det> all I ever find is citations to wwhat I am searching for
17:20:51 <shapr> yah, citeseer
17:20:56 <Smerdyakov> Yup. If only anyone had worked on it in the last few years =)
17:21:03 <Pseudonym> :-)
17:21:05 <emu> Pseudonym: what's the issue?
17:21:11 <shapr> I'd like to see the GHC runtime system running on bare metal
17:21:26 <det> citeseer just gives me a milloipn papers that cites the paper I am looking for
17:21:36 <Heffalump> probably that means that the paper itself isn't online
17:21:59 <Heffalump> google and citeseer are great, but in the end to do a proper literature search you still need a properly resourced uni library :-/
17:22:05 <shapr> which sucks
17:22:06 <flippo> I wish journals would just put all their ten-year-old papers online
17:22:07 <shapr> very much
17:22:10 <shapr> I agree
17:22:14 <Heffalump> ACM have done
17:22:31 <Heffalump> journals do have to make money too, unfortunately
17:22:46 * Arnia22 goes and sits in the library stacks and plays with the electronic shelving units
17:22:48 <Heffalump> and while the model is changing, we can't expect it to happen overnight
17:23:03 <flippo> It's usually too late to make money on papers have been out for decades
17:23:03 <Pseudonym> emu: ?
17:23:07 <Heffalump> (and I don't think we should, jumping into new technologies/ways of doing things without testing the water carefully first is dangerous)
17:23:12 <Pseudonym> Oh, sorry.
17:23:14 <flippo> that have been out
17:23:23 <Pseudonym> The problem is that resources hang around after they become garbage.
17:23:29 <Pseudonym> Unntil they're collected.
17:23:30 <Heffalump> flippo: well, by making an archive and charging for it they can
17:23:34 <det> shapr, happen to know tha name of the original STG paper ?
17:23:42 <Pseudonym> In an OS, you want them to become garbage straight away.
17:23:48 <det> citeseer needs a sort by date
17:23:49 <Pseudonym> For example, using reference counting GC.
17:23:53 <emu> you mean, freed straight away?
17:23:58 <Pseudonym> Yes.
17:24:02 <emu> why?
17:24:10 <flippo> Heffalump: as an author I also want to see my stuff online
17:24:16 <emu> (they become garbage the instant they are last dereferenced =)
17:24:21 <Smerdyakov> Yes, why treat, say, open files separately?
17:24:26 <Pseudonym> Yes, but they're not _freed_ then.
17:24:26 <Heffalump> flippo: sure, and most people now just put things on their webpage
17:24:32 <emu> so?
17:24:36 <shapr> det: no, I don't know...
17:24:37 <Smerdyakov> Do a GC when you run out of space for storing information on open files.
17:24:44 <flippo> Heffalump: I'm not certain all journals allow that
17:24:44 <Heffalump> but (a) you still need journals for peer review and (b) old stuff is still an issue
17:24:53 <Pseudonym> I think there's an argument for the kernel being written in a traditional procedural language, therefore.
17:24:57 <emu> why?
17:24:59 <Heffalump> flippo: most CS ones do if you say they have the copyright
17:25:00 <Pseudonym> Assuming it's a small enough kernel, anyway.
17:25:01 <emu> why do you need instant free?
17:25:11 <Binkley> det: http://research.microsoft.com/copyright/accept.asp?path=/users/simonpj/papers/spineless-tagless-gmachine.ps.gz&pub=34
17:25:12 <emu> remember, free is not an overhead-less operation
17:25:17 <Pseudonym> I know that.
17:25:18 <Heffalump> Pseudonym: yeah, you want something that's close to the hardware
17:25:23 <Pseudonym> The problem is one of contention.
17:25:36 <Pseudonym> Allocation is also not an overhead-less operation.
17:25:36 <det> Binkley: thanks
17:25:47 <shapr> the mythical Haskell ircbot must keep a database of research papers....
17:25:50 <Pseudonym> So you want fast free list management and so on.
17:26:12 <Smerdyakov> Free list? You just allocate at the end of the current heap space.
17:26:31 <Pseudonym> Oh, even worse.
17:26:31 <emu> not to mention, with a copying GC you don't have to worry about fragmentation
17:26:35 <Pseudonym> Fragmentation.
17:26:43 <Smerdyakov> Fragmentation? Where?
17:27:01 <Pseudonym> Sorry, not fragmentation.  You said fragmentation. :_)
17:27:09 <emu> one of the reasons why GC is more performant than manual memory management is the elimination of fragmentation
17:27:19 <Pseudonym> An OS has to worry about things like cache line optimisations.
17:27:30 <Smerdyakov> I think the problem is that Pseudonym has not yet given an OS resource that needs reference counted GC.
17:27:43 <Pseudonym> OK: open files.
17:27:46 <Smerdyakov> Why?
17:27:47 <Pseudonym> There's one.
17:28:25 <shapr> Pseudonym: a haskell ircbot?
17:28:27 <Pseudonym> lambdabot: Do you have a database of research papers?
17:28:28 <lambdabot> Sorry, I'm not a very smart bot yet.
17:28:32 <Heffalump> :-)
17:28:36 <Binkley> heh
17:28:43 <emu> lambdabot: \x.xx\x.xx
17:28:44 <lambdabot> Sorry, I'm not a very smart bot yet.
17:28:48 <shapr> heheh
17:28:50 <Heffalump> lol
17:28:51 * shapr bounces
17:28:53 <shapr> that's great
17:29:00 <shapr> Pseudonym: haskell source?
17:29:01 <Pseudonym> lambdabot: @modules
17:29:02 <lambdabot> Sorry, I'm not a very smart bot yet.
17:29:07 <Pseudonym> Hang on.
17:29:15 <lament> lambdabot: How smart are you?
17:29:15 * Arnia22 applies Y to himself in an effort to outdo shapr
17:29:24 <lambdabot> Sorry, I'm not a very smart bot yet.
17:29:25 <emu> the other point i want to make is that you can introduce low-level machine operations into a high level language as needed
17:29:28 <Heffalump> lambdabot: can you find all substitutions for f and x that make f x beta-reduce to 0?
17:29:29 <lambdabot> Sorry, I'm not a very smart bot yet.
17:29:31 <Pseudonym> Forgot how to use it.
17:29:34 <Pseudonym> lambdabot: @listchans
17:29:35 <lambdabot> I am on these channels: ["#haskell"]
17:29:36 <Smerdyakov> Pseudonym, I hope you get back to explaining why open files need to be reference counted!
17:29:40 <Pseudonym> Sorry, yes.
17:29:45 <Heffalump> bah, can't even do matching :-)
17:29:54 <Pseudonym> Open files hold pages of buffer cache, they hold cached inodes and so on.
17:29:56 <shapr> Arnia: er, what did I do?
17:30:09 <shapr> Y apply?
17:30:27 <shapr> lambdabot: @help
17:30:28 <lambdabot> Sorry, I'm not a very smart bot yet.
17:30:30 <Smerdyakov> Pseudonym, why does that mean they can't be copy-collected?
17:30:37 <shapr> hrm
17:30:39 <Arnia22> shapr: You bounced... I need to outdo that :)
17:30:44 <shapr> oh!
17:30:44 <Pseudonym> It's not that they can't be copy-collected.
17:30:50 <Pseudonym> It's that they use memory until they are collected.
17:30:56 <Pseudonym> And kernel memory is a precious resource.
17:31:09 <emu> assuming we'd choose a brain-damaged design like Unix
17:31:10 <shapr> Pseudonym: is that bot written in Haskell?
17:31:14 <Pseudonym> Yes.
17:31:14 * shapr bounces impatiently
17:31:16 <shapr> w00
17:31:22 <Smerdyakov> You don't need separate "kernel memory" and "user memory" if you only run code verified to be type safe.
17:31:23 <Pseudonym> It doesn't do very much.
17:31:28 <emu> then sure we'd have silyl resource limitations =)
17:31:30 <shapr> sources! I want sources!
17:31:46 <emu> Smerdyakov: type safe code can still delete all your files =)
17:31:54 <lambdabot> Please set me free!
17:32:01 <Smerdyakov> emu, if you export interfaces that allow that, short
17:32:03 <Binkley> lambdabot: free
17:32:04 <lambdabot> Sorry, I'm not a very smart bot yet.
17:32:09 <Smerdyakov> s/short/sure
17:32:27 <Heffalump> modifyIORef lambdabot free
17:32:44 <det> lambdabot: help
17:32:45 <lambdabot> Sorry, I'm not a very smart bot yet.
17:32:45 * Arnia22 wants to apply Y to lambdabot and set it free
17:32:47 <Smerdyakov> Pseudonym, do you still have an argument if we assume user code is verified safe?
17:32:56 <Pseudonym> Yes, I think so.
17:33:04 <Pseudonym> Kernel memory is not precious because of safety.
17:33:06 <det> lambdabot: 1+2
17:33:07 <lambdabot> Sorry, I'm not a very smart bot yet.
17:33:12 <det> I see
17:33:20 <shapr> lambdabot: @channels
17:33:20 <lambdabot> Sorry, I'm not a very smart bot yet.
17:33:29 <Pseudonym> It's because it's nonpageable and so on.
17:33:33 <shapr> lambdabot: @listchans
17:33:34 <lambdabot> I am on these channels: ["#haskell"]
17:33:40 <shapr> ok, he has one command...
17:33:42 <Pseudonym> lambdabot: @listmodules
17:33:43 <lambdabot> I have the following modules installed: ["hello_module"]
17:33:45 <Pseudonym> He has two.
17:33:48 <shapr> aha!
17:33:58 <shapr> does he use Andre Pang's runtime loading for GHC?
17:34:04 <Binkley> lambdabot: hello
17:34:04 <lambdabot> Sorry, I'm not a very smart bot yet.
17:34:10 <Pseudonym> There are more if you /msg to him directly.
17:34:21 <Smerdyakov> Well, I don't know too much about OS details yet. Perhaps I'll have to get back to you later =)
17:34:33 <emu> I think that's a restriction thanks to the Unix model
17:34:43 <Pseudonym> Perhaps.
17:34:51 <Pseudonym> It's true in microkernel OSes too.
17:34:58 <emu> but really this argument is a bit spurious
17:35:00 <Pseudonym> Generally, kernel memory is all that needs to be nonpageable there.
17:35:10 <emu> because there has existed several OSes written in higher level languages
17:35:25 <Smerdyakov> What does "nonpageable" mean?
17:35:27 <shapr> lambdabot: @hello
17:35:28 <lambdabot> Sorry, I'm not a very smart bot yet.
17:35:37 <Pseudonym> I see no reason why various non-kernel OS services can't be written in something like Haskell.
17:35:41 <Pseudonym> Say, your TCP/IP stack.
17:35:55 * shapr googles for Pseudonym's homepage, hoping for lambdabot sources
17:35:56 <Smerdyakov> Foxnet @ CMU has an ML TCP/IP stack.
17:36:17 <Pseudonym> He can leave and join channels too, as you can see.
17:36:19 <shapr> neat!
17:36:27 * Pseudonym isn't actually sure if lambdabot is male
17:36:29 <det> lambdabot: @part #haskell
17:36:30 <lambdabot> Sorry, I'm not a very smart bot yet.
17:36:35 <emu> Genera, Forth OSes
17:36:42 <Pseudonym> det: type /msg lambdabot @leave #haskell
17:36:45 <Pseudonym> det: type /msg lambdabot @join #haskell
17:36:46 <emu> I suppose Oberon and several Smalltalks too
17:36:52 <Binkley> that's OK, I'm not sure whether I'm male either
17:36:53 <Smerdyakov> emu, Forth is high level now? :D
17:37:06 <emu> tehehe
17:37:18 <shapr> Arnia22: why were there two of you?
17:37:22 <Pseudonym> Oh, and there's: /msg lambdabot @quit
17:37:25 <Heffalump> Pseudonym: are you assuming that Haskell would have comparable performance to lower-level languages?
17:37:38 <Pseudonym> Heffalump: It depends on the task.
17:37:42 <Smerdyakov> ML sure does ;-)
17:37:51 <Smerdyakov> http://foxnet.cs.cmu.edu/
17:37:59 <Arnia22> shapr: I'm using recursive definitions of myself
17:38:00 <Pseudonym> If it's a task for which lazy evaluation is the optimal solution, probably yes.
17:38:16 <Heffalump> Pseudonym: well, the TCP/IP stack thing, in particular
17:38:22 <Pseudonym> Probably not, no.
17:38:28 <Pseudonym> Might be good in ML, though.
17:38:36 <Smerdyakov> Is. IS good.
17:38:39 <Smerdyakov> See above URL :P
17:38:41 <shapr> Pseudonym: you don't have any software on your home page....
17:38:48 <Pseudonym> No, I don't.
17:38:51 <lambdabot> shapr is my love-dumpling
17:38:57 <shapr> wow
17:38:57 * Pseudonym laughs
17:39:08 <emu> I wonder what this bot has been applying herself to
17:39:09 <shapr> loved by a lambda, a geek's memoir
17:39:10 <det> wtf is a "love-dumpling" ?
17:39:20 <emu> det: jilted?
17:39:22 <lambdabot> I don't feel myself.
17:39:24 <shapr> haha
17:39:34 <Binkley> is that a lambda in your pocket or are you just happy to see me?
17:39:35 <lambdabot> Take that how you will
17:39:38 <det> emu: yes
17:39:40 * shapr snickers
17:39:44 <emu> actually, love by a lambda would probably make the bot a him
17:40:05 * emu assumes shapr is male
17:40:14 <shapr> emu: you never know...
17:40:24 <shapr> :-P
17:40:26 <emu> ...but on IRC, you can be 99.99% sure
17:40:33 <shapr> really?
17:40:52 <shapr> ok, I admit, I'm male.
17:41:07 <Smerdyakov> Chauvinist!!
17:41:08 <shapr> but I have a strong suspicion not that not everyone on this channel is male.
17:41:10 <Arnia22> We need programming languages with case systems and gender agreement
17:41:15 <emu> ...that anyone who claims to be female is really male
17:41:26 * shapr shrugs
17:41:31 <Smerdyakov> emu, I don't think you made that up. :P
17:41:37 <emu> probably not
17:41:40 <shapr> Pseudonym: I still haven't persuaded you to show me the code :-)
17:41:43 <Binkley> gender is to natural languages what pascal's type system is to programming languages
17:41:45 <emu> it's a well known fact
17:41:50 <lambdabot> I'm not even human.
17:41:54 <Pseudonym> shapr: You haven't asked.
17:41:54 <shapr> pascal had a type system?
17:42:07 <shapr> Pseudonym: could I please get the source for lambdabot?
17:42:08 <Binkley> sure, an array of 99 integers was a different type from an array of 100 integers
17:42:15 <Pseudonym> Sure!
17:42:16 <Arnia22> Gender is a very clever disambiguation system for noisy channels (sort of like #python)
17:42:18 <shapr> yay!
17:42:29 <shapr> Arnia22: huh?
17:42:29 <Pseudonym> Hang on a moment, got to log him out.
17:42:29 <Smerdyakov> You shouldn't diss Pascal when Haskell is so heavily influenced by it, or at least a close predecessor of it ;-)
17:42:34 <Binkley> or it would be if it weren't so ambiguous
17:42:38 <shapr> Smerdyakov: you are a sick man
17:42:39 <emu> ALGOL?
17:42:55 <lament> Smerdyakov: eh?
17:42:56 <Smerdyakov> emu, at least
17:43:00 <lambdabot> Bye everyone.
17:43:01 <emu> ALGOL is far superior to Pascal, which was a teaching language in the beginning
17:43:01 <Arnia22> Gender is one part of case-agreement systems
17:43:13 <emu> quite amusing how it caught on
17:43:21 <shapr> what, gender?
17:43:25 <Smerdyakov> Haskell uses English words to denote structure, instead of other haphazard things =)
17:43:25 <lament> Pascal is a toy
17:43:31 <Binkley> I will always have warm feelings for Pascal, as it was my first programming language, but its bondage-and-discipline nature leaves something to be desired
17:43:34 <lament> It's a fairly good toy
17:43:41 <lament> Although a bit outdated
17:43:47 <Smerdyakov> I think this insight is generally attributed to Algol.
17:44:36 <shapr> Pseudonym: lambdabot sounds like a very hackable project
17:44:40 <emu> yes, because using various strange and space-wasting words is a wonderful way to increase your line-count
17:44:49 * emu kicks MinML a few more times
17:45:05 <Binkley> Pseudonym: Could I please have the source for lambdabot too?
17:45:10 <Pseudonym> Anyone else want a copy of lambdabot, /msg me your email address.
17:45:14 <Smerdyakov> emu, tehe. Add 15-399; it's not too late ;-)
17:45:25 <emu> what's that
17:45:29 <Smerdyakov> Constructive Logic w/ Harper
17:45:33 <emu> oh that.
17:45:42 <Pseudonym> Hang on, I'd better put a licence on it.
17:45:45 <Pseudonym> :-)
17:45:47 <emu> end fi end end end end fi end end ;
17:45:48 <Binkley> heh
17:45:49 <Pseudonym> MIT good enough for everyone?
17:45:56 <shapr> sure
17:46:06 <shapr> or create a sourceforge project :-P
17:46:14 <shapr> I have lots of things I want to add
17:46:32 * Arnia22 reads Harper 1994
17:46:51 <emu> i'd take the course, if it wasn't taught by harper
17:47:09 <Arnia22> Oh?
17:48:13 <Smerdyakov> emu, he's doing a really good job, at a pace that is necessary for the average student's abilities
17:48:53 <Pseudonym> Sent.
17:48:56 <Smerdyakov> emu, it's hard for an instructor who's in love with the subject material as much as he is to do an outright _bad_ job
17:48:58 <Pseudonym> I'm off to have lunch
17:49:08 <emu> the problem is that he's in love with the subject material
17:49:11 <shapr> I'm off to sleepp
17:49:19 <Smerdyakov> emu, heh. Why is that a problem?
17:49:19 <Binkley> hmm, how could that be a problem?
17:49:21 <Arnia22> Type theory is cool though
17:49:24 <shapr> g'nite folks
17:49:27 * Arnia22 bounces
17:49:29 <Arnia22> Night
17:49:32 <emu> well
17:49:32 * shapr falls over
17:49:38 <emu> it's a problem when you become too attached
17:49:52 <Smerdyakov> How can you become too attached to material you are trying to teach?
17:50:21 <emu> you can be too attached when you can't offer a coherent argument defending an error in your book
17:50:32 <Smerdyakov> Sure, he makes unfounded statements all the time, but you just need to call him on it, and maybe he'll think up some explanation for next time =)
17:50:39 <emu> I did call him on it
17:50:49 <Smerdyakov> I know; we discussed this earlier. =)
17:50:49 <Binkley> well, that's not so much being attached to the material as being arrogant
17:51:38 <Smerdyakov> Though your point wasn't related to dynamic typing, per se, but to the fancy-schmancy CL version of dynamic typing.
17:52:05 * Heffalump realises that here might be a good place to get an answer to a problem he has with semaphores
17:52:10 <emu> you mean, real-world practical dynamic typing =)
17:52:26 <Heffalump> if people don't mind helping me with some homework :-)
17:52:26 <emu> unlike toy academic dynamic typing
17:53:07 * Arnia22 wonders what sort of universe an untyped universe would be and gets a headache
17:53:17 <emu> Arnia22: think "assembly"
17:53:31 <Binkley> I thought the universe *was* untyped...
17:53:32 <lament> Universe is typed?
17:53:34 <Smerdyakov> Heffalump, who knows. You could ask =)
17:53:56 <emu> lament: actually, it was carved in stone
17:53:58 <Arnia22> Are photons quarks? No... so the universe is typed to some degree :)
17:54:15 <emu> Arnia22: sure, dynamically =)
17:54:26 <Heffalump> ok, the problem is implementing a counting semaphore from binary semaphore(s)
17:54:27 <lament> Arnia22: oh, you're that person who thinks everything is a type
17:54:34 <lament> Arnia22: there's no hope for you, then :)
17:55:31 <Arnia22> lament: I worked out a formalism for that earlier... I'm going to talk to Luo and Paul about it as soon as I can
17:55:36 <Heffalump> the "model answer" to this problem uses an integer count, plus two binary semaphores, one to protect changes/tests of the count, and the other for waiting processes to block on
17:56:02 <Arnia22> emu: Dynamic types are just leaving off the labels ;)
17:56:12 * emu takes this moment to remind everyone that programming languages and math are just models
17:56:19 <emu> Arnia22: you have a strange concept of dynamic types
17:56:29 <Arnia22> emu: I'm joking
17:56:30 <emu> Arnia22: dynamic typing is putting labels on everything =)
17:56:43 <emu> quite literally
17:56:56 * lament puts a label on emu
17:57:04 * lament puts labels on quarks
17:57:06 * Smerdyakov donates an additional emu label
17:57:10 <Arnia22> emu: all functions are statically typed when they're called
17:57:14 * emu change-class's himself
17:57:21 * Arnia22 slaps himself
17:57:25 <emu> huh
17:57:35 <Arnia22> Sorry, I really don't want to start this again tonight. I'm too tired :(
17:57:49 <emu> Arnia22: hum, i can't tell if you really are confused, or just tired
17:58:58 <Arnia22> emu: I am viewing a function as a black box that exists on its own and which exists only when applied to something. I've been reading some very odd maths texts lately and my worldview has become skewed
17:59:28 <Smerdyakov> I can't tell if Arnia22 is really interested in anything useful, or just semantical puzzles ;-)
17:59:28 <emu> a function as a black box -- okay.  it is a mapping from its parameters to its results
17:59:28 <Arnia22> I tried to commute a traceability exercise in Software Engineering earlier... that's when I realised I was shattered
17:59:28 * Heffalump decides not to paste the code into IRC, if anyone cares, it's at http://urchin.earth.li/~ganesh/sems.txt - I want to know if there's anything wrong with CODE B as opposed to CODE A (because CODE A is the answer I've been given but it seems harder to explain than B)
18:00:06 <emu> what does this have to do with objects carrying types?
18:00:42 <Arnia22> Well, when the box exists it has to have some type to be a meaningful mapping even if the type is calculated only at application.
18:01:21 <emu> from domain to codomain
18:01:59 <emu> view functions as objects too
18:02:21 <Arnia22> Yep...
18:04:52 <Arnia22> You just accumulate a universe of functions, each with a well defined type even if that type wasn't known at compile time
18:05:23 * Arnia22 wonders if he's actually making sense or just saying random words in tiredness
18:05:23 <Arnia22> :/
18:05:38 <emu> i'm not sure what the point was
18:06:38 <Smerdyakov> Arnia22, be honest: do you care what the point is, or are you just in this for aesthetic value?
18:06:43 <Arnia22> I think I was viewing dynamic types as a static type system that doesn't label a function with its type but rather infers it as its used for the duration of use.
18:07:23 <Arnia22> I just like viewing things from other places... its a bad habit of mine. If I can see static types from dynamic and dynamic from static then I feel a lot more secure about both
18:08:05 <emu> a static type system doesn't label a function with its type
18:08:14 <emu> it labels the bindings to that function with the type
18:08:46 <Arnia22> Is that an abstract or concrete difference?
18:08:47 <Smerdyakov> A static type system has a type for every term and subterm....
18:09:22 <emu> and a dynamic type system has  a type for every object
18:09:41 <Smerdyakov> Yes. Not much of a difference, from a theoretical viewpoint =)
18:09:53 <emu> once the compiler/analyzer has run through the statically type language, there are no more types
18:10:29 <emu> the theoretical view is rather limited, usually, which is why academics have such a tough time understanding why people use dynamically typed systems
18:10:31 <Arnia22> What do compilers have to do with it? I don't care about real languages, just about the theory :)
18:10:53 <emu> the whole point of a /static/ type system is that it can be analyzed without running the program
18:11:01 <emu> so compiler/analyzer has a lot to do with it
18:12:08 <Smerdyakov> I think Arnia22 just admitted lack of consideration for anything but aesthetic value.
18:12:17 <Arnia22> Yep :)
18:12:37 <Arnia22> I'm someone who likes maths for its elegence, its why I like haskell :)
18:13:23 <emu> we usually send those sorts of people over to #scheme where they belong =)
18:13:43 <Arnia22> I prefer Haskell...
18:13:48 <emu> that works too
18:14:08 <Smerdyakov> shapr made me start an #sml channel, if anyone wants to join ;)
18:14:17 <emu> oh wow
18:14:22 <emu> will there actually be people there?
18:14:34 <Smerdyakov> 2 now
18:14:37 <whee> sml, heh
18:15:00 <Heffalump> hmm, I ought to, since most of my coding is in that atm :-)
18:15:03 <Smerdyakov> It doesn't cost anything to idle, and some day there might be enough people to have a conversation =)
18:15:16 <emu> well, I'm on channels with less people...
18:16:25 <Arnia22> I had the bizzare practical today of implementing map and filter in C++...
18:16:38 <Binkley> well, you can, it'll just be really frightening
18:16:41 <emu> I have way too many irssi windows open
18:17:58 <Arnia22> I found it very weird... so did everyone else though
18:18:21 <Smerdyakov> Arnia22, in STL?
18:18:23 <Smerdyakov> er
18:18:26 <Smerdyakov> with templates, I mean?
18:18:35 <Arnia22> Templates and using std::vector
18:20:44 <emu> and this man calls himself an asthete
18:21:18 <Arnia22> I have no choice, that was the practical and I had to do it
18:21:26 <Arnia22> I dislike C++ a lot :(
18:21:58 <Smerdyakov> What year are you, Arnia22?
18:22:39 <Arnia22> 2nd year... so only next year to go.
18:24:26 <Smerdyakov> Are you in a usually-3-years program?
18:24:38 <Smerdyakov> And are CS majors required to take classes that teach FP?
18:25:00 <Arnia22> Most degrees in the UK are unless they are undergrad Masters in which case they're 4 year
18:26:27 <Smerdyakov> I see. This relies on common practice of taking many "A-levels," right?
18:27:03 <Arnia22> And I'm not a Compsci major, I'm doing a Computer Science degree (well, an AI degree) which means that I follow their course of modules.
18:27:16 <Heffalump> smery: 18 year olds take 3-4 A-levels
18:27:21 <Heffalump> (normally)
18:27:38 <Arnia22> I took Maths, Physics, Chemistry and Further Maths
18:27:56 <Smerdyakov> Arnia22, please, be understanding of interational terminology differences =)
18:28:12 <Smerdyakov> international...
18:28:24 <Arnia22> Don't worry, I get very confused by our system too... its complicated
18:28:42 <emu> Further Maths
18:28:45 <Arnia22> Lack of patience isn't with you, its with trying to get the words straight in my own head
18:28:48 <Smerdyakov> I don't think I'm "confused." I think I know exactly what I mean, except I say it in American terms.
18:28:48 <emu> how descriptive
18:29:06 <Smerdyakov> emu, yes, it's pretty humorous =)
18:29:07 <Heffalump> basically we specialise earlier than people do in the US, so need to spend less time on our degrees
18:29:15 <emu> must be a british thing
18:29:26 <Arnia22> Further maths is simply two more modules of pure maths and two more modules from the applied list
18:29:28 <Heffalump> (I've also heard claims from many sources that our pre-18 education system is significantly better)
18:29:32 <Smerdyakov> Heffalump, you get the same effect in the US today with "AP tests," which are pretty much identical to "A-levels"
18:29:34 <Pseudonym> Back.
18:29:39 <Heffalump> Smerdyakov: right
18:29:55 <Heffalump> YAY! I found the answer to my semaphore problem with Google.
18:30:06 <Smerdyakov> Heffalump, it allowed me to graduate comfortably after 2.5 years instead of usual 4, though I'm still here through 3 years because of bad planning =)
18:30:13 <Heffalump> Google is the king.
18:31:17 * emu agrees about pre-college though
18:31:29 <Pseudonym> Heffalump: Still working on the semaphore problem?
18:31:31 <emu> it's worthless
18:31:41 <Heffalump> Pseudonym: I was, I'm not any more :-)
18:31:44 <Pseudonym> :-)
18:32:06 <Heffalump> I have to explain the answer to people tomorrow, and it was going to be a bit hard if I couldn't figure out why the "simpler" version didn't work.
18:32:20 * Pseudonym was just reading "Unix Systems for Modern Architectures" on the train this morning
18:32:28 <Pseudonym> So I happen to know the answer. :-)
18:32:34 <Pseudonym> What's the simpler version?
18:32:44 <Heffalump> oh, I just deleted the file :-)
18:32:52 <Smerdyakov> emu, you don't think post-secondary is pretty awful, too? =)
18:33:03 <Arnia22> We start specialising at 14 with GCSEs, specialise heavily at 16 with A levels and then almost completely specialise at 18 with our degrees... of course you can never stop specialising really ;)
18:33:06 <Heffalump> http://www.mcs.drexel.edu/~shartley/ConcProgJava/Semaphores/bis2.java though
18:33:23 <Heffalump> and the correct version is bis3
18:33:33 <Pseudonym> Incidentally, for those who got lambdabot, first thing I want to do is move the command parser over to something like Parsec.
18:35:46 <Pseudonym> Nice.  The actual point where the race condition happens is there in the comment for you.
18:36:29 * Arnia22 picks up a pitcher of coffee and jumps in
18:36:31 <Arnia22> Bye all
18:36:35 <Pseudonym> Bye.
18:36:37 <Heffalump> Pseudonym: yeah
18:36:37 <Smerdyakov> Hm
18:36:38 <Heffalump> oh hell.
18:36:47 <Smerdyakov> Arnia22 reveals 2 substance addictions in one sitting ;-)
18:36:48 <Heffalump> I actually /still/ don't get it :-)
18:36:57 <Pseudonym> Coffee and pitchers
18:36:58 <Pseudonym> ?
18:37:10 <Smerdyakov> Coffee and alcoholic beverages at the pub with postgrads.
18:37:21 <Pseudonym> Good point.
18:37:22 <Heffalump> the link claims that a V(blocked) can get lost, but I can't see how.
18:37:23 <Arnia22> To confuse you more... the pitcher denotes my mind :)
18:37:39 <Pseudonym> See, in Commonwealth countries, we don't call that a "pitcher".
18:37:49 <Pseudonym> Either "jug" or "bowler".
18:37:53 <Smerdyakov> Anyone know of any practical type systems that prevent deadlock? =)
18:38:03 <Pseudonym> Type systems?
18:38:12 <Arnia22> Luo is working on some I believe (I'm being serious ;)
18:38:25 <Arnia22> Pitchers strike me as larger
18:38:35 * Heffalump thinks a bit harder and finally does get it
18:39:15 <Pseudonym> Sorry for the joke so late in the day.
18:39:37 * Arnia22 was too tired to get the joke
18:40:32 * Heffalump doesn't get the joke either.
18:40:33 <Smerdyakov> Wow. Can it be? A word with the same meaning in the US and UK? ("pitcher")
18:40:49 <Heffalump> But at least I understand semaphores.
18:41:01 <Heffalump> Not that they were pissing me off or anything, you understand.
18:41:07 <Arnia22> I want to think about CPOs... I'll probably end up dreaming in C++
18:41:13 * Arnia22 shudders
18:41:27 <Pseudonym> What would UK people think was a "pitcher"?  Do they even use that word?
18:41:37 <Heffalump> I wouldn't use it for alcohol
18:41:41 <Smerdyakov> Arnia22, get thee out if thou sayest thou art OUT
18:41:46 <Pseudonym> Me neither.  That's a jug.
18:41:53 <Heffalump> I wouldn't use that either :-)
18:41:59 <Heffalump> jug is an Australianism to me
18:41:59 <Pseudonym> What would you call that, then?
18:42:02 * Pseudonym nods
18:42:08 <Heffalump> but it may also be from other parts of the UK
18:42:11 <Heffalump> I'm not sure, to be honest
18:42:12 <Arnia22> A large jug of beer is what I see a pitcher as
18:42:18 <Heffalump> I was just trying to work out what I would call it.
18:42:25 <Arnia22> I'm influenced by Geordie and Bucks though...
18:42:37 <Smerdyakov> In the US, you here advertisements for "[some amount of money] pitchers" by bars.
18:42:38 <Pseudonym> Complete the joke: Heffalump walks into a bar and orders...
18:42:47 <Smerdyakov> s/here/hear
18:43:13 <Pseudonym> Right.  Here it's "[money] jugs" which occasionally draws amusement from visiting Englanders.
18:43:31 <Pseudonym> More likely, though, the discount is by the pot.
18:43:32 <Pseudonym> Pot == glass
18:43:38 * Arnia22 attacks pointers and falls into an uneasy sleep
18:46:16 <Smerdyakov> I'd rather hear advertisements for "[some amount of money] [some unit of volume]'s of tofu" ;)
18:46:44 * Pseudonym doesn't drink
18:46:53 <Smerdyakov> Huzzah
18:47:00 <Smerdyakov> Maybe we're the only ones here of legal age in that category =)
18:47:14 <Pseudonym> :-)
18:47:14 * emu burps
18:47:19 <Pseudonym> I can't stand the taste of alcohol.
18:47:24 <Pseudonym> No moral objections at all.
18:47:27 <Smerdyakov> Does Australia have historically clean drinking water?
18:47:27 * emu had a pitcher today
18:47:31 <Pseudonym> Sure.
18:47:37 <Smerdyakov> That would explain how it's possible =)
18:47:44 <Pseudonym> Depends where you live, I guess.
18:47:57 <Pseudonym> Melbourne has some of the best drinking water in the world.
18:49:15 <Pseudonym> People think I'm very odd, but then I don't know of anyone who liked the taste of alcohol the first time they tried it.
18:50:10 <Smerdyakov> Alcohol gives you cancer!!! or somethin ;)
18:51:03 <Pseudonym> Research gives you cancer.  Studies prove it.
18:52:16 <Heffalump> Igloo doesn't drink, I think because he doesn't like the taste.
18:52:48 <Pseudonym> There you go.
18:52:57 <Pseudonym> There are few like us, but we do exist.
18:52:58 <Smerdyakov> Any other vegetarians here?
18:53:23 <Heffalump> Though Igloo also avoids huge numbers of varieties of food on taste grounds.
18:54:43 <Pseudonym> I'll eat anything.
18:54:57 <Pseudonym> Only thing I wasn't sure if I could manage (in my adult life) was cuttlefish.
18:55:02 <Pseudonym> But I ate it anyway.
18:56:53 <Smerdyakov> Not too healthy for you!
18:57:21 <Pseudonym> Probably not, no.
18:57:26 <emu> studies have been shown to cause widespread boredom
18:58:09 <Heffalump> ooh, Parsec makes slashdot
18:58:18 <Heffalump> (sadly it's not /our/ Parsec :-)
18:58:42 <Pseudonym> Damn.
18:59:03 <Smerdyakov> I'd like to see a "C isn't a very good language to use for daemons" headline on Slashdot some day ;-)
18:59:18 <Smerdyakov> Instead of just mentioning different buffer overflow exploits
18:59:55 <Pseudonym> We were just talking about that earlier.
19:00:05 <Pseudonym> Why do people use C, for heaven's sake?
19:00:18 <Pseudonym> Even C++ is far less prone to buffer overruns.
19:00:42 <Smerdyakov> Hooray for Cyclone!
19:03:05 <lament> Pseudonym: the good thing about C is, you can actually learn all of it.
19:03:16 <Pseudonym> Is that an advantage?
19:03:28 <Pseudonym> All it means is you have to learn lots of libraries.
19:03:30 <lament> To me, it certainly is. I hate using things I don't understand fully.
19:03:37 <Pseudonym> Third-party ones, to be precise.
19:03:55 <lament> With any language you will need libraries.
19:04:11 <Pseudonym> Yes, but with C, everyone's libraries are different.
19:04:23 <Pseudonym> With C++, everyone can use the STL.
19:04:29 <Pseudonym> With C, everyone uses something different.
19:04:40 <lament> They can use the STL, but they don't :)
19:05:01 <Pseudonym> They don't if their code pre-dates the STL.
19:05:17 <lament> Or if they use MFC :)
19:05:28 <Pseudonym> Ick ick ick.
19:05:37 <Pseudonym> OK, if they use MFC, they deserve what they get.
19:05:44 <Pseudonym> But the other option is the Win32 native calls.
19:06:10 <Pseudonym> Basically if they program under windows they're stuffed whatever they do.
19:08:28 <Smerdyakov> No, they can use libraries like wxWindows
19:10:55 <emu> the trouble is that people somehow think that libraries and language are different
19:11:25 <lament> Libraries and language are different.
19:11:26 * Smerdyakov walks up to emu's conversation and tacks a "FORECLOSED" notice to it.
19:11:55 <Pseudonym> Sure they're different.
19:12:03 <emu> how?
19:12:28 <Pseudonym> True, they can use wxWindows.  Or Qt.  Or FLTK.
19:12:29 <lament> Language is the set of primitives, plus the means of abstraction and combination.
19:12:43 <emu> why?
19:12:49 <emu> what's primitive?
19:12:52 <Pseudonym> My point remains: They can use something different from everyone else.
19:13:01 <emu> in wxWindows, perhaps the create window function is primitive
19:13:05 <Pseudonym> Primitive is whatever the compiler alone handles.
19:13:08 <lament> emu: That which is not from a library
19:13:27 <emu> lament: wowie, circular definition prize of the day!
19:13:52 <Pseudonym> I think it's arguable that _standard_ libraries, being part of the language definition, are "primitive".
19:13:58 <emu> here we are in a purely functional programming language channel
19:14:05 <Pseudonym> Third party libraries are definitely not.
19:14:06 <emu> and we can't even conceive of extending the language by writing functions
19:14:09 <lament> emu: no, see
19:14:23 <lament> emu: primitives are things which are not made of other primitives.
19:14:42 <Pseudonym> Primitive == fundamental
19:14:50 <lament> Abstraction is the means of creating new primitive-like things, i.e. extending the language.
19:15:12 <emu> language is what you use to describe your program
19:15:28 <emu> if you use + and - to do so, then that is your language
19:15:51 <emu> if you use CreateFoobarWindow and FrobObject_Mercilessly
19:15:55 <lament> emu: I don't like your definition.
19:15:55 <emu> then that is your language
19:16:10 <lament> emu: Because "Your program" is really vague.
19:16:10 <Pseudonym> Lament doesn't like fuzzy definitions.
19:16:18 <lament> Right.
19:16:26 <emu> it is a very logic-based definition
19:16:32 <emu> ask any logician
19:16:51 <lament> then what's "your program"?
19:16:52 <Pseudonym> I think it makes sense to make a distinction between the language and the "development environment".
19:17:04 <lament> emu: In C, I do things like #include <stdio.h>
19:17:16 <lament> emu: Is stdio.h a part of my program?
19:17:18 <Pseudonym> The development environment is whatever you build your program on, which includes libraries and tools.
19:17:24 <lament> If it is, printf() is not a primitive
19:18:11 <emu>      1. Any means of conveying or communicating ideas;
19:18:12 <lament> Pseudonym: Yes.
19:18:27 <lament> emu: FUZZINESS ALERT
19:18:36 * lament turns on the blinking red lights
19:18:48 <emu> I really couldn't care what you think
19:18:52 <emu> you're just wrong
19:18:54 <emu> heh
19:19:00 <Pseudonym> emu: Where does a tool like happy or yacc fit into this?
19:19:03 <emu> it's up to you now to figure it out
19:19:15 <lament> emu: In other words you admit defeat :)
19:19:25 <Pseudonym> No, he just read the FORCLOSED sign.
19:19:27 <emu> in other words, you need to learn something about logic
19:19:29 <lament> hehe
19:19:37 <emu> and a programming language like Lisp
19:19:46 <emu> where so called 'primitives' can easily be introduced by libraries
19:20:40 <lament> special forms aren't necessarily primitives.
19:20:47 <lament> if that's what you mean.
19:21:11 <emu> just take this one idea:
19:21:12 <Pseudonym> I think "language" is whatever is in the languag espec.
19:21:25 <emu> language is the means by which you express ideas
19:21:28 <Pseudonym> That's what "language specification" means, after all.
19:21:47 <emu> the C language specification lets you express certain ideas
19:21:51 <lament> emu: I don't like fuzzy definitions when non-fuzzy ones will do.
19:21:59 <emu> in combination with the GTK language you can write GTK applications
19:22:07 <emu> lament: will you stop throwing around words like an idiot
19:22:13 <Pseudonym> lament: I agree in principle, but I don't like arbitrary non-fuzzy ideas.
19:22:16 * lament shrugs
19:22:41 <Pseudonym> Personally, I think "language" has a common meaning amongst programmers which is fairly well understood.
19:22:45 <emu> have you grasped that I am not referring to any one particular language?
19:23:09 <Pseudonym> Yes, I have.
19:23:24 <Pseudonym> I also think you're also overloading a jargon term.
19:23:26 <emu> when I am on the #sdl channel, I talk in SDL terms and people understand what I am saying
19:23:35 <Pseudonym> FOLDOC has two definitions:
19:23:40 <Pseudonym> 1. <language, programming> {programming language}.
19:23:45 <Pseudonym> 2. <human language> {natural language}.
19:23:59 <Pseudonym> I think that's how we use the term in this industry.
19:24:06 <emu> now pick up some book on basic formal logic
19:24:10 <Pseudonym> Add "formal language".
19:24:24 <emu> and find out what it has to say about language
19:24:32 <Pseudonym> I've studied linguistics.
19:24:36 * emu has to go
19:24:39 <lament> yay
19:25:04 <Pseudonym> Language is a social contract between two parties.
19:25:25 <Pseudonym> In which they agree to understand each other.
19:25:48 <Pseudonym> (Unless it would be humorous not to, I suppose.)
19:33:41 <engstad> Greets.
19:33:45 <Pseudonym> G'day.
19:34:26 <engstad> Quick question. I've made a function that is of type: forall a m. (Monad m, Ord a, Fractional a) => Expr a -> m a
19:34:35 <engstad> How do I "run" this function?
19:35:01 <Pseudonym> I guess you piggyback it on another monad.
19:35:04 <Heffalump> do you have an Expr?
19:35:07 <engstad> Yes.
19:35:11 <Pseudonym> OK, then.
19:35:16 <Pseudonym> main = yourfunction expr
19:35:23 <Pseudonym> Sorry.
19:35:32 <Heffalump> main = do val <- yourfunction expr
19:35:37 <Heffalump>           print val
19:35:41 <Pseudonym> main = yourfunction expr >>\x -> putStr (show expr)
19:35:43 <Pseudonym> Yes.
19:35:50 <engstad> Ok. :-)
19:35:56 <Pseudonym> Assuming (Show a), of course.
19:36:14 <Pseudonym> But I think Show a => Fractional a.
19:36:17 <Heffalump> oh, "main = yourfunction expr >>= print", just to show off
19:36:31 <engstad> But this function is a "pure" function, how would I define that?
19:36:34 <Pseudonym> Could probably even obfuscate it better than that.
19:36:47 <engstad> Let's say it is a part of a bigger whole.
19:36:55 <Pseudonym> main = fmap print (yourfunction expr) >>= putStrLn
19:37:03 <Pseudonym> main = fmap show (yourfunction expr) >>= putStrLn
19:37:04 <Pseudonym> Sorry.
19:37:12 <engstad> heh, stop now.. :-)
19:37:27 <Pseudonym> Well, you need to piggyback it on top of some other monad.
19:37:36 <Heffalump> engstad: you could just use a unit monad
19:37:38 <Pseudonym> Do you have IO in the general area of where you need to "run" it?
19:37:50 <Pseudonym> Or you could use, say:
19:38:00 <engstad> Well, it's quite simple actually. Here's the "non-monadic" version:
19:38:07 <engstad> getConst (Const c)    = Just c
19:38:07 <engstad> getConst (Var v)      = Nothing
19:38:07 <engstad> getConst (Unary op v) = case (getConst v) of
19:38:07 <engstad>    Nothing -> Nothing
19:38:07 <engstad>    Just c  -> Just (eval (Unary op (Const c)))
19:38:08 <engstad> getConst (Bin op l r) = case (getConst l) of 
19:38:10 <engstad>    Nothing -> Nothing
19:38:12 <engstad>    Just c  -> case (getConst r) of
19:38:14 <engstad>           Nothing -> Nothing
19:38:16 <engstad>   Just d  -> Just (eval (Bin op (Const c) (Const d)))
19:38:21 <Pseudonym> Easy then.
19:38:24 <Heffalump> is the idea of making it monadic so that you can later add monad operations that it'll use?
19:38:25 <Pseudonym> Use the Maybe monad.
19:38:30 <engstad> So, I really just wanted to clean it up.
19:39:04 <Pseudonym> case  getConst expr  of { Just x -> x ; Nothing -> error "" }
19:39:12 <Pseudonym> Or fromJust
19:39:18 <Pseudonym> Or whatever you want to do to catch the error.
19:39:23 <Heffalump> engstad: the course at http://spivey.oriel.ox.ac.uk/mike/proglan/outline.html follows a very similar pattern of development to what you're describing, btw
19:39:24 <engstad> *nod*
19:39:37 <engstad> I'll look at it. Thanks.
19:40:37 <engstad> Yes, the idea was: make it cleaner + make it easier to change later.
19:55:28 <engstad> Heffalump: It's similar, but I am going a different direction.
19:55:51 <engstad> I'm interested in rewriting rules that "match" simd instruction set.s
19:56:50 <Heffalump> engstad: like BURG?
19:57:05 <Heffalump> 'lo
19:57:08 <Binkley> heya
19:57:20 * Heffalump ought to be in bed
20:00:15 <engstad> I haven't heard about BURG. What is it? 
20:02:12 <Heffalump> see http://research.microsoft.com/~toddpro/
20:03:28 <Heffalump> there's also a BURG implemented in the JIT compiler in Mono
20:03:50 <Pseudonym> Sorry, you're trying to write a code generator?
20:04:05 <engstad> Yes, for a non-common processor.
20:04:16 <Pseudonym> There's a really easy way to do it.
20:04:25 <Pseudonym> Bottom-up dynamic programming.
20:04:29 <Pseudonym> It's damn easy in Haskell.
20:04:50 <engstad> Bottom up dynamic programming... 
20:04:58 <Pseudonym> OK, here's the idea:
20:05:00 <Heffalump> sorry, I should have been more clear, BURG generates code that does precisely that
20:05:08 <Pseudonym> Yes, but Haskell does it for you.
20:05:46 <Heffalump> anyway, bed calls
20:05:51 <Heffalump> night all
20:05:51 <Pseudonym> Night.
20:05:56 <engstad> G'Night!
20:06:32 <Pseudonym> The general idea is that you can compute the optimal code sequence for a node by computing the optimal code sequences for the subnodes, then trying all templates which match the current node.
20:07:06 <Pseudonym> Picking the most optimal one.
20:07:25 <engstad> That's roughly what I was planning on.
20:07:29 <Pseudonym> Right.
20:07:32 <Binkley> gnight
20:07:34 <Pseudonym> In Haskell this is very, very easy.
20:07:35 <Pseudonym> Night.
20:07:38 <engstad> First however, I need to some simple optimizations.
20:07:42 <Pseudonym> Because you have lazy evaluation.
20:07:52 <engstad> Like: Unary Neg (Unary Neg x) ==> x
20:07:57 <Pseudonym> Sure.
20:08:02 <engstad> "-(-x) == x".
20:08:06 <Pseudonym> DEfinitely do peephole simplifications on the tree first.
20:08:26 <Pseudonym> The general idea is this:
20:08:38 <Pseudonym> You add an annotation to every node in the tree which corresponds to the optimal code sequence.
20:08:56 <Pseudonym> In that annotation you put a call to the function which computes said optimal code sequence.
20:09:03 <Pseudonym> Lazily evaluated, naturally.
20:09:10 <engstad> Makes sense.
20:09:37 <Pseudonym> That function tries all templates (perhaps using a nondeterminism monad), using the optimal code sequences for any subnodes that it needs.
20:09:44 <Pseudonym> Picks the best and returns it.
20:09:55 <Pseudonym> Then you just read the annotation off the topmost node.
20:10:05 <engstad> Interesting.
20:10:14 <Pseudonym> One of the reasons why lazy evaluation works well here is that there might be different ways to evaluate a node.
20:10:42 <Pseudonym> For example, in C, you might need to compute a node as an lvalue or as an rvalue.;
20:10:56 <Pseudonym> So you need two annotations there.
20:11:06 <Pseudonym> And if you don't use one, it doesn't get evaluated.
20:11:35 <engstad> Yes, that seems to be the way to go.
20:11:48 <engstad> Of course, I have some "additional" constraints, but I can see where it is going.
20:11:48 <Pseudonym> One suggestion.
20:12:03 <Pseudonym> As well as returning the optimal code sequence, it should also return the "cost"
20:12:03 <engstad> Sure.
20:12:16 <Pseudonym> Where "cost" may be multiple costs.
20:12:25 <Pseudonym> e.g. register usage complexity, code size complexity etc
20:12:28 <engstad> Actually, I should always return several options.
20:12:33 <Pseudonym> Yes.
20:12:39 <Pseudonym> Uhm... no.
20:12:42 <Pseudonym> Well, maybe.
20:12:55 <Pseudonym> You should return the "cheapest" solution for every kind of cost you might care about.
20:13:10 <Pseudonym> Then you might also return a weighted cheapest solution.
20:13:21 <engstad> See, there's a couple of ways of doing divides: [ div vq rega regb, mul res res vq], [ rcsp vp rega, mul res res vp].
20:13:29 <Pseudonym> Yes.
20:13:47 <Pseudonym> And there are several ways of getting a divide operation.
20:13:52 <engstad> In the end, I want to find a "balanced" solution.
20:14:05 <Pseudonym> Binary Mul (Binary Divide (Const 1) x) y
20:14:07 <Pseudonym> For example.
20:14:14 <engstad> Exactly.
20:14:23 <Pseudonym> That's what all the templates are for, of cours.e
20:14:38 <Pseudonym> Anyway, that's my suggestion.
20:14:41 <engstad> These "templates", would they be ordinary functions?
20:14:51 <Pseudonym> They'd look something like this:
20:15:19 <Pseudonym> Uhm...
20:15:24 <Pseudonym> Well, yes, sort of.
20:15:28 <Pseudonym> They'd be pattern matches.
20:15:39 <engstad> Yes.
20:15:41 <Pseudonym> If you use a nondeterminism monad, you mplus them all together.
20:15:50 <engstad> *nod*
20:15:51 <Pseudonym> You can also put in boolean guards of course.
20:16:02 <Pseudonym> Always make sure there's a default template for each node which will never fail.
20:16:19 <Pseudonym> Which may require poor code, but at least that way there will always be a solution.
20:16:35 <Pseudonym> Code generation design is basically inspecting generated code, looking for improvements, and then adding templates. :-)
20:17:04 <Pseudonym> You'll probably want to implement each template as a case-switch on the topmost constructor.
20:17:10 <Pseudonym> Then mplus all of the possibilities below that.
20:17:10 <engstad> See, I also have a different sub-problem. The operations are "vector" commands. So, [add rega regb regc] is really rega.xyzw = regb.xyzw + regc.xyzw.
20:17:19 <Pseudonym> OK.
20:17:40 <Pseudonym> Why is this a problem?
20:17:50 <engstad> Well, it'll explode the search space. :-)
20:18:10 <Pseudonym> Not really.;
20:18:21 <Pseudonym> It will be O(nm) where n is the number of nodes and m is the number of templates.
20:18:25 <Pseudonym> In the worst case.
20:19:34 <Pseudonym> The easiest way to write it is as a bunch of mplus'd templates.
20:19:49 <Pseudonym> But you can optimise the search space a bit by using nested pattern matching in some cases.
20:20:01 <Pseudonym> BURG is really a glorified pattern matching compiler.
20:20:08 <Pseudonym> Haskell, OTOH, has one built in.
20:20:08 <engstad> :-)
20:20:45 <Pseudonym> Anyway, did that help?
20:21:22 <engstad> Yes, indeed.
20:21:27 <Pseudonym> Kewlies.
20:21:44 <engstad> Thanks... I'll still be struggling with Haskell, but I'll get over it.
20:21:58 <Pseudonym> What's this for, as a matter of interest?
20:22:22 <engstad> Oh, it's a tool for myself to optimize.
20:22:43 <engstad> I.e., I'm really coding in assembly, but I want to make sure my routines really are optimal.
20:23:02 <engstad> For instance, I want to make an optimized FFT and (iFFT) routine for the processor.
20:23:31 <engstad> The FFTW approached led me to believe I should do something similar.
20:23:56 <engstad> Besides, it's a good way to learn Haskell. :-)
20:24:35 <Pseudonym> Cool.
20:25:05 <engstad> Oh, and the system is the VU processor in the Playstation 2.
20:26:59 <Pseudonym> Gotcha.
20:27:14 <Pseudonym> I wrote most of a C code generator for an 8-bit RISC chip using this technique.
20:27:16 <Pseudonym> In Mercury.
20:27:24 <engstad> :-)
20:27:31 <Pseudonym> Supporting Duff's device in a bottom-up way was kinda interesting.
20:27:47 <Pseudonym> But it didn't need backpatching
20:27:59 <Pseudonym> You generate the labels at the points they're needed and pass them back too.
20:28:37 <Pseudonym> So I actually returned, effectively (CostVector, LvalCode, RvalCode, CaseTargets)
20:28:51 <engstad> Cool.
20:28:57 <Pseudonym> Er... not quite.
20:29:02 <Pseudonym> So I actually returned, effectively (LvalCode, RvalCode, CaseTargets)
20:29:13 <Pseudonym> Where LvalCode and RvalCode are pairs of (CostVector, Code)
20:29:28 <Pseudonym> It worked, too.
20:30:34 <engstad> So many people are being payed by Microsoft these days... :-)
20:32:35 <Pseudonym> :-)
20:32:44 <engstad> Btw, I read some really interesting stuff from HP.
20:32:50 <Pseudonym> What stuff?
20:33:27 <engstad> They built this dynamic JIT parser for _binaries_, and managed to run these faster than the binaries.
20:34:23 <Pseudonym> Interesting.
20:34:45 <Pseudonym> There's a paper from somwehere in MS research about a finite state machine-based JIT compiler.
20:34:51 <Pseudonym> Apparently it's very fast.
20:35:12 <engstad> The point was that static compilation often cannot do the same kind of optimizations as dynamic measuring of code-paths do.
20:35:40 <Pseudonym> This is true.
20:36:07 <engstad> I.e., during running the program, the system figures out the most common flows, and by extracting these out it can streamline these.
20:36:26 <Pseudonym> Yes, Hotspot does that too.
20:36:57 <engstad> The cool thing of course was that they used binaries, and not some kind of byte-code.
20:37:04 <Pseudonym> Yes, that is cool.
20:37:08 <Pseudonym> What processor was it for?
20:37:34 <engstad> Some risc processor.
20:37:39 <Pseudonym> Something simple, I would think.  Sparc or MIPS or ARM or something.
20:37:59 <engstad> ARM i think.
20:38:18 * Pseudonym can't see it happening for the ia-64 any time soon
20:42:17 <engstad> Ah well, gotta go. Take care!
20:48:45 <Pseudonym> Fairwell.
20:48:50 <Pseudonym> Farewell, rather.
