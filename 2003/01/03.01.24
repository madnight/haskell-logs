00:14:54 <dark> Bah.  The hard part of uncc's typing is the weird rules of C!
00:17:20 <Marvin--> heh
00:18:07 <Marvin--> this alliance for digital progress seems scary
00:18:28 <dark> Never heard of that.
00:19:02 <Marvin--> /.
00:19:25 <dark> Hmm, is this different from the deal that BSA made with the RIAA?  A countermove?
00:19:28 <Marvin--> Apple, Cisco Systems, Dell, Hewlett-Packard, Information Technology Association of America, IBM, Intel, Microsoft, Motorola, etc. are going against Hollywood re DRM
00:19:40 <dark> It can't be a countermove, Microsoft is part of both.
00:19:47 <Marvin--> exactly! That's what I mean with scary
00:20:00 <Marvin--> I can understand why Apple would oppose it
00:20:18 <Marvin--> but e.g. Intel have already said "we'll be using Palladium"
00:20:20 <dark> The name itself is about as trust-inspiring as "The Glorious Democratic People's Republic of Foo" :)
00:20:25 <Marvin--> yup ;)
00:20:44 <Marvin--> they do what I do, pick a bland title so you can change your opinion later :)
00:21:07 <dark> Like "institute for software choice"?
00:21:46 <Marvin--> that's micros~1's campaign against free software, isn't it?
00:21:51 <dark> The problem with news from slashdot is that the sites are always slashdotted :-)
00:22:15 <dark> Marvin: Yep, it's a vehicle for disinformation.
00:22:29 <Marvin--> [The Alliance's platform: "OK, OK, we'll cave in and put DRM chips in every device we sell, just please, pretty please, don't tell Congress on us!"] (from a /. comment)
00:23:15 <dark> Hmm, sounds like this might be the _result_ of the BSA deal.
00:23:25 <dark> They're not opposed to DRM, just to laws mandating it.
00:23:28 <Marvin--> I guess the alliance is about "we want to put our own proprietary DRM standard on our hardware instead of an open government-mandated one"
00:23:38 <Marvin--> BSA?
00:23:53 <dark> And they've already had this concession from the RIAA, so now they get to have a glorious charge against oppression and injustice -- on an issue they've already settled in a smoke-filled room.
00:24:16 <Marvin--> those are the best ;)
00:24:17 <dark> Marvin: "Business Software Alliance", I think.  Microsoft's enforcement arm.
00:24:32 <dark> Marvin: They're the ones who come in and "Audit" companies that don't pay enough Microsoft tax.
00:24:57 <dark> Marvin: They also wrote the new EU software patent policy, and are the ones behind the EUCD.
00:24:58 <Marvin--> aha
00:25:26 <dark> Well, not "the ones" -- obviously Disney was involved with the EUCD :-)
00:25:44 <dark> But Bruce Perens has documents showing their authorship of the patent policy.
00:25:54 <Marvin--> I'm not the least surprised
00:26:47 * Marvin-- looks at the ADP web site and idly wonders if design is built into IIS
00:28:02 <dark> "
00:28:06 <dark> "Industry Cooperation Is Good For Consumers" is part of their platform.
00:28:31 <dark> They cite DVD as a stunning example of the success of anti-copying technologies.
00:28:59 <Marvin--> ... e.g. ADP is by no means the Good Guys :)
00:29:03 <Marvin--> err... i.e.
00:29:16 <dark> Sheesh, they're not even hiding it.  Their platform is that they should be implementing DRM without government interference.
00:29:28 <Marvin--> yup
00:29:40 <Marvin--> Which makes me wonder why Apple is there!
00:30:12 <Marvin--> I guess you could say "okay, if DRM is inevitable, at least we want to be there designing it so it won't go *all* the way to hell"
00:31:55 <Marvin--> .oO(DRM should of course not be confused with the DMR)
00:34:25 * Marvin-- does away with d-shlibs in libd-i and laughs evilly
00:37:08 <dark> Marvin: That's the collaborator attitude :)
00:37:08 <Marvin--> whops, I should rush off to a lecture
00:37:36 <dark> The EFF reasoned similarly when it got involved in drafting the DMCA.
00:37:49 <Marvin--> if PC makers start using DRM, it's a good bet that my next computer will be a mac
00:37:50 <dark> If they'd just left it alone, it would have been far more evil to start with, and probably roused stronger public opposition.
00:38:07 <dark> In addition to being more clearly unconstitutional.
00:38:30 <Marvin--> ...lecture :)
02:04:00 * shapr yawns
02:10:19 <shapr> hi rublik 
02:19:12 <jadrian> hello
02:19:23 <shapr> hi
02:19:28 <jadrian> hi shapr
02:19:42 <shapr> how's life?
02:19:46 <jadrian> right now?
02:19:50 <shapr> sure :)
02:19:57 <jadrian> Grrrrrrrrrrrrrrrr!
02:20:00 <jadrian> :)
02:20:15 <shapr> yow
02:20:18 <jadrian> I think that resumes the way I feel
02:20:20 <jadrian> ;)
02:20:51 * jadrian is feeling tempted to define another (*) using multi parameters class
02:21:17 <jadrian> so you have a bunch of expressions where you keep needing to multiply ints and floats
02:21:26 <jadrian> how do you do that in an elegant fashion?
02:23:16 <jadrian> fromIntegral everywhere looks way to bad...
02:29:01 <jadrian> brb or bbl
02:38:48 <shapr> grr
02:38:59 <shapr> I missed jadrian :-(
02:39:01 <shapr> distracted by work
02:40:11 <shapr> hi d33p 
02:40:27 <d33p> hey
02:41:16 <shapr> written any cool code lately?
02:41:42 <d33p> hmm, no not really
02:41:55 <shapr> written any code lately? :-)
02:43:00 <d33p> hehe, yea
02:43:25 <d33p> i updated my C stringlib to work arbitary primitive objects 
02:43:41 <d33p> just got to write the unit tests and i cant really be bothered.. :\
02:43:54 <shapr> I like unit tests
02:43:58 <shapr> I write them before the code
02:44:04 <d33p> i should have done that 
02:44:05 <d33p> hehe
02:44:18 <shapr> it's a nice way to do things
02:44:27 <d33p> yep
03:08:01 <Derhunne> hi @all
03:08:22 <shapr> hiya
03:10:02 <Derhunne> im back again.....
03:12:00 <shapr> what's up?
03:13:42 <Derhunne> im still trying to implement a tree...
03:14:41 * shapr has a seed
03:16:21 <shapr> um, I don't do DCC
03:20:31 <Pretender> re
03:20:34 <shapr> hi
03:20:48 <Pretender> Derhunne is dead ...
03:20:57 <shapr> heh, ok :-)
03:30:21 <shapr> Pretender: have you tried to make a tree?
03:33:20 <Pretender> yeah....but i began to learn last night
03:34:08 <Pretender> but i can't understand the functional programming right now....
03:35:58 <shapr> it takes some time, but it is very powerful
03:36:01 <shapr> have you read some of the tutorials?
03:36:33 <Pretender> im on page 50 in the Haskell Textbook of the University of Oklahoma...
03:36:55 <Pretender> and i read the first four chapters of gentle Introduction to haskell 
03:37:17 <shapr> what do you think so far?
03:37:40 <Pretender> pretty heavy stuff for someone who learned Java, C and PHP...
03:37:57 <shapr> I'm sure you can do it
03:38:17 <Pretender> i'm too :) but the important factor is time
03:38:42 <shapr> learning haskell will improve your programming skills in Java, C and PHP
03:39:57 <Pretender> Our Prof at the University....tries to teach Haskell now for one Week, what means, we've got 4 hours to understand it....and now we should implement a FIFO Queue, Tree
03:41:42 <Pretender> and after one more week of haskell....we could forget it all....there's no need to know further on....
03:42:00 <shapr> that's not true!
03:42:31 <Pretender> i know what you try to say....its important...but this is the oppinion of my prof...
03:44:40 <Pretender> but instead of saying....there's no need to implement e.g a tree...we have to do it....and we will get points for it, which are important for our exam in late february
03:53:58 <Pretender> hmh
03:54:28 <shapr> ?
03:54:57 <Pretender> nothing sorry....i try to understand some code samples
03:57:16 <shapr> any questions?
03:57:58 <Pretender> thousands :)
04:02:09 <Pretender> i found a better german tutorial... perhaps i try it first
04:16:56 <shapr> yow, the GUI haskell list has a knock down drag-out fight going on...
04:32:30 <Pretender> hmh the module tree i have to implement should have functions which returns the elements in postorder preorder and inorder
04:55:45 <Pretender> is this implementation of a queue correct :
04:55:46 <Pretender> module Queue where
04:55:46 <Pretender> type Queue a = ([a],[a]) 
04:55:46 <Pretender> emptyQueue :: Queue a
04:55:46 <Pretender> emptyQueue =  ([],[])
04:55:46 <Pretender> enqueue                   :: Queue a -> a -> Queue a
04:55:48 <Pretender> enqueue (ws,[])         x =  (ws,[x])
04:55:51 <Pretender> enqueue (ws,rs@(r:rs')) x =  (x:ws,rs)
04:55:52 <Pretender> dequeue              :: Queue a -> Queue a
04:55:54 <Pretender> dequeue (ws, x:r:rs) =  (ws, r:rs)
04:55:57 <Pretender> dequeue (ws, [x])    =  ([], reverse ws) 
04:56:00 <Pretender> first            :: Queue a -> a
04:56:01 <Pretender> first (ws, r:rs) =  r
04:56:53 <shapr> what do you think?
04:57:03 <Heffalump> looks exactly like the one I was suggesting
04:57:15 <Pretender> hmh ?
04:57:51 <Pretender> what do you mean heffalump ?
04:57:57 <Heffalump> i.e. it looks fine
04:58:27 <Heffalump> btw you can use rs@(_:_) instead of rs@(r:rs') in enqueue
04:58:41 <Heffalump> _ is a placeholder where you want to do a pattern match but not bind the result
04:58:53 <Pretender> hmh.....ok
04:59:06 <Pretender> now its time to try....the tree....
04:59:07 <Heffalump> s'partly a matter of style, I just find it helps avoid having to make up useless variable names
05:00:25 <Pretender> hmh so i have to overwrite rs@(r:rs') with rs@(_:_) simply ?
05:01:22 <Heffalump> you don't have to, you just could
05:02:13 <Igloo> Or you could just write rs as the [] case is already dealt with
05:02:40 <Pretender> ok i could do it in this way ...
05:03:17 <Heffalump> oh, true
05:04:21 <Pretender> you mean: enqueue (ws,rs[]) x = (x: ws, rs) ????
05:05:08 <Heffalump> no, just (ws,rs)
05:05:16 <Heffalump> the point is that the case above already matches []
05:05:31 <Heffalump> so if this case is being tried rs will have to be non-empty, so there's no need to explicitly pattern match to check that
05:06:50 <Pretender> so i reduce the line to enqueue (ws, rs) x = (x:ws, rs) ?
05:06:55 <Heffalump> yeah
05:07:05 <Heffalump> again, you don't have to, and your code is fine as it is
05:07:07 <Heffalump> you just could
05:07:56 <Pretender> ok, but it would be the better style ?
05:08:08 <Heffalump> I wouldn't necessarily claim better.
05:08:29 <Heffalump> I'd say that using rs@(_:_) instead of rs@(r:rs') was explictly better, because it makes it clear they won't be used
05:08:52 <Heffalump> but some people prefer to distinguish cases explicitly rather than relying on fall-through, and I think that's reasonable.
05:09:35 * shapr just realized that the UniForFM Htk thing has been compiling on his system for a very long time...
05:09:37 <Pretender> ok...thanks guys
05:10:24 <Pretender> but don't think thats it...i've more questions ;)
05:13:05 <Pretender> Now a question to binary trees in Haskell
05:13:35 <Pretender> i should implement a function wich gives back, the elements in preorder, inorder and so on....
05:14:16 <Pretender> for example postorder....is the following right ?
05:14:16 <Pretender> elements_post :: Tree a -> [a]
05:14:16 <Pretender> elements_post Empty = [ ]
05:14:16 <Pretender> elements_post (Branch left label right)
05:14:16 <Pretender> = elements_post left ++ elements_post right ++ [label]
05:16:14 <Heffalump> yes
05:16:37 <Heffalump> you can do it faster with an accumulating parameter, but I doubt you're expected to
05:17:08 <shapr> yow,
05:17:11 <shapr> Htk is cool
05:20:03 <Pretender> i read about it....about i doesn't understand it right now....when i have enough time i try, but not yet
05:20:38 * shapr is suddenly in shock
05:21:09 <Pretender> why are you shocked shapr ?
05:21:18 <shapr> I found haskell code for talking to emasc
05:21:20 <shapr> lots of code
05:21:32 <Pretender> emacs you mean ?
05:21:37 <shapr> yah
05:22:00 <Pretender> sure, there also wordlist etc. for ultraedit and so on...
05:22:50 <shapr> this looks like the Haskell equivalent of PyMacs
05:24:28 <Pretender> damn....i forgot sth important....my data type has no empty...
05:24:55 * shapr cackles happily
05:25:07 <shapr> instance Functor EmacsContent where
05:25:11 <Pretender> the exercise ist declared as the following: data Tree a = Leaf a
05:25:11 <Pretender> | Branch a (Tree a) (Tree a)
05:26:11 <Pretender> ähm Branch (Tree a) a (Tree a)
05:29:39 <dark> I'm giving up on C casting rules.  I'm going to define my own rules which make sense, and just produce C code with lots of explicit casts.
05:31:35 <shapr> heh
05:31:59 <shapr> aha, now gnuclient works... why not before?
05:32:22 <Pretender> can you look at this part of my implementation ?
05:32:34 <Pretender> data Tree a = Leaf a | Branch (Tree a) a (Tree a)
05:32:34 <Pretender> insert:: a -> Tree a -> Tree a
05:32:34 <Pretender> insert x (Branch left label right)
05:32:34 <Pretender> 	= if x<= label
05:32:34 <Pretender> 	then Branch (insert x left) label right
05:32:34 <Pretender> 	else Branch left label (insert x right)
05:32:36 <Pretender> countElements :: Tree a -> Int
05:32:38 <Pretender> elements_in :: Tree a -> [a]
05:32:40 <Pretender> elements_in Empty = [ ]
05:32:42 <Pretender> elements_in (Branch left label right)
05:32:44 <Pretender> = elements_in left ++ [label] ++ elements_in right
05:32:48 <Pretender> elements_pre :: Tree a -> [a]
05:32:48 <Pretender> elements_pre Empty = [ ]
05:32:50 <Pretender> elements_pre (Branch left label right)
05:32:52 <Pretender> = [label] ++ elements_pre left ++ elements_pre right
05:32:54 <Pretender> elements_post :: Tree a -> [a]
05:32:56 <Pretender> elements_post Empty = [ ]
05:32:58 <Pretender> elements_post (Branch left label right)
05:33:00 <Pretender> = elements_post left ++ elements_post right ++ [label]
05:34:09 <shapr> weird... the test program is confused.
05:34:41 <shapr> oh
05:35:33 <Pretender> @Heffalump you've got ICQ ?
05:35:57 <shapr> yikes, now what's it doing?
05:36:13 <shapr> whoa, cool
05:39:12 <shapr> yow, this haskell code created a new emacs buffer that has buttons in it that can send events back to the haskell code.
05:39:45 * dark watches shapr tie himself into knots.
05:39:55 <shapr> I'm enjoying myself very much :-)
05:40:19 <shapr> the extents are slightly wrong though.... hrm
05:40:28 <dark> Pretender: You need to decide whether your base case is Empty or Leaf.
05:40:46 <shapr> ohh
05:41:37 <shapr> hrm
05:42:56 <Pretender> have to leave now guys thx
05:43:00 <shapr> have fun!
05:43:06 <Pretender> thx :)
05:54:42 <shapr> wow, this is very cool code.
05:55:27 * shapr snickers
05:55:32 <shapr> they use Parsec to parse sexps
05:59:38 <shapr> this is very cool stuff
06:02:10 <shapr> I really like Htk
06:02:14 <shapr> I think I'll bring it up on the GUI list
06:02:17 <shapr> hi det, what's up?
06:02:35 <andersca> det == it
06:03:01 <shapr> huh?
06:03:01 <det> it ?
06:03:13 <det> as in a person named it? no.
06:03:13 <shapr> oh, yes, it swedish :-)
06:03:16 <det> ohh
06:03:46 <det> shapr: patiently waiting for a well deserved beating on the haskell mailing list
06:04:42 <shapr> what did you ask?
06:05:08 <shapr> oh, lazy eval?
06:05:08 <det> lazy evaluation vs CPS
06:05:26 <shapr> total thread size, five messages
06:05:34 <shapr> that's pretty good for that amount of time
06:06:56 <det> 1 is a dupe
06:07:28 <shapr> norback says "that simulates it, but we want it built-in"
06:07:50 <andersca> norback?
06:07:59 <det> yeah, who is norback ?
06:08:25 <andersca> martin?
06:08:34 <shapr> yah, martin norback
06:08:48 <andersca> I know him
06:08:59 <shapr> he's a chalmers guy I think
06:09:29 <andersca> yeah
06:09:42 <andersca> he's here sometimes
06:09:45 <andersca> with the nick norpan
06:09:49 <shapr> oh, that's him
06:10:02 <shapr> det: you used haskell much?
06:10:14 <shapr> I really like Htk...
06:10:25 <shapr> I'd like to test it on win32, see if it works equally well.
06:12:39 <lament> CPS simulates lazy evaluation?
06:12:59 <det> shapr: no :)
06:13:22 <shapr> det: it's a nice language, you should try it.
06:13:50 <det> shapr, I want to make my own language! :D
06:14:05 <lament> woo
06:14:05 <shapr> I do too
06:16:43 <Heffalump> the world has too many languages already
06:17:25 <shapr> doesn't have any spoken programming languages.
06:18:35 <det> Heffalump: and they are all teh suck
06:19:32 <lament> shapr: cobol!
06:20:14 <lament> The problem with making your own language is coming up with something that doesn't suck.
06:20:14 <shapr> eww
06:20:34 <shapr> I suspect it's the other way around
06:20:47 <shapr> come up with something, see how it sucks, repeat with less suckage
06:26:27 <shapr> does Tcl/Tk work on Mac?
06:28:57 <det> most likely
06:29:04 <det> ecspecially OSX
06:29:32 <shapr> have you ever seen it running on MOX?
06:29:42 <shapr> or even system 9 or earlier?
06:29:59 <det> man, mutt is sucking
06:30:09 <det> can't even reply to a mailing list correctly
06:30:15 <shapr> gnus...
06:31:02 <dark> Define "correctly"?
06:31:09 <det> OH
06:31:13 <det> that was directed to me
06:31:20 <det> not the mailing list
06:31:35 <det> erk
06:32:17 <rublik> where i can find haskell-mode for FSF/Emacs?
06:33:17 <shapr> most linux distributions come with a premade package, you can also find it on the haskell.org website
06:33:17 <shapr> would you like an exact url?
06:33:40 <shapr> my Htk post is titled "crass platform"
06:33:52 <shapr> is that cute or what? :-)
06:36:29 <det> shapr: puns are evil
06:36:55 <det> shapr: a tool of the PSU^H^H^HHSU even
06:37:47 <SyntaxPolice__> rublik: if you use Debian, you can just type "apt-get install haskell-mode" and it'll install it for you.
06:39:20 <shapr> det: I said "Tcl/Tk is ugly enough to be called 'crass platform'..."
06:39:23 * shapr snickers
06:39:42 <shapr> hm, HToolkit seems to gaining momentum...
06:40:00 <shapr> Axel Simon and Daan Leijen are both working on it.
06:40:08 <shapr> *but* it runs on Gtk, which isn't very Mac friendly
06:40:09 <shapr> hmmmmm
06:40:21 <andersca> get me a mac and I'll port it
06:40:50 <shapr> claims on the list are that Gtk just won't be a good thing on Mac
06:41:18 <shapr> because MacOS X has a way of doing things that is very different from Gtk
06:41:23 <shapr> not that I know about that myself
06:42:05 <shapr> mmmm
06:42:18 <shapr> daan attached some working demo code to his email, I'm convinced.
06:46:06 <dark> Ack, my esc key is stuck.
06:46:53 <dark> I use vi, I can't program without it
06:47:01 * shapr grins
06:47:03 <dark> Oh, my exclamation point is broken too.  But not the 1.  Weird.
06:47:04 <shapr> must fix!
06:52:06 * shapr learns about xalan
06:53:15 <shapr> hi dennisb!
06:53:15 <dennisb> Hi all!
06:53:16 <shapr> how are ya?
06:53:26 <dennisb> Life is just fine!
06:54:27 <dennisb> I've not been here for a week or two, did I miss anything?
06:54:48 * dennisb don't expect an answere
06:54:52 <shapr> nothing huge...
06:55:04 <shapr> there's a neat discussion on the gui@haskell.org list
06:55:06 <dennisb> nothing hugs
06:55:09 <shapr> Htk has been updated and released
06:55:25 <shapr> some new people have showed up
06:55:28 <dennisb> Hmm, I might be on that list..
06:56:08 <dennisb> There are just too many list, I only subscribe to lists, never unsubscribe
06:56:21 <dark> dennisb: Do you read them?
06:56:31 <dennisb> Sometimes, but most. Yes
06:57:18 <dennisb> All is filtered out into different boxes, so now I will take a look in the gui-box
07:08:57 <dennisb> I've been reading a little about gui.. For me, I would not have any use for a generic haskell gui-library that can have several backends.
07:09:54 <det> shapr, does ghc produce decent binaries? and does it compile to C first ?
07:10:05 <dennisb> Sooner or later one would just run into the wall and whatever advanced feature on need is not there. I would prefer to just use some low level binding like for gtk
07:10:24 <dennisb> det: it can compile to C but usually compiles nativly
07:10:57 <dennisb> I think they are decent
07:12:36 <det> HOpenGL .. hrmm
07:13:46 <shapr> det: it can produce its own binaries, or it can go via-C
07:13:57 <shapr> oh, dennisb already answered :-)
07:15:19 <dark> "generic haskell gui-library that can have several backends" sounds like Swing to me.
07:15:31 <dark> Except for the haskell part of course :)
07:16:18 <det> yay for sanity HOpenGL doesn't prepend names with gl like some other language binding ..
07:17:28 <shapr> aha, java classpath problem, as usual
07:17:30 <shapr> er
07:19:10 <dark> det: I tried to do the same for sdl but I didn't like calling a function "init".
07:19:40 <det> is that a reserved haskell thing ?
07:20:20 <det> well, even not, yeah that is pretty bad
07:21:27 <dark> det: init isn't reserved, but it's a prelude function.  
07:21:51 <dark> I evaded the issue by splitting the functionality into init_some and init_all functions :)
07:21:56 <shapr> heh
07:23:45 <shapr> det: your post started a neat thread
07:23:51 <shapr> I like the second millikin reply
07:24:05 <det> shapr, they don't seem to understand sarcasm very well :)
07:24:25 <det> well, millkin in paticular
07:24:45 <det> reacted rather hostile
07:26:05 <shapr> I was just looking at the code :-)
07:26:09 <shapr> hadn't even noticed that part
07:26:30 <shapr> yah, I think he didn't notice the smiley
07:29:53 <det> shapr, http://twistedmatrix.com/users/chris/primes.py
07:30:38 <det> shapr, I made that using the same "trick" awhile ago :)
07:31:30 <shapr> cute
07:31:58 <shapr> you'll like Haskell :-)
07:39:14 <shapr> bwahaa, you mentioned moshez on haskell@haskell.org
07:39:19 * shapr falls over laughing
07:41:30 <dark> Mentioning moshez is funny?
07:41:45 <shapr> you know moshez?
07:42:01 <shapr> the famous Moshe Zadka, scource of .... something
07:42:04 <shapr> scourge 
07:42:10 * shapr can't spell
07:42:21 <shapr> my brain is full of xsl with embedded javascript
07:42:21 <dark> Well he hangs out on #debian-devel.
07:42:26 <shapr> yes, that's him.
07:42:36 <shapr> famous and infamous, for a variety of good reasons.
07:42:46 <shapr> I like moshez.
07:50:17 <Heffalump> det is Chris Clearwater?
07:50:31 <shapr> yup
07:50:31 * liiwi gets out the katana and removed shapr's head before the plague gets too far
07:50:36 <Heffalump> ah.
07:50:36 <shapr> liiwi: :-P
07:56:07 <det> shapr: hehehe, doesn't everyone know moshez? :)
07:56:22 <shapr> I don't think he's been on #haskell 
07:59:51 <det> Jerzy Karczmarczuk makes for a good read :)
07:59:53 <liiwi> shapr: yet. ph3ar the day when he comes.
07:59:55 <shapr> always
08:00:02 <shapr> liiwi: I could invite him.
08:00:09 <liiwi> he's just plain hyperactive.
08:00:12 <shapr> liiwi: YOU could invite him.
08:00:16 <shapr> liiwi: so am I :-)
08:00:18 <liiwi> you're a bit bouncy
08:00:27 <dark> liiwi: Reminds me of Culus's reaction to someone who liked perl.  I can't find the quote though.
08:00:58 <Heffalump> Jerzy isn't usually that rude, but I guess posting a type incorrect program was a bit silly :-)
08:01:16 <Heffalump> He is definitely somewhat hyperactive, in real life too.
08:01:18 <det> Heffalump: PSUEDO-CODE!!
08:01:49 <shapr> cold coffee tastes bad
08:01:49 <shapr> ew
08:02:11 <Heffalump> It was still type incorrect pseudo-code... (and you gave no real indication it was pseudo-code - it was syntactically valid Haskell)
08:02:13 <det> Heffalump: I should have not made it haskell syntax to avoid the appearance that I meant it to be real haskell code
08:02:20 <shapr> det: yah, that's true
08:02:37 <det> Heffalump: I said "Psuedo-code"
08:02:50 <shapr> great, now that I'm done with that ms access project, I discover debian's mbdtools package ...
08:02:51 <Heffalump> oh, you did, sorry
08:05:00 <det> shapr, I bet it's easy to troll haskell-list
08:05:47 <liiwi> shapr: it has to be cooled quickly.
08:06:08 <shapr> oh neat, dasher reached debian
08:06:18 <liiwi> dasher?
08:06:34 <shapr> the zoom-in pen letter system
08:06:39 <Heffalump> det: I doubt it
08:06:46 <shapr> er.. sf.net/projects/dasher I think
08:07:03 <shapr> they haven't released a palmOS version yet, :-(
08:07:09 <Heffalump> It's quite hard to troll knowledgeable people, and the list has a *lot* of them.
08:07:44 <shapr> yah, haskell list probably has an average IQ twice mine :-)
08:08:02 <shapr> of course, having the Simons on it throws the average far away from the mean...
08:08:08 <shapr> er
08:08:09 <shapr> wait
08:08:22 <shapr> is mean the word for what I'm thinking of?
08:08:32 <det> shapr, then your IQ has to be less that 100 seeing how 200 is the highest :)
08:08:40 <Igloo> mean is what people normally mean by average
08:08:40 <Heffalump> I'm sure yours is above 100, and I doubt the list has an average (or indeed anyone) of more than 200
08:08:44 <Heffalump> IWW is 200 the highest?
08:08:45 <Igloo> I have no idea what you mean  :-)
08:08:51 <shapr> Igloo: hah :-)
08:09:12 <shapr> Heffalump: thanks, see my ego swell ;-)
08:09:12 <Heffalump> you probably mean that the mean is far away from the median
08:09:14 <Igloo> Did you mean the list mean far away from teh general population mean?
08:09:17 <shapr> yah, that's what I meant
08:09:19 <shapr> median/mean
08:09:53 <dark> I don't even know what these words mean.
08:10:05 <det> mean is the number occuring most, right ?
08:10:18 <shapr> what's code for median?
08:10:18 <dark> If you add them all up and divide by the number of members, what do you get?
08:10:20 <dennisb> you are all mean talking like that, I get confused...
08:10:22 <Igloo> I wouldn't be surprised if, ignoring the homework help seeking undergrads, everyone on the list had higher than the GP mean IQ
08:10:30 <Igloo> dark: The mean
08:10:32 <shapr> dennisb: hah, that's a different mean :-)
08:10:33 <det> and median being the number in the middle if you wrote all the scores in a big ordered list
08:10:37 <dark> Then, what's the average?
08:10:49 <Igloo> mean, mode and median are all aerages
08:10:53 <Igloo> averages
08:11:09 <shapr> mean = foldr1 (+) iqs / length iqs
08:11:11 <Igloo> mode is the number most people have
08:11:34 <dark> Oh, okay.  For a moment I was worried that someone had redefined "average" to mean something strange :)
08:11:43 <shapr> median = sort (iqs) length / 2
08:11:49 <shapr> er should have been a ! in there
08:12:20 <Igloo> and an iqs and a `div` and no /  :-)
08:12:20 <Heffalump> sort iqs !! (length iqs / 2)
08:12:27 <Heffalump> bah :-)
08:12:33 * shapr laughs
08:13:19 <dark> shapr: Those meanings of "mean" are probably related, though.  It's common for words that mean "common" to acquire negative meanings.  Compare "vulgar" :)
08:13:35 <shapr> dark: interesting point!
08:14:05 <dark> The dutch word "gemeen" (which plays the same role as english "common" in various compounds) actually means "nasty".
08:14:07 <shapr> yesterday I read the original 1800's definition of "deadline" in _The Pragmatic Programmer_
08:14:31 <shapr> seems it was a line drawn on the ground, if prisoners stepped outside of it, the guards were allowed, even encouraged to shoot them.
08:14:36 <shapr> das ist gemeen!
08:15:19 <dark> shapr: I wonder if that led to disputes depending on which way they fell.
08:15:33 <shapr> probably not
08:16:05 <shapr> I suspect the prisoners were encouraged to keep a much larger than bodylength distance from the line
08:16:38 <dark> I know that in Houston we were told that if we shot annoying people at the front door, we should make sure they fall into the house.
08:16:38 <shapr> anyone planning on trying Htk on win32 here?
08:16:47 <shapr> I'd like to know if it works.
08:16:53 <shapr> dark: same in new york
08:17:16 <dark> shapr: Interesting, I thought it was a typically Texan attitude :)
08:17:52 <emu> in NY, so long as you don't block the road, it's okay
08:17:56 <shapr> in new york, if you shoot someone who's robbing your apartment, and they fall out of the doorway
08:18:17 <shapr> urban wisdom says you should push them back into your apartment
08:18:46 <dark> Maybe the typically Texan part was the Chief of Police saying on TV that you should pull them if they start falling the wrong way :)
08:18:46 <emu> and then drop them out the window with the rest of the trash
08:18:54 <shapr> seems it's self-defense if they're entering your apartment, but assault if they're leaving
08:19:24 <dark> I guess it means less work for them.
08:19:57 <shapr> in any case .... anyone uses GHC on win32?
08:23:17 <dark> <crickets>
08:24:30 <dark> I don't see why anyone would use something as cool as Haskell and then run it on Windows.
08:33:20 * Janni has finally survived this hard week and is now enjoying to be able to listen to good music while IRCing and thinking what to do next...
08:33:58 * Janni also greets everyone, of course
08:44:29 <shapr> hi Janni 
08:44:37 <shapr> dark: hahah
08:44:43 <shapr> dark: excellent point
08:46:43 <shapr> man, the GUI list is hopping
08:46:57 <shapr> huge flood of stuff today
09:12:17 <shapr> yay, I got replies
09:16:55 <shapr> seems to me HTk is the best way to go
09:17:00 <shapr> it's already cross platform
09:37:19 <eivuokko> How can I get around to have a template-haskell compiler? (I have only toyed with hugs before)
09:37:36 <Heffalump> get GHC out of CVS
09:38:07 <eivuokko> Okay, thx.  I'll try :)  (any hints compiling in windows?)
09:38:33 <shapr> eivuokko: patience =)
09:39:37 <Heffalump> I've never compiled it in Windows
09:39:49 <Heffalump> you'll need a binary GHC first though, unless you feel like bootstrapping via .hc files
09:44:17 <eivuokko> Thx, I'll ask again if those build docs don't help me through.  They look real good, though.
09:51:57 <eivuokko> Iik, it doesn't just require mingw (which I got) but also cygwin.
10:07:33 <shapr> mmm, sauna time
10:11:23 <eivuokko> Enjoy :)
10:15:14 <steele> hi
11:11:27 <Marvin--> cool, I got money today, and will get money on tuesday too
11:12:36 <Heffalump> amazing
11:13:42 <Marvin--> salary today for teaching during the fall, and money from csn on tuesday, yay
11:14:11 * Marvin-- is going to buy a laptop tomorrow :D
12:13:55 * dark goes "la la la la la" like Roxette.
12:15:26 <andersca> you've got the look?
12:19:17 * SyntaxPolice does the "found a small program that makes ghc-created executables crash" dance
12:20:00 <Smerdyakov> I made SML/NJ crash ;-)
12:23:30 <dark> andersca: Presumably.
12:35:01 <det> can haskell do sockets ?
12:35:08 <det> how about async IO ?
13:10:24 <esap> Hmm.. Is there somewhere a paper describing how I could represent categories? I mean, I would like to build a data structure to represent an arbitrary category.
13:13:49 <dark> det: sockets and async io are in the posix modules in hslibs.
13:13:54 <dark> With GHC, at least.
13:24:09 <steele> esap: did you look at the docon/bal manual?
13:25:35 <esap> hmm.. no, I haven't heard of that one.
13:27:04 <esap> oh it's that one. yes, I guess I should look into it.
13:27:53 <steele> there are some literature references to papers in the manuals
13:29:41 <esap> hmm.. I guess I have actually some time ago looked at it (had a copy already on the hard drive :-) couldn't remember anything about it though :-)
15:32:47 * Janni is not very talkative tonight. so he will let the universal passive person tell you, what he wants you to know.
15:32:51 * Janni greets you all
15:33:16 <Riastradh> Saluton.
15:45:10 <det> how to read a line from input ?
15:53:43 <det> How can you read a line of input in a do block ?
15:56:03 <Igloo> x <- getLine
15:56:18 <andersca> hey there Igloo
15:56:23 <Igloo> Hi
15:57:37 <det> Is there anything like printf ?
15:58:09 <Igloo> Nothing closer than show
15:58:52 <det> so, I would need to append the strings together before printing ?
15:59:05 <Igloo> Or use multiple putStrs
16:00:17 <det> is there some syntactical magic that allows me to put them all on one line, ; perhaps ?
16:01:19 <Igloo> Yes
16:01:45 <det> awsome, thanks
16:04:25 <det> shapr: I really like type classes
16:17:41 <det> just trying to reinvent the wheel for learning purposes, would this be a correct way to implement a List?
16:19:07 <det> hrmm, copy paste messed up
16:20:09 <det> data List a = Nil | Cons a (List tail)
16:20:47 <det> s/tail/a/
16:20:48 <Riastradh> No, not '(List tail)', but '(List a)'.
16:21:17 <det> cool, caught myself, thanks :)
16:22:06 <det> hrmm, how to define a pop operation, it needs to return 2 values :/
16:24:55 <det> I guess return a tuple :/
16:27:54 <det> how could I decompose a tuple that is returned ?
16:32:43 <Heffalump> pattern match
16:32:51 <det> example ?
16:33:10 <Heffalump> let (x,y) = foo bar in ....
16:33:21 <det> ahh, thanks
16:33:33 <Heffalump> or use a where clause, which is roughly equivalent to a let ... in but goes after the 
16:33:39 <Heffalump> s/ the/wards
16:37:12 <det> where works nicely
16:38:25 * Riastradh grumbles at Haskell's syntax and the weird 'layout' rules.
16:39:08 <det> what is the diference between using instance and using deriving ?
16:39:34 <Smerdyakov> I think deriving defines the members for you.
16:39:45 <Smerdyakov> For special built-in classes where it's clear how to do it.
16:40:26 <det> that makes sense
16:42:06 <det> does this look correct ?
16:42:18 <det> instance Stableable (List a) where
16:42:20 <det> ...
16:42:36 <det> s/Stableable/Stackable/
16:57:16 <Heffalump> deriving works for Show, Read, Enum, Eq and Ord, IIRC
18:57:08 <det> shapr: hi
