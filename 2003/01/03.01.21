00:45:59 <Marvin--> morning shapr
00:47:09 <shapr> g'morning Marvin-- 
00:47:11 <shapr> what's up?
00:48:16 <Marvin--> I'm sitting here wrestling with otter
00:49:35 <shapr> ?
00:49:49 <shapr> large river rat?
00:50:22 <Marvin--> heh, no, it's a theorem prover
00:50:45 <Marvin--> "Organized Techniques for Theorem-proving and Effective Research"
00:53:38 <Marvin--> or rather, I'm trying to work out a clever way to encode inductive haskell types in otter
00:53:44 <Marvin--> Couldn't match `OtterTerm' against `t -> t1'
00:53:46 * Marvin-- curses
00:54:52 <Marvin--> ah, found it, phew
00:55:50 <Marvin--> isInt(X) & isList(Xs) -> isList(cons(X,Xs))
00:58:57 * shapr tries to wake up
01:09:01 <Marvin--> hmm
01:11:39 <Marvin--> hmm
01:11:52 <Marvin--> I wonder how to write a quickcheck property that says "if f is associative, then..." :)
01:12:30 <Marvin--> If f is associative and has unit e, then foldl f x xs == f x (foldl f e xs)... *can* I test that at all?
01:19:44 <shapr> there's a QC associative property in the icfp99 paper
01:19:51 <shapr> that could be a guide
01:21:20 <Marvin--> prop_foldl_3 f e x' y' x'' x xs = prop_Assoc f x' y' && prop_Unit f e x'' ==> foldl f x xs == f x (foldl f e xs)
01:21:29 <Marvin--> or so I thought
01:23:03 <Marvin--> hmm, where did I put my Observer
01:30:46 * Marvin-- SWEARS
01:31:20 <Marvin--> Compiling Observe          ( Observe.lhs, interpreted )
01:31:20 <Marvin--> Observe.lhs:45: parse error on input `#'
01:31:21 <Marvin--> wtf???
01:32:34 <Marvin--> why doesn't this work?
02:02:01 <shapr> hi dark!
02:05:49 <dark> Hello :)
02:05:54 <shapr> how's life?
02:06:24 <dark> In general it's fine, but I've been having a kind of programmer's block.
02:06:52 <shapr> for uncc?
02:06:55 <shapr> or everything?
02:06:58 <dark> For everything!
02:07:01 * Marvin-- just realized that coffee is a good idea
02:07:30 <dark> It might be as simple as needing a better monitor, though.
02:07:34 <shapr> dark: I've found that writing something in Joy unblocks me
02:09:54 <dark> My problem is that I start reading news sites to take a break from programming, then I find all sorts of interesting sites and spend all day on them.
02:09:59 <shapr> he
02:10:09 <shapr> I have that problem sometimes
02:10:16 <dark> Partly it's very good, I learned many interesting things :)
02:10:27 <dark> But I haven't written anything useful for... two weeks I think, and that sucks.
02:10:35 <shapr> I talked to johnw about it, he said "people do what they enjoy doing"
02:11:12 <dark> I've also heard "what you enjoy doing will earn you money".  I'm sure there's a step missing in that recipe though :)
02:11:37 <shapr> 1. underwear 2. ???? 3. Profit!
02:12:04 <dark> http://www.panties.com/
02:12:27 * shapr chortles
02:12:37 <dark> My girlfriend makes corsets, that's also underwear :)
02:12:50 <dark> Though people these days don't seem to wear them that way...
02:12:59 <shapr> that's true
02:22:56 <Marvin--> fuck, there was an extra lecture in compiler construction today that I forgot completely
02:23:16 <shapr> whoops
02:23:36 <shapr> so, next we write a time planner in Haskell?
02:23:38 <Marvin--> heh, "The GCC Internals, by Richard Stallman" is linked from the course homepage :P
02:23:44 <shapr> sounds interesting
02:23:50 <shapr> I've often wondered about GCC internals
02:24:02 <Marvin--> shapr: *bonk* I actually have a time planner, written in *ducks* php
02:24:06 <shapr> heh
02:24:08 <shapr> which one?
02:24:12 <shapr> I'm looking for a decent one
02:24:15 <Marvin--> I wrote it myself
02:24:18 <shapr> something I can sync with my Palm
02:24:23 * andersca is going to fosdem!
02:24:30 <Marvin--> it's very simplistic, it was in my years of naive youth
02:24:37 <shapr> Marvin--: see, this is a great opportunity to rewrite it for HWS-WP
02:24:55 <shapr> if only we had a decent postgresql lib :-/
02:25:01 <Marvin--> shapr: tsk, it's just a calendar, and it works just the way I want it and I don't have the time nor energy to rewrite it
02:25:03 <shapr> or even just a working pg lib
02:26:50 <Marvin--> I don't know the C API for postgreqsl, I've only used it from python and php... if it's somewhat decent you could do an ffi wrapper for it, no?
02:27:09 <shapr> that's probably the best option
02:27:23 <shapr> I found an existing wrapper, but I couldn't get it to compile
02:27:30 <shapr> seems it was written for 5.02 or so
02:30:26 <Marvin--> lots of char *, which is kinda to be expected, but as long as you can think of PGconn and its friends as opaque structures, you should be fine
02:30:53 <Marvin--> and pray that they haven't been nice and smart and make some functions macros for speed
02:32:40 <Marvin--> there's plenty of "The contents of this struct are not supposed to be known to applications." in libpq-fe.h...sounds promising
02:34:34 <Marvin--> okay, why doesn't ghci accept these #ifdefs?
02:34:39 <shapr> ?
02:34:44 * shapr looks at libpq-fe
02:35:12 <Marvin--> Observe.lhs:45: parse error on input `#'
02:35:17 <dark> I wonder how far you can mold haskell into an sql-like syntax :)
02:35:36 <shapr> HaskelDB from the Parsec author completely gets around SQL
02:35:44 <shapr> only works with ODBC and MySql though
02:35:48 <Marvin--> dark: eew
02:35:53 <shapr> and I think it requires Hugs for TREX and win32 for something else
02:36:01 <dark> I think there's an odbc module for postgresql.
02:36:17 <Marvin--> I kinda like sql though
02:36:26 <Marvin--> not that I've ever worked with odbc
02:36:38 <Marvin--> which means my opinion is kinda worthless :-)
02:36:39 <shapr> domain specific embedded compiler that dynamically generates of SQL queries from monad comprehensions
02:36:46 <shapr> sounds cool, eh?
02:36:49 <Marvin--> heh
02:36:54 <dark> As far as I can tell, odbc is mainly a standard for shuffling sql queries back and forth.
02:37:00 * Marvin-- turns on his buzzword detector
02:37:06 <Marvin--> *BOOM*
02:37:13 <shapr> heh
02:37:29 <Marvin--> it's like when they hook up Homer to a lie detector and ask him if he's understood
02:37:47 <shapr> :-)
02:38:11 <Marvin--> do I have to turn on some silly flag for ghci to parse #ifdefs?
02:38:20 * shapr has no idea
02:38:36 <shapr> have you tried building an .o file and then loading that into ghci?
02:38:41 <Marvin--> nope, good point
02:39:00 <Marvin--> same error :(
02:39:05 <Marvin--> $ ghc -c Observe.lhs -fglasgow-exts
02:39:05 <Marvin--> Observe.lhs:45: parse error on input `#'
02:39:22 <shapr> must not be ghci then
02:42:56 <Marvin--> I don't get it
02:43:26 <Marvin--> what am I doing wrong?
02:47:56 * Marvin-- sighs and edits the ifdefs instead :(
02:56:09 <Marvin--> nope, this is probably not a very smart application of quickcheck
02:56:25 <Heffalump> what's the application?
02:56:42 <Marvin--> here's my current prop:  prop_foldl_3 f e x' y' x'' x xs = prop_Assoc f x' y' && prop_Unit (observe "foo" f) e x'' ==> foldl f x xs == f x (foldl f e xs)
02:56:50 <Marvin--> the problem is that I can only have global all quantifiers, not local
02:57:27 <Marvin--> so I'd actually like to be able to say things like    quickCheck prop_Assoc ==> ...
02:57:38 <Marvin--> (modulo a decent embedded language)
02:58:23 <Heffalump> hmmm
02:58:41 <Heffalump> the idea being that you generate random functions?
02:59:21 <shapr> dark: memepool.com is the most distracting thing I've ever seen.
02:59:30 <Marvin--> yes, which is pretty much very inefficient :) but I want to show that foldl has this and that property for every associative function with a unit e
02:59:53 <Marvin--> actually, maybe this could be an example of something a theorem prover would be better than quickcheck at :P *files away for future reference*
03:01:12 <Heffalump> The trouble is that quickCheck prop_Assoc being true doesn't necessarily mean that it is
03:01:28 <Heffalump> So I think the theorem prover for that aspect of it would be better anyway.
03:01:39 <Heffalump> But then maybe you might as well theorem prove the foldl property too...
03:01:45 <Marvin--> exactly
03:02:20 <Marvin--> I need some sort of motivation for a master project about combining theorem proving with quickcheck, maybe this is it
03:04:07 <Marvin--> if (==>) had the type Property -> a -> Property  instead of Bool -> a -> Property, then you could say something like   prop_foldl_3 f e x xs = prop_Assoc f &&' prop_Unit f e ==> foldl f x xs == f x (foldl f e xs)
03:04:48 <Marvin--> or perhaps  (Testable a, Testable b) => a -> b -> Property
03:09:16 <shapr> speaking of memepool weirdness http://www.uq.edu.au/education/extra/all.html
03:09:36 <Marvin--> maybe I should fire away a mail to Koen
03:15:38 * Marvin-- tries to make sense of otter
03:20:28 * Marvin-- ends his mail with "should we meet some time soon and fix some formalities so I can get money from CSN?"
03:26:55 <Marvin--> gah
04:37:14 <shapr> hi ozone 
04:37:20 <shapr> what's up?
04:40:47 <ozone> hullo, at LCA2003
04:41:05 <ozone> am absolutely buggered, had about 3 hours of sleep last night
04:41:59 <shapr> lca?
04:44:46 <ozone> www.linux.conf.au
04:46:02 <shapr> looks like fun!
04:46:23 <Marvin--> 3 hours of sleep sounds about normal for a conference
04:47:12 <ozone> Marvin--: i only got here today :D
04:47:41 <Marvin--> ozone: oh :)
04:47:47 <Marvin--> that's worse :)
04:48:23 <Marvin--> "It's common for programs to need to display a progress meter on the terminal while it performs some length operation (it behaves like an anesthetic)."
04:48:24 <Marvin--> heh
04:49:09 * shapr laughs
04:49:14 <shapr> where'd you get that quote from?
04:49:29 <Marvin--> the newt manual
04:50:17 * Marvin-- adds it to the quote book
04:57:06 <dark> Historically, it was an assurance that the system hadn't died.
04:57:17 <Marvin--> yeah
04:57:33 <dark> Then "modular programming" became fashionable, and the progress indicator was decoupled from the actual process, and ran independently :)
04:57:40 <Marvin--> ;;)
04:57:57 <Marvin--> not in newt! Newt is not event-driven
04:57:58 <dark> I've actually seen systems where the twirly cursor was the only thing that still worked.
05:04:21 <dark> Intel x86 architecture is surprisingly well-documented.
05:06:10 <shapr> cache coherency still sucks
05:07:32 <dark> Sometimes their pseudcode is a bit weird, but it was probably written by hardware people :)
05:13:42 <dark> I'm not saying the x86 architecture is surprisingly _good_ :)  Just well-documented.
05:14:28 <dark> In fact, the documentation keeps pointing out new ways in which it sucks.  Consider the segment descriptors, which have fields scattered around in three or four pieces.
05:15:30 <dark> Fortunately uncc doesn't have to care about those :)
05:40:36 <Marvin--> uncc?
05:52:46 <dark> Marvin: My decompiler.  machine code to C.
05:53:24 <Marvin--> dark: oh, cool
05:59:57 <ludde> dark: do you translate to some intermediate code before making C?
06:07:47 <dark> ludde: To an intermediate representation, yes.
06:08:16 <ludde> you could write a plugin for IDA
06:08:25 <dark> What's IDA?
06:09:30 <ludde> Interactive Disassembler, www.datarescue.com
06:14:07 <dark> You mean, to take advantage of IDA's detection of subroutines and basic blocks?
06:14:21 <dark> I don't see what else the combination would have to offer.
06:29:14 <ludde> dark: take advantage of the structs/constants that the user of IDA has defined, as well as variable names, and function names.
06:30:01 <dark> ludde: I see.  So people who have done work on a program with IDA can reuse the work when decompiling?
06:30:57 <ludde> exactly
06:31:35 <ludde> there is already an open source IDA decompiler (called desquirr i think). I havn't tested it.
06:32:33 <dark> Hmm, it seems to be windows-only.
06:33:08 <dark> ida, that is.  It has a "freeware version" but no source.
06:33:23 <ludde> IDA is a commercial product
06:33:31 <ludde> but the decompiler plugin desquirr is open source
06:33:36 <andersca> you mean proprietary
06:34:22 <ludde> proprietary product?
06:34:29 <dark> andersca: Depends on how you define proprietary... they have an older version up for download, but it's binary only.
06:35:02 <ludde> http://desquirr.sourceforge.net/desquirr/
06:53:00 <dark> ludde: It has an interesting thesis, thanks :)
06:57:02 <dark> "Afterward wee entred the lande of the Kangittae, which in many places hath great scarcetie of waters, wherin there are but fewe inhabitants by reason of the foresayd defect of water."
06:57:11 <dark> Medieval writing seems to tortured :)
06:57:55 <ludde> is that from the thesis?
06:59:41 <dark> Heh, no :)  I'm also doing some pages at the Distributed Proofing site whenever I get distracted.
07:00:20 <dark> This is from "The Principal Navigations, Voyages, Traffiques and Discoveries of the English Nation"
07:01:09 <dark> It's pretty interesting because it's a 17th century author quoting and annotating several older works, so it has a range of styles.
07:01:20 <dark> I also get to learn some Latin :-)
07:53:50 --- topic: '["mo' nads than you", "We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/", "Gtk+HS 0.14.10:  http://www.cse.unsw.edu.au/~chak/haskell/gtk/","HWS-WP: http://www.dum.chalmers.se/~marvin/hws-wp/", "HaskellWiki resurrected", "ANNOUNCE: GHC version 5.04.2 released","HaSDL: http://www.xs4all.nl/~dark/hasdl-0.1pre7.tar.gz","New Mailing List for Template Haskell", "Tallest dwarf in Moria"]'
07:53:50 --- topic: set by Pseudonym on [Wed Jan 08 16:29:45 2003]
07:53:50 --- names: list (clog d33p skylan ludde dark Marvin-- jak_ galority lament tez lindril Smerdyakov gdsx SyntaxPolice__ Igloo Logan jewel mgoetze jmalicki-work tWip andersca Radek drlion emu xkb SyntaxPolice Segora Heffalump smkl Fractal whee liiwi Chilli)
08:48:43 <Janni> greetings
09:06:10 <noshadow> I'd like to have a " chi :: value -> (state->Bool) -> (state->value) " , but I have no idea how to implement the distiction. Any ideas what I should read to get a clue about this?
09:07:22 <Janni> what does chi do?
09:07:58 <noshadow> it shall return a function that returns the first argument if the second argument would return true, and some special other value otherwise...
09:08:36 <noshadow> and I totally fail to hugs to understand me...
09:10:00 <Janni> noshadow: you know guards?
09:10:40 <andersca> or you could use pattern matching
09:10:42 <noshadow> I've learned Haskell merely by looking at other people programs. Am missing the names for the things. Are gueards the distinctions with | ?
09:11:36 <Janni> noshadow: yeah, but andersca's right. i find pattern matching much nicer (if it's appliable)
09:11:43 <noshadow> andersca: I tried chi f v s <nl> | f s = v <nl> | otherwise = I
09:12:01 <noshadow> but this seems to be something other than I espected...
09:12:39 <Janni> noshadow: you shouldn't learn haskell by trying. have a look at: http://www.cs.ou.edu/cs1323h/textbook/haskell.shtml
09:12:49 <Janni> it's my favorite tutorial for beginners (and advanced)
09:13:57 <noshadow> ahh, what am I stupid. just (.)ing with a function Bool->value does of corse the right thing...
09:15:40 <noshadow> hm, or perhaps also not??
09:16:57 <Janni> chi v True = v
09:17:07 <Janni> chi v False = <special>
09:20:19 <noshadow> AAAAAAAAAAAARG. now I have it. The function was right all the time. I just foget to but a (-1) instead of a -1.........................
09:21:08 <Janni> noshadow: but isn't pattern matching (as in my example) much cuter? :)
09:22:49 <noshadow> Janni: think it is the wrong type. I need b -> ( a->bool) -> (a -> b) , not b -> Bool -> ...
09:23:07 <Janni> noshadow: ah. yes.
09:24:00 <Janni> (didn't really read your code)
10:03:48 * shapr sighs
10:09:38 <Marvin--> ?
10:10:13 <shapr> java code...
10:11:29 <Marvin--> aha
10:11:42 <shapr> weeks of java code on the horizon.
10:11:54 <shapr> call me a prima donna, but I really prefer Haskell.
10:17:06 <Marvin--> well...duh? :)
10:17:10 <shapr> heh
10:17:18 <shapr> doesn't go over well with others sometimes.
10:17:30 <shapr> especially those others who contribute to my paycheck.
10:18:59 <Marvin--> :)
10:19:11 <Marvin--> can't say "I know the feeling" since I'm a student, but... ;)
10:19:50 <Marvin--> I do know that it's painful doing labs in java
10:20:08 <shapr> hi inkedmn 
10:20:14 <inkedmn> howdy :)
10:20:23 <Marvin--> I wonder if the distributed systems course was a bit worse though, we had to write the code in C, using a totally hopeless system called Lydian
10:20:33 <Marvin--> sure, it could do lots of cool things, but it was *not* newbie friendly
10:32:07 * dark drinks a beer because of the picture on the label. http://www.wychwood.co.uk/images/Black_Wych.jpg
10:32:54 <andersca> does it have frogs in it?
10:51:57 * Janni 's back
10:52:22 <shapr> hi Janni 
10:59:26 <Marvin--> dark: is it any good? ;)
11:01:02 <dark> I'm not sure :)  It's pleasantly bitter, but in a way it's too light.  It invites fast drinking, but drinking it fast changes the flavour for the worse.
11:10:36 <Marvin--> heh
11:12:03 <SyntaxPolice> can anyone tell me: is there a way to compile ghc with debugging symbols to help track down why I'm getting a segfault?
11:12:34 <SyntaxPolice> (some of you may remember that I get a segfault when using the --make flag unless I make clean, but it is hard to reproduce unless I'm trying to get actual work done)
11:12:51 <SyntaxPolice> sorry: the segfault is in the program, not in the compiler.
11:17:04 <shapr> hi socrates2 
11:17:11 <socrates2> hi guys
11:17:23 <socrates2> i have an error message which i dont understand
11:17:28 <socrates2> can i pm it here please
11:17:30 <socrates2> ?
11:17:40 <shapr> if it's short, paste it in the channel
11:17:45 <socrates2> ok
11:17:48 <socrates2>  Expression     : accumulator ls
11:17:48 <socrates2> <socrates2> *** Term           : ls
11:17:48 <socrates2> <socrates2> *** Type           : [f]
11:17:48 <socrates2> <socrates2> *** Does not match : (a,b,c,d,e)  
11:17:50 <socrates2> ;
11:17:50 <socrates2> ;
11:17:53 <socrates2> thats it
11:18:21 <shapr> that doesn't tell me much
11:18:24 <shapr> are you using Hugs?
11:18:28 <socrates2> yes
11:19:01 <socrates2> shapr: i can pm my functions in here
11:19:10 <shapr> I looks like the function "accumulator" wants a tuple of five items
11:19:18 <shapr> but you're giving it a list of something
11:19:37 <socrates2> its being given a list of tuples
11:19:55 <shapr> accumulator says he doesn't want a list at all
11:19:59 <Heffalump> well, it seems to expect a tuple.
11:20:15 <socrates2> but im using it in a list comprehension
11:20:17 * shapr athropomorphises heavily
11:20:43 <socrates2> accumulator (_,_,_,thePrice,_) = thePrice
11:21:10 <socrates2> func ls =  sum [ x | x <- ls, accumulator ls ]
11:21:24 <socrates2> ls is a list of tuples
11:21:30 <Igloo> But (_,_,_,thePrice,_) is a pattern that matches a tuple
11:21:47 <socrates2> yeah i see what u are saying
11:22:07 <andersca> sum $ map accumulator ls 
11:22:15 <Igloo> Do you want a list of prices?
11:22:21 <socrates2> yes
11:22:30 <socrates2> igloo: yes
11:22:38 <Igloo> So for each x in ls you want thePrice of that x?
11:23:25 <socrates2> igloo: for each x?
11:23:53 <socrates2> for each tuple is ls- (the list of tuples) i want the fourth member in a list 
11:24:16 <socrates2> then i want to compute the sum of all the prices
11:25:24 <Igloo> Right, but x will be given the value of each tuple in turn
11:25:40 <socrates2> ok
11:26:03 <socrates2> yeah x will be a list of all prices
11:26:09 <socrates2> igloo: with me?
11:26:12 <Igloo> No it won't
11:26:47 <Igloo> x will have the value of each tuple in turn
11:26:54 <Igloo> One at a time
11:27:06 <Igloo> And for each one a list element will be built
11:27:43 <Igloo> And accumulator takes a tuple and gives you a price
11:27:51 <socrates2> yes
11:28:08 <socrates2> so....
11:29:06 <socrates2> igloo: yes u know what i mean
11:29:38 <Igloo> Yes, but I'm trying not to do your homework for you  :-)
11:29:49 <socrates2> Igloo: I know
11:29:50 <Igloo> Do you just want an answer?
11:29:50 <socrates2> :)
11:30:00 * Igloo gives up  :-)
11:30:17 <socrates2> Igloo: I would appreciate it yeah
11:30:34 <Igloo> sum [ accumulator x | x <- ls ]
11:30:47 <socrates2> thanks
11:30:55 <Igloo> Read that as "sum of (for each x in ls, accumulator x)"
11:31:44 <socrates2> - Instan
11:31:44 <socrates2> ce of Integral [Char] required for definition of printInvoice               
11:31:53 <socrates2> ce of Integral [Char] required for definition of func               
11:33:07 <socrates2> Insta
11:33:14 <socrates2> what does this mean
11:33:15 <socrates2> ?
11:33:30 <Igloo> You're trying to use a string as a number
11:33:43 <socrates2> thanks 
11:36:13 <socrates2> if i delete sum, from,    sum [ accumulator x | x <- ls ]
11:36:36 <socrates2>  Than i get Instancece of Integral Char required for definition of func
11:37:57 <Igloo> Have you got type signatures for all your top level functions?
11:38:24 <socrates2> I dont think so
11:38:27 <socrates2> u mean 
11:38:44 <socrates2> func:: a-> [b] these?
11:38:48 <Igloo> Yes
11:38:57 <socrates2> no i dont use those often
11:39:03 <Igloo> Put them in and you will probably be able to work out what is going on
11:39:26 <socrates2> for every top level function?
11:40:21 <Igloo> Yeah
11:41:43 <socrates2> func :: [(a,b,c,d,e)] -> String, like this 
11:42:00 * Igloo has fun keeping c2hs and gtk+hs happy with a moving GHC
11:42:24 <shapr> tWip was asking about working gui libs
11:42:26 <Igloo> Can a, b, c, d, e really be any type?
11:42:40 <socrates2> no
11:42:47 <Igloo> That would only help me if it ended up in the GHC tree, shapr
11:43:24 <Igloo> So put in the minimum requirement of the function
11:43:46 <shapr> Igloo: huh?
11:43:46 <Igloo> Well, I mean libraries/ rather than GHC tree
11:43:54 <shapr> oh
11:44:16 * shapr fights the evil java monster
11:44:18 <socrates2> *** Term           : sum [ accumulator x | x<-ls ]
11:44:19 <socrates2> *** Type           : Double
11:44:19 <socrates2> *** Does not match : [Char]    
11:44:22 <Igloo> The problem, I believe, is that the c2hs and gtk+hs binaries I made are now incorrect given recent GHC changes
11:44:40 <socrates2> Igloo: can u see the problem?
11:44:53 <Igloo> You have that piece of code somewhere where a String is expected
11:45:00 <Igloo> (String == [Char])
11:45:07 <socrates2> i know
11:45:20 <Igloo> But it has type Double
11:46:03 <socrates2> if i take sum out it expects a char
11:46:45 <socrates2> why?
11:46:48 <Igloo> Can you paste that error?
11:47:05 <Igloo> Oh, I could have the two types the wrong way round
11:47:22 <socrates2> Igloo which one, the one without sum
11:47:23 <socrates2> ?
11:47:26 <Igloo> Yup
11:47:36 <socrates2>  Than i get Instancece of Integral Char required for definition of func
11:47:36 * Igloo doesn't think I do, though
11:48:12 <Igloo> Oh, so it wasn't the same sort of error?
11:48:18 <socrates2> no
11:48:29 <socrates2> with sum its [Char]
11:48:32 <Igloo> What does func do?
11:48:49 <Igloo> sum [ accumulator x | x<-ls ]   is part of func, right?
11:49:12 <socrates2> yes
11:49:16 <socrates2> thats right
11:49:36 <Igloo> So what is the purpose of func? And what type signature have you given it?
11:49:37 <socrates2> func takes the list of tuples and prints out bits
11:49:49 <socrates2> func ls = 
11:49:50 <Igloo> Oh, you are trying to do IO?
11:50:11 <socrates2> thre is IO in my program
11:50:45 <socrates2> yes
11:50:47 <Igloo> If you are trying to do IO in func then you are completely lost
11:51:02 <socrates2> its not an IO function
11:51:15 <Igloo> So in what sense does it print out bits?
11:51:32 <socrates2> bits of a tuples
11:51:56 <socrates2> from the list of tuples
11:52:16 <Igloo> What do you mean by "print", though?
11:52:30 <socrates2> display on the sceen
11:52:32 <socrates2> display on the screen
11:52:39 <socrates2> thats all 
11:52:41 <Igloo> Bother, my c2hs problem is more fundamental than I thought
11:52:45 <Igloo> That's IO
11:53:10 <Igloo> I suggest you read an IO tutorial - I think there is some stuff on haskell.org
11:54:12 <socrates2> I know about IO god damn it
11:54:31 <socrates2> putStr 
11:54:36 <socrates2> getLine
11:54:39 <socrates2> readFile
11:54:59 <socrates2> writeFile --- whats the big deal
11:55:27 <Marvin--> Haskell isn't like other kids :)
11:56:19 <socrates2> *** Expression     : sum [ accumulator x | x<-ls ] ++ "\n" ++ "-----------------
11:56:19 <socrates2> --------------------------------------------------" ++ "\n\n"
11:56:19 <socrates2> *** Term           : sum [ accumulator x | x<-ls ]
11:56:19 <socrates2> *** Type           : Double
11:56:19 <socrates2> *** Does not match : [Char]                     
11:56:21 <socrates2> ;
11:56:52 <Marvin--> yes?
11:56:56 <Marvin--> a number is not a string
11:57:01 <socrates2> ok
11:57:24 <socrates2> read (sum [ accumulator x | x<-ls ])::String
11:59:55 * Janni has returned
12:00:10 <Marvin--> socrates2: er, no... read 
12:00:15 <Marvin--> socrates2: read *takes* a String
12:00:24 <Marvin--> socrates2: you want show
12:00:44 <shapr> java is a lot more manual than haskell
12:01:08 <Marvin--> I'm trying to get newt to place my buttons decently :(
12:01:10 <Logan> Java requires you to annotate everything.
12:01:21 <socrates2> Thanks guys
12:01:28 <socrates2> :))))))))))))))))))))))))))))))))))))))
12:01:34 <shapr> java is very tiresome when I'm used to type inferencing
12:01:42 <Logan> Yeah.
12:01:46 <Logan> I'm no longer using java for anything.
12:01:52 <Logan> Python gets the same job done with less fuss.
12:01:56 <shapr> I'm using it for money.
12:02:05 <shapr> yah, I agree.
12:02:05 <Logan> I'm coding C for money.
12:02:14 <shapr> and in extreme cases, Jython is a much better solution.
12:02:45 <Logan> I did ircquotes in python and XSLT.  I need to implement a language that compiles to XSLT, because XSLT is a pain in the ass to type and edit. :P
12:02:52 * Janni is recommending Eiffel for imperative OO programming
12:03:01 <Marvin--> "Language Zealots - For Fun and Prophets"
12:03:10 <shapr> ha
12:03:14 <Janni> it just had to been said ;)
12:03:27 <shapr> haskell is my number one choice
12:03:33 <jmalicki-work> why eiffel over java?
12:03:42 * shapr flashes zealous FPness
12:03:49 <Marvin--> why can't stupid newt figure out the width of the button on its own? :(
12:04:06 <jmalicki-work> shapr: hmm... if the compilers got reasonably optimized it would be for me
12:04:39 <jmalicki-work> shapr: it was my favorite until i rewrote input file parsing for one of my programs in C for a 30x speed and 15x memory improvement :)
12:05:34 <shapr> I still prefer Haskell
12:05:49 <Janni> me too
12:06:00 <Marvin--> it took me quite some time to figure out that component positions were relative to the window, not to the screen, and that was what was making my Cancel button end up outside the screen *cough*
12:06:07 <shapr> I don't want to manage my own memory :-)
12:06:35 <shapr> plus I just like Haskell, it's beautiful in my eyes
12:06:57 <jmalicki-work> shapr: sure, its nicer
12:07:15 <jmalicki-work> shapr: but if i have to wait 30x as long for my program to execute, it doesnt matter :)
12:07:25 <jmalicki-work> i mean , i ultimately write code to have a program that does something
12:07:28 <dark> Bah, you just need a faster computer.
12:07:30 <jmalicki-work> as opposed to looking nice
12:07:34 <shapr> yah, computers get faster all the time
12:07:47 <jmalicki-work> dark: this was for economic forecasting... i.e. i could spend $1million and the computer owuldnt be fast enough
12:07:50 <Janni> and you need to _compile_ the stuff
12:07:59 <jmalicki-work> dark: and ironically, its such problems where haskell really shines as a language
12:08:19 <dark> jmalicki: Isn't that stuff normally done in FORTRAN? :)
12:08:27 <shapr> jmalicki-work: see, chakravarty's parr with MPI support would have been great for your problem
12:08:30 <Janni> doesn't ghc create really _fast_ code?
12:08:39 <Heffalump> nice looking code is probably easier to maintain
12:08:39 <jmalicki-work> Janni: nope.
12:08:43 <dark> Janni: Depends on what you compare it to.
12:08:44 <Igloo> Not for IO
12:08:46 <Heffalump> Janni: it creates really fast Haskell code
12:08:47 <Marvin--> Janni: depends on what you com..duh
12:08:48 <shapr> heh
12:08:53 <Marvin--> what he said
12:09:05 <jmalicki-work> Heffalump: sure... but code ultimately needs to execute :)
12:09:07 * Marvin-- decides to have a beer, maybe that'll make me type faster
12:09:12 <shapr> I think I have to quote that...
12:09:16 <dark> You can always write some parts in C.  You don't even need to go through IO if you get the interface right.
12:09:25 <Marvin--> shapr: http://193.11.232.159:8080/quotes/ :P
12:09:26 <Heffalump> jmalicki-work: but execution speed is rarely the bottleneck these days
12:09:37 <dark> Speaking of beer... I still have the second half of that Black Wych.
12:09:38 <jmalicki-work> dark: it got to be the whole program, really.
12:09:51 <jmalicki-work> Heffalump: execution speed is the bottleneck for anything you can sanely program in haskell, however.
12:10:00 <jmalicki-work> Heffalump: seriously, haskell only shines at compute-bound stuff
12:10:04 <Marvin--> dark: you drink too slowly
12:10:17 <jmalicki-work> Heffalump: noone is gonna go through monad hell to write stuff in haskell thats just doing IO waits all the time
12:10:23 <dark> jmalicki: Remember that if you had written the whole thing in C in the first place, it might have been a lot slower :)  Haskell invites you to think about the problem in better ways.
12:10:33 <jmalicki-work> dark: actually, no it doesn't
12:10:34 <dark> Marvin: I'm getting old.
12:10:39 <Janni> Heffalump: but when it comes to costs you spend _much_ mony to optimate your programs for speed, where with a high level language you save a lot of money
12:10:42 <jmalicki-work> dark: i think about the problem in the same ways to begin with :)
12:10:43 <Heffalump> jmalicki-work: its only Monad hell if you don't understand monads
12:11:01 <jmalicki-work> Heffalump: im sorry, but for IO intensive stuff, haskell really provides no benefits
12:11:07 <jmalicki-work> Heffalump: C is just as good and easier
12:11:16 <dark> Haskell provides richer data structures.
12:11:22 * Heffalump rewrote a shell script in Haskell and made it much nicer
12:11:29 <Marvin--> And C SUCKS BIGTIME AT STRING FIDDLING
12:11:39 <jmalicki-work> dark: yes.... rich data structures dont matter for IO bound stuff.
12:11:46 <Marvin--> sorry 'bout that, I've been writing string fiddling stuff for debian-installer lately
12:11:49 <dark> Marvin: You just say that because you have an irrational prejudice against security holes.
12:11:55 <jmalicki-work> Marvin--: Haskell is worse at string fiddling.
12:12:07 <jmalicki-work> Marvin--: its the string fiddling of haskell that i find MOST objectionable
12:12:08 <dark> jmalicki: That wasn't my experience when I started a version control system in Haskell :)
12:12:28 <Marvin--> jmalicki-work: maybe slower, but a lot neater, thanks to automatic memory handling
12:12:33 <jmalicki-work> dark: linked lists of characters simply are not an acceptable representation of strings
12:12:49 <Marvin--> mind you, I can just as easily do it in Python as in Haskell, but definitely not in C
12:12:51 <Heffalump> they are to people who aren't hung up on performance
12:12:54 <dark> jmalicki: I'm still talking about rich data structures.
12:12:59 <jmalicki-work> dark: the compiler *absolutely needs* to be able to optimize them into arrays in the common case, or it will be unusable
12:13:05 <Marvin--> jmalicki-work: what, but pointer to character terminated by zero IS?
12:13:15 <jmalicki-work> Heffalump: yes. but again, haskell's strong suit *is* for performance-intensive apps
12:13:18 <dark> jmalicki: Only if you're storing them more than you're manipulating them.
12:13:28 <dark> In which case there's PackedString.
12:13:32 <jmalicki-work> Heffalump: like the sorts of problems it represents better than other lnaguages the most are compute-bound ones
12:13:37 <jmalicki-work> Marvin--: yep
12:13:38 <shapr> I always thought Haskell's strong suit was letting you think about the code in new, more abstract ways
12:13:40 <shapr> as dark said
12:13:49 <jmalicki-work> dark: the compiler needs to be able to do that automatically
12:14:01 <jmalicki-work> shapr: i dunno... i always coded like that to begin with
12:14:05 <shapr> because the abstraction is the real limit of of anything
12:14:07 <jmalicki-work> shapr: haskell just automates the process
12:14:13 <Marvin--> as I said, in an installer I don't care much about efficiency, heck I write O(n^3) algorithms because they're easy to write
12:14:16 <shapr> jmalicki-work: with recursion and algebraic datatypes and stuff?
12:14:17 <Heffalump> it makes it feasible
12:14:23 <Marvin--> Unfortunately, I do have to care about the size of the executable :(
12:14:23 <jmalicki-work> shapr: however, the thing is only compute bound stuff typically benefits from the kind of stuff haskell provides
12:14:25 <Marvin--> so C it is
12:14:28 <Marvin--> but I hate working with strings in C
12:14:33 <ludde> char* is nice
12:14:34 <jmalicki-work> shapr: again, only compute bound stuff typically benefits from that
12:14:43 <Heffalump> hws is a good example of an IO bound application that looks nice in Haskell (from what little I've read the code)
12:14:45 * Marvin-- thinks of realloc loops and shudders
12:14:51 <dark> ludde: Until you need characters wider than 8 bits :)
12:15:01 <jmalicki-work> Heffalump: you could do IO bound stuff in haskell but thats not the point
12:15:02 <Marvin--> Heffalump: then obviously you haven't looked enough, a lot of the code is horrible :)
12:15:03 <shapr> jmalicki-work: I think the simplicity of the code I write in Haskell means I have less bugs, less code overall
12:15:08 <Heffalump> Marvin--: ah :-)
12:15:08 <Marvin--> Heffalump: not that Apache is prettier *g*
12:15:10 <ludde> dark: :)
12:15:11 <jmalicki-work> Heffalump: haskell is like 100x better than anything else for compute bound stuff
12:15:24 <shapr> I remember when I was first learning Haskell, and I asked Heffalump to look at ten pages of Haskell source..
12:15:25 <Heffalump> jmalicki-work: naah, ML exists
12:15:26 <jmalicki-work> Heffalump: maybe 2x for IO bound stuff, if not worse
12:15:34 <shapr> Heffalump said "that's not short!"
12:15:42 <shapr> but I was used to thinking about code size in python terms
12:15:46 <jmalicki-work> Heffalump: well ok, the haskell/ML family is, and haskell is a bit nicer than ML :)
12:15:51 <socrates2>  Instan
12:15:51 <socrates2> ce of Integral Double required for definition 
12:15:53 <Marvin--> shapr: heh
12:15:58 <socrates2> what does this mean
12:16:14 <dark> shapr: My lower limit for a project being "real" was 5000 lines :)
12:16:20 <Heffalump> jmalicki-work: yeah, but sometimes updatable references really save effort :-)
12:16:21 <shapr> I can read and absorb ten pages of Python in very little time.
12:16:25 <socrates2> Instance of Integral Double required for definition func? 
12:16:28 <shapr> not so with ten pages of Haskell.
12:16:34 <shapr> *lots* of stuff can happen in ten pages of Haskell
12:16:43 <jmalicki-work> Heffalump: yeah, but ML's type system is much worse than haskell's
12:16:45 <Heffalump> socrates2: how big is func?
12:16:48 <Marvin--> socrates2: you use something defined in the type class Integral, but Double isn't a member of that class
12:16:50 <jmalicki-work> Heffalump: or at least the built-in types
12:16:52 <Heffalump> jmalicki-work: yeah, though it does have functors
12:16:55 <dark> Of course, uncc is already more than 1500 lines, but that's mainly because of the disassembler.
12:16:56 <jmalicki-work> Heffalump: err standard, or whatever
12:17:20 <shapr> dark: does your lower line limit vary per lang?
12:17:22 <jmalicki-work> Heffalump: i mean, haskell is the PERFECT language for supercomputer-type applications
12:17:26 <shapr> yow, alliteration
12:17:30 <jmalicki-work> Heffalump: and thats probably where it shines the *most*
12:17:35 <shapr> per lang lower line limit?
12:17:39 <socrates2> Marvin: what can i do?
12:17:39 * shapr snickers
12:17:40 <jmalicki-work> Heffalump: however, its performance is so subpar its unusable for them
12:17:41 <dark> Heffalump: What I really like about Haskell is that you can get that stuff if you want it.  There's Dynamic, there's MutableArray, etc.
12:17:51 <dark> Much better than having to switch to a whole new language.
12:17:55 <Heffalump> dark: true
12:18:04 <jmalicki-work> Heffalump: though i havent gotten to trying the 5.x compilers, so what i said may have changed, i dunno
12:18:06 <dark> shapr: It didn't, but I may have to make an exception for Haskell.
12:18:08 <Marvin--> socrates2: depends on what fuunctions/operators you've used
12:18:28 <shapr> dark: do you see greater 'density' in Haskell also?
12:18:41 <shapr> what I find amazing is that the greater density I see doesn't cut down on readability
12:18:48 <dark> shapr: Yeah, Haskell cuts out the crap :)
12:18:51 <shapr> sometimes it makes it easier even, because the code is all in the same place.
12:18:57 <shapr> heh
12:19:05 <Janni> when talking about performance. i was thinking about s.th. like a hardware lambda processor. does s.th. like that exist?
12:19:08 <shapr> that would be fun to quantify sometime
12:19:19 <Marvin--> dark: sometimes it cuts out too much crap and it becomes unreadable *cough*pointlessprogramming*cough*
12:19:35 <dark> shapr: Well it can easily cut down on readability.  I submit Control.Monad.RWS as evidence :)
12:19:44 <shapr> Janni: I saw a short thread on the primary haskell mailing list about that
12:19:58 <shapr> Janni: simon pj said "it's just not economically advantageous"
12:20:15 <shapr> dark: I haven't used it... 
12:20:17 <shapr> yet :-)
12:20:19 <Marvin--> bah, down with von Neumann
12:20:23 <socrates2> Marvin: i get the error when i use the'*' operator
12:20:28 <Janni> shapr: but it would be, if an OS in Haskell would be coded :)
12:20:35 <Marvin--> socrates2: hrrm.. * is in Num...
12:20:39 <shapr> maybe so...
12:20:39 <Marvin--> socrates2: and Double is Num
12:20:45 <jmalicki-work> Janni: the big problem with Haskell for performance is memory fragmentatin and cache-line bouncing
12:20:46 <shapr> I'd love to see an OS in Haskell =)
12:20:57 <shapr> Janni: we should probably start with something smaller, like an emacs clone ;-)
12:20:58 <Marvin--> yay, pointless OS
12:21:03 <dark> Like, what does this function do:
12:21:05 <shapr> Marvin--: excellent name!
12:21:05 <Marvin--> oh, sorry, point*free* OS
12:21:11 <dark> evalRWST :: (Monad m) => RWST r w s m a -> r -> s -> m (a, w)
12:21:11 <dark> evalRWST m r s = do
12:21:11 <dark>     (a, _, w) <- runRWST m r s
12:21:11 <dark>     return (a, w)
12:21:11 <shapr> brilliant!
12:21:13 <Janni> shapr: smaller?? ;)
12:21:19 <dark> I especially love the type signature.
12:21:22 <shapr> Janni: hah!
12:21:25 <jmalicki-work> Janni: there is a 20x speed improvement easy if you make arrays of #Integer from linked lists of Integer
12:21:25 <Marvin--> dark: hahahaha
12:21:30 <jmalicki-work> or is it Inetger#? i dont remember
12:21:37 <socrates2> Marvin: ideas?
12:21:55 <socrates2> i multily two int variables
12:21:57 <Marvin--> socrates2: what is the exact error message?
12:22:02 <dark> shapr: Uh, there are OSes smaller than emacs :)
12:22:31 <jmalicki-work> dark: calling them OSes is often a stretch...
12:22:42 <socrates2>  Instan
12:22:42 <socrates2> ce of Integral Double required for definition of 
12:22:44 <socrates2> func
12:22:58 <socrates2> Marvin: thats it
12:22:58 <Marvin--> socrates2: er, and that's all? It doesn't say anything about what the sinner is?
12:23:14 <socrates2> Marvin
12:23:23 <socrates2> i know the sinner is this line
12:23:31 <Marvin--> okay, what is the line?
12:23:44 <socrates2> accumulator (_,_,qty,thePrice,_) = thePrice * qty
12:24:05 <socrates2> when i take ' * qty ' out i get no error
12:24:13 <socrates2> and it works fine
12:24:17 <dark> and thePrice is type Double?
12:24:32 <socrates2> int
12:25:36 <socrates2> its an Int
12:25:39 <shapr> I have a silly question... how could I fund the further development of Haskell?
12:25:42 <Marvin--> socrates2: both arguments to * must be of the same type...
12:25:55 <shapr> oh, I know
12:25:58 <socrates2> ok
12:26:00 <shapr> hire Alistair to write libs
12:26:03 <dark> shapr: Become independently wealthy, and then head the Haskell 2 standardization effort?
12:26:14 <Marvin--> socrates2: is thePrice Double? Then try  thePrice * fromInt qty
12:26:21 <shapr> dark: what do you think about hiring alistair whats his name to write libs?
12:26:26 <jmalicki-work> shapr: there are tons of people who would love to work obn haskell if someone was willing to pay them
12:26:28 <Heffalump> Reid?
12:26:29 <shapr> sounds more realistic to me
12:26:33 <shapr> yah, him
12:26:36 <shapr> reid consulting
12:26:40 <dark> I'm not aware of any Alistair.
12:26:41 <Marvin--> socrates2: or is the return type Double?
12:26:47 <dark> My world is quite small :)
12:26:48 <jmalicki-work> alistair cockburn?
12:26:52 <Heffalump> no, Reid.
12:26:55 <shapr> dark: http://reid-consulting-uk.ltd.uk/
12:27:10 <shapr> jmalicki-work: I spent an evening with a cockburn once
12:27:14 <shapr> he's a fun guy
12:27:21 <dark> We need to convince the government of Peru that Haskell is just the thing.
12:27:25 <shapr> heh!
12:27:56 <Marvin--> haha
12:27:59 <jmalicki-work> dark: you're probably better off convincing one guy
12:28:25 <jmalicki-work> dark: nightmares like programming languages mandated by the govt are bad for everybody
12:29:14 <dark> jmalicki: Like ADA?
12:29:35 <jmalicki-work> yes
12:29:51 <jmalicki-work> then you end up with engineers trying to write code
12:31:05 <shapr> as much reflection can be useful, it sure is abused in Java
12:31:15 <Heffalump> IWW?
12:31:34 <shapr> can't even claim minimal type safety when you instantiate stuff from a classname in a string
12:31:43 <Heffalump> you get an exception though
12:32:04 <shapr> createInstanceWithContext("com.sun.star.bridge.UnoUrlResolver",xLocalContext);
12:32:05 <shapr> that kind of stuff
12:32:07 <Marvin--> my biggest bone with java has to be the stupid stupidity of javac
12:32:10 <socrates2> how do u print strings to screen without the quotes?
12:32:20 <Marvin--> "Oh, oh, I know, let's drop warnings, everything should be errors!"
12:32:27 <Heffalump> use putStr not print
12:32:48 <Heffalump> Marvin--: that's in the language spec, if you mean the dead code stuff
12:32:58 <Heffalump> and uninitialised variables etc
12:33:04 <Marvin--> "Variable foo might not be initialized" <- helloooo I can PROVE that the variable is initialized when used!?
12:33:13 <socrates2> HeffaLump:that only works in IO
12:33:20 <Heffalump> yes, but the language spec imposes certain rules by which you must initialise it
12:33:27 <socrates2> what about in lowerlevel functions
12:33:38 <Heffalump> socrates2: you can't print stuff out without being in IO
12:33:50 <Marvin--> I don't get why "Foo foo = null," is better than "Foo foo;"
12:34:18 <Heffalump> Marvin--: means the language doesn't need to mandate null initialisations in the compiled code
12:34:26 <Heffalump> If you don't want a safe language, use C :-p
12:34:36 <dark> Marvin: It's part of the "compile everywhere, run once" philosophy :)
12:34:54 <dark> A compiler isn't allowed to be smarter about initializations even if it wants to be.
12:35:45 <Marvin--> Heffalump: I am using C and it's painful too
12:36:02 <Marvin--> I just want the compiler to stop pretending that it's smarter than me
12:36:25 * Marvin-- goes to fetch another beer
12:36:39 <socrates2> *** Term           : putStr "stock"
12:36:39 <socrates2> *** Type           : IO ()
12:36:39 <socrates2> *** Does not match : [Char]       
12:36:51 <dark> Marvin: I'm still working on the same beer :)
12:36:55 <socrates2> HeffaLump: that does not work
12:37:07 <Marvin--> dark: sheesh :)
12:37:16 <dark> socrates2: This is why Igloo told you to read about the IO monad.
12:37:44 <dark> Marvin: Well it was a .5 liter bottle :)
12:37:55 <Marvin--> dark: and I've got .5 liter cans, so? ;)
12:38:16 <dark> I get a perverse glee out of getting off-topic slashdot comments moderated up as "insightful".  Does this make me a troll?
12:38:28 <socrates2> anyone know the answer?
12:38:58 <Marvin--> dark: yes
12:39:04 <Marvin--> dark: or probably a meta-troll
12:39:43 <shapr> a para-troll?
12:40:07 <socrates2> Marvin?
12:40:11 <Marvin--> quasi-troll
12:40:11 <Marvin--> socrates2: yes?
12:40:18 * shapr wants just any beer
12:40:33 <shapr> no, the code must be completed!
12:40:35 <dark> A couple of years ago I switched to drinking only weird beer.
12:40:51 <socrates2> Marvin: How do u put a String variable to the screen without getting the error message i pmed above
12:40:52 <socrates2> ?
12:40:53 <Marvin--> a couple of years ago i switched to drinking only good beer
12:41:02 <Marvin--> socrates2: you learn about the IO monad
12:41:09 <dark> shapr: Silly.  Code is never complete.  Completing code is like reaching the speed of light.  The code gets heavier the closer you get to completion.
12:41:22 <socrates2> Marvin got a URL?
12:41:41 <Marvin--> socrates2: sorry, no :/
12:41:53 <socrates2> is there a simple answer
12:42:06 <shapr> dark: true, but my clients want some sort of output.
12:42:10 <socrates2> if its too long winded i will leave it
12:42:13 <socrates2> ?
12:42:48 <Marvin--> socrates2: okay, short answer. main = do { putStrLn "Foobar"; ... }
12:43:41 <socrates2> I know that
12:44:23 <dark> socrates2: The short answer is, any function which does IO has to be in the IO monad.
12:44:45 <dark> (or "be an IO computation" or however you want to call it.)
12:45:12 <shapr> hm, there's a brace missing in here somewhere.
12:46:13 <Marvin--> aaaaargh, they're going to start showing Dr. Phil on Swedish television
12:46:26 <Igloo> Wassat?
12:46:40 <dark> I'll never be as good a meta-troll as the guy who got a goatse.cx link moderated up to +5.
12:46:43 <Marvin--> a scary American tv psychologist
12:47:06 <Marvin--> Letterman usually mocks him a lot
12:47:08 <Igloo> Ah
12:47:22 <Igloo> Letterman?
12:47:36 <Heffalump> US talk show host
12:47:44 <Heffalump> dark: cool, how?
12:48:02 <dark> "The first discovery I'd like to present here is an algorithm for lazy evaluation of research papers. Just write whatever you want and don't cite any previous work, and indignant readers will send you references to all the papers you should have cited."
12:48:16 <dark> Heffalump: It actually was on-topic, insightful, and funny.  I don't remember the context, but I was amazed :)
12:48:58 <dark> It was probably a meta-article about slashdot itself, or something.
12:49:28 <socrates2> how can u ensure that a number is calculated to 2 decimal places?
12:49:32 <socrates2> 148.5  
12:49:44 <socrates2> i want 148.50!
12:49:56 <Heffalump> that's a printing issue
12:50:54 <socrates2> ok
12:51:22 <socrates2> one more thing then is there an easy to print are string without quotes
12:51:27 <socrates2> ?
12:52:15 <Heffalump> yes, use putStr, like I said several screens up...
12:52:35 <socrates2> i get IO errors
12:52:46 <Heffalump> which?
12:52:59 <socrates2>  Term           : putStr "stock"
12:52:59 <socrates2> <socrates2> *** Type           : IO ()
12:52:59 <socrates2> <socrates2> *** Does not match : [Char]       
12:53:10 <Heffalump> ok, so use it in IO context
12:53:17 <socrates2> stock is a variable by the way
12:55:44 <socrates2> Heffalump:?
13:00:02 <Heffalump> socrates2: where are you calling putStr from?
13:04:38 <socrates2> im 
13:04:43 <socrates2> not in main
13:04:48 <socrates2> in a function
13:04:52 <socrates2> called func
13:06:11 <socrates2> ideas?
13:06:25 <Heffalump> make func have an IO type
13:06:32 <shapr> dark: that's a great quote for research papers, where'd you get it?
13:07:04 <socrates2> how?
13:07:25 <Heffalump> what's its type now?
13:07:36 <socrates2> String
13:07:43 <socrates2> it gives strings
13:08:00 <Heffalump> and what calls it?
13:08:01 <socrates2> it takes a list of tuples with five elements
13:08:09 <Heffalump> (why do you need to print something out from it?)
13:08:16 <shapr> Tape = [Strip]
13:08:25 <shapr> String = [Thread]
13:08:35 <socrates2> Heffalump: because i do 
13:09:09 <Heffalump> well, you'll need to change the type of func to IO String
13:10:01 <socrates2> func :: [(a,b,c,d,e)] -> IO()  
13:10:04 <socrates2> like this
13:10:06 <socrates2> ?
13:10:24 <shapr> Salad :: [Lettuce]
13:15:05 <Heffalump> socrates2: yeah
13:15:18 <Heffalump> what was it before?
13:18:29 <dark> shapr: I got it from the Plan for Spam II, http://paulgraham.com/better.html
15:06:21 * shapr yawns
15:06:24 <shapr> g'morning Pseudonym 
15:06:41 <socrates2>  i have two problems
15:06:41 <socrates2> <socrates2> can u help me?
15:06:41 <socrates2> <socrates2> 1) I can print out strings without quotation marks (2) How the hell do i display numbers to 2 decimal places. 1.5 should be 1.50 for example
15:07:06 <shapr> 2) is just a print problem
15:07:12 <shapr> as Igloo said :-)
15:07:26 <shapr> figuring out how to do right hand zero padding should be easy enough :-)
15:07:26 <socrates2> :) is it possible to fix
15:07:38 <shapr> I'm confident you can figure it out.
15:07:44 <socrates2> yeah
15:08:13 <socrates2> really or are u just kidding
15:08:16 <socrates2> :/
15:08:19 <shapr> I'me serious.
15:08:31 <socrates2> yeah i can i will give it a go
15:08:43 <shapr> :-)
15:08:53 <socrates2> and number 1?
15:09:07 <shapr> Heffalump already have you the answer for that one.
15:09:49 <socrates2> ok i will goto work
15:18:50 * shapr yawns
15:20:08 * Arnia curls up in a ball
15:20:36 <shapr> good night Arnia 
15:21:04 <Arnia> Night
15:22:46 <socrates2> shapr: padZero number = if rem number 100 then show number ++ '0' else number 
15:23:13 <Pseudonym> G'day.
15:23:17 <Pseudonym> Sorry, briefly afk.
15:23:30 <shapr> socrates2: I'm falling asleep now, I can look at your code tomorrow....
15:23:47 <socrates2> i will hand it in tommorow
15:23:50 <shapr> g'night and g'day Pseudonym :-)
15:23:54 <Smerdyakov> What is rem?
15:23:57 <socrates2> thanks though
15:23:58 <Pseudonym> Night.  Sleep.
15:24:01 <Heffalump> socrates2: what uni are you at?
15:24:03 <socrates2> remainder
15:24:04 <Pseudonym> rem = remainder
15:24:11 <Pseudonym> as opposed to mod = modulus
15:24:13 <socrates2> Manchester
15:24:13 <Smerdyakov> rem number 100 : Bool ?
15:24:28 <socrates2> Smerdyakov: try it
15:24:30 <Pseudonym> Uh, good point.
15:24:40 <socrates2> Heffalump: u?
15:25:23 <Smerdyakov> socrates2, that code doesn't compile.
15:25:45 <socrates2> rem 100 100
15:25:51 <socrates2> rem 100 51
15:26:09 <Pseudonym> if (rem m n) then ...
15:26:11 <Pseudonym> Doesn't work.
15:26:23 <Pseudonym> rem returns an Integral thing, not a Bool.
15:26:34 <socrates2> good point
15:26:45 <Pseudonym> Also, it should be ++ "0", not ++ '0'
15:26:57 <Pseudonym> And it should be: else show number, not else number
15:26:59 <socrates2> i want to say if one number after the decimal point stick a zero there
15:27:03 <socrates2> else dont
15:27:17 <socrates2> its a tricky one
15:28:14 <Pseudonym> import Numeric
15:28:18 <Pseudonym> showFFloat 2 x
15:28:27 <Pseudonym> That should do it.
15:28:36 <socrates2> whats the x for?
15:29:23 <Pseudonym> Sorruy:
15:29:30 <Pseudonym> showFFloat (Just 2) x ""
15:29:32 <Pseudonym> where x is the number.
15:29:40 <socrates2> i ""?
15:30:07 <Pseudonym> Try it.
15:30:13 <Pseudonym> showFFloat (Just 2) 1.0 ""
15:32:00 <Pseudonym> Oh, hang on.
15:32:06 <Pseudonym> Significant digits or decimal places?
15:40:34 <socrates2> decimal places
15:40:37 <socrates2> sorry
15:40:47 <Pseudonym> Hmmm.
15:40:56 <Pseudonym> It should more correctly be used ina ShowS chain, too.
15:41:56 <socrates2> so do u know?
15:43:18 <Pseudonym> See, your problem is going to be with exponentials.
15:43:27 <Pseudonym> Handling, say, 1.24e20
15:43:53 <socrates2> ahh
15:44:21 <Pseudonym> Numerics are hard.
15:44:39 <Pseudonym> There's also the issue of IEEE's round-to-even semantics.
15:45:15 <Pseudonym> Do you have to take that into account?
15:58:19 <socrates2> dont worry
16:40:15 * Pseudonym isn't worried
18:20:44 --- mode: sterling.freenode.net set +n
22:09:47 --- topic: '["mo' nads than you", "We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/", "Gtk+HS 0.14.10:  http://www.cse.unsw.edu.au/~chak/haskell/gtk/","HWS-WP: http://www.dum.chalmers.se/~marvin/hws-wp/", "HaskellWiki resurrected", "ANNOUNCE: GHC version 5.04.2 released","HaSDL: http://www.xs4all.nl/~dark/hasdl-0.1pre7.tar.gz","New Mailing List for Template Haskell", "Tallest dwarf in Moria"]'
22:09:47 --- topic: set by Pseudonym on [Wed Jan 08 16:29:45 2003]
22:09:47 --- names: list (clog Chilli lament jak_ Radek ludde Pseudonym skylan d33p drlion Smerdyakov emu xkb_ andersca lindril SyntaxPolice smkl galority tez Heffalump Fractal liiwi tWip jmalicki-work jewel Logan Igloo SyntaxPolice__ gdsx mgoetze|away)
