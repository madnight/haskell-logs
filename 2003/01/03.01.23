00:16:57 * shapr bounces
01:37:17 <shapr> good morning evehboddy!
01:37:53 <Marvin--> morning
01:57:47 <Marvin--> morning dark
01:58:04 <dark> Greetingses
02:00:46 <dark> parseWord32 LittleEndian b = parseWord32 BigEndian (reverse (take 4 b))
02:00:49 <dark> I luv Haskell :-)
02:04:51 <Marvin--> heh
02:05:54 <Marvin--> but what's the type of parseWord32? What if b is longer than 4 characters? What happens with the rest?
02:12:40 * Marvin-- does NOT understand the quickcheck definitino of Arbitrary (a -> b)
02:13:35 <dark> Marvin: The type is Word32.  The rest of b is ignored, there's a separate getWord32 that takes an offset.
02:13:44 <Marvin--> dark: oh
02:13:59 <shapr> greetz
02:14:12 <dark> I considered making all of them type Integer, but I decided to have the caller do that when desired.
02:14:20 <dark> Otherwise it's too difficult to get signed/unsigned right :)
02:14:26 <dark> shapr, greetingses
02:14:45 <Marvin--> is Word32 signed or unsigned or both?
02:14:50 <Marvin--> (or neither?)
02:15:17 * shapr autographs a handy Word32
02:15:18 <dark> It's unsigned.  Int32 is the signed version.
02:16:29 <Marvin--> ah
02:16:41 <dark> I'm doing some dirty tricks here.  
02:16:42 <dark> getInt32 :: Endianness -> Binary -> Int -> Int32
02:16:42 <dark> getInt32 e b pos = fromIntegral $ getWord32 e b pos
02:18:33 <Marvin--> looks reasonable?
02:19:13 <dark> Yeah but it relies on the way fromIntegeral handles overflow :)
02:21:11 <dark> http://www.kuro5hin.org/ is funny today.
02:22:19 * Marvin-- is looking at var'aq
02:22:38 <shapr> nuq'Neh
02:22:59 <andersca> nuq'Daq oh puHpa eh
02:23:01 <andersca> or something
02:23:25 * shapr doesn't have his case correct
02:23:47 <Marvin--> http://images.ucomics.com/comics/ft/2003/ft030122.gif
02:26:23 <dark> Early in the Silmarillion there is an army of balrogs :)
02:26:29 <Marvin--> sure
02:26:57 <dark> Elves kicked ass back then.
02:26:57 <Marvin--> I just like the part about "arrow of +205 devastation" :)
02:27:34 * dark wields his chainsaw +5 of graphically explicit violence.
02:27:35 <Marvin--> I mean, with high level characters in D&D, it IS like that
02:27:38 * shapr grins
02:28:52 <dark> Yeah but high level characters can be funny :)
02:30:19 <Marvin--> Koen is going to WG2.8
02:30:20 * Marvin-- pouts
02:30:30 <shapr> WG?
02:30:43 <Marvin--> http://haskell.cs.yale.edu/wg2.8/
02:31:06 <Marvin--> horrible homepage though
02:31:17 <Marvin--> wait, that was 2002
02:32:07 <Marvin--> http://lamp.epfl.ch/wg2.8/ <- that looks more correct
02:33:02 <Marvin--> http://www.gamespy.com/comics/dorktower/archive.asp?nextform=viewcomic&id=687 <- hehehe
02:35:45 <shapr> have you played chez dork?
02:36:40 <Marvin--> no, only chez geek
02:38:02 <shapr> chez dork is great, you're one of the characters in dorktower, and you try to satisfy your obsessions
02:38:16 <Marvin--> cool :)
02:41:50 <dark> I wonder how many elf jokes I can hide in Format.ELF
02:42:57 <Marvin--> http://www.gamespy.com/comics/dorktower/images/comics/dorktower219.jpg <- so true, so true
02:44:02 <shapr> I'm not sure I want to put my life up on a blog
02:45:39 <dark> I considered writing a diary on advogato...
02:46:06 <Marvin--> I'm registered on advogato, but I haven't really done anything there
02:47:22 <shapr> we could get Arnia to add a blog to the haskell plone site
02:49:02 <shapr> my problem is that my personal and work life aren't very separate
02:52:14 <Marvin--> http://www.gamespy.com/comics/dorktower/images/comics/dorktower230.jpg
02:54:23 <dark> Hmm, gaming.
02:54:29 <dark> With, like, other people.
02:54:47 <Marvin--> yeah?
02:54:57 <Marvin--> I played the GoT CCG for *hours* last night with some friends :P
02:55:02 <shapr> hey, we've actually done that recently
02:55:04 <shapr> last week
02:55:10 <shapr> we're planning to do it again tomorrow
02:55:57 <shapr> dark: the ultimate game: http://wunderland.com/icehouse/Default.html
02:55:59 <dark> I grew spoiled in Groningen when there was a weekly gaming night at the youth club :)
02:56:07 <dark> Now I never get off my ass to organize one.
02:56:10 <shapr> I have an icehouse set, I even have the Black Ice extension!
02:56:20 <shapr> martian chess is the spiffiest chess variant I've ever heard of
02:56:46 <dark> Spiffier than Dragonchess?
02:56:51 <dark> I'm still working on a set for that :)
02:56:55 <shapr> dunno dragonchess
02:59:06 <Marvin--> several hours of playing, but we only played two games :p we played a 2v2 game and it took aaages
02:59:17 <dark> Hmm, this stuff reminds me of an Atlantis game I learned once, which also used simple colored markers.
03:00:00 <Marvin--> Two intrigue/control decks vs one military and one power deck, it was awesome
03:00:08 <dark> The main feature of the game was that generating new pieces involved blowing up parts of the board.  Sometimes this could set off a chain reaction that would wipe out everything :)
03:06:10 <shapr> sounds very cool
03:31:11 <shapr> hi Helen 
03:31:17 <Helen> Hi :) 
03:31:23 <shapr> new to haskell?
03:31:54 <Helen> I studied it a bit at uni :) 
03:32:10 <shapr> looking to brush up on it?
03:32:18 <shapr> want to use it for web development? :-)
03:32:29 <Marvin--> heh
03:32:30 <Helen> Nah just curious that's there's an IRC on it :)
03:32:43 <Helen> Our evil uni assignment involved the generation of HTML :)
03:32:55 <shapr> not so hard with Haskell
03:33:07 <Helen> just a different way of thinking about it
03:33:12 <shapr> yah, I agree
03:33:20 <Helen> Quite elegant in some ways
03:33:27 * shapr wonders exactly how Thiemann's WASH/HTML generates html source
03:33:39 <shapr> I wonder if he used ShowS ...
03:33:40 * shapr looks
03:34:02 <Helen> Are there actually people using it as a CGI module?
03:34:21 <shapr> yup
03:34:31 <shapr> maybe not lots of people, but some...
03:34:47 <shapr> Marvin-- added apache style loadable module support to the Haskell Web Server
03:35:11 <Helen> there's actually a web server written in it?
03:35:12 <Marvin--> rofl, the compiler construction course got an assistant
03:35:17 <Marvin--> I wonder why, we're just seven or eight students on it
03:35:51 <shapr> the HWS-WP url in the topic leads to the web server with plugin support
03:36:14 <Marvin--> and the assistant is a guy I worked together with during fall :P
03:36:16 <shapr> Marvin--: did you ever send an email to marlow telling him about that?
03:36:53 <Marvin--> shapr: yup
03:36:57 <shapr> what did he say?
03:37:00 <Marvin--> he said something like "Very Cool!"
03:37:07 <shapr> heh :-)
03:37:10 <shapr> good response
03:37:14 <Marvin--> very neutral ;)
03:37:51 <shapr> hmmm
03:37:52 <Marvin--> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/komp/2003/laboration/cccPM.html <- this is the compiler we're going to write
03:38:26 <shapr> wow, augustsson wrote part of the course...
03:38:32 <shapr> and hallgren
03:38:58 <shapr> I want to take the classes you're taking :-)
03:39:17 <Marvin--> heh
03:40:30 <shapr> looks like a fun course
03:40:43 <shapr> quadruples are neat
03:41:02 <shapr> oh, they furnish haskell modules for jasmin and quadruples
03:41:03 <shapr> spiffy
03:41:13 <shapr> Helen: tempted to write more code with Haskell?
03:41:24 <shapr> if you have any questions I'd be happy to help as much as I can.
03:42:42 <Helen> :) maybe
03:42:57 <Helen> Is the haskell community very large?
03:43:09 <shapr> no, not very large
03:43:12 <Helen> Active?
03:43:20 <shapr> yes, active :)
03:43:24 <Marvin--> bah, they're giving all the asm for all the code constructs? :(
03:43:42 <shapr> Marvin--: I'm sorry, do you think the class will be too boring? 
03:43:44 * shapr grins
03:44:18 <Helen> :) what I awnt to know, is there more to Haskell than hugs?
03:44:23 <shapr> sure
03:44:31 <shapr> GHC is the most popular Haskell compiler
03:44:49 <dark> Hmm, I wonder if anyone has written a C parser in Haskell.
03:44:59 <Marvin--> shapr: the less we have to figure out ourselves the more boring it'll be
03:45:25 <Marvin--> dark: probably. For example during this course last year? ;)
03:45:31 <shapr> yow
03:45:48 <dark> Marvin: So is it Free? :)
03:45:49 <shapr> Helen: GHC is the most populer Haskell compiler, and there's also NHC
03:46:06 <shapr> "popular"
03:46:13 * shapr is starting to spell in swedish
03:46:31 <Helen> what's it's used for mostly?
03:46:49 <Marvin--> dark: I don't know what license they've been written under, but I'll talk to my lab partner about releasing ours as GPL ;)
03:47:02 <shapr> the common wisdom is that Haskell is best at compilers.
03:47:14 <shapr> I just really like using it.
03:47:14 <Marvin--> this is going to be fun fun fun
03:47:21 <Helen> ah, that makes sense. That's what we were using it for
03:47:27 <Marvin--> I'd better go to the university
03:47:36 <Marvin--> friends to meet, lunch to eat, books to buy... :)
03:47:38 <shapr> I don't know if I agree with the common wisdom.
03:47:46 <dark> Haskell is best at *everything*.
03:47:47 <Helen> I was just frightened by a language that could do quick sort in one line :)
03:47:48 <shapr> in my experience, Haskell is good at a lot of things
03:47:51 <shapr> heh
03:47:58 <Marvin--> Helen: so can Python I'm pretty sure :)
03:48:01 <Heffalump> how long a line?
03:48:13 <shapr> in my opinion, the only downside of Haskell is that monads are difficult to understand.
03:48:23 <dark> Heck, in C, quicksort is one function call.
03:48:27 <shapr> much like the jump from subroutines to objects
03:48:41 <Helen> yeah but this was actually the coding logic
03:48:43 <Marvin--> dark: I think we're talking about implementation ;)
03:48:53 <Helen> :) I can't remember how long, it was a couple of yeras ago now
03:49:38 <Marvin--> well, I'm off *waves*
03:49:42 <shapr> cya
03:50:06 <Heffalump> quicksort xs = if null xs then [] else let x=head xs in quicksort (filter (<y) xs)++filter (==y) xs++quicksort (filter (>y) xs)
03:50:25 <shapr> looks like the cheesy one that picks the head as the pivot...
03:50:44 <Heffalump> that's not particularly cheesy, it's just susceptible to being consistently bad on certain data
03:50:48 <Heffalump> as opposed to randomly bad
03:50:50 <Heffalump> but you're not here
03:51:14 * Heffalump repeats himself
03:51:17 <Heffalump> that's not particularly cheesy, it's just susceptible to being consistently bad on certain data
03:51:20 <Heffalump> as opposed to randomly bad
03:54:18 <shapr> yay, d steinitz is asking for a database mailing list
03:54:28 <shapr> I want better database bindings in haskell
03:57:40 <shapr> boing
03:58:18 <shapr> let's all bounce together now...
04:04:07 <shapr> I could start a thread on the libraries list about database bindings...
04:09:53 <shapr> Igloo: do you know when Template Haskell will be released?
04:10:58 <Heffalump> next release of GHC AIUI
04:11:05 <shapr> oh excellent
04:11:11 <shapr> any idea when that will be?
04:11:37 <Heffalump> don't think so
04:11:44 <Helen> Nice to meet you all :)
04:13:41 <shapr> yay, new HOpenGL BSD port 
05:26:25 <shapr> cool, looks like Clean's Object-IO approach is gaining momentum as the standard Haskell gui lib
05:26:28 <shapr> nifty
06:14:58 * Janni greets everyone
06:44:12 <Marvin--> I went and registered my master project today
06:48:11 <shapr> cool!
06:48:14 <shapr> what is it?
06:48:20 <shapr> hi Janni 
06:49:04 <Janni> hi
06:49:17 <shapr> how's the code treating you?
06:49:29 <Marvin--> I had to invent a preliminary title :P
06:49:36 <Marvin--> "Proving and Testing Functional Correctness"
06:49:45 <shapr> sounds great!
06:49:52 <shapr> has Koen given you any guidance?
06:50:26 <Marvin--> well he sure has given me a lot to look at :P
06:50:30 <shapr> Marvin--: I'm very interested also, do you have your links / references online somewhere?
06:50:38 <shapr> oh oh, I wanna see!
06:50:41 <Marvin--> I'm meeting him when he's coming back from the wg2.8 meeting
06:51:55 <Marvin--> shapr: Maarten de Mol's master project about Clean Prover System is a pretty good read, and aside from that, just read anything you can find about automatic theorem proving I suppose... Google for otter, E prover, gandalf, spass...
06:52:19 <dark> That sounds like a dutch name too.
06:52:27 <Marvin--> yes
06:52:42 <shapr> what's up with all these dutch people in programming?
06:52:51 <Marvin--> one of the "crazy dutch people" working with Clean (quoth Koen)
06:52:52 <shapr> especially functional programming...
06:52:54 <shapr> heh
06:56:35 <Marvin--> "Lisa, in this house we obey the laws of thermodynamics!"
06:57:21 <shapr> I like dark's quote about Chalmers
06:58:30 <shapr> you have some excellent quotes saved
06:59:19 <Marvin--> which one? "There was internet at the top"? :)
07:00:18 <Smerdyakov> Anyone know if lindril is associated with any university?
07:00:28 <shapr> is the trolley quote also about Chalmers?
07:00:33 <shapr> I don't know.
07:00:46 <shapr> I assume that lindril is in pittsburgh from the hostname.
07:00:47 <Marvin--> trolley?
07:00:55 <shapr> er, tram?
07:01:00 <Marvin--> ah, heh
07:01:06 <Marvin--> well, it's Göteborg, yes
07:01:15 <Marvin--> Angered is a part of the city
07:01:19 <shapr> heh!!!
07:01:23 <Smerdyakov> shapr, yes, and so am I, so I wonder if we are at the same school. =)
07:01:38 <shapr> Smerdyakov: well, ask :-)
07:01:51 <Smerdyakov> Idle for over an hour!
07:02:16 <shapr> well, send a private message or a memo
07:02:46 <Smerdyakov> I think I will just take you up on that offer!!
07:03:44 <shapr> hm, axel simon just sent a neat (and long) message to the haskell GUI mailing list.
07:03:55 <shapr> nifty discussion on that list
07:04:25 <shapr> summarized: "we want a standard Haskell graphical widget kit, what should it be?"
07:04:53 <shapr> Simon PJ said "I suggest we port Object-IO to Gtk or somehow to Linux"
07:04:59 <shapr> others chimed in with "what about Mac?"
07:05:25 * shapr suddenly wonders if the blow by blow commentary is boring people :-)
07:06:00 <Marvin--> Object-IO?
07:06:11 <Marvin--> I think Clean's IO system is called ObjectIO
07:06:16 <shapr> that's the one
07:06:28 <Marvin--> ah
07:06:37 <Marvin--> shapr: http://data.mpi-sb.mpg.de/internet/news.nsf/Spotlight/19991004 <- this article is pretty nifty
07:06:57 <shapr> someone ported Clean's Object-IO to ghc on windows
07:07:02 <Marvin--> ooh
07:07:03 <shapr> I think it was Simon PJ originally
07:07:19 <shapr> and Krasimir somebody updated it from ghc4 or so...
07:07:24 <shapr> but couldn't get it to work with Gtk
07:07:30 <Marvin--> having Object-IO on all platforms would be nifty
07:07:33 <shapr> everyone who uses Object-IO seems to love it
07:07:42 <shapr> so that's starting this whole ruckus
07:07:52 <Marvin--> but unfortunately there are more problems than GUI toolkit to get compatible programs
07:08:20 <Smerdyakov> Anyone have a URL to Object-IO information?
07:08:29 <Marvin--> during the summer, I tried to design a configuration system for the CAPS client to be used both on windows and unix, that was hellish
07:08:40 <shapr> Smerdyakov: http://research.microsoft.com/~simonpj/Papers/haskellobjectio.htm
07:09:04 <shapr> I'd like to have some way to write Haskell GUIs that would work on both Linux and Win32
07:09:10 <shapr> I don't have any need for Mac so far
07:09:43 <shapr> I haven't even touched Object-IO since it doesn't work on linux
07:09:46 <Marvin--> what I came to realize when designing the config system was that the differences between windows and unix are *vast*
07:09:51 <shapr> truly they are
07:09:58 <shapr> in many ways
07:11:52 <lament> 'everything is a file' versus 'everything is a window'? :)
07:12:07 <Marvin--> I've always been big on platform independence, but I've sorta stopped believing in it
07:12:32 <Marvin--> well, first of all you have the "application" concept in windows, which doesn't really exist on unix afaik
07:12:52 <Marvin--> then there's of course the registry
07:12:54 <lament> yeah, which is probably unfortuante
07:12:58 <lament> *unfortunate
07:13:02 <shapr> registry is a bad word...
07:13:19 <Marvin--> windows doesn't use environment variables pretty much at all, unix uses them for everything
07:13:49 <Marvin--> unix uses decentralized config files instead of a registry, which also means that there's absolutely no standard for them (which sucks badly)
07:14:11 <Marvin--> unix has the pipe ("yay") but windows uses COM a lot
07:14:14 <shapr> on the good side, it means you can edit them by hand, and usually figure them out without instructions
07:14:36 <Marvin--> yes and no, there's always syntactical issues
07:14:39 <shapr> I agree the non-standardness sucks
07:14:46 <Marvin--> and often you're asked to write a config file from scratch
07:14:49 <shapr> yah, that's true.
07:15:00 <ludde> the registry sucks.. if you reinstall windows you lose all application settings
07:15:07 <shapr> I like those unixy apps which have a command line options to spit out a default config file
07:15:08 <Marvin--> It doesn't help when the man page says "It looks just like sendmail/bind/somethingelse" when you haven't written config files for sendmail/bind/somethingelse ;)
07:15:09 <shapr> that's a cool trick
07:15:17 <Marvin--> yes, the registry sucks
07:15:25 <Marvin--> but the unix way sucks too
07:15:58 <Marvin--> I like the way gnome 2 uses corba a lot
07:16:12 <ludde> there should be some tree-structured config file format that you can access using a well defined api
07:16:22 <Marvin--> walters' debian-corba is way cool, too bad it hasn't been deployed properly
07:16:23 <ludde> like the registry api, but one config file / application
07:16:28 <shapr> ludde: xml registry
07:16:30 <Marvin--> ludde: like gconf
07:16:37 <shapr> I could live with an xml registry
07:16:37 <Marvin--> gconf is really neat
07:16:39 <shapr> yah, it is
07:16:42 <lament> why would you want xml
07:16:51 <ludde> i don't see any reason for xml either
07:16:58 <lament> actually, why would you care about what format it uses
07:16:59 <ludde> I think it's too verbose.. becomes cluttered
07:17:02 <shapr> because I can edit it with notepad, or edlin
07:17:10 <lament> oh... sexprs it is, then :)
07:17:14 <ludde> lament: because you want to edit it manually sometimes
07:17:15 <shapr> I also think xml is too verbose 
07:17:25 <lament> sexprs sexprs sexprs
07:17:29 <Marvin--> *shrug* it's standard, it's not TOO hard to edit and there are some very good parsers for it
07:17:33 <shapr> right, exactly
07:17:38 <lament> sexprs are standard too
07:17:39 <Marvin--> and it's tree stuctured which is good
07:17:42 <shapr> yup
07:17:48 <lament> and prettier
07:17:56 <Marvin--> but I think gconf is backend-independent
07:18:07 <ludde> when are you supposed to use <Tag param="value"\> and when <Tag>value</Tag> ?
07:18:26 <ludde> or..
07:18:58 <ludde> <Group><A>value1</A><B>value2</B></Group> v.s. <Group A="value1" B="value2"/>
07:19:44 <shapr> sexprs or registry do not answer that question differently
07:21:41 <lament> but sexprs are better because they're about SEX
07:22:02 <Marvin--> hrrm :)
07:23:43 <shapr> hi tmoertel!
07:23:53 <tmoertel> hi shapr! long time, no chat.
07:24:00 <shapr> how's life treating you?
07:24:02 <shapr> lots of good code?
07:24:35 <tmoertel> life's been busy, busy, busy -- mostly business-related stuff, not a lot of good code, sadly
07:25:10 * tmoertel notices that business = busy-ness, hmm . . .
07:25:19 <tmoertel> how about with you?
07:25:28 * Marvin-- swears at newt
07:25:43 <shapr> java and xml here, though I continue to play with Haskell in my spare time
07:27:32 <tmoertel> I'm starting a new project today. It builds web sites (and other media "targets") from XML repositories.
07:27:39 <shapr> cool!
07:27:48 <shapr> will you be able to write it in Haskell?
07:27:55 <tmoertel> I am going to try to work in Haskell somehow, maybe in the dependency analysis.
07:28:24 <Marvin--> wtf
07:28:38 <Marvin--> now let's see if this book is any good
07:29:05 <shapr> I'm doing OpenOffice to other XML flavors, I wonder if it would be easier to prototype in Haskell before rewriting in Java
07:29:17 <Marvin--> heh
07:29:39 <Smerdyakov> shapr, this sounds like something that has probably been done before. Are you sure it hasn't? =)
07:29:53 <shapr> Smerdyakov: not to the XML flavor I want
07:30:09 <tmoertel> vanilla? ;-)
07:30:16 <Smerdyakov> Aren't there billions of tools for converting between XML documents in different schemas?
07:30:34 <shapr> sort of...
07:30:51 <Smerdyakov> So why are you using Haskell or Java? =)
07:31:32 <shapr> a) I love Haskell b) I'm paid to do this in Java
07:32:07 <Marvin--> I wonder if I can learn ML by reading this book :)
07:32:25 <Marvin--> ("Modern Compiler Implementation in ML")
07:32:26 <shapr> from what I've heard, ML is Haskell without exceptions, and without Integer
07:32:49 <Marvin--> yeah, well, it's the syntax I don't know
07:33:20 <Marvin--> datatype tree = LEAF | TREE of tree * key * tree
07:33:38 <Heffalump> Marvin--: probably a good plan :-)
07:33:40 <Marvin--> eeeew... val empty = LEAF  ... fun ...
07:33:44 <Smerdyakov> ML is Haskell *with* exceptions, perhaps you mean? =)
07:34:05 <Smerdyakov> Marvin--, why "ew"?
07:34:14 <Heffalump> ML is Haskell with horrible syntax, references, functors, and no type clases
07:34:17 <Marvin--> Heffalump: actually, we're allowed to use whatever language we please to implement our compilers, it's just the coursebook that's in ML
07:34:27 <Marvin--> Smerdyakov: "val" and "fun" annotations
07:34:37 <Marvin--> seems totally unnecessary
07:34:46 <Smerdyakov> fun gives you recursion.
07:34:55 <Marvin--> so you can say  val foo x y = ...?
07:35:00 <Smerdyakov> You don't need to globally analyze the program to resolve references.
07:35:00 <Heffalump> no
07:35:12 <Heffalump> it doesn't do binding group analysis for you, in other words
07:35:19 <Marvin--> the whole point with functional programming is that functions-are-values, isn't it?
07:35:22 <Heffalump> mutually recursive stuff has to be done with fun ... and ...
07:35:30 <Heffalump> otherwise you can only refer to definitions that are above you
07:35:35 <Smerdyakov> You can do val foo = fn x => fn y => ...
07:35:37 <Heffalump> Marvin--: since it's not pure, evaluation order matters
07:35:40 <Marvin--> Heffalump: yeah, I saw that for   datatype ... and ...
07:35:42 <Heffalump> so you need to know the difference
07:35:48 <Marvin--> Heffalump: ugh, yeah
07:36:16 <Heffalump> I end up writing a lot of functions that take () as an argument just to delay evaluation
07:36:17 <Smerdyakov> What is this crucial thing about which you need to know the difference in what has been discussed so far?
07:37:00 <Marvin--> huh?
07:37:13 <Smerdyakov> I am asking why it was relevant for Heffalump to say <Heffalump> so you need to know the difference
07:37:26 <Heffalump> Smerdyakov: between val and fun
07:37:45 <Marvin--> Regular expressions, NFA and DFA... I think I can skip this chapter
07:37:46 <Heffalump> IM really "you need to be able to tell the compiler which you mean", not "you need to understand what each does"
07:38:14 <lament> A language can be either beautiful, or fast.
07:38:22 <lament> ML is fast :)
07:38:28 <Marvin--> you mean xor? :)
07:38:36 <lament> yes :)
07:39:15 <dark> Marvin: You have a quote from me about Chalmers?
07:39:23 <ludde> ML seems pretty slow to me, at least compared to C for this particular application.. mldonkey.. a file sharing client on the edonkey network.. it uses like 30% cpu all the time
07:39:24 <shapr> he has two!
07:39:33 <Marvin--> one about Chalmers and one about Göteborg in general
07:39:41 <Smerdyakov> Heffalump, I don't think that's an accurate "reason why". fun is just syntactic sugar for val rec. What you really need is to be able to mark some bindings as [mutually] recursive. Maybe that's what you meant.
07:39:47 <lament> ludde: are you using ocaml?
07:39:53 <Marvin--> dark: http://193.11.232.159:8080/quotes/ go find them yourself :)
07:40:05 <ludde> lament: it's not my application, but yes, it's written in ocaml
07:40:21 <Smerdyakov> ludde, try using SML with MLton and see if it's faster :D
07:40:22 <andersca> Marvin--: so did you meet koen?
07:40:34 <Marvin--> andersca: yup, he was talking to Peter Dybjer
07:40:45 <Heffalump> smerdyakov: no, the evaluation time is also important
07:40:48 <Marvin--> so now my master project is registered and all that
07:40:51 <andersca> Marvin--: ah
07:40:52 <andersca> Marvin--: koen is cool
07:40:59 <andersca> Marvin--: lovely, what is it?
07:41:10 <Heffalump> fun foo () = bar blat and val foo = bar blat are very different things
07:41:17 <Marvin--> andersca: the preliminary title, which I invented on the spot, is "Proving and Testing Functional Correctness"
07:41:26 <andersca> Marvin--: sounds like fun
07:41:26 <Smerdyakov> fun foo () = bar blat is just val foo = fn () => bar blat
07:41:27 <Marvin--> oh, this reminds me I should have a word with CSN now
07:41:29 <ludde> quickcheck ?
07:41:34 <Marvin--> andersca: very!
07:41:36 <Smerdyakov> You don't even need fun if you don't want to use recursion!
07:41:39 <Marvin--> ludde: among other things, yes
07:41:53 <shapr> yay quickcheck!
07:42:02 <Heffalump> smerdyakov: ah, ok, that's true
07:42:16 <Smerdyakov> Soo... you'll need a better example to show anything, and then you'll see that the only salient thing is that you need to be able to designate nests of recursive bindings ;-)
07:42:22 <andersca> Marvin--: I'm pondering writing a multi-threaded filemanager in haskell
07:42:23 <Marvin--> I realized that quickcheck isn't all that good at higher order functions
07:42:31 <shapr> andersca: yay!
07:42:42 <shapr> Marvin--: oh tell me more..
07:42:52 <shapr> have you looked at the monadic quickcheck version?
07:43:03 <Heffalump> but given that you don't want to have to write lambdas (i.e. "fn") everywhere, the distinction between val and fun is important
07:43:09 <Marvin--> I've looked briefly at the article, but not more closely
07:43:25 <Heffalump> well, I don't want to have to write lambdas everywhere, anyway
07:44:15 <Marvin--> shapr: the thing is that when involved with higher order functions, you want to be able to say things like "If f is associative and has unit e then..." and I'm at a loss how to do that
07:44:30 <Marvin--> maybe you can write a custom Arbitrary instance that only generates associative functions
07:44:34 <shapr> I don't understand...
07:45:01 <Marvin--> you do know what associativity is, right?
07:45:07 <shapr> sure
07:45:26 <shapr> do you have an example I could look at?
07:45:50 <Marvin--> if f is associative and has unit e (that is, f e x == x and f x e == x), then for example, foldr f e xs = foldl f e xs
07:46:05 <Marvin--> if xs is finite of course
07:46:38 <shapr> ok...
07:46:39 <shapr> how is that useful?
07:47:28 <Marvin--> foldr f x xs == f x (foldr f e xs)
07:47:54 <Marvin--> which means that foldl f x xs == f x (foldl f e xs), which is a useful lemma when you want to prove correctness of foldl-like functions
07:48:48 <Janni> i'm failing a simple problem. i want to generate a list of all possible orders of a given list. can someone help?
07:49:04 <shapr> I think you can do that simply with a list comp...
07:49:06 <Heffalump> write a function to insert a single element into a list at all possible points
07:50:07 <Marvin--> shapr: in any case, it's something which is tricky to test but fairly easy to prove with induction over the list
07:55:05 <shapr> Marvin--: I'll have to think about that...
08:00:51 <Marvin--> heh, this book doesn't just talk about how to create parsers, it also talks about how to create parser generators :)
08:01:17 <andersca> what about parser generator generators?
08:01:24 * shapr snickers
08:01:26 <Marvin--> sorry, no
08:01:47 <Marvin--> Does yacc use yacc to parse its files?
08:02:39 <Smerdyakov> Marvin--, Appel's book?
08:02:49 <Marvin--> "Grammar 3.26. A grammar capturing the essence of expressions, variables, and pointer-dereference in the C language."
08:02:51 <Marvin--> Smerdyakov: yup
08:03:22 <Marvin--> "Figure 3.27. LR(1) states for Grammar 3.26."
08:03:27 <Marvin--> lots of boxes and arrows there
08:04:21 <Marvin--> Smerdyakov: it seems quite good
08:04:41 <Smerdyakov> Marvin--, if you spend a lot of time learning about how parser generators work or learning to write your own effective parsers from scratch, then you have missed the essence of what studying compiler design today is really about ;-)
08:04:59 <Marvin--> Smerdyakov: yup, I'm not going to delve into this too much :)
08:05:49 <Smerdyakov> All that's really worth doing from a practical perspective is looking at sample .lex and .grm files.
08:06:49 * Heffalump agrees
08:07:13 <Heffalump> just use mllex and mlyacc and all will be right with the world :-)
08:07:23 <Marvin--> *cough*happy*cough*
08:07:47 <Marvin--> I think that the first four chapters of this book could've been tossed away and be prerequisites
08:17:20 <Marvin--> 'One might say, by way of excuse, "but the language in which I program has the kind of address arithmetic that makes it impossible to know the bounds of an array." Yes, and the man who shot his mother and father threw himself upon the mercy of the court because he was an orphan."
08:18:10 <Smerdyakov> I remember that =)
08:21:56 <shapr> tmoertel: this may be a silly question, but have you looked at Silva for Zope?
08:22:10 <tmoertel> shapr: no, what's that?
08:22:29 <shapr> it's a useful xml tool
08:22:41 <shapr> but I don't know the boundaries of your xml project
08:22:51 <Segora> re
08:22:53 <shapr> tmoertel: http://infrae.com/products/silva
08:23:03 * tmoertel checks it out . . .
08:27:43 <tmoertel> shapr: that looks cool. can it support arbitrary DTDs?
08:30:15 * tmoertel must get some tea . . .
08:33:09 <shapr> tmoertel: for the Editor produced XML? or what?
08:39:49 <shapr> anyone know if HaXml has XSchema support?
08:40:19 <Marvin--> I don't get this, why does my listbox break, but not the one in the example code
08:41:44 * Marvin-- whimpers
08:45:23 <shapr> hi rublik 
08:45:38 <rublik> hello :)
08:47:11 <shapr> do you use Haskell?
08:47:55 <Marvin--> is it a good sign when an example program that comes with the lib segfaults when you fiddle with it?
08:48:08 <shapr> sure, if they're your competition.
08:48:15 <Marvin--> unfortunately not
08:48:27 <shapr> is this newt?
08:49:26 <Marvin--> yes
08:49:33 <shapr> scary
08:49:42 <Marvin--> Selected listbox items:
08:49:42 <Marvin--> Segmenteringsfel
08:49:50 <Marvin--> guess they're having problems with the listboxes too :)
08:50:19 <shapr> :)
08:50:30 <rublik> No, i use Python only (sorry for my bad english)
08:50:49 <shapr> coming to investigate the world of purely functional programming?
08:51:00 <shapr> rublik: would you like to learn Haskell?
08:51:20 <rublik> shapr: yes :)
08:52:23 <shapr> if you're able to purchase books on Haskell, I would suggest Thompson's book "Haskell : The Craft of Functional Programming" or if you like math lots, Hudak's book ...
08:52:32 * shapr looks behind him for the full title
08:52:54 <rublik> Ok,thx.
08:53:07 <shapr> Hudak wrote "The Haskell School of Expression"
08:53:25 <shapr> if you can't order a book, there's the YAHT tutorial on Hal Daume's web page.
08:53:36 <shapr> would you like the url the YAHT tutorial?
08:54:32 <rublik> sure :)
08:55:26 * SyntaxPolice likes Haskell School of Expression
08:56:04 <SyntaxPolice> though its hard to skip around in that book, I found.
08:56:56 <shapr> SyntaxPolice: do you have a good math background?
08:57:16 <shapr> manuel chakravarty also prefers Hudak's book, and he teaches Haskell
08:57:58 <SyntaxPolice> shapr: not particularly good, no.
08:58:06 <jmalicki-work> shapr: what is a good math background?
08:58:43 <Marvin--> the more, the better :)
08:58:51 <jmalicki-work> Marvin--: pssh
08:59:06 <jmalicki-work> Marvin--: as long as it doesn't involve any analysis classes
08:59:32 <shapr> rublik: http://www.isi.edu/~hdaume/htut/
08:59:35 <shapr> jmalicki-work: good question.. mine is so poor I can't tell you :-)
08:59:35 <rublik> shapr: thx
08:59:52 <jmalicki-work> shapr: heheh so's mine
09:00:18 <shapr> jmalicki-work: I had business calculus in college, that's the extent of my formal math education.
09:00:34 <jmalicki-work> oh hehe i guess i've had a decent bit more
09:00:41 <shapr> of course, my formal CS is cs 101, so formal isn't really that important
09:00:50 <jmalicki-work> although i think the rest of it came out to like a 1.2 GPA
09:01:16 <jmalicki-work> formal will make you dumber unless the classes are *really* good :)
09:01:41 <shapr> I have wondered if formal education leads people to think that's the only way to do something
09:02:06 <jmalicki-work> well i mean they structure classes such that people will become robots
09:02:22 <Marvin--> I tend to think that people with formal education overvalue it and people without undervalue it :)
09:02:22 <jmalicki-work> they pay lip-service to independent thought and creativity, while quietly working to kill it
09:02:46 <shapr> I would have liked to be let loose in a library, with a bunch of knowledgeable people handy so I could ask questions
09:02:52 <jmalicki-work> Marvin--: in all the formal education i've had i've learned disturbingly little
09:03:03 <jmalicki-work> Marvin--: if done *really well*, ill agree its valuable
09:03:10 <jmalicki-work> Marvin--: its so often just horrible, though
09:03:36 <Marvin--> jmalicki-work: my university studies have been 99% good
09:03:48 <shapr> swedish education culture is spectacular though
09:03:52 <jmalicki-work> i've learned lots more from reading books and talking to others who read books
09:04:09 <shapr> the idea of life long learning seems to be an integral part of the culture
09:04:14 <shapr> I *really* like that
09:04:19 <jmalicki-work> yeah
09:04:51 <shapr> it's not so strong in the US
09:05:46 <shapr> it's also different in a system where college is free, as long as you don't suck
09:06:29 <shapr> though I've heard it doesn't work so well in .de
09:07:25 <shapr> anyway, interest in Haskell is one good filter for those wish to continue teaching themselves.
09:09:34 <shapr> yay! HTk binary bundles for linux/windows/solaris! http://www.informatik.uni-bremen.de/htk/
09:09:45 <Marvin--> htk?
09:10:44 <shapr> uses the Tk from Tcl/Tk I think
09:12:23 <Marvin--> oh
09:12:27 <Marvin--> ugh
09:13:39 <shapr> it does solve my linux/win32 problem
09:13:46 <Marvin--> true
09:14:31 <Marvin--> tk is ugly as hell though
09:15:00 * shapr shrugs
09:15:15 <shapr> nothing I can do about that
09:18:27 <jmalicki-work> aren't there TK themes out there?
09:18:37 <jmalicki-work> and/or patches?
09:27:07 <dark> I wonder what "HTTP/1.1 Application Restarting" means.  I bet they made that up.
09:27:35 * shapr snickers
09:27:48 <jmalicki-work> hah
09:27:58 <jmalicki-work> does it have an error code associated with it?
09:29:15 <dark> It seems to be a code 500.  But that's with wget, mozilla doesn't seem to want to tell me.
09:30:02 <jmalicki-work> you could use telnet
09:30:06 <jmalicki-work> 500 is bad request
09:30:19 <jmalicki-work> err no
09:30:21 <jmalicki-work> thats 400
09:30:28 <Marvin--> 500 is internal server error
09:30:29 <jmalicki-work> 500 usually means CGI script coredumped
09:30:42 <Marvin--> yeah, or wasn't executable or something
09:31:19 <dark> So where's that "Application Restarting" coming from?  It's in the html.
09:31:35 <jmalicki-work> Marvin--: doesnt being nonexecutable usually result in a 403 or something like that?
09:31:42 <jmalicki-work> dark: the server error redirection page probably
09:32:05 <dark> jmalicki: so, they made it up :-)
09:32:18 <jmalicki-work> hehe yeah
09:32:39 <jmalicki-work> im curious what some of them mean
09:32:46 <jmalicki-work> like "202 Accepted"
09:32:54 <dark> It's probably more like "Application not there because we're running a Java thing on Windows NT and it crashes all the time"
09:33:01 <jmalicki-work> i guess you could use that for a post with no data
09:33:04 <jmalicki-work> hehe yeah
09:33:15 <jmalicki-work> or "412 Precondition failed"
09:33:18 <jmalicki-work> precondition failed?
09:33:25 <dark> I think 202 Accepted means the request was stored for later handling.
09:33:32 <jmalicki-work> oh ok
09:33:36 <dark> So it's not quite "ok" yet but also there's nothing wrong with it.
09:33:52 <jmalicki-work> or the other "417 Expectation failed"
09:34:01 <jmalicki-work> an Expectation that was different than a precondition?
09:34:09 <jmalicki-work> and they both need separate error codes than 500?
09:34:56 <dark> "Its purpose is to allow a server to accept a request for some other process (perhaps a batch-oriented process that is only run once per day) without requiring that the user agent's connection to the server persist until the process is completed."
09:36:54 <dark> jmalicki: Preconditions are things like "If-Modified-Since", and expectations are specifically in the "Expect" header. 
09:37:24 <dark> I think there's currently only one Expect value defined and it's optional, so there's no point in 417 yet :)
09:38:01 <dark> The main reason for having separate codes for them is, I think, to allow the client to retry without the header that's causing trouble.
09:38:33 * Marvin-- swears at newt
09:38:38 <dark> The client can't do that if all it gets is "bad request", because then it doesn't know what was wrong.  Simply trying all variations of a request would be bad; see "combinatorial explosion" :)
09:38:49 <dark> Anyway, I'm off to kill some more monsters.
09:38:57 <dark> shapr: You might be interested to know that I'm currently playing Half-Life for the first time :)
09:38:58 <Marvin--> listboxes do *NOT* work
09:39:37 <shapr> dark: heh, cool!
09:39:55 <shapr> dark: beware, the counterstrike mod is the most addictive thing I've ever played.
09:40:02 <shapr> dark: I've never actually played the single player stuff though.
09:40:35 <dark> jmalicki: I think the conceptual difference is that a precondition says "I don't want the entity unless this is true", and an expectation says "I can't process your response unless this is true".
09:41:02 <dark> shapr: Heh, I play the single-player parts of a game much more often than multiplayer.
09:41:02 <dark> shapr: I guess I like games to have an ending.
09:41:08 <dark> shapr: Also, I like careful thought during a game.
09:42:07 <dark> shapr: One of my favourites in the genre was "Entombed".  You get to play a marine stuck in Egypt gone bad.  Pyramid mazes filled with walking mummies etc :)
09:42:15 <shapr> counterstrike requires careful thought, but usually you have fractions of a second in which to think carefully
09:42:20 <shapr> that's what I'm best at though.
09:42:57 <Marvin--> I feel like playing War3
09:43:06 <shapr> I feel like playing tetrinet
09:43:20 <Marvin--> heh
09:43:22 <Marvin--> sure :)
09:43:35 <Marvin--> that'll do ;)
09:43:42 * shapr bounces happily
09:44:02 <shapr> ok, just a bit though.. I really need to keep doing this XSL stuff
09:44:14 <Marvin--> heh
09:44:15 * shapr thinks "just a little won't hurt"
09:45:24 * Logan has done a lot of XSL lately.
09:48:48 <jadrian> hello
09:49:31 <jadrian> I got a list with elements between 1 and 6 and I want to count the number ofe 1s, 2s, 3s..6s 
09:49:33 <jadrian> easy ;)
09:49:48 <jadrian> what's the most appropriate structure for that?
09:49:53 <jadrian> My answer would be arrays
09:50:05 <jadrian> but I've had bad experiences with them...
09:50:13 <whee> you could use a FiniteMap
09:50:23 <whee> which will update quicker than an array
09:50:26 <jadrian> FiniteMap doesn't seem very elegant...
09:50:36 <jadrian> would it be more efficient?
09:50:38 <whee> an array in haskell requires that you return an entirely new array even when 'changing' one element
09:50:49 <whee> I think, anyway :\
09:51:10 <whee> it'd be really easy to do what you want with a FiniteMap, though. one liner.
09:51:19 <jadrian> yeah I know
09:53:27 <jadrian> just seems kind of ugly
09:53:27 <jadrian> to me anyway
09:53:29 <jadrian> it doesn't even provides a function to change an element given a certain key...
09:53:34 * Igloo needs a good structure for a constant size rolling window
09:54:30 <whee> jadrian: it doesn't?
09:54:43 <Heffalump> binary tree?
09:54:48 <whee> given a key, you can 'change' the element by providing a new one
09:54:50 <Heffalump> array?
09:55:56 <Igloo> How do you do it with a binary tree? Arrays have the problem that when you put the next character on and one falls off the array gets copied, which is slow
09:56:22 <Igloo> Or were you talking to jadrian/whee?
09:57:49 <Heffalump> oh, yes, you don't want to use a mutable array, duh
09:58:06 <esap> maybe an one-liner with filter and length would be elegant enough?
09:58:22 <Igloo> Mutable array and an integer would do, but H98 doesn't have one
09:58:24 <Heffalump> you keep a binary tree plus a path into it that points to the head of the window
09:58:24 <jadrian> whee: and one liner?
09:58:24 <jadrian> whee: it would be if I had a listToM_C
09:58:24 <jadrian> that allowed me to provide an operation for elements with repeated keys
09:58:24 <jadrian> how would you do a one liner with finite map?
09:58:39 <whee> using addListToFM_C
10:00:02 <jadrian> I just noticed it is trivial with arrays and the function accumArray
10:00:02 <jadrian> so I just have to build it once
10:00:02 <jadrian> I didn't want array because changing it seems way to inneficient
10:01:43 <jadrian> this will probably do the trick though
10:11:49 <Heffalump> igloo: what do you actually need to use the window for?
10:12:51 <Igloo> Heff: It's the last 32k of output where the next output can either be character x or n characters starting from m characters back
10:13:48 <Heffalump> sounds like a binary tree wouldn't be horrible overhead, then
10:14:23 <Heffalump> either that or possibly a pair of lists and an amortisation argumnet
10:14:23 * Igloo will have a play some time
10:15:25 <Igloo> What would the pair of lists be?
10:25:41 <Heffalump> one forwards, one backwards
10:25:51 <Heffalump> I haven't worked out the details
10:26:17 <Heffalump> basically you hope that you only have to do an O(n) reversal operation once every n steps
10:29:12 <Marvin--> eeew, there's mold on my nutmeg
10:31:56 <Janni> re
10:32:16 <Igloo> Updating one of them requires sticking an element on the end for each thing you write, though
10:33:13 <Janni> i still (not all the time since a few hours ago, of course) desperating about my little piece of shit problem. i want to generate a list of all possible orders of a given list.
10:33:19 <Igloo> I was planning to see how a single list compares to the current array as laziness will help when n > m
10:35:07 <Janni> can someone help me with this, please?
10:36:18 <Heffalump> janni: I did help
10:36:28 <Heffalump> try to write a function that inserts a single element into a list in all possible ways
10:36:33 <Janni> Heffalump: and i didn't get it though
10:36:57 <Janni> Heffalump: i even fail this (this evening i'm just unable to think)
10:37:07 <Heffalump> igloo: if the lists are (xs,ys) and xs ++ reverse ys represents the window
10:37:22 * Janni is in some stress situation and out of concentration
10:37:31 <Heffalump> then xs := tail xs ; ys := y:ys is the way to move the window
10:37:46 <Heffalump> assuming that xs isn't empty, in which case you have to reverse ys to get xs
10:38:10 <Heffalump> but if m can get big, then it's probably not much good since each lookup operation will be expensive
10:38:22 <Igloo> Ah, I see
10:38:45 <Igloo> m ranges from 1 to 32768 - otherwise the window would be smaller
10:49:57 * Janni got it. but it's an ugly solution (*styling*)
10:51:27 <Janni> can someone think of something better than this?
10:51:28 <Janni> inserts x [] = [[x]]
10:51:28 <Janni> inserts x (y:ys) = (x:y:ys) : map (y:) (inserts x ys)
10:52:01 <Janni> well, it's not really ugly, but i don't really like it neither
10:52:42 <dark> Are you building slowsort?
10:53:31 <Janni> dark: no sorting. as said above, i want to generate a list of all possible orders of a given list. that's the first helper function (i'm really slow today)
10:54:15 <dark> A list of permutations?
10:54:46 <Janni> dark: yep
10:54:57 <dark> Someone sent me a list of ways to do that once.  In portuguese :)
10:55:31 <shapr> Marvin--: I'm beginning to lose now...
10:55:42 <whee> ombinations (x:xs) = [ (y:ys) | y <- x, ys <- combinations xs ] 
10:55:43 <whee> something like that?
10:55:48 <Janni> dark: not really permutations, but (i don't know how to cal it). [0, 2, 1] makes "acb" from "abc"
10:55:53 <whee> err, prepend a c on that :\
10:56:54 <dark> Janni: So your function will take a list of indices, and another list?
10:58:42 <Janni> dark: i want a function which creates from [1, 2, 3] a list of possible combinations [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1] ...]
10:58:58 <dark> Janni: That sounds like a list of permutations.
10:59:05 <Janni> ok
10:59:12 <dark> Janni: I don't see how "acb" and "abc" are related, though.
11:01:58 <Janni> [0, 2, 1] are the positions of the old string.
11:02:21 <dark> Somehow this sounds like you're going the long way around :)
11:02:26 <Janni> 2 is at the second position, so the third (2) character will be put to the second position
11:02:46 <Janni> ah yeah. it's called transposition
11:02:52 <dark> You can permute ['a', 'b', 'c'] as easily as [0, 1, 2].
11:03:20 <Janni> dark: no, you don't understand. [0, 1, 2] is the _rule_ for the transposition of the string "abc"
11:03:35 <Janni> which produces "acb"
11:03:56 <dark> So you have two different problems here?
11:04:08 <dark> Because I don't see how you would need either one to solve the other.
11:04:08 <jmalicki-work> Janni: why arent those permutations?
11:04:22 <Janni> dark: yep, but i wasn't asking for the whole thing, because i already solved the transpositions thing
11:04:48 <Janni> dark: i now need a list for all possible transposition and therefore need all possible rules of specified length
11:05:04 <dark> And you don't count [0, 0, 0] as a valid rule?
11:05:12 <Janni> jmalicki-work: hmm. i don't exactly remember, but permutations are s.th. else
11:05:14 <Janni> dark: no
11:05:18 <jmalicki-work> Janni: no, they aren't
11:05:25 <dark> Hmm, generating all possible rules might be easier than generating permutations.
11:05:33 <jmalicki-work> dark: how is it any different?
11:05:35 <Janni> dark: sort rule == [0 .. length rule - 1 ]
11:05:52 <jmalicki-work> or do permuatations also include like [0] and [1] and [1,2]?
11:06:23 <Janni> jmalicki-work: a permutation specifies the replacement of one character by another
11:06:31 <shapr> why not use //
11:06:39 <Janni> jmalicki: transpositions specify the position of characters
11:07:06 <jmalicki-work> Janni: yes. but your list of possible transpositions is the list of permutations pf [1... length of string]
11:07:07 <dark> Janni: What field are those definitions from?
11:07:07 <shapr> er, ! I mean
11:07:21 <Janni> shapr: for what?
11:07:22 <shapr> if you want to go from [0,1,2] to "abc"
11:07:41 <shapr> you could just partially evaluate foo = "abc" !
11:07:41 <shapr> and then map it across the indices
11:07:46 <Janni> sharp: i already implemented this. i'm asking for s.th. else
11:07:47 <shapr> is that what you're asking for?
11:07:47 <dark> jmalicki: Knowing that the list to be permuted is [0 .. (n-1)] might make it possible to leave out the list, and generate the result algebraically.  Not sure how though.
11:07:59 <shapr> Janni: oh whoops :-)
11:09:12 <jmalicki-work> dark: yes, but thats a problem for the ghc optimizer
11:09:25 <jmalicki-work> dark: if the ghc optimizer cant do that, haskell isnt yet ready for prime-time ;)
11:09:42 <Janni> all i need is a function ``combinations :: [a] -> [[a]]'' which makes e.g. from [1, 2] this: [[1, 2], [2, 1]]
11:09:51 <emu> ooh fun. hw.
11:10:05 <jmalicki-work> dark: that's the power of haskell... that you can express things like that without worrying about the algebraic way, and its theoretically relatively easy for the compiler to optimize
11:10:17 <jmalicki-work> Janni: yes. that is the list of permutations
11:10:23 <jmalicki-work> Janni: you want a permutationsOf function.
11:10:29 <Janni> what i have specified now is a function which takes one element and puts it into all possible positions in a list returning a list of lists
11:10:39 <shapr> I'm convinced the standard library already has this..
11:10:40 <jmalicki-work> Janni: yes. thats called the permutations
11:10:48 <shapr> I think I've seen it even
11:10:52 <jmalicki-work> Janni: if you're convinced its not, im pretty sure you're wrong
11:11:02 <Janni> jmalicki-work: ah, now i understand you. i thought that you thought that i wanted to implement permutations
11:11:14 <Heffalump> That's what I thought you wanted to do.
11:11:27 <jmalicki-work> Janni: permuations might include like [0] and [1] and [1,2] and [1,3] though, i'm not positive
11:12:17 <shapr> http://www.haskell.org/pipermail/haskell-cafe/2002-June/003122.html
11:14:03 <shapr> ok, one more time.. what's the question? :-)
11:14:30 <Janni> shapr: ok, one more time.
11:14:37 <shapr> :)
11:14:54 <jmalicki-work> one more time in the ghetto.
11:15:57 <Janni> shapr: i need a function which creates a list of lists. it contains all possibilities of orders of a given list. given a list of [1, 2, 3] there are many ways to order these elements like [[1, 2, 3], [1, 3, 2], [2, 1, 3], ...]
11:16:11 <jmalicki-work> Janni: is that actually different than permutations?
11:16:17 <shapr> what about that url I pasted?
11:16:26 * shapr tries the code in the url
11:16:44 <Janni> shpar: i don't understand it. i pasted the code but it doesn't give me any result ([])
11:16:45 <shapr> oh
11:17:06 <shapr> I think that's because it's missing a base case
11:17:43 <jmalicki-work> Janni: yeah.. .but that function is what you want to do, i think...
11:17:54 <jmalicki-work> Janni: though you may want to rewrite selections
11:17:58 <Janni> jmalicki-work: you want to solve the problem by using permutations? because for solving this problems it's not relevant if these numbers represent permutiations or whatever
11:18:17 <jmalicki-work> Janni: what you asked for IS permutations
11:18:32 <jmalicki-work> Janni: permutations aren't a tool.the definition of a permutation is the function you specified
11:18:36 <jmalicki-work> Janni: the *SAME* thing
11:19:02 <jmalicki-work> Janni: the exact name of the exact thing you asked for is the list of permutations :)
11:19:13 <shapr> Janni: add "permutations [] = [[]]" to that function, that should fix it
11:19:51 <Janni> jmalicki: no. permutations work look like ['a', 'b', 'c']. every 'a' is replaced by a 'b'. every 'b' by a 'c' and every 'c' by an 'a'
11:19:59 <Janni> -look
11:20:01 <jmalicki-work> Janni: no, you're wrong.
11:20:03 <whee> haha
11:20:11 * shapr shrugs
11:20:16 <jmalicki-work> Janni: a permutation is, BY DEFINITION, "all possibilities of orders of a given list"
11:20:20 <shapr> can you guys agree to disagree?
11:20:22 <jmalicki-work> Janni: that is the DEFINITION of a permutation
11:20:28 <whee> Janni: copy/paste the function in that mailing list entry, and try it.
11:20:49 <shapr> Janni: I've gotten the code to work, would you like me to send it to you?
11:20:55 <shapr> jmalicki-work: let it go ...
11:21:31 <Heffalump> a permutation is *one* possibility of an ordering of a given list
11:21:38 <shapr> we just want running code :-)
11:21:39 <Heffalump> that's why the function that generates the whole lot is called perms
11:23:16 * shapr tries Htk
11:23:29 <Janni> jmalicki: i have TAoCP right before me and it confirms my view of permutations
11:23:33 <Janni> permutations can be written in two ways:
11:23:51 <jmalicki-work> shapr: yeah, i'm done now :)
11:23:54 <shapr> I wonder if Object-IO could be implemented on top of Htk 
11:23:59 <Janni> first (two lines) is: (abcdef) [next line] (cdfbea)
11:24:00 <Marvin--> shapr: don't you dare!
11:24:07 <shapr> Marvin--: oh, it'd be so cute :-)
11:24:11 <jmalicki-work> Janni: whatever
11:24:22 <Marvin--> Janni: cdfbea is a permutation of abcdef, yes
11:24:24 <Janni> this transforms every 'a' to a 'c' and so on
11:24:40 <Marvin--> Janni: but fedcba is also a permutation of abcdef
11:25:21 <Janni> Marvin: no. in this case these two lines define the permutation rule. these two lines are written in one pair of brackets
11:25:41 <Riastradh> Does the Haskell Emacs mode indent things based on the 'layout' style of formatting?
11:25:46 <jmalicki-work> Marvin--: if he wants to be dumb, that's his problem
11:25:50 <shapr> Riastradh: yes it does
11:25:52 <Janni> this rule (abcdef | cdfbea) makes from "abba" "cddc"
11:25:54 <whee> and how is this different from what you want, Janni?
11:25:58 <Marvin--> Janni: "permutation rule" in this case, I bet only means "the result is a permutation of the original"
11:26:01 <whee> no it doesn
11:26:04 <shapr> Riastradh: and only rarely does it get confused and screw up your code..
11:26:07 <shapr> whee: it doesn't?
11:26:25 <Janni> the second method for writing the same rule would be (acf)(bd)
11:26:27 <shapr> Riastradh: do you need assistance with haskell-mode ?
11:26:39 <jmalicki-work> Janni: that is not called a permutation.
11:26:45 <Janni> whee: what i already implemented (i was not asking for that) were transpositions.
11:27:05 <jmalicki-work> Janni: no , its called the permutations
11:27:06 <Marvin--> per·mu·ta·tion  3. Mathematics. A rearrangement of the elements of a set.
11:27:07 <Janni> whee: [1, 2, 0] makes from "abc" "bca"
11:27:11 <whee> Janni: but right now, you want something that goes from [1, 2, 3] to [[1, 2, 3], [1, 3, 2], [2, 1, 3] ...]
11:27:11 <Riastradh> shapr - Reading the 'Gentle introduction to Haskell,' I came under the impression that, for example, this would be the proper way to format something:
11:27:17 <Riastradh> let a  = b + c
11:27:25 <whee> which is a list of all the permutations of the given list.
11:27:28 <Riastradh>     fo = c + d
11:27:36 <Janni> Marvin--: transpositions and permutations as well rearrange characters, but they do it a different way
11:27:36 <Riastradh>    ...
11:27:50 <jmalicki-work> Janni: permutations transpose.
11:27:54 <jmalicki-work> Janni: really, they do.
11:28:04 <jmalicki-work> Janni: whatever you're reading in TAOCP, you're misunderstanding
11:28:05 <Janni> Marvin--: transpositions define the the new positions of characters. permutations (as the name says) replace charcers by others
11:28:16 <Heffalump> any permutation can be expressed as a series of transpositions
11:28:18 <Riastradh> But the Emacs mode doesn't put tabs in the 'correct' places.  Perhaps I just misread the Haskell introduction and was confused by the indentation rules.
11:28:21 <jmalicki-work> Janni: permutations transpose characters
11:28:27 <Heffalump> but not all permutations are *single* transpositions
11:28:34 <jmalicki-work> Heffalump: yes. good way of putting it
11:28:48 <Janni> jmalicki: ok. but these two things are not the same.
11:28:58 <jmalicki-work> Janni: yes. but what you asked for is permutations
11:29:01 <shapr> Riastradh: it's hard to discuss whitespace on irc...
11:29:18 <Janni> jmalicki: no. i just believe Donalt E. Knuth more than you ;)
11:29:24 <Riastradh> shapr, heh, yes, that's why I wrote 'fo' instead of 'foo' -- I accidentally forgot one space in the previous line.
11:29:31 <jmalicki-work> Janni: sure. but you're also misunderstanding what he's saying
11:29:31 <Marvin--> Riastradh: don't argue tabs with emacs, by its definitions it's correct by definition, something I learned when I tried to use the damn thing once
11:29:45 <Janni> jmalicki: of course. just a moment. i'll cite.
11:29:47 <jmalicki-work> Janni: i don't believe he's wrong, i believe you're wrong in your interpretation :)
11:30:06 <Heffalump> Could summarise to me what Janni and jmalicki each believe?
11:30:07 <jmalicki-work> Janni: i don't care. i know i'm right, and its not my problem that you're wrong, i'm just trying to help. i have work to do.
11:30:37 <jmalicki-work> Heffalump: i believe that the "list of all possible orders of a string" is the same as "the list of permutations of the string". janni disbelieves this.
11:30:40 <Janni> jmalicki-work: <- everybody sees :)
11:30:51 <Marvin--> Permutations, 45-46, 51, 97-98, 164-185, 242-243
11:30:55 <Marvin--> Janni: which page do I want?
11:30:57 <Janni> jmalicki: now i know, that you really didnt understand my purpose!
11:31:04 <Heffalump> what does Janni believe?
11:31:36 <Janni> Marvin--: volume one. page 164
11:31:43 <jmalicki-work> Heffalump: i dunno. but he asked for a function that generated said list. i said he could use a function that generated permutations, because it could be cut and pasted from the web or something instead of explaining how to do it. he says he doesnt want permutations
11:31:46 <Janni> jmalicki: what i asked for was not "the list of permutations of the string"
11:31:50 <shapr> Riastradh: truly, emacs idea of indentation doesn't always match what other people would say, but it's the only one I use and know
11:31:50 * whee grabs his copy
11:31:59 <Heffalump> Janni: so what do you want?
11:32:05 <jmalicki-work> Janni: in this case, the string is [0,1,2]
11:32:33 <jmalicki-work> Janni: and the permutations would be [[0,1,2] , [0,2,1], [1,0,2], [1,2,0], [2,0,1], [2,1,0]]
11:32:38 <jmalicki-work> Janni: that sounds to me like what you want
11:32:44 <Janni> ok. perhaps you're right
11:33:06 <jmalicki-work> Janni: the function on that website is a little weird in what it generates, im not sure what the tuple's all about
11:33:10 <Janni> jmalicki: but still, our whole communication was a big misunderstanding
11:33:12 <Marvin--> this looks a lot like permutation groups, but I'm not sure I agree with Knuth. The mathematical definition as I know it of *a permutation* of [a1,a2,...,an] is *any* list consisting of the elements a1,a2,...,an in any order
11:33:19 <jmalicki-work> Janni: yes. because you wouldnt listen :)
11:33:44 <jmalicki-work> Marvin--: he's probably calling it something else
11:33:47 <Marvin--> of course what he talks about is a way to describe *a* permutation of a sequence, but he's talking about permutations in a rather specialized way
11:33:48 <jmalicki-work> subtly
11:33:53 <jmalicki-work> Marvin--: yes
11:33:54 <Janni> jmalicki: you want to permute my transposition rules, where i wanted to tell you that my transposition rules aren't permutation rules
11:34:04 <jmalicki-work> Janni: exactly. and you wouldnt listen :)
11:34:21 <Janni> jmalicki: maybe :)
11:34:38 <jmalicki-work> Janni: now of course, the list of all strings transposed by said permutation of transposition rules IS the list of permutations of the string, also, if thats what you're doing with it :)
11:35:13 <jmalicki-work> Janni: which sounded to me like what you were doing :)
11:35:47 <Marvin--> what Knuth calls permutations looks to me like elements of Sn (the symmetric group of bijections on {1,2,...,n})
11:35:57 <Janni> jmalicki: ok. but i have to solve call it "homework"
11:36:07 <Heffalump> a permutation is a member of Sn
11:36:17 <Heffalump> a permutation of something is the result of applying a permutation to that thing
11:36:34 <Marvin--> Heffalump: that's one way of putting it
11:36:45 <Janni> s.th. is encrypted by a transposition of the type [0, 2, 1, 3] and i should break that cypher
11:37:03 <Janni> therefore i need to create a list of alle possible strings
11:37:08 <Marvin--> and you use haskell lists to represent the bijection (0213)?
11:37:14 <Janni> and select the best one
11:37:26 <jmalicki-work> Janni: if all you need is the list of all possible strings you can even just use the list of permutations of the string ;)
11:37:32 <jmalicki-work> Janni: is what im saying :)
11:37:34 <Janni> Marvin--: no. just a list as above
11:37:42 <jmalicki-work> Janni: you dont even need to generate this list of tranpsotions then do them.
11:38:03 <Heffalump> so you only want the list of single transpositions
11:38:08 <Heffalump> ?
11:38:19 <Janni> jmalicki: ok, but the "homework" is asking for s.th. else
11:38:23 <jmalicki-work> ok
11:38:27 <Janni> Heffalump: no. i'll explain it in one message. wait a bit.
11:41:54 <Janni> There is an encryption method, which encrypts strings by applying a transposition rule on them. this transposition rule look e.g. like [2, 1, 0, 3] which makes of "abcdefg" a new string "cbadgfe". (it represents the positions of the characters in the old string). the key constists therefore of the rule [2, 1, 0, 3]. i get an encrypted string and want to break the cypher (find the plaintext). therefore i generate all possible transponation rules..
11:42:15 <Janni> to create all possible transponations of the cypher-text.
11:42:37 <Heffalump> that's not a transposition rule, it's a permutation
11:42:49 <Janni> the rest isn't interesting for solving the problem. my problem is the generation of all possible transposition rules
11:42:56 <Heffalump> hangon
11:43:11 <Heffalump> how can [2,1,0,3] be applied to "abcdefg"?
11:43:32 <jmalicki-work> Janni: didnt we already get through this?
11:43:54 <Heffalump> oh, never mind
11:44:24 <Janni> Heffalump: according to Donald E. Knuth a permutation defines the _replacement_ of characters by others e.g. every 'a' is replaced by 'c' in the rule (abcdef | cdfbea) or other method to express the same rule (acf)(bd)
11:44:25 <Janni> Heffalump: too late :)
11:44:30 <jmalicki-work> Heffalump: in other words, he wants a list of permutations of the cyphertext, and then needs to choose the most "interesting" permutations. but he's dumb and wont accept help.
11:44:32 <Janni> so, i have big problems to create all possible transposition rules of a given length (4).
11:44:35 <whee> that's not a replacement
11:44:49 <whee> he defines it as "a becomes b", where "becomes" means is put in the same place a
11:45:03 <whee> it's a rearrangement
11:45:21 <Janni> jmalicki: hey. in the homework, we need to implement the transposition by these rules and not by permutations
11:45:26 <jmalicki-work> whee: a transposition rule, even ;)
11:45:38 <Heffalump> there's only 24 permutations of length 4, why not just write them all out?
11:45:48 <jmalicki-work> Janni: well, you can still do the permutations of the transposition rules
11:46:02 <Janni> Heffalump: because it's crazy and I want to learn s.th.
11:46:07 <jmalicki-work> Janni: you just need the list of permutations of [0 .. whatever_haskell_calls_strlen(str) ]
11:46:11 <Janni> jmalicki: ok. that's something i can accept without problems
11:46:27 <Janni> jmalicki: length "muh" :)
11:46:37 <jmalicki-work> Janni: i havent actually done haskell in a few years ;P
11:47:14 <shapr> jmalicki-work: time to get off your but, and do some ;-)
11:47:37 <Janni> jmalicki: but is it really an easy way to use permutations to create all possible transpositions? don't i need to define all possible permutations then?
11:47:37 <jmalicki-work> Janni: although in your position, i would just do permutations of the string and accompany the assignment with a nasty letter telling the professor how dumb he is :)
11:47:59 <jmalicki-work> Janni: yeah... but you can find functins on the web, or in TAOCP most likely, that do that for you
11:48:05 <Marvin--> am I stupid? I don't see how [2,1,0,3] maps "abcdefg" to "cbadgfe"
11:48:18 <Janni> jmalicki: i guess Marvin's right
11:48:24 <jmalicki-work> Marvin--: they're indices
11:48:25 <Janni> sorry!
11:48:29 <jmalicki-work> Marvin--: c is str !! 2
11:48:29 <Marvin--> Janni: what, about being stupid?
11:48:35 * Janni is talking shit!
11:48:35 <jmalicki-work> Marvin--: b is str !! 1
11:49:04 <Marvin--> oh, and then apply the same thing on "efg_"
11:49:13 <jmalicki-work> yeah
11:49:14 <Janni> yep
11:49:24 <jmalicki-work> str !! 2 is the right syntax isnt it?
11:49:43 <Janni> exactly
11:50:01 <Marvin--> (2103) as a member of S4 would map c -> b, b -> a, a -> d, d -> c
11:50:15 <Marvin--> but I gather that's not what you want
11:51:10 <Janni> Marvin: i don't understand...
11:51:14 <jmalicki-work> actually that webpage function does do what you want
11:51:16 <Marvin--> (note that in S4, (3120) == (2103))
11:51:20 <jmalicki-work> it just has the tuples in the middle
11:51:29 <jmalicki-work> Janni: just use the function from that webpage
11:51:31 <Janni> S4?
11:51:35 <Janni> ok
11:51:38 <Heffalump> Marvin--: huh?
11:51:42 <jmalicki-work> Janni: it will work with the slight edit shapr said
11:51:47 <shapr> yah
11:51:51 <Marvin--> Heffalump: (3210) of course
11:52:03 <Marvin--> Heffalump: not (3120)
11:52:07 <Heffalump> ahhh :-)
11:52:08 <Janni> but it always returns an empty list
11:52:12 <Marvin--> Heffalump: typical typo :)
11:52:19 <jmalicki-work> Janni: it does?
11:52:23 <jmalicki-work> shapr: does it?
11:52:39 <shapr> works here
11:52:39 <shapr> Janni: did you add the base case before the rest of the code?
11:52:41 <Marvin--> Janni: S4 is the group of bijections {0,1,2,3} -> {0,1,2,3}
11:52:52 <shapr> as in, after the type signature, but before everything else?
11:52:52 <Janni> lemme check...
11:53:21 <jmalicki-work> jesus
11:53:55 <jmalicki-work> i need to start dedicating my life to hedonism
11:54:01 <shapr> er, why?
11:54:02 <Janni> shapr: *parse error*
11:54:24 <jmalicki-work> explaining permutations erodes the soul
11:54:42 <shapr> http://kungens.kemi.fi/~shae/src/haskell/Perm.hs
11:54:49 <shapr> Janni: try that url
11:54:56 <Janni> shapr: i just don't understand your sentence (because of my English, I guess)
11:55:11 <Janni> shapr: aww.
11:55:12 <Marvin--> shapr: perm looks like a nice function :)
11:55:24 <Janni> shapr: i used the other page
11:55:27 <shapr> Janni: ich keine spreuchen deustch :-)
11:55:29 <shapr> as you can see
11:55:49 <jmalicki-work> shapr: yeah, like wtf is perm?
11:55:49 <shapr> Marvin--: bah I'll find something to tease you about :-P
11:56:06 <shapr> hey, I was just hacking around to try to fix it myself, but it sucked
11:56:08 <jmalicki-work> shapr: you forgot about the base case :)
11:56:32 <Janni> ok works now
11:56:40 <jmalicki-work> Janni: isnt that what you want?
11:56:55 <shapr> ok, reload :-P
11:57:03 <Marvin--> shapr: heh
11:57:11 <Marvin--> I like the main function
11:57:13 * shapr laughs
11:57:22 <shapr> yes, it's truly classic.
11:57:33 <jmalicki-work> shapr: you should have main coredump
11:57:40 * shapr grins
11:57:44 <jmalicki-work> thats what i miss when i do haskell
11:57:55 <jmalicki-work> the ability to write code like:  *(char *)8 = 22;
11:57:59 <shapr> yah, all those years of C experience going to waste..
11:58:02 <shapr> so few coredumps to work with
11:59:24 * Marvin-- wonders if this can be rewritten in a pointless way
12:00:10 * esap thinks it's way too easy to write infinite loops in Haskell.
12:00:11 <jmalicki-work> Marvin--: what if you generated list of the permutations of all possible lengths of strings
12:00:20 <jmalicki-work> Marvin--: and then just indexed it by strlen
12:00:25 <Marvin--> jmalicki-work: heh
12:02:12 <dark> slowsort = head . slowsort . permutations
12:02:29 <jmalicki-work> hmmm. there HAS to be an 802.11 laundromat SOMEWHERE in this city...
12:02:32 <Janni> shapr: just btw. i don't really see, why you are splitting the [ | <- ] thing into multiple lines. i don't find it nicer than putting everything in one line, but you might, so... *shrug*
12:02:50 <shapr> Janni: I didn't, I just copied it from the mailing list post en masse
12:03:18 <esap> dark: I've actually seen that kind of stuff in a respected C++ book as an example :-)
12:03:24 * Marvin-- did it without LCs
12:04:01 <Marvin--> ins a [] = [[a]]
12:04:01 <Marvin--> ins a (x:xs) = (a:x:xs) : map (x:) (ins a xs)
12:04:01 <Marvin--> perms [] = [[]]
12:04:01 <Marvin--> perms (x:xs) = concatMap (ins x) (perms xs)
12:05:04 <shapr> I want to do something useful this weekend...
12:05:07 <jmalicki-work> i guess i could just get shitfaced
12:05:12 <jmalicki-work> but that just seems pathetic
12:05:18 <shapr> I wonder if two days is enough time to hack together an smtp sending module in Haskell
12:05:19 <jmalicki-work> to drink alone as i'm doing laundry
12:05:29 <jmalicki-work> but maybe i could pick up a drunk slut with clean, fresh smelling clothex
12:05:35 * shapr blinks
12:05:41 <dark> shapr: probably.  The s is for "simple" :)
12:05:42 <jmalicki-work> oh sorry
12:05:44 <jmalicki-work> wrong channel
12:05:51 <shapr> jmalicki-work: enrich your mind, write haskell
12:06:33 <Janni> shapr: you could work on CHaOS
12:06:38 <shapr> what's that?
12:06:47 <Janni> (Cool Haskell Operating System ;)
12:06:55 <shapr> since my last name is Erisson, that's a project I'd like to work on
12:07:15 <Janni> shapr: who wouldn't? but it's hard to start...
12:07:19 <shapr> truly
12:08:06 <shapr> I suspect I should start with something simpler
12:08:09 <Janni> shapr: that's a thing i'd to participate, but not enough knowledge yet.
12:08:09 <shapr> same here
12:08:25 <Janni> shapr: but a good name, isn't it (if the "Cool" could be replaces by s.th. better, maybe :)
12:08:27 <shapr> I guess you could write an STG that runs on the bare metal
12:08:42 <shapr> I think it's a great name just as it is.
12:08:45 <Janni> whatis STG
12:08:59 * esap has a project that could use a good name.
12:09:04 <Heffalump> Spineless Tagless G machine
12:09:14 <shapr> maybe "ChAoS - Haskell Operating System" 
12:09:24 * shapr gets the case confused
12:09:34 * Janni is good in finding good name! (is he?) anyway: what for, esap?
12:09:40 <Janni> s/name/names
12:09:40 <shapr> Heffalump: what do you think? SMP capable STG?
12:09:56 <esap> I'm designing a new language based on category theory.
12:09:57 <Janni> shapr: yeah. of course! it must be recursive! cool...
12:10:01 <Heffalump> in hardware?
12:10:07 <dark> Canny Haskell Operating System
12:10:07 <shapr> heh
12:10:07 <dark> (opposite of uncanny)
12:10:09 <Heffalump> no, it's too high-level
12:10:15 <dark> Might be too close to "cunny" though.
12:10:18 <Heffalump> Curried Haskell Operating System, obviously
12:10:20 <Janni> dark: no chaos haskell operating system is _perfect_
12:10:25 <shapr> Heffalump: nah, I was thinking SMP STG that runs on x86
12:10:29 * shapr laughs
12:10:32 <shapr> this is great :-)
12:10:34 <Marvin--> dark: Cunning Haskell Operating System you mean?
12:10:37 <Heffalump> shapr: doesn't concurrent GHC etc exist?
12:10:39 <shapr> I must put this on the wiki
12:10:45 * dark is not your common cunning linguist.
12:10:51 <Janni> Heffalump: no. what can be better than a recursive definition of the name?
12:10:51 <shapr> Heffalump: yes, but it uses anonymous OS threads
12:11:10 <shapr> so relies on the OS for scheduling, etc
12:11:16 <Janni> i guess everybody knows "GNU's not UNIX"
12:11:22 <shapr> yah :-)
12:11:38 <esap> janni: a recursive acronym is not a good idea any more, it's overused.
12:11:40 <Marvin--> just don't do what the hurd people do, my theory is that they spent so much time on smoking together the name so that's why they haven't gotten further with the OS
12:11:48 * shapr snickers
12:11:58 <dark> Janni: Yeah but that was a big mistake.
12:11:59 <dark> http://www.gnu.org/fun/jokes/gnu-overflow.html
12:12:03 <Janni> esap: maybe, but still...
12:12:15 <jmalicki-work> my theory is that they spend too much time talking about how great free software is and how linux should be called GNU/linux
12:12:25 <Janni> dark: lol :)
12:12:33 <Marvin--> they sat smoking for years trying to figure out a name, and when they finally did, they sat smoking a few more years, slapping each other on the backs and saying "Damn, we're GNU/cool!"
12:12:41 <jmalicki-work> hahaha
12:13:02 <rublik> =)
12:13:06 * Janni can't stop laughing reading that text
12:13:14 <shapr> Heffalump: now that you mention it, that's an excellent research path...
12:13:51 <Marvin--> shouldn't that be GNU/Humor Collection?
12:14:37 <dark> I suspect that rant is in esperanto... can anyone translate?
12:14:40 <jmalicki-work> i still liked Lignux better
12:14:51 <jmalicki-work> dark: does babelfish not support esperanto? :)
12:15:02 <dark> jmalicki: Hadn't thought of that.
12:15:20 <dark> Anyway, I think they're right -- a project needs to start with a cool name.  All else follows from that.
12:15:41 <jmalicki-work> dark: not in the case of GNU :)
12:15:44 <dark> Also, every project needs to have a FAQ entry explaining how to pronounce the name.
12:15:51 <jmalicki-work> hehe yes
12:15:57 <jmalicki-work> preferably wih a .au file
12:16:22 * esap has a problem that my project has been going on for years and I haven't got a good name :­(
12:16:23 <dark> I think this is the problem with the hurd, the name is too complicated and it scares away developers.  Much easier to work on gnome.
12:16:27 <Janni> jmalicki: and a video how to mime the pronounciation of the name
12:16:48 <dark> Note that it should technically be "the gnome", but no-one cares about that.  Contrast with The HURD.
12:17:10 <dark> I think the most brilliant name of all time is perl.
12:17:33 <lament> C is better.
12:17:37 <Janni> dark: java isn't bad either
12:17:38 <dark> Janni: Bah, it's the name of an island.
12:17:40 <lament> And of course Brainfuck.
12:18:01 <dark> One important quality of project names is that googling for them shoudl find the project :)
12:18:03 <shapr> a real smp stg would have to work like IA64 EPIC I think...
12:18:03 <Janni> dark: that's a good point
12:18:05 <dark> java succeeds at that through sheer force of marketing.
12:18:14 <dark> But I'm afraid "CHaOS" is doomed.
12:18:21 <jmalicki-work> yeah
12:18:23 <jmalicki-work> its like cool
12:18:26 <Janni> dark: yep. but i still find the name good.
12:18:28 <jmalicki-work> but unprofessional
12:18:29 <shapr> it would have to solve the dependency problems and then it could parcel out the code to any CPUs available...
12:19:16 <shapr> it would seem to me that haskell would be the perfect language for such a system
12:19:24 * shapr thinks more...
12:19:33 <dark> And if you have a student group working on CHaOS, and they have a little clubhouse for storing the servers that run it, would that be a CHaOS computer club?
12:19:41 <shapr> hah
12:20:00 <Janni> how much time i spent on thinking about such things (luckily in the in the train or bus...)
12:20:04 <jmalicki-work> shapr: i would think C would be a better language? :)
12:20:08 <shapr> I think manuel chakravarty's Nepal project is more likely to work in the immediate future.
12:20:36 <shapr> it allows transparent data paralellism only though
12:20:39 <shapr> even so, that's a good thing.
12:20:43 <jmalicki-work> yeah
12:21:11 <shapr> now I just want him to finish the MPI implementation so I can transparently use all of my computers with one Haskell program... :-)
12:21:24 * shapr goes off to find food
12:21:46 <dark> Even back in 1994 I remember an article about how you could hook up parallel processors to interpret a functional language without having to do any analysis, just by keeping track of live nodes.
12:22:05 <Janni> sharp: this time you won't find much. you should store the food you find during summer and autum/fall :)
12:22:35 <dark> Janni: I've found that in Finland you can find surprisingly much food preserved under the ice.
12:22:43 <jmalicki-work> dark: it would be cool if there was a processor by which you could like "push graph nodes"
12:22:45 <dark> Janni: Frozen bunnies, that sort of thing.
12:22:50 <jmalicki-work> dark: and the processor could evaluate them as it saw fit
12:23:00 <dark> jmalicki: That sounds about like the way it worked :)
12:23:18 <jmalicki-work> dark: it would be sweet if that was in hardware though :)
12:23:29 <dark> jmalicki: This was in the transputer age :)
12:23:40 <dark> I wonder what happened to transputers.
12:23:40 <Janni> "darling, i want to cook. can you go out and dig out some rabbits?"
12:23:42 <jmalicki-work> wtf is a transputer?
12:24:19 <dark> jmalicki: Simple processors designed to be nodes in a computing network, which could be hooked up any number of ways.  Great for studying parallelism designs.
12:24:56 <dark> jmalicki: I never understood if "transputer" referred to individual nodes or only to the network.
12:25:09 <jmalicki-work> so sort of like beowulf clusters
12:25:35 <jmalicki-work> well not quite
12:25:35 <dark> jmalicki: I think beowulf clusters are quite heavyweight in comparison.  Each node in a cluster is a whole PC, right?
12:25:43 <jmalicki-work> dark: sure
12:25:53 <jmalicki-work> dark: but thats an implementation detail ;P
12:26:27 <jmalicki-work> i need to learn to program in postscript
12:26:34 <esap> I guess transputers were killed by there being no language that could take advantage of the parallelism [and the relative cost compared to commodity PC's]
12:26:39 <dark> Each transputer node had a few kb of memory, and I think five "threads" (in hardware).  One for computation, and four for I/O.  They could exchange messages atomically (from the computation's point of view).
12:26:40 <jmalicki-work> and start using printers to do all my work
12:27:00 <dark> One of the nodes would be connected to the console, and you'd seed the network by pushing a program onto that node, and tell it to propagate.
12:27:09 <jmalicki-work> dark: that might come back some... hyperthreading is pretty cool
12:27:19 <jmalicki-work> dark: i presume hyperthreading will become more like that in the future
12:27:42 <dark> jmalicki: Threads that communicate by exchanging events is becoming a popular programming model again.
12:27:43 <jmalicki-work> hyperthreading is just starting from the practical side and working its wayt o the theoretical
12:28:21 <esap> I'd prefer starting from theoretical (C++ was started from the practical side :-)
12:28:36 <jmalicki-work> esap: i disagree
12:28:45 <dark> esap: It ended up as a surprisingly impractical language, then :)
12:28:51 <jmalicki-work> esap: well ok. started from the pracical but finished with the theoretical
12:29:07 <jmalicki-work> esap: it didnt suck until people started masturbating on about typesafety and shit
12:29:21 <esap> right, and that is the way things go. I'd prefer the foundation to be solid when it gets to the theoretical stuff...
12:29:36 <jmalicki-work> esap: i'd prefer you just dont worry about it ;)
12:29:42 * whee loves erlang processes
12:29:47 <jmalicki-work> esap: and say fuck you whenever someone talks about a theoretical problem
12:29:59 <jmalicki-work> esap: because their answer will create just as many problems as it solves
12:30:00 <dark> jmalicki: Like perl?
12:30:01 <jmalicki-work> so why worry?
12:30:22 <jmalicki-work> dark: my only issue with perl is lack of , like 'strictness'
12:30:31 <dark> "Umm, wouldn't it be nice if the language had a well-defined grammar?"  "Fuck you"
12:30:31 <jmalicki-work> dark: i do enjoy real datatypes and having to declare variables
12:30:39 <jmalicki-work> dark: :)
12:30:55 <jmalicki-work> dark: perl is just overboard
12:31:36 <lament> ew, having to declare variables
12:32:15 <Janni> did you ever hear s.th. of Clean? i don't know much about it, but it seems to be quite the same as Haskell but with a functional IO system
12:32:29 <jmalicki-work> Janni: yeah, i've heard of it
12:33:12 <Janni> i have to read a bit about it. maybe it's better than Haskell...
12:34:55 <Janni> i don't know, if Monads a ingenious or stupid (don't know enough about them)
12:35:19 <dark> Janni: Why can't they be both?
12:35:35 <esap> janni: monads are just an interface to 'sequencing'.
12:35:47 <Janni> dark: did i write "ingenious xor stupid"? ;)
12:37:35 <esap> The most ingenious thing about monads is just how small interface it is [small interfaces are good!]
12:38:58 <lament> Janni: the problem with Clean is that it's not free.
12:39:10 <lament> Janni: otherwise it's supposed to be really good
12:39:29 <Janni> lament: then it's dead for me. won't have a look at it anymore...
12:40:20 <Janni> unless i want to learn s.th. about a good feature it provides
12:41:06 <dark> I guess you could always write a free compiler?  If the language is worth it.
12:42:50 <esap> Is there actually anything in Clean that Haskell doesn't already provide nicely?
12:43:09 * esap should know but I don't.
12:43:12 <Janni> esap: functional IO
12:43:36 <lament> haskell doesn't provide functional IO?
12:43:53 <lament> sounds like heresy :)
12:47:23 <Janni> what would you say? did the ghc developers do good work or could the compiler produce much more code (don't have a opinion on that, but i'm interested) (again, no "xor" ;)
12:48:06 <Marvin--> http://193.11.232.159:8080/lego.png <- mini-me! :)
12:48:20 <esap> ghc is probably the least buggy compiler I've ever seen.
12:49:24 <jmalicki-work> i dunno
12:49:33 <jmalicki-work> i have seen lots of problems with it core dumping
12:49:37 <jmalicki-work> if you dont make clean
12:49:38 <Janni> esap: ok. but i'm mainly thinking about code efficiency, becaus i want to know how efficient haskell generated code could be
12:49:45 <jmalicki-work> i think other people have too
12:49:54 <Janni> of course it could be perfectly efficient, but... maybe you know what i mean...
12:49:58 <jmalicki-work> i think it probably just doesnt do enough name mangling
12:50:40 <esap> janni: it's hard to compare compiler efficiency of different languages. But ghc does seem to do pretty good job in optimizing.
12:50:49 <jmalicki-work> esap: it shoudl do a lot more though
12:51:06 <jmalicki-work> esap: it is easy to compare. ghc sucks unless you can write code in it thats faster than C
12:51:14 <jmalicki-work> esap: otherwise its power of abstraction is a waste :)
12:51:41 <Janni> jmalicki: well, that exaggerated.
12:51:46 <jmalicki-work> Janni: i dont think so
12:51:58 <jmalicki-work> Janni: i just need to get independently wealthy first so i can spend time fixing it
12:52:03 <esap> jmalicki: heh, well the counterargument to that is that it's not the efficiency of the code that matters in most cases, but the efficiency of the people who write the code.
12:52:05 <jmalicki-work> but i have bills to pay, unfortunately
12:52:13 <Janni> jmalicki: abstaction mainly saves time, i'd say
12:52:24 <jmalicki-work> esap: yes. but the beauty of haskell is that it has a real possibility of doing *both*
12:52:31 <jmalicki-work> esap: so anything less is totally unacceptable
12:53:28 <esap> jmalicki: heh. I think it's quite hard for Haskell compilers to be both actually.
12:54:13 <jmalicki-work> esap: actually its not
12:54:15 <esap> jmalicki: but it's not because of the extra level of abstraction. It's more because it doesn't *also* provide a low level of abstraction.
12:54:37 <jmalicki-work> esap: it doesnt need to. the high level code in haskell is easily optimizable, because of its highly mathematical nature
12:54:39 <jadrian> What is wrong with this line????
12:54:44 <jadrian> t = l with ?u=1
12:54:54 <jmalicki-work> esap: it makes it hella easy to mathematically analyze to find optimizations
12:55:02 <jadrian> isn't this the correct syntax for implicit parameters??
12:55:15 <jmalicki-work> esap: hence specialization etc are *really* easy in haskell compared to almost any other language
12:55:20 <jmalicki-work> ML and Clean excepted
12:55:31 <esap> jmalicki: that's true. But I'm not talking about that.
12:55:35 <jmalicki-work> esap: therefore there is no need whatsoever for a lower level of abstraction
12:55:45 <jmalicki-work> esap: yes. but you're just not seeing the big picture
12:55:48 <Marvin--> jadrian: I think 'with' is deprecated
12:55:57 <jmalicki-work> esap: you dont NEED to be able to write low level code if your high level code is fast
12:56:14 <jadrian> Marvin--: which one is used now? let?
12:56:17 <Marvin--> jadrian: let ?u = 1 in t = l
12:56:33 <jmalicki-work> esap: haskell's high level code needs to be faster than you can even possibly create low level code
12:56:33 <Marvin--> jadrian: there's also a flag for ghc that lets you use with but I don't remember what it is
12:56:37 <jadrian> Marvin--: let me try it
12:56:53 <Janni> jadrian, Marvin: use "where" but "let". please!
12:56:55 <jmalicki-work> esap: or else its just a toy language, not a truly revolutioanry one
12:57:04 <Janni> let is ugly.
12:57:13 <esap> jmalicki: The problem is that if there is no low level of abstraction, people will have no choice but to write code that does more than they intend. There is no way to "fill-in" the blanks.
12:57:13 <jmalicki-work> esap: the language itself is truly revolutionary, but it doesnt matter if the implementations constrict it
12:57:27 <Janni> jadrian: s/with/where
12:57:31 <jmalicki-work> esap: sure there is.  the compiler optimizes out the stuff that is more than they intend
12:57:42 <jmalicki-work> esap: with most languages, this is hard if not impossible. with haskell, its easy
12:57:47 <Marvin--> Janni: the advantage of let is that let is an expression
12:57:52 <jadrian> ok it worked
12:57:52 <jmalicki-work> eas: and THAT is the power and beauty of haskell
12:58:17 <jmalicki-work> esap: haskell is a language that is easy to write very optimizing compilers for
12:58:24 <jmalicki-work> unfortunately, ghc isnt nearly that good yet
12:58:27 <Janni> Marvin: what do you mean with "an expression"?
12:58:27 <esap> jmalicki: I agree that optimization in Haskell is way easier than in anything else.
12:58:28 <jmalicki-work> not that ghc is total trash
12:58:33 <jmalicki-work> but its not up to what it could be
12:58:47 <Marvin--> Janni: let p = e in e' is an expression,  e where p = e'  is not an expression
12:58:49 <jadrian> it can't be used with where, just let, right?
12:59:06 <Janni> Marvin: ah, but still.
12:59:11 <jmalicki-work> esap: the problem right now is that you need to *choose* between RAD and performance. there's no excuse for that
12:59:27 <jmalicki-work> esap: and that you need to make that choice is REALLY holding back computing right now
12:59:32 <jadrian> Hmmm I don't like this syntax... I prefered specifying the implicit parameters in the end of the expression
12:59:49 <jmalicki-work> esap: but with languages like haskell, there is no defensible reason for that choice to exist
13:00:06 <esap> jmalicki: recursion is one reason.
13:00:11 <Janni> jadrian: just replace with by where
13:00:17 <jadrian> Janni: doesn't work
13:00:20 <jmalicki-work> esap: no. you're not getting it.
13:00:28 <jadrian> Janni: not for implicit parameters it seems
13:00:35 <jmalicki-work> esap: the high level code you write in haskell isn't fundamentally slower than the most low level code
13:00:48 <esap> jmalicki: No I'm not saying that.
13:00:50 <jmalicki-work> esap: the only thing separating it is the lack of a good optimizing compiler
13:00:57 <jmalicki-work> what are you saying?
13:01:23 <esap> jmalicki: I'm saying that we need *both* levels of abstraction.
13:01:32 <jmalicki-work> esap: why do you EVER need the low level?
13:01:51 <esap> jmalicki: To be able to express yourself *exactly*.
13:02:09 <jmalicki-work> esap: umm, and you cant do that at the high level?
13:02:14 <jmalicki-work> esap: like, give me an example
13:02:54 <jmalicki-work> esap: if you want to express an algorithm, rather than a result, thats where you're wrong already
13:03:04 <jmalicki-work> i guess we have to agree to disagree if you feel that way :)
13:03:08 <esap> jmalicki: no, I'm talking about types.
13:03:17 <jmalicki-work> esap: ?
13:04:14 <esap> jmalicki: The problem is, in order for the compiler to be able to "guess" your intentions, you must have first told the compiler. How would you express prime numbers larger than 1000 for example in Haskell?
13:04:41 <esap> jmalicki: I know, you can write an algorithm for computing them. But that is not good enough.
13:04:47 <jmalicki-work> esap: like this
13:04:55 <jmalicki-work> esap: first you have your list of all primes (infinite)
13:05:03 <Marvin--> sounds like you want a declarative language
13:05:13 <jmalicki-work> then you write a function "throw out all numbers until i see one >= 1000"
13:05:21 <jmalicki-work> and throwoutlessthan1000 primes
13:05:24 <jmalicki-work> is your list
13:05:26 <jmalicki-work> Marvin--: yes
13:05:32 <jmalicki-work> Marvin--: declarative languages are the future
13:05:42 <jmalicki-work> Marvin--: they're theoretically impossible, but haskell is the next best thing :)
13:05:54 * Marvin-- likes Prolog :)
13:05:59 <Janni> jmalicki: the sieve/sifter/colander of <some greek>
13:06:01 <jmalicki-work> well theoretically so computationally intensive that they're worthless, at least
13:06:05 <esap> jmalicki: What I would like is the compiler to consider the fact that I wanted to use only primes larger than 1000, then use their properties to automatically deduce their properties, and optimize based on that.
13:06:10 * Janni can't be more specific :)
13:06:17 <Marvin--> Janni: Erathostenes
13:06:20 <jmalicki-work> esap: exactly
13:06:30 <jmalicki-work> esap: i would call that extremely high level, personally?
13:06:44 <Janni> Marvin: yes. what's it? sieve, sifter or colander?
13:06:46 <jmalicki-work> esap: is that where we're differing? you callt hat low level?
13:06:58 <Marvin--> Janni: sieve
13:07:05 <jmalicki-work> esap: i mean sure, you need low level until the compiler can deduce that
13:07:08 <Marvin--> Janni: there's a whole branch of mathematics dealing with sieve methods
13:07:14 <esap> jmalicki: Yes, the reason I call it low-level is that you can specify very small details in the specification in such language.
13:07:21 <jmalicki-work> esap: i'm just saying computing will be held back until we have compilers that can deduce it
13:07:33 <jmalicki-work> esap: but you don't specify them. the compiler deduces them.
13:07:53 <Janni> jmalicki: or incredibly fast computers because of some revolutionary technology
13:08:04 <jmalicki-work> Janni: or both
13:08:20 <jmalicki-work> Janni: fast computers is nice, fast computers + fast programs is even better
13:08:21 <esap> jmalicki: well ok, I think type inference is infeasible for the stuff I'd like it to be able to handle.
13:08:27 <Janni> jmlicki: again, no "xor" :)
13:08:57 <jmalicki-work> esap: making it feasible is what i'd like to be my life's work... i am just not rich enough to live off of interest yet :)
13:09:28 <esap> jmalicki: at least complete type inference. I would say you can have Haskell-like type inference where you have to specify "top-level" type annotations for everything.
13:09:29 <jmalicki-work> Janni: sure. i just think even a plain "or", rather than an "and" , is throwing out a lot of stuff
13:09:49 <jmalicki-work> esap: but why couldn't haskell, say, recognize properties of primes?
13:10:11 <jmalicki-work> esap: i mean you need to start with the common case
13:10:19 <esap> jmalicki: Well one problem is recursion. It's very hard to deduce properties of a recursive function.
13:10:26 <jmalicki-work> esap: like, say, properties of strings would speed up a lot of noticable things
13:10:43 <jmalicki-work> esap: not a tail-recursive funciton
13:10:53 <jmalicki-work> and tail-recursion is the common case
13:11:04 <jmalicki-work> ghc misses out on a lot of the common cases, even
13:11:21 <esap> jmalicki: well ok, I agree, but it doesn't help if you'd like to deduce the maximum running time of your program.
13:11:32 <Janni> jmalicki: AFAIK a right-recursive is much better than a left-recursive (don't know if it's a common expression in english)
13:11:49 <Janni> s/recursive/linear
13:11:59 <jmalicki-work> Janni: huh?
13:12:00 <Janni> is it still right then?
13:12:05 <jmalicki-work> Janni: you mean like tail recursive?
13:12:22 <Janni> jmalicki: hmm. some translation problem.
13:12:29 <jmalicki-work> Janni: as in function (x:xs) = (blah x : function xs)
13:12:33 <jmalicki-work> Janni: thats tail recursion
13:12:42 <Janni> jmalicki: clear. forget about it.
13:12:51 <esap> jmalicki: What I mean is, you need more refined mechanism for expressing things, so that if you do not need recursion, then the compiler doesn't force you to it. And using that "hard case" should be an exception, not the default.
13:12:51 <jmalicki-work> actually
13:12:54 <jmalicki-work> maybe its not :)
13:12:59 <Riastradh> No, that's not tail recursive.  That's recursive, but not properly tail recursive.
13:13:16 <jmalicki-work> Riastradh: yeah.. i realized that :)
13:13:20 <jmalicki-work> after the fact :)
13:13:34 <Riastradh> function (x:xs) = function (xs : blah x)   would be tail recursive.
13:14:04 <jmalicki-work> Riastradh: hmmm... wouldnt it be possible for a compiler to rewrite that as tail recursive somehow?
13:14:06 <esap> jmalicki: I mean, I'd rather have a primitive that only allows you to use tail-recursion [but provides very good compiler support] and a special very hard-to-use general recursion primitive.
13:14:27 <Riastradh> jmalicki, a compiler like the Stalin Scheme compiler, yes, but it would require a rather smart compiler to do that.
13:14:35 <jmalicki-work> Riastradh: actually not that smart
13:14:50 <jmalicki-work> Riastradh: so ghc can't do it? exactly what i mean. ghc blows chunks
13:15:04 <jmalicki-work> Riastradh: thats a really common haskell idiom. no excuse for ghc to not make it tail recursive
13:15:09 <jmalicki-work> fuck. i need to get rich quick.
13:15:15 <Riastradh> Er, I don't know about GHC; I just started learning Haskell last night.
13:15:15 <emu> huh?
13:15:52 <Marvin--> jmalicki-work: the problem with tail recursion is that it doesn't work on infinite lists :)
13:15:53 <emu> there's no general way for the compiler to rewrite a recursive function into tail-recursive form
13:16:16 <Riastradh> emu - Exactly: that's why I said it would have to be very smart.
13:16:18 <jmalicki-work> Marvin--: recursion doesnt necessarily work on infinite lists either ;)
13:16:28 <jmalicki-work> emu: there is for many cases.
13:16:29 <emu> smarter than the universe
13:16:31 <Marvin--> jmalicki-work: didn't you want to use infinite lists of primes? :)
13:16:35 <jmalicki-work> emu: again, you're stuck begin an academic
13:16:43 <emu> not really
13:16:50 <jmalicki-work> Marvin--: sure.. the trick is for the compiler to realize its not really infinite
13:16:52 <emu> I don't htink any interesting cases can be done
13:17:02 <jmalicki-work> emu: whatever :)
13:17:08 <emu> I just use iteration constructs =)
13:17:17 <Riastradh> Simple recursive but not tail recursive list processing functions can easily be rewritten with CPS.
13:17:31 <jmalicki-work> Riastradh: exactly what im thinking
13:17:57 <Janni> sh> resolve CPS
13:18:17 <emu> i can do the easy stuff myself :p
13:18:17 <Riastradh> 'sh>'?
13:18:28 <jmalicki-work> emu: the thing is, the compiler should always do it for you
13:18:29 <Janni> Riastradh: i just defaced my question as a shell command
13:18:33 <jmalicki-work> emu: you shouldnt have to think about it
13:18:54 <Janni> english: can please anyone tell me, what CPS stands for?
13:18:55 <jmalicki-work> emu: if the argument is "i can do it yourself" , that pretty rapidly evolves into "i'll just write it in C"
13:18:59 <esap> CPS = continuation passing style.
13:18:59 <jmalicki-work> emu: and that's the problem :)
13:19:05 <Riastradh> emu - I really don't think it would be that difficult to have a compiler that converts non tail-recursive functions to CPS functions.
13:19:35 <jmalicki-work> i mean you cant do it for ALL recursive funcitons necessarily
13:19:40 * Riastradh would give an example of a CPS function in Haskell but he doesn't know Haskell well enough to do so.
13:19:45 <jmalicki-work> but you could do it for quite a few common haskell idioms
13:19:46 <esap> btw, continuations are another thing I think functional languages do not yet have fully grasped.
13:20:11 <Riastradh> 'fully grasped?'
13:20:28 <emu> I generally make do w/o using tail-recursion these days, though I could, but generally it's not a problem
13:20:35 * Janni just want's to know which words the letters 'C', 'P' and 'S' represent
13:20:37 <jmalicki-work> perhaps.. my interest in haskell has always been the possibility of heavy optimization that a purely functional, mathematically-well-thought-out language provides
13:20:51 <jmalicki-work> then you get abstraction for no performance penalty with a good compiler
13:20:58 <esap> I mean, there are some dark corners with continuations, like its relationship with unions.
13:21:05 <jmalicki-work> Janni: esap said.
13:21:11 <Riastradh> Janni - C: Continuation, P: Passing, S: Style
13:21:11 <Janni> Riastradh: thex
13:21:12 <Riastradh> Unions?
13:21:12 <Janni> sorry
13:21:36 <emu> there are many more complicated things I don't want to do myself than simple tail-recursive transformation
13:21:39 <jmalicki-work> like the AFL/CIO?
13:22:01 <emu> yes, the programmer's union is rising up against continuations
13:22:08 <emu> they demand to be first-class
13:22:21 * Janni is much too confused today and has to write a math test tomorrow and still has to learn and has to go to bed and fears tomorrow
13:22:29 <jmalicki-work> www.techsunite.org
13:22:36 <esap> riastradh: I think there is a connection between continuations and coproducts.
13:22:44 <jmalicki-work> they talk baout their relation with continuations
13:22:44 <Riastradh> ...coproducts?
13:23:00 <esap> riastradh: algebraic data types
13:23:23 <esap> there are many names for the same thing.
13:23:45 <emu> multi-shot continuations can open a whole can of worms
13:24:29 <Riastradh> What worms are in that can?
13:24:34 <esap> I think I know a typing rule for continuations that works quite nicely and prevents those cans of worms.
13:25:44 * Riastradh must depart for a few minutes.
13:25:53 <esap> riastradh: you can create very complex "goto-like" behaviour with it.
13:26:09 <Marvin--> ugh, yes
13:26:11 <emu> well
13:26:26 <Marvin--> "continuations considered harmful" :)
13:26:38 <emu> you can exit a form multiple times, so when do you trigger behavior such as an unwind-protect form?
13:26:57 <emu> I'm not sure if a typing rule can help here
13:27:30 <emu> I noticed that Ruby has this problem with their  try...except form
13:27:35 <emu> er
13:27:44 <emu> try...something or other like finally
13:28:02 <jmalicki-work> seee... this is what happens when people get all up with their cool theoretical forms... they have all these problems :)
13:28:06 <esap> emu: ok, consider the following typing rule: C \\ x:A |- y : B  --> C |- control x.y : A \/ B. Does this have the problem?
13:28:15 <jmalicki-work> omfg
13:28:17 <jmalicki-work> wtf is that?
13:28:30 <jmalicki-work> is there a language for that rule?
13:28:39 * emu hates ASCII math notation
13:28:56 * emu notes that Haskell kinda falls under that category too :/
13:29:34 <Janni> cu guys. nice talking.
13:29:39 <esap> The "\\" is my notation for a "subtraction-type", which would be a new type constructor needed just for this.
13:30:48 <emu> my reasoning is that this is not a question which can be resolved statically
13:31:05 <esap> ok, explain more.
13:31:25 <emu> unfortunately, I can't figure out the notation of your rule
13:31:58 <emu> how is the computer to know when the final exit of a protected form occurs, basically?
13:32:58 <emu> actually, I think it might also require mutation of bindings somewhere.  But I don't remember atm.
13:33:02 <esap> it does not need to do that. That rule says that there is exactly one "target" for the exit, and prevents that you cannot pass the continuation outside of that location.
13:33:05 <emu> perhaps Haskell gets out of this one scot-free =)
13:33:23 <emu> of course, I wonder if unwind-protect relaly means anything in a functional language
13:34:24 <esap> the typing rule notation I used should correspond closely to the natural deduction style of typing rules.
13:36:28 <esap> well I guess unwind-protect might be too dynamic thing to be relevant in a statically typed language that tries to type check it. But I'm not sure.
13:36:58 <emu> its primary usage is side-effect, that is why
13:37:10 <emu> I wonder how Haskell would achieve a similar effect
13:39:52 <esap> well you can write a continuation monad that can provide continuations.
13:41:56 <esap> To me, it's actually somewhat unclear what is the normal use of unwind-protect.
13:42:13 <emu> cleaning up resources
13:42:47 <esap> oh, it's the same as RAII from C++? I would not think that's a problem.
13:43:02 <emu> RAII?
13:43:12 <esap> resource-acquisition-is-initialization
13:44:07 <emu> still not clear what that means
13:44:13 <esap> With continuation passing, this problem is solved by explicitly passing the continuation. IF you want to do resource clean-up, you will pass a different continuation to the next function in the chain.
13:44:52 <emu> in the presence of non-local control transfers
13:46:47 <esap> But then you are assuming that the code that creates the resource to be freed has no control over the continuations passed through it. It has to have control to them.
13:47:41 <esap> The c++ idiom for resource freeing is that you allocate an object whose "destructor" will free it. If you jump out of a block, the destructor is invoked and the resource freed.
13:47:42 <emu> all of them?
13:48:03 <emu> the destructor is invoked by explicitly deleting it
13:48:33 <esap> RAII means destructor for a stack-allocated object (in local scope).
13:49:17 <esap> That is, when you allocate a resource, you immediately create a local-scope object whose destructor will free that resource.
13:49:18 <emu> seems like a bit of a hack
13:49:27 <emu> what you really want is code to run at the dynamic exit of a form
13:49:51 <emu> you're getting that through a roundabout means
13:49:54 <emu> but that's how C++ does things mostly
13:50:27 <esap> ok, the c++ solution is that "non-local exits" are actually not allowed, but only exceptions.
13:50:56 <esap> but it's over-conservative.
13:51:02 <emu> I consider those to be control transfers too, particularly in C++ without restart semantics
13:51:35 <esap> for exceptions, the problem is not at all hard.
13:52:25 <esap> general continuations are a bit harder, because you might have two continuations passed to the same piece of code.
13:52:48 * Riastradh returns.
13:53:47 <esap> The important realization is that invoking a continuation will never return, so that the type system require that ANY CODE can be placed after that, including impossible ones.
13:54:28 <esap> This means that a non-local exit using a continuation must mean "no effects" from that function.
13:54:58 <Riastradh> What do you mean invoking a continuation will never return?  I can show you an instance in which it can (in Scheme, for I know it best):
13:55:00 <esap> or any piece of code "skipped" due to that continuation.
13:55:17 <Riastradh> (call/cc (lambda (k) (some-other-continuation k)))
13:56:00 <Riastradh> Then the other continuation can call k and controll will again return to to where that code was called.
13:56:50 <esap> no, I mean the function (lambda (k) (some-other-continuation k)) must have type "X -> _|_".
13:57:21 <Riastradh> s/controll/control/1
13:57:27 <Riastradh> Oh, I see.
13:57:49 * Riastradh is used to programming in languages which aren't completely statically typed.
13:59:44 <esap> So Haskell for example has monads that easily fix this problem, since effects do not happen for anything that is not returned from 'main'.
13:59:52 <Derhunne> Anyone around qho can help a beginner writing a FIFO Queue in Haskell ?`
14:01:02 <Derhunne> its really important for me
14:01:45 <Riastradh> I don't think it can be done very easily.  FIFOs are mutable; Haskell is not.
14:02:12 <esap> riastradh: heh, that statement means at least two things :-)
14:02:34 <Heffalump> derhunne: try using a pair of lists
14:02:37 <Riastradh> esap, by 'Haskell is not' I was just making a play on words.
14:03:05 <Derhunne> i know....we now in the second week studying Haskell at a local University and now we should program a FIFO Queue and a Tree
14:03:20 <Riastradh> Trees are excessively simple.
14:03:39 <Derhunne> so you will help me ?
14:03:51 <Riastradh> Actually...a stack shouldn't be that difficult, either, as long as you don't need to actually mutate it and can just return a new one.
14:03:56 <Heffalump> a stack is easy
14:03:59 <Heffalump> and it'll all happen in place
14:04:00 <Riastradh> I'll help you but I won't solve your problem for you.
14:04:22 <Riastradh> OH!
14:04:38 * Riastradh kicks himself: FIFO ~= stack; -L-IFO = stack.
14:05:28 <esap> heh
14:05:36 <shapr> yow, I missed a bunch of conversation
14:05:46 <Riastradh> Indeed.
14:05:55 <shapr> dang, star trek pulled me away...
14:06:19 <shapr> fifo == queue
14:06:25 * Riastradh cackles, for he has no TV to distract him.
14:06:32 <shapr> hah, lucky you
14:06:53 <esap> we just talked about continuations and CPS, then moved on to FIFO vs LIFO.
14:06:57 <Riastradh> Never have I in my life owned a TV.
14:06:58 <shapr> I didn't watch any TV before I moved in with a woman who likes movies
14:07:00 * Riastradh is glad.
14:07:04 <shapr> I got a free TV once
14:07:17 <Riastradh> Who says you need a TV to watch movies?  DVD players on computers work fine!
14:07:33 <Riastradh> Indeed, every weekend I watch one or two movies on my computer.
14:07:47 <Derhunne2> re....con los
14:07:47 <Derhunne2> s
14:07:57 <shapr> good point
14:08:30 <Derhunne2> is anyone so nice to solve my problem....
14:08:55 <shapr> er, what's your problem?
14:08:55 <Riastradh> It would be nicer of us not to solve the problem but to show you how to.
14:08:55 <shapr> oh
14:09:03 <shapr> I agree
14:09:13 <Riastradh> Implementing FIFOs and Trees.
14:09:46 <Derhunne2> ria, we learn haskell for now 2 weeks and after 3 weeks or semester ends....and we can forget all about Haskell
14:10:01 <whee> now, why would you want to do that :)
14:10:09 <Derhunne2> our
14:10:09 <shapr> you should try using a pair of lists for FIFOs
14:10:10 <shapr> noo, Haskell is beautiful!
14:10:17 <esap> derhunne: you don't want to forget haskell.
14:10:20 <shapr> if you want to be an excellent programmer, learn Haskell, it has many lessons to teach
14:10:27 <Riastradh> You -can- but you -oughtn't- forget about Haskell.
14:10:39 <shapr> right on
14:10:54 <whee> Derhunne2: I'll show you my implementation of a FIFO in 68k assembly, and then you won't ever want to forget haskell :)
14:11:03 <Derhunne2> My Problem is not having enough ideas to solve my problems....but i have not the time yet to learn the syntax...
14:11:05 <esap> hehe
14:11:38 <Riastradh> Derhunne, what languages do you know already?
14:11:48 <esap> derhunne: syntax is the easy part.
14:11:48 <Derhunne2> C, Java, PHP
14:12:02 <Derhunne2> hehe you say so....
14:12:13 <Riastradh> YEEK!  You -DEFINITELY- shouldn't forget Haskell, then.
14:12:31 <shapr> yah, syntax is easy
14:12:46 <Riastradh> Semantics are what are difficult to teach at times.
14:13:15 <Derhunne2> but after 5 hours of learning math, 5 hours of hearing math, theres not much time....to learn haskell...
14:13:34 <shapr> haskell is more like math than it is like C
14:13:34 <Riastradh> At other times, of course, like in the case of teaching Scheme, semantics aren't difficult to teach.
14:13:38 <Riastradh> Indeed.
14:14:14 <Derhunne2> I learned TScheme a while ago....a simplier version of Scheme, but it was much more easier than Haskell for me
14:14:57 <esap> derhunne: Haskell does require you to actually *understand* things for being able to do much with it. But it's well worth it.
14:15:16 <shapr> most programming does require you to understand it for it to be useful
14:16:11 <Derhunne2> i thing its worth spending time on haskell....but there's no way...after now...1-2 weeks to implement a FIFO Queue....
14:16:25 <Riastradh> There are some languages that require no understanding, like Visual BASIC, but that aren't useful anyways.
14:16:30 <Derhunne2> hehe 
14:16:48 <whee> that's plenty of time to do a queue :P
14:17:06 <Riastradh> How much time do you have to implement a tree?
14:17:27 <Derhunne2> from now on ? hmh lets calculate...
14:17:45 <Riastradh> If you have longer than two minutes, that's enough.
14:18:10 <whee> the quick queue implementation (bit slow on adding) is pretty short
14:18:11 <Derhunne2> hmh ....5 hours....but i have to learn the syntax....before
14:18:14 <Riastradh> One minute and fifty five seconds for reading the fine manual to find the syntax, five seconds to implement a tree.
14:18:14 <Heffalump> derhunne2: do you understand the concept of data abstraction?
14:18:41 <shapr> Derhunne2: your Haskell code is due tomorrow morning?
14:19:23 <Derhunne2> hehe do you the textbook "Two dozen short lessons in Haskell" ?
14:19:38 <shapr> yah, I've seen it.
14:19:38 <Derhunne2> its from the University of Oklahoma...
14:20:22 <Derhunne2> im now on page 30....its very good.....but i have to spend more time on math right now
14:20:47 <Riastradh> See, I only started learning Haskell last night, but I can implement a tree right now.
14:21:09 <Derhunne2> how long does it take for you ria ?
14:21:13 <Riastradh> Do you know about the 'data' syntax?
14:21:17 <Riastradh> Take for me to what?
14:21:49 <Derhunne2> to learn haskell and his syntax
14:22:10 <Riastradh> I don't know -- as I said, I only started learning it last night; I wouldn't claim to know Haskell right now.
14:22:25 <Riastradh> But I -can- write a tree implementation; it is excessively simple.
14:22:52 <SyntaxPolice> Derhunne2: you have to write a tree data structure, and do you have to make it do something? Do you have to perform some sort of traversal over the tree?
14:23:37 <Derhunne2> ok here is what i have to do:
14:23:58 <Derhunne2> i have to implement a tree with the following functionality
14:24:27 <Derhunne2> there has to be a function to count all elements
14:25:04 <Derhunne2> a function to get the height (depth) of the tree
14:26:09 <Derhunne2> a function which gives back a list of the elements in a certain order: elements_pre b = [4,2,1,3,6,5,7]
14:26:49 <Derhunne2> the next function should give back the elements this way: elements_in b = [1,2,3,4,5,6,7]
14:27:07 <Derhunne2> the next this way: elements_post b = [1,3,2,5,7,6,4]
14:27:07 <Derhunne2> elements_
14:27:28 <Derhunne2> the last this way: elements_bf b = [4,2,6,1,3,5,7]
14:27:32 <whee> I think once you understand the tree data structure that you'll have no problems writing those
14:28:27 <Derhunne2> i have no problems with trees, avl-trees or something like that, my problem IS HASKELL....
14:29:07 <esap> what is the specific problem you are having?
14:29:25 <whee> well I think writing the queue should be done first, it'll be useful in writing your elements_bf function
14:29:45 <Derhunne2> right whee
14:29:50 <SyntaxPolice> Derhunne2: I'm sure that several of us here will be willing to help you.  None of us here are willing to write it for you, even though several of us could, but I think you'll need to help us out a little by explaining what you're having trouble with and how you are approaching the problem.
14:31:09 <Derhunne2> for example what means "::", or "[[Char]]"....
14:31:32 <Derhunne2> elementary things are my problem....
14:31:37 <SyntaxPolice> [[Char]] means a list of lists of chars. A list of chars is a String.
14:31:45 <SyntaxPolice> (similar to C)
14:31:46 <Riastradh> foo :: bar   foo is of type bar
14:31:59 <Riastradh> [[Char]]   a list of lists of characters
14:32:02 <SyntaxPolice> so [[Char]] is a list of Strings.
14:32:09 <Riastradh> That too.
14:32:58 <SyntaxPolice> and if I said "foo [[Char]]" that would mean "foo is of the type List of Strings" similar to "char** argv" or something in C.
14:33:10 <Derhunne2> ok so "n :: Int -> Int" is the same as " int n = integer ?
14:33:26 <Riastradh> No.
14:33:30 <esap> derhunnel: that means n is a function from integer to integer.
14:33:40 <Riastradh> n :: Int -> Int   means that n is a function that takes an integer argument and returns an integer.
14:34:14 <SyntaxPolice> so in C: int n (int b) { return something of type integer }
14:34:35 <Riastradh> No, not quite; in C:  int n (int);
14:34:54 <Riastradh> Your example, SyntaxPolice, is a function -definition-; 'n :: Int -> Int' is more like a function declaration.
14:35:04 <SyntaxPolice> Riastradh: yes, you're right.
14:35:06 <Riastradh> Actually, to be even more precise:
14:35:09 <Derhunne2> ok so its a like the definition in math: "f: D -> R" 
14:35:23 <Riastradh> int (*n) (int);
14:35:35 <Marvin--> Derhunne2: yup
14:36:13 <Derhunne2> ok
14:36:26 <Marvin--> time to sleep
14:36:55 <Derhunne2> so i put the function definition first and after that i define it more precisly
14:37:10 <Derhunne2> i lost an e 
14:37:17 <Derhunne2> precisely
14:37:31 <Riastradh> You declare its type and then you define it; i.e.:
14:37:33 <SyntaxPolice> Derhunne2: yeah, don't make sort of the mistake I did... You declare the type of the function in one point, and then usually below that, you define the function itself.
14:37:34 <Riastradh> f :: Int -> Int
14:37:42 <Riastradh> f x = x * x ^ x
14:37:49 <SyntaxPolice> but don't confuse define and declare :)
14:37:51 <Riastradh> Which would translate to C as:
14:37:59 <Riastradh> int f (int);
14:38:04 <Riastradh> int f (int x)
14:38:04 <Riastradh> {
14:38:11 <Riastradh>   return (x * x ^ x);
14:38:13 <Riastradh> }
14:38:35 <Derhunne2> so instead of f(x) = x * x^x i write f x = x * x^x
14:38:41 <Riastradh> Yes.
14:39:11 <Riastradh> Functions in Haskell aren't called like in C -- 'f(x)' -- instead they're called like:  'f x'
14:39:28 <Derhunne2> ok
14:41:03 <Derhunne2> hmh now its time to think how to construct a list....
14:41:51 <Riastradh> head : tail
14:42:18 <shapr> edge
14:42:34 <Derhunne2> so i have acces only to the head like in Scheme...
14:43:22 <Derhunne2> right ?
14:43:43 <Riastradh> No, you can access the tail, too.
14:44:08 <Derhunne2> hmh ok
14:47:36 <Derhunne2> concat :: [[a]] -> [a] would merge the lists into one....
14:48:04 <esap> right.
14:49:44 <Derhunne2> so a list with the name numbers would be defined like this :
14:49:57 <Derhunne2> numbers :: Int -> [a]
14:51:06 <esap> Hmm.. no. Note that there is a difference between names starting with a lower-case letter and names starting with upper-case letter.
14:51:54 <esap> [a] means "list of objects of any type 'a'"
14:53:07 <esap> and so your example would be a function taking one integer and returing a list of objects of any type 'a'.
14:53:25 <Derhunne2> ah
14:54:25 <Derhunne2> so i have to write : numbers :: Int -> [Int]
14:54:31 <esap> consider "id :: a -> a". This is a function taking any object and returning an object with the same type.
14:54:34 <Derhunne2> for a list of integers ?
14:54:49 <esap> that would be a function taking an integer and returning a list of integers.
14:55:10 <Derhunne2> right....
14:55:59 <Derhunne2> i think i understand the declaration
14:56:37 <Derhunne2> data Tree a = Leaf a
14:56:37 <Derhunne2> | Branch a (Tree a) (Tree a)
14:56:54 <Derhunne2> can you explain me what this means ?
14:57:48 <esap> It defines a type called "Tree a" for every type 'a'.
14:58:41 <Derhunne2> is data necessary ?
14:58:51 <esap> Such that you can construct objects of type 'Tree a' using a constructors 'Leaf' and 'Branch'.
14:59:09 <esap> Yes, 'data' is a keyword that says it's a new data type.
14:59:47 <Derhunne2> so its like Object a = new Object(); in Java ?
15:00:45 <esap> no, consider 'data Color = Red | Blue'. That defines a type 'Color'.
15:01:00 <Derhunne2> oh ok
15:01:13 <esap> With exactly two different values.
15:02:04 <esap> The a in 'Leaf a' is a type of the value that the constructor will expect to be able to construct a value of that type (Tree a).
15:02:27 <esap> I mean in that 'data Tree a = Leaf a | ...'
15:02:34 <Derhunne2> so its declaration is: Color :: String -> String ?
15:02:54 <esap> No, those are not strings.
15:03:18 <esap> it's more like Red :: Color.
15:03:30 <Riastradh> Do you know C++?
15:03:39 <esap> and Leaf :: a -> Tree a
15:04:03 <Derhunne2> a bit through C and Java....why ?
15:04:45 <Riastradh> I hate to make this comparsin, and I'll probably be murdered here if I do, but imagine 'data Tree a' as like a template declaration with one parameter, 'a'.
15:04:53 <Riastradh> s/comparsin/comparison/1
15:06:09 <Derhunne2> hm
15:10:35 <esap> Leaf, Red, Blue and Branch in the examples are all like C++'s class constructors. They construct values.
15:11:03 <Derhunne2> ok...
15:11:37 <Smerdyakov> Riastradh, the difference is that C++ templates in general need to emit separate code for each instantiation, whereas one copy of a polymorphic Haskell function suffices.
15:11:39 <Derhunne2> perhaps esap and ria you both tell me how you learnded Haskell....
15:11:45 <esap> So you would be able to use 'x :: Color' followed by 'x = Red' to make a variable x contain value red.
15:11:57 * shapr bounces happily
15:12:11 <Riastradh> Derhunne - Er, I haven't learned Haskell yet; as I said, I started learning it last night.
15:12:21 <Riastradh> But what I'm reading is the 'Gentle Introduction to Haskell' found on haskell.org.
15:12:33 <Derhunne2> ok and you esap ?
15:13:08 <esap> I also read gentle introduction and the stuff at haskell.org. But I had lots of c++ experience beforehand, so after that I proceeded to read the definition of the language.
15:13:36 <Smerdyakov> Riastradh, did my explanation help..?
15:13:46 <esap> But I would not recommend that approach.
15:13:48 <Riastradh> I've got plenty of experience with Scheme and a bit in ML, though, so it's not difficult for me to learn Haskell.
15:14:20 <Derhunne2> right
15:14:21 <Riastradh> Smerdyakov - Er, I was explaining it to Derhunne, not trying to think up something to help me understand it.
15:14:39 <Smerdyakov> Oops. I came too late ;-)
15:14:51 <Smerdyakov> So, Derhunne2, did that help? =)
15:14:57 <Riastradh> Indeed, I don't even know C++; I've just read a little bit of code in it (maybe ten lines at most) and heard a bit about templates.
15:15:13 <esap> But some of the important things (like monads) took longer to understand. The examples in the gentle introduction and the standard libraries are very good at learning, once you get some idea of the syntax.
15:16:07 <Smerdyakov> Monads are a lot easier to understand if some schmoe doesn't tell you "they're how you do IO in Haskell!!" ;-)
15:16:16 <Smerdyakov> (by way of a definition)
15:16:24 * Riastradh doesn't understand monads yet.
15:16:34 <Riastradh> But I haven't read more than one or two sentences about them yet, either.
15:16:34 <Derhunne2> perhaps i read the gentle introduction and come back to you when i have finished 
15:17:23 <Smerdyakov> Riastradh, as far as I've been able to figure out, monads are a general way of combining atomic computations to yield big fat computations. If the atomic computations are implemented in a lower level language, you can get things like IO. =)
15:19:23 <esap> in a sense, a monad is an interface that has an operation for building an 'action' from two actions composed sequentially. (x >>= \a -> y   means "do x, bind the result to 'a' and then do x"
15:19:42 <esap> the last x should be y.
15:20:26 <Derhunne2> ok guys, i thank you all, for helping me....i think the best way is...: first get some coffee, second get the gentle introduction....after that...read and learn
15:21:12 <Riastradh> Er, why can't you just do:  let a = x in y  ?
15:21:42 <Smerdyakov> Riastradh, because then mutation of global state can seep out all over your program!!!
15:21:55 <shapr> and then you have to clean it up!
15:22:02 <shapr> and you've run out of towels!
15:22:03 <Smerdyakov> Riastradh, presumably, x does something awful, like write a bit in your filesystem ;-)
15:22:08 <esap> because 'action' is different from 'value'. An action for producing an integer might have type 'IO Integer' which is different from 'Integer'.
15:22:34 <Derhunne2> good night guys....thanks a lot...i will come back in lets say 7 hours....
15:22:35 * Riastradh will have to read about how I/O is done in Haskell.
15:22:41 <shapr> good night!
15:23:09 <Smerdyakov> I haven't yet thought through how monads interact with lazyness to produce a reasonable implementation where only the monadic values put together to form the main() return value get executed, and in the right order...
15:23:51 <esap> in (x >>= \a -> y), both x and y have type IO <something>.
15:27:33 <esap> smerdyakov: you need to think it in a sense "backwards" or "bottom to up" order, in a sense that the main function returns an IO action, which is executed. The first operation in that IO action may require some evaluation, so that is evaluated first. After that, the first IO operation is performed. Then the second I/O operation might require something etc.
15:28:57 <esap> Only things that are required by I/O operations returned from main will ever be evaluated.
15:29:52 <esap> And the system evaluates only those parts of expressions that are necessary to determine the next I/O operation to be performed.
15:30:04 <Smerdyakov> Oh, thanks =)
15:33:00 <shapr> hi Pseudonym!
15:33:05 <shapr> gooood morning!
15:33:06 <Pseudonym> G'day.
15:33:07 <Pseudonym> You're up late.
15:33:18 <shapr> yah, having fun...
15:35:19 <esap> smerdyakov: There are some very obscure situations that are not quite that simple [involving unsafePerformIO etc], but I guess that description covers the basic idea.
15:36:07 <esap> smerdyakov: oh and 'seq' that can be used to specify what additional parts are evaluated.
15:36:52 <esap> but if you do not do anything strange, the description should be sufficient to determine the performance characteristics of the programs.
15:37:49 <shapr> Pseudonym: what's up with you? cool code?
15:38:10 <Pseudonym> Er... no.
15:38:13 <Pseudonym> Very uncool code.
15:38:25 <shapr> what are you doing?
15:38:38 <Pseudonym> OK, we write this Z39.50 database server.
15:38:46 <Pseudonym> The on-disk format has changed between versions.
15:38:50 * shapr urks 
15:38:54 <Pseudonym> I am writing a tool to upgrade them.
15:38:58 <shapr> Z39.50 == ASN.1
15:39:02 <Pseudonym> Yes.
15:39:08 <shapr> ASN.1 == Cthulhu
15:39:09 <Pseudonym> :-)
15:39:14 <shapr> by logical induction....
15:39:19 <shapr> I'm impressed you can still speak
15:39:28 <Pseudonym> Actually we're using XER in the new version instead of the old BER.
15:39:32 <esap> database upgrades are very complex beasts.
15:39:39 <Pseudonym> That's one of the format changes. :-)
15:39:48 <Pseudonym> Thankfully the index and data store formats have NOT changed.
15:39:52 <shapr> XER is the most insane format I've ever conceived of....
15:39:58 <Pseudonym> Just the definitions and associated database metadata.
15:40:05 <shapr> it's like.. turn a tightly packed binary formant INTO XML?????
15:40:11 <shapr> what were they THINKING?
15:40:24 <Pseudonym> ASN.1 is a syntax, no more.
15:40:26 <emu> XML???? what were they THINKING?
15:40:28 <esap> heheh
15:40:35 <Pseudonym> PER is a tightly packed binary format.
15:40:40 <Pseudonym> BER is a loosely packed binary format.
15:40:47 <Pseudonym> DER is... who knows.
15:40:53 <Pseudonym> XER is a human-editable format.
15:41:03 <shapr> DER is just like BER, but the load is placed on the encoder 
15:41:05 <Pseudonym> All corresponding to the same syntax.
15:41:07 <Pseudonym> Right.
15:41:14 <emu> anything is human-editable, with the proper editor
15:41:18 <shapr> emu: not ASN.1
15:41:20 <Smerdyakov> Hello, EMU
15:41:25 <shapr> that stuff is evil
15:41:25 <Pseudonym> I still don't know the point of DER, that was what I meant.
15:41:32 <Pseudonym> As opposed to BER.
15:41:40 <Pseudonym> Sorry, as opposed to PER.
15:41:42 <lament> being human-editable is overrated.
15:41:44 <Pseudonym> Or gzipping your BER.
15:41:48 <shapr> oh, I don't know about PER
15:41:54 <Pseudonym> PER = Packed Encoding Rules
15:42:01 <esap> being human-editable might actually be a problem.
15:42:04 <shapr> I don't know how it compares to BER and DER though
15:42:07 <Pseudonym> Like BER only 97% fat free.
15:42:10 <shapr> heh
15:42:21 <emu> wow, Smerdyakov on a haskell channel =)
15:42:34 <shapr> DER is "Distinguished" but it should really mean "deterministic"
15:42:41 <Pseudonym> There's one real problem with XER as a human-editable format, though.
15:42:55 <Pseudonym> ASN.1 has no concept of a "syntax error".
15:42:58 <shapr> the idea being that you never have the unknown length problems you can have with BER
15:43:00 <Pseudonym> It conforms or it doesn't.
15:43:02 <Pseudonym> Oh, I see.
15:43:06 <Pseudonym> That's a good idea.
15:43:11 <shapr> sort of...
15:43:27 <Pseudonym> We've only ever supported BER and XER, anyway.
15:43:32 <shapr> what it really means is that you can write a static decoder for a format in C, and still scrape by...
15:43:47 <Pseudonym> Oh.  I guess that's useful, kind of.
15:43:51 <shapr> wouldn't work so well with BER, because you can't declare array size beforehand...
15:43:53 <shapr> or something like that.
15:44:00 * Pseudonym tries to recall when he last wrote something in C...
15:44:20 <shapr> hey, I saw some cute Oz code on the pragmatic programmers list today...
15:44:23 <Pseudonym> Oh?
15:44:48 <shapr> "spreadsheets as transparently paralell processes"
15:44:50 <shapr> neat idea
15:45:00 <Pseudonym> Interesting.
15:45:07 * Pseudonym has worked most of it out from that, incidentally
15:45:11 <shapr> heh :-)
15:45:21 <Pseudonym> Spreadsheets use a fancy dataflow evaluation mechanism.
15:45:25 <shapr> I suspect you could come up with better code than they did....
15:45:32 <Pseudonym> Not in Oz, I couldn't.
15:45:37 <shapr> really?
15:45:58 <shapr> in any case, is your upgrade trouble free so far?
15:46:00 <Pseudonym> Ich spreche kein Oz.
15:46:04 <Pseudonym> So far.
15:46:06 * shapr laughs
15:46:44 <Pseudonym> The problem is, we have big customers out there with multiple-terabyte databases with critical data who use weird corner cases of our system.
15:46:59 <Pseudonym> Writing it is easy.  Testing it is a dozen different varieties of bitch.
15:47:00 <shapr> that's scary
15:47:20 <shapr> multi-terabyte database... yikes
15:47:21 <Pseudonym> And the code is not cool.
15:47:35 <Pseudonym> Read.  Copy, copy, copy, sanity check, copy, copy, sanity check, copy, copy... write.
15:47:43 <shapr> heh
15:48:17 <esap> you mean half of the time spent in the system is used for the sanity checks? :-)
15:48:28 <Pseudonym> :-)
15:48:44 <emu> what could possibly be kept in a multi-terabyte database
15:48:50 <shapr> emu: a *lot* of stuff!
15:48:55 <emu> the value of 1000000000000000000000000000000000000000! ?
15:48:57 <Pseudonym> All sorts of things.
15:49:12 <emu> megatons of pr0n
15:49:16 <Pseudonym> Generally, the multi-terabyte customers are government agencies who won't tell us what they put in there.
15:49:21 <shapr> whenever anyone says "Z39.50" think "really really big libraries"
15:49:23 <emu> pr0n
15:49:29 <Pseudonym> Probably.
15:49:32 <esap> newsfeed.
15:49:36 <emu> fed pr0n -- your personal info
15:49:43 <Pseudonym> I'll bet the US DoD is storing lots and lots of pr0n.
15:49:47 * shapr grins
15:49:56 <Pseudonym> You know where the term "boilerplate" comes from?
15:50:02 * shapr raises his hand
15:50:06 <shapr> steam engines?
15:50:09 <Pseudonym> shapr?
15:50:12 <emu> pots
15:50:12 <Pseudonym> Good!
15:50:26 <Pseudonym> I mean "boilerplate" to refer to padding in documentation.
15:50:32 <shapr> oh
15:50:48 <shapr> I don't really know how it came to mean "boilerplate" in code or docs.
15:50:49 <emu> I know what it is!
15:50:52 <emu> XML!
15:50:54 <shapr> hah
15:50:57 * Pseudonym laughs
15:50:59 <emu> multi-terabytes
15:51:17 <emu> <stupid_long_tag_name>1</stupid_long_tag_name>
15:51:20 <Pseudonym> There's a probably apocryphal story that the DoD never actually read their tenders.
15:51:27 <emu> guaranteed to bloat your data or your money back
15:51:35 <Pseudonym> They would put out a tender, get the submissions back and just weigh them.
15:51:49 <shapr> haha
15:51:56 <Pseudonym> To test this theory, one contractor cut out the middle of one of their volumes and put in a piece of boilerplate.
15:52:03 <Pseudonym> The story concludes that they got the contract.
15:52:05 <esap> the worst that I've seen is all those nice gzipped XML stuff. It's a lose-lose proposition.
15:52:28 <Pseudonym> Our customers store a LOT of XML.
15:52:33 <Pseudonym> Multiple terabytes, in some cases.
15:52:46 <Pseudonym> But then, they store structured documents, which is what XML is for.
15:53:22 <emu> XML -- the eXtreme Meta Language
15:53:36 <lament> is there _any_ excuse for the existance of xml?
15:53:51 <emu> eXcuse for a markup language
15:54:12 <Pseudonym> Sure there is.
15:54:13 <lament> hehehe
15:54:14 <Pseudonym> It's a simpler SGML.
15:54:22 <lament> Pseudonym: gah! that's not an excuse.
15:54:29 <Pseudonym> Sure it is.
15:54:30 <esap> I guess the standard excuse is that it's not microsoft-proprietary.
15:54:31 <lament> that's an insult.
15:54:33 <shapr> DSSSL is scary
15:54:43 <Pseudonym> We don't touch DSSSL.
15:54:59 <Pseudonym> We steer clear of most things built on top of XML.
15:55:09 <Pseudonym> We support XPath.  That makes some kind of sense.
15:55:25 <Pseudonym> You have XML, you want to index it.  XPath is the right thing to say what you want in each index.
15:56:57 <esap> XPath has the right idea. I'm not sure it's been brought far enough though.
15:57:27 <emu> structured document markup is a problem.  when you try XML, you now have 2 problems.
15:58:23 <esap> three, actually, you need to have the DTD as well, oh and the schema :-)
15:58:37 <shapr> hi Arnia 
15:59:05 <Pseudonym> The problem with XML, IMO, is that people use it for things other than structured documents.
15:59:23 <Arnia> Heya
15:59:29 <esap> right, like for protocols.
15:59:42 <shapr> Arnia: more good dates?
15:59:44 <Pseudonym> XER isn't really XML.
15:59:45 * Arnia bounces up and down and starts designing his SEG project
15:59:52 <Pseudonym> It doesn't need a DTD, for example.
16:00:17 <Arnia> shapr: Nah, just computation stuff
16:00:31 <shapr> ok
16:01:16 <Arnia> Using Plone to develop my SEG project... I'm the only one in my group that knows Python... but then I'm the only coder in my group anyway
