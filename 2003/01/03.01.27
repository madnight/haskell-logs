01:13:47 <Marvin--> morning
01:14:18 <dennisb> Marvin--: Hi, did you get yourself a laptop?
01:17:19 <Marvin--> dennisb: yup
01:18:11 <Marvin--> I'm sitting here wondering if I should work on my master project or install Debian on it
01:18:22 * Marvin-- needs a switch, badly
01:18:41 <dennisb> Debian of course
01:19:13 <Marvin--> it's kind of a pain to do it before I buy a switch since it means I'll have to pull the net from this machine
01:19:36 <dennisb> Run out and buy a switch, they are cheap nowadays
01:20:15 <Marvin--> yeah, I just wonder if I should get a 4-port or an 8-port
01:20:43 <Heffalump> what would you need 8 ports for?
01:20:45 <Marvin--> not that I have the room for eight computers here, but it might be nice for LAN gaming
01:20:45 <dennisb> I don't have a laptop yet, but it's getting harder and harder to resist getting one
01:21:09 <Heffalump> do you have the room for an 8 port switch?
01:21:14 <Heffalump> Or will it just get in the way mostly?
01:21:15 <Marvin--> considering that a 4-port costs something like 40 euro and an 8-port something like 50 euro
01:21:34 <dennisb> I've got 4 connected computers, but I have 6 ports on my old hub
01:21:36 <Marvin--> I'm not sure exactly how big it is, I won't decide until I've had a look at them
01:21:53 <Marvin--> I guess I'll be having three computers on this one
01:22:03 <Marvin--> or two when the laptop is away
01:22:29 <Heffalump> sounds like you'd be better off with an 8 port then
01:22:40 <Heffalump> three computers + incoming connection, or two computers + incoming connection?
01:23:10 <Marvin--> hmm... do switches have uplink thingies or is just hubs that have them?
01:23:13 <dennisb> I just had a 50-minute power failure, could have used a laptop today.. Always fun to see if the server boots after a failure...
01:23:24 <Marvin--> dennisb: at MC? yeah
01:23:29 <dennisb> Marvin--: no, at home
01:23:51 <Marvin--> dennisb: oh... I'm not too worried about power outages at home, but power outages at MC always end up as disasters :)
01:24:27 <Marvin--> anyway, I guess I'll be putting my old computer as gateway/firewall... Will I need two NICs in it, or can I just plug everything into the switch?
01:24:29 <dennisb> well, I have two computers that both export nfs-filsystems that the other mounts. nfs is not fun in situations like this :-)
01:24:47 <Marvin--> true
01:24:57 <Marvin--> # Garbage collection reclaimed 4048 unused term cells.
01:24:58 <Marvin--> hrrm
01:25:02 <dennisb> Marvin--: I have two nics in my gateway-computer, since I get only one IP that's how it should be
01:25:31 <Marvin--> dennisb: ok, same for me then
01:25:45 <Marvin--> then I guess there'll be three computers plugged into the switch, and two NICs in one of the computers
01:26:03 <Marvin--> I'm just wondering what the differences between a hub and a switch is
01:26:06 <dennisb> I wrote a parser using parsec yesterday, it's a pleasure compared to bison/happy and similar
01:26:23 <Heffalump> Marvin--: decent switches tend to auto-detect
01:26:30 <Marvin--> I haven't really used parsec, only parsek :)
01:26:37 <dennisb> hmm...
01:26:38 <Marvin--> Heffalump: neat
01:26:42 <Heffalump> at least mine does
01:27:07 * Marvin-- has been playing civ3 on his laptop to..uh..practice using the pointer pad! yes, right!
01:28:11 <dennisb> My hub also autodetects 10/100mbit, it's like two hubs with a switch between. The typical difference between a switch and a hub is that with a hub only two computers can talk at the same time.
01:28:16 <dennisb> Marvin--: what is parsek?
01:28:42 <Marvin--> dennisb: something Koen wrote, I feel it's easier to use than parsec, but that's probably just because I've used it more
01:29:27 <dennisb> Probably, as I see it parsec is as simple as it can be :-)
01:30:52 <Marvin--> I guess I never understood the try combinator
01:31:30 <Marvin--> ''The aim was to get a library that was equally fast, without having to use the cumbersome "try" combinator.'' (from Parsek.hs)
01:33:48 <dennisb> Is Parsek on the web somewhere?
01:33:58 <Marvin--> hmm
01:34:05 <Marvin--> try the semantics course homepage :)
01:34:22 <Marvin--> Jörgen used it for a parser for the language we used there
01:34:49 <dennisb> try is not difficult, if you have two parsers that accept the same input (prefix) then if you put them in parallell with <|> you have to put try on the first to allow the parser to backtrack there
01:35:15 <Marvin--> okay... instead of left-factoring it?
01:35:28 <dennisb> It would be better without try, but if it helps the speed, then ok
01:35:36 <dennisb> Marvin--: yes
01:39:12 <dennisb> Marvin--: about Parsek, since we work at the same place of course I can just do a cd to koens home directory, but that is cheating
01:42:10 <Marvin--> dennisb: I was wondering ;)
01:43:15 <dennisb> I found it
01:43:16 * Marvin-- tries to understand E
01:43:21 <dennisb> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/nasem/labfiles/haskell/Parsek.hs
01:43:27 <Marvin--> sounds familiar
01:43:49 <Marvin--> find ~koen -name Parsek.hs would've worked too :-)
01:44:22 <dennisb> But parsec has other nice features, like handle line/column numbers for error reporting, expression-parser that takes care of boring stuf like +,*,= and the usual stuff
01:44:47 <Marvin--> the line/column number stuff sounds nice indeed
01:44:52 <dennisb> Helpfunctions to create lexers is also included
01:45:03 <Marvin--> have you looked at Aarne's bnfc?
01:45:13 <dennisb> no, almost nothing
01:45:35 <Marvin--> I mean, it generates the happy file for you
01:45:57 <Marvin--> he demonstrated it on a komp lecture, kinda cute that it generates documentation too ;)
01:46:12 <dennisb> Aha, well, I don't know anything about it. I just know that he has done something in that area
01:46:49 <dennisb> Hmm, my haskell file does not load after the power failure... that's strange. It worked a couple of hours ago
01:47:25 <Marvin--> no journalling file system?
01:47:31 <dennisb> Or maybe it didn't
01:47:39 <dennisb> I use ext3
01:47:58 <Marvin--> bnfc generates an alex file, a happy file, data types, documentation skeleton, a Makefile...
01:48:06 <Marvin--> and a test program too I think
01:48:11 <dennisb> Give me an url
01:48:31 <Marvin--> http://www.cs.chalmers.se/~markus/BNFC
01:49:24 <Marvin--> oh yeah, it generates a pretty printer too
01:50:01 <dennisb> And it makes coffee?
01:50:10 <Marvin--> I don't think so, but I'll talk to him about it
01:50:13 <Marvin--> sounds like a reasonable extension
01:51:57 <Marvin--> hmm
01:52:07 <Marvin--> no license information
01:52:52 <Marvin--> it seems like GPL from the program output, but there's no licensing information in the source
01:52:53 <dennisb> Well, bnfc is "just" an bnf-converter. The nice thing about combinators is that you can make higher order stuff so easy, and you don't have some of the strange restrictions
01:53:07 <Marvin--> sure
01:54:16 <Marvin--> speaking of coffee...brb
02:02:18 * Marvin-- now has coffee, all is well with the world
02:02:44 <lament> coffee is just a tea substitute.
02:04:04 <Marvin--> tsk
02:17:14 <Marvin--> dang, I'll have to package alex too if this is to be meaningful
02:39:49 <Marvin--> hah, that's what you get for not loving coffee! :)
03:00:41 <Janni> long time no see
03:18:47 * Marvin-- digs through the TPTP database
03:27:19 <Janni> re
03:27:23 <shapr> hi Janni 
03:28:49 --- topic: set to '["mo' nads than you", "We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/", "buddha debugger 0.4 http://www.cs.mu.oz.au/~bjpop/buddha/", "new  #sml channel for all your ML topics", "HWS-WP: http://www.dum.chalmers.se/~marvin/hws-wp/", "HaSDL: http://www.xs4all.nl/~dark/hasdl-0.1pre7.tar.gz","New HTk release http://www.informatik.uni-bremen.de/htk/", "Tallest dwarf in Moria"]' by shapr
03:47:09 <Marvin--> Does anyone know how far away Alex is from being integrated with happy?
03:47:59 <Marvin--> i.e. does it make sense for me to package alex for Debian?
03:50:04 <andersca> Marvin--: murphy's law...if you package it it'll be integrated right away
03:50:12 <andersca> if you don't, then it won't
03:52:34 <Marvin--> good point
03:52:44 <Marvin--> I'd better package it then, shouldn't be too hard
03:52:53 <Marvin--> after all, it doesn't use autotools ;)
03:53:36 * Marvin-- wonders what the difference between "vänteläge" and "viloläge" is
04:00:29 <Marvin--> andersca: surely you have a laptop and know the difference between them?
04:01:48 <andersca> hmm, good question
04:01:57 <andersca> could be just turn off screen vs turn of screen and cpu and only power memory
04:03:32 <Marvin--> I guess "viloläge" is hibernation
04:03:47 <Marvin--> but since there are separate settings for powering down monitor and hard drives I don't really understand what "vänteläge" is
04:07:00 <Marvin--> $ ls /proc/acpi/button/
04:07:00 <Marvin--> power/  power/
04:07:01 <Marvin--> hmmm!
05:55:37 * shapr bounces
06:00:16 <Segora> re shapr
06:00:20 <shapr> heya
06:00:27 <Segora> got my mail?
06:00:28 <shapr> thanks for sending the IRC parsing stuff
06:00:31 <shapr> yah, it's neat
06:00:45 <Segora> well it's not nearly as polished as it should be
06:00:52 <shapr> as you said, it's a prototype
06:01:03 <shapr> I'd like to hack it into a real bot at least
06:01:10 <Segora> far less. just a small experiment. a prototype would do something useful ;)
06:01:13 <shapr> heh
06:01:22 <shapr> fair enough
06:01:41 <shapr> I'd like to have a bot written in Haskell
06:01:45 <shapr> this is a good starting point.
06:02:02 <Segora> well, I would recommend factoring out the irc protocol aspect as a monad.
06:02:28 <shapr> I've been thinking that I can factor protocols out as monads
06:02:30 <shapr> but I'm not really sure how
06:02:44 <shapr> I haven't constructed a monad from nothing
06:02:49 <shapr> only used monads other people wrote
06:03:56 <Segora> well, you could with starting simple. a calculator maybe. (clear :: Calc (); add :: Int -> Calc (); result :: Calc Int)
06:04:06 <Heffalump> Segora: are you suggesting making a separate monad rather than just making some methods for IO?
06:04:07 <Segora> arg. parse error
06:04:10 <Heffalump> and if so, why?
06:04:48 <Segora> Heffalump: yes. when using IO directly, you would still have to pass around references to state.
06:04:55 <Heffalump> oh, true
06:05:27 <Segora> the IRC monad would hold protocol and connection state
06:06:32 <shapr> I think I understand that.
06:06:35 <Segora> do { join "#haskell"; msg "hi!" } looks not too bad, doesn't it? ;)
06:06:44 <shapr> truly
06:07:11 <Segora> withIrcServerDo "irc.freenode.net" 6667 (do { join "#haskell"; ... }) that is
06:08:05 <Heffalump> how would you handle multiple servers at the same time with that interface?
06:08:33 <Segora> concurrency abstractions
06:09:20 <shapr> Segora: sounds like you should design irclib.hs whether you write all the code or not :-)
06:09:45 <Segora> oh my god, I saw it coming ;)
06:09:51 * shapr snickers
06:10:04 * Segora ducks.
06:10:09 <Segora> phew. missed for now. *g*
06:10:35 <shapr> well, if you write up something that shows me how an irc monad should work, I can fill in the rest. ( I think )
06:11:04 <Segora> anyway, I would like to but I fear exams, work and my current spare-time commitments will leave me now room for that in the next two or three weeks
06:11:42 <shapr> well, I can work on email tools for three weeks :-)
06:11:47 <Segora> shapr: ok, i'll stick a note to my monitor. can't guarantee anything, though.
06:11:55 <shapr> that's cool
06:12:09 <shapr> I'll play with this code in the meantime
06:12:23 <Segora> have fun :)
06:12:31 <shapr> thanks
06:29:35 <Heffalump> Segora: concurrency abstractions where?
06:30:01 <shapr> Segora: hey, silly question, is your code lGPL? can I redistribute, etc etc?
06:30:17 <Segora> shapr: hmm.
06:30:40 <Segora> Heffalump: forkIO, MVars etc.
06:31:28 <Segora> shapr: please wait a moment, i'll take a sharp glance at it.
06:31:49 <shapr> ok, thanks
06:32:30 <Segora> BSD license
06:32:34 <Heffalump> Segora: hmm, seems excessive given that you could just serialise it all in the underlying implementation
06:33:17 <Segora> Heffalump: I must admit I did not think very hard about that problem
06:42:15 --- topic: set to '["mo' nads than you", "We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/", "buddha debugger 0.4 http://www.cs.mu.oz.au/~bjpop/buddha/", "new  #sml channel for all your ML topics", "Helium 1.0 - Haskell for Students http://www.cs.uu.nl/~afie/helium/index.html", "HaSDL: http://www.xs4all.nl/~dark/hasdl-0.1pre7.tar.gz","New HTk release http://www.informatik.uni-bremen.de/htk/", "Tallest dwarf in Moria"]' by shapr
06:42:40 <shapr> Helium (for learning Haskell) 1.0 - http://www.cs.uu.nl/~afie/helium/index.html 
06:43:32 <SyntaxPolice> good morning.
06:43:44 <shapr> good morning Mr. Police
06:44:50 <SyntaxPolice> shapr: how are you?
06:44:51 <shapr> I should read up on daan leijen's lazy virtual machine 
06:45:18 <shapr> I'm doing well, wrote good code over the weekend. a very bad but working SMTP.hs, and a 75% of a decent RFC822.hs
06:45:42 <Smerdyakov> Now, I wonder why you always give filenames instead of descriptions.
06:46:01 <shapr> Smerdyakov: good point.
06:46:20 <Smerdyakov> I wrote a good cool.txt!!!!
06:46:25 <shapr> I wrote the beginnings of Haskell email tools over the weekend.
06:47:11 <shapr> after that, MIME support!
06:47:36 <shapr> hey, what kind of libs would you guys like to use?
06:47:49 <shapr> I want email and postgres support.
06:49:11 <shapr> since the haskell wishlist is dead...
06:50:49 <Smerdyakov> Postgres support is easy if you have a C FFI
06:51:13 <shapr> I'm not familiar enough with the existing FFI to write my own binding
06:51:16 <Heffalump> if I had (partial) replacements for Image::Magick, Image::Info, Image::Size, Date::Parse, URI::Escape and HTML::Entities I might be able to rewrite http://urchin.earth.li/projects/photopub/ in Haskell (the web page is horribly slow cos our upstream provider seems to be having some trouble)
06:51:32 <Smerdyakov> Is the FFI complex enough that you can't learn it? =)
06:52:30 * Smerdyakov marvels at how many different software packages do what that page says Heffalump's does =)
06:54:23 <xkb_> hmm what module do I import if I want to use throw?
06:54:45 <Heffalump> smerdyakov: yeah, it's kind of something everyone wants to do their own way :-)
06:55:22 <Smerdyakov> Heffalump, I don't buy it. You just like to waste time. :P
06:55:23 <shapr> xkb_: I think it's in either one of the Monad modules, or one of the IO modules.
06:55:38 <shapr> Smerdyakov: aren't you writing a webserver in SML?
06:55:52 <Heffalump> I could explain why mine is better than everyone else's (IMO of course :-) but I have to go
06:55:55 <Smerdyakov> Yes, in a way that's never been done before.
06:56:01 <Heffalump> if you really care, I'll be back in 2 hours or so
06:56:05 <shapr> Smerdyakov: many webservers exist ;-)
06:56:23 <Smerdyakov> i.e., being "a web server" isn't the point. I don't think Heffalump's software includes a new programming language and a compiler for it ;-)
06:56:44 <shapr> I think if Heffalump wants to do it, that's enough reason.
06:57:08 <shapr> if I wanted my coding efforts to have the greatest benefit for the world, I'd become a kernel janitor.
06:57:13 <Smerdyakov> Maybe so, but duplication of effort is one major thing holding free software back from having a complete viable set of tools/etc. for everyone.
06:57:26 <shapr> ML and Haskell have very little effect on the world compared to the Linux Kernel
06:57:46 <Smerdyakov> Not yet, shapr. They're very young, and we can all work to change the state of affairs.
06:58:03 <Smerdyakov> And they have very much effect on the world of research.
06:59:00 <Smerdyakov> I want to create a central web site soon for statically typed functional language advocacy aimed at the masses.
06:59:08 <shapr> http://haskell.org/wiki/wiki?WishList
06:59:17 <shapr> Smerdyakov: sounds good to me.
06:59:49 <Smerdyakov> Someone already found my ML advocacy page and added it to the Open Directory, to my surprise, since I only used it for avoiding repeating myself on IRC. =)
07:01:02 <Smerdyakov> I think it was because I said the URL on a channel whose logs are Googled.
07:01:44 <Smerdyakov> OK, off to spend 2 hours hearing about how to write OS's in C ;-)
07:01:49 <shapr> have fun
07:21:00 <shapr> hey jewel, I wrote some email stuff this weekend, tiny smtp support, and a partial rfc822 parser.
07:21:32 <jewel> cool
07:21:42 <jewel> remember the haskell mail agent?
07:21:55 <shapr> er, no?
07:22:00 <shapr> sounds vaguely familiar
07:22:24 <jewel> a project we started on the wiki ages ago
07:22:33 <shapr> oh that does sound familiar...
07:23:49 <shapr> aha
07:23:55 <shapr> http://haskell.org/wiki/wiki?HaskellMailClient
07:27:58 <SyntaxPolice> shapr: I have been wanting a very painless way to send a simple email to someone via my MTA or something. Does anything like that exist?
07:28:11 <SyntaxPolice> It could pipe something to mail int he backend or whatever.
07:28:23 <shapr> SyntaxPolice: yes, that exists
07:28:31 <shapr> lemme get the url...
07:28:40 <shapr> it's just what Smerdyakov has been suggesting
07:28:46 <shapr> it's a command line call to sendmail
07:28:53 <shapr> SyntaxPolice: or do you want win32 email sending?
07:29:01 <shapr> if so, then my SMTP.hs module is probably better.
07:29:27 <SyntaxPolice> shapr: win32? HAHWHAHAHA!
07:29:31 <SyntaxPolice> ;)
07:30:16 <shapr> should I take that to mean you're not running code on Win32?
07:33:06 <shapr> SyntaxPolice: http://www.cit.gu.edu.au/~arock/haskell/index.html
07:33:20 <shapr> his library of useful stuff includes SendMail.lhs
07:34:49 <SyntaxPolice> OK cool.
07:34:58 <SyntaxPolice> yeah, I'm not running code on Win32 :)
07:35:57 <shapr> jewel: well, if you're bored, we could continue with the MUA
07:36:27 <xkb_> Does anyone here have some simple code displaying the use of exceptions?
07:36:41 <shapr> xkb_: look in the examples in the ghc source
07:36:43 <xkb_> I only have really basic examples
07:36:44 <xkb_> k
07:36:44 <shapr> lots of good stuff in there
07:36:50 <xkb_> thanks
07:37:03 <shapr> I think the net examples have exception catching in them
07:59:20 <jewel> shapr: ok, we'll see what I get up to with my newly found free time
08:01:27 <shapr> fair enough
08:02:05 <jewel> I have become totally addicted to the board game 'go'
08:02:18 <jewel> and this takes up most of my spare time
09:34:22 <shapr> ouch
09:35:12 <Heffalump> bah
09:35:23 <Heffalump> does OFTC get all these splits at such regular intervals?
09:35:55 <shapr> I dunno
09:36:17 <shapr> wanna come up with an improved chat network that doesn't have splits? :-)
09:36:36 <shapr> irc has these problems by its very nature
09:36:42 <shapr> since it is a continuous connection
09:37:04 <shapr> ohoh, I know how to fix it
09:37:15 <shapr> IPv6 multicast addresses dedicated to chat channels.
09:38:00 <Heffalump> make IRC use a graph not a tree
09:38:07 <shapr> sounds good to me
09:38:16 <Heffalump> (tag messages with IDs to stop loops)
09:38:28 <shapr> ok, let's fix it :-)
09:42:21 <steele> hi
09:42:37 <shapr> hi steele 
09:49:28 <dark> Heffalump: That means the servers have to keep a history of messages, though.
09:50:01 <shapr> unless they're sequential, like tcp sequence numbers
09:50:11 <shapr> then you know when you have them all, right?
09:50:21 <dark> shapr: But you might not get them in order.
09:50:26 <shapr> you could use a sparse list to just keep the missing message
09:50:27 <shapr> s
09:50:51 <dark> Some of them you might not get at all, if the network is smart enough to only route to servers that have interested users.
09:51:00 <shapr> good point
09:51:03 <dark> Usenet has to deal with this same problem :)
09:51:14 <shapr> how do they do it?
09:51:34 <dark> And I think there were reports of "phantom messages" which are stuck in loops with such long propagation delays that the history files have been discarded by the time they come round again.
09:51:49 <dark> shapr: Usenet nodes keep a history of message ids.
09:51:52 <shapr> yow
09:52:01 <Heffalump> surely the path can be used to eliminate looping messages in usenet?
09:53:00 <dark> Heffalump: Hmm.  It should.  I don't know why that doesn't work :)
09:54:07 <shapr> I'm very much looking forward to IPv6 multicasting
09:54:19 <dark> I'm still looking forward to IPv6.
09:54:56 <Heffalump> I'm not, I'll never be able to remember IP addresses again
09:55:11 <dark> Though, we'll have to upgrade ghc's Network modules to support it :)
09:56:05 <shapr> Heffalump: some are simpler, ::1 for example
09:56:10 <Heffalump> true.
10:13:33 * shapr considers giving up on java for today and doing more haskell
10:25:51 <Heffalump> but I don't have trouble remembering 127.0.0.1 either :-)
10:26:29 <shapr> what are the class a, b, and c private addresses?
10:29:14 <shapr> I need to read up on ipv6
10:29:27 <shapr> in my cfp
10:33:21 <Heffalump> in IPv4 or IPv6 ?
10:34:02 <Heffalump> IPv4, 10.0.0.0/8 (1 class A), 172.16.0.0/12 (16 class Bs), 192.168.0.0/16 (256 class Cs)
10:34:20 <Heffalump> IPv6 doesn't have class A B and C afaik, so presumably you did mean IPv4
10:35:14 <shapr> yup
10:35:22 <shapr> I didn't remember class B private
10:36:24 <Heffalump> yeah, I had to look that up too :-)
10:36:40 <Heffalump> I like being able to just type "rfc 1918" into Mozilla and getting the answer, though
10:37:02 <shapr> :-)
10:37:07 * shapr tries that in galeon
10:37:22 <Heffalump> you need to configure it
10:37:26 <shapr> cute
10:37:29 <shapr> seems to be the default
10:37:35 <Heffalump> oh, really?
10:37:41 <shapr> yup
10:37:41 <Heffalump> I had to configure it in Mozilla.
10:37:50 <shapr> throws it to google
10:37:52 <Heffalump> what URL does Galeon go to?
10:37:53 <Heffalump> oh, right
10:38:07 <Heffalump> IM that I configured Mozilla to actually go to a specific URL for rfc n
10:38:16 <shapr> ah I see
10:38:20 <shapr> konq does that
10:38:23 <shapr> totally configurable
10:38:26 <shapr> I dunno about galeon
11:29:30 * shapr boings
11:30:17 <eivuokko> Happy? :)
11:30:26 <shapr> yes!
11:30:59 <eivuokko> What happened? :)
11:31:17 <shapr> I'm done with work for the day!
11:31:21 <shapr> I can write Haskell code now!
11:31:24 <shapr> yay!
11:31:28 <shapr> eivuokko: how are you?
11:31:38 <eivuokko> lol
11:31:51 <eivuokko> Fine, thank you.
11:31:57 <shapr> how's your study of Haskell going?
11:33:08 <eivuokko> Hmmm.  Nothing special, I guess.  Just playing with few bits every now and then.
11:33:27 <shapr> I hope I can finish my rfc822 parser today.
11:33:53 <eivuokko> :)
11:34:21 <shapr> any interesting bits today?
11:35:29 <eivuokko> Nah, I should read up on monads.  I just don't see what's so big in carrying state around.
11:35:37 <Heffalump> wdym by "big"?
11:36:12 <eivuokko> A lot of noise about them in haskell.org bookshelf.
11:36:27 <Heffalump> they're not just for carrying around state
11:36:29 <shapr> well, you know about referential transparency?
11:36:34 <eivuokko> I know.
11:37:17 <eivuokko> Heffalump, that's what they do, though.  Carry state to make sideeffects happen in order.
11:37:43 <shapr> that's just IO monads
11:37:46 <eivuokko> I code with c++ every day, c++ templates are really just a compiletime functional language.
11:37:47 <shapr> there's more!
11:38:11 <eivuokko> "Referential transparency" and carrying state are really common tricks.
11:38:29 <eivuokko> Or, rather transperncy causes interesting rules.
11:38:59 <eivuokko> So, I need to read up to see what's more in them?
11:39:15 <shapr> have you read meijer's monadic parser paper?
11:39:52 <eivuokko> Nope.  I've read nothing but few reallyu simple examples and the Monad stuff from report.
11:40:08 <Heffalump> eivukko: exceptions, nondeterminism; neither of these things are to do with carrying state
11:40:37 <eivuokko> But that how you implement them in haskell :)
11:40:57 <shapr> there's some immensely cool stuff that uses monad transformers to make modular interpreters.
11:41:23 <Heffalump> eivukko: sorry?
11:42:28 <eivuokko> I meant, you do implement exceptions in haskell with monads? :)
11:43:01 <Heffalump> errm, look for a reference, I cba to explain right now :-)
11:43:08 <eivuokko> Or rather catching them, I guess.
11:43:44 <eivuokko> Well, thx.  I'll see to it.
11:45:06 <eivuokko> I guess I'll look into exceptions first.
11:55:31 * shapr gives in and starts working on rfc822 parsing
11:56:15 <shapr> hey, does anyone know how to run HUnit tests in "main" ?
11:56:21 <shapr> I can't quite seem to get the types to match
11:58:25 <shapr> hm, my test function is IO Counts, and Counts is an instance of Show
11:59:46 <Heffalump> but?
12:00:17 <shapr> oh 
12:00:21 <shapr> I think I got it :-)
12:00:35 <shapr> main = do c <- t
12:00:35 <shapr>           putStr $ show c
12:00:49 * shapr bounces happily
12:00:57 <shapr> I think I'm really getting the hang of these monad thingies ;-)
12:02:40 <shapr> yay! it works!
12:02:41 <shapr> w00
12:05:28 <shapr> uh, now it doesn't work...
12:05:32 * shapr blinks confusedly
12:06:17 <shapr> doh, user error
12:07:24 <dark> "User error.  Replace user and reboot."
12:07:28 <shapr> heh
12:07:32 <shapr> hi dark, what's up?
12:08:06 <dark> Hello :)  Not much.  I've been playing Half-Life.
12:14:49 * shapr is persuaded to watch an episode of st:tng before more coding
12:14:51 <shapr> bbl
12:38:09 <SyntaxPolice> does anyone know of a web page summarizing the various GUI libraries for Haskell?
12:38:45 <Heffalump> the haskell mailing list archives? :-)
12:39:10 <SyntaxPolice> heh thats what I was afraid of.
12:39:41 <Heffalump> IM there was a discussion on this subject recently and they were all listed in one email
12:40:08 <SyntaxPolice> OK. THanks, I'll look.
13:43:28 <Janni> hi
13:43:58 <eivuokko> hi :)
13:44:01 <Janni> i have a (standard) problem of which i'm thinking i have already solved it some time ago, but forgot...
13:44:29 <Janni> i an infinite tree of the type "data Tree a = Node a [Tree a]"
13:44:32 <Janni> +have
13:45:03 <Janni> it is known to end in a finite depth with "Node _ []"
13:45:29 <Janni> and i would like to extract a list of all paths to every node
13:45:40 <Janni> how can i achieve that?
13:46:01 <Janni> more specific: to every terminating Node
13:46:11 <Smerdyakov> Janni, what
13:46:23 <Janni> ok, small example
13:46:23 <Smerdyakov> 's an easy way to divide up the possible paths from a given root?
13:46:27 <Smerdyakov> Nono, I understand
13:46:34 <Smerdyakov> Just hit <enter> when I didn't want to =)
13:46:55 <Heffalump> what is a path, a list of numbers?
13:47:07 <Janni> Effalump a list of "a"s
13:47:13 <Heffalump> "a"s??
13:47:18 <Heffalump> OIC.
13:47:37 <Janni> Heffalump: OIC? the "a"s from the generic data type definition
13:47:44 <Janni> data Tree a
13:47:47 <Heffalump> paths (Node a ts) = map ((a:) . paths) ts
13:47:49 <Marvin--> Janni: "Oh, I See"
13:48:11 <Janni> :)
13:48:31 <Marvin--> Heffalump: won't that always yield an empty list?
13:48:50 <Heffalump> oh yeah.
13:48:55 <Heffalump> minor details :-)
13:49:01 <Heffalump> it probably wants a concat too.
13:49:06 <Janni> Marvin--: no: "unification would give infinite type"
13:49:10 <Janni> Heffalump: yep
13:49:36 <Smerdyakov> Janni, did you mean "paths from the root that follow only child links" by "paths"?
13:49:59 <Marvin--> well, even with a concatMap... shouldn't paths (Node 3 []) be something like [[3]]?
13:50:05 <Heffalump> Marvin--: yes
13:50:14 <Heffalump> my code is just wrong, but it's not /that/ far off what you want :-)
13:50:23 <Marvin--> heh
13:51:09 <Janni> a bit pattern matching and it's solved.
13:51:22 <Janni> thx. i think i got it
13:51:32 <Smerdyakov> Janni, and my question..?
13:51:32 <Heffalump> paths (Node a ts) = [a]:concat (map ((a:) . paths) ts)
13:52:00 <Janni> Smerdyakov: didn't really understand :{
13:52:08 <Smerdyakov> Janni, you never said what a path was
13:52:38 <Smerdyakov> But if that
13:52:46 <Smerdyakov> 's the correct code, then it's clear =)
13:52:56 <Janni> Smerdyakov: every a on the path to the root
13:53:05 <Smerdyakov> The great thing is that if you can ever explain exactly what you mean by something like this, you already have the code written =)
13:53:19 <Smerdyakov> Janni, sorry, your recursive definition has no base case =) You can't use "path" to tell me what a "path" is.
13:54:23 <Janni> Smerdyakov: ok. if you start from the root element i want the list of all "a"s i meet when descending to every leaf (is that clear?)
13:54:44 <Heffalump> what is a leaf?
13:55:10 <Smerdyakov> Janni, maybe. It's hard to tell, since I already know what you meant. But the fact remains that if you could say exactly what you meant, in purely logical terms, you'd have the function written for you.
13:55:16 <Janni> Heffalump: in my case a Node with an a and an empty list
13:55:38 <Heffalump> ok, so my code is wrong
13:55:48 <Heffalump> paths (Node a []) = [a]
13:56:02 <Heffalump> paths (Node a ts) = concat $ map ((a:) . paths) ts
13:56:03 <Smerdyakov> Heffalump, that's what it does....
13:56:09 <Janni> yea. as i said: plus some pattern matching
13:56:14 <Smerdyakov> Oh
13:57:00 <Smerdyakov> What's $?
13:57:13 <Heffalump> low priority (in binding terms) function application
13:57:16 <Smerdyakov> O
13:57:17 <Heffalump> saves on the brackets :-)
13:57:29 <Janni> Heffalump: still not right. because i need the list of a list but i'll check myself (i need a bit longer)
13:57:35 <Heffalump> oh yes, sorry
13:57:40 <Marvin--> Heffalump: in this case you could've used a concatMap though
13:57:40 <Heffalump> [[a]] in the first case, yes
13:57:48 <Heffalump> Marvin--: I keep forgetting that exists
13:57:51 <Heffalump> but yeah.
13:58:04 <Marvin--> I thought the type was going to be Tree a -> [[a]]?
13:58:11 <Marvin--> paths (Node a []) = [[a]]
13:58:11 <Marvin--> paths (Node a ts) = map (a:) $ concatMap paths ts
13:58:19 <Heffalump> or ts >>= ((a:) . paths), but that's a tad obscure
13:58:28 <Marvin--> > paths (Node 3 [Node 4 [], Node 5 []])
13:58:28 <Marvin--> [[3,4],[3,5]]
13:58:40 <Heffalump> Marvin--: s'equivalent to mine...
13:59:34 <Marvin--> no, your function returns [3,4,3,5]
13:59:38 <Janni> Heffalump: no. his is correct (i just need too much time to understand)
13:59:43 <Heffalump> oh.
13:59:52 <Heffalump> so it does.
13:59:56 * Heffalump looks embarrassed
14:00:01 <Marvin--> heh
14:00:04 <Marvin--> don't take it too hard ;)
14:00:17 <Heffalump> I'll try to get over it :-)
14:00:27 <Janni> a yeah. i know, what my problem was. i somehow refused to think about the [[a]] and therfore got the infinite type error
14:01:23 <Marvin--> I find that it helps to think of the outer list as a set and the inner as a sequence...
14:01:41 <Smerdyakov> ... and how does that help?
14:02:22 <Marvin--> I get confused when there are several lists in lists and lists
14:02:27 <Marvin--> so I stop and think about what I really want
14:02:44 <Marvin--> "I want a set of paths. OK, what's a path? It's a sequence of a:s"
14:02:56 <Smerdyakov> So make an abstract multiset type that is really a list =)
14:03:40 <Marvin--> oh, when I've figured out what I *mean* I usually don't have a hard time coding it down in raw lists :)
14:27:11 * shapr boings
14:27:44 <Marvin--> hello shapr :)
14:27:57 * andersca writes mainloop code
14:28:23 <shapr> hiya Marvin-- 
14:28:25 <shapr> what's up?
14:28:30 <Pseudonym> G'day.
14:28:35 <shapr> hiii Pseudonym!
14:28:39 <shapr> how are ya?
14:28:44 <Pseudonym> Not bad, not bad.
14:28:48 <Pseudonym> Hell of a weekend, though.
14:28:53 <shapr> what happened?
14:28:55 <Pseudonym> Second hottest day on record for Melbourne.
14:28:58 <shapr> wow
14:29:01 <shapr> how hot?
14:29:06 <Pseudonym> Plus lots of smoke in the air from bushfires.
14:29:07 <Pseudonym> 44C
14:29:10 <shapr> wow!
14:29:19 <Heffalump> I thought they were mostly in NSW?
14:29:21 * shapr converts to F
14:29:24 <Heffalump> (obviously not)
14:29:56 <Pseudonym> The ones in NSW threatened the most people.
14:30:04 <shapr> 111.2 degrees F
14:30:11 <shapr> that's hotter than Birmingham, Alabama
14:30:13 <shapr> wow
14:30:17 <Pseudonym> The ones in Vic mostly threatened alpine resorts in the middle of summer.
14:31:33 <shapr> hey, I wrote most of an rfc822 parser over the weekend
14:31:39 <shapr> and a crappy smtp sender module
14:31:49 <shapr> Pseudonym: have you seen any email tools for Haskell?
14:31:54 <Pseudonym> Nope.
14:31:56 <Pseudonym> Haven't looked either,.
14:32:02 <shapr> hm, good reason
14:32:04 <shapr> :-)
14:32:15 * Pseudonym wonders if shapr is going to set himself up as a spamhaus
14:32:25 <shapr> nah, Haskell mail tools
14:32:52 <shapr> basically I want all the libs I've had in Python, but in Haskell
14:32:58 <shapr> and if I have to write them myself, so be it
14:33:12 <Pseudonym> Fair enough.
14:33:39 <shapr> I should stuff these libs into haskell-libs sf project
14:33:44 <shapr> hm
14:34:26 <Pseudonym> Has anyone produced any Haskell libraries for arrays of bits?
14:34:46 <shapr> I think I've heard of some
14:35:09 <Pseudonym> I have a suspicion that Haskell isn't the right tool for the bit fiddling that I want to do.
14:35:21 <shapr> what do you want to do?
14:35:38 <Pseudonym> Compressed inverted indexes.
14:36:14 * shapr doesn't know what those are
14:36:29 <Pseudonym> Oh.
14:36:30 <Pseudonym> Uhm...
14:36:34 <Pseudonym> Text indexing.
14:36:56 <Pseudonym> Think of a collection of documents, like a web site search engine or somethign.
14:37:09 <Pseudonym> How do you index it by word?
14:37:25 <shapr> suffix tries?
14:37:47 <Pseudonym> Yeah, that's the front end.
14:37:54 <Pseudonym> You need a mapping of word -> stuff.
14:37:59 <shapr> oh
14:38:07 <Pseudonym> The mapping isn't what I'm thinking off, it's the stuff.
14:38:19 <Pseudonym> In principle it's a list of document numbers.
14:38:41 <shapr> in reality...
14:38:42 <shapr> ?
14:38:54 <Pseudonym> In reality that can get quite unweildy.
14:39:00 <Pseudonym> You need to compress it.
14:39:09 <Pseudonym> My typing is really bad today for some reason.
14:39:21 <shapr> keyboard's melting =)
14:39:25 <Pseudonym> :-)
14:39:40 <shapr> I left one in the back window of my car when I drove from seattle to birmingham
14:39:43 <shapr> it really did melt.
14:39:56 <Pseudonym> The most obvious representation (list of n-bit integers) can easily get bigger than the document collection you're trying to index.
14:40:18 <shapr> hm
14:40:29 <Pseudonym> In addition, to do ranked queries, you also need the number of times the word occurs in each document.
14:40:33 <shapr> hmmm
14:40:41 <Pseudonym> So you need to compress it.
14:40:41 <Smerdyakov> Pseudonym, let's approximate that with 6
14:41:08 <shapr> Pseudonym: soo
14:41:11 <shapr> how do you do that?
14:41:42 <Pseudonym> Well, first, you don't store actual document numbers.  You store the difference between each document number and the previous one.
14:41:50 <shapr> that makes sense
14:42:14 <shapr> this reminds me of trellis compression that the usr modems did
14:42:15 <Pseudonym> Now let's suppose you know how many documents there are for each word.
14:42:23 <shapr> minicom compression
14:42:34 <Pseudonym> You can model that probabalistically.
14:43:01 <shapr> ok
14:43:17 * shapr runs out of coffee
14:43:20 <Pseudonym> If there are N documents in the collection and this term appears f times, then you expect each value stored to be about N/f.
14:43:54 <shapr> that makes sense
14:44:08 <Pseudonym> To a first approximation, values which are much bigger or smaller than that value are unlikely to occur.
14:44:23 <Pseudonym> So you can design a kind of Huffman code for that frequency distribution.
14:44:30 <shapr> that also makes sense
14:44:43 <shapr> pathological word ocurrence is unusual
14:44:43 <Pseudonym> I say "to a first approximation" because in fact this analysis is slightly bogus.
14:45:00 <shapr> how so?
14:45:08 <Pseudonym> If the documents are in some sort of order, word occurrence is _not_ random.
14:45:13 <shapr> oho
14:45:17 <Pseudonym> Consider, for example, a news feed.
14:45:21 <shapr> good point
14:45:30 <Pseudonym> The word "Regan" doesn't appear much nowadays.
14:45:31 <shapr> replies will have ocurrences of words in the original messages
14:45:37 <Pseudonym> The word is clustered around the 1980s.
14:45:42 <shapr> heh, neat !
14:46:10 <shapr> oh oh, this is related to the automatic document structure discovery code I've been thinking about
14:46:13 <Pseudonym> In a web site search engine you'd expect the same behaviour.  Words will be clustered around directories.
14:46:24 <shapr> that also makes sense
14:46:29 <shapr> though I had never of these things before
14:46:51 <shapr> er "thought"
14:47:19 <Pseudonym> Concordances were designed for works like the Bible or Shakespeare, and term occurrences are very highly clustered there.
14:47:30 <shapr> so you design your algorithm to handle word clusters gracefully
14:47:35 <Pseudonym> Yes.
14:47:41 <shapr> maybe sliding windows
14:47:46 <shapr> of adaptive size?
14:47:59 <Pseudonym> Kind of.
14:48:14 <Pseudonym> Would you like some of the details?
14:48:18 <shapr> and if these windows are actually branches on a tree
14:48:33 <shapr> and the beginning of a branch can say "this branch is different in these ways"
14:48:40 <Pseudonym> Kind of.
14:48:40 <shapr> then you have a single data structure you can look through
14:48:44 <shapr> hopefully efficiently
14:48:55 <shapr> yes, I would like some of the details
14:48:59 <Pseudonym> OK.
14:49:01 <shapr> do you teach computers classes? 
14:49:05 <Pseudonym> Nope.
14:49:08 <shapr> you should
14:49:12 <Pseudonym> I used to be a residential tutor.
14:49:15 <Pseudonym> Until last year.
14:49:25 <shapr> what's a residential tutor, vs a regular tutor?
14:49:54 <Pseudonym> Uh, you have to understand the Australian university system.  It's kind of like the US system and kind of like the UK system.
14:50:04 <Pseudonym> We have colleges attached to universities, but they're optional.
14:50:36 <Pseudonym> They're mostly a place to stay, but they also provide extra tutoring.
14:50:44 <shapr> oh, ok
14:51:02 <Pseudonym> So they're kind of half-way between UK colleges and US dorms/fraternities/sororities/whatever.
14:51:27 <Pseudonym> OK.
14:51:57 <Pseudonym> First thing you need to understand is binary coding.
14:51:59 <Pseudonym> Pretty easy.
14:52:35 <Pseudonym> If you have, say, 5 values to encode of equal probability, the Huffman code is fairly straightforward:
14:52:49 <Pseudonym> 000 001 01 10 11
14:53:10 <shapr> yah
14:53:11 <Heffalump> bah, use arithmetic encoding already :-)
14:53:16 <Pseudonym> The code will be betwqeen floor(log n) and ceil(log n) bits.
14:53:24 <Pseudonym> Heffalump: You can't.
14:53:37 <Pseudonym> I'll digress for a moment as to why.
14:53:40 <Heffalump> I wasn't paying any attention to the context.
14:53:45 <Pseudonym> Oh, OK. :-)
14:53:51 <Janni> isn't '\n' the newline character? doesn't work for me...
14:53:53 <Pseudonym> Then I won't digress.
14:53:55 <kawfee> woot
14:54:00 <kawfee> there are actually people in here
14:54:18 <Pseudonym> For some definition of "people".
14:54:22 <kawfee> yeah
14:54:26 <shapr> hi kawfee 
14:54:28 <kawfee> most of them I recognize from #lisp
14:54:31 <kawfee> hello sir
14:54:37 <shapr> learning Haskell?
14:54:38 <Pseudonym> There are LISPers here?!
14:54:41 <kawfee> would someone like to help me parenthesize an equation?
14:54:46 <Pseudonym> Persecute!  Kill the heretic!
14:54:48 <kawfee>  :  has precedence 1 and is right associative, % has precedence 2 and is left associative, given a : b : c % d % e : f % g % h  how would it look fully parenthesized
14:54:54 <kawfee> ( a : ( b : ( ( c % d ) % e ) : ( ( f % g ) % h) ) ) )
14:55:00 <shapr> kawfee: sounds like homework
14:55:05 <kawfee> that is what I think it would be, I just need to check
14:55:06 <kawfee> shapr: it is
14:55:21 <Pseudonym> I think you left one out.
14:55:24 <kawfee> shapr: I keep getting different answers everytime I try, but they seem to get better and better
14:55:29 <Pseudonym> b : stuff : stuff
14:55:29 <kawfee> I think I have the final solution
14:55:33 <Pseudonym> that bit isn't parenthesised
14:55:50 <shapr> yah, you're missing a paren according to emacs
14:55:58 <shapr> too many closing parens
14:56:35 <Pseudonym> Where were we?
14:56:36 <Pseudonym> Oh, yes.
14:56:39 <shapr> binary coding
14:56:42 <Pseudonym> Right.
14:56:46 <Pseudonym> Now consider unary coding.
14:56:46 <kawfee> (a : (b : (( ( c % d )  % e)  : (( f % g ) % h))))
14:56:47 <shapr> you were talking about huffman coding
14:56:48 <kawfee> how about that
14:56:53 <kawfee> I just checked it in an editor
14:57:03 <kawfee> sorry
14:57:05 <Pseudonym> See, the numbers you have to encode here are unbounded.
14:57:14 <Pseudonym> So you really need an infinite-symbol code.
14:57:20 <kawfee> talking about huffman trees?
14:57:29 <Pseudonym> kawfee: Kind of.
14:57:41 <kawfee> ya'll do haskell programming in here for beginners?
14:57:47 <Pseudonym> We're talking about inverted index compression.
14:57:52 <shapr> this makes me think of the lean left trees I've seen in the lapalme/rabhi book
14:57:56 <kawfee> I'm learning haskell this semester
14:58:05 <shapr> kawfee: sure, beginner, midlevel, expert, whatever
14:58:08 <shapr> this is all about haskell
14:58:13 <Pseudonym> We don't do homework, of course.
14:58:16 <shapr> right
14:58:16 <kawfee> such is life
14:58:26 <kawfee> right, I wouldn't ask you to do my homework, I like to learn
14:58:30 <Pseudonym> :-)
14:58:30 <Pseudonym> Sure.
14:58:44 <kawfee> as you can see from above, I already had it worked out, just not sure about the answer
14:58:49 <Pseudonym> Sure.
14:59:04 <Pseudonym> One thing yu might try doing in that case is to actually try it out.
14:59:08 <shapr> yah
14:59:27 <shapr> it's easy to declare operators and their precedence and associativity in Haskell
14:59:34 <Pseudonym> Define non-associative operators, type in the non-parenthesised and the parenthesised versions and see if they match.
15:00:09 <Pseudonym> So in this case, something like:
15:00:22 <kawfee> hrm
15:00:32 <kawfee> I just saw my first bit of haskell today
15:00:44 <Pseudonym> data Foo = Foo :: Foo | Foo :% Foo | F Char
15:00:45 <kawfee> I should install hugs on my home machine
15:00:54 <Pseudonym> Then define the precedences and associativities.
15:00:56 <Pseudonym> Then type:
15:01:10 <kawfee> installing now
15:01:14 <Pseudonym> F 'a' :: F 'b' :: F 'c' :% F 'd' {- etc etc -}
15:01:24 <Marvin--> except that "::" is kinda taken
15:01:25 <kawfee> hrm
15:01:26 <Pseudonym> Actually, :: won't work.
15:01:27 <Pseudonym> Yes.
15:01:32 <shapr> silly cvs question... with cvs_rsh=ssh, can I login and stay logged in for some length of time?
15:01:33 <kawfee> what does: data Foo = Foo :: Foo | Foo :% Foo | F Char
15:01:33 <Pseudonym> ::: would work.
15:01:35 <kawfee> mean?
15:01:40 <shapr> or do I need to type my password for each transaction?
15:01:52 <Pseudonym> shapr: You could try using the ssh agent.
15:01:58 <shapr> er, oh
15:02:05 <shapr> good point
15:02:06 <Marvin--> shapr: ssh agent and a dsa key
15:02:13 <kawfee> ERROR - Syntax error in expression (unexpected keyword "data")
15:02:15 <shapr> Marvin--: works for sf.net also?
15:02:22 <Pseudonym> kawfee: You need to put that in a script.
15:02:26 <kawfee> ahhh
15:02:26 <Pseudonym> It's defining a data type.
15:02:37 <Pseudonym> Try this instead:
15:02:44 <kawfee> how do you quit hugs?
15:02:46 * shapr tries putting his public key on sf.net
15:02:49 <shapr> kawfee: :q
15:02:52 <shapr> should work
15:02:54 <kawfee> thanks
15:02:55 <Marvin--> shapr: hmm...good question, you'll need to put the public key in the authorized_keys file on the target machine, and I that's possible with sf cvs...
15:02:56 <Pseudonym> data Foo = Foo `C` Foo | Foo `P` Foo | F Char
15:03:02 <Pseudonym> C == Colon, P == Percent
15:03:07 <Marvin--> shapr: with "'m not sure" before "that's" ;)
15:03:12 <Pseudonym> It is possible.
15:03:23 <shapr> Marvin--: yah, I agree.
15:03:42 * Marvin-- ponders what else to see on the festival
15:03:43 <shapr> I like to check in after every five or so new unit tests work
15:04:03 <shapr> cuz then I have something to jump back to if I find a blind alley
15:04:07 <Marvin--> maybe an Iranian movie?
15:04:28 <shapr> is there some simpler way to do regular cvs check-ins to sf.net without having to type in my password everytime?
15:04:29 <Marvin--> oh, Lilja 4-ever...gotta see that one even though it's scary
15:04:36 <shapr> that's a silly question probably....
15:04:36 <kawfee> I still don't know what data Foo = Foo :: Foo | Foo :% Foo | F Char
15:04:36 <Pseudonym> If you go to your "account options" page on sf, down the bottom is a section on CVS/SSH shared authorized keys.
15:04:37 <kawfee>  means
15:04:47 <Marvin--> Pseudonym: ah, nice
15:04:51 <shapr> Pseudonym: oh, I hadn't seen that, thanks...
15:04:52 <Pseudonym> Which festival?
15:04:54 <Marvin--> kawfee: you can define infix constructors
15:04:55 * shapr goes to try it
15:05:02 <Marvin--> Pseudonym: Göteborg Film Festival
15:05:17 <shapr> hey, another silly question
15:05:28 <shapr> is there any way to demote a project admin to developer?
15:06:19 <kawfee> hugs iusn't very user friendly
15:06:49 <shapr> it's just picky about its friends
15:06:54 * shapr repeats that old tired joke
15:06:58 <kawfee> heh
15:07:03 <shapr> kawfee: are you an emacs or vi user?
15:07:05 <kawfee> I never heard it
15:07:06 <shapr> or other?
15:07:06 <kawfee> emacs
15:07:10 <shapr> ah, excellent
15:07:13 <kawfee> yes, very
15:07:15 <shapr> haskell-mode r0xx0rs
15:07:18 <kawfee> I've coded in scheme before
15:07:22 <kawfee> xemacs?
15:07:25 <shapr> yup
15:07:27 <kawfee> or emacs?
15:07:27 <shapr> I'm using ERC Version 3.0 $Revision: 1.405 $ with XEmacs 21.4 (patch 11) "Native Windows TTY Support" XEmacs Lucid!
15:07:29 <kawfee> hrm
15:07:30 <shapr> e) all of the above
15:07:32 <kawfee> let me start er um
15:07:34 <kawfee> up
15:08:28 <shapr> I'm a fan of emacs.
15:09:35 <kawfee> how do I pick haskell mode in emacs?
15:09:38 <kawfee> I am as well
15:09:44 <kawfee> It's the editor of all editors
15:09:55 <kawfee> M-x haskell
15:09:57 <kawfee> nothing
15:09:59 <shapr> kawfee: try opening a haskell file
15:10:02 <kawfee> I did
15:10:05 <kawfee> hmwk1.lhs
15:10:08 <shapr> ok, then M-x haskell-mode
15:10:10 <Pseudonym> Cool, editor flamewar!
15:10:15 <kawfee> Pseudonym: hah
15:10:20 * Pseudonym is a vim user
15:10:21 <whee> hooray! count me in
15:10:23 * whee also uses vim
15:10:33 <kawfee> no match
15:10:33 <shapr> Pseudonym: is that where we burn editors, and see who has bigger flames?
15:10:43 <kawfee> do I need the haskell plugin or something?
15:10:45 <shapr> oh, no matches, I guess we can't burn anything
15:10:46 <Pseudonym> Vim is actually an editor, rather than a poor excuse for a command shell.
15:10:49 <kawfee> heh
15:10:51 <kawfee> lol
15:10:57 * Marvin-- is also a vim user
15:11:01 <shapr> Pseudonym: bah, eshell is excellent
15:11:03 <shapr> :-P
15:11:12 <Pseudonym> I have a magnifying glass and it's a bright sunny day.
15:11:12 <kawfee> you can open bash under emacs!
15:11:19 <shapr> kawfee: haskell-mode may be separate
15:11:22 <Pseudonym> Yes, but why would you want to?
15:11:23 <shapr> you using linux?
15:11:28 <SyntaxPolice> kawfee: if you're not in haskell-mode you may need to install it.
15:11:35 <Pseudonym> That's what multiple windows or virtual consoles are for.
15:11:40 <kawfee> SyntaxPolice: where?
15:11:40 <shapr> truly, eshell lets you arbitrarily mix elisp and shell scripting
15:11:55 <Pseudonym> Eek.
15:11:55 <kawfee> I've got it defined in my .emacs file to go to haskell mode when opening a .lhs file
15:11:57 <shapr> much better than bash
15:11:59 <Pseudonym> That's what Perl is for. :-)
15:12:17 <shapr> Pseudonym: no, perl is for arbitrarily mixing line noise and insanity ;-)
15:12:24 <SyntaxPolice> kawfee: you shouldn't have to tell your .emacs file about .lhs files, haskell-mode should do that for you.
15:12:30 <SyntaxPolice> so M-x haskell-mode failed?
15:12:34 <Pseudonym> BTW, before we go any further, I have a can here labelled "worms".  Does anyone have a can opener?
15:12:40 * shapr laughs
15:12:45 <shapr> Pseudonym: ok ok, good point
15:12:50 <shapr> we can all agree that we like haskell
15:12:54 <shapr> and that's why we're here.
15:12:55 <Pseudonym> Absolutely.
15:12:57 <whee> Pseudonym: see, if you were using emacs you'd have one :)
15:12:59 * Pseudonym nods seriously
15:13:02 * shapr laughs
15:13:03 <kawfee> SyntaxPolice: .emacs is loaded when emacs runs and it tells what mode to go into
15:13:04 * Pseudonym laughs
15:13:21 <Marvin--> time to sleep
15:13:25 <kawfee> (if first-time
15:13:25 <kawfee>     (setq auto-mode-alist
15:13:25 <kawfee>           (append '(("\\.cpp$" . c++-mode)
15:13:25 <kawfee>                     ("\\.hpp$" . c++-mode)
15:13:25 <kawfee>                     ("\\.lsp$" . lisp-mode)
15:13:28 <kawfee>                     ("\\.scm$" . scheme-mode)
15:13:30 <kawfee>                     ("\\.pl$"  . perl-mode)
15:13:31 <SyntaxPolice> if you happen to use Debian GNU/Linux (unstable), then you can run "apt-get install haskell-mode" otherwise, you can get the file from http://www.haskell.org/haskell-mode/
15:13:35 <shapr> kawfee: SyntaxPolice is the maintainer of the haskell-mode package for debian
15:13:35 <kawfee>                     ) auto-mode-alist)))
15:13:51 <kawfee> ahh kewl
15:13:57 <kawfee> what's the package name?
15:14:04 <kawfee> apt-cahce
15:14:07 <shapr> ((clue SyntaxPolice) > 1) == True
15:14:13 <Marvin--> SyntaxPolice: do you know how far away alex is from being integrated with happy?
15:14:14 <SyntaxPolice> kawfee: yes. I understand that.  However, you shouldn't need to do this, at least for haskell mode, and probably not for several others. Maybe it depends on the version of emacs you're using?
15:14:37 <SyntaxPolice> Marvin--: well... depends on what you mean by integrated :) I'm really not sure what to do with it I guess, but you can download them togehter and they work well together.
15:14:52 <SyntaxPolice> Marvin--: sorry I never got back to you about that state stuff (that was you,right?) but I'm pretty sure you can't do that in Alex.
15:14:52 <kawfee> installing
15:14:58 <Pseudonym> Real programmers write their own lexical analysers by hand.
15:15:03 <kawfee> SyntaxPolice: yeah I guess, the way emacs starts for me is how it is set up
15:15:06 <shapr> speaking of which...
15:15:07 <Marvin--> SyntaxPolice: I was going to package the bnf converter, but thought that it didn't really make sense unless I packaged alex too...
15:15:10 <Marvin--> SyntaxPolice: err...no :)
15:15:15 <shapr> Pseudonym: have you written any Parsec parsers?
15:15:21 <kawfee> ahh nice colors
15:15:28 <Pseudonym> Nope.
15:15:30 <shapr> kawfee: you using color-theme?
15:15:33 <kawfee> how can you make it automagically start with a >
15:15:38 <kawfee> shapr: it is now
15:15:45 <Pseudonym> I've used happy, though.
15:15:46 <kawfee> no colors until that plugin loaded
15:15:52 <shapr> if it's an .lhs file, C-c > will 'literate' a region
15:15:59 <shapr> aka, add little birdy tracks on the left
15:16:03 <Marvin--> SyntaxPolice: I've never used alex, but seeing as I will be using the bnf converter, I might as well package them both
15:16:05 <SyntaxPolice> Marvin--: since Alex is included w/ Happy, you can make your bnf converter depend on Happy. but I don't know actually if that change has made its way to Debian yet.
15:16:11 <kawfee> ERROR "hmwk1.lhs":3 - Syntax error in declaration (unexpected `;', possibly due to bad layout)
15:16:19 <shapr> oh, he doesn't like you.
15:16:20 <Pseudonym> And I've written this monstrosity:
15:16:25 <Pseudonym> http://andrew.bromage.org/Dfa.lhs
15:16:33 <Marvin--> SyntaxPolice: ah, it's included with happy, nice... but no, the Debian happy package doesn't include alex
15:16:49 <kawfee> Pseudonym: did that declaration work for you?
15:16:53 <SyntaxPolice> Marvin--: I guess that is because they have not made a new release of Happy since I added Alex.
15:16:54 <Marvin--> SyntaxPolice: And I don't need depends, the bnf converter just generates an .x file, so I was going to Suggest alex, happy and stuff
15:17:07 <SyntaxPolice> Marvin--: I see. I thought you were saying that the bnf converter used Alex.
15:17:08 <shapr> Pseudonym: that looks scary.
15:17:10 <Pseudonym> kawfee: I didn't try it.
15:17:24 <Marvin--> SyntaxPolice: maybe I did, but in that case I lied ;) it generates .x and .y files (among other things)
15:17:26 <Pseudonym> shapr: It's actually a very efficient regular expression -> DFA converter.
15:17:40 <Pseudonym> It uses a far more efficient algorithm than, say, lex.
15:17:41 <Marvin--> SyntaxPolice: but it doesn't really make sense to use the bnf converter unless you have alex handy as well
15:17:43 <shapr> Pseudonym: is it faster than the standard regex lib?
15:17:50 <Pseudonym> Based as it is on algebraic data types.
15:17:58 <Pseudonym> shapr: It's different.
15:18:01 <SyntaxPolice> Marvin--: I think I understand... can you tell me more about the bnf converter?
15:18:03 <Pseudonym> regex != regular expression
15:18:15 <shapr> one of these days I have to take a computer class or something...
15:18:17 <Pseudonym> In particular, regular expressions don't have the parenthesis operators.
15:18:26 <Pseudonym> For extracting substrings.
15:18:39 <shapr> I'm still missing lots of theory.
15:18:42 <Marvin--> SyntaxPolice: written by Aarne Ranta and Markus Forsberg... I just closed galeon but I think the url is www.cs.chalmers.se/~markus/bnfc/ or something like that... there's probably a link from /~markus/
15:18:51 <kawfee> Pseudonym: says who?
15:18:56 <kawfee> reg expr
15:19:08 <kawfee> grep is for get regular expression
15:19:18 <Pseudonym> kawfee: The POSIX regex is only loosely based on real regular expressions.
15:19:22 <shapr> I thought it was global regular expression parser
15:19:25 <Pseudonym> It uses the same notation.
15:19:27 <kawfee> who cares about POSIX?
15:19:33 * Pseudonym laughs
15:19:35 <shapr> kawfee: the POSIX committee?
15:19:42 <kawfee> I don't even know what POSIX is
15:19:45 <shapr> oh
15:19:58 <Pseudonym> They're really quite different in their purposes.
15:19:58 <Marvin--> SyntaxPolice: but I guess I could package alex for now and drop it when a new happy is released
15:20:09 <kawfee> isn't is a standard of some sort
15:20:10 <Marvin--> but now...sleep
15:20:19 <shapr> Marvin--: I'd be flat out excited to see the bnf converter in unstable
15:20:20 <Pseudonym> Night.
15:20:22 <SyntaxPolice> Marvin--: I would suggest harassing the happy people to release a new version of happy rather than upload an Alex package.
15:20:25 <shapr> g'night Marvin-- 
15:20:42 <Marvin--> SyntaxPolice: might be a good idea
15:20:43 <SyntaxPolice> Marvin--: by the way, how are you intending to solve some of the various problems w/ compiling haskell libraries for different compilers.
15:20:55 <SyntaxPolice> or you could create happy-cvs :)
15:20:59 <shapr> I've had the same question...
15:21:00 <kawfee> Pseudonym: couldn't I just change the associativity and operator table in haskell?
15:21:09 <Pseudonym> Sure you could.
15:21:21 <shapr> I think some of the cross-compiler Haskell packages should be able to support GHC and more
15:21:23 <Pseudonym> The thing is, though, you need somehting that's type correct as well./
15:21:23 <shapr> but how?
15:21:53 <shapr> sounds like it's time to start a debian-haskell mailing list
15:21:56 <SyntaxPolice> shapr: yeah, this question has been driving me nuts for weeks.
15:22:00 <shapr> then we can argue like the python-debian and emacs-debian lists
15:22:25 <SyntaxPolice> shapr: thats not a half bad idea really. I"ve been mulling over sending a flame to Haskell@haskell.org about the difficulty of creating 3rd party libraries.
15:22:30 <shapr> SyntaxPolice: we could do the smart thing... ask on haskell@haskell.org and see what comes out of the resulting mess of Simon PJ and A. Reid duking it out.
15:22:44 <Pseudonym> :-)
15:22:54 <shapr> plus, we could sell popcorn on the sidelines and make a profit.
15:22:58 <kawfee> > left, 9: %
15:22:59 <kawfee> > right, 8: #
15:23:04 <kawfee> that should work for defining the ops
15:23:12 <SyntaxPolice> I think there is some promise in hmake, but I don't know... 
15:23:13 <kawfee> hrm, but that would eval them
15:23:35 <SyntaxPolice> shapr: that is a good idea. I would buy popcorn to watch people fight about haskell and debian.
15:23:35 <shapr> many of the haskell mailing list people have very strong personalities.
15:23:41 <Pseudonym> I can see John Hughes not saying how he wants it done, but being very, very insistent about a bad detail like it's the end of the world.
15:23:42 <shapr> the [GUI] list has been hopping lately
15:24:26 <shapr> Axel Simon(?) wants to use gtk2hs (he wrote it) and Daan Leijen wants a platform independent api (and really wants to use Ports on HToolkit, both of which he wrote)
15:24:48 <Pseudonym> I'm so glad I didn't join in there.
15:24:59 <SyntaxPolice> I noticed that fight.
15:25:04 <shapr> Personally, I want to use HTk and put the independent api on top of it.
15:25:11 <shapr> then everyone will be convinced the widgets suck
15:25:16 <shapr> and we can get on with the api =)
15:25:17 <kawfee> how can I mkae hugs like me?
15:25:19 <Pseudonym> I want an independent API like ObjectIO.
15:25:25 <shapr> yah, I agree
15:25:32 <SyntaxPolice> I just sent Axel Simon an email about license problems in gtk2hs, and as it turns out gtk+hs... the tarball says its LGPL but all the files say tha tthey're GPL.
15:25:34 <Pseudonym> kawfee: Do you have a small rodent to sacrifice?
15:25:40 <shapr> kawfee: M-x turn-on-haskell-hugs
15:25:46 <kawfee> Pseudonym: I'm sure I could find one
15:25:48 <shapr> then hit C-c C-l in your haskell source buffer
15:25:55 <kawfee> hrm
15:26:16 <shapr> kawfee: does that help?
15:26:24 <Pseudonym> Then type C-f M-e S-6 i k C-z M-w.  Should set you up nicely.
15:26:28 <shapr> SyntaxPolice: yah, lGPL is important for my also.
15:26:40 <Pseudonym> Emacs would be so much easier on a space cadet keyboard.
15:26:41 <shapr> Pseudonym: you're not sposed to know about that command unless you're in the inner circle!
15:26:46 <kawfee> hrm
15:26:47 <kawfee> nice
15:26:49 <kawfee> but no
15:26:54 <kawfee> I already had most of that
15:27:06 <kawfee> what does turn-on-haskell-hugs
15:27:08 <kawfee>  do?
15:27:10 <shapr> Pseudonym: I'll have to sic RMS on you now.
15:27:10 <Pseudonym> Oh, that's right.  That's the sequence that invokes Cthulu, isn't it.
15:27:25 <SyntaxPolice> shapr: I get the feeling that it can be fixed w/ some changes to the source files, but I'm not so sure about the license for c2hs which gtk2hs uses.
15:27:25 <shapr> Pseudonym: no, just hastur, hast-URK
15:27:42 <shapr> Pseudonym: even worse, RMS might come to your house.
15:27:44 <shapr> that would suck.
15:27:45 <SyntaxPolice> kawfee: you can read the description of haskell-mode by hitting "H-m" in a haskell file, and it will explain the turn-on thing.
15:27:48 <Pseudonym> It would.
15:27:57 <shapr> as much as I like emacs I really don't like RMS.
15:27:58 <kawfee> the problem is when I want to run the script I get errrors
15:28:05 <Pseudonym> He'd drink up all my herbal tea and leave even more beard hairs in the shower.
15:28:08 <kawfee> ahh
15:28:30 <Pseudonym> I don't like RMS either, but I concede he is necessary.
15:28:36 <Pseudonym> The world needs zealots.
15:28:45 <SyntaxPolice> kawfee: so C-c C-l loads the file in hugs (M-p will load it in ghci if you have that installed) and then if hugs gives you errors, you can tell us about them.
15:28:49 <kawfee> % must already be defined
15:28:53 <Pseudonym> Yes.
15:29:02 <Pseudonym> It does the same job as C's %.
15:29:03 <shapr> let me rephrase that... (like emacs) :: Integer (dislike RMS) :: Integer ((like emacs) == (dislike RMS))
15:29:31 <dark> And these are Integers?
15:29:38 <shapr> dark: they wouldn't fit into Int
15:29:40 <kawfee> bah
15:29:46 <kawfee> I'll go with what I had
15:29:48 <Pseudonym> ircConversation :: Sublime -> Ridiculous
15:29:51 * shapr laughs
15:30:05 <dark> Pseudonym: I must have idled through the Sublime part :)
15:30:25 <SyntaxPolice> shapr: so if you create a haskell-debian list, I'll join. I've heard that packaing tons of lisp stuff did wonders for the lisp community.
15:30:29 <Pseudonym> OK.
15:30:32 <Pseudonym> ircConversation :: Maybe Sublime -> Ridiculous
15:30:34 <Pseudonym> That better?
15:30:44 <shapr> SyntaxPolice: I'm not a debian developer, but I'll see what I can do.
15:30:54 <shapr> I know many DDs
15:31:00 <SyntaxPolice> shapr: and maybe someone can figure out a build system that will be sane.
15:31:09 <shapr> truly
15:31:09 <SyntaxPolice> shapr: well, I was thinking more on the haskell side htan the debian side actually.
15:31:13 <shapr> oh
15:31:14 <Pseudonym> How did the Lisp people do it?
15:31:22 <SyntaxPolice> @haskell.org rather than @debian.org :)
15:31:27 <SyntaxPolice> Pseudonym: I wish I knew :)
15:31:34 <Pseudonym> Maybe we should ask them.
15:31:37 <SyntaxPolice> Pseudonym: but elisp does have several of the same problems.
15:31:39 <Pseudonym> We're all functional programmers here.
15:31:51 <SyntaxPolice> Pseudonym: yeah, why cna't we all just get along and use emacs?
15:31:52 <shapr> I don't know if I have any influence over mailing lists @haskell.org, but I can ask their mailmain admin.
15:31:56 * Pseudonym laughs
15:32:17 <Pseudonym> Emacs :: Lisp as Miranda :: Haskell
15:32:18 <SyntaxPolice> shapr: it was your idea :)
15:32:37 <shapr> SyntaxPolice: it was?
15:33:04 <kawfee> what's a tree snapshot?
15:33:08 <shapr> SyntaxPolice: I thought you came up with it. In any case, it's a good idea, I'll ask them to start one.
15:33:15 <SyntaxPolice> <shapr> I think some of the cross-compiler Haskell packages should be able to support GHC and more
15:33:15 <SyntaxPolice> <Pseudonym> The thing is, though, you need somehting that's type correct as well./
15:33:15 <SyntaxPolice> <shapr> but how?
15:33:15 <SyntaxPolice> <-- Marvin-- has quit ("Linux - the choice of a GNU generation")
15:33:15 <SyntaxPolice> <shapr> sounds like it's time to start a debian-haskell mailing list
15:33:24 <SyntaxPolice> :-)
15:33:36 <shapr> hm, so it was.
15:33:42 <shapr> neat! I had a good idea!
15:33:45 * shapr bounces happily
15:33:54 <kawfee> SyntaxPolice: what language did you write haskell mode in?
15:33:56 <kawfee> lisp?
15:34:06 <SyntaxPolice> shapr: but in any case, a list like that would probably have lots of postings from me.
15:34:16 <shapr> ok
15:34:20 <SyntaxPolice> kawfee: I didn't write Haskell-mode, I think Simon Marlow did, but its written in Elisp (emacs lisp)
15:34:29 <SyntaxPolice> I just packaged it for Debian.
15:34:32 <kawfee> you're just the maintainer?
15:34:33 <kawfee> oh
15:34:34 <kawfee> ok
15:34:37 <SyntaxPolice> well. I didn't even do that. I just took over the debian package :)
15:34:41 <kawfee> heh
15:34:52 <SyntaxPolice> but I did close several bugs.
15:35:01 <kawfee> I wonder what would happen to debian if all the maintainers died
15:35:22 <shapr> kawfee: I would become president of Debian, and appoint new maintainers.
15:35:30 * shapr dreams on...
15:35:30 <kawfee> hah
15:35:34 * Pseudonym notes that he wasn't talking about debian with his "type correct" comment
15:35:40 <kawfee> I don't think Deb and Ian would like that
15:35:55 <shapr> I don't think either of them are still there.
15:35:56 <SyntaxPolice> Pseudonym: yeah, sorry I coppied that too.
15:35:58 <Pseudonym> Hang on, doesn't Python have some kind of recompilation system which kicks in when the bytecode format changes?
15:36:03 <shapr> Pseudonym: yes.
15:36:08 <Pseudonym> We'd need that too.
15:36:17 <shapr> we would
15:36:29 <Pseudonym> Speaking of debian developers...
15:36:44 <shapr> that's a feature of python
15:36:50 <SyntaxPolice> I can see a source package which installs and then gets recompiled when you update the compiler.
15:36:51 <shapr> I wish it were a feature of GHC
15:36:59 <SyntaxPolice> That is a little lame... but it works
15:37:00 <Pseudonym> I know a debian developer, one of the first in Australia to distribute debian CDs, who now works for the principal .NET evangelist of Microsoft Corporation.
15:37:05 <shapr> SyntaxPolice: that's what emacs does.
15:37:07 <SyntaxPolice> but we'd have to alter the packages for all the compilres.
15:37:12 <shapr> Pseudonym: very scary
15:37:18 <Pseudonym> career: Sublime -> Ridiculous
15:37:32 <shapr> Pseudonym: sounds like you've found a Monad
15:37:38 <Pseudonym> Yes.
15:37:47 <Pseudonym> I may well have.
15:38:00 <shapr> SyntaxPolice: yes, that happens already for emacs packages.
15:38:06 <Pseudonym> The Life monad.
15:38:18 <shapr> you should have seen the crap fly when I tried to install preview-latex with xemacs
15:38:27 <SyntaxPolice> if hmake had some sort of registration system where packages can register themselves to be recompiled when a new compiler gets installed or something, that might be cool.
15:38:34 <Heffalump> Tony Hoare used to go around asking people to exchange monads with him, apparently.
15:38:43 <Pseudonym> SyntaxPolice: Yes, Python does that I believe.
15:38:47 <shapr> same for various packages from cedet.sf.net, they were packaged for gnu emacs, not xemacs.
15:38:53 <Heffalump> SyntaxPolice: or get your packaging system to handle it with dependencies
15:38:54 <shapr> Heffalump: neat!
15:39:34 <shapr> right now, both python and emacs use /usr/share/<name>/site-packages/<package-name>
15:39:47 <SyntaxPolice> Heffalump: my packaging system, meaning Debian or the hmake thing I'm talking about?
15:39:54 <shapr> but that doesn't always work, because some packages only work on one flavor/version/etc
15:40:14 <SyntaxPolice> (for some reason hmake seems like the way to go since it can be used w/ ghc and nhc and has some nice configuration options, but I don't yet see how it would all fit together)
15:40:18 <shapr> so then you have /usr/share/xemacs/21/site-packages (I think)
15:40:28 <shapr> SyntaxPolice: I agree, hmake is necessary
15:40:39 <Pseudonym> I think it would be reasonable to only package portable libraries this way.
15:40:42 <shapr> too bad marvin-- went to sleep, he could help
15:40:49 <Pseudonym> Where "portable" is a variable concept.
15:41:04 <shapr> iirc, ghc5 isn't as portable as debian.
15:41:05 <SyntaxPolice> it would be nice if all 3rd party library developers used hmake :)
15:41:06 <Pseudonym> You want vanilla H98 on the one hand and -fglasgow-exts on the other.
15:41:18 <SyntaxPolice> shapr: yeah, I can't use ghc5 on my debian sparc machine.
15:41:32 <shapr> oh, also... I think there are some packages that will only work with -fglasgow-exts
15:41:42 <Pseudonym> Yes, but that's still portable with the latest Hugs.
15:41:47 <SyntaxPolice> Pseudonym: but some of the packages I want to use  are not portable. Most of them work w/ ghc and hugs, though. 
15:41:48 <Pseudonym> In theory.
15:41:49 <shapr> are there any packages that won't work with the extended switches turned on?
15:42:05 <Pseudonym> I don't know of any.
15:42:11 <Pseudonym> It's possible of course.
15:42:24 <Pseudonym> e.g. using "exists" as a function name
15:42:29 <Pseudonym> Sorry, "forall".
15:43:04 <shapr> good point.
15:43:24 <Pseudonym> But I don't know of any libraries which do this.
15:43:36 <Pseudonym> They're pretty much all tested with ghc.
15:43:38 <SyntaxPolice> hmm... I will be probably hacking on this library stuff this week, we should all talk more. I'm interested in 1. a sane way to package Haskel libraries for Debian, and 2. how to distribute 3rd party libraries in a way that makes them portable.
15:43:53 <Pseudonym> I'd be happy to set up an unofficial mailing list if you want.
15:44:01 <shapr> sounds good to me
15:44:21 <SyntaxPolice> sure. otoh, it may be that we could get a haskell-debian@haskell.org list set up almost as fast.
15:44:33 <Pseudonym> I can do it in about 30 seconds. :-)
15:44:46 <Pseudonym> I agree that a more official list would be a good idea.
15:44:47 <shapr> though I can't figure out who at haskell.org to email with that mailing list request....
15:44:55 <SyntaxPolice> hehe. up to you. 
15:45:07 <Heffalump> SyntaxPolice: Debian
15:45:12 <Pseudonym>  haskell-admin@haskell.org
15:45:14 <Pseudonym> That's who you ask.
15:45:14 <shapr> oh
15:45:16 <SyntaxPolice> shapr: simon marlow I think. he seems to maintain a lot of the lists @haskell.org. You could tell him that I can maintain this one though.
15:45:24 <SyntaxPolice> or you can if yuo want. whatever.
15:45:43 <shapr> SyntaxPolice: quick, make up your mind what you prefer :-)
15:45:45 <Pseudonym> I vote SyntaxPolice as admin since he's already a debian developer.
15:45:50 <shapr> I agree.
15:46:00 <shapr> all in favor...
15:46:01 <SyntaxPolice> Heffalump: yeah. I guess we've been over this a bit, but the problem is that whenever you change versions of a compiler, youd' ahve to chagne the depends line for all packages.
15:46:04 <SyntaxPolice> hehe
15:46:05 <SyntaxPolice> I'll do it :)
15:46:08 <shapr> yay
15:46:11 <SyntaxPolice> I can send the mail too if you'd rather.
15:46:20 <Pseudonym> Hey, less work for the rest of us.
15:46:21 <shapr> I'm not picky :-)
15:46:24 <shapr> sure, good point
15:46:31 <shapr> SyntaxPolice: ok, this is now your responsibility.
15:46:37 <SyntaxPolice> shapr: OK fine :)
15:46:43 <SyntaxPolice> it was your idea, though. I'll have you know.
15:46:45 <Pseudonym> I think haskell-admin@haskell.org is the place to ask.
15:46:46 <shapr> haha
15:47:03 <SyntaxPolice> Pseudonym: that goes to the list admin for haskell@haskell.org.
15:47:05 <shapr> SyntaxPolice: if you need any help, assistance, etc, I'll do what I can.
15:47:10 <SyntaxPolice> shapr: OK.
15:47:14 <Pseudonym> Right, which is at least a place to ask. :-)
15:47:54 <shapr> I do think a sane way to package Haskell libs for debian will shake out something useful for the haskell community in general
15:48:20 <SyntaxPolice> I guess technically, i should mail mailman-owner@haskell.org
15:48:21 <Pseudonym> I agree.
15:48:32 <Pseudonym> That sounds like a good idea.
15:49:53 <SyntaxPolice> anyone want CC'd on this email, /msg me with your email address :)
15:50:17 <shapr> I just want to know how to subscribe once the list is operational.
15:50:31 <Pseudonym> Well I assume there will be some sort of announcement on haskell@
15:50:55 <shapr> or we could co-opt libraries@ which just isn't doing much.
15:51:14 <Pseudonym> Imagine the fun once we start packaging the Official Haskell GUI Library(tm).
15:51:27 <SyntaxPolice> heh
15:51:34 <Pseudonym> We can merge most of the flamewars into one.
15:52:53 <SyntaxPolice> yeah, maybe there are too many little sub-communities after all.
15:53:16 <shapr> well, let's pick something
15:53:27 <Pseudonym> I think that the debian list is a good idea because it's relatively separate.
15:55:29 <SyntaxPolice> OK I sen the mail :)
15:55:36 <shapr> yay!
15:56:24 <SyntaxPolice> see, since there's a ghc bug that makes my program crash all the time, I have about a week to Do Something Else :) Including digging up information about building GUIs in Haskell and finding out a sane wway to build Debian packages.
15:56:46 <SyntaxPolice> OK I'm going to go home now.  Talk to you all soon :)
15:56:53 <shapr> cya
15:56:58 <SyntaxPolice> peace.
15:57:28 <Pseudonym> Farewell.
16:05:11 * shapr finds the sourceforge public key thingy
16:05:25 <shapr> is dsa or rsa better to use?
16:05:29 <shapr> does it make any difference?
16:06:54 <Heffalump> someone claimed RSA is better, but I don't know why really.
16:07:35 <Pseudonym> I use DSA, personally.
16:08:33 <Smerdyakov> Heffalump, you don't know what metric of betterness he used, or you just don't know how to justify the claim?
16:08:47 <Heffalump> I know neither
16:08:59 <Heffalump> oh, no, sorry, the metric was security.
16:09:13 * shapr shrugs and picks one at random
16:09:34 <Smerdyakov> I think both are completely unproven to be secure at all =)
16:10:10 <Heffalump> he claimed there was more evidence DSA was insecure
16:10:17 * Pseudonym shrugs
16:10:20 <Pseudonym> DSA has been around longer.
16:10:36 <Pseudonym> I wonder what evidence this would be.
16:10:47 <Pseudonym> DSA is as hard to crack as the discrete log problem.
16:11:02 <Pseudonym> Whereas RSA is as hard to crack as the minimum of prime factoring and the discrete log problem.
16:11:34 <Pseudonym> Unless there is some very weird specific flaw.
16:12:14 <Heffalump> I have no particular evidence to suggest that the person in question knew what he was talking about.
16:12:22 <Pseudonym> Fair enough.
16:12:32 <Pseudonym> I don't actually understand how DSA works.
16:12:35 <Heffalump> so given what you just said, I'd tilt back towards favouring DSA
16:12:39 <stepcut> personally, I use RSA because R comes after D, so it must be better
16:12:55 <Pseudonym> I use DSA because it was introduced in SSH 2.
16:13:03 <Pseudonym> I figure there was a reason for introducing it.
16:13:29 <Pseudonym> Now for PGP, there are definite reasons to choose DSA.
16:13:43 <Heffalump> well, the obvious reason might be just to provide choice
16:13:46 <Pseudonym> It can't be used for an encryption key, which is actually a strength.
16:14:20 <Pseudonym> For SSH, I don't think there's a compelling argument either way.
16:14:50 <Pseudonym> It's not like someone is going to come along with a tcpdump of your session and demand your SSH key.
16:15:00 <whee> hey, you never know :)
16:15:04 <Pseudonym> True.
16:15:10 <Heffalump> well, they could, but SSH will hopefully have thrown it away by then
16:15:16 <stepcut> http://www.der-keiler.de/Newsgroups/comp.os.linux.security/2002-06/1159.html
16:16:16 <Pseudonym> That sounds about right to me.
16:16:33 <Pseudonym> Though the "faster" aspect doesn't really apply in the case of SSH.
16:16:44 <Pseudonym> Authentication happens once, then the rest is symmetrically ciphered.
16:16:48 <stepcut> yeah
16:16:54 <Pseudonym> It's an O(1) cost.
16:17:19 <Pseudonym> Actually, now that I think about it, RSA is indeedcheaper.
16:17:26 <Pseudonym> Although creating a DSA key is quicker.
16:19:10 <Pseudonym> SInce you don't have to find large pseudo-primes.
16:25:13 <Smerdyakov> But I did anyway!
16:33:32 <shapr> yargh, I can't stand working in gnome nowadays.. back to ion
16:34:25 <stepcut> "The number one thing people want to do on their computer is run software."
16:36:21 <Pseudonym> And in other news: The number one thing people want to do with language is communicate.
16:36:29 <shapr> really?
16:37:12 <stepcut> its a quote from a recent staff meeting
16:37:17 <Pseudonym> I see.
16:37:35 <Pseudonym> Was the rest of the meeting as content-free as that?
16:38:24 <Pseudonym> People want to run software.  And we make software.  Good coincidence, that.
16:39:14 <shapr> yup
16:39:50 <shapr> silly question...
16:40:01 <shapr> what should I do with all these rfc822 bits once I have them parsed?
16:40:23 <Pseudonym> You need some kind of data structure to hold the parsed information, I would think.
16:40:26 <shapr> should I build a Message datatype or record with each of these small pieces inside of it?
16:40:44 <shapr> so, should it be a record with a gazilling pieces, or more like ASN.1, smaller subtypes?
16:41:11 <shapr> oh, I've forgotten the various three letter codes.
16:41:16 <shapr> Pseudonym: do you have them documented on your website?
16:42:15 <Pseudonym> Sorry, which codes?
16:42:31 <shapr> XXX, YYY, ZZZ
16:42:35 <Pseudonym> Nope.
16:42:48 * Pseudonym has never written them down
16:42:55 <Pseudonym> But roughly speaking, they're in order of severity.
16:43:04 <Pseudonym> ZZZ is very severe.
16:43:16 <shapr> right now, I have YYY is "possible improvement"
16:43:18 <Pseudonym> XXX is not so severe.
16:43:22 <shapr> XXX is "needs fixing"
16:43:23 <Pseudonym> OK.
16:43:35 <shapr> oh, and ZZZ means segfault waiting to happen?
16:44:11 <shapr> any other codes you use?
16:44:36 <Pseudonym> Not really.
16:44:41 <shapr> ok, thanks.
16:44:42 <Pseudonym> ZZZ's must be fixed before checking in.
16:44:54 <shapr> hm, ok.
16:44:57 <shapr> I like that.
16:45:23 <Pseudonym> XXX's signify known issues, such as missing functionality or failing unit tests.
16:45:30 <shapr> makes sense.
16:45:38 <shapr> I rarely check in with failing unit tests.
16:45:39 <Pseudonym> YYY's are general improvements.
16:45:42 <shapr> only when I'm about to fall over.
16:45:44 <Pseudonym> I do occasionally.
16:45:59 <Pseudonym> If I write unit tests first, then they often fail during development.
16:46:12 <shapr> I write a test, then the code to fill it in
16:46:18 <Pseudonym> Right.
16:46:28 <shapr> do you write high level tests that take a lot of smaller test/code cycles to finish?
16:46:30 <shapr> that could be useful
16:46:48 <shapr> doesn't work so well in Haskell because I don't always know the types ahead of time
16:46:57 <shapr> hm, probably shouldn't matter.
16:47:22 <shapr> I wish I could figure out how to merge unit testing and quickcheck testing.
16:47:23 <Pseudonym> I tend to write two kinds of tests in Haskell.
16:47:29 <Pseudonym> Actually three.
16:47:33 <shapr> what are they?
16:47:38 <Pseudonym> One is known test cases.
16:47:42 <shapr> yah
16:47:46 <Pseudonym> The second is randomised quickCheck-style tests.
16:47:48 <shapr> yah
16:47:56 <Pseudonym> The third is testing structural invariants.
16:48:01 <shapr> huh?
16:48:12 <Pseudonym> So, for example, if I'm writing a binary search tree, I write code which tests that the tree is well-formed.
16:48:28 <shapr> doesn't that fit into QC tests?
16:48:38 <Pseudonym> That keys to the left of the node are less-than, and that it's balanced.
16:48:43 <Pseudonym> And so on.
16:48:49 <Pseudonym> Well yes.
16:48:53 <shapr> I'd put that into the QC category
16:49:06 <shapr> "condition that should always be satisfied"
16:49:12 <Pseudonym> I use them in both of the above kinds of situations, though.l
16:49:26 <shapr> yah, makes sense
16:49:34 <Pseudonym> I use quickCheck to create random data structures, then test them for well-formedness.
16:49:34 <shapr> I'd really like to integrate both into my code.
16:49:47 <shapr> how can you do QC-first coding?
16:49:50 <Pseudonym> I've found that QuickCheck and the like don't work well with modularity.
16:49:53 <shapr> I just can't figure that out.
16:49:58 <shapr> really?
16:50:04 <Pseudonym> Yes.
16:50:11 <shapr> can you give me an example?
16:50:13 <Pseudonym> I need to export another function which tests well-formedness.
16:50:30 <Pseudonym> Or expose enough of the innards so that QC can test it.
16:50:50 <shapr> ime, unit testing pushes my api into a good shape for the same reason
16:50:51 <Pseudonym> The thing is that QC needs access to more than the module's interface in general.
16:50:55 <shapr> oh
16:51:01 <shapr> oh I see
16:51:02 <Pseudonym> Or so I've found.
16:51:04 <shapr> that makes sense.
16:51:06 <shapr> in that case
16:51:17 <shapr> QC tests should probably be in the same file with the code
16:51:35 <shapr> though that's not so true of unit tests.
16:51:45 <Pseudonym> You need to strike a balance.
16:51:58 <Pseudonym> For example, in TernaryTrie, I only needed to expose this:
16:52:09 <Pseudonym> structuralInvariantFM :: (Show k, Ord k) => FM k a -> Bool
16:52:12 <Pseudonym> That was enough.
16:52:51 <Pseudonym> Now admittedly this is a kind of a special case.
16:52:56 <shapr> maybe QC tests should always use the established interface.
16:53:11 <Pseudonym> For a library, you don't want to bog down client code with your internal stuff.
16:53:19 <Pseudonym> For unit tests for an application, things are easier.
16:53:34 <shapr> hm
16:53:49 <Pseudonym> If you expose some internals, it's not so serious
16:54:01 <shapr> I'll think about that.
16:54:09 <Pseudonym> If you expose internals in a library, the problem is that people might rely on those internals.
16:54:18 <Pseudonym> No matter how strongly you tell them not to.
16:54:26 * Pseudonym recalls libc5
16:54:34 <shapr> good point.
16:54:59 <Pseudonym> Now admittedly, the libc5 problem was not because of exposed internals.
16:55:25 <Pseudonym> But it just goes to show that if you write something that people use, people will rely on it.
16:55:36 <Pseudonym> Therefore you should write something clean.
16:56:25 <shapr> on the other hand
16:56:28 <Pseudonym> Exposing a single function which tests well-formedness seems like a good compromise to me.
16:56:37 <Pseudonym> In theory, structuralInvariant _ = True
16:56:39 <shapr> it's also good to write something dirty rather than nothing at all
16:56:44 <shapr> imho
16:56:44 <Pseudonym> For a non-buggy implementation.
16:56:48 <Pseudonym> Oh, absolutely.
16:56:53 <Pseudonym> For your own code, especially.
16:57:03 <Pseudonym> I'm talking specifically here about libraries intended to be libraries.
16:57:23 <shapr> I think it's also true for libraries.
16:57:32 <Pseudonym> Perhaps.
16:57:32 <shapr> nothing < dirty < clean
16:57:38 <Pseudonym> Yeah, I guess so.
16:57:55 <Pseudonym> There's a reason my version of Edison isn't in hslibs, though.
16:57:59 <shapr> why?
16:58:04 <Pseudonym> The interface is different.
16:58:08 <shapr> oh
16:58:09 <Pseudonym> And it ain't stable yet.
16:58:30 <Pseudonym> I don't want to break other peoples' code.
16:58:51 <shapr> but there's already an Edison
16:59:03 <shapr> so you're going for clean now, yes?
16:59:27 <Pseudonym> Yes.
16:59:32 <Pseudonym> I don't like Edison's interface.
16:59:44 <Pseudonym> For a start, it wouldn't support TernaryTrie.
16:59:52 <Pseudonym> You need fundeps for that.
17:00:14 <Pseudonym> So I'm going the whole hog and requiring -fglasgow-exts
17:01:10 <Pseudonym> I've gone through about six iterations of the facade system so far.
17:01:19 <Pseudonym> I think I know what I want now.
17:01:51 <shapr> I still don't know much about Edison.
17:01:55 <shapr> I'll get there at some point.
17:02:21 <Pseudonym> OK, one of the design principles behind Edison (and it's a good one, IMO) is that all data structures provide all operations.
17:02:43 <Pseudonym> For example, C++ STL stacks don't support peering down below the top element of the stack.
17:02:50 <shapr> suckage
17:03:01 <shapr> you have to take them apart yourself, and rebuild them?
17:03:04 <Pseudonym> Well, the thing is, stacks don't need to support that operation.
17:03:09 <shapr> oh
17:03:11 <Pseudonym> No, if you need that, you use a list or a vector.
17:03:44 <Pseudonym> Edison's philosophy is that all data structures support all operations.  Some of them might be bloody inefficient, but they're there.
17:04:09 <shapr> who comes up with the list of operations?
17:04:12 <Pseudonym> The reason is, Chris Okasaki found himself not knowing in advance which data structure he needed.
17:04:36 <Pseudonym> You start off thinking you need a simple list, then you find yourself needing O(log N) random lookup.
17:05:01 <Pseudonym> Oh, the list of operations are all the standard ones for each kind of data structure.
17:05:19 <Pseudonym> The "sequence" abstraction, for example, provides left-cons, right-cons, left-tail, right-tail, append and so on.
17:06:11 <Pseudonym> So they support all the operations for lists, queues, stacks, deques, catenable deques and so on.
17:06:26 <Pseudonym> Because it is possible to append two stacks, it's just very inefficient.
17:07:50 <shapr> sounds useful 
17:07:54 <Pseudonym> Right.
17:08:01 <shapr> I like that principle.
17:08:07 <Pseudonym> Right.
17:08:10 <Pseudonym> This is a good idea.
17:08:15 <Pseudonym> Except for one problem.
17:08:28 <Pseudonym> There is no "stack" data type.
17:08:45 <Pseudonym> Because every sequence data structure supports the operations you'd want for "stack".
17:08:52 <Pseudonym> Instead, in Edison, you pick the data structure by name.
17:09:31 <Pseudonym> So instead, you use "ListSeq" or "BraunSeq" or "MyersStack".
17:10:11 <Pseudonym> Not only is this bad to program (assuming you don't know what operations are efficient on a Braun sequence), it's bad if you want Edison to be a standard library.
17:10:38 <Pseudonym> Because you want to be able to replace your algorithms and data structures with more efficient ones as they are invented.
17:11:00 <shapr> that makes sense.
17:11:11 <Heffalump> why not just make an interface layer
17:11:14 <Pseudonym> Besides, you don't want C++ STL-style error messages.
17:11:25 <Pseudonym> Heffalump: That's precisely what I'm doing.
17:11:29 <Heffalump> ah :-)
17:11:32 <shapr> yah, at the top of my file, I say "Stack = ListSeq"
17:11:42 <shapr> how are you doing the interface layer?
17:11:45 <Pseudonym> But it took about six iterations to get the interface layer looking half right.
17:12:00 <shapr> how do I choose which stack implementation I'm using?
17:12:05 <shapr> should I go look at the docs :-)
17:12:14 <Pseudonym> Well using my scheme, you don't.
17:12:29 <Pseudonym> You import Stack and use operations like push, top and pop.
17:12:38 <Pseudonym> However, there's also a type class:
17:12:39 <Pseudonym> class (Sequence s) => AsSequence t (s a) | t -> (s a) where
17:12:39 <Pseudonym>     asSequence :: t -> s
17:12:59 <Pseudonym> Then if you need the more advanced operations, you use asSequence to get at the underlying sequence.
17:13:08 <shapr> hm
17:13:21 <Pseudonym> Sorry, also:
17:13:34 <Smerdyakov> Does the | introduce a type synonym bound in the class member types?
17:13:34 <Pseudonym> class (Sequence s) => AsSequence t (s a) | t -> (s a) where
17:13:42 <Pseudonym>     asSequence :: t -> s a
17:13:46 <Pseudonym>     toSequence :: s a -> t
17:14:04 <Pseudonym> Smerdyakov: No, it's a functional dependency.
17:14:53 <shapr> looks like fun reading
17:15:02 <shapr> I've not dealt with library writing before.
17:15:20 <Pseudonym> I think this is the right thing to do.
17:15:26 <Pseudonym> But I'm not sure.
17:15:58 <Smerdyakov> Pseudonym, what does it mean? O_o
17:16:04 <Pseudonym> Edison had a lot of good ideas in it, but I'm trying to work out good idioms for complex standard libraries.
17:16:29 <Pseudonym> Smerdyakov: http://haskell.org/wiki/wiki?FunDeps
17:19:26 <Smerdyakov> Oh. It all comes together =)
17:26:22 <shapr> I can't figure out where in rfc822 it says anything about requiring a space after the colon in a field name
17:30:56 <Smerdyakov> What do y'all think: does any language with a pure functional fragment of reasonable size earn the moniker "functional"?
17:33:12 <Pseudonym> We've discussed this before.
17:33:28 <Pseudonym> My opinion is that every language has one or two "dominant paradigms".
17:34:08 <Pseudonym> A language might support functional programming, but it's not a "functional language" unless that's the dominant paradigm.
17:34:16 <Pseudonym> We discussed this earlier in the context of Python.
17:34:30 <Pseudonym> Python has, according to those in the know, good support for functional programming.
17:34:34 <Smerdyakov> Just wondering how Common Lisp is "functional" =)
17:34:36 <Pseudonym> But it's an object oriented language.
17:35:17 <Pseudonym> Common Lisp is functional because just about everything is a function, functions are first-class objects and so on.
17:35:22 <shapr> truly, I can often write extremely FP code in Python.
17:35:30 <Pseudonym> Sure.
17:35:45 <Pseudonym> But you wouldn't call it a functional language.
17:35:48 <shapr> I agree.
17:36:01 <shapr> it explodes when I get too recursive.
17:36:07 <Pseudonym> I can write OO code in Perl, but I wouldn't call it an OO language.
17:36:26 <Pseudonym> It is a procedural language with support for OO design.
17:37:09 <Pseudonym> Common Lisp, IMO, is a functional language with support for procedural programming.
17:37:24 <Pseudonym> It's far easier to write functional Lisp than procedural Lisp.
17:37:32 <Pseudonym> But you can if you want to/have to.
17:37:42 <lament> "functional language" means nothing.
17:37:55 <lament> You can attach some meaning to "OO language"
17:38:15 <lament> e.g. a language with first-class objects and language-level support for inheritance and polymorphism.
17:38:34 <lament> But I don't see how you can define a "functional language", especially in a way that would exclude Python.
17:39:15 <Pseudonym> In Python, everything is an object.
17:39:20 <shapr> is happy with deep recursion?
17:39:36 <Pseudonym> In Haskell, everything is a function.
17:39:45 <Pseudonym> To a zeroth approximation.
17:39:48 <lament> shapr: is lisp?
17:40:00 <shapr> lament: I would assume so.
17:40:07 <lament> I wouldn't.
17:40:14 <lament> And it's not.
17:40:36 <Smerdyakov> To someone used to strict functional languages, everything in Haskell looks like a function without much approximation needed at all ;)
17:40:53 <lament> shapr: Besides, it's an implementation feature.
17:40:59 <Pseudonym> Well, an integer isn't a function.
17:41:03 <lament> shapr: Stackless Python has tail recursion and unbounded recursion otherwise
17:41:04 <Pseudonym> That's what I meant. :-)
17:41:46 <Pseudonym> But my main point is that in Python, functional programming is not the dominant paradigm.
17:41:47 <Smerdyakov> Pseudonym, an integer isn't represented as a suspension that always returns a constant value?
17:41:58 <Smerdyakov> [represented at runtime]
17:42:03 <lament> Pseudonym: so, while an OO language is defined in terms of what features it has, a functional language is defined in terms of features it doesn't have?
17:42:09 <Pseudonym> Perhaps, but that's not what the language says.
17:42:15 <Pseudonym> lament: No, I disagree.
17:42:16 <lament> Pseudonym: I.e. if you remove classes from Python, it will become a functional language?
17:42:35 <Pseudonym> I don't know what removing classes from Python would make it look like.
17:42:41 <dark> lament: More like a non-functional language :)
17:42:49 <shapr> lament: for me personally, functional language means "has referential transparency"
17:42:52 <Pseudonym> I don't think of C++ as an object oriented language.
17:42:58 <shapr> so I'm probably not a good person to discuss this with.
17:43:03 <Pseudonym> Despite the fact that it has enough features.
17:43:03 <dark> shapr: I think that would exclude Scheme.
17:43:03 <lament> shapr: that's "purely functional" :)
17:43:13 <lament> Pseudonym: no, C++ doesn't have enough features
17:43:14 <shapr> dark: yup
17:43:19 <shapr> lament: like I said...
17:43:22 <Pseudonym> C++ is a procedural language with support for OO programming.
17:43:27 <Smerdyakov> Pseudonym, I know it doesn't _say_ that, but to an ML user, that's the way things appear at first.
17:43:29 <Pseudonym> Actually, most people say C++ has too many features.
17:43:39 <lament> Pseudonym: It doesn't have enough _OO_ features
17:43:49 <Pseudonym> It depends what you need.
17:44:06 <Pseudonym> Personally, I think that C++ hits a "sweet spot" as far as programming languages go.
17:44:10 <shapr> lament: how else can you tell them apart?
17:44:29 <Pseudonym> It's the best multi-paradigm language you're going to get subject to the constraint that you need backwards compatibility with C.
17:44:32 <lament> shapr: tell whom apart?
17:44:39 <lament> shapr: "Purely functional" is a great term
17:44:40 <shapr> lament: fp and non-fp languages.
17:44:45 <lament> shapr: while "functional" has no meaning
17:45:02 <lament> shapr: I'd be happy to use "functional" the way you do, but that's not the meaning Pseudonym implies
17:45:02 <shapr> I know that I like referential transparency
17:45:17 <Smerdyakov> I think "functional" is very helpful in describing languages like ML.
17:45:30 <shapr> it's not referentially transparent, though, is it?
17:45:32 <Pseudonym> And Erlang, too.
17:45:42 <Pseudonym> Erlang and ML are not referentially transparent.
17:45:44 <Smerdyakov> I'm not sure how to properly specify it, except that the imperative features are few and orthogonal to each other and the rest of the features.
17:46:06 <Pseudonym> See, here's a problem that I have with geek semantics:
17:46:13 <Pseudonym> These definitions should not be binary.
17:46:22 <lament> Pseudonym: they don't have to be binary!
17:46:28 <lament> Pseudonym: but they bloody well should be _well-defined_
17:46:55 <whee> I think erlang would be the hardest to place into one of these definitions
17:46:57 <Pseudonym> There's a continuum between pure functional on the one hand and "has functions" on the other.
17:47:24 <dark> Wouldn't "doesn't have functions" be the other end?
17:47:31 <whee> since you don't get functions as first class unless you use the fun(X) -> blah. syntax
17:47:34 <Pseudonym> I think that a functional language is one which is closer to the "pure functional" end than it is to anything else.
17:47:42 <Pseudonym> dark: Possibly.
17:47:50 <lament> that's not a very good definition :)
17:48:00 <lament> Besides, a language doesn't need to have functions to be referentially transparent.
17:48:04 <Pseudonym> Maybe not, but I don't see of anything else that makes sense.
17:48:11 <Pseudonym> lament: This is true.
17:48:21 <Smerdyakov> Pseudonym, what about logic languages?
17:48:22 <lament> Pseudonym: yes, which is why i propose not to use the term "functional language"
17:48:23 <Pseudonym> Mercury was referentially transparent before it had functions.
17:48:31 <lament> Pseudonym: since it's absolutely meaningless
17:48:38 <Pseudonym> I don't think it's meaningless.
17:48:43 <lament> then define it :)
17:48:48 <Pseudonym> Wittgenstein wouldn't think it was meaningless either.
17:48:57 <lament> then ask Wittgenstein to define it for you.
17:49:03 <Pseudonym> OK, lament, let me try you on something.
17:49:08 <Pseudonym> To digress for a moment.
17:49:17 <Pseudonym> This will illustrate what I mean.
17:49:19 <Pseudonym> What's a "game"?
17:49:40 <Pseudonym> Your definition should include board games, card games, the Olympic games, war games and mind games.
17:50:02 <Pseudonym> Also, game theory.
17:50:10 <whee> what about hunting game :)
17:50:11 <lament> yes, the word game is not well-defined (apart from game theory)
17:50:24 <Pseudonym> "Game" in the sense of prey doesn't count.
17:50:31 <Pseudonym> Yes it is well-defined.
17:50:32 <lament> However programming terms, IMHO, can be well-defined.
17:50:34 <Pseudonym> We can spot a game when we see one.
17:50:43 <Pseudonym> Most of the time.
17:50:52 <lament> since CS is a branch of math :)
17:50:59 <Pseudonym> There might be some cases on the border which we can't tell.
17:51:14 <Pseudonym> Wittgenstein actually wrote a paper on the question of what is a "game".
17:51:19 <lament> Pseudonym: "we can spot a game when we see one" is pretty much the opposite of well-defined
17:51:20 <Pseudonym> That's why I brought him up.
17:51:33 <Pseudonym> No, because I haven't actually said how we define "game" yet.
17:51:51 <Pseudonym> We do have a meaningful definition.  "Game" is a prototype class.
17:51:52 <lament> right, and until you haven't, it's not well-defined
17:52:05 <lament> it's intuitively defined
17:52:09 <Pseudonym> It's based on having some thing sthat we know are "games" and comparing them.
17:52:13 <Pseudonym> We know that chess is a game.
17:52:27 <Pseudonym> So go, for example, is a game because it's like chess.
17:52:27 <lament> the problem with intuitive definitions is that different people's definitions differ.
17:52:51 <lament> And they always will differ until the term is well-defined.
17:52:52 <Pseudonym> Whist is a game, so bridge is a game because it's like whist.
17:53:23 <lament> For example, I can consider python to be a functional language, because the term "functional language" is not well-defined. Noone can stop me.
17:53:38 <lament> Python is a functional language because Python is like Haskell.
17:53:49 <Pseudonym> But Python isn't like Haskell.
17:53:53 <Pseudonym> It's more like Smalltalk.
17:53:58 <lament> Pseudonym: and Go is like chess?
17:54:01 <lament> heh.
17:54:02 <Pseudonym> Sure it is.
17:54:03 <Smerdyakov> Let's just put up a page now that lists all functional languages, chosen by an expert committee, and settle this once and for all!
17:54:07 <Smerdyakov> It can be updated once a year.
17:54:07 <lament> Pseudonym: You are mad :)
17:54:15 * stepcut is not convinced the 'card game war' is actually a game
17:54:34 <whee> stepcut: I spent years mastering that game.
17:55:04 <Pseudonym> Go is like chess.  It uses a board and pieces and two people take turns to move, it's a full-knowledge system and so on and so forth.
17:55:18 <lament> Pseudonym: that's really silly.
17:55:23 <Pseudonym> I don't think so.
17:55:27 <lament> You should.
17:55:36 <Pseudonym> Most English words actually make more sense when you consider them this way.
17:55:38 <stepcut> i once wrote a program, so you could play war against the computer. But all you did was press enter -- which was annoying. So then I added 'auto-play' mode so that you didn't have to press enter
17:55:40 <lament> Python is like haskell, it's a formal system, it's turing-complete, etc
17:55:54 <stepcut> but then it just ran and told you if you won or lost
17:56:11 <stepcut> it was very anti-climatic
17:56:23 <Pseudonym> Sure, Python is like Haskell in that sense.  They're both programming languages.
17:56:30 <lament> Pseudonym: did you read the stuff I said a minute ago?
17:56:31 <Pseudonym> "Programming language" is another prototype class.
17:56:35 <Pseudonym> Sure I did.
17:56:43 <lament> <lament> the problem with intuitive definitions is that different people's definitions differ.
17:57:05 <Pseudonym> I agree, but I only think it's a problem in corner cases.
17:57:26 <lament> Pseudonym: the problem there is that "corner cases" is an intuitively-defined term itself
17:57:43 <lament> Pseudonym: for example, I certainly think Python is a corner case. You probably don't :)
17:57:44 <Pseudonym> See, what I think you're after is something like this:
17:57:54 <Pseudonym> functional :: Language -> Bool
17:57:58 <Pseudonym> English doesn't work like that.
17:58:10 <lament> No, English doesn't.
17:58:12 <lament> Math does.
17:58:15 <lament> Programming is math.
17:58:24 <shapr> nuhuh
17:58:30 <lament> Which is why we can have a nice clear definitions of terms like "turing-complete"
17:58:36 <shapr> programming is not math.
17:58:37 <lament> s/ a //
17:58:37 <Pseudonym> Deciding what paradigm a language falls into is not maths.
17:58:40 <shapr> programming is magic.
17:58:42 <stepcut> in high school I would have consider programming to be a game
17:58:47 <lament> shapr: Magic, too, is math.
17:59:16 <Pseudonym> Where is the borderline between "programming" and "software engineering"?  That's not maths.
17:59:22 <shapr> lament: read up on Goedel :-)
17:59:25 <Pseudonym> Where is the borderline between "debugging" and "testing"?
17:59:29 <lament> Fine, programming isn't math.
17:59:36 <Pseudonym> Writing programs is maths.
17:59:38 <Smerdyakov> lament, HEH!
17:59:40 <Smerdyakov> er
17:59:42 <lament> Computer science is math. Study of formal system is math. Languages are formal systems.
17:59:42 <Smerdyakov> lament, HEY!
17:59:44 <kawfee> Pseudonym: there isn't one
17:59:46 <Pseudonym> Deciding what categories to put languages into usually isn't.
17:59:47 <Smerdyakov> Programming is so math :P
17:59:49 <lament> s/system/systems
17:59:59 <Pseudonym> Human languages are NOT formal systems.
18:00:03 <Pseudonym> Formal languages are formal systems.
18:00:05 <kawfee> lament: CS is more than that
18:00:09 <shapr> truly
18:00:12 <lament> Pseudonym: Python is not a human language.
18:00:18 <Pseudonym> I don't think it is, no.
18:00:23 <shapr> kawfee: I'm afraid to ask how #haskell compares to #lisp ;-)
18:00:25 <Pseudonym> It's certainly not a natural language.
18:00:30 <kawfee> none of the programming languages are human languages
18:00:31 <whee> isn't syntax a form of human language?
18:00:39 <shapr> programming is an unnatural act anyway....
18:00:45 <Pseudonym> I agree.
18:00:49 <kawfee> shapr: which net?
18:00:55 <shapr> kawfee: dunno
18:00:59 <Pseudonym> Maybe I shouldn't have said "human language".
18:01:02 <shapr> kawfee: just idly wondering
18:01:04 <Pseudonym> I think I meant "natural language".
18:01:06 <kawfee> shapr: OPN usually has a better crowd
18:01:21 <lament> Pseudonym: There must be always a clear distinction between well-defined math stuff and fuzzy natural-language stuff. Once the distinction is made, I'll stop arguing the fuzzy side. :)
18:01:26 <kawfee> shapr: ask me again in a few days
18:01:33 <shapr> kawfee: ok
18:01:35 <Pseudonym> I agree with you there.
18:01:41 <kawfee> I'll have to see how much nonsense you speak in here
18:01:49 <shapr> probably lots.
18:02:02 <shapr> you should hear me talk about monads.
18:02:04 <lament> Pseudonym: However, I think well-defined math stuff is good and should be always used instead of fuzzy stuff if at all possible - especially in areas like Programming.
18:02:12 <kawfee> how about gonads?
18:02:21 <Pseudonym> You say that the term "functional" is meaningless.  I say it's fuzzy.
18:02:25 <kawfee> define fuzzy stuff
18:02:26 <lament> Fine.
18:02:29 <Pseudonym> I think that's what it boils down to.
18:02:29 <lament> Then I'll stop arguing it :)
18:02:32 <Pseudonym> :-)
18:02:43 <Smerdyakov> lament, do you have an example of a concrete incarnation of programming language that isn't well defined mathematically?
18:02:43 <Pseudonym> I think that "object oriented" is fuzzy too.
18:02:47 <kawfee> functional has meaning
18:02:54 <Pseudonym> Of course it has meaning.
18:02:57 <kawfee> object oriented is defined in objects
18:03:01 <lament> kawfee: Fuzzy meaning.
18:03:05 <kawfee> no
18:03:12 <Pseudonym> A functional language is one that has more in common with functional languages than other kinds of languages.
18:03:15 <lament> Smerdyakov: Of course not. Programming languages are formal systems.
18:03:27 <kawfee> functional programming persists where the constructs are fucntions
18:03:32 <lament> Pseudonym: That's a good and valid fuzzy definition.
18:03:37 <Pseudonym> Good.
18:03:39 <Smerdyakov> <lament> Fine, programming isn't math.
18:03:41 <Pseudonym> On that note, lunch. :-)
18:03:42 <kawfee> Pseudonym: that doesn't define it
18:03:50 <lament> Smerdyakov: programming _languages_ are math.
18:03:50 <Pseudonym> BBIAB.
18:03:51 <kawfee> I just had dinner
18:03:59 <Smerdyakov> lament, so why isn't programming?
18:04:00 <kawfee> lament: math based yes
18:04:09 <lament> Smerdyakov: I said "programming isn't math" because Pseudonym mentioned things like software engineering and debugging.
18:04:14 <lament> kawfee: not math based; just math
18:04:23 <kawfee> or should I say, you can define a language using mathematical constructs?
18:04:28 <kawfee> lament: wrong
18:04:38 <kawfee> lament: how is assembly language math?
18:04:39 <lament> kawfee: s/can//
18:04:40 <kawfee> hrmmmm
18:04:45 <Smerdyakov> Well, debugging has a clear analogue in crafting mathematical proofs, so there's no problem there.
18:04:47 <lament> kawfee: how is assembly language not math?
18:05:05 <lament> kawfee: It's a well-defined formal system
18:05:06 <kawfee> lament: mov a,x
18:05:18 <Smerdyakov> Software engineering is harder, but I think it's a shame to knock programming off the math block for something like software engineering that so few programmers really practice.
18:05:22 <kawfee> define that mathematically
18:05:22 <lament> kawfee: with precisely (mathematically) specified semantics
18:05:38 <Smerdyakov> kawfee, oh dear. You've never studied programming language semantics?
18:05:40 <lament> It is possible to prove stuff about assembly programs.
18:05:44 <kawfee> Smerdyakov: this semester
18:05:53 <Smerdyakov> kawfee, then you should know very well how to define it mathematically.
18:06:00 <kawfee> semantics are just the meaning
18:06:02 <Smerdyakov> kawfee, or, at least, by the end of the semester =)
18:06:07 <lament> hehe
18:06:08 <kawfee> heh
18:06:12 <kawfee> bah
18:06:16 <kawfee> stop harassing me
18:06:24 <Smerdyakov> What else is anything but its "meaning" in math?
18:06:39 <kawfee> look, everything can be defined mathematically in this world
18:06:41 <kawfee> math is everywhere
18:06:45 <lament> kawfee: not really.
18:06:50 <kawfee> yes really
18:06:53 <lament> kawfee: no, not really.
18:06:53 <Smerdyakov> kawfee, prove it
18:07:01 <kawfee> it can al be defined with a formula from physics
18:07:04 <Smerdyakov> kawfee, prove it
18:07:10 <lament> kawfee: physics doesn't _define_ stuff
18:07:15 <kawfee> Smerdyakov: ask a physics professor to prove it
18:07:18 <lament> kawfee: physics tries to explain stuff
18:07:21 <Smerdyakov> kawfee, you're venturing into the realm of philosophy now
18:07:23 <lament> using math, yes
18:07:34 <kawfee> Smerdyakov: math!
18:07:40 <kawfee> ya'll started it
18:07:44 <kawfee> not me
18:07:50 <Smerdyakov> kawfee, I think we're all aware of physicists searching for new theories all the time, because the current ones don't explain everything.
18:07:51 <lament> kawfee: yes, but you're the one using silly arguments
18:07:58 <kawfee> no
18:08:05 <Smerdyakov> kawfee, the tiniest difference between expected and actual measurements shows that theories are not correct.
18:08:21 <kawfee> who said anything about theories?
18:08:32 <Smerdyakov> kawfee, and these differences exist... thus, there is no proof that "the universe" obeys physical laws.
18:08:35 <lament> kawfee: you did.
18:08:43 <lament> kawfee: by mentioning physics.
18:08:46 <kawfee> and there is a fine line between having a theory and having a concrete method of proviing it
18:08:59 <Smerdyakov> kawfee, in fact, if you assume an infinite universe, then we certainly won't have any way to prove physical determinism in our lifetimes!
18:09:06 <Smerdyakov> ... and it certainly hasn't been done yet
18:09:09 <lament> kawfee: yes, there is
18:09:17 <lament> kawfee: in other words, a fine line between not-math and math
18:09:31 <kawfee> if you jump into a circle and walk around it, wont you end up walking forever until you reach the end?
18:09:55 <Smerdyakov> kawfee, relevance of this is?
18:10:07 <kawfee> infinite universe
18:10:08 * lament wonders whether the dealer kawfee purchased the crack from still has some
18:10:27 <kawfee> lament: you aren't very nice are you?
18:10:32 <whee> lament: yes, I do
18:10:35 <whee> I mean, drugs are bad, mmmkay!
18:10:39 <Smerdyakov> kawfee, by "infinite," I mean infinitely many distinct locations, or something like that :P
18:10:53 <kawfee> ohhh
18:11:01 <Smerdyakov> For how can you prove something about subatomic particles without examining each one?
18:11:03 <dark> Smerdyakov: Obviously your notion of "distinct locations" is not well-defined :)
18:11:06 <kawfee> I think I've eaten too many reeses bites
18:11:28 <kawfee> if all the particles are the same then all you need is one
18:11:33 <Smerdyakov> Prove they're the same
18:11:36 <kawfee> induction
18:11:40 <kawfee> you assume it
18:11:51 <lament> kawfee: right. That's not called "proof"
18:12:03 <kawfee> oh, I see where you are headed with this
18:12:14 <kawfee> are ya'll fans of the color plane proof?
18:12:17 <shapr> I wonder what kind of operations people are likely to do with rfc822 datatypes.
18:12:21 <kawfee> I think it was the 4 color 
18:12:39 <kawfee> where they proved it with a computer
18:12:47 <kawfee> they checked every possible combination
18:12:55 <kawfee> which wasn't a proof at all
18:13:00 <Smerdyakov> Why not?
18:13:14 <lament> Checking every possible combination is proof.
18:13:22 <kawfee> in the formal method it isn;t
18:13:24 <lament> Yes, it is
18:13:27 <kawfee> no
18:13:29 <lament> Yes :)
18:13:30 <Smerdyakov> Wow
18:13:32 <kawfee> no.
18:13:38 <kawfee> are you familiar with it?
18:13:43 <Smerdyakov> This formal semantics class is a godsend for you, kawfee, I doooo declare. =D
18:13:46 <dark> I would say that it isn't a proof, because the program that checks every possible combination probably has bugs.
18:13:58 <kawfee> lol
18:14:00 <kawfee> bugs!
18:14:18 <lament> dark: obviously you'll have to prove the correct behaviour of the program
18:14:19 <Smerdyakov> dark, then we can't have any proofs, because people probably have bugs.
18:14:26 <lament> dark: for which you'll have to write another one :)
18:14:39 <dark> Smerdyakov: This is something I have indeed claimed :)
18:14:44 <kawfee> what is the method to which proofs are attributed have bugs?
18:15:05 <lament> kawfee: unpossible!
18:15:08 <kawfee> s/is/if
18:15:12 <dark> Or rather, I've observed that some mathematicians have far too much faith in proofs, and fail to consider the possibility that proofs can have bugs.
18:15:12 <kawfee> hah
18:15:16 <Smerdyakov> dark, that fact is, proofs serve social functions, and they depend on lots of assumptions about logical rules anyway, so buggy programs are only accurately simulating the social environment =)
18:15:16 <lament> kawfee: see, we prove stuff using the method X
18:15:32 <lament> kawfee: after we proved it, we can happily say, "this is correct if X is correct"
18:15:38 <kawfee> lament: yeah, but I just substituted Y for X and Y has bugs
18:15:47 <lament> kawfee: that's all that math does. It doesn't ever say "this is ALWAYS correct"
18:16:10 <kawfee> does P = NP
18:16:15 <Smerdyakov> lament, well, we would have to have a different method for each person, then =)
18:16:16 <dark> lament: It's starting to sound suspiciously like physics now.
18:16:23 <lament> You can only prove something in a given system of axioms
18:16:30 <kawfee> lament: axioms!
18:16:38 <Smerdyakov> given system + your personal fallibilities =)
18:16:41 <kawfee> sounds like assumptions to me
18:17:09 <Smerdyakov> kawfee, they're assumptions that are deemed as useful for the purpose for which we prove theorems.
18:17:24 <kawfee> just like you assume every atom is like the other
18:17:25 <Smerdyakov> kawfee, I don't think any assumptions about the universe are "useful" in forming an all-encompassing theory.
18:17:35 <shapr> axemacs
18:17:36 <shapr> mmm
18:17:40 <kawfee> hah
18:17:41 <lament> kawfee: no, axioms aren't assumptions.
18:17:44 <Smerdyakov> We produce physical theories to understand the "essence of the existence."
18:17:45 <shapr> provably large.
18:18:12 <Smerdyakov> We prove theorems about algorithms' complexity because we care about time and space usage, and proofs in the systems we use give us reliable information about that.
18:18:36 <kawfee> ya'll have fun
18:18:42 <shapr> will do
18:18:48 <lament> gladly.
18:18:52 <Smerdyakov> I won't.
18:19:03 <Smerdyakov> I'm going to sit on this crocodile until he wakes up.
18:19:07 <Smerdyakov> I'm counting the seconds.
18:19:43 <dark> And then... CHOMP?
18:21:19 <Smerdyakov> All I can say for sure is that the sun is setting on my new petunias.
18:23:55 <kawfee> awww
18:24:33 * shapr yawns
18:25:03 <kawfee> so what is this you are referring to programming language semantics?
18:25:04 * shapr realizes he should start using worthwhile datatypes right now.
18:27:05 <Smerdyakov> <Smerdyakov> kawfee, oh dear. You've never studied programming language semantics?
18:27:07 <Smerdyakov> <kawfee> Smerdyakov: this semester
18:27:26 <Smerdyakov> You answered a question using an unknown term? =)
18:28:27 <shapr> man this is a bigger task than I thought.
18:28:40 <dark> shapr: I often run into that problem :)
18:29:58 <det> shapr, what are you up to now ?
18:34:15 <shapr> det: still working on the rfc822 parser
18:34:30 <det> oh :)
18:36:14 <shapr> det: what are you up to?
18:37:36 <dark> shapr: You might be dealing with a subtle and little-understood property of software, which is that all mail handling software automatically sucks.
18:37:45 <shapr> dark: hah
18:38:02 <shapr> I'm just trying to figure out what sort of granularity I want for my rfc822 datatypes
18:38:08 <dark> This has disastrous consequences when paired with another property, which is that all programs will accumulate features until they can send mail.
18:38:30 <shapr> I'm starting at the mail end, and working towards having a real program
18:39:47 <shapr> oh, I can't just pass around datatypes, I need to keep handing around parsers...
18:39:48 <shapr> hmmm
18:41:11 <det> shapr: I got a couple *gasp* possitive replies on haskell-list so I'm happy ! :-)
18:41:18 <shapr> yay!
18:41:45 <det> shapr, and I have time to write something haskell tonight
18:41:49 <shapr> spiffy!
18:41:53 <shapr> what are you going to write?
18:42:05 <det> that is to be seen
18:42:21 <det> maybe I'll attempt some Jelly
18:46:25 <flippo> I want read a Haskell book.  What should I get?
18:46:44 <flippo> [to] read
18:47:12 <shapr> I like Simon Thompson's "Haskell The Craft of Functional Programming"
18:47:24 <flippo> shapr: Sounds like a very promising title.
18:47:31 <shapr> though some people prefer Paul Hudak's "Haskell School of Expression"
18:47:37 <shapr> I have them both :-)
18:48:07 <flippo> shapr: After I read one, then I'll read the other.  Great. (^^)
18:49:46 <flippo> So far I've read the "Gentle Introduction" twice, and a book "Algorithms" by Rabhi and Lapalme.  I want more.
18:50:01 <shapr> flippo: I really like the lapalme and rabhi book
18:50:40 <shapr> I became a great fan of Burstall & Darlington after reading that book.
18:50:42 <flippo> shapr: It expanded my mind, but it didn't give me as much appreciation for what makes Haskell special as the Gentle Introduction.
18:51:10 <flippo> Burstall & Darlington?
18:51:39 <flippo> s/It/"Algorithms"/
18:51:47 <shapr> the transformation system that lapalme and rabhi use throughout their book.
18:52:04 <shapr> my copy of that book has lots of notes written in it
18:52:09 <flippo> shapr: I should reread it.  :)  Been more than a year.
18:53:02 <shapr> flippo: best way to appreciate Haskell, write code in it.
18:53:02 <flippo> shapr: I read the "Algorithms" book first, thought the functional approach was great, but I wasn't sold on Haskell over say scheme.  Then I read the Gentle Introduction and saw the light.
18:53:24 <shapr> once you've written some code in Haskell, you either love it or hate it.
18:53:46 <shapr> I've not met many who used Haskell and then didn't like it.
18:53:46 <flippo> shapr: indeed.  Is there an interactive command line?
18:53:52 <shapr> yup
18:53:55 <shapr> ghci or hugs
18:54:11 <shapr> they're not as interactive as Python, but still good
18:54:13 <flippo> shapr: which do I download first?  (for linux)
18:54:22 <shapr> I'd suggest ghc5
18:54:34 <shapr> there's an excellent emacs mode
18:54:48 <shapr> with support for running ghc or hugs as an inferior process
18:54:55 <shapr> and dumping the current buffer into that process, etc
18:54:59 <flippo> yum
18:55:15 <flippo> fortunately, I use emacs (in vi-mode)
18:55:24 <shapr> yes, I've seen you on #emacs 
18:55:29 <flippo> heh
18:55:30 <det> shapr, does emacs really call child prccesses "inferioe processes" ?
18:55:40 <flippo> hahaha
18:55:42 <shapr> it does
18:56:18 <shapr> det: though I doubt it's trying to be insulting :-)
18:56:25 <Pseudonym> An "inferior process" is anything not written in lisp.
18:56:46 <shapr> yow, it's nearly 4am
18:56:55 <shapr> I must sleep.
18:57:09 <flippo> shapr: good plan, thanks for the help
18:57:16 <Pseudonym> Yes, go sleep.
18:57:28 <shapr> flippo: sure, we're happy to help
18:57:29 <shapr> good night all
18:57:35 * shapr goes to sleep
18:58:30 <det> shapr: oh :)
18:58:32 <flippo> dang, all ghc5 downloads assume I am using debian (as I should)
18:58:33 <det> shapr, higt
18:58:40 <det> shapr, night even
19:11:53 <emu> Pseudonym: inferior-lisp mode ;)
19:20:30 <Pseudonym> :-)
19:21:22 <emu> a name that only RMS could come up with
19:23:28 <Smerdyakov> Or a clone of RMS
19:23:52 <emu> scary thought
19:24:07 <flippo> yay for RMS -- my hero
19:25:26 <Smerdyakov> My hero is Pokey the Penguin.
19:25:59 <lament> My hero is me.
19:26:07 <whee> pokey hasn't updated recently :(
19:26:08 <Smerdyakov> emu, why do you have a cheme hostname?
19:26:24 <flippo> I visualize RMS as he is portrayed in a drawing on the cover of the emacs manual, in armor, on a noble steed
19:26:41 * andersca has met rms
19:26:44 <Smerdyakov> Pshaw. I eat noble steeds for breakfast.
19:26:45 <emu> I have a shell from a friend in cheme
19:27:27 <Smerdyakov> emu, and this is just to have a presentable hostname? =)
19:27:47 <emu> ?
19:31:36 <Smerdyakov> Why do you need a shell? Don't you have broadband?
19:32:04 <emu> I like to have a stable shell to run screen on
19:32:22 <Smerdyakov> You don't have a stable PC of your own?
19:32:42 <emu> DSL is not conducive to remote logins
19:35:39 <Smerdyakov> My dreams are shattered.
21:20:31 <kawfee> emu: I didn't know they allowed you in here
