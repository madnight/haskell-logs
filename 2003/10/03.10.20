01:14:50 --- mode: tolkien.freenode.net set +b *!23kjhkjf@*
02:09:58 <shapr> @yow
02:09:59 <lambdabot> Yow!  Now I get to think about all the BAD THINGS I did to a BOWLING BALL
02:09:59 <lambdabot>  when I was in JUNIOR HIGH SCHOOL!
02:19:11 <mattam> :)
02:58:53 <shapr> bonjour mattam 
02:59:14 <shapr> it's beginning to look a lot like christmas!
02:59:22 <shapr> oh, I heard from the nhc98 runtime on the Palm guys
02:59:35 <shapr> they said they're porting their changes to nhc98 proper
03:00:02 <shapr> and that they expect to have something alpha quality to use in a month or two
03:06:06 <earthy> schweet.
03:26:05 <stormix_> hey
03:26:21 <stormix_> i'm having some trouble making an infinite list of the odd numbers, but alternately negative
03:26:42 <stormix_> i.e. 1,-3,5,-7,9,-11 etc.
03:27:27 <stormix_> i could do it with map and the list [1,3..] but
03:27:36 <stormix_> i can't make a function that alternates between returning 1 and -1
03:28:51 <ludde_> maybe something like this
03:28:51 <ludde_> (\a -> (a*2 + 1) * (-1) ^ a) [1..]
03:31:19 <stormix_> ah yes, excellent :D
03:31:22 <stormix_> thanks very much :)
03:38:36 <shapr> hi harsha123!
03:38:43 <harsha123> hi shapr :)
03:39:00 <shapr> what's going on?
03:39:25 <harsha123> hmm. writing a few scripts for my bootable CD 
03:39:31 <harsha123> and you?
03:40:24 <shapr> trying to make an audio CD from a few mp3s
03:40:43 <harsha123> hmmm Ok .. what are you using?
03:40:53 <shapr> I dunno yet
03:40:58 <shapr> I'm trying to figure out what I should use
03:40:59 <harsha123> ok
03:41:28 <shapr> is there a certain program that turns a bunch of mp3s into an ISO image?
03:41:45 <harsha123> mkisofs
03:41:48 <shapr> ah
03:41:55 <phubuh> audio CDs don't use ISO9660
03:42:13 <phubuh> so you wouldn't be able to play it on most CD players
03:42:15 <shapr> phubuh: how do I know if my mp3s will fit onto a single disk when converted to .wav?
03:42:15 <harsha123> phubuh yep, they dont
03:43:03 <phubuh> shapr, i've used k3b to burn audio CDs and it graphically shows how full the disk would be
03:43:11 * shapr searches
03:43:20 <phubuh> it's a KDE application :/
03:43:22 <shapr> cool, I'll try it
03:43:25 * shapr shrugs
03:43:29 <shapr> if it's a deb I'm happy
03:43:35 <phubuh> it is :-)
03:43:39 <harsha123> phubuh k3b does it have a GUI?
03:43:44 <phubuh> yup
03:43:52 <phubuh> it's very similar to nero for windows
03:44:00 <shapr> I think both KDE and Gnome are good things
03:44:14 <harsha123> hmm... i have never used it..but does it convert .mp3 to .wav?
03:44:27 <phubuh> harsha123, yep
03:44:44 <phubuh> shapr, so do I, but I prefer GNOME :)
03:44:45 <harsha123> phubuh hmm. ok.. :) i ll try it too
03:45:17 <harsha123> so how as weekend guys?
03:45:36 <shapr> phubuh: I don't use either as an environment, so I'm not so picky
03:46:02 <shapr> I had fun, I set up a new debian box that I'll be taking to customers soon
03:46:47 <harsha123> shapr debain box... customized to do something? or just a debian box?
03:46:50 <shapr> oh, have you guys seen the *BSD Linux 2.{4,6} comparison on slashdot?
03:46:57 <shapr> harsha123: yah, it'll be a zope server
03:46:59 <phubuh> hmm, no
03:47:09 <shapr> http://bulk.fefe.de/scalability/
03:47:50 <shapr> Linux 2.6 scales O(1) in all benchmarks. Words fail me on how impressive this is. If you are using Linux 2.4 right now, switch to Linux 2.6 now!
03:47:54 <shapr> that's the conclusionary quote
03:48:00 <shapr> I gotta try 2.6 very soon
03:48:02 <phubuh> hee hee
03:48:25 <harsha123> ok. i'll try it too.. :)
03:49:42 <harsha123> shapr: is zope under GPL?
03:50:00 <shapr> something close, it's ZPL
03:50:13 <harsha123> hmm.... ok
03:57:49 <shapr> I like k3b
03:57:54 <shapr> it's quite spiffy
03:58:16 * harsha123 is still downloading it.
03:58:29 <shapr> though sadly not multithreaded
03:58:34 <harsha123> shapr whats your download speed like ?
03:58:35 <shapr> so it only uses one CPU
03:58:49 <shapr> I have a 512kbits line
03:58:55 <shapr> though we'll be upgrading soon
03:58:57 <harsha123> ooops.. 
03:59:53 <harsha123> so 2MBPS now? ;)
04:01:41 <shapr> 10Mbits :-)
04:01:56 <phubuh> yay :-) bredbandsbolaget?
04:01:59 <shapr> yup
04:02:08 <phubuh> that's what I have, and I love it
04:02:15 <phubuh> except their usenet server is down
04:02:23 <phubuh> I was just about to ring them up and whine :-)
04:02:24 <shapr> one great thing about sweden, they have *lots* of bandwidth
04:02:40 <shapr> so, k3b can't find my cdburner
04:02:48 <shapr> but it did create a bunch of wav files
04:02:54 <phubuh> i think you need to run it as root, or something
04:03:11 <phubuh> well, as a user that has permissions to the burner :)
04:03:16 <shapr> yah, it still can't find my burner even as root
04:03:21 <phubuh> hrm.
04:03:33 <harsha123> we suffer from not enough bandwidth.. bandwidth here is very costly :(
04:04:30 <shapr> harsha123: you should install ipv6 so you can get multicasting at the routers
04:04:32 <shapr> that would save you bandwidth
04:04:58 <shapr> for example, a multicast debian archive push update would save all debian users bandwidth
04:05:13 <shapr> same for other distros
04:05:28 <shapr> Mutex destroy failure: Device or resource busy
04:05:32 <shapr> that's slightly scary
04:06:24 <YveDeLarc> ave
04:07:01 <harsha123> hmm..Ok.
04:07:06 <shapr> eva
04:10:12 <shapr> fooey, my cdburner is flippin out
04:10:17 <shapr> gotta reboot to reset it
04:22:21 <phubuh> OpenBSD 3.4 was a real stinker in these tests. The installation routine sucks, the disk performance sucks, the kernel was unstable, and in the network scalability department it was even outperformed by it's father, NetBSD. OpenBSD also gets points deducted for the sabotage they did to their IPv6 stack. If you are using OpenBSD, you should move away now.
04:22:23 <phubuh> ouch!
04:31:26 <Lunar^__> phubuh: Just read that also
04:53:49 --- mode: clancy.freenode.net set +b *!23kjhkjf@*
04:55:31 --- mode: kornbluth.freenode.net set +b *!23kjhkjf@*
04:57:32 --- mode: clancy.freenode.net set +b *!23kjhkjf@*
05:35:35 --- mode: kornbluth.freenode.net set +b *!23kjhkjf@*
05:38:19 <phubuh> :~(
05:38:44 <phubuh> I just found out that bredbandsbolaget (my ISP) shut down their USENET server out of lack of use :(
05:45:45 * earthy coughs
05:45:56 <earthy> that would be classified under `lousy ISP'
05:46:18 <harsha123> hehehehe..
05:46:20 <phubuh> it's an amazingly awesome ISP except for this, actually
05:47:13 <phubuh> I get dedicated 10 Mbit up and down for like $40/month, so I shouldn't really be complaining :-)
06:27:21 <harsha123> phubuh $40 is dead cheap...
06:27:43 <harsha123> phubuh do you have any download restrictions?
06:27:49 <phubuh> nope
06:28:01 <harsha123> geeez..
06:29:15 <harsha123> i pay $125 per month for a 64kbps line and 6G download restriction.. 
06:30:05 <harsha123> and $50 for every 1GB then onwards.. :(
06:30:36 <phubuh> ouch!
06:30:43 <harsha123> hurts right? :)
06:31:36 <harsha123> phubuh where are ya from?
06:31:47 <phubuh> sweden
06:31:58 <harsha123> hmmm..
06:31:59 <phubuh> you're indian, correct?
06:32:04 <harsha123> yep :)
06:32:31 <harsha123> i think you guys have surplous bandwidth... 
06:33:00 <polli> harsha123: is that possible? :)
06:33:08 <harsha123> hehehe..
06:33:11 <earthy> well... the $40/month is extremely cheap, yeah.
06:33:31 <harsha123> earthy how much do you pay?
06:33:41 * earthy thinks ADSL at EUR 35/month for 1Mbit down, 128Kbit up is reasonable
06:33:57 * earthy pays EUR 50/month for Cable, at 1.5Mbit down, 256Kbit up
06:34:18 <harsha123> reasonable enough
06:34:59 <harsha123> i think these damn indian ISP's are minting money.. looting us
06:36:10 <earthy> probably not. international bandwith is dead cheap 'round here
06:36:23 <earthy> I'd say that's quite a different story in india
06:37:01 <harsha123> earthy are you telling me Indian's ISPs pay more for their bandwidth?
06:37:23 <earthy> yes.
06:37:35 <Heffalump> everyone but the US pays a hefty premium for the fact that the US is the centre of the Internt
06:37:35 <earthy> as do australian ISPs, e.g.
06:37:40 <Heffalump> s/Internt/Internet/
06:37:44 <earthy> heffalump: not *quite* as bad
06:37:49 <harsha123> hmm... probably.
06:37:52 <Heffalump> so we have to pay for the cables to the US, rather than the cost being shared
06:38:02 <Heffalump> I imagine there's lots of cheap cables from Europe these days, though
06:38:08 <earthy> what helps in .eu is the big xchanges such as LINX, AMSIX, DE-CIX
06:38:31 <earthy> and the *large* amounts of fiber on the seafloor between .eu and .us
06:38:49 <Heffalump> yeah.
06:38:52 <earthy> australia, eg., has only three or so international fiberlinks.
06:38:55 <harsha123> how is it like in the US?
06:39:14 <earthy> the US has MAE-East, MAE-West and a couple smaller ones
06:39:17 <harsha123> how much do they pay in the US?
06:39:29 <earthy> owh, the same or more as in most parts of .eu
06:39:31 <Heffalump> I remember 7 or 8 years ago it was all a very big deal - and you do still need your own transatlantic bandwidth to peer at LINX
06:39:35 <earthy> for broadband, that is.
06:39:45 <earthy> Heffalump: true. but *that*helps*. ;)
06:39:53 <Heffalump> comparing the prices of colocation shows up more of a difference
06:40:04 <earthy> (one of the more interesting companies at LINX is the BBC. ;))
06:40:05 <Heffalump> you can get some _really_ cheap deals in the US, which you don't see in Europe
06:40:12 * earthy nods
06:40:24 <Heffalump> the BBC are really good about peering deals, AIUI
06:40:24 <earthy> but space is at more of a premium in .eu
06:40:32 <Heffalump> that's a point
06:40:37 <earthy> the BBC run their own transatlantic links. ;)
06:40:43 <Heffalump> I hadn't really considered if it was a bandwidth or a space issue
06:40:46 <harsha123> i guess space is dead cheap in india
06:40:48 <earthy> just to be able to peer worldwide. ;)
06:41:02 <earthy> for colocation, believe me, it's space.
06:41:31 <earthy> it's not that cheap to get a large enough building with enough electricity going in to run all the machines *and* their cooling systems.
06:41:58 <Heffalump> yeah, true
06:42:05 <harsha123> earthy do you have a website hosted somewhere?
06:42:25 <Heffalump> my ISP's 1U charge is £15/month
06:42:47 <harsha123> Heffalump resonable enough..
06:43:10 <Heffalump> that's just the space charge, not the full colocation cost
06:43:16 <harsha123> oh.. Ok
06:43:49 <earthy> harsha123: no. but I do have friends (quite a lot of them) in the ISP business.
06:43:58 <earthy> and was in it myself for a while as well.
06:44:06 <harsha123> ok
06:44:26 <Heffalump> oh, and that's +VAT, so more like £18
06:44:38 <Heffalump> we pay £58.75 including VAT for 1U hosting and 40GB/month of traffic
06:45:04 <earthy> (one of the nicer colo places I've ever been to is a converted bank-building that used to house part of the Dutch gold-bullion underpinning the guilder)
06:45:37 <harsha123> hmm.. 
06:45:45 <earthy> `physical security -- check'
06:46:08 <earthy> `getting cables in -- well... there's specialised companies for that, right?' :)
06:46:54 <harsha123> not in india..
06:47:33 <earthy> the drilling company *did* have quite the problem with those walls. ;)
06:47:43 <harsha123> hehehe
06:48:01 <earthy> (it cost them a drill... and those are the expensive, cuts-through-everything kind... ;))
06:49:28 <harsha123> earthy what Irc client are you using?
06:50:13 <earthy> ircII
06:50:22 <earthy> nice and oldskool
06:50:32 <harsha123> is bitchx done on ircII ?
06:51:09 <harsha123> i mean is it a wrapper on ircII ?
06:51:24 <earthy> it was, once, but it's diverged
06:51:33 <harsha123> hmmm Ok
06:52:34 <harsha123> i was looking for a good tutorial on epic.. but www.epicsol.org is not comprehensive enough..
06:54:07 <harsha123> someone was telling me ircII is better to write Irc scripts.. is that true?
06:54:27 <harsha123> I guess its the same on bitchx.. isn't it?
06:55:32 <earthy> dunno.
06:56:02 <earthy> I'd consider looking into irssi if I wanted to do stuff like that
06:56:16 <earthy> it's quite the IRC client, from what I hear
06:56:48 <harsha123> hmm... Ok..
06:57:54 <Heffalump> irssi is nice
06:57:59 * Heffalump uses it
06:58:20 <harsha123> Heffalump do you write Irc scripts?
06:59:18 <Heffalump> not really
06:59:26 <Heffalump> I fiddle with other people's occasionally
06:59:36 <harsha123> ok
07:25:50 <harsha123> Heffalump whats the irssi's debian package name?
07:26:15 <phubuh> irssi-text
07:26:33 <harsha123> hhmm ok cause apt-get says irssi is obselete
07:27:35 <Heffalump> what phubuh said :-)
07:28:08 <harsha123> okie
08:13:12 <phubuh> hmm
08:13:25 <phubuh> i stumbled across a log from irc.jabber.org #jabber
08:13:34 <phubuh> [15:11] <erisson|wrk> ||cw: yeah, a functional programming language I had to learn in school.
08:13:35 <phubuh> [15:11] <erisson|wrk> Functional languages are screwey. switching between OO and procedural is easy enough, but functional's just wrong.
08:13:41 <phubuh> might it be our erisson? :-)
08:14:30 <SyntaxPolice> phubuh: that's pretty incriminating... how old was the log?
08:16:04 <phubuh> like three years
08:16:09 <phubuh> 2000/09/28
08:17:05 <SyntaxPolice> hmmmm
08:17:20 <phubuh> i suspect that's how most people feel at first, though. i know i did :-)
08:17:31 <Smerdyakov> I didn't!
08:19:29 <phubuh> i think the language he learned in school was ML; that might explain things :-P
08:19:50 <SyntaxPolice> hehe
08:35:48 <Smerdyakov> Oh, you big silly.
08:37:16 <phubuh> i'm allowed to say that in #haskell!
08:50:19 <Heffalump> shapr: you about?
08:59:06 <Heffalump> oh, actually, never mind
09:14:59 * esap just ran into a case where f x = ( ... ) x  is different from f = ( ... ). Weird thing.
09:16:18 <Smerdyakov> What's the difference?
09:16:33 <esap> the second gives 'Couldn't match' error, the first works fine.
09:16:47 <Heffalump> in Haskell?
09:16:50 <esap> yes.
09:17:03 <Heffalump> apart from the monomorphism restriction, unless ( ... ) mentions x, the two should be identical
09:17:13 <Heffalump> also apart from if you have other cases in the definition of f
09:17:46 <Heffalump> can I see the code?
09:17:53 <esap> the situation is that 'f' is used in a context where it is instantiated into multiple types.
09:18:48 <esap> The code is: instance Sequencable QFSystem where { sequenceS x = fold_system x (QFSystemF sequenceSM sequenceSM sequenceSM sequenceSM sequenceSM sequenceSM sequenceSM) where sequenceSM x = mapSequenceS make_system x. But I guess you need to know a bit more to understand it.
09:19:13 <esap> Each of those uses of sequenceSM have different type.
09:19:15 <Heffalump> sounds like it is a monomorphism restriction issue then
09:19:25 <Heffalump> or does that only apply to top-level bindings?
09:20:49 <esap> Yea, sounds like monomorphism restriction, I guess.
09:20:56 <esap> But it's still weird :-)
09:21:37 <Heffalump> the monomorphism restriction is not nice
09:21:58 <Heffalump> it's a shame that it breaks eta-equivalence
09:25:29 <Smerdyakov> Maybe if you'd eaten your vegetables when you were a kid....
09:25:30 <esap> Interesting that GHC didn't say monomorphism restriction problem with that code, it instantiated the type of sequenceSM to one of the types used, and then gave an error for the rest.
09:25:50 <Heffalump> I've experienced that before too
09:26:24 * esap wonders if I've turned monomorphism restriction off :-)
09:27:52 <Heffalump> if you have, the code should have worked
09:28:03 <Heffalump> (well, that definition should have got a polymorphic type, anyway)
09:39:55 <esap> Is it possible to give a type signature to (\x -> QFSystemF x x x x x x) in that example?
09:40:09 <esap> Where each x would be instantiated to different type?
09:40:15 <Heffalump> umm?
09:40:24 <Heffalump> that's not possible without a rank 2 type
09:41:00 <esap> hmm.. you're right. Actually rank-2 type works fine.
09:41:28 <esap> it's type is (forall f. f a -> b) -> QFSystemF a b
09:42:48 <esap> But I think I also need to specify some constraints on 'f' to make it useable. Hmm..
09:45:02 <esap> Does this mean that my original example would not typecheck if rank-2 types weren't supported in GHC?
09:45:11 <Heffalump> your very first one?>
09:45:15 <esap> yes.
09:45:34 <Heffalump> no, that's a monomorphism restriction issue
09:45:57 <Heffalump> your second example is a rank-2 issue because the x that you repeat is a parameter to a function, not a separate definition
09:46:35 <Heffalump> in the first case, the type of sequenceSM doesn't appear in negative position in any type
09:47:20 <Heffalump> Smerdyakov: I did eat my vegetables as a kid :-p Maybe if I hadn't I'd always be using ML, where eta-expansion changes termination :-)
09:47:46 <esap> hmm.. so the type of x in sequenceSM x = ... must be different than if I use  sequenceSM = \x -> ... ?
09:48:27 <esap> If they behave differently due to monomorphism restriction :-)
09:48:50 <Heffalump> yes
09:49:33 * esap doesn't see the difference.
09:50:00 <Heffalump> the difference is imposed by the Haskell spec, not by our intuition of how these things should behave
09:50:49 <esap> So the lambda variant instantiates the type of 'x' always to the concrete type or something like that. It's not quite intuitive, because I don't think lambda ordinarily does that.
09:51:10 <Heffalump> lambda bindings are monomorphic in any case
09:51:36 <Heffalump> I think this only actually makes a difference when you have a class constraint involved.
09:51:50 * Heffalump is getting out of the depth of his (lack of) detailed knowledge of this issue
09:52:09 <esap> So, actually, the correct way how the spec should have fixed this was that you indicate in a function type whether the argument is polymorphic or monomorphic?
09:52:14 <Lunar^__> Heffalump: that's why you can't write an Y combinator directly
09:52:42 <esap> Or actually, have a different lambda abstraction for monomorphic and polymorphic case?
09:52:55 <Heffalump> esap: no, if you give an explicit type you always avoid the monomorphism restriction
09:53:42 <Heffalump> if you allow polymorphic lambda bindings I think you start needing to have System F for your type system - and type inference becomes undecidable
09:53:52 <Heffalump> that's why Hindley-Milner (+ type classes) is a nice compromise
09:54:58 <esap> Ok, my preferred compromise is that type annotations have to be used for top-level declarations only. But for this case, I'd have to reconsider that.
09:56:21 <Heffalump> the monomorphism restriction is orthogonal to that
09:56:49 <Heffalump> that's to do with not wanting to surprise the user about how many times something gets evaluated
09:57:04 <Heffalump> monomorphic lambda bindings are so that type inference stays decidable
09:57:13 <Heffalump> confused yet? :-)
09:57:57 <esap> no, not yet. My preferred solution for the double-evaluation problem is that you annotate also strictness separately.
09:58:39 * esap thinks that works
09:59:35 <Heffalump> I don't think that's a strictness issue.
10:00:11 <esap> If the thing being doubly-evaluated is strict, then you don't have double-evaluation in any case.
10:00:26 <Heffalump> wh?
10:00:29 <Heffalump> s/wh/why/
10:03:51 <esap> Becayse consider you have \ ! x -> x  that you pass to several contexts. That function has to be able to strictly evaluate its argument. You are saying that the function _contains_ that evaluation. Therefore, if that function does it, I would not think in client of that code that that function is not responsible for that evaluation.
10:04:13 <Heffalump> no, that's not the issue
10:04:16 <Heffalump> if you write:
10:04:21 <Heffalump> f = g 1
10:04:24 <Heffalump> where g does a lot of computation
10:05:00 <Heffalump> then if f has a type without class constraints, g 1 will be evaluated precisely once, because there's only one possible bit of code to run
10:05:38 <Heffalump> whereas if f has a type with class constraints, then actually the implementation of f will have an extra parameter that is the class dictionary
10:05:47 <Heffalump> so g 1 will be evaluated once each time f is called
10:06:06 <Heffalump> the idea behind the monomorphism restriction is to avoid surprising the user when this happens
10:06:39 <Heffalump> so it's banned _unless_ they give an explicit type signature to say "I know this is what will happen" - or they use it in a local block where a monomorphic type can be inferred
10:06:48 <esap> Hmm.. so you mean the issue is about having a constraint on the universally quantified type variable vs. not having a constraint?
10:07:15 <Heffalump> I'm fairly sure that's the case, yes
10:07:36 <Heffalump> cos if there was no constraint, there'd be no dictionary and no issue with re-using the original computation
10:08:27 <esap> ok, then I need to change my proposed solution towards explicitly indicating dictionaries :-)
10:12:08 <esap> Or actually, isn't the problem about the compiler not being able to infer what dictionary to use?
10:12:41 <esap> Because it only knows about those some concrete types that need to satisfy that dictionary, but not the constraint itself.
10:13:19 <esap> And there is no way of inferring a constraint from a collection of types.
10:14:04 <Heffalump> huh?
10:14:10 <Heffalump> it knows about the constraint
10:14:15 <Heffalump> that'll come from type inference
10:15:00 <esap> like in my example QFSystem x x x x x x, each x has some type of the form (A x -> b), where A is some concrete type that is different for each instance of use of x.
10:15:14 <Heffalump> ah, right
10:16:02 <Heffalump> but again, that's not a monomorphism restriction issue
10:16:22 <Heffalump> does it work when you give it a rank-2 type, anyway?
10:17:49 <esap> no. But it works if I don't give any type signature for x.
10:19:07 <esap> Because there is no choice of constraint that I can use to specify that exact set of concrete types.
10:19:56 <esap> I can declare that expression to have rank-2 type, but that function will be unusable.
10:20:03 <Heffalump> umm
10:20:11 <esap> because any use of that would require you to have a constraint.
10:20:11 <Heffalump> you've written \
10:20:17 <Heffalump> \x -> QFSystem x x x x x x
10:20:34 <Heffalump> and that typechecks even though QFSystem uses x at different types each time it invokes it?
10:21:45 <esap> no, I guess not actually. I have that for a proposed declaration that has rank-2 type.
10:22:12 <esap> but I can't put a constraint on the universal quantification on that.
10:22:26 <esap> And for using that declaration I would need a constraint.
10:23:06 <Heffalump> umm, what's the type of the thing you intend passing as a parameter?
10:23:41 <esap> (forall f. f next -> b) -> QFSystemF next b, where I would want f to have some constraint, but I don't know what to write there.
10:23:59 <esap> Because no choice of constraint will pass the type check.
10:24:04 <Heffalump> isn't that the type of that lambda abstraction, not the type of the thing you want to pass it?
10:24:44 <esap> oh you want the type of QFSystem?
10:24:46 <esap> constructor?
10:24:59 <Heffalump> no
10:25:09 <Heffalump> you're writing this lambda abstraction for a reason, yes?
10:25:19 <Heffalump> at some point, it will be applied to a parameter, right?
10:25:37 <esap> yes.
10:26:00 <Heffalump> give me the type of one example of that parameter
10:26:04 <esap> For each use, the type of the argument is different.
10:26:25 <Heffalump> but in each case, they'll be valid in all those positions as arguments to QFSystem?
10:26:56 <esap> yes.
10:27:27 <Heffalump> there must be _something_ all these things have in common
10:27:34 <Heffalump> can't you just invent a type class and make them all instances of it?
10:28:05 <esap> This all comes down to my declaration of the data type: data QFSystemF next b = QFSystemF (QFExpression next -> b) (QFDom next -> b) (QFCod next -> b) (QFFuncApp next -> b) (QFType next -> b) (QFKind next -> b)
10:28:34 <Heffalump> and give some examples of things that might be parameters?
10:29:17 <esap> Each of those concrete types are a node in a parse tree. That data type is used to describe _folds_ over that tree.
10:30:07 <Heffalump> ok, so give an example of something that might be the parameter to your lambda function
10:31:42 <esap> Well one example was the sequenceSM function: sequenceSM x = mapSequenceS make_system x, which has type (Monad m, Sequencable f, NatTranform f QFSystem) => f (m a) -> m (QFSystem a)
10:32:04 <esap> I have other examples, but with different sets of constraints.
10:32:12 <Heffalump> ah
10:32:13 <Heffalump> hmm.
10:33:07 <Heffalump> so in essence, your lambda abstraction ought to have a large variety of types
10:33:16 <esap> yes.
10:33:36 <Heffalump> are you sure you can't make up a class to encapsulate them, using the conditions above as prerequisites in each case?
10:33:43 <esap> In a sense, I guess, it could be modelled as a parametrized constraint or something like that.
10:33:49 <Heffalump> i.e. class QFSystemFold where
10:34:31 <Heffalump> and then instance Monad m, Sequenceable f, NatTransform f QFSystem => QFSystemFold f m
10:34:34 <Heffalump> or similar
10:34:42 <Heffalump> sorry, class QFSystemFold f m
10:34:49 <Heffalump> but in general I think you might be stuffed, yeah
10:35:15 <esap> I have to think about that to see. But I guess it's problematic.
10:36:25 <esap> Because the constraint would have to cover all different kinds of folds that you can do for that data type. I guess that's hard to design.
10:39:16 * esap would like to have constraints of the form (f a) =>, that would definitely solve this.
10:45:07 * esap thinks a concept like type class for which you could define constructors (not types) as instances, and then use that to define "universally-quantified constraints" that ranges over all such constructors.
10:46:00 <Heffalump> DYM type constructors?
10:46:11 <esap> DYM?
10:46:15 <Heffalump> "do you mean"
10:49:08 <esap> I'm not sure, actually, it would be something beyond current type classes anyway (in a sense, 'higher-order' type class or something like that). I think ordinary type classes can do this already for type constructors (e.g. Monad).
10:50:21 <Heffalump> yes, precisely
10:50:22 <esap> It would declare something like: "all constraints that are satisfied for all of these constructors"
10:50:52 <esap> that is why constructors would be the instances.
10:51:07 <Heffalump> YM data constructors?
10:51:11 <esap> yes.
10:54:55 <esap> you'd have to have something like: (C f) => (f x) => x -> x, and instance C X  (when X is a data constructor).
10:58:51 <esap> Maybe this makes the whole type system undecidable or something, I haven't thought that far :-)
10:59:06 <Heffalump> it already is, if you're using MPTCs, isn't it?
10:59:12 <Heffalump> unless you're always using a fundep
10:59:37 <esap> is it?
11:00:02 <Heffalump> I can't remember
11:00:42 <esap> hmm.. that would be a good reason not to include MPTCs.
11:01:36 <esap> I thought it just makes the dictionary lookup O(n^k), where k is the number of parameters.
11:02:20 <esap> at least if the number of instances for the class is large.
11:03:44 <esap> or maybe it was just space usage of the dictionary.
11:04:02 * esap can't remember these things exactly.
11:22:44 <ibid> is there a useful MonadPlus m => m, for which fail s = mzero does not hold?
11:23:45 <ibid> hmm, i'll rephrase
11:24:07 <ibid> for which there is no s for which fail s = mzero holds
11:59:19 <esap> ibid: I can't think of any now.
12:00:48 <esap> ibid: unless fail = error (because you can't pass a string) but mzero exists. But I'm not sure that's useful.
12:01:41 <ibid> right
12:03:16 <esap> I'm actually wondering which one is badly designed, Monad or MonadPlus :-)
12:05:06 <ibid> oh?
12:05:15 <ibid> you mean for fail being in m
12:05:16 <ibid> Monad
12:06:24 <esap> yes.
12:07:10 <esap> It seems that either fail should be in MonadPlus or mzero should be in Monad.
12:08:49 <esap> Or then I've missed some deep reason why the current solution is good.
12:09:04 <ibid> i believe the reason for fail to be in Monad is beause it's needed by do notation
12:09:34 <esap> Is there some reason why do notation cannot use another type class?
12:09:50 <ibid> it's no longer a Monad notation? ;)
12:11:01 <Riastradh> esap, uh, how would you do that?
12:11:57 <esap> Depending on what part of the syntax is used, require different constraints to be satisfied.
12:12:37 <Riastradh> Gee, how specific.
12:13:34 <esap> I mean, if you use fail (due to pattern matching translation), then you'd require MonadPlus.
12:14:05 <Riastradh> Give me an example of using do with another typeclass, and what code it would be equivalent to without the syntactic sugar.
12:16:44 <esap> so do { Just x <- Nothing ; return x }  == Nothing >>= matchJust >>= return. Obviously, matchJust :: (MonadPlus m) => Maybe a -> m a
12:17:06 <Riastradh> How does do figure out to use matchJust?
12:17:55 <esap> It would be a projection function generated from using 'data'.
12:18:24 <esap> And could be used when you pattern match against a pattern using that constructor.
12:20:34 <esap> Note that the syntax already requires the existence of such functions.
12:23:48 <esap> actually current do notation translation translates that to let with pattern matching. I guess you can do the same here.
12:25:24 <esap> but the compiler just needs to ensure that fail branch is not generated unless the previous match can fail.
12:25:30 <Heffalump> have they abandoned the distinction between do and mdo in monad syntax that'll be in the upcoming GHC?
12:28:41 * esap doesn't know.
12:37:54 <Tomasso> where can i find stuff on concepts of functional programming, not only haskell, if they are explained in haskell better
12:40:11 <esap> try http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
12:41:38 <Tomasso> let me check
12:44:40 <esap> if it's too dense, there are easier ones, but that's the definite one if you don't have trouble reading it.
12:45:33 <Tomasso> hmhmhm Ok
12:51:01 <esap> oh and SICP is another good thing to read.
12:51:20 * esap slaps himself for forgetting about that.
12:51:38 <esap> http://mitpress.mit.edu/sicp/
12:53:18 <Re-Born> which is a good website for learnin haskell, yes i have read the topic but find it hard to follow the tutorials there
12:54:19 <esap> tutorials?
12:54:26 <Re-Born> for learning haskell
12:55:07 <esap> which one? the SICP or the thomson book?
12:55:31 <esap> SICP uses scheme.
12:56:05 <Re-Born> well i just went to a few links and cant seem to find anything which is gonna help me with my work
12:56:54 <esap> oh sorry, I missed that you just came here [I just referred to SICP and another haskell book on the web]
12:57:39 <Re-Born> this language is hard
12:58:36 <esap> Well, I'd say it's not hard, it's just different :-) You need a specific kind of way of thinking to understand it. Learning that is hard :-)
12:59:02 <Smerdyakov> Re-Born, let me guess: You are taking a "programming languages survey" course, and the teacher expects you to learn Haskell in a week. :)
12:59:35 <Re-Born> nah im takin a functional programming course and the lecturer expects us to know everything in a week
13:00:16 <Tomasso> esap: that book is too advanced,,.. i think
13:00:23 <Tomasso> its type theory
13:00:38 <esap> tomasso: ok, then try SICP, I learned functional programming from it.
13:00:46 <Re-Born> my friends been at our coursework for like 13 hours and only halfway through question 1
13:00:52 <Tomasso> SCIP?
13:00:58 <Tomasso> is it available online?
13:01:06 <esap> tomasso: yes.
13:01:24 <esap> tomasso: http://mitpress.mit.edu/sicp/
13:02:11 <Tomasso> let me check
13:02:58 <Re-Born> well im findin this harder than c++ and java at the moment
13:03:18 <Tomasso> hhm do you know if it is available in ps or pdf
13:03:52 <Tomasso> Re-Born: an algortihm that in c++ takes 30 lines here takes 4
13:04:52 <Re-Born> im just havin trouble understandin it
13:05:00 <Re-Born> thats why i need a good tutorial
13:05:35 <Tomasso> mhhm yeah, that is because its not imperative
13:05:59 * jao is back (gone for 02:36.27)
13:06:04 <Tomasso> you dont tell the computer what to do, you just write definitions
13:06:42 <esap> reborn: have you tried to read the tutorials on http://www.haskell.org/learning.html?
13:06:51 <Re-Born> yeah im going through em now
13:07:49 <Tomasso> hmhm esap, that book is only available in html... ?
13:08:04 <Tomasso> seems to be widely used in functional programming courses
13:08:27 <esap> tomasso: I'm not sure, that was the first version I found :-)
13:08:39 <Tomasso> hehehe
13:08:45 <Riastradh> Tomasso, it's available in PDF or something somewhere else...Google will help you.
13:09:37 <Tomasso> Riastradh: let me check
13:09:40 <esap> http://www.itlabs.umn.edu/HyperNews/get/gopalan/courses/CSCI5106-Spring-2003/class/1.html?nogifs says it is no longer available in ps and pdf versions, and suggests how to get a text-only version.
13:11:34 <Tomasso> hahaha why do they do that?
13:21:36 <Re-Born> where can i get a ps reader?
13:23:38 <Heffalump> what OS?
13:23:40 <Tomasso> ghostview
13:23:49 <Heffalump> but yeah, google for that
13:24:26 <Re-Born> xp
13:25:19 <Re-Born> is it easy to convert types in haskell?
13:25:58 <Re-Born> well type conversions
13:26:56 <esap> standard library has several type conversions (e.g. fromInteger or fromIntegral). But usually you don't need them.
13:28:54 <Re-Born> well ive got to write a function to convert like int to string, string to int, natural numbers to decimal representation as strings and vice versa
13:29:29 <esap> there are functions 'show' and 'read' for doing string->int and int->string conversions.
13:30:09 <esap> show is for turning things to strings, and read is for reading from a string.
13:31:45 <Re-Born> which tutorial could i read up on that?
13:32:30 <ink|work> Yet Another Haskell Tutorial is pretty good
13:32:36 <ink|work> that's what i went through about 6 months ago
13:33:15 <ink|work> of course, i was promptly lost after doing the Binary Tree thing, but that's ok :)
13:33:47 <Lunar^__> Hudak's book is really great
13:35:10 <ink|work> i had Simon Peterson (i think that name is right)'s book, but i lost it :\
13:35:15 <esap> Gentle intro has about 'show' and 'read' in section 'standard haskell classes'.
13:35:54 <Re-Born> the yet another haskell tutorial wasnt very helpful
13:36:41 <ink|work> i've been toying w/ the idea of getting back into haskell
13:36:53 <ink|work> but i've been lusting after scheme for the past couple months
13:37:04 <ink|work> and i'm curious about the ML's
13:39:43 <Re-Born> these tutorials aint gettin me anywhere
13:40:23 <esap> what's the problem? What things seem hard?
13:41:22 <Re-Born> converting natural numbers to decimal representation as strings
13:42:07 <esap> just use 'show'. Like 'show 10' would produce "10".
13:42:42 <Re-Born> i need to write a function that does that
13:42:49 <ink|work> could he do: "show <cast to a decimal> 10" ?
13:42:51 <ink|work> or something
13:43:50 <Re-Born> and i need to be able to do the reverse too 
13:47:13 <esap> I think all what you need is in the tutorials.
13:49:27 <Re-Born> well i mean show is a prewritten function, and i can like do show 10 and get "10" but i need to write a function that does that
13:51:33 <ink|work> esap: which tutorials are you referring to?
13:51:42 <ink|work> the ones listed on haskell.org, i assume
13:54:04 <Heffalump> re-born: what uni are you at, out of interest?
13:55:28 <Re-Born> university of leeds (uk)
13:55:47 <Re-Born> i have a clash with one of my lectures so i can only make one a week
13:55:58 <Re-Born> so its hard to follow when you only at half the lectures
13:56:29 <Re-Born> and the lectures notes arent very helpful either
13:58:25 <Re-Born> is what i need to do simple or quite hard out of interest?
13:59:03 <Heffalump> fairly simple
13:59:26 <Heffalump> does it only need to work on integers?
13:59:48 <Heffalump> well, maybe not that simple if you've been doing it a week
14:01:31 <Re-Born> i need to write a function to convert natural numbers to strings like say 1024 to "1024" and vice versa, a function to convert int to string and vice versa like intToString 16 (-12345678) gets "- BC614E" 
14:02:47 <Heffalump> huh?
14:02:50 <Heffalump> I don't understand the last bit
14:02:58 <Heffalump> oh, base 16
14:03:11 <Re-Born> yeah
14:03:19 <Heffalump> ok, so for the first bit, I suggest you work out how to do it for single digit numbers first
14:03:41 <Heffalump> then work out how to reduce dealing with multi-digit numbers to dealing with single digit numbers
14:03:45 <Re-Born> do i require the show function in it?
14:04:00 <Heffalump> I suspect you're supposed to do it without show
14:04:07 <Heffalump> you certainly don't _need_ to use it
14:04:12 <Re-Born> oh okay
14:04:42 <Heffalump> you may find the chr and ord functions useful
14:05:10 <Re-Born> do i have it as String -> String?
14:05:31 <Tomasso> hhm is this ok?
14:05:33 <Tomasso> sumL:: [Int] -> Int
14:05:34 <Tomasso> sumL x = foldr (+) 0
14:05:45 <Tomasso> (sumL sums all the elements of a list)
14:05:58 <Heffalump> that sounds correct, yes
14:06:01 <Riastradh> Tomasso, what is the type of foldr?
14:06:05 <Heffalump> do you have what as String -> String ?
14:06:13 <Tomasso> ERROR "practica7.hs":12 - Type error in explicitly typed binding
14:06:48 <Heffalump> oh, you forgot the x
14:06:54 * Riastradh smacks Heffalump.
14:06:55 <Heffalump> when calling foldr
14:06:56 <Tomasso> Riastradh: (a -> b -> b) -> b -> [a] -> b
14:07:05 <Re-Born> well i've got to have function named natToString, so dont i need to declare types first
14:07:06 <Tomasso> Heffalump: what x =
14:07:10 <Heffalump> riastradh: oh come on, it was just a silly mistake, not me doing his homework for him
14:07:18 <Riastradh> Tomasso, what's the type of 'foldr (+) 0', then?
14:07:25 <Heffalump> re-born: you don't _have_ to declare types first, but it helps a lot
14:07:37 <Tomasso> ho i forgot x :D
14:08:07 <Heffalump> Re-Born: what do you think the type of natToString should be?
14:08:21 <Tomasso> i cant believe :D it works
14:08:22 <Tomasso> haha
14:08:23 <Re-Born> Int -> String i thought but can you do that?
14:08:43 <Heffalump> sounds right to me
14:15:56 <Re-Born> so would i start natToString Ord :: Int -> String or is that wrong?
14:16:27 <Heffalump> that's wrong
14:16:34 <Heffalump> why do you have the Ord bit?
14:17:27 <Re-Born> so just natToString :: Int -> String
14:17:46 <Darius> Of course, you don't want to use foldr for sum.
14:18:27 <Heffalump> re-born: yeah
14:37:50 <Re-Born> which documentation could i find out about ord and chr heffalump>
14:38:00 <basti_> hi
14:39:31 <Tomasso> its dificultto get acostum to use filter map and foldr.. for lists...
14:39:59 <basti_> hi Tomasso...
14:40:04 <Re-Born> whats foldr?
14:40:07 <Tomasso> hello basti_
14:40:11 <basti_> the opposite of foldl? ;)
14:40:18 <Tomasso> yeah :D
14:40:28 <Re-Born> whats foldl?
14:40:42 <Tomasso> the opposite of foldr
14:40:45 <Tomasso> hahahaha
14:40:52 <basti_> Re-Born its an operator that connects elements of a list in a special way:
14:40:58 <Riastradh> foldl kons knil [] = knil; foldl kons knil (h:t) = foldl kons (kons h knil) t
14:41:08 <Re-Born> erm okay
14:41:20 <basti_> [1,2,3,4,5] would become (1*(2*(3*(4*(5*x))))) if you "foldr" with *
14:41:37 <Re-Born> oh okay
14:41:54 <Re-Born> well i dont need that, need to find how to use ord and chr
14:42:05 <Tomasso> haha
14:42:09 <basti_> lol
14:42:11 <Riastradh> foldl and foldr are probably the most general list processing combinators, or they would be, anyways, if kons returned a 'Maybe a' instead of just 'a'.
14:42:23 <Riastradh> (no pun intended)
14:43:10 <Re-Born> been at this for an hour and still on first question *sigh*
14:43:25 <basti_> I'm reading about Monads. This time I understand a little. Maybe because the author was mathematican.
14:43:32 <basti_> Re-Born what you need to do?
14:43:36 <Riastradh> Prelude> ord 'a'
14:43:36 <Riastradh> 97
14:43:36 <Riastradh> Prelude> chr 97
14:43:36 <Riastradh> 'a'
14:43:43 <basti_> sounds good.
14:43:57 <basti_> to me.
14:44:09 <Tomasso> Maybe a = Just a | Nothing
14:44:11 <Riastradh> basti_, monads are simple: they're just CPS functions, except with only one allowed continuation, and they don't necessarily need to be _functions_.
14:44:23 <Re-Born> just need to write a function to convert natural numbers to decimal representation as strings and vice versa
14:44:38 <Riastradh> I.e. you can 'pass' the continuation to things other than functions, such as lists, Maybes, et cetera.
14:44:38 <basti_> Riastradh: I know what Monads are used for... i was interested in the background... all this ARROW and CATEGORY stuff ;)
14:45:12 <basti_> Re-Born: sounds not too hard ;)
14:45:22 <Re-Born> i know but im new to haskell
14:46:20 <basti_> well what would your first step be if you did it by hand?
14:46:26 <Re-Born> the third question seems quite hard, gotta write a function called root2, and have it so if i put root [0..5] i would get [1,4,1,4,2]
14:46:43 <Heffalump> huh?
14:46:48 <basti_> <?>
14:46:49 <Heffalump> oh, I see
14:47:01 <Heffalump> root2 [0..5] is the first 5 (why not 6?) digits of sqrt(2)
14:47:19 <Re-Born> oops missed the 1 after 2
14:47:34 <Re-Born> should be [1,4,1,4,2,1]
14:47:46 <basti_> Re-Born uhm maybe you should start with the easy functions ;)
14:47:57 <Re-Born> yeah im still tryin to do the easy functions
14:48:10 <basti_> how would you start that sort of calculation if you did it by hand?
14:48:21 <Re-Born> what calculation?
14:48:31 <basti_> Number => Decimal Representation
14:49:23 <Re-Born> decimal representation as strings it says, so 1024 becomes "1024"
14:49:37 <basti_> yes.
14:49:47 <basti_> lets stick with the "decimal" part for now ;)
14:49:54 <Re-Born> erm okay
14:49:54 <basti_> we have a number lets call it a.
14:50:02 <basti_> what do you do to a to make it "decimal"?
14:51:11 <Re-Born> add d, e, c, i, m, l to it
14:51:22 <basti_> uhm.
14:51:30 <Re-Born> umm i read that wrong
14:51:34 <basti_> <?> ;)
14:51:45 <Re-Born> a = "decimal"?
14:51:48 <basti_> no
14:51:51 <basti_> a is a number
14:51:57 <basti_> some number in some way we dont know
14:52:16 <Re-Born> erm i dunno
14:52:24 <basti_> hm
14:52:33 <basti_> how about taking the remainder of /10?
14:52:42 <basti_> that would get you the lowest digit
14:52:57 <Re-Born> oh okay
14:53:03 <basti_> maybe.
14:53:15 <basti_> now you could do that recursively
14:53:19 <Re-Born> hmm
14:53:46 <basti_> and maybe get a list back
14:54:04 <basti_> and then you could convert the list to chars elementwise.
14:55:25 <Re-Born> sounds complicated
14:55:33 <basti_> uhm
14:55:34 <basti_> well no.
14:57:05 <Re-Born> well just to have it like convert 1024 to "1024"
14:57:18 <basti_> yeah
14:57:19 <basti_> ;)
14:57:22 <basti_> base conversion
14:57:27 <basti_> so to say.
14:57:49 <Re-Born> so i need to take remainder of /10 for lowest digit, then /100 for next lowest digit?
14:57:59 <basti_> if you do it right its always the same
14:58:02 <basti_> /10
14:58:09 <basti_> remainder => digit, rest => recursion
14:59:05 <basti_> actually its a twoliner.
14:59:50 <basti_> Main> decimal 4245526
14:59:50 <basti_> "4245526"
15:00:10 <Re-Born> two lines?
15:00:15 <basti_> two.
15:01:00 <Re-Born> i had first as natToString :: String -> Int, im guessin you didnt
15:01:23 <basti_> well okay i had no type declaration ;)
15:01:47 <basti_> with that its 3
15:02:13 <basti_> yours is wrong way round btw.
15:02:23 <basti_> nattostring would be Int -> String
15:03:29 <Re-Born> oops
15:03:48 <basti_> :)
15:04:19 <Re-Born> how do i put each one into a list
15:04:51 <basti_> maybe put [] around?
15:10:01 <basti_> Re-Born hows it going?
15:10:16 <Re-Born> erm not too good
15:10:26 <basti_> why?
15:10:30 <Tomasso> remainders:: [Int] -> Int -> [Int]
15:10:31 <Tomasso> remainders x y = map (mody z) x
15:10:31 <Tomasso>                  where mody z = z `mod` y
15:10:45 <Re-Born> erm cos im hopeless at haskell?
15:10:50 <Tomasso> hhm why it returns undefined variable z ?
15:10:54 <basti_> uhm.
15:11:08 <basti_> Re-Born how do you calculate the remainder of a division?
15:11:25 <Tomasso> using mod
15:11:28 <basti_> yep.
15:11:33 <basti_> like (a mod 10) right?
15:11:45 <Tomasso> or just substracting recursively
15:11:47 <basti_> uhm no
15:11:53 <Re-Born> right
15:11:54 <basti_> (a `mod` 10) i wanted to say
15:11:56 <Tomasso> basti_: right
15:11:59 <Tomasso> yes
15:12:35 <basti_> thats a digit of your number isnt it?
15:12:54 <basti_> it should go in a list at the right of your result
15:13:07 <basti_> so you go like .... ++ [(a `mod` 10)]
15:13:10 <Tomasso> basti_: what digit?
15:13:18 <basti_> the lowestvalued
15:13:21 <basti_> the "ones"
15:13:34 <basti_> in decimal system of course
15:13:47 <Tomasso> mhmh
15:13:56 <Re-Born> so the ++ adds it to the list?
15:14:08 <Tomasso> ++ adds things to lists
15:14:22 <basti_> no ++ concatenates two lists
15:14:25 <basti_> to be exactly
15:14:32 <basti_> but the list to the right has just one element
15:14:56 <basti_> (a `mod` 10)
15:16:17 <Tomasso> but why does hugs say undefined variable z?
15:16:20 <Tomasso> ehhehehe
15:16:26 <Riastradh> Tomasso, well, where is z defined?
15:17:09 <Tomasso> in anywhere,... but does it have to be defined?
15:17:30 <basti_> uhm
15:17:30 <basti_> yes.
15:17:30 <Riastradh> Well, if it's not defined, why do you expect hugs to not give you an undefined variable error?
15:17:41 <basti_> | ... |
15:17:51 <Tomasso> for example f x = blah, x is never defined... or it takes the type from f 
15:18:00 <basti_> uhm x IS defined
15:18:16 <Tomasso> then it takes type from f
15:18:38 <Riastradh> x is defined in blah.
15:18:39 <basti_> definition is another beast than type binding.
15:19:21 <basti_> Re-Born: getting better? ;)
15:20:22 <Re-Born> so does the ++ [(a 'mod' 10)] just take the remainder of the number and add it to a list?
15:20:31 <basti_> yes exactly
15:20:43 <basti_> now you got to specify the thing left of ++
15:20:53 <Re-Born> so i wanna first have like a/10 
15:21:00 <basti_> yeah.
15:21:02 <basti_> but not a/10
15:21:11 <basti_> but the decimal represantation of a/10
15:21:17 <basti_> and where do you get that?
15:22:06 <Tomasso> fixed :D
15:22:09 <Tomasso> remainders:: [Int] -> Int -> [Int]
15:22:09 <Tomasso> remainders x y = map (mody) x
15:22:09 <Tomasso>                  where mody z = z `mod` y
15:22:15 <Tomasso> hehe
15:22:19 <basti_> Tomasso: ah.
15:22:22 <basti_> now you defined z.
15:22:34 <Re-Born> erm do you mean the remainder of a/10
15:22:46 <basti_> Re-Born uhm...
15:22:54 <basti_> Re-Born actually i wanna guide you to some idea...
15:23:00 <Tomasso> haha exactly
15:23:17 <basti_> we now split off a digit (mod 10), and then divided by 10, so that another number is the digit to get...
15:23:25 <basti_> ...and so on... ... and so on...
15:23:32 <basti_> (......mmmmmh? ;)
15:24:13 * basti_ goes roundandroundandroun
15:24:30 <Re-Born> i know the idea of the function, just dont know how to write it
15:24:52 <basti_> so you know you got to recurse here? ;)
15:24:59 <Re-Born> yes
15:25:06 <Tomasso> Re-Born: you want to write the mod function?
15:25:31 <basti_> okay... so how do you recursively get "the decimal representation (in a list) of a/10"?
15:25:36 <basti_> to prepend it to your digit
15:26:09 <Re-Born> hold on split off a digit, you mean gettin rid of last digit?
15:26:19 <basti_> uhm yes you do that with a/10
15:26:32 <basti_> resp a `div` 10
15:26:58 <Re-Born> oh cos its an int and not a float right
15:27:05 <basti_> uh yes.
15:27:05 <basti_> :)
15:27:07 <Tomasso> or substracting recursively
15:27:12 <Re-Born> but how ya get the first digit 
15:27:15 <basti_> YES TOMASSO ;)
15:27:21 <Tomasso> haha
15:27:28 <basti_> Re-Born what "first"? why dont you go from back to front?
15:27:40 <Re-Born> well thats what i meant
15:27:43 <basti_> :)
15:27:51 <basti_> simply append the digit you split off at the end
15:27:54 <basti_> not at the front
15:28:07 <basti_> hm?
15:28:14 <Re-Born> im gettin confused again how
15:28:15 <Re-Born> now*
15:28:30 <basti_> well lets say you got a digit... "5"
15:28:44 <Re-Born> k
15:28:45 <basti_> now we could say result = "xyz5" or result = "5xyz"
15:28:53 <Re-Born> ok
15:29:09 <basti_> if we do "xyz5" then it's the ones number
15:29:17 <basti_> so mod 10
15:29:32 <basti_> and append at the right side
15:29:38 <Re-Born> so the mod10 takes the 5
15:29:47 <basti_> no we have maybe 2345
15:29:50 <basti_> mod 10 takes the 5
15:30:12 <basti_> and you append it right to (decimal (a `div` 10))
15:30:33 <basti_> ...?
15:32:02 <Re-Born> natToString n :: (natToString (n 'div' 10)) ++ (natToString (n 'mod' 10))
15:32:02 <Re-Born> ??
15:32:08 <Re-Born> oops = not ::
15:32:09 <basti_> uhm
15:32:17 <basti_> why do you convert that single digit?
15:32:22 <basti_> you can do that better cant you?
15:32:31 <basti_> i mean you got a single digit and need to make a char of it...
15:32:35 <Re-Born> [n]?
15:32:40 <basti_> yes and a list
15:32:43 <basti_> a char in a list
15:32:47 <basti_> best an ascii char
15:33:00 <Re-Born> so [n] = ...
15:33:07 <basti_> uhm no
15:33:11 <basti_> in goes a number
15:33:13 <basti_> out goes the list
15:33:17 <timbod>  anyone about who can answer a basic question on monad transformers?
15:33:17 <basti_> Int -> [Char]
15:33:29 <basti_> timbod depends on how basic it is actually
15:34:00 <timbod> Well, I want to create a combo monad that can read from an
15:34:18 <timbod> implied environment, and can propagate errors..
15:34:31 <timbod> this seems to do the job:
15:34:37 <timbod> type Ref a = ReaderT RefData (Either String) a
15:35:00 <basti_> uhm I heard such a thing is possible
15:35:03 <basti_> ;)
15:35:05 <Re-Born> how imake a digit a char
15:35:07 <Lunar^__> timbod: You could also use an ErrorT around a ReaderT (or vice versa)
15:35:18 <basti_> Re-Born: chr?
15:35:31 <Re-Born> chr [n]?
15:35:39 <basti_> no [(chr blabla)]
15:35:42 <Lunar^__> Re-Born: digits are nicely ordered in the ASCII table
15:35:47 <timbod> Lunar^__: that's my question, what the difference between ErrorT around Reader,
15:35:56 <timbod> versus ReaderT around Error?
15:36:03 <basti_> not chr of a list but a list of a chr
15:36:09 <Lunar^__> timbod: mhhh there's something about it in the tutorial
15:36:52 <Re-Born> not chr of a list but a list of a chr?
15:37:26 <basti_> ;)
15:37:41 <timbod> Lunar^__: I've got the tute open (it's pretty good), but I can't map what it says about StateT+ErrorT to ReaderT+ErrorT.
15:37:49 <basti_> Re-Born you dont want to chr a list. Chr doesnt know how to do lists.  But you want a list with a single chr inside.
15:38:24 <Lunar^__> "If an error means no state could be produced, you would apply StateT to Error. If an error means no value could be produced, but the state remains valid, then you would apply ErrorT to State."
15:38:49 <Lunar^__> timbod: I think it doesn't matter in case of a ReaderT
15:39:07 <phubuh> sort of off topic, but how do i typeset a tilde in LaTeX?
15:39:19 <timbod> Lunar:Yep, but if I sed /StateT/ErrorT/ in your quote, I don't think it makes sense
15:39:21 <Lunar^__> timbod: But mapping ErrorT around ReaderT has more sense to me
15:39:33 <basti_> phubuh \texttilde maybe?
15:39:52 <Lunar^__> timbod: Your computation always need to thread its data, but it can produce error
15:40:27 <timbod> Lunar^__: it's a reader, so it doesn't thread data past an error does it?
15:40:30 <Re-Born> could you give me a simple example basti
15:40:39 <basti_> Re-Born uhm yes.
15:40:48 <basti_> > decimal a = (decimal (a `div` 10))++[(chr ((a `mod` 10) + 48))]
15:41:05 <Lunar^__> timbod: I think so
15:41:20 <Lunar^__> timbod: I think your right then, forget what I said
15:41:36 <Lunar^__> basti_: 48 is really not nice
15:41:40 <phubuh> basti_, ah, it was actually \textasciitilde, thanks!
15:41:48 <basti_> 48?
15:41:48 <basti_> phubuh: okay ;)
15:41:48 <timbod> Lunar^__: anyway, I seem to have the ReaderT around Error working ok with: 
15:41:51 <timbod> type Ref a = ReaderT RefData (Either String) a
15:41:57 <basti_> Lunar^__ what else?
15:42:01 <Lunar^__> basti_: chr '0' would be better than a magic number I think
15:42:05 <basti_> yes okay.
15:42:06 <phubuh> i was considering making a space and drawing a tilde with a pen after printing :-)
15:42:11 <basti_> i thoguth about it... ;)
15:42:31 <Lunar^__> basti_: not chr sorry
15:42:38 <basti_> ord
15:42:38 <Lunar^__> basti_: fromEnum
15:42:39 <timbod> Lunar^__: but can't come up with a compilable defintion for the opposite case
15:42:40 <basti_> or this
15:42:41 <Re-Born> natToString n = (natToString (n 'div' 10)) ++ [(chr ((a 'mod' 10)))]? any better
15:42:42 <basti_> ;)
15:42:55 <Re-Born> oops n not a
15:43:06 <basti_> Re-Born yes good except that you need '0' instead of \nul as your first character.
15:43:34 <Re-Born> oh so put + 0?
15:43:37 <basti_> uhm no
15:43:44 <Heffalump> no, cos that'd be the wrong type
15:43:48 <basti_> + (fromEnum '0') Lunar^__ says.
15:43:52 <Lunar^__> Re-Born: x ++ [y] => x:y:[]
15:44:06 <basti_> uh that too.
15:44:20 <Lunar^__> timbod: strange.. what does it says ?
15:44:40 <Re-Born> so where would the fromEnum '0' go?
15:44:52 <Lunar^__> Re-Born: instead of magic number 48
15:44:58 <timbod> Lunar^__: with:
15:45:00 <basti_> Lunar^__ but x is a list itself
15:45:05 <timbod> type Ref2 a = ErrorT (Either String) (Reader RefData) a
15:45:30 <timbod> I'm getting a kind error that I don't really understand.
15:45:34 <Lunar^__> basti_: uh.. sorry I'm tired
15:45:36 <Re-Born> so natToString n = (natToString (n 'div' 10)) ++ [(chr ((a 'mod' 10) fromEnum '0'))]??
15:45:42 <basti_> Re-Born "+"
15:45:48 <basti_> and ()
15:46:03 <Re-Born> so natToString n = (natToString (n 'div' 10)) ++ [(chr ((a 'mod' 10) + (fromEnum '0')))]??
15:46:07 <basti_> uh yes.
15:46:08 <basti_> very good.
15:46:38 <basti_> now you only need to end the recursion
15:46:41 <Lunar^__> Re-Born: You can remove a lot of parenthesis now
15:46:52 <Lunar^__> timbod: Either a b
15:47:20 <Re-Born> erm..end the recursion?
15:47:24 <basti_> uh yes.
15:47:27 <basti_> try what you have now
15:47:59 <timbod> Lunar^__: but I though that the monad constructor is (Either String) - this works for the other case.
15:47:59 <Re-Born> i did and got improperly terminated character constant
15:48:09 <Lunar^__> timbod: runErrorT :: forall a e m. ErrorT e m a -> m (Either e a)
15:48:12 <Heffalump> your 'div' and 'mod' should be `div` and `mod`
15:48:17 <basti_> Re-Born uhm
15:48:26 <Heffalump> ` ` is for turning functions into operators, and ' ' is for characters
15:48:27 <Lunar^__> timbod: It's running the monad that will let you with an Either
15:48:31 <basti_> yep Heffalump
15:48:32 <Heffalump> (and "" is for strings)
15:48:56 <Heffalump> I don't see any improperly terminated character constants
15:49:32 <Re-Born> natToString n = (natToString (n `div` 10)) ++ [(chr ((n `mod` 10) + (fromEnum `0`)))]?
15:49:39 <basti_> uhm '0'
15:49:41 <Re-Born> oh
15:49:43 <Lunar^__> timbod: try  type Ref2 a = ErrorT String (Reader RefData) a
15:49:43 <basti_> 0 is a character here
15:50:16 <Darius> (Either String) is a monad, not a monad -transformer-.
15:50:17 <Re-Born> natToString n = (natToString (n `div` 10)) ++ [(chr ((n `mod` 10) + (fromEnum '0'))]?
15:50:24 <basti_> uh looks good.
15:50:29 <Lunar^__> timbod: "ErrorT e m a" <--- here e = String, m = Reader RefData
15:50:38 <Heffalump> you should use ord, rather than fromEnum, btw, it's designed to be paired with chr
15:50:49 <Heffalump> well, it looks good apart from the fact that it won't work
15:50:52 <Lunar^__> Heffalump: didn't know that, thanks
15:50:58 <basti_> it wont why?
15:51:02 <Re-Born> syntax error in expression (unexpected `]`) error
15:51:09 <Heffalump> re-born: ok, check brackets
15:51:09 <basti_> uhm
15:51:18 <basti_> yes
15:51:19 <Heffalump> basti_: lack of a base case in the recursion?
15:51:29 <Re-Born> oh yeah missed a )
15:51:32 <basti_> Heffalump yes
15:51:42 <basti_> Heffalump we mentioned that before ;)
15:51:55 <Re-Born> ERROR - C Stack overflow
15:51:57 <Heffalump> yes, I know :-)
15:52:01 <basti_> Heffalump Re-Born is still busy with all the ++ [] ! . 
15:52:08 <Lunar^__> Re-Born: CQFD
15:52:12 <Heffalump> re-born: right, now think about what'll happen with natToString 1
15:52:23 <Heffalump> what will it do?
15:52:59 <Re-Born> hope it returns "1" ;)
15:53:11 <Heffalump> well, that's what you hope
15:53:16 <basti_> ;)
15:53:20 <Heffalump> but what precisely will happen when you call natToString 1 ?
15:53:32 <basti_> apparently it rather does ERROR C Stack overflow whats far from "1" i think
15:53:51 <Re-Born> divides by 10 and takes the mod and puts in list?
15:53:56 <basti_> yeah
15:53:59 <Re-Born> i put 1024
15:54:02 <basti_> what happens to the divide part?
15:54:02 <Re-Born> and got taht error
15:54:11 <basti_> what happens to the divide part in case 1?
15:54:36 <Re-Born> it repeats again?
15:54:44 <basti_> uhm yes. but with what value now?
15:54:48 <Re-Born> 0
15:54:51 <basti_> yes.
15:55:02 <basti_> what should happen when you get "0" as value?
15:55:12 <Re-Born> recursion ends
15:55:14 <basti_> yep.
15:55:16 <basti_> in what?
15:55:24 <Re-Born> huh
15:55:28 <basti_> i mean
15:55:37 <basti_> whats the value of the recursion end
15:55:48 <basti_> the very first digit
15:56:05 <basti_> with 1024 you get ???++[1]++[0]++[2]++[4]
15:56:06 <Re-Born> huh
15:56:16 <Re-Born> 0
15:56:17 <basti_> where ??? denotes the place where the recursion end should happen
15:56:21 <basti_> uhm 0 is a good one
15:56:29 <basti_> but it will give "01024"
15:56:35 <Re-Born> " "
15:56:37 <basti_> but it treats the number 0 correctly
15:56:37 <timbod> Lunar^__: thanks, I got it passed the compiler. But I think I'm starting to understand the difference, I don't think that the ErrorT wrapping Reader case can generate errors based upon the contents of the threaded state (which is one of the things I need to do!).
15:56:42 <basti_> how about []? 
15:56:53 <Re-Born> oh yeah that could work hehe
15:57:06 <basti_> just an idea
15:57:28 <Lunar^__> timbod: sure it can.. You just have to lift throwError
15:57:46 <Re-Born> okay so do i need an if n = 0 statement?
15:57:56 <Lunar^__> Re-Born: there's no statement in Haskell ;)
15:57:56 <basti_> uhm
15:58:11 <Heffalump> re-born: you could do that, yeah
15:58:17 <timbod> Lunar^-__: yep, just got there, you are right of course
15:58:22 <Heffalump> but you want to be careful that it works if you call it with 0 initially too
15:58:27 <Heffalump> as well as when you don't
15:58:30 <Re-Born> oh
15:58:37 <Re-Born> whats the easiest way to do it then?
15:58:43 <Heffalump> work it out for yourself :-)
15:58:46 <basti_> lol
15:58:57 <basti_> "the rest is left as an exercise to the reader"
15:59:04 <Lunar^__> basti_ ;)
15:59:41 <Lunar^__> Re-Born: Think about making an helper function. You can also optimize this helper function by not using (++) but (:) and reversing the whole
16:00:16 <Lunar^__> Re-Born: think that pattern matching can also work for plain value
16:00:17 <Heffalump> Lunar^__: no, don't confuse the issue
16:00:35 <Heffalump> once it's working it can be made better
16:00:35 <Re-Born> erm
16:00:53 <Lunar^__> Heffalump: sorry... I really problems not pushing too far. 
16:01:25 <Lunar^__> Heffalump: "really have problems"
16:01:29 <timbod> also on monads in general: Now that I have a moderate understanding, I'm starting to find them in (too?) much of my code. Any time I want an error condition, I need at least a Maybe, and then I start using do{} to make things easier, and then I have monadic code all over the place. Does anyone else have this experience?
16:01:40 <Heffalump> timbod: yeah
16:01:47 <Heffalump> sadly most real code does have error checks everywhere
16:02:08 <Heffalump> if you don't care about the which error you get first, you could just throw an exception in pure functional code and catch it in IO
16:02:40 <Lunar^__> timbod: what is your code working on, btw ?
16:03:13 <timbod> Heffalump: I don't like that idea, as I want the error throwing code to be fully useable from other functional code.
16:03:47 <Heffalump> where do you want the errors to be handled?
16:03:50 <timbod> Lunar^__: "code working on" - what do you mean?
16:04:10 <Heffalump> inside the "error throwing code" you just mentioned?
16:04:27 <Lunar^__> timbod: what problems does it solves ?
16:04:44 <timbod> probably often near the top level, (in which case catching in the IO monad) is OK. But I don't want to make that call at the time I write the code.
16:05:10 <Re-Born> so basti is the ending of recursion the second line of what you got?
16:05:39 <Heffalump> timbod: not much you can do then, sorry
16:05:48 <timbod> Lunar^__: unofficial project for a financial institution
16:06:33 <oligarca> Hey there! I've been looking at HaRe's demo (http://www.cs.kent.ac.uk/projects/refactor-fp/hare/demo.html) and looks quite nice. But what exactly is "refactoring"?
16:07:10 <timbod> Heffalump: It's not so bad, but the do syntax irritates me a bit, in that much syntax needs to change in getting from functional expressions to do based (or >== for that matter) monadic code.
16:07:48 <timbod> (I meant >>=)
16:08:22 <Re-Born> can i get a hint on ending the recursion? hehe
16:08:52 <timbod> oligarca: refactoring is improving the structure and form of existing code without changing it's functionality
16:09:31 <Lunar^__> Re-Born: traditionnal way : use if ; Haskell way : use another equation
16:10:10 <Re-Born> ughhh another equation
16:10:10 <oligarca> timbod: :-) hmm. that's it. thanks.
16:10:40 <Re-Born> does it involve the enum
16:10:53 <Heffalump> timbod: I'd really like some TH that automatically lifts code to be monadic
16:11:08 <timbod> TH ??
16:11:16 <Cale> template haskell
16:11:18 <Lunar^__> Heffalump: Buddha is nearly doing that, no?
16:11:41 <Heffalump> it does?
16:11:47 * Heffalump hasn't looked at it
16:12:08 <Lunar^__> Heffalump: Buddha is really impressiv
16:12:12 <Heffalump> timbod: oh yes, liberal use of liftM et al might help
16:12:20 <Lunar^__> Heffalump: as long as you stay in pure functional code (no monads)
16:12:34 <timbod> True, but that's messy in it's own way.
16:12:49 <Re-Born> (fromEnum '0' <-- what does that do
16:13:17 <Heffalump> re-born: change it to ord '0'  - has the same effect but it's more sensible
16:13:22 <Lunar^__> timbod: The best practice is to rename liftM, liftM . liftM etc to what it really does (liftToError)
16:13:27 <Heffalump> chr (ord c) == c
16:13:33 <Heffalump> if that helps you understand what it does
16:13:53 <Re-Born> whats the relevance of it in my program?
16:14:05 <Heffalump> I'll leave you to work that out for yourself :-)
16:14:33 <Re-Born> oh come on, i been on this for like 2-3 hours and aint even done half of question 1
16:14:34 <Lunar^__> Re-Born: Are you on Unix or similar ?
16:14:41 <Re-Born> windows xp
16:14:58 <Lunar^__> Re-Born: no man ascii then... let me explain
16:15:25 <Lunar^__> Re-Born: In the ASCII table, characters from 0 to 9 are ordered
16:15:51 <Lunar^__> Re-Born: So when you want the n-th digit character, what do you do ?
16:16:29 <Lunar^__> Re-Born: character code for the zero character + n
16:16:38 <Re-Born> right
16:17:12 <Lunar^__> ord '0' => 48 ; ord '1' => 49 ; ord '2' => 50 ; ...
16:17:36 <Re-Born> so why i got fromenum '0' in my program?
16:17:46 <Heffalump> I don't know, it's your program...
16:17:56 <Heffalump> As I've said repeatedly, I think you should have ord in it.
16:18:00 <Heffalump> As it happens, they do the same thing.
16:18:04 <Lunar^__> fromEnum is like ord for any enum type
16:18:26 <Lunar^__> Use ord, it's just nicer when handling characters
16:18:32 <Re-Born> but still what purpose does the fromenum play in my program?
16:19:07 <Lunar^__> fromEnum '0' => 48 as does ord '0'
16:19:21 <Re-Born> erm okay now whats with the 48
16:19:26 <Heffalump> *sigh*
16:19:29 <Lunar^__> *sigh
16:19:29 <Re-Born> why have that in my program
16:19:42 <Heffalump> well, try your program without it and see what happens
16:20:22 <Lunar^__> Play with chr and ord functions in Hugs, understand how they work first
16:20:47 <timbod> Lunar^__: is there a tricky way to use liftM to lift a binary function? ie  (...something.. (+)) :: m Int -> m Int -> m Int 
16:20:57 <Re-Born> error c stack overflow
16:21:24 <Heffalump> did you fix the recursion problem?
16:21:47 <Lunar^__> @prelude liftM2
16:21:48 <lambdabot> *** "liftM2" prelude "Haskell Standard Prelude Dictionary": text follows
16:21:48 <lambdabot> liftM2
16:21:48 <lambdabot>   liftM2 ::  (Monad m) => (a -> b -> c) -> (m a -> m b -> m c)
16:21:48 <lambdabot>   liftM2 f          = \a b -> do { a' <- a; b' <- b; return (f a' b') }
16:21:49 <Re-Born> i was tryin it without enum
16:21:49 <lambdabot>                                    (m a -> m b -> m c -> m d)
16:22:16 <Re-Born> thats the error i got without the fromEnum '0'
16:22:37 <Lunar^__> Re-Born: fix the recursion first
16:22:43 <timbod> Lunar^__: oops, of course. Now you point it out I think I've even used it before
16:22:48 <Heffalump> does the same problem happen with the fromEnum '0' ?
16:24:12 <Re-Born> no i get garbage collection fails to claim sufficient space
16:25:30 <Lunar^__> Re-Born: means also that the recursion never ends
16:25:38 <Lunar^__> G'night everyone
16:25:57 <Re-Born> 4G12ood 4N12ight
16:26:04 <timbod> Lunar^__: thanks for the help
16:26:44 <Re-Born> i still get c stack overflow without the fromEnum '0'
16:28:19 <Heffalump> right, well fix the garbage collection error you get with it
16:29:12 <Re-Born> i dont know how to end the recursion
16:29:27 <Heffalump> you suggested one way yourself
16:29:42 <Re-Born> if n = 0
16:30:03 <Re-Born> but i dunno how to go about it
16:31:13 <Heffalump> well, try
16:31:36 <Re-Born> how do i just return natToString if n == 0?
16:32:17 <Heffalump> try using an if ... then ... else expression
16:32:26 <Heffalump> for example, it can be used like this:
16:32:42 <Heffalump> fact n = if n > 0 then n * fact (n-1) else 1
16:34:06 <timbod> why c# and java are better than haskell: http://blogs.gotdotnet.com/emeijer/PermaLink.aspx/30391acc-49e2-4365-ad1d-2d287ef64460 (I wouldn't be lurking here if I agreed)
16:34:14 <Re-Born> yes but what do i have on the else? cos i want it to return n
16:38:40 <Heffalump> timbod: that was quite funny
16:38:49 <Heffalump> (are you aware of Erik's background?)
16:39:15 <Heffalump> re-born: try to do something similar to what my example does
16:39:18 <Re-Born> omg i got it
16:39:35 <phubuh> timbod, hee hee
16:39:42 <Re-Born> i finally done first half of question 1 heh
16:39:59 <Heffalump> how fast are you expected to do these questions?
16:40:18 <Re-Born> prolly a lot faster than im doing em
16:40:49 <Re-Born> but i mean i got a clash with this module so i can only make one lecture per week, have to read up notes on other lecture
16:40:53 <phubuh>  Pure functional programmers, your days are numbered. The grim reaper is knocking at your door.
16:40:53 <phubuh> :O
16:41:03 <phubuh> good think I lock my doors
16:41:16 <phubuh> ... that apparently wasn't "good think"
16:41:22 <phubuh> i'm going to start using that phrase
16:41:34 <phubuh> or maybe sleep/drink more coffee
16:41:41 <Re-Born> okay now i need to do the reverse of that program
16:42:01 <Heffalump> well, I'm about to go to bed :-)
16:42:09 <Re-Born> quick hint?
16:42:09 <phubuh> good night, Heffalump :-)
16:42:24 <Heffalump> process the input one character at a time
16:42:24 <timbod> Heffalump: I've seen his name, but don't know who he is?
16:42:44 <phubuh> timbod, he was very involved in the design of Haskell
16:42:46 <Heffalump> timbod: he (co-)wrote the functional programming with lenses, barbed wire etc paper
16:43:06 <phubuh> he did lots of things :-)
16:43:44 <timbod> That make's it funnier, I think - although I'm not quite sure how to interpret his tone in that case.
16:43:54 <Heffalump> well, where about = sometime soon, honest
16:43:58 <Smerdyakov> I don't think he argues convincingly for any sort of point.
16:44:12 <Heffalump> but I'll get there quicker if I stop trying to help with Haskell homework :-)
16:44:21 <Heffalump> Smerdyakov: no, not really
16:44:57 <Smerdyakov> Iterators correspond with fold, not unfold.
16:45:08 <Heffalump> not true
16:45:15 <Heffalump> not the way foreach etc work
16:45:23 <timbod> Given he's an expert, its interesting that he wrote y = foldl' (\y -> x -> y+x) 0 xs using the lambda and not the (+) section
16:45:28 <Heffalump> the interface is precisely that of unfold, as he says
16:45:45 <Heffalump> timbod: I don't think that makes any difference
16:45:57 <Smerdyakov> The interface doesn't matter. What matters is how people do things from a high level.
16:45:59 <timbod> He counts the chars in the comparison
16:47:06 <Smerdyakov> I've been under the impression that everyone in the FP community agrees that iterators are degenerate fold's.
16:47:06 <Heffalump> timbod: oh, good point
16:47:35 <Heffalump> Smerdyakov: the interface that foreach exists is precisely that of unfold, though - it doesn't really correspond with fold at all
16:48:01 <Re-Born> so do i use ord to convert the string to int this time?
16:48:15 <Heffalump> re-born: what's the type of ord?
16:48:20 <Heffalump> aargh, I wasn't going to do that.
16:48:35 <Re-Born> char -> Int
16:48:39 * Heffalump will have students FP work of his own to deal with tomorrow :-)
16:48:57 <Smerdyakov> Heffalump, it doesn't correspond with unfold, either, because it's imperative.
16:49:09 <Heffalump> you could imagine a monadic unfold
16:49:35 <Smerdyakov> I could, but I'd always use a fold instead, with isomorphic parameters.
16:49:57 <Heffalump> isomorphic to what?
16:51:12 <Smerdyakov> To the arguments you'd use with unfold.
16:52:00 <Heffalump> actually, I guess it's not really an unfold cos you don't build a new structure
16:52:04 <Heffalump> a hylomorphism, maybe
16:52:28 <Heffalump> the point is that you use the Iterator interface to probe inductive structure, and then do something with it
16:52:36 <Heffalump> the first part is an unfold and the second part is a fold
16:52:43 <phubuh> i feel so uneducated when you start talking about your crazy morphisms :~(
16:53:10 <phubuh> and then i realize that i just started high school, and that i actually *am* uneducated
16:53:23 <Heffalump> phubuh: I've been studying Haskell stuff for 6 years at uni, I think I have a slight advantage over you :-)
16:54:06 <Heffalump> you're the best 14-year old Haskeller I know, but that's trivially true, so... :-)
16:54:22 <phubuh> that's so awesome. i can't wait 'til higher education.
16:54:31 <phubuh> haha, thanks, i guess!
16:54:36 <Re-Born> is double used in haskell?
16:54:45 <Smerdyakov> Lucky you. You're in a good country for FP in uni. :-)
16:54:55 <Heffalump> re-born: the datatype?
16:54:58 <Heffalump> yes, it's called Double
16:55:57 <phubuh> Smerdyakov, indeed -- i actually heard about haskell for the first time when a couple of IRC friends were talking about how they wished john hughes would leave their campus and let them use some other language :-)
16:56:08 <Heffalump> lol
16:56:25 <Heffalump> I'm sure we'd be pleased to have him back
16:56:49 <phubuh> are you at oxford?
16:57:14 <Heffalump> yeah
16:57:26 <Heffalump> he did his PhD here
16:57:33 <Smerdyakov> Some PL faculty here (UC Berkeley) are petitioning for the creation of an undergraduate PL course. That might mean that there will be an undergrad class here that acknowledges the existence of statically typed FP languages. :)
16:57:46 <Heffalump> Smerdyakov: cool
16:58:25 <phubuh> interesting. in the place where i least expected it, i just today actually overheard someone saying "Haskell is kicking my ass." out of the blue on IRC. he just started taking computer science classes at oxford, i believe.
16:58:38 <phubuh> it's a small world
16:58:41 <Heffalump> oh, name?
16:59:10 <Heffalump> (I promise I won't take it out on him if I know him :-)
16:59:10 <phubuh> all i know is that his irc handle is "aliensex"
16:59:18 <phubuh> hee hee
16:59:33 <phubuh> i could ask him later and get back to you :)
16:59:36 <Heffalump> we teach it to first year UGs in their first term here
17:00:21 <phubuh> oh oh, i know another thing -- he said he'd been given an obtusely defined function, and his assignment was to explain why it wasn't implemented in a more straight forward way
17:00:32 <Heffalump> interesting
17:00:37 <Heffalump> I can't remember the first tutorial sheet yet.
17:00:51 <Heffalump> Oh, was it sometime between 2pm and 6pm our time? (It's 1am now)
17:02:01 <phubuh> 19:16:59
17:02:08 <phubuh> it's 02:01 now
17:02:32 <Re-Born> yup 1am and i've only done half of question 1 *Sigh*
17:02:45 <Heffalump> hmm, so just after the end of his first practical session, I suspect
17:38:29 <jdrake> anone alive?
17:39:09 <phubuh> i'd hope so!
17:39:17 <Heffalump> I'm in bed. Honest.
17:39:29 <jdrake> i am trying nhc98
17:39:44 <jdrake> and I can't get it to accept any lines from a thing I am reading
17:39:53 <phubuh> i'm supposed to be sleeping but i got stuck adjusting the aesthetics of my latex paper :-/
17:39:55 <jdrake> g. Prelude> data Color = Red | Green
17:40:05 <Smerdyakov> I hope the thing you are reading isn't a Spanish novel.
17:40:11 <Heffalump> what's the paper about?
17:40:21 <Heffalump> jdrake: it probably doesn't allow declarations in interactive mode
17:40:28 <Heffalump> hugs doesn't either
17:40:34 <Heffalump> not even sure if ghci would like data declarations
17:40:37 <jdrake> that isn't much good :-)
17:40:39 <phubuh> alternative sources of energy
17:40:56 <Heffalump> ah, homework type stuff :-)
17:41:09 <phubuh> not cool sources like asimovian mininucleics, mundane stuff like bioenergy :/
17:41:10 <phubuh> yup
17:41:21 <Heffalump> one of my housemates is a teacher (11-16 year olds).
17:41:32 <jdrake> the future surely belongs to 'cold fusion' :p
17:42:06 <phubuh> Heffalump, what do they teach?
17:43:21 <Smerdyakov> jdrake, that just means you need to load definitions from a file.
17:43:46 <Heffalump> phubuh: she teaches Science
17:43:50 <jdrake> Smerdy, annoying but necessary I guess
17:44:19 <phubuh> i bet you hear a lot about alternate sources of energy :-)
17:44:19 <Heffalump> it's quite funny how many of the assignments she gives out are answered by cut and paste from the web
17:44:48 <Heffalump> she just googles for phrases in them and writes the URL on them before returning them
17:44:57 <phubuh> haha
17:45:12 <Smerdyakov> jdrake, necessary because all definitions in a Haskell module may be mutually recursive
17:46:12 <jdrake> i am sort of curious - does haskell have a concept of classes like I might be framilar with?
17:46:14 <phubuh> this paper is actually doubly not so -- i sent my work to my team mate, who thought i was sending him information i got from somewhere else, and he wrote a paper from that
17:46:26 <phubuh> jdrake, type classes resemble abstract classes in OOP somewhat
17:46:54 <jdrake> abstract, i.e. pure virtual?
17:46:55 <phubuh> and there's always O'Haskell: http://www.math.chalmers.se/~nordland/ohaskell/ :-)
17:46:58 <phubuh> yeah
17:47:37 <jdrake> i am looking for something that can kind of separate certain sets of operations that belong with a specific type
17:47:56 <jdrake> without invading the global namespace with all the different functions
17:48:23 <phubuh> use modules and qualified imports
17:50:04 <jdrake> qualified imports?
17:50:39 <jdrake> but what you are saying is that it can be done relatively easily?
17:50:50 <phubuh> if you have a module Foo and do "import Foo", everything exported from Foo gets moved into the current namespace
17:51:04 <phubuh> but if you do "import qualified Foo", you have to prefix identifiers from Foo with "Foo."
17:51:22 <jdrake> what about the so called instance pointer 'self'
17:51:26 <Riastradh> jdrake, because Haskell has a real module system, you don't need to worry about polluting the global namespace like you do in Objective-C.
17:51:29 <jdrake> or 'this'
17:52:07 <jdrake> what I am 'worried' about is being able to remember names and stuff like that of things
17:52:13 <Riastradh> Haskell doesn't have an object system.  (see O'Haskell if you want one, but generally you want typeclasses instead, and an object system is a poor but common substitute for those hypothetical purposes)
17:52:13 <phubuh> oh, i'm not talking about OOP -- just a way to stop namespace pollution
17:54:11 <Riastradh> jdrake, how do you get by in other languages if you can't remember names?
17:55:32 <Riastradh> ...
17:56:53 --- mode: stephenson.freenode.net set +b *!23kjhkjf@*
18:00:37 --- mode: ChanServ set +o Heffalump
18:00:47 --- mode: Heffalump set -b *!23kjhkjf@*
18:00:57 --- mode: Heffalump set -o Heffalump
19:38:24 <Leimy_> anyone got a favorite Haskell tutorial I should read as a novice?
19:40:50 <Smerdyakov> What's your background?
19:41:02 <Leimy_> well I know a bit of lisp
19:41:09 <Leimy_> but mainly a C/C++ programmer
19:41:16 <Leimy_> and I've tinkered with Haskell before
19:41:22 <Smerdyakov> The critical bit is if you're comfortable with functional programming already.
19:41:41 <Leimy_> I feel that I am pretty comfortable with functional programming
19:43:22 <Smerdyakov> I know very little about Haskell tutorials, but maybe "A Gentle Introduction to Haskell" would suit you.
19:43:37 <Leimy_> sounds pleasant :)
19:43:41 <syntax-laptop> look at the wiki under LearningHaskell :)
19:43:47 <syntax-laptop> there are several people's recommendations there.
19:43:54 <Leimy_> http://www.haskell.org/tutorial/ ?
19:44:04 <syntax-laptop> ja
19:44:12 <Leimy_> I will try it... thank you :)
19:44:24 * Leimy_ is also trying GHC on panther-seed on a G5 :)
20:57:23 <danols> what is the difference of type vs data ?
20:58:18 <Darius> type is an abbreviation, data/newtype are completely new (compiler-enforced) types.
20:59:38 <danols> can types be recursive ?
20:59:57 <Darius> Not type synonyms (i.e. not using 'type')
21:00:21 <danols> i'm sorry ?
21:00:32 <Pseudonym> data can, and newtype can
21:00:50 <Pseudonym> Note that newtype gives you the same efficiency as type synonyms.
21:01:07 <danols> so we have data type and newtype ? what is the diff between newtype and type ?
21:02:30 <Darius> Check the wiki.
21:03:03 <danols> ok
21:06:36 <Darius> Actually, I don't think there is a specific page on the more apparent differences.
21:08:30 <Darius> Anyways, a newtype is like a type synonym, but you need to explicitly inject/project the values into/out of the type.
21:08:53 <Darius> Data is used to make new data types
21:09:22 <danols> ok
21:09:42 <danols> i'm gonna check the tutorials out
21:09:43 <danols> thank you
21:12:59 <danols> to randomize data do i need to use IO ?
21:13:21 <Darius> No
21:13:55 <danols> what is a simple example ?
21:19:25 <Darius> take 10 $ Random.randomRs (0,10) (Random.mkStdGen 0) :: [Int]
21:19:43 <danols> thanks
21:31:32 <danols> how do i show new data types ?
21:32:36 <Darius> A deriving clause is usually suitable
21:32:47 <danols> what do you mean ?
21:36:13 <Darius> Lookup deriving in a tutorial or the online report.
21:49:56 <danols> crap this is giving me a headache
21:50:31 <danols> i need to make a new data type Node each node has n input connections and n output connections any idea how i could create sucha  data ?
21:51:03 <Pseudonym> What are you trying to model?
21:52:13 <danols> a backpropagation network
21:52:30 <danols> and i do wish to do it in haskell, as i will learn along the way
21:52:53 <danols> i do know a bit of it already
21:53:27 <danols> last time i made perceptron using just lists, i.e. one node with many inputs but that was meassy so i'm trying this new aproach with type and data declerations
21:53:37 <Pseudonym> OK, you may want to consider using a graph library.
21:53:43 <danols> graph ?
21:53:51 <Pseudonym> Hang on.
21:54:10 <danols> so it has all this done for me, but would it be hard if I try doing it myself, this way i'll learn
21:54:36 <Pseudonym> http://haskell.org/ghc/docs/latest/html/base/Data.Graph.html
21:54:36 <Pseudonym> Ah, believe me, implementing mutable cyclic structures is something you don't want to fiddle with yet.
21:55:10 <danols> is the graph library loaded automaticly ? i'm using ghc
21:55:13 <Pseudonym> Anyway, this is just infrastructure.
21:55:35 <Pseudonym> You'll need to import Data.Graph
21:55:35 <Pseudonym> And it's only GHC 6, I think.
21:56:22 <danols> how do you import ?
21:57:01 <danols> i'm reading on it now, hold on
21:57:30 <Cale> "import Data.Graph" :)
21:58:05 <Pseudonym> Mutable cyclic structures are actually an active research area.
21:58:21 <Tomasso> remHeadLast (x:xs:y) = xs {- Is this pattern matching valid ?? -}
21:58:31 <Pseudonym> This is why I suggest that you don't tackle them now.
21:58:57 <Pseudonym> Another possible model is to use stream processor arrows.
21:59:00 <danols> it says not found hmmm is it called Graph.hi ?
21:59:08 <Pseudonym> And that's just going to confuse you.
21:59:12 <Pseudonym> What version of GHC ar eyou using?
21:59:16 <danols> you are already doing that
21:59:17 <danols> latest ?
22:00:35 <Pseudonym> If it's the latest, it should work.  Hmmm.
22:00:53 <Pseudonym> Hang on, right in the middle of something else. 
22:00:53 <danols> it's 6.0
22:00:57 <danols> cool
22:01:16 <Darius> Tomasso: Yes, but the names you use aren't suggestive which probably means it doesn't do what you want.
22:02:57 <Tomasso> hhm Darius, hugs doesnt accept it..
22:03:20 <Tomasso> i wanted to remove the first and the last element of the list
22:04:32 <Pseudonym> Prelude> tail . init $ [1..10]
22:04:33 <Pseudonym> [2,3,4,5,6,7,8,9]
22:04:39 <Pseudonym> Like that?
22:04:52 <Tomasso> exactly
22:04:54 <danols> what is  init for ?
22:04:55 <Pseudonym> Actually, init . tail is probably a littke more efficient.
22:05:05 <andersca> @type init
22:05:06 <Pseudonym> Prelude> init [1..10]
22:05:06 <lambdabot> init :: [a] -> [a]
22:05:06 <Pseudonym> [1,2,3,4,5,6,7,8,9]
22:05:12 <danols> i see
22:05:18 <Darius> @type let f (x:y:rest) = y in f
22:05:19 <lambdabot> let {f ((x : y : rest) $0 (0 y) $0) $0 $0} in f :: [a] -> a
22:05:33 <Pseudonym> Tomasso: (:) doesn't mean what you think it does.
22:05:43 <Pseudonym> You can't do this: [1,2,3]:4
22:05:52 <Pseudonym> Only this: 4:[3,2,1]
22:05:57 <Tomasso> Pseudonym: what do  you mean?
22:05:58 <Pseudonym> @type (:)
22:05:58 <lambdabot> (:) :: a -> [a] -> [a]
22:06:08 <Pseudonym> Does that help?
22:06:22 <Darius> The only reason Hugs wouldn't accept it is if you had a type error.  If you get an error, you should state what it is.  If you get a type error see what the implementation thinks the type should be.
22:06:46 <Tomasso> hhmhm
22:07:49 <Tomasso> i corrected it to remHeadLast (x:xs:y) = [xs]
22:08:05 <Darius> (a type error from a conflicting explicit type signature)
22:08:13 <Tomasso> hugs doesnt complain but when i call the function
22:08:23 <danols> my head hurts lol
22:08:30 <Tomasso> Main> remHeadLast [3,4,5,6,7,8]
22:08:30 <Tomasso> ERROR - Illegal Haskell 98 class constraint in inferred type
22:08:30 <Tomasso> *** Expression : remHeadLast [3,4,5,6,7,8]
22:08:30 <Tomasso> *** Type       : Num Char => [Char]
22:09:48 <danols> can a type be recursive ?
22:09:53 <Darius> Yes
22:10:07 <Darius> You asked this before.
22:10:11 <danols> i know
22:10:15 <danols> but my head hurts
22:10:18 <danols> sorry
22:11:35 <Tomasso> data recursive = Constr Int recursive | Nil
22:13:07 <danols> how would one use that ? now that we a have a new type how do we give it vaules
22:13:49 <Tomasso> in the parameters when you evaluate the function
22:13:51 <Darius> data Maybe a = Just a | Nothing
22:13:55 <Darius> @type Nothing
22:13:55 <lambdabot> Nothing :: Maybe a
22:13:58 <Darius> @type Just
22:13:59 <lambdabot> Just :: a -> Maybe a
22:14:32 <Tomasso> haha lambdaot returns the types of what we say?
22:14:51 <danols> cool
22:20:00 <danols> crap
22:20:01 <Tomasso> where can i find the exact definition of the data list
22:20:13 <Tomasso> notations are weird
22:20:22 <Darius> The Report.
22:20:24 <Tomasso> dont see why i can use [] or ()
22:22:16 <Cale> [a] means a list of values of type a
22:22:34 <danols> does this make sense at all ?
22:22:34 <danols> type Weight = Float
22:22:35 <danols> type Node = [ConnectionIn]
22:22:35 <danols> type ConnectionIn = (Node,Weight)
22:22:59 <Cale> (a,b) means a pair with a value of type a and a value of type b
22:23:31 <Tomasso> yeah, but i dont see why some pattern matchings are done with (x:xs)
22:23:43 <Riastradh> data [a] = [] | a : [a] -- pseudo-code
22:23:45 <Tomasso> and not [x,xs] or smth similar
22:23:56 <Riastradh> [x,xs] is equivalent to x:xs:[].
22:24:20 <Riastradh> (:) is the constructor; [foo,bar] is the convenient syntax.
22:24:42 <Tomasso> and why [a,s,f] belongs to data [a] ?
22:24:53 <andersca> Riastradh: [x,xs] isn't x:xs:[]
22:24:56 <Riastradh> It's a list of elements of type a.
22:25:06 <Riastradh> andersca, no?  What is it, then?
22:25:09 <andersca> unless xs is of type a :)
22:25:13 <andersca> which it has to be
22:25:24 * andersca shuts up now
22:25:30 <Riastradh> Heh.
22:26:08 <Cale> [a] as a type means (arbitrarily long) lists of type a.
22:26:27 <Cale> So [Int] means lists of Ints, like [3,2,2,5,7,1]
22:27:01 <danols> i need to define a Node that has other Nodes as input how could I decleare a new data type like that?
22:27:17 <Cale> : is an infix operator that takes an element and a list and prepends the element onto the list
22:27:22 <Tomasso> then i cant use pattern matching to take the last element of the list
22:27:34 <Riastradh> Tomasso, no, you can't.
22:27:44 <Darius> Not unless you know the size of the list at compile-time.
22:27:49 <danols> data Node a = Node a | Node [a] ?
22:28:54 <Riastradh> OK, yes, you could do some TH hack to do it.
22:29:33 <Riastradh> That is, to be able to write the last element for an N-element list, where N is determined at code-writing-time, without having to write out x:x':x'':x''':x'''':...:last:[].
22:29:39 <Darius> You don't need TH (though that would be convenient)
22:30:16 <Darius> f [_,_,_,_,_,x] = x
22:31:20 <Riastradh> Er, yeah, you could do that too.
22:31:50 <Cale> You probably want a guard though.
22:32:51 <Cale> like f xs | (last xs == foo) = bar
22:33:19 <Darius> If all you want to do is get the last element, use last.
22:33:38 <Darius> Of course, Tomasso has apparently run off.
22:34:40 <Cale> heh. "Oh no, they're talking about Template Haskell!"
22:34:42 <Cale> :)
22:35:13 <danols> i'm going crazy
22:36:20 <Cale> danols: maybe data Rose a = Leaf a | Branch [Tree a] is what you're looking for?
22:36:32 <Cale> er
22:36:37 <Cale> danols: maybe data Rose a = Leaf a | Branch [Rose a] is what you're looking for?
22:36:38 <Pseudonym> I still haven't tried using TH yet.
22:36:52 <Pseudonym> Haven't found a use for it up till now.
22:37:01 <Riastradh> I want real macros, not just metaprogramming!
22:37:11 <danols> ha this is what i had data Node a = ConnectionIn a | Nodes [Node a]
22:37:20 <Riastradh> Oh.  Right.  I can just use Scheme.
22:37:29 * Riastradh goes back to working on SRFI 46.
22:38:07 <danols> so let me see if I understand it , so a node is either by itself or has nodes connected to it right ?
22:39:09 <Cale> danols: That means a node is either a "ConnectionIn" with a value of type a, or a "Nodes" with a list of Node a's
22:39:52 <Darius> Pseudonym: So you've found a use for TH now?
22:39:58 <Cale> I think the naming in the rose tree example makes a bit more sense :)
22:40:13 <Cale> data Rose a = Leaf a | Branch [Rose a]
22:40:24 <danols> was it called Rose ?
22:40:46 <Cale> Trees like this are often called Rose trees apparently.
22:40:56 <Cale> :)
22:41:12 <danols> i see oh ok where could I find an example of trees in haskell that would propably give me a head start
22:41:20 <Cale> Here's a binary tree:
22:42:01 <Cale> data Tree a = Leaf a | Branch (Tree a) (Tree a)
22:42:26 <danols> how would i create a tree than, now that i have a structure for it ?
22:43:00 <Cale> Branch (Branch (Leaf 5) (Leaf 4)) (Leaf 9)
22:43:27 <danols> why do you have Branch (Branch ?
22:43:47 * Cale wishes he had a blackboard
22:43:51 <danols> me too
22:43:56 <Cale> it's just branching twice
22:44:11 <Darius> Somehow I don't think that would do much good for IRC, though I too wish I had a blackboard.
22:44:28 <danols> are you doing an example for binary tree or rose tree ?
22:44:38 <Cale> that was a binary tree
22:45:12 <danols> the top node would be Leaf 9 followed by Leaf 5 and 4 on the bottom ?
22:45:25 <Cale> The root node has on its left a binary tree (which has on its left 5 and its right 4) and on its right 9
22:46:38 <danols> i see
22:47:01 <danols> i think i see the light at the end of the tunnel
22:47:37 <danols> cannot find show function ?
22:48:11 <Cale> data Tree a = Leaf a | Branch (Tree a) (Tree a) deriving (Show, Eq)
22:48:26 <Cale> that'll fix problems with showing and checking for equality :)
22:48:47 <danols> ohhh ok that inherits Show, but why Eq >
22:48:49 <danols> ohhh ok that inherits Show, but why Eq ?
22:48:53 <Cale> no reason
22:48:57 <danols> really ?
22:49:06 <Cale> well, I just added that in case
22:49:15 <Cale> data Tree a = Leaf a | Branch (Tree a) (Tree a) deriving Show
22:49:16 <danols> what does it contain ? 
22:49:18 <Cale> is fine as well
22:49:29 <danols> but i would have to specifiy comparisons explicitly ?
22:49:31 <Cale> @prelude Show
22:49:33 <lambdabot> *** "Show" prelude "Haskell Standard Prelude Dictionary": text follows
22:49:33 <lambdabot> Show
22:49:33 <lambdabot>   class Show a where
22:49:33 <lambdabot>       show      :: a -> String
22:49:33 <lambdabot>       showsPrec :: Int -> a -> ShowS
22:49:35 <lambdabot>       showList  :: [a] -> ShowS
22:49:37 <lambdabot>       -- Minimal complete definition: show or showsPrec
22:49:40 <lambdabot>       show x          = showsPrec 0 x ""
22:49:41 <lambdabot> [16 @more lines]
22:49:45 <Cale> @prelude Eq
22:49:47 <lambdabot> *** "Eq" prelude "Haskell Standard Prelude Dictionary": text follows
22:49:47 <lambdabot> Eq
22:49:49 <lambdabot>   class Eq a where
22:49:51 <lambdabot>       (==), (/=) :: a -> a -> Bool
22:49:53 <lambdabot>       -- Minimal complete definition: (==) or (/=)
22:49:55 <lambdabot>       x == y      = not (x/=y)
22:49:57 <lambdabot>       x /= y      = not (x==y)
22:50:02 <danols> interesting but almost gebrish :)
22:50:26 <Cale> well, show takes a value of your type and turns it into a string
22:50:45 <Cale> to display a value of that type for you, hugs or ghci needs an instance of Show.
22:51:26 <danols> what's a good free editor for haskell i'm using notepad right now :/
22:51:32 <Cale> I like vim
22:51:50 <Cale> If you're using windows, try TextPad. There's a haskell style file for it.
22:51:58 <danols> i know only the basics of vim 
22:51:59 <danols> ok 
22:52:06 <Cale> (you'd need to download and install that though)
22:53:43 <danols> i see
22:54:38 <Darius> I use vim on Windows.
22:55:15 <Cale> yeah, it's available for windows as well, but I usually find most windows users are somewhat uncomfortable with it. :)
22:56:01 <Darius> I bet most people who have only used word processors are uncomfortable with it to begin with.
22:58:16 <danols> worked
22:59:50 <danols> jesus! what did I eat today
23:01:28 <ibid> emacs is good too :)
23:01:39 <ibid> but of course, ed is the standard editor
23:02:34 <Pseudonym> No, cat is the standard editor.
23:02:44 <Pseudonym> Though patch helps.
23:02:51 <Pseudonym> cat - > a.out.gz
23:02:59 <Pseudonym> It's the only way to fly.
23:03:36 <Pseudonym> Really, it doesn't matter which editor you use so long as it a) satisfies a minimum of features, and b) you know it well.
23:03:48 <ibid> no, ed is the standard editor :)
23:03:53 <phubuh> and c) it has built-in tetris
23:03:58 <phubuh> that's really all you need
23:04:04 <ibid> and d) a kitchen sink
23:04:10 <Pseudonym> I prefer my tetris stand-alone.
23:04:37 <Pseudonym> James Clark wrote a validating XML parser in emacs lisp.  Now that's insane.
23:04:50 <ibid> http://www.gnu.org/fun/jokes/ed.msg.html
23:05:02 <phubuh> i read about the people who wrote a haskell lexer in TeX
23:05:55 <ibid> "ED WILL NOT CORRUPT YOUR PRECIOUS
23:05:56 <ibid> BODILY FLUIDS!!"
23:05:58 <ibid> :)
23:06:58 <danols> where can I findout how to use the random function
23:09:13 <Darius> The Report.
23:09:19 <danols> www ?
23:10:13 <ibid> www.haskell.org :)
23:10:54 <danols> thnks
23:12:43 <danols> crap my haead hurts again is it possible to implement a neural network using the Rosy tree ? i need 21 input 17 hidden nodes and 3 outputs
23:13:20 <danols> might be just easier to use lists ?
23:13:43 <Darius> It depends on how you implement propagation and training.
23:14:31 <danols> it's a back propagation network, what i'm confused about how I would create such a tree ? i.e. 3 root nodes
23:14:42 <danols> using the data we defined
23:15:18 <danols> i can see a way of doing it with lists but would like to learn more about haskell, that's why i've spent trying to figure out how this data thing works
23:15:50 <danols> that is all the output nodes are connected to the hidden nodes, and hidden nodes to the input nodes
23:17:40 <danols> am I making sense ?
23:17:47 <danols> or mumbling gebrish lol
23:17:57 <Cale> yeah
23:17:59 <Darius> "gibberish"
23:18:01 <Cale> makes sense
23:18:03 <danols> lols
23:18:28 <Cale> http://www.haskell.org/ghc/docs/6.0/html/base/Data.Graph.html -- if you need a graph
23:18:56 <danols> now that thing is gebrish to me, i'm trying to learn and would like to do it myself
23:19:07 <Cale> okay
23:19:11 <ibid> gibberish
23:19:15 <ibid> please :)
23:19:33 <danols> sorry my english getting goodder and goodder
23:19:54 <danols> Cale care to elaborate ?
23:20:29 <Cale> well, you need to represent this set of nodes and their connections
23:20:31 <Darius> If all you need to worry about is one input layer, one hidden ladder, and one output layer, then a triple (or even pair) of Arrays of lists of weights should work.
23:20:44 <Darius> Assuming it's fully connected.
23:21:02 <danols> feed forward type of network each layer is only connected to the next one
23:21:25 <danols> Darius i see how that could work, but i would like to make something more general and though along the way i'll learn about data declerations
23:21:30 <Darius> I know, but is every node connected to all nodes in the next layer.
23:21:35 <danols> yes
23:21:55 <danols> i was thinking of using list with just weights in them
23:22:17 <danols> but would like to make a data structure to make 'clean' ...
23:22:28 <danols> this is what i have so far lol data Rose a = Leaf a | Branch [Rose a] deriving (Show)
23:22:43 <Cale> that's a tree, not exactly what you want
23:23:02 <danols> figured that when thinking how can i make it a network now crap
23:23:06 <danols> back to square one ?
23:23:43 <danols> isn't there a way to have it similiar to java ? where each object can be connected to another one, that's the aproach i was trying to take
23:24:04 <danols> so i would have an object node, and it could have an array of connections from it
23:24:31 <danols> or is my aproach incorrect due to haskell 'style'?
23:24:53 <Cale> Algebraic data types are not exactly the same as objects.
23:25:13 <Darius> There not even "not exactly" the same as objects.
23:25:21 <danols> :)
23:25:27 <Cale> yeah, that was a bit of an understatement.
23:25:42 <danols> is there a way to represent something like that using data types ?
23:25:59 <danols> like a the way a binary tree is represented ?
23:26:21 <Cale> well, what numbers do you want to store, and what structure would be most convenient for their use?
23:26:30 <Cale> or values, rather
23:26:42 <Cale> I presume it's a bunch of Doubles
23:26:45 <danols> floats, and i need 3 layers an input hidden and output
23:26:47 <danols> yes
23:27:11 <danols> go on
23:27:40 <Cale> okay, so you have the weights between each node in one layer and a node in the next
23:27:49 <danols> yes
23:28:12 <danols> the simple aproach is to use lists, but i was wondering if it could be done with data types ?
23:29:19 <Cale> Well, you can wrap the lists up into data types if it adds some convenience in being able to tell things apart.
23:29:43 <danols> could you give me an example ?
23:30:01 <Cale> Like, as part of being a value of an algebraic data type, each value would get a label, so you can use pattern matching.
23:30:07 <danols> that's what i'm trying to learn making it easier to tell things apart instead of using cryptic lists and stuff
23:30:11 <Cale> I'm not sure how it applies to what you're doing.
23:30:18 <Cale> Okay
23:31:02 <Cale> So you might just say type Weight = Double for the time being
23:31:16 <danols> ok
23:31:26 <Cale> Do all your nodes have the same transfer function?
23:31:46 <danols> yes, if I understand your question correctly
23:32:55 <Cale> okay, hmm...
23:33:53 <Cale> So I suppose that we'd have something like type Layer = [[Weight]], though that isn't saying much.
23:34:25 <danols> hmmm
23:34:32 <Cale> We might be able to have something like Data Node = [Weight] [Node]
23:34:46 <Cale> but that's a little more tricky to work with.
23:34:56 <Cale> er
23:34:59 <danols> what do you mean ?
23:35:11 <Cale> It would be data Node = Node [Weight] [Node]
23:35:28 <danols> hmmm
23:35:40 <Cale> well, you have to build the structure in the first place, right?
23:35:51 <danols> yeah
23:36:30 <Cale> It's easier to fill in a list of connection weights then it is to get a graph structure happening (though that's possible)
23:36:45 <danols> can i paste something ?
23:37:06 <Cale> and for the purposes of computation, you really just want the connection weights anyway - so the Node structure seems too dense.
23:37:11 <Cale> I think it would be okay
23:37:14 <danols> type Weight = Double
23:37:14 <danols> type Layer = [Weight]
23:37:14 <danols> type InputLayer = Layer
23:37:14 <danols> type HiddenLayer = Layer
23:37:14 <danols> type OutputLayer = Layer
23:37:15 <danols> type Network = (InputLayer,HiddenLayer,OutputLayer)
23:37:33 <danols> i think i see what you mean cause each node would contain the same connections in
23:37:37 <Darius> A layer isn't a list of Weights.
23:37:39 <danols> duplicating what all the other nodes have
23:37:54 <danols> Darius ok
23:38:01 <Cale> A layer should be a list of lists of weights.
23:39:23 <danols> a list of lists, crap, isn't that each node gets exactly the same weight from prior nodes ?
23:40:03 <Cale> Well, you want to store the connection weights from each node in the layer, to each node in the next.
23:41:26 <danols> i think my mind is shuting down lol
23:46:34 <danols> to use the random number gen i need to import it right ?
23:48:45 <Cale> yeah, "import Random" should do
23:50:19 <danols> it says there is genRange (int,int) but it is not defined ?
23:50:22 <danols> i've imported Random
23:51:42 <danols> crap
23:53:53 <danols> how do u use it ? 
23:55:39 <Cale> something like
23:55:54 <Cale> randomWeight :: IO Double
23:56:35 <Cale> randomWeight = getStdRandom random
23:57:02 <Cale> that should give an IO Double with random value in the interval [0,1)
23:57:29 <danols> there is no way not to have the IO part i remember a while back that gave me a headache
23:57:44 <Cale> It's quite nice once you get used to it.
23:59:23 <Cale> "randomWeight" here is like a computation that returns a value of type Double if run. You can view it as a box that you might pull doubles out of. The only place you can do that is in the IO monad.
23:59:41 <Cale> so anywhere in the definition of main is fine.
23:59:54 <danols> it displies nothing , do i need to add dervies (Show)
