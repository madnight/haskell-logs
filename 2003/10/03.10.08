00:03:57 <harsha> hi #haskell
00:08:30 <Bananana> hi harsha
00:09:13 <Bananana> Disclaimer: My opinion does not represent that of #haskell
00:09:16 <Bananana> :)
00:45:40 <blackdog> that's ok, Bananana, mine does.
00:50:28 <harsha> top
01:27:11 <Lor> There's no top in haskell, only bottom.
01:36:20 <ejt> morning
02:05:00 <clausen> gday ejt
02:37:02 <shapr> good morning #haskell
02:37:31 <shapr> @yow
02:37:32 <lambdabot> Yow!  Maybe I should have asked for my Neutron Bomb in PAISLEY--
02:54:22 <Lunar^_> shapr: I'm gonna do some Zope programming for leaving
02:54:27 <Lunar^_> s/leaving/living/
02:54:37 <Lunar^_> Wonder how many Haskell hackers do that ;)
02:55:52 <vegai> I guess you're not using haskell for that...?
04:32:27 <shapr> Lunar^_: oh, I want to integrate Zope and Haskell
04:44:33 <earthy> what for? :)
05:07:22 <shapr> earthy: because I have existing Zope sites, my clients want more of those.
05:14:11 <earthy> but you want to do more haskell..
05:14:12 <earthy> right
05:14:29 <shapr> yes, you got it.
05:14:51 <shapr> tapl is really cool
05:15:01 <shapr> I'm only about thirty pages in, but it's spiffy
05:15:08 <shapr> I do have questions about some of the definitions
05:15:39 <Igloo> Oh?
05:15:52 <shapr> there's a symbol that's a U lying on its side, with a line under it
05:16:04 <shapr> Igloo: you have TAPL handy? I can point to the page/definition number
05:16:33 <Igloo> Yup
05:16:46 <Igloo> That's a subset symbol if that's the question
05:17:03 <Igloo> The line underneath meaning the subset might be the entire set
05:17:39 <shapr> so it's 'sub or equal to' much like 'less than or equal to' ?
05:17:44 <Igloo> Yup
05:18:27 <shapr> which end is the sub end? the bottom of the U ?
05:18:42 <Igloo> Yes
05:18:50 <ski> the open end is similar to the open end of <
05:18:59 <shapr> I had guessed that, but wasn't sure
05:19:01 * jao is back (gone for 01:07.51)
05:19:13 <shapr> hi jao, I have the category theory book
05:19:33 <jao> hi! oh, nice! which one?
05:19:45 <shapr> the one you recomended
05:19:55 <jao> good choice :)
05:19:58 <shapr> heh
05:20:02 <jao> are you enjoying it?
05:20:11 <shapr> I've only read the first few pages, it looks good so far.
05:20:15 <shapr> but TAPL is distracting me
05:20:23 <ski> tapl ?
05:20:32 <jao> you mean knuth's taopl?
05:20:35 <shapr> bcpierce - Types and Programming Languages
05:20:41 <ski> which (category) book ?
05:20:55 <shapr> I've forgotten the exact name and author
05:21:11 <jao> (oh, silly me: it's knuth's taocp, of course)
05:21:18 <shapr> I had to choose between bcpierce's category theory book and another one, and jao recommended the other one.
05:21:33 <jao> it's called 'conceptual mathematics'
05:21:43 <jao> but i don't remember the authors
05:21:44 <shapr> yes, that's it
05:21:56 <shapr> 'introduction to category theory' or something
05:22:12 <jao> published by cup
05:23:28 <jao> F. William Lawvere, Stephen Hoel Schanuel. Conceptual Mathematics: A First Introduction to Categories. 1997. Cambridge University Press.
05:23:41 <jao> that's it
05:23:54 <shapr> I don't understand Definition 2.1.3 in TAPL, what does the X mean between S1 X S2 X S3 ... X Sn ?
05:24:17 <shapr> why does it use a comma in the collection of sets and the X for the tuples part?
05:25:13 <shapr> I think I should download the references at the end of the Definitions section that give intros to set notation and set theory
05:25:13 <ski> X is cartesian prouct, presumably ?
05:25:18 <shapr> I don't know
05:25:19 <ski> prouct
05:25:24 <ski> product
05:25:45 <ski> (damn keyboard, bad 'd' key)
05:25:54 <shapr> buy a kinesis :-)
05:26:13 <earthy> ;)
05:26:14 <jao> i'd say its cartesian product, too. i.e., the set of tuples (x1,..,xn) where xi belongs to Xi...
05:26:34 <jao> s/its/it's
05:26:51 <ski> often the cart. prod. is an X in a circle, but not always, i think
05:26:58 <jao> and Si
05:27:43 <jao> yeah, i've seen it represented simply by x in math books
05:27:49 <jao> quite often
05:29:22 <earthy> I've almost never seen it as an X in a circle
05:29:29 <smkl> x in a circle is tensor product
05:29:32 <earthy> and virtually always as just x
05:29:58 <shapr> @foldoc "tensor product"
05:29:59 <ski> my math lexicon uses a circle aroun it
05:29:59 <lambdabot> *** "tensor product" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
05:29:59 <lambdabot> tensor product
05:29:59 <lambdabot>      
05:29:59 <lambdabot>         <mathematics> A function of two {vector spaces}, U and V,
05:29:59 <jao> earthy: yup, that's my experience, too
05:30:00 <lambdabot>         which returns the space of {linear maps} from V's {dual} to U.
05:30:02 <lambdabot>      
05:30:04 <lambdabot>         Tensor product has natural symmetry in interchange of U and V
05:30:06 <lambdabot>         and it produces an {associative} "multiplication" on vector
05:30:08 <lambdabot> [28 @more lines]
05:30:15 <shapr> I gotta add the whitespace line cleaning
05:33:44 <Igloo> It means   R is a subset of [ (x1, x2, ..., xn) | x1 <- s1, x2 <- s2, ..., xn <- sn ]  in Haskell-speak
05:34:08 <shapr> ah, that's crystal clear to me :-)
05:34:34 <det> shapr: so what kind of haskelly things are you up to now ?
05:34:43 <shapr> det: zope mostly
05:34:47 <shapr> and it's not very haskelly
05:34:57 <shapr> I'm reading TAPL at the moment
05:35:21 <shapr> det: what are you up to?
05:35:24 <det> TAPL ?
05:35:53 * det guesses
05:36:02 <det> Truth About Prgramming Languages
05:36:27 <shapr> Types and Programming Languages
05:36:35 <shapr> I want to understand System F and cohorts
05:36:36 <det> how is it ?
05:36:44 <shapr> it's fun!
05:36:56 <det> shapr: I'm playing with Standard ML/MLton
05:37:04 <shapr> cool
05:37:17 <det> SML tendancy to use tuples instead of curried functions really bothers me however
05:38:50 <det> it seems you cant apply the + operator to fold to produce a sum function because (op +) is a function of 1 argument, a 2-tuple
05:39:22 <shapr> I've heard you have a separate operator for int/float/etc
05:39:26 <shapr> something like .+. ?
05:39:42 <earthy> det: curry? :)
05:39:44 <phubuh> ocaml does that, i'm not sure about SML
05:39:45 <ski> in O'Caml : +.
05:40:08 <Maddas> (for float)
05:40:08 <ski> SML has a few built-in overloaed operators
05:40:08 <phubuh> i really want ocaml with type classes
05:40:11 <shapr> the code in TAPL is written in OCaml, I wonder if it's already been ported to Haskell
05:40:17 <Maddas> TAPL?
05:40:28 <shapr> Types and Programming Languages, by Benjamin C. Pierce
05:40:34 <det> shapr: not in SML, ocaml is like that however
05:40:34 <Maddas> ok
05:40:37 <shapr> I have to reinstate @fact sometime soon
05:40:57 <smkl> SML overloads some ops for integers and floats, so you don't have +. etc. the types are never overloaded though
05:41:01 <ski> see http://www.smlnj.org/doc/Conversion/top-level-comparison.html for which operators are overloaded
05:41:07 <det> phubuh: did you ever read the link I gave you
05:41:51 <smkl> in ocaml, most functions are curried
05:42:17 <phubuh> det, about using structs instead of objects in ocaml?
05:42:22 <det> phubuh: yes
05:42:26 <phubuh> yes
05:42:39 <det> phubuh: same effect as type classes with just a little bit more verbosity
05:43:41 <det> smkl: SML, it seems, prefers tuples instead for alot of things :/
05:44:30 <smkl> det: do you still have that link?
05:44:55 <Lunar^_> shapr: If I'm finally working there, I will try also I think
05:45:07 <Lunar^_> shapr: Even as a side project, that would be cool
05:45:30 <det> I'll find it
05:45:49 <det> smkl: http://caml.inria.fr/archives/200308/msg00268.html
05:45:53 <phubuh> det, well, sort of, but i still prefer type classes -- the main reason i want them in ocaml is to get rid of (+.), (*.), and their friends
05:47:02 <det> do most haskell compilers optimize away the overloading ?
05:47:19 <shapr> Lunar^_: are you changing jobs?
05:47:26 <det> possibly specialize functions for different type classes ?
05:48:31 <det> or does it have to dispatch for each (+), (*), etc ?
05:48:38 <Igloo> You can direct GHC to specialise for certain types. I think it will do it itself if the type is guaranteed unique too
05:48:51 <ski> i woul think that optimizing away dictionary passing (usual impl.) would usually not be so hard on monomorphic uses of overloaded names
05:49:40 <Maddas> phubuh: the most annoying thing for me is converting e.g. something that uses integers to something that uses Int64
05:49:48 <Maddas> as you don't even have "operators" in that sense anymore
05:49:51 <phubuh> heh, yes
05:49:57 <det> ski: I am just curious if a haskell compile would create multiple functions for "add a b = a + b" or if it would need to dispatch on the +
05:50:52 <Igloo> If that's all you had it would dispatch
05:50:55 <ski> det : i guess it could depend on, if you have a monomorphic type-sig of add or not
05:51:02 <smkl> Maddas: you can locally redefine (+) if you want to
05:51:12 <Igloo> It can't create *all* the function there anyway as you might make another instance in a module that imports that one
05:51:19 <Maddas> smkl: yeah, but that's not, well, "nice" :)
05:51:59 <ski> det : i think, in ghc, one can give specialize pragmas to explicitely request specializations of a polymorphic value to more specific types
05:52:37 <det> Igloo: this makes me like whole-program optimization :)
05:53:06 <det> ski: and code that uses that module will know about the specialization ?
05:54:16 <ski> det : code using that module at (an instance) of one of the specialized instances will automatically use the more specific version, IIRC
05:55:48 <det> ehh, SML is wierd ..
05:55:48 <det> - (op +);;
05:55:49 <det> val it = fn : int * int -> int
05:55:49 <det> - (op +) (4.1, 5.8);;
05:55:50 <det> val it = 9.9 : real
05:56:42 <ski> it just defaults to int
05:57:11 <ski> i think haskell has a rarely-used default-keyword ..
05:57:20 <shapr> ?
05:58:32 <phubuh> yeah, you can change the default num implementation
05:58:40 <phubuh> i think
05:59:20 <smkl> those ops are handled as a special case in the SML type system
05:59:30 <ski> shapr : see http://www.haskell.org/onlinereport/decls.html#overloading at 4.3.4 Ambiguous Types, and Defaults for Overloaded Numeric Operations
06:00:10 <ski> shapr : also the BNF at the top of the page
06:00:16 <det> smkl: at lest it could claim they were polymorphic, like ocaml comparison operators
06:00:34 <det> althought I guess it doesnt work on all values like ocaml cmp ops
06:02:04 <smkl> comp. ops don't work for all values, too. in SML, there is a separate eqtype keyword for declaring types for which comparations (or at least equality) works
06:02:45 <det> smkl: comparison operators do work for all types in ocaml
06:04:33 <smkl> well, they typecheck, but they'll throw exceptions, if there is wrong type ... this couldn't be done for addition very easily because ints and data type constructors are represented in the same way
06:05:57 <det> when will they throw exceptions ?
06:06:10 <smkl> (fun x -> x) = (fun x -> x)
06:06:55 <det> oh, yes, it can't compare functions :)
06:08:05 <smkl> SML won't compare reals for equality, i think
06:09:03 <det> wow
06:09:21 <det> why wont it do that ?
06:09:24 <ski> true
06:09:39 <ski> it is not efined as an equality type, perhaps
06:10:21 <det> I mean, what is the reasoning behind this ?
06:11:13 <ski> floating point inexactness (?)
06:11:51 <phubuh> does it at least have an approximate equality operator? ;-)
06:12:20 <det> phubuh: probally you have to define that yourself :)
06:12:28 <ski> - Real.==;;
06:12:28 <ski> val it = fn : real * real -> bool
06:12:34 <det> ahh
06:13:43 <ski> see e.g. http://www.standardml.org/Basis/real.html
06:14:03 <ski> there is an ?= also, apparently
06:15:35 <harsha123> hi #haskell
06:16:02 <harsha123> does anyone know the various parameters for hdparm that i have to use to tune my hardisk
06:16:48 <det> harsha123: how many channels have you tried so far ?
06:18:18 <det> ski: any idea for the reasoning of using tuples instead of curried arguments? :)
06:18:43 <ski> det : what do you mean ?
06:18:49 <harsha123> det: i asked in debain.. but one helped me
06:19:35 <ski> det : "equational reasoning" ??
06:20:16 <det> ski: why is (op +) int * int -> int instead of int -> int -> int
06:20:52 <shapr> det: actually, functional equality was why I wanted to design the supercombinator and S&K language
06:21:13 <det> shapr: isn't functional equality undecidable ?
06:21:18 <shapr> so that (\x -> x + 1) == (\x -> x + 1) would return true
06:21:30 <ski> det : well .. i don't know for sure so i can only guess : perhaps it's because of ML's ago that they wasn't so used to curried functions ??
06:21:58 <det> ski, maybe, but it reall bothers me :/
06:22:28 <ski> oops, s/ago/age/
06:22:52 <det> ski: I was happy to learn the constructors in SML are regular functions and dont have special status like O'Caml, but then I found out they too take tupled arguments
06:23:33 <det> shapr: or maybe it is Y that screws up functional equality
06:24:02 <ski> det : they have special status in O'Caml ?  is it for allowing two constructors with the same name in the same scope ??
06:24:54 <det> ski: nope
06:25:08 <det> ski: polymorphic variants are for that
06:25:20 <ski> shapr : was you thinking of comparing the SK-expressions ?
06:25:41 <shapr> yup
06:25:45 <ski> det : then, what special status ?
06:26:25 <ski> shapr : not sure, but doesn't that only give you conservative equality ?
06:26:31 <det> # type intlist = Nil | Cons of int * intlist;;
06:26:32 <det> type intlist = Nil | Cons of int * intlist
06:26:32 <det> # Cons;;
06:26:33 <det> The constructor Cons expects 2 argument(s),
06:26:33 <det> but is here applied to 0 argument(s)
06:26:40 <shapr> ski: yes, only extensional equality
06:26:42 <det> I mean, Cons isnt a function
06:26:45 <shapr> but it still might be interesting
06:26:54 <det> it is a "constructor"
06:27:10 <det> whereas in SML Cons would be a function taking a 2-tuple
06:27:18 <ski> det : aha, so you have to eta-expand :(
06:28:17 <det> ski: meaning it has it's own syntax
06:28:28 <ski> det : well, 'twould still be a constructor : you can match on it in patterns. but, yes, you can use it as an ordinary function (value)
06:28:57 <ski> shapr : yes
06:28:58 <det> ski: and you can pass it as a value
06:29:39 <ski> shapr : i'm wondering if there is some safe (pure, i.e.) way of using conservative equalities/etc
06:29:49 <det> ski:  in ocaml you would have to pass "fun hd tl -> (Cons(hd, tl))"
06:30:02 <ski> det : yes, it is a function *value*
06:30:20 <shapr> ski: I would think so, you can *always* compare the S & K composition, since it's just an ordered set of S & K, right?
06:30:22 <det> shapr: is comparing S K combinators not undecidable ?
06:31:00 <ski> det : or just "fun blah -> Cons blah" if you don't mind it noncurried
06:31:12 <shapr> det: can you compare an ordered list to another ordered list?
06:31:55 <det> shapr: but, many different S K combinations may be equivalent
06:32:19 <shapr> det: sure, I know that
06:32:31 <shapr> that's why you only get extensional equality, not intensional equality
06:32:33 <det> ski: yeah
06:32:34 <ski> shapr : you can, of course normalize the two exprs, and then compare for exact match (modulo sharing, and different copies of same structure)
06:32:44 <shapr> for example, do you consider quicksort and bubble sort as equal?
06:33:02 <ski> shapr : but this doesn't work, generally, if the language can express nontermination :(
06:33:05 <det> ski: dont you lose normal forms by having recursion ?
06:33:39 <det> oh, I'm slow
06:33:43 <det> shapr: no
06:34:32 <ski> det : not if you don't allow *general* recursion, the problem is just finding a workable restriction
06:35:05 <det> what is an example of a workable restriction ?
06:35:12 <det> is "Y" too general ?
06:35:14 <ski> det : in Charity, one can express arbitrary folds over inductive/algebraic types
06:35:36 <det> Charit isnt turing complete, so I hear
06:35:41 <det> boo hiss
06:36:24 <det> I must start my day
06:36:43 <det> g'day all
06:36:47 * det detaches
06:36:50 <ski> yes, that means that you can't express some things in Charity, which you can in a turing machine (or untyped lambda calculus)
06:37:27 <ski> (namely, some of these things you can't express is nontermination, this is intentionally so in Charity)
06:38:25 <ski> shapr : equal as in extensional or intensional ? :P
06:47:20 <shapr> ski: I don't understand...
06:49:15 <ski> you asked if I (or someone) considere quicksort and bubble sort equal. and i countered by asking what equality you meant ;)
06:49:28 <ski> considered
06:57:48 <ski> shapr : see ?
07:04:45 <shapr> sure
07:04:51 <shapr> I agree with that
07:05:00 <shapr> there are at least two types of equality
07:05:05 <shapr> probably more than three
07:05:34 <ski> but, i think i usually mean/think of extensional equality, when i hear/see the word equal
07:07:16 <ski> one (conservative) equality is that of equalness under any context..
07:17:49 <Lunar^_> shapr: I'm part time at school part time at job
07:45:36 <harsha123> shapr hello 
07:49:13 <shapr> hi harsha123 
07:49:25 <shapr> Lunar^_: if you have any zope questions, ask me
07:49:45 <harsha123> shapr have you used bitchX ?
07:50:04 <shapr> last time, about six years ago
07:51:31 <Lunar^_> shapr: Thanks.. but actually the technical director is Olivier Deckmyn
07:51:46 <Lunar^_> shapr: Which is the co-writer of this book : http://zope.editions-eyrolles.com/
07:51:58 <shapr> is he on #zope?
07:54:08 <Lunar^_> Don't see him
07:54:36 <shapr> hm
08:28:40 * esap blinks.
08:47:43 * shapr boings
08:48:28 * ski smiles big
08:49:04 * prologic shakes his head and blinks
08:49:11 <prologic> hello :)
08:49:17 <ski> hi
08:49:57 <prologic> writing a script for some guy in #linuxhelp, bbs
08:51:30 <ski> phew
08:52:34 <prologic> phew ?
08:52:48 <ski> re sci.logic
08:53:57 <Lor> sci.logic is too full of crud nowadays.
08:54:30 <ski> the feud/flame war between mitch an George Greene seems to have ended in a nice way
08:55:43 <ludde> hi ski
08:56:01 <ski> ludde : hi
08:56:09 <ludde> what's up
08:56:27 <ski> i'm reading thread "Eliminability of identity -- For George Greene" on sci.logic
08:56:33 <ludde> oh ok
08:57:25 <ludde> did you solve assignment 3 in the algorihms class
08:58:56 <ski> ludde : not yet
09:20:20 <prologic> weee
09:20:23 <prologic> nice little script
09:20:28 <prologic> for i in $(find . | egrep "\/mbox"); do mv $i `echo $i | sed -e "s/\/\([0-9A-Za-z]*\)\/mbox/\/\1\/\1\.mbox/"`; done;
09:20:34 <prologic> I'm done :) back to Haskell!
09:21:00 <ski> welcome back ;)
09:21:29 <prologic> ta
09:21:34 <prologic> how you going ?
09:21:54 <ski> listening to good music :)
09:22:58 <prologic> me too :)
09:23:48 <ski> what music ?  just curious
09:24:04 <prologic> I'll generate a list hold on
09:24:25 <ski> (you can /msg it if you don't want to flood ...)
09:24:26 * shapr chortles merily
09:24:32 <ski> :)
09:24:33 <shapr> oh I want to see the list too
09:24:37 <shapr> life is fun
09:24:38 <shapr> I like that.
09:24:43 <ski> yes
09:24:49 <prologic> oh alright
09:24:53 <prologic> I'll open up gnump3d
09:24:58 <tic> life is short. enjoy it while you can. sprite
09:24:59 <prologic> seems xmms can't generate html lists
09:26:52 <ski> prologic : perhaps you can save the playlist to a file ??
09:27:30 <shapr> tic: life is fun, enjoy it. shae
09:28:10 <shapr> what's the signature I keep seeing? "It's never too late to give up"
09:28:25 <shapr> is that norpan's signature?
09:28:37 <prologic> http://daisy.ods.org:8888 should work although it's re-indexing all the files yet again hate it when it does that
09:28:47 <prologic> everytime the machine is booted, or gnump3d restarted it re-indexes
09:29:00 <prologic> I outta submit a feature request so it doesn't re-index inless necessary
09:29:04 <tic> shapr, dunno.
09:29:19 <prologic> 90% cpu, 96% ram, 97% swap
09:29:20 <prologic> argg :)
09:30:56 <shapr> what sort of hardware do you have?
09:31:30 <prologic> click the sysinfo link on http://daisy.ods.org/
09:32:44 * prologic screams at gnump3d, stop indexing!
09:32:58 <prologic> weee it's finished :)
09:33:01 <prologic> bloody about time
09:33:24 <shapr> that's a decent chunk of drivespace
09:33:36 <prologic> what /music/ ?
09:33:42 <shapr> all of 'em together
09:33:45 <prologic> ahh
09:33:54 <prologic> yeh I got a new 120G hdd for my 21st birthday :)
09:34:01 <prologic> and that dvd rom and cdrw
09:34:13 <shapr> I'm tempted to buy new a new drive myself
09:34:15 <prologic> I had a creative 52x cdrom (piece of shit!)
09:34:35 <prologic> I would like more ram though
09:34:38 <prologic> and preferably ddr
09:34:49 <prologic> the cpu itself is fast enough for desktop work
09:36:05 <prologic> hrmm yay :) someone search for "pircsrv" on google :P
09:36:14 <prologic> I discovered it the other day, and was quite amazed :)
09:38:07 <ski> i'm currently playing a few mp3 remixes (of c64 tunes)
09:38:27 <ski> wanna see ?
09:38:44 <prologic> sure :)
09:38:50 <ski> Red Devil - Chuck Rock goes MP3
09:38:50 <ski> Red Devil - Comic Bakery
09:38:50 <ski> Red Devil - Druid II Remix
09:38:50 <ski> Red Devil - IronLord
09:38:50 <ski> Red Devil - Last Ninjha 3
09:38:51 <ski> Red Devil - Supremacy
09:39:08 <prologic> they good ?
09:39:17 <ski> author is Red Devil alias Emil Hellin
09:39:19 <ski> yes
09:39:27 <ski> except possibly the first one
09:39:32 <prologic> c64 tunes hrmm
09:39:50 <prologic> where do you get them from ?
09:40:39 <ski> well, i have all/most of his mp3 collection at home, but i have just foun these on the net, here at uni
09:40:56 <ski> so you want to download and try some ?
09:41:05 <ski> s/foun/found/
09:41:08 <prologic> they freely available ? from IP or copyright ?
09:41:54 <ski> you can check his page at http://clix.to/helldin
09:42:00 <prologic> k
09:42:26 <ski> unfortunately the links there doesn't seem to work (didn't last time i looked)
09:42:36 <prologic> ah k
09:43:33 <ski> i'm not totally sure, but i think one can download them as long as no commercial use or whatever
09:44:27 <prologic> hrmm yeah there's no restriction imposed that I see
09:44:34 <prologic> and his server that holds them is offline I think
09:44:42 <ski> anyway much of the music from The Scene is just free to listen to
09:44:44 <prologic> you could send me one to try ?
09:45:14 <ski> waitasec
09:45:23 <prologic> ta
09:47:57 <ski> those i have here at school i dowloaded from http://remix.kwed.org/index.php?search=red+devil but you can also look at my crude http://www.mdstud.chalmers.se/~alg3-59/msx/RedDevil/
09:48:07 <prologic> k
09:48:22 <prologic> ty
09:48:46 <prologic> the wiki on haskell.org, is that written in Haskell ?
09:49:28 <shapr> no, but there is a haskell wiki
09:49:46 <prologic> the wiwiwi ?
09:49:54 <shapr> yup
09:49:58 <prologic> k
09:50:10 <prologic> is there a complete configuration file for wiwiwi ?
09:50:15 <ski> prologic : http://www.mdstud.chalmers.se/~alg3-59/msx/fromHome/Amiga/ is perhaps also of interest if you like mod music
09:50:21 <prologic> I had to guess the xml config
09:50:31 <prologic> ok ta ski
09:50:37 <prologic> never listened to mod music before :)
09:50:39 <prologic> but I'll try
09:50:51 <prologic> as long as it's freely available :)
09:51:09 <ski> yes
09:51:33 <prologic> oh guess what we have to do for our 3rd and final Haskell assignment :) ?
09:52:13 <prologic> a small parsing exercise, an interpeter (no selection or iteration), and a prolog database program
09:52:33 <shapr> whee
09:52:43 <prologic> hehe
09:52:47 <shapr> prologic: hopefully you'll still come back and hang out with us even when your class is over
09:52:49 <prologic> whee indeed ;)
09:52:55 <prologic> I love it!
09:53:00 <prologic> of course :)
09:53:03 <shapr> yay!
09:53:19 <shapr> prologic: yes, there's a complete xml config file, I have one online
09:53:46 <prologic> I'll probably come back here often, because I want to start thinking about what my degree program professor (Prof. Geoff Dromey) is doing with his work in components and system engineering.
09:53:52 <shapr> http://www.scannedinavian.org/cgi-bin/wiwiwi/blog.cgi
09:54:13 <prologic> I've started some work in this area and believe I can reach his goal of being able to build software systems with no code
09:54:25 <prologic> ta shapr :)
09:54:28 <Maddas> huh?
09:54:33 <Maddas> prologic: how would that work? :)
09:54:35 <prologic> I didn't know a copy was running there of wiwiwi
09:54:36 <shapr> prologic: I still want to see some latin-1 transcriptions of your native lang
09:55:02 <prologic> Maddas, it's easy in my head :) and my professors although he thinks there are many barriers to get over which I agree.
09:55:18 <shapr> prologic: have you seen thomas wouter's stuff?
09:55:26 <prologic> shapr, sure, I'll write up some examples when I have some time. I don't speak or write it anymore, but it was native to me.
09:55:34 <prologic> shapr, nope ? got a url ?
09:55:43 <Maddas> prologic: I mean, what's the context?
09:55:50 <Maddas> I just hopped in :-)
09:55:58 <prologic> ooh
09:56:04 <prologic> sorry you lost me
09:56:04 <prologic> context of what ?
09:56:17 <prologic> I'm talking about a new programming paradigm, quite similar to FP but also quite different
09:56:21 <prologic> where you do not need to write new code
09:56:22 <Maddas> Ah, cool
09:56:30 <Maddas> Just a bunch of intertextual (intercodual?) links?
09:56:35 <shapr> prologic: http://wouter.fov120.com/proglang/index.html
09:56:46 <prologic> esentially software engineers should (one day) be able to link up components that make up an entire system
09:56:50 <prologic> and also abtract to higher levels
09:56:54 <Maddas> Interesting
09:56:59 <prologic> Maddas, precisely
09:57:06 <prologic> I have already done it at a low level
09:57:09 <Maddas> Cool
09:57:13 <prologic> I'm going to continue researching the idea
09:57:23 <prologic> it's not an original idea, but I don't think too many have succeeded yet
09:57:30 <prologic> ta shapr
09:57:34 <prologic> java's net beans are pathetic :)
09:57:38 <prologic> I've looked at them
09:57:41 <Maddas> Hm
09:57:50 <Maddas> Do you have an URL that explains the idea in a simple way?
09:57:50 <ski> prologic : (re modules : you'll perhaps need some module player or plugin. i know winamp used to come with one, but this xmms version has none preinstalled ..)
09:57:54 <Maddas> I don't know about NetBeans
09:57:58 <shapr> truly net beans should be rooted out
09:58:00 <prologic> no lol
09:58:06 <prologic> I'll have to publish my research as I go
09:58:13 <Maddas> ok!
09:58:14 <prologic> but I haven't started putting it on paper or web yet
09:58:21 <prologic> except with the few written notes I have on file
09:58:30 <prologic> and sources of examples of how it can be used and applied
09:58:37 <prologic> as well as diagrams in smartdraw
09:58:53 <prologic> shapr, net beans are a piece of shit! die! :)
09:59:02 <prologic> I agree
09:59:21 <prologic> FP is close to what I want (and Haskell is bloody excellent), but it's not quite there.
09:59:26 <croesus> prologic: have you thought of an interface to the collection of components
09:59:32 <prologic> the abstractions you can do with Haskell are brilliant
09:59:37 <prologic> but you're still having to write code though
09:59:53 <prologic> croesus, most of this has already been well defined by our professor Geoff Dromey
10:00:00 <croesus> prologic: ah
10:00:06 <prologic> he has taught us to design software with what he calls "Behaviour Trees"
10:00:11 <ski> prologic : (btw : if you decide you like the mod music you can go up one directory and download a zipfile of them)
10:00:18 <prologic> which are a graphical representation of how the software works
10:00:24 <prologic> instead of mathematical carp :)
10:00:33 <prologic> ski: ta :)
10:00:33 <Maddas> Mathematics is nice
10:00:46 <prologic> I'm not dissing Maths :)
10:00:50 <prologic> Maths is fine for most people
10:00:55 <prologic> but most people have short memories
10:01:02 <Maddas> True
10:01:03 <prologic> we can only remember about 7 things at once
10:01:07 <prologic> graphical representations are much better
10:01:20 <prologic> and compared to UML and Z and other formal notations which require many many pages
10:01:26 <prologic> Behaviour Trees can usually be done on one page
10:01:36 <prologic> representation an entire system as complicated as a satellite system
10:02:05 <prologic> what I want to do is complete the whole thing by building (or at least trying to) a new paradigm based on my professors work
10:02:22 <Maddas> Let me know if it's usable!
10:02:27 <Maddas> Sonuds very interesting :-)
10:02:30 <Maddas> Sounds, even
10:02:34 <prologic> similarily to Hakell, the underlying basic components would have to be hard-coded into the compiler of course
10:02:38 <prologic> basic operations such as selection, iteration etc.
10:02:45 <croesus> it'd be neat to have something like a spreadsheat interface to components
10:02:51 <prologic> but esentially there should be no further need to write code
10:04:09 <prologic> croesus, this is also possible as well :) representing the requirements in english, which are then translated into what we call TTT's, which are then transformed into individual Behaviour Tree, which are then integreated to producee an IBT (Integrated Behaviour Tree), which are then transposed to produce the overall system behaviour and system archectecture
10:04:19 <prologic> which can then be used by the compiler to automatically generate the code
10:04:44 <prologic> the whole process of writing software (eventually) will and can be automated
10:04:49 <prologic> programmers would no longer be needed :)
10:05:08 <prologic> I'm not dissing programmers either, I've been programming since 11years of age
10:05:52 <ski> how old are you ?
10:06:08 <shapr> I'm 100,000 in binary!
10:06:10 <prologic> told you before
10:06:15 <prologic> just turned 21 not long ago :)
10:06:15 <prologic> hehe
10:06:18 <ski> i forgot :(
10:06:20 <prologic> got new hdd, cdrw and dvd
10:06:25 <prologic> amongst other things :)
10:06:30 <prologic> lol
10:06:30 <prologic> 100000 ?
10:06:30 <prologic> wow
10:06:53 <shapr> yah, that's old
10:06:57 <prologic> I'm 10101
10:07:04 <prologic> 32
10:07:08 <shapr> like I said
10:07:09 <prologic> not that old :)
10:07:18 <shapr> well, feels like it sometimes
10:07:31 <prologic> hehe
10:07:35 <prologic> I know how ya feel
10:07:43 <prologic> people kept saying I was getting older now
10:07:45 <ski> i got a programmable calculator when in second (or was it first) class, IIRC.  510 bytes of program memory :)
10:07:48 <prologic> I felt it too and I'm only 21!
10:08:12 <prologic> one of my birthday cards says, "There are two things you can count on. Getting older, and a friend to remind you."
10:09:06 <prologic> yeah so guys, I'll be coming back here often to discuss my ideas about this :) (which I like to call COL - Component Oriented Language)
10:10:27 <ski> cool :)
10:11:05 <shapr> y03
10:11:38 <shapr> component object oriented language - CObOL !
10:11:51 * ski lol
10:12:59 <prologic> lol
10:13:04 <prologic> no not COBOL :P
10:13:11 <ski> COOL ?
10:13:29 <prologic> what'd the extra O stand for ? :P
10:13:30 <ski> Component Object-Oriented Language
10:13:45 <prologic> heh
10:13:54 <prologic> it won't be Object Oriented
10:13:55 <ski> i said this above :)
10:14:16 <ski> just a knee-jerk reflex :)
10:14:23 <prologic> I want to steer completely away from imperitive and oo features
10:14:42 <prologic> there might be similaries, but in no way shape or form will it look like current languages
10:14:46 <prologic> except perhaps FP languages
10:15:17 <prologic> FP languages like Haskell are close, but I think there are drawbacks and restrictions
10:15:23 <prologic> but I have to think about it more :)
10:15:44 <prologic> see a component is all about it's attributes and behaviours which are composed to create a system
10:15:56 <prologic> or if you like a higher-order component which contains many sub-components
10:16:23 <prologic> much like creating an amplifier in electronic engineering, few resistors and transistors and you have yourself an amplifier!
10:16:36 <prologic> we should be able to do the same thing with software engineering, but can't (yet)
10:16:49 <prologic> this way anything that you create, any component or system, is 100% reusable
10:17:00 <prologic> and every component and system can be abstracted to a higher level
10:17:18 <prologic> eg: you could integrate a microwave oven system (software) into a kitchen system
10:17:45 <ski> is there no room for bad design, then ?                         ;-)
10:18:06 <ski> what have the world come to
10:18:12 <Maddas> haha
10:18:33 <prologic> yeap
10:18:37 <prologic> there is no room for bad design :)
10:18:56 <prologic> because the very process of desiging systems with Behaviour Trees makes no room for defects
10:19:02 <prologic> in other words: 0 bugs
10:19:05 <croesus>  how are you going to identify and classify behaviors?
10:19:33 <prologic> in order to answer that croesus, I'd have to talk about all the theory and practical applications of Behaviour Trees
10:19:35 <prologic> I'd be here all night :)
10:19:43 <croesus> gotcha
10:19:48 <prologic> just know that a component has attributes and it can exhibit behaviour
10:20:09 <prologic> and a system is just made up of a number of components that interact together to produce system behaviour
10:20:23 <prologic> try and think of a microwave oven and the comonents it has and how they all interact
10:20:31 <croesus> well i'm wondering if you're going to be able to say i want this behavior here and have the system find the best component for the job
10:20:40 <prologic> we have repeatedly created software simulations of entire microwave ovens
10:20:44 <prologic> easily with 0 defects
10:21:21 <shapr> but mozilla is far more complicated than a microwave oven
10:21:37 <prologic> well just in electronica, where you cannot replace a transistor in place of a resistor
10:21:44 <prologic> the same applies with this
10:21:59 <prologic> components and their interfaces when connected together have to be compatible
10:22:36 <croesus> right, just wondering what the view of the behavior is like
10:22:46 <prologic> do you have smartdraw ?
10:22:49 <croesus> a text description, graphic, etc...
10:22:50 <prologic> I can send you an example
10:22:57 <croesus> no, i don't...
10:23:00 <Maddas> So there will be no 'need' for me to write code?
10:23:06 <prologic> Maddas, got it :)
10:23:07 <Maddas> No more coding?!?!
10:23:11 <prologic> yup
10:23:17 * Maddas puts many bugs in prologic's work
10:23:23 <prologic> lol
10:23:24 <Maddas> I like coding, you foo!
10:23:34 <prologic> think about it, what is a programming language ?
10:23:42 <prologic> it's just a representation of our ideas
10:23:59 <prologic> a way to express what we want the computer to do, but it can only understand 1's and 0's
10:23:59 <Maddas> A good way to allow me to train my abstract thinking
10:24:03 <Maddas> An interesting way to spend my time
10:24:09 <prologic> yup
10:24:33 <prologic> abstrations are hightened with this just as they are in FP langauges like Haskell
10:24:45 <Maddas> You mean it's *more* abstract?
10:24:55 <prologic> it can be abstracted to higher levels yes
10:25:02 <Maddas> Maybe I like it then
10:25:08 <prologic> knew you would :)
10:25:14 <Maddas> Just show it to me before you publish, so I can still decide what to do with you and your work :-)
10:25:53 <croesus> is there going to be a randomize feature? i give the system a certain amount of behaviors and it constructs a system that does something valid
10:26:00 <croesus> but unknown
10:26:11 <prologic> *shrugs*
10:26:13 <prologic> possibly
10:26:22 <croesus> sort of like "mad libs" for programming
10:26:24 <prologic> I certainly don't see why not
10:26:26 <Maddas> haha
10:26:31 <Maddas> anyway, I want to be the first to do cool things with that system
10:26:56 <prologic> I'll be trying to work closely with my professor with this
10:26:57 <Maddas> I missed enough chances already ;)
10:27:05 <prologic> but I'll publish work somewhere :)
10:27:35 <Lor> Deriving programs from specs is an age-old dream.
10:27:44 <prologic> I'll have to convert some behaviour trees to .jpg files for you guys so you can see
10:27:59 <Lor> And it you only trade the task of writing programs to the task of writing specs.
10:28:01 <prologic> Lor: indeed it is :) many have thought of it
10:28:50 <Maddas> Yea, Lor 
10:28:56 <Maddas> but hey, if it's more fun that way..
10:29:01 <prologic> I guess the key idea here is reuseability and quality
10:29:20 <Lor> I thought it was reliability.
10:29:32 <prologic> time and time again I and my colleagues (in a group) have implemented 100% defect free software systems with behaviour trees and a very crude component based implementation which is far from where I want to go with this.
10:29:45 <prologic> reliability ties in with quality
10:29:49 <prologic> it's a quality attribute
10:30:54 <prologic> the only language so far that I've seen that has very high reuseability is Haskell (and possibly other FP's)
10:31:42 <prologic> OO languages (spits at them) reuseability is a joke if you've ever seen the relationship between different components in the java swing or awt library
10:32:03 <prologic> like a web, and even spider's webs are less complicated and elegant :)
10:37:12 <ski> prologic : do you have any link to some of this work or some site of Geoff Dromey on this ?
10:37:25 <prologic> sure
10:37:27 <prologic> absolutely
10:38:40 <ski> are you able to share it ?
10:39:28 <prologic> I don't see why not
10:39:41 <prologic> anyway just in case I'm not allowed to share the subject websites
10:39:46 <prologic> I'll give you the SQI's website
10:39:54 <ski> then do it !    (the imperative at last ;)
10:40:08 <ski> ok
10:40:08 <prologic> http://www.sqi.gu.edu.au/
10:40:19 <prologic> the sqi website does contain information about Behaviour Trees
10:40:25 <prologic> not sure to what extent though
10:40:41 <Maddas> just don't forget to remind me when it's public :)
10:40:45 <prologic> my professor goes all over the country and world to software engineering discussions/meetings etc
10:40:53 <prologic> Maddas, I won't :)
10:40:56 <prologic> as I said I'll be here often
10:41:13 <prologic> hey ski, I love this music so far
10:41:23 <ski> which of it ?   :)
10:41:49 <ski> i.e. what tunes have you listened to yet ?
10:42:05 <prologic> Druid II Remix
10:42:08 <prologic> just that one thus far
10:42:40 <ski> that one is nice
10:43:43 <prologic> it is
10:43:55 <prologic> I'm gonna listen again !
10:44:46 <ski> the initial part (dunno, perhaps 1.5 or 2 or 3 mins) is more or less the original tune, spiffed up. the later part is a "free expansion" of that
10:45:13 <prologic> yeh I like the later part :)
10:45:19 <prologic> gets the brain ticking quite lively
10:45:34 <ski> Last Ninjha 3 is also one of my favourites. i think i could listen to that one at least 15 times in a row :)
10:45:52 <prologic> hehe
10:46:27 <prologic> any of you lovely people compiled lambdabot before ?
10:46:38 <prologic> I can't with the sources I downloaded
10:47:14 <ski> (well, i think i'll have to put the rest of Red Devil's tunes on a CD or something, so i have it available..)
10:48:12 <ski> not me
10:49:17 <prologic> Makefile:59: depend: No such file or directory
10:49:17 <prologic> I get that error when compiling it
10:49:25 <prologic> which assumedly causes the whole compilcation to fail
10:49:46 <ski> shapr : !
10:50:26 <ski> he has made plugins to lambabot, so perhaps he can help
10:51:01 <prologic> cool
10:51:07 <prologic> shapr :)
10:51:18 <ski> hmm, i think there was some revision control system to download, but you've perhaps done that ?
10:51:32 <ski> (IIRC)
10:51:41 <prologic> rcs ?
10:51:45 <prologic> I use cvs here
10:51:56 <prologic> I downloaded lambdabot from the darc repository
10:54:05 <ski> well, i haven't hacked any on it so i'm probably not of much help there ATM
10:54:21 <prologic> k
11:00:16 <ski> (perhaps it was darcs which was the rev. contr. sys. ??? not sure)
11:00:40 <prologic> *shrugs*
11:04:20 <prologic> class Queue a where
11:04:49 <prologic>    enqueue, dequeue, front, back :: a -> a
11:04:49 <prologic> would that be ok for specifying the methods of a queue class ?
11:05:15 <ski> infinite queue ?
11:05:42 <prologic> hrmm
11:05:47 <ski> can't some of the ops fail if we have an empty queue ?
11:05:49 <prologic> I guess it shouldn't be infinite :)
11:05:54 <ski> (which ?)
11:06:02 <prologic> they can indeed
11:06:06 <prologic> sorry I haven't written a class yet :)
11:06:20 <prologic> dequeue, front and back can fail
11:06:21 <ski> those ops could possibly use the Maybe type(constructor)
11:06:26 <prologic> so can enqueue if the queue is full
11:06:41 <prologic> :: a -> Maybe a
11:06:44 <ski> if you have bounded size, yes
11:06:45 <prologic> ?
11:06:54 <ski> @type lookup
11:06:55 <lambdabot> lookup :: Eq a => a -> [(a,b)] -> Maybe b
11:06:58 <ski> like that
11:07:01 <ski> e.g.
11:08:02 <prologic> I'll have a look at the online report of how classes are defined :)
11:08:13 <ddarius> prologic: Don't you want to get elements out of the queue?
11:08:30 <prologic> yeh
11:08:47 <prologic> that's what queues do don't they :)
11:08:58 <ski> prologic : can't you begin with looking at some sample classes and instances, and interpolate ?
11:09:01 <prologic> enqueue and dequeue
11:09:01 <prologic> and possibly peek at the front or back
11:09:01 <ddarius> Then it may help for front/back to return something other than the queue
11:09:08 <prologic> I can
11:09:15 <prologic> that's just what I did lol
11:09:37 <prologic> the Eq class seems too simple to interpolate off though
11:09:44 <prologic> hey hey don't knock me, I just started writing this 30seconds ago :)
11:10:06 <ski> prologic : note : this class does *not* encapsulate any hidden state (like e.g. the queue storage) !
11:10:35 <prologic> the one I pasted above ?
11:11:10 <ski> yes (it seemed like you assumed a queue state would be encapsulated inside "values of this class")
11:11:23 <prologic> yeh
11:11:29 <prologic> it's truely lacking :)
11:11:34 <ski> (or sounded instead of seemed, if you like)
11:11:35 <prologic> I haven't thought about it yet
11:11:40 <prologic> I just copied and modified the Eq class in the PRelude :)
11:11:52 <ski> no bad in that :)
11:12:03 <ddarius> Typeclasses specify interfaces.  If you actually want to implement a queue, you use 'data' and functions operating on the data type.
11:12:06 <prologic> hehe
11:12:06 <prologic> ta
11:12:15 <prologic> don't worry I've implemented queues and stacks in various other non FP languages
11:12:18 <ski> but you'll have to think of the interface
11:12:37 <prologic> *nods*
11:16:11 <shapr> y0
11:16:23 <Maddas> yow
11:16:26 <shapr> @yow
11:16:27 <lambdabot> ..  or were you driving the PONTIAC that HONKED at me
11:16:27 <lambdabot>  in MIAMI last Tuesday?
11:17:17 <ski> shapr : prologic had some trouble with lambdabot ..
11:17:51 <prologic> yeh
11:18:08 <prologic> $ make
11:18:14 <prologic> Makefile:59: depend: No such file or directory
11:18:19 <prologic> ghc-6.0.1: unknown package name: HToolkit
11:18:19 <prologic> rm: cannot remove `depend': No such file or directory
11:18:19 <prologic> make: *** [depend] Error 1
11:18:42 <Igloo> You might want "make depend" first
11:19:18 <prologic> hrmm ok
11:19:27 <prologic> I thought I tried analysing the Makefile
11:19:45 <prologic> nope, same errors
11:20:53 <Igloo> .me odesn't have a copy handy to look at and needs ot rush off now, sorry
11:21:13 <prologic> hehe cya have fun :)
11:26:20 <shapr> oh, I need to pull all of the HToolkit stuff out of lambdabot I think
11:26:44 <shapr> prologic: http://www.scannedinavian.org/~shae/Makefile
11:26:46 <shapr> use that instead
11:27:12 <prologic> ahh ta :)
11:27:15 <prologic> ty shapr
11:31:53 <ski> prologic : (tried any of the other tunes yet ?)
11:32:08 <prologic> yep
11:32:16 <prologic> downloading a few of them atm
11:32:22 <prologic> but I should be heading off to bed
11:32:28 <prologic> so I'll say night :)
11:32:32 <ski> me too, soon
11:32:38 <prologic> thanks for listening to my mumblings :)
11:33:08 <ski> no prob :)
11:33:22 <ski> g'night to you
11:33:54 <prologic> night
16:11:22 --- mode: hardy.freenode.net set +b *!23kjhkjf@*
16:19:52 --- mode: clancy.freenode.net set +b *!23kjhkjf@*
20:18:10 <blackdog> @yow
20:18:11 <lambdabot> We place two copies of PEOPLE magazine in a DARK, HUMID mobile home.
20:18:11 <lambdabot>  45 minutes later CYNDI LAUPER emerges wearing a BIRD CAGE on her head!
20:52:39 * steveh is the keeper of arcane knowledge.
20:52:56 <Pseudonym> Oooh.  Sounds creepy.
20:53:20 <steveh> wait until I tell you that it has something to do with using truetype fonts with TeX.
20:53:25 <steveh> :-P
20:56:50 <Pseudonym> "Arcane" doesn't seem to be quite the right word there.
20:57:19 <Pseudonym> @wn arcane
20:57:21 <lambdabot> *** "arcane" wn "WordNet (r) 2.0"
20:57:21 <lambdabot> arcane
20:57:21 <lambdabot>      adj : requiring secret or mysterious knowledge; "the arcane
20:57:21 <lambdabot>            science of dowsing"
20:57:31 <Pseudonym> Hmmm... maybe,
20:58:28 <steveh> well
20:58:36 <steveh> the incantations are certainly arcane
20:58:55 <steveh> i think I need to write a bigass python script to chain the whole process together
20:59:20 <steveh> the one issue is naming of the font files in tex's naming scheme
20:59:20 <Pseudonym> @jargon muttter
20:59:21 <lambdabot> No match for "muttter".
20:59:28 <Pseudonym> @jargon mutter
20:59:29 <lambdabot> *** "mutter" jargon "Jargon File (4.3.0, 30 APR 2001)"
20:59:29 <lambdabot> mutter vt. To quietly enter a command not meant for the ears, eyes, or
20:59:29 <lambdabot>    fingers of ordinary mortals. Often used in `mutter an {incantation}'.
20:59:29 <lambdabot>    See also {wizard}.
20:59:32 <lambdabot> = N =
20:59:36 <steveh> heh
21:00:13 <Pseudonym> Definitely the term there.
21:04:50 <danols> i'm dead
21:04:55 <danols> lol
21:06:45 <danols> if anyone wants to help me sort out my mess trying to program a neural perceptron please put up your hand
21:10:06 <danols> crap anyone care to give me one on one lessons ?
23:06:39 <danols> whats wrong with this format ? train xs (adjWeights (x:xs) ws) cs k
23:12:15 <danols> anyone alive i'm stuck with syntax !
23:12:18 <danols> pls respond
