00:06:25 <shapr> miserable and rainy?
00:06:27 <shapr> and cold
00:07:17 <blackdog> good hacking weather.
00:09:48 <shapr> truly
00:09:58 * shapr yawns
00:21:59 * earthy looks out at the nice and soft sun peeking through the moderate cloud cover
00:23:01 <earthy> and goes back to trying to convince HOL that *yes* it can automatically prove   maxchar - i > 0    from  0 <= i   and    i < maxchar
00:25:50 <earthy> somehow the Presburger arithmetic solver seems to struggle with the *extra* info that !n. 0 <= n /\ n < i ==> (skips ArrayApp n = 0)
00:55:19 <phubuh> sigh, back in computer class :~(
01:03:31 <earthy> if only they'd teach you haskell, right?
01:04:07 <Maddas> yes :(
01:04:30 <andersca> here they do :)
01:20:02 <phubuh> earthy: that'd be cool, but excel is almost as interesting!
01:20:09 <phubuh> not to mention powerpoint!
01:20:32 <Maddas> Yeah, it is! I worked with excel and powerpoint only for over a month, I should know!
01:21:02 <shapr> looks like I missed some interesting discussion
01:21:06 * shapr reads the logs
01:21:08 * Maddas grins
01:21:27 <earthy> phubuh: hasn't Simon PJ written something about embedding a functional programming language in Excel?
01:21:59 <shapr> sort of
01:22:42 <shapr> he ended up saying that the advanced concepts were really out of reach of the average user
01:22:45 * shapr checks the hardcopy
01:24:19 <shapr> he added 'functions' to Excel.
01:25:15 <shapr> http://research.microsoft.com/Users/simonpj/Papers/excel/index.htm
01:39:03 <harsha123> hello #heaskell
01:39:10 <shapr> heallo hearsha :-)
01:39:19 <harsha123> shapr: hi :) 
01:39:23 <harsha123> whats up?
01:39:26 <shapr> ceilings!
01:39:30 <shapr> actually, work
01:39:44 <harsha123> ok.. 
01:40:03 <harsha123> the doc has adivsed me a weeks rest for my eyes :(
01:40:12 <shapr> wow, what did you do?
01:40:29 <harsha123> hm I have devleped allergy  :(
01:40:38 <shapr> to computers?
01:41:07 <harsha123> hehehe.. maybe to the radiation.. or constant staring at the screen
01:41:16 <shapr> you should switch to an LCD monitor
01:41:27 <shapr> I get headaches from CRTs, but LCDs are much better.
01:41:27 <harsha123> hmm do you use an LCD monitor?
01:41:31 <shapr> not yet
01:41:38 <harsha123> Ok
01:41:47 <harsha123> they cost a bomb :(
01:41:49 <shapr> it's on my list of things to buy when I have enough money.
01:41:56 <Maddas> What about TFTs?
01:41:57 <shapr> they're a lot cheaper förtiden
01:42:25 <harsha123> have to check the prices.. not sure though
01:43:20 <harsha123> anyways i solved the FSM problem .. 
01:43:28 <shapr> cool
01:43:29 <Maddas> Aren't TFTs good too, shapr?
01:43:52 <shapr> Maddas: what's the difference between LCD and TFT? whether it's LCD or plasma based?
01:43:59 <Maddas> No idea, just wondering :-)
01:44:12 <Maddas> shapr: I'm not aware of the differences myself
01:44:17 <shapr> nor am I
01:44:18 <Maddas> aren't they two distinct types though?
01:44:23 <shapr> yes they ar
01:44:24 <shapr> e
01:44:26 <shapr> I was being too specific
01:44:38 <Maddas> oh, cool. Didn't know :)
01:45:47 <shapr> at least, I think they are... a google search says that most things are called TFT-LCD
01:49:17 <shapr> TFT LCD (Thin Film Transistor Liquid Crystal Display)
01:49:44 <shapr> I thought there was a plasma based or 'fluorescent light' style of flat screen also.
01:50:59 <Maddas> I see
01:52:11 <shapr> http://www.netbored.com/classroom/what_is_tft_lcd.htm
01:52:32 <shapr> aha: http://www.netbored.com/classroom/about-plasma.htm
01:54:34 <Maddas> hm, thanks!
01:55:14 <shapr> they say that LCD is best for 28 inches and smaller, and plasma is best for 32 inches and larger
01:55:23 <shapr> gee, I want a plasma monitor now :-)
01:55:24 <Maddas> I see, cool
01:55:29 <Maddas> me too :)
01:56:28 <shapr> urk, $3900 for a 46" display
01:56:47 <Maddas> Hm. Let me know if you get one, so I can come and steal it :-)
01:56:52 * shapr laughs
01:57:40 <shapr> for only $15000 you can have a 63" display.
01:58:03 <shapr> 1366 x 768 resolution
01:58:13 <Maddas> That's a very low resolution for such a large display.
01:58:17 <shapr> yup
01:58:35 <Maddas> Ugh. Why not buy many small monitors and hook them together somehow then, every monitor being a pixel? :)
01:58:44 <tic> Maddas, :)
01:59:07 <shapr> I've seen some interesting pure html image technology based on that idea
01:59:10 <tic> actually, though, why not get a couple of 19" monitors?
01:59:25 <Maddas> Money.
01:59:30 <Maddas> heh shapr :)
01:59:45 <tic> shapr, ohh.. that's fresh. heard of the so-called ANSI art? ;)
01:59:57 <earthy> hm. don't 17" LCD's go for something like EUR 250 to EUR 300 nowadays?
02:00:04 <shapr> earthy: yah, they're cheap
02:00:11 <shapr> I want a dual-link DVI myself
02:00:32 <Maddas> I might get an external monitor later, as I can easily hook it up to my laptop.
02:00:35 <earthy> I mean, my (very good) 17" CRT kost me some EUR 400 back in 1999...
02:00:59 <Maddas> Heh, I payed 900 EUR for my 17" TFT
02:00:59 <tic> say you get four 17" LCDs, and you have a large TV
02:01:23 <earthy> tic: the problem is that you then also get a nasty big cross in the center of that TV
02:01:25 <shapr> I've had a dual monitor Xinerama setup
02:01:35 <Maddas> Although a friend of mine bought two 15" CRTs for around seventy cent on ebay last week.
02:01:37 <earthy> and TV needs differen display characteristics to look good.
02:01:42 <shapr> but the monitors had thick borders, so I couldn't get them close to each other
02:01:45 <Maddas> Yeah. LCD TVs look crap :(
02:01:55 <tic> earthy, yeah -- although that depends on the framing.
02:01:58 <shapr> I'd like to see monitors with at least one thin side
02:02:05 <Maddas> shapr: you need two :-)
02:02:06 * earthy nods
02:02:09 <tic> the samsung 19" ones have really thin sides.
02:02:30 <shapr> Maddas: well, I could turn the other one upside down.
02:02:35 <tic> TV won't look -that- bad on LCDs if you apply some real-time postprocessing.
02:02:40 <Maddas> shapr: ok :)
02:03:40 <earthy> tic: TV *really* needs the slow decay of phosphors
02:03:48 <earthy> as in light-intensity decay
02:04:05 <tic> hm?
02:04:05 <earthy> or some powerful averaging in time...
02:04:14 <shapr> my first monitor was amber and black
02:04:22 <shapr> I had high resolution Hercules graphics
02:04:30 * earthy has amber on dark grey xterms.
02:04:55 <earthy> wow. my first monitor was green and black and gave me on the order of 140x60 pixels
02:04:57 <shapr> I sort of miss the slow decay look, but I have xscreensavers, so it's okay
02:05:17 <earthy> (I forget the exact numbers...)
02:07:33 <tic> Maybe I should frame a monitor and hang it up on the wall, and display alternating beautiful pictures/colors? :)
02:07:43 <shapr> I want animated tshirts
02:08:32 <shapr> It'd be fun to write memetic tshirt screensavers where the patterns could jump to other peoples clothing.
02:08:39 <Maddas> haha
02:08:40 <tic> heh
02:09:45 <shapr> I wonder if attention focussed clothing is feasible
02:09:59 <shapr> so that when a bunch of people are in the same conversation, their clothing turns similar colors
02:11:46 <shapr> hi prologic 
02:11:51 <prologic> hi :)
02:11:55 <shapr> how's code?
02:12:16 <prologic> code ?
02:12:27 <shapr> have you written any interesting code lately?
02:12:34 <prologic> a little
02:12:38 <prologic> nothing too fancy though :)
02:12:41 <shapr> what was it?
02:12:45 <prologic> having trouble atm understanding this assignment
02:12:57 <prologic> if you'd take a look I'd appriciate it :)
02:12:59 <shapr> uh oh, homework?
02:13:05 <prologic> yeh
02:13:16 <shapr> for ethical reasons we can't give much help with homework
02:13:25 <shapr> but if you'll give a short description of the problem
02:13:36 <prologic> I don't want help, just want help in explanation
02:13:40 <prologic> I don't understand his words ;)
02:13:47 <shapr> oh, okay
02:13:55 <prologic> hehe
02:14:02 <prologic> http://daisy.ods.org/~prologic/2.pdf
02:14:38 <prologic> takes all the fun away not doing it yourself, but it gets frustrating when you don't understand it though
02:15:30 <shapr> which part?
02:15:38 <prologic> Ex2 part 2, is what I'm having problems with understanding
02:15:51 <prologic> I think I've done 1. ok, similar to the definition of a tree
02:16:00 <prologic> data Box = Compartment Box Box | Box
02:16:17 <earthy> ah, whoo, 280x192 it was...
02:17:21 <shapr> prologic: he's saying 'there is a way to calculate the width and height of any Box type if the shortest line is always length one'
02:17:41 <shapr> assuming you have a suitable Box type, of course
02:18:00 <shapr> so he wants you to find out how to do that
02:18:03 <prologic> well my box type works on paper and in hugs
02:18:37 <prologic> see I was confused about the "shortest edge length of any compartment is 1 whole unit"
02:18:43 <prologic> that mean each compartment is 1x1 ?
02:18:46 <earthy> shapr: no, that's not what he's saying in exercise 2 part 2.
02:18:55 <prologic> ahh lol
02:19:00 <shapr> earthy: are you sure?
02:19:01 <prologic> see different interpretations already :(
02:19:04 <earthy> shapr: yes. ;)
02:19:10 <prologic> this is why I'm stuck :)
02:19:11 <shapr> earthy: explain it to me?
02:19:21 <shapr> I think he's saying the smallest box is 1x1
02:19:33 <prologic> that's kinda what I gathered too
02:19:38 <earthy> it's simple: `assuming the boxes can only be drawn on a grid'
02:20:17 <earthy> shapr: the smallest compartment is 1x1
02:20:35 <prologic> even if the box was only divided into two compartments ?
02:20:40 <shapr> is the grid part mentioned anywhere?
02:20:43 <cm> heyho people
02:20:50 <shapr> hi cm
02:20:56 <earthy> shapr: no. ;) but the box is rectangular.
02:20:57 <cm> hey shapr :)
02:21:34 <earthy> he is saying that the smallest edge of the smallest compartment defines a grid
02:22:13 <prologic> http://www.cit.gu.edu.au/~arock/Virgil/Virgil.cgi/ppl.03.2?forum+34+1
02:22:22 <earthy> but the exercise is somewhat subtle
02:22:37 <earthy> and prologic, your data type does not encapsulate all the data you need.
02:22:46 <prologic> what am I missing ?
02:23:03 <earthy> whether the cut was horizontal or vertical.
02:23:15 <prologic> hrmm k
02:25:05 <cm> shapr: how's you and the haskell? :)
02:28:16 <earthy> the University of Durham is setting up a new CS group apparently.
02:29:55 <prologic> earthy, having trouble working out this data type :)
02:31:08 <shapr> cm: slow, work is keeping me away
02:31:17 <cm> shapr: are you working in web business?
02:31:24 <shapr> yup
02:31:34 <shapr> and we got a new website contract today
02:31:49 <cm> we share the same disease :)
02:32:05 <shapr> I'm using Zope, at least I get to write Python
02:49:53 * harsha123 is reading about roumers wheather Pink Flyod actually had a alternative soundtrack to The wizard of Oz..
02:50:33 <harsha123> dunno where are the roumer mills.. :)
02:50:42 <cm> shapr: is Zope any cool? i'm pretty familiar with python in general, not with zope-ish webdev, tho.
02:55:33 <shapr> zope is powerful
03:09:23 <earthy> prologic: data Container = VSplit Container Container | HSplit Container Container | JustContainer
03:09:30 <earthy> type Box = Container
03:10:01 <earthy> now go and think. :)
03:32:14 <earthy> ha. voer
03:32:17 <earthy> (wce)
04:13:15 <p3rs3ph4n3> hi i have a doubt in haskell someone can help me please? :)
04:13:36 <ski> sure
04:13:42 <p3rs3ph4n3> thanks
04:13:45 <p3rs3ph4n3> so that is it
04:13:51 <p3rs3ph4n3> i'm doing a function
04:13:56 <p3rs3ph4n3> named safetail
04:13:58 <ski> mm
04:14:03 <p3rs3ph4n3> and i'm doing like that :
04:14:13 <p3rs3ph4n3> safetail xs = if null xs then [] else tail xs
04:14:29 <ski> ok
04:14:29 <p3rs3ph4n3> hugs when i load doesn't give error
04:14:39 <p3rs3ph4n3> but when i do safetail []
04:14:43 <p3rs3ph4n3> it gives an error
04:14:52 <p3rs3ph4n3> what am i doing bad?
04:15:13 <tic> there's an easier way:
04:15:18 <tic> safetail xs = tail xs
04:15:22 <tic> safetail [] = []
04:15:39 <p3rs3ph4n3> yes tic but i have to do it with the conditional
04:15:42 <tic> a-ha.
04:15:44 <ski> is it this error ?
04:15:44 <ski> ERROR - Cannot find "show" function for:
04:15:44 <ski> *** Expression : let {...} in safetail []
04:15:45 <ski> *** Of type    : [a]
04:15:48 <tic> well then, test for  [] instead?
04:16:01 <p3rs3ph4n3> ERROR - Cannot find "show" function for:
04:16:01 <p3rs3ph4n3> *** Expression : safetail []
04:16:01 <p3rs3ph4n3> *** Of type    : [a]                
04:16:07 <p3rs3ph4n3> this is the error
04:16:12 <ski> aha, as i thought
04:16:23 <ski> try  safetail ""
04:16:33 <ski> or safetail ([] :: [Int])
04:17:00 <p3rs3ph4n3> but how do i do that with the conditional?!
04:17:03 <ski> p3rs3ph4n3 : it doesn't know how to print an arbitrary list
04:17:17 <Igloo> I think it should work in recent hugs and GHC, but possibly CVS only
04:17:27 <Igloo> GHCi I mean
04:17:39 <ski> Igloo : why, is there some defaulting done ?
04:17:44 <kosmikus> in ghci 6.0.1, it does not yet work
04:17:47 <p3rs3ph4n3> ski but when i do a list that's not empty it gives correct result
04:18:01 <Igloo> It defaults things with Show in the context when interactive, yes
04:18:22 <Igloo> p3rs3ph4n3: This isn't going to cause a problem in your actual program
04:18:24 <ski> yes, but if the list is not empty, it (most often) can infer what type the elements in the list are
04:19:12 <ski> you could make a type-signature to safetail, constraining it like :
04:19:22 <ski> safetail :: [Int] -> [Int]
04:19:36 <ski> or safetail :: Show a => [a] -> [a]
04:19:51 <p3rs3ph4n3> ski but that is in pattern-matching
04:19:54 <ski> but perhaps you are not allowed to constrain it in that way
04:20:02 <p3rs3ph4n3> can i do so in conditional?
04:20:54 <ski> no what i wrote just above is a type signature. often put just over the definition (whether that is pattern-matching or conditional)
04:21:32 <p3rs3ph4n3> i'll try it to see if it works just a minute please
04:21:58 <ski> the reason you get an error is because hugs don't know how to print an arbitrary list.
04:22:08 <ski> so your function definition is working
04:22:25 <ski> mm
04:22:27 <p3rs3ph4n3> thank you very much
04:22:31 <p3rs3ph4n3> it's working
04:23:05 <ski> but, in most programs, you don't want to restrain the function's type like that
04:23:30 <p3rs3ph4n3> no that it works in conditional i'll do it for guarded equations and for pattern-matching thank you very much for your help
04:23:48 <ski> p3rs3ph4n3 : do you understand why the error occured, and why it does not matter much ?
04:24:03 <p3rs3ph4n3> ski i know cause in the other functions i haven't put the type and it worked well
04:24:15 <p3rs3ph4n3> yes i did :)
04:24:36 <ski> the problem was with testing and printing lists, not with your code
04:24:51 <p3rs3ph4n3> so when a error of show occurs i have to say to hugs what's the type right?
04:25:37 <ski> so you don't normally constrain the type of something, just so you can print the empty list.  instead you use tests with more info
04:26:09 <ski> like   safetail ""   and safetail ([] :: [Double])
04:26:32 <p3rs3ph4n3> i see :)
04:27:10 <ski> yes, you don't have to constrain the functions type (unless you already want that for other reasons), just use a list where the element type is printable
04:27:13 <ski> good
04:27:35 <p3rs3ph4n3> thanks :)
04:28:06 * Igloo sighs at gcc issues
04:29:37 <p3rs3ph4n3> at guarded equations it's working too :)
04:29:43 <ski> mm
04:29:49 <p3rs3ph4n3> now it's only pattern-matching :)
04:30:22 <p3rs3ph4n3> last year i gave prolog
04:30:34 <p3rs3ph4n3> but i'm understanding much better haskell
04:30:46 <p3rs3ph4n3> i find it more easy don't know why
04:30:58 <ski> gave ? you was a TA in prolog
04:31:09 <ski> ?
04:31:10 <p3rs3ph4n3> what's a TA?
04:31:16 <ski> Teaching assistant
04:31:17 <p3rs3ph4n3> ño lol
04:31:22 <p3rs3ph4n3> a student
04:31:29 <p3rs3ph4n3> i gave = i learned
04:31:31 <p3rs3ph4n3> lol
04:31:46 <ski> hm, you meant you *took* a prolog course, right ?
04:31:53 <p3rs3ph4n3> yes
04:32:10 * ski got confused about "gave"
04:32:15 <p3rs3ph4n3> ahaha
04:32:43 <p3rs3ph4n3> i'm only a student yet
04:32:52 <p3rs3ph4n3> when i finished the course
04:33:05 <p3rs3ph4n3> maybe i'll become a teacher or something else
04:33:16 <p3rs3ph4n3> i don't know the future :)
04:33:43 <ski> but if you have learned prolog, you shouldn't have much difficulty with pattern-matching in haskell, yes ?
04:33:51 <ski> mm
04:34:05 <p3rs3ph4n3> more or less
04:34:14 <p3rs3ph4n3> as i told you
04:34:24 <p3rs3ph4n3> i didn't understand very well prolog
04:34:35 <p3rs3ph4n3> i'm understanding better haskell
04:34:43 <ski> hm, ok
04:34:58 <p3rs3ph4n3> cause prolog it was in the first year of university
04:35:05 <p3rs3ph4n3> haskell is the second year
04:35:21 <ski> ok
04:35:48 <ski> you had problems with backtracking ? logic variables ?
04:36:31 <p3rs3ph4n3> yes
04:36:38 <ski> both ?
04:36:50 <p3rs3ph4n3> i'll explain to you
04:36:57 <ski> ok :)
04:37:05 <p3rs3ph4n3> prolog ended last year in university
04:37:23 <p3rs3ph4n3> because it was a reestructuration in the course
04:37:44 <earthy> fala en portugues, vo traducir
04:37:45 <p3rs3ph4n3> i didn't succed in prolog
04:37:54 <ski> you mean they don't use in in intro course anymore ?
04:38:17 <p3rs3ph4n3> so this year they gave haskell for first year
04:38:27 <ski> ok
04:39:03 <earthy> (that is, if you want me to :))
04:39:29 <p3rs3ph4n3> earthy sorry didn't understand?!
04:39:42 <ski> want you to what ?   not succeed ;)
04:39:45 <ski> ?
04:40:07 <earthy> pt == portugal, right?
04:40:24 <p3rs3ph4n3> you are portuguese? that's it?
04:40:30 <earthy> nope
04:40:38 <ski> he's asking if you are in portugal
04:40:38 <earthy> but I can translate portuguese if you want me to. :)
04:40:39 <p3rs3ph4n3> so?!
04:40:50 <p3rs3ph4n3> oh lol
04:41:10 <p3rs3ph4n3> thanks but i prefer to train a little my english
04:41:16 <earthy> (ofcourse, I'm quite a bit better at reading portuguese then at writing it ;))
04:41:36 <p3rs3ph4n3> but how do you learned portuguese?
04:41:39 <earthy> quick tip: word order is Different in English
04:41:49 <earthy> sou brasileiro, mesmo
04:41:54 <p3rs3ph4n3> ah
04:42:14 <p3rs3ph4n3> so if you are brasilian you talk portuguese :)
04:42:21 <earthy> problem is we moved to the netherlands when I was like, 7, so I don't really speak (or write) portuguese too well anymore.
04:42:29 <earthy> brasilian portuguese, yes. ;)
04:42:34 <p3rs3ph4n3> it's the same but with other sound in words :)
04:42:47 <earthy> and some different words
04:42:55 <p3rs3ph4n3> yes some :)
04:42:58 <earthy> (kinda like the difference between haskell and clean)
04:43:07 <ski> heh
04:43:44 <p3rs3ph4n3> but earthy are you studying haskell in netherlands?
04:43:57 <earthy> um. what to answer. :)
04:44:13 <p3rs3ph4n3> just the truth :)
04:44:32 <earthy> not as such, no. :)
04:44:56 <earthy> (I just happen to like using it)
04:45:01 <earthy> prefer it over ML, really
04:45:05 <p3rs3ph4n3> oh i see
04:45:41 <p3rs3ph4n3> but i've noticed that in university we learn a few of functional programming
04:46:01 <p3rs3ph4n3> the most we learn is C, java, etc
04:46:13 <earthy> sounds like any other CS program out there
04:46:19 <p3rs3ph4n3> and i couldn't learn java yet lol
04:46:43 <earthy> good for you! get spoiled by haskell, and then see what horrors are still out there. ;)
04:47:11 <p3rs3ph4n3> :)
04:47:45 <p3rs3ph4n3> i think i'll have to learn all to succed in course lol
04:47:56 <p3rs3ph4n3> succed :)
04:48:02 <p3rs3ph4n3> ups succeed
04:48:09 <p3rs3ph4n3> now that's the word!
04:49:01 <ski> p3rs3ph4n3 : you perhaps meant if i want you to explain about prolog.  then, sure
04:49:25 <p3rs3ph4n3> didn't understand ski
04:49:53 <p3rs3ph4n3> i don't remember very well prolog
04:49:58 <p3rs3ph4n3> but i know next year
04:50:12 <p3rs3ph4n3> i'll have a very little of prolog
04:50:21 <ski> in another course ?
04:50:24 <p3rs3ph4n3> in introduction to artificial inteligence
04:50:28 <ski> aha
04:50:41 <p3rs3ph4n3> ski is the same course
04:50:45 <p3rs3ph4n3> it's university
04:51:07 <p3rs3ph4n3> course it's informática (informatics in english i guess)
04:51:47 <ski> same course as the one you are lerning haskell in ?
04:51:54 <p3rs3ph4n3> yes
04:52:00 <ski> s/lerning/learning/
04:52:04 <ski> ok
04:53:11 <p3rs3ph4n3> and you ski are learning or teaching haskell?
04:53:30 <ski> IMO functional and logic programming is more similar to each other, than to imperative languages, like C,Java,Ada
04:54:16 <p3rs3ph4n3> Java it's not imperative, java it's oriented object
04:54:29 <ski> not formally learning haskell ATM. not (formally) teaching it either. (if you don't count a little halp on irc formal teaching i.e. ;)
04:54:41 <ski> and Java is imperative
04:54:53 <ski> 'tis not exclusive
04:55:06 <p3rs3ph4n3> my teachers said it's object oriented
04:55:22 <p3rs3ph4n3> you're confusing me :|
04:55:26 <ski> it is (at least one can program oo in it ;)
04:56:17 <p3rs3ph4n3> so it's both things?
04:56:22 <ski> by imperative here, i mean roughly, that sequencing,assignment (and perhaps control flows like break,goto)
04:56:34 <ski> is important in it
04:56:40 <ski> yes
04:56:58 <ski> depends on exact definition of imperative, i guess, though
04:57:12 <p3rs3ph4n3> oh i see
04:57:53 <ski> it is possible to do oo in functional programming as well as in logic (or so i've heard)
04:57:59 <p3rs3ph4n3> give me just five minutes to try doing pattern-matching to safetail
04:58:05 <ski> mm, sure
05:02:57 <p3rs3ph4n3> an error :(
05:03:03 <p3rs3ph4n3> i did so :
05:03:13 <p3rs3ph4n3> safetail :: [Int] -> [Int]
05:03:13 <p3rs3ph4n3> null xs = []
05:03:13 <p3rs3ph4n3> _       = tail xs
05:03:22 <p3rs3ph4n3> ERROR "C:\Os meus documentos\safetailpm.hs":3 - No variables defined in lhs patt
05:03:22 <p3rs3ph4n3> ern                                       
05:03:43 <p3rs3ph4n3> what's lhs pattern ?
05:04:07 <p3rs3ph4n3> don't read that
05:04:07 <ski> is this supposed to be pattern-matching or conditions/guards ?
05:04:18 <p3rs3ph4n3> pattern-matching
05:04:21 <ski> ok
05:04:21 <p3rs3ph4n3> but i think
05:04:27 <p3rs3ph4n3> i detected
05:04:29 <p3rs3ph4n3> the error
05:04:41 <ski> ok ?
05:05:24 <p3rs3ph4n3> it doesn't give the same error
05:05:35 <p3rs3ph4n3> safetail :: [Int] -> [Int]
05:05:35 <p3rs3ph4n3> safetail null xs = []
05:05:35 <p3rs3ph4n3> safetail _       = tail xs
05:05:44 <p3rs3ph4n3> ERROR "C:\Os meus documentos\safetailpm.hs":2 - Equations give different arities
05:05:44 <p3rs3ph4n3>  for "safetail"      
05:05:50 <ski> yes, that was the first obvious error :)
05:06:09 <p3rs3ph4n3> first? there's more?
05:06:16 <ski> safetail should take one argument, yes ?
05:06:46 <ski> in "safetail null xs", there are two, namely "null" and "xs"
05:07:01 <p3rs3ph4n3> but i have to use null
05:07:05 <ski> you know how to fix it ?
05:07:09 <p3rs3ph4n3> to see if it's null or not
05:07:15 <harsha123> Igloo: I ran a dh_make in the source directory of a package. its created a rules file...but i dn not know where i've to make the necessary changes.
05:07:15 <ski> (hint : parenthesis)
05:07:20 <p3rs3ph4n3> lol
05:07:27 <p3rs3ph4n3> i'm so stupid sometimes
05:07:58 <ski> did you say you are required to use null, for the pattern-matching version as well ?
05:08:10 <p3rs3ph4n3> it's not required but
05:08:15 <ski> ok
05:08:16 <p3rs3ph4n3> they give as hint
05:08:18 <p3rs3ph4n3> use null
05:08:19 <Igloo> harsha123: It doesn't run make (or $(MAKE)) anywhere, nor have comments indicating where you'd normally change it?
05:08:38 <ski> so waht does your code look like now ?  ;)
05:09:09 <p3rs3ph4n3> looks good
05:09:16 <p3rs3ph4n3> but it's giving another error
05:09:22 <ski> paste it !
05:09:26 <p3rs3ph4n3> safetail :: [Int] -> [Int]
05:09:26 <p3rs3ph4n3> safetail (null xs) = []
05:09:26 <p3rs3ph4n3> safetail _         = tail xs
05:09:35 <p3rs3ph4n3> ERROR "C:\Os meus documentos\safetailpm.hs":2 - Syntax error in declaration (une
05:09:35 <p3rs3ph4n3> xpected `)')                                            
05:09:38 <ski> yes, we are not done yet :)
05:09:52 <ski> ??
05:09:54 <ski> hmm
05:10:38 <p3rs3ph4n3> hugs don't allow the parentheses there
05:10:42 <ski> is this definition the first text in safetailpm.hs ?
05:11:01 <ski> yes it should do. i'm suspecting it complains about some other code
05:11:10 <harsha123> Igloo: hmm it has a $(MAKE) install DESTDIR=$(CURDIR)/debian/serialmail
05:11:22 <p3rs3ph4n3> the error it's about the last code i past
05:11:25 <p3rs3ph4n3> paste
05:11:37 <harsha123> Igloo: serialmail is the package that i am trying to create
05:11:53 <Igloo> Did you say it was just a shell script?
05:12:08 <ski> but the parenthesis are vaild there, in case i'm not seeing the obvious ..
05:12:26 <ski> s/seeing/missing/  :)
05:12:31 <harsha123> Igloo: hmmm not this..  :)
05:12:45 <prologic> ahh good earthy you're still here :)
05:12:50 <p3rs3ph4n3> it should give
05:12:53 <prologic> I worked it out while watching the simpsons 
05:12:54 <harsha123> Igloo: i was trying to package serialmail... actually just trying to learn
05:13:02 <Igloo> ski: They are valid, but having that contents there is meaningless
05:13:14 <prologic> earthy, yours has nicer looking names :)
05:13:24 <p3rs3ph4n3> Igloo so how to solve the problem?
05:13:42 <ski> p3rs3ph4n3 : can you paste the text from the first two lines in your file ?
05:13:59 <p3rs3ph4n3> safetail :: [Int] -> [Int]
05:14:00 <p3rs3ph4n3> safetail (null xs) = []
05:14:03 <Igloo> harsha123: If whatever you are packaging has make, make install, make clean or make distclean (I don't know which one it will default to) then the generated one might just work
05:14:21 <prologic> earthy, data Box = HCut Box Box | VCut Box Box | Box
05:14:28 <Igloo> You either want a pattern to match against there or to put the conditional in a guard
05:14:29 <ski> Igloo : i know, just taking one thing at a time ... :)
05:14:29 <p3rs3ph4n3> only if hugs don't consider (null xs) as a int list
05:14:29 <prologic> earthy, not as elegant as yours :(
05:14:40 <Igloo> Ah, OK
05:15:04 <ski> p3rs3ph4n3 : yes
05:15:31 <ski> have you seen a pattern-matching definition of e.g. head, tail, length, etc ?
05:15:38 <harsha123> Igloo: is there any change that I would have to make to install int serial mail binary in /usr/bin/ ?
05:15:38 <p3rs3ph4n3> yes
05:16:03 <ski> then you remember that the def for head, e.g., looked something like :
05:16:16 <ski> head (x:xs) = x
05:16:26 <ski> and for length :
05:16:26 <Igloo> harsha123: Probably just putting "/usr" on the end of the DESTDIR=... will do it
05:16:31 <ski> length [    ] = 0
05:16:37 <p3rs3ph4n3> sorry i haven't seen head
05:16:41 <ski> length (x:xs) = 1 + length xs
05:16:47 <p3rs3ph4n3> i've only seen (&&)
05:16:51 <ski> ok
05:17:05 <harsha123> Igloo: Ok
05:17:18 <p3rs3ph4n3> wait i've an idea
05:17:19 <ski> but if you want to know if a list is empty, you can either use the function "null"
05:17:48 <ski> in that case you get a Bool (to use e.g. in an if-then-else or in a guard)
05:17:57 <ski> ok, i'm waiting
05:18:12 <p3rs3ph4n3> safetail :: [Int] -> [Int]
05:18:12 <p3rs3ph4n3> safetail []        = []
05:18:12 <p3rs3ph4n3> safetail _         = tail xs
05:18:21 <ski> yesssss !!!!
05:18:26 <p3rs3ph4n3> i've changed null to []
05:18:27 <ski> :)
05:18:32 <p3rs3ph4n3> but other error
05:18:49 <p3rs3ph4n3> ERROR "C:\Os meus documentos\safetailpm.hs":3 - Undefined variable "xs"
05:18:53 <ski> (you mean  null xs  to  [])
05:19:00 <p3rs3ph4n3> yes
05:19:12 <ski> you see the problem now ?
05:19:32 <p3rs3ph4n3> yes he doesn't know xs is a int list
05:19:46 <p3rs3ph4n3> in pattern-matching can i use where?
05:19:52 <earthy> _
05:19:58 <ski> you are using xs in the function body of the second def. line, but where do xs come from ?
05:20:11 <ski> yes
05:20:25 <ski> you can use where
05:20:46 <ski> where is orthogonal to pattern-matching vs conditionals
05:21:11 <p3rs3ph4n3> safetail :: [Int] -> [Int]
05:21:11 <p3rs3ph4n3> safetail []        = []
05:21:11 <p3rs3ph4n3> safetail _         = tail xs
05:21:11 <p3rs3ph4n3>                       where
05:21:11 <p3rs3ph4n3>                          xs = [] 
05:21:18 <p3rs3ph4n3> now i'll see if it works
05:21:41 <ski> does that give the answers you think it should ?
05:21:45 <ski> try it
05:22:25 <p3rs3ph4n3> for empty it gives well
05:22:33 <p3rs3ph4n3> now i'll try not empty
05:22:43 <ski> yes ...   and for nonempty ? ;D
05:23:05 <p3rs3ph4n3> Main> safetail[2,3,4]
05:23:06 <p3rs3ph4n3> Program error: {tail []}
05:23:09 <p3rs3ph4n3> error
05:23:11 <ski> :)
05:23:13 <ski> yes
05:23:30 <p3rs3ph4n3> i'll kill hugs lol
05:23:47 <ski> first you are saying that the safetail of an empty list is just an empty list
05:24:16 <ski> then you say that the safetail of any other list is the tail of xs, where xs is (always) the empty list
05:24:30 <ski> ok ?
05:24:34 <p3rs3ph4n3> yes
05:24:46 <ski> you see what it is doing wrong ?
05:24:50 <p3rs3ph4n3> but i only wanted to say that xs was a list
05:25:00 <ski> but which list *
05:25:02 <ski> ?
05:25:15 <ski> (s/*/?/)
05:25:17 <p3rs3ph4n3> safetail :: [Int] -> [Int]
05:25:17 <p3rs3ph4n3> safetail []        = []
05:25:17 <p3rs3ph4n3> safetail _         = tail xs
05:25:17 <p3rs3ph4n3>                       where
05:25:17 <p3rs3ph4n3>                          xs = [1..n]  
05:25:25 <p3rs3ph4n3> maybe it works like this
05:25:26 <ski> which n ?   :)
05:25:30 <earthy> you just shifted your problem to n. ;)
05:25:32 <earthy> _
05:25:58 <p3rs3ph4n3> _ i could but this in the middle of list?
05:26:14 <ski> before, in the conditional version, you did :
05:26:15 <ski> safetail xs = if null xs then [] else tail xs
05:26:32 <p3rs3ph4n3> yes
05:26:46 <ski> so the answer to the question "which xs", is here : the xs that is the argument to safetail
05:26:51 <ski> got it ?
05:27:17 <p3rs3ph4n3> so
05:27:28 <p3rs3ph4n3> safetail :: [Int] -> [Int]
05:27:28 <p3rs3ph4n3> safetail []        = []
05:27:28 <p3rs3ph4n3> safetail _         = tail xs
05:27:28 <p3rs3ph4n3>                       where
05:27:28 <p3rs3ph4n3>                          xs = [xs]
05:27:32 <p3rs3ph4n3> that's it?
05:27:37 <p3rs3ph4n3> i'll test
05:27:49 <ski> hmm, .. no                  ( :) )
05:28:17 <ski> not you say : the xs that is a list with the single element, namely xs
05:28:35 <p3rs3ph4n3> but i want to say all the elements
05:28:42 <ski> probably it'l complain about infinite type or something ..
05:28:54 <ski> all the elements of *what* ?
05:28:57 <p3rs3ph4n3> ERROR "C:\Os meus documentos\safetailpm.hs":5 - Type error in function binding
05:28:57 <p3rs3ph4n3> *** Term           : xs
05:28:57 <p3rs3ph4n3> *** Type           : [a]
05:28:57 <p3rs3ph4n3> *** Does not match : a
05:28:57 <p3rs3ph4n3> *** Because        : unification would give infinite type       
05:29:03 <ski> as i though
05:29:05 <p3rs3ph4n3> all elements of xs
05:29:06 <ski> thought
05:29:14 <ski> but what is xs
05:29:20 <p3rs3ph4n3> a list
05:29:26 <ski> say e.g.  safetail [1,2,3,4]
05:29:27 <p3rs3ph4n3> [[]]?
05:29:32 <ski> now what is xs ?
05:29:38 <p3rs3ph4n3> 1,2,3,4
05:29:42 <ski> yes
05:29:47 * earthy sees a good case for helium
05:29:52 <ski> the argument to safetail
05:30:09 <ski> earthy : :)
05:30:28 <p3rs3ph4n3> ERROR "C:\Os meus documentos\safetailpm.hs":3 - Type error in explicitly typed b
05:30:28 <p3rs3ph4n3> inding
05:30:28 <p3rs3ph4n3> *** Term           : safetail
05:30:28 <p3rs3ph4n3> *** Type           : [Int] -> [[a]]
05:30:28 <p3rs3ph4n3> *** Does not match : [Int] -> [Int]         
05:30:50 <ski> so in the previous version you just did :
05:30:51 <ski> safetail xs = if null xs then [] else tail xs
05:31:05 <p3rs3ph4n3> yes
05:31:16 <ski> p3rs3ph4n3 : no [[]] is also wrong, as you see
05:31:45 <ski> so this says : safetail of any list, *call*it*xs*, is blahaha...
05:32:20 <p3rs3ph4n3> yes
05:32:48 <ski> btw : perhaps you think that the "_" means : all the other cases   , right ?
05:33:05 <ski> well, it doesn't
05:33:05 <p3rs3ph4n3> yes
05:33:31 <Lunar^> First hour and a half... everything goes find... students are happy, thanks Hudak's book
05:33:32 <ski> "_" means : anything, and we'll ignore it, so we don't even give it a name
05:34:00 <p3rs3ph4n3> but in pattern-matching we don't have to _ to see otherwise of guarded equations ?
05:34:04 <ski> "someVariable" means : anything, and btw, call it someVariable
05:34:11 <ski> no
05:34:41 <ski> because the lower def. line is only ever tried if all the above fails
05:35:21 <ski> that is why one can think _ means otherwise, as it doesn't mean
05:35:44 <p3rs3ph4n3> i've done so and it's working:
05:35:49 <ski> had you seen a pattern-matching definition of length ?
05:35:53 <p3rs3ph4n3> safetail :: [Int] -> [Int]
05:35:53 <p3rs3ph4n3> safetail []        = []
05:35:53 <p3rs3ph4n3> safetail xs        = tail xs
05:35:55 <ski> ok
05:36:09 <ski> now try it :)
05:36:48 <p3rs3ph4n3> but something it's confusing me pattern-matching doesn't have to have always a _ ? 
05:36:55 <prologic> yeh _ means "don't care", right ? which means the pattern is bound when all other patterns fail to match
05:37:04 <prologic> no it doesn't
05:37:24 <p3rs3ph4n3> oh is that i thought i had always a _
05:37:30 <ski> usually the _ is used as tha last def. line, if used at all  (in simple patterns anyway)
05:37:49 <ski> no
05:37:54 <p3rs3ph4n3> õh so i was complicating what was obvious
05:37:57 <prologic> most patterns can be caught without having to use _ neway
05:37:58 <ski> you don't always have to have a _
05:38:45 <ski> in pattern-matching : _ means the same as xs, except _ refrains from naming whatever is matched to it
05:39:05 <ski> ok ?
05:39:14 <p3rs3ph4n3> with you i just learned a few things i didn't understood in class :)
05:39:19 <p3rs3ph4n3> ok
05:39:21 <ski> nice :)
05:41:10 <p3rs3ph4n3> but for example
05:41:12 <ski> btw, you don't always have to use a "otherwise" in guards/conditions either
05:41:18 <p3rs3ph4n3> in this pattern-matching
05:41:21 <ski> mm
05:41:38 <p3rs3ph4n3> that comes from a guarded equation
05:41:54 <p3rs3ph4n3> pred n | n>=0 = n-1
05:42:07 <p3rs3ph4n3> | otherwise = 0
05:42:23 <p3rs3ph4n3> i could write something like this
05:42:40 <p3rs3ph4n3> pred :: Int -> Int
05:43:01 <p3rs3ph4n3> pred (n>=0) = n-1
05:43:10 <p3rs3ph4n3> pred _ = 0
05:43:23 <p3rs3ph4n3> rigth?
05:43:23 <ski> no
05:43:35 <ski> n >= 0  is a test, not a pattern
05:43:50 <ski> just like "null xs" is a test
05:44:09 <ski> (a test is an expression, that happens to have type Bool)
05:44:39 <p3rs3ph4n3> so i could do
05:44:54 <ski> expressions and patterns are different things
05:44:55 <p3rs3ph4n3> pred 0 = (-1)
05:45:07 <p3rs3ph4n3> pred n = n-1
05:45:20 <p3rs3ph4n3> pred (-n) = 0
05:45:29 <p3rs3ph4n3> it was rigth like this?
05:45:38 <ski> the last line is not possible
05:46:07 <p3rs3ph4n3> but it's in parentheses
05:46:20 <ski> many strings of program code that can be interpreted as a pattern can also be interpreted as an expression
05:46:35 <ski> yes, but -n is not a pattern
05:46:50 <ski> e.g.
05:46:52 <ski> for lists
05:47:00 <ski> these are patterns :
05:47:22 <ski> []  [_]  [a,b]  (a:as) (a:b:[c,d])
05:47:30 <ski> but these are not :
05:47:47 <ski> (xs ++ ys)   (reverse xs)
05:48:12 <p3rs3ph4n3> yes but ints are both positive and megative aren't they?
05:48:25 <ski> you can extend yourself what expressions you can write by making more functions and constants
05:49:09 <ski> but you can't extend what patterns you can make in any similar way   (e.g. considering a pattern for a particular type)
05:49:13 <ski> yes
05:49:28 <ski> you can match against integer *literals*
05:49:39 <ski> and integer variables (matching anything)
05:49:56 <ski> and against _  (the wildcard/"don't care")
05:50:11 <ski> 12 56 -678
05:50:17 <ski> these are integer literals
05:50:28 <p3rs3ph4n3> i could put pred _ = 0
05:50:55 <p3rs3ph4n3> pred 0 = (-1) in the result i can put negative numbers?
05:51:01 <ski> the - in front of 678 is to be considered part of the number  (i.e. it is not exactly like  "-n" where n is a *variable*)
05:51:11 <ski> yes
05:51:35 <p3rs3ph4n3> but how do i make pred n be always positive
05:51:35 <ski> in the result you can use any functions defined (by you or predefined or whatever)
05:51:58 <ibid> besides, if -n was a pattern it ought to match anything and bind n to the negation of the value :)
05:51:59 <ski> but you can't extend what patterns you can make in a similar way
05:52:07 <ski> ibid : yes
05:53:02 <p3rs3ph4n3> so this arew defined pred _ = 0
05:53:13 <p3rs3ph4n3> pred 0 = (-1)
05:53:28 <p3rs3ph4n3> but if i put pred n = n-1
05:53:39 <ski> perhaps one could say that pattern-matching takes care of cases with a 'sharp contour', like this integer literal "-6", or this list with variable holes in it "x:xs"
05:53:46 <p3rs3ph4n3> he will acept negative values from the user 
05:53:56 <ski> yes
05:54:30 <ibid> sharp contour?
05:54:31 <ski> so to check these more 'amorphous' conditions, you have to use guards or if-then-else
05:54:42 <p3rs3ph4n3> pred (+n) = n-1
05:54:46 <p3rs3ph4n3> is it possible?
05:54:49 <kosmikus> no
05:54:53 <kosmikus> you have to use guards then
05:55:00 <kosmikus> pred n | n >= 0 =  n-1
05:55:33 <p3rs3ph4n3> kosmikus but that expression gives an error
05:55:40 <ski> ibid : like, only sharp and clear (data) constructors (with possible holes, i.e. vars)
05:55:41 <p3rs3ph4n3> oh no
05:55:51 <p3rs3ph4n3> gives error in patern matching
05:56:10 <p3rs3ph4n3> so i can't do this function in pattern-matching rigth?
05:56:21 <ski> not totally
05:56:27 <kosmikus> no
05:56:45 <kosmikus> you cannot use functions in pattern matching, only literals and constructors
05:56:47 <ski> you can, if you want, match on 0
05:57:08 <ski> or on (-1),(-2),..  and as (finitely) many of these you like
05:57:23 <p3rs3ph4n3> yes but see
05:57:33 <p3rs3ph4n3> pred 0 = 0 so good
05:57:41 <p3rs3ph4n3> sorry
05:57:47 <p3rs3ph4n3> pred 0 = (-1)
05:57:55 <p3rs3ph4n3> pred _ = 0
05:58:14 <ski> p3rs3ph4n3 : there has been talk about an extension, called views, which IIRC, would allow you to make this function pattern-matching, only ...
05:58:14 <p3rs3ph4n3> but pred n = n-1 will accept negative values
05:58:30 <ski> yes
05:58:46 <ski> if you don't use guards or if-then-else, e.g.
05:59:11 <p3rs3ph4n3> but i can use guards or if-then-else in pattern-matching?
05:59:29 <ski> you mean, at the same time ?   no problem at all
05:59:40 <p3rs3ph4n3> just like
06:00:00 <p3rs3ph4n3> pred n | n = n-1 if n>= 0
06:00:13 <p3rs3ph4n3> no
06:00:26 <p3rs3ph4n3> pred :: Int -> Int
06:00:34 <ski> each def. line can have zero or more guards.  each body to the right of a "=" can have as many if-then-else's as it wants to
06:00:57 <ski> go on
06:00:59 <p3rs3ph4n3> pred n = n -1 if n >= 0
06:01:07 <p3rs3ph4n3> pred _ = 0
06:01:20 <p3rs3ph4n3> but i have to put hipothese to then and else
06:01:26 <ski> isn't that miranda notation ??
06:01:36 <ski> hipothese ?
06:01:47 <p3rs3ph4n3> i don't learned miranda
06:01:49 <earthy> hypothesis
06:01:58 <ski> ok, nevermind about that then.
06:02:11 <ski> you can do
06:02:15 <p3rs3ph4n3> yes hypothesis your rigth earthy :)
06:02:28 <ski> pred n = if n >= 0  then ... else ...
06:02:40 <ski> or you can do
06:02:58 <ski> pred n | n >= 0 = n - 1
06:03:09 <ski> pred n          = 0
06:03:16 <ski> ok ?
06:03:35 <p3rs3ph4n3> yes ski but the last one isn't pattern-matching or is?
06:03:45 <ski> remember, it's the "if" part that is directly after the "|"
06:03:56 <ski> well
06:04:08 <ski> change the last n to _  if you like
06:04:11 <ski> :)
06:04:19 <p3rs3ph4n3> :)
06:05:30 <ski> so you see, each def. line can have as many guards it wants, and if all of them fails, the next def. line is just tried
06:05:56 <ski> and if there are no more def. lines, then you get a run-time error
06:06:30 <ski> just like you get with  tail ([] :: [Int])
06:06:45 <ski> because tail only has one def.line :
06:06:50 <ski> tail (_:xs) = xs
06:08:13 <p3rs3ph4n3> oh i see
06:08:19 <p3rs3ph4n3> so pattern-matching
06:08:24 <p3rs3ph4n3> it's like a mix of all
06:08:31 <ski> (that was the interaction between multiple def. lines (with possible pattern-matching) and guards)
06:08:36 <ski> yes
06:09:46 <p3rs3ph4n3> but a question
06:09:50 <ski> mm
06:09:56 <p3rs3ph4n3> pred :: Int -> Int
06:09:56 <p3rs3ph4n3> pred n        = if (n>=0) then (n-1) else 0
06:09:56 <p3rs3ph4n3> pred _        = 0
06:10:07 <p3rs3ph4n3> i could remove the last line
06:10:10 <ski> yes
06:10:15 <ski> it can't be reached
06:10:26 <p3rs3ph4n3> and it's pattern-matching in the same
06:10:58 <ski> yes  (but trivial pattern-matching, 'cuz matching against a variable is trivial)
06:11:28 <p3rs3ph4n3> ok
06:16:01 * shapr boings
06:17:39 * ski shudders my ankle
06:19:59 <shapr> you shuddered your ankle?
06:20:10 <ski> "darra"
06:20:16 <shapr> idag vi lärar oss mer ord
06:20:33 <shapr> jaså
06:20:46 <shapr> shiver
06:20:47 <ski> i'm not sure "shudder" is a very good translation, though
06:20:58 <ski> yes, that is better :)
06:20:59 <prologic> wow I am so confused :)
06:21:02 <shapr> you could say "I wiggled my ankle"
06:21:15 <shapr> prologic: varför? kan du talar svenska också?
06:21:29 <shapr> unless you prefer deep south alabamian drawl
06:21:33 <ski> the word "wiggle" isn't normally in my active english vocabulary
06:21:36 <prologic> no I'm confused about part 2 of ex2 which I showed you and earthy
06:21:47 <shapr> oh something on-topic.
06:21:50 <shapr> shocking
06:22:02 <ski> lol
06:22:57 <ski> shapr : seddutom ska det vara "laer", och inte "laerar"  :)
06:23:02 <ski> he
06:23:09 <ski> s/seddutom/dessutom/  !
06:23:17 <p3rs3ph4n3> what's that language?
06:23:20 <shapr> swedish!
06:23:25 <ski> nu aer det jag som inte kan svenska :)
06:23:28 <p3rs3ph4n3> oh ok 
06:23:40 <shapr> ja, det är
06:23:57 <shapr> vad är laer?
06:24:15 <ski> learn  (or sometimes, teach)
06:24:18 <earthy> acho que eles nao falam portugues...
06:24:19 <shapr> oh
06:24:37 <p3rs3ph4n3> acho que não tb
06:24:56 <ski> "today we laerning us more words"  :)
06:24:59 <shapr> hah
06:25:37 <ski> laer is present tense  (nutid)
06:25:39 <shapr> I'm frum alabayumuh
06:25:53 <ski> heh lol
06:26:02 <p3rs3ph4n3> oh god swedish seems so difficult
06:26:14 <shapr> swedish isn't so hard
06:26:19 <ski> have you tried to learn some ?
06:26:33 * earthy has seen some here and it seems doable
06:26:36 <p3rs3ph4n3> earthy costuma dizer-se qua portugues é dificil mas olha q sueco não fica atreas
06:26:48 <p3rs3ph4n3> ski noone teach me
06:26:52 <p3rs3ph4n3> ups atrás
06:26:53 <shapr> p3rs3ph4n3: it's a lot easier if you have a gorgeous blonde blue-eyed teacher, it helps direct your attention ;-)
06:26:53 <ski> i (usually) don't think it is so hard. but then, i'm biased
06:27:11 <p3rs3ph4n3> ahahah
06:27:28 <ski> p3rs3ph4n3 : but have you tried to learn some of it ?
06:27:39 <shapr> p3rs3ph4n3: svenska är kul!
06:27:48 <p3rs3ph4n3> i prefer a green-eyed dark haired like my bf lol
06:28:02 <p3rs3ph4n3> svenska means swedish rigth?
06:28:02 <shapr> well, whatever works for you.
06:28:10 <earthy> as persephone mentions, portuguese is hard, but it looks like swedish isn't different
06:28:13 <shapr> yup, svenska is the swedish name for swedish.
06:28:13 <ski> yes
06:28:30 * earthy looks in the mirror and sees a green-eyed dark haired youg man
06:28:31 <earthy> +n
06:28:32 <p3rs3ph4n3> kul = cool ?
06:28:32 <shapr> difficile, c'est français, oui?
06:28:41 <p3rs3ph4n3> lol earthy
06:28:49 <p3rs3ph4n3> non ce n'es pas
06:28:49 <shapr> parlez vous français aussi?
06:28:52 <earthy> but I've never been to portugal, so I'm clear. ;)
06:28:53 <p3rs3ph4n3> oui
06:28:56 <ski> kul = fun
06:29:09 <shapr> c'est bien :-) le français est une bonne langue
06:29:22 <earthy> belle, aussi
06:29:22 <ski> kool = cool
06:29:41 <shapr> I can do okay in swedish and french, and my first language is American.
06:29:49 <ski> (well 'kool' is a borrowed word, jargon)
06:29:49 <earthy> amerrikun
06:29:56 <shapr> alabamian ;-)
06:29:56 <p3rs3ph4n3> je parle portugais, anglais, français un petit peu de espagnol et c'est ça :)
06:30:07 <shapr> muy bien :-)
06:30:25 <p3rs3ph4n3> verdad
06:30:31 <shapr> ik spraak un beetje nederlands
06:30:40 <earthy> mais, persephone, tu comprends espagnol, n'est-ce pas?
06:30:50 <earthy> je spreekt inderdaad niet meer dan een beetje nederlands. ;)
06:30:51 <p3rs3ph4n3> oui 
06:30:54 <shapr> dutch is great fun, I love those deep throaty Gs
06:30:55 <ski> i only know swedish,english and some german
06:31:00 <shapr> earthy: hah
06:31:13 <shapr> earthy: yeah sure, we believe you ;-)
06:31:18 <p3rs3ph4n3> oh german 
06:31:24 <earthy> allemao
06:31:27 <shapr> gutentag, wie geht es?
06:31:27 <p3rs3ph4n3> i don't speak german
06:31:31 <shapr> oh, me neither.
06:31:35 <ski> gut
06:31:35 <p3rs3ph4n3> good
06:31:36 <Malik> allemao?
06:31:37 <earthy> eigentlich recht gut. ;)
06:31:40 <shapr> allemagne?
06:31:51 <shapr> hi Malik 
06:31:52 <yazirian> allyourbase?
06:32:01 <p3rs3ph4n3> it sounds too rude i don't know
06:32:02 <Malik> hi :)
06:32:04 <shapr> yazirian: beliong2us
06:32:04 <earthy> nah, wie viele sprachen spricht man hier eigentlich, insgesamt?
06:32:14 <ski> am liebsten moechte ich schlafen.  ich will mit mein kopf arbeiten
06:32:17 <Maddas> ich bin ein berliner
06:32:18 <yazirian> OMGHI2BASE!
06:32:21 <shapr> german *really* looks like swedish to me nowadays.
06:32:25 <shapr> nuförtiden
06:32:28 <Malik> ski: hihi
06:32:32 <earthy> somebody set us up the bomb. :)
06:32:35 <Maddas> je cherche ma voiture
06:32:40 <shapr> take off every lambda!
06:32:45 <Maddas> for great justice!
06:32:47 <yazirian> for great closure!
06:32:54 <Malik> earthy: viele scheinbar
06:32:56 <shapr> for the continuation of the language!
06:32:59 <earthy> so, we've got, english, french, swedish, german, portuguese...
06:33:05 <apmuf> yeah
06:33:08 <shapr> alabamian!
06:33:10 <earthy> dutch
06:33:12 <apmuf> :)
06:33:16 <ski> yazirian : what happen ?  someone set us up the bomb !
06:33:17 <earthy> (*d'oh*)
06:33:20 <p3rs3ph4n3> alabamian? lol
06:33:28 <shapr> sure, I'm from alabama
06:33:29 <prologic> earthy, shapr: would you be able to help me understand 2.2 and 2.3 (2.3 I partly understand, but I don't understand how to compute the overal smallest dimensions when you don't even know the dimensions of the smallest compartment).
06:33:42 <yazirian> old memes never die, they just fade away... :)
06:33:45 <earthy> the dimensions of the smalles compartment are 1 by 1.
06:33:47 <p3rs3ph4n3> lol but tath's american english rigth?
06:34:00 <prologic> earthy, how do you determine that ?
06:34:07 <earthy> prologic: it is in 2.2.
06:34:11 <prologic> earthy, I've been speaking to a colleauge for over an hour about it
06:34:12 <earthy> explicitly mentioned
06:34:14 <ski> Malik : old quote from a german class book, we had to memorise it for some reason ..
06:34:21 <shapr> funny story, my woman came to visit me in Alabama, she's dual-citizen German/French, with 100% perfect english... we went to a Kentucky Fried Chicken restaraunt in Birmingham, and I had to translate between her and the cashier :-)
06:34:46 <p3rs3ph4n3> :)
06:34:46 <prologic> earthy, doesn't it say "shortest edge length of any compartment is 1 whole unit" ?
06:34:47 <Malik> ski: it doesnt really make sense :)
06:34:49 <earthy> Birmingham, aHAlabama, right.
06:34:55 <earthy> prologic: yes.
06:34:59 <shapr> earthy: yes, exactly
06:35:12 <ski> Malik : well, at least it was something like that.
06:35:15 <prologic> earthy, how is that interpreted to mean the smallest compartment's dimensions are 1x1 ? I'm so lost sorry :(
06:35:32 <Malik> ski: perhaps it is "mit meinem kopf arbeiten." but that also sounds a bit weird. :)
06:35:38 <shapr> the cashier said something like 'wush oo wah' which is ebonics for "what would you like to order?"
06:36:18 <yazirian> hahaha, like on Airplane
06:36:19 <earthy> prologic: well... there is a problem in the exercise...
06:36:25 <yazirian> "Excuse me, I speak Jive."
06:36:30 <shapr> heh!
06:36:34 <p3rs3ph4n3> Jive?
06:36:39 <shapr> I haven't seen Airplane, I must try that.
06:36:48 <yazirian> You should, it's hilarious.
06:36:50 <earthy> it doesn't explicitly state that the smallest container is square
06:36:50 <ski> Malik : i don't remember it too well
06:37:02 <shapr> earthy: I think that's implicit though
06:37:04 <prologic> earthy, so how do you assume that it is ?
06:37:24 <earthy> from the graph at the top and from the fact that it is a reasonable assumption to make
06:37:26 <prologic> this question is stupid ihmo :(
06:38:01 <earthy> no, the exercise isn't stupid, just lacking in definite information.
06:38:05 <shapr> yah
06:38:08 <prologic> yeh
06:38:09 <prologic> precisely
06:38:14 <shapr> right on brutha
06:38:24 <prologic> how would you two answer 2.2 ?
06:38:26 <shapr> get me a witness homey
06:38:36 <prologic> with a type synomn ? type Size = (Int, Int) ?
06:38:43 <shapr> sadly, I've forgotten my ebonics since I moved out of the US.
06:38:49 <earthy> I'd hand in a solution that starts with: `Assuming that the smallest compartment is square,...'
06:39:00 <shapr> prologic: yes, I agree with earthy .
06:39:04 <yazirian> shapr: sadly? ;)
06:39:10 <ski> prologic : where are the exercise ?  what book/tutorial/web info ?
06:39:16 <earthy> prologic: that would function perfectly.
06:39:19 <p3rs3ph4n3> shapr what's ebonics?
06:39:19 <prologic> yes however, on our subject's forum the profressor has said not to assume this
06:39:22 <shapr> yazirian: my ebonics renditions are very popular at parties.
06:39:23 <earthy> (for 2.2)
06:39:31 <prologic> ski: http://daisy.ods.org/~prologic/2.pdf
06:39:40 <yazirian> hahaha
06:39:52 <prologic> http://www.cit.gu.edu.au/~arock/Virgil/Virgil.cgi/ppl.03.2?forum+34+1
06:40:07 <earthy> ebonics is a mix-language of english and some other languages
06:40:15 <shapr> I do redneck, ebonics, hick, and some other deep south humor.
06:40:19 <earthy> IIRC
06:40:23 <p3rs3ph4n3> ok
06:40:31 <shapr> oh, I do plantation owner too
06:40:33 <earthy> ohhh, hick
06:40:45 <earthy> what's the difference between redneck and hick, btw?
06:41:08 <shapr> rednecks have huge beer bellies, drive jacked up trucks, and go hunting a lot.
06:41:17 <ski> is ebonics a creole ?
06:41:17 <shapr> they usually live in or near cities
06:41:27 <yazirian> they have mullets
06:41:28 <earthy> ski: yup
06:41:31 <shapr> no, creole is really something
06:41:36 <shapr> something entirely different
06:41:43 <earthy> shapr: a creole is a mix-language
06:41:45 <shapr> creole started with the acadians long ago
06:41:47 <earthy> ebonics is one as well
06:41:54 <shapr> creole is fascinating
06:42:04 <earthy> Creole is one specific mix-language. ;)P
06:42:05 <p3rs3ph4n3> creole isn't african?
06:42:06 <shapr> I've spent some time in 'Nuh Ohlans'
06:42:14 <shapr> no way, creole is a mix of french and haitian
06:42:28 <shapr> that's where vodun (voodoo) comes from
06:42:29 <Maddas> aren't Creole languages a group fo languages?
06:42:36 <Maddas> just like Pidgin languages are
06:42:49 <earthy> prologic: the forum posting is quite unhelpful
06:42:56 <prologic> yes I know :)
06:42:59 <shapr> a common last name in New Orleans is Thibodeaux, but it's spoken tibbuhduh
06:43:00 <yazirian> creole always sounds like some sort of lard-based cooking ingredient to me
06:43:04 <yazirian> the word, not the whole language
06:43:05 <prologic> but the profressor Dr. Rock says you can't assume it's 1x1
06:43:18 <earthy> you can't assume the *box* is 1x1. ;)
06:43:26 <earthy> he sais nothing about compartments.
06:43:27 <prologic> eh?
06:43:29 * prologic re-reads
06:43:29 <shapr> I can do the creole accent, but not very well
06:43:38 <prologic> No. Look at the example. Not all compartments are drawn square.
06:44:04 <prologic> hrmm
06:44:16 <prologic> so what you're saying is you could still assume the smallest compartment is 1x1
06:44:17 <shapr> anyways, hicks live way out in the country away from cities.
06:44:25 <ski> yazirian : lard ??  larder ?
06:44:29 <prologic> and other compartments around it are then worked out by the smallest one ?
06:44:38 <earthy> the problem is that the exercise does not take into account boxes that are only separated by either horizontal or vertical lines
06:44:53 <earthy> prologic: exactly.
06:44:56 <yazirian> ski: lardest! :)
06:45:06 <shapr> I should probably be classified as a hick, since my relatives all live on one mountain in northeast Alabama. The nearest town is half an hour drive away, namely Hollywood Alabama
06:45:11 * earthy thinks Dr. Rock hasn't thought the assignment through very deeply.
06:45:17 <prologic> I agree
06:45:27 <earthy> shapr: uhuh. but you're not a hick, as you live in sweden now.
06:45:34 <shapr> I'm an international hick =)
06:45:37 * shapr laughs
06:45:41 <prologic> well let me try a solution and I'll see in a few mins if you agree with it
06:45:57 <yazirian> hicks are a nonlocalized phenomenon
06:46:03 <yazirian> I'm sure sweden has its share.
06:46:15 <p3rs3ph4n3> Portugal has not lol
06:46:19 <shapr> Boden has some hicks, but not many.
06:46:22 <ski> prologic : perhaps you could ask him (again ?)
06:46:25 <yazirian> SOMEbody has to be eating all of that lutefisk.
06:46:29 <shapr> haha!
06:46:35 <shapr> lutefisk is scary
06:46:53 <prologic> ski: I have no time. I was injured and sick on the week I was suppose to do this. Now I'm doing it in my one week holiday (extension request).
06:47:01 <earthy> prologic: draw him a compartmentization with only horizontal lines and ask him how to deal with that. :)
06:47:08 <shapr> prologic: wow, you're a dedicated student.
06:47:11 <ski> yazirian : lardest ?  kidding, right ?  i wondered what 'lard' means ?
06:47:17 <shapr> lard means animal fat
06:47:28 <shapr> but turned into a white foamy substance used for cooking.
06:47:42 <shapr> it makes your arteries harden to even look at it :-)
06:47:45 <yazirian> pure fat, whipped up into something you can scoop with a spoon
06:47:47 <earthy> nah.
06:47:54 <earthy> lard is good for cooking. :)
06:47:58 <prologic> shapr, maybe so, but I don't like being confused :(
06:48:07 <shapr> prologic: you're a wise student too.
06:48:22 <prologic> why thank you :) I don't know how you deduce that
06:48:29 <shapr> because you don't like to be confused.
06:48:56 <prologic> heh
06:49:02 <ski> i don't like lutefish (except putting red cabbage on it so ot turns green/blue :)
06:49:07 <prologic> sometimes even profressors are confusing
06:49:22 <shapr> yup
06:49:24 <ski> prologic : ok
06:49:53 <p3rs3ph4n3> even the man who invented haskell sometimes should be confused about it :)
06:50:04 <shapr> he is, sometimes
06:50:06 <ski> and larder is "skafferi" (swedish), right ?
06:50:08 <earthy> there is no single man that invented haskell, right? :)
06:50:15 <prologic> I don't find Haskell that confusing :)
06:50:20 <shapr> I dunno, I think SPJ is the closest to that.
06:50:20 <prologic> just my profressors questions
06:50:28 <earthy> even if Simon PJ is somewhat the father of Haskell
06:50:30 <p3rs3ph4n3> earthy oh the men (plural) lol
06:50:42 <shapr> SPJ is an impressive guy.
06:50:46 <earthy> so I hear
06:50:52 <ski> ah, so lard is "spaeck" in swedish i think.  Spaeck !!!!  (fun to say)
06:51:48 <shapr> späck?
06:51:56 <shapr> does ae == ä?
06:52:27 * p3rs3ph4n3 5 minuts to cooking something for lunch!
06:52:37 <prologic> earthy, shapr: http://www.cit.gu.edu.au/~arock/Virgil/Virgil.cgi/ppl.03.2?forum+34+9 doesn't this message give the answer to the problem ?
06:52:38 <ski> prologic : (note on spelling : it is professor, not profressor)
06:52:44 <prologic> sorry :)
06:52:49 <prologic> it's getting late
06:53:07 <phubuh_> skafferi is a cupboard in which you store stuff like bread
06:53:09 <ski> ae is aumlaut
06:53:16 <shapr> prologic: it's only 1600
06:53:21 <ski> an a with two dots over it
06:53:29 <prologic> 2353 here
06:53:37 <ski> sometimes written "a  in ascii
06:54:07 <phubuh_> so ä, then. :-)
06:55:03 <ski> prologic : (no prob, just though you didn't know 'cuz you repeated it)
06:55:15 <prologic> my keybaord is shotty too
06:55:17 <prologic> eeek
06:55:22 * prologic screams and pulls his hair out
06:55:23 <ski> phubuh_ :  yes, that is skafferi
06:55:37 <shapr> my keyboard is nifty
06:55:47 <ski> phubuh_ : no,  a /= ae  !
06:55:48 <shapr> prologic: where are you?
06:55:51 <shapr> oh, .au
06:55:54 <shapr> I remember
06:55:54 <prologic> yep
06:55:56 * earthy guesses .au ;)
06:56:10 <earthy> euhm, yeah, that forum message does hint at the solution
06:56:11 <phubuh_> ski, ä is an a with two dots. do you see it as a?
06:56:20 <earthy> however, it also assumes that smalles boxes are 1x1
06:56:51 <ski> phubuh_ : yes, in this console-based client called just "irc"
06:56:58 <phubuh_> aha.
06:57:08 <phubuh_> that's probably ircii :-)
06:57:11 <ski> phubuh_ : perhaps xchat is better with that
06:57:15 <shapr> ski: ERC is also somewhat console based.
06:57:20 <shapr> since it runs in emacs
06:57:21 * Maddas recommends isrsi
06:57:23 <Maddas> irssi
06:57:24 <ski> phubuh_ : yes, i think it was something like that.
06:57:34 <phubuh_> -ski- VERSION ircII 2.8.2 SunOS 5.8 :ircii 2.8: almost there...
06:57:45 <shapr> SunOS 5.8 ??
06:57:57 <shapr> wow
06:58:13 <ski> phubuh_ : but it seems each time i press right mouse button in xchat, the system crashes (i.e. the login session. the computer isn't rebooting)
06:58:35 <earthy> damn.
06:58:40 <earthy> prologic: now I get it. :)
06:58:43 <prologic> earthy, with such a box represented as a tree in Haskell, it wouldn't actually be possible to know which is the smallest compartment anyway right ? Except that you could recurse down to the bottom of the tree, in this example arriving at the compartment assumed to be 1x1 .
06:58:51 <prologic> lol
06:58:52 <prologic> good good
06:58:54 <prologic> explain it to me :)
06:58:59 <shapr> yah, explain it to me too.
06:59:06 <prologic> I only half get it atm
06:59:17 <earthy> *DAMN* is this subtle
06:59:40 <earthy> http://www.cit.gu.edu.au/~arock/Virgil/Virgil.cgi/ppl.03.2?forum+50+5  tipped me off
06:59:43 <ski> shapr : is SunOS 5.8 the newest version ?
06:59:50 <earthy> ski: yes.
07:00:14 <ski> shapr : i haven't it clear the difference between Solaris and SunOS ... :(
07:00:27 <prologic> earthy, lol that message was posted by me
07:00:30 <prologic> I am James
07:00:48 <earthy> prologic: then you are *very* close to solving it. :)
07:00:49 <shapr> hi James. I'm Shae.
07:00:56 <prologic> I am ?
07:01:02 <prologic> well please re-explain it to me lol
07:01:08 <prologic> I have forgotten everything I knew
07:01:17 <prologic> trying to reunderstand my post now :(
07:01:19 <earthy> yeah. 2.2 states the smallest side of a compartment is 1.
07:01:46 <earthy> then 2.3 states: calculate the smallest possible *overall* dimensions...
07:01:48 <prologic> true
07:01:52 <prologic> 1 whole unit
07:01:58 <Igloo> Is the problem on a webpage somewhere or in scrollback?
07:02:10 <earthy> Igloo: in scrollback
07:02:11 <prologic> http://daisy.ods.org/~prologic/2.pdf
07:02:45 <prologic> so if you recurse down to the bottom of the tree you can assume that compartment is 1x1 ?
07:02:48 <earthy> prologic: for that to hold *both* sides of the smallest compartments need to be of the smallest possible length... i.e. 1.
07:02:52 <prologic> and then work your way backwards
07:03:00 <earthy> exactly.
07:03:06 <prologic> that's what I thought
07:03:12 <prologic> but my colleague disagreed
07:03:22 <earthy> oh?
07:03:26 <prologic> which means all I'd need is a function to recurse deep into the tree
07:03:32 <prologic> right ?
07:03:33 <earthy> then how does he make it smaller? :)
07:03:42 <earthy> prologic: yeah, but that was obvious from the outset. :)
07:03:46 <prologic> he's solution is totally incorrect
07:04:00 <prologic> I wish it was obvious to me :)
07:04:01 <earthy> his you mean
07:04:10 <prologic> yeh sorry
07:04:11 <prologic> his
07:04:20 <prologic> english wasn't my first language :)
07:04:28 <earthy> nor mine. :)
07:04:30 <shapr> what is your first language?
07:04:36 <shapr> American is my first language.
07:04:49 <Igloo> Oh, cute
07:04:50 <prologic> Papua New Guiniean dilect, Pidgen
07:04:58 <shapr> oh nifty
07:05:07 <earthy> one more for the tally
07:05:13 <prologic> a pseodo language created by the Germans, Japanese and various other countries to communicate with the natives
07:05:25 <prologic> I (to this day) can still speak and write it fluently
07:05:47 <prologic> type Size = (Int, Int)
07:05:49 <shapr> cool, what does it look like?
07:05:50 <prologic> dimensions :: Box -> Size
07:05:50 <prologic> dimensions JustCompartment =
07:05:53 <prologic> so would that be part the way there now ?
07:05:57 <prologic> for 2.2 and 2.3 ?
07:06:06 <earthy> prologic: yes.
07:06:06 <Igloo> Hmmm, is it just a case of working out the maximum number of h and v lines going across and down?
07:06:18 <earthy> igloo: more subtle than that
07:06:31 <prologic> and dimensions JustCompartment = (1,1)
07:06:39 <earthy> but, yeah, roughly.
07:06:44 <prologic> that very source line my colleague disagreed with
07:06:45 <earthy> prologic: yup.
07:07:10 <earthy> prologic: well... then he hasn't read the exercise carefully enough. ;)
07:07:12 * Igloo can't see why it is more subtle than that
07:07:17 <prologic> now I just need patterns to crawl through the tree :)
07:07:20 <Igloo> I don't think I understand 2.2 though
07:07:38 <prologic> earthy, true, he admits he will loose marks on it
07:07:52 <prologic> tomorrow I have fun in implementing the macro processor. Ex 3 :)
07:07:58 <earthy> igloo: 2.2. is *quite* unhelpful
07:08:18 <prologic> but that shouldn't be so hard, I have written an interpreter in pascal
07:08:22 <prologic> 2.2 is very frigg'n unhelpful!
07:08:28 <ski> but isn't there compartments in the pic in the pdf that is e.g. (2,1) in size ?
07:08:51 <prologic> as I always say to my colleagues and my gf, english is such an inefficient and informal language
07:09:00 <earthy> igloo: it is a case of working out the maximum number of h and v lines in each subtree
07:09:25 <prologic> ski, yeh but if you recurse to the bottom of the tree and assume that it's 1x1, you can work backwards and work out the dimensions of the other compartments, and the overall box dimensions
07:09:39 <Igloo> Yup, right
07:09:40 <earthy> (just going across the box with a horizontal counting verticals or with a vertical counting horizontals doesn't cut it)
07:09:48 <prologic> that right earthy ?
07:10:30 <earthy> prologic: yup. and then adding 1 to the appropriate one, depending on if it's an h or a v in the current node.
07:10:34 <prologic> in the example in the pdf, the dimensions are (logically speaking) 5x7
07:10:38 <ski> ah, ok
07:10:45 <Darius> What do you do given a box like |--| where the smallest compartments are 2 by 1?
07:11:11 <earthy> darius: you don't know that. you only know the division.
07:11:19 <prologic> that diagram lost me :)
07:11:35 <prologic> yeh you only know the way it which it has been divided, horizontally or vertically
07:11:55 <earthy> and *given* that division *and* 2.2, you can assume the smallest compartments to be 1 by 1 to calculate the smallest *possible* overall dimensions for that division
07:12:10 * p3rs3ph4n3 back with lunch someone's served?
07:12:14 <earthy> so, given that division the smallest possible woud be 1 by 2, instead of 2 by 2
07:12:28 <earthy> hm. lunch.
07:12:30 <ski> ok, i was thinking we should give lengths to all walls, but it seems we only have to give the outer dims. ..
07:12:41 <earthy> ski: exactly.
07:12:44 <prologic> it wouldn't be possible to calculate the dimensions of a box divided by a single horizontal line would it ?
07:12:52 <ski> good
07:12:55 <earthy> prologic: obviously it would. :)
07:13:00 <prologic> it would ?
07:13:04 <ski> yes
07:13:08 <earthy> yes. think about it. :)
07:13:15 <ski> 1 by 2
07:13:29 <prologic> yeh that's what I thought
07:13:31 <prologic> 1x2
07:13:58 <prologic> I outta shoot Dr. Rock :)
07:14:01 <earthy> but that is taking 2.2 into account. if you don't do that, then all bets are off.
07:14:03 <p3rs3ph4n3> lol
07:14:13 <prologic> yeh you have to assume 2.2
07:14:16 * earthy has quite some respect for Dr. Rock. the assignment is *good*. :)
07:14:19 <prologic> otherwise it's not possible
07:14:21 <prologic> lol
07:14:22 <earthy> very concise. ;)
07:14:25 <prologic> oh I have high respect for him too
07:14:28 <earthy> very puzzling. ;)
07:14:34 <prologic> but he sure knows how to confuse the hell out of me
07:14:36 <earthy> and very elegant. ;)
07:14:51 <prologic> and I'm the uni's best programmer (in my cohort, if that's how it's spelt)
07:15:05 <earthy> spelled. :)
07:15:07 <p3rs3ph4n3> don't know him but if it's a teacher it's a good man cof cof lol
07:15:19 <prologic> spelt is a word :P
07:15:40 <prologic> eek
07:15:43 <prologic> I just ate my own works
07:15:44 <earthy> yeah, but it means something else.
07:15:44 <prologic> maybe it isn't
07:15:51 <prologic> lol
07:15:58 <prologic> my apolagies
07:16:09 <ski> (apologies :)
07:16:24 <earthy> okay, I'll stop being a language-nazi. :)
07:16:31 <p3rs3ph4n3> prologic where are you from?
07:16:36 <prologic> Australia
07:16:44 <p3rs3ph4n3> ok
07:18:17 <Darius> It looks like the first clause of 2.2 should be in 2.3
07:18:27 <prologic> yes!
07:18:41 <prologic> 2.2 shouldn't even be a separate question
07:18:42 <Darius> I can't see what relevance it has to how you'd design a datastructure to hold width and height
07:18:50 <earthy> darius: I do. :)
07:19:10 <earthy> ponder   type Size = (Double,Double)   for me, will you? :)
07:19:24 <prologic> weee :)
07:19:30 <prologic> well that makes no difference
07:19:42 <prologic> but 2.2 does say "whole unit"
07:19:50 <prologic> which implies it'd have to be an Int/Integer
07:20:49 <earthy> and then ponder  1.1 + 2.2 :: Double in ghci
07:21:10 <prologic> shhhh :)
07:21:11 <Darius> earthy: It simplifies it slightly, but Double is useable, obviously, and Int would be as well, you'd merely need to scale it afterwards.
07:21:15 <prologic> confuse me after I write the function
07:21:56 <earthy> well, Double does not necessarily have exact represantations for all ints...
07:22:40 <prologic> dimensions JustCompartment = (1, 1)
07:22:41 <prologic> dimensions (HDiv Compartment Compartment) = (2, 1)
07:22:41 <prologic> dimensions (VDiv Compartment Compartment) = (1, 2)
07:22:42 <prologic> almost there :)
07:23:02 <p3rs3ph4n3> earthy i've an answer to a question that i think it's right but have no sure but i only know how to say it in portuguese can i ask you?
07:23:18 <prologic> earthy, you agree with what I've done so far ?
07:24:19 <prologic> make sense to me
07:24:23 <ski> prologic : probably you should be able to handle all Compartments, yes ?   (even ones that have a thousand HDivs,VDivs in them)
07:24:33 <prologic> I'm getting there
07:24:39 <prologic> I have 3 patterns down
07:24:53 <p3rs3ph4n3> Escreva a função mult x y z = x*y*z utilizando uma expressão-lambda. A minha resposta foi (/x y z -> x*y*z) está certo?
07:25:02 <prologic> I'm not good with visial stuff, so I have to work out the patterns on paper
07:25:04 <Darius> Also, I don't know what your current data type is, but is Compartment a data constructor of it.
07:25:05 <prologic> visual
07:25:12 <prologic> data Compartment = VDiv Compartment Compartment | HDiv Compartment Compartment | JustCompartment
07:25:13 <prologic>    deriving (Eq, Show)
07:25:13 <prologic> type Box = Compartment
07:25:13 <ski> Compartment in the 2nd and 3rd line, shouldn't it be JustCompartment  ?
07:25:22 <prologic> yeh I corrected it sorry :)
07:25:57 <ski> p3rs3ph4n3 : \x y z -> x*y*z  seems better, i think
07:26:12 <earthy> persephone: the / is in the wrong directon. ;)
07:26:21 <prologic> yeh
07:26:24 <prologic> it's \x
07:26:29 <ski> earthy : persephone ?
07:26:36 <p3rs3ph4n3> yes sorry i wrote \ in paper
07:26:50 <earthy> p3rs3ph4n3 == persephone to my eyes
07:27:07 <p3rs3ph4n3> lol
07:27:08 <ski> hadn't thought of that
07:27:19 <p3rs3ph4n3> p3rs3ph4n3 means persephone yes :)
07:27:19 <Darius> 4 usually is 'a', though.
07:27:23 <p3rs3ph4n3> from the matrix
07:27:34 <p3rs3ph4n3> 4 for me it's a o
07:27:53 <ski> i just thought it was line noise or some cryptic abbrev. or something ..
07:28:14 <prologic> (HDiv (HDiv a b) JustCompartment), such a box would have dimensions 4x1 right ?
07:28:18 <earthy> you should read some more 133+zPe4|<
07:28:43 <ski> p3rs3ph4n3 : is the exact name from matrix ?
07:28:52 <p3rs3ph4n3> no
07:28:56 <p3rs3ph4n3> it's persephone
07:28:59 <earthy> prologic: (HDiv (HDiv JustCompartment JustCompartment) JustCompartment) would be 3x1, IIRC
07:29:03 <p3rs3ph4n3> without numbers
07:29:10 <ski> l4M3r+zPe4|<
07:29:29 <prologic> earthy, but the smallest compartment fits twice into the upper one ?
07:29:51 <earthy> so? the division needn't have been in the middle...
07:30:05 <prologic> ahh yes
07:30:08 <prologic> good point :)
07:30:12 <p3rs3ph4n3> the numbers have nothing to do with lammers
07:30:15 * prologic smacks himself, don't assume things that aren't there!
07:30:28 <p3rs3ph4n3> it's just i like to put numbers instead of vogals
07:31:02 <Darius> prologic: But Hal and Gerry are always talking about using wishful thinking in program design.
07:31:11 <ski> p3rs3ph4n3 : ok :)
07:31:12 <prologic> eh?
07:31:32 <ski> heh
07:31:34 <p3rs3ph4n3> :)
07:32:12 <Darius> prologic: Harold Abelson and Gerald Sussman.
07:32:18 <prologic> I don't know them
07:32:27 <ski> SICP, right ?
07:32:35 <Darius> Yes
07:32:52 <ski> HTDP also ?
07:33:43 <prologic> hrmm earthy, I know that (HDiv (HDiv JustCompartment JustCompartment) JustCompartment) is my next Horizontal pattern to match, but I'm having troubles writing it. got an error instace of Num (Int,Int) one way I tried it.
07:34:16 <ski> prologic : you are adding results of recursive calls ?
07:34:24 <prologic> yeh
07:34:47 <ski> prologic : put the is a where (or let) and pattern-match on the pair
07:34:52 <ski> s/the/them/
07:35:13 <Darius> ski: No, not for HtDP, though I'd be surprised if they didn't talk with the authors about it.
07:35:36 <earthy> HtDP?
07:35:38 <prologic> I don't follow ski
07:35:48 <prologic> dimensions (HDiv (HDiv a b) JustCompartment) =
07:35:51 <ski> earthy : How to design programs
07:35:54 * kosmikus has ghc 6.3 with builtin arrow-syntax up and running :)
07:35:58 <Darius> www.htdp.org
07:36:13 <ski> earthy : my mind associates it with SICP for some reason
07:36:30 <Darius> ski: I consider the pre/sequel to SICP.
07:36:31 <ski> kosmikus : kool
07:36:50 <earthy> ski: hm. cool. :)
07:36:59 <earthy> kosmikus: nice. :)
07:37:22 <earthy> reminds me to finish building 6.0.1 for solaris :)
07:37:35 <kosmikus> Prelude Control.Arrow> :t proc x -> returnA -< x
07:37:35 <kosmikus> proc x -> returnA -< x :: forall a b. (Arrow a) => a b b
07:37:38 <ski> prologic : you have a def. line with recursive calls ?
07:38:08 <prologic> dimensions :: Box -> Size
07:38:09 <prologic> dimensions JustCompartment = (1, 1)
07:38:09 <prologic> dimensions (HDiv JustCompartment JustCompartment) = (2, 1)
07:38:09 <prologic> dimensions (HDiv (HDiv a b) JustCompartment) = 
07:38:09 <prologic> dimensions (VDiv JustCompartment JustCompartment) = (1, 2)
07:38:14 <prologic> is all I have atm
07:38:44 <ski> where did you get the Num (Int,Int) message ?
07:38:55 <Darius> kosmikus: You should also have parallel array syntax
07:39:06 <prologic> dimensions (HDiv (HDiv a b) JustCompartment) = dimensions a + dimensions b
07:39:08 <prologic> from that
07:39:25 <ski> Darius : array ?
07:39:33 <ski> Darius : arrow ?
07:39:54 <ski> ok
07:39:56 <Darius> ski: See "An Approach to Fast Arrays in Haskell" or something to that affect.
07:40:31 <ski> a Size is a pair of numbers, right ?
07:40:38 <prologic> yup
07:40:43 <ski> Darius : ok, thanks
07:40:49 <prologic> type Size = (Int, Int)
07:41:02 <ski> you are trying to add them in that line
07:41:36 <ski> Darius : 'tis Nepal related ?
07:42:40 <ski> you can't add pairs  (unless you define somewhere how to do it. but that's probably not what you want to do)
07:42:48 <prologic> yeh
07:42:58 <prologic> but I can add values inside pairs ?
07:42:59 <Darius> ski: Yes
07:43:04 <prologic> which is probably what I want right ?
07:43:26 <ski> so the pair to be returned by this line should probably depend on the pairs returned by those recursive calls
07:43:45 <ski> add inside pairs ??
07:43:52 <prologic> hrmm
07:43:54 <ski> what you mean ?
07:44:50 <prologic> well you said to use let
07:45:08 <ski> or where.  you have met where, haven't you ?
07:45:16 <prologic> yeh
07:45:31 <prologic> either can be used :)
07:45:41 <ski> right
07:46:12 <prologic> could you see http://daisy.ods.org/~prologic/ex2.hs please
07:46:25 <ski> so perhaps you have only used where to define local constants  (and small functions, perhaps) ?
07:46:40 <ski> 'kay
07:46:54 <ski> Forbidden   You don't have permission to access /~prologic/ex2.hs on this server.
07:47:11 <prologic> piece of shit :)
07:47:11 <prologic> lol
07:47:13 <prologic> sorry try again
07:47:30 <kosmikus> Darius: yes, I do
07:47:35 <earthy> prologic: there's another cool little screwy thing in the assignment
07:47:42 <ski> ok
07:47:43 <prologic> oh no :)
07:47:44 <prologic> what's that ?
07:48:16 <earthy> the graph can be drawn in multiple ways
07:48:31 <ski> what graph ?
07:48:31 <prologic> how's that make a difference ?
07:48:38 <prologic> he means the box I think
07:49:17 <ski> earthy : if you mean what i think, then it doesn't matter for the overall dimensions of the box
07:49:54 <earthy> ski: well, look at the top left of the box
07:50:16 <ski> earthy : 'kay
07:50:23 <earthy> I'm not sure if the different ways of drawing it don't lead to different results
07:50:35 <ski> earthy : ah, you mean that 
07:51:35 <ski> earthy : but i interpreted it such that the input is (something isomorphic to) the datastructure, and that the pic was just a lossy representation of it
07:51:47 <prologic> wow this recursion is losing me since you can't add tuples
07:52:01 <prologic> the pic is a lossy representation :)
07:52:10 <ski> :)
07:53:07 <ski> prologic : you are redefining a and b in the let-clause. you probably don't want that
07:53:50 <prologic> dimensions (HDiv (HDiv a b) JustCompartment) = should return (3,1)
07:53:57 <prologic> can't quite get there though
07:54:17 <ski> each recursive call gives us a Size, i.e. a pair of numbers,  how do we extract the numbers out from the pair ?
07:54:26 <p3rs3ph4n3> earthy you said there wasn't a man that made haskell
07:54:30 <prologic> (a,b)
07:54:31 <p3rs3ph4n3> but i found in the net
07:54:41 <prologic> ahh
07:54:43 <p3rs3ph4n3> Haskell Curry
07:54:46 <prologic> pattern match again a tuple :) ?
07:54:53 <ski> try it :)
07:54:56 <prologic> lol
07:55:03 <prologic> ok that changes the approach
07:55:12 <earthy> ski: true.
07:55:39 <earthy> persephone: Haskell B. Curry is the namesake for Haskell
07:55:59 <earthy> he's a big lambda-calculus figure (or rather was, IIRC he's dead)
07:56:08 <p3rs3ph4n3> ok
07:57:08 <ski> prologic : hmm, what's your height supposed to return ?
07:57:26 <ski> He invented Combinatory logic (S,K,I) IIRC
07:57:28 <p3rs3ph4n3> how can anyone writte sections as lambda expressions?
07:57:37 <p3rs3ph4n3> can someone give me an example please
07:57:53 <prologic> ski: pardon ?
07:58:00 <earthy> ski: and the typed lambdacalculus.
07:58:23 <Darius> and is credited for Schoenfinkeling
07:58:34 <ski> p3rs3ph4n3 :  (+ 5)  ===  (\x -> x + 5)   (8 *)  ===  (\x -> 8 * x)
07:58:39 <earthy> ski: and the lambdacalculus itself, IIRC. and conjectured the Curry-Howard isomorphism
07:59:03 <ski> prologic : just commented on Haskell B. Curry
07:59:17 <prologic> no about the height
07:59:20 <p3rs3ph4n3> for example (++) === (\x -> x ++) ?
07:59:20 <ski> prologic : or did you mean about height ?
07:59:20 <phubuh_> i thought alonzo church was considered the inventor of lambda calculus
07:59:38 <ski> p3rs3ph4n3 : no (++) === (\x y -> x ++ y)
08:00:21 <p3rs3ph4n3> ski why are 3 signs of = between them there's any special signification?
08:00:29 <ski> earthy : wasn't it Alonzo Church who invented lambda-calculus ?
08:01:10 <ski> p3rs3ph4n3 : "meta-equality"  :)
08:01:23 <p3rs3ph4n3> ok :)
08:01:54 <earthy> could be...
08:02:04 <earthy> I'm hazy on that. :)
08:02:16 <earthy> he was big, anyway. ;)
08:02:47 <ski> prologic : i was particulary wondering about the "... - 1" in the last line
08:03:00 <prologic> oh no
08:03:03 <prologic> ignore that ski :)
08:03:10 <prologic> that's the solution to tute9 from last week
08:03:14 <prologic> using it as a rough guide
08:04:44 <ski> it seemed like unusual to call it height
08:05:02 <prologic> the hight function was for a binary tree
08:05:20 <ski> but why is it called height
08:05:22 <ski> ?
08:05:29 <arguile> Turing was a student of Church's wasn't he?
08:05:37 <prologic> to calculate the height of a binary tree
08:05:54 <ski> when it doesn't return what i think a height-function should (even modulo 0- or 1- based counting)
08:06:05 <phubuh_> would it be theoretically possible to design a (not necessarily terminating) function to determine if two algorithms are semantically equivalent?
08:06:11 <prologic> http://daisy.ods.org/~prologic/09.pdf
08:06:14 <p3rs3ph4n3> when i thought about the machine of Turing i become sick
08:06:31 <prologic> that's tutorial 9
08:06:41 <prologic> of which height function is the first question's solution
08:07:02 <Igloo> phubuh_: Yes, just check they have the same output for all possible inputs
08:07:08 <prologic> I wasn't at the tute so I'm not sure myself
08:07:13 <prologic> ;)
08:07:53 <phubuh_> Igloo, but then the inputs have to be countable :-)
08:08:06 <phubuh_> actually, i was looking for a not so brute forcy function
08:08:14 <Igloo> No they don't
08:08:22 <Igloo> In fact, a program that just diverges satisfies your spec
08:09:21 <Darius> phubuh_:  You are just asking for something that can prove -some- functions are equal.  That's easy to write, and Igloo's remark is one possible implementation.
08:10:01 <ski> prologic : your function would generate a run-time error on the tree in the pic, i think  :(
08:10:33 <p3rs3ph4n3> there's any good tutorial that explains how to convert sections like (++[1,2]) and ([1,2]++
08:10:45 <p3rs3ph4n3> there's any good tutorial that explains how to convert sections like (++[1,2]) and ([1,2]++) in lambda expressions?
08:10:56 <prologic> the height function in ex2.hs has nothing to do with what I'm doing. it's the solution from tutorial 9 from last week which I didn't attend, so I don't even know if it's correct. It's suppose to calculate the height of a binary tree.
08:10:57 <p3rs3ph4n3> cause i'm not understanding
08:11:41 <prologic> Main> dimensions (HDiv (HDiv JustCompartment JustCompartment) JustCompartment)
08:11:42 <prologic> (3,1)
08:11:42 <prologic> Main> dimensions (VDiv (VDiv JustCompartment JustCompartment) JustCompartment)
08:11:42 <prologic> (1,3)
08:11:44 <prologic> part way there :)
08:12:06 <Darius> p3rs3ph4n3: No, the tutorial would be: (* a) == \x -> x * a and (a *) == \x -> a * x forall a and operators *.  With the note, watch out for -.
08:12:08 <ski> prologic : ok.  (just that, to me, it seems incorrect. but that's not so important relative to the dimensions problem ..)
08:12:17 <prologic> ski, no it isn't :)
08:12:18 <prologic> thank god
08:12:19 <prologic> hehe
08:12:30 <prologic> ski, could you look at http://daisy.ods.org/~prologic/ex2.hs again
08:12:49 <Darius> p3rs3ph4n3:  There are no doubt tutorials on Haskell in general that cover it though.
08:12:56 <ski> sure
08:13:00 <prologic> ta
08:13:06 <ski> ok, now you've updated
08:13:06 <p3rs3ph4n3> so can you explain me that?
08:13:13 <prologic> think the last pattern I need now is the overall recursive one right ?
08:13:34 <ski> ?
08:13:49 <prologic> or will what I've got cover any box ? :)
08:13:57 <prologic> I'm even loosing myself hehe
08:13:59 <ski> don't you already have overall recursive cases ?
08:14:14 <earthy> wow. that dimensions thing is huge. ;)
08:14:17 <ski> no, because it's not finished yet
08:14:21 <prologic> no not yet
08:14:29 <prologic> I don't think so anyway :)
08:14:37 <prologic> I've only covered 4 patterns
08:14:41 <prologic> which are base cases really
08:14:50 <earthy> dimensions (HDiv JustCompartment JustCompartment) = (2, 1)
08:14:53 <earthy> is not a base case
08:14:58 <prologic> ehh
08:15:00 <prologic> 5 patterns
08:15:04 <prologic> yeh sorry you're right
08:15:05 <Darius> p3rs3ph4n3: There's nothing to explain.  That's the translation.
08:15:09 <ski> but the pattern "HDiv a b" matches any HDiv tree, similary with VDiv
08:15:12 <prologic> JustCompartment is the base case
08:15:13 <arguile> prologic: Why would they bother to use (Fork a b) (Fork b c)?
08:15:26 <earthy> it follows from    dimensions JustCompartment = (1,1)       and   dimensions (HDiv a b)
08:15:28 <prologic> arguile, your guess is as good as mine
08:15:29 <p3rs3ph4n3> so ([1,2]++) === (\x y -> [1] ++ [2]) ?
08:15:39 <ski> so if you put a line below that last one, i won't get reached, ever
08:15:47 <earthy> persephone: no.
08:15:48 <arguile> prologic: Fork (Tree) (Tree), etc. would be faster/make more sense :)
08:15:52 <ski> yes, that's a base case
08:15:58 <p3rs3ph4n3> :(
08:16:11 <p3rs3ph4n3> i hate lambda sections
08:16:21 <Darius> p3rs3ph4n3: No, a == [1,2] and * == ++, (a *) ==> \x -> a * x, so that is \x -> [1,2] ++ x
08:16:23 <prologic> ski: you saying if I put another pattern in, it won't ever get matched ?
08:16:25 <p3rs3ph4n3> don't understand nothing of it :(
08:16:27 <ski> as you have written, HDiv JustCompartment JustCompartment , is a base case also  ('cuz it doesn't call dimensions recursively, right ?)
08:16:40 <prologic> that's right
08:16:44 <ski> prologic : yes
08:16:50 <prologic> because that can be worked out on paper easily
08:16:55 <prologic> just a box with a single division
08:16:58 <ski> prologic : (except if you add constructors to the datatype, i.e.)
08:17:00 <earthy> however, the dimensions thing seems correct to my eyes
08:17:03 <Darius> p3rs3ph4n3: Do you understand lambda expressions?
08:17:17 <earthy> even if it contains some superfluous code
08:17:19 <prologic> I'll test it for an arbitary box :)
08:17:29 <earthy> I tested it for the example. :)
08:17:34 <prologic> shit you did ?
08:17:40 <earthy> (H (V (H (V (H (V C (V C C)) C) (V (H C C ) C)) C) (H C (V C C))) (V (H C C) C))
08:17:42 <ski> you have to have an induction/recursion hypothesis
08:17:45 <prologic> rofl
08:17:46 <p3rs3ph4n3> Darius more or less
08:17:55 <prologic> I couldn't write the expression
08:18:12 <prologic> did you create type synonmns for the constructors ?
08:18:22 <ski> like, "we know how to compute the dimensions of the two SubCompartments"
08:18:24 <earthy> well, timtowtdi.
08:18:29 <earthy> prologic: nope, just shortened them. :)
08:18:33 <prologic> heh
08:18:34 <prologic> ok
08:18:54 <earthy> but, fun as this is, I should be going.
08:19:58 <prologic> your example returns (2,1)
08:20:03 <p3rs3ph4n3> Darius so (++[1,2]) === (\x -> ++ [1,2] x)
08:20:10 <earthy> prologic it does?
08:20:11 <ski> bad it seems ?
08:20:17 <prologic> Main> dimensions (H (V (H (V (H (V C (V C C)) C) (V (H C C ) C)) C) (H C (V C C))) (V (H C C) C))
08:20:17 <prologic> (2,1)
08:21:01 <Darius> p3rs3ph4n3: No.  That's (* a) which (from above) translates to \x -> x * a, with a == [1,2] and * == ++ we get, \x -> x ++ [1,2]
08:21:10 <prologic> something wrong with my function ?
08:21:26 <ski> it seems you think that, in "dimensions (HDiv a b) ...", a and b have 1 (or 0 ?) in height ?
08:21:37 <earthy> yes, there is a bug in your function. ;)
08:21:43 <earthy> subtle, but present.
08:21:48 <prologic> hehe
08:21:52 <ski> s/height/width/
08:21:52 <earthy>    in (1, w + w')
08:21:54 <p3rs3ph4n3> but Darius how do i know when is x * a or a * x
08:22:06 <prologic> ahh yeah
08:22:09 <earthy> do you *really* think that you should keep one dimension at 1? :)
08:22:11 <prologic> I dunno why I wrote it like that
08:22:15 <prologic> no :)
08:22:28 <prologic> I'm not sure which one it should take though
08:22:38 <earthy> well, isn't that obvious?
08:22:50 <earthy> the bigger one!
08:22:52 <Darius> p3rs3ph4n3: It depends on wether the operater is to the left or right of the expression.  (/3) is divide by 3, (3/) is 3 divided by something.
08:22:59 <prologic> lol
08:23:03 <prologic> I'm an idiot :)
08:23:19 <ski> you got it ?  :)
08:23:32 <prologic> Main> dimensions (H (V (H (V (H (V C (V C C)) C) (V (H C C ) C)) C) (H C (V C C))) (V (H C C) C))
08:23:32 <prologic> (5,7)
08:23:34 <prologic> yay :)
08:23:35 <prologic> bloody finally
08:23:36 <p3rs3ph4n3> but that is only x*a and a*x or there's more ?
08:23:38 <prologic> it works for the example
08:23:57 <prologic> in (h + h', max w w')
08:24:04 <prologic> in (max h h', w + w')
08:24:08 <earthy> bingo
08:24:12 <prologic> :)
08:24:15 <prologic> bingo alright
08:24:21 <prologic> I have reached enlightenment :P
08:24:22 <prologic> haha
08:24:24 <ski> :)
08:24:39 <prologic> now I know why you love the question earthy :)
08:25:08 <earthy> it's good, isn't it? :)
08:25:14 <Darius> p3rs3ph4n3: The * in the above stands for -any- operator. +,/,*,++,=^.-=,`div`, anything that can be used infix.
08:25:14 <prologic> yeh
08:25:21 <ski> now you ask yourself : is some of the base-cases perhaps already covered by other (more general) cases correctly
08:25:25 <prologic> it's not bad when you dig deep to understand the question
08:25:34 <prologic> ski: probably :)
08:25:40 <earthy> yeah, you want to go clean up. :)
08:25:48 <p3rs3ph4n3> ok understood thank you Darius
08:25:50 <p3rs3ph4n3> :)
08:25:57 <prologic> dimensions (H C C) = (2, 1) that's already covered
08:25:59 <prologic> as is the other way
08:26:02 <prologic> since it's recursive :)
08:26:04 <ski> yes
08:26:16 <prologic> think it just helped me at first :)
08:26:36 <arguile> prologic: Is the question itself online?
08:26:42 <prologic> yes of course
08:26:47 <prologic> http://daisy.ods.org/~prologic/2.pdf
08:26:48 <ski> to have some small concrete examples to look at ?
08:27:11 <ski> (small, but not trivial, i.e.)
08:27:14 <Darius> p3rs3ph4n3: There is one exception.  (- n) doesn't work because Haskell thinks that's just negation.  (n -) does though.
08:27:37 <prologic> ski: I'll have to draw up some examples :)
08:27:45 <ski> of course
08:27:49 <Smerdyakov> SML wins, for using ~ for negation!
08:28:01 <ski> :)
08:28:12 <p3rs3ph4n3> Darius so if someone gives me an exercice with -n i say it's unsolvable rigth?
08:28:26 <prologic> I've never very good at building complex data structures though :)
08:28:30 <prologic> I loose myself in it
08:28:36 <Darius> Smerdyakov: ~ is taken in Haskell.
08:28:50 <Darius> Though arguably it could be used for both.
08:29:01 <earthy> smerdyakov: I *hate* that. :)
08:29:20 * Darius is with earthy.
08:29:38 <Smerdyakov> earthy, why?
08:29:50 <earthy> it is jarring to my eyes
08:30:09 <Smerdyakov> You'd get used to it the same way you get used to * for multiplication. :)
08:30:12 <earthy> it just doesn't jive right, to have the sign for `about' be misappropriated to designate `minus'
08:30:26 <earthy> owh, I'm used to it all right...
08:30:37 <ski> prologic : i think you can remove unnecessary cases in height also, ...
08:30:38 <earthy> doing some HOL hacking... I have to...
08:30:56 <arguile> p3rs3ph4n3: in the case of - n you can use flip (-) n
08:31:25 <p3rs3ph4n3> arguile what makes the function flip?
08:31:54 <arguile> p3rs3ph4n3: look it up in the standard prelude (or lambdabot)
08:32:03 <prologic> ski: I already have
08:32:04 <ski> @prelude flip
08:32:06 <lambdabot> *** "flip" prelude "Haskell Standard Prelude Dictionary": text follows
08:32:06 <lambdabot> flip
08:32:06 <lambdabot>   flip ::  (a -> b -> c) -> b -> a -> c
08:32:06 <lambdabot>   flip f x y      = f y x
08:32:08 <Darius> arguile: subtract was specifically added to handle this.  Also you can always do ((-n)+) assuming + and negation have the normal relationships to -.
08:32:58 <p3rs3ph4n3> ok
08:34:00 <ski> prologic : you moved it outta my sight ?  ;)
08:34:11 <prologic> eh?
08:34:22 <ski> prologic : so i couldn't complain ?  ;)
08:34:31 <ski> height
08:34:40 <prologic> it wasn't necessary to be there anymore
08:34:46 <ski> well, sure.
08:34:50 <prologic> I was only using it as a rought guide to dimensions
08:34:53 <arguile> Darius: And here I always though subtract was just there to please the LISPers ;)
08:36:22 <p3rs3ph4n3> well i have to go now thank you very much all for explain me some doubts and for having much patience :)
08:36:39 <p3rs3ph4n3> ciao ******************************************************
08:36:49 <ski> bye
08:37:41 <ski> arguile : see http://www-gap.dcs.st-and.ac.uk/~history/Mathematicians/Church.html
08:37:49 <arguile> Or was it the old LISP that used all names instead of symbols... I know Scheme was (- x y). Bah, it's been too long.
08:37:57 <ski> arguile : doctorial student, it says
08:38:08 <ski> s/doctorial/doctoral/
08:38:18 <arguile> Yeah I looked it up in FOLDOC and got that reference :)
08:38:34 <Lor> Anyone have suggestions for a proof assistant or theorem prover to use with classical mathematics?
08:39:05 <earthy> mizar
08:39:17 <earthy> or isabelle with proof general
08:39:27 <earthy> but I'd go with mizar, as it has more libraries.
08:39:36 <Lor> I hear mizar doesn't have very much automation.
08:39:42 <earthy> so? :)
08:40:08 <earthy> if you want automation to isabelle with isar mode and proof general
08:40:11 <earthy> s/to/do
08:40:14 <Lor> ...so I expect things to be even more horribly tedious.
08:40:39 <earthy> hell.. that's what prooftools are for :)
08:40:44 <earthy> anyway, time to bail
08:40:49 <earthy> see you all later
08:41:06 <Smerdyakov> Lor, http://gtps.math.cmu.edu/tps.html is something I've used before.
08:41:29 <ski> earthy : bye
08:42:00 <Lor> I like the type system of Coq, but it's not very mathematically oriented, and it's not very pretty as a language.
08:42:16 <Smerdyakov> Why not mathematically oriented?
08:42:16 <vegai> but?
08:42:53 <Lor> Well, there's nothing resembling ZFC in the standard libraries.
08:43:17 <Lor> So it's all very constructive. Natural numbers are an inductive datatype, etc.
08:43:55 <ski> has coinductive datatypes been used in any proof tool ?
08:44:11 <Lor> And in general that's all right with me, but it's not _math_ as it's usually understood.
08:49:49 <Smerdyakov> Aren't naturally numbers always an inductive datatype in formalizations of math?
08:50:04 <Smerdyakov> Church numerals would be even farther than usual.
08:50:11 <Smerdyakov> I guess they're sets on some crazy planets.
08:50:50 <Lor> To my understanding, the existence of natural numbers is directly postulated by the axiom of infinity.
08:51:13 <Smerdyakov> Lame and counterintuitive :P
08:52:03 <Lor> In math, there are no "types", there are only sets.
08:52:14 <Smerdyakov> Not in math formalized with type theory.
08:52:29 <Lor> Well yeah, but the usual formalization is based on ZFC.
08:52:33 <Smerdyakov> There's no a priori reason to start with the weaker set theory instead of category theory.
08:52:47 <Lor> And then you can say weird things like 3 \in 4.
08:53:28 <ski> \in ?  set difference ?
08:53:41 <ski> member of ?
08:53:46 <Lor> Yeah, member.
08:53:52 <Darius> member of
08:55:10 <Smerdyakov> I'm familiar on a basic level with the set theoretical formalization of math, but I think it's silly to call that "math" instead of a particular formalization of math.
08:55:13 <ski> x < y |= x \in y
08:55:22 <ibid> math is not formalized
08:55:34 <Lor> Since it's really {{},{{}},{{},{{}}}} \in {{},{{}},{{},{{}}},{{},{{}},{{},{{}}}}}
08:55:40 <Smerdyakov> I prefer a type theoretical formalization myself.
08:55:56 <Lor> Who wouldn't?
08:56:15 * esap prefers type-theoretical interpretation. Then math can be considered as just a type system.
08:56:25 <Smerdyakov> The people who formalize math with set theory?
08:56:35 <prologic> http://daisy.ods.org/~prologic/Example1.png
08:57:20 * Smerdyakov goes to class.
08:58:17 <ski> prologic : you made that pic ?
08:58:20 <prologic> yer
08:58:25 <prologic> is it correct though ?
08:58:31 <prologic> (4,3)
08:58:43 <prologic> the joys of using dia :)
08:59:41 <ski> hmm
09:00:51 <ibid> types frequently get in the way when doing maths
09:00:55 <ibid> (in a typed theory)
09:00:59 <ski> ok, you put the upper part in the second arg to top H
09:01:18 <prologic> yep I did
09:01:48 <ski> (i was thinking about it, the other way around)
09:02:03 <prologic> I have a limited mindset :)
09:02:20 <ski> it seems correct, i think
09:02:20 <ibid> there's a paper called something like "should your specification language be typed", which is very critical of typed speclangs
09:02:20 <prologic> I tried to write it as I divided it
09:04:16 <ski> dia ?
09:04:48 <prologic> diagram tool for linux
09:05:23 <ski> ok
09:05:26 <prologic> http://www.lysator.liu.se/~alla/dia/
09:08:34 <prologic> http://daisy.ods.org/~prologic/Example2.png
09:08:53 <prologic> I've finished testing it :) pretty satisfied now
09:11:08 <ski> fine
09:12:19 <prologic> thank you ski and earthy for your help :)
09:12:38 <ski> no prob
09:12:46 <ski> just fun
09:12:50 <ski> :)
09:12:59 <prologic> yeh it was :)
09:18:04 <prologic> Haskell does a lot of binding in compile time doesn't it ?
09:18:11 <prologic> early binding
09:18:44 <Darius> what?
09:19:04 <Lor> prologic, everything, really.
09:19:12 <prologic> yeh that's what I thought
09:19:22 <prologic> there isn't much run-time in haskell at all really
09:19:32 <ski> prologic : what do you mean by early binding ?
09:19:42 <prologic> just Ex1 is all about binding times
09:19:45 <Lor> prologic, you can get something with existential types. And with implicit parameters.
09:19:50 <prologic> just want to clear my understanding
09:20:13 <Lor> And in a way the usual implementation of type classes also involves run-time dispatching.
09:20:28 <prologic> k
09:20:34 <Lor> But usually, if you want something done at runtime, you explicitly show it in the code.
09:20:39 <prologic> but most of haskell works by static binding
09:20:45 <prologic> right
09:21:33 <prologic> ie: the number of significant digits in a real number is bound at implmentation time ?
09:24:38 <ski> um
09:24:48 <Lor> prologic, uh, say what?
09:25:07 <Lor> You mean the distinction between a Float and a Double?
09:25:27 <prologic> well yeah
09:25:32 <Lor> Actually, float literals are overloaded.
09:25:51 <prologic> in the implmentation ?
09:26:07 <ski> in the language
09:26:22 <Lor> No, I mean that "0.5" in the program source can mean either a Float or a Double or a Rational or whatever type that implements the Fractional class.
09:26:27 <ski> try taking the type of, say 1.23
09:26:41 <ski> :t 1.23
09:26:49 <ski> @type 1.23
09:26:49 <lambdabot> 1.23 :: Fractional a => a
09:26:55 <Darius> @type 1.23
09:26:56 <lambdabot> 1.23 :: Fractional a => a
09:27:04 <ski> :)
09:27:32 <prologic> yeh it's a Fractional
09:28:04 <prologic> see the question says, "Give as precise binding times as you can for the following attributes: The maximum number of significant digits in a real number"
09:29:29 <Lor> And this exercise is specific to haskell?
09:30:05 <prologic> yes
09:30:05 <Lor> (There are no "real numbers" in most programming languages, btw.)
09:30:15 <prologic> but I have to do this for Fortran, C and java as well
09:30:18 <prologic> for other attributes
09:30:40 <prologic> this is straight out of the textbook, which I haven't been able to afford. had to photocopy the page
09:31:15 <Lor> There is no simple answer.
09:31:48 <Lor> The "binding" can be done either at compile time or at runtime.
09:32:03 <ski> or link-time
09:32:41 <Lor> There is no concept of "linking" in vanilla Haskell, to my knowledge.
09:32:45 <Lor> It's just an implementation detail.
09:32:47 <ecraven> macro-expand-time too...
09:33:25 <ski> runtime, with existensials and pol.rec. ?
09:34:05 <Lor> Yeah, polymorphic recursion forces the dictionaries to be passed at runtime.
09:34:33 * esap would like to have first-class dictionaries.
09:34:44 <Lor> And the actual Fractional dictionary used really determines the precision of the number that the decimal source expression denotes.
09:34:54 <Lor> esap, who wouldn't?
09:35:10 <Lor> Implicit parameters + records with existential types ought to be pretty close.
09:35:12 <Darius> esap: Of sorts, that's what implicit parameters do/ar.
09:35:15 <ski> and output dictionaries, like in mercury ...
09:35:43 <Lor> First-class modules...
09:35:50 <Darius> There is also an article on named instances.
09:35:59 <ski> but then we'd probably need that exists keyword
09:38:59 <esap> Hmm.. don't first-class modules usually support downcast?
09:39:12 <ski> dunno
09:40:02 <Lor> Downcast?
09:40:48 <esap> determining at run-time whether your module supports some specific interface.
09:40:55 <prologic> Lor, back to what you were saying, how can it be either compile time or runtime ?
09:41:09 <esap> like C++ dynamic_cast.
09:41:38 <Lor> prologic: if you have f :: Float; f = 0.3, then you know the precision of f at compile-time.
09:41:52 <prologic> yup
09:41:56 <prologic> and run-time ?
09:42:03 <Lor> But if you have f :: Fractional a => a; f = 0.3, then the precision can be whatever instance of a is used.
09:42:23 <prologic> gotcha :)
09:42:29 <Lor> And in some situations the actual type a _cannot_ be decided until runtime.
09:42:43 <ski> so you can use f with type Double, somewhere, and with type Float, somwhere else
09:43:21 <Lor> And somewhere else with Rational, which is _precise_.
09:43:30 <Lor> The problem is that none of these are "real numbers".
09:43:40 <Lor> So the question was not very well formulated.
09:44:17 <prologic> I know the question isn't well formulated
09:44:21 <prologic> but I have to do it anyway :(
09:44:54 <prologic> what about "The meaning of Char" ?
09:45:08 <prologic> I did say this was Compile time, since it's a definable module in module Char.
09:46:09 <prologic> and if you have c :: Char; c = 'a', you know what it is at compile time
09:46:23 <prologic> you even know c = 'a', that c has to be of type Char
09:46:48 <prologic> so it'd have to be bound at compile time ?
09:48:07 <Lor> Essentially, yes. Even though that's not a really good way to express it.
09:48:51 <prologic> I'm not going to be too pedantic on this question
09:49:04 <prologic> what about the location of functions and local variables ? runtime ?
09:49:39 <Lor> "Location"?
09:49:39 <ski> location ?  machine address ?
09:49:54 <prologic> I assume it means machine address
09:49:55 <prologic> yeh
09:49:59 <prologic> it's vauge
09:50:38 <Lor> Variables don't have an "address".
09:50:48 <prologic> but the most languages calculate the addresses of functions and variables at compile time relative to some offset
09:50:54 <prologic> but it could be anywhere in memory at runtime
09:50:57 <Lor> (This is in contrast to C, where a non-register variable does have a location)
09:51:07 <ski> location of (thunk) closure or of mach.lang. snippet ?
09:51:11 <prologic> variables have an address :)
09:51:39 <prologic> or are you refering to variables in Haskell ?
09:51:42 <Lor> Only in C and some related languages.
09:51:46 <prologic> yeh
09:51:49 * esap actually tried to implement a useful concept of location in Haskell. It's not a simple thing.
09:51:52 <prologic> there are no variables in Haskell
09:52:06 <ski> yes, there are
09:52:12 <prologic> only functions :)
09:52:23 <prologic> f :: Int; f = 1
09:52:23 <Lor> There are no _mutable_ variables, but that's a different issue.
09:52:28 <prologic> yeh
09:52:30 <esap> There are variables and references to variables. Locations are quite a bit like those references.
09:52:30 <Lor> f is a variable.
09:52:45 <ski> there are no updateable boxes (not counting XRef's, etc in monads)
09:53:03 * esap is counting IORef.
09:53:14 <Lor> (Btw, the name "variable" is quite ok even for non-mutable ones, since the idea is that "x" can vary, ie. assume multiple different values)
09:53:33 <prologic> that's generally what variable means
09:53:39 <prologic> which really doesn't apply to Haskell
09:53:44 <prologic> only C, Java, and Fortran
09:53:53 <ski> esap : depends whether you think about implementation or semantics)
09:53:55 <Lor> Depends on which world you come from.
09:54:15 <prologic> imperitive :)
09:54:19 <esap> ski: Well I only think about semantics.
09:54:21 <Lor> prologic, in math and logic there's much talk about variables, yet none of them are mutabel.
09:54:24 <Lor> mutable.
09:54:32 <prologic> yeh
09:54:35 <ski> compare with variables in math
09:54:44 <prologic> that's why I like Haskell :)
09:54:49 <prologic> it's very formal
09:57:24 <ski> esap : then why are you counting IORef ?
09:58:17 <esap> ski: because they have very well defined semantics, which is close to what you'd expect from an identifier referring to some location.
09:58:57 <esap> ski: in particular, you can dereference them (to obtain the value stored in the location).
09:59:13 <esap> ski: and you can store another value to the location referred to by IORef.
09:59:51 <prologic> is the lamdabot only a reference tool, or can it do some haskell ?
10:00:01 <ski> esap : in the monad, yes. but that possibly in denot.sem. just gets interpreted as passing around TheWorld ..
10:00:33 <ski> @eval reverse ([1,2] ++ [3,4])
10:00:33 <lambdabot> [4, 3, 2, 1]
10:00:49 <prologic> wow
10:00:51 <Darius> prologic: There's a lambda calculus interpreter.  If you want to get it closer to Haskell go ahead and hack it.
10:01:12 <prologic> so it'll only evalulate labda expressions ?
10:01:19 <prologic> lamda
10:01:32 <Darius> As the example above shows, obviously not.
10:01:44 <ski> extended with some other types, syntices and functions, i presume
10:01:53 <ski> (syntaxes ? syntices ?)
10:02:12 <Darius> ski: I think the former is more used.
10:02:50 <ski> Darius : but what is correct ?  (syntax is latin, innit ?)
10:02:58 <esap> ski: I'm not choosing any particular choice of model of semantics. It shouldn't matter, really. You're only interested in the _behaviour_, not in the particular way that this semantics is represented in your model.
10:03:31 <Darius> ski: Heck if I know which one is correct. 
10:03:48 <ski> esap : i was thinking like : can be reduced (not too unelegantly) to ...
10:04:46 <ski> index -> indices  vertex -> vertices  redex -> redices ?  :)
10:05:55 <esap> The simple way to understand english spelling is to ask google. The one that gets most hits must be the correct one.,
10:06:08 <ludde> ski: both are correct
10:06:25 <ludde> Index \In"dex\, n.; pl. E. {Indexes}, L. {Indices}(?). [L.: cf.
10:06:25 <ludde>      F. index. See {Indicate}, {Diction}.]
10:06:45 <ludde> actually Indexes is the correct one
10:06:48 <ludde> Indices is latin
10:06:51 <ludde> Indexes is english
10:06:56 <ski> ludde : saeker ?  kom just pao att syntax slutar pao ax istaellet foer ex ..
10:07:01 <prologic> @eval [x*x | x <- [1..10]]
10:07:01 <lambdabot> (line 1, column 6):
10:07:01 <lambdabot> unexpected "|"
10:07:01 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string, "(", operator, "*", "/", simple term, "," or "]"
10:07:15 <prologic> hrmm :)
10:07:24 <prologic> of course :) idiot
10:07:41 <ludde> ski: vet inte om syntax
10:07:57 <prologic> hold on, why didn't that work ?
10:08:01 <prologic> does i hugs
10:08:14 <ski> prologic : not sure if lambdabot understands list comprehension right now ..
10:08:23 <ludde> who wrote lambdabot?
10:08:31 <ski> @type [x*x ; x <- [1..10]]
10:08:44 <ski> @type [x*x | x <- [1..10]]
10:08:44 <lambdabot> [ x * x | x<-enumFromTo 1 10 ] :: (Enum a, Num a) => [a]
10:08:54 <ski> hmm
10:09:06 <prologic> @eval [1..10]
10:09:06 <lambdabot> (line 1, column 4):
10:09:06 <lambdabot> unexpected "."
10:09:06 <lambdabot> expecting simple term
10:09:07 <ludde> @eval let a = 1 in a
10:09:07 <lambdabot> (line 1, column 7):
10:09:07 <lambdabot> unexpected "="
10:09:07 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string, "(", operator, simple term or end of input
10:09:11 <prologic> lol
10:09:23 <ludde> @eval a where a = 1 
10:09:23 <lambdabot> (line 1, column 11):
10:09:23 <lambdabot> unexpected "="
10:09:23 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string, "(", operator, simple term or end of input
10:09:38 <ludde> @eval var a = 1
10:09:38 <lambdabot> (line 1, column 7):
10:09:38 <lambdabot> unexpected "="
10:09:38 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string, "(", operator, simple term or end of input
10:09:42 <SyntaxPolice> ludde: shapr is probably the primary author
10:09:47 <ludde> SyntaxPolice: ko
10:09:50 <ludde> ok even
10:09:50 <SyntaxPolice> but a lot of people have contributed
10:09:52 <ski> @eval (\a.a) 1
10:09:53 <lambdabot> 1
10:10:00 <SyntaxPolice> http://www.haskell.org/hawiki/LambdaBot
10:10:10 <ludde> @eval (\a.a a) (\a.a)
10:10:10 <lambdabot> <<EM Dynamic -> EM Dynamic>>
10:10:13 <ludde> hm
10:10:19 <ludde> @eval (\a.a a) (\a.a) 1
10:10:19 <lambdabot> 1
10:10:30 <ludde> @eval (\a.a a) 1
10:10:30 <lambdabot> type error
10:10:43 <ludde> @eval (\a.a a) (\a.a a)
10:10:47 <ski> heh
10:10:55 <ludde> @eval 1
10:10:57 <ski> no type error ?
10:11:00 <ludde> oops
10:11:02 <ski> cyclic types ?
10:11:03 <Darius> SyntaxPolice: It's based off of Pseudonym's IRC code, but now there are no primary/main/majority authors; it's rather spread out.
10:11:05 <lambdabot> out of fuel - use @resume to continue
10:11:05 <lambdabot> 1
10:11:15 <ludde> ah out of fuel :)
10:11:18 <ludde> ski: infinite expansion
10:11:21 <SyntaxPolice> Darius: OK :) Someone should actually add the authors to the Wiki page :)
10:12:07 <ski> @eval if True then 1 else 2
10:12:08 <lambdabot> 1
10:12:23 <ski> @eval 4 >= 6
10:12:23 <lambdabot> False
10:13:10 <Darius> @definitions
10:13:11 <lambdabot> ["Arrow"]
10:13:11 <lambdabot> ["B","Branch"]
10:13:11 <lambdabot> ["C","Cons"]
10:13:11 <lambdabot> ["False","Forall"]
10:13:11 <lambdabot> ["I"]
10:13:11 <lambdabot> ["Just"]
10:13:13 <lambdabot> ["K"]
10:13:15 <lambdabot> ["Leaf","Left"]
10:13:17 <lambdabot> ["MonadError","MonadLP","MonadParser","MonadReader","MonadState","MonadWriter","MonadWriter_"]
10:13:19 <lambdabot> [30 @more lines]
10:13:20 <Darius> @get-definition X
10:13:22 <lambdabot> X = \x.x K S K
10:13:26 <ski> @eval (\f.(\t.t t) (\g.f (g g))) (\fac.\n.if n == 0 then 1 else n * fac n)
10:13:26 <lambdabot> <<EM Dynamic -> EM Dynamic>>
10:13:33 <ski> @eval (\f.(\t.t t) (\g.f (g g))) (\fac.\n.if n == 0 then 1 else n * fac n) 25
10:13:46 <ski> too big perhaps
10:13:57 <lambdabot> out of fuel - use @resume to continue
10:13:59 <ski> @eval (\f.(\t.t t) (\g.f (g g))) (\fac.\n.if n == 0 then 1 else n * fac n) 5
10:14:23 <lambdabot> out of fuel - use @resume to continue
10:14:30 <Darius> @get-definition Y
10:14:31 <lambdabot> Y = \f.U(\g.f(U g))
10:14:33 <ski> is it cbv or cbn ?
10:14:54 <Darius> @eval Y (\fac n.if n == 0 then 1 else n * fac (n - 1)) 5
10:14:54 <lambdabot> 120
10:15:02 <ski> fine
10:15:07 <Darius> call-by-need, of course!
10:15:21 <ski> @get-definition U
10:15:21 <lambdabot> U = \f. f f
10:15:23 <ski> ok
10:15:48 <ski> did i make a typo somewhere above ?
10:15:54 <esap> @eval (\f. (\t -> f (t t)) (\g. f (g g)) (\fac.\n.if n == 0 then 1 else n * fac n) 5
10:15:55 <lambdabot> (line 1, column 10):
10:15:55 <lambdabot> unexpected "-"
10:15:55 <lambdabot> expecting identifier or "."
10:16:08 <esap> @eval (\f. (\t.f (t t)) (\g. f (g g)) (\fac.\n.if n == 0 then 1 else n * fac n) 5
10:16:08 <lambdabot> (line 1, column 76):
10:16:08 <lambdabot> unexpected end of input
10:16:08 <lambdabot> expecting simple term, operator or ")"
10:16:21 <esap> @eval (\f. (\t.f (t t)) (\g. f (g g))) (\fac.\n.if n == 0 then 1 else n * fac n) 5
10:16:35 <Darius> @eval take 10 (fix (\ones.1:ones))
10:16:45 <ludde> @eval sum [1..2]
10:16:46 <lambdabot> out of fuel - use @resume to continue
10:16:46 <lambdabot> [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
10:16:46 <lambdabot> (line 1, column 8):
10:16:46 <lambdabot> unexpected "."
10:16:46 <lambdabot> expecting simple term
10:16:54 <ludde> @eval [1..2]
10:16:54 <lambdabot> (line 1, column 4):
10:16:54 <lambdabot> unexpected "."
10:16:54 <lambdabot> expecting simple term
10:17:10 <Darius> @eval sum (enumFromTo 1 10)
10:17:10 <lambdabot> 55
10:17:15 <ski> ludde : it doesn't seem to understand list compr.
10:17:23 <prologic> it doesn't understand ..
10:21:33 <ski> @eval (\t.t t) (\g.\f.f (g g f)) (\fac.\n.if n == 0 then 1 else n * fac n) 5
10:21:59 <lambdabot> out of fuel - use @resume to continue
10:23:34 <cm> @eval 1337
10:23:35 <lambdabot> 1337
10:24:48 <ski> @eval map (\x.(x * (x + 1)) / 2) [2,3,5,7,13,17,19]
10:24:49 <lambdabot> [3, 6, 15, 28, 91, 153, 190]
10:25:41 <Darius> It has Haskell's precedence rules for the operators implemented.
10:26:24 <ski> @eval map (\x.(x * (x + 1)) / 2) (map (\x.(2 ^ x) -1) [2,3,5,7,13,17,19])
10:26:24 <lambdabot> (line 1, column 40):
10:26:24 <lambdabot> unexpected "^"
10:26:24 <lambdabot> expecting operator, simple term or ")"
10:26:54 <Darius> ^ isn't implemented, but would be very easy to add.
10:27:07 <ski> **,* ?
10:27:55 <Darius> * is of course, ** isn't.  In fact, it uses Integers not Double or Rational so ** doesn't make much sense.
10:28:14 <Darius> @get-definition pow
10:28:14 <lambdabot> pow not defined
10:28:24 <Darius> meh
10:28:46 <ski> @eval (\pow.map (\x.(x * (x + 1)) / 2) (map (\x.pow 2 x - 1) [2,3,5,7,13,17,19]) (fix (\x.\y.if x == 0 then 1 else x * pow x (y-1)))
10:28:47 <lambdabot> (line 1, column 127):
10:28:47 <lambdabot> unexpected end of input
10:28:47 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string, "(", operator, simple term or ")"
10:28:49 <Darius> Who needs a simple programming exercise?
10:29:02 <ski> @eval (\pow.map (\x.(x * (x + 1)) / 2) (map (\x.pow 2 x - 1)
10:29:02 <lambdabot> (line 1, column 55):
10:29:02 <lambdabot> unexpected end of input
10:29:02 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string, "(", operator, simple term or ")"
10:29:06 <ski>   [2,3,5,7,13,17,19])) (fix (\x.\y.if x == 0 then 1 else x * pow x (y-1)))
10:29:26 <ski> @eval (\pow.map (\x.(x * (x + 1)) / 2) (map (\x.pow 2 x - 1) [2,3,5,7,13,17,19])) (fix (\x.\y.if x == 0 then 1 else x * pow x (y-1)))
10:29:26 <lambdabot> type error
10:29:32 <phubuh_> @eval foldl
10:29:32 <lambdabot> <<EM Dynamic -> EM Dynamic>>
10:29:54 <Darius> let would be a decent addition to the syntax
10:29:56 <ski> Darius : i meant ** and ^^
10:30:12 <ski> @eval (\pow.map (\x.(x * (x + 1)) / 2) (map (\x.pow 2 x - 1)
10:30:12 <lambdabot> (line 1, column 55):
10:30:12 <lambdabot> unexpected end of input
10:30:12 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string, "(", operator, simple term or ")"
10:30:20 <ski>   [2,3,5,7,13,17,19])) (fix (\pow.\x.\y.if x == 0 then 1 else x * pow x (y-1)))
10:31:00 <phubuh_> @get-definition pow
10:31:00 <lambdabot> pow not defined
10:31:11 <ski> doh !
10:31:14 <phubuh_> @define pow \n. if n == 0 then 1 else n * pow (n - 1)
10:31:14 <lambdabot> pow defined
10:31:18 <phubuh_> @eval pow 4
10:31:18 <lambdabot> 24
10:31:21 <ski> @eval (\pow.map (\x.(x * (x + 1)) / 2) (map (\x.pow 2 x - 1) [2,3,5,7,13,17,19])) (fix (\pow.\x.\y.if x == 0 then 1 else x * pow x (y-1)))
10:31:26 <Darius> @eval (\n x.product (replicate n x)) 2 5
10:31:50 <lambdabot> out of fuel - use @resume to continue
10:31:50 <lambdabot> 25
10:32:11 <ski> @eval (\pow.map (\x.(x * (x + 1)) / 2) (map (\x.pow 2 x - 1) [2,3,5])) (fix (\pow.\x.\y.if x == 0 then 1 else x * pow x (y-1)))
10:32:13 <Darius> @eval (\n x.product (replicate x n)) 2 5
10:32:41 <lambdabot> out of fuel - use @resume to continue
10:32:41 <lambdabot> 32
10:32:44 <ski> :(
10:33:08 <ski> (\pow.map (\x.(x * (x + 1)) / 2) (map (\x.pow 2 x - 1) [2,3,5])) (\n x.product (replicate n x))
10:33:23 <ski> @eval (\pow.map (\x.(x * (x + 1)) / 2) (map (\x.pow 2 x - 1) [2,3,5])) (\n.x.product (replicate n x))
10:33:23 <lambdabot> unbound variable: x
10:33:34 <ski> @eval (\pow.map (\x.(x * (x + 1)) / 2) (map (\x.pow 2 x - 1) [2,3,5])) (\n.\x.product (replicate n x))
10:33:34 <Darius> phubuh_: Make a logarithmic pow, not linear.
10:33:35 <lambdabot> [6, 36, 300]
10:34:11 <Darius> @get-definition replicate
10:34:11 <lambdabot> replicate = \n x.take n (iterate id x)
10:34:25 <ski> @eval (\x.(x * (x + 1)) / 2) ((\x.pow 2 x - 1) 3))
10:34:25 <lambdabot> (line 1, column 44):
10:34:25 <lambdabot> unexpected ")"
10:34:25 <lambdabot> expecting simple term or end of input
10:34:47 <ski> @eval (\x.(x * (x + 1)) / 2) ((\x.pow 2 x - 1) 3)
10:34:47 <lambdabot> type error
10:35:05 <prologic> @eval pow 2
10:35:06 <lambdabot> 2
10:35:08 <prologic> @eval pow 3
10:35:09 <lambdabot> 6
10:35:10 <arguile> @eval (\fib -> 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ]) [1..10]
10:35:10 <lambdabot> (line 1, column 7):
10:35:10 <lambdabot> unexpected "-"
10:35:10 <lambdabot> expecting identifier or "."
10:35:23 <prologic> what is pow ?
10:35:41 <Darius> -^-
10:35:53 <prologic> raised to what index ?
10:36:07 <ski> pow is currently factorial
10:36:22 <prologic> that's what I thought
10:36:22 <prologic> lol
10:36:29 <Darius> @define fib 1:1:zipWith (\x y.x+y) fib (tail fib)
10:36:29 <lambdabot> fib defined
10:36:31 <prologic> I said wait a minute, that's factorial
10:36:37 <Darius> @eval take 10 fib
10:36:40 <lambdabot> [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
10:36:50 <prologic> cool :)
10:37:19 <ski> @eval (\pow.(\x.(x * (x + 1)) / 2) ((\x.pow 2 x - 1) 3)) (\n.\x.product (replicate n x))
10:37:19 <lambdabot> 36
10:37:49 <ski> @eval (\pow.(\x.pow 2 x - 1) 3) (\n.\x.product (replicate n x))
10:37:49 <lambdabot> 8
10:37:55 <Darius> You need to swap the n and the x, if you want 2^x.
10:38:23 <ski> oh, i thought i just took the right version above.  doh
10:38:52 <ski> @eval (\pow.map (\x.(x * (x + 1)) / 2) (map (\x.pow 2 x - 1) [2,3,5])) (\x.\n.product (replicate n x))
10:38:52 <lambdabot> [6, 28, 496]
10:38:56 <ski> yay !
10:39:05 <phubuh_> @define pow \b. \n. if n == 0 then 1 else (if even n then (square (pow b (n / 2))) else (b * (pow b (n - 1))))
10:39:06 <lambdabot> pow defined
10:39:12 <phubuh_> @eval pow 2 4
10:39:12 <lambdabot> unbound variable: even
10:39:32 <phubuh_> @eval 5 mod 2
10:39:32 <lambdabot> type error
10:39:35 <ski> @eval 15 % 7
10:39:35 <lambdabot> (line 1, column 4):
10:39:35 <lambdabot> unexpected "%"
10:39:35 <lambdabot> expecting operator, simple term or end of input
10:39:38 <phubuh_> @eval mod 5 2
10:39:38 <lambdabot> 1
10:39:41 <prologic> @eval 5 `mod` 2
10:39:41 <lambdabot> 1
10:39:41 <ski> @eval mod 15 7
10:39:42 <lambdabot> 1
10:39:44 <Darius> @eval 5 `mod` 2
10:39:44 <lambdabot> 1
10:39:48 <Darius> @get-definition square
10:39:49 <lambdabot> square not defined
10:39:57 <phubuh_> @define even \x. if x mod 2 == 0 then True else False
10:39:57 <lambdabot> even defined
10:40:03 <phubuh_> @eval even 2
10:40:03 <lambdabot> type error
10:40:05 <phubuh_> @eval even 3
10:40:05 <lambdabot> type error
10:40:13 <phubuh_> oh, huh
10:40:15 <prologic> any of you compiled lambdabot before ?
10:40:19 <ski> @define even \x. if x `mod` 2 == 0 then True else False
10:40:20 <lambdabot> even defined
10:40:23 <Darius> `mod`
10:40:25 <phubuh_> oh duh
10:40:35 <Darius> also there's no point to do if True then True
10:40:36 <phubuh_> @eval [even 2, even 3]
10:40:37 <lambdabot> [True, False]
10:40:48 <ski> @define even \x.x `mod` 2 == 0
10:40:49 <lambdabot> even defined
10:40:57 <phubuh_> @eval pow 2 4
10:40:58 <lambdabot> unbound variable: square
10:41:05 <phubuh_> @define square \x.x*x
10:41:05 <lambdabot> square defined
10:41:08 <phubuh_> @eval pow 2 4
10:41:08 <lambdabot> 16
10:41:15 <phubuh_> @eval pow 5 3
10:41:15 <lambdabot> 125
10:41:32 <ski> @eval map (\x.(x * (x + 1)) / 2) (map (\x.pow 2 x - 1) [2,3,5,7])
10:41:34 <lambdabot> [6, 28, 496, 8128]
10:41:36 <prologic> @get-definition pow
10:41:36 <lambdabot> pow = \b. \n. if n == 0 then 1 else (if even n then (square (pow b (n / 2))) else (b * (pow b (n - 1))))
10:41:43 <prologic> @get-definition square
10:41:43 <lambdabot> square = \x.x*x
10:41:46 <ski> @eval map (\x.(x * (x + 1)) / 2) (map (\x.pow 2 x - 1) [2,3,5,7,13])
10:41:46 <lambdabot> [6, 28, 496, 8128, 33550336]
10:42:33 <ski> @eval map (\x.(x * (x + 1)) / 2) (map (\x.pow 2 x - 1) [2,3,5,7,13,17,19,31,67])
10:42:34 <lambdabot> [6, 28, 496, 8128, 33550336, 8589869056, 137438691328, 2305843008139952128, 10889035741470030830754200461521744560128]
10:43:21 <ski> @define someMersennePrimes [2,3,5,7,13,17,19,31,67,127,257]
10:43:21 <lambdabot> someMersennePrimes defined
10:43:58 <norpan> @get-definition fibs
10:43:58 <lambdabot> fibs not defined
10:44:20 <Darius> @get-definition fib
10:44:20 <lambdabot> fib = 1:1:zipWith (\x y.x+y) fib (tail fib)
10:44:27 <norpan> oh
10:44:27 <prologic> ERROR "test.hs":18 - Syntax error in expression (unexpected `.'), is pow = \b. \n. if n == 0 then 1 else (if even n then (square (pow b (n / 2))) else (b * (pow b (n - 1)))) syntactically correct ?
10:44:36 <norpan> @eval take 10 fib
10:44:38 <Darius> @define fibs 1:1:zipWith (\x y.x+y) fib (tail fib)
10:44:39 <lambdabot> [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
10:44:39 <lambdabot> fibs defined
10:44:57 <Darius> @define fibs 1:1:zipWith (\x y.x+y) fibs (tail fibs)
10:44:57 <lambdabot> fibs defined
10:45:07 <Darius> @del-definition fib
10:45:07 <lambdabot> fib removed
10:45:12 <norpan> that's better :)
10:45:20 <Darius> prologic: Haskell uses \x -> x instead of \x.x
10:45:21 <norpan> but you should use zipWith (+)
10:45:34 <prologic> ta Darius, why does the bot use something different ?
10:45:54 <ski> @define makePerfect \x.(\y.y * (y + 1) / 2) (pow 2 x - 1)
10:45:55 <Darius>  @eval doesn't support sections or (+) syntax
10:45:55 <lambdabot> makePerfect defined
10:46:01 <norpan> oh
10:46:01 * Darius actually doesn't remember about that latter
10:46:08 <norpan> stupid bot
10:46:18 <Darius> @eval zipWith (+) [1] [2]
10:46:19 <lambdabot> (line 1, column 10):
10:46:19 <lambdabot> unexpected "+"
10:46:19 <lambdabot> expecting simple term
10:46:25 <ski> @define somePerfectNumbers map makePerfect someMersennePrimes
10:46:25 <lambdabot> somePerfectNumbers defined
10:46:32 <ski> @eval somePerfectNumbers
10:46:33 <lambdabot> [6, 28, 496, 8128, 33550336, 8589869056, 137438691328, 2305843008139952128, 10889035741470030830754200461521744560128, 14474011154664524427946373126085988481573677491474835889066354349131199152128, 26815615859885194199148049996411692254958731641184786755447122887443528060146978161514511280138383284395055028465118831722842125059853682308859384882528256]
10:46:38 <ski> :)
10:47:26 <Darius> prologic: Because \x -> x takes more room than \x.x, LC uses \x.x, and it was originally didn't have too large expressions to deal with (@define changed that) so it wasn't much of a problem.
10:47:36 <Darius> I'm thinking about changing to \x -> x 
10:48:03 <prologic> well if the bot is going to evaluate haskell expressions it at least should use Haskell syntax :)
10:48:26 <Darius> It isn't though, it evaluate lambda calculus expressions
10:48:34 <ski> or a subset thereof, at least
10:48:41 <prologic> yeh
10:48:48 <prologic> not a different syntax :)
10:48:55 <Darius> @eval joy "3 4 *"
10:48:58 <lambdabot> [12]
10:49:08 <ski> @type joy
10:50:17 <prologic> and shouldn't it have been "pow = \b -> \n -> if n == 0 then 1 else (if even n then (square (pow b (n `div` 2))) else (b * (pow b (n - 1))))", since you're mixing Fractional and Integral ?
10:50:39 <Darius> prologic: @eval only uses Integers
10:50:46 <prologic> oh ok
10:50:48 <prologic> phew :)
10:50:49 <Darius> ski: joy isn't exactly a prelude function
10:51:37 <ski> lambdabot typechecks exprs fed into @eval, right ?
10:52:00 <Darius> No, @type spawns a Hugs process.
10:52:03 <ski> @eval 1 2
10:52:03 <lambdabot> type error
10:52:29 <ski> can't one get to see @evals inferred type, somehow ?
10:52:47 <ski> (at leastin case of type correctness)
10:52:49 <prologic> where is depend found ?
10:52:56 <prologic> I cannot compile lambdabot because it's not there
10:52:56 <Darius> eval doesn't infer types, it's dynamically type checked.
10:53:08 <ski> ah, ok.
10:53:39 <phubuh_> @eval (\n. all (== 0) (map (\i. flip mod i) (enumFromTo 2 (sqrt n + 1)))) 7
10:53:39 <lambdabot> (line 1, column 11):
10:53:39 <lambdabot> unexpected "="
10:53:39 <lambdabot> expecting simple term
10:53:49 <Darius> Part of the reason is not to limit what can be done with, i.e. U is untypable in HM, and part is because I'm lazy.
10:53:52 <phubuh_> @eval (\n. all (\x. x == 0) (map (\i. flip mod i) (enumFromTo 2 (sqrt n + 1)))) 7
10:53:53 <lambdabot> unbound variable: sqrt
10:54:01 <phubuh_> oh no.
10:54:16 <phubuh_> @eval (\n. all (\x. x == 0) (map (\i. flip mod i) (enumFromTo 2 n))) 7
10:54:16 <lambdabot> type error
10:54:36 <phubuh_> @get-definition all
10:54:36 <lambdabot> all = \p.and . map p
10:54:50 <ski> Darius : ok  (though U is typeable with rectypes aka cyclic types aka equi-recursive types, right ?)
10:54:53 <Darius> I can make it a bit more helpful about the type errors, I just haven't done it yet.
10:55:10 <ski> mm
10:55:21 <Darius> Yes, if you wrap it, but then you are just moving the problem up to the type level.
10:55:43 <ski> no, i mean equi-recursive types
10:55:44 <phubuh_> @get-definition any
10:55:44 <lambdabot> any = \p.or . map p
10:55:51 <Darius> You can use the Y combinator... if you have recursive types.
10:55:56 <phubuh_> @eval (\n. any (\x. x == 0) (map (\i. flip mod i) (enumFromTo 2 (n - 1)))) 7
10:55:56 <lambdabot> type error
10:56:02 <phubuh_> hrm.
10:56:04 <ski> like ocaml -rectypes
10:56:32 <phubuh_> @eval enumFromTo 2 (7 - 1)
10:56:32 <lambdabot> [2, 3, 4, 5, 6]
10:56:48 <phubuh_> ooh, of course
10:57:12 <phubuh_> @eval (\n. any (\x. x == 0) (map (mod n) (enumFromTo 2 (n - 1)))) 7
10:57:12 <lambdabot> False
10:57:19 <phubuh_> @eval (\n. any (\x. x == 0) (map (mod n) (enumFromTo 2 (n - 1)))) 8
10:57:19 <lambdabot> True
10:57:42 <phubuh_> @eval (\n. all (\x. x != 0) (map (mod n) (enumFromTo 2 (n - 1)))) 8
10:57:43 <lambdabot> (line 1, column 17):
10:57:43 <lambdabot> unexpected "!"
10:57:43 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string, "(", operator, simple term or ")"
10:57:49 <phubuh_> @eval (\n. all (\x. x /= 0) (map (mod n) (enumFromTo 2 (n - 1)))) 8
10:57:53 <lambdabot> False
10:57:53 <phubuh_> @eval (\n. all (\x. x /= 0) (map (mod n) (enumFromTo 2 (n - 1)))) 7
10:57:53 <lambdabot> True
10:58:04 <phubuh_> @define isPrime (\n. all (\x. x /= 0) (map (mod n) (enumFromTo 2 (n - 1))))
10:58:04 <lambdabot> isPrime defined
10:58:18 <ski> Darius : like
10:58:18 <ski> [md9slj@dada8][~]> ocaml -rectypes
10:58:19 <ski>         Objective Caml version 3.04
10:58:21 <ski>  
10:58:26 <ski> # let u t = t t;;
10:58:26 <ski> val u : ('a -> 'b as 'a) -> 'b = <fun>
10:58:26 <ski> # let y f = u (fun g -> f (u g));;
10:58:27 <ski> val y : ('a -> 'a) -> 'a = <fun>
10:58:58 <ski> @eval sqrt
10:58:58 <lambdabot> unbound variable: sqrt
10:59:22 <phubuh_> that's why it goes up to n-1 instead of sqrt n - 1 :-)
10:59:24 <phubuh_> err, + 1
10:59:27 <Darius> phubuh: You could define an integer sqrt.  I'm not sure how efficient it would be.
11:02:40 <prologic> @eval isPrime 2
11:02:40 <lambdabot> True
11:02:45 <prologic> @eval isPrime 9
11:02:45 <phubuh_> \eval map (\x. pow 2 x - 1) [1, 2, 3, 4, 5]
11:02:45 <lambdabot> False
11:02:54 <phubuh_> @eval map (\x. pow 2 x - 1) [1, 2, 3, 4, 5]
11:02:54 <lambdabot> [1, 3, 7, 15, 31]
11:03:26 <prologic> @eval map (\x. isPrime x) enumFromTo 1 20
11:03:27 <lambdabot> type error
11:03:30 <phubuh_> does @eval do lazy evaluation?
11:03:41 <phubuh_> @eval map isPrime (enumFromTo 1 20)
11:03:42 <prologic> @eval map (\x. isPrime x) (enumFromTo 1 20)
11:03:45 <lambdabot> [True, True, True, False, True, False, True, False, False, False, True, False, True, False, False, False, True, False, True, False]
11:03:48 <lambdabot> [True, True, True, False, True, False, True, False, False, False, True, False, True, False, False, False, True, False, True, False]
11:04:17 <phubuh_> @eval take 5 (enumFrom 1)
11:04:17 <lambdabot> [1, 2, 3, 4, 5]
11:04:20 <phubuh_> yay
11:04:21 <prologic> @eval filter (\x. isPrime x) (enumFromTo 1 20)
11:04:22 <lambdabot> [1, 2, 3, 5, 7, 11, 13, 17, 19]
11:04:58 <phubuh_> @eval take 5 (filter isPrime (map (\x. pow 2 x - 1) (enumFrom 1)))
11:05:26 <lambdabot> out of fuel - use @resume to continue
11:05:34 <phubuh_> @eval take 1 (filter isPrime (map (\x. pow 2 x - 1) (enumFrom 1)))
11:05:34 <lambdabot> [1]
11:05:46 <phubuh_> @eval isPrime 1
11:05:46 <lambdabot> True
11:05:53 <phubuh_> oops.
11:06:02 <phubuh_> @eval take 2 (filter isPrime (map (\x. pow 2 x - 1) (enumFrom 1)))
11:06:03 <lambdabot> [1, 3]
11:06:12 <phubuh_> @eval take 4 (filter isPrime (map (\x. pow 2 x - 1) (enumFrom 1)))
11:06:15 <lambdabot> [1, 3, 7, 31]
11:06:29 <phubuh_> @define mersennePrimes (filter isPrime (map (\x. pow 2 x - 1) (enumFrom 1)))
11:06:31 <lambdabot> mersennePrimes defined
11:06:58 <phubuh_> @eval take 5 mersennePrimes
11:07:26 <lambdabot> out of fuel - use @resume to continue
11:07:28 <phubuh_> @resume
11:07:37 <Darius> @resume
11:07:58 <lambdabot> out of fuel - use @resume to continue
11:08:29 <lambdabot> out of fuel - use @resume to continue
11:08:38 <phubuh_> heh
11:09:08 <Darius> isPrime isn't exactly the most efficient of things on large numbers.
11:10:08 <Darius> It would also be better to incrementally calculate the powers
11:11:54 <phubuh_> @eval "strings?"
11:11:56 <lambdabot> strings?
11:12:09 <Darius> @eval take 10 $ map pred (iterate (\x.x*2) 2)
11:12:09 <lambdabot> unbound variable: pred
11:12:12 <phubuh_> @eval map (\x. x) "are lists?"
11:12:12 <lambdabot> are lists?
11:12:20 <ski> @define sqrt (\x.fix (\sqrt.\a.if square a <= x && square (a+1) > x then a else sqrt ((a + x / a) / 2)) x)
11:12:20 <lambdabot> sqrt defined
11:12:27 <phubuh_> yay!
11:12:32 <phubuh_> @get-definition isPrime
11:12:32 <lambdabot> isPrime = (\n. all (\x. x /= 0) (map (mod n) (enumFromTo 2 (n - 1))))
11:12:39 <Darius> @eval take 10 $ map (\x.x-1) (iterate (\x.x*2) 2)
11:12:39 <lambdabot> [1, 3, 7, 15, 31, 63, 127, 255, 511, 1023]
11:12:46 <phubuh_> @define isPrime (\n. all (\x. x /= 0) (map (mod n) (enumFromTo 2 (sqrt n + 1))))
11:12:46 <lambdabot> isPrime defined
11:12:57 <ski> @eval (\sqrt.map sqrt (enumFromTo 0 31))
11:12:57 <lambdabot> <<EM Dynamic -> EM Dynamic>>
11:13:00 <Darius> @eval sqrt 24
11:13:01 <lambdabot> 4
11:13:06 <ski> @eval map sqrt (enumFromTo 0 31)
11:13:07 <lambdabot> [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5]
11:13:17 <ski> @eval (1,2)
11:13:17 <lambdabot> (line 1, column 3):
11:13:17 <lambdabot> unexpected ","
11:13:17 <lambdabot> expecting digit, operator, simple term or ")"
11:13:36 <Darius> No pair syntax
11:13:38 <phubuh_> @eval map (\x. [x, sqrt x]) (enumFromTo 0 31)
11:13:39 <lambdabot> [[0, 0], [1, 1], [2, 1], [3, 1], [4, 2], [5, 2], [6, 2], [7, 2], [8, 2], [9, 3], [10, 3], [11, 3], [12, 3], [13, 3], [14, 3], [15, 3], [16, 4], [17, 4], [18, 4], [19, 4], [20, 4], [21, 4], [22, 4], [23, 4], [24, 4], [25, 5], [26, 5], [27, 5], [28, 5], [29, 5], [30, 5], [31, 5]]
11:13:42 <ski> @eval map (\x -> 1000 * sqrt x + x) (enumFromTo 0 31)
11:13:42 <lambdabot> (line 1, column 9):
11:13:42 <lambdabot> unexpected "-"
11:13:42 <lambdabot> expecting identifier or "."
11:13:53 <ski> @eval map (\x.1000 * sqrt x + x) (enumFromTo 0 31)
11:13:54 <lambdabot> [0, 1001, 1002, 1003, 2004, 2005, 2006, 2007, 2008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 4024, 5025, 5026, 5027, 5028, 5029, 5030, 5031]
11:14:01 <Darius> @definitions show
11:14:01 <lambdabot> ["showList","showMaybe","showNum","showPair","showTerm","showTerm'","showType"]
11:14:22 <phubuh_> @definitions pair
11:14:22 <lambdabot> ["pair"]
11:14:26 <phubuh_> @eval pair 2 5
11:14:26 <lambdabot> type error
11:14:26 <Darius> @eval showPair showNum showNum (Pair 2 4)
11:14:26 <lambdabot> (2,4)
11:14:43 <phubuh_> @eval pow 2 13
11:14:43 <lambdabot> 8192
11:14:49 <phubuh_> @eval isPrime (pow 2 13)
11:14:49 <lambdabot> False
11:14:55 <phubuh_> @eval isPrime (pow 2 13 - 1)
11:14:56 <Darius> @eval fst (Pair 1 2)
11:14:57 <lambdabot> True
11:14:57 <lambdabot> 1
11:15:05 <ski> phubuh_ : is it faster now ?
11:15:15 <Darius> @eval pair (\a b.a + b) (Pair 1 2)
11:15:15 <lambdabot> 3
11:15:17 <phubuh_> i'm not sure
11:15:21 <phubuh_> @eval take 5 mersennePrimes
11:15:24 <lambdabot> [1, 3, 7, 31, 127]
11:15:28 <phubuh_> yay!
11:15:30 <ski> @eval Pair 1 2
11:15:30 <lambdabot> <<EM Dynamic -> EM Dynamic>>
11:15:45 <phubuh_> @eval take 6 mersennePrimes
11:15:46 <Darius> @get-definition Pair
11:15:53 <ski> @eval someMersennePrimes
11:15:54 <Darius> @get-definion Left
11:15:56 <lambdabot> [1, 3, 7, 31, 127, 8191]
11:15:56 <lambdabot> Pair = \x y k.k x y
11:15:56 <lambdabot> [2, 3, 5, 7, 13, 17, 19, 31, 67, 127, 257]
11:15:56 <lambdabot> Sorry, I don't know the command "get-definion", try "lambdabot: @listcommands"
11:16:05 <phubuh_> it's a lot faster!
11:16:20 <Darius> @get-definition Left
11:16:20 <lambdabot> Left = \x l r.l x
11:16:38 <ski> @get-definition mersennePrimes
11:16:38 <lambdabot> mersennePrimes = (filter isPrime (map (\x. pow 2 x - 1) (enumFrom 1)))
11:17:18 <ski> @eval isPrime 3
11:17:19 <lambdabot> True
11:17:31 <Darius> @eval take 10 $ map (\x.pow 2 x - 1) (from 1)
11:17:31 <lambdabot> [1, 3, 7, 15, 31, 63, 127, 255, 511, 1023]
11:17:40 <phubuh_> ooh, there's a $! :-)
11:17:56 <Darius> @eval take 10 $ map (\x.x-1) $ iterate (\x.x*2) 2
11:17:56 <lambdabot> [1, 3, 7, 15, 31, 63, 127, 255, 511, 1023]
11:18:31 <ski> @eval take 5 mersennePrimes
11:18:35 <lambdabot> [1, 3, 7, 31, 127]
11:18:44 <ski> @eval someMersennePrimes
11:18:44 <lambdabot> [2, 3, 5, 7, 13, 17, 19, 31, 67, 127, 257]
11:18:53 <ski> why doesn't it find 2 ?
11:19:16 <Darius> @eval take 10 $ unfoldr (\x.Just (Pair (x*2) (x*2-1))) 2
11:19:17 <lambdabot> [4, 6, 10, 18, 34, 66, 130, 258, 514, 1026]
11:19:30 <Darius> @eval take 10 $ unfoldr (\x.Just (Pair (x*2-1) (x*2))) 2
11:19:31 <lambdabot> [3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047]
11:19:44 <phubuh_> ski, someMersennePrimes contains exponents; mersennePrimes contains primes
11:19:53 <ski> oh
11:21:21 <phubuh_> @define mersenneExponents filter (\x. isPrime (pow 2 x - 1)) (from 1)
11:21:21 <lambdabot> mersenneExponents defined
11:21:34 <phubuh_> @take 5 mersenneExponents
11:21:34 <lambdabot> Sorry, I don't know the command "take", try "lambdabot: @listcommands"
11:21:39 <phubuh_> @eval take 5 mersenneExponents
11:21:43 <lambdabot> [1, 2, 3, 5, 7]
11:21:54 <phubuh_> @eval isPrime 0
11:21:54 <lambdabot> True
11:21:57 <phubuh_> heh
11:23:56 <ski> i seemed to remember that the exponents were the mersenne primes.  guess i remembered wrong
11:24:28 <ski> @get-definition someMersennePrimes
11:24:37 <lambdabot> someMersennePrimes = [2,3,5,7,13,17,19,31,67,127,257]
11:24:47 <ski> @define someMersennePrimeExponents = [2,3,5,7,13,17,19,31,67,127,257]
11:24:50 <lambdabot> (line 1, column 2):
11:24:50 <lambdabot> unexpected "="
11:24:50 <lambdabot> expecting space or simple term
11:24:55 <ski> @define someMersennePrimeExponents [2,3,5,7,13,17,19,31,67,127,257]
11:24:57 <lambdabot> someMersennePrimeExponents defined
11:25:03 <ski> @del-definition someMersennePrimes
11:25:05 <lambdabot> not enough privileges
11:25:18 <ski> @get-definitions somePrefects
11:25:20 <lambdabot> Sorry, I don't know the command "get-definitions", try "lambdabot: @listcommands"
11:25:26 <ski> @get-definitions somePerfects
11:25:26 <lambdabot> Sorry, I don't know the command "get-definitions", try "lambdabot: @listcommands"
11:25:37 <ski> @get-definition somePerfects
11:25:39 <lambdabot> somePerfects not defined
11:25:43 <ski> @get-definition somePerfectNumbers
11:25:50 <lambdabot> somePerfectNumbers = map makePerfect someMersennePrimes
11:25:54 <Darius> @definitions some
11:25:54 <lambdabot> ["someMersennePrimeExponents","someMersennePrimes","somePerfectNumbers"]
11:26:05 <ski> @define somePerfectNumbers map makePerfect someMersennePrimeExponents
11:26:05 <lambdabot> somePerfectNumbers defined
11:26:19 <Darius> @definitions p
11:26:19 <lambdabot> ["pair","para","paraNat","parens","parseError","parseNum","parseRule","parseTerm","pass","pow","product","prologFreevars","prologMatch","put"]
11:26:19 <ski> @eval somePerfectNumbers
11:26:19 <lambdabot> [6, 28, 496, 8128, 33550336, 8589869056, 137438691328, 2305843008139952128, 10889035741470030830754200461521744560128, 14474011154664524427946373126085988481573677491474835889066354349131199152128, 26815615859885194199148049996411692254958731641184786755447122887443528060146978161514511280138383284395055028465118831722842125059853682308859384882528256]
11:26:50 <ski> @define someMersennePrimes "this was removed"
11:26:53 <lambdabot> someMersennePrimes defined
11:26:58 <ski> @eval someMersennePrimes
11:27:00 <lambdabot> this was removed
11:27:09 <Darius> @del-definition someMersennePrimes
11:27:22 <lambdabot> someMersennePrimes removed
11:27:22 <ski> good
11:29:29 <ski> @define divides \n.\d.n `mod` d == 0
11:29:29 <lambdabot> divides defined
11:30:45 <ski> @define divides \d.\n.n `mod` d == 0
11:30:47 <lambdabot> divides defined
11:33:43 <ski> @eval filter (\x.not (divides x 12))(enumFromTo 2 (sqrt 12 + 1))
11:33:46 <lambdabot> []
11:35:37 <Darius> @get-definition enumFromTo
11:35:39 <lambdabot> enumFromTo = \l h.take (h-l+1) $ iterate (\x.x+1) l
11:35:44 <Darius> @get-definition fromTo
11:35:47 <lambdabot> fromTo = enumFromTo
11:37:09 <ski> @eval filter (\x.divides x 12) (enumFromTo 1 12)
11:37:12 <lambdabot> [1, 2, 3, 4, 6, 12]
11:39:53 <ski> @eval factors 0
11:39:56 <lambdabot> []
11:40:34 <ski> @define factors \n.if n == 0 then from 0 else filter (\d.d `divides` n) (fromTo 1 n)
11:40:34 <lambdabot> factors defined
11:41:03 <ski> @eval take 40 (factors 0)
11:41:05 <lambdabot> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39]
11:42:01 <ski> @eval sum [1,2,3,4]
11:42:03 <lambdabot> 10
11:42:27 <ski> @define decay \n.sum (factors n) - n
11:42:29 <lambdabot> decay defined
11:42:43 <ski> @eval map decay (fromTo 1 20)
11:42:50 <lambdabot> [0, 1, 1, 3, 1, 6, 1, 7, 4, 8, 1, 16, 1, 10, 9, 15, 1, 21, 1, 22]
11:48:43 <ski> @define decaySequence unfoldr (\n.if n == 0 then Nothing else Just (Pair n (decay n)))
11:48:46 <lambdabot> decaySequence defined
11:49:30 <ski> @eval map (take 10 . decaySequence) $ fromTo 0 20
11:49:45 <lambdabot> [[], [1], [2, 1], [3, 1], [4, 3, 1], [5, 1], [6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [7, 1], [8, 7, 1], [9, 4, 3, 1], [10, 8, 7, 1], [11, 1], [12, 16, 15, 9, 4, 3, 1], [13, 1], [14, 10, 8, 7, 1], [15, 9, 4, 3, 1], [16, 15, 9, 4, 3, 1], [17, 1], [18, 21, 11, 1], [19, 1], [20, 22, 14, 10, 8, 7, 1]]
11:51:45 <ski> @define decaySequence \n.n : unfoldr (\n.if n == 0 then Nothing else (\m.Just (Pair m m)) (decay n)) n
11:51:47 <lambdabot> decaySequence defined
11:51:52 <ski> @eval map (take 10 . decaySequence) $ fromTo 0 20
11:52:13 <lambdabot> [[0], [1, 0], [2, 1, 0], [3, 1, 0], [4, 3, 1, 0], [5, 1, 0], [6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [7, 1, 0], [8, 7, 1, 0], [9, 4, 3, 1, 0], [10, 8, 7, 1, 0], [11, 1, 0], [12, 16, 15, 9, 4, 3, 1, 0], [13, 1, 0], [14, 10, 8, 7, 1, 0], [15, 9, 4, 3, 1, 0], [16, 15, 9, 4, 3, 1, 0], [17, 1, 0], [18, 21, 11, 1, 0], [19, 1, 0], [20, 22, 14, 10, 8, 7, 1, 0]]
11:53:12 <ski> @eval take 5 (decaySequence 25)
11:53:15 <lambdabot> [25, 6, 6, 6, 6]
11:53:28 <ski> @eval take 5 (decaySequence 28)
11:53:31 <lambdabot> [28, 28, 28, 28, 28]
11:53:39 <ski> @eval take 5 (decaySequence 220)
11:54:04 <lambdabot> [220, 284, 220, 284, 220]
11:54:09 <ski> :)
11:54:50 <ski> @get-definition factors
11:54:50 <lambdabot> factors = \n.if n == 0 then from 0 else filter (\d.d `divides` n) (fromTo 1 n)
11:55:25 <ski> @get-definition ++
11:55:27 <lambdabot> ++ not defined
11:55:34 <ski> @get-definition append
11:55:36 <lambdabot> append = flip (fold Cons)
11:55:58 <Darius> @eval [1]++[2]
11:55:58 <lambdabot> [1, 2]
11:56:06 <Darius> It's just that it's syntax
11:56:39 <Darius> append is for Church encoded lists.
11:56:48 <Darius> @get-definition Cons
11:56:50 <lambdabot> Cons = \a l n c.c a l
11:57:01 <Darius> (actually something like Church encoding
11:57:15 <ski> @get-definition []
11:57:17 <lambdabot> [] not defined
11:57:20 <ski> @get-definition :
11:57:23 <lambdabot> : not defined
11:57:28 <ski> @get-definition null
11:57:30 <lambdabot> null not defined
11:57:35 <ski> @get-definition head
11:57:35 <lambdabot> head not defined
11:57:42 <ski> @get-definition map
11:57:42 <lambdabot> map = \f.foldr (\x y.f x:y) []
11:57:47 <Darius> None of the operators are defined.
11:57:49 <ski> @get-definition foldr
11:57:49 <lambdabot> foldr = \c n l.if null l then n else c (head l) (foldr c n (tail l))
11:57:58 <Darius> And head and tail are special.
11:58:02 <ski> null ?
11:58:17 <phubuh_> _ == []
11:58:26 <ski> @get-definition null
11:58:28 <lambdabot> null not defined
11:58:31 <Darius> that was the other one, that is too.
11:58:37 <phubuh_> @eval [null [], null [1]]
11:58:39 <lambdabot> [True, False]
11:58:39 <ski> ok
11:59:08 <phubuh_> @define myNull \x. x == []
11:59:10 <lambdabot> myNull defined
11:59:28 <phubuh_> @eval [myNull [], myNull [1]]
11:59:30 <lambdabot> [True, False]
12:00:22 <Darius> @define head "DDR!"
12:00:22 <lambdabot> head defined
12:00:33 <phubuh_> @eval head [1, 2]
12:00:35 <lambdabot> 1
12:00:39 <Darius> @eval head [1,2,4]
12:00:40 <lambdabot> 1
12:01:04 <phubuh_> @del-definition myNull
12:01:06 <lambdabot> not enough privileges
12:01:10 <phubuh_> i figured :-)
12:01:25 <phubuh_> is myNull equivalent to null?
12:01:31 <Darius> You could hack lambdabot and change the BotConfig.
12:01:56 <Darius> phubuh_: Yes, it wouldn't be in Haskell though, for a somewhat subtle reason.
12:02:09 <Darius> @del-definition head
12:02:10 <lambdabot> head removed
12:02:15 <Darius> @del-definition myNull
12:02:17 <lambdabot> myNull removed
12:02:47 <ski> @define factors \n.if n == 0 then from 0 else filter (\d.d `divides` n) (fromTo 1 (sqrt n + 1) `app` [n])
12:02:49 <lambdabot> factors defined
12:02:53 <phubuh_> what's that reason?
12:02:56 <ski> @get-definition app
12:02:58 <lambdabot> app not defined
12:03:03 <Darius> @type null
12:03:04 <lambdabot> null :: [a] -> Bool
12:03:11 <Darius> @type \x -> x == []
12:03:11 <lambdabot> \x -> x == [] :: Eq a => [a] -> Bool
12:03:17 <phubuh_> ah, of course.
12:03:27 <Darius> @type null [id]
12:03:29 <lambdabot> null [id] :: Bool
12:03:37 <Darius> @type [] == [id]
12:04:43 <ski> @define app flip (foldr (:))
12:04:44 <lambdabot> (line 1, column 15):
12:04:44 <lambdabot> unexpected ":"
12:04:44 <lambdabot> expecting simple term
12:05:10 <ski> @define app flip (foldr (\x xs.x:xs))
12:05:12 <lambdabot> app defined
12:05:20 <ski> @eval app [1,2,3] [4,5,6]
12:05:20 <lambdabot> [1, 2, 3, 4, 5, 6]
12:05:42 <ski> @eval factors 2047
12:05:43 <lambdabot> [1, 23, 2047]
12:05:52 <ski> hmm
12:05:58 <ski> this is not correct
12:06:08 <ski> of course
12:07:08 <ski> @define factors \n.if n == 0 then from 0 else filter (\d.d `divides` n) (fromTo 1 n)
12:07:09 <lambdabot> factors defined
12:07:21 <ski> @eval factors 2047
12:07:45 <lambdabot> [1, 23, 89, 2047]
12:11:30 <Darius> @dump
12:11:31 <lambdabot> dumped
12:11:41 <ski> whatis @dump ?
12:11:59 <Darius> It dumps the definitions to a file.
12:27:57 * Igloo bounces
12:29:01 <phubuh_> is the function somewhere in the standard library that can turn "foo,bar,baz" ',' into ["foo", "bar", "baz"]?
12:29:32 <phubuh_> it's trivial to define, but i don't want to waste effort or names :-)
12:30:15 <Igloo> Not exactly. It might be an unfold though
12:30:35 * Igloo thinks and decides it probably won't be a particularly nice one
12:35:50 <phubuh_> @prelude words
12:35:51 <lambdabot> *** "words" prelude "Haskell Standard Prelude Dictionary": text follows
12:35:51 <lambdabot> words
12:35:51 <lambdabot>   words ::  String -> [String]
12:35:51 <lambdabot>   words s    = case dropWhile isSpace s of
12:35:52 <lambdabot>   		  "" -> []
12:36:02 <lambdabot>   		  s' -> w : words s''
12:36:02 <lambdabot>   			where (w,s'') = break isSpace s'
12:36:21 <phubuh_> words and lines should use a generic splitWhen or such
12:53:17 <ski> hmm, unix (nfs) question : how to remove .nfs82E3 files ?
12:54:12 <ski> a new one is generated every time i rm it
12:54:38 <Smerdyakov> Don't give the nfs daemon permission to write it. ;D
12:54:55 <ski> how
12:55:03 <ski> must i be root ?
12:55:25 <ski> perhaps the file should be removed by some cleanup-tool
12:55:30 <Smerdyakov> I don't know. I'm just speculating. Maybe the nfs daemon runs as root itself.
12:55:31 <ski> fsck ???
12:55:51 <Smerdyakov> Why are you worried about an extra dotfile?
12:56:37 <ski> it got generated when i removed a file which, i guess wasn't properly closed/created or something, i suppose
12:57:32 <ski> so perhaps the file marks some bad sector on the hard disk or something..
13:06:19 <Igloo> I'm fairly sure it's normal and would advise against touching it if you don't know what you're doing. If it's 0 size it might just be something to indicate the FS has changed or something.
13:07:21 <ski> i usually don't get these kind of things if i haven't done something stupid
13:07:49 <ski> like trying to rename or delete a file before it is totally created
14:01:24 <Binkley> rob x-men
14:01:26 <Binkley> oops
15:52:11 <lektu> Somebody 'round here to answer a newbie question about monads?
15:57:00 <Xcalibor> mm...
15:57:33 <lektu> Is that a "yes"? :-)
15:58:02 <Xcalibor> i am a newbie myself...
15:58:08 <Xcalibor> but let's give it a try :)
15:58:50 <lektu> Basically, I'm trying to understand what's the intent of the monadic laws.
15:58:56 <lektu> Let me explain.
15:59:31 <lektu> I'm trying to define (for no useful purpose, other than learning) a monad which "counts" the number of times an operation is done over the monad.
15:59:33 <lektu> For example:
15:59:44 <lektu> data Count a = C Int a
15:59:51 <lektu> instance Monad (Count) where
16:00:00 <lektu> return a = C 1 a
16:00:25 <lektu> C n a >>= f = let (C n' a') = f a in C (n+n') a'
16:01:02 <lektu> so "return 'x'" whould return (C 1 'x') (of type Count Char)
16:01:09 <ibid> i would not try to make a monad out of anything that isn't internally represented by a function
16:01:17 <lektu> Why?
16:01:28 <ibid> just a practical observation, no theory behind it :)
16:01:29 <lektu> Maybe is a function?
16:01:36 <ibid> it hasn't worked for me:)
16:01:40 <lektu> I mean, "Maybe"
16:01:40 <ibid> good point
16:01:47 <ibid> [a], too
16:02:03 <lektu> The fact is, the monad I'm defining seems to work...
16:02:04 <Xcalibor> Maybe is not a function... :)  let's try to follow your Count example...
16:02:18 <ibid> Xcalibor: i know it isn't
16:02:29 <Xcalibor> ibid: i knew you knew :)
16:02:35 <ibid> Xcalibor: so why say it?:)
16:02:57 <lektu> but reading the monadic laws, the first one says: (return x) >>= f == f x
16:03:01 <Xcalibor> it's late and I have a cold... I'm in extrospective mode :)
16:03:22 <ibid> :)
16:03:50 <ibid> lektu: how do you define fail for Count?
16:03:51 <lektu> Well, the fact is, for a mathematical (or structural) meaning of "==", obviously f x and (return x) >>= f are not going to be equal.
16:04:08 <Xcalibor> lektu: okay, let's see... (return x) => (C 1 x)
16:04:18 <lektu> It's not important, I think. The default is enough.
16:04:23 <ibid> the only meaning that matters is the meaning your Eq instance gives it
16:04:38 <lektu> *That's* precisely the question I was going to ask!!
16:05:11 <ibid> lektu: fail is important for me in order to visualise your type
16:05:11 <lektu> Is "mathematical" (or structural) == which the monad should satify, or can I simply do:
16:05:22 <lektu> instance Eq a => Eq (Count a) where
16:05:34 <lektu> C _ x == C _ y = x == y
16:05:35 <Xcalibor> so... (C 1 x ) >>= f = let (C n' a') = f a in C (1+n') a'
16:06:09 <Xcalibor> souldn't return a = C 0 a ?
16:06:15 <lektu> (ibid: fail _ = C 0 undefined, for example)
16:06:20 <Xcalibor> 0 is the neutral element of the (+) function
16:06:58 <lektu> But fail cannot return C 0 a, because a it's not necesarily [Char]
16:07:12 <ibid> lektu: all that matters is that your type is coherent and relevant to what you want it to do, ie. *if* you define (==), it has to be an equivalence relation and if you make it a Monad, the monad laws should be satisfied wrt *that* (==)
16:07:23 <ibid> imo
16:07:55 <lektu> Yeah, that's what I thought, but reading about the monadic laws and do notation, the tutorial says that satisfying the laws is important for the do notation to work.
16:07:59 <Xcalibor> mmm... i'm confused
16:08:10 <lektu> (Xcalibor) Why?
16:08:30 <Xcalibor> return should be return a = C 0 a
16:08:47 <Xcalibor> because C 1 a would be adding one to the current count, wouldn't it?
16:09:06 <ibid> lektu: sorry, you misdirected me by writing == instead of = ;) i believe leibniz's test is what is required
16:09:10 <Lor> I think the "=" in monad laws means full substitutability.
16:09:15 <ibid> exactly
16:09:16 <Xcalibor> (C n a) = f = let (C n' a') = f a in C (n+n') a'
16:09:38 <ibid> Lor: he used ==, so i was misdirected; i just checked the report
16:09:46 <lektu> (Xcalibor) Well, is not really important, it depends on what you want to do with the monad. C 0 a or C 1 a are both valid.
16:09:48 <Xcalibor> n+n' = n' iif n = 0
16:09:53 <Lor> It's a good idea for == to be an extensional equality as well.
16:10:03 <Xcalibor> lektu: ah... ah, okay then
16:10:22 <lektu> (ibid): Sorry, I was reading the monad tutorial ("All About Monads, version 1.02"), and it says:
16:10:23 <ibid> Lor: extensional equality makes sense only for sets :)
16:10:31 <Xcalibor> but C 0 a would yield f x for the monadic law
16:10:34 <ibid> Lor: and setlike things
16:10:36 <lektu>  "1.- (return x) >>= f == f x
16:10:47 <Lor> I mean that if a = b then f a = f b for any f that only uses public interfaces.
16:11:10 <Lor> ibid, what would be a non-setlike thing, then?
16:11:28 <Xcalibor> Lor: thatt protptertty has a name... homotecy?
16:12:02 <ibid> Lor: yeah, but that defines function equality :) a = b => f a = f b is guaranteed by leibniz equality
16:12:03 <lektu> (XCalibor): The tutorial says: "the first law requires that return is a left-identity with respect to >>="
16:12:13 <ibid> Xcalibor: extensionality
16:12:20 <Xcalibor> mmm...
16:13:03 <lektu> (Lor): You said "the '=' in monad laws means full substitutability"
16:13:18 <ibid> i should go to bed
16:13:22 <Xcalibor> (return x) => (C 0 x) = f = let (C n' y) = f x in C (n') y
16:13:48 <Xcalibor> qed.
16:13:56 <lektu> (Lor): How to define the substitutability? For me, if I define a == for the monad, C 1 'a' and C 2 'a' are equivalent.
16:14:03 <Xcalibor> however return a = C 1 a  doesn't give this
16:14:33 <ibid> Lor: a non-setlike thing? numbers, i'd say, though they can be encoded as sets
16:14:35 <Xcalibor> the count is irrelevant with respect to the counted thing?
16:14:47 <Lor> If they cannot be distinguished by only using public interfaces, then I'd say it's ok.
16:15:06 <lektu> (Xcalibor): It does not have to be a count, that's just an example. It could be the length, or any kind of state.
16:15:27 <Lor> Ie you can have multiple internal representations for structures which are meant to denote the same "thing".
16:15:32 <Xcalibor> lektu: ah... oh... then i don't uderstand how that law is to be satisfied :-P
16:15:52 <lektu> (Lor): Ok, then
16:15:59 <Xcalibor> Lor: 1,2,3,1,1,2 is not a set
16:16:20 <ibid> Lor: yeah, that's equality through isomophism :)
16:16:44 <lektu> (Xcalibor): But the problem can happen on any monad that accumulates some kind of state, can't it?
16:16:46 <Xcalibor> the abstract agrupation of the numbers <1,2,3,2,4,1,1,5,2> is not a set (because there's no unicity)
16:17:15 <ibid> unicity? agrupation?
16:17:18 <Xcalibor> lektu: mmm... i woulda ccumulate state through closures, not by using monads... but that's me
16:17:19 <lektu> (Lor): yes, I could potentially have multiple internal representations.
16:17:38 <Xcalibor> ibid: a Set is an aggregation of unique elements
16:17:39 <lektu> (Xcalibor): Hey, I wouldn't accumulate state yet, I'm just learning this stuff :-)
16:18:17 <ibid> Xcalibor: that's one characterization. so?
16:18:24 <Xcalibor> ibid: thus <1,2,3> is a Set but <1,2,1,3> is not (it's just an account of numbers, a general aggregation)
16:18:25 <ibid> (not entirely accurate)
16:18:42 <ibid> Xcalibor: actually, it does not work that way
16:18:55 <Xcalibor> ibid: i'm not getting into full algebra... i was simply giving not-set examples to lor
16:19:10 <ibid> Xcalibor: in standard mathematical notation, {1,2,3} and {1,2,1,3} are both sets
16:19:13 <ibid> it's not algebra :)
16:19:22 <ibid> Xcalibor: and it was not a valid example
16:19:22 <Xcalibor> set theory is algebra
16:19:26 <ibid> no it's not
16:19:44 <ibid> (well, you can do set theory as algebra, but set theory is more fundamental)
16:19:57 <Xcalibor> i was tryting to avoid the {}'s precisely because 1,2,1,3 is not a proper set...
16:20:07 <Xcalibor> okay, you are right
16:20:12 <ibid> Xcalibor: you are defining your terms funny
16:20:19 <Xcalibor> they are both sets
16:20:35 <Xcalibor> (my sets theory is sooooo far away, damn)
16:20:45 <ibid> Xcalibor: the important property of a set is that you cannot *distinguish* sets based on how many times an element is in there
16:21:27 <Xcalibor> ibid: you can define an is_element_of operation, but not a how_many_times()
16:21:30 <Xcalibor> right?
16:21:32 <Lor> "1,2,1,3" is just a meaningless string until you have a theory explaining what it means.
16:21:47 <ibid> Xcalibor: yes you can, it'll just return 0 or 1 :)
16:22:02 <ibid> (1 denoting nonzero)
16:22:13 <Xcalibor> Lor: of course... let's define the english language so we can have proper communication in the first place, and then let's develop a full theory of ascii representation of maths :-P
16:22:13 <ibid> what Lor said :)
16:22:25 <lektu> (In spanish terms, I don't know in English, that would be called the "characteristic function" of the set.
16:22:43 <ibid> lektu: true
16:22:45 <lektu> (If I'm not misremembering my maths clases of quite a few years ago...)
16:22:49 <Xcalibor> ibid: ie. it belongs in or doesn't belong in the set (is_element-of())
16:22:55 <ibid> Xcalibor: yes
16:23:08 <Xcalibor> lektu: you spanish?
16:23:18 <lektu> Yeah. Currently in Madrid.
16:23:22 * Xcalibor too :-)
16:23:28 <ibid> but i'm off to bed. damn, another night of only 4 hours of sleep
16:23:34 <ibid> see you all :)
16:23:42 <Xcalibor> ibid: good night!
16:23:47 <lektu> (Xcalibor) Then why are we talkin' in English? :-) (just joking)
16:23:49 <Lor> typically, {a,b...z} is shorthand for the set s with the property: q \in s <-> q = a \/ q = b \/ ... \/ q = z
16:23:50 <lektu> Good night
16:24:11 <ibid> (mm, btw, don't let me get started on set theory, my msc thesis contained a lot of it:)
16:24:19 <ibid> msc dissertation, sorry
16:24:25 <Xcalibor> ibid: poor you ;-)
16:24:30 <ibid> poor?
16:24:32 <ibid> it's fun :)
16:24:40 * Xcalibor maths are a bit crazy
16:24:41 <Xcalibor> :-)
16:24:52 <Xcalibor> my phd work was on magnetic properties
16:25:04 <ibid> physics?
16:25:07 <Xcalibor> and my dissertation wuld have used lot¡s of hamitonians
16:25:08 <Xcalibor> yup
16:25:10 <lektu> I've never been good in maths, but I remember algebra and set theory as being some of the most mind-exciting things I've ever learnt.
16:25:12 <Lor> Note that it's quite okay to have a property q = 1 \/ q = 2 \/ q = 1 \/ q = 3
16:25:31 <Xcalibor> spaces and all that, if I had actually finished it... but still it was just atomes and particles doing stuff :-)
16:25:33 <lektu> (Quite the same feeling that reading a paper about surreal numbers)
16:26:33 <ibid> one definition that i saw for { ... } was nice: { e } = { x : x = e }, x nonfree in e; { l, e } = { l } u { e }
16:27:09 <ibid> ({ x : p } being defined through axiom of separation)
16:27:11 <Lor> Uh. Comprehensions are hardly a simplification.
16:27:20 <ibid> comprehensions are primitive
16:27:48 <ibid> a comprehension is just a name for the set postulated by the axiom of separation
16:27:56 <ibid> (as you can see, i'm still here. argh)
16:28:31 <Lor> Axiom of separation? Is that the same thing as "axiom of comprehension" or "axiom of subsets"?
16:29:07 <ibid> axiom of separation is a weak form of axiom of comprehension
16:29:18 <ibid> i don't think i've heard the term "axiom of subsets"
16:29:21 <Lor> Apparently. Lord, I hate it that in no two places is ZFC presented in exactly the same way with the same names for axioms.
16:29:29 <ibid> :)
16:29:53 <Lor> Sometimes the empty set is dismissed (as trivial?). Sometimes comprehension/separation is omitted...
16:30:05 * Smerdyakov spits on ZFC. ;)
16:30:13 <Lor> Foundation/regularity is presented in many ways...
16:30:44 <ibid> the axiom schema of comprehension is \exists x : p(x)
16:31:06 <Lor> http://mathworld.wolfram.com/AxiomofSubsets.html
16:31:09 <ibid> (p is obviously a metavariable for formulae)
16:31:28 <ibid> ähh
16:31:29 <Lor> ibid, that leads to russell's paradox.
16:31:43 <Lor> That's why you always have to do the comprehension inside some already existing set.
16:31:48 <ibid> the axiom schema of comprehension is \exists x : \forall y : y in x <-> p
16:31:51 * Xcalibor is not being in here soon :-)
16:31:52 <ibid> Lor: obviously
16:32:35 <ibid> the axiom schema of separation is \exists x : \forall y : y in s --> (y in x <-> p)
16:33:16 <ibid> Lor: actually, the axiom schema of comprehension is valid in theories that distinguish sets from classes
16:33:24 <Smerdyakov> Lor, can you tell me why you personally would choose to use ZFC instead of type theory?
16:33:39 <Lor> "use"? For what?
16:33:54 <Smerdyakov> Well, presumably you're discussing it because you intend to use it somewhere.
16:34:00 <Smerdyakov> AKA, take it as the foundation of math.
16:34:35 <ibid> Lor: my terminology is from jech
16:34:44 <Lor> Well, I want to learn math, and to my knowledge, ZFC is what the math we are commonly taught is based on.
16:35:17 <Lor> Personally, I prefer more constructive approaches whenever possible, but I do want to understand what it is that mathematicians in general deal with.
16:35:22 <ibid> Lor: most math is based on naive set theory
16:35:52 <Smerdyakov> Lor, do you have an example of any part of math except set theory that is formalized in ZFC but can't be in type theory?
16:35:53 <Lor> ...and is thus inconsistent?
16:35:56 <ibid> i don't think i was ever shown any set axioms besides choice in my math studies
16:36:02 <ibid> Lor: and is thus informal
16:36:33 <ibid> Smerdyakov: type theory (hol) can encode set theory, yes?
16:36:36 <Lor> Mathematicians aren't commonly very interested in foundations, true.
16:37:12 <Smerdyakov> ibid, I don't think so.
16:37:25 <Smerdyakov> ibid, I believe it is strictly weaker.
16:37:28 <Lor> Smerdyakov, I don't really understand what you mean. It's of course trivial to represent the axioms of zfc in a properly typed system. I just wrote them down in Coq today.
16:37:32 <ibid> Lor: even metamathematicians are sloppier than real formalists :) - they are formal wrt their object language but their metalanguage is most often just a restricted version of 'math common'
16:37:51 <ibid> Smerdyakov: in what sense? i have seen an encoding of sets in type theory
16:38:13 <Smerdyakov> ibid, beats me. Someone with a PhD in math who works in logic said it. I think I might have learned it in a past class.
16:38:14 * Smerdyakov thinks.
16:38:25 * Lor doesn't understand what this discussion is about.
16:38:37 <ibid> Smerdyakov: set theory is actually the weaker one, it emulated higher-order predicates by calling them sets
16:38:46 <Smerdyakov> Lor, about the reason you want to learn ZFC.
16:38:46 <Lor> The classical view on mathematics postulates the existence of certain objects with certain properties, and everything is then derived on that.
16:39:01 <ibid> that's not very classical :)
16:39:07 <ibid> not even 100 years old
16:39:17 <ibid> but it's the standard approach
16:39:18 <Lor> It's called classical, as opposed to intuitionistic.
16:39:34 <Lor> Well, let's say platonist, then.
16:40:04 <ibid> hmm, i've read some of the period texts, and i don't remember them being called 'classical', more like 'formalist' or something :)
16:40:10 <ibid> i should reread them
16:40:12 <Lor> Anyway, zfc is just a formalization of the things which we think it's sensible to postulate.
16:40:35 <Smerdyakov> Lor, so is type theory. Why choose ZFC?
16:40:52 <Lor> It's a three-way division: platonism, intuitionism, formalism.
16:41:39 <ibid> i also think of three-way division, but for me, the third one has no name, i just associate it with russell
16:41:50 <Lor> Smerdyakov, because it's part of the mathematical culture.
16:41:56 <ibid> formalism is the established one in my experience
16:42:32 <Lor> I have to understand what zfc is before I'm qualified to criticize it.
16:43:04 <Smerdyakov> Lor, OK. It has more axioms than the typed higher order logic formulation I learned.
16:43:28 <ibid> Smerdyakov: zfc is older than church's simple theory of types
16:43:35 <ibid> Smerdyakov: that may be a factor
16:44:02 <Smerdyakov> It shouldn't be a factor to professionals choosing the best tools to do what they do.
16:44:03 <ibid> zfc was a reaction to principia, which was a typed system, and a nasty one at that
16:44:04 <Lor> Why do you contrast zfc and type theory all the time? I don't see them having anything to do with each other.
16:44:12 <ibid> Lor: they do
16:44:28 <Smerdyakov> Lor, they're representatives of the two main approaches to formalizing math today.
16:44:30 <Lor> ZFC is a _theory_ in a particular system (first-order logic). Type theory is a different _logic_.
16:44:55 <ibid> Lor: they have similar aims
16:44:59 <Smerdyakov> Type theory is an empty _theory_ is a particular logic.
16:45:06 <ibid> Lor: that is, to formalize a theory of aggregates
16:45:30 <Smerdyakov> Either fits the formal definition of a theory and can be taken as the starting point for formalizing everything that arises naturally in math.
16:46:26 * ibid goes, really, this time, bbl and good night all :
16:46:27 <ibid> )
16:46:36 <Lor> What's the type theoretical formalization of natural numbers?
16:46:51 <Xcalibor> okay, time for bed (really now)
16:46:53 <Xcalibor> laters!
16:46:54 <Smerdyakov> One is church numerals
16:47:43 <Lor> And, say, rational numbers?
16:48:23 <Lor> What's the relation between them? Is N naturally a subset of Q?
16:49:24 <clausen> Lor: there are a few different constructions
16:49:30 <Smerdyakov> You're using a set theoretical term where it doesn't make sense.
16:49:45 <Smerdyakov> What you're asking translates into a question of sub_types_, which is not so clear cut.
16:49:48 <clausen> (which means the construction is independent of the properties we like them to have)
16:50:00 <clausen> one is:
16:50:04 <clausen> 0 = empty
16:50:06 <clausen> 1 = {empty}
16:50:10 <clausen> 2 = {{empty}}
16:50:14 <Lor> Yes, I know.
16:50:19 <clausen> ah, ok
16:50:42 <Lor> Usually the ordinal 2 is {{},{{}}}, but nevermind...
16:50:47 <Smerdyakov> clausen, do you mean for that to be in type theory?
16:51:08 <clausen> Smerdyakov: no
16:51:14 * clausen wandering in halfway through
16:51:28 <Smerdyakov> Lor, the natural numbers that we used in the class I took were defined such that n is the set of all sets of individuals with cardinality n, where sets are really predicates.
16:51:58 <clausen> Smerdyakov: that is one construction, but not the only one
16:52:00 <Lor> How do you avoid Russell's paradox?
16:52:16 <Smerdyakov> Lor, that's easy. Don't have comprehension. :)
16:52:30 <Smerdyakov> Lor, everything has to type-check, just like in Haskell!
16:52:48 <Lor> undefined typechecks just fine...
16:53:07 <lektu> Bye. And thanks for the comments.
16:53:16 <Smerdyakov> OK, but it's still valid not to allow it to typecheck.
16:54:06 <Smerdyakov> Type theory looks just like Haskell programs, really.
16:54:15 <Lor> If you don't have comprehension, how can you define those naturals then?
16:54:15 <Smerdyakov> So you should be able to answer any questions you have about it. :)
16:54:25 <Smerdyakov> They're predicates.
16:54:40 <Smerdyakov> They take a set as an argument and check that it has the right cardinality, returning true or false depending.
16:55:02 <Lor> "type theory" is a bit vague. Which system are you talking about?
16:55:48 <Smerdyakov> Church-style typed lambda calculus
16:55:57 <Lor> Typed how?
16:56:26 <Smerdyakov> A boolean type, a type of individuals, and function spaces built up from these.
16:57:02 <Lor> Just simply typed?
16:57:10 <Lor> Any polymorphism, dependent types, what?
16:57:13 <Smerdyakov> I guess, if that's what I just described. :)
16:57:30 <Smerdyakov> No dependent types
16:57:33 <Lor> You can't even type church numerals with simply typed LC.
16:57:56 <Lor> Except for a single hard-coded return type..
16:58:02 <Smerdyakov> That's OK!
16:58:29 <Smerdyakov> Obviously you can extend it with those features, but I don't think it's necessary for formalizing math.
16:58:50 <Lor> Is the equational theory then somehow based on reduction?
16:59:57 <Smerdyakov> Mostly
17:00:17 <Lor> That's just weird.
17:00:24 <Lor> What does math have to do with computation?
17:00:47 <Smerdyakov> What does math have to do with large cardinals? :P
17:00:58 <Lor> More. :)
17:01:09 <Smerdyakov> Nope, because people use computation to solve math problems.
17:01:11 <Binkley> What's that got to do with the price of onions?
17:02:51 <Lor> How would your system represent Chaitin's Omega?
17:04:00 <Lor> Agh, three a.m. Maybe I'll yield to sleep.
17:04:03 <Smerdyakov> This is the probability of a randomly chosen program halting or something like that?
17:04:04 <Lor> Night, folks.
17:04:40 <Smerdyakov> If so, then the same way it would represent any real number..
18:19:37 <Smerdyakov> Would anyone like to recommend a work of fiction for me to check out of the library?
18:20:10 <Riastradh> _The Picture of Dorian Grey_
18:20:36 <Riastradh> ...or is it Gray?  I can never remember whether to use 'a' or 'e' in that title.
18:22:33 <Smerdyakov> Amazon.com tells me that the "reading level" of that book is "young adult."
18:22:36 <Smerdyakov> I take that as a bad sign.
18:23:23 <Riastradh> amazon.com is a dork.
18:23:54 <Riastradh> Anyone who trusts it for anything more than to look up a book's ISBN number or author or other specific fact about a book is a dork as well.
18:25:12 <Smerdyakov> People who use the word "dork" are dorks.
18:25:58 <Riastradh> No they aren't, you dork.
18:26:06 <Riastradh> Dork dork dork dork dork dork!
18:26:27 <Binkley> "Hard Laughter", Anne Lamott
18:28:36 <arguile> Smerdyakov: You point was proven for you.
18:28:45 <arguile> s/You/Your/;
18:30:58 <arguile> However, "The Picture of Dorian Gray" (correct spelling) by Oscar Wilde is hardly a 'young adult novel' in the sense you seem to be assigning to it :)
18:31:40 <Smerdyakov> My experience with Oscar Wilde so far is just through "The Importance of Being Earnest," which I found rather shallow.
18:34:32 <Riastradh> _The Importance of Being Earnest_ is his silliest work.
18:34:50 <Smerdyakov> Does he write about crazy people?
18:34:57 <Riastradh> _The Picture of Dorian Gray_ isn't very silly at all.
18:35:50 <Smerdyakov> Answer question!
18:36:11 <Riastradh> Yes, of course he writes about crazy people, because he writes aboutt the English.
18:36:27 <Riastradh> About, even.
18:36:33 <Smerdyakov> That doesn't make any sense.
18:36:50 <Riastradh> Nor did a lot of the people in his plays.
18:44:50 <arguile> I love the sarcasm of _Earnest_, taking the most frivolous and shallow and making it of the utmost importance
21:16:13 --- mode: capek.freenode.net set +b *!23kjhkjf@*
22:05:36 <prologic> boo :)
