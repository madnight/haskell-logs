03:54:54 <prologic> you can't pattern match against complex lexical structures as CamelCase can you ?
03:57:09 <Lor> What is CamelCase?
03:57:17 <Lor> But if you mean regular expressions, then no, not directly.
03:57:32 <Lor> (Actually, I'm just working on a scheme macro thingy to allow just that.)
03:57:45 <prologic> lol really
03:57:48 <prologic> good on ya :)
03:57:53 <prologic> I'm just playing with wiwiwi
03:57:58 <prologic> I'm obsessed with wiki :P
03:58:13 <prologic> I added horizontal rules to it, cause I like them :)
03:58:17 <prologic> ----
04:07:30 <shapr> hi keir, ltns
04:25:57 <shapr> prologic: did you commit the hrule-wiwiwi changes to hlibs?
04:26:16 <prologic> no :)
04:26:18 <prologic> you want me to ?
04:26:39 <shapr> sure
04:30:46 <shapr> keir: whatcha doin with your life these days?
04:39:36 <prologic> shapr, how exactly do I commit the changes to the hlibs neway ? :)
05:06:23 <zaragata> hey there how would you generate this list? : [[0,0,0],[1,0,0],[0,1,0],[1,1,0],[0,0,1],[1,0,1],[0,1,1],[1,1,1]]
05:08:21 <zaragata> I came up with this approach, but am shure there must be a better alternative: transpose $ map (take 8) $ map cycle $ take 3 (iterate (\x->concat [[c,c]|c<-x]) [0,1])
05:13:24 <prologic> you're building up binary numbers right ?
05:13:25 <d33p> um, thats the binary representation of the first 2^n integers, where n is 3 here
05:13:33 <prologic> yeh
05:13:34 <prologic> it is
05:15:09 <d33p> so write a function to return the binary rep of an integer n as a list of ints, and simply do a  map over [1 .. n]
05:15:27 <d33p> bbl
05:20:00 <zaragata> na, 
05:20:36 <zaragata> know it is, but i was looking up for something concise, and elegant (but no simple) :-D
05:21:01 <prologic> there isn't
05:21:07 <prologic> I don't think anyone has written a binary function :)
05:21:13 <prologic> I'm having a go at it now though
05:21:13 <zaragata> :-( 
05:21:50 <zaragata> my solution is decently complicated, but not enough.
05:22:20 <prologic> lol
05:22:59 <zaragata> I will not stop untill all the prelude is used! 
05:24:30 <prologic> lol
05:26:39 <prologic> Main> binary 126
05:26:40 <prologic> [1,1,1,1,1,1,0]
05:26:42 <prologic> there ya go :)
05:26:43 <prologic> it works
05:27:25 <prologic> Main> map binary [1..8]
05:27:26 <prologic> [[1],[1,0],[1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1],[1,0,0,0]]
05:27:47 <zaragata> actually, map binary [0..7]
05:28:04 <prologic> Main> map binary [0..7]
05:28:04 <prologic> [[0],[0,1],[0,1,0],[0,1,1],[0,1,0,0],[0,1,0,1],[0,1,1,0],[0,1,1,1]]
05:28:06 <prologic> there :)
05:28:07 <prologic> happy :P
05:28:12 <zaragata> but no, that is clear and obvious! you got it wrong.
05:28:38 <prologic> I got it wrong ?
05:28:42 * prologic rubs his eyes
05:29:31 <zaragata> the solution is supposed to ilustrate the programmers superior intellect, not solve the problem
05:29:42 <prologic> eeesh
05:29:46 <zaragata> lol
05:29:46 <prologic> I thought I stuffed up somewhere ;)
05:30:10 <zaragata> actually, you're solution has a problem
05:30:18 <prologic> it does ?
05:30:22 <prologic> that'd be right :(
05:30:25 <zaragata> the lists should all have length = 3
05:30:30 <prologic> oh
05:30:37 <prologic> that's not really a problem :P
05:31:19 <prologic> I dunno how I'd pad the lists without ruining the simplicity of the function :)
05:31:42 <zaragata> yep, that's a problem.
05:32:12 <zaragata> ...and that's why my solution wins
05:32:15 <prologic> why must it be padded in with 0's at the front ?
05:32:20 <prologic> my calculator doesn't do it :P
05:32:38 <zaragata> it's part of a bigger problem. let me get the link
05:32:55 <prologic> oh no you don't :) I'm a student myself lol
05:32:57 <zaragata> http://acm.uva.es/p/v100/10001.html
05:33:32 <zaragata> this an ACM contest problem I am solving
05:33:42 <prologic> oh so I see
05:33:50 <prologic> I competed in the local competition not long ago
05:33:51 <prologic> twas fun :)
05:34:04 <blackdog> so, now we need a monadic solution.:)
05:34:11 <zaragata> lol
05:34:25 <prologic> monadic ?
05:34:28 <prologic> using monads
05:34:38 <zaragata> it's a pity that ACM doesn't accept other languages
05:34:44 <zaragata> (like haskell)
05:34:48 <prologic> yeh
05:34:51 <prologic> it is a pity
05:34:59 <zaragata> (obviouslly)
05:35:04 <prologic> I'd have so much fun doing the problems in haskell :)
05:35:34 <zaragata> actually, some of them are harder to solve in haskell, I think
05:35:48 <blackdog> Can you use perl?
05:36:02 <prologic> no
05:36:09 <prologic> problems have to be solved with programming languages
05:36:19 <prologic> and the only ones they have are imperitive ones atm
05:36:30 <prologic> java, c and something else I forge t:)
05:36:33 <blackdog> ...and perl is what?
05:36:37 <zaragata> c++.
05:36:54 <prologic> ihmo I consider perl more a scripting language :)
05:37:02 <prologic> but don't listen to me :P
05:37:05 <blackdog> oh, gotcha. the A in ACM stands for assembler, right?
05:37:07 <zaragata> you mean interpreted...
05:37:14 <prologic> yeh
05:37:14 <zaragata> nop
05:37:16 <prologic> interpreted
05:37:39 <blackdog> I'm just kidding. Cheap potshots at portable assemblers like C and C++... :)
05:38:00 <prologic> assemblers blah :)
05:38:05 * prologic spits at C/C++
05:38:33 <prologic> even with real assembly you can't do many of the horrible things you can do in C :)
05:38:51 <blackdog> i tend to find haskell's pretty good for getting a correct prototype done, even if the eventual goal is a program in a lower-level language.
05:39:05 <prologic> indeed :)
05:39:40 <prologic> hrmm I wonder if I should now write functions to add binary numbers together :)
05:40:55 <zaragata> blackdog: that's exaclty how I am solving this problem
05:43:48 <prologic> hrmm
05:43:56 <zaragata> prologic: send us your binary function
05:43:57 <prologic> how do you pattern match against the back of the list ?
05:44:13 <prologic> (a:as) will match at least 1 element, and the rest of the list
05:44:21 <prologic> need to do it in reverse for binary numbers :)
05:44:41 <prologic> binary :: Integral a => a -> [a]
05:44:41 <prologic> binary n = binary' n []
05:44:41 <prologic>    where
05:44:41 <prologic>    binary' 0 ds = 0:ds
05:44:41 <prologic>    binary' d ds = binary' (d `div` 2) (r:ds)
05:44:42 <prologic>       where
05:44:43 <prologic>       r = d `mod` 2
05:44:56 <zaragata> why not use unfoldr?
05:45:07 <prologic> unfoldr
05:45:08 <prologic> hrmm :)
05:45:08 <prologic> ok
05:45:16 <zaragata> binarize :: Int -> [Int]
05:45:16 <zaragata> binarize n = unfoldr f n
05:45:16 <zaragata> where f 0 = Nothing
05:45:16 <zaragata> f n = Just (n `mod` 2,n `div` 2)
05:45:20 <zaragata> oops
05:45:27 <Heffalump> the only way you can pattern match against the back is to use reverse first, or alternatively write a recursive function that works its way to the bottom
05:45:34 <Heffalump> or just use first and last and pattern guards
05:45:41 <Heffalump> s/pattern //
05:45:44 <prologic> ta Heffalump
05:46:27 <prologic> Main> addbin [0,1,0] [0,1]
05:46:27 <prologic> [0,1,1]
05:46:28 <prologic> that works :)
05:46:37 <prologic> now the tricky part, to handle overflows :)
05:47:01 <zaragata> :-)
05:47:04 <prologic> zaragata, I'm not as familar as you are with all the Prelude and List functions yet :)
05:47:54 <zaragata> I decided to get familiar when half my programs were made of my own prelude duplicates
05:48:24 <prologic> fair enough
05:48:39 <prologic> I've only been learning Haskell for a little over 2 months though at uni
05:48:41 <zaragata> I bet you'rs are too... :-P
05:48:52 <prologic> so half the time the names of the functions in the libraries don't make sense to me anyway
05:49:01 <prologic> Haskell being a mathematical orientated language
05:49:26 <prologic> no I slowly replace functions with Prelude and List functions, when I discover them of course
06:05:50 <prologic> hrmm
06:05:54 <prologic> seems to work
06:05:56 <prologic> maybe :)
06:06:01 <zaragata> what?
06:06:08 <prologic> adding two binary numbers :)
06:13:09 <prologic> Main> bin2dec $ addbin (dec2bin 123) (dec2bin 321)
06:13:09 <prologic> 444
06:13:10 <prologic> weeee :)
06:13:11 <prologic> it works
06:22:46 <earthy> me grins
06:23:53 <prologic> weee this is complicated
06:24:01 <prologic> someone wanna take a look ?
06:24:25 <prologic> other than perhaps replacing some code with Prelude or List functions, I think the patterns are overly complex
06:24:31 <prologic> or I could be dreaming ;)
06:24:59 <prologic> http://daisy.ods.org/~prologic/binary.hs
06:26:53 <zaragata> just by the number of lines, i'm sure a lot can be trimmed out...
06:27:15 <prologic> I'm more worried about the patterns :)
06:43:55 <phubuh> addbin a b = bin2dec a + bin2dec b
06:43:55 <phubuh> :-)
06:43:56 <phubuh> err, add a dec2bin to that
06:46:43 <prologic> lol
06:46:44 <prologic> that's cheating :)
06:46:44 <prologic> get out of working out how to take care of the carry :P
06:47:15 <phubuh> i wrote a program in C++ (yuck!) yesterday to add arbitrarily large integers, but it used lists of unsigned ints instead of booleans :)
06:47:33 --- mode: calvino.freenode.net set +b *!23kjhkjf@*
06:47:41 <phubuh> it's supposed to be able to multiply as well, but there's a bug in my bitshift functions, and i'm too lazy to look at it
06:47:59 <d33p> phubuh: why did you use unsigned ints instead of booleans?
06:50:34 <phubuh> they're faster to work with
06:51:06 <d33p> is that an algorithm thing or an architecture thing?
06:51:19 <phubuh> architecture thing
06:51:45 <d33p> ok, thought so
06:52:13 <phubuh> adding unsigned ints is about as fast as adding booleans, but one unsigned int add does the work of eight boolean adds :-)
06:52:51 <d33p> sure that works :)
06:53:26 <phubuh> was that a question? :)
06:53:42 <d33p> nope
06:53:56 <d33p> but it was an answer :)
06:57:13 <prologic> hrmm
06:58:07 <prologic> last year in the christmas holidays I wrote what started out to be a compiler exercise from Crenshaw's tutorials, but turned out to be a math interpeter that can do all sorts of calculations with arbitary precision.
06:58:24 <prologic> it used 4Gb strings to represents real numbers
06:58:41 <prologic> it still works to this day without a bug, except the division algorithm is sooooo slow :(
06:59:24 <d33p> whats the relavance of 4Gb?
06:59:36 <prologic> none
06:59:59 <prologic> was written in pascal, using AnsiString
07:00:07 <d33p> oh
07:00:08 <prologic> which has a limited length of 4Gb
07:00:08 <phubuh> neat!
07:00:12 <prologic> wish I had 4Gb of ram :)
07:00:18 <d33p> hehe
07:00:22 <prologic> yeh it is rather neat
07:00:27 <phubuh> what did you use for multiplication?
07:00:30 <prologic> it has it's own rather crude scripting language
07:00:37 <prologic> lookup table
07:00:43 <prologic> multiplication is actually very fast
07:00:56 <prologic> but alas division is where the program was never as good as I had wished :)
07:01:19 <prologic> I'm not good enough at maths to work out a better algorithm other than to continually subtract the divisor
07:01:22 <d33p> hmm division as in real division?
07:01:29 <d33p> or just a 'div' b
07:01:39 <prologic> no real division
07:01:48 <d33p> ok
07:01:52 <prologic> real division can do integer division anyway
07:01:57 <d33p> yep
07:02:01 <prologic> integer division's speed is instant ;)
07:02:07 <prologic> same speed as multiplication
07:02:16 * d33p nods
07:03:24 <prologic> 2000/2
07:03:28 <prologic> 1000
07:03:28 <prologic> Timing: 139msecs 
07:03:28 <prologic> 200/2
07:03:28 <prologic> 100
07:03:28 <prologic> Timing: 10msecs 
07:03:33 <prologic> just an example of division's poor speed
07:04:00 <prologic> in comparision with multiplication, multiplication is done in constant time, dependant on the number of digits to multiply together
07:06:08 <phubuh> for reasons i don't quite remember, i'm using a multiplication algorithm that's about O(n log 2)
07:06:40 <prologic> I think mine is O n
07:07:02 <phubuh> ... where n is the actual number, not the number of digits in it
07:07:22 <d33p> so its log with number of digits
07:07:24 <prologic> yeh it's dependant on the number of digits
07:08:01 <phubuh> how silly of me! of course, O(n log 2) is proportional to the number of digits in its binary representation
07:08:19 <prologic> I'd expect it do be :)
07:09:50 <prologic> how do you do division in yours phubuh ?
07:09:58 <phubuh> i don'
07:10:00 <phubuh> t
07:10:08 <prologic> haven't gotten that far ?
07:11:04 <phubuh> it's actually an assignment, and it doesn't require division, but i'll probably add it anyway :)
07:11:26 <prologic> well if you do, lemme know
07:11:33 <phubuh> sure thing
07:11:36 <prologic> I really want to redesign my division algorithm
07:11:40 <prologic> ta
07:13:11 <prologic> Abs, Pow, Sigma, Int, Frac, nPr, nCr, PI, e, sin, cos, tan, arcsin, arctan, Mod, SqrRoot, Round, Trunc, Rad, Deg, Shift. just some of the functions mine has ;P
07:13:20 <phubuh> nice!
07:13:47 <d33p> you guys wrote it in C++/pascal ?
07:13:58 <prologic> I wrote mine in pascal yes
07:13:59 <phubuh> C++ here
07:14:03 <d33p> cool
07:14:08 <d33p> iam gonna try it on C :p
07:14:16 <prologic> did it out of sheer boredem :)
07:14:34 <prologic> you guys run linux ?
07:14:41 <phubuh> yup
07:15:14 <prologic> I'll send you a binary copy with example scripts for it if you give me your email address ;)
07:15:26 <phubuh> oh, cool!
07:15:33 <phubuh> phubuh@phubuh.org should work. i hope.
07:19:17 <prologic> enjoy :)
07:19:50 <prologic> hope it runs ok, hehe. type: HELP at the command prompt to get started
07:20:51 <prologic> night all
07:21:09 <d33p> goodnight
07:21:17 <phubuh> night!
07:21:35 <phubuh> it does appear to work :-)
07:22:02 <pl_zzzz> oh good :)
07:22:17 <pl_zzzz> try something like, $pow(2,512)
07:22:29 <pl_zzzz> hope you have a fast machine :)
07:22:37 <phubuh> hee hee
07:23:04 <d33p> mint: error while loading shared libraries: libgpm.so.1: cannot open shared object file: No such file or directory
07:23:18 <pl_zzzz> gpm ?
07:23:21 <pl_zzzz> it doesn't use gpm
07:23:28 <d33p> hehe
07:23:32 <d33p> *shrug*
07:23:33 <pl_zzzz> yikes
07:23:40 <pl_zzzz> install that library then
07:23:44 <pl_zzzz> it isn't anywhere in my sources
07:23:48 <phubuh> maybe your pascal compiler uses it by default, for some reason :)
07:23:54 <pl_zzzz> I'll go complain to the FPC developers in the morning :)
07:23:59 <pl_zzzz> yeah I think it must do
07:24:33 <pl_zzzz> weird, nothing in the compile options
07:24:43 <pl_zzzz> d33p, install libgpm :)
07:24:50 <pl_zzzz> you obviously don't use the mouse in the console :P
07:24:54 <d33p> pl_zzzz: hm.. my distro is broken
07:25:01 <pl_zzzz> lol
07:25:02 <d33p> i'll have to check 
07:25:04 <pl_zzzz> not good :)
07:25:08 <d33p> nope :)
07:25:11 <pl_zzzz> use debian :)
07:25:18 <d33p> i tried upgrading xmms, and it wanted to rebuild xfree amongst other things
07:25:20 <d33p> :-|
07:25:31 <pl_zzzz> heh
07:26:19 <pl_zzzz> phubuh, all working good for you ? your machine is the 3rd it's run on now, email me specs when you can mint@daisy.ods.org
07:27:12 <phubuh> will do
07:27:17 <pl_zzzz> night again :)
07:27:21 <phubuh> night
08:45:42 --- mode: jordan.freenode.net set +b *!23kjhkjf@*
12:16:55 <keir> shapr, working on 3rd year of comp eng at u of toronto
12:18:23 <keir> if you have a function with a pattern-matched paramater (ie, rmlast x:xs), why can't you use guards to specify the rest?
12:18:47 <Riastradh> What do you mean 'to specify the rest?'
12:18:48 <keir> i've noticed that all 'guarded' examples are of the form fn x y z | x<y 1 ...
12:19:07 <keir> never fn x:xs | x<0   0
12:19:16 <keir> |x>0 x:x:xs
12:19:16 <keir> etc
12:19:35 <keir> ie, pattern matched argument along with a guard
12:19:43 <Heffalump> you can do that
12:19:48 <keir> it's entirely possible i've just done something stupid with my code
12:20:08 <Heffalump> f (x:xs) | x>0 = x
12:20:11 <Heffalump> f _ = 0
12:20:13 <Heffalump> for example
12:20:18 <keir> oh, so you need the parens
12:20:24 <Heffalump> you always need them
12:20:35 <keir> oh! ok thanks
12:20:39 <Heffalump> f x:xs parses as (f x):xs
12:20:57 <Heffalump> space binds tighter than any other operator
12:21:26 <keir> ah!
12:21:32 <keir> excellent. i am enlightened.
12:21:48 <keir> i'm new to this whole haskell thing if you hadn't noticed 
12:24:38 <keir> what's the equivalent of 'else' in guarded expressions? ie |else = 42
12:24:46 <Heffalump> | otherwise
12:24:51 <keir> ok
12:25:17 <Heffalump> (actually the guards are just Boolean expressions which are matched in order, so | otherwise is just syntactic sugar for | True)
12:25:38 <Heffalump> so make sure you do put it at the bottom of the list of guards :-)
12:26:30 <keir> i figured as much
12:26:34 <Igloo> It's not syntactic sugar, otherwise is a function (or value if you prefer)
12:26:36 <phubuh> it isn't even that -- otherwise is just a preludian variable defined as otherwise :: Bool = true
12:26:49 <phubuh> @prelude otherwise
12:26:54 <Heffalump> oh, ok
12:26:57 <lambdabot> *** "otherwise" prelude "Haskell Standard Prelude Dictionary": text follows
12:26:57 <lambdabot> otherwise
12:26:57 <lambdabot>   otherwise ::  Bool
12:26:57 <lambdabot>   otherwise    = True
12:30:35 <keir> is x' a valid variable name?
12:30:41 <Riastradh> Yes.
12:30:45 <keir> sweeT!
12:31:32 <Heffalump> couldn't live without it :-)
12:32:40 <keir> is there an empty? operator in haskell like in scheme? (or rather, null? and (null? []) --> true
12:33:03 <andersca> null
12:33:20 <andersca> @type null
12:33:20 <lambdabot> null :: [a] -> Bool
12:34:26 <keir> ok, here's a question of code prettyness
12:34:37 <keir> i'm writing a toy function 'addpairs' which does what you'd guess
12:35:04 <keir> ie, returns a list of ceil(len/2) elements where each element is a sum of adjacent numbers
12:35:33 <keir> i'd like to use pattern matching to grab the first two elements (ie (x:x':xs)
12:35:52 <keir> but how do i nicely catch the case where there is only one element?
12:36:03 <Smerdyakov> Another pattern match case.
12:36:07 <andersca> [x]?
12:36:13 <keir> oh! that's it
12:36:15 <keir> thanks
12:36:32 <phubuh> addpairs [] = 0 | [x] = something | (x:x':xs) = something else
12:36:52 <keir> oh, i didn't know you could do it like that
12:37:06 <keir> i had different lines with addpairs on each one
12:37:31 <Heffalump> umm, don't you have to?
12:37:33 <Riastradh> phubuh, this is Haskell, not OCaml.
12:38:22 <phubuh> agh, switching between haskell and ocaml daily results in a lot of half-haskell/half-ocaml mish mash
12:38:45 <keir> is ocaml worth learning?
12:38:52 <keir> i just recently started the scheme thing
12:39:01 <keir> but decided if i was going to do functional, i should go all the way
12:39:11 <phubuh> it's quite nice if you just need a better C++
12:39:18 <Lor> The type system is nice, and it's blazingly fast, but the syntax is ugly.
12:39:31 * Smerdyakov arches an eyebrow at phubuh.
12:39:35 <keir> lor, yeah, it looks pretty butt ugly
12:39:48 <phubuh> Smerdyakov, emphasis on *better* :-)
12:40:13 <Smerdyakov> In other words, you're saying "OCaml is nice if you just need a language that is suited for pretty much any task"?
12:40:15 <keir> has anyone written an OS in ocaml?
12:40:44 <Heffalump> type classes are the biggest thing I miss in ML
12:41:00 <keir> does ml have pattern matching?
12:41:03 <Riastradh> Yes.
12:41:07 <keir> cool
12:41:46 <Lor> Heffalump, on the other hand, modules are what many miss in Haskell. :)
12:42:17 <Lor> And ocaml has nice things like polymorphic variants.
12:42:18 <keir> i thought haskell had modules?
12:43:11 <Lor> Not MLish modules where a single signature can be implemented by several structures, and they can be parameterized.
12:43:15 <Riastradh> It does, but they're not as good as ML's.
12:43:22 <Lor> ML modules are very much like type classes, except that they're not implicit.
12:43:50 <Lor> OTOH, they can probably be simulated with existential types.
12:45:00 <phubuh> Smerdyakov, no. OCaml is suited for many things, but there are many situations in which I'd rather use Haskell. OCaml resembles C++ in that it supports all three of the major paradigms (FP, OOP, imperative), is really fast, and interacts well with UNIX -- but it's also better than C++ for a lot of things.
12:46:44 <keir> is the where clause depricated? i read somewhere online that it was. or one of its forms or something along those lines.
12:46:47 <phubuh> I would like to use Haskell for pretty much everything, but some times, when it doesn't cut it, I have to resort to another programming language -- that would usually be C++, if it wasn't for OCaml. 
12:46:58 <phubuh> keir, absolutely not!
12:48:55 <keir> would someone mind look at #flood? i'm not sure what's wrong with my where clause
12:50:43 <Lor> phubuh, how about SML?
12:53:19 <phubuh> Lor, I haven't used SML at all, actually :/
12:53:28 <phubuh> I hardly know anything about it
12:54:39 <Lor> It has somewhat nicer syntax than ocaml, and a little less fancy stuff.
12:54:51 <Lor> Except that SML/NJ has call/cc. :)
12:55:11 <phubuh> oh, interesting. I'll take a look at it :-)
12:56:55 <Lor> Here's a fairly comprehensive guide: http://www-2.cs.cmu.edu/~rwh/smlbook/
12:57:38 <phubuh> thanks!
12:57:42 <Darius> If I were going to look at an ML for interesting stuff, Alice ML would probably be my choice.
12:58:29 <Lor> There's lots of interesting stuff based on ML, for sure. :)
13:00:27 <toxic> is it possible to have a variable and change its value more then once?
13:00:33 <toxic> (a global one)
13:00:51 <phubuh> well, not *really*.
13:01:06 <Riastradh> You can't modify variables in Haskell.
13:01:09 <toxic> is there any way that isn't super slow?
13:01:17 <toxic> but something else than variables
13:01:27 <Lor> toxic, what do you want to accomplish?
13:01:29 <Heffalump> you can use a state monad
13:01:31 <toxic> something that returns a type but you can set it and so on
13:01:44 <Lor> Why do you think you need such a thing?
13:01:58 <toxic> Lor, a changing value that alot of recursions can modify and compare against
13:02:20 <Riastradh> Pass it as an argument to that recursive function.
13:02:36 <Lor> Yes, that's what you want, but what do you want it _for_?
13:02:42 <toxic> but wont some previous recursions have an older value
13:03:19 <toxic> ?
13:04:18 <Lor> toxic, there are some situations where mutable variables may really be called for, but they are rarer than you'd think.
13:04:37 <Lor> So please tell what it is you think they're needed _for_.
13:04:42 <toxic> hmmm
13:05:26 <toxic> i want a value that all levels of a recursion tree can compare against and change
13:05:47 <Lor> Yes but _why_? What are you trying to _accomplish_?
13:05:49 <Riastradh> toxic, you just stated that.  He wants a _concrete_ description of what you're doing, not an abstract one.
13:07:12 <Lor> Most likely what you want can be accomplish by simply threading a state through the recursion.
13:07:22 <toxic> if one of the recursions gets above the changable value it returns a Nothing
13:08:16 <toxic> but isn't that possible?
13:08:42 <Lor> All right, once more: what is this recursive function supposed to do? Not _how_, you have already said what you think is the way to do it, but _what_?
13:08:56 <Lor> What problem is it meant to solve?
13:09:35 <phubuh> are you trying to sort a list? read a file? what, in *concrete* terms, do you want to accomplish?
13:10:07 <Lor> I could understand if this is a hypersecret project for a company and you're under an NDA and cannot therefore give any hints about what you might be up to, yet somehow I surmise that this is not the case...
13:11:08 <keir> how do i make a function work on any type of number? my largest function is not compiling because it's puking on bad inferred types
13:11:09 <toxic> its a "shortest-path"-problem
13:11:24 <Lor> Now we're getting somewhere. :)
13:11:29 <toxic> =)
13:11:47 <Heffalump> keir: make it of type Num a => a -> Bool (for example)
13:11:48 <toxic> i just want the shortest path to be changable.
13:11:52 <Heffalump> but that should just be inferred
13:11:53 <phubuh> keir, often, it's a simple matter of removing the explicit type declaration and looking at what the compiler infers -- it does try to be as general as possible, after all.
13:12:08 <phubuh> toxic, perhaps every recursion can return its updated path?
13:12:12 <keir> phubuh, hrm... ok. that's what i had at first. i must have made a different error.
13:12:31 <Lor> toxic, yes, just threading the shortest path so far would solve your problem.
13:12:40 <toxic> hmm
13:13:03 <Lor> Into each recursive call you give as a parameter the shortest path length that's been found so far, and it returns (among other things) the new shortest path length.
13:13:27 <toxic> every recursion returns its path.. but to compare to all of them, doesn't that take alot of time?
13:13:44 <Lor> When you branch, you first give the old value to the first branch, then give the value that the first recursive call returned, to the next one, etc, and finally return whatever the last branch's call returned.
13:13:55 <Darius> Depending on how you are doing it, you may not need to do that.  For example, if you just did a breadth first search, laziness would keep any longer paths from being calculated.
13:14:14 <Lor> Yeah, breadth-first came to my mind, too.
13:14:19 <toxic> hmm
13:14:32 <Lor> But it's not trivial when the edges are weighted.
13:14:41 <Lor> You need a priority queue.
13:17:39 <toxic> sorry for my "i dont know the words"thing but what is "breadth-first"?
13:18:40 <keir> look it up ;) basically you search every level completely before descending down another. ie, you look at all positions 1-move away then all positions 2-moves away etc (to make a chess example)
13:19:09 <keir> whereas depth-first descends all the way down to the n-th level, then climbs back up, checks the next n-th level path, etc
13:19:26 <Lor> All the way to the _bottom_, that is.
13:19:48 <keir> lor, sure. of course the bottom is usually just where you decide it to be, in the chess example :)
13:19:50 <toxic> ah ok
13:19:57 <Lor> There are of course travelsal algorithms that go depth-first but only up to a certain depth.
13:20:24 <Lor> But "plain" depth-first implies to me that the _entire_ tree is traversed (which of course is never the case in chess).
13:20:33 * keir has more fodder for #flood if anyone wants to look at my code and help me out
13:20:47 <Heffalump> it would be in endgame situations
13:21:01 <keir> true
13:21:20 <Lor> Are there endgame situations that _must_ terminate, no matter what the players do?
13:21:38 <Heffalump> being close to the 50 move rule is an obvious example
13:22:21 <Lor> Ah. I'm not very acquainted with the rules of chess.
13:22:37 <Heffalump> 50 moves (half-moves, possibly) without a piece being taken or a pawn moving = draw
13:22:56 <Heffalump> means that all games have to end eventually
13:23:28 <Heffalump> the absolute maximum of moves is something like (56+15)*50*2
13:23:40 <Lor> Most sensible.
13:24:20 <Lor> Go also terminates, provided that you have some policy for triple ko:s.
13:25:39 <keir> what's the diff between fromIntegral 0, and 0?
13:26:16 <andersca> Prelude> :t 0
13:26:16 <andersca> 0 :: Num a => a
13:26:16 <andersca> Prelude> :t fromIntegral 0
13:26:16 <andersca> fromIntegral 0 :: (Integral a, Num b) => b
13:26:49 <Lor> In practice there's no difference.
13:27:04 <phubuh> 0 can't be implicitly coerced from an Integral to a Num
13:27:33 <Igloo> There is no difference
13:28:34 <phubuh> oh. sorry!
13:28:38 <Heffalump> the Integral a constraint is bogus there, since a isn't in the type and defaulting will take over
13:28:39 <Lor> Unless type a's (fromInteger 0) does really weird things.
13:29:08 <Lor> Sorry, _toInteger_.
13:29:30 <Heffalump> but type a would be defaulted to a standard type
13:29:40 <Igloo> Oh, hmm, does the report use fromIntegral or fromInteger? There might be a difference if you change the type defaulting order
13:29:40 <Lor> Depends on your defaulting.
13:29:57 --- mode: brunner.freenode.net set +b *!23kjhkjf@*
13:30:49 <Heffalump> doesn't the report define the defaulting?
13:31:06 <Igloo> It defines the default defaulting
13:31:14 <Igloo> But you can change it with the default keyword
13:34:57 <Heffalump> oh.
13:35:13 <keir> is & logical and?
13:35:29 <andersca> && is
13:35:34 <andersca> @type (&&)
13:35:34 <lambdabot> (&&) :: Bool -> Bool -> Bool
13:35:42 <keir> thanks
13:36:21 <Heffalump> oh. I never knew about that :-)
13:36:36 <Igloo> Yes you did  :-P
13:36:54 <andersca> sure ya did laddie
13:37:09 <Heffalump> when?
13:37:24 <Heffalump> andersca: Igloo probably has more chance of knowing that I did than you do :-p
13:37:27 <Igloo> When I was writing the H2L parser
13:37:30 <Heffalump> ah.
13:37:44 <Igloo> You also knew about otherwise, FWIW. That was a few weeks ago in the office.
13:38:04 <Heffalump> that it was a definition and not syntactic sugar?
13:38:08 <Igloo> Yup
13:38:21 <Heffalump> how come it ends up as True in TH syntax if it's a definition?
13:39:39 <Igloo> Prelude Language.Haskell.THSyntax> do x <- runQ [d| foo | otherwise = 5 |]; print x
13:39:42 <Igloo> [Val (Pvar "foo") (Guarded [(Var "GHC.Base:otherwise",Lit (Integer 5))]) []]
13:41:56 <Igloo> Or did you mean something else?
13:43:01 <Heffalump> I'm sure there was something we were discussing a while ago where it ended up as that
13:43:43 * Igloo can't remember, but that might have been the conversation where I said that no special handling was necessary because it's just a value
13:43:53 <Heffalump> hmm, ok
13:50:18 <keir> is there a list? function
13:50:35 <keir> or can i match a pattern where the first element is a list
13:50:43 <keir> ie (x:xs) where it only matches if x is a list
13:50:55 <phubuh> just treat it as a list, and you'll know it is a list.
13:51:15 <keir> that doesn't quite work. i'm trying to write flatten
13:51:18 <phubuh> you can't do [2, [4, 5]]
13:51:48 <keir> and the two cases are: head is a list? flatten x ++ flatten xs, and otherwise, x:flatten xs
13:52:10 <keir> but how to express this in haskell...
13:52:21 <phubuh> you just need the first case -- head will always be a list
13:52:53 <keir> no compute
13:53:08 <Igloo> keir: Think about what type flatten should have
13:53:19 <keir> [a] -> [a]
13:53:30 <phubuh> no, not quite
13:53:41 <phubuh> it turns a list of lists into a list of things
13:53:48 <keir> ok
13:54:02 <Igloo> phubuh: He's trying to write a LISP function that can't be typed, so there is no right answer
13:54:08 <Igloo> (If I'm right at least)
13:54:11 <keir> yes
13:54:31 <phubuh> ah -- do you want flatten to turn [1, [2, 3]] into [1, 2, 3]?
13:54:36 <Igloo> keir: So in any particular instance a has to be a concrete type
13:54:45 <keir> ie, '(a b '(c d e '(f)) g) --> '(a b c d e f g)
13:54:50 <Igloo> e.g. [Int] or Int
13:55:11 <Igloo> But there's no way you can have a list with different typed elements in
13:55:15 <keir> oooooh
13:55:18 <keir> ahah, right
13:55:19 <phubuh> the problem, then, is that 1 and [2, 3] are of different types, so you can't have them both in one list
13:55:22 <keir> i forgot about that
13:55:32 <Riastradh> ...unless you use typeclasses and rank-n polymorphism.
13:55:33 <keir> that's kind of annoying
13:55:54 <Darius> Anyways, s-expr aren't lists, they're rose trees.
13:56:01 <keir> oh
13:56:10 <keir> does haskell have an equiv?
13:56:54 <Riastradh> keir, see the Eq typeclass.
13:56:55 <Smerdyakov> keir, why is it annoying?
13:57:14 <keir> Smerdyakov, i like scheme's lists
13:57:24 <Smerdyakov> keir, why?
13:57:25 <keir> Smerdyakov, it seems like something haskell would support
13:57:36 <Smerdyakov> keir, why?
13:57:38 <keir> how are you going to build trees?
13:57:44 <Smerdyakov> You make a datatype for them.
13:58:28 <Smerdyakov> data Tree a = Nil | Node a [Tree a]
13:58:44 <phubuh> a thing in your list can be either a single thing, or a lot of things -- data a Thing = Single a | LotOf [a]
14:00:45 <phubuh> actually, change LotOf [a] to LotOf [a Thing] and you can have arbitrarily deep sublists, as in scheme
14:01:47 <Darius> phubuh: Thing a.  Haskell is sane in this regard.
14:02:19 * Smerdyakov rolls his eyes.
14:02:29 <Smerdyakov> There is no convincing reason to prefer one order over the other.
14:02:49 <phubuh> I prefer OCaml's syntax, in fact.
14:03:07 <phubuh> int tree is more intuitive than Tree Int, in my opinion.
14:05:28 <Darius> For simple scenarios they are both equally readable, "int tree" "Tree of Int", but Haskell's style is more uniform and more clearly supports thinking of type constructors as type level functions.  Also, I don't think that ML's syntax remains intuitive for more complex examples.
14:05:46 <phubuh> let's just leave it at that :-)
14:07:20 <keir> what's the best way to split a list in half?
14:07:21 <shapr> hi keir
14:07:26 <keir> hey shapr!
14:07:31 <keir> very ltns!
14:07:46 <shapr> yah, it's been years
14:07:46 <keir> shapr, i'm finally taking the plunge... haskell time!
14:07:49 <shapr> yay!
14:08:02 <shapr> what do you think sofar?
14:08:06 <keir> i very much like it
14:08:14 <keir> shapr, what are you up to these days?
14:08:18 <phubuh> it would be, uh, interesting if matching on a@b splitted the target up in half
14:08:28 <Heffalump> keir: well, there's two ways, one is just to do half xs = take (length xs `div` 2) xs
14:08:33 <shapr> keir: python/zope for money, haskell for fun
14:08:35 <Heffalump> the other way is:
14:08:50 <Heffalump> half' xs [] = xs
14:08:55 <Heffalump> half' xs [_] = xs
14:09:01 <keir> shapr, cool. how do you like zope?
14:09:11 <shapr> zope is powerful but arcane at times
14:09:13 <Heffalump> half' (_:xs) (_:_:ys) = half' xs ys
14:09:16 <Heffalump> half xs = half' xs xs
14:10:21 <keir> so no pretty slicing sematics like in python. pity
14:10:33 <Darius> Haskell lists aren't arrays.
14:10:34 <Smerdyakov> Oh puh-lease.
14:10:37 <Lor> slicing is not pretty.
14:10:49 <keir> depends on your perspective. i quite like it.
14:10:52 <Smerdyakov> Any "special semantics" that Python has can be implemented easily in Haskell.
14:10:59 <Smerdyakov> Possibly even with the same syntax.
14:11:30 <shapr> I like sequence slicin7g
14:11:36 <keir> a= [1,2,3,4]; a[1:3] --> [2,3]
14:12:09 <keir> or a[-1] --> 4
14:12:09 <Smerdyakov> It's easy enough to write slice so that you can do: slice a 1 3
14:12:22 <keir> i like negative indexing
14:12:24 <shapr> me too
14:12:35 <shapr> plus the simple syntax is nice
14:12:48 <keir> exactly. clearer than a[len(a) - 1]
14:12:51 <shapr> yup
14:13:06 <Smerdyakov> You can implement the same thing in Haskell with slightly different operators.
14:13:28 <Smerdyakov> Like a # @-1
14:13:38 <keir> eww
14:13:41 <Smerdyakov> To pick random operators # that @ that might have standard definitions already. :)
14:13:50 <keir> i prefer to avoid perl-style operators like *&@#*$&
14:14:01 <keir> can you say ugly!
14:14:06 <Smerdyakov> No, I can't.
14:14:12 <Smerdyakov> There's no practical reason to disprefer them.
14:14:24 <shapr> I've tried to implement slicing in Haskell, but the syntax is part of the elegance.
14:14:43 <keir> and there's no practical reason why i prefer debussey to bach
14:14:53 <phubuh> heathen!
14:14:55 <Smerdyakov> Music listening is not engineering.
14:15:08 <phubuh> neither is writing code!
14:15:09 <keir> Smerdyakov, then i'm afraid you've missed the good stuff
14:15:15 <Riastradh> Schubert is better than both of them, anyways.
14:16:01 <Smerdyakov> keir, or perhaps you've missed "the good stuff" when it comes to programming effectively.
14:16:55 <keir> if you don't find programming like listening to music, why hang out in #haskell?
14:16:59 <shapr> I think the summary here is that beauty is not the same to everyone
14:17:07 <keir> very true
14:17:37 <shapr> to me, the python (neé Icon) slicing syntax is beautiful
14:17:56 <keir> ditto
14:18:27 <Smerdyakov> keir, programming is unlike music because it has a _practical_ purpose. I find programming to be the more enjoyable for the more good stuff I can create with it.
14:18:44 <Smerdyakov> keir, so effective programming techniques are important to me.
14:19:43 <keir> it all comes down to an argument about existentialism... too much for this channel
14:19:46 <phubuh> shapr, but also that quality is not the same to everyone
14:19:57 <shapr> phubuh: truly
14:20:03 <phubuh> to me, for example, code quality is almost a synonym for beauty
14:20:17 <keir> (there's an interesting argument which says the beauty of music is the same of functionality of code)
14:21:25 <Smerdyakov> keir, I would be careful about saying that existentialism is too much for this channel. :)
14:21:40 <shapr> Smerdyakov: very punny
14:21:55 <shapr> is forall the existential quantifier?
14:21:57 <Smerdyakov> shapr, it wasn't meant to be a pun. This is the most intellectual IRC channel I've ever known.
14:22:03 <Smerdyakov> shapr, no, that's exists.
14:22:10 <Riastradh> Forall is the universal quantifier.
14:22:47 <shapr> Smerdyakov: it's still a good pun
14:22:49 <shapr> :-P
14:22:49 <keir> Smerdyakov, apologies, i didn't mean to indicate that the channel could not handle extentialism, merely that i find discourse in person generally better.
14:23:28 <shapr> I can never remember which is universal and which is existential
14:23:30 <Smerdyakov> I don't.
14:23:39 <shapr> I do
14:23:42 <shapr> but I don't get the chance
14:23:47 <Smerdyakov> It's a lot harder to track an argument or conversation when words vanish into the air soon after you say them.
14:24:01 <keir> anyway, i could write a funky secondhalf xs function, but is there a quick function to do this? (here slicing would be pretty)
14:24:03 <shapr> oh, I was thinking about how I can never beat up on Smerdyakov cuz he's in another country ;-)
14:24:10 * shapr teases Smerdyakov 
14:24:26 <Smerdyakov> shapr, was that an allusion to something such that I should find it witty?
14:24:43 <shapr> Smerdyakov: must have been an illusion instead
14:24:50 <phubuh> keir, drop (length x `div` 2) x
14:24:59 * Heffalump realises that his half is actually the second half, not the first half. Oops.
14:25:24 <shapr> hej toxic, hur är det med dig?
14:25:37 <keir> Heffalump, no, yours gets the first half...
14:28:16 <Heffalump> no it doesn't
14:28:34 <Heffalump> sorry, to be precise, my second version doesn't
14:28:38 <Heffalump> my first version does, obviously
14:28:44 <shapr> @yow
14:28:45 <lambdabot> ..  My vaseline is RUNNING...
14:29:09 <keir> Heffalump, oh! yes.
14:29:44 <Heffalump> firsthalf' xs [] = []
14:29:48 <Heffalump> firsthalf' xs [_] = []
14:30:00 <Heffalump> firsthalf' (x:xs) (_:_:ys) = x:firsthalf' xs ys
14:30:08 <Heffalump> firsthalf xs = firsthalf' xs xs
14:30:09 <Heffalump> (I think)
14:40:02 * shapr bounces cheerfully
14:42:23 <keir> woop, my mergesort worked first go
14:42:44 <shapr> Lunar^_: you're twins!+
14:44:36 --- mode: brunner.freenode.net set +b *!23kjhkjf@*
14:44:38 <keir> anyone here implemented a regex engine in haskell?
14:45:01 <shapr> luke gorrie wrote a simple one, I may have the source handy
14:46:53 <Smerdyakov> Regex matching is pretty easy to do.
14:47:38 <keir> yup, just whip out the good ole' FSA's
14:48:26 <Smerdyakov> You don't even need to do that. You can do it with backtracking with continuations very easily. Such a problem is assigned in ML in a course every CS major takes at CMU.
14:49:25 <Darius> I believe there is a Regex library in the heirarchical libs, perhaps specifically, System.Posix.Regex
14:50:08 <keir> does scheme have continuations?
14:50:12 <Darius> yes
14:50:19 <keir> hrm... ok
14:50:34 <keir> i hadn't thought of using continuations
14:52:36 <keir> probably because i've never used them.
14:54:37 <Smerdyakov> I'm not talking about built-in continuations, but just about certain kinds of functions.
14:54:53 <keir> ok
15:02:34 <keir> woah! continuations are cool!
15:02:41 <phubuh> :-)
17:39:27 <keir> does haskell have continuations? coroutines?
17:39:40 <Lor> You can use a continuation monad.
17:39:52 <Heffalump> it sort of has coroutines, because of lazy evaluation
17:40:11 <Riastradh> ...which is syntactic sugar over CPSifying your code.
17:40:15 <Riastradh> (er, continuation monads are, that is)
17:40:33 <Heffalump> and I think Koen Claessen's paper about "A poor man's concurrency monad" essentially comes down to a coroutine monad
17:41:21 <Pseudonym> Lazy evaluation, IMO, gets you about 90% of what you want from coroutines, assuming that you don't actually want concurrency.
17:41:26 <Heffalump> but I forget the precise details of it
17:41:37 <Heffalump> what's the other 10%?
17:41:56 <Pseudonym> The other 10% has something to do with destructive update.
17:42:35 <Heffalump> the Parsing Polish paper in this year's ICFP does coroutine-ish things using a datastructure to control them, IIRC
17:42:56 <Pseudonym> For example, a spreadsheet it kind of a coroutine engine.
17:43:27 <Pseudonym> You often want _updates_ to flow through your system.
17:43:47 <Heffalump> I don't see the coroutine-ness
17:44:55 <Heffalump> but right now it's bedtime
17:45:08 <Pseudonym> It's a little hard to describe, but I see a spreadsheet cell as a coroutine.
17:45:14 <Pseudonym> Say, if it's some kind of numeric solver.
17:45:40 <Pseudonym> I might think about this a bit and see if I can word it well.  You sleep.
17:46:19 <keir> i've been googling, but i haven't found a good tutorial / description of continuations (ie, with examples to help me think in continuations). has anyone here found a good source? even a book?
17:48:08 <Heffalump> Pseudonym: oh, I think I see - if it's some kind of iterative solution of a set of equations, then you do one iteration for one equation, hand it off to the next one, and so on?
17:49:09 <Heffalump> if that's what you mean, I think you can only describe it as coroutines if you allow recursively defined cells and your spreadsheet engine does iterate
17:49:39 <Riastradh> keir, http://www.bloodandcoffee.net/campbell/txt/continuation-tutorial.log
17:49:49 <Riastradh> It assumes some Scheme knowledge, but doesn't require that much.
17:50:16 <Smerdyakov> Yeah, no more than a Seventh Degree Scheme Major.
17:50:48 <keir> nice
17:51:19 <keir> what's CPS?
17:51:25 <Riastradh> Continuation-Passing Style.
17:51:44 <Pseudonym> Right.
17:52:10 <Pseudonym> Actually, I'd probably model that as a Fudgets-like stream processor.
17:52:44 <Pseudonym> This is very brief: http://haskell.org/hawiki/ContinuationPassingStyle
17:53:26 <Riastradh> Pseudonym, heh, I give a link to that (well, CpsTransform) in the end of that log.
17:53:31 <Pseudonym> :-)
17:54:53 <Pseudonym> http://haskell.org/hawiki/DataStructureFreeTransformation may also be useful.
17:54:57 <Pseudonym> Or may not.
17:55:40 <keir> ok
18:20:00 <keir> is haskell stackless?
18:21:05 <Pseudonym> Hard question to answer.
18:21:31 <Pseudonym> Haskell doesn't specify how it should be implemented.
18:22:09 <Riastradh> That's not a very hard question to answer.  The answer is just 'mu.'
18:22:13 <Pseudonym> :-)
18:22:31 <Pseudonym> However, all VMs that I'm aware of use a stack for some purpose or other.
18:22:57 <Pseudonym> On a machine with a finite number of registers, you need to spill somewhere. :-)
18:23:37 <Riastradh> Well, it could be done entirely in straight memory addresses...but that would be kind of silly.
18:23:42 <Pseudonym> In addition, in Haskell, evals can recursively invoke evals.  This effectively requires recursion.  Whether you use a machine stack or a linked list of records is up to you.
18:23:43 <keir> stackless in the sense that a haskell function call does not use space on the C stack
18:23:49 <Riastradh> Or, worse, directly to the hard drive.
18:24:00 <keir> ie, similar to stackless python
18:24:05 <dnm> Hey guys.
18:24:06 <Pseudonym> keir: It's up to the implementation.
18:24:29 <Pseudonym> You need to maintain a C stack because of signal delivery, of course.
18:24:46 <Pseudonym> dnm: G'day.
18:24:58 <Riastradh> keir, some implementations might not touch the C stack; some might devour it.  E.g., if any Haskell implementations are like the CHICKEN Scheme compiler, they'll use the C stack, but they'll use it for garbage collection, not like what some things would use it for.
18:25:11 <Riastradh> The Haskell definition does not specify how Haskell interacts with the C stack.
18:25:33 <Pseudonym> An SECD machine-alike would tend to use the C stack for the "dump", not the "stack".
18:25:55 <Riastradh> And on some environments, there wouldn't _be_ a 'C stack.'
18:26:03 <keir> ok ok
18:26:04 <Pseudonym> There is on Unix.
18:26:10 <Pseudonym> Signal delievery requires it.
18:26:22 <Riastradh> Pseudonym, yes, and UNIX is one environment.  It's not the _only_ one.
18:26:28 <Pseudonym> True.
18:26:44 <Pseudonym> IMO, this is actually the biggest problem with Unix from a new-fun-language point of view.
18:27:00 <Pseudonym> Unix == C virtual machine
18:31:04 <Riastradh> And that's most of why many people are opposed to having first-class, multishot, non-local extrance (is that a word?) and entrance in languages: it's hard to implement in C, and UNIX is C's virtual machine, so implementing them on UNIX is made difficult[er].
18:32:30 <Smerdyakov> I hate it when extrance is made difficulter.
18:32:55 <Pseudonym> Me want much more gooder extrance.
18:33:06 <Riastradh> Well, extrance _ought_ to be a word!
18:33:24 <Pseudonym> How about "egress"?
18:33:33 <Pseudonym> @wn egress
18:33:34 <lambdabot> *** "egress" wn "WordNet (r) 2.0"
18:33:34 <lambdabot> egress
18:33:34 <lambdabot>      n 1: (astronomy) the reappearance of a celestial body after an
18:33:34 <lambdabot>           eclipse [syn: {emersion}] [ant: {ingress}, {ingress}]
18:33:35 <lambdabot>      2: the becoming visible; "not a day's difference between the
18:33:36 <Riastradh> Yuck, that doesn't sound right.
18:33:37 <lambdabot>         emergence of the andrenas and the opening of the willow
18:33:39 <lambdabot>         catkins" [syn: {emergence}, {issue}]
18:33:41 <lambdabot>      3: the act of coming (or going) out; becoming apparent [syn: {egression},
18:33:43 <lambdabot> [4 @more lines]
18:33:53 <Pseudonym> Ah, egression.  Perfect.
18:33:56 <Riastradh> It should look similar to 'entrance,' which is why I chose 'extrance.'
18:34:08 <Riastradh> And 'egtrance' _definitely_ wouldn't sound right.
18:34:09 <Pseudonym> Non-local egression.
18:34:26 <Pseudonym> WHY should it look similar to "entrance"?
18:34:41 <Pseudonym> If you want a regular language, speak in Lojban or Esperanto.
18:34:43 <Riastradh> It just should!
18:34:56 <Riastradh> Well, I would, if you weirdos spoke it.
18:35:13 <Pseudonym> Mi komprenas Esperanton.
18:35:31 <Riastradh> Well, humph.
18:35:50 <Riastradh> Does Esperanto have words for 'continuation' and 'monad?'
18:35:51 <Pseudonym> Mi ne komprenas Lojxbanon.
18:35:57 <Pseudonym> Uhm...
18:36:32 <Pseudonym> Probably not "monad".  I hereby coin "monado".
18:36:58 <Pseudonym> "dauxrigo" works for "continuation"
18:37:16 <Riastradh> Vivas la monadoj!
18:37:30 <Pseudonym> Don't you mean "monadojn"?
18:37:40 <Pseudonym> And I think "Vivu".
18:37:47 <Smerdyakov> Mohadin?
18:37:49 <Riastradh> Curse you.
18:37:50 <Pseudonym> Imperative mood, surely?
18:38:08 <Riastradh> But we're declarative programmers!
18:38:47 <Pseudonym> Yes, so what you want to do is describe to the monads how to live long, but not actually tell them to do it.
18:38:48 <Riastradh> Monads can _simulate_ imperative stuff, but they aren't really; therefore, 'viv_as_ la monadojn.'
18:39:03 <Riastradh> No, I'm declaring _that_ they live long.
18:39:10 <Smerdyakov> Sometimes I wonder if, every time Riastradh tries to make a joke, an angel somewhere in heaven loses its wings.
18:39:11 <Riastradh> It's like a type annotation.
18:39:28 <Pseudonym> Oh, in which case, "monadoj" is correct.
18:39:32 <Riastradh> Hah!
18:39:33 <Riastradh> See?
18:39:35 <Pseudonym> Translation: "Monads live long."
18:39:59 <Riastradh> Or, in other words, they're persistent, because they aren't actually mutated.
18:40:01 <keir> continuations just seem like fancy gotos
18:40:11 <Smerdyakov> keir, and I'll take fancy goats over that any day.
18:40:14 * Pseudonym washes out keir's mouth with soap and water
18:40:33 * Riastradh hands Pseudonym a small phial of capsaicin as well.
18:40:51 <Pseudonym> Oooh!  Weapon of mass destruction!
18:41:11 <keir> ahah, well i'll first finish reading this tutorial before being further disciplined by #haskell
18:41:28 <Pseudonym> No, you just said the "g" word.
18:42:00 <Pseudonym> In C-style olanguages, "break" and "continue" are kind of like fancy g-words, but they're not really.
18:42:26 <Riastradh> Pseudonym, no, they're like _dreary_ and _limiting_ g-words, not _fancy_ g-words.
18:42:53 <Pseudonym> Limiting compared with continuations, but not compared with that which is considered harmful.
18:43:00 <Riastradh> keir, if continuations are fancy g-words, then every time you call a function, you're using the g-word.
18:44:03 <keir> well... you are
18:44:24 <keir> function calls just happen to push PC ;)
18:44:47 <keir> er, IP rather (too much 68k assembly for me)
18:44:57 <Pseudonym> Not in a RISC CPU.
18:45:07 <Riastradh> And not if you think in abstract terms of what a function does.
18:45:13 <keir> true
18:45:19 <Riastradh> Thinking in platform-specific, low-level terms will rot your brain.
18:45:43 <keir> Riastradh, yes, but occasionally you gotta program assembler
18:45:51 <keir> at least in my line of work
18:46:00 <Pseudonym> You avoid it like hell, though.
18:46:09 <Pseudonym> What is your line of work, as a matter of interest?
18:46:12 <Pseudonym> Device drivers?
18:46:16 <keir> engineering student!
18:46:26 <keir> i probably should have done CS though
18:46:32 <Pseudonym> That explains a lot.
18:46:37 <keir> but then i'd never get to learn electronics
18:46:48 <Pseudonym> Yes, engineering students need to program assembler.
18:46:49 <keir> which i find fascinating.
18:46:52 <Riastradh> (just look at what happened to this guy named 'BusError' in #macdev on this network: it is his opinion that:  anything with garbage collecting is evil, because it's 'scripting,' and if you don't manually manage memory, you're stupidly not understanding the inner workings of your computer; any language that you can't write device drivers in is useless; et cetera...)
18:46:57 <Pseudonym> Ah, but you could do what I did.
18:47:03 <Pseudonym> CS, with minor in physics.
18:47:11 <Pseudonym> And do your electronics in physics.
18:47:32 <keir> hah, the U of T engineering dept. is awful if you want to customize your curriculum. you can't.
18:47:38 <keir> i have zero course selection
18:47:45 <Pseudonym> Oh well.  Sucks to be you.
18:47:48 <keir> yup!
18:47:57 <Pseudonym> :-)
18:48:05 <keir> i get some choice 4th year though
18:48:23 <Riastradh> U of T?  University of Texas?
18:48:24 <Pseudonym> Riastradh: That's just frightening.
18:48:27 <keir> toronto
18:48:36 <Riastradh> Pseudonym, yes, indeed.  Don't try arguing with him.
18:49:01 <Pseudonym> Remind me never to hire this guy.
18:49:16 <keir> me?
18:49:24 <Pseudonym> No, this BusError person.
18:49:26 * Riastradh and a couple of CL advocates, lots of Objective-C advocates, and a Java advocate can't stick _anything_ into his thickly coated with several coats of titanium skull.
18:49:42 <Pseudonym> Assuming it's a person and not a non-garbage-collected bot.
18:49:47 <keir> hah
18:49:53 <Pseudonym> @yow
18:49:54 <lambdabot> Is it NOUVELLE CUISINE when 3 olives are struggling with a scallop
18:49:54 <lambdabot>  in a plate of SAUCE MORNAY?
18:50:13 <Riastradh> I think it's a person.  He's written a fair bit of software (e.g., glTerm) that I'm familiar with.
18:50:22 <Pseudonym> Mind you, I'm wary as soon as anyone identifies as an 'advocate".
18:50:30 <Riastradh> I couldn't think of a better term.
18:50:51 * Pseudonym nods, fair enough
18:50:53 <Riastradh> 'Programmer' sounded wrong to me, and 'proponent' is pretty much the same as 'advocate.'
18:52:17 <keir> it's funny though, my dad totally doesn't 'get' FP. i try and try... but i think i'm giving up finally. 
18:52:35 <Smerdyakov> How did your dad come into this?
18:52:49 <Pseudonym> BusError isn't your dad, is he?
18:52:51 <keir> we were talking about convincing someone about a way of programming
18:53:50 <Riastradh> keir, are you French, and does your dad use Macs and IRC?
18:53:51 <keir> seems relevant. most of my class for csc326 (eng. students) doesn't 'get' FP either, and my prof isn't helping things.
18:53:59 <keir> Riastradh, no.
18:54:02 <Smerdyakov> What's csc326?
18:54:08 <Riastradh> OK, then he's probably not BusError.
18:54:10 <keir> computer programming
18:54:24 <Smerdyakov> There's a 300-level course called "computer programming"?
18:54:31 <keir> 'programming languages'
18:55:00 <keir> brief skim over java/scheme/c++ (although if you're a so-called hardcore coder, you can do the last bit in haskell or ml or whatever)
18:55:02 <Smerdyakov> Now we're getting somewhere. :)
18:55:04 <Pseudonym> Smerdyakov: In the arts faculty, there's a 300-level course called "telephony".
18:55:07 <Pseudonym> Or so I've heard.
18:55:32 <Smerdyakov> The usual chance for a pedagogically-challenged professor to completely underestimate the difficulty of learning functional programming from a cold start.
19:02:12 * keir clicks
19:02:19 <keir> now the scheme continuations make sense
19:02:35 <keir> call/cc confused me before but that tutorial by nathaniel gray cleared things up
19:02:49 <keir> that's very neat
19:02:54 <Riastradh> Nathaniel Gray?
19:03:27 <keir> http://mojave.cs.caltech.edu/papers/cont-tut.ps
19:03:36 <Smerdyakov> Riastradh, that means a person with family name Gray and given name Nathaniel.
19:03:43 <Riastradh> keir, did you read that log?
19:03:55 <keir> somewhat, but it was a bit confusing
19:04:07 <Riastradh> What parts of it confused you?
19:04:23 <keir> the idea of a 'hole'
19:04:34 <Riastradh> What was confusing about it?
19:04:36 <Smerdyakov> Riastradh will demonstrate to you the many uses of holes.
19:05:02 * Riastradh slaps a portable hole on Smerdyakov's forehead and throws some dice into it.
19:05:26 <keir> hah
19:06:24 <keir> as i understand it
19:06:42 <keir> cal/cc returns the value of it's passed function except
19:07:18 <keir> when somewhere inside that function (continuation x) gets eval'd
19:07:27 <keir> then it jumps out of the function right to the call/cc
19:07:30 <keir> and returns that value
19:27:14 <Darius> keir:  What happens if (continuation x) gets eval'd more than once?
19:31:49 <mattam> keir: nice tute indeed
19:35:56 <keir> (continuation x) can't be eval'd more than once
19:36:13 <keir> not in the same call
19:36:24 <keir> because it resumes you out to the call/cc level
19:37:06 <keir> now i gotta figure out how to make my regex parser use continuations rather than horrible, ugly recursion
19:37:44 <Riastradh> keir, sure it can.
19:37:56 <Riastradh> Did you read the _entire_ log I pointed you towards?
19:38:26 <keir> Riastradh, nope!
19:39:29 <Riastradh> keir, (let ((k (call/cc (lambda (k*) (0 (k* k*)))))) <body>) -- what happens if you call K in <BODY>?
19:39:30 <Darius> keir: Many interesting uses of continuation are based on calling a continuation more than once.
19:40:57 <keir> Riastradh, hrm... gimmie a sec
19:41:13 <Riastradh> Where does K* continue to?
19:41:49 <keir> identity?
19:42:15 <Riastradh> 'Identity' is a thing.  I'm asking for a place (preferrably using the [] notation I employed in the log).
19:42:21 <Riastradh> s/thing/concept/1
19:44:16 <keir> (k [])
19:44:48 <Riastradh> OK.  So (k* k*) puts K* in that hole.  Remember that K* is the continuation that returns to that place.
19:44:57 <Riastradh> What does K get bound to, then?
19:45:48 <keir> the continuation from (call/cc...). (i'm a bit fuzzy again here)
19:45:59 <Riastradh> Yes, that's right.
19:46:11 <Riastradh> So if you call K in <BODY>, where do its arguments get put?
19:46:30 <keir> hahaha into k
19:46:32 <keir> that's cool
19:47:03 <keir> then next time around, k is a different value... hrm. this seems not quite correct.
19:47:19 <Riastradh> The next time around -- i.e. when you do (k x) -- K becomes X.
19:47:24 <keir> yup
19:47:25 <Riastradh> If you do (k k), it stays the same.
19:47:58 <keir> and calling (k x) is kinda like recursing to the beginning of the function
19:48:04 <keir> and changing k to x
19:48:06 <Riastradh> Yes, indeed.
19:48:21 <Riastradh> You can in fact implement SET! using just LETREC and CALL/CC.
19:48:39 <keir> woah, cool
19:49:01 <keir> is call/cc efficient? ie, is it indeed faster than 'normal' recursion (though not necessarily tail recursion)
19:49:37 <Riastradh> CALL/CC can have widely varying degrees of efficiency, depending on how it's implemented.
19:49:51 <keir> ok. 
19:50:03 <Riastradh> Some implementations (e.g., Bigloo) have a _terribly_ slow CALL/CC; others (like CHICKEN) have continuations that are as lightweight as ordinary closures.
19:50:25 <keir> what about, say, mzscheme or mitscheme?
19:51:33 <Riastradh> MzScheme's continuations are somewhat expensive.  I'm not familiar with MIT Scheme's continuations (or much about MIT Scheme, in fact, due to the fact that it's x86-only).
19:51:57 <keir> ewww, x86 only, didn't know that.
21:58:49 --- mode: brunner.freenode.net set +b *!23kjhkjf@*
22:11:50 --- mode: brunner.freenode.net set +b *!23kjhkjf@*
22:14:21 <isomer> @harr
22:14:21 <lambdabot> Sorry, I don't know the command "harr", try "lambdabot: @listcommands"
22:14:29 <isomer> @listcommands
22:14:29 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define","definitions","del-definition","devils","dict","dict-help","dummy","dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements","eval","foldoc","foo","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","lojban","more","msg","part","prelude
22:14:34 <isomer> @arr
22:14:34 <lambdabot> Get out of me way, yeh landlubber
23:11:23 <blackdog> @lojban
23:11:56 <blackdog> @hitchcock
23:12:04 <blackdog> i'm doing something wrong, hm?
23:28:17 <earthy> g'maen
23:28:27 <earthy> @lojban dutch
23:28:29 <lambdabot> ERROR: 501 Syntax error, illegal parameters
23:28:39 <earthy> @help lojban
23:28:39 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
23:28:45 <earthy> hm. :)
23:29:11 <earthy> yes, you're doing something wrong, but I can't for the life of me figure out what exactly. ;)
23:42:44 <blackdog> oh well. I'll ask shapr when he's round.
