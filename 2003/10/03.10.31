03:20:09 <harsha123> hey! how do I register my nick using NickServ ?
03:25:25 <shapr> try /msg nickserv help
03:25:49 <harsha123> shapr hello..:)
03:26:03 <harsha123> shapr got it, after some trial and error :)
03:26:06 * shapr snores quietly
03:26:15 <harsha123> sleeping ?
03:26:30 <shapr> sort of
03:26:46 <harsha123> :)
03:28:06 <earthy> m nickserv help
03:28:43 <harsha123> hi earthy!, ty.. I finally registered my nick.. after trial and error.. :)
04:18:48 * shapr yawns
04:18:54 <shapr> @yow
04:18:55 <lambdabot> Two LITTLE black dots and one BIG black dot...nice 'n' FLUFFY!!
04:23:54 <earthy> @yow
04:23:55 <lambdabot> Is a tattoo real, like a curb or a battleship?
04:23:55 <lambdabot>  Or are we suffering in Safeway?
04:24:05 <shapr> wassup earthy ?
04:24:21 <earthy> fuck if I know
04:24:39 <earthy> been looking at the screen all morning
04:25:11 <shapr> seen anything interesting?
04:25:16 <earthy> been reading papers
04:25:27 <earthy> mostly not too interesting, but for the one I'm reading now
04:25:40 <shapr> which one is that?
04:25:45 <earthy> (but that's due to the question of whether I'd like to work on it and co-author it ;))
04:25:50 <shapr> aha
04:50:26 <shapr> hiya mvw 
04:50:43 <shapr> looking for Haskell info?
04:51:10 <steele> hi
04:51:27 <shapr> hi steele
04:51:41 <shapr> what's up?
04:52:06 <steele> prototyping some c stuff in haskell
04:52:06 <shapr> haven't seen you in awhile
04:52:23 <steele> i wasn't on freenode for some time
04:52:35 <mvw> hi guys, i participate in a seminaire on advanced fp
04:52:46 <mvw> i have to do the talk about quickcheck
04:52:56 <shapr> mvw: oh, cool! quickcheck is amazing
04:52:58 <mvw> i have no clue about haskell
04:53:07 <shapr> mvw: this is a great chance to learn!
04:53:12 <mvw> i have two books now
04:53:18 <mvw> 1. algebra of programming
04:53:24 <mvw> 2. the old peyton jones book
04:53:37 <mvw> (some of the phds always grab the new edition :-)
04:53:48 <mvw> my question: what compiler should i grab?
04:53:50 <shapr> I learned Haskell from the Simon Thompson and Paul Hudak books
04:53:55 <shapr> I'd recommend GHC version 6
04:53:58 <mvw> a ha
04:54:09 <shapr> steele: well I'm glad you're back :-)
04:54:26 <steele> shapr: ;)
04:55:31 <mvw> do you use quickcheck?
04:55:43 <shapr> sure
04:55:43 <steele> is there something like f (x:xs) as l = ... in haskell (or is that in ocaml)?
04:55:59 <shapr> you mean naming an entire pattern?
04:56:20 <shapr> f all@(x:xs) = if x == [] then all else xs
04:56:22 <shapr> something like that?
04:56:35 <shapr> mvw: read the two QuickCheck papers from John Hughes website
04:56:58 <shapr> mvw: I've been interested in software testing for years, and I think QuickCheck is a powerful tool that no one knows much about, sadly.
04:56:59 <mvw> i did read the older one
04:57:05 <steele> shapr: exactly what i've been looking for
04:57:27 <shapr> steele: you can also nest that naming, but it quickly gets unreadabble
04:57:33 <shapr> it's easy to overdo named patterns
04:57:58 <shapr> f a@(x:(b@xs)) something like that...
04:58:21 <mvw> something different
04:59:02 <mvw> i was polishing up my web pages and hit the icfp link by accident, i was surprised to see that they finally published contest results - anyone knows when they did this?
04:59:12 <shapr> I heard the results in person...
04:59:17 <shapr> they were depressing :-(
04:59:28 <steele> i just need one level, it's for test cases, something like: test t@(a,b) = TestCase $ assertEqual (show t) (f a) b
05:00:13 <shapr> are you using HUnit?
05:00:19 <shapr> ah, of course you are
05:00:31 <shapr> TestCase and assertEqual are only from HUnit
05:00:32 <mvw> shapr: one team, team red, does contests every week
05:00:43 <mvw> see www.topcoder.com
05:00:45 <shapr> mvw: oh, fun, can I participate? :-)
05:00:56 <shapr> is Haskell an allowed language for topcoder.com ?
05:00:59 <mvw> i tried some and it is not easy
05:01:15 <mvw> they allow c++, java, c# and visual basic :)
05:01:24 <shapr> oh, never mind...
05:01:29 <mvw> don't laugh
05:01:36 <mvw> the time limit makes it very hard
05:01:37 <shapr> I've used two of those languages, and don't want to do that again.
05:02:10 <mvw> i found it very interesting how the situation changes under extreme pressure
05:02:18 <shapr> yes, I agree.
05:02:25 <mvw> e.g. you are forced to use the system libs very well
05:02:31 <shapr> I've used Jython quite happily
05:02:57 <shapr> with test driven development and regular refactoring, programs are easier to write in a short amount of time
05:02:59 <mvw> i agree that all those langs are more or less junk, except c++ which is very good for efficient stuff
05:03:31 <shapr> I'd rather use the hard and soft layers, I'd write my app in Jython and only use Java when I really need speed for one small piece
05:03:37 <mvw> that team red consisted of some of the highest rated of these coders
05:03:38 <shapr> and then I can still use that fast piece from Jython
05:03:43 <shapr> same for Haskell/C Python/C etc
05:03:52 <mvw> they solve advanced algorithmic stuff in a very short time
05:04:06 <shapr> I wonder how hard it would be to do a Haskell version....
05:04:08 <mvw> so it was probably more the guys, than the langs who made the difference
05:04:15 <shapr> sadly, I don't have any prizes to give out.
05:04:16 <mvw> for that kind of competition?
05:04:19 <shapr> sure
05:04:27 <shapr> yes, I agree that it's the people, not the languages used.
05:04:33 <mvw> the hard thing would be to come up with good problem sets
05:05:18 <mvw> it would be interesting to make a monthly competion or so under icfp brand similiar like topcoder for functional langs (and perhaps open to others as well)
05:05:32 <shapr> it would be easier to do for Haskell, since many standard libraries aren't available
05:05:50 <mvw> why does that make a difference?
05:06:11 <shapr> because smtp, pop3, xml-rpc, etc are available as useful and fun problem sets
05:06:43 <shapr> though maybe that sounds too much like work ....
05:06:51 <mvw> haskell has these, or has these not in the standard libs?
05:06:57 <shapr> has these not
05:07:19 <mvw> java has
05:07:23 <mvw> erlang not
05:07:27 <mvw> hm
05:07:37 <mvw> but the tc problems are interesting
05:08:07 <shapr> like what?
05:08:13 <mvw> e.g. you get an array with an asccii rendering of some graph
05:08:22 <mvw> the task is to reconstruct the graph
05:08:32 <mvw> man, do this in 30 mins without error
05:09:08 <mvw> some of the trained guys have no trouble solivng that stuff routinely
05:09:45 <mvw> of course that nothing to do with the real world
05:10:30 <shapr> do you think it's more fun if it's not real world?
05:10:48 <mvw> no, but i underestimated the difficulties
05:11:00 <mvw> if i have no pressure my brain works better :)
05:11:36 <shapr> I think I work better with some pressure
05:11:54 <mvw> you are right
05:11:57 <mvw> no pressure: lazy
05:12:02 <mvw> pressure: work
05:12:09 <mvw> high pressure: make mistakes
05:12:15 <mvw> :)
05:12:27 <shapr> but you have QuickCheck ;-)
05:12:34 <shapr> then you don't make as many mistakes
05:12:40 <mvw> i still don't understand how it works
05:12:51 <mvw> it seems to hit the input with random junk
05:13:06 <mvw> i need to understand how it prepares that
05:13:19 <shapr> it prepares it how you ask it to...
05:13:37 <shapr> http://www.scannedinavian.org/~shae/src/haskell/ProtoQuickCheck.hs
05:13:44 <shapr> that's source code from the first paper
05:13:57 <mvw> i need to understand haskell first, i fear
05:14:11 <shapr> prop_RevRev :: [Int] -> Bool
05:14:11 <shapr> prop_RevRev xs = 
05:14:11 <shapr>     reverse (reverse xs) == xs
05:14:26 <shapr> that says, for any list of Int, if you reverse it twice, it should be the same as the original list
05:14:49 <shapr> so QuickCheck makes up a bunch of random lists of Int, and tries to see if it can find fault with your property
05:14:57 <shapr> if it does, it tells you.
05:15:08 <mvw> that was the funcs definition, or?
05:15:24 <shapr> that's one QuickCheck property
05:16:04 <mvw> can i feed quickcheck the haskell source of the function to check, or do i need to prepare a extra qc description of the funcs properties?
05:16:46 <shapr> you prepare the properties once the function has been defined
05:17:14 <mvw> it would be nicer if qc could read the function directly :)
05:17:26 <shapr> how would it know what properties to test?
05:18:00 <shapr> let's say you write a max3 function that returns the largest of three numbers, can you think up some properties that should always be true for that function?
05:18:01 <mvw> don't the properties would be at least to be part of a functions definition?
05:18:25 <mvw> let me go to the toilet and think about it, i am back in 5min :)
05:18:27 <steele> if qc derived the spec from the implementation it would be always correct 
05:18:47 <mvw> steele: yes you are right
05:19:17 <shapr> but the implementation doesn't always follow the spec
05:22:16 <shapr> g'day mrak
05:22:41 <blackdog_> g'day shapr. paper deadline today/tomorrow/damn timezones got me so confused...
05:23:09 <shapr> the point of software testing is that you check whether the implementation follows the spec in your head
05:23:47 <shapr> you're submitting?
05:24:34 <mvw> what conference are you talking about?
05:24:51 <blackdog_> IFL...
05:24:53 <steele> shapr: i just meant that it wouldn't make sense to derive the spec from the implementation, because then the implementation would always follow that (derived) spec
05:25:14 <steele> shapr: you have to write down the spec in some form
05:25:21 <shapr> oh, yes ..
05:25:28 <blackdog_> it'd make correctness much easier to achieve, though. :)
05:25:33 <shapr> heh, truly
05:25:42 <mvw> i guess i got confused. i had a dose of prolog and a dose of model checking lately
05:26:13 <shapr> mvw: if you could build a formal model, then you could check the code against it
05:26:27 <shapr> but with Quickcheck, you establish certain properties
05:26:51 <mvw> do you know the Junit stuff?
05:27:24 <steele> shapr: does qc overlap with HUnit or do they complement each other?
05:27:47 <shapr> they're entirely different critters
05:27:51 <mvw> ah hunit is a haskell junit?
05:28:02 <shapr> they could be complementary, though I don't know where anyone has used them together in the same software
05:28:06 <blackdog_> qc is randomised, isn't it?
05:28:21 <shapr> mvw: it's called xUnit actually, since the first one was written in Smalltalk
05:28:50 <mvw> that would be interesting stuff for my talk
05:29:00 <shapr> software testing is a fun subject
05:29:02 <mvw> what is the smalltalk one alled
05:29:09 <shapr> SUnit :-)
05:29:10 <mvw> what is the smalltalk one called?
05:29:13 <mvw> thanks
05:29:26 <shapr> JUnit is for Java, PyUnit is for Python.. HUnit is for Haskell
05:29:33 <mvw> why do gamma and beck get the fame?
05:29:38 <shapr> actually, refactoring theory is a further step along that trail
05:29:42 <shapr> that's *cool* stuff
05:29:58 <mvw> refactoring is just higher level editing
05:29:59 <shapr> that probably comse from the Gang of Four book, Design Patterns
05:30:02 <shapr> mvw: no way
05:30:12 <shapr> refactoring is much stricter than editing
05:30:30 <shapr> editing means you're just changing code, but refactoring means you can't change the *meaning* of the code while you do htat
05:30:33 <mvw> i see it just as having editor functonality on a syntactic level
05:30:44 <shapr> no no!
05:30:53 <shapr> read Brant's thesis on the original Refactoring Browser
05:31:03 <mvw> i feel stupid now :)
05:31:03 <shapr> and Opdyke's earlier work with C++
05:31:41 <shapr> if you have an application that fits inside the ideas from the original refactoring browser thesis, then your unit tests define 'meaning' in your application
05:31:47 <mvw> but refactoring is only about reorganizing - changing structure 
05:31:53 <shapr> right
05:31:59 <shapr> but not changing meaning
05:32:02 <shapr> editing changes meaning also
05:32:15 <mvw> changing a variable name in all modules?
05:32:19 <shapr> for example, if you move a method from a subclass to a superclass, no 'functionality' is changed
05:32:30 <det> shapr: text awaits you!
05:33:19 <mvw> so Xunit has theoretical foundation
05:33:26 <shapr> sure
05:33:36 <mvw> is qc more than a combination or property description lang and random input generator?
05:33:43 <shapr> but slightly metaphysical as well, since it somewhat defines 'meaning' in your application
05:33:56 <shapr> mvw: no
05:34:05 <shapr> not that I can think of
05:34:20 <shapr> det: :-P
05:34:55 <shapr> mvw: I'm interested in refactoring and software testing, in case you didn't notice ;-)
05:35:02 <mvw> me too
05:35:09 <shapr> I started on a refactoring browser once, but my skillz were not sufficient
05:35:18 <shapr> happily someone else took it over, and he's doing a good job with it.
05:35:24 <mvw> i worked for 6 years in industry and ended allways up doing the testing
05:35:37 <shapr> have you read the extreme programming books?
05:35:45 <shapr> have you used a refactoring browser?
05:35:52 <mvw> i am interested in eclipse
05:36:01 <mvw> the java module is very good
05:36:18 <mvw> there i learned about refactoring functions
05:36:24 <shapr> personally, I only see three kinds of software testing, unit testing (xUnit) , random testing (QuickCheck), design by contract (Eiffel)
05:36:26 <mvw> but i avoided the theory yet
05:36:37 <shapr> I think QuickCheck could do DbC also
05:36:44 <shapr> do you know of any other flavors of software testing?
05:36:52 <mvw> where fit the hoare conditions in?
05:37:03 <shapr> I dunno, what is one?
05:37:28 <mvw> that kind of proof, where you specify what condition holds before and after a statement
05:37:40 <blackdog_> if you're following comp.lang.functional, the lisp dudes are trying to cast static typing as a test suite... :)
05:37:45 <Lunar^> Does anyone know where I could find an example/tutorial of System.Console.GetOpt usage ?
05:37:52 <shapr> blackdog_: that's strange...
05:37:58 <mvw> this seems to be the real idea behind assert( ) macros
05:38:17 <shapr> mvw: that sounds like design by contract to me, but I'm not sure if they're exactly the same
05:38:18 <blackdog_> shapr: one of those epic threads that just won't die.
05:38:53 <mvw> what i have not understood yet is, where the idea of loop invariants came from
05:39:02 <blackdog_> the static typers can't imagine programming without types, and the dynamicists want the freedom to be wrong.
05:39:13 <shapr> I think static typing is a simple automated proof system, and you can choose to drap your program over that skeleton, and to what extent
05:39:35 <shapr> you can also choose to ignore it and play with dynamic types all the time :-)
05:39:36 <mvw> there must some theory
05:39:50 <blackdog_> that's closer - it's like the distinction between theorem proving and model checking. 
05:39:54 <mvw> my advisor created a static type checking for functional lungs
05:40:01 <shapr> blackdog_: what's the distinction?
05:40:05 <steele> some of the arguments from the lisp camp sound like assembler/C ones: "I'm smarter than the computer"
05:40:11 <shapr> mvw: oh, I want a functional lung ;-)
05:40:30 <shapr> steele: you could argue that's why Template Haskell came along :-)
05:40:35 <mvw> on time he made the remark that the bottom type is related to a not terminating computation  - i see no connection yet to this
05:40:45 <mvw> :)
05:40:50 <shapr> anyways, I think both static and dynamic typing are useful critters, though I'd rather have Soft or even better, Firm typing
05:41:56 * Darius goes out and invents Motherly typing.
05:42:09 <shapr> hehe!
05:42:31 <shapr> hi Darius, whatcha doin?
05:42:48 <Darius> Reading IRC mostly
05:42:54 <shapr> anything interesting?
05:43:18 <shapr> I wanted to discuss something with Lor, but I've forgotten what...
05:43:53 <mvw> darius: any interesting discussion you saw anywhere? :)
05:44:26 <mvw> shapr: thank you for your comments!
05:44:40 <mvw> stelle: u 2
05:45:32 <shapr> hi vegai 
05:45:42 * vegai bows at sharp.
05:45:49 * shapr boings at vegai 
05:47:04 <Darius> shapr: I implemented reify and reflect in direct style in Scheme and found an example of something that needs laziness annotations to be conveniently expressed.
05:47:36 <shapr> interesting, do you have the source online?
05:48:40 <Darius> It's only about 10 lines of Scheme.
05:49:30 <shapr> I wanna see!
05:49:38 <shapr> not that I've done any scheme lately
05:49:57 <blackdog_> shapr: modelchecking sets up some predicates that should hold on all states, then iterates over all states checking the predicate. theorem proving does everything in terms of formal logic. so modelchecking can't deal with big statespaces easily, and theorem proving can't go all that far without human help.
05:50:09 <blackdog_> </terrible explanation>
05:50:16 <Darius> I still haven't quite gotten a monadic version to work in Haskell.
05:52:42 <mvw> blackdog: the problem seems to be the translation from logic (CTL, LTL, FO, MSO..) to finite automata, e.g. quantors needing to be translated into deterministic automata -> power set construction -> bang!
05:55:06 <mvw> is it true the the pentium bug was caused by someone taking a bad proof into his model checker?
05:55:45 <blackdog_> mvw: yes, that. :)
05:56:32 <blackdog_> one of my lecturers once put it nicely; The problem with engineers is that they cheat in order to get results.
05:56:35 <blackdog_> The problem with mathematicians is that they work on toy problems in order to get results.
05:56:38 <blackdog_> The problem with program verifiers is that they cheat on toy problems in order to get results.
05:59:11 <mvw> i just start with model checking, listening to a lecture by prof. thomas in aachen over the internet, very interesting
06:03:53 <ski> Darius : a reflected lazy list monad ???
06:05:03 <Darius> If that's in reference to the thing I couldn't do conveniently without laziness annotations than no.  Lazy streams are easy to implement in Scheme.
06:05:15 <ski> shapr : (btw iirc in the new qc paper they talk some about hoarse triples)
06:05:41 <ski> i mean : by using monadic refection
06:05:47 <ski> reflection
06:06:52 <Darius> That would only make it easier as the only way to get at the stream then would be via the operators provided, which could delay things as necessary.
06:07:33 <ski> just trying to grasp/ask what you were trying to do ...
06:08:02 <ski> (and did in Scheme)
06:08:25 <Darius> It's just a Scheme implementation of the stuff in "Representing Monads".
06:09:08 <ski> ok, i guessed it was related to that  (as opposed to tfpe, say)
06:10:02 <SyntaxPolice> so the mango fairy left two mangos last night, and a note.
06:10:12 <ski> i have some few times been struggling to (correctly) express reify and reflect in haskell
06:12:03 <ski> SyntaxPolice : the mango fairy again ?  have you found out who it is yet, then ??  what was written in the note ?
06:12:27 <Darius> My monadic version (which partly defeats the point) works for some monads, but for e.g. the state monad I need the continuation monad inside the action which is causing typing issues.
06:13:18 <ski> SyntaxPolice : also, have you spared any mango part for us on #haskell ?
06:13:55 <ski> Darius : yeah, i know (about seemingly point defeating)
06:14:16 <SyntaxPolice> ski: I don't know who it is yet.  The note this time was a little opaque... hinting that there may be more than one mango fairy in actual fact.
06:14:39 <ski> have you expressed a shift and reset, then ?  or are you implementing reify and reflect, directly from raw continations ?
06:14:42 <SyntaxPolice> but I still have some bits for anyone on here.
06:14:59 <ski> SyntaxPolice : cool !
06:15:24 <Darius> I'm using shift and reset
06:15:33 <ski> SyntaxPolice : perhaps we can have one mango fairy each, for every person here :)
06:15:53 * harsha123 wonders what is mango fairy
06:16:59 <ski> with what type of shift (i.e. what is it's type ? :)   does it fit into a monadic interface or not ?   (i.e. what i wonder if is you can have two separate "result" types or not)
06:20:01 <phubuh> in about half an hour, I'll have watched twelve weeks worth of buffy in less than a day
06:20:12 <phubuh> quite an accomplishment, don't you agreE?
06:20:26 <shapr> phubuh: like, totally
06:20:31 * shapr goes all valley girl
06:20:38 <shapr> gag a maggot with a spoon!
06:20:42 <phubuh> hee hee
06:20:57 <phubuh> just the other day, I realized I download video at more than one minute per minute
06:21:00 <shapr> well, we just got the second season of Deep Space Nine on DVD... so ...
06:21:02 <ski> Darius : (i.e. e.g. "3.6. Danvy and Filinski types" in "Monads and Composable Continuations". or "4. Two-level continuations". other ?)
06:21:05 <phubuh> and certainly more than one buffy episode per buffy episode
06:21:08 <shapr> oh, download?
06:22:11 <phubuh> I've basically streamed the entire season :-)
06:22:51 <Darius> shift :: ((a -> Cont r b) -> Cont b b) -> Cont b a; reset :: Cont a a -> Cont r a
06:23:02 <Darius> That's not the Control.Monad.Cont Cont.
06:23:28 <SyntaxPolice> ski: sorta like _everyone_ has a mango fairy?
06:23:35 <SyntaxPolice> and a good angel and a bad angel
06:23:36 <shapr> these are not the monads you're looking for...
06:23:44 <shapr> you will take federation credits...
06:23:52 * shapr tries his Jedi mind tricks on the channel
06:24:35 <SyntaxPolice> shapr!!
06:24:39 <shapr> what??
06:24:41 * earthy never understood the fascination with watching entire seasons of TV series all in one or two sittings
06:24:50 <shapr> earthy: then you never ever want to see that show again
06:24:51 <SyntaxPolice> shapr!!!
06:24:53 <shapr> it's like exorcism
06:24:57 <shapr> what???
06:25:01 <shapr> SyntaxPolice!!!
06:25:11 <shapr> Agent Jones!!!
06:25:16 <shapr> of the HSU!
06:25:24 * SyntaxPolice dances around
06:25:28 * shapr boings furiously
06:25:30 <phubuh> earthy: have you tried it? :-)
06:26:11 <earthy> phubuh: yeah.
06:26:18 <earthy> it's just exhausting and irritating
06:26:32 <ski> SyntaxPolice : or at least, everybody that wants one. but perhaps mango fairies are a scarce/limited resource :(
06:26:43 <earthy> (but then again, I don't usually have on the order of 24*45 minutes to spend in one or two blocks ;))
06:26:44 <Darius> evalCont (do x <- reset (do x <- shift (\k -> k 10 >>= k);return (2*x));return (1+x))
06:26:53 <SyntaxPolice> ski: so far, I enjoy them. if this is a practical joke, it's the best ever.
06:28:37 <ski> Darius : 'twas some time ago i fiddled with the typing of shift and the likes, so i can't immediately say if i recognise the types  :(
06:30:18 <shapr> oh, Ensign Wesley Crusher for US President - http://www.draftwesleycrusher.com/
06:30:31 * Darius never liked Wesley.
06:32:17 <ski> Cthulhu For President, The Dawning of a New Era - http://www.cthulhu.org/
06:32:24 <blackdog_> I watched all of Cowboy Bebop in a day or two... didn't turn me off to any appreciable degree.
06:32:33 * earthy grinz
06:32:37 <phubuh> Ia! Ia!
06:32:37 <blackdog_> then again, Bebop is superlative entertainment.
06:33:49 <blackdog_> somethingpositive.net just did a cthulhu strip, actually. first and last time you'll see an Old One in an apron.
06:34:03 <ski> Y'ai 'ng'ngah  YOG-SOTHOTH
06:35:36 <earthy> see, I knew I could find it: Yes, that's how badly it hurt me: I was actively trying to get a Hooters waitress out of my mind. While my wife was out of town.
06:35:57 <earthy> (by Wil Wheaton, who played young ensign crusher)
06:38:11 <ski> Darius : ok, so you have one result type
06:38:25 <shapr> I haven't seen any Cowboy Bebop, I want!
06:38:54 <blackdog_> shapr: how i envy you.
06:38:56 <shapr> earthy: you have Hooters in .nl?
06:39:19 <shapr> one of the first Hooters restaraunts was in Birmingham, Alabama where I lived
06:39:43 <ski> Darius : can't remember right now if i had some (interesting) example requiring pre and post result types ...
06:40:16 <Darius> I use to have it implemented as Cont o r a but that wasn't working out.
06:40:38 <ski> ok
06:40:38 <vegai> shapr: I've got the series
06:40:46 <ski> why ?
06:40:57 <earthy> yeah, we do have Hooters in .nl
06:41:03 <vegai> shapr: 5,2GB =)
06:41:25 <earthy> I know of only one though, in A'dam, between the central trainstation and Dam square
06:41:58 <shapr> vegai: no thanks, I'll get it legally.
06:42:23 <vegai> shapr: good idea. Certainly worth it
06:42:40 <ski> earth : there is a word/place in dutch/netherlands named "a'dam'" ?  interesting..
06:42:54 <ski> (make that "a'dam")
06:43:44 <earthy> owh, A'dam is just the usual abbreviation for Amsterdam
06:43:54 <ski> oh, ok
06:44:05 <mvw> no to be confused with R'dam 
06:44:07 <earthy> and there isn't a hooters, there's a teasers, which is the same but different. :)
06:44:31 <shapr> R'Lyeh
06:44:32 <shapr> ?
06:44:39 <ski> earthy : i was thinking along a'dam:s in WoT (Wheel of Time)
06:44:55 <shapr> rolling rings of earth and fire! yay!
06:44:57 * mvw just went away to change diapers of daugther and you use that opportunity talk all non haskell stuff here :)
06:45:06 <shapr> whoops
06:45:11 <earthy> I haven't read enough WoT to say anything about that.
06:45:13 <shapr> I could change the diapers on my cat.
06:45:23 <earthy> anyway, back to reading articles.
06:45:28 <shapr> c.l.f?
06:45:38 <earthy> owh, good idea...
06:45:41 <ski> shapr : what about R'Lyeh ?
06:45:52 <Darius> ski: Changing it back, reflect complains about an infinite type.
06:46:05 <shapr> skylan: R'Dam, R'Lyeh, what's the difference?
06:46:41 <mvw>  *
06:46:47 <mvw>   *
06:46:49 <ski> earthy : well, if it is an abbrev. in dutch, the Jordan probably didn't get the term from there ..
06:46:50 <mvw> ***
06:47:02 <ski> mvm : sorry
06:47:04 * earthy nods
06:47:05 <mvw> :)
06:47:56 <ski> Darius : i seem to recall some problems getting satifactory typing also, yes
06:48:43 <mvw> just wanted to ask you about this one: http://www.catb.org/hacker-emblem/faqs.html
06:49:07 <mvw> good marketing or plain stupid?
06:49:08 <ski> shapr : yeah, all the same.    (i take you not mean skylan)
06:50:05 <shapr> er, right
06:50:18 <shapr> I think a clanking replicator is a better hacker emblem
06:50:28 <blackdog_> if you need to advertise that you're a hacker, you almost certainly aren't one.
06:50:38 <shapr> blackdog_: good point
06:51:03 <shapr> didn't von neumann's first cellular replicator take 180x180 squares and eight states in each square?
06:51:22 <shapr> or was that von neumann who was researching self-replicating patterns?
06:53:24 <shapr> hi sild 
06:53:38 <shapr> what do you think of ESR's hacker emblem?
06:54:18 <shapr> sild: looking for Haskell info?
06:55:18 <shapr> crap, have I failed my Turing Test again?
06:55:28 <blackdog_> <groan>
06:55:35 * shapr snickers
06:56:05 <shapr> that's what she said...
06:56:15 <shapr> what's seafood doing lately?
06:56:53 <shapr> sild: seriously, are you learning Haskell?
06:57:24 <sild> shapr: oh, sorry, yes
06:57:38 <shapr> great, do you have any questions? (other than whether I'm a bot)
06:57:42 <sild> :b
06:57:56 <shapr> :-√ê
06:58:10 <blackdog_> shapr: sean's upstairs watching Alan Partridge episodes and Ninja Scroll
06:58:15 <sild> yeah, I wasnt sure if it was too trivial though :b (I didnt want to get a 'go read a book' type answer ;))
06:58:24 <shapr> sild: you'll probably get both answers from us :-)
06:58:28 <blackdog_> bastard always finishes stuff with time to spare... it's infuriating.
06:58:33 <shapr> blackdog_: hehe!
07:00:46 <sild> think I've kind of realised the problem now, or at least stopped looking in the wrong place (I stupidly trusted the line number given in hugs' error msg)
07:01:20 * mvw wonders if any really let loose a talk bot on an irc channel
07:01:25 <ski> sild : problems with ";" ?
07:01:37 <Darius> Compilers for most languages don't always get the correct line.
07:02:02 <sild> Darius: yeah, but for some reason I thought hugs might
07:02:33 <sild> ski: errors about 'Instance of Num <type> required for definition of f'
07:02:51 <blackdog_> sild: hugs isn't really the best interpreter around any more. you'll probably get better error messages from ghci. (If you're not using a lot of typeclass hackery, Helium might be even better.)
07:03:00 <ski> ok, that kind of error
07:03:34 <sild> blackdog_: the uni uses hugs, probably best if I stick with it
07:04:13 <mvw> the FreeBSD ports collection offers hugs, ghc, generic-haskell - why should i use ghc?
07:06:18 <shapr> cuz it's cool
07:06:28 <shapr> actually, because it has the most features, imho
07:06:32 <blackdog_> cuz chixdiggit.
07:06:39 <shapr> yah, sure :-)
07:07:03 <blackdog_> no, really... "wanna come up and see my typeclasses?"
07:07:08 * shapr snickers
07:07:17 <shapr> let's do some higher order combining...
07:08:37 <blackdog_> unsafePerformIO? I'm not that kind of girl...
07:08:47 * shapr laughs!
07:08:49 <mvw> changing diapers makes it a bit less attractive :)
07:09:00 <shapr> side effects...
07:09:04 <shapr> they'll get you in the end...
07:09:34 <shapr> mvw: but seriously, GHC has the Network libs, and lots of extra features that are worthwhile
07:09:47 <earthy> helium *does* have the best errors for that subset of Haskell that it accepts
07:10:19 <mvw> is there a haskell mode for Emacs?
07:10:27 <earthy> for learning it just wins big
07:10:47 <shapr> mvw: sure, haskell-mode is nice
07:11:06 <ski> mvw : http://www.haskell.org/libraries/#editormodes
07:11:22 <shapr> or http://www.haskell.org/hawiki/HaskellMode
07:11:27 <sild> installing helium now heh
07:11:41 <shapr> hi sphinx 
07:11:53 <tomas> hi
07:11:53 <shapr> tomas: I am not a bot.
07:11:57 <tomas> ok
07:12:08 * shapr looks evilly at sild 
07:12:28 <shapr> so tomas, do you have Haskell questions?
07:12:32 <sild> :b
07:12:44 <mvw> helium is in the ports collection as well, interesting
07:12:46 * shapr grins evilly
07:13:20 <mvw> and ghc is only 5megs, that is not much
07:14:13 <blackdog_> knock it off, shapr, you're about as evil as big bird.
07:14:27 <ski> shapr : now you are supposed to say "and Cthulhu will eat you all ! Bwahaha !"
07:14:52 <blackdog_> well, that would have made sesame street a lot more gripping.
07:15:30 <shapr> I think I'm primarily chaotic rather than evil
07:15:42 <shapr> blackdog_: scary thought...
07:17:23 <ski> shapr : thats not bad :)
07:18:07 <mvw> shapr: i just read the wikipedia entry on cranking replicator - there is no one - how could we make it a logo??
07:18:24 <shapr> I don't know :-)
07:18:53 <shapr> ski: sometimes chaotic is more trouble than evil.
07:18:53 * mvw must again change diapers, oh noo
07:19:58 <shapr> hei aleator 
07:20:07 <shapr> do you know ibid?
07:20:25 <aleator> Yes, casually.
07:20:52 <sild> bleh I was just missing some brackets ;(
07:24:30 <shapr> aleator: looking for Haskell info?
07:26:13 <aleator> Yup. I'm trying to make reasonable "suspendable computation" monad.. But I'm lacking a bit..
07:27:23 <ski> suspendable in what way ?
07:27:41 <ski> coroutine-like ?
07:28:11 <aleator> Yes. 
07:28:16 * aleator googles..
07:28:46 <Darius> Are you trying to make one for the heck of it or do you just need one?
07:28:59 <ski> just two alternating, or many ? should they pass any value when yielding ?
07:29:01 <aleator> Didn't actually think of them as coroutines, though.
07:29:21 <aleator> Several alternating.
07:30:03 <ski> like threads, then (perhaps not preemtive though) ?
07:31:10 <aleator> Well. The thing what I'm after is a blackboard and few agents waiting for others to scribble on it..
07:32:05 <mvw> i just read a funny number. guess: how many commandline options has java 1.4.1?
07:32:39 <ski> aleator : perhas http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/Papers/concurrent-claessen.ps is of interest ?
07:32:42 <blackdog_> is it in three digits?
07:32:55 <mvw> yes
07:33:42 <aleator> ski: Thanks. I'll look into it.
07:33:50 <ski> mvw : 496 ?   945 ?
07:33:54 <ski> mvw : 276 ?
07:33:59 <blackdog_> **** a duck, i was joking... that's insane.
07:34:00 <mvw> 224! http://www.javaperformancetuning.com/news/contents035.shtml
07:34:25 <ski> mvw : (none of those chosen randomly)
07:34:37 <shapr> wow, Java has more flags than GHC
07:34:39 <shapr> I'm impressed.
07:34:44 <mvw> i am shocked 
07:35:08 <ski> would have been more fun with 220  (or 284)
07:35:11 <mvw> and it is not 224 facultiy - or what is the english word for the ! operation? :)
07:35:31 <shapr> what's the german word?
07:35:36 <shapr> or dutch?
07:35:39 <shapr> or swedish?
07:35:48 <mvw> german: fakultdt
07:35:51 <mvw> german: fakultaet
07:36:06 <mvw> which is same word as facultiy (university department)
07:36:11 <shapr> hm, sounds like faculty
07:36:11 <ski> swedish : fakultet
07:36:39 <shapr> I dunno
07:36:55 <mvw> java is overdimensioned in many aspects
07:37:49 <mvw> is haskell usually compiled into native coder or interpreted?
07:38:43 <mvw> shapr: btw the options were no compiler options, but runtime interpreter options, perhaps jit options
07:38:43 <Darius> compiled
07:39:03 <mvw> how fast compared to c?
07:39:14 <Darius> It depends on the effort you put into it.
07:39:43 <Darius> You can get some code to be as fast as C, but if you aren't careful it can be -much- slower.
07:40:29 <mvw> is there any application area where haskell shines?
07:42:25 <shapr> abstraction?
07:43:20 <mvw> is there a killerapp? (besides quickcheck? :)
07:43:33 <tic> J. Hughes has written QuickCheck, right?
07:44:05 <mvw> yes, i need to give a seminaire talk on that 
07:44:27 <mvw> and coen claessen
07:45:29 <ski> koen
07:45:33 <blackdog_> it's really nice for writing haskell compilers. </deadpan>
07:46:07 <earthy> haskell is used for a number of other projects as well
07:46:11 <earthy> see the HC&A report
07:46:20 <shapr> lambdabot is a great killer app ;-)
07:46:30 <shapr> actually, check out darcs - http://www.abridgegame.org/darcs/
07:46:46 <ski> @yow
07:46:46 <lambdabot> Why is it that when you DIE, you can't take your
07:46:46 <lambdabot>  HOME ENTERTAINMENT CENTER with you??
07:48:23 <blackdog_> @arr
07:48:23 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
07:48:40 <blackdog_> bluebeard's getting saucy.
07:49:21 <shapr> :-)
07:53:12 <Darius> Someone's been reading too much c.l.f... and so has ski.
07:56:14 <blackdog_> clf's my secret vice. it's a sick sad world.
08:05:12 <shapr> it's SAKE TIME!
08:05:22 * shapr forsvinner
08:11:25 <mvw> @arr?
08:11:26 <lambdabot> Sorry, I don't know the command "arr?", try "lambdabot: @listcommands"
08:11:36 <mvw> heck
08:11:40 <mvw> @heck
08:11:40 <lambdabot> Sorry, I don't know the command "heck", try "lambdabot: @listcommands"
08:11:50 <mvw> @too @bad
08:11:51 <lambdabot> Sorry, I don't know the command "too", try "lambdabot: @listcommands"
08:12:34 <mvw> one should recode that into some tamagotchi
08:14:54 <mvw> why is there a ghc5 and ghc6 in the ports collection - is ghc6 experimental?
08:17:15 <SyntaxPolice> ghc6 is not particularly experimental, no.  which ports collection do you speak of?
08:19:21 <Igloo> It'll be because some thing will need a bit of tweaking to work with ghc6 I suspect
08:40:48 <mvw> freebsd's ports collection
09:25:44 <keverets> @yow
09:25:44 <lambdabot> Where's my SOCIAL WORKER?
09:26:26 <blackdog_> @listcommands
09:26:26 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define","definitions","del-definition","devils","dict","dict-help","dummy","dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements","eval","foldoc","foo","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","lojban","more","msg","part","prelude
09:26:52 <blackdog_> @arr
09:26:53 <lambdabot> Drink up, me hearties
09:34:53 <Darius> @listmodules
09:34:56 <lambdabot> I have the following modules installed: ["base","cmafihe","dict","dummy","dynamic","eval","hello","karma","more","quote","seen","state","system","topic","type"]
09:35:21 <Darius> @listcommands dummy
09:35:21 <lambdabot> Module dummy provides the following commands: ["dummy","foo"]
09:55:06 <elmex> @eval 2
09:55:06 <lambdabot> 2
09:56:01 <elmex> @eval (define test (lambda (x) (display x)))
09:56:01 <lambdabot> unbound variable: define
09:57:40 <elmex> it's broken ;-)))
09:57:47 <vegai> =)
10:28:35 <Lunar^> shapr: Ever heard of Jacob Zimmerman ?
12:06:11 <pimpbot5001> hi, is anyone here familiar with the ForeignPtr module?
14:56:33 <pimpbot5001> anyone here?
14:57:43 <Riastradh> Yes.
15:00:28 <dark> I'm here intermittently.
15:01:33 <pimpbot5001> hi, does anyone know how to get tail recursion in the GHC
15:02:09 <dark> "get" in what way?  You mean force the compiler to not compile it to something iterative?
15:02:10 <pimpbot5001> i wrote a fairly tight tail recursive function, but it ballons out and takes like 9MB of stack spacew
15:03:11 <dark> Ah, you want GHC to optimize away tail recursion.  Unfortunately, GHC optimization is black magic.  Fortunately, you get a spell book.
15:03:21 <pimpbot5001> sweet!
15:03:37 <Riastradh> GHC doesn't do TCO by default?!
15:03:43 <dark> Usually strictness is the answer.  Can you show the function?
15:03:51 <pimpbot5001> yes
15:03:53 <pimpbot5001> one sec
15:03:56 <dark> Riastradh: It should, but it can't always figure it out :)
15:04:12 <Riastradh> dark, what do you mean 'it can't always figure it out?'
15:04:13 <pimpbot5001> fillArr :: Array -> Int -> Double -> Array fillArr arr n x = if n < 0     		  then arr 	          else let arr' = writeArr arr n x in 			 fillArr arr' (n - 1) x
15:04:48 <pimpbot5001> so here's the deal, im doing something rather hackish in that code
15:04:59 <pimpbot5001> the writeArr is side-effecting an array
15:05:19 <Riastradh> Is writeArr tail-recursive?
15:05:35 <pimpbot5001> but every time it does that, writeArr returns a new pointer to the array...write array is this:
15:05:49 <pimpbot5001> writeArr :: Array -> Int -> Double -> Array writeArr fptr ix x = unsafePerformIO $          do 	 let ptr = foreignPtrToPtr fptr 	 addr <- peek ptr 	 if addr == nullAddr 	    then return undefined 	    else do 		 poke ptr nullAddr 		 writeC addr ix x 		 newPtr <- mallocForeignPtr 		 poke (foreignPtrToPtr newPtr) addr 		 return newPtr
15:06:18 <Riastradh> Does writeArr cause immense stack usage?
15:06:30 <pimpbot5001> yea
15:07:03 <Riastradh> That probably has something to do with it, then.
15:07:47 <pimpbot5001> so is it my slight of hand with the IO monad maybe?
15:08:01 <dark> Are you sure it's stack usage?  mallocForeignPtr allocates space, right?
15:09:07 <pimpbot5001> yes, but i've actually turned it off and the same effect 
15:09:09 <dark> I assume that Array is not the one from Data.Array.
15:10:49 <dark> I think the first thing to do is to figure out where the space is going.
15:11:50 <pimpbot5001> ok, what's the profiler for ghc called?
15:12:43 <dark> If you compile with -prof -auto, and then run with +RTS -hc, you'll get profiling information about which functions allocate memory.
15:13:12 <pimpbot5001> ah excellent!
15:13:20 <dark> Hmm, I haven't done this in a while, but I think the program hp2ps is the one that converts all this profile data to a graph.
15:13:50 <pimpbot5001> ah that would be helpful
15:15:20 <dark> Another useful option is -hd, which counts allocated space by data constructor.  That can be the critical clue or it can be useless, depending.  It often tells me that most of the data is list elements, or closures :)
15:15:27 <dark> But sometimes it'll point directly at the culprit.
15:15:45 <dark> Chapter 5 of the GHC user's guide is all about profilling.
15:16:33 <dark> If you want to dig deeper, you can use specially-formatted comments to mark individual expressions for profiling, without having to make them separate functions.  
15:16:59 <dark> I last used all this about a year ago to optimize a pathfinding function, so I'm a little rusty :)
15:17:01 <pimpbot5001> ok cool, thanks!
15:17:22 <pimpbot5001> hmm this is weird, fs.prof is empty
15:18:44 <pimpbot5001> ah ok
15:18:47 <pimpbot5001> -auto-all
15:18:55 <dark> Hmm, there might be a +RTS flag missing.
15:19:53 <dark> Yeah you need +RTS -p to profile at all.
15:20:14 <dark> Or is that just for time profiling?
15:20:36 <pimpbot5001> yea i think so
15:20:42 <pimpbot5001> but it's still being useful
15:20:55 <pimpbot5001> do you know offhand if calling C methods is really costly?
15:20:58 <dark> Ok.  Ah yeah, if you have a single module that exports nothing then -auto does nothing :)
15:21:11 <pimpbot5001> if im calling a pure c call
15:21:11 <dark> No, it should have no overhead.
15:21:20 <pimpbot5001> ok good
15:21:22 <dark> Only if you need to marshal strings or something.
15:21:47 <dark> GHC will compile via C, so a C method call translates just to a C function call :)
15:22:15 <pimpbot5001> hehe, writeArr consumes 88% of the allocation space
15:22:21 <dark> There might be some work involved in the fromIntegral functions if you need to translate between Integer and CInt.
15:23:32 <pimpbot5001> ah so maybe ill try using all CInts
15:24:02 <dark> Nah, translating between Int and CInt should cost nothing.  But Integer requires the multiprecision libs et.
15:24:54 <pimpbot5001> yea im using all ints and doubles
15:25:01 <pimpbot5001> no infinte precision numbers here
15:26:09 <dark> How is Array defined?
15:26:54 <pimpbot5001> type Array = ForeignPtr Addr
15:28:37 <shapr> oy
15:29:15 <pimpbot5001> is that pretty slow?
15:29:57 <shapr> hoi dark
15:42:22 <dark> shapr, hello :)
15:42:40 <dark> pimpbot: No I'm just trying to read your function.
15:44:35 <dark> pimpbot: I suggest Data.Array.Unboxed if you really want speed, then you don't have to design it yourself :)
15:44:55 <pimpbot5001> hehe, well im actually writing a new array library for a research project
15:45:01 <pimpbot5001> this is just the basic stuff
15:45:35 <pimpbot5001> the prof doesn't like depending on monads...and he's one of the first to think of using lazy evaluation in scheme
15:46:14 <pimpbot5001> so he wanted to do things a in quite a different way than the haskell people do
15:46:31 <Riastradh> What kind of crazy person is he who doesn't like depending on monads?
15:46:58 <dark> Er... but writeArr is very monadic!
15:48:17 <pimpbot5001> hehe
15:49:00 <pimpbot5001> indeed, we've discussed this...it's up to me how i will implement his array libraries...but he wants to low-level stuff to be non-monadic
15:49:09 <pimpbot5001> well, officially non-monadic
15:49:25 <pimpbot5001> even though it's pretty much isomorphic
15:49:54 <pimpbot5001> he was actually on the comittee that designed haskell...this was a while back tho
15:53:00 <shapr> who is this guy?
15:53:01 <pimpbot5001> the prof that is...so it's funny he doesn't want to depend on monads
15:53:05 <pimpbot5001> david wise
15:53:12 <pimpbot5001> www.cs.indiana.edu/~dswise
15:54:21 <shapr> interesting
15:56:11 <pimpbot5001> ok this is still quite weird
15:57:14 <pimpbot5001> fillArr is, by itself, consuming ~100k of alloced space
16:00:30 <pimpbot5001> AHA!
16:00:51 <pimpbot5001> compiling with -O2 squashed the allocation space mightily
16:00:53 <pimpbot5001> hehe
16:00:58 <dark> Er, yeah :)
16:02:40 <pimpbot5001> does anyone know what the benefits of -fvia-c are?
16:37:20 <dark> pimpbot: I think -O2 and -ffi already turn that on.
16:37:38 <dark> It means ghc gets to use gcc's code generators instead of its own.
16:38:00 <dark> gcc is a lot better at low-level optimization.
16:49:31 <pimpbot5001> ok cool
16:54:02 <pimpbot5001> does anyone know why FFI return values fail when using -O ?
16:54:15 <pimpbot5001> foreign import ccall readC :: Addr -> CInt -> Double
16:54:22 <pimpbot5001> that works without -O
16:54:44 <pimpbot5001> but with -O I get a large nonsense number
16:55:39 <Smerdyakov> Perhaps the error is in the foreign readC code?
16:56:26 <pimpbot5001> hmm, doubt it... readC is one line.  return arr[i];
16:59:00 <dark> You need to return CDouble and then convert it.
16:59:06 <dark> I'm not sure why it would have worked before :)
17:10:21 <Darius> Unboxing maybe
