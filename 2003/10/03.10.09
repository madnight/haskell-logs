02:42:56 <danols> anyone alive ? i need help
04:32:09 <harsha123> Igloo: where can i get docs on the debian installer? 
04:32:15 <harsha123> Igloo: http://cvs.debian.org/debian-installer/doc/html/
04:32:36 <harsha123> this link takes me to the page.. but i cannot read it
04:32:51 <harsha123> shapr: hi
04:54:43 <Lunar^_> buddha is so nice !
05:05:56 <harsha123> buddha?? what buddha?
05:06:56 <ski> declarative debugger for haskell, i presume ...
05:07:29 <ski> http://www.cs.mu.oz.au/~bjpop/buddha/
05:07:54 <clausen> ah, I know him
05:08:02 * clausen also at cs.mu.oz.au
05:08:03 <ski> whom
05:08:07 <clausen> bjpop
05:08:11 <clausen> (Bernie Pope)
05:08:19 <ski> k
05:08:30 * clausen is aclausen there...
05:10:13 <ski> ok. then you perhaps know people like fergus henderson,conway,zoltan somygi(?) ...
05:10:20 <clausen> yep
05:10:41 <clausen> zoltan was one of my lecturers
05:11:01 <clausen> I know Bernie better than all the others, though
05:11:03 <clausen> (socially)
05:11:16 <ski> he (zoltan) looks kinda cool, i think
05:11:51 <ski> is Bernie involved in Mercury too ?
05:22:41 <clausen> ski: not really
05:22:47 <clausen> ski: zoltan is rather odd
05:22:57 <clausen> he certainly has "cult" status here
05:23:05 <clausen> but doesn't seem to be be particularly social
05:23:20 <clausen> (some students have photos of him as their background picture!!!)
05:23:25 <ski> ok
05:23:28 <ski> :)
05:23:32 <ski> lol
05:24:07 <clausen> he has a reputation for not tolerating sloppy arguments
05:24:22 <clausen> my supervisor recommended I try to write as if my audience was "Zoltan on a bad day"
05:24:31 <clausen> (my thesis)
05:24:46 <ski> lol again
05:44:18 <phubuh> hi!
05:44:25 <ski> hi..
06:07:28 <seafood> Hey guys. Anyone know where I can get a copy of Cayenne? I can't seem to download it from Lennart Augustsson's page. Annoying.
06:12:37 <seafood_> Woah. I had huge lag.  So, anyone got a copy of Cayenne lying around on their hard drive?
06:13:00 <blackdog> connection keeps going down. Don't know why, it doesn't show up in the logs.
06:13:34 <ski> .. looking around here at chalmers system ...
06:13:58 <seafood_> ski: thanks.
06:17:06 <ski> hmm ... can't find it anywhere on ftp.cs.chalmers.se at least ...
06:17:51 <seafood_> lennart hasn't answered any of my email either.
06:17:59 <seafood_> I've only hassled him twice though. I'll try again.
06:19:07 <ski> :)
06:32:39 <ski> hmm, i've think i've found a compiler and cayenne libs on local systems ....,  no distro or source found yet, though
06:35:05 <seafood_> h
06:35:14 <seafood_> sorry
06:35:28 <ski> h ?
06:40:40 <seafood> I thought I'd been kicked off, but I hadn't. h is nonsense typing.
06:43:21 <ski> also, i've found a home dir of account ~augustss, i don't think this has been much in use for the last 13 years, say :) (though, he seems to have logged in on a machine here last time in the year 1999, judging from the .xsession-errors file) ...
06:48:33 <seafood> hmmmm. Maybe Cayenne just is current anymore.  Maybe he hasn't been interested in it lately.  
06:48:45 <ski> i dunno
06:50:43 * shapr boings cheerfully
06:50:53 * shapr sings Ode to Joy at window shattering volume
06:51:17 <ski> heh
06:51:29 <ski> what kind of music is that ?
06:51:40 <shapr> Bach I think
06:51:55 <shapr> oh, Beethoven, doh
06:52:21 <ski> ok
06:52:29 <shapr> http://www.bachfaq.org/odetojoy.html
06:53:03 <shapr> g'day seafood 
06:53:07 <seafood> It's Baroque house misc :-)
06:53:20 <seafood> shapr: hi!
06:53:32 <shapr> Baroque is when you're out of Monet, right?
06:54:44 <seafood> shapr: I love that joke :-)
06:54:53 <kosmikus> apropos cayenne: what is the problem with http://www.math.chalmers.se/~augustss/cayenne/ ?
06:56:14 <seafood> kosmikus: Can you connect? I can't.
06:56:20 <kosmikus> yes, I got the file
06:56:32 <seafood> any way that you can pass it on to me?
06:57:04 <seafood> I just can't connect to it, either using my browser or via command line ftp.
06:57:13 <ski> kosmikus : no prob with the site, i think. but download link seems broken
06:57:23 <kosmikus> worked for me
06:57:34 <kosmikus> try www.andres-loeh.de/cayenne.tgz
06:57:46 <ski> seafood : are you able to connect to the site or not ?
06:59:20 <ski> kosmikus : 403 Forbidden   The server has no permission to   ...
06:59:26 <kosmikus> again?
06:59:42 <ski> "again?" ?
06:59:49 <kosmikus> I fixed the permissions of the file
06:59:51 <shapr> ""again?" ?" ?
06:59:51 <ski> ok, works now
07:00:18 <seafood_> I just had some connectivity problems. Is the file downloadable now?
07:00:23 <ski> shapr : "\"\"again?\" ?\" ?" ?
07:00:34 <shapr> :-)
07:00:58 <kosmikus> seafood: if you cannot get it from the original page, try to fetch it from my page now
07:01:05 <kosmikus> I will remove it again, though, in about 5 minutes
07:01:11 <seafood_> kosmikus: thanks.
07:01:18 * shapr quickly grabs the warez from kosmikus' site
07:01:39 <ski> kosmikus : it seems like i can unpack the file, yes
07:02:55 <kosmikus> seafood_: got it?
07:03:13 <seafood_> kosmikus: sorry. where is it on your page. Oh and hi! Great to hear from you again.
07:03:24 <kosmikus> www.andres-loeh.de/cayenne.tgz
07:03:34 * ski laughs
07:03:53 <shapr> hot warez! even named after a pepper!
07:04:05 <kosmikus> seafood_: yeah, hi again
07:04:17 <seafood_> kosmikus: yeah, got it. Thank you ever so much.
07:04:39 <kosmikus> okay, distribution time's over, then :)
07:09:54 <seafood_> I must have some dodgy version of ftp then. For I keep getting the error "ftpd: Unknown flag -a ignored."
07:14:11 <shapr> hi croesus 
07:14:23 <croesus> heya shapr
07:14:28 <shapr> wassup?
07:14:41 <croesus> nada mucho, and you?
07:14:56 <shapr> being lazy at the moment
07:15:32 <croesus> sweet
07:15:45 <shapr> seafood: why are you running ftpd?
07:15:55 <shapr> seafood: isn't that the server?
07:15:59 <shapr> rather than the client?
07:17:02 <seafood> shapr: I don't think it's me that's running that.
07:17:12 <seafood> I think that's the error I'm getting from chalmers.
07:17:55 <seafood> shapr: Just install new client. lftp. Can get in now.
07:19:44 <syntax-laptop-> hey seafood!
07:22:07 <seafood> syntax: Hey, how you going?
07:22:23 <SyntaxPolice> go away syntax-laptop-
07:22:32 <SyntaxPolice> seafood:  pretty good
07:22:52 <reffie> fuck the police!
07:22:59 <SyntaxPolice> been busy here doing java work instead of Haskell for a bit, but we're seeing the light at the end of the tunnel
07:23:04 <SyntaxPolice> reffie: get in line
07:23:09 <reffie> heh
07:23:13 <seafood> SyntaxPolice: I'm trying to get Cayenne installed an running so that I can play around with dependent types.
07:23:26 <SyntaxPolice> hm. what is cayenne?
07:23:29 <seafood> SyntaxPolice: Good old undecidable typing systems :-)
07:23:44 <seafood> SyntaxPolice: A language designed by Lennart Augustsson.
07:24:49 <SyntaxPolice> sounds like fun :)
07:32:32 <seafood> *Sigh* Another question. Where is lmlc on the ftp site?
07:35:07 <seafood> Oh. Is this right? hbc and lmlc come in the same tarball?
07:41:17 <kosmikus> seafood: that is possible at least, because hbc also uses LazyML as backend
07:44:37 <det> seafood, undecidable typing systems ?
07:45:34 <seafood_> det: type checking in Cayenne is undecidable since it is such a powerful type system.
07:46:02 <det> so it cant type check your programs ?
07:46:04 <seafood_> det: check out the paper on Lennart Augustsson's site.
07:46:27 <seafood_> det: No. It can. Just not always.
07:46:52 <seafood_> det: In the same sense that a program sometimes doesn't terminate, the type checker sometimes doesn't. Lots of people think this is a bad idea.
07:47:09 <seafood_> det: Having your compiler not terminate doesn't sound like a very good thing.
07:47:12 <det> the type checker sometimes doesnt terminate? :p
07:47:21 <seafood_> det: In Cayenne, yes.
07:47:34 <det> I hear the programs always terminate however :p
07:47:37 <det> what a crazy tradeoff
07:47:48 <seafood_> det: In Cayenne?
07:47:55 <det> yes
07:48:02 <seafood_> det: Hmm, i haven't heard that. 
07:48:12 <det> ski said yesterday that it doesnt have non-termination
07:48:29 <det> and recursion only in the form of some kind of fold
07:48:32 <seafood_> det: Wow. I'll have to talk to him about it.
07:48:33 <det> so it is not turing complete
07:48:40 <seafood_> det: Nah, it's got to be.
07:52:42 <det> oops
07:52:47 <det> I am confusing it with Charity
08:05:57 * shapr chortles merrily
08:25:26 * Igloo resists the temptation to reply to SPJ asking "I suppose I need to get libgnome. How do I do that?" with "apt-get install ..."  :-)
08:34:39 <SyntaxPolice> Igloo: hehe
09:15:55 <shapr> Igloo: aww, it's a great reply!
09:41:57 <Markus> C++: mylist[index]  . How do i do the corrosponding thing in Haskell with a list?
09:42:55 <esap> markus: (!!) [but note it's linear time, not constant time].
09:43:18 <Markus> thanks
09:43:38 <Markus> the longer a list is the longer it takes then...
10:02:56 <tez_> \quit
10:02:58 <tez_> \quit
10:03:13 <Markus> hoho =)
10:04:01 <Markus> what are you doing tez?
10:09:34 <phubuh> Markus: it's likely that you don't actually need to use (!!)
10:10:34 <Markus> well, i found out another way
10:11:13 <Markus> its equally bad =)
10:11:19 <Markus> but, it works
10:13:31 <Markus> Now im using Kate, displaying hugs in the terminal, and editing the code in the main window. Its not a great editor, but nice colours...
10:13:44 <Markus> built in terminal
10:13:46 <Markus> in kate
10:14:25 <Markus> ...
10:51:31 <det> do you need another combinator other than Y for mutual recursion ?
10:52:15 <ski> where ?
10:58:08 <det> "where" ?
10:58:35 <det> in a polymorphic lambda-calculus'y language
10:59:04 <ski> lazy ?
10:59:26 <det> no
11:00:53 <det> but I am curious as to how that might chagne things
11:01:07 <ski> well
11:01:20 <ski> say, define odd,even
11:01:34 <ski> of type Nat -> Bool
11:01:57 <ski> hm
11:02:48 <ski> given perhaps   natCase :: a -> (Nat -> a) -> (Nat -> a)
11:03:49 <det> you mean define a function to detrimine a Natural number to be odd or even ?
11:04:21 <ski> (even,odd) = Y \evenOdd. (natCase True (snd evenOdd), natCase False (fst evenOdd))
11:04:23 <ski> yes
11:04:44 <ski> does that work
11:04:45 <ski> ?
11:05:49 <ski> hm
11:06:14 <det> brb
11:08:21 <det> I mean like
11:08:36 <det> defining 2 functions
11:09:00 <det> fun a x = b x
11:09:01 <det> and
11:09:06 <det> fun b x = a x
11:09:09 <det> for example
11:09:44 <det> where the functions recurse each other
11:09:58 <det> I was wondering if you need another recursion combinator other than Y
11:14:58 <det> like this in ocaml
11:15:00 <esap> I guess you can build mutual recursion by combining Y and function composition: Y (f . g)
11:15:15 <det> let rec a x = b x
11:15:21 <det> and b x = a x
11:15:35 <det> hmm
11:16:05 <ski> (back)
11:17:01 <ski> i just tried to write even and odd above in ocaml
11:17:37 <ski> the "let (even,odd) = y (fun (e,o) -> ...)" loops
11:17:49 <ski> but this works, say in haskell
11:18:05 <ski> remember how y is defined (recursively)
11:18:14 <ski> y f = f (y f)
11:18:56 <ski> in strict languages (like SML,O'Caml,Scheme) this doesn't work, so we do instead :
11:19:03 <ski> y f x = f (y f) x
11:19:24 <ski> note :  the first y has type  (a -> a) -> a
11:19:46 <ski> the second has type  ((a -> b) -> (a -> b)) -> (a -> b)
11:20:38 <ski> in the even/odd example above, i was trying to use y at this type :
11:21:17 <ski> ((Nat -> Bool,Nat -> Bool) -> (Nat -> Bool,Nat -> Bool)) -> (Nat -> Bool,Nat -> Bool)
11:21:48 <ski> i.e. the second type for y is the first one, with a changed to (a -> b)
11:22:25 <ski> this latest type (instance) of y has the original a changed to (Nat -> Bool,Nat -> Bool)
11:23:06 <Joopdod> Has someone succesfully installed HSQL-1.0? 
11:23:12 <ski> these two latest types does not unify !   (no type is an (substitution) instance of both)
11:23:28 <ski> det : see ?
11:23:50 <ski> esap : how do you mean ?
11:24:56 <det> I am thinking
11:25:53 <esap> ski: think of \f g -> fix (f . g). It has type forall b c. (b -> c) -> (c -> b) -> c.
11:27:34 <ski> esap : hmm, haven't though of or seen that before :)  does this only work for two mutually recursive functions, which always are alternating (only calling eachother, not themselves) ?
11:27:53 <shapr> Joopdod: I've used a pre-1.0 HSQL with lambdabot 
11:28:14 <esap> ski: yes, that's the idea. You can of course pass the argument through to allow the other function to call himself too...
11:28:40 <ski> esap : yes, was just thinking of that.. hmmm ..
11:29:34 <det> # let rec y f x = f (y f) x;;
11:29:34 <det> val y : (('a -> 'b) -> 'a -> 'b) -> 'a -> 'b = <fun>
11:29:35 <det> # let fog f g x = f(g(x));;
11:29:35 <det> val fog : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b = <fun>
11:29:35 <det> # let mr f g = y (fog f g);;
11:29:35 <det> val mr : ('a -> 'b -> 'c) -> (('b -> 'c) -> 'a) -> 'b -> 'c = <fun>
11:29:36 <det> # let a b x = b x;;
11:29:38 <det> val a : ('a -> 'b) -> 'a -> 'b = <fun>
11:29:40 <det> # let b a x = a x;;
11:29:42 <det> val b : ('a -> 'b) -> 'a -> 'b = <fun>
11:29:44 <det> # let inf = mr a b;;
11:29:46 <det> val inf : '_a -> '_b = <fun>
11:29:48 <det> # inf 2;;
11:29:50 <det> <infinite loop ensues>
11:29:52 <ski> esap : perhaps one could make, like a circular queue/network, with each function passing on each call (with address), until it reaches the intended reciever .. ??
11:29:53 <det> esap: neat!
11:30:52 <det> esap, ski, you guys are students ?
11:30:59 <ski> does it work as intended ?
11:31:18 <ski> det : i am
11:31:22 <det> I guess I could make the functions print something to make sure they are alternating
11:31:29 <ski> det : how about you ?
11:31:41 <det> nadda
11:31:44 <ski> yes, thought just that
11:32:04 * esap is no longer a student.
11:32:18 <ski> det : sw developer ? hobby programmer ? scientist ?
11:33:13 <ski> det : you got my point about (even,odd) ?
11:33:36 <det> put in a print statement, does indeed alternate
11:33:41 <det> ski: no :/
11:33:41 <ski> fine
11:33:52 <ski> other ?  :)
11:34:24 <det> ski: does natural number imply some kind of knowledge of its implementation ?
11:34:35 <ski> what do you mean ?
11:34:47 <det> machine integers vs church numerals
11:34:50 <det> or is it irrelevant
11:35:03 <det> ski: was your point about lazy eval ?
11:35:06 <ski> i was just using type nat = Zero | Succ of nat;; in ocaml
11:36:15 <ski> well, if we have mod we can of course make it nonrecursive :)
11:36:57 <ski> so you can, if you like, have the functions take lists instead, and answering if their length is even/odd
11:36:57 <det> :)
11:37:39 <det> I'm not sure if you mean this to relate to mutual recursion, lazy evaluation or both
11:38:37 <Tomasso> there is a way to define booleans using high order functions
11:38:51 <Tomasso> ifThenElse_Lam = \x -> x
11:39:02 <ski> det : the way of implementing mutual recursion by giving y a function which takes and returns a tuple of the to-be-defined function, ...
11:39:07 <esap> It's important to understand the relationship between natural numbers and sequences.
11:39:11 <Tomasso> true_Lam = \x -> \y -> x
11:39:27 <ski> det : ... one can't do this if one hasn't lazy pairs
11:39:31 <Tomasso> false_Lam = \x -> \y -> y
11:39:44 <ski> det : (or tuples, should that be)
11:39:52 <Tomasso> but dont see how to apply these functions...
11:40:53 <ski> det : (well, if we have mutable tuples, and some dummy/unitialized value(s) to initialize the tuple with, we can do it.  i think letrec in Scheme is ordinary implemented like this)
11:41:45 <ski> esap : yes.  (finite sequences, i assume you mean)
11:42:34 <esap> ski: well sequences are usually defined as functions from naturals to some element type.
11:42:40 <det> ski: oh, ok
11:42:43 <ski> Tomasso : i think there can be some problems with these in language with a HM style type-sys.
11:43:23 <Tomasso> mhhmmh this is just papper lambda notation...
11:43:29 <det> ski: I am going to have to think about this :)
11:43:43 <det> ski: what year of university are you in ?
11:43:50 <ski> esap : infinite sequences, yes.  finite sequences can be defined as a function from some finite subset to naturals (usually for all i sa i < some n), but i think you know this
11:43:55 <Tomasso> not_Lam = \x -> ifThenElse_Lam x false_Lam true_Lam
11:44:07 <Tomasso> hmhm but dont understend...
11:44:20 <Tomasso> i have to write the and_Lam the xor_Lam...
11:44:50 <ski> det : but, with esap's suggestion/idea we perhaps just need y, even in strict languages
11:45:05 <esap> ski: but I think there is no deep relationship between naturals and finite sequences.
11:45:31 <esap> ski: The point was, the definition of natural _requires_ you to also define sequences.
11:45:32 <ski> det : 3rd or something
11:46:05 <ski> Tomasso : this is some exercise in lambda-calc. ?  :)
11:46:30 <Tomasso> hmhm no.. we havent studied lamda calc yet
11:46:34 <Tomasso> its the last topic
11:46:45 <ski> Tomasso : of what ?
11:46:55 <ski> esap : how do you mean ?
11:46:59 <Tomasso> of the functional programming course
11:47:01 <esap> ski: think of coalgebras and algebras. Naturals are the algebra part and the sequence is the corresponding coalgebra.
11:47:16 <ski> Tomasso : ok
11:48:04 <Tomasso> on my way to understend this, i think it means that if smth is true in the inThenElse, the first argument is evaluated, if its false the second is evaluates...
11:48:19 <Tomasso> but still not so familiar with this..
11:49:10 <ski> esap :  ??   we can make an algebra from the functor T(X) = 1 + X, this is natural numbers, right ?   the sequence(of A) coalgebra is made from the functor T_A(X) = A * X, right ?
11:50:20 <ski> esap : these two functors are not the same, right ?  what do you mean by corresponding ?
11:50:34 <esap> ski: yes. Note the symmetry. Those functors are dual.
11:51:03 <ski> esap : no, they aren't.  A is not dual to 1, for arbitrary A
11:51:42 <ski> esap : (or have i understood completely worng ?)
11:51:55 <esap> ski: But more importantly, when you define naturals, you also have to define (+), (*), ... operations, which normally have type N -> X for any X. This type is the same as the type of sequences.
11:52:22 <ski> Tomasso : what is "smth" ?
11:52:49 <esap> ski: of course, this requires a category-theory definition of naturals, I guess.
11:53:02 <ski> Tomasso : the above impl. of bools is a kind of continuation passing style (CPS), i think
11:53:44 <ski> esap : ??   naturals is just the initial algebra of the functor T(X) = 1 + X, right ?
11:54:28 <Tomasso> ski: smth= something
11:54:51 <Tomasso> ski: what is continuation passing style??
11:55:00 <ski> Tomasso : ok, so, then, what is "something" ?  ;)
11:55:13 <esap> ski: yes, I think so (although I'm used to a bit different formulation)
11:57:12 <ski> Tomasso : look at true_Lam/false_Lam, e.g., it is a function that takes an x and a y, ok ?     the x and the y represent the possible things to do (i.e. evaluate) next
11:57:45 <Tomasso> ski: smth = an expresion that evaluates to Bool
11:57:47 <ski> Tomasso : true_Lam always decides to use x (i.e. return it), and just skips y
11:58:20 <Tomasso> ski: Korrect
11:58:33 <ski> Tomasso : this corresponds to, in "if True then x else y", the y is thrown away, and the x is returned/evaluated
11:59:21 <Tomasso> ski: Exactly, thats what i suspect
11:59:41 <Tomasso> but the ifThenElse??
11:59:45 <Tomasso> what does it do?
12:00:00 <ski> esap : you are ?   i thought there wasn't much possible different ways to formalize these things (as algebras and coalgebras).  you can explain your used-to-formulation, if you like  :)
12:00:27 <ski> Tomasso : well
12:00:36 <esap> ski: I'm looking for some paper with the picture :-)
12:00:42 <ski> Tomasso : think of my previous "if ..." example
12:00:48 <det> Tomasso: it does nothing, the identity function
12:01:20 <ski> Tomasso : with your functions, that correspnds to just "true_Lam x y", right ?
12:01:39 <Tomasso> hmhm
12:01:39 <det> Tomasso: because a boolean itself is the same functionality of ifThenElse
12:02:06 <Tomasso> det: is the only thing for what booleans are used?
12:02:13 <det> Tomasso: ifThenElse <boolean> x y is the same as <boolean> x y
12:02:34 <ski> esap : ok.  there is a paper called (perhaps approx.) "A tutorial on (co)algebra and (co)induction". This talks about things like naturals and lists and streams
12:02:51 <det> Tomasso: I dont undertstand the question
12:02:56 <Tomasso> mhm isnt it ifThenElse (<boolean> x y ) ??
12:03:33 <ski> Tomasso : can you think of another  (that can't be reduced to testing the boolean, and then doing one or another thing, based on the result) ?
12:03:48 <Tomasso> det: i said that booleans are only used for ifThenElse desitions, and thats why we can write them in that way..
12:03:50 <det> mm, ifThenElse <boolean> x y is equivalent to ifThenElse (<boolean> x y)
12:04:07 <Tomasso> OK
12:04:25 <Tomasso> det: my teachers always say in case of doubt use parenthesis
12:05:30 <ski> det : that i would call an accident. try eta-expanding ifThenElse to \b t e -> b t e  :)
12:05:58 <det> i'd agree
12:06:07 <ski> Tomasso : "ifThenElse b x y" is the correct one, the other is (very probably) not intended
12:06:12 <Tomasso> ski: what do you mean by expanding?
12:07:04 <ski> Tomasso : *eta-expanding* to be precise.  e.g. :
12:07:06 <Tomasso> ski: how does haskell know that ifThenElse b x y is not taking 3 parameters? because of the type definition?
12:07:10 <det> Tomasso: think about what ifThenElse b x y does, ifThenElse being the identity function, consumes b returning b and it then aplies x and y to b
12:07:22 <ski> mapSquares f ns = map square ns
12:07:32 <ski> Tomasso : this is the same as
12:07:39 <ski> mapSquares f = map f
12:07:45 <ski> Tomasso : right ?
12:08:08 <Tomasso> det: what is mapSquares?
12:08:24 <Tomasso> sorry ski, no det hehe
12:08:26 <ski> Tomasso : it doesn't know that, unless you say it in an explicit type signature, yes :)
12:08:35 <ski> Tomasso : e.g.
12:08:45 <Tomasso> ski: I see
12:08:49 <ski> noo
12:09:06 <det> Tomasso: do you understand currying ?
12:09:11 <ski> the second version should *of course* be
12:09:23 <ski> mapSquares = map square
12:09:28 <Tomasso> if i had to critizise this i would say that is not readable for humans, because you have to check type definition
12:09:35 <ski> and the first should be
12:09:38 <ski> mapSquares ns = map square ns
12:09:41 <Tomasso> det: yes i do
12:09:56 <ski> Tomasso : i was just brain-dead for half a minute  ;)
12:10:05 <det> Tomasso: do you understand why ifThenElse is the identity function and how it is unneccesary ?
12:10:21 <ski> Tomasso : well, mapSquares is intended to do e.g.
12:10:51 <ski> mapSquares [1..10]  --->  [1,4,9,16,25,36,49,64,81,100]
12:11:25 <Tomasso> det: i see, ifThenElse is just identity because true_Lam and false_Lam do all the job of telling what to evaluate
12:11:37 <Tomasso> i see
12:11:49 <det> Tomasso: yes, and ifThenElse itself is only consuming the boolean
12:12:08 <ski> Tomasso : yes
12:12:12 <det> Tomasso: and then returning it
12:12:46 <ski> Tomasso : but !  we see directly from "someBoolExpr x y" that booleans is implemented as functions
12:12:48 <det> ifThenElse ifThenElse ifThenElse ifThenElse <boolean> x y is the same as <boolean> x y
12:13:20 <ski> Tomasso : perhaps we'd like to have booleans as an abstract type  (i.e. what it really is should be hidden)
12:13:36 <ski> Tomasso : then we need "ifThenElse"
12:13:45 <ski> Tomasso : do you see ?
12:13:49 <Tomasso> det: hahaha exactly
12:14:07 <ski> heh
12:14:19 <Tomasso> mmh i see
12:15:02 <esap> ski: hmm.. I mean the way "Oosten:Basic category theory" (http://www.math.uu.nl/people/jvoosten/catsmoeder.ps.gz) page 71 (definition 7.6) defines a natural number object.
12:15:41 <ski> Tomasso : anyway, what i was trying to show, when i went brain-dead, was that we can skip the last argument to a function, if it is at the end of the function body also, and *nowhere* else
12:17:07 <ski> Tomasso : (by "the end of the function body" i mean that the function is calling some (possibly other) function, which the parameter (ns is our case) to be removed as the last argument
12:21:34 <ski> esap : (def 7.6 is on page 67 in the version i download just now ...)
12:22:33 <esap> ski: heh, but anyway, that definition is what I mean.
12:23:02 <esap> ski: there the unique map is I think what I call sequence :-)
12:25:20 <ski> esap : i *think* this is a specialization of naturals as an (initial) algebra (defined through a functor)
12:25:50 <ski> esap : would you like a link to the paper i mentioned above about (co)algebra and (co)induction ?
12:26:20 <esap> ski: I have read it.
12:26:37 <ski> esap : fine :)
12:26:43 <det> Tomasso: the same thing arises if you define lists from lambdas, nil = \n c -> n and cons = \hd tl n c -> c hd tl and then a function to dispatch on them becomes the identity function
12:26:48 <esap> ski: if you mean Rutten, I mean.
12:27:00 <ski> esap : yes
12:27:17 <ski> esap : Jacobs and Rutten
12:27:39 <det> Tomasso: but if you want to represent sequences in a way other than a list then the dispatch function becomes necesarry, in a type class perhaps
12:27:59 <esap> ski: but that definition shows the connection between sequences and naturals. I think it's important.
12:28:36 <ski> esap : haven't read that far yet ...
12:32:14 <det> Tomasso: it is perhaps more clear to define cons as: \hd tl -> \n \c -> c hd tl
12:33:33 <ski> esap : looking at def 7.7, what is S^n1 ?
12:33:54 <ski> esap : and S^F(...) ?
12:34:57 <esap> ski: I guess it's the successor function composed with itself n1 (or F(...)) times.
12:35:49 <ski> esap : ok
12:37:04 <ski> esap : i think i've found a type : the type of the proj. should be N^k -> N, and not N -> N
12:38:17 <esap> ski: agreed, it's a typo.
12:38:38 <Joopdod> Has anyone compiled HSQL/or another Mysql package succesfully?
12:38:52 <ski> esap : (typ*o*, yes)
12:43:00 <ski> esap : which part is related to sequences ?
12:43:23 <esap> ski: the definition 7.6. But you have to notice that the unique function N->X is a sequence.
12:44:15 <ski> esap : hmmmm
12:45:11 <esap> ski: because it is from naturals to arbitrary set, and you can vary x and f to choose different sequences.
12:45:39 <esap> ski: s/function/map/
12:45:50 <ski> esap : yes   (Nat -> a) <-> Stream a
12:46:42 <esap> ski: yes.
12:49:25 <ski> esap : blah :  Nat -> a = ~ (Nat * ~ a) = ~ ((1 + Nat) * ~ a) = ~ (1 * ~ a + Nat * ~ a) = ~ (~ a + Nat * ~ a) = ~ ~ a * ~ (Nat * ~ a) = a * (Nat -> a)     ok
12:49:41 <ski> esap : hmm
12:50:15 <esap> ski: I think this shows a connection between the algebra defining natural numbers and the coalgebra defining sequences.
12:50:44 <ski> esap : mm, just thinking about additive vs multiplicative now ...
12:51:48 <ski> esap : i think we need additive streams, for this to work in a linear setting
12:52:12 <esap> ski: what do you mean by additive stream?
12:52:28 <ski> esap : (i.e. if we keep the Nat additive. i don't know what multiplicative "Naturals
12:52:52 <ski> esap : " would have properties like)
12:53:50 <ski> esap : one which you must extract exactly one element of
12:55:13 <ski> esap : The normal naturals is afaik always used in an additive way in nonlinear systems (e.g. ordinary math), so the corresponding one in a linear setting would be additive Naturals
12:55:28 <ski> esap : i.e. with the + in the definition as additive disjunction
12:56:40 <esap> ski: in the definition 7.3, you get (+n) as the unique map if you set x = n, f = succ
12:58:10 <ski> esap : i see no "definition 7.3"
12:58:19 <ski> esap : only a "proposition 7.3"
12:58:21 <esap> oh definition 7.6.
12:58:55 * esap looked at the chapter number and thought it was the definition number :-(
12:59:27 <ski> esap : ah, ok
12:59:36 <esap> ski: and you get (*n), if you set x=0, f = (+n).
12:59:58 <ski> esap : yes. i see that
13:00:16 <ski> esap : fold over naturals, just, right ?
13:00:27 <esap> yes.
13:05:48 * esap is thinking about connection between folds and coalgebras.
13:06:02 <Tomasso> grgr they told me to do something in pascal and the same thing in haskell
13:06:34 <Tomasso> it took me 70 lines in pascal and a few in haskell
13:06:39 <Tomasso> i hate imperative languages
13:06:55 <Tomasso> they are a waste of time
13:07:01 <Tomasso> and mental effort
13:08:03 <ski> esap : if we express it as an algebra we get  [0,S] : 1 + N -> N   1 + phi : 1 + N -> 1 + X   [x,f] : 1 + X -> X   phi : N -> X     right ?
13:08:55 <Tomasso> and it probably doesnt work
13:09:00 <Tomasso> in pascal
13:09:01 <esap> ski: yes.
13:09:21 <ski> esap : it is possible to generalize this correspondance between N -> X and Stream X  to more algebras/coalgebras ?? hmm
13:09:42 <ski> Tomasso : what doesn't work in pascal ?
13:09:44 <esap> ski: I would hope so, because it seems very useful to do that
13:10:51 <ski> esap : can you (or i) come up with some other example (alg. or coalg.), to try to do the same to (find a corr. one) ?
13:11:11 <esap> ski: yes, I know actually a couple of examlpes of such pairs.
13:12:07 <ski> esap : care to show any ?                              :)
13:12:19 <esap> ski: yea, hold on, I'm looking from the code :-)
13:12:33 <ski> esap : 'kay
13:13:13 <esap> ski: data List p top = Nil top | Cons !(p (List p top))  and data Tree f bot = Tree bot (f (Tree f bot))  are one example.
13:13:35 <esap> I think, at least.
13:13:53 <ski> esap : they are corresponding to each other ?
13:14:05 <esap> yes.
13:14:29 <ski> esap : is the ! necessary ?   (or is it "of course" ?)
13:15:01 <esap> ski: well I think so.
13:15:26 <ski> esap : to weed out extra bottoms, i presume ..
13:16:16 <ski> esap : but isn't both of them examples of algebras ?   shouldn't one be a coalgebra ??  (don't know)
13:16:17 <esap> ski: another is type Pair a = (a,a)  and Bool.
13:16:33 <esap> ski: I think that tree is a coalgebra.
13:16:51 <Tomasso> ski: i said that what i wrote in pascall probably doesnt work or has memory allocation problems when in haskell is much easier
13:16:59 <ski> esap : hmm, i think this "correspondance" is assymmetric ...
13:17:52 <ski> Tomasso : well, compared with haskell, pascal can easily seem irritating :)
13:18:24 <Tomasso> but the problem is that haskell is slow
13:18:48 <Tomasso> i sar some haskell2c preprocessors, is it tru?
13:18:52 <Tomasso> true
13:19:03 <esap> ski: heh, it's possible I've haven't thouhgt all of it correctly.
13:19:24 <ski> Tomasso : one of them is called "ghc"
13:19:28 <Binkley> heh
13:19:35 <Tomasso> i have it installed
13:22:08 <esap> ski: oh btw, if you set X=_|_ in the definition of the natural number object, then you get the unique map is inverse of zero (which is also a bit interesting case!).
13:24:38 <ski> esap : (Nat -> a) <-> Stream a,  is there a corresponding one for your two datatypes above ?
13:25:15 <esap> ski: well (Bool -> a) <-> (a,a), I guess.
13:26:20 <ski> esap : ??  explain that (about _|_) again, please
13:26:40 <ski> esap : and for the Trees ?
13:26:56 <ski> esap : true
13:27:02 <esap> ski: I mean, if you set x=undefined, f=id, then the unique map has type N -> _|_.
13:27:26 <esap> ski: which is negation of N.
13:27:30 <ski> esap : you mean in the paper ?
13:27:42 <esap> ski: yes, definition 7.6 again.
13:28:22 <ski> esap : ok.  hmmm
13:28:59 <esap> ski: of course, you cannot really have 'undefined', but for thinking about this, I think it's a good example.
13:29:50 <ski> esap : hmmm, should f be id, as you say, or _|_  ?
13:30:18 <ski> perhaps it's the same thing for _|_
13:30:39 <esap> ski: well f would have type _|_ -> _|_. I guess \x -> undefined and id are the same for that case.
13:30:40 <ski> id and 1 is the same over 1, i think
13:30:57 <Tomasso> hhm can anyone tell me why hugs returns type error in the function oddListOfList in the file http://200.63.129.93/facultad/2anio/2cuat/Funcional/practicos/practica5/practica5.html
13:30:59 <Tomasso> ??
13:31:02 <ski> esap : no, i didn't mean \x -> undefined
13:31:37 <Tomasso> hehe apache is great
13:31:52 <esap> oh you meant _|_ (the function). I usually use _|_ for the type.
13:31:55 <Tomasso> and kate editor too
13:32:13 <esap> ski: s/function/arrow/
13:33:04 <ski> esap : (well, we can perhaps replace undefined by some continuation arrow, if we don't like to use a nonexisting undefined : 1 -> _|_)
13:33:33 <esap> ski: yes, that's a good idea.
13:33:58 <ski> esap : i meant the mapping function (arrow) over _|_.   is this what you said lastly, too ?
13:34:03 <Tomasso> hoo i see
13:34:11 <esap> ski: I tried :-)
13:34:30 <Tomasso> hhhhm no same error.
13:34:39 <ski> Tomasso : waitasecond, what type error ?
13:34:46 <esap> ski: I sometimes say things a bit less accurately than I would like.
13:35:27 <Tomasso> mhhm It works now :D
13:35:55 <ski> esap : well, if we're going to use +, both for the coproduct and for it's (bi)map, i don't know why we shouldn't do so for the initial object
13:35:58 <Tomasso> ski: had to use ++ in place of :
13:36:44 <ski> Tomasso : ok, fine :)   (just when i was going to look at the code at the page already opened in the browser ;)
13:37:34 <Tomasso> haha click on update
13:37:41 <Tomasso> in the browser
13:38:05 <Tomasso> kate editor generates html and has haskell highlighting!! :D
13:39:10 * ski is really trying to function concurrently ATM
13:39:26 <esap> ski: oh actually, if you set x=id, f=id, that's another interesting case.
13:40:15 <esap> ski: but trivial, I guess.
13:43:57 <ski> waitsomemoments
13:47:37 <ski> esap : phi becomes <>, right ?
13:48:01 <esap> ski: <>? [I'm not familiar with the notation]
13:48:15 <ski> esap : you know <f,g> ?
13:48:37 <ski> esap : for products, i.e.
13:48:45 <esap> ski: oh ok. <> = top : A -> 1.
13:48:54 <ski> esap : yes, that's it
13:48:59 <Tomasso> haskell doesnt have lambda notation right?
13:49:12 <ski> Tomasso : yes, it does
13:49:26 <Markus> Tomasso: there must be a bug in haskell...
13:49:28 <Tomasso> why it doesnt get ifThenElse_Lam = \x -> x
13:49:32 <Markus> ;)
13:49:36 <esap> ski: but with A=N, obviously.
13:49:46 <Riastradh> Tomasso, what doesn't it 'get' about that?
13:50:18 <ski> Tomasso : you yourself (well, hm) used it above in "not_Lam = \x -> ifThenElse_Lam x false_Lam true_Lam"
13:50:23 <Tomasso> sintax error unexpected =
13:50:43 <ski> Markus : why ?
13:51:03 <Markus> ski: JK =)
13:51:04 <Riastradh> Tomasso, are you entering this straight into a REPL?
13:51:19 <ski> esap : yes
13:51:24 <Tomasso> Riastradh: what is REPL?
13:51:49 <Riastradh> Read-Eval-Print-Loop.  When you run 'hugs' with no arguments, you get into a REPL.
13:51:52 <ski> Tomasso : Read-Eval-Print-Loop, also called interactive toplevel
13:52:13 <Tomasso> yeah, i just pasted the line in hugs
13:52:18 <ski> Markus : JK ?
13:52:33 <Riastradh> Hugs doesn't let you define stuff in its REPL.
13:52:33 <Markus> Just not Kidding
13:52:42 <Markus> i mean, just kidding
13:54:07 <ski> Tomasso : if you want to define (nonlocal) things, you have to enter it into a file, and then load that into hugs
13:54:46 <Riastradh> Or you can use GHCi, where you have to write 'let foo = bar'.
13:56:17 <Tomasso> hihihihhi Ok
13:57:26 <ski> Markus : mm
13:58:38 <ski> esap : top and bot in List and Tree can really be any type, yes ?
13:58:54 <esap> ski: yes.
14:00:06 <esap> ski: There is a reason I named them like that, but it would require quite a bit of explanation about what I'm trying to do.
14:00:39 <ski> esap : i think i can imagine ...        :)
14:01:31 <esap> ski: basically I sometimes think of 'arbitrary object' as _|_ and 'fixed object' as top.
14:03:50 <ski> esap : can you have some <-> between two somethings mentioning List and Tree ?
14:04:51 <Tomasso> dont remember how to say xor in terms of and not or
14:04:57 <esap> ski: I think it should be (List p () -> a) <-> Tree f a, if there is a similar relationship between p and f.
14:05:05 <ski> esap : i often think of _|_ as the same as forall a. a, and then lifting the forall to toplevel
14:06:35 <ski> Tomasso : b0 `xor` b1   should be true if b0 `or` b1 is true, except in the case when both b0 `and` b1 is true, then the xor:ed things should be false
14:06:40 <Tomasso> hmmh isnt it not (iff) ?
14:06:49 <ski> Tomasso : try to write that down in code !   :)
14:06:57 <Tomasso> hehehehe Ok
14:07:08 <Tomasso> i have to do i in high order function! :D
14:08:40 <ski> Tomasso : yes, that is another formulation. yet another is : first should be true and second false, or, first should be false and second true   (doesn't matter if the used or here is inclusive or exclusive !)
14:09:24 <ski> Tomasso : you do ?    how would that be higher-order ?
14:09:37 <Tomasso> hhm for example:
14:09:59 <Tomasso> and = \x -> \y -> not_Lam (or_Lam (not_Lam x) (not_Lam y))
14:10:12 <Tomasso> written in terms of or and not
14:10:23 <Tomasso> or just and_Lam = \x -> \y -> ifThenElse_Lam (x (y false_Lam))
14:10:37 <Tomasso> this is funny
14:10:37 <ski> Tomasso : ah, you mean you have to use your booleans-as-functions implementation.  ok
14:10:45 <Tomasso> hehe yeah :D
14:11:39 <ski> Tomasso : yes :)
14:13:21 <ski> Tomasso : hmm, is that 'direct' and_Lam correct ?
14:14:35 <timbod> according to ghci, why is
14:14:41 <timbod> class DBConst a where
14:14:41 <timbod>     dbConst :: a -> String
14:14:41 <timbod> instance DBConst Int where
14:14:41 <timbod>     dbConst = show
14:14:47 <timbod> ok, but
14:14:53 <timbod> instance DBConst Show where
14:14:53 <timbod>     dbConst = show
14:15:00 <timbod> is not?? help anyone?
14:16:01 <Lor> Show is not a type.
14:16:20 <Lor> What is your intention with the latter instance declaration?
14:17:12 <timbod> Sorry, I mistyped into irc, I mean to say that
14:17:20 <timbod>   instance DBConst String where
14:17:20 <timbod>       dbConst = show
14:17:25 <timbod> is not ok??
14:17:53 <timbod> Here's the error:
14:17:58 <Tomasso> ski: shouldnt it be and_Lam = \x -> \y -> ifThenElse_Lam (x y false_Lam) ?
14:18:12 <ski> timbod : anything to do with lists ?
14:18:46 <Tomasso> if x is true it returns y that could be true_Lam or false_Lam, if x is false returns false_lam
14:19:16 <ski> Tomasso : yes
14:19:26 <timbod> ski: are you saying it's because String  is equiv to [Char]
14:19:43 <Lor> timbod, what was the error?
14:19:48 <ski> Tomasso : the old one always returned false_Lam when anded on two true_Lam's, i think
14:19:58 <timbod>     Illegal instance declaration for `DBConst String'
14:19:58 <timbod>         (The instance type must be of form (T a b c)
14:19:58 <timbod>          where T is not a synonym, and a,b,c are distinct type variables)
14:19:58 <timbod>     In the instance declaration for `DBConst String'
14:20:07 <Lor> Ah.
14:20:19 <Lor> Haskell 98 doesn't allow type synonyms in instances.
14:20:27 <Lor> So change the String to [Char]
14:20:41 <Lor> Or use extensions.
14:20:49 <ski> Lor : is that allowed in haskell98 ?
14:21:11 <Lor> Yes, it is of the required form.
14:21:35 <timbod> It still doesn't seem to like
14:21:40 <timbod>   instance DBConst [Char] where
14:21:40 <timbod>      dbConst = show
14:21:41 <Lor> [Char] is just sugar for ([] Char], where [] is the unary type constructor for lists, and Char the nullary constructor for chars.
14:21:43 <ski> Tomasso : but, i would write it as "and_Lam = \x -> \y -> ifThenElse_Lam x y false_Lam"
14:21:45 <timbod> if that's what you mean
14:21:59 <Lor> timdod, right. What's the problem?
14:22:58 <Tomasso> ski: Ok, arent they equivalent?
14:23:07 <ski> Lor : IIRC (not sure), the type in an instance head in haskell 98 must be of the form "T a b c ..."  where T is a type-constructor and a,b,c,... are (all different) type-*variables*
14:23:29 <Lor> That seems silly. Can H98 really be _that_ restricted?
14:23:59 <timbod> Ok, ghci 5.0.x seems to accept either instance DBConst [Char] or instance DBConst String
14:24:15 <timbod> if -fglasgow-exts is enabled
14:24:25 <timbod> otherwise it doesn't like either of them
14:24:33 <timbod> with the same previous error message
14:25:14 <timbod> Seems like quite a restriction, making a string an instance of a typeclass
14:25:18 <ski> Tomasso : they are equivalent in operation, yes. but i thought the point of having an ifThenElse at all (except possibly readability) was to think of this Bool implementation as an abstract (hidden implementation) type.  i.e. one should think as if you had declared   ifThenElse_Lam :: Bool -> a -> a -> a
14:25:28 <timbod> doesn't seem that unlikly a thing to want to do.
14:25:42 <Lor> timbod, apparently you have to make _all_ lists an instance, then.
14:25:51 <Tomasso> hmmh
14:26:01 <Lor> But that probably doesn't fit your purpose.
14:26:29 <ski> Lor : i get "ERROR ABCDEF.hs:4 - syntax error in instance head (variable expected)"
14:26:34 <Lor> Just use the extensions. No one will flame you for that. Haskell isn't like C in that respect. :)
14:27:03 <timbod> Nope, My intention was to write a simple util function:dbConst :: DBConst a => a -> String
14:27:17 <Lor> The meaning being what?
14:27:17 <timbod> for formatting SQL literals.
14:27:21 <Lor> Right.
14:27:36 <Lor> This is yet another reason why having strings be lists of characters is a Bad Idea.
14:27:54 <ski> Lor : i.e. in hugs (+98). with hugs -98 it works just fine
14:28:12 <timbod> I guess so. The whole extension thing makes me a bit nervous,
14:28:14 <Lor> Yeah, I think we established already that it's illegal.
14:28:25 <Lor> timbod, why? The common extensions are supported by all implementations.
14:28:37 <Lor> You don't really lose any factual portability.
14:28:53 <timbod> It's more do do with the fact that I don't know _which_ are the
14:29:05 <timbod> common ones. For example, which one is this?
14:29:41 <Lor> This is just in the "general bunch", I think (-fglasgow-exts in ghc, -98 in hugs)
14:29:55 <Lor> Ie. not so terribly dangerous as to require its own command line switch.
14:30:12 <timbod> Doesn't -fglasgow-exts turn on the lot?
14:30:27 <Lor> Yeah. There has been talk about splitting it to many pieces.
14:32:14 <timbod> I've just done a quick scan of the ghc doco, and can't see which
14:32:30 <timbod> flag actually enables it. Anyway, thanks for the tip.
14:32:32 <Lor> -fglasgow-exts
14:32:47 <ski> timbod : you've used "type synonyms in instances"  and "generalized instance heads" i think
14:32:53 <timbod> Sorry, I mean what's the name of the extension to the H98 type system
14:33:00 <timbod> that this is makeing use of
14:33:04 <Lor> There are (currently) no flags for the different extensions that glasgow-exts activates.
14:33:13 <Lor> There are some additional ones that aren't included in those, though.
14:33:45 <timbod> OK, but most people refer to "multi type parameters", or "dependend types"
14:33:49 <timbod> whats this one?
14:33:56 <Lor> ski said already.
14:34:13 <timbod> oops, thanks ski!
14:34:46 <ski> timbod : for some doc, see 5.4.5.3 a bit down from http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#MULTI-PARAM-TYPE-CLASSES
14:36:41 <ski> timbod : you mean "multi-parameter type classes" ?  and probably you mean "dependent types", which AFAIK no haskell processor provides as extension   (not counting some things you can do with fun.dep. now)
14:36:58 <timbod> ski: found it - thanks
14:37:26 <timbod> ski: sorry, Yep, that's what I meant (but not what I said :-)
14:38:05 <timbod> anyway -fglasgow-exts means that I can go on hacking... thx
14:41:29 <andersca> where was the url to the monad t-shirt?
14:48:59 <ski> andersca : this one ?  http://www.cafeshops.com/doitmonad.7154442
14:52:12 <ski> esap : well, your List seems dual to your Tree, yes ...
14:52:44 <esap> ski: dual?
14:52:57 <ski> esap : in a specific sense, yes
14:53:26 <ski> esap : similar to as CoMonad is dual to Monad, if i'm not mistaken
14:55:10 <ski> esap : Assume   ~top = bot   and  ~(f a) = p (~a)   then :
14:55:19 <ski> esap : ~List p top  =  ~(top + p (List p top))  =  ~top * ~(p (List p top))  =  bot * f (~List p top)  =  bot * f (Tree f bot)  =  Tree f bot
14:55:44 <ski> esap : right ?  (reasoning quite loosely/informally)
14:56:54 <ski> esap : (with  List p top = top + p (List p top)  and  Tree f bot = bot * f (Tree f bot)  of course)
14:56:56 <esap> ski: hmm.. yes, I suppose. So then '~' is duality?
14:57:04 <ski> esap : ~ is negation
14:57:25 <ski> esap : or continuation cofunctor, if you like :)
14:57:26 <esap> ski: ok hmm.. but then List and Tree are just negations of each other.
14:57:37 <esap> ski: and not duals.
14:57:53 <ski> esap : yes, taking into account the top/bot and p/f
14:58:28 <ski> esap :  isn't e.g.  ~(a + b)  =  ~a * ~ b  ?
14:58:44 <ski> esap : you don't call + and * duals ?
14:59:24 <esap> ski: yes hmm.. That reminds me of DeMorgan's rules.
14:59:34 <ski> esap : yes, exactly
15:00:35 <ski> esap : so   ~List p top = Tree (\a.f (~a)) (~top)
15:01:08 <ski> esap : or  ~List p top = Tree (f . (~)) (~top)
15:01:33 <esap> ski: ~A = A -> _|_, I guess.
15:01:45 <ski> esap : yes, of course ;)
15:01:52 <ski> esap : if you like
15:02:36 <esap> ok, so what is the end result of all this thinking? That sequences and natural numbers are duals?
15:03:03 <ski> esap : no, can't be exactly that
15:03:37 <ski> esap : 'cuz   Nat : *  and  Stream : * -> *   so the kinds isn't the same
15:04:13 <ski> esap : you are doing one thing with Nat/Stream and Bool/Pair, and another with List/Tree  (possibly related though)
15:04:29 <esap> ski: oh but now I need to disclose another interesting thing: data Nat t = Zero t | Succ (Nat t)  :-)
15:04:42 <esap> ski: So Nat : * -> * as well
15:06:03 <ski> esap : yep
15:06:10 <ski> esap : call it Nat'
15:06:27 <ski> esap : Nat' a = Nat * a  right ?
15:06:41 <esap> no.
15:06:51 <esap> oh actually, yes.
15:07:01 <ski> :)
15:07:16 * esap forgot the recursion.
15:08:59 <ski> so that is the dual of streams
15:09:01 <esap> the difference is, Nat * a supports constant-time access to the second component, and Nat' doesn't :-)
15:09:11 <ski> :)
15:10:40 <ski> i have (for some months ?) ago been thinking about optimizations like : automatically store Nat-isomorphic types as Integer and store Nat' a-isomorphic types as Integer * a
15:11:24 <esap> hmm.. interesting. Isn't F(X)=A*X the defining functor for streams. Then G(Nat) = Nat'. Hmm...
15:11:34 <esap> I mean F(Nat) = Nat'.
15:11:57 <ski> yes, of course it is the defining functor for streams
15:12:09 <ski> hmm
15:12:29 <ski> perhaps there is some deep behind this ..
15:12:44 * esap thinks of units of adjunction.
15:13:24 * ski doesn't think of units of adjunction (dunno what it is)
15:14:05 <esap> for an adjunction F -| G, it's  unit :: a -> g (f a). There is a corresponding counit :: f (g a) -> a.
15:14:22 <ski> ok,hm
15:15:15 <ski> is one of Nat',Stream a left adjoint to the other ?
15:15:50 <ski> hmm
15:15:58 <esap> hmm.. I think yes.
15:16:38 <esap> Nat' -| Stream  I think.
15:17:42 <ski> Nat' A -> B     A -> Stream B    or however it was now ..
15:17:45 <ski> ?
15:18:31 <esap> ski: yes.
15:18:37 <ski> esap : 'twas something like  F A -> B   A -> G B    F -| G  , right ?
15:19:02 <ski> esap : (btw, do you have any idea why they use the symbol -| ?)
15:19:03 <esap> ski: yes, that was the the left adjunct part. the right one was inverse of that.
15:19:21 <esap> ski: no, not really.
15:19:35 <esap> ski: I think it's just convenient syntax.
15:20:14 <ski> esap : (previously i've used  -| as a convenient converse of |-, for stating assumptions. e.g. type of free vars)
15:20:56 <esap> ski: no that's not a good idea :-) I would be very confused...
15:21:06 <ski> (like : <f,g> : x -> a * b  -|  f : x -> a  ,  g : x -> b)
15:21:36 <ski> esap : then i saw it use in connection to adjuctions and got very confused :)
15:21:41 <ski> used
15:22:36 <esap> Hmm.. what does this all mean? That algebras and coalgebras can be generated from adjunctions?
15:22:48 <ski> i dunno :)
15:23:06 <ski> but, it's fun.  that's for sure :)
15:24:36 <ski> hmm, shouldn't one perhaps say that given a (co)algebra, we can construct it's dual as an adjoint of it ??
15:25:41 <ski> i seem to recall that products and coproducts isn't directly related by adjunction, there was something in between...   + -| Delta -| *   ???
15:26:03 <esap> ski: yes, true. Delta(X) = X,X.
15:26:22 <ski> but, this doesn't seem to be the case with, e.g. Nat'/Stream, no ?
15:27:09 <ski> esap : is that like a type-pair ?   (which just happend to have the same thing in both places)
15:27:47 <esap> ski: hmm.. actually, since Nat' = (Integer,_), I guess Stream = Integer=>_ by adjunction  (because (A,_) -| A=>_ )
15:28:31 <ski> esap : hmmmm..
15:29:02 <ski> esap : Nat' = \a.Integer * a  ?
15:29:37 <ski> esap : \a.A * a -| \a.A => a   ?
15:29:38 <esap> yes, I suppose (but \ there is type-level)
15:29:45 <ski> esap : of course
15:30:06 <esap> ski: yes.
15:31:09 <esap> ski: The problem of course with defining it as (Integer,_) is that then we have to assume some definition of Integer. If you'd like to define integers, then I guess the categorical definition of the natural numbers object should be used.
15:31:59 <ski> esap : Integer ????   i was thinking of Nat all the time :)
15:32:12 <esap> ski: oh I again misspoke. Nat of course.
15:32:31 <ski> esap : ok
15:33:41 <ski> esap :  if F -| G0 and F -| G1, is G0 = G1 ?
15:34:15 <esap> ski: I think adjoints are unique up to isomorphism.
15:34:23 <ski> esap : ok
15:34:25 <esap> ski: so yes.
15:35:06 <ski> esap : but we have only intuitively seen that Nat' a = Nat * a, still, yes ?
15:35:49 <esap> ski: yes. I think the interesting thing is: why does Nat require Stream for its definition? [as opposed to Nat', where I think it's easy to explain].
15:36:09 <ski> esap : require ?
15:36:12 <esap> ski: assuming Nat' a = Nat * a
15:36:23 <ski> esap : require how ?
15:37:02 <esap> ski: I mean, the categorical definition of natural number object defines the sequence concept.
15:38:01 <esap> ski: by requiring the unique map N->X.
15:39:31 <ski> can we find some example of a dual situation ?
15:43:15 <ski> does it matter if we say instead : (_,A) -| A=>_  ?
15:44:07 <esap> ski: hmm.. it might. I'm actually not sure which one is correct, (_,A) -| A=>_ or (A,_) -| A=>_.
15:45:05 <ski> (_,A) -| A=>_  seems (looks) more symmetric to me, at least in a linear natural language
15:45:41 <Darius> No it doesn't matter.  (-,A) is isomorphic to (A,-).
15:47:43 <esap> What happens if you just invert all arrows of the definition of the natural numbers object?
15:47:44 <ski> esap : (.. , ..) is product here, yes ?   (i.e. not thing like Delta previously above)
15:48:41 <ski> esap : i was thinking along lines of findind some natural coalgebra to start with, but i guess we can try that, yes
15:48:49 <esap> ski: yes.
15:49:05 <ski> (natural = "occurs naturally")
15:49:49 <ski> esap : so the ( , ) is product, right ?
15:50:11 <ski> above in the adjunctions, i.e.
15:50:38 <ski> (i've guessed that it is)
15:50:58 <esap> ski: yes, ( , ) is the product.
15:51:05 <ski> good
15:51:35 <ski> then this is correct, yes :  _ >- A  -|  A + _
15:52:27 <esap> ok.
15:53:07 <ski> hmmm :  ~Nat  =  ~(1 + Nat)  =  ~1 * ~Nat  =  0 * Foo  =  Foo
15:53:22 <ski> in that case, Foo = 0 * Foo, hmm
15:53:45 <ski> (additive pair, if that helps a little)
15:55:12 <esap> does it help if you replace '0' with an arbitrarily chosen object?
15:56:49 <esap> oh but I think ~Nat = Nat -> _|_ = Stream _|_ :-)
15:57:05 <ski> yes, seem so
15:57:19 <ski> of course :)
15:57:24 <ski> yay
16:02:18 <det> esap: heya
16:03:06 <ski> hmm
16:04:21 <det> how to write a combinator so that "f a b = .." and "f2 a b= .." then (Y2 f f2) and both functions will get passed both functions
16:04:31 <det> can that be done in terms of Y :)
16:05:30 <esap> det: I think yes.
16:06:04 <ski> esap : can i paste a (Nat dual) diagram ?
16:06:17 <esap> ski: sure.
16:06:21 <ski>      x'	     f
16:06:22 <ski> 0  <---  X  --->  X
16:06:22 <ski> 	      f
16:06:22 <ski> 	 X  <---  X
16:06:22 <ski>       /  |	  |
16:06:23 <ski>   x' /   | psi	  | psi
16:06:24 <ski>     /    |	  |
16:06:26 <ski>    L     V	  V
16:06:28 <ski> 0  <---  N  <---  N
16:06:30 <ski>      0'	      S'
16:06:32 <ski> wait
16:06:38 <ski> have to remove the tabs :)
16:07:36 <ski>      x'       f
16:07:36 <ski> 0  <---  X  <---  X
16:07:36 <ski>               f
16:07:36 <ski>          X  <---  X
16:07:36 <ski>       /  |        |
16:07:37 <ski>   x' /   | psi    | psi
16:07:41 <ski>     /    |        |
16:07:43 <ski>    L     V        V
16:07:45 <ski> 0  <---  N  <---  N
16:07:47 <ski>      0'       S'
16:08:19 <ski> almost right. (it skipped 3 blank lines, but i think you can see it now)
16:08:26 <ski> is that correct ?
16:08:41 <ski> and, in such case, what does it mean ?  ;)
16:09:20 <ski> 0' and S' is probably some sort of head and tail
16:09:49 <esap> ski: One problem is, I'm not sure how to handle those 'arbitrarily chosen' objects when dualizing. Should you transform it somehow?
16:09:54 <ski> oh, N should be N', also
16:10:09 <ski> you mean X ?
16:10:14 <esap> ski: yes.
16:10:30 <ski> i guess it depends on where the quantor is
16:10:42 <ski> hmm
16:10:47 <esap> ski: because you did transform 1 to 0, maybe you should transform X to 'almost' 1 :-)
16:11:01 <ski> i don't think we need to do anything with X
16:11:22 <esap> ski: because 0 is almost an arbitrarily chosen object.
16:11:23 <ski> after all, this (or at least the old one) is polymorphic in X
16:11:57 <ski> esap : depends on where the quantor is, and if it occurs many times (in some sense)
16:13:43 <ski> esap : e.g.   return :: forall a. a -> m a  (as a polymorphic arrow) dualizes to  coreturn :: forall a. cm a -> a  , where cm is the Comonad that is dual to the Monad m
16:14:18 <esap> Hmm.. yes that is actually very interesting, because I think the forall and existential quantification are duals.
16:14:36 <ski> esap : (hint : it is not the "same" a that is quantified in return's type, as in coreturn's type !)
16:14:56 <ski> esap : on object level, yes
16:16:44 <esap> What I'm thinking is, should that X be actually transformed into something that is very definitely chosen in particular way [and not arbitrarily chosen], and vice versa (so that N should be transformed to an arbitrarily chosen object?)
16:17:12 <ski> esap : see :   Assume  m (~ a) = ~ (cm a)  then  all a. a -> m a  =  all a'. ~a' -> m (~a')  =  all a'. ~a' -> ~ (cm a')  =  all a'. cm a' -> a'  =  all a. cm a -> a
16:17:32 <ski> esap : i don't think so
16:18:00 <ski> esap : N is what is being characterized, X is just help for that
16:18:11 <Leimy> lisp questions ok in here?
16:18:51 <Binkley> you might want to try #lisp instead
16:18:55 <Leimy> ok
16:19:03 <Leimy> thanks :)
16:19:36 <ski> esap : see what i did ?
16:20:05 <esap> ski: I have to think it a couple of seconds.
16:20:14 <ski> esap : sure
16:22:12 <esap> ski: oh, you've done substitution, a = ~(a')? Hmm.. does that substitution preserve universal quantification?
16:22:12 <ski> esap : (mind, i'm gladly using RAA, and similar things there, so this kind of reasoning should probably/perhaps be taken as a hint/way to discover something that we later can confirm actually is dual.  hmm...)
16:22:37 <ski> esap : just universal instantiation
16:22:51 <ski> esap : substitute a by ~a'
16:22:59 <ski> esap : no big deal, i think
16:23:21 <esap> ok.
16:23:52 <esap> I think have to be careful with the negation. I think it has some quite interesting properties.
16:24:00 <ski> esap : it would work if we had existensials at the beginning (and the end), also.  see why ?  :)
16:24:39 <ski> esap : yes, that's why i currently think of this as a kind of semi-formal hint
16:26:26 <ski> esap : (the possible problems are possibly related to cbn/cbv duality and "critical pair")
16:26:47 <esap> yes.
16:27:07 <ski> yes to what ?   all ?
16:27:19 <esap> yes :-)
16:27:30 <ski> nice
16:28:13 <ski> so i think that quantors at arrow-level should not be turned inside-out
16:28:53 <esap> ok, so what does this dual of Nat mean?
16:29:35 <esap> It somehow classifies arbitrary objects to classes defined by naturals.
16:29:50 <ski> well...  because the first part is always 0, it seems we always have to traverse the right path
16:30:14 <ski> (additive pair, you recall)
16:30:26 <esap> oh not naturals, N wasn't Nat :-)
16:30:26 <ski> hmm
16:30:37 <ski> N'
16:30:43 <ski> Conaturals ?
16:30:46 <esap> right, I forgot.
16:30:49 <ski> :)
16:31:25 <ski> classifies, how ?
16:32:13 <ski> um
16:32:32 <esap> Hmm.. I mean, it seems that you have a collection of isomorphic objects (because you can get from every one of them to 0), and from that, you can get to N'. But hmm..
16:32:37 <ski> no, i think we don't have to traverse the right path, endlessy
16:32:58 <ski> if we enter a left path, i think we jump
16:33:41 <ski> esap : if  A0 -> 0   A1 -> 0   are A0 and A1 isomorphic ?
16:33:45 <esap> ok, that's a good interpretation.
16:34:47 <esap> ski: hmm.. I think yes, I think it was proved somewhere.
16:35:36 <ski> but, (thinking about what you said above), if  f : A -> B , g : B -> A  then surely g doesn't have to be the inverse of f ?
16:35:52 <ski> or, is that the case when B is 0 ?
16:35:59 <ski> what about when B is 1 ?
16:37:05 <esap> There is Crolard:Subtractive logic, Theorem 1.3.2 (Joyal) : "In any CCC, if _|_ is initial, and if C[A,_|_] is nonempty, then A is initial."
16:37:31 <ski> C[A,_|_] ?
16:37:41 <esap> ski: collection of arrows from A to _|_.
16:38:05 <ski> (there can be no such arrows in Set, right ?)
16:38:21 <esap> right.
16:39:43 <ski> hmm, but that is correct in a CCC. i'm not sure we can keep the CCC properties if we include coexponentials...  (except the inconsistent category... ?)
16:40:22 <ski> (i.e. (IIRC) the category with one object and one morphism)
16:41:13 <esap> true.
16:43:44 <esap> oh actually, this subtractive logic paper describes that a CCC whose dual is a CCC is degenerated [only one arrow between each pair of objects]
16:46:52 * esap thinks I need to get some sleep.
16:47:22 <ski> Declarative Continuations and Categorical Duality
16:47:37 <ski> e.g. just before 2.4.3
16:47:46 <esap> ski: heh Filinski :-)
16:47:50 <ski> he talks about his dual category
16:48:00 <ski> yes :-) :-)
16:48:19 <ski> and says that it defied set-theoretic reasoning
16:50:00 <ski> and i think somewhere he says that he can't assume to strong properties (like distribution perhaps, or something), because then it's dual gonna make the category inconsistant (or something) ...
16:50:12 <ski> well
16:50:33 <ski> i probably should bike home as well
16:50:51 <esap> ok, see you later.
16:50:57 <ski> is the Crolard paper good, btw
16:51:08 <ski> (thinking of printing it out)
16:51:12 <ski> (perhaps)
16:51:24 <esap> It is good.
16:51:28 <ski> ok
16:51:37 <ski> bye
16:51:44 <esap> at least to understand duality.
16:51:50 <ski> mm
16:52:10 * esap doesn't yet understand it well.
19:25:51 <Tomasso> hmm can anyone tell me why when i load the sumbin function hugs returns: ERROR "practica5.hs":402 - Instance of Eq DigBin required for definition of sumbin
19:25:51 <Tomasso>  
19:25:52 <Tomasso> ?
19:26:12 <Tomasso> http://200.63.129.93/facultad/2anio/2cuat/Funcional/practicos/practica5/practica5.html
19:26:50 <Pseudonym> Well, I can tell you what that error means.
19:27:20 <Pseudonym> It means that you're using == or /= (or calling some function which uses it) on the type DigBin.
19:27:38 <Tomasso> mhmh let me check
19:28:36 <Tomasso> hmmh
19:28:45 <Tomasso> in if (x == Uno && y == Uno) ??
19:28:56 <Tomasso> (but thats not the line)...
19:28:59 <Pseudonym> That looks like a good suspect.
19:29:06 <Pseudonym> No, it's not the line.
19:29:17 <Pseudonym> The line where the error would be reported is the type signature, right?
19:29:33 <Pseudonym> Now there are two ways to fix this.
19:29:38 <Tomasso> no, it is sumbin [] [] w = []
19:29:49 <Pseudonym> Ah, OK.  The first line of the function?
19:30:00 <Tomasso> exactly...
19:30:35 <Pseudonym> Anyway, if equality actually makes sense on this type (which it probably does), and you defined the type yourself, the easiest fix is to change this:
19:30:41 <Pseudonym> data DigBin = ...
19:30:42 <Pseudonym> to this:
19:30:47 <Pseudonym> data DigBin = ... deriving (Eq)
19:31:09 <Tomasso> hhm what is deriving (Eq) ??
19:31:16 <Tomasso> i dont understend :D
19:31:16 <Pseudonym> Another possibility is to change the == testing to pattern matching.
19:31:31 <Tomasso> Pseudonym: how do i do that?
19:31:44 <Tomasso> in interested in the second :D
19:32:18 <Pseudonym> deriving (Eq) lets the haskell implementation derive a natural definition of ==
19:32:29 <Pseudonym> There is an "obvious" definition for most types.
19:33:13 <Tomasso> Eq = == 
19:33:15 <Tomasso> ?
19:33:23 <Pseudonym> Something like that.
19:33:28 <Tomasso> i see
19:33:36 <Tomasso> and by pattern matching?
19:33:59 <Pseudonym> By pattern matching, you might do this.  Compare:
19:34:07 <Pseudonym> factorial n = if n == 0 then 1 else n * factorial(n-1)
19:34:09 <Pseudonym> with:
19:34:12 <Pseudonym> factorial 0 = 1
19:34:19 <Pseudonym> factorial n = n * factorial (n-1)
19:34:34 <Pseudonym> Can you see how these are equivalent?
19:35:00 <Pseudonym> But the first one uses == and the second doesn't.
19:35:22 <Tomasso> hmhm i see
19:35:23 <Pseudonym> You can, of course, also pattern match with a case expression.
19:35:35 <Pseudonym> Anyway, I need to eat lunch.  BBL
19:36:02 <Tomasso> hehe ok
21:36:34 <Tomasso> guys what can i do if hugs returns ERROR: Cannot find "show" function for ...blah
21:37:29 <Tomasso> im reading the hugs common errors and it says that the types that can be printed are limited, and i cant show the result of evaluating my function
21:53:00 <Smerdyakov> Yup.
21:53:06 <Smerdyakov> What type of value do you want to print?
21:59:54 <Tomasso> data DigBin = One | Zero
22:00:10 <Tomasso> type NumBin = [DigBin]
22:00:35 <Tomasso> Smerdyakov: how would you print it?
22:05:19 <Smerdyakov> You want to put "deriving Show" into the data definition somewhere.
22:05:22 <Smerdyakov> I'm not sure where.
22:06:08 <Smerdyakov> Maybe after it.
