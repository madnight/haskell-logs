01:43:47 <phubuh_> http://search.cpan.org/author/LBROCARD/Language-Functional-0.03/Functional.pm
01:43:48 <phubuh_> hehe
01:51:23 <Maddas> hah
01:58:17 <Lunar^> hi shapr
01:58:24 <shapr> hi Lunar^ 
05:21:10 <Marvin--> anyone who knows of an effort for a libgmp interface for haskell?
05:25:10 * Marvin-- wonders why ghc -lgmp doesn't seem to work
05:25:19 <Marvin--> oh wait
05:25:20 <Marvin--> gah
05:27:57 <Marvin--> hm
05:28:06 <Marvin--> I thought including <gmp.h> would be enough to resolve the defines
05:29:35 <Marvin--> apparently not
05:30:09 <Igloo> Hi Marvin
05:30:11 <Marvin--> feh, on the other hand, I have absolutely no idea how to declare mpz_t variables in a sane way from haskell
05:30:12 <Marvin--> hello
05:30:27 <Marvin--> mpz_t foo ; mpz_init(foo);  gee, thanks
05:30:43 <Marvin--> if I read this right, mpz_t is a singleton array containing a struct
05:30:50 <Igloo> ghc's configure works out types for various other C types, so that might help
05:31:06 <Igloo> Oh, if it doesn't just map onto a Haskell numeric type it probably won't
05:31:09 <Marvin--> I have  {-# OPTIONS -#include <gmp.h> #-}
05:31:19 <Marvin--> I was going to go around it by using a Ptr ()
05:31:19 <Igloo> c2hs, greencard etc probably do it for you
05:31:48 <Igloo> Ah, that might work if you don't need to look inside it
05:31:56 <Marvin--> I have no intention of looking inside it :-)
05:32:01 <Marvin--> I just don't know how to "create" one
05:32:12 <Igloo> On an unrelated note, do you anticipate darcs being in sarge out of interest?
05:32:30 <Marvin--> I hope to upload it to sid this weekend
05:32:52 <Marvin--> so yes, I hope it will be in sarge
05:33:37 <Igloo> Cool!
05:33:39 <Marvin--> anyway, my current problem is that mpz_init and friends aren't functions, but defines
05:33:51 <Igloo> Oh, ick
05:33:55 <Marvin--> I thought an -#include <gmp.h> would solve that, but it seems I'm mistaken
05:34:30 <Igloo> That would just stick the C code into your Haskell before it is compiled surely?
05:35:02 <Marvin--> I guess I shouldn't play with this before knowing how it works :(
05:35:20 <Igloo> You might need to write a C file which is just things like    mpz mpz_init_ (void) {return mpz_init();}
05:35:48 <Marvin--> funny thing is that it only complains about three of the five imported functions
05:37:55 <Marvin--> http://sjogren.ost.sgsnet.se:8080/gmp.hs <- this is what I'm trying to do
05:38:10 <Marvin--> trying to compile with  ghc --make gmp.hs -fffi -lgmp
05:38:53 <Igloo> I think you've misunderstood unsafe
05:39:02 <Marvin--> probably, yes :)
05:39:15 <Igloo> It's just about whether the function you are calling can call back into the Haskell code IIRC
05:39:23 <Marvin--> hm
05:39:24 <Marvin--> okay
05:39:38 <Igloo> So I think they all want to be unsafe, although it's possible I hav them the wrong way round
05:39:55 <Marvin--> so it's just the IO in the return type that determines the upIO-ishness?
05:40:00 <Igloo> Yup
05:40:18 <Marvin--> all right, it didn't change the result of the compilation anyway :)
05:40:57 <Igloo> Hmm, I'm not convinced that comparisons are going to be pure even with that limited set of operations
05:40:59 <Marvin--> Speaking of sarge, btw, d-i currently "works" on i386, some powerpc, somewhat on alpha, mips and ia64, and that's about it, I think
05:41:21 <Marvin--> perhaps, perhaps not, doesn't change the linking problems though
05:41:28 <Igloo> Oh, no, they won't be if add takes it's destination as an argument
05:41:48 <Igloo> Hmmm, the bug count is a tad high too
05:42:06 * Igloo thinks to make it compile you'll need C wrappers as I suggested above
05:42:15 <Marvin--> bleagh
05:42:20 <Marvin--> might as well write this stupid program in C, then
05:42:36 <Marvin--> (crypto course assignment, implement DSA)
05:42:41 <Igloo> You can easily autogenerate the lot of them though
05:42:58 <Igloo> I had some TH to do something similar for curses  :-)
05:43:09 <Marvin--> hm
05:43:37 <Marvin--> well, on the other hand, since all the arithmetic operations take the result as an argument, and since mpz_t is such an evil type, I think it'll be more trouble than it's worth anyway
05:44:05 <Marvin--> maybe I'll just write the damn thing in C, and then see if I can rewrite parts of it in Haskell :-)
05:44:18 * Igloo heads into comlab
05:46:46 <Lunar^> Igloo: Did you look at making a Debian package for HGL ?
05:48:04 <Lunar^> look further btw
07:11:03 <Grinler> anyone willing to look at a haskell program that intentionally broken and help me fix it :)
07:11:42 <phubuh_> sure
07:11:47 <andersca> sounds like homework
07:12:31 <Marvin--> sounds a lot like homework
07:12:40 <Grinler> not homework at all
07:12:41 <Grinler> actually
07:12:43 <Grinler> its a game
07:12:46 <Grinler> i can learn haskell
07:12:49 <Grinler> or i can have someone help me
07:13:14 <Grinler> i have tried my ass off to learn haskell through the tutorials at haskell.org, but i still dont see whats wrong
07:13:18 <Grinler> i can only fix it up to a certain point
07:19:06 <Grinler> so is anyone willing to help me?
07:19:28 <d33p> with?
07:20:45 <Grinler> have a haskell program that intentionally broken, i dont know haskell, though i have attempted to learn it via the tutorials on haskell.org.  I have fixed as much as I could on my own but now im stuck.  this is not homework, but a game
07:21:53 <Grinler> most of the tutorials i read assume you have some basckground in functional programming which i do not
07:22:17 <Marvin--> got a url?
07:22:20 <Marvin--> for the code
07:22:42 <Grinler> yeah gimme one sec...will put it up.  For anyone interested its for the game at http://www.modx.co.uk
07:22:46 <Grinler> one sec marvin
07:29:31 <Marvin--> why the hell are you sending it to me in a /msg if you expect to get help?
07:30:00 <Grinler> because your the only one who offered
07:30:06 <Grinler> http://216.213.8.26/haskell/ is the info on what I need help on
07:30:10 <phubuh_> <phubuh_> sure
07:30:23 <Marvin--> you didn't provide any information at all to base a decision on
07:30:47 <Marvin--> the worst possible thing to ask on irc is "can you help?" without saying *what* you need help with
07:31:10 <Grinler> uh...i was pretty sure i said that above
07:31:17 <Grinler> <Grinler> have a haskell program that intentionally broken, i dont know haskell, though i have attempted to learn it via the tutorials on haskell.org.  I have fixed as much as I could on my own but now im stuck.  this is not homework, but a game
07:31:17 <Grinler> <Grinler> most of the tutorials i read assume you have some basckground in functional programming which i do not
07:31:39 <Marvin--> still doesn't say anything, the fact that I had to ask for a url means that you didn't provide enough information
07:33:37 <Igloo> That looks very peculiar
07:34:25 <Igloo> Lunar: I'll see if it compiles, and will probably add it to the ghc6 packages shortly (a few days, maybe weeks away probably due to other issues) if so
07:39:17 <Marvin--> does anybody know of a program that runs a given program until it terminates or until X minutes has passed? (And then it should terminate the other program)
07:40:14 <Marvin--> I'm trying to write something up in python, but it fails to kill stuff properly
07:40:27 <shapr> Grinler: oh this is the x-mystery secret agent thing
07:40:32 <shapr> and this is the level eight challenge
07:40:37 <Grinler> level 7 :)
07:40:42 <Igloo> foo &; sleep $(( 60 * X )); kill %1; except the sleeping process won't go away early
07:40:47 <Grinler> need it to get to level8
07:40:50 <shapr> Grinler: aren't the rules such that you're sposed to learn how to fix that yourself?
07:41:04 <Grinler> rules are cant ask an agent, no rules that you can ask outside the game
07:41:09 <shapr> ah
07:41:19 <Marvin--> Igloo: hm
07:41:37 <Marvin--> a sleeping process isn't that cpu intensive, that doesn't really matter :)
07:41:47 <Igloo> :-)
07:42:31 <Grinler> shapr: and trust me im doing this as a last resort...ive gone over almost every tutorial on haskell.org, read about monadic parsing...its just beyond me
07:43:21 <Marvin--> Igloo: so ; binds tighter than &?
07:43:45 <Igloo> Oh, the first ; isn't necessary
07:44:17 <Marvin--> hm, actually, having the sleeping process die WOULD be nice, since I want to run the next test asap
07:44:41 <Marvin--> I wonder if I could have some scary cross-wiring of kills
07:44:46 <Igloo> The precedence doesn't matter there does it? But anyway, I think each applies only to the one immediately preceeding it
07:45:24 <Marvin--> probably not
07:45:34 <Marvin--> (re: cross-wiring)
07:46:29 <Igloo> Hmmm, sh -e ' { foo ; kill $$; } & sleep $(( 60 * X )); kill %1; '?
07:46:43 <Marvin--> hm
07:46:58 <Igloo> IM -c
07:47:04 <Marvin--> why {}?`don't you mean ()?
07:47:32 <Igloo> No, that would make a subshell
07:47:37 <Igloo> Oh, it doesn't like %1 there
07:48:25 <Marvin--> well, you do need a subshell in order to put it in the background, don't you?
07:48:57 <Marvin--> especially since $$ expands to the "parent", not the subshell's pid
07:49:26 <Marvin--> sh -c '( time ../run_eproof normal.tptp > proof.normal.0; kill $$ ) & sleep 60 ; kill %1'
07:49:27 <Igloo> Oh, maybe () would end up with 2 subshells then
07:49:29 <Marvin--> seems like it could work
07:51:18 <Marvin--> hm, no
07:52:07 <Marvin--> strange that the kill %1 doesn't work
07:52:12 <Igloo> Oh, actually, kliling $$ in either case ought to work
07:52:34 * Igloo waits 10 seconds
07:52:49 <Igloo> Hmm, no, doesn't kill the backgrounded process too
07:53:02 <Marvin--> (sleep 20 ; sleep 20) & sleep 1 ; kill %1 <- this does what I want...
07:53:46 <Igloo> But you can't then kill the watcher if you finish
07:53:51 <Igloo> I suspect it won't work in a script either
07:54:49 <Marvin--> oh wait... you probably don't get job control with sh -c :)
07:56:27 <Marvin--> bleagh
07:56:48 <Marvin--> gotta hate working with undecidable tests
07:56:59 <Igloo> OK, now I have it working in one direction but not the other
07:57:51 <Marvin--> I mean, the point is that I want to do N test runs that may or may not terminate within say 5 minutes
07:58:04 <Igloo> Confused
07:58:05 <Igloo> migloo@userpc15:~$ time sh -ic ' echo bar $$; { sleep 1 ; echo foo $$; kill $$; } & sleep 10; kill %1; '
07:58:08 <Igloo> bar 28332
07:58:11 <Igloo> [1] 28333
07:58:13 <Igloo> foo 28332
07:58:16 <Igloo> sh: kill: %1: no such job
07:58:18 <Igloo> The last line is the outer kill
07:58:29 <Marvin--> hm
07:59:02 <Igloo> Same with -9
07:59:10 <Igloo> Maybe I need to ignore a signal or something
07:59:25 <Marvin--> maybe I should just ask on #bash
07:59:51 <Marvin--> um
07:59:57 <Marvin--> I got op when I entered #bash... how fun :)
08:00:04 <Igloo> :-)
08:00:10 <Igloo> Was it empty?
08:00:36 <Igloo> Doh, I put the -9 in the wrong place
08:01:22 <Igloo> Right, sh -ic ' { sleep 1 ; echo foo; kill -9 $$; } & sleep 10; kill %1; '    and    sh -ic ' { sleep 10 ; echo foo; kill -9 $$; } & sleep 1; kill %1; '
08:01:44 <Marvin--> no, lots of people in #bash
08:01:50 <Marvin--> that works?
08:01:57 <Igloo> Yup
08:03:11 <Marvin--> hrrm, I'm getting syntax errors
08:04:03 <Igloo> $ sh --version
08:04:03 <Igloo> GNU bash, version 2.05b.0(1)-release (i386-pc-linux-gnu)
08:04:05 <Igloo> What errors?
08:04:18 <Marvin--> same here
08:04:30 <Marvin--> .
08:04:30 <Marvin--> (0)-(17:04)-(martin@winterfell) ~/exjobb/results$ bash -ic '{ ../run_eproof normal_typed.tptp > proof.normal_typed.0; kill -9 $$ } & sleep 30 ; kill %1'
08:04:30 <Marvin--> bash: syntax error: unexpected end of file
08:04:42 <Igloo> You need a ; before the }
08:04:47 <Marvin--> gah
08:06:31 <Marvin--> on the OTHER hand, someone at #bash suggested ulimit -t
08:06:34 <Marvin--> (d'oh!)
08:07:33 <Igloo> Tell them their solution is dull and uninspired
08:07:47 <Marvin--> hehe
08:08:24 <Igloo> Anyway, it doesn't satisfy your spec  :-)
08:08:44 <Marvin--> eh, the test runs are very cpu intensive anyway, so it doesn't really matter
08:13:32 * Marvin-- now feels very stupid
08:13:57 <Igloo> Oh?
08:14:45 <Marvin--> you know, if I'd bothered reading the lengthy eprover --help text, I'd have found the --cpu-limit flag
08:14:55 <Igloo> :-)
08:15:06 <Marvin--> rule #1: if it may or may not be interesting, eprover has a command line flag for it
08:15:18 <Marvin--> rule #2: only Stephan Schulz understands more than 50% of the flags
08:17:02 * Igloo gets very confused
08:17:23 <Igloo> Apparently nhc98 is in state installed for IA64, but there's no build log for it and it shouldn't compile
08:17:32 <Marvin--> eprover: CPU time limit exceeded, terminating
08:17:33 <Marvin--> joy
08:17:38 <Marvin--> eh
08:19:54 <Marvin--> <dufflebunk> program &  i=0; while [[ $( ps h -p $! ) ]] && [ $i -lt 600 ] ; do sleep 1; let i++; done ; kill $!
08:30:31 <Igloo> Lunar: HGL needs X11 which needs greencard, so it's unlikely to happen particularly soon
08:35:00 <Lunar^> Igllo: ok thanks
08:35:07 <Lunar^> s/Igllo/Igloo/
09:19:16 <p3rs3ph4n3> good afternoon :)
09:31:17 <Grinler> can anyone help me fix a piece of code.  It can be found at http://216.213.8.26/haskell.  I have tried all I could and just dont know haskell well enough
09:31:32 <Smerdyakov> Why are you fixing this piece of code?
09:40:28 <maximo_ragazzo> hello
09:41:29 <p3rs3ph4n3> hi maximo_ragazzo :)
09:42:41 <maximo_ragazzo> hi :))) p3rs3ph4n3 *******
09:42:54 <p3rs3ph4n3> ***************+
09:43:32 <maximo_ragazzo> :))))))
09:45:54 <Smerdyakov> Hoooo!!!!!!!!!!!!!1
09:47:43 <maximo_ragazzo> so where u guys and girls from?
09:51:31 <Lor> 4r3 W3 b31n6 l337 0r Wh47?
09:52:50 <p3rs3ph4n3> wh47s y0ur pr0bl3m 10r ?
09:56:33 <Lor> 5p34k1N6 l337 15 d4N63r0u5 f0R Y0uR h3417h: http://megatokyo.com/?strip_id=9
10:11:24 <Smerdyakov> Lor, hey, what did you mean by "representing" Chaitin's Omega yesterday?
10:11:59 <Smerdyakov> Lor, did you mean a predicate describing it?
10:12:16 <Lor> Yes, and a proof that a number with such a property exists.
10:12:40 <Smerdyakov> Is there some peculiarly set theoretical trick that you've seen used for that?
10:13:26 <Lor> I haven't seen it done, but I'd suppose it has to be "peculiarly set theoretical" at least in the sense that you have to have a way of postulating the existence of objects which you are unable to compute.
10:14:00 <Lor> That's why the approach of representing numbers as church numerals seems a bit strange.
10:14:15 <Smerdyakov> Not really. It's pretty easy to see that a program has to either terminate or not.
10:14:30 <Smerdyakov> That's just the law of the excluded middle.
10:14:37 <Lor> Because really the thing that separates math from CS is that in CS everything has to be computable. In math it suffices for things to just exist on their own right, whether we can compute them or not.
10:15:13 <Smerdyakov> I'd summarize that more succinctly by saying that most of CS is concerned with constructive logic only, but certainly not all.
10:15:24 <Lor> Essentially, yeah.
10:15:38 <Smerdyakov> At any rate, I fail to see why omega would be a problem case for higher order type theory.
10:16:23 <Lor> Frankly, I don't feel qualified to present any comments on this since I really don't know what I'm talking about. :)
10:16:49 <Smerdyakov> The simply typed lambda calculus isn't constructive.
10:17:02 <Smerdyakov> That just might be a false intuition you would get from the form of most of the proof rules.
10:17:24 <Lor> What do you mean "not constructive"?
10:20:39 <Smerdyakov> The law of the excluded middle is provable.
10:20:48 <Smerdyakov> You can prove an existential without demonstrating a witness.
10:20:49 <Smerdyakov> Etc.
10:21:12 <Lor> Uh, how can you have existentials in a simply typed system?
10:22:04 <Smerdyakov> A series of definitions. I'll read them out of my textbook. :)
10:22:13 <Smerdyakov> Equality is a primitive function.
10:22:48 <Smerdyakov> Forall takes a predicate on a type and checks it for equality with the always-true function.
10:23:13 <Smerdyakov> Negation compares for equality with falsehood, which is itself defined as "the always true function is equal to the identity function on booleans"
10:23:27 <Smerdyakov> And exists has the usual definition from forall and negation.
10:24:01 <Smerdyakov> So, you see, these definitions already do uncomputable things. :)
10:24:12 <Lor> Could you give a reference to that system?
10:24:30 <Lor> I get the feeling that it's something quite different from what I envisioned.
10:24:49 <Smerdyakov> Well, this is from the book "An Introduction to Mathematical Logic and Type Theory: To Truth Through Proof," by Peter B. Andrews.
10:25:22 <Smerdyakov> I've never looked for info on the web.
10:25:30 <Smerdyakov> This is a pretty unpopular view about formalizing math, these days.
10:25:50 <Smerdyakov> The text is written by the professor who's been teaching the class for 30 some years. :)
10:26:11 <Smerdyakov> It was out of print 2 years ago.
10:26:13 <Smerdyakov> BRB
10:26:38 <Lor> How can that be, since it was published 2002?
10:26:42 <Lor> http://gtps.math.cmu.edu/tttp.html
10:27:09 <Smerdyakov> That's a newer edition than the one I had. He was working on it when I took the class.
10:27:24 <Smerdyakov> I have a draft of it.
10:27:27 <Lor> Ah, ok.
10:28:58 <Lor> Yeah, the rationale in the preface pretty much reflects my own thoughts.
10:30:52 <Smerdyakov> Which are?
10:32:26 <Lor> Basically, that mathematicians are sloppy both with their notation and with their thinking, and types would let them clarify their concepts and deal with them more rigorously.
10:53:23 * shapr cackles cheerfully
10:53:44 <shapr> chuck moore says types are a crutch, and that real programmers don't need them.
10:56:26 <yazirian> well, I guess perl is pretty popular :)
11:33:51 <p3rs3ph4n3> The middle section of a list composed of one element if the list is of
11:33:51 <p3rs3ph4n3> odd length, and two elements if the list is of even length.
11:33:51 <p3rs3ph4n3> For example
11:33:54 <p3rs3ph4n3> Main> mid [1,2,3,4,5]
11:33:55 <p3rs3ph4n3> [3]
11:33:57 <p3rs3ph4n3> Main> mid [1,2,3,4,5,6]
11:33:59 <p3rs3ph4n3> [3,4]
11:34:01 <p3rs3ph4n3> Main> length (mid [])
11:34:03 <p3rs3ph4n3> 0
11:34:05 <p3rs3ph4n3> is there any way of solving this
11:34:08 <p3rs3ph4n3> without the conditional?
11:34:20 --- mode: simak.freenode.net set +b *!23kjhkjf@*
11:35:08 <phubuh_> p3rs3ph4n3, huh? what's the problem? what's "this"?
11:35:27 * vegai smells homework.
11:35:46 <p3rs3ph4n3> this is the function mid
11:35:56 <p3rs3ph4n3> vegai no it's not an homework
11:36:29 <vegai> ok, so what's the problem?
11:37:14 <p3rs3ph4n3> i'm asking if it's any way of making the function mid without using the conditional
11:38:15 <vegai> ok... guess I'm a bit tired ;P
11:38:23 <p3rs3ph4n3> ok
11:44:17 <Darius> Define "the conditional"
11:44:40 <p3rs3ph4n3> if ... then ... else
11:44:58 <p3rs3ph4n3> i'm trying to do with dropWhile
11:45:03 <phubuh_> that's "a conditional", not "the conditional"
11:45:18 <p3rs3ph4n3> ?!
11:46:01 <p3rs3ph4n3> i did an auxiliar function
11:46:04 <Darius> Then yes, of course, pattern matching, guards, and/or case analysis can always replace if then else.  In fact, if then else can be considered a derived form.
11:46:25 <p3rs3ph4n3> mid1 xs = xs !! x
11:46:26 <p3rs3ph4n3> where
11:46:55 <p3rs3ph4n3> x = ((length xs) - 1) `div` 2
11:47:13 <p3rs3ph4n3> i did that auxiliar function
11:47:18 <p3rs3ph4n3> now i'm trying to do
11:47:23 <p3rs3ph4n3> something like this
11:47:42 <p3rs3ph4n3> dropWhile (<mid1 xs)
11:49:15 <Darius> Typically, case is the only branching construct, all others being built from it, and even it isn't absolutely necessary.
11:49:48 <p3rs3ph4n3> so what i'm doing is wrong?
11:52:34 <Darius> I have no idea.  If all you need to do is write the function without explicitly using if, or using something other than if than that doesn't require too much effort.
11:56:19 <ski> p3rs3ph4n3 : hi
11:56:43 <p3rs3ph4n3> ski hi :)
11:57:07 * shapr chortles merrily
11:57:19 <p3rs3ph4n3> ski i'm doing something but i don't know if it's wrong
11:57:24 <p3rs3ph4n3> can you help me
11:57:37 <p3rs3ph4n3> i'm writting function mid
11:57:38 <ski> shapr : what is chortle ?
11:57:43 <p3rs3ph4n3> that is :
11:57:47 <ski> i can but try
11:58:07 <p3rs3ph4n3> The middle section of a list composed of one element if the list is of
11:58:07 <p3rs3ph4n3> odd length, and two elements if the list is of even length.
11:58:07 <p3rs3ph4n3> For example
11:58:07 <p3rs3ph4n3> Main> mid [1,2,3,4,5]
11:58:07 <p3rs3ph4n3> [3]
11:58:07 <p3rs3ph4n3> Main> mid [1,2,3,4,5,6]
11:58:09 <p3rs3ph4n3> [3,4]
11:58:11 <p3rs3ph4n3> Main> length (mid [])
11:58:13 <p3rs3ph4n3> 0
11:58:19 <p3rs3ph4n3> so what i did till now is this
11:58:29 <p3rs3ph4n3> mid1 xs = xs !! x
11:58:30 <p3rs3ph4n3>            where
11:58:30 <p3rs3ph4n3> 	      x = ((length xs) - 1) `div` 2
11:58:30 <p3rs3ph4n3>  mid xs |dropWhile (<mid1 xs)
11:58:30 <p3rs3ph4n3>         |takeWhile (=mid1 xs)
11:58:41 <ski> ok
11:59:32 <ski> err
11:59:40 <shapr> @wn chortle
11:59:41 <lambdabot> *** "chortle" wn "WordNet (r) 2.0"
11:59:41 <lambdabot> chortle
11:59:41 <lambdabot>      n : a soft partly suppressed laugh [syn: {chuckle}]
11:59:41 <lambdabot>      v : laugh quietly or with restraint [syn: {chuckle}, {laugh
11:59:42 <lambdabot>          softly}]
11:59:49 <ski> does that syntax-check ?
11:59:50 <shapr> ski: it's from Lewis Carrol
12:00:10 <p3rs3ph4n3> ERROR "C:\Os meus documentos\mid.hs":6 - Syntax error in input (unexpected symbo
12:00:11 <p3rs3ph4n3> l "mid")              
12:00:16 <p3rs3ph4n3> gives that error
12:00:20 <ski> shapr : Alice in Wonderland ?
12:02:01 <ski> you have defined a function mid1 (almost, at least), and now you want to define another function mid, in terms of mid1 ?
12:02:29 <p3rs3ph4n3> i did mid1 as an auxiliary function
12:02:48 <ski> i think you probably want to remove the space in front of "mid xs |dropWhile ...."
12:03:42 <p3rs3ph4n3> i took the space it gave other error
12:03:57 <p3rs3ph4n3> ERROR "C:\Os meus documentos\mid.hs":6 - Syntax error in declaration (unexpected
12:03:57 <p3rs3ph4n3>  `|')                                                                       
12:04:11 <ski> and if you want mid1 as just an auxilary function to mid, you should put it in a where-clause after mid, i think
12:04:38 <ski> hmm
12:04:55 <ski> i think it is talking about the second |
12:05:26 <ski> the general form for a def. line with guards is something like
12:05:40 <p3rs3ph4n3> yes it's the second
12:05:42 <ski> f p0 p1 ... pn
12:05:50 <ski>   | b0 = e0
12:05:56 <ski>   | b1 = e1
12:06:01 <ski>   | ...
12:06:07 <ski>   | bm = em
12:06:21 <p3rs3ph4n3> but in this case i only have the b's
12:06:24 <p3rs3ph4n3> not the e's
12:06:53 <ski> so each guard should have one test (boolean expression) and then an '=' and then what to return in that case
12:06:58 <ski> yes
12:07:06 <ski> you should have e's also
12:07:28 <p3rs3ph4n3> but in the b's i have functions from the prelude
12:07:42 <ski> so ?
12:07:50 <p3rs3ph4n3> i can't put the = after them cause i have nothing to put there
12:08:11 <ski> there should be no problem of using prelude functions in guard test, methinks
12:08:17 <p3rs3ph4n3> only if i put equal to True 
12:08:50 <ski> sorry ?  you don't want the function mid to return in any of these cases ?
12:09:31 <p3rs3ph4n3> yes i do
12:09:35 <ski> i though you wanted the function to return a list of one or two elements
12:09:45 <p3rs3ph4n3> yes
12:10:09 <ski> then, i you use guards, you surely must return something in each guard case ?
12:10:18 <ski> s/i/if/
12:10:47 <p3rs3ph4n3> mid xs |dropWhile(<mid1 xs) = xs
12:10:48 <p3rs3ph4n3>         |takeWhile(==mid1 xs) = xs
12:11:00 <ski> ok, hmm
12:11:31 <ski> for what purpose are you calling dropWhile,takeWhile ?
12:11:49 <p3rs3ph4n3> i'm calling them
12:12:05 <p3rs3ph4n3> cause i want only the two/one element(s)
12:12:09 <p3rs3ph4n3> from the middle
12:12:59 <ski> ok, so you thought you should first drop initial elements, and then final, so you get only the middle ones ?
12:13:08 <p3rs3ph4n3> yes
12:14:02 <ski> then that would perhaps look something like "takeWhile (yadda) (dropWhile (kladda) xs)"
12:14:49 <ski> (i.e. if that approach to solving the problem is workable/correct. which i'm not sure it is)
12:15:21 <p3rs3ph4n3> so what approach do you think i should have?
12:15:34 <ski> anyway, if you want to drop, and then take elements of a list, you got to pass the results from the dropping to the taking function, ok ?
12:15:42 <ski> well
12:15:48 <ski> it depends
12:16:09 <ski> is the input list to mid always sorted in ascending order ?
12:16:11 <p3rs3ph4n3> i can't use the conditional 
12:16:43 <p3rs3ph4n3> the example it's like this
12:16:44 <ski> conditional ??    if-then-else ? guards ? case ?
12:16:58 <p3rs3ph4n3> mid [1,2,3,4,5,6]
12:17:05 <p3rs3ph4n3> conditional if then else
12:17:12 <ski> ok
12:17:13 <p3rs3ph4n3> [3,4]
12:17:22 <p3rs3ph4n3> but the numbers doesn't matter
12:17:34 <p3rs3ph4n3> what matters are the elements in the middle
12:18:06 <ski> ('cuz  "cond" in scheme corresponds more or less to guards in haskell (not if-then-else))
12:18:28 <p3rs3ph4n3> ok
12:19:23 <ski> i think you could probably use a dropWhile (< leftMiddleX)  for removing the initial part, *if* the list is sorted ascending
12:20:06 <p3rs3ph4n3> but i think you didn't understood one thing i said
12:20:16 <ski> but, you want the function to work in any case, weather the list was sorted or not, is that correct ?
12:20:25 <p3rs3ph4n3> there's no nedd the list being sorted ascending
12:20:26 <ski> ok, what ?
12:20:31 <ski> ok
12:20:44 <p3rs3ph4n3> only matters the elements in the middle
12:21:04 <p3rs3ph4n3> even if the list is sorted descending
12:21:04 <ski> then i think you can not use dropWhile
12:21:24 <p3rs3ph4n3> why?
12:21:59 <ski> because dropWhile doesn't keep track of where in the list it is, only looks for the first place something happens (so to speak)
12:22:12 <ski> say e.g.
12:22:32 <ski> mid [1,2,3,2,3,2,1]
12:22:55 <ski> if you use mid1 to get the (left) middle element, you get 2, right ?
12:23:06 <p3rs3ph4n3> yes
12:23:39 <ski> if you then use, perhaps, dropWhile (/= leftMiddleElement)
12:24:02 <p3rs3ph4n3> oh i see
12:24:11 <p3rs3ph4n3> it will only drop number 1
12:24:11 <ski> then you get the list  [2,3,2,3,2,1]  and not  [2,3,2,1] as you would like, no ?
12:24:14 <ski> yes
12:24:39 <p3rs3ph4n3> so what function should i use?
12:24:52 <ski> ans using < doesn't work because the list isn't necessarily sorted
12:25:28 <ski> *should* you use a predefined function ?   (i don't know)
12:25:40 <p3rs3ph4n3> i could make
12:25:48 <ski> ?
12:25:49 <p3rs3ph4n3> take (mid1 xs)
12:25:56 <p3rs3ph4n3> but i have a problem
12:26:04 <ski> mhmm ?
12:26:08 <p3rs3ph4n3> take doesn't let me put a function as argument
12:26:22 <ski> do you need that ?
12:26:34 <ski> what function would you like to pass ?
12:26:43 <p3rs3ph4n3> mid1 xs
12:26:59 <ski> ?
12:27:04 <p3rs3ph4n3> is that mid1 xs make what i want
12:27:09 <p3rs3ph4n3> but with numbers
12:27:11 <ski> what function ... ?
12:27:19 <p3rs3ph4n3> and i want to do it with lists
12:27:29 <p3rs3ph4n3> mid1 xs = xs !! x
12:27:29 <p3rs3ph4n3>             where
12:27:29 <p3rs3ph4n3> 	      x = ((length xs) - 1) `div` 2
12:27:33 <p3rs3ph4n3> this one
12:27:51 <ski> sorry, i didn't understand the last you said (before the code)
12:28:13 <ski> you want to use this function ?
12:28:18 <p3rs3ph4n3> yes
12:28:34 <p3rs3ph4n3> that function makes mid work but with numbers
12:28:42 <p3rs3ph4n3> but instead of numbers
12:28:51 <p3rs3ph4n3> it should make with lists
12:28:57 <p3rs3ph4n3> for example
12:29:13 <p3rs3ph4n3> mid1 [1,3,5,7,11]
12:29:16 <ski> but you hardly want to pass this function to another function, no ?   (you want to pass the *result* from this function (on xs) to another function, possibly)
12:29:17 <p3rs3ph4n3> returns 5
12:29:36 <p3rs3ph4n3> mid shoud return [5]
12:29:57 <p3rs3ph4n3> yes that's what i want ski the result of mid1 passed to mid
12:30:28 <ski> hmm, mid1 calls !! which takes out one element of xs
12:31:31 <ski> in my mind, it seems easier (at least for me) to write a new function similar to !!, but it should return a (contiguous) sublist of xs, and not just one element
12:32:16 <p3rs3ph4n3> yes but !! only let us return a number
12:32:27 <ski> what do you think ?  we could probably write mid in terms of mid1.  it will perhaps even be fun ;}
12:33:24 <ski> yes, in that case, we have to write a function which looks a bit like !!, but will take two Int's, instead of one
12:33:39 <p3rs3ph4n3> yes
12:34:20 <ski> yes ??  what alternative do you want ?  :)
12:34:38 <ski> both ?  ;)
12:34:45 <p3rs3ph4n3> the last one i guess
12:35:00 <ski> ok
12:35:05 <ski> @prelude !!
12:35:07 <lambdabot> *** "!!" prelude "Haskell Standard Prelude Dictionary": text follows
12:35:07 <lambdabot> !!
12:35:07 <lambdabot>   See (!!)
12:35:08 <Xcalibor> hi all
12:35:18 <ski> @prelude (!!)
12:35:19 <lambdabot> *** "(!!)" prelude "Haskell Standard Prelude Dictionary": text follows
12:35:19 <lambdabot> (!!)
12:35:19 <lambdabot>   infixl 9 !!
12:35:19 <lambdabot>   (!!) ::  [a] -> Int -> a
12:35:20 <lambdabot>   (x:_)  !! 0       = x
12:35:22 <lambdabot>   (_:xs) !! n | n>0 = xs !! (n-1)
12:35:24 <lambdabot>   (_:_)  !! _       = error "Prelude.!!: negative index"
12:35:26 <lambdabot>   []     !! _       = error "Prelude.!!: index too large"
12:35:28 <lambdabot> [2 @more lines]
12:35:30 <ski> Xcalibor : hi
12:35:34 <ski> @more
12:35:52 <ski> @more
12:35:57 <ski> hm ?
12:36:07 <p3rs3ph4n3> (!!) :: [Int] -> Int -> Int -> Int
12:36:48 <ski> if you want an operator we should probably tuple the two Int args into a pair
12:37:30 <p3rs3ph4n3> (!!) :: (Int, Int)
12:37:33 <p3rs3ph4n3> like this?
12:37:35 <ski> also, we should probably not be calling it !!.  do you have any good operator symbol ?  or should we stick to an ordinary function name ?
12:37:42 <ski> like :
12:38:15 <p3rs3ph4n3> the main function has to be called mid
12:38:16 <ski> #$k32ljkh4$%#  :: [a] -> (Int,Int) -> a
12:38:35 <ski> where #$k32ljkh4$%# is out name (function or operator)
12:38:41 <ski> s/out/our/
12:38:49 <ski> ok, no problem
12:38:58 <ski> this is not the main function
12:39:02 <p3rs3ph4n3> mid :: [a] -> (Int,Int) -> a
12:39:11 <phubuh_> i'm getting this strange error on compilation of gtk2hs:
12:39:18 <ski> no, i thought you wanted :
12:39:20 <phubuh_> make -Cgtk noinplace
12:39:20 <phubuh_> make[1]: Entering directory `/home/phubuh/software/gtk2hs-0.9.3/gtk'
12:39:20 <phubuh_> Removing old local entry for "gtk2".
12:39:20 <phubuh_> /home/phubuh/software/gtk2hs-0.9.3/localpackage.conf: package `gtk2' not found
12:39:20 <phubuh_> make[1]: *** [noinplace] Error 1
12:39:21 <phubuh_> make[1]: Leaving directory `/home/phubuh/software/gtk2hs-0.9.3/gtk'
12:39:23 <phubuh_> make: *** [noinplace] Error 2
12:39:27 <ski> mid :: [a] -> [a]
12:39:41 <p3rs3ph4n3> yes you're rigth
12:39:48 <p3rs3ph4n3> this one will be an auxiliar
12:39:54 <ski> right
12:40:24 <p3rs3ph4n3> i i'll call her middy :)
12:40:32 <ski> so how should we write mid, in terms of middy ?
12:40:35 <p3rs3ph4n3> middy :: [a] -> (Int,Int) -> a
12:40:59 <ski> hmm, we'll also have to decide what the Int's to middy mean
12:41:16 <ski> the first is probably the starting index, yes ?
12:41:22 <p3rs3ph4n3> yes
12:41:28 <p3rs3ph4n3> and the other the final
12:41:50 <ski> is the second the number of elements or the finishing index (or perhaps one plus that) ?
12:41:54 <p3rs3ph4n3> but when i have only one number will mid works?
12:42:19 <ski> only one number ?  where ?
12:42:23 <ski> in what ??
12:42:49 <p3rs3ph4n3> when mid is odd it will return only one element
12:42:57 <ski> yes
12:43:03 <p3rs3ph4n3> only when it's even it will be a pair
12:43:26 <ski> i don't think that should be a problem, just get a sub-sequence of length 1
12:43:41 <p3rs3ph4n3> ah ok
12:44:08 <ski> either (n,1) or (n,n) or (n,n+1)  depending on the decited meaning
12:44:25 <ski> s/t/d/
12:44:50 <p3rs3ph4n3> ok
12:45:25 <ski> so we have to choose one of the 3 and stick to it..
12:45:31 <ski> which one
12:45:49 <p3rs3ph4n3> the finishing index
12:46:01 <p3rs3ph4n3> no
12:46:06 <p3rs3ph4n3> (n,n+1)
12:46:37 <ski> the middle one is inelegant to get an empty sublist, but perhaps that's not so important (the empty sublist is between any two elements anyway..  hmm?)
12:46:47 <ski> ok
12:47:05 <ski> then shall we write mid ?
12:47:20 <p3rs3ph4n3> yes
12:47:28 <ski> i think we can look at the code for mid1 and reuse some of it
12:47:48 <p3rs3ph4n3> mid1 xs = xs !! [x]
12:47:48 <p3rs3ph4n3>             where
12:47:48 <p3rs3ph4n3> 	      [x] = ((length xs) - 1) `div` 2
12:48:12 <ski> how do we get the starting index to cut off the initial part with ?
12:48:13 <p3rs3ph4n3> [x] were x
12:48:19 <ski> ok
12:48:31 <ski> i.e. n above
12:48:57 <p3rs3ph4n3> dropping the initial part
12:49:15 <ski> your x in mid1 is an index into xs, right ?
12:49:22 <p3rs3ph4n3> yes
12:49:31 <ski> where into xs does it point ?  (0-based indexing)
12:50:07 <p3rs3ph4n3> sorry didn't understood your question
12:50:26 <ski> which element in xs has x as index ?
12:50:39 <p3rs3ph4n3> the middle one
12:50:39 <ski> (should not be so hard, i think)
12:50:57 <ski> what middle one ?  (in case of even number of elements)
12:51:05 <ski> left or right ?
12:51:09 <p3rs3ph4n3> the left one
12:51:15 <ski> ok
12:51:26 <p3rs3ph4n3> but in mid it should take the two middle ones
12:51:47 <ski> hmm .... (checking) ... yes, that seems right
12:51:52 <ski> yes
12:52:15 <p3rs3ph4n3> mid1 i tested in hugs and it works well
12:52:52 <ski> but in mid we need to have an index to the starting point of the sublist, and one to the finishing point plus 1
12:53:20 <p3rs3ph4n3> yes we need two indexs
12:53:26 <p3rs3ph4n3> ´not only a x but a y too
12:53:54 <ski> say you take the def. of x in mid1 and copy it to mid's where-clause, and rename it to, say, leftMiddle, or whatever you like
12:54:09 <phubuh_> the build process for gtk2hs is horribly broken
12:54:42 <ski> because the x def. in mid1 computes the left middle index, and that is one of the things we need in mid, yes ?
12:55:12 <p3rs3ph4n3> yes it will help solve when we only have a number
12:56:09 <ski> also, for two numbers, yes ?
12:56:18 <p3rs3ph4n3> yeah
12:56:41 <ski> somewhere in mid we'll call middy with (blaha,jaha) as args
12:56:54 <Smerdyakov> Blaha and jaha are my dear, dear friends.
12:57:15 <Smerdyakov> (I can tell from your choices of names that you aren't a native English speaker. :D)
12:57:40 <p3rs3ph4n3> lol why blaha and jaha?
12:57:42 <ski> Smerdyakov : sometimes i use generic foo,bar,... stuff
12:57:54 <ski> um
12:58:08 <ski> jaha means "so what" in swedish
12:58:09 <Smerdyakov> Yeah, but "jaha" is not a sequence of syllables occuring in any English word, I think.
12:58:22 <ski> no :)
12:58:58 <ski> i can't for the moment think of the translation of blaha
12:59:06 <p3rs3ph4n3> lol
12:59:13 <Smerdyakov> "Blah"?
12:59:21 <p3rs3ph4n3> ok i'll call them sara and manel
12:59:29 <ski> perhaps ?
12:59:30 <p3rs3ph4n3> 2 portuguese names :)
13:00:40 <ski> Smerdyakov : sometimes i call them things like : mogno,cp,apa,banan,kroffo,hajp, ...
13:00:53 <ski> (in no particular order)
13:01:02 <p3rs3ph4n3> mogno it's a kind of wood :)
13:01:08 <ski> is it ?
13:01:11 <p3rs3ph4n3> yes
13:01:26 <p3rs3ph4n3> it's very dark wood
13:01:52 <p3rs3ph4n3> i think it comes from india
13:02:29 <ski> well the mogno i use is a missspelling of a word that i perhaps don't use politically correct (in this context) ... ;?
13:02:34 <ski> also cp
13:03:00 <p3rs3ph4n3> in portuguese mogno is wood :)
13:03:21 <ski> (well, perhaps swedish readers can guess ...)
13:03:41 <ski> mahogny ?
13:03:56 <p3rs3ph4n3> what means mahogny?
13:04:05 <ski> it a kind of wood.
13:04:17 <ski> i wondered if it was the same as your mogno..
13:04:38 <p3rs3ph4n3> mahogny comes from india?
13:04:38 <p3rs3ph4n3> and it's dark?
13:04:57 <ski> often used for panels on boat, i think.  or something
13:05:12 <ski> it is dark brown
13:05:22 <p3rs3ph4n3> mogno
13:05:23 <p3rs3ph4n3> do Ing. mahogany
13:05:23 <p3rs3ph4n3> s. m., Bot., 
13:05:23 <p3rs3ph4n3> árvore meliácea da América;
13:05:23 <p3rs3ph4n3> madeira dessa árvore;
13:05:23 <p3rs3ph4n3> acaju.
13:05:35 <p3rs3ph4n3> that's an portuguese dictionary
13:05:39 <p3rs3ph4n3> it's the same
13:05:54 <p3rs3ph4n3> our mogno comes from the english mahogany
13:06:21 <ski> http://www.algonet.se/~peterny/pr_a06.htm
13:06:45 <ski> sailing boat, exclusive mahogny coast cruiser : For sale
13:07:01 <ski> (word for word translation, mind)
13:07:13 <p3rs3ph4n3> i only understood the word svenska lol
13:07:57 <p3rs3ph4n3> yes it's the wood of the boat
13:08:04 <ski> table in mahogny : http://www2.blocket.se/view/1506016.htm?l=0&c=1
13:08:18 <ski> does it look like mogno ?
13:08:42 <ski> bookcase : http://www2.blocket.se/view/1474319.htm?l=0
13:08:43 <p3rs3ph4n3> it doesn't look like mogno
13:08:46 <ski> ok
13:08:47 <p3rs3ph4n3> it is mogno!
13:08:54 <ski> ?
13:08:56 <p3rs3ph4n3> :)
13:09:07 <ski> are you contradicting yourself ??
13:09:19 <p3rs3ph4n3> no
13:09:20 <ski> :)
13:09:24 <p3rs3ph4n3> lol
13:09:31 <p3rs3ph4n3> it's really mogno
13:09:39 <p3rs3ph4n3> it's not sembable
13:09:43 <p3rs3ph4n3> it is mogno really
13:09:48 <p3rs3ph4n3> forget lol
13:09:51 <p3rs3ph4n3> it's mogno
13:09:55 <ski> ok, so we have sorted that out then. :)
13:10:10 <p3rs3ph4n3> yeah :)
13:10:44 <ski> (i presume sembable is another portuguese word for a kind of wood. perhaps i should start using it as a variable name ? :)
13:10:55 <p3rs3ph4n3> lol
13:11:07 <p3rs3ph4n3> sembable i think it was english
13:11:15 <p3rs3ph4n3> it means "seems"
13:11:48 <ski> ok, one Swedish-English-Swedish dictionary says that mahogany is also the same ..
13:12:14 <ski> does a wood name mean "seems" ??
13:12:22 <p3rs3ph4n3> noooooo
13:12:34 <p3rs3ph4n3> sembable means "seems"
13:12:35 <ski> :)
13:12:41 <ski> ?
13:12:45 <p3rs3ph4n3> sembable it's not a wood name
13:12:48 <p3rs3ph4n3> :)
13:12:48 <ski> aha
13:14:24 <ski> well where were we ?  (nice alitteration)
13:14:36 <p3rs3ph4n3> yes good one
13:14:41 <p3rs3ph4n3> we were in mid
13:14:46 <ski> right
13:14:52 <p3rs3ph4n3> middy :: [a] -> (Int,Int) -> a
13:14:52 <p3rs3ph4n3>  mid :: [a] -> [a]
13:14:52 <p3rs3ph4n3>             where
13:14:52 <p3rs3ph4n3> 	      leftMiddle = ((length xs) - 1) `div` 2
13:14:57 <ski> ok
13:15:10 <ski> don't indent mid one space !
13:15:44 <ski> probably we should start like :
13:15:50 <ski> mid xs = ...
13:16:38 <p3rs3ph4n3> instead of mid:: ? mid xs =
13:16:40 <ski> what should we return ?  a sublist, right ?  and middy is going to give us that
13:16:43 <ski> no
13:16:53 <ski> not instead of the type signature
13:17:02 <ski> on a new line, under it
13:17:18 <ski> um, waitasec..
13:17:25 <p3rs3ph4n3> ok
13:18:01 <ski> middy has wrong type, right ?
13:18:24 <p3rs3ph4n3> yes
13:18:33 <ski> you see what is wrong ?
13:18:50 <ecraven> lg
13:18:53 <p3rs3ph4n3> the pair shoud be a list
13:19:01 <ski> um
13:19:06 <ski> why
13:19:21 <p3rs3ph4n3> cause the return in mid will be a list
13:19:30 <ski> we only need two indices, right ?   start and end, no ?
13:19:52 <p3rs3ph4n3> yes
13:19:56 <ski> yes, we want a list from middy
13:20:18 <ski> so change middy's type accordingly
13:20:36 <p3rs3ph4n3> ok a minute
13:21:17 <p3rs3ph4n3> middy :: [a] -> [(Int,Int)] -> [a]
13:21:34 <ski> um
13:22:01 <ski> i think this is not what we want
13:22:38 <ski> letssee.. , middy should take a list of a's, correct.
13:23:03 <p3rs3ph4n3> yes
13:23:36 <ski> and it should select out a (contiguous) sublist with the help of two indices, a starting index and an ending end, right ?
13:24:05 <p3rs3ph4n3> yes
13:24:17 <ski> is it doing that ?
13:24:36 <p3rs3ph4n3> no
13:24:58 <ski> then change it again :)
13:25:21 <p3rs3ph4n3> middy :: [a] -> [(Int,Int)] 
13:25:30 <ski> and...
13:25:59 <ski> no (mea culpa)
13:26:27 <ski> [(Int,Int)] is a list of pairs of indices, right ?
13:26:34 <p3rs3ph4n3> yes
13:26:52 <ski> how many indices do we need ?             :)
13:26:56 <p3rs3ph4n3> 2
13:27:07 <ski> yesss !
13:27:10 <ski> :)
13:27:52 <ski> so i think it is better to make sure that one can only pass two indices to middy
13:28:20 <ski> (that way we don't have to check for it in middy's implementation)
13:28:29 <ski> do you follow ?
13:28:47 <p3rs3ph4n3> [(Int)]
13:28:48 <p3rs3ph4n3> ?
13:29:36 <ski> if something has type [Int], how few, and how many Int's can it contain ?   (should be easy)
13:29:48 <p3rs3ph4n3> one
13:30:18 <ski> @eval [1,2,3,4]
13:30:18 <lambdabot> [1, 2, 3, 4]
13:30:30 <p3rs3ph4n3> n
13:30:31 <ski> @type [1,2,3,4]
13:30:31 <lambdabot> [1,2,3,4] :: Num a => [a]
13:30:42 <ski> n ?
13:31:36 <p3rs3ph4n3> n ints
13:31:50 <ski> where n can be ... ?
13:31:57 <p3rs3ph4n3> a
13:32:29 <ski> ?
13:33:03 <p3rs3ph4n3> a from [a]
13:33:08 <ski> is n a complex number ? a boolean ? a prime number ? an infinite ordinal ?
13:33:20 <ski> :)
13:33:42 <p3rs3ph4n3> ñ ia an int
13:34:04 <ski> except it can't be negative, right ?
13:34:35 <p3rs3ph4n3> rigth
13:34:38 <ski> ok
13:35:41 <ski> so if middy gets something of type [Int], that thing can contain from 0 upto how many Int's you want (i.e. no upper bound)
13:36:08 <p3rs3ph4n3> + 8 (lay)
13:36:24 <p3rs3ph4n3> i mean more infinite (positive)
13:36:38 <ski> i was suggesting that we could perhaps just send to middy something that will always contain the correct number of indices (how many indices did middy need ?)
13:36:48 <ski> yes
13:36:55 <p3rs3ph4n3> 2
13:36:58 <ski> yes
13:37:27 <ski> so, can you think of a type, whose values will always contain 2 Int's ?
13:38:09 <ski> no ?
13:38:17 <p3rs3ph4n3> double
13:38:21 <ski> shall i say it ?
13:38:52 <ski> no, not Double, that is a floating point number with double precision (whatever that means)
13:39:15 <ski> or..
13:39:39 <ski>                              do you mean pair by double ?
13:39:48 <p3rs3ph4n3> yes
13:39:52 <ski> yes
13:39:57 <ski> like
13:40:13 <ski> @type (42,12+5)
13:40:13 <lambdabot> (42,12 + 5) :: (Num a, Num b) => (b,a)
13:40:17 <ski> or
13:40:50 <ski> @type ("rats live on no evil star","potrzebie")
13:40:50 <lambdabot> ("rats live on no evil star","potrzebie") :: ([Char],[Char])
13:41:13 <p3rs3ph4n3> oh
13:41:26 <p3rs3ph4n3> ([Int],[Int])
13:41:33 <ski> yes
13:41:38 <ski> thank you
13:41:40 <ski> no
13:41:43 <ski> almost
13:41:58 <ski> that is a pair of list of int and list of int
13:42:17 <ski> and each list can still contain upto infinity elements
13:42:20 <Smerdyakov> [([[Int]], [[[Int]]])] ?
13:42:30 <ski> Smerdyakov : :-P
13:42:31 <p3rs3ph4n3> (Int,Int)
13:42:40 <ski> yes
13:42:49 <ski> simple and nice
13:42:54 <ski> not complicated
13:43:03 <p3rs3ph4n3> yeah
13:43:17 <ski> so perhaps we can go back to mindy's type now, eh :)
13:43:18 <p3rs3ph4n3> the problem is that i complicate too much
13:43:40 <p3rs3ph4n3> yes
13:43:42 <ski> me too, perhaps (?)  (sometimes)
13:44:01 <ski> mindy :: [a] -> ???
13:44:41 <p3rs3ph4n3> middy :: [a] -> (Int,Int)
13:45:02 <ski>                           -> ???
13:45:27 <ski> middy :: [a] -> (Int,Int) -> ??
13:45:38 <p3rs3ph4n3> (a,a)
13:45:39 <p3rs3ph4n3> ?
13:46:09 <ski> p3rs3ph4n3 : sorry, i, for some time, thought you called the function *mindy*  :)
13:46:14 <SyntaxPolice> hi all. so can anyone tell me the latest word on a Haskell XML-RPC or SOAP implementation?
13:46:19 <SyntaxPolice> shapr alive?
13:46:48 <p3rs3ph4n3> no problem mindy or middy , just names :)
13:47:33 <ski> SyntaxPolice : he was at 11:59:50 according to clog
13:47:54 <ski> (a,a)  ?
13:47:58 <SyntaxPolice> wow. if you search for haskell xmlrpc, you get my wiki on the 5th hit
13:48:06 <p3rs3ph4n3> a ?
13:48:07 <SyntaxPolice> but I don't know anything about it! stupid google.
13:48:18 <ski> do you remember what middy was supposed to return ?
13:48:28 <p3rs3ph4n3> a list
13:48:34 <p3rs3ph4n3> [InT]
13:48:34 <ski> yes
13:48:43 <ski> a list of what ?
13:48:49 <p3rs3ph4n3> of int
13:48:52 <ski> why ?
13:49:11 <p3rs3ph4n3> cause the numbers in the middle are ints
13:49:24 <ski> shouldn't   middy "abcdefg" (3,5)  be a valid call ?
13:49:44 <p3rs3ph4n3> yes
13:49:53 <p3rs3ph4n3> no
13:49:57 <p3rs3ph4n3> no
13:50:06 <p3rs3ph4n3> only numbers
13:50:08 <ski> i.e. if middy is going to be a general, grown-up function, working on many sorts of lists
13:50:29 <ski> otherwise the [a] as the type of the first argument is wrong
13:51:09 <ski> (i.e. the first arg of middy)
13:51:10 <p3rs3ph4n3> i think instead of [a] should be [Int]
13:51:35 <ski> yes, if you want it monomorphic, it should be that.
13:51:40 <ski> shall we ?
13:51:44 <p3rs3ph4n3> yes
13:51:50 <ski> ok
13:52:02 <p3rs3ph4n3> middy :: [Int] -> [(Int,Int)]
13:52:18 <shapr> SyntaxPolice: no way!
13:52:19 * ski stadfaester haemed detta !
13:52:40 <p3rs3ph4n3> what you said?!
13:52:51 <shapr> stedfastly something that
13:52:58 <SyntaxPolice> shapr: no way what/!
13:53:42 <ski> (it means : "ski hearby ratifies this !")
13:53:59 <SyntaxPolice> man. I've been java hacking for weeks and have missed #haskell :(
13:54:11 <SyntaxPolice> actually a lot of this so-called "hacking" is writing documents too :(
13:54:16 <p3rs3ph4n3> please not java
13:54:17 <ski> shapr : stadfaesta aer ett roligt ord :)
13:54:42 <SyntaxPolice> p3rs3ph4n3: please.not(java);
13:55:24 <ski> not (Y not) ?
13:55:44 <SyntaxPolice> missing semi-colon!
13:56:12 <ski> SyntaxPolice : you talking to me ?
13:56:15 <p3rs3ph4n3> System.out.println("I'm alergic to java");
13:57:16 <ski> i'm not sure i like .-syntax for methods ...
13:57:57 <SyntaxPolice> :)
13:58:37 <ski> prefix methods seems cleaner.  dunno about how it looks in large hairy programs, though
13:58:55 <SyntaxPolice> I was thinking that one could use greencard to implement an xml-rpc thing overtop of a C xml-rpc thing. have you given that any thought, shapr?
13:59:04 <SyntaxPolice> (rahter than writing it from scratch)
13:59:30 <ski> (i used prefix methods in my little comparision of (an aspect of) FP and OO)
14:00:47 <ski> well
14:01:19 <ski> middy :: [Int] -> (Int,Int) -> ??
14:02:11 <p3rs3ph4n3> yes
14:02:17 <p3rs3ph4n3> [Int]
14:02:20 <ski> yes
14:02:59 <p3rs3ph4n3> middy :: [Int] -> [(Int,Int)] -> [Int]
14:03:11 <p3rs3ph4n3> so this is the type of middy
14:03:33 <ski> mid :: [a] -> [a]
14:03:33 <ski> mid xs = ...
14:03:33 <ski>   where
14:03:33 <ski>   leftMiddle = ((length xs) - 1) `div` 2
14:04:02 <ski> ok
14:04:11 <shapr> SyntaxPolice: I have not given that any thought.
14:04:37 <p3rs3ph4n3> mid :: [a] -> [a]
14:04:37 <p3rs3ph4n3>      mid xs = 
14:04:37 <p3rs3ph4n3> 	where
14:04:37 <p3rs3ph4n3> 	   leftMiddle = ((length xs) - 1) `div` 2
14:04:42 <shapr> SyntaxPolice: I've been reading megatokyo for an hour.
14:04:43 <p3rs3ph4n3> yes
14:04:48 <shapr> I've nearly reached the 200th strip.
14:05:00 <ski> (modulo indenting)
14:05:46 <ski> so mid should return the (middle) sublist
14:05:51 <p3rs3ph4n3> yes
14:05:52 <shapr> SyntaxPolice: plus, I'd rather write Haskell code anyday, it's fun.
14:06:00 <ski> so it should call middy, for that, right ?
14:06:04 <shapr> though functioning libs would be useful, that's true.
14:06:37 <p3rs3ph4n3> yes
14:07:01 <ski> and middy returns a sublist, and that's the one we want to return
14:07:12 <p3rs3ph4n3> yes it is
14:07:14 <ski> mid xs = middy xs (...,...)
14:08:06 <p3rs3ph4n3> middy xs (_,_)
14:08:08 <p3rs3ph4n3> ?
14:08:13 <ski> what should the two ... be ?
14:08:23 <shapr> urm
14:08:24 <ski> what shall we write there ?
14:08:26 <p3rs3ph4n3> we can put _ meaning whatever?
14:08:33 <ski> no
14:08:44 <ski> _ can only be used in patterns
14:08:49 <shapr> @yow
14:08:49 <lambdabot> Now I understand the meaning of ``THE MOD SQUAD''!
14:09:05 <ski> (another story in prolog, though)
14:09:27 <p3rs3ph4n3> ... have to be the middle int's
14:09:37 <ski> yes
14:09:42 <ski> the start and end index
14:09:46 <p3rs3ph4n3> yes
14:10:02 <ski> what was the start index, again ?
14:10:16 <p3rs3ph4n3> leftMiddle
14:10:18 <ski> yes
14:10:25 <ski> so we have ..
14:10:36 <p3rs3ph4n3> middy (leftMiddle, ...)
14:10:50 <ski> yes (you got before me)
14:10:59 <p3rs3ph4n3> :)
14:11:02 <SyntaxPolice> shapr: yeah, I'd rather write haskell code too. I'm going to see if I can implement an xml-rpc client
14:11:04 <ski> (hm, perhaps not correct english)
14:11:29 <ski> so the end index, then
14:11:41 <ski> how long should this sublist be ?
14:11:58 <p3rs3ph4n3> 2 elements
14:12:08 <ski> always ?
14:12:13 <p3rs3ph4n3> no
14:12:21 <p3rs3ph4n3> 2 or 1 elements
14:12:26 <ski> yes
14:13:27 <ski> we decided that the second Int should be the first index we should not take, didn't we ?
14:13:39 <p3rs3ph4n3> yes
14:13:45 <ski> so
14:13:54 <ski> [0,1,2,3,4,5,6,7,8,9]
14:14:11 <ski> say, e.g. that 5 is our first index
14:14:30 <ski> (it points, incidentically, at the number 5 in the list)
14:14:43 <p3rs3ph4n3> yes
14:14:45 <shapr> hi jewel! ltns!
14:14:53 <shapr> how's Zud Afrika?
14:15:01 <jewel> pretty cool
14:15:12 <ski> so in this case we'd want only one element
14:15:13 <jewel> playing with the L4 microkernel the last few days
14:15:18 <shapr> when you gonna write more Haskell code? :-)
14:15:20 <p3rs3ph4n3> (leftMiddle + 1)
14:15:27 <ski> yes
14:15:36 <jewel> when I find a fun project!
14:15:44 <ski> say
14:15:45 <shapr> have you tried writing a lambdabot plugin?
14:15:55 <ski> [0,1,2,3,4,5,6,7,8]  instead
14:16:14 <ski> um
14:16:16 <p3rs3ph4n3> 4
14:16:35 <jewel> what do the plugins do?
14:16:56 <ski> mea culpa, it is the other way around. it is [0..8] which has an odd number of elements, not [0..9]
14:17:18 <ski> so for [0..8] we have (leftMiddle,leftMiddle + 1)
14:17:28 <p3rs3ph4n3> yes
14:17:32 <ski> and for [0..9] we have ... ?
14:18:02 <p3rs3ph4n3> (leftMiddle,leftMiddle)
14:18:08 <ski> no
14:18:16 <p3rs3ph4n3> (leftMiddle,[])
14:18:21 <ski> that will get middy to select an empty list
14:18:41 <ski> no that either, both things in the pair should be indices, i.e. Int's
14:19:13 <ski> if (leftMiddle,leftMiddle + 1) gets you a one-element list, how do you get a two-element list ?
14:19:30 <p3rs3ph4n3> (leftMiddle,leftMiddle -1)
14:19:31 <ski> (you remember what middy's supposed to do, right ?)
14:20:08 <p3rs3ph4n3> yes middy is suposed to return a list
14:20:17 <p3rs3ph4n3> of the middle(s) elements
14:20:17 <ski> for [0,1,2,3,4,5,6,7,8,9], if leftMiddle is 4
14:20:22 <shapr> jewel: whatever you want them to do :-)
14:20:24 <shapr> @listmodule
14:20:24 <lambdabot> Sorry, I don't know the command "listmodule", try "lambdabot: @listcommands"
14:20:25 <shapr> @listmodules
14:20:26 <lambdabot> I have the following modules installed: ["base","cmafihe","dict","dummy","dynamic","eval","hello","karma","more","quote","seen","state","system","topic","type"]
14:20:35 <shapr> @cmafihe cilre
14:20:38 <lambdabot> cilre <BRIVLA> [learn] 
14:20:52 <shapr> doi djul .i do mo
14:20:59 <p3rs3ph4n3> 4?
14:21:01 <phubuh_> hey shapr :-)
14:21:07 <shapr> coi phubuh
14:21:10 <shapr> ma nuzba
14:21:13 <phubuh_> @cmafihe nuzba
14:21:14 <lambdabot> nuzba <BRIVLA> [news] 
14:21:29 <phubuh_> not much :)
14:21:36 <ski> then (leftMiddle,leftMiddle -1) will select a sublist, starting from (and including) the element with index 4 (i.e. the number 4)  and stop just before the element with index 3
14:21:46 <phubuh_> well, the source code for Half-Life 2 leaked out, which is pretty interesting
14:21:54 <shapr> the *source* ??
14:21:57 <phubuh_> yup!
14:22:15 <jewel> pretty cool
14:22:23 <ski> 4 is leftMiddle in that example, yes
14:22:36 <Riastradh> phubuh, does it work?
14:22:37 <p3rs3ph4n3> it isn't 5 ?
14:23:05 <shapr> mi djica le nu cnino samselpla bau la xaskel
14:23:08 <phubuh_> Riastradh, i heard it compiles, but there's no artwork or anything like that, so it obviously doesn't run
14:23:44 <ski> length xs is 10 right ?  that minus one is 9,  and that (integer) divided by two is 4, right ?
14:23:53 <shapr> doi djul .i xu do tavla mi bau la lojban
14:24:00 <ski> @cmafihe xaskel
14:24:01 <lambdabot> xaskel <CMENE> [] 
14:24:02 <p3rs3ph4n3> yes
14:24:11 <shapr> ski: xaskel == haskell :-)
14:24:30 <Riastradh> What does this 'cmafihe' thing do?
14:24:32 <ski> shapr : thought so :)
14:24:40 <shapr> ski: you know lojban?
14:24:48 <ski> shapr : i've heard of it
14:25:03 <phubuh_> Riastradh, it uses the command line tool 'cmafihe' to parse and translate lojban words
14:25:18 <shapr> I want a full jbofihe plugin
14:25:28 <ski> @cmafihe cmafihe
14:25:29 <shapr> or can I dump multiple words at once to cmafihe?
14:25:42 <shapr> @cmafihe cmafi'e
14:25:43 <lambdabot> cmafi'e <BRIVLA> [small-fish] 
14:25:49 <ski> @cmafihe jbofihe
14:25:49 <phubuh_> @cmafihe djica cnino samselpla
14:25:50 <lambdabot> djica <BRIVLA> [desire] cnino <BRIVLA> [new] samselpla <BRIVLA> [computer program [not necessarily executing; source code]] 
14:26:08 <shapr> ah, nifty
14:26:18 <p3rs3ph4n3> mid xs = middy xs (leftMiddle,leftMiddle -1) rigth?
14:26:30 <ski> i don't think so
14:26:55 <p3rs3ph4n3> :(
14:26:59 <ski> you want the second index to be equal or greater than the first, right ?
14:27:15 <p3rs3ph4n3> yes
14:27:24 <p3rs3ph4n3> mid xs = middy xs (leftMiddle,leftMiddle+1) rigth?
14:27:31 <ski> if you subtract it with 1, it will only get smaller :)
14:27:56 <ski> yes, for the case when the list has an odd number of elements
14:28:08 <ski> s/rigth/right/
14:28:29 <p3rs3ph4n3> yes 
14:28:49 <p3rs3ph4n3> middy :: [Int] -> [(Int,Int)] -> [Int]
14:28:50 <p3rs3ph4n3>  mid :: [a] -> [a]
14:28:50 <p3rs3ph4n3>      mid xs = middy xs (leftMiddle,leftMiddle -1)
14:28:50 <p3rs3ph4n3> 	where
14:28:50 <p3rs3ph4n3> 	   leftMiddle = ((length xs) - 1) `div` 2
14:29:09 <ski> not minus 1
14:29:34 <p3rs3ph4n3> middy :: [Int] -> [(Int,Int)] -> [Int]
14:29:34 <p3rs3ph4n3>  mid :: [a] -> [a]
14:29:34 <p3rs3ph4n3>      mid xs = middy xs (leftMiddle,leftMiddle+1)
14:29:34 <p3rs3ph4n3> 	where
14:29:34 <p3rs3ph4n3> 	   leftMiddle = ((length xs) - 1) `div` 2
14:29:34 <ski> perhaps we shall write middy, so you then can try middy and mid out ?
14:29:48 <ski> in hugs e.g.
14:30:04 <shapr> coi kosmikus
14:30:06 <shapr> ma nuzba
14:30:13 <p3rs3ph4n3> yes
14:30:47 <ski> @cmafihe ma
14:30:48 <lambdabot> ma <KOhA7> [sumti ?] 
14:31:11 <kosmikus> hi shapr
14:31:29 <shapr> ski: ma means "this is a question, I want you to fill in the noun blank here" and mo means the same for verbs.
14:32:05 <shapr> so "ma nuzba" is "? are news"
14:32:11 <ski> shapr : ok. it is interesting how one can parse such blanks
14:32:34 <shapr> there's "mo" for the verb, so sometimes I say "ma mo" for entertainment.
14:32:36 <p3rs3ph4n3> a moment someone is knocking at the door
14:32:49 <shapr> p3rs3ph4n3: it's the Haskell Secret Underground!
14:32:51 <ski> shapr : is ma always put at the beginning of the (sub-)phrase  or always at the gap position ?
14:33:01 <shapr> ski: can be in any noun position
14:33:09 <shapr> I could say do cilre ma
14:33:14 <shapr> meaning "you learn ?"
14:33:36 <ski> shapr : so ma is the gap, then
14:33:40 <shapr> yes
14:33:49 <shapr> ma is a gap for a noun, mo is a gap for a verb
14:34:05 <p3rs3ph4n3> lol ski , it was only my mom
14:34:27 <shapr> do you live with your parents? or do they come to visit you?
14:34:39 <shapr> I haven't seen my mother in nearly two years :-(
14:34:44 <p3rs3ph4n3> i live with my mom
14:35:08 <ski> shapr : in relativ-fraser in swedish, "som" is used to initialize a relative phrase,  which is like a sentence, except a sub-noun phrase is completely missing
14:35:21 <shapr> ski: t.ex.?
14:35:36 <ski> p3rs3ph4n3 : perhaps your mum has joined THU ..
14:35:47 <shapr> I thought it was the HSU?
14:36:04 <shapr> oh wait, maybe ski is in a competing secret Haskell organization!
14:36:08 <ski> shapr : gah, typed too fast
14:36:18 <p3rs3ph4n3> lol my mom only likes to spoil pc's
14:36:21 <ski> :)
14:36:38 <p3rs3ph4n3> i don't even let her join near my pc lol
14:36:40 <ski> lo really l
14:36:56 <shapr> har du en exmpel för som i en relativ frase?
14:37:40 <shapr> I have recently realized that I really enjoy learning languages, spoken or programming. I think I should spend more time doing that.
14:37:49 <ski> shapr : Katten jagar hunden, som dr ful.
14:37:57 <shapr> dr ful?
14:38:00 <ski> ae
14:38:12 <shapr> där ful ?
14:38:16 <ski> stupid thing lost the upper bit
14:38:23 <shapr> oh
14:38:32 <ski> aer ful   (aumlaut)
14:38:37 <shapr> jaså
14:38:38 <shapr> tack
14:38:49 <p3rs3ph4n3> your talking chinese
14:38:54 <p3rs3ph4n3> :)
14:38:54 <shapr> there are relative phrases in lojban too, but I've forgotten how they work.
14:38:59 <shapr> p3rs3ph4n3: nah, it's just swedish.
14:39:04 <shapr> chinese is a tonal language :-)
14:39:11 <shapr> at least, if you mean mandarin.
14:39:18 <p3rs3ph4n3> shapr for me is chinese cause i don't understand
14:39:26 <shapr> I only know two words in mandarin
14:39:29 <shapr> the tonal part is difficult.
14:39:52 <p3rs3ph4n3> and in portuguese when we don't understand other language we say that the other person is talking chinese
14:40:02 <ski> shapr : Huset omger maskinen, som Lisa hatar.
14:40:02 <shapr> in american we say they're speaking greek
14:40:14 <shapr> ski: nifty :-)
14:40:38 <p3rs3ph4n3> and portuguese do you understand any words?
14:40:47 <ski> shapr : you see that in the last case the missing/gap is after hatar, and not before Lisa
14:40:49 <Darius> shapr: I think that has partly to do with Greek symbols used in math.
14:41:09 <shapr> some, portuguese is one of the romance languages so it has similarities to spanish, english, etc
14:41:20 <shapr> at least, I think portuguese is one of the romance languages.
14:41:30 <shapr> ski: yah, I see.
14:41:31 <p3rs3ph4n3> yes it is :)
14:41:34 <Darius> English isn't a romance language.
14:41:56 <ski> p3rs3ph4n3 : we say that also.   sometimes was say greek (greech ?)  instead
14:42:01 <shapr> European women sometimes think english is romantic ;-)
14:42:06 <shapr> worked for me at least =)
14:42:28 <p3rs3ph4n3> lol shapr
14:42:38 <p3rs3ph4n3> but how old are you guys?
14:42:48 <shapr> I'm 100,000 in binary.
14:42:54 <shapr> how old are you?
14:42:57 <p3rs3ph4n3> 20
14:43:27 <ski> shapr : there was some interesting examples in lolli (like lambdaprolog, but linear logic), that used linear implication in a dcg to handle the gaps correctly .....
14:43:31 <andersca> I'm 010,110
14:43:33 <Lor> http://bash.org/?25464
14:43:45 <p3rs3ph4n3> wait let me make the binary counts lol
14:43:58 <shapr> Lor: bash.org has too many good quotes
14:44:00 <ski> how old i am. um lemme see ..
14:44:10 <ski> this year is 2003 ..
14:44:25 <ski> i have not had birthday yet ..
14:44:30 * Lor is 011001
14:44:41 <shapr> ski: lojban is based on predicate logic. I'd like to use lojban as the basis for a spoken programming language at some point.
14:45:01 <ski> so i'm 211 in trinary
14:45:11 <p3rs3ph4n3> i had my birthday on 1st february
14:45:20 <p3rs3ph4n3> trinary does that exists? lol
14:45:48 <ski> yes
14:46:10 <ski> http://www.trinary.cc/
14:46:21 <ski> trinary circuits
14:46:29 <p3rs3ph4n3> i only learned binary, octal and hexadecimal
14:46:50 <ski> all are easy
14:46:56 <p3rs3ph4n3> yes :)
14:46:57 <Riastradh> Bah, real men can use any base!
14:47:03 <ski> (except possibly the nagative bases)
14:47:03 <Lor> Balanced ternary is nice.
14:47:24 <ski> Riastradh : All your base are belong to us !
14:47:40 <p3rs3ph4n3> Riastradh i'm not a man so i can't use any base :þ
14:48:16 * Lor is +0-+ in balanced ternary.
14:48:35 <ski> Lor : yes
14:49:10 <ski> i remember a puzzle in an old good game that used balanced ternary ..
14:50:19 <shapr> balanced ternary is new to me
14:50:20 * Riastradh wonders what the negative bases would be like.
14:50:35 <ski> shapr : nice, i've heard something like that, but i don't know to what extent
14:50:40 <shapr> by p3rs3ph4n3
14:50:43 <shapr> er "bye"
14:51:03 <shapr> anyways, I'm off to play a shooty game for awhile...
14:54:24 <ski> Riastradh :
14:54:41 <ski> 1 .. 9 in base -10 is just 1 .. 9 is base 10
14:55:09 <ski> 10 .. 19 in base -10 is -10 .. -1 in base 10
14:55:25 <Smerdyakov> Base -10 is stupid.
14:55:36 <ski> is base -2 better ?
14:55:46 <Smerdyakov> No.
14:55:53 <ski> or base 2i ?
14:55:56 <Smerdyakov> NO.
14:55:56 <Lor> How about base 2i?
14:55:58 <ski> :)
14:55:58 <Riastradh> What would you prefer?
14:57:01 <Lor> Um, 2i won't work.
14:57:22 <ski> sqrt 2 * i then ?
14:58:08 <Lor> I do recall that there is some pretty way of expressing complex numbers.
14:58:21 * Lor grabs TAoCP2.
14:59:05 <ski> or perhaps sqrt (sqrt 2) * i
14:59:42 <Lor> Ah, 2i needs digits 0,1,2 and 3.
14:59:55 <ski> mm
14:59:57 <Lor> Apparently i-1 works, too.
15:00:57 <ski> then you only need digits 0,1 ?  at least for integer reals ..
15:01:15 <Lor> Yep. TAoCP2 p. 206.
15:01:36 * ski doesn't have it :(
15:01:40 <Smerdyakov> I have digits.
15:01:47 <ski> good
15:03:47 <ski> heh : http://www.liafa.jussieu.fr/web9/rapportrech/description_en.php?idrapportrech=651
15:36:50 <prologic> Morning :)
15:37:04 <ski> Good night
15:37:08 <prologic> lol
15:37:15 <prologic> got a few mins ski ?
15:37:21 <ski> i suppose so
15:37:24 <prologic> good o :)
15:37:38 <prologic> if you could quickly read over http://daisy.ods.org/~prologic/2.pdf
15:37:41 <prologic> Exercise 3
15:37:55 <prologic> just want to collaborate some ideas with you people :)
15:39:27 <ski> reading
15:39:31 <prologic> ta
15:39:43 <prologic> way I see it I have two ways of doing this
15:40:17 <prologic> have a symbol table as a pair of String, [(String, String)], and just dive into the text recursively creating many instances of tables as needed in local scopes
15:40:36 <prologic> or create a triple symbol table keeping track of each macro's scope
15:41:20 <prologic> the most difficult part of this is handling nested blocks and local macro definitions :)
15:41:33 <ski> first one seems easier  (not knowing yet exactly what you are talking about)
15:41:51 <ski> (i.e. first way/option)
15:41:54 <prologic> well if you read I have to build a simple macro processor
15:42:00 <ski> mm
15:43:14 <prologic> I'm probably going to do it with my first idea
15:43:28 <prologic> later might be too complex for now
15:43:41 <ski> mm
15:43:48 <prologic> lol
15:45:16 <ski> this exercise seems way larger than exercise 2
15:45:22 <prologic> of course it is
15:45:28 <prologic> prolly why it's worth 10 marks
15:45:29 <prologic> vs. 5
15:45:36 <ski> how long time have you got on it ?
15:45:40 <prologic> umm
15:45:44 <prologic> about 8 hours today
15:45:45 <prologic> :)
15:46:00 <prologic> I got up at 7.30am just to finish the assignment
15:46:21 <ski> good to start solving it now, then ;)
15:46:27 <prologic> yup
15:46:43 <prologic> well if you want to tell me anything I should know, tell me now :)
15:47:07 <prologic> otherwise it should be pretty trivial seeing as I've written simple interpreters before in imperitive languages
15:47:08 <ski> hmm
15:48:08 <ski> a macro can't expand to just }, no ?
15:48:23 <prologic> you mean a macro with nothing in it ?
15:48:38 <ski> no, a macro with } in it
15:48:51 <prologic> I'm not sure
15:49:16 <prologic> hrmm
15:49:25 <prologic> not according to the syntax of defining a macro
15:49:36 <prologic> macroName ::= {upper-case-letter}+
15:49:47 <prologic> macroValue := "{" text "}"
15:50:02 <ski> then we can probably pre-parse the file, taking into account the block structure ...
15:50:17 <prologic> yeh I was thinking of that
15:50:22 <prologic> parsing the file into 2 stages
15:50:28 <prologic> parse1 and parse2 functions
15:50:41 <prologic> except parse2 can parse on the initial parse1 results
15:51:28 <ski> a datatype with one constructor for a plain text string, one for a macro definition, one for a macro usage, and one for a block of sub-things of the same type as the whole datatype
15:51:33 <ski> or something like that
15:51:43 <ski> yes
15:52:07 <ski> s/usage/call/
15:53:07 <prologic> data SymbolTable = Text | Macro | MacroCall | Block
15:53:08 <prologic> ?
15:53:35 <ski> but each constructor should have corresponding arguments
15:53:44 <ski> String for Text, e.g.
15:53:53 <prologic> yup
15:54:12 <prologic> data SymbolTable = Text String | Macro String | MacroCall Macro | Block ???
15:54:16 <prologic> something like that ?
15:54:17 <ski> s/Macro /MacroDef /
15:54:30 <prologic> data SymbolTable = Text String | MacroDef String | MacroCall Macro | Block ???
15:54:55 <ski> MacroDef logically consists of two things, right ?
15:55:04 <prologic> yup
15:55:06 <prologic> you are right :)
15:55:16 <ski> MacroName
15:55:19 <ski> and ...
15:55:22 <prologic> data SymbolTable = Text String | MacroDef String String | MacroCall MacroDef | Block ???
15:55:25 <prologic> and value
15:55:25 <prologic> :)
15:55:33 <prologic> what would the Block constructor store ?
15:55:54 <ski> but the value can contain macro definitions and calls, as well as blocks and text
15:56:11 <prologic> true
15:56:18 <prologic> so it would really have to be SymbolTable
15:56:27 <ski> i think so
15:56:29 <prologic> data SymbolTable = Text String | MacroDef String SymbolTable | MacroCall MacroDef | Block ???
15:56:43 <prologic> I'm liking this data type so far :)
15:56:46 <ski> MacroCall MacroDef ?
15:57:12 <ski> also, why are you calling it SymbolTable ?
15:57:18 <ski> wanna know
15:57:23 <prologic> dunno
15:57:24 <prologic> lol :)
15:57:45 <prologic> what should it be called ?
15:57:47 <ski> i would perhaps call the macro environment a symbol table
15:58:00 <ski> umm
15:58:26 <ski> MacroExpr ?  Expr ?
15:58:40 <ski> MacroText ?
15:58:57 <prologic> well this data type is representing the entire input file isn't it ?
15:59:20 <ski> but the second arg to MacroDef isn't a whole file
15:59:30 <prologic> no
15:59:35 <ski> so MacroFile won't do it
16:00:02 <prologic> ok well let me understand this a bit better now
16:00:08 <prologic> data MacroExpr = ...
16:00:14 <ski> mm
16:00:34 <prologic> hrmm
16:00:38 <prologic> what's Text hold ?
16:00:49 <prologic> by my thinking it'll eventually be empty
16:01:22 <ski> only in the cases when the whole file is empty or the value of a macro is empty, methinks
16:01:31 <prologic> ahh yup
16:01:35 <prologic> so it'll hold all other text
16:01:39 <prologic> that isn't inside a block or macro
16:01:40 <ski> yes
16:01:40 <prologic> right ?
16:01:44 <prologic> ok
16:01:49 <prologic> MacroDef is ok :)
16:01:56 <prologic> hold a macro and it's value or blocks etc...
16:01:59 <ski> possibly with the \ things restored to normal
16:02:06 <prologic> yup
16:02:07 <prologic> of course
16:02:09 <prologic> :)
16:02:15 <prologic> what about MacroCall and Block ?
16:02:16 <ski> (i.e. \\ --> \ etc)
16:02:25 <prologic> and \\\\ --> \\
16:02:31 <ski> mm
16:02:47 <ski> well
16:03:07 <ski> MacroCall should just contain a MacroName i think
16:03:16 <ski> i.e. a String, proabably
16:03:24 <ski> you can define a type synonym
16:03:31 <ski> type MacroName = String
16:03:40 <prologic> but isn't that what MacroDef is holding ?
16:03:57 <ski> then you can write MacroName in MacroDef and MacroCall
16:04:01 <ski> sure
16:04:23 <prologic> so why do we need another constructor MacroCall ?
16:04:28 <ski> \=FILENAME{fred.txt}
16:04:39 <ski> this is a macro def.
16:04:43 <prologic> indeed it is
16:04:51 <prologic> Name: FILENAME, Value: fred.txt
16:04:55 <ski> contains both macro name (the defined one) and it's value
16:04:58 <ski> yes
16:05:10 <ski> we need MacroCall for
16:05:20 <ski> The file is "\FILENAME"
16:05:38 <prologic> ah huh ok
16:05:50 <prologic> what if you have...
16:05:50 <ski> (that would be a Text,a MacroCall and a Text)
16:05:54 <prologic> The file is \"FILENAME"
16:05:55 <prologic> The file is \"FILENAME"
16:06:03 <prologic> then we would have a tree of MacroExpr ?
16:06:11 <ski> ?
16:06:30 <prologic> err "\ sorry :)
16:07:02 <ski> ask again, please
16:07:28 <prologic> when we parse the input file, we'll be building up a tree of the data type MacroExpr right ?
16:07:58 <ski> yes, MacroExpr is a sort of abstract syntax tree
16:08:07 <prologic> yeh
16:09:27 <prologic> ok what about the Block constructor ?
16:09:33 <prologic> don't understand the need for that yet
16:09:35 <ski> well
16:09:49 <ski> obviously we can have things like
16:10:40 <ski> \=FOO{hej\BAR{hoppsan} ja BAR i tralala}
16:10:53 <ski> \=FOO{hej\BAR{hoppsan} ja \BAR i tralala}
16:10:56 <ski> i meant
16:11:46 <prologic> and Block would hold the inside of FOO ?
16:11:58 <ski> yes
16:12:02 <prologic> ok
16:12:08 <prologic> so it'd have to be: Block MacroExpr ?
16:12:30 <ski> umm, now that i think of it, we probably can just let the value be a list of MacroExpr's instead ..
16:13:02 <prologic> because the value could contain other macros and blocks ?
16:13:03 <ski> no, it'd have take a list of MacroExpr's, in that case
16:13:10 <ski> yes
16:13:25 <prologic> type MacroName = String
16:13:25 <prologic> data MacroExpr = Text String | MacroDef MacroName [MacroExpr] | MacroCall MacroName | Block MacroExpr
16:13:27 <prologic> how's that ?
16:13:46 <ski> there isn't just one thing inside BAR's value. not just one MacroExpr constructor
16:14:05 <prologic> oh right :)
16:14:10 <prologic> in [MacroExpr] ?
16:14:47 <prologic> oh
16:14:57 <prologic> data MacroExpr = Text String | MacroDef MacroName [MacroExpr] | MacroCall MacroName | Block [MacroExpr]
16:14:58 <prologic> there :)
16:15:16 <ski> after MacroDef  (and after Block, if we are going to keep it, which i don't think will be necessary anymore)
16:15:46 <prologic> yeh why it Block needed now ?
16:15:55 <prologic> since MacroDef's value can hold a list of MacroExpr
16:16:05 <prologic> which would satisfy nested macros and blocks anyway
16:16:23 <ski> and i don't think we'll need the Block capability anywhere else
16:16:44 <prologic> cause it can be held by MacroDef right
16:16:46 <ski> phase1 could possibly just return a [MacroExpr]
16:16:58 <ski> (for the toplevel of the file)
16:17:02 <prologic> yup
16:17:13 <ski> mm
16:17:18 <prologic> parse2 could then apply the [MacroExpr] to the input file and spit out the output
16:17:45 <ski> input file ?, youv'e got two files to work on ?
16:17:53 <prologic> no
16:17:55 <prologic> just one
16:17:55 <prologic> stdin
16:18:10 <prologic> but it has to spit out the translated output file obviously :)
16:18:12 <ski> isn't it just enough to traverse the MacroExpr ?
16:18:19 <prologic> ahh yes
16:18:23 <prologic> hehe stupid me :)
16:18:37 <prologic> then you only need 1 parse
16:18:50 <ski> or where you initially thinking that SymbolTable would just hold macro def.s and not all the ordinary text + macro calls ?
16:19:48 <prologic> no
16:19:56 <prologic> I was thinking SymbolTable would hold everything
16:20:07 <prologic> text, macro defs, macro calls, etc
16:20:12 <ski> this way you need two phases still, one for a parsing of the original String into an MacroExpr, and the second to do the actual macro-replacements and output the resulting String
16:20:20 <ski> ok
16:20:38 <prologic> so my way, your way. we only need one parse ?
16:20:46 <prologic> which was my originaly intention
16:20:52 <prologic> except I was going to do it with a tuple
16:20:58 <ski> i think so
16:21:05 <prologic> err triple rather
16:21:09 <ski> tuple for what ?
16:21:10 <prologic> data type be better :)
16:21:37 <ski> the second phase still probably need a MacroEnv argument, methinks
16:22:00 <prologic> why ?
16:22:07 <ski> triple is a tuple
16:22:11 <prologic> k :)
16:22:18 <ski> why ?
16:22:20 <ski> well
16:23:19 <ski> because when we recursively (of course)  traverse the MacroExpr in the second phase, we need to keep track of the current Macro definitions in effect at the moment
16:23:33 <shapr> gutenabend MLHueHue 
16:23:45 <MLHueHue> hi
16:23:50 <shapr> learning Haskell?
16:24:05 <prologic> ski: I don't understand that
16:24:06 <shapr> longtime user?
16:24:20 <shapr> long time viewer, first time caller? :-)
16:24:22 <MLHueHue> Have been using Haskell for over 2 years now, but not frequently
16:24:35 <shapr> what do you do with Haskell?
16:24:51 <ski> think of  \FILENAME{fred.txt}The file is "\FILENAME"
16:25:01 <prologic> yeap
16:25:05 <MLHueHue> I did a university project with it (a parser for a small programming language, including interpreter etc.)
16:25:20 <shapr> cool, parsers are fun in Haskell.
16:25:28 <prologic> I have to build a simple one now :)
16:25:30 <MLHueHue> And I am currently trying to write a CAS using haskell
16:25:33 <ski> prologic : how are you going to remember that FILENAME is fred.txt, by the time you get to \FILENAME ?
16:25:37 <shapr> CAS?
16:25:40 <shapr> @jargon cas
16:25:41 <lambdabot> No match for "cas".
16:25:43 <MLHueHue> Computer Algebra System
16:25:45 <shapr> oh
16:26:00 <prologic> ski: won't it be in the [MacroExpr] tree that we've built up in parse 1 ?
16:26:22 <MLHueHue> But much work, I dont think I will ever finish it, just began it during a Computer Algebra lecture last semester
16:26:52 <shapr> as long as you enjoy working on it, that's the important part.
16:26:59 <shapr> I have lots of barely started Haskell projects lying around.
16:27:20 <shapr> I mostly write code to learn how things work.
16:27:28 <shapr> I should learn how to finish things maybe :-)
16:27:36 <ski> prologic : yes, but it can get a bit tedious to, whenever you are faced with a macro call, you have to traverse the original tree down to the definition of the macro (which path ?) just to find what to substitute the call with
16:27:52 <prologic> fair enough
16:28:18 <ski> MLHueHue : The same with me
16:28:20 <prologic> but by keeping an environment wouldn't we be building up another complex tree anyway ? or just a lookup table ?
16:28:44 <ski> prologic : you sortof understand what i was hinting at ?
16:28:53 <prologic> yeah
16:28:56 <ski> no
16:28:59 <ski> not a tree
16:29:02 <ski> just a list
16:29:08 <prologic> it would be inefficient to search the tree for macro values everytime you come across a macro call
16:29:33 <MLHueHue> @shapr: :) 
16:29:33 <lambdabot> Sorry, I don't know the command "shapr:", try "lambdabot: @listcommands"
16:29:33 <ski> the list representing the current path from the root to the position we are at now
16:30:15 <prologic> hrmm :)
16:30:26 <ski> (but reversed)
16:30:27 <shapr> @yow
16:30:27 <lambdabot> Sign my PETITION.
16:30:41 <blackdog> lambdabot: @listcommands
16:30:42 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define","definitions","del-definition","devils","dict","dict-help","dummy","dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements","eval","foldoc","foo","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","lojban","more","msg","part","prelude
16:30:43 <Binkley> @yow
16:30:44 <lambdabot> Why are these athletic shoe salesmen following me??
16:30:49 <prologic> how do you represent such a thing ?
16:31:08 <ski> prologic : e.g.   data Tree a = Nil | Node a (Tree a) (Tree a)
16:31:39 <ski> a path can then be [a]
16:32:03 <prologic> where a is of type Tree ?
16:32:36 <ski> you start walking down the tree, branch for branch, and for each Node (in this case) you put the element there at the front of a list
16:32:44 <ski> no
16:32:57 <ski> a is whatever we store in the nodes
16:33:47 <prologic> mm
16:33:49 <ski> in the MacroExpr syntax tree, it would probably correspond to (MacroName,[MacroExpr]), taken from MacroDef's arguments
16:34:21 <prologic> wanna look at http://daisy.ods.org/~prologic/macro.hs :)
16:34:37 <ski> 'kay
16:35:38 <ski> MacroValue = MacroExpr ?
16:36:29 <shapr> g'day blackdog 
16:36:33 <shapr> hi Binkley 
16:36:44 <prologic> ski: just a type synonmn :)
16:37:09 <ski> shouldn't it be [MacroExpr]
16:37:22 <prologic> yes it should
16:37:23 <prologic> ta :)
16:37:37 <prologic> done
16:37:56 <prologic> is addMacro the only function I'm going to need to build up the syntax tree ?
16:38:03 <ski> if you like, you can write MacroValue as 2nd arg of MacroDef in the data def.
16:38:18 <prologic> yep I will now
16:38:40 <ski> The SymbolTable should not be [MacroExpr], methinks
16:39:29 <prologic> well essentially addMacro is correct though? addMacro :: [MacroExpr] -> MacroName -> MacroValue -> [MacroExpr]
16:39:54 <ski> ddMacro :: SymbolTable -> MacroName -> MacroValue -> SymbolTable
16:40:05 <ski> addMacro
16:40:19 <prologic> yeh I just wanted a better name for [MacroExpr] :)
16:40:43 <ski> but it shouldn't be [MacroExpr] at all, IMO
16:40:57 <prologic> SyntaxTree ? :)
16:41:00 <prologic> that better
16:41:03 <ski> no
16:41:06 <prologic> hehe
16:41:11 <ski> SymbolTable is just fine
16:41:21 <prologic> oh
16:41:27 <prologic> just it shouldn't be [MacroExpr]
16:41:28 <ski> but change what a SymbolTable *is*
16:41:35 <ski> correct
16:41:51 <prologic> well hold on it's a damn tree
16:41:54 <prologic> so it'd just be MacroExpr :)
16:42:12 <ski> you don't have to decide/define it yet
16:42:27 <shapr> @fortune
16:42:28 <lambdabot> Neurotics build castles in the sky,
16:42:28 <lambdabot> Psychotics live in them,
16:42:28 <lambdabot> And psychiatrists collect the rent.
16:42:37 <prologic> type SymbolTable = MacroExpr
16:42:39 <ski> you can probably start coding on phase 2 directly
16:42:55 <ski> lambdabot : heh
16:44:01 <ski> prologic : i didn't mean that you would actually need  Tree a  for this problem. it was just an example of paths in a tree..
16:44:16 <prologic> k
16:44:28 <prologic> but you did say I'd need to have an environment of some sort
16:44:29 <ski> is parse2 taking a SymbolTable ?
16:44:34 <prologic> it is
16:44:55 <ski> shouldn't it be taking a MacroExpr, somewhere ?
16:45:08 <prologic> that's what SymbolTable is
16:45:19 <ski> aargh.. :)
16:45:29 <ski> i don't think so
16:45:39 <ski> lol
16:45:47 <prologic> ok well bare in mind I don't know IO yet or monads
16:45:53 <prologic> so I'm having to stick with interact
16:46:00 <prologic> @type interact
16:46:00 <lambdabot> interact :: (String -> String) -> IO ()
16:46:01 <ski> irrelevant for this
16:46:04 <prologic> ok
16:46:12 <prologic> thought it might bare some weight to how I'd do it
16:46:37 <ski> (well, one could possibly use an environment monad if one wanted)
16:46:53 <prologic> me knows nothing of monads :)
16:47:17 <ski> not so hard, IMO
16:47:33 <ski> anyway
16:47:40 <prologic> I should keep this simple or I'll never get it done :)
16:47:40 <ski> um
16:48:08 <ski> shouldn't parse2 be called phase2 or macroExpand or something ?
16:48:16 <ski> it is not parsing
16:48:22 <prologic> good point
16:48:27 <prologic> macroExpand sounds fine
16:48:32 <prologic> spitOutput even :)
16:48:54 <ski> or perhaps one could call parse macroExpand ?  
16:49:04 <prologic> macroExpand it is :)
16:49:04 <prologic> lol
16:49:06 <ski> any suggestion ?
16:49:15 <prologic> you wanna write it the assignment ? :)
16:49:21 <ski> which is macroExpand ?  parse or parse2 ?
16:49:27 <prologic> parse2
16:49:27 <ski> what ?
16:49:41 <prologic> I have only done something like this in pascal argg :)
16:49:45 <ski> me ?  i don't live in australia
16:50:20 <prologic> yeh you're looking at macro.hs live :)
16:50:26 <ski> yes ;)
16:50:38 <prologic> I :w every few mins
16:51:22 <ski> you could perhaps call parse, macroProcess
16:51:34 <prologic> or processInput ?
16:51:37 <ski> and then rename parse' to just parse
16:51:38 <prologic> since that's what it's doing
16:52:24 <ski> processInput seems to assymetrical IMO. it is both parsing an input string and generating an output string
16:52:59 <ski> (parse i.e.  not parse')
16:54:15 <prologic> how's that now ?
16:54:27 <ski> you can compose the macroExpand and the parse functions in macroProcess
16:54:39 <ski> fine
16:54:43 <ski> like
16:54:54 <ski> macroProcess = macroExpand . parse
16:55:11 <ski> or
16:55:12 <ski> macroProcess = macroExpand
16:55:12 <ski>              . parse
16:55:29 <ski> you know . i presume ?
16:55:50 <prologic> the . ?
16:55:53 <ski> yes
16:55:56 <prologic> composite
16:55:59 <ski> yes
16:56:07 <prologic> yeah I know it :)
16:56:13 <ski> output of parse is passed directly to input of macroExpand
16:56:24 <ski> that is what we want, right ?
16:56:29 <prologic> hold on :)
16:56:33 <ski> mm
16:57:18 <ski> no
16:57:25 <ski> no argument
16:57:35 <prologic> yeh none needed ;)
16:57:36 <ski> its implicit
16:58:02 <prologic> it'll eat the string anyway :)
16:58:25 <ski> (i.e. it is worng to have it there, except if you type "(macroExpand . parse) i" or, equivalently "macroExpand . parse $ i")
16:58:33 <ski> yes
16:59:13 <ski> (or "macroExpand $ parse $ i" or "macroExpand $ parse i" for that matter)
16:59:19 <prologic> k
16:59:33 <ski> ok
17:00:13 <ski> so we start writing macroExpand by pattern-matching then. or do you want more design thoughts first ? :)
17:00:31 <prologic> I'd kinda like to build the addMacro function first
17:00:36 <ski> ok
17:00:57 <prologic> hrmm
17:01:02 <ski> but, in that case, we have to decide what a SymbolTable is, right now
17:01:03 <prologic> I know how to build up a list
17:01:11 <prologic> but how do you build up a custom data type
17:01:11 <prologic> ?
17:01:45 <prologic> well I've thought of a SymbolTable as just a pretty name for MacroExpr
17:01:55 * ski whispers : SymbolTable needn't necessarily be a custom datatype
17:01:57 <prologic> which is a tree of our input file properly parsed ;)
17:02:55 <ski> i was thinking, that if we start writing macroExpand, perhaps we can see clearer what a SymbolTable should be. because we'll see how we call addMacro.
17:03:03 <prologic> ok
17:03:08 <prologic> fair enough :)
17:03:53 <ski> but you do it in anyway *you* want, of course :)  whatever seems best to start with from your POV
17:04:13 <prologic> no no let's do macroExpand
17:04:23 <prologic> since I seem to not understand what a SymbolTable is anyway :)
17:04:24 <ski> sure                                          ;9
17:04:44 * prologic note to self, read a compile textbook over the holidays
17:04:57 <ski> anyway
17:05:25 <prologic> see but because I don't know what a SymbolTable should be, I don't know what to pattern-match in macroExpand :)
17:05:28 <ski> parse should be returning an MacroExpr, right ?
17:05:29 <prologic> delimha :P
17:05:38 <shapr> dilemma?
17:05:39 <prologic> yes it should
17:05:44 <prologic> dilemma
17:05:50 <prologic> however the damn word is spelt :p
17:05:53 <prologic> and spelt is a word :)
17:05:54 <shapr> though dilemha sounds much cooler, I admit.
17:05:58 <shapr> @wn spelt
17:05:59 <lambdabot> *** "spelt" wn "WordNet (r) 2.0"
17:05:59 <lambdabot> spell
17:05:59 <lambdabot>      n 1: a psychological state induced by (or as if induced by) a
17:05:59 <lambdabot>           magical incantation [syn: {enchantment}, {trance}]
17:06:00 <lambdabot>      2: a time for working (after which you will be relieved by
17:06:02 <lambdabot>         someone else); "it's my go"; "a spell of work" [syn: {go},
17:06:03 <prologic> my gf looked it up in a dictionary
17:06:04 <lambdabot>          {tour}, {turn}]
17:06:06 <lambdabot>      3: a period of indeterminate length (usually short) marked by
17:06:06 <ski> and macroExpand need a MacroExpr argument to pattern-match on.
17:06:08 <lambdabot> [26 @more lines]
17:06:11 <ski> dilemma resolved :)
17:06:26 <shapr> prologic: I just ask lambdabot, he's smart.
17:06:31 <prologic> lol
17:06:32 <ski> :)
17:07:00 <prologic> like so ski ?
17:08:17 <ski> um
17:08:31 <ski> yes, fine
17:08:41 <ski> @more
17:08:42 <lambdabot>         some action or condition; "he was here for a little
17:08:42 <lambdabot>         while"; "I need to rest for a piece"; "a spell of good
17:08:42 <lambdabot>         weather"; "a patch of bad weather" [syn: {while}, {piece},
17:08:42 <lambdabot>          {patch}]
17:08:42 <lambdabot>      4: a verbal formula believed to have magical force; "he
17:08:42 <lambdabot>         whispered a spell as he moved his hands"; "inscribed
17:08:44 <lambdabot>         around its base is a charm in Balinese" [syn: {magic spell},
17:08:46 <lambdabot>          {charm}]
17:08:48 <lambdabot>      v 1: recite the letters of or give the spelling of; "How do you
17:08:50 <lambdabot> [17 @more lines]
17:09:04 <shapr> I guess spelt is the alternate past tense of spell?
17:09:11 <prologic> indeed it is :)
17:09:13 <ski> @more
17:09:13 <lambdabot>           spell this word?"
17:09:13 <lambdabot>      2: indicate or signify; "I'm afraid this spells trouble!" [syn:
17:09:13 <lambdabot>          {import}]
17:09:13 <lambdabot>      3: write or name the letters that comprise the conventionally
17:09:13 <lambdabot>         accepted form of (a word or part of a word); "He spelled
17:09:13 <shapr> I spelt him yesterday?
17:09:14 <lambdabot>         the word wrong in this letter" [syn: {write}]
17:09:15 <Binkley> it's also a grain
17:09:16 <lambdabot>      4: place under a spell [ant: {unspell}]
17:09:18 <lambdabot>      [also: {spelt}]
17:09:20 <prologic> ski, how do you pattern-match against MacroExpr ?
17:09:22 <lambdabot> [8 @more lines]
17:10:00 <ski> shapr : i think webster has spelt
17:10:06 <ski> @more
17:10:06 <lambdabot> *** "spelt" wn "WordNet (r) 2.0"
17:10:06 <lambdabot> spelt
17:10:06 <lambdabot>      n : hardy wheat grown mostly in Europe for livestock feed [syn:
17:10:06 <lambdabot>          {Triticum spelta}, {Triticum aestivum spelta}]
17:10:06 <lambdabot> *** "spelt" wn "WordNet (r) 2.0"
17:10:08 <lambdabot> spelt
17:10:10 <lambdabot>      See {spell}
17:10:10 <ski> sorry :)
17:10:30 <ski> yes
17:10:51 <ski> we just begin by writing a line for each constructor of MacroExpr
17:11:09 <prologic> eg: macroExpand Text = ... ?
17:11:16 <ski> macroExpand (Text s) = ...
17:11:18 <ski> ...
17:11:19 <prologic> macroExpand MacroDef = ...
17:11:20 <prologic> k
17:11:25 <prologic> me understands now
17:11:31 <ski> just as for lists
17:11:37 <prologic> yup
17:11:47 <ski> except lists have special syntax
17:11:56 <prologic> hehe why sould pattern matching be any different for a custom datatype :P
17:11:59 <prologic> yep
17:12:01 <ski> or for Bool, for that matter
17:12:03 <prologic> x:xs etc.
17:12:23 <prologic> macroExpand (Text s) = s
17:12:25 <ski> [] is most important exception
17:12:29 <prologic> that'd be the first pattern
17:12:41 <ski> one can define own infix constructors, like :
17:12:54 <ski> yes, quite possibly
17:14:16 <prologic> macroExpand (MacroDef name value)
17:14:19 <prologic> that'd have to be the next one
17:14:29 <prologic> but I'd have to expand the list
17:14:32 <ski> mm
17:14:42 <ski> umm
17:14:44 <ski> wait
17:15:17 <ski> didn't we say previously that parse should return [MacroExpr]
17:15:32 <prologic> oh yes sorry
17:15:34 <prologic> you did
17:15:36 <ski> so macroExpand will have to pattern-match on that
17:15:42 <ski> easy to fix
17:15:49 <prologic> which it should anyway
17:15:58 <prologic> a single line could have macros, blocks and text
17:16:04 <prologic> and could get quite complex :)
17:16:07 <ski> yes
17:16:18 <ski> change macroExpand's type also
17:16:25 <ski> good
17:16:30 <ski> :)
17:16:37 <ski> what ?
17:16:38 <prologic> this changes everything
17:16:42 <ski> no
17:16:47 <prologic> I'm pattern macthing against a list now
17:16:49 <ski> not at all
17:17:00 <ski> a list of MacroExpr's
17:17:05 <prologic> yeh
17:17:24 <ski> we can still also pattern-match against the head of the list, as before
17:17:31 <prologic> yup
17:17:46 <ski> (well, i suppose one could make an auxilary function for that)
17:18:04 <ski> the parens around Text s is now unnecessary
17:18:15 <prologic> just Texts:ms ?
17:18:18 <prologic> err
17:18:20 <prologic> just Text s:ms ?
17:18:23 <ski> inside ()
17:18:27 <ski> not inside []
17:18:30 <prologic> yehg
17:18:33 <ski> sure
17:18:33 <prologic> done that :)
17:19:07 <ski> the () in  e.g.  length (x:xs) = yadda  is just so it doesn't get interpreted as  (length x):xs = yadda
17:19:21 <prologic> ok
17:19:26 <ski> similary with previous version of macroExpand
17:19:27 <prologic> macroExpand [Text s:ms] = ..
17:19:30 <prologic> should return s
17:19:34 <ski> no
17:19:35 <prologic> but what do I do with the tail, ms ?
17:19:37 <ski> parens
17:19:42 <ski> ()
17:19:45 <ski> not []
17:19:49 <prologic> sorry yeh () :)
17:20:14 <ski> you are currently matching against a list of one element, namely a list of MacroExpr's
17:20:21 <ski> fine
17:20:27 <ski> :)
17:21:34 <ski> hmm, but i dont think you should also match the tail with []
17:21:52 <ski> just make a line above, that only matches on []
17:21:56 <prologic> there is no tail
17:22:04 <ski> macroExpand (Text s:[]) = s
17:22:07 <ski> [] is tail
17:22:20 <prologic> yeh but if there's only one element
17:22:24 <prologic> it's the head and tail :)
17:22:45 <ski> (almost certainly) unnecessary base-case :)
17:23:20 <prologic> what is ?
17:24:07 <ski> for very many functions on lists, you only need two cases of lists : empty and non-empty   singleton list are most often unnecessary
17:24:20 <ski> your second def. line of macroExpand is
17:24:50 <ski> (btw it is equivalent to "macroExpand [Text s] = s", you know)
17:25:36 <prologic> doesn't it have to be in ( ) ?
17:25:57 <ski> [a,b,c] is syntactic sugar for a:b:c:[]
17:26:15 <ski> if it is inside [] you don't need no ()
17:26:31 <prologic> ok
17:27:12 <ski> but i still think you don't need that case ...  :)
17:27:22 <ski> anyway
17:27:44 <ski> add the other constructors to def. lines, as well
17:30:22 * prologic thinks
17:31:46 <prologic> macroExpand (Text s:ms), what should that return to give me an idea to start off with ?
17:32:19 <ski> umm
17:32:39 <ski> the s contains no macro defs or calls
17:32:56 <ski> and we assume parse have already fixed the \ things
17:33:06 <prologic> so it should return s
17:33:07 <ski> so we'll just output the string
17:33:17 <prologic> what about the rest of the macros, ms ?
17:33:31 <ski> followed by the expansion of the rest of the MacroExpr's, i.e.
17:33:36 <ski> right
17:33:55 <prologic> s (++) macroExpand ms ?
17:34:04 <ski> forget the ()
17:34:12 <prologic> hah :)
17:34:19 <prologic> knew I was half on the right track with ++ :)
17:34:30 <ski> if you want (++), it should say  (++) s (macroExpand ms)
17:34:39 <prologic> yup
17:34:46 <prologic> couldn't remember which way it way
17:34:57 <prologic> seeing as Haskell has both infix and prefix
17:35:24 <ski> easy :  + is written infix, all operators are infix by default  (i.e. until you put them in ())
17:35:32 <prologic> yup
17:35:40 <ski> (except unary -)
17:35:44 <prologic> true
17:35:46 <prologic> it's prefix
17:36:25 <ski> for MacroDef
17:36:39 <ski> we should call macroExpand ms, sure ?
17:36:59 <prologic> hmm why ?
17:37:00 <ski> but where to put/use d ?
17:37:16 <prologic> ms is just macros :)
17:37:18 <prologic> list of macros
17:37:28 <ski> (umm, s/MacroDef d/MacroDef n v/)
17:37:37 <prologic> ahh yes
17:37:40 <prologic> it has two parameters
17:37:45 <ski> mm
17:38:17 <prologic> MacroDef contains a name and a value
17:38:18 <ski> why ?  umm, no, mea culpa
17:38:21 <prologic> hrmm
17:38:43 <ski> umm, no worng again
17:38:59 <ski> v is the value of the name n, right ?
17:39:09 <prologic> yeh
17:39:11 <prologic> that's right
17:39:20 <prologic> v contains a [MacroExpr]
17:39:47 <ski> but ms is all the rest things after the macro def  (except possibly if we are nested inside an outer macro def (or block, if we had one))
17:40:14 <prologic> macroExpand (MacroDef n v:ms) = macroExpand v ++ macroExpand ms
17:40:22 <ski> but, ummm again, mayhaps we'll need Block anyways
17:40:23 <prologic> would that be sufficient to handle that pattern ?
17:40:45 <ski> um, no, worng, methinks
17:40:53 <prologic> why's that ?
17:41:09 <ski> we don't want to macroexpand the macroname's value at it's definition site, right ?
17:41:17 <ski> only at the call sites
17:41:39 <prologic> ahh yep
17:41:50 <prologic> this is where the environment would be built then ?
17:42:00 <ski> and you didn't use n anywhere
17:42:03 <ski> yep
17:42:16 <ski> a part of it
17:43:08 <ski> but the macroExpand ms was correct, just not sufficient
17:43:12 <prologic> could the environment just be a [(a,b)] ?
17:43:20 <ski> yes
17:43:39 <ski> but we only need monomorphic one, in this case
17:43:46 <ski> so you can say
17:44:07 <ski> type SymbolTable = [(...,...)]
17:44:12 <ski> for some ...'s
17:44:27 <ski> (other than type variables, i.e.)
17:44:51 <prologic> type SymbolTable = [(MacroName, MacroValue)]
17:44:55 <prologic> like so ? :)
17:45:16 <ski> we add definitions to the environment sequentially, so a plain list would suffice, i'd say
17:45:21 <ski> yes :)
17:45:26 <ski> nice
17:45:27 <prologic> excellent :)
17:45:38 <prologic> now I understand what our SymbolTable is at last
17:45:42 <ski> heh
17:45:44 <prologic> it's our environment right ?
17:45:49 <ski> yes
17:45:53 <prologic> lol
17:45:55 * prologic smacks his head in
17:46:08 <prologic> you must know a fair bit about parsing and compilers :)
17:46:35 <ski> didn't you get that from the beginning ?  (that SymbolTable == Environment, just different names. i thought you did)
17:46:42 <prologic> nope :(
17:46:53 <prologic> macroExpand (MacroDef n v:ms) =
17:46:57 <ski> prologic : well, not soo much, actually.
17:47:02 <prologic> ok so this is going to have to add n and v to SymbolTable
17:47:13 <ski> but environments are good for many things
17:47:41 <prologic> an auxilary function would be good yeh ?
17:48:17 <ski> yes
17:48:38 <ski> or we could make macroExpand be that auxilary function, if you want
17:48:56 <prologic> well for this pattern it has to call addMacro
17:48:59 <prologic> and parse the rest of ms
17:49:06 <prologic> brb I have to get eye drops in my eyes
17:49:29 <ski> (otherwise we make a (local probably) auxilary function to macroExpand, and move the pattern-matching code to it instead. do you see why ?)
17:49:41 <ski> yes
17:49:53 <ski> sure
17:50:06 <ski> s/parse/expand/
17:53:11 <prologic> hmm me is a little lost with this pattern
17:53:15 <prologic> it has to do two things I know :)
17:53:25 <ski> do ?
17:53:27 <prologic> addMacro s n v
17:53:34 <prologic> whereever s comes from
17:53:35 <prologic> dunno yet :)
17:53:52 <ski> do is a keyword for syntactic sugar for monads
17:54:01 <prologic> I know :)
17:55:11 <ski> what we need, in each step (i.e recursive call to macroExpand), is : what is the current environment/symbol table
17:55:43 <prologic> what you were saying before is to make macroExpand the auxilary function
17:55:46 <ski> (or each rec. call to its auxilary func. if you write it that way)
17:55:54 <prologic> and have a HOF macroExpand that calls on it
17:56:07 <ski> auxilary to macroProcess, i.e.
17:56:17 <ski> (not HOF)
17:56:35 <ski> yes, that was the other option i see
17:57:01 <prologic> now aren't we going to have to build up a SymbolTable somewhere ?
17:57:13 <ski> in any way, you need a function which knows the current environmnet
17:57:26 <ski> of course
17:57:35 <ski> incrementally
17:57:43 <prologic> yep
17:58:12 <ski> (we don't need to allocate a large chunk of memory and initialize it, in the beginning :)
18:00:37 <ski> if you write an auxilary to macroExpand, then macroExpand is going just call the auxilary, initializing the environment to the empty environment (i.e. empty list)
18:01:23 <ski> should you report an error if a macro is used, but not defined ?  or should you not ?
18:01:24 <prologic> hmm hold on, lost me a bit :)
18:01:30 <prologic> yes
18:01:41 <ski> you should report an error ?
18:01:46 <prologic> if you look at the end of the exercise, there are a number of errors it should report
18:01:58 <prologic> No macro name after \=.
18:02:03 <prologic> No block in new macro definition.
18:02:07 <prologic> No macro name after \.
18:02:11 <prologic> Undefined macro.
18:02:15 <prologic> To many }s.
18:02:17 <prologic> No closing }.
18:02:25 <ski> ok
18:02:30 <prologic> the profressor has obviously written the program himself before hand
18:02:43 <prologic> the program just have to exit upon the first error it encounters
18:02:44 <ski> :)
18:02:50 <ski> easy
18:03:13 <ski> don't return "", then.  call error
18:03:23 <ski> @type error
18:03:24 <lambdabot> error :: String -> a
18:03:52 <prologic> for macroExpand [] = "" ?
18:04:01 <ski> noo  :)
18:04:10 <ski> for lookup returned Nothing
18:04:14 <prologic> ahh yup
18:04:16 <prologic> hehe
18:04:21 <prologic> geez what's wrong with me :)
18:04:37 <ski> use ==, not = to compare with Nothing
18:04:48 <prologic> yeesh :)
18:04:58 <ski> btw, i think it is better to use a case in cases like this  (pun intended)
18:04:59 <prologic> there
18:05:42 <ski> i you'd like, you could print out the undefined macro name also
18:06:08 <prologic> done
18:07:04 <ski> well, i guess it perhaps doen't matter very much in this case. because it is not polymorphic. but they say case is generally more efficient than let
18:07:19 <ski> use () or $ after error
18:07:34 <ski> otherwise it is : (error "Undefined macro ") ++ n
18:07:46 <ski> which is not what you wanted
18:08:06 <prologic> fixed :)
18:08:29 <ski> and you can't use "otherwise" like that
18:08:36 <prologic> didn't think so
18:08:37 <ski> @prelude otherwise
18:08:38 <lambdabot> *** "otherwise" prelude "Haskell Standard Prelude Dictionary": text follows
18:08:38 <lambdabot> otherwise
18:08:38 <lambdabot>   otherwise ::  Bool
18:08:38 <lambdabot>   otherwise    = True
18:08:48 <prologic> there a better way to do the case expression ?
18:09:12 <ski> match with  Just v
18:09:23 <ski> then use (i.e. return) v
18:09:54 <ski> that works
18:10:13 <prologic> ERROR "macro.hs":36 - Type error in case pattern
18:10:14 <prologic> hrmm
18:10:16 <ski> umm
18:10:36 <ski> you can subst. lookup n for a, because it is only used once
18:10:45 <ski> then you get rid of the let
18:11:09 <ski> oh, yes
18:11:21 <ski> we have to call macroExpand on ms also
18:11:32 <ski> and put the a in front of that
18:11:41 <ski> no "in"
18:11:57 <ski> good
18:12:30 <prologic> still getting that error
18:12:32 <ski> quite nice indenting. i use that style quite often
18:12:41 <prologic> ERROR "macro.hs":36 - Type error in case pattern
18:12:41 <prologic> *** Term           : Nothing
18:12:41 <prologic> *** Type           : Maybe b
18:12:41 <prologic> *** Does not match : [([Char],a)] -> Maybe a
18:12:42 <ski> a
18:12:48 <prologic> learnt it from our professor :)
18:12:54 <prologic> layout rules
18:12:56 <prologic> I like it too
18:12:57 <ski> yes
18:13:59 <ski> (was prev. referring to having a trailing case ... of on on line and the the braches of it just indented a few spaces inside the function)
18:14:04 <ski> well
18:14:10 <prologic> why am I getting that error above ?
18:14:16 <ski> ah
18:14:21 <ski> @type lookup
18:14:21 <lambdabot> lookup :: Eq a => a -> [(a,b)] -> Maybe b
18:14:31 <prologic> hmm
18:14:34 <prologic> it should be right
18:14:41 <ski> lookup wants two arguments, before it gives you a Maybe b
18:14:54 <prologic> oh shit :)
18:14:55 <prologic> lol
18:14:57 <prologic> SymbolTable!
18:15:24 <ski> no problem
18:15:37 <ski> just rename macroExpand to macroExpand'
18:15:55 <ski> and put the real macroExpand above that
18:16:10 <ski> then we'll start tweaking macroExpand'
18:16:46 <prologic> like that ?
18:16:56 <prologic> and macroExpand calls macroExpand' with an empty symboltable ?
18:17:02 <ski> because, it will turn out, that it is the auxilary that should do the actual pattern-matching on the MacroExpr
18:17:24 <ski> yes, yess
18:18:02 <ski> macroExpand should not get a SymbolTable as arg
18:18:34 <ski> and i think (in this case) it is nicer to have the SymbolTable as first arg to macroExpand'
18:18:38 <ski> 'cuz
18:18:43 <ski> then you can write
18:19:13 <ski> macroExpand = macroExpand' theEmptyTableOrWhateverYou'llWriteHere
18:19:46 <ski> yes, [] works fine
18:19:56 <ski> nice, innit ?
18:20:02 <prologic> yeh :)
18:20:08 <prologic> ERROR "macro.hs":36 - Equations give different arities for "macroExpand'"
18:20:10 <prologic> yikes :)
18:20:19 <prologic> 36: macroExpand' _ [] = ""
18:20:24 <ski> you forgot to add SymbolTable args to the other rows
18:20:31 <prologic> oh yeah
18:20:32 <prologic> lol
18:20:39 <ski> call it, perhaps, st, or something
18:20:46 <ski> or env, if you like
18:21:11 <ski> yes
18:21:24 <ski> now, the recursive calls
18:21:35 <prologic> ERROR "macro.hs":39 - Type error in application
18:21:36 <prologic> *** Expression     : lookup st n
18:21:36 <prologic> *** Term           : n
18:21:36 <prologic> *** Type           : [Char]
18:21:36 <prologic> *** Does not match : [(a,b)]
18:21:38 <prologic> hold on :)
18:21:46 <ski> no, not lookup ! :)
18:22:02 <ski> oh, sorry
18:22:24 <ski> of course lookup should get st, but as second arg
18:22:28 <ski> @type lookup
18:22:28 <lambdabot> lookup :: Eq a => a -> [(a,b)] -> Maybe b
18:22:33 <prologic> argg
18:22:39 <ski> (for some weird reason)
18:22:41 <prologic> it should be the other way around :)
18:22:41 <prologic> lol
18:22:46 <ski> yep
18:23:43 <ski> does it currently type-check ?
18:23:48 <prologic> not atm
18:24:22 <prologic> problem on line 41
18:24:26 <prologic>    Just a  -> a ++ macroExpand' (st ms)
18:24:36 <prologic> *** Expression     : st ms
18:24:37 <prologic> *** Term           : st
18:24:37 <prologic> *** Type           : [([Char],[MacroExpr])]
18:24:37 <prologic> *** Does not match : a -> b
18:24:47 <ski> oh
18:24:53 <ski> no ()
18:25:22 <prologic> oh shiza :)
18:25:25 <ski> you don't want to apply st to ms. st's no function
18:25:31 <ski> mm :)
18:25:47 <ski> what ?
18:25:51 <ski> umm
18:25:51 <prologic> there :)
18:25:54 <prologic> done and fixed
18:25:56 <prologic> it type checks :)
18:26:12 <prologic> when it looks up it returns [MacroExpr]
18:26:16 <prologic> which also needs to be expanded
18:26:31 <ski> ok, so you have implemented dynamic scope (i.e. not static)
18:26:41 <prologic> yeah :)
18:26:42 <prologic> sweet
18:26:52 <prologic> macroExpand' st (MacroDef n v:ms)
18:26:58 <prologic> now that one is going to be tricky :(
18:26:59 <ski> is that what is wanted/required ?
18:27:09 <prologic> what dynamic scope ?
18:27:11 <ski> (i.e. dynamic scope)
18:27:12 <ski> yes
18:27:14 <prologic> yeh of course
18:27:19 <prologic> since you can have local macro defintions
18:27:38 <prologic> ie: \=FILENAME could be the same macro as in an inner block
18:27:43 <prologic> but with different values
18:27:43 <ski> you could do static scope with local macro definitions, you know
18:27:54 <prologic> eh don't confuse me :)
18:28:01 <prologic> wait till I've read a compiler book from front to back
18:29:11 <prologic> ok the last pattern (I hope), has to add the macro
18:29:25 <prologic> add it to the symbol table right :)
18:29:26 <ski> when i was learning haskell from the beginning, i firstly compared it with macro substitution. i.e. until i discovered that it had static instead of dynamic scope ('course i didn't know those words then)
18:29:40 <prologic> I don't even know them now :)
18:29:53 <prologic> vaugly understand the differnce
18:30:57 <prologic> have I done that last pattern right ?
18:31:07 <ski> \FOO{first}\BAR{\FOO}\FOO{second}\BAR
18:31:19 <ski> does that become first or second ?
18:31:28 <ski> first with static scope
18:31:34 <ski> second with dynamic
18:31:49 <ski> compare with
18:31:57 <ski> let foo = "first" in
18:32:03 <ski> let bar = foo in
18:32:11 <ski> let foo = "second" in
18:32:12 <ski> bar
18:32:40 <prologic> it becomes "second"
18:32:54 <ski> yes, i think so
18:32:58 <prologic> you're redefining \FOO
18:33:02 <ski> in dynamic scope
18:33:26 <prologic> oh I understand
18:33:31 <prologic> doesn't fortran use static scope ?
18:33:34 <prologic> or something like that
18:33:56 <ski> in static scope i'm just making another FOO, othershadowing the old, but the FOO in BAR still refers to the FOO that it saw when BAR was defined
18:34:13 <ski> i.e. the old FOO
18:34:22 <prologic> yup
18:34:29 <prologic> got it :)
18:34:44 <prologic> with dynamic scope you're redefining \FOO
18:34:48 <prologic> which destroys the old value
18:34:54 <ski> some people think that macro systex should be static scope  (at least the default)
18:34:58 <ski> yes
18:35:10 <prologic> which is it for this exercise ?
18:35:14 <prologic> it doesn't really say
18:35:26 <ski> dynamic scope is more tricky, especially with higher-order functions
18:35:54 <ski> Emacs-lisp still uses dynamic scope (the old lisp did that from the beginnig, prob. by accident)
18:36:01 <ski> no
18:36:36 <ski> not that static scope would be much harder here, though
18:36:54 <prologic> k
18:37:03 <prologic> I take it we're implementing dynamic scope atm ?
18:37:10 <ski> (note : haskell (extensions) actually has dynamic scope, but controlled better by types !)
18:37:29 <ski> the current implementation ?   yes
18:37:35 <prologic> I shoudl come here more often just to learn :)
18:37:47 <prologic> macroExpand' st (MacroDef n v:ms) = macroExpand (addMacro st n v) ms
18:37:48 <ski> heh :)
18:37:50 <prologic> that's right isn't it ?
18:37:56 <prologic> expand the rest of ms
18:37:58 <ski> yes
18:38:00 <prologic> but with the new macro added
18:38:03 <prologic> sweet ;)
18:38:05 * prologic dances
18:38:06 <ski> with updated env
18:38:09 <prologic> yep :)
18:38:29 <prologic> ok now here's something interesting
18:38:32 <prologic> I can build up a list
18:38:35 <prologic> ie: using cons, :
18:38:40 <ski> and the really nice thing is : we don't have to undo the adding after the recursive call finishes
18:38:44 <prologic> wait a minute
18:38:49 <prologic> SYmbolTable is a list
18:38:51 <ski> 'cuz we haven't mutated it
18:39:51 <ski> all the old calls to macroExpand' that are lying waiting on the stack to get called in gonna get older versions of st, as they should
18:40:04 <prologic> that's right :)
18:40:05 <ski> yes
18:40:09 <prologic> was my originaly intention
18:40:12 <prologic> dive in, come back out
18:40:18 <prologic> preserving the original table
18:40:37 <ski> that is the environment pattern  (captured e.g. by the env monad)
18:40:45 <prologic> ahh k
18:40:45 <ski> so to speak
18:40:49 <prologic> which we'll probably learn son
18:40:50 <prologic> soon
18:41:10 <ski> that reminds me
18:41:26 <ski> the concrete syntax can contain things like
18:41:40 <ski> abcd{yadda yadda}efgh
18:41:42 <prologic> addMacro st n v = st ++ n:macroExpand' (st v) <-- gonna have to be something like this ?
18:42:03 <prologic> yeh that's just a block with plain text :)
18:42:13 <prologic> should putput: abcdyadda yaddaefgh
18:42:42 <ski> yes, but how do we represent the block in the MacroExpr.  i now think we need the Block constructor after all
18:43:23 <ski> yeah : bu t suppose macros are defined in yadda, then those shouldn't be visible after the }, according to the spec.
18:43:35 <prologic> that's right
18:43:41 <prologic> it's inside a local block
18:43:55 <ski> so if we add a Block constructor again
18:44:12 <prologic> you mean we need a Block constructor afterall ? :)
18:44:29 <ski> and make macroExpand' call itself recursively on that, we should have no problem with the }, i think
18:44:31 <ski> yes
18:44:35 <prologic> heh
18:44:41 <prologic> what should Block hold ?
18:44:45 <prologic> [MacroExpr] ?
18:44:59 <ski> a list of MAcroExpr's, of course
18:45:03 <ski> yes
18:45:40 <prologic> now we have another pattern on Block
18:45:50 <ski> btw you only need {-  -} for block comments
18:45:56 <prologic> ahh k
18:45:57 <prologic> ta :)
18:46:08 <ski> what is ta ?   thanks ?
18:46:11 <prologic> yep
18:46:13 <ski> ok
18:46:18 <prologic> bit of english slang
18:46:34 <ski> maybe i should learn it too
18:46:52 <ski> you can't have the smae variable more than once in the same pattern
18:46:59 <ski> s/smae/same/
18:47:01 <ski> :)
18:47:02 <prologic> it's ms' now :)
18:47:06 <ski> fine
18:47:12 <prologic> (Block ms:ms')
18:47:21 <ski> st ?
18:47:28 <prologic> with st in front :)
18:47:50 <ski> or (Block ms':ms)  ('cuz you called the tail ms in all the other cases)
18:48:12 <prologic> there
18:48:13 <prologic> :)
18:48:28 <ski> (just personal stylistic thing)
18:48:33 <prologic> yep
18:48:39 <ski> work too :)
18:48:40 <prologic> always good to keep code clean  :)
18:48:45 <ski> right
18:48:57 <prologic> ERROR "macro.hs":34 - Type error in application
18:48:57 <prologic> *** Expression     : n : macroExpand' st v
18:48:57 <prologic> *** Term           : n
18:48:57 <prologic> *** Type           : [Char]
18:48:57 <prologic> *** Does not match : Char
18:49:06 <prologic> 34: addMacro st n v = st ++ n:macroExpand' st v
18:49:20 <ski> now any macro def.s in bs ain't gonna contaminate the rest ms
18:49:32 <ski> yes
18:49:40 <ski> that is worng
18:49:48 <prologic> I know :(
18:49:56 <ski> say you have this
18:50:11 <ski> \FOO{a}\FOO{b}\FOO
18:50:34 <ski> what should st look like just before the macro call
18:50:58 <ski> (remember how lookup searches the list)
18:51:02 <prologic> ("FOO", "b") ?
18:51:11 <ski> is's a list
18:51:17 <ski> [...]
18:51:20 <prologic> yeh
18:51:25 <prologic> [("FOO", "b")]
18:51:43 <ski> or [("FOO", "b"),("FOO","a")]
18:51:51 <prologic> ahh yep
18:51:54 <prologic> with the old one
18:51:58 <ski> lookup always takes the first match
18:52:03 <prologic> k
18:52:38 <prologic> trouble is, in addMacro, v is [MacroExpr]
18:52:47 <prologic> not so easy extending the table
18:52:51 <ski> perhaps a little inefficient, but not very much. more inefficient to try to remove all the old overridden def.s from the list, i think
18:53:10 <ski> v is MacroValue
18:53:16 <prologic> yeh
18:53:19 <ski> type SymbolTable = [(MacroName, MacroValue)]
18:53:22 <prologic> which is synonm for [MacroExpr]
18:53:46 <prologic> of course
18:53:53 <prologic> MacroValue == MacroValue
18:53:59 <ski> just add a new pair, in front of the old SymbolTable, that's what i'd do
18:54:02 <ski> yes :)
18:55:00 <prologic> weee :)
18:55:04 <prologic> type checks ok :)
18:55:06 <ski> and i don't think you want to macroexpand the macro-def.s body *both* in addMacro *and* in macroExpand' (line with MAcroCall)
18:55:16 <ski> yes
18:55:22 <prologic> all good now ?
18:55:34 <ski> hmm
18:56:47 <ski> anyway, if you wanted static scope, you'd just move the macroExpand' call of the macro def. body from MacroCall line in macroExpand' to addMacro
18:57:09 <ski> (+ change to  type SymbolTable = [(MacroName, String)] )
18:57:18 <ski> like
18:57:35 <ski> addMacro st n v = [(n, expandMacro' st v)] ++ st
18:57:36 <ski> and
18:57:55 <ski> Just a  -> a ++ macroExpand' st ms
18:58:07 <prologic> ahh k
18:58:44 <ski> (that way the body of the def. get the st which was in effect at the def. site. not the one in effect at the call site)
18:58:46 <prologic> now we need to do the parse function ?
18:58:58 <ski> hmm, one more thing
18:59:19 <prologic> yup?
18:59:44 <ski> \=FOO{\=BAR{xyzzy}}\FOO\BAR
19:00:03 <ski> is the last \BAR an undefined macro or not
19:00:14 <prologic> yes it is
19:00:18 <prologic> it's only local to \FOO
19:00:20 <ski> i.e. does the above turn into :
19:00:33 <ski> {\BAR{xyzzy}}\BAR
19:00:34 <ski> or
19:00:42 <ski> \BAR{xyzzy}\BAR
19:00:50 <ski> presumably the first one
19:00:54 <prologic> yeah
19:00:57 <prologic> presumably :)
19:01:14 <prologic> that's the very definition of a block anyway
19:01:17 <prologic> in 7. Blocks
19:01:17 <ski> because they use the {} as brackets in the macro def.
19:01:29 <prologic> yeah
19:01:54 <prologic> that's not a problem in our implementation is it ?
19:02:09 <ski> (one could also see the {} in a def. as just part of the syntax, and thus nothing to actually substitute)
19:02:15 <ski> m
19:02:30 <ski> no
19:02:37 <ski> it would be if we did
19:02:39 <prologic> well according to the rules {} defines a local scope
19:02:46 <ski>    Just a  -> macroExpand' st (a ++ ms)
19:02:59 <ski> you see ?
19:03:22 <prologic> kinda :)
19:03:58 <ski> if a contains any definitions, then those are going to pollute the whole list we are currently in
19:04:27 <prologic> that's why we're expanding it first ?
19:04:37 <prologic> then adding it on to the rest of ms expanded
19:04:47 <ski> (because we always pass the st (possibly updated in MacroDef) to the call with the rest of the list)
19:04:52 <ski> yes
19:04:55 <prologic> yeah
19:04:58 <prologic> precisely
19:05:04 <ski> same thing in Block case
19:05:12 <prologic> k
19:05:41 <ski> btw, you can replace [foo] ++ bar  with foo : bar , you know
19:06:14 <prologic> ah didn't know that
19:06:18 <prologic> what's ++ used for anyway ?
19:06:26 <ski> @prelude (++)
19:06:28 <lambdabot> *** "(++)" prelude "Haskell Standard Prelude Dictionary": text follows
19:06:28 <lambdabot> (++)
19:06:28 <lambdabot>   infixr 5 ++
19:06:28 <lambdabot>   (++) ::  [a] -> [a] -> [a]
19:06:28 <lambdabot>   []     ++ ys      = ys
19:06:30 <lambdabot>   (x:xs) ++ ys      = x : (xs ++ ys)
19:06:35 <ski> appending lists
19:07:02 <prologic> where did you say I could replace it ?
19:07:05 <prologic> not in addMacro
19:07:08 <prologic> I am appending a list there :)
19:07:14 <ski> but if the first list is very short, one often does it by hand  (especially in the 0- and 1- element cases)
19:09:19 <ski> if you do that, then i think the macroExpand portion is working correctly
19:09:35 <prologic> addMacro st n v = (n, v):st
19:09:36 <prologic> :)
19:09:40 <ski> (of course [foo] ++ bar is correct too)
19:09:41 <prologic> (n, v) is just a single element :)
19:09:53 <ski> mm
19:12:09 <ski> do you want all type-def.s in one place.  otherwise you can move SymbolTable down to the macroExpand part of the program, because other pieces of the program doens't use it at all. it is internal to the implementation of the expansion part ..
19:12:30 <ski> doensn't matter much, really
19:13:37 <ski> hello ?
19:17:54 <ski> prologic ?
19:20:48 <prologic> sorry ski
19:20:51 <prologic> my gf's family is here
19:20:59 <ski> ok
19:21:00 <ski> :)
19:21:00 <prologic> she's going down for a few days
19:21:06 <prologic> have to be umm what you call it
19:21:08 <prologic> social :)
19:21:12 <prologic> bbs I apolagise
19:21:19 <ski> ok
19:21:30 <ski> do you have any idea of how to implement parse
19:21:35 <ski> i have to go soon
19:21:50 <ski> have to come home in time to watch Sailor Moon :)
19:35:10 <prologic> hehe
19:35:19 <prologic> ok I'm back for a little while
19:35:22 <prologic> they kicked me out
19:35:25 <ski> ok
19:35:28 <prologic> I wasn't participating much anyway
19:35:32 <ski> :)
19:35:38 <prologic> with the parse, I'd just pattern match against the string patterns ?
19:36:01 <prologic> and of course patterns like \=[A-Z]*
19:36:04 <ski> (you know what Sailor Moon is ?)
19:36:09 <ski> yes
19:36:10 <prologic> yes I do vaugly
19:36:21 <prologic> but it doesn't suprise me that you watch it
19:36:25 <prologic> I watch all sorts of weird stuff too :)
19:36:33 <ski> dont forget \LineFeed \Space and \EOF
19:36:40 <prologic> yup
19:37:01 <prologic> what else must parse do besides follow the rules given in the exercise ?
19:37:22 <prologic> like when it identifies a macro \=[A-Z]* ...
19:38:37 <ski> i got started when i distributed some newspapers in the morning in the summer. then the series started over, so i thught, doh, i'll try to not miss a single program.  anyway it is really funny, in a weird ironic sensne sometimes :)
19:38:49 <ski> well
19:38:55 <prologic> I like watching stargate myself :)
19:38:59 <prologic> try not to miss an episode
19:39:04 <ski> it has to keep track of the nesting level
19:39:26 <ski> you know how to keep track of that ?
19:39:34 <prologic> counter ?
19:39:49 <prologic> doesn't macroExpand already take care of nested blocks ?
19:39:53 <ski> but it should be restored on each }
19:39:59 <ski> yes
19:40:29 <ski> but we have to create the nested blocks correctly also. i.e. from the input string
19:41:14 <prologic> hrmm so parse each line, incrementing the nesting counter for each {
19:41:22 <prologic> then decrement it for each mathing }
19:41:23 <ski> hmm, i think one could do the nesting level with an environment pattern (as with st below)
19:41:43 <ski> but it is probably easier to use an accumulator
19:42:13 <ski> prologic, you don't even have to split the input into lines
19:42:22 <ski> just go on character for character
19:42:33 <prologic> in the prase function ?
19:42:54 <prologic> parse
19:43:04 <ski> (well, if we had a Parser monad here, an env pattern would perhaps be simpler)
19:43:09 <ski> yes
19:43:18 <prologic> no monads :)
19:43:18 <prologic> hehe
19:43:23 <ski> yep
19:43:25 <prologic> I'll only get confused
19:44:08 <prologic> well we'll start off by parsing a macro name ?
19:44:11 <ski> it is easier to use a monad than to make one, or to understand how it works, for that matter
19:44:36 <ski> code written in a parsing monad is quite easy to grasp, actually
19:44:49 <ski> well, nevermind that for now
19:45:35 <ski> macro call or def. ?
19:46:35 <ski> prologic = you'll need an accumulator arg for the nesting level, so it is best to make a local function directly
19:47:02 <ski> btw you can put macroExpand' in a where-clause to macroExpand
19:47:14 <ski> macroExpand :: [MacroExpr] -> String
19:47:17 <ski> macroExpand = macroExpand' []
19:47:19 <ski>   where
19:47:23 <ski>   macroExpand' :: SymbolTable -> [MacroExpr] -> String
19:47:24 <prologic> yep
19:47:26 <ski>   macroExpand' _ [] = ""
19:47:27 <ski>   ...
19:47:29 <prologic> I'll leave it out for now :)
19:47:34 <ski> 'kay
19:47:49 <ski> easier to test, that way..
19:47:52 <prologic> will I need an auxilary function to parse ?
19:47:54 <prologic> yep
19:47:59 <ski> right
19:48:11 <ski> better make an parse'
19:48:41 <ski> i usually call local functions like parse' and macroExpand', loop
19:48:51 <prologic> k
19:48:59 <ski> just loop  (all of them)
19:49:04 <prologic> start off the nesting counter at 0
19:49:07 <ski> ok, hm
19:49:12 <ski> yes
19:49:26 <ski> swap args in type of parse'
19:49:32 <prologic> ok
19:49:40 <ski> worng order compared to parse definition
19:50:05 <ski> i think you can remove the {- and -} now also
19:50:11 <prologic> yup
19:50:13 <ski> right
19:50:27 <prologic> now with parse'
19:50:31 <ski> yep
19:50:34 <prologic> we do \=FOO first ?
19:50:40 <ski> ok
19:50:42 <prologic> match a macro
19:50:45 <prologic> seems logical
19:51:10 <ski> use '\\'
19:51:13 <ski> :)
19:51:20 <prologic> hrmm
19:51:26 <prologic> how does the nesting counter come into play in parse' ?
19:51:44 <ski> parse' n ('\\':'=':s) = ...
19:51:44 <prologic> oh nevermind :)
19:51:59 <prologic> ahh wonderfull :)
19:52:08 <prologic> then I need to check if s is all uppercase
19:52:13 <prologic> that's the rule :)
19:52:24 <ski> (you can't use ++ in patterns :(  not even when the first arg is known)
19:52:35 <prologic> k
19:52:40 <ski> must the macro name be in upper case ?
19:52:46 <prologic> yep
19:52:48 <ski> ok
19:52:56 <prologic> macroName ::= {upper-case-letter}+
19:52:58 <ski> just takeWhile isUpper
19:53:07 <ski> or something like thar
19:53:09 <ski> that
19:53:12 <prologic> yep
19:53:21 <ski> then check it has length > 0
19:53:40 <prologic> hrmm
19:53:45 <prologic> how complicated is parse' going to be ?
19:53:51 <prologic> because once it has a macroname
19:53:52 <ski> hmm
19:53:58 <prologic> it'll then have the value
19:54:02 <prologic> between the { and }
19:54:12 <ski> probably some more lines than macroExpand'
19:54:23 <ski> but i don't think it should be so long
19:54:25 <prologic> ok
19:54:30 <prologic> sounds reasonable
19:54:38 <prologic> and it'll obviously be recursive
19:55:22 <ski> i think you can make another auxilary function for parsing { .... }, then call that both from a macro def. , and from an ordinary block
19:55:34 <ski> let it return [MacroExpr]
19:55:35 <prologic> spanBlock :) ?
19:55:45 <ski> parseBlock ?
19:55:51 <prologic> hehe
19:56:00 <prologic> it was actually suggested by our professor, spanBlock
19:56:03 <prologic> but parseBlock is ok
19:56:24 <ski> so you don't have to repreat the code for checking { and }
19:56:35 <prologic> parseBlock :: String -> [MacroExpr]
19:56:42 <ski> parseBlock should be quite short, i think
19:57:24 <ski> it will need the nesting level  (or make it's own local functions,  aargh, more local functions ! :)
19:57:34 <prologic> lol
19:57:41 <prologic> parseBlock will need the nesting level ?
19:57:42 <prologic> why ?
19:58:10 <prologic> won't it just return the text from { to the first matching } ?
19:58:34 <ski> parseBlock will (with the given type, at least) parse a block, *and* *then* call parse' to parse the remaining of the string
19:58:54 <ski> we could also make parseBlock return ([MacroExpr],String)
19:59:01 <prologic> yeh parseBlock will have to parse the string inside
19:59:16 <ski> in that case it just returns the remaining string
19:59:24 <prologic> hmm
19:59:50 <prologic> can I write it the long way first
19:59:50 <ski> hm
19:59:53 <prologic> repeating the code :)
19:59:58 <ski> sure
20:01:09 <ski> parse' n ('\\':'=':s)
20:01:20 <ski>   | length n > 0 = ...
20:01:28 <ski>   | otherwise = error ...
20:01:30 <ski>   where
20:01:37 <ski>   n :: MacroName
20:01:41 <ski>   n = takeWhile isUpper s
20:02:26 <ski> what do you think of that ?
20:03:01 <prologic> you're only gaurding against a negative nesting level ?
20:03:13 <ski> what ?
20:03:21 <prologic> n is an Integer
20:03:25 <ski> so
20:03:37 <ski> n wont become negative anyway
20:03:39 <prologic> length takes a list ?
20:03:46 <ski> @type length
20:03:46 <lambdabot> length :: [a] -> Int
20:03:52 <prologic> yeh
20:04:01 <prologic> oh wait
20:04:13 <prologic> you're referring to the n = takeWhile isUpper s
20:04:22 <ski> yes
20:04:25 <ski> hmm
20:04:25 <prologic> ok :)
20:04:26 <prologic> sorry
20:04:32 <ski> @type splitWhile
20:04:41 <ski> @type List.span
20:04:46 <ski> @type span
20:04:46 <lambdabot> span :: (a -> Bool) -> [a] -> ([a],[a])
20:04:51 <ski> @eval span
20:04:52 <lambdabot> <<EM Dynamic -> EM Dynamic>>
20:05:20 <ski> @eval span (\x.x < 5) [1,2,3,4,5,6,7,8,7,6,5,4,3,2,1]
20:05:21 <lambdabot> <<EM Dynamic -> EM Dynamic>>
20:05:37 <ski> ??
20:05:52 <prologic> don't ask me :)
20:06:03 <ski> @get-definition span
20:06:04 <lambdabot> span = \p l.if null l then Pair [] [] else pair (\ys zs.if p (head l) then Pair (head l : ys) zs else Pair [] l) (span p (tail l))
20:06:37 <ski> @get-definition pair
20:06:38 <lambdabot> pair = \k p.p k
20:07:30 <ski> @define oldSpan \p l.if null l then Pair [] [] else pair (\ys zs.if p (head l) then Pair (head l : ys) zs else Pair [] l) (span p (tail l))
20:07:30 <lambdabot> oldSpan defined
20:08:37 <ski> @eval fst
20:08:37 <lambdabot> <<EM Dynamic -> EM Dynamic>>
20:10:42 <prologic> ski help :)
20:10:51 <prologic> trying to do parseBlock best I can
20:10:52 <ski> @define pair_ \k.\p.k (fst p) (snd p)
20:10:53 <lambdabot> pair_ defined
20:11:15 <ski> @define span \p l.if null l then Pair [] [] else pair_ (\ys zs.if p (head l) then Pair (head l : ys) zs else Pair [] l) (span p (tail l))
20:11:15 <lambdabot> span defined
20:11:20 <ski> @eval span (\x.x < 5) [1,2,3,4,5,6,7,8,7,6,5,4,3,2,1]
20:11:20 <lambdabot> <<EM Dynamic -> EM Dynamic>>
20:11:26 <ski> nooo
20:12:01 <ski> whatever
20:12:33 <prologic> IO> span (\x -> x < 5) [1,2,3,4,5,6,7,8,7,6,5,4,3,2,1]
20:12:33 <prologic> ([1,2,3,4],[5,6,7,8,7,6,5,4,3,2,1])
20:12:57 <ski> @define span "see oldSpan. though it is not working correctly. probably has to do with pair. tried to make a pair_"
20:12:57 <lambdabot> span defined
20:13:10 <prologic> heh
20:13:12 <prologic> @eval span
20:13:13 <lambdabot> see oldSpan. though it is not working correctly. probably has to do with pair. tried to make a pair_
20:13:15 <prologic> lol
20:13:20 <ski> :)
20:13:43 <Riastradh> Mmmmm AlBook!
20:13:47 <ski> ok
20:13:49 <prologic> hrmm ok ski
20:13:51 <prologic> with parseBlock
20:13:59 <prologic> if it sees another { it has to call parse again on that right ?
20:14:02 <ski> yes
20:14:06 <prologic> ie: nested blocks
20:14:07 <prologic> argg :)
20:14:11 <ski> yes
20:14:13 <prologic> takeWhile won't work in this case
20:14:14 <ski> no
20:14:17 <ski> call parse'
20:14:23 <prologic> yeh sorry
20:14:27 <ski> and pass the current nesting level
20:14:42 <ski> which parseBlock should get from parse' i think
20:15:26 <ski> parseBlock n [] = error someEOFerror
20:15:57 <ski> parseBlock _ _ = error missing{inMacroDef
20:16:06 <ski> right ?
20:16:13 <prologic> something like that :)
20:17:07 <ski> (i don't think you need parseBlock')
20:17:14 <ski> yes
20:17:53 <prologic> I don't ?
20:18:40 <ski> hmm, i was just going to say that you could display what macro name was before, but you can't.  it isn't passed to parseBlock. and we was thinking of calling parseblock from another place in parse', right ?
20:18:52 <ski> no, what's it for
20:19:05 <ski> parseBlock already gets the nesting level
20:19:20 <prologic> wooah
20:19:23 <prologic> loosing me :)
20:19:24 <ski> it can just call itself, if it wants
20:19:35 <prologic> me bloody eyes feel like sandpaper ;(
20:19:41 <ski> tired ?
20:19:46 <prologic> no
20:19:50 <prologic> I have an eye disease
20:19:54 <prologic> slowly going blind
20:20:03 <ski> ok, not funny
20:20:05 <prologic> genetic :(
20:20:15 <ski> :(
20:20:20 <prologic> yeh it's crap
20:20:30 <prologic> neway nevermind
20:20:52 <prologic> so why don't I need parseBlock' ?
20:20:55 <ski> we can add the simple cases ro parse'
20:20:59 <ski> um
20:21:18 <prologic> yeh ok let's do some simple cases
20:21:26 <prologic> will help me understand how to do the macro one :)
20:21:43 <ski> well, in the other cases we wanted local functions, because we wanted to pass extra info, that was going to change in recursive calls
20:21:53 <prologic> yep
20:22:03 <prologic> that's why you have auxilary functions :)
20:22:06 <ski> in parseBlock we already have that extra info (and it can change in recursive calls)
20:22:09 <ski> :)
20:22:15 <prologic> ok
20:22:24 <ski> ok, simple cases coming up.
20:22:30 <ski> \\
20:22:32 <ski> \Space
20:22:37 <ski> \NewLine
20:22:39 <ski> \EOF
20:22:43 <ski> EOF
20:23:01 <ski> also
20:23:07 <ski> \MACRONAME
20:23:17 <ski> and
20:23:34 <ski> AnyOtherCharThan\
20:23:55 <ski> have i forgot some ?
20:24:09 <prologic> I don't think so
20:24:48 <ski> the first four should be matched against, before \MACRONAME
20:24:58 <ski> easiest
20:25:01 <ski> well :
20:25:24 <ski> \NonUpperCaseNon\NonSpaceNonNewLine     also ?
20:25:29 <ski> ye
20:25:31 <ski> yes
20:25:55 <prologic> hmm?
20:25:57 <prologic> \Non ?
20:26:02 <ski> first line is worng, i think
20:26:07 <ski> Non =  not
20:26:22 <prologic> parse' ('\\':s) =
20:26:23 <prologic> parse' ('\\':' ':s) =
20:26:23 <prologic> parse' ('\\':'\n':s) =
20:26:23 <prologic> parse' ('\\':'\0':s) =
20:26:23 <prologic> parse' ('\\':s) =     
20:26:23 <prologic> parse' (c:s) =
20:26:27 <ski> and EOF is not \0
20:26:31 <ski> just
20:26:35 <prologic> no EOF is ^D
20:26:37 <ski> ('\\':[])
20:26:39 <prologic> whatever that is in Haskell
20:26:44 <prologic> k
20:26:44 <ski> or
20:26:50 <ski> ['\\']
20:26:51 <ski> or
20:26:54 <ski> "\\"
20:26:57 <prologic> ok
20:27:06 <ski> that is, End-Of-List
20:28:20 <prologic> isn't there another one
20:28:21 <ski> you could rename n to name, then you can rename level to n or i or l or something
20:28:27 <prologic> a \ and the end of a line supresses the new line char
20:28:33 <ski> if you want to, i.e.
20:28:43 <ski> yes
20:28:47 <ski> same with Space
20:29:07 <ski> (except it is still a break)
20:29:17 <ski> i.e. ABC\ DEF
20:29:22 <ski> should become
20:29:34 <ski> [Text "ABC",Text "DEF"]
20:29:47 <prologic> brb
20:29:49 <ski> well, that actually doesn't matter
20:30:31 <ski> try \=FOO{kroffo}\FOO\ ABCD
20:30:55 <ski> hello RibenaBoy
20:31:01 <RibenaBoy> hi
20:31:06 <ski> Are you in sydney ?
20:31:13 <RibenaBoy> yeh
20:31:16 <RibenaBoy> y
20:31:18 <RibenaBoy> ?
20:31:31 <ski> what ?
20:31:37 <RibenaBoy> why do u ask?
20:32:05 <ski> ~23kjhkjf@234.b.007.syd.iprimus.net.au  i guessed syd was sydney, that's all :)
20:32:39 <ski> well, are you learning haskell ?
20:32:48 <ski> or just looking in ?
20:33:04 <ski> or perhaps you even know it already ..
20:33:17 <RibenaBoy> im a newbie
20:33:21 <ski> ok
20:33:32 <ski> taking a course ?
20:33:39 <ski> any questions right now ?
20:34:37 <RibenaBoy> not really
20:34:46 <ski> ok
20:35:20 <ski> i'm currently trying to help prologic to program a small macro expander
20:35:42 <RibenaBoy> i hav no idea what that is
20:36:17 <prologic> arggg
20:36:20 <ski> do you know any other programming language ?  basic ? c ? java ?
20:36:26 <prologic> I hate it when my gf goes aaway :(
20:36:27 <ski> prologic : what ?
20:36:30 <ski> ok
20:36:38 * prologic feels lonely already!
20:37:14 <ski> don't feel so lonely, there is still people here ;)
20:37:19 <prologic> hehe
20:37:23 <prologic> where am I up to
20:37:26 <prologic> I don't have long
20:37:30 <RibenaBoy> haskell is my first programming language
20:37:35 <RibenaBoy> and i hate it already
20:37:35 <prologic> oh lucky you :)
20:37:38 <ski> RibenaBoy : ok
20:38:09 <prologic> ihmo it's probably good knowing a FPL first than a IPL
20:38:25 <ski> RibenaBoy : fine, then your haven't spoiled your brain with other paradigms yet (for instance : imperative programming, e.g. c,basic,java)
20:38:48 <ski> yes, i think so too
20:39:26 <prologic> am I stil here ?
20:39:39 <prologic> phew
20:39:41 <ski> of course you are, you are writing
20:39:42 <prologic> got disconnected :)
20:39:50 <ski> aha
20:40:00 <prologic> 6hr session limit
20:40:16 <ski> what ?  why ?
20:40:24 <ski> eevil !
20:40:25 <prologic> dialup
20:40:27 <prologic> yeh
20:40:29 <prologic> eveil :)
20:40:31 <RibenaBoy> ski can i ask you a question but u hav to download some files to see what im talking about first
20:40:45 <prologic> is the first pattern right now ski ?
20:40:50 <prologic> ('\\':'\\':s)
20:41:28 <ski> RibenaBoy : if they aren't too big, i think you can ask  (well, you can *ask* in either case)
20:41:41 <ski> yes, looks like that
20:42:05 <ski> '\\':'\\': 
20:42:11 <ski> is two \\
20:42:13 <ski> yes
20:42:36 <prologic> yup
20:42:43 <prologic> parse' n ('\\':'\\':s) = [Text '\\'] ++ parse' n s
20:43:24 <prologic> I hope that's right
20:43:25 <prologic> hehe
20:44:54 <prologic> parse' n ('\\':'\n':s), should this be (s:'\\':'\n') ?
20:45:16 <ski> no
20:45:25 <ski> but, hmmm
20:45:41 <prologic> in 4. it says the \ at the end of a line supresses the \n
20:46:45 <ski> yes
20:47:00 <prologic> so it should be s:'\\':'\n' :)
20:47:11 <ski> but, i was thinking on making as long Text's as possible
20:47:41 <prologic> what do you mean ?
20:48:11 <ski> with breaks in Text only for other constructors than Text
20:48:25 <prologic> hrmm
20:48:58 <prologic> wb
20:49:36 <ski> wb ?
20:49:45 <prologic> heh nevermind
20:49:50 <prologic> wb = welcome back
20:50:30 <ski> ah
20:50:49 <ski> i was just starting another irc client
20:50:52 <prologic> k
20:51:17 <prologic> could you take a look at what I've done ?
20:51:47 <ski> yes, sure
20:51:50 <prologic> ta
20:51:58 <ski> lemmesee
20:52:38 <ski> the [Text ""] ++ parts in row 2 and 3 is totally unnecessary, don't you think ?
20:53:14 <ski> also  [foo] ++ ...  ==  ???      :)
20:53:59 <prologic> eh ?
20:54:11 <ski> [foo] ++ bar === foo : bar
20:54:22 <prologic> right
20:55:24 <ski> also, if we are going to call parseBlock to parse an ordinary block, then the error message is wrong (it is wrong specific)
20:56:13 <prologic> well if there is nothing after it
20:56:21 <prologic> eg: \FOO
20:56:22 <prologic> err
20:56:28 <prologic> \=FOO
20:57:28 <ski> ummmm, no, nevermind
20:57:36 <ski> it won't happen
20:57:36 <prologic> it's good ?
20:57:39 <ski> yes
20:57:41 <prologic> k
20:57:42 <ski> mostly
20:57:46 <prologic> heh
20:57:50 <prologic> it type checks ok :)
20:58:23 <prologic> Macro> parse' 0 "\\=FOO"
20:58:23 <prologic> Program error: {parseBlock (Num_fromInt instNum_v30 0) "FOO"}
20:58:24 <prologic> lol
20:58:30 <prologic> not good :(
21:01:07 <ski> umm
21:01:20 <prologic> yeh?
21:01:22 <ski> it has eaten \=
21:01:37 <ski> yes
21:01:45 <prologic> it should have in the pattern
21:02:03 <ski> use span, instead of takeWhile,  i was thinking of that before, but forgot
21:02:16 <prologic> why span vs. takeWhile ?
21:02:20 <ski> span does the job of both takeWhile and dropWhile
21:02:26 <prologic> ahh k
21:02:28 <ski> @type span
21:02:29 <lambdabot> span :: (a -> Bool) -> [a] -> ([a],[a])
21:02:38 <ski> it'll return two lists
21:02:51 <ski> the initial part (the name) and the rest
21:03:21 <prologic> hrmm
21:03:23 <ski> currently we send the whole s ("FOO") to parseBlock
21:03:33 <ski> that's not good
21:03:38 <prologic> yeh
21:03:48 <prologic> should be sending the { ... }
21:05:25 <prologic> how am I going to extract the name out and the rest of the string ?
21:05:33 <prologic> I know I have to pattern match it again (a,b)
21:06:54 <ski> Prelude> span isUpper "FOO{dkjfkljsdf}"
21:06:55 <ski> ("FOO","{dkjfkljsdf}")
21:07:29 <prologic>    name :: MacroName
21:07:30 <prologic>    name = span isUpper s
21:07:32 <prologic> that won't work though :)
21:07:34 <prologic> hrmm
21:10:00 <prologic> @type fst
21:10:01 <lambdabot> fst :: (a,b) -> a
21:10:04 <prologic> ahh :)
21:10:05 <prologic> fst :)
21:10:09 <prologic> @type snd
21:10:10 <lambdabot> snd :: (a,b) -> b
21:10:13 <prologic> idiot :)
21:10:24 <prologic> I was almost going to write functions to do the same thing!
21:10:45 <ski> (name,s') = span isUpper s
21:10:51 <ski> name :: MacroName
21:10:59 <prologic> ahh
21:11:02 <prologic> I didn't know you could do that
21:11:03 <ski> (s :: String)     if you want it
21:11:04 <prologic> :(
21:11:19 <ski> another form of pattern-matching
21:11:37 <ski> mostly useful for types with only one constructor
21:11:40 <ski> (like tuples)
21:11:43 <prologic> k
21:12:33 <prologic> Macro> parse' 0 "\\=FOO{asdfasdf}"
21:12:34 <prologic> Program error: {parse' ((instNum_v30 Num_+ Num_fromInt instNum_v30 0) (Num_fromInt instNum_v30 1)) "asdfasdf}"}
21:12:34 <prologic> wee :)
21:13:05 <ski> it has eaten the {  :)
21:13:23 <prologic> Macro> parse' 0 "\\=FOO"
21:13:24 <prologic> Program error: No block in new macro definition.
21:13:25 <prologic> excellent
21:13:28 <prologic> that works :)
21:13:51 <ski> parse' n (c:s) = Text [c] : parse' n s
21:13:56 <ski> put that lastly
21:13:58 <prologic> ok well I need to complete the definition of parseBlock
21:14:00 <prologic> I think it's wrong
21:14:09 <ski> that is possible
21:14:25 <prologic> this parses every _other_ character ?
21:14:30 <ski> yes
21:14:41 <ski> that's why you should put it last
21:14:48 <prologic> yup
21:15:08 <prologic> ok what should parseBlock do again ?
21:15:14 <ski> hmm
21:15:19 <prologic> see a '{', increment the level, call parse'
21:15:26 <ski> hmm
21:15:36 <ski> no
21:15:39 <ski> hmm
21:15:51 <ski> (yes to your sentence)
21:16:37 <prologic> I haven't done it right though
21:16:41 <ski> perhaps i'm just stupid, we can't actually pair together the matching of a { and the corresponding } in parseBlock, as i was thinking
21:17:13 <prologic> unless you eat the initial { in parse'
21:17:25 <ski> must have been thinking of the monadic parser version with environment-like nesting level
21:17:32 <ski> so
21:17:57 <ski> i'll think we skip parseBlock completely
21:18:08 <prologic> arrr :)
21:18:18 <ski> @arr
21:18:19 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
21:18:24 <ski> @arr
21:18:24 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
21:18:29 <ski> doh
21:18:39 <ski> bad random ?
21:18:48 <prologic> delete parseBlock alltogether ?
21:18:58 <ski> you can keep the error
21:19:04 <ski> we'll need it
21:19:12 <ski> :)
21:19:21 <prologic> you just said to delete the function :)
21:19:39 <ski>    | length name > 0 = case s' of
21:19:55 <ski>      [] -> error about end of file
21:20:17 <ski>      '{':s'' -> here we'll continue
21:20:29 <ski>      _ -> error about missing {
21:20:48 <ski> or should [] complain about missing { as well ?
21:21:59 <prologic> there check it :)
21:22:20 <ski> reloaded
21:22:42 <ski> "No macro name after \\." ??
21:22:47 <ski> EOF it is !
21:23:00 <prologic> well if you have \=FOO
21:23:08 <prologic> and nothing after it, it should complain with that error message
21:23:12 <prologic> No block in new macro def.
21:23:20 <ski> "No macro name after \\."
21:23:35 <ski>       []       -> error "No macro name after \\."
21:24:23 <prologic> better ?
21:27:40 <prologic> Macro> parse' 0 "\\=FOO{asdfasdf}"
21:27:41 <prologic> [Text "a",Text "s",Text "d",Text "f",Text "a",Text "s",Text "d",Text "f",Text "}",Text ""]
21:27:44 <prologic> hrmm :)
21:30:03 <ski> lemmesee
21:30:05 <prologic> that ok so far ?
21:30:15 <prologic> works for very simple cases
21:30:21 <prologic> \\=FOO{text}
21:30:24 <ski> yes
21:30:43 <ski> you must decrease n in the }
21:30:48 <ski> } case
21:30:49 <prologic> yup
21:30:50 <prologic> of course :)
21:30:51 <ski> also
21:31:30 <ski> parse' 0 ('}':s) = error unexpexted}
21:31:34 <ski> and
21:31:41 <ski> parse' n ""
21:31:44 <prologic> k
21:31:57 <ski>   | n > 0 = error unexpectedEOF_expected}
21:32:04 <ski>   otherwise = []
21:32:35 <ski> we want to catch those two kinds of mismatching number of {'s and }'s, right ?
21:32:57 <prologic> yup
21:32:59 <prologic> that's right :)
21:34:00 <prologic> how's that now ?
21:34:06 <prologic> I think I've covered all patterns now
21:34:10 <prologic> except the macro call
21:38:26 <prologic> ski, shouldn't I be building a list of other things besides Text as well ?
21:38:30 <prologic> ie: MacroCall, MacroDef
21:38:32 <prologic> in parse'
21:38:35 <ski> yes
21:38:39 <prologic> lol
21:38:41 <prologic> I'd better do it then
21:38:45 <ski> we have forgotten that :)
21:38:48 <prologic> yeah
21:38:54 <prologic> could you have a look again
21:38:58 <prologic> see what else I may be missing
21:38:59 <ski> yes
21:39:02 <prologic> ta :)
21:39:09 <ski> tada
21:39:27 <prologic> I'll say tada when it's finished :)
21:39:28 <prologic> and working
21:39:29 <prologic> lol
21:39:32 <ski> ('\\':"\n") is worng
21:39:38 <prologic> it is
21:39:39 <prologic> hrmm
21:39:49 <ski> it's the same as
21:39:59 <ski> ('\\':'\n':[])
21:40:12 <prologic> it wouldn't let me use '\n'
21:40:20 <ski> the file need not finish directly after the first newline :)
21:40:21 <prologic> ERROR "macro.hs":29 - Type error in application
21:40:22 <prologic> *** Expression     : '\\' : '\n'
21:40:22 <prologic> *** Term           : '\n'
21:40:22 <prologic> *** Type           : Char
21:40:22 <prologic> *** Does not match : [a]
21:40:36 <prologic> don't like '\n' for some reason :(
21:40:41 <ski> '\\':'\n':[] !
21:40:48 <ski> change to
21:40:52 <ski> '\\':'\n':s
21:40:59 <ski> see ?
21:41:00 <prologic> oh k
21:41:01 <prologic> yup
21:41:06 <prologic> there could be more chars after :)
21:41:08 <prologic> eeesh
21:41:10 <ski> yes
21:41:23 <prologic> parse' n ('\\':'\n':s) = parse' n s
21:41:28 <prologic> so just ignore, and parse the rest
21:41:28 <ski> remove all Text "":
21:41:37 <prologic> not needed
21:41:38 <ski> they are unnecessary
21:41:39 <prologic> ?
21:41:40 <ski> yes
21:41:42 <prologic> ok
21:41:56 <ski> ok
21:42:31 <prologic> hrmm
21:42:43 <prologic> how is it going to suppress the '\n' if it was already parsed ?
21:42:43 <ski> you could put the parse' n "" case at the top or at the bottom, for uniformity
21:42:57 <ski> what ?
21:43:10 <prologic> Macro> parse' 0 "\\=FOO{asdfasdf\n\\}"
21:43:10 <prologic> [Text "a",Text "s",Text "d",Text "f",Text "a",Text "s",Text "d",Text "f",Text "\n",Text "\\"]
21:44:06 <ski> but that \n shouldn't get suppressed, right ?
21:44:16 <prologic> no
21:44:17 <ski> it's not after \
21:44:20 <ski> mm
21:44:24 <prologic> oh wait
21:44:25 <prologic> lemme read
21:44:34 <prologic> oooh
21:44:35 <prologic> lol
21:44:37 <prologic> sorry I read wrong
21:44:48 <prologic> a \ at the end of a line supressed the output of the newline that follows
21:44:52 <prologic> *phew*
21:44:58 * prologic swipes sweat
21:44:59 <ski> (the "" case can actually be after the (c:s) case, because they are not overlapping)
21:45:06 <prologic> ok
21:45:07 <ski> yes
21:45:41 <prologic> ok it works :)
21:45:50 <prologic> now all I need are to construct the other constructors ?
21:45:54 <prologic> MacroCall and MacroDef
21:46:38 <prologic> oh wait
21:46:45 <prologic> I don't have the pattern for calling a macro yet :)
21:49:36 <prologic> arggg my eyes :(
21:49:39 <prologic> this is so unfair :(
21:51:26 <ski> lemmesee
21:51:35 <prologic> please do :)
21:51:41 <prologic> it's looking quite good ihmo
21:51:42 <prologic> thanks to you
21:51:52 <prologic> think I've done MacroDef :)
21:51:59 <ski> and, let's not forget, you :)
21:52:03 <prologic> lol
21:52:11 <prologic> I only had really really rough ideas
21:52:22 <ski> hmm
21:52:25 <ski> well
21:53:03 <ski> no, it seems we'll perhaps have to change to type of parse' a bit
21:53:03 <prologic> Macro> parse' 0 "\\=FOO{asdfasdf\\\n}"
21:53:04 <prologic> [MacroDef "FOO" [Text "a",Text "s",Text "d",Text "f",Text "a",Text "s",Text "d",Text "f"]]
21:53:04 <prologic> Macro> parse' 0 "\\=FOO{asdfasdf\\\n\\FOO}"
21:53:04 <prologic> [MacroDef "FOO" [Text "a",Text "s",Text "d",Text "f",Text "a",Text "s",Text "d",Text "f",MacroCall "FOO"]]
21:53:04 <ski> hmm
21:53:05 <prologic> how's that :)
21:55:07 <ski> we *must* get parse' to return to "      ('{':s') ->  ..." after the matching } , returning the parsed block, *and* the rest of the string after. that way, we'll get a handle to the parsed block, and can put it into MacroDef's second arg
21:55:14 <ski> how does that sound ?
21:55:32 <ski> try
21:55:42 <ski> parse' 0 "\\=FOO{asdfasdf\\\n\\FOO}abcd"
21:55:59 <prologic> [MacroDef "FOO" [Text "a",Text "s",Text "d",Text "f",Text "a",Text "s",Text "d",Text "f",MacroCall "FOO",Text "a",Text "b",Text "c",Text "d"]]
21:56:15 <prologic> that's alright isn't it ?
21:56:23 <ski> no
21:56:26 <ski> Text "a",Text "b",Text "c",Text "d"
21:56:40 <ski> should not be inside the first MacroDef
21:56:46 <prologic> ahh yes
21:56:50 <prologic> ok now I see what you mean
21:56:52 <ski> change type of parse' to 
21:56:52 <prologic> just saw that
21:57:18 <ski> parse' :: Integer -> String -> ([MacroExpr],String)
21:57:32 <ski> change parse to :
21:57:45 <ski> parse s = case parse' 0 s of
21:58:01 <ski>   (ms,[]) -> ms
21:58:28 <ski>   _       -> error hmmm
21:58:40 <ski> not totally sure about this last bit
21:58:53 <prologic> well if a string is returned
21:58:57 <prologic> it should parse that as well
21:59:03 <prologic> when it's empty stop
21:59:19 <ski> define
21:59:51 <ski> prepend :: MacroExpr -> ([MacroExpr],String) -> ([MacroExpr],String)
22:00:02 <ski> prepend m (ms,s) = (m:ms,s)
22:00:11 <ski> then you can write like :
22:00:31 <ski> parse' n ('\\':'\\':s) = Text "\\" `prepend` parse' n s
22:00:39 <ski> parse' n ('\\':' ':s) = parse' n s
22:00:45 <ski> next is similar
22:00:51 <ski> next also
22:01:30 <ski> parse' n ('}':s) = ([],s)
22:01:37 <ski> important !
22:01:41 <prologic> yup :)
22:01:52 <ski> this will make it stop on a }
22:02:05 <ski> and return to the call from     ('{':s') -> 
22:02:33 <prologic> check for me :)
22:02:45 <ski> mm
22:04:13 <ski>       ('{':s') -> let (ms,s'') = parse' (n+1) s' in MacroDef n ms `prepend` parse' n s''
22:04:17 <ski> right ?
22:04:30 <prologic> weee
22:04:32 <prologic> lemme see
22:04:36 <ski> note the last parse' call : n ! not n+1
22:04:59 <ski> also
22:05:29 <ski> parse' n ('\\':s) = MacroCall n `prepend` parse' n s'
22:05:32 <ski>   where
22:05:49 <ski>   (n,s') = span isUpper s
22:06:08 <ski> to get the macro calls
22:06:22 <ski> hmm,
22:06:40 <ski> i think the commented out parse is correct
22:06:44 <ski> but try it out
22:06:55 <ski> and figure out what it should be
22:07:28 <ski> you changed the MacroDef bit ?
22:07:36 <prologic> yup
22:07:44 <prologic> ERROR "macro.hs":40 - Undefined variable "s'"
22:07:49 <ski> no
22:07:59 <ski> put the let-clause
22:08:02 <ski> after the
22:08:07 <ski>       ('{':s') -> 
22:08:13 <ski> in parse' n ('\\':'=':s) ...
22:08:21 <prologic> oh shit :)
22:08:22 <prologic> lol
22:08:24 <ski> this should be replaced
22:08:26 <ski>       ('{':s') -> [MacroDef name (parse' (n + 1) s')]
22:08:30 <prologic> I just wiped that bit of code then
22:09:00 <ski> parse' n ('}':s) = ([],s)
22:09:11 <ski> it was, i think
22:09:21 <prologic> yup
22:09:22 <prologic> ta :)
22:09:33 <ski> in how many hours, is it due ?
22:09:50 <prologic> 2 :)
22:09:54 <ski> ok
22:10:04 <prologic> RROR "macro.hs":42 - Type error in application
22:10:04 <prologic> *** Expression     : MacroDef n ms
22:10:04 <prologic> *** Term           : n
22:10:04 <prologic> *** Type           : Integer
22:10:04 <prologic> *** Does not match : [Char]
22:10:12 <ski> make sure you understand all of the last bits
22:10:13 <prologic> 42:       ('{':s') ->
22:10:27 <prologic> yeh I'll ask you what prepend does in a sec :)
22:10:35 <ski> feel free to more around or rename or such if you want  (of course 
22:11:09 <prologic> hmm what's wrong with line 42 ?
22:11:14 <ski> prepend is just a small helper function so we don't have to type very many let or where clauses instead
22:11:19 <prologic> oh
22:11:20 <prologic> nevermind :)
22:12:18 <ski> ok
22:12:27 <ski> i think i'll have to run now
22:12:33 <ski> good luck !
22:12:39 <prologic> yikes
22:12:41 <prologic> lol
22:12:49 <prologic> thank you ever so much though :)
22:12:53 <ski> is there anything you want to ask now before ?
22:13:02 <prologic> yes parse
22:13:07 <ski> k
22:13:09 <prologic> parse = parse' 0 right ?
22:13:16 <prologic> or the commented out version
22:13:19 <ski> lemmesee
22:13:29 <ski> parse' gives us ms and a string
22:13:37 <ski> when does parse' return
22:13:42 <ski> parse' n ('}':s) = ([], s)
22:13:51 <ski> (return directly)
22:14:07 <ski> and
22:14:09 <ski> parse' n ""
22:14:09 <ski>    | n > 0     = error "error: Unexpected EOF"
22:14:09 <ski>    | otherwise = ([], "")
22:14:16 <ski> second branch
22:14:30 <ski> and we init n to 0
22:14:56 <prologic> by calling parse' here ?
22:15:21 <ski> so yes, i think that, in parse, the string from parse' is always gonna be ""
22:15:24 <ski> so
22:15:32 <ski> parse = fst . parse' 0
22:15:34 <ski> right
22:15:45 <prologic> yup
22:15:55 <ski> i'm not totally sure that that is the case though
22:16:12 <ski> so i suggest you think or test a little about it..
22:16:17 <prologic> see you've changed the very definition of what parse' returns now
22:16:24 <prologic> which means macroExpand has to change too
22:16:32 <ski> no
22:16:39 <ski> should not happen
22:16:49 <prologic> Macro> parse' 0 "\\=FOO{asdfasdf\\\n\\FOO}abcd"
22:16:49 <prologic> ([MacroDef "FOO" [Text "a",Text "s",Text "d",Text "f",Text "a",Text "s",Text "d",Text "f",MacroCall "FOO"],Text "a",Text "b",Text "c",Text "d"],"")
22:16:50 <ski> parse' returns ([MacroExpr], String)
22:17:04 <ski> parse should return [MacroExpr]
22:17:13 <prologic> oh right
22:17:14 <prologic> which it will
22:17:18 <prologic> fst . parse' 0
22:17:18 <ski> try hug it in hugs
22:17:19 <prologic> :)
22:17:25 <prologic> yup
22:17:25 <prologic> it does
22:17:31 <ski> it does type-check right ?
22:17:45 <prologic> Macro> macroExpand $ parse "\\=FOO{asdfasdf\\\n\\FOO}abcd"
22:17:45 <prologic> "abcd"
22:17:47 <prologic> hehe
22:17:49 <prologic> that ain't right :)
22:17:53 <ski> try also to think if there is any case forgotten
22:18:01 <prologic> oh yes it is
22:18:04 <prologic> it isn't calling the macro :)
22:18:28 <prologic> shit infinite loop :)
22:18:29 <ski> macroExpand $ parse "\\=FOO{asdfasdf\\\n}\\FOOabcd"
22:18:33 <ski> try that
22:18:41 <ski> no FOO inside of FOO !
22:18:46 <prologic> Macro> macroExpand $ parse "\\=FOO{asdfasdf\\\n}\\FOOabcd"
22:18:46 <prologic> "asdfasdfabcd"
22:18:52 <ski> nice ?
22:18:56 <prologic> very :)
22:18:59 <ski> ok
22:19:01 <ski> bye
22:19:03 <prologic> I'll have to test it now
22:19:05 <prologic> thank you ski!
22:19:09 <ski> no prob
22:22:12 <prologic> /usr/lib/ghc-6.0.1/libHSrts.a(Main.o)(.text+0xd): In function `main':
22:22:13 <prologic> : undefined reference to `__stginit_Main'
22:22:13 <prologic> /usr/lib/ghc-6.0.1/libHSrts.a(Main.o)(.text+0x2e): In function `main':
22:22:13 <prologic> : undefined reference to `Main_zdmain_closure'
22:22:18 <prologic> what's that mean when I compile with ghc ?
22:22:20 <prologic> anyone :)
