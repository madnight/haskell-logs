00:00:17 <Pseudonym> Well, suppose you had a function which converted a single string into a record.
00:00:40 <Pseudonym> Let's call it "makeAppointmentRecord" or something.
00:00:44 <SlushP> Ok
00:00:54 <Pseudonym> makeAppointmentRecord :: String -> ((Int,Int),String,Bool)
00:00:57 <Pseudonym> or whatever
00:01:03 <SlushP> Can I send you what i've done so far so you can keep my original variables etc?
00:01:09 <Pseudonym> Hang on.
00:01:14 <SlushP> I'll just get confused further:(
00:01:14 <SlushP> Ok
00:01:28 <Pseudonym> You get what makeAppointmentRecord is supposed to do?
00:01:34 <Pseudonym> Take a string and return a _single_ record.
00:01:46 <SlushP> yep
00:01:53 <Pseudonym> Then, you can do something like this:
00:02:14 <Pseudonym> foo s = [ makeAppointmentRecord l | l <- lines s ]
00:02:21 <SlushP> ahh, set comp
00:02:26 <Pseudonym> Right.
00:02:29 <Pseudonym> Or you could use "map".
00:02:33 <Pseudonym> Whatever you like.
00:02:46 <Pseudonym> The point is: you break the problem down into parts.
00:03:01 <SlushP> Ok...
00:03:07 <Pseudonym> Now the problem is reduced to getting a _single_ record out of a string.
00:03:38 <Pseudonym> Get the idea?
00:03:40 <SlushP> Oh, before you go on...
00:03:47 <SlushP> The type of Appointment is...
00:03:55 <SlushP> > type Appointment = (Duration, Note, Important)
00:03:58 <Pseudonym> OK.
00:04:05 <Pseudonym> Sure, you have type synonyms.
00:04:07 <SlushP> Duration = Time,Time (ie. Int, Int)
00:04:08 <Pseudonym> Which is a good thing.
00:04:09 <SlushP> etc etc.
00:04:19 <Pseudonym> So makeAppointmentRecord :: String -> Appointment
00:05:51 <SlushP> Um, where do we use that set comprehension? I mean, we've got makeAppointmentRecord :: String -> Appointment
00:06:00 <Pseudonym> Right.
00:06:02 <SlushP> But, where do we use that part that uses teh set comp?
00:06:08 <SlushP> SOrry
00:06:31 <Pseudonym> Something needs to return a list of Appointments.
00:06:57 <SlushP> :S
00:08:12 <SlushP> I don't get it
00:08:52 <Pseudonym> Well the problem, as I understand it, is to write some function of type String -> [Appointment]
00:09:01 <SlushP> yeah
00:09:12 <SlushP> I just typed:
00:09:12 <SlushP> > strToApp :: String -> Appointment
00:09:12 <SlushP> > strToApps s = [ makeAppointmentRecord l | l <- lines s ]
00:09:16 <SlushP> But that doesn't work:(
00:09:18 <Pseudonym> Basically.
00:09:20 <SlushP> Oh
00:09:21 <SlushP> Hang on
00:09:27 <SlushP> (keep going hehhe)
00:09:41 <Pseudonym> :-)
00:09:46 <Pseudonym> OK.
00:09:52 <SlushP> Yeah, still didn't work:(
00:10:05 <Pseudonym> Looks like makeAppointmentRecord doesn't actually conform to your naming scheme.
00:10:08 <SlushP> > makeAppointmentRecord :: String -> Appointment
00:10:08 <SlushP> > strToApps :: String -> Appointment
00:10:08 <SlushP> > strToApps s = [ makeAppointmentRecord l | l <- lines s ]
00:10:36 <Pseudonym> What error message do you get?
00:10:39 <SlushP> Could I send you what I have so far? so you can see what I'm doing wrong?
00:10:40 <SlushP> Please?
00:10:58 * Pseudonym knows what you're doing wrong from what you've already said
00:11:05 <SlushP> Missing binding for variable "makeAppointmentRecord" in type signature
00:11:12 <Pseudonym> Yes.
00:11:24 <Pseudonym> That means you defined a type for makeAppointmentRecord but no actual code.
00:11:43 <Pseudonym> For now, try this:
00:11:47 <Pseudonym> makeAppointmentRecord = undefined
00:11:52 <SlushP> ok
00:11:57 <Pseudonym> undefined is very useful for this kind of thing.
00:12:46 <SlushP> ok
00:13:41 <SlushP> Another error
00:13:49 <SlushP> Type error in explicitly typed binding
00:13:54 <Pseudonym> Yup.
00:14:04 <SlushP> Want me to paste the error?
00:14:07 <Pseudonym> Sure.
00:14:22 <SlushP> *** Term           : strToApps
00:14:22 <SlushP> *** Type           : String -> [((Int,Int),[Char],Bool)]
00:14:22 <SlushP> *** Does not match : String -> Appointment
00:14:27 <Marvin--> morning guys
00:14:31 <Pseudonym> Morning.
00:14:43 <Pseudonym> SlushP: OK, look hard at this error message for a moment.
00:14:52 <Pseudonym> Does the "Type:" line look familiar?
00:15:20 <SlushP> Um, it looks like the Appointment type.
00:15:21 <SlushP> ???
00:15:28 <Pseudonym> Not quite.
00:15:51 <Pseudonym> What's the type of Appointment, when expanded?
00:15:58 <Pseudonym> Roughly speaking?
00:16:04 <Pseudonym> type Appointment = ?
00:16:29 <Pseudonym> BTW, you'll go a long way once you've learned how to read these error messages.
00:16:48 <SlushP> Umm
00:17:33 <SlushP> > type Appointment = ((Int, Int), String, Bool))
00:17:34 <SlushP> ?
00:17:39 <Pseudonym> Yup.
00:17:46 <Pseudonym> Now look at what hugs thinks the type is.
00:18:10 <SlushP> An array?
00:18:13 <SlushP> List?
00:18:17 <Pseudonym> Bingo.
00:18:30 <Pseudonym> You said the type was String -> Appointment.
00:18:40 <Pseudonym> Hugs says it thinks the type is String -> [Appointment]
00:18:58 <SlushP> Ahh. I'll give that a go.
00:19:03 <Pseudonym> :-)
00:19:10 <SlushP> But I'm guessing it's not the whole of my answer? :) hehe
00:19:22 <Pseudonym> Actually, no.  It is the whole of your answer.
00:19:27 <Pseudonym> As it turns out.
00:19:40 <Pseudonym> This, BTW, is why you put in type declarations.
00:20:01 <Pseudonym> A program has two interpretations: the one you intended, and the one that the compiler inferred.
00:20:13 <Pseudonym> A type error is what happens when the two interpretations don't match.
00:20:20 <SlushP> Ahh.
00:20:40 <Pseudonym> You put in type declarations so that the system has a fighting chance at understanding what _you_ meant.
00:20:51 <SlushP> strToApps "! 10-11 lecture\n12-13 lunch:("
00:20:56 <SlushP> Program error: Undefined
00:20:59 <Pseudonym> Right.
00:21:07 <Pseudonym> That's because you haven't implemented makeAppointmentRecord yet.
00:21:14 <SlushP> :S
00:21:20 <Marvin--> schedule program in haskell? yay :)
00:21:25 <Pseudonym> But you're getting there.
00:21:46 <Pseudonym> More importantly, you're understanding what's going on. :-)
00:21:48 <SlushP> Yeah, it sucks:(
00:21:48 <SlushP> lol
00:21:51 <SlushP> Thanks
00:21:53 <SlushP> :)
00:22:17 <Pseudonym> I have to go soon, BTW, but we'll get you started on this first.
00:22:26 <SlushP> Thanks muchly
00:22:27 <Pseudonym> You have this string.
00:22:33 <Pseudonym> And you have to pull out information from it.
00:22:39 <SlushP> Will I have this done by the time you have to leave? :)
00:22:43 <SlushP> yeah
00:22:44 <Pseudonym> No.
00:22:49 <SlushP> Bugger:(
00:22:52 <Pseudonym> :-)
00:23:04 <Pseudonym> You have to do your own homework, unfortunately.
00:23:05 <SlushP> Ok...let's hurry
00:23:08 <SlushP> hehe
00:23:11 <Pseudonym> OK.
00:23:23 <SlushP> getDuration :: String -> Duration
00:23:24 <SlushP>  getDuration s 
00:23:24 <SlushP> 		| head s == '!'	= ((head . head . tail . words) s, (head . head . tail . words) s)
00:23:24 <SlushP> 		| otherwise	= (head . words) s
00:23:31 <SlushP> I guess I can scrap that
00:23:37 <Pseudonym> Probably.
00:24:25 <Pseudonym> Here's a suggestion.
00:24:26 <SlushP> So, what should I do?
00:24:30 <SlushP> Cool
00:24:45 <Pseudonym> Let's just pull out the importance first.
00:24:56 <Pseudonym> Generally when you're parsing a string, it makes sense to work from left to right.
00:25:08 <SlushP> I'm not sure what you mean by "parsing"
00:25:12 <Pseudonym> The '!' comes first, so deal with that first.
00:25:48 <Pseudonym> In this context, "parsing" means getting information out of the string.
00:25:55 <SlushP> I see.
00:26:07 <SlushP> Ok, well I had "head s == '!
00:26:19 <SlushP> head s == '!' = ....etc.
00:26:22 * Pseudonym nods
00:26:29 <Pseudonym> Here's the second suggestion:
00:27:06 <Pseudonym> Once you've worked out whether there's a '!' in the string or not, you should remove it (if it's there).
00:27:23 <Pseudonym> That way, when you extract the duration information, you don't have to worry about whether or not there's a '!' in front.
00:27:27 <Pseudonym> Because it won't be there.
00:27:34 <SlushP> Remove it? If that's the recommended way, how do i do it?
00:27:35 <SlushP> :S
00:27:37 <SlushP> Sorry man
00:27:52 <Pseudonym> See. you have three pieces of information in the string.
00:28:06 <SlushP> Yeah
00:28:17 <Pseudonym> WHen you need to extract the second piece of information, you should be able to deal with just that part of the string.
00:28:22 <Pseudonym> Not having to worry about what came before.
00:28:37 <SlushP> Ahh I get ya.
00:28:41 <SlushP> So, how do I do that? lol
00:28:54 <Pseudonym> Well, how do you return the string minus the '!'?
00:29:03 <SlushP> tail?
00:29:06 <Pseudonym> Yup.
00:29:19 <Pseudonym> Pretty much.
00:29:50 <Pseudonym> But you only want to do that if the '!" is present.
00:29:56 <Pseudonym> Right?
00:29:58 <SlushP> So, I detect if there's a '!' there, and then remove it. But what about the part in between? Don't I have to do something?
00:30:03 <SlushP> Yeah
00:30:07 <Pseudonym> What is inbetween?
00:30:26 <SlushP> Making the result True.
00:30:27 <SlushP> ?
00:30:30 <SlushP> Or something
00:30:41 <Pseudonym> I thought you were referring to the space.
00:31:01 <SlushP> Well, that too. But I'm guessing we can just use words or somethign:S
00:31:12 <SlushP> Or break isSpace
00:31:19 <Pseudonym> Yeah, I think you want break.
00:31:22 <Pseudonym> Not words.
00:31:35 <Pseudonym> Because you don't want to split the text after the duration into words.
00:31:42 <SlushP> Oh yeah. I forgot words gives you ["word", "word"] etc.
00:31:48 * Pseudonym nods
00:31:59 <Pseudonym> Actually, you could use "break" on the '!', too.
00:32:19 <SlushP> I se.e
00:32:21 <SlushP> see*
00:32:47 <SlushP> So, what do I do in between detecting if there's that '!' and removing it?
00:33:29 <SlushP> Like, how do I make the resulting list of Appointments ((Int,Int), String, True)?
00:33:44 <Pseudonym> Forget that you have to make a list, because you don't.
00:33:49 <Pseudonym> You've already dealt with that.
00:33:55 <Pseudonym> You jsut have to make a single Appointment.
00:33:55 <SlushP> Oh, ok.
00:34:19 <Pseudonym> This is why you decompose your problem. :-)
00:34:28 <SlushP> I see.
00:34:43 <SlushP> Um, what do we do now that we've dealt with the '!'?
00:34:59 <Pseudonym> Well, you know whether or not there's a '!' there.
00:35:06 <Pseudonym> That's head s == '!'
00:35:28 <Pseudonym> You could, for example, write this:
00:35:35 <SlushP> > 		| head s == '!' = tail s 
00:35:37 <SlushP> ?
00:35:38 <SlushP> :)
00:35:54 <Pseudonym> I was thinking of this:
00:36:00 <SlushP> Oh
00:36:01 <Pseudonym> makeAppointment s = ...
00:36:03 <Pseudonym>     where
00:36:09 <Pseudonym>         important = head s == '!"
00:36:21 <Pseudonym>         important = head s == '!'
00:36:21 <Pseudonym> Sorry.
00:36:28 <Pseudonym> Shift key gets you every time.
00:36:32 <SlushP> lol
00:36:55 <SlushP> Okk...
00:36:59 <Pseudonym> What's the type of "important"?
00:37:03 <SlushP> bool
00:37:05 <SlushP> Bool
00:37:07 <Pseudonym> Right.
00:37:14 <Pseudonym> So you could then write, in the where clause:
00:37:21 <Pseudonym>         s2 | important = tail s
00:37:27 <Pseudonym>            | otherwise = s
00:37:30 <Pseudonym> For example.
00:37:35 <SlushP> I see.
00:37:40 <Pseudonym> Or perhaps:
00:37:46 <Pseudonym>         s2 = if important then tail s else s
00:37:58 <SlushP> Cool
00:37:58 <SlushP> If I kept it my way (out of curiousity), how would I do this?
00:37:59 <Pseudonym> Now s2 is the rest of the string.
00:38:13 <SlushP> I mean, using head s
00:38:23 <Pseudonym> I used head s.
00:38:28 <Pseudonym> In the definition of "important".
00:38:53 <Pseudonym>         important = head s == '!'
00:39:05 <SlushP> Yeah, but if I were to save a few lines (maybe), and I just used "head s == '!' = tail s"
00:39:05 <SlushP> ?
00:39:23 <Pseudonym> Ah, but you need that test for two things.
00:39:33 <Pseudonym> 1) You need to know whether or not to chop the head off the string.
00:39:46 <Pseudonym> 2) You need to fill in a field in the Appointment tuple.
00:40:00 <Pseudonym> Presumably you don't want to perform the test twice.
00:40:16 <SlushP> Ahh. I get that. But just going back up a bit, what comes after makeAppointment s = ?
00:40:25 <Pseudonym> Well, what are you returning?
00:40:55 <SlushP> I'm not sure what there should be there since I've just got the "| head s == '!' = tail s" part
00:41:13 <Pseudonym> What are you trying to return?
00:41:32 <SlushP> We're returning Appointment but that's declared on the preceding line.
00:41:53 <Pseudonym> Yes.
00:41:57 <SlushP> Phew
00:41:59 <Pseudonym> So somewhere we need to construct a triple.
00:42:15 <Pseudonym> If I were writing it, that's what I'd put there.
00:42:36 <SlushP> I'm soryr, but I'm lost at this point.
00:42:40 <Pseudonym> makeAppointment s = (something, somethingElse, important)
00:42:52 <Pseudonym> I can't remember what the "something" and "somethingElse" are.
00:43:29 <SlushP> (Duration, Note, Important)
00:43:35 <Pseudonym> Right, so this:
00:43:36 <SlushP> where Duration = int,int
00:43:46 <Pseudonym> makeAppointment s = (duration, note, important)
00:43:48 <Pseudonym>     where
00:43:52 <Pseudonym>          important = ?
00:43:58 <Pseudonym>         duration = ?
00:44:01 <Pseudonym>         note = ?
00:44:09 <Pseudonym> Offside error there, but you get the idea.
00:44:33 <Pseudonym> In your case:
00:44:38 <SlushP> Ahh, ok. Can I just put all this in my code and see what I get?
00:44:39 <Pseudonym>         important = head s == '!'
00:44:46 <Pseudonym> Sure.
00:44:55 <Pseudonym> For now, fill in some dummy values.
00:45:00 <SlushP> Ok
00:45:02 <Pseudonym>         duration = (0,0)
00:45:07 <Pseudonym>         note = ""
00:45:08 <Pseudonym> or something
00:47:22 <SlushP> Um...
00:47:34 <SlushP> what did you mean, or rather, how do I do this:
00:47:34 <SlushP> <Pseudonym> So you could then write, in the where clause:
00:47:34 <SlushP> <Pseudonym>         s2 | important = tail s
00:47:34 <SlushP> <Pseudonym>            | otherwise = s
00:47:51 <Pseudonym> You just stick that in the where clause.
00:48:06 <SlushP> Ok
00:48:07 <Pseudonym> You do know what a where clause is, right?
00:48:12 * Pseudonym is just checking
00:48:16 <SlushP> Yeah
00:48:19 <Pseudonym> Some lecturers use strange terminology.
00:48:33 <SlushP> Oh, but, you've got "where" above. 
00:48:45 <SlushP> Isn't the pipe symbol like a case scenario?
00:48:52 <SlushP> So, do I have where...
00:48:56 <Pseudonym> Yes, it's called a "guard".
00:48:57 <SlushP> and then teh above?
00:49:05 <SlushP> Yeah, that's it:) hehe
00:49:07 <Pseudonym> I suggest using the if-then-else form.
00:49:14 <Pseudonym>         s2 = if important then tail s else s
00:49:17 <Pseudonym> It's less confusing
00:50:17 <SlushP> I think I've got things messed up here. I'll show you what I mean as soon as I get them typed up.
00:50:52 <Pseudonym> OK.
00:50:54 <SlushP> Am I able to paste it here?
00:51:00 <Pseudonym> If it's short.
00:51:00 <SlushP> It's 5 or 6 lines:S
00:51:07 <Pseudonym> Go ahead then.
00:51:09 <SlushP> > makeAppointmentRecord :: String -> Appointment
00:51:09 <SlushP> > makeAppointmentRecord = (Duration, Note, Important)
00:51:09 <SlushP> > 		where Important = head s == '!'
00:51:09 <SlushP> >			s2 | important = tail s
00:51:09 <SlushP> >			   | otherwise = s
00:51:10 <SlushP> >			Duration = (12,3)
00:51:12 <SlushP> >			Note = "lecture"
00:51:18 <Pseudonym> OK.
00:51:24 <SlushP> Those boxes are tabs:) hehe
00:51:26 <Pseudonym> Does that compile?
00:51:55 <SlushP> No, unexpected pipe.
00:52:03 <Pseudonym> Hmmm.
00:52:05 <SlushP> or, "guard" as is the correct term:)
00:52:10 <Pseudonym> You may have some kind of offside problem.
00:52:30 <Pseudonym> As a rule, I generally put the first line of a "where" clause on the line after "where".
00:52:33 <Pseudonym> foo = bar
00:52:35 <Pseudonym>   where
00:52:40 <Pseudonym>     baz = quux
00:52:59 <Pseudonym> Less likely to break the offside rule.
00:53:23 <SlushP> Ok, I'll compile.
00:54:08 <SlushP> It says "no variable defined..."  and is referring to "Note = "lecture""
00:54:18 <Pseudonym> Ah.
00:54:32 <Pseudonym> Hint: identifiers starting with capital letters aren't variables.
00:55:00 <Pseudonym> So, for example, Important isn't a valid variable.
00:55:18 <Pseudonym> When hugs sees "Important" it thinks that's a type constructor, like False.
00:55:26 <Pseudonym> You should start that with a lower case letter.
00:55:29 <SlushP> Hmmm...
00:55:29 <SlushP> Ok
00:55:54 <SlushP> But at the start of the file I've got Important declared to be a Bool
00:56:01 <SlushP> type Important = Bool
00:56:02 <Pseudonym> Yes, but that's a _type_.
00:56:05 <Pseudonym> Not a variable.
00:56:08 <SlushP> Oh, so it's ok?
00:56:16 <Pseudonym> Yes.
00:56:20 <Pseudonym> In fact, it's mandatory.
00:56:26 <Pseudonym> Type names start with capital letters.
00:56:36 <SlushP> Ahh, for all of them - duration and note aswell?
00:56:41 <Pseudonym> Yes.
00:57:05 <SlushP> Bugger it. Now it's telling there's no variable s
00:57:11 * Marvin-- swears at overlapping patterns
00:57:14 <SlushP> No, undefined variable
00:57:30 <Pseudonym> Well where you define "s"?
00:57:58 <Pseudonym> Marvin: Believe me, it's more confusing when you  allow them.
00:58:00 <SlushP> I didn't. And I don't know what to do.
00:58:01 <SlushP> hahaha
00:58:11 <Pseudonym> Well what is "s" supposed to be?
00:58:21 <SlushP> the input parameter
00:58:37 <SlushP> Oh, I got it.
00:58:38 <SlushP> lol
00:58:44 <SlushP> Now I'll try compiling again.
00:59:10 <SlushP> > makeAppointmentRecord s = (Duration, Note, Important)
00:59:19 <Pseudonym> No...
00:59:30 <Pseudonym> Hugs things that Duration is a type constructor there.
00:59:34 <SlushP> Now it's referring to that line and saying "undefined constructor function" :S
00:59:36 <SlushP> Hey?
00:59:36 <Pseudonym> You want a variable.
00:59:48 <Pseudonym> If you have: duration = (12,3)
00:59:58 <Pseudonym> Then you want makeAppintmentRecord s = (duration, ...)_
01:00:01 <Pseudonym> Lower case d.
01:00:48 <SlushP> ok
01:00:54 <Marvin--> Pseudonym: Haskell always has overlapping patterns, aren't you thinking about overlapping instances?
01:01:04 <Pseudonym> Oh, sorry.
01:01:15 <Pseudonym> I thought you were referring to overlapping pattern variables.
01:01:19 * Pseudonym must be tired
01:01:51 <Marvin--> Pseudonym: my problem is that I'm translating haskell programs to first order logic, and the clauses are unordered :)
01:01:59 <Pseudonym> Ah. :-)
01:02:06 <Pseudonym> Well you want my Logic monad.
01:02:20 * Pseudonym is assuming the prolog program is well-moded
01:02:35 <SlushP> Why are we making them lower case though? Aren't they the actual types of teh Appointment type?
01:02:52 <Pseudonym> No, they're variables.
01:03:10 <Pseudonym> Duration is a type.
01:03:12 <Pseudonym> duration is a variable.
01:03:44 <SlushP> And do they relate to the type Appointment?
01:03:45 <Pseudonym> Marvin: http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/hfl/hfl/mtl/
01:03:56 <SlushP> > makeAppointmentRecord :: String -> Appointment
01:03:56 <SlushP> > makeAppointmentRecord s = (duration, note, important)
01:03:57 <SlushP> ?
01:04:02 <Pseudonym> Yeah.
01:04:40 <Marvin--> Pseudonym: um, how does that help me?
01:05:23 <Pseudonym> Suppose your Prolog program is:
01:05:31 <Pseudonym> p(f(X,1)) :- foo.
01:05:38 <Pseudonym> p(f(1,X)) :- foo.
01:05:43 <Pseudonym> Then you can translate it as:
01:05:47 <Pseudonym> p = do
01:05:51 <Pseudonym> Sorry.
01:06:27 <Marvin--> um, I'm translating *from* haskell *to* FOL.. (well, FOL with equality)
01:06:35 <Pseudonym> p arg = (do { (F x 1) <- arg ; foo }) `mplus` (do { F 1 x) <- arg ; foo })
01:06:36 <SlushP> Wow:) It bloody works! 
01:06:40 <Pseudonym> Oh, sorry.
01:06:45 <Pseudonym> Thought you were going the other way.
01:06:47 <SlushP> Thanks so much Pseudonym:)
01:06:51 <Pseudonym> Not a problem.
01:06:53 <Pseudonym> Must go home now.
01:06:54 <Marvin--> Pseudonym: thanks though :)
01:06:57 <Pseudonym> Farewell all.
01:07:11 <Pseudonym> SlushP: You also have s2 now.
01:07:21 <SlushP> Oh
01:07:21 <Pseudonym> You can use that to extract the next piece.
01:07:23 <SlushP> One more thing
01:07:47 <SlushP> Can I get your advice on one more piece?
01:07:47 <SlushP> duration = (12,3)
01:07:47 <SlushP> >			note = "lecture"
01:07:55 <Pseudonym> Right...
01:08:10 <Pseudonym> You get this information from s2.
01:08:28 <Pseudonym> As a big hint: You need to produce "s3".
01:08:36 <SlushP> What do I do to get these variables to hold the data that is got from the input string?
01:08:40 <Pseudonym> If you know what I mean.
01:08:46 <SlushP> I don't get i:(
01:08:48 <SlushP> it*
01:08:50 <SlushP> I'm sorry
01:08:58 <Pseudonym> What's in s2?
01:09:17 <Marvin--> Pseudonym: translating to prolog wouldn't have been a problem since prolog does have ordered clauses, doesn't it? However, I'm translating to a theorem proving format
01:09:18 <SlushP> Um, the list of appointments?
01:09:29 <Pseudonym> Marvin: Right.
01:09:39 <Pseudonym> SlushP: No!  Forget the list of appointments.
01:09:44 <Pseudonym> You only need to produce _one_.
01:09:57 <SlushP> Oh, it's just the data that's outputted.
01:10:03 <Pseudonym> I have a suggestion.
01:10:08 <SlushP> Which means the string WE input doesn't get outputted.
01:10:09 <Pseudonym> Return s2 in the "note" slot.
01:10:10 <SlushP> ?
01:10:18 <Pseudonym> Just temporarily.
01:10:20 <Pseudonym> See what's in there.
01:10:38 <Pseudonym> Then you should be able to work out what to do with it.
01:10:41 <Pseudonym> Gotta go.
01:10:43 <Pseudonym> Bye/
03:54:06 <d33p> can i get someone to help me with some code
03:54:08 <d33p> http://www.chelp.info/upload/code/paste-33.c
03:55:27 <d33p> iam trying to compute Sum i^2 from i to n 
04:00:20 <mgoetze> d33p: sumsquares a n = sum [i^2|i<-[a..n]]
04:00:33 <d33p> :\
04:00:37 <d33p> thats how to do iteration?
04:00:49 <d33p> can i do it recursively.. like the way i was trying?
04:01:07 <mgoetze> TMTOWTDI :)
04:01:27 <d33p> heh, nice
04:01:30 <d33p> what does it mean?
04:01:40 <Marvin--> There's More Than One Way To Do It
04:01:42 <mgoetze> there's more than one way to do it - it's the perl slogan :)
04:01:48 <d33p> aah
04:02:05 <mgoetze> sumrec a n | a == n = n^2
04:02:16 <Marvin--> "Haskell - functional perl without the line noise"
04:02:32 <mgoetze>    | otherwise = a^2 + sumrec (a+1) n
04:02:56 <Marvin--> see if you can write a pointless^H^H^H^Hfree version too ;)
04:03:06 <d33p> okay
04:03:07 <d33p> thanks 
04:05:05 <d33p> i get this error
04:05:10 <d33p> Type checking ERROR "lab1.hs":9 - Type error in application *** Expression : sumsqrs (i + 1,n,s + sqr i) *** Term : (i + 1,n,s + sqr i) *** Type : (Int,Int,Int) *** Does not match : Int 
04:05:20 <d33p> i dont understand why though
04:05:25 <d33p> since i want it to make the function call
04:05:33 <d33p> which should then give an Int 
04:07:05 <mgoetze> d33p: are you, uhm, trying to pass a tuple as the arguments?
04:07:14 <d33p> mgoetze: no
04:07:21 <d33p> mgoetze: did you take a look at the code?
04:07:31 <mgoetze> no, my mouse isn't working :)
04:07:37 <d33p> ahh
04:07:49 <d33p> i could paste, unless people will get pissed off?
04:07:57 <mgoetze> how long?
04:08:03 <d33p> 9 lines
04:08:18 <Marvin--> d33p: sumsqrs(i+1, n, s+sqr(i))  is wrong
04:08:27 <mgoetze> hm, i'd say fix your code first, so that it's the right size, hehe ;)
04:08:30 <Marvin--> you should write  sumsqrs (i+1) n (s+sqr i)
04:08:38 <d33p> Marvin--: oh!
04:08:42 <d33p> lemme try
04:08:51 <Marvin--> d33p: haskell has uncurried argument passing
04:09:00 <Marvin--> (or is it curried, I can never remember which is which)
04:09:13 <Marvin--> curried argument passing is probably it
04:09:20 <mgoetze> yes, i'd say so
04:10:15 <d33p> iam still getting an error
04:10:17 <mgoetze> "+ 1 2" is applying the function + to 1, which returns a function, and then applying (+ 1) to 2
04:10:20 <mgoetze> that's currying
04:10:47 <Marvin--> yeah
04:11:09 <d33p> okay, that was my fault
04:11:12 <d33p> hugs didnt bitch
04:11:15 <d33p> let me try this thing
04:11:36 <d33p> it worked.
04:12:05 <mgoetze> :)
04:12:13 <d33p> many thanks :)
04:29:52 <shapr> goood morning!
04:30:33 <mgoetze> hi shapr!
04:30:38 <shapr> wassup?
04:30:54 <mgoetze> hm, nothing? :)
04:49:24 <Igloo> What should I call a in Maybe a? Type parameter doesn't sound right, and I don't mean type variable
04:53:45 <Igloo> OK, type parameter it is then  :-)
04:53:56 <shapr> I like type parameter
04:54:05 <shapr> hi No0dle
04:54:19 <No0dle> hi
04:54:35 <shapr> the aussie contingent is growing
04:54:41 <No0dle> yes indeed
04:54:56 <norpan> hiya
04:55:00 <shapr> Riastradh: ok, either scandinavian or down under
04:55:01 <No0dle> only caus my uni is using haskell for 1st years 1st semester
04:55:06 <No0dle> as an introduction
04:55:08 <shapr> hej norpan, hur är det med dig?
04:55:10 <No0dle> to CompSci
04:55:16 <norpan> hej shapr
04:55:20 <shapr> No0dle: lucky you, haskell is a great language.
04:55:25 <No0dle> lol
04:55:28 <norpan> yeah
04:55:32 <norpan> you lucky bastard
04:55:37 <No0dle> well seeing as it's purely functional and i go calculus
04:55:43 <No0dle> i like it :
04:55:51 <No0dle> *do
04:56:01 <shapr> I got to use IBM ROM BASIC in my first (only) CS class.
04:56:26 <No0dle> lol
04:56:27 <Igloo> What machine was that on?
04:56:38 <Riastradh> shapr - ?
04:56:42 <No0dle> well next semester, i start Java and never use haskell ever again
04:56:53 <shapr> Riastradh: you said "everyone in #haskell speaks a scandinavian language"
04:57:04 <shapr> Igloo: it was a true blue IBM XT
04:57:06 <Riastradh> Oh.
04:57:12 <Riastradh> What did you mean by 'down under?'
04:57:16 <shapr> .au
04:57:28 <mgoetze> shapr: a germanic language, please :)
04:57:29 <Igloo> I don't
04:57:36 <shapr> mgoetze: ah, good point
04:57:44 <Igloo> Well, not more than "Hei" and "Hej", and I don't know which is which  :-)
04:57:47 * shapr grins
04:58:18 <Marvin--> ARGH
04:58:23 <mgoetze> sup Marvin--?
04:58:43 <Marvin--> I'm working on overlapping pattern matching
04:58:58 <Marvin--> trying to transform the buggars to a non-overlapping equivalent version
04:59:19 <shapr> No0dle: that's too bad, it's a great language.
04:59:25 <No0dle> yeh :(
04:59:50 <shapr> I'm trying to get Haskell into my commercial work.
04:59:55 <Igloo> For what, Marvin?
04:59:55 <shapr> hi Laury 
05:00:15 <No0dle> alright ppl, how do u split a large string "(body of text)" into sentences
05:00:15 <Laury> hi there
05:00:34 <shapr> No0dle: look for punctuation?
05:00:41 <No0dle> :(
05:00:43 <Marvin--> Igloo: for translating it to a language that thinks of the clauses as a set without ordering
05:00:45 <No0dle> what if there is none
05:00:55 <Marvin--> Igloo: e.g. FOL
05:00:56 <No0dle> but there are spaces
05:00:57 <No0dle> and lines
05:00:58 <mgoetze> No0dle: you use perl :)
05:01:04 <No0dle> :(
05:01:14 <shapr> mgoetze: hey, have you added code to lambdabot to check user mode? ;-)
05:01:25 <Igloo> Ah, right - for your course?
05:01:34 <mgoetze> shapr: actually, i haven't even gotten around to looking at the code :)
05:01:38 <shapr> !
05:01:59 <Marvin--> Igloo: for the "master" project, yes
05:02:16 <shapr> No0dle: so cut at the lines?
05:02:38 <shapr> Laury: learning Haskell? or looking for other users?
05:02:46 <No0dle> yeh
05:02:54 <Igloo> That reads so much like you're trying to take over the world  :-)
05:02:55 <No0dle> shapr: how do i cut at the lines
05:03:11 <No0dle> if a whole document is given to me as a large "string"
05:03:27 <No0dle> like say if there is 2x white spaces
05:03:39 <No0dle> split the string into two there
05:03:41 <No0dle> and stuff
05:03:55 <shapr> well, first write a function to cut at single spaces
05:03:59 <shapr> then you'll know how to cut strings
05:04:07 <No0dle> hmm
05:04:12 <shapr> then extend that function to cut at multiple spaces
05:04:30 * Marvin-- goes digging for some articles and stuff
05:04:43 * shapr finds a definite article
05:04:48 <shapr> varorna!
05:05:18 <mgoetze> shapr: it's not finite?
05:05:30 <shapr> nope, it's specifically those things.
05:06:00 <No0dle> shapr: can u point me to where examples of this cut function exist on the web
05:06:09 <No0dle> or where i can obtain know how to write it myself
05:06:13 <No0dle> (on the web)
05:07:28 <shapr> you could read about lists and strings in Haskell.
05:07:51 <No0dle> ok
05:07:54 <No0dle> well thanks anyway
05:10:37 <Marvin--> dang, this paper doesn't seem to be online
05:11:42 <Marvin--> "Pour obtenir la version papier"? Damn inria :-)
05:11:53 <Marvin--> they want me to mail them about getting a paper version?
05:12:13 <shapr> looks like it
05:12:16 <shapr> quelle dommage
05:13:25 <SlushP> Can someone tell me how I get the 10-13 to be represented as 10,13 in " 10-13 lecture"?
05:13:49 <shapr> ?
05:13:56 <shapr> you want to parse it?
05:14:00 <shapr> or just replace a character?
05:14:04 <SlushP> parse it
05:14:47 <shapr> I've had good experiences using Parsec
05:15:10 <shapr> it even has calculator in the tutorial that you could modify to do that, I think
05:15:22 <SlushP> I've taken the space out - (break isSpace . tail) " 10-11 lecture"
05:15:31 <SlushP> so it looks like ("10-11"," lecture")
05:15:48 <SlushP> but, how do i get it to display 10,11 ?
05:16:13 <shapr> in that case, you could break on (=='-') and then use read :: Int
05:17:37 <SlushP> How do I write that? break == '-'?
05:18:26 <shapr> do you know what parameters the break function wants?
05:18:42 <SlushP> one?
05:18:50 <SlushP> oh, it wants a predicate.
05:19:03 <SlushP> sorry, didn't read your question properly:)
05:19:17 <shapr> :-)
05:19:50 <shapr> do you know how to write a predicate?
05:20:03 <SlushP> yeah, but not in this sense:S
05:20:20 <SlushP> hang on, is it "break (=='-') ..." ?
05:20:21 * Marvin-- tries to wrap his head around the mathematical definitions of patterns, pattern matching and partially evaluated values
05:20:32 <shapr> SlushP: try it
05:20:48 <shapr> you've used one predicate already, isSpace
05:20:51 <shapr> do you know how it works?
05:21:50 <shapr> @searchml predicate
05:22:12 <SlushP> Planner> break (=='-') " 10-11 lecture"
05:22:12 <SlushP> (" 10","-11 lecture")
05:22:15 <SlushP> That didn't work:(
05:22:35 <shapr> looks like it did to me.
05:22:41 <SlushP> I need it to be (10,11, "Lecture")
05:23:37 <shapr> it looks to me like you have several small pieces that you could sew together to get the result you want.
05:23:55 <SlushP> Can how help me answer the "how" ? :)
05:24:08 <shapr> huh?
05:24:42 <SlushP> I don't get your previous comment. How do I get my small pieces of code to work together to get the desired result?
05:25:18 <lambdabot> 1939 1573 1264 1103 1102 216
05:25:32 <shapr> you start out with a string
05:25:38 <shapr> you can break that string into pieces
05:25:43 <shapr> those pieces are strings
05:25:57 <shapr> you can break those strings differently into pieces
05:26:40 <shapr> SlushP: does that help?
05:26:47 <SlushP> I've tried using isSpace, isDigit, head, tail, last, etc etc etc and nothing is working the way I want:(
05:27:31 <SlushP> > makeAppointmentRecord :: String -> Appointment
05:27:31 <SlushP> > makeAppointmentRecord s = (duration, note, important)
05:27:31 <SlushP> > 		where 
05:27:31 <SlushP> >			important = head s == '!'
05:27:31 <SlushP> >			s2 | important = tail s
05:27:31 <SlushP> >			   | otherwise = s
05:27:33 <SlushP> >			s3 | duration = break (== '-' s2)
05:27:35 <SlushP> >			note = tail s2
05:27:42 <SlushP> duration is my problem.
05:28:11 <SlushP> I want to get the numbers out of the string, from 10-11 format, to 10,11
05:28:20 <shapr> yes, I am aware of that :-)
05:28:29 <SlushP> Because type Duration is (Int,Int)
05:28:30 <SlushP> Oh.
05:28:41 <SlushP> Sorry, I have been working on this for ages:(
05:29:11 <shapr> the first steps in a language are difficult and frustrating, but it gets easier if you make it past the frustrating stage.
05:29:35 <shapr> it even gets into real fun.
05:29:59 <SlushP> Ok, well can you help me work this problem of mine out? Please:)
05:30:15 <shapr> I'm trying to help you with this problem without doing your homework for you....
05:30:40 <SlushP> Yeah, that's all I want.
05:30:48 <SlushP> But it doesn't just come to me:(
05:31:26 <shapr> do you know how to turn the string "10-11" into "10","11" ?
05:31:46 <SlushP> No
05:31:58 <shapr> how close can you get?
05:32:01 <SlushP> The closest I got was that one from above.
05:32:10 <SlushP> break (=='-') " 10-11 lecture"
05:32:13 <shapr> can you get from that one above to this one?
05:32:25 <SlushP> but the result was still only (" 10","-11 lecture")
05:32:36 <shapr> what if you combine the one above with the first one you showed me?
05:32:47 <SlushP> there's a space in from of the "10" too.
05:33:21 <SlushP> Um, wasn't that the only one I showed you? :S
05:34:47 <shapr> @searchml predicate
05:34:48 <lambdabot> 1939 1573 1264 1103 1102 216
05:34:51 <shapr> @showml 1939
05:34:51 <lambdabot> Andreas Abel wrote:
05:34:51 <lambdabot> > Well, sorting is a special case of permuting, so my idea was to use the library
05:34:51 <lambdabot> > routine
05:34:51 <lambdabot> > 
05:34:51 <lambdabot> >    List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
05:34:52 <lambdabot> > 
05:35:01 <shapr> @showml 1573
05:35:01 <lambdabot> On 24-Jan-2003, Norman Ramsey <nr@eecs.harvard.edu> wrote:
05:35:01 <lambdabot> > In a fit of madness, I have agreed to deliver a 50-minute lecture
05:35:01 <lambdabot> > on type classes to an audience of undergraduate students.  These
05:35:01 <lambdabot> > students will have seen some simple typing rules for F2 and will
05:35:02 <lambdabot> > have some exposure to Hindley-Milner type inference in the context
05:35:04 <lambdabot> > of ML.  I am soliciting advice about
05:35:35 <SlushP> Shapr: (break isSpace . break (=='-') . tail) " 10-11 lecture"
05:35:40 <SlushP> is that what you meant? 
05:35:54 <shapr> what does that give you?
05:35:59 <SlushP> Error:(
05:36:11 <shapr> what's the error?
05:36:17 <SlushP> *** Term           : break isSpace
05:36:17 <shapr> @searchml homework
05:36:17 <SlushP> *** Type           : [Char] -> ([Char],[Char])
05:36:17 <SlushP> *** Does not match : ([Char],[Char]) -> ([Char],[Char])
05:36:18 <lambdabot> 2129 1641 1614 1215 464 248 246 162 158
05:36:31 <shapr> SlushP: what does that tell you?
05:36:55 <SlushP> Something has screwed up:)
05:36:57 <SlushP> no...
05:36:59 <SlushP> um...
05:37:07 <shapr> truly :-)
05:37:31 <SlushP> My output is different to what it's expecting
05:37:45 <SlushP> :S
05:37:49 <shapr> what's the difference between the two?
05:37:55 <shapr> can you make them match?
05:38:13 <SlushP> Well, I get confused between the 2. is the bottom the one that reflects mine?
05:39:29 <SlushP> I mean, is the bottom one, the one that reflects what I'm "TRYING" to output?
05:41:36 <SlushP> I've tried changing them around, but I still get the same error.
05:41:45 <SlushP> I'm not sure how to match them:(
05:41:47 <shapr> SlushP: you can find out the type of something in hugs or ghc by putting :t in front of it
05:42:15 <SlushP> the type of which one? break?
05:42:36 <SlushP> Planner> :t isSpace
05:42:36 <SlushP> isSpace :: Char -> Bool
05:42:36 <SlushP> Planner> :t break
05:42:36 <SlushP> break :: (a -> Bool) -> [a] -> ([a],[a])
05:42:56 <shapr> so, what does that tell you?
05:43:25 <shapr> you can go further with that also
05:43:28 <shapr> Prelude> :t break (=='-')
05:43:28 <shapr> [Char] -> ([Char], [Char])
05:43:55 <SlushP> hmmm...oook
05:44:03 <SlushP> But what am I missing? :S
05:44:13 <SlushP> I must have tried everything:(
05:44:19 <shapr> you're getting closer
05:45:00 <shapr> what's the output type of break isSpace ?
05:45:07 <shapr> try :t break isSpace
05:45:19 <SlushP> Where am I going wrong exactly? Or what should i be thinking about? Because I can't use two breaks in the one statement.
05:45:36 <shapr> what's the input type of "break (=='-')" ?
05:46:01 <shapr> you can use two breaks in one statement, as long as you feed them the right things.
05:46:14 <SlushP> Planner> :t break (=='-')
05:46:14 <SlushP> break (flip (==) '-') :: [Char] -> ([Char],[Char])
05:46:21 <SlushP> WTf?
05:46:41 <SlushP> I don't have a clue what that is...but I'm guessing it's further away from my answer.
05:46:55 <shapr> try :t break ('-'==)
05:47:19 <SlushP> break ('-' ==) :: [Char] -> ([Char],[Char])
05:47:26 <shapr> so, what does that say?
05:47:30 <shapr> what does it want as input?
05:47:37 <SlushP> A string?
05:47:40 <shapr> yes
05:47:45 <shapr> what does it give as output?
05:47:51 <SlushP> Two strings?
05:48:03 <shapr> yes, and the two strings are wrapped in what?
05:48:16 <SlushP> Gladwrap?
05:48:18 <SlushP> lol. Sorry
05:48:20 <shapr> sort of
05:48:21 <shapr> :-)
05:48:22 <SlushP> Umm...
05:48:31 <SlushP> The parentheses? :S
05:48:35 <shapr> yes!
05:48:39 <shapr> what do you call the parentheses?
05:48:49 <SlushP> brackets
05:48:55 <shapr> well, in Haskell language :-)
05:49:05 <SlushP> umm...I don't remember:(
05:49:11 <shapr> (something,something)
05:49:14 <shapr> it's called a tuple
05:49:32 <SlushP> Oh
05:49:42 <SlushP> Umm...that didn't work.
05:49:50 <SlushP> Planner> (break ('-'==)) " 10-11 lecture"
05:49:50 <SlushP> (" 10","-11 lecture")
05:49:52 <shapr> so, one break takes in a string, and puts out a pair of strings that are in a tuple
05:50:13 <shapr> what if you want to run another break on one of the strings in the output tuple?
05:50:24 <shapr> how can you get the strings out of the tuple?
05:50:57 <SlushP> I really don't know...not to either of those questions:(
05:50:59 <SlushP> I'm sorry
05:51:07 <shapr> if it's a tuple of length 2
05:51:15 <shapr> you can use the handy functions fst or snd
05:51:18 <Marvin--> also known as "pair" ;)
05:51:22 <shapr> can you guess what they're short for?
05:51:40 <SlushP> first and second
05:51:44 <shapr> yes, exactly
05:51:47 <SlushP> Oh, yeah;)
05:51:50 <Igloo> It's probably going to be easier to have
05:51:55 <SlushP> I'll give that a go...if I know what I'm doing.
05:52:04 <Igloo> let (a, xs1) = break ... xs
05:52:11 <Igloo>     (b, xs2) = break ... xs1
05:52:14 <Igloo> etc
05:52:16 <shapr> yes, I would use the code from Igloo :-)
05:52:34 <shapr> a let statement can 'unpack' a tuple into variables
05:52:41 <SlushP> Let's not confuse me...I'm using Hugs (if that's what you are referring to)
05:53:09 <Igloo> Are you writing code in a file or at the hugs prompt?
05:53:22 <Igloo> You're about to get big enough (either way) that you'll want to use a file
05:53:28 <SlushP> Planner> (fst . break ('-'==)) " 10-11 lecture"
05:53:28 <SlushP> " 10"
05:53:48 <SlushP> I've still got the space in front of it:( And, when I do snd, I get "-11 lecture"
05:53:59 <Marvin--> dropWhile isSpace
05:54:18 <SlushP> lol
05:54:19 <SlushP> Great
05:54:37 <SlushP> The first half works - ie. the 10
05:54:38 <SlushP> lol
05:55:26 <Marvin--> to get the 11 you could do  takeWhile (not . isSpace) (tail ...)
05:55:27 <SlushP> but, how do I go about doing the second half? And, so they'll be together (Int,Int)?
05:55:30 <SlushP> Oh
05:55:32 <Marvin--> but you really need to put this in a file
05:56:07 <SlushP> So how do I get them to be together - 10,11? And not "10" and then "11" somewhere else.
05:56:07 <SlushP> ?
05:57:12 <Marvin--> use local variables with let or where
05:57:59 <SlushP> Planner> takeWhile (not . isSpace) (tail " 10-11 lecture")
05:57:59 <SlushP> "10-11"
05:58:17 <SlushP> Any way of now getting it to be (10,11) now? :)
05:58:38 <shapr> split it at the dash
05:58:42 <shapr> and use read
05:59:18 <SlushP> To split at dash, i wrote:
05:59:19 <SlushP>  break (=='-') . takeWhile (not . isSpace) (tail " 10-11 lecture")
05:59:30 <SlushP> *** Type           : [Char]
05:59:31 <SlushP> *** Does not match : a -> b
05:59:38 <shapr> what does the dot do?
06:00:00 <SlushP> performs functions from right to left
06:00:01 <SlushP> :S
06:00:24 <shapr> and what's the function you want to have on the left?
06:00:39 <SlushP> break?
06:00:52 <SlushP> or maybe "read" when I get to it
06:01:38 * arguile gasps in amazement
06:01:46 <shapr> SlushP: what's the order of operations in that line you just pasted?
06:01:49 <shapr> arguile: hi there.
06:02:04 <shapr> arguile: wanting to learn Haskell? or looking for other users?
06:02:06 <arguile> Life!?! In #haskell? And within 10hours of joining! =P
06:02:16 <Marvin--> arguile: don't be mean :P
06:02:27 <SlushP> takeWhile there isn't a space. 
06:02:33 <arguile> I'm not being mean, I'm just astounded :)
06:03:02 <SlushP> take the characters while there isn't a space. 
06:03:04 <SlushP> :)
06:03:05 <SlushP> ?
06:03:12 <arguile> Ohhh.. haha, I joined on a diff server
06:03:31 <Marvin--> arguile: *LOL*
06:03:36 <arguile> nm me, I've been up for ages
06:04:20 <shapr> SlushP: I have to have a meeting, but you need to change that dot to something else
06:04:34 <SlushP> ???
06:05:00 <shapr> I'll be back later.
06:05:06 <SlushP> :(
06:05:17 <SlushP> You coudlnt' just paste the word?
06:05:19 <SlushP> hehe
06:05:41 <shapr> if I did your homework for you now, what would you do on the test?
06:05:52 <SlushP> Well, I really am trying:)
06:05:58 <arguile> Sneak in a PDA w/ inet access?
06:05:58 <SlushP> I've been trying to do it for 2 days:(
06:05:58 <shapr> I agree :-)
06:06:14 <SlushP> lol
06:07:30 <SlushP> I honestly don't have a clue what to use. I've tried using parentheses instead of the dot...but of course that's not right. But I don't know what else to us.
06:07:34 <SlushP> use*
06:09:00 <SlushP> Can anyone else give me any hints or whatever to help me work out what I'm supposed to use instead of the dot operator?
06:09:02 <arguile> SlushP: You have the problem up on a sratchpad/pasteboard?
06:09:16 <SlushP> Umm, no:(
06:09:54 <arguile> http://www.pastebin.com/, then you can refer to it by url
06:10:50 <arguile> (Just ignore the fact it's for some other language, it's the only one I can ever remeber the URL of :)
06:12:51 <SlushP> http://www.pastebin.com/6306
06:13:26 <SlushP> Marvin: are you able to help me also, specifically with what I'm supposed to use instead of the dot?
06:13:39 <SlushP> in...
06:13:39 <SlushP> break (=='-') . takeWhile (not . isSpace) (tail " 10-11 lecture")
06:15:22 <SlushP> Anyone? :(
06:16:22 <Marvin--> SlushP: function application binds harder than operators (and . is an operator) so you can't say   f . g . h x  you have to say  (f . g . h) x
06:16:39 <Marvin--> or  f . g . h $ x  ($ is application, but binds looser)
06:16:59 --- mode: ChanServ set +v Janni
06:17:25 <Janni> hellas!
06:18:24 <arguile> Personally I'd do a lambda abstraction
06:18:34 <SlushP>  (break (=='-') . takeWhile (not . isSpace) . tail) " 10-11 lecture"
06:18:41 <SlushP> ("10","-11")
06:18:54 <SlushP> Now I've still gotta get rid of that -
06:18:54 <SlushP> :(
06:19:06 <mgoetze> hi Janni :)
06:22:17 <arguile> SlushP: Just do the same again, paren the outer.. or you can do it in multiple steps
06:22:45 <arguile> While function application is great, sometimes it can reduce legibility quite a bit
06:22:45 <Marvin--> SlushP: I keep telling you, put this in a file so you can do it in multiple steps
06:23:47 <SlushP> I don't know how to put it into a file as such. Unless you mean what I'm going to be putting this into when I work out how to do it:)
06:23:58 <SlushP> LIke what I posted on:
06:24:01 <SlushP> http://www.pastebin.com/6306
06:25:09 <SlushP> Arguile: is this kind of how you meant: 
06:25:26 <SlushP> (break (=='-') . break (=='-') . takeWhile (not . isSpace) . tail) " 10-11 lecture"
06:25:26 <SlushP> ?
06:25:36 <SlushP> I'm not sure what you mean.
06:27:03 <Marvin--> actually, I'd use  words " 10-11 lecture" to get ["10-11","lecture"] and then break (=='-') on the first element
06:29:07 <SlushP> Arguile: I'm not sure what you mean. Can you tell me what you mean?
06:29:37 <SlushP> Marvin: I think I'll just go the way I'm going. I've done with it for this long:) hehe
06:30:11 <Marvin--> SlushP: the point is that if you put it in a file, you can assign temporary variables to things so it's easier to read
06:30:28 <SlushP> http://www.pastebin.com/6306
06:30:38 <Marvin--> sort of... stripped = takeWhile (not . isSpace) (tail "....")  and then  (a,b) = break (=='-') stripped  et.c.
06:30:40 <SlushP> Can you tell me how i'd do that? My code is there.
06:31:36 <SlushP> Planner> (break (=='-') . takeWhile (not . isSpace) . tail) " 10-11 lecture"
06:31:37 <SlushP> ("10","-11")
06:31:53 <Marvin--> yes, yes, yes, but I'd use temporary variables to simplify it
06:31:58 <SlushP> I've got that...so how can I just remove the "-" and the quotes? :(
06:32:28 <SlushP> Marvin: would you look at my code at the above address so you can tell me how you mean because I wouldn't know HOW.
06:33:13 <Marvin--> how's this?
06:33:36 <Marvin--> er, modulo some '.' stuff and so
06:33:49 <Marvin--> http://www.pastebin.com/6308
06:34:55 <Marvin--> actually, look at 6311 instead
06:38:17 <SlushP> Well, it looks good, but it's stuffed up my recursion side of things. It doesn't let me anymore to have multiple strings separated by \n
06:38:33 <SlushP> eg. "! 10-12 Lecture \n 12-13 Go home"
06:38:51 <SlushP> Planner> strToApps "! 10-13 Lecture\n1-4 Go home"
06:38:52 <SlushP> [((10,3),"note",True),((
06:38:52 <SlushP> Program error: Prelude.read: no parse
06:40:24 <Marvin--> well, that's not strange, the second line has no leading space, so using tail is broken
06:40:39 <SlushP> Is there a quick way to fix that?
06:40:43 <Marvin--> that's why I wanted to use dropWhile isSpace instead, or for simplicity, words
06:42:24 <arguile> Or even better, use the regexp lib in GHC ;)
06:42:50 <SlushP> Marvin: are you able to fix this up? please:)
06:43:33 <Marvin--> SlushP: hey, I think the hint "replace tail" with "dropWhile isSpace" is quite enough
06:44:22 <SlushP> I wish it was...but it doesn't work either.
06:44:39 <arguile> SlushP: Do you have Haskell: The Craft of Functional programming?
06:45:11 <SlushP> Yeah, and I've read it:)
06:45:12 <SlushP> lol
06:45:16 <SlushP> Planner> strToApps "! 10-13 Lecture\n 1-4 Go home"
06:45:16 <SlushP> [((10,3),"note",True),((1,
06:45:16 <SlushP> Program error: Prelude.read: no parse
06:45:22 <arguile> An intro to parsers is in there, one sec I'll get you the page reference
06:45:35 <SlushP> I've got it open to page 42 - isDigit hehehe
06:45:59 <arguile> Go to 128
06:46:10 <SlushP> Any other ideas Marvin? i want to head to bed:(
06:46:11 <SlushP> Ok
06:46:16 <arguile> There's an extended example on simple text processing
06:46:21 <arguile> It's a great into
06:46:25 <arguile> s/into/intro/
06:47:46 <arguile> The example then continues ~Pg. 164
06:48:40 <arguile> Then again at Pg. 186
06:48:53 <arguile> Between those you shouldn't have any problems
06:48:58 <SlushP> Can someone just help me get this little error working? please? Reading is the last thing I want to do at the moment. I'm so tired and I've to get up again in 5 hours:(
06:49:21 <arguile> And have much better reasoning about it then we're likely to provide over IRC 
06:49:27 <SlushP> I've been working on this for 2 days straiht, and i'll leave if someone could just fix up this little problem of having to read 2 strings:(
06:52:15 <SlushP> I honestly won't find what I need to add to my code just to make it read another string? :S
06:52:33 <shapr> it's in the book.
06:52:33 <SlushP> Pretty please? just as a last token of your gratitude? :)
06:53:38 <SlushP> > makeAppointmentRecord :: String -> Appointment
06:53:38 <SlushP> > makeAppointmentRecord s = (duration, note, important)
06:53:38 <SlushP> > 		where 
06:53:38 <SlushP> >			important = head s == '!'
06:53:38 <SlushP> >			s2 | important = tail s
06:53:38 <SlushP> >			   | otherwise = s
06:53:40 <SlushP> >            		duration = (read a, read (tail b)) 
06:53:42 <SlushP> >           		note = "note"
06:53:44 <SlushP> >           		(a,'-':b) = (break (=='-') . takeWhile (not . isSpace) . dropWhile isSpace) s2 
06:54:02 <SlushP> Ok, where in the book is the answer to this problem:
06:54:03 <SlushP> Planner> strToApps "! 10-13 Lecture\n 1-4 Go home"
06:54:03 <SlushP> [((10,3),"note",True),((1,
06:54:03 <SlushP> Program error: Prelude.read: no parse
06:54:51 <SlushP> ? If you could tell where abouts I'll find what my problem is, I'll be happy to fix it up.
06:55:02 <shapr> arguile: cute nickname, does that mean you're an underhanded diamond patterned sock?
06:55:29 <SlushP> Can you just give me this last bit of assistance so i can rest in peace for 5 hours?
06:55:30 <SlushP> please:)
06:55:43 <arguile> shapr: Very close :)
06:56:54 <shapr> arguile: have you posted to the Haskell mailing list before?
06:57:11 <SlushP> Anybody? please???
06:57:37 <SlushP> I just want to go to bed...but I really want to get this done though
06:58:07 <arguile> No, I've only somewhat recently started using it for anything other than fun (was a Schemer for years though)
06:58:26 <shapr> The latest toy here on #haskell is lambdabot 
06:58:30 <shapr> @fact source
06:58:30 <lambdabot>  http://sf.net/projects/haskell-libs/, http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/lambdabot/
06:59:07 <SlushP> Please someone? :(
06:59:19 * arguile sighs
06:59:37 <shapr> SlushP: c'mon, you were even given a page number.
06:59:46 <arguile> First calls lines on it so you can deal with it as an array of lines
06:59:50 <SlushP> But none answers teh problem i'm having.
06:59:59 <SlushP> I have.
07:00:08 <SlushP> > strToApps :: String -> [Appointment]
07:00:08 <SlushP> > strToApps s = [ makeAppointmentRecord l | l <- lines s ]
07:00:09 <arguile> Then call words, see if the first element is !
07:00:19 <shapr> the idea of homework is that you have to figure out the answers from the building blocks you're given.
07:00:23 <SlushP> > makeAppointmentRecord :: String -> Appointment
07:00:23 <SlushP> > makeAppointmentRecord s = (duration, note, important)
07:00:23 <SlushP> > 		where 
07:00:23 <SlushP> >			important = head s == '!'
07:00:23 <SlushP> >			s2 | important = tail s
07:00:24 <SlushP> >			   | otherwise = s
07:00:26 <SlushP> >            		duration = (read a, read (tail b)) 
07:00:26 <shapr> the idea is not just to finish the homework correctly
07:00:28 <SlushP> >           		note = "note"
07:00:30 <SlushP> >           		(a,'-':b) = (break (=='-') . takeWhile (not . isSpace) . dropWhile isSpace) s2 
07:00:47 <shapr> the idea is that you learn how to solve problems from the pieces you're given
07:00:47 <SlushP> But I'm trying to learn, but I find this every difficult to grasp:(
07:01:40 <shapr> because that's something someone else can't tell you how to do
07:01:50 * shapr wonders if that sentence parsed correctly.
07:02:34 <SlushP> I just want someone to tell me how to fix up this code that Marvin wrote, because it's not doing what it originally did - that being to accept multiple strings.
07:02:43 <SlushP> I will leave you all alone then:) PLease???
07:02:51 <SlushP> I beg you...ALL:)
07:02:55 <shapr> why?
07:03:02 <shapr> it would be less work for you to figure it out yourself.
07:04:07 <mgoetze> SlushP: we don't want to be left alone, we want you to learn haskell :)
07:04:14 <shapr> yes, truly
07:04:26 <SlushP> less work? Marvin gave me code, which was good in that it did was it was supposed to, except for not accepting mulitple strings:(
07:04:48 <SlushP> All I want ("all"...sorry) is for someone to tell me what I do to fix up that so it'll allow what it used ot.
07:04:49 <SlushP> to*
07:05:00 <SlushP> Please please please. 
07:05:26 <SyntaxPolice> morning all.
07:05:28 <shapr> SlushP: d00d, take it somewhere else.
07:05:32 <mgoetze> hi SyntaxPolice 
07:06:18 <shapr> y0 SyntaxPolice 
07:08:13 <SyntaxPolice> shapr: mgoetze: how's it going?
07:08:45 <shapr> I have all the things I need, and then some. Life is good!
07:08:50 <shapr> how are you?
07:09:26 <SyntaxPolice> shapr: word. Life is good, isn't it.
07:09:46 <shapr> Yah
07:10:02 <shapr> I've been unable to figure out what your lambdabot plugin hint is about.
07:10:03 * andersca bounces
07:10:06 * shapr boings
07:11:40 <shapr> arguile: Have any questions about Haskell? Anything we can do for you?
07:12:00 <SlushP> This is bloody crap!
07:12:08 * Marvin-- gets inspired to write a pastebin that's not php specific
07:12:18 <Marvin--> gotta love enscript --language=html -E  :-)
07:12:18 <shapr> Marvin--: what's a pastebin?
07:12:26 <Marvin--> shapr: www.pastebin.com
07:12:35 <SlushP> I've read those bloody pages and nothing has worked:S
07:12:40 --- mode: ChanServ set +o shapr
07:14:25 <SlushP> Why can't you guys "help" me do this? I've not once asked you do just give me the answer - i've asked "HOW" things work etc.
07:14:25 <SlushP> And explained to you my knowledge. And I admit I don't follow half of this crap, but I'm in desperate need of help:(
07:14:50 <shapr> You have asked us to give you the answer.
07:15:16 <shapr> if you understand the pieces that you have, you will know how to do it.
07:16:04 <shapr> Any more requests for us to give you the answers to your homework, and I will remove you from the channel.
07:17:41 <arguile> SlushP: Seriously, Pg. 129-130 has exactly what you want. All you need to do is change the whitespace to some other character (think '-')
07:18:08 <arguile> It's not the most elegant or efficient way, but it's easily understood and has a good explanation as to why it works
07:19:53 <shapr> Marvin--: pastebin == lambdabot + hws-wp integration :-)
07:20:20 <arguile> SlushP: You already know (d:note) = words "1-2 foo"; just add duration = split d
07:20:40 <arguile> Or generalise split to splitOn ch st.. it's all there
07:20:42 <SlushP> Not straight out...I've accepted all your information but I just don't get it.
07:21:11 <Marvin--> shapr: oh go away :)
07:21:23 * shapr grins evilly
07:21:24 <Marvin--> I'm starting to seriously dislike pattern matching *siiigh*
07:21:45 <arguile> SlushP: That's why I referred you to the book
07:21:58 * arguile likes parser generators and regexps
07:22:42 <arguile> If I can't express it in BNF and get something to do the work for me, it's obviously not worth matching =P
07:24:07 <SlushP> That's exactly the point! I don't get it!
07:24:07 <SlushP> If I could do it, do you thihk I'd be spending this long "expecting" you guys to do it for me?!
07:24:07 <SlushP> Arguile: what part of my code are you referring to?
07:24:07 <SlushP> Seeing that I DON'T understand much of this, I have to ask questions!
07:24:07 <SlushP> Surely you'd do the same if you didn't understand something.
07:24:33 <Smerdyakov> If this is for a class, you should ask an instructor.
07:24:55 <arguile> SlushP: I was referring to the app handling bit, specifically duration and notes
07:24:56 <shapr> When I don't understand something, it's because my mental model doesn't fit the thing itself. So I try to get to the point where my mental model does fit the thing itself.
07:24:58 <SyntaxPolice> shapr: I'm good. work is pretty fun.  I'm doing some more strictly AI type stuff lately.
07:26:17 <shapr> hi Smerdyakov, what's up?
07:27:12 <mgoetze> shapr: be careful where you point that @, it's loaded ;)
07:27:18 * shapr grins
07:28:11 <Marvin_> grr
07:29:03 <Janni> roar!
07:29:07 <shapr> wheee
07:29:31 * mgoetze gives shapr a trampoline.
07:29:39 * shapr sproings happily
07:30:37 --- mode: ChanServ set +v Marvin--
07:31:46 <shapr> @loaded
07:31:46 <lambdabot> Sorry, I don't know the command "loaded", try "lambdabot: @listcommands"
07:36:32 <arguile> Anyone know any good references for O'Haskell? I'm intrigued.
07:37:07 --- mode: brunner.freenode.net set +vv SyntaxPolice dennisb
07:38:10 <shapr> arguile: I don't know anything other than the actual website
07:38:14 <shapr> @fact o'haskell
07:38:14 <lambdabot> Nothing
07:38:38 <shapr> @fact o'haskell http://www.math.chalmers.se/~nordland/ohaskell/
07:38:38 <lambdabot> set o\'haskell to http://www.math.chalmers.se/~nordland/ohaskell/
07:39:19 <shapr> It has some nifty features.
07:39:38 <shapr> Someone was here lately considering implementing O'Haskell for GHC as their master's project
07:40:13 <arguile> The website would be great if I had more time, but alas... I don't get paid to do Haskell
07:40:59 --- mode: mgoetze set -o shapr
07:40:59 --- mode: ChanServ set +o shapr
07:41:09 <mgoetze> bad ChanServ!
07:41:13 <SyntaxPolice> heh
07:41:15 <arguile> Are you at Glasgow?
07:47:53 <shapr> not me
07:47:59 <shapr> I'm self-employed.
07:48:15 <SyntaxPolice> huh. SlushP quit... strange.
07:48:22 <shapr> I didn't do it!
07:48:47 <mgoetze> shapr: quick, hide the @! the police might come looking for you!
07:48:56 --- mode: shapr set -o shapr
07:49:08 <ludde> eh?
07:49:11 * shapr dunno
07:49:24 <SyntaxPolice> the closest I ever came to kicking someone was threatening to kick his annoying bot. that alone made him leave the channel and never come back.
07:49:28 <shapr> arguile: I don't get paid to do Haskell either, but I hope to!
07:49:39 <SyntaxPolice> actually, I did kick his bot, but it auto rejoined, so I threatened to ban his bot.
07:49:49 <shapr> SyntaxPolice: you have kick/ban privs btw
07:50:43 <SyntaxPolice> +v does that?
07:51:03 <shapr> arguile: I'm both recruiting and coding for sf.net/projects/haskell-libs/ in hopes of getting more good libraries for Haskell.
07:51:21 <shapr> SyntaxPolice: chanserv settings
07:51:53 <SyntaxPolice> OK.
07:53:17 <shapr> hi pesco!
07:53:23 <pesco> hey shapr!
07:53:26 <shapr> wassup?
07:53:53 <pesco> I decided to tar up the PPC GHC with a broken GHCi.
07:54:00 <shapr> fair enough
07:54:04 <pesco> Yup.
07:54:20 <shapr> it's a good step forwards for GHC on ppclinux
07:54:22 <pesco> And I glanced over the runtime linker stuff.
07:54:33 <shapr> what do you think?
07:54:36 <pesco> I think it smells bad.
07:54:39 <shapr> how so?
07:54:54 <shapr> cool, haskell-libs is/was at 89% activity 
07:55:05 <pesco> It's just an interface to the GHCi runtime linker.
07:55:14 <shapr> yup
07:55:29 <pesco> Which smells bad, because of its mere existence.
07:55:36 <shapr> Is there a better way?
07:56:01 <pesco> I am failing to see why one would not use dlopen.
07:56:03 <Janni> What about "instance Bits [Bool]"? Is that Haskell98 conformable?
07:56:31 <pesco> Janni: What do you mean by conformable?
07:57:00 <shapr> wow, haskell-libs is ranked 1048th most active project right now.
07:57:08 <Janni> I mean: conform
07:57:26 <pesco> Janni: Yes. Why wouldn't it?
07:57:38 <Janni> Or: Is that correct? It seems that hugs doesn't accept it
07:58:06 <pesco> Janni: You did include definitions for the functions in class Bits, right?
07:58:35 <Janni> yes. It's not my program but a library which works fine with ghc(i)
07:59:01 <pesco> Janni: Hm, I don't see a problem with the line you gave in principle. Is it really than one or maybe one of the function defs?
07:59:16 <pesco> Janni: What's the error you get from Hugs?
07:59:32 <Janni> Syntax error in instance head (variable expected)
07:59:57 <pesco> Erm.
08:00:17 <pesco> Maybe it's just not seeing class Bits. Do you have the imports right?
08:00:47 <Janni> instance Show [Bool] where show xs = "muhahaha"  gives me the same error
08:01:22 <pesco> Ugh
08:01:58 <pesco> I don't know.
08:02:16 <Janni> The same goes for:
08:02:20 <Janni> data Test = A | B
08:02:21 <Janni> instance Show Test where
08:02:21 <Janni>         show A = "A"
08:02:21 <Janni>         show B = "B"
08:02:21 <Janni> instance Show [Test] where show xs = concatMap show xs
08:02:44 <pesco> Looks like the problem is with the List.
08:06:51 <pesco> shapr: Has your new KB arrived yet?
08:07:15 <Janni> According to the Haskell98 report "instance C [a]" is correct...
08:07:35 <pesco> Yes, it's definately not a problem with the syntax.
08:07:36 <shapr> pesco: yes! got it yesterday!
08:07:39 <shapr> it's soooo nice
08:07:45 <shapr> hi datk 
08:07:48 <shapr> hello opet 
08:07:52 * shapr boings happily
08:07:56 <pesco> shapr: Cool, I can't wait to get mine. When did you order?
08:08:00 <shapr> um
08:08:10 <shapr> about a week ago.
08:08:25 <Igloo> Janni: a has to be a type variables, not a type
08:08:31 <shapr> but then we had to call them on the phone cuz they didn't believe we really owned the credit card.
08:08:50 <pesco> shapr: How so?!
08:09:15 <shapr> pesco: It was ordered in my name, but with Bea's credit card.
08:09:21 <pesco> shapr: oic
08:09:31 <shapr> So they thought it might be credit card fraud.
08:09:42 <pesco> Eek!
08:09:55 <pesco> shapr: RecompileModule isn't working.
08:09:58 <shapr> Bea called them and they quickly found our customer record, and realized this was the second kbd we've ordered from them.
08:10:10 <pesco> Hehe, cool.
08:10:17 <shapr> So they may have sent this one to us extrafast to keep us happy :-)
08:10:39 <shapr> what's the problem?
08:10:57 <pesco> executeFile gives me an illegal instruction. :-O
08:11:14 <shapr> I've never seen that error before, what does it mean?
08:11:27 <pesco> It means somehow the CPU got fed an illegal instruction.
08:11:31 <shapr> whoa
08:11:37 <pesco> yep.
08:12:10 <shapr> Does PPC Linux come with nifty Bomb icons like MacOS? :-)
08:12:25 <pesco> Anyway, I foreign imported execv myself but haven't been able to test it because of lack of Internet access.
08:13:04 <pesco> shapr: No, fortunately the OS doesn't care if userspace makes illegal instructions.
08:13:20 <shapr> heh, ok.
08:14:13 <pesco> I should try to get the PB on the WLAN at work...
08:16:10 <pesco> I've already read some PPC assembly language and know the calling conventions on linux in principle.
08:16:33 <pesco> One day, I'll be able to make a registerised GHC for it!
08:16:36 <shapr> yay!
08:18:20 <pesco> The asm looks funny because they use straight numbers for the registers _and_ literals because they know what was meant from the instruction.
08:18:30 <pesco> So you have lines like
08:18:32 <pesco> li 0,0
08:18:41 <pesco> Which loads register 0 with 0.
08:18:53 <shapr> interesting
08:19:00 <pesco> And there's an instruction called 'bla'
08:19:09 <andersca> isn't register 0 always 0?
08:19:21 <pesco> andersca: no, not on powerpc.
08:19:29 <andersca> oh ok
08:20:51 <Janni> When I run hugs with the "-98" flag I get on the code line "instance Bits [Bool] where" this one:
08:20:51 <Janni> Cannot build superclass instance
08:20:51 <Janni> *** Instance            : Bits [Bool]
08:20:51 <Janni> *** Context supplied    : ()
08:20:51 <Janni> *** Required superclass : Num [Bool]
08:21:45 <shapr> oh, that has been discussed on the mailing lists recently
08:21:52 <shapr> in relation to some DES code that Igloo wrote
08:22:23 <Janni> Yeah, I'd like to use that code
08:22:35 <Janni> @searchml DES
08:22:50 <pesco> fsck, what is wrong with my wlan card? It for hell's sake won't connect to the UNI net.
08:22:52 <shapr> @searchml python
08:22:52 <lambdabot> 1916 1823 1557 1555 1397 1394 1367 1316 1301 356 355 354 272 271 238 237 236 245 84 76 75 74 73
08:23:08 <shapr> I need to add a zero results message
08:23:20 <shapr> @searchml des
08:23:20 <lambdabot> 2141 1934 24 20 17
08:23:23 <shapr> oops
08:23:29 <shapr> I need to lowercase input words
08:23:36 <shapr> @showml 2141
08:23:36 <lambdabot> Is this a recent change? I've downloaded Ian Lynagh's DES module and it
08:23:36 <lambdabot> doesn't compile because of this. I assume it used to. I don't see the
08:23:36 <lambdabot> rationale for this. I can see Bool can be an instance of Bit but why does it
08:23:36 <lambdabot> need to be an instance of Num?
08:23:37 <lambdabot> Dominic Steinitz
08:23:39 <shapr> aha :-)
08:24:06 <shapr> Janni: you found a bug, thanks :-)
08:24:09 <shapr> now I can fix it!
08:24:57 <shapr> Yow, do you ever look at code you wrote and wonder just how many hours of sleep you were missing when you wrote it?
08:25:30 <shapr> obviously I need to add thread finding code to lambdabot, that way you can track backwards in a thread.
08:25:52 <shapr> threads are very easy to do
08:26:36 <pesco> No, there is an emergency circuit in my brain that suppresses my ability to code entirely when thing start getting too bad.
08:26:42 <shapr> heh
08:28:01 <shapr> @showml 1934
08:28:02 <lambdabot>  **** <We apologize for multiple postings.> ****
08:28:02 <lambdabot> Please can you publicise this amongst your colleagues and particularly
08:28:03 <lambdabot> PhD students who could take advantage of our grants for accommodation
08:30:07 <shapr> Janni: maybe Igloo can help you?
08:33:04 <Janni> Thx. I'll ask him.
08:55:59 <mgoetze> @more
08:55:59 <lambdabot> etc
08:55:59 <lambdabot> +---------------------------------------------------------------------+
08:55:59 <lambdabot> 			CALL FOR PARTICIPATION
08:56:05 <mgoetze> @more
08:56:06 <lambdabot> 	    British Colloquium on Theoretical Computer Science
08:56:06 <lambdabot> 			7th - 9th April 2003
08:56:06 <lambdabot> 		      Leicester, United Kingdom
08:56:09 <lambdabot> 	     http://www.mcs.le.ac.uk/events/bctcs19/
08:56:16 <mgoetze> @more
08:56:17 <lambdabot> The British Colloquium for Theoretical Computer Science (BCTCS) is an
08:56:17 <lambdabot> annual conference providing a forum for research in all areas of
08:56:19 <lambdabot> theoretical computer science. As such, it aims to provide an informal
08:56:21 <lambdabot> setting within which researchers can meet and discuss
08:56:23 <lambdabot> recent developments and results in the broad swathe of the subject
09:27:40 <shapr> urgh
09:28:07 <shapr> Java is the COBOL of the future.
09:28:26 <Darius> that's right
09:29:12 <shapr> Like COBOL in its day, Java pays well, but is not a joy to write.
09:29:31 <Darius> how's this: I prefer C++ to Java for most things
09:31:36 <shapr> wow
09:31:39 <shapr> scary :-)
09:31:53 <shapr> I prefer Haskell, and after that, Python.
09:32:18 <shapr> after that, I prefer a week at the beach.
09:32:44 * shapr hangs up the "Will code for food" sign and goes back to doing Java
09:34:44 <Janni> Poor shapr :'-(
09:36:55 <shapr> on the good side, writing Java increases my motivation to make paying Haskell work happen.
09:38:27 <Janni> In the new semester I will also have to use Java :-( But I'm so happy Haskell was used in the first semester. That's the way I got to know it...
09:41:07 <SyntaxPolice> someone needs to add links and explanation of arrows and frp to the wiki :) http://haskell.org/wiki/wiki?CommonHaskellIdioms
09:48:59 <Igloo> Janni: The answer is just to have an empty instance for Num [Bool]
09:49:22 * Igloo should look at the fixed tarball Dominic sent me and put it up
09:59:09 <Janni> thx
10:07:41 <Darius> woo and whew. The lambdabot problem is just a parsing problem (as I started thinking with my last example). (at least this problem is ;)
10:11:16 <Darius> @eval (\S K I a o.(S (S (K S) (K I)) (S (K K) I)) a o) (\f g x.f x (g x)) (\x y.x) (\x.x) 5 (\x.x+10)
10:11:17 <lambdabot> <<EM Dynamic -> EM Dynamic>>
10:11:30 <Darius> @eval (\S K I a o.S (S (K S) (K I)) (S (K K) I) a o) (\f g x.f x (g x)) (\x y.x) (\x.x) 5 (\x.x+10)
10:11:31 <lambdabot> 15
10:16:12 <Marvin--> having fun?
10:21:26 <Darius> actually I'm staring at the progress bar of a download (only 28 hrs. to go), thinking of how to fix it.  By the way, in response to a comment you made 7 hours ago, it's easy to remember it's currying: the language is named after Haskell Curry.
11:02:55 <Darius> unit testing coming in handy...
11:18:04 <Darius> woo "failures = 0"
11:25:53 <Igloo> Heh, John Peterson has ported Pan back to .NET
11:28:30 * esap blinks.
11:33:31 <Marvin--> "back" to .NET?
11:44:46 <Igloo> I'm fairly sure it started out targettijg .NET
12:02:56 * shapr has an evil idea
12:03:20 * Riastradh has lots of those.
12:03:30 <shapr> I think this one could be especially evil.
12:03:46 <shapr> I'm thinking of applying Paul Graham's "Plan for SPAM" ideas to IRC.
12:04:17 <Riastradh> What're his 'Plan for Spam' ideas?
12:04:21 <shapr> http://www.paulgraham.com/spam.html
12:04:31 <Riastradh> I'm too lazy to read it.  Can you sum it up?
12:04:38 <shapr> use bayesian statistics to classify stuff
12:05:28 <esap> oh the idea would be to construct an encyclopedia of IRC discussions organized based on the bayesian statistics? :-)
12:05:48 <shapr> oh, that's a good idea
12:05:56 <shapr> actually
12:06:00 <shapr> you could extend that even further
12:06:10 <shapr> to a personal web search engine
12:06:19 <shapr> yes yes, this is a good idea.
12:07:03 <shapr> esap: you're brilliant!
12:07:27 <esap> heh
12:07:44 <shapr> so, here's the plan... first we make the Haskell spam filter
12:08:00 <shapr> then we use the statistics in those spam filters as input to google
12:08:13 <shapr> to find stuff that's interesting to the user
12:08:56 <shapr> you could extend that further to make personal web spiders
12:21:13 * shapr downloads crm114
12:26:48 * Riastradh figures out how to define B in terms of S and K.
12:26:54 <shapr> show us!
12:27:00 <SyntaxPolice> shapr: you should implement xmlrpc for haskell and extend lambdabot to be able to call certain xmlrpc functions (ones that have been registered).
12:27:16 <shapr> SyntaxPolice: that would be a useful thing, I agree.
12:27:35 <Riastradh> shapr - Well, I'm still busy working at it.
12:27:40 <Riastradh> I've gotten it to:
12:27:51 <SyntaxPolice> anyone have good pointers on FRP?  Is there a tutorial out there w/ examples?
12:27:58 <shapr> SyntaxPolice: yampa
12:28:09 <shapr> the robot soccer demo is great fun
12:28:15 <Riastradh> (S (S (K S) (lambda x (S (K S) (K x)))) (K K))
12:28:17 <mgoetze> SyntaxPolice: as in, Fantasy Role-Playing?
12:28:31 <SyntaxPolice> mgoetze: the last thing I need is a new game :-)
12:28:50 <shapr> There's also a version of Space Invaders written with FRP
12:29:47 <shapr> one reason I'd like a moinmoin wiki... we could add attachments to pages.
12:30:46 <SyntaxPolice> oh shapr, what do you think is a good wiki thats in Debian?
12:30:58 <shapr> moin
12:31:18 --- mode: ChanServ set +v Janni
12:31:18 <Janni> re
12:31:20 <shapr> I was a developer on moin... but I never did anything =)
12:31:34 <SyntaxPolice> how does it compare w/ usemod?
12:31:43 <Riastradh> @define B1 S (S (K S) (\x. S (K S) (K x))) (K K)
12:31:43 <lambdabot> B1 defined
12:31:48 <Riastradh> @eval B1 I 5 I
12:31:48 <lambdabot> unbound variable: S
12:31:51 <Riastradh> Ack.
12:32:00 <Riastradh> @define S \f g x. (f x) (g x)
12:32:00 <lambdabot> S defined
12:32:04 <shapr> SyntaxPolice: http://twistedmatrix.com/users/jh.twistd/moin/moin.cgi/
12:32:05 <Riastradh> @define K \x y. x
12:32:05 <lambdabot> K defined
12:32:07 <Riastradh> @define I S K K
12:32:08 <lambdabot> I defined
12:32:13 <Riastradh> @define B1 S (S (K S) (\x. S (K S) (K x))) (K K)
12:32:13 <lambdabot> B1 defined
12:32:17 <Riastradh> @eval B1 I 5 I
12:32:18 <lambdabot> 5
12:33:42 <shapr> imo, moin is the best wiki system.
12:33:57 <shapr> until we write the HaskellWiki of course
12:34:06 <shapr> :-)
12:35:04 <SyntaxPolice> shapr: have you ever used usemod?
12:35:24 <shapr> yes
12:35:41 <shapr> I've used many wiki systems
12:35:59 <SyntaxPolice> can you tell me what features moin has that usemod doesn't?  Looks like searching is better...
12:36:09 <shapr> moin is written in Python
12:36:20 <shapr> moin is 8-bit clean
12:36:48 <shapr> It was originally an extension of PikiPiki (or PyWiki, I forget which) to add umlaut support to the text.
12:37:17 <shapr> I'm pretty sure usemod is written in perl
12:38:18 <shapr> yes, it is written in Perl
12:38:27 <SyntaxPolice> can you alias two pages? Like originally, two concepts had separate pages, but then later they were merged, but you don't want to change all of the links to those pages.  IS there a solution in moin?
12:38:34 <shapr> I think SunirShah wrote usemod
12:38:43 <SyntaxPolice> the only solution I found offhand in usemod is to us ln -s :)
12:38:55 <shapr> I think usemod and moin both allow redirects
12:39:01 <SyntaxPolice> hrm. OK.
12:39:13 <shapr> If usemod doesn't then kensanata has fixed the emacswiki version
12:39:38 <shapr> I know moin supports redirects
12:39:39 <shapr> and subpages
12:40:12 <SyntaxPolice> so is there some massive forking going on in the wiki world or somethign? Everything seems to be cloned or derived from something else?
12:40:17 <Riastradh> S (S (K S) (S (S (K S) (S (K K) (K S))) K)) (K K)
12:40:25 <SyntaxPolice> (Sorry Im' too lazy to answer all these questions for myself :-)
12:40:26 <Riastradh> @define B1 S (S (K S) (S (S (K S) (S (K K) (K S))) K)) (K K)
12:40:26 <lambdabot> B1 defined
12:40:30 <Riastradh> @eval B1 I 5 I
12:40:30 <lambdabot> 5
12:40:35 <Riastradh> At last!
12:40:43 <SyntaxPolice> my cat is named lambda :-)
12:40:50 <shapr> SyntaxPolice: yes, everything was forked from the c2.com version in 1995 or so
12:41:14 <shapr> actually, pywiki and pikipiki were equally short clones in python
12:41:25 <shapr> lots of those happened for various languages
12:41:38 <Marvin--> SyntaxPolice: not "cat five"? :)
12:41:44 * shapr laughs
12:42:30 <SyntaxPolice> heh.
12:42:49 <SyntaxPolice> Lambda Mu is actually his full name
12:42:50 <shapr> oh, Clifford Adams wrote usemod, but he's handing it off to SunirShah after 1.0
12:43:18 <SyntaxPolice> so moin is better than usemod, 'eh? I think I'll try it out.  Trying to pick one for a site.
12:43:45 <shapr> the next big thing in wikis will be Fit
12:43:49 <Marvin--> SyntaxPolice: geek :)
12:43:53 <shapr> from fit.c2.com
12:44:35 <shapr> fit would integrate well with Haddock, QuickCheck, and HUnit; so I'm tempted to hack it into an HWS-WP plugin
12:44:46 <shapr> I just have to find the time...
12:44:49 <SyntaxPolice> Marvin--: I guess you could say that.  Its just such a good name, though.
12:45:22 <SyntaxPolice> I'm using a wiki at work to take notes and connect concepts.
12:45:28 <shapr> I use emacs-wiki
13:19:44 --- topic: '["mo' nads than you","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","New Hat 2.02 http://www.haskell.org/hat/","New Learning Haskell page - http://www.haskell.org/learning.html","GUI Demos - http://repetae.net/john/computer/haskell/gui/","Order Haskell 98 Report in Hardcopy - http://titles.cambridge.org/catalogue.asp?isbn=0521826144","GHC 5.04.3 released!","This is no longer a LOL Free Zone"]'
13:19:44 --- topic: set by shapr on [Mon Apr 07 09:41:24 2003]
13:19:44 --- names: list (clog +Janni o3 OuterMind Darius Vincenz tic kunphuzil esap kani^^off ludde Smerdyakov psy nbd norpan +mgoetze Fractal gdsx RadekH +Riastradh xkb Segora galority polli +Igloo skylan lambdabot kawfee emu LoganH_ smkl arguile tWip +Marvin-- andersca Arnia +shapr +SyntaxPolice +dennisb)
13:19:51 <shapr> he's baaack
13:20:18 <andersca> the man behind the mask?
13:20:27 <mgoetze> everyone watch out! we're being logged!
13:20:44 <SyntaxPolice> the manual talks of a library which includes:
13:20:47 <SyntaxPolice> # A core module (FRPCore) that defines the basic types and functions;
13:20:47 <SyntaxPolice> # A geometry (Geometry) module that provides 2D and 3D geometrical operations;
13:20:47 <SyntaxPolice> # A graphics (GraphicsZ) module that provides 2D graphics capability;
13:20:47 <SyntaxPolice> # Other supportive modules.
13:21:02 <SyntaxPolice> is clog a bot that logs us? 
13:21:05 <shapr> yup
13:21:09 <SyntaxPolice> do we want it?
13:21:16 <shapr> sure
13:21:24 <shapr> at least, I think so
13:21:44 <shapr> it's good for finding something that someone mentioned three months ago and I can't remember exact details for...
13:21:49 <shapr> that kind of thing
13:22:01 <shapr> I'm planning on adding #haskell log searching to lambdabot at some point
13:22:28 <SyntaxPolice> neat.  I was just a little weirded out by all the warnings and paranoid jokes ;)
13:22:31 * shapr grins
13:22:40 * shapr boings
13:23:02 <Marvin--> aiih, the thing I really hate about making up a background story is that you'll end up having to think of 10+ names
13:23:50 * SyntaxPolice browses through newsgroups for interesting names.
13:29:29 * Marvin-- finds some name generators
13:29:36 <Marvin--> hey cool, this one can even generate insults :-)
13:33:58 --- mode: ChanServ set +v Janni
13:49:23 --- mode: ChanServ set +o SyntaxPolice
13:49:40 <SyntaxPolice> whoa
13:49:43 --- mode: SyntaxPolice set -o SyntaxPolice
13:50:44 * mgoetze smiles at SyntaxPolice 
13:54:54 <Igloo> Out of interest why did someone want me to register with ns? I can't see anything that says I'm an anything on #haskell
13:57:02 <mgoetze> Igloo: well, uhm, you can ghost yourself, and get memos with memoserv, and so on :)
13:57:28 <Igloo> Oh, how useful
13:58:18 <Igloo> Well, I guess ghosting might come in handy some time
13:59:33 * Igloo is tired
14:31:56 * shapr boings
14:32:02 * shapr emails energy to Igloo 
14:32:50 * shapr warbles
14:33:02 * Riastradh sprounces.
14:33:11 <mgoetze> shapr: tell me when the judging will be done!
14:33:18 <shapr> mgoetze: RSN!
14:33:41 <Igloo> shapr  :-)
14:33:50 <Igloo> (re energy)
14:34:01 <shapr> Igloo: do you feel more energetic now?
14:34:08 * Igloo hopes I can still find my judgings
14:34:11 <shapr> heh
14:34:30 <Igloo> Sadly not  :-(
14:34:40 --- mode: mgoetze set +v clausen
14:49:39 * shapr hacks away on a Haskell spam filter
14:50:07 <shapr> I'm starting to get so much spam...
14:52:25 * mgoetze is happy with spamassassin
14:53:05 * andersca too
14:53:07 <andersca> especially 2.50
14:56:30 * SyntaxPolice is also happy w/ spamassassin
14:57:50 <shapr> probably I would be also
14:58:05 <shapr> But I enjoy writing code...
14:59:03 <shapr> It's a lot spiffier to write your own utilities :-)
14:59:42 <mgoetze> have you written 'ls' in haskell yet? :P
15:00:05 <shapr> nah, Igloo did that.
15:00:06 <andersca> are you using hash?
15:00:11 <andersca> HAskell SHell
15:00:33 <mgoetze> andersca: package it for debian and i'll try :)
15:00:36 <shapr> nah, I used it a little bit, but at the time I didn't have the skillz to extend it
15:01:13 <shapr> I did update a much ghc4 version of Hsh.hs to ghc5
15:01:25 <shapr> but then I found out that Hsh.hs comes with ghc sources...
15:02:54 <shapr> it would be neat to do map/filter/etc from a shell
15:02:57 * shapr considers that
15:05:36 <shapr> rules 1,2, and 5 from http://paulgraham.com/better.html are easy to implement
15:05:45 <shapr> any suggestions for 3 and 4 ?
15:08:16 <shapr> oh, nub doesn't need sort, duh
15:08:29 <shapr> I was thinking sort | uniq
15:27:41 <kunphuzil> Hmm. I want to learn more haskell so I can start hacking some code! ;l
15:27:58 <shapr> yay!
15:27:59 <shapr> good idea!
15:28:04 <Smerdyakov> Hooray! Hacking some code!
15:28:10 <shapr> hiya Smerdyakov
15:28:11 <shapr> what's up?
15:28:23 <kunphuzil> Smerdy is evil. Don't talk with him
15:28:26 <shapr> ?
15:28:36 <Smerdyakov> Oh, I was just yelling at kunphuzil in another channel for young programmers.
15:28:37 <shapr> He gave me a nice tutorial on lambda calculus recently.
15:28:50 <Smerdyakov> He just blabbers on all the time in all capital letters and helps distract anyone there from learning to code.
15:29:14 <kunphuzil> Smerdyakov: So. That is what the environment in there allows.
15:29:21 <kunphuzil> For example, I wouldn't do something like that in this channel.
15:29:33 <Smerdyakov> You can change the environment by setting a good example.
15:46:10 <kunphuzil> In hugs, it will only allow to me to declare things in a file, and I must load the file. 
15:46:22 <kunphuzil> i.e. 
15:46:46 <kunphuzil> Prelude> shortPalindrome = "bob"
15:46:46 <kunphuzil> ERROR - Syntax error in input (unexpected `=')
15:46:46 <kunphuzil> Prelude> 
15:46:55 <Riastradh> That is corret.
15:46:59 <Riastradh> s/corret/correct/1
15:47:18 <kunphuzil> ?
15:48:14 <shapr> yah, what he said
15:48:17 <Riastradh> You can't define variables from the interpreter.
15:48:23 <Riastradh> The interactive interpreter, that is.
15:48:30 <kunphuzil> Hmrf. Darn
15:48:31 <shapr> closest you can get is the "let" stuff in GHC
15:48:44 <shapr> which is just like doing a "let" in a monadic context
15:48:46 <kunphuzil> In lisp you can.. :|
15:48:57 <Riastradh> Haskell isn't Lisp.
15:49:24 <kunphuzil> Maybe I want lisp then.
15:49:52 <kunphuzil> After Haskell..
15:49:56 <shapr> :-)
15:50:04 <Riastradh> No, you want Haskell, not Common Lisp.
15:50:16 <Igloo> Euch, you can't compare languages based on interpretter implementations  :-)
15:50:46 * shapr finish field accessors
15:50:53 <kunphuzil> Why has the writers of the interpreters done that?
15:50:54 <Smerdyakov> An option to send declarations to the interpreter in mutually recursive batches would be awfully nice.
15:51:09 * shapr gets more spam to help motivation
15:51:10 <Smerdyakov> kunphuzil, in Haskell, a declaration can refer to later declarations, not just itself and earlier ones.
15:51:24 <Igloo> Rubbish
15:51:30 <shapr> Igloo: yes, that's it.
15:51:37 * shapr throws the spam in the rubbish
15:51:46 <Smerdyakov> Igloo, ?
15:52:12 <kunphuzil> Smerdyakov: Well, it could just store it, like loading a file. I guess.
15:52:20 <Igloo> What you said is true of statements, like let in the do monad
15:52:48 <Smerdyakov> Can't I do:
15:52:48 <Igloo> ghci (which notably is not Haskell) puts you in something resembling the IO monad
15:52:52 <Smerdyakov> a = 1:b
15:52:54 <Smerdyakov> b = 2:a
15:52:55 <Igloo> I meant s/do/IO/ up there
15:52:55 <Smerdyakov> ?
15:53:12 <Igloo> In Haskell? You can
15:53:22 <Smerdyakov> So then how was what I said wrong...?
15:53:58 <Igloo> *DONK*
15:54:02 <Igloo> Because I read it wrong
15:54:20 * Igloo apologises, guess I'm even more tired than I thought
15:54:56 * Igloo goes away
16:03:51 <shapr> I wonder what a haskellish interface should look like
16:05:09 <Darius_> what do you mean?
16:05:40 <shapr> I'm writing accessors for the RFC2822 parser
16:05:52 <kunphuzil> What is that?
16:05:54 <shapr> they're named getMessage getTo getToText
16:05:59 <shapr> I dunno if those are good names or not
16:06:08 <shapr> any suggestions for 'haskellish' names?
16:06:29 <shapr> kunphuzil: rfc2822 is the successor to rfc822, basically, email headers
16:06:48 <shapr> Sender: To: etc
16:06:51 <shapr> but not MIME
16:08:21 <shapr> @searchml mime
16:08:23 <lambdabot> 2078 1991 1920 1917 1909 1867 1858 1852 1744 1731 1608 1544 1462 1458 1396 1350 1349 1348 1330 1313 1276 1253 1144 1100 1043 1038 1030 1026 1020 1003 917 909 719 702 684 682 627 605 604 467 365 355 354 253 36
16:08:25 <shapr> yow
16:08:52 <shapr> hm, I should be sorting results from new to old
16:09:00 <shapr> @shoml 2078
16:09:00 <lambdabot> Sorry, I don't know the command "shoml", try "lambdabot: @listcommands"
16:09:04 <shapr> @showml 2078
16:09:04 <lambdabot> This message is in MIME format. Since your mail reader does not understand
16:09:04 <lambdabot> this format, some or all of this message may not be legible.
16:09:04 <lambdabot> ------_=_NextPart_000_01C2EF82.201B9260
16:09:04 <lambdabot> Content-Type: text/plain;
16:09:05 <lambdabot> 	charset="iso-8859-1"
16:09:08 <shapr> doh
16:09:11 <mgoetze> lol
16:09:15 <shapr> lambdabot: silly bot, that's not what I meant.
16:09:15 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
16:09:15 <SlushP> hi guys
16:09:19 <shapr> hello SlushP 
16:09:20 <SlushP> guess what!
16:09:23 <shapr> what?
16:09:26 <SlushP> I did it:)
16:09:27 <SlushP> lol
16:09:28 <shapr> YAY!
16:09:35 <SlushP> I woke up this morning and I just started over.
16:09:37 <Riastradh> What did you do?
16:09:39 <SlushP> Want to see my new code?
16:09:47 <shapr> Riastradh: he succeeded in not getting kickbanned
16:09:51 <shapr> we are happy :-)
16:09:56 <shapr> or at least I am
16:09:58 <SlushP> Thanks;)
16:10:06 <shapr> SlushP: yes, I would like to see your new code.
16:10:09 <shapr> if it's short
16:10:15 <SlushP> I'm sorry I sounded moody last night. I was really cold, tired, and pissed off!
16:10:16 <SlushP> lol
16:10:26 <SlushP> > makeAppointmentRecord :: String -> Appointment
16:10:26 <SlushP> > makeAppointmentRecord s = (duration, note, important)
16:10:26 <SlushP> > 		where 
16:10:26 <SlushP> >			important = head s == '!'
16:10:26 <SlushP> >			s2 | important = tail s
16:10:27 <SlushP> >			   | otherwise = s
16:10:29 <SlushP> >            		duration = (read a, read (tail b)) 
16:10:29 <shapr> it's considered impolite to paste more than five lines into a channel without permission.
16:10:31 <SlushP> >           		note = dropWhile (not . isAlpha) s2
16:10:33 <SlushP> >           		(a,b) = (break (=='-') . getWord . dropSpace) s2
16:10:44 <SlushP> Whoops. Soryr
16:10:46 <SlushP> Sorry*
16:10:59 <shapr> SlushP: truly, you were a pain yesterday... but we're all like that sometimes.
16:11:24 <SlushP> Thanks for your honesty,  but I admit what you said is true.
16:11:28 <shapr> :-)
16:11:35 <SlushP> Now I'm going to do the next question...by myself:)
16:11:38 <shapr> yay!
16:12:00 <shapr> frustration is the hardest thing to beat
16:12:07 <Smerdyakov> No.
16:12:12 <Smerdyakov> A dragon with a laser gun is harder.
16:12:12 <shapr> it isn't?
16:12:14 * shapr laughs
16:12:17 <shapr> ok, that's true
16:12:50 <shapr> last time I got really frustrated I headbanged my $300 keyboard... and broke it.
16:12:54 <Riastradh> What about a ranting Bjarne Stroustroup?
16:13:21 <Darius_> SlushP: a note, you can pattern match constants (e.g. s2 ('!':rest) = ... (next line) s2 s = ...)
16:13:25 * esap has never heard Bjarne rant.
16:13:33 <shapr> I haven't heard him rant either.
16:13:47 <Riastradh> OK, what about a Bjarne Stroustroup in general?
16:13:51 <shapr> I still need to send my keyboard off to get it repaired.
16:14:22 * andersca transfers
16:14:28 <shapr> andersca: to where?
16:14:33 <andersca> to my ipod
16:14:36 <shapr> yay
16:30:32 <shapr> anyone clueful about bayesian statistics?
16:32:06 <Riastradh> I'm sure someone is, somewhere on Earth.
16:32:10 <shapr> :-P
16:32:52 <clausen> I've been reading up on probability and statistics
16:33:08 <clausen> (mainly motivated by information theory)
16:33:23 * clausen wonders if it's related to the maths for spam (that's your motivation?)
16:33:26 <shapr> I'm writing a paul graham style spamfilter
16:33:38 <shapr> I have tokenization
16:33:50 <Riastradh> Didn't he implement it in Arc?
16:33:54 <shapr> yah
16:34:01 <shapr> but he gives CL code on his site
16:34:01 <andersca> unlines (unwords (... ?
16:34:02 <andersca> :)
16:34:04 <Riastradh> Can't you use that as a reference?
16:34:08 <Riastradh> Ewwww.
16:34:57 <clausen> it looks somewhat like Bayes' Theorem
16:35:06 * clausen remembers learning about that a few years ago
16:35:12 <shapr> I've heard of it...
16:35:16 <clausen> it's some way of calculating Pr(A | B) given Pr(B | A) and a few other things
16:35:49 <shapr> 1) count the number of times each token occurs in the two bunches, spam and non-spam
16:36:02 <clausen> P(A|B) = (P(A^B)) / P(B)
16:36:07 <clausen> ^ is intersection
16:36:34 <shapr> can you translate that into haskell or pseudocode?
16:37:01 <shapr> p = probability?
16:37:03 <clausen> yes
16:37:14 <clausen> that is just an axiom
16:37:19 <clausen> it's not bayes' theorem
16:37:22 <clausen> you read it as:
16:37:48 <clausen> "the probability of even A occurring if B has occurred equals the probability of A and B happening, divided by the probability of B happening"
16:38:21 <shapr> interesting
16:38:24 <shapr> is that true?
16:38:42 <clausen> yep
16:38:53 <clausen> s/even/event/
16:38:53 <shapr> neat
16:39:12 <clausen> draw some diagrams to convince yourself
16:39:19 <clausen> hmmm, actually, I guess it need not be an axiom
16:39:23 <clausen> you can define a probability space, etc.
16:39:26 * shapr makes pretty pictures
16:39:27 <clausen> and probably prove it that way
16:39:52 <shapr> actually, at the moment I'll take your word for it and make the code work
16:40:22 <clausen> well, what I wrote is just the beginning
16:40:29 * clausen googles Bayes theorem
16:42:25 <clausen> http://www.wikipedia.org/wiki/Bayes%27_theorem
16:43:27 <Darius_> note that Graham uses a degenerate form of Bayes' rule
16:44:07 <clausen> shapr: that formula I wrote is basically the definition of "conditional probabilities"
16:44:14 <clausen> (there's a link to a page on that on wikipedia)
16:44:16 <clausen> wikipedia rocks!
16:44:35 <shapr> truly wikipedia rocks
16:52:35 * shapr tries to absorb knowledge
16:55:21 <shapr> Darius_: do you understand the PG form of Bayes' rule enough to write it in Haskell? ;-)
16:56:37 --- mode: ChanServ set +v Pseudonym
16:56:41 <shapr> hiya Pseudonym 
16:56:45 <Pseudonym> G'day.
16:57:38 <shapr> hey...
16:57:43 <shapr> I have lots of questions =)
16:57:54 <Pseudonym> It's not homework, I hope.
16:57:59 * shapr laughs
16:58:10 <shapr> if only lambdabot code were homework
16:58:33 <Pseudonym> I see you met SlushP.
16:58:38 * Pseudonym is reading through the logs
16:58:43 <shapr> :-)
16:58:55 <shapr> I had to count chimpanzees.
16:58:57 <Pseudonym> G'day, Slush, BTW.  Don't mean to be rude.
16:59:03 <Pseudonym> Oh?
16:59:10 <shapr> You read Robert Heinlein?
16:59:16 <Pseudonym> If you had an infinite number, you might get some decent code out of them.
16:59:44 <Pseudonym> Uhm... no, actually.
16:59:51 <Pseudonym> This is a failing of me, I know.
17:00:06 * Pseudonym is an odd geek
17:00:19 <shapr> problem: modules are initialized after the socket is connected, but before the login is made
17:00:36 <Pseudonym> OK...
17:00:46 <Pseudonym> Is this a timing thing?
17:00:48 <shapr> solution: force evaluation of "(evalStateT m initState)" earlier
17:01:01 <Pseudonym> Makes sense.
17:01:01 <shapr> yah, I wrote a mailing list search module, and it takes three minutes to build an FM
17:01:09 <shapr> @searchml Pseudonym 
17:01:16 <shapr> @hello
17:01:16 <lambdabot> Hello world. 
17:01:22 <shapr> @searchml bromage
17:01:25 <lambdabot> 2136 2115 1990 1905 1802 1780 1775 1754 1729 1571 1565 1561 1488 1481 1452 1449 1446 1416 1414 1413 1412 1320 1316 1314 1312 1310 1309 1304 1303 1302 1301 1300 1299 1247 1246 1217 1094 1054 1051 893 805 703 650 630 609 607 602 600 594 591 585 581 569 464 463 272 271 171 170 155 137 135 130 126 114 33 32
17:01:36 <shapr> @showml 2136
17:01:37 <lambdabot> Announcing the release of lambdabot 1.0
17:01:37 <lambdabot> ------------------------------------
17:01:37 <lambdabot> lambdabot is an IRC 'bot and plugin framework written in Haskell 
17:01:38 <lambdabot> by Andrew Bromage, and a collection of plugins by Shae Erisson, Taylor
17:01:43 <Pseudonym> Oh, $DEITY,, it's the ghost of mailing list past.
17:01:46 * shapr smiles
17:02:03 <Pseudonym> @showml 33
17:02:04 <lambdabot> G'day all.
17:02:04 <lambdabot> On Mon, May 06, 2002 at 02:15:55PM +1000, Garner, Robin wrote:
17:02:04 <lambdabot> > How you would do this in a functional implementation is another question -
17:02:04 <lambdabot> > Dijkstra's example is comparing two arrays, and there may be inefficiencies
17:02:13 <shapr> after which I had to write the @more plugin
17:02:18 <Pseudonym> @more
17:02:18 <lambdabot> > translating it to a list-based implementation.
17:02:18 <lambdabot> Here's my humble contribution.  It compiles the string to a function
17:02:18 <lambdabot> which performs the match, using continuations to handle the failure
17:02:18 <lambdabot> transitions.  It's also not a good example of the sort of Haskell
17:02:19 <lambdabot> code that you should write.  It's possibly also buggy.
17:02:31 <shapr> because everytime anyone called @showml, lambdabot was kicked for flooding
17:02:38 <Pseudonym> fair enough.
17:02:57 <Pseudonym> Methinks you need a binding for Berkeley DB or GDBM.
17:03:02 <shapr> it's only my local gnus archive, so it extends as far back as I've been on the list.
17:03:09 <Pseudonym> Or, hell, PostgreSQL.
17:03:16 * Pseudonym nods
17:03:17 <shapr> lambdabot already uses PostgreSQL bindings
17:03:22 <shapr> for @fact
17:03:23 <Pseudonym> Right.
17:03:26 <shapr> but
17:03:30 <shapr> that would be no fun =)
17:03:33 <shapr> too easy
17:03:42 <shapr> well, maybe
17:03:49 <Pseudonym> Maybe, but it wouldn't take ~3mins.
17:03:53 <shapr> that's a good point
17:04:11 <shapr> A good version of Binary.hs could also fix this problem.
17:04:21 <shapr> somewhat
17:04:30 <Pseudonym> Yes, I guess.
17:04:30 <shapr> searchml still takes ~370mb of ram
17:04:38 <shapr> for 16mb of the haskell mailinglist
17:04:45 <Pseudonym> Eek.
17:04:59 <shapr> I'm sure the code is inefficient
17:05:00 <Pseudonym> If you ask me, one of the worst design decisions was to make String == [Char].
17:05:18 <Pseudonym> But nobody asks me.
17:05:37 <shapr> so, my question is...
17:05:57 <shapr> how the heck do I move that evalStateT call above the connectTo call?
17:06:07 <shapr> I am clueless on how to make the types match up
17:06:33 <Pseudonym> Hang on.
17:06:35 <shapr> ok
17:06:37 <Pseudonym> Hmmm.
17:06:42 * Pseudonym thinks about this for a moment.
17:06:59 * Pseudonym cvs updates
17:07:02 * shapr grins
17:07:22 <shapr> hey, haskell-libs was at 89.8% active two days ago =)
17:07:36 <shapr> primarily due to lambdabot 
17:07:49 <Pseudonym> Though I did put the exact real library in.
17:07:53 <shapr> yes
17:07:58 <Pseudonym> Probably noise in the signal, though.
17:07:59 <shapr> and I did some email stuff
17:08:09 * Pseudonym has to check this
17:08:13 <Pseudonym> @karma Pseudonym
17:08:14 <lambdabot> You have a karma of 0
17:08:17 <Pseudonym> Cool!
17:08:20 <shapr> it's not persistent yet
17:08:28 <shapr> so everytime lambdabot is restarted, it goes away
17:08:43 <Pseudonym> At least I don't have any spiritual baggage to work off.
17:08:50 * shapr grins
17:09:47 <Pseudonym> OK, you want the state evaluated... before what?
17:09:56 <Pseudonym> Before the reader thread starts?
17:10:10 <shapr> before the connectTo gets called
17:10:15 <Pseudonym> OK.
17:10:21 <shapr> basically, the IRC () init
17:10:41 <Pseudonym> Couple of possibilities.
17:10:43 <shapr> so that modules can finish moduleInit before any network activity happens
17:10:55 <Pseudonym> The "best" solution is mdo.
17:11:06 <shapr> I'm still not sure what that is...
17:11:15 <shapr> parallel monads?
17:11:16 <Pseudonym> Recursive "do", basically.
17:11:31 <Pseudonym> No...
17:11:35 <Pseudonym> Let me think...
17:11:39 <Pseudonym> OK. Consider this:
17:12:04 <Pseudonym> mdo { xs <- return (1:ys) ; ys <- return (2:xs) ; return xs }
17:12:25 <Pseudonym> With "do", the "ys" would necessarily be different in the first and second lines.
17:12:30 <Pseudonym> With "mdo", they're the same.
17:13:08 <shapr> er
17:13:22 <shapr> um
17:13:41 <shapr> the <- means >>= 
17:13:52 <Pseudonym> Er... kind of.
17:13:55 <Pseudonym> Yes.
17:13:56 <shapr> so, doesn't that mean that the order is wrong there?
17:14:02 <Pseudonym> Not with "mdo".
17:14:13 <shapr> how can that work?
17:14:27 <shapr> the monad calls do not depend on each other?
17:14:38 <Pseudonym> They can in general.
17:14:57 <shapr> but in essence, they're separate in an mdo, yes?
17:14:59 <Pseudonym> You need an extra operation on your monad for this to work.
17:15:06 <Pseudonym> class (Monad m) => MonadFix m where
17:15:06 <Pseudonym>         mfix :: (a -> m a) -> m a
17:15:29 <shapr> mfix works like Control.Monad.fix ?
17:15:38 <Pseudonym> It's exactly Control.Monad.Fix.
17:15:57 <Pseudonym> What this gets translated into is something like this:
17:17:00 <Pseudonym> mfix (\(xs,ys,_) -> return (1:ys) >>= \xs -> return (2:xs) >>= \ys -> return (xs,ys,xs))
17:17:15 <Pseudonym> mfix (\(xs,ys,_) -> return (1:ys) >>= \xs -> return (2:xs) >>= \ys -> return (xs,ys,xs)) >>= \(_,_,retval) -> return retval
17:17:16 <Pseudonym> Sorry.
17:17:19 <Pseudonym> Something like that.
17:17:34 <Pseudonym> The actual translation is a little fiddly.
17:17:39 <Pseudonym> http://www.cse.ogi.edu/PacSoft/projects/rmb/mdoTalk.pdf
17:17:42 <Pseudonym> Gory details there.
17:18:09 <Pseudonym> Now if you don't like mdo, there's another possibility.
17:18:24 <shapr> is mdo in ghc5.04.2 ?
17:18:29 <Pseudonym> O think so.
17:18:40 <Pseudonym> You probably need -fglasgow-exts
17:18:42 * shapr tries
17:21:15 <shapr> foo = mdo 
17:21:15 <shapr>       xs <- return (1:ys)
17:21:15 <shapr>       ys <- return (2:xs)
17:21:15 <shapr>       return xs
17:21:18 <Pseudonym> Prelude> :module + Data.Tuple
17:21:19 <shapr> doesn't compile
17:21:28 <Pseudonym> Prelude Data.Tuple> mdo { xs <- return (1:ys) ; ys <- return (2:xs) ; print xs }
17:21:34 <Pseudonym> Try that from the command line.
17:22:00 <shapr> parse error on input
17:22:00 <Pseudonym> You may need to explicitly import Data.Tuple.
17:22:09 <Pseudonym> Did you enable -fglasgow-exts?
17:22:38 <shapr> yup
17:22:43 <shapr> are you using ghc5.04.2 ?
17:23:28 <Pseudonym> I just checked.  Nope, I'm using 5.05/.
17:23:31 <Pseudonym> :-/
17:23:33 <Pseudonym> OK.
17:23:37 <Pseudonym> Possibility #2:
17:23:46 <Pseudonym> Dump state and continue.
17:24:17 <Pseudonym> Actually...
17:24:19 <Pseudonym> Erm, no.
17:24:23 * Pseudonym hmmms
17:24:34 <Pseudonym> All you want is to make sure that the module state is fully evaluated, right?
17:24:37 <shapr> yup
17:24:42 * Pseudonym thinks
17:24:56 <Pseudonym> And you only really care about the FiniteMap in one module's state.
17:25:06 <shapr> yes
17:25:25 <Pseudonym> Why not let that module fork off a thread to do a deep seq?
17:25:42 <shapr> well
17:25:53 <Pseudonym> It can be deep seqing while everyone else is waiting for network traffix.
17:26:01 <Pseudonym> Or traffic.
17:26:17 <shapr> the current solution (credits to Darius) is for the Nothing branch of the ModuleState IORef lookup to call the module init
17:26:54 <Pseudonym> Hmm.
17:26:59 <shapr> so that just makes a three minute lag after the first @searchml call
17:27:15 <shapr> I'd like for module calls to happen in a separate thread
17:27:16 <Pseudonym> Probably should really call the init at module install time.
17:27:23 * Pseudonym nods
17:27:26 <Pseudonym> I agree with you there.
17:27:38 <shapr> init is called at module install time
17:27:46 <shapr> but modules aren't installed until ...
17:28:02 <shapr> ircMain is passed to runIrc
17:28:07 <shapr> it's not evaluated
17:28:40 <Pseudonym> It's not?
17:28:43 <shapr> nope
17:28:52 <shapr> runIrc is passed the function ircMain
17:28:57 <shapr> main :: IO ()
17:28:57 <shapr> main = runIrc host port ircMain
17:29:21 <Darius_> actually that wasn't exactly what I was thinking, but it seemed like a better idea so I just shut-up (I'll take credit as muse)
17:29:23 <shapr> runIrc calls runIrc' which does connectTo, and *then* does (evalStateT m initState)
17:29:28 <shapr> and the m there is the ircMain
17:29:49 <shapr> Darius_: what were you thinking?
17:30:00 <Pseudonym> I see.  You want modules being installed while waiting for a network connection.
17:30:02 <Pseudonym> Or do you?
17:30:05 <shapr> sure
17:30:11 <Pseudonym> I'm not so sure.
17:30:19 <Pseudonym> What if a module wants the socket open to initialise itself?
17:30:25 <Pseudonym> Case in point: @topic
17:30:25 <SlushP> Can I ask for some assistance regarding making a list of strings, from one string which is delimited \n\n (ie. a blank line)?
17:30:33 <shapr> I just wanted to swap the order around so that all moduleInit calls would be finished before connection starts
17:30:38 <shapr> Pseudonym: oh, interesting point
17:31:01 <shapr> so maybe moduleInit should happen only when the module is first called.
17:31:10 <Darius_> SlushP: check 'lines'
17:31:16 <shapr> SlushP: lines
17:31:27 <SlushP> Ok
17:31:49 <shapr> even so, I'd like for module calls to happen in their own thread
17:31:54 <shapr> if possible
17:32:01 <SlushP> Is there a way to break at \n\n ?
17:32:23 <shapr> SlushP: there's some code in Util.hs in the lambdabot sources that can do that.
17:32:43 <shapr> originally written by Pseudonym, extended by tmoertel
17:33:18 <Darius_> shapr: I was thinking about loading all modules later by changing the order in ircMain
17:33:24 <shapr> oh
17:33:58 <Darius_> that was to avoid getting dropped (the problem at the time)
17:34:35 * Riastradh gives up trying to make his hooks and new karma module work.
17:35:26 <Darius_> lambdabot: @eval (\S K I a o.(S (S (K S) (K I)) (S (K K) I)) a o) (\f g x.f x (g x)) (\x y.x) (\x.x) 5 (\x.x+10)
17:35:27 <lambdabot> <<EM Dynamic -> EM Dynamic>>
17:35:40 <shapr> Riastradh: think we should try a different hooks implementation?
17:35:48 <SlushP> Where can I get the Util module?
17:35:52 <SlushP> I don't have it
17:36:00 <Riastradh> http://www.bloodandcoffee.net/campbell/code/rias-lambdabot.tar.gz
17:36:10 <Darius_> @fact source
17:36:10 <lambdabot>  http://sf.net/projects/haskell-libs/, http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/lambdabot/
17:36:14 <Riastradh> You can go ahead and try to fix it.  I didn't commit it to CVS so as not to bork what currently works.
17:36:34 <shapr> Riastradh: thanks, that's polite of you :-)
17:36:45 <shapr> we could try branching in cvs
17:36:46 <Darius_> the fix for the parser is in CVS
17:36:52 <shapr> though I've never done that before
17:37:25 <Darius_> SVN folk: hurry up!
17:37:58 <shapr> lambdabot: @quit
17:38:59 <Pseudonym> More and more I wonder if what we want for the modules is Chilli's most excellent Haskell ports library.
17:39:01 <shapr> Darius_: updated and running
17:39:09 <Darius_> lambdabot: @eval (\S K I a o.(S (S (K S) (K I)) (S (K K) I)) a o) (\f g x.f x (g x)) (\x y.x) (\x.x) 5 (\x.x+10)
17:39:10 <lambdabot> 15
17:39:18 <Darius_> tada
17:39:23 * shapr cheers
17:39:24 <Pseudonym> Woohoo!
17:39:36 <Pseudonym> lambdabot: @eval Y I
17:39:36 <lambdabot> unbound variable: Y
17:39:40 <Pseudonym> OK.
17:39:51 <Pseudonym> lambdabot: @define Y (\f.f (Y f))
17:39:52 <lambdabot> Y defined
17:39:54 <Pseudonym> lambdabot: @eval Y I
17:39:55 <lambdabot> unbound variable: I
17:40:01 <Pseudonym> Oh.
17:40:06 <Pseudonym> lambdabot: @define I (\x.x)
17:40:06 <lambdabot> I defined
17:40:07 <Pseudonym> lambdabot: @define Y (\f.f (Y f))
17:40:07 <lambdabot> Y defined
17:40:10 <Pseudonym> lambdabot: @eval Y I
17:40:10 <Darius_> @definitions
17:40:10 <lambdabot> out of fuel
17:40:10 <lambdabot> ["I","Y"]
17:40:12 <Pseudonym> There we go.
17:40:22 <Riastradh> @define S \f g x. (f x) (g x)
17:40:22 <lambdabot> S defined
17:40:35 <Pseudonym> lambdabot: @define B (\f g x.f (g x))
17:40:35 <lambdabot> B defined
17:40:45 <Pseudonym> lambdabot: @define B (\f x y. f y x)
17:40:45 <lambdabot> B defined
17:40:46 <shapr> Riastradh: should I tell lambdabot to join #scheme as well?
17:41:02 <Darius_> C?
17:41:04 <Pseudonym> Not until eval handles s-expressions.
17:41:07 * shapr grins
17:41:11 <Pseudonym> lambdabot: @define C (\f x y. f y x)
17:41:11 <lambdabot> C defined
17:41:12 <Pseudonym> lambdabot: @define B (\f g x.f (g x))
17:41:12 <lambdabot> B defined
17:41:13 <Pseudonym> Thanks.
17:42:58 <shapr> lambdabot: @eval Y I K E S
17:42:58 <lambdabot> out of fuel
17:43:36 <Riastradh> @definitions
17:43:36 <lambdabot> ["B","C","I","S","Y"]
17:43:45 <Riastradh> E?
17:43:54 <shapr> I had to get creative to come up with a word :-)
17:44:04 <Darius_> @get-definition S
17:44:04 <lambdabot>  \f g x. (f x) (g x)
17:44:06 <Riastradh> Quick!  Define an E combinator!
17:44:19 * shapr snickers
17:44:29 <Darius_> @get-definition E
17:44:29 <lambdabot> E not defined
17:44:38 <Riastradh> By the way, the eval module should store its definitions in an external file, so they can be reused later.
17:45:52 <Darius_> ya, that was coming up.  Right now I'm thinking about data structures
17:46:21 <Riastradh> But data structures are just functions.
17:46:25 <Pseudonym> @define ITE (\c t e. if c then t else e)
17:46:26 <lambdabot> ITE defined
17:46:30 <Riastradh> Persistent definitions are more important.
17:46:38 <Pseudonym> @define MUL (\x y. x * y)
17:46:38 <lambdabot> MUL defined
17:46:45 <Pseudonym> @define SUB (\x y. x - y)
17:46:46 <lambdabot> SUB defined
17:47:02 <Pseudonym> @eval  Y (B (S (C (B ITE (C EQ 0)) 1)) (B (S MUL) (C B (C SUB 1)))) 5
17:47:03 <lambdabot> unbound variable: EQ
17:47:08 <Pseudonym> Damn.
17:47:17 <Pseudonym> @define EQ (\x y. x == y)
17:47:17 <lambdabot> EQ defined
17:47:21 <Pseudonym> @eval  Y (B (S (C (B ITE (C EQ 0)) 1)) (B (S MUL) (C B (C SUB 1)))) 5
17:47:21 <lambdabot> 120
17:47:24 <Pseudonym> Woohoo!
17:47:31 <Pseudonym> Factorial lives.
17:48:07 <Riastradh> Bah, silly Bs and Cs.
17:48:11 <Riastradh> Go S and K!
17:48:23 <Pseudonym> I have a version that uses B* and C' too.
17:48:37 <Pseudonym> We need to be practical here, after all.
17:49:21 <Pseudonym> What ever happened to Research Software Ltd?
17:49:56 <shapr> the miranda guys?
17:50:06 <Pseudonym> Well, the miranda guy. :-)
17:50:28 <shapr> 'twas before my time in the FP world.
17:51:50 <shapr> my question of the moment is how to calculate the third FiniteMap in paul graham's "A Plan for Spam" article.
17:52:19 <Darius_> Miranda* would seem more correct :P
17:52:22 <Darius_> (*Miranda is a registered trademark of Research Software Ltd.)
17:55:23 <SlushP> Can someone be a little more specific with regard to the use of "lines" in my problem:
17:55:32 <SlushP> ...making a list of strings, from one string which is delimited \n\n (ie. a blank line)?
17:56:33 <shapr> Did you look at the Util.hs module in haskell-libs cvs tree?
17:57:49 <Darius_> lines "aeu\naoeu\n\naou" == ["aeu","aoeuA",[],"naou"]
17:58:16 <Darius_> [] is also "" (for Char's)
17:58:28 <shapr> yah, that's probably a simpler solution
17:58:38 <shapr> use break with that
17:59:18 <shapr> hi shreya
17:59:50 <buggy> hey shapr
17:59:55 <Pseudonym> G'day.
18:00:05 * Pseudonym wonders what would happen if buggy and debug logged on at the same time
18:00:21 <buggy> hehe pseudonym
18:00:23 <Pseudonym> Would they annihilate each other?
18:00:47 <shapr> I think it's more a yin and yang thing
18:01:18 <Darius_> nah, buggy would just appear elsewhere
18:01:22 * shapr grins
18:02:56 * shapr doesn't understand this CL code
18:03:42 <buggy> I have a problem too which I can't think of a way to solve, anyone care to hear in on it and give me a hand? :(
18:03:50 <shapr> ask your question
18:03:58 <shapr> the oracle might even respond
18:04:30 <Pseudonym> You owe the Oracle a woodchuck exterminator.
18:04:41 * shapr grins
18:05:01 <shapr> Pseudonym: soooo, do you know anything about Bayesian statistics? =)
18:05:30 <Pseudonym> Oh, geez.  Uhm...
18:05:46 <Pseudonym> Only its application to information theory.
18:05:55 <Pseudonym> Data compression and modelling, that sort of thing.
18:06:06 * Pseudonym didn't do much AI
18:06:07 <buggy> heh ok well I have a function between i j xs which takes all the crap between the i and jth elements of xs, not including i and j
18:06:09 <Pseudonym> Which is odd for a logic programmer.
18:07:47 <buggy> Now I have a function :: [(Int, Int)] -> [a] -> [[a]] which takes an array of pairs, and maps between fstelem sndelem to the list generating a list of lists
18:07:52 <Pseudonym> OK.
18:07:52 * Pseudonym will need a more specific definition of "the crap", but this will do for now
18:08:05 <Pseudonym> OK.
18:08:24 <buggy> ok that's the bit I'm stuck on, I can't think of a way to get the fst and snd thing out with map
18:08:38 <shapr> I'm writing a Paul Graham spam filter now that Peter Simons wrote an RFC2822 parser
18:08:38 <shapr> buggy: and?
18:08:39 <Smerdyakov> Good. Paul Graham sends me way too much spam.
18:08:39 * shapr snickers
18:09:04 <Pseudonym> Er...
18:09:21 <Pseudonym> So let me get this straight.
18:09:56 <Pseudonym> thisFunction [(1,1),(2,3)] "Hello" = ["H","el"]?
18:10:02 <Pseudonym> Pretty much?
18:10:55 <buggy> well the between function takes everything between the i and jth elements, but not the i and jth elements so between 1 2 "hello" would be ""
18:11:03 <Pseudonym> Oh, OK.
18:11:29 <Pseudonym> Can you a) not write a function to do this, or b) not write a function to do this efficiently?
18:11:39 <buggy> b)
18:11:43 <Pseudonym> Right.
18:12:03 <buggy> well not inefficiently, but not elegantly :P
18:12:25 <Smerdyakov> Watch out for elegance.
18:12:29 <Pseudonym> What are you planning to use the return value for?
18:12:30 <Smerdyakov> Sometimes it's a cover for nefariousness.
18:13:04 <Darius_> Nefarious Haskell
18:13:30 <buggy> umm... some html parser thing, I'm actually doing a first year unit's assignment to stay in tune with haskell (I'm in second year now) and basically the assignment just makes us build a variety of functions given a specification and the program will just work :)
18:14:04 <Pseudonym> Aha.
18:14:55 <Pseudonym> OK.
18:15:06 <Pseudonym> Well, the first obvious solution is to write:
18:15:15 <Pseudonym> someOtherFunction :: (Int,Int) -> [a] -> [a]
18:15:33 <Riastradh> Perhaps you should name it 'sublist.'
18:15:54 <Pseudonym> someOtherFunction (i,j) = take (j-i-2) . drop i
18:15:57 <Pseudonym> I think.
18:16:01 <Pseudonym> Might be an off-by-one there.
18:16:14 <buggy> I just did:
18:16:16 <buggy> between :: ListIndex -> ListIndex -> [a] -> [a]
18:16:17 <buggy> between i j xs = drop (i+1) (take j xs)
18:16:23 <Pseudonym> There you go.
18:16:38 <buggy> should I just add an extra one, someOtherFunction :: (ListIndex, ListIndex) -> [a] -> [a]
18:16:39 <Pseudonym> Then use:
18:16:51 <buggy> someOtherFunction (i, j) xs = between i j xs
18:17:08 <Pseudonym> No, that's cool.
18:17:20 <Pseudonym> [ between i j xs | (i,j) <- idxs ]
18:17:28 <Pseudonym> That's pretty elegant.
18:18:07 <buggy> ahh so there is no way to break apart the tuple without list comprehension?
18:18:15 <buggy> hmmm I think I am just making it more confusing than it is
18:18:18 <Pseudonym> No, there are lots of ways.
18:18:29 <Pseudonym> map (\(i,j) -> between i j xs) idxs
18:18:41 <Pseudonym> For example.
18:18:43 <buggy> ahhh that's the thing I was thinking of but I couldn't remember, that lambda symbol
18:19:04 <Pseudonym> Pity that @eval can't handle tuples.  Could demonstrate it. :-)
18:19:14 <buggy> We hadn't learnt it last year when I did the unit, I think shapr explained to me how to use it before but I forgot :(
18:19:18 <Darius_> you could use a where or let clause
18:19:28 <Pseudonym> Or a case statement.
18:19:50 <Pseudonym> Or another function, like you did there.
18:21:28 <buggy> thanks pseudo and everyone else who helped!
18:21:37 <Pseudonym> No prob.
18:21:40 <buggy> I have just realised how much practice I need with haskell again :(
18:22:34 <Darius_> @listmodules
18:22:34 <lambdabot> I have the following modules installed: ["eval","fact","fortune","hello","karma","more","searchml","state","system","topic","type"]
18:24:13 <Riastradh> Sqwuuux.
18:26:28 <shapr> I think Ketil hasn't used FMs much
18:26:48 <Darius_> @listcommands type
18:26:48 <lambdabot> Module type provides the following commands: ["type"]
18:28:31 <Riastradh> Still no type-from!
18:28:46 <shapr> yah, we gotta bug pesco about that.
18:29:25 <Darius_> hmm it would be nice to have a moduleDestroy or some such
18:29:37 <shapr> yah, I agree.
18:29:52 <Darius_> is @type still insecure?
18:30:30 <shapr> I know it's changed interface, I don't know if it's secure now.
18:30:45 * Igloo returns - sorry about earlier
18:31:19 <Pseudonym> You did something apology-worthy?
18:31:27 <Pseudonym> Sorry I wasn't here to see it.
18:31:39 <Igloo> I was in a bad/tired mood
18:34:02 <Igloo> Hmmm, there's no order I can put my code such that all the dependencies will work out
18:34:30 <Igloo> And I really don't want to hack around it with mutually recursive modules
18:38:41 <Pseudonym> Curse these so-called Haskell implementation which don't like plain Haskell.
18:39:24 <Igloo> You mean by not supporting mutually recursive modules nicely?
18:39:39 * Pseudonym nods
18:39:55 <Pseudonym> Well, not supporting mutually recursive modules without some extra-Haskell code.
18:40:40 <Igloo> I don't think it should have gone in if it wasn't implementable easily
18:40:52 <Igloo> Easily and efficiently, that is
18:40:55 * Pseudonym nods
18:41:21 <Pseudonym> Basically, Haskell is a bit too lax with its required declarations.
18:41:36 <Pseudonym> If it's exported from a module, it must have a type declaration.
18:41:45 <Pseudonym> That way, you need no inter-module analysis to compile a program.
18:42:05 <Igloo> Works for me
18:42:21 <Igloo> For your next trick, remove the need for the monomorphism restriction  :-)
18:43:03 * shapr grins
18:43:39 <Riastradh> What -is- this 'monomorphism restriction?'
18:44:26 <Smerdyakov> Is it like the ML value restriction?
18:44:38 <Igloo> What's the ML value restriction?
18:45:14 <Igloo> The MR basically says something will be given a monotype (one without type variables) in certain circumstances where otherwise you would think it was polymorphic
18:45:14 <SlushP> I'm still having problems.
18:45:19 <Riastradh> f = g x, if g has a type of 'a -> 'b -> 'c, f has a type of '_b -> 'c.
18:45:21 <SlushP> Can anyone give me further suggestions?
18:45:34 <Riastradh> When you first call f, the '_b turns into whatever the type of the parameter you called f with was.
18:45:55 <Smerdyakov> Yup, that's the value restriction.
18:45:58 <Igloo> That sounds similar, but it happens at compile time
18:46:23 <Smerdyakov> I think they are the same, Igloo, at least insofar as where they apply.
18:46:28 <Smerdyakov> There is no runtime component.
18:46:56 <Igloo> The definition is given in the report if you're interested
18:47:03 <Smerdyakov> Riastradh, was that OCaml? SML removed those special type variables in the '97 revision and just said you can't make such bindings.
18:47:18 <Riastradh> Smerdyakov - That was indeed OCaml.  I don't know SML.
18:47:49 <Smerdyakov> The reason for all of these restrictions is that you can get type unsafety when you combine mutability (inside a monad or elsewhere) with polymorphism, if you aren't careful.
18:48:34 <SlushP> Using lines "first \n\n 2nd \n\n third goes \n on \n and on"
18:48:36 <SlushP>  I get ["first ",""," 2nd ",""," third goes "," on "," and on"]
18:48:46 <Smerdyakov> The usual example is creating a reference cell with a polymorphic type.
18:48:58 <Smerdyakov> It is Very Bad if you can write to it thinking it has one type, then read from it thinking it has another.
18:49:21 <Riastradh> SlushP - Yes -- is that a problem?
18:49:23 <SlushP> but I need ["first "," 2nd "," third goes \n on \n and on"]
18:49:35 <Riastradh> filter (=="") $ lines str
18:49:52 <Riastradh> Er.
18:49:54 <SlushP> So only the \n\n (blank lines) delimit the strings.
18:50:38 <shapr> y0 flippo 
18:50:46 <shapr> write a plugin for lambdabot :-)
18:50:50 <Riastradh> filter won't work right...is there a 'remove' or 'delete' or something?
18:50:57 <Darius_> map unlines . filter (=="") . lines (may work)
18:51:18 <Darius_> er no it won't
18:51:30 <SlushP> hmmm
18:51:34 <flippo> shapr: I thought I was talking to you in #haskell just now.  Little did I know you hang in #python as well.
18:51:50 <Riastradh> Blasphemous Pythoner!
18:51:52 <shapr> I started in #python many many years ago
18:52:07 <shapr> back when it was  eleven people on EFNet
18:52:10 <Smerdyakov> Couldn't be too many, if it was on OPN. :P
18:52:35 <shapr> Smerdyakov: we all migrated at some point
18:52:39 <Smerdyakov> Hm. Couldn't be too many if it was on EFNet, either =)
18:52:50 <Riastradh> filter (\x -> not (x == "")) $ lines str
18:52:55 <shapr> how old is EFNet?
18:53:01 <Riastradh> Too old.
18:53:08 <flippo> shapr: I'm still waiting for Thompson's book to be reprinted.  Dang.  This isn't right.
18:53:26 <Smerdyakov> 1990
18:53:47 <Pseudonym> Before my time.
18:53:52 <Pseudonym> By a year.
18:53:52 <shapr> I looked through Hudak's book in greater detail, I think I like it.
18:53:58 <Riastradh> What, you were born in 1991?
18:54:01 * shapr grins
18:54:09 <Pseudonym> Virtually, I suppose.
18:54:23 <Pseudonym> Might have been 1992.
18:54:25 * Pseudonym thinks
18:54:31 <shapr> I got on IRC first time in 88 or 89
18:54:32 * Riastradh hehs evilly, but won't say why.
18:54:42 * Riastradh hehs even more evilly, but still won't say why.
18:54:45 <Pseudonym> Evil never needs justification.
18:54:46 <Smerdyakov> I got on IRC first in 96.
18:54:56 <shapr> Smerdyakov: wow, how old are you?
18:55:02 <Smerdyakov> 21
18:55:07 <shapr> cool
18:55:08 <Pseudonym> I got in IRC first in about 94, for about 10 mins.  Then didn't touch it again until 2001.
18:55:16 <flippo> shapr: I don't like hudak's book.  Graphics seem like unnecessary unportable flash for those with short attention spans
18:55:26 <shapr> possibly so
18:55:31 <Pseudonym> Back in those days, IRC was the biggest bandwidth killed in undergrad computer labs.
18:55:32 <shapr> but the Haskore stuff is very nifty
18:55:50 <Smerdyakov> A lot of CS majors here don't know what IRC is.
18:55:51 <Smerdyakov> But a lot do.
18:55:55 <Pseudonym> So we couldn't really use it.
18:56:03 <shapr> flippo: well, you could jump into writing a lambdabot plugin and use Hudak as reference.
18:56:09 <Kuril> I got on in about '95.
18:56:10 <shapr> or ask here on #haskell
18:56:23 <SlushP> How do I replace the "," with the \n character, which lines changes? In other words, how do I get the single newline character back, from a comma?
18:56:50 <shapr> lambdabot plugins are fun and easy to write. (imho)
18:58:02 <shapr> flippo: http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/lambdabot/HelloModule.hs
18:58:47 <shapr> ten lines without blanks/comments
19:00:34 <Darius_> SlushP: you can use lines then use unlines on everything between each ""
19:03:09 <SlushP> That doesn't work...that puts the \n\n back to \n, but I don't want that changed.
19:03:17 <SlushP> How do I get " third goes on "," and on" to be  ->  " third goes on \n and on"
19:03:52 <SlushP> Here:
19:03:54 <SlushP> ITB433Html> filter (\x -> not (x == "")) $ lines "first \n\n 2nd \n\n third goes
19:03:54 <SlushP>  on \n and on"
19:04:26 <SlushP> I only want the \n\n to delimit the string. The single \n I want to stay as it is.
19:04:51 <SlushP> The output of the above code gives: 
19:04:53 <SlushP> ["first "," 2nd "," third goes on "," and on"]
19:06:04 <Igloo> Probably easiest to write a recursive functino to do the splitting by hand
19:07:22 <SlushP> Can you give me a hint as to how I go about doing that?
19:07:31 <shapr> hi cgray 
19:07:54 <shapr> new to Haskell? long time user?
19:08:09 <cgray> hey... kind of new... i don't use it that much...
19:08:16 <Igloo> Slush: Not really, no
19:08:38 <shapr> cgray: looking for resources to learn more?
19:08:55 <cgray> i'm kind of having a problem.  i want to do s11box13 = minimum [x | x <- [0..s11box13prelim],  end < -617.00], where end depends on s11box13
19:09:03 <cgray> but obviously that doesn't work
19:09:53 <shapr> recursive definitions are possible in Haskell
19:10:03 <Pseudonym> Sure.
19:10:08 <shapr> are you trying to build a lazy list?
19:10:15 <cgray> well sure, but this loops forever
19:10:24 <cgray> i'm not sure why
19:10:27 <Igloo> Does end also depend on x?
19:10:45 <cgray> it depends on s11box13, so in a sense it does
19:11:21 <Igloo> To see why, consider what happens when you evaluate it. minimum asks for the first element, which takes 0 from the arith seq and then tests the guard...which immediately needs the answer
19:11:37 <Igloo> If it doesn't depend directly on x then it's either always true or always false
19:12:25 <cgray> oh.  maybe i can change it to depend on x then
19:13:03 <cgray> instead of x, could i call it s11box13?
19:13:45 <Igloo> Yes, at the risk of driving whoever is reading it mad
19:14:01 * shapr snickers
19:14:10 <cgray> hmm.  it still segfaults hugs though
19:14:22 <Igloo> Can you describe what you are trying to do?
19:14:50 <shapr> I have a sudden urge to make a new language called eecummings where capital letters are illegal.
19:15:27 <cgray> Calculate my taxes.  I want to take the least amount of a deduction possible while getting the same refund.
19:15:37 <shapr> oh cool
19:16:20 <shapr> Taxkell
19:16:39 <cgray> Right.  It's worked great so far, but this seems to be pushing it a bit.
19:16:55 <shapr> I've always found Haskell simpler than income taxes.
19:17:08 <Igloo> That's too high level for me to understand
19:17:42 <Pseudonym> In Haskell, the $ operator means something fairly sane.
19:17:56 <Pseudonym> I say "fairly", because of course it has the wrong associativity.
19:18:10 <Pseudonym> But still.  It's more sane than tax forms.
19:18:41 <cgray> Tax forms are pretty much just programs. :)  You just have to parse them.
19:18:44 <shapr> cgray: Do you have your code online somewhere?
19:18:53 * shapr waits for 1040EZ.hs
19:19:27 <cgray> shapr: No, this is not general at all.  It has a lot of my personal info in it.
19:19:38 <shapr> oh, ok
19:20:09 <shapr> Do you work at Acunia?
19:20:25 <cgray> Do I?  No, I'm a grad student at UBC.
19:20:39 <shapr> oh.
19:21:23 <shapr> When I grow, I'll be a grad student too.
19:21:27 <shapr> er "grow up"
19:21:40 <cgray> It's a pretty sweet gig. :)
19:21:55 <shapr> cgray: if privacy issues aren't a problem, could we see the code you have now?
19:22:20 <shapr> or at least a broader definition of s11box13
19:22:50 <cgray> Sure, but you won't understand most of it.  http://www.cs.ubc.ca/~cmg/taxes.hs
19:24:02 <shapr> *Main> main
19:24:02 <shapr> *** Exception: <<loop>>
19:25:01 <cgray> I think without the tax forms, it's fairly unreadable.
19:25:20 <cgray> Yeah
19:25:23 <shapr> what should s11box13 actually do?
19:25:37 <cgray> It should just be a number.
19:26:12 <cgray> The number should be the minimum number that keeps end the same and is less than s11box13prelim
19:26:28 <shapr> ah
19:26:30 <Igloo> The same as what?
19:26:35 <shapr> fix end
19:26:53 <cgray> how?
19:26:56 <shapr> er
19:26:59 <shapr> fixpoint
19:27:03 <shapr> sorry
19:27:15 <cgray> Oh, that's a function?
19:27:25 * shapr is just confused
19:28:05 <cgray> Sorry.  I thought you meant I should do that.
19:28:11 <shapr> you want to find the smallest input to s11box13 that gives 617 as an output
19:28:30 <shapr> yes?
19:28:33 <cgray> Right
19:28:44 <Igloo> And it's non-decreasing presumably?
19:28:59 <cgray> Right.
19:29:16 <Igloo> And there is a maximum input m?
19:29:23 <cgray> yup
19:29:49 <Igloo> Is there always an acceptable answer?
19:30:43 <cgray> I think
19:30:53 <cgray> I'm not sure I understand though.
19:30:57 <Igloo> (fst $ filter ((== 617) . snd) $ map (\x -> (x, f x)) [0..m]) - 1   give or take
19:31:23 <Igloo> Oh, that filter should be /=, not ==
19:31:46 <Igloo> Or maybe > depending on what you really mean
19:33:05 <cgray> Where f is end?
19:33:27 <Igloo> Maybe
19:33:48 <Igloo> Yes
19:34:00 <cgray> Yeah, I'm not sure, because f doesn't actually take any arguments.
19:35:14 <Igloo> If it has a free variable then bind that with a lambda and that's probably what I mean
19:40:21 <shapr> what's up with using multiple guards in a list comp?
19:42:37 <shapr> actually, how do I use guards at all in a list comprehension?
19:42:58 <Igloo> What are you trying?
19:43:04 <Darius_> ... , (e :: Bool)]
19:43:09 <Igloo> [ x | x <- [1..], even x ]
19:43:22 <shapr> ohh
19:43:36 <shapr> spifffy
19:44:04 <shapr> I wanted to rewrite cgray's s11box13 as a single list comp
19:44:48 <cgray> Did it work?
19:44:56 <shapr> not yet
19:46:18 <shapr> actualy, I think I'll go to sleep and look at it again tomorrow.
19:46:19 <shapr> g'nite all.
19:46:36 <shapr> @fact g'nite
19:46:37 <lambdabot> zzzz
19:47:01 <cgray> Igloo: I'm not sure how to bind the variable.
19:48:45 <Igloo> Is end something vaguely like x + 5?
19:49:07 <Darius_> [x | (x,y) <- [(t,f t) | t <- [0..m]], y /= 617]
19:50:22 <cgray> Igloo: vaguely.  
19:50:34 <Igloo> \x -> x + 5 then
19:50:48 <Darius_> lambda lifting
19:53:50 <cgray> Hmm.  Maybe I'll just have to make everything explicitly depend on the variables it uses.  That's kind of disappointing -- it was pretty clean without that.
19:54:27 <Igloo> It sounds worryingly like you want dynamic scope
19:54:39 <cgray> What's that?
19:56:26 * Igloo is too tired to explain now, but you really don't want it and Haskell won't give it to you anyway
19:56:53 <Darius_> dynamic scoping can be handy at times
19:57:58 <Darius_> I don't think this is one of them
19:58:47 * Igloo crawls off to bed
22:40:17 <SlushP> hi guys.
22:40:23 <SlushP> can i get somoeone to help me again?
22:40:42 <SlushP> I couldn't get that answer to work.
22:48:23 <dennisb> Ask the question instead and maybe someone will help, noone is going to promise to answer a question that they don't know yet
22:50:28 <SlushP> I've got this string:
22:50:41 <SlushP> "first \n\n 2nd \n\n third goes \n on \n & on".
22:50:56 <SlushP> And the output has to be like this:
22:51:22 <SlushP> ["first "," 2nd "," third goes \n on \n & on"]
22:51:34 <SlushP> But, I've used this function:
22:51:43 <SlushP> (filter (\x -> not (x == "")) . lines) s
22:52:05 <SlushP> And I can only get this -> ["first "," 2nd "," third goes "," on "," & on"]
22:52:20 <SlushP> So, those last two commas should be \n
22:52:43 <dennisb> yes, the filter removes all the "", I can see why you get that result
22:53:24 <SlushP> So, the output that I am (wrongly) getting, should display newline characters for the last two commas.
22:53:44 <SlushP> eg, the result should be -> ["first "," 2nd "," third goes \n on \n & on"]
22:53:44 <dennisb> so, do you have an idea of how to solve (not in haskell but in english)
22:53:59 <SlushP> I thought I did, but it doesn't seem to work. 
22:54:07 <SlushP> I thought of using line, then filtering the ""
22:54:10 <SlushP> and then using unlines.
22:54:23 <SlushP> But that just puts \n everywhere, which is wrong.
22:55:26 <dennisb> yes, that wont work since both ["a","","b","c"] and ["a","","b","","c"] is the same after the filter, yet they should give different result
22:56:32 <SlushP> Ok
22:56:47 <dennisb> the first way to do this seems to start from left in the list and collect strings until you find "", that's the first part of the output. Then you can continue with the next part, and so on
22:57:08 <dennisb> SlushP: I guess you can see why filter doesn't work?
22:57:15 <SlushP> No, I can't.
22:57:39 <dennisb> what does filter (\x -> not (x == "")) do?
22:58:27 <dennisb> which can also be written: filter (\x -> x /= "")
22:58:47 <arguile> Get's rid of empty stings 
22:58:52 <arguile> from a list of strings
22:58:56 <dennisb> right!
22:59:21 <SlushP> Yeah
22:59:21 <arguile> Ohh... sorry I thought that was a general question
22:59:21 <arguile> Heh
22:59:23 <SlushP> Sorry
22:59:31 <dennisb> filter uses a predicate to select which elements to keep in a list, this example keeps all the non-empty strings
22:59:38 <SlushP> Yep
23:00:16 <dennisb> then if you run filer on ["a","","b","c"] you get ["a","b","c"] and also if you run it on ["a","","b","","c"] you get ["a","b","c"]
23:00:56 <dennisb> so you will get the same end result when you run lines in the end even though you expected to get different results
23:01:08 <SlushP> I understand that, luckily. hehe
23:01:10 <SlushP> So, with your suggestion above, about working from the left in the list and collecting strings till I find ""...well do I do lines first?
23:01:19 <SlushP> Well, of course I do.
23:01:30 <dennisb> yes
23:01:53 <dennisb> otherwise you don't have the list of strings to work with (but I can imagine other solutions that work on the string directly)
23:02:06 <dennisb> there are as many solutions as there are people on earth
23:02:10 <SlushP> You say collect the "", right? Well, what do I do with them? Don't I just filter them out like I did? Because my problem seems to be with with single \n characters.
23:03:46 <dennisb> I would probably try to break the problem up in two parts (that is the key to programming). First write a function that takes a [String] as above and consume the first part of that list to produce the first result
23:04:20 <dennisb> so if you send in the list ["a","b","","c"] the function would return "a\nb"
23:05:20 <dennisb> or even better it can return a pair ("a\nb", ["c"]) which is the result and the rest of the input list that it didn't use
23:05:45 <dennisb> this makes it easy to continue working on the rest to get the next part
23:05:54 <kawfee> anyone here know how to use latex with new fonts?
23:06:02 <SlushP> hmmm
23:06:09 <SlushP> Ok. I'll give it a go. Thanks Dennis.
23:06:44 <dennisb> kawfee: latex is like woodoo, you probably have to sacrifice a chicken
23:06:51 <kawfee> or a lamb
23:07:00 <dennisb> yes, a lambda
23:07:09 <Earl> latex is beauty.  
23:07:44 <SlushP> Dennis: sorry, I think you've misread my problem:S Um...I need to output a list, and input a string. 
23:08:05 <kawfee> yeah
23:08:06 <kawfee> lambda
23:08:18 <SlushP> And, can you give me any hints how to KEEP the \n instead of lines converting it to ","
23:08:19 <SlushP> ?
23:08:25 <dennisb> SlushP: well, I tried to break it up into smaller piece. You can use the help function above to create a list with the results
23:09:01 <dennisb> you don't konvert the \n to a ",", you convert it to a list of strings. The , is part of the list syntax
23:09:55 <dennisb> well, if you don't convert it to a list of strings you can solve it in almost the same way. Starting from the left and collect characters until you find \n\n
23:10:04 <SlushP> If I use lines, it takes away my \n, so do I not use lines in the above function?
23:10:07 <arguile> You're seeing a strinified reprensentation of the data (through the show function to be exact)
23:10:23 <arguile> It doesn't actually have quotes or commas in it
23:12:01 <SlushP> Hrmm...maybe I should just ask how I "find" the two consecutive newline characters "\n\n"? Because I tried break and filter and couldn't work out what I was doing wrong.
23:12:09 <dennisb> [1,3,4] is a list with integers in it, ["1","3","4"] is a list with strings in it. The , is part of the list syntax; [ elem1, elem2, elem3 ]
23:12:56 <dennisb> break can only look at one character in a string (but you could use break on the list of strings you got after running lines)
23:14:19 <SlushP> Ok. I think I understand that little bit. But, how would I then go about making the single \n which were changed to , after using lines, back to the \n ?
23:14:56 <SlushP> As in: ["first "," 2nd "," third goes \n on \n & on"]
23:16:01 <dennisb> I don't agree with the explanation that \n got changed to ,
23:16:50 <SlushP> well you know what i mean
23:16:56 <dennisb> you can not convert the , in a list to anything really, the , is not an element in the list that you can work with
23:16:58 <SlushP> when you use lines, the syntax changes:)
23:17:05 <dennisb> yes
23:17:13 <SlushP> so how do I change it back to a \n ?
23:17:17 <dennisb> unlines
23:17:25 <SlushP> as in the expected output that i pasted above? :S
23:17:26 <SlushP> Oh
23:17:32 <SlushP> But I used that and it didn't work:(
23:17:41 <SlushP> Of course, I am using it incorrectly.
23:17:42 <dennisb> but it will just turn it back to the start string of course
23:18:13 <SlushP> Yeah, so how do I use it properly for my expected output?
23:18:39 <dennisb> you have to split up the list into smaller parts, each that you can run unlines on
23:18:58 <SlushP> can you please just reiterate what those smaller parts are?
23:19:00 <SlushP> sorry:)
23:19:28 <SlushP> because this is what i got for my function:
23:19:28 <SlushP> Planner> (unlines . filter (\x -> not (x == "")) . lines) "first \n\n 2nd \n\n t
23:19:28 <SlushP> hird goes \n on \n & on"
23:19:28 <SlushP> "first \n 2nd \n third goes \n on \n & on\n"
23:19:48 <dennisb> first part ["first "], second part [" 2nd "], third part [" third goes ", " on ", " & on"]
23:20:05 <SlushP> yeah, so lines.
23:20:07 <SlushP> I get that
23:20:11 <SlushP> I've got that*
23:22:44 <SlushP> ?
23:23:17 <dennisb> so you have ["first ",""," 2nd ",""," third goes "," on "," & on"]
23:23:26 <SlushP> Yeah
23:23:48 <dennisb> lets call it  ["a","","b","","c","d","e"]
23:24:03 <SlushP> pl
23:24:07 <SlushP> ok i mean
23:24:15 <dennisb> and you want [ ["a"],  ["b"],  ["c","d","e"] ]
23:24:38 <SlushP> OOOk. I'll take your word for it. No, I get that.
23:24:45 <SlushP> I mean, understand that.
23:24:47 <dennisb> so that you can run unlines on each part to get the strings with \n in them
23:25:29 <dennisb> now, how would we get that list that we want?
23:25:51 <SlushP> I don't know:)
23:25:54 <SlushP> shit
23:25:56 <SlushP> I mean :(
23:26:02 <SlushP> Cos i'm not winning lol
23:26:02 <dennisb> I would not try to produce everything at once, it's too hard. Instead I would write a function that produces the first result
23:26:37 <dennisb> I would write a function that takes as input ["a","","b","","c","d","e"] and returns a list of all elements until the first ""
23:27:17 <dennisb> this would give me the first result in the end list [ ["a"],  ["b"],  ["c","d","e"] ] (that is, the first result is ["a"])
23:27:42 <dennisb> so, write a function that given ["a","","b","","c","d","e"] gives ["a"]
23:28:10 <dennisb> and for input ["a","b","","foo"] would give ["a","b"]
23:29:02 <dennisb> then one can use this function many times to get all the elements in the end list
23:40:05 <SlushP> I'm trying:) lol
23:43:16 <dennisb> No worries, it's hard for everyone in the beginning. Also, the exact function I hinted above might needs to be change a little (but just a little). But that is how it is. One can't just sit down and write a solution in one go
23:43:26 <dennisb> Programming is an iterative process
23:44:41 <SlushP> I'm using lines, but nothing I can think of is working to allow me to get a string of words up until the first ""
23:44:43 <SlushP> :S
23:44:50 <SlushP> Break doesn't work:(
23:45:37 <dennisb> are you sure?
23:45:55 <SlushP> > test :: String -> [String]
23:45:56 <SlushP> > test s = (break (=="") . lines ) s
23:46:28 <dennisb> try it in hugs instead (or maybe you use ghci?)
23:46:35 <SlushP> I'm in hugs
23:46:55 <dennisb> break (=="") ["a","b","","c"]
23:47:06 <dennisb> what do you think is the answer?
23:47:23 <dennisb> and what does hugs think?
23:48:16 <SlushP> Wait, could you make the input just a string, and not a list?
23:48:24 <SlushP> Otherwise I might confuse myserlf
23:48:25 <SlushP> Otherwise I might confuse myself
23:49:08 <SlushP> If the input is a String, the answer I think would be ["a", "b", "c"]
23:49:09 <dennisb> break (=="") (lines "a\nb\n\nc")
23:49:35 <SlushP> Oh, the answer to the list is 
23:49:35 <SlushP> ITB433Html> break (=="") ["a","b","","c"]
23:49:35 <SlushP> (["a","b"],["","c"])
23:49:44 <SlushP> I'll have a look at the String now
23:50:13 <dennisb> so break returns a pair of two things, still in you function test you seem to think that break returns a list
23:50:14 <SlushP> Ok, that looks good.
23:50:33 <SlushP> Oh yeah. Whoops
23:50:42 <dennisb> I guess you got a type error?
23:50:43 <SlushP> Sorry to be a pain
23:50:46 <SlushP> Yeah
23:50:58 <SlushP> [String] -> [Char,Char] or something
23:51:01 <dennisb> maybe even something like (a,b) does not match [String]
23:51:09 <SlushP> Yeah, that sounds like it.
23:51:27 <dennisb> well, something that a pair is not a list
23:53:09 <SlushP> I see.
23:53:46 <SlushP> Ok, so now I know how to extract strings which precede the ""
23:54:12 <SlushP> But, when I put this into my code, it won't work because I have to have the output as one list of String
23:54:15 <dennisb> ok, and that was just a small part!
23:55:05 <SlushP> So if I do this to each part of the list, will my output then be [String] ?
23:55:21 <dennisb> so you can use it to get the first part, how do you call it to get the next part out?
23:56:19 <dennisb> you have to call it with another list this time, where the first part have been removed
23:56:36 <SlushP> But I can't use tail because it will only lost the first element:(
23:56:37 <SlushP> :S
23:56:49 <SlushP> snd?
23:56:52 <dennisb> and if you look on break you see that it returns two things, the people ho created break where smart!
23:57:51 <SlushP> yeah, two lists ([],[])
23:58:28 <dennisb> then it's just a matter of writing a recursive function that goes through your list and picks out part, after part, and put's them in a result list
23:59:18 <SlushP> i'm not sure who to call the next part of the string
23:59:26 <SlushP> snd, tail etc? :S
23:59:33 <andersca> morning dennisb
23:59:42 <dennisb> The rest is also a big job. I can't help you more at the moment though (sorry). I have work that I have do
