00:39:34 <Vincenz> hi
01:16:50 <Vincenz> :)
01:16:55 <Vincenz> lambdabot: @karma
01:16:55 <lambdabot> I can't find the karma of nobody.
01:17:04 <Vincenz> lambdabot: @karma- nobody
01:17:04 <lambdabot> nobody's karma has been decremented.
01:17:05 <Vincenz> lambdabot: @karma
01:17:06 <lambdabot> I can't find the karma of nobody.
01:17:09 <Vincenz> damn
01:18:38 <mgoetze> lambdabot: @karma nobody
01:18:38 <lambdabot> nobody has a karma of -1
01:21:37 <Vincenz> I know, but...
01:21:42 <Vincenz> lambdabot: @karma
01:21:42 <lambdabot> I can't find the karma of nobody.
01:21:52 <Vincenz> see -> I can't find the karma of _nobody_
01:25:55 <mgoetze> Vincenz: go ahead and fix it then :)
01:26:10 * mgoetze thinks "@karma" should equate to "@karma lambdabot"
01:28:42 <Vincenz> mgoetze: I don't know one iota of haskell
01:28:47 <Vincenz> (I'm learning ocaml :P )
01:29:40 <Vincenz> I just happen to like this channel
02:20:27 * andersca bounces
02:23:18 * Arnia thinks that bouncing is catching
02:24:21 <Marvin--> anyone here familiar with haskell.sty?
02:25:12 <mgoetze> Marvin--: is that similar to pig.sty?
02:25:36 * Marvin-- bonks mgoetze
02:25:42 <mgoetze> :P
02:29:57 <Marvin--> I'm trying to do things like  \left[\hsif{...}\right]  but I get lots of extra space
02:51:17 <shapr> yay, I fixed my keyboard temporarily
02:51:22 <shapr> goood morning #haskell!
02:51:51 * Arnia bursts into applause
02:52:01 <shapr> hi Arnia, what's up?
02:52:20 <Arnia> Ah, learning software engineering stuff :(
02:52:21 <shapr> I think we should make up a name for combinators that works like Java Beans
02:52:30 <shapr> how about calling them Chickens?
02:52:36 <Arnia> Chickens?
02:52:37 <shapr> then we could talk about Currying Chicken
02:52:40 * shapr laughs
02:52:46 * Arnia groans
02:52:52 <shapr> Curried Chickens =)
02:53:33 <Arnia> Hmm... I was thinking about the possibility of arrowised network IO
02:53:38 <shapr> Arnia: have you been reading the lambdabot TODO ?
02:53:49 <Arnia> No...
02:54:18 <shapr> that's one the entries
02:55:18 <shapr> I want to switch lambdabot to using arrows as much as possible
02:55:49 <shapr> Darius suggested that happen in a cvs branch, because it might take several tries
02:56:43 <shapr> Arnia: do you have some experience using arrows?
02:57:01 <Marvin--> do you have experience using *branches in cvs*? ;)
02:57:08 <shapr> no :-)
02:57:11 <Marvin--> cvs sucks at branching
02:57:13 <Arnia> I'd agree... I think a good project for #haskell would be the development of an application framework (in the style of twisted) to encourage development of applications with haskell
02:57:24 <shapr> Arnia: ok, let's do it... we can start with lambdabot 
02:57:33 <shapr> we can integrate lambdabot and HWS-WP
02:58:04 <shapr> hm, instead of twisted
02:58:14 <shapr> what do you call klein bottles, since they're inside themselves?
02:58:21 <shapr> something like 3D recursion?
02:58:35 <Arnia> shapr: I think the GUI side of the framework should be based on Fruit and, in fact, the behavioural side should be done using AFRP.
02:58:48 <shapr> Arnia: I agree
02:59:43 <Arnia> shapr: Hudak and Elliot will probably want to know about this if we pull it off
03:00:14 <mgoetze> so, i shall be gone for the weekend
03:00:18 <shapr> it'll take me awhile to get anything figured out about arrows
03:00:19 <mgoetze> happy hacking, meanwhile
03:00:34 * Marvin-- tries to document his transformations and ends up in \*dots hell
03:00:37 <shapr> mgoetze: going off to spend the weekend with a woman?
03:00:52 <mgoetze> shapr: i wish :(
03:01:06 <Marvin--> mgoetze: don't forget to post a VAC message ;)
03:01:07 <mgoetze> shapr: actually, going to a diplomacy tournament in holland
03:01:17 <shapr> oh, that's cool
03:01:23 <Marvin--> mgoetze: oh wait, you're not official DD yet, are you?
03:01:42 <shapr> Arnia: do you want to create an arrows subdir in haskell-libs and we can throw some arrow code in there to get us started?
03:01:43 <mgoetze> Marvin--: nope, not even in NM yet
03:01:47 <Marvin--> oh
03:01:53 <mgoetze> Marvin--: (at least i have a potential package sponsor, though)
03:02:12 <shapr> if I can get someone to sign my key, I'll create a lambdabot package =)
03:02:17 <mgoetze> Marvin--: i was planning to actually figure out how to make good packages before applying
03:02:23 <Arnia> shapr: Ok, I'll need to be added to the developers list though
03:02:29 <Marvin--> mgoetze: heh
03:02:31 <shapr> Arnia: sure, what's your sf.net user-id?
03:02:37 <Arnia> shapr: Arnia :)
03:02:40 <mgoetze> anyway, have a nice weekend everyone!
03:02:42 <shapr> easy enough
03:02:45 <shapr> have fun mgoetze!
03:02:52 <Arnia> Have fun :)
03:03:14 <Marvin--> shapr: bring your fingerprint when we meet and I'll sign it, shouldn't be a problem
03:03:21 <mgoetze> thanks :)
03:03:53 <shapr> Marvin--: spiffy
03:03:59 <shapr> Arnia: ok, you're in
03:04:31 <Arnia> shapr: Ok, as soon as the cron job adds my permissions, I'll set up the directory
03:04:45 <Marvin--> shapr: or you can contact tao, he's in Umeå
03:04:49 <shapr> you should have privs immediately
03:05:01 <Arnia> Oooh... ok... I'll set it up now then :)
03:05:02 <shapr> Marvin--: tao@d.o ?
03:05:33 <Marvin--> shapr: yes, David Weinehall
03:05:47 <shapr> spiffy, thanks
03:08:13 <Marvin--> *groan* now I'll have to learn about sponsoring too
03:08:22 <Marvin--> I've only sponsored uploads of d-i stuff, and that's kinda relaxed
03:09:00 <shapr> d-i ?
03:09:22 <shapr> debian-internationalization?
03:09:57 <Marvin--> debian-installer
03:10:01 <shapr> oh
03:10:27 <shapr> too bad michaelw doesn't show up here
03:10:42 <Marvin--> ah, it's simply debsign -m, okay, no problem there then
03:11:03 * Marvin-- now knows how to properly sponsor uploads ;)
03:11:09 <shapr> yay!
03:11:16 <Arnia> shapr: Do you want the arrows stuff to be in the libs module or to have its own module?
03:11:20 <Riastradh> Hi.
03:11:57 <shapr> Arnia: I would suggest putting it in the libs module, the idea being that you can get/update/whatever everything with a single checkout/command
03:12:05 <shapr> Arnia: but if you want it in a separate module, that's okay too
03:12:16 <shapr> y0 Riastradh 
03:12:51 <Arnia> shapr: Ok. Will do. What modules in the Arrows Framework do you want to develop initially?
03:13:16 <shapr> any design suggestions for a maildir searching engine in Haskell?
03:13:59 <shapr> Arnia: easiest for me would be simple demos to start with, just doing the basic stuff, and then I'd try to port something existing that I already understand, like lambdabot 
03:14:05 <shapr> then I would start on the framework
03:17:37 <shapr> planetmath
03:17:37 <shapr> hm
03:29:21 <Arnia> shapr: There you go
03:29:32 <Marvin--> GOOD GOD
03:29:36 * Marvin-- boggles
03:30:28 <Marvin--> *29* groups want to play Svenil on gothcon?! Where the heck are we going to find storytellers?!
03:34:07 <shapr> is what's his name running gothcon?
03:34:12 <shapr> LAC's guy?
03:34:37 <shapr> yay, haskell-libs is at 85% active!
03:34:38 <shapr> we're so cool!
03:36:15 <shapr> Riastradh: hey, when will karma be persistent?
03:36:29 <Riastradh> shapr - Oh, I suppose I could try to get that working now...
03:36:49 <shapr> Riastradh: well if you're working on something else, it's not a big deal
03:37:00 <shapr> I was just hoping to steal your persistence code for @fact ;-)
03:37:06 <Riastradh> Heh.
03:37:15 <Marvin--> shapr: Jacob? No, but he did a while back
03:37:16 <Riastradh> I was hoping to do the same from you.
03:37:20 <shapr> oh
03:37:30 <shapr> maybe we should work on that together then
03:38:03 <Riastradh> I just need to know how to do file I/O.
03:40:47 <Riastradh> Where is 'FilePath' defined?
03:41:58 <Riastradh> Oh, it's just a string.
03:49:29 <shapr> Arnia: spiffy!
03:57:35 * Arnia hands shapr what appears to be an infinitely long pipe
03:57:54 * shapr lights up
03:58:30 * Arnia points out the similarity to a signal function
04:33:09 <shapr> y0 pesco 
04:33:11 <pesco> wee
04:34:46 <pesco> ghc is a hard beast
04:35:25 <pesco> GHCi kept on segfaulting.
04:35:38 <shapr> any ideas why?
04:35:51 <pesco> luckily gdb was able to tell me that the segfault occured in a call to dlsym.
04:36:45 <pesco> In the end the problem was the undetected failure of the corresponding dlopen().
04:37:17 <pesco> GHCi appearently dlopens itself to get at the symbols or something.
04:37:28 <Marvin--> scary
04:38:25 <pesco> Anyway the stage one GHC this one was built with had decided that it should (because of arch=powerpc) always pass -static to the linker.
04:38:39 <pesco> And you can't dlopen a statically linked executable.
04:38:42 <shapr> whoops
04:39:05 <pesco> So I went to search for the famous Glorious Driver.
04:39:06 <shapr> doesn't ghci work on ppc mox?
04:39:20 <pesco> No, because mox does'n use ELF.
04:39:23 <shapr> oh
04:40:15 <pesco> At least I think they can't dynload that yet. I haven't been paying attention to that.
04:40:51 <Riastradh> mox?
04:40:55 <pesco> MacOS X
04:41:01 <Riastradh> GHCi works for me.
04:41:09 <Riastradh> (and yes, I'm running OS X on a PPC)
04:41:28 <pesco> Oh, ok I take it they don't need dynamic linking for GHCi on MacOS X then.
04:42:14 <pesco> Anyway I quickly found the part of the driver that inserted the -static and removed it.
04:42:46 <pesco> The result being that now the whole stage 1 GHC 5 segfaulted in any case.
04:44:10 <pesco> The relevant code in DriverFlags.lhs is a big series of guards of the form
04:44:11 <pesco>   
04:44:55 <pesco>   | prefixMatch "mips" cTARGETPLATFORM = return ( ["-static"], ["-fblahblah"] )
04:45:42 <pesco>  | prefixMatch "powerpc" cTARGETPLATFORM = return ( ["-static"], ["-finhibit-size-directive"] )
04:46:06 <pesco> So I inserted a new line before the general "powerpc" case:
04:46:38 <pesco>   | prefixMatch "powerpc-unknown-linux" cTARGETPLATFORM = return ( [], ["-finhibit-size-directive"] ) -- no idea what -finhibitblah does
04:46:44 <Vincenz> ah shapr is back :)
04:46:54 <shapr> where?
04:46:55 <shapr> oh
04:47:10 <shapr> bonjour Vincenz, comment ça va?
04:47:19 <shapr> kan du talar svenska?
04:47:26 <Vincenz> nein
04:47:32 <Vincenz> tres bien, merci
04:47:36 <pesco> The funny part is that with that said line GHC segfaults at the first opportunity.
04:47:42 <Marvin--> shapr: det kan inte du heller uppenbarligen :)
04:48:14 <Marvin--> shapr: "kan du tala svenska?", "kan du prata svenska?" or simply "kan du svenska?"
04:48:23 <shapr> bah, close enough ;-)
04:49:09 <opet> shapr: the worlds of many a stuggling linguist ;)
04:49:20 <Riastradh> The worlds?
04:49:24 <shapr> words
04:49:26 <opet> words, too
04:49:37 <shapr> I think opet is 'stuggling' too ;-)
04:49:41 <opet> argh
04:49:44 <opet> I am
04:49:49 <pesco> Or it did for me. I suspect some dependency got confused and old code linked with the new DriverFlags.o. Or something. I had to leave the PB at home for work so I'll know what came out of a clean rebuild only later today.
04:49:52 <opet> I can't even speak the one language I know
04:50:02 * opet goes back to bed
04:50:05 <shapr> heh
04:50:30 <shapr> pesco: lycka till
04:50:35 <shapr> bonne chance
04:50:42 * pesco .oO("GHC ruined my life")
04:50:46 * shapr laughs
04:51:21 <shapr> or at least your free time
04:51:30 <pesco> Everytime I think "Oh so here it ends, doesn't work, don't know how to fix. So long, let's do something productive" and bounce off to freedom....
04:52:01 <pesco> It comes back to me 10 minutes later with a new idea what might be the problem...
04:52:34 <shapr> heh
04:52:40 <shapr> that's what programming is all about, yeah?
04:52:44 <pesco> Exactly.
04:52:58 <pesco> "Programming ate my social life."
04:53:08 <shapr> I keep thinking "I'll go back to Plan A, be an artist."
04:53:15 <pesco> Heh.
04:53:26 <shapr> then I think, "maybe I'll just read about the S K I combinators some first"
04:53:45 <pesco> Sometimes programming lets you be an artist. Until something doesn't work.
04:53:55 <shapr> art was my first plan
04:54:00 <pesco> It's fiendish.
04:54:00 <shapr> drawing/painting/writing
04:54:15 <shapr> programming a lot more fun though
04:54:18 <shapr> "is"
04:55:03 <pesco> Yah, and I find writing Haskell to be an artistic activity in itself sometimes.
04:55:08 <shapr> truly
04:55:14 <shapr> as you said yesterday
04:55:22 <shapr> the more you rewrite it, the prettier it gets
04:55:26 <pesco> *g*
04:55:50 <shapr> I'm rewriting all the putStrLn calls in lambdabot to debugStrLn 
04:56:05 <shapr> debugStr and debugStrLn are the new console output collectors
04:56:06 <pesco> I'm really thankful for literate Haskell which lets you intersperse all the code with spiffy ASCII art.
04:56:11 <shapr> heh
04:56:29 <shapr> I wish Haddock and the LaTeX .lhs stuff could be mixed somehow
04:57:00 <shapr> I want a literate format that allows for XML and PostScript at the same time
04:57:08 <pesco> Hm...
04:57:26 <shapr> oh I want to extend Haddock to include unit tests as well
04:57:38 <shapr> and write a HWS-WP plugin where you can run them from a browser =)
04:58:37 <shapr> that way we could contribute unit tests to the GHC sources whenever we find a bug
05:01:24 <shapr> Riastradh: I'm now seeing the usefulness of source :: IRCMessage -> a and target :: IRCMessage -> a
05:01:31 <shapr> Riastradh: have you already written them? or should I?
05:05:39 <pesco> Riastradh: Hey, will you switch to powerpc-linux once I get GHC up and running?! ;-)
05:12:54 <pesco> I can't wait to get my kinesis, even if it's not dvorak-labelled.
05:13:24 <shapr> :-)
05:13:30 <shapr> same here
05:14:12 <pesco> Maybe one day they'll make dvorak-labeled keycaps for it that one can buy as an accessory kit. Like PFU has them for the HHKB.
05:14:20 <opet> there's no easy way to save a data structure in haskell, is there? (ala Java's ObjectOutputStream.writeObject())
05:14:46 <pesco> opet: The short answer is no.
05:14:55 <pesco> (I think)
05:16:29 <pesco> But you could derive Read and Show and save your data as text.
05:17:23 <shapr> they're working on it though
05:17:27 <shapr> the Binary module
05:17:32 <pesco> Oh
05:17:42 <pesco> Are they doing it nicely?
05:18:02 <shapr> they're planning on making one module that works the same for GHC,NHC,and Hugs
05:18:14 <shapr> right now there's one for NHC, one for GHC, and they're not compatible
05:18:22 <pesco> Aha.
05:20:24 <pesco> I wonder why NHC doesn't work on powerpc-linux
05:23:53 <pesco> Hope my bug report helps them find out soon.
05:23:53 <pesco> Oh, and I hope Sven Panne finishes the new HOpenGL soon!
05:26:22 <Vincenz> I love Ocaml!!!
05:26:22 <Vincenz> OCaml's sexy
05:26:22 <Vincenz> much better than ODromedaris
05:29:36 <shapr> Marvin--: could SlowProve be executed on a 'derivative' of Core to do more efficient direction of the optimization passes?
05:31:06 <Marvin--> I don't use Core at all
05:31:10 <shapr> yah, but..
05:32:17 <shapr> a derivative wouldn't be the Core itself, but instead a parse tree that held some properties of the Core
05:32:43 <shapr> I think the different passes only affect certain properties
05:32:55 * shapr shrugs
05:33:06 <shapr> just a random thought I had
05:52:07 <shapr> I am *so* convinced that ghc-users@haskell.org is the correct address
05:52:15 <shapr> I've bounce mail from there so many times
06:01:18 <shapr> I have a list of [Field] in the Message type
06:01:37 <shapr> what's the best to pick out one specific type of Field from the list?
06:01:42 <shapr> data Field
06:01:42 <shapr>     =   OptionalField           String String
06:01:42 <shapr>       | From                    [String]
06:01:42 <shapr>       | Sender                  String
06:02:00 <shapr> is there a good way to get only the From field if it exists?
06:03:12 <shapr> any ideas?
06:04:56 <Vincenz> in ocaml?
06:04:59 <pesco> filter (\f -> case f of {From _ -> True ; otherwise -> False})
06:05:06 <Vincenz> :)
06:05:10 <shapr> Vincenz: :-P
06:05:17 <shapr> pesco: thanks, I'll do that.
06:05:31 <Vincenz> Map.find_all (fun From _ -> true; _ -> false) list..
06:05:40 <Vincenz> oopa
06:05:43 <Vincenz> Map.find_all (fun From _ -> true | _ -> false) list..
06:06:21 <shapr> Vincenz: you should really learn Haskell
06:06:25 <pesco> oh right, s/otherwise/_/
06:06:31 <shapr> then you can chatter with us all the time :-)
06:07:06 <Vincenz> and that should be List, not Map
06:07:41 <pesco> We should hold a Haskell Blitz-Quiz sometime.
06:07:45 <shapr> yah, really
06:07:53 <Vincenz> yeah, extra poitns if you answer in ocaml :P
06:08:00 <shapr> sounds like a good lambdabot plugin
06:08:03 <pesco> lambdabot could keep the scores.
06:08:06 <pesco> *g*
06:08:10 <shapr> :-)
06:08:24 <Vincenz> euhm haskell has no states..
06:09:14 <shapr> pesco: ok, next stupid question, is there some way to make that filter function generic? can I just feed it the type to look for?
06:09:19 <shapr> I don't think there is...
06:09:27 * shapr thinks
06:09:33 <pesco> Hm, I've had the same question on my mind...
06:10:10 <shapr> oh
06:10:13 <shapr> hm
06:10:39 <shapr> ur
06:10:58 <shapr> no
06:11:00 <shapr> arg
06:11:47 <Vincenz> shapr: yeah, just pass a different func
06:12:06 <shapr> yes, but
06:12:09 <Vincenz> ?
06:12:24 <shapr> I want to only parameterize which type inside Field it's using
06:12:35 <pesco> you want something like filter (dtype From) right?
06:12:38 <Vincenz> ...write a different func..
06:12:43 <shapr> pesco: riight
06:12:50 <Vincenz> oh!
06:12:57 <Vincenz> I thikn that's possible, just don't remember how
06:12:58 <shapr> filter (dtype From) or filter (dtype To)
06:13:24 <shapr> thing is, that's a pattern match
06:13:38 <shapr> you can't generically construct them, can you?
06:13:53 <pesco> Yeah, I can't think of a way to test for the equality of the data constructor.
06:14:53 <Vincenz> hmm, good question :)
06:15:47 <pesco> I don't think you can do it.
06:15:55 <shapr> I don't think so either
06:15:59 <Vincenz> nop nop
06:16:12 <Vincenz> feature request!
06:16:55 <pesco> An example are the Exception type selectors from Control.Exception!
06:17:03 <shapr> ??
06:17:26 * shapr looks
06:23:54 <shapr> arithExceptions 	:: Exception -> Maybe ArithException
06:23:59 <shapr> arithExceptions (ArithException e) = Just e
06:23:59 <shapr> arithExceptions _ = Nothing
06:24:53 <Vincenz> ??
06:24:56 <pesco> hm, oh, I thought there was something like isArithException :: Exception -> Bool
06:25:12 <shapr> hrm
06:25:20 <pesco> But I think you're right, this makes more sense.
06:25:31 <shapr> that's from the GHC sources
06:25:52 <shapr> I wish I could not those kind of functions
06:25:57 <pesco> But it serves the same purpose just with the extra efect of handing you the ArithException.
06:26:15 <shapr> if I want both From and To fields in the message
06:26:48 <shapr> I can't just map (fromFields || toFields) fields_list
06:27:32 <pesco> I think you have to either make a seperate selector function for each of the field types or rearrange your data so the field type becomes an enumeration type you can explicitly compare to.
06:27:50 <shapr> what do you mean with the enumeration?
06:28:00 <pesco> data FieldType = From 
06:28:06 <pesco>  | To | blahblah
06:28:27 <shapr> how would that help?
06:28:31 <pesco> Sorry, this kb has Return where | is at home.
06:29:03 <pesco> then you could filter ((==From).msgtype)
06:30:07 <shapr> feh
06:30:21 <shapr> I'll just go for separate selector functions
06:30:29 <pesco> Yes, makes more sense.
07:00:19 <pesco> w00, I get out of work!
07:00:32 * shapr hacks on the mailing list searcher
07:01:04 * pesco .oO(IT is calling me, I must get back, quickly, IT must be compiled...)
07:01:11 * shapr grins
07:09:19 * Vincenz might have found a bug in Ocaml
07:09:22 * Vincenz beams brightly
07:12:05 <shapr> hiya Heffalump 
07:12:08 <shapr> wassup?
07:12:19 * andersca bounces
07:12:20 * andersca has a beer
07:12:26 * shapr sproings
07:12:28 * shapr has RC Cola
07:12:30 <Heffalump> hiya
07:12:36 <Heffalump> just wondering if anyone from here will be at ETAPS
07:12:45 * shapr looks around
07:13:18 <shapr> I'm writing a horribly inefficient mailing list searcher
07:20:44 * SyntaxPolice has some fancy coffee that he got for his birthday
07:21:14 <shapr> have you been using the mysterious filter holder to pick up your coffee filter?
07:21:15 <shapr> s
07:21:52 <shapr> sadly, for just a moment there, I thought filter was the swedish plural of en filt
07:22:51 <andersca> filtAr
07:23:07 <shapr> there really is such a word?
07:27:28 <andersca> en filt
07:27:29 <andersca> flera filtar
07:27:39 <shapr> scary =)
07:27:42 <shapr> tack
07:27:47 <andersca> ett filter
07:27:48 <andersca> flera filter
07:27:52 <andersca> swedish nouns are weird
07:27:56 <andersca> just like german nouns
07:28:29 <shapr> today we learned more about ny, nytt, nya
07:28:34 <shapr> fin, fint, fina
07:28:35 <shapr> etc
07:28:58 <andersca> ah
07:29:25 <shapr> I tried to convince the girl who sits next to me that this guy in the book should be doing mail order for his clothes
07:29:31 <shapr> but she had no clue what I was talking about
07:29:49 <shapr> how do you say mail order in swedish?
07:29:57 <shapr> betalar på posten?
07:30:11 <shapr> er köper på posten?
07:30:45 <shapr> lambdabot: @fortune
07:30:46 <lambdabot> Now I lay me down to sleep,
07:30:46 <lambdabot> I pray the Lord my soul to keep,
07:30:46 <lambdabot> If I should die before I wake,
07:30:46 <lambdabot> I'll cry in anguish, "Mistake!!  Mistake!!"
07:39:01 <shapr> crap
07:39:26 <shapr> ghci open 1200 files and then exploded.
07:40:57 <shapr> pesco: did it work?
07:41:04 <pesco> Yes!
07:41:09 <shapr> w00!
07:41:14 <pesco> That was only stage one though.
07:41:21 <pesco> Which doesn't have GHCi.
07:41:27 <shapr> oh
07:41:33 <shapr> that's still progress though, yes?
07:41:37 <pesco> But it will now build stage 2 without -static.
07:41:39 <pesco> Yes.
07:42:01 <pesco> The problem was just that convincing stage 1 of dynamic linking broke it.
07:42:24 <shapr> ah
07:42:25 <shapr> ok then
07:43:24 <pesco> GARRR!
07:43:45 <shapr> ?
07:44:10 <Vincenz> shapr: exploded?!?!?!?
07:44:19 <pesco> stage 2 builds dynamic executables. GHCi crashes on a new error.
07:44:25 <shapr> Vincenz: actually, it just threw an exception.
07:44:35 * pesco takes a nose-dive back into Linker.c
07:46:09 <pesco> "If your system uses ELF, chances are you don't have to do anything" *mumble* *mumble*
07:47:09 <shapr> this sort of sucks
07:47:19 <Vincenz> hmm, does Haskell use Hindeley-Milner?
07:47:26 <shapr> I don't know how to only open some files in the dir
07:47:28 <shapr> Vincenz: yes
07:47:31 <pesco> Hindley-Millner, isn't it?
07:47:40 * shapr isn't sure
07:47:40 <Vincenz> oh, yes sorry
07:47:49 * Vincenz has this really cool book
07:47:51 <pesco> I'm not either
07:48:11 <Vincenz> it covers ALL aspects of compiling, lazy, OO, functional, hindley-milner, SSA, assembly-generation, register-coloring...
07:48:14 <Vincenz> only prob...
07:48:23 <Vincenz> we had to get the c-version of the book for my course
07:48:27 * Vincenz si considering the ML book
07:48:49 <Vincenz> it's prolly exactly the same except that all the code is written in ML, so perhaps it's a waste as some sources can be downed from the net
07:48:50 <Vincenz> not sure
07:49:14 <Vincenz> 60 euroes
07:49:15 <Vincenz> about
07:50:58 <pesco> why the hell does this work on Intel?!
07:51:24 <Heffalump> vincenz: Haskell 98's type system is Hindley-Milner with the addition of type classes
07:51:33 <Vincenz> alright
07:52:36 <pesco> Oh, ok, I see.
08:04:25 <pesco> Is there anyone here who can explain to me what a relocation (in the context of an ELF object file) is?
08:04:37 * shapr has no idea
08:06:19 <pesco> I should get off my bum and read some ELF documentation
08:06:34 * pesco googles
08:07:34 <shapr> y0 Darius 
08:07:36 <shapr> wassup?
08:07:45 <Darius> heya
08:07:57 * shapr made sure not to say that greeting this time ;-)
08:08:11 <shapr> did you make up for lost sleep?
08:08:40 <Darius> still working on the Dvorak, seemingly
08:08:48 <shapr> cool
08:08:54 <shapr> persistence is rewarding
08:09:15 <shapr> well, most of the time
08:09:30 <shapr> lambdabot: @fortune
08:09:30 <lambdabot> BOFH excuse #418:
08:09:30 <lambdabot> Sysadmins busy fighting SPAM.
08:09:34 <shapr> lambdabot: @fortune
08:09:34 <lambdabot> Debian Hint #14: If you would like to follow things happening to a package
08:09:34 <lambdabot> (for example, if you want to see bug reports, release notices, and other
08:09:34 <lambdabot> similar things), consider subscribing to it on the Package Tracking System.
08:09:34 <lambdabot> You can find out more about the PTS at:
08:09:37 <lambdabot> http://www.debian.org/doc/manuals/developers-reference/ch-resources.en.html
08:09:39 <lambdabot> (Section 4.11)
08:09:58 <shapr> I unsuccessfully hacking on a mailing list search plugin
08:10:26 <shapr> I'm trying to search my local maildir, but ghc opens too many files
08:10:50 <shapr> there are 2k files in the dir, I'm trying to figure out how to do them in chunks
08:12:02 <Darius> Is it a lazyness thing?
08:12:06 <shapr> I think so
08:12:12 <SyntaxPolice> shapr: remember the carrot-and-stick thing about my laptop? I was waiting until a project was done?
08:12:18 <shapr> SyntaxPolice: yah?
08:12:19 <SyntaxPolice> (before buying one)
08:12:25 <shapr> did you succeed?
08:12:25 <SyntaxPolice> shapr: I just sent in the patch! :) :)
08:12:40 <shapr> SyntaxPolice: you've earned yourself a carrot-colored laptop?
08:12:59 <SyntaxPolice> I think so.  I'd like to wait until the patch gets accepted, but we'll see.
08:13:05 <shapr> happy birthday carrot!
08:13:08 <SyntaxPolice> !!
08:13:51 <shapr> Darius: I'm sure it is, now I'm trying to restructure my code into a lazy list
08:14:53 <shapr> SyntaxPolice: have you looked at the lambdabot sources?
08:15:18 <shapr> oh, I need to check in the changes I just made
08:15:31 <SyntaxPolice> shapr: I looked at them a little. I'm thinking of a module I might write.
08:15:53 <shapr> Darius: oh, hey, Riastradh found a really fun @eval 'bug'
08:15:59 <shapr> or maybe misfeature
08:16:05 <shapr> lambdabot: @define a 1
08:16:05 <lambdabot> a defined
08:16:16 <shapr> lambdabot: @define a a + 1
08:16:16 <lambdabot> a defined
08:16:23 <shapr> lambdabot: @eval a
08:16:27 <shapr> *boom*
08:17:47 <shapr> Darius: I looked at the code shortly, but I'm not familiar enough with the interpreter to figure out how to get around that
08:19:26 <Darius> hmm
08:20:10 <Darius> @define Y \f.f (Y f)
08:20:47 <Darius> lambdabot: @define Y \f.f (Y f)
08:20:48 <lambdabot> Y defined
08:22:22 <Darius> lambdabot: @eval Y (\fac n.if n == 0 then 1 else fac (n-1)) 5
08:22:22 <lambdabot> 1
08:22:31 <Darius> darn
08:22:33 <shapr> ?
08:23:04 <shapr> SyntaxPolice: any specific module in mind?
08:23:10 <Darius> oh
08:23:16 <Darius> lambdabot: @eval Y (\fac n.if n == 0 then 1 else n*fac (n-1)) 5
08:23:17 <lambdabot> 120
08:24:51 <Darius> well I didn't mean it, but you can write recursive eq's
08:25:10 <Darius> now to count them
08:26:42 <shapr> oh
08:26:43 <shapr> I see
08:26:44 <shapr> neat
08:27:20 <SyntaxPolice> shapr: yes, but its a secret.  lets just say that it has something to do with floating around in three dimensional space.
08:27:38 <SyntaxPolice> :-)
08:27:44 <shapr> and it's a lambdabot plugin?
08:27:48 <SyntaxPolice> not yet.
08:27:56 <shapr> but that's the idea, yes?
08:28:00 <SyntaxPolice> yes
08:28:03 * shapr tries to think of the connection
08:28:39 <Darius> lambdabot: @define fac \n.if n == 0 then 1 else n*fac (n-1)
08:28:39 <lambdabot> fac defined
08:29:00 <Darius> lambdabot: @eval fac 10
08:29:00 <lambdabot> 3628800
08:30:28 <Darius> lambdabot: @define count \n.if n == 0 then 0 else count (n-1)
08:30:28 <lambdabot> count defined
08:30:40 <Darius> lambdabot: @eval count 333
08:30:40 <lambdabot> 0
08:30:43 <Darius> lambdabot: @eval count 1000
08:30:43 <lambdabot> out of fuel
08:30:51 <Darius> lambdabot: @eval count 999
08:30:51 <lambdabot> 0
08:32:01 <tmoertel> Darius: if lambdabot runs out of fuel, can it return a suspended computation?
08:32:18 <tmoertel> So that you can say lambdabot : @resume
08:32:45 <tmoertel> to give the computation another batch of fuel
08:33:04 <Darius> not now, but it shouldn't be that hard
08:34:20 <Darius> just save the rest in a special var when the fuel runs out
08:44:09 <Vincenz> lambdabot: @eval ((\x.x x)(\x.x x))
08:44:10 <lambdabot> out of fuel
08:44:13 <Vincenz> woo!
08:45:45 <Darius> yeah, but the equivalent to a=a isn`t checked right
08:49:03 <Darius> so where's a script to change vim to Dvorak?
08:49:30 * shapr dunno
08:49:32 <shapr> I use emacs
08:51:17 <Darius> I found some.  Vim.org doesn't list anything
09:07:30 <shapr> where's max number of open files defined?
09:07:50 <shapr> in ghc? or in Linux?
09:15:51 <psy> /proc/sys/fs/file-max i think
09:18:53 * kawfee bounces
10:33:14 <shapr> hi esap 
10:33:26 <esap> Hi. What's up?
10:33:40 <shapr> I'm trying to figure out how to rewrite map code as lazy list code
10:34:00 <shapr> map funcfoo myList
10:34:33 <shapr> what's up with you?
10:35:15 <esap> I found out that unification for function application is not as simple as it seems.
10:37:25 <Marvin--> shapr: eh?
10:38:04 <shapr> trying to get around the 'too many open files' problem
10:38:06 <esap> shapr: for one, because unify(app,snd) = fix, which is very interesting.
10:38:15 <Marvin--> uhm
10:49:09 <Vincenz> blah
10:54:10 <Darius> shapr: do you have code like: map (open; dostuff file; close) files, or similar?
10:58:07 <Darius> actually, if you think it's laziness, then check out the Strategy library and rnf
10:58:08 <pesco> Ah, there it finally is: The System V ABI PowerPC Supplement
10:59:02 <pesco> shapr: This is getting really exciting, not long and I'm going to know all kinds of stuff about my PowerPC! I owe you a beer!
10:59:49 <Marvin--> you want to give him a beer for making you do lots and lots of dirty work?
11:00:14 <pesco> Basically, yeah.
11:00:49 <Marvin--> what did I miss?
11:00:51 <Marvin--> ;)
11:01:03 <Marvin--> are you ill or something? :)
11:01:33 <pesco> Just imagine you managed something you wouldn't have thought yourself capable of.
11:01:54 <Marvin--> yeah I know what you mean :)
11:02:11 <Marvin--> I still hold that *he* should buy *you* a beer for it :)
11:02:23 <pesco> And imagine you got a bunch of knowledge you've always wanted to aquire but didn't know where to start thrown in for free.
11:04:43 <pesco> Marvin: Well, I'm thankful for it so I feel I should reward him.
11:05:00 <Marvin--> why don't you guys just buy each other beer then ;)
11:05:27 <pesco> That's the way one usually proceeds, right. ;)
11:07:54 * Heffalump repeats his question about people going to ETAPS
11:24:01 <Marvin--> ETAPS?
11:27:31 <Heffalump> European joint conferences on Theory and Practice of Software
11:27:41 <Heffalump> big thing in Poland next week
11:35:08 * shapr returns from drugging the kitties
11:35:40 <shapr> 5 cats + one pile catnip = much entertainment
11:36:18 <shapr> pesco: let's exchange beer next time we're in the same room ;-)
11:36:34 <pesco> Yah, sure.
11:37:02 <shapr> you realize I'll be asking you about GHC internals when I have questions? ;-)
11:37:03 <pesco> I always forget your physical location. .se?
11:37:15 <shapr> yup, north sweden
11:37:38 <Riastradh> Hi.
11:37:49 <shapr> I was hoping to drop by erlangen in a month or so, but it didn't pan out
11:37:54 <shapr> y0 Riastradh 
11:38:01 <pesco> shapr: Bleh!
11:38:24 <shapr> where in .de are you?
11:38:29 <pesco> Hamburg.
11:38:50 <shapr> um, isn't that in the far north of .de ?
11:39:04 <pesco> Yes.
11:40:17 <shapr> Darius: actually, my code uses readFile, I wonder if explicit open/close would help
11:40:29 <Igloo> Oooo, pesco knows about GHC internals?
11:40:44 * pesco hides
11:41:04 * Igloo is sure that knowledge will come in handy at some point  :-)
11:41:58 * pesco shouts from behind somewhere "I know nothing of those matters!"
11:42:08 <Vincenz> anyone know how to work with dual view under windows?
11:42:21 <shapr> Vincenz: install linux?
11:42:24 <pesco> You mean with both eyes? *g*
11:42:30 <Vincenz> shapr: it works under windows
11:42:34 <Vincenz> but I want do something specific
11:42:40 <Vincenz> run media player full screen on one monitor
11:42:46 <Vincenz> and run other apps on the other
11:42:50 <shapr> I think my solution was excellent :-)
11:43:11 <shapr> I have three monitors on my desktop, and zero copies of windows
11:43:18 <shapr> :-P
11:43:37 <shapr> of course, when someone pays me to do windows code, I have to go borrow my woman's win98 box
11:43:39 <shapr> :-/
11:43:44 <pesco> shapr: Ooh, you're using three displays (Xinerama?)?
11:43:47 <Vincenz> at least you have a woman
11:44:00 <shapr> pesco: nah, three PCs :-)
11:44:09 <pesco> shapr: Bah! ;)
11:44:12 * shapr grins
11:44:24 <shapr> Vincenz: yes, and she speaks dutch and french
11:44:38 * Vincenz mutters
11:44:42 <shapr> and she uses XEmacs
11:45:01 <shapr> on the linux she installed herself ;-)
11:46:32 <Darius> I'd use Linux `cept I have a Winmodem that I couldn't get to work
11:46:40 <shapr> what chipset?
11:47:44 <shapr> Bea said Mandrake is easier to install than windows 98
11:54:19 <shapr> hi vardamir 
11:54:24 <vardamir> hey
11:54:29 <shapr> wassup?
11:54:58 <vardamir> not much really; just taking a look at the haskell reference
11:55:39 <vardamir> i was wondering, what kind of precision do Floats have in haskell?
11:55:48 <shapr> C Double
11:55:57 <vardamir> ok
11:56:32 <shapr> 1 sign bit, 52 mantissa and 11 bits exponent
11:56:40 <shapr> I think I got that right
11:56:56 <shapr> er waitasec
11:57:16 <shapr> I think there are multiple sizes of Float
11:59:04 <Darius> http://www.idir.net/~gromitkc/ess/ess_es56pi.html this one or one close
12:00:09 <opet> http://www.haskell.org/onlinereport/basic.html#numbers
12:00:21 <shapr> right
12:00:34 <shapr> Float is single precision, Double is double precision
12:00:43 <opet> "Float is implementation-defined; it is desirable that this type be at least equal in range and precision to the IEEE single-precision type."
12:01:03 <opet> etc
12:10:53 <vardamir> i don't know much about this, so I'm not critisizing or anything, just wondering why there aren't any Haskell libraries supporting arbitrary/"infinite" precision Floats.  Is it just not that useful, or is it hard to implement?  It looks like GNU MP has it.
12:12:01 <vardamir> i mean, i don't have a good reason to use it myself ;)
12:12:39 <Darius> there is
12:13:27 <Darius> as of like a few days ago
12:13:30 <vardamir> i looked under the libraries page at Haskell but didn't notice anything.  what is it?
12:13:35 <vardamir> oh, haha
12:14:07 <Darius> It's in the Haskell-libs
12:14:31 <Darius> along vith lambdabot :P
12:14:53 <pesco> Which is of equally importance, obviously.
12:15:00 <pesco> "equal"
12:15:21 <Darius> lambdabot: @fact source
12:15:22 <lambdabot>  http://sf.net/projects/haskell-libs/, http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/lambdabot/
12:15:39 <vardamir> nice
12:21:03 <shapr> gee, maybe I should make a webpage describing the libs in haskell-libs
12:22:37 <shapr> haskell-libs is 85% active on sf.net =)
12:22:39 <shapr> w00
12:23:13 * shapr quickly tries to delegate the job of making a webpage for haskell-libs
12:23:36 * shapr delegates the job to lambdabot 
12:23:44 <shapr> lambdabot: @webpage
12:23:44 <lambdabot> Sorry, I don't know that command, try "lambdabot: @listcommands"
12:23:46 <shapr> :-/
12:36:58 <Vincenz> lambdabot: @karma- shapr
12:36:58 <lambdabot> shapr's karma has been decremented.
12:37:01 <Vincenz> lambdabot: @karma shapr
12:37:02 <lambdabot> shapr has a karma of -1
12:37:04 <Vincenz> tsk
12:37:07 <Vincenz> you're not doing so well, shapr
12:37:08 <shapr> oh no
12:37:11 <shapr> what did I do?
12:37:18 <Vincenz> you :-/'d
12:37:18 * shapr quickly writes more code
12:37:21 <shapr> ohh
12:37:27 <Vincenz> cause it didn't accept your command
12:37:43 <Vincenz> code you!
12:37:45 <Vincenz> CODE!
12:37:50 <Vincenz> like your life depended on it
12:37:53 <Vincenz> lambdabot: @karma shapr
12:37:54 <lambdabot> shapr has a karma of -1
12:37:56 <Vincenz> lambdabot: @karma- shapr
12:37:57 <lambdabot> shapr's karma has been decremented.
12:38:02 <Vincenz> your life is slowly losing value
12:38:06 <shapr> Vincenz: my life does depend on it, that's how I make money.
12:38:19 <Vincenz> hehe, me too :P
12:39:08 <Vincenz> I guess that's why I make so little of it
12:47:17 * shapr boings happily
12:47:29 <shapr> my woman is in Norway, time for a coding binge
12:49:26 <Marvin--> heh
12:49:37 * Marvin-- is watching L.A. Confidential
12:57:44 <shapr> what's the trick to go from [m a] to m [a] ?
12:59:28 <shapr> aha
12:59:33 <shapr> Control.Monad.sequence
13:04:24 * Heffalump deGaneshes
13:04:31 <shapr> ?
13:06:01 <shapr> y0 dark
13:06:03 <shapr> wasssup?
13:06:40 <dark> Umm... I'm trying to make Duke Nukem 3D run on linux :)
13:06:44 <dark> Actually I'm trying to make it link.
13:06:56 <shapr> how close are you?
13:07:25 * Marvin-- swears at aj and sobs
13:07:27 <dark> About 600 link errors :)
13:07:44 <shapr> Marvin--: who's aj?
13:08:17 <dark> It's tricky, they forgot to provide source for a utility library.  Now I have to guess how KB_KeyDown[] is supposed to behave.
13:08:34 <Marvin--> shapr: Anthony Towns, debian's release manager
13:08:44 <shapr> Marvin--: what happen?
13:08:52 <dark> In another world, this would be a job for uncc :)
13:08:59 <shapr> dark: maybe someday
13:10:00 <Marvin--> shapr: he set me up the bomb, i.e. made me co-responsible for getting d-i to the stage where it can be used in a preview release within a month
13:10:17 <shapr> yow
13:11:40 <SyntaxPolice> Marvin--: looks like you'd better stop watching movies ;)
13:12:15 <Marvin--> not something I needed piled on me what with the master project and all :/
13:13:18 <Marvin--> I just hope the official d-i project leader starts having some more time soon
13:16:37 <dark> Heh, http://icculus.org/duke3d/.  I'm always slower than those guys :)
13:20:48 <shapr> grrr
13:21:00 <shapr> I can't figure out how to stop overflowing max files
13:22:45 * shapr applies limburgher quality cheesiness
13:24:52 <Darius> is the code anyplace it can be looked at?
13:25:02 <shapr> can be, just a moment
13:25:22 <shapr> I just broke the file list into chunks of 500 and looped over that.
13:26:19 <shapr> http://kungens.kemi.fi/~shae/src/haskell/ProtoMailingList.hs
13:26:50 <shapr> requires the RFC2822 parser in haskell-libs
13:27:51 <dark> Interesting now "unixify" deunixifies it.
13:27:56 <shapr> heh
13:28:18 <shapr> that parser wants \r\n and will ignore any messages that don't have that.
13:29:20 <shapr> I finally got a result without an exception
13:29:54 <shapr> it always dies at 1088 files
13:30:00 <shapr> well, not now
13:36:09 * shapr writes a generic chunker
13:36:54 <Darius> what does test_run return? type-wise
13:37:36 <shapr> *ProtoMailingList> :t test_run
13:37:37 <shapr> forall a tok. GenParser tok () a -> [tok] -> Either ParseError a
13:38:30 <shapr> so test_run message fixd returns IO Message
13:39:10 <shapr> well, IO (Either ParseError Message) actually
13:40:57 <Darius> if you haven't try putting a $! between return and test_run in getMessage
13:41:17 * shapr tries that
13:43:19 <shapr> wow
13:43:23 <shapr> it looks like it's working!
13:43:35 <shapr> man, it's using a lot of CPU
13:43:38 <shapr> and disk
13:43:53 <shapr> and ram
13:44:14 <Darius> what's the type of getMessage?
13:44:20 <Darius> IO (IO ...)
13:44:22 <Darius> _
13:44:23 <Darius> ?
13:45:30 <shapr> *ProtoMailingList> :t getMessage
13:45:30 <shapr> FilePath -> IO (Either ParseError Message)
13:45:34 <shapr> w000
13:45:42 <Marvin--> "oh great, you get the girl, I get the coroner" hahah
13:45:43 * shapr buys a beer for Darius 
13:45:53 <shapr> lambdabot: @karma+ Darius 
13:45:53 <lambdabot> Darius's karma has been incremented.
13:46:09 <shapr> it takes forever, but it works!
13:46:27 <Marvin--> argh, damn tehse commercials
13:46:43 * Darius doesn't drink, but whatever
13:47:17 <shapr> ok, now I have to hack it into a lambdabot plugin, even in the current incredibly inefficient state
13:48:46 <shapr> or maybe not.. if there's a simple way to make it more efficient
13:57:37 * SyntaxPolice posted a patch to apt (implementing secure updates) on his home page.
13:58:19 * SyntaxPolice going out of town now. byebye
13:58:20 * SyntaxPolice &
14:04:02 <Janni> hey all!
14:04:25 * Janni is drinking milk
14:05:12 <Janni> lambdabot: @fact milk
14:05:13 <lambdabot> bad for the karma
14:05:30 <Janni> lambdabot: @karma- Janni
14:05:30 <lambdabot> You can't change your own karma, silly.
14:06:26 <Milk> lambdabot: @karma- Janni
14:06:26 <lambdabot> Janni's karma has been decremented.
14:07:08 <Darius> lambdabot: @karma Darius
14:07:08 <lambdabot> You have a karma of 1
14:07:26 <Janni> lambdabot: @karma Darius
14:07:27 <lambdabot> Darius has a karma of 1
14:08:02 <Janni> Hmm. Intelligent (remark the "You" and the "Darius")
14:08:26 <Janni> lambdabot: You have gotten quite intelligent.
14:08:26 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
14:12:22 * shapr boings
14:13:47 <shapr> I wonder how people write search engines
14:13:50 <shapr> suffix trees?
14:14:11 <shapr> that's more for searching through a large single text though...
14:14:28 <Janni> shapr: How can I imagine your "boinging" or "bouncing"? Is it like rocking your upper body according to the tact of the actual song?
14:15:06 <shapr> it's more like jumping up and down on my chair
14:15:19 <Janni> shapr: With your feet on it... :)
14:15:25 <shapr> or sometimes running around the house and scaring all the cats
14:15:38 <Janni> and kids...
14:15:47 <shapr> we don't have any kids other than me =)
14:16:54 <Janni> But according to music or just because of being a crazy wierdo?
14:16:54 <shapr> I wonder if there are any search engines written in Haskell
14:17:01 <shapr> Janni: I just can't sit still.
14:17:06 <shapr> not for very long
14:17:11 <Janni> Even without music?
14:17:21 <shapr> it's easier to sit still with music
14:17:32 * Janni wonders...
14:17:47 <shapr> I'm just a crazy weirdo ;-)
14:18:16 <andersca> aren't we all
14:18:18 * andersca bounces
14:18:57 * shapr boings
14:20:39 <Janni> Well, I'm doing a lot of bouncing a day, but only with music or when sporting. Being crazy wierdo shows in other ways...
14:21:42 <Janni> But actually
14:21:50 * Janni is bouncing right now as well...
14:22:03 * shapr is looking for text searching code in Haskell
14:22:54 <Janni> So what do you exactly want to do? Just searching a substring in a string?
14:23:34 <shapr> no, I want to index all of the haskell and haskell-cafe mailing list archives
14:23:44 <shapr> actually all the mailing lists
14:24:02 <shapr> I just finished writing a brute force regex search (with help from Darius, thanks!)
14:24:11 <Janni> what do you mean with "index" in that context?
14:25:32 <shapr> it takes five minutes to brute force its way through ~2000 files @ 16mb total
14:25:45 <shapr> so I want to go through it once and build an index
14:25:54 <shapr> then I can do quick searching from lambdabot 
14:26:22 <Janni> But what should that index contain?
14:26:22 <shapr> at least, that sounds like a good idea
14:26:58 <shapr> keywords?
14:27:01 <shapr> I'm not sure.
14:28:28 <shapr> that sounds like a good idea
14:29:16 <shapr> break an email into words, build a FiniteMap Word [Messages]
14:29:27 <Igloo> What regexp was it?
14:29:46 <shapr> just (mkRegexp "of")
14:29:51 <shapr> nothing exciting
14:29:58 <Igloo> Matches literal "of"?
14:30:02 <shapr> I think so
14:30:12 <Igloo> That sounds surprisingly slow
14:30:23 <shapr> I think the regex library is confused anyway
14:31:11 <shapr> it fails to return matches entirely in matchRegex, and also drops chars in matchRegexWithOpts
14:32:49 <shapr> Igloo: it would probably be faster if I weren't parsing each email with Parsec into an RFC2822.Message
14:33:03 <shapr> and then running the regexp on the subject line
14:33:17 <Igloo> Oh, I see
14:33:57 <shapr> the primary purpose of this exercise was to exercise Peter Simons' rfc2822 code so I could give him decent feedback
14:34:02 <Igloo> So it's not actually matching regexps at 56k/s  :-)
14:34:16 <shapr> but, now that I have a sucky mailing list search engine
14:34:28 <shapr> why not upgrade it from sucky to bad?
14:34:33 <Igloo> :-)
14:37:03 <Igloo> Should be quite nice - parse it with the library and you can have maybe 3 FMs, one for headers, one for body and one for subject. Then for each messages you take each of the three bits and   foldr addToFM the_fm $ filter not_the_etc $ uniq $ sort $ words new_stuff   or something
14:37:18 <shapr> yah :-)
14:37:54 <Igloo> Oh, except the addToFM should be somewhat different
14:37:54 * shapr takes that idea and runs with it
14:38:00 <shapr> oh tell me more =)
14:38:44 <Igloo> I would if I could find a hugs that is willing to tell me the type fo addToFM_C  :-)
14:38:47 <shapr> heh
14:39:19 <shapr> http://www.haskell.org/ghc/docs/latest/html/base/Data.FiniteMap.html
14:39:34 <shapr> I really need to do the HaddockPlugin for lambdabot 
14:39:36 * Igloo finds my path is mangled from trying to build hat
14:39:42 <shapr> that would be the most useful plugin yet
14:40:27 * Igloo hmmms
14:41:08 <shapr> thing is, FastMutInt crashes ghci, and Haddock won't load without it
14:41:19 <Igloo> I can't see anything that looks like it'll do what you want
14:41:20 <shapr> and I am heavily dependent on interactive exploration
14:42:42 <Igloo> addToFM the_fm the_word (this_message:lookupWithDefaultFM the_fm [] the_word)   anyway
14:42:43 <shapr> couldn't I just use "zipWith3 updateFM [allbodies, allsubjects, allheaders] [thisbody, thissubject, thisheaders]" for each message?
14:42:56 <shapr> ohh
14:43:04 <shapr> that's much more elegant than what I was thinking of
14:43:19 <Igloo> updateFM doesn't exist in what I'm looking at?
14:43:54 <shapr> there is one that combines FMs
14:44:12 <shapr> plusFM
14:44:18 <shapr> oh wait
14:44:27 <Igloo> Oh, plusFM_C might do it
14:44:34 <Igloo> Depends what it does with things in one FM but not the other
14:45:03 <shapr> couldn't you do plusFM if you had FiniteMap Message [Word]
14:45:07 <Igloo> Oh, and it constrains the types to be the same, which isn't ideal
14:45:19 <shapr> and then switched that to FiniteMap Word [Message] afterwards?
14:45:40 <Igloo> I think   plusFM_C (++)   is what you're thinking of
14:45:49 <Igloo> Oh
14:45:54 <shapr> ?
14:46:02 <shapr> I think you're right
14:46:04 <Igloo> Ah, I see, yes, that would work
14:46:13 <Igloo> But the conversino would be horribly inefficient
14:46:18 <shapr> yes it would be
14:46:24 <shapr> your solution is much more efficient
14:46:25 <Igloo> You'd have to redo it for each new message
14:46:35 <shapr> yah, true
14:47:19 <shapr> I generally code up the first solution that I think of, and then when it works, I improve it
14:47:22 * Igloo investigate plusFM_C (++)
14:47:39 <shapr> I've discovered that I get more stuff done if I just *finish* something first, no matter how ugly or hackish
14:47:55 <Igloo> :-)
14:48:08 <shapr> then I can improve it in discrete steps, or just wander off
14:50:00 <Igloo> Yeah, plusFM_C (++) (foldr (flip addToFM [this_message]) emptyFM word_as_previously_defined) the_old_fm   would be an alternative
14:50:31 <shapr> which one do you think is best?
14:51:21 <Igloo> The first one I think, partly because the ++ is ugly
14:51:50 <shapr> this one --> addToFM the_fm the_word (this_message:lookupWithDefaultFM the_fm [] the_word)  ?
14:52:55 <Igloo> Ths first would be much cleaner if there was a updateFM :: Ord a => (Maybe b -> c -> b) -> FiniteMap a b -> a -> c -> FiniteMap a b
14:53:15 <Igloo> Or alternatively updateFM :: Ord a => (b -> c -> b) -> b -> FiniteMap a b -> a -> c -> FiniteMap a b
14:54:09 <Igloo> Yeah, that one, using that were I said addToFM in the line containing uniq
14:54:25 <shapr> ok
14:54:55 <Igloo> Don't blindly do what I say though  :-)
14:55:15 <shapr> why not? it's worked wonderfully for me in the past... :-)
14:55:22 <Igloo> lol
14:56:32 <Marvin--> cute, I got gnupg + gabber to work
14:56:51 <Igloo> Does that remember your passphrase?
14:56:59 <Marvin--> yes, during the session
15:01:20 <shapr> kunphuzil: what was your nickname before?
15:02:06 <Smerdyakov> Fatty McLarge
15:02:07 <Smerdyakov> Ha ha ha
15:02:14 * shapr blinks
15:02:16 <shapr> huh?
15:02:27 * Marvin-- swears at Evolution
15:02:38 <andersca> what now
15:02:49 <shapr> Smerdyakov: thanks again for that lambda calculus tutorial, I'm enjoying playing with it.
15:02:57 <Marvin--> it refuses to encrypt a message to someone because it doesn't trust his key
15:03:09 * shapr snickers
15:03:10 <kunphuzil> shapr: kunphuzi1 number 1 instead of letter l
15:03:15 <shapr> kunphuzil: ohhh
15:03:17 <Marvin--> of course I wouldn't trust an untrusted signature, but *how* does it harm *encrypting a mail to him*?
15:03:41 <shapr> are you encrypting with his public key?
15:03:46 <shapr> if so, it could harm
15:03:56 <Marvin--> why?
15:04:00 <shapr> it could be a public key designed to exploit your key
15:04:15 <Marvin--> how?
15:04:45 <shapr> there are pathological cases in the public/private key system where sometimes the encrypted text is plain text
15:05:22 <Marvin--> yes, but how is it related to *my* key when I just encrypt to him?
15:05:32 <shapr> and some cases where an attacker can choose a key that matches your key in a certain way
15:05:39 <shapr> and thereby get part or all of your private key
15:05:58 <shapr> hrm
15:06:10 <shapr> Marvin--: you have a good point there
15:06:16 <Marvin--> heh
15:06:51 <shapr> something like, you encrypt a message with your private key, then you encrypt it with his public key
15:07:05 <shapr> and then he can do something like encrypt it with your public key and get your private key
15:07:09 <shapr> something bizarre like that
15:07:25 <Darius> the problem is that you could be sending something private to an imposter
15:08:06 <Marvin--> but that's *my* problem, not evolution's
15:08:27 <shapr> hey, they were trying to emulate outlook, right?
15:08:30 <Marvin--> it should say "This may an impostor, dumbfuck, do you really really really want to continue?" and since I'm only sending a "hihi" string I'd say "yes"
15:08:50 <Darius> yes it should
15:09:26 <Marvin--> and I don't really see it as an improvement that I'll end up sending the mail without encryption instead of with uncertain encryption :)
15:10:20 <shapr> heh
15:10:26 <shapr> Marvin--: excellent point
15:11:03 <shapr> Marvin--: hey, when are you going to write the @quote plugin for lambdabot that automatically writes to your quotesite?
15:11:12 <shapr> oh, and extend @fortune to read from your site!
15:11:35 <Marvin--> I don't really see how   D(a, E(b, E(a, m))) == a's secret key...
15:11:55 <shapr> I'm sure I've gotten it wrong...
15:11:58 <Marvin--> shapr: sometime when my master project is finished, sarge is released and pigs can fly
15:11:58 <shapr> but there is an attack like that
15:12:04 * shapr laughs
15:12:19 <shapr> wasn't Mozilla codenamed porcine aerial navigator?
15:12:29 <shapr> or was that the bug tracking system for Mozilla?
15:12:33 <Marvin--> is this attack gnupg-specific or is it in DSA?
15:12:43 <shapr> I don't remember :-(
15:13:00 <shapr> I'll look it up again in my copious free time.
15:13:16 <Marvin--> the only gunpg attack I'm aware of is the one that relies on stupid people mailing back a quoted, decryped reply, thereby giving you a free known-cleartext attack
15:13:31 <shapr> I want to finish the mailing list searching plugin for lambdabot first =)
15:14:03 <Darius> plusFM_C (flip (++)) the_fm (unitFM the_word [this_message]) ?
15:14:15 <shapr> what? you're already done?
15:14:48 <shapr> er, what's useful about (flip (++)) ?
15:14:58 <Marvin--> I'm going to go bang my head against my pillow
15:15:43 <shapr> Marvin--: have fun
15:15:56 <Darius> so it's [x]++[a,o,e,u,i...]
15:16:02 <shapr> oh!
15:16:09 <shapr> excellent point
15:17:31 <shapr> Darius: have you rolled it into a plugin yet? =)
15:18:16 <Igloo> That won't work if the_word isn't in the_fm will it?
15:18:31 <Igloo> Oh, no, I'm talking rubbish
15:19:31 <Igloo> That's basically what I said earlier but for a single word I think
15:21:54 <Darius> yeah I think it is.
15:48:47 <shapr> ok, I'm finished dealing with rfc2822 for the moment
15:49:20 <shapr> Darius: are you working on a mailing list plugin?
15:49:29 <Darius> no
15:49:32 <shapr> ok cool
15:49:42 <shapr> just checking to keep from duplication of effort
16:25:12 <vardamir> are there any typical ways to take the inverse of a bijective function?
16:32:18 <Smerdyakov> Say WHAT?
16:32:33 <Smerdyakov> You need to define the problem better than that.
16:33:42 <vardamir> well, i guess i could use lists instead of the typical functions.  i mean a permutation basically, like f x = case x of {1 -> 3; 2 -> 1; 3 ->2;}
16:34:11 <vardamir> but i think if i used a function based on 2 lists, that would be better (wish i'd thought of that before)
16:34:33 <Smerdyakov> Formulate a specification (including a type) for a function that would perform the transformation you want, and then we can tell you if its possible.
16:35:45 <vardamir> ok, i'm going to try to implement this later on tonight using lists .. nothing too fancy. thanks
16:37:02 <Igloo> If I understand the problem then it should be straightforward with lists
16:37:39 <Igloo> Some subset of    sort $ map (\(x, y) -> (y, x)) $ zip [1..]
17:01:30 <Igloo> You know things are going badly when not only is your code wrapping but your terminal is 112 characters wide
17:06:41 <lament> indeed, that's why everyone should use assembly!
17:06:57 <Smerdyakov> Except for lament.
17:07:02 <Smerdyakov> lament will use cold cereal.
17:11:22 <Riastradh> My cold cereal wraps too much.
17:31:27 <shapr> I wish the source for Dark Reign would be released.
17:39:43 <shapr> hmm
17:40:02 <shapr> Hal told me something about a Binary persistent FM
17:40:07 <shapr> now I can't find it.
17:57:43 <Igloo> Yay, I have simplification working again!
17:57:47 <shapr> yay!
18:03:48 <Igloo> Hmmm, beta reductino will require more work though  :-(
18:14:54 <Riastradh> Isn't beta reduction just tree replacing?
18:15:06 <shapr> reforestation?
18:15:08 <shapr> hi Riastradh 
18:15:11 <Riastradh> Hi.
18:15:41 <Igloo> Yes, but my rewrite rules aren't powerful enough to understand "if unification succeeds"
18:15:52 <Riastradh> 'If unification succeeds?'
18:16:11 <Igloo> You need to try unifying the pattern with the argument
18:16:39 <Igloo> i.e. you can't beta reduce (\(x, y) -> some big expr) foo
18:17:00 <Riastradh> Why can't you beta reduce that?
18:17:16 <Igloo> Because you don't have a value/tree for x
18:17:24 <Riastradh> A 'value/tree?'
18:17:46 <Igloo> OK, what should    (\(x, y) -> x + y) foo    be beta reduced to?
18:18:35 <Riastradh> Er, oh, is this not plain, simple Lambda-Calculus?
18:18:45 * Igloo points at the channel name  :-)
18:18:57 <Riastradh> Well, you might just be writing a Lambda-Calculus interpreter!
18:19:01 <Riastradh> Like I am.
18:19:03 <Igloo> Heh
18:19:07 <Riastradh> (though mine is in Scheme)
18:21:12 <Riastradh> At first I was just playing around with the S and K combinators...
18:22:00 <Riastradh> Then I decided to try to hack up the implementation so functions would be automatically curried, not because I always like them being automatically curried, but so that the Lambda-Calculus stuff would look nicer.
18:22:02 <Igloo> Oooo, I think it might all be working
18:22:31 <Riastradh> Then I decided that I should just write a little Lambda-Calculus interpreter to do that stuff, because it would be too difficult to hack up the implementation.
18:23:26 <Riastradh> Then the interpreter got bigger...and worked better...though I hadn't implemented everything, like beta reduction.  So I started to write that, and now I've decided that it'll be a testbed for experiments with compiler stuff.
18:23:37 <shapr> wow, I have a keyword index
18:23:43 <Igloo> Cool - to both of you  :-)
18:24:12 <shapr> now to clean it up and stick it into a lambdabot plugin
18:25:23 <Riastradh> Whee, my beta reducer works.
18:25:40 <shapr> I want a gamma reducer
18:25:51 <Riastradh> Of course, I don't know if it's real beta reduction; it's what I think beta reduction is.  I really need some material to read on the Lambda-Calculus.
18:25:54 * shapr buys lead windows
18:26:57 <Riastradh> Hmm.
18:27:06 <shapr> how do I display results?
18:27:10 <Riastradh> show results
18:27:13 <shapr> privmsg the whole email to someone?
18:27:31 * Riastradh wants to know if his beta reducer is a real beta reducer.
18:27:53 * Igloo gets bored checking tests about 1/3 of the way through and decides it probably really works
18:27:58 <shapr> heh
18:28:00 <Riastradh> Would anyone mind if I pasted a couple lines of s-expressions for anyone to tell if his beta reducer is a real beta reducer?
18:28:11 <shapr> two lines? I say go for it.
18:28:23 <Riastradh> OK, first of all, if you do:
18:28:24 <Igloo> Does it check for variables being rebound deeper in the expression?
18:28:32 <Riastradh> (lc-eval (lc-compile 'I) *lc-default-env*)
18:28:36 <Riastradh> it returns:
18:28:51 <Riastradh> (closure x (lc-const . x) ())
18:29:27 <Riastradh> x is the parameter it takes, () is its lexical environment.
18:29:48 <Riastradh> (lc-beta-reduce (lc-eval (lc-compile 'I) *lc-default-env*) 'x 5)
18:29:50 <Riastradh> returns:
18:29:55 <Riastradh> (closure x (lc-const . 5) ())
18:30:22 <Igloo> Errr, what does closure x mean?
18:30:46 <Igloo> If that's \x -> 5 then it's wrong
18:30:46 <Riastradh> That's what you get when you evaluate \x.<blah>.
18:31:01 <Riastradh> OK, I thought it might be a bit off.
18:31:44 <Riastradh> What should beta-reducing (\x.x)5 return?
18:31:45 <Igloo> (\x -> E) F   is E with all instances of x replaced by F. Only it's more complex if E rebinds x or if x is free in F
18:31:53 <Igloo> 5
18:32:29 <Igloo> As hugs will tell you if you change . to ->   (beta reduction is basically function application)
18:33:26 <Riastradh> I already have a guard against x being free.
18:33:44 <Riastradh> OK, so doing:
18:33:54 <Igloo> The correct thing to do in that case is alpha-rename x in E to something that isn't free in F
18:33:57 <Riastradh> (lc-beta-reduce (lc-eval (lc-compile 'I) *lc-default-env*) 'x 5)
18:34:03 <Riastradh> should give you just '5',  right?
18:34:22 <Igloo> yes - you shouldn't be passing 'x to beta-reduce
18:34:30 <Riastradh> Er, good point.
18:35:01 <Igloo> When does your environment get changed OOI?
18:35:25 <Riastradh> 'OOI?'
18:35:32 <Igloo> Out Of Interest
18:35:44 <Riastradh> When does the 'environment get changed?'
18:35:49 <Riastradh> Rephrase, please.
18:36:03 <Igloo> When do you ever have anything other than lc-default-env?
18:36:14 <Riastradh> Oh, you can make whatever environment you like.
18:36:44 <Vincenz> night folks
18:36:50 <Riastradh> (lc-extend-env (lc-make-env-frame . binding-alist) outer-env)
18:36:57 <Igloo> Do you have let bindings or something?
18:36:59 <Igloo> Night
18:37:01 <Igloo> Doh
18:37:12 <Riastradh> Lambda binds things, duh.
18:37:48 <Igloo> But beta-reduction deals with that, you don't need environments
18:37:57 <Riastradh> I suppose I could add a LET device, too.
18:38:14 <Riastradh> Hmm...when should and shouldn't I use beta reduction?
18:38:38 <Igloo> You should use it when you want to simplify (\x -> E) F
18:39:08 <Riastradh> But let x = F in E is the same as (\x.E)F...unless there's something I missed when reading what little I have read about the Lambda-Calculus.
18:40:26 <Igloo> True, I guess it depends what you want to do
18:41:36 <Riastradh> Perhaps there should be a BETA-LAMBDA which automagically gets beta-reduced, and an ordinary LAMBDA which doesn't.
18:42:40 <Riastradh> (it isn't supposed to be a Lambda-Calculus interpreter for me to distribute as an example of the Lambda-Calculus; it's by now a way for me to play around with compiler techniques)
18:42:45 <shapr> yay FM is already Typeable
18:42:49 <Igloo> Right, I need to go to bed before I start implementing case statements
18:43:00 <shapr> hm
18:43:06 <shapr> ok, I'll give in to sleep also
18:43:08 <Riastradh> shapr - In Util, it gets a Typeable instance.
18:43:13 <shapr> Riastradh: yah, very handy
18:43:24 <shapr> I want to put the keyword index in there
18:43:34 <shapr> I bet that'll use a bit of ram.
18:43:59 <shapr> keyword index of 16mb of emails
18:44:21 <shapr> ok, time for sleep
18:44:35 <Riastradh> Argh, no one has a comment on having a BETA-LAMBDA and a LAMBDA separately?
18:44:47 * shapr oings away
18:57:04 <Darius> In an interpreter that wouldn't make any sense, and in a compiler it should be attempted without annotation (to a degree)
19:01:21 <Riastradh> But how should it know when to and when not to beta reduce?
19:05:18 <Darius> In an interpreter it always does when possible (at least for the applications it encounters), for a compiler its a mixture of heuristics and necessity.
19:06:28 <Darius> as Igloo said it's basically function application
19:07:51 <Riastradh> Heuristics?
19:09:10 <Darius> Inlining and beta reduction are very similar
19:11:59 * Riastradh really ought to get a book on the Lambda-Calculus.
21:17:37 <jlk> I have a few questions for the haskell experts here tonight:
21:17:37 <jlk> 1) how does haskell work with opengl? Does it work well? where can
21:17:37 <jlk> I gety it?
21:17:37 <jlk> 2) explain the instance parameters?:
21:17:37 <jlk>  (ie. class Functor f where fmap :: (a ->b)
21:17:38 <jlk> -> f a -> f b     instance Functor Tree where fmap (Lead x) = Leaf (f x)
21:17:40 <jlk> ...what role does Functor and tree perform?
21:17:42 <jlk> 3) where can I get demonstrations and source code for 
21:17:44 <jlk>    complete simple haskell programs?
21:17:46 <jlk> 4) fib@(1:tfib) = 1: 1 :[ a+b | (a+b | (a,b) <- zip fib tfib] ..... 
21:17:48 <jlk> Am I right in saying that the tfib is actually taken from the bytes
21:17:50 <jlk>  of the previous evaluation in this recursive function? If so how
21:17:52 <jlk> is the fist evalution accomplished?
21:17:54 <jlk> 5) where is a better example of lazy irrefutable patterns than the one
21:17:56 <jlk> in the Gentle Introdoction...? (one with ~pat)
21:17:58 <jlk> 6) how can you tell what the difference is between what the parameters
21:18:00 <jlk> actually are, what the the internal types worked on and what the end 
21:18:02 <jlk> result of of a function is by it's type declaration (::)?
21:20:04 <jlk> hello?
21:21:04 <jlk> :P
21:21:25 <tmoertel> 1) http://www.haskell.org/HOpenGL/
21:22:55 <tmoertel> 2) Functor is the class of container-like things supporting the equivalent of map over list: fmap
21:23:32 <tmoertel> 3) Follow some of the links in the topic of #haskell
21:24:28 <tmoertel> To look at some of my Haskell code, follow links at http://c2.com/cgi/wiki?TomMoertel
21:25:26 <tmoertel> 4) Not really.
21:26:28 <tmoertel> tfib is actually bound to everything in 1 : 1 : [ ... ] after the first 1
21:26:53 <tmoertel> i.e., 1 : [ ... ]
21:27:22 <tmoertel> The trick is that the part in [ ... ] is computed from preceeding elements lazily.
21:27:44 <tmoertel> Since the first two elements have been provided (1 and 1), that's enough to compute the third.
21:27:53 <tmoertel> The 2nd and 3rd are enough to compute the 4th, and so on.
21:28:54 <tmoertel> An equivalent definition is: fibs = 1 : 1 : [ a+b | (a,b) <- zip fibs (tail fibs) ]
21:29:33 <tmoertel> 5) Another lazy irrefutable pattern is fib in your definition in (4).
21:30:05 <tmoertel> Patterns bound with @ are automatically irrefutable, since that's almost always what you want. 
21:30:31 <tmoertel> 6) I'm not sure what you're asking, but I'll take a guess.
21:31:08 <jlk> 2) Well is tree the parameter to Functor?
21:31:30 <dennisb> 4) written in another way is: fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
21:32:11 <tmoertel> If you are considering a type signature like a -> b -> c,
21:32:21 <tmoertel> you can take it as a function taking two arguments (of types a and b)
21:32:30 <tmoertel> and returning a value of type c.
21:32:55 <tmoertel> Or, you can consider it a function that takes and a and returns a function taking a b that returns a c.
21:33:05 <tmoertel> Either interpretation is correct.
21:33:28 <tmoertel> Consider: f x y = x + y :: Int -> Int -> Int
21:33:37 <tmoertel> f :: Int -> Int -> Int
21:33:43 <jlk> hm, well what about a-> b -> c -> d -> e ?
21:33:44 <tmoertel> (f 1) :: Int -> Int
21:34:01 <tmoertel> (f 1 3) :: Int
21:34:49 <tmoertel> It takes four arguments of types a, b, c, and d and returns an e.
21:35:04 <tmoertel> Or it takes three arguments (a,b,c) and returns (d -> e)
21:35:18 <tmoertel> Or two arguments and returns (c -> d -> e).
21:35:28 <tmoertel> It's just a matter of how *you* choose to interepet it.
21:35:50 <jlk> ah.
21:36:00 <tmoertel> A bit mind-bending at first, but all-the-time currying comes in very handy.
21:36:20 <dennisb> the function arrow in types is right associative. The "correct" way to read a -> b -> c -> d -> e is a -> (b -> (c -> (d -> e)))
21:36:54 <jlk> what about private types within the functionality of the function's declaration , is their such a beast?
21:36:58 <dennisb> the parentheses is omitted since we know that -> is right associative
21:37:40 <dennisb> I don't understand the question
21:37:43 <tmoertel> jlk: firstN n = take n fibs where fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
21:37:56 <tmoertel> fibs is private to firstN
21:38:22 <tmoertel> If you want, you can provide a type annotation to fibs within firstN
21:38:54 <tmoertel> Is that what you mean?
21:40:26 <jlk> well the privatization was in reference to the :: 'has type' declaration.
21:41:18 <tmoertel> You can tack type annotations onto just about anything
21:41:58 <tmoertel> E.g., [1 :: Int, 2 :: Int, 3 :: Int] :: [Int]
21:41:58 <jlk> hm, lets see is is 1) parameter 2) private functionality 3) return value? or just 1+3?
21:42:46 <tmoertel> I don't understand what you mean. Can you elaborate?
21:44:18 <jlk> are the types which are used within a function available to the type delcaration (ie. temp variables (rather function conversions to said type) or state adjustments)?
21:45:26 <tmoertel> If the values used within a function are passed in or out, their types certainly must be a part of the type of the function.
21:46:31 <tmoertel> If they are purely internal to the function, their types are not part of the function's type per se,
21:48:02 <tmoertel> but if they somehow interact with arguments or a returned value, types must match.
21:48:40 <tmoertel> But usually, you can just not worry about it because type inference will take care of it for you.
21:49:09 <tmoertel> (Just don't bother to provide annotations for internal values or helper functions.)
21:50:37 <jlk> k
21:50:39 <jlk> danke
21:50:50 <tmoertel> you're welcome
21:51:15 <jlk> dennisb, so the right associateive is like a foldr scenerio?
21:52:00 <dennisb> I don't know what it means
21:52:26 <dennisb> functions are always called with exactly one argument
21:52:51 <dennisb> if you write f 4 2 it might look like you call f with 2 arguments but you don't
21:53:00 <tmoertel> i.e. f 1 2 3 is really ((f 1) 2) 3
21:53:54 <jlk> oh, well is that because of a curry?
21:54:07 <dennisb> since (my) f has type Int -> (Int -> Int) it is easy to see that f 4 has type Int -> Int
21:54:45 <dennisb> therefor (f 4) 2 has type Int which is not a function so you can not write f 4 2 6
21:56:47 <dennisb> It's because of the definition of the language. Functions work like this in haskell.
21:58:52 <dennisb> All functions take exactly one argument and some functions return another function that can take another argument, and so on. We can think of this as a function that takes several arguments, but that is just in out minds
22:00:08 <tmoertel> Of course, the two viewpoints are provably equivalent, so you are free to adopt whichever best fits the situation.
22:01:22 <jlk> tell me is it possible to carry events through function left of right like you can with smalltalk?
22:01:46 <tmoertel> Can you elaborate?
22:01:52 <dennisb> I've never even heard of that
22:03:00 <jlk> can the the state of one function be transplanted into the next? Though the language doesn't support it, i almost see it possible with supporting layers.
22:03:25 <dennisb> what is the state of a function?
22:03:30 <jlk> for if it has closure, it should. :)
22:03:37 * tmoertel was just going to ask that . . .
22:03:51 <jlk>              ^^^^ that would be the nearest equivilent of the state of a function, closure.
22:04:22 <dennisb> a Function is a Function, just like an Int is an Int :-)
22:04:29 <dennisb> (very nice explanation)
22:04:37 <tmoertel> jlk: are you referring to dynamic binding, as in elisp?
22:04:47 <jlk> lisp has closure though. does haskell have this?
22:05:06 <tmoertel> haskell does have closures
22:05:17 <jlk> ok.
22:05:20 <dennisb> plus a b = a + b
22:05:23 <tmoertel> but the idioms under which they are used are different from lisp
22:05:24 <dennisb> inc = plus 1
22:05:32 <dennisb> x = inc 4 + inc 3
22:05:43 <tmoertel> because you cannot modify values stored in a closure
22:05:47 <jlk> then you *could* curry closures is the point I'm getting at here.
22:06:11 <jlk> oh. that's odd.
22:06:33 <tmoertel> you can't modify *any* values in Haskell. it's purely functional
22:09:07 <dennisb> curry (and uncurry) is just a transformation between higher order functions like we have in haskell and functions that "take all arguments at once"
22:09:28 <jlk> well, can you have a function which tracks a literal?
22:09:59 <dennisb> I need an example to understand what that is
22:10:01 <tmoertel> yes, assuming by literal you mean a constant
22:10:24 <jlk> well can the constant be changed at all?
22:10:31 <tmoertel> no
22:10:43 <jlk> what about replaced?
22:10:50 <dennisb> no
22:10:55 <jlk> huh.
22:10:55 <tmoertel> no values in Haskell can be changed, nor replaced
22:11:10 <tmoertel> you can simply compute new values from the old and bind them to new variables
22:11:20 <tmoertel> jlk: do you know perl?
22:12:28 <jlk> Hell no..thank good no.
22:12:49 * tmoertel chuckles
22:15:21 <jlk> ah, let me get this right, so, if you lazily evaluate the process of old to new binding one get literally tie up state from within the lazy eval.
22:16:30 <tmoertel> yes, but strictly speaking, you don't need laziness for this
22:17:50 <dennisb> what's up with the obsession of states, since values don't change we don't need to focus on state like that
22:19:06 <jlk> why are map, fold*, filter the raw functions for haskell? is there math behind this reasoning?
22:20:32 <tmoertel> I wouldn't say that they are the fundamentals of Haskell, but they are powerful, useful functions.
22:20:40 <dennisb> Actually, the only reason is because they are useful. Likewise they are useful to mathematicians so they have studied them also
22:20:45 <jlk> dennisb, i think the obession tends to be things monads where invented. Opengl for example is a stateful system. I don't see how you can implement it without storing then altering states.
22:21:51 <dennisb> so in functional languages state is usually handled by writing functions that take the old state as input and returns the new state as output
22:22:37 <jlk> why then run a function more than one for a known state, is that where lazy takes over?
22:22:44 <dennisb> there is nothing primitive about map, fold and so on. They are all defined using haskell like any other function
22:23:20 <noodle> can someone tell me what's wrong with this expression?
22:23:23 <noodle> "findBlankLines xss = [ k | k <- [0..length xss] , xs <- xss , xs == [] ]"
22:23:35 <dennisb> what is the error message?
22:23:42 <noodle> hang on
22:24:19 <tmoertel> you need to zip your first to generated results
22:24:26 <tmoertel> s/to/two/
22:24:28 <noodle> Type: [[a]] -> [Int], Given context: (), Constraints: Eq a
22:24:50 <noodle> Cannot justify constraints in explicitly typed binding
22:25:28 <tmoertel> [ k | (k,xs) <- zip [0..] xss, xs == [] ]
22:25:53 <tmoertel> but you probably also need to fix your type annotation
22:25:57 <noodle> k
22:26:09 <noodle> is zip in the prelude?
22:26:15 <dennisb> yes
22:26:19 <noodle> k
22:26:24 <noodle> thx i'll look it up
22:27:29 <jlk> hy then run a function more than one for a known state, is that where lazy takes over?\
22:27:58 <dennisb> jlk: I think we are mixing things up, laziness and state are different things and maybe should be understood seperatly. Laziness is just that we calculate on demand. If there is a result we always get the same result, lazy or not
22:29:50 <dennisb> just because haskell is "lazy" and calculates something later then one might have expected does not mean that it's evaluated in some other state, giving som other result
22:29:52 <jlk> ok, this tell me that placements of functions will allow states to be updated only once, correct?
22:30:07 <dennisb> I don't know if this is what you ask, but it might be
22:31:34 <dennisb> Lets take an example. Lets pretend that the state is just a single Int value. Then we can write functions of the type: f (State,String) -> (State,String) instead of a function String->String
22:31:40 <jlk> well in order to make a game, one needs to track and update variable and also keep them in sync with opengl - a very stateful system. I want to see how that is done in haskell without un neccessarily retrieving known states.
22:32:32 <dennisb> And if State = Int then we can call it like f (4,"Dennis") and get back maybe (10,"Foo") and the next time we call f wi do it with the new state (10 in this case), and f will once again return a new state
22:33:12 <dennisb> then we have monads that will help us write functions like that but hiding the actual state being passed around
22:34:54 <dennisb> but the underlying idea even when using monads is that of passing a state around, at least that is how I understand it
22:36:49 <dennisb> can you see that f (State,String) -> (State,String) could be used for simulating state?
22:37:24 <jlk> k, well i think i get it now. t
22:37:33 <dennisb> if that is so, then I (think I) can continue explaining and arrive at Monads if you like
22:38:13 <dennisb> lets transform f into the equivalent function of the type f :: State -> String -> (State,String)
22:38:50 <dennisb> remember, we want to write a function f :: String->String that also can change some state (that's why we add the state both as input and output)
22:40:31 <dennisb> sorry, I made a misstake. I should have changed f to String -> State -> (State,String)
22:41:09 <dennisb> Now lets invent a new type: type MString = State -> (State,String). Then we can write the type of f like this: f :: String -> MString
22:41:56 <dennisb> or if we don't want to always return a String we can have. type M a = State -> (State,a)
22:42:05 <dennisb> then f :: String -> M String
22:42:30 <dennisb> this seems very similar to f :: String -> IO String, doesnt it (I guess you have seen IO?)
22:43:00 <jlk> not yet
22:44:14 <dennisb> f :: String -> String is a pure function that does not change any state. f :: String -> IO String is a function that also returns a String but can change the state while doing it
22:45:36 <dennisb> in the case of OpenGL changing the state can mean opening a windows, drawing a circle and so on. f :: String -> String can never do any OpenGL operations, it can not change the global state. f :: String -> IO String can change the global state and perform OpenGL operations if it wants to
22:46:07 <dennisb> this is hard to explain, i'm doing my best here :-)
22:47:57 <dennisb> well, maybe I shouldn't try so hard the next time...
22:48:16 <dennisb> sometimes it does more harm then good...
22:48:34 <Darius> the idea of monads is much more general than state passing
22:48:57 <dennisb> yes
22:49:59 <tmoertel> For more on interfacing Haskell w/ the rest of the world: http://research.microsoft.com/Users/simonpj/Papers/marktoberdorf
22:50:52 <Darius> good 'ole "Awkward Squad"
22:51:01 <tmoertel> indeed
22:51:28 <dennisb> still, the first and most important application for monads is the IO system that was in a bad State before we had monads
