02:34:33 <Janni> hya!
02:34:46 <mgoetze> morning Janni 
03:36:21 * shapr boings
03:44:24 <mgoetze> lambdabot: @fortune
03:44:26 <lambdabot> The Bible on letters of reference:
03:44:26 <lambdabot> 	Are we beginning all over again to produce our credentials?  Do
03:44:26 <lambdabot> we, like some people, need letters of introduction to you, or from you?
03:44:26 <lambdabot> No, you are all the letter we need, a letter written on your heart; any
03:44:26 <lambdabot> man can see it for what it is and read it for himself.
03:44:27 <lambdabot> 		-- 2 Corinthians 3:1-2, New English translation
03:44:45 <shapr> good quote
03:44:47 <shapr> hi mgoetze!
03:47:10 <mgoetze> hi shapr!
03:47:58 <shapr> what's up?
03:48:14 <mgoetze> i'm reading about prime numbers
03:48:34 <mgoetze> unfortunately, haskell is very inefficent at the lucas-lehmer test :(
03:49:14 <shapr> you could write an FFI wrapper
03:49:17 <shapr> :-)
03:53:01 * mgoetze needs to start understanding FFT, anyway.
04:03:41 * Segora is twisting his brain with 'The algebra of computing'
04:57:19 <mgoetze> lambdabot: @fortune
04:57:19 <lambdabot> Over the years, I've developed my sense of deja vu so acutely that now
04:57:19 <lambdabot> I can remember things that *have* happened before ...
04:57:40 * shapr doesn't understand that quote
04:58:24 <mgoetze> shapr: well, in english, "deja vu" is used idiomatically even when the speaker hasn't actually experienced something before
04:59:34 <shapr> ohh
04:59:34 <shapr> I see
04:59:40 <shapr> thanks
05:00:21 <mgoetze> (not saying it's funny or anything)
05:00:46 <shapr> hey, new lambdabot plugin released today
05:00:49 <shapr> written by Darius 
05:01:06 <Riastradh> shapr, how do I get a list of modules?
05:01:31 <shapr> Riastradh: (keysFM (ircModules s))
05:01:43 <shapr> assuming s <- get in :: ... -> IRC ()
05:02:06 <shapr> I should really clean out ircModules
05:02:11 <shapr> it's not really used at the moment.
05:02:21 <Riastradh> I just used it.
05:02:26 <shapr> oh, ok then :-)
05:03:08 <Riastradh> I must go, now -- I'll work on it later.
05:03:10 <shapr> I'm considering moving all the doFOO functions from Main.hs to IRC.hs, what do you think?
05:03:12 <shapr> ok, cool
05:18:10 <Janni> re
05:18:31 <shapr> hey Janni 
05:45:13 * shapr yawns
05:45:18 <shapr> soon
05:46:31 * Janni eats ice-cream
05:46:33 <Janni> now!
05:51:41 * shapr organizes lambdabot 1.0 release
06:35:58 <SyntaxPolice> today's my birthday :-)
06:36:14 <andersca> happy birthday to the syntax police
06:37:00 <shapr> happy birthday SyntaxPolice! how old are you?
06:38:10 <mgoetze> happy birthday to you / you live in a zoo / you look like a monkey / and you smell like one too! (to the tune of "happy birthday")
06:40:55 <andersca> lambdabot: @listmodules
06:40:55 <lambdabot> I have the following modules installed: ["eval","fact","fortune","hello","karma","state","system","topic"]
06:41:00 <andersca> lambdabot: @system
06:41:00 <lambdabot> Sorry, I don't know that command, try "lambdabot: @listcommands"
06:41:11 <andersca> lambdabot: system
06:41:12 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
06:41:13 <shapr> andersca: @listcommands shows the commands
06:41:17 <andersca> oh sorry :)
06:41:21 <andersca> lambdabot: @listcommands
06:41:21 <lambdabot> I react to the following commands: ["define","echo","eval","fact","fortune","goodbye","hello","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","msg","part","quit","set-fuel","state","topic"]
06:41:29 <andersca> lambdabot: @eval 1+1
06:41:29 <lambdabot> 2
06:41:37 <shapr> I'm planning on adding @listcommands <modulename> but haven't done it yet.
06:41:46 <andersca> can you do eval [1..]
06:42:20 <shapr> Darius is giving me a demo of the @eval plugin on #joy right now
06:42:20 <shapr> it's a lambda calculator =)
06:42:23 <andersca> lambdabot: @eval 1:2:3
06:42:23 <lambdabot> (line 1, column 2):
06:42:23 <lambdabot> unexpected ":"
06:42:23 <lambdabot> expecting digit, operator, simple term or end of input
06:42:25 <andersca> oh :)
06:42:51 <shapr> Darius: you want to do an @eval demo here on #haskell also?
06:43:19 <Darius> yah, it's pretty much lambda calculus with relational/if and arithmetic
06:43:28 <shapr> I've read about the S,K,I,Y combinators, but I've never played with them directly
06:44:19 <Darius> lambdabot: @eval Y (\fib n.if n == 0 || n == 1 then 1 else fib (n-1) + fib (n-2)) 20
06:44:19 <lambdabot> out of fuel
06:44:22 <Darius> lambdabot: @eval Y (\fib n.if n == 0 || n == 1 then 1 else fib (n-1) + fib (n-2)) 10
06:44:22 <lambdabot> 89
06:44:35 <Darius> the fuel it to avoid infinite recursion
06:44:44 <andersca> oh cool
06:44:51 <Darius> or just dominating shapr's overpowerful machine
06:44:55 <shapr> heheh
06:45:08 <shapr> I need this box for web development ;-)
06:45:26 <Darius> you can define new top-level variables with @define, e.g. Y is defined as...
06:45:45 <Darius> lambdabot: @define Y (\f.(\x.f(x x))(\x.f(x x)))
06:45:45 <lambdabot> Y defined
06:46:07 <Darius> lambdabot: @eval (\x.x x) (\x.x x)
06:46:08 <lambdabot> out of fuel
06:46:16 <Darius> lambdabot: @eval S I I (S I I)
06:46:16 <lambdabot> out of fuel
06:46:42 <Darius> using Y makes recursion almost as simple as Haskell (at least for a single function)
06:47:03 <Janni> Darius: neat! :)
06:47:16 <Darius> lambdabot: @eval Y (\funcname param. if param == 0 then 0 else funcname (param - 1)) 100
06:47:16 <lambdabot> 0
06:47:23 <Darius> or better named
06:47:38 <Darius> lambdabot: @eval Y (\count n. if n == 0 then 0 else count (n - 1)) 100
06:47:39 <lambdabot> 0
06:48:31 <shapr> nifty
06:48:35 <Darius> The definitions aren't persistent so when lambdabot resets, they'll go away.  I don't see that as too much of a problem
06:48:46 <Darius> lambdabot: @fact eval-example
06:48:46 <lambdabot> (\f.(\x.f(x x))(\x.f(x x)))(\fac acc n.if n == 0 then acc else fac (n*acc) (n-1)) 1 100
06:49:36 <Janni> s/neat/great (just realised that "neat" is not a very strong expression)
06:49:57 <Darius> andersca: btw the list module was the one I was thinking of next.  Mainly just defining the nice Haskell syntax
06:50:48 <Darius> Of course you'd have to use head/tail/null as there's no pattern matching and I don't see that for a while
06:51:13 <Darius> but hey, that's what foldr's for
06:52:06 <Darius> If you're really up to it you can define cons/nil/null?/head/tail with just lambda calculus
06:52:18 <shapr> that would be spiffy 
06:52:25 <shapr> would be a great 'online' irc course
06:53:15 <Smerdyakov> Darius, that is easy!
06:53:21 <shapr> Smerdyakov: show us!
06:53:38 <Smerdyakov> That wouldn't be much fun, now would it, since I already know the answers from a class?
06:53:53 <shapr> it would be fun for me :-)
06:54:06 <shapr> it's true that self-exploration can be fun
06:54:16 <Darius> I know some of the answers and could probably figure the rest, and with if and arithmetic some would be much easier
06:54:50 <Smerdyakov> Well, define nil = \k f . k
06:55:25 <Darius> lamdabot: @define nil \k f.k
06:56:09 <Darius> hmm
06:56:18 <Darius> ah
06:56:19 <Smerdyakov> And cons = \a l . \k f . f a l (l k f)
06:56:22 <Darius> lambdabot: @define nil \k f.k
06:56:22 <lambdabot> nil defined
06:56:22 <Smerdyakov> I think that's it...
06:57:01 <Darius> lambdabot: @define cons (\a l.(\k f. f a l (l k f)))
06:57:02 <lambdabot> cons defined
06:57:25 <Smerdyakov> Now it should be clear how to define the rest.
06:57:57 <Darius> The professor's trick "the rest is left as an exercise"
06:59:19 <Smerdyakov> If it's not obvious how to define the rest, then you could stand to figure it out :P
07:00:04 <Darius> I wonder if fortune has this quote from _On Lisp_
07:00:04 <Darius> Instead of seven ways of using macros, it might be better to say that there are
07:00:05 <Darius> six and a half. In an ideal world, all Common Lisp compilers would obey inline
07:00:05 <Darius> declarations, and saving function calls would be a task for inline functions, not
07:00:05 <Darius> macros. An ideal world is left as an exercise to the reader.
07:00:50 <Smerdyakov> Darius, do you know how to write the others?
07:01:34 <Darius> Not off the top of my head, and then there's the choice between using pure lambda calculus or the "extensions" implemented
07:01:52 <Smerdyakov> Extensions like?
07:02:08 <Darius> True False if etc.
07:02:15 <Smerdyakov> You don't need special support for those.
07:02:24 <Darius> I know, but the syntax is nice
07:02:48 <Smerdyakov> lambdabot: #define true \a b. a
07:02:48 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
07:02:55 <Darius> CPP?
07:03:03 <Smerdyakov> lambdabot: @define true \a b. a
07:03:03 <lambdabot> true defined
07:03:10 <Smerdyakov> lambdabot: @define false \a b. b
07:03:10 <lambdabot> false defined
07:03:24 <shapr> hi Hallski 
07:03:38 <Smerdyakov> lambdabot: @define if \x. x
07:03:38 <lambdabot> if defined
07:04:13 <Smerdyakov> lambdabot: @define not \b. if b false true
07:04:13 <lambdabot> (line 1, column 21):
07:04:13 <lambdabot> unexpected end of input
07:04:13 <lambdabot> expecting var, num, bool, "(", operator, simple term or "then"
07:04:23 <Smerdyakov> lambdabot: @define not \b. (if b false true)
07:04:23 <lambdabot> (line 1, column 22):
07:04:23 <lambdabot> unexpected ")"
07:04:23 <lambdabot> expecting var, num, bool, "(", operator, simple term or "then"
07:04:35 <Smerdyakov> lambdabot: @define not (\b. (if b false true))
07:04:35 <lambdabot> (line 1, column 23):
07:04:35 <lambdabot> unexpected ")"
07:04:35 <lambdabot> expecting var, num, bool, "(", operator, simple term or "then"
07:04:46 <Smerdyakov> Agh
07:04:50 <Smerdyakov> It's already in there, apparently
07:04:51 <Darius> if is special syntax
07:04:55 <Smerdyakov> lambdabot: @define If \x. x
07:04:55 <lambdabot> If defined
07:05:00 <Smerdyakov> lambdabot: @define not (\b. (If b false true))
07:05:00 <lambdabot> not defined
07:05:07 <Darius> not defined (hehe)
07:05:10 <Smerdyakov> Ohhh
07:05:10 <Smerdyakov> Heh
07:05:17 <Smerdyakov> @eval not true
07:05:22 <Smerdyakov> lambdabot: @eval not true
07:05:22 <lambdabot> type error
07:05:35 <Smerdyakov> lambdabot: @eval not
07:05:35 <lambdabot> (line 1, column 4):
07:05:35 <lambdabot> unexpected end of input
07:05:35 <lambdabot> expecting end of "not" or simple term
07:05:37 <shapr> Hallski: learning Haskell? long time user? just looking for andersca? =)
07:05:44 <Darius> er not is special too
07:05:53 <Smerdyakov> lambdabot: @define Not (\b. (If b false true))
07:05:53 <lambdabot> Not defined
07:06:02 <Smerdyakov> lambdabot: @define False \a b. b
07:06:03 <lambdabot> False defined
07:06:09 <Smerdyakov> lambdabot: @define True \a b. a
07:06:09 <Hallski> shapr: just looking for andersca :)
07:06:09 <lambdabot> True defined
07:06:10 <Darius> No False is special false isn't
07:06:15 <Smerdyakov> !!
07:06:20 <Darius> It mimics Haskell when it can
07:06:29 <Smerdyakov> lambdabot: @eval Not true
07:06:29 <lambdabot> <<EM Dynamic -> EM Dynamic>>
07:06:40 <Darius> yeah that's a function
07:06:47 <Darius> which is the correct result
07:06:56 <shapr> Hallski: ok, if you get the urge to try Haskell, we can hook you up with lots of good stuff :-)
07:07:03 <Hallski> hehe
07:07:06 <Smerdyakov> We need a base type that can be displayed! What is it?
07:07:10 <Darius> Hallski: get the urge to try haskell
07:07:19 <andersca> Hallski is more of a C# guy actually
07:07:19 <Darius> Integers or Bools
07:07:23 <Hallski> haha
07:07:27 <Smerdyakov> Ohno! Cheating!
07:07:28 <shapr> ow
07:07:32 * Hallski hides 
07:07:53 <Smerdyakov> lambdabot: @define showBool \b. If b 1 0
07:07:53 <lambdabot> showBool defined
07:07:59 <Smerdyakov> lambdabot: @eval showBool (Not true)
07:07:59 <lambdabot> 0
07:08:05 <Smerdyakov> lambdabot: @eval showBool (Not false)
07:08:05 <lambdabot> 1
07:08:21 <Smerdyakov> @eval nil
07:08:27 <Smerdyakov> lambdabot: @eval nil
07:08:27 <lambdabot> <<EM Dynamic -> EM Dynamic>>
07:08:45 <Smerdyakov> lambdabot: @eval cons 0 (cons 1 nil)
07:08:45 <lambdabot> <<EM Dynamic -> EM Dynamic>>
07:09:04 <Darius> lambdabot: @eval S (S K K) (S K K) (S (S K K) (S K K))
07:09:04 <lambdabot> out of fuel
07:09:17 <Smerdyakov> lambdabot: @define fold \f b l. l b f
07:09:17 <lambdabot> fold defined
07:09:51 <shapr> at this rate named persistent environments for @eval could be useful
07:09:54 <Smerdyakov> lambdabot: @define and \b1 b2. If b1 b2 false
07:09:54 <lambdabot> and defined
07:10:17 <shapr> hello Marvin--, esap 
07:10:22 <Smerdyakov> lambdabot: @eval showBool (fold and true nil)
07:10:23 <lambdabot> 1
07:10:32 <Smerdyakov> lambdabot: @eval showBool (fold and true (cons true nil))
07:10:32 <lambdabot> <<EM Dynamic -> EM Dynamic>>
07:10:37 <Smerdyakov> :-O
07:10:44 <Darius> lambdabot: @eval fold (\x y.x+y) 0 (cons 5 (cons 4 (cons 3 (cons 2 (cons 1)))))
07:10:44 <lambdabot> type error
07:11:45 <shapr> looks like the @eval readme could be large :-)
07:12:31 * shapr considers HWS-WP <-> lambdabot interoperability
07:12:33 <Smerdyakov> How do I see a stored definition?
07:13:10 <Smerdyakov> lambdabot: jhfa
07:13:11 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
07:13:14 <Smerdyakov> lambdabot: @listcommands
07:13:14 <lambdabot> I react to the following commands: ["define","echo","eval","fact","fortune","goodbye","hello","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","msg","part","quit","set-fuel","state","topic"]
07:13:16 <Darius> Yeah, it's stored pre-parsed as a function
07:13:35 <Darius> There's no going back, but I was thinking about having @define squirrel the string away somewhere
07:13:48 <SyntaxPolice> shapr: I'm 24 today.
07:13:50 <Smerdyakov> Oh, I remember now.
07:13:57 <shapr> SyntaxPolice: yay! 
07:14:02 <shapr> SyntaxPolice: do you feel old and wise now?
07:14:14 <SyntaxPolice> shapr: yes. suddenly.
07:14:22 * shapr grins
07:14:47 <Smerdyakov> lambdabot: @define fold \f b l. l b (\a l' acc. f a acc)
07:14:47 <lambdabot> fold defined
07:14:54 <Darius> lambdabot: @eval fold (\x y.x+y) 0 (cons 5 (cons 4 (cons 3 (cons 2 (cons 1)))))
07:14:54 <lambdabot> type error
07:14:55 <Smerdyakov> lambdabot: @eval showBool (fold and true (cons true nil))
07:14:55 <lambdabot> 1
07:14:58 <Smerdyakov> Hooray
07:15:03 <Smerdyakov> lambdabot: @eval showBool (fold and true (cons false nil))
07:15:04 <lambdabot> 0
07:15:06 <Smerdyakov> Huzzah
07:15:10 * shapr cheers
07:15:35 <Smerdyakov> shapr, have you followed it, then?
07:15:41 <shapr> somewhat
07:15:48 <shapr> I have a log that I will pick to pieces later =)
07:15:57 <shapr> thanks for the interactive demo
07:16:20 <Smerdyakov> lambdabot: @eval fold (\x y.x+y) 0 (cons 5 (cons 4 (cons 3 (cons 2 (cons 1 nil)))))
07:16:20 <lambdabot> 15
07:16:25 <Marvin--> hi
07:16:27 <Darius> doh
07:16:34 <Darius> I knew that :P
07:16:49 <shapr> Smerdyakov: would you mind if I edited the log of stuff you've input to put into the README for the @eval command?
07:16:55 <Smerdyakov> Not mind
07:16:56 <Marvin--> hmm? we have an eval? cute
07:16:58 <shapr> yay :-)
07:17:23 <debug> hm
07:17:32 * shapr bounces happily
07:17:34 <Darius> Here's the extent of the documentation so far (short of the log for today)
07:17:43 <Darius> lambdabot: @fact eval-example
07:17:43 <lambdabot> (\f.(\x.f(x x))(\x.f(x x)))(\fac acc n.if n == 0 then acc else fac (n*acc) (n-1)) 1 100
07:17:51 <Smerdyakov> @lambdabot: @define makePair \a b f. f a b
07:17:54 <Smerdyakov> lambdabot: @define makePair \a b f. f a b
07:17:54 <lambdabot> makePair defined
07:18:02 <Darius> You could read the source with such wonderful as "{- bugger it, I'll just use Dynamics
07:18:09 * shapr snickers
07:18:10 <Marvin--> is it just an extended lambda calculus?
07:18:24 <Darius> yeah
07:18:40 <Smerdyakov> lambdabot: @define matchPair \p f. p f
07:18:40 <lambdabot> matchPair defined
07:18:51 <Darius> (or really just syntactic sugar and efficiency over lambda calculus)
07:19:01 <Marvin--> okay
07:19:03 <Marvin--> still cute :)
07:19:06 <Marvin--> what about Y?
07:19:18 <Marvin--> does it have a reduction counter?
07:19:23 <Darius> yeah
07:19:34 <Darius> lambdabot: @eval S I I (S I I)
07:19:34 <lambdabot> out of fuel
07:19:39 <Marvin--> :-)
07:19:44 <Darius> Y is defined
07:19:47 <Darius> so
07:19:56 <Smerdyakov> lambdabot: @define fst \p. matchPair p (\a b. a)
07:19:56 <lambdabot> fst defined
07:20:01 <Smerdyakov> lambdabot: @define snd \p. matchPair p (\a b. b)
07:20:01 <lambdabot> snd defined
07:20:03 <Darius> lambdabot: @eval Y (\fac acc n.if n == 0 then acc else fac (n*acc) (n-1))
07:20:03 <lambdabot> <<EM Dynamic -> EM Dynamic>>
07:20:06 <Darius> lambdabot: @eval Y (\fac acc n.if n == 0 then acc else fac (n*acc) (n-1)) 1 100
07:20:06 <lambdabot> 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000
07:20:24 <Smerdyakov> lambdabot: @eval fst (makePair 1 2)
07:20:25 <lambdabot> 1
07:20:28 <Smerdyakov> lambdabot: @eval snd (makePair 1 2)
07:20:28 <lambdabot> 2
07:20:30 <andersca> Marvin--: how did you handle parsing too big integers when doing your compiler?
07:20:36 <shapr> hi jak_
07:20:37 <Darius> But the definitions aren't persistent.  Only the syntactic sugar is
07:20:47 <shapr> bye jak_
07:20:59 <Marvin--> andersca: we just turned it over to jasmin verbatim and let it deal with it
07:21:10 <andersca> Marvin--: ok
07:21:16 <Smerdyakov> I hope you guys realize that this simple lambda calculus is enough to implement all of an untyped Haskell in a way that is easy to code =)
07:21:26 <jak_> hi shapr
07:21:30 <shapr> hello!
07:21:39 <shapr> Smerdyakov: you got fst and snd really fast
07:21:43 <Darius> Of course, lambda calculus can compute all things computable
07:22:00 <shapr> that's very spiffy
07:22:06 <Smerdyakov> Darius, I said "easy to code".... as in "your programs in the end look just like Haskell with some minor syntax transformations"
07:22:26 <Darius> Not if you don't allow definitions ;)
07:22:42 * andersca bounces
07:22:48 <Smerdyakov> Bah =)
07:22:49 <shapr> I'm now very tempted to write up a Joy interpreter
07:22:49 <opet> Smerdyakov: nice and efficient, too ;)
07:23:01 <shapr> no, must release lambdabot 1.0 first!
07:23:28 <Darius> Hey it only took a coupla minutes to evaluate factorial 10 (I think) using Scheme and only lambda
07:23:39 <Marvin--> no @definitions command?
07:23:41 <Darius> (with two helper functions for sanity)
07:23:55 <Darius> Yes define too
07:24:02 <Darius> but that wouldn't effect efficiency
07:24:09 <Marvin--> how do I get the available definitions?
07:24:25 <Darius> You can get what is defined, you can easily define anything you want
07:24:40 <Darius> Just try it and hope it's there
07:24:48 <Marvin--> so no way to list them?
07:24:51 <Marvin--> lambdabot: @eval Y
07:24:51 <lambdabot> <<EM Dynamic -> EM Dynamic>>
07:24:55 <Smerdyakov> lambdabot: @define append fold (\a f l. cons a (f l)) nil
07:24:56 <lambdabot> append defined
07:24:58 <Marvin--> lambdabot: @eval fst
07:24:59 <lambdabot> <<EM Dynamic -> EM Dynamic>>
07:25:00 <Marvin--> I mean...
07:25:05 <Darius> Here are the keywords ["if","then","else","not","True","False"] })
07:25:26 <Marvin--> yes yes, but it would be helpful to have a command for listing everything that's been created with @define
07:25:31 <Smerdyakov> lambabot: @eval 1 == 1
07:25:46 <shapr> Marvin--: quick, add it!
07:25:52 <Segora> lambdabot: @help
07:25:52 <lambdabot> Sorry, I don't know that command, try "lambdabot: @listcommands"
07:25:55 <Smerdyakov> No respone?!
07:25:58 <Smerdyakov> lambabot: @eval 1
07:26:02 <Darius> d
07:26:03 <Smerdyakov> lambdabot: @eval 1
07:26:03 <lambdabot> 1
07:26:05 <Smerdyakov> lambdabot: @eval 1 == 1
07:26:06 <lambdabot> True
07:26:06 <shapr> Segora: tomorrow :-)
07:26:13 <Segora> shapr: *g*
07:26:35 <Smerdyakov> lambdabot: @define result append (cons 0 (cons 1 nil)) (cons 2 (cons 3 nil))
07:26:35 <lambdabot> result defined
07:26:50 <shapr> I know how to write @help, just haven't done it yet.
07:26:53 <Marvin--> let expressions would be handy
07:27:07 <Darius> As would pattern matching
07:27:18 <Darius> much more syntactic sugar
07:27:52 <Darius> you can define instead of let, anyways let x=y in b is just (\x. b) y
07:28:17 <Marvin--> not with letrecs :)
07:29:08 <Smerdyakov> @define nth \n l. fold (\a p. if (fst p == n) then makePair (fst p + 1) a else makePair (fst p + 1) (snd p)) (makePair 0 0)
07:29:12 <Smerdyakov> lambdabot: @define nth \n l. fold (\a p. if (fst p == n) then makePair (fst p + 1) a else makePair (fst p + 1) (snd p)) (makePair 0 0)
07:29:13 <lambdabot> nth defined
07:29:34 <Smerdyakov> lambdabot: @eval nth 0 result
07:29:35 <lambdabot> <<EM Dynamic -> EM Dynamic>>
07:29:50 <Smerdyakov> lambdabot: @define nth \n. fold (\a p. if (fst p == n) then makePair (fst p + 1) a else makePair (fst p + 1) (snd p)) (makePair 0 0)
07:29:50 <lambdabot> nth defined
07:29:52 <Smerdyakov> lambdabot: @eval nth 0 result
07:29:52 <lambdabot> type error
07:30:00 <Marvin--> Darius: couldn't you have used  -> instead of . so we at least can pretend it's haskell? :)
07:30:35 <Smerdyakov> lambdabot: @define nth \n. fold (\a p. if ((fst p) == n) then makePair ((fst p) + 1) a else makePair ((fst p) + 1) (snd p)) (makePair 0 0)
07:30:35 <lambdabot> nth defined
07:30:38 <Smerdyakov> lambdabot: @eval nth 0 result
07:30:39 <lambdabot> type error
07:31:30 <Smerdyakov> It would be nice to see where the type error is!
07:32:35 <Darius> I personally like spaces around my -> but that leads to four characters, I thought that the dot was better for online
07:32:54 <Darius> and I don't have a (.) to worry about... yet
07:33:12 * Smerdyakov goes away: shower
07:33:24 <shapr> Smerdyakov: thanks!
07:38:39 <shapr> y0 pesco 
07:38:45 <pesco> yay shapr!
07:39:06 <shapr> how's ghc treating you?
07:39:19 <pesco> woah, make binary-dist is very tiring.
07:40:04 <pesco> Right now I'm building a binary distribution of ghc 4 without profiling support in parallel with ghc 5 with GHCi and everything
07:40:15 <shapr> yow
07:40:33 <shapr> making the whole build chain available?
07:40:55 <pesco> What do you mean by build chain?
07:41:33 <pesco> Hrng, it always wants to generate the documentation, too, although it's totally useless!
07:41:41 <shapr> building ghc5 requires ghc4, yes?
07:41:46 <pesco> Yes.
07:41:51 <pesco> Ah, I get you.
07:41:56 <shapr> so, the chain of requirements
07:42:12 <shapr> I think that's called a toolchain
07:42:45 <pesco> Hm, no I think a toolchain is something like ghc->gcc->as->ld
07:43:33 <Marvin--> yes
07:43:37 <pesco> I think build chains fits it good enough.
07:43:38 <Marvin--> I think so too
07:44:35 <Marvin--> hm, wonder if I have time to go to Jörgen's talk next week
07:44:59 <Marvin--> the talk is at 13.15 and the interview is at 15.00
07:45:00 <Marvin--> should work
07:45:05 <shapr> suddenly, I realize why people put a dist into Makefiles
07:45:20 <pesco> Heh
07:45:31 <Marvin--> ?
07:45:52 <shapr> cause it's a pain to manually clean out all the .o and .hi files to create a sources tgz
07:46:17 <Marvin--> http://www.fileshack.com/file.x?fid=2585  uhmmm
07:46:19 <Marvin--> ah, yes
07:46:36 <Marvin--> late april fool's joke I gues
07:46:37 <Marvin--> s
07:46:45 <Marvin--> no wait, the file is dated Apr 1, so it's just /. that's slow
07:54:24 <SyntaxPolice> can you guys think of a rule for when its best to use one vs the other of these two decls:
07:54:26 <SyntaxPolice> type Foo = (A, B, C)
07:54:26 <SyntaxPolice> data Foo = Foo A B C
07:55:33 <Smerdyakov> The second is almost always better to me, since it prevents mix-ups from types with the same representation but different intended meanings.
07:55:37 <shapr> you can't make "type Foo" an instance of other typeclasses iirc
07:55:59 <SyntaxPolice> true true.
07:56:01 <pesco> right, that would be a technical reason for data
07:56:19 <SyntaxPolice> And I can't think of a time where I'll want (A,B,C) to be the same as Foo...
07:56:48 * pesco bounces
07:56:48 * shapr boings
07:56:48 * SyntaxPolice dances around
07:56:53 <Smerdyakov> Does anyone here know when the NSF Graduate Fellowships for this year will be announced??
07:57:09 * mgoetze shows SyntaxPolice a birthday cake
07:57:13 <mgoetze> here ... catch!
07:57:16 <pesco> Sometimes a tuple just appears more natural, i.e. if you're modelling after a paper or other well-known work where they talk about tuples.
07:57:27 <pesco> s/i.e./e.g./
07:57:42 <shapr> SyntaxPolice: one advantage of type Foo is that you can unpack it more easily
07:57:55 * SyntaxPolice catches the cake.... with  his face!
07:58:21 * mgoetze releases balloons
07:58:22 <SyntaxPolice> or when modeling coordinates or something...
07:59:14 <pesco> Anything like that
08:00:07 <SyntaxPolice> I like using type for stuff like "type Time = Float" or "type Direction = (Float, Float)" then I don't have to comment the code as much.
08:00:26 <SyntaxPolice> thats what I usually use type for. almost everythign else I use data for.
08:03:41 * SyntaxPolice needs to read other people's haskell more though...
08:03:56 <shapr> wanna write a lambdabot plugin? ;-)
08:05:52 <SyntaxPolice> shapr: I haven't been following the lambdabot stuff... can you tell me what it does?
08:06:11 <mgoetze> lambdabot: @fortune
08:06:12 <lambdabot> Why isn't there a special name for the tops of your feet?
08:06:12 <lambdabot> 		-- Lily Tomlin
08:06:15 <SyntaxPolice> is there a way to tell hugs to give me more warnings? like shadowed stuff?
08:06:31 <shapr> in a nutshell, lambdabot is a big dispatch table for irc events
08:07:00 <SyntaxPolice> is fortune an irc event?
08:07:11 <shapr> er
08:07:13 <shapr> sort of
08:07:21 <shapr> lambdabot: @echo blah
08:07:21 <lambdabot> echo; msg:IRCMessage {msgPrefix = "shapr!~user@h224n1fls32o1017.telia.com", msgCommand = "PRIVMSG", msgParams = ["#haskell",":lambdabot: @echo blah"]} rest:"blah"
08:07:32 <shapr> that's what an IRCMessage looks like internally
08:07:46 <shapr> plugins register their commands
08:07:54 <shapr> there's a Module typeclass
08:08:09 <shapr> lambdabot: @listcommands
08:08:09 <lambdabot> I react to the following commands: ["define","echo","eval","fact","fortune","goodbye","hello","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","msg","part","quit","set-fuel","state","topic"]
08:08:42 <shapr> lambdabot: @listmodules
08:08:42 <lambdabot> I have the following modules installed: ["eval","fact","fortune","hello","karma","state","system","topic"]
08:09:09 <shapr> I'm making a lambdabot 1.0 release right now
08:10:51 <pesco> tar cjf ../ghc-4.08.2-powerpc-unknown-linux.tar.bz2 ghc-4.08.2
08:10:58 * pesco grins
08:11:03 <shapr> yay!
08:11:22 <pesco> lambdabot: @eval 1+5
08:11:22 <lambdabot> 6
08:11:26 <pesco> woo!
08:12:26 <pesco> lambdabot: @eval (\x -> x x) (\x -> x x)
08:12:26 <lambdabot> (line 1, column 5):
08:12:26 <lambdabot> unexpected "-"
08:12:26 <lambdabot> expecting identifier or "."
08:12:41 <SyntaxPolice> lambdabot: @eval (\x -> x) $ 6
08:12:42 <lambdabot> (line 1, column 5):
08:12:42 <lambdabot> unexpected "-"
08:12:42 <lambdabot> expecting identifier or "."
08:13:00 <pesco> lambdabot: @eval (\x . x) (\x . x)
08:13:00 <lambdabot> <<EM Dynamic -> EM Dynamic>>
08:13:23 <pesco> Hey, that's what I was just about to implement!!
08:13:45 <SyntaxPolice> hm, so how much will lambdabot eval? are there any security problems there?
08:13:52 <SyntaxPolice> maybe he won't do anything in the IO monad?
08:13:57 <pesco> lambdabot: @eval (\x . x x) (\x . x x)
08:13:57 <lambdabot> out of fuel
08:13:59 <Marvin--> it's just lambda calculus
08:14:00 <pesco> hihihi
08:14:06 <SyntaxPolice> ahh
08:14:11 <shapr> and it has a max recursion setting
08:14:33 <shapr> hey Arnia 
08:14:37 <pesco> lambdabot: @fact eval
08:14:37 <lambdabot> Nothing
08:14:43 <pesco> lambdabot: @fact @eval
08:14:43 <lambdabot> Nothing
08:14:54 <shapr> pesco: @help module tomorrow :-)
08:14:58 <pesco> lambdabot: @fact EvalModule
08:14:59 <lambdabot> Nothing
08:15:03 <Arnia> Heya
08:15:13 <pesco> shapr: *g* good
08:25:07 <Darius> SyntaxPolice: no it isn't in the IO monad
08:26:35 <Darius> You could try to overwhelm memory making big numbers.
08:26:59 <Darius> And I'm pretty certain you can get it kicked for Excess flood, but you could do that anyways
08:31:48 <shapr> ok, Darius just committed @definitions and @get-definition for EvalModule
08:31:53 <shapr> lambdabot: @definitions
08:31:53 <lambdabot> []
08:32:01 <shapr> lambdabot: @define a 1 + 1
08:32:02 <lambdabot> a defined
08:32:04 <shapr> lambdabot: @definitions
08:32:04 <lambdabot> ["a"]
08:32:11 <shapr> lambdabot: @get-definition a
08:32:11 <lambdabot>  1 + 1
08:32:56 <Darius> lambdabot: @fact lambdabot-version-1.0 now with more FiniteMap goodness
08:32:56 <lambdabot> Sorry, I don't know that command, try "lambdabot: @listcommands"
08:33:14 <shapr> I commented out @fact for the tgz
08:33:28 <shapr> since most people won't have the postgresql bindings installed
08:33:51 <pesco> Can't you just distribute them with it?
08:34:38 <shapr> I might be able to distribute a lambdabot binary
08:35:21 <shapr> HToolkit is a ghc package, so you have to build/install it on your machine
08:35:48 <shapr> I'll switch to using a file database in @fact before the next release
08:35:57 <pesco> Nah!
08:36:11 <Darius> Just have both supported
08:36:16 <shapr> good point
08:40:34 <Marvin--> try { import HToolKit } ... no wait :)
08:41:18 <shapr> heh
08:41:38 <Darius> Hmm, you could probably hack something in TH to get precisely that effect (though it'd be easier to just conditional compilation a la TH or CPP)
08:42:34 <Darius> lambdabot: @modules
08:42:35 <lambdabot> Sorry, I don't know that command, try "lambdabot: @listcommands"
08:42:39 <Darius> lambdabot: @listmodules
08:42:39 <lambdabot> I have the following modules installed: ["eval","fortune","hello","karma","state","system","topic"]
08:42:48 <Darius> lambdabot: @listcommands
08:42:48 <lambdabot> I react to the following commands: ["define","definitions","echo","eval","fortune","get-definition","goodbye","hello","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","msg","part","quit","set-fuel","state","topic"]
08:43:24 <Darius> lambdabot: @define Y (\f.(\x.f(x x))(\x.f(x x)))
08:43:25 <lambdabot> Y defined
08:43:53 <Darius> lambdabot: @eval Y (\count n.if n == 0 then 0 else count (n-1)) 1000
08:43:53 <lambdabot> out of fuel
08:43:59 <Darius> lambdabot: @eval Y (\count n.if n == 0 then 0 else count (n-1)) 999
08:43:59 <lambdabot> out of fuel
08:44:03 <Darius> lambdabot: @eval Y (\count n.if n == 0 then 0 else count (n-1)) 500
08:44:05 <lambdabot> out of fuel
08:44:07 <Darius> lambdabot: @eval Y (\count n.if n == 0 then 0 else count (n-1)) 250
08:44:08 <lambdabot> 0
08:44:14 <Darius> lambdabot: @eval Y (\count n.if n == 0 then 0 else count (n-1)) 375
08:44:14 <lambdabot> out of fuel
08:44:35 <Darius> lambdabot: @eval (375+250)/2
08:44:35 <lambdabot> 312
08:44:38 <Darius> lambdabot: @eval Y (\count n.if n == 0 then 0 else count (n-1)) 312
08:44:38 <lambdabot> 0
08:44:53 <Darius> lambdabot: @eval (312+375)/2
08:44:53 <lambdabot> 343
08:44:56 <Darius> lambdabot: @eval Y (\count n.if n == 0 then 0 else count (n-1)) 343
08:44:57 <lambdabot> out of fuel
08:45:02 <Darius> lambdabot: @eval Y (\count n.if n == 0 then 0 else count (n-1)) 335
08:45:02 <lambdabot> out of fuel
08:45:07 <Darius> lambdabot: @eval Y (\count n.if n == 0 then 0 else count (n-1)) 330
08:45:07 <lambdabot> 0
08:45:10 <Darius> lambdabot: @eval Y (\count n.if n == 0 then 0 else count (n-1)) 332
08:45:11 <lambdabot> 0
08:45:13 <Darius> lambdabot: @eval Y (\count n.if n == 0 then 0 else count (n-1)) 333
08:45:14 <lambdabot> out of fuel
08:49:45 <shapr> anyone else want to try this before I put it up on sf.net? - http://kungens.kemi.fi/~shae/lambdabot-1.0.tar.gz
08:53:11 <mgoetze> shapr: don't put it on sf.net
08:53:19 <mgoetze> shapr: put it on savannah or something
08:53:43 <shapr> why?
08:56:37 <Marvin--> haskell-libs already *is* on sf.net
08:59:07 <Darius> lambdabot: @definitions
08:59:07 <lambdabot> ["Y","a"]
09:01:09 <pesco> damn, I'm running out of disk space!
09:03:58 * pesco .oO(alias broom=rm -r)
09:10:36 <shapr> as lambdabot said earlier, "the time for action has passed, now is the time for useless bickering."
09:10:52 <shapr> or something like that :-)
09:11:41 <SyntaxPolice> shapr: what about blame? you forgot blame.
09:12:30 <shapr> oh right
09:12:45 <shapr> that's an important part of every balance meeting.
09:12:49 <shapr> "balanced"
09:12:58 <opet> blame VB
09:13:08 <opet> chances are it's done something wrong
09:13:59 <andersca> lambdabot: @eval 6*15
09:13:59 <lambdabot> 90
09:14:09 <Darius> _it_ is wrong
09:18:16 <shapr> yay!
09:18:45 <shapr> lambdabot 1.0 "Candy Shop" is online!
09:19:20 * shapr bounces happily
09:19:30 <shapr> now I just have to announce on haskell@haskell.org
09:19:56 * andersca ponders subscribing to haskell mls
09:20:06 <shapr> haskell@ is relatively low traffic
09:20:10 <shapr> haskell-cafe@ is a lot more fun
09:20:27 <shapr> all sorts of random stuff there
09:25:56 <hdaume> sup fellas
09:26:00 <shapr> hey hal
09:33:25 <pesco> Is there anyone else on this channel who has a PowerPC running Linux (to test the GHC binary on)?
09:33:39 <shapr> ok, I sent the announcement
09:33:45 <shapr> I hope I got everything right
09:34:08 * shapr dances cheerfully
09:34:23 <shapr> the first #haskell project has had its first release! w00!
09:35:35 <mgoetze> ok, what's our next project? how about a bootloader? :)
09:35:53 <shapr> you want to run the GHC runtime system on the raw hardware?
09:35:56 * shapr thinks about that
09:36:11 <emu> oskit
09:36:20 <pesco> Well, LISP machines are getting kind of old...
09:36:32 <emu> ghc would be no good anyway though
09:36:35 <emu> not w/o a lot of changes
09:36:52 <emu> it's not interactive like the lispms were
09:36:53 * pesco mumbles something unidentifiable
09:36:55 <shapr> what about the Helium LVM?
09:37:11 <pesco> logical volume manager?
09:37:16 <shapr> lazy virtual machine
09:37:17 <emu> wha, every time you want to change something, oyu gotta reboot? what is this, MS?
09:37:26 <shapr> part of Daan Leijen's thesis
09:37:30 <shapr> emu: eh?
09:37:39 <emu> (functional languages assume perfection)
09:37:40 <pesco> shapr: Tell me about it.
09:37:59 <shapr> pesco: that's about all I know :-) Marvin-- probably knows more than I do.
09:38:15 <shapr> or you can read the PDF about the LVM from the Helium website.
09:38:23 * emu is quite sleepy
09:38:28 <shapr> me too
09:38:29 * pesco makes a note in his head
09:38:39 <mgoetze> emu: sleepy? hm, how about a game of go? lol
09:38:45 <emu> i'm in class too
09:39:20 <shapr> lambdabot: @quit
09:39:33 <emu> what a good little lambda
09:39:52 * pesco sees little lambdas bouncing and floating about
09:39:58 <mgoetze> shapr: does it listen to just anyone?
09:40:02 <shapr> mgoetze: try it ;-)
09:40:13 <mgoetze> lambdabot: @quit
09:40:14 <lambdabot> not enough privileges
09:40:18 <emu> boring
09:40:19 --- kick: lambdabot was kicked by mgoetze (mgoetze)
09:40:27 * shapr laughs
09:40:28 <pesco> show-off
09:40:31 <mgoetze> shapr: yup, works :)
09:40:32 * shapr laughs much
09:41:03 <Arnia> lambdabot: @dance
09:41:03 <lambdabot> Sorry, I don't know that command, try "lambdabot: @listcommands"
09:41:07 <shapr> mgoetze: that *must* be the theme quote for the next release :-)
09:41:34 <mgoetze> shapr: lol
09:42:04 <pesco> Who started release quotes?!
09:42:35 <shapr> pesco: I wanted to have a quote of the release for 1.0, but I was too tired to choose one.
09:44:12 <Darius> lambdabot: now with 20% more FM goodness
09:44:13 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
09:44:24 <Darius> How many FiniteMaps do we have in there, like 12
09:44:41 <Darius> I think there are four or five in relation to EvalModule alone
09:45:52 * shapr laughs
09:45:53 <shapr> truly
09:46:03 <shapr> lambdabot: @fact lambdabot 
09:46:03 <lambdabot> the coolest (only) irc 'bot written in Haskell., is rude
09:46:17 <shapr> lambdabot: @fact lambdabot now with 20% more FM goodness
09:46:18 <lambdabot> set lambdabot to now with 20% more FM goodness
09:48:00 <shapr> hm, I've just realized there aren't any directions on how to use lambdabot once it's built and running.
09:48:01 <shapr> oops
09:49:56 <pesco> lambdabot: @eval 0.0001 + 0.00005
09:49:58 <lambdabot> (line 1, column 2):
09:49:58 <lambdabot> unexpected "."
09:49:58 <lambdabot> expecting digit, operator, simple term or end of input
09:50:09 <pesco> lambdobot: @eval 5/2
09:50:15 <pesco> lambdabot: @eval 5/2
09:50:15 <lambdabot> 2
09:50:18 <pesco> ok.
09:52:27 <Darius> Yeah, no rationals
09:54:14 <emu> gee
09:54:21 <emu> lambdabot fails arithmetic
09:54:53 <pesco> lambdabot, if you keep this up, you're gonna FLUNK!
09:55:06 <mgoetze> lambdabot: @eval x/2 where x = head [4..8]
09:55:06 <lambdabot> (line 1, column 13):
09:55:06 <lambdabot> unexpected " "
09:55:06 <lambdabot> expecting "=="
09:55:08 <emu> did someone infect lambdabot with C?
09:55:08 <Darius> Not Integer arithmetic
09:56:23 <Darius> lambdabot: @define Y (\f.(\x.f(x x))(\x.f(x x)))
09:56:23 <lambdabot> Y defined
09:56:53 <mgoetze> lambdabot doesn't know about where?
09:57:12 <Darius> It's mostly a slightly extended lambda calculus, not embedded haskell
09:57:31 <emu> tsk
09:57:38 <Darius> It doesn't know about 'c' or (:) or many more
09:58:05 <emu> you had to write your own parser, too?
09:58:36 <Darius> I probably didn't have to too much, I did though.
10:00:05 <Darius> If/When it gets (much) closer to Haskell I'd probably steal the parser that comes with GHC
10:00:29 <shapr> could steal ghci entirely
10:00:40 <emu> gotta learn to READ
10:00:54 <shapr> ?
10:05:26 <hdaume> or just use runhugs :)
10:06:46 <Darius> Yeah, that's part of why I didn't go crazy
10:06:57 <hdaume> ooh, it knows how to deal with /msg :)
10:07:10 <shapr> yah, Marvin-- requested that recently
10:07:43 <Darius> You could get most of Haskell by just shelling out to runhugs (though you may collect processes on shapr's machine and there's no sure-fire infinite recursion check)
10:07:49 <Marvin--> lambdabot: @karma lambdabot
10:07:50 <lambdabot> lambdabot has a karma of 0
10:08:22 <Marvin--> Darius: heh.... @eval unsafePerformIO (system "rm -rf /")
10:08:38 <shapr> if someone here has worked with the Haddock sources, I'd like to write a Haddock plugin for lambdabot, and am looking for some advice/assistance
10:08:55 <hdaume> shapr: to do what?
10:09:35 <Darius> Marvin--: lol, that too 
10:11:05 * pesco mumbles something about emppc in linker c
10:11:19 <hdaume> Marvin--: this wouldn't be too hard....just use runhugs and don't import unsafePerformIO...then make it 'main = print ___whatevertheytyped___'.  then there's no chance of them running actions.  to fix the recursion problem, you could just have it fork out a process which gets killed after 60 seconds and then reports that it took too long
10:11:59 <hdaume> actually nevermind, they could still run actions :)
10:12:27 <hdaume> but they'd need to define something like "<<=" the opposite of ">>=".  perhaps 'main = putStrLn (show ___)' would be safer
10:12:51 <Marvin--> =<< already exists :-)
10:12:54 <Darius> =<< is defined
10:12:58 <hdaume> ah :)
10:13:42 <hdaume> then 'eval =<< system "rm -rf /"' it is :)
10:13:46 <andersca> :)
10:14:09 <Darius> Anyways, it'd be more difficult to play with.  How about shift/reset? I could add that in a jiffy.  _That's_ trippy.
10:14:09 * hdaume is off for a bit
10:15:44 <Darius> let g = if shift id then 1 else 2 in g True + g False ==> 3
10:17:35 <Darius> er let g = reset(if shift id then 1 else 2) in g True + g False
10:17:44 <Marvin--> shift?
10:17:48 <Marvin--> reset?
10:18:51 <Darius> Partial continuations.  Kind of like callCC only much trickier.  reset delimits a continuation and shift passes it's argument the current continuation until the closest reset
10:19:02 <Marvin--> good god
10:19:23 <Darius> 1+reset(10+shift(\k -> k (k 100))) = 121
10:19:40 <Darius> One level isn't too bad.
10:19:47 * shapr 's brain segfaults trying to read that
10:20:02 <Darius> The if one above is really sickening.
10:20:19 <Darius> that addition one is fairly straightforward
10:20:44 <Darius> the continuation of shift is 1+reset(10+[])
10:20:50 <Marvin--> okay so it takes the (10+) and passes that into k
10:20:50 <Darius> reset delimits it so it's just
10:20:53 <Darius> 10 + []
10:21:04 <shapr> segmentation fault could have a interesting dual meaning in one of those snake robots
10:21:47 <pesco> I'd say centipede.
10:21:54 <shapr> pesco: yah, you're right
10:22:05 <Marvin--> ho ho ho
10:22:10 <Marvin--> yousa funny
10:22:20 <shapr> hdaume: I want a HaddockPlugin so I can do @haddock foldr and get all the Haddock docs from the GHC sources
10:22:53 <shapr> type signature, examples, etc
10:22:56 <mgoetze> so, any volunteers to write the bootloader plugin to lambdabot?
10:22:59 * Marvin-- watches mklibs run
10:23:07 <shapr> mgoetze: what would it do?
10:23:10 <Marvin--> \-lilo?
10:23:26 <mgoetze> Marvin--: i like grub, but i want one written in haskell!
10:23:27 <Marvin--> bootstrapping gets a whole new meaning in lambda calculus :P
10:23:42 <pesco> grand unified boot lambda?
10:23:56 <Marvin--> Y is the mother of all bootstrapping
10:23:59 <mgoetze> shapr: uhm, install itself into boot sectors, read filesystems, load kernels...
10:24:44 <shapr> scary
10:25:46 <Darius> lambdabot: @get-definition Y
10:25:47 <lambdabot>  (\f.(\x.f(x x))(\x.f(x x)))
10:27:57 * shapr has an inspiration for a new lambdabot plugin
10:30:32 <shapr> jak_: do you know Lindsay Errington?
10:32:09 <jak_> no, she at imperial?
10:32:16 <jak_> or is it a he :) ?
10:32:20 <shapr> I don't know
10:32:35 <jak_> definitely at IC
10:32:51 <shapr> but I think that person wrote all or some of the exactreal Haskell code in haskell-libs
10:33:07 <jak_> ah
10:33:20 <shapr> just curious if it was either you or someone you knew
10:33:59 <jak_> heh
10:34:48 <pesco> Isn't it horrible how one ends up knowing peoples' names for their contribution to something but never being quite sure about their gender?
10:35:36 <Marvin--> I kinda like it, makes you more open-minded
10:36:07 <shapr> yah, I agree.
10:36:25 <shapr> Shae is primarily a female name in the US where I come from
10:36:58 <Darius> I've almost never heard of a Shae
10:37:10 <pesco> Like short for Shaela, I knew a girl with that name.
10:37:17 <Darius> Definitely not personally, or even passingly
10:37:17 <shapr> Darius: well, I started out with Robert, aka "Ben"
10:37:20 <shapr> but that got boring
10:37:36 <Darius> I'm content with my name.
10:38:01 <shapr> me too
10:39:50 <Marvin--> "Robert aka Ben"??? :)
10:40:04 <shapr> Marvin--: used to be Robert Benjamin Gilliam
10:40:08 <shapr> I was called "Ben"
10:40:10 <Marvin--> ohh
10:40:50 * Marvin-- tries to think of a background story for his tin can character
10:46:58 * kawfee bounces
10:47:08 * shapr boings furiously
10:47:21 * mgoetze listens to furious music
10:47:30 <shapr> what music?
10:47:41 * shapr is listening the one good track from Jimmy Eat World
10:47:55 <mgoetze> bach, orchestral suite no. 2 in b minor
10:48:48 <Darius> shapr: What? Jimmy's good.
10:49:10 <shapr> Darius: you know 'em?
10:49:16 <Darius> Andres Segovia playing Sarabande is excellent.
10:49:16 <Darius> yah
10:49:21 * shapr is surprised
10:49:26 <shapr> I randomly found them on mp3.com
10:49:32 <Darius> Not my favorite band, but damned good.
10:49:43 <shapr> Prayer Chorus is awesome
10:49:47 <Darius> lambdabot: @fact BadReligion Best Band Ever
10:49:47 <lambdabot> set badreligion to Best Band Ever
10:49:50 <Darius> Praise Chorus
10:49:54 <shapr> yes, that one
10:50:09 <shapr> actually, I don't think I've heard anything else from them.
10:50:17 <Darius> I use to not like Authority Song, now it's one of my favorites.
10:50:25 <shapr> they had quicktime or something on their website
10:51:00 <Darius> Bad Religion's a pretty old band (for a punk band).  They're going on 40.  First started in 1980.
10:51:23 <Darius> They are a pretty big band too, but not well known... it's kind of weird
10:51:39 <shapr> bad religion was popular in my high school.
10:51:47 <Darius> What's weirder is check out www.derekelkins.com
10:51:55 <shapr> yah, I saw that already ;-)
10:51:59 <Darius> I also play guitar
10:52:02 <shapr> cool!
10:52:21 <shapr> I figure derekelkins.com /= Darius 
10:52:54 <shapr> am I right?
10:53:29 <Darius> well wander around that site, then check out thebrpage.tierranet.com
10:55:40 <shapr> is derekelkins.com your website?
10:55:54 * shapr is confused
10:56:46 <Darius> Not in the least.  That guy's like a preacher, I'm not even Christian.
10:57:05 <shapr> I am, just in case anyone doesn't already know :-)
10:57:19 <shapr> not a preacher, Christian
10:57:34 <shapr> man cannot live on lambda calculus alone ;-)
10:57:39 * shapr grins
10:58:16 * shapr tries to stuff an email into this parser
10:58:29 <Darius> It makes no difference to me. Despite the somewhat provoking sign, Bad Religion is much more about tolerance and individuality.  Of course, I like the song My God by Pennywise...
10:58:35 <Darius> Fun to play.
11:05:35 <Darius> One problem with being a Bad Religion fan though, is I don't think I could enjoy myself at a concert where people jump and scream but that's all.
11:05:54 <Marvin--> "fighter/wizard spellsword"... spellsword *groan*
11:06:03 * shapr snickers
11:06:04 <shapr> cute pun
11:06:08 * andersca boings
11:07:10 * shapr brukar
11:07:22 <shapr> andersca: is that right?
11:07:36 <andersca> nej
11:07:39 <andersca> studsar = bounces
11:07:42 <shapr> ohh
11:07:43 <shapr> tack
11:07:47 * shapr studsar
11:08:27 <shapr> I actually enjoy mosh pits
11:08:39 <shapr> haven't been to a concert in several years though
11:09:13 <Darius> The moral of my last concert is, if you're going to go crowd surfing make sure you get to the front.  You DON'T want to end partway.
11:09:19 <shapr> truly
11:09:34 <Darius> That was while Flogging Molly was playing
11:09:38 <shapr> crowd surfing is dangerous unless you're an attractive female
11:09:59 <Marvin--> heh
11:10:09 * Marvin-- went to Stratovarius the other week
11:10:15 <Darius> One attractive female ended up taking a fall near me, because some of the people around were jerks.
11:10:24 <shapr> :-(
11:10:57 <shapr> I'm tempted to move south where they have real rock concerts
11:11:04 <Darius> She got up and said she was fine, though she was bleeding.  Of course, I got up and said I was fine, though my left arm didn't work all the way.
11:11:12 <shapr> yow
11:11:26 <Marvin--> shapr: come to sweden rock this summer :)
11:11:45 <shapr> I weight 215 lbs, so no one has tried to make me crowd surf lately
11:12:03 <Darius> What's worse, is the concert was in a rocky like parking lot thing.  It sucked.
11:12:09 <shapr> oww
11:12:12 <shapr> Marvin--: I'll try to
11:13:15 <shapr> is there a literal string thingy in Haskell?
11:13:22 <shapr> something like triple quoting in Python?
11:26:34 <_Codex> what does triple quoting do in python?
11:27:02 <shapr> everything between triple quotes is a literal string
11:27:12 <shapr> and can span many lines, etce
11:27:46 <shapr> I'm trying to parse an email message, so I wanted to just paste it into my Haskell source buffer for testing
11:31:31 <shapr> hey dark
11:31:34 <shapr> what's up?
11:31:34 <dark> Hello :)
11:31:48 <mgoetze> hi dark
11:31:58 <dark> I'm trying to catch up on email.  And admiring the Duke Nukem 3D source release :)
11:31:59 <mgoetze> we're having a birthday party, come on and join in on the fun!
11:32:06 <dark> Whose birthday?
11:32:09 <mgoetze> SyntaxPolice: 
11:32:21 <shapr> weren't you working on a megahal in haskell?
11:32:45 <dark> shapr: Yeah but I gave that up.  I did it mainly to try out some new algorithms and they turn out to suck :)
11:32:53 <shapr> does it do anything at all?
11:33:07 <shapr> could be an entertaining lambdabot plugin
11:33:14 <dark> Yeah, I fed it a history of #haskell and made it produce a sentence.
11:33:17 <dark> It was "lol"
11:33:21 * shapr laughs
11:33:27 <shapr> very scary
11:33:28 <dark> Then I knew it had learned everything there was to know about IRC communication :)
11:33:46 <dark> Unfortunately, I can't get the memory use under control.
11:33:54 <shapr> how much does it use?
11:35:03 <dark> Hmm, not sure.  It seems to run out of stack space rather than memory.  It eats a megabyte of stack with just a 2000-line input file.
11:35:06 * pesco sighs at the other xterm
11:35:14 <shapr> weird
11:35:45 <shapr> dark: is the code online somewhere? even if it just produces random output, it could be fun to plug into lambdabot 
11:35:49 <dark> It's probably my heavy use of FiniteMaps.  They have some weird strictness qualities.
11:36:01 <dark> Heh, I ran it just now and got:
11:36:06 <dark> it doesn't *do* anything yet
11:36:11 <shapr> hi nbd 
11:36:50 <nbd> hi
11:37:14 <shapr> nbd: learning Haskell? long time user?
11:37:18 <shapr> what can we do for you?
11:37:30 <Darius> Hmm, my connections looking like it's going to kill itself.  I'll be right back.
11:37:45 <dark> shapr: It's not online anywhere yet.
11:38:21 <dark> Its main failing right now (other than the memory thing) is its tendency to quote people exactly.  This may be a side-effect of not being able to use large enough samples because of the stack problem...
11:38:22 * pesco stares in amazement at the puff of smoke that was Darius 
11:38:29 <nbd> shapr: learning. just read a part of the haskell tutorial and found it interesting
11:38:54 <shapr> if you want to share megaha(skel)l, I'll put it into haskell-libs, and then anything could happen
11:39:22 <SyntaxPolice> shapr: you should make lambdabot notice when its meeting someone for the first time and tell you :-)
11:39:25 * shapr mugs people for their source code
11:39:31 <shapr> SyntaxPolice: ohh, good idea!
11:39:46 <mgoetze> SyntaxPolice: so, are you partying today or something?
11:39:55 <shapr> he's on irc, I doubt it :-)
11:40:11 <SyntaxPolice> mgoetze: i went out to lunch... may go out to dinner... ATM i'm at work.  my last insane deadline was replaced by a more insane deadline for a new project :(
11:40:15 <SyntaxPolice> but at least its in Haskell.
11:40:15 <dark> shapr: I call it "eviltwin" :)
11:40:16 <andersca> I was on irc new years eve 1999
11:40:25 <dark> shapr: Though I admit Megahaskell is cute.
11:41:10 <shapr> SyntaxPolice: yow, you need a coprocessor
11:41:26 * shapr succeeds in parsing an email
11:41:27 <shapr> yay!
11:43:01 <shapr> this rfc2822 parser is much better than the code I was working on
11:43:58 <shapr> dark: so, what's been happening lately? did you get sucked into writing C or something?
11:44:22 <shapr> nbd: do you have any questions?
11:45:04 <nbd> shapr: not yet, just watching the channel, got other things to do right now.
11:45:08 <dark> shapr: No, though I did have a flirt with linux-kernel :)
11:45:32 <mgoetze> shapr: i lured him here with quotes of dark talking about megahal :)
11:45:37 <shapr> did you prototype that FP fs?
11:45:51 <shapr> mgoetze: good move!
11:46:52 <dark> shapr: I don't really understand clausen's ideas on that, but I do think I get phase trees now.
11:47:43 <dark> shapr: I went and read basically all of the list archives relating to that :)
11:49:04 <dark> I asked Daniel Phillips what was up with tux2, and he told me this:
11:49:10 <dark> Tux2's phasetree algorithm has, according to Hans Reiser, influenced the
11:49:10 <dark> design of ReiserFS version 4.  I'd love to get back to work on Tux2, but it's
11:49:10 <dark> tough to do without a sponsor.
11:49:36 <andersca> looks like I'm gonna use QuickCheck in my next lab assignment
11:51:18 <Marvin--> eh? you taking datalogins grunder or something?
11:51:43 <andersca> yeah
11:52:19 <shapr> dark: sounds like a project worth sponsoring
11:52:40 <Marvin--> uhm..why? in my memory you took courses like Programming Languages last semester
11:53:00 <Riastradh> shapr, what should the type of hooks be?
11:53:41 <andersca> Marvin--: cos I have to take them for the base block?
11:53:51 <Marvin--> andersca: then how did you take Programming Languages?
11:53:54 <Riastradh> (Module m) => m -> IRCMessage -> IRC ()  ?
11:54:26 <andersca> Marvin--: I did that because I had already taken the java and haskell courses (and a data structure course)
11:55:55 <Riastradh> And how should I make a list given a size and an element to fill it with?
12:00:55 <Riastradh> Oh, 'replicate.'
12:06:41 * Kuril is away: to store
12:08:01 * Riastradh pokes shapr.
12:08:56 <mgoetze> take size foo where foo = elem:foo
12:09:42 <shapr> wha?
12:10:08 <shapr> er
12:10:18 <Riastradh> shapr - For the hook methods in the 'Module' class.
12:10:45 <shapr> that looks good to me
12:14:18 <tic> heh
12:14:22 <tic> are there only swedes on this channel? :)
12:14:31 * shapr uses the "two hands and a compass" algorithm in his email search engine
12:14:33 <tic> s/on/in
12:14:41 <shapr> tic: I'm from Alabama.
12:14:49 <mgoetze> tic: swedes and wannabe swedes
12:14:52 * Riastradh would like to move to Sweden...but alas, he is condemned to the U.S.
12:14:52 <shapr> hey!
12:15:16 <shapr> I really need to get around to the @lart plugin
12:15:21 <mgoetze> lol
12:15:28 <Riastradh> Luckily, I'm in one of the parts that isn't swarmed with loud-mouthed Texan extremist conservative right-wing nuts.
12:15:49 <Riastradh> @lart?
12:16:08 <shapr> I've forgotten what the abbreviation stands for
12:16:17 <mgoetze> luser attitude readjustment tool
12:16:19 <shapr> ah
12:16:20 <mgoetze> man lart
12:16:31 <shapr> no man entry
12:16:41 <shapr> http://foldoc.doc.ic.ac.uk/foldoc/foldoc.cgi?query=lart&action=Search
12:16:52 <mgoetze> shapr: apt-get install asr-manpages
12:17:07 <shapr> y0 Vincenz 
12:17:21 <shapr> mgoetze: whoa, cool!
12:17:23 <Vincenz> hihi :)
12:17:41 <mgoetze> shapr: while you're at it, apt-get install funny-manpages
12:17:52 <Marvin--> yeah, man sex :-)
12:18:33 <mgoetze> HISTORY
12:18:33 <mgoetze>        Oldest program ever.
12:22:46 <shapr> looks like maildir stores mails with \n between lines
12:22:53 <shapr> not \r\n
12:24:25 <Vincenz> my god this is a good book
12:24:31 <Vincenz> almost 800 pages
12:24:52 <Vincenz> still only at page 60
12:24:57 <Vincenz> doing the exercises: )
12:24:59 <Vincenz> :
12:25:00 <Vincenz> )
12:25:07 <Vincenz> ugh, I'm tired, can't type
12:25:23 <Riastradh> What book?
12:25:36 <shapr> I didn't know the foldoc guy put the strictness analyzer into GHC
12:26:03 <Vincenz> the free pdf of the translation of the french oreilly book on OCaml
12:27:16 <SyntaxPolice> shapr: can lambdabot to keep state across command invocations?
12:27:26 <shapr> SyntaxPolice: yup, see the StateModule.hs for a demo
12:27:31 <shapr> lambdabot: @state blah
12:27:31 <lambdabot> nothing yet
12:27:34 <Riastradh> lambdabot: @state foo
12:27:34 <lambdabot> blah
12:27:35 <shapr> lambdabot: @state foo
12:27:35 <lambdabot> foo
12:27:37 <Riastradh> Heh.
12:27:41 <shapr> :-)
12:27:46 <Riastradh> Predictable?  Who?
12:28:44 <shapr> we could add across transparent persistent state across lambdabot invocations if Binary.hs gets released soon
12:28:56 <shapr> or we could try the one that comes with Haddock
12:29:34 <shapr> or we could hack up "deriving Postgres" with Template Haskell =)
12:30:08 * shapr goes back to his hi-tech email search engine
12:35:28 <pesco> Aw man, I can't get to rest before GHCi runs.
12:35:58 <shapr> I think there's a bug in the Text.Regex lib
12:37:48 <shapr> what do you guys get from: import Text.Regex ; putStr $ show $ matchRegexAll (mkRegexWithOpts "foo" False False) "bazfoobar"
12:41:31 <hdaume> Just ("ba", "foo", "bar", [])
12:41:34 <hdaume> which seems wrong to me :)
12:45:37 <hdaume> brb
13:19:09 <Riastradh> How do I get the current calendar time?
13:19:28 <shapr> I think FortuneModule does that
13:19:48 <shapr> yes, look at intGet
13:22:51 <shapr> lambdabot: @quit
13:23:44 <shapr> lambdabot: @karma
13:23:44 <lambdabot> I can't find the karma of nobody.
13:23:45 <Vincenz> lambdabot: @kiss shapr
13:23:45 <lambdabot> Sorry, I don't know that command, try "lambdabot: @listcommands"
13:23:49 <Vincenz> lambdabot: @kiss Vincenz
13:23:50 <lambdabot> Sorry, I don't know that command, try "lambdabot: @listcommands"
13:23:54 <Vincenz> lambdabot: @karma Vincenz
13:23:55 <lambdabot> You have a karma of 0
13:23:59 <shapr> Vincenz: new plugin you're writing?
13:24:18 <Vincenz> kiss?
13:24:22 <Vincenz> heh, no :/
13:24:28 <Vincenz> I'm learning Ocaml currently
13:25:03 <shapr> maybe next week :-)
13:25:13 <Vincenz> lol
13:25:17 <Vincenz> right...
13:25:27 <Vincenz> I'm not that good and I barely have free time
13:25:28 <Vincenz> :(
13:35:07 <shapr> lambdabot: @listcommands
13:35:07 <lambdabot> I react to the following commands: ["define","definitions","echo","eval","fact","fortune","get-definition","goodbye","hello","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","msg","part","quit","set-fuel","state","topic-cons","topic-init","topic-snoc","topic-tail","topic-tell"]
13:35:59 <Vincenz> Woo, my Ocaml-exercises are going great
13:36:21 <Marvin--> Vincenz: sicko ;)
13:36:42 <Vincenz> what?
13:36:56 <Vincenz> anyone who can read ocaml and knows FP?
13:39:50 <Vincenz> my my, I didn't know FP could make code so reusable
13:40:04 <Vincenz> every step extra I take to add a feature is less code
13:40:56 --- mode: ChanServ set +o shapr
13:40:59 --- mode: shapr set -t
13:41:11 --- topic: set to '["mo' nads than you","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","New Hat 2.02 http://www.haskell.org/hat/","New Learning Haskell page - http://www.haskell.org/learning.html","GUI Demos - http://repetae.net/john/computer/haskell/gui/","Order Haskell 98 Report in Hardcopy - http://titles.cambridge.org/catalogue.asp?isbn=0521826144","GHC 5.04.3 released!","lambdabot \"Candy Shop\" 1.0 now with 20% more FM"]' by lambdabot
13:41:34 --- mode: shapr set -o shapr
13:43:06 <Marvin--> FM as in finite map?
13:43:09 <shapr> yup
13:44:20 <opet> why -t?
13:44:36 <shapr> to test the new lambdabot topic editing plugin
13:44:38 <Riastradh> So that lambdabot can change the topic.
13:45:07 <opet> oh ok
13:45:28 <opet> fair enough :)
13:47:07 * Vincenz happily keeps making homework for himself (this is not even for a class)
13:47:52 <shapr> speaking of which...
13:47:53 <Marvin--> good for you
13:47:56 <shapr> I need to do my swedish homework
13:48:08 <Riastradh> Wait, don't go away yet.
13:48:08 <Marvin--> how's class coming along?
13:48:14 <shapr> Marvin--: it's great!
13:48:27 <Marvin--> shapr: what kind of other nutcases are there in the class? :)
13:48:30 <shapr> right now we're doing fin fint fina
13:48:49 <shapr> actually, all the other people in the class are pretty normal
13:49:05 <shapr> but, they're always worried when they ask me to make up questions, or come up with answers =)
13:49:05 <Riastradh> shapr - What you showed me in the FortuneModule won't work for me.
13:49:08 <pesco> Oh I love how Haskell code just gets prettier and prettier the more you work on it.
13:49:40 <shapr> Riastradh: what do you need?
13:50:12 <Marvin--> shapr: heh, why?
13:50:44 <Riastradh> shapr - A, er, way to get the current date as a calendar time.
13:50:44 <shapr> everyone else does stuff like a robot, following the teacher's example almost exactly.
13:50:52 <shapr> I get creative
13:51:11 <shapr> when asked about pets, I claimed I had a björn at home.
13:51:14 * Vincenz wishes there was this much chatter on #ocaml
13:51:26 <Marvin--> *lol*
13:51:31 <shapr> Vincenz: well, talk lots on #ocaml
13:51:33 <Riastradh> Haha.
13:51:42 <Vincenz> hehe :P
13:51:48 <Vincenz> once I'm an expert
13:51:50 * Riastradh actually gets shapr's Swedish there!
13:51:56 <emu> pesco: well, it can only get better
13:51:57 <shapr> yay!
13:52:15 <Riastradh> Which proves my Swedish vocabulary includes...one word.
13:52:23 <shapr> Marvin--: the following questions revealed that it was actually a teddy björn
13:52:35 <Riastradh> Heh.
13:52:43 <Marvin--> shapr: *beeep* capital error
13:52:49 <shapr> ?
13:52:51 <Marvin--> shapr: "teddybjörn", we write words together
13:52:53 <shapr> aha
13:52:54 <shapr> neat
13:52:55 <Vincenz> if bjorn = bear then Vincenz.knowsswedish
13:53:14 <shapr> I tend to come up with those kinds of questions and answer whenever possible
13:53:37 <Marvin--> shapr: c.f. skrivihop.nu
13:54:12 <Marvin--> you get a lot of amusing errors when writing the words apart
13:54:19 * Riastradh hrms.
13:54:30 <Marvin--> "sjuksköterska" = nurse, "sjuk sköterska" = sick nurse
13:54:37 <emu> if (bjorn = (**(blah **)&bear)) then { { ((foo *)Vincenz).knowsswedish(barf) } }
13:54:50 * shapr snickers
13:54:50 <Vincenz> emu you sick c++ bastard
13:54:50 <Marvin--> emu: hahahaha
13:54:51 * emu knows one word in swedish
13:55:59 <Marvin--> skrivihop.nu has more members than many of the Swedish parliament parties :)
13:56:09 * shapr grins
13:56:16 <Marvin--> http://skrivihop.nu/propaganda/polstats.gif
13:56:31 <shapr> wow
13:57:05 <Marvin--> SSU, MUF, CUF, KDU, LUF, ung vänster and grön ungdom are the youth divisions of the respective parties
13:57:24 <shapr> young left and green youth
13:57:28 <shapr> hm
13:58:13 <Marvin--> "Rök fritt" is my favourite
13:58:20 * Riastradh really isn't getting how to get the current calendar time.
13:58:29 <tic> "vi byter vatten och spolar vatten och olja på din bil".. *grin*
13:58:37 <Marvin--> "rökfritt" = no smoking, "rök fritt" = feel free to smoke
13:58:52 <shapr> :-)
13:58:57 <pesco> cool
13:59:09 <shapr> ohhh
13:59:28 <shapr> "smoke free" as in, smoke free environment... versus "smoke freely"
13:59:31 <shapr> neat
13:59:34 <tic> yeah
14:00:07 <Riastradh> So 'teddy bjorn' would be a 'bearly teddy' or something?
14:00:12 <Vincenz> smoke free weed
14:00:31 <Marvin--> Riastradh: "teddy björn" doesn't exist
14:00:42 <Marvin--> 'cause teddy isn't a verb
14:00:48 <Riastradh> Oh, ok.
14:00:59 * emu levies a syntax of 34% on #haskell
14:01:06 <emu> pay up
14:01:10 <shapr> emu: ha!
14:01:28 * shapr does an RST on emu's SYN tax
14:01:31 <Riastradh> What syntax is there on Scheme?
14:01:38 <emu> very little
14:01:59 <shapr> Riastradh: what's wrong with "do calTime <- liftM toCalendarTime getClockTime" ?
14:02:14 <Riastradh> Does that indicate that Scheme has a syntax as bad as OCaml...or that Haskell's syntax is worse than OCaml's?
14:02:34 * Vincenz slaps Riastradh around the head with a recursive list
14:02:38 <emu> (riastradh: you should have asked "What syntax is there for Scheme?")
14:02:48 <Marvin--> Vincenz: recursive trout!
14:02:58 <Vincenz> feel the tail!! MUHAHA
14:03:00 <emu> syntax is levied on heavily synning languages
14:03:04 <SyntaxPolice> emu: who said you could do that?
14:03:27 <shapr> IRS - Iterative Recursion Syntax (service) ?
14:03:29 <Vincenz> Marvin-- :)
14:03:32 <Riastradh> shapr - Somewhere in there is the type 'IO,' apparently, when it wants 'IRC.'
14:03:37 <shapr> ohh
14:03:40 <emu> hey
14:03:45 <emu> SyntaxPolice: go collect some tax already
14:03:54 <Vincenz> Scheme has a syntax like Lisp, Lots internal silly parenthesis
14:03:58 <Marvin--> http://skrivihop.nu/exempel/bilder/magmuckler.jpg *lol*
14:04:02 * SyntaxPolice polices the collecting of tax...
14:04:06 <emu> Lisp has a 2 level syn tax
14:04:22 <Riastradh> Lots internal silly parenthesis?
14:04:28 <shapr> infernal
14:04:28 <hdaume> Marvin--: care to translate?
14:04:29 <Riastradh> This make lot sense!
14:04:38 <emu> yes it does~!
14:04:43 <emu> parenthesis are silly!!!
14:04:44 <emu> didn't you know?
14:04:47 <emu> silly!
14:04:54 <Riastradh> Parenthes_i_s?
14:04:54 <Vincenz> Yay!
14:04:59 <hdaume> i think i can read it, but i'm not sure :)
14:05:00 <emu> you need to have +!@$%#%^&$%*&%^&Y$ in your language
14:05:09 <Vincenz> Free the expression, unleash them from their parenthesis!!!
14:05:14 <hdaume> magmuskler is "large"?
14:05:15 <Vincenz> s/expression/expressions/g
14:05:15 <shapr> I just wiggle the network cable to get that
14:05:17 <Marvin--> hdaume: contact ad, and she's looking for a man with "breasts and stomach muscles"
14:05:25 <Vincenz> s/parenthesis/parentheses/g
14:05:26 <Riastradh> Parenthes_i_s is singular.
14:05:31 <emu> whatever
14:05:35 <Vincenz> yea I know
14:05:38 <Vincenz> it's supposed to be
14:05:40 <Vincenz> parentheses
14:05:41 <Vincenz> I messed up
14:05:49 <Vincenz> I'm tired, slept little and I'm studying 
14:05:53 <emu> Because the more like Perl you look, the less silly.
14:05:55 <Riastradh> Lots of infernal grammatical errors!
14:05:57 <shapr> Marvin--: and it's supposed to say breastmuscles and stomach muscles, right?
14:06:17 <Marvin--> yes
14:06:20 <emu> the more you have to use the shift key, the more RSI you develop, hence the closer you are to a "real programmer"
14:06:29 <shapr> I use the shift key with my left thumb
14:06:48 <Marvin--> "bröst- och magmuskler" is correct
14:06:52 <shapr> ah
14:07:20 <pesco> shapr: I think my family is going to give me a kinesis for easter, isn't than nice?
14:07:26 <shapr> wow! awesome!
14:07:43 <shapr> pesco: what did you do? how did you bribe them into that? :-)
14:07:56 <pesco> I almost feel bad for getting such expensive hardware thrown at me.
14:08:09 <emu> kinesis? sounds mystical
14:08:43 <pesco> Oh right, does the keyboard sound pleasant, shapr?
14:09:38 <shapr> it has a built-in keyclick that's okay
14:09:53 <shapr> it's piezoelectric speaker that does the clicking
14:09:57 <Marvin--> arrarrgh, the flame war. never. ends.
14:10:09 <Marvin--> sometimes I wonder why I'm part of debian
14:10:21 <esap> which flame war?
14:10:23 <shapr> the key response isn't as good an IBM clicky, I wish it were
14:10:30 <pesco> shapr: huh? artifical key clicks I don't like.
14:10:35 <shapr> pesco: you can turn them off
14:10:38 * esap is obviously missing something fun :-)
14:10:49 <shapr> I leave the key clicks on, but turn the toggle sound off
14:11:08 <shapr> I hope my new kinesis arrives tomorrow
14:11:10 <pesco> shapr: Oh, and I suppose the keycaps are all the same size so one can rearrange them to dvorak?
14:11:10 <Marvin--> esap: sekhrut one
14:11:17 <shapr> nope
14:11:20 <Vincenz> don't those kinesis cost a shitload?
14:11:22 <pesco> shapr: WAH?
14:11:22 <shapr> that would be too easy
14:11:38 <shapr> you can buy the keycaps that have dual qwerty/dvorak though
14:11:54 <pesco> But I want dvorak _only_!
14:11:55 <shapr> the hardware switchable models come with the dual caps
14:12:10 * shapr looks on the website
14:14:00 <shapr> looks like there's only the hardware switchable models
14:14:02 <pesco> This is bad.
14:14:16 <Vincenz> dvorak..dvorak
14:14:17 <shapr> I'm using a qwerty layout, because I never look at the keyboard anyway :-)
14:14:25 <Vincenz> I've never even seen a dvorak
14:14:30 <Vincenz> heh, I use a qwerty too
14:14:37 <Vincenz> but in belgium they all use azerty :((
14:14:43 <Vincenz> had to ask a qwerty at work
14:14:50 <Marvin--> azerty is seriously twisted
14:14:53 <shapr> the keys on my kinesis say qwerty, but they're remapped to a modified dvorak
14:15:00 <Vincenz> (shift-number, shift-number ARGGH!!)
14:15:03 <Marvin--> even us in sweden use qwerty :)
14:15:20 * Riastradh doesn't see the real point of Dvorak...an increase of, what, 20%?  Amazing.  And you also have to spend a while reteaching your fingers to type.
14:15:43 <Marvin--> now I'm seriously off to bed
14:15:52 <shapr> Riastradh: I've been typing dvorak for eleven years!
14:15:57 <shapr> g'nite Marvin-- 
14:16:01 <Vincenz> Riastradh: lol
14:16:18 <shapr> lesse, 20% * 11 years...
14:16:18 * esap thinks he has never even seen a dvorak kb.
14:16:19 <pesco> I don't care about what the keys say on keyboards but if I buy a KB for $300 I want it to look right.
14:16:35 <shapr> get the dual layout
14:16:39 <shapr> it has both on the keycaps
14:16:40 <Vincenz> I'ev never seen a dvorak kb
14:16:58 <Vincenz> is it true about the 20%?
14:17:00 <Vincenz> I think it's just a myth
14:17:03 <Vincenz> like python vs ruby..
14:17:06 <Riastradh> I don't know, it's somewhere around there.
14:17:07 <Vincenz> personal preference
14:17:22 <shapr> I think dvorak is more efficient for typing english
14:17:33 * pesco checks price...
14:17:57 <Riastradh> One person someone I know knows spent two months trying to learn Dvorak...he ended up two months later not being able to type with either Qwerty OR Dvorak.
14:18:06 <shapr> pesco: http://www.kinesis-ergo.com/images/dual-leg.gif
14:18:07 <Riastradh> Anyhow, I must go for a few minutes now.
14:18:13 <Vincenz> Riastradh: poor guy
14:18:19 <shapr> Riastradh: it took me 1.5weeks 
14:18:25 <shapr> two months??
14:19:08 <shapr> I hope that guy never tries to learn another spoken language, he'll never be able to speak again ;-)
14:19:16 <pesco> shapr: Ugh, dual keycaps only in white?!
14:19:21 <shapr> :-(
14:19:31 <hdaume> shapr: haha
14:19:40 <shapr> the black keyboard and caps are much much sexier looking
14:19:43 * Vincenz wants it blackcolored just like the dells
14:19:59 <shapr> Vincenz: http://www.kinesis-ergo.com/images/pro_blk-sml.jpg
14:20:03 <pesco> shapr: But there are no dual keycaps in black, or am I missing them?
14:20:18 <shapr> pesco: I think you're right, I don't think dual black caps exist
14:20:24 <shapr> pesco: call 'em up and ask 'em
14:20:25 <Vincenz> sexy
14:20:31 <Vincenz> but the big empty part in the middle is a bit yucky
14:20:33 <pesco> shapr: Good idea.
14:20:38 <esap> Those cursor key locations remind me of C64.
14:20:45 <shapr> Vincenz: no, the big empty part is *good*
14:21:01 <Vincenz> shapr: esthetically speaking not
14:21:07 <shapr> Vincenz: like when you sit down in a chair and put your hands in front of you, do they stick together in your lap?
14:21:12 <shapr> or do you put them on your knees?
14:21:16 <Vincenz> shapr: depensd on what I'm doing :P
14:21:21 * shapr laughs
14:21:49 <shapr> well, the point I'm trying to make is that kinesis keeps your hands at shoulder-width while typing, normal keyboards do not
14:22:03 <Vincenz> ah
14:22:33 <Vincenz> I want a kinesis!
14:22:35 <shapr> :-)
14:23:53 * Vincenz is stuck on an exercise
14:23:59 <shapr> push ups?
14:24:03 <Vincenz> no, Ocaml
14:24:05 <shapr> oh
14:24:06 <shapr> :-)
14:24:28 <Vincenz> I want something in between List.map and List.select...
14:25:14 <hdaume> what is select?  i get "Unbound value List.select"
14:25:34 <Vincenz> Ocaml
14:26:58 <shapr> #haskell is so much fun, people show up here to learn other languages 
14:28:05 <Vincenz> hehe
14:39:06 <pesco> Ok, bedtime. Good night everyone!
14:43:09 <hdaume> Vincenz: yeah, i know...but ocaml doesn't have it (or at least mine doesn't ^_^)
14:43:19 <Vincenz> sorry
14:43:21 <Vincenz> List.find_all
14:46:13 * Riastradh returns.
14:47:01 <Riastradh> shapr, are you still here?
15:08:39 <shapr> Riastradh: eh?
15:08:54 <shapr> hi kosmikus 
15:09:01 <kosmikus> hi shapr
15:09:10 <shapr> hoe gaat? ;-)
15:09:17 <kosmikus> goed
15:09:23 <shapr> that's about all I can say
15:09:35 <kosmikus> well, I'm not Dutch myself
15:09:37 <shapr> are you learning Haskell?
15:09:48 <shapr> parlez vous français?
15:09:53 <kosmikus> no - I am a PhD student working with Haskell
15:09:57 <kosmikus> sorry, no
15:09:58 <shapr> wow, cool!
15:10:05 <kosmikus> and you?
15:10:30 <shapr> I'm an uneducated professional programmer who loves Haskell
15:10:43 <kosmikus> that is great as well
15:10:56 <kosmikus> how did you find out about Haskell in the first place?
15:11:06 * shapr tries to remember
15:11:14 <Riastradh> shapr - 'calTime <- liftM toCalendarTime getClockTime' doesn't work, because it expects an IRC foo instead of IO foo.
15:11:29 <kosmikus> :)
15:11:47 <shapr> Riastradh: have you tried "calTime <- liftIO (liftM toCalendarTime getClockTime)" ?
15:12:13 <shapr> you may not need the liftM when using liftIO
15:12:29 <shapr> kosmikus: I think I heard about Haskell first many years ago on the #python irc channel
15:13:03 <kosmikus> I'm just learning Python ...
15:13:08 <shapr> once I became fluent in Python, I wanted to learn something else
15:13:34 <shapr> around about the same time, Christian Tismer and Guido van Rossum disagreed about Stackless Python
15:13:44 <shapr> and I realized I wanted to use a language that could give me first class continuations
15:13:51 <shapr> so I started learning Haskell
15:14:02 <shapr> how did you first find out about Haskell?
15:14:44 <shapr> kosmikus: if you're not french or dutch, where are you from?
15:14:46 <kosmikus> I had a course about SML and Prolog at the university
15:14:49 <shapr> if you don't mind me asking :-)
15:15:09 <kosmikus> given by an enthusiastic PhD student at the time ...
15:15:32 <kosmikus> I suddenly realized that this is what I should have been doing all the time.
15:15:37 <shapr> cool!
15:16:02 <kosmikus> So I abandoned mathematics and moved to the Netherlands ;-)
15:16:07 <kosmikus> I'm from Germany.
15:16:50 <kosmikus> Are you working at a company?
15:17:01 <shapr> are you working with Leijen et al? or maybe CWI?
15:17:06 <shapr> yes, sort of
15:17:11 <shapr> I own my own company
15:17:11 <Riastradh> Hrm...I need to get the actual calendar time from the IO calendar time.
15:17:21 <kosmikus> Daan Leijen is in my group. Do you know him?
15:17:22 <shapr> and I'm one-third owner of another company
15:17:51 <shapr> I've exchanged a few emails with him, I sent him some small nifty bits of Parsec stuff recently
15:18:32 <shapr> so I work for myself actually
15:18:41 <shapr> most of my paying work is Python and Java right now
15:18:45 <kosmikus> That's great.
15:19:06 <shapr> but I want to move to doing commercial Haskell work
15:19:34 <kosmikus> Yeah, that would certainly be nice, but I suspect that many people don't want their programs written in Haskell ...
15:20:07 <shapr> in the case where my client will be maintaining the sources I write, that is good business sense
15:20:21 <shapr> in the case where I will be maintaining and extending the sources I write for them, it does not.
15:20:33 <shapr> er "it is not"
15:21:09 <kosmikus> You mean: in the case where you just sell the final product, not the source?
15:21:37 <kosmikus> Otherwise, as a client, I would always want to keep the option to move to another programmer (no offense intended), and there aren't many Haskell programmers around.
15:21:41 <shapr> more like the case where software is a service to my clients
15:21:52 <kosmikus> Riastradh: What exactly do you mean?
15:23:22 <shapr> I hope to make a living from software as a service
15:23:46 <shapr> I'm convinced that I can produce higher-quality software in a shorter amount of time with Haskell
15:23:54 <shapr> so I'm trying to "put my money where my mouth is"
15:24:12 <kosmikus> what kind of software do you write?
15:24:20 <shapr> what do you want? ;-)
15:24:35 <shapr> actually, I've mostly done the standard boring web application stuff
15:24:39 <opet> a cup of tea
15:24:39 <shapr> dynamic websites
15:24:45 <Riastradh> kosmikus - I'm writing a module for lambdabot, a 'seen' module, and it stores a finite map of nicks to (channel, message, last time seen).  I'm having some difficulty with the 'last time seen' -- toCalendarTime takes a clock time and returns an IO CalendarTime, and either I need to get a CalendarTime there, or a CalendarTime later when I'm printing out the last time seen.
15:24:55 <shapr> I haven't written hpctp.hs yet ;-)
15:25:01 <Riastradh> Heheh.
15:25:16 <shapr> I think I got some of those letters wrong
15:25:27 <Riastradh> HTCPCP, I think you mean.
15:25:34 <Riastradh> RFC 2323, if I remember correctly.
15:25:35 <shapr> yes! that's it!
15:25:42 <shapr> 2324
15:25:43 <shapr> :-P
15:25:47 <Riastradh> Humph.
15:25:50 * shapr grins
15:26:29 <kosmikus> Riastradh: you can't get a CalendarTime from an IO CalendarTime, but you don't need to ...
15:26:41 <shapr> kosmikus: I've also done some PKI work, some code for Nokia phones, random database stuff, etc etc
15:26:44 <Riastradh> Eric Marsden wrote one in elisp...I'm so glad now I can do HTCPCP while at the same time watching a psychoanalysis of Zippy!
15:27:08 <shapr> if only emacs were multithreaded
15:27:12 <Riastradh> kosmikus - Well, yes, I'm assuming there's a better solution, and I'd be happy if someone could find that better solution for me.
15:27:14 <kosmikus> Riastradh: How much experience do you have with IO programming in Haskell?
15:27:19 <shapr> then it could take advantage of many CPUs
15:27:21 <Riastradh> Some, not much.
15:28:14 <opet> shapr: it could import linux kernel threading code :p
15:28:15 <Riastradh> do { realTime <- someIOCalendarTime; stuff }   -- Are you thinking about doing something like that, where I use 'realTime' in stuff?
15:28:26 <kosmikus> I don't know about lambdabots interface, but usually IO actions are all within the IO monad. Within, you can get access to the actual values by making use of do-notaion. 
15:28:35 <kosmikus> Yes!
15:28:50 <Riastradh> But that where I put that 'do' I need to return an IRC ().
15:29:00 <Riastradh> s/But that/But /1
15:29:33 <kosmikus> Certainly you can embed IO into IRC somehow?
15:29:50 <Riastradh> shapr - Um...can I?
15:29:58 <shapr> IRC is an IO somewhat
15:30:02 <kosmikus> Is there a function with type "IO a -> IRC a"?
15:30:13 <kosmikus> How's IRC defined?
15:30:24 <shapr> with StateT
15:30:29 <kosmikus> Is the code available somewhere?
15:30:32 <shapr> sure
15:30:39 * shapr gets url
15:31:50 <shapr> lambdabot: @fact source
15:31:50 <lambdabot>  http://sf.net/projects/haskell-libs/, http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/lambdabot/
15:31:53 <shapr> that's the easy solution
15:32:34 * kosmikus is browsing the source ;-)
15:32:34 <shapr> Riastradh: do you have the code you're working on available online?
15:32:34 <shapr> could I look at it?
15:32:36 <shapr> kosmikus: so, the best solution to the problem you mentioned is for more haskell programmers to appear somehow
15:32:40 <Darius> liftIO should be IO a -> m a (in this case IRC)
15:33:05 <shapr> and I think the best way to do that is to write fun and/or useful apps in Haskell so people see how usefulness and fun of Haskell
15:33:48 <shapr> lambdabot: @karma+ Darius
15:33:49 <lambdabot> Darius's karma has been incremented.
15:33:59 <kosmikus> shapr: certainly. Your should definitely try.
15:34:22 <kosmikus> Darius: sounds good ...
15:35:22 * Riastradh must pfheed on pfhood now; he'll be back in a few minutes.
15:35:27 <Smerdyakov> @karma- Smerdyakov
15:35:30 <Smerdyakov> lambdabot: @karma- Smerdyakov
15:35:31 <lambdabot> You can't change your own karma, silly.
15:35:31 <kosmikus> Riastradh: try do { caltime <- liftIO $ getCalendarWhateverTime; stuff } where stuff uses caltime
15:35:32 <shapr> kosmikus: so what are you working on for your PhD?
15:35:39 <shapr> lambdabot: @karma+ Smerdyakov
15:35:40 <lambdabot> Smerdyakov's karma has been incremented.
15:35:54 * Smerdyakov grumbles.
15:35:58 * shapr grins
15:36:05 <kosmikus> shapr: on Generic Haskell
15:36:14 <kosmikus> www.generic-haskell.org
15:36:15 <Darius> Your all's yammering has made me think about learning Dvorak again, so here I am typing slow as heck
15:36:18 <shapr> are you looking at karma from the original Hindu viewpoint that any karma is bad?
15:36:24 <shapr> Darius: w00!
15:37:11 <shapr> kosmikus: nice picture
15:37:34 <kosmikus> shapr: which one?
15:37:45 <shapr> the small one in the top left of your homepage?
15:37:54 <kosmikus> I should remove it ;-)
15:38:17 <Darius> I don't like where the ?-marks are. Though "the" is nice
15:38:31 <Igloo> Oh, I think I've spoken to you, kosmikus
15:39:00 <shapr> lambdabot: @fact kosmikus Andres Löh
15:39:01 <lambdabot> set kosmikus to Andres Löh
15:39:16 <opet> argh.. my project supervisor is listed on generic-haskell.org
15:39:33 <shapr> opet: who?
15:39:34 <opet> I was trying to pretend the project didn't exist for a while
15:39:40 * shapr grins
15:39:50 <opet> graham hutton
15:40:04 <Igloo> I didn't realise Richard Bird was involved in it
15:40:21 <kosmikus> opet: just met Graham in Nottingham
15:40:32 <opet> kosmikus: cool :)
15:41:06 <kosmikus> opet: who are you ;-) ?
15:41:06 <opet> kosmikus: he's my third year project supervisor
15:41:12 <shapr> the Haskell world is very interconnected
15:41:25 <opet> kosmikus: just a random cs.nott.ac.uk student :)
15:41:35 <kosmikus> Igloo: Richard does not directly work on it, but is considered "interested" in the project.
15:41:57 <opet> argh.. roland backhouse is on there too
15:42:09 <opet> he's confused me in more lectures than I can count
15:42:10 <kosmikus> And he certainly is "interesting" for the project as well, because of, for example, the "Algebra of Programming" book.
15:42:17 <shapr> Darius: there are several dvorak training programs on the web
15:42:17 <Igloo> *nod*
15:43:21 <shapr> kosmikus: will you be at ICFP/HW in Uppsala?
15:43:37 <Darius> yeah I'm doing one nov
15:43:38 <kosmikus> I plan to be there, but it depends on some papers being accepted ;-)
15:44:02 <kosmikus> If my university pays, I will certainly go.
15:44:35 <Vincenz> shapr: my ocaml code looks a lot like lisp
15:44:38 <shapr> I'm showing up for the after hours coding binges
15:44:42 <andersca> :)
15:44:48 <andersca> will you be hacking C#?
15:44:56 <shapr> sure, if I have a really big knife
15:45:05 <shapr> every copy I can find ;-)
15:45:11 <Smerdyakov> shapr, what are you really saying, in terms of your attendance there?
15:45:25 <andersca> he's like neelix
15:45:27 <andersca> morale officer
15:45:30 * shapr laughs
15:45:32 <Vincenz> what's going on?
15:45:38 <shapr> and useless otherwise ;-)
15:45:57 <shapr> Smerdyakov: just saying that I'm not doing any research
15:46:02 <Darius> Vincenz: that can't be good
15:46:09 <shapr> that's all
15:46:49 <shapr> I'm still sort of shocked that there wasn't any programming at the 'Fun of Programming'
15:47:16 <Vincenz> lol
15:47:18 <shapr> Smerdyakov: are you going to be at ICFP/HW?
15:47:19 <Igloo> I did some programming there
15:47:22 <Smerdyakov> shapr, and you're not going to any of the main conference events?
15:47:23 <shapr> Igloo: yay!
15:47:37 <Smerdyakov> shapr, I don't know. I repeat kosmikus' answer.
15:47:53 <Igloo> And at lunch and in the evenings I copied it from my brain to PC
15:47:59 <shapr> how much is the conference fee?
15:48:11 <Igloo> (oh for a laptop)
15:48:24 <shapr> Igloo: you could buy a sharp zaurus and run hugs on it
15:48:55 <Igloo> I think the keyboard would annoy me (but I've never actually seen one)
15:51:22 <kosmikus> Igloo: didn't realize that you are "professionally" working with TH
15:51:42 <Igloo> 'fraid so
15:51:45 <shapr> Smerdyakov: assuming the entrance fee won't bankrupt me, I'll be there.
15:51:58 * Igloo is probably doing generics ATM, bizarrely enough  :-)
15:52:29 <Igloo> Not very interesting/deep generics if it is, though
15:53:23 <kosmikus> why not? Generics are cool ;-)
15:53:35 <Igloo> :-)
15:54:43 <shapr> hey Pseudonym!
15:55:19 <Smerdyakov> shapr, looks like the fee would be around $400 US for you.
15:55:54 <Pseudonym> G'day.
15:56:35 <Riastradh> Hi.
16:05:26 <kosmikus> Have to leave ... Good bye!
16:05:33 <shapr> cya
16:05:51 <shapr> I have to sleep
16:05:56 <dark> sleep?!?
16:06:03 <shapr> I have class soon
16:06:22 <dark> Swedish class?
16:06:25 <shapr> yup
16:06:31 <shapr> an my keyoar is roken also
16:07:39 <Riastradh> Heh.
16:30:57 <tmoertel> hello, all!
16:31:16 <Riastradh> Hi.
16:34:40 <Darius> well I haven't slept in well over a day. So I'm going to sleep.
17:09:34 <Vincenz> night
17:56:40 <Riastradh> How should I case-insensitively compare strings?
17:58:17 <tmoertel> ciCompare s t = (map toLower s) == (map toLower t)
17:58:35 <Riastradh> Ah, ok.
18:00:29 <Riastradh> Is it predefined, or did you just hand out a sample definition?
18:01:20 <tmoertel> I just made it up.
18:01:26 <tmoertel> toLower is in Char
18:01:37 <Riastradh> OK, then.
18:40:28 * Riastradh pokes a lambdabot person.
18:41:40 <Riastradh> Whoops, never mind.
18:42:45 <Smerdyakov> lambdabot: @eval 1
18:42:45 <lambdabot> 1
18:42:52 <Smerdyakov> See?
19:44:44 <Pseudonym> lambdabot: @eval 1+1
19:44:44 <lambdabot> 2
19:44:52 <Pseudonym> lambdabot: @eval (\x -> x+x) 2
19:44:53 <lambdabot> (line 1, column 5):
19:44:53 <lambdabot> unexpected "-"
19:44:53 <lambdabot> expecting identifier or "."
19:44:56 <Pseudonym> Hmmm.
19:45:56 * kawfee bounces
