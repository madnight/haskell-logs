00:13:44 <emu> LAMBDA Replacement or Repair -- Reconditioned LAMBDA inventory -- 12 Month Warranty
00:13:47 <emu> http://www.google.com/search?q=lambda
00:14:42 <emu> Have you had your LAMBDA checked recently?
01:44:25 <Marvin--> nice, *something* is working
02:21:00 <Marvin--> aiiih, this is evil
02:24:57 <Marvin--> yay, progress
03:00:11 <shapr> whee
03:06:04 <shapr> Darius_: I like the stripMS verbose error code. I've been wanting something like that.
05:24:51 --- mode: ChanServ set +v mgoetze_
05:53:07 --- mode: ChanServ set +v Janni
05:53:22 * Janni greets exhaustedly
05:53:51 <Janni> (I don't really know why I'm feeling like this, I'm just totally tired)
05:55:02 <mgoetze> hi Janni 
07:51:53 <SyntaxPolice> shapr: you might email the 'darps' author to see if he wants to use haskell-libs: http://www.abridgegame.org/darcs/
07:52:47 <SyntaxPolice> s/darps/darcs
08:04:53 <SyntaxPolice> I guess thats a dumb idea since he probably wants to use darcs to keep the code :-)
08:13:39 * mgoetze thinks haskell-libs should be called CHAN
08:18:36 <SyntaxPolice> should I write something for the HaskellNewbies wiki page?
08:29:35 <Marvin--> aiiiighhh, this is way too complicated
08:29:51 <Marvin--> I look at my code and don't understand what it does, and I just wrote it
08:30:52 <SyntaxPolice> shit. I can't save my changes to the HaskellNewbies pages :(
08:30:54 * esap suggests refactoring.
08:31:24 <Marvin--> esap: oh, really ;)
08:31:49 <SyntaxPolice> shapr: wake up :)
08:34:08 <norpan> Marvin--: you are to intelligent to understand yourself
08:34:11 <norpan> too
08:35:10 <Marvin--> is that good or bad?
08:35:29 <SyntaxPolice> Marvin--: you're asking us? how could we possibly understand?
08:36:08 * Marvin-- is nervous about tomorrow
08:38:22 <SyntaxPolice> whats tomorrow?
08:40:33 <Smerdyakov> THURSDAY!!
08:40:34 <Marvin--> interview
08:40:53 <Marvin--> for a PhD position
08:41:42 <Smerdyakov> Interviews. Ha. These quaint European customs.
08:42:05 <norpan> hehe
08:42:07 <norpan> me too
08:42:47 <norpan> don't be nervous
08:43:05 <norpan> they are nice
08:43:06 <Smerdyakov> Yeah, because people who are nervous never get the positions.
08:45:03 <norpan> i wonder how i will do
08:45:06 <Marvin--> norpan: yeah, I saw your name in the list
08:46:02 <Smerdyakov> What is the purpose of these interviews?
08:46:13 <norpan> to filter out the best candidates
08:46:21 <Smerdyakov> Based on what?
08:46:28 <norpan> based on the interviews of course :)
08:46:48 <Smerdyakov> How are the interviews conducted so that they can be used to identify the best candidates?
08:47:12 <norpan> i don't know, i am at the wrong end to answer that :)
08:47:45 <Smerdyakov> OK. PhD program admissions in the US generally happen with no face-to-face contact, so I'm curious as to how things work for you.
08:49:14 <Marvin--> I guess they roast us for two hours
08:49:29 <norpan> i guess so
08:49:47 <Smerdyakov> What I'm looking for is what qualities they are trying to identify.
08:50:01 <norpan> probably if you are a nice guy
08:50:16 <Smerdyakov> In CS? Dream on!
08:50:34 <Smerdyakov> Egotistic bastards get bonus points.
08:51:39 <Marvin--> I think they're interested in finding out *how* interested we are for example
08:52:30 <Smerdyakov> Ha. The application process must have been too easy so far if they need to do that. =D
08:53:01 <Marvin--> yes, it's pretty relaxed
08:55:29 <norpan> i don't know
08:55:39 <norpan> at least they've narrowed it down from 150 to 15
08:57:16 <norpan> Marvin--: how come you are applying?
08:58:45 <Marvin--> 'cause I'm bored with the courses and want to learn more interesting and exciting things
08:59:03 <Marvin--> you?
08:59:05 <norpan> bored with the courses?
08:59:19 <Marvin--> yeah, most of them are too easy
08:59:21 <norpan> because i've been working three years now and want to do more research
09:00:01 <norpan> there is never time to really research the problems, you just have to implement quick and dirty and hope no-one notices
09:00:45 <Smerdyakov> I'm going to grad school because it's the easiest option I have now that lets me do halfway interesting things while I sort out what I want to do in life. =)
09:00:50 <norpan> Marvin--: so you take courses although you have a degree?
09:01:02 <norpan> even though
09:01:53 <Marvin--> no, I don't have a degree yet, working on my exjobb right now
09:01:57 <norpan> oh
09:02:52 <Smerdyakov> I think all undergraduate courses are too easy everywhere. :D
09:03:10 <norpan> if they are too easy, you just take more of them and get done quicker
09:03:41 <Marvin--> well, most of them involve plenty of *work* but mainly boring legwork that still takes time
09:03:44 <Smerdyakov> Hm.
09:03:54 <Smerdyakov> Or don't go to school and learn more more quickly and be happier!
09:04:20 <Marvin--> our institution has too much breadth and not enough depth
09:04:39 <Smerdyakov> Mine has too much DUMBNESS and not even reasonable students. =)
09:04:49 <psy> mine has both those problems :)
09:05:14 <Smerdyakov> psy is the lucky winner.
09:05:21 <norpan> but i don't look forward to get a reduction in income though :)
09:05:34 <norpan> but i'll manage
09:05:34 <psy> the prize - a partner for your next assignment!
09:05:39 <Smerdyakov> You should, norpan, because it will help you avoid wasteful consumption.
09:05:57 <norpan> well, it's almost all taxes anyway
09:05:58 <Marvin--> norpan: the good thing about going to postgrad directly instead of via the industry ;)
09:06:15 <norpan> but i think the industry experience will be very helpful
09:06:30 <Marvin--> all experience is helpful IMO
09:06:39 <Marvin--> if you're analytical about it
09:06:40 <Smerdyakov> Not experience coding ASP for 5 years!
09:07:02 <norpan> no, i've been coding haskell!
09:07:15 <Marvin--> oh, yeah, you work at safelogic, right?
09:07:19 <norpan> yes
09:07:19 <Smerdyakov> GOod. But Marvin-- said all experience :D
09:07:36 <Marvin--> Smerdyakov: certainly it's good, helps you appreciate haskell more :-)
09:08:11 <Smerdyakov> The best reason to work in industry is to see why capitalism is self destructive and should be avoided at all costs.
09:09:19 <norpan> no, the best reason to work in industry is to create things that actually are useful :)
09:09:24 <norpan> and to make heaps of money
09:09:44 <norpan> well, time to go home
09:09:50 <Smerdyakov> Making heaps of money as a goal in itself is troubling, if you have it.
09:11:33 <norpan> making heaps of money in order to use them to make your life better
09:11:46 <norpan> bye bye
09:17:37 <esap> many things that industry does are not actually useful [except for extracting money out of customers]
09:18:27 <Darius_> that's useful?
09:20:48 <esap> hard to define, actually.
09:21:20 <Smerdyakov> It's nice being in a channel this size where almost everyone hates working in industry. =D
09:21:51 * esap does work in the industry, and I'm not (very) unhappy.
09:22:05 <Smerdyakov> esap, then you are a Bad Person!
09:22:25 <SyntaxPolice> sorry Smerdyakov, I don't hate it either.  I would prefer to work on free software projects, including Haskell, full time, though.
09:22:39 <Smerdyakov> Oh no! You are all Bad People!!
09:26:39 <Smerdyakov> So you two don't see yourselves at a huge disadvantage compared to people living in a cooperative society with no currency, everyone working a little to produce what's needed, and fair distribution to all?
09:27:30 <esap> There is no such thing as fair distribution to all. Everyone has a different definition of fair.
09:28:22 <vardamir> Smerdyakov, I see a problem; 90% of the people I know of probably wouldn't work their "fair share" unless they were under penalty of punishment or unless there was an incentive that would allow them to be placed "above" other people in some respect
09:28:23 <Smerdyakov> But close-knit communities tend to have very similar definitions.
09:28:37 <vardamir> of course i'm not talking about programmers, specifically
09:29:04 <Smerdyakov> vardamir, that's because of their upbringing, which is an easy to solve problem with cooperation from enough people.
09:29:51 <SyntaxPolice> Smerdyakov: I would like to live in such a society.
09:30:20 <vardamir> i suppose that may be true.  I admit, it hurts me to see how easily people are swayed by materialistic things like cars.
09:30:43 * esap doesn't own a car.
09:31:08 <vardamir> esap, probably for the best
09:31:54 <esap> yea, it would be too hard to drive to work too. [I live about 800meters from the place I work]
09:32:13 <Smerdyakov> Public transportation is a beautiful thing.
09:34:32 <Smerdyakov> Ugh. The whole practice of grouping people into their "careers" is so completely awful.
09:35:13 <vardamir> Yeah especially since there are not many girls in Computer Science or Math, but that is a different story i guess.
09:35:56 <esap> smerdyakov: The same problem applies to all gross generalizations.
09:36:11 <Smerdyakov> You should come here. They admit plenty of girls into CS (40%ish), but most of them have never coded in their lives and transfer to some other major. =D
09:36:35 <Smerdyakov> esap, so quit your job and be free!!
09:37:25 <esap> smerdyakov: I did that once already. In the end, it didn't work .-)
09:39:03 <SyntaxPolice> Smerdyakov: be free of what? of gross generalizations?
09:39:34 <Smerdyakov> SyntaxPolice, be free of involvement with grossly generalizing yourself in that specific way, at least.
09:40:03 <vardamir> you'd still be stereotyped somehow
09:40:18 <SyntaxPolice> ? thats a strange way of looking at it. I'd rather try to convince people not to generalize than to avoid a particular behavior to avoid being generalized.
09:40:25 <Smerdyakov> But your lifestyle wouldn't be organized in a way that acknowledged that stereotype.
09:40:34 <SyntaxPolice> its the generalizers' problem, not mine or esap's
09:41:04 <Smerdyakov> SyntaxPolice, the actual physical fact that you spend so much of your waking time doing one particular thing is a problem, not just the ways people might see it....
09:41:31 * esap loves doing just one thing, if it's the thing I chose to do.
09:41:55 <vardamir> hehe
09:41:55 <Smerdyakov> Yes, but that's not a socially responsible lifestyle.
09:42:08 <Smerdyakov> I think "the people" have a right to prevent you from leading it, if you won't prevent yourself.
09:42:13 <SyntaxPolice> Smerdyakov: I think you chagned the subject, right?  I thought we were talking about how generalizing people is evil?
09:42:27 <Smerdyakov> ... and I think you would actually be happier with a less specialized life.
09:42:29 <SyntaxPolice> sorry, 'aweful'
09:42:45 <Darius_> depends on what he chooses to do
09:42:46 <Smerdyakov> SyntaxPolice, not particularly. esap just interjected that.
09:44:01 <shapr> SyntaxPolice: I'm awake!
09:44:55 <vardamir> i believe if that were the case we wouldn't have had many of our greatest innovations though; what if we kept some of the greatest scientists from devoting their time to their interests?
09:45:09 <SyntaxPolice> hi shapr :)
09:45:44 <shapr> hello SyntaxPolice 
09:45:45 <SyntaxPolice> so I was trying to add a page to the wiki, and it said someone else was editing it.  Then I noticed on the problems page that this is aproblem, so there is still brokenness w/ the wiki?
09:45:53 <shapr> I dunno
09:45:54 * shapr looks
09:45:57 <SyntaxPolice> actually, I was trying to put something in the "Newbies" page.
09:46:01 <SyntaxPolice> HaskellNewbies
09:46:20 <vardamir> where is this newbiews page?
09:46:26 <vardamir> newbies even
09:46:48 <shapr> on the HaskelWiki
09:47:03 <SyntaxPolice> linked from the wiki front page: http://haskell.org/wiki/wiki
09:47:40 <shapr> SyntaxPolice: oh, yes...
09:47:43 <shapr> that's the problem
09:48:51 <SyntaxPolice> so I know there was some talk about replacing the wiki because of missing features and bugs & stuff... as anyone thought about this? how big is the wiki?
09:49:00 <shapr> not very big
09:49:10 <shapr> RecentChanges goes back to 99 or so
09:49:26 <shapr> 99/08/04 in fact
09:49:44 <shapr> yes, I offered to convert the pages to MoinMoin
09:49:58 <Darius_> it needs diffs
09:50:05 <shapr> among other things :-)
09:50:10 * buggler evaluates 5012^5012 in HUGS and watches it unravel before his eyes
09:50:20 <SyntaxPolice> shapr: did anyone take you up on the offer?
09:50:21 <shapr> y0 shreya
09:50:38 <shapr> SyntaxPolice: no, the response was "we've updated PyWiki, the problem might go away now"
09:50:42 <buggler> hey hey shap, I'm just admiring HUGS' power calculation abilities :)
09:50:50 <shapr> and in fact, it did go away for a long time
09:50:52 <shapr> until now...
09:51:07 <shapr> PyWiki II - UNDEAD REVENGE
09:51:13 * shapr rolls the credits
09:51:41 <SyntaxPolice> I see.
09:51:49 <SyntaxPolice> the moment _I_ try to edit it ;)
09:51:53 * shapr grins
09:52:07 <shapr> @searchml wiki
09:52:16 <shapr> oy
09:52:22 * shapr waits the requisite three minutes
09:52:44 <shapr> I should complain to the author about the slowness of lambdabot's mailing list search code...
09:53:09 <vardamir> has anyone taken a look at www.evlan.org ?
09:56:03 <lambdabot> 1704 1684 1423 1404 1335 1330 1329 1318 1134 607 588 569 540 152 126
09:56:06 <shapr> yay
09:56:13 <shapr> @showml 1704
09:56:14 <lambdabot> >| On a side note: why not toss up a TH page on the Haskell wiki,
09:56:14 <lambdabot> >especially if
09:56:14 <lambdabot> >| the answer to my second question is no?
09:56:14 <lambdabot> >
09:56:14 <lambdabot> >by all means go ahead.
09:56:23 <shapr> @showml 1684
09:56:23 <lambdabot> Datatypes can take contexts.  Currently TH dies if you try to reifyDecl a 
09:56:23 <lambdabot> datatype with a context e.g.
09:56:23 <lambdabot> import Language.Haskell.THSyntax (runQ)
09:56:26 <lambdabot> data (Eq a) => Tree a = Leaf a | Branch (Tree a) (Tree a)
09:56:33 <shapr> @searchml wikiwiki
09:56:39 <shapr> @searchml haskellwiki
10:01:01 <n3d> hello all ! 
10:01:28 <n3d> i use hugs, and when i try to use the '\n' char to go to the next line,
10:01:50 <n3d> it doesn't work, it just write "sdfg\nsdfg"
10:02:27 <SyntaxPolice> n3d: thats what happens when it displays a string, but when you _print_ (output) a string, it will put the newlines in
10:02:44 <n3d> ok thanks !
10:02:45 <SyntaxPolice> try putStr "asdf\nasdf"
10:02:53 <n3d> that's it !
10:03:04 <shapr> hi n3d
10:03:07 <n3d> hi
10:16:22 <norpan> hi again
10:16:33 <shapr> hi norpan 
10:16:35 <shapr> wassup?
10:16:39 <shapr> coi .i do mo
10:18:43 <norpan> doi capr. i mi pinxe le vanju
10:19:13 <shapr> xamgu
10:19:24 <norpan> go'i
10:19:33 <shapr> mi cilre samtrosku
10:19:52 <shapr> bau la xaskel
10:20:25 <norpan> you are a learning type-of computer type-of sayer?
10:20:31 <shapr> er
10:20:47 <shapr> I'm learning a program in the language haskell
10:21:10 <shapr> mi ciska zo'e bau la xaskel
10:21:13 <shapr> how's that?
10:22:16 <norpan> you are writing something which is obvious or unspecified in the language haskell
10:22:28 <norpan> you don't need to put zo'e there though
10:22:31 <shapr> I know
10:22:44 <shapr> I'm writing something in Haskell.
10:23:05 <shapr> so call me a malglico :-P
10:23:29 <norpan> zo'e doesn't mean something, you should use da or similar
10:23:48 <shapr> yah, good point
10:23:57 <shapr> so, you wanna write a lojban parser plugin for lambdabot ? ;-)
10:24:04 <norpan> not really :)
10:24:07 * shapr grins
10:25:57 <norpan> lojban grammar is not obvious
10:26:02 <norpan> especially the lexing part
10:26:25 <norpan> even though there is a yacc description
10:31:25 <shapr> I'd like to write a Haskell parser for lojban
10:39:04 <Darius_> lambdabot: @define S \f g x.f x (g x)
10:39:04 <lambdabot> S defined
10:39:27 <Darius_> @define Y \f.f(Y f)
10:39:28 <lambdabot> Y defined
10:39:38 <Darius_> @define K \x y.x
10:39:39 <lambdabot> K defined
10:39:45 <Darius_> @define I \x.x
10:39:45 <lambdabot> I defined
10:39:51 <norpan> shapr: the easiest is probably to use happy
10:40:14 <Darius_> or pappy
10:40:53 <norpan> @define X \x.x K S K
10:40:54 <lambdabot> X defined
10:40:58 <norpan> there you go
10:41:16 <norpan> genesis combinator defined
10:41:38 <Darius_> @eval XXX 4 5
10:41:38 <lambdabot> unbound variable: XXX
10:41:46 <Darius_> @eval X X X 4 5
10:41:46 <lambdabot> 4
10:41:56 <Darius_> @eval K 4 5
10:41:57 <lambdabot> 4
10:43:20 <Darius_> @eval (X (X X) (X (X X) (X X X) (X X X)) (X (X X) (X X X) (X X X))) X (X X) (X (X X) (X X X) (X X X)) (X (X X) (X X X) (X X X))
10:43:21 <lambdabot> <<EM Dynamic -> EM Dynamic>>
10:43:26 <norpan> hehe
10:43:54 <Darius_> @eval (X (X X) (X (X X) (X X X) (X X X)) (X (X X) (X X X) (X X X))) (X (X X) (X (X X) (X X X) (X X X)) (X (X X) (X X X) (X X X)))
10:43:55 <lambdabot> out of fuel
10:44:14 <Darius_> @eval S I I (S I I)
10:44:15 <lambdabot> out of fuel
10:44:46 <Darius_> @eval S (S K K) (S K K) (S (S K K) (S K K))
10:44:46 <lambdabot> out of fuel
10:46:41 <norpan> he seems to have a small fuel tank
10:47:10 <norpan> @eval X (X X) I
10:47:10 <lambdabot> <<EM Dynamic -> EM Dynamic>>
10:47:32 <norpan> @eval X (X X) I I I
10:47:32 <lambdabot> <<EM Dynamic -> EM Dynamic>>
10:47:35 <norpan> @eval X (X X) I I I I
10:47:36 <lambdabot> <<EM Dynamic -> EM Dynamic>>
10:47:40 <norpan> indeed
11:10:37 --- mode: ChanServ set +v Janni
11:10:37 <Janni> re
11:13:03 <shapr> y0
11:23:39 * Igloo bug hunts
11:27:06 <Igloo> I really need better debugging tools
11:27:11 <shapr> like what?
11:27:44 <Igloo> hat or hsdebug probably, but that can debug TH stuff
11:27:48 <shapr> oh
11:28:12 * Darius_ would like hat to compile
11:28:27 <Igloo> Me too
11:28:39 <shapr> I have a hat binary deb
11:28:39 <Igloo> I think next time I will go through making a list of what breaks and send it to a list
11:28:43 <shapr> I should try it...
11:28:50 <shapr> yes, the hat mailing list
11:39:49 <norpan> TH=template haskell?
11:39:55 <shapr> yup
11:39:56 <shapr> @fact th
11:39:57 <lambdabot> Nothing
11:40:05 <shapr> @fact TH Template Haskell
11:40:06 <lambdabot> set th to Template Haskell
11:40:13 <norpan> url?
11:40:25 <SyntaxPolice> does lambdabot save its knowledge?
11:40:29 <Smerdyakov> @eval Nil
11:40:30 <lambdabot> unbound variable: Nil
11:40:34 <Smerdyakov> Apparently not
11:40:36 <Smerdyakov> @eval nil
11:40:37 <lambdabot> unbound variable: nil
11:40:38 <shapr> @eval Ni
11:40:39 <lambdabot> unbound variable: Ni
11:40:42 <shapr> @fact Ni
11:40:42 <lambdabot> Nothing
11:40:47 <Smerdyakov> My list definitions keep getting EATEN.
11:40:53 <shapr> Smerdyakov: happily, that's been fixed!
11:41:01 <shapr> Darius_ just fixed that
11:41:04 <shapr> @dump
11:41:04 <lambdabot> dumped
11:41:14 <shapr> @listcommands @eval
11:41:14 <lambdabot> No module "@eval" loaded
11:41:18 <shapr> @listcommands eval
11:41:18 <lambdabot> Module eval provides the following commands: ["eval","define","get-definition","definitions","dump","set-fuel"]
11:41:20 * shapr dohs
11:41:34 <shapr> @define a 1
11:41:34 <lambdabot> a defined
11:41:37 <shapr> @dump
11:41:37 <lambdabot> dumped
11:42:23 <shapr> Smerdyakov: from the dump file: [("I"," \\x.x"),("K"," \\x y.x"),("S"," \\f g x.f x (g x)"),("X"," \\x.x K S K"),("Y"," \\f.f(Y f)"),("a"," 1")]
11:42:46 <shapr> Darius_: does EvalModule autoload from the dump file upon lambdabot startup?
11:42:51 * shapr looks at the source
11:43:16 <norpan> i need food now
11:43:25 <shapr> yes, it does
11:43:41 <shapr> Smerdyakov: your definitions can be permanent now.
11:44:18 <shapr> I know I'm about to steal the @dump code for the SearchML module
11:44:55 <Smerdyakov> Permanent unless someone accidentally overwrites one, eh?
11:45:19 <shapr> even if someone overwrites one, the file isn't saved until someone with admin privs executes @dump
11:59:13 <shapr> hi cptchaos 
11:59:39 <shapr> @y0
11:59:39 <lambdabot> Sorry, I don't know the command "y0", try "lambdabot: @listcommands"
12:13:29 <shapr> @type addListToFM_C
12:13:32 <shapr> :-/
12:13:37 <shapr> where's pesco?
12:17:36 <cptchaos> hi shapr
12:17:47 <cptchaos> i expected pesco here
12:17:51 <shapr> me too
12:25:29 * andersca bounces
12:25:51 * shapr boings
12:25:58 * shapr ports CL code to Haskell
12:40:15 * shapr cackles happily
12:46:02 <Marvin--> gahhh, they've moved the formal methods course
12:46:08 <shapr> in space? or time?
12:46:52 <andersca> right, I need to apply for the courses
12:47:38 <Marvin--> in time *grmbl* if I don't get a PhD position, that was one of the courses I was going to take during fall, but now they've moved it to spring
12:48:07 * andersca is gonna take AFP, HCI, algorithms and computational models
12:48:39 * shapr writes lispy looking Haskell
12:49:53 <Marvin--> HCI?
12:50:00 <andersca> human computer interaction
12:50:16 <Marvin--> ah
12:50:53 <andersca> it was either that course or mathematical logic
12:51:03 <Marvin--> I might go to some lectures on that, 'cause it's never bad to know something about it, but I don't think I'll take the exam and stuff
12:54:19 <Igloo> HCI doesn't sound like it will have the most exciting exam questions
12:55:05 <Marvin--> indeed, and there are lots of coursework, interviews and stuff
12:56:47 <andersca> I think it's pretty interesting
12:56:52 <andersca> but that's just because I hack on gnome2 and stuff :)
12:58:07 <Marvin--> sure, it's a must for user application development
12:58:35 <andersca> and it's just not for computer user interfaces
12:58:50 <andersca> stuff like microwave-ovens and videos come to mind for example
12:59:07 <Marvin--> oh yes, those are typical examples from the course
12:59:10 <Marvin--> at least the microwave oven
13:00:01 <Marvin--> I don't get it, it's so obvious that two knobs is an unbeatable interface for a microwave oven
13:00:11 <Marvin--> (well, except for mind reading)
13:01:32 <andersca> yeah, I have one exactly like that
13:02:42 <Marvin--> my parents too
13:02:49 <Marvin--> old and solid :)
13:03:01 <andersca> my parents have one exactly like mine
13:03:12 * andersca bought it as a christmas present
13:03:28 <Igloo> Mine has a big button. I just press it n times when I want n/2 minutes of microwaving
13:04:38 <andersca> so
13:04:51 <andersca> paul graham has a pretty interesting piece about what programming languages will be used in 100 years
13:05:06 <Marvin--> oh?
13:05:30 <andersca> http://www.paulgraham.com/hundred.html
13:05:50 <kaninchen> booiiing: pls join #team.sucht
13:05:55 <andersca> I can already tell you what's going to happen to all those extra cycles that faster hardware is going to give us in the next hundred years. They're nearly all going to be wasted.
13:06:44 <Marvin--> heh
13:12:44 <ludde> XML!
13:13:01 <ludde> hardware will communicate with the CPU using XML in 20 years
13:13:14 <ludde> and the memory chips will be XML enabled
13:13:18 <Marvin--> probably
13:13:25 <ludde> DMA transfers will be initiated using XML
13:13:33 <ludde> and we'll have an XML parser in every device
13:24:01 <Marvin--> "The right way to solve that problem, I think, is to separate the meaning of a program from the implementation details. Instead of having both lists and strings, have just lists" *cough* haskell
13:24:23 <andersca> yeah 
13:27:22 <Marvin--> "The more of your application you can push down into a language for writing that type of application, the more of your software will be reusable."
13:27:30 <Marvin--> that's pretty much what Koen advocates in AFP
13:27:36 <andersca> afp is gonna rock
13:27:39 <Marvin--> embedded languages, embedded languages, embedded languages
13:27:45 * andersca is gonna write funkylus
13:35:41 <norpan> tomorrow, after the interviews, i'm going to FRANCE
13:36:06 <andersca> norpan: cool
13:36:13 <norpan> yes
13:36:13 <andersca> norpan: I'm going to ronneby
13:36:24 <norpan> not equally cool, but almost
13:44:32 <andersca> norpan: I'm gonna bring the prisoner dvds, and then lose them
13:45:33 <norpan> then you owe me SEK 750
13:45:47 <andersca> :'(
13:46:35 <norpan> but you can pay by being my slave for the next year
13:46:58 <andersca> when are we gonna trick dennis into fixing that lunch
13:47:03 <andersca> with john and koen
13:48:07 <norpan> that can be your first assignment as my slave
13:49:49 <andersca> I already have an assignment that I need doing
13:54:18 <norpan> you poor thing
14:48:54 * shapr sings happily
14:48:58 <shapr> @bounce
14:48:58 <lambdabot> Sorry, I don't know the command "bounce", try "lambdabot: @listcommands"
14:49:00 <shapr> bah
14:57:04 <shapr> gutenabend kosmikus 
14:57:25 <kosmikus> hi shapr
14:57:28 <shapr> wassup?
14:57:36 <shapr> g'day clausen 
14:57:38 <kosmikus> not much
14:57:52 <clausen> gday shapr
14:58:03 <shapr> I hope I'm porting Paul Graham's CL code correctly...
14:58:21 <shapr> I'd hate to get it backwards and only let spam into my inbox ;-)
14:58:47 <andersca> hey shapr
15:00:36 <shapr> y0 andersca 
15:14:14 <andersca> hmm
15:14:45 <andersca> is there an equivalent to the logical 'implies' in haskell?
15:16:16 <kosmikus> implies x y = not x || y
15:16:29 <andersca> I just realized that
15:16:30 <andersca> :)
15:51:07 <shapr> mgoetze: any progress on the lambdabot per-user mode code?
15:51:15 <mgoetze> nope :)
15:52:41 <Darius_> I just dislocated a bone in my foot... I didn't know you could do that
15:53:06 <shapr> Darius_: that's gotta suck
15:53:41 <Darius_> it's fine now it was only a little out
15:56:36 <ddarius> the types in LambdaTerm are scary and can't be inferred
16:00:03 <shapr> ?
16:01:01 <Igloo> By LambdaTerm do you just mean terms in lambda calculus?
16:03:27 <ddarius> no, in my working copy of LambdaTerm.hs (part of EvalModule)
16:24:24 --- mode: ChanServ set +v Igloo
16:24:50 --- mode: sterling.freenode.net set +vv shapr Riastradh
16:48:06 <Igloo> Ha hah!
16:48:11 <Igloo> Bug found! (probably)
16:48:38 <Igloo> (how do you do a triumphant ha hah as opposed to laughter on IRC?)
16:48:46 * Igloo thinks about how to fix it
16:49:11 <clausen> a Ha
16:49:33 <Igloo> It definitely starts with an h
16:49:54 <clausen> I was thinking of "new idea" a ha
16:49:57 --- mode: ChanServ set +v Pseudonym
16:49:59 <clausen> gday Pseudonym
16:50:06 <Pseudonym> G'day.
16:50:07 <Igloo> Hey Pseud
16:50:15 <Pseudonym> How's the anti-copyright conspiracy?
16:50:25 <clausen> Pseudonym: I went with the trust metrics option...
16:50:32 <Pseudonym> Cool.
16:50:35 <clausen> (and p2p seems to be a good application of trust metrics... ;)
16:50:37 * Igloo gets an equal and opposite sinking feeling
16:50:46 <Igloo> after 2 mins thought on how to fix it
16:50:58 <mgoetze> hello, judges and nonjudges
16:51:42 <shapr> hiya Pseudonym 
16:51:53 <Pseudonym> G'day again.
16:52:01 * Pseudonym should make a macro for that
16:59:57 <shapr> finally
17:00:03 <shapr> the CL code from Paul Graham compiles
17:00:07 <shapr> still looks like CL though
17:01:50 <Pseudonym> That's what vi's % key is for.
17:02:49 <shapr> ?
17:03:03 <shapr> I just hope it works...
17:03:12 <Pseudonym> Which CL are you using?
17:03:37 <shapr> the chunk of code about one quarter way through http://www.paulgraham.com/spam.html
17:03:43 <shapr> I've just ported it to Haskell
17:03:46 <shapr> I tink
17:03:48 <Pseudonym> Oh, I see.
17:03:48 <shapr> think
17:04:06 <shapr> I'm trying to build the third FM
17:04:13 <shapr> from the good and spam FMs
17:04:14 <Pseudonym> data SExpr = SCons SExpr SExpr | SAtom Atom
17:04:21 <Pseudonym> Actually.
17:04:36 <Pseudonym> data SExpr = SCons { car :: SExpr ; cdr :: SExpr } | SAtom Atom
17:04:57 <shapr> oh, did you see Paul Graham's latest writings?
17:05:01 <Pseudonym> No.
17:05:03 <shapr> from today or yesterday I think
17:05:06 <shapr> he says
17:05:09 <shapr> @fact java
17:05:09 <lambdabot> Java is the COBOL of the future --Shae Erisson
17:05:13 * Pseudonym goes and takes a look
17:05:17 * Pseudonym LOL
17:05:20 <shapr> as well, "strings should be lists of characters"
17:05:21 <Pseudonym> That's true, I think.
17:05:29 <Pseudonym> That's NOT true.
17:05:32 <shapr> heh
17:05:37 <Pseudonym> And I think it's a fault of Haskell that they are.
17:05:37 <shapr> I thought you'd say that :-)
17:06:04 <Pseudonym> The problem would be ameliorated a bit if they were arrays of character flyweights.
17:06:22 <shapr> I got several more spams while reading the article, and decided to keep workin on Fram
17:06:40 <shapr> I think they're on to me
17:07:35 <Pseudonym> Apparently Paul Graham expects to be still coding in a hundred years' time.
17:08:01 <Pseudonym> The string thing might be because I get paid to hack text.
17:08:08 <Pseudonym> Lots and lots of text.
17:08:30 <Pseudonym> If we had to use two machine words per glyph, we'd be sunk.
17:08:55 <Pseudonym> Well, per codepoint, anyway.
17:09:02 <shapr> I like the idea of strings as lists of characters
17:09:07 <shapr> is there some way to make it flyweight?
17:09:11 <Pseudonym> I also like the idea, where it works.
17:09:16 <Pseudonym> Possibly.
17:09:18 <shapr> how?
17:09:26 <Pseudonym> A global table of Char objects.
17:09:35 <Pseudonym> When you need to construct a Char, you grab it from the table.
17:09:51 <shapr> so you only have a list of pointers?
17:09:55 * Pseudonym nods
17:10:01 <shapr> Chars are only 'instantiated' once?
17:10:08 <Pseudonym> Basically, yup.
17:10:14 <shapr> sounds great
17:10:23 <Pseudonym> It's almost perfect if strings are arrays.
17:10:27 <shapr> a heap of codepoints
17:10:36 <Pseudonym> Well you make them as needed.
17:10:40 <shapr> just never allocate codepoints you don't need
17:10:45 * Pseudonym nods
17:11:02 <shapr> you should send that to SPJ :-)
17:11:05 <Pseudonym> If strings are arrays, on a 32-bit machine you need basically one pointer per char-in-a-string.
17:11:19 <Pseudonym> Compare this to a UTF-32 code point.
17:11:35 <Pseudonym> The problem is that strings are linked lists.
17:11:59 <Pseudonym> Which effectively doubles the space, and kills cache locality.
17:12:12 <Pseudonym> Assuming a non-compacting GC, of course.
17:12:38 <Pseudonym> Even so, it doubles the amount of stuff you need to investigate to handle a string.
17:12:54 <Pseudonym> I think (not sure) that it's even worse in the STG machine.
17:13:14 <Pseudonym> A cons record in STG land is three cells long.
17:13:19 <shapr> :-/
17:13:42 <Pseudonym> This is why I think strings should be atomic abstractions.
17:13:47 <Pseudonym> Like arrays.
17:14:31 <Pseudonym> Naturally you should be able to turn strings into lazy streams of chars.
17:14:54 <Pseudonym> Lists are very convenient for many kinds of string processing.
17:18:00 <shapr> well, hopefully both of faster computers and more efficient Haskell implementations will increase the popularity of Haskell
17:18:09 <Pseudonym> Yes, this is true.
17:19:43 <shapr> lately I seem to be spending all my time using FiniteMap
17:20:22 <Pseudonym> Bloody useful, innit.
17:20:23 <shapr> Pseudonym: where do you think lambdabot should go next?
17:20:29 * Pseudonym laughs
17:20:34 <Pseudonym> Let's see...
17:20:38 <shapr> :-)
17:20:43 <Pseudonym> Have you had a look at the haskell ports library?
17:20:53 <shapr> No, I haven't
17:21:07 <shapr> I read the description, but I don't understand what to do with it.
17:21:07 * Pseudonym hasn't seen chilli around lately, but he wrote it
17:21:16 <Pseudonym> OK, here's the general idea.
17:21:30 <Pseudonym> Suppose you have a global data structure, like a big hash table.
17:21:39 <Pseudonym> Which lots of pieces of code all need to access.
17:21:45 <Pseudonym> Say, the symbol table in a compiler.
17:21:50 <shapr> ok
17:22:15 <Pseudonym> How would you implement it?
17:22:23 <Pseudonym> You might hide it in a monad.
17:22:27 <shapr> yah
17:22:28 <Pseudonym> Or use an IORef.
17:22:31 <shapr> right
17:22:44 <Pseudonym> Now suppose different threads have to access it concurrently.
17:22:51 <Pseudonym> As in lambdabot.
17:23:27 <Pseudonym> At the moment, lambdabot uses channels to throw IRC messages up and down the wire.
17:23:31 <shapr> yah
17:23:39 <shapr> which I still don't completely understand, but hey, it works.
17:23:40 <Pseudonym> That's fine so long as communication is only one-way.
17:23:48 <Pseudonym> Well, a channel is like a pipe.
17:24:05 <Pseudonym> There's a writer thread, for example, which takes IRC messages and writes them to the socket.
17:24:14 <Pseudonym> Anyone can put a message into the channel.
17:24:22 <Pseudonym> For example, a module can.
17:24:32 <shapr> well, why is it necessary?
17:24:54 <Pseudonym> Well, you could in principle write straight to the socket.
17:25:17 <Pseudonym> Except that if multiple threads are writing to the same socket concurrently, you could end up with two messages interspersed.
17:25:23 <shapr> a channel is just a queue, yes?
17:25:27 <Pseudonym> Yup.
17:25:43 <Pseudonym> The IRC protocol states that PING messages should be responded to as soon as possible, for example.
17:25:44 <shapr> and in this case, a thread-safe queue
17:25:48 <Pseudonym> So there's a fast path to do that.
17:25:52 <shapr> hm
17:25:55 <shapr> neat
17:26:04 <Pseudonym> In fact, the reader thread does it.
17:26:13 <shapr> I didn't know that
17:26:18 <shapr> oh hey
17:26:23 <Pseudonym> Using the channel, the reader thread and a module can write to the same socket in a thread-safe way.
17:26:36 <shapr> that's what that code does
17:26:38 <shapr> aha
17:26:41 <Pseudonym> Yup.
17:26:45 <Pseudonym> Now, here's the tricky part.
17:27:00 <Pseudonym> :-)
17:27:19 <Pseudonym> This setup is fine when you have an effectively stateless protocol like IRC.
17:27:31 <Pseudonym> But suppose you had to do request-response types of things.
17:27:34 <shapr> ahh
17:27:35 <Pseudonym> Say, the global hash table.
17:27:45 <shapr> or a mail connection
17:27:54 <Pseudonym> You could put in a "lookup this key" message, but where should the reply go?
17:28:03 <shapr> give a callback?
17:28:07 <Pseudonym> Possibly.
17:28:08 <shapr> async replies?
17:28:15 <Pseudonym> You could give an MVar or a channel in the message.
17:28:22 <Pseudonym> Telling the server where to send the reply.
17:28:44 <Pseudonym> As I understand it, haskell ports are a lightweight way to do this.
17:29:27 <Pseudonym> Now I might be wrong there.
17:29:35 <Pseudonym> But that's how I understand it.
17:30:08 <Pseudonym> Actually, MVars might be a good solution.
17:31:11 <Pseudonym> Hmmm.
17:31:24 <shapr> ?
17:31:33 <Pseudonym> Do you know what an MVar is?
17:31:45 <shapr> nope
17:31:58 <shapr> I vaguely recally they're some sort of semaphore
17:32:02 <Pseudonym> Well it's like an IORef, except it's synchronising.
17:32:08 <Pseudonym> Kind of.
17:32:34 <Pseudonym> MVars can either have a value in them or no value in them.
17:32:48 <Pseudonym> There are operations to, for example, take the value out.
17:33:03 <Pseudonym> Where you wait on the MVar until it's got the value in.
17:33:15 <shapr> this sounds like some of the IPC stuff I've read about
17:33:18 <shapr> mailboxes
17:33:21 * Pseudonym nods
17:33:28 <Pseudonym> Well you could do the global hash table thing with this mechanism.
17:33:34 <Pseudonym> For example:
17:33:52 <Pseudonym> data HashTableMsg k v = HashSet k v | HashLookup k (MVar v)
17:34:23 <Pseudonym> To read a value from the hash table, you send a HashLookup message, with an MVar where the hash table server thread should put the value.
17:34:32 <Pseudonym> Then you wait on the MVar.
17:34:38 <Pseudonym> When it's filled in, you have your answer.
17:34:45 <shapr> interesting
17:35:12 <shapr> how does it work on the other end?
17:35:14 <shapr> for example
17:35:27 <shapr> could we use that to do lambdabot module calls in their own thread?
17:35:34 <Pseudonym> Very possibly, yes.
17:35:48 <shapr> does the writer thread select() on an MVar?
17:35:58 <Pseudonym> Kind of.
17:36:17 <Pseudonym> What you do is you send requests via a channel and replies via an MVar.
17:36:52 <Pseudonym> In the case of modules, I don't think you need MVar replies.
17:37:28 <Pseudonym> Because I think most replies will be in the form of writes to the socket.
17:38:59 <shapr> but
17:39:13 <shapr> I'd like to have an output collector
17:39:25 <shapr> for writing a h4x0r plugin for example
17:40:21 * Pseudonym nods
17:40:42 <Pseudonym> Why not have a look at haskell ports and see what you think.
17:41:05 <shapr> I will, thanks
17:45:24 * Igloo collapses in exhaustion
17:45:43 <Igloo> Note to self: When traversing false branch of conditional you should not assume the guard to be true
17:47:26 <Pseudonym> I dunno.
17:47:32 <Pseudonym> Logical paradoxes can be useful sometimes.
18:21:10 <f2f> hi
18:21:35 <Pseudonym> G'day.
18:21:54 <f2f> Q: how would I instantiate, say, (+) over a data type that I have created myself and another class (e.g.:
18:22:04 <f2f> data Pt = Pt Float
18:22:10 <f2f> instance Num Pt where...
18:22:23 <f2f> and i want to add a double, or an int to a Pt?
18:24:22 <f2f> rephrasing:
18:24:30 <f2f> i want to achieve something like:
18:24:31 <f2f> Prelude> 5+1.0
18:24:31 <f2f> 6.0
18:24:31 <f2f> it :: Double
18:24:39 <f2f> with a data type that i have created
18:24:51 <Riastradh> You probably have to add a Num instance, if you can.
18:24:55 * Pseudonym nods
18:25:03 <Pseudonym> Hang on.
18:25:13 * Pseudonym did this last week
18:25:16 <Riastradh> Oh, right, you already figured that out.
18:25:19 <f2f> pointers to relevant documentation is just fine :)
18:25:28 <f2f> s/is/are/
18:25:35 <Riastradh> instance Num Pt where ...   -- that ought to work...
18:25:46 <Pseudonym> OK, what you need to do is create a Num instance and a Fractionjal instance.
18:25:53 <Igloo> That only works because the type of 5 is inferred as Double
18:26:09 * Igloo isn't sure I understand the question
18:26:11 <Pseudonym> The key methods are fromInteger (from Num) and fromRational (from Fractional).
18:26:30 <f2f> pseudonym, do you have a simple example?
18:26:46 <f2f> or, better yet, i'll try to write one myself
18:26:56 <Pseudonym> Definitely try to write one yourself.
18:27:17 <Pseudonym> When you implement fromInteger and fromRational, the overload (+) happens automagically.
18:28:08 <Pseudonym> Actually, there's a simple example in Data.Complex
18:28:42 <Pseudonym> Complex numbers are of the form (x :+ y) where x is the real part and y is the imaginary part.
18:28:48 <f2f> right
18:28:58 <Pseudonym> You can do this: (1 :+ 3) + 4
18:29:15 <Pseudonym> The reason you can do this is because Haskell actually interprets this as:
18:29:23 <Pseudonym> You can do this: (1 :+ 3) + (fromInteger 4)
18:29:30 <Pseudonym> Where fromInteger is a member of the Num typeclass.
18:29:48 <f2f> i got it :)
18:29:50 <Pseudonym> instance  (RealFloat a) => Num (Complex a)  where
18:29:51 <Pseudonym>     fromInteger n       =  fromInteger n :+ 0
18:29:53 <Pseudonym> Got it?
18:29:56 <Pseudonym> Cool.
18:29:57 <f2f> i'll be back in a few if i have any problems :)
18:30:01 <Pseudonym> For floats, you use fromRational.
18:30:11 <Pseudonym> Which is a member of Fractional.
18:30:22 <f2f> i was wondering what the from functions were
18:30:33 <Pseudonym> Well now you know. :-)
18:57:37 <Pseudonym> shapr: Checked something into hslibs.
18:57:49 <f2f> done
18:57:56 <Pseudonym> It's rudimentary but it works.
18:58:03 <f2f> data Pt = Pt Float Float Float deriving (Show,Eq,Ord)
18:58:23 <f2f> instance Num Pt where
18:58:30 <f2f>    fromInteger = pfromInteger
18:58:35 <f2f> pfromInteger x = (Pt (fromInteger x) (fromInteger x) (fromInteger x))
18:58:45 <f2f> seems to be fine and does what i want it to
18:58:55 <f2f> stuf flike 2 + Pt works
18:58:58 <Pseudonym> Yup.
18:59:08 <f2f> not very elegant, but i'm just getting into haskell :)
18:59:16 <Pseudonym> Can I ask what you're doing?
18:59:18 <f2f> *Main> let y = Pt (-1) (-1) 0
18:59:24 <f2f> *Main> print y
18:59:24 <f2f> Pt (-1.0) (-1.0) 0.0
18:59:46 <f2f> somebody did work on a language for subdivision surfaces 
18:59:52 <Pseudonym> Oh?
18:59:59 <f2f> their code is in C++ and is very nasty involving flex+bison
19:00:12 <Pseudonym> You going to implement winged-edge models in Haskell? :-)
19:00:20 <f2f> i have the basics implemented in 300 lines of haskel, substituting 3000 lines of C++
19:00:25 <Pseudonym> Cool.
19:00:40 <Pseudonym> Very, very cool in fact.
19:00:44 <f2f> i did some HOpenGL so that's not the hard part
19:00:59 <Pseudonym> Which subdivision basis are you using?
19:01:06 <Pseudonym> Loop?  Catmull-Clark?
19:01:09 <Pseudonym> NURSS?
19:01:37 <f2f> pseudonym, well, the language is a relational model that can easily be done to reimplement all the subdivision algorithms
19:01:52 <Pseudonym> OK.
19:02:01 <f2f> as an assignment i reimplemented 4-8 subdivision in about 20 lines of c++-like code
19:02:09 <f2f> but i think haskell is a nicer way to do it
19:02:15 <Pseudonym> Definitely.
19:02:16 <Pseudonym> That's cool.
19:02:18 <f2f> pseudonym, no matrices involved
19:02:28 <f2f> that's the key with vertex-vertex systems
19:02:35 * Pseudonym nods
19:02:42 <Pseudonym> Got a meeting.  BBIAB
19:02:44 <f2f> the guy will probably publish at siggraph
19:02:51 <f2f> ok, thanx for your help
19:35:05 <Pseudonym> No prob,
19:35:19 <Pseudonym> This is an interesting idea.  I'm curious if you can express NURSS in this scheme.
19:35:20 <Pseudonym> Probably can.
19:35:31 <Pseudonym> But you need to attach weights to vertices.
20:20:50 <vardamir> I'm trying to use the newest CGI module (I think it is the newest, by Jan Laitenberger), but I get the following error:
20:21:02 <vardamir> CGI.lhs:10: Type constructor or class not in scope: `RawHTML'
20:21:08 <vardamir> not really sure what to do about that
20:21:35 <vardamir> this is with the newest GHC
20:21:36 <f2f> NURBS?
20:21:52 <f2f> you can express bezier curves with L-systems
20:22:07 <f2f> which somebody implemented in Lithp already
20:54:37 <Pseudonym> You know how Catmull-Clark surfaces are subdivision generalisations of B splines?
20:54:44 <Pseudonym> Well, NURSS are generalisations of NURBS.
20:55:04 <f2f> yes
20:55:08 <f2f> 4-8 subdivision too..
20:55:09 <f2f> hmm
20:55:29 <Pseudonym> See, the problem with traditional subdivision surfaces is that they are uniform.
20:56:02 <Pseudonym> NURSS give you arbitrary knot spacings, like NURBS do.
20:58:19 <f2f> not familiar with NURSS :)
21:27:02 <f2f> thank you and bye :)
22:01:03 <vardamir> does anyone here use Haskell for their CGI needs (if you use CGI at all)?
22:01:30 * mgoetze perls.
22:01:41 * Pseudonym usually perls too
22:02:35 <Pseudonym> OK, here's a strange question.
22:02:54 <Pseudonym> I have an abstract data type, which is basically a channel which forwards requests to a server thread.
22:03:16 <Pseudonym> The problem is: When the ADT becomes garbage, I want the thread cleaned up too.
22:03:57 <Pseudonym> I guess it's not so strange.
22:04:07 <Pseudonym> I'm not sure what to do about this.
22:11:05 <vardamir> http://www.astray.com/Functional/  --well, if you do use perl for CGI, at least there is this
22:15:23 <SlushP> Hello again guys. I won't be bothering you anymore after today, and hopefully (for you guys) anymore after I ask this question:
22:15:45 <SlushP> how do I produce HTML (like a test file) from this: Date -> HtmlTable
22:16:00 <SlushP> My code is simply:
22:16:01 <SlushP>  testMonthPic :: IO ()
22:16:01 <SlushP>  testMonthPic = writeFile "testMonthPic.html" (renderHtml monthPic)
22:16:21 <SlushP> But it tells me "Instance of HTML (Date -> HtmlTable) required for definition of testMonthPic"
22:16:32 <SlushP> And I'm not sure what it's expecting me to do
22:17:32 <Pseudonym> What's the type of renderHtml?
22:17:42 <Pseudonym> Uhm...
22:17:48 <Pseudonym> Actually, what's the type of monthPic?
22:20:05 <SlushP> monthPic :: Date -> HtmlTable
22:20:12 <Pseudonym> There you go then.
22:20:18 <SlushP> Hey?
22:20:23 <Pseudonym> It's a function.  You need to give it an argument.
22:20:56 <SlushP> shouldn't this work? ->     testMonthPic = writeFile "testMonthPic.html" (renderHtml monthPic)
22:21:02 <Pseudonym> Nope.
22:21:15 <Pseudonym> monthPic is a function.  It needs an argument.
22:21:42 <Pseudonym> You can't just call renderHtml on it because renderHtml is expecting an HtmlTable.
22:22:52 <SlushP> testMonthPic = writeFile "testMonthPic.html" (renderHtml monthPic )
22:23:03 <SlushP> so, i'd put (renderHtml monthPic s) ?
22:23:07 <Pseudonym> No.
22:23:13 <Pseudonym> (renderHtml (monthPic s))
22:23:16 <Pseudonym> Assuming that s :: Date
22:23:16 <SlushP> Ahh
22:23:22 <SlushP> Yeah
22:23:23 <SlushP> Thanks:)
22:23:53 <SlushP> Hmm...that didn't work.
22:25:19 <SlushP> Any other suggestions?
22:25:39 <Pseudonym> What do you mean "it didn't work"?
22:25:44 <Pseudonym> Can you be more specific?
22:26:51 <SlushP> Undefined variable s
22:27:08 <SlushP> or even (d,m,y) which is the format of Date
22:27:19 <Pseudonym> Well you actually need to give monthPic a date.
22:27:23 <Pseudonym> I thought you realised that.
22:27:42 <SlushP> No. 
22:27:57 <Pseudonym> Well here's you rproblem.
22:28:00 <SlushP> So you can't just get a random date when you run the test?
22:28:01 <Pseudonym> You noted that monthPic :: Date -> HtmlTable
22:28:15 <Pseudonym> Well you actually need to use a date.
22:28:21 <Pseudonym> Presumably monthPic needs it for some reason.
22:29:44 * mgoetze thinks SlushP should try perl... it's much more DWIM :)
22:30:10 <SlushP> I see.
22:30:10 <SlushP> Thanks
23:39:08 <Pseudonym> Solved it.  It's ugly, though.
23:42:26 <emu> DoWhatTheMachineThinksIMean
23:42:53 <emu> I thought people learned the lesson of DWIM by now
23:44:55 * Pseudonym laughs
23:45:09 <Pseudonym> Testing this is a bitch.
23:45:26 <Pseudonym> I mean a COMPLETE bitch.
23:45:34 <Pseudonym> How do you force the death of a weak reference?
