02:00:41 <Janni> @yow
02:00:41 <lambdabot> Yow!  I'm out of work...I could go into shock absorbers...or SCUBA
02:00:41 <lambdabot>  GEAR!!
03:53:53 <funktor> hmm, what nice interpreter would you suggest for Windows?
05:08:04 * shapr boings
05:08:09 <shapr> funktor: hugs
05:08:27 <funktor> yah... is a ms-dos prog though :/
05:08:39 <shapr> oh
05:09:09 <funktor> hmm, how do I do a let in hugs?
05:09:18 <shapr> you can't do it interactively
05:09:21 <shapr> that only works in ghci
05:09:24 <funktor> let sum2 = foldr1 (+)
05:09:27 <funktor> doesnt work somehow
05:09:40 <shapr> because ghci pretends to be in a do statement
05:09:47 <shapr> so you can do let there
05:09:58 <funktor> bah
05:10:03 <shapr> :-(
05:10:03 <funktor> I know why I prefer ghc
05:10:14 <dennisb> there is winhugs
05:10:21 <shapr> ghc is generally more useful, imho
05:10:28 <shapr> hugs is good for running on the Sharp Zaurus
05:10:31 <funktor> is there a win ghci?
05:10:40 <shapr> I think so
05:11:10 <dennisb> hugs is fast, it's really nice when you develop bigger programs. ghci can take some time to load when there is a lot of file (not to speak about memory usage)
05:11:29 <shapr> happily, I have lots of CPU and RAM
05:11:36 <shapr> Heffalump: hello weekend man!
05:11:37 * Heffalump has a shiny Haskell 98 report
05:11:46 <shapr> Heffalump: I'M SO JEALOUS.
05:11:46 <Heffalump> just thought I'd come and bounce about it briefly :-)
05:11:55 <shapr> OH take a pic and post it!
05:11:56 <dennisb> shapr: me too
05:12:07 <Heffalump> well, it's been published now
05:12:09 <shapr> Heffalump: yay bounce! can we see pix??
05:12:13 <shapr> pix pix!
05:12:15 <Heffalump> sorry, don't have my camera with me
05:12:18 <shapr> awww
05:12:22 <shapr> maybe tomorrow?
05:12:27 <Heffalump> I'll try to remember to take it home or bring the camera in tomorrow
05:12:39 <shapr> yay!
05:12:40 <shapr> thanks!
05:12:53 <Heffalump> but any of you can order your own now (given 35 of our UK pounds + P&P :-)
05:12:54 <dennisb> I don't have a camera, but I do have a scanner. Send it to me and I will scan it for you... :-)
05:12:54 <shapr> if you email me a pic, I'll put it online and put the url in the #haskell topic
05:16:32 * Heffalump reorganises his bookshelf
05:17:48 <shapr> finding a prominent place for your H98 Report?
05:19:06 <Heffalump> just sorting out a bit really
05:19:18 <Heffalump> but I've put it next to my copy of FoP
05:19:29 <shapr> bah, you get all the good hardcopy :-)
05:20:41 <Heffalump> well, I did pay (personally) for the H98 report
05:32:10 <shapr> well
05:32:20 <shapr> I'll be rich enough to afford all the spiffy books someday.
05:33:21 <shapr> @yow
05:33:22 <lambdabot> There's enough money here to buy 5000 cans of Noodle-Roni!
05:33:24 <shapr> @yow
05:33:24 <lambdabot> My LESLIE GORE record is BROKEN..
05:33:33 <shapr> lambdabot: I feel so sorry for you.
05:33:33 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
05:34:04 <shapr> @yow
05:34:04 <lambdabot> Where's the Coke machine?  Tell me a joke!!
05:53:29 * shapr boings
05:53:53 * psy beeps
05:54:02 <psy> how's business, shapr
05:54:07 * shapr psyks
05:54:27 <shapr> psy: code is good.
05:54:40 <psy> just got done writing a 200-line bash script for uni
05:54:41 * psy shudders
05:54:47 <shapr> write Haskell!
05:54:50 <shapr> it's good for your bones!
05:54:52 <psy> it was for uni!
05:55:33 <psy> going to go write an MSN client using sjj's twisted support in a minute i think, never found one i liked and i'm sick of not being able to talk to people :)
05:56:15 <shapr> code is good.
05:56:31 <psy> not bash
05:56:33 * Heffalump unheres
06:07:42 * shapr boings
06:13:31 * shapr discovers #haskellwars - http://www.dtek.chalmers.se/~d00nibro/hwars/index.php4?Page=main
06:25:12 <funktor> cute
06:31:53 <shapr> @yow
06:31:54 <lambdabot> Jesus is my POSTMASTER GENERAL..
06:31:58 <shapr> @yow
06:31:58 <lambdabot> Sign my PETITION.
06:32:01 <shapr> @yow
06:32:01 <lambdabot> Join the PLUMBER'S UNION!!
06:42:43 <SyntaxPolice> good morning
06:42:53 <shapr> goooood morning vietskel!
06:59:21 --- mode: ChanServ set +o shapr
06:59:54 --- mode: shapr set -o shapr
07:15:26 <f2f> hi
07:15:29 <shapr> hiya
07:15:43 <shapr> hey, what's your latitude?
07:15:50 <f2f> mine?
07:15:56 <shapr> yah, yours
07:16:03 <f2f> <informix> somebody said calgary was CYYC located in  Alta. Canada. 51-07N 114-01W.
07:16:34 <shapr> 65.83°N 21.70°E here
07:16:52 <shapr> so, how's the sunny south treating you? ;-)
07:17:00 <f2f> hahaha
07:17:16 <f2f> foggy
07:17:37 <shapr> we have sun and rain
07:17:43 <f2f> hmm, telia is in norway, right?
07:17:47 <shapr> nah, sweden
07:17:52 <f2f> gotcha :)
07:17:58 <shapr> or at least, they weren't in norway last I checked.
07:18:02 <shapr> who knows...
07:18:12 <shapr> you could be right.
07:18:36 <f2f> so, here's my question
07:18:45 <shapr> ?
07:18:57 <f2f> i came here to ask a question about haskell :)
07:19:05 <shapr> that's great!
07:19:08 <shapr> what's the question?
07:19:55 <shapr> you want to know about monad transformers?
07:20:00 <shapr> arrows?
07:20:09 <shapr> multiparameter type classes?
07:20:09 <f2f> i have a graph represented as an adjacency list, something like "data Node = Node Int [Node]"; my problem is that as i'm updating the graph i need to change the adjacency list to more than one node at the same time
07:20:28 <shapr> sure, ask something hard...
07:20:40 <f2f> however as soon as I return the new graph i lose all information of the previous node
07:20:44 <f2f> example:
07:20:51 <shapr> I think I understand.
07:21:07 <shapr> you're trying to modify a list while looping over it, yah?
07:21:15 <f2f> yes
07:21:25 <f2f> i map a function over it
07:21:42 <f2f> i also tried with recursion -- passing the entire graph all the way down
07:21:47 <shapr> yah, that's what I would do
07:21:47 <f2f> but that's inelegant
07:22:03 <shapr> it sounds like you're trying to use the new graph with the next call, instead of usin the rest of the old graph
07:22:15 <f2f> in C i would just use pointers and modify the original node, nothing like that here?
07:22:30 <shapr> there is stuff like that, but I would recommend against using it in this situation
07:22:47 <shapr> 'variables' aren't particularly 'functional'
07:22:53 <f2f> here's a sample function:
07:23:42 <Arnia> f2f: Look at the FGL (Functional Graph Library), it provides a more functional view of graphs than the terribly imperative idea of an adjacency list with node-marking
07:23:58 <shapr> why not accumulate the *changes* not the actual graph?
07:24:06 <shapr> then you can apply those changes to the old graph to get the new graph
07:24:41 <f2f> insert a b = n where n = Node <some int> [x, y] x = <replace b with n in a> y = <replace a with x in b> 
07:24:52 <shapr> that's what I would do if it's homework, and I should be using the graph datatype I'm given.
07:24:59 <shapr> otherwise, I'd go with Arnia's suggestion and grab the FGL
07:25:01 <f2f> arnia, i took a look there, but it wasn't immediately obvious if it'll do the job
07:25:21 <f2f> ok, then i'll dig deeper there
07:25:25 <Arnia> f2f: It does all graph algorithms functionally
07:25:38 <shapr> @fact afp
07:25:38 <lambdabot> Nothing
07:25:40 <shapr> @fact afpa
07:25:40 <lambdabot> Algorithms, A Functional Programming Approach, http://www.iro.umontreal.ca/~lapalme/Algorithms-functional.html
07:25:51 <Arnia> f2f: It works best with GHC's notion of Active Patterns. Read his papers, they're great stuff
07:25:54 <f2f> shapr, i have this book
07:26:01 <shapr> f2f: oh excellent :-)
07:26:03 <shapr> that's a great book.
07:26:23 <shapr> have you read the section on graph algorithms?
07:26:34 <f2f> the adjacency list stuff is explained there, but not how to solve a particular problem like mine
07:26:45 <f2f> or at least i didn't see it
07:27:16 <shapr> I would recommend checking the FGL
07:27:39 * shapr opens afpa
07:28:13 <shapr> page 138
07:28:46 <shapr> "modifications to the shape of the array cannot be easily achieved"
07:28:52 <f2f> quote the solution and i'll die in shame :)
07:29:03 <shapr> nah, they totally agree with you :-)
07:29:35 <opet> dying of shame is overrated
07:29:46 <shapr> opet: but often expected
07:29:57 <shapr> I've surely tried it a few times.
07:30:15 <shapr> bah
07:30:24 * shapr bounces
07:30:38 <debug> hello
07:30:43 <shapr> hi debug
07:30:46 <shapr> how are you?
07:30:51 <shapr> hur är det med dig?
07:30:51 <debug> I'm functional.
07:30:53 <shapr> w00
07:30:59 <shapr> that's better than dysfunctional
07:31:03 <debug> :)
07:31:18 <shapr> my spam filter is nearly working!!
07:31:23 <Arnia> If you were a police officer I'd accuse you of being procedural :)
07:31:29 * shapr groans
07:31:34 * shapr snickers
07:32:42 <Arnia> A good bad joke is better than a bad good joke
07:32:51 <shapr> someone can tell me the differences among lift, liftM, and liftIO ?
07:32:59 <shapr> and liftST ?
07:34:41 <shapr> I know vaguely what I can do with them, but not really what they're doing.
07:34:50 <Arnia> liftST is a lift into a state transformer monad
07:35:00 <Arnia> liftM is a generic monad lift
07:35:01 <shapr> and liftIO lifts an IO a -> m a
07:35:21 <shapr> so liftIO is really 'lift from IO monad into some other monad' right?
07:35:31 <Arnia> @type liftIO
07:35:41 <shapr> liftM lets me use a normal boring function with a monadic type
07:36:01 <shapr> so liftM2 (+) (IO Int) (IO Int) works
07:36:15 <shapr> so what about lift by itself?
07:36:19 <Arnia> That's what lifts do... its a functor
07:36:23 <Arnia> shapr: What's the type
07:36:28 * f2f printed 'inductive graphs and functional graph algorithms'
07:36:35 <shapr> lift :: (Monad m) => m a -> t m a
07:36:40 <f2f> but still nothing about updating graphs :)
07:36:51 <shapr> it's a (the?) method in the MonadTrans class
07:36:59 <shapr> seems to be the only method
07:37:22 <f2f> maybe the shapr idea is better -- accumulate new nodes and then just fix the neighbours lists in place...
07:37:46 <shapr> it's what I would do to get it to work 
07:37:52 <shapr> then I would come back later and refactor it
07:37:59 <f2f> refactor?
07:38:08 <shapr> oh, you must learn =)
07:38:12 <f2f> i must :)
07:38:18 <f2f> i'm not a functional programmer 
07:38:20 <shapr> http://www.refactoring.com/
07:38:30 <shapr> refactoring came from the Smalltalk world originally
07:38:53 <shapr> http://c2.com/cgi-bin/wiki?WhatIsRefactoring
07:39:16 <shapr> I'm not much of a functional programmer
07:39:28 <shapr> still on the path to purely functional
07:40:19 * shapr remembers what he was doing
07:40:37 <f2f> ok, thanx for the help :)
07:40:51 <f2f> i'll bug you more when i have tried your suggestions :)
07:41:10 <shapr> I wonder if that guy has a dialup connection
07:41:19 <shapr> or maybe he can't code while connected to IRC?
07:41:25 * shapr thinks that's true of 99% of humans
07:44:40 <Arnia> Hmm... that type seems to state that lift takes a monad to a new type that is parameterised on the monad...
07:46:59 * shapr has fun classifying spam
07:55:33 <shapr> hi bea!
07:55:41 <shapr> would you like to learn Haskell?
07:55:47 <shapr> =)
07:55:59 <bea> shapr, are you talking to me?
07:56:02 <shapr> yes!
07:56:05 <debug> :)
07:56:08 <bea> no!
07:56:08 <shapr> haskell is such a great language!
07:56:11 <debug> another swede
07:56:20 <shapr> actually, bea is french/german
07:56:20 <bea> so is French
07:56:26 <debug> ok :)
07:56:35 <shapr> she's my sambo
07:56:40 <debug> cool
07:56:43 <debug> hi bea
07:56:52 <bea> hi debug 
07:56:58 <debug> bea: It is a wonderful day.
07:57:04 <bea> my Swedish is about as good as shapr's ;)
07:57:15 <shapr> bea: your swedish is better than mine
07:57:17 <shapr> much better
07:57:29 <shapr> but my haskillz are better than yours!
07:57:49 <bea> shapr, you can try that next time we go shopping at ICA :)
07:57:55 <shapr> heh
07:58:09 <debug> functional food
07:58:26 * shapr tries to make shopping aisles an instance of Functor so he can fmap over them
07:58:58 <shapr> map (elem shoppingList) aisles
07:59:40 <shapr> er, do let basket = filter (elem shoppingList) aisles; return $ köper basket
07:59:50 <bea> uhoh
08:00:00 <shapr> maybe I should have said betalar instead
08:00:18 <debug> the swedish word 'ta' is usefull
08:00:43 * shapr tries to partially apply reflexive verbs
08:01:46 <shapr> bea: see, this is the source of all my distractions ;-)
08:02:42 * bea thought she was the source of most of shapr's distractions
08:03:29 <shapr> ok, that's true
08:03:59 <bea> debug, so is the English word "ta", also
08:04:28 <debug> ta ta
08:04:30 <debug> hehe
08:06:01 <shapr> there's two of delYsid here
08:06:12 <shapr> he's hiding behind funktor 
08:06:40 <shapr> not so many north amercans here
08:06:50 <shapr> mostly northern europe
08:06:54 <shapr> hi d33p
08:08:18 <tic> debug, f.d. bamze?
08:08:28 * shapr counts swedish addresses
08:08:28 <debug> perhaps
08:08:44 <tic> debug, TF?
08:08:50 <debug> TF?
08:08:58 <shapr> tic, debug, andersca, shapr, bea, polli, ludde, dennisb
08:09:12 <debug> my memory is not what it used to be... do I know you tic?
08:09:35 <shapr> my memory is just as bad as it was ten years ago ;-)
08:09:37 <tic> debug, did you read at Hulebäcksgymnasiet?
08:09:43 <debug> of course
08:09:58 <debug> but chalmers destroyed my memory
08:10:08 <dennisb> maybe it's time to start a haskell.se
08:10:22 <shapr> jaså
08:10:24 <tic> debug, you know me a bit, I think. or at least, you know about me. We've spoken a couple of times. I'm the BeOS guy... ?
08:10:25 * dennisb is not serious (yet)
08:10:31 <SyntaxPolice> there was a huge fire here in columbus, five students dead :(
08:10:38 <dennisb> ouch
08:10:44 <shapr> :-(
08:10:49 <debug> tic: then perhaps I know you
08:10:51 <d33p> hey shapr
08:10:55 <debug> tic: were you in 'lokalen'>
08:10:56 <debug> ?
08:11:06 <tic> debug, yeah
08:11:14 <tic> debug, bamzerummet.
08:11:25 <tic> debug, used to ask you a lot of questions about everything :)
08:11:37 <debug> tic: ok, but not in the 'lokalen' as in Hissingen-lokalen?
08:11:42 <tic> debug, oh.. nope. :-/
08:12:15 <tic> debug, but if you had "debug" as a nick back then, you're the same one at least. You had a bit strange last name
08:12:16 * debug has a fuzzy memory
08:12:21 <debug> yes
08:12:29 <debug> what's your realname?
08:12:31 <shapr> hoi BlitzNL 
08:12:33 <shapr> hoe gaat?
08:12:45 <BlitzNL> hoe shapr, het gaat goed ;)
08:12:55 <tic> debug, "mikael jansson"
08:13:06 <tic> debug, ITDA?B
08:13:07 <shapr> BlitzNL: how's the code treating you?
08:13:22 <BlitzNL> shapr: code has been good on me lately ;)
08:13:27 <shapr> that's great!
08:13:31 <debug> tic: then perhaps I remember you
08:13:43 <debug> but it was a long long time ago
08:13:44 <shapr> debug: you should have backed up before chalmers ;-)
08:14:11 * shapr backs up his brain to a wiki
08:14:36 * debug remembers eating kanelbullar and drinking jolt and watching movies and eating pepparkakor at xmas in school
08:14:44 <shapr> mmmm pepparkakor
08:14:59 <funktor> help!
08:15:00 <shapr> acrylamids, tyvarr :-(
08:15:01 <debug> and a friend, tic you remember janczyk?  he sometimes slept over
08:15:06 <shapr> funktor: yes?
08:15:14 <BlitzNL> does anyone know of a nice application to write proofs given a set of rules? I mean I know of HOL and stuff but I don't want the program help me proof the hypothesis but just help me write nice proofs.
08:15:15 <shapr> funktor: you're being assimilated by a windows machine?
08:15:31 <funktor> if I have a data definition which uses a type variable, how do I write a proper show instance?
08:15:33 <shapr> BlitzNL: you mean layout proofs in documents like LaTeX or something?
08:15:50 <debug> tic: the alarm was set at 11 pm I think, so he had to stay in the bamze room all night :)  no toilet visits or anything like that
08:15:50 <Igloo> I've never used it bude jade might be what you want
08:15:51 <shapr> funktor: http://kungens.kemi.fi/~shae/src/haskell/Mandelbrot6.hs
08:15:58 <funktor> i.e.: data Game position = Plays position [Game position]
08:15:59 <tic> debug, yeah. :)
08:16:01 <Igloo> s/bude/but/
08:16:11 <funktor> data Position = Pos Colour Board
08:16:12 <tic> debug, and oh, I was the guy using svorak as well.
08:16:14 <BlitzNL> shapr: well something like that, but I was looking for something more visual.
08:16:18 <shapr> ouch, svorak
08:16:25 <Igloo> (to Blitz)
08:16:26 <debug> ah, ok
08:16:46 <shapr> funktor: does the show instance there help you?
08:16:47 <BlitzNL> Igloo: Ok, I'll look for Jade
08:17:04 <funktor> shapr: there? where there?
08:17:05 <shapr> I've seen svorak, but I prefer dvorak
08:17:18 <shapr> funktor: newtype MandelData = MandelData (Integer, Complex Double, Complex Double)
08:17:18 <shapr>     deriving (Ord,Eq) --,Show)
08:17:18 <shapr> instance Show MandelData where
08:17:18 <shapr>     show (MandelData (iters, z, c)) = "MandelData, Iters: " ++ show iters ++ ", Z:" ++ show z ++ ", C:" ++ show c
08:18:07 <funktor> shapr: That does not use a type-variable
08:18:44 <tic> shapr, okay, why?
08:19:42 <shapr> because I prefer the punctuation in the top left where it is
08:19:54 <shapr> maybe I would prefer svorak if I were a native swedish speaker
08:20:21 <shapr> but I have x-symbol
08:20:44 <shapr> so I just used dvorak
08:21:32 <shapr> isn't it hard to get to the square brackets and curly braces with svorak?
08:22:46 <shapr> funktor: you want an instance of Show for Position?
08:22:53 <tic> just as hard as with normal swedish qwerty
08:23:29 <shapr> I guess it's because I learned dvorak eleven years before I started learning swedish.
08:23:58 <funktor> shapr: I have a Show instace for Position
08:24:12 <funktor> but ghci complains that I do not have an instance for (Show (Game Position))
08:24:40 <shapr> oh
08:24:42 <shapr> um
08:24:56 <funktor> so I need a show instance for Game position
08:25:19 <shapr> instance (Show a) => Show Game a where ...
08:25:25 <shapr> something like that I think
08:25:29 <funktor> ah
08:25:33 <funktor> Ill try that, tnx
08:25:58 <shapr> that may be just close to the real thing
08:27:09 <shapr> urf
08:27:58 <BlitzNL> Igloo: You meant Jape ;) 
08:28:33 <Igloo> Oh, OK, sorry
08:29:09 <BlitzNL> Igloo: No problem, it seems to be a nice tool
08:29:52 <shapr> funktor: hey, I think I figured it out...
08:30:00 <shapr> assuming you have deriving show on Colour and Board
08:30:23 <shapr> instance (Show a) => Show (Game a) where
08:30:23 <shapr>     show (Plays pos gs) = "Game " ++ (show pos) ++ (concatMap show gs)
08:35:48 <shapr> is there a simple way to format a Float into a percent? 
08:36:59 * shapr discovers GHC.Float.formatRealFloat
08:51:33 <hdaume> hi all
08:52:19 <shapr> hi hal!
08:52:42 <shapr> hey, do you think GDC could be useful in classifying spam?
08:53:36 <hdaume> meh, i'd probably just use a regular classifier like c4.5 or svmlight...clustering seem a bit overkillish
08:53:37 <shapr> the GDC license is a bit sparse, is that on purpose?
08:53:48 <hdaume> shapr: yes, because I'm lazy
08:53:52 <shapr> heh, ok
08:54:54 <shapr> I hacked up a rudimentary spam filter that uses paul graham style bayesian statistics
08:55:03 <hdaume> cool
08:55:14 <shapr> do you think svmlight or c4.5 would do a better job than bayesian statistics?
08:56:04 <hdaume> in *theory* bayesian stats are optimal.  in practice, it largely depends on how much training data you have.
08:57:08 <shapr> PG says don't train on anything over a year old
08:57:25 <shapr> I've also noticed it's important to train on at least one instance of every 'flavor' of spam
08:57:38 <hdaume> seems reasonable.  for something like this, it might make sense to use a forgetful learner
08:57:47 <shapr> I grabbed the latest 150 and didn't get any "dr. mbongo" spams, and then it couldn't tell they were spam.
08:58:22 <hdaume> i'd give svms a whirl.  with only 150 instances, they'll likely beat the pants off any other method
08:58:32 <shapr> I have 2500 or so
08:58:35 <shapr> spams, that is
08:58:39 <hdaume> (don't tell my associate franz och i said that though -- he'll kill me for not pimping maxent)
08:58:42 <shapr> heh
08:58:45 <shapr> what's maxent?
08:58:46 <hdaume> that's still not very much...i'd still go with svms :)
08:58:48 <hdaume> maximum entropy
08:59:39 <hdaume> it's essentially a log-linear classifier...it has the advantage that it's only got one extrema, so you can use a simple gradient method to find an optimal solution
09:00:02 * shapr sees a weeks worth of homework to understand that sentence
09:00:24 <hdaume> but, despite it's name, it tends to overfit especially on sparse data, a problem svms don't have
09:00:42 <shapr> ah
09:01:10 <hdaume> franz gets around this problem essentially by introducing a gaussian prior on feature weights, but if you work through the math, this is essentially just a hack
09:01:10 <shapr> I'll do one better, I'll take a clue from lambdabot and write a plugin api for the trainer/classifier
09:01:13 <funktor> yeha!
09:01:17 <funktor> it works!!!!!!!!!!!
09:01:20 <shapr> funktor: yay!
09:01:35 <shapr> hdaume: that's a quotable sentence.
09:01:59 <hdaume> :)
09:02:06 <shapr> saying that a gaussian applied to feature weights is just a hack =)
09:02:14 * shapr adds to the QuotesPage
09:02:18 <hdaume> there are also various smoothing methods you can apply, but again, in theory these shouldn't be necessary
09:02:58 <funktor> gimme some hours, and this baby will play chess
09:03:20 <shapr> PG is getting three false negatives and one false postive in 5000 incoming emails
09:03:38 <funktor> shapr: Hmm,  data Game position = Plays position [Game position] driving (Show)
09:03:39 <funktor> worked
09:03:42 <hdaume> that's not bad
09:03:46 <funktor> I still wonder how to write my own show...
09:03:54 <shapr> funktor: did you see what I pasted for you?
09:04:25 <hdaume> shapr: svms also have the nice ability that it's easy to weight whether you think fps are worse than fns, etc.  they do take a while to train though :)
09:04:28 <shapr> hdaume: he's been changing tokenization and matching rules though
09:04:49 <funktor> shapr: The Mandelbrot thing?
09:05:02 <shapr> now, words in a certain field have the field name prepended, making for a larger and more specific vocabulary
09:05:13 <shapr> Subject*FREE instead of just FREE
09:05:21 <BlitzNL> I am confused about the term 'graduate student'. It seems to popup quite often lately, but what does it mean? 
09:05:34 <shapr> instance Show Position where
09:05:34 <shapr>     show (Pos c b) = "Position " ++ (show c) ++ (show b)
09:05:34 <shapr> instance (Show a) => Show (Game a) where
09:05:34 <shapr>     show (Plays pos gs) = "Game " ++ (show pos) ++ (concatMap show gs)
09:05:56 <shapr> hdaume: thanks for your expert advice, I'll probably ask you more about it in the future :-)
09:06:03 <hdaume> np :)
09:06:23 <funktor> concatMap? cute!
09:07:29 <funktor> cool, now I just need to add move-info to the Position data type, and take the first entry of the move-data list to get the bestMove
09:08:09 <shapr> BlitzNL: it means someone who has completed a bachelor's degree (four years) and is in a further degree
09:08:45 <BlitzNL> shapr: so someone who is currently working on hister MSc ?
09:08:46 <shapr> in the US, one year of kindergarten, twelve years of 'school', then college
09:08:46 <tic> isn't a bachelor three years here in .se?
09:09:08 <shapr> bachelor's is four years of school, master's is three years more after a bachelor's
09:09:21 <shapr> PhD is a variable number of years after a bachelor's
09:09:27 <shapr> I've heard from three to seven
09:10:34 <shapr> the goals I've often seen are; bachelor's, get a job; master's, get a good job; PhD, become a professor
09:11:11 <tic> hrm
09:11:22 <shapr> tic: I don't know about the .se system
09:11:24 <tic> my aim is to get my MSc in four and a half year.
09:11:35 <shapr> I'd like to have a bachelor's someday.
09:11:40 <shapr> that would be fine with me.
09:11:53 <tic> shapr, well, here at chalmers, it takes you three years to get a bachelor's and 4.5 years to get a MSc
09:12:12 <Smerdyakov> tic, 4.5 counts the three years before, or no?
09:12:15 <tic> Smerdyakov, nope.
09:12:21 <shapr> gee, I like that plan.
09:12:25 <tic> shapr, mhm. :)
09:12:31 <Smerdyakov> Hm. That's very out of wack with what a masters degree is in the USA>
09:12:34 <hdaume> anyone know what the new name for CVar
09:12:38 <Smerdyakov> Usually only one or two years.
09:12:49 <tic> 180p, where 1p is ~40h studying (i.e., a full-time week)
09:12:50 <shapr> hdaume: is that the mailbox thingy?
09:12:54 <shapr> maybe MVar?
09:12:55 <tic> so you read 40p a year.
09:12:58 <tic> or 40 weeks a year.
09:13:03 <Smerdyakov> Heh.
09:13:10 <Smerdyakov> "p's" and "reading" don't mean anything to me, either.
09:13:15 <tic> heh
09:13:16 <tic> points
09:13:17 <shapr> reading means "taking a class"
09:13:19 <ludde> What does the ~ letter do in lambda functions? It makes it "irrefutable" but what does that mean?
09:13:27 <tic> you don't really take classes 40 weeks a year though. only 32
09:13:41 <tic> so we "study" at a rate of ~50h/week
09:13:43 <tic> or something.
09:13:48 <shapr> I could take 40p of CS classes a year... if I could afford to eat at the same time.
09:13:52 <shapr> that would rock.
09:13:59 <hdaume> ludde: if you write 'foo ~(x:xs) = 5', then the result of "foo []" is going to be 5
09:14:15 <hdaume> even though the program would usually "refute" this match, since it's irref, it won't
09:14:16 <shapr> hdaume: is that like forcing a base case?
09:14:28 <hdaume> it's helpful for making stuff more lazy
09:14:33 <tic> shapr, we get money from the gov't
09:14:41 <tic> shapr, we lend a bit and recieve a bit for free
09:14:52 <tic> shapr, and school doesn't cost you anything.
09:14:55 <ludde> hdaume: hmm ok
09:14:58 <tic> shapr, but that you might know already.
09:14:58 <Smerdyakov> tic, so if you have a MSc, how long would it take to then get a PhD from the same school?
09:15:04 <tic> Smerdyakov, dunno. 
09:15:04 <shapr> tic: yah, the last bit I know.
09:15:05 <tic> ludde?
09:15:07 <BlitzNL> ludde: A pattern that always matches and never fails?
09:15:15 <hdaume> BlitzNL: yeah
09:15:16 <ludde> hdaume: what about foo ~(x:xs) = x
09:15:20 <ludde> tic: yes?
09:15:27 <hdaume> ludde: you'll get an error if you pass that the empty list
09:15:35 <tic> ludde, how long time would it take to "upgrade" your MSc to a PhD?
09:15:38 <tic> ludde, Smerdyakov asked.
09:15:42 <hdaume> but "foo ~(x:xs) = 5:x" then "head (foo [])" will not fail
09:16:00 <ludde> the chalmers MSc is not international though
09:16:09 * shapr doesn't really understand ~
09:16:41 <tic> uhm?
09:16:57 <tic> ludde, the MSc -is-, but some poeople were arguing if the IT MSc was.
09:17:15 <hdaume> giving patterns in function arguments is like making a case statement.  "foo (x:xs) = ..." ==> "foo l = case l of { x:xs -> ... }", right.  using ~ makes it a "let" instead of a case.  "foo ~(x:xs) = ..." ==> "foo l = let (x:xs) = l in ..."
09:17:20 <Smerdyakov> What is an "international degree"??
09:17:48 <shapr> internationally accredited
09:17:56 <shapr> allowing you to do grad studies in another country
09:18:32 <ludde> tic: are you sure about that? cause I talked to marianne last wednesday and then she said it wasn't
09:18:35 <Smerdyakov> Hm.
09:18:45 <Smerdyakov> You just need a bachelor's degree to start a PhD in CS in the USA.
09:18:53 <Smerdyakov> So I'm not sure if this distinction you mention matters outside of Europe.
09:20:16 <Smerdyakov> And I'm still hoping for an answer of how long it would take you to get a PhD at your university after getting the MSc....
09:20:44 <ludde> Smerdyakov: i'm not sure
09:20:44 <BlitzNL> Smerdyakov: In Utrecht it'll take 4 years..
09:21:19 <tic> ludde, d'oh.  that's nasty.
09:21:44 <Smerdyakov> BlitzNL, ah. Thank you. That's 4 years after already spending 3 for a bachelor's and 4.5 for a MsC??
09:23:04 <BlitzNL> Smerdyakov: No. This is the dutch curriculum (for Beta studies): Bachelor 3 years -> Master 2 years -> Phd 4 years.
09:24:04 <Smerdyakov> Oh. That makes sense, then.
09:24:33 <Smerdyakov> tic makes it sound like, to keep the total time-to-PhD of most of the world, an MSc student would need to spend less than 2 years to get a PhD.
09:27:04 <BlitzNL> I think a more interesting question is; what's the typical age of a newly graduated MSc? I holland that's after walking through high school in 6 years and after that spending 5 (3+2) on your Msc, I'll be 23 when I get my Msc.
09:28:04 <emu> high school is 6?
09:28:11 <ludde> at summer, i've been 9+3+3 years in school 
09:28:32 <ludde> when i get my MSc, i've been 9+3+4.5 years in school
09:29:11 <Smerdyakov> ludde, I guess you are not considering PhD at all, if you have no idea how long it would take?
09:29:18 <ludde> no i don't
09:31:06 <BlitzNL> mmm 8 years grammar school + 6 years high school + 5 years university is the way to go in Holland.
09:31:53 <emu> when do you start school
09:31:53 <Smerdyakov> Not if you want to be a professor, right?
09:32:03 <BlitzNL> emu: age 4/5
09:32:19 <emu> high school entrance at 13?
09:32:43 <BlitzNL> emu; yeah most children are 12
09:32:49 <emu> I see
09:33:08 <BlitzNL> emu: does this look like your system?
09:33:18 <emu> high school is ~14 here
09:33:34 <emu> and lasts for 4
09:33:41 <emu> its all BS anyway
09:33:54 <BlitzNL> emu : BS?
09:33:56 <emu> then you get your undergrad in 3-4 years
09:34:00 <emu> bachelors
09:34:04 <BlitzNL> ah ok
09:34:05 <emu> and can get a masters in a year or two
09:34:57 <BlitzNL> so you recieve a masters at age ~24..
09:35:07 * shapr grumbles
09:35:45 <Smerdyakov> BlitzNL, close enough
09:35:48 * ibid got my masters at age 25
09:36:54 <BlitzNL> Smerdyakov, emu: and you are both from the US?
09:37:44 <Smerdyakov> Yes
09:37:54 <shapr> me too!
09:38:37 <Arnia> Hum... here A Level's finish at 18... bachelors are 3 years and masters after bachelors is one year. Then Doctorates are 2 to 4 years on top of that...
09:38:50 * ibid submitted my very first (second, if we are being picky) paper today (to a symposium)
09:39:12 <BlitzNL> ibid: what symp and where is it about?
09:39:38 <emu> you can get a masters at 22 if you're fairly intelligent and willing to work. or even earlier
09:39:43 <ibid> BlitzNL: http://www.cs.uku.fi/~fehs03/
09:40:17 <BlitzNL> ibid: deadline is today ;)
09:40:25 <ibid> BlitzNL: "where is it about"?
09:40:29 <ibid> BlitzNL: quite :-)
09:40:59 <Smerdyakov> I think the US is the only country stupid enough to have 4 years as the default time for a bachelor's degree. =D
09:42:34 <BlitzNL> ibid: It is interesting to me since I study `Software Technology` in Utrecht which focusses on programming languages and tools.. what is your paper about?
09:43:13 <ibid> BlitzNL: title is "On Typechecking B"
09:43:47 <BlitzNL> ibid: I am currently following a course on implementing a type checker, it's very interesting stuff indeed.
09:45:59 <ibid> BlitzNL: what are they telling you?
09:47:53 <ibid> i'm in a disadvantage here, i'm working on stuff that nobody else in staff here quite knows. my professor, while teaching formal methods, does research in other areas :-)
09:48:00 <ibid> but i like the town :_)
09:49:13 <BlitzNL> ibid: It's not a full blown course on type system ( I will take that next month and they'll use the book "Types and Programming Languages Benjamin C. Pierce The MIT Press"). The course I take currently is on implementing programming languages and we are implementing some toy language and finally add a simple type system.
09:49:35 <Smerdyakov> "Finally"??
09:49:50 <ibid> (and i believe before i taught popl last fall, formal type systems were unheard of,... well... one of the professors might know it:-)
09:50:21 <BlitzNL> Smerdyakov: yeah, in the meaning of eventually
09:50:35 <Smerdyakov> But wouldn't you have type systems from the beginning?
09:50:47 <Smerdyakov> Or users can just make up whatever programs they want?!
09:51:45 <BlitzNL> Smerdyakov: The initial version of the compiler just didn't do type checking so anything goes ;)
09:51:59 <Smerdyakov> That's inane. You go to an infidel school.
09:52:36 <BlitzNL> Smerdyakov: lol
09:53:18 <ibid> Smerdyakov: in what other order would you do it?
09:55:20 <Smerdyakov> Type checking before generating any output code.
09:56:07 <ibid> why?
09:56:19 <Smerdyakov> So your compiler doesn't produce code that crashes horribly?!
09:56:31 <BlitzNL> Smerdyakov: but when considering a course on programming language implementation, don't you think it is better to start out small with no or a very limited type checker and start learning students how to generate language constructs into assembly?
09:56:37 <ibid> you can't avoid that :-)
09:56:50 <Smerdyakov> ibid, oh gawd. And you say that in #haskell.
09:57:14 <Smerdyakov> BlitzNL, no. The course I took never had us hand in anything but complete compilers.
09:57:28 <ibid> Smerdyakov: you can make it produce code that does not crash horribly, but for that, you first need to make it produce code that does crash horribly
09:57:41 <ibid> Smerdyakov: debugging the code generator etc
09:57:41 <Smerdyakov> BlitzNL, we just made the language more complicated from project to project, and compilation was always done in a safe way for each one.
09:57:41 * shapr produces code that crashes horribly
09:57:48 <shapr> well, dysfunctional emails at least
09:58:04 <shapr> I quite a few bugs to fix
09:58:09 <shapr> "found"
09:58:36 <Smerdyakov> ibid, that is not related to type checking....
09:58:52 <ibid> Smerdyakov: no, but it is related to your answer
09:59:15 <Smerdyakov> ibid, how? I think it was clear that I'm talking about _finished_ projects, not the steps you take in debugging them.
09:59:42 <ibid> Smerdyakov: oh, we were talking about unfinished projects. i thought that was clear
10:00:04 <Smerdyakov> BlitzNL, what were YOU talking about? =D
10:01:15 * BlitzNL is confused ;)
10:01:35 <Smerdyakov> BlitzNL, were you saying that one assignment was to hand in a compiler that did no type checking, despite having a non-trivial language?
10:01:59 <shapr> y0 Marvin-- 
10:04:13 <BlitzNL> Smerdyakov: yes. Assigment 1: hand in compiler, Assignment 2: hand in compiler with type checker
10:04:20 <Smerdyakov> ibid, see?
10:04:48 <BlitzNL> Smerdyakov: but hey, I am not making the decisions around here ;)
10:05:32 <ibid> BlitzNL: is ass 2 supposed to build on ass 1?
10:05:43 <Marvin--> evening
10:06:05 <ibid> evening
10:06:07 <BlitzNL> ibid: yeah it's a purely incremental process
10:06:15 <ibid> Smerdyakov: see ;-)
10:06:24 * BlitzNL hehe
10:06:37 <Smerdyakov> BlitzNL, is the incremental thing built just a type checker for the same language?
10:07:52 <ibid> if i were to teach a pli course, i'd do something similar. hand in a trivial compiler. add more features, among them a type checker as you go
10:07:53 <BlitzNL> Smerdyakov: yes it is, and if it contains polymorphism you get a bonus ;)
10:08:15 <Smerdyakov> ibid, see++!
10:08:21 <ibid> that way you always have something that gets source and outputs object code
10:08:30 <ibid> Smerdyakov: no i don't. he just supported my position :-)
10:08:41 <Smerdyakov> What?
10:09:01 * ibid laughs
10:09:03 <shapr> Marvin--: wassup?
10:09:06 <ibid> (but i'm serious)
10:09:06 <Smerdyakov> My position is that it is bad to first make a compiler that compiles ill-typed programs for one project, and then add a type checker later.
10:09:10 <Smerdyakov> Isn't that what he just confirmed?
10:09:24 <ibid> Smerdyakov: no, what he confirmed is that that's what they do
10:09:34 <ibid> Smerdyakov: the bad part is your assertion :-)
10:10:00 <ibid> Smerdyakov: my position is that it is a sensible order of business on a pli course
10:10:43 <Smerdyakov> How does the fact that his class does that show that it's sensible?
10:11:24 <ibid> Smerdyakov: i tend to view the incremental project done during the course as a one project, with increments that you hand out so the instructor can check you aren't chasing wild goose
10:11:43 <Marvin--> shapr: I'm throughly stuck with the pattern matching
10:11:55 <Marvin--> other than that, I just came home from visiting my parents over the weekend
10:12:08 <Smerdyakov> Well, anyone at CMU who tried to teach a course where a type checker was added to a compiler in a later project would be CRUCIFIED. =D
10:12:48 <shapr> I think incremental development is good
10:12:48 <ibid> Smerdyakov: even if the compiler is for a dynamically typed language? ;-) (yes, they can have static type checkers)
10:12:53 <shapr> it's what happens in the real world.
10:13:03 <shapr> the requirements are always a moving target.
10:13:09 <mgoetze> real what?
10:13:16 <Smerdyakov> ibid, yes, though anyone teaching a compilers class working with dynamically typed languages would be crucified as well.
10:13:25 <shapr> Marvin--: my spam filter is moronic at the moment.
10:13:29 <ibid> Smerdyakov: heh :-)
10:13:45 <ibid> Smerdyakov: you are prisoners of your own tradition ;-)
10:14:01 <Smerdyakov> shapr, I'm saying that it's ridiculous to do the stages of compilation out of order in creating a compiler. Taking code that may be ill-typed and compiling it to machine code is not helpful to the compiler developer.
10:14:03 <ibid> and that, my friends, tries to be a joke
10:14:31 <shapr> I get paid to fulfill my clients' requirements.
10:14:54 <ibid> Smerdyakov: i'd like to hear why you at CMU think it is a bad idea, given that we are talking about an incrementally developed project in the same course?
10:14:58 <shapr> that usually means I ship something that does a bad job at first, because it's better than them doing it manually.
10:15:07 <ibid> Smerdyakov: i'm open to good arguments :-)
10:15:36 <shapr> I just try to make sure that the exact definition of "bad" that I'm using is understood by my clients.
10:16:11 <shapr> Smerdyakov: I understand your point, I just think it's not how the commercial world works.
10:16:15 * Marvin-- grumbles
10:16:28 <Marvin--> I wish I didn't get all the "updated LL translation of XYZ" commit mails for d-i
10:16:43 <shapr> use Paskalle!
10:16:54 <ibid> shapr: did you get my comment? :-)
10:16:58 <shapr> once I get it working ....
10:17:08 <shapr> ibid: I saw your translation.
10:17:13 <shapr> Paskalle is a lovely name =)
10:17:31 <ibid> shapr: some people in finland might not like it at first sight
10:17:42 <ibid> shapr: it isn't even cute like SeX
10:17:51 <shapr> I'll just claim it's a combination of Pascal and Haskell
10:17:56 <ibid> heh
10:19:37 <shapr> Smerdyakov: the most expensive (and probably most common) thing that happens to in-progress commercially developed software is that the requirements change.
10:19:41 * Smerdyakov returns
10:19:58 <Smerdyakov> shapr, if you think I'm arguing against incremental development, then you're confused.
10:20:12 <Smerdyakov> shapr, I'm recommending adding one language feature at a time, at every stage of the compiler at once.
10:20:26 <ibid> Smerdyakov: it does not sound that way
10:20:41 <ibid> Smerdyakov: or do you consider typechecking a non-languagefeature
10:20:48 <shapr> you're saying the type checking feature should be added before the executable code generation feature
10:21:00 <Smerdyakov> ibid, making it harder for yourself to debug a compiler is a bad idea, and deferring easy checks that would let you know if input programs are at fault is just stupid.
10:21:37 <ibid> Smerdyakov: that is a good point, though i need to ponder whether it's enough :_)
10:21:51 <Smerdyakov> shapr, both type checking and executable code generation _for_a_single_language_feature_ (say, addition of integers) are so trivial that the order doesn't matter.
10:21:55 <shapr> I think commercial development is about shipping whatever best helps the customer get their job done, as quickly as possible
10:22:30 <Smerdyakov> shapr, you test all parts of that feature at once, in a single unit.
10:22:44 <shapr> what do you mean?
10:22:50 <Smerdyakov> OK.
10:23:03 <Smerdyakov> You have a compiler that does what it does perfectly, as far as your tests have determined.
10:23:09 <Smerdyakov> But it doesn't support addition of integers.
10:23:12 <shapr> ok
10:23:17 <Smerdyakov> So you go through and, as a unit, update every part needed to support that.
10:23:22 <Smerdyakov> Then you test programs that add integers.
10:23:34 <shapr> actually, I would write the tests first :-)
10:23:47 <shapr> but that's just a picky detail ;-)
10:23:55 <Smerdyakov> Yes. Not related to this discussion.
10:23:58 <ibid> Smerdyakov: if the compiler targets a typechecking platform, would you still be as strongly of that opinion? (granted, for a pli course, it may not be a good platform choice)
10:24:35 <Smerdyakov> ibid, yes. You can know if the user has an inherently ill-typed input program, or if your compiler is outputting ill-typed code by an internal fault.
10:24:47 <ibid> Smerdyakov: ok
10:25:46 <Smerdyakov> shapr, do you see what I mean, and why your statements about "getting products to market as quickly as possible" are meaningless?
10:26:51 <Smerdyakov> ibid, also, for nontrivial languages, type checking is needed to even decide how to proceed in compilation.
10:26:53 <ibid> Smerdyakov: actually, your comments make me think whether there would be a better compiler organisation that allows you to add a feature by editing one place, while still affecting all the necessary phases (you know, code change localization and all that)
10:26:57 <shapr> I see what you mean, and I agree that adding type checking while adding the feature is best.
10:26:58 <ibid> Smerdyakov: that's true
10:27:19 <shapr> I also think that there are situations where I would just add the feature
10:27:20 <Smerdyakov> shapr, still a bad way to think about it: type checking is PART OF the feature.
10:27:23 <ibid> Smerdyakov: well, i'll contest that nontrivial part, but your point stands in any case
10:27:49 <shapr> If type-checking is part of the client requirements, then it's part of the feature.
10:27:51 <shapr> otherwise, it's not.
10:28:12 <Smerdyakov> If it's not a requirement, then you wouldn't be adding it later, anyway, so that case is not relevant here...
10:28:33 <ibid> Smerdyakov: requirements change
10:28:40 <shapr> yes, that's my point
10:29:10 <shapr> it's entirely possible that I would ship some software that did not have type checking as part of the requested features, and then suddenly, my clients change their mind.
10:29:22 <shapr> this happens with incredible regularity
10:29:24 <Smerdyakov> So, what, you're trying to say that it's possible to choose a strategy that lets you implement requirements BEFORE THEY'RE DECIDED?
10:29:39 <shapr> no, just that decisions are barely written in sandstone.
10:29:41 <Smerdyakov> Obviously that's not possible, so why are you bringing this up to refute what I've said?
10:29:53 <shapr> yes, that is possible.
10:30:10 <shapr> in many cases, the clients only know what they want, when they don't get it.
10:30:10 <Smerdyakov> It's not possible to be sure you've met all requirements before they are decided, no.
10:30:21 <ibid> Smerdyakov: you said "If it's not a requirement, then you wouldn't be adding it later" - which is not true
10:30:38 <ibid> Smerdyakov: that's the only point i was contesting there
10:30:41 <shapr> clients are dynamically typed at best =)
10:30:49 <Smerdyakov> ibid, well, then change it to "you don't have to choose a point in time to implement it from the beginning of your project"
10:31:06 <shapr> what do you mean?
10:31:10 <Smerdyakov> ibid, AKA, the ordering heuristic I'm proposing and that that you proposed are not relevant to that situation.
10:31:19 <ibid> Smerdyakov: true
10:31:37 <Smerdyakov> shapr, the heuristics we are discussing solve the following problem: In creating a compiler, there are decomposable steps. Decide in what order to perform them to achieve a given set of goals.
10:31:47 <ibid> Smerdyakov: any thoughts about the change localisation?
10:32:04 <shapr> Smerdyakov: oh, that sounds great :-)
10:32:12 <Smerdyakov> shapr, so cases where the goals _change_ are not claimed to be handled. Indeed, it is "provably impossible" to handle them.
10:32:36 <shapr> but that's normal everyday commercial software development...
10:32:45 <shapr> it *is* a case, and a common one
10:32:51 <ibid> shapr: and often noncommercial too
10:33:03 <ibid> Smerdyakov: yet, most of SE is about trying to handle them
10:33:07 <Smerdyakov> ibid, make sure your language features don't interact in funny ways, and maybe you could do it =D
10:33:15 <ibid> Smerdyakov: heh
10:33:29 <shapr> I'm go with the Steele et al monad transformers approach :-)
10:33:29 <Smerdyakov> shapr, ibid, look. You are going about this in a very bizarre way.
10:33:39 <ibid> Smerdyakov: do you know of any research on that?
10:33:41 <shapr> what do you mean? how so bizarre?
10:34:17 <Smerdyakov> shapr, ibid, if you have a method for writing an individual function well, that method is not "invalidated" by not applying to the whole program you have to write.
10:34:36 <shapr> oh, I agree with that.
10:34:39 <Smerdyakov> shapr, ibid, thus, trying to apply my heuristic to a situation where requirements change is a "type error."
10:34:40 <ibid> Smerdyakov: me? :-) you all but convinced me earlier. i'm just discussing particulars here, as objections occur to me :-)
10:35:08 <Smerdyakov> shapr, whenever you have a choice, with a given set of current requirements, I claim my heuristic is the way to go.
10:35:26 <Smerdyakov> shapr, even assuming that you will have random requirement changes later.
10:35:36 <shapr> what's the best heuristic for situations where requirements *will* change?
10:35:43 <Smerdyakov> shapr, mine.
10:35:45 <Smerdyakov> shapr, I just said that.
10:36:24 <Smerdyakov> shapr, if the probability distribution of requirement changes is evenly distributed among all possibilities, you should clearly do what seems best at the moment.
10:36:39 <shapr> yah, that's XP for ya
10:36:51 <Smerdyakov> shapr, if you know more about the possibilities, then "do well given this probability distribution" becomes a concrete feature requirement, and it becomes a moot point.
10:37:00 <ibid> Smerdyakov: that sounds much like XP. most of the SE literature disagrees though
10:37:03 <shapr> yep, I agree.
10:37:14 <shapr> @karma+ XP
10:37:14 <lambdabot> XP's karma has been incremented.
10:38:09 <ibid> (well, "most" is too much to say. the SE establishment disagrees is better said;-)
10:38:15 <Smerdyakov> OK.... you guys are confusing me. Have I convinced you that the optimality of what I said is independent of what may happen in the future?
10:38:26 <shapr> happily, monad transformers seem likely to outdo OOP for modularization and speed of change.
10:38:47 <shapr> Smerdyakov: you have convinced that "do what seems best at this moment" is the correct course of action at any time.
10:38:50 <shapr> but I already knew that.
10:38:52 <ibid> shapr: OO is mostly misunderstood :-)
10:39:08 <shapr> heck I understand it... why do you think I'm here? :-)
10:39:12 <Smerdyakov> shapr, great. So why did you argue about it?
10:39:33 <ibid> shapr: most people who think they understand it are wrong :-)
10:39:49 <shapr> because what you said about "always implement type checking along with or before code generation" is a special case of that strategy that I disagree with.
10:40:00 <Smerdyakov> ibid, how do you define understanding?
10:40:07 <shapr> yah, I'm curious also.
10:41:04 <Smerdyakov> shapr, but your disagreement was based on cases where type checking is not required.... and I never said you should implement type checking in those cases!
10:41:05 <ibid> Smerdyakov: being able to think object-orientedly. but the problem is, the term is often taken to mean inheritance, class diagrams etc, when it is all about objects that communicate
10:41:42 <Smerdyakov> ibid, and how do you prove that you have the "one true understanding"?
10:42:10 <shapr> ibid: Python was my first love (in programming languages), so I believe I do understand OOP.
10:42:13 <ibid> Smerdyakov: you don't, it's a matter of school, i guess. i wasn't being completely serious there
10:42:29 <ibid> shapr: knowing a language does not make one know OOP
10:42:57 <shapr> yes, but I vote that knowing Smalltalk/Python in that order is likely to encourage that understanding.
10:43:20 <ibid> perhaps :_)
10:43:24 <shapr> I don't know enough about Dylan,Cecil, etc to say anything about them.
10:43:37 <ibid> OO is not a language, it is a state of mind
10:43:39 <ibid> like FP
10:43:40 <shapr> I do think Self helps OOP understanding.
10:43:45 <shapr> yes, I agree
10:43:47 * ibid has done FP in Java
10:43:56 <shapr> it's a set of idioms
10:44:04 <ibid> no, it's a way of thinkin
10:44:04 <ibid> g
10:44:15 <ibid> idioms come from that
10:44:19 * Marvin-- gives in to his tummy and goes to get some dinner
10:44:20 <shapr> ok, fair enough
10:44:27 <shapr> what encryption does SSL use?
10:44:44 <shapr> ah
10:48:41 <Marvin--> the client and server agree on a symmetric cipher
10:49:26 <shapr> of the ciphers listed in apt-cache show openssl, I only know of RSA in Haskell
10:49:27 <shapr> hmm
10:49:57 <shapr> hoi dark!
10:49:59 <shapr> hoe gaat?
10:50:00 <dark> hallo :)
10:50:05 <Igloo> There is movement on a Haskell crypto library
10:50:28 <shapr> I'll mention Fractal's haskell-libs code
10:50:42 <dark> Gaat slecht: collect2: ld terminated with signal 11 [Segmentation fault], core dumped
10:50:53 <shapr> ouch
10:51:15 <dark> binutils is broken.
10:51:40 <ibid> hm, would i dare post the url to my paper here? probably not :-) (i'd be eaten alive probably)
10:52:10 * shapr pretends to be a piranha
10:52:18 <dark> Eaten alive?  I don't think we have ibidivores here.
10:52:37 <shapr> :-)
10:52:49 <Smerdyakov> There is the void which consumes all.
10:52:55 <Smerdyakov> But it's on holiday at the moment.
10:53:21 <dark> If the void consumes you, you will also consume the void.
10:53:34 <Smerdyakov> That was last year's model. They have that fixed now.
10:53:48 * shapr takes a fork to the void
10:53:51 <shapr> I'm hungry
10:54:01 <dark> forking the void is probably extremely dangerous.
10:54:19 <shapr> dark: hey, I've come up with name for my spam filter.... Paskalle
10:54:35 <dark> shapr: Inspired by finnish?
10:54:39 <shapr> yes, exactly
10:54:43 <Smerdyakov> What does it mean?
10:54:55 <shapr> you'll have to ask a finnish person to translate for you ;-)
10:55:02 <shapr> Smerdyakov: you were being huffy, so you missed :-P
10:55:09 * shapr snickers
10:55:16 <Smerdyakov> I think a currently unused name of a gatekeeper from mythology would be better.
10:55:27 <shapr> hm
10:55:59 <Smerdyakov> Or "The Smart Shredder"!
10:56:52 <ibid> 20:44:11 <ibid> shapr: paskalle is literally "[go] to feces" (actually, paska is more vulgar, closer to sh*t), idiomatically, "[go] take a dump"
10:56:58 <ibid> (from the logs)
10:57:07 <shapr> Smerdyakov: see? isn't that much more fun?
10:57:22 <Smerdyakov> No.
10:57:27 * shapr cackles happily
10:57:34 <Smerdyakov> It has nothing to do with what it names.
10:57:45 <dark> It doesn't imply much discrimination :)  I wouldn't want all my mail to go paskalle.
10:57:54 <shapr> sure it does, it takes the dump out of your email.
11:00:49 <shapr> I'll just say it's a combination of Pascal and Haskell in the docs :-P
11:00:50 <ibid> (http://www.mit.jyu.fi/antkaij/tmp/splst03.pdf - don't kill me:)
11:01:21 <shapr> y0 Vincenz 
11:01:31 * Marvin-- nibbles a bit on ibid's leg
11:02:15 * shapr winds up the vampire fish
11:02:15 <dark> shapr: What's the Pascal angle?
11:02:15 <shapr> Pascal + Haskell = Paskalle
11:02:20 <dark> Yeah but did you write any part of it in Pascal?
11:02:22 <shapr> oh, you mean how does Pascal fit into spam filtering?
11:02:32 <shapr> I haven't figured that out yet...
11:02:52 <Vincenz> hiya shapr :)
11:02:58 <shapr> I was thinking Blaise Pascal
11:03:20 <Marvin--> ibid: it looks kinda weird that you say "Section 2", "Section 3", "Section 4" and then "Sect. 5" :)
11:03:50 <ibid> Marvin--: blame springer :-)
11:04:10 <ibid> Marvin--: Section should be abbreviated, except when it is the first word of a sentence
11:07:20 <ibid> (they require submissions to be in springer format, though it won't probably be published by springer)
11:07:21 <Marvin--> ibid: ah
11:07:21 <ibid> was somebody here from chalmers?
11:07:23 <Marvin--> "here" as in #haskell?
11:07:36 <ibid> for example :-)
11:07:51 <Marvin--> I'm formally at Göteborg University, but it makes little difference in practice
11:29:06 <ustenzel> When i'm interfacing with c libraries, is there any tool that can easily import constants or defines from a header file into haskell world?
11:32:00 <ibid> (okay, you may wound me;-)
12:03:55 <Riastradh> *PONG*
12:04:15 <ibid> i was just wondering if i have a huge lag
12:05:26 <mgoetze>  /ctcp ibid kill
12:09:47 <ibid> (i did, you know, a short while ago)
12:16:34 <shapr> oy
12:34:50 <shapr> hi whee 
12:35:43 <whee> hola
12:35:46 <shapr> wassup?
12:36:10 <whee> absolutely nothing 
12:36:21 <shapr> haven't seen you inna while, where ya been hiding?
12:37:22 <whee> just getting bogged down with work :|
12:37:30 <shapr> what do you do for a living?
12:37:39 <whee> absolutely nothing :)
12:37:45 <whee> work being college, heh
12:37:51 <shapr> heh
12:38:03 <shapr> writing any fun code lately?
12:38:14 <whee> nope :|
12:38:18 <shapr> that sucks
12:38:26 <whee> trying to get back into doing objc work for fun
12:38:29 <shapr> ah
12:38:32 <Riastradh> Mmm, Objective-C.
12:38:48 <shapr> I think o3 is doing an objc binding for Haskell
12:39:10 <whee> I can't think of a project to start, though
12:39:12 <Riastradh> If you worked at Akamai and on their 'FirstPoint' product, you could be working on turning badly designed Perl and C++ things into much better-designed Objective-C things.
12:39:13 <whee> that's always my main problem
12:39:28 * esap has too many projects to actually finish any of them :-)
12:39:34 <shapr> well, if you were looking to do haskell I'd recruit for one of several haskell-libs projects.
12:40:00 <shapr> lambdabot, Paskelle, and the general email libs
12:41:05 * esap suggests developing a decent architectural model.
12:41:12 <shapr> ?
12:41:39 <whee> I'd be most interested with lambdabot, but I really would hate doing coding in haskell for irc :)
12:41:56 <Riastradh> Why's that?
12:42:03 <shapr> yah, why?
12:42:32 <whee> mainly it seems like a lot of monad things that I don't understand, and I don't look forward to dealing with concurrency in haskell
12:43:09 <shapr> ime, the best way to learn about the monad things is to poke them till they give up their secrets, aka use them till you understand
12:43:26 <shapr> lambdabot is multithreaded already
12:43:29 <dark> Didn't work for me.  I know how to use them now, but not how they work :-)
12:43:45 <shapr> though the plugin calls don't happen in their own thread, I think that will happen soon.
12:43:59 <esap> I learned monads by writing a monadic parser combinator library. I wouldn't recommend that though, it's a lot of hard work.
12:44:02 <shapr> right now it's only two threads, a reader and a writer
12:44:26 <dark> Probably the only way to get that level of understanding would be for me to write my own, without just wrapping an existing monad.
12:44:39 <shapr> the read and write ends of the socket are wrapped in 'channels' which are concurrent safe FIFOs (and I don't understand much more about it)
12:45:11 <whee> heh
12:45:35 <shapr> the overall structure is a puzzle wrapped in an enigma, wrapped in a nice plain brown wrapper
12:45:48 <esap> FIFOs are actually quite complicated beasts.
12:45:57 <shapr> er, I mean, a reader monad transformer wrapped inside a state monad transformer
12:46:21 <shapr> in short, it turns a Haskell record into a state monad. tada
12:47:00 <shapr> whee: now wasn't that easy?
12:47:14 <whee> no :P
12:47:46 <shapr> writing a plugin is easy
12:47:50 <shapr> @hello
12:47:50 <lambdabot> Hello world. 
12:47:59 <Riastradh> newtype MyModule = MyModule ()
12:48:02 <Riastradh> myModule = MyModule ()
12:48:07 <Riastradh> instance Module MyModule where
12:48:13 <Riastradh>     moduleName m = "myModule"
12:48:17 <Riastradh>     moduleSticky m = False
12:48:28 <Riastradh>     commands m = ["myModuleCommand", ...]
12:48:46 <Riastradh>       process ... -- see how to write the process function in the Hello, World module.
12:48:52 <shapr> http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/lambdabot/HelloModule.hs
12:49:33 <shapr> whee: is that easier?
12:50:01 <Riastradh> See the state module for how to maintain a module's state.
12:50:03 <Riastradh> @state foo
12:50:03 <lambdabot> nothing yet
12:50:06 <Riastradh> @state bar
12:50:07 <lambdabot> foo
12:50:09 <Riastradh> @state baz
12:50:09 <lambdabot> bar
12:50:16 <Riastradh> Or the karma module.
12:50:18 <Riastradh> @karma shapr
12:50:18 <lambdabot> shapr has a karma of 0
12:50:21 <Riastradh> @karma+ shapr
12:50:22 <lambdabot> shapr's karma has been incremented.
12:50:24 <Riastradh> @karma shapr
12:50:24 <lambdabot> shapr has a karma of 1
12:50:35 <whee> uh, heh
12:50:38 <shapr> @listmodules
12:50:39 <lambdabot> I have the following modules installed: ["eval","fact","fortune","hello","karma","more","searchml","state","system","topic","type","yow"]
12:50:49 <whee> karma is incredibly confusing :|
12:51:06 <whee> seems like a lot of work to maintain some sort of state
12:51:29 <shapr> we need to factor out some state accessors, as suggested by Darius
12:52:11 <shapr> the state module is a demo of per-module state
12:53:49 <whee> I don't know, I don't think I can get the hang of any of that quick enough for my liking heh
12:53:55 <shapr> ok
12:54:53 <shapr> whee: we need a @help module
12:55:08 <shapr> what about an @uptime plugin?
12:56:47 <shapr> @yow
12:56:47 <lambdabot> Let's climb to the TOP of that MOUNTAIN and think about STRIP MINING!!
12:56:56 <shapr> silly 'bot
12:57:05 <shapr> @fortune
12:57:05 <lambdabot> Time is fluid ... like a river with currents, eddies, backwash.
12:57:05 <lambdabot> 		-- Spock, "The City on the Edge of Forever", stardate 3134.0
12:58:49 * shapr tries to figure out GetOpt
12:59:33 <Marvin--> shapr: what's to figure out?
12:59:59 <shapr> I have flags, and functions to run if those flags are present
13:00:13 <shapr> just trying to sew it together from reading the Haddock sources
13:06:14 <SyntaxPolice> shapr: when you figure something out, maybe you should append an example or two to the Haddock sources :-)
13:06:24 <SyntaxPolice> or post a diff to the hakell-libs list.
13:06:44 <shapr> at the moment I'm thinking of putting Haddock through a shredder and writing something myself
13:10:13 <hdaume> shapr: i posted sopmeting about getopt to the mailing list a few weeks ago you might find helpful
13:10:25 <shapr> @searchml getopt
13:10:48 <shapr> I really gotta make that FM persistent :-/
13:10:58 <hdaume> its on libraries@haskell.org from 18 feb
13:11:01 <shapr> ah, ok
13:11:07 <hdaume> "getOpt overly abitious" or something it the subject
13:11:16 <hdaume> ambiguous, even
13:12:01 <shapr> oh, that's nice
13:12:05 <shapr> hdaume: thanks!
13:12:09 <hdaume> np
13:12:26 <shapr> that should be the example code for GetOpt
13:12:38 <hdaume> :)
13:12:55 <shapr> SyntaxPolice: I'd already have written a HaddockPlugin for lambdabot if I could get it to load into ghci
13:13:12 <shapr> has anyone tried to load FastMutInt.hs into ghci 5.04.3 ?
13:13:16 <shapr> it craps out with .2
13:13:34 <shapr> hey, does 5.04.3 have mdo?
13:13:35 <SyntaxPolice> shapr: what do you have against haddock?
13:13:42 <shapr> it's the smell ;-)
13:13:55 <shapr> just FastMutInt actually
13:14:09 <lambdabot> 1004 1002 1001
13:14:12 <shapr> yay
13:14:20 <shapr> happy 'bot
13:14:57 <shapr> @searchml whee
13:15:05 <shapr> @hello
13:15:06 <lambdabot> Hello world. 
13:15:08 * shapr shrugs
13:26:18 <mgoetze> @fortune
13:26:19 <lambdabot> <doogie_> linux takes shit and turns it into something useful.
13:26:19 <lambdabot> <doogie_> windows takes something useful and turns it into shit
13:26:33 <mgoetze> hm
13:26:37 <shapr> ?
13:26:58 <ludde> i like windows
13:26:58 <mgoetze>  /vmlinuz | /mnt/win/windows/win.exe
13:27:59 <shapr> time for TV, bbl
14:48:50 * shapr boings
14:54:18 <mgoetze> hi shapr
14:54:21 <mgoetze> shapr: your nick sounds like you know about traffic shaping. can you help me? :)
14:57:44 <Igloo> lol
15:01:59 <funktor> so, next is alpha-beta pruning
15:02:29 <shapr> mgoetze: I don't actually
15:02:40 <shapr> mgoetze: the real solution is to use IPv6, since it has real QoS
15:02:55 <shapr> y0 funktor 
15:03:05 <funktor> yo
15:03:18 <shapr> do you have 'net access from your laptop? can I see the code? =)
15:03:21 <funktor> bestMove :: Colour -> Board -> MoveInFull
15:03:30 <shapr> nifty!
15:03:32 <mgoetze> shapr: i'm trying to reduce latency, and you're telling me the solution is to use ipv6, which means a tunnel with a minimum added latency of 200ms or something? :P
15:03:33 <funktor> works fine now, I just need to tell it about checkmate
15:03:45 <shapr> mgoetze: nah, run IPv6 natively :-)
15:03:54 <mgoetze> shapr: oh sure, and how would i do that? :)
15:04:00 <shapr> the linked list headers of IPv6 are awesome
15:04:14 <shapr> where do you want to reduce latency?
15:04:58 <mgoetze> i want to reduce the latency of my interactive sessions such as ssh when my upstream bw is saturated
15:05:14 <shapr> bw?
15:05:18 <mgoetze> problems include a dsl modem with a big queue and similar problems
15:05:20 <mgoetze> bandwidth
15:05:21 <shapr> oh
15:05:48 <shapr> yes, you want traffic shaping :-)
15:05:58 <shapr> no, I don't know how to use it.
15:06:25 <shapr> I've read about a few of the ways of hooking up to the prioritizer, but all the IPv4 stuff is ugly hacks
15:07:30 <mgoetze> i was planning to use iptables to mark packets with the priority i want them to have and sort them into a PRIO queue accordingly - how is that an ugly hack? :)
15:08:18 <shapr> IPv4 does have some priority support, you probably know the URGent flag
15:08:27 <mgoetze> isn't that TCP?
15:08:31 <shapr> er
15:08:45 <mgoetze> IPv4 has TOS or, more recently, DiffServ
15:08:57 <shapr> oooh, what's that? :-)
15:09:09 <mgoetze> but really, i couldn't care less about that, i just want this to work :)
15:09:43 <shapr> I really hope ipv6 becomes the 'real' standard pretty soon.
15:10:08 <shapr> as nicely as ipv4 has treated me, I'm getting tired of it
15:10:50 <mgoetze> yes, well, that's all fine and well, but it doesn't help me atm at all
15:10:56 <shapr> truly :-/
15:12:40 <mgoetze> now everyone, do me a favour and never ever write crap nondocumentation such as this:
15:12:43 <mgoetze> Usage: ... fw [ classid CLASSID ] [ police POLICE_SPEC ]
15:12:43 <mgoetze>        POLICE_SPEC := ... look at TBF
15:12:43 <mgoetze>        CLASSID := X:Y
15:16:56 <shapr> hi Darius 
15:23:57 <shapr> hi Kuril 
15:31:11 <shapr> crap
15:31:21 <shapr> DMCA strikes honeyd - http://niels.xtdnet.nl/honeyd/
15:31:54 <shapr> at the rate the DMCA is hitting the world governments, I need to change professions.
15:35:22 <shapr> oh no, nethack-el has become a debian package
15:35:29 <Riastradh> Grumbling about it does no good.  People who are against the DMCA need to come up against it in unison and with force.
15:35:29 <shapr> watch my productivity drop into the toilet
15:35:33 <Riastradh> Heheh.
15:35:35 <shapr> Riastradh: how?
15:36:16 <Riastradh> shapr - First the unison bit has to come about.  Get a bunch of people who are against it together, then, with all those heads together, surely you can think up ways to fight the DMCA and get a bigger unison.
15:38:09 <shapr> that's true
15:38:13 <Riastradh> It might sound idealistic and stuff, but seriously, what else can you do?  A bunch of single people against it will be brushed off lightly.
15:38:20 <shapr> you're right
15:38:29 <shapr> ok, where do I join up?
15:38:41 <Riastradh> Google is a good place to start, probably.
15:40:12 <Riastradh> eff.org is also probably a good place to look.
15:58:58 <shapr> crap, I need a MIME parser
16:00:39 <Riastradh> Well, go write one!
16:02:24 <Riastradh> It can't be that difficult, can it?
16:02:56 <shapr> I don't know, I've never tried it.
16:03:23 <Riastradh> RTF...RFC, is it?
16:51:09 <shapr> hi Pseudonym
16:58:47 <Pseudonym> G'day.
16:59:15 <shapr> what's up?
17:00:12 <Pseudonym> Not much.
17:00:29 <Pseudonym> Let's think... got my QLR parser generator working.
17:00:35 <shapr> cool
17:00:41 <Pseudonym> I'm thinking I might hack happy.
17:00:45 <shapr> for what?
17:00:54 <Pseudonym> Update it to use LALR(1) instead of SLR(1).
17:00:57 <shapr> oh
17:01:11 <Pseudonym> That will make it accept the same class of languages as yacc/bison/etc.
17:01:37 <shapr> neat!
17:01:47 <shapr> I could use that for a future lojban parser.
17:02:03 <Pseudonym> Does happy not accept lojban?
17:02:39 <Pseudonym> Oh dear.
17:02:42 <shapr> I haven't tried yet, but the lojban grammar claims it stretches yacc
17:02:46 * Pseudonym nods
17:02:57 <Pseudonym> You might do better with FROWN.
17:02:58 <shapr> I think the grammar relies on backtracking in some unusual ways.
17:03:04 <shapr> what's that?
17:03:19 <Pseudonym> Uhm...
17:03:28 <Pseudonym> Here's the talk on it: http://www.informatik.uni-bonn.de/~ralf/talks/Frown.pdf
17:03:31 <Pseudonym> Can't find any code, though.
17:03:58 <shapr> whoa, joint work with patterson and swierstra
17:04:00 <shapr> I'm scared already.
17:06:33 <shapr> it seems that Generic Haskell has some connection or use of frown
17:07:43 <shapr> I can't find any code either.
17:08:19 <Pseudonym> Well there's also my QLR parser generator. :-)
17:08:25 <Pseudonym> It's nondeterministic at the moment.
17:10:43 <shapr> generic haskell is a frown spec
17:10:50 <shapr> so someone has used it at some point.
17:17:03 <shapr> has anyone here tried darcs yet?
17:19:37 <Darius> you may also want to check out http://www.pdos.lcs.mit.edu/~baford/packrat/thesis/ for your lojban parser
17:20:15 <shapr> cool! thanks!
17:21:06 <shapr> wow, it includes java parsers
17:21:25 <shapr> coool, he tested with cryptix
17:24:11 <Darius> Java parsers are easy... at least compared to C++ parsers (of course, most anything is easy compared to parsing C++)
17:24:28 <Pseudonym> C++ is inherently ambiguous.
17:24:37 <Pseudonym> Whole companies exist who just write C++ parsers.
17:27:18 <Smerdyakov> I thought it was just 1/8 companies.
17:37:54 <shapr> oy
17:38:08 <shapr> my spam filter is not very good :-(
17:46:51 <shapr> hi flippo 
18:04:01 * shapr survives hours of reading c.l.f
18:04:04 <shapr> yay
18:05:22 <Darius> hours?
18:09:19 * shapr boings
18:09:34 <shapr> Darius: yah, I've been ignoring c.l.f for weeks
18:10:02 <shapr> I think that ALIEN guy is pretty funny.
18:12:35 <Darius> Most people that know enough to know what Haskell is usually know enough to poke at some of it's real problems
18:12:46 <shapr> yup
18:12:56 <shapr> what do you consider its real problems?
18:13:29 <shapr> I think I'd complain about the slow, memory hogging [Char]
18:13:41 <shapr> but I really do like dealing with strings as lists of Char
18:14:16 <Darius> The easiest and probably most important one is figuring out space-usage.
18:14:59 <shapr> like that single $! you came up with that fixed my mailing list code?
18:15:15 <Darius> That's related
18:15:42 <Darius> I believe it's Simon PJ that isn't too much a fan of lazy IO
18:16:15 <shapr> I haven't used it enough to have an opinion
18:16:29 <Darius> (Eager Haskell may be one solution to both of these problems)
18:16:40 <shapr> I really do enjoy laziness
18:16:50 <lowks_> Eager Haskell
18:17:08 <Pseudonym> Lazy evaluation also gets you better GC performance, I've found.
18:17:33 <Pseudonym> Because objects are consumed right after they're created, generational GC is pretty much optimal.
18:18:04 <Igloo> Lazy evaluation can also lead to space explosion, though...
18:18:07 <shapr> I've just committed the Paskelle prototype to haskell-libs
18:18:23 <Pseudonym> That's true, however I've never met a programmer who didn't roughly know the lifetimes of their data.
18:18:38 <Pseudonym> Short-lived data should be lazy, long-lived data should be strict.
18:19:01 <Pseudonym> You don't need to know it _exactly_, of course.
18:19:05 <shapr> if anyone has the urge to look at the code and make suggestions, I'd like to hear them.
18:20:58 <Igloo> I often don't realise the lifetime of some of my data before I profile
18:21:15 <Igloo> In fact, GHC has profiling modes dedicated purely to helping you work out the lifetime of your data, so I guess I'm not alone
18:21:50 <Igloo> Lazy evaluation can really surprise you
18:28:46 <Darius> My opinion on the matter is that it seems easier, more maintainable, and more modular to put a few seq's (admittedly a few _well-placed_ seq's and using the Strategies library when useful) which are identity funtions for the most part in a lazy language, than to restructure your eager code to get the same effect or even to use laziness primitives.  However, for this to be meaningful there have to be enough instances where 
18:30:06 <Darius> (combined with laziness not being to bad where it isn't really used)
18:50:33 * shapr yawns
19:24:01 <Pseudonym> That and a few well-placed !'s on your data structures.
19:24:35 <Pseudonym> Igloo: I agree with you there.  Lifetimes are often non-obvious in advance.
19:24:43 <Pseudonym> In retrospect, though, I find they often are.
19:26:00 <Igloo> Ah, yes, there's always that "Of *course* the entire 16GB will need to be in memory simultaneously if I do that!" moment once you realise what's going on  :-)
19:26:10 * Pseudonym laughs
19:26:51 <Pseudonym> I will say one thing, though: I think that most programmers know what data they _intend_ to be long-lived.
19:27:21 <Pseudonym> A discrepancy between programmer intention and compiler inference is a bug.
19:27:33 <Pseudonym> Either the program or the intention must be changed.
19:28:55 <shapr> what's the flag? -fno-main?
19:36:14 <shapr> aha
19:37:09 <shapr> wheee
19:39:15 * shapr bounces
19:39:17 <shapr> @yow
19:39:18 <lambdabot> It's OBVIOUS..  The FURS never reached ISTANBUL..  You were
19:39:18 <lambdabot>  an EXTRA in the REMAKE of ``TOPKAPI''..  Go home to your
19:39:18 <lambdabot>  WIFE..  She's making FRENCH TOAST!
19:39:44 * shapr waits for profiling data from GHC
19:39:44 <flippo> zippy lives
19:39:50 <shapr> yes, zippy my hero
19:39:54 <shapr> my spam filter sucks
19:40:05 <shapr> maybe it'll work better after I've implemented all the rules from PG
19:41:03 <flippo> Good old Paul.  He had a heavily linked essay the other day.
19:41:19 <shapr> yah, hundred
19:41:25 <shapr> It sounded like Haskell to me.
19:41:40 <flippo> Except he doesn't believe in statically typed languages
19:41:52 <shapr> flippo: the spam filter is in the CVS tree of haskell-libs if you want to look at it.
19:42:24 <flippo> shapr: sorry my energy is spent.  All day I slaved over complicated numerical code.
19:43:18 <shapr> flippo: have you tried Hudak?
19:43:20 <flippo> Paul Graham: "static typing seems to preclude true macros-- without which, in my opinion, no language is worth using."
19:43:35 <shapr> I'll send him an email when Template Haskell is released.
19:43:36 <flippo> shapr: no, I was too annoyed at the use of graphics.  Very annoyed.
19:43:43 <shapr> :-(
19:44:58 <flippo> I shouldn't be in this channel at the moment.  Even though Haskell is still my favorite language, I don't use it or even play with it at the moment.
19:45:38 <shapr> write a lambdabot plugin!
19:45:46 <shapr> that doesn't require a book :-)
19:46:13 <flippo> At the moment, I'm doing numerical code that could have been written in C or even Fortran
19:46:41 <flippo> By the end of the day, my mind is gone from tracking indices and loop limits
19:47:10 <flippo> Yet, it is useful, so I must go on
19:47:15 <shapr> @hello
19:47:16 <lambdabot> Hello world. 
19:47:21 <flippo> @yow
19:47:21 <lambdabot> Somewhere in DOWNTOWN BURBANK a prostitute is OVERCOOKING a LAMB CHOP!!
19:47:38 <flippo> I love old Zippy
19:47:57 * shapr tries to get flippo addicted
19:48:02 <shapr> just look at the code ;-)
19:48:02 <shapr> http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/lambdabot/HelloModule.hs
19:48:05 <shapr> it's so simple...
19:48:09 <shapr> so easy to understand
19:48:10 <flippo> Okay, you pusher you
19:48:13 * shapr laughs
19:48:58 <shapr> fourteen lines, three of which are blank, and one is a comment
19:49:01 <shapr> ten lines of actual code
19:49:13 <shapr> it's soooo simple
19:49:25 <flippo> I don't understand the process line
19:49:26 * shapr swings a shiny bit of code back and forth
19:49:48 <shapr> process is one of the methods of the Module typeclass
19:49:52 <shapr> when the module is called
19:50:01 <shapr> the process method is what does everything
19:50:27 <flippo> What is a sticky module?
19:50:34 <shapr> it receives as parameters, the module itself, the target (channel or person if it's a privmsg), the cmd, and everything after the command
19:50:44 <shapr> a sticky module is one that shouldn't be unloaded once it's loaded.
19:50:49 <shapr> not currently used
19:50:57 <shapr> will be once we switch to runtime loadable modules
19:51:23 <shapr> @fact author
19:51:24 <lambdabot>  Andrew Bromage aka Pseudonym
19:51:47 * shapr watches the shiny bit of code
19:51:52 * shapr is getting verrrry sleeeepy
19:52:02 <flippo> ooh, it's so shiny
19:52:31 <shapr> you're going back to your childhood... you're reliving your assembly language days...
19:52:32 <flippo> What's this?  target ("Hello world. " ++ rest)
19:52:42 <shapr> @hello We are receiving you.
19:52:43 <lambdabot> Hello world. We are receiving you.
19:52:56 <Smerdyakov> @type 1
19:52:57 <lambdabot> 1 :: Num a => a
19:52:59 <shapr> hello is the command
19:53:04 <shapr> everything after the command is "rest"
19:53:11 <Smerdyakov> @type \x.x
19:53:11 <flippo> got it
19:53:18 <Smerdyakov> @type \x -> x
19:53:19 <lambdabot> \x -> x :: a -> a
19:53:20 <shapr> @type faster silly bot
19:53:55 * shapr wants to barbecue lambdachops
19:55:14 <shapr> flippo: the state module is an example of saving per-module state
19:55:47 <shapr> Hello and State are demos, designed to be hammered into real modules.
19:56:32 <shapr> flippo: what about a @time module? something that just shows the current system time?
19:57:07 <flippo> shapr: I'm barely conscious.  Please have mercy.
19:57:10 <shapr> heh
19:57:24 <shapr> ok, I'll go off to sleep
19:57:38 <flippo> shapr: thanks for making the effort though.
19:57:42 <shapr> :-)
19:57:45 <flippo> shapr: looks like fun
19:58:01 <shapr> I think a @time plugin would be just a simple extension of the @hello plugin....
19:58:06 <flippo> shapr: I'll gather up my scraps of strength and enthusiasm eventually
19:58:17 <shapr> great, I'm looking forward to it.
19:58:47 <shapr> now, time for sleep
19:58:48 <shapr> @fact g'nite
19:58:49 <lambdabot> zzzz
20:58:57 <flippo> @yow
20:58:58 <lambdabot> Yow!  I just went below the poverty line!
21:02:58 <debug> good morning world
21:05:30 <Pseudonym> Morning, if that's what it is there.
21:07:01 <Pseudonym> pushd
21:07:03 <Pseudonym> Oops.
21:09:38 <mgoetze> yeah, i think it's morning. maybe i should turn off the lights....
21:10:10 <debug> it will be a wonderful day
