00:22:29 <andersca> morning Marvin--
00:29:03 <Marvin--> morning
00:39:25 * Marvin-- swears over unique naming
00:42:59 <mgoetze> good morning, Marvin-- 
00:44:56 <Marvin--> I wonder if this is enough...
01:31:18 <Marvin--> how the heck would I prove this *boggles*
02:24:37 <Marvin--> wohoo, sushi for lunch today
02:25:39 <shapr> goood morning #haskell!
02:27:18 <shapr> hi Chilli!
02:27:23 * shapr boings
02:27:33 <shapr> Marvin--: oh, go for unique swearing instead
02:31:06 <shapr> hi carol__
02:35:07 <delYsid> morning
02:35:13 <shapr> y0 delYsid 
02:35:58 <delYsid> y0 shapr 
02:36:02 <delYsid> wassup?
02:36:28 <shapr> just reading various Haskell emails
02:37:14 <shapr> hey, if switch the Board to an Array, you can optimize to an ST Array
02:38:14 <shapr> ST Arrays are like IORefs from what I've read, they can be changed in-place
02:38:39 <shapr> but for safety reasons, you're only supposed to do it in places where it's identical to replacing an immutable array
02:41:54 <mgoetze> gmornin shapr
02:43:18 <shapr> hi mgoetze
02:43:51 * shapr yawns
02:54:28 <shapr> delYsid: have you gotten to the point of profiling a Board that's an array?
03:07:47 <shapr> so, anything exciting happening today?
03:08:31 <opet> I woke up!!!
03:08:40 <opet> oh, wait.. I do that every day
03:12:58 <shapr> is that an exciting happening?
03:15:36 <opet> not really
03:15:48 <shapr> it's better than sleeping all day
03:15:48 <opet> I should get dressed though
03:22:04 <shapr> oh hey, I can contribute at least three bits to the haskell communities report
03:23:03 <shapr> #haskell, haskell-libs, and I can advertise my company as one of those "will write Haskell for money"
03:25:36 <shapr> nifty
03:37:46 <shapr> actually, my haskillz probably aren't up to real commercial development yet.
03:37:49 <shapr> I must learn more.
03:54:04 <shapr> gutentag kosmikus 
03:54:08 <shapr> wie geht es?
03:54:14 * shapr pretends to know deustch
03:54:34 <kosmikus> danke, gut, und Dir?
03:54:47 <shapr> um
03:54:48 <shapr> gut :-)
03:55:01 * kosmikus is impressed
03:55:13 <Segora> re
03:55:16 <shapr> ich habbe keine ahnung ;-)
03:55:30 <shapr> and I'm sure my spelling is terrible
03:55:31 <Segora> shapr: das sage ich auch immer *g*
03:55:48 <shapr> my woman comes from Saarbrucken
03:56:02 <Segora> shapr: (well, if you call one letter off terrible spelling ;)
03:56:10 <shapr> what did I miss?
03:56:13 <Segora> habe
03:56:18 <shapr> ah, thanks
03:56:20 <kosmikus> yes, actually, your spelling is quite okay
03:56:24 <shapr> spiffy!
03:56:43 <shapr> kosmikus: I know you told me which part of .de you're from before, but I've forgotten...
03:58:21 <kosmikus> not so easy: born in Luebeck, went to university in Konstanz; the former is north of Hamburg, the latter is close to the Swiss border ...
03:58:29 <shapr> oh, nifty
03:58:47 <shapr> so, is everyone going to submit something about their current projects to the Haskell Communities and Activities report?
03:59:10 <kosmikus> well, I hope that my supervisor does ...
04:00:02 <shapr> I'm going to mention this lovely #haskell irc channel, and give a summary of the code in the haskell-libs sourceforge project.
04:00:36 <shapr> kosmikus: world domination is at hand!
04:00:56 <shapr> well, maybe a little further off
04:01:30 <shapr> Segora: are you working on a project in
04:01:32 <shapr> Haskell?
04:01:44 <Segora> shapr: not right now. erlang.
04:01:54 <shapr> ah, nice language.
04:02:02 <Segora> yes. and OTP is a nice platform.
04:02:18 <shapr> I hope Haskell gets to that level of network transparency
04:02:28 <HannahS> Hi!
04:02:30 <shapr> hi HannahS 
04:02:53 <shapr> HannahS: how may we assist you?
04:03:04 <HannahS> No need.
04:03:11 <HannahS> I'm sitting in the same room as Segora.
04:03:15 <shapr> oh, cool
04:03:21 <shapr> do you both use Haskell?
04:03:22 <HannahS> And I've seen you asked him for anything he's doing w/ Haskell.
04:03:30 <HannahS> I've already done a few bits in Haskell.
04:03:32 <HannahS> But not currently.
04:03:48 <shapr> What sort of stuff have you done?
04:03:59 <HannahS> Now I'm down in the swamps of C++, alas.
04:04:11 <HannahS> I've done something to simulate network packet losses and latencies.
04:04:20 <shapr> in Haskell?
04:04:22 <shapr> that sounds very nifty
04:04:23 <HannahS> With bindings to bpf and tun.
04:04:25 <HannahS> Yep.
04:04:26 <shapr> is the source online?
04:04:30 <HannahS> no.
04:04:35 <opet> like dummynet?
04:04:38 <HannahS> It was for the company here.
04:04:44 <shapr> oh, it's commercial software
04:04:50 <HannahS> No, internal use soft.
04:04:50 <shapr> cool! you've done Haskell for-pay then?
04:04:56 <HannahS> A LITTLE bit.
04:05:02 <shapr> more than I have :-)
04:05:09 <HannahS> Another thing was some performance tester for a jserv installation here.
04:05:25 <shapr> I'm self-employed, I hope to turn my company towards doing Haskell code.
04:05:35 <HannahS> Something like "fetch a few pages from the jserv, use the session ID from a HTTP redirect as soon as you can decode it, and fetch sub-frames, too"
04:05:49 <shapr> that's nifty, did you use the HTTP.hs module?
04:05:52 <shapr> or did you write your own?
04:05:53 <HannahS> Having a HTML parser in the GHC libs definitively has helped.
04:06:04 <HannahS> No, IIRC back then, there was no HTTP module yet. Or I didn't know it.
04:06:12 <HannahS> But the HTML parser was very useful.
04:06:25 <shapr> could you release any of the code you've written under an open source license?
04:06:29 <HannahS> It'd have been annoying if I'd have had to do *that* myself.
04:06:32 <HannahS> Dunno.
04:06:44 <HannahS> I'm not the ideal social engineering woman...
04:06:44 <shapr> I'd love to get it into the haskell-libs sourceforge project, it sounds like useful code.
04:06:47 <shapr> :-)
04:06:52 * shapr grins
04:07:14 * shapr considers quoting that
04:08:10 <shapr> if you do get permission to release your code under an OSS compatible license, I'd be happy to put it into the cvs tree of haskell-libs
04:08:26 <shapr> I'm always looking for new libraries and applications.
04:08:50 <HannahS> Hmmm.
04:09:01 <HannahS> Let's try. *switch to mail program*
04:09:15 <seth_> What is the syntax for loading a package into ghci?
04:09:15 <HannahS> I can't guarantee that the things compile with the current GHC, though.
04:09:22 <HannahS> I've done them with some 4.xx version.
04:09:35 <shapr> HannahS: that's ok, I can probably update them myself
04:09:46 <shapr> seth_: if it's a file, :load <filename>
04:10:09 <shapr> seth_: if you want to add a module to the loaded modules, use ":m Data.FiniteMap"
04:10:14 <kosmikus> :set -package xyz
04:10:31 <shapr> good point, sometimes you need to set a -package to use certain modules.
04:10:35 <seth_> so for GHC.Read, I would do  :set -package GHC.Read
04:11:02 <shapr> nah, that's a module
04:11:10 <shapr> :m GHC.Read
04:11:31 <shapr> then your ghci prompt should add GHC.Read to the prompt, showing you it's loaded.
04:11:37 <seth_> shapr: thanks.  the message is confusing  "GHC.Read is a package module"
04:11:41 <shapr> oh
04:11:44 * shapr tries
04:11:57 <seth_> :m works
04:12:06 <kosmikus> that happens if you try to load the module and the module is already in a package that you have loaded. 
04:12:14 <kosmikus> then :m works ...
04:12:26 <seth_> ok, thanks kosmikus & shapr
04:12:34 <shapr> sure, any other questions?
04:13:05 <seth_> lots.  I've been doing ocaml for the past two weeks and I have to refamiliarize with haskell
04:13:26 <shapr> fire away
04:13:27 <seth_> where in the docs do I find string functions?  I find the string type in Char, but no functions
04:13:46 <HannahS> seth_: Strings are just lists of Char.
04:13:46 <shapr> a String is actually a list of type Char
04:13:47 <kosmikus> you can use list functions for strings
04:14:02 <HannahS> In contrast to ocaml, where they are a separate type.
04:14:13 <seth_> ok, but there must be things built in.  e.g., how do I convert "123" to an Int?
04:14:24 <shapr> I'd use read :: Int
04:14:42 <shapr> Prelude GHC.Read> (read "123") :: Int
04:14:42 <shapr> 123
04:14:56 <shapr> @type read
04:14:56 <lambdabot> read :: Read a => String -> a
04:15:00 <seth_> ah, thanks.  So that's in the haddock page for GHC.Read
04:15:41 <seth_> now, suppose I load GHC.Read, and then I load another module.  In ghci, how do I refer to the GHC.Read method?
04:15:46 <seth_> when it isn't the current module?
04:16:33 <shapr> if you've imported GHC.Read into the module you're editing, all the functions exported from GHC.Read are now in your current module
04:16:48 <seth_> so no prefix is required.
04:17:11 <seth_> when I do (read "123") (at Prelude GHC.read>), I get Ambiguous type variable(s) `a' in the constraint `Show a'  etc.
04:17:16 <shapr> I think you can use "qualified" or "as" to force a prefix
04:17:30 <kosmikus> yes, the :: Int is important ...
04:17:33 <shapr> that's because read doesn't know what type you want
04:17:51 <shapr> it could be an Integer, a Float, a Int, a Double
04:17:54 <seth_> oh, ok, so I have to be explicit because, well, it told me, (read "xxx") is ambiguous
04:18:26 <shapr> yes
04:18:33 <HannahS> Oh, that lambdabot is cool *g*
04:18:48 <shapr> HannahS: lots of cool plugins in lambdabot 
04:18:54 <shapr> we got a new one yesterday
04:18:59 <shapr> @listcommands chess
04:18:59 <lambdabot> Module chess provides the following commands: ["ply","reset-chess","validmoves","board"]
04:19:05 <shapr> @listmodules
04:19:05 <lambdabot> I have the following modules installed: ["chess","eval","fact","fortune","hello","karma","more","searchml","state","system","topic","type","yow"]
04:19:12 <seth_> I'm somewhat disappointed in ocaml.  I wrote a lot of code in it because it has a debugger, but the debugger is very buggy and mostly useless
04:19:26 <HannahS> seth_: I actually have done something useful w/ ocaml, too.
04:19:44 <HannahS> seth_: Some utility to control our climate system for the computer center of our company.
04:19:45 <shapr> seth_: I'm a big fan of unit testing, imho it replaces 95% of the need for debuggers
04:19:52 <HannahS> Yeah.
04:20:03 <HannahS> And w/ ocaml, you can try out things interactively, too.
04:20:06 <HannahS> Try ocamlmktop(1).
04:20:09 <seth_> shapr: that's very true.  but, still, the debugger can be very helpful
04:20:24 <HannahS> Good debuggers... A rare good.
04:20:31 * HannahS has come to *hate* gdb.
04:20:33 <seth_> HannahS: true.
04:20:45 <shapr> seth_: have you tried Hat or Buddha in Haskell?
04:20:48 <seth_> gdb is better then some of its predecessors   :)
04:20:52 <seth_> shapr: no, what are they?
04:20:55 <shapr> @fact hat
04:20:55 <lambdabot> Nothing
04:20:57 <shapr> hmr
04:21:00 <HannahS> seth_: Which doesn't say much about gdb *g*
04:21:00 <shapr> @fact buddha
04:21:00 <lambdabot> declarative debugger for Haskell 98 http://www.cs.mu.oz.au/~bjpop/buddha/
04:21:02 <shapr> aha
04:21:15 <seth_> shapr: interesting, I'll grab it.
04:21:39 <shapr> http://www.cs.york.ac.uk/fp/hat/publications.html
04:21:44 <shapr> @fact hat http://www.cs.york.ac.uk/fp/hat/publications.html
04:21:44 <lambdabot> set hat to http://www.cs.york.ac.uk/fp/hat/publications.html
04:22:14 <HannahS> jftr: I've just asked whether I may release my few Haskell bits to Open Source.
04:22:20 <shapr> @fact hat http://www.cs.york.ac.uk/fp/hat/download.html
04:22:21 <lambdabot> set hat to http://www.cs.york.ac.uk/fp/hat/download.html
04:22:24 <HannahS> I've suggested a BSD-like (3 clause) licence.
04:22:28 <shapr> HannahS: nifty, I hope they say yes :-)
04:22:32 <HannahS> Yeah.
04:22:34 <HannahS> Could well be.
04:22:56 <seth_> What would you consider the Haskell equivalent to the ocaml functor syntax?
04:22:58 <shapr> haskell-libs is really taking off lately
04:23:35 <shapr> email parsing libs, chess game, irc 'bot, crypto code, web server with plugins
04:23:48 <HannahS> seth_: Dunno. :-E
04:23:59 <shapr> I don't know ocaml
04:23:59 <HannahS> seth_: You could try whether you can use things like type classes etc. instead.
04:24:04 <seth_> How do I refer to GHC.Data's read within a source file?
04:24:08 <HannahS> shapr: functors are functions from modules to modules.
04:24:31 <shapr> oh, you can't do that exactly in Haskell, but you can use typeclasses
04:24:36 <HannahS> seth_: Perhaps coupled with functional dependencies.
04:24:51 <shapr> seth_: module Main where import GHC.Data
04:25:16 <shapr> usually the import statements are on their own line
04:25:24 <seth_> shapr: is there no syntax to be explicit?  In case modules have a name clash?
04:25:39 <HannahS> Yes.
04:25:44 <HannahS> import qualified Foo
04:25:45 <shapr> yes, you can use qualified and as
04:26:18 <seth_> ok, is I use the as clause, and say "as X", do I then write X.read?
04:26:48 <HannahS> Yes.
04:26:57 <HannahS> The as assigns a local alias name to the module.
04:27:15 <seth_> and if I use qualified, would I then write GHC.Data.read?
04:27:20 <shapr> yup
04:27:33 * shapr checks to make sure that's correct
04:27:37 <HannahS> Btw, name clashes are only detected lazily.
04:27:58 <HannahS> I.e. if you import A; import B, both have a name "f" exported, the name clash is only an error if you actually use f without qualifying.
04:28:01 <seth_> I like to be explicit.  it makes the code more readable.
04:28:05 <HannahS> Yes.
04:28:33 <HannahS> OTOH, I like less syntactic mess. I.e. I tend to use "system" things unqualified.
04:28:36 <shapr> seth_: you can also use "import GHC.Read (read)" which is explicit slightly differently
04:29:12 <seth_> shapr: that hides all names except read, correct?  and I still use GHC.Read.read?
04:29:24 <seth_> all GHC.Data names except read
04:29:41 <shapr> in that case, read is available directly
04:29:52 <shapr> It probably is still available as GHC.Read.read
04:29:53 * shapr checks
04:30:08 <seth_> shapr: oh, ok, I see what you mean, if I import explicitly there can't be hidden name clashes.
04:30:20 <shapr> right
04:30:51 <delYsid> hmm
04:30:56 <delYsid> I am confused!
04:31:01 <seth_> Now I created a .hs file, which has "import GHC.Data qualified" in it.  when I :load it, I get "can't find module GHC.Data"
04:31:03 <delYsid> listArray is supposed to be defined as 
04:31:19 <HannahS> seth_: import qualified ...
04:31:24 <HannahS> IIRC.
04:31:32 <delYsid> listArray b l = array b $ zip (range b) l
04:31:42 <delYsid> at least that is what prelude says...
04:31:53 <delYsid> if I do this manually, I can fill my array in the right order.
04:32:07 <delYsid> If I use listArray with the same list, it is flipped by 90%?!!!
04:32:35 <kosmikus> seth_: are you sure that there _is_ a module GHC.Data ?
04:32:52 <seth_> kosmikus: yes, because :m GHC.Data works
04:32:57 <delYsid> does anyone have an explanation for this?
04:33:08 <seth_> kosmikus: wait, no, it doesn't.
04:33:28 <seth_> kosmikus: my fault, GHC.Read is the module
04:33:33 <kosmikus> I have no such module on my hard disk ...
04:33:41 <seth_> kosmikus: sorry, dumb mistake.
04:34:27 <HannahS> delYsid: No idea.
04:34:38 <kosmikus> seth_: may I ask which functions of GHC.Read you actually need?
04:35:08 <seth_> at the moment I'm still with (GHC.Read.read "123") :: Int
04:35:43 <kosmikus> you don't need GHC.Read for that; read is a Prelude function ...
04:36:19 <seth_> kosmikus: ah, ok.  why then are some functions in the prelude and also in a module (such as GHC.Read)?
04:36:43 <kosmikus> GHC.Read contains several more specific function around read, among other things, the functions that are internally used to implement the read function, but they are specific to GHC and not part of Haskell 98
04:36:57 <seth_> kosmikus: ok.
04:37:02 <kosmikus> AFAIK the Prelude imports GHC.Read and reexports some of its functions ...
04:39:43 <kosmikus> delYsid: could you give a one-line example that demonstrates the difference in behaviour?
04:59:47 <HannahS> Oh, the bot has gone.
04:59:52 <HannahS> No more lambdas in here!
05:00:33 <shapr> someone found a bug in the code I wrote yesterday
05:00:42 <shapr> @ply in the chess plugin didn't check for zero input
05:01:08 <HannahS> Isn't lambdabot statically typed?! :-)
05:01:56 <shapr> it is
05:02:02 <shapr> but that doesn't find all errors
05:03:43 <shapr> I should really use HUnit and QuickCheck on lambdabot
05:03:56 <HannahS> Yeah.
05:04:08 <HannahS> Is the *whole* bot written in Haskell?
05:04:12 <shapr> yup
05:04:18 <HannahS> How are plugins implemented?
05:04:22 <shapr> @fact source
05:04:22 <lambdabot>  http://sf.net/projects/haskell-libs/, http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/lambdabot/
05:04:23 <HannahS> Re, lambdabot :-)
05:05:08 <shapr> HannahS: plugins are very easy to write
05:05:32 <shapr> http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/lambdabot/HelloModule.hs
05:05:37 <shapr> that's the simplest demo module
05:05:54 <shapr> note I didn't write the 'bot, just a bunch of plugins
05:06:08 <HannahS> Are they statically linked in or is there some kind of more dynamic plugin mechanism?
05:06:17 <shapr> right now they're statically linked
05:06:26 <shapr> I'd like to use o3's runtime loader instead
05:06:41 <shapr> that's on the TODO list
05:06:49 <HannahS> o3?
05:07:03 <shapr> Andre Pang
05:07:31 <shapr> http://www.algorithm.com.au/wiki/hacking/haskell.ghc_runtime_loading
05:07:37 <shapr> @fact runtimeloader
05:07:38 <lambdabot> Nothing
05:07:42 <shapr> @fact runtimeloader http://www.algorithm.com.au/wiki/hacking/haskell.ghc_runtime_loading
05:07:43 <lambdabot> set runtimeloader to http://www.algorithm.com.au/wiki/hacking/haskell.ghc_runtime_loading
05:07:51 <HannahS> Is there some global registry of plugins in lambdabot, too?
05:08:02 <shapr> @listmodules
05:08:02 <lambdabot> I have the following modules installed: ["chess","eval","fact","fortune","hello","karma","more","searchml","state","system","topic","type","yow"]
05:08:10 <shapr> they're all explicitly imported right now
05:08:12 <HannahS> Or how does the core know of, e.g. HelloModule.helloModule?
05:08:16 <HannahS> Ah, okay.
05:08:20 <HannahS> @yow
05:08:21 <lambdabot> Is it clean in other dimensions?
05:08:23 <HannahS> *g*
05:08:26 <shapr> oh, Module is a typeclass also
05:08:34 <shapr> @fact author
05:08:34 <lambdabot>  Andrew Bromage aka Pseudonym
05:08:42 <shapr> Pseudonym did some very cool stuff in the lambdabot sources
05:09:40 <delYsid> strange!
05:09:44 <delYsid> t = (listArray dim [1..16]) == (array dim $ zip (range dim) [1..16])
05:09:47 <delYsid> evals to True
05:10:02 <delYsid> but my example, using a custom Ix instance, does not work like this
05:10:05 * shapr tries to figure out what that does
05:10:06 <HannahS> Looks scary -> runtime loading.
05:10:35 <delYsid>   where dim = ((1,1),(4,4))
05:12:01 <HannahS> Now, Ix for pairs is predefined, isn't it?
05:12:55 <shapr> delYsid: what's your custom Ix instance?
05:13:10 <HannahS> Now, back to the C++ swamps :-E
05:13:21 <HannahS> I'm currently writing a live malloc trace analysis tool.
05:13:36 <HannahS> Things you probably wouldn't need with a proper GC + (if needed) heap profiler.
05:14:11 <HannahS> Hello.
05:14:27 <delYsid> instance Ix Square where
05:14:27 <delYsid>   range (Sq l l',Sq u u') = [Sq i i' | i' <- range (l',u'), i <- range (l,u)]
05:14:27 <delYsid>   inRange (Sq l l',Sq u u') (Sq i i') = inRange (l,u) i && inRange (l',u') i'
05:14:27 <delYsid>   index (Sq l l', Sq u u') (Sq i i')
05:14:28 <delYsid>       = index (l,u) i * rangeSize (l',u') + index (l',u') i'
05:15:01 <delYsid> oh, might it be that index is wrongly defined?
05:15:35 <shapr> it might be
05:20:37 <delYsid> ah yeah, that was it
05:21:12 <delYsid> strange though that the implementation relies on index, but the Standard Library Preulde defines listArray in terms of zip and range
05:21:45 <Igloo> That sounds like a bug
05:23:45 <kosmikus> I don't think it's a bug
05:24:03 <HannahS> IIRC the libs may rely on the laws defined for the standard type classes.
05:24:16 <kosmikus> you cannot define an array implementation if there is no consistent instance of Ix provided
05:31:32 <delYsid> hehe, cute, since I use an Array for my Board, I can write most of the primitives as list comprehensions.
05:31:50 <delYsid> forcesColoured c bd = [(k,sq) | (sq,Just (c',k)) <- assocs bd, c==c']
05:39:21 * Darius misses referential transparency.
05:41:47 <HannahS> Darius: Why do you miss it?
05:41:55 <HannahS> Darius: We're on #haskell, not on #c++ or so *g*
05:42:39 <HannahS> Darius: Or are you forced into intransparent programming?
05:42:52 * Darius is hacking C++
05:45:56 <ddarius> thank you ISP
05:46:14 <HannahS> Darius: Oh ...
05:46:17 <HannahS> Darius: Me too.
05:46:28 <HannahS> It's a *lovely* experience, isn't it?
05:47:21 <ddarius> It wouldn't be so bad if it were my code, but I'm writing code in another not very well documented framework.  I have no idea what is messing with what.
05:48:35 <ddarius> I'm only missing garbage collection because I'm generating code, but can't generate cleanup code, because I don't know when it will happen.
05:50:03 <ddarius> I could roll my own GC though (I'm guessing that's better than random crashes ;)
05:50:31 <HannahS> Or use some reference counted pointer class.
05:50:32 <HannahS> :-S
05:50:45 <HannahS> They aren't fast, they can't handle cycles, but besides that, they sort of work.
05:53:07 <ddarius> I would but I'm interfacing to code that wouldn't know about that.
05:53:22 <HannahS> Hummm.
05:53:23 <HannahS> :-E
05:55:39 <HannahS> I LIKE error messages with a line length of 1498.
06:00:20 <ddarius> Well it makes you feel like a guru when your eyes only -slightly- glaze over in response.
06:02:50 <HannahS> Oh, if there just was some matching <> highlighting in the error message...
06:02:55 <HannahS> :-E
06:06:18 <delYsid> grrr
06:06:18 <delYsid> is there a way to determine if succ would succeed?
06:08:58 <HannahS> I'd think:
06:09:36 <HannahS> If a type is Bounded, then succ will succeed iff the argument is /= maxBound
06:09:43 <HannahS> If a type is not Bounded, succ will succeed period.
06:09:46 <HannahS> Or am I wrong?
06:10:20 <jadrian> hello
06:10:24 <shapr> y0
06:10:28 <andersca> hey shapr
06:10:28 <jadrian> hi shapr
06:10:46 <kosmikus> HannahS: I don't think this behaviour is enforced somehow, but for derived instances and standard types it's proabably true
06:10:47 <jadrian> this might be a naive question and I shuold probably RTFM anyway
06:11:19 <jadrian> I'm going to reinstall suse linux, and there are no suse rpms available, so I'll have to compile ghc from source
06:11:26 <jadrian> but seems like I need ghc to compile ghc
06:11:35 <shapr> yup
06:11:46 <jadrian> I would install ghc to compile ghc, but then I need to compile ghc
06:11:53 <jadrian> to install ghc to compile ghc
06:11:56 <shapr> aren't there binary distributions of GHC?
06:12:00 <jadrian> get the idea?
06:12:06 <Igloo> You can get a tarballed binary from the webpage
06:12:20 <jadrian> hmmmm
06:12:26 <kosmikus> you don't necessarily need SuSE RPMs to get a usable binary
06:12:38 <Igloo> Assuming x86, anyway
06:12:39 <jadrian> so if I can get a tared binary, why would I need to compile ghc myself?
06:12:50 <jadrian> (is the answer *you don't*?)
06:12:51 <jadrian> :)
06:13:10 <Igloo> If you wanted a SuSE package you'd need to
06:13:31 <jadrian> but assuming I just want to use it
06:13:39 <Igloo> And you might need to if you have a different readline version or something like that
06:13:47 <jadrian> oh
06:14:16 <jadrian> where is the tared binary??
06:14:24 <jadrian> I just see rpms and sources
06:14:35 <jadrian> or is it another version 
06:14:44 <jadrian> non 5.04.3 that is
06:14:52 <Igloo> http://www.haskell.org/ghc/dist/5.04.3/ghc-5.04.3-i386-unknown-linux.tar.bz2
06:14:53 <jadrian> nevermind
06:14:54 <jadrian> got it
06:15:01 <delYsid> HannahS: yes, thanks
06:15:15 <jadrian> built on RH... 
06:15:20 <delYsid> hmm, is there some predefined function to apply a tuple as arguments to a function?
06:15:20 <jadrian> hmmm hope it works...
06:15:55 <HannahS> delYsid: uncurry?
06:16:39 <Darius> f :: a -> b -> c; uncurry f :: (a,b) -> c  for the details
06:16:45 <delYsid> cool!
06:16:45 <delYsid> thanks
06:16:49 <jadrian> delYsid: it is used like: uncurry (*) (1,2)
06:17:02 <Marvin--> @type uncurry
06:17:03 <lambdabot> uncurry :: (a -> b -> c) -> (a,b) -> c
06:17:15 <jadrian> nice
06:17:35 <jadrian> @type uncurry (*)
06:17:35 <lambdabot> uncurry (*) :: Num a => (a,a) -> a
06:17:45 <jadrian> very nice :)
06:38:20 <shapr> hi Heffalump 
06:38:40 <Heffalump> 'lo
06:39:14 <Darius> woo, I may not need to worry about leaks after all
06:39:23 <shapr> ?
06:42:08 <Darius> converting std::string's to/from char *'s
06:42:22 <shapr> ah
06:43:08 <HannahS> You can't convert a std::string to char*, only to const char*!
06:43:29 <HannahS> const_cast'ing the const away from string::data()/c_str() is utterly non-portable.
06:43:35 <HannahS> I've been bitten by that already :-E
06:46:33 <Darius> I meant a more general conversion (e.g. copying if necessary), but usually it is to const char *.  The main problem would be if Kyra (the library) wanted to hold on to some pointers.
06:46:55 <shapr> ooh, you're working on wrapping Kyra
06:46:56 * shapr bounces
06:49:15 <Darius> (that wouldn't be very good design though)
07:18:19 <delYsid> hmm? Cant tuples be enumerated?
07:18:57 <Heffalump> they should be able to be if the components can be
07:19:11 <Heffalump> i.e. there should be instance Enum a,Enum b => Enum (a,b) where ...
07:19:18 <Heffalump> and if it doesn't exist, you could write it
07:20:07 <andersca> what's kyra?
07:20:11 <delYsid> hmm, both components are deriving Enum
07:20:23 <Darius> www.grinninglizard.com/kyra
07:20:24 <delYsid> but [(White,Kingside) .. (Black,Queenside)] fails.
07:20:31 * Heffalump consults his report, just cos he can
07:20:36 <Igloo> :-)
07:20:53 <Igloo> hugs seems to agree you can't
07:21:39 <Heffalump> it appears not to be defined
07:21:47 <Heffalump> shouldn't be too hard to write, though
07:22:06 <delYsid> yah, but then its probably shorter to enumerate it by hand.
07:22:16 * Igloo thinks about wondering over and admiring Heff's report some time
07:22:31 <Heffalump> wander!
07:22:43 <Igloo> Yeah, that too  :-)
07:22:47 <Heffalump> unless you actually intend to wonder over my report, which seems like an extreme reaction
07:25:21 <delYsid> [Pawn | _ <- [1..8]]
07:25:27 <delYsid> hmm, is there a nicer way to express this?
07:25:46 <Darius> replicate 8 pawn?
07:25:59 <delYsid> tnx
08:16:39 * HannahS 's leaving for some food.
08:16:42 <HannahS> CU all!
08:37:33 <syntax-laptop> does anyone feel like there are too many links on the FrontPage (HaWiki)?
08:40:28 <jemfinch> I didn't when I was looking at it the other day.
08:40:57 <syntax-laptop> I keep wanting to add stuff to the front page.  I guess if people don't liek it they can change it!
08:41:08 <syntax-laptop> (Currently I'm thinking of adding LibrariesAndTools)
08:57:12 <ibid> appy +RTS -K2048576 -RTS -i Parser.y
08:57:12 <ibid> unused rules: 35
08:57:12 <ibid> unused terminals: 3
08:57:12 <ibid> shift/reduce conflicts:  1061
08:57:12 <ibid> reduce/reduce conflicts: 1207
08:57:17 <ibid> (heh :-)
09:04:52 <hdaume> yikes
09:08:24 <delYsid> What is the reason for disallowing different currying with pattern matching?
09:09:12 <delYsid> i.e., aux [] _ _ = id; aux _ 0 _ = id; aux (c:s) r f bd = ...
09:11:25 <hdaume> delYsid: i asked the same question on the mailing list a while back.  the answer was that often when people write like that it's an error (they forgot to put the extra params), but i think that the typechecker will almost always catch that.  i think more practically it's because function definitions with pat matching are converted into case statements, and if you don't have the same arity, this becomes tough, essentially because you have to inline, in this
09:11:36 * hdaume still thinks that rule is stupid though
09:14:20 <ibid> now down to:
09:14:21 <ibid> shift/reduce conflicts:  402
09:14:21 <ibid> reduce/reduce conflicts: 267
09:16:51 <delYsid> hdaume: I agree, thanks for the explanation though
09:17:20 <hdaume> np
09:19:43 <delYsid> aux ('1':s) r f bd = aux s r (f+1) bd
09:19:44 <delYsid> aux ('2':s) r f bd = aux s r (f+2) bd
09:19:44 <delYsid> aux ('3':s) r f bd = aux s r (f+3) bd
09:19:44 <delYsid> aux ('4':s) r f bd = aux s r (f+4) bd
09:19:44 <delYsid> aux ('5':s) r f bd = aux s r (f+5) bd
09:19:44 <delYsid> aux ('6':s) r f bd = aux s r (f+6) bd
09:19:46 <delYsid> aux ('7':s) r f bd = aux s r (f+7) bd
09:19:48 <delYsid> aux ('8':s) r f bd = aux s r (f+8) bd
09:19:51 <delYsid> oh my, I hate repetition...
09:20:30 <shapr> how about using read :: Int ?
09:20:37 <hdaume> out about "aux (x:s) r f bd | x `elem` ['1'..'9'] = aux s r (f + read [x]) bd
09:20:39 <hdaume> "
09:21:00 <delYsid> hmm
09:21:02 <delYsid> cute
09:21:24 <hdaume> or "ord x - ord '0'" should work
09:21:29 <hdaume> perhaps faster than read
09:21:44 <hdaume>     where perhaps = certainly
09:33:22 <delYsid> coool, that made it nice and compact
09:50:40 <pesco> hey everyone
09:56:44 <pesco> woah, cool, Netshrub is working!!
10:08:39 <shapr> Marvin--: is "ar" in binutils broken?
10:08:44 <shapr> hi pesco 
10:09:53 <shapr> how do I turn a bunch of .o files into a file that ends with .a ?
10:10:05 <Marvin--> shapr: not that I know... it doesn't use libstdc++, does it?
10:10:23 <shapr> I don't know
10:10:27 <Marvin--> (there are plenty of nasty problems with libstdc++ right now)
10:10:31 <Marvin--> nope, ar doesn't use it
10:10:38 <Marvin--> I don't know of any other major problems
10:10:43 <pesco> hi shapr
10:10:46 <shapr> I'm trying to build the GHC version of HGL for use with Yampa
10:10:56 <pesco> What's Yampa?
10:11:09 <shapr> @fact yampa
10:11:09 <lambdabot> http://www.haskell.org/yampa/
10:11:58 * pesco giggles watching the little line to irc.freenode.org flash as shapr speaks
10:12:52 <shapr> what's netshrub?
10:13:52 <delYsid> hmm
10:13:55 <pesco> Ooh, yampa sounds goood!
10:13:58 <pesco> Netshrub is my new toy project.
10:14:08 <delYsid> I'd love if ghci could automatically produce some useful stack info on exceptions.....
10:15:03 <Heffalump> is the stack entirely obvious with laziness?
10:15:23 <delYsid> ?
10:15:23 <pesco> shapr: It draws little green boxes connected by lines representing Internet hosts resp. their communications.
10:15:45 <pesco> shapr: In 3d of course. Written in Haskell of course.
10:16:03 <shapr> nifty
10:16:08 <Darius> delYsid: the reason -xc needs profiling is with laziness the -actual- stack is meaningless to mere mortals
10:16:58 <delYsid> is there a simple way to tell ghci to use -xc, without explicitly compiling the thing?
10:18:05 <shapr> how are .a files normally created?
10:18:58 <shapr> aha
10:26:09 <hdaume> we have a bunch of code which uses floats *everywhere*.  we were running into precision issues, so we changed them all to doubles and everything got faster.  this is with gcc on new x86 architecture.  can you explain this?
10:26:24 <hdaume> (this is c, not haskell, but there are smart people in this channel... :P)
10:26:50 * Heffalump reads the bottom of http://www.standardml.org/Basis/overview.html and looks smug
10:27:43 <Darius> ALWAYS use doubles unless you are having space issues
10:27:58 <hdaume> Darius: why?
10:28:35 <Darius> the natural precision of the x86 is double/long double (I think Pentiums are double). Why? So you don't run into precision issues!
10:28:56 <Darius> And typically it isn't significantly slower, it (as you've seen) may even be faster.
10:29:37 <pesco> Quake used floats everywhere. I'm using what Quake uses.
10:29:50 * pesco nods with great determination
10:30:59 <Darius> Floats are good if you really need the speed and you (or your compiler) will use SIMD and you can accept and minimize numerical errors
10:31:22 <hdaume> k
10:31:58 * pesco looks the other way, unsuspiciously whistling a tune...
10:32:38 <pesco> *whisper* hdaume: quake you know, just do what quake does. it's always right, you know.
10:32:57 * pesco glances around and continues whistling
10:34:58 <pesco> *whisper* i know what they're thinking. they all think I'm mad. but just think about it. didn't quake work wonderfully? everyone could be on the safe side if we just followed its brilliant examples.
10:36:01 * Darius has only played the first Quake a few times and hasn't played the others at all.
10:36:40 <pesco> Had I meant Quake II or III, I woulde have said so! There is only one Original Quake!
10:37:24 <Darius> Back in the day, using floats for 3D was lazy and considered, you used 0.32, 1.31, 16.16 fixed point.
10:37:46 * pesco pulls his copy of Quake half-way out under his coat, gives it a short but heartful look and quickly restows it safely inside.
10:37:47 <Darius> s/considered/considered slow/
10:39:02 <pesco> That must surely have been before the era of Quake. It would never have worked with fixed points. Just rememeber the particle effects!
10:40:15 <shapr> I heard rumors NIN will do the soundtrack for Doom III
10:40:35 * pesco drools
10:41:13 <pesco> I know.
10:41:20 <shapr> trying to build Yampa increases my interest in a Haskell dist-utils system
10:42:35 <pesco> shapr: I just wish they'd get H.R. Giger to do some of the artwork.
10:42:47 <shapr> that would be cool
10:42:53 <pesco> Although that would have probably given me a heart-attack.
10:44:01 <pesco> Trent Reznor, H.R. Giger, and John Carmack are pretty much _the_ people I personally admire.
10:45:14 <Darius> From (the little) I've seen of Doom III it looks like it still would give one a heart attack
10:45:29 <pesco> And looking forward to it.
10:46:29 <pesco> If I die in happy horror playing Doom III to sounds from NIN, I won't argue.
10:47:34 <pesco> Although that would mean I'd miss some other goals in my life...
10:48:29 <pesco> Hm, maybe I can reschedule the dying to some later date.
10:49:10 * pesco searches his address book, runnnig a finger across the pages
10:51:22 <pesco> Ah, Dept. for Mortality Issues, building 37b, room 6
10:51:56 <pesco> gotta run, they close at eight...
11:36:21 <delYsid> gah!
11:36:46 <delYsid> Now I spent >50% of time and alloc in forcesColoured, and pieceAt is nicely gone down to 15%
11:37:04 <delYsid> overall, its slower than before
11:37:05 <Igloo> What did you do?
11:37:11 <Igloo> Ah
11:37:14 <delYsid> convert to an Array
11:37:22 <Heffalump> what is forcesColoured?
11:37:41 <delYsid> forcesColoured :: Colour -> Board -> [(Kind,Square)]
11:37:41 <delYsid> forcesColoured c (Board bd _)
11:37:42 <delYsid>     = [(k,sq) | (sq,Just (c',k)) <- assocs bd, c==c']
11:40:20 <Darius> Would time and space usage be attached to pieceAt if it were merely the function that forced most of the board first?
11:41:16 <Heffalump> what is it supposed to do?
11:41:38 <delYsid> pieceAt :: Board -> Square -> Maybe Piece
11:41:38 <delYsid> pieceAt (Board bd _) sq
11:41:38 <delYsid>     | inRange (bounds bd) sq = bd ! sq
11:41:39 <delYsid>     | otherwise              = Nothing
11:44:10 <delYsid> anyway, it seems the version using an array is about two times slower than the old list based board, and does about three times more alloc
11:44:50 <hdaume> delYsid: you know that arrays aren't update in place, right?
11:45:05 <delYsid> mind to elaborate?
11:45:27 <hdaume> if you say "arr // [(1,'a')]", if arr is 100000 elements long, it will copy the array to do the update
11:45:46 <hdaume> so array update is in effect an O(n) operation, not O(1)
11:46:09 <delYsid> O(64) then
11:46:40 <Igloo> If most of what you are doing is looking at the board rather than changing it then also keeping around a list of (Piece, Square) for each colour might be faster
11:46:41 <ibid> O(64) is O(1) :)
11:46:42 <hdaume> imo, functional arrays are only useful for filling in the data at the beginning and then reading
11:46:55 <hdaume> ibid: haha
11:47:18 <ibid> i seem to remember reading about a functional array structure that has both efficient lookup and update
11:47:22 <hdaume> if you're updating frequently, you'll almost certainly be better off with something like FiniteMap
11:47:38 <ibid> hdaume: seriously, really. you cannot use O notation usefully with fixed n
11:48:12 <hdaume> ibid: of course
11:48:31 <delYsid> FiniteMap?
11:48:38 <hdaume> let's just say it's an O(1) operation with very high constants :)
11:48:39 <Igloo> ibid: Yes you can, in an informal context
11:48:49 <ibid> Igloo: it's abuse of the notation, so no you can't
11:49:07 <Darius> ibid: math advances by abusing notation
11:49:08 <ibid> Igloo: O notation is essentially modulo any fixed factor
11:49:10 <Igloo> You can abuse notation in informal context. That's almost the *definition* of informal context.
11:49:39 <ibid> Igloo: that's about as good abuse of notation as saying 12 = 1, informally
11:49:48 <ibid> (it is, really, in Z_12:-)
11:50:27 <hdaume> Z_11 :)
11:51:13 <ibid> true
11:51:43 <ibid> Darius: math is abuse o notation. we are not mathematicians here, though
11:51:47 <ibid> of too
12:09:33 <ibid> (there was, btw, a nice EWD paper where he made the point that mathematicians just wave hands, computing sciencists need to be precise:-)
12:32:10 <Darius> "No garbage collection is bad, very bad." - some wisdom from Buddha
12:32:58 <ibid> yeah, it makes the streets dirty - you can catch disease if you don't do gc :-)
12:41:36 <delYsid> hmm, if I'd use FiniteMap, I could implement forcesColoured in terms of foldFM
12:41:51 <delYsid> does anyone think this could be worth it somehow?
12:57:35 <delYsid> piecesOf c = foldFM (\sq (c',k) xs -> if c==c' then (k,sq):xs else xs) []
12:58:39 <seth_> hey, all, in the message "Expected type: [Char]   Inferred type: Char"  which is the type of my argument and which is the type that my argument _should_ be?  Is it telling me I have a Char where I need a [Char], or the other way around?
12:59:12 <Igloo> It inferred the expression it tells you has type Char
12:59:19 <Igloo> You used it somewhere it expected an Exp
12:59:30 <seth_> So my code has a Char instead of a [Char] ?
12:59:33 <Igloo> Ermmm, IM [Char] (sorry, brain elsewhere)
12:59:38 <Igloo> Yes
12:59:41 <seth_> thanks
12:59:58 <delYsid> I guess that should do less consing than the list comprehension on assocs, right?
13:07:23 <delYsid> class (Eq k) => Map d k v | d -> k v where ...
13:07:30 <delYsid> What does this exactly mean?
13:07:38 <delYsid> I dont understand the -> there
13:09:17 <Heffalump> it's a fundep
13:09:29 <delYsid> ?
13:09:39 <Heffalump> I think it means that for any particular d, there can only be one k and one v
13:09:56 <Marvin--> yeah, if d is known, then k and v can be deduced
13:10:28 <Marvin--> I have never ever understood when and exactly why I need to add fundeps :)
13:10:45 <Marvin--> I know there *is* a why, I read the paper though I didn't understand much of it
13:11:06 <Heffalump> to stop type-checking of MPTCs being undecidable, right?
13:11:26 <Marvin--> well, yes, but I never understood in which cases it's needed
13:13:19 <ham[let]> hiho
13:13:43 <Darius> When the compiler gives you a bunch of MPTC-related ambiguity errors that intuitively seem unambiguous, then use fundeps.
13:13:49 <Darius> That's my rule of thumb.
13:14:09 <Marvin--> mine too :)
13:14:45 <ham[let]> hey mgoetze :)
13:16:28 <Darius> anyways, delYsid, read the -> as "decides" as in "d decides k and v" and it usually makes some kind of sense
13:25:56 <seth_> I want to put a putStrLn into a function for debugging purposes.  How do I do so?  I thought I could do something like:   putStrLn whatever >> ....          but this fails because the type of putStrLn whatever is not the same as the type of  .........   
13:26:50 <Smerdyakov> You can't. Maybe the Haskell community has special debugging tools for handling such situations.
13:27:18 <seth_> how about calling a function to do the print?
13:27:27 <Igloo> Look at Debug.Trace.trace
13:27:38 <seth_> Igloo: ah, right, now I remember.  thanks
13:28:11 <Heffalump> (trace is implemented with unsafePerformIO, so make sure you remove it again once you've finished with it, and don't be surprised if it doesn't quite behave how you'd expect)
13:28:31 <seth_> Heffalump: ok, but for debugging it should be ok?
13:28:37 <Heffalump> yep
13:28:44 <Heffalump> just don't use it in the final version :-)
13:28:55 <Heffalump> and remember it'll only kick in when the expression is evaluated
13:29:20 <seth_> right.
13:29:23 <Heffalump> i.e. trace "foo" e prints out "foo" and evaluates to e, but this only happens when something asks for it to be reduced anyway
13:29:40 <Heffalump> so if the value of e was never demanded before, replacing it with trace "foo" e will have no effect
13:30:06 <seth_> ah, ok.  that in itself might be informative.
13:30:52 <Heffalump> yeah
13:30:57 <Heffalump> you just have to be aware of how it works :-)
13:32:36 <seth_> why do I get an error (error in character literal) on "abc\ndef" ?
13:32:54 <seth_> never mind, I typed it wrong.
17:04:16 <seth_> I'm trying to figure out how to use references.  I created a reference with newSTRef, but I can't figure out how to apply readSTRef to it.
17:05:30 <seth_> also...
17:05:43 <seth_> I have a function that takes a list of strings and returns a tuple
17:05:52 <seth_> the second element of the tuple is a modified list of strings.
17:05:55 <seth_> the following works:
17:05:58 <Darius> do ref <- newSTRef whatever; ...; thedata <- readSTRef ref
17:06:06 <seth_> (a,b) = func c
17:06:10 <seth_> c = b
17:06:13 <seth_> that is, let c=b
17:06:25 <seth_> but, (a,c) = func c   doesn't work.  why?
17:07:09 <seth_> Darius: for the ref question, that gives "the last statement in a 'do' construct must be an expression
17:07:25 <Darius> That would be passing the result to the function, which is probably not what you want
17:07:37 <Darius> well you need to do something with thedata
17:07:55 <Darius> e.g. (superfluously) return thedata
17:08:07 <seth_> I can't do anything with thedata unless i have it to begin with.  I'll use the combinators, the do construct is impossible to use.
17:09:03 <seth_> but I'd rather not use a reference at all.  is there a way to do my two statements (a,b) = func c; let c=b;    in a single statement?
17:09:44 <seth_> return thedata doesn't work either.
17:10:04 <Darius> there's no reason to, let c = b, is the same as just using b
17:10:30 <seth_> no, the name c now refers to the new list
17:12:14 <Darius> and so does b
17:12:25 <seth_> Darius: yes, so what?
17:13:07 <seth_> can you give me some working code with a reference?  I need an example that doesn't get a compile error
17:18:22 <Darius> import Control.Monad.ST and Data.STRef, then in GHCi or Hugs: runST (do ref <- newSTRef (1 :: Int); a <- readSTRef ref; writeSTRef ref (a+1); readSTRef ref;)
17:24:43 <Smerdyakov> Would someone like to share his AIM screen name with me, so I can check degrees of separation at buddyzoo? =)
17:25:15 <seth_> Darius: when I put that in a file and load it into ghci, I just get a parse error
17:25:38 <Darius> What error?
17:26:15 <seth_> Darius: if I paste it into ghci, it appears to run, but if I put it into a file, it says parse error, possibly incorrect indentation.
17:26:25 <Riastradh> What's the difference between STRefs and IORefs?
17:26:55 <seth_> what is the runST for?
17:27:01 <Darius> There's a runST, there isn't a runIO (well unsafePerformIO)
17:27:53 <Darius> seth_: The STRefs are in a monad, you have to tell it to start.  The runST effectively delimits a stateful function from the rest of the pure code. 
17:29:30 <Darius> seth_: Haskell is a pure language. let c = b doesn't change the value of c, it makes a new variable.  You can never change the value of a variable in Haskell.
17:31:42 <seth_> I don't want to change the variable.  I want to create a new variable.  I just want to do it in one line instead of two.
17:32:16 <Pseudonym> You mean like let { a = 1 ; b = 2 } ?
17:35:09 <seth_> Pseudonym: I don't see how that applies to my example.  I'll give it again.  I have (a,b) = func c; c = b     is there a way to do that in one statement?
17:35:34 <Pseudonym> I don't know your example.
17:35:37 <Pseudonym> ::-)
17:35:38 <Pseudonym> Oh.
17:35:42 <Pseudonym> That should be okay.
17:35:56 <Pseudonym> let { (a,b) = f c ; c = b } in ...
17:35:58 <Pseudonym> Should work fine.
17:36:10 <seth_> yes, it does, but that is the shortest way to do it?
17:36:14 <Pseudonym> It will, of course, be a circular definition.
17:36:26 <Pseudonym> This might save you a few characters:
17:36:41 <Pseudonym> let { ((a,b),c) = (f c,b) } in ...
17:36:55 <Pseudonym> Actually it didn't.
17:37:09 <Pseudonym> Why are you after the shortest way?  IOHCC entries are closed.
17:37:41 <seth_> just trying to understand the syntax.  maybe that is the shortest way, but logically you should be able to say (a,c) = func c
17:37:51 <Pseudonym> Sure.
17:37:58 <Darius> you can, but it means something different
17:38:07 <seth_> what, then, does it mean?
17:38:10 <Darius> that's why you can't with the meaning you want
17:38:18 <Pseudonym> What meaning do you want?
17:38:29 <seth_> I want (a,b) = c; c = b
17:38:30 <Pseudonym> Do you want the c on the left-hand side to be the same as the one on the right-hand side?
17:38:51 <seth_> I want the c on the left side, after the statement is executed, to denote the returned value
17:39:11 <Pseudonym> And you want that to be the same as the c on the right-hand side?
17:39:24 <seth_> no, the value on the right hand side is before the function is applied
17:39:29 <Pseudonym> Oh.
17:39:41 <Pseudonym> Shortest way I can think of is this:
17:39:58 <Pseudonym> (\(_,c) -> ...) (f c)
17:40:20 <Pseudonym> Most readable way is:
17:40:22 <Darius> The shortest way I can think of is c <- f c
17:40:29 <Pseudonym> let (a,b) = f c in let c = b in ...
17:40:32 <Darius> (with f c being in a monad)
17:40:45 <Pseudonym> You mean c <- return (f c)
17:40:56 <Pseudonym> That way f doesn't need to be in a monad.
17:41:14 <Pseudonym> You can even use MonadIdentity. :-)
17:41:53 <seth_> Pseudonym: can you show me c <- return (f c) in the combinator notation, with >>= ?
17:41:59 <Pseudonym> Sure.
17:42:02 <Riastradh> do c <- return (f c); ...
17:42:04 <Riastradh> is the same as:
17:42:07 <Pseudonym> return (f c) >>= \c -> ...
17:42:12 <Riastradh> (return (f c)) >>= \c -> ...
17:42:17 <Riastradh> Bah!
17:42:43 <Darius> Your Scheme is showing through Riastradh :P
17:43:25 <Riastradh> Darius - No, my forgetfulness of >>= associativity.
17:43:27 <seth_> Pseudonym: the function returns a tuple, (a,b) say.  How does that fit into the >>= ?
17:43:33 <Riastradh> Er, precedence.
17:43:38 <Riastradh> Associativity, precedence, whatever!
17:43:39 <Pseudonym> return (f c) >>= \(_,c) -> ...
17:43:41 <Pseudonym> That'd work.
17:43:53 <Darius> Riastradh: function application is highest precedence no matter what
17:43:59 <seth_> Pseudonym: and if I want both values,  return (f c) >>= \(b,c) -> ...
17:44:05 <Pseudonym> Right.
17:44:13 <Riastradh> See, my forgetfulness of precedence!
17:44:13 <Pseudonym> _ is just an "ignore me" pattern
17:44:29 <Pseudonym> I forget precedence too, but I always remember where function application is.
17:44:31 <Riastradh> Well, I suppose that is a result of me being a Schemer.
17:44:46 * Pseudonym constantly gets lost in C's operator precedences
17:44:59 * Riastradh never gets lost in anything in C because he avoids C.
17:45:01 <Riastradh> It works quite well!
17:45:08 <Darius> I don't have all of them down, I just add ()'s when I need them in C++.
17:45:09 <Pseudonym> Actually it's C++, but it's the same operator set.
17:45:14 * Pseudonym nods
17:45:17 <Darius> or when I'm not sure
17:45:45 <Pseudonym> I think even Dennis Ritchie admitted that he got the relative precedences of bit shifting and bitwise logic round the wrong way.
17:47:22 <seth_> Pseudonym: possibly, but since most people use parentheses because they can't remember them, it is somewhat academic.
17:53:33 <seth_> I still can't make readSTRef work
17:54:07 <seth_> without using do, show me how to use readSTRef
17:54:49 <Riastradh> newSTRef foo >>= \ref -> readSTRef ref >>= \value -> <process value>
17:55:21 <kawfee> how would I make a data type of two lists as in: data LIstM = cur | prev
17:55:29 <kawfee> how would I make a data type of two lists as in: data LIstM = cur List | prev List
17:55:30 <Darius> runST (newSTRef (1 :: Int) >>= \ref -> readSTRef ref >>= \a -> writeSTRef ref (a+1) >> readSTRef ref)
17:56:45 <seth_> Riastradh: I have a value I've created thus:  x = newSTRef foo.  Show me how to use that reference.  
17:56:51 <Darius> kawfee, I have no idea what you mean.
17:57:14 <kawfee> Darius: I was to make a data type that can be two lists
17:57:29 <kawfee> a pair of lists
17:58:37 <Darius> type ListM a b = ([a],[b])
17:58:55 <kawfee> ok
17:58:56 <kawfee> thanks
17:59:13 <Riastradh> seth_ - x >>= \ref -> readSTRef ref >>= \value -> <process value>
17:59:36 <kawfee> > data ListM  a b = ([a],[b])
17:59:44 <Darius> Two different list a different times or two different lists at the same time?
17:59:50 <Riastradh> type ListM a b = ([a],[b])  -- not data
17:59:53 <kawfee> hrm why does ty[e work here?
17:59:59 <kawfee> I tried both
18:00:01 <Riastradh> 'type' defines a type synonym.
18:00:08 <kawfee> umm ok
18:00:09 <Riastradh> 'data' defines a new datatype with its own constructors.
18:02:06 <seth_> Riastradh: doesn't work.  Using your original line, with the newSTRef and readSTRef on the same line, I did:
18:02:20 <seth_> Riastradh: newSTRef "abc" >>= \ref -> readSTRef ref >>= \value -> putStrLn value
18:02:27 <seth_> Riastradh: to which ghci responds:
18:02:44 <seth_> Couldn't match `GHC.ST.ST s' against `IO'
18:02:45 <seth_>         Expected type: GHC.ST.ST s b
18:02:45 <seth_>         Inferred type: IO ()
18:02:45 <seth_>     In the application `putStrLn value'
18:02:45 <seth_>     In a lambda abstraction: putStrLn value
18:02:55 <Darius> putStrLn is IO () not ST ()
18:03:16 <seth_> Darius: so what?  If I make a reference, and then extract a value from the reference, the type should be the original value's type
18:03:32 <seth_> I did newSTRef "abc"
18:03:41 <seth_> so the value extracted from the reference should be a string
18:04:02 <seth_> It shouldn't be IO or ST
18:04:02 * Riastradh hmms.
18:04:12 <Darius> @type >>=
18:04:19 <Darius> @type (>>=)
18:04:20 <lambdabot> (>>=) :: Monad a => a b -> (b -> a c) -> a c
18:04:21 <Riastradh> @type (>>=)
18:04:21 <lambdabot> (>>=) :: Monad a => a b -> (b -> a c) -> a c
18:04:23 <Riastradh> Bah!
18:04:54 <Darius> or nicer: M a -> (a -> M b) -> M b
18:04:56 <seth_> Right, that doesn't work.  So, how do I get at the value within the reference?
18:05:10 <Riastradh> The way I showed you.
18:05:14 <Darius> the second parameter of >>= gets the value
18:05:19 <Riastradh> But you can't use 'putStrLn' like you did.
18:05:34 <Darius> The result of the whole >>= is still ST s ()
18:05:39 <Darius> or whatever
18:05:51 <seth_> Yes, and that is useless.  How do I get the value?
18:05:59 <Riastradh> The way I showed you!!
18:06:14 <Riastradh> You just can't return the value with (>>=).
18:06:14 <Darius> runST will give you the ultimate value of the ST computation
18:06:16 <seth_> Riastradh: I did exactly what you showed me, and I showed you the resulting error
18:06:27 <Riastradh> No, seth_, you inserted a usage of 'putStrLn' that doesn't work.
18:06:29 <seth_> Darius: so I apply runST to what?
18:06:41 <Riastradh> 'putStrLn' returns IO ().
18:06:48 <seth_> Riastradh: If I had extracted the value, it would certainly work, su I didn't extract the value.
18:06:50 <Riastradh> The second argument to (>>=) must return ST a, where a can be anything.
18:06:51 <Darius> The result of the string of binds, there are already two examples
18:07:05 <Riastradh> seth_, you -did- extract the value.
18:07:06 <seth_> Riastradh: the problem is not that putStrLn returns an IO.  putStrLn "abc" works fine in that statement.
18:07:21 <Riastradh> @type (>>=)
18:07:22 <lambdabot> (>>=) :: Monad a => a b -> (b -> a c) -> a c
18:07:25 <seth_> Riastradh: No, it appears that I extracted ST value, not value
18:07:34 <Riastradh> a is the monad type.
18:07:37 <seth_> Riastradh: that doesn't help me.  It doesn't get me to the value.
18:07:50 <seth_> No, perhaps runST gets me to the value...
18:07:50 <Riastradh> The function must return something of the type 'a c'.
18:08:04 <Riastradh> IO () is not the same as ST a.
18:08:26 <seth_> Riastradh: you are going around in circles.  I put a string into the reference.  I want to get a string out of the reference.  JUST a string.  not ST string, not IO string, just string
18:08:42 <Riastradh> Yes, and (>>=) applies its second argument to JUST the string.
18:08:54 <Riastradh> 'a b' is 'ST String'.
18:08:58 <seth_> then, if putStrLn "abc" works, putStrLn value should have worked
18:08:58 <Riastradh> 'b' is 'String'.
18:09:05 <Riastradh> No, because:
18:09:06 <Riastradh> @type putStrLn
18:09:07 <lambdabot> putStrLn :: String -> IO ()
18:09:12 <Riastradh> IO is not the same as ST.
18:09:22 <seth_> that's irrelevant.  in exactly the same statement, putStrLn "abc" works.
18:09:38 <seth_> so the problem is not putStrLn, the problem is the type of the argument to putStrLn
18:10:01 <Riastradh> In exactly the same context using:  x >>= \ref -> readIORef ref >>= \string -> putStrLen "abc"   ?
18:10:12 <seth_> right, that works
18:10:37 <Riastradh> Err.
18:10:51 <Riastradh> x >>= \ref -> readSTRef ref >>= \string -> putStrLn "abc"
18:12:03 <Darius> seth_: GHCi doesn't say it works
18:12:28 <Riastradh> It doesn't work for me, either.
18:12:33 <seth_> Darius: let me try it again.  In any event, my question stands.  I want to get "abc" back.
18:12:57 <Riastradh> You can't just return "abc" from (>>=).
18:13:18 <seth_> I don't want to know how _not_ to get "abc", I want to know how to get "abc"
18:13:37 <seth_> there is no point in putting something into a reference if you can't get it out again
18:13:38 <Riastradh> OK, where do you want to be using "abc"?
18:13:47 <Riastradh> You -can- get it out again -- with readSTRef.
18:13:50 <seth_> For this illustration, in putStrLn "abc"
18:14:37 <Igloo> I'm just jumping in in the middle here, but do you want runST (or whatever it's called)?
18:14:45 <Darius> It is runST
18:14:51 <Darius> there's also stToIO
18:14:52 <seth_> Riastradh: ok, lets back up.  explain why readSTRef z (where z was created with newSTRef) give me Couldn't match `STRef s a' against `GHC.ST.ST s1 (STRef s1 [Char])'
18:15:19 <seth_> Darius: when I try runST, I get "variable not in scope:  runST"  I did import Control.Monad.ST
18:15:20 <Riastradh> readSTRef $ newSTRef "foo"    -- like that?
18:15:28 <Riastradh> Or if you insist:
18:15:46 <Riastradh> let { z = newSTRef "foo" } in readSTRef z
18:15:50 <seth_> Riastradh: without the infix operator, please
18:16:07 <Riastradh> readSTRef (newSTRef "foo")   -- ok, like that?
18:16:28 <seth_> Couldn't match `STRef s a' against `ST s1 (STRef s1 [Char])'
18:16:42 <kawfee> > module ADT_List
18:16:44 <kawfee> > ( ListM, 
18:16:49 <Riastradh> Right, because 'newSTRef x' does not return an STRef.
18:16:54 <Riastradh> It returns an ST monad.
18:16:54 <kawfee> what is wrong with that?
18:17:12 <seth_> Darius: I had misspelled Control.Monad.ST, so ignore my previous complaint about runST
18:17:24 <Darius> kawfee: you need a closing )?  What errors are you getting?
18:17:33 <kawfee> Darius: I have that
18:17:37 <Darius> you can't export type synonyms
18:17:39 <seth_> Riastradh: wonderful.  Now, tell me how to apply readSTRef to the result of newSTRef
18:17:39 <kawfee> Syntax error in input (unexpected symbol "ADT_List")
18:17:51 <Riastradh> seth_ - With (>>=).
18:17:53 <Darius> oh you need a where too
18:18:02 <Darius> er nt
18:18:04 <Darius> nm
18:18:14 <Riastradh> newSTRef z >>= \ref -> readSTRef ref >>= \contents -> <process contents>
18:18:24 <Igloo> kawfee: Does it work without the _?
18:18:32 <Igloo> Oh, and this is a .lhs file, right?
18:18:43 <kawfee> Igloo: yes
18:18:53 <seth_> Riastradh: fine, except that everything I try for <process contents> is a syntax error
18:18:54 <kawfee> Syntax error in input (unexpected symbol "ADTList")
18:18:55 <Riastradh> Note that the result of <process contents> -must be- an ST.
18:19:19 <Riastradh> OK, try putting parentheses around the \contents -> blah.
18:19:24 <Igloo> Try adding a space before the (
18:19:24 <seth_> Riastradh: that's the point, that isn't what I want.  I want to get the string as a string, not a string ST.  Does runST do that for me?
18:19:37 <Riastradh> readSTRef returns an ST.
18:19:43 <Riastradh> (>>=) extracts that ST.
18:19:55 <Darius> runST :: ST s a -> a (approx.)
18:20:11 <Riastradh> 'contents' becomes bound to the extracted value in the ST returned by 'readSTRef.'
18:20:27 <kawfee>  anyone?
18:20:31 <Darius> If you are only going to follow it with IO use IORefs
18:20:36 <seth_> Ah, applying runST to the results of readSTRef does get me to "foo"
18:20:51 <seth_> Darius: that's just an example, I don't want to do IO in the general case.
18:20:58 <seth_> but apparently runST does what I need
18:21:19 <Igloo> kawfee: Try adding a space before the (
18:21:30 <Igloo> If that doesn't work give me a URL
18:21:35 <Darius> kawfee: and is module the first thing in the file?
18:22:21 <kawfee> Igloo: it has plenty
18:22:25 <kawfee> Darius: yes
18:22:54 <Igloo> Not in what you pasted above
18:22:56 <kawfee> Darius: no it isn't
18:22:59 <kawfee> I import first
18:23:14 <Igloo> Oh, imports come after
18:23:35 <kawfee> yeah, I see that
18:24:00 <seth_> what's the difference between GHC.STRef and Data.STRef?
18:24:58 <Riastradh> I think they're the same.
18:25:21 <seth_> ok, then I won't worry about that.  :)
18:25:23 <Riastradh> GHC has a lot of alias modules.
18:25:26 <Darius> But use Data.
18:25:53 <Darius> GHC.stuff is usually internal-ish, and certainly GHC specific
18:26:19 <seth_> Darius: so in general I should avoid GHC.XXX unless there isn't another name for it?
18:26:56 <Darius> Yes
18:27:23 <kawfee> Constructor "L" must have exactly 1 argument in pattern
18:27:30 <kawfee> let me post it
18:28:15 <kawfee> http://www.cs.utexas.edu/users/heimlich/ListM.lhs
18:28:26 <kawfee> if someone wouldn't mind
18:28:32 <kawfee> this is my first attempt at making an ADT
18:28:51 <Igloo> You need brackets around the arguments
18:28:55 <Igloo> foo (L x) = ...
18:30:41 <kawfee> thanks
18:40:17 <seth_> how do I fix this:  Inferred type is less polymorphic than expected
18:40:21 <seth_> Quantified type variable `s' escapes
18:40:43 <seth_> This happens if I try to use runST on a function argument, and the arguments type is inferred
18:41:48 <Igloo> What type signature have you given it?
18:41:51 <seth_> Doesn't help if I add a signature to the function
18:41:53 <seth_> as:
18:42:05 <seth_> func :: STRef s [[Char]] -> [[Char]]
18:42:24 <seth_> although it does change the error message
18:42:26 <seth_> slightly
18:42:33 <seth_> Couldn't match `ST s a' against `STRef s1 [[Char]]'
18:42:34 <Igloo> And what is func?
18:42:50 <seth_> so far (obviously for testing):
18:42:52 <seth_> getaline rlines =
18:42:53 <seth_> 		let lines = runST(rlines) in
18:42:53 <seth_> 				lines
18:43:21 <Igloo> Are you sure you have the arguments to ST the right way round?
18:43:51 <seth_> there is only one argument.  the type is   data STRef s a
18:44:08 <Igloo> No, there are 2, s and a
18:44:25 <seth_> well, yes, type arguments, and a is the type of the reference value
18:44:55 <Igloo> OK, so what is func?
18:45:03 <seth_> Ijust pasted it
18:45:11 <Riastradh> func is getaline, I believe.
18:45:14 <seth_> right
18:45:55 <Igloo> Ah, probably the monomorphism restriction. Does getaline rlines = runST rlines work?
18:46:18 <seth_> I'll try...
18:46:43 <seth_> no, same error
18:47:14 <seth_> also ultimately I want to do something with lines, but put that aside for the moment.
18:48:31 <seth_> now, if instead of an argument (rlines) I has an actual reference (not a formal parameter but one whose type is assigned before getaline occurs in the source file) then there is no error
18:58:09 <seth_> I tried using the type displayed by ghci for the concrete value, but it is a syntax error.  Perhaps there is a syntax for using this in a signature?  The type is  forall s. ST s (STRef s [[Char]])
18:58:53 <Riastradh> :set -fglasgow-exts
18:59:00 <seth_> for ghci?
18:59:02 <Riastradh> Then use the forall syntax.
18:59:05 <Riastradh> Yes, in ghci.
18:59:10 <seth_> thanks, I'll try...
19:03:25 <seth_> same error, about s escaping
19:17:46 <Darius> seth_: for getaline you need an explicit type signature because it uses rank-2 types.  It signature is not STRef s [[Char]] -> [[Char]], it's (forall s.ST s a) -> a (i.e. the type of runST, since removing the let's in whatnot, getaline = runST)
19:18:01 <seth_> Darius: yes, I did that.  same message
19:18:09 <seth_> getaline :: forall s. ST s (STRef s [[Char]]) -> [[Char]]
19:18:43 <Darius> That's not what I wrote, I wrote (forall s. ST s a) -> a.  The ()'s are important
19:19:01 <seth_> Darius: hm, I took my type for the actual argument type.  OK, let me try yours...
19:20:32 <Darius> also with the type you just posted, your function can only be the constant function or undefined (I'm pretty sure)
19:21:01 <seth_> Darius: Let me show you the function (I changed the body a bit) and your signature and the message.  Probably changing the body requires changing the signature...
19:21:11 <seth_> getaline :: (forall s.ST s a) -> a
19:21:17 <seth_> getaline rlines = runST(rlines >>= \ref -> readSTRef ref)
19:21:27 <seth_>     Cannot unify the type-signature variable `a'
19:21:27 <seth_>         with the type `STRef s a1'
19:21:27 <seth_>         Expected type: STRef s a1
19:21:27 <seth_>         Inferred type: a
19:21:27 <seth_>     In the first argument of `readSTRef', namely `ref'
19:21:28 <seth_>     In a lambda abstraction: readSTRef ref
19:23:18 <seth_> also, I don't see why my signature won't work.  It is more specific, but that should be ok.
19:24:04 <Darius> Ignoring the a, it is too specific, that's what the earlier errors were saying
19:24:29 <seth_> ok, though I'm not sure why I can't make it more specific.  Another question, I guess.
19:25:04 <seth_> But it doesn't compile either way.
19:28:42 <Darius> the new type is (I believe): getaline :: (forall s.ST s (STRef s a)) -> (forall s.ST s a)
19:29:25 <seth_> same message
19:29:36 <seth_> let me check it again...
19:30:08 <seth_> no, different message:
19:30:16 <seth_>     Cannot unify the type-signature variable `a' with the type `ST s a'
19:30:17 <seth_>         Expected type: ST s a
19:30:17 <seth_>         Inferred type: a
19:30:17 <seth_>     In the application `runST (rlines >>= (\ ref -> readSTRef ref))'
19:30:17 <seth_>     In the definition of `getaline':
19:30:17 <seth_>         runST (rlines >>= (\ ref -> readSTRef ref))
19:30:41 <Darius> oh yeah, I forgot the runST
19:30:44 <seth_> that doesn't make sense to me anyway, as the returned type should be a
19:31:07 <Darius> then it's (forall s.ST s (STRef s a)) -> a
19:31:17 <seth_> ah, it appears to take that  :)
19:33:13 <seth_> now, let me see if I can do what I really need to do.
19:49:08 <seth_> I have this almost working.  Let me show you what I have...
19:49:14 <seth_> getaline :: (forall s.ST s (STRef s [a])) -> a
19:49:23 <seth_> getaline rlines =
19:49:24 <seth_> 		let lines = runST(rlines >>= \ref -> readSTRef ref) in
19:49:24 <seth_> 				let rval = head lines in
19:49:24 <seth_> 						rval
19:49:25 <seth_>   
19:49:42 <seth_> Now I want to add code to do writeSTRef rlines (tail lines)
19:49:53 <seth_> before returning rval
20:20:15 <seth_> I can't get writeSTRef or modifySTRef to actually change the contents of the reference.  They compile, and appear to run, but nothing changes.
20:21:53 <seth_> Any hints?
20:22:33 <Darius> I'm pretty sure I know exactly what's wrong.  Anyways, this is what Riastradh was talking about.
20:22:55 <seth_> OK, tell me, because I was too mixed up about the types to really get it the first time.
20:23:49 <seth_> do you want to see my statement using writeSTRef?
20:24:30 <Darius> What the hey, let's see if they are what I'm expecting.
20:24:52 <seth_> final = tl3 >>= \ref -> modifySTRef ref tail
20:25:07 <seth_> I also tried it with runST(tl3 >>= ...), which didn't seem to matter
20:25:12 <seth_> here is the writeSTRef...
20:25:35 <seth_> final = tl3 >>= \ref -> writeSTRef ref ["ddd","eee"]
20:26:06 <Darius> What's the whole function.
20:26:29 <seth_> that's the whole function.  tl3 is from this:  tl3 = newSTRef ["111","222","333","444"]
20:26:45 <seth_> I invoke final within ghci
20:27:29 <seth_> and this works:  runST(tl3 >>= \ref -> readSTRef ref)
20:29:43 <Darius> so everything is working
20:30:11 <seth_> except that the reference value doesn't change
20:31:35 <Darius> The reference value does change (at least in something using writeSTRef) you are just confused about what the reference is.
20:31:56 <Darius> In Haskell you can always substitute equals for equals
20:32:01 <seth_> Darius: ok, then, tell me what I'm confused about.
20:32:10 <seth_> I was assuming that a Haskell reference is like an ml reference
20:32:28 <Darius> It is -inside the ST monad-
20:32:47 <seth_> Yes, and readSTRef extracts it.
20:33:00 <seth_> and writeSTRef should change it
20:33:31 <Darius> Anyways, runST(tl3 >>= \ref -> writeSTRef ref 5) is the same as runST(newSTRef [...] >>= \ref -> writeSTRef ref 5)
20:33:47 <Darius> and writeSTRef does change it -inside the monad-
20:34:01 <Darius> In ML there is an implicit monad everywhere
20:34:05 <seth_> what is the point of changing it if you can never see it.
20:34:07 <Darius> (or you can look at it that way)
20:34:20 <Darius> you only care about the final result
20:34:25 <seth_> I see nowhere on the call to supply a monad argument
20:34:46 <seth_> tell me how to get the behavior as in ML, then
20:35:15 <seth_> I still see no point to writing a new reference value if that value can never be retrieved
20:35:43 <seth_> and, the STRefs docs talk about the current state thread, which should not change, should it?
20:36:04 <Darius> Each runST is it's own thread
20:36:20 <seth_> ah, ok.  then once runST ends any state is lost?
20:37:07 <Darius> That's one way of thinking about it, it even matches the type of runST :: (forall s.ST s a) -> a
20:37:58 <seth_> what happens if I invoke runST from within another runST ?
20:38:14 <Smerdyakov> You get shot.
20:38:22 <seth_> oh, ok.  :)
20:39:34 <Darius> The type make's it impossible to use a reference from one ST in another.  You can invoke runST in the argument of runST, but it can't read or write any of the first's references (it can pass them around). 
20:40:03 <seth_> So this isn't the way to do what I'm trying to do then.
20:40:57 <Darius> no
20:42:14 <seth_> Let me tell you what I'm trying to do.  I have a list of strings.  I want to use it more or less as if I were doing I/O, applying a get string to it to get head string.
20:42:28 <seth_> But I don't want them all at once as in your usual recursive call on a list
20:42:36 <seth_> I want to be able to extract one as needed.
20:43:03 <seth_> (Or maybe I restructure the code so that isn't required.)
20:43:33 <seth_> Or can I use an explicit monad, and pass it and its state around?
20:45:30 <Darius> You could just use a state monad, but are you sure you want to do it this way.  It not exactly the functional solution.
20:46:05 <seth_> Possibly not, but I'd like to understand the option.  There are parts of what I'm writing that inextricably have state.
20:47:48 <seth_> Control.Monad.State?  And the referenced paper by Jones?
20:49:31 <seth_> What would be a typical appropriate use of the newSTRef type of reference?
20:50:17 <Darius> When you need in-place update for efficiency, but the effect is pure
20:50:27 <Darius> E.g. an in-place qsort
20:50:56 <seth_> Ah, ok; there is no requirement to keep the data (except the result, of course) after completion of the sort.
21:10:25 <SyntaxPolice> seth_: are you trying to understand Control.Monad.State?
21:10:38 <seth_> Yes
21:10:54 <seth_> among other things, of course.
21:11:21 <SyntaxPolice> not sure what you have in front of you, but the documentation in the GHC CVS tree has some examples. I don't think thats online yet (except in my home directory).  The examples are on the wiki, though.
21:12:05 <seth_> Ah, thanks.  I don't know wiki, how do I find them?  They aren't in the ghc distribution tree, or at least grep didn't find them.
21:12:17 <SyntaxPolice> If you come up with a better example for Control.Monad.StateT (better than the one on the wiki) please add it :-)
21:12:33 <seth_> I will, but first I have to understand it.  :)
21:12:38 <SyntaxPolice> seth_: it should be in the source code for the ghc cvs HEAD, but I'll point you to it...
21:12:56 <SyntaxPolice> http://haskell.org/hawiki/StateMonad (thats the wiki one)
21:12:59 <seth_> SyntaxPolice  I can pull cvs HEAD, but I'd like to know how to use wiki also.
21:13:18 <seth_> ah, fantastic!
21:13:48 <SyntaxPolice> Here's the new version of the documentatin, don't bother w/ CVS: http://www.syntaxpolice.org/~ijones/tmp/Control.Monad.State.html
21:14:25 <seth_> Great.  I knew there had to be examples somewhere.  :)
21:15:29 <seth_> I have this program coded in Ruby and in ocaml.  I decided I was never going to convince my commercial clients to use haskell without a serious example.
21:16:02 <SyntaxPolice> seth_: cool!
21:16:17 <seth_> Any pointers for documentation about using theads in Haskell?
21:16:32 <SyntaxPolice> re examples, yes.  There were none for a long time, and I worked to figure out C.M.State myself w/ those examples, so I decided to add them to the docs.
21:16:51 <SyntaxPolice> seth_: sorry, haven't really played w/ threads yet.
21:16:51 <seth_> excellent.  one example is worth a thousand questions.  :)
21:17:15 <seth_> SyntaxPolice:  ok, just point me at a place to start for docs or examples.
21:17:37 <seth_> SyntaxPolice: with a working example I can figure out almost anything.  Except maybe monads.  :)
21:19:17 <Darius> SyntaxPolice: I was thinking recently of writing examples and (some) documentation for each of the monads in Control.Monad
21:23:10 <seth_> SyntaxPolice: I don't see anything for threads in the wiki search.  Do you have a suggestion as to which module to start with?  Or perhaps I should go to the ghc users guide?
21:24:11 <seth_> control.concurrent, perhaps?
21:24:28 <Pseudonym> Yes, Control.Concurrent.
21:24:45 <jemfinch> you can do threads in Haskell?
21:24:49 * Pseudonym nods
21:24:53 <Pseudonym> In GHC, anyway.
21:24:54 <Pseudonym> And hugs.
21:25:09 <jemfinch> how does that work?
21:27:05 <Pseudonym> You use forkIO
21:28:04 <Darius> If you just need threads for speed reasons (e.g. exploiting multiple processors) checkout Parallel Haskell.
21:28:27 <Darius> And combining parallelism and concurrency is Distributed Haskell.
21:28:47 <seth_> Are they stable?  I've seen some messages on the mailing list indicating that parallel may have problems.
21:29:08 <Pseudonym> There are some problems.  Mostly to do with threads + FFI.
21:29:27 <seth_> so if I'm not using FFI then parallel is ok?
21:29:32 <Pseudonym> Haskell threads and POSIX threads are not 1:1, so thread local storage is not necessarily preserved.
21:30:01 <Pseudonym> I don't know about Parallel Haskell, but certainly Control.Concurrent is fine.
21:30:21 <Pseudonym> http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/hashtable/
21:30:24 <Pseudonym> Some example code there.
21:31:43 <seth_> Pseudonym: is forkio part of haskell98, or base?
21:31:52 <Pseudonym> base
21:33:33 <SyntaxPolice> Darius: that would be great.  If you want, I can push them into the GHC Haddock documentation.
21:33:36 <seth_> according to the doc threads are pre-emptive
21:33:45 <jemfinch> SyntaxPolice: you're up late!
21:34:05 <SyntaxPolice> jemfinch: I'm going to bed! I just got back from climbing, ate, showered, checked email... time for sleep.
21:34:49 <seth_> Pseudonym: are what's referred to as communcations abstractions the equivalent of mutexes and things like condition variables?
21:34:57 <Pseudonym> Kind of.
21:35:09 <Pseudonym> Mutexes are not so useful in Haskell.
21:35:13 <Pseudonym> What would they protect?
21:35:28 <seth_> don't know, things specified as strict, I guess.
21:35:41 <Pseudonym> Only things like IORefs.
21:36:04 <Pseudonym> Which is what Control.Concurrent.MVar is.
21:36:13 <Pseudonym> It's like a concurrent IORef.
21:36:14 <Darius> strictness isn't a problem, impurity is
21:36:38 <Pseudonym> There are semaphores, so you can get mutexes and condition variables if you want them.
21:36:47 <Pseudonym> But more likely you use channels and MVars.
21:37:11 <Pseudonym> The hashtable example I mentioned earlier illustrates one way to do it.
21:37:17 <seth_> Pseudonym: I see MVars in the concurrent docs.  where are semaphores?
21:37:20 <Pseudonym> The data structure is handled by a server thread.
21:37:29 <seth_> Pseudonym: one way to do synchronization primitives?
21:37:33 <Pseudonym> Yes.
21:37:39 <Pseudonym> Semaphores are normal semaphores.
21:37:51 <Pseudonym> The ones you're used to if you know any concurrent programming.
21:38:19 <SyntaxPolice> Darius: let me know about Control.Monad... you could add the examples to the wiki or mail them to me, or mail them to libraries@haskell.org, and I'd be glad to do the work of putting them into Haddock and checking them into the GHC tree.
21:39:16 <Darius> SyntaxPolice: I was originally thinking about adding them to the wiki, so they could get worked over and added to
21:39:21 <Pseudonym> SyntaxPolice, I think Control.Monad.Nondet is almost ready for prime time.
21:39:30 <Pseudonym> And Control.Monad.Negate.
21:39:43 <Pseudonym> Can I submit them to you?
21:39:49 <Darius> Oo, Control.Monad.Negate?
21:40:23 <Pseudonym> Yup,.
21:40:29 <Pseudonym> class (Monad m) => MonadNegate m where
21:40:29 <Pseudonym>     mtrue     :: m ()
21:40:29 <Pseudonym>     mfalse    :: m ()
21:40:33 <Pseudonym>     mnot      :: m a -> m ()
21:40:41 <Pseudonym>     mifPred   :: m a -> (a -> m b) -> m b -> m b
21:40:41 <Pseudonym>     mif       :: m a -> m b -> m b -> m b
21:41:09 <SyntaxPolice> Pseudonym: sure.  would you email them to me? ijones@syntaxpolice.org
21:41:17 <Pseudonym> Sure.
21:41:23 <SyntaxPolice> Darius: great. I think the wiki is the place for that.
21:43:40 <SyntaxPolice> Pseudonym: are these new modules? I thought you were talking about docs...
21:44:04 <Pseudonym> Yup, they're new modules.
21:45:09 <SyntaxPolice> Pseudonym: ahh.  I'm probably not the person to send them to then.  I would post them to libraries@h.o and you can mention that I'd be glad to fold them into CVS if they're approved by someone else (probably SimonMar?).
21:45:17 * Pseudonym nods
21:45:20 <Pseudonym> OK.
21:46:08 <SyntaxPolice> cool. I'm off to bed. peace all.
21:47:35 <Pseudonym> Night.
