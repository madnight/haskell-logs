00:00:11 <shapr> andersca: it amuses me that my name ends up being "girl/woman/chick eriksson" in swedish.
00:00:21 <andersca> :)
00:00:30 <ibid> delYsid: tried p < q = (score p) < (score q)?
00:01:40 <shapr> I think WASH has the best animated logos of any Haskell project I've seen.
00:01:57 <andersca> haha
00:01:59 <andersca> I have to agree
00:02:16 <andersca> I like the eyeballs
00:03:03 <shapr> I think you can see WASH in the machines in the first frame
00:04:50 <shapr> the eyeballs really are cool.
00:05:02 * kawfee bounces
00:05:24 * shapr splashes
00:06:45 <witten> what do haskell people use for databases or database alternatives?
00:06:57 <shapr> @fact htoolkit
00:06:58 <lambdabot>  http://sf.net/projects/htoolkit,  postgresql mysql and odbc bindings
00:07:25 <shapr> the @fact plugin in lambdabot is using a postgresql backend
00:08:37 <witten> so in other words, traditional sql databases
00:08:48 <lowks_> shapr: what sites are written using haskell ?
00:08:53 <shapr> There's also HaskellDB which has been discussed on comp.lang.functional
00:09:05 <lowks_> witten: enterprise level dbs
00:09:11 <witten> shapr: cool
00:10:13 <lowks_> shapr: what sites are written using haskell ?
00:10:36 <shapr> lowks_: I know that SyntaxPolice did the OSUOSS forms with CGI.hs
00:10:43 <shapr> I haven't written any sites in Haskell yet...
00:10:45 <shapr> soon :-)
00:11:38 <lowks_> hmmm
00:11:45 <lowks_> looks promising tho'
00:12:05 <lowks_> shapr: prior to this what do you do your web work in ?
00:12:34 <shapr> I've used J2EE, Zope, Perl, some others
00:12:54 * kawfee sproings
00:13:09 * shapr splishes
00:14:16 <lowks_> wow you sure got quite some experience at it
00:14:27 <lowks_> why the move to haskell for web ?
00:14:33 <shapr> Haskell kicks ass ;-)
00:14:44 <lowks_> :^)
00:16:03 <shapr> look at Tom Moertel's "Haskell, Perl, and XSLT" article on kuro5hin.org
00:16:32 <witten> I didn't know people still read kuro5hin.org
00:17:07 <shapr> http://www.kuro5hin.org/story/2002/1/15/1562/95011
00:22:40 <lowks_> shapr: wow 19 pages to print
00:22:45 <lowks_> shapr: whoooppss
00:22:58 <shapr> lowks_: Zope was my favorite web dev platform before I found Haskell.
00:23:55 <lowks_> shapr: hehe i use zope now ..
00:23:56 <lowks_> http://www.cs.kun.nl/~clean/
00:24:11 <shapr> I've seen Clean
00:24:18 <shapr> doesn't it use uniqueness types?
00:25:14 <lowks_> what is that
00:27:33 <shapr> something like monads
00:28:40 <shapr> hi Pseudonym 
00:30:59 <jemfinch> shapr: where's lambdabot's source?
00:31:51 <shapr> @fact source
00:31:52 <lambdabot>  http://sf.net/projects/haskell-libs/, http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/lambdabot/
00:32:43 <lowks_> shapr: is haskell older or python ?
00:34:37 <jemfinch> hmm.
00:34:43 <jemfinch> Python was born in 1991.
00:34:56 <shapr> 1989 xmas vacation
00:35:04 <shapr> Haskell is fifteen years old
00:35:20 <shapr> or was it 1990 xmas vacation?
00:35:20 <jemfinch> shapr: mind giving me the brief overview of how lambdabot's code is organized?
00:35:34 <shapr> jemfinch: what? you want organization too?
00:35:39 <shapr> oh, ok...
00:35:39 <jemfinch> shapr: yeah!
00:35:45 <shapr> Main.hs is the main file
00:35:50 <shapr> IRC.hs has the irc stuff
00:36:00 <shapr> everything else is plugins.
00:37:01 <jemfinch> shapr: ok, so I'm looking at HelloModule now.
00:37:09 <lowks_> wow
00:37:22 <lowks_> jemfinch: shapr : which haskell do you guys use ?
00:37:39 <jemfinch> shapr: what are moduleName, moduleSticky, process, and commands used for?
00:37:42 <lowks_> which implementation i mean
00:37:45 <jemfinch> lowks_: I don't generally use haskell.
00:37:58 <lowks_> jemfinch: what do you use ?
00:37:59 <shapr> lowks_: I mostly use GHC5
00:38:07 <lowks_> shapr: 5 ?
00:38:11 <jemfinch> lowks_: most of my programming these days is in Python.
00:38:17 <jemfinch> lowks_: version 5.
00:38:28 <lowks_> ok
00:38:49 <shapr> jemfinch: moduleName gives you the name for @listmodules
00:38:51 <shapr> @listmodules
00:38:51 <lowks_> The Glorious Glasgow Haskell Compilation System, version 5.04.3
00:38:52 <lambdabot> I have the following modules installed: ["eval","fact","fortune","hello","karma","more","searchml","state","system","topic","type","yow"]
00:39:07 <shapr> jemfinch: sticky tells you whether the module can be unloaded
00:39:18 <shapr> process is where most of the work happens
00:39:30 <shapr> cmd will be the word after the @ sign
00:39:46 <shapr> so when @hello is called, the command should be "hello"
00:40:00 <jemfinch> shapr: can modules be dynamically loaded/unloaded?  i.e., can I write a module after the bot is started and inject it into the running bot?
00:40:03 <shapr> that allows you to easily deal with multiple commands in a module
00:40:08 <shapr> jemfinch: no, not yet.
00:40:38 <shapr> at the moment it requires recompilation
00:40:46 <shapr> runtime loading and reloading is on the TODO list
00:41:32 <jemfinch> is that possible in Haskell?
00:41:53 <shapr> yup
00:42:38 <jemfinch> using Dynamic, or how?
00:42:50 <shapr> http://www.algorithm.com.au/wiki/hacking/haskell.ghc_runtime_loading
00:45:57 <shapr> hiya sjj 
00:45:59 <shapr> wassup?
00:46:03 <sjj> yo
00:46:35 <shapr> sjj: have you written any Haskell yet?
00:46:49 <sjj> not much, taking a small look at Woven, you?
00:46:51 <andersca> yo dennis
00:46:58 <sjj> shapr: just stuff for class, i'm in the middle of a Haskell assignment currently.
00:47:06 <shapr> something nifty?
00:47:24 <sjj> shapr: extending the compiler for a simple programming language
00:47:46 <Marvin--> morning
00:47:58 <shapr> good moron
00:48:16 <Marvin--> tsk
00:48:31 <sjj> shapr: pretty nifty, but I have to write an interpreter for the same language in java :\
00:48:33 <shapr> göd morgon
00:48:40 <shapr> sjj: eww
00:49:51 <sjj> shapr: it doesn't help that the lecturer writes platform specific code and does other annoying stuff that makes me have to fix it before being able to do development at home :\
00:49:58 <Marvin--> shapr: you want to feed the morning? I don't understand
00:50:05 <shapr> oops
00:50:20 <shapr> sjj: platform specific Haskell code?
00:50:40 <sjj> shapr: mainly with respect to loading modules, and the naming of the files
00:51:43 <shapr> maybe he's not used to students with clue? :-)
00:51:52 <sjj> hehe
00:52:13 <sjj> shapr: how was your easter?
00:52:27 <shapr> I wrote Haskell code, played Warcraft III, it was fun.
00:52:38 <sjj> :)
00:53:13 <shapr> I'm working on a bayesian spam filter
00:53:21 <shapr> it's not very good at the moment
00:53:55 <sjj> bayesian?
00:54:09 <shapr> you know bayes' theorem?
00:54:27 <sjj> statistics stuff?
00:54:30 <shapr> yah
00:54:49 <shapr> I read the Paul Graham "plan for spam" articles
00:54:55 <sjj> ahh
00:55:54 <shapr> and there's lambdabot, everybody's favorite code-toy
00:55:55 <shapr> @yow
00:55:57 <lambdabot> YOW!!
00:56:10 <sjj> :P
00:56:37 <shapr> @listmodules
00:56:38 <lambdabot> I have the following modules installed: ["eval","fact","fortune","hello","karma","more","searchml","state","system","topic","type","yow"]
00:56:49 <witten> tmda is so much better than any sort of bayesian or other spam filter
00:57:00 <witten> I get zero spam
00:57:39 <shapr> bah, it's easy to use a spam filter someone else has written ;-)
00:58:10 <witten> yeah, but they won't catch 100% of spam, and often blocks legitimate messages
00:58:44 <sjj> shapr: what's the "yow" module?-)
00:58:54 <shapr> sjj: it's a port of M-x yow
00:59:23 <sjj> ahh, I'm yet to come across that ;)
00:59:31 <shapr> you use emacs?
00:59:34 <shapr> @fortune
00:59:35 <lambdabot> There's no use in having a dog and doing your own barking.
00:59:42 <sjj> shapr: yeah
00:59:49 <shapr> try M-x yow
01:00:51 <sjj> ahhh, another fun emacs toy.  I like playing with M-x doctor ;)
01:00:58 <shapr> yah, I should port that to lambdabot 
01:01:08 <sjj> heehee
01:01:35 <shapr> witten: you are correct. but, I enjoy writing code that does something useful
01:01:45 <witten> shapr: ok :)
01:01:53 <witten> I enjoy not getting spam :)
01:02:01 <shapr> and maybe my spam filter will one day be as good as tmda
01:02:21 <witten> good luck :)
01:03:24 <shapr> witten: plus it took me 127 lines of Haskell to write the initial version
01:03:30 <witten> shapr: cool
01:03:57 <tic> @yow
01:03:58 <lambdabot> Kids, don't gross me off..  ``Adventures with MENTAL HYGIENE''
01:03:58 <lambdabot>  can be carried too FAR!
01:04:08 <tic> @system
01:04:09 <lambdabot> Sorry, I don't know the command "system", try "lambdabot: @listcommands"
01:04:12 <tic> hrm.
01:04:21 <shapr> @listcommands system
01:04:22 <lambdabot> Module system provides the following commands: ["listchans","listmodules","listcommands","join","leave","part","msg","quit","echo"]
01:04:31 <tic> ah
01:04:45 <tic> @system.listchans
01:04:45 <lambdabot> Sorry, I don't know the command "system.listchans", try "lambdabot: @listcommands"
01:04:49 <tic> or what's the syntax?
01:04:51 <shapr> @listchans
01:04:52 <lambdabot> I am on these channels: ["#Haskell","#emacs","#haskell","#joy","#scheme","#think","#widian"]
01:05:00 <tic> okay, directly.
01:05:21 <sjj> why does it list #haskell twice?-)
01:05:29 <shapr> sjj: excellent question
01:05:34 <jemfinch> sjj: capitalization differences.
01:05:48 <jemfinch> shapr: apparently he's taking *any* JOIN and adding it to his list.
01:05:54 <shapr> I think so
01:06:10 <jemfinch> shapr: he should probably only use joins for himself, but his scheme will work if you just ircToLower the channel name.
01:06:35 <jemfinch> shapr: check out supybot's ircutils.toLower function if you don't feel like reading the RFC to get it exactly right :)
01:06:46 <shapr> I think it's his own joins
01:06:51 * shapr tries 
01:06:56 <shapr> @join #hAsKeLl
01:07:00 <shapr> @listchans
01:07:01 <lambdabot> I am on these channels: ["#Haskell","#emacs","#haskell","#joy","#scheme","#think","#widian"]
01:07:06 <shapr> hrm
01:07:12 * jemfinch checks.
01:07:22 <shapr> @listchans
01:07:23 <lambdabot> I am on these channels: ["#Haskell","#emacs","#hASKell","#haskell","#joy","#scheme","#think","#widian"]
01:07:25 <jemfinch> list the channels now.
01:07:29 <shapr> jemfinch: hah, you're right!
01:07:31 <shapr> nifty!
01:07:33 <shapr> ohh
01:07:34 <jemfinch> yup, it's everyone's joins.
01:07:36 <jemfinch> :)
01:07:38 <shapr> I know why that happens
01:07:45 <shapr> it's because of the @topic module
01:08:26 <jemfinch> shapr: ircToLower is basically just a normal toLower that also lowercases "\\[]~" to "|{}^"
01:09:27 <shapr> hm
01:23:54 <shapr> hi Arnia 
01:25:14 <Arnia> Hey
01:26:47 <witten> is (##) a haskell operator? or did WASH make it up?
01:26:54 <shapr> wash made it up
01:26:58 <shapr> you get to do that in Haskell.
01:27:39 <shapr> some time back, rather late at night, we decided to replace the standard cat operator with =^.^=
01:27:43 <witten> how is it different than (.) ?
01:27:49 <witten> haha
01:28:08 <shapr> ## sticks together chunks of generated html
01:28:26 <shapr> so if you had two tables in table1 and table2
01:28:32 <witten> I thought it was for composing functions that happen to be transforms related to html
01:28:38 <shapr> er, maybe so?
01:29:00 <shapr> I don't remember at the moment :-/
01:30:17 <witten> ok
01:30:37 <Arnia> I want a 'boing' operator... ::)
01:32:39 <shapr> Arnia: oh, good idea
01:47:43 <delYsid> (==) = (==) EQ . compare
01:47:47 <delYsid> hmm, what is wrong here?
01:52:42 <Darius> ((EQ ==) (compare x)) y <=> x == y.  You can't compare a function against EQ (you can't compare functions at all)
01:54:02 <Darius> simpler, that says (EQ == compare x), not (EQ == compare x y)
01:57:10 <delYsid> ahh
01:57:11 <Marvin--> delYsid: and you can't use function composition for functions taking two arguments
01:57:21 <delYsid> (==) a = (==) EQ . compare a
01:57:26 <Marvin--> :t (. compare)
01:57:26 <Marvin--> forall a c. (Ord a) => ((a -> Ordering) -> c) -> a -> c
01:58:12 <delYsid> coool!
01:58:33 <Marvin--> delYsid: eh, so, you want to implement Eq in terms of Ord?
01:58:34 <delYsid> since (Ord score) >= Game score
01:58:44 <delYsid> is what my alpha-beta minimax is working on.
01:58:57 <Marvin--> but Ord requires Eq...
01:59:11 <delYsid> I can embed static scoring in the Ord class by defining compare in terms of static scores.
02:00:13 <delYsid> Marvin--: instance Ord Position where
02:00:13 <delYsid>   compare a b | (score a) == (score b) = EQ
02:00:13 <delYsid>               | (score a) <= (score b) = LT
02:00:13 <delYsid>               | otherwise = GT
02:00:14 <delYsid> instance Eq Position where (==) a = (==) EQ . compare a
02:01:04 <delYsid> this means I can remove (maptree static) from the evaluator, and now it just returns the Position of the best possible game.
02:03:37 <Marvin--> delYsid: why not compare a b = compare (score a) (score b)
02:04:02 <delYsid> oh! right!
02:04:14 <Marvin--> this is an evil evil hack
02:04:29 <Marvin--> using Ord to implement Eq is evil evil evil
02:05:24 <delYsid> why?
02:05:39 <Marvin--> because Ord requires Eq to be implemented
02:05:55 <Marvin--> class Eq a => Ord a where ...
02:06:09 <Marvin--> I mean, sure, it works because of mutual recursion and stuff, but it's still evil
02:06:29 <delYsid> is it particularily slow or something?
02:06:52 <Marvin--> no I don't think so, I'm just concerned with the readability
02:06:59 * delYsid thinks its pretty obvious that it only requires Eq on the return type of score
02:07:01 <Marvin--> it's very non-obvious to use Ord to implement Eq since Ord is a subclass of Eq
02:07:40 <Marvin--> delYsid: you're misunderstanding, you're using Eq of score to implement Ord of Position, this is all right, and what you usually do
02:07:46 <Marvin--> but you're also using Ord Position to implement Eq Position
02:07:51 <delYsid> ok, but if I did it the other way round, I'd require more code, isn't that right?
02:08:32 <Marvin--> you'd have   instance Eq Position where x == y = score x == score y ; instance Ord Position where compare x y = compare (score x) (score y)
02:08:35 <Marvin--> that's not a lot of code, is it?
02:08:45 <Marvin--> and it's much easier to read and understand
02:09:40 <delYsid> hmm, ok, thanks
02:14:59 <delYsid> wow, this is very concise now
02:15:35 <Marvin--> note that I don't advocate making the instances one-liners, I just write that way on irc ;)
02:21:14 <Marvin--> wow, this was scary
02:21:23 <Marvin--> TyData t (map (guessType ds) (transpose (as : map extractArgs ps)))
02:21:29 * Marvin-- boggles
02:22:45 <Marvin--> uh
02:26:05 <Marvin--> niiiice, it's working
02:32:13 <delYsid> hmm, I seem to fail to grok classes.
02:32:29 <jemfinch> delYsid: aren't you a Python person?
02:34:46 <Marvin--> haskell isn't like other children when it comes to classes
02:35:04 <Marvin--> a haskell class is more like a java interface
02:35:52 * jemfinch was going to say a haskell typeclass is like a normal class without inheritance.
02:36:20 <jemfinch> which is exactly what Java's interfaces are, of course :)
02:36:28 <Marvin--> but there is inheritance...
02:36:53 <Marvin--> or rather, inheritance is a special case of the contexts
02:37:18 <Marvin--> if you have  class ctx => C T where ..., if ctx only refers to T, you have inheritance
02:37:35 <jemfinch> Marvin--: I should've specified "implementation inheritance"
02:37:42 <Marvin--> jemfinch: ah
02:38:03 <Marvin--> jemfinch: well, obviously you don't have implementation inheritance, but as you said, you have exactly java's interfaces
02:38:14 <jemfinch> yeah :)
02:38:21 <Marvin--> well, expcept for parametric interface inheritance for lack of a better name
02:38:53 <delYsid> class Scoreable a where
02:38:53 <delYsid>   score :: (Num b) => a -> b
02:40:00 <delYsid> why cant I do
02:40:21 <Marvin--> ?
02:40:35 <Marvin--> why can't you do what?
02:40:55 <delYsid> instance Scoreable Position where score p = -- some floating value
02:41:30 <Marvin--> because you're dealing with polymorphism :-)
02:41:45 <Marvin--> the class definition says that score must have the type Num b => a -> b
02:42:23 <Marvin--> if you say score p = 4.2  you are giving it the type Fractional b => a -> b (iirc)
02:42:35 <delYsid> is there a way to allow for any Num return type?
02:42:39 <jemfinch> is Fractional not a Num?
02:43:06 <Marvin--> jemfinch: Num is not Fractional, that's the issue
02:43:44 <Marvin--> delYsid: Num is only guaranteed to work for ints (there's a fromInteger :: Num a => Integer -> a)
02:43:58 <Marvin--> Fractional is guaranteed to work for all rational numbers
02:44:00 <Marvin--> like 4.2
02:44:31 <delYsid> Would Fractional allow for Int?
02:45:10 <Marvin--> no
02:45:18 <Marvin--> :i Int
02:45:38 <delYsid>     Cannot unify the type-signature variable `b' with the type `Float'
02:45:38 <Marvin--> you could use multi-parameter type classes
02:45:52 <Marvin--> class Num b => Scoreable a b where score :: a -> b
02:45:59 <delYsid> Marvin--: which requires fglasgow-exts, hmmm :/
02:46:28 <Darius> But it's a widely implemented extension
02:46:48 <Darius> (I guess widely being nhc and hugs too)
02:46:50 <Marvin--> delYsid: yes, but hugs implements it too, I don't know about nhc
02:47:06 <delYsid> hmm, but not even (Fractional b) works.
02:47:12 <Darius> Also, it's just about guaranteed to be in Haskell II
02:47:36 <delYsid> I have
02:47:36 <delYsid> class Scoreable a where
02:47:37 <delYsid>   scor :: (Fractional b) => a -> b
02:47:37 <Marvin--> then you can say instance Fractional b => Scoreable Position where score p = (some floating point number)
02:47:42 <Marvin--> er, Scoreable Position b
02:48:26 <Marvin--> delYsid: are the scores constant?
02:49:13 <delYsid> constant?
02:49:21 <Marvin--> what does the instance look like
02:49:22 <delYsid> yeah, every position has a static, constant score
02:50:01 <Marvin--> do you have instance Scoreable Position where score (C1 ...) = 1.1 ; score (C2 ...) = 4.7 ; score (C3 ...) = 132.0  et.c.?
02:51:42 <Marvin--> I don't see why you can't just have score :: a -> Float though :)
02:55:10 <delYsid> strange!
02:55:16 <delYsid> instance Scoreable Position where
02:55:17 <delYsid>  scor p = 1.0
02:55:18 <delYsid> works
02:55:37 <delYsid> instance Scoreable Position where
02:55:38 <delYsid>  scor p = score p
02:55:45 <delYsid> fails where score :: Position -> Float
02:56:02 <Darius> Float isn't polymorphic enough
02:56:04 <delYsid> Cannot unify the type-signature variable `b' with the type `Float'
02:56:04 <delYsid>     Expected type: b
02:56:05 <delYsid>     Inferred type: Float
02:56:22 <Marvin--> delYsid: Float != Fractional b => b
02:56:23 <Darius> Float isn't (Fractional a) => a
02:56:33 <Marvin--> delYsid: check :t 4.2 in ghci
02:56:39 <Marvin--> it'll say that 4.2 :: Fractional a => a
02:56:46 <Darius> @type 4.2
02:56:47 <lambdabot> 4.2 :: Fractional a => a
02:56:51 <Marvin--> well, that too ;)
02:57:14 <delYsid> So? do I need to rewrite score such, that it is fractional?
02:57:29 <Darius> you wouldn't need to rewrite any code
02:57:32 <Marvin--> delYsid: I think you should just change your class to have the score function return a Float instead of Fractional a => a
02:57:36 <Darius> just change/remove the type
02:58:08 <Marvin--> delYsid: why do you have both scor and score?
02:58:28 <Darius> Is there any reason you are using a type class anyways?
02:58:42 <Darius> There's no point if there will only ever be one instance
03:00:08 <delYsid> Darius: There is a reason (at least I think its a valid one)
03:01:13 <delYsid> Darius: hmm, maybe you're right.
03:02:28 <delYsid> I currently have evaluate :: (Ord position, Num a) =>
03:02:28 <delYsid> (position -> [position])
03:02:28 <delYsid> -> (position -> Player) -> a -> position -> position
03:02:34 <delYsid> and I wanted to change it into
03:03:03 <delYsid> (Scoreable position, Num a) => ...
03:04:16 <delYsid> and define Scoreable based on Ord
03:04:20 <Darius> Do you (or can you reasonably assume) that you (will) have more than one type of Position?
03:04:57 <delYsid> Darius: hmm, not in a single program, but I thought it would increase modularity...
03:05:20 <Marvin_> grmbl
03:05:34 <Marvin_> first make it work, THEN abstract, is my philosophy :)
03:05:40 <Darius> It would, but there may be better ways.
03:06:01 <Marvin_> in spirit of this, I now have to go clean up my code :P
03:07:51 <Darius> anyways I agree with Marvin.  It's an application of YAGNI.
03:08:06 <Marvin--> and probably KISS too
03:10:05 <Marvin--> hmm, YAGNI is not in VERA
03:11:15 <Darius> VERA?
03:11:43 <Marvin--> Virtual Entity of Relevant Acronyms
03:12:10 <Marvin--> it doesn't seem to be in jargon either, and I've forgotten what it means, grr
03:12:30 <Marvin--> oh, right, you aren't going to need it
03:24:58 <delYsid> instance Eq (Scoreable a) where
03:24:58 <delYsid>     x == y = score x == score y
03:25:00 <delYsid> hmmm, nah
03:25:13 <delYsid> Is it even possible to define Eq and Ord for Scoreable?
03:27:57 <Marvin--> Scoreable is a type class, not a type
03:28:34 <Marvin--> there are extensions that allow you to say  instance Scoreable a => Eq a where ...
03:28:42 <Marvin--> but let me rephrase this. Do you *need* it?
03:30:39 <delYsid> not really.
03:31:02 <delYsid> What I'd like to achieve is that someone using Alphabeta.hs would just need to instantiate score for Scoreable.
03:31:13 <delYsid> without having to redefine the rather obvious Ord and Eq too.
03:31:41 <delYsid> (Scoreable Position) actually
03:32:02 <delYsid> er, forget it, I'll reattemt this when I know more
03:33:40 <Marvin--> but Alphabeta.hs doesn't need Eq and Ord for Scoreable?
03:34:14 <Marvin--> note that a user of Alphabeta may want a completely different definition of Eq and Ord for his types
03:35:15 <delYsid> A user of Alphabeta will need to instantiate Ord such that it Orders based on the score of a position.
03:35:33 <delYsid> that will be the same definition for 99% of the cases, only the scoring function differs.
03:36:25 <Marvin--> but why? can't Alphabeta compare the scores instead of the values, if the user has to guarantee monotonicity anyway?
03:36:55 <delYsid> ?
03:37:25 <Marvin--> the way I understood you, you require that  compare x y == compare (score x) (score y)
03:37:29 <delYsid> ah, well
03:37:33 <Marvin--> for anything that's Scoreable
03:37:44 <delYsid> Marvin--: right
03:37:51 <Marvin--> if so, why do you need to compare the values? Why not just compare the scores?
03:37:58 <Marvin--> and let the user do whatever they want with their Ord instance
03:38:17 <delYsid> well
03:38:18 <delYsid> the problem is:
03:38:35 <delYsid> If you evaluate a given position, you get the best (max/min) score.
03:38:43 <delYsid> If I do maptree score $ ...
03:38:48 <Marvin--> you can't enforce  compare x y == compare (score x) (score y)  in code, so don't even try... if someone created an Ord instance for me, when I instantiated another class, I'd be pissed off
03:38:57 <delYsid> I get a nice gameTree with scores, and maximise works on that and returns a Number
03:39:08 <delYsid> but then I do not know what the moves were leading to this position
03:39:21 <delYsid> So I observed that maximise/minimise only need Ord
03:39:38 <delYsid> if I instantiate Ord for Positions, eval returns the actual Position which was the best.
03:39:59 <Marvin--> the problem is that you introduce redundancy
03:40:47 <delYsid> why? where?
03:41:22 * delYsid thought this "optimisation" was pretty cute
03:42:40 <delYsid> i.e., before that, I had to map over all possible moves, and do a evaluate on all of them, to see which would going to be the best.
03:42:57 <delYsid> Now I can just eval the top-level, and just see what the first move was
03:43:04 <Marvin--> note that you can do this with wrapper types... newtype T a = T a, instance Scoreable a => Scoreable (T a) where ...   instance Scoreable a => Eq (T a) where ...  instance Scoreable a => Ord (T a) where ...
03:44:01 <Marvin--> delYsid: demanding an Ord instance to behave in a certain way together with a certain other type class is a good way to ask for trouble and non-modularity
03:46:07 <delYsid> Well, data Position = Position Some Other Thing
03:46:15 <delYsid> is required anyway to be able to use Alphabeta.hs
03:46:42 <delYsid> so requiring that this type has instances for Ord isn't very unobvious, to me, at least
03:47:03 <Marvin--> so Alphabeta exports a Position type?
03:47:08 <delYsid> no
03:47:16 <delYsid> but it uses a parametric type
03:47:20 <Marvin--> then why is it required?
03:47:28 <delYsid> Data Game position = Game position [Game position]
03:47:28 <delYsid> internally
03:47:37 <delYsid> so that the user can define his own Position type
03:47:44 <Marvin--> but you only demand that the position is Scoreable, don't you?
03:48:12 <delYsid> that would be the ideal, yeal
03:48:33 <Marvin--> and Scoreable has score :: a -> Float?
03:48:45 <delYsid> yup
03:49:09 <Marvin--> so in theory I could invent any old type that instantiates Scoreable, with reasonable values for the score function
03:49:34 <Marvin--> however, in this theory, I need a very peculiar Ord instance to do something, or maybe I don't want to instantiate Ord at all, because it makes no sense to order my values
03:50:03 <delYsid> for Alphabeta you need to be able to Order your scores
03:50:08 <delYsid> thats the whole point of Minimaxing
03:50:15 <Marvin--> The *SCORES* yes, not the *Scoreable values*
03:50:38 <delYsid> er
03:50:53 <delYsid> score :: (Scoreable a) => a _> Float
03:50:54 <delYsid> then 
03:51:01 <Marvin--> yes?
03:51:24 <Marvin--> what do you do with the actual Float values? I don't remember these algorithms
03:51:28 <delYsid> hmm differently
03:51:35 <delYsid> Every position has to have a possible score
03:51:45 <delYsid> and scores have to be Orderable
03:51:59 <Marvin--> scores are always in Ord, Float is in Ord
03:52:25 <delYsid> Marvin--: You take the maximum of your possible alternatives, and the minimum on the alternatives of your opponent
03:52:27 <Marvin--> why do you need Scoreable a => Ord a? To me it sounds like you're trying to take a short cut
03:52:41 <Darius> Scoreable should be: class Scoreable a where score :: a -> Float
03:53:16 <Marvin--> delYsid: so, why do you actually need a Float? Isn't    class Ord b => Scoreable a b where score :: a -> b   enough?
03:53:37 <delYsid> Marvin--: yup
03:53:53 <Marvin--> you don't actually need Num or Fractional or whatever?
03:54:07 <Darius> Wouldn't class Scoreable a where score :: Ord b => a -> b be better.
03:54:31 <delYsid> oh, yeah
03:54:36 <Marvin--> Darius: tricky to instantiate then
03:55:27 <Marvin--> Darius: instance Scoreable Int where score = id   wouldn't work, because  Int != Ord b => b,   however instance Scoreable Int Int where score = id   would work
03:55:35 <Marvin--> Darius: that's the beauty of MPC
03:55:40 <delYsid> All I wanted to do is hide the instances for Ord and Eq on Scoreable positions inside Alphabeta.hs so that only score :: Position -> Ord needs to be instantiated...
03:57:04 <Marvin--> I guess I don't understand what you're trying to do, because I still don't see why you need Scoreable a => Eq a
03:58:03 <delYsid> Marvin--: to tell it to use (score a) == (score b) whenever it wants to compare two Scoreable things
03:58:20 <Marvin--> BUT WHY?
03:58:39 <Marvin--> I, as a user, do not *want* you to define an Eq for my type
03:58:40 <delYsid> Marvin--: So that min and max work as expected on those.
03:58:53 <Marvin--> delYsid: then use wrapper types
03:59:03 <Marvin--> delYsid: that's the *only* way to enforce it
04:00:11 <delYsid> newtype T a = T a
04:00:11 <delYsid> ?
04:01:01 <Marvin--> yes
04:01:05 <Marvin--> can I see your code?
04:01:18 <Marvin--> the T type will never be visible to the user, they don't know it exists
04:01:38 <Marvin--> so the user can happily use their own Eq and Ord, and only worry about instantiating Scoreable
04:06:24 <delYsid> hmm, I dont get this
04:06:59 <delYsid> newtype T a = T a
04:06:59 <delYsid> instance Scoreable a => Eq (T a) where
04:07:00 <delYsid>   x == y = scor x == scor y
04:07:21 <Marvin--> no,   T x == T y = scor x == scor y
04:07:36 <delYsid> oh
04:09:49 <Marvin--> your secret functions would use T all the time, and the top-level function exposed to the user would take Scoreable a:s and wrap them in T and call a secret function
04:12:19 <Darius> what's the definition of scor?
04:12:46 <delYsid> Darius: hmm, not very interesting to paste...
04:13:21 <Marvin--> ... not that I haven't written my share of evil code *cough*
04:13:30 <delYsid> score (Position c _ bd) =
04:13:30 <delYsid>       if checkmate c bd then
04:13:30 <delYsid>         case c of
04:13:30 <delYsid>           White -> -4096
04:13:30 <delYsid>           Black -> 4096
04:13:30 <delYsid>       else
04:13:32 <delYsid>         ((negate $ materialFor Black bd) +
04:13:34 <delYsid>          (materialFor White bd)) + scorePos bd
04:13:45 <Marvin--> delYsid: what's the difference between score and scor?
04:14:10 <delYsid> Marvin--: oh, hmm, ok, if I have to wrap everything, I'll leave that idea. I wanted something pretty :)
04:14:28 <Darius> Yes, it's scor I'm asking about.
04:14:31 <Marvin--> my favourite evil piece of code right now is to use nubBy with an ordering relation instead of an equivalence relation 
04:14:32 <Marvin--> *cough*
04:14:34 <delYsid> Marvin--: just convinience renaming so that I can still load the file in ghci without errors.
04:14:41 <Marvin--> oh
04:16:59 <Marvin--> helper types and wrapper types are heavenly :)
04:17:32 <Marvin--> in my code here I have type representations in a pretty standard way, data Type = TAp Type Type | TyVar Id | ...
04:17:54 <Marvin--> but when dealing with pattern matching, it's much more convenient to see a type as a collection of constructors
04:18:09 <Marvin--> so I convert Types to MyTypes which have infinite values
04:18:10 <Marvin--> really neat
04:19:13 <Marvin--> now I'm getting very tempted to use implicit parameters
04:24:26 <delYsid> Marvin--: nah, you're right
04:24:48 <delYsid> one could want to define (==) in another way, i.e., comparing the Positions itself, not the individual scores.
04:25:01 <delYsid> viewed in that light, the hiding of Eq and Ord really makes no sense
04:26:04 * Darius doesn't get why Sylpheed always thinks I have one unread message in my inbox.
04:26:15 <Marvin--> yay, I'm right :D
04:26:16 <Marvin--> ;)
04:26:36 <Marvin--> Darius: evolution gets that way too, might be imap issues?
04:26:52 <Marvin--> though I haven't had it for a long time, they might've fixed it in recent versions
04:27:07 <Marvin--> thank god for implicit parameters
04:27:19 * Darius has never used implicit parameters.
04:27:35 <Darius> Used just about every other GHC extension though 
04:28:18 <Marvin--> ouch, this was nasty, though... I have to use separate let:s for every implicit parameter
04:28:29 <Marvin--> I can't say let ?decls = ... ; ?t = ... in ...
04:29:22 <Marvin--> it's neat, instead of having my overlap function take three arguments, it can now take two arguments and an implicit parameter, so I can use it infix instead :-)
04:29:30 <Marvin--> p1 `overlap2` p2 = any (p1>-) (allSubsts ?t p1 p2)
04:33:20 <Janni> hya!
05:19:12 <Marvin--> these snooker players are *insane*
05:21:04 <Marvin--> nämen, en jolta
05:21:10 <Jolta> jepp.
05:21:40 <Jolta> marvin: har du kollat vårt projekt på www.haskellwars.com ? =)
05:22:02 <Marvin--> nope, gimme a sec
05:22:25 <Marvin--> who the fuck registered a .com domain!?
05:22:30 <Jolta> We're supposed to be done in three weeks, and I just started on the report. Is that good? =)
05:22:35 <Jolta> I did
05:22:44 <Jolta> and why not? It's cheap...
05:23:05 <Marvin--> what course is this? a project course?
05:23:11 <Jolta> yep
05:23:20 <Jolta> "d3-projekt"
05:24:02 <Marvin--> nice trailer ;)=
05:24:18 <Marvin--> is it afrp?
05:24:24 <Jolta> yes... a bit over the top on the commentary pehaps
05:24:35 <Jolta> yep, or Yampa as they call it these days
05:25:00 <Jolta> you missed the Multi Meeting yesterday, Hanrik Nilsson was over from Yala to talk about it
05:25:09 <Jolta> that's Henrik of course...
05:25:15 <Marvin--> yesterday?
05:25:18 <Jolta> and Yale. =)
05:25:23 <Jolta> yep
05:25:28 <Jolta> thay had it moved, I guess
05:25:43 <Marvin--> hrrm, well, even if it were today, I'd forgotten about it :)
05:25:56 <Marvin--> too bad, Koen recommended it
05:26:07 <Marvin--> I've been busy working on my exjobb all day
05:26:12 <Jolta> Yes, he even attended the first 10 minute. =)
05:26:34 <Marvin--> heh
05:26:42 <Jolta> what was the topic again?
05:26:49 <Jolta> of your exjobb, I mean
05:27:14 <Marvin--> replacing quickcheck with theorem proving
05:27:24 <Marvin--> gaah, god I hate the stupid cal program
05:27:26 <Jolta> Ah, yes, that rings a bell...
05:27:39 <Marvin--> (well, not really, but I'm investigating the possibilities and limitations of it)
05:27:46 <Jolta> cal... never heard of it
05:27:58 <Marvin--> oh it's a shell command
05:28:25 <Marvin--> the annoying thing is that if you write  cal <n>  you get the calendar for *year* <n>, but if you want a particular month you have to write  cal <month> <year>
05:28:55 <Marvin--> so cal 5 gives you year 5, but to get May this year you have to write cal 5 2003, not cal 2003 5
05:29:14 <Jolta> ah, yes, I can see how that's ... annoying.
05:29:47 <Jolta> cal2 = flip cal   ? =)
05:29:58 <Darius> Damn, I was about to say that
05:30:24 <Jolta> >;-)
05:30:42 <Marvin--> ho ho
05:31:24 <Jolta> I guess your average shell doesn't have a "flip" program? 
05:31:40 <Marvin--> no :)
05:31:54 <Marvin--> there's flipdiff, but it does other things :)
05:35:02 <Jolta> and swap is something entirely different
05:36:41 <Darius> well (in bash) flip () { $1 $3 $2; } is a start. flip cal 2003 4 works but flip cal 4 is still cal 4
05:37:31 <Jolta> looks pretty good... I should perhaps switch to a more recent shell than tcsh. =)
05:38:21 <delYsid> nval (Sq f r) = [[0,1,2,3,3,2,1,0],
05:38:21 <delYsid>                  [1,2,3,4,4,3,2,1],
05:38:21 <delYsid>                  [2,3,4,5,5,4,3,2],
05:38:21 <delYsid>                  [3,4,5,6,6,5,4,3],
05:38:21 <delYsid>                  [3,4,5,6,6,5,4,3],
05:38:21 <delYsid>                  [2,3,4,5,5,4,3,2],
05:38:23 <delYsid>                  [1,2,3,4,4,3,2,1],
05:38:25 <delYsid>                  [0,1,2,3,3,2,1,0]] !! (8-r) !! (f-1)
05:38:33 <delYsid> hmm, can anyone think of a more efficient definition?
05:39:10 <Marvin--> bah, it's O(1) :-)
05:45:54 <Darius> wait, that does make sense.
05:47:15 <Marvin--> what makes sense?
05:51:40 <Marvin--> delYsid: what about   let xs = [0,1,2,3,3,2,1,0] in xs !! (8-r) + xs !! (f-1)
05:54:39 <Marvin--> delYsid: you can rewrite that to a stepwise linear function
05:58:59 <delYsid> What is a stepwise linear function?
06:00:36 <Marvin--> hmm, not stepwise, I only have the Swedish name in my head
06:01:04 <Marvin--> piece-wise something?
06:01:31 <Marvin--> anyway, it's a function f that you can split up in intervals so that f is linear in the intervals
06:01:53 <Marvin--> abs is piece-wise linear for example
06:02:22 <Igloo> It's probably only worth it if profiling shows that it is taking a lot of time
06:03:03 <Marvin--> exactly :)
06:03:11 <Igloo> Oh, I missed the start of the conversation  :-)
06:03:40 <Marvin--> from the top of my head, since the table is symmetric, I think you'll get something like...
06:04:03 <Marvin--> nval (Sq f r) = (1 - r`div`5) * (r-1) + (r`div`5) * (8-r)  +  (1 - f`div`5) * (f-1) + (f`div`5) * (8-f)
06:05:29 <Marvin--> let g x = (1 - x`div`5) * (x-1) + (x`div`5) * (8-x) in g r + g f  if that's easier to read ;)
06:05:37 <Igloo> urgle?
06:05:50 <Marvin--> (yes I cheated and used quickcheck)
06:06:53 <Igloo> Oh, having 3 repeated will make it ugly
06:07:07 <Marvin--> yeah
06:07:26 <Marvin--> I mean, this is the brute force function that you get from a simple algorithm that creates piece-wise linear functions
06:08:32 <delYsid> cute!
06:08:33 <delYsid> thanks
06:09:33 <Igloo> I suggest you profile first before getting too excited  :-)
06:10:02 <Marvin--> ;)
06:10:25 <delYsid> well, its more concise, that by itself, is worthwhile
06:10:43 <Marvin--> delYsid: if you want conciseness and understanding, use the xs one! :)
06:10:52 <Igloo> It looks about the same as the list one to me
06:11:09 <Marvin--> Igloo: did you see the original list-in-list function?
06:11:36 <Igloo> Yes,but I meant the single list one
06:11:49 <Marvin--> nod
06:12:15 <Marvin--> delYsid: note that you might as well use r-1 instead of 8-r, it's symmetrical
06:16:07 <delYsid> hmm, right
06:17:48 <delYsid> let r = 1
06:17:51 <delYsid> er
06:19:55 <Marvin--> well, you can't replace 8-x with x-1 in the non-list version
06:21:19 <Igloo> (14 - (abs (r - 3) + abs (r - 4) + abs(f - 3) + abs(f - 4))) `div` 2 might be faster
06:22:48 <Marvin--> :)
06:23:16 <Marvin--> except that it's incorrect
06:23:21 <Igloo> Is it?
06:23:30 <Marvin--> Falsifiable, after 0 tests:
06:23:30 <Marvin--> 3
06:23:30 <Marvin--> 4
06:23:43 <Marvin--> i.e. f = 3, r = 4
06:24:18 <Marvin--> the original function is = 5 for those coordinates, your function is = 6
06:25:32 <Igloo> Oh, my r and f are 0 based
06:25:37 <Marvin--> ah
06:25:57 <Marvin--> right, so -4 and -5 instead
06:25:58 <Marvin--> then it works
06:26:18 <Marvin--> note that my function will also be prettier for 0-based r and f ;)
06:26:45 <Igloo> also? You think 3 and 4 makes it prettier than 4 and 5?  :-)
06:27:01 <Marvin--> no but your function is prettier than mine :)
06:27:14 <Igloo> Ah  :-)
06:27:29 <Marvin--> both have the problem that they bear no resemblance to the problem they solve though ;)
06:28:38 <Igloo> It think mine would be reasonable for a 9 by 9 board
06:28:55 <Igloo> It might be a bit late to convince the world chess should be played on a 9x9 board, though
06:29:09 <Marvin--> yeah
06:29:32 <delYsid> yay, score is considerably faster now
06:29:58 <delYsid> (not because of nval though, the speedup is related to me scoring pawns manually now)
06:30:05 <Marvin--> :)
06:51:36 <delYsid> hmm, short-algebraic parser would be next logical step...
06:52:38 <delYsid> shapr?
07:06:38 <delYsid> hmake -nhc98 -hat play.hs
07:06:52 <delYsid> Fail: user error
07:06:52 <delYsid> Reason: Can't open any of:
07:06:52 <delYsid>  Hat/Hat/PreludeBasic.hi
07:06:52 <delYsid>  ./Hat/PreludeBasic.hi
07:06:52 <delYsid>  /usr/include/nhc98/base/Hat/PreludeBasic.hi
07:06:53 <delYsid>  /usr/include/nhc98/hat/Hat/PreludeBasic.hi
07:06:55 <delYsid>  /usr/include/nhc98/Hat/PreludeBasic.hi
07:06:57 <delYsid>  when trying to read Hat.PreludeBasic.
07:06:59 <delYsid> hmmm
07:15:03 * shapr awakens
07:15:39 <Riastradh> Hi.
07:15:41 <delYsid> hmm, why does hat not want to compile chess?
07:16:04 <andersca> morning shapr
07:16:11 <shapr> g'morning andersca 
07:16:16 <Marvin--> ugh, I really should prett-print this too
07:16:20 <Marvin--> pretty even
07:16:26 <Marvin--> > let DFun _ _ ms = expandPatterns example zipfun in mapM_ (print.fst) ms
07:16:27 <Marvin--> [PCon "Cons" [PVar "x",PVar "xs"],PCon "Cons" [PVar "y",PVar "ys"]]
07:16:27 <Marvin--> [PAs "x1" (PCon "Nil" []),PVar "y1"]
07:16:27 <Marvin--> [PAs "x1" (PCon "Cons" [PVar "z1",PVar "z2"]),PAs "y1" (PCon "Nil" [])]
07:16:27 <Igloo> Does anyone remember a message to one of the lists from Wolfgang about porting GHC recently?
07:17:06 <Marvin--> you mean about porting it to macosx?
07:17:40 <Igloo> Yes
07:17:50 <Igloo> Any idea which list it was or when?
07:18:07 <Marvin--> I have one on g-h-u from March
07:18:29 <Marvin--> but seeing as that's the only one I'm on except for libraries@h.o...
07:19:25 <Igloo> I'm thinking of one where he gave a description of what he'd done to successfully port it
07:19:55 <Marvin--> you're not thinking of pesco's port to linux-powerpc?
07:20:09 <Igloo> Possibly
07:20:14 <Igloo> @fact pesco
07:20:15 <lambdabot> Nothing
07:20:23 <Igloo> What's his name?
07:20:36 <Marvin--> Sven Moritz Hallberg, Apr 11 on g-h-u
07:20:45 <Igloo> Ta
07:21:14 <Igloo> Ah, yes, that's the one, ta
07:21:39 * Marvin-- grumbles about implicit parameters
07:21:53 <Marvin--> I want to define several implicit parameters in the same let :/
07:22:06 <Marvin--> does the old 'with' syntax allow that?
07:22:27 * Igloo knows virtually nothing of IPs
07:23:19 <delYsid> OH! debian hat-bug...
07:23:40 <delYsid> /usr/include/nhc98/hat/ is not /usr/include/nhc98/Hat/
07:23:53 <Marvin--> ick
07:28:34 <delYsid> hmm, nah, hat doesn't compile my executable...
07:28:49 <delYsid> any other nice tracers you would suggest (for someone who is really GUI-impaired)
07:29:17 <Marvin--> I like the plain simple Observe module in -package util
07:29:24 <SyntaxPolice> morning all
07:32:17 <vincenz> Hello!
07:32:40 <Riastradh> Hi!
07:33:12 <vincenz> You're on a lot of channels Riastradh 
07:33:39 <Riastradh> I am.
07:33:44 <vincenz> Well, not today
07:33:49 <vincenz> but usually
07:33:49 <Riastradh> ?
07:33:59 <vincenz> scheme, ocaml, haskell, emacs
07:34:06 <vincenz> all those fp's plus editors
07:34:07 <Smerdyakov> The sign of a dilettante ;)
07:34:09 <Riastradh> I'm on a lot more channels than that.
07:34:43 <Riastradh> #joy, #twisted, #opendarwin, #dylan, #sisc, #scsh, #squeak, #macdev, to name a few more.
07:35:15 <Marvin--> arhg, I don't see the real difference, as far as implicit parameters go, between these two programs
07:36:11 * vincenz grins at Smerdyakov 
07:36:26 <Igloo> EWORLDTOOSMALL # Reading a friends quotes file and seeing delYsid and shapr appear
07:37:29 <Marvin--> from #debian or something?
07:37:43 <Marvin--> or #python?
07:38:17 <Igloo> #perl
07:38:58 <Smerdyakov> Ha! They should be banished for being there!
07:38:59 <Marvin--> eeew
07:39:05 <Riastradh> EWWWW!
07:39:16 <Riastradh> What were they doing -THERE-!?
07:40:00 <Marvin--> making line noise I suspect
07:41:19 <delYsid> oh! that is very inefficient...
07:41:20 <delYsid> pieceAt (Board wkss bkss _) sq =
07:41:20 <delYsid>         pieceAtWith White (pieceAtWith Black Nothing bkss) wkss
07:41:20 <delYsid>   where
07:41:20 <delYsid>     pieceAtWith c n [] = n
07:41:20 <delYsid>     pieceAtWith c n ((k,s):xs) =
07:41:22 <delYsid>        if s==sq then Just (c,k) else pieceAtWith c n xs
07:41:36 <delYsid> Does anyone see a reason why this should take 43% of all computation and allocation time?
07:42:30 <Marvin--> how long are bkss and wkss typically?
07:42:38 <Marvin--> it looks like this one's O(length bkss * length wkss)
07:42:54 <Marvin--> are they the pices?
07:42:59 <Igloo> O(length bkss + length wkss) isn't it?
07:43:13 <Marvin--> oh, right
07:43:20 <Smerdyakov> I think Omega(something) would be more helpful =)
07:43:28 <Marvin--> duh
07:43:34 <delYsid> Marvin--: yeah
07:43:41 <delYsid> each list is 16 entries at most...
07:43:51 <Smerdyakov> I hate it when people abuse O() to try to say how expensive a computation is. =)
07:44:00 <Igloo> You should certainly be able to write it more readably with something like lookup
07:44:49 <Igloo> And mplus, actually
07:45:06 <Marvin--> delYsid: isn't it just a case of this function being called all the bloody time?
07:45:21 <Igloo> Oh, does lookupBy not exist?
07:45:41 <Marvin--> nope
07:45:51 <delYsid> Marvin--: that could also be it...
07:46:07 <delYsid> but the profiler didn't include a call-count...
07:46:18 <Marvin--> Smerdyakov: don't you mean \Theta... \Omega is just the lower bound, and the lower bound here is obviously 1
07:46:42 <Marvin--> Smerdyakov: not that it matters since O(32) = O(1) :)
07:46:49 <Igloo> It's the same as     (fmap (\x -> (White, x)) $ lookup sq $ map (\(x, y) -> (y, x)) wkss) `mplus` (the same thing for black)     I think
07:47:13 <Igloo> Which I think should be quite readable if you call (\(x, y) -> (y, x)) flip
07:47:22 <Smerdyakov> Marvin--, no! I like to be polite with my bounds!
07:47:23 <Marvin--> Igloo: ynk, is there no function that does the \(x,y) -> (y,x) ?
07:47:32 <Marvin--> Igloo: flip is something else!
07:47:44 <Igloo> Oh, swap then. Whatever the normal name for it is.
07:47:50 <Smerdyakov> Marvin--, and you can give a tighter bound that is actually useful.
07:47:55 <Smerdyakov> Marvin--, whereas you can't with O()!
07:48:08 <Marvin--> yeah yeah yeah :)
07:49:19 <Marvin--> Igloo: too bad you can't write tuples as sections
07:49:20 <delYsid> @type mplus
07:49:37 <Igloo> In fact it's lookup sq $ map (\(x, y) -> ((y, White), x)) wkss) `mplus` ...
07:49:41 <Igloo> Marvin: Yeah  :-(
07:50:03 <Igloo> It's in Monad
07:50:08 <Igloo> Monad> :t mplus
07:50:08 <Igloo> mplus :: MonadPlus a => a b -> a b -> a b
07:50:55 <Igloo> Basically if one argument is Just x then that'll be the result, otherwise Nothing. The case when both are Justs can't happen here (I assume)
07:51:02 <delYsid> so, if the first expression does not return Just, the second one is executed?
07:51:08 <vincenz> ???
07:51:56 <Marvin--> "Welcome to the world of Haskell, if you thought you already knew about abstraction - HAH!"
07:52:36 <Igloo> Monad> Nothing `mplus` Just 3
07:52:37 <Igloo> Just 3
07:53:11 <vincenz> I don't know shit about haskell, so..
07:54:00 * Marvin-- likes monad transformers
07:54:16 <Marvin--> monad transformers are almost for Haskell what patterns are for object oriented languages
07:55:11 <Smerdyakov> I think programming language idioms are almost for Haskell users what bizarre fetishes are for sexual deviants. ;)
07:55:24 <Marvin--> that's another way to put it
07:58:11 <Marvin--> yeech, this is ugly
07:58:23 <Marvin--> [ (ps,r) | (PCon "," ps,r) <- (process t [] [ (PCon "," ps,r) | (ps,r) <- ms ]) ]   suggestions for improving that? :/
07:58:39 <Marvin--> the adding and removing of PCon "," is really ugly
08:00:47 <delYsid> pieceAt (Board wkss bkss _) sq =
08:00:47 <delYsid>     lookFor White wkss `mplus` lookFor Black bkss
08:00:47 <delYsid>   where
08:00:47 <delYsid>   lookFor c xs = lookup sq $ map (\(x, y) -> (y, (c, x))) xs
08:00:56 <delYsid> Igloo: cute, thanks, its alot more readable now at least
08:01:32 <delYsid> Marvin--: what are you writing, if I may ask?
08:01:50 <Marvin--> delYsid: this particular code expands pattern matching to remove overlaps
08:01:52 <Segora> hi
08:05:35 <Igloo> I'd probably write that as strip_pcon_comma $ process t [] $ add_pcon_comma ms
08:08:20 <Marvin--> in the haskell spirit, that'd be map strip_pcon_comma $ process t [] $ map add_pcon_comma ms
08:08:25 <Marvin--> and I'm almost back to where I started
08:08:57 <delYsid> total time  =      203.30 secs
08:08:59 <delYsid> total alloc = 37,573,527,188 bytes
08:09:25 <Marvin--> map remT $ process t [] $ map addT ms   might be acceptable though
08:09:30 <delYsid> What?! Am I reading this wrongly, or did it really alloc 36 GB in 130 secs?
08:10:10 <Marvin--> cute
08:10:20 <Darius> you are reading it wrongly.  It's 36 GB in 203 secs.  (Unless you are looking at something else)
08:12:07 <delYsid> Darius: ah yeah, ment that...
08:12:25 <delYsid> pfft, this looks like a tremendous waste somewhere
08:13:00 <delYsid> and pieceAt now consumes 62% computing, and 72% alloc time
08:13:26 <delYsid> hmm, is it possible that the definition using mplus is alot more inefficient?
08:13:52 <Igloo> Yes
08:14:49 <delYsid> :(
08:23:04 <Darius> delYsid, try a biographical profile of pieceAt before and after the mplus version
08:30:43 <andersca> wow, joel was here?
08:41:59 <shapr> who's joel?
08:45:47 <shapr> @yow
08:45:48 <lambdabot> I've been WRITING to SOPHIA LOREN every 45 MINUTES since JANUARY 1ST!!
08:46:04 <shapr> good morning #haskell!
08:46:15 <Igloo> Hey shapr  :-)
08:47:03 <vincenz> Shapr!
08:47:22 <shapr> Igloo: what's the irc nickname of the person with the quotefile?
08:47:24 <shapr> hi vincenz 
08:47:25 <shapr> wassup?
08:47:55 <Igloo> Kosai, probably
08:47:58 <shapr> Igloo: delYsid and I are in the same quotefile only on emacswiki that I'm aware of...
08:48:30 <shapr> unless delYsid has gotten into the #twisted or #python quotefiles
08:49:17 <Igloo> Oh, I was talking rubbish earlier, it was #emacs
08:50:09 <Igloo> About the 16 year old perl6 hacker
08:50:24 <shapr> ayrnieu?
08:50:28 <kosmikus> hi vincenz
08:50:35 <kosmikus> did you succeed?
08:50:44 <Igloo> If you say so
08:51:06 <sjj> ayrnieu is 16?!
08:52:27 <shapr> not anymore ;-)
08:52:44 <sjj> ahh, in the old days of #python?-)
08:52:50 <shapr> yah
09:01:47 <vincenz> window 2
09:02:06 <shapr> vincenz: no! I won't do it!
09:04:19 <shapr> moo
09:04:20 <vincenz> I'm sorry, still getting used to irssi
09:04:25 <shapr> vincenz: try erc!
09:04:28 <vincenz> By the way, I installed Gentoo on my home box
09:04:33 <shapr> neat,
09:04:36 <shapr> what do you think?
09:04:36 <vincenz> shapr: : this is not my pc, it's iusris'
09:04:41 <vincenz> it's neat
09:04:42 <vincenz> :)
09:04:47 <vincenz> much better than debian
09:04:50 <vincenz> the install was a WHIZ
09:04:53 <shapr> hah, I disagree
09:05:16 <vincenz> hmm, I tried installing debian a while back and it would never take my ethernet card, so I didn't really get anywhere
09:05:30 <kosmikus> vincenz: good to see another Gentoo Haskeller
09:05:35 <delYsid> hmm, can anyone suggest a idiom, how to parse algebraic chess notation?
09:05:42 <vincenz> kosmikus: I'm an ocamler :P
09:06:09 <kosmikus> vincenz: never mind ;)
09:06:19 <vincenz> I never tried haskell, I'm sure I could read some of it but, just a little part
09:06:54 <Igloo> del: It's probably simple enough you just want pattern matching
09:06:58 <kosmikus> vincenz: anyway, if you have any comments about Haskell-related ebuilds in Gentoo, make sure to complain to me about it ...
09:07:03 * Riastradh basks in Haskell's syntactic elegance, looking down at the wretched syntax of OCaml.
09:07:04 <Igloo> Maybe apply lines first
09:07:25 <delYsid> Igloo: ?
09:07:49 <delYsid> example: Nef3
09:07:53 <Igloo> del: Maybe I misunderstand, can you give an example of something you want to parse?
09:08:10 <vincenz> The reason I hang out in Haskell is because it's also an FP-language plus it's a friendly channel :).  Ocaml is always quiet
09:08:11 <delYsid> Qaxd4
09:08:22 <delYsid> d4
09:08:26 <vincenz> Besides, the legendary shapr  invited me here
09:08:27 <delYsid> exd5
09:08:32 <shapr> I'm legendary?
09:08:42 <vincenz> well, now you are
09:08:44 <vincenz> I made you legendary
09:08:46 <shapr> oh, cool!
09:08:51 * shapr cheers for legendary status
09:08:57 <shapr> @fact shapr 
09:08:58 <vincenz> *dubs shapr  legendary*
09:08:59 <lambdabot> Shae Erisson, wrote the factoid plugin for lambdabot, 31 years old, good for the karma
09:09:06 <shapr> @fact shapr now dubbed legendary
09:09:07 <lambdabot> set shapr to now dubbed legendary
09:09:12 <vincenz> @karma+1 shapr 
09:09:13 <lambdabot> Sorry, I don't know the command "karma+1", try "lambdabot: @listcommands"
09:09:20 <mgoetze> @karma+ shapr
09:09:21 <lambdabot> shapr's karma has been incremented.
09:09:21 <Igloo> Oh, I'd forgotten about the e up there. I'd suggest parser combinators, but I'm not sure it's a predictive grammar
09:09:23 <shapr> yay
09:09:25 <vincenz> Ah!
09:09:31 <vincenz> @karma+ shapr
09:09:32 <lambdabot> shapr's karma has been incremented.
09:09:49 <Riastradh> shapr, have you made my changes to the karma module work?
09:09:58 <shapr> nope, not yet
09:10:03 * Riastradh grumbles.
09:10:53 <vincenz> I hadn't realized I liked linux so much.
09:10:56 <delYsid> yah, I think I'll need to use Parsec
09:11:14 <shapr> vincenz: linux is very nice
09:11:33 <vincenz> I can't ssh into my own box yet, because it's not setup yet and my brother is at home so I can't leave linux on 24/7
09:11:45 <shapr> teach your bro how to use linux
09:11:49 <vincenz> But iusris gave me an account on his pc, cause we're working a coupla projects together
09:11:57 <vincenz> shapr: no way, he's not into computers
09:11:59 <vincenz> AT ALL
09:12:00 <vincenz> Anyways
09:12:02 <vincenz> check out
09:12:08 <vincenz> codedbliss.com/abstractoasis
09:12:14 <shapr> vincenz: then that's an even better reason to show him how linux is just as simple
09:12:32 <vincenz> shapr: problem #2 my pc makes noise, and he has his bed in the living of our appartement
09:12:55 <vincenz> I work, he studies, we live together
09:13:09 <shapr> I find it relaxing to listen to six or eight case fans while sleeping. I'm not sure that's a good sign.
09:13:09 <vincenz> But I didn't know he'd come live with me so I had gotten a 1-bdrm appartement
09:13:20 <vincenz> it's not the casefan, it's the cpufan
09:13:27 <vincenz> after a while it gets pretty loud
09:13:38 <shapr> oh, I have cpu fans running too
09:13:38 <vincenz> even though it's a good one (dragonorb 3 I think
09:14:45 <vincenz> anyways check out the site mentioned above
09:14:48 <shapr> I did
09:14:51 <shapr> looks nice
09:14:54 <vincenz> :)
09:15:00 <vincenz> it's just started, we have to work on more stuff
09:15:10 <vincenz> but we both barely have any time atm
09:15:24 <vincenz> anyways, he setup an account on his pc for me, and hence I'm here chatting at work 
09:16:03 <vincenz> Not that that is the point, but it's handy to ask questions
09:16:37 <shapr> I want to steal the enscript support on abstract oasis
09:16:42 <shapr> for HaWiki
09:18:31 <vincenz> it's really easy
09:18:46 <vincenz> the only prob is that enscript doesn't have support for ocaml yet (it does for haskell) so I'm going to have to implement that
09:18:55 <vincenz> is haWiki moinmoin?
09:18:58 <shapr> yup
09:19:06 <vincenz> if so, the processor can be found on the official moinmoin site
09:19:10 <shapr> nifty
09:19:12 <vincenz> it's called syntax.py
09:19:32 <vincenz> Just copy it into your /usr/lib/pythonxxx/site-packages/MoinMoin/processor(s?)
09:19:57 <vincenz> edit it so it supports haskell (it checks the types, enscript supports many more types than the .py file allows....)
09:20:09 <vincenz> and you're set :)
09:20:20 <shapr> spiffy, thanks
09:22:07 * vincenz wishes people would walk as much on ocaml as they do here on haskell :(
09:24:01 <vincenz> *sniffs*
09:25:39 <kosmikus> bye all
09:27:36 <shapr> vincenz: well, start talking
09:29:58 * SyntaxPolice reorganized wiki front page
09:32:19 <delYsid> wow, Parsec is really neat...
10:14:05 <vincenz> sorry, had to show something to my boss
10:14:34 <vincenz> how's the thingy working with enscript?
10:25:36 <delYsid> hmm, if I need some additional information for parsing, is there a way to pass that to parse as initial state somehow?
10:28:37 <Darius> yes
10:29:30 <Darius> one of the runParser like commands takes a state parameter, and GenParser takes a type for the state
10:30:31 <delYsid> ah! runParser, tnx
11:29:07 <delYsid> hmm
11:29:13 <delYsid> is there a way to overrule try?
11:29:36 <hdaume> delYsid: what do you mean:
11:29:43 <delYsid> My current way of doing things seems to require that I use try alot, but I'd like to continue to fail at certain points explicitly, without another retry...
11:30:58 <delYsid> to = try (takes >>= \(sq,pc) -> promoting sq >>= \pp ->
11:30:58 <delYsid>           return (Move sq pc pp)) <|>
11:30:58 <delYsid>      try (try square >>= \sq -> promoting sq >>= \pp ->
11:30:58 <delYsid>           return (Move sq Nothing pp)) <|>
11:30:59 <delYsid>      (square >>= \sq -> return (Move sq Nothing Nothing))
11:31:07 <Darius> I don't think Parsec has cut, and using try a lot isn't good.
11:36:07 <delYsid> hmmmm
11:36:41 <hdaume> hrm...i dunno...i can't read that code well enough to suggest something.  in general, though, you could write a 'trySome :: (Exception -> Bool) -> IO a -> IO (Either Exception a)   where it only gives you 'Left e' when the predicate is met and otherwise just lets the error fall through.  either that, or write some sort of join combinator that uses try
11:38:33 * delYsid scratches head and decides to give himself a break
11:38:45 * hdaume thinks that sounds reasonable :)
11:50:23 <delYsid> hmmm, braintwisting
11:50:49 <delYsid> nearly every component of a move can be left out, this makes it quite tricky to parse...
11:52:22 * Igloo doesn't think parsec is the right tool - I'd probably write some backtracking parser combinators
11:52:45 <delYsid> [kind] [[file [rank]]|rank] [x] rank file [= kind]
11:53:07 <delYsid> or something like that...
11:53:15 <delYsid> Igloo: I'd too, if I'd know what that is :)
12:32:45 <jemfinch> shapr, you in?
12:50:18 <hdaume> delYsid: i'd just use the regex library, since it seems that what you're parsing is regular
12:54:39 * delYsid never used regexps in haskell before
12:54:57 <hdaume> they're pretty easy
12:55:55 <hdaume> you probably just want something like mkRegex "([^\s]+)? ([^\s]+ ([^\s]+)?)?" ... and so on
12:56:08 <hdaume> anything you put in parens will be matched out in the result of matching the regex
12:56:13 <hdaume> and just use ? for the optional ones
12:57:14 <hdaume> you could probably get away with using .+ instead of [^\s]+ if you used ^ and $
12:57:39 * delYsid struggles finding mkRegex...
12:57:48 <hdaume> Text.Regex or something
12:58:00 <delYsid> *Parse Regex> :t mkRegex
12:58:00 <delYsid> <interactive>:1: Variable not in scope: `mkRegex'
12:58:02 <delYsid> hmm
12:58:30 <hdaume> ue Text.Regex, not Regex
12:58:43 <hdaume> or use RegexString
13:01:31 <hdaume> Prelude Text.Regex> matchRegexAll (mkRegex "^([^ ]+)( [^ ]+)?$") "hello you"
13:01:32 <hdaume> Just ("","hello you","",["hello"," you"])
13:01:32 <hdaume> Prelude Text.Regex> matchRegexAll (mkRegex "^([^ ]+)( [^ ]+)?$") "hello"
13:01:32 <hdaume> Just ("","hello","",["hello",""])
13:15:13 <delYsid> re = mkRegex
13:15:13 <delYsid>      "([QKRBNP])?([a-h][1-8]?|[1-8])?([x])?([a-h][1-8])(=[QKRBNP])?([+])?"
13:15:34 <delYsid> wow, thats it, exactly... now I just need to take the values out from the result list...
13:15:45 <hdaume> cool :)
13:17:21 <Igloo> Do you not want [a-h]?[1-8]?   (optional rank, optional file)?
13:17:58 <delYsid> ah, yeah
13:41:51 <Riastradh> Is there a standard functional negation or complement function?
13:42:21 <mgoetze> Riastradh: you mean for booleans?
13:42:27 <Igloo> There's negate, or Bits.complement (IIRC)
13:42:31 <Riastradh> No, note the 'functional' bit.
13:42:39 <Riastradh> i.e.:  complement f <=> \x. not $ f x
13:42:48 <Igloo> Oh, you want to get the inverse of a function?
13:42:56 <Igloo> Oh, I see
13:43:06 <Riastradh> The functional complement of a function, a functional negation function, whatever the name is.
13:43:11 <Riastradh> All I care about, actually, is the name.
13:43:13 <Igloo> (not .) for single argument functions
13:43:25 <Riastradh> So there isn't a standard one?
13:43:43 <delYsid> No instance for (Show (Kind, [Char], Bool, [Char], [Char], [Char]))
13:43:45 <delYsid> hmm?
13:43:59 <delYsid> did I overdo the tuple thingie? :)
13:44:05 <Igloo> (not .) is shorter than complement, so you wouldn't gain much by defining it  :-)
13:44:46 <Igloo> del: There's a bug that only defines Show for tuples up to 5 (I think, which would fit what you're seeing)
13:45:04 <Igloo> I assume you do have a Show Kind instance?
13:45:10 <delYsid> yup
13:45:20 <Igloo> I think it's that bug then
13:45:35 <hdaume> ther eare no built in show instances for big tuples
13:45:48 <Igloo> Ooops, I mean "There's a bug that Show is only defined for ..."
13:46:12 <hdaume> though i thought the report required up to 7tuples....
13:47:39 <Igloo> Oh, I thought the report required tuples of any size
13:48:03 <hdaume> Igloo: i meant it doesn't require show instances of them
13:48:42 <Igloo> So did I. I always thought it was an implementation bug.
13:49:26 <hdaume> ah: he Prelude and libraries define tuple functions such as zip for tuples up to a size of 7.
13:49:33 <hdaume> Ifrom 6.1.4 of the report
13:49:37 <hdaume> but it doesn't say anything about instances
13:49:44 <hdaume> oh wait
13:49:50 <hdaume> Each tuple type has a single constructor. All tuples are instances of Eq, Ord, Bounded, Read, and Show (provided, of course, that all their component types are).
13:49:53 <hdaume> so yeah, it is a bug
13:50:21 <hdaume>  There is no upper bound on the size of a tuple, but some Haskell implementations may restrict the size of tuples, and limit the instances associated with larger tuples. However, every Haskell implementation must support tuples up to size 15, together with the instances for Eq, Ord, Bounded, Read, and Show. The Prelude and libraries define tuple functions such as zip for tuples up to a size of 7.
13:50:27 <hdaume> this seems to be contradictory
13:50:51 <hdaume> "All tuples are instances of...."  /  "...some Haskell implementations may srestrict the size of tuples, and limit the instances..."
13:51:10 <hdaume> even so, it seems to say that you have to support instances and existence of tuples up to 15
13:51:29 <Darius> Are both paragraphs normative?
13:52:16 <hdaume> normative?
13:53:45 <Darius> As in defining the standard (as opposed to, say, a footnote or an example)
13:53:56 <hdaume> ah, yeah they are
13:54:04 <hdaume> http://haskell.org/onlinereport/basic.html
14:09:44 <Arnia> @yow
14:09:45 <lambdabot> Yow!  Are we in the perfect mood?
14:10:19 <debug> It is a wonderful day.
14:12:02 <SyntaxPolice> @yow
14:12:03 <lambdabot> Yow!  Am I cleansed yet?!
14:12:40 <Arnia> Aww... how sweet :)
14:39:03 <pseiko> hi all
14:50:19 <delYsid> cute!
14:50:21 <delYsid> it parses!
14:50:34 <hdaume> delYsid: yay!
14:51:04 <delYsid> Its actually easier to match against available moves then to check real validity...
14:54:30 <delYsid> hmm, now the question is, do I really want to dump portability?
15:02:44 <pseiko> i have a question, maybe someone has an advice:
15:03:50 <pseiko> would you say that (,) a is a subtype of (,) b if a is a subtype of b? or would you say, that only (,) a b is a subtype of (,) c d if a<c and b<d?
15:05:01 <Smerdyakov> Choose subtypes based on operations that you can perform. You don't need "advice." It's objective.
15:05:03 <Igloo> (,) a isn't a type
15:05:14 <Smerdyakov> If a is a subtype of b, you should be able to perform all operations on a that you can on b.
15:05:55 <pseiko> do you know typing haskell in haskell?
15:07:20 <pseiko> i want to add subtyping and have some problems, because types are roughly of the form TAp Type Type | TCon ... and not T TCon [Type]
15:07:36 <pseiko> so they may be incomplete
15:08:47 <pseiko> should i make the design decision that only types of kind Star can be compared in this sense?
15:09:02 <Igloo> It depends what you want to achieve
15:09:52 <pseiko> hmm, i am trying to implement ohaskell for the ghc
15:10:22 <pseiko> in the calculus of nordlanders thesis all rules use "complete" types
15:11:49 <pseiko> the problem is, that a lot of overhead is introduced if there are a lot of "transformations" of the type representation
15:40:27 <Riastradh> @yow
15:40:27 <lambdabot> NOW, I'm supposed to SCRAMBLE two, and HOLD th' MAYO!!
18:25:37 <Riastradh> In an implementation of the IO type, what hidden data might be stored?
18:55:21 <Riastradh> ...
19:08:00 <Smerdyakov> Probably none...?
19:08:56 <Riastradh> Er, what's the point of having an IO data type, then?
19:10:40 <Smerdyakov> To indicate order of operations explicitly
20:36:20 <Riastradh> !
20:36:46 <Riastradh> Where did -you- run off to, cleverdra?
20:37:48 <cleverdra> USAF.  How have you been doing?
20:38:26 * Riastradh has been doing much more than he was a while ago.
20:39:00 <Riastradh> And I've submitted a SRFI...though not the DLL one.
20:39:21 <Riastradh> But what are you doing in #haskell and not #scheme!?  Traitor!
20:40:27 <Riastradh> Ack, I must go.
20:40:39 <cleverdra> =)  I'm in #Lisp, though that probably doesn't help my case.
20:40:44 <cleverdra> bye, then
21:20:18 <jemfinch> shapr: you in?
23:15:39 <jemfinch> hmm.
23:15:55 <jemfinch> why does CPUTime.getCPUTime (an IO Int) show me nothing in ghci?
23:18:15 <Darius> the same reason why return 4 doesn't.
23:18:56 <Darius> GHCi -shows- functions, it -executes- IO actions
23:19:19 <Darius> so, getCPUTime >>= print
23:31:05 <jemfinch> thanks :)
23:35:34 <o3> or 'foo <- CPUTime.getGPUTime; putStrln foo'
23:42:00 <Darius> which, with a 'do' prepended, says the same thing
23:42:12 <Darius> more or less
