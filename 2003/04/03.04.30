00:24:13 <delYsid> hmm, what might be the fastest way to decompose a value into a list of bits?
01:47:50 <seth_> To use Maybe (Just, etc.) do I have to create a class and use "deriving"?
01:49:09 <Marvin--> no, Maybe is a type
01:49:26 <Marvin--> you can just say  foo :: Maybe Int -> somethingelse -> moretypes -> ...
01:50:17 <seth_> If I have an enumeration (data X = Y | Z), can I use the Maybe syntax with it?
01:50:38 <Marvin--> sure
01:50:43 <emu> maybe
01:51:12 <seth_> emu  :)
01:51:22 <Marvin--> seth_: do you mean using   Maybe X  or using  Maybe  inside the definition of X?
01:51:30 <Marvin--> or both? :)
01:51:59 <seth_> I'm thinking about distinguishing between the value of the enumeration and "not set".  Although in Haskell that may not even make sense.
01:52:28 <Marvin--> well, that's pretty much what Maybe is for
01:52:47 <seth_> right, but I'm not sure "never set" means anything in the Haskell context.
01:52:50 <Marvin--> either it has a value (the e in Just e) or it doesn't (Nothing)
01:53:18 <seth_> right.  But "never set" sort of implies an imperative variable.
01:53:30 <Marvin--> yes
01:54:03 <Marvin--> but you don't have to think about it as "not set", you will pass around things explicitly, right? or will you return a Maybe X somewhere?
01:54:25 <seth_> I'm not sure yet, I need to understand the feature before I decide that.  :)
01:54:31 <Marvin--> you can also think of Maybe as a primitive exception mechanism
01:54:45 <Marvin--> that's precisely what it does in a monad context
01:55:24 <seth_> Let me ask a general question.  the answer may be "not a sensible question".  In haskell, how do I create the equvialent of a mutable record type in ocaml?
01:55:50 <seth_> or is the answer, "I don't" ?
01:56:16 <Marvin--> I don't know what a mutable record type is in ocaml, but I can guess, and there are two answers, depending on how advanced you want to be :)
01:56:35 <Marvin--> the simple answer is "you don't", the more advanced answer is "use monads" ;)
01:56:49 <seth_> For example, I have a function that takes a string which is an HTTP header, and parses the string and populates members of a structure.
01:57:09 <seth_> I make a product type for the structure...
01:58:00 <seth_> And I need to keep both the parsed info and the original string
01:58:59 <seth_> I may simply be thinking imperatively here.
01:59:46 <seth_> Does haskell have associative arrays (or hash tables or something similar)?
02:00:09 <Marvin--> well.. what function needs to keep the original string? I mean, if function f calls function g with the original string and g returns the parsed info, then you have both the string and the struct and can call another function with them both...
02:00:31 <Marvin--> no, but there's a balanced tree based type called FiniteMap
02:00:31 <emu> maybe
02:00:39 <seth_> yes.  I'm trying to avoid sending around dozens of things as arguments.
02:01:24 <Marvin--> if you don't want to send dozens of things as arguments, you should look at state monads
02:01:45 <seth_> Ok, I started to look at them but it will take some studying.
02:04:20 <Marvin--> but if you have to pass around multitudes of things, that might also indicate bad design :)
02:04:51 <seth_> I'm porting a program that I have written versions of in Ruby and ocaml, so clearly the architecture is not well designed for Haskell.  Yes.
02:05:24 <Marvin--> "porting" between different paradigms usually involves more than syntax ;)
02:06:05 <seth_> yes.  I need to know more about Haskell, though, before I can do the "right" thing for Haskell.
02:08:19 <seth_> falling asleep, got to go.  Thanks Marvin-- (and others) for your help.
02:47:29 <delYsid> hmm
02:47:47 <delYsid> Isn't Word64 instantiated for Integral?
02:48:07 <delYsid> bitsToList n = biNumToBitList n 0 []
02:48:08 <delYsid>   where
02:48:08 <delYsid>   biNumToBitList 0 i l = l
02:48:09 <delYsid>   biNumToBitList 1 i l = (i : l)
02:48:09 <delYsid>   biNumToBitList n i l | n `rem` 2 == 0 = biNumToBitList (n `div` 2) (i+1) l
02:48:10 <delYsid>                        | otherwise = biNumToBitList (n `div` 2) (i+1) (i : l)
02:48:11 <delYsid> bitsToSq = map (\b -> Sq ((b `rem` 8)+1) ((b `div` 8)+1)). bitsToList
02:48:33 <delYsid> I'd like to use bitsToSq with a Word64 input, but the type inferred is Integer -> [Square]
02:48:36 <delYsid> does anyone know why?
02:51:55 <delYsid> oh, nm
02:52:00 * delYsid slaps himself
02:55:08 <HannahS> Hi!
03:06:54 <HannahS> Good news: I've received an email that it'll be no problem that I release some Haskell bits I've developped in the company to Open Source.
03:07:23 <opet> thoopah!
03:07:30 <HannahS> But: Should I hold on and try to get that permit in written form?
03:07:54 <Marvin--> HannahS: just agree with them on a license
03:08:50 <HannahS> I've proposed one in my email query (3-clause BSD style)
03:08:59 <Marvin--> okay.. I would've suggested LGPL
03:09:00 <HannahS> And the answer was "no problem".
03:09:10 <HannahS> Oh, spare me with those many pages of legalese.
03:09:11 <HannahS> *g*
03:09:18 <Marvin--> heh
03:09:22 <HannahS> And BSD style is even more free *g*
03:09:33 <HannahS> At least if you omit that obnoxious advertising clause.
03:09:43 <Marvin--> what, you don't want users to contribute back their changes?
03:10:00 <mgoetze> now now, let's not have any license flamewars :)
03:10:06 <HannahS> mgoetze: Agree.
03:10:16 <HannahS> Marvin--: I'd like, but I don't need to *require* it.
03:10:32 <Marvin--> "If you use BSD style licenses, then MICROSOFT have already WON!!!"
03:10:38 <Marvin--> or was it "terrorists"?
03:10:39 <delYsid> hmm, isn't QuickCheck part of GHC?
03:10:56 <Marvin--> it's distributed with both ghc and hugs
03:11:03 <opet> Marvin--: if you use three exclamation marks, They have already won :p
03:11:06 <delYsid> so how do I load it?
03:11:12 <Marvin--> opet: dang
03:11:16 <Marvin--> delYsid: import Debug.QuickCheck
03:11:23 <delYsid> ah
03:11:25 <HannahS> Marvin--: Especially that LGPL still poses restrictions not only on changes to your work itself, but also on work which uses your work as library.
03:11:33 <HannahS> Marvin--: Just not *as* many as GPL.
03:12:03 <delYsid> No instance for (Arbitrary Word64)
03:12:03 <delYsid> hmmm
03:12:08 <Marvin--> HannahS: those restrictions are pretty sensible though, but if you don't want a license flamewar, let's not go there :) the have-already-won was in jest :)
03:13:15 <HannahS> Marvin--: I find those restrictions annoying from a library user's perspective. So I don't impose them upon others.
03:13:20 <mgoetze> Marvin--: no no, i was the one not wanting a license flamewar :)
03:13:25 <HannahS> Hello.
03:13:27 <Marvin--> mgoetze: oh, right
03:13:36 <HannahS> So then.
03:13:38 <mgoetze> Marvin--: so, tell me, how's your D&D character coming along?
03:13:41 <Marvin--> HannahS: then remind me what the restrictions are, I don't have the whole license in my head ;)
03:13:58 <Marvin--> mgoetze: still don't have a name for my horse ;) we're playing the first session today so we'll see what happens
03:14:20 <mgoetze> no name for the horse? :-O
03:14:31 <HannahS> Marvin--: You have to accompany your binaries built with a LGPL library with some object form one can use to re-link your binary with a different version of the library.
03:14:34 <Marvin--> I haven't managed to think of a good one, yet
03:14:35 <mgoetze> well, you know, things without names are expendable ;)
03:14:43 <Marvin--> haha
03:14:52 <Marvin--> maybe I should just call it "horse"
03:14:58 <HannahS> Marvin--: That's illusional for most cases (inline functions, C++ templates, cross module analysis of GHC, ...)
03:14:58 <mgoetze> did you get yourself a +1 weapon, in the end?
03:15:08 <HannahS> Marvin--: In fact, with inlining you get GPL style contagion anyway.
03:15:27 <Marvin--> HannahS: hmm
03:15:34 <HannahS> Marvin--: Which is why some Lispers use another modification of the LGPL (if they don't use really free licenses instead).
03:15:38 <Marvin--> mgoetze: no, I talked to the DM and he said go for the shiny plate armor
03:15:51 <HannahS> Marvin--: (In Lisp the problem is mostly macroexpansion)
03:16:03 <HannahS> Role playing *ggg*
03:16:25 <Marvin--> mgoetze: spending 2300 out of 2700 is quite a lot
03:16:55 <mgoetze> Marvin--: well, ya gotta do something for your armor check penalty, eh? ;)
03:17:12 <Marvin--> bah, who needs more than +1 dex :P
03:17:38 <Marvin--> I'm supposed to be in the front, chopping at things, not prancing around like a silly rogue or something
03:17:49 <Marvin--> (whoops, that was almost in-character)
03:18:46 * mgoetze has a character with +5 dex, bwahaha
03:18:58 <HannahS> *What* RPG are you talking about?
03:19:07 <mgoetze> HannahS: D&D
03:19:33 <HannahS> mgoetze: The old D&D w/o any A in front? :-)
03:19:41 <Marvin--> HannahS: no, the new D&D without any A
03:19:43 * mgoetze is still having trouble deciding whether to go for +7 str or +6 dex next level
03:19:46 <Marvin--> HannahS: D&D3
03:19:49 <mgoetze> yeah, the really new one
03:19:53 * HannahS has played some Shadowrun and AD&D in the past. However it's quite long ago.
03:20:00 <HannahS> Marvin--: I see.
03:20:10 <Marvin--> mgoetze: speaking of which, what kind of level penalty is it on playing a centaur?
03:20:14 * mgoetze used to be an AD&D2 player, but the new stuff is much better
03:20:45 <mgoetze> Marvin--: according to the monstrous manual, 6, but seeing as that is ridiculous, my dm toned the stats down a bit and made it 3
03:21:14 <mgoetze> (most of the level penaltiin the monstrous manual are ridiculous...)
03:21:15 <Marvin--> mgoetze: well, centaurs are ridiculously powerful too, I think 3 is too little
03:22:09 <mgoetze> Marvin--: you might rethink that once you start running into people who can cast level 4 spells :)
03:22:25 <delYsid> No instance for (System.Random.Random Word64)
03:22:26 <delYsid> arising from use of `choose' at <interactive>:1
03:22:27 <delYsid> hmm
03:22:33 <delYsid> choose (minBound :: Word64, maxBound :: Word64)
03:22:41 <delYsid> isn't this a valid way to generate a Word64?
03:24:12 <mgoetze> Marvin--: +6 str isn't very useful when people with improved invisibility are flying around and casting fireballs on you
03:26:35 <Marvin--> heh
03:26:50 <Marvin--> LOL, Peter Ebdon is colour blind, not the best trait for playing snooker
03:27:03 <mgoetze> heh
03:29:53 <mgoetze> now, the question is, how do i get to Mainz to pick up this 8-cpu machine being sold on ebay... hm...
03:31:34 * delYsid gives up on QuickCheck
03:31:40 <delYsid> thats everything else, just not "quick"
03:36:01 <HannahS> Hmpf.
03:36:14 <HannahS> I *like* the state of the art wrt free C++ implementations :-E
03:36:45 <HannahS> NOT!
03:37:28 <Marvin--> quit complaining :P
03:37:52 <HannahS> Marvin--: What shall I do instead?
03:38:11 <HannahS> Marvin--: They don't seem to be able to have that project I'm on to be implemented with more reasonable tools.
03:38:33 <HannahS> How often has the term "memory leak" touched my ears in the recent months :-E
03:53:08 <ham> hiho
03:53:18 <HannahS> Hohi!
03:53:33 <ham> :)
03:54:47 <HannahS> :-)
03:54:52 <HannahS> What do you let?
03:55:05 <HannahS> let name = "ham" in setNick name? *g*
03:55:05 <ham[let]> heh i let me go ;)
03:55:22 <ham[let]> ham is a mutlifunc name :)
03:55:24 <ham[let]> ham.*
03:56:59 <HannahS> Hmmm. In Lisp, we could write something like (defgeneric ham (some arguments)) *g*
03:57:11 <ham[let]> :)
03:57:55 <ham[let]> i think youere the first one who finds that let funny :)
03:58:07 <HannahS> *grin*
03:58:37 <ham[let]> maybe then some of you also will find my homepage funny
03:58:45 <ham[let]> codemages.sf.net
03:59:45 <HannahS> Now, considering that "let" funny isn't too far fetched in a channel about a programming languages where let is a keyword.
03:59:47 <HannahS> *g*
03:59:55 <HannahS> (remove one "s" for better reading)
03:59:55 <ham[let]> :)
04:00:08 <HannahS> Eeeek.
04:00:13 <HannahS> Those poor llamas!
04:00:18 <ham[let]> :))
04:00:22 <HannahS> They haven't deserved *that* (www.microsoft.com)
04:00:28 <ham[let]> heh :)
04:00:46 <ham[let]> llamas is pronounced the same like lamers :)
04:00:47 <HannahS> Oh, AI *g*
04:00:52 <HannahS> And A* search...
04:00:59 <ham[let]> yes ai and that codemages game
04:01:00 <HannahS> I've had to do with A* search in my diploma thesis!
04:01:06 <ham[let]> might ber interesting for some of you
04:01:14 <HannahS> You're German? *g*
04:01:17 <ham[let]> yep
04:01:25 <ham[let]> cognitive scientistr
04:01:27 <ham[let]> -r
04:01:47 <HannahS> Cognitive Science? What's the German term?
04:01:51 <HannahS> (I'm German too)
04:02:10 <ham[let]> bewusstseins wissenschaften maybe
04:02:11 <HannahS> What does lead you to #haskell? Your page looks more like a Lisp guy's one *g*
04:02:18 <ham[let]> its about brain and cognition
04:02:29 <ham[let]> yeah but i like haskell too
04:02:35 <ham[let]> its more functional i think
04:02:42 <HannahS> Hmmm. I've done Haskell before I've come to like Lisp.
04:02:43 <ham[let]> and im looking into category theory
04:02:49 <HannahS> Category theory.
04:02:59 <HannahS> Let me say: I've done quite some math in my CS curriculum.
04:03:10 <ham[let]> cool
04:03:33 <ham[let]> i want to map a lot of ai techniques into CT
04:03:43 <ham[let]> to make them combinable and distributable
04:03:54 <HannahS> However, I've not yet really GOT CT.
04:04:11 <HannahS> Somehow that was to abstract even for me (who has liked algebra)
04:04:14 <ham[let]> ive never met someone who claims that
04:04:24 <ham[let]> i like the structures
04:04:32 <HannahS> Yeah, I like what I've grokked, too.
04:04:32 <ham[let]> im kind of a structuralist
04:04:45 <HannahS> But there was always some point where I didn't get further.
04:05:14 <HannahS> I like structures too. As said, algebra was nice. And when I learn foreign natural languages, I'm usually most interested in the structure.
04:05:25 <HannahS> (Turkish is quite nice, very regular and such!)
04:05:36 <ham[let]> but what i dont get is if i can use edges as objects too
04:05:39 <ham[let]> or why i cant
04:06:15 <ham[let]> cause id like to have a functor wich is dependent on some nodes in the cat and update the edges in that way
04:06:35 <ham[let]> so i tought i could build some cartesian products over edges or such
04:07:17 <ham[let]> i can have functor with parameters cant i?
04:07:56 <HannahS> Hmmm. I thought a functor is a mapping from one cat to another cat, which maps objects to objects and arrows to arrows (with some laws, of course)
04:08:09 <ham[let]> yes
04:08:14 <HannahS> So you can, of course, consider objects (or arrows) as parameters of the functor.
04:08:23 <ham[let]> but what if i want to have a dependent mapping
04:08:40 <mgoetze> funny seeing two germans talking about maths in english... i always have trouble with that :)
04:08:44 <ham[let]> like F(Catx,some_other_param)
04:08:49 <ham[let]> heh
04:08:56 <HannahS> You could consider that as a family of different functors.
04:09:06 <ham[let]> i got nearly all my courses in englishso i get kinda used to that
04:09:07 <HannahS> I.e. a mapping from some index set to the set of functors
04:09:17 <HannahS> (or a set of functors from cat A to cat B or whatever)
04:09:25 <HannahS> Why now?
04:09:26 <HannahS> not?
04:09:37 <ham[let]> HannahS: would you mind having a look at what i crafted this eve?
04:10:02 <ham[let]> i tried to model neural networks in a category
04:10:26 <HannahS> Hmmm. Dunno whether I find the time and energy.
04:10:36 <HannahS> Especially as I should continue with my (ugh C++ :-E) work.
04:11:00 <ham[let]> :)
04:11:01 <mgoetze> WRAAARGH!
04:11:05 <HannahS> Hunting memory leaks in C++ components :-E
04:11:09 <ham[let]> ok didnt want to bother you
04:11:18 <ibid> (my paper was accepted for SPLST'03)
04:11:18 <mgoetze> fsck it!
04:11:19 <ham[let]> HannahS: do you know about bounds checker?
04:11:29 <ham[let]> ibid: what paper?
04:11:43 <HannahS> ham[let]: I don't think I'm exceeding bounds. It's more why some process uses up more and more memory over time.
04:11:51 <ibid> the one i've mentioned here before. not directly haskell or fp-related
04:11:55 <HannahS> mgoetze: fsck(8) will not help I fear.
04:12:18 <mgoetze> HannahS: no, probably not *sniff*
04:12:23 * mgoetze gives up
04:12:57 <mgoetze> 'twas a crazy idea anyway... to think that i could have an 8-cpu box...
04:13:21 <mgoetze> "The maximum per package weight for that service from the selected country is 70 kg." - bah!
04:13:28 <HannahS> I'd really like to do stuff like that with more *ehm* interesting tools.
04:31:54 * HannahS 's leaving.
04:32:02 <HannahS> To have some food etc.
05:38:26 <shapr> oy
05:38:42 <shapr> wassup?
05:38:50 <shapr> hello everybody, how's life treating you?
05:38:55 <Smerdyakov> I woke up. Before that I was sleeping.
05:38:56 <shapr> @yow
05:38:56 <lambdabot> Tex SEX!  The HOME of WHEELS!  The dripping of COFFEE!!  Take me
05:38:56 <lambdabot>  to Minnesota but don't EMBARRASS me!!
05:39:01 <shapr> Smerdyakov: wow, that's great!
05:39:15 <Smerdyakov> Before that I was awake and working on something.
05:39:16 * shapr bounces happily
05:39:17 <Smerdyakov> Before that I ate dinner.
05:39:25 <shapr> Smerdyakov: were you working on something fun?
05:39:34 <Smerdyakov> I was working on a poster in LaTeX.
05:39:42 <shapr> oh, nifty
05:39:44 <Smerdyakov> http://www.contrib.andrew.cmu.edu/~adamc/poster.pdf
05:39:51 <Smerdyakov> (Don't use Acrobat Reader!!)
05:40:03 <shapr> er, why not?
05:40:09 <shapr> explosions? fire?
05:40:10 <Smerdyakov> It doesn't know how to behave.
05:40:16 <Smerdyakov> It shows only a small bit of it.
05:40:21 <shapr> oh, yes, now I see
05:40:57 <shapr> truly, acroread is upset about yoru poster
05:41:04 <Marvin--> gv doesn't like it either
05:41:13 * mgoetze uses ggv
05:41:14 <Marvin--> xpdf likes it though
05:41:17 <Smerdyakov> Marvin--, set magnification to 0.100, if you have the same version I've used.
05:41:22 <Smerdyakov> Marvin--, (for gv)
05:41:29 <Smerdyakov> It's an A0 sized PDF.
05:42:37 <Marvin--> all I get is a smaller view of the same part of the poster ;)
05:43:23 <shapr> Smerdyakov: the poster looks really nice
05:43:59 <Marvin--> wow, ggv is amazingly slow compared to gv and xpdf
05:44:18 <Smerdyakov> Marvin--, sorry!!
05:44:39 <Marvin--> sorry?
05:44:48 <Smerdyakov> Marvin--, sorry that didn't work!
05:44:51 <Smerdyakov> shapr, thank you
05:45:05 <shapr> Smerdyakov: hey, what's the history of your last name?
05:45:21 <Marvin--> Smerdyakov: well it worked fine in xpdf, and it looks great :)
05:45:56 <Smerdyakov> shapr, Poland --> Immigration --> Mispronunication
05:45:59 <shapr> ah, ok
05:48:13 <shapr> Smerdyakov: how did you design the poster?
05:48:45 <Marvin--> bleagh
05:48:48 <Marvin--> bleeeehhhh
05:48:57 <Smerdyakov> LaTex!!
05:48:58 <Smerdyakov> XXX
05:51:51 <shapr> Marvin--: hey, have you created a HaWiki page?
05:51:59 <Marvin--> no
05:52:00 <shapr> I still haven't gotten around to learning LaTeX
05:52:19 <Marvin--> LaTeX is nice, though I'm having a hard time writing Haskell code in it
06:09:06 <Marvin--> for the TH gurus among us, would it be easy to write a generic "recurse and substitute" function for an AST in TH?
06:15:06 <shapr> I think Igloo did something vaguely like that with Fraskell
06:24:59 <Marvin--> HeliumFrontend.hs: static flags are not allowed in {-# OPTIONS #-} pragmas
06:25:00 <Marvin--> bah :)
06:44:07 * shapr boings
06:46:01 * mgoetze puts up a sign, "warning, low ceiling! watch your head when boinging, bouncing or sproinging!"
06:47:19 * shapr stops bounces
06:48:22 <delYsid> :(
06:48:41 <delYsid> now, this is the fourth implementation of a Board now, and not even that one seems to be fast
06:53:36 <delYsid> oh my, and it consumes more memory than the FiniteMap version
06:53:37 <delYsid> bah
06:57:56 <Igloo> Marvin: I have some code that substitutes a literal for a variable if that's what you mean
06:58:24 <Igloo> Substituting expressions is messier because you have to rename things all over the place
06:59:45 <Marvin--> I'd love to have a look
07:00:09 * Igloo should autogenerate some of the code
07:02:03 <Igloo> Oh, give me a minute, I'll just merge the fixes I noticed when writing a paper
07:04:09 <Marvin--> heh
07:04:23 <Igloo> http://urchin.earth.li/~ian/Subst.lhs  The docs might not be quite right, and it won't compile with the HEAD (you'll need to strip out all the type parameters)
07:05:23 <Igloo> Oh, and you'll need http://urchin.earth.li/~ian/Utils.lhs too
07:06:35 * Igloo declares them to be GPLed - but talk to me if that's a problem
07:09:00 <Marvin--> :P
07:09:12 <Marvin--> oh no, my eyes, I'm tainted by the GPL now
07:09:28 * Marvin-- mutters and symlinks Subst.lhs to subst.tex
07:10:09 <Igloo> You want better syntax highlighting you do  :-)
07:11:23 <Marvin--> \htolvarid?
07:12:10 <Igloo> Oh, \def\htolvarid#1\texttt{#1} and similarly for anything else (I *think* that's the right syntax)
07:13:04 <Marvin--> I just wrote a \newcommand for it
07:13:13 * Marvin-- tries to remember the syntax for creating environments
07:14:07 <delYsid> \newenvironment[args][default]{start}{end}
07:14:08 <delYsid> iirc
07:14:27 <Igloo> Oh, for code? Hang on
07:14:29 <Marvin--> "Hey cool, lots of stuff for me to work with. Good thing you didn't kill off your entire family!" (my DM after I mailed him my character description)
07:15:21 <delYsid> Marvin--: Are you the kinslayer or what ? :)
07:16:15 * Igloo points and laughs at Marvin's silly script
07:16:35 <Marvin--> delYsid: no, the "you" is out of character, my character's father died in a tavern brawl and one of my siblings was still born
07:16:37 <Igloo> Ooops, I'm being incompetent
07:17:36 * SyntaxPolice_ looks around the latex and D&D channel
07:17:40 <SyntaxPolice_> ;)
07:17:52 <Marvin--> Igloo: eep. thank god for vim's block copy&paste
07:18:16 <Igloo> Do you mean :set paste?
07:19:06 <Marvin--> no, I mean ctrl-v for selecting the '<Igloo> %' prefix on all lines
07:19:26 <Igloo> Oh, right
07:20:13 <Marvin--> any other packages I need?
07:20:20 <Marvin--> ! Undefined control sequence.
07:20:21 <Marvin--> l.180 for all $n \in \mathbb
07:20:21 <Marvin-->                             {N}$.
07:20:35 <delYsid> bah!
07:20:41 <Igloo> \usepackage{amssymb}
07:20:41 <Igloo> \usepackage{amsmath}
07:20:51 <delYsid> Now that I have a bitboard, I'm spending 60% of time and alloc in bitsToList
07:20:59 <Marvin--> LyX has made me lazy :P
07:21:01 <Igloo> You might need alltt and/or subfigure too
07:21:04 * delYsid gives up and decides that Haskell is very nice, but.......
07:21:09 <delYsid> hard to code efficient for
07:21:25 <Marvin--> make: *** No rule to make target `foo.ps'.  Stop.
07:21:26 <Igloo> del: Do you know how far off equivalent C you are?
07:21:29 * Marvin-- tsks at make ;M)
07:22:02 <delYsid> Igloo: Parse error
07:22:06 <delYsid> rephrase please
07:22:23 <Marvin--> heh, re-phrased structured grammars
07:22:28 * Marvin-- ducks
07:23:02 <Igloo> If you wrote it in C, how long would it take? And how long is it taking in Haskell?
07:23:13 <Igloo> To run, not to write
07:23:29 <delYsid> hmm, good question
07:23:39 <delYsid> I'm guessing that efficient C should be about 10 times faster
07:23:41 <delYsid> if not even more
07:24:06 <Igloo> Based on what?
07:24:07 <Marvin--> Igloo: hmm, this is to perform substitutions on your haskell source code, isn't it? (using TH I mean) what I need is some way to easily express a substitution over my own ASTs
07:24:35 <Darius> Also, bitsToList seems like it defeats the point of using a bitboard, depending on how you are using it.
07:24:41 <Marvin--> but it looks like it could be a fun read
07:24:45 <Marvin--> now I'm off to play D&D though :)
07:24:49 <Igloo> Ah, I see, sorry
07:25:05 <Igloo> Without writing it out case-by-case you mean?
07:25:19 <Darius> Marvin-- would Strafunski be appropriate, it seems like that's what it's meant for
07:25:35 <delYsid> Darius: I agree, I'm certainly using it too often... but this was just a draft
07:25:38 <Igloo> Well, if/when I get round to generating the code I'll let you know - I imagine you'd be able to use that easily
07:25:59 <delYsid> and if your draft runs 2 times slower than your previous draft, and 4 times slower than the original, that is not encouraging
07:26:15 <Marvin--> Darius: I'll have a look at it when I get back
08:43:53 <hdaume> hi all
09:31:55 <shapr> oy
09:39:36 <shapr> vay
09:39:37 <shapr> @yow
09:39:38 <lambdabot> You were s'posed to laugh!
09:40:36 <shapr> wouldn't Marvin--'s project be able to use the generic refactoring stuff?
09:49:59 <shapr> I suddenly wish for a Help typeclass, with method "help" that returns the haddocks defined for the given function/data constructor/etc
09:50:04 <shapr> would be really handy in GHCi
09:57:08 * shapr thinks of "help nub"
09:57:15 <shapr> er
09:57:17 <shapr> actually
09:57:36 <shapr> hm
09:59:21 <hdaume> it would just have to be ":help nub"
10:02:28 <shapr> yah, that would be better
10:15:22 <tmoertel> getUsers "#haskell" >>= mapM_ (putStrLn . ("Hello, " ++))
10:23:29 <opet> hi
10:26:04 <shapr> hi tmoertel 
10:28:19 <hdaume> if there weren't monads, would there by any point to the () type?
10:29:45 <Darius> Yes.
10:29:49 <ham[let]> hiho
10:29:53 <shapr> hohi
10:29:58 <hdaume> darius: such as?
10:31:26 <Darius> data DecorateTree a b = Leaf a b | Branch (DecoratedTree a b) a b (DecoratedTree a b); type UnDecoratedTree a = DecoratedTree a ()
10:32:15 <hdaume> but you could just say 'type UnDecTree a = DecTree a (forall b.b)' and fill in with undefineds....but okay, i had stupidly forgotten about stuff like that
10:36:35 <shapr> in that case, () is an untroublesome value that acts like "undefined" ?
10:37:06 <shapr> it looks to me like () is a tuple of size zero
10:37:12 <shapr> how do I make a tuple of size one?
10:38:14 <opet> I think tuples are only defined n >= 2
10:38:27 <shapr> why?
10:38:50 <hdaume> data OneTuple a = OneTuple a
10:39:14 <Darius> (a) == a
10:39:38 <Darius> There doesn't need to be a separate type (and it would make parsing annoying).
10:40:51 <shapr> I've occasionally wanted to do (x:xs) pattern matching with tuples
10:42:37 <Igloo> Sounds like you want records
10:43:06 <shapr> hm, probably so
10:44:19 <hdaume> Igloo: yeah, but then you have something like "Tuple2 'a' 'b' :: Tuple Char Char a b c d e f g", which is ugly (if i'm interpreting you correctly)
10:44:43 <Igloo> Eh what?
10:44:52 <hdaume> i guess not :)
10:44:54 <hdaume> nm
10:44:58 * shapr grins
10:45:23 <shapr> hey hal, what are you working on now?
10:45:31 <Igloo> I could be the one misunderstanding - I thought shapr wanted to be able to refer to part of a datastructure without having to have loads of _s matching other bits
10:45:32 <hdaume> same old stuff :)
10:45:52 <shapr> I actually wanted to be able to loop or map over the bits of a tuple
10:45:58 <shapr> any size tuple
10:46:10 <shapr> I realize that maybe the solution is "don't use a tuple"
10:46:55 <shapr> I think I'm having Pythonic flashbacks, in Python a tuple is just an immutable list. Also, both lists and tuples can have items of any type inside them
10:47:16 <shapr> so, alist is a collection of a bunch of the same thing
10:47:33 <shapr> a tuple in Haskell is actually a separate complex type
10:47:44 <shapr> and so can have a bunch of items of different types
10:48:10 * shapr isn't sure that was at all understandable
10:48:35 <shapr> soo, who's interested in that Haskell library installer project?
10:58:03 <shapr> @yow
10:58:04 <lambdabot> Should I start with the time I SWITCHED personalities with a BEATNIK
10:58:04 <lambdabot>  hair stylist or my failure to refer five TEENAGERS to a good OCULIST?
11:02:51 <delYsid> can a argument type of a typeclass method left undecided?
11:04:07 <shapr> do you have an example?
11:05:45 <delYsid> hmm, not nice for pasting, too long and too complicated to put in context.
11:07:56 <shapr> class Foo a where bar :: a -> b
11:07:56 <shapr> ?
11:08:12 <delYsid> yeah, that one
11:10:08 <Darius> You don't need to supply a method even if there is no default, in which case it defaults to undefined (not a good thing)
11:10:27 * Riastradh bounces in through the window.
11:16:29 <shapr> what about types that aren't mentioned in the instance?
11:16:54 <shapr> I just tried it, looks like that method expects to find a type named b
12:32:18 <ham[let]> in haskell i can have real lambda expressions can i?
12:33:20 <Riastradh> What's a 'real' lambda expression?
12:34:20 <ham[let]> btw could you plz get rid of the " in the topic cause i cant open the pages by just clicking at the urls
12:34:44 <ham[let]> in lisp you can have lambda expressions but you have to "bind" all variables at once
12:35:08 <Riastradh> Yes, and...?
12:35:10 <ham[let]> but maybe i just want to bind one and retrieve another new fun
12:35:17 <ham[let]> ie
12:35:20 <Smerdyakov> Wow. I have no idea what you mean. =D
12:35:41 <ham[let]> (lambda (x y) (...))
12:35:53 <ham[let]> i have to "bind" both x and y
12:36:09 <ham[let]> i cant just bind one and retrieve (lambda (x) (...))
12:37:07 <Riastradh> You mean call:  ((lambda (x y) ...) foo) and get (lambda (y) ...) where X is bound to FOO in ...?
12:37:57 <ham[let]> #'(lambda (x y) (+ x y))
12:38:16 <ham[let]> then ie #'(lambda (x) (+ x 10))
12:38:33 <Riastradh> What's your question, though?
12:38:38 <ham[let]> cant do that in lisp afaik since you need to spec all lambda vars
12:38:53 <Darius> You mean currying? (\x y -> x+y) 10 ==> \y -> 10+y?
12:38:55 <ham[let]> can i bind only one var in haskell that way?
12:39:09 <ham[let]> Darius seems like it yes
12:40:02 <ham[let]> http://codemages.sourceforge.net/llamabo/llamabo.lisp
12:40:15 <ham[let]> just in the last lines ive got some lambda expressions
12:40:27 <ham[let]> with alot of nested lambda expressions
12:40:35 <ham[let]> and i dont like the look of that
12:41:20 <ham[let]> so in haskell i always "bind" the leftmost lambda var?
12:42:00 <Riastradh> \x y -> x + y  -- is the same as:  \x -> \y -> x + y  -- is this something like what you're trying to get?
12:42:08 <ham[let]> so implicitly all lambda fns are nested lfns with an aryty of one?
12:42:23 <Darius> that's how it is in lambda calculus
12:42:30 <ham[let]> ah ok
12:42:35 <Darius> and it's not just abstractions it's all Haskell functions
12:42:53 <Darius> the ''uncurried'' version would take a tuple
12:43:00 <Darius> \(x,y) -> x*y
12:43:06 <ham[let]> is there any graphical editor for haskell with graphlike structureing?
12:43:22 <ham[let]> i think ill have to have a look into haskell
12:43:25 <Riastradh> 'Graphlike structuring?'
12:43:27 <ham[let]> seems to be fun
12:43:41 <ham[let]> that is all the errors represent functions right?
12:43:46 * Darius can't live without partial application and currying anymore
12:43:59 <ham[let]> Darius partial application?
12:44:01 <Darius> errors?
12:44:09 <ham[let]> erm sry arrows
12:44:14 <Darius> yes
12:44:38 <ham[let]> then its like in category theory i could write my program as a big graph
12:44:58 <Darius> map (2*) [1..] or sumFrom = foldl (+)
12:45:32 <Darius> as opposed to map (\x -> 2*x) [1..] or sumFrom s l = foldl (+) s l
12:45:32 <ham[let]> hmm haskell seems to have some cool concepts
12:45:44 <ham[let]> is there any book youd advise me to buy?
12:45:55 <Riastradh> Read the 'Gentle Introduction to Haskell.'
12:45:59 <Riastradh> It's on haskell.org.
12:46:00 <ham[let]> ok
12:46:12 <ham[let]> is anyone of you into ai?
12:47:58 <ham[let]> cause id like to know if haskell is a language which provides concepts that i could use for that
12:48:16 <ham[let]> anyway thx
12:49:09 <Riastradh> What concepts do you need?
12:49:47 <ham[let]> hmm thats though
12:49:57 <Darius> For some AI algorithms lazy evaluation is useful, otherwise I'm not sure what you expect
12:50:24 <ham[let]> i just dont know if haskells 'idea' or basic concepts support some ai concepts
12:50:46 <ham[let]> ie a neural network
12:51:07 <Riastradh> But what concepts are you looking for?
12:51:16 <ham[let]> thats relativley simple but i might wont to have ...
12:51:38 <ham[let]> exchangeble functions for the sum nodes
12:51:58 <ham[let]> is haskell dynamic?
12:52:17 <Riastradh> 'Dynamic' in what sense?
12:52:29 <ham[let]> haskell is purely fn right so how do i store data?
12:52:38 <Riastradh> Haskell isn't -purely- functional.
12:52:42 <ham[let]> like being able to exchange functions on the fly
12:52:48 <Riastradh> There are things like IORefs and STRefs in Haskell.
12:52:50 <ham[let]> oh sry tehen
12:52:50 <ham[let]> then
12:52:51 <Riastradh> But you needn't use them.
12:53:12 <Riastradh> You can certainly store data without using imperative stuff.
12:53:33 <ham[let]> how so?
12:54:07 <Riastradh> data Tree a = Node a [Tree]   -- now you can store a value in a node by doing:  Node value subtrees
12:54:27 <Darius> Haskell -is- -purely- functional.  IORefs and STRefs don't change that.
12:54:29 <Riastradh> (where subtrees is a [possibly null] list of trees)
12:54:38 <Darius> unsafePerformIO does though
12:54:53 <Riastradh> Is 'unsafePerformIO' in GHC in specific or something?
12:55:08 <Darius> It's actually part of the FFI addendum
12:55:28 <Darius> There was some dynamic NN code in Haskell online somewhere
12:55:37 <ham[let]> FFI == foreign function interface?
12:55:52 <Darius> yes
12:55:55 <ham[let]> i think ill have a look into haskell tomorrow
12:56:06 <Riastradh> Why not now?
12:56:11 <ham[let]> im a bit tired
12:56:15 <ham[let]> had a hard day at uni
12:56:46 <ham[let]> maybe im just strolling on the haskell site though
12:59:47 <shapr> I can't live without partial application either
13:00:05 <shapr> though I don't use currying much
13:00:15 <shapr> I'm a total addict for partial application...
13:00:26 * tmoertel just checked in lambdabot DictModule
13:00:36 <shapr> oh?
13:00:38 * shapr looks
13:00:47 <ham[let]> what is that lambdabot all about?
13:00:55 <Darius> @fact source
13:00:55 <lambdabot>  http://sf.net/projects/haskell-libs/, http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/lambdabot/
13:01:24 * shapr is missing the fireworks... :-(
13:02:06 <Riastradh> @fact lambdabot
13:02:07 <lambdabot> the coolest (only) irc 'bot written in Haskell., is rude, now with 20% more FM goodness
13:02:22 <ham[let]> isnt there a project which makes use of graphs for visualization for haskell programs?
13:03:41 <ham[let]> oh haskell also has let???
13:03:53 <ham[let]> but isnt this non functional?
13:04:03 <shapr> ham[let]: you could check out http://haide.sf.net/
13:04:16 <shapr> http://kungens.kemi.fi/~shae/hIDE.png
13:04:46 <shapr> the second url being a screenshot I made
13:04:52 <ham[let]> thats cool
13:05:09 <ham[let]> thats using dotty isnt it?
13:05:27 <shapr> I don't remember
13:05:28 <ham[let]> is that just visualizing the programm or can i also construct programs that way?
13:05:45 <shapr> just visualization
13:06:00 <ham[let]> too bad
13:06:12 <ham[let]> but what goes in that dir will get in the other too ;)
13:06:17 <ham[let]> if its isomorphic
13:06:57 <ham[let]> thx alot
13:07:04 <ham[let]> ill got to bed now
13:07:16 <ham[let]> where are you from btw?
13:07:22 <shapr> me?
13:07:29 <shapr> I'm from Alabama.
13:07:35 <ham[let]> or will you be on in say 10h?
13:07:43 <shapr> maybe
13:07:57 <shapr> my sleep schedule isn't consistent enough to be called a schedule
13:08:05 <ham[let]> i need to think about some mall progs i wanna write :)
13:08:09 <ham[let]> heh
13:08:12 <ham[let]> i know that
13:08:21 <ham[let]> are you a student?
13:08:29 <shapr> not right now
13:08:32 <shapr> hopefully soon
13:09:26 <shapr> ok, gotta try the DictModule
13:09:28 <shapr> @quit
13:09:40 <ham[let]> and im going to bed thx again see you tomorrow
13:09:40 <tmoertel> shapr: I didn't fold it into Main.hs yet
13:09:46 <shapr> I did
13:09:53 <shapr> but haven't checked in the changes
13:09:59 <tmoertel> gotcha
13:10:11 <shapr> oh, I haven't checked in the ChessModule imports in Main either
13:10:21 <shapr> @listmodules
13:10:21 <lambdabot> I have the following modules installed: ["chess","dict","eval","fact","fortune","hello","karma","more","searchml","state","system","topic","type","yow"]
13:10:24 <shapr> @listcommands dict
13:10:25 <lambdabot> Module dict provides the following commands: ["dict"]
13:10:29 <shapr> @dict eponymous
13:10:31 <lambdabot> *** "Eponymous" web1913 "Webster's Revised Unabridged Dictionary (1913)"
13:10:31 <lambdabot> Eponymous \E*pon"y*mous\, a. [Gr. ?; 'epi` upon, to + ? for ?
13:10:31 <lambdabot>    name.]
13:10:31 <lambdabot>    Relating to an eponym; giving one's name to a tribe, people,
13:10:32 <lambdabot>    country, and the like.
13:10:36 <lambdabot>          What becomes . . . of the Herakleid genealogy of the
13:10:38 <shapr> tmoertel: awesome =)
13:10:38 <lambdabot>          Spartan kings, when it is admitted that eponymous
13:10:51 <tmoertel> @dict haskell functional
13:10:52 <lambdabot> *** "Haskell" gazetteer "U.S. Gazetteer (1990)"
13:10:52 <lambdabot> Haskell, AR (city, FIPS 30640)
13:10:52 <lambdabot>   Location: 34.50546 N, 92.63664 W
13:10:52 <lambdabot>   Population (1990): 1342 (485 housing units)
13:10:53 <lambdabot>   Area: 8.5 sq km (land), 0.0 sq km (water)
13:10:55 <lambdabot> Haskell, NJ
13:10:57 <lambdabot>   Zip code(s): 07420
13:10:57 <Darius> How is let non functional.  Non-recursive lets are equivalent to (\x -> e) a == let x = a in e
13:10:59 <lambdabot> Haskell, OK (town, FIPS 32900)
13:11:03 <lambdabot> *** "Functional" web1913 "Webster's Revised Unabridged Dictionary (1913)"
13:11:05 <lambdabot> Functional \Func"tion*al\, a.
13:11:07 <lambdabot>    1. Pertaining to, or connected with, a function or duty;
13:11:09 <lambdabot>       official.
13:11:09 <shapr> oh, neat, multiple inputs
13:11:13 <lambdabot>    2. (Physiol.) Pertaining to the function of an organ or part,
13:11:15 <Riastradh> lambdabot should say '...type @more for more...' so you know when to use the '@more' command.
13:11:15 <lambdabot>       or to the functions in general.
13:11:24 <shapr> Riastradh: yah yah, feel free to fix it ;-)
13:11:30 <Riastradh> Bah!
13:11:34 <tmoertel> @more
13:11:34 <lambdabot>    {Functional disease} (Med.), a disease of which the symptoms
13:11:34 <lambdabot>       cannot be referred to any appreciable lesion or change of
13:11:34 <lambdabot>       structure; the derangement of an organ arising from a
13:11:34 <lambdabot>       cause, often unknown, external to itself opposed to
13:11:34 <lambdabot>       organic disease, in which the organ itself is affected.
13:11:37 <lambdabot> *** "functional" wn "WordNet (r) 1.7"
13:11:39 <lambdabot> functional
13:11:41 <lambdabot>      adj 1: designed for or capable of a particular function or use; "a
13:11:47 <Darius> @dict deducible
13:11:48 <lambdabot> *** "Deducible" web1913 "Webster's Revised Unabridged Dictionary (1913)"
13:11:48 <lambdabot> Deducible \De*du"ci*ble\, a.
13:11:50 <lambdabot>    1. Capable of being deduced or inferred; derivable by
13:11:51 <lambdabot>       reasoning, as a result or consequence.
13:11:55 <lambdabot>             All properties of a triangle depend on, and are
13:11:57 <lambdabot>             deducible from, the complex idea of three lines
13:11:59 <lambdabot>             including a space.                    --Locke.
13:12:02 <Riastradh> Ack, bah, it uses Webster.
13:12:04 <shapr> @dict deductible
13:12:06 <lambdabot> *** "Deductible" web1913 "Webster's Revised Unabridged Dictionary (1913)"
13:12:06 <lambdabot> Deductible \De*duct"i*ble\, a.
13:12:07 <lambdabot>    1. Capable of being deducted, taken away, or withdrawn.
13:12:11 <lambdabot>             Not one found honestly deductible From any use that
13:12:13 <lambdabot>             pleased him.                          --Mrs.
13:12:15 <lambdabot>                                                   Browning.
13:12:18 <tmoertel> Riastradh: easy to change the dict server
13:12:25 <Riastradh> Good.
13:12:36 <Riastradh> But...hrm.  There is no OED server as far as I know...
13:13:20 <Vincenz> stop the spam!
13:13:43 <shapr> Vincenz: hey, you don't even write Haskell ;-)
13:13:48 <Vincenz> so?
13:13:52 <Vincenz> I'm the star of this channel
13:13:57 <Vincenz> ...after you of course
13:14:00 * shapr laughs
13:14:09 <shapr> yah right
13:14:19 <shapr> I'm just an organizer
13:14:26 <tmoertel> What servers should we consult for dict queries?
13:14:37 * tmoertel thinks foldoc, etc. would be nice
13:17:36 <shapr> yah, I agree
13:17:59 <shapr> at this rate, the feeping creaturitis release will happen soon
13:18:35 <shapr> @listmodules
13:18:35 <lambdabot> I have the following modules installed: ["chess","dict","eval","fact","fortune","hello","karma","more","searchml","state","system","topic","type","yow"]
13:18:40 * shapr grins happily
13:19:06 <Vincenz> what's searchml?
13:19:11 <Vincenz> lambdabot: @yow
13:19:12 <lambdabot> Yow!  I want to mail a bronzed artichoke to Nicaragua!
13:19:17 <Vincenz> lambdabot: @searchml
13:19:18 <lambdabot> must have at least one keyword
13:19:21 <Vincenz> lambdabot: @searchml ocaml
13:19:42 <Vincenz> lambdabot: @searchml type
13:19:44 <Vincenz> ?
13:20:12 <Vincenz> lambdabot: @chess
13:20:50 <Darius> @listcommands searchml
13:21:15 <Vincenz> @chess
13:21:17 <Vincenz> lambdabot: @yow
13:21:19 <Vincenz> He crashed
13:37:29 * tmoertel added support for foldoc and jargon queries
13:44:16 <tmoertel> @dict aiekdieksk
13:44:30 <Riastradh> lambdabot died.
13:44:44 <tmoertel> ah
13:45:36 <Riastradh> Which sucks, because I was about to use him as a lambda calculator.
13:45:36 <shapr> oh, I'll reboot him
13:45:50 <tmoertel> shapr: pull the most-recent DictModule first, please.
13:46:00 <shapr> will do
13:46:04 <tmoertel> thx
13:48:30 <tmoertel> @listcommands dict
13:48:30 <lambdabot> Module dict provides the following commands: ["dict","foldoc","jargon"]
13:48:34 <tmoertel> @foldoc curry
13:48:35 <shapr> yay
13:48:36 <lambdabot> *** "Curry" web1913 "Webster's Revised Unabridged Dictionary (1913)"
13:48:36 <lambdabot> Curry \Cur"ry\, n. [Tamil kari.] [Written also {currie}.]
13:48:36 <lambdabot>    1. (Cookery) A kind of sauce much used in India, containing
13:48:36 <lambdabot>       garlic, pepper, ginger, and other strong spices.
13:48:40 <lambdabot>    2. A stew of fowl, fish, or game, cooked with curry.
13:48:43 <lambdabot>    {Curry powder} (Cookery), a condiment used for making curry,
13:49:00 <tmoertel> d'oh!
13:49:09 <tmoertel> the @ comes across in the command, right?
13:49:25 <tmoertel> when the module gets it in process?
13:49:47 <shapr> nope
13:49:55 <Riastradh> @jargon hacker
13:49:57 <lambdabot> *** "Hacker" web1913 "Webster's Revised Unabridged Dictionary (1913)"
13:49:57 <lambdabot> Hacker \Hack"er\, n.
13:49:57 <lambdabot>    One who, or that which, hacks. Specifically: A cutting
13:49:57 <lambdabot>    instrument for making notches; esp., one used for notching
13:49:58 <lambdabot>    pine trees in collecting turpentine; a hack.
13:50:02 <lambdabot> *** "hacker" wn "WordNet (r) 1.7"
13:50:04 <lambdabot> hacker
13:50:09 <Darius> shapr: what broke lambdabot before?
13:50:17 <tmoertel> yow
13:50:20 <shapr> flooding from @searchml
13:50:21 <Riastradh> What?  I asked for a jargon term, not a term to be looked up in the dictionary of a doofus!
13:50:24 <Riastradh> @yow
13:50:24 <lambdabot> Yow!  I want to mail a bronzed artichoke to Nicaragua!
13:51:03 <shapr> tmoertel: @command is the command, but "command" shows up in the cmd param
13:51:26 * tmoertel looks at DictModule.hs for my error
13:52:21 * shapr adds tmoertel to admins
13:53:41 * tmoertel can't figure out why @jargon queries the web1913 dict
13:54:08 <tmoertel> @foldoc polymorphism
13:54:09 <lambdabot> *** "Polymorphism" web1913 "Webster's Revised Unabridged Dictionary (1913)"
13:54:09 <lambdabot> Polymorphism \Pol`y*mor"phism\, n.
13:54:09 <lambdabot>    1. (Crystallog.) Same as {Pleomorphism}.
13:54:10 <lambdabot>    2. (Biol.)
13:54:12 <lambdabot>       (a) The capability of assuming different forms; the
13:54:14 <lambdabot>           capability of widely varying in form.
13:54:16 <lambdabot>       (b) Existence in many forms; the coexistence, in the same
13:54:32 <shapr> tmoertel: oohh, I see
13:54:40 <shapr> you want "case cmd of"
13:54:44 <shapr> not "case target of"
13:54:53 * tmoertel slaps jos forehead
13:54:58 <shapr> target is who sent you the command, and who you'll send it back to
13:55:09 * tmoertel fixes . . .
13:55:15 * shapr gets ready to cvs up
13:56:45 <shapr> tmoertel: committed?
13:56:48 * tmoertel gets phone
13:57:00 * shapr waits impatiently
13:57:07 <shapr> I could fix it locally and restart lambdabot :-)
13:57:23 * tmoertel is refactoring it a bit, too
13:57:28 <shapr> ok
13:57:33 * shapr waits...
14:01:44 <shapr> now?
14:03:46 <tmoertel> shapr: now it's ready
14:03:50 <shapr> yay!
14:03:53 <shapr> @quit
14:05:24 <tmoertel> @foldoc curry
14:05:25 <lambdabot> (No match for "curry".)
14:05:30 <tmoertel> @foldoc haskell
14:05:32 <lambdabot> *** "Haskell" foldoc "The Free On-line Dictionary of Computing (09 FEB 02)"
14:05:32 <lambdabot> Haskell
14:05:32 <lambdabot>    <language> (Named after the logician {Haskell Curry}) A {lazy}
14:05:33 <lambdabot>    {purely functional} language largely derived from {Miranda}
14:05:34 <lambdabot>    but with several extensions.  Haskell was designed by a
14:05:35 <shapr> w00
14:05:36 <lambdabot>    committee from the {functional programming} community in April
14:05:38 <shapr> it's fixed!
14:05:38 <lambdabot>    1990.  It features static {polymorphic} typing, {higher-order
14:05:46 <Riastradh> @jargon hacker
14:05:47 <lambdabot> *** "hacker" jargon "Jargon File (4.3.0, 30 APR 2001)"
14:05:47 <lambdabot> hacker n. [originally, someone who makes furniture with an axe] 1. A
14:05:47 <lambdabot>    person who enjoys exploring the details of programmable systems and how
14:05:48 <lambdabot>    to stretch their capabilities, as opposed to most users, who prefer to
14:05:50 <lambdabot>    learn only the minimum necessary. 2. One who programs enthusiastically
14:05:52 <lambdabot>    (even obsessively) or who enjoys programming rather than just theorizing
14:05:54 <lambdabot>    about programming. 3. A person capable of appreciating {hack value}. 4.
14:05:56 <lambdabot>    A person who is good at programming quickly. 5. An expert at a
14:06:03 <shapr> tmoertel: plugin authors are added to the admin list
14:06:03 <Riastradh> @more
14:06:04 <lambdabot>    particular program, or one who frequently does work using it or on it;
14:06:04 <lambdabot>    as in `a Unix hacker'. (Definitions 1 through 5 are correlated, and
14:06:04 <lambdabot>    people who fit them congregate.) 6. An expert or enthusiast of any kind.
14:06:04 <lambdabot>    One might be an astronomy hacker, for example. 7. One who enjoys the
14:06:06 <lambdabot>    intellectual challenge of creatively overcoming or circumventing
14:06:08 <lambdabot>    limitations. 8. [deprecated] A malicious meddler who tries to discover
14:06:10 <lambdabot>    sensitive information by poking around. Hence `password hacker',
14:06:13 <lambdabot>    `network hacker'. The correct term for this sense is {cracker}.
14:06:21 <Riastradh> @jargon cracker
14:06:22 <shapr> polly wanna...
14:06:22 <lambdabot> *** "cracker" jargon "Jargon File (4.3.0, 30 APR 2001)"
14:06:22 <lambdabot> cracker n. One who breaks security on a system. Coined ca. 1985 by
14:06:22 <lambdabot>    hackers in defense against journalistic misuse of {hacker} (q.v., sense
14:06:24 <lambdabot>    8). An earlier attempt to establish `worm' in this sense around 1981-82
14:06:26 <lambdabot>    on Usenet was largely a failure.
14:06:27 <Riastradh> Heh.
14:06:30 <lambdabot>    Use of both these neologisms reflects a strong revulsion against the
14:06:32 <lambdabot>    theft and vandalism perpetrated by cracking rings. While it is expected
14:06:46 <Riastradh> @more
14:06:47 <lambdabot>    that any real hacker will have done some playful cracking and knows many
14:06:47 <lambdabot>    of the basic techniques, anyone past {larval stage} is expected to have
14:06:47 <lambdabot>    outgrown the desire to do so except for immediate, benign, practical
14:06:47 <lambdabot>    reasons (for example, if it's necessary to get around some security in
14:06:47 <lambdabot>    order to get some work done).
14:06:49 <lambdabot>    Thus, there is far less overlap between hackerdom and crackerdom than
14:06:51 <lambdabot>    the {mundane} reader misled by sensationalistic journalism might expect.
14:06:53 <shapr> I'm off to watch TV for a bit, bbl
14:06:53 <lambdabot>    Crackers tend to gather in small, tight-knit, very secretive groups that
14:07:02 <tmoertel> see ya
14:07:06 <Riastradh> @more
14:07:06 <lambdabot>    have little overlap with the huge, open poly-culture this lexicon
14:07:06 <lambdabot>    describes; though crackers often like to describe _themselves_ as
14:07:06 <lambdabot>    hackers, most true hackers consider them a separate and lower form of
14:07:06 <lambdabot>    life.
14:07:07 <lambdabot>    Ethical considerations aside, hackers figure that anyone who can't
14:07:09 <lambdabot>    imagine a more interesting way to play with their computers than
14:07:11 <lambdabot>    breaking into someone else's has to be pretty {losing}. Some other
14:07:13 <lambdabot>    reasons crackers are looked down on are discussed in the entries on
14:07:26 <Riastradh> @more
14:07:27 <lambdabot>    {cracking} and {phreaking}. See also {samurai}, {dark-side hacker}, and
14:07:27 <lambdabot>    {hacker ethic}. For a portrait of the typical teenage cracker, see
14:07:27 <lambdabot>    {warez d00dz}.
14:07:49 <tmoertel> @foldoc polymorphic
14:07:50 <lambdabot> *** "polymorphic" foldoc "The Free On-line Dictionary of Computing (09 FEB 02)"
14:07:50 <lambdabot> polymorphic
14:07:50 <lambdabot>    {polymorphism}
14:07:58 * opet blinks
14:08:06 <tmoertel> @foldoc polymorphism
14:08:08 <lambdabot> *** "polymorphism" foldoc "The Free On-line Dictionary of Computing (09 FEB 02)"
14:08:08 <lambdabot> polymorphism
14:08:08 <lambdabot>    A concept first identified by Christopher Strachey (1967) and
14:08:08 <lambdabot>    developed by Hindley and Milner, allowing types such as list
14:08:10 <lambdabot>    of anything.  E.g. in {Haskell}:
14:08:14 <lambdabot>    	length :: [a] -> Int
14:11:01 <Darius> Well. Lambdabot's now a spam machine.
14:11:25 <Riastradh> It's a good thing lambdabot supports stuff in privmsgs.
14:13:08 <tmoertel> @listcommands
14:13:09 <lambdabot> I react to the following commands: ["board","define","definitions","del-definition","dict","dump","echo","eval","fact","foldoc","fortune","get-definition","goodbye","hello","jargon","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","more","msg","part","ply","quit","reset-chess","resume","searchml","set-fuel","showml","state","topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type","validmoves"
14:13:51 <Darius> gah, shapr needs to fix more a bit.
14:18:12 <Riastradh> @listmodules
14:18:13 <lambdabot> I have the following modules installed: ["chess","dict","eval","fact","fortune","hello","karma","more","searchml","state","system","topic","type","yow"]
15:31:51 <shapr> oy
15:32:22 <shapr> Darius: actually, I think that's the max line length according to the IRC server
15:32:38 <Riastradh> The maximum packet length is 512 bytes.
15:32:48 <Riastradh> The packets that lambdabot has been sending were -FAR- shorter than that.
15:33:06 <shapr> I wonder why @listcommands was cut off then
15:33:20 <Riastradh> Oh.
15:33:30 <Riastradh> The commands listed may have been more than 512 bytes.
15:35:23 <shapr> hm, Oleg works for the Navy?
15:36:59 <Riastradh> Weird.
15:37:08 <Darius> Riastradh: this is something that @more should handle, that's why it needs to be fixed (that, 500 characters is not -a- line)
15:37:37 <Riastradh> Darius - Actually, @listcommands shouldn't really be used, anyways, without a module argument -- there are getting to be too many commands for no argument.
15:37:57 <shapr> yah, I agree
15:38:07 <tmoertel> Riastradh: or at least it should group the commands by module
15:38:33 <shapr> more is a hack anyway :-)
15:38:41 <shapr> It's not really a plugin
15:39:23 <Darius> I've wanted to be able to hide "privileged" commands, but as it is now there's no way to tell which those are
15:40:25 <shapr> yah, true
15:46:36 <shapr> I sometimes despair of understand what Oleg writes about
15:46:57 * shapr creates ThingsToResearch on his local wiki
16:03:25 * shapr plays with the arrow-based lambda calculus evaluator
16:04:57 <Riastradh> Oleg has his own Wiki?
16:05:12 <shapr> *my* local wiki
16:05:56 <shapr> I think I will create a public wiki at some point, but I'll still keep my particularly odd ideas hidden ;-)
16:06:18 <Riastradh> Oh.
16:17:33 <shapr> @foldoc lart
16:17:34 <lambdabot> *** "LART" foldoc "The Free On-line Dictionary of Computing (09 FEB 02)"
16:17:34 <lambdabot> LART
16:17:34 <lambdabot>    {Luser Attitude Re-adjustment Tool}
16:17:41 <shapr> see, we need a @lart plugin too
16:18:06 <shapr> I ran across a nice dwarvish insult in the Discworld Companion last night
16:18:23 <shapr> translates to "lawn ornament"
16:19:00 <shapr> @jargon cpu
16:19:01 <lambdabot> (No match for "cpu".)
16:19:05 <shapr> @jargon
16:19:14 <shapr> @dict
16:19:16 <shapr> @hello
16:19:17 <lambdabot> Hello world. 
16:19:19 <shapr> cool
16:24:09 <andersca> yo shapr
16:24:27 <shapr> y0 andersca 
16:24:28 <shapr> wassup?
16:24:42 <mgoetze> wow, that was extremely close
16:24:46 * mgoetze feels very lucky
16:25:00 <shapr> mgoetze: what happen?
16:25:23 <mgoetze> shapr: my maximum bid was 552.34 EUR, i got it for 545 EUR
16:25:36 <shapr> what did you buy?
16:25:45 <mgoetze> a roland synthesizer, xv-2020
16:26:05 <shapr> cool
16:26:20 * shapr is occasionally tempted to buy music equipment
16:26:45 <mgoetze> it was the perfect match for my needs, and it just happened to be on ebay! and then this close... wow
16:26:46 <shapr> mgoetze: do you write or play music?
16:27:09 <mgoetze> i used to write music, but my windows installation went broke and i haven't been motivated enough to fix it
16:27:22 <mgoetze> no i'll be able to afford an ibook, and then... oh boy!
16:27:26 <shapr> can't write music with Linux?
16:27:30 <shapr> or BSD?
16:27:54 <mgoetze> well, i could, but it would be extremely frustrating
16:28:03 <mgoetze> and frustration doesn't make for good music :)
16:28:17 <mgoetze> (reason: no decent program available)
16:28:29 <shapr> you could always write one :-)
16:28:47 <shapr> maybe extend Haskore to handle MPEG4
16:29:05 <mgoetze> what's mpeg4 got to do with it?
16:29:20 <andersca> what's mpeg4 but a second hand emotion
16:29:26 <shapr> andersca: heh
16:29:35 <andersca> sorry :=
16:29:37 * shapr is listening to Jimmy Eat World
16:29:38 <andersca> :) even
16:29:40 <Smerdyakov> andersca, it's also a five-character string.
16:29:53 <mgoetze> shapr: the output is midi, of course
16:30:17 <shapr> I'd like to write mpeg4 targeted music
16:30:39 <mgoetze> shapr: hire an orchestra to record it, or what? :P
16:31:19 <Darius> shapr: which song?
16:31:21 <shapr> nah, mpeg4 does all the stuff midi does, and all the stuff mpeg3 does
16:31:31 <shapr> Darius: same one, praise chorus
16:31:36 <shapr> it's just so cool :-)
16:31:55 * mgoetze has extreme doubts about what shapr is saying but goes to google for it anyway
16:32:01 <shapr> seriously, it does
16:32:24 <shapr> you get the good points of 'vector' formats like midi, and 'bitmap' formats like wav
16:32:40 <shapr> it's a bit more complicated of course...
16:33:13 <shapr> mgoetze: look at the sfront deb for example
16:33:33 <mgoetze> sure, but midi is pretty specific. i have extreme doubts that a totally generic format could get that good at doing this job. plus, how would you convert it into actual sound? there are no devices for such things that i'm aware of
16:33:54 <Darius> shapr: listen to "The Middle" some time
16:34:07 <shapr> Darius: is it legally available online?
16:34:23 <shapr> if not, what album would you recommend I purchase?
16:34:36 <mgoetze> shapr: and software synthesis is, well, teh sux
16:34:39 <shapr> mgoetze: install the sfront deb, look in /usr/share/doc/sfront/examples/
16:35:04 <shapr> isn't that a #pythonism?
16:36:53 <shapr> note that the bach example actually uses the included midi file as part of the mpeg4 input
16:38:02 <mgoetze> shapr: so, what's an SAOL orchestra file?
16:38:16 <mgoetze> shapr: it better not be software synthesis, because in that case you lose :)
16:38:32 <shapr> see file:///usr/share/doc/sfront/html/index.html
16:39:38 <mgoetze> shapr: yup, you lose. sorry, but this is absolutely useless for my purposes
16:39:39 <shapr> I find it amusing that the actual output format of sfront is C source
16:39:48 <seth_> I need to use a state monad.  I've defined a type with the data statement.  For a state monad whose data is described by this type, do I change the data statement do be   data X = State Y ...  (Y ... being the rest of the current type definition)?
16:39:50 <mgoetze> shapr: well, not absolutely useless, just extremely crap.
16:39:57 <shapr> mgoetze: ok, if you say so
16:40:19 <mgoetze> shapr: what kind of sound card do you have?
16:40:24 <shapr> emu10k1
16:40:38 <shapr> it's nice
16:40:44 <mgoetze> shapr: uhm... how much wavetable ram?
16:40:53 <shapr> hrm, lemme look
16:40:59 <mgoetze> (if you insist on telling me the chip instead of the sound card...)
16:41:33 * Pseudonym yawns
16:41:36 <shapr> I vaguely recally seeing 16mb somewhere
16:41:38 <shapr> hi Pseudonym!
16:41:41 <Pseudonym> G'day.
16:41:43 <shapr> new lambdabot plugins!
16:41:43 <seth_> Or is my type the 'a' in    State s a
16:41:48 <Pseudonym> Oh?
16:41:51 <Pseudonym> lambdabot: @listmodules
16:41:52 <lambdabot> I have the following modules installed: ["chess","dict","eval","fact","fortune","hello","karma","more","searchml","state","system","topic","type","yow"]
16:41:53 <hdaume> seth: the latter
16:41:57 <hdaume> erm
16:41:59 <hdaume> no, it's the 's'
16:42:06 <seth_> hdaume: the s?
16:42:11 <hdaume> yes
16:42:16 <mgoetze> shapr: that's not the kind of value one would vaguely recall, because it woulda cost a lot of money :)
16:42:20 <seth_> hdaume: then what is the 'a'?
16:42:21 <Pseudonym> Chess.
16:42:29 <hdaume> 'State s a' is an action in a state of type s whose result is of type a
16:43:12 <shapr> mgoetze: I bought it along with the rest of my dual Athlon MP system
16:43:22 <shapr> Pseudonym: and dict
16:43:33 <Pseudonym> lambdabot: @dict scratch monkey
16:43:35 <lambdabot> *** "Scratch" web1913 "Webster's Revised Unabridged Dictionary (1913)"
16:43:35 <lambdabot> Scratch \Scratch\, v. t. [imp. & p. p. {Scratched}; p. pr. & vb.
16:43:35 <lambdabot>    n. {Scratching}.] [OE. cracchen (perhaps influenced by OE.
16:43:35 <lambdabot>    scratten to scratch); cf. OHG. chrazz[=o]n, G. kratzen, OD.
16:43:35 <seth_> hdaume: can you give me a _simple_ example?  The examples I've found are much too involved to make sense of.
16:43:36 <lambdabot>    kratsen, kretsen, D. krassen, Sw. kratsa to scrape, kratta to
16:43:38 <lambdabot>    rake, to scratch, Dan. kradse to scratch, to scrape, Icel.
16:43:40 <lambdabot>    krota to engrave. Cf. {Grate} to rub.]
16:43:42 <lambdabot>    1. To rub and tear or mark the surface of with something
16:43:46 <lambdabot> *** "Monkey" web1913 "Webster's Revised Unabridged Dictionary (1913)"
16:43:48 <lambdabot> Monkey \Mon"key\, n.; pl. {Monkeys}. [Cf. OIt. monicchio, It.
16:43:51 <lambdabot>    monnino, dim. of monna an ape, also dame, mistress, contr.
16:43:52 <lambdabot>    fr. madonna. See {Madonna}.]
16:43:55 <hdaume> seth: sure.  i'll msg you
16:43:55 <lambdabot>    1. (Zo["o]l.)
16:43:56 <shapr> @jargon lart
16:43:56 <lambdabot>       (a) In the most general sense, any one of the Quadrumana,
16:43:58 <lambdabot>           including apes, baboons, and lemurs.
16:43:59 <Pseudonym> Doesn't have the jargon file, then?
16:44:00 <lambdabot>       (b) Any species of Quadrumana, except the lemurs.
16:44:03 <mgoetze> shapr: does it show up with lspci?
16:44:04 <Pseudonym> Ah.
16:44:04 <lambdabot> *** "LART" jargon "Jargon File (4.3.0, 30 APR 2001)"
16:44:06 <lambdabot> LART // Luser Attitude Readjustment Tool. 1. n. In the collective
16:44:08 <lambdabot>    mythos of {scary devil monastery}, this is an essential item in the
16:44:09 <Smerdyakov> @dict go
16:44:10 <lambdabot>    toolkit of every {BOFH}. The LART classic is a 2x4 or other large billet
16:44:12 <lambdabot>    of wood usable as a club, to be applied upside the head of spammers and
16:44:13 <Smerdyakov> @dict run
16:44:14 <lambdabot>    other people who cause sysadmins more grief than just naturally goes
16:44:14 <shapr> @listcommands dict
16:44:16 <lambdabot>    with the job. Perennial debates rage on alt.sysadmin.recovery over what
16:44:18 <lambdabot>    constitutes the truly effective LART; knobkerries, semiautomatic
16:44:22 <lambdabot> *** "go" web1913 "Webster's Revised Unabridged Dictionary (1913)"
16:44:25 <shapr> mgoetze: no, I just tried that
16:44:28 <lambdabot>    2. Drawn out or extended in time; continued through a
16:44:30 <lambdabot>       considerable tine, or to a great length; as, a long series
16:44:32 <lambdabot>       of events; a long debate; a long drama; a long history; a
16:44:34 <lambdabot>       long book.
16:44:35 <Pseudonym> Dictionary spam!
16:44:40 <lambdabot> *** "Run" web1913 "Webster's Revised Unabridged Dictionary (1913)"
16:44:40 <shapr> mgoetze: it's an sb live! of some flavor
16:44:42 <lambdabot> Run \Run\, v. i. [imp. {Ran}or {Run}; p. p. {Run}; p. pr. & vb.
16:44:44 <lambdabot>    n. {Running}.] [OE. rinnen, rennen (imp. ran, p. p. runnen,
16:44:46 <lambdabot>    ronnen). AS. rinnan to flow (imp. ran, p. p. gerunnen), and
16:44:48 <lambdabot>    iernan, irnan, to run (imp. orn, arn, earn, p. p. urnen);
16:44:50 <lambdabot>    akin to D. runnen, rennen, OS. & OHG. rinnan, G. rinnen,
16:44:52 <lambdabot>    rennen, Icel. renna, rinna, Sw. rinna, r["a]nna, Dan. rinde,
16:44:54 <lambdabot>    rende, Goth. rinnan, and perh. to L. oriri to rise, Gr. ? to
16:44:56 <lambdabot> Module dict provides the following commands: ["foldoc","jargon","dict"]
16:45:03 <mgoetze> an isa sb live? hm... never heard of such a beast
16:45:08 <Pseudonym> @foldoc fixpoint
16:45:10 <lambdabot> *** "fixpoint" foldoc "The Free On-line Dictionary of Computing (09 FEB 02)"
16:45:10 <lambdabot> fixpoint
16:45:10 <lambdabot>    {fixed point}
16:45:11 <Smerdyakov> Hey, I didn't get my damned definition of "run"!!
16:45:14 <Pseudonym> @foldoc fixed point
16:45:15 <lambdabot> (No match for "fixed".)
16:45:18 <lambdabot> *** "point" foldoc "The Free On-line Dictionary of Computing (09 FEB 02)"
16:45:19 * Pseudonym hmms
16:45:20 <lambdabot> point
16:45:21 * mgoetze is rather convinced that isa was way out by the time sb live came on the market
16:45:24 <lambdabot>    1. <text, unit> (Sometimes abbreviated "pt") The unit of
16:45:26 <lambdabot>    length for {text} {characters}.  There are two different
16:45:28 <lambdabot>    definitions: there are 72.27 "printer's points" per inch but
16:45:30 <lambdabot>    the points used in the {PostScript} {page description
16:45:32 <lambdabot>    language} are slightly larger at 72 per inch.
16:45:32 <shapr> mgoetze: no, it's PCI
16:45:34 <Pseudonym> @foldoc "fixed point"
16:45:35 <lambdabot> (No match for ""fixed".)
16:45:36 <lambdabot> ERROR: 501 syntax error, illegal parameters
16:45:46 <Pseudonym> @foldoc lambda
16:45:48 <lambdabot> *** "LAMBDA" foldoc "The Free On-line Dictionary of Computing (09 FEB 02)"
16:45:48 <lambdabot> LAMBDA
16:45:48 <lambdabot>    A version of {typed lambda-calculus}, used to describe
16:45:48 <lambdabot>    semantic {domain}s.
16:45:52 <lambdabot>    ["Outline of a Mathematical Theory of Computation",
16:45:54 <lambdabot>    D.S. Scott, TM PRG-2, PRG, Oxford U, 1971].
16:46:01 <shapr> hi dnm 
16:46:01 <Pseudonym> @foldoc haskell
16:46:01 <lambdabot> *** "Haskell" foldoc "The Free On-line Dictionary of Computing (09 FEB 02)"
16:46:01 <lambdabot> Haskell
16:46:04 <lambdabot>    <language> (Named after the logician {Haskell Curry}) A {lazy}
16:46:06 <lambdabot>    {purely functional} language largely derived from {Miranda}
16:46:08 <lambdabot>    but with several extensions.  Haskell was designed by a
16:46:10 <lambdabot>    committee from the {functional programming} community in April
16:46:12 <lambdabot>    1990.  It features static {polymorphic} typing, {higher-order
16:46:13 --- mode: mgoetze set +q lambdabot!*@*
16:46:21 <shapr> what's +q ?
16:46:24 <mgoetze> quiet
16:46:28 <shapr> oh, interesting
16:46:37 <dnm> hey shapr
16:46:44 <shapr> dnm: wassup?
16:46:54 * mgoetze thinks these commands probably work fine in query if people are interested :)
16:47:01 --- mode: mgoetze set -q lambdabot!*@*
16:47:02 <dnm> languishing at job #2. No one is here who I need to talk to.
16:47:12 <shapr> dnm: come write code!
16:47:27 <Pseudonym> The foldoc entry looks good to show to people if they turn up just wanting warez.
16:47:29 <dnm> Would love to. Pay me.
16:47:38 <mgoetze> shapr: well, try comparing sfront output of a midi with playmidi output then...
16:47:39 <dnm> You're in Sweden now?
16:47:39 <shapr> Pseudonym: I see the lambdabot feeping creaturitis release on the horizon
16:47:51 <shapr> dnm: yup, nearing six months here
16:47:52 <Pseudonym> That's modular design for you.
16:48:48 <shapr> heh, truly
16:49:15 <Pseudonym> The nice thing about modular design is you can pretend there's no feeping creaturism.
16:49:25 <Pseudonym> At least not in the core./
16:49:28 <shapr> that term is from Darius btw :-)
16:49:36 <Pseudonym> It's in the jargon file.
16:49:46 <shapr> Pseudonym: speaking of which, any idea how to move @more into a plugin?
16:50:01 <Pseudonym> Hmm.
16:50:06 <Pseudonym> That's tricky.
16:50:45 <shapr> hey, have you done anything with arrows?
16:50:49 <Pseudonym> Me?
16:50:51 <Pseudonym> Nope.
16:50:57 <Pseudonym> I kinda get what they are now.
16:51:07 <Pseudonym> I still don't understand all the axioms, though.
16:51:08 <shapr> transformers?
16:51:28 <shapr> if monads are for sequencing, what are arrows for?
16:51:44 <Pseudonym> Well first, monads aren't just for sequencing.
16:51:47 <shapr> I thought the arrow axioms were the same as the monad axioms?
16:51:56 <shapr> @fact monadlaws
16:51:57 <lambdabot> see leftunit, rightunit, monadassociativity
16:51:58 <Pseudonym> No, there are more of them and they're less well motivated.
16:52:12 <shapr> I have no clue about pure vs arr
16:52:56 <Pseudonym> Anyway, monads imply a "line" of code.
16:53:03 <Pseudonym> Kind of like a pipeline function.
16:53:07 <Pseudonym> f . g . h $ x
16:53:16 <Pseudonym> That's kind of analogous to f >> g >> h
16:53:22 <Pseudonym> Or h >> g >> f
16:53:23 <Pseudonym> Or something.
16:53:46 <Pseudonym> Monads with mzero and mplus imply a tree of code.
16:54:04 <Pseudonym> Arrows imply arbitrary directed graphs.
16:54:34 <shapr> ohh
16:54:54 <shapr> so, you couldn't do the Yampa "loop" combinator with monads?
16:54:58 <Pseudonym> I never "got" arrows until I realised the wiring diagrams are the keep things.
16:55:02 <Pseudonym> Uhm...
16:55:06 <shapr> "the keep things" ?
16:55:10 <Pseudonym> key
16:55:12 <shapr> oh "key" ?
16:55:32 <shapr> what are the key things in monads?
16:55:57 <Pseudonym> Monads are like list comprehensions.
16:56:20 <Pseudonym> In fact, the reason they got into Haskell was because someone noticed that they are a generalisation of list comprehensions.
16:56:34 <shapr> nifty
16:56:57 <Pseudonym> Compare [ e | p <- x, q <- y ] with do { p <- x ; q <- y ; return e }
16:57:30 <shapr> wow, interesting
16:57:43 <Darius> Gofer had monad comprehension syntax
16:57:58 <Pseudonym> Yup.
16:58:11 <Pseudonym> IO monad comprehensions were fun to use, too.
16:58:15 <shapr> is that related to mdo or 'unsequenced' monads as mentioned in the hair shirt retro?
16:58:27 <Pseudonym> That's something a bit different.
16:58:41 <Pseudonym> mdo allows for fixpoint monads.
16:59:17 <Pseudonym> Currently, you can't do this:
16:59:29 <Pseudonym> do { x <- f y ; y <- g x ; return x }
16:59:35 <Pseudonym> You can with mdo, though.
17:01:07 <Pseudonym> Apparently Eris makes a guest appearance in the next Dreamworks animated movie.
17:01:11 * Pseudonym woohoos
17:01:12 <hdaume> ...which is very cool... :)
17:01:33 <Pseudonym> She'll probably be eating hotdogs on a Friday, too.
17:02:48 <shapr> of course
17:03:06 <shapr> Pseudonym: are you a Discordian?
17:03:14 <Pseudonym> Of course.
17:03:18 <shapr> yay!
17:03:20 <shapr> hail eris!
17:03:25 <Pseudonym> Hail Eris!
17:03:28 <shapr> all hail discordia!
17:03:35 <Pseudonym> I got called up for jury duty once.
17:03:41 <shapr> yah?
17:03:48 <Pseudonym> I briefly considered ruling myself out as I was a pope.
17:03:55 * shapr laughs
17:04:06 <Pseudonym> Turned out I was ineligible for other reasons.
17:04:21 <Pseudonym> But still...
17:04:25 <mgoetze> shapr: you don't happen to have a cd for your soundcard, do you?
17:04:26 * shapr wonders if there's a second punchline hinding there somewhere
17:04:34 <Pseudonym> A Discordian pope and a minister of the Universal Life Church.
17:04:36 <shapr> mgoetze: er, I don't know...
17:04:46 <Pseudonym> No, no second punchline.
17:04:56 <Pseudonym> The reason I was ineligible is very mundane.
17:05:08 * Pseudonym used to work for the Commonwealth Director of Public Prosecutions
17:05:12 <mgoetze> shapr: or a windows installation on the machine?
17:05:16 <shapr> mgoetze: no way
17:05:33 <Pseudonym> When I mentioned this, they asked if I had access to any files.  I said "yes, and the backup tapes, too".
17:05:40 <mgoetze> shapr: thing is, i seem to be missing my copy of 4mbgmgs.sf2, which kinda sucks
17:05:41 * shapr grins
17:05:51 <shapr> mgoetze: what's that?
17:06:26 <mgoetze> shapr: a soundfont file, i.e. the instructions for the soundcard how to turn midi into music
17:06:33 <shapr> oh
17:06:38 <shapr> soundfont
17:06:40 <shapr> neat
17:08:19 <shapr> with my last name, you'd think people would ask
17:08:31 <shapr> but so far, only one person has gotten the joke without prompting
17:08:55 <Pseudonym> There you go.
17:09:21 <shapr> then I moved to sweden... and everyone 'corrects' the spelling to ericsson
17:09:22 <shapr> :-/
17:09:31 * Pseudonym laughs
17:09:52 <Riastradh> In -Sweden-, not Norway?
17:10:00 <shapr> yup
17:10:10 <Pseudonym> Sweden, Norway... it all depends whose army is occupying your town at the time.
17:10:13 <shapr> eriksson is just as common as ericsson
17:14:07 <seth_> still needing monad help.  hdaume showed me this function to put a value into a state monad:
17:14:15 <seth_> foo::State Int ()
17:14:18 <seth_> foo = do
17:14:27 <seth_>    put 5
17:14:29 <seth_>     return ()
17:14:32 <seth_>   
17:14:45 <seth_> How would I code a similar function that takes the value (in this case 5) as an argument?
17:15:01 <Darius> foo x = put x
17:16:30 <seth_> Darius: thanks.
17:41:17 <shapr> so, if monads are "after"
17:41:28 <shapr> do arrows also have "before" ?
17:41:59 <Pseudonym> Erm... I don't know what you mean.
17:42:14 <shapr> monads are about sequencing
17:42:29 <Pseudonym> OK...
17:42:45 <shapr> it looks like you're specifically saying that x has to happen after y
17:42:54 <Pseudonym> Well not really.
17:43:05 <Pseudonym> Monads can be written that don't sequence left-to-right.
17:43:05 <shapr> ?
17:43:16 <Pseudonym> I think.
17:43:46 <Pseudonym> The bindings have to happen left-to-right, of course.
17:43:50 <Darius> runIdentity (a <- f; b <- g; return (a+b)) only has data dependencies ordering it
17:44:07 <delYsid> Can anyone explain to me why I cant define an instance Show (Sometype,Someothertime) ?
17:44:22 <delYsid> s/time/type/
17:44:36 <shapr> delYsid: I think you won't have to
17:44:44 <Darius> Because, probably, it's already defined. instance (Show a,Show b) => (a,b) where ...
17:44:59 <Darius> If you want something different you need a newtype
17:45:45 <Pseudonym> Or -fglasgow-exts -fallow-overlapping-instances
17:46:24 <Pseudonym> Obviously don't do this unless you really need it. :-)
18:00:54 <Pseudonym> BTW, shapr, you weren't here for another Haskell milestone, I think last week.
18:01:19 <Pseudonym> Someone turned up asking for help understanding some Haskell code a previous employee left him.
18:01:33 <seth_> I used "deriving (Show)" in a data statement, but one of the types I used in my data statement does not have Show.  Is there a way for me to fix that, that is, some way to provide a function to show that type?
18:01:35 <Pseudonym> Haskell officially has its own production legacy code.
18:01:50 <Pseudonym> We've truly come of age, I tell you.
18:02:08 <Pseudonym> seth: What type is that?
18:02:15 <seth_> FiniteMap
18:02:20 <Pseudonym> Ah.
18:02:29 <Pseudonym> Well, you could either write one.
18:02:42 <Pseudonym> Or you could write your own Show implementation.
18:02:48 <Pseudonym> Something like:
18:02:58 <Pseudonym> instance Show (FiniteMap k v) where
18:03:09 <Pseudonym>     showsPrec _ _ = "{FiniteMap}"
18:03:13 <Pseudonym> That should do for now.
18:03:38 <seth_> OK.  Could I write instead an "instance Show" for my type?
18:03:44 <Pseudonym> Sure.
18:04:03 <seth_> In that case do I leave out the "deriving (Show)" in the type definition?
18:05:34 <Riastradh> Yes.
18:07:06 <seth_> Another very basic question.  It is a product type, so it is   data X = Y ...., where Y is the constructor for the type.  in the pattern (the showsPrec line), do I use the constructor?
18:07:45 <seth_> and also in the instance Show (Y ...)   ?  do I need the Y there?
18:08:25 <Riastradh> The Y won't work there; X will.
18:08:41 <Riastradh> In the pattern you use the Y.
18:08:47 <seth_> Riastradh: thanks.
18:09:03 <Riastradh> X is for type signatures; Y is for making and matching the data.
18:15:06 <seth_> in Pseudonym's instance Show for FiniteMap, I'm getting 
18:15:07 <seth_>     Couldn't match `String -> String' against `[Char]'
18:15:08 <seth_>         Expected type: String -> String
18:15:08 <seth_>         Inferred type: [Char]
18:15:08 <seth_>     In the definition of `showsPrec': "{FiniteMap}"
18:15:29 <seth_> ?
18:15:43 <Riastradh> 'showsPrec' must take three arguments.
18:15:45 <Pseudonym> Oh, sorry.
18:15:51 <seth_> oh, ok.
18:15:57 <Riastradh> Hmm, no it doesn't.
18:16:04 <Pseudonym> showsPrec _ _ = (++) "{FiniteMap}"
18:16:08 <Pseudonym> That'll work.
18:16:10 <seth_> ah
18:16:19 <Darius> or ("..."++)
18:16:37 <Riastradh> Ah, is ShowS a synonym for String -> String?
18:16:52 <Darius> It's more efficient that way
18:40:37 <shapr> Pseudonym: spiffy, we're mainstream once we have legacy code
18:45:41 <seth_> I have this state monad code working, at least a bit.  I'm still confused about where the state monad actually _is_.
18:46:33 <Darius> A monad (in Haskell) is a type constructor and two functions.
18:46:44 <seth_> ok.  more specifically...
18:47:16 <seth_> I ran a function that replaces the monad's value with another value.  I have the old and new values.  The monad itself no longer exists?
18:47:53 * shapr realizes that arrows are quite readable
18:48:11 <Darius> More correctly you would say you have monadic computations.
18:48:56 <seth_> The point of the state monad is to pass state around.  I don't see how you do that, then.
18:49:31 <Darius> bind (>>=) handles the plumbing details
18:49:46 <shapr> we just turn on the water
18:49:56 <seth_> so all the monad does is to allow me to do several operations on the data in a single function.
18:50:29 <Pseudonym> A monad is an abstract data type.
18:50:44 <Pseudonym> The monad handles stuff for you without you worrying about the details.
18:50:49 <Pseudonym> In your case, state passing.
18:51:17 <seth_> by state passing you mean along the "pipe" you create with >>= or >>
18:51:22 <Pseudonym> Right.
18:52:22 <shapr> y0 dnm 
18:52:26 <shapr> back so soon?
18:52:39 <Pseudonym> We're such compelling company.
18:52:45 <Pseudonym> Couldn't stay away.
18:52:56 <shapr> must be
18:58:27 <Riastradh> Where's StateT defined?
19:00:22 <Darius> Control.Monad.State
19:06:58 <seth_> the StateT monad has three arguments.  what is the third (m)?  
19:07:21 <Darius> The monad it's transforming
19:08:18 <seth_> and runStateT returns the monad?  Is that what -> m(a,s) is telling me?
19:09:14 <Darius> runStateT executes a stateful monadic computation and returns a monadic computation that uses the transformed monad
19:09:45 <seth_> I still have no idea what you mean by returning a computation
19:10:23 <Darius> Try reading "How to Declare an Imperative"
19:11:32 <Darius> let x = put 4; x is the computation of setting the state to 5.
19:11:51 <Darius> er 4
19:12:35 <Riastradh> Since Haskell is lazy, when you just type 'x', it's a delayed computation, not what 'put 4' returns.
19:13:05 <Darius> laziness is a non-issue here
19:14:03 <Riastradh> Well, yes, but I was just pointing out that you didn't need to put 'put 4' in a thunk, because Haskell is lazy -- it automatically thunkifies it.
19:14:36 <Darius> I haven't put it in a thunk
19:15:04 <Riastradh> Right, but because Haskell is lazy, it automatically thunkifies it and makes it a computation, not the value that 'put 4' returns.
19:16:05 <Darius> It wouldn't matter if Haskell were strict, let x = put 4; x is still only the computation.  What state is put supposed to update until I bind it?
19:16:17 <Smerdyakov> You're showing your orientation. Your Haskell program describes what value you want computed. The details of implementation are irrelevant.
19:17:05 <Riastradh> Oh, oops...put returns a computation.
19:17:24 * Riastradh wanders away, embarrassed.
19:17:42 <shapr> I learned something useful from your confusion
19:17:53 <shapr> I also thought the laziness was important
19:18:27 * Riastradh wasn't confused, he just forgot that put returned a computation.
19:20:06 <shapr> I'm less confused
19:21:08 <seth_> I'm not less confused.  put returns m ().  I don't see how that is a computation.
19:21:23 <Riastradh> m () is a computation -- only when you bind it does it compute.
19:21:32 <Riastradh> Or rather, m () is the type of a computation.
19:21:52 <seth_> To what can I assign m ()
19:22:05 <shapr> I think it's about first-class computations, sort of like one step past first-class functions
19:22:18 <Smerdyakov> You don't want to assign it. It's the "side effects" you like.
19:22:21 <seth_> because  let x = put 4   as was illustrated is a compile error
19:22:38 <shapr> or like a zero-arg lambda that doesn't actually execute till called
19:22:39 <seth_> Smerdyakov: if it "returns" something, I should be able to put that "something" somewhere
19:22:52 <Smerdyakov> seth_, you make use of it with monad sequencing, >>
19:22:57 <shapr> it "does" something
19:23:06 <Riastradh> The thing about monads, though, is they're just a level of abstraction over functions generally, and so you can't manipulate them much better -- which is, as I understand, what arrows are for.
19:23:09 <seth_> then it doesn't return a computation.  It returns the result of a computation
19:23:18 <Smerdyakov> seth_, what is this "return"?
19:23:36 <seth_> return is what comes from a function.
19:23:43 <seth_> functions return things
19:23:47 <Riastradh> 'put 4' returns a computation.
19:23:59 <Riastradh> >> or >>= runs that computation.
19:24:02 <Smerdyakov> seth_, we can define the semantics of what a particular monad means. The semantics of this monad allow it to have mutable values.
19:24:03 <seth_> put 4 is a compiler error, so I don't see how it can return anything.
19:24:12 <Riastradh> That's because it doesn't know what it's putting it in.
19:24:32 <seth_> So?  The fact remains that it can't return a computation, because it isn't even a correct expression
19:24:35 <Riastradh> The type system in Haskell is really cool -- it can figure out what to do just by where the code is.
19:24:40 <Smerdyakov> seth_, who said it returns a computation?
19:24:43 <Riastradh> It -is- a correct expression, just not in the right context.
19:24:47 <seth_> four people here
19:24:51 <Darius> actually >>=, >> don't either.  There is no state (for the State case) until you runState comp state
19:24:52 <Smerdyakov> seth_, get over the idea that it "returns something" meaningful in itself.
19:25:06 <seth_> I was saying that it doesn't return something.
19:25:10 <Smerdyakov> seth_, the meaning comes in the definition of combination of monadic values with >>=
19:25:26 <seth_> Then in no sense does it return a computation
19:25:30 * Riastradh departs.
19:25:37 <shapr> I should depart also
19:25:48 <seth_> was it something I said?  :)
19:25:57 <shapr> no, just the passing of 4am
19:26:00 <Darius> That, or it's 4am
19:26:03 <Smerdyakov> It sort of does.... it returns a computation that does something. But... you need something else prepared to run that computation.
19:26:26 <shapr> Darius: isn't it 9pm there?
19:26:40 <shapr> it returns half a lego block
19:26:41 <shapr> ha
19:26:46 <Darius> 10:30
19:26:48 <shapr> oh
19:27:05 <seth_> Smerdyakov: I don't see that.  A partial application, which is also something that computes when completed, returns a value.  I don't see put returning anything.
19:27:05 * shapr has the timezones confused again
19:27:42 <seth_> put as far as I can see does something, but returns nothing
19:27:57 <Darius> put 4 :: State Int ()
19:28:32 <Smerdyakov> seth_, think of it as returning a script to be executed by some benevolent entity
19:28:33 <Darius> put 4 doesn't do anything until you run it.  Like ghc.exe doesn't do any thing until you execute it.
19:28:45 <seth_> hardly comparable
19:28:59 <seth_> what you said applies to every function.
19:29:13 <Smerdyakov> seth_, completely comparable. put 4 gives you a program which can be combined with other programs to form something to run.
19:29:14 <shapr> you could read moggi/wadler
19:29:28 <seth_> so does every function definition.
19:29:40 * shapr shrugs
19:29:42 <seth_> except that the function is also a value
19:29:47 <Darius> add 5 4 == 9, it doesn't -execute- and give you 9 it IS 9
19:29:48 <seth_> but put 4 is not a value
19:29:54 * shapr is amused to see an arrow named newOrder
19:30:00 <shapr> I want one named newWorldOrder
19:30:04 <Darius> it's value is a computation
19:30:07 <seth_> Darius: no, but "add 4" returns something, while "put 4" doesn't
19:30:20 <shapr> I guess it would do IO... maybe even clean my room if the name means anything
19:30:34 <seth_> Darius  no, "add" might be said to return a computation.
19:30:35 <Smerdyakov> seth_, put 4 returns a first class operation on a state value in a hypothetic execution.
19:30:47 <Darius> how 'bout this.  Forget about the word return.
19:30:57 <seth_> OK
19:31:02 <Smerdyakov> So then
19:31:05 <Smerdyakov> seth_, put 4 is a first class operation on a state value in a hypothetic execution.
19:31:19 <shapr> ooh, that's good
19:31:29 <seth_> OK, that makes sense.  It is something.  It doesn't return that something
19:31:36 <Smerdyakov> "return
19:31:48 <Smerdyakov> "return" is not used in that way in Haskell, right.
19:32:14 <shapr> dnm_: return whence thou camest!
19:32:15 <seth_> It is in other contexts.  For example,  "add 4" _does_ return what you might consider a computation.
19:32:23 <Smerdyakov> seth_, we don't use that word.
19:32:33 <seth_> Smerdyakov: all the Haskell books and papers do.
19:32:45 <Darius> add 4 IS the function \y -> 4+y
19:32:50 <Smerdyakov> seth_, well, that may just confuse you, if you are coming from an imperative background. =)
19:33:17 <Darius> In a pure language expressions only have values.  The are.  They don't do.
19:33:23 <seth_> Darius: That's right, but it also _returns_ it, because I can do    x = add 4,  then I can apply x to, say 5 and get 9
19:33:24 <shapr> right on
19:33:31 <shapr> return doesn't exist in Haskell
19:33:37 <shapr> there is no spoon
19:33:37 <Darius> "returning" is somewhat procedural thinking
19:33:38 <shapr> or something
19:34:29 <Smerdyakov> seth_, you are best served by thinking of a Haskell program of a description of the value you want computed.
19:34:30 <seth_> Darius: it is not.  Functions return values.  there is nothing imperative about that.
19:34:41 <Smerdyakov> seth_, rather than instructions on how to compute it.
19:34:55 <Smerdyakov> seth_, so functions "returning things" really isn't in the vocabulary.
19:34:59 <shapr> think of "evaluate"
19:35:02 <seth_> Smerdyakov: yes, but that doesn't mean that the value is not returned.
19:35:19 <Smerdyakov> seth_, it need not be, in an implementation of Haskell.
19:35:25 <shapr> actually, a Haskell program works a lot like an equation in your average math book
19:35:26 <Darius> denote. add 4 denotes the function that adds four to it's argument
19:35:31 <seth_> I do understand the concept, I just differ with your interpretation of the word return.
19:38:28 * shapr cheers for AFRP
19:38:29 <shapr> @fact afrp
19:38:29 <lambdabot> Nothing
19:38:38 <shapr> @fact afrp arrowized functional reactive programming
19:38:39 <lambdabot> set afrp to arrowized functional reactive programming
19:56:30 <shapr> oh, now I understand the difference between arr and pure
19:58:51 <Darius> the name? Or have they changed it? or has it been changed? (I'm thinking the latter if either)
19:59:09 <Darius> In Arrow.hs, arr = pure
19:59:55 <shapr> in this yampa paper, it seems that pure means a pointwise function, where the output only depends on the input
20:01:04 <shapr> in contrast to the stateful functions where all prior events can be involved in the next output
20:02:27 <Darius> yes...
20:03:58 <shapr> so I wonder...
20:04:08 <shapr> is there any difference?
20:04:38 <shapr> I should invite Ross Patterson here as a guest speaker on Arrows
20:05:54 <Darius> arr is like return in monads.  It describes a function that doesn't depend on the "effect" of the arrow/monad, i.e. a pure function.
20:06:12 <Darius> It seems like someone thought pure would be a good name and now we have both.
20:06:26 <Darius> Arrow.hs describes arr and pure as synonyms
20:09:30 * shapr gives in...
20:09:31 <shapr> g'nite
20:09:33 <shapr> @fact g'nite
20:09:34 <lambdabot> zzzz
21:19:05 <flippo> @yow
21:19:06 <lambdabot> There's a little picture of ED MCMAHON doing BAD THINGS to JOAN RIVERS
21:19:06 <lambdabot>  in a $200,000 MALIBU BEACH HOUSE!!
21:20:48 <flippo> my local bookstore called to say Thompson's Craft book is back in stock.
21:21:08 <Pseudonym> Woohoo.
21:21:24 <flippo> yay, finally something to read
21:27:39 <Pseudonym> Why read when you have IRC?
21:32:59 <flippo> Pseudonym: what a question!
21:33:49 <flippo> Pseudonym: maybe I can find a way to IRC on my train/bus commute everyday
21:34:26 <Darius> PDA
21:35:41 <flippo> but someone might see me doing it and mock me
21:36:51 <Pseudonym> Not on #haskell.
21:37:01 <Pseudonym> Maybe on a lowbrow channel.
21:38:03 <flippo> Frankly, there just isn't enough to read on this channel.   One sentence every fifteen minutes won't do.
21:38:34 <flippo> And new books smell so nice
21:39:11 <Darius> no one will mock you smelling a book on the bus
21:39:12 <Pseudonym> Your loss.
21:40:36 <flippo> Pseudonym: I can do both.  I'll set my client to beep when a pearl appears on this channel, and I will tear my eyes from Thompson's light reading
21:40:47 <Pseudonym> Good plan.
21:48:10 <sjj> flippo: the Thompson book is quite good
21:48:32 <flippo> sjj: yes, I've been waiting months for a copy, since last year I think
21:49:03 <flippo> sjj: had to wait for another press run
21:49:24 <seth_> the Hudak book is also quite good
21:49:53 <sjj> flippo: ahh.
21:50:00 <flippo> seth_: I have that one, but I wanted to read, not play with graphics on a Windows(TM) box
21:50:16 <seth_> flippo: I went through the Hudak book and I don't have Windows
21:50:37 <flippo> seth_: Yes, I heard it had been ported.
21:50:54 <seth_> flippo: it is really about Haskell, not graphics.
21:51:08 <seth_> flippo: although the examples are mostly graphics, that really doesn't matter.
21:51:25 <flippo> seth_: I enjoyed Rabhi and Lapalme greatly.  Wanted more of that.
21:52:28 <Pseudonym> WHat kind of graphics examples?
21:53:33 <seth_> actually some neat stuff. some fractals, things like that.
21:53:39 * Pseudonym nods
21:53:56 <seth_> it's good because you wouldn't typically think of using haskell for that, so it shows interesting ways to use it.
21:54:58 <flippo> fractals are inherently recursive, so a functional approach sounds reasonable
21:55:50 <seth_> yes.  I was thinking more about actually putting graphics on a display, which is less intuitively functional
21:55:54 <flippo> I'd like to see a space filling curve in haskell.  That's handy for iterators, not just graphics
21:56:38 <seth_> What's the best thing to use in Haskell for a FIFO queue?
21:56:48 <Pseudonym> Are you using GHC?
21:56:54 <seth_> Yes
21:58:31 <Pseudonym> In -package data is the rather useful Edison.Seq.SimpleQueue
21:58:58 <seth_> thanks, I'll take a loot.
21:59:01 <seth_> look
21:59:49 <seth_> Is that a separate download?
21:59:56 <Pseudonym> Shouldn't be.
22:00:52 <seth_> my library directories are base, haskell98, network, mk, GLUT, ObjectIO, and OpenGL
22:01:11 <Pseudonym> What version are you using?
22:01:17 <seth_> 5.04.3
22:02:09 <Pseudonym> You don't have hslibs?
22:02:30 <seth_> I must; must be in a different part of the tree
22:02:45 <seth_> ok, yes, hslibs is in a different directory
22:03:02 <Pseudonym> Right.
22:03:26 <Pseudonym> You need to use the -package data flag
22:03:36 <seth_> I'm looking for the doc files
22:04:02 <Darius> They aren't in the hierarchical libraries because they haven't been moved yet
22:04:19 <Darius> Check the (Old) Haskell libraries section of the User Guide
22:04:28 <seth_> Darius: thanks
22:04:37 <Darius> @eval joy "2 dup dup mul mul"
22:04:38 <lambdabot> out of fuel
22:04:41 <Darius> @resume
22:04:42 <lambdabot> [8]
22:05:07 <Pseudonym> They won't be moved into the hierarchical libraries either.
22:05:15 <Pseudonym> Because that version is unmaintained.
22:05:33 <seth_> FiniteMap was moved, wasn't it?
22:05:34 <Darius> It seem(s/ed) that way.
22:05:38 * Pseudonym needs to get his anatomy in gear and get the maintained version up to date
22:05:51 <Pseudonym> And I need to Haddockise it too.
22:06:20 <seth_> I think Okasaki told me he is no longer maintaining them.  Wasn't there an effort to update it, with a different name?
22:06:29 <Pseudonym> Yeah, that's me.
22:06:30 <Pseudonym> hfl
22:06:42 <seth_> Does that exist yet?
22:06:47 <Pseudonym> Of sorts.
22:06:47 <seth_> For people to try/test?
22:07:01 <Pseudonym> http://sourceforge.net/projects/hfl
22:07:27 <seth_> I'll use hfl, then, unless you tell me not to.  :)
22:07:33 <Pseudonym> Go for it.
22:07:50 <Pseudonym> Then if you have trouble, you can bug me. :-)
22:08:12 <seth_> Well, I do that anyway, so at least maybe I'll find useful stuff.  :)
22:08:18 <Pseudonym> The main thing that still needs to be done is all the facade types.
22:08:28 <seth_> Is the mailing list active?
22:08:37 <Pseudonym> Well it's live.
22:08:40 <Pseudonym> It's not very active.
22:08:47 <Pseudonym> But I'm on it, obviously.
22:08:47 <seth_> I mean, should I join it?
22:08:52 <Pseudonym> If you want.
22:08:57 <Pseudonym> You won't get any mail unless you send it.
22:09:01 <seth_> OK.
22:09:13 <seth_> Is there a place to download on this page?
22:09:43 <Pseudonym> You'll need to get it from CVS.
22:09:51 <seth_> instructions here somewhere?
22:10:01 <seth_> I see it
22:12:29 <seth_> what module name(s) should I check out?
22:13:21 <seth_> just hfl?
22:13:47 <Pseudonym> Yes.
22:14:42 <seth_> then what?  make?
22:15:17 <Pseudonym> I think so, yes.
22:15:44 <seth_> hm, it complains in Sequence.hs.  You want the message?
22:15:52 <seth_> make depend first, by the way
22:16:20 <seth_> edison/Seq/Sequence.hs:276:
22:16:20 <seth_>     Couldn't match `*' against `* -> *'
22:16:20 <seth_>         Expected kind: * -> * -> *
22:16:20 <seth_>         Inferred kind: (* -> *) -> (* -> *) -> k
22:16:20 <seth_>     When checking kinds in `AsSequence s s'
22:16:21 <seth_>     In the instance declaration for `AsSequence s s'
22:17:41 <seth_> that line is at the end of sequence.hs, and looks fairly benign.  :)
22:17:55 <Pseudonym> Oh, crap.
22:18:00 * Pseudonym forgot about that
22:18:10 <Pseudonym> Go into Sequence.hs and delete the AsSequence typeclass.
22:18:15 <seth_> ok
22:18:37 <seth_> do I delete the instance also?
22:18:41 <Pseudonym> Yes.
22:18:53 <seth_> ok, semms to be building now.
22:19:05 <seth_> lots of warnings, mostly about nothing used from edison/prelude
22:19:05 <Pseudonym> You may need to delete Facade.Stack as well.
22:19:10 * Pseudonym nods
22:19:20 <Pseudonym> That's all Chris Okasaki's fault.
22:19:22 <seth_> nope, it built
22:19:26 <Pseudonym> Cool.
22:19:29 <seth_> OK, I'll send him a nasty email   :)
22:19:37 <Pseudonym> Do you see a file called "INSTALL"?
22:20:08 <seth_> yes
22:20:10 <seth_> run it?
22:20:17 <Pseudonym> If you have root on this machine, yes.
22:20:38 <seth_> I have root on ALL machines.  I work for myself.  :)
22:20:43 * Pseudonym grins
22:21:01 <Pseudonym> I was giving a talk about portals some years ago and I asked the audience "How many passwords do you have?"
22:21:06 <Pseudonym> One person replied "All of them!"
22:21:25 <seth_> :)
22:21:54 <seth_> one problem, I don't think I ever installed sudo
22:22:01 <Pseudonym> Oh.
22:22:07 <Pseudonym> Well look at the INSTALL script.
22:22:12 <seth_> can I just run the command as root?
22:22:20 <Pseudonym> Yeah, if you delete the call to sudo.
22:23:06 <seth_> ghc-pkg didn't complain, so I guess I'm ok.
22:23:18 <Pseudonym> Excellent.
22:23:25 <Pseudonym> You'll need to use -package hfl
22:24:00 <seth_> any docs, or should I use the edison docs?
22:24:12 <Pseudonym> The edison docs will be a little bit misleading.
22:24:18 * Pseudonym has fixed a lot of the warts in the interface
22:24:23 <Pseudonym> Well I think they're warts.
22:24:30 <seth_> are there newer docs, or should I try reading the source?
22:24:39 <Pseudonym> I think the source is best.
22:24:56 <Pseudonym> Basically, to use SimpleQueue, you need rcons and lview/lhead/ltail.
22:25:00 <seth_> ok, so looking at the edison docs and then checking the source might be a reasonable way to start.
22:25:06 <Pseudonym> Yes.
22:25:15 <Pseudonym> Note that ltail, for example, has changed a bit.
22:25:31 <Pseudonym> In the original edisil, ltail of an empty sequence gives you an empty sequence.
22:25:52 <seth_> and now?
22:26:11 <Pseudonym> Now it gives you an error.
22:26:24 <seth_> ok, that's more logical to me
22:26:29 <Pseudonym> I thought so too.
22:26:37 <Pseudonym> I think you'll want lview, mostly.
22:26:43 <Pseudonym> Note this has changed too.
22:26:59 <Pseudonym> It used to return Maybe2 x (SimpleQueue x)
22:27:08 <Pseudonym> Where data Maybe2 a b = Just2 a b | Nothing2
22:27:23 <Pseudonym> It now returns (Monad rm) => rm (x, SimpleQueue x)
22:27:53 <seth_> What's the difference between simple queue and bootstrapped queue?
22:28:22 <seth_> with an error if it is empty?
22:28:39 <Pseudonym> BootstrappedQueue isn't implemented, I don't think.
22:29:13 <seth_> too bad, it is described in Okasaki's book
22:29:16 <Pseudonym> Yes, I know.
22:29:22 <Pseudonym> You have his book?
22:29:26 <seth_> yes
22:29:31 <Pseudonym> Great!  Send me some code!
22:29:34 * Pseudonym grins
22:29:40 <Pseudonym> It doesn't have to be Edisonised.
22:29:41 <seth_> I found an error in a footnote.  He tells me that is the only one anyone has found
22:29:53 <Pseudonym> Did you get a cheque for $2.56?
22:29:57 <Pseudonym> No, that's Knuth.
22:30:19 <seth_> The Haskell code is at the back.  I can probably scan it and send it to you.
22:30:30 <Pseudonym> Sure, OK.
22:30:58 <seth_> it's been a couple of years since I read it.  I'll have to reread it.
22:31:07 * Pseudonym nods
22:32:04 <Pseudonym> The thing I really don't like about Edison is that you pick by algorithm.
22:32:17 <Pseudonym> Like you said: What's the difference between a SimpleQueue and a BootstrappedQueue?
22:32:23 <seth_> instead of by data structure?
22:32:27 <Pseudonym> Right.
22:32:34 <Pseudonym> By the set of operations which are supported efficiently.
22:33:15 <seth_> Since his emphasis in the book is on performance analysis, you can see why it came out that way.
22:33:15 <Pseudonym> I want a Queue, not be required to decide between a BootstrappedQueue and a BankersQueue.
22:33:21 <Pseudonym> Yes.
22:33:28 <Pseudonym> But I don't think this is right for a general library.
22:33:33 <Pseudonym> They should be there if you want them.
22:33:34 <seth_> I agree.
22:33:46 <Pseudonym> But most of the time you just want a Queue or a Stack or a Deque.
22:34:02 <o3> has anybody here played with template haskell much?
22:34:06 <seth_> Besides, there is nothing that says you can't _document_ by algorithm if you are so inclined
22:34:11 <Pseudonym> Right.
22:34:20 <seth_> o3: I did, a bit, but I don't really like the concept.
22:34:22 <Pseudonym> What I'm thinking of is:
22:34:25 <Pseudonym> import Edison.Queue
22:34:27 <Pseudonym> or:
22:34:34 <Pseudonym> import Edison.Seq.BankersQueue
22:34:49 <seth_> definitely, as all the other libraries work that way
22:34:51 <o3> seth_: ok :)
22:35:11 <seth_> o3: I may not be right.  To me it looks too much like macros, and I hate macros
22:35:18 <Pseudonym> It's not, though.
22:35:21 <Pseudonym> It's metaprogramming.
22:35:29 <Pseudonym> And get used to it. :-)
22:35:39 <seth_> Yes, I know, but it is code generation, which I've always disliked.
22:35:45 * Pseudonym shrugs
22:35:50 <Pseudonym> That's the way languages are going.
22:35:52 <seth_> besides, I'm not sure it solves the important problems
22:35:52 <Pseudonym> Higher and wider.
22:36:01 <Pseudonym> Higher like yacc, wider like C++ templates.
22:36:02 <Darius> You dislike having a program do your job for you?
22:36:13 <seth_> you can enhance the language without necessarily resorting to code generation.
22:36:15 <o3> seth_: it depends on what you think are important problems
22:36:19 <seth_> of course, that can be done later.
22:36:53 <Darius> The user can enhance the language with metaprogramming facilities.
22:36:59 <seth_> o3: I do a _lot_ of development of code that is actually deployed and used, so I have a useful perspective.
22:37:14 <seth_> Darius: true, but there are many problems with that approach
22:38:06 <o3> seth_: you're implying that the problems encountered in your experience are the same problems that everybody else runs into
22:38:51 <seth_> o3: no, just that they are likely representative.
22:38:57 <seth_> o3: not necessarily complete.
22:39:09 <o3> sure, depending on what field you work in
22:39:18 <seth_> however, the problem space as viewed by most academics is quite _un_representative
22:39:25 <o3> i'll take a bet they're not representative of the problems i have to deal with :)
22:39:27 <flippo> http://www.nizkor.org/features/fallacies/appeal-to-authority.html
22:39:41 <seth_> o3: you might be surprised.  what do you code?
22:40:21 <o3> seth_: multimedia apps, for one thing.  (media players)
22:41:22 <o3> anyway, the point is that template haskell is useful
22:41:45 <o3> if you don't want to use it, that's ok, you don't have to
22:41:48 <seth_> o3: I'm just skeptical, I'm not saying it isn't.
22:43:07 <seth_> It seems to me that rather than solve problems requiring repetetive coding, it mechanizes such coding.
22:44:04 <o3> well, you can write printf in haskell now.  that's a worthy enough application for me ;)
22:44:10 <o3> s/haskell/th/
22:44:22 <seth_> except that I found type errors in the printf implementation
22:44:44 <seth_> while the GNU compiler finds such type errors in C code
22:45:14 <seth_> so a problem that doesn't exist is solved incorrectly
22:46:54 <o3> strongly opinionated, i see :)
22:47:00 <seth_> oh, no, never.  :)
22:47:06 <seth_> back in about 15 minutes, all.
22:47:07 <Darius> Isn't one of the main uses of programming to perform repetitive tasks?  Why would programming lack repetitive tasks itself or is programming not solving the problems in those cases?
22:47:32 <seth_> repetitive tasks have nothing to do with repetitive _code_
22:47:41 <Pseudonym> People should be strongly opinionated about their chosen field.
22:47:50 <Pseudonym> You need to care to be good at it.
22:47:59 <seth_> don't go away, I'll be back.  :)
22:48:11 <o3> Pseudonym: aww, i don't agree with that
22:48:29 <o3> there's a difference between being passionate and being at the extreme ends of an opinion
22:48:40 <Pseudonym> Ah, there's a difference here.
22:48:52 <Pseudonym> Having a strong opinion and being at the extreme end of an opinion are different, IMO.
22:49:37 <o3> ah
22:49:51 <o3> yes, i agree
22:49:54 <o3> (silly english semantics)
22:49:56 <Pseudonym> RMS, for example, is at the extreme end of many of his opinions.
22:50:07 <Pseudonym> Not that this isn't valid.
22:50:10 <Pseudonym> The world needs zealots.
22:50:19 * Darius mumbles, "That's for damn sure" (about RMS)
22:50:20 <Pseudonym> But I don't think this is for everyone.
22:50:32 <Pseudonym> In fact, I hope it's not for most.
22:50:45 <o3> :)
22:51:09 <o3> aanyway, was just going to ask if TH can play around with the syntax tree of functions outside quasi-quotes
22:51:14 <o3> but it doesn't look like it :(
22:51:26 <Pseudonym> I think you want Lisp.
22:51:39 <Pseudonym> TH is more like C++ templates.
22:51:46 <Darius> You can reifyDecl's
22:52:09 <Pseudonym> Somehting I want is a way to specify derivable typeclasses.
22:52:10 <Darius> I don't believe you can change it, but you could make a wrapper
22:52:44 <Darius> Generics were supposed to do that, but now it looks like Simon is going for Strafunski-like Typable/Term
22:52:51 * Pseudonym nods
22:52:57 <Pseudonym> Strafunski isn't a bad idea at all.
22:53:20 <Darius> And if I get back on my TH code, I'll make TH DrIFT.
22:53:22 <o3> Darius: well, what i want is to be able to get at haskell's syntax tree of an argument so you can transform it to something else
22:53:40 <o3> (trying to think of a simple concrete example)
22:54:08 <Darius> Can Lisp even transform things like that?  Wouldn't you need a code walker over the whole source?
22:54:21 <o3> hmm, never mind.  i think i'll have to find another way of doing this
22:57:57 <o3> wooho!
22:58:02 * o3 bounces
22:59:25 <Darius> frungy? The Sport of Kings?
23:01:50 <o3> the sport of kings!
23:01:57 <o3> now available for modern platforms :)
23:02:15 <Darius> Have it.  I need to update and reinstall though.
23:06:20 <Pseudonym> Sorry, back.
23:07:12 <Pseudonym> Anyone here know how to use dbx?
23:07:15 * Pseudonym is more of a gdb man
23:09:54 <Pseudonym> Ah, it's in the FAQ.  Never mind.
23:16:29 <seth_> I used dbx a _lot_, but it was some time ago.
23:17:11 <Pseudonym> Unfortunately I'm using Solaris and the program is multi-threaded.
23:17:17 <Pseudonym> Hence gdb isn't an option.
23:17:25 <seth_> They did add thread support to gdb
23:17:30 <seth_> but it isn't great
23:17:48 <seth_> dbx is annoying but you can use the alias mechanism to shorten the commands
23:31:12 <seth_> Pseudonym: why is the Monad necessary in lview?
23:33:44 <Pseudonym> Excellent question.
23:34:01 <Pseudonym> http://www.haskell.org/hawiki/NotJustMaybe
23:34:14 <seth_> reading...
23:36:25 <seth_> interesting.  Not having a message with Nothing is a definite problem.
23:43:45 <Pseudonym> The point is you can use Maybe if you want.
23:44:31 <seth_> yes, I saw that.  I also noticed that you use the fail function which takes a string, which should make error handling a little easier.
23:44:38 <Pseudonym> Right.
23:44:50 <Pseudonym> If you use Maybe, you just get Nothing.
23:44:55 <seth_> I have some initial code with SimpleQueue working
23:45:00 <Pseudonym> OTOH, you can use MonadIdentity, and it will call error.
23:45:24 <seth_> Better than ExceptionMonad?  Or just different.
23:46:07 <Pseudonym> The exception monad would be fine too.
23:46:15 <Pseudonym> MonadIdentity calls error on fail.
23:46:25 <Pseudonym> Exception monads give catchable exceptions.
23:46:42 <seth_> I didn't know that about MonadIdentity
23:47:28 <seth_> do you know off hand how to use lfc from ghci?  If not I'll look it up in the user's guide; just being lazy.  :)
23:47:43 <Pseudonym> lfc?
23:48:19 <seth_> do I start ghci with -package lfc?
23:48:29 <Pseudonym> What's lfc?
23:48:35 <seth_> hfc
23:48:37 <seth_> sorry
23:48:43 <Pseudonym> Ah.  Yes, you do.
23:48:44 <seth_> :)
