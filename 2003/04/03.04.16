00:40:51 <Marvin--> ARGH
00:48:05 <Marvin--> dennis: coming or going? ;)
00:48:46 <dennis> I plan to stay!
00:49:15 <dennis> I've put in an extra fan in my machine now, all seems to be working
00:50:17 <dennis> As far as I know I've just been out and in two times, but maybe it was more at your end :-)
00:50:45 <Marvin--> I didn't really count, but it's not as if there's been any other traffic :)
00:50:53 <dennis> Aah
00:51:35 <dennis> I also took apart the cpu fan, it was 2 cm of dust between the fan and the cooler. I'm surprised if any of the air got in before..
00:51:44 <Marvin--> ouch
00:52:25 <Marvin--> "Rumour has it that the Iraqi Information Minister has been employed by the British Government to inform the British people that Chancellor's new budget is actually all good news.
00:52:25 <Marvin--> I guess they beat the swedish government to it."
00:53:06 <dennis> The computer is in my closet. It's very hot, and a lot of dust in there from all the clothes.
00:53:27 <dennis> Another rumour is that he commited suicide
00:56:42 <Marvin--> [PCon "Cons" [PVar "x",PVar "xs"],PCon "Cons" [PVar "y",PVar "ys"]]
00:56:42 <Marvin--> [PCon "Nil" [],PVar "y1"]
00:56:42 <Marvin--> [PCon "Cons" [PVar "z1",PVar "z2"],PCon "Nil" []]
00:56:43 <Marvin--> YAY
00:56:48 <Marvin--> (about bloody time too)
00:57:30 <Marvin--> (overlapping pattern matching to non-overlapping pattern matching translation)
00:59:50 <dennis> Nice, it's more complicated then one thinks before one has tried it...
01:02:04 <Marvin--> oh yes
02:57:48 <funktor> @type const
02:57:49 <lambdabot> const :: a -> b -> a
02:58:30 <funktor> can anyone explain to me, what this func is supposed to do?
03:00:45 <funktor> const k _ = k
03:01:12 <funktor> what a pointless thing!
03:01:18 <funktor> why would one need that, for foldr?
03:02:31 <Darius> it's quite useful along with id
03:04:39 <Darius> Another fact is it and the function \f g x.f x (g x) are all you need to compute all things computable
03:06:22 <Darius> I used const at least 6 times in the code for EvalModule
03:07:23 <ludde> funktor: it's useful when you want to throw away the argument and always return the same thing
03:07:50 <ludde> "const 1" always returns 1, even if you give it "hello"
03:10:03 <Darius> it most useful for higher-order functions.  E.g. if you want to replace every element of a tree (that's an instance of functor) with x, then you can do: fmap (const x) the_tree
03:15:30 <funktor> ahh, I start to get it, thanks guys
03:16:51 <Janni> main
03:16:58 <Janni> err.. moin
03:47:40 <ibid> any helium people here?
03:48:55 <shreya> *high pitch* hey ibid
03:50:08 <ibid> yes?
04:02:48 <Janni> There is no such rocking music older than 100 years than Beethoven's Waldstein Sonata. And I don't mean just _good_, but really _rocking_. It's amazing...
04:38:20 <funktor> ahh, so const x is basicly the same as (\_ -> x)
04:40:51 <dennis> funktor: exactly
04:41:11 <dennis> it's the constant function that always returns x
04:41:17 <funktor> hmm, like do, I actually find it easier to understand without syntactic sugar...
04:41:29 * funktor prefers >>= and >= over do-notation...
04:43:15 <Darius> >=? greater than or equal?
04:43:31 <funktor> er >> I ment
04:43:47 <Darius> and const isn't syntactic sugar, it's just a definition
04:44:00 <funktor> ok, right.
04:44:19 <Riastradh> const is just the K combinator, isn't it?
04:44:48 <funktor> heh, /me feels out of place here with his zero-math-background sometimes :)
04:45:25 <Riastradh> Bah, the Lambda-Calculus is easy.
04:45:36 <Riastradh> If you understand functions in Haskell, you'll understand them in the Lambda-Calculus.
04:45:49 <Riastradh> @definitions
04:45:49 <lambdabot> ["Branch","Cons","I","Just","K","K2","Leaf","Left","Nil","Nothing","Pair","Right","S","X","Y","a","ana","apo","append","car","cata","cdr","const","drop","either","flip","fold","fst","head","id","iterate","lookupTree","map","maybe","modifyTree","not","null","pair","para","product","replicate","return","snd","sum","tail","take","tree","undefined","unfold"]
04:46:14 <Riastradh> The syntax is just a little different.
04:46:41 <funktor> I learned all I know about lambda-calculus from sicp...
04:46:52 <Riastradh> There's no pattern matching, and instead of writing: \foo -> bar, you write: \foo. bar
04:47:01 <Riastradh> @eval (\foo. foo) 5
04:47:01 <lambdabot> 5
04:47:05 <Janni> @fact sicp
04:47:05 <lambdabot> Structure and Interpretation of Computer Programs, http://mitpress.mit.edu/sicp/
04:47:19 <Riastradh> @get-definition I
04:47:20 <lambdabot>  \x.x
04:47:23 <Riastradh> @get-definition K
04:47:23 <lambdabot>  \x y.x
04:47:26 <Riastradh> @get-definition S
04:47:26 <lambdabot>  \f g x.f x (g x)
04:47:46 <Janni> Whoa, lambdabot is really knowledgable.
04:48:06 <funktor> anyone mind explaining the deeper meaning of S?
04:48:18 <Riastradh> S is the distributor function.
04:48:34 <Riastradh> s/function/combinator/1
04:48:50 <Riastradh> Given f and g, it distributes x amongst them.
04:49:33 <funktor> hmm
04:49:35 <Riastradh> So, you might do:  (S K K foo) -- that would distribute foo amongst K and K -- K foo (K foo)
04:49:41 <Riastradh> K ignores its second argument, so foo is returned.
04:49:51 <Riastradh> (S K K), by the way, is how you can define I, the identity function.
04:49:52 <Riastradh> @eval I 5
04:49:53 <lambdabot> 5
04:49:56 <Riastradh> @eval (S K K) 5
04:49:57 <lambdabot> 5
04:50:32 <funktor> @eval: S K K $ 5
04:50:32 <lambdabot> Sorry, I don't know the command "eval:", try "lambdabot: @listcommands"
04:50:55 <funktor> @eval S K K $ 5
04:50:56 <lambdabot> (line 1, column 7):
04:50:56 <lambdabot> unexpected "$"
04:50:56 <lambdabot> expecting var, num, bool, "(", operator, simple term or end of input
04:51:04 <Riastradh> You don't need the '$' -- function calls are left-associative.
04:51:07 <Riastradh> @eval S K K 5
04:51:07 <lambdabot> 5
04:51:20 <Riastradh> I just parenthesised it to emphasise the fact that you could replace I with it.
04:51:25 * funktor is still struggling with $ and . sometimes
04:51:54 <Riastradh> $ is generally used after . -- foo . bar $ baz is the same as foo (bar (baz))
04:52:03 <Janni> $ just says: "Everything after me is in brackets"
04:52:13 <Riastradh> $ is used generally because you want to use fewer parentheses, since it doesn't have a very high priority.
04:52:34 <Riastradh> foo bar baz $ quux zot mumble   -- that parses to: (foo bar baz) $ (quux zot mumble)
04:53:15 <Janni> Is there difference between "brackets" and "parenthesis"?
04:53:31 <funktor> brackets are usually [] iirc
04:53:35 * Riastradh has always referred to [ and ] as 'brackets' and ( and ) as 'parentheses' (and { and } as curly braces).
04:54:21 <Riastradh> The example I just gave could have otherwise been written as:
04:54:25 <Riastradh> foo bar baz (quux zot mumble)
04:54:40 <Janni> Hmm. My (English <-> German) dictionary doesn't know a plural of parethesis...
04:54:58 <Riastradh> And actually, it's the same amount of typing, since you remove two parentheses, and you put a $ and a space.
04:55:48 <funktor> ahhh, maybe is a good case for const...
04:56:13 <Riastradh> The plural of 'parenthesis' is 'parentheses.'
04:56:17 <funktor> @eval maybe False  $ const True $ Nothing
04:56:17 <lambdabot> (line 1, column 14):
04:56:17 <lambdabot> unexpected "$"
04:56:17 <lambdabot> expecting var, num, bool, "(", operator, simple term or end of input
04:56:37 <Riastradh> ...er, this Lambda-Calculus doesn't support '$'.
04:57:46 <Riastradh> @get-definition True
04:57:46 <lambdabot> True not defined
04:57:50 <Riastradh> Oh, hrmph.
04:57:53 <funktor> @eval maybe False (const True) Nothing
04:57:53 <lambdabot> False
04:58:05 <Riastradh> @get-definition B
04:58:05 <lambdabot> B not defined
04:58:15 <Riastradh> @define B \f g x. f (g x)
04:58:15 <lambdabot> B defined
04:58:36 <Janni> @define True \x y. x
04:58:37 <lambdabot> True defined
04:58:39 <Riastradh> @define lcTrue K
04:58:39 <lambdabot> lcTrue defined
04:58:44 <Riastradh> @define lcFalse (B K)
04:58:44 <lambdabot> lcFalse defined
04:58:45 <Janni> @define False \x y. y
04:58:46 <lambdabot> False defined
04:58:53 <Riastradh> @define lcIf I
04:58:53 <lambdabot> lcIf defined
04:59:09 <Riastradh> @eval lcIf lcTrue 0 1
04:59:10 <lambdabot> 0
04:59:15 <Riastradh> @eval lcIf lcFalse 0 1
04:59:15 <lambdabot> <<EM Dynamic -> EM Dynamic>>
04:59:19 <Riastradh> ...?
04:59:21 <Riastradh> Oh, hrm.
04:59:24 <Riastradh> Maybe it's (C K).
04:59:28 <Riastradh> @define lcFalse (C K)
04:59:28 <lambdabot> lcFalse defined
04:59:32 <Riastradh> @eval lcIf lcFalse 0 1
04:59:32 <lambdabot> unbound variable: C
04:59:38 <Janni> @define chTrue \x y. x
04:59:39 <lambdabot> chTrue defined
04:59:43 <Riastradh> @define C (\f g x. (f x) g)
04:59:43 <lambdabot> C defined
04:59:45 <Janni> @define chFalse \x y. y
04:59:45 <lambdabot> chFalse defined
04:59:48 <Riastradh> @eval lcIf lcFalse 0 1
04:59:49 <lambdabot> 1
04:59:49 <Janni> @undefine True
04:59:49 <lambdabot> Sorry, I don't know the command "undefine", try "lambdabot: @listcommands"
04:59:52 <Riastradh> That's better.
04:59:53 <Riastradh> True
04:59:54 <Riastradh> ER.
04:59:56 <Riastradh> @eval True
04:59:57 <lambdabot> True
05:00:09 <Riastradh> I guess you can't redefine True.
05:00:18 <Janni> @listcommands
05:00:18 <lambdabot> I react to the following commands: ["define","definitions","del-definition","dump","echo","eval","fact","fortune","get-definition","goodbye","hello","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","more","msg","part","quit","resume","searchml","set-fuel","showml","state","topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type","yow"]
05:00:22 <Riastradh> @yow
05:00:23 <lambdabot> Today, THREE WINOS from DETROIT sold me a framed photo of
05:00:23 <lambdabot>  TAB HUNTER before his MAKEOVER!
05:00:32 <Riastradh> @listmodules
05:00:33 <lambdabot> I have the following modules installed: ["eval","fact","fortune","hello","karma","more","searchml","state","system","topic","type","yow"]
05:00:39 * Riastradh goes away.
05:00:41 <Janni> @del-definition True
05:00:41 <lambdabot> not enough privileges
05:00:44 <Janni> @del-definition False
05:00:45 <lambdabot> not enough privileges
05:00:58 <Janni> :'-(
05:01:03 <Janni> He doesn't like me...
05:01:32 <funktor> well, I'd protect myself against someone trying to destruct my notion of falsehood :)
05:02:05 <Janni> @get-definition I
05:02:06 <lambdabot>  \x.x
05:02:18 <Janni> @define chIf I
05:02:19 <lambdabot> chIf defined
05:03:45 <funktor> hmm, is @eval written from scratch, or is that based on some predefined haskell-parser?
05:03:50 <Janni> @define chNot \x y z . x z y
05:03:50 <lambdabot> chNot defined
05:04:28 <Darius> Scratch
05:04:45 <Janni> @eval chIf (chNot chFalse) 1 2
05:04:46 <lambdabot> 1
05:06:40 <Janni> @eval chAnd \x y . x y chFalse
05:06:41 <lambdabot> unbound variable: chAnd
05:06:49 <Janni> @define chAnd \x y . x y chFalse
05:06:50 <lambdabot> chAnd defined
05:07:20 <Darius> True and False are builtin and Haskell's True and False
05:07:42 <Janni> @define chOr \x y . x chTrue y
05:07:42 <lambdabot> chOr defined
05:08:24 <Janni> Don't be scared. I won't define the churchian numbers :)
05:08:53 <Darius> @get-definition modifyTree
05:08:54 <lambdabot>  \i f.tree (\x.Leaf (f x)) (\l k r.if i < k then Branch (modifyTree i f l) k r else Branch l k (modifyTree i f r))
05:09:00 <Darius> @get-definition Leaf
05:09:00 <lambdabot>  \x l b.l x
05:09:05 <Darius> @get-definition Branch
05:09:05 <lambdabot>  \l k r lk bk.bk l k r
05:09:07 <Darius> @get-definition tree
05:09:08 <lambdabot>  \l b t.t l b
05:09:35 <Janni> @eval (chNot chAnd) True True
05:09:36 <lambdabot> type error
05:09:47 <Janni> @eval (chNot chAnd) chTrue chTrue
05:09:47 <lambdabot> <<EM Dynamic -> EM Dynamic>>
05:10:07 <Darius> @eval chNot chAnd chTrue chTrue 1 2
05:10:07 <lambdabot> 1
05:10:24 <Janni> err.. yeah
05:11:18 <Darius> A word of warning, the (:) and (++) operators are strict in both arguments (quite annoyingly)
05:11:30 <Janni> lambdabot shuld be able to print out lambda expressions as results...
05:12:38 <Darius> @definitions
05:12:39 <lambdabot> ["B","Branch","C","Cons","False","I","Just","K","K2","Leaf","Left","Nil","Nothing","Pair","Right","S","True","X","Y","a","ana","apo","append","car","cata","cdr","chAnd","chFalse","chIf","chNot","chOr","chTrue","const","drop","either","flip","fold","fst","head","id","iterate","lcFalse","lcIf","lcTrue","lookupTree","map","maybe","modifyTree","not","null","pair","para","product","replicate","return","snd","sum","tail","take","tree","undefined
05:13:06 <Darius> @get-definition fold
05:13:06 <lambdabot>  \f b l.l b (\x y.f x)
05:14:30 <Darius> @define iterate \f.ana (\s.Just (Pair s (f s)))
05:14:30 <lambdabot> iterate defined
05:14:46 <Darius> @get-definition take
05:14:46 <lambdabot>  \n l.if null l || n <= 0 then Nil else Cons (car l) (take (n-1) (cdr l))
05:15:05 <Darius> @define toList cata (\x y.x:y) []
05:15:05 <lambdabot> toList defined
05:15:50 <Darius> @eval toList (take 10 (iterate (const 'h') 'a'))
05:15:51 <lambdabot> type error
05:17:53 <Darius> @define list \c n l.l c n
05:17:54 <lambdabot> list defined
05:18:26 <Darius> @define nullL list (K (K False)) True
05:18:27 <lambdabot> nullL defined
05:19:12 <Darius> @define take \n l.if nullL l || n <= 0 then Nil else Cons (car l) (take (n-1) (cdr l))
05:19:12 <lambdabot> take defined
05:19:18 <Darius> @eval toList (take 10 (iterate (const 'h') 'a'))
05:19:18 <lambdabot> type error
05:19:43 <Darius> @get-definition car
05:19:44 <lambdabot>  fold const undefined
05:19:59 <Darius> @get-definition unfold
05:20:00 <lambdabot>  \f s.maybe Nil (\p.Cons (fst p) (unfold f (snd p))) (f s)
05:20:17 <Darius> @get-definition fold
05:20:17 <lambdabot>  \f b l.l b (\x y.f x)
05:20:57 <Darius> @eval fold (\x y.x+y) 0 (Cons 3 (Cons 2 (Cons 1 Nil))))
05:20:58 <lambdabot> (line 1, column 49):
05:20:58 <lambdabot> unexpected ")"
05:20:58 <lambdabot> expecting var, num, bool, "(", operator, simple term or end of input
05:21:01 <Darius> @eval fold (\x y.x+y) 0 (Cons 3 (Cons 2 (Cons 1 Nil)))))
05:21:02 <lambdabot> (line 1, column 49):
05:21:02 <lambdabot> unexpected ")"
05:21:02 <lambdabot> expecting var, num, bool, "(", operator, simple term or end of input
05:21:09 <Darius> @eval fold (\x y.x+y) 0 (Cons 3 (Cons 2 (Cons 1 Nil)))
05:21:10 <lambdabot> 6
05:21:32 <Darius> nullL Nil
05:21:39 <Darius> @eval nullL Nil
05:21:39 <lambdabot> <<EM Dynamic -> EM Dynamic>>
05:21:55 <Darius> @get-definition nullL
05:21:55 <lambdabot>  list (K (K False)) True
05:22:20 <Darius> @get-definition Nil
05:22:20 <lambdabot>  const
05:22:24 <Darius> @get-definition Cons
05:22:24 <lambdabot>  \a l k f.f a l (l k f)
05:22:54 <Darius> @define Cons \a l n c.c a l
05:22:55 <lambdabot> Cons defined
05:24:15 <Darius> @define fold \c n.list n (\a l.c a (fold c n l))
05:24:16 <lambdabot> fold defined
05:24:37 <Darius> @eval fold (\x y.x+y) 0 (Cons 3 (Cons 2 (Cons 1 Nil)))
05:24:38 <lambdabot> 6
05:25:07 <Darius> @eval nullL Nil
05:25:07 <lambdabot> <<EM Dynamic -> EM Dynamic>>
05:25:31 <Darius> @define nullL list True (K (K False))
05:25:32 <lambdabot> nullL defined
05:25:34 <Darius> @eval nullL Nil
05:25:34 <lambdabot> True
05:25:40 <Darius> @eval nullL (Cons 4 Nil)
05:25:41 <lambdabot> False
05:26:14 <Darius> @eval toList (take 10 (iterate (const 'h') 'a'))
05:26:14 <lambdabot> type error
05:26:40 <Darius> @eval car (Cons 4 Nil)
05:26:40 <lambdabot> 4
05:26:45 <Darius> @eval cdr (Cons 4 Nil)
05:26:46 <lambdabot> <<EM Dynamic -> EM Dynamic>>
05:27:12 <Darius> @define car list undefined const
05:27:12 <lambdabot> car defined
05:27:28 <Darius> @define cdr list undefined (K I)
05:27:29 <lambdabot> cdr defined
05:27:36 <Darius> @eval car (Cons 4 Nil)
05:27:37 <lambdabot> 4
05:27:43 <Darius> @eval cdr (Cons 4 Nil)
05:27:43 <lambdabot> <<EM Dynamic -> EM Dynamic>>
05:27:53 <Darius> @eval toList (cdr (Cons 4 Nil))
05:27:53 <lambdabot> []
05:28:01 <Darius> @eval toList (take 10 (iterate (const 'h') 'a'))
05:28:02 <lambdabot> ahhhhhhhhh
05:36:37 <shapr> hm
05:39:15 <Darius> @eval toList (take 100 (iterate (const 'h') 'a'))
05:39:15 <lambdabot> ahhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
05:39:37 <Darius> @eval toList (take 3 (iterate (const 'm') 'h'))
05:39:37 <lambdabot> hmm
05:45:52 <Darius> @define zero \z s.z
05:45:53 <lambdabot> zero defined
05:45:58 * shapr boings
05:46:04 <Darius> @del-define zero
05:46:05 <lambdabot> Sorry, I don't know the command "del-define", try "lambdabot: @listcommands"
05:46:13 <Darius> @del-definition zero
05:46:14 <lambdabot> zero removed
05:46:20 <Darius> @define Zero \z s.z
05:46:21 <lambdabot> Zero defined
05:46:38 <Darius> @define Succ \n z s.s n
05:46:39 <lambdabot> Succ defined
05:46:40 <shapr> Darius: should I start checking in the definitions file as well? :-)
05:46:49 <Darius> @definitions
05:46:50 <lambdabot> ["B","Branch","C","Cons","False","I","Just","K","K2","Leaf","Left","Nil","Nothing","Pair","Right","S","Succ","True","X","Y","Zero","a","ana","apo","append","car","cata","cdr","chAnd","chFalse","chIf","chNot","chOr","chTrue","const","drop","either","flip","fold","fst","head","id","iterate","lcFalse","lcIf","lcTrue","list","lookupTree","map","maybe","modifyTree","not","null","nullL","pair","para","product","replicate","return","snd","sum","t
05:47:34 <Darius> The... something (probably related te @more) needs to be messed with
05:47:53 <Darius> @del-definition null
05:47:53 <lambdabot> null removed
05:47:56 <Darius> @del-definition head
05:47:56 <lambdabot> head removed
05:47:58 <Darius> @del-definition tail
05:47:58 <lambdabot> tail removed
05:48:03 <Darius> @definitions
05:48:04 <lambdabot> ["B","Branch","C","Cons","False","I","Just","K","K2","Leaf","Left","Nil","Nothing","Pair","Right","S","Succ","True","X","Y","Zero","a","ana","apo","append","car","cata","cdr","chAnd","chFalse","chIf","chNot","chOr","chTrue","const","drop","either","flip","fold","fst","id","iterate","lcFalse","lcIf","lcTrue","list","lookupTree","map","maybe","modifyTree","not","nullL","pair","para","product","replicate","return","snd","sum","take","toList",
05:48:27 <Darius> @get-definition C
05:48:27 <lambdabot>  (\f g x. (f x) g)
05:48:46 <Darius> @define C \f x y.f y x
05:48:47 <lambdabot> C defined
05:49:31 <Darius> @define nat \z s n.n z s
05:49:31 <lambdabot> nat defined
05:49:59 <Darius> @define inc \x.x+1
05:50:00 <lambdabot> inc defined
05:50:30 <Darius> @eval (succ zero) inc
05:50:31 <lambdabot> unbound variable: succ
05:50:41 <Darius> @eval (Succ Zero) inc 0
05:50:41 <lambdabot> type error
05:51:23 <Darius> @eval nat inc 0 (Succ Zero) 0
05:51:24 <lambdabot> type error
05:51:26 <Darius> @eval nat inc 0 (Succ Zero)
05:51:26 <lambdabot> type error
05:52:14 <Darius> @eval nat 0 inc (Succ Zero) 0
05:52:14 <lambdabot> type error
05:52:16 <Darius> @eval nat 0 inc (Succ Zero)
05:52:16 <lambdabot> type error
05:52:31 <Darius> @define foldNat \z s.nat z (fold z s)
05:52:31 <lambdabot> foldNat defined
05:52:49 <Darius> @eval foldNat 0 inc Zero
05:52:50 <lambdabot> 0
05:52:56 <Darius> @eval foldNat 0 inc (Succ Zero)
05:52:56 <lambdabot> <<EM Dynamic -> EM Dynamic>>
05:53:44 <Darius> @get-definition Succ
05:53:45 <lambdabot>  \n z s.s n
05:54:04 <Darius> @get-definition Zero
05:54:05 <lambdabot>  \z s.z
05:54:11 <Darius> @get-definition nat
05:54:12 <lambdabot>  \z s n.n z s
05:54:26 <Darius> @define foldNat \z s.nat z (foldNat z s)
05:54:27 <lambdabot> foldNat defined
05:54:30 <Darius> @eval foldNat 0 inc (Succ Zero)
05:54:31 <lambdabot> 0
05:54:44 <Darius> @eval foldNat 0 inc Zero
05:54:44 <lambdabot> 0
05:55:08 <Darius> @eval nat 0 (K 1) Zero
05:55:09 <lambdabot> 0
05:55:16 <Darius> @eval nat 0 (K 1) (Succ Zero)
05:55:17 <lambdabot> 1
05:55:28 <ibid> please, take that to /msg
05:55:38 <Darius> ok
05:58:07 <shapr> yow
05:58:32 <shapr> the guy who wrote the original yacc grammar for lojban, just said he thinks a spoken programming language is a bad idea.
05:58:34 <shapr> that sucks.
06:05:00 <shapr> hey jewel!
06:05:01 <shapr> wassup?
06:05:04 <shapr> ltns
06:05:20 <Arnia> The problem with 'logical' languages and in fact all conlangs its that they contain insufficient error compensation and aren't designed for parsing by the unification parsers of the brain :(
06:05:37 <shapr> Arnia: have you tried lojban?
06:07:39 <Arnia> shapr: Yes. Natural languages are in fact constantly moving to optimality... conlangs are generally far from optimal
06:08:24 <shapr> coi jewel 
06:08:27 <shapr> .i do mo
06:09:26 <shapr> doi le arnia .i xu do tavla fo mi la lojban
06:09:35 <shapr> seems pretty straightforward to me :-)
06:11:51 <Arnia> shapr: But suboptimal... you'll find its hard to reconstruct context with a bad input stream (like we deal with every day) plus it isn't amenable to unification grammars (and hence takes more work for the brain to decode including some conscious shuffling)
06:12:07 <shapr> what's a unification grammar?
06:12:58 <shapr> I think it takes less work to decode lojban
06:13:10 <shapr> mostly because each 'predicate' is both a noun and a verb
06:13:27 <shapr> so you just parse the concept, and then 'switch' according to how it's used.
06:14:31 <shapr> plus, every lojban predicate does partial application as well
06:14:34 <Arnia> shapr: Unification grammars are the sort of grammar reckoned to be used by the brain. Read up on Head-Driven Feature Structure Grammar (see the Pollard and Sag book of the same name from 1994) for more information
06:15:29 <shapr> for example, pilno is use/employ ; x1 uses/employs x2 [tool, apparatus, machine, agent, acting entity, material] for purpose x3
06:15:36 <Arnia> shapr: Yes, that's a bad language design. No redundancy and lack of stability in the face of error. NatLangs contain much redundancy and dual encoding for that reason. The ear uses dual encoding as well, marking up frequencies in two different ways.
06:15:45 <shapr> so, se pilno means "flip pilno"
06:15:46 <shapr> or "tool"
06:16:10 <jewel> coi doi
06:16:42 <shapr> do mo
06:16:42 <Arnia> shapr: Logical languages are eminently unsuitable for the brain and for the world because of the awkward structure (neurologically speaking) and the lack of redundancy.
06:16:54 <shapr> Arnia: maybe they're good for spoken programming though :-)
06:18:07 <Arnia> shapr: Not so sure. I'm in agreement with the idea that spoken programming is a bad idea
06:18:11 <jewel> Arnia: have you tried lojban?
06:18:12 <shapr> why?
06:19:24 <shapr> YAY
06:19:28 <shapr> new HASKELL WIKI
06:19:29 <shapr> w00
06:19:46 <shapr> http://www.haskell.org/hawiki/
06:21:46 <SyntaxPolice> haha! he went with moin, 'eh?
06:22:26 * shapr bounces happily
06:22:29 <shapr> yay! new wiki!
06:22:34 <shapr> SyntaxPolice: yes, I'm thrilled!
06:25:07 <SyntaxPolice> shapr: you can partly thank me for talking him into it :-)
06:25:47 <shapr> thanks SyntaxPolice!
06:26:17 <o3> aww, i thought the haskell wiki announcement was a wiki written in haskell
06:26:40 <shapr> o3: do it :-)
06:28:24 <shapr> a straightforward port of the original wiki code wouldn't take too long
06:30:29 <o3> hehe, got too much else to do, sorry :)
06:30:39 <shapr> yah, me too
06:35:24 <SyntaxPolice> shapr: how do you get to the HaskellIRC page?
06:35:48 * SyntaxPolice feels like there should be a link to "communities" or something on the front page.
06:36:22 <shapr> create one
06:41:54 <funktor> shapr!
06:42:17 <funktor> its done, it plays, and, (blush) it already beats me!
06:53:56 <shapr> funktor: yay! when do we get code?
06:54:43 <funktor> shapr: I fear monday, at the earliest
06:54:54 <shapr> I'll try to be patient....
06:55:26 * shapr waits patiently, sort of...
06:55:29 * shapr bounces
06:55:30 <funktor> its fairly fast too, computes a move with depth 4 (4 half-move plies) in about 10 secs
06:55:46 <shapr> with what CPU/RAM demand?
06:56:02 <funktor> 800MHZ cpu, ram demand is fairly low, 3MB iirc
06:56:10 <shapr> wow
06:56:33 <shapr> cool, let's optimize it =)
06:56:44 * shapr is now less patient
06:56:51 <funktor> I'd love to write a alpha-beta version too, but I'm too stupid to convert a FORTRAN algorithm into haskell...
06:57:29 <shapr> well, tell me when the code hits cvs!
06:57:31 * shapr bounces
06:57:43 <shapr> funktor: you want to write a lambdabot plugin for it?
06:58:01 <shapr> I'd love to write a lambdabot plugin for it, of course
06:58:11 <funktor> ok, thats your job then...
06:58:15 <shapr> but I've written lots of lambdabot plugins, I should save some of the fun for other people too :-)
06:58:18 <funktor> it will need threading somehow...
06:58:22 <shapr> yes!
06:58:29 <shapr> I want to add module calls in a separate thread
06:58:46 <funktor> @bestMove White 7k/5ppp/R/K
06:58:47 <lambdabot> Sorry, I don't know the command "bestMove", try "lambdabot: @listcommands"
06:58:59 <funktor> something like that would be fun, and a way to actually initiate a game...
06:59:05 <shapr> I've been thinking about per-user state as well
06:59:25 <shapr> so different people can all be playing at the same time
06:59:26 <shapr> oh oh
06:59:35 <shapr> I'll be able to add erc-chess integration!
06:59:38 <shapr> w00
06:59:51 <funktor> right!
06:59:52 <shapr> and then humans can play against each other or your code
06:59:59 * shapr bounces lots
07:00:06 <shapr> ok, now I'm *really* impatient.
07:00:12 <funktor> we'll need a short-algebraic parser though
07:00:20 <funktor> I'm using long-algebraic right now
07:00:30 <shapr> if you tell me what that is, I'll hack on it.
07:00:51 <funktor> Pe2-e4 is the long-algebraic
07:01:06 <funktor> short-algebraic would just say "e4" given that only one piece can move to e4...
07:01:22 <funktor> so you need readAlgebraic :: String -> Board -> MoveInFull
07:01:55 <shapr> oh
07:02:06 <shapr> I'll think about that.
07:02:13 <funktor> but its kind of hard to do this without functions like moveDetailsFor :: Colour -> Board -> [MoveInFull]
07:02:17 <shapr> I don't think I'll be able to write it without seeing your long-algebraic code
07:02:36 <dennis> the only way to parse algebraic notation is to generate all moves and "remove" all that don't match the string move
07:02:50 <dennis> well, not only way but I guess the simples
07:02:52 <dennis> t
07:03:18 <shapr> dennis: oh, that's a good idea
07:03:21 <funktor> its still tricky, you can have stuff like dxe5 and such...
07:03:23 * dennis loves chess
07:03:39 <shapr> dennis:  that way, you could do short-algebraic even for long moves
07:03:41 <dennis> funktor: I know, I've written a chessprogram in C (many years ago)
07:03:58 <shapr> because an 'interactive' parser could ask you which piece you want to move to that square
07:04:23 <mgoetze> dennis: learn go :)
07:04:34 <shapr> so, short notation could take either a piece or a destination square as input
07:04:43 <dennis> mgoetze: I still don't master chess
07:04:49 <dennis> :-)
07:05:02 <shapr> and then if a piece has multiple moves, or if multiple pieces could go to the destination, ask the user for further input based on the options
07:05:03 <shapr> neat
07:05:07 <shapr> funktor: I like it!
07:05:08 <mgoetze> dennis: there's no need to, your computer can play it very well :)
07:05:13 <dennis> shapr: there are exact rules of how algebraic notation looks
07:05:18 <shapr> ah, I see
07:05:31 <funktor> finding a spec for that would be a good start
07:05:49 <shapr> funktor: ok, I'll look it up.
07:06:15 <shapr> funktor: hey, did any ideas for improvement occur to you when you looked through the lambdabot sources?
07:06:35 <funktor> hmm, come to think of it, I might be able to get a real RJ45 internet connection tomorrow afternoon... hmm, lets see
07:06:36 <shapr> I know you have lots more experience writing IRC code than me
07:07:24 <funktor> shapr: not really, I just looked at it very briefly...
07:07:54 <funktor> And, Bots usually do need just a very little subset of IRC... since they only use privmsg most of the time.
07:08:47 <shapr> I've had the idea to turn lambdabot into a real irc client, with ncurses
07:10:41 <funktor> hey, there is ERC, what use is there for YAIC? :)
07:11:08 <SyntaxPolice> so for the communities page, I put the channel, the mailing lists... any other ideas?
07:11:22 <SyntaxPolice> oh the communities report
07:12:27 <shapr> funktor: what about VInfidels?
07:15:03 <SyntaxPolice> OK, if you have any ideas, you can add them!
07:15:13 <shapr> yah!
07:15:17 <shapr> what's the url?
07:15:19 <SyntaxPolice> oops, I didnt' put a log entry.
07:15:29 <SyntaxPolice> I linked it to the front, but its HaskellCommunities
07:15:39 <SyntaxPolice> http://www.haskell.org/hawiki/HaskellCommunities
07:17:27 <funktor> shapr: wha?
07:19:04 <shapr> vi users :-)
07:20:15 <shapr> oh, I need to update the http://purl.org/wiki/haskell/ forward
07:21:16 <funktor> shapr: Oh, they are real?
07:21:25 * shapr laughs
07:21:30 <funktor> I always thought they were some imaginary evil or something :)
07:21:48 <shapr> several #haskell people use VI
07:21:53 <shapr> er, vim I guess
07:22:09 <funktor> eVIl
07:22:12 <shapr> heh
07:22:36 * Darius is a vim'er
07:22:48 <shapr> see!
07:22:50 <shapr> evil!
07:22:51 <shapr> er
07:23:00 * shapr is just teasing, of course
07:23:28 <funktor> well, vi always beeps at me...
07:23:33 <Darius> Of course. We all know that emacs is evil
07:24:30 <funktor> typical vi session of mine: J <swear> ESC x J ...
07:24:52 * shapr snickers
07:24:58 <shapr> lambdabot: @holywar
07:24:59 <lambdabot> Sorry, I don't know the command "holywar", try "lambdabot: @listcommands"
07:25:14 <shapr> oh, I have to figure out how apt does holywar
07:25:26 <funktor> @oilwar
07:25:27 <lambdabot> Sorry, I don't know the command "oilwar", try "lambdabot: @listcommands"
07:25:41 <funktor> hmm, so he isn't american, is he? :)
07:25:44 <shapr> :-P
07:26:19 <shapr> war is wrong.
07:26:40 <shapr> just because my country is doing something wrong, doesn't mean all americans agree with it ;-)
07:27:53 <shapr> SyntaxPolice: hey, you should create a HaWiki page
07:28:02 <funktor> shapr: But pressuring all those Americans like that is the best way to get them to vote for a sane person next time...
07:28:12 <funktor> if they dont feel the pressure, they will not really care that much
07:28:43 <shapr> oh, I think they do care.
07:28:58 <funktor> btw, anti-war demos are much larger in europe, so either they are afraid of Intelligence, or they dont care...
07:29:48 * funktor </politics>
07:30:53 <Darius> lambda pumping... that's a new one
07:32:47 <shapr> Darius: keep those mental muscles strong
07:32:52 * shapr does some lambda lifting
07:32:55 <shapr> hi basti_ 
07:32:58 <shapr> gutentag
07:33:02 <basti_> hi all :)
07:33:22 <shapr> learning Haskell? or looking for other users?
07:33:22 <Marvin--> afternoon
07:33:26 <shapr> y0 Marvin-- 
07:33:31 <basti_> hmm... something inbetween...
07:33:33 <funktor> hey marvin--
07:33:42 <shapr> Marvin--: I had something to ask you, but I've forgotten it :-/
07:33:56 <basti_> i just thought i have a look...
07:34:03 <shapr> funktor: the politics that scares me right now is IPR,DRM,DMCA,RIAA, etc
07:34:15 <basti_> i think haskell is a cool language and definetly plan to do some more things in it...
07:34:18 <Marvin--> shapr: been there, done that :)
07:34:24 <shapr> Marvin--: it's getting worse
07:34:47 <shapr> basti_: you could look at our irc 'bot
07:34:49 <basti_> my largest project in H. was an finite automaton optimizer
07:34:49 <shapr> @fact source
07:34:49 <lambdabot>  http://sf.net/projects/haskell-libs/, http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/lambdabot/
07:35:15 <basti_> :)
07:35:25 <shapr> I'm trying to build the haskell-libs project into a sort of cvs-wiki for #haskell and other Haskell users.
07:35:30 * funktor smiles brightly
07:35:34 <basti_> I suppose its written in haskell? ;)
07:35:37 <shapr> yes!
07:35:40 <funktor> my largest Haskell project so far is a Chess-game
07:35:43 <shapr> funktor just wrote a chess game
07:35:54 <shapr> and I'm SO impatient to see the source!
07:35:57 <basti_> :)
07:35:59 <shapr> I want to plug it into lambdabot!
07:36:07 <shapr> I haven't tried doing per-user state in lambdabot yet
07:36:21 <shapr> that would give me a good reason to add full nick/user/host matching as well
07:36:24 <funktor> shapr: Try that in the meantime...
07:36:31 <shapr> and pull the module calls into their own threads
07:36:31 <basti_> that game is a multi user game?
07:37:04 <shapr> the chess game?
07:37:15 <basti_> yea
07:37:27 <shapr> I don't know, he finished it last night, and he doesn't have a 'net connect to his laptop until monday or so
07:37:35 <basti_> oh i see
07:37:41 <funktor> chess is two-player, but lambdabot could certainly play more than one game with several people at once
07:37:52 <shapr> It will be a multi user game via lambdabot at some point.
07:38:01 <basti_> I thought there was a relation between the game and the multi user features of the bot
07:38:08 <shapr> not yet
07:38:09 <shapr> but soon
07:38:11 <basti_> ;)
07:38:19 <shapr> it's *easy* to write plugins for lambdabot 
07:38:26 <basti_> of course...
07:38:26 <shapr> I've written... nine I think
07:38:33 <basti_> its always in lambda calculus languages ;)
07:38:46 <shapr> yes, lambdabot has a LC interpreter by Darius 
07:38:50 <shapr> @definitions
07:38:50 <lambdabot> ["B","Branch","C","Cons","False","I","Just","K","K2","Leaf","Left","Nil","Nothing","Pair","Right","S","Succ","True","X","Y","Zero","a","ana","apo","append","car","cata","cdr","chAnd","chFalse","chIf","chNot","chOr","chTrue","const","drop","either","flip","fold","foldNat","fst","id","inc","iterate","lcFalse","lcIf","lcTrue","list","lookupTree","map","maybe","modifyTree","nat","not","nullL","pair","para","product","replicate","return","snd",
07:39:02 <shapr> @get-definition const
07:39:02 <lambdabot>  \x y.x
07:39:25 <shapr> I'm still don't know when I would use const....
07:39:27 <basti_> seeing a lisp compiler written in lisp converted me to the belief that lc is the most advanced principle of computation
07:39:45 <funktor> hehe, read sicp? :)
07:39:52 <shapr> @fact sicp
07:39:52 <lambdabot> Structure and Interpretation of Computer Programs, http://mitpress.mit.edu/sicp/
07:40:03 <Darius> shapr: funktor was talking about that earlier
07:40:09 <Darius> const
07:40:12 <shapr> Darius: yah, I saw it in the scrollback
07:40:16 <shapr> but I'm not sure I understand it.
07:40:30 <shapr> does it just mean, "turn a value into a function" ?
07:40:36 <shapr> sort of like a value object in OOP?
07:40:36 <basti_> how do I read this function? \(x y).x or \x(y.x) ?
07:40:37 <funktor> const x == (\_ ->  x)
07:40:55 <shapr> a 'callable value' ?
07:41:10 <funktor> const k _ = k
07:41:10 <Darius> a constant function
07:41:13 <funktor> the definition is that simple
07:41:17 <funktor> nothing else behind it :)
07:41:17 <Marvin--> basti_: \x.\y.x
07:41:22 <Darius> like in math f(x)=4
07:41:22 <basti_> I see
07:41:23 <shapr> right, but what do you use it for?
07:41:49 <Marvin--> you can use it with foldr for example
07:41:56 <Darius> sum (fmap (const 1)) some_list
07:42:08 <shapr> gives you the length
07:42:12 <funktor> shapr: maybe True (const Flase)  Maybe 1
07:42:22 <shapr> funktor: huh?
07:42:26 <Marvin--> foldr (const (+1)) 0 xs
07:42:47 <shapr> oh
07:42:48 <shapr> oh!
07:42:52 <funktor> shapr: You use it if you have to use a function which one arg, but you discard the arg and return a const value
07:42:53 <shapr> interesting
07:43:12 <shapr> wow, nifty
07:43:13 <basti_> mmmh.
07:43:13 <basti_> ;)
07:43:24 <shapr> where's clausthal?
07:43:30 <funktor> German
07:43:33 <funktor> y
07:43:36 <basti_> erm... in germany... harz mountains...
07:43:37 <shapr> where in .de?
07:43:41 <shapr> north? south?
07:43:44 <basti_> hmm
07:43:46 <Marvin--> aiih, no reception on the TV
07:43:53 <shapr> Marvin--: code is more fun anyway!
07:43:56 <basti_> where niedersachsen, thüringen and hessen meet
07:43:56 <basti_> ;)
07:44:01 <Marvin--> more fun than Simpsons?
07:44:05 <basti_> a little north of the middle...
07:44:06 * Darius doesn't watch TV
07:44:08 <shapr> Marvin--: yah
07:44:11 <basti_> or north east
07:44:11 <shapr> TV is too slow.
07:44:17 <shapr> and it's not interactive.
07:44:20 <basti_> *g
07:44:24 <Marvin--> shapr: meep, wrong, thanks for playing
07:44:29 <funktor> They are responsible for alcohol-free beer (shudder)
07:44:35 <shapr> Marvin--: it's buzzer in the US
07:44:36 <basti_> *laugh*
07:44:36 <shapr> @fact
07:44:36 <lambdabot> empty factoid, BZZZT, thank you for playing!
07:44:37 <basti_> nope
07:44:44 <basti_> the alcohol free beer comes from hannover
07:44:48 <basti_> just the name is "clausthaler
07:45:15 <shapr> I really do find TV 99% slow and boring
07:45:38 <shapr> if I could heard it on fast-forward, maybe
07:45:41 <Darius> I don't watch it because there's nothing good on
07:45:50 <basti_> < brb...
07:46:02 <shapr> oh, I haven't listened to the SICP lectures I downloaded...
07:46:21 <Darius> (I'd download them but they are huge)
07:46:30 <shapr> yah, they are
07:46:35 <shapr> that's TV I could watch
07:46:40 <shapr> I wish they had TV about programming
07:46:47 <shapr> discovery channel is fun sometimes.
07:47:06 <Darius> Discovery is worth watching
07:47:33 <shapr> junkyard challenge is a sort of geeky counterpart to some of the standard game shows
07:48:05 <shapr> they had a river/boat episode, and one team was from NASA, that was great!
07:48:18 <shapr> they built a jetboat from some sort of high power pump
07:49:35 <basti_> *g*
07:49:35 <shapr> There aren't any classes on improvisation in programming.
07:49:43 <shapr> just contests
07:50:08 <shapr> basti_: do you have your code online?
07:50:32 <shapr> I've been thinking about FSMs lately
07:50:43 <basti_> hmm I could bring it in a minute or so... I just have to babysit a computer thats installing gentoo...
07:50:55 <shapr> there's BNF to describe protocol or file formats
07:51:07 <shapr> is there something like BNF to describe a state machine for a protocol?
07:51:17 <basti_> hmm...
07:51:24 <basti_> if you just have a state machine you dont need BNF
07:51:27 <basti_> its an automaton then
07:51:57 <shapr> I'd like to have a protocol construction kit for Haskell, that works like a parser generator
07:51:59 <basti_> i'd take the time and comment my code now... its also very raw form...
07:52:32 <basti_> how about a haskell flex? ;)
07:52:39 <shapr> basti_: if you can release it under an OSS compatible license, you could put it into haskell-libs
07:52:46 <shapr> with or without comments
07:52:53 <basti_> I dont know if its ready for that yet ;)
07:53:01 <basti_> its just about 100 lines or something too
07:53:18 <basti_> *looks*
07:53:27 <shapr> well, my spam filter isn't really ready for use either, but it's in haskell-libs for people to look at, comment on, play with, etc
07:53:35 <basti_> hmm wait
07:53:42 <basti_> I see i commented it... but in german
07:53:54 <Marvin--> I'm getting crappy reception on the non-cable channels and no reception at all on the cable channels :/
07:53:56 <basti_> ill translate the comments and then load it up somewhere
07:54:01 <shapr> ok, cool
07:54:13 <shapr> Marvin--: must be ECM
08:00:12 <shapr> is there a language like BNF to describe protocol interactions?
08:00:22 <shapr> something that translates into an FSM?
08:00:54 <basti_> shapr as I said, you just need a delta list... no need for a grammar...
08:01:14 <basti_> its so simple that noone bothered about standardizing I think ;)
08:02:01 <shapr> hm
08:02:46 <Darius> layout the comments right, and use a list of lists of functions as a matrix
08:04:03 <shapr> I think I'd have to see an example
08:04:07 <shapr> or write one myself
08:04:08 <basti_> hmm easy:
08:04:18 <basti_> 0 a => 1
08:04:21 <basti_> 0 b => 0
08:04:24 <basti_> 1 a => 1
08:04:27 <basti_> 1 b => 0
08:04:29 <basti_> :)
08:05:02 <shapr> that does look easy.
08:05:03 <Arnia> I think an FSM for protocols would be cool
08:05:33 <shapr> would that scale well even up to writing a TCP/IP stack in Haskel?
08:06:48 <basti_> hmm... if you do some compilation...
08:07:02 <basti_> < brb again, babysitting gentoo
08:09:57 <basti_> at least it runs sshd now.
08:10:43 <shapr> yay
08:10:53 <basti_> *typing english comments*
08:15:27 <basti_> does anyone know what a "hauptlinkskongruenz" is in english?
08:15:32 <basti_> principial left congruence?
08:15:50 * shapr sees "main link congruence"
08:16:02 <shapr> not that I know any german
08:16:03 <basti_> mmmmmmh
08:16:05 <basti_> ;)
08:16:27 <debug> hm
08:16:35 <shapr> hi debug, what's up?
08:16:46 <debug> It is a wonderful day.
08:16:49 <shapr> it is
08:16:50 <debug> (literally speaking)
08:16:54 <debug> not just virtually
08:16:57 <debug> but irl as well
08:17:00 <shapr> yup
08:17:01 <basti_> we have great weather too
08:17:02 <basti_> :)
08:17:17 * debug sat outside in the sun, and actually studied for a couple of minutes
08:17:24 <shapr> wow
08:17:34 <basti_> *g*
08:17:41 <shapr> I went to the exercise gym yesterday for the ... second time in some years
08:17:55 <shapr> I realized I'm *very* white compared to everyone else.
08:18:05 <basti_> hmm?
08:18:23 <shapr> my skin is more white than a bunch of swedes at the end of winter.
08:18:23 <basti_> you mean as opposed to tanned?
08:18:25 <shapr> that's amazing.
08:18:32 * debug should go biking more, but there's always something broken on the bike
08:18:35 <basti_> tanning gives you skin cancer
08:18:36 <shapr> yes, as opposed to tanned
08:18:43 <shapr> hey! I found a unicycle at the bike shop today!
08:18:45 <shapr> I'm in love!
08:18:54 <basti_> *g*
08:18:59 <debug> tanning also hides the radiation burn marks caused by the computer monitors
08:19:05 <shapr> debug: hah
08:19:25 <debug> a unicycle? the thing you bike to the university on?
08:19:31 <shapr> heheh
08:19:38 <shapr> uni = one
08:19:49 * debug used a two-wheel-drive bike for a while, but then had to return it
08:19:52 <shapr> it's one wheel at the bottom of a stick, with a seat on top of the stick.
08:20:03 <debug> I know :)
08:20:28 <debug> two-wheel-drive is probably like SMP, once you get used to it you cannot imagine going back
08:20:31 <debug> but I had to :(
08:20:40 <shapr> that's true of SMP
08:20:44 <shapr> I'll never go back.
08:20:52 <basti_> *g*
08:21:04 <debug> two-wheel-drive actually does its thing even on bare asphalt
08:21:15 <debug> it divides the force to both wheels during acceleration and so on
08:21:20 <debug> it's quite a nice feeling
08:21:48 <shapr> sounds like it would change the handling for the better
08:22:16 <shapr> I wonder if they have to design the front fork differently
08:22:40 <shapr> I'd really like to get one of these: http://www.mrrecumbenttrikes.com/
08:22:52 <shapr> but they're at least 1000euro :-(
08:23:36 <shapr> this unicycle is only 995 kronor ( ~100 euro )
08:25:38 * Marvin-- is reading through the scenario he's storytelling on Friday
08:25:44 <basti_> soo
08:25:48 <shapr> I'm trying to improve my spam filter
08:25:52 <basti_> the english comments are done shapr
08:25:54 <shapr> yay!
08:26:01 <mgoetze> Marvin--: storytelling? as in, vampire or something? :)
08:26:04 <basti_> ill now upload that...
08:26:06 <shapr> basti_: do you want to put it into haskell-libs?
08:26:10 <debug> http://www.spicerindustries.com/frame/2wdonoff.jpg   although this is a more modern implementation than the prototype I borrowed
08:26:14 <basti_> hmm...
08:26:22 <basti_> depends ;)
08:26:42 <shapr> debug: wow nifty, the shaft drive means the front fork shouldn't require any design changes
08:26:44 <basti_> I mean... Im concerned about the average quality of code there ;)
08:27:09 <shapr> the open source motto is "release early and often"
08:27:13 <basti_> *g*
08:27:15 <shapr> that's what I use
08:27:29 <Marvin--> mgoetze: as in Svenil, our home-made RPG that for some reason has become quite popular (as in we can't get enough storytellers for the two sessions on the convention this weekend)
08:27:31 <shapr> I put in anything that someone else might use
08:27:46 <Marvin--> this is a roadmovie scenario :D
08:28:01 <debug> shapr: the one I had looked a lot different, it had a ... I don't know the english word.. "kardanaxel" through the front fork, and a rubber chain with metal plates inside it, instead of the tube
08:28:02 <shapr> oh, mad max?
08:28:05 <basti_> http://home.tu-clausthal.de/~ifbz/finiteautomaton.lhs
08:28:07 <basti_> there it is
08:28:31 <basti_> oh
08:28:36 <basti_> i should include my email ad and stuff
08:28:48 <shapr> yah, and a license
08:28:48 <mgoetze> Marvin--: you'll have to tell me about it sometime :)
08:29:02 <basti_> I think the license will be larger than the file itself... ;)
08:29:12 <basti_> is it enough to write something like "This is GPL"? ;)
08:29:23 <shapr> works for me
08:30:42 <Marvin--> mgoetze: a friend is supposedly working on an English translation but I'm guessing he hasn't gotten far :)
08:31:05 <shapr> basti_: would you like to have cvs commit privileges for haskell-libs?
08:31:26 <shapr> if not, I can put your code into cvs myself
08:32:04 <shapr> I know that DFA/NFA/FSM is somehow related to regular expressions
08:32:08 <basti_> hmm better you put it on first... im not that much into cvs... but wait until the version with my ad and the license comment is on... (a minute or something)
08:32:10 <basti_> yes thats right
08:32:28 <shapr> I guess I need to learn the relationship
08:32:35 <basti_> oh its easy:
08:33:00 <basti_> what an DFA/NFA/FSM can "recognize" (as you call it) is exactly the same stuff a regexp can match
08:33:24 <basti_> the trick is to compile a regexp to a DFA, which can easily be interpreted by a computer.
08:33:31 <basti_> (easily = linear time)
08:33:55 <basti_> now the version with email ad and gpl annotation is on
08:34:26 <basti_> if you want to put it onto your cvs dont hesitate shapr
08:34:33 <basti_> I hope the code is correct ;)
08:35:45 <shapr> I still see the same version
08:35:51 <basti_> shift reload?
08:35:55 <shapr> I wonder if telia added a transparent web proxy recently
08:35:58 <basti_> its just a few lines of the first comment
08:36:13 <shapr> still the same
08:36:17 <basti_> mmmh
08:36:46 <basti_> dcc?
08:36:58 <shapr> my irc client doesn't support that yet
08:37:01 <shapr> sadly
08:37:06 <basti_> mh
08:37:10 <shapr> lambdabot needs dcc :-)
08:37:12 <basti_> *g*
08:37:29 <shapr> you could email it to me, shae at ScannedInAvian dot com
08:37:38 <basti_> with capital letters?
08:37:52 <shapr> doesn't matter actually :-)
08:37:57 <basti_> ic.
08:39:21 <basti_> sent it.
08:39:23 <basti_> brb
08:39:56 <shapr> yay
08:41:22 <shapr> basti_: um, it looks like this one doesn't have email/license either?
08:41:22 <ludde> shapr: I don't think telia added a transparent web proxy
08:41:35 <shapr> ludde: that's good to hear
08:41:44 <shapr> I had that with sonera in .fi, and it sucked
08:42:04 <ludde> :(
08:42:13 <shapr> happily, I'm in .se now
08:42:36 <ludde> heh
08:42:39 <ludde> where in .se?
08:42:44 <shapr> Boden!
08:42:51 <ludde> oh that's far away
08:42:53 <shapr> jag bor i Boden!
08:42:58 <shapr> det är kul!
08:43:00 <ludde> jag bor i ett hus
08:43:03 <shapr> jag kan tala lite svenska nu
08:43:14 <ludde> jag kan också prata svenska
08:43:17 <shapr> jag bor i min stor lägenhet.
08:43:28 <ludde> min storA lägenhet
08:43:30 <shapr> många rum och kök
08:43:33 <shapr> oh, right
08:43:51 <shapr> er, why is that?
08:43:52 <ludde> i dunno why it should be stora instead of stor though
08:44:01 <shapr> stor, stort, stora?
08:44:07 <ludde> hmm?
08:44:09 <ludde> what is that
08:44:12 <ludde> jag är stor
08:44:16 <ludde> huset är stort
08:44:30 <ludde> jag har många stora bilar
08:44:37 <shapr> is that because of the first/second/third person thing?
08:44:49 <ludde> jag bor i min stora lägenhet
08:44:50 <shapr> or is that the gender of the noun being described?
08:44:54 <ludde> jag bor i mitt stora hus
08:44:58 <ludde> i dunno
08:45:09 <ludde> it seems to be stora when it's an adjective ?
08:45:19 <shapr> oh
08:45:39 <shapr> so, "I am strongly strong" would be jag är stora stor. ?
08:45:41 <ludde> jag är stor <-- stor is not an adjective now, is it?
08:45:56 <basti_> errmmm
08:46:06 <basti_> wtf? ;)
08:46:18 <ludde> basti_: ?
08:46:22 <shapr> basti_: did you save the file after you made the changes? :-)
08:46:27 <ludde> basti_: we're discussing swedish grammar
08:46:29 <basti_> yes I saved... I even uploaded
08:46:41 <basti_> the wtf thing was about my file...
08:46:44 * shapr dunno
08:46:48 <basti_> wait
08:47:13 <shapr> basti_: http://kungens.kemi.fi/~shae/src/haskell/finiteautomaton.lhs
08:47:29 <shapr> that's with wget from .fi 
08:47:56 <shapr> ludde: would the "stora stor" example be correct?
08:48:15 <ludde> shapr: i don't think it makes sense
08:48:24 <ludde> shapr: i think you use stora when it's "bestämd form"
08:48:40 <shapr> what about stora luktigt?
08:48:52 <ludde> what does that mean in english?
08:48:56 <shapr> er
08:49:11 <shapr> I thought it was "strong smelling" but now I think I've gotten the wrong word
08:49:23 <ludde> "stark lukt"
08:49:27 <basti_> now i mailed you the right file
08:49:31 <shapr> basti_: yay!
08:49:34 <shapr> basti_: thanks!
08:49:44 <ludde> shapr: stora is used when it's definite form OR plural, i think.
08:50:35 <shapr> I guess we haven't gotten to adjective + definite form yet
08:50:35 <ludde> heh, it really sucks to know stuff without knowing why it is like this
08:50:44 <basti_> *laugh*
08:50:50 <ludde> like.. you just hear what's right, but you don't know why :(
08:51:27 <shapr> that's me and monads :_)
08:51:47 <shapr> I know how to make them do stuff, but I don't know why it works.
08:51:50 <shapr> very frustrating.
08:51:57 <basti_> ;)
08:52:16 <basti_> oh i think monads are like the function of a monoid :)
08:54:28 <shapr> ok
08:54:36 <basti_> *duckandcover*
08:54:45 <basti_> can you make any sense out of my code?
08:55:02 <shapr> sure
08:55:10 <basti_> :)
08:55:13 <shapr> but I still don't understand monoids or monads :-)
08:55:26 <basti_> erm theres not much connection ;)
08:55:37 <ludde> monads are fun
08:55:43 <basti_> theyre not fun ;)
08:55:55 <ludde> why not?
08:56:02 <basti_> theyre a thing we need because we think about computers in a strange way... ;)
08:56:14 <basti_> we think "a computer does one thing after another"...
08:56:19 <basti_> and thats what a monad is about
08:56:59 <ludde> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/schedule.html
08:57:13 <ludde> that's the webpage for a haskell course i took
08:57:22 <basti_> oh :) gentoo bootstrap-compiles :)
09:00:11 <basti_> shapr btw, you could use my code for a regexp compiler... although a pretty crappy one I suppose...
09:00:12 <ludde> it describes monads
09:00:20 <basti_> where?
09:00:28 <basti_> I mean, I see a syntax description ok ;)
09:00:47 <shapr> is there a detailed description of the reasons for the three monad laws somewhere?
09:01:24 <ludde> which laws are those?
09:01:58 <shapr> commutativity, and something else
09:02:08 <Marvin--> er, they're not commutative
09:02:15 <shapr> uh?
09:02:18 <shapr> ok, nm then =)
09:02:22 <basti_> nope they arent ;)
09:02:31 <Marvin--> how could a state monad be commutative?
09:02:36 <ludde> heh
09:02:46 <Marvin--> but  return x >>= f  == f x   is one of the laws, I think?
09:03:06 <Marvin--> transitivity?
09:03:14 <basti_> commutative would be "a then b" equals "b then a"
09:03:22 <Marvin--> exactly
09:03:37 * Marvin-- digs for Wadler's paper
09:03:47 <basti_> the laws of monads dont have words in mathematics language i think
09:03:51 <dennis> associative they are
09:04:06 <basti_> yes thats right
09:04:18 <basti_> (a then b) then c equals a then (b then c)
09:04:25 <shapr> right
09:04:27 <shapr> associative
09:04:43 <dennis> and if they where not it would not be easy to use
09:04:53 <Marvin--> ah, left unit, right unit and associativity
09:05:09 <basti_> hmm
09:05:17 <basti_> if they were not they wouldnt represent IO
09:05:49 <Marvin--> state in general would be tricky :)
09:05:54 <basti_> yep *g*
09:06:01 <dennis> you can write (a>>b)>>c or a>>(b>>c) and it is the same. This means that you can for example break out a>>b or b>>c into a helpfunction
09:06:52 <dennis> or maybe i'm confused (let me think :-)
09:07:00 <Marvin--> no, you're right
09:07:05 <dennis> yes, it's correct
09:07:13 <Marvin--> not that imperative programmers worry about the associativity of ';' :)
09:07:36 <shapr> heh
09:07:38 <basti_> *g*
09:07:44 <dennis> you couldn't do it otherwise, if you had to calculate a>>b first then you can't put b into a function and compile it together with c
09:07:47 <shapr> so it's just left unit, right unit, and associative
09:08:00 <dennis> shapr: yes
09:08:03 <dennis> that's all
09:08:04 <basti_> hmm
09:08:13 <shapr> @fact monadlaws left unit, right unit, associativity
09:08:13 <lambdabot> set monadlaws to left unit, right unit, associativity
09:08:21 <Marvin--> heh
09:08:28 <basti_> *ponders*
09:08:36 <dennis> the unit looks a but funny (one one side), but it's still unit
09:08:43 <basti_> you really think? ;)
09:08:55 <Marvin--> @fact leftunit return x >>= f == f x
09:08:56 <lambdabot> set leftunit to return x >>= f == f x
09:09:08 <Marvin--> @fact rightunit m >>= return == m
09:09:08 <lambdabot> set rightunit to m >>= return == m
09:09:14 <dennis> basti_: think what?
09:09:34 <basti_> I cant see why these two laws should be what mathematicans call an unit...
09:09:49 <basti_> unit would be an element that doesnt change anything
09:10:00 <Marvin--> i.e. return?
09:10:03 <basti_> i mean, sure, return doesnt change.
09:10:07 <Marvin--> return is a unit for bind
09:10:10 <dennis> it's the unit of bind
09:10:14 <basti_> uh.
09:10:31 <shapr> hi tmoertel 
09:10:35 <tmoertel> hi, shapr 
09:10:42 <shapr> ok, next question... are the arrow laws the same?
09:10:51 <shapr> @fact delete monadlaws
09:10:51 <lambdabot> deleted monadlaws
09:10:55 <Marvin--> it's complicated a bit by the fact that the left argument to bind is a monadic value and the right argument is a function
09:10:56 <basti_> I think Ill have to learn a little more about monads... ;)
09:10:59 <shapr> @fact monadlaws leftunit, rightunit, associativity
09:11:00 <lambdabot> set monadlaws to leftunit, rightunit, associativity
09:11:15 <Marvin--> shapr: maybe "see leftunit, rightunit, associativity"?
09:11:31 <shapr> yah, good point
09:11:41 <shapr> @fact associativity
09:11:41 <lambdabot> Nothing
09:11:43 <dennis> Marvin--: maybe unit is not he best word, lets call it unit wannabes
09:11:59 <Marvin--> :)
09:12:03 <basti_> *g*
09:12:03 <shapr> @fact monadassociativity (a>>b)>>c is the same as a>>(b>>c)
09:12:03 <lambdabot> set monadassociativity to (a>>b)>>c is the same as a>>(b>>c)
09:12:18 <shapr> @fact delete monadlaws
09:12:18 <lambdabot> deleted monadlaws
09:12:29 <shapr> @fact monadlaws see leftunit, rightunit, monadassociativity
09:12:29 <lambdabot> set monadlaws to see leftunit, rightunit, monadassociativity
09:12:34 <shapr> tmoertel: how's the contest?
09:12:49 <tmoertel> shapr: shouldn't that be >>= in monadassocitivity?
09:12:56 <dennis> yes
09:12:59 <shapr> er
09:13:06 <dennis> I just used >> to make it somple
09:13:08 <dennis> simple
09:13:11 <shapr> @fact delete monadassociativity
09:13:12 <lambdabot> deleted monadassociativity
09:13:41 <shapr> @fact monadassociativity (a >>= b) >>= c is the same as a >>= (b >>= c)
09:13:42 <lambdabot> set monadassociativity to (a >>= b) >>= c is the same as a >>= (b >>= c)
09:13:45 <dennis> With a little help from google: m >>= (\x -> k x >>= h) = (m >>= k) >>= h
09:13:54 * tmoertel has been called to lunch; he'll bbl
09:13:58 <shapr> anyone know about the arrow laws?
09:14:14 <shapr> I've heard that archery is illegal in most city limits in the US :-)
09:14:22 <basti_> *g*
09:14:25 <Marvin--> whoops, starting hugs from fptools/libraries/base was a bad idea
09:14:31 <dennis> shapr: you need to change monadassociativity again
09:14:35 <shapr> Marvin--: did it explode?
09:14:39 <Marvin--> ERROR "Prelude.hs":27 - Syntax error in module definition (unexpected symbol "#")
09:14:45 <shapr> heh
09:14:49 <shapr> just a bit of smoke
09:14:54 <Marvin--> cd .. && hugs :)
09:15:26 <dennis> shapr: m >>= (\x -> k x >>= h) = (m >>= k) >>= h
09:15:43 <Marvin--> yah, you have to pay attention to the details
09:16:00 <shapr> @fact delete monadassociativity
09:16:00 <lambdabot> deleted monadassociativity
09:16:12 <shapr> @fact monadassociativity m >>= (\x -> k x >>= h) = (m >>= k) >>= h
09:16:12 <lambdabot> set monadassociativity to m >>= (\\x -> k x >>= h) = (m >>= k) >>= h
09:16:14 <dennis> it's easier with >> when you don't have any arguments to care about
09:16:15 <shapr> whew
09:19:16 <basti_> hmm
09:22:18 <dennis> Why one want associativity is clear, but what about the units? What would happen if we didn't have that?
09:22:36 <basti_> erm
09:22:45 <basti_> we wouldnt be able to end a "line" of IO? ;)
09:23:01 <basti_> hrm
09:23:03 <shapr> that's the kind of answer I'd like to hear
09:23:09 <basti_> strictly speaking no.
09:23:09 <basti_> ;)
09:23:29 <basti_> I still doubt that you can identify return with a unit just because it doesnt change anything...
09:23:31 <Marvin--> Weird Things would probably happen, but I can't pinpoint exactly what :)
09:23:50 <shapr> I know it's possible to write monads that don't follow all of the rules
09:23:59 <shapr> after which, Weird Things happen
09:24:08 <basti_> *g*
09:24:15 <basti_> probably theyre overloaded? ;)
09:28:36 <shapr> hi pesco!
09:28:39 <shapr> how ar ya?
09:28:44 <pesco> hey shapr!
09:28:59 <pesco> I'm sifting through some kind of twilight
09:29:14 <pesco> 1) My PowerBook was stolen. 2) My Kinesis just arrived.
09:29:46 <pesco> 3) is still foggy.
09:30:12 <pesco> I can't get the Kinesis to work.
09:30:55 <pesco> USB tells me connection timed out.
09:31:17 <pesco> I don't suppose you've had that?
09:32:41 <pesco> But the problem seems to be with my USB bus, my Logitech Gamepad doesn't work either (which it did before).
09:32:54 <basti_> thats normal for usb i think.
09:33:15 <basti_> its known to cause problems that are hard to find.
09:34:44 <basti_> a few weeks ago i had a friend who brought some memory stick
09:35:00 <basti_> that memory stick had a bug that made windows erase a dll when you put it into your usb port...
09:35:11 <basti_> after that you needed to reinstall that dll (as a new version)....
09:35:32 <pesco> Ugh.
09:37:27 <Janni> re
09:37:44 <basti_> re Janni
09:38:09 <pesco> shapr: But once you get to the point where there is /dev/input/kb* or something that would be it, right?
09:40:31 <shapr> your powerbook was stolen! that sucks!
09:43:51 <shapr> pesco: I had no trouble getting USB to work
09:45:00 <shapr> pesco: using linux 2.4.x ?
10:04:32 <pesco> shapr: Yes, 2.4.19
10:05:58 <pesco> re
10:06:58 <shapr> pesco: do you have usb support compiled into your kernel? using the HID driver?
10:07:11 <pesco> shapr: modules
10:08:09 <shapr> hid module?
10:08:15 <pesco> yes
10:08:33 <pesco> I have usbcore, hid, and keybdev
10:09:15 <shapr> I have usb-ohci
10:09:26 <pesco> hmm...
10:09:41 * pesco checks kernel config
10:09:55 <shapr> hmm
10:10:41 <shapr> for one thing, I have a ps/2 keyboard, only my mouse is USB
10:10:56 <pesco> oh
10:11:32 <pesco> I've used my mom's Apple USB keyboard once before, though. It should work...
10:12:18 <Janni> .oO(How could anybody be so stupid to buy USB mouse/keyboard? Fortunately nobody can see what I'm thinking...)
10:12:37 <pesco> What is wrong with a USB keyboard?
10:13:15 <shapr> I'd prefer firewire, but you take what you can get...
10:13:24 <Janni> *scared* Can you read my mind? :-o
10:13:38 <pesco> There are no firewire keyboards, for all I know.
10:27:44 <Janni> shapr: I was going to the Classic Contoured (Dvorak/Qwerty) but then they told me it would cost 30$ extra if I transfer the money from my bank account and I don't have a credit card...
10:28:11 <Janni> ... I didn't... (<- I guess this was missing)
10:28:14 <shapr> that sucks :-(
10:28:37 <shapr> I got the .se layout since I'm giving this one to Bea when mine is fixed.
10:29:32 <Janni> But I'll buy one. I'll ask around if anybody I know has a credit card and then let him buy it for me
10:30:35 <Janni> I even have to pay about 5 Euros (IIRC) to transfer money from Germany to the USA...
10:31:33 * Janni realises that he hasn't really looked for resellers in Germany...
10:33:36 <shapr> afaik, there's only one EU reseller, in .nl
10:35:20 <Janni> According to the Kinesis HP, yes. But he only sells the cheapest one.
10:35:29 <shapr> oh
10:35:31 <shapr> that sucks.
10:36:27 <funktor> hmm, this is maybe stupid, but is there an elegant way to say
10:36:36 <funktor> head xs == "+"
10:36:42 <funktor> for the case where xs is []?
10:37:07 <shapr> what are the other patterns?
10:37:19 <shapr> you could use a helper function to 'postprocess' it
10:37:45 <Marvin--> funktor: err... you mean you want  head xs == "+"  to evaluate to False if xs is []?
10:38:10 <funktor> Marvin--: exactly
10:38:23 <Marvin--> funktor: not (null xs) && head xs == "+"  is one way...
10:38:47 <shapr> could you use the ~ trick?
10:38:53 <Marvin--> I guess
10:39:00 <funktor> ~ trick?
10:39:08 <shapr> the irrefutable pattern match marker
10:39:30 <shapr> func ~([]) == "+"  -- ?
10:39:38 <shapr> er, I think that will explode
10:39:46 <Marvin--> or [ x == '+' | (x:xs) <- [xs] ]  is another way *cough*
10:39:54 <Marvin--> er
10:39:56 <Marvin--> yes
10:40:09 <Marvin--> er, (x:_) <- [xs]  I mean
10:40:55 <funktor> what does ~ exactly do?
10:41:11 <Janni> Yay! The european reseller now sells the other contoured variants too. :)
10:41:21 <Marvin--> shapr: I don't see the point of saying  foo xs@(~(y:ys)) = not (null xs) && y == "+"  when you can simply say  not (null xs) && head xs == "+"
10:41:39 <Marvin--> funktor: lazy pattern matching
10:41:45 <Janni> Err, no :(
10:41:50 <shapr> Janni: eh?
10:42:01 <Marvin--> funktor: foo (~(x:xs)) = ...   the argument isn't actually evaluated until x or xs are used
10:42:14 <Janni> Just mixed up two sites...
10:42:23 <Janni> (if you know what I mean)
10:44:20 <Marvin--> shapr: do you know if there are parser generators for java?
10:44:29 <Darius> Antlr
10:44:36 <Darius> Javacc
10:44:57 <shapr> Marvin--: there are several.
10:45:05 <shapr> run away while you still can.
10:45:10 <Marvin--> I was just curious
10:45:23 <Marvin--> I was trying to pull off some sort of "enterprise" joke
10:45:37 <shapr> I used SableCC when I was trying to make cryptix work.
10:45:47 <Marvin--> "enterprise text analyzing tools"
10:45:55 <shapr> paper shredder_
10:45:56 <shapr> ?
10:45:57 <Marvin--> (aka regexp)
10:46:37 <shapr> java finally has regexp support now
10:46:47 <shapr> though I've heard it's like racing snails.
10:46:47 <Marvin--> I'm just trying to be funny :)
10:47:32 <shapr> @fact java
10:47:32 <lambdabot> Java is the COBOL of the future --Shae Erisson
10:47:37 <Darius> They need generics... so they can start work on the other features it lacks and is too inflexible to capture
10:48:11 <shapr> basically, let's market a language that sucks, then add more features so it doesn't suck.
10:48:22 <shapr> but retain backwards suckability.
10:48:45 <Darius> if it even did that...
10:49:02 <shapr> the more I learn about programming, the less I like Java.
10:49:07 <Marvin--> in the language semantics course we worked a bit with a subset of the dot-net byte code... the type annotations were pretty scary
10:54:54 <esap> I think the biggest problem with Java is not what is in the language (even though that is scary as well) but what is not.
10:55:03 <shapr> how so?
10:56:00 <shapr> I always find it amusing to show heavy duty Java programmers Python or Haskell code.
10:56:08 <shapr> they usually say "it's so *short*"
10:56:31 <esap> I mean, Java has quite restricted facilities for expressing things. You can only do OO-style design but even with that, the most important things are missing.
10:56:58 <whee> I really don't understand OO in java
10:56:58 <whee> spoiled by smalltalk-esque languages :|
10:57:08 <shapr> whee: there isn't much ;-)
10:57:26 <shapr> whee: hey, when and how can I rope you into doing some Haskell? ;-)
10:57:54 <whee> certainly not this week
10:58:04 <shapr> ok, I'll bug you again next week.
10:59:07 <whee> next week may or may not work as well
10:59:30 <whee> heh
10:59:52 * shapr gets out the lasso
10:59:52 <whee> it depends on how this pain in the ass java SE project goes between now and then
11:00:01 <shapr> whatcha writing?
11:00:28 <whee> bowling simulator
11:01:00 <shapr> pinned down the details yet?
11:01:03 * shapr makes horrible puns
11:01:18 <shapr> going balled from stress?
11:05:41 <Janni> shapr: Are you using the wrist pads from Kinesis?
11:05:55 <shapr> nope
11:06:12 <Janni> S.th. else or just plain plastic?
11:06:17 <shapr> just plain plastic
11:06:30 <shapr> I might try them soon
11:06:32 <Janni> OK
11:07:08 <shapr> ime, they're good when my hands are sweaty, but it doesn't get that warm very often in this part of the world.
11:22:53 * shapr codes happily
11:23:15 <shapr> ok, let's see if this improves my Bayes' stats
11:24:46 <Igloo> Is this the spam classifier? What've you done to it?
11:26:36 <shapr> I've just added filtering for items that occur less than five times, and only using the fifteen most significant words, rather than the top and bottom fifteen
11:27:20 <shapr> after that I'll see if I can figure out fallback checking
11:27:34 * shapr retrains
11:29:17 <shapr> ram usage is a real problem
11:29:34 <Darius> profile
11:30:05 <shapr> once it works ;-)
11:30:25 <shapr> it's not smart enough to strip binary attachments atm :-(
11:30:35 <shapr> afaik, there's not a MIME parser in Haskell.
11:39:39 <shapr> y0 y0
11:40:55 <shapr> hm, I bet fallback checking will help tremendously
11:40:56 <basti_> im back
11:41:05 <shapr> hello again basti_ 
11:41:09 <Vincenz> hiya
11:41:11 <basti_> hi shapr
11:41:57 <basti_> hi Vincenz
11:42:02 <Vincenz> hello basti_
11:43:17 <basti_> im playing around with vt100 features ;)
11:43:35 <basti_> did you know vt100 supports double width and double size chars? ;)
11:43:40 <shapr> no, I didn't
11:43:46 <basti_> now you do *g*
11:43:47 <shapr> how does an xterm deal with that?
11:43:51 <basti_> pretty fancy.
11:43:52 <basti_> I dont know ;)
11:43:56 <basti_> but its in the standard...
11:44:17 <basti_> try "esc # 3" (something)
11:58:06 <apocalexiz> hi
11:58:08 <shapr> y0
11:58:21 <shapr> cute nickname
11:58:32 <shapr> are you learning Haskell?
11:58:57 <apocalexiz> me?
11:59:07 <shapr> yes, you.
11:59:23 <apocalexiz> ya i'm very new with haskell
11:59:58 <Riastradh> Do you like it so far?
12:00:08 <apocalexiz> i try to understand the functional programming...cause i need it for my study
12:00:38 <Riastradh> Functional programming is easy.  You have functions.  You can make them and call them.  That's it.
12:01:07 <apocalexiz> ya i know ;) but for me its very strange
12:01:22 <apocalexiz> i only know imperativ programming
12:01:24 <Riastradh> Imperative programming is evil.  Come to the light side and forget anything you knew about the dark side.
12:02:42 <shapr> you can escape Darth Kernighan!
12:02:47 <apocalexiz> ;)
12:02:47 <shapr> join the rebellion!
12:03:12 <Riastradh> Do you have any questions about it?
12:03:31 <apocalexiz> only about my little task
12:04:22 <apocalexiz> it quite hard for me to let the imperative paradigm behind me
12:04:37 <Riastradh> Catbert's 'Secret Untraining Method' might help.
12:04:52 <Riastradh> But seriously, what's your question?
12:05:07 <apocalexiz> oke but dont laugh ;)
12:05:13 <Smerdyakov> Riastradh, you should know that Catbert isn't real....
12:05:55 <apocalexiz> i try to programm a little dec to bin transformator 
12:06:02 <apocalexiz> the thougt is easy...
12:06:10 <apocalexiz> but the haskell implementation...
12:06:13 <Riastradh> 'dec' to 'bin?'
12:06:30 <apocalexiz> binary values
12:06:37 <apocalexiz> i tried something like this
12:06:39 <apocalexiz> dec2bin :: Int -> [Int]
12:06:39 <apocalexiz> eList = []
12:06:39 <apocalexiz> dec2bin n = n`mod` 2:eList where n = dec2bin (n`div`2)
12:07:23 <Riastradh> Give me an example of using it.
12:07:36 <Riastradh> Rather, give me an example of what using it -should- do, not what it actually does.
12:07:50 <apocalexiz> u put a 3 in and get the binary value out
12:07:56 <apocalexiz> e.g.
12:08:32 <esap> apocalexiz: '=' does not stand for assignment. "where n = ..." will define a new name 'n', no assignment.
12:08:51 <Riastradh> dec2bin 3  -- returns: [1,1], right?
12:08:54 <apocalexiz> hmm...can i do multiple statemens ?
12:08:56 <apocalexiz> ja ria
12:09:12 <apocalexiz> i meant yes
12:09:47 <esap> apocalexiz: you can use 'do' notation. For this example, you should not do that though. If you have 'pure functions' that do not perform I/O, you should not need to use assignment or do notation.
12:10:29 <apocalexiz> hmm..so where is the way between the trees
12:10:30 <apocalexiz> ;)
12:10:48 <Riastradh> You get each bit sequentially.
12:11:19 <apocalexiz> ya i will do this recursive...that seems to be the only way in haskell 
12:11:24 <Riastradh> dec2bin a will return the first bit, consed onto 'dec2bin (a, shifted one bit)'.
12:12:19 <apocalexiz> hmm...and how do i shift the bits?
12:13:56 <Riastradh> RTFMing will help.
12:14:02 <Riastradh> (I'm afraid I don't know)
12:14:09 <apocalexiz> i tried to read the manual ;)
12:14:11 <Riastradh> Someone here probably knows, though.
12:14:32 <Riastradh> Look for a function called 'ashl' or 'ashr' or 'arithmetic-something' or anything of that sort.
12:15:37 <Darius> I don't think bitshifting is supported in standard haskell, just div by 2,
12:15:47 <apocalexiz> ya but if i div by 2
12:15:54 <apocalexiz> than i have to look with mod
12:16:13 <apocalexiz> and the solution from this is a "bit"
12:16:16 <esap> nhc seems to support "Bit" library. Not standard.
12:16:29 <apocalexiz> but i will try it for my own ;)
12:16:31 <esap> http://www.cs.york.ac.uk/fp/nhc13/libs/Bit.html
12:16:35 <apocalexiz> it cant be very hard
12:17:29 <Darius> GHC also has a Bits (I think it's plural) library
12:18:33 * esap has never needed bit shifting in Haskell.
12:18:37 <apocalexiz> hmm...is there a way to group statements 
12:19:02 <apocalexiz> esap i dont need it too ;) but i have to do a little task...so for me its a must 
12:19:41 <esap> apocalexiz: yes. do notation and the Monad interface (>> and >>= operations). Or you can use function composition ('.') if you do not want to do I/O.
12:20:22 <apocalexiz> and with this i got the binary value into a list?
12:21:18 <esap> apocalexiz: explain more what you want.
12:21:27 <apocalexiz> ok
12:21:37 <Riastradh> esap - dec2bin 3 -- returns: [1,1]
12:21:42 <apocalexiz> correct
12:21:53 <Riastradh> He wants to get a list of all the bits in an integer.
12:21:54 <apocalexiz> and i would like to do that recursively
12:22:14 <Riastradh> OK, first, dec2bin 0 will return [], or nil.
12:22:30 <Riastradh> So, show how you would write that which I just described.
12:22:40 <apocalexiz> oke dec2bin n | n == 0 = [] right?
12:22:53 <Riastradh> Indeed.
12:23:11 <Smerdyakov> Do you know a shorter way to write that, apocalexiz?
12:23:44 <apocalexiz> hmm... dec2bin 0 = [] something like this?
12:23:47 <Smerdyakov> Yes
12:23:54 <apocalexiz> patternmatching ya?
12:24:00 <Smerdyakov> Yes
12:24:16 <Riastradh> Given a function 'firstBit' (which we'll define later), which takes an integer and returns the first bit in it, and a function 'restBits' (which we'll also define later), what would you do to return a pair of bits, the first of which being 'firstBit n'?
12:25:20 <Riastradh> Oh, and the tail of which being a recursive call to 'dec2bin'.
12:25:45 <apocalexiz> ya thats my main problem...i dont get the correct idea to do the recursive call
12:26:17 <apocalexiz> to return a bit i tried to do something like this dec2bin n = n`mod`2
12:26:34 <apocalexiz> this would give mit the "first" bit i guessed
12:27:09 <Riastradh> No, no, no, ignore how you implement 'firstBit' and 'restBits' for now.
12:27:14 <apocalexiz> oke
12:27:35 <Riastradh> First, how do you make a pair whose head is 1 and whose tail is nil?
12:27:57 <apocalexiz> hmm... foo (x:_) ?
12:28:16 <Riastradh> No, no, show me how to make the list [1] with consing instead of the list syntax?
12:28:37 <shapr> I wish I could remember stuff longer...
12:28:47 * shapr figures out how to use lazy lists for the zillionth time
12:29:04 <shapr> fib = 1 : 1 : (zipWith (+) (fib) (tail fib))
12:29:09 <shapr> that looks right, doesn't it?
12:29:23 <apocalexiz> ?
12:29:39 <esap> shapr: yes, it looks.
12:29:44 <shapr> esap: thanks
12:29:52 <Riastradh> apocalexiz - Instead of writing [1], write the same list, but using the : operator (cons).
12:30:20 <apocalexiz> ah u mean something like 1:anylist
12:30:32 <Riastradh> OK, that works.
12:30:43 <Smerdyakov> Except that anylist is something very specific here, apocalexiz.
12:30:53 <apocalexiz> ya but what ;)
12:30:54 <Riastradh> Now, instead of using 1, we're going to use the first bit of n, the argument to 'dec2bin'.
12:31:07 <Riastradh> Smerdyakov - It doesn't really matter for the sake of example now.
12:31:53 <apocalexiz> hmm..
12:32:12 <Smerdyakov> apocalexiz, the empty list: nil
12:32:21 <apocalexiz> what does nil mean?
12:32:26 <apocalexiz> really empty?
12:32:29 <Riastradh> Nil is the list terminator.
12:32:30 <Smerdyakov> It is the name of the empty list.
12:32:34 <Smerdyakov> Oh, I meant Nil.
12:32:39 <Smerdyakov> nil in SML ;-)
12:33:41 <esap> and I guess it's [] and not Nil anyhow.
12:33:55 <apocalexiz> Riastradh can u explain this " Now, instead of using 1, we're going to use the first bit of n, the argument to 'dec2bin'." in another way ;)
12:33:59 <Smerdyakov> I think [] is a shorthand for Nil..?
12:34:09 <Smerdyakov> Guess not
12:34:14 <Riastradh> Replace 1 with applying 'firstBit' to 'n'.
12:34:29 <Smerdyakov> esap, so [] is an actual constructor name?
12:34:42 <Riastradh> Smerdyakov - It is.
12:34:45 <apocalexiz> so i only have to change the 1 against a function?
12:34:47 <Smerdyakov> WhOoOoOa
12:34:51 <Riastradh> Well, not a name.
12:35:01 <Riastradh> apocalexiz - 'against a function?'
12:35:45 <apocalexiz> hmm...the argument is not a one, its a returnvalue from a function
12:36:08 <Riastradh> In the expression:  1 : []  replace the '1' with an application of 'firstBit' to 'n'.
12:36:14 <Riastradh> You know what 'apply to' means, right?
12:36:53 * Smerdyakov cries about how horrible it is to teach people imperative programming before functional.
12:36:53 <apocalexiz> hmm.. u mean something like ive done before something like n`mod`2
12:37:23 <apocalexiz> ja smerdyakov iam getting really angry about that
12:37:27 <Riastradh> OK, tell me what 'apply to' means, and give me an example of applying 'foo' to 'bar'.
12:38:08 <apocalexiz> applying foo to bar... hmm... foo+bar
12:38:25 <Riastradh> No, that's applying the function (+) to foo, and applying the result to bar.
12:39:03 <apocalexiz> so wich "applying" do i need?
12:39:05 <Smerdyakov> apocalexiz, what text source are you using for learning Haskell?
12:39:11 <apocalexiz> nothing?
12:39:19 <apocalexiz> Smerdyakov
12:39:25 <Smerdyakov> apocalexiz, uh huh. That won't work. Find a book and read it.
12:39:37 <apocalexiz> ya but the books r very expensive
12:39:39 <Smerdyakov> apocalexiz, check http://www.haskell.org/learning.html
12:39:43 <Smerdyakov> apocalexiz, I meant online books.
12:39:44 <apocalexiz> i checked it..
12:39:45 <Riastradh> Reading about the Lambda-Calculus might help too.
12:39:53 <Riastradh> The 'Gentle Introduction' was useful to me.
12:40:16 <apocalexiz> hmm...but there is nothing related to my problem in the "gentle introduction"
12:40:18 <Smerdyakov> Try http://www.cs.ou.edu/~rlpage/fpclassCurrent/textbook/haskell.shtml
12:40:36 <Smerdyakov> apocalexiz, there was PLENTY related to your "problem." You just didn't read it thoroughly.
12:40:53 <Smerdyakov> apocalexiz, but the link I gave will have plenty of exercises at every step to help you understand things in the proper order instead of guessing out of nowhere.
12:41:00 <Riastradh> The 'Gentle Introduction' is a general-purpose introduction to Haskell.
12:41:29 <apocalexiz> hmm...
12:41:30 <Riastradh> Since you need to learn Haskell to solve your problem, reading it will help.
12:41:43 <apocalexiz> Riastradh in wich way would you explain the applying to?
12:41:55 <Riastradh> Would the term 'call' work better?
12:42:17 <Riastradh> i.e., to 'call' the function strcat in C, for example.
12:42:19 <Smerdyakov> He would, I hope, explain it in the terms of: This concept is so basic that the fact that you don't know it shows you have spent ZERO time trying to understand any text teaching Haskell.
12:42:37 <apocalexiz> i would write strcat(arguments)
12:42:50 <Riastradh> Yes, what Smerdyakov said.
12:42:59 <n3d> i learn haskell trought tutorials since 2-3 months, and i find it really great, 
12:43:17 <apocalexiz> ;) the problem i dont got the time
12:43:23 <n3d> but i only use hugs, and i dunno how to compile it,
12:43:27 <Smerdyakov> apocalexiz, too bad. Then you "dont got" the ability to learn Haskell.
12:43:31 <n3d> i installed ghs
12:43:35 <n3d> i installed ghc
12:43:52 <Smerdyakov> apocalexiz, is this for a course?
12:43:56 <n3d> but dunno how to deal with IO() stuff
12:43:56 <apocalexiz> Smerdyakov but i would be very happy if i solve my little prob today ;)
12:44:06 <n3d> where can i find any info about it ?
12:44:22 <basti_> n3d try to search about "Monads"
12:44:24 <apocalexiz> Smerdyakov no not really 
12:44:42 <Riastradh> n3d - There's a tutorial on the 'books about Haskell' page or something on haskell.org called 'what the hell are monads?' or something.  I found it very useful.
12:44:43 <n3d> basti_: thanks
12:44:50 <Smerdyakov> apocalexiz, then why are you trying to learn it?
12:45:10 * n3d gone to seewhat the hell are
12:45:15 <n3d> monads  :)
12:45:31 <apocalexiz> its for later use with algebraic structures
12:45:56 <apocalexiz> so i need the hmm...damn i lose the word ;)
12:46:12 <apocalexiz> the basic
12:46:29 <apocalexiz> i need to learn the basics 
12:46:33 <Smerdyakov> apocalexiz, learning Haskell is not like learning shell scripting to make some quick toys.
12:46:46 <shapr> it's a lot more fun than that :-)
12:46:50 <Smerdyakov> apocalexiz, it requires the same kind of dedication and time it will take you to learn about algebraic structures, or any university level math class.
12:46:58 <shapr> yah, I agree with that.
12:47:08 <Smerdyakov> apocalexiz, you should keep that in mind if you are considering learning it. We think it's well worth your while, but it's not a trivial investment.
12:47:09 <apocalexiz> but i found it easier to learn math than haskell ;)
12:47:21 <Riastradh> How much time have you devoted to learning maths?
12:47:26 <shapr> Of course, once you've learned it, you will be a far far better programmer than before.
12:47:39 <Smerdyakov> apocalexiz, and what math classes have you taken? Probably just math classes for engineers....
12:47:48 <Riastradh> More than five years?
12:48:49 * basti_ has taken math classes up to things that I cant name in english
12:48:51 <basti_> ;)
12:49:03 <apocalexiz> ;)
12:49:23 <Riastradh> Now, how much time have you spent devoted to learning Haskell?
12:49:26 <Riastradh> About ten minutes?
12:49:27 <Smerdyakov> apocalexiz, care to answer my question?
12:49:29 <apocalexiz> hmm...
12:49:31 <basti_> I know rings have the same name in english.. but I dont know whats the translation of Schiefkörper ;)
12:49:31 <apocalexiz> ya ;)
12:49:45 <apocalexiz> naja basti ich auch nich ;)
12:49:56 <basti_> Riastradh: hmm, like maybe a few months now... but ive known a few other languages before...
12:49:58 <basti_> apocalexiz ;)
12:50:08 <Riastradh> basti_ - Er, I was talking to apocalexiz.
12:50:10 <Smerdyakov> apocalexiz, OK, you appear to be ignoring my question to avoid incriminating yourself.
12:50:11 <apocalexiz> Smerdyakov its for IT ;)
12:50:15 <basti_> oic
12:50:16 <basti_> ;)
12:50:22 <apocalexiz> no i dont ignore you
12:50:29 <apocalexiz> but sometimes i need a little longer
12:50:32 <Smerdyakov> apocalexiz, then what math classes have you taken that are sooo much easier than learning Haskell?
12:50:46 <apocalexiz> what do you mean with math classes?
12:51:06 <Smerdyakov> apocalexiz, courses... modules... whatever you call them! Like "Differentil Equations" is a math class.
12:51:10 <Smerdyakov> Differential...
12:51:44 <apocalexiz> hmm...there are different levels in the modules
12:51:44 <basti_> Differential Equations are a really beautiful thing btw :)
12:51:50 <Smerdyakov> *sigh*
12:51:58 <Smerdyakov> What TOPICS have you covered in the modules you've taken?
12:52:07 <apocalexiz> right now? not much ;)
12:52:24 <Smerdyakov> OK. Then saying that "math is easy, Haskell is hard" seems a little dishonest for you to say, don't you think?
12:52:25 <apocalexiz> iam in the second half term  
12:52:58 <Smerdyakov> If you are studying "Information Technology," then it may very well be that learning Haskell is "too hard for you," given the amount of effort you want to spend.
12:53:02 <apocalexiz> oke think haskell is easy but I programmed a lot of time in C and some assembler
12:53:24 <apocalexiz> so that my thougts going another way like haskell 
12:53:37 <Darius> What's a lot of time?
12:53:42 <Smerdyakov> If you are already planning to take real, thought-requiring university math classes, then you will develop the skills to learn Haskell easily that way.
12:53:43 <apocalexiz> 3-4 years
12:54:10 <apocalexiz> give me a well written tutorial and iam willing to learn
12:54:22 <Smerdyakov> There are many linked from the haskell.org site.
12:54:24 <Riastradh> The 'Gentle Introduction' is a good tutorial.
12:54:41 <Smerdyakov> But most will assume a certain mathematical maturity... which you may not have.
12:54:50 <Smerdyakov> And, quite honestly, not having it may mean you can't learn Haskell. Sorry.
12:55:21 <apocalexiz> but where is the math for an easy decimal to binary converter?
12:55:25 <Darius> The 'Gentle Introduction' is more for those coming from another functional language, though still pretty good
12:55:27 <apocalexiz> there u need no math
12:55:45 <Smerdyakov> That's so trivial that it would be ridiculous to need special coverage in a tutorial for you to know how to do it.
12:55:49 <Riastradh> Most likely you won't understand your 'Algebraic Structures' class, you will need to know mathematical stuff, too.
12:55:56 <Riastradh> Er.
12:56:05 <apocalexiz> i know the algorithm but i dont know how to implement in haskell
12:56:17 <Smerdyakov> You actually don't know a _functional_ algorithm.
12:56:18 <Riastradh> Most likely you won't understand your 'Algebraic Structures' class either, if you aren't very adept with maths.
12:56:22 <apocalexiz> thats it
12:56:28 <Smerdyakov> You don't know a _mathematical_ characterization of the solution, and that's the problem.
12:56:41 <esap> Actually, that trivial problem requires far more math than anything else. (You need to understand bits! Those are quite complicated from math point of view.) 
12:56:46 <apocalexiz> @ Smerdyakov
12:56:46 <lambdabot> Sorry, I don't know the command "", try "lambdabot: @listcommands"
12:59:33 <apocalexiz> dec2bin n = dec2bin(n`div`2) ++ [n`mod`2]
12:59:41 <apocalexiz> better?
12:59:51 <apocalexiz> i got the solution for my own :/
13:00:06 <Riastradh> No, because we still know you haven't read any substantial material on Haskell.
13:00:12 <Smerdyakov> I guess you're the man, now!
13:00:20 <apocalexiz> Smerdyakov no iam not the man
13:23:44 <apocalexiz> ok folks i'll come back if i really ready for haskell, bye there
13:26:42 <Riastradh> @fortune
13:26:43 <lambdabot> P.S. Perl's master plan (or what passes for one) is to take over the
13:26:43 <lambdabot> world like English did.  Er, *as* English did...
13:26:43 <lambdabot>              -- Larry Wall in <199705201832.LAA28393@wall.org>
13:39:34 <Darius> @eval B toList reverse (unfold (\s.if s == 0 then Nothing else Just (Pair (mod s 2) (s/2))) 10)
13:39:35 <lambdabot> [1, 0, 1, 0]
13:40:17 <funktor> @type unfold
13:40:28 <Darius> @type unfoldr
13:40:58 <Riastradh> Isn't @type only for Haskell, not the LC interpreter?
13:41:04 <Riastradh> @get-definition unfold
13:41:05 <lambdabot>  \f s.maybe Nil (\p.Cons (fst p) (unfold f (snd p))) (f s)
13:41:15 <Darius> Unfold really is a second class citizen to fold; relegated to List
13:41:34 <Darius> yes, and pesco needs to add @type-from
13:41:42 <Darius> ... or has he?
13:41:54 <Darius> @listcommands type
13:41:54 <lambdabot> Module type provides the following commands: ["type"]
13:41:57 <Riastradh> No.
13:43:10 <Darius> if someone is bored, reverse is horribly implemented (I was lazy)
13:43:53 <Riastradh> reverse can just be implemented as 'fold cons Nil', can't it?
13:44:19 <Darius> that would just copy a list
13:44:30 <Riastradh> Er.
13:44:48 <Darius> @get-definition reverse
13:44:48 <lambdabot>  fold (\x r.append r (Cons x Nil)) Nil
13:45:08 <Riastradh> No, it reverses a list.
13:45:17 <Riastradh> @define folding-reverse fold cons Nil
13:45:17 <lambdabot> folding-reverse defined
13:45:29 <Riastradh> Is there a list syntax in the interpreter?
13:45:37 <Riastradh> Or do I have to use Cons and Nil?
13:45:38 <Darius> @define folding-reverse Cons Nil
13:45:38 <lambdabot> folding-reverse defined
13:45:47 <Riastradh> @define folding-reverse fold Cons Nil
13:45:48 <lambdabot> folding-reverse defined
13:46:04 <Riastradh> @eval folding-reverse (Cons 1 (Cons 2 (Cons 3 Nil)))
13:46:05 <lambdabot> unbound variable: folding
13:46:20 <Darius> There is but it's strict (though that wouldn't be a problem here)
13:46:27 <Riastradh> @define freverse fold Cons NIl
13:46:27 <lambdabot> freverse defined
13:46:29 <Riastradh> @define freverse fold Cons Nil
13:46:29 <lambdabot> freverse defined
13:46:38 <Riastradh> @eval freverse (Cons 1 (Cons 2 (Cons 3 Nil)))
13:46:38 <lambdabot> <<EM Dynamic -> EM Dynamic>>
13:46:49 <Riastradh> @definitions
13:46:49 <lambdabot> ["B","Branch","C","Cons","False","I","Just","K","K2","Leaf","Left","Nil","Nothing","Pair","Right","S","Succ","True","X","Y","Zero","a","ana","apo","append","car","cata","cdr","chAnd","chFalse","chIf","chNot","chOr","chTrue","const","drop","either","flip","fold","foldNat","folding-reverse","freverse","fst","id","inc","iterate","lcFalse","lcIf","lcTrue","list","lookupTree","map","maybe","mod","modifyTree","nat","not","nullL","pair","para","p
13:46:58 <Riastradh> @eval car (Cons 1 2)
13:46:59 <lambdabot> 1
13:47:01 <Darius> @eval toList (freverse (Cons 1 (Cons 2 (Cons 3 Nil))))
13:47:01 <lambdabot> [1, 2, 3]
13:47:18 <Darius> @get-definition toList
13:47:19 <lambdabot>  cata (\x y.x:y) []
13:49:09 <Darius> @define fromList Y (\f l.if null l then Nil else Cons (head l) (f (tail l)))
13:49:10 <lambdabot> fromList defined
13:49:31 <Darius> @eval B toList fromList [1, 2, 3]
13:49:31 <lambdabot> [1, 2, 3]
13:49:57 <Darius> doh
13:50:11 <Darius> @define fromList \l.if null l then Nil else Cons (head l) (fromList (tail l)))
13:50:12 <lambdabot> (line 1, column 62):
13:50:12 <lambdabot> unexpected ")"
13:50:12 <lambdabot> expecting var, num, bool, "(", operator, simple term or end of input
13:50:13 <Darius> @eval B toList fromList [1, 2, 3]
13:50:13 <lambdabot> [1, 2, 3]
13:50:20 <Darius> @define fromList \l.if null l then Nil else Cons (head l) (fromList (tail l))
13:50:20 <lambdabot> fromList defined
13:50:21 <Darius> @eval B toList fromList [1, 2, 3]
13:50:22 <lambdabot> [1, 2, 3]
13:51:22 <Darius> @eval B toList freverse (fromList "aoeu")
13:51:22 <lambdabot> aoeu
13:51:29 <Darius> @eval B toList reverse (fromList "aoeu")
13:51:30 <lambdabot> ueoa
13:51:57 <Riastradh> @define foldl \kons knil l. if l == Nil then knil else foldl kons (kons (car l) knil) (cdr l)
13:51:58 <lambdabot> foldl defined
13:52:13 <Riastradh> @eval foldl Cons Nil (fromList [1,2,3,4])
13:52:13 <lambdabot> type error
13:52:27 <Darius> l only works for ints (no type classes)
13:52:32 <Darius> use nullL
13:52:32 <Riastradh> @eval car (foldl Cons Nil (Cons 1 (Cons 2 (Cons 3 Nil))))
13:52:33 <lambdabot> type error
13:52:54 <Riastradh> Oh.
13:53:04 <Riastradh> @define foldl \kons knil l. if l == nullL then knil else foldl kons (kons (car l) knil) (cdr l)
13:53:04 <lambdabot> foldl defined
13:53:07 <Riastradh> Like that?
13:53:24 <Darius> no 
13:53:28 <Darius> @eval nullL Nil
13:53:28 <lambdabot> True
13:53:39 <Riastradh> @define foldl \kons knil l. if nullL l then knil else foldl kons (kons (car l) knil) (cdr l)
13:53:39 <lambdabot> foldl defined
13:53:42 <Riastradh> That, then?
13:54:06 <Riastradh> @eval foldl Cons Nil (fromList [1,2,3,4])
13:54:07 <lambdabot> <<EM Dynamic -> EM Dynamic>>
13:54:14 <Riastradh> @eval toList (foldl Cons Nil (fromList [1,2,3,4]))
13:54:14 <lambdabot> [4, 3, 2, 1]
13:54:24 <Riastradh> Ah, so 'fold' -is- 'foldr.'
13:54:35 <pesco> hey
13:54:38 <Darius> that's the natural one for a Cons list
13:54:52 <Riastradh> Er, how?
13:55:43 <Darius> Cons list are right associative, further folds replace constructors with the functions you provide
13:55:55 <Darius> so fold Cons Nil should be the identity
13:56:03 <Darius> and so it is
13:56:50 <Darius> (on lists obviously)
13:57:23 <Riastradh> @define foldr fold
13:57:23 <lambdabot> foldr defined
13:57:39 <Darius> @type-from List unfoldr
13:57:39 <lambdabot> Sorry, I don't know the command "type-from", try "lambdabot: @listcommands"
13:57:50 <Riastradh> @type List.unfoldr
13:58:00 <Riastradh> Blah.
14:03:54 <funktor> ?  f m = maybe Nothing f m
14:04:05 <funktor> does such a function exist in the prelude?
14:04:41 <Darius> just use maybe Nothing
14:04:50 <Riastradh> @eval maybe Nothing
14:04:51 <lambdabot> <<EM Dynamic -> EM Dynamic>>
14:05:21 <Darius> @define a maybe Nothing
14:05:22 <lambdabot> a defined
14:06:51 <Darius> @eval maybe 0 (C K) (a (\x.Just (x*3)) (Just 5))
14:06:51 <lambdabot> <<EM Dynamic -> EM Dynamic>>
14:07:30 <Darius> @eval maybe 0 (flip const) (a (\x.Just (x*3)) (Just 5))
14:07:30 <lambdabot> <<EM Dynamic -> EM Dynamic>>
14:08:25 <Darius> @eval maybe 0 id (a (\x.Just (x*3)) (Just 5))
14:08:25 <lambdabot> 15
14:08:44 <Darius> @eval maybe 0 id (a (\x.Just (x*3)) (Nothing)
14:08:44 <lambdabot> (line 1, column 40):
14:08:44 <lambdabot> unexpected end of input
14:08:44 <lambdabot> expecting var, num, bool, "(", operator, simple term or ")"
14:08:49 <Darius> @eval maybe 0 id (a (\x.Just (x*3)) Nothing
14:08:50 <lambdabot> (line 1, column 38):
14:08:50 <lambdabot> unexpected end of input
14:08:50 <lambdabot> expecting var, num, bool, "(", operator, simple term or ")"
14:09:03 <Riastradh> @eval maybe 0 id (a (\x.Just (x * 3))) Nothing
14:09:04 <lambdabot> type error
14:09:08 <Riastradh> @eval maybe 0 id (a (\x.Just (x * 3)) Nothing)
14:09:08 <lambdabot> 0
14:09:35 <Darius> @eval C K 1 2
14:09:36 <lambdabot> 2
14:09:39 <Darius> @eval K I 1 2
14:09:40 <lambdabot> 2
14:11:58 <funktor> anyway, Maybe(..) is really nice
14:12:45 <shapr> I've heard that Maybe can be used in a monad
14:12:56 <shapr> how does that work?
14:13:05 <shapr> is it implicit failure handling?
14:13:23 <Darius> It IS a monad
14:13:28 <shapr> yah
14:13:32 <funktor> Maybe m => Monad m
14:13:42 <shapr> but what can I use that for?
14:13:50 <funktor> like Either
14:13:53 <Darius> instance Monad (Maybe a)
14:14:01 <funktor> I think of Maybe as a poor-mans exception handling...
14:14:15 <shapr> if I have a bunch of stacked <- calls, and one of them in the middle is a Nothing, does that mean none of the rest get called?
14:14:36 <funktor> no
14:14:46 <funktor> I have code like:
14:14:56 <Darius> it means everything 'after' (you'd be using do-notation)
14:15:00 <Igloo> The total value will be Nothing
14:15:21 <funktor> maybe Nothing (\ ... -> ...) $ maybe Nothing (\ ... -> ...) $ ...
14:15:38 <Igloo> Whether the rest "get called" or not is irrelevant - with referential transparency you can't tell
14:16:10 <Darius> use the maybe monad funktor
14:16:29 <funktor> how?
14:16:40 <pesco> shapr: Oooh, this keyboard is so cool!
14:16:44 <shapr> call me dense, but can I see some demo code? 
14:16:46 <shapr> pesco: YAY!
14:17:25 <Riastradh> pesco - Is it cool enough to write a 'type-from' command on it?
14:17:26 <Darius> maybe Nothing (\a -> m1) $ maybe Nothing (\a -> m2) --> do a <- m1; b <- m2
14:17:45 <Darius> (well with a return at the end when you have the result)
14:17:47 <pesco> Especially how typing the numbers suddenly works!
14:17:47 <Igloo> You might want to do something like   do val_left <- maybe_left_val; val_right <- maybe_right_val; return (val_left, val_right)
14:18:04 * Riastradh barfs at those multitudes of underscores.
14:18:11 <Igloo> Which would return Nothing if one or both values are Nothing or Just (left, right) otherwise
14:18:18 <Riastradh> This is #haskell, not #ocaml, you...you...
14:18:22 <pesco> Riast: Yah, as soon as I get my Linux kernel to do USB (I'm on windows now)
14:18:55 <shapr> Igloo: oh, so it's like a monadic 'and' ?
14:18:58 <Darius> The esscom driver doesn't work with mandrake
14:19:05 <shapr> Darius: suckage :-(
14:19:09 <Darius> shapr: exactly!
14:19:38 <Igloo> I guess
14:19:55 <Igloo> But all monads with fail not being bottom are
14:20:32 <funktor> yay, move-parsing is now a bit less strict...
14:20:49 <funktor> and the play executable actually checks if the move you're doing is legal now
14:21:03 <shapr> Igloo: will all the bindM calls still happen?
14:21:17 <Darius> what did it do before?
14:21:47 <shapr> Darius: real external modems are pretty cheap :-)
14:22:04 <Darius> DSL isn't that expensive either
14:22:39 * shapr tests what he has learned
14:23:08 <Darius> I have a 28.8 that, in theory, would work
14:23:09 <Igloo> shapr: Nothing >>= k = Nothing   so the right hand argument of >>= won't be evaluated if the left hand argument is Nothing
14:23:50 <shapr> so, no more would be called/executed after the first bindM that returned Nothing
14:24:00 <shapr> ok, I understand that now, I think.
14:24:12 * shapr writes demo code to prove it to himself weeks from now.
14:24:18 <funktor> huh? really?
14:24:39 <shapr> funktor: it's like a big stack of "if then else" implicitly done
14:24:40 <shapr> I tihnk
14:24:53 <Darius> Usually, Either is probably better for most uses
14:25:10 <shapr> as soon my Maybe demo code works, I'll ask about Either
14:25:11 <Darius> Unless you are just representing a partial function
14:25:33 <funktor> I use Maybe for simple parsing...
14:25:47 <funktor> if some part failed, Nothing, otherwise Just (result,rest)
14:26:03 <funktor> and then a nested maybe Nothing (maybe ...) ...
14:26:22 <Darius> Wouldn't it be nicer to have Left "explanation"
14:26:27 <pesco> @listmodules
14:26:27 <lambdabot> I have the following modules installed: ["eval","fact","fortune","hello","karma","more","searchml","state","system","topic","type","yow"]
14:26:43 <funktor> Darius: hmm, good point
14:28:09 <Darius> and Right (result,rest) is a very reassuring message
14:28:43 <funktor> hmm, all this makes me think I should do the moveparser in Parsec
14:29:33 * Darius is a fan of Parsec.
14:29:40 <pesco> Darius, funktor, shapr: Update me, what's going on?
14:29:42 <funktor> yah, me too
14:29:48 <funktor> my first haskell prog was a parsec experiment
14:29:51 * Darius hasn't used anything else, so...
14:29:51 <shapr> pesco: with lambdabot?
14:30:30 <shapr> pesco: I've been spending all my spare time working on this spam filter, Paskalle
14:30:46 <pesco> shapr: just generally , what's the Either/Parsec/... talk about?
14:31:01 <Darius> the Maybe monad
14:31:18 <pesco> shapr: Oh, a spam filter, cool, how does it work?
14:31:29 <pesco> Darius:
14:31:38 <pesco> ook, I meant.
14:31:55 <shapr> pesco: not very well ;-)
14:31:58 <pesco> Have to get used to space next to return.
14:32:14 <Darius> @define map \f.fold (B Cons f) Nil
14:32:14 <lambdabot> map defined
14:32:15 <shapr> you're typing quickly imho
14:32:17 <pesco> shapr: Hehe! 
14:32:20 <funktor> hehe, pesco got a kinesis?
14:32:27 <shapr> took me three days before I could do anything much
14:32:40 <shapr> funktor: do you still use your kinesis?
14:32:57 <funktor> sure, @work, 8h / 5 days a week
14:33:09 <shapr> ah, cool
14:33:09 <Riastradh> @eval map (^2) (fromList [1,2,3,4])
14:33:09 <lambdabot> (line 1, column 6):
14:33:09 <lambdabot> unexpected "^"
14:33:09 <lambdabot> expecting simple term
14:33:12 <Riastradh> Bah!
14:33:18 <Darius> @eval B toList (map (\x.x*3)) (fromList [1,2,3,4])
14:33:19 <lambdabot> [3, 6, 9, 12]
14:33:30 <pesco> shapr: Hm... Don't know, it feels pretty natuoral just that I miss the keys sometimesv
14:34:16 <pesco> And I always mix up querty and dvorak because my head thinks "Oh, strange typing, must be querty!" and presses the querty keys. Doh.
14:34:40 <shapr> after a bit, I totally stopped missing keys ( except for the function keys, which took more than a year for me to get right )
14:34:51 <Darius> I could define a generic fold... if I could define a generic map... though I could just parameterise it on map (that's all "Functor f =>" does anyways)
14:38:09 <Darius> @define gfold \mp f.B f (mp (gfold mp f))
14:38:09 <lambdabot> gfold defined
14:39:37 <Darius> @eval B toList (gfold map (list 0 (\x y.x+y))) (fromList [1,2,3,4])
14:39:37 <lambdabot> type error
14:39:51 <pesco> Ooh, look, I'm on the GHC homepage!!
14:40:11 * shapr looks
14:40:55 <shapr> where?
14:41:16 <pesco> GHC 5.04.3 download page
14:41:43 <shapr> pesco: whoa, nifty!
14:42:16 <shapr> it's good they mirrored them, I'm giving my gateway to someone as a desktop box.
14:42:21 <pesco> Heh, I'm a little bit proud
14:42:22 <shapr> switching to 200MHz gateway :-/
14:42:51 <pesco> So what, enough for a gateway.
14:43:40 <shapr> truly
14:43:47 <shapr> this ALIEN guy on c.l.f is amusing.
14:44:08 <shapr> "well if microsoft supports haskell then they'd better make a visual haskell
14:44:09 <shapr> That will make the language do something useful. "
14:44:18 <shapr> sadly, he's unable to use google.
14:44:26 <Darius> @del-definition gfold
14:44:27 <lambdabot> gfold removed
14:44:33 <Darius> @del-definition mapL
14:44:34 <lambdabot> mapL removed
14:44:54 <shapr> I find it difficult to respect people who are unable to use google on a regular basis.
14:45:03 <pesco> haha
14:47:09 <shapr> quote from Darius "You can use google as well as I for more (there are certainly
14:47:10 <shapr> more even beyond the others I've seen) and details."
14:47:13 <pesco> mmhhmmw, me want 64bit IBM powerpc chips... munchy munchy
14:47:15 <shapr> Darius: hah, you wish :-)
14:47:38 <shapr> I wish too :-/
14:48:32 <shapr> hey, has everyone seen the pix of the hardcopy H98 report?
14:48:40 <shapr> http://kungens.kemi.fi/~shae/h98/
14:48:57 <shapr> Heffalump took glamour shots for us to be envious :-)
14:50:44 <pesco> *g* 
14:51:12 <shapr> note the emacs in the background showing Haskell code.
14:51:52 <Darius> and the way too many quick-launches
14:52:13 <basti_> cool ;)
14:52:54 * Darius can't stand gui text-editors for coding
14:52:58 <shapr> Darius: is that what those are? I can't see them well enough
14:53:18 <shapr> does emacs count as a gui text editor?
14:54:07 <Darius> if it's in a window it's gui, I use vim in console mode
14:54:26 <shapr> whoa, hardcode :-)
14:54:37 <shapr> I use emacs and the ion window manager
14:54:41 <shapr> and I feel hardcore
14:55:12 <shapr> it's nice to have access to Super and Hyper in emacs
14:55:36 <pesco> Ok, I must sleep, goodnite!
14:55:45 <shapr> g'nite pesco!
14:56:05 <Darius> 'nite
14:58:11 <Igloo> ion looks like it would just give me what galeon tabs and screen already do
14:58:43 <shapr> this is what my screen usually looks like: http://kungens.kemi.fi/~shae/erc.png
14:59:20 <shapr> ion gives me the option to stay away from the mouse 99% of the time
14:59:26 <shapr> I still have to use the mouse in galeon sometimes
14:59:47 <Riastradh> Bah, why don't you juse use links?
14:59:47 <Darius> what would be great if if that had "this is what my screen usually looks like: http://kungens.kemi.fi/~shae/erc.png"
15:00:29 <shapr> Darius: you think I should make real captions for the images in my dirs?
15:01:01 * Riastradh doesn't see any difference in what Darius said and what shapr said.
15:01:10 * Riastradh feels he has missed something.
15:01:15 * shapr probably did too
15:01:24 <debug> goodnite
15:01:27 <shapr> Riastradh: difference is, I'm used to it ;-)
15:01:32 <Darius> no it should be the current screen shot
15:01:48 <Darius> that would take trickery
15:01:52 <shapr> ?
15:02:00 <shapr> I don't understand?
15:02:15 * Riastradh is confused, too.
15:02:37 <shapr> of course, my last name is Erisson, so confusion is part of the deal.
15:02:53 <Darius> it would've been great if the screen shot was of you saying, "this is ..."
15:03:00 <shapr> oh!
15:03:02 <shapr> excellent point!
15:03:09 <shapr> internal captions, now I understand.
15:03:58 <shapr> Darius: I hadn't thought of that before, from now on I shall implement your suggestion.
15:04:01 <shapr> thanks
15:04:03 <Darius> not just that, the _current_  statement (you'd have to post the link before taking the screen shot(
15:04:06 <Riastradh> Oh, heh.
15:04:18 <Darius> (hence the trickery)
15:04:22 <shapr> Darius: lazy evaluation of screenshots, w00
15:04:33 <Riastradh> It wouldn't be that hard.
15:04:41 <Darius> it would work if you were fast enough
15:04:52 <Riastradh> Either dynamically generate the thing, or write a little script to take a screenshot and upload it.
15:05:17 <shapr> there's some nifty random desktop screenshot sharing software out there
15:05:21 <Riastradh> In Squeak, you could very easily do that: it would take about two method calls, I think.
15:05:23 <shapr> for win32 I think
15:05:36 <Riastradh> Hmm...Haskell in Squeak.  That would be weird.
15:05:40 <shapr> I could do it in emacs with a timer
15:05:46 <shapr> it's been done
15:05:55 <Riastradh> Haskell in Squeak has been done?
15:06:05 <Darius> hsqueak.sf.net ?
15:06:06 <shapr> Jan Skibinski (?) on numeric-quest.com
15:06:26 * shapr gets url
15:06:27 <Darius> no I'm thinking of hscheme (I think)
15:06:40 * Darius doesn't know what he's thinking of
15:06:44 <Riastradh> Not only has Scheme in Haskell been done, but also Scheme in Squeak.
15:06:47 <shapr> ashely yakeley did HScheme
15:06:57 <Riastradh> Scheme is just so easy to write an implementation of.
15:07:05 <shapr> http://web.archive.org/web/20010520121707/http://www.numeric-quest.com/haskell/smartest.html
15:07:33 <shapr> I think that's the correct url
15:07:34 <shapr> wayback machine is lagging for me
15:07:34 <Riastradh> ASCII should have the lambda character.
15:07:34 <Darius> I could do Scheme in the LC, with callCC and! tail optimization
15:07:39 <shapr> have you seen the pretty lambda stuff for emacs?
15:07:43 <Riastradh> I'm sick of using 'L' or 'lambda' or '\'.
15:07:54 <Darius> lambda sucks
15:08:00 <Darius> (lambda (x) x)
15:08:06 <Darius> \x -> x
15:08:23 <shapr> jorge adrian hacked luke gorrie's hacked version of ... >>= into a pretty-lambda.el for haskell-mode
15:08:23 <Darius> the TeX \lambda
15:08:28 <Riastradh> shapr - Yes, and it looks horrible...I think I've tried it with two different fonts, even.
15:08:48 <shapr> yes, that's the correct url
15:08:53 <Riastradh> It looks like a beached whale, not a lambda.
15:09:06 <shapr> "After all I named it: 'The world's smartest i/o device for Haskell'. I am not ashamed that I know and appreciate Smalltalk"
15:09:45 <Riastradh> Oh, bah.  It just uses hugs.
15:09:48 <shapr> numeric-quest.com was awesome
15:09:51 <Darius> Smalltalk is shameful?
15:09:52 <shapr> Riastradh: port it!
15:09:53 <Riastradh> I meant a real implementation, written entirely in Squeak.
15:10:00 <shapr> yow
15:10:05 <shapr> use Self
15:10:16 <shapr> then you'll get the poly-inline whatsis
15:10:32 <shapr> and sixteen other spiffy optimizations that the SelfVM had
15:10:36 <shapr> Self r0xx0rs
15:10:39 <Riastradh> Gah, and it uses Squeak 2.8.
15:10:53 <shapr> even worse, all the code from numeric-quest.com is UNLICENSED
15:10:57 <shapr> I can't put it into haskell-libs!!!
15:11:01 <shapr> this pisses me off!
15:11:33 <shapr> I started haskell-libs very specifically because of numeric-quest dropping off the 'net
15:11:58 * shapr gets off soapbox, goes back to code.
15:12:07 <shapr> Riastradh: know anything about opencroquet?
15:12:22 <Riastradh> No.
15:12:27 <shapr> is there an OpenGL display mode for Squeak yet?
15:12:28 <Riastradh> You could ask in #squeak.
15:12:35 <shapr> ok, I will.
15:14:53 <shapr> only for windows
15:15:37 <Riastradh> No, not Self -- Slate!
15:15:46 * shapr refuses to use Slate
15:15:52 <Riastradh> Why's that?
15:16:03 <Riastradh> It's originally written in CL?
15:16:06 <shapr> personality conflict with the main developer.
15:16:15 <Riastradh> That's water.
15:16:17 <shapr> yup
15:16:57 <Riastradh> He seems to despise me, too, for talking of Scheme in #squeak.
15:17:38 <shapr> he does not wish to communicate with me, because I have a prescription for psychoactive substances.
15:17:53 <Riastradh> Er, he just did communicate with you, a minute ago.
15:17:56 <shapr> he did
15:19:28 * Riastradh finds it curious that he hasn't been banned yet from #squeak, but eh, whatever.
15:20:42 * shapr shrugs
15:21:11 <shapr> Riastradh: hey, you know anything about bayesian statistics?
15:21:18 <Riastradh> No.
15:21:22 <Riastradh> Didn't you ask me that a few days ago?
15:21:33 <shapr> yah, I did.
15:21:55 <Riastradh> Expecting I'd get my butt over to some place where I'd learn something about 'em?
15:22:04 * shapr grins innocently
15:22:28 * Riastradh wonders why his lambda calculator is borken.
15:24:10 * Darius may need to use a totally different implementation of dynamics
15:25:25 * shapr rubs his feet on the carpet and touches a static value
15:25:37 <Darius> Java?
15:26:01 <shapr> actually just a constant in this Haskell file
15:26:16 <shapr> ohhh
15:26:27 * shapr finds a great Haskell quote on c.l.f
15:26:45 <shapr> "The best thing to get out of this, I guess, is that Haskell IS becoming more mainstream and even morons have heard of it." -- Darius
15:26:55 * shapr cackles
15:30:12 <Riastradh> Do you really want morons trying to be Haskell hackers and coming in here, pleading for help?
15:30:32 <Darius> not that bad yet
15:31:03 <Darius> well...
15:31:16 <Riastradh> I'd hate to see more people like the one who came in here who hadn't spent any time trying to learn Haskell but who tried to write in it.
15:40:03 <shapr> ok, I'm undistracted from our earlier discussion
15:40:21 <Igloo> Bah, computers aren't fast enough
15:40:25 <shapr> I think I've proven to myself that the Maybe thing does work, and now I have an example that I can go back to
15:40:30 <shapr> Igloo: what's up?
15:40:48 <shapr> now I'd like to see an example of Either used for errors
15:41:15 <shapr> @get-definition either
15:41:15 <lambdabot>  \f g e. e f g
15:41:19 <Igloo> type Parser a = [Token] -> Either a String
15:41:33 <Darius> EvalMonad uses ErrorT the transformer version of Either
15:41:53 <Igloo> I'm trying to generate an enormous number of test cases for Printf
15:41:55 <shapr> is that sort of like a unification type of something and error?
15:42:02 <shapr> that way you can return whichever one you get?
15:42:04 <Igloo> Yes
15:42:10 <Igloo> Yes
15:42:13 <shapr> nifty!
15:42:58 <Igloo> It's like struct {bool type; union {void *foo} {char *error}} in C (or however you write it) if that helps
15:43:35 <shapr> I know far more about Haskell than C
15:44:03 <Igloo> OK  :-)
15:44:14 <shapr> soooo, how would I use it?
15:44:23 <shapr> I see how to use Maybe as a monad
15:44:26 <Darius> struct Error { bool type; /* or better enum */ union { void *foo; /*this would need to be tagged too*/ char *error;}}
15:44:59 <shapr> at least, I see that I can use maybe as a monad to replace a stack of if/then/else or case checks
15:45:13 <shapr> that's something I've wanted since I started programming
15:45:21 <Igloo> It wouldn't need to be tagged in the same way as the a and b of Either a b don't need to be
15:45:59 <Igloo> Either isn't a Monad
15:46:11 <Darius> (Either a) is
15:46:53 <Igloo> Ah, yes - does H98 make it an instance of the class?
15:47:02 <Darius> I think
15:47:14 <shapr> yes
15:47:19 <shapr> er I dunno about H98
15:47:44 <shapr> but it's an instance of Functor, Monad, MonadPlus, MonadFix, MonadError, Typeable, Read, and Show in GHC docs
15:48:25 <Darius> Does H98 allow non simple instances: instance Monad (Either a) ?
15:49:00 <Darius> MonadError is probably the best interface to use Either (or ErrorT), it IS non-standard though
15:54:18 <Darius> I don't see instance Monad (Either a) in the online report.  Oh, well, I take -fglasgow-exts as a given.
16:14:29 <shapr> same guy
16:14:33 <shapr> what's up with that?
16:30:42 <Darius> ?
16:30:49 <shapr> !
16:30:57 <Marvin--> evening
16:31:00 <shapr> y0
16:31:01 <shapr> wassup?
16:31:08 <shapr> påsklov?
16:31:30 <Darius> Wie geht's?
16:31:40 <shapr> schoen, danke
16:31:42 <Marvin--> shapr: I wish
16:31:43 <shapr> och du?
16:31:56 * Marvin-- just came home from the pub though :)
16:32:00 <shapr> yay
16:32:01 <shapr> beer
16:32:44 <Marvin--> yep, mmm, ale and stout
16:34:02 <Marvin--> ick, foreign exchange student murdered in Uppsala
16:34:07 <shapr> :-(
16:35:13 * Riastradh suddenly feels a little less of a desire to go to the ICFP.
16:35:49 <Marvin--> heh
16:36:51 <Marvin--> wonder if it's too late to join the "world's worst vampire live"
16:39:18 <Marvin--> since I've never played any form of Vampire, I think I can be pretty convincing at the "worst" part ;)
16:46:09 <Marvin--> time to sleep
17:09:56 <shapr> hm
17:10:19 <shapr> I've sort of written the fallback key checking
17:10:22 <shapr> trim2 key = trimBang key : trimCaps key : trimField key : trimCase key : trim2 (head $ trim2 key) 
17:10:35 <shapr> as a lazy list so I can 'downgrade' the key until it matches
17:11:03 <shapr> problem is that I want the whole bang sequence first, then the whole caps sequence, then the case, then the field
17:11:11 <shapr> obviously, it doesn't work that way.
17:11:23 <shapr> how can I make it work that way?
17:22:04 <Darius> If I'm understanding this right, the simplest thing I can think of is to have trimBang key return a list of (value,key) pairs and feed the keys into trimCaps doing the same thing etc.
17:22:27 <shapr> hm
17:22:28 <shapr> neat
17:22:32 * shapr tries that
17:24:08 <Darius> hm this seems exponential
17:24:23 <shapr> ?
17:25:28 <Darius> you feed trimBang one key it gives you a list of keys, you feed trimCaps a list of keys it gives you a list of keys for each key...
17:25:35 <shapr> riht
17:25:37 <shapr> yes
17:26:14 <Darius> is that what it's supposed to be doing (every combination perhaps)
17:26:17 <Darius> ?
17:26:18 <shapr> yup
17:26:48 <shapr> http://kungens.kemi.fi/~shae/src/haskell/ProtoLazyList.hs
17:27:05 <shapr> trim2 being the code I'm working on at the moment, result showing a sample input
17:27:42 <shapr> specifically, I'm trying to implement the 'alternatives' part of http://paulgraham.com/better.html
17:27:52 <shapr> just in case you're interested in all that extra detail ;-)
17:33:22 <Darius> a pair of lists may be easier and more sensible than a list of pairs
17:34:50 <shapr> how so?
17:35:14 <shapr> er
17:35:17 <shapr> I think I see that
17:55:07 <shapr> y0 Pseudonym
17:55:21 <Pseudonym> G'day.
17:55:28 <shapr> what's happening?
17:55:50 <Pseudonym> Not a lot.
17:55:52 <Pseudonym> Oooh, new wiki!
17:55:57 * Pseudonym woohoos
17:55:58 <shapr> yes, wiki!
17:56:01 <Pseudonym> There goes my productivity.
17:57:14 --- topic: set to '["mo' nads than you","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","New Learning Haskell page - http://www.haskell.org/learning.html","GUI Demos - http://repetae.net/john/computer/haskell/gui/","Order Haskell 98 Report in Hardcopy - http://titles.cambridge.org/catalogue.asp?isbn=0521826144","New HaWiki - http://www.haskell.org/hawiki/RecentChanges"]' by shapr
17:57:33 <shapr> have you seen the pinup pix of the H98 hardcopy?
17:57:43 <Pseudonym> No...
17:57:47 <shapr> http://kungens.kemi.fi/~shae/h98/
17:57:51 * Pseudonym shudders at the thought of Haskell pinups
17:57:56 * shapr laughs
17:58:10 <shapr> "shirts off to wadler"
17:58:29 <Pseudonym> Hey, you're not a real geek.  Your desk is way too clean.
17:58:34 <shapr> not my desk
17:58:36 <shapr> Heffalump
17:58:48 <Pseudonym> Oh, that's okay then.  it's not technically his desk then.
17:58:52 <shapr> right
17:59:02 <shapr> he's at oxford, being paid by microsoft.
17:59:06 <shapr> or something like that
17:59:13 * Pseudonym ooohs and aaahs
17:59:31 <Igloo> He's paid be EPSRC nowadays
18:00:26 <shapr> oh, what's that?
18:00:57 <Igloo> Engineering and Physics Science Research Council or similar
18:06:23 <shapr> nifty
18:06:40 <jlk> :)
18:06:47 <shapr> hi jlk 
18:06:49 <shapr> wassup?
18:07:48 <jlk> hello.
18:08:39 <jlk> well i'm on the look for a crossplatform gui (like lispworks)... except it's beyond approach at this point.
18:14:21 <shapr> jlk: Tk?
18:14:26 <Igloo> 0~
18:14:26 <Igloo> Bah
18:14:36 <shapr> do you mean a cross-platform IDE?
18:14:37 * jlk twists his fingers together in shapr's direction.
18:14:57 <jlk> :lispworks, java,etc.
18:15:05 <jlk> except java you can decompile..
18:15:33 <shapr> ?
18:16:22 <Igloo> I would imagine you could decompile Haskell as far as core
18:16:43 <jlk> if you didn't already have to distribute the source for execution.
18:16:45 <jlk> hahaha.
18:16:59 <Igloo> ?
18:17:04 <shapr> what?
18:17:47 <shapr> why would you need to distribute the source?
18:18:16 <jlk> what other options are there for haskell to distribute?
18:18:39 <Igloo> binaries...
18:18:52 <Pseudonym> You mean statically linked binaries, presumably.
18:19:57 <Igloo> statically linked with the standard Haskell libraries? Yes, although I imagine it would be an easy change to have them shared at a speed cost
18:20:11 <jlk> hmm, can haskell access tcp/ip higher level protocols like smtp/pop3?
18:20:28 <Pseudonym> Igloo: The trouble with GHC is that binary compatibility breaks on every minor version of the compiler.
18:20:43 <shapr> jlk: yes
18:20:49 <Igloo> The implementations can, but there aren't many higher level libraries around
18:21:10 <Pseudonym> jlk: We'd welcome a contribution. :-)
18:21:37 <jlk> of course
18:21:55 <shapr> @fact source
18:21:56 <lambdabot>  http://sf.net/projects/haskell-libs/, http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/lambdabot/
18:22:26 <shapr> http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/email/SMTP.hs
18:22:39 <shapr> that's a quick hack of smtp email sending
18:24:38 <jlk> thanks
18:26:18 <jlk> hmm is pop in there?
18:26:53 <shapr> nope
18:26:58 <shapr> wanna write it? 
18:27:41 <jlk> possibly, for the love of the language. will probably protoype in lisp first.
18:27:48 <shapr> ok
18:28:14 <jlk> <such a newbie. :l
18:28:49 <shapr> gotta start somewhere
18:28:55 <Pseudonym> We don't hate lisp, necessarily.
18:28:59 <Pseudonym> It's still a functional language.
18:29:12 <Pseudonym> Some people here even use *hack spit* Emacs.
18:29:25 <shapr> :-)
18:30:50 <Riastradh> Hack spit because it's Lisp or hack spit because it's elisp?
18:31:09 <Pseudonym> Hack spit because it's Emacs.
18:31:23 <jlk> clisp distribution isn't too viable. think i'll go back to haskell path. though it'll be a bitch for me.
18:31:36 <Riastradh> Yuck, I wouldn't want a Common Lisp Emacs.
18:31:38 <Pseudonym> Ah, but you'll learn a lot.
18:31:52 <Pseudonym> Riastradh: Indeed.
18:31:57 <Igloo> Are you writing commercial stuff?
18:31:58 <Pseudonym> It's not the language so much, of course.
18:32:06 <Pseudonym> It's the libraries.
18:32:17 <jlk> where can I get a documentation rundown for all the haskell native, protocol extended libraries, ...pwease.
18:32:30 <Riastradh> I'd like to see a ScheMacs or a Haskell Emacs.
18:32:36 <shapr> HEmacs!
18:32:37 <shapr> w000
18:32:40 <Pseudonym> Err... these libraries are documented?
18:32:44 <Pseudonym> News to me.
18:33:01 <jlk> Igloo, i have to make some money. 
18:33:25 <jlk> though otherwise, it'd be free. so i am releasing as shareware. hopefully.
18:33:25 <Igloo> It wasn't a complaint, I was just wondering at your dislike of source distribution
18:34:09 <jlk> well, eventually I will definitely distribute the source.. just not for some time.
18:35:00 <jlk> Pseudonum, how about the source?
18:35:11 <Darius> of course Pseudonym, with the source
18:35:59 <shapr> @fact learning
18:36:00 <lambdabot> http://www.haskell.org/learning.html
18:36:05 <shapr> jlk: lots of docs at that url
18:36:19 <shapr> check the GHC docs for native/extended stuff
18:37:00 <jlk> well on GHC I can never get it to work. :) hugs works fine though.
18:37:32 <Pseudonym> True, the source.
18:38:07 <Darius> It's the only documentation I can find on GHC's Dynamic implementation
18:41:13 <jlk> also, where can I get complete source to small demos? I've looked everywhere.
18:41:37 <Pseudonym> There's haskell libs, there's a lot of stuff on the wiki...
18:41:38 * Pseudonym thinks
18:41:55 <Pseudonym> Should keep you going for a while, anyway.
18:42:12 <shapr> yah, I agree.
18:42:47 <jlk> that's with hugs right? :)
18:43:46 <Pseudonym> Can be.
18:44:07 <Darius> Chances are it's either standard haskell or GHC
18:44:12 <jlk> spoken like a true hugs user.
18:44:20 <jlk> :P~~~
18:44:57 <Pseudonym> Hugs and GHC are mostly compatible.
18:46:03 * shapr goes to sleep
18:46:23 <Pseudonym> Night.
18:46:32 <Darius> Yeah, if you put the Hugs REPL in an IO Monad you wouldn't be able to tell them apart... oh wait, startup would give it away.
18:47:00 <jlk> thanks shapr, bye.
18:47:53 <jlk> that's ok.
19:20:09 <jlk> bbl
