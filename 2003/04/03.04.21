00:04:09 <Verbophobe> Hmmm...  What are these alternatives?
00:09:27 <Darius> Use rationals or there's a exact real library it haskell-libs
00:09:43 <Verbophobe> Alright.
00:09:46 <Verbophobe> Thanks man.
00:10:26 <Darius> the output of printf(".16f",(double)(32.3)-(double)(5.2)); is 27.0999999999999979
00:11:56 <Verbophobe> Here I get 27.100000
00:12:03 <Verbophobe> But it doesn't matter, I get your drift.
00:45:34 <Riastradh> @yow
00:45:35 <lambdabot> What's the MATTER Sid?..  Is your BEVERAGE unsatisfactory?
02:29:48 <o3> any template haskell experts in the house?  is it possible to call an FFI function from within oxford brackets?  (i.e. in a [| ... |] construct)
03:20:34 <Riastradh> Does anyone have any suggestions for how I should go about writing a parser?
03:21:23 <Marvin--> get a parser combinator library?
03:21:39 <Riastradh> Er, a bit more specific than that.
03:22:16 <Marvin--> er, "learn how it works and how to use it"? :)
03:22:23 <Marvin--> maybe the other way around :)
03:22:44 <Riastradh> No, no, no, not like that, but is there one you would recommend?
03:23:11 <Riastradh> I see eight to choose from just on the haskell.org 'libraries and tools' page.
03:23:12 <Marvin--> I like Koen's Parsek, which is based on Parsec (which is distributed with ghc at least, don't know about hugs)
03:23:28 <Marvin--> Fokker's library is slower, but simpler
03:25:30 <Marvin--> You can also use Happy, or Ranta & Forsberg's bnfc (http://www.cs.chalmers.se/~markus/BNFC/ I think)
03:27:40 <Janni> morning
03:28:18 <Riastradh> Hi.
03:41:28 <Marvin--> N-arnia
03:42:07 <Arnia> Hey
04:00:18 <basti_> hi all & happy easter II
04:07:21 * Riastradh pokes someone who is familiar with Parsec.
04:10:42 <o3> Riastradh: i've used it, like, once ... a long time ago ...
04:10:48 <o3> i.e. i'm not very useful :)
04:11:02 <Riastradh> Fear not: my question is basic.
04:12:40 <Riastradh> In writing a simple parser of a 'Term' type (of which there are three variants), I write one parser-ish thing for each variant, and a 'term' parser-ish thing.  What else need I define?
04:13:18 <o3> erm, i'm not really sure :)
04:13:29 <Riastradh> Blah.
04:13:41 <o3> been a very long time since i've used it, sorry
04:13:49 <o3> i did find the docs and the examples in there to be very helpful, though
04:14:04 <Darius> You have parsers that parses each type of term?
04:14:24 <Riastradh> Yes.
04:15:04 <Darius> Then you shouldn't need to define anything else (for basic stuff)
04:15:30 <Riastradh> But in order that each term may contain any other sort of term (except for one), I need a generic 'term' parser, correct?
04:16:59 <Darius> It depends on how you structure it, but just term = term1 <|> term2 <|> term3 should work (assuming they have different FIRST sets)
04:17:29 <Riastradh> 'FIRST sets?'
04:18:49 <Darius> The first token that each parser can parse, basically that (term) will work as long as it can tell which termN to choose by the first token it sees
04:19:56 <Darius> If it can't then you need a 'try' or you need to restructure the grammar
04:20:55 <Darius> Parsec has (perhaps surprisingly) some decent documentation
04:28:14 <delYsid> string "(a)" <|> string "(b)"
04:28:39 <delYsid> it fails, because the first parser consumes the '('
04:31:02 <o3> delYsid: i think you want to put the 'try' keyword in front of it.  there's something about it in the parsec documentation
04:32:10 <delYsid> o3: I know, just wanted to provide an example for the abocve discussion
04:32:27 <o3> ah, okay
04:36:34 <delYsid> foldr1 (<|>) $ map (\s -> try s >> return (s)) ["(a)","(b)"]
04:43:14 <Darius> try (string s)
04:43:43 <Darius> and I think choose == foldr1 (<|>)
04:45:11 <Darius> choose . map (try . string) 
05:57:28 <shapr> gooood morning #haskell!
05:57:49 <mgoetze> hi shapr
05:58:01 <shapr> y0 mgoetze, wassup?
05:58:15 * shapr boings
05:58:58 <mgoetze> shapr: well, i'm at a german hacker convention watching people behave like geeks
05:59:10 <mgoetze> e.g. drooling over linesis keyboards
06:00:47 <mgoetze> kinesis, rather
06:00:56 * mgoetze is not used to typing on laptops
06:03:59 <delYsid> shapr: Count-down is running, approx. ETA 5h
06:04:08 <shapr> delYsid: till you can check in code?
06:04:16 <delYsid> yup
06:04:29 <shapr> mgoetze|away: well, I have two kinesis here, neither of which I'm drooling over
06:04:31 <shapr> delYsid: yay!
06:10:24 <shapr> I've never been to a computer convention
06:10:38 <shapr> I sort of doubt that PLI/ICFP/HW will be typical
06:12:19 * shapr boings
06:13:08 <Igloo> I don't think there's much similarity between computer conventions and conferences
06:13:23 <Igloo> But I haven't /really/ been to either, so...  :-)
06:14:00 <shapr> hi Igloo, how's the code?
06:14:16 <Igloo> Stationary  :-(
06:14:24 * Igloo is trying to be in paper-writing mode
06:14:58 <shapr> ah
06:16:18 <Igloo> And Dominic?k? has been tempting me to write more crypto stuff  :-)
06:16:41 <shapr> Dominic Steinitz?
06:16:51 <Igloo> That sounds right
06:16:55 <shapr> someone is working on an SSL implementation also
06:18:48 <shapr> I still think web browsers should do tab completion of addresses like http://tld.domain.host/etct
06:19:11 <Igloo> Do you mean reversing them?
06:19:42 * Igloo clears my Debian buglist...aaahhhh  :-)
06:19:53 <shapr> not all of them, just the com.foo.bar part 
06:20:11 <shapr> what's the point of doing tab completion from the most specific part of name?
06:20:49 * shapr has the urge to write a haskell web browser that embeds the mozilla rendering component
06:20:50 <Igloo> I want some where where I can select prefered completions
06:24:09 <shapr> I'd like to make some Haskell packages for debian...
06:25:11 <Igloo> Do you mean package some programs written in Haskell?
06:25:17 <shapr> yup
06:25:29 <shapr> lambdabot and hws-wp for example
06:25:53 * Igloo is tempted to package my pan implementation when it's finished
06:26:28 <shapr> yah, good idea
06:27:37 <Igloo> Hmm, although to do any sort of compilation I'd have to depend on a specific version of GHC
06:27:40 * shapr tries to wrap his head around lazy lists
06:37:18 <shapr> hi SyntaxPolice
06:37:20 <shapr> wassup?
06:37:52 <SyntaxPolice> shapr: good morning. have a good weekend?
06:38:20 <shapr> yah, I did
06:38:23 <shapr> how was yours?
06:38:40 * Marvin-- yawns
06:40:00 <SyntaxPolice> pretty good, visited my folks, saw some old friends.
06:40:39 <shapr> I hung out with friends, had good food
06:40:54 <shapr> g'mornin Marvin-- 
06:41:05 <Marvin--> morning? Not really :)
06:41:15 <Marvin--> I went up fairly early today expecting to work on my master project
06:41:17 <Marvin--> haven't started yet, though
06:43:17 <shapr> yah, I'm trying to jump start my day also
06:44:21 <shapr> at the moment I'm trying to increase my ability to use lazy lists
06:53:30 <shapr> at some point someone is going to ask a question about lazy lists, and I'll get to respond "I think you're on the right tail"
06:54:25 <shapr> so, what's everyone working on today? fun Haskell code?
06:54:36 <Marvin--> shapr: *groan*
06:54:37 <shapr> SyntaxPolice: did you release your project?
06:54:47 * shapr grins evilly
06:55:15 * Arnia laughs evilly as he designs his new personal site
06:59:41 <shapr> ono, I have been asked to come over to my friends apt and play warcraft III
06:59:43 <SyntaxPolice> shapr: no releases anytime soon.
06:59:47 * shapr disappears for two hours
07:11:50 <delYsid> shapr: chess is full of laziness
07:13:39 <Igloo> How do you mean, del?
07:55:28 <SyntaxPolice> hrm. hugs make clean does not return it to anything like its original form :(
08:20:41 <delYsid> Igloo: The gameTree I use is a recursiv lazy data-type.
08:21:00 <delYsid> So I can compute the potentially infinite gameTree for a given position, and only look at the parts I'm interested in.
08:21:31 <delYsid> or prune to a certain depth or whatever
08:22:11 <Igloo> Right, OK
10:35:27 <shapr> y0h0h0 and a bottle of bubble-gum
10:36:05 <Igloo> What ya up to, shapr?
10:36:57 <shapr> oh, about five foot nine
10:37:00 <shapr> what about you?
10:37:13 <Igloo> No idea
10:38:41 <shapr> how tall are you in meters?
10:38:48 <Igloo> No idea
10:38:55 <shapr> ok then :-)
10:39:23 <shapr> I played warcraft III for two hours, and it was fun! yay!
10:39:34 <Igloo> I am precisely one standard Igloo tall, but units doesn't know about them
10:39:40 <shapr> now to see if delYsid has checked in new chess code
10:39:41 <Igloo> Cool  :-)
10:40:00 <Igloo> Are the warcrafts in the same genre as Command and Conquer?
10:40:08 <shapr> yah, real time strategy
10:41:30 <shapr> I'd like to write an RTS game in Haskell, and give a decent strategy combinator library with which to reprogram unit behaviour
10:41:45 <shapr> for example, in starcraft, units are totally suicidal
10:42:21 <Igloo> Interesting idea
10:42:30 <Igloo> Combinators at the team level or the unit level?
10:42:35 <shapr> e) all of the above
10:42:47 <shapr> though unit level would give you team level
10:42:58 <shapr> just use starlogo-style code
10:43:08 <Igloo> It would?
10:43:22 <shapr> yah, if units can 'detect' other units around them
10:43:38 <shapr> then a bunch of weenies would be smart enough to not attack the enemy unless they were in a bunch
10:43:51 <Igloo> I'm just thinking that you wouldn't want a single unit to decide to attack something, you'd want to decide which is best to attack globally and then have each unit near it help out
10:44:07 <shapr> oh, interesting idea
10:44:55 <shapr> since the player will end up writing the equivalent of custom AI
10:45:27 <Igloo> Oh, this is for the player to do in real time?
10:45:28 <shapr> I think one unit type should be able to 'steal' chunks of AI source from dead units of the other team.
10:46:06 <shapr> you can write/install the code ahead of time
10:46:36 <Igloo> I initially thought you just meant as a way to write the AI side, but that's a much cooler idea  :-)
10:47:07 <Igloo> Being able to program buildings would be really useful
10:47:16 <shapr> I can see lots of fun 'extensions' happening
10:47:36 <shapr> such as a source obfuscator that means that stolen AI code isn't worth much without *all* of the code
10:48:29 <Igloo> Actually, I think you should steal the units entire orders
10:48:34 <shapr> ohh!
10:48:37 <shapr> excellent idea!
10:48:42 <Igloo> And if you capture the control center you should get the whole teams orders
10:48:44 <shapr> stealing current orders is much more useful
10:49:05 <shapr> oh, you could write 'counter-AI' code
10:49:13 <shapr> that would decide what to do based on the current orders of the other team
10:49:39 <shapr> if their objective is to capture a certain building or resource, then you shift your strategy to take advantage of that knowledge
10:49:43 <shapr> man, this could be *really* cool
10:50:10 <shapr> counter-counter-AI code would shift objectives once the current objective was known
10:50:13 <shapr> mmm, nifty
10:50:50 <Igloo> Maybe you wouldn't be able to give orders directly to anything more than x distance from your CC. Or maybe you only could if you have a chain of comms units to it
10:51:00 <shapr> oh wow!
10:51:04 <shapr> that's perfect!
10:51:11 <shapr> then you're forced to write comm code as well
10:51:24 <shapr> so you end up having to program 'army ants'
10:51:26 <Igloo> Ermmm, that's not what I meant
10:51:33 <shapr> that pass messages from unit to unit
10:51:58 <Igloo> I mean you couldn't click on a unit and tell it to move somewhere or attack something unless you had a trail of a certain type of unit
10:51:59 <shapr> but unit-to-unit comm code would be the next step, yes?
10:52:22 <shapr> right, but the units you could order could pass the orders to the next unit, right?
10:53:00 <shapr> then, you could allow undercover units that would pretend to be enemy weenies but actually pass info back to you
10:53:04 <Igloo> I think that would be too complex. I meant that you could order a unit directly as you are used to provided you have a comm chain to it
10:53:26 <Igloo> Oh, ISWYM, you could also send units off to reorder units in battle, yes
10:54:09 <shapr> a game like this could be more fun to play than to write!
10:54:12 <shapr> wow
10:54:50 <Igloo> I'm not sure whether you should be able to see only as far as chains from your CC or anywhere you have units (or anywhere you have been before)
10:54:56 <Igloo> Well, all 3 could be options
10:55:16 <shapr> I think actual 'sight' would be limited to 'chain of command'
10:55:35 <shapr> but you could have overall updates passed back via u2u comm code
10:55:58 <Igloo> The problem is it's then hard to know how to reorder units. But it does encourage you to work more at keeping links up
10:56:10 <shapr> yah, links would be very important
10:56:19 * Igloo meant "communications" by comm, incidentally
10:56:42 <shapr> but you could also have 'special forces' that are designed to run 'behind enemy lines' far away from your comm chains
10:56:48 * Igloo thinks we should write this
10:56:50 <shapr> yes!
10:57:28 <Igloo> Oh, there would be no need to keep a comm chain to all units, but those you can't reach would just keep on doing what you last ordered them to, which might be bad
10:57:34 <shapr> also, if the strategy combinators are just a DSL in Haskell, it would be a great way to infiltrate the Haskell addiction
10:57:42 <shapr> right
10:57:49 <shapr> unless passed new orders
10:57:50 <Igloo> It would need to be biased in favour of the defender - it wouldn't be very exciting if the first attack tended to win
10:57:57 <Igloo> Yes
10:58:15 <shapr> with an equal bias towards expansion, since you can run out of resources if you defend too much
10:58:27 <shapr> called 'turtling' in starcraft
10:58:40 <shapr> where you have great defenses and no money left to expand
10:59:22 * Igloo mutters about needing to do dphil things  :-/
10:59:26 * shapr grins
10:59:34 <shapr> yah, I wasn't planning on writing a game either ;-)
10:59:38 <Smerdyakov> Igloo, "dphil"
10:59:40 <Smerdyakov> ?
10:59:41 <Igloo> We need a graphics person
10:59:45 <Igloo> PhD
10:59:45 <shapr> yes, we do
10:59:50 <shapr> who?
10:59:55 <shapr> Arnia does graphics
10:59:58 <shapr> Arnia: pssst
11:00:03 <Smerdyakov> Igloo, is "dphil" a usual term at your school?
11:00:08 <shapr> Arnia: the arrows are calling you...
11:00:11 <Igloo> Well, we need a design first  :-)
11:00:18 <Igloo> And 2d would do for the first draft
11:00:24 <shapr> that's true
11:00:25 <Igloo> university, yes
11:00:40 <Smerdyakov> Igloo, I don't know why you specified "university," but OK. =)
11:01:07 <Igloo> Well, I thought that while I was explaining terms used there I should correct the term used to describe it  :-)
11:01:28 <shapr> we would need to investigate the DrIFT and other strategy combinators
11:01:28 <Igloo> School here is up to age 16 or 18
11:01:30 <Smerdyakov> Really? You haven't taken classes there?
11:01:46 <SyntaxPolice> shapr: methinks I'm going to add DebianUsers to the wiki.
11:01:50 <SyntaxPolice> (fyi :)
11:02:20 <Igloo> I think I have, it's just that school isn't a word we'd use for it
11:02:27 <shapr> SyntaxPolice: good idea
11:02:38 <Smerdyakov> Hm. And here I thought I had one word everyone who speaks English can agree on. =)
11:03:34 <Igloo> shapr: I think it's the ordering that would make it a different game, but having combinators/FP programming would be a bonus if it worked nicely
11:04:08 * Igloo goes to rescue food
11:04:20 <Igloo> (curse interesting conversations when I'm cooking!)
11:07:05 <Marvin--> Igloo: been there, done that :)
11:08:37 <shapr> I wonder how Strafunski does its strategy combinators
11:12:31 <shapr> Igloo: the first dark reign has excellent ordering
11:12:48 <Igloo> shapr: Oh?
11:12:56 <shapr> some very cool tricks were allowed, for example, the mechanics were considered standard units that did -5 damage to friendly units
11:13:10 <shapr> so you set them on medium pursuit and medium independence
11:13:18 <Smerdyakov> Uh... yeah... that's "very cool".
11:13:20 <shapr> and they would autorepair friendly units in a small radius
11:13:33 <shapr> Smerdyakov: have you seen niftier features in RTS games?
11:13:49 <shapr> the three settings were pursuit, independence, and repair level
11:14:19 <Igloo> Ah, so it allowed you to give a few set pieces of AI to your own units?
11:14:25 <shapr> they mapped onto the rows on the numpad (columns were low, med, hi) , so you could select a bunch of units and immediatly change their settings
11:14:28 <Smerdyakov> I sure hope they have niftier things than "units that do negative damage"! =D
11:14:52 <SyntaxPolice> Debian users, add thyselves: http://www.haskell.org/hawiki/DebianUsers
11:14:55 <shapr> Smerdyakov: they did, they also had unit promotion, unit 'transformation' that allowed other cool features
11:15:22 <Igloo> Smerdyakov: Such as?
11:16:10 <Smerdyakov> Igloo, units that do complex damage.
11:16:17 <Igloo> Feel free to add me - I maintain haskell-doc, haskell98-{tutorial,report}
11:16:27 <Igloo> complex?
11:16:39 <Smerdyakov> Yeah, real and imaginary components.
11:16:48 <shapr> actually, DR did have 'complex damage'
11:16:56 * Igloo raises an eyebrow
11:16:58 <shapr> there were different types of armor, and different types of damage.
11:17:14 <shapr> Smerdyakov: imaginary damage would be nifty from a psionicist
11:17:17 <SyntaxPolice> Igloo: do you want me to put your name there? (If so, what is it :)
11:17:35 <SyntaxPolice> I guess I could ask apt :)
11:17:52 <shapr> @fact Igloo 
11:17:52 <lambdabot>  Ian Lynagh,  Template Haskell Guru
11:17:58 <shapr> @fact SyntaxPolice
11:17:59 <lambdabot> Nothing
11:18:12 * Marvin-- points and laughs
11:18:14 <shapr> @fact SyntaxPolice Isaac Jones, debian developer, maintainer of haskell-mode
11:18:15 <lambdabot> set syntaxpolice to Isaac Jones, debian developer, maintainer of haskell-mode
11:18:22 <shapr> @fact Marvin-- 
11:18:23 <lambdabot> Nothing
11:18:27 * Marvin-- points and laughs
11:18:33 <Marvin--> oh wait
11:18:40 <SyntaxPolice> I might be maintaining hugs soon too. we'll see.
11:18:49 <shapr> @fact Marvin-- Martin Sjögren, debian developer, developer of d-i among other pkgs
11:18:50 <lambdabot> set marvin-- to Martin Sjögren, debian developer, developer of d-i among other pkgs
11:18:55 <shapr> @fact shapr 
11:18:55 <lambdabot> Shae Erisson, wrote the factoid plugin for lambdabot, 31 years old, good for the karma
11:19:00 * ibid used to maintain some haskell packages
11:19:01 * shapr grins
11:19:04 <shapr> @fact ibid 
11:19:05 <lambdabot> Nothing
11:19:06 <Igloo> Oh, I was going to look at its bugs shortly and prod the maintainer
11:19:08 <ibid> (for example hugs)
11:19:26 <shapr> @fact ibid Antti-Juhani Kaijanaho
11:19:26 <lambdabot> set ibid to Antti-Juhani Kaijanaho
11:19:32 <shapr> ibid: are you still a DD?
11:19:36 <ibid> yes
11:19:42 <shapr> @fact ibid debian developer
11:19:43 <lambdabot> set ibid to debian developer
11:19:46 <Marvin--> how's that relevant to #haskell?
11:20:01 <shapr> we're Debian friendly?
11:20:04 * shapr dunno
11:20:08 <ibid> i maintain grep-dctrl and sablecc currently
11:20:10 <SyntaxPolice> ibid: hugs is a pain :)
11:20:17 <ibid> SyntaxPolice: it wasn't then :-)
11:21:03 <shapr> @fact ibid maintains grep-dctrl and sablecc
11:21:04 <lambdabot> set ibid to maintains grep-dctrl and sablecc
11:21:18 <ibid> ää
11:21:55 <SyntaxPolice> ibid: what changed?
11:22:18 <ibid> SyntaxPolice: haven't looked at hugs lately, i use the compilers nowadays
11:22:48 <ibid> this was around the time when Hugs was freed
11:23:04 * ibid also created the haskell-doc package
11:23:43 <SyntaxPolice> well currently the build system needs to install libraries in {prefix}/lib, though there may be a way around this, also it copies stuff from random spots in the source tree into other spots, so make clean doesn't really work.
11:24:07 <SyntaxPolice> plus the package is currently in pretty bad shape :(
11:24:26 <shapr> Igloo: http://www.haskellwars.com/ 
11:25:02 * ibid is also (probably) going to teach fp with haskell next autumn
11:25:07 <shapr> yay!
11:25:25 <Igloo> Ah, interesting - we were a combination of that and RTSs
11:25:51 <Marvin--> yay, the Charmed ones are listening to Ozzy
11:26:08 <Igloo> It has a trailer? That's gotta be worth a look...
11:26:12 * shapr grins
11:26:16 * SyntaxPolice is almost ready to upload a new hugs package, though.
11:26:23 <shapr> Igloo: I found #haskellwars recently...
11:27:14 <Igloo> Do you know how near finished they are?
11:27:24 <shapr> ludde: how much code do you have?
11:27:31 <SyntaxPolice> BTW, I mentioned that I was giving an intro to Haskell talk the other day. I introduced the language by talking about how its different from other languages, going through an example Stack module, and talking a little bit about pattern matching. I was mainly trying to give people an idea about why Haskell is neat.
11:27:42 <shapr> SyntaxPolice: how did it go?
11:27:59 <SyntaxPolice> For the 2nd talk, I was thinking of targeting people on the level of the Gentle Introduction, and i'm curious as to what you folks would recommend talking about
11:28:07 <ibid> SyntaxPolice: how do you define "other languages"? imperative stuff?
11:28:18 <SyntaxPolice> shapr: pretty well, had some really good questions, and OK attendence.
11:28:40 <SyntaxPolice> ibid: I talked about imperative languages and other functional type languages, especially Lisp since most ppl have some lisp experience.
11:28:45 <shapr> SyntaxPolice: how many ppl?
11:28:45 <Igloo> Well, it looks like they have some decent graphics guys, anyway
11:28:50 <shapr> what sort of questions?
11:28:53 <SyntaxPolice> shapr: about 20 I think.
11:28:56 <shapr> spiffy!
11:29:20 <shapr> do you have an outline of your first talk?
11:29:23 <SyntaxPolice> some folks like jemfinch had seen Haskell, so they asked questions about ($) vs (.), um...
11:29:47 <SyntaxPolice> one guy asked if all haskell functions had to be one line long, which I had a little trouble answering in a way :)
11:29:48 <shapr> oh, he lives in the same place?
11:29:55 <SyntaxPolice> yeah, he's in Columbus.
11:29:56 * shapr laughs
11:30:11 <SyntaxPolice> the talk is linked from http://opensource.cis.ohio-state.edu
11:30:19 <shapr> I guess $ . and $! are in the same category
11:30:24 <shapr> 'flavors' of function calling
11:30:42 <SyntaxPolice> I felt that my approach was a little odd in that I didn't introduce stuff like "data" and how to design data structures in Haskell.
11:30:55 <SyntaxPolice> but I wanted to give ppl a tour more than a lesson.
11:31:51 <Smerdyakov> Anyone know if there is a standard bibtex type for web page citations?
11:32:08 <ibid> nothing standard surely
11:32:15 * ibid usually uses @misc
11:32:22 <Smerdyakov> Where do you put the URL?
11:32:27 <SyntaxPolice> soo. for the next talk I was thinking about 1. data structures 2. list commprehensions (just because they're cool) 3. monads 4. classes, with most of the time speant on Monads and just a conceptual introduction to classes
11:32:30 <ibid> depends on the bst
11:32:45 <ibid> with standard bst's, i do note = {{\url{...}}
11:32:52 <ibid> some bst's support url =
11:32:55 <SyntaxPolice> comments?
11:33:07 <Igloo> I midified one of the standard bsts to include a wep and program type
11:33:33 <ibid> wep?
11:33:53 <Igloo> web
11:34:02 <ibid> right
11:34:56 <shapr> SyntaxPolice: you could go down the 'theoretical' path by showing partial evaluation, and how -> is right associative, and how that compares with lambda calculus
11:36:39 <shapr> monads and arrows are the most interesting part of Haskell imho (probably because I don't totally understand them )
11:36:44 <Smerdyakov> SyntaxPolice, talk where and for what purpose?
11:36:53 <Smerdyakov> shapr, you don't understand monads?
11:37:07 <SyntaxPolice> shapr: thats a thought - I feel that my audience is full of more practical types and Haskell is a hard sell as it is :)
11:37:25 <SyntaxPolice> Smerdyakov: a 2nd (out of two) hour long talk on Haskell to an open source club.
11:37:39 <SyntaxPolice> Smerdyakov: where is Columbus, Ohio.
11:37:58 <Riastradh> Monads are strikingly simple...they're basically a way of storing hidden data with values, retreiving the other useful data, and putting it all back together again.
11:37:59 <shapr> Smerdyakov: no, not from a theoretical basis. I can use them, but it's not the same.
11:38:05 <Riastradh> Or so I've gathered.
11:38:15 <shapr> Riastradh: that's the state monad...
11:38:22 <Riastradh> shapr - No, just any monad.
11:38:42 <shapr> I'd say it's more about subclassing the idea of 'function call'
11:38:49 <shapr> look at the Maybe monad
11:39:09 <Riastradh> '>>=' retrieves the data useful to you, and 'return' puts it all back together.
11:39:22 <shapr> what about >>= in the maybe monad?
11:39:26 <Smerdyakov> shapr, I don't know what theory there is to monads as used in Haskell, but OK. =)
11:39:47 * Riastradh isn't familiar with it.
11:39:48 * Riastradh looks it up.
11:39:55 <ibid> monads are about sequencing :-)
11:40:05 <shapr> Smerdyakov: I feel like a stone age native being given firearms... I can load the bullets and pull the trigger, but making new bullets, etc is beyond my understanding.
11:40:24 * ibid has written some monads
11:40:29 <ibid> it always warps my brain
11:40:32 <shapr> ibid: hah! I'm jealous!
11:40:41 <shapr> I *will* design my own Arrows at some point.
11:40:49 <shapr> but not this month.
11:40:52 <Igloo> My Pan stuff has a Monad for pretty much every source file  :-)
11:40:57 <Riastradh> shapr - It's the same thing -- >>= on a 'Just' calls its second argument with the useful data.
11:41:08 <Smerdyakov> Igloo, did you know that there is an old model checking program named Pan?
11:41:13 <Igloo> But they're all basically the same - pass along some state and some functions to manipulate it
11:41:33 <ibid> i think there is also a news agent called pan
11:41:42 <Igloo> No - I'm just taking the name from Conal's Pan of which mine is essentially a reimplementation
11:41:56 <Igloo> I should probably think of a new name if I want to release my stuff
11:42:06 <shapr> Riastradh: http://kungens.kemi.fi/~shae/src/haskell/ProtoMaybe.hs
11:42:39 <Riastradh> shapr - What about that?
11:43:11 <shapr> from what I understand, the z <- jz call never happens in demo2
11:43:29 <shapr> so, the Maybe type can be used instead of a big stack of if/then/else calls
11:43:30 <SyntaxPolice> I think that I understand the combinators now, but I still don't quite understand why one should use Arrows. I want to, though :)
11:44:02 <Riastradh> shapr - Yes, and that's a common use of monads, but the theory behind them is unchanged.
11:44:14 <shapr> how is that a passing of state?
11:44:22 <Riastradh> I didn't say it was passing of state.
11:44:23 <Smerdyakov> There is no theory besides the signature of the type class.....
11:44:25 <shapr> oh
11:44:25 <Riastradh> One of those other buffoons did.
11:44:49 <shapr> well
11:44:51 <shapr> ok then
11:45:00 <Igloo> My passing of state comment was refering to all the monads in my pan implementation, not all monads everywhere
11:45:07 <shapr> right
11:45:52 <Igloo> But I think all monads can do is to pass state or fail, and I think failure is optional
11:46:00 <shapr> SyntaxPolice: most understandable monad intro for me : http://www.cs.fit.edu/~satkin/monads.html 
11:46:15 <shapr> can arrows do something more?
11:46:28 <Igloo> I don't know much about arrows
11:48:57 <SyntaxPolice> shapr: arrows can do more, yes. from Hughes' paper: "to optimize a combinator library, redefinte the combinators to collect static properties of the computations they construct, and they use those static properties to optimize the dynamic computations" :)
11:49:47 <Riastradh> Where can I read about these 'arrows' things?
11:50:00 <Smerdyakov> A book of fairy tales.
11:50:01 <Smerdyakov> ;-)
11:50:50 <Riastradh> Bah.
11:50:52 <SyntaxPolice> the example in the paper is an LL(1) parser which can be represented by an arrow, where rules can be composed together in sequence or to have two options
11:51:00 <SyntaxPolice> Riastradh: check the wiki: UnderstandingArrows :)
11:51:13 <SyntaxPolice> I wrote that, but there are som elinks to ppl who know what they are talking about.
11:51:38 <shapr> I suspect the number of people who can fluently use arrows in Haskell is very very small
11:51:47 <shapr> possibly less than ten
11:51:51 <SyntaxPolice> sorry I'm not being very clear about this parser :(
11:52:01 <shapr> better than I could do ;-)
11:52:24 <shapr> the little bit that I've understood from Hughes' paper is that monads can't do anything until they've been called
11:52:35 <shapr> you have to call them with input to use them at all
11:52:57 <shapr> so, if you have multiple fall-through monads, you have to save the entire input for each of them
11:53:09 <SyntaxPolice> (so you can backtrack)
11:53:10 <shapr> at least until each possible backtrack
11:53:18 <shapr> garg01l: do you work with SyntaxPolice?
11:53:47 <shapr> so the advantage of arrows in the Hughes' paper is that you can see their static properties without calling them
11:54:06 <SyntaxPolice> shapr: or maybe you can choose which arrows to compose together based on their static properties?
11:54:17 * SyntaxPolice is curious as to why shapr thinks garg01l works with him.
11:54:25 <shapr> SyntaxPolice: you're both on #osuoss
11:55:13 <garg01l> shapr: i deny working with SyntaxPolice.  We share locale.
11:55:16 <shapr> ah, ok
11:55:41 <SyntaxPolice> shapr: yeah, #osuoss is for the Ohio State Open Source club :)
11:55:49 <SyntaxPolice> which has little to do w/ my job.
11:55:49 <garg01l> SyntaxPolice: i'll be attending your chat tomorrow eve.
11:56:02 <SyntaxPolice> garg01l: cool! Did you come to the last one? Did I meet you?
11:56:06 <shapr> so in the Hughes' paper, Swierstra and somebody pull out the static properties of some of their parser combinators, so you know ahead of time whether they might succeed
11:56:42 <shapr> one thing they make explicit is success on the empty string
11:56:54 <shapr> I forget the other stuff that is made explicit.
11:57:02 * shapr looks at the paper
11:57:18 <garg01l> SyntaxPolice: i'm not affiliated w/ osu, but wandered in due to interest in advanced programming technologies.  do live in cmh.
11:57:24 <Riastradh> @yow
11:57:25 <lambdabot> Tex SEX!  The HOME of WHEELS!  The dripping of COFFEE!!  Take me
11:57:25 <lambdabot>  to Minnesota but don't EMBARRASS me!!
11:58:21 <SyntaxPolice> shapr: I want a simpler example :-) this paper keeps pointing out weaknesses in arrows and introducing new combinators to fix those weaknesses, which doesn't exactly help in understanding when to use arrows.
11:58:31 <shapr> yah, really
11:59:02 <shapr> there was a discussion on lambda.weblogs.com that said that arrows are just monads with static type information made explicit
11:59:07 <shapr> but I don't think that's correct
11:59:10 <garg01l> SyntaxPolice: i missed the last one; calendar hiccup.  isnt tomorrow the good stuff like monads?
11:59:19 <shapr> if it were, then arrows could use the same combinators as monads, right?
11:59:23 <SyntaxPolice> garg01l: yup. thats what we were just talking about.
11:59:51 <shapr> I've read that *some* monads can be lifted to arrows
11:59:59 <shapr> or is that all?
12:00:07 <SyntaxPolice> shapr: I think they could be monads w/ static type information, but I think they are more general than that.
12:00:12 <shapr> and that either some or all arrows are automatically arrow transformers
12:00:31 <shapr> yah, I agree, they must be more general than that, otherwise they would just be extended monads
12:00:31 <SyntaxPolice> arrows are more general than monads and any monad can be implemented as an arrow, I do believe.
12:00:53 <shapr> but you can't implement all arrows as monads, which is the subject of the whole Hughes' paper
12:01:09 <Marvin--> SyntaxPolice: the famous Kleisli arrow
12:01:32 <shapr> so, *all* monads can be 'lifted' to arrows, right?
12:01:44 <SyntaxPolice> Marvin--: yes. shapr: in fact this paper constantly points out how to implement various bits of monads as arrows.
12:01:53 <Marvin--> shapr: that's my understanding of it
12:02:05 <shapr> somewhere in there it says that some/all arrows are arrow transformers...
12:02:15 * shapr looks
12:02:52 <SyntaxPolice> anyone is welcome to add insite to the wiki page on this topic: http://www.haskell.org/hawiki/UnderstandingArrows
12:03:00 <shapr> heh, cute pun
12:03:33 <shapr> insite :-)
12:03:40 * SyntaxPolice wonders if his pun was a misspelling of insight
12:04:06 <SyntaxPolice> never attribute to cleverness what can be explained by bad spelling. (or so the saying goes)
12:05:30 <shapr> one of my arrow questions is "Can I make monad transformers for free by lifting any old monad to an arrow?"
12:07:15 <shapr> y0 Vincenz 
12:07:21 <Vincenz> hi
12:07:28 <Vincenz> just came back from switzerland
12:07:36 <shapr> aha, page 25 of Hughes' draft
12:07:44 <shapr> how was Switzerland?
12:07:56 <Vincenz> good good
12:07:58 <Vincenz> very nice :)
12:08:00 <Vincenz> very tiring tho
12:08:21 <shapr> sounds like a good vacation
12:08:29 <Vincenz> 2 days :)
12:10:30 <shapr> "We note briefly that the concepts of monad transformers and functors can be formalised as classes, thereby overloading the lifting operations, but that this requires a much more powerful class system than Haskell currently supports. We therefore refrain from doing so."
12:10:31 <shapr> yow
12:10:38 <shapr> there's a hook for another research paper
12:11:08 <Vincenz> hehe :P
12:11:10 <SyntaxPolice> heh
12:13:51 <shapr> @fact monadlaws
12:13:52 <lambdabot> see leftunit, rightunit, monadassociativity
12:14:38 <shapr> anyone else looking at the arrows paper?
12:14:49 <ibid> no
12:14:50 * SyntaxPolice is looking at it.
12:14:50 <Riastradh> @fact leftunit
12:14:51 <lambdabot> return x >>= f == f x
12:14:59 <Riastradh> @fact rightunit
12:14:59 <shapr> I'm looking at the arrow laws on page 30
12:15:00 <lambdabot> m >>= return == m
12:15:10 <Riastradh> @fact monadassociativity
12:15:10 <lambdabot> m >>= (\x -> k x >>= h) = (m >>= k) >>= h
12:15:13 <shapr> what does the circle mean in the definition of f >>> g ?
12:16:00 <shapr> f >>> g = g ° f
12:16:21 <SyntaxPolice> I think its f >>> g = g . f
12:16:53 <shapr> oh
12:18:35 <SyntaxPolice> since composition of arrows that represent functions would be composition of functions :)
12:18:42 <shapr> right, that makes sense
12:18:54 <SyntaxPolice> but I haven't really read that far into the paper yet.
12:19:02 <shapr> so, monads are parameterized types, and arrows are paramterized functions?
12:21:00 <SyntaxPolice> shapr: i don't now about that. I think arrows are an abstraction of functions, though. Bascially I think you can only say that arrows represent functions and you can really only compose them or sometimes apply them, the rest is up to the implementation.
12:21:29 <SyntaxPolice> where by implementation I mean the instance.
12:21:55 <shapr> and monads are an abstraction of of types?
12:22:19 <SyntaxPolice> but in practice, you may be right that they are used as parameterized functions, but I'm not sure what you mean by that.
12:22:42 <shapr> I don't know either :-)
12:23:50 <SyntaxPolice> I keep jumping back & forth between that paper and "Arrows, Robots and Functional Reactive Programming" by Hudak, Courtney, Nilsson, & Peterson.  I seem to be making steady progress.
12:24:03 <shapr> oh, I haven't seen ARFRP
12:24:07 * shapr googles
12:25:09 <shapr> that paper isn't mentioned on the Arrows bibliography page
12:25:14 <shapr> is that the Yampa paper?
12:25:47 <shapr> oh, and monads are <- and arrows are -<
12:25:53 <shapr> cute
12:26:02 <SyntaxPolice> shapr: yeah, its the Yampa paper.
12:26:26 <Marvin--> scary, there's a Swedish hockey player that looks a lot like me
12:26:36 <kosmikus> well, it still is vague, but one can say that a monad represents "things" which can produce values of a type, whereas an arrow "represents "things" that can consume values of one type and produce values of another ...
12:27:07 <shapr> kosmikus: that makes sense... do you understand arrows?
12:27:11 <kosmikus> shapr: as to syntax, the <- represents the "production" part
12:27:21 <kosmikus> whereas the "-<" represents the consumption ...
12:27:36 <kosmikus> that's why monad syntax just uses "<-", whereas arrow syntax uses both
12:28:26 <kosmikus> "understanding" is not a function that yields a boolean value ;)
12:28:40 <SyntaxPolice> Marvin--: and here I always thought you were a Swedish hockey player.
12:29:25 <Marvin--> SyntaxPolice: er
12:29:41 <shapr> kosmikus: my floating point value of understanding is about to drown.
12:30:08 <kosmikus> sorry if I should have confused you ...
12:30:45 <shapr> nah, that's helpful, thanks
12:31:12 <shapr> a monad produces values of a single type
12:31:23 <shapr> an arrow consumes values of one type, and produces values of another type
12:31:58 <kosmikus> yes, that's at least one view on the whole thing
12:32:14 <shapr> thanks
12:32:41 <kosmikus> therefore, in monad do notation you can write "x <- action" to get at the resulting value(s) of a monadic action ...
12:33:24 <kosmikus> ... and in arrow proc notation (as proposed by Ross Paterson) you can write "out <- arrow -< in" to feed inputs into an arrow and get at the outputs.
12:33:34 <Riastradh> x <- action -< foo   -- foo is the input, action is the action, x is the output, right?
12:33:48 <kosmikus> yes
12:33:49 <Riastradh> Er, in x is stored the output.
12:35:42 <shapr> ok, time to write the first example for the arrows/ subdir in haskell-libs then
12:36:15 <shapr> lesse, what's the simplest monad examples?
12:36:41 <kosmikus> shapr: identity monad ;)
12:38:24 <kosmikus> after identify, I would say that there are three basic monad examples: exception (Maybe), state, and nondeterminism (list) ...
12:38:32 <shapr> ok
12:38:34 <kosmikus> s/identify/identity/
12:38:56 <kosmikus> for arrows, the "trivial" example is functions ...
12:39:13 <shapr> arr f = f
12:40:00 <shapr> I wonder if anyone has extended haskell-mode to deal with the arrow syntax?
12:55:11 <shapr> the yampa paper is nice
13:02:11 <Igloo> Someone dropped a hint at Simon at FoP. He then asked for suggestions on how to make it more usefriendly as people had enough trouble with monads and do syntax, but I don't think there were any real answers
13:03:01 <shapr> He also requested mdo syntax ideas
13:03:37 <shapr> I say just pass 'em as a list :-)
13:04:16 <shapr> or maybe <<- for 'fast forward'
13:04:26 <SyntaxPolice> whats mdo?
13:04:46 <shapr> it's for monads that don't need to be sequenced in relation to each other (I think)
13:04:59 <shapr> it's in HEAD, but not on ghc5.04.2
13:05:03 <shapr> maybe in ghc5.04.3
13:05:06 <shapr> I haven't checked
13:05:23 <shapr> speaking of which, I want ghc5.04.3 in debian/unstable
13:05:47 <SyntaxPolice> kosmikus: mind if I add some of your comments on arrows to the wiki?
13:06:11 <SyntaxPolice> shapr: what are you going to do about it ;)
13:06:20 <shapr> whine vociferously
13:06:58 * shapr considers trying to build a test package locally
13:07:34 <SyntaxPolice> or you could emali the maintainer.
13:07:47 <shapr> or /msg him
13:07:58 <shapr> oh, he's offline atm
13:08:01 <kosmikus> SyntaxPolice: that's fine ...
13:08:54 <kosmikus> shapr: ghc-5.04.3 is in Gentoo ;)
13:10:20 <SyntaxPolice> kosmikus: any chance you could find a simple arrow example? Is there such a thing?
13:10:45 <kosmikus> you probably mean: a simple _useful_ arrow example? 
13:10:58 <shapr> identity is just "arr f = f"  ( I think )
13:11:12 <shapr> in short, same laws apply to arrows
13:11:27 <shapr> but it has more combinators since it's a mapping rather than a producer
13:12:03 <SyntaxPolice> kosmikus: yes :)
13:12:38 <SyntaxPolice> or at least illustrative and simple.
13:12:53 * kosmikus is off looking for one ...
13:14:14 <kosmikus> shapr: what's your source for "mdo"?
13:19:04 <shapr> mostly Pseudonym
13:19:20 <shapr> though I've also seen it mentioned in the 'hair shirt' retrospective
13:19:46 <kosmikus> SyntaxPolice: at the moment only trivial (i.e. monad-) or not very simple examples come to my mind; perhaps better ask someone who actually _uses_ arrows; I never did, I am just interested in the theory a bit
13:19:58 <shapr> ok, so... arr lifts a function to an arrow
13:20:08 <shapr> arr :: (a -> b) -> SF a b
13:20:09 <SyntaxPolice> kosmikus: OK. thanks for trying :-)
13:20:31 <shapr> er, the SF is from the Yampa paper
13:20:38 <shapr> I dunno what's normally used
13:20:49 <kosmikus> normally?
13:21:05 <shapr> oh, whatever arrow type you're lifting to, duh :-)
13:21:17 <shapr> >>> composes two arrowized functions
13:21:20 <shapr> (>>>) :: SF a b -> SF b c -> SF a c
13:21:50 <shapr> just like f :: a -> b and g :: b -> c can turn into f . g :: a -> c
13:22:25 <shapr> &&& runs two arrows on the same input and returns the result as a tuple
13:23:05 <shapr> (&&&) :: SF a b -> SF a c -> SF a (b,c)
13:23:48 <shapr> *** runs a tuple of two arrows on a tuple of two inputs, and returns the result as a tuple
13:24:14 <shapr> (***) :: SF b c -> SF b' c' -> SF (b,b') (c,c')
13:24:37 <shapr> is that right?
13:24:52 * shapr isn't sure
13:25:16 <kosmikus> you've given the types specific for signal functions, but otherwise it's ok ...
13:25:41 <shapr> well, the input is actually just two functions
13:25:46 <shapr> er
13:25:52 <shapr> no
13:26:08 <kosmikus> the general type for (>>>) would be ...
13:26:48 <shapr> (>>>) :: Arrow a => a b c -> a c d -> a b d
13:26:48 <kosmikus> (>>>) :: Arrow x b c => x a b -> x b c -> x a c
13:27:02 <kosmikus> you're right
13:27:18 <kosmikus> got the class constraint wrong
13:27:40 <shapr> I'm looking at the paper at the same time, so I have an unfair advantage ;-)
13:27:51 <Marvin--> er, so  Arrow x a b  is not necessary?
13:28:13 <shapr> just Arrow a
13:28:18 <shapr> er, Arrow x
13:28:21 <shapr> in that case
13:28:35 <kosmikus> right, Arrow is a type class of kind * -> * -> * :)
13:29:30 * Marvin-- is watching Sex and the City
13:29:39 <Vincenz> Marvin--: the mind of the married men is much better
13:30:00 <Marvin--> Vincenz: never heard of
13:30:27 <debug> hm
13:30:58 <debug> Vincenz: perhaps you are mixing up the concepts 'married' and 'merry'?
13:31:09 <Vincenz> nope
13:31:11 <debug> anyway, it is a wonderful day
13:31:17 <kosmikus> didn't Ross have a few nice arrow examples in his Fun Of Programming talk, maybe also in the book; unfotunately, I have the book only at work, so I cannot check right now ...
13:31:19 <shapr> yes, though it's a bit dark now
13:31:22 <Marvin--> indeed
13:33:41 * debug is all warm and fuzzy
13:34:00 <debug> red skin caused by the irl sun
13:34:15 <debug> as opposed to the virtual in my appartment
13:37:15 <shapr> y0 Arnia 
13:38:01 <Arnia> Heya
13:38:12 <shapr> ever written any games?
13:38:30 <Igloo> :-)
13:38:51 <kosmikus> I'm away, at least for a short while ... see you around!
13:42:51 <Igloo> Does "thin interface" make sense?
13:43:03 <shapr> ?
13:43:42 <Igloo> I'm trying to describe a simple mapping of Haskell to C functions with the FFI, like my curses bindings
13:44:02 <shapr> sounds sensible to me
13:44:14 <shapr> what about 'thin wrapping' ?
13:44:20 <shapr> or 'transparent wrapping' ?
13:44:28 <shapr> if it's a direct map
13:44:54 <Igloo> I think I definitely want the word interface in there. I'll go with thin interface for now
13:45:05 <shapr> ok
13:45:14 * shapr is always ready to give random input
13:47:39 * Igloo suddenly realises quite how similar an AI for the game would be to a player (unless it needs to cheat)
13:48:55 <debug> goodnite
13:48:56 <shapr> cheating AIs are signs of wimpy programmers ;-)
13:48:58 * debug goes into debug mode
13:48:58 <shapr> g'nite delYsid
13:49:02 <shapr> er, debug 
13:49:06 <shapr> sheez, nick completion
13:49:27 <shapr> Igloo: otoh, if the AI is good enough to win, players can just steal the AI code
13:49:34 <shapr> so maybe the AI should cheat for that reason.
13:50:39 <shapr> Igloo: alternatively, maybe it should require human players? no AI at all?
13:50:46 <Igloo> Well, a scenario-style game may need the aI to react to things it couldn't otherwise
13:51:23 <shapr> ?
13:51:24 <Igloo> Also, I went to an interesting talk by a games company based around here, and they put forward the view that there was nothing wrong with the AI cheating as long as the user couldn't tell and it made it more enjoyable
13:51:39 <shapr> that's a good point
13:51:50 <shapr> when we play warcraft III, we can tell the AI is cheating
13:52:43 <Igloo> What does it do?
13:53:27 <shapr> in wIII, you have three special units, heroes, they need to win battles against other units to gain experience and levels and powers
13:53:52 <Igloo> Ah, and they immediately have them?
13:54:00 <shapr> the computer knows where all the NPC monsters are on the map, and kills them in the correct order mostly
13:54:04 <shapr> so it levels up quickly
13:54:10 <Igloo> Oh, right
13:54:25 <shapr> but we have to slowly explore the map, and usually we just find empty spots where the computers has already been
13:54:54 <shapr> it's very irritating
13:55:21 <Igloo> Are they always the same?
13:55:43 <shapr> the NPC monsters are always in the same spots each time you play the map
13:56:01 <shapr> so I guess it'll be okay once we know the maps
13:56:13 <shapr> but it's only the second day we've played wIII :-)
13:56:19 <Igloo> OK, so you can learn too, and once you do it'd effectively be you cheating if the computer didn't know
13:56:27 <Igloo> :-)
13:56:28 <shapr> good point
13:56:33 <shapr> I hadn't thought of it that way.
13:56:42 <shapr> the computer is just acting like an experienced player.
13:57:02 <Igloo> It would be better if they were randomly placed within some constraints and the AI only knew the constraints
13:57:17 <shapr> yah, I agree
14:00:10 * Igloo tries to focus his mind back on what he *should* be doing  :-)
14:07:46 <shapr> hej andersca 
14:08:01 <andersca> hej sha
14:08:02 <andersca> pr
14:08:09 <shapr> hur är det med dig?
14:08:09 <andersca> (stupid keyboard :(
14:08:12 <andersca> :) even
14:08:28 <shapr> trivs du med kinesis?
14:08:36 <andersca> jag tror det
14:08:42 <shapr> yay!
14:09:15 <debug> shapr: trivs du med en kines?
14:09:28 <shapr> ja!
14:09:59 <shapr> jag köper kinesis tre år sedan
14:10:08 <debug> what?
14:10:13 <debug> ok
14:10:22 <debug> :)
14:10:23 <shapr> did I say that correctly?
14:10:30 <debug> not really
14:10:37 <shapr> what would be correct?
14:10:45 <shapr> "I bought a kinesis three years ago"
14:10:54 <debug> either "jag köpte en kinesis för tre år sedan"
14:10:58 <shapr> I wanted to say "I have had a kinesis for three years"
14:11:00 <debug> well, just that.
14:11:00 <debug> hm
14:11:08 <shapr> but I don't know the imperfekt of "to have"
14:11:08 <debug> "jag har haft kinesis i tre år"
14:11:32 <shapr> jaså
14:11:34 <shapr> tack
14:11:40 <debug> but I asked something else
14:11:42 <debug> :)
14:11:57 <shapr> good point
14:12:08 <debug> trivs du med en kines?  ==  do you feel comfortable with a chinese?
14:12:14 * shapr laughs
14:12:16 <debug> hehe
14:12:35 <shapr> I read "kinesis"
14:12:53 <shapr> ja, jag trivs med en kines. och du?
14:13:11 <debug> visst
14:13:12 <debug> :)
14:13:18 <debug> men jag sover egentligen
14:13:25 <debug> so goodnite again
14:13:38 <shapr> sov gut!
14:13:46 <andersca> http://www.guadec.org/schedule/
14:22:40 <shapr> hi jao
14:22:50 <jao> hey shapr
14:22:53 <shapr> what's up?
14:23:06 <jao> just lurking a bit :)
14:24:24 <shapr> you missed a fun discussion on monads/arrows a bit earlier
14:24:31 <shapr> I'm still reading the Yampa paper
14:25:15 <jao> hm. interesting: i'll read the logs
14:48:54 * shapr bounces happily
14:49:20 <Igloo> Oh?
14:49:28 <shapr> yah, new haskell-libs developer
14:49:37 <andersca> who?
14:49:40 <shapr> nibro
14:49:53 * shapr has been recruiting on #haskellwars
14:50:33 <Marvin--> ... #haskellwars?
14:50:54 <andersca> yo marvin
14:51:04 <shapr> Igloo: seems haskellwars is about turning the Yampa robots into a corewars contest
14:51:25 <shapr> Marvin--: see haskellwars.com
14:51:32 <Igloo> Is Yampa an FRP thing?
14:51:36 <shapr> yup
14:51:44 <shapr> Yampa is the latest in FRP I think
14:52:34 <Marvin--> shapr: yay, corewars
14:53:16 <shapr> Marvin--: did you see the RTS idea Igloo and I were talking about earlier?
14:53:22 <Marvin--> no
14:53:40 <Marvin--> I've been busy fighting with d-i today
14:53:50 <shapr> real-time strategy game where you program your units with strategy combinators
14:54:07 <shapr> Igloo had a bunch of very cool ideas I hadn't thought of
14:54:22 <Igloo> shapr, can you send me an example program you might write with the combinators?
14:54:23 <Marvin--> interesting
14:54:29 <shapr> Igloo: sure!
14:54:38 <shapr> Marvin--: Igloo's idea would put this game halfway between RTS and corewars
14:55:08 <Marvin--> shapr: when you said RTS I thought you meant Run-Time System, heh
14:55:37 * Marvin-- bought a real-time card game yesterday
14:56:13 <shapr> are there non-real-time card games?
14:56:26 <Marvin--> most card games are turn-based
14:56:29 <Marvin--> this one isn't
14:56:35 <shapr> oh! neat!
14:57:03 <Marvin--> you sit trading cards all at the same time and have rules for when you get to draw cards
14:57:10 <shapr> interesting
14:57:18 <shapr> what's the name?
14:57:32 <Marvin--> when the deck is all out, you don't even shuffle the discard pile, you just turn it upside down, just so nobody get extra time to think :)
14:57:38 <shapr> heh, cool
14:57:38 <Marvin--> Nodwick - The Card Game
14:57:52 <Marvin--> it's about piecing together a henchman from spare parts as fast as possible
14:58:12 <Marvin--> (a henchman, as everybody know, consists of a head, a torso, arms, legs, a spirit - and a spleen)
15:00:10 <Marvin--> to play the body parts you need other cards, duct tape, happy thoughts, life-force kick start, et.c.
15:00:19 <shapr> sounds nifty
15:00:28 <Marvin--> very, I played it once, and then bought it :P
15:02:16 <shapr> that's a good recommendation
15:03:48 * Marvin-- is bringing it to uni tomorrow to see if anybody wants to play over lunch :P
15:04:41 <andersca> sounds like fuyn
15:05:00 <andersca> gar, stupid keyboard :)
15:05:50 <Marvin--> of course, it's even more fun if you read the nodwick comic
15:20:30 <delYsid> shapr: checked in
15:20:59 <Igloo> Oh, does that mean you got our connectivity sorted, del?
15:21:06 <delYsid> yup
15:21:11 <Igloo> Cool  :-)
15:21:19 <delYsid> and the stack-overflow bug is still there.
15:21:23 <delYsid> no matter what I do
15:21:41 <Igloo> :-(
15:21:51 <shapr> delYsid: yay code!
15:22:00 <Marvin--> ls: /org/ftp.debian.org/ftp/: Input/output error
15:22:01 <Marvin--> oh dear
15:22:09 <shapr> ?
15:22:14 <delYsid> but current checked in version has castle moves commented, so it works without overflows.
15:22:20 <Marvin--> NFS problems on the debian machines somewhere
15:22:29 <shapr> delYsid: cooool
15:23:21 * hdaume just submitted his paper.  time to celebrate :)
15:23:30 <shapr> yay!
15:23:33 <Igloo> Lucky  :-)
15:23:36 <shapr> hdaume: what's your paper about?
15:23:42 <Igloo> Well, hardworking actually I guess  :-)
15:23:45 <Igloo> Where'd you submit to?
15:24:31 <tic> hey, any of you tried the OQO?
15:24:48 <shapr> what's OQO?
15:24:49 <hdaume> automatically inducing paraphrase templates from text (i.e., something like "X costs Y" <--> "pay Y for X", or "X did Y" <--> "Y was done by X")....submitted to a workshop associated with our major conference
15:25:15 <hdaume> it is my last ditch effort to get something published this year so i can go to japan :)
15:25:44 <Marvin--> hdaume: heh
15:26:32 <delYsid> shapr: cvs up; make; ./play
15:26:42 <tic> shapr, http://www.linuxdevices.com/news/NS4054087444.html
15:27:02 <hdaume> where can i find a good reference on how to write makefiles (i've never written one :P)
15:28:21 <shapr> tic: that's awesome
15:28:31 <Igloo> Do you need to do anything complicated?
15:28:35 <Igloo> Basically it's
15:28:39 <hdaume> Igloo: nope
15:28:43 <Igloo> target: dependency1 dependency2
15:28:47 <Igloo> <tab>first line to do
15:28:51 <Igloo> <tab>second line to do
15:29:05 <tic> shapr, yeah
15:29:19 <Igloo> e.g.
15:29:19 <tic> shapr, www.oqo.com, scheduled for release in q2 2003 or so
15:29:19 <tic> .
15:29:22 <Igloo> foo.o: foo.c
15:29:35 <Igloo> <tab>gcc -c $< -o $@
15:30:00 <Igloo> (those are the 2 most common automatic variables)
15:30:15 <shapr> tic: wow, I want one.
15:30:30 <tic> shapr, yup, me too. I'd sell my soul for an OQO and unlimited GPRS :P
15:30:34 <shapr> I could fit that and some extra batteries into my kinesis keyboard easily
15:30:37 <hdaume> k cool...thanks
15:30:44 <Smerdyakov> Igloo, does "automatic" here have any connection to automatic variables in C, or is it a coincidence?
15:31:17 <Marvin--> hdaume: $< is the first dependency, $@ is the target... info make has more info
15:31:31 <hdaume> ok
15:31:41 <Igloo> Remind me what they are in C?
15:31:42 <Marvin--> GNU make has $^ for all dependencies
15:31:49 <tic> shapr, fit the oqo?
15:31:55 <Marvin--> Igloo: "put these in registers" iirc
15:31:59 <Marvin--> no, wait
15:32:00 <Igloo> Oh, the other thing you need to know is that make will eat your soul
15:32:02 <Smerdyakov> Igloo, local variables, indicated by the 'auto' keyword, which no one uses anymore. =)
15:32:08 <Marvin--> right
15:32:14 <Marvin--> the opposite of static
15:32:17 <Igloo> coincidence
15:32:45 <Igloo> I also may have got the wrong term
15:32:59 <Igloo> These are just variables whose value is automatically filled in for you
15:33:07 <Smerdyakov> shapr, you don't want that oqo! It run Windows XP!
15:33:51 <Smerdyakov> Hm. I'm moving near the company that makes those.
15:35:22 <shapr> Smerdyakov: it's also runs linux
15:35:29 <Smerdyakov> Oh. Good.
15:36:03 <Smerdyakov> I really want a device that works well for reading books.
15:36:14 <Smerdyakov> Being able to store lots of music on it would be a plus.
15:37:11 <tic> laptops sucks if you're on the go, 'cause you need to unfold them, you need a lap and two hands to operate it efficiently. the oqo you can just use right away, with only one hand (more or less), and while even walking. no need to put it down.
15:37:22 <tic> and when you're at home you can just plug it in to your bigger screen.
15:39:48 <delYsid> hmm, Move.hs:108: If I uncomment this line, stack explodes.  Does anyone have an idea why this could happen?
15:40:39 <shapr> delYsid: I don't understand the code enough yet
15:40:56 <Igloo> Is it viewable on the web?
15:41:12 <delYsid> cvsweb of haskell-libs/chess
15:41:37 <Igloo> @source
15:41:37 <lambdabot> Sorry, I don't know the command "source", try "lambdabot: @listcommands"
15:41:40 <Igloo> @fact source
15:41:40 <lambdabot>  http://sf.net/projects/haskell-libs/, http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/lambdabot/
15:41:55 <shapr> delYsid: can you get castlemoves  to work on any board at all?
15:42:11 <delYsid> shapr: sure
15:42:35 <delYsid> *Move> castlemoves White cBoard
15:42:35 <delYsid> [g1]
15:42:52 <delYsid> cBoard is a testBoard which allows white and black to castle
15:45:46 <Igloo> delYsid: Is that fold in castlemoves the same as catMaybes :: [Maybe a] -> [a]?
15:46:21 * shapr bounces happily
15:46:27 <shapr> hm
15:46:29 * Igloo can't immediately see the problem and should be doing other things
15:47:11 <delYsid> catMaybes?
15:47:38 <Igloo> It's in the Maybe module - does what the type suggests
15:47:41 <shapr> it turns a list of [Maybe a] into a list of [a]
15:47:53 <delYsid> filtering all nothings?
15:47:59 <shapr> I think so
15:48:22 <Igloo> Yup - if you think about it there's nothing else it could really do
15:48:57 <Marvin--> Igloo: 'course it can :)
15:48:59 <hdaume> grr...i didn't even know about catMaybes.  i always used mapMaybe id :)
15:49:22 <delYsid> ok
15:49:39 * Igloo twonks Marvin  :-)
15:50:04 * Igloo wonders if I missed shaprs program or if he's doing other things first
15:50:23 <shapr> nah, my program is getting larger quickly =)
15:50:34 <shapr> 57 lines so far
15:50:35 <Igloo> Ah, OK, excellent  :-)
15:50:46 <shapr> I'm having to write more and more code as I have new ideas...
15:50:52 <delYsid> White to move:
15:50:52 <delYsid> e2-e4
15:50:53 <delYsid> Stack space overflow: current size 1048576 bytes.
15:50:53 <delYsid> Use `+RTS -Ksize' to increase it.
15:50:55 * delYsid glares
15:51:05 <shapr> delYsid: can you profile it?
15:51:23 <Igloo> del: Or use trace to show the castling move lists
15:51:32 <delYsid> trace?
15:52:05 <Igloo> If we have an embedded Haskell interpretter we can probably use the combinators to hide the fact it's monadic and have IO in the monad to get randomness
15:52:38 <Igloo> trace :: String -> a -> a, trace s x prints s when it is evaluated and then returns x
15:52:54 <Igloo> But it can get confusing due to the evaluation order of lazy evaluation
15:53:01 <Marvin--> observe is cute too
15:53:11 <shapr> what's observe?
15:53:29 <Marvin--> same type signature, basically the same thing, I think
15:53:45 <Igloo> Would it be foolish of me to ask the difference?  :-)
15:53:53 <Marvin--> I don't know what trace does :)
15:54:38 <Igloo> Errr, what I said up there  :-)
15:55:13 <Marvin--> if you have an IO action m with calls to observe inside it
15:55:33 <delYsid> oh fuck! I think I have a loop
15:55:35 <Marvin--> just evaluating m will proceed as usual, but evaluating runO m will evaluate and print the messages
15:55:46 <Marvin--> it prints the string and the partially evaluated value
15:56:06 <Marvin--> filling in _:s for non-evaluated sub-values
15:56:23 <Marvin--> so if you're observing a length function, it can print things like _ : _ : _ : _
15:56:25 <Igloo> Oh, neat
15:56:33 <Marvin--> very neat
15:56:52 <Marvin--> I don't have a *clue* how it works :P
15:56:59 <Marvin--> probably some really really nasty unsafePerformIO things
15:57:13 <Marvin--> s/nasty/clever/ if you like :)
15:58:12 <delYsid> hmm, no loop...
15:58:16 <Igloo> Well, it sounds like it has to be built into the implementation
15:59:26 <Marvin--> http://www.haskell.org/hood/downloads/hugs/Observe.lhs
16:03:48 * shapr tries to beat delYsid's code
16:07:45 <jao> shapr: where can i find the Yampa paper?
16:09:00 <shapr> @fact yampa
16:09:00 <lambdabot> Nothing
16:09:09 <shapr> @fact yampa http://www.haskell.org/yampa/
16:09:10 <lambdabot> set yampa to http://www.haskell.org/yampa/
16:09:20 <jao> thanks!
16:09:25 <shapr> sure, np
16:11:38 <Marvin--> Igloo: cool stuff, huh? :)
16:13:07 * Igloo only scanned it and decided I don't have time to read it properly now
16:16:23 <Marvin--> heh
16:16:26 <Marvin--> I'm off to bed
16:18:00 <Arnia> Yampa = COOOOOOOOOL
16:22:21 <shapr> y0 pesco 
16:22:30 <pesco> hey shapr!
16:22:45 <pesco> Guess what, I met mgoetze in person today!
16:23:37 <Smerdyakov> Oh, I thought you said "in prison."
16:23:45 <pesco> er.
16:24:10 <Arnia> Hmm
16:24:45 <shapr> pesco: nifty!
16:25:21 <pesco> shapr: I'm writing a network traffic visualizer in Haskell.
16:25:48 <Igloo> Oh, cool
16:25:58 <Igloo> Will it know about common protocols?
16:26:44 <pesco> Igloo: Maybe later.
16:27:55 <pesco> Primarily, I want to implement spring-based graph layout.
16:28:05 <Igloo> *nod*
16:28:40 <pesco> Right now I'm a bit puzzled because it seems to forget to draw the edges when I pass it real traffic.
16:29:24 <pesco> It did draw them when I used my prototype "fake traffic" generator.
16:31:27 <Igloo> Heh
16:43:24 <pesco> Ok, I need sleep...
17:01:34 <delYsid>     failed to load interface for `Maybe':
17:01:34 <delYsid>         Could not find interface file for `Maybe'
17:01:36 <delYsid> ?
17:02:05 <shapr> import Data.Maybe
17:02:12 <shapr> or, -package data
17:02:19 <Igloo> Maybe is H98 isn't it?
17:02:20 <shapr> delYsid: your code is smarter than my brain
17:02:52 <Igloo> Yes, it is - what's giving you that error, del?
17:03:19 <delYsid> ah
17:03:21 <shapr> er, I think your code just persuaded a pawn to jump two spaces to take my bishop
17:03:26 <delYsid> if I use -prof, it doesnt seem to find them
17:03:40 <delYsid> hmm, how would I go about finding this stack overflow?
17:03:48 <Igloo> Ah, you need profiling versions of the libraries installed
17:04:53 <delYsid> shapr: If you can, reconstruct the position, and call legalMovesFor c bd
17:05:02 <delYsid> on that position to see if it really generates an invalid move
17:05:56 <shapr> ok
17:39:57 * Igloo sends off what I'm working on to Oege and doesn't know whether to get distracted by crypto stuff or game stuff  :-)
19:25:02 <witten> I've got an infinite "2d" list (an infinite list of infinite lists). what I want to do is take a 5x5 chunk of this 2d list. how might I do that?
19:25:25 <Smerdyakov> The same was as you would with a finite list.... do you know how to do that?
19:25:34 <witten> yeah
19:25:50 <witten> take 5 finite_list
19:26:08 <Smerdyakov> witten, then you're set.....
19:26:20 <witten> I'm getting tripped up on the fact that it's a list of lists though
19:26:54 <Smerdyakov> How would you take a 5x5 chunk from a finite list of finite lists?
19:27:25 <witten> Smerdyakov: hmmm..
19:29:51 <Smerdyakov> Stuck?
19:29:57 <witten> get_chunk source w h    = map (take w) (take h source)
19:30:06 <Smerdyakov> Great =D
19:30:09 <Smerdyakov> Now you're done!
19:30:19 <witten> hmm
19:30:58 <Smerdyakov> Do you still have some problem?
19:31:37 <witten> well
19:32:28 <witten> get_chunk is of type [[a]] -> Int -> Int -> [[a]] or something like that
19:33:03 <witten> a in this case is a Char, so [[a]] is really [String]
19:33:19 <Smerdyakov> OK. Is that bad?
19:33:21 <witten> I want to print out the list of Strings, one string per line
19:33:26 <witten> not quite sure how to do that
19:33:35 <Smerdyakov> Do you know how to print one string?
19:33:39 <witten> yah
19:33:43 <witten> just use tail recursion?
19:33:48 <Smerdyakov> Do you know what >> is?
19:33:53 <witten> yeah
19:34:03 <Smerdyakov> So you should be set to do it.
19:34:07 <witten> hmm ok
19:34:44 <Smerdyakov> I.e., you can turn each string into an IO action that prints the string, and then combine them with >>.
19:34:58 <witten> ok thanks
19:35:15 <Smerdyakov> Or just make one long string with newlines in it. =D
19:40:07 <witten> thanks for the help
19:40:09 <witten> I appreciate it
19:40:14 <witten> haskell is a little weird, but fun
19:40:59 <witten> it seems like there should be some sort of "join" function
19:41:20 <Riastradh> 'join' function?
19:41:58 <witten> yeah, which would join a list of strings into a big long string, possibly using some char as a delimeter
19:42:05 <witten> lots of scripting languages have something like that
19:42:55 <witten> e.g. string.join() in python or join()/implode() in php
19:44:03 <Riastradh> @type concat
19:44:04 <lambdabot> concat :: [[a]] -> [a]
19:44:10 <Riastradh> That should do what you want, I believe.
19:44:13 <witten> cool, thanks!
19:45:04 <Riastradh> join c = concat . intersperse c   -- if you need to put a char between all the others, too.
19:45:17 <Riastradh> Er, no, if you need to put a string between all the others.
19:46:31 <Riastradh> let join s = concat . intersperse s in join ", " ["foo", "bar", "baz"]  -- returns: "foo, bar, baz"
19:46:44 <witten> nice
19:51:30 <witten> join_strings chunk sep          = concat (intersperse sep chunk)
19:51:58 <Smerdyakov> If you switched the parameter order, you could use Riastradh's shorter definition. =)
19:52:56 <witten> hm
19:53:39 <witten> ahh.. (.) is function composition.. forgot that
19:53:40 <Riastradh> Mine illustrates the cool functional bits of Haskell.
19:57:00 <Riastradh> Also, the '_strings' part is kind of silly in yours -- yours will work on any type of list, just like mine.
19:57:24 <witten> oh, right
19:57:36 <witten> yay for genericity
19:57:53 <witten> join sep                        = concat . intersperse sep
19:58:17 <Smerdyakov> witten, good work; you copied what was written above ;-)
19:58:25 <witten> hehe thanks :P
19:58:38 <witten> but at least I understand it now
19:59:10 <Riastradh> Also understand that it uses currying.
19:59:20 <witten> yeah
20:04:42 <witten> thanks again
