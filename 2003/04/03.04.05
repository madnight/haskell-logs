00:04:28 <noodle> :(
00:04:29 <noodle> findBlankLines :: [[a]] -> [ListIndex]
00:04:30 <noodle> -- findBlankLines xss returns a list containing the indices
00:04:30 <noodle> -- of the elements of xss that are empty
00:04:30 <noodle> findBlankLines xss = [ k | k <- [ 0 .. length xss - 1 ] , xss !! k == [] ]
00:04:36 <noodle> ^what is wrong with that?
00:04:44 <noodle> type ListIndex = Int
00:05:18 <noodle> if i don't put the line "findBlankLines :: [[a]] -> [ListIndex]", then haskell does everything fine
00:05:24 <noodle> but if i do, it complains 
00:05:40 <Marvin--> You need   Eq a => [[a]] -> [ListIndex]
00:05:44 <Marvin--> since you're using  ==
00:06:08 <noodle> hmm can u explain further Marvin?
00:06:27 <Marvin--> noodle: type classes, it's how overloading works in Haskell
00:06:40 <Marvin--> noodle: Eq is the type class containing   ==  and  /=
00:06:56 <noodle> ok..
00:07:05 <Marvin--> and   Eq a => [[a]] ...   means "list of list of any a that has == defined"
00:08:07 <noodle> so i have to put the line "type Eq a => [[a]] -> [ListIndex]" somewhere in my code?
00:08:15 <Marvin--> no
00:08:21 <Marvin--> Eq a =>  is part of the type signature of the function
00:08:30 <Marvin--> findBlankLines :: Eq a => [[a]] -> [ListIndex]
00:08:42 <noodle> i see
00:08:50 <Marvin--> the left-hand side of the => is called the context
00:09:08 <Marvin--> in your particular case you can do away with the equality and use pattern matching instead
00:09:30 <noodle> but my assignment specifically states that "findBlankLines :: [[a]] -> [ListIndex]" has to be stated explicitly as shown
00:09:42 <Marvin--> then you need to use overloading instead
00:09:47 <Marvin--> ertr
00:09:52 <Marvin--> pattern matching, not overloading
00:09:56 * Marvin-- just got up :)
00:09:59 <noodle> lol
00:10:11 <noodle> well can u pm me
00:10:25 <Marvin--> no, I don't want to do your homework for you :)
00:10:27 <noodle> caus i'm not meant to paste my code anywhere, just incase.. ;(
00:10:30 <noodle> lol
00:10:47 <noodle> thx neway i'll google it
00:11:18 <Marvin--> well, pattern matching is simple, look at the 'null' function
00:11:28 <noodle> yes what about it
00:11:41 <Marvin--> look at what it does
00:11:46 <noodle> k
00:11:47 <Marvin--> and how
00:15:32 <noodle> hmm
00:15:52 <noodle> i got it by doing null (xss !! k)
00:16:05 <noodle> which doesn't use ==
00:16:11 <Marvin--> exactly
00:16:15 <noodle> :(
00:16:19 <Marvin--> isn't that good?
00:16:24 <noodle> no..
00:16:33 <noodle> caus y doesn't haskell let me use ==?
00:16:49 <Marvin--> it does, but then it doesn't work for *all* lists
00:16:58 <Marvin--> it only works for comparable lists
00:17:10 <noodle> ok continue
00:17:20 <Marvin--> which is why you need the context Eq a
00:17:39 <Marvin--> it means "this works for all lists of lists of a where a can be compared for equality"
00:17:40 <noodle> so [a] == [] cannot be compared??
00:17:49 <Marvin--> not unless a is in Eq, no
00:18:02 <noodle> i see
00:18:21 <Marvin--> pattern matching is also more efficient, so be happy ;)
00:18:26 <noodle> ok
00:18:30 <noodle> but the thing is
00:18:34 <noodle> in a written test
00:18:37 <noodle> i wouldn't know about this
00:18:45 <noodle> caus i have no means to check
00:18:53 <Marvin--> then you need to learn more about overloading
00:18:58 <Marvin--> and pattern matching
00:19:03 <noodle> yes ;)
00:19:23 <noodle> same with `div` and /
00:19:25 <noodle> :(
00:20:58 <Marvin--> yes, they are all overloaded, just like in other languages
00:21:28 <noodle> k
00:21:37 <noodle> well now to question 2
00:21:41 <noodle> (on assignment)
00:21:48 <noodle> i will be idling here
03:13:24 * shapr awakens
03:13:28 <shapr> goood morning #haskell!
03:14:26 <Vincenz> shapr!
03:14:36 <shapr> y0 Vincenz, wasssup?
03:15:00 * Arnia bounces
03:15:05 * shapr boings
03:15:06 <Vincenz> nothing much, going to help someone with his matlab code for his thesis
03:15:13 <Vincenz> He's asking my expert advice :)
03:15:36 <shapr> are you a matlab expert?
03:15:46 <Vincenz> I'm good at algorithms in computer vision :)
03:15:55 <shapr> neat
03:16:25 <Vincenz> he has to segment a tumor in a 3d mri-dataset
03:17:09 <shapr> sounds like fun
03:17:31 <shapr> I'm going to try to finish the mailing list searcher plugin today
03:18:04 <Arnia> Whee :)
03:19:01 <shapr> it only does maildir searching, but I suspect the raw haskell mailing list archives are mbox format
03:19:23 * Marvin-- sighs
03:20:01 <Marvin--> sure, the 2.4 linux console supports utf-8, but there doesn't seem to be any terminfo for it
03:20:03 <Marvin--> at least not in debian
03:23:27 <shapr> sunny and blue skies today
03:23:37 <shapr> makes me wish I had a laptop so I could code outside =)
03:23:46 <andersca> isn't it windy?
03:23:58 <shapr> I can't tell from here.
03:24:06 <shapr> it was very windy yesterday
03:24:59 * Riastradh sploofs.
03:25:17 <Arnia> It isn't windy here... which is surprising
03:25:49 * shapr explorbs
03:26:02 <shapr> hi Riastradh!
03:26:25 <shapr> Riastradh: hey, have you checked in the new module typeclass?
03:27:27 <Riastradh> No, not yet.
03:27:38 <shapr> yay, haskell-libs is at 89% activity, and we've had six downloads!
03:29:08 <pesco> *g* We're driving the open source revolution.
03:29:31 <shapr> yah!
03:29:57 <shapr> pesco, Riastradh: I think we need to explicitly give copyright and license for our sources
03:30:05 <pesco> Bah!
03:30:05 * Riastradh was too busy working on his Lambda-Calculus stuff last night.
03:30:59 <shapr> even if it's just one line in AUTHORS saying "my code is released under lGPL/GPL/BSD" or whatever
03:30:59 <pesco> shapr: Why? So IBM doesn't steal lambdabot and makes a fortune with it?
03:31:24 <Riastradh> OK, GHC doesn't like my definition of 'doHooks':
03:31:40 <Riastradh> doHooks f msg =  -- f is a hook function
03:31:42 <Marvin--> pesco: no, so that it can be released at all
03:31:43 <Riastradh>     do s <- get
03:31:46 <shapr> pesco: right, we want to fund the Simon&Simon research foundation instead ;-)
03:31:53 <Riastradh>        doHooks' . eltsFM $ ircModules s
03:31:55 <Riastradh>     where
03:32:00 <Riastradh>     doHooks' [] = return ()
03:32:07 <Riastradh>     doHooks' (x : xs) =
03:32:11 <Riastradh>         do f x msg
03:32:14 <pesco> Marvin: What do you mean? I can't give people code if I don't stamp it with a license?
03:32:17 <Riastradh>            doHooks' xs
03:32:45 <Marvin--> pesco: yes you can, but they can't redistribute it unless you give them explicit permission to
03:32:47 <Marvin--> i.e. a license
03:33:07 <shapr> yah, explicit license would mean I could make a lambdabot Debian package.
03:33:19 <Riastradh> I vote for the BSD license.
03:33:23 <shapr> well, explicit DFSG compatible licensing.
03:33:37 <shapr> Marvin--: BSD fits into debian, right?
03:33:44 <pesco> Yes.
03:33:56 <Marvin--> I vote for LGPL
03:33:57 <pesco> I like the MIT license.
03:33:59 <Marvin--> if I have a vote
03:34:08 <shapr> I prefer LGPL also
03:34:13 <Riastradh> Blah.
03:34:25 <pesco> The way I read MIT it says "This is my code, but if you manage to steal it, you can keep it"
03:34:42 <pesco> I like cleptocracy.
03:35:01 <shapr> lambdabot was entirely BSD when first checked into CVS
03:35:17 <shapr> pesco: I think it's klepto
03:35:19 <andersca> we have such cool function names in d-bus
03:35:28 <shapr> andersca: like what?
03:35:31 <andersca> void _dbus_babysitter_kill_child (DBusBabysitter *sitter);
03:35:36 <shapr> yow
03:35:37 <shapr> scary
03:35:41 <pesco> shapr: Oh, you mean not all k's become c in english?
03:35:58 <shapr> nope, not all. klepto is greek or something
03:36:04 <pesco> I guess.
03:36:05 <Riastradh> pesco - No, that Webster bastard didn't get that far.
03:36:10 * shapr grins
03:36:12 <Marvin--> heh
03:36:14 <pesco> heh
03:36:32 <Marvin--> pesco: with "MIT" license, do you mean the X11 license?
03:36:39 <Marvin--> there are several MIT licenses
03:36:53 <pesco> Marvin: Oh, there are? I probably meant X11.
03:37:30 <Marvin--> "This is a simple, permissive non-copyleft free software license, compatible with the GNU GPL. XFree86 uses the same license. This is sometimes called the "MIT" license, but that term is misleading since MIT has used many licenses for software."  (from gnu.org)
03:37:43 <pesco> oic
03:37:59 <Riastradh> Hmm, isn't beta reduction just alpha reduction, but with any value instead of variables?
03:38:07 <pesco> ppclamb: @type (>>=)
03:38:14 <shapr> ??
03:38:20 <pesco> ppclamb: @type foldr
03:38:21 <shapr> pesco: did you write a haddock plugin?
03:38:22 <ppclamb>   foldr :: (a -> b -> b) -> b -> [a] -> b
03:38:28 * shapr bounces
03:38:29 <shapr> oh oh
03:38:31 <shapr> how did you do that?
03:38:38 <Marvin--> pesco: neato :)
03:38:43 * pesco grins mysteriously
03:38:48 <shapr> ppclamb: @type map
03:38:49 <ppclamb>   map :: (a -> b) -> [a] -> [b]
03:38:53 * andersca boings
03:39:01 <Marvin--> ppclamb: @type (+1)
03:39:05 <Marvin--> bah
03:39:10 <Marvin--> ppclamb: @type +
03:39:17 <Riastradh> ppclamb: @type (map succ)
03:39:18 <ppclamb>   map succ :: Enum a => [a] -> [a]
03:39:22 <Riastradh> Cool!
03:39:34 <Marvin--> but it doesn't handle operators?
03:39:41 <Marvin--> ppclamb: @type map (+)
03:39:47 <Marvin--> ppclamb: @type (map (+))
03:39:51 <pesco> Behold the power of the shell: echo ':t foldr' | hugs '-p  ' | grep -E '^  foldr :: '
03:39:52 <shapr> ppclamb: @type neg
03:40:02 * pesco laughs manically
03:40:06 <shapr> pesco: nice
03:40:17 * Riastradh pokes someone about his question about alpha and beta reduction.
03:40:44 <shapr> Riastradh: I used to do radiation safety, you need some help? ;-)
03:40:53 <Riastradh> Heh.
03:41:12 <Marvin--> oh, need escaping on the parentheses
03:41:14 <pesco> ppclamb: @type (>>=)
03:41:32 <pesco> Hrm?
03:41:39 <Marvin--> you need  echo ':t (>>=)' | hugs '-p ' | grep -E '^ \(>>=\) :: '
03:41:49 <pesco> Ugh
03:42:12 <Marvin--> or be lazy and just grep for ' :: ' *cough*
03:42:31 <pesco> No, I'll ditch grep and find the line in haskell.
03:47:10 <shapr> Arnia: do you know if the example from Hughes' first paper have been transcribed into the latest arrow notation?
03:47:33 <shapr> "examples"
03:47:40 <andersca> time to check out how much rhl9 rocks
03:47:48 <shapr> what's rhl9?
03:49:03 <Arnia> shapr: Don't think so... could email him?
03:49:04 <andersca> red hat linux 9
03:50:05 <Marvin--> andersca: how well does utf8 work in the console on RH?
03:50:32 <andersca> lemme try some funky stuff
03:50:42 <Igloo> You don't want to pass operators to grep, they might contain RE special chars
03:50:43 <Marvin--> e.g. if you run http://193.11.232.159:8080/border.py in the console, do you get a border?
03:51:21 <Marvin--> yeah
03:52:19 <andersca> Marvin--: works in gnome-terminal, not in the console
03:52:32 <shapr> Arnia: or I could just transcribe them
03:52:41 <shapr> assuming I can figure out the latest notation
03:53:09 <Marvin--> andersca: well of course it works in X... damn, we need working UTF8 in the console for d-i
03:53:29 <Marvin--> wonder how anaconda does that
03:53:31 <Arnia> shapr: Yeah, probably easiest
03:56:41 <Janni> hi
03:56:54 <shapr> y0
03:57:00 <shapr> lambdabot: @quit
04:03:43 <Arnia> shapr: Show off ;)
04:03:48 <shapr> :-)
04:03:57 <shapr> I was just rebuilding with -O2 to see if lambdabot is any faster
04:04:16 <Arnia> shapr: And?
04:04:26 <shapr> I think it is
04:04:44 <shapr> seems to respond a lot faster
04:04:46 <Riastradh> Well, duh!  The compiler made it faster because you told it to.
04:05:11 <shapr> I didn't know if the irc lag times would mean -O2 was unimportant
04:05:19 * Arnia bounces and thinks about a haskell equivalent to Zope
04:05:24 <shapr> Arnia: yes!
04:05:33 <shapr> let's integrate HWS-WP and lambdabot 
04:06:54 <Arnia> Once we have the arrows component framework :)
04:19:14 <shapr> pesco: whoops
04:20:07 * pesco mumbles
04:20:37 <shapr> I think I crashed ppclamb 
04:20:46 <shapr> lambdabot: @karma lambdabot 
04:20:46 <lambdabot> lambdabot has a karma of 0
04:20:54 <pesco> What did you tell it?
04:21:11 <shapr> @type neg, @type plus, @type mplus
04:21:31 <shapr> it didn't actually respond to any of them
04:21:43 <pesco> 14:18 <pesco> @quit
04:21:48 <shapr> oh
04:21:52 <pesco> because it didn't respond. ;)
04:22:44 <pesco> Where is debugStrLn from?
04:22:48 <andersca> lambdabot: @karma andersca
04:22:48 <lambdabot> You have a karma of 0
04:23:03 <pesco> Oh, Util.hs
04:40:02 * Riastradh has a persistent karma module now.
04:40:08 <Riastradh> I dunno if it works, though.
04:40:21 <shapr> oh I wanna see!
04:40:27 <shapr> did you use Read and Show? or what?
04:41:09 <Riastradh> You'll see when I commit it.
04:41:35 <shapr> yay!
04:41:39 * shapr boings
04:41:47 <Riastradh> I doubt it will work very well, though.
04:42:11 <shapr> if it works any at all, it's a step past what we have
04:43:02 <shapr> fits into my development philosophy, first make it work, then make it pretty
04:45:58 <Marvin--> eureka!
04:46:08 <Marvin--> I think I just solved the problem with overlapping guards
04:46:10 <shapr> I had a shower!
04:46:19 <Riastradh> As I guessed, it doesn't work.
04:46:24 <shapr> Riastradh: what are you trying?
04:46:35 * shapr is very curious
04:46:47 <Riastradh> shapr -
04:46:53 <Riastradh> readKarma path =
04:46:59 <Riastradh>     do handle <- openFile path ReadMode
04:47:06 <Riastradh>        text <- hGetContents handle
04:47:11 <Riastradh>        case (reads text) of
04:47:20 <Riastradh>            [(list, "")] ->
04:47:38 <Riastradh>                return $ (listToFM list :: FiniteMap String Integer)
04:47:40 <Marvin--> won't you have lots of problems with the laziness of hGetContents?
04:47:49 <Riastradh>            _ ->
04:48:06 <Riastradh>                return (emptyFM :: FiniteMap String Integer)
04:48:13 <Riastradh> and I just realised that $ there needn't be there.
04:48:20 <shapr> I think that's the best solution until there's a decent Binary.hs
04:48:29 <Riastradh> What's 'Binary.hs?'
04:48:51 <shapr> file persistence of types
04:49:11 <Riastradh> I'm invoking it with:
04:49:14 <Riastradh> moduleInit m =
04:49:15 <shapr> in which case you'd be able to just dump the FM into a file and just load it again later.
04:49:16 <Riastradh>     do s <- get
04:49:25 <Riastradh>        storedKarma <- liftIO $ readKarma "StoredKarma"
04:49:48 <shapr> I like it.
04:49:53 <Riastradh>        newRef <- liftIO . newIORef $ ModuleState storedKarma...oops, that was 'readKarma' in the actual code, not 'storedKarma.'
04:49:58 <Riastradh> That might explain it.
04:50:36 <shapr> maybe I should ask about Binary.hs on the libraries mailing list
04:50:41 <shapr> the discussion has died down
04:50:46 <shapr> with no code :-(
04:51:15 * Riastradh hmms, wondering what he should add to his Lambda-Calculus toy.
04:51:23 <shapr> partial evaluation!
04:51:35 <Riastradh> ...which is...?
04:51:56 <Riastradh> Yay, it works now!
04:52:01 <Riastradh> ...or at least it almost works.
04:52:04 <Riastradh> It doesn't write the karma out yet.
04:52:09 <shapr> http://www.lisp-p.org/htdocs/peval/peval.cgi
04:52:13 <Riastradh> There needs to be a 'moduleUnload' or something.
04:52:25 <Riastradh> A 'moduleUnload' method on Module, that is.
04:52:28 <Marvin--> yes this will probably work, yay
04:52:29 <shapr> yah, I agree
04:52:34 <Marvin--> (guards)
04:53:14 <shapr> Riastradh: initModule/finalizeModule or loadModule/unloadModule ... some pair that matches
04:53:34 <shapr> init/fin ?
04:53:59 <Riastradh> Well, it's already 'moduleInit', so I was thinking of rather 'moduleUnload' or something.
04:54:21 <shapr> what about moduleFin ?
04:54:30 <Riastradh> 'Fin' is a bit vague.
04:54:39 <shapr> it's latin for "end"
04:54:51 <shapr> for example, "final"
04:54:53 <Riastradh> Yes, but not everyone speaks Latin; people such as me.
04:55:03 <shapr> I don't either
04:55:10 <Riastradh> How about 'moduleDeInit' or something to be similar to 'moduleInit?'
04:55:28 <Riastradh> I also wanted it to be congruent with 'moduleName' and 'moduleSticky.'
04:55:33 <shapr> yah, I agree
04:55:47 <shapr> the name system needs to be ... balanced/flat whatever you call that
04:55:54 <Riastradh> Consistent.
04:55:57 <shapr> yes :-)
04:56:01 <shapr> heck I can't even speak english
04:56:05 <Riastradh> Heh.
04:56:49 <shapr> hm
04:57:07 <shapr> what about moduleEnd and moduleStart ?
04:57:26 <shapr> deinit seems too cheesy to me
04:57:42 * Riastradh has seen it used in various other things, like ircd-hybrid.
04:57:51 <shapr> I still like moduleIni and moduleFin better
04:58:31 <Riastradh> The problem is that 'init' and 'finalise' aren't really similar at all; I'd prefer it to be something like 'init' and 'deInit' or 'load' and 'unload' or something.
04:58:33 <shapr> ok, what about moduleLoad and moduleUnload ?
04:58:36 <Riastradh> Heh.
04:58:39 <Riastradh> OK, then.
04:59:02 <shapr> a compromise is where no one gets their way, but at least they're happy the other guy didn't get his way either, right? ;-)
04:59:08 <Riastradh> Heh.
04:59:09 * shapr grins
05:00:09 <shapr> means we have to go rename all the moduleInit methods, but I don't think that's a big deal since the lambdabot user community isn't huge
05:00:44 <shapr> not yet
05:01:15 * shapr hunts the wily coffee
05:03:23 * Riastradh hmms, wonders how he might go about doing lazy evaluation in his Lambda-Calculus interpreter.
05:05:04 <Arnia> There is a paper on that
05:05:14 * Arnia goes and hunts the reference
05:08:04 <Arnia> Liang, Hudak and Jones - Monad Transformers and Modular Interpreters
05:09:01 <Marvin--> cute, this idea seems to be holding
05:10:19 <pesco> shapr, Riastradh: the opposite of init is exit of course
05:12:25 <pesco> initialise exitialize hahaha
05:13:01 <shapr> we could go for borja and sluta =)
05:13:26 <shapr> lambdabot: @fortune
05:13:26 <lambdabot> The most serious doubt that has been thrown on the authenticity of the
05:13:26 <lambdabot> biblical miracles is the fact that most of the witnesses in regard to
05:13:26 <lambdabot> them were fishermen.
05:13:26 <lambdabot> 		-- Arthur Binstead
05:13:32 <shapr> lambdabot: @fortune
05:13:32 <lambdabot> Obviously your filters are throwing away mail from Randal.  :-)
05:13:32 <lambdabot>              -- Larry Wall in <199710221937.MAA25131@wall.org>
05:13:32 <pesco> sound like "pig" and "slut"
05:13:35 <shapr> lambdabot: @fortune
05:13:35 <lambdabot> Once the toothpaste is out of the tube, it's hard to get it back in.
05:13:35 <lambdabot> 		-- H.R. Haldeman
05:13:42 <shapr> lambdabot: @fortune
05:13:42 <lambdabot> Not that I'm against sneaking some notions into people's heads upon
05:13:42 <lambdabot> occasion.  (Or blasting them in outright.)
05:13:42 <lambdabot>              -- Larry Wall in <199710211624.JAA17833@wall.org>
05:14:07 <shapr> we need some quotes from the Haskell cadre
05:14:50 <pesco> The GHC commentary should provide some
05:15:07 <shapr> the one from Manuel's page?
05:15:13 <pesco> yup
05:15:29 <shapr> I want to extend @fortune so that we can add quotes
05:16:09 <pesco> shouldn't be too hard?
05:16:40 <shapr> lambdabot: @fact chilli
05:16:41 <lambdabot> Nothing
05:17:35 <Marvin--> [ Clause name typ (gDisjs (ps2qv ps) (disjs ps) gs) | gs <- tail (inits ge) ]
05:17:48 <pesco> wtf is wrong with the shell?
05:17:58 <shapr> what shell?
05:18:03 <shapr> Hsh.hs?
05:18:12 <pesco> /bin/sh
05:18:53 <pesco> Why doesn't echo ':t \'a\'' | hugs work?
05:19:22 <pesco> argh! nevermind
05:20:22 <pesco> I hate the bourne shell.
05:21:17 <pesco> Is there _no_ way to embed a single quote in a single-quoted string?!
05:21:56 <pesco> Fine, I'll just use pipe and fork, stupid thing!
05:22:04 <Igloo> '\'' will do it
05:22:11 <Igloo> Or you could just use a double quoted string
05:22:26 <Marvin--> Igloo: yeah!  @type $(rm -rf /)
05:22:53 <pesco> Igloo: My sh doesn't see the backslash in single quotes as an escape. Does yours?!
05:22:54 <Igloo> Well obviously you'd escape things...
05:22:58 <Marvin--> Igloo: and no, '\'' doesn't work
05:23:12 <Igloo> In the middle of a single quoted string it does
05:23:28 <sjj> Hola shapr.
05:23:28 <Igloo> end string, literal ', start string
05:23:37 <shapr> y0 sjj, ltns
05:23:38 <pesco> Oh, hm, ok!
05:23:39 <Marvin--> what kind of shell do you use?
05:23:39 <shapr> sjj: wasssup?
05:23:46 <shapr> sjj: have you seen lambdabot?
05:24:00 <sjj> shapr: not much, just juggling exam dates ;), you?
05:24:04 <sjj> shapr: hrm, nope.
05:24:12 <Igloo> I believe   echo 'foo'\''bar'   will work in any POSIX sh
05:24:16 <pesco> echo ':t '\''a'\'''
05:24:21 <pesco> That's really disgusting.
05:24:29 <shapr> sjj: hacking on lambdabot, writing a mailing list searching plugin right now
05:24:40 <Marvin--> Igloo: well all right, but that's because you terminate the string and then resume it
05:24:44 <Marvin--> so it's not really embedded
05:24:50 <Igloo> Yes, that's what I said
05:24:50 <sjj> cool.  Does lambdabot have a project page?
05:24:56 <shapr> lambdabot: @fact source
05:24:57 <lambdabot>  http://sf.net/projects/haskell-libs/, http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/lambdabot/
05:25:05 <sjj> ta.
05:25:09 <Marvin--> Igloo: oh, I failed to parse that sentence
05:25:24 <shapr> sjj: and as always, I'm recruiting developers and code for http://sf.net/projects/haskell-libs/
05:25:51 <sjj> hehe :)
05:26:50 <shapr> sjj: so, can you write Haskell now?
05:27:09 <sjj> to an extent ;)
05:27:27 <sjj> haven't touched on monads yet.
05:27:33 <shapr> they're very spiffy
05:27:39 <Riastradh> Hmm.
05:27:47 <shapr> imho a more powerful abstraction than objects
05:27:54 * Riastradh 's module unloader doesn't work.
05:27:59 <Riastradh> moduleUnload m =
05:28:08 <shapr> Riastradh: no one has ever tested the module unloading code that I know of
05:28:16 <Riastradh>     do maybeKarmaFMRef <- gets (\s -> lookupFM (ircModuleState s) "karma")
05:28:18 <sjj> shapr: *nods* been finding it hard to get decent reading time lately.
05:28:24 * shapr gives Riastradh the 'explorer into the unknown' badge
05:28:29 <Riastradh> I know, but this function doesn't type check.
05:28:44 <pesco> Do not anger the monads for they posess unspeakable powers.
05:28:44 <Marvin--> yay, this seems to be working
05:28:47 <Marvin--> hooray
05:28:49 <shapr> sjj: too many women and parties? ;-)
05:28:49 <Riastradh>     case maybeKarmaFMRef of
05:28:54 <Riastradh>         Just karmaFMRef ->
05:29:05 <Riastradh>         do karmaFMState <- liftIO $ readIORef karmaFMRef
05:29:05 <sjj> shapr: haha ;) I wish ... Uni work mostly
05:29:07 <shapr> pesco: right, they'll send their big brothers the Arrows after you.
05:29:22 <Riastradh>            let (karmaFM :: FiniteMap String Integer) = stripMS karmaFMState
05:29:31 <Riastradh>            writeKarma karmaFile karmaFM
05:29:47 <Riastradh> ...and writeKarma returns IO (), but that expression needs IRC foo.
05:29:57 <shapr> pesco: we should get motorcycle jackets, "H(ask)ell's Arrows"
05:29:59 <sjj> shapr: so, I see you were discussing type persistence, any new developments with regard to hBanana/hJelly? ;)
05:30:08 <pesco> shapr: Oh, yeah!!\
05:30:23 <Riastradh> shapr - How goes toe Haskell Banana gizmo?
05:30:33 <Riastradh> s/toe/the/1
05:30:46 <shapr> I haven't done anything with TwistedHaskell lately
05:30:55 <Riastradh> Rather, how far have you gotten with it?
05:31:10 <shapr> maybe I should stick it into haskell-libs and we can beat into submission as a group
05:31:36 <shapr> Riastradh: Banana works
05:31:40 <Riastradh> Darn.
05:31:48 <Riastradh> I was hoping to gloat that the Scheme one was better.
05:31:48 <shapr> ?
05:31:50 <shapr> heh :-)
05:31:55 <sjj> hehe
05:32:07 <Riastradh> Anyhow, I need to get that thing to type check properly...
05:32:10 <shapr> Jelly can do some stuff, but can't really be extended the way it is
05:32:36 <shapr> sjj: you wanna work on TwistedHaskell?
05:32:48 <Riastradh> Ack, I must go.
05:32:48 <sjj> shapr: I doube my skills are up to the task.
05:32:55 <sjj> s/doube/doubt/
05:33:04 <shapr> best way to improve your skills is to work past your level
05:33:46 * pesco whispers ...it again..
05:34:21 <sjj> i'll see how my schedule looks after this week (pretty hectic) .. besides, Jelly is currently undergoing a refactor IIRC which will ruin backwards compatibility perhaps, so it might be best to hold off.
05:34:30 <shapr> sjj: ok
05:34:31 <pesco> ppclamb: @type 'a'
05:34:32 <ppclamb>   'a' :: Char
05:34:40 <pesco> ppclamb: @type (1+)
05:34:41 <ppclamb>   (1 +) :: Num a => a -> a
05:34:43 <shapr> yay!
05:34:47 <pesco> ppclamb: @type (>>=)
05:34:48 <ppclamb>   (>>=) :: Monad a => a b -> (b -> a c) -> a c
05:34:53 <shapr> ppclamb: @type liftIO
05:35:00 <pesco> ppclamb: @type (1+'a')
05:35:18 <pesco> It only knows the prelude.
05:35:21 <shapr> ah
05:35:30 <sjj> shapr: so what else have you been up to lately, I didn't even know you left .fi until a month or so ago ;)
05:35:43 <shapr> sjj: been here five months now I think
05:35:53 <shapr> started a new company
05:36:01 <sjj> ahh, going well?
05:36:05 <shapr> finally got my residence permit happening
05:36:12 <shapr> sjj: haven't got any Haskell work yet :-(
05:36:24 <shapr> got a decent sized Python contract though
05:36:27 <Igloo> It would be easy enough to change hugs to hugs Foo.lhs where Foo.lhs imports the standard libraries as well as things like FiniteMap though
05:36:28 <sjj> hehe, what sort of work are you doing?
05:36:30 <sjj> ahhh.
05:36:43 <shapr> Have some Java contract work coming up
05:36:43 <pesco> Igloo: Good idea.
05:36:46 <shapr> and some XML
05:36:51 <shapr> but I want Haskell work!
05:37:05 <sjj> :)
05:37:22 <Igloo> That's handy though, ta  :-)
05:37:47 <shapr> sjj: what about you?
05:37:50 <shapr> just school?
05:37:57 <sjj> yeah basically.
05:38:07 <shapr> how close are you to finishing?
05:38:11 <sjj> nothing terribly interesting ;)
05:38:19 <sjj> ~1.5 years to go :\
05:38:29 <shapr> well, I haven't even started yet ...
05:38:49 <sjj> oh, you're starting a course?
05:38:51 <shapr> I hope my swedish will be good enough to start ~January
05:39:10 <shapr> you think I should go for a math or cs degree?
05:39:22 <sjj> hrm, probably math.
05:39:36 <sjj> depends if you want it for learning or for getting work :P
05:39:45 <shapr> learning
05:39:47 <shapr> I have work
05:39:51 <sjj> yeah, i'd go math.
05:40:31 <sjj> at least, based on the cs programs offered here.
05:40:43 <Igloo> For you I'd probably try to find a mixed course
05:41:07 <shapr> Igloo: a math/cs mix?
05:41:11 <Igloo> Yup
05:41:34 <shapr> I'll see what Luleå is offering.
05:42:14 <sjj> I'm hoping to populate my many electives with math courses ;)
05:42:14 * Igloo realises I can't simplify i1 > i2 either
05:43:23 * shapr notes that #haskell now has 39 members not counting 'bots
05:43:26 <shapr> yay! we're growing!
05:43:37 <Igloo> :-)
05:43:47 <andersca> woo
05:44:00 <Igloo> If tunes has full logs you could make pretty graphs of number of lines said per day over time
05:44:29 <shapr> I thought about grabbing their logs for searching
05:44:41 <shapr> there's already something a bit like that
05:44:49 * Igloo disappears for family stuff
05:44:54 <shapr> http://tunes.org/~coreyr/
05:45:15 <shapr> the only clog channel that beats #haskell for lines per day is #lisp
05:45:25 <sjj> shapr: well i'm going to do some reading and head off to bed.  It's been nice catching up with you, i'll try to log on more during the week, that is, if the uni proxy is as willing as me :).  Night.
05:45:34 <shapr> sjj: g'nite!
05:48:22 <pesco> shapr: TypeModule checked in. Have a look, I think it's pretty!
05:49:22 * shapr looks
05:51:37 <shapr> it's amusing to look at the early #haskell logs
05:51:46 <pesco> Yah, they're cool.
05:51:53 <Marvin--> ?
05:52:09 <shapr> I was 100% clueless =)
05:52:24 <Marvin--> pesco: you know, there is a popen in the posix modules somewhere
05:52:26 <shapr> dennisb has been on #haskell since before clog started logging
05:52:37 <pesco> Marvin: no?
05:53:20 <pesco> Marvin: I looked over the haddock to GHC.Posix and didn't see it.
05:53:57 <Marvin--> pesco: it's probably in the old hierarchy still
05:54:41 <pesco> Grrrr.
05:56:37 <pesco> Ah well, had a bit of FFI exercise then.
05:56:43 <Marvin--> :P
05:57:19 * shapr looks for the logs where SimonPJ and SimonM showed up
06:01:38 <shapr> lambdabot: @quit
06:02:18 * shapr tries with -O -fvia-C
06:02:47 <shapr> lambdabot: @listcommands type
06:02:48 <lambdabot> Module type provides the following commands: ["type"]
06:02:56 <shapr> lambdabot: @type liftM
06:03:05 <shapr> lambdabot: @type (+)
06:03:05 <lambdabot>   (+) :: Num a => a -> a -> a
06:03:15 <pesco> ppclamb: @type (+)
06:03:15 <ppclamb>   (+) :: Num a => a -> a -> a
06:03:20 <pesco> Heh, yours is quicker
06:03:30 <shapr> my machine might be faster
06:04:08 <pesco> No way, nothing beats my PowerPC when it's not compiling GHC.
06:04:24 <shapr> dual Athlon MP @ 1533 MHz ?
06:04:48 <pesco> single PowerPC G4 @ 400 MHz ?
06:04:51 <Marvin--> shapr: pipe it to ghci instead so we can ask   :t Control.Monad.liftM
06:04:52 <pesco> !
06:05:06 <shapr> pesco: ok, your machine is more powerful.
06:05:25 <shapr> Marvin--: ask pesco, or... you could fix it...
06:05:28 <shapr> you have commit privs
06:05:36 <shapr> Marvin--: and I know you have nothing to do with your time.
06:05:39 * shapr ducks
06:06:06 <shapr> just a master's project and the d-i stuff.
06:06:06 <pesco> I thought about giving the interpreter command as an argument to the Module constructor.
06:06:09 * Marvin-- grumbles
06:06:48 <pesco> I'll add it once I'm done with removing all the shell magic in favour of POSIX.POpen and Text.Regex.
06:07:43 <Marvin--> heh
06:23:19 <pesco> Does ghci have a -p switch like hugs?
06:23:46 <shapr> what does -p do?
06:23:52 <pesco> set the prompt
06:24:11 <shapr> not that I'm aware of
06:24:16 <pesco> grmbl
06:24:18 <shapr> the prompt always tells you which modules are loaded
06:24:25 <pesco> Ah, right.
06:24:39 <shapr> there is a regex to match the prompt in haskell-mode.el
06:24:42 <shapr> I can scrape it out if you want
06:24:50 <pesco> sure
06:25:25 <pesco> probably something like "^[[:alnum:]]+> " right?
06:25:32 <shapr> (setq comint-prompt-regexp  "^\\*?[A-Z][_a-zA-Z0-9]*\\( \\*?[A-Z][_a-zA-Z0-9]*\\)*> ")
06:25:48 <pesco> Yah, ok.
06:28:12 * shapr has fun writing the "and" search
06:33:33 <shapr> we really really need to factor out some ModuleState accessor functions
06:59:54 * Igloo reappears for a bit and suggests    (what you have; echo I don't know anything about escape($foo)) | head -1
07:00:23 <Igloo> (for @type)
07:00:49 <pesco> That would yield the first line.
07:01:12 <pesco> __   __ __  __  ____   ___      _________________________________________
07:01:17 <Igloo> But there is only 1 line. And if there are no lines it would tell you it failed rather than sittin ghtere doin gnothing
07:01:20 <Marvin--> :P
07:01:32 <Marvin--> Igloo: don't forget the silly logos :)
07:01:35 <Igloo> But what_you_have already gets rid of that
07:02:40 <Marvin--> pesco: I don't think ghci will print a prompt if you just pipe ':t ...' to it
07:02:43 <pesco> What I have extracts all lines that match 'prompt> .* :: .*' or something
07:03:05 <pesco> Marvin: Can you try that?
07:03:21 <Marvin--> pesco: just did
07:03:37 <Marvin--> $ echo ":t Control.Monad.liftM" | ghci
07:03:40 <Marvin--> ... lots of crap ...
07:03:42 <Marvin--> Loading package haskell98 ... linking ... done.
07:03:42 <Marvin--> forall r m a1. (Monad m) => (a1 -> r) -> m a1 -> m r
07:03:42 <Marvin--> Leaving GHCi.
07:03:55 <pesco> Ugh
07:04:09 <Marvin--> you could search for ^forall
07:04:12 <pesco> What does it look like in the error case?
07:04:16 <Igloo> I just meant to get an error message easily if it fails rather than changing it to use ghci
07:04:49 <pesco> Hm, GHCi needs some time to start, doesn't it?
07:04:56 <Marvin--> Igloo: it's nicer to use ghci than hugs anyway, since hugs will only give you types for things in the Prelude
07:05:10 <Marvin--> pesco: yeah, that's the tradeoff
07:06:17 <Igloo> With 5.05 it's worse:
07:06:18 <Igloo> Control.Monad.liftM :: forall r m a1.
07:06:18 <Igloo>                        (Monad m) =>
07:06:18 <Igloo>                        (a1 -> r) -> m a1 -> m r
07:06:25 <Marvin--> oh dear
07:06:40 <Igloo> I'd stick with hugs and importing lots
07:07:06 <pesco> Ok.
07:07:14 <Marvin--> right
07:07:25 <Marvin--> but won't that be slow too?
07:07:48 <pesco> Yes, but then again Hugs parses pretty fast.
07:07:54 <Igloo> You could have @type Control.Monad liftM
07:08:11 <pesco> Yes, that's better.
07:08:21 <Marvin--> @type Monad liftM for hugs
07:08:21 <Igloo> (or parse Control.Monad.liftM)
07:08:46 <Marvin--> or @type liftM Monad   so the module is optional, defaulting to Prelude
07:08:48 <Igloo> Control.Monad works in recent versions
07:08:52 <Marvin--> oh, neat
07:09:04 <Igloo> Well, it can be optional either way round
07:09:09 <pesco> yes
07:09:12 <Marvin--> yeah, but easier to parse if the module is last
07:10:17 <pesco> not really.
07:10:56 <Vincenz> yowyow
07:12:41 <pesco> It would probably be easiest with a seperate @type-from or something.
07:20:13 <Marvin--> 4
07:20:16 <Marvin--> bleh
07:20:41 <pesco> What happened?
07:21:37 <Marvin--> ?
07:22:00 * shapr zoinks
07:22:51 * andersca yoinks
07:23:00 * shapr shazams
07:23:08 * andersca WHAMs
07:23:22 * shapr book faults
07:23:37 <shapr> gotta get that book back from the guy I loaned it to
07:26:13 <Marvin--> lambdabot: @type (+1).(+1)
07:26:13 <lambdabot>   flip (+) 1 . flip (+) 1 :: Num a => a -> a
07:26:18 <Marvin--> yay
07:26:40 <Marvin--> lambdabot: @type (+1).(+1).(+1).(+1).(+1).(+1)
07:26:41 <lambdabot>   flip (+) 1 . flip (+) 1 . flip (+) 1 . flip (+) 1 . flip (+) 1 . flip (+) 1 :: Num a => a -> a
07:26:43 <shapr> ?
07:26:54 <Marvin--> hugs doesn't do any pretty printing?
07:27:00 <shapr> where does flip come from?
07:27:09 <pesco> Prelude.hs
07:27:09 <Marvin--> it's a right section
07:27:35 <Marvin--> (e *) -> (*) e ,  (* e) -> flip (*) e
07:28:41 <shapr> lambdabot: @type (+1)
07:28:41 <lambdabot>   flip (+) 1 :: Num a => a -> a
07:28:44 <shapr> lambdabot: @type (1+)
07:28:45 <lambdabot>   (1 +) :: Num a => a -> a
07:28:46 <shapr> ah
07:30:32 <shapr> hi Darius 
07:30:33 <shapr> g'mornin
07:30:42 <Darius> heya
07:33:10 <shapr> what's up with you?
07:34:36 <shapr> oh, see pesco's new plugin
07:34:43 <shapr> lambdabot: @type foldr
07:34:43 <lambdabot>   foldr :: (a -> b -> b) -> b -> [a] -> b
07:34:56 <Darius> trying to get as much as possible from a 2GB slightly corrupt .tar.bz2.
07:35:11 <shapr> yow
07:35:28 <Darius> lambdabot: @listcommands
07:35:28 <lambdabot> I react to the following commands: ["define","definitions","echo","eval","fact","fortune","get-definition","goodbye","hello","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","msg","part","quit","set-fuel","state","topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type"]
07:36:23 <shapr> hopefully I'll have the mailing list search plugin working in a bit
07:36:23 <Darius> lambdabot: @type callCC
07:37:13 <shapr> I really want binary persistence now
07:41:04 <shapr> catMaybes is handy
07:41:15 <pesco> mapMaybe as well
07:42:51 <Darius> type plugin just the prelude?
07:43:14 <shapr> yah, using hugs atm
07:43:37 <shapr> I think pesco is switching it to ghci so you can do @type Control.Monad.join
07:43:46 <pesco> No, no ghci.
07:43:49 <shapr> oh, ok
07:44:02 <pesco> But I might add @type-from <module> <expr>
07:44:58 <pesco> Yay, all the shell magic is gone!
07:45:04 <shapr> yay!
07:45:18 <Marvin--> now it's regex magic in haskell instead?
07:45:35 <pesco> Yes.
07:45:39 <pesco> But it's only one regex.
07:45:49 <pesco> Which looks horrible but works accurately.
07:46:11 <pesco> There are no good-looking regexps that accomplish anything half-way sophisticated.
07:48:29 <Darius> lambdabot: @type foldr\n5
07:48:57 * shapr worries
07:50:15 <pesco> lambdabot: @type foldr\nwritefile "hello" "hi shapr"
07:50:24 <shapr> how
07:50:29 <shapr> er
07:50:29 <shapr> yow
07:50:47 <pesco> Ok, let me fix...
07:50:56 <Vincenz> what ddoes @type do?
07:51:32 <pesco> pipe the argument prepended with ":t " to hugs
07:51:57 <Vincenz> lamdabot: @type ((\x.x x)(\x.x x))
07:52:14 <Darius> lambdabot: @fact nl aou\neao
07:52:15 <lambdabot> set nl to aou\\neao
07:52:31 <Igloo> That's neither Haskell nor typeable in Haskell's type system, Vincenz
07:52:43 <Vincenz> it works with eval
07:52:47 <Vincenz> lamdabot: @eval ((\x.x x)(\x.x x))
07:52:56 <Vincenz> or used to work when @eval worked
07:53:00 <Vincenz> it gave me an outofstack
07:53:05 <Igloo> That's a lambda calculus interpreter
07:53:12 <Vincenz> ah~!
07:53:21 <Vincenz> that shows you how much Haskell I know :P
07:53:27 <Igloo> :-)
07:54:10 <Darius> lambdabot: @fact kangaroo
07:54:10 <lambdabot> ,  _,'   ___
07:54:10 <lambdabot> , <__\__/   \
07:54:10 <lambdabot> ,    \_  /  _\
07:54:10 <lambdabot> ,      \,\ / \\
07:54:10 <lambdabot> ,        //   \\
07:54:11 <lambdabot> ,      ,/'     `\_,
07:54:16 <shapr> heheh
07:54:16 <Marvin--> hahaha
07:54:23 <Vincenz> lambdabot: @fact ocaml
07:54:24 <lambdabot> Nothing
07:54:26 <shapr> lambdabot: @fact think
07:54:26 <lambdabot> +------------------+
07:54:26 <lambdabot> | ALWAYS THINK AHEA|
07:54:26 <lambdabot> |                 D|
07:54:26 <lambdabot> +------------------+
07:54:45 <Vincenz> lambdabot: @fact ocaml is Objective Caml
07:54:46 <lambdabot> set ocaml to is Objective Caml
07:55:08 <Marvin--> lambdabot: @fact ocaml THE ENEMY
07:55:09 <lambdabot> set ocaml to THE ENEMY
07:55:13 * shapr grins
07:55:21 <Darius> lambdabot: @definitions
07:55:22 <lambdabot> []
07:55:22 * Vincenz kicks Marvin--'s ass
07:55:34 * Vincenz slaps Marvin--'s face with a recursive trout
07:55:36 <Darius> lambdabot: @eval 5
07:55:37 <lambdabot> 5
07:55:37 <Vincenz> FEel that tailcall!
07:55:53 * shapr snickers
07:56:12 <Darius> lambdabot: @eval (\x.x x) (\x.x x)
07:56:13 <lambdabot> out of fuel
07:56:25 <Vincenz> there ya go
07:56:27 <Darius> lambdabot: @eval ((\x.x x)(\x.x x))
07:56:27 <lambdabot> out of fuel
07:57:48 <andersca> mmm snickers
07:58:00 <shapr> I want chocolate
07:58:10 <shapr> I should go to the corner store before they close
07:58:48 <Vincenz> shapr: you could pay me and I'd send it to you from here in belgium
07:58:52 <Vincenz> best chocolate in the world
07:59:05 <andersca> shapr: I have a store in the same house as my apartment :)
07:59:11 <shapr> lucky you
07:59:23 <shapr> I have to walk two blocks to the handlar'n
07:59:29 <Marvin--> Göteborg has a belgian chocolate shop :)
07:59:36 <andersca> Marvin--: where?
07:59:48 <Marvin--> andersca: Belgian House of Chocolate, somewhere in Haga I think
07:59:53 <andersca> ah
08:00:07 <Marvin--> wwaaaaaay expensive though :)
08:03:07 <Vincenz> OH YEAH!!!
08:03:14 <shapr> ?
08:03:21 <Vincenz> I can load in an MRI scan (3d data)
08:03:27 <Vincenz> pick a point somewhere in the lungs
08:03:39 <Vincenz> and it find the tumor's size and delineates it on the drawings
08:03:39 <Vincenz> :)
08:03:43 <shapr> can you show it with OpenGL?
08:03:51 <Vincenz> shapr: heh, ...it's matlab code
08:03:55 <shapr> oh
08:03:56 <Vincenz> but yes, that could be done
08:04:07 <Vincenz> shapr: besides, matlab plots are 3d
08:04:07 <shapr> lambdabot: @fact hopengl
08:04:07 <lambdabot> Nothing
08:04:14 <Vincenz> lambdabot: @karma- shapr
08:04:14 <lambdabot> shapr's karma has been decremented.
08:04:18 <shapr> ?
08:04:23 <Vincenz> opengl..
08:04:25 * Vincenz tsks
08:04:27 <Vincenz> Matlab!
08:04:27 <andersca> lambdabot: @karma+ shapr
08:04:27 <lambdabot> shapr's karma has been incremented.
08:04:29 <shapr> what's bad about it?
08:04:36 <shapr> I like OpenGL
08:04:43 <shapr> I just wish I had a different graphics card
08:04:48 <shapr> NVidia drivers suck
08:05:11 <shapr> I want a Radeon 9000 Pro
08:05:23 <pesco> I'm looking forward to the DOOM III release. Then I'm getting a Radeon 9700 Pro, no two ways about it.
08:05:27 <Igloo> Has that got OS drivers?
08:05:31 <Vincenz> I want an nvidia :)
08:05:32 <shapr> Igloo: yes
08:05:37 <shapr> ATI has open source drivers
08:05:40 <Vincenz> Geforce 4600(GT I think)
08:05:45 <Igloo> Nice
08:05:58 <shapr> they're not as fast as nvidia drivers, but then again, nvidia drivers have SMP deadlock problems
08:06:01 <shapr> among other problems
08:06:01 <pesco> shapr: You're not referring to the FireGL drivers though, are you?
08:06:04 <Vincenz> shapr: yup
08:06:17 <Vincenz> shapr: nvidia drivers even have multithrading problems
08:06:22 <shapr> yes, I know all too well
08:06:26 <Vincenz> had to write my own mutex at work to synchronize opengl card
08:06:33 <Vincenz> I was getting like 12 seconds to load a texture!!!
08:06:36 <shapr> even worse, I would try to fix them if they were OSS
08:06:59 <shapr> I fixed the IDE drivers in the kernel when they didn't support my motherboard
08:07:30 <shapr> pesco: whatever the ATI Radeon 9700 Pro drivers are
08:08:05 <pesco> shapr: Hmm, if you know there is source, you must have seen it. Where?
08:08:05 <shapr> which ones are the FireGL drivers?
08:08:11 <shapr> online somewhere...
08:08:17 * shapr looks
08:09:13 <pesco> shapr: I've poked around the ATI website, looking for Linux drivers for the 9700 and found a package of Linux drivers designated for the FireGL's based on the R300 which also work for the Radeon cards.
08:09:26 <pesco> I thought it was closed source.
08:09:54 <Riastradh> Hi.
08:10:45 <shapr> y0
08:11:04 * Igloo vanishes for family stuff
08:16:30 <Riastradh> Hmm.
08:19:11 <shapr> pesco: further research implies that there are both closed and open source drivers for the Radeon series
08:19:43 <pesco> Aha! That's what I had suspected.
08:20:01 <shapr> ATI claims that they actively support the XF86 ATI driver 
08:20:43 <pesco> That looks like kind of a split-tounge way of acting on ATI's part.
08:20:50 <shapr> I don't how the drivers compare by speed
08:21:04 <pesco> Take a guess.
08:21:24 <pesco> equal: improbable. open source faster: impossible
08:23:31 <Riastradh> GHC doesn't like hook_message and doHooks...
08:23:33 <shapr> on the other hand, we can fix the OSS driver
08:23:50 <pesco> In theory.
08:24:06 <shapr> hey, you fixed ghc
08:24:07 <shapr> :-)
08:24:15 <shapr> where there's a will...
08:24:18 <shapr> there are relatives.
08:24:22 <shapr> or something like that.
08:24:23 <pesco> Once I find out how _any_ 3D gfx card works on the hardware level, we'll talk again.
08:24:27 <shapr> heh
08:24:54 <shapr> sure, let's write an OpenGL driver generator in Haskell
08:25:01 <Riastradh> hook_message has a type of (Module m) => m -> IRCMessage -> IRC ()...or something like that.
08:25:11 <Riastradh> doHooks is defined as:
08:25:12 <shapr> generates optimized C source code
08:25:14 <Riastradh> doHooks f msg =
08:25:16 <Riastradh>     do s <- get
08:25:25 <Riastradh>        doHooks' . eltsFM $ ircModules s
08:25:26 <Riastradh>     where
08:25:31 <Riastradh>     doHooks' [] = return ()
08:25:37 <Riastradh>     doHooks' (x : xs) =
08:25:41 <Riastradh>         do f x msg
08:25:46 <Riastradh>            doHooks' xs
08:25:53 <shapr> Riastradh: look at checkPrivs in IRC.hs
08:26:01 <pesco> ppclamb: @type foldr
08:26:02 <ppclamb> foldr :: (a -> b -> b) -> b -> [a] -> b
08:26:11 <pesco> ppclamb: @type-from Monad liftM
08:26:12 <ppclamb> liftM :: Monad a => (b -> c) -> a b -> a c
08:26:12 <shapr> ppclamb: @type Control.Monad.join
08:26:18 <shapr> ah cool
08:26:31 <shapr> ppclamb: @type-from Control.Monad join
08:26:37 <Riastradh> shapr - Look at it for what?
08:26:41 <shapr> no hierarchical modules?
08:26:45 <pesco> Hm, oh, I think I forgot that switch.
08:27:09 <shapr> Riastradh: for a hook function
08:27:10 * pesco inserts three characters into TypeModule.lhs
08:27:23 <Riastradh> shapr - Er, I don't see what you're getting at.
08:27:39 <pesco> lambdabot is really fun.
08:27:43 <shapr> yah, I agree
08:28:35 <Riastradh> Oh, and doHooks is being invoked through mainloop --
08:28:36 <Riastradh> mainloop =
08:28:40 <Riastradh>     do msg <- ircRead
08:28:46 <Riastradh>        doHooks hook_message msg
08:29:08 <shapr> can you use sequence?
08:29:17 <Riastradh> What does 'sequence' do?
08:29:22 <shapr> Control.Monad.sequence
08:30:01 * shapr swears at his roken keyoar
08:30:25 <shapr> grr, I'm going to get chocolate...
08:30:42 * Riastradh sees no documentation about what it does...
08:31:04 <shapr> it comines a list o monaic types
08:31:07 <shapr> argh
08:31:22 <shapr> what aout mapM?
08:32:43 <shapr> mapM oHook (eltsFM $ ircMoules s)
08:32:44 <shapr> ?
08:32:59 <shapr> grr.. shopping
08:33:16 <Riastradh> OK, now it's defined as:
08:33:18 <Riastradh> doHooks f msg =
08:33:21 <Riastradh>     do s <- get
08:33:34 <Riastradh>        mapM_ (\mod -> f mod msg) . eltsFM $ ircModules s
08:33:59 <Riastradh> (the resulting list is thrown away, hence the usage of mapM_ and not mapM)
08:36:09 <pesco> ppclamb: @type-from Control.Monad join
08:36:14 <Riastradh> And it still borks.
08:36:20 <Riastradh> With the same error.
08:36:24 * pesco curses
08:36:42 <Darius> ppclamb: @listcommands
08:36:43 <ppclamb> I react to the following commands: ["define","definitions","echo","eval","fortune","get-definition","goodbye","hello","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","msg","part","quit","set-fuel","state","topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type","type-from"]
08:37:31 <Darius> ppclamb: @type-from Control.Monad.join
08:37:40 <pesco> *g*
08:38:42 <Riastradh> Argh, I must go again.
09:00:30 <Janni> re
09:25:31 <shapr> amn this keyoar
09:27:31 <Vincenz> d and b not working?
09:27:47 <shapr> 6fdb and up
09:28:01 <shapr> I just wiggled the connector again
09:28:06 <shapr> it's back, yay!
09:30:28 <Darius> 89.26%
09:30:36 <shapr> w00
09:30:38 <shapr> we're going up!
09:31:08 <shapr> I think we were 82 or 85 yesterday
09:31:29 <shapr> 6 lambdabot downloads
09:31:39 <shapr> 57 page views
09:31:46 <shapr> as of two days ago
09:34:49 <shapr> Darius: we're ranked 1148 in most active - http://sourceforge.net/top/mostactive.php?type=week&offset=1100
09:35:44 <Darius> we've been gaining ~500 ranks a day
09:36:00 <shapr> :-)
09:36:33 * shapr codes faster
09:37:11 <shapr> I won't have much time to work on Haskell next week :-(
09:37:18 <shapr> two commercial jobs to work on
09:39:24 <Darius> hopefully by next week I'll be able to type faster
09:39:32 <shapr> heh :-)
09:40:40 <shapr> lambdabot: @type fromJust
09:41:48 <Darius> module Maybe
09:41:56 <dennisb> what is the status of gtk+hs for gtk2? Most of the home page seems to talk about gtk1.x
09:42:05 <shapr> there's gtk2hs
09:42:11 <shapr> which is a separate library by Axel Simon
09:42:17 <dennisb> another page?
09:42:17 <shapr> gtk+hs is by Manuel Chakravarty
09:42:18 <shapr> yup
09:42:22 <shapr> entirely different lib
09:42:25 <dennisb> aha
09:42:57 <shapr> lambdabot: @fact gtk+hs
09:42:57 <lambdabot> Nothing
09:42:58 <dennisb> explains why I didn't find it. I knew I had read about gtk2 bindings, still it wasn't at Manuels page
09:43:02 <shapr> lambdabot: @fact gtk2hs
09:43:02 <lambdabot> Nothing
09:43:13 <shapr> lambdabot: @fact gtk2hs http://gtk2hs.sourceforge.net/
09:43:13 <lambdabot> set gtk2hs to http://gtk2hs.sourceforge.net/
09:43:32 <shapr> lambdabot: @fact gtk+hs http://www.cse.unsw.edu.au/~chak/haskell/gtk/
09:43:33 <lambdabot> set gtk+hs to http://www.cse.unsw.edu.au/~chak/haskell/gtk/
09:44:04 <shapr> I wish lambdabot could respond via fact to single word questions
09:44:24 <shapr> that way @fact gtk2hs would get called from
09:44:26 <shapr> gtk2hs?
09:46:37 <Janni> shapr: Wishing doesn't help (normally). You'll have to implement it...
09:46:46 <shapr> I just put it into the TODO list
09:47:04 <Janni> Yeah, that constantly growing thing (I hate it :)
09:47:04 <shapr> once I finish the searchml plugin, I'll look at the TODO list and pick the next thing to work on
09:47:22 <shapr> c'mon, an empty TODO would be far worse
09:47:46 <Janni> Right...
09:47:50 <shapr> what if we were *finished* ?
09:47:58 <shapr> we'd all have to get real jobs or something.
09:48:14 <Janni> And _work_.
09:48:20 <shapr> yah, really
09:51:55 <dennisb> strange, I get errors when I unpack the gtk2hs tarball
09:57:36 * shapr watches his searchml module repeatedly explorb
10:02:18 <dennisb> Hoho, I tried to subscribe to the gtk2hs mailinglist, but it seems I was already on that list...
10:02:26 <shapr> heheh
10:02:42 <shapr> I guess you know how active it is now
10:04:52 <dennisb> seems to be low activity on gtk+hs also
10:05:24 <shapr> I haven't tried writing gtk apps yet with Haskell
10:05:32 <shapr> I'd like to
10:08:13 <dennisb> Me to, I did try it a year or two ago, but it wasn't ready. And if I would get involved in the binding it would take to much time. It's a bit sad
10:10:22 <shapr> the gui@haskell.org mailing list is *really* active the last weeks
10:10:28 <shapr> I hope they release something soon
10:12:06 <dennisb> I don't know what they plan to release, but I would prefer to use a standard toolkit
10:13:09 <shapr> they're making a cross-toolkit binding
10:13:35 <shapr> I suggested they start with Htk, since it's the most cross-platform
10:14:09 <shapr> I don't know the current plans, I've been distracted
10:14:36 <Vincenz> heh
10:14:37 <Vincenz> ...
10:14:46 <Vincenz> how do you implement a nontrivial quicksort in FP?
10:17:02 <dennisb> Vincenz: why would you want a more complicated one?
10:17:12 <Vincenz> dennisb: smarter pivotting
10:18:48 <Vincenz> quicksort on a sorted list -> O(N^2)
10:21:43 <dennisb> Vincenz: I think Lennart Augustsson had one very optimized version
10:26:25 <dennisb> Vincenz: this seems to be a nice page: http://www.informatik.uni-bonn.de/~ralf/software/Library/Sort.html
10:26:54 <andersca> hey dennisb
10:26:55 <dennisb> I havn't really understood the qsort yet, maybe it has the same problem as the trivial one, and maybe not
10:27:24 <dennisb> seems to be the same
10:28:18 <dennisb> well, quicksort is always going to be O(n^s) on some cases no matter what
10:28:25 <dennisb> n^s
10:28:31 <dennisb> what is this.. I cant type 2
10:28:58 <andersca> you could check if the list is sorted and don't sort it :)
10:29:34 <pesco> Ok, what is this Fruit stuff? And AFRP? And Haven?
10:29:52 * pesco scribbles "Aaarrroooowwwss" somewhere into his head.
10:30:01 <shapr> yay arrows
10:30:45 * pesco suddenly notices the giant rock in his hands, engraved with "R_PPC_REL24"
10:30:52 <pesco> damn
10:32:47 <pesco> "P represents the place (section offset or address) of the storage unit being relocated..."
10:33:06 <pesco> Well, which is it, section offset or virtual address?!
10:47:32 <dennisb> fun quote from the ghc manual: "Another extremely efficient way to make your program snappy is to use library code that has been Seriously Tuned By Someone Else. You might be able to write a better quicksort than the one in the HBC library, but it will take you much longer than typing `import QSort'. (Incidentally, it doesn't hurt if the Someone Else is Lennart Augustsson.)"
10:49:53 <Marvin--> haha
10:55:32 * shapr wiggles his keyoar connector or the zillionth time toay
10:59:29 <Marvin--> your keyoar isn't working too well, is it? ;)
10:59:45 <pesco> keyoars are cool.
10:59:49 <shapr> how could you tell?
11:00:05 <shapr> I can barely wait till the new one shows up
11:01:10 <shapr> something bad happens when I try to pack an IO FiniteMap into an IORef
11:01:27 <shapr> and it only happens when I try to unpack it with the stripMS stuff
11:02:24 <shapr> lament: divide by pickle
11:02:57 <lament> shapr: sorry, not enough bugs!
11:03:02 <shapr> :-)
11:03:07 <shapr> wassup?
11:03:21 <shapr> yay, it looks like the searchML is working now!
11:03:25 <lament> yay
11:03:26 * shapr waits for a long time
11:03:29 <lament> (whatever that is)
11:03:35 <shapr> I should have used -O -fvia-C
11:03:43 <shapr> lament: it's a haskell mailing list search plugin for lament
11:03:47 <shapr> er "for lambdabot"
11:03:59 <shapr> raise nickCompletionError
11:05:32 <shapr> lambdabot: @quit
11:08:22 * shapr finds an entirely new bug
11:09:28 <shapr> crap
11:11:08 <shapr> Riastradh: found an interesting problem with moduleInit
11:11:35 <shapr> Riastradh: it gets called after lambdabot connects, but before lambdabot logs in
11:11:54 <shapr> meaning it times out with large module startup times
11:19:42 <pesco> Oh my god, I juts peeped into #mklinux to ask about the GHC relocation problems.
11:19:49 <shapr> and?
11:19:55 <pesco> The C gurus are _arrogant_ as hell.
11:20:07 * shapr is unsurprised
11:20:17 * Marvin-- is also unsurprised
11:20:54 <dennisb> strange, I'm not arrogant :-)
11:21:02 <shapr> in my experience, Haskell gurus are not arrogant.
11:21:09 <shapr> dennisb: are you a C guru?
11:21:40 <dennisb> maybe not, but i've used it since childhood
11:21:50 <andersca> and that's like a hundred years ago
11:21:51 * andersca ducks
11:22:00 * shapr grins
11:22:07 <dennisb> I agree. andersca is a duck
11:22:17 <andersca> can you prove it? :)
11:22:29 * shapr quacks up laughing
11:25:32 <pesco> hozer: /topic
11:25:34 <pesco> oops
11:30:05 <shapr> ok, I need a haskell guru
11:30:53 <pesco> hehe, one of the people on #mklinux is interested in haskell, now the C people have to listen to my monologue about monads and stuff.
11:31:01 <shapr> heh
11:31:58 <shapr> the problem is that the first IRC () isn't being constructed until *after* the connection is made
11:35:35 * shapr ponders
11:36:58 <shapr>         bracket (return ()) (\_ -> killThread threadr >> killThread threadw)
11:36:58 <shapr>                 (\_ -> runReaderT (evalStateT m initState) chans)
11:37:27 <shapr> is there some way I can force the (evalStateT m initState) to be evaluated before that?
11:37:44 <shapr> oh, I think I can do that outside of the bracket and pass it in... maybe
11:42:31 <_Codex> andersca: easy to prove. B f(A); A a; f(a) : B.
11:46:13 <shapr> I am *so* far out of my depth
11:46:21 <shapr> Couldn't match `IO' against `ReaderT IRCRState IO'
11:47:58 <Vincenz> it's good to be out of the depths
11:48:02 <Vincenz> that way you're happy :)
11:48:12 <shapr> I like to swim in deep waters.
11:48:24 <shapr> truly it is fun :-)
11:51:23 <Darius> the simplest (but unsatisfactory) solution is just to load the modules after signon
11:51:35 <shapr> that's what it does currently
11:51:43 <shapr> oh
11:51:47 <shapr> I see what you mean.
11:52:03 <shapr> I'll try that.
11:52:31 <shapr> I'll move the init code out of moduleInit into the Nothing branch of ModuleState lookup
11:52:37 <shapr> good idea
11:56:19 <shapr> hello Ar_Pharazon 
11:56:38 <Ar_Pharazon> shapr, hey, this is 'vardamir'
11:56:46 <shapr> ah, re vardamir
11:56:55 <Ar_Pharazon> re vardamir
11:56:56 <Ar_Pharazon> ?
11:57:00 <shapr> re == rehi
11:57:07 <shapr> as in, hello again
11:57:13 <shapr> ircspeak from long ago
11:57:35 <Ar_Pharazon> i see; i should get more familiar with IRC since I'm using it 
11:58:16 * Darius thinks "me too"
11:58:18 <shapr> Darius: yay, it both compiled and connected
11:58:28 <shapr> now I gotta see if it explorbs when I init the state
11:58:57 * shapr watches the drives/CPUs chug
12:04:43 <Ar_Pharazon> is there a better way to declare the type of elements in a list than specifying for each element individually?
12:05:09 <shapr> why are you specifying types at all?
12:05:26 <shapr> they're usually not required
12:07:20 <Ar_Pharazon> well, i'm trying to simulate permuations, so if i have a list of Ints, then I can say a!!(b!!(c!!2)) where a,b,c are lists and 2 is an index.  but, this won't work if the lists are using Integer instead of Int
12:07:42 <shapr> oh
12:07:50 <shapr> why not use a list comprehension?
12:08:22 <shapr> [(a,b) | a <- [1..5], b <- [1..5]]
12:08:23 <Ar_Pharazon> well, probably cause I don't know what that is ;), but I'll check it out
12:08:44 <shapr> is that what you want?
12:09:37 <shapr> [(a ++ b) | a <- ["dark","light","solid"], b <- ["red","grey","green"]]
12:10:47 <Ar_Pharazon> well, i don't think so because I just need an integer value returned, not a pair or concatenation
12:10:59 <shapr> what do you mean?
12:11:07 <shapr> you want order permutation also?
12:12:07 <Ar_Pharazon> order permutation? well, order would matter certainly matter ..
12:12:53 <_Codex> btw, Is the "list comprehension" always implemented as a list? I'm wondering whether there would be easy way to index the resulting space?
12:13:05 <dennisb> Ar_Pharazon: I don't know exactly what you want to do but the problem of Int and Integer maybe can be solved by using fromEnum at selected places
12:13:21 <shapr> Ar_Pharazon: http://kungens.kemi.fi/~shae/src/haskell/Perm.hs
12:14:02 <Darius> Would default make a difference?
12:17:19 <shapr> it's amusing to hear my CPU fans speed up when I'm building this FM
12:17:37 <shapr> zooom
12:17:46 * andersca zooms
12:18:03 * shapr basks in heat from the CPUs
12:18:18 <_Codex> I mean, does the following make sense: c = [(a,b) | a <- [1..5], b <- [1..5]]. d=map(c,a+b*2); d[(3,2)]. (pseudo.-syntax). I.e. list comprehension used for space generation only...
12:20:14 <Darius> whee.  catting 30 half gig files into one 20GB file... one at a time 
12:22:23 <Ar_Pharazon> shapr, that is nice. you are going from a list to a list of lists (finding all permutations), but what i'm trying to accomplish is going from a list of lists (though it may be only one) to another list (composition of permutations).  Thanks for the code though, I'm still new to FP and this will help.
12:23:00 <shapr> composition of permutations? huh?
12:24:13 <Ar_Pharazon> hang on i'll find a link
12:24:20 <shapr> can you show me an example?
12:24:22 <Darius> foldr (!!) 2 [a,b,c]
12:24:37 <Ar_Pharazon> hmm, Darius, why didn't I think of that?
12:25:04 <Ar_Pharazon> oh well i'll get used to it eventually
12:27:56 <Ar_Pharazon> http://www.cs.jcu.edu.au/Subjects/cp5030/1999/lectures/perm/perm.html
12:28:46 <Vincenz> bye dudes and dudettes
12:28:49 <Vincenz> going to see a movie
12:28:52 <shapr> cya Vincenz 
12:28:58 <shapr> my searchml works, yay!
12:29:16 <shapr> and it takes 3 minutes to index 16mb of the haskell mailing list
12:49:49 <Ar_Pharazon> but anyway, is there a way to specify the type of all elements of a list only once?  Otherwise I've got it done, i believe: permute x = [foldr (!!) i x | i <- [1..len]]
12:49:50 <Ar_Pharazon>   where len = length x!!0
12:50:34 <Ar_Pharazon> hmm, len should be the length - 1
12:50:48 <Darius> x!!0 == head
12:51:33 <Ar_Pharazon> ah yes ;)
12:54:47 <Darius> what error are you getting? you shouldn't need to specify the type anywhere
13:01:30 <Ar_Pharazon> and just when i was going to post the error ;)
13:20:27 <Ar_Pharazon> Darius, here it is:
13:20:28 <Ar_Pharazon> <interactive>:1:
13:20:29 <Ar_Pharazon>     Couldn't match `Int' against `Integer'
13:20:29 <Ar_Pharazon>         Expected type: Int
13:20:29 <Ar_Pharazon>         Inferred type: Integer
13:20:29 <Ar_Pharazon>     In the expression: b !! 2
13:20:31 <Ar_Pharazon>     In the second argument of `(!!)', namely `(b !! 2)'
13:21:35 <Igloo> sounds like you need fromInteger (b !! 2)
13:25:22 <Darius> what is the declaration of b?
13:25:48 <Darius> or definition
13:27:38 <Ar_Pharazon> b is just a list of Integers .. let b = [0,3,2,1]
13:27:46 <Darius> and what's the context for that error?
13:28:03 <Ar_Pharazon> basically the foldr expression you have me
13:28:47 <Ar_Pharazon> or the expression i gave you that prompted you to give it to me: a!!(b!!(c!!2)) for example
13:31:45 <Ar_Pharazon> foldr (fromInteger . !!) 2 [a,b,c] would work, except, well, it doesn't ;)
13:33:45 <Igloo> You mean fromInteger . (!!), only you don't because that won't work either
13:34:46 <Ar_Pharazon> because !! is considered an operator instead of a function?
13:34:57 <Igloo> Yes
13:35:05 <Darius> well, you could try adding "default (Int)", or add a type to b ("let b= [0,3,2,1] :: [Int]"), or give permute type [[Int]] -> [Int]
13:35:08 <Igloo> That's why you need the parentheses
13:36:45 <Darius> It should be able to put the pieces together with that
13:37:10 <Ar_Pharazon> haha, hmm, ok, I appologize for being an idiot and not trying let b= [0,3,2,1] :: [Int] before, I think I did let b= [0,3,2,1] :: Int or something
13:39:49 <Darius> See if default (Int) works.  It's probably a good idea in general anyways, unless you really need arbitrary Integers
13:41:07 <Darius> though Integer is a bit safer
13:45:16 <Ar_Pharazon> so you're saying just type "default (Int)" in the interpreter, or add it in a source file?
13:46:19 <Marvin--> that default declaration is really scary
13:47:39 <Ar_Pharazon> how do I use it?  typing in "default (Int)" in an interpreter gives me a parse error
13:47:41 <Darius> it probably needs to be in the source file
13:47:45 <Ar_Pharazon> ah
13:51:18 <Ar_Pharazon> I guess it will work if I put it in another source file where the variables are declared, but not if it is just put in permute's source file.
13:53:30 <Ar_Pharazon> but now i have a permute function that works!
13:54:48 <Darius> My character map has Telugu... ?
13:56:20 <Darius> no, not Telugu
13:57:18 <Darius> Arabic, which is more bizarre
14:10:28 * Marvin-- finds an old amusing /. comment
14:10:33 <shapr> w00, it works
14:12:45 * shapr boings happily
14:13:17 * Janni bounces greetingly
14:13:26 <shapr> my mailing list plugin works!
14:13:45 <shapr> it needs some more polishing, but it works!
14:13:52 <Janni> cool. how does it find suitable keywords?
14:14:09 <shapr> it cuts every message up with words
14:14:20 <shapr> I'll check it in, just a moment
14:14:22 <Marvin--> "SKY have just won the rights to screen the World Origami Championships from Tokyo. - Unfortunately it's only available on Paper View."
14:14:29 <shapr> Marvin--: HA
14:14:56 <Janni> HA?
14:15:01 <Janni> *checking lambdabot*
14:15:04 <shapr> very funny
14:15:46 <Janni> Will you implement one-word questions? I think that's really useful
14:15:49 <shapr> lambdabot will be back when it's done building the FM for the haskell mailing list
14:16:03 <shapr> ah here it is
14:16:22 <shapr> WARNING: showml will paste the ENTIRE email
14:16:35 <shapr> lambdabot: @searchml dynamic types
14:16:36 <lambdabot> 2099 2075 2071 1897 1835 1834 1658 1626 1624 1580 1576 1567 1564 1488 1481 1443 1442 693 597 287 253 153 58
14:16:41 <Janni> lambdabot: @listcommands
14:16:41 <lambdabot> I react to the following commands: ["define","definitions","echo","eval","fact","fortune","get-definition","goodbye","hello","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","msg","part","quit","searchml","set-fuel","showml","state","topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type"]
14:16:52 <Darius> did you find a way to persist the index?
14:16:55 <shapr> nope
14:17:04 <shapr> it's still being built every startup
14:17:33 <shapr> lambdabot: @searchml lambdabot
14:17:33 <lambdabot> 2136
14:17:34 <Janni> lambdabot: @searchml irc bot
14:17:35 <lambdabot> 2136
14:17:37 <Igloo> Is "dynamic types" a literla string or the intersectino of the two words?
14:17:48 <shapr> intersection
14:18:06 <shapr> it's just a word index
14:18:29 <shapr> lambdabot: @showml 2136
14:18:35 <shapr> too much spam
14:18:50 <Igloo> Oh, do you lower-case anything?
14:18:56 <shapr> yes, everything
14:19:11 <Igloo> Ooops, that's what I meant  :-)
14:19:15 <Janni> I think lambdabot should also handle "/msg"d commands and /msg back
14:19:21 <shapr> it does
14:19:34 <Darius> soon lambdabot is going to be kicked for excess flood just for @listcommands
14:19:38 <Igloo> Does all the stuff to IRC go through a single function? If so it would be fairly easy to put flood limiting in
14:19:44 <Janni> Oh, yay!
14:19:56 <Igloo> It's just number of lines i believe
14:20:03 <shapr> Darius: I can barely wait =)
14:20:15 <Janni> Then the feature list was the answer to @showml 2136 and not only a default answer to /msgs :)
14:22:53 <Darius> the next release can have the motto, "lambdabot: feeping creaturitis personified"
14:23:17 <shapr> heh
14:23:21 <shapr> good idea
14:26:44 <shapr> ok, the module is in cvs
14:33:02 * shapr reads the TypeModule and *laughs*
14:33:36 <Darius> some literate haskell action
14:34:24 <shapr> haskell module as short story
14:37:44 <Marvin--> someone who doesn't know about liftIO?
14:37:55 <shapr> where?
14:38:02 <Marvin--> lift.lift $ popen
14:38:28 <shapr> oh, I dunno
14:39:06 <Marvin--> lambdabot: @type liftIO
14:39:14 <Marvin--> what was it, type-from?
14:39:17 <shapr> yup
14:39:22 <Marvin--> lambdabot: @type-from MonadTrans liftIO
14:39:22 <lambdabot> Sorry, I don't know that command, try "lambdabot: @listcommands"
14:39:27 <shapr> lambdabot: @listcommands type
14:39:27 <lambdabot> Module type provides the following commands: ["type"]
14:39:31 <shapr> oh, hm
14:39:57 * psy ughs
14:40:10 <shapr> I guess he hasn't checked in the new code
14:40:19 * Marvin-- growls
14:43:16 <shapr> if we keep adding lambdabot plugins this quickly, we'll need another release next weekend
14:43:32 <Marvin--> yay, bloatware
14:43:32 <shapr> lambdabot: @listmodules
14:43:32 <lambdabot> I have the following modules installed: ["eval","fact","fortune","hello","karma","searchml","state","system","topic","type"]
14:44:14 <Marvin--> system?
14:44:24 <Riastradh> Main.hs:59:
14:44:28 <shapr> I'm planning on factoring fortune and searchml modules out into separate Haskell apps
14:44:28 * Darius watches as time goes from 0 to 234987 min on a big move in windows
14:44:34 <Riastradh>    No instance for (Module MODULE)
14:44:50 <Riastradh>    arising from the use of `hook_message' at Main.hs:59
14:44:58 <Riastradh>    In the first argument of `doHooks', namely `hook_message'
14:45:08 <Riastradh>    In a 'do' expression pattern binding: doHooks hook_message msg
14:45:17 <shapr> lambdabot: @listcommands system
14:45:18 <lambdabot> Module system provides the following commands: ["listchans","listmodules","listcommands","join","leave","part","msg","quit","echo"]
14:45:26 <Riastradh> The 'do' expression is:
14:45:29 <Riastradh> do msg <- ircRead
14:45:37 <Riastradh>    doHooks hook_message msg
14:45:43 <Riastradh>    let cmd = msgCommand msg
14:45:48 <Riastradh>    ... dispatch on the message ...,
14:45:53 <Riastradh> s/,//1
14:46:02 <Riastradh> I already pasted 'doHooks,' I think.
14:46:34 <shapr> that's a strange error
14:47:16 <Riastradh> hook_message, declared in the Module type class (Module m), has a type of: m -> IRCMessage -> IRC ()
14:47:49 <shapr> I don't understand what the problem is
14:47:56 <Riastradh> Nor do I.  That's why I'm asking.
14:48:09 <Riastradh> If you want it, doHooks is defined as:
14:48:12 <Riastradh> doHooks f msg =
14:48:15 <Riastradh>     do s <- get
14:48:26 <Riastradh>        mapM_ (\mod -> f mod msg) . eltsFM $ ircModules s
14:50:50 <shapr> I don't have any clues :-(
14:51:00 <Marvin--> sheesh
14:51:06 * Marvin-- educates a friend about Jabberwocky
14:51:11 <Riastradh> !!
14:51:15 <Riastradh> They knew not of it?!
14:51:24 <Marvin--> apparently not
14:51:30 <Riastradh> Blasphemy!
14:51:36 <Riastradh> http://www.damnsw.net/~campbell/jabberwocky.html
14:51:41 <shapr> I would rip out some stuff until it works, and then add until it doesn't
14:51:43 <Marvin--> already gave him a link :)
14:52:02 <Riastradh> Oh, darn.
14:52:22 <Marvin--> One, two! One, two! And through and through
14:52:38 <Riastradh> ...the vorpal blade went snicker-snack!
14:52:45 <Riastradh> He left it dead, and with its head, he went galumphing back.
14:52:51 <shapr> callooh, callay
14:53:14 <Riastradh> 'And thou hast slain the Jabberwock?  Come to my arms, my beamish boy!  Callooh, callay!  O Frabjous Day!'  He chortled in his joy.
14:57:03 <lament> chortled.
14:57:34 <Riastradh> Chortled.
14:57:40 <lament> chortled.
14:58:11 <Riastradh> Chortled.
14:58:26 <lament> chortled.
14:59:00 <Riastradh> Chortled.
14:59:32 <lament> chortled.
14:59:43 * psy chortles
15:00:04 * shapr swears at his keyoar
15:00:04 <psy> chortle is the emote i use most when mudding :)
15:00:22 <psy> pfft, mine is still broken from that encounter the other night
15:00:34 <shapr> ut you can type all your letters, right?
15:00:40 <psy> letters yes
15:00:47 <psy> i'm missing numbers and the odd f-keys
15:00:59 <shapr> I on't use numers much when coing
15:01:16 <psy> i on't either but numbers are pretty handing when udding
15:01:17 <shapr> ut I o use consonants oten.
15:01:30 <psy> s/handing/handy
15:01:40 <shapr> I wat to coe!
15:01:41 <shapr> argh
15:01:50 <psy> learn brainfuck
15:01:52 <psy> :)
15:01:54 <shapr> :-P
15:01:55 <psy> or whitespace!
15:02:47 <psy> also i have no escape :/
15:17:18 <Igloo> Is pesco around?
15:38:25 <Ar_Pharazon> anyone have a copy of Erik Meijer's paper on CGI/Haskell?  The link to it on his site seems to be invalid.
15:38:56 <kunphuzil> Ar_Pharazon: Google
15:40:32 <Ar_Pharazon> interesting, he works at MS now 
15:47:28 <shapr> hey Jerub 
15:47:29 <shapr> ltns
15:47:40 <Jerub> heya shapr.
15:47:59 <Jerub> soemone came into an arbitary channel on another network, asking for haskell help, so I told him to come here.
15:47:59 <shapr> wassup?
15:48:09 <shapr> yah, I like it.
15:48:34 * shapr wiggles his keyoar connector
15:48:38 * Jerub looks at topic.
15:49:08 <Ar_Pharazon> has anyone used Mondrian with Mono or something else on a GNU system? 
15:49:08 <Jerub> not much important has changed ;)
15:49:21 * Darius does some crazy file rearranging to stuff 40GB in 30
15:50:54 <Jerub> keyoar?
15:51:09 <shapr> some keys are roken
15:51:33 <Jerub> no d or b?
15:51:41 <Jerub> poor shapr.
15:51:48 <Jerub> my keyboard doesn't have right control, left alt or {tilde}
15:52:19 <Jerub> and F1 and F2 are borked I think
15:52:30 <Jerub> its weird having to do control-d with the opposite control key
15:53:40 * shapr gives up, switches to backup keyboard
15:53:51 <Darius> I (almost) always use the left modifier keys
15:54:01 <shapr> Jerub: did you see the lambdabot 1.0 announcement?
15:54:31 <shapr> lambdabot: @listcommands
15:54:31 <lambdabot> I react to the following commands: ["define","definitions","echo","eval","fact","fortune","get-definition","goodbye","hello","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","msg","part","quit","searchml","set-fuel","showml","state","topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type"]
15:54:32 <Jerub> no.
15:55:04 <shapr> lambdabot: @fact lambdabot
15:55:05 <lambdabot> the coolest (only) irc 'bot written in Haskell., is rude, now with 20% more FM goodness
15:55:29 <shapr> lots of goodness with lambdabot
15:56:02 <Riastradh> lambdabot: @listmodules
15:56:02 <lambdabot> I have the following modules installed: ["eval","fact","fortune","hello","karma","searchml","state","system","topic","type"]
15:56:18 <shapr> searchml is new
15:56:18 <Jerub> lambdabot: echo foldr ++ '' ['a','b','c']
15:56:18 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
15:56:37 <Jerub> lambdabot: @eval foldr ++ '' ['a','b','c']
15:56:38 <lambdabot> (line 1, column 8):
15:56:38 <lambdabot> unexpected "+"
15:56:38 <lambdabot> expecting simple term
15:56:50 <shapr> and will take three minutes to start up while it builds a keyword index of 16mb of haskell mailing list
15:57:23 <Darius> (extended) lambda calculus (for now)
15:57:26 <Riastradh> lambdabot: @eval foldr (++) "" ["a", "b", "c"]
15:57:26 <lambdabot> (line 1, column 8):
15:57:26 <lambdabot> unexpected "+"
15:57:26 <lambdabot> expecting white space or simple term
15:57:49 <shapr> maybe I should write the @help plugin now
15:58:16 <Darius> lambdabot: @fact eval-example
15:58:16 <lambdabot> (\f.(\x.f(x x))(\x.f(x x)))(\fac acc n.if n == 0 then acc else fac (n*acc) (n-1)) 1 100
15:58:57 <shapr> lambdabot: @eval (\f.(\x.f(x x))(\x.f(x x)))(\fac acc n.if n == 0 then acc else fac (n*acc) (n-1)) 1 100
15:58:57 <lambdabot> 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000
15:59:02 <shapr> whee
15:59:29 <shapr> lambdabot: @fact source
15:59:29 <lambdabot>  http://sf.net/projects/haskell-libs/, http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/lambdabot/
16:00:08 <Darius> shapr: did you do full update before the last build or so?
16:00:29 <shapr> yup, has the latest Eval
16:01:39 <shapr> lambdabot: @fact authors
16:01:40 <lambdabot> Nothing
16:02:38 <shapr> I think I'll fix the output limiting, then searchml will be useful
16:03:04 <Riastradh> lambdabot: @define Y (\f.f (Y f))
16:03:04 <lambdabot> Y defined
16:03:20 <Darius> at the risk of killing lambdabot, a test
16:03:38 <shapr> whee
16:03:40 <Riastradh> Is the Lambda-Calculus evaluator lazy?
16:04:05 <Darius> of course!
16:04:17 <Riastradh> OK, just making sure.
16:04:37 <Darius> lambdabot: @define a a
16:04:37 <lambdabot> a defined
16:04:38 <shapr> hm, sleep or code...
16:04:42 <Riastradh> Er, oops, will (\f.f (Y f)) work?
16:04:58 <Darius> yes
16:05:10 <Riastradh> Oh.
16:05:12 <Darius> lambdabot: @eval a
16:05:13 <lambdabot> out of fuel
16:05:16 <Riastradh> But that kind of defeats the purpose of Y, doesn't it?
16:05:17 <shapr> yay!
16:05:22 <shapr> Darius: you fixed it!
16:05:39 <shapr> lament: @define b b + 1
16:05:43 <shapr> er
16:05:48 <lament> ok.
16:05:49 <shapr> lambdabot: @define b b + 1
16:05:50 <lambdabot> b defined
16:05:53 <shapr> lament: :-PP
16:05:59 <shapr> lambdabot: @eval b
16:05:59 <lambdabot> out of fuel
16:06:43 <Riastradh> shapr: @listmodules
16:07:08 <shapr> ["haskell","java","socialskills"]
16:07:28 <lament> Riastradh: @quit
16:07:28 <shapr> :
16:07:32 * shapr laughs
16:07:33 <Riastradh> Socialskills?  What a useless module.
16:07:49 <shapr> Riastradh: it's useful for live-in fiancees
16:07:50 <Riastradh> lament: sorry, not enough privileges.
16:08:01 * shapr laughs more
16:08:07 <lament> bye
16:08:10 <lament> er
16:08:16 <lament> sorry wrong window
16:13:09 <shapr> gee, how do I do rate limiting?
16:22:51 <shapr> lambdabot has no concept of delay
16:23:26 * Darius wonders where winzip is sticking these gigs
16:23:41 * shapr has an idea
16:26:03 * shapr starts writing @more
16:28:01 <Riastradh> @more?
16:28:09 <shapr> sure
16:28:24 <shapr> Riastradh: I'm going to extend ircPrivmsg' to collect the lines
16:28:29 <shapr> and only send a certain amount
16:28:43 <shapr> then it'll stuff the rest into a ModuleState for "more"
16:29:13 <shapr> after which @more will send another chunk less than the flood limit
16:29:17 <shapr> what do you think?
16:29:22 <Riastradh> OK.
16:29:29 <shapr> seems sane?
16:29:45 <Riastradh> Whatever.
16:29:53 <shapr> can you think of a better way to do it?
16:29:57 <Riastradh> Nope.
16:30:01 <shapr> ok :-)
16:30:15 <shapr> hey, do you have your new module code online?
16:30:23 <shapr> I can help with it now, if you have time
16:31:56 <Riastradh> http://www.bloodandcoffee.net/campbell/code/lambdabot+hooks.tar.gz
16:42:06 <shapr> hello jlk 
16:42:10 <jlk> hi
16:42:24 <shapr> you're the first aol user to arrive on #haskell
16:42:31 <shapr> I think we've hit the big time.
16:42:51 <jlk> hehe.
16:43:10 <jlk> well, this is the story, i'm an out of work programmer using aol's free 45 day trial.
16:43:20 <shapr> oh
16:43:23 <shapr> smart move
16:44:04 <jlk> dennisb are you there?
16:45:04 <Darius> msg?
16:45:36 <shapr> I was showing off @showml on another channel
16:45:45 <shapr> with the expected result :-(
16:46:06 <Darius> ah, which channel?
16:46:13 <shapr> #think
17:05:44 <shapr> no pasta for us tonite
17:05:53 <Riastradh> shapr, what have you to say of the code
17:05:54 <Riastradh> ?
17:06:15 <shapr> I'm commenting out all the hook calls and recompiling
17:06:17 <shapr> hopefully
17:12:40 <Igloo> What code is this?
17:12:51 <Riastradh> http://www.bloodandcoffee.net/campbell/code/lambdabot+hooks.tar.gz
17:15:05 <Igloo> I was hoping for a 10 word summary  :-)
17:15:07 <shapr> I would have gotten one hook call to work before writing all of them :-)
17:15:07 <shapr> did they work at one point?
17:15:45 <Riastradh> No.
17:16:11 <shapr> Igloo: hey, have you looked at the lambdabot source?
17:16:11 <shapr> if so, do you have any suggestions?
17:16:14 <Riastradh> But hey, C-M-% works fine.
17:17:00 <Igloo> No, sorry
17:17:03 <Igloo> (to the first one)
17:25:51 <Riastradh> What's 'eta-reduction?'
17:27:40 <Igloo> \x -> f x     =>      f
17:27:49 <Riastradh> Are there any other kinds of reduction?
17:27:55 <Darius> beta
17:28:01 <Riastradh> Er, other than alpha, beta, and eta.
17:28:17 <Igloo> Those are the 3 most common transformations
17:28:28 <Igloo> alpha isn't reduction, though
17:28:38 <Igloo> And eta is used both ways
17:30:07 <Darius> you eta expand when the monomorphism restriction bites you in Haskell
17:30:52 <Igloo> Well, if writing code by hand I'd say adding a type signature was nicer
17:31:16 <Igloo> Particularly if it's not already a function
17:31:48 <shapr> Riastradh: I think I know how to fix it
17:32:10 <shapr> Riastradh: it's getting MODULE but it wants an instance of Module
17:33:10 <Riastradh> Ah, right, because ircModules is a finite map of String and MODULE.
17:33:59 <shapr> I think (MODULE mod) might work
17:34:02 <shapr> not sure about that
17:34:59 <Darius> Igloo: sometimes the robustness (to change) is preferable, other times it's just easier and quicker than figuring out the type
17:35:22 <shapr> lambdabot: @searchml igloo
17:35:22 <lambdabot> 1729
17:35:47 <shapr> aha
17:35:50 <Igloo> Fair enough
17:36:02 <shapr> Igloo: 1729 is the IOHCC announcement
17:36:27 <shapr> it gives nick/name pairs
17:36:37 <Igloo> Ah, right
17:37:15 <Riastradh> shapr - Not:  (ircModules s :: FiniteMap String ((Module m) => m)) ?  That is, could I not force that type?
17:37:29 <shapr> Riastradh: that might work
17:37:39 <shapr> (MODULE m) doesn't work
17:37:48 <shapr> I think it should though...
17:38:17 * Riastradh tries it.
17:38:33 <shapr> I think this should work (but it doesn't) -> processM (MODULE mod) = process mod
17:39:41 <shapr> yes, that really should work...
17:39:44 <Riastradh> You think it should work, but it doesn't?
17:40:13 <shapr> yes, 4am is getting in the way.
17:40:15 <Vincenz> Hiya!
17:40:18 <Riastradh> Heh.
17:40:20 <Vincenz> it's 3:40 am
17:40:24 <Vincenz> just came back from the pubs
17:40:25 <Vincenz> :)
17:40:25 <shapr> close enough
17:40:29 <shapr> hi Vincenz 
17:40:35 <Vincenz> :P
17:40:39 <shapr> hm, I have a beer here.
17:40:41 * Riastradh should move to Sweden so he can get the useful info he needs from shapr when they're both awake.
17:40:42 <shapr> it's an import though.
17:40:46 <shapr> Riastradh: heh :-)
17:40:56 <Riastradh> And then I could far more easily go to the ICFP.
17:41:18 <shapr> yes, truly
17:41:25 <Riastradh> And I wouldn't have to live under the reign of Dubya, either.
17:41:31 <shapr> my import beer is a budweiser
17:42:01 <shapr> I'm happy to be living outside of the US at the moment :-(
17:43:06 * Riastradh is happy to at least be living in a fairly liberal place in the U.S.
17:43:43 <shapr> Riastradh: look at the functions that take (MODULE m) on the left hand side
17:44:00 <shapr> I think you can use that same pattern to make doHooks work
17:44:05 <Riastradh> On the 'left hand' side?
17:44:13 * Darius is happy to be living in a fairly diverse place
17:44:44 <shapr> er, pattern matching (MODULE m)
17:44:53 <shapr> for example, ircLoadModule
17:44:58 <shapr> in the Just case
17:45:25 <shapr> case why of Just cause -> why
17:45:28 * shapr snickers
17:45:34 <shapr> ok, I obviously need sleep
17:45:44 <shapr> Just 'cause is funny
17:46:17 <Vincenz> jeje
17:46:19 <Vincenz> hehe
17:46:22 <Vincenz> me too
17:46:24 <Vincenz> but I'm sticking strong
17:47:03 <shapr> je donc dorm
17:47:06 <shapr> or something like that
17:47:12 <shapr> jag maste sover
17:47:32 <Vincenz> je pense donc je suis
17:47:32 <Vincenz> :)
17:47:43 <shapr> I meant dois
17:47:49 <shapr> je dois dorm
17:47:59 <shapr> ik ben een buitenlander!
17:48:04 <Riastradh> Je deteste francias, fripons!
17:48:12 <Riastradh> s/ia/ai/1
17:48:29 <shapr> j'aime les française
17:48:51 <shapr> g'nite all
17:49:18 * shapr falls over asleep
17:51:03 * Riastradh wonders whom he could get funding from to go to the ICFP...
