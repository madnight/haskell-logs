00:06:42 <keir> http://haskell.org/hawiki/WikiSandBox
00:06:46 <keir> at the bottom i posted the code
00:06:52 <keir> it's fairly simple
00:06:59 <keir> just an expression evaluator
00:07:11 <keir> (not parser)
00:08:17 <dennisb> keir: each st-computation get the Int as an input and gives the result and an Int as the output
00:09:04 <dennisb> the monad makes sure that the output state of one St-computation is passed in into the next St-computation as input
00:11:00 <keir> hrm. but the tick is not part of the return
00:11:17 <keir> so how can the evalSt calls in the recursing tree pass the new state outward?
00:12:12 <dennisb> it is part of the return
00:12:41 <keir> ok i must be misunderstanding some fundamental part of monads
00:12:43 <dennisb> return is probably implemented as return x = MkSt (\s -> (x,s))
00:13:14 <dennisb> that is, the return value and the current state is the end result
00:13:58 <dennisb> in the example, the code for >>= and return is missing
00:14:04 <keir> ah, yes
00:14:07 <keir> now i see
00:14:11 <keir> and i feel enlightened
00:14:17 <keir> this is what return is for!
00:14:23 <keir> it threads states
00:14:37 <dennisb> and the trick is that the monad hides all the work with the state from the user of the monad
00:14:52 <dennisb> that is what makes it useful of course
00:14:53 <keir> yes! aaaaah
00:14:58 * keir feels better 
00:15:48 <keir> instance Monad St where
00:16:02 <keir>   return x = MkSt f   where f s = (x,s)
00:16:09 <keir> so that's it
00:16:17 <keir> same as what you wrote
00:16:33 <dennisb> yes, and the >>= runs the thing on the left and passes the state on to the thing to the right
00:16:48 <keir> this book never seems to do lambda notation... too bad.
00:17:12 <phubuh> I've found that lambda notation isn't actually used much in practice
00:17:27 <dennisb> for a small function like that I just think it's clearer to use lambda-notation
00:17:45 <phubuh> but admittedly, f in that example should be one :-)
00:24:03 <magr> good morning, #haskell
00:24:08 <phubuh> hi magr!
00:34:44 <keir> is there any way of getting aronud the MkSt stuff?
00:34:51 <keir> ie Mk*
00:35:40 <Marvin--> depends, what do you mean?
00:37:34 <keir> it just seems like extra verbosity that isn't necessary?
00:37:34 <keir> ie
00:38:02 <keir> newtype Parser a = MkP(String -> [(a,String)])
00:38:12 <Marvin--> well
00:38:29 <Marvin--> if MkP wasn't there, there would be nothing to make Parser unique
00:38:38 <Marvin--> it would be the same as any old String -> [(a,String)] function
00:38:57 <keir> but why does that matter?
00:39:01 <keir> why not just use 
00:39:23 <keir> type Parser a = String -> Maybe(a, String)
00:39:39 <Marvin--> because you might also want type Somethingelse a = String -> Maybe (a,String)
00:39:55 <Marvin--> and if you want them to have different instances of classes, they have to be unique
00:40:04 <Marvin--> without newtype/data and a constructor they aren't
00:40:06 <keir> so this way, Parser becomes distinct so we can define different >>= etc?
00:40:11 <Marvin--> exactly
00:42:10 <keir> ok
00:42:57 <Marvin--> when you add modularity it becomes even more interesting, because you can export types without exporting their constructors
00:43:10 <Marvin--> and if you have a datatype with more than one constructor, you can choose which constructors to export
00:45:08 <keir> interesting
00:46:24 <keir> wow, monads are cool. parsing with monads is neat
00:46:45 <Marvin--> indeed
00:46:46 <keir> just define the good ole' bind operation and you get a nice parse tree if you feed in a bunch of parsers
00:58:08 <keir> i guess continuations would let you implement GOTO's inside do statements
00:58:15 <keir> now that would be funny
00:58:44 <andersca> I think I understand continuations as of today
01:00:14 <keir> so now that i think i understand monads, is it correct to say that monads are essentially similar to continuations? and monads in haskell are the reason there isn't call/cc in haskell?
01:00:38 <keir> (call/cc as in scheme's call-with-current-continuation)
01:07:55 <musasabi> imho they are quite different approaches
01:08:55 <Marvin--> different things
01:09:15 <Marvin--> you can, however, implement a continuation monad transformer that even has call/cc
01:09:50 <Marvin--> http://haskell.org/hawiki/MonadicContinuationPassingStyle
01:27:56 <keir> does space bind more tightly than .
01:27:57 <keir> ?
01:28:10 <Marvin--> function application binds tighter than operator application, yes
01:28:19 <keir> ie, a.b c === a(b c)
01:28:30 <Marvin--> yep
01:28:52 <Marvin--> (unless it's a . qualifier, like Control.Monad.foldM or something)
01:42:01 <keir> i have a definition like
01:42:01 <keir> item              :: Parser Char
01:42:11 <keir> now, i want to actually use this function
01:43:02 <keir> the book shows 'item "hello"' ===> [("h","ello")]
01:43:17 <keir> yet ghci/hugs give me errors: Parser Char != a -> b
01:43:23 <keir> which makes sense
01:45:13 <keir> nevermind
01:45:25 <keir> it's 5am here so i'm not running at full clock speed
02:05:47 <Marvin--> yeah, well, we slapped a constructor on the function, didn't we? :)
02:06:23 <keir> the funny thing is, the book uses the constructor too
02:06:38 <keir> so the way it's presented is a bit misleading
02:06:41 <Marvin--> then the book is wrong
02:06:44 <Marvin--> yeah
02:06:52 <keir> that's why i was confused.
02:07:04 <Marvin--> it should be clearer about the list with the pair is just an internal state
02:07:37 <keir> it's funny, i still haven't read a monad tutorial that ties the state idea down with code that i understood
02:08:08 <keir> ie, threading states
02:09:05 <Marvin--> http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm <- I like this tutorial
02:09:48 * Marvin-- wonders off in search of coffee
02:09:55 <Marvin--> er, s/wonder/wander/
02:12:48 <keir> i think that tutorial -still- misses it
02:12:51 <keir> just a bit
02:13:05 <keir> they should start out with a monadic statement like:
02:13:15 <keir> do {tick; tock; thecat; isback;}
02:13:25 <keir> ie, no assignments
02:13:50 <keir> and try to hammer home the idea that the state gets implicity passed downward, like a hot potato or something
02:13:51 <Marvin--> I'm not sure what that would buy
02:14:18 <Marvin--> in an imperative program you typically have both implicit and explicit state
02:39:56 <_joey> could someone recommend a book on Haskell?
02:40:38 <keir> i've found Introduction to Functional Programming using Haskell by Richard Bird to not be too bad
02:40:48 <keir> and the multimedia one is good if you have time to do the excercises
02:41:29 <_joey> what the authority book, if there's one?
02:41:49 <Marvin--> I don't think there is a "standard" book
02:42:28 <Marvin--> my first haskell book was The Craft of Functional Programming by Thompson and I found it pretty good
02:46:45 <_joey> keir: multimedia one by Paul Hudak?
02:47:07 <keir> yeah
02:47:31 <_joey> would anyone know why CS course would teach Haskell in 1semester 1 year
02:48:16 <Marvin--> what do you mean? why not?
02:48:36 <_joey> it's usually procedrual language, OO paradigm
02:48:41 <keir> yeah, what's wrong with haskell?
02:48:46 <_joey> Java/C++/Ada95
02:48:57 <keir> cs people will see OO for the rest of their lives
02:49:05 <keir> uni is a nice chance to broaden their scope
02:49:06 <keir> haha
02:49:23 * keir hangs head in bad pun shame
02:49:24 <_joey> not in our course
02:49:39 <Marvin--> in Gothenburg we do Haskell first half of the first semester and java the second half
02:49:43 <_joey> huskell 1st semester, C 2n semester, the rest is math
02:49:45 <Marvin--> keir: yeah, go stand in the corner!
02:49:59 <_joey> Haskell rather
02:50:10 <_joey> damn I can't even spell the name of this language:)
02:53:39 <_joey> http://www.cse.unsw.edu.au/~cs1711/schedule.html
02:54:13 <keir> they don't even cover monads
02:54:16 <keir> you have it easy!
02:54:24 <keir> just use the online haskell stuff
02:54:27 <_joey> that's introduction subject
03:11:03 <_joey> keir: what compiler do you use?
03:11:59 <_joey> hehe
03:12:24 <_joey> tutorial on haskell.org/learning.html is from our University
03:13:30 <keir> ghc
03:42:19 * Marvin-- sighs and swears
04:30:32 * shapr swears and bounces
04:30:49 <shapr> goood morning #haskell!
04:31:12 <Lor> Slept late?
04:31:22 <shapr> just got back from svenska skolan
04:32:12 <shapr> Lor: kan du tala svenska ocksa? :-)
04:33:05 <shapr> I doubt I'll get a degree in swedish literature, but it sure is fun to speak the language
04:34:02 <Lor> Hereabout's it's obligatory for everyone, so it's not very much liked.
04:34:11 <Lor> abouts
04:36:08 <shapr> yah, too ba
04:36:09 <shapr> d
04:36:13 <shapr> I think languages are nifty.
04:36:22 <shapr> forcing someone to do something isn't though
04:38:47 <Marvin--> forcing and forcing
04:39:00 <Marvin--> aren't both Finnish and Swedish official languages in Finland?
04:39:07 <Marvin--> thus, you learn both languages in school?
04:39:31 <Marvin--> I mean, the real question is, should really Swedish be an official language in Finland or not?
04:39:45 <Lor> We are supposed to learn them both at school. The actual reality might be somewhat different.
04:39:46 <shapr> yes, but in my experience in Tornio, no one actually learned Swedish unless they were planning on going into internation .fi-.se business.
04:39:54 <andersca> Marvin--: samiska is an official language in sweden
04:40:10 <shapr> s/internation/international
04:40:53 <shapr> Linus only speaks swedish, right?
04:41:08 <andersca> no, he speaks finnish too
04:41:16 <shapr> ah
04:41:21 <Marvin--> andersca: not to the same degree. IIRC, official documents in Finland have to be made available in Swedish as well as Finnish, this is not the case with samiska in Sweden
04:41:40 <Lor> Linus is pretty much bilingual, I think.
04:42:26 <andersca> he speaks english too
04:42:34 * andersca talked to him in swedish when he met hinm
04:44:59 <Marvin--> hm, if you don't give fixities for operators, they are applied left-to-right?
04:45:12 <andersca> yeah, I think so
04:45:38 <Marvin--> I mean, if I say   x `f` y `g` z  without giving fixities for `f` and `g` this would be   g (f x y) z  rather than f x (g y z)  ?
04:46:31 <andersca> hmm
04:46:58 <Lor> Anyone know a lightweight browser that supports ssl and authentication?
04:47:14 <Marvin--> lynx?
04:47:14 <Lor> Dillo is nice and lightweight, but lacks these.
04:49:37 <Lor> I'd prefer one with mouse support.
04:49:55 <Marvin--> lynx has mouse support :P
04:50:11 <Marvin--> but seriously, if you ask dumb questions you get dumb answers :)
04:50:15 <Marvin--> try being more specific
04:50:35 <Marvin--> I use Galeon, which IMO is more lightweight than Mozilla, but not as lightweight as Epiphany
04:50:44 <Lor> galeon is no longer lightweight.
04:50:50 <Lor> At startup, its RSS is 20 megs.
04:51:23 <Lor> The older galeon might be better, but it would be somewhat hard to install.
04:53:35 <Marvin--> lightweight isn't an absolute, it's relative
04:54:23 <shapr> I just posted that antispam server idea in a reply on slashdot.org, where's my asbestos underwear...
04:54:26 <Lor> Well, I need something that's lightweight relative to my 96 megs of ram.
04:54:34 <shapr> grail?
04:56:26 <Lor> Um. It seems kind of dead.
04:56:44 <Lor> Or at least the latest release is from 2000.
05:00:59 <shapr> otoh, it's written entirely in python
05:01:06 <shapr> and Marvin-- wrote PySSL I think?
05:01:16 <shapr> so it would probably be easy to integrate
05:01:36 <Marvin--> no, not PySSL, pyOpenSSL
05:01:49 <shapr> ah, sorry
05:02:01 <Marvin--> (which, incidentally has an RC bug right now *sigh*)
05:35:10 <Lunar^> Just added something in FfiTutorial on hawiki
05:37:55 * shapr looks
05:38:49 <shapr> neat
05:39:12 <Lunar^> thanks :)
05:39:21 <Lunar^> anyway, FFI is pretty easy
05:41:42 <shapr> I haven't tried it, so I don't know, but I'll try out your code sometime soon.
05:45:05 <Lunar^> Refresh
05:45:13 <Lunar^> I gave the compilation line
05:45:46 <shapr> nice illustration
05:46:18 <shapr> very informative
05:47:19 <Lunar^> Learned a lot on that point on hacking MySQL binding and writing the one for PDFLib
05:47:39 <Lunar^> That remembers me to send patch to HToolkit people
05:50:26 <phubuh> And Java is the only language whose memory management is more 
05:50:27 <phubuh> > advanced than 1968-era LISP.
05:50:31 <phubuh> memorable quote from the caml mailing list :-)
05:50:40 <Lunar^> ????
05:51:03 <phubuh> they were actually talking about -mainstream- languages -- he probably just forgot the word 'mainstream', but it's funny
05:51:12 <Lunar^> yes
05:56:40 <Lor> Hm. Maybe I should just use netscape 4. It's light enough, and supports ssl.
05:59:04 <harsha> hello all!
06:02:48 <harsha> shapr hi
06:12:22 <shapr> y0
06:14:19 <harsha> hey,sup?
06:20:15 <shapr> work!
06:36:53 <emu> what does vb use? a refcounter?
06:40:44 <phubuh> probably.
06:41:03 <phubuh> maybe it just leaves the garbage on the floor :-)
06:46:30 <emu> i suppose it would be disasterous for vb if it used a gc
06:48:35 <shapr> yup, it would collect itself and the operating system
07:01:42 <Lor> This c.l.f-c.l.l typing war is getting distasteful.
07:03:32 <emu> is it still going?
07:03:47 <Lor> Somewhat.
07:03:58 <emu> damn cross posting on cll made it impossible for me to keep up anymore
07:04:03 <emu> =)
07:04:22 <Lor> This is what always happens when someone crossposts between c.l.l and, um, just about anything. :)
07:05:51 <emu> this is by far the most i remember seeing
07:06:05 <shapr> lispers may have a flexible syntax, but their viewpoints ....
07:06:05 <emu> or maybe i'm just have less time these days
07:06:30 <emu> maybe i do too
07:08:05 <emu> the trouble is, some people come and spout various logical arguments why such-and-such language is better than lisp, and the lispers know from experience otherwise but can't quite explain it, so you end up with these ridiculously long threads trying to hash it out
07:08:39 <shapr> I think static typing is cute, but I really like purely functional code a lot.
07:14:27 <det> shapr, nice quote
07:14:35 <det> the lisp one :)
07:15:08 * mgoetze likes perls type system
07:15:10 * mgoetze runs :)
07:50:51 <Lor> To split or not to split? That is the question.
07:51:42 <keverets> On this network, the former is always the answer.
08:04:21 <mgoetze> keverets: all irc networks are like that :)
08:05:12 <shapr> IRC on IPv6 could multicast
08:05:19 * shapr loves the idea of true multicast
08:05:27 <Lunar^> :)
08:05:34 <Lunar^> That would not be IRC anymore
08:06:35 <shapr> IMC
08:06:39 <shapr> internet multicast chat
08:10:41 <Lunar^> IMC = IndyMedia Center
08:11:37 * Smerdyakov loves the idea of false multicast, to throw spies off the scent.
08:16:06 <shapr> I wish he'd stop doing that.
08:16:15 <shapr> it was funny the first time.
08:17:11 <shapr> @yow
08:17:11 <lambdabot> Now I understand the meaning of ``THE MOD SQUAD''!
08:17:47 <_joey> is there a free book on haskell?
08:17:53 <_joey> or would I have to buy one
08:19:10 <det> shapr, so, what do you think of the joy programming language ?
08:21:44 <shapr> det: it's a great toy, I'd like to use it for shell scripting.
08:22:06 <shapr> _joey: there are several tutorials on http://www.haskell.org/learning.html
08:22:20 <_joey> there's no book on that site
08:22:44 <shapr> have you tried YAHT, Two Dozen, and the Gentle Introduction?
08:23:00 <_joey> those are tutorials
08:23:06 <det> shapr, I came across it from a old mailing list thread when searching google, looks really interesting
08:23:23 <shapr> det: I started the #joy channel, but so far only one person has dropped by actually looking for Joy
08:23:33 <det> erm, anyone know how to move window #x to window #y in epic4 ?
08:23:58 <shapr> _joey: have you tried the tutorials?
08:24:09 <det> shapr: who are those people then
08:25:31 <shapr> now you know...
08:25:31 <_joey> that's quite disappointing, most langauges do provide a free book
08:25:48 <shapr> _joey: #haskell is free, we can help you through the rough spots in the tutorials.
08:25:58 <_joey> a couple, including one you mentioned
08:26:03 <_joey> they all sucked
08:26:08 <shapr> hi UdontKnow, want to learn Haskell?
08:26:17 <_joey> shapr: rough spots:)
08:26:29 <UdontKnow> hi shapr 
08:26:33 <shapr> _joey: how far have you gotten?
08:26:33 <_joey> I'm spared from rough spots 
08:26:45 <mgoetze> i think UdontKnow just wants to watch whether TITANIC returns :)
08:26:48 <_joey> shapr: don't bullshit man
08:26:56 <shapr> _joey: um, I'm not?
08:27:06 <_joey> if there s no book, say I am not aware of one
08:27:11 <UdontKnow> mgoetze: ideed... realname is 'unsinkable'. we'll see :P
08:27:52 <shapr> UdontKnow: you could still learn Haskell, it's spiffy ;-)
08:28:26 <shapr> _joey: I do not know of a free online book written for learning Haskell.
08:28:34 <UdontKnow> shapr: well. maybe... 
08:28:41 <shapr> I do know of several tutorials, and several people who have learned Haskell from those tutorials.
08:28:55 <Smerdyakov> I think "Two Dozen Lessons" could be counted as a book.
08:29:16 <Smerdyakov> But I also don't think talking about "online books" means anything in particular.
08:29:29 <Smerdyakov> There's no serious distinction between a "book" and a "tutorial" when both are online.
08:30:03 <shapr> _joey: if you prefer a print book, I'd suggest Hudak's School of Expression or Thompson's Craft book.
08:30:17 <shapr> yah, I agree with Smerdyakov, once it's online, there's not much difference.
08:31:31 <shapr> UdontKnow: would you like some introductory pamphlets? :-)
08:31:36 <det> UdontKnow: maybe that was his real intention, to draw you here to learn haskell, maybe TITANIC isn't such a bad guy after all ..
08:31:44 * shapr grins
08:31:52 <UdontKnow> heh
08:32:13 <shapr> UdontKnow: are you familiar with any programming languages?
08:32:53 <UdontKnow> ruby, C, pascal (ugh!), java, prolog, a bit of lisp, bash,...
08:33:12 <shapr> oh, you won't have much trouble with Haskell then.
08:33:44 <shapr> here's a tiny example based intro I wrote: http://purl.org/net/shapr/src/haskell/Demo.hs
08:33:50 <shapr> does that look interesting?
08:35:07 <_joey> Ruby is a beauty
08:35:36 * mgoetze|away heads off to play cards, expecting UdontKnow to be fluent in haskell when he gets back :)
08:36:29 <det> _joey: what is it you like about ruby ?
08:36:57 <_joey> clear syntax
08:37:15 <_joey> clean*
08:38:42 <UdontKnow> shapr: interesting :)
08:41:51 <UdontKnow> well, back later
08:42:49 <Lunar^> _joey: this apply to Haskell as well IMHO
08:47:10 <_joey> I wouldn't know
08:47:40 <_joey> I spent about an hour gathering information on it and installing compiler
08:47:51 <_joey> that's all my experience:)
08:48:28 <Cale> you might try one of the tutorials :)
09:06:40 <shapr> hi maximus 
09:07:09 <shapr> don't you hate it when paying work distracts you?
09:07:34 <maximus> hi shapr
09:09:50 <harsha123> shapr i have a question for you!
09:10:49 <phubuh> I just had a crazy dream
09:10:58 <phubuh> I had implemented monads in the C preprocessor
09:11:06 <harsha123> why would you use *Debian* to create a customized Linux CD ?
09:11:15 <harsha123> hey, this question is for everyone..!
09:11:47 <phubuh> it's small, for one, and doesn't need a whole C++ toolchain
09:11:50 <Lor> Customized for what?
09:12:36 <harsha123> Lor customized to do something that wanna do
09:12:46 <harsha123> Lor no specifics actually
09:15:21 <shapr> harsha123: isn't knoppix a Debian derivative?
09:15:43 <harsha123> shapr yes it is
09:15:58 <shapr> maybe they've already written something as to why they chose Debian?
09:16:18 <harsha123> shapr :) not a bad idea 
09:24:45 <scarface> harsha : hi
09:33:55 <shapr> hi scarface 
09:34:06 <scarface> hi shapr how r u?
09:34:51 <shapr> I'm awake!
09:36:53 <harsha123> shapr i induced scarface into haskell :)
09:37:00 <shapr> yay!
09:37:04 <shapr> you've been induced!
09:37:24 <shapr> scarface: so, have you written anything?
09:37:27 <harsha123> :) damn, am low on the learning curve. i need to dedicate more time on it
09:38:27 <scarface> shapr: im n illetrate..im juz tryin 2 gain sum knowledge before writing nething
09:38:38 <shapr> that's a good place to start.
09:38:42 <shapr> actually, it's the only place to start.
09:42:18 <scarface> shapr: any piece of advise?
09:42:58 <shapr> sure!
09:43:08 <shapr> have you installed GHC?
09:43:21 <shapr> have you grabbed one of the tutorials?
09:43:34 <shapr> do you have an idea in mind of something to write?
09:43:57 <scarface> shapr: yes i juz installed it..
09:44:39 <scarface> shapr: i did grab one of da tutorials..rt know i duno hav ne idea..
09:45:13 <scarface> shapr: can u recomend sum tutorials?
09:46:02 <shapr> I'd suggest "Yet Another Haskell Tutorial", "Two Dozen Lessons", and "The Gentle Introduction".
09:46:21 <shapr> also, I can point you to some simple Haskell programs that you can take apart
09:46:26 <scarface> shapr: thks.. 
09:46:31 <shapr> and play with in GHCi
09:47:21 <shapr> you can find some interesting stuff here: http://www.scannedinavian.org/~shae/src/haskell/
09:47:28 <scarface> shapr: dat wuld b extremli helpful
09:47:28 <shapr> for example, http://www.scannedinavian.org/~shae/src/haskell/Mandelbrot-0.1.hs
09:52:48 <scarface> shapr: mayb im bein greedy but nemore insights?
09:53:34 <Smerdyakov> scarface, if you need any more "insights," you are not ready to learn Haskell.
09:57:14 <scarface> smerdyakov: thks..
09:59:54 <Marvin--> scarface: are you allergic to vowels or something?
10:00:39 <scarface> marvin: i din realise that till now.. sorry..
10:01:06 <Marvin--> just curious :) I find it incredibly hard to spell that way
10:02:26 <scarface> marvin: i'll remember that...somehow got induced 2 skip vowels
10:08:54 <Cale> It's considered more polite to spell things out online - it makes things easier for people to read.
10:21:58 * shapr chortles merrily
11:13:58 * isomer bangs head on desk
11:19:39 <Tomasso> whats the sintax for case??
11:20:15 <phubuh> case foo of
11:20:19 <phubuh> Foo -> foo
11:20:22 <phubuh> Bar -> bar
11:20:45 <Tomasso> thank you ;D
11:20:48 <Tomasso> haha
11:21:43 <SyntaxPolice> w0000t 
11:21:49 * SyntaxPolice chortles at shapr
11:28:52 <TripleDES> hi
11:31:22 <Igloo> at, not with?
12:00:21 <SyntaxPolice> Igloo: with... with.
12:03:11 <Tomasso> @type filter
12:03:11 <lambdabot> filter :: (a -> Bool) -> [a] -> [a]
12:05:02 <Cale> @eval filter (<5) [7,3,2,8,1,9,5,7,6,4]
12:05:02 <lambdabot> (line 1, column 9):
12:05:02 <lambdabot> unexpected "<"
12:05:02 <lambdabot> expecting simple term
12:05:18 <Cale> @eval filter (\x -> x<5) [7,3,2,8,1,9,5,7,6,4]
12:05:18 <lambdabot> (line 1, column 12):
12:05:18 <lambdabot> unexpected "-"
12:05:18 <lambdabot> expecting identifier or "."
12:05:24 <Cale> @eval filter (\x. x<5) [7,3,2,8,1,9,5,7,6,4]
12:05:24 <lambdabot> [3, 2, 1, 4]
12:19:55 <cybermanco> @eval 1+1
12:19:55 <lambdabot> 2
12:20:11 <ddarius> @eval 100000000000000000+100000000000000000
12:20:12 <lambdabot> 200000000000000000
12:20:26 <ddarius> @eval 100000000000000000*100000000000000000
12:20:26 <lambdabot> 10000000000000000000000000000000000
12:23:35 <phubuh> @eval fac 10
12:23:36 <lambdabot> unbound variable: fac
12:23:59 <phubuh> @eval take 5 primes
12:24:00 <lambdabot> [2, 3, 5, 7, 11]
12:24:03 <phubuh> whee
12:24:29 <ddarius> @define fac product . fromTo 1
12:24:29 <lambdabot> fac defined
12:24:35 <ddarius> @eval fac 1
12:24:35 <lambdabot> 1
12:24:38 <ddarius> @eval fac 0
12:24:38 <lambdabot> 1
12:24:44 <ddarius> @eval fac 10
12:24:44 <lambdabot> 3628800
12:25:02 <phubuh> @eval fac 100
12:25:03 <lambdabot> 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000
12:25:11 <phubuh> :-P
12:26:09 <ddarius> @eval take 200 piDigits
12:26:18 <lambdabot> [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3, 2, 3, 8, 4, 6, 2, 6, 4, 3, 3, 8, 3, 2, 7, 9, 5, 0, 2, 8, 8, 4, 1, 9, 7, 1, 6, 9, 3, 9, 9, 3, 7, 5, 1, 0, 5, 8, 2, 0, 9, 7, 4, 9, 4, 4, 5, 9, 2, 3, 0, 7, 8, 1, 6, 4, 0, 6, 2, 8, 6, 2, 0, 8, 9, 9, 8, 6, 2, 8, 0, 3, 4, 8, 2, 5, 3, 4, 2, 1, 1, 7, 0, 6, 7, 9, 8, 2, 1, 4, 8, 0, 8, 6, 5, 1, 3, 2, 8, 2, 3, 0, 6, 6, 4, 7, 0, 9, 3, 8, 4, 4, 6, 0, 9, 5, 5, 0, 5, 8, 2, 2, 3, 1, 7, 2, 5, 3, 5, 9, 4, 0, 
12:26:32 <phubuh> @get-definition piDigits
12:26:32 <lambdabot> piDigits = piGen 1 0 1 1
12:26:42 <phubuh> @get-definition piGen
12:26:43 <lambdabot> piGen = \q r t k. (\n.if (4*q+r)/t == n then n : piGen (10*q) (10*(r-n*t)) t k else piGen (q*k) (q*(4*k+2)+r*(2*k+1)) (t*(2*k+1)) (k+1)) ((3*q+r)/t)
12:27:00 <phubuh> interesting
12:29:43 <Lor> Wasn't there an arbitrary-precision real arithmetic module for haskell somewhere?
12:32:28 <ddarius> Yes, in haskell-libs
12:45:17 <andersca> @eval piDigits
12:45:24 <andersca> good thing that didn't work :)
12:45:37 <lambdabot> out of fuel - use @resume to continue
12:46:41 <Lor> Wow, that's pretty advanced.
13:03:20 <shapr> yeehaa
13:03:28 <shapr> goood evening #haskell!
13:04:18 <shapr> what's going on this evening?
13:04:23 <shapr> where's the goodness?
13:07:02 <Igloo> Hi shapr
13:08:07 <shapr> hi Igloo!
13:08:11 <shapr> how's life treating you?
13:09:35 <Igloo> Could be worse
13:09:41 <shapr> is that good?
13:10:14 <Igloo> Well, it is better than the alternative  :-)
13:10:32 <shapr> heh, true
13:10:53 <shapr> any random thoughts on a mailserver written in Haskell?
13:11:53 <Igloo> Anything written in Haskell can only make the world a better place. Unless it's a nuclear bomb controller or something.
13:11:56 * shapr laughs
13:12:07 <Lor> The same thoughts as with any other heavy-duty server. IMHO haskell isn't very suited for them.
13:12:27 <shapr> Lor: well, I haven't written a network server in Haskell before, so this will be my first try.
13:12:37 <shapr> why do you think Haskell isn't very suited to them?
13:12:44 <Igloo> Lor: And maybe it will never improve if people don't start writing them  :-)
13:12:56 <Lor> Mostly because of the string representation.
13:13:05 <shapr> ok, what if I use Packed String?
13:13:13 <Lor> It helps a bit, but is tedious.
13:13:36 <phubuh> I scrapped the Haskell Direct Connect protocol -- I'm using O'Caml as originally planned instead :-(
13:13:37 <Igloo> Given you don't actually want to look at the mail content I wouldn't have thought it was too bad
13:13:37 <shapr> well, I'm in this business for expressiveness over speed anyway..
13:13:49 <phubuh> where did that "protocol" come from?  I definitely don't remember writing it
13:13:56 <shapr> phubuh: oh, why scrap it?
13:14:09 <Igloo> Oh, except for looking for a line containing just "."
13:14:35 <phubuh> I've already gotten a fair bit of code down in O'Caml, and I'm generally more familiar with it for heavily imperative and I/O stuff
13:14:36 <shapr> phubuh: found something that wouldn't work?
13:14:42 <shapr> ah, ok
13:14:44 <phubuh> nope
13:14:46 <Tomasso> how do you compose functions using the defined prelude?
13:14:52 <phubuh> @type (.)
13:14:52 <lambdabot> (.) :: (a -> b) -> (c -> a) -> c -> b
13:14:56 <Tomasso> is there any function to perform that?
13:15:01 <Tomasso> hooo OK
13:15:06 <shapr> oh, I didn't see pesco
13:15:10 <Tomasso> THANK YOU :D
13:15:43 <phubuh> the one thing I miss most from Haskell is ($) :D
13:15:54 <shapr> why?
13:16:03 <phubuh> it's just so convenient!
13:16:13 <mattam> phubuh: you can define it
13:16:34 <phubuh> ooh, I thought there was no way to specify precedence!
13:16:52 <shapr> hi Jad
13:16:57 <mattam> there is no way :)
13:17:09 <Jad> hello shapr
13:17:19 <Jad> can you gimme the link to the tutorials please
13:17:19 <Jad> ?
13:17:50 <phubuh> I also miss type classes and monads :(
13:18:40 <Jad> is their HOpenGl ?
13:18:45 <phubuh> yup
13:18:52 <phubuh> but it's called HOpenGL with a capital L :-)
13:18:57 <Jad> ahokay
13:19:04 <Jad> can you gimme a link to obtaining it ?
13:19:32 <phubuh> nope, but I'm sure Google can
13:19:35 <Jad> k
13:19:48 <shapr> http://www.haskell.org/HOpenGL/
13:19:49 <mattam> phubuh: but you get inference everywhere
13:19:58 <Jad> shapr: tnx
13:20:36 <phubuh> what do you mean?
13:20:57 <shapr> I just get interference everywhere
13:21:34 <mattam> Haskell's inference is limited, but ocaml isn't (you can write _any_ functional code without type signatures)
13:21:35 <phubuh> speaking of interference, `The Bachelorette' has to be the worst TV show ever
13:21:51 <Marvin--> worse than The Bachelor?
13:21:58 <Marvin--> or Temptation Island?
13:22:03 <Marvin--> or <insert name of any other reality show>?
13:22:07 <mattam> maybe it's not true ?
13:22:29 <phubuh> hmm, I have noticed that ghc tends to get angry if I don't declare the types of my functions
13:22:40 <shapr> I rarely have that problem.
13:23:13 * Marvin-- laughs at the UI design book he's reading
13:23:13 <phubuh> O'Caml does too, but to a lesser extent, and when I do get type errors, the errors are more incomprehensible
13:23:23 <mattam> sure ;)
13:23:38 <Marvin--> one of the examples in the book is from Diablo II :-)
13:23:41 <phubuh> shapr: well, me neither -- only when I feel adventorous enough to omit the declarations :-)
13:23:51 <mattam> well, i only have inference problems when i use classes 
13:24:04 <phubuh> Marvin--: the bachelor was better since there was a 20:1 female ratio instead of a 20:1 male ratio
13:24:05 <shapr> heh
13:24:17 <phubuh> mattam: hmm, that might be true
13:24:22 <Marvin--> phubuh: point
13:24:29 <shapr> TV is the opiate of the masses.
13:24:41 <shapr> or maybe that's just snus
13:24:47 <mattam> snus ?
13:24:53 <phubuh> is there an English word for snus?
13:24:57 <mattam> nonsense ?
13:24:58 <shapr> I don't think so.
13:25:05 <shapr> chewing tobacco?
13:25:08 <shapr> but different
13:25:12 <mattam> haha
13:25:30 <shapr> I went drinking with this tall cute swedish woman weekend before last
13:25:38 <Marvin--> isn't it "snuff" in English?
13:25:46 <Marvin--> or maybe that's different?
13:25:48 <shapr> nah, snuff is a powder that you sniff into your nose
13:25:53 <Marvin--> okay
13:25:59 <shapr> at least, I think it is
13:26:03 <shapr> I barely survived smoking.
13:26:11 <shapr> I'll pass on any tobacco products.
13:26:19 <Marvin--> I've never tried any at all
13:26:22 <shapr> smart man
13:26:35 <phubuh> me neither
13:26:41 <mattam> i tried all!
13:26:49 <shapr> tobacco makes magic the gathering look like a non-addictive substance.
13:26:52 <mattam> and got used to one
13:26:54 <phubuh> haha
13:27:08 <Marvin--> I was never that big on MtG either :)
13:27:15 <phubuh> MtG was huge in Sweden for a while
13:27:16 <shapr> I only spent four thousand dollars on MtG
13:27:22 <phubuh> :O
13:27:25 <shapr> tobacco cost me far more.
13:27:33 * Marvin-- confesses a certain addiction to A Game of Thrones though
13:27:47 <Marvin--> phubuh: it still is, ever been to a gaming convention?
13:27:54 <shapr> MtG is crack for geeks.
13:28:00 <shapr> unless you find something like lambda calculus
13:28:03 <Lor> mtg is crack for kids.
13:28:04 <phubuh> I mean outside of gaming conventions and even geekopia
13:28:21 <Lor> Geeks play more sophisticated ccg:s, like VtES or OtE.
13:28:24 <shapr> I had everything in MtG for awhile
13:28:32 <phubuh> it was like the biggest break activity at my school a couple of years back
13:28:35 <mattam> Lor: agree, no one plays magik after 17 here
13:28:40 <Marvin--> sure, if you've heard of a ccg at all, it's MtG
13:28:44 <shapr> so...
13:28:50 <shapr> tobacco is far far more addictive than MtG
13:29:02 <shapr> I still want to smoke cigarettes, two years after I stopped.
13:29:08 <shapr> I stopped wanting to play MtG at some point.
13:29:39 <mattam> two years ? could i ask how old are you ?
13:29:47 <shapr> guess ;-)
13:29:51 <Marvin--> mattam: he's four
13:29:53 <Marvin--> duh
13:29:54 <shapr> heh!
13:29:56 * mattam 's rolling a cigarette
13:30:04 <mattam> 19
13:30:09 * Jad is rolling a joint
13:30:14 <mattam> no, 21
13:30:18 <shapr> I am older than 21
13:30:26 <mattam> 23 ?
13:30:27 <Marvin--> sheesh, *I* am older than 23
13:30:31 <Marvin--> er, 21
13:30:36 <shapr> I am older than 23
13:30:41 <Lor> Me too.
13:30:46 <mattam> 31 ?
13:30:49 <shapr> >
13:30:57 * Marvin-- still cheerfully plays MtG when someone lends him a deck
13:31:00 <shapr> > 31
13:31:03 <Lor> So who's the Old Geezer of the channel?
13:31:05 <mattam> really ?
13:31:11 <shapr> yah, I'm 100,000 in binary.
13:31:13 <Marvin--> I don't have a chance of keeping track of the cards any more though
13:31:29 <shapr> Lor: how old are you?
13:31:29 <mattam> 32 
13:31:34 <shapr> mattam: yup.
13:31:34 <Lor> 25.
13:31:37 <shapr> I smoked for eight years.
13:31:55 * Marvin-- is 23
13:32:10 <phubuh> I'm one thousand, one hundred, and eleven!
13:32:11 <Lor> It's always a comfort to be in a company where someone is older than yourself. :)
13:32:26 * Marvin-- happens to have friends who are even older than shapr ;)
13:32:29 <shapr> quelle surprise!
13:32:41 <Marvin--> (yes, they're ancient! fossils!)
13:33:21 <shapr> j'espere quelqu'un est vieux que moi
13:33:24 <shapr> or something like that..
13:33:40 <mattam> damn, you speak like someone excited about what he's learning and are 32, you're now a model for me :)
13:33:46 <shapr> haha!
13:33:52 <shapr> of course I'm excited about what I'm learning!
13:34:01 <shapr> Haskell is immensely spiffy!
13:34:04 <Jad> shapr: got a pic ?
13:34:07 <shapr> sure
13:34:31 <shapr> shapr and Igloo --> http://www.cse.unsw.edu.au/~sseefried/seafood/photos/people/people-Pages/Image8.html
13:35:10 <mattam> shapr: j'éspère _que_ (that) quelqu'un est "_plus_(more) vieux"(older) que moi :)
13:35:31 <shapr> merci
13:35:41 <Jad> shapr: you are the one with the beard ?
13:35:43 <mattam> de rien
13:35:45 <shapr> heh! no!
13:36:04 <Marvin--> no, Igloo's the channel's resident beard
13:36:08 <shapr> jao: Igloo is the mystical guru looking guy, I'm the silly looking guy on the left.
13:36:15 <shapr> I am extremely silly in person.
13:36:24 * Marvin-- happily agrees :)
13:36:41 <mattam> up gives a 404 on this page
13:37:05 <shapr> another pic; shapr, Igloo, and blackdog http://www.syntaxpolice.org/pics/londonSweden/small/ICFP/6.html
13:37:26 <shapr> Igloo is the guru with the beard on the right.
13:37:42 <phubuh> http://www.hemsida.net/brockman/2003/avslut10.jpg
13:37:51 <phubuh> horrible picture, but aren't they all?
13:38:05 <phubuh> my glasses are terribly skewed
13:38:12 <shapr> they look like my glasses!
13:38:16 <andersca> hehe
13:38:18 <shapr> it's the swedish fashion!
13:38:19 <tic> Whot's that?
13:38:26 <tic> Who's that, even.
13:38:28 * Igloo looks back at the mention of his name and finds a splurgeful of conversation already
13:38:34 <shapr> Igloo: you're famous!
13:38:43 <shapr> I'm just a little tjock
13:38:46 <Marvin--> look, it's the amazing beard!
13:38:49 <phubuh> tic: the one I linked to is appropriately myself
13:38:58 <tic> kent brockman ?:P
13:39:02 <Jad> if you ever shave your hair, or beard Igloo please send me a pic
13:39:06 <phubuh> tic: oh, I see you got your BBB connection! :-)
13:39:09 <tic> phubuh, schysst domännamn.
13:39:14 <tic> phubuh, ah, yeah! :)
13:39:21 <tic> "I'm loving it".
13:39:28 <tic> (hate mcd though)
13:39:28 <shapr> what is this? do all swedes know each other in person?
13:39:37 <tic> hehe, neh. :)
13:39:41 <phubuh> the main page (my mom's) is at brockman.nu, actually :-)
13:39:42 <Marvin--> no, I don't have a clue what they're talking about
13:39:51 <shapr> geez, I'll have to meet everyone in the country before I qualify for citizenship?
13:39:58 <tic> shapr, yup. :)
13:40:05 <phubuh> of course!
13:40:17 <shapr> hm, I'd like to meet the king, he looks chilled out.
13:40:29 * Marvin-- rolls his eyes
13:40:40 * andersca too
13:40:40 <tic> I don't really get the point of having a king in sweden.
13:40:44 <shapr> it's cool!
13:40:47 <Marvin--> makes two of us
13:40:53 <andersca> three
13:40:57 <andersca> republik.nu!
13:41:01 <shapr> c'mon, I've never lived in a country with a king before! it's part of the great european adventure!
13:41:03 <Marvin--> bleedin' ancient useless system
13:41:08 <tic> just costs a lot of money.
13:41:13 <Jad> shapr: wer are you from ?
13:41:19 <shapr> I'm from Alabama!
13:41:32 <shapr> southeast backwoods part of the USA
13:41:38 <shapr> but I live in Sweden
13:41:55 <shapr> Jad: have you lived in several places?
13:42:34 <Lor> "My own personal belief is that "the Lisp way" cannot be defined, because it is not "the Lisp way" to do so."
13:42:41 <shapr> phubuh: what are the flowers for?
13:42:46 <shapr> Lor: who said it?
13:42:49 <Lor> This proves the long-lived suspicion that lisp is really zen. :)
13:42:49 <shapr> is this name that quote?
13:42:59 <phubuh> shapr: graduation from högstadiet
13:43:03 <Igloo> Anyone got a simple c2hs test handy?
13:43:05 <Lor> From the c.l.f war. Duane Rettig.
13:43:15 <shapr> huh, I thought it would be rahul who would say that.
13:44:49 <shapr> @yow
13:44:50 <lambdabot> Yow!  Am I JOGGING yet??
13:45:34 <Marvin--> I pondered entering this stupid programming contest
13:45:41 <andersca> which one?
13:45:48 <Marvin--> don't know what it's called
13:45:51 <Marvin--> that IBM contest
13:46:00 <Marvin--> you can only use IBM-approved programming languages
13:46:16 <Marvin--> C, C++, Java or something
13:46:28 <Marvin--> so I pondered entering and using ghc -fvia-C just to spite them...
13:46:35 <phubuh> haha
13:46:59 <Marvin--> I mean, wtf, if they're not going to judge the *code* what difference does it make what *language* I use?
13:47:21 <phubuh> maybe using a good language is cheating
13:47:27 <Marvin--> every time I ponder entering the contest I get so worked up over this and never get around to enter
13:47:32 <Riastradh> It gives you an unfair advantage.
13:47:32 <esap> So one of their criterion is not how many comments your generated code has? :-)
13:48:09 <Marvin--> It gives me an unfair advantage to use a decent language? Yeah, I guess you're right
13:48:15 <phubuh> yup.
13:50:40 <sex|more> hi, can someone help me with a haskell app?
13:51:29 <TFP> hi sex|more
13:51:33 <sex|more> hi
13:52:45 <sex|more> I have a task to do, I have to determine experimentally the number pi
13:53:00 <sex|more> I can give a reference how to do, but I have no idea how to do on in haskell
13:53:14 <Marvin--> *experimentally*?
13:53:18 <Cale> in which way? There are lots of ways to experimentally calculate pi
13:53:21 <sex|more> yes
13:53:25 <sex|more> hold on!
13:54:54 <sex|more> this is the way
13:55:03 <sex|more> you have a quarter circle
13:55:38 <Cale> okay
13:55:52 <sex|more> you shoot 1000x on the quarter and you have to determine how often of the 1000x time the hit is in the quarter circle
13:56:06 <sex|more> I have a approximate to do list, which functions you need
13:56:35 <sex|more> a random func which creates a x list and a y list as coordinates
13:57:26 <sex|more> a functions which compares if the couples are inside the quarter circle (sqrt (x^2+y^2 <= 1))
13:57:28 <Cale> i.e. you drop n points into the square (0,0) (0,1) (1,1) (1,0) and about (pi/4) n of them should land within 1 of (0,0)
13:57:51 <sex|more> and then calculate pi this way:
13:58:20 <sex|more> (4 * (number of shots in the cirlce))/total shots
13:58:25 <sex|more> this equals pi
13:59:14 <Cale> right
13:59:30 <Marvin--> right
13:59:38 <sex|more> got my point?
13:59:42 <Cale> yep
13:59:49 <sex|more> great
14:00:28 <Cale> rather than having two lists of random Doubles, you might just have one list of random (Double, Double)'s as input.
14:00:50 <TFP> sex|more: http://www.gslt.hum.gu.se/~leifg/dab725/haskell_assignments.html <-- look at the bottom
14:00:52 <sex|more> a list of 2-tuples?
14:01:02 <Cale> then you take the function that calculates whether each is in or out of the circle, and map it over that list
14:01:11 <Cale> sex|more: yeah
14:01:18 <sex|more> hold on!
14:02:33 <sex|more> @ TFP, I took a look
14:02:34 <lambdabot> Sorry, I don't know the command "", try "lambdabot: @listcommands"
14:02:55 <sex|more> seems cool but I can'T use that, I have to solve it the way I have descibed the prob
14:03:28 <Cale> I think this is easy enough...
14:03:52 <Cale> the function that says "is (x,y) within 1 of (0,0)" is just 
14:03:55 <sex|more> how can I access the values of a tuple which are in a list
14:04:21 <Cale> \(x,y) -> sqrt (x^2 + y^2)
14:04:40 <sex|more> with backslash?
14:04:45 <Cale> \ is lambda
14:04:55 <sex|more> why lambda?
14:04:59 <sex|more> what is this?
14:05:03 <Cale> it produces anonymous functions
14:05:09 <Cale> \x -> x + 1
14:05:18 <Cale> is the function that takes a value and adds 1 to it
14:05:25 <Cale> \(x,y) -> x
14:05:35 <Cale> is the function that gets the first element of a tuple
14:05:46 <Marvin--> s/tuple/pair/
14:05:49 <sex|more> hold on, I will try some funcs
14:05:51 <Cale> yes
14:05:53 <Cale> pair
14:06:35 <Cale> (\x -> x+1) 5 should return 6 for example
14:08:57 <sex|more> do I have to do it with a filter?
14:11:19 <Cale> you'll want to map the function that determines whether a point is in the circle over the list, then filter out the ones that are True, then count how many there are
14:11:47 <sex|more> compareIt xylist = [(x,y) | (x,y) <- xylist, sqrt (x^2 + y^2) <= 1]
14:12:04 <sex|more> doesn't work
14:12:09 <sex|more> Looking for the bug
14:12:23 <Cale> oh, you could do something like that as well
14:12:37 <sex|more> how would yo do that else?
14:12:41 <sex|more> what is wrong with mine?
14:12:45 <Cale> nothing
14:13:03 <Cale> I wasn't thinking about list comprehensions
14:13:18 <phubuh> you could also use map and filter, which was probably what Cale was thinking of :-)
14:14:33 <sex|more> hell, it works :D
14:14:42 <phubuh> whee
14:14:54 <sex|more> no the next step
14:14:59 <sex|more> gimme a sec
14:16:24 <Tomasso> hhm can anyone tell me how to implement graphs in functional???
14:16:45 <Tomasso> does it have a recursive definition to implement using datas?
14:19:28 <phubuh> gah, this stupid direct connect hub doesn't follow the spec
14:19:45 <phubuh> but it's one of the most common ones, so not supporting it would be disastrous
14:20:01 <phubuh> protip: don't ever even think about even glancing at the direct connect protocol
14:20:50 <ddarius> Tomasso: Use the Functional Graph Library, google should turn up a link (maybe with "haskell" added)
14:23:11 <sex|more> ok gentleman, my app works with a predefined x y list
14:23:17 <sex|more> how can I create a random one?
14:24:10 <Cale> there's an IO action that will give a random Double, getStdRandom random
14:24:29 <sex|more> I am not allowed to use it, custom made!!
14:24:30 <Tomasso> ddarius: hhm i prefer to implement it myself because its for faculty
14:24:50 <Cale> you need to write your own random number generator?
14:25:06 <phubuh> sex|more: are you sure?  pseudo-random number generation is a very esoteric topic.
14:25:22 <phubuh> and not what strikes me as a useful excercise in functional programming :-)
14:25:36 <sex|more> I have this:
14:26:00 <sex|more> rando s = (25173*s + 13849) `mod`65536
14:26:07 <sex|more> this generates a random number
14:26:18 <phubuh> oh
14:26:36 <Cale> oh, alright
14:26:54 <ddarius> Tomasso: Then look at how it's implemented or look at how Data.Graph is implemented.  It's not easy to make a decent general purpose pure graph library.
14:26:57 <Cale> then map rando [1..1000]
14:27:26 <sex|more> great idea
14:27:28 <sex|more> hold on
14:27:32 <Cale> will make one list of random integers between 0 and 65535
14:27:38 <sex|more> jupp
14:27:39 <ddarius> more like take howManyYouNeed (iterate rando initialSeed)
14:27:40 <sex|more> it will
14:27:48 <Cale> oh
14:28:18 <Cale> alright then, ddarius comment seems more reasonable
14:28:25 <ddarius> @define rando (25173*s + 13849) `mod` 65536
14:28:25 <lambdabot> rando defined
14:28:36 <ddarius> @eval take 100 (iterate rando 1)
14:28:36 <lambdabot> unbound variable: s
14:28:44 <ddarius> @define rando \s.(25173*s + 13849) `mod` 65536
14:28:44 <lambdabot> rando defined
14:28:46 <ddarius> @eval take 100 (iterate rando 1)
14:28:47 <lambdabot> [1, 39022, 61087, 20196, 45005, 3882, 21259, 65216, 19417, 30502, 20919, 26076, 16421, 44130, 63139, 32824, 14513, 51934, 36303, 35284, 8573, 11930, 41787, 65200, 9865, 29590, 743, 39628, 46037, 30162, 47315, 23080, 30049, 20814, 4351, 30916, 22317, 25098, 38763, 29344, 34105, 17414, 6167, 956, 27525, 54082, 40707, 10264, 46609, 11198, 30767, 7092, 20701, 43386, 12187, 23184, 26601, 59510, 37191, 41132, 26421, 50354, 43315, 59912, 64193, 
14:29:05 <Lor> I wonder how many times today I've began replying to one of those c.l.f posts only to abort before sending...
14:29:09 <phubuh> you should probably iterate n+1 times and ignore the first value
14:29:14 <ddarius> (note: that @eval doesn't use Haskell syntax)
14:29:43 <phubuh> @define random-list \n. \s. tail (take (n + 1) (iterate rando s))
14:29:44 <lambdabot> random-list defined
14:29:51 <phubuh> @eval random-list 10 1
14:29:51 <lambdabot> unbound variable: random
14:30:05 <phubuh> how silly
14:30:25 <phubuh> @define randomList \n. \s. tail (take (n + 1) (iterate rando s))
14:30:25 <lambdabot> randomList defined
14:30:37 <phubuh> @eval randomList 10 1
14:30:38 <lambdabot> [39022, 61087, 20196, 45005, 3882, 21259, 65216, 19417, 30502, 20919]
14:33:04 <ddarius> phubuh: you mean take the tail or start with (rando initialSeed)
14:33:09 <phubuh> yeah
14:33:33 <Tomasso> mhmh ddarius OK
14:33:35 <sex|more> ok, I have the random list: atn = map rando [1..1000]
14:33:44 <sex|more> and the scale: newscale a = (fromInt(a))/65535
14:33:51 <sex|more> but the scale won't work
14:34:10 <sex|more> I want to scale my random number down to from 0 to 1
14:34:30 <sex|more> all I get is Int doesnt match [Int]
14:34:44 <phubuh> what do you pass to newscale?
14:35:00 <sex|more> a enum of numbers
14:35:02 <sex|more> not a list
14:35:12 <sex|more> atn is passed to
14:35:29 <phubuh> an enum of numbers as in [x..y]?
14:35:51 <sex|more> yes, the enum is atm = map rando [1..1000]
14:36:03 <sex|more> I want to scale down these numbers to below 1
14:36:07 <phubuh> [x..y] is syntactic sugar for enumFromTo x y, which returns a list of all the things between x and y
14:36:12 <phubuh> map also returns a list
14:36:30 <phubuh> newscale atm will try to use the list as an int, and won't pass the type checker
14:36:44 <phubuh> you probably want to do "map newscale atm" to scale all the numbers
14:36:53 <sex|more> yes
14:36:57 <sex|more> that was my idea
14:36:59 <sex|more> hold on
14:37:51 <sex|more> this is it!
14:45:46 <sex|more> ok, I almost have it
14:45:59 <sex|more> now I have to fill the tuples
14:46:21 <phubuh> you want a list of tuples and you have two lists?
14:46:21 <sex|more> atn = map rando [1..1000]
14:46:22 <sex|more> newscale a = (fromInt(a))/65535
14:46:22 <sex|more> belowx1 = map newscale atn
14:46:22 <sex|more> belowy1 = map newscale atn
14:46:22 <sex|more> fillin belowx1 belowy1 = [(x,y) | x <- belowx1, y <- belowy1]
14:46:32 <sex|more> I have the tuple list
14:46:39 <sex|more> the insertion is not the way I want
14:46:56 <sex|more> I have 1000 numbers each
14:47:03 <phubuh> belowx1 and belowy1 are just two different names for the exact same thing
14:47:36 <sex|more> can I use the same name, I thought I would have the same values then
14:48:10 <phubuh> I don't think it would make a difference
14:48:14 <shapr> hmm, suddenly telia won't relay my mail anymore
14:48:25 <sex|more> you understand what I mean?
14:48:30 <ddarius> sex|more: While numerical correctness isn't that important, you really don't want to use rando as map rando [1..1000]
14:48:40 <sex|more> why?
14:48:54 <Cale> yeah, I realised that after darius mentioned is before
14:48:59 <Cale> it*
14:49:18 <sex|more> and what does he mean now?
14:49:23 <ddarius> That kind of random number generator (and most) are meant to -start- at a seed and continue with the seed produced.
14:49:25 <Cale> rando takes the last random number and gives the next
14:49:34 <phubuh> because the seed is very predictable, so the numbers aren't actually very random at all.  it is better to reuse the random numbers as the seed for the next number.
14:49:47 <sex|more> and how should I do it then?
14:50:37 <phubuh> take 1000 (iterate rando (rando x))
14:50:59 <phubuh> iterate f x returns [x, f x, f (f x), f (f (f x)), ...]
14:52:03 <sex|more> and what is x?
14:52:25 <phubuh> x is a value of any type
14:52:40 <sex|more> right, right, but what do I have to fill in for?
14:52:40 <phubuh> for example, iterate rando 5 is [5, rando 5, rando (rando 5), ...]
14:52:50 <phubuh> oh, I already did that for you :-)
14:53:00 <phubuh> err, sorry, no I didn't
14:53:17 <phubuh> for now, you could just put some arbitrary number
14:53:28 <sex|more> good
14:53:39 <phubuh> but it'd be better to use, say, the current time in milliseconds
14:54:33 <sex|more> ok, so far so good
14:54:52 <sex|more> now my last problem is to fill it the right way in the tuples
14:54:59 <sex|more> fillin below1 below2 = [(x,y) | x <- below1, y <- below2]
14:55:18 <sex|more> this fill in fills 1st x with all ys, then 2nd x with all ys
14:55:21 <sex|more> not my intention
14:55:27 <phubuh> what is your intention?
14:56:03 <sex|more> I want to have 1st x w/ 1st x, 2nd x w/ 2nd x.....and the and I want to have a list with 1000 2-tuples
14:56:17 <sex|more> I can't figure out the proper filter for
14:56:30 <phubuh> you just want a list of (x, y) where x and y are random numbers, right?
14:56:47 <sex|more> from the generated list twice
14:56:49 <sex|more> yes
14:57:23 <phubuh> make two lists with different seeds, and do zip a b
14:57:40 <sex|more> and without zip?
14:57:50 <sex|more> don't allowed to use it :(
14:58:02 <phubuh> you could define it yourself
14:58:36 <ddarius> Here we go again.  You shouldn't use separate seeds.  The simplest thing would be to make a list twice as long and then pair the values off.
14:59:10 <phubuh> ah, true.
14:59:24 <ddarius> Though with a multiplicative congruential generator I think that isn't especially nice, but as I said earlier numerical accuracy probably isn't that important here.
15:00:17 <ddarius> Alternatively, you could make a list of pairs directly.
15:00:25 <phubuh> you could also instead of iterate make a function that ... bah!
15:03:02 <sex|more> there's an other prob I have noticed: atn1 = take 1000 (iterate rando (rando 5))
15:03:20 <sex|more> everytime I invoke it, it gives me the same numbers
15:03:28 <sex|more> is there any options to avoid that?
15:03:52 <phubuh> yes, that's a property of your function being purely functional.  notice that rando just applies some numerical magic to the number, and 5 doesn't change.
15:04:27 <sex|more> damn, there is no solution I guess?
15:04:35 <phubuh> yup, there is!
15:04:40 <sex|more> because of this dependancy?
15:04:42 <sex|more> which one?
15:06:08 <phubuh> the function you're working on now will still be purely functional, but it should take the seed as an argument.  then you'll call it in the main function, which can do a bunch of not-really-functional stuff, like getting the current time.
15:06:35 <sex|more> this is too much haskell, my tutor won't accept this :D
15:07:22 <sex|more> I guess I know how to bypass it
15:07:53 <sex|more> but let's get back to my self zip
15:07:59 <sex|more> still don't know how to do this :(
15:09:02 <phubuh> the simplest way is to, as ddarius said, generate 2000 random ints, and turn them into a list of tuples, i.e., [a, b, c, d, ...] -> [(a, b), (c, d), ...]
15:10:51 <sex|more> ok, hold on!
15:16:04 <ddarius> Well, once you get it working you could earn lazy functional brownie points by using infinite lists to allow the user to decide the accuracy.
15:22:12 <sex|more> can someone tell me, what is wrong with that:
15:22:23 <sex|more> atn1 = take 1000 (iterate rando (rando 5)) -- hier total zufällig
15:22:23 <sex|more> atn2 = take 1000 (iterate rando (rando 10)) -- hier total zufällig
15:22:23 <sex|more> newscale a = (fromInt(a))/65535
15:22:23 <sex|more> below1 = map newscale atn1
15:22:23 <sex|more> below2 = map newscale atn2
15:22:24 <sex|more> fillin:: [Float] -> [Float] -> [(Float,Float)]
15:22:26 <sex|more> fillin first second = [(x,y) | x <- first, y <- second]
15:22:28 <sex|more> showme:: [(Float,Float)]
15:22:30 <sex|more> showme = fillin below1 below2
15:22:36 <sex|more> I get this: ERROR "C:\Dokumente und Einstellungen\Administrator\Desktop\assignment3.hs":90 -
15:22:37 <sex|more>  Type error in application
15:22:37 <sex|more> *** Expression     : fillin below1 below2
15:22:38 <sex|more> *** Term           : below2
15:22:40 <sex|more> *** Type           : [Double]
15:22:42 <sex|more> *** Does not match : [Float] 
15:23:22 <phubuh> explicitly declare the type of newscale -- it now returns a Double
15:23:29 <phubuh> [Double], rather
15:24:56 <ddarius> sex|more: You should generally use Doubles unless you have a good reason.
15:25:24 <sex|more> and why??
15:29:50 <sex|more> k, I switched to doubles!
15:29:54 <sex|more> works better now!
15:30:01 <shapr> I've always done better in the singles
15:30:09 <shapr> tennis is so demanding
15:30:17 <Cale> heh
15:31:14 <shapr> I really did play tennis for awhile.
15:31:26 <Pseudonym> In Haskell, of course, Rationals are often a good thing if you really need precision.
15:31:30 <shapr> g'day Pseudonym 
15:31:33 <Pseudonym> G'day.
15:31:56 <Pseudonym> Though I find Emotionals also useful.
15:32:02 <shapr> how's RH treating you?
15:32:06 <shapr> heh
15:32:07 <Pseudonym> Writing manuals.
15:32:09 <shapr> mm, fun.
15:32:19 <Pseudonym> We should really hire a technical writer.
15:32:33 <phubuh> RH as in RedHat?
15:32:40 <Pseudonym> Release Hell
15:32:45 <phubuh> oh :-)
15:33:20 <Pseudonym> Must write.  I probably won't be very responsive. :-(
15:33:23 <phubuh> bah!  I hate Unix programming.
15:33:32 * isomer hands Pseudonym a extra huge coffee
15:33:47 <shapr> I'm trying to figure out why mail.telia.com refuses to relay my emails
15:33:54 <shapr> phubuh: you have any clues with telia?
15:34:05 <phubuh> nope, sorry.
15:34:22 <isomer> are you using a .telia.com address?
15:34:35 <shapr> no
15:34:38 <sex|more> guys, It works PERFECT!
15:34:43 <shapr> but I've been able to send email for the last year or so anyway.
15:34:44 <sex|more> I used zip though
15:34:48 <sex|more> you are GREAT
15:34:48 <isomer> hmm
15:34:51 <sex|more> thx a lot!
15:35:04 <phubuh> no problem :-)
15:35:10 <isomer> maybe they changed their sendmail config...
15:35:10 <sex|more> awesome!
15:35:15 <sex|more> jut awesome!
15:35:19 <sex|more> you make coding fun!
15:35:51 <isomer> i guess you put the fun in funktion :)
15:36:07 <shapr> heh
15:36:11 <sex|more> haskell is fun!
15:36:14 <shapr> yes!
15:36:25 <sex|more> makes more fun than Java to me
15:36:26 <sex|more> :d
15:36:29 <shapr> truly
15:36:38 <shapr> java macht keine spaß
15:36:48 <sex|more> macht es auch nicht!
15:36:53 <sex|more> haskell rulez :D
15:37:07 <mgoetze|away> java ist eklig :)
15:37:24 <shapr> what's eklig?
15:37:30 <mgoetze|away> disgusting
15:37:41 <shapr> ah, true
15:38:41 <isomer> java is a small spa?
15:39:01 <phubuh> I think it's a keen spaz
15:39:10 <isomer> java sucks?
15:39:20 <sex|more> java doesn't suck
15:39:21 <ddarius> Nicht 'kleine'.
15:39:31 <sex|more> it is a complete different level than haskell
15:39:43 <isomer> right... java blows
15:39:46 <sex|more> guys, I how can I produce a comepletely random number
15:39:49 <Lor> In one sense java seems to be the most advanced language there is.
15:39:56 <sex|more> is there a func in haskell?
15:39:59 <mattam> sex|more: you can't
15:40:02 <phubuh> I think you'll have to ask that question to a quantum physicist
15:40:05 <sex|more> really?
15:40:11 <shapr> Lor: you mean in the management sense?
15:40:18 <sex|more> I mean like Math.random() in java
15:40:22 <mattam> unless you have some atomic reaction you can observe on your computer :)
15:40:27 <Lor> No, in the typed reflection sense.
15:40:29 <phubuh> that's just a pseudo-random number :-)
15:40:48 <phubuh> use your rando function seeded with the current time
15:40:56 <sex|more> I want to replace this: atn1 = take 1000 (iterate rando (rando 20))
15:41:01 <sex|more> the 20
15:41:04 <sex|more> is crap
15:41:04 <mattam> he, #haskell makes me picky
15:41:21 <sex|more> the 20 is a cumbersome static
15:41:24 <sex|more> final
15:43:41 <phubuh> main = do clockTime <- getClockTime
15:44:21 <phubuh>           doThings (ctPicosec (toUTCTime clockTime))
15:45:41 <sex|more> paste with where??
15:46:49 <phubuh> doThings is something that takes an Integer, and presumably uses it as a seed to rando, and returns some value
15:47:10 <phubuh> actually, you probably want to do putStrLn (doThings ...) so you can see what it returns
15:47:29 <phubuh> if you're using hugs, you can run main by just hugsing the file and typing main
15:47:31 <sex|more> well well, thx
15:47:39 <sex|more> I have to comment my code first :D
15:53:46 <ayrnieu> shapr - what does the tutorial line in the title mean?
15:53:57 <shapr> just what it says
15:54:02 <shapr> feel free to suggest tutorial
15:54:03 <shapr> s
15:54:24 <shapr> I've created a page on the HaWiki for tutorials
15:54:36 <shapr> http://www.haskell.org/hawiki/HaskellTutorials
15:54:40 <ayrnieu> I don't understand what it says.  Are you asking for people to suggest ideas on what tutorials could be written?  To contribute tutorials?  To ask for copies of unfinished tutorials?  For copies of currently unwritten tutorials (when you finish them)?
15:54:46 <ayrnieu> Ah, OK.
15:54:55 <shapr> ayrnieu: e) all of the above
15:55:04 <shapr> and then some
15:55:32 * shapr listens to Tool "THESE ARE THE CRIES OF THE CARROTS!"
15:55:59 <ayrnieu> shapr - I'd like a mini-tutorial on how to convert a random number (in a string or as a literal) to a PortNumber for Network.listenOn -- because I just came back to Haskell and I bashed my head against this *again*.  I'm still not totally clear on it.
15:56:26 * ayrnieu wishes that his sources didn't so regularly burn away.
15:56:28 <shapr> sounds pretty easy to do badly
15:56:36 <shapr> what's the range of the incoming random number?
15:56:39 <shapr> from what to what?
15:57:36 <shapr> say the number is from 0 to 65536, and your range of portnumbers is 1024 to 65536
15:57:39 <ayrnieu> Not a random number as in a randomly generated number, but an arbitrary number.  How do you pass a literal such as '1667' to listenOn?  I had to search online to find that out.  How do you have a function construct an integer (from getArgs or otherwise) and somehow pass this to listenOn?
15:57:48 <shapr> oh
15:57:58 <phubuh> fromInteger . read
15:58:07 <shapr> http://www.scannedinavian.org/~shae/src/haskell/Echo2.hs
15:58:23 <shapr> ssock <- listenOn ((PortNumber portnum) :: Network.PortID)
15:58:37 <shapr> portnum     :: PortNumber
15:58:37 <shapr> portnum     = 7001
15:58:50 <ayrnieu> Nifty.  Thank you.
15:59:56 <ayrnieu> Put more generally, what I'd like is not a bunch of tutorials so much as better library documentation -- something riddled with usage and examples and a human voice as opposed to brief descriptions, occasional vague larger bits of text, and generated binding descriptions.
16:00:35 <shapr> me too
16:00:49 <shapr> therefore I charge you to find out exactly which tutorials you'd like to have right now
16:00:53 <shapr> and write the parts you can write
16:01:01 <ayrnieu> shapr - OK.
16:01:18 <isomer> i want a clear explanation of monads....
16:01:27 <shapr> isomer: that exists actually
16:01:27 <isomer> ie one that my mom could understand
16:01:37 <shapr> nomaware is it
16:01:39 <phubuh> is your mom a category theorist?
16:01:49 <phubuh> if so, there's plenty of material!
16:02:10 <isomer> hehe
16:02:23 <isomer> she's a math teacher...
16:03:14 <shapr> she'll probably understand it better than we will :-)
16:03:50 <ayrnieu> I still think about a brief Erlang example when I think of monads: automatically turning foo(RealArg, State) -> State1 = bar(RealArg, State), State2 = baz(random(), State1), State3 = quux(random(), State2), State3.  into  foo(RealArg) -> bar(RealArg), baz(random()), quux(random()). -- or something like that.
16:05:58 <isomer> don't get it :(
16:06:11 <Smerdyakov> Well, ayrnieu transformed in the wrong direction. :)
16:06:31 <sex|more> well guys, I did it!
16:06:35 <sex|more> thx again!
16:07:01 <ayrnieu> Smerdy - did I?  The second isn't real Erlang code, it's supposed Erlang inside a monad.
16:07:38 <Smerdyakov> ayrnieu, yeah. You want to write the second code and have it run like the first code. :)
16:08:15 <shapr> ?
16:09:21 <ayrnieu> The tutorial page might also link to relevant academic papers -- reading the Concurrent Haskell paper helped me some =)
16:10:12 <Smerdyakov> The idea of a monad is trivial.
16:10:21 <Smerdyakov> It's only bad explanations that are to blame with anyone floundering with it.
16:11:28 <isomer> Smerdyakov: care you give a try at an explanation?
16:12:35 <shapr> I disagree with you Smerdyakov 
16:12:51 <Smerdyakov> Is there a good place to try to put a superspeed explanation on the HaWiki? :)
16:12:52 <shapr> I think that the idea of monads is simple, but that people are used to thinking in imperative ways.
16:13:04 <ayrnieu> I suppose that "monads are a way to thread state through a program in a way that can be checked by the compiler -- IO is such a monad" is a good explanation for newbies.
16:13:22 <shapr> http://www.haskell.org/hawiki/Monad
16:13:34 <ddarius> I *hate* that explanation.
16:13:44 <shapr> ddarius: how would you explain it?
16:14:18 * isomer listens extra hard
16:15:05 <ayrnieu> ddarius - ok, how about "monads are a way to force code to evaluate in an expected order by forcing a natural data dependency -- which is kept mostly invisible by a special syntax' ?
16:15:20 <shapr> I think that's a much better way to describe it.
16:15:33 <shapr> monads sequence the purely functional 
16:15:40 <ayrnieu> OK, 'expected' and 'natural' in the same breath is less than ideal.  'certain' order and 'natural', maybe.
16:15:45 <shapr> I think of monads as identically sized rings on a string
16:15:59 <ddarius> ayrnieu: Much better.
16:16:05 <esap> rings?
16:16:28 <shapr> the string is the purely functional code, the rings are the monads, you can slide the rings around a certain amount in relation to the pure code string, but they cannot go past each other
16:16:33 <shapr> esap: silly explanation?
16:16:39 <phubuh> a type for which the only necessary operations are the computation chaining operation and the return operation -- a way of temporarily "extracting" the value from the monad, and a way to lift a value into it
16:16:50 <ayrnieu> ddarius - well, I can still monads carrying useful state -- the idea of the IO monad is that it contains the 'state of the world', after all, even though it's more practically used as the second description describes.
16:17:01 * ddarius cringes everytime he hears, "I understand monads now! They just thread the state!"
16:17:02 <ayrnieu> think that monads can still carry.  Yowch.
16:17:10 <ayrnieu> Gotta go.
16:17:14 <shapr> run away!
16:17:17 <shapr> cya ayrnieu 
16:17:30 <phubuh> because you don't always care about the evaluation order -- for example, when (ab)using the List monad to do concatMapping :-)
16:17:30 <esap> shapr: Well I'm not sure about the relationship with monads :-)
16:17:54 <shapr> truly, SPJ talks about overordering
16:18:09 <shapr> he'd like to have some spiffy syntax for non-sequential monads
16:18:25 <shapr> at least, monads that can be done in parallel
16:18:34 <shapr> it's mentioned in the hairshirt retrospective
16:18:42 <phubuh> oh
16:19:37 <ddarius> If a generate some boilerplate, I can finish my commutative monads hack.
16:19:49 <esap> shapr: I think non-sequential monad is a contradiction in terms :-) But I'd expect parallel things would be better expressed as comonads, not monads.
16:19:51 <shapr> esap: can you think of a more accurate physical analogy than identical rings on a string?
16:20:06 <isomer> hm... monad: an elementary individual substance which reflects the order of the world and from which material properties are derived
16:20:17 <isomer> (meriam-webster)
16:20:18 <shapr> isomer: that's philosophy... 
16:20:21 <shapr> what was that guy?
16:20:23 <shapr> @wn monad
16:20:28 <lambdabot> *** "monad" wn "WordNet (r) 2.0"
16:20:28 <lambdabot> monad
16:20:28 <lambdabot>      n 1: an atom having a valence of one
16:20:28 <lambdabot>      2: a singular metaphysical entity from which material
16:20:29 <lambdabot>         properties are said to derive [syn: {monas}]
16:20:29 <ddarius> Leibniz
16:20:31 <lambdabot>      [also: {monades} (pl)]
16:20:33 <shapr> ah, leibniz
16:20:48 <isomer> that's not much help
16:20:50 <isomer> @arr
16:20:50 <lambdabot> Arrr!
16:20:58 <shapr> @arr
16:20:58 <lambdabot> Get out of me way, yeh landlubber
16:21:07 <esap> shapr: Hmm.. let me think, something related to time, definitely.
16:23:01 <esap> shapr: how about the way _tasks_ can be performed in sequence? :-)
16:23:37 <shapr> hm
16:23:57 * esap thinks tasks are physical :-)
16:24:32 <sex|more> are there any other haskell channels on freenode or other networks?
16:24:48 <shapr> yup
16:24:54 <sex|more> which?
16:24:58 <shapr> one on EFnet, one on quakenet
16:25:06 <mattam> sex|more more more more, always :)
16:25:08 <sex|more> #haskell?
16:25:13 <sex|more> ths is it :d
16:25:18 <mattam> 'night
16:25:28 <shapr> bonne nuit
16:25:32 <phubuh> scout [info]: I'm in.
16:25:34 <phubuh> Yay!!
16:25:37 <shapr> eh?
16:25:50 <phubuh> making progress on the direct connect client :-)
16:25:57 <phubuh> it logs in and stuff
16:26:01 <shapr> oh!
16:26:16 <shapr> sex|more: the other haskell channels are smaller than this one
16:26:39 <sex|more> ok, thanks for the input!
16:26:50 <sex|more> well check them after class today
16:26:53 <shapr> ok
16:27:11 <shapr> if some of them are looking for a larger group of people, they're welcome here
16:27:15 <shapr> we're not too draconian
16:27:45 <sex|more> I will tell tomorrow in class about this channel and it's great ppl!
16:28:55 <shapr> yay!
16:29:14 <sex|more> does someone of you know 2-3-Trees?
16:29:14 <shapr> where do you take classes?
16:29:27 <sex|more> I study computer science
16:29:34 <shapr> which country/city?
16:29:37 <sex|more> berlin
16:29:41 <shapr> oh, cool
16:29:41 <sex|more> at the Free University
16:30:28 <isomer> sex|more: i know that i've forgotten how to build them....
16:30:45 <sex|more> I started haskella month ago from the scratch
16:30:51 <sex|more> now haskell goes well
16:31:08 <sex|more> I have to implement that by the end of the next week either in haskell or java
16:31:54 <isomer> fun fun... :)
16:32:12 <sex|more> yes it is!
16:32:34 <sex|more> ok guys, it's already 01:33 here, I need my rest
16:32:40 <shapr> yah, me too
16:32:43 <shapr> it's 1:33 here too
16:32:44 <sex|more> deadline for my assignment is 10:10
16:32:47 <shapr> oh!
16:32:49 <sex|more> where are you?
16:32:54 <shapr> I'm in Sweden.
16:32:59 <sex|more> and wherE?
16:32:59 <shapr> 800km north of Stockholm
16:33:00 * ayrnieu returns.
16:33:06 <shapr> Boden, specifically
16:33:07 <sex|more> pretty far notrth :d
16:33:13 <sex|more> fucking cold :d
16:33:15 <shapr> yah, it's dark, dark, dark, here.
16:33:18 <shapr> and yes, fucking cold.
16:33:22 <sex|more> he he
16:33:30 <shapr> -15°C today.
16:33:36 <sex|more> woooooooooooooooow
16:33:39 <sex|more> damn cold!
16:33:44 <shapr> and it just gets colder
16:33:50 <sex|more> we had a few degrees!
16:33:53 <sex|more> 5
16:33:54 <sex|more> maybe
16:34:03 <_joey> it's been over +35 C here for 3 days in row now
16:34:12 <sex|more> where are you??
16:34:17 <sex|more> damn, want to be with you there :D
16:34:27 <shapr> coupla years ago, I lived in Finland near here, it got down to -35°C on our front porch, and -45°C in the next town over.
16:34:33 <_joey> shapr good for you, you can sit home and learn programming in this cold weather:)
16:34:45 <sex|more> -45 cool
16:34:50 <sex|more> siberia -60
16:34:52 <sex|more> this is cool
16:35:05 <sex|more> run your PC w/o addtional cooling!
16:35:06 <_joey> in some places of Siberia
16:35:11 <shapr> I'm from Alabama! I'm not used to this!
16:35:56 <shapr> _joey: I want to visit someplace where it's +35°C
16:35:59 <shapr> for like..
16:36:01 <shapr> a few years.
16:36:11 <isomer> shapr: i recommend...melbourne!
16:36:24 <shapr> I was thinking of maybe Sydney.
16:36:37 <shapr> actually, what's the biggest city in New South Wales?
16:36:39 <isomer> that's a good place, too
16:36:47 <isomer> so is brisbane
16:36:55 <shapr> where's unsw?
16:37:01 <shapr> I'd like to spend awhile at unsw.
16:37:08 <isomer> i'm guessing sydney
16:37:54 <_joey> Gold Cost is popular too
16:38:12 <shapr> I'd love to hang out with the Haskell guys at unsw.
16:38:15 <_joey> Sydney is expensive
16:38:23 <shapr> compared to what?
16:38:31 <sex|more> I'd like to be in the Caribbean :D
16:38:32 <_joey> compared to the rest of Australia
16:38:47 <isomer> i *really* like melb.
16:39:06 <sex|more> how's brisbane?
16:39:11 <shapr> how much time have you spent in au anth?
16:39:21 <isomer> about 4 months
16:39:24 <shapr> neat
16:39:27 <sex|more> cool
16:39:31 <sex|more> small town?
16:39:50 <isomer> well, melbourne is a couple million people....so....no
16:39:52 <shapr> isn't melbourne relatively large?
16:40:07 <shapr> guess so
16:40:09 <sex|more> we have 3,4 Million in berlin!
16:40:10 <_joey> 2nd biggest city in .au
16:40:12 <_joey> :)
16:40:17 <sex|more> area 902 km²
16:40:18 <shapr> sex|more: that's extra large!
16:40:20 <shapr> with cheese!
16:40:22 <sex|more> pretty large
16:40:27 <sex|more> :d
16:40:30 <sex|more> and salami!
16:40:34 <shapr> heh!
16:40:51 <shapr> I wonder how the population density compares to my hometown, Birmingham, Alabama
16:41:04 <shapr> last I checked we had 1.3 mil in an area 25x33 miles
16:41:12 <_joey> did you know that nearly a half of Australian population live Melbourne and Sydney
16:41:21 <sex|more> sure
16:41:26 <sex|more> and dundee in the outbak
16:41:27 <sex|more> ck
16:41:31 <shapr> sounds like Sweden and Finland, everyone lives in the cities in the south, and the north is empty.
16:41:32 <_joey> :))
16:41:33 <isomer> shapr: http://etherealplanet.org/ftp/Files/park%20near%20parliament.jpg
16:41:47 <isomer> that's right in the middle of the city
16:41:47 <shapr> isomer: whoa, addictive
16:42:13 <sex|more> who is this girl on the lawn
16:42:15 <sex|more> down right
16:42:21 <sex|more> nice legs!
16:42:23 <shapr> she's the decoration.
16:42:23 <sex|more> :d
16:42:26 <isomer> wish i knew
16:42:36 <sex|more> did you "check" the deco before? :d
16:43:00 <isomer> lucky me, i only had to stay in a hotel for 3 nights before i met a nice girl who took me in :)
16:43:13 <isomer> hostel rather
16:43:17 <shapr> lucky you
16:43:19 <sex|more> welll done!
16:43:27 <sex|more> how are assie girls?
16:43:30 <sex|more> aussie
16:43:36 <isomer> we canadians are "exotic", you see... :)
16:44:03 <sex|more> I've been to toronto in summer 2001
16:44:06 <isomer> sex|more: everyone i met there was incredibly nice
16:44:07 <sex|more> fukcing rainy!
16:44:19 <sex|more> damn, aus a place to fuck!
16:44:27 <sex|more> let's get my ticket to down under!
16:44:27 <sex|more> :D
16:44:50 <shapr> man, I bet americans aren't exotic.
16:44:57 <isomer> sure you are!
16:45:04 <shapr> in au?
16:45:06 <mgoetze|away> americans living in sweden are exotic!
16:45:11 <shapr> mgoetze|away: that's true.
16:45:16 <shapr> especially where I live.
16:45:18 <sex|more> if someone wants to see th e best european chicks
16:45:22 <sex|more> go to Hungary
16:45:25 <sex|more> AWESOME chicks!
16:45:31 <sex|more> best I've ever seen"
16:45:31 <mgoetze|away> btw, how's your german girlfriend, if you're still with her? :)
16:45:32 <isomer> i thought spain, no?
16:45:46 <shapr> mgoetze|away: she's fine, learning swedish quickly.
16:45:54 <sex|more> hungarians are unique!
16:46:05 <shapr> I'm unique, just like everyone else.
16:46:16 <sex|more> he he:D
16:47:03 <ddarius> No you aren't shapr.  You're unique, but not like everyone else.
16:48:09 <ayrnieu> "No, you aren't shapr." "But then -- who am I?"
16:49:47 * ayrnieu wonders if he should find a better way to write these functions than as if they modeled a state machine: serverStart serverListen serverGoAway, etc.
16:52:02 <sex|more> well, gentlemen=
16:52:07 <sex|more> I need finally my rest
16:52:11 <sex|more> I am outta here
16:52:21 <sex|more> good night and keep haskelling!
16:52:23 <shapr> ddarius: thanks, I think ;-)
16:52:27 <shapr> yah, I gotta sleep too
16:56:32 <Lor> Wow, I started using wiki to organize my ideas on my thesis, and I'm actually getting things written.
17:12:31 <ayrnieu> Shock of shocks, I still have trouble with PortNumber and co.
17:26:51 <keir> in a do expression, i have a bunch of nested if's
17:26:58 <keir> and the layout is getting pretty grotty
17:27:23 <keir> is there a nice way to make the layout so that it's like what you'd expect in a normal imperetive language?
17:27:28 <ayrnieu> Could you paste it?
17:27:32 <keir> ok
17:27:33 <keir> one sec
17:27:37 * isomer is away: grinding out problems
17:27:46 <ayrnieu> keir - nested ifs get pretty grotty in any language -- why do you think that they're especially so in Haskell?
17:27:46 <keir> beware paste
17:28:06 <keir> main :: IO ()
17:28:06 <keir> main = do line <- getLine
17:28:06 <keir>           if (line == "q" || line == "quit") 
17:28:06 <keir>             then return ()
17:28:06 <keir>             else do let exprdata = apply assignment line
17:28:07 <keir>                     print exprdata
17:28:09 <keir>                     main
17:28:11 <keir> ok
17:28:19 <keir> i'd like to move the else in line with the first if
17:28:26 <keir> but it doesn't work if i do that
17:28:47 <keir> and i need to add a bunch of conditions, ie, if exprdata == [], then i have to apply a different parser
17:28:54 <Pseudonym> No.  That's usually considered a mistake in the syntax and it will probably be fixed next standard.
17:29:21 <keir> it took me 20 mins to figure out how the layout engine wanted the do formatted
17:29:50 <Pseudonym> You could, I suppose, try introducing auxilliary functions.
17:29:58 <Pseudonym> do line <- getLine
17:30:01 <Pseudonym>     f line
17:30:02 <Pseudonym> where
17:30:08 <Pseudonym>   f "q" = return ()
17:30:12 <Pseudonym>   f "quit" = return ()
17:30:21 <Pseudonym>   f line = do let exprdata = {- etc -}
17:30:35 <keir> yes.
17:30:36 <Pseudonym> You can, of course, put guards on f.
17:30:44 <Pseudonym> Also a case expression may help.
17:30:59 <Pseudonym> do line <- getLine
17:31:06 <keir> if i use { ... } and semicolons, can i lay it out however i please?
17:31:12 <Pseudonym>    case () of
17:31:31 <ayrnieu> keir - you can, indeed.
17:31:33 <Pseudonym>      _ | line == "q" || line == "quit" = return ()
17:31:45 <Pseudonym>        | otherwise = do {- whatever -}
17:32:09 <Pseudonym> case expressions are good for mixed pattern matching and multiple guards rather than a simple if-then-else.
17:32:10 * ayrnieu is a bit dubious about the improved syntax.
17:32:29 <keir> is there an 'in' operator like python? ie, if quit in ["q","quit","exit"]...
17:32:51 <keir> any (quit==) lst
17:32:52 <Pseudonym> Yes, there's elem.
17:32:55 <keir> oh
17:32:57 <keir> that too
17:33:08 <Pseudonym> if quit `elem` ["q","quit","exit"]
17:34:00 <Pseudonym> "null" is also a good function to know.
17:34:05 <Pseudonym> null [] = True
17:34:07 <Pseudonym> null _  = False
17:38:13 <ayrnieu> keir - do you really think that your original code was all that grotty?
17:38:23 <keir> not yet
17:38:36 <ayrnieu> keir - were you planning on defining all commands in the same manner?
17:38:36 <keir> ayrnieu, not yet! but it will be
17:38:45 <keir> ayrnieu, no.
17:39:16 <keir> ayrnieu, it's just a simple program that parses assignments (ie, "var1 = 1 +2*(23-4)/y")
17:39:25 <ayrnieu> keir - why else did you expect to have a nested if in there?
17:39:25 <keir> and print statemets ("print var'")
17:39:38 <keir> give me a few mins i'll code it
17:39:54 <keir> i have the parser working thougH! i reached enlightenment around 4am
17:55:30 <keir> now it's grotty
17:55:37 <keir> main :: IO ()
17:55:37 <keir> main = do line <- getLine
17:55:37 <keir>           if (line == "q" || line == "quit") 
17:55:37 <keir>             then return ()
17:55:37 <keir>             else do let exprdata = apply statement line
17:55:37 <keir>                     if null exprdata
17:55:37 <keir>                       then do putStrLn "Syntax error"
17:55:39 <keir>                               main
17:55:41 <keir>                       else do let [(expr,rest)] = exprdata
17:55:43 <keir>                               if not $ null rest
17:55:45 <keir>                                 then do putStrLn "Syntax error"
17:55:47 <keir>                                         print (expr, rest)
17:55:49 <keir>                                         main
17:55:51 <keir>                                 else do print expr
17:55:53 <keir>                                         main
17:56:40 <Pseudonym> OK, seems to me like you should perhaps start to use parser combinators.
17:56:45 <Pseudonym> Or something like then.
17:57:13 <Pseudonym> At the very least, abstract out some of these operations.
17:57:47 <keir> i am using  them
17:58:00 <keir> the problem is that i have to handle interactive useage
17:58:02 <Lor> What a huge function.
17:58:04 <Pseudonym> But not to handle the "quit" command.
17:58:08 <keir> no
17:58:14 <keir> true
17:58:16 <keir> good point
17:58:19 <Lor> No function should be bigger than ten lines. :)
17:59:38 <keir> Lor: never manually unrolled assembly have you? ;)
18:00:11 <Lor> In human discourse, there is such a thing as context, y'know...
18:00:20 <Pseudonym> Obviously Lor's "ten line" rule scales with the expressivity of the language.
18:00:50 <Pseudonym> So, say, if assembly requires 1,000 lines where Haskell requires one, then Lor's rule of thumb would mean that 10,000 line assembly functions are appropriate.
18:00:54 <Lor> Yeah, in C Linus's rule of thumb is good: a function ought to fit in one terminal screen, ie. 80x24.
18:00:55 <keir> hehe
18:01:01 <keir> i was just being a jerk ;)
18:01:03 <Pseudonym> HOWEVER: Assembly language doesn't have functions.
18:01:10 <keir> Pseudonym, that's not true
18:01:15 <Pseudonym> At least not any assembly language that I'm aware of.
18:01:18 <Lor> All right, it has entry points.
18:01:21 <Lor> Labels.
18:01:22 <keir> assembly absolutely does have functions
18:01:25 <keir> in fact in my last lab
18:01:36 <keir> in 68k assembly, i was passing functions around to other functions
18:01:46 <keir> i got my prof nicely confused 
18:01:47 <Pseudonym> No, you were passing addresses.
18:01:50 <Lor> Actually, just a small while ago I explained to someone that assembly has neither loops nor recursion, it's just capable of expressing the same computations as those constructs.
18:02:25 <Pseudonym> Precisely.
18:02:27 <Lor> Someone had the opinion that assembly inherently supports loops but not recursion and therefore loops are faster and better. :P
18:02:30 <Pseudonym> That's my point exactly.
18:02:31 <_joey> you coud even implement Classes in Assembly
18:02:45 <Pseudonym> You can implement anything Turing-hard in assembly.
18:03:02 <Pseudonym> But, and this is the key point, no mainstream assembly languages provide them.
18:03:02 <Smerdyakov> Pseudonym, but not if it's easier than Turing-hard?
18:03:07 <Lor> I then tried to explain that a piece of assembly code could result either from a loop or from a tail-recursive construct and still look exactly the same.
18:03:17 <_joey> anything is not practicable, however, classes have been implemented and shown as an example to us
18:03:32 <Pseudonym> Smerdyakov: I'll have to check. :_)
18:03:33 <Lor> pseudonym, can you provide a language-agnostic definition of "function"?
18:03:53 <Pseudonym> Lor: Absolutely.  A function is something that takes arguments and returns a value.
18:03:55 <Lor> What would make a particular assembly feature a function.
18:04:12 <Lor> pseudonym, how do you define argument and value in a language-agnostic way?
18:04:26 <Pseudonym> Arguments are values.
18:04:33 <_joey> function doesn't have to arugments
18:04:38 <Lor> Why couldn't I say that x86 assembly has functions and argument means pushing a value and return value means something you pop?
18:04:39 <Pseudonym> Where a "value" is a programmer-interpreted class of data objects.
18:05:18 <Pseudonym> Parnas, Shore and Weiss deal with this in their paper, "Abstract Types Defined as Classes of Variables".
18:05:29 <Pseudonym> Don't have an online reference handy, unfortunately.
18:05:45 <Pseudonym> Might be on citeseer.
18:06:01 <Pseudonym> Lor: Ah, that's something different.
18:06:11 <Pseudonym> Saying that you can implement functions in assembly is one thing.
18:06:18 <Pseudonym> Saying that assembly provides functions is something different.
18:06:30 <Pseudonym> Assembly provides all of the mechanisms required to implement functions, for sure.
18:06:45 <Pseudonym> Or, perhaps, a sufficient set of features to implement functions.
18:06:59 <keir> in 68k assembly
18:07:03 <keir> there is bsr
18:07:06 <keir> branch to subroutine
18:07:13 <Pseudonym> And that transfers control.
18:07:16 <keir> which saves the PC to the stack and jumps
18:07:23 <keir> then on the other ende, there is 'return'
18:07:25 <Pseudonym> OK.  That's still not a function.
18:07:35 <Pseudonym> At best, it's a "subroutine".
18:07:36 <keir> which pops the PC and goes back to the instruction after the BSR
18:07:50 <Pseudonym> Argument passing and value return is the province of the ABI, not of the assembly language.
18:08:00 <Pseudonym> ABIs provide functions.  I'll concede that.
18:08:29 <ayrnieu> Perl lacks 'arguments' in the traditional sense in that function define their arguments by how they use an array defined in their context -- actual passing is the caller's business, and actual declarations of 'arguments' only serve to aid caller syntax.
18:08:31 <Pseudonym> Some assembly languages don't even provide subroutines.
18:08:42 <Lor> pseudonym, but since essentially all the processor does is move electrons around, how do you say when something it does is "inherently" a function call and when it is only a representation of function call?
18:08:59 <Lor> You always have a layer of arbitrary interpretation.
18:09:02 <keir> technically, all you need is one instruction with three operads -- subtract and branch if negative
18:10:02 <Pseudonym> Lor: That's true.  A particular C program, for example, may be written in an object-oriented way.
18:10:11 <Pseudonym> But that's not the same as claiming that "C has objects".
18:10:21 <Pseudonym> Because it doesn't.
18:10:25 <Lor> But can you draw an absolute line?
18:10:32 <Pseudonym> Yes, I believe I can.
18:11:00 <Pseudonym> The line is drawn between what is directly supported and what you have to do yourself.
18:11:04 <ayrnieu> Pseud - aside, the HP49G's assembly has 'subroutines' in the sense that the best editor for it had a database of official and discovered useful entry points into the ROM.
18:11:13 <Lor> Would "having functions" be a feature of _assembly_ or of the machine language?
18:11:30 <_joey> I know 68K and DLX provide functions
18:11:40 <Smerdyakov> It would be a feature of discussing ludicrous things!
18:11:44 <Pseudonym> Lor: "Having functions" is a feature of the machine + ABI, or of the particular program.
18:12:00 <Pseudonym> Or of the language which was translated into the machine's native language.
18:12:11 <keir> is there a read-line alike function that handles backspace in haskell?
18:12:21 <ayrnieu> keir - GHC comes with a 'readline' library.
18:12:23 <keir> getLine also hands me those wonderful \DEL characters
18:12:36 <Pseudonym> I used, for example, to use a set of 8086 assembler macros that provided "functions".  So it just goes to show that the layer of abstraction is pretty thin.
18:12:43 <Smerdyakov> keir, I'd bet that that's a problem with your terminal setup./
18:12:50 <Pseudonym> _joey: No they don't.
18:13:03 <Pseudonym> The MIPS chip doesn't even provide subroutines!
18:13:12 <Pseudonym> If you want to push the program counter, you do it yourself.
18:13:32 <ayrnieu> getName = do mN <- readline "What's your name? "
18:13:32 <ayrnieu> 	     case mN of
18:13:32 <ayrnieu> 		     Nothing -> do putStrLn ""			
18:13:32 <ayrnieu> 				   getName
18:13:32 <ayrnieu> 		     Just "" -> getName
18:13:33 <ayrnieu> 		     Just s -> return s
18:13:44 <Pseudonym> And to return from a function, you jump to the location passed in a specific register mandated by the ABI.
18:14:31 <ayrnieu> seems fairly easy to use -- but the library is typically documented, so you'll have to be very familiar with both GNU Readline and Haskell to be able to do more complex operations.
18:14:41 <Pseudonym> Damn, people have started to ignore me.  Now I'll have to find some other way to avoid work.
18:14:51 <Smerdyakov> Pseudonym, you are talking about the most inane subject imaginable.
18:15:02 <Pseudonym> Oh, no.  Not even close.
18:15:10 <Pseudonym> I can think of far, far more inane subjects.
18:15:11 <Smerdyakov> Pseudonym, arguing over why someone else's arbitrary definition of something is not the same as yours, as far as I can tell.
18:17:10 <Pseudonym> You haven't even scratched the surface of my potential inanity.
18:17:14 <ayrnieu> Pseudonym - arguing that something doesn't have functions because it only has functions by building on something that certainly does not have functions is also somewhat odd.
18:17:30 <Pseudonym> Why not?
18:17:46 <ayrnieu> Pseudonym - because that renders 'function' a useless word, and I hate it when people do that.
18:17:55 <Pseudonym> Would you say that C has objects?
18:18:05 <Pseudonym> Is "object" therefore a useless word?
18:18:21 <ayrnieu> Pseudonym - you've got my complaint entirely backwards.
18:18:21 <Pseudonym> (It might be anyway, but I maintain that it's not for this reason!)
18:18:42 <_joey> Pseudonym: do you want me to pull out the notes and give you an example?
18:18:46 <Pseudonym> I disagree.  A function is a fairly well-understood abstraction.
18:19:03 <_joey> they don't provide scoping like you get in C
18:19:06 <Pseudonym> A very thin abstraction on top of a physical machine, but an abstraction nonetheless.
18:19:16 <_joey> but you could label it (name it), define it and call it later
18:19:37 <Pseudonym> _joey: I believe that you can implement objects in C, but I don't believe that C provides the object as an abstraction.
18:20:13 <Pseudonym> You can implement closures in C, too.
18:20:17 <_joey> Pseudonym: go away man
18:20:18 <Smerdyakov> Time out, biatches.
18:20:18 <Pseudonym> Or type classes.
18:20:29 <ayrnieu> Pseudonym - it is in a context -- in a mathematical context, certainly, but you've already partially violated the C concept of a function with your assertion that a function necessarily returns a value.  Does this mean that C doesn't have functions, or that you're abusing the language to say that it doesn't?  The latter is OK for humor or for comparison, but it has to be *for* *something*!
18:20:57 <Smerdyakov> All further arguing on the subject is prohibited until Pseudonym gives a rigorous definition of "function," "object," or whatever else is in the air at the moment.
18:21:05 <Pseudonym> OK, ayrnieu, this raises a slightly different issue.
18:21:37 <Pseudonym> The C language has something that it calls a "function" which isn't exactly a mathematical function, but is pretty close to the normal imperative programming language definition of a "function".
18:21:45 <_joey> using C to implement OO features could be akward but you can still implement anything you find in any other OO langauage
18:21:49 <Pseudonym> The one catch is that C functions can return "void", which technically makes the procedures.
18:21:52 <_joey> so don't troll 
18:21:58 <Pseudonym> _joey: That's my point!
18:22:02 <ayrnieu> Pseudonym - perhaps the issue is that I see 'function' as inherently an, erm, I forget the term -- let's call it a 'null word' whose meaning is determined by its context.
18:22:37 <Pseudonym> @foldoc function
18:22:38 <lambdabot> *** "function" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
18:22:38 <lambdabot> function
18:22:38 <lambdabot>      
18:22:38 <lambdabot>         1. <mathematics> (Or "map", "mapping") If D and C are sets
18:22:39 <lambdabot>         (the domain and codomain) then a function f from D to C,
18:22:41 <Pseudonym> @more
18:22:41 <lambdabot>         normally written "f : D -> C" is a subset of D x C such that:
18:22:43 <lambdabot>      
18:22:45 <lambdabot>         1. For each d in D there exists some c in C such that (d,c) is
18:22:48 <lambdabot> [23 @more lines]
18:22:49 <lambdabot>         an element of f.  I.e. the function is defined for every
18:22:51 <lambdabot>         element of D.
18:22:53 <lambdabot>      
18:22:54 <Pseudonym> @more
18:22:55 <lambdabot>         2. For each d in D, c1 and c2 in C, if both (d,c1) and (d,c2)
18:22:58 <lambdabot>         are elements of f then c1 = c2.  I.e. the function is uniquely
18:22:59 <lambdabot>         defined for every element of D.
18:23:01 <lambdabot>      
18:23:03 <lambdabot>         See also {image}, {inverse}, {partial function}.
18:23:05 <lambdabot>      
18:23:07 <lambdabot> [14 @more lines]
18:23:07 <Pseudonym> @more
18:23:09 <lambdabot>         2. <programming> Computing usage derives from the mathematical
18:23:11 <lambdabot>         term but is much less strict.  In programming (except in
18:23:13 <lambdabot>         {functional programming}), a function may return different
18:23:15 <lambdabot>         values each time it is called with the same argument values
18:23:17 <lambdabot>         and may have {side effects}.
18:23:19 <lambdabot>      
18:23:22 <lambdabot>         A {procedure} is a function which returns no value but has
18:23:23 <lambdabot>         only {side-effects}.  The {C} language, for example, has no
18:23:25 <lambdabot>         procedures, only functions.  {ANSI C} even defines a {type},
18:23:26 <Pseudonym> @more
18:23:27 <lambdabot> [5 @more lines]
18:23:29 <lambdabot>         {void}, for the result of a function that has no result.
18:23:31 <lambdabot>      
18:23:33 <lambdabot>         (1996-09-01)
18:23:35 <lambdabot>      
18:23:37 <lambdabot>      
18:23:37 <Pseudonym> Here we are.  Definition 2 is what I mean by "function".
18:23:56 <Pseudonym> Smerdyakov: Happy now?
18:24:18 <ayrnieu> This definition conflicts with Haskell, but foldoc says that it is the 'programming' definition.  That's nice.
18:24:33 <Pseudonym> It doesn't conflict with Haskell.
18:24:48 <Pseudonym> It notes that in functional programming, functions are pure and have no side-effects.
18:24:56 <Pseudonym> And in other languages, they may not.
18:25:08 <Pseudonym> I'm paraphrasing, obviously.
18:25:10 <ayrnieu> Pseudonym - when does a function in haskell ever return a different value given the same arguments when you don't use an intentionally worldview-violating binding?
18:25:28 <Smerdyakov> Pseudonym, no. To have an argument of the sort you've been attempting, you need to define "what is a function?" in terms of a decision procedure.
18:25:30 * Pseudonym points to the words "except in {functional programming}".
18:25:36 <Smerdyakov> Pseudonym, otherwise, how can we tell who's right?
18:25:36 <_joey> Pseudonym: you know what Perl programmers do if they can't find interesting OO features built-in in the lnaguage, they implement it, put it in library and use it
18:25:47 <ayrnieu> Great, so now we've recovered 'function' from the jaws of one definition and returned to definition-in-context.
18:26:59 <Pseudonym> Smerdyakov: I don't think that we need a decision procedure.  I believe that the concept of a "function" is sufficiently well-understood.
18:27:09 <Pseudonym> A dictionary definition is sufficient, surely.
18:27:15 <Smerdyakov> Pseudonym, obviously not, since we've had so much disagreement here.
18:27:22 <diminished> Which is better Haskell or Ocaml?
18:27:36 <ayrnieu> joey - Perl OO *is* built into the language; it has a special syntax and a magical 'bless' function.
18:27:47 <Pseudonym> Yup.
18:28:06 <ayrnieu> Pseudonym - It's never been sufficient for me, but OK.
18:28:07 <Pseudonym> Perl has language support for OO style.
18:28:42 <ayrnieu> diminished - Haskell, because you spelled it correctly.
18:28:59 <ayrnieu> diminished see www.ocaml.org if you're interested in O'Caml
18:30:32 <_joey> ayrnieu: it has but it doesn't provide all the features
18:30:50 <_joey> and setting up certain OO constructs isn't pleasant
18:31:32 <Pseudonym> _joey: See, I knew you'd see it my way. :-)
18:31:48 <ayrnieu> joey - 'all the features' doesn't make sense to me, nor does 'certain OO constructs'.  Are you suggesting that other languages have features that they associate with OO that Perl does not?  Sure -- Perl has no built-in support for multiple dispatch.
18:31:53 <_joey> I am not supporting your agument
18:31:55 <Pseudonym> Assembly doesn't provide all the features required of functions, either.  It just provides a set of operations upon which functions can be implemented.
18:32:13 <_joey> ayrnieu: doesn't make sense?
18:32:24 <_joey> you go and find out for yourself what's missing and what's not
18:32:29 <Pseudonym> _joey: I know, hence the smiley.
18:32:39 <Pseudonym> You seem to be using a similar argument than I was, though.
18:32:47 <ayrnieu> joey - in order to find out for myself, I would have to first READ YOUR MIND to discover what you consider to be an OO feature.
18:33:01 <_joey> besides, Perl OO suck and other features suck so bad that the author decided to change about 35% of the language
18:33:26 <ayrnieu> joey - and now you've left the realm of of discussable things.  You suck!
18:33:30 <Pseudonym> _joey: I was there when Larry Wall announced Perl 6.  He put it very differently.
18:33:58 <_joey> ever tried to implement private variables in perl?
18:34:13 <Pseudonym> They're perfectly implementable.
18:34:22 <Pseudonym> It's just up to everyone lese not to touch them.
18:34:28 <Pseudonym> s/lese/else/
18:34:41 <_joey> ayrnieu: want to discuss Perl go ahead, I'd give you the list and find all the modules they put on CPAN to ease the use of OO in Perl
18:34:50 <Pseudonym> As he noted himself, "I'd rather you didn't come into my house because you're not invited, not because I own a gun".
18:35:20 <_joey> Pseudonym: it's not implementing , it's convention to to touch them, but you can still implment privacy in Perl using closures
18:35:25 <Pseudonym> Uhm... did I just start a gun debate?  I hope not.
18:35:26 <_joey> not to touch
18:35:45 <_joey> ayrnieu: wo where are you comments you Perl export
18:35:53 <ayrnieu> Pseudonym - no, your assertion is palatable to pro- and anti- gun people alike.
18:36:00 <Pseudonym> Ah, OK.  Good.
18:36:01 <_joey> it's funny how many people start defending Perl without actually knowing much about it:))
18:36:11 <Pseudonym> _joey: I know a lot about Perl.
18:36:34 <ayrnieu> joey - why do you assume that I know little about it?  Because you assert that many modules exist to make OO easier in Perl?
18:36:36 <Pseudonym> I was there when Larry announced Perl 6 because I was presenting a paper at TPC 4.
18:37:08 <diminished> why learn O'Caml or Haskell.. ?
18:37:10 <_joey> ayrnieu: I assumed you've been talking out of your sphincter
18:37:19 <diminished> ayrnieu: why learn O'Caml or Haskell.. ? ;]
18:37:30 <ayrnieu> joey - private variables aren't what I consider to be an interesting OO feature -- but it's possible to implement them.  Perhaps somebody will, some day, and use Perl6 to make a nice syntax.  I don't care.
18:37:57 <ayrnieu> joey - please make a log of this discussion so that you can, ten years hence, refer to it if you want a good example of somebody talking out of their sphincter.
18:37:58 <Pseudonym> diminished: How dare you stay on topic?! :-)
18:38:08 <diminished> Pseudonym: ?!?! :D
18:38:26 <Pseudonym> People might think this channel is about functional programming or something.
18:38:30 <_joey> okay, ever tried to implement late binding in Perl?
18:38:58 <Pseudonym> http://www.perldesignpatterns.com/?LateBinding
18:39:00 <_joey> ayrnieu let's see if you could write hello world in Perl:))
18:40:14 <_joey> Pseudonym: you could implement anything you want in Perl and other programming languages, it's just it's not practicable and for many large projects these languages are not acceptable
18:40:18 <Pseudonym> I don't even find late binding in Perl particularly painful.
18:40:24 <Pseudonym> Ah, now that's another issue.
18:40:31 <Pseudonym> Is Perl good for large projects?
18:40:32 <ayrnieu> diminished - because Haskell is a useful language with astonishing expressivity, several good implementations with likewise good libraries, a forest of accessible and information academic features on various features of the language, and such as Concurrent Haskell and Template Haskell to aid in programming -- Concurrent Haskell particularly interests me, because it makes Haskell one of two languages that I find to have palatabl
18:40:32 <ayrnieu> e concurrency-oriented-programming (Haskell and Erlang, for now).
18:40:40 <Pseudonym> The answer is "yes and no".
18:40:52 <_joey> anyway, I'm off to learn Haskell:)
18:41:00 <Pseudonym> Perl is a fine "soft layer" for a large project, but I wouldn't want to write _all_ the code for a large project in Perl.
18:41:33 <Pseudonym> Perl is glue.
18:41:35 <ayrnieu> diminished - I still haven't played with Template Haskell, because the last I read about it wasn't in stable GHC.  It seems nifty in that it allows you to write programs that occur at compile-time.
18:42:09 <diminished> ayrnieu: but why use the time to learn such a language when you can't really make use of it in the real world?
18:42:13 <ayrnieu> Pseudonym - I hate that term, 'glue', simply because I always remember the smell of glue when somebody uses it.  Ick.
18:42:19 <Pseudonym> :-)
18:42:45 <Pseudonym> diminished: Many people have found that learning Haskell makes their imperative code better.
18:42:48 <ayrnieu> diminished - eh?  I use it in the real world
18:43:11 <diminished> Pseudonym: oh, so its more of a learning aid kinda thing..
18:43:11 <Pseudonym> I use it in the real world too.
18:43:23 <Pseudonym> No, that's not what I'm saying.
18:43:33 <Pseudonym> A good programmer has many tools at their disposal.
18:43:40 <diminished> Hmm
18:43:50 <Pseudonym> There are a few things to consider.
18:44:02 <Pseudonym> First off, not all of the code you write goes straight into a product.
18:44:04 <diminished> The concepts aid you in better code design in other languages.. that what you mean?
18:44:19 <Pseudonym> You also write code generators, programs to massage data into a form which the product uses etc.
18:44:21 <ayrnieu> diminished - if you mean that Haskell-requiring jobs are few, OK.  There is a small set of languages that tend to be required by name in job applications -- and different sets if you restrict your search for specific kinds of jobs.
18:44:43 <Pseudonym> Also, programs are slowly but surely going multi-language.
18:44:55 <Pseudonym> .NET is just the latest incarnation of this.
18:45:09 <diminished> yeah
18:45:46 <Pseudonym> I _also_ mean that the concepts aid you in better code design in other languages.
18:45:56 <Pseudonym> But I don't mean to say that Haskell is useless for anything else.
18:46:04 <Pseudonym> Far from it.
18:47:30 <diminished> So basically.. all you can write in Haskell is console apps?
18:48:33 <Lor> Huh?
18:48:40 <Pseudonym> Er... no.
18:48:43 <Pseudonym> No more than in C.
18:49:03 <ayrnieu> diminished - where are you getting these silly questions from?
18:49:54 <diminished> :>
18:50:03 <diminished> uhh..
18:50:08 * diminished forgot
18:50:17 <Pseudonym> You just wanted to kill the "functions in assembly" discussion, didn't you.
18:50:20 * diminished points north
18:50:23 <Pseudonym> Don't blame you.
18:50:31 <ayrnieu> diminished - Haskell has more than 'read from terminal' and 'print to terminal' in terms of IO.  It also has 'read to handle' and 'write to handle' and 'read from socket' and 'write to socket' -- which is enough, all by itself, for X and an IRC server -- if those aren't console apps in your estimation.  There's also HOpenGL, for one of several GUI libraries.  There's also various FFI libraries.
18:50:37 <ayrnieu> !!
18:50:47 <ayrnieu> diminished - clever
18:51:15 <diminished> ;]
18:51:19 <diminished> Always.
18:53:33 * ayrnieu goes off to catch dinner.
18:54:06 <Pseudonym> Eeeuw.
18:54:24 <Pseudonym> You're going to kill an animal then eat it?
18:54:44 <Pseudonym> Or are you eating the Alaskan Running Turnip?
18:54:49 <ayrnieu> No, I'm going to catch a human and demand that it provide me with sustenance.
18:55:01 <Pseudonym> Ah, excellent plan.
18:55:22 <ayrnieu> Presumably, the human will kill the animal and then eat the parts I'm not interested in.
18:55:51 <Pseudonym> That depends whether the human is a hunter or a gatherer.
18:56:51 <ayrnieu> Is that human a gatherer if it hunts Alaskan Running Turnips?  A hunter if it harvests domesticated animals?
18:57:21 <Pseudonym> Good question.  I'm not up with newfangled "agriculture".
18:57:33 <Pseudonym> I think it's going to be a passing fad.
18:58:44 <Pseudonym> We should never have come down from the trees, if you ask me.
19:19:47 * ayrnieu returns for the second time in as many announcements.
19:19:52 <Lor> Does anyone have an opinion on whether haskell ought to have observable sharing, ie. objects with distinct identities?
19:20:35 <Pseudonym> I think that would be a fine feature, if Haskell had objects.
19:21:14 <Pseudonym> (No, I'm not starting another flame war.)
19:21:38 <Pseudonym> Algebraic data types should support algebraic/semantic equivalence, not object identity.
19:21:59 <Pseudonym> Objects support object identity.
19:23:17 <Lor> I don't mean OO. Just having, um, things with identities, whatever you call them.
19:23:22 <Lor> http://citeseer.nj.nec.com/claessen99observable.html
19:23:50 <Lor> Essentially, "ref a" will return a new object with the value of a, but another "ref a" will return another one which compares inequal with the first one.
19:23:55 <Lor> So it breaks referential transparency.
19:24:13 <Lor> But Claessen argues that it's not all that bad.
19:24:19 <Pseudonym> Yes.  Well we kind of have that already, only Haskell's refs are embedded in monads.
19:24:28 <Pseudonym> e.g. IORefs, MVars, STRefs etc.
19:24:52 <Lor> Of course. I was talking of the pure language, and making it thus partly impure.
19:25:14 <Lor> The point is that we already care about sharing, and the identites of objects, because of efficiency reasons.
19:25:42 <Pseudonym> I'll read the paper and get back to you.
19:26:05 <Lor> It's trivial to implement, just a simple unsafePerformIO suffices.
19:26:18 <Pseudonym> My gut feeling is that making the language "partly impure" is a cop out.  We should be searching for pure ways to do things.
19:26:27 <Pseudonym> I don't mean that as an elitist thing, either.
19:26:37 <Lor> But we _don't_.
19:26:38 <Pseudonym> Haskell's strength is that it's pure.
19:27:02 <Pseudonym> Impure or partly impure languages are fine things, but they're not Haskell.
19:27:05 <Lor> We write "f x x where x = bighugeexpr" instead of "f bighugeexpr bighugeexpr" already.
19:27:14 <Lor> Because we _care_ about sharing.
19:27:14 <Pseudonym> Still pure.
19:27:22 <Lor> Yes, but the motivation is not pure.
19:27:24 <Pseudonym> Yes, but operationally.  Not semantically.
19:27:52 <Lor> But we never really deal with non-operational semantics. We care that our programs work, _and_ that they work in reasonable time and space.
19:28:08 <Pseudonym> Haskell's semantics are pure.  Its pragmatics are, unfortunately, grounded in real implementations.
19:28:36 <Lor> What use are these pure semantics that are far removed from the implementations?
19:29:16 <Pseudonym> They're not far removed from the implementations, though.
19:29:28 <Pseudonym> Any correct implementation implements correct semantics.
19:29:44 <Lor> Yes, but _semantics_ doesn't say anything about time or space.
19:29:56 <Pseudonym> Right.  That's the domain of pragmatics.
19:29:58 <Lor> Yet the implementations do, and the users do.
19:30:17 <Lor> But this means that the semantics alone is an insufficient tool for judging the value of programs.
19:31:38 <Pseudonym> True enough.
19:31:48 <Pseudonym> For some definitions of "value".
19:32:06 <Pseudonym> Actually, pragmatics rarely get much air time in language definitions.
19:32:26 <Pseudonym> They do in library definitions sometimes.
19:32:52 <Pseudonym> For example, "the sort operation must take at worst O(n log n) time in the length of the collection".
19:33:05 <Pseudonym> You see that in library definitions.
19:33:37 <Lor> Yep.
19:34:02 <Lor> It's also funny how R5RS seemingly specifies the space usage of tail-calls, but actually it gives no guarantees about anything.
19:34:15 <Pseudonym> Yeah, it's kind of interesting.
19:34:22 <Lor> Will Clinger wrote a paper on fixing that, though.
19:34:49 <Lor> http://citeseer.nj.nec.com/clinger98proper.html
19:34:51 <Pseudonym> Interestingly, the Haskell language standard doesn't demand full laziness.
19:35:07 <Pseudonym> Suppose you have:
19:35:11 <Pseudonym> f x = x + sqrt 2
19:35:29 <Pseudonym> Then (sqrt 2) MUST NOT be evaluated unless f is called.
19:35:40 <Pseudonym> But it can be re-evaluated as many times as the implementation likes.
19:35:58 <Pseudonym> In practice, all implementations support full laziness.
19:36:02 <Lor> Yeah, call-by-need is an optimization. Call-by-name is semantically equivalent.
19:36:08 <Pseudonym> Haskell is no fun without it.
19:36:11 <ayrnieu> In Template Haskell, it can be evaluated at compile time!
19:36:21 <Pseudonym> True!
19:40:10 <Pseudonym> OTOH, other examples can't.
19:40:13 <Lor> I think an operational semantics can be used fairly easily to specify space and time requirements.
19:40:31 <Pseudonym> http://haskell.org/hawiki/LambdaLifting
19:40:42 <Pseudonym> About half-way down is an example that can't be done at compile time.
19:40:57 <Lor> Since opsem gives you an abstract machine for implementing the thing, and you can then calculate the efficiency of that abstract machine in terms of expression and context sizes and reduction steps.
19:41:13 <Pseudonym> Lor: Part of the problem is that nobody really understands Haskell's space and time pragmatics.
19:41:29 <Pseudonym> It's so highly non-local.
19:42:01 <Lor> That's one of the reasons why I think Haskell has taken the wrong evolutionary branch.
19:42:02 <Pseudonym> With fully lazy evaluation, whether something is evaluated or not is a property of the program as a whole.
19:42:53 <ayrnieu> Lor - what the right evolutionary branch have been?
19:43:06 <Lor> Well, dunno. Maybe the optimistic evaluation thingy can eventually give us space guarantees as simple as those in strict languages.
19:43:27 <Pseudonym> Lor, you might be interested in Concurrent Clean.
19:43:35 <Lor> I think strictness by default is much easier to understand.
19:43:46 <Pseudonym> It might be closer to your ideal of a pure functional language.
19:43:48 <Lor> It's also much easier to implement efficiently, but that's secondary.
19:43:56 <Lor> I don't like clean's approach.
19:44:11 <ayrnieu> I suppose that strictness by default makes laziness so much harder to understand, but OK.
19:44:24 <Lor> Monads are a better way of encapsulating side effects than uniquness types, but my gut feeling really prefers effect systems over both.
19:44:24 <Pseudonym> I don't like Clean's IO system.
19:44:35 <Pseudonym> Right.
19:44:49 <Pseudonym> What you want, I think, is Clean's approach to laziness with Haskell's approach to side-effects.
19:44:49 <ayrnieu> Lor - effect systems?
19:44:58 <Lor> Perhaps.
19:45:04 <Lor> I'm not really all that familiar with clean.
19:45:23 <Lor> ayrnieu, code the side effects an expression may have into its type.
19:45:50 <Lor> A bit like monads, except that you have subtyping: a pure function is simply a subtype of an effectful function.
19:46:27 <Lor> Most of all I like it because of the simplicity of its operational interpretation.
19:46:48 <Lor> A function is a function is a function. The effect is just an annotation that tells what is done while the function is running.
19:46:56 <ayrnieu> Lor - what would the definition of such types look like?
19:47:11 <Lor> Definition in what sense?
19:47:21 <ayrnieu> Still, I'm not sure how this would interact with laziness.
19:47:29 <ayrnieu> Lor - how would they look in code.
19:47:43 <Lor> Yeah, it mostly makes sense only with strict languages.
19:47:56 <Lor> I have some examples here: http://www.cs.helsinki.fi/u/lealanko/ttjok/
19:47:59 <Lor> It's in finnish, though.
19:48:14 <ayrnieu> But if this is a strict language, I'm not sure what the point is.
19:48:34 <Lor> "kalvot.ps.gz" are slides, there are some example typings there.
19:48:58 <Lor> ayernie, how? The point is to have the type system control side effects.
19:49:06 <Lor> And not let impurities there where they aren't wanted.
19:59:37 <Lor> Hum. On the radio someone just said "good morning".
20:00:46 <ayrnieu> Lor - top of the morning to you.
20:01:29 <Lor> I think this might be an indication that it's about time for me to go to sleep.
20:02:13 <Lor> Then again, it might be an indication that it's time for me to get up and prepare for a new day.
20:02:15 <Lor> Choices, choices...
20:03:41 <ayrnieu> Lor - just remember as you drift off that there is always a section of the planet where the sun hangs in the sky, where bright like shines through windows, where a sky of sky-blue blue does nothing to prevent the bright, shining light of the sun from forcing you to squint your eyes as evil rays streak through your poorly-protected windows and bounce glaringly off your screen, book, and such.
20:04:43 <Lor> Uh, all right, I'll keep that in mind.
20:04:46 <ayrnieu> Lor - bright light.  Always daylight.  No night ever exists all about the planet.  The sun is still shining!  Bright light!  A gigantic spotlight behind your window!  Time for activity!
20:05:23 <ayrnieu> Lor - hey, it's dawn *right now* -- wake up!  Are you sleepy?  Why didn't you sleep before?  People are already late for work!
20:05:32 <Lor> Uh, it's 6 am.
20:06:07 <Lor> But yes, if you live in a farm at the country, you ought to have been up for hours already.
20:06:27 <Lor> Nevertheless, I think I'll opt for sleep.
20:06:31 * ayrnieu is transmitting, but no communication is happening.
20:06:44 <Pseudonym> Night.
20:06:46 * ayrnieu transmits, but does not communicate.
20:07:08 <ayrnieu> Lor - good morning, and enjoy your rest.
20:13:08 <Cale> "One of the great things about static analyses is that one can always tweak any analysis system to make it more accurate." -- this corollary to the unsolvability of the Halting Problem is known as 'The Full Employment Theorem for Compiler Writers'.
20:13:09 <Cale> heh
20:13:30 <Pseudonym> Someone is reading the Tiger Book.
20:14:33 <Pseudonym> Anything by Andrew Appel is worth reading, IMO.
20:14:50 <Pseudonym> .
20:15:01 <Pseudonym> He's just that kind of writer.
