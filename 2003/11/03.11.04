00:01:47 <shapr> I don't know
00:01:54 <Darius> No
00:02:17 <phubuh> I figured
00:02:28 <Darius> (well, == on Refs works but I don't think that's what you meant)
00:02:47 <phubuh> I'm adding a bunch of cool Unicode substitution rules to Emacs :-)
00:02:55 <shapr> ??
00:03:23 <phubuh> like substituting an actual NOT-EQUAL-TO character for "/="
00:03:36 <phubuh> as in http://www.phubuh.org/~phubuh/ocaml-unicode.png
00:03:58 <shapr> oh, you can do that with LaTeX already, can't you?
00:04:02 <shapr> I'd steal their code if possible.
00:04:06 <Darius> I believe it was Koen Claussen that wanted some compiler support for observable sharing which gives you pointer equality (where requested)
00:04:29 <phubuh> yeah, that's cool... what's it called, again?
00:04:32 <shapr> phubuh: http://www.scannedinavian.org/~shae/pre-latex.png
00:04:41 <phubuh> hee hee
00:05:12 <phubuh> your colors in erc are ... weird
00:05:22 <shapr> that's resolve's color-theme, I usually use winter-day
00:05:36 <shapr> which I suspect is only used by its creator and myself.
00:07:53 <phubuh> I wonder if there is a symbol in Unicode with two overlayed plusses
00:08:05 <phubuh> like the symbol used in typeset Haskell code
00:17:59 <shapr> would be nice to have a shape based search of unicode
00:18:07 <phubuh> yeah!
00:18:28 <phubuh> maybe some OCR package can do that... it is, after all, their purpose
00:20:26 <shapr> hoi kosmikus 
00:21:08 <shapr> how do you do shape matching? give a score to correctly related pixels?
00:21:28 <kosmikus> hoi shapr
00:21:43 <shapr> how's life at uu?
00:21:44 <phubuh> feed a neural net a bunch of approximations, maybe...
00:21:44 <pesco> kosmikus: Do you know how to get a locale under gentoo that will make my programs accept UTF-8?
00:21:56 <pesco> kosmikus: Hi, btw. gnome-terminal in particular?
00:22:18 <shapr> phubuh: think that'll work?
00:23:07 <phubuh> yeah, I think I remember seeing it done
00:23:49 <kosmikus> pesco: I'm afraid not. I've never used UTF-8, and I don't use gnome-terminal either.
00:24:15 <kosmikus> pesco: unrelated: what architecture are you on?
00:24:48 <kosmikus> shapr: Daan is defending his thesis today
00:25:50 <shapr> yay!
00:26:09 <det> shapr: what if they are rotated or scaled differently
00:27:42 <pesco> kosmikus: x86
00:27:57 <pesco> kosmikus: And ppc.
00:28:12 <pesco> kosmikus: Using the x86 currently.
00:28:21 <pesco> kosmikus: Woot, I did it!
00:28:44 <pesco> localedef -f UTF-8 -i de_DE de_DE.UTF-8 generates the locale I want.
00:29:03 <kosmikus> glueckwunsch!
00:29:06 <pesco> Now xterm displayes my unicode umlauts perfectly.
00:30:18 <phubuh> yäy
01:47:15 * shapr boings
03:07:54 <Jad> hello guys
03:24:07 <shapr> hi Jad
03:24:13 <Jad> :)
03:24:24 <shapr> what's up?
03:24:31 <Jad> nothing special
03:24:37 <Jad> the lecture went great yesterday :)
03:24:47 <Jad> it is my second lecture
03:25:09 <Jad> shapr: in concurrent haskell, each runs in a proccess ?
03:25:11 <Jad> no shared memory ?
03:25:21 <shapr> huh?
03:25:39 <Jad> i want to write a simple haskell app for my cluster
03:25:45 <Jad> checking if proccess will migrate ?
03:26:29 <shapr> if you mean a PVM or MPI cluster, there isn't any easy way to migrate concurrent threads among multiple runtime instances
03:26:39 <shapr> there is hMPI by Hal
03:26:53 <shapr> which lets you explicitly manage MPI from inside Haskell
03:27:00 <Jad> ah okay
03:27:12 <Jad> but i am running an ssi (single system image cluster)
03:27:21 <shapr> and there are distributed and parallel versions of GHC, but they're limited to GHC5, not GHC6
03:27:22 <Jad> which means no code to be added in the haskell code
03:27:36 <shapr> oh, I don't know how that would work
03:28:12 <Jad> as long as each proccess doesnt share memory with the other, proccess will migrate
03:29:40 <shapr> do you mean whether Concurrent threads can share pointers to the same memory area?
03:29:56 <Jad> am asking if they do
03:30:01 <Jad> like pthreads 
03:31:05 <shapr> I'm not sure. I would guess they would, but I don't have any real reason to think that.
03:31:40 <Jad> k
03:32:02 <Jad> any way for the cluster am using openmosix 
03:32:05 <Jad> openmosix.sf.net
03:32:12 <ozone> Jad: threads in haskell are implemented entirely in GHC
03:32:36 <ozone> Jad: there's an experimental --enable-pthreads'ish switch which you can specify in ./configure, and then it'll use pthreads
03:33:04 <ozone> Jad: oh, you're talking about concurrent haskell.  silly me
03:34:16 <Jad> concurrent haskell, yep
03:35:19 <ozone> for concurrent haskell, i _think_ it's the same deal
03:35:29 <ozone> parallel haskell uses independent processes
03:36:07 <ozone> send an email to glasgow-haskell-users@haskell.org and ask, i'm sure some guru will give you an answer
03:36:16 <Jad> then concurrent haskell will run great on an ssi if so..
03:36:29 <Jad> ozone: i will
03:39:17 <ozone> sup shapr, how're you doing?
03:41:56 <shapr> running on 3 hours sleep, quietly sizzling in circles
03:42:04 <shapr> how're you?
03:44:10 <ozone> having fun
03:44:19 <ozone> i've had continuous deadlines since i've been back from work
03:44:35 <ozone> but on the bright side, now i (a) have an actual office, (b) have a shiny new G5 :)
03:44:47 <ozone> "so fast, it boots up emacs in 0.1 seconds"
03:44:52 <shapr> oh, nice
03:45:09 <shapr> my dual 1.5GHz still takes quite some time to start emacs
03:45:23 <shapr> could have something to do with my 1500 lines of .emacs maybe...
03:46:00 <ozone> maybe :)
03:46:21 <ozone> i'm pretty much not exaggerating on the emacs thing though.  started emacs after a cold boot in <1 second
03:46:26 <shapr> wow
03:46:30 <shapr> how big is your .emacs ?
03:46:33 <ozone> i think i have invented a new metric for how fast systems are
03:46:38 <ozone> err, 7k :)
03:46:39 <shapr> I should test my with a stock emacs
03:46:48 <shapr> bah, newbie ;-)
03:46:48 <ozone> 239 lines
03:47:18 <shapr> admittedly, I'd trade my elisp skillz for a post-doc FP position in a heartbeat
03:48:06 <mattam> shapr: don't you byte-compile it ?
03:48:10 <shapr> mattam: of course
03:48:31 <shapr> I even have a byte-compile-on-save hook plugged in somewhere
03:48:46 <ozone> i'll stick to vim for the majority of my editing needs
03:48:51 <mattam> i was thinking yesterday, wouldn't it be possible to use a decent lisp impl instead of elisp ?
03:48:58 <shapr> mattam: sure it would be
03:49:02 <blackdog_> but what if you _need_ a kitchen sink?
03:49:12 <ozone> sup bliick daawg
03:49:21 <shapr> mattam: but the problem is that emacs is far too tightly bound on the inside
03:49:24 <blackdog_> sup sup, my chemical friend
03:49:34 <ozone> and where are you these days?  michelle says that you were spotted at your desk some time last year
03:49:40 <shapr> XEmacs is trying to factor out the scripting engine, several of the developers would like to switch to Scheme at least
03:50:04 <shapr> but it seems that it will take several years to factor out the dependencies. scary, eh?
03:50:15 <shapr> obviously well factored != successful
03:50:20 <mattam> well, it's very mature software
03:50:24 <blackdog_> i got a laptop. :) I'm somewhat enamoured of it - haven't really felt the need to go in lately.
03:50:26 <shapr> yah, flat out ancient
03:50:45 <shapr> I think XEmacs is the only software I use that approaches my own age.
03:50:47 <ozone> blackdog_: did you get your paper submitted in time?
03:50:53 <ozone> blackdog_: i handed mine in on monday :D
03:51:02 <blackdog_> ozone: i handed it in this afternoon. :)
03:51:02 <mattam> i would start an emacs from scratch using ML if i had the time :)
03:51:03 <ozone> shapr: latex?
03:51:08 <ozone> blackdog_: ahahahaha
03:51:11 <ozone> blackdog_: ahahaha
03:51:20 <shapr> ozone: no thanks, I'm more into leather ...
03:51:28 <ozone> shapr: *fop*
03:51:33 <shapr> that's what she said ;-)
03:51:44 <mattam> well, emacs birth is approximately mine :)
03:51:50 <shapr> mattam: actually, Hemlock is the emacs clone written in Common Lisp
03:51:56 <shapr> ErMacs is written in Erlang
03:51:56 <blackdog_> Eh. I'm pretty sure mine won't get published anyway, it wasn't polished. i just want the reviewer comments.
03:52:00 <shapr> jMacs is written in Java
03:52:13 <shapr> amazingly, jMacs has a 99% correct elisp interpreter!
03:52:26 <shapr> at least, that's what the docs claim.
03:52:26 <ozone> so who's going to write bfmacs?
03:52:31 <shapr> ozone: not me.
03:52:44 <mattam> are they viable alternatives shapr ?
03:52:59 <shapr> mattam: I've heard that Hemlock is almost usable, and that jMacs is quite good.
03:53:30 <shapr> personally, I want to try programmatica, and the other editor shown at ICFP
03:53:37 <ozone> blackdog_: i hope mine gets published, i'm fairly happy with it after roman commented on it and tore it to shreds :)
03:53:39 <shapr> I'm becoming a believer in a structure editor.
03:54:11 <blackdog_> ozone: your thesis was pretty solid, i'd be surprised if the paper was rejected. Mine needed a lot more work.
03:54:38 <shapr> I've been thinking about Jad's idea from yesterday, short HOWTO docs for Haskell
03:54:56 <ozone> blackdog_: hehe, roman commented on it and said things like "hmm, you know the two styles of multiple inheritance in C++?  how does your scheme handle that?" *blank stare*
03:55:08 <shapr> He suggested HOWTOs for networking and string manipulation, do you guys have any other suggetions or ideas?
03:55:20 <ozone> how about how to write an mp3 jukebox in haskell?
03:55:26 <ozone> that way, we can have a totally useful contribution to the world
03:55:27 <shapr> ozone: what are they? ad-hoc and what?
03:55:32 <shapr> polymorphism?
03:55:45 <ozone> shapr: no, virtual and non-virtual
03:55:53 <shapr> ozone: I strongly suspect that acid aussie sense of sarcasm there...
03:56:04 <shapr> though we would get to call it heMP3
03:56:05 <ozone> C++ multiple inheritance is so whacko
03:56:21 <shapr> each copy comes with a free Dub track!
03:56:45 <blackdog_> non-virtual inheritance is just an efficiency hack anyway, isn't it?
03:56:58 <shapr> I'm soo happy I don't know C++ when I hear you guys talk about it.
03:57:14 <ozone> blackdog_: yes, but C++ has the whole PAYG thing, so "efficiency hacks" are part of the language design
03:57:26 <shapr> pay as you go?
03:58:01 <ozone> shapr: nod
03:58:06 <mattam> virtual inheritance, is like Java Interfaces inheritance right ?
03:58:21 <ozone> mattam: no, it's basically dynamic binding
03:58:37 <ozone> well, kinda
03:58:52 <ozone> if you use virtual inheritance, you only get one copy of the base class in memory
03:59:03 <mattam> ok
03:59:20 <mattam> so it's only an efficiency issue
03:59:22 <ozone> you just get a pointer to it rather than memory-extending the base class like you if you don't use it
03:59:43 <ozone> mattam: yeah, except that you get different semantics because of it
03:59:59 <mattam> how ?
04:00:00 <Jad> shapr: You can handle writing v 0.1 of any tutorial ?
04:00:50 <ozone> mattam: think of diamond inheritance ... base class A, with two classes, B and C deriving from that
04:00:59 <ozone> and another class D deriving from both B and C
04:02:08 <mattam> if B and C inherit virtually the mro is different ?
04:02:09 <ozone> if you have a method foo() in the base class A, and you call that foo() from D, then without virtual inheritance it's ambigious which A's foo you want to call
04:02:52 <mattam> k
04:02:57 <ozone> since that foo() might play with attributes in A, and depending on which A you invoke, B or C can inherit those attributes
04:03:22 <ozone> which is different with virtual inheritance, since B and C will always inherit attributes from a single source
04:03:47 <ozone> so you have to disambiguate which A's foo() you want, at the call site
04:04:19 <ozone> i'm sure there's some twisted situation where you actually want that kind of behaviour, but it's still evil :)
04:04:27 <shapr> Jad: I can probably handle writing v 0.1 of several tutorials once I read some docs
04:04:50 <mattam> yeah i know that. Wonder why i did not remember this construction... maybe because i code in ML for too long...
04:05:49 <mattam> going to uni, cul8r
04:05:55 <ozone> bibi
04:06:11 <Jad> shapr: i guess what we need now is a list of requested subjects ?
04:06:14 <ozone> blackdog_: oh, did you check out the older homestarloween cartoon?
04:06:25 <shapr> Jad: sure, but we have two to start with
04:06:40 <Jad> okay
04:06:58 <Jad> shapr: yesterday you said that String manipulation is like manipulation of lists
04:07:11 <Jad> i understood no need for the string tutorial ?
04:07:58 <blackdog_> ozone: no. Worth checking?
04:08:56 <ozone> blackdog_: most definitely -- http://www.homestarrunner.com/homestarloween.html
04:09:13 <ozone> blackdog_: btw, what spec is your new laptop?
04:10:00 <shapr> Jad: I don't know if there's a need for it or not.
04:11:09 <Jad> can i add it in the topic, any user requesting any unwritten tutorial msg shapr ?
04:11:31 <shapr> sure
04:11:40 <shapr> I think a matching wiki page is a good idea too
04:12:14 --- topic: set to '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","lots of cool debs in the haskell-experimental archive - see http://haskell.org/hawiki/DebianUsers","new monads tutorial http://www.nomaware.com/monads/html/","Haskell Refactorer - http://www.cs.kent.ac.uk/projects/refactor-fp/hare.html","en,de,fr,se,nl,pt,es,fi,pg,ru,ua"]  any user requesting any unwritten tut' by Jad
04:12:26 --- topic: set to '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","lots of cool debs in the haskell-experimental archive - see http://haskell.org/hawiki/DebianUsers","new monads tutorial http://www.nomaware.com/monads/html/","Haskell Refactorer - http://www.cs.kent.ac.uk/projects/refactor-fp/hare.html","en,de,fr,se,nl,pt,es,fi,pg,ru,ua"]' by Jad
04:12:42 <Jad> topic too large to add to.
04:12:53 <shapr> Jad: you can take out the refactorer url
04:13:08 <blackdog_> ozone:: pII, 128mb, 14 inch screen.asdads
04:13:29 <shapr> blackdog_: bit more powerful than your last one?
04:13:40 <blackdog_> uh, sorry about the asdads. network issues.
04:13:57 --- topic: set to '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","lots of cool debs in the haskell-experimental archive - see http://haskell.org/hawiki/DebianUsers","new monads tutorial http://www.nomaware.com/monads/html/","Any user who would like to request any unwritten tutorial please msg shapr"]' by Jad
04:14:01 <blackdog_> just a tad. I can run ghc _and_ vim _and_ madplay, _ALL AT THE SAME TIME!_
04:14:07 <shapr> wow, shocking!
04:14:18 <blackdog_> Ooh, and X! I almost forgot X!
04:14:22 * shapr gasps
04:14:27 <blackdog_> As you can see, i'm well nigh ecstatic. :)
04:14:35 <shapr> understandably
04:15:01 <ozone> blackdog_: how fast?
04:15:05 <ozone> and ... can you run ... emacs?
04:15:28 <shapr> well, he's running vim...
04:15:40 <blackdog_> 366 mhz, and a fat 718  bogomips.
04:15:55 <blackdog_> I used emacs for the twelf tutorial, and i didn't notice any smoke...
04:16:01 * shapr checks his bogomips
04:16:19 <shapr> hmm
04:16:22 <blackdog_> god, not in public, shae!
04:16:26 <shapr> whoops!
04:16:32 * shapr quickly hides his BogoMIPS
04:16:35 <blackdog_> *zip*
04:16:53 <ozone> i saw this chick the other day who could use a good bogomipping
04:17:02 <shapr> serious processing power you say?
04:17:26 <ozone> shapr: she could use some serious hardware, huhuuhuhuh
04:17:48 <harsha123> whats bogomips guys? ;) hehe
04:18:14 <blackdog_> ozone: you're the reason we australians get such a bad rap overseas. (Well, you and Howard. :)
04:18:17 <shapr> harsha123: dmesg | fgrep -i bogomips
04:18:43 <ozone> blackdog_: putting howard and moi in the same category is rather low, sonny
04:18:57 <blackdog_> I know. I'm not a nice person.
04:18:58 <harsha123> shapr hmm.. nothing.. 
04:19:03 <shapr> harsha123: you using linux?
04:19:11 <harsha123> OFCOURSE 
04:19:21 <shapr> it's possible your bogomips have scrolled out of the kernel message buffer
04:19:33 <blackdog_> cat /proc/cpuinfo
04:19:51 <shapr> oh, I've got two of those
04:20:06 <shapr> and the model name is different even
04:20:12 <shapr> my BIOS is confused
04:20:29 <harsha123> cat says bogomips :1490.94
04:22:33 <shapr> I have 3060.53 per CPU, and enough case fans to ride this baby around the room.
04:23:08 <harsha123> the number of million times per second a processor can do absolutely nothing.''
04:23:12 <shapr> hoverball anyone?
04:23:31 <shapr> harsha123: impressive number isn't it?
04:23:39 <harsha123> hehehe.. 
04:23:54 <shapr> one thing I learned when I bought big hardware... it doesn't improve my coding skillz any at all.
04:24:09 * harsha123 nodes
04:24:11 * harsha123 nods
04:24:53 <shapr> any recomendations for a dhcp server?
04:26:08 <ozone> udhcpd, but YMMV
04:26:21 <shapr> ok, thanks
04:30:22 <harsha123> shapr are you single? ;)
04:31:21 <shapr> er, no?
04:31:38 <shapr> you just want me for my hardware, I already know it.
04:31:51 * shapr snickers
04:32:35 <harsha123> hehehe..
04:32:51 <blackdog_> man, #haskell's blue tonight...
04:32:59 <shapr> how so?
04:33:27 <harsha123> its still back for me.. black, a bit of yellow, a pinch of blue.. and pale green ;)
04:33:33 <blackdog_> hardware? whipping out your bogomips in public?
04:33:34 <harsha123> black sorry
04:33:53 <blackdog_> hm. maybe it's an australian/english expression
04:33:54 <shapr> blackdog_: that's right
04:33:58 <shapr> hej andersca 
04:34:01 <andersca> hi
04:35:26 <ozone> blackdog_: i don't think it has anything to do with me talking, no
04:35:48 <shapr> friendster is very slow
04:39:49 <blackdog_> shapr: any hints on how to write unit tests?
04:40:34 <shapr> sure, start with something stupid
04:40:51 <shapr> what sort of code are you doing?
04:41:38 <shapr> http://www.scannedinavian.org/~shae/src/haskell/Test_Hxml.hs
04:41:50 <blackdog_> translation of GHC Core to a monadic form
04:42:13 <shapr> ok, I'd look for the simplest most straight forward test you can write
04:42:18 <blackdog_> the problem is that often, there's more than one valid way to translate a particular expression.
04:42:19 <shapr> hopefully something that takes zero work
04:42:45 <shapr> unit tests usually check for invalidities
04:43:15 <shapr> do you know when the multiple valid ways will turn out?
04:43:16 <blackdog_> Sure. But how can i check for invalidities without enumerating all the correct answers?
04:43:37 <shapr> only test the stuff that can break
04:43:42 <blackdog_> No. There's always an infinite number of ways to translate from one language to another...
04:43:55 <shapr> sure, but will your software have an infinite number of ways?
04:44:43 <blackdog_> No. But even giving the top four or five will give me tests that are enormously larger than the code.
04:44:55 <shapr> can't you break down the bits?
04:45:49 <blackdog_> not really. they're pretty atomic. every time i try to write tests, they turn out isomorphic to the code. :/
04:46:05 <shapr> I usually work my way towards tests that cover a single end to end operation first, then expand to cover the rest of the code
04:46:38 <shapr> for example, test for something that can turn only one single part of Core into one single form of the monadic stuff
04:47:10 <shapr> a good unit test suite can end up being half the size of the actual code, I've seen it, I've done it.
04:47:24 <shapr> the code never broke btw
04:47:29 <shapr> once I had that many tests
04:47:58 <shapr> blackdog_: ok, can you give some concrete examples?
04:48:17 <blackdog_> ok. hold on.
04:48:40 <shapr> from what you've said so far, you may want to try QuickCheck for testing equivalence, assuming equivalence can always be calculated from the two inputs
04:53:37 <blackdog_> I'll check QC out, then. (hm - maybe if i write the simplifier and apply it consistently, i can find a canonical form...)
04:54:10 <shapr> the difference is that I don't know how to do QuickCheck first coding
04:54:16 <shapr> though I've tried to figure it out
04:55:04 <shapr> hi Tomasso
04:55:14 <Tomasso> Hello shapr !
04:55:48 <shapr> blackdog_: with TDD, you could write a simple test to read and parse Core, and a simple test to turn one small bit of Core into your M form
04:56:07 <shapr> after each test you write the code to make the test pass
04:57:11 <shapr> unit test first has all the good points and none of the bad points of CowboyCoding
05:02:33 <blackdog_> " Since my code is never at fault, I don't need to test it thoroughly, if at all" ... uh, guilty. <sheepish>
05:39:44 <shapr> hiya Marvin-- 
05:40:34 * shapr reinstalls debian for the third time
05:40:53 <shapr> seems that the latest lilo in sarge isn't happy with me.
05:41:23 <Marvin--> hello
05:45:44 <shapr> aha
05:46:33 <andersca> li-lo?
05:46:36 * andersca tries to pronounce
05:48:40 <Darius> mutipass
05:49:26 * shapr snickers
05:49:39 <shapr> big bada boom!
05:49:52 <andersca> why don't you use grub shapr?
05:52:31 <shapr> the boot cd won't install it
05:52:33 <shapr> I tried
05:52:55 <shapr> actually, the boot cd is being difficult in several ways
05:53:01 <shapr> I don't know how many are user error
05:53:48 <Marvin--> it looks like d-i will default to grub
05:55:20 <Marvin--> well, today I've been pronounced both ill and well
05:55:32 <Marvin--> though for two different things - and at two different hospitals
06:00:11 <shapr> sounds exciting
06:01:14 <Marvin--> I'm perfectly well wrt my heart, but my thyroid gland is way ill :)
06:02:23 <shapr> hypo or hyper?
06:02:25 <Lunar^> Darius: thanks about your explaination about MonadCont, btw
06:02:40 <Lunar^> Darius: (I found it in an old log of this very channel)
06:09:12 <Marvin--> shapr: hyper
06:09:27 <Marvin--> shapr: I'm on beta blockers to keep my pulse down
06:13:26 <shapr> oh, nifty
06:14:47 <Marvin--> and now I'm going to start medicating for real and eventually perhaps even have surgery :/
06:15:35 <Marvin--> the scary part is that I have absolutely no idea how long I've had this
06:16:15 <andersca> ugh :(
06:17:25 <Marvin--> eh, but I feel just fine
06:17:29 <Marvin--> which is the weird part
06:17:37 <Marvin--> imagine how I'll feel when I'm *well* ;)
06:29:36 * Marvin-- goes back to fiddling with his proof parser
06:39:59 <Smerdyakov> Whatcha meta-provin', Marvin--?
06:47:49 <Marvin--> Smerdyakov: oh, it's for my degree project
06:48:11 <Smerdyakov> Yeah, but what's the project? ;)
06:48:11 <Marvin--> Smerdyakov: right now I'm just writing a parser for the proofs that E spits out, so I can actually read them
06:48:27 <Marvin--> the project is trying to find bugs in haskell programs Ã¡ la quickcheck, but with FOL theorem proving
06:48:28 <Smerdyakov> E is the distributed programming language?
06:48:42 <Marvin--> no, E, the FOL prover
06:48:56 <Smerdyakov> Uh oh. I _knew_ a one-character namespace wouldn't be big enough. ;)
06:49:03 <Marvin--> :-)
06:49:11 <Marvin--> Eprover then
06:50:43 <Darius> B, C, and D don't seem to have too many competitors.
06:51:02 <Darius> But E is the most common letter in the English alphabet.
06:52:14 <Igloo> I think someone would have to be quite barmy to call something else C
06:52:49 <Smerdyakov> Barmaids are barmy.
06:52:53 <Smerdyakov> Better watch out for them.
06:53:28 <Darius> Beerchan!
06:53:44 * SyntaxPolice calls barmaids 'B'
07:09:21 <Marvin--> yay, cool, now the proofs are quite readable
08:18:15 <Marvin--> time for some D&D
08:43:15 <emu> proofs, readable? that's not right
10:10:42 <basti_> hi
10:24:33 <shapr> hiya
10:25:17 <shapr> what's going on?
10:25:23 * shapr yawns
10:25:42 <basti_> not that much
10:25:45 <basti_> ;)
10:26:18 <shapr> written any cool code lately?
10:26:40 <basti_> i did a regexp parser and discovered that lazy eval is cool.
10:26:41 <basti_> ;)
10:26:57 <shapr> oh nifty, do you have the code online?
10:27:02 <basti_> uhm no
10:27:14 <basti_> its not that much anyway
10:27:26 <basti_> more of a finger exercise ;)
10:27:44 <basti_> it uses monadic calculation and has higher order functions
10:27:51 <basti_> like "star" and "plus"
10:28:32 <shapr> sounds interesting
10:29:52 <basti_> ill have a look how i get to my new homepage...
10:31:04 <shapr> man, I look pycnic in my ICFP photos.
10:31:38 <basti_> ICFP?
10:31:46 <shapr> international conference on functional programming
10:31:48 <basti_> international conference on functional programming?
10:31:49 <basti_> ic
10:31:50 <basti_> :)
10:32:00 <shapr> http://www.cse.unsw.edu.au/~sseefried/seafood/photos/people/people-Pages/Image8.html
10:32:02 <Igloo> pycnic?
10:32:11 <shapr> of course, standing next to Igloo, who is by no means pycnic...
10:32:25 <shapr> leptosome maybe :-)
10:32:33 <basti_> woah *g*
10:32:43 <Smerdyakov> What's "pycnic"?
10:32:50 <basti_> "fat"? ;)
10:32:59 <shapr> basti_: did you write this FARP proportions and muscles tutorial?
10:33:08 * Igloo dicts - ah, assuming you mean pyknic
10:33:12 <basti_> uhm. yes shapr :)
10:33:16 <shapr> basti_: it's cool
10:33:19 <basti_> thanks a lot :)
10:33:27 <basti_> did you google my name?
10:33:33 <shapr> yup :-)
10:33:37 <shapr> you've been google-stalked
10:34:10 <shapr> I wonder if blackdog_ weighs more than me...
10:35:31 <shapr> http://www.syntaxpolice.org/pics/londonSweden/small/ICFP/6.html
10:35:50 <shapr> I had fun at ICFP.
10:36:42 <shapr> basti_: are you studying in undergrad or postgrad?
10:36:58 <basti_> uhm depends what your "grad" means...
10:37:04 <basti_> I'm vordiplom
10:37:09 <basti_> thats a little more than a Bachelor
10:37:14 <shapr> ah, masters?
10:37:30 <shapr> I guess that's in the middle, graduate work.
10:37:39 <shapr> are you getting a vordiplom in functional programming?
10:37:47 <basti_> I think "masters programme" is what you'd call it in AngloSaxon language...
10:37:53 <basti_> uhm no.
10:38:00 <basti_> actually its a general qualification
10:38:08 <basti_> lots of math, lots of computer science
10:38:19 <shapr> ozone: why'd you change your nick?
10:38:46 <basti_> things like basics of compiling/parsing, complexity theory, mathematical basics (a lot), hardware practise, programming practise
10:38:54 <shapr> sounds like fun
10:39:05 <basti_> I became quite an FP fan after Vordiplom
10:39:25 <basti_> after being Presented with Lambda Calculus shortly after (why not before I ask...)
10:39:32 <shapr> heh
10:39:34 <shapr> good question
10:39:41 <shapr> I wish they'd at least introduce it in undergrad
10:39:59 * basti_ too
10:40:06 <basti_> well it wasnt to late obviously
10:40:19 <shapr> good point
10:40:27 <basti_> I always took programming with a grain of salt and stayed close to mathematics
10:40:38 <basti_> despite heavy practice in my teen years ;)
10:41:06 <shapr> I'm on the other end, I want useful code, but I'm slowly seeing the beauty of the theories.
10:41:23 <basti_> (BASIC. 6502 Assembler and Hardware. 386 Assembler. C. guess that wasnt enough to spoil me ;)
10:41:27 <basti_> *g*
10:41:34 <basti_> where do you come from, programming wise?
10:41:41 <basti_> i mean what languages?
10:42:03 <SyntaxPolice> shapr: I like that photo :)
10:42:04 <shapr> nearly the same, BASIC, i386 asm, (many years) Visual Basic, Java, Python, Haskell
10:42:09 <shapr> SyntaxPolice: which one?
10:42:15 <SyntaxPolice> the one you just posted.
10:42:19 <shapr> SyntaxPolice: the one you took of the three of us?
10:42:27 <SyntaxPolice> yeah
10:42:32 <basti_> i did java too later...
10:42:34 <shapr> I think Igloo always looks like a mysterious wizardly hacker to me.
10:42:53 <basti_> a great thing is that I am now fluent in LOTS of languages. I mean really LOTS. ;)
10:43:01 <basti_> yes thats what i thought too when I saw the pic
10:43:08 <shapr> I just look a bit too pyknic ;-)
10:43:35 <SyntaxPolice> shapr: definitely
10:43:39 <SyntaxPolice> I mean about igloo
10:43:42 * shapr laughs
10:43:44 <SyntaxPolice> I don't know what pyknic means :)
10:43:50 <shapr> it means fat :-)
10:43:51 <basti_> "fat"
10:43:51 <basti_> ;)
10:44:06 <basti_> thats a model artists and early physicans used
10:44:10 <SyntaxPolice> heh
10:44:14 <basti_> pycnic, leptosome, athletic and indifferent
10:44:25 <basti_> and dysmorphic i think
10:44:35 <shapr> I get to choose between athletic and pyknic, so lately I'm choosing more athletic.
10:44:44 <shapr> basti_: have you tried Joy?
10:44:46 * basti_ is definetly leptosome
10:44:47 <basti_> joy?
10:44:56 <shapr> the programming language.
10:44:58 <basti_> no.
10:45:11 <shapr> it's postfix, stack based, concatenative and purely functional
10:45:16 <shapr> it's like Haskell and Forth had a kid
10:45:26 <basti_> whoo.
10:45:29 <shapr> yah, it's cute
10:45:30 <basti_> now thats sounds crazy.
10:45:39 <shapr> I really enjoyed learning it.
10:45:43 <shapr> hey yazirian, ltns.
10:45:44 <shapr> wassup?
10:46:14 <yazirian> it just occurred to me that ArrayList is an affront to god, and my Java-writing life has suffered for it
10:46:27 <yazirian> save me from the typeless masses!
10:46:33 * shapr laughs
10:46:49 <shapr> doesn't array force you to cast to Object anyway?
10:46:53 <shapr> er, Array
10:46:55 <basti_> what is ArrayList? ;)
10:47:03 <yazirian> no, you declare arrays typed
10:47:12 <yazirian> String[] strs = new String[];
10:47:21 <yazirian> that's an array of strings and it will moan about anything else.
10:47:44 <yazirian> ArrayList on the other hand, is like the Ellis Island container. 
10:47:53 <yazirian> Take anything, and change its name to something pronounceable like 'Object'
10:47:57 <yazirian> "You're one of US now."
10:48:13 <yazirian> and you better remember what it was when it comes out the other side!
10:50:47 <yazirian> you can stick anything you want into an ArrayList, and it just casts it to Object and grins at you. And then next week when you want something out of it, you best remember that alist.get(3) is going to need to be cast to WhateverType... and you'd better catch ClassCastException in case you're wrong!
10:51:50 <yazirian> and, naturally, most people who work here would rather not think about types, so these things are -enormously- popular.
10:51:52 <shapr> yah, I remember that
10:52:06 <shapr> they're great when you want to write Python in Java
10:52:14 <shapr> as long as you don't mind explicitly casting stuff all the time
10:52:23 <shapr> that has led to the comment that Java is untyped.
10:52:27 <basti_> that sounds bad.
10:52:40 <yazirian> Python is more strongly typed than Java.
10:53:03 <shapr> I used lots of nested lists and dictionaries when I did lots of Python, but it didn't carry over well into Java.
10:53:23 <shapr> I remember putting three casts in a single line of code.
10:53:34 * shapr shivers
10:53:36 <yazirian> At least in Python, things keep their types; there is no casting, when you want a string to something, you call a method on it and get a NEW object off of it that happens to be a string.
10:53:41 <shapr> yup
10:53:56 <yazirian> In Java, it's like "Oh, parentheses? Hey, I'll give it a shot."
10:54:48 <yazirian> and due to the nature of downcasting back out of Object, that is -always- a runtime exception. The smartest compiler in the world will never see that one coming. 
10:54:52 <Darius> pssh, that's nothing the rts actually will check you.  Ah the joys of *(long *)&someFloat.
10:54:55 <yazirian> hip hip, hooray!
10:55:21 * shapr grins
10:56:27 <yazirian> the sad part is, that's not even what people really want
10:56:33 <yazirian> what they want is vectors
10:56:46 <yazirian> an array they don't have to know the size of beforehand
10:56:52 <yazirian> and so they use ArrayList instead
10:57:30 <Darius> How is ArrayList generally considered to be implemented (i.e. what is it?)
10:57:40 <yazirian> and in Java, there is a Vector class, but it has exactly the same typecasting behavior as ArrayList, and is slower (because it's synchronized)
10:57:55 <shapr> oh, that's the one I remember so well.
10:58:03 <shapr> well, maybe not, since you had to remind me
10:58:07 <yazirian> hehehe
10:58:25 <yazirian> ArrayList is, to quote the javadoc, "Resizable-array implementation of the List interface."
10:58:31 <shapr> I may have to take some Java contract work soon :-/
10:58:40 <yazirian> which is to say, it's Object[] where you don't have to know the size first.
10:58:45 <shapr> I'll have to read up on 1.5
10:58:49 <shapr> heck I'll have to read up on 1.4
10:58:55 <yazirian> heh
10:59:25 <yazirian> 1.5, wherein they add generics, because they're scared of C#, and tout that they'll save the world... nevermind the abomination they are in C++
10:59:34 <yazirian> As if Java didn't chew up enough memory already!
10:59:46 <Darius> The GotW guy believes deques should be the array-like datastructure C++'s programmers should reach for not vectors.
10:59:54 <shapr> seems to me Java started out simple and straightforward and grew fuzz
11:00:05 <yazirian> deques suffer from poor implementations in many standard C++ toolkits though
11:00:06 <Darius> Java started out too simple.
11:00:11 <shapr> or maybe that's just how my perception of it has changed over the years.
11:00:23 <basti_> stone knives and bear skins.
11:00:25 <shapr> GotW?
11:00:27 <yazirian> you can take a 4x performance hit just by choosing a different compiler, using deques
11:00:33 <shapr> Guy of the Week?
11:00:37 <shapr> would that be Peter Van Roy?
11:01:22 <shapr> I'm still not sure if PvR is way above me, or way below me when it comes to understanding programming.
11:01:35 <Darius> Guru of the Week (www.gotw.ca I think), definitely not Peter van Roy, I don't think PvR does anything with C++.
11:01:38 * yazirian is not familiar enough to comment.
11:02:59 <yazirian> I also think stack-ish collections are usually fast and can result in clean algorithms... but suffer maintainability problems because most application programmers don't think that way.
11:03:21 <shapr> that fits with my experience of most programmers.
11:03:33 <shapr> actually, most programmers are CowboyCoders at best.
11:03:36 <yazirian> in my experience at least, the 'average' app programmer thinks of collections like... you know those "day of the week" medication trays? 
11:03:52 <yazirian> you put your pills for each day in the little square for "Monday" or "Thursday" or whatever?
11:03:53 <shapr> heh, cute analogysic
11:03:57 <yazirian> that's how average app programmers think
11:04:13 <yazirian> that's the collection that lives in their head
11:04:59 <yazirian> that's why arrays and hashes are basically all you see
11:05:11 <shapr> so you think they should have other mental tools?
11:05:24 <phubuh> Speaking of collections in Java, it is ridiculous that there is no interface distinction between random-access containers and non-random-access containers
11:05:34 <yazirian> I think it never hurts to know more. But no, actually, I don't see much need to convince them otherwise, in most cases.
11:06:04 <yazirian> Usually, an array or a hash will do your job, and it won't kill your performance because they tend to be constant or near-constant time accesses.
11:06:07 <shapr> I think Java is just ridiculous.
11:06:23 <Darius> Imperative programming maps well to arrays.
11:06:31 <shapr> sadly, I think I'll get paid to write Java for the next several years. It's the COBOL of the future.
11:06:40 <basti_> lol
11:06:45 * yazirian nods. And the human mind maps well to imperative.
11:07:05 <yazirian> At least, how it's taught in gradeschool, anyway.
11:07:10 <shapr> yah, truly
11:07:31 <shapr> I wonder what computer programs would be like if functional had been the first paradigm
11:07:33 <phubuh> Imperative, probably.  OOP, definitely not.
11:08:04 <yazirian> Heh. There's barely a language left that DOESN'T have OOP somewhere.
11:08:35 <yazirian> shapr: two points
11:08:48 <shapr> does Haskell have any OOP bits?
11:08:52 <phubuh> I'm not against OOP, but pro-OOP people tend to claim that it's so intuitive and maps well to the human mind, which I definitely don't agree with.
11:08:59 <yazirian> one is, that's not how computers themselves work, so it's sort of "if functional had been the -second-"
11:09:02 * basti_ detects that his monadic parser needs revision
11:09:16 <yazirian> two is, functional is still a hell of a lot older than OOP
11:09:21 <shrimpx> blame the turing machine for the imperativeness that's plaguing the world :)
11:09:49 <yazirian> I'd say functional is as old as imperative; it's just that all the math people were talking functional and the engineers, who were describing the CPU they had built, weren't
11:09:52 <shapr> hej Pinnen, vad händer?
11:10:09 <Darius> shrimpx: Yah!  I mean isn't bloody obvious how to implement the lambda calculus mechanically.
11:10:11 <Pinnen> shapr: inte mycket, kolalr runt på nätet bara :-)
11:10:14 <Pinnen> kollar*
11:10:21 <shrimpx> Darius: :)
11:10:41 <shapr> Darius: is it?
11:10:43 * shapr thinks
11:10:51 <shapr> lambda lego =)
11:11:03 <shrimpx> a lambda cpu would rule
11:11:13 <shapr> LispM?
11:11:14 <shrimpx> wait, it's been done
11:11:17 <shrimpx> ya :)
11:11:19 <shapr> Pinnen: are you learning Haskell?
11:11:26 <yazirian> heh, and we saw how far that got
11:11:37 <shapr> I don't know anything about the internals of the LispM
11:12:05 <shapr> I *do* know that a government agency is interested in Haskell that runs on bare metal hardware for end-to-end verification purposes.
11:12:09 <Pinnen> shapr: heh, nahh... don't even know what the heck it is :-)
11:12:11 <Darius> Lisp was and is a far cry from the lambda calculus.
11:12:21 <shapr> Pinnen: well, this is a great chance to learn.
11:12:32 <yazirian> Personally I think the lambda is overhyped anyway.
11:12:40 <yazirian> I have tried to care about it.
11:12:44 <yazirian> But I have had to accept that I failed.
11:12:48 <Pinnen> shapr: ok.
11:12:50 <shapr> Pinnen: are you a programmer?
11:13:01 <shrimpx> who isn't
11:13:18 <Pinnen> shapr: nej, programmerar bara lite
11:13:35 <shapr> tyvarr
11:13:45 <shapr> Haskell är en jattekul programmerings språk
11:13:56 <shapr> and feel free to correct my swedish mistakes :-)
11:14:25 <Pinnen> heh, ok.. ja, man kanske provar på det nån gång då, när man lärt sig lite mer
11:14:26 <phubuh> That's supposed to be -ett- jättekul. Completely arbitrary and useless distinctions, you gotta love 'em.
11:14:27 <shapr> I'm a newbie with swedish.
11:14:32 <shapr> phubuh: tack :-)
11:15:14 <Pinnen> ohh, i see :-)
11:15:23 <shapr> Pinnen: ja, det är bra, om du vill lära sig mer, fråga mig.
11:15:35 <basti_> ICH KANN AUCH NE FREMDSPRACHE IHR! ;)
11:15:41 <shapr> ICH HABBE KEINE AHNUNG!
11:15:48 <basti_> ;)
11:15:52 * shapr grins
11:15:55 <Pinnen> shapr: hehe, ska komma ihåg det
11:16:03 <shapr> cool
11:16:07 <phubuh> Oh, and very fun -> jättekul, so programming language -> programmeringsspråk, not programmerings språk.  Incorrectly separating words like that is called 'särskrivning', and will probably be correct swedish in a couple of years or so. :-)
11:16:07 <basti_> °a < i cant even make that character.
11:16:15 <phubuh> ååå!
11:16:19 <shapr> speaking of which, I should go work on my swedish homework.
11:16:21 <yazirian> boy, this is really showing the limitations of my terminal program :-)
11:16:44 <shapr> it's a° Centigrade
11:16:47 <ibid> here we call that the disease of lappeen Ranta (though this joke will be lost on most of you)
11:17:06 <shapr> isn't that like saying it's redneck disease?
11:17:10 <vegai> hmm, we do?
11:17:21 <ibid> vegai: you mean you don't? :)
11:17:29 <Dark-Star> basti_: å is <Alt>-134 ;-)
11:17:47 <basti_> å
11:17:48 <basti_> wow
11:17:50 <shapr> Dark-Star: doesn't work for me.. emacs doesn't like that.
11:18:12 <ibid> shapr: no, i think it's just because someone from Lappenranta mistyped it lappeen Ranta years ago on sfnet
11:18:18 <vegai> ibid: ok, I've seen "lappeen Ranta", but the disease part was new ;P
11:18:18 <shapr> oh!
11:18:22 <Dark-Star> shapr: it's a windows-thingy ;-)
11:18:37 <shapr> Dark-Star: ohhh, one of those things.
11:18:45 <shapr> wow, we nearly have 70 today
11:18:55 <shapr> just two more people ;-)
11:19:48 <yazirian> So I'm reading this gotw.ca site... and I spot this:
11:20:00 <shapr> well, I'm off to read a famous swedish novel condensed into small child language for furreners.
11:20:02 <yazirian> "Herb is convener (chair) of the ISO C++ standards committee, [...] Visual C++ architect for Microsoft"
11:20:10 <yazirian> I'm scared. Hold me.
11:20:17 * shapr snickers
11:20:27 <ibid> yazirian: many haskell people are employed by MSR
11:21:01 <yazirian> so I've noticed, but I don't hear of companies actually selling products to make Haskell more compatible with its own standard ;-)
11:21:12 <yazirian> they do that, for Visual C++ 
11:23:01 <Dark-Star> isn't there a "Haskell .NET"? I think I've read about it somewhere...
11:23:20 <Darius> There's a F# and SML.NET and Mondrian.
11:23:46 <Dark-Star> or was that Scheme .NET? I'm not sure ...
11:24:15 <Kr1st1na> can someone help me, i've got to make a function which takes a list and returns a string like ["ab", "bc", "cd"] returns "abcd" and ["a", "b"] returns "ab" and if wrongly input like ["ab", "cd"] returns an empty list, i can make it a string but dunno how to return an empty list if it is wrongly input
11:30:43 * shapr notes the sudden silence
11:31:10 <shapr> Kr1st1na: have you used if then else ?
11:31:16 <phubuh> It's the land of DONNY AND MARIE as promised in TV GUIDE!
11:31:21 * yazirian notes having no idea :-)
11:31:29 <shapr> @yow
11:31:29 <lambdabot> If a person is FAMOUS in this country, they have to go on the ROAD
11:31:29 <lambdabot>  for MONTHS at a time and have their name misspelled on the SIDE
11:31:29 <lambdabot>  of a GREYHOUND SCENICRUISER!!
11:31:34 * Dark-Star thinks about what that function should actually do...
11:32:34 <yazirian> that should be your 70 shapr 
11:32:48 <Dark-Star> ["ab", "bc", "cd"] -> "abcd" seems like it should just "overlap" the strings, but that wouldn't work for ["a", "b"] -> "ab"...
11:33:37 <phubuh> ["ab", "bc", "cd"] = "abcd" | ["a", "b"] = "ab" | _ = "" :-)
11:33:50 <yazirian> hahaha
11:38:39 <Kr1st1na> it needs to work for any length so like ["abcd", "bcde", "cdef"] returns abcdef
11:39:09 <basti_> "ab" still doesnt fit imop
11:39:10 <basti_> imo
11:39:21 <Igloo> What should f ["abbbbb", "bbbc"] be?
11:39:37 <Kr1st1na> that should return [] cos its not in the right format
11:39:53 <basti_> what IS the right format?
11:41:13 <Kr1st1na> well each element has same length, ["abc", "bcd"] is right format where as ["ab", "cd"] isnt
11:41:23 <keverets> wouldn't that be "abbbbbc"?
11:41:39 <Igloo> What should f ["abbbbb", "bbbccc"] be then?
11:41:45 <Kr1st1na> i know "ab" should be the wrong format but well its supposed to work
11:42:00 <keverets> at a guess: abbbbbccc
11:42:58 * Igloo is somewhat lost as to who actually wanted this in the first place
11:43:00 <Kr1st1na> the beginnin of the next element has to follow on from the first element of the previous element
11:43:25 <keverets> 14:24 < Kr1st1na> can someone help me, i've got to make a function which...
11:43:30 <Igloo> Ta
11:43:35 <keverets> (in EST)
11:44:08 <basti_> Kr1st1na: so ["abbb","bbbc"] -> "abbbc"?
11:44:21 <Kr1st1na> no basti that should return an empty list
11:44:27 <mattam> @type fix
11:44:31 <Kr1st1na> the letters have to follow in the alphabet
11:44:43 <Igloo> Oh, right
11:45:13 <basti_> ah.
11:45:21 <keverets> Kr1st1na: are you sure about those requirements?
11:45:23 <basti_> you didnt mention that i think.
11:45:32 <Kr1st1na> sorry its hard to explain
11:45:48 <Kr1st1na> yes keverets
11:46:06 <keverets> What's the purpose of the function, then?
11:47:02 <Kr1st1na> well our first task was too make a function where if you input function 3 "abcdef" you would get ["abc", "bcd", "cde", "def"]
11:47:30 <Kr1st1na> now we have to do the inverse so if we put function["abc", "bcd", "cde"] it would give "abcde"
11:47:51 <Kr1st1na> and "" if the format was wrong
11:48:03 <Kr1st1na> sorry i said [] before that was wrong
11:48:51 <Kr1st1na> i just cant figure out how to give "" if format is wrong
11:49:44 <mattam> hmmm, how come this is correct:
11:49:50 <mattam> fix a = let fixa = a fixa
11:49:55 <mattam>        in fixa
11:50:04 <Kr1st1na> i think the lengths of each element are supposed to be entered the same so all length 1 or 2 etc but supposed to return "" if letters are incorrect
11:50:35 <Darius> mattam: Why would it be wrong?
11:51:03 <mattam> well, it's wrong in Caml :)
11:51:17 <Darius> It's wrong in C too.
11:52:12 <mattam> so how does it work ?
11:52:31 <mattam> it is automatically infered that fix has type '(a -> a) -> a'
11:53:20 <mattam> this means a has type a -> a and fixa has type a right ?
11:53:27 <Darius> Yes
11:53:53 <Darius> @eval take 10 $ fix (\x.1:x)
11:53:54 <lambdabot> [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
11:54:12 <Kr1st1na> does anyone have any ideas on my problem?
11:54:20 <mattam> so it's the application of a to fixa which is ?
11:54:27 <Darius> @type let fix f = f (fix f) in fix (1:)
11:54:28 <lambdabot> let {fix (f $0 (0 (f (fix f))) $0) $0 $0} in fix (1 :) :: Num a => [a]
11:54:45 <Darius> fixa
11:55:32 <mattam> this recursion drives me crazy... 
11:55:37 <basti_> fix infix?
11:55:52 <Jad> how to know the variables of the arguments of an application run
11:55:59 <Jad> ?
11:56:15 <Darius> Jad: ... what?
11:56:31 <Jad> for example ./app Jad123
11:56:32 <mattam> Darius: it's a infinite recursion right ?
11:56:35 <Jad> how can i know the arguments ?
11:56:51 <Darius> mattam: Not necessarily.
11:56:51 <Jad> in this case Jad123
11:57:10 <Darius> see getArgs (in module System I think)
11:57:12 <mattam> Darius: without using lazy eval i do not see
11:57:24 <Darius> Well, yes it does require laziness.
11:57:44 <Darius> Jad: e.g. main = getArgs >>= putStrLn
11:57:49 <mattam> that's certainly why i'm not allowed to write that in ML 
11:57:54 <mattam> Caml even
11:57:56 <Jad> ya
11:58:01 <Jad> thats how to use it ?
11:58:08 <Jad> functoin getArgs ?
11:58:32 <phubuh> getArgs is an I/O action that gives you a list containing the command-line arguments
11:58:34 <Darius> You can use do notation (which is usually cleaner) e.g. main = do args <- getArgs; putStrLn args
11:58:51 <Jad> okay
11:58:51 <Jad> tnx alot
11:59:00 <Darius> mattam: eta expanding will give you a fix that works with CbV
11:59:20 <shapr> oh wow, 70!
11:59:33 <shapr> w00, 72!
11:59:33 <Igloo> Any (La)TeX gurus about?
11:59:43 <phubuh> Igloo: Try me :-)
11:59:49 <mattam> i do not remember the eta  one...
12:00:12 <ibid> Igloo: not a guru, but what do you need?:)
12:00:16 <Igloo> OK, I have a tall \left\{ ... \right\}. I want this so that the top of it is aligned with the top of the letters in the line.
12:00:23 <ibid> ugh
12:00:34 <ibid> beats me
12:00:52 * shapr dances cheerfully
12:00:53 <phubuh> Me too.  I'm not a guru, though. :-)
12:00:55 <Darius> f = \x -> f x
12:00:59 <shapr> high water mark for #haskell is 72 clients
12:01:01 <mattam> oh yeah
12:01:14 <Igloo> Thanks anyway, guys
12:01:23 * shapr writes a note on lambdabot 
12:03:06 --- topic: set to '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","lots of cool debs in the haskell-experimental archive - see http://haskell.org/hawiki/DebianUsers","new monads tutorial http://www.nomaware.com/monads/html/","Any user who would like to request any unwritten tutorial please msg shapr", "peakUsers = 72"]' by Jad
12:03:09 <shapr> heh
12:03:40 <shapr> we do have a surprising number of people who actually talk and say things with real on-topic content here.
12:03:45 <shapr> it's shocking!
12:04:01 <Kr1st1na> basti : any ideas on my problem?
12:04:10 <shapr> hi sophist 
12:04:19 <basti_> Kr1st1na sorry im not fully understanding the requirements.
12:04:37 <Jad> shapr: are you good in english ?
12:04:59 <shapr> Jad: I think so.
12:05:10 * Darius would hope so.
12:05:26 <shapr> I'm a native (American) English speaker, and my mother taught American English in school.
12:05:29 <Kr1st1na> well i got to return a string from a list so like ["abc", "bcd", "cde"] returns "abcde" and if format is wrong so like ["def", "bcd", "edf"] is input then you get ""
12:05:37 <Jad> can i email you my essay and tell me what you think ?
12:05:42 <shapr> sure
12:05:49 <shapr> I warn you, I've been told I'm a harsh editor.
12:06:48 <Jad> k
12:06:53 <Jad> msg me your email please
12:07:02 <basti_> Kr1st1na what exactly is "wrong" and "right"? please be exact. I suppose, all strings shall be equally long is one requirement.
12:07:41 <shapr> yay, just got my 10,000th piece of spam.
12:08:33 <yazirian> hooray!
12:08:41 <yazirian> enough to train a bayesian filter!
12:08:42 <Kr1st1na> okay if the first element is say abc, then the next must continue the pattern so must go bcd, then cde, so must follow from first letter in previous element and continue in alphabet, so if first is abcde, next must be bcdef
12:09:09 <shapr> yazirian: truly
12:09:21 <Kr1st1na> if say first is bcd, and next is def its wrong, or if first is def, next is abc its wrong
12:09:55 <Kr1st1na> the next element must continue from first letter in previous element and must continue on with the alphabet
12:14:35 <Dark-Star> Kr1st1na: are you sure about that the character must be in alphabetical order? because if it's the inverse function to the one you described (f 3 "abcdef"), then something like this should also work:
12:14:54 <Dark-Star> f 3 "foobar" -> ["foo", "oob", "oba", "bar"]  so ["foo", "oob" "oba" "bar"] -> "foobar"
12:15:32 <Kr1st1na> can i give the website with the question paper so you can see the question and the examples given?
12:15:44 <shapr> uh oh, this sounds like homework...
12:15:48 <Dark-Star> so you have n strings of length k, which must match on their last (k-1) letters. then the result is the first letter of each string
12:15:59 <keverets> it's most definitely homework.
12:16:14 <Kr1st1na> yes its coursework and im stuck 
12:16:50 <shapr> well, as long as everyone is being ethical about it :-)
12:17:07 <Kr1st1na> yes the result if the first letter of each string but must contain the whole of the last string
12:17:20 * SyntaxPolice does shapr's homework
12:17:24 <Kr1st1na> but if its not alphabetical then its wrong
12:17:43 <Jad> shapr: email sent
12:17:43 <Jad> you might receive multiple copies am sorry, very bad connection :S
12:17:53 <shapr> Jad:  no worries
12:18:00 <shapr> SyntaxPolice: yes! I'll pay you money to do my homework!
12:18:01 <Dark-Star> Kr1st1na: Try what I described. match the substrings i and (i+1) on their last / first (k-1) characters (if k is the lengts of each string). if they match then it's the correct format and you have to output the first letter of each substring
12:18:17 <shapr> SyntaxPolice: would you happen to know anything about swedish substaniv forms?
12:18:22 <shapr> er substantiv
12:18:53 <Kr1st1na> but will that determine whether it is alphabetical
12:19:23 <SyntaxPolice> shapr: yes. I wrote a perfect parsec grammar for that recently, but I lost it.
12:19:35 <shapr> SyntaxPolice: dang
12:19:36 <Dark-Star> I think it needn't be alphabetical because the function you described earlier (f 3 "abcdef") should work for other (non-alphabetical) strings too
12:19:41 <shapr> SyntaxPolice: what would I have to bribe you with to find it?
12:19:48 <shapr> I could send you a reindeer.
12:19:55 <phubuh> I bet I know about substantiv forms, but I don't know what it is :-(
12:19:59 <SyntaxPolice> your unicycle, a reindeer, and you have to visit Ohio :)
12:20:07 <shapr> nooo, not the unicycle!
12:20:12 <Dark-Star> Kr1st1na: f 3 "foobar" --> ["foo", "oob", "oba", "bar"]
12:20:16 <shapr> it's my dearest possession!
12:20:29 <Kr1st1na> well cos of the examples has f["efg", "def","cde", "bcd"] which returns "" cos its not right
12:20:41 <SyntaxPolice> shapr: well, that's the price :)
12:20:47 <shapr> the horror!
12:21:01 <shapr> bah, I'll have to do my homework by myself.
12:21:02 <keverets> but that could be because there's no overlap.
12:21:22 <SyntaxPolice> shapr: ah well. nice doing business w/ ya ;)
12:21:31 <shapr> phubuh: I can actually do my homework by myself, it's just whether to use ett brev or brevet, that sort of thing.
12:21:35 <Kr1st1na> it has to be alphabetical just doesnt have to start from a
12:21:42 <phubuh> Ah.
12:21:56 <Dark-Star> Kr1st1na: that example you just described (f ["efg", "def", "cde", "bcd"]) doesn't work because the strings do not match (remember: they must match on 2 letters, so the first 2 letters of the second string must be the same as the last 2 letters of the first string)
12:23:28 <Dark-Star> that's because the list ["efg", "def", "cde", "bcd"] cannot be the result of the function f you described earlier (try to find a string for which 'f 3 <string>' gives exactly that list)
12:24:22 <Jad> --- Ping reply from Jad : 73.98 second(s)
12:24:40 <Kr1st1na> so i need to recursively compare the last k-1 elements with the following first k-1 elements?
12:25:08 <Dark-Star> yes. if they match then the strings are "correct", otherwise they can't be the result of the function f
12:25:25 <Kr1st1na> well i thought of that, but had problems writin it
12:25:39 <Dark-Star> Kr1st1na: that should be enough of a hint to help you solve it. Remember: we're not here to do your homework ;-)
12:26:17 <Kr1st1na> i know that, but i have thought of that, just been havin trouble thinkin how to actually do it
12:27:18 <Dark-Star> yeah, I think it's not easy. you can always try a 2-step method. Step 1: check the list and see if, for each string, the last (k-1) chars match the first (k-1) chars of the following string. if this fails somewhere then you return ""...
12:27:36 <Dark-Star> ...otherwise you just take the first char of every string and make a string from them
12:27:57 <Kr1st1na> but i need the whole of the last element
12:28:04 <Kr1st1na> not just the first char
12:28:23 <Dark-Star> yeah, but that's not too hard to implement, just break off your recursion one element earlier
12:29:59 <Kr1st1na> its the comparing the last elements with the first elements of the next string thats troubling me
12:31:07 <Dark-Star> you can write a helper-function for that. remember that a string is just a list of chars.
12:31:51 <Dark-Star> try to write this function first.
12:31:55 <phubuh> http://arstechnica.infopop.net/OpenTopic/page?a=tpc&s=50009562&f=6330927813&m=5650909395&r=6590990495#6590990495 :-)
12:43:12 <shapr> phubuh: cute url, I totally agree with Simeon and Wadler
12:44:26 <shapr> I've been thinking about self-describing file formats
12:44:42 <yazirian> XML!!!!!!!!!!!
12:44:50 <shapr> and about code that would 'automatically' figure out file formats
12:44:57 <yazirian> haven't you read every single damn magazine published since 1997?!?
12:45:02 <yazirian> you maniac!
12:45:02 <phubuh> Yeah, so do I.  newton_meter is a really cool guy, actually.  He's familiar with Haskell, too -- he should be here! :-)
12:45:04 <shapr> yazirian: have you read that url that phubuh pasted?
12:45:15 <yazirian> I haven't. It scared me. 
12:45:25 <phubuh> At least look at my post at the bottom :D
12:46:07 <shapr> phubuh: so, I have a trivia question for you, if you wanted to design a bitstream to have the format automatically figured out, possibly decades from now, possibly by an alien intelligence, how would you do it?
12:46:28 <shapr> or, how would you write file formats so that file format discovering code could easily unravel them?
12:46:41 <yazirian> pizza!
12:47:01 <phubuh> shapr: Hofstadter discusses that a bit in Gödel, Escher, Bach, IIRC.  I don't remember what he actually says about it, though.
12:47:23 <vegai> hmm
12:55:42 <elmex> its about DNA in GEB
12:56:15 <elmex> DNA describes it's own format somehow... (the biggest problem is the bootstrapping ;-)))))
12:57:13 <yazirian> bootstrapping DNA is -fun- though! ;-)
12:57:27 <Riastradh> Luckily, that problem was solved and never need to be solved since three billion years ago
12:57:43 <elmex> Riastradh: ;)
12:58:02 <Riastradh> Or at least it was solved to itself.
12:58:05 <elmex> but that kind of bootstrapping for fileformats would be quite cool
13:00:27 <shapr> elmex: yah, so how could it be done?
13:00:40 <elmex> simple
13:00:42 <shapr> ok
13:00:59 <shapr> I wanna know :-)
13:01:01 <mattam> there need to be some protocol, no matter how simple it is
13:01:27 <shapr> mattam: prime numbers?
13:01:29 <elmex> the only way to describe a fileformat is to describe the way it should be de- and en-coded... and thats done in procedural-form of data... 
13:01:37 <mattam> actually binary can be regarded as a structure i think
13:01:43 <elmex> or am i wrong?
13:02:04 <mattam> i think we agree elmex 
13:02:13 <shapr> elmex: does a C struct refer to codec info?
13:02:19 <elmex> ?
13:02:24 <elmex> shapr: no
13:02:57 <shapr> I still don't have a good answer to this question, just some ideas.
13:03:37 <shapr> currently, I think I'd try to find an encoding that's based on the fibonacci sequence
13:04:04 <shapr> but maybe a stream with fields is easier to figure out?
13:04:12 <mattam> shapr: is your question 'how can it be done without having the endpoints know about the format description format' ?
13:04:24 <shapr> mattam: right
13:06:35 <mattam> duh!
13:06:35 <shapr> for both the format and the format reader
13:06:35 <elmex> shapr: send a program along with the data
13:06:35 <mattam> elmex: how to interpret the program then...
13:06:35 <shapr> elmex: if an alien lifeform receives a binary string of bits, how will they know it's a program?
13:06:35 <elmex> shapr: no way ?
13:06:35 <shapr> elmex: I think there's a way.
13:06:35 <shapr> I just haven't figured it out yet :-)
13:06:35 <Dark-Star> didn't they come up with something like that for the voyager spacecrafts? A self-describing code or something?
13:06:35 <elmex> shapr: you need something like a atom- or subatomic assembler ;) something on the lowestlevel
13:06:49 <elmex> Dark-Star: not really... only nice pictures and some numbers
13:07:45 <elmex> shapr: without enzymes the DNA would have no meaning
13:07:45 <mattam> shapr: if you assume nothing about the alien lifeform then you could as well send junk :)
13:07:45 <elmex> shapr: you have to assume some things...
13:09:43 <mattam> there would be a misunderstanding (given the alien 'recognize' something in your junk) and then it is the first information. Send the same junk after getting a response and it means 0 (for you). Send something else and it means 1. You've got to have a differential coding, and wait for responses before resending.
13:10:19 <elmex> the cool thing... DNA doesn't only describe the encoding or decoding... it even describes copying, and other effects... 
13:10:42 <mattam> that way maybe you could have communication...
13:11:29 <mattam> my protocol assumes the alien have the concept of equality though
13:13:14 <vegai> bah, that's not a problem. Every alien looks like a human and speaks English
13:13:17 <mattam> i guess my 3 lines are not understandable by human lifeforms :)
13:13:35 <elmex> vegai: lol
13:13:47 <shapr> :-)
13:13:49 <mattam> vegai: maybe vega ones but not all 
13:14:26 <shapr> Hofstadter says that the medium is as important to the meaning of a message as the content itself.
13:14:34 <elmex> shapr: of course
13:14:40 <shapr> as elmex said, DNA has no meaning without enzymes.
13:14:47 <elmex> indeed
13:15:06 <Darius> mattam: a,.csdaos#$%
13:15:11 * shapr grins
13:15:52 <mattam> Darius: guess i'm not alone
13:15:55 <shapr> Dark-Star: I don't know, that's a good question.
13:16:05 <Darius> mattam: 490auhst
13:17:31 <mattam> Darius: 0
13:18:08 <elmex> 2 3 5 7 11 16
13:18:53 * shapr is highly entertained
13:18:59 <Darius> mattam: 490auhst
13:19:29 <phubuh> YAY, PIZZA!!!
13:19:53 <shapr> now I'm hungry.
13:19:57 <phubuh> :-)
13:20:50 <pesco> Hm, Pizza, nice idea...
13:23:12 <shapr> elmex: 2 3 5 7 11 16 22 ?
13:24:22 <elmex> shapr: 2 4 5 7 11 16 17 !
13:24:38 <elmex> s/4/3/
13:24:45 <shapr> hmm
13:26:23 <andersca> hey polli
13:26:28 <shapr> hej polli 
13:26:29 <polli> hej andersca 
13:26:34 <polli> och shapr 
13:26:37 <shapr> wazzup?
13:27:01 <polli> not much, tried to help a friend with a harddrive with some errors
13:35:32 * SyntaxPolice learns junit
13:35:41 <shapr> yay, sort of
13:36:19 * Darius wonders, I don't think managers aren't included in the bus number does that mean if all managers got hit by a bus a project wouldn't be seriously set back.
13:36:41 <shapr> Darius: in my experience, projects would take a huge leap forward
13:36:56 <shapr> managers count in the negative on bus numbers.
13:37:07 <shapr> er wait, you said the same thing
13:37:09 * shapr is getting sleep
13:37:11 <shapr> y
13:37:12 <shapr> argh
13:39:02 * Darius thinks he'll start the process of going to sleep. It's coming to the time he woke up yesterday.
13:57:25 * Marvin-- is back
13:58:33 <shapr> hej Marvin-- 
14:00:06 <Marvin--> that was the shortest damn session I've ever been to
14:00:21 <shapr> why? what happened?
14:01:10 <Marvin--> eh, one person was missing since he's away, and two wanted to leave early, so that left just half the group after that, kinda pointless to continue
14:01:14 <Marvin--> so a three hour session
14:01:15 <Marvin--> *sigh*
14:01:28 <Marvin--> oh well, I got to find out more about my majjickal sword
14:01:36 <shapr> dat's handy
14:01:49 <Marvin--> well, I'm *guessing* it could've been the sword
14:01:57 <Marvin--> I heard a voice in my head
14:02:05 <shapr> you could be having too much stress ;-)
14:02:08 <Marvin--> so it's probably one of those damn intelligent swords
14:02:15 <shapr> oh those
14:02:20 <shapr> they're usually a pain in the ass
14:02:23 <Marvin--> oh, I'm talking player knowledge here, not character knowledge
14:02:28 <Marvin--> my character is just generally confused
14:02:52 <shapr> always fun
14:03:04 <Marvin--> but yay, the cards I traded with a Polish guy arrived :)
14:03:09 <shapr> yay
14:03:40 <shapr> I discovered the latest sarge kernel-image is b0rked
14:03:59 <Marvin--> dang
14:04:07 <shapr> won't work for me at least
14:08:54 <shapr> g'day clausen 
14:09:14 <clausen> gday
14:09:24 <shapr> what's up?
14:09:37 <clausen> exam preparation, writing thesis, etc.
14:10:07 <shapr> enjoying it?
14:11:15 <phubuh> zoing
14:11:18 <shapr> boing
14:12:21 <Marvin--> there was a funny analysis of the matrix movies in today's metro
14:13:15 <Marvin--> they claimed that the first movie was 57% action, the second movie was 51% "new age mumbo jumbo" and that the third movie will be 51% special effects
14:13:48 <phubuh> works for me!
14:13:53 <phubuh> as long as they cut the mumbo jumbo.
14:13:57 <Riastradh> At least the first one had more than 0% plot.
14:14:30 <clausen> shapr: I'd rather focus on my research
14:14:30 <Marvin--> http://www.metro.se/content/acrobat/gothenburg/SEGOT_20031104_A_Metro.pdf page 14 (it's in Swedish)
14:14:37 <phubuh> if I wanted plot, I'd ... actually, I don't want plot.
14:14:50 <Marvin--> they've split up the 100% on action, special effects, love and new age mumbo jumbo
14:15:46 <Riastradh> phubuh, it's nice to have _some_ plot for these sorts of movies.  (if the movie is _centred_ on silly action, like Jackie Chan movies such as _The Legend of Drunken Master_, then it's a waste of time; but _The Matrix_ is definitely not centred on the silly martial arts action)
14:16:48 <phubuh> yeah, true -- but special effects and fighting is still a large part of it
14:17:00 <phubuh> `it' being the Matrix series
14:17:28 <Riastradh> It may be a large part of it, but taking out an even semi-halfway-decent plot for the second one really screwed it up.
14:18:31 <shapr> I luv Jackie Chan
14:18:44 <phubuh> yeah.  I wouldn't mind so much if the fighting and effects were really great, but even those were pretty mediocre in Reloaded.
14:19:06 <shapr> I like his physical action comedy.
14:19:19 <Riastradh> The gigantic Agent Smith and Neo fight scene was a _complete_ waste of fourteen minutes...
14:19:55 <shapr> dang, I liked it.
14:20:01 <shapr> pretty colors :-)
14:20:25 <Marvin--> Riastradh: it was fun at first, but then it was just silly
14:20:31 <Marvin--> Agent Smith is cool
14:20:37 <shapr> yah, I think there was less plot in the second movie.
14:20:39 <Riastradh> If it were perhaps _three_ minutes long it would have been nice.
14:20:41 <phubuh> at the end of that scene, I think everyone in the theater were annoyed that he didn't just zoom away to begin with
14:20:43 <Marvin--> "me too!"
14:20:45 <Riastradh> s/would/might/1
14:20:54 <Marvin--> Riastradh: yeah
15:38:23 <shapr> is there some way to force LILO to give you a prompt even if you didn't set a delay= ?
15:39:17 <shapr> oh yeah, hold down left shift
15:39:28 <shapr> whew
15:44:40 <ozone> shapr: this is my usual nickname, except i set it as o3 once in my .irssi file, and couldn't be bothered changing it back.  now i'm ircing from my work machine
15:45:41 <shapr> oh I See
15:51:42 <shapr> man this 2.4 GHz machine feels slow
15:51:52 <shapr> er, 1.4 GHz
15:52:03 <Smerdyakov> 2.4 GHz would feel slow, too.
15:52:33 <shapr> yup, when I'm used to a dualie with 3.0
15:53:19 <shapr> dual CPU feels more responsive than a single, I wonder if that's because of various support hardware
16:01:05 <dark> shapr: Might be that you usually have a single big process taking up slices.
16:01:13 <dark> ghc, for example :)
16:02:23 <phubuh> Or Emacs :-)
16:02:28 <phubuh> Night.
16:02:49 <dark> emacs doesn't take much, unless you do silly things like wave a mouse at it.
16:03:52 <shapr> I don't use a mouse with emacs, but I do nearly everything else with it.
16:04:10 <shapr> I would really like to have an emacs clone in Haskell
16:04:13 <shapr> even a crappy one
16:04:58 <dark> Writing a crappy one is pretty easy.
16:05:14 <dark> Did one as a student project once :)  Not in Haskell, though.
16:06:11 <ozone> dark: what scripting language did you use?
16:06:15 <ozone> (out of curiosity)
16:06:25 <dark> ozone: None... it was crappy :)
16:06:39 <ozone> hehe, so it was an editor then
16:06:48 <ozone> i was thinking 'emacs clone, must at least have a scripting language ...'
16:06:58 <dark> Well it had the same key bindings, same idea of buffers & files, and the same kill ring stuff.
16:07:42 <dark> ozone: I think the scripting language was a new feature of GNU emacs when it came out :)  Previous emacsen didn't have that.
16:08:10 <shapr> so, if you were to write one in Haskell now, how would you approach it?
16:08:15 <dark> shapr: Would you want one with an elisp interpreter, or a haskellish language instead?
16:08:23 <shapr> haskellish
16:08:44 <dark> Then I might try to build it on top of ghci :)
16:08:48 <shapr> hm
16:13:21 * esap has a question. What natural number is represented by fix (In . Just)? [which has type Rec Maybe = Nat]
16:13:42 * shapr doesn't have an answer
16:13:54 <isomer> shapr: so...in the end it looks like I can make a partial evaluation compiler for smalltalk. so i'm going to give it the old college try
16:14:48 <shapr> isomer: spiffy
16:19:41 <isomer> :) i'll let you know how it goes. i think this is turning into a cool little side project
16:21:08 <shapr> partial evaluation sounds cool
16:23:32 <blackdog_> shapr: dumb question - how do i set a variable in elisp?
16:23:52 <isomer> (setq var value)?
16:23:57 <blackdog_> cheers
16:24:05 <shapr> beat me to it
16:24:15 <shapr> hey mrak, how much do you weigh? (if you don't mind me askin)
16:25:24 <blackdog_> hold on, i'll go check.
16:25:35 <shapr> heh :-)
16:27:32 <blackdog_> man, i'm fading away... only 109 kg. they'll never let me play front row for australia at this rate.
16:27:32 * shapr grins
16:27:32 <shapr> I'm still six under, only 103
16:27:51 <ozone> sup mkar
16:27:57 <shapr> blackdog_: so, you trying emacs again with the spiffy hardware?
16:27:58 <blackdog_> it's a bit odd, actually. the only time i lose weight is when i'm doing no exercise.
16:27:58 <ozone> cool, i just gave you a new nickname
16:28:18 <blackdog_> he can be shapr, i'll be makr. :)
16:28:46 * shapr laughs
16:28:53 <shapr> that's a spiffy connection
16:28:58 <blackdog_> shapr: yep. just trying to ge tused to it now. Is there an organiser program or something?
16:29:21 <shapr> there's BBDB for a rolodex
16:29:24 <ozone> hmm
16:29:32 <ozone> let's go compile ghc on this machine
16:29:32 <shapr> and gnus for email, news, etc
16:29:37 <ozone> and see if it takes, like, 30 minutes or something
16:29:55 <shapr> I'll be impressed if it does.
16:30:02 <shapr> it takes hours on my dual 1.5GHz
16:30:09 <ozone> i'll be impressed if it takes less than about 5 hours :)
16:30:18 <ozone> does ghc's build system support make -j2?
16:30:24 <shapr> not really
16:30:30 <ozone> eh, let's find out
16:30:38 <shapr> as in, every once in awhile I file the next -j2 Makefile bug
16:30:43 <shapr> and then one of the Simons fixes it.
16:30:46 <blackdog_> hm. i was thinking more of a day planner kind of thing. let me know when i'm meant to be places, that sort of thing.
16:30:56 <shapr> blackdog_: there is, but it only works in gnu emacs
16:31:11 <shapr> g'day Pseudonym 
16:31:19 <blackdog_> i guess i'm not overly bound to xemacs yet. worth swapping for?
16:31:24 <shapr> I dunno
16:31:25 <shapr> haven't used it.
16:31:41 <shapr> I have a palm IIIc
16:31:43 <Pseudonym> G'day.
16:32:00 <shapr> I think sachac is the maintainer...
16:32:01 * shapr looks
16:32:23 <Pseudonym> Happy Guy Fawkes Day, everyone!
16:32:50 <shapr> ah, here we go..
16:32:52 <shapr> http://www.emacswiki.org/cgi-bin/wiki/PlannerMode
16:34:18 <blackdog_> cheers
16:34:27 <shapr> can't find any screenshots
16:34:37 <shapr> http://www.emacswiki.org/cgi-bin/wiki/CategoryPersonalInformationManager
16:34:58 <isomer> shapr: that page inspired me to buy a packet of PIM biscuits :)
16:35:18 <shapr> heh, cool
16:35:21 <shapr> what is one?
16:35:46 <isomer> CategoryPersonalInformationManager, of course (PIM)
16:39:00 <shapr> no, what's a PIM biscuit?
16:40:10 <isomer> http://www.danone.fr/wps/portal/redirect/ficheProduit/ref/CMS.DanoneConseils.VieDesMarques.MarquesEtProduits.LU.Pims
16:40:29 <shapr> nifty!
16:41:00 <isomer> they're delicious
16:42:54 <Lunar^> lol
16:43:08 <Pseudonym> Damn, this is exactly the kind of paper I've been looking for.
16:43:15 * Pseudonym sighs happily
16:43:23 <Lunar^> Pseudonym: The description of Pim's ?
16:43:27 <blackdog_> shapr: just trying to upgrade packages with xemacs: i'm getting permissions errors. I assume it's trying to install in /usr, which isn't really what i want - can it be set up to install packages in a local directory?
16:43:34 <Pseudonym> No, valuable though that is.
16:43:54 <Pseudonym> The one on Algebraic Specifications that's on LtU at the moment.
16:44:11 <Pseudonym> I've been thinking that someone should have written a historical/survey paper on it by now.
16:44:43 <shapr> blackdog_: are you using xemacs on debian?
16:45:02 <blackdog_> yep
16:45:10 <blackdog_> is there an easier way?
16:45:35 <shapr> are you using xemacs to upgrade packages?
16:45:55 <shapr> Pseudonym: what do you think of PvR?
16:46:33 <blackdog_> shapr: yeah. Is that dumb?
16:46:49 <Pseudonym> I have a lot of respect for the man.
16:47:04 <shapr> Pseudonym: that's tactful...
16:47:13 <Pseudonym> Well, I perosnally don't like Oz much.
16:47:22 <Pseudonym> But then, I'm kinda burned out on logic programming anyway.
16:47:41 <shapr> blackdog_: in my experience, you should use the debian packages, the xemacs upgrading process conflicts
16:47:54 <Pseudonym> Having said that, it's only projects like Oz which are going to make logic programming useful, if it's possible.
16:47:59 <shapr> having xemacs package support is great on win32 where you don't have anything else, but debian is better imho
16:48:11 <blackdog_> Hm. Ok, fair enough.
16:48:15 <Pseudonym> So I do see Oz as an important stepping stone, even if it's not what I'd want to use.
16:49:27 <Pseudonym> I did find his essays very interesting.
16:49:53 <Pseudonym> I think, for example, that he hit the nail on the head with the conflict between concurrency and state.
16:50:11 <Pseudonym> A language which can sort that out will be a kick-arse language indeed.
16:51:24 <Pseudonym> I also liked his comments on nonalgorithmic programming.  I noticed that he was very reserved in expressing any opinion on the topic.
16:52:43 <Riastradh> What's the conflict between concurrency and state?
16:53:36 <Pseudonym> Concurrent programming isn't hard.  Stateful programming isn't hard.  Concurrent stateful programming is hard.
16:53:42 <Pseudonym> That's the brief version.
16:54:06 <Riastradh> OK.  How about a brief defence of that assertion?
16:54:31 <dark> Pseudonym: You may have just described databases :)
16:54:53 <Pseudonym> dark: No I haven't, though I freely admit that databases have the worst concurrency problems.
16:55:34 <Pseudonym> Well, the problem is that when you have state which is accessed by more than one concurrent task, you have to protect it.
16:55:58 <Pseudonym> For simple cases, this isn't a problem.
16:56:15 <Pseudonym> But beyond a certain level of complexity, there are no good general solutions to the problem.
16:56:56 <Riastradh> At what level of complexity do mutexes or placeholders or condition variables lose their property of being good solutions?
16:56:59 <Pseudonym> The issues include deadlock, livelock, priority inversion and so on.
16:57:25 <Pseudonym> Around the level where you need to hold more than one or two mutexes.
16:57:41 <Pseudonym> At any given time, of course.
16:58:51 <Pseudonym> It gets worse when you don't know exactly how many mutexes you're going to need to hold beforehand.
16:59:03 <Riastradh> Example, please.
16:59:14 <Pseudonym> Databases are a good example.  Multi-table or multi-database transactions are horrid.
16:59:14 <clausen> "Transaction Processing" by Gray and Reuter
16:59:39 <Riastradh> OK, besides databases.
16:59:41 <Pseudonym> clausen: It's still horrid, and it's still not a completely solved problem.
16:59:49 <clausen> Pseudonym: agreed
17:00:01 <Pseudonym> Riastradh: I use the example of databases because that's what I do for a living.
17:00:01 <clausen> Pseudonym: it's The Book for understanding the issues
17:00:05 <Pseudonym> So it's the one I'm most familiar with.
17:00:07 <Riastradh> (I know too little about the implementation of databases to be able to think about it.)
17:00:16 <clausen> Riastradh: consider to threads:
17:00:19 <clausen> T1: lock(A)
17:00:23 <clausen> T2: lock(B)
17:00:25 <Pseudonym> I know too little about anything else to be able to think about it. :-)
17:00:26 <clausen> T1: lock(A)
17:00:32 <clausen> T1: [busy waits]
17:00:38 <clausen> oops
17:00:43 <clausen> T1: lock(B) [busy waits]
17:00:50 <clausen> T2: lock(A) [busy waits]
17:00:54 <clausen> they will both wait forever
17:01:07 <clausen> for each other to release locks
17:01:11 <Riastradh> clausen, right, and that's a problem; but when would that happen if you're not an idiot programmer?
17:01:12 <blackdog_> so the problem is that sometimes you can't find a sane ordering of mutexes?
17:01:13 <dark> Postgres says it can detect this and break the lock.
17:01:14 <clausen> (not even busy waits, just waits, sorry)
17:01:30 <dark> Riastradh: You're assuming a one-programmer model :)
17:01:38 <Riastradh> And if you _do_ plan to let that happen, why wouldn't you mark either of the mutexes as not owned?
17:01:50 <Pseudonym> Riastradh: In general, the problem is that synchronisation is part of a function's interface.
17:01:51 <clausen> Riastradh: it will happen whenever locks are acquired in a different order
17:01:58 <Pseudonym> And there is no good way to annotate this.
17:02:09 <dark> blackdog: Sometimes you have to restructure your whole program just to change the order of mutexes.  Linux's filesystem code has had this a few times.
17:02:36 <dark> It's also the reason why there's still no good union filesystem.
17:02:40 <shapr> union?
17:03:01 <mattam> union ?
17:03:24 <Pseudonym> It's like a normal filesystem, only it campaigns for better wages and conditions.
17:03:43 <shapr> blackdog: dropped your underscore, eh?
17:03:56 <Riastradh> Pseudonym, so what's the solution to the concurrent state problem?
17:03:59 <shapr> Pseudonym: and after awhile, it goes on strike, and gets scabs?
17:04:09 <dark> shapr: I think the phrase is used in two ways :)  One is to have a filesystem shadowing another, for example a ram fs mounted on top of a cdrom, with all the changes going into ram.  The other is to combine two directories into one, for example /usr/packages/*/bin/* all showing up in /bin/
17:04:25 <Pseudonym> Riastradh: Being clever.
17:04:27 <mattam> are you lauging at us Pseudonym ? :)
17:04:32 <Pseudonym> Usually.
17:04:39 <shapr> dark: oh, the first one sounds very useful
17:04:44 <clausen> Riastradh: deadlock detection
17:04:52 <Pseudonym> mattam: Oh, no, no, no... ok, yes.
17:04:55 <Pseudonym> Who's "us"?
17:05:00 <clausen> Riastradh: that is, if a transaction has been running for a long time
17:05:03 <mattam> shapr & me
17:05:08 <clausen> Riastradh: (i.e. waiting on a lock for a long time)
17:05:12 <clausen> Riastradh: then you try to figure out why
17:05:18 <shapr> Pseudonym laughs at me on a regular basis....
17:05:19 <blackdog> shapr: it's like going round with your fly undone and your shoelaces untied.
17:05:19 <dark> shapr: Despite its usefulness we still don't have one :)  And I think it's mainly because linux VFS locking is way too hairy to allow a filesystem call to go back into the VFS.
17:05:22 <Pseudonym> Basically, there are four preconditions to deadlock.
17:05:37 <Smerdyakov> 1) It's Monday.
17:05:39 <Smerdyakov> 2) It's 3 PM.
17:06:02 <shapr> 3) you're using an IMPERATIVE language
17:06:11 <shapr> 4) programmers wrote your code
17:06:18 <Pseudonym> 1. Serially reusable resources.  (That is, resources are protected by mutual exc;llusion.)
17:06:25 <Smerdyakov> Oh man.
17:06:28 <mattam> if it were alien lifeforms though...
17:06:34 <Smerdyakov> Pseudonym is seriously doing an undergrad OS course review.
17:06:40 <Smerdyakov> Let me get my notebook open first, Pseudonym!
17:06:44 <Pseudonym> 2. Incremental acquisition.  You acquire resources one at a time, and you hold on to them while you're waiting for other resources.
17:06:55 <dark> mattam: We could use dselect as a basis of comparison, it was definitely written by aliens.  So was AIX, which has more concurrency in it.
17:07:00 <Pseudonym> 3. No pre-emption.  Once you hold a lock, you keep it until you explicitly release it.
17:07:04 <shapr> Pseudonym is the man, I've learned lots from these guerilla lectures. They're great.
17:07:19 <Riastradh> PFHOOD.
17:07:28 <Smerdyakov> shapr, you're probably one of the only ones here who hasn't taken a class that drills these 4 points into your head. :)
17:07:28 <Pseudonym> 4. Wait-for cyclke.  Basically, there's a cycle in the graph of tasks which are waiting for resources.
17:07:33 <mattam> dark: AIX has absolutely no problems with semaphores and the like, AFAI experienced
17:07:51 <Pseudonym> The cycle may have only one node.  Self-deadlocks (where you hold a lock and then try to reacquire it) are surprisingly common./
17:08:00 <dark> mattam: So we need to look at it to see how aliens solved this problem :)
17:08:00 <shapr> Smerdyakov: that's true. My last (only) computer class was taught me ROM BASIC on IBM-XT hardware
17:08:11 <Pseudonym> Got all that?
17:08:22 <Pseudonym> If you remove any one of these conditions, no deadlock.
17:08:38 <dark> I guess postgres goes the preemption route.
17:08:46 <clausen> dark: no
17:08:52 <shapr> Pseudonym: makes sense
17:08:52 <mattam> dark: its proprietary, and i don't buy into your argument that its supposedly built by aliens
17:08:56 <Pseudonym> Usually, you break deadlocks in database-like code by allowing preemption, yes.
17:09:05 <shapr> mattam: have you ever *met* any IBM programmers??
17:09:07 * shapr grins
17:09:18 <Pseudonym> Also by breaking incremental acquisition.
17:09:21 <mattam> no...
17:09:27 <clausen> dark: all popular database systems timeout locks, and then rollback transactions until they break deadlock
17:09:30 <mattam> seems delightful though
17:09:31 <dark> clausen: Well the manpage says that a transaction can be terminated if it deadlocked, and the caller then has to retry.
17:09:40 <dark> clausen: Sounds like preemption to me :)
17:09:41 <Pseudonym> Generally, databases build up a sequence of operations that they _want_ to do, then do it all atomically.
17:09:46 <clausen> dark: ok, I guess so :)
17:10:04 <Pseudonym> And a transaction manager makes sure that there are no cycles.
17:10:05 <clausen> dark: well, i would define preemption as "you wait"
17:10:09 <clausen> dark: not "start again"
17:10:13 <dark> Well I've used AIX too, and it's definitely from some alternate universe or something.
17:10:23 <Pseudonym> Because all the jobs are done at once, there's no incremental acquisition.
17:10:24 <shapr> yah, did you use the AIX graphical installer?
17:10:32 <shapr> mrun or something
17:10:35 <Pseudonym> Anyway.
17:10:42 <mattam> ksh hell
17:10:50 <Pseudonym> There are whole books and many, many PhD theses on this topic.
17:10:54 <shapr> I was sysadmin of an AIX box running on PPC 604e
17:10:56 <dark> clausen: "you wait" won't work in the general case.  The process already has lock A and is waiting for lock B.  If you break its lock A, you break its proof of correctness.
17:10:59 <shapr> massive floating point power on that box
17:11:04 <clausen> dark: exactly
17:11:17 <Pseudonym> Another situation which happens with embedded systems sometimes is "livelock".
17:11:38 <Pseudonym> Livelock is far more subtle.
17:11:46 <mattam> what is that Pseudonym ?
17:12:06 <Pseudonym> Basically, the system is swamped by so many events that it can't get work done.
17:12:26 <Pseudonym> Processes which signal events to other tasks are usually the culprits.
17:12:41 <Pseudonym> I think of it as the condition variable equivalent of mutex deadlock.
17:12:57 <clausen> a common mistake is to prioritize transactions by things like user status
17:13:10 <dark> The modern example is an apache server that spends all its time forking new servers to handle incoming connections, and never gives those servers time to handle the requests.
17:13:14 <Pseudonym> The thundering herds problem from Unix is a good example.
17:13:31 <clausen> this is a big mistake, because if a "low-ranked" user locks a high-contention resource, it will take a long time to release it
17:13:43 <Pseudonym> No, that's priority inversion.
17:13:55 <Pseudonym> That's different again. :-)
17:14:04 <dark> Hmm is livelock the same as starvation?
17:14:08 <Pseudonym> Kind of.
17:14:14 <clausen> Pseudonym: it was a continuiation of an earlier thing I said
17:14:19 <Pseudonym> Ah, OK.
17:14:26 <dark> I guess livelock is a quality of the system and starvation is what happens to one process.
17:14:41 <Pseudonym> The standard solution to priority inversion, namely the priority inheritance protocol, is notoriously deadlock-prone.
17:14:56 <Pseudonym> dark: Yes, but deadlock is also a quality of the system.
17:15:03 <mattam> and DoS is a common name for attacks that do that to computer
17:15:20 <dark> Sounds like process priority should depend on the value of the resources it has locked.  This is possibly abusable though :)
17:15:20 <Pseudonym> Priority ceiling protocol is deadlock-free, but you lose some concurrency.
17:15:28 <Pseudonym> dark: Exactly.
17:15:33 <Pseudonym> That's precisely what you do.
17:15:48 <Pseudonym> Where you define the value of the resources as the priority of the tasks which want it.
17:16:24 <dark> So everyone who wants to do some serious seti@home work will lock something important first :-)
17:16:35 * Pseudonym laughs
17:17:05 <Pseudonym> Not quite.  Unless you're writing a kernel or a real-time task, you probably won't have access to priority inheritance because it is so abusable.
17:17:31 <Pseudonym> But then, I suppose, there are easier ways to DoS most systems.
17:17:58 * Smerdyakov hates priority scheduling now thanks to the efforts of the instructors for the advanced systems class he is taking.
17:18:12 <Pseudonym> Anyway, back to state vs concurrency.
17:18:30 <Pseudonym> Basically, if you have a) no state, or b) no concurrency, there's hardly any problem.
17:18:37 <mattam> Pseudonym: why not give an order on resources instead of processes and balance with process priorities ? this would be more equitable wouldn't it ?
17:18:59 <Pseudonym> Which is one of the reasons why we don't really have this problem in Haskell.
17:19:00 <Pseudonym> No state.
17:19:03 <Smerdyakov> mattam, better yet is lottery scheduling.
17:19:09 <Pseudonym> mattam: One example of what you're describing is the priority ceiling protocol.
17:19:23 <mattam> interesting
17:19:31 <Pseudonym> What you do there, is you tell each resource beforehand the maximum priority task which can acquire it.
17:19:40 <Pseudonym> This gives you a measure of how important the resource is.
17:20:07 <mattam> i haven't much studied systems in school and Tannenbaum book are out of date it seems :)
17:20:39 <clausen> when was Tannenbaum written?
17:20:52 <clausen> Gray&Reuter was 1991, which everyone is still using (?)
17:21:17 <mattam> the one on systems (3rd edition) in 1997
17:21:21 <Pseudonym> Tannenbaum comes out with a new edition every couple of years.
17:21:25 <mattam> 2nd edition
17:22:35 <Pseudonym> Mind you, I don't think hat anyone has really tried to solve a hard concurrency problem in Haskell.  Yet.
17:22:36 <clausen> mattam: well, most of this stuff is from the 80s
17:23:44 <mattam> probably, but it isn't much detailed in his book, which i find bad. I have not a good opinion of Tannenbaum's books overall...
17:24:22 <mattam> Lottery is better than what i proposed. Is it something like worst-fit being the best in general cases ?
17:24:43 <Pseudonym> Is lottery basically random?
17:24:51 <mattam> i suppose
17:25:03 <Pseudonym> There's something to be said for randomness in scheduling problems.
17:25:13 <shapr> never works for me :-)
17:25:31 <Pseudonym> But I think that, especially in real-time or performance-sensitive applications, predictability is far more important.
17:25:49 <Pseudonym> Hell, many hard real-time systems do scheduling at compile time.
17:25:57 <mattam> well, it's in the contract in this case
17:25:59 <Pseudonym> It's that important to get it right.
17:36:45 <shapr> blackdog: how do I copy/paste a line in vim?
17:37:05 <Smerdyakov> y for yank.
17:37:06 <Pseudonym> capital Y copies a line.
17:37:07 <Smerdyakov> p for put.
17:37:11 <Smerdyakov> (If I remember from 5 years ago.)
17:37:16 <Pseudonym> Yup.
17:37:23 <shapr> ah, thanks
17:37:27 <Pseudonym> lower-case y is for yanking other-sized regions.
17:37:30 <Pseudonym> Y is an optimisation.
17:42:20 <isomer> shapr: you go back to emacs, of course\
17:42:36 * shapr grins
17:42:48 <shapr> oh, actually I could
17:42:54 <shapr> it's only a three hop tramp file
17:43:07 <isomer> ugh
17:43:45 <shapr> don't like tramp?
17:43:50 <isomer> it's just slow
17:44:01 <isomer> ...unless there is some trick i don't know?
17:44:09 <shapr> no, it's slow.
17:44:18 <Smerdyakov> Now what kind of retrograde doesn't like tramps?
17:44:19 <shapr> and it's way picky too
17:44:40 <isomer> i'm going to try gnuserv with a local client and see if it sucks less
17:45:03 <shapr> isomer: if your remote shell doesn't use bash and doesn't have a conforming prompt, tramp will fail miserably
17:45:07 <shapr> gnuserv is spiffy
17:45:10 <shapr> especially with xemacs
17:45:46 <isomer> *nod*
17:46:27 <isomer> hmm....don't seem to have it installed on my remote machine :(
17:46:34 <isomer> is it not standard part of xemacs?
17:47:26 <shapr> I think it is, but I dunno if it's useful for remote network stuff
17:47:49 <isomer> i was going to try forwarding the X session over to my client, and see if that was faster than tramp
17:48:01 <isomer> failing that, i'll install nano on that box and suffer
17:48:15 <shapr> tramp is only slow the first time
17:48:18 <shapr> after that it's fine
17:48:49 <shapr> are you using ssh-agent and authorized_keys ?
17:48:50 <isomer> we must be missing something...
17:48:54 <isomer> yup
17:49:06 <shapr> which tramp methods are you using?
17:49:33 <isomer> uh....whatever the default is? is that bad?
17:50:07 <shapr> I don't remember which is the default
17:50:24 <shapr> scp is a pretty fast method
17:50:42 <isomer> where do i set it? M-x customize-group RET tramp RET ...then what?
17:52:21 <shapr> I did M-x pp-variable tramp-methods
17:52:27 <shapr> and then chose the one I wanted
17:53:11 <isomer> where do you choose it?
17:53:26 <shapr> when you're opening the file
17:53:39 <shapr> C-x C-f /[su/root@localhost]/etc/apt/sources.list
17:53:58 <shapr> C-x C-f /[scp/shae@couatl].zshrc
17:54:07 <shapr> I think both of those will work
17:54:15 <shapr> I can't remember multi-hop syntax off the top of my head
17:54:21 <isomer> let me try...
17:55:30 * shapr rebuilds the kernel for fourth time in an hour
17:56:06 <Pseudonym> I remember when it took hours to do it once.
17:57:22 <shapr> me too
17:57:36 <Pseudonym> shapr <- old fart
17:57:37 <shapr> first time for me was on a pentium 90
17:57:46 <isomer> shapr: it's still not exactly what i'd call speedy...it's still going
17:57:48 <shapr> actually a p75 overclocked to 90
17:57:54 <shapr> isomer: no way
17:58:02 <isomer> way
17:58:15 <shapr> isomer: it takes about five seconds to start up for me, and then saving is less than half a second
17:58:22 <isomer> not me :(
17:59:08 <shapr> I'm sure we can figure it out later.
17:59:16 <shapr> I gotta finish this and then sleep.
17:59:16 <isomer> okey...thanks
17:59:24 <isomer> i should really write my lab up
17:59:34 <shapr> sounds threatening
18:00:26 <isomer> meh...busy work. no brains req'd (unfortunately)
18:01:38 <shapr> Pseudonym: I like being an old fart, I can regale the youngsters with tales of the Intel 4004
18:02:07 * isomer hand shapr a dusty accumulator register
18:03:00 <shapr> back then, when we had a core dump, it meant we had to get the RAM up off the floor.
18:03:05 * shapr sniggers
18:05:49 <shapr> isomer: I think this one's full.
18:07:05 * isomer offers shapr a chromate ester instead
18:07:18 <shapr> yow
18:07:19 <isomer> you can use it to remove all the extra 1's in the accumulator
18:08:07 <shapr> oh, that's useful
18:08:29 <isomer> you should see what a job it does on your fingers :(
18:22:35 <shapr> yay,sleep
18:22:37 * shapr falls over
18:47:06 <emu> 486 DX-33 -- hours and a half
12:54:01 --- topic: '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","lots of cool debs in the haskell-experimental archive - see http://haskell.org/hawiki/DebianUsers","new monads tutorial http://www.nomaware.com/monads/html/","Any user who would like to request any unwritten tutorial please msg shapr", "peakUsers = 72"]'
12:54:01 --- topic: set by Jad on [Tue Nov 04 12:03:06 2003]
12:54:01 --- names: list (clog Arnia Darius figment tic blackdog Pseudonym Cale Smerdyakov phubuh clausen smkl crass Pinnen keverets andersca ejt ludde_ jasonw Tomasso mattam shapr ozone galority skylan polli _rubix musasabi shrimpx wax lambdabot kaol Lor Brandon_ earthy jameson esap el_diego themus emu aleator wagle__ vegai Lunar^ keir ibid isomer Segora det kosmikus|away SyntaxPolice Igloo asmodai mgoetze norpan FastJack cm xkb Riastradh)
12:57:07 <blackdog> You're going to have to be a bit clearer and more specific. Obviously, your algorithm is broken in some way: can you explain it in words?
12:57:40 <figment> Not easily
12:58:22 <figment> T\]And that may be the problem in and of itself
21:31:03 <Jad> good morning guys
21:31:15 <Pseudonym> G'day.
21:57:05 <crazney> out of curiousity.. what happens if you have a - in function/variable/data constructor name.. ie 'foo-bar'.. it doesn't seem to work, but hugs doesn't seem to complain (got an exam tomorrow and on a past exam they asked this)...
21:57:40 <Smerdyakov> What do you mean "doesn't seem to complain"?
21:57:45 <crazney> well
21:57:49 <crazney> i have a file with:
21:57:51 <crazney> foo-bar = 3
21:57:52 <crazney> in it..
21:57:57 <Smerdyakov> I think that defines the infix operator -/
21:57:58 <crazney> and when i load it in hugs, it loads ok
21:58:00 <Smerdyakov> I think that defines the infix operator -.
21:58:16 <crazney> hrm?
21:58:34 <Smerdyakov> Do you know what an infix operator is?
21:58:38 <crazney> nope
21:58:56 <Smerdyakov> It's an operator that you use like this: someExpression OPERATOR otherExpression.
21:59:01 <Smerdyakov> Examples are: + - * /
21:59:21 <crazney> ah right
22:00:36 <Smerdyakov> So, in slightly less accurate terms, the definition you were surprised to see work "redefines subtraction."
22:02:48 <crazney> so the 'foo' and 'bar' would be considered variables then?
22:02:48 <crazney> yeah
22:02:48 <crazney> haha thats funny
22:02:48 <crazney> a-b = 3
22:02:48 <crazney> Foo> 5-5
22:02:48 <crazney> 3
22:02:48 <crazney> Smerdyakov: thanks dude!
22:11:17 <crazney> whats it called when you put a class constraint on a function type signature (eg foo :: Eq a => [a] -> a -> Bool)...?
22:11:57 <crazney> also.. how do I specify multiple type constraints (also for multiple variables).. ie say I wanted Ord and Show defined for 'a' and Ord defined for 'b'.. (as in foo :: a -> b -> Int)..
22:24:15 <ozone> crazney: foo :: (Ord a, Show a, Ord b) => a -> b -> Int
22:24:23 <crazney> thanks ozone.
22:25:11 <ozone> as for your other question ... it's called exactly what you described :)
22:25:24 <ozone> (type constraint, or class constraint)
22:25:30 <crazney> cool stuff. thanks again!
22:25:43 <ozone> you're being tested on haskell syntax?
22:25:46 <ozone> that sounds a bit lame
22:26:49 <crazney> ozone: yeah, its incredibly lame.. its probably only a couple of marks
22:27:04 <Darius> "Today we are having a quiz on the syntax of Lisp"
22:27:07 <crazney> most of the stuff will be writing programs.
22:28:09 <alanl> hello
22:28:21 <alanl> does anyone know what does := do?
22:28:49 <Darius> It can be a constructor, otherwise nothing.
22:29:01 <ozone> Darius :)
22:29:24 <alanl> well I'm seeing this in this really old code that I wish to modernise
22:29:45 <alanl> I think it might have something to do with arrays
22:29:49 <ozone> haskell code?
22:29:57 <ozone> i don't think := was ever defined for anything
22:30:17 <ozone> isn't a constructor starting with : a GHC extension?
22:30:27 <crazney> hrm, its not possible to put a type constraint in a parameterised algebraic data structure / parameterised type synonym..?
22:30:33 <Darius> ozone: I don't think so
22:31:31 <alanl> well its on the bottom of this page..
22:31:33 <alanl> http://www.informatik.uni-bonn.de/~ralf/software/math/Math_9.html#SEC28
22:31:36 <Darius> crazney: Depending on what you mean it is to a degree but not useful for 'data' and I don't think there's much of a point for type synonyms without rank-2+ types.
22:32:02 <alanl> it would be really cool to get this thing working again
22:33:13 <crazney> Darius: ok, thanks.
22:37:03 <alanl> any hints??
22:42:31 <Darius> Find out what version of Haskell it is using and read the report for that version.
22:51:23 <alanl> The problem is it doesn't seem to be standard Haskell...it might be some funky ghc extension :-(
22:53:37 <alanl> what about mutable stuff like writeRef and so forth...is there a standard module I can import?
23:01:39 <Darius> It isn't Haskell 98 because of the 'renaming' in the module declaration.
23:56:00 <shapr> wheee
