00:13:46 <det> exarkun: heya
00:14:02 * Marvin-- tries to recall what tanh looks like
00:15:23 <ddarius> sigmoid
02:23:50 <TripleDES> morning
02:24:25 * earthy nods
02:33:21 <earthy> it still is, in some places of the world, such as mine
02:59:51 <shapr> SyntaxNinja: gforge is massive
04:55:16 <shapr> @yow
04:55:16 <lambdabot> LIFE is a never-ending INFORMERCIAL!
04:55:19 <shapr> hello modeless 
05:13:26 <modeless> hi shapr... 
05:14:55 <shapr> learning Haskell?
05:15:09 <modeless> yes, i'm trying some things out at the moment...
05:15:20 <modeless> need it for my thesis...
05:15:27 <shapr> have you seen http://www.haskell.org/learning.html ?
05:15:31 <shapr> what's your thesis about?
05:15:44 <modeless> about algorithms to solve context matching problems.
05:15:50 <shapr> sounds cool
05:15:55 <modeless> yes, i've seen that site before.
05:16:03 <modeless> well, it's quite theoretical ;-)
05:16:27 <modeless> what's your connection to haskell?
05:16:50 <shapr> I'm a self employed programmer, I think Haskell is the best tool for most jobs.
05:17:05 <modeless> so you're really using haskell for real world projects?
05:17:10 <shapr> only once so far.
05:17:16 <shapr> but I hope to do more.
05:17:41 <shapr> how did you get into Haskell?
05:18:01 <modeless> in university, i had a course about functional programming, and that was done with haskell.
05:18:26 <modeless> ...it's the favourite language of my prof where i'm writing my thesis.
05:18:57 <shapr> who's your prof?
05:19:05 <modeless> prof schmidt-schauss in frankfurt
05:19:13 <modeless> (germany)
05:19:28 <shapr> I don't think I've read any papers by him before.
05:20:01 <modeless> well, at least he's mentioned in the latest haskell community & activities report with an extension of ghc...
05:20:16 * shapr looks
05:20:53 <shapr> oh, neat
05:21:27 <Lunar^> shapr: Do you know if Alister Reid business is working ?
05:21:46 <shapr> Lunar^: he just released .. CMI? so I think so.
05:21:47 <modeless> well, personally i don't know much about that project since i'm not connected with it. but it sounds interesting.
05:21:55 <shapr> I know that John Launchbury's business is working quite well.
05:22:20 <Lunar^> He was interested in hOp if I remember well, right ?
05:22:39 <shapr> yup
05:22:55 <shapr> did sebc ever hear from him?
05:23:07 <Lunar^> I hope to convince sebc in taking care of this project now that he doesn't have the time to do it
05:23:11 <Lunar^> shapr: dunno
05:23:35 <Lunar^> I need some base to test my ideas about OS programming
05:24:06 <shapr> I'd like to try hOp on my SMP box
05:24:06 <Lunar^> Dunno if I will have the time to continue hOp, but I think it's better that someone who wants to continue to carry on
05:24:09 <shapr> see how to make that work
05:24:40 <shapr> as far as I understand, shared garbage collection is the major theoretical obstactle for an SMP GHC runtime.
05:24:52 <Lunar^> right
05:25:11 <shapr> modeless: fundio looks very useful
05:25:13 <Lunar^> But with generational GC, isn't there something ?
05:25:26 <Lunar^> like proc 0 for gen 0 and proc 1 for gen 1 ?
05:25:44 <shapr> huh?
05:25:59 <modeless> so it is... it'd really be nice to get rid of all those difficulties connected with unsafePerformIO
05:26:13 <Lunar^> whatever, I'm saying dumb things
05:26:45 <shapr> Lunar^: I don't know any details about generational GC, so I don't know.
05:27:11 <modeless> okay, i'm out... time to get sth to eat ;-)
05:27:13 <modeless> byebye...
05:35:54 <shapr> I can barely wait for the solstice
05:46:58 <shapr> the sun is already gone.
05:47:03 <shapr> 2:45pm
05:58:18 <SyntaxNinja> g'mornin
06:01:18 <shapr> y0 y0
06:01:35 <SyntaxNinja> hey shapr. so jabber is too big?
06:01:38 <SyntaxNinja> oops
06:01:42 <SyntaxNinja> I mean gforge or whatever
06:01:45 <shapr> nah, it's not too big
06:01:48 * SyntaxNinja is trying out jabber
06:01:53 <shapr> just that it'll take me awhile to configure it all
06:02:15 <SyntaxNinja> thats cool.
06:02:29 <shapr> I've never set up an LDAP server before.
06:02:58 <shapr> cvs, postgres, postfix, bind, mailman I know
06:03:57 <earthy> ldap isn't too hard
06:03:58 <SyntaxNinja> wow
06:04:41 <SyntaxNinja> so do you have any clue how diff sourceforge is from gforge?
06:05:05 <shapr> no, I don't
06:05:33 <shapr> this might help: http://gforge.org/
06:06:09 <shapr> the project manager looks spiffy!
06:06:29 <shapr> I may try this for my client projects
06:18:17 <SyntaxNinja> cool
06:20:01 <SyntaxNinja> I like the idea of a "code snippits" section!
06:21:06 <SyntaxNinja> it is _way_ more intuitive than sorceforge :)
06:22:34 <shapr> grr, it's having trouble talking to pg
06:22:47 <SyntaxNinja> do you know pg?
06:22:58 <SyntaxNinja> are you using sameuser authentication, I always got tripped up by that
06:25:25 <shapr> actually, I think it may be upset because I've put all of these many services on the same box
06:25:49 <SyntaxNinja> odd
06:26:01 <shapr> oh, I wonder if I've allowed tcp/ip connections from pg
06:26:22 <shapr> oh, I have. hmm.
06:26:35 <SyntaxNinja> are you going between boxen?
06:26:47 <SyntaxNinja> server is on a different box I mean?
06:26:58 <shapr> nah, it's all on raven.
06:27:59 <shapr> aha!
06:31:55 <shapr> well, now I have a bug to file for gforge.
06:32:00 <shapr> hi skew, what's up?
06:32:07 <SyntaxNinja> Igloo: alive? ross p was asking if its too late to get hugs-2003 into sarge, I'm guessing its too late, but I'd like to find something to point him to?
06:32:14 <SyntaxNinja> shapr: eww a bug already?
06:32:35 <shapr> yah, gforge configure stage should *stop* slapd before it changes the config files.
06:32:48 <shapr> if slapd is already running, the configure errors when trying to *start* slapd.
06:33:16 <skew> shapr: Not a whole lot.
06:33:41 <skew> Does anybody know of a Python/Haskell interface?
06:33:56 <shapr> I've heard of Python.
06:34:20 <skew> You've worked on Twisted quite a bit, haven't you?
06:35:42 <SyntaxNinja> he _is_ Twisted
06:35:44 <shapr> I don't remember if I ever wrote any Python code for it, if I did, it wasn't much.
06:35:53 <SyntaxNinja> (but in a good way)
06:36:06 <shapr> I argued a lot with glyph, dash, and radix about design issues and structure.
06:37:13 <shapr> and then Guido decided against Stackless Python, and I went in search of a language that did the same tricks as Stackless.
06:37:27 <shapr> I remember when glyph was writing Twisted in Java =)
06:37:45 <skew> That's not right
06:38:11 <shapr> he showed up on #python on EFNet and was quickly converted.
06:38:29 <skew> This was a long time ago when Twisted was just starting?
06:38:35 <shapr> yes
06:38:45 <skew> Twisted could really use stackless, I think
06:38:59 <shapr> iirc, Twisted is the third iteration of Glyph's original idea
06:39:32 <shapr> anyways, glyph once told me that monads made his head hurt, so that's why I checked out Haskell in the first place.
06:39:54 * shapr nostalges a bit.
06:39:54 <skew> Poor glyph. Monads are the best thing since ... ever?
06:40:04 <shapr> have you seen Arrows? =)
06:40:36 <skew> yeah, I guess so
06:40:40 <shapr> I've heard that the Department of Defense has hired a small company named Aetion or so to design Spears, a generalization of Arrows.
06:40:55 <skew> How do you generalize them? To precategories?
06:41:12 <shapr> I wonder if Britney is actually the result of a secret DoD project.
06:41:28 <skew> It doesn't get much cooler than making a function polymorphic in the semantics it is to be executed with
06:41:34 <Cale> Arrows aren't category theory arrows.
06:41:46 <skew> No? They seem pretty close
06:41:58 <Cale> Yeah, they do - they're confusingly close :)
06:42:03 <shapr> I have Category Theory for dummies, but I haven't gotten very far in that book.
06:42:25 <skew> I got Categories for the Working Mathematician, but I haven't had time to start it
06:42:46 <shapr> anyways, I vaguely recall that someone does have a Python/Haskell interface.
06:42:55 <Cale> I've been reading that book slowly over the past year :)
06:42:57 <shapr> and I don't mean TwistedHaskell.
06:43:59 <skew> google thinks TwistedHaskell = HaskellBanana
06:44:23 <shapr> yah, funny
06:44:47 <shapr> I never got around to making the rest of the pieces work
06:45:27 <shapr> I've heard the protocol has changed since then.
06:46:41 <Cale> apparently arrows are equivalent to Freyd categories.
06:47:46 <shapr> skew: have you written much Haskell?
06:48:42 <skew> shapr: I've written a fair bit
06:49:02 <skew> shapr: Lots of odd things playing around with combinator parsers, monads, generic recursion schemes, etc
06:49:16 <skew> shapr: Half a scheme interpreter, and Unlambda interpreter ready to submit
06:49:54 <skew> shapr: a JAva parser wanting to grow into a compiler, started for a class project, for which I wrote a really cool lexer generator
06:50:13 <shapr> that's spiffy
06:50:17 <skew> shapr: So, bunches of random code with no real function. (Except the unlambda interpreter)
06:50:17 <shapr> is your code online?
06:50:31 <skew> shapr: No, although it wouldn't be too hard to put it there
06:50:41 <shapr> you could put into the hlibs darcs repo
06:51:09 <shapr> or haskell-libs.sf.net if you don't use darcs
06:51:19 <skew> shapr: hlibs? Sounds like stuff that is supposed to be halfway useful
06:51:36 <shapr> yah, like the brainfuck interpreter.. :-)
06:51:40 <skew> shapr: Maybe as a collection of excercises with various libraries
06:52:00 <skew> shapr: How much do people write interpreters?
06:52:11 <skew> shapr: I'm wondering how much there would be in my lexer generator
06:52:24 <shapr> well, hlibs is a cvs-wiki kind of thing
06:53:04 <shapr> part of the idea is that code that's put in there will be maintained to the point of always compiling with the latest Haskell compilers (hopefully)
06:53:16 <skew> shapr: at the simplest extreme of the format it takes a list of kewords and generates an Alex lexer, a Token data type, and UU_Parsing parsers for recognizing each of the tokens
06:53:31 <shapr> hm, nifty
06:53:38 <shapr> can I see?
06:54:06 <skew> sure. Input file?
06:54:23 * shapr thinks
06:54:31 <skew> Or full source?
06:54:57 <shapr> I'd like to get hold of the source, but I have a list of Joy system functions & keywords handy...
06:55:19 <shapr> what does the list need to look like?
06:58:32 <skew> shapr: Okay, check the paste page on the Wiki
07:00:05 <shapr> neat
07:00:09 <shapr> that's your java parser?
07:00:23 <shapr> er, lexer
07:00:28 <skew> First column is a regular expression. Second column is token name, defaults to capitalizing the regex if its aphabetical, Third column is the type T of value this token carries (optional), fourth (in {}) is Haskell code of type String -> T. Defaults to read
07:00:43 <skew> shapr: Minus some random lines so it didn't take up quite so much page space
07:00:52 <skew> shapr: but yeah
07:02:01 <skew> shapr: I got annoyed typing in PlusPlus the tenth time or so, and recorded a set of vim macros for each translation
07:02:13 <skew> shapr: That really sucked so eventually I wrote code
07:03:10 <shapr> nice :)
07:04:02 <skew> I tried to make it easy to add modules for different sort of output.
07:13:43 <Tomasso> is there any defined function that you give an index and returns the corresponding element of a list?
07:13:55 <Tomasso> cant find nothing in the haskell reference..
07:14:03 <shapr> !!
07:14:11 <shapr> @type (!!)
07:14:11 <lambdabot> (!!) :: [a] -> Int -> a
07:14:25 <exarkun> haskell is so wacky
07:14:51 <Tomasso> hahahahha let me chec
07:14:51 <exarkun> can that be used infix?  foo !! bar?
07:14:56 <shapr> yup
07:15:05 <exarkun> waaacky :)
07:15:05 <Tomasso> interesting! :D
07:15:13 <shapr> @type ("a" !! 1)
07:15:14 <lambdabot> "a" !! 1 :: Char
07:15:16 <Tomasso> it simplifies my life :D
07:16:22 <shapr> skew: I'd like to see your unlambda interpreter.
07:16:24 <skew> operator slices are so nice
07:16:46 <Tomasso> yeah...
07:17:00 <exarkun> are haskell lists vectors or linked?
07:17:18 <skew> shapr: It's pretty standard: ContT ??? (StateT Char IO) for the monad, 3 lines of ReadP for the parser.
07:17:38 <skew> It does need to go in CUAN sometime.
07:17:51 <shapr> CUAN?
07:18:01 <skew> The big tarball of everything Unlambda
07:18:11 <skew> By analogy to CTAN I think
07:18:13 <shapr> oh
07:18:20 <skew> exarkun: Linked of course
07:18:29 <skew> data List a = Cons a (List a) | Nil
07:18:42 <skew> We must have our algebraic data types.
07:18:49 <shapr> how does a vector list work?
07:18:56 <skew> (The constructors are really : (infix) for cons, and [] for nil)
07:19:50 <exarkun> so !! is not a nice operator
07:19:55 <TripleDES> hi
07:20:06 <skew> exarkun: no. foldr is much nicer
07:26:03 <skew> exarkun: Or list comprehensions, or any of a million other higher order functions
07:26:22 <skew> exarkun: And sometimes explicitly pattern matching, when you must
07:30:33 <skew> I wonder how well you could type a python binding
07:32:08 <exarkun> it'd be tough, I imagine.
07:33:32 <skew> If you don't care to type attribute creation and destruction it would be more reasonable
07:34:33 <skew> I think any binding that would be nice from the python side would have to use the ghci dynamic loading stuff anyway
07:34:45 <skew> So it shouldn't be that much harder to synthesize types as needed
07:35:23 <skew> Method constraints would be very useful for talking to OO languages
07:36:10 <skew> You could at least get typeclasses expressing the presence of attributes, although all those types would probably need to be PyObject
07:36:43 <exarkun> you'd have to be careful about how you wrote your python code for it to be usable, right?
07:36:50 <skew> Eh?
07:37:10 <skew> No the idea is that the haskell side would check that your object had the right methods before blessing it into Haskell land
07:37:19 <skew> Or raise an exception right then
07:37:30 <exarkun> But later on the Python object might lose that status
07:37:42 <skew> You're right
07:38:14 <skew> Never mind, we could just raise exceptions
07:38:47 <skew> And write some cool typeclasses or something for marshalling Haskell values into python
07:39:10 <exarkun> sounds cool
07:39:14 <exarkun> when will it be done!
07:39:18 <skew> All the object operations would be in IO. I guess that's not so bad
07:39:32 <exarkun> Dunno what that means
07:39:40 <skew> IO monad?
07:39:52 <exarkun> Oh
07:39:59 * exarkun scrunches
07:40:07 <exarkun> because they might mutate an object?
07:40:36 <skew> Yeah, or lots of other statefulness
07:40:51 <skew> Like other threads deleting attributes while you are using the object, etc
07:41:50 <skew> probably best just to have get_attr:: PyObject -> String -> IO PyObject, some kind of call function, etc
07:42:05 <exarkun> So how would you go about this?  There are multiple Haskell implementations, so I guess anything you wrote would only be applicable to one?
07:42:33 <skew> Ah, call :: (GoesToPy args) => PyObject -> args -> PyObject
07:43:39 <skew> exarkun: I think writing to the supposed to be stabalized interpreter API in the soon to be unified GHC/Hugs runtime
07:43:54 <exarkun> Ah, cool.
07:44:05 <skew> exarkun: Anything else would probably be less dynamic than you want from the python side
07:44:12 <exarkun> Using C as a glue language... groan.
07:44:32 <skew> Make some python bindings and it shouldn't be so bad :)
07:44:53 <exarkun> Are there any ffi modules (like ctypes or dl.. Call arbitrary functions w/ C calling conventions) for Haskkel?
07:44:57 <exarkun> Haskell
07:45:14 <skew> Not that I know of. There's dlopen I think
07:46:16 <exarkun> I guess you could make calls directly into the haskell interpreter API with ctypes, from Python
07:46:29 <skew> Okay, so there is a Dlopen binding.
07:46:37 <exarkun> Cool
07:47:01 <skew> It's unsafe as hell, but it should work
07:47:19 <skew> Get a void funpointer and cast to whatever type you like. Just like in C.
07:47:48 <exarkun> Yay
07:48:05 <skew> and segfault if you screw it up.
07:48:40 <exarkun> Of course
07:51:11 <skew> I think you could probably wrap Haskell values being passed to python so you can tell the types when you get them back, if you don't want to marshal
07:52:23 <exarkun> hmm
07:52:47 <exarkun> monads let you do mutate-y stuff, but does object identity matter a lot in haskell programs?
07:53:31 <exarkun> I'm trying to think of an example other than file io, but I can't.  If you pass stdin to Python, then python passes it back, does it matter if the thing you got back is the thing you passed?  Is there an identity operator at all?
07:53:52 <skew> Not for most things
07:54:24 <skew> I think the various sorts of references are just about the only thing
07:55:02 <skew> I was talking more about passing some fancy Haskell data structure out to Python, where it would be an opaque blob, but the interface would recognize it going the other way and could unpack it for you
07:55:04 <exarkun> I think managing object identity was the hardest part about the Py/ObjC bridge
07:55:12 <exarkun> Ahh
07:55:20 <Igloo> SyntaxNinja?
07:55:21 <skew> rather than giving you an generic PyObject or whatever
07:55:24 <exarkun> Why should anything be opaque? :)
07:55:30 <exarkun> Ahh, I see
07:55:43 <skew> Well, guido wants to add algebraic data types to Python, all the better
07:55:51 <exarkun> skew: Just finishing the spread implementation for Haskell might be easier :)
07:55:53 <SyntaxNinja> hi Igloo
07:55:55 <skew> Otherwise you would have to use some nasty class based encoding
07:56:39 <skew> Hmm, the post that said the runtime system was still vapourware was 1999. I'm having no luck finding docs that claim to be recent though
07:56:51 <skew> Ah well. I'll ask on the haskell list sometime
07:56:54 <shapr> SyntaxNinja: is this your new portable identity?
07:57:18 <SyntaxNinja> shapr: I'm thinking abou tit. i registered it :)
07:57:20 <shapr> hi harsha 
07:57:24 <shapr> SyntaxNinja: cool!
07:57:36 <shapr> you could even be the SyntaxNinjaPolice!
07:57:40 <SyntaxNinja> I was just messing with irc via gaim, since I'm using jabber and aim and irc now
07:57:51 <SyntaxNinja> so we'll see :)
07:57:53 <shapr> ya know, I tried to change to shaper a few years back, but there were huge protests.
07:58:00 <harsha> hi shapr 
07:58:18 <harsha> @fortune
07:58:19 <lambdabot> Maturity is only a short break in adolescence.
07:58:19 <lambdabot> 		-- Jules Feiffer
07:58:38 <SyntaxNinja>  heh. I always feel immature when messing with chat clients.
07:58:52 <SyntaxNinja> joining #gaim to ask about a bug helped a lot, though.
07:59:01 <exarkun> tootles
08:08:39 <Tomasso> if i had two types like : type a = (Int,Int) and type b = (Int,Int), how does haskell know what type is the expression (3,4) ?
08:09:31 <andersca> Tomasso: they are type aliases
08:09:53 <andersca> so the type of (3,4) will be inferred as (Int, Int)
08:09:59 <andersca> but will be able to unify with both a and b
08:10:11 <Tomasso>  i seeee :D
08:10:12 <Tomasso> hehe
08:10:21 <Tomasso> thanx
08:10:31 <andersca> actually, the type will be (a, b) where a and b have to be of type Num
08:35:04 <shapr> andersca: hey, did that forkIO work?
08:51:32 <shapr> @yow
08:51:32 <lambdabot> NOW do I get to blow out the CANDLES??
08:51:37 <shapr> @fortune
08:51:37 <lambdabot>     switch (ref $@) {
08:51:37 <lambdabot>     OverflowError =>
08:51:37 <lambdabot> warn "Dam needs to be drained";
08:51:37 <lambdabot>     DomainError =>
08:51:40 <lambdabot> warn "King needs to be trained";
08:51:42 <lambdabot>     NuclearWarError =>
08:51:46 <lambdabot> [3 @more lines]
08:52:01 <shapr> Marvin--: I request that you come up with a collection of funny swedish quotes, and I'll addd @oj to the quote module
08:53:18 <ddarius> @more
08:53:18 <lambdabot> die;
08:53:18 <lambdabot>     }
08:53:18 <lambdabot>              -- Larry Wall in <199709302338.QAA17037@wall.org>
08:54:00 <shapr> SyntaxNinja: have you tried to install the gforge deb?
08:58:04 <Riastradh> Ninjas don't 'try.'  They flip out and kill people!
08:58:53 <shapr> right, my mistake.
09:12:07 <Marvin--> shapr: heh
09:30:15 <Riastradh> Hey, there's someone in #scheme who started bashing lazy evaluation when I mentioned Haskell to him!
09:31:03 <andersca> give him seq
09:31:19 <Riastradh> ...er, you aren't going to come in and argue against him?
09:33:34 <Riastradh> Argh!  I'm all alone in defending lazy evaluation!
09:33:44 <shapr> Riastradh: we believe in lazy evaluation to the point that we're only going to defend it if he comes here and complains :-)
09:34:02 <Riastradh> Bah!  You lazy bums!
09:34:14 <shapr> yah, exactly
09:34:39 <Riastradh> I actually didn't realize that completely obvious pun there when I typed it.
09:46:14 <det> Lazy evaluation sucks!
09:47:45 <Riastradh> shapr, there, attack det!
09:53:12 <det> LOOK AT ME, MY PUNY UNARY APPLICATIVE FUNCTIONAL SYSTEM CANT COPE WITH MANY RECURSIVE FUNCTIONS, LET'S ADD SOME NORMAL-ORDER-EVALUATION TO THE MIX! YEAH! OH, WAIT, NOW DUPLICATED VALUES GET REVALUATED A SEVERAL TIMES, BETTER MAKE IT LAZY!
09:53:38 <det> When will the pattern of hackery end shapr, when?
09:58:01 <shapr> uh oh. evil strikes!
09:59:04 <shapr> bad things are happening to parts of the swedish internet 
10:00:21 <shapr> sheisa. on a stick.
10:01:06 <shapr> 60% packet loss between me and raven
10:01:49 <shapr> just when I was trying to setup gforge :-/
10:08:27 <cybermanco> hi
10:08:42 <cybermanco> where is the func ord in ghc?
10:12:49 <shapr> cybermanco: Data.Char probably
10:12:52 <shapr> hi det
10:12:53 <shapr> wassup?
10:14:35 <SyntaxNinja> shapr: I haven't installed it, no.
10:54:53 <det> shapr: oh, heya, just reopening epic4, got screwed up somehow
10:55:07 <det> shapr: still working on your email system?
10:56:12 <Marvin--> # TSTP exit status: GaveUp
10:56:13 <Marvin--> damn
10:58:16 <Marvin--> we talked about Fibonacci heaps today, that was pretty nifty
11:06:32 <shapr> det: the antispam server? sure
11:07:01 * Marvin-- drools a bit over the fibonacci heaps
11:10:02 <shapr> oh no, the infamous Thaddeus L. Olczyk is interested in darcs
11:10:10 <shapr> run away!
11:10:39 <Marvin--> oh dear
11:13:44 <det> darcs is ?
11:14:50 <shapr> det: http://abridgegame.org/darcs/
11:15:23 <shapr> darcs is spiffy. Thaddeus is the only person I've banned from this channel. Soon after that, he was banned from The Pragmatic Programmers mailing list as well.
11:15:53 <shapr> There are some people you really want to keep out of your favorite user community.
11:15:55 <Marvin--> he's something of a PITA
11:16:49 <SyntaxNinja> heh
11:17:01 <det> I reconize the name
11:18:19 <Marvin--> jeepers, a ninja!
11:18:36 <Riastradh> Watch out!  Don't drop a spoon or he'll use his Real Ultimate Power to flip out and kill you!
11:18:54 <shapr> det: really? from where?
11:19:28 <det> shapr: no idea
11:19:36 <det> shapr: mailing list probally
11:23:07 <det> shapr: do you develop lambdabot with darcs ?
11:23:16 <shapr> yup
11:24:36 <shapr> cool, top segfaulted.
11:25:18 <shapr> det: if you want to try darcs, debs are available.
11:25:49 <andersca> and rpms
11:29:58 <shapr> hej polli 
11:31:17 <polli> hej shapr, what's up?
11:31:34 <shapr> trying to set up gforge on my colo box...
11:31:56 <polli> colo box?
11:32:07 <shapr> colocated
11:32:36 <shapr> basically, darcs is nice, I'd like to try a tiny sourceforge like thing
11:32:42 <polli> oh
11:33:15 <andersca> gforge is pretty good
11:33:26 <shapr> there are quite a few small projects in haskell-libs.sf.net, and some of the Haskell luminaries asked me why haskell-libs isn't hosted on haskell.org
11:33:50 <shapr> so I thought if gforge is spiffy, I could ask them to set up, I'd be willing to admin gforge.haskell.org
11:34:56 <Marvin--> hm, how would you implement circular lists in haskell?
11:35:05 <shapr> with the credit card transform.
11:36:02 <Marvin--> man, I gotta get Okasaki's book
11:36:10 <Marvin--> stupid of me not to order it when I ordered the algorithm books
11:38:25 <shapr> Marvin--: have you got the Rabhi and Lapalm book?
11:38:28 <Marvin--> no
11:38:36 <shapr> I like it a lot.
11:38:49 <shapr> I haven't read Okasaki though.
11:39:38 <Marvin--> what's it called?
11:40:10 <Lor> Does okasaki's book have something essential that's not in his publicly available papers?
11:40:27 <harsha> shapr which editor do you use to create html pages?
11:40:49 <Marvin--> Lor: I don't remember, been a while since I read the papers :)
11:40:55 <Marvin--> (besides the fact that I really like having it in book form)
11:41:27 <shapr> harsha: I use emacs.
11:41:37 <Marvin--> and I use vim :)
11:41:45 <Marvin--> when I really really have to create html pages
11:41:56 <harsha> do you guys remember the tags?
11:42:03 <shapr> html tags? yes
11:42:09 <harsha> aah Ok
11:42:16 * Marvin-- shrugs
11:42:20 <Marvin--> what's another markup language?
11:42:21 <Lor> xml (and html) should be properly written as s-expressions.
11:42:40 <shapr> not in extreme detail, but psgml lets you interactively create legal SGML once it has a DTD
11:43:04 <shapr> so I can hit C-c C-a in a random html tag and see all the possible attributes it can have, and their legal values
11:43:24 <shapr> or I can hit another key combo to see all the tags that are legal to place in this spot in the file.
11:43:36 <shapr> and that works for html/xml/sgml
11:43:37 <harsha> hmm..
11:44:02 <shapr> emacs also does heavy duty validation via nsgmls
11:44:04 <andersca> does anyone know if HSGL is any good?
11:44:13 <shapr> andersca: what is it?
11:44:21 <harsha> but am not very familiar with the html tags.. just know a few handful
11:45:46 <andersca> shapr: isn't that the opengl binding for haskell
11:47:25 <shapr> HOpenGL?
11:47:41 <shapr> that's the one I've heard of...
11:47:44 <shapr> is there another?
11:50:13 <andersca> ah, that one
11:50:14 <andersca> sorry
12:02:51 <shapr> I vaguely recally hearing of a second haskell opengl binding...
12:13:55 <Marvin--> dang, Eprover 0.7 can prove this, Eprover 0.8 doesn't seem to be able
13:31:20 <Tomasso> hey, can anyone tell me if it is posible to pattern match in the following way?
13:31:30 <Tomasso> (\Mina _ -> True)
13:31:47 <shapr> sure
13:31:52 <Tomasso> hmmh i mean if it is posible pattern matching using lambda notation
13:32:04 <andersca> except that you'll get an error instead of false if the type isn't Mina
13:32:19 <Tomasso> shapr: and how do you contemplate other cases?
13:33:35 <Tomasso> for example if the type of mina = Mina .. | Nami ...
13:34:10 <Tomasso> (\Mina _ -> True)(\Nami _ -> False) ?
13:34:15 <Tomasso> or altogheter..
13:36:13 <andersca> Tomasso: you'll have to use case
13:36:35 <andersca> (\x -> case x of (Mina _) -> True; otherwise -> False
13:36:39 <andersca> dunno if you can write ; there
13:37:12 <Tomasso> hmm Ok
13:37:28 <Tomasso> Thank You
14:29:35 <raver> hi
15:37:55 <raver> gatecrasher_ do you know birmingham?
15:37:58 <raver> ;)
15:39:27 <gatecrasher_> hehe
15:39:39 <gatecrasher_> I am brazilian
15:39:42 <gatecrasher_> nope
15:39:46 <raver> i saw
15:39:53 <gatecrasher_> just know cambridge brighton and london
15:40:33 <raver> then you know what's the gatecrasher party?
15:41:36 <gatecrasher_> yeah kind of
15:41:42 <raver> this saturday will take place
15:41:50 <raver> 40 pounds...:/
15:41:55 <gatecrasher_> what it really is?
15:42:09 <gatecrasher_> paul oakenfold stuff?
15:42:14 <raver> mmm..
15:42:16 <gatecrasher_> john digweed?
15:42:22 <raver> ooohh...
15:42:25 <gatecrasher_> live on birmingham
15:42:25 <raver> better
15:42:30 <gatecrasher_> hallucinogen
15:42:34 <gatecrasher_> skazi
15:42:37 <raver> paul van dyck
15:42:43 <raver> tiësto
15:42:46 <gatecrasher_> slinky wizard, parasense, 
15:42:47 <raver> dave calrke
15:42:53 <raver> green velvet
15:42:56 <raver> :)
15:43:01 <raver> and so on..
15:43:02 <gatecrasher_> green velvet?
15:43:06 <raver> yeah
15:43:09 <gatecrasher_> i ve never heard about
15:43:13 <raver> buf
15:43:13 <gatecrasher_> cool one?
15:43:20 <raver> sure
15:43:26 <gatecrasher_> dave carlke?
15:43:32 <gatecrasher_> or dave calrke?
15:43:47 <raver> dave clarke sorry
15:44:16 <gatecrasher_> what kind of sound?
15:44:20 <raver> techno
15:44:27 <gatecrasher_> which one is good on chill out?
15:44:52 <raver> nobody...
15:44:54 <raver> lol
15:45:06 <gatecrasher_> ?
15:45:07 <raver> it's a trance&techno festival
15:45:11 <raver> :)
15:45:58 <gatecrasher_> I know
15:46:09 <gatecrasher_> what indian groups are good on trance?
15:46:50 <raver> deep dish it's good
15:47:10 <gatecrasher_> deep dish i'll try to hear
15:47:25 <raver> cool
16:11:06 <Leimy_> is it possible/portable to use Haskell's import function on a variable of sorts?
16:11:38 <Leimy_> or is that a compile-time only thing and not dynamic?
16:13:51 <dark> I think the import statement takes only literals.
16:21:01 <Riastradh> It's purely compile-time.
16:21:45 <Leimy_> Riastradh: thanks
16:21:58 <dark> Isn't everything other than IO actions compile-time? :-)
16:22:26 <Riastradh> Module-related things are strictly _before_ run-time; it specifies stuff about how to interpret (in the literal meaning) the code in the module; the code's meaning would change if you could evaluate module metadata at run-time.
16:24:35 <dark> Hmm, even stuff like operator precedence could change :)
16:37:46 <Leimy_> Riastradh: so the import itself doesn't happen at runtime... but at compile time
16:37:53 <Riastradh> Yes.
16:38:07 <Leimy_> hmmm
16:41:00 <Pseudonym> I love Amazon.
16:41:16 <Smerdyakov> I love LIBRARIES!
16:41:23 <Pseudonym> Apparently those who are interested in a book called "Portable Shell Programming" may also be interested in a portable acoustic shell.
16:50:07 <_Aether> makes sense
17:36:22 <skew> Hmm - has anyboded successfully embedded a Haskell interpreter?
17:36:48 <skew> I've been trying to find and read stuff about the HEP or RTS or whatever they are calling it these days
17:36:56 <Leimy_> I've been wondering that too :)
17:37:25 <skew> But most of it claims to be stale or is stale, and I haven't found anything that looks like a nice API for loading and compiling code while browing the GHC sourse
17:38:36 <ddarius> GHC isn't an interpreter and is not exactly something one would want to embed into a program.  Hugs has a C interface that is at least a start.
17:40:20 <skew> ddarius: I'm thinking more being able to compile new Haskell at runtime (at least to bytecode), and having a nice API for getting information / exporting functions and stuff
17:42:49 <skew> What about method constraints. Are they planned for implementation?
18:07:34 <Leimy_> So I am going through this haskell tutorial and I am hitting user datatypes with multiple constructors
18:07:41 <Leimy_> and I am quite confused :)
18:08:09 <Leimy_> basically it wants me to define a type called Tuple which can have four different items all of different types
18:08:12 <Leimy_> so I said:
18:08:21 <Leimy_> data Tuple  a b c d = One a
18:08:26 <Leimy_> | Two a b
18:08:31 <Leimy_> | Three a b c
18:08:36 <Leimy_> | Four a b c d
18:08:40 <Leimy_> does that make sense?
18:08:46 <skew> sure.
18:08:51 <Pseudonym> Yes, though there's an offside error.
18:08:56 <skew> It might not be whatyou want
18:09:01 <Leimy_> Pseudonym: by spacing?
18:09:05 * Pseudonym nods
18:09:12 <Leimy_> Yeah... IRC client limitation :)
18:09:18 <Leimy_> tab didn't do it :)
18:09:23 <Pseudonym> Yep, just thought I'd mention it.
18:09:30 <skew> That data type has four constructors,
18:09:31 <Leimy_> Pseudonym: I appreciate it... :)
18:09:37 <Leimy_> skew: I wanted 4 constructors
18:09:44 <skew> so it's more like a tuple of up to four arguments
18:09:45 <Leimy_> so it doesn't have to have all 4 types
18:09:58 <Leimy_> skew: that's what I want
18:10:03 <Leimy_> I didn't describe it well
18:10:04 <skew> but you might have problems with polymorphism in the types that you don't use in a constructor
18:10:27 <skew> like (show (One True)) will probably complain about a missing show intsnace for Tuple Bool a b c
18:10:59 <Pseudonym> Well, there isn't actually a deriving (Show) here.
18:11:09 <skew> Is the GHC compilation mangager in any package? I want to use CompManager
18:11:33 <skew> Psedonym: Yeah, but that sort of thing could happen in general
18:11:42 <Pseudonym> Yeah, it could.
18:13:24 <Leimy_> I would like to know how to use this type I've created?
18:13:38 <Pseudonym> First type this at the command line:
18:13:39 <Leimy_> Do I now do things like tuple1 (One a) = a
18:13:41 <Pseudonym> :t Two
18:13:47 <Pseudonym> or :t One
18:13:55 <Leimy_> sure
18:14:20 <skew> Or you could define the data type with field names:
18:14:54 <skew> data Triple a b c = One {triple1 :: a} | Two {triple1 :: a, triple2 :: b} | Three {triple1 :: a, triple2 :: b, triple3 :: c}
18:15:24 <skew> Hmm - why is this a syntax error?
18:15:26 <skew> data Tuple a b c d = One a
18:15:26 <skew>     | Two a b
18:15:26 <skew>     | Three a b c
18:15:26 <skew>     | Four a b c d 
18:15:27 <skew>       (deriving Show)
18:15:29 <Leimy_> haven't seen that in the tutorial yet... but I like it :)
18:16:20 <skew> Oh, misparenthesized deriving clause.
18:16:24 <Pseudonym> Right.
18:17:03 <skew> now that GHCi is happy, we can see all sorts of thinkgs like
18:17:04 <skew> *Main> show (Three True "a" 'c')
18:17:04 <skew> Ambiguous type variable `d' in the top-level constraint:
18:17:06 <skew>   `Show d' arising from use of `show' at <interactive>:1
18:17:10 <skew> and
18:17:52 <Leimy_> yeah... but the cool thing is this works... and its what I wanted to have work:
18:17:53 <Leimy_>  tuple1 (Four  1 'c' "Three" (Two 1 "two"))
18:17:58 <dark> You might have to write your own Show instance :)
18:18:00 <Leimy_> tuple1 giving back the first element
18:18:20 <skew> on the other hand,
18:18:21 <skew> *Main> :t [One True, Two False 'c']
18:18:21 <Leimy_> tuple1 (One a) = a
18:18:21 <Leimy_> tuple1 (Two a b) = a
18:18:21 <Leimy_> tuple1 (Three a b c) = a
18:18:21 <Leimy_> tuple1 (Four a b c d) = a
18:18:22 <skew> [One True, Two False 'c'] :: forall c d. [Tuple Bool Char c d]
18:19:01 <Leimy_> ooh... that's cool
18:19:05 <Leimy_> if somehow knew it was a tuple?
18:19:11 <Leimy_> er Tuple
18:19:22 <Leimy_> oh... nevermind :)
18:19:23 <Leimy_> One 
18:19:25 <Leimy_> and Two
18:19:32 * Leimy_ shouldn't drink beer and program
18:19:37 <skew> Yeah. and polymorphic in the type not mentioned
18:20:29 <skew> You can also do it with fields:
18:20:34 <skew> data Tuple a b c d = One {triple1 :: a}
18:20:34 <skew>     | Two {triple1 :: a, triple2 :: b}
18:20:34 <skew>     | Three {triple1 :: a, triple2 :: b, triple3 :: c}
18:20:34 <skew>     | Four {triple1 :: a, triple2 ::  b, triple3 :: c, triple4 :: d} 
18:20:34 <skew>       deriving Show
18:20:42 <Pseudonym>  /* drunk.. fix later */
18:20:56 <Leimy_> Pseudonym: hehe
18:21:13 <skew> *Main> triple1 (Three 'x' True "blah")
18:21:13 <skew> 'x'
18:21:13 <skew> *Main> triple1 (One 'x')
18:21:13 <skew> 'x'
18:21:13 <skew> *Main> triple1 (Two True "c")
18:21:14 <skew> True
18:21:16 <skew> *Main> triple1 (Three "blah" False 11)
18:21:18 <skew> "blah"
18:21:19 <Leimy_> skew: you are probably about 10 pages ahead of my skill level in this tutorial :)
18:21:20 <skew> *
18:21:51 <skew> Glad to help
18:21:56 <Leimy_> hehe :)
18:22:10 <Leimy_> I appreciate it and all... but I am just trying to complete this one excercise so I can understand this step.
18:22:41 <Leimy_> Its going to involve Maybe to do things like tuple2 [gets the second element] when the constructor is One
18:22:48 <Leimy_> so it can return Nothing
18:23:25 <skew> Hmm. The GHC stuff doesn't seem to be part of any packages.
18:23:35 <skew> The compiler interface from CompilationManager that is
18:23:52 <Leimy_> tuple1 :: (a -> Tuple) -> Maybe a
18:23:52 <Leimy_> tuple1 (One a) = Just a
18:23:52 <Leimy_> tuple1 (Two a b) =  Just a
18:23:52 <Leimy_> tuple1 (Three a b c) = Just a
18:23:52 <Leimy_> tuple1 (Four a b c d) = Just a
18:23:55 <Leimy_> what's wrong with that
18:24:12 <skew> the type
18:24:20 <Leimy_> the Tuple part?
18:24:32 <Leimy_> what should the type be if it works on all Tuples?
18:24:49 <skew> Well, the first argument is a tuple not a fuction
18:24:57 <Leimy_> oops
18:25:23 <Leimy_> I accidentally cut and pasted from a function that took a predicate :)
18:25:24 <skew> And Tuple needs four type arguments to be a type. Plain tuple is a type constructor of kind * -> * -> * -> * -> * (four arguments)
18:25:24 <Leimy_> doh!
18:26:01 <skew> You should have gotten an error something like "can't match type Tuple a b c d" with "a -> Tuple"
18:26:14 <Leimy_> Kind error: `Tuple' is not applied to enough type arguments
18:26:14 <Leimy_>     In the type: forall a. a -> Tuple -> Maybe a
18:26:14 <Leimy_>     While checking the type signature for `tuple1'
18:26:19 <Leimy_> that's the error in GHC
18:26:20 <skew> or maybe "type constructor Tuple not applied to enough arguments"
18:26:26 <Leimy_> hehe
18:26:44 <skew> Hmm. That should really print the kinds
18:27:10 <skew> There's an implicit forall binding any free type variables you mention in a type, so you can just say Tuple a b c d -> Maybe a
18:27:49 <Leimy_> cool
18:28:29 <Leimy_> :t tuple1
18:28:30 <Leimy_> tuple1 :: forall a d c b. Tuple a b c d -> Maybe a
18:28:38 <Leimy_> goofy ordering in the forall now that its fixed :)
18:28:53 <Leimy_> the interesting thing in this case is I really don't need Maybe a
18:29:00 <Leimy_> all Tuples have at least the first item
18:29:11 <skew> you should use it for all the extraction functions or none, for consistency
18:29:43 <Leimy_> sure
18:29:48 <Leimy_> stylistically :)
18:29:59 <Leimy_> can I now say "1::Tuple" ?
18:30:19 <Leimy_> Or just 1::One?
18:30:54 <skew> No, niether One nor Tuple are types
18:31:14 <Leimy_> ah
18:31:20 <skew> And even if they were the types wouldn't match up
18:31:20 <Leimy_> so that's for built-ins only?
18:31:41 <skew> No, it's perfectly fine to say stuff like (One 'x')::Tuple Char String Int Bool
18:31:55 <skew> It's just that the only way to make a Tuple is with one of the constructors.
18:32:09 <Leimy_> I see
18:32:47 <skew> Well, applying any function that makes tuples
18:33:04 <skew> You can't just randomly cast around values, at least not with reasonable results
18:33:15 <Leimy_> ok
18:33:31 <Leimy_> so ... now I have a function that make's Maybe's
18:33:41 <Leimy_> using Just a or Nothing
18:33:48 <Leimy_> how to get the a out of the Maybe? :)
18:34:01 <skew> You can do evil things with typeclasses to claim that Tuples are a kind of number, in which cas you could get 1 to parse as a tuple, but that's pretty evil
18:34:11 <skew> data Maybe a = Nothing | Just a
18:34:23 <skew> plenty of functions for working on it in Data.Maybe, or you can just pattern match
18:43:25 <Leimy_> I don't think I have the correct solution here
18:43:39 <Leimy_> I can't say "tuple2 (One 1)"
18:43:54 <Leimy_> Ambiguous type variable `b' in the top-level constraint:
18:43:54 <Leimy_>   `Show b' arising from use of `print' at <No locn>
18:43:54 <skew> Why not?
18:44:05 <Leimy_> tuple2 :: Tuple a b c d ->  Maybe b
18:44:05 <Leimy_> tuple2 (One a) = Nothing
18:44:05 <Leimy_> tuple2 (Two a b) = Just b
18:44:05 <Leimy_> tuple2 (Three a b c) = Just b
18:44:05 <Leimy_> tuple2 (Four a b c d) = Just b
18:44:12 <skew> Ah - the return value has type Maybe b, for unknown v.
18:44:57 <Leimy_> *Main> :t tuple2
18:44:57 <Leimy_> tuple2 :: forall b d c a. Tuple a b c d -> Maybe b
18:45:01 <Leimy_> that is odd too
18:45:06 <skew> The value happens to be Nothing so it really does make sense to print it, but the typesystem can't represent (yet) that the string for Nothing doesn't depend on the argument to maybe
18:45:52 <skew> What's odd about that?
18:46:11 <Leimy_> *Main> :t tuple3
18:46:11 <Leimy_> tuple3 :: forall c d b a. Tuple a b c d -> Maybe c
18:46:14 <Leimy_> c is first there
18:46:24 <Leimy_> tuple3 :: Tuple a b c d -> Maybe c
18:46:32 <Leimy_> and that's not how I wrote the type for that function :)
18:46:49 <Leimy_> I guess it is
18:47:03 <Leimy_> I just don't understand why forall is reordered
18:49:41 <skew> I don't think it really makes a difference
18:49:47 <Leimy_> probably not :)
18:49:57 * skew heads off to dinner
18:49:58 <Leimy_> I just felt "snuck behind" :)
18:50:03 <Leimy_> skew thanks!
19:52:28 <seafood> Igloo: You around?
19:52:57 <Igloo> Yup
19:53:09 <seafood> Got a question for you about changing THSyntax.hs
19:53:38 <seafood> Igloo: I want to actually modify the data types for expressions and types
19:54:05 <seafood> Igloo: Apart from THSyntax.hs and THLib.hs and making necessary modifications in DsMeta.hs, what other files do I have to modify?
19:55:39 <Igloo> I haven't really looked since the most recent changes, but you'll need to change the datatypes themselves, the prettyprinter, the smart constructors, the conversions in each direction (used to be Convert.*hs and DsMeta.hs IIRC) and I think that's it
19:57:43 <seafood> Igloo: Thanks
19:58:15 <Igloo> Is this for unboxed tuples?
19:58:24 <seafood> Igloo: You guessed it.
20:09:24 <`john> are the anything suchs as lisp type macros in Haskell? or what's the nearest equivilent to it? if any...
20:24:26 <Riastradh> `john, the nearest equivalent is Template Haskell, which is less macros and more simple metaprogramming.  (and it's ugly, so it's not a very good substitute for macros)
20:24:50 <dark> Those sound like fighting words!
20:25:34 <`john> oh
20:32:23 <`john> Riastradh, great thanks.
20:32:38 <Riastradh> Just continue using Lisp!
20:32:41 * Riastradh ducks.
20:32:53 <`john> ;)
20:32:55 <`john> :P
20:33:49 <`john> for all intents and purposes I don't think that lisp will ever go mainstream.
20:34:46 <`john> actually it has, it's called xml.
20:45:41 <Pseudonym> No, nobody will ever write a _real_ application in Lisp.
20:45:45 <Pseudonym> :-)
20:47:57 <Leimy_> loaded comments
21:32:36 <Cale> heh
21:50:39 * Leimy_ is away: zzzzzzzzz
23:07:47 * shapr boings
23:08:03 <Pseudonym> G'day.  I was just leaving.
23:08:12 <Pseudonym> Odd timing.
23:08:54 <shapr> have a nice evening...
23:09:13 <Pseudonym> I'll try.  Looks like it's going to be warm.
23:12:48 <shapr> I wish the same were true here.
23:15:49 <Pseudonym> Nytol.
23:15:54 <Pseudonym> Must dash and all.
23:15:54 <shapr> yay, someone tried to send spam from raven and was slapped down.
23:18:18 <shapr> good morning #haskell
23:18:40 <blackdog> hey shapr - did you pinch your nick from the Sandman?
23:18:44 <blackdog> oops, gotta go
23:18:49 <shapr> no, and cya
23:20:11 <shapr> looks like the spammer is in kentucky
23:43:38 <shapr> @yow
23:43:39 <lambdabot> Just imagine you're entering a state-of-the-art CAR WASH!!
23:43:44 <shapr> hi joel_ 
23:48:18 <det> @eval a
