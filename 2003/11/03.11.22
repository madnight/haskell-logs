02:27:18 <shapr> @yow
02:27:19 <lambdabot> When this load is DONE I think I'll wash it AGAIN..
02:28:54 <Jad> shapr: you abandoned erights ?
02:32:27 <shapr> Jad: no, just no autojoin today
02:32:32 <shapr> I'm playing with my irc settings
02:33:11 <shapr> hi anth
02:48:18 <shapr> hi blacksheep, any relation to blackdog?
02:48:34 <blacksheep> shrimpx: no!
02:49:16 <blacksheep> hey! could someone point me a howto to calling c functions from haskell (using hugs)?
02:49:32 <blacksheep> if it's possible...
03:06:05 <shapr> blacksheep: the FFI maybe?
03:07:26 <blacksheep> shapr: i am a haskell newbie, could you point me to an example... I would like to call some C functions from an haskell program, how should i call them and how should i compile and link the both files?
03:07:56 <shapr> I've never done it myself, so I don't know.
03:08:07 <shapr> but if you search for FFI and haskell on the web, I'm sure you can find stuff about it.
03:08:14 <shapr> I've seen some info on the HaWiki
03:08:36 <Jad> shapr: shouldn`t we add the hawiki tutorials page to the topic ?
03:08:42 <shapr> hmm
03:08:51 <blacksheep> searching in google, gives me lots of pdf files :( i would like a simple example
03:08:51 <shapr> blacksheep: http://www.haskell.org/hawiki/FfiTutorial
03:09:17 <shapr> Lunar^ just wrote that FFI Tutorial page, it has a simple example and how to compile it
03:09:35 <blacksheep> shapr:  that's great! but i would prefer to use hugs...
03:09:54 <blacksheep> anyway, it's great for a start
03:12:02 <shapr> well, credit to Lunar^ for writing it.
03:17:16 <shapr> hoi kosmikus|away
03:17:19 <shapr> er kosmikus
03:41:08 <blacksheep> thx! bye now
03:49:55 <Lunar^> shapr: neat it's usefull
04:01:45 <TripleDES> hi :)
06:25:16 <kosmikus> hi shapr; strange, irssi didn't highlight your greeting ...
06:38:41 <blacksheep> hi! sorry, for the dumb question, but what's the keyword to include another haskell file in a haskell file?
06:39:36 <blacksheep> i found it: import ... sorry
07:38:29 <TripleDES> re
08:02:56 <Jad> re
08:03:17 <dark> Greetingses
08:05:49 <Jad> ooops!!
08:05:54 <Jad> sorry for version guys
08:06:46 <Jad> Saklawi
09:27:03 <Lor> Hm, there are no implementations available of either the Cheney/Hinze or the Baas/Swierstra Dynamic systems?
09:28:06 <Lor> Funny. They have written those and presented them in papers, but don't provide the actual code in a convenient form.
10:35:41 <Lor> Hm, there's something fundamentally wrong about having generative types in a pure language.
10:36:27 <Lor> Actually, this again is an argument for having Claessen's impure Refs in the language.
10:36:47 <Lor> They are essentially the term-level equivalent of generative types.
10:37:14 <ibid> generative types?
10:38:10 <Lor> Non-structural types. "New" types.
10:38:48 <Lor> eg. in Haskell, data Pair a b = Pair a b, or newtype Pair a b = Pair (a, b) are both structurally equivalent to (a, b), but still distinct from that.
10:39:07 <Lor> (Never mind the additional bottom when using "data")
10:39:08 <ibid> hmm
10:39:16 <SyntaxLaptop> hey TripleDES
10:39:20 <ibid> and why is it wrong?
10:39:33 <TripleDES> hi _
10:39:35 <TripleDES> hi SyntaxLaptop 
10:39:49 <Lor> Well, because.
10:40:10 <Lor> It means that you can't deal with types in a "pure" fashion, looking only at their structures.
10:40:27 <Smerdyakov> I think you'll have a hard time showing how that is the same "pure" used to described Haskell.
10:40:40 <ibid> Lor: hum, i don't think there is anything particularly "pure" about structural equucalence
10:40:47 <ibid> though it's cool
10:41:00 <ibid> but i would include constructor names as part of the structure
10:41:04 <Lor> Yes there is. At a term level, the equivalent of generative types would be having a term that reduces to a value that is distinct from all other values.
10:41:05 <ibid> in determining equivalence
10:41:28 <ibid> Lor: but at term level Pair a b and (a, b) are distinct values
10:41:55 <ibid> (and they could be even if the language was statically untyped)
10:42:22 <Lor> Well, they have the same representation.
10:42:37 <ibid> they maight have
10:42:42 <ibid> or they might not
10:42:51 <Lor> The problem becomes apparent when you try to lower the type language back to the term language, as is done in implementations of Dynamic.
10:43:17 <Lor> You can create a datatype that replicates the _structure_ of primitive types, built from unit, void, + and *.
10:43:21 <ibid> i find very useful to distinguish values with a tag (the constructor)
10:43:29 <Lor> But when you need to have representations for _named_ types, you have to resort to hacks.
10:43:42 <ibid> well yeah, name equivalence sucks
10:44:02 <ibid> but you can have constructors as tags in structural equivalence as well
10:44:05 <Lor> The problem is that it's just a _convention_, that if two types have the same name, they have the same structure.
10:44:20 <Lor> GHC's current dynamics thingy, and _also_ the Cheney/Hinze system depend on that convention.
10:44:41 <Lor> You can break the system by just creating a typerep with the same name as some other existing type.
10:47:32 <ibid> (did i mention that i got peirce's book and have already done an initial reading pass over it:)
10:48:03 <Lor> Cool.
10:48:09 <Lor> Apparently there's a followup in the works.
10:49:05 <ibid> i have also already talked with the processors. i'll get ovs for reading it
10:49:29 * jasonw_ would rather watch the other two games, probably.
10:50:54 <ibid> professor
10:50:58 <ibid> actually :)
10:51:58 <Lor> Do you have to do a test? :)
10:52:03 <ibid> no
10:52:06 <Smerdyakov> ovs = ?
10:52:07 <ibid> a "referaatti"
10:52:39 <ibid> Smerdyakov: opintoviikkoja (study weeks or credits, 1 ov is theoretically equivalent to 40 hours of work)
10:53:13 <Smerdyakov> A-ha.
10:53:28 <Lor> Golly, wonder how many credits worth of papers on programming language theory I've read for my leisure...
10:53:47 <Smerdyakov> Six quinTILLION.
10:54:26 <ibid> Lor: also have asked the libary to get a copy of peirce's book
10:54:54 <shapr> I like pierce's book.
10:54:58 <Lor> Smerdyakov, sounds about right. :)
10:55:03 <Smerdyakov> He has more than one, you know.
10:55:23 <Lor> Yeah, there's category theory for computer scientists, and attapl is forthcoming.
10:55:23 <shapr> one is most famous though
10:55:37 <shapr> attack of the types and programming languages?
10:55:47 <Lor> "advanced topics in"
10:56:22 <shapr> ah
10:56:47 <ibid> tipl (or was it tapl?) is already advanced :)
10:57:05 * Smerdyakov laughs.
10:57:10 <Lor> Nah, it's just the basics.
10:57:19 <Smerdyakov> I don't agree, since most of that is covered in undergraduate PL semantics courses.
10:57:37 <Lor> Yeah, in more civilized countries.
10:58:07 <Lor> Hereabouts an undergrad PL semantics course will just have something about loop invariants.
10:58:23 <ibid> hereabouts there are no undergrad pl semantics courses
10:58:34 <Smerdyakov> They're are in the USA, as well.
10:58:49 <Smerdyakov> I went to CMU, one of the small amount of schools with courses like that.
10:58:51 <ibid> my pl course is a grad course (i mean, between bsc and msc)
10:59:08 <Smerdyakov> And all the maybe 5 others in the country use the notes from the class I took. :D
10:59:33 <Lor> Smerdyakov, whose course was it?
10:59:44 <Smerdyakov> Bob Harper.
10:59:54 <ibid> Smerdyakov: if you read the book's preface, it says that the book can be primarily used as a textbook for an advanced (or second) course on pls. or parts of it can be used in a basic pl course
10:59:54 <shapr> I wonder if Lule√• teaches a type theory course.
10:59:57 <Smerdyakov> Sometimes taught by the usual suspects as well: Frenk Pfenning, Karl Crary, Peter Lee.
11:00:45 <shapr> SyntaxLaptop: yo, you awake?
11:01:01 <Smerdyakov> ibid, but it's all easy stuff. :P
11:01:11 <ibid> Smerdyakov: that is true :)
11:01:25 <ibid> Smerdyakov: assuming you already know at least one pl semantics course worth of stuff :)
11:01:34 <Smerdyakov> No. It's easy in any case.
11:01:39 <SyntaxLaptop> hey shapr I sure am.
11:01:42 <Smerdyakov> If you can program worth your larynx.
11:01:44 * SyntaxLaptop is not watching ohio state football
11:01:48 <Lor> Harper is pretty cool. He flamed one young presenter pretty thoroughly, and afterwards explained calmly to some interested young folks what was really wrong with the paper.
11:01:58 <shapr> SyntaxLaptop: you think I should install SF on raven? if so, anything else I should install?
11:02:06 <ibid> Smerdyakov: do you have any concrete proof (ie. somebody with that background actually finding the book easy?)
11:02:08 <Smerdyakov> Lor, this was the last ICFP?
11:02:11 <Lor> Yeah.
11:02:27 <Smerdyakov> ibid, well, I found the material easy with that background. Not with that book, though it was suggested reading. :)
11:02:27 <ibid> Lor: what was wrong?
11:02:43 <ibid> Smerdyakov: you are special, you don't count :)
11:02:49 <SyntaxLaptop> shapr: I'm very torn; you should install bugzilla, I think.
11:02:54 <shapr> awright
11:02:57 <ibid> (an aswer i usually get myself in this kind of discussions:)
11:03:08 <SyntaxLaptop> if we just run sf, I don't know what the advantage to not using sf.com is
11:03:13 <Lor> I think it was _mostly_ a matter of taste, he didn't think the approach was very sensible.
11:03:23 <Lor> I don't recall if there was some actual technical problem with it.
11:03:27 <Smerdyakov> Lor, he's very opinionated.
11:03:39 <Smerdyakov> Lor, scary to work with at times. (Which I did)
11:03:58 <Lor> Yeah, he told me about his history with Matthias Felleisen and their endless arguments about types.
11:04:05 <shapr> ick, bugzilla requires mysql
11:04:08 <shapr> y0 Cale 
11:04:44 <SyntaxLaptop> shapr: ja
11:04:45 <Cale> hey
11:04:51 <SyntaxLaptop> shapr: doesn't sf require ad atabase?
11:04:59 <SyntaxLaptop> techinically of course bugzilla can work w/ postgres too
11:05:22 <shapr> I suspect SF requires many things
11:05:55 <shapr> yah, apache, php4, postgresql, bind9, proftpd,
11:05:56 <shapr> etc
11:08:25 <Igloo> I'd have thought some of that ought to be just recommends
11:08:40 <Igloo> bind9 I don't get at all
11:08:59 <shapr> so people can make their own foo.projects.haskell.org ?
11:09:22 <Igloo> But that's totally independent of the sf functionality
11:10:08 <Lor> Uh? Is someone going to put up a sourceforge for haskell projects?
11:10:13 * Igloo boggles at elvis | nvi | vim
11:10:32 <shapr> Lor: quite possibly
11:10:45 <Lor> What's wrong with the real sourceforge or savannah?
11:10:52 <Smerdyakov> For no reason other than that it makes shapr feel special :P
11:11:03 <shapr> Smerdyakov: funny, but not true :-)
11:11:15 <Smerdyakov> shapr, OK, then what is your reason?
11:12:00 <shapr> Claus asked me why haskell-libs.sf.net wasn't on www.haskell.org, and he wanted a listing of the separate projects in the haskell-libs.sf.net cvs
11:12:32 <Smerdyakov> So? Why does this warrant more than a list of SF project names/links on a wiki?
11:12:37 <Lor> Hm, LICS 2004 is in Turku...
11:12:53 <shapr> Smerdyakov: it may not, or it might warrant more.
11:12:54 <liw> LICS?
11:13:02 <Smerdyakov> shapr, and why would it warrant more?
11:13:04 <SyntaxLaptop> shapr: so you should use postgres instead of msql for buzlla
11:13:18 <shapr> part of the question is, how hard is it to install and admin the different systems, and if you build it, will they come?
11:13:23 <shapr> hi liw, long time no see.
11:13:25 <ibid> Lor: i am hoping to come up with something i can submit there
11:13:39 <Smerdyakov> shapr, that question is irrelevant if you can't demonstrate benefit from having your own duplication of the SF setup.
11:13:39 <ibid> :)
11:13:51 <liw> shapr, greetings
11:14:03 <shapr> liw: learning Haskell? have any questions?
11:14:10 <Lor> You know each other?
11:14:13 <Smerdyakov> shapr, so what benefits do you anticipate>
11:14:20 <liw> shapr, not learning Haskell at the moment, just hanging around
11:14:24 <shapr> ok
11:14:34 <liw> Lor, I've met shapr on #debian-fi
11:14:38 <SyntaxLaptop> Smerdyakov: shapr is aware of this; and in fact I said the same thing 10 minutes ago.
11:15:13 <Smerdyakov> SyntaxLaptop, yet he's still talking about it. It's rather bizarre if he has never thought of a single possible reason why his idea is worth exploring, yet he is still talking about it.
11:15:47 <SyntaxLaptop> Smerdyakov: you're right. he should shut up. shapr don't talk about it anymore!
11:15:52 <shapr> heh
11:16:00 <Smerdyakov> And he won't even respon to me.
11:16:24 * SyntaxLaptop wonders why sf is available as free software if everyone can just use the real sourceforge
11:16:27 <shapr> Smerdyakov: feel free to look at the logs from yesterday where SyntaxLaptop and I discussed it.
11:16:46 <Smerdyakov> shapr, you ought to be able to summarize one compelling reason in one line....
11:16:54 <shapr> Smerdyakov: you ought to be able to read logs too.
11:17:21 <Smerdyakov> It's much easier for you to type a line than for me to find logs and search through them.
11:18:03 <SyntaxLaptop> Smerdyakov: one reason: sorceforge is slow
11:18:19 <Smerdyakov> SyntaxLaptop, even with their hardware improvements?
11:18:26 <Lor> Agh. Someone just decided to start a war on comp.lang.ml: "ML is not an FPL; it is an imperative language with first-class functions."
11:18:44 <esap> lor: hehe
11:18:51 <SyntaxLaptop> Smerdyakov: what software improvements?
11:19:02 <Smerdyakov> My current spot check of sf.net shows that it is "fast as hell" by my standards. :)
11:19:03 <ibid> in my current paradigm system, ml is an imperative functional language
11:19:05 <ibid> :)
11:19:07 <Lor> "Among the reasons that ML is not an FPL are:  (1) side-effect based IO; (2) exceptions; (3) references; (4) eager evaluation."
11:19:22 <Smerdyakov> SyntaxLaptop, they upgraded their CVS servers to have about 5x as many of them, or something in that neighborhood. It's been in the e-mail newsletters.
11:19:37 <Lor> Apparently someone definition of "FPL" is "Haskell".
11:19:59 <Smerdyakov> Sourceforge was slow a few months ago because of its extreme popularity, but they upgraded things as appropriate to deal with them.
11:20:14 <Smerdyakov> These are people with a lot of community support and means to scale up to offer good service.
11:20:22 <SyntaxLaptop> Smerdyakov: can we run darcs on sf.net?
11:20:25 <ibid> Lor: no, there are people who have defined FPL as no side effects & lazy evaluation & first class functions even before haskell existed
11:20:25 <SyntaxLaptop> and / or arch?
11:20:52 <Lor> All right, but it's silly.
11:20:53 <Smerdyakov> SyntaxLaptop, is it in open source project?
11:20:58 <ibid> Lor: (judging from some papers dating before haskell)
11:21:02 <Smerdyakov> s/in/an
11:21:09 <Lor> Functional programming is more about the use of functions than about the lack of side effects.
11:21:23 <ibid> yeah
11:21:34 <ibid> i'd say there is no point in classifying languages
11:21:37 <SyntaxLaptop> Smerdyakov: darcs and arch are revision control systems.
11:21:49 <ibid> we should classify programming styles
11:22:22 <liw> detailed and precise classification is mostly a waste of time
11:22:29 <ibid> that is true as well
11:22:38 <Smerdyakov> SyntaxLaptop, if they are projects that release software under open source licenses, then you can host them on sf.net.
11:22:56 <SyntaxLaptop> not host them, I said "run" them.
11:23:05 <dark> There's also the even more popular alternative of having projects that don't release anything.
11:23:06 <Smerdyakov> Oh, got it.
11:23:12 <Smerdyakov> No.
11:23:37 <Smerdyakov> Sorry, I interpreted "darcs" as referring to a multi-person project that needs to be run, not software. :)
11:23:47 <SyntaxLaptop> right;
11:23:49 <Lor> "Popular" as in "widely used", not as in "widely liked", I think. :)
11:23:51 <dark> I think Debian's alioth server has been experimenting with alternative source control systems.
11:24:02 <SyntaxLaptop> dark: cool.
11:24:09 * SyntaxLaptop has been using arch lately. I like it a lot
11:24:13 <Smerdyakov> I think the reliability of sf.net ought to make up for any gripes you have with CVS, though.
11:24:33 <ibid> my current theory has two dimensions: declarative (no side effects) - imperative (side effectful); functional (centered around functions as data and abstraction mechanisms) - procedural (centered around subroutines as abstraction) - object-oriented (views the world as a set of communicating objects)
11:24:39 <SyntaxLaptop> haskell.org is pretty reliable
11:24:40 <liw> I should look at CVS replacements some day (but that will have to wait until I find a new editor for myself)
11:24:46 <ibid> and that's a theory of programming styles, not programming languages
11:25:17 <Smerdyakov> SyntaxLaptop, but it probably has nowhere near the infrastructure of sf.net.
11:25:20 <Lor> What's the essential difference between functions and procedures, if it's orthogonal to side effects?
11:25:47 <ibid> Lor: procedures are not data is my current theory :)
11:25:49 <Smerdyakov> SyntaxLaptop, if your concern is really the revision control system that you use, then sf.net might not be for you. But I'd be surprised if CVS is really inadequate for your needs.
11:26:11 <Lor> So functional=procedural+first class functions?
11:26:22 <ibid> perhaps :)
11:26:23 <SyntaxLaptop> Smerdyakov: I've used a lot of version control systems.  furthermore, there are reasons to use darcs beside its quality.
11:26:26 <ibid> i'm not sure
11:26:41 <ibid> Lor: that certainly characterizes correctly my current theory
11:26:48 <Smerdyakov> SyntaxLaptop, OK.
11:26:51 <SyntaxLaptop> Smerdyakov: I think that I've sufficiently justified testing out our own installation of sourceforge software.
11:27:02 <SyntaxLaptop> I haven't perhaps sufficiently justified moving to it
11:27:04 <Smerdyakov> SyntaxLaptop, yup. Too bad shapr couldn't do that. :D
11:27:05 <esap> ibid: I think there are two ways to view the world as a set of communicating objects. And both yield a different style.
11:27:15 <ibid> esap: oh?
11:27:27 <SyntaxLaptop> Smerdyakov: I think if you had asked the question more politely, he would have been glad to respond. just a guess.
11:27:39 <Smerdyakov> SyntaxLaptop, I didn't ask anything impolitely.
11:28:22 <esap> ibid: In one of them, communcation passes mostly _changes_ to data stored in objects. In another, the data is brought to the objects which describe changes.
11:28:57 <ibid> esap: they sound like things that are both traditionally classed as oo
11:29:05 <scharob> Hi shapr 
11:29:14 <SyntaxLaptop> Smerdyakov: I agree. you didn't ask an impolite question. I get the feeling that your comment about shapr having no other reason other than "feeling special" was intended to provoke annoyance.
11:29:29 <esap> ibid: well many things have been called OO.
11:29:30 <SyntaxLaptop> in which case, I think he's justified in ignoring your subsequent questions.
11:29:37 <ibid> esap: that is certainly true
11:30:08 <Smerdyakov> SyntaxLaptop, the rules of IRC allow anyone to say anything if it is suffixed with ":P"!
11:30:32 <SyntaxLaptop> if you say so :P
11:32:08 <esap> ibid: another problem perhaps with that division is that I think one should also consider 'changes to changes' etc, which this classification doesn't really do.
11:33:11 <ibid> esap: i'm mainly trying to make a sensible definition of those common terms. i'm not trying to invent a new classification
11:34:30 <esap> ibid: how does your classification handle logic programming, just as declarative?
11:35:01 * esap classifies logic programming as a type system.
11:35:02 <ibid> i had it in the second dimension along with functional etc, but i removed it
11:35:37 <ayrnieu> catFromSock :: Socket -> (String -> IO String) -> IO ()
11:35:37 <ayrnieu> catToSock :: Socket -> IO String -> IO ()
11:35:37 <ayrnieu> catToSock sock f = do s <- f
11:35:37 <ayrnieu>                       send sock $ s ++ "\r\n"
11:35:37 <ayrnieu>                       catToSock sock f
11:35:43 <ibid> if it goes to the functional dimension, i'd characterize it as viewing programming as theorem proving
11:36:12 <Lor> I think that "type system" is a _pragmatic_ concept: whether something is a type system or not depends on the _purpose_ it is used for.
11:36:13 * ayrnieu isn't entirely happy with that.
11:36:57 <Lor> Simply typed lambda calculus and natural deduction for propositional logic are essentially the same formal system. Still we think of them as different things, because we use them for different purposes.
11:37:06 <ayrnieu> also, (String -> IO ())
11:37:32 <ibid> more detailedly, relying on implicit unification of variables and implicit backtracking upon failure
11:37:57 <pimpbot5000> is anyone here familiar with how to rebind syntax with GHC?
11:38:09 <esap> lor: I think the difference has something to do with whether specifications or proofs are the focus of interest.
11:38:15 <ayrnieu> pimpbot - I don't understand 'rebind syntax', sorry.
11:38:25 <Lor> That's what I said, pretty much. :)
11:38:37 <ibid> i gave static typechecking as an example of an everyday formal method
11:38:43 <ayrnieu> and there's Erlang, which seems interested in neither.
11:38:45 <ibid> in my formal methods class yesterday
11:39:31 <pimpbot5000> hmm, well lets say i want to unfold a recursive function by 16 calls... is there a good example out on the web of how to do this?
11:40:41 <ayrnieu> pimpbot - take 16 . iterate ?
11:40:55 <ayrnieu> No, I suppose not.
11:41:18 <pimpbot5000> i mean like a pre compile transformation
11:41:42 <ayrnieu> pimpbot - I don't follow you, then.
11:41:47 <Lor> Why would you want to do that?
11:41:57 <pimpbot5000> it makes matrix operations very fast
11:41:58 <Lor> GHC ought to know when it is useful or not.
11:42:36 <pimpbot5000> would GHC unfold a state monad automatically?
11:44:06 <Lor> One can always hope. :)
11:44:30 <pimpbot5000> hmm...doesn't matter actually.  i need to tune these algorithms to certain base case sizes...that is, the base cases need to be sized right for cache
11:45:02 <dark> ghc does a lot.  Once I wrote a test program for my pathfinding algorithm, and I had to do tricks to stop it from running the whole algorithm at compile time.
11:45:09 <ayrnieu> map fst $ take 16 $ iterate fact (1, x) where fact (n, m) = (n*m, m-1)
11:46:26 <ayrnieu> (But that doesn't work, because a 'take' of more than (1, x) can provide will repeat once and then return zero)
11:46:52 <SyntaxLaptop> is anyone here in moscow, btw?
11:46:59 <ddarius> pimpbot5000: Igloo wrote a loop unrolling TH macro
11:47:27 <pimpbot5000> ah cool!
11:47:54 <pimpbot5000> igloo: are you around?
11:53:38 <Igloo> Yes - see http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/Fraskell/ (but it probably won't match whichever version of the TH datastructures you are using)
11:56:49 <pimpbot5000> you wrote fraskell?
11:57:01 <pimpbot5000> hehe ive already been looking at it
11:57:22 <Igloo> Cool  :-)
11:57:43 <pimpbot5000> ok so this is kind of a weird function im trying to unroll
11:57:57 <pimpbot5000> can i run it by you real quick?
11:59:28 <Igloo> OK
11:59:53 <pimpbot5000> what im doing here is a recursive matrix multiply
12:00:42 <pimpbot5000> the calls are low level, at the base case i read primitives from a C call
12:01:15 <Igloo> But a pure C call presumably?
12:01:20 <pimpbot5000> yes
12:01:48 <pimpbot5000> the return type is ST s (DblMtx s)
12:02:50 <pimpbot5000> but there are a fixed number of recursions, so i think it will be possible to unroll....maybe by hand if i have to
12:03:18 <pimpbot5000> first off, how do i invoke the 'unroll' function?
12:04:27 <Igloo> You'll want to alter it, and probably add simplifying cases too. I think it takes an argument number, an initial value for that argument, a maximum unroll depth and the function code
12:04:34 <Igloo> (in some order)
12:04:56 <pimpbot5000> ok, but what im not sure of is where and when to apply it
12:05:37 <pimpbot5000> is there an example of unroll somewhere?  i can't seem to find one in the Fraskell tarball
12:05:38 <Igloo> Does the use in MB.lhs not make it clear?
12:05:50 <pimpbot5000> ok one sec, i might have missed that
12:06:04 <pimpbot5000> hmm
12:06:11 <pimpbot5000> where is MB.lhs located?
12:06:28 <pimpbot5000> Mandelbrot.lhs?
12:06:34 <Igloo> Oh, probably that, yeah
12:07:03 <Igloo> It'll be whichever file contains "TEMPLATE_HASKELL"  :-)
12:07:30 <pimpbot5000> ok cool!  this should be enough to go with
12:07:38 <pimpbot5000> so you're a phd student at oxford?
12:07:56 <Igloo> Yup
12:08:32 <pimpbot5000> cool, mainly working on PL stuff?
12:09:04 <Igloo> In the Prog. Research Tools Group, doing TH stuff, yeah
12:09:17 <pimpbot5000> Amr Sabry is at oxford now...in the MS part i think
12:09:37 <pimpbot5000> he was my research advisor for a semester, really cool guy
12:10:20 <pimpbot5000> i think he's working with Simon Peyton Jones
12:10:24 <Igloo> MS part? I vaguely recognise the name
12:10:29 <pimpbot5000> microsoft
12:28:41 <Lor> It's also a good way never to get a project started in the first place.
12:33:01 <dark> Did you ever read Alan Cox's "Cathedrals, Bazaars and the Town Council"?
12:34:27 <ayrnieu> Lor - what's also a good way?
12:35:04 <Riastradh> Lor, perfectionism.
12:35:06 <Riastradh> Er.
12:35:09 <Riastradh> s/Lor/ayrnieu/1
12:40:53 <ayrnieu> dark - interesting article.
12:41:15 <ayrnieu> Riastradh - ah, the signoff.
12:50:05 <Lor> Bah, I remember the time when I very muched wished for the linux 8086 project to reach a usable state so I could use linux on an old toshiba laptop.
12:50:18 <Lor> And Cox calls it a "pointless exercise".
12:52:00 <ayrnieu> mm, I like that hugs starts so quickly.
13:03:51 <emu> the catheter and the bizarre
13:16:37 <det> Does anyone here have some advice for the best place to look for buying a used car? :)
13:19:49 <emu> #usedcars
13:20:14 <Cale> No, but there's are some good online used cdr shops.
13:21:49 <det> Cale: how pointless!
13:22:30 <Cale> What, a used cdr?
13:24:15 <Cale> (car '(1 2 3 4 5)) -> 1;  (cdr '(1 2 3 4 5)) -> (2 3 4 5)
13:29:22 <det> oh sure, if you want an inferior American^Wmutable cdr!
13:42:55 <emu> your cdr can hold many different types
13:47:35 <dark> Not in Haskell.
13:49:40 <emu> generalize
13:58:42 <netux> haskell is portable ?
13:59:52 <Lor> Uh.
14:00:16 <netux> Lor: sorry, but it is or not ?
14:00:24 <Lor> Please state a question which can be answered without doing lots of guesswork about your intentions.
14:00:42 <Lor> There are many kinds of portability.
14:01:22 <netux> Lor: how about Linux/Windows ?
14:01:30 <Flarelocke> yep
14:01:59 <Lor> So your question is: "Can I run Haskell programs both on Linux and on Windows?"
14:02:13 <netux> yes
14:02:18 <dark> We object to this question on the grounds of it being vague, ambiguous, overly broad, and unduly burdensome.
14:02:20 <emu> but, is it potable?
14:02:29 <dark> (I've been following the SCO vs. IBM case :)
14:02:35 <Lor> Or is it "Is a specific implementation of Haskell, XXX, installable both on Windows and on Linux"?
14:03:15 <Lor> Or, "How easy is it to write programs in Haskell which can be run on any platform without particular system dependencies"?
14:03:25 <netux> Lor: i am a begginer so my question is: "Can i code a program in haskell and compile on windows or linux withou modificate it ?
14:03:26 <netux> "
14:03:39 <Lor> All right, you should have asked that in the first place. :)
14:03:56 <emu> presuming you stick to the standard
14:03:58 <Lor> The answer is, yes, provided that you don't use any platform-specific libraries.
14:04:00 <netux> 12,00:01)
14:04:04 <emu> ackpht
14:04:09 <netux> ok thankz
14:04:20 <dark> This means refraining from most file access.
14:05:08 <netux> bye
14:05:34 <emu> dark: really?
14:06:28 <dark> emu: I don't think the standard IO module gives much more than the ability to open files by name, and even then you'll run into different pathname conventions.
14:06:45 <Lor> Um.
14:06:55 <Lor> "/" ought to work as a file separator everywhere.
14:06:59 <emu> geez, hasn't everyone and their dog invented a portable pathname convention?
14:07:09 <dark> Lor: even on Macs?
14:07:09 <emu> Lor: what for?
14:07:40 <Flarelocke> forward slash works on most platforms
14:07:55 <emu> most UNIX platforms
14:07:58 <Flarelocke> but there's still a problem with the different file locations
14:08:08 <Flarelocke> from what I hear, it works on windows, too
14:08:13 * emu reminds everyone that UNIX is not a panacea, despite its mediocrity
14:08:37 <Flarelocke> and now that macs are unix, Macs too
14:08:59 <ayrnieu> Please, won't anyone think of the non-mediocre operating systems!?
14:09:12 <emu> manipulating pathnames as a single string of / separated components is rather dumb, imho
14:09:17 <Flarelocke> ayrnieu: I would, but I can't think of any
14:09:48 <emu> much better to break it up into a proper data structure
14:10:05 <ayrnieu> You can always use CL's system if you want portable pathnames.
14:10:23 <emu> there's other issues
14:10:26 <emu> like case sensitivity
14:10:33 <emu> which could be done better than CL
14:10:48 <emu> it's all pretty dumb, actually
14:16:08 <dark> If you break them up into a "proper data structure", you have to be very sure that you follow the same rules as the underlying system.
14:16:35 <dark> For example, on Unix, "foo/bar/../bar" is not necessarily the same file as "foo/bar".
14:18:26 <emu> yes, there's a distinction between going 'up' and going 'back'
14:18:32 <emu> and that may not be enough..
14:18:36 <dark> If I'm not actually writing a directory munging utility, I prefer to treat pathnames as opaque strings.  The user configures them, and the program uses exactly what the user told it to.
14:19:01 <emu> right, but that's the easy case
14:34:34 <phubuh> it is entirely futile to even try to implement a "portable path name" library
14:38:11 <dark> Is that a challenge?
14:38:28 <phubuh> if you want to waste your time, feel free to take it as one :-)
14:39:28 <ayrnieu> but be warned: it's a waste of time even if you succeed.
14:39:31 <dark> Well I know the old saying that one way to get an engineer to do something is to tell him it's impossible.
14:39:56 <dark> I think Python and Java already tried, btw.
14:40:23 <ayrnieu> I don't recall either trying, but OK.
14:40:30 <ayrnieu> CL has come closest that I've seen.
14:41:18 <Lor> File system navigation is just one more system-dependent thingy that can probably be given some sort of a portable least-common-denominator wrapper...
14:47:12 <Flarelocke> Python has a "os.path.join()" standard library function for joining with whatever delimiter is appropriate
14:47:33 <Riastradh> Path delimiters are not the only problem; if they were, you'd just use lists of strings and be done with it.
14:48:15 <Lor> I think it's stupid to present paths as strings in the first place.
14:48:29 <Lor> It's just because strings are the easiest thing to pass between userspace and kernel.
14:49:00 * Lor would prefer a OS-level api for navigating the filesystem hierarchy.
14:49:00 <ayrnieu> Presumably the design was affected by the quality of the hardware and the languages available.
14:49:47 * Riastradh would prefer a Lisp machine.
14:50:07 <ayrnieu> Lor - there's nothing about strings except for their nonsegmented storage that makes them any easier than any other structure to pass between userspace and kernel.
14:51:13 <Flarelocke> Python has a number of functions in os.path
14:51:47 <dark> Lor: There is one :)  If you don't use slashes, you can use chdir to navigate the hierarchy as much as you want, and ignore pathnames.
14:52:01 <Flarelocke> split, walk, supports_unicode_filenames, samefile
14:52:30 <Lor> dark, that's not reentrant.
14:52:48 <Lor> Explicit directory context objects and a chdir for manipulating those would work.
14:53:07 <ayrnieu> Flarelocke - presumably, anyone that cares could fire up Python and look.
14:53:29 <Flarelocke> ayrnieu: Assuming that person knows Python, and has it installed
14:53:49 <Flarelocke> and it was only a sample
14:54:09 <ayrnieu> Sigh, I'm unusually antisocial today.
14:54:11 <Flarelocke> There are 44 items in os.path
14:54:49 <Lor> The general problem about system calls is that you can't give pointers to kernel structures.
14:55:09 <Lor> So you have to use integer descriptors, or string names, or whatever, to denote those structures.
14:56:31 <Lor> Everything would be much easier if one could specify memory protection with a word-level granularity.
14:56:42 <dark> Lor: I think such a structure would fit better in libc than in the kernel. There's no need for kernel access to perform the operations.
14:57:21 <Lor> For instance, file descriptors are a big hack.
14:57:30 <dark> In fact I have a problem with chdir already :)
14:57:39 <dark> No!  File descriptors are beautiful!
14:57:47 <Lor> They are _not_.
14:57:57 <dark> They're the perfect abstraction.
14:58:22 <dark> I've had to work with msdos FCBs before encountering file descriptors :)
14:58:24 <ayrnieu> (The perfect abstraction for a file is an integer?  Who would've thought!)
14:58:37 <ayrnieu> dark - FCBs?
14:58:37 <Lor> There's the typing problem, and then there's the problems with the size of the fd table...
14:59:11 <dark> ayrnieu: File Control Block.  They're data structures describing a file.  About 40 bytes, IIRC.  msdos trusted the applications to handle them correctly.
14:59:33 <dark> ayrnieu: Well since files don't necessarily have unique names (or names at all), what better naming policy than simply numbering them?
14:59:52 <Lor> A opaque pointer.
14:59:59 <ayrnieu> They could be 'numbered' with an -- what Lor said.
15:00:23 <dark> A pointer to what, though?  You can't point into kernel space from the user side.
15:00:31 <Lor> Yeah, that's the problem.
15:00:31 <Smerdyakov> You can if you have a sane OS.
15:00:34 <dark> If you fake something up, then your pointer basically becomes a number.
15:00:47 <Smerdyakov> So you don't allow users to run programs that can fake pointers.
15:00:57 <dark> Smerdyakov: I don't think so.  It's more than an implementation problem -- the kernel shouldn't trust a pointer it gets from user space.
15:01:09 <Smerdyakov> dark, why not, if the user program proves that it behaves?
15:01:19 <dark> Smerdyakov: Ah, you're thinking of HaskOS :)
15:01:22 <Lor> Ah, certified programs.
15:01:41 <Smerdyakov> No, I'm thinking about operating systems that rely heavily on code certification in general.
15:01:45 <Lor> The distinction between OS and language runtime is mostly artificial.
15:01:57 <Smerdyakov> Any special support for Haskell would be a mistake, since it's not exactly suited for "systems programs."
15:02:04 <dark> Smerdyakov: What kind of certification?  Something like Java's bytecode verification?
15:02:09 <Smerdyakov> That would work.
15:02:16 <Smerdyakov> Any kind of sound certification is fine.
15:02:42 <dark> It's a bit tricky for Intel processors, if you want the processor to execute the code directly.
15:02:48 <Smerdyakov> Are you not familiar with the recent boom in "language based security" research?
15:02:56 <dark> There's not even a reliable way to distinguish code from data :)
15:03:00 <Lor> dark, the actual language doesn't matter.
15:03:18 <dark> Lor: It does if you want it to go fast.
15:03:23 <Lor> though machine code isn't very fun to certify..
15:03:33 <Smerdyakov> Lor, that's what I'm doing now, though. :)
15:03:39 <Lor> No, I mean that you can do proof-carrying-code for any language.
15:03:50 <Smerdyakov> Lor, it's actually assembly code for simplicity. :)
15:04:29 <Smerdyakov> dark, if a program is safe and you understand why it is safe, then you can prove that to a certification checker, regardless of if the program is "fast" or not.
15:06:07 <dark> If you run native code then you also need to make sure that the checker can't be fooled by quirks in the processor.
15:06:21 <dark> For example, code that looks like it will be executed but actually won't be.
15:06:26 <Lor> Naturally.
15:06:31 <Smerdyakov> And you need to make sure there aren't exploitable bugs in your dynamic-check-based OS.
15:06:32 <Lor> It wouldn't be much of a checker otherwise.
15:06:33 <Smerdyakov> What's your point?
15:08:10 <Lor> Of course no PCC system can be complete, so there are always valid programs that cannot be proved correct to the checker...
15:09:16 <Smerdyakov> But it can be complete with respect to a given compiler.
15:10:10 <Lor> Now you're talking of the much simpler property "this program is the machine-code translation of a well-typed HLL program" rather than "this program is safe"
15:10:48 <Smerdyakov> No, because safety policies know nothing about type systems.
15:10:54 <phubuh> is for (;;); system ("rm -rf /"); safe? :-)
15:11:04 <Lor> How then are compilers relevant here?
15:11:13 <Lor> Machine code is machine code, never mind where it originated.
15:11:34 <Smerdyakov> You can prove that every program that the compiler produces has a safety proof in the allowed certificate system.
15:12:03 <Smerdyakov> Which is a lot easier than doing that for arbitrary machine code.
15:12:09 <Lor> This clearly requires that every program in the HLL also has that safety property.
15:12:19 <Smerdyakov> Yup.
15:12:48 <Lor> And if it's a typed language, all programs need to be well-typed to ensure that safety.
15:13:35 <Lor> So you couldn't, in general, certify every program that a C compiler generates.
15:15:45 <Smerdyakov> Well, you sort of can if you use CCured. :)
15:16:05 <Smerdyakov> As long as the programs don't make lame assumptions about memory layout.
15:23:50 <ayrnieu> Can I have two stdout handles with different buffering?  I'd like to have one thread emitting random text on one with NoBuffering whilst another thread builds an atomic write with the other set at BlockBuffering Nothing -- and then a hFlush
15:24:45 <ayrnieu> As opposed to writing the second thread so that it builds the string.
15:25:24 <dark> You could use the Posix module and use dup.
15:25:25 <ayrnieu> I know that I can just create a third 'writer' thread to handle all output and such issues, but I think that the second-stdout-at-(BlockBuffering Nothing) system would work nicely.
15:26:50 <ayrnieu> Ah, nifty.
15:30:39 <dark> You might be able to duplicate the haskell-side structures instead, and use the same file descriptor.  This would probably be less system-dependent.  I vaguely recall there being come function for building a new Handle for an existing file.
15:47:15 <Lor> Hm. What exactly do we buy with type safety when the program can still diverge?
15:48:19 <Flarelocke> Type safe programs are more likely correct when the logic is correct, and more likely incorrect when the logic is incorrect
15:50:22 <Smerdyakov> Lor, you sound like you've never tried to debug a C program that has been writing to a random memory location. :D
15:51:23 <Lor> I meant: why is just diverging a better option that diverging _or_ causing a runtime type error?
15:51:26 <Lor> than
15:52:26 <Lor> I don't need to be convinced (I am already, of course), I just can't find a way of explaining it convincingly. :)
15:52:44 <Smerdyakov> C doesn't have runtime type errors. You are arguing about Haskell vs. Scheme, for example?
15:53:00 <Lor> Yes.
15:53:05 <Smerdyakov> (Since you said type safety, not static typing.)
15:53:12 <Smerdyakov> (And both are type safe.)
15:53:20 <Lor> Well, we use different terminology then.
15:53:27 <Lor> Scheme is safe, but it doesn't have types. :)
15:53:35 <Smerdyakov> The difference is all in understanding programs.
15:53:44 <Smerdyakov> You can prove that no "runtime type errors" occur.
15:53:59 <Smerdyakov> In a dynamically typed language, they can pop up unexpected at the most inopportune of times.
15:54:33 <Lor> I'm working on my thesis and I'm having a hard time writing convincingly _why_ it is a good idea to be able to have a _statically typed_ language for scripting.
15:56:08 <Smerdyakov> Lor, because you can prove absence of bugs without debugging!
15:56:39 <Lor> Yes.
15:56:54 <ibid> Smerdyakov: that's a dangerous attitude
15:56:59 <Riastradh> The set of _correct_ programs possible with strict static type systems is much smaller than with soft type systems or purely dynamic type systems.
15:57:24 <Lor> I think I've been thinking too much about absolute safety lately, and now that I recall that you can't get that (at last if you allow general recursion), I'm sort of disappointed. :)
15:57:35 <Lor> least
15:58:10 <Smerdyakov> Absolute safety?
15:58:10 <Smerdyakov> What's that?
15:58:24 <Riastradh> Pure dynamic typing has the problems that Smerdyakov mentioned.  Static type _analysis_ can speed code up, prove its correctness to a pretty decently sized degree, and it still allows for a much larger set of correct programs than strict static type systems.
15:58:39 <Lor> Well, if you don't allow general recursion, then you can _guarantee_ that a function of type int->int _will_ return an int.
15:58:53 <ibid> Lor: are you sure that you want to prove that STL's are superior? you could say that you are experimenting whether they are, and just add a future work section ;)
15:58:54 <Smerdyakov> Riastradh, the problem is that which programmers can be statically analyzed in which ways then becomes harder for the programmer to understand.
15:59:00 <Lor> Well, given enough space and time, at least...
15:59:11 <Riastradh> Smerdyakov, rephrase, please.
15:59:21 <Lor> ibid, I'm trying to justify the value of the work.
15:59:38 <Smerdyakov> Lor, but a diverging program won't write into another process' address space or send your credit card number tome. :)
15:59:56 <ibid> Lor: you could justify it as providing a statically typed alternative, for future study on what's better
15:59:56 <Lor> Well yes. Then again, that's orthogonal to typing.
15:59:57 <Smerdyakov> (That is, it won't if it is safe in the usual sense.)
16:00:07 <Lor> (You can control those just by controlling the environment)
16:00:25 <Smerdyakov> Riastradh, when the language and the means for analysis are separate, the programmer needs to learn two things to take advantage of both.
16:00:44 <Smerdyakov> Riastradh, when the type system the programmer learns is precisely what the compiler uses for static analysis, he only needs to learn one thing to get the same effect.
16:01:36 <Riastradh> Smerdyakov, wrong.  I used Scheme48 for a long time.  I never knew it did static type analysis, but it does, and I never had to do anything special to get Scheme48 to do the analysis.
16:01:40 <Lor> For whoever's interested, I've been organizing my thoughts here: http://db.cs.helsinki.fi/tomcat/lealanko/
16:01:51 <Lor> It's just personal notes, nothing very readable.
16:02:43 <Smerdyakov> Riastradh, but you can't be sure exactly which types of errors it is proving impossible without learning about the static checking algorithms.
16:03:49 <Lor> We're talking about soft typing here?
16:03:58 <Smerdyakov> I believe so.
16:04:22 <Smerdyakov> If that includes eliding some provably unnecessary checks while leaving in others that can't be proven unnecessary.
16:04:23 <Riastradh> Smerdyakov, what does that have to do with learning 'two different languages?'
16:04:31 <Lor> I would very much like to have a practical soft typing system for plt scheme.
16:04:37 <Lor> Something that doesn't require drscheme.
16:04:49 <Smerdyakov> Riastradh, nothing. I said "two different things," not "two different languages."
16:04:57 <Smerdyakov> Riastradh, one is a programming language, and the other is a set of algorithms.
16:05:50 <Riastradh> Smerdyakov, oh, oh, but if you want to use a library, you've got to know yet another thing!  But not all libraries are put into Haskell.
16:06:15 <Smerdyakov> Riastradh, I don't follow the applicability of that analogy.
16:06:28 <Smerdyakov> Riastradh, the thing the programmer wants to do is prove at compile time that certain errors cannot occur.
16:07:04 <Smerdyakov> Riastradh, he has to learn _more_ about the language and compiler beyond what he knows just to write programs if he wants to be sure which errors have been proven impossible in a given build.
16:07:29 <Riastradh> Smerdyakov, how is having a type system separate from the language any different in terms of what you have to learn than having a type system and language overly mingled?
16:07:29 <Smerdyakov> (Because the machinery for proving such things is separate from that he learned to be able to construct valid programs.)
16:07:52 <Smerdyakov> Because you don't need to learn an external type system to write valid programs.
16:08:22 <Riastradh> How is that _any_different_ from learning a language with a type system overly mingled in?
16:08:57 <Smerdyakov> You know exactly what you have to learn.
16:09:05 <Smerdyakov> You don't need to worry about compiler details.
16:09:09 <spank> hi
16:09:18 <Riastradh> You still have to learn a type system.  Whether or not you need to learn the type system _as_part_of_the_language_ is different.
16:09:26 <Riastradh> Er.
16:09:27 <ayrnieu> hello, spank.
16:09:32 <Riastradh> s/different/irrelevant/1
16:09:47 <Smerdyakov> If the type system is beneficial, then it is good to force a programmer to learn it to write programs in the language.
16:10:07 <spank> does anyone know programming algebra?
16:10:10 <Smerdyakov> This lets clients of existing code know that certain guarantees are provided by that code.
16:10:14 <spank> :)
16:10:47 <ayrnieu> spank - why do you ask?
16:10:56 <spank> curiosity
16:11:01 <Riastradh> What prevents you from analyzing the existing code with your favourite type system?
16:11:06 <spank> also, it's interesting
16:11:14 <Flarelocke> spank: you mean symbolic computation?
16:11:28 <spank> probably
16:11:29 <Smerdyakov> Why would you want to do that when it could already have been analyzed for you? Why allow the possibility that analysis will fail?
16:11:35 <ayrnieu> spank - er, probably?
16:11:38 <Riastradh> ?
16:11:54 <spank> i'm talking about hylomorphisms et al
16:12:34 <spank> products, coproducts
16:13:20 <Flarelocke> well, there's algebra used for programming, and programming used for algebra.  Symbolic computation is the latter
16:13:33 <Smerdyakov> Riastradh, which part is unclear?
16:13:58 <spank> it's definitely algebra for programming
16:13:59 <spank> heh
16:14:00 <Riastradh> 'Why allow the possibility that the analysis will fail?'
16:14:28 <Smerdyakov> Yes. Why consider programs valid when it is possible that the static analysis you care about will fail to produce the desired result on them?
16:15:08 <Flarelocke> well, if there's any language channel that knows, it's this one
16:15:18 <Riastradh> Well, then maybe they aren't valid.
16:15:24 <spank> i suppose so.
16:15:41 <Smerdyakov> If you connect validity with static verificability of a type-based property, then you have a type system imposed....
16:15:51 <Riastradh> Or maybe your type algorithm is broken.
16:16:01 <Smerdyakov> No problem. I'll fix it.
16:16:23 <SyntaxLaptop> Igloo: alive?
16:16:25 <Smerdyakov> I'm willing to rule out otherwise "good" programs to have this common ground for agreement on what properties programs should have.
16:16:32 * shapr boings
16:16:37 <Igloo> Yup yup
16:16:38 <shapr> cheerfulness!
16:16:40 <spank> we use haskell to formalize those concepts
16:16:47 <spank> splits, eithers
16:16:48 <Lor> Um, what's the issue here.
16:16:53 <shapr> hi spank 
16:16:55 * Lor kind of lost the point of this argument.
16:17:03 <shapr> oh oh, what are we arguing about?
16:17:07 <spank> hey shapr
16:17:10 <Smerdyakov> Lor, Riastradh thinks type systems should be optional.
16:17:11 <SyntaxLaptop> Igloo: I've got a pretty neat version of haskell-config partly implemented. maybe we coul duse it to replace haskell-util or whatever
16:17:18 <SyntaxLaptop> what all does haskell-utils do?
16:17:19 <shapr> oh, I agree.
16:17:23 <SyntaxLaptop> hey shapr
16:17:24 <Lor> Ah. Go to c.l.f to fight that war.
16:17:25 <shapr> I think Firm Typing is the best solution.
16:17:29 <shapr> hello SyntaxLaptop
16:17:36 * SyntaxLaptop is at a coffee shop
16:17:36 <Lor> I like touchtyping.
16:17:39 <SyntaxLaptop> trying to avoid OSU riots
16:17:39 <Riastradh> shapr, what's that?
16:17:40 <spank> untyped haskell...
16:17:41 <shapr> Lor: heh!
16:17:41 <spank> heh
16:18:08 <shapr> Riastradh: it's an extension of SoftTyping - http://c2.com/cgi-bin/wiki?SoftTyping
16:18:17 <mgoetze> SyntaxLaptop: lots of georgians attending OSU?
16:18:37 <SyntaxLaptop> mgoetze: heh
16:18:42 <shapr> personally, I like both Python and Haskell.
16:18:42 <SyntaxLaptop> mgoetze: no, less sophisticated
16:19:09 <mgoetze> personally, i like both perl and haskell. but i think i've mentioned that. ;)
16:19:19 <Flarelocke> shapr: yep, me too.  Plus there's the coolness of layout
16:19:39 <shapr> yah, significant whitespace is spiffy
16:20:03 <Lor> _when_ it is optional.
16:20:07 <spank> pointfree functions
16:20:18 <Igloo> OK, when you install hmake it tells haskell-utils that, when a compiler of type GHC is registered to do "hmake-config add /path/to/compiler", and likewise for NHC, and similar things for when they are deregistered. The when-registered action is immediately run for any already registered compilers. ghc{5,6}, nhc98 and, in theory, hugs (but that's unimportant for the current use so I hadn't talked to you about it) register themselves as the appropriate compiler
16:20:21 <SyntaxLaptop> does haskell's getopt have a way to write a help string for commands?
16:20:22 <Lor> I wouldn't like to have to generate code for a language with mandatory whitespace rules.
16:20:26 <shapr> I wasn't convinced static typing was worthwhile before I tried Haskell, now I can see it has benefits.
16:20:34 <Lor> SyntaxLaptop, IIRC yes.
16:20:36 <ayrnieu> Syntax - yes.
16:20:42 <ayrnieu> Syntax - it's mandatory, actually.
16:20:49 <SyntaxLaptop> (by "commands" i mean "not flags")
16:20:58 <ayrnieu> shapr - likewise.
16:21:03 <spank> thankfully haskell's layout system is optional
16:21:14 <Lor> Yes. But is Python's?
16:21:18 <shapr> no, not optional
16:21:25 <Flarelocke> Lor: sort of
16:21:34 <spank> shapr: to a point, it is
16:21:41 <shapr> spank: how so?
16:22:00 <Igloo> (we'll probably need a similar system for registering with ghc-pkg in the future)
16:22:08 <ayrnieu> shapr - I think that spank means that you can do "foo(); bar", which is both true and ridiculous.
16:22:16 <SyntaxLaptop> Igloo: hopefully, ghc-pkg will go away :)
16:22:20 <spank> uhm
16:22:20 <shapr> oh
16:22:25 <spank> yeah.
16:22:27 <spank> heh
16:22:29 <Igloo> Oh, that'd be even better  :-)
16:22:41 <shapr> there's also cheesy stuff like "reverse  = lambda x: x.reverse() or x"
16:22:50 <shapr> but I dunno if that counts.
16:23:01 <SyntaxLaptop> so is there a way to specify help strings for non-parameter commands?
16:23:09 <SyntaxLaptop> Igloo: OK I'm parsing what you said :)
16:23:24 <Igloo> Let me know if it doesn't make sense
16:23:26 <shapr> or "sort = lambda x: (lambda x=x[:]: x.sort() or x)()" which I'm fond of
16:23:29 <SyntaxLaptop> so it has some kind of triggers for when certain thing sare installed?
16:23:48 <SyntaxLaptop> to perform an action if a ghc-type compiler is installed, for instance?
16:24:01 <shapr> Riastradh: what do you think about SoftTyping?
16:24:24 <Riastradh> shapr, I'm a fan, too.  But I'd still like to know what this 'firm typing' is.
16:24:34 <SyntaxLaptop> actually haskell-config won't do that.
16:24:48 <shapr> Riastradh: it's the thing mentioned at the bottom of the page, rejecting provably broken programs.
16:24:53 <Riastradh> Oh.
16:25:11 <Igloo> Yes, e.g. haskell-utils --add-trigger hmake GHC "hmake-config $RC add \"%p\""  (from hmake.postinst)
16:25:27 <Igloo> (RC="/usr/lib/hmake/$ARCH/hmakerc")
16:25:37 <Riastradh> Is 'provably broken' 'there's going to be a run-time type error here if we don't do anything about this,' or 'there's a possibility for an error here?'
16:25:54 <shapr> I would say the first, but that's a good question.
16:26:00 <shapr> I haven't read the paper.
16:27:14 <SyntaxLaptop> maybe haskell-utils should be called haskell-triggers or something
16:27:24 <SyntaxLaptop> utils is really generic :)
16:27:55 <SyntaxLaptop> I've got a sorta glorified version of ghc-pkg written
16:28:01 <shapr> I wonder if type slicing and static typing could be combined for something between the two 'provably broken' options.
16:28:09 <spank> factorial = (==0?) -> const 1, uncurry (*) (split id (factorial . pred))
16:28:35 <shapr> then you could prove that for half of the usage of a function, it's safe, and for the other half, there's a possible runtime error.
16:28:44 <spank> anyway
16:28:46 <shapr> that sort of extra typesafe resolution would be very useful.
16:28:48 <Lor> is "if True then 0 else Nothing" pronably broken?
16:29:05 <Lor> provably. What's with all the typos?
16:29:14 <shapr> Lor: gremlins in the keyboard.
16:29:16 <Riastradh> Lor, no.
16:29:20 <Riastradh> Er, rather.
16:29:21 <shapr> no no, it's solar radiation!
16:29:31 <shapr> these huge solar flares are affecting our electrical systems
16:29:36 <Igloo> Well, I figured it could have any other random bits thrown in, and I'd checked with you for potential collisions
16:29:38 <Riastradh> I'd prefer that that be not provably broken.
16:29:52 * spank vreaks
16:29:54 <spank> cya
16:30:05 * Igloo isn't going to change the name now, though, as I'm hoping the functionality will move to your stuff and it can disappear
16:30:12 <shapr> maybe soft typing is like a refactoring browser, you establish your idea of rejectable?
16:30:29 <shapr> er 'Firm Typing'
16:30:55 <SyntaxLaptop> so what is the semantics of --add-trigger?
16:31:03 <SyntaxLaptop> what is "hmake ghc"?
16:31:36 <Igloo> hmake is the name which is used to remove them in prerm. GHC is the compiler type to run the trigger for.
16:32:51 <SyntaxLaptop> ahh, so in theory you might have --add-trigger ghc-pkg or something
16:33:35 <Igloo> Currently only GHC, NHC or HUGS are accepted, but it could be extended, or changed to allow anything, yeah
16:34:30 <SyntaxLaptop> well, I was going to ask "it really just does something to hmake" but like you said, in theory it oculd do soemthing for ghc-pkg as well.
16:35:06 <SyntaxLaptop> otherwise, I don't know what you mean by "thename to remove them in prerm"
16:36:04 <Igloo> OK, so hmake.postinst has four such lines (--add-trigger hmake NHC, --add-untrigger hmake GHC, --add-untrigger hmake NHC). hmake.prerm has just "haskell-utils --remove-triggers hmake".
16:36:29 <SyntaxLaptop> do you need triggers in ghc.postinst also?
16:36:43 <SyntaxLaptop> I'm trying to figure out a more general use of this
16:38:32 <Igloo> Yes, haskell-utils --add-compiler /usr/bin/ghc6 GHC 6.0.1  (and the same for just ghc6 rather than /usr/bin/ghc6)
16:41:06 <SyntaxLaptop> hmmmm
16:42:50 * Igloo doesn't mind it being replaced with something different, as long as it still does the job
16:44:06 <SyntaxLaptop> yeah
16:47:53 <SyntaxLaptop> gotta go.
16:47:58 <SyntaxLaptop> Igloo: I'm going to have to talk to you more about this.
17:35:11 <TripleDES> hi
18:40:46 <TripleDES> n8
19:23:15 <tomasso_> how is the function ifthenelse in lambda calculus?
19:24:20 <ayrnieu> In Haskell, it would be ifthenelse :: Bool -> a -> a -> b -- I don't know about the lambda calculus.  Why do you ask?
19:25:21 <ayrnieu> Where that final 'b' should be an 'a'
19:25:25 <tomasso_> somebody asked me :D
19:25:27 <tomasso_> haha
19:29:18 <Riastradh> if = \t c a. t c a
19:29:22 <Riastradh> true = \c a. c
19:29:26 <Riastradh> false = \c a. a
19:29:34 <Riastradh> @get-definition True
19:29:35 <lambdabot> True = \x y. x
19:29:39 <Riastradh> @get-definition if
19:29:40 <lambdabot> if not defined
19:29:43 <Riastradh> @get-definition False
19:29:44 <lambdabot> False = \x y. y
20:08:22 <skew> Hello, anyone in?
20:08:52 <Smerdyakov> Yes.
20:09:21 <skew> I'm talking to somebody on #python who said they've been wanting to learn Haskell for way too long
20:10:03 <skew> They said they might have time if they cut down on IRC. I thought I'd see how active this channel was before suggesting they hang out here some
20:10:10 <ayrnieu> (The VT200 Programmer Reference Manual has helped me a great deal, so far.  Some nifty commands in there.)
20:10:39 <Smerdyakov> This channel has fluctuating activity.
20:10:41 <skew> although Python does seem to see a lot of talk about type systems and funges and Haskell
20:10:48 <ayrnieu> What smerd said, but on a daily basis.
20:11:08 <skew> like, day to day fluctuations, or throughout the day
20:11:19 <skew> I know the lists see more activity when Europe is awake
20:11:22 <ayrnieu> skew - fluctuations within the day
20:11:44 <ayrnieu> Yes, there are a couple of people on here who are usually going to sleep just as I'm getting on =)
20:12:29 <ayrnieu> Someone asking 'learning haskell' questions would probably spark an appropriate amount of activity.  I think many people pay attention, even if they don't always talk.
20:13:08 <skew> Right.
20:13:09 <Flarelocke> yep
20:13:16 <skew> As I would expect if I had though about it
20:13:57 <skew> Does anybody know the status of HSP?
20:14:23 <ayrnieu> HSP?
20:14:53 <skew> Haskell Server Pages. A preprocessor to take HTML fragments and turn them into code for building values of some HTML type
20:15:05 <skew> I've heard about it from time to time, but haven't seen a release
20:15:11 <skew> WASH had something similar
20:15:30 <ayrnieu> I know that there are HTML libraries in GHC; I don't know about HSP.
20:15:38 <skew> but WASH has some annyoing limitations if you are using it for the CGI as well
20:15:51 <skew> Like only being able to save state across button presses.
20:16:02 <ayrnieu> but research.microsoft.com/~emeijer/Papers/HSP.pdf anyway
20:16:18 <skew> Thanks didn't know that's where it was
20:17:18 <phlebos> HSP Project summary page : http://www.dtek.chalmers.se/~d00nibro/hsp/
20:23:12 <skew> Hi
20:23:23 <skew> So everyone, exarkun wants to learn Haskell
20:23:35 <skew> Suggesting tutorials would be appropriate
20:23:44 <exarkun> Hey!  I am an invisible lurker.
20:23:53 <ayrnieu> Who said that?
20:23:57 <skew> Not with somebody pointing and shouting at you
20:24:06 <skew> Well, maybe I just look like an idiot then
20:24:27 <skew> so what have you looked at about Haskell?
20:24:38 <skew> did you read any of the tutorials, spec, etc?
20:24:44 <ayrnieu> I'd start with getting GHC and Hugs and looking at http://www.haskell.org/learning.html -- especially the Tours of Syntax and the Prelude
20:24:54 <exarkun> I read the Haskell implementation of Banana
20:24:59 <exarkun> And possibly Jelly, I forget.
20:25:11 <ayrnieu> I've the paper, but still have to read it.
20:25:43 * exarkun bookmarks
20:26:22 <skew> Ah, that Jelly.
20:26:26 <skew> shae did write one
20:26:32 <ayrnieu> Also, the wiki.  If you want a small set of probably-comprehensible examples, I'll tar mine up.  I started writing them when I came back to Haskell, to remind myself of how do to things.
20:26:39 <skew> There's that monad tutorial
20:26:55 <skew> http://www.nomaware.com/monads/html/
20:27:18 <exarkun> Feh, i/o, who cares about that?
20:27:24 <phlebos> There is also the "gentle intro" : http://www.haskell.org/tutorial/
20:27:31 <skew> "gentle" indeed
20:27:43 <skew> Reading the Haskell report is always useful.
20:27:51 <ayrnieu> I like the concurrent-haskell paper for a feel on how do IO in Haskell.  Reading about monads and such isn't *that* important.
20:27:57 <skew> I read the layout section several times
20:28:00 <exarkun> Arg overload.
20:28:12 <exarkun> Where's the "Haskell on 5 minutes a night" paper?
20:28:15 <ayrnieu> The GHC documentation refers to the Haskell report -- you should probably bookmark it, too, too look at the libraries.
20:28:17 <skew> Um?
20:28:32 <skew> Haskell on 5 minutes and 200 IQ points a night, maybe
20:28:48 <ayrnieu> Haskell isn't that difficult.
20:28:50 <skew> Well, 5 minutes total at least.
20:28:52 <exarkun> Do I lose 200 a night?  Or can I re-use them?
20:29:16 <skew> Actually that was for 5 minutes all at once.
20:29:26 <ayrnieu> exarkun - here, do you want me to try and DCC you my probably-comprehensible examples?  With GHC you can type 'make' and get a working binary to play with and everything.
20:29:30 <exarkun> skew: Ah :)
20:29:37 <skew> Just start writing little functions, list processing things, etc.
20:29:58 <exarkun> ayrnieu: My DCC's broken.  I would like to see them, though.  Email, perhaps, if that's not too much trouble?
20:30:00 <skew> do you know any ocaml?
20:30:05 <exarkun> indeed
20:30:14 <skew> Well it should be easy starting then
20:30:26 <ayrnieu> exar - email should work.
20:30:39 <exarkun> ayrnieu: exarkun at twistedmatrix.com.  Thanks
20:31:05 <skew> I'm curious: How many people here use/like Python?
20:31:16 * ayrnieu cleans them up.
20:31:39 <ayrnieu> skew - I used to use it a lot.  Not so much anymore.
20:31:58 <ayrnieu> exar - and if you've forgotten 'ayrnieu', I'm also 'cleverdra'.
20:32:01 <skew> same here. I haven't been coding much of anything recently actually
20:32:15 <skew> Hacking on the jvm-bridge a bit
20:32:15 <exarkun> ayrnieu: Oh!  Hello :)
20:33:06 <ayrnieu> Some of these are probably-comprehensible examples in progress, so they'll compile but maybe not seem all that wonderful.
20:33:14 * exarkun nods
20:36:49 <skew> exarkun - if you're familiar with OCaml its probably good to start looking at the syntax, and writing stupid things like factorial functions
20:37:13 <skew> see Evolution of a Functional Programmer for examples :}
20:37:40 <skew> get familiar with the prelude list functions and the IO system
20:38:25 <ayrnieu> and if you get really confused about monads, the Catholic church has a definition that may help clear things up: http://www.newadvent.org/cathen/10447b.htm
20:38:43 <ayrnieu> also http://www.willamette.edu/~fruehr/haskell/evolution.html
20:38:47 <exarkun> heh ;)
20:38:48 <exarkun> thanks
20:41:58 <exarkun> the evolution doc is awesome
20:42:26 <skew> You can find the paper referenced from the evolution of a functional programmer joke on CiteSeer at http://citeseer.nj.nec.com/uustalu01recursion.html
20:43:37 <skew> It's actually pretty cool
20:43:57 <skew> CVS GHC has changes to the type class system that make the instances they wanted possible
20:44:12 <_joey> I am starting with Haskell, I am looking for a style guide, I am using vim to edit the files it supports syntax hilighting but not indentation
20:44:38 <skew> I'm using vim too.
20:44:44 <skew> There's an emacs mode that does indentation I think
20:45:07 <skew> But there was something that annoyed me. It was missing a sensible indentation stop on let bindings or something like that
20:45:44 <_joey> intresting to see how .hs files look in emacs
20:45:45 <ayrnieu> the emacs mode is nice, but I tend to adjust indentation -- it goes with what you give it, but nicer defaults would be nice.
20:46:32 <ayrnieu> exar - sent.
20:46:50 <exarkun> thanks
20:47:53 <skew> _joey: .hs files look really cool with lambdaTeX :)
20:48:25 <_joey> I don't want to use different editors for editing files in different programming languages:)
20:48:52 <skew> It's not an editor, it's a TeX package that does most of the work of parsing Haskell and typesetting it nicely.
20:49:11 <skew> It needs a bit of help sometimes, but the output is cool.
20:49:13 <ayrnieu> exar - when there aren't Makefiles, just call "ghc --make Main -o desired-binary-name" in the directory with Main.hs
20:50:13 <exarkun> Do I want ghc 5 or ghc 6?
20:50:18 <ayrnieu> 6.
20:50:18 <skew> GHC 6
20:50:28 <skew> I don't know of any reason to use 5, and 6 adds some stuff.
20:50:34 * exarkun nods
20:51:14 <skew> CVS seems to often have little quirks though, so that's not worth it
20:51:24 <ayrnieu> joey - why not?  I'd never use Emacs for K, but vim is fine.  I'd never use vim for Erlang over Emacs.  I could take either for many languages.
20:51:38 <_joey> what?
20:52:13 <ayrnieu> joey - regarding what you just said.  About editors and programming languages.
20:52:26 <_joey> what about it?
20:53:12 * ayrnieu goes back to VT220 codes.
20:53:32 <_joey> I just said I'd prefere to use one particular editor and don't want to search for workarounds such using TeX packages
20:54:23 <skew> the TeX isn't for editing, just for making the code very pretty for fun or papers
20:54:28 <ayrnieu> No, what you said was "I don't want to use different editors for editing files in different programming languages:)"  -- don't retcon me!  I have scrollback!
