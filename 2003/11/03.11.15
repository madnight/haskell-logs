02:57:03 <shapr> jameson: nah, they've been around for a long time
02:57:07 <shapr> jameson: they're actually from clog
02:57:47 <andersca> hej shapr
02:58:15 <shapr> y0 y0
02:58:55 * Marvin-- sighs
03:06:00 <Marvin--> my code is horrible
03:06:10 <shapr> get the code mop!
03:06:40 <Marvin--> I think this is beyond hope, I don't really have time to clean up the code, I really should focus on getting the thesis done :P
03:06:51 <shapr> well, ok
03:06:54 <Marvin--> I've cleaned up some stuff and removed unused stuff though
03:07:01 <Marvin--> ('bout time)
03:08:10 <Marvin--> cool, apparently LWN had some good things to say about debian-installer
03:08:18 <Marvin--> (now, where did I put my lwn account...)
03:12:51 * Marvin-- experiments with induction
03:28:07 * Marvin-- swears
03:29:45 * shapr argues with MosheZ on #python
03:29:50 * Marvin-- stays away ;)
03:29:57 <Marvin--> what's it about now?
03:30:06 <shapr> I just called him up on his mobile phone to harangue him about Haskell :-)
03:31:07 <Marvin--> hahaha
03:31:52 <Marvin--> there are these weird posters at some of the walls at the institutions with the headline "What's it like to live in Israel?" I don't remember exactly what it's about, probably some speech somewhere
03:32:08 <shapr> you probably have to yell at Moshe for hours on end ;-)
03:32:08 <Marvin--> everytime I walk by I get this urge to say "I dunno, let me call Moshe and ask"
03:32:16 <shapr> that's what it's like to live in Israel
03:32:27 <Marvin--> Moshe has very definitive opinions :)
03:32:51 <Marvin--> urrgh
03:32:59 <Marvin--> I like Data.Generics, but half the time I don't understand the code I write
03:33:17 <Marvin--> (and I had to write my own Writer monad just to slap 'deriving Typeable' on it *grmbl*)
03:33:37 <Marvin--> floatLets :: Decl -> FloatM [Decl] Decl
03:33:37 <Marvin--> floatLets d = everywhereM (mkM f) d
03:33:37 <Marvin-->   where f (ELet ds e) = do ds' <- everywhereM (mkM f) ds
03:33:37 <Marvin-->                            tell ds'
03:33:37 <Marvin-->                            return e
03:33:38 <Marvin-->         f e = return e
03:33:43 * Marvin-- boggles at his code
03:34:59 <Marvin--> I wonder if this'll work
03:35:15 <Marvin--> actually, I should just say floatLets there instead of everywhere
03:35:49 <Marvin--> mommy, my code is scaring me :-(
03:41:32 <Marvin--> http://sjogren.ost.sgsnet.se:8080/FloatLets.hs
03:45:13 <shapr> hi raver 
03:45:22 <raver> yep shapr
03:45:36 <shapr> wassup?
03:46:08 <raver> haskell improvement morning
03:46:20 <Marvin--> yay, can't you improve my haskell?
03:46:21 <raver> :)
03:46:41 <raver> i don't tin k so
03:46:49 <Marvin--> dang :/
03:46:51 <raver> first i have to learn
03:46:53 <raver> sorry
03:46:54 <raver> :)
03:48:09 <raver> this morning's goal is to add more than 1 arg to my program
03:48:14 <raver> i will try getArgs
03:50:06 <Marvin--> oh, maybe I shouldn't scare you with Data.Generics then
03:52:11 <Marvin--> hm, wonder how to prove that this code actually works
03:52:48 <raver> step by step
03:52:52 <raver> i'm so newbie
03:52:54 <raver> :)
03:53:05 <raver> but i take note about that
04:39:12 * Marvin-- grumbles at quickcheck
06:04:43 <earthy> great
06:04:51 <earthy> just great. I've forgotten my NickServ passwd. ;)
06:05:18 <earthy> oh well, time for some groceryshopping
07:30:31 <Lor> Grumble. If I have an ordered list [0,0,1,1,1,2,2,5,5,5] then how do I turn it into an array with the counts of each value within that range in linear time?
07:31:46 <Lor> I can use map (\x->(head x, length x)) (group l) to get elem,count -pairs, but how do I get the missing zero-valued entries easily?
07:32:03 <Lor> Naturally it is possible, but I want a _pretty_ way. :)
07:33:02 <Marvin--> hm, so for this particular case you want 0 -> 2, 1 -> 3, 2 -> 2, 3-> 0, 4 -> 0, 5 -> 3?
07:34:37 <Lor> Yep.
07:35:08 <Marvin--> I guess you could start with an array filled with zeroes and use accum
07:35:09 <Lor> Yeah, it's trivial to just traverse it manually and get the lengths of consecutive sections, but that ain't pretty.
07:35:26 <Marvin--> @type accum
07:35:32 <Marvin--> hm
07:35:33 <Lor> accum ain't pretty either. :)
07:35:37 <Lor> And it isn't linear time.
07:35:48 <Marvin--> right you are
07:35:55 <Lor> Oh, sorry, yes it is.
07:36:08 <Lor> (linear, not pretty)
07:36:17 <Marvin--> depends on the array implementation I guess
07:36:32 <Lor> I guess we can assume that each array construction takes time proportional to its length.
07:36:42 <Marvin--> depends on the array implementation :)
07:36:45 <Marvin--> ST arrays are pretty funky
07:36:59 <Lor> In any safe language, arrays do have to be initialized.
07:38:41 <Marvin--> I'd use a LC instead of map btw
07:39:50 <Leimy> how do I get command line arguments in a haskell program
07:40:25 <Lor> System.getArgs
07:41:03 <Leimy> and its a list?
07:41:12 <Lor> System.Environment.getArgs in the hierarchical libs.
07:41:20 <Marvin--> IO [String]
07:42:15 <Leimy> I should say... the result of "x <- System.getArgs" is a list? :)
07:42:28 <Marvin--> as much as you can talk about "result" in Haskell
07:42:37 <Leimy> sure
07:42:45 <Marvin--> x <- System.getArgs binds x to a value of type [String] yes
07:42:57 <Marvin--> or rather, import System (or System.Environment) and use just getArgs
07:43:08 <Leimy> that's what I should have said... but I've only really been playing with Haskell for 3 days
07:43:15 <Leimy> so I am still learning the ropes and how to think :)
07:43:34 <Marvin--> I usually do    main = getArgs >>= iMain   with iMain :: [String] -> IO ()  in my programs so I can use iMain in interpreter mode
07:43:48 <Leimy> nive
07:43:50 <Leimy> er nice
07:44:04 <Leimy> I am just trying to make a simple compound interest caclulator that I can run from the command line
07:44:33 <Marvin--> yay, parsing
07:44:42 <Leimy> heh
07:44:47 <Leimy> read and show I guess
07:44:56 <andersca> Marvin--: do you remember the turtle lab
07:45:15 <Marvin--> Leimy: if you want to limit yourself to space-separating everything, then yeah :)
07:45:39 <Marvin--> andersca: sure, it was fun (except that we got a return that I don't agree with)
07:45:53 <Leimy> Marvin
07:45:57 <Leimy> er... yeah :)
07:45:57 <andersca> Marvin--: we handed in ours yesterday
07:45:58 <Leimy> space is ok
07:46:16 <andersca> Marvin--: we wrote this program that would read a .ppm image and draw it one pixel at a time
07:46:17 <andersca> :)
07:46:18 <Marvin--> andersca: fun stuff :)
07:46:22 <Marvin--> blegh
07:46:35 <Marvin--> insanity
07:46:49 <Marvin--> we mainly experimented with concurrency
07:46:56 <Marvin--> concurrent turtles are fun
07:47:05 <andersca> yeah
07:47:11 <andersca> why did you get a return?
07:48:44 <Marvin--> IIRC, we implemented asymmetric fork instead of symmetric, which means that we didn't implement joining (you have two states, which one is "correct"?) and we motivated our decision
07:48:55 <Marvin--> the only comment was basically "you have to implement this"
07:49:01 <Marvin--> so we had to make an ugly hack to make it work :/
07:50:04 <andersca> oh, hmm
07:50:05 <Marvin--> Lor: anyhoo, I think using accum with a listArray is your best option
07:51:03 <Marvin--> we tried to make a concurrent turtle program for Koch curves but never got it to work
07:52:54 <Leimy> is that multi-threaded Logo or something?
07:53:20 <Leimy> :)
07:53:46 <Leimy>  /= is the inequality operator correct?
07:54:20 <Marvin--> Leimy: pretty much, yeah, it's a programming assignment in our Advanced Functional Programming course
07:54:25 <Marvin--> yes, /= is inequality
07:54:32 <Leimy> nice
07:54:42 <Leimy> I had joked about that a little before I think :)
07:54:53 <Leimy> like MPI-Logo on a cluster
07:55:27 <Marvin--> but multi-threading implemented in the haskell module, not using system concurrency
07:59:40 <Marvin--> hey, this code is pretty good
07:59:51 <Marvin--> always fun to look back at code you've written and be proud of it :-)
08:00:43 <Leimy> I am having problems with indentation
08:00:43 <Leimy> :P
08:00:45 <Marvin--> Data.Generics is fun
08:01:31 <Marvin--> andersca: http://sjogren.ost.sgsnet.se:8080/FloatLets.hs
08:15:04 <andersca> Marvin--: interesting
09:01:25 <TripleDES> hi
09:01:36 <prologic> hi
09:04:14 <raver> hi all
09:04:15 <raver> :)
09:04:57 <prologic> hi raver :)
13:46:49 <keir> is there a function to slice an array in haskell? ie, take a certain column out of an array and get a list back.
13:47:13 <Lunar^> keir: You're talking about Array, or about lists ?
13:47:23 <keir> well, both i guess
13:47:33 <keir> ok, let's say Array
13:47:46 * keir is finding haskell kind of hard to get started with
13:47:52 <keir> writing all the standard sort functions was easy
13:48:00 <ibid> for lists i'd use map (!!4) if i remember !! correctly
13:48:01 <keir> but now that i want to do something -real- with it, i'm kinda lost
13:48:07 <ibid> for slicing column 4
13:48:17 <keir> brilliant!
13:48:22 <keverets> @type (!!)
13:48:23 <lambdabot> (!!) :: [a] -> Int -> a
13:48:40 <keir> ok, now back to another question i've had for awhile
13:48:55 <keir> what would be a nice, 'haskell' way to define a card? (as in, playing card)
13:49:03 <keir> i need to put these cards in a 5x5 array
13:49:13 <keir> some array elements may be empty (no card)
13:49:19 <Jad> Card a = Ace | Jack | ..
13:49:21 <keir> and i need to change this array as the user puts stuff in it
13:49:22 <keir> ok
13:49:37 <keir> Card a = Ace | Jack | ... ... but what about suit?
13:49:47 <keir> Suit Card = Diamonds | Hearts ???
13:49:49 <Darius> Perhaps Card Face Suit with suitable enumerations and derive Enum
13:50:16 <keir> but, i need to assign Face cards = 10 pts, numbers as expected, ace = 1
13:50:35 <phubuh> data Color = Red | Black, data Suit = Diamond | Heart | Spade | Clover, data Value = One | Two | Three | Four | ...
13:50:40 <Lunar^> keir: You'd write a function that maps a Face to points
13:50:48 <keir> ok
13:50:55 <phubuh> I don't know the English names for playing cards, but you get the point. :-)
13:51:06 <Darius> Clover == Clubs
13:51:08 <keir> :)
13:51:09 <Lunar^> phubuh: Joker, Queen, Kind, Ace
13:51:12 <phubuh> Oh, sorry.
13:51:19 <Lunar^> s/Kind/King
13:51:29 <phubuh> Clover is the literal translation of the Swedish "klöver"
13:52:06 <Jad> data Card = Card suit Face
13:52:06 <keir> cool
13:52:18 <Jad> data suit = Hears | spades | ....
13:52:20 <keverets> it is a clover, but in cards it's called "clubs" for some reason.
13:52:21 <keir> but what about the numbered cards?
13:52:28 <Jad> data Face = Jack | Queen | ...
13:53:12 <Darius> keir, when you derive Enum you get to/fromEnum which are functions Int -> a/a -> Int and it's just numbered by the order it's written, so data Face = Ace | Two | Three | etc. would give you 0, 1, 2 
13:53:44 <Darius> Also, the range syntax should work, e.g. map (Card Hearts) [Ace..King]
13:53:52 <phubuh> keir, I wouldn't use Ints to store those -- that way, you can pass any arbitrary integer to functions that will expect them to be 0-13.  It's better to use a type and derive Enum.
13:53:53 <keir> Darius, ok. 
13:54:09 <keir> phubuh, i agree. Enum is prettier anyway
13:54:38 <phubuh> And there's usually no semantic difference between a numbered card and a royal card, they just have different representations. :-)
13:58:44 <keir> can i do things like somecard > Ace && somecard < Three?
13:59:43 <Darius> Yes.  I'm not sure what the derived Ord instance does, but worse case scenario you can make your own instance that is simply a < b = fromEnum a < fromEnum b
13:59:46 <Darius> etc
13:59:47 <phubuh> Deriving Enum should get you Ord as well.
13:59:59 <keir> ok
14:01:56 <Lor> It doesn't.
14:02:04 <Lor> For some reason, Enum isn't a subclass of Ord.
14:02:06 <phubuh> Oh.  That's odd.  Why not?
14:02:25 * keir is rather confused about haskell's typing / classes
14:02:30 <keir> is there a good explanation somewhere?
14:02:57 <keir> i have three books at my desk on haskell (hurray university library) but none are particularly good
14:03:34 <phubuh> Have you read http://www.haskell.org/tutorial/goodies.html?
14:04:42 <phubuh> Back when I didn't know any languages with sophisticated type systems, I remember being very confused about the difference between type constructors and data constructors
14:04:46 * keir reads now
14:05:26 <Darius> phubuh: A deriving clause won't add any classes not mentioned.  E.g. deriving Ord doesn't derive Eq as well.
14:06:40 <phubuh> I see.
14:12:59 <keir> is 'a' special?
14:13:02 <keir> ie, 
14:13:06 <keir> data Point a = Pt a a
14:13:16 <keir> can you use, say, b?
14:13:48 <phubuh> Sure.
14:14:07 <Lunar^> I'd love to use alpha and beta ;)
14:14:14 <keir> ok, so data constructors are at run time
14:14:28 <keir> why would i not use a type class for the card representation?
14:14:30 <phubuh> Lunar^, I have Emacs set to render "alpha" and "beta" as actual greek letters. :-)
14:14:40 <Lunar^> phubuh: hehe
14:14:52 <Darius> keir: A type class only specifies an interface.
14:14:54 <ibid> Lunar^: shouldn't it be possible, unicode is supported by h98 :)
14:14:57 <keir> does emacs have nice AA'd fonts yet?
14:15:10 <phubuh> There is a patch to use XFT, but it's slow and buggy. :-(
14:15:20 <keir> bleh. i'll stick with vim then ;)
14:15:37 <ibid> shouldn't be _im_possible, of course  :)
14:18:18 <Lunar^> ibid: unfortunately, it's not GHC's case
14:19:12 <ibid> Lunar^: true
14:21:01 <keir> mind if i paste some code from the tutorial? (4 lines)
14:22:29 <keir> type String             = [Char]
14:22:29 <keir> type Person             = (Name,Address)
14:22:29 <keir> type Name               = String
14:22:29 <keir> data Address            = None | Addr String
14:22:37 <keir> i understand that  the type keyword is like C's typedef
14:23:02 <Lor> Ah, accumArray does do the trick I wanted, after all.
14:23:03 <keir> but data Address, that doesn't do anything either, does it?ie, it doesn't instantiate anything
14:24:34 <ibid> keir: it does something, but no instantiation (are you thinking too oo?)
14:24:40 <keir> yes
14:24:42 <keir> ibid, yes
14:25:13 <keir> ibid, but i realize that doesn't really appyl in the funktional context
14:25:24 <Lor> Bah. There really is no section syntax for pairs?
14:25:29 * Lor would have liked (,1).
14:25:29 <ibid> keir: if type is typedef, then data is a combination of union and struct
14:25:40 <keir> ibid, ok!
14:25:47 <keir> ibid, that's what i thought
14:28:26 <keir> cardval :: (Card Suit Face) -> Integer
14:28:34 <keir> i get ERROR "proj.hs":48 - Illegal type "Card Suit Face" in constructor application
14:28:54 <ibid> how have you defined Card?
14:29:00 <keir> data Card = Card Suit Face
14:29:06 <keir> data Suit = Hearts | Spades | Diamonds | Clubs
14:29:13 <keir> data Face = Ace | Two | Three | Four | Five |  ...
14:29:18 <ibid> keir: use cardval :: Card -> Integer
14:29:18 <keir> deriving Enum
14:29:36 <ibid> keir: the left side is the type, the right side is a description of the data structure
14:29:49 <keir> ok
14:30:14 <keir> how do i get the enumerated value 'out of' a card?
14:30:19 <keir> ie, Ace -> 1
14:30:24 <ibid> for Card Suit Face to work, you would need to have data Card a b = ...
14:30:31 <ibid> fromEnum?
14:30:32 <keir> cardval (Card s f) | f <= Ten     = f
14:30:34 <keir>                    | otherwise    = 10
14:31:02 <keir> oh, hehe, i have a better idea, max(f,10)
14:32:47 <keir> hrm, deriving Ord doesn't help
14:32:52 <keir> it still doesn't know the value
14:32:56 <ibid> hmm?
14:33:02 <keir> of Ace (ie, type error on ord f)
14:33:11 <ibid> ord f?
14:33:14 <ibid> use fromEnum
14:33:29 <Lor> What, why?
14:33:38 <Lor> Ah, to get a numeric value.
14:34:27 <Lor> No, waitasec, is cardval supposed to return a Face or a number?
14:34:40 <keir> a number
14:34:50 <Lor> Then you ain't gonna return f.
14:34:55 <keir> 1=ace, 2=2,... 10=10, all face cards = 10
14:35:01 <keir> cardval (Card s f) = min (fromEnum f) 10
14:35:05 <keir> works
14:35:26 <Lor> or fromEnum (min f Ten) :)
14:35:32 <keir> hrm, but i need the enumeration to start from 1 for covenience
14:36:01 <Lor> Just say +1. You can't change the way that instances are derived.
14:36:04 <phubuh> Add one to it. :-P
14:36:04 <keir> i could add a 'NoCard' to the face constructor
14:36:10 <Lor> No, that's ugly.
14:36:12 <keir> adding one to it is a hack
14:36:12 <phubuh> That would be yucky.
14:36:19 <keir> ok
14:36:23 <keir> yeah i guess that's easiest
14:36:31 <keir> since i'll do all the scoring with the cardval function
14:36:44 <ibid> isn't it possible to instantiate Enum manually, or does it require the first to be 0?
14:37:15 <keir> can i take Ten => "Ten"?
14:37:24 <Lor> It's possible, but a bother. Automatic instances are easier.
14:37:29 <Lor> keir, yeah, derive Show
14:37:29 <keir> ie for display purposes
14:37:31 <phubuh> keir, derive Show and use show.
14:37:33 <ibid> Lor: quite true
14:37:36 <phubuh> @type show
14:37:37 <lambdabot> show :: Show a => a -> String
14:48:15 <keir> is there real 2d arrays, or only arrays of arrays?
14:48:38 <keir> ie in python there aren't any 2d arrays unless you use Numeric
14:49:43 <Darius> Uh, I think (effectively) both.
14:50:47 <keir> is '.' string concatenation?
14:51:33 <Darius> No, ++
14:51:50 <keir> then what does this mean --
14:51:51 <keir> aprint a width = shows (bounds a) . showChar '\n' . showRows lx ly where
14:51:53 <keir> ...
14:51:57 <Darius> . is function composition (actually it's quite overloaded syntactically)
14:52:11 <Darius> @t shows
14:52:11 <lambdabot> Sorry, I don't know the command "t", try "lambdabot: @listcommands"
14:52:16 <Darius> @type shows
14:52:17 <lambdabot> shows :: Show a => a -> ShowS
14:52:23 <Darius> @prelude ShowS
14:52:24 <lambdabot> ERROR: does not exist
14:52:24 <lambdabot> Action: connect
14:52:24 <lambdabot> Reason: Connection refused
14:52:47 <Darius> anyways, type ShowS = String -> String
14:53:34 <Darius> The use of (.) there is an optimization.
14:54:18 <Darius> Or rather, the use of shows and (.) etc. is an optimization.  The use of (.) is necessary from the type of shows.
14:56:12 <keir> how would i make a random card?
14:57:11 <andrewc> StdGen and related functions from the prelude give you random values, i think
14:58:58 <Darius> Most (all?) of the random stuff is in module Random.
14:59:05 <keir> yes, i just got that
15:00:04 <keir> how does toEnum work?
15:00:33 <keir> Enum a => Int -> a
15:00:45 <keir> how do i actually call this?
15:01:00 <keir> oh!
15:01:17 <keir> Main> toEnum 4::Face
15:01:17 <keir> Five
15:01:24 <andrewc> [oh, sorry - have an import Random at the top of my code!]
15:07:47 <keir> it drives me crazy when library docs have extensive, extensive docs on functions and modules, but NO EXAMPLES!!! ARGH!!!
15:08:00 <keir> http://www.haskell.org/onlinereport/random.html
15:08:05 <keir> appears to have all i would need
15:09:06 <Darius> Yes, the Report is pretty readable.
15:09:18 <keir> except examples :(
15:09:25 <keir> i'm sure the answer is simple
15:09:35 <keir> but i'm not a haskell expert
15:09:46 <keir> i learn best by lots of small examples...
15:10:06 <keir> and even one line giving me a random number between 1 and ten would be enough
15:10:09 <keir> but noooo
15:11:39 <ibid> the report is a reference, not a tutorial :)
15:17:18 <keir> rollDice :: IO Int
15:17:19 <keir> rollDice = getStdRandom (randomR (1,6))
15:17:26 <keir> <an example>
15:17:29 <keir> but it does nothing
15:17:37 <keir> ie, Main> rollDice
15:17:42 <keir> <blank line>
15:17:49 <ibid> try rollDice >>= print
15:18:23 <keir> cool.
15:18:35 <keir> now, why do i need to use IO just to generate a random number?
15:18:47 <Darius> You don't.
15:19:15 <Lor> Well, you do if you want it to be a different random number every time.
15:19:24 <Lor> To get the seed.
15:19:33 <keir> ok
15:19:39 <ibid> keir: you'd like a simple rand :: Int, wouldn't you? except that you'd get the same random number every time you called it
15:19:51 <keir> so this is the monad thing
15:19:55 <keir> do ...
15:19:55 <ibid> Lor: you could have a stream of random numbers :)
15:21:28 <Lor> Well yes, but it would be the same stream every time, without IO.
15:22:14 <keir> is there a nice, elegant way to make a deck of cards (ie, has every permutation of face/suit)
15:22:20 <keir> in a list
15:22:27 <Lor> Yes.
15:22:41 <keir> in python i would do it with comprehensions
15:23:02 <Lor> Just derive Enum for Card and Suit.
15:23:07 <Lor> and Bounded.
15:23:19 <Lor> Then all your cards are [minBound .. maxBound] :: [Card]
15:23:20 <keir> ok
15:23:26 <Lor> Permutations you have to do by your self.
15:23:29 <Lor> It's a three-liner.
15:23:49 <Lor> I think you meant combination, previously.
15:24:37 <ibid> Lor: unless you give a seed to the stream generator
15:24:39 <keir> sure.
15:34:36 <keir> [(Card Ace Clubs) .. (Card King Spades)]
15:34:44 <keir> ERROR - Illegal Haskell 98 class constraint in inferred type
15:40:44 <keir> can i override the way Card is displayed?
15:41:06 <keir> Lor, I couldn't get the .. trick to work, but I wrote  this instead:
15:41:12 <keir> freshdeck = [(Card (toEnum f::Face) (toEnum s::Suit)) 
15:41:12 <keir>                | f <- [fromEnum Ace .. fromEnum King],
15:41:12 <keir>                  s <- [fromEnum Spades .. fromEnum Clubs]]
15:42:45 <Darius> You don't need ':: Face' etc. it can figure it out from Card.  And you shouldn't need fromEnum Ace etc.
15:43:56 <keir> yes you do
15:44:01 <keir> when i take it out i get
15:44:07 <keir> ERROR "proj.hs":66 - Type error in application
15:44:07 <keir> *** Expression     : toEnum s
15:44:07 <keir> *** Term           : s
15:44:07 <keir> *** Type           : Suit
15:44:07 <keir> *** Does not match : Int
15:44:26 <keir> er
15:44:28 <keir> my bad
15:47:46 <Lor> keyr, did you derive Enum for Card?
15:48:00 <keir> Lor, nm, sorry, i did get it working
15:48:04 <keir> i just forget to take out the toEnum
15:48:10 <keir> freshdeck = [(Card f s) | f <- [Ace .. King],
15:48:10 <keir>                           s <- [Spades .. Clubs]]
15:48:15 <keir> works great
15:48:33 <Lor> It ought to go all the way.
15:48:55 <keir> no, i didn't put Enum in card
15:49:04 <keir> when I try to, i get 
15:49:08 <keir> ERROR "proj.hs":42 - Can only derive instances of Enum for enumeration types
15:49:18 <Lor> Ah.
15:49:19 <Lor> Silly.
15:49:42 <Lor> You could use Ix, though.
15:50:41 <Lor> Yep, that'd work. 
15:51:00 <Lor> Derive Ix for everything, and then just use range(low,high)
15:51:03 <keir> so make Card derive Ix?
15:51:10 <Lor> And all the others, too.
15:51:38 <Lor> If you ever want to use Cards as indices for an array, you'll want to do that anyway.
15:52:03 <keir> Ix wants Ord... but Ord doesn't like enum
15:52:25 <Lor> "doesn't like"?
15:52:35 <Lor> Just derive Ord for everything.
15:52:45 <keir> sorry, it wants Eq
15:52:56 <Lor> You'll want that too, in any case.
15:53:06 <Darius> Yes, you need to derive both (or provide one yourself).
15:53:14 <Lor> It is very rare not to need an Eq instance for a data type.
15:53:28 <keir> woah, that does work
15:54:05 <Lor> I don't see why Ix and Enum are separate classes. Their functionality is so close.
15:54:17 <keir> what is Ix?
15:54:33 <Lor> It means the type is usable as an index for an array.
15:54:47 <Lor> Essentially it gives an enumeration for the type, just like Enum.
15:56:29 <keir> now onto randomizing the deck...
15:57:29 <keir> how might one define a randomPop function? the IO thing bends my brain a bit
15:57:43 <keir> because you'd have to define a new range every time
15:57:54 <Darius> Lor: They are conceptually different, I wouldn't want to glom them in one class.  Also, Ix requires Ord but Enum doesn't.
15:58:12 <keir> which means a new getStdRandom(randomR (1, length (lst)))
15:59:56 <Darius> Why the ()'s around 'lst' and why not 'list'?
16:07:27 <keir> Darius, you're right they're unnecessary
16:08:05 <keir> but how do i get a value out of that?
16:08:22 <keir> return?
16:21:58 <Riastradh> HI!
16:22:33 <andrewc> surely there's a neater way that avoids [StdGen]?
16:22:50 <keir> you would think so
16:23:41 <Riastradh> Monads are infectuous.
16:23:46 <Riastradh> They're slowly taking over all of your code.
16:24:01 <Riastradh> And the worst thing is...you don't even notice!
16:24:06 <Riastradh> Well, OK, you do notice.
16:24:12 <Darius> All your base are belong to IO
16:24:55 <Riastradh> Launch unit!  Launch unit!  Take off every unit!  For great binding!
16:25:31 <Riastradh> Even my Scheme macros are being infected by monads!@
16:25:41 <Riastradh> HELP!
16:25:52 <Riastradh> (actually, not just yet: I'm still writing them in CPS!)
16:25:59 <keir> nice
16:26:04 <keir> continuations rock
16:26:24 <Riastradh> My macros are so cool they don't even need CALL/CC.
16:28:08 <ibid> i have a student who writes call/cc in haskell ;)
16:28:26 <Riastradh> Eh, that's not hard.
16:28:55 <Riastradh> But SYNTAX-RULES is a plain, call-by-name, pattern-matching language and nothing more: and they're _still_ Turing-complete, and they can _still_ do continuation jumps!
16:30:21 <ibid> no, it's not hard
16:30:35 <Riastradh> I'm working on a numerics library for it: it will support the full Scheme numeric tower!
16:30:37 <ibid> but it's not something that would occur to my average student
16:31:09 <Riastradh> Do you not teach CPS or something?
16:31:16 <ibid> i don't
16:31:18 <ibid> no time
16:31:27 <Riastradh> That sucks.
16:31:41 <keir> my prof didn't know much about call/cc
16:31:42 <keir> sucks
16:31:52 <keir> he's not the best programming languages instructor
16:32:08 <Riastradh> Teach him about CPS and CALL/CC, then!
16:32:16 <keir> well, i would
16:32:22 <keir> but i don't think i fully understand it myself
16:32:31 <ibid> i have only 120 hours (including out-of-class study) to bring them from full ignorance to some level of understanding
16:32:42 <Riastradh> http://www.bloodandcoffee.net/campbell/txt/continuation-tutorial.log
16:32:52 <Riastradh> Read that, and once I return from supper, tell me if you think you understand them any more.
16:33:12 <Riastradh> (it assumes some basic Scheme knowledge, but nothing that complicated)
16:33:55 * Darius reads then tells Riastradh that he doesn't understand them anymore.
16:34:06 <keir> Riastradh, i'm still confused
16:34:10 <keir> Riastradh, i read that before
16:34:27 <keir> Riastradh, i need to implement something useful with them before i'm going to understand
16:34:31 <keir> i get the idea
16:34:42 <keir> but sometimes when trying out simple thing with them it doesn't work as expected
16:36:13 <keir> ((call/cc (lambda (k) (k k))) (call/cc (lambda (k) (k k))))
16:36:16 <keir> hurray infinite loop
16:36:29 <keir> now, i don't see why that is an infinite loop
16:37:01 <keir> nm
16:37:02 <keir> i do now
16:37:16 <keir> for some reason last time  i cooked this up i couldn't see why it was infinite
17:01:23 <keir> so Maybe is a monad?
17:02:10 <Heffalump> yes, Maybe is a monad
17:07:19 <Lor> Darius, that was quite an amazingly abhorring piece of code you posted on c.l.f. Congratulations. :)
17:07:56 <keir> comp.lang.funge?
17:08:00 <keir> fortran?
17:08:02 <keir> faskell?
17:08:42 <Lor> ferl?
17:08:58 <keir> fython?
17:09:15 <keir> (a python -> fortran converter ;)
17:10:24 <Riastradh> comp.lang.functional, presumably.
17:10:34 <Heffalump> bah, no stating the obvious allowed here
17:10:44 <Riastradh> I presumed; I did not state the obvious.
17:10:54 <Riastradh> You are being presumptuous by presuming that I did not presume.
17:10:59 <Riastradh> No being presumptuous here!
17:11:05 <Heffalump> butbutbut
17:11:12 <Riastradh> Everyone I know has a big but!
17:11:23 <Heffalump> I deny being presumptuous, whereas you admit it
17:12:02 <Riastradh> Ah, but there we differ: I _presumed_, but I was not _presumptuous_.  You were _presumptuous_by_presuming_.  There is a subtle difference there and I'm still right.
17:12:16 <Heffalump> but you still smell
17:13:32 * Riastradh blames the grunge he acquired by arguing about something regarding Python earlier today.
17:13:46 <steveh> python is a nice language
17:13:51 <steveh> it shouldn't cause fights
17:14:06 <Riastradh> steveh, no it isn't, you piece of filth!  YAAAAARGH!  CHAAAARGE!
17:14:14 <Lor> Python is presumably a nice language.
17:14:21 <steveh> the way I see it
17:14:27 <Lor> At least I read some python source and could sortakinda figure out what it did.
17:14:55 <Riastradh> I'm very able to read Python.  In fact, I understand it so well I know exactly how much it sucks!
17:14:58 * Riastradh charges at steveh.
17:14:59 <Lor> Of course, that is not an issue if you actually know the language.
17:15:09 <Lor> So in conclusion, python is a very good language not to know.
17:15:22 <Riastradh> Zigackly.
17:15:23 <steveh> C, Python, Haskell, are the languages I would like to be very fluent in
17:15:42 <steveh> possibly Lisp dialects as well
17:15:45 <Smerdyakov> steveh, and so why aren't you?
17:15:53 <steveh> but at some point it's just getting familiar with whatever dialect
17:16:20 <steveh> Smerdyakov: Well, right now it's probably because I'm programming in Perl and Java the majority of the time. It's the money, you see
17:16:21 <steveh> :)
17:16:23 <Smerdyakov> steveh, it some point it's just hacking away.
17:16:28 <Smerdyakov> s/it/at
17:16:50 <steveh> I've seen things that Perlers wouldn't believe
17:16:58 <steveh> yet
17:17:03 <steveh> all those memories will fade away
17:17:06 <steveh> like tears in rain
17:17:07 <Smerdyakov> steveh is the one who was planning to apply to 100 graduate schools, I think.
17:17:09 <Lor> Forth is something I ought to learn.
17:17:12 <Smerdyakov> Did I remember correctly?
17:17:17 <Riastradh> Perl people will believe anything: just look at what they're letting go into Perl 6!
17:17:35 <steveh> Smerdyakov: :) Yeah, but that's gonna wait a little bit. Had a long-term planning session with the SO
17:17:43 <Lor> If I ever have to work on an unknown platform with nothing but an assembler, forth would probably be the language I'd implement to get real languages bootstrapped.
17:18:01 <Smerdyakov> Lor, I don't know. I might want to go with Scheme.
17:18:10 <Lor> It requires a too hefty runtime.
17:18:13 <Riastradh> Smerdyakov, not Pre-Scheme?
17:18:18 <Riastradh> Lor, um, no it doesn't: not at all.
17:18:20 <Smerdyakov> Not really. A shitty garbage collector is easy to write. :D
17:18:24 <Lor> Well yeah.
17:18:33 <keir> Riastradh, what do you have against python?
17:18:34 <Lor> Still something I wouldn't like to write in asm if avoidable.
17:18:40 <steveh> It will make much more sense when she is a doctor
17:18:42 <keir> Riastradh, i've found it quite good.
17:18:52 <steveh> then she can support my lazy ass when I go back to school
17:18:54 <Riastradh> keir, well, you must be very presumptuous!  QED.
17:19:10 <steveh> and since presumably I will be keeping grad student hours at that point, I can watch rugrats
17:19:19 <steveh> and I don't mean the show
17:19:27 <Smerdyakov> steveh, support your ass? Oh, yeah, you want to do masters.
17:19:40 <keir> steveh, where are you going to apply?
17:19:41 <Smerdyakov> steveh, if you do PhD, you can be hella rich if you live modestly.
17:19:52 <steveh> well, we'll see how deep the rabbit hole goes
17:20:24 <Smerdyakov> steveh, if you apply for PhD from the start, you can get paid to take classes from the start.
17:20:26 <Lor> Golly, there are places where education actually means you'll get paid more?
17:20:27 <steveh> keir: lots of places. it's not as exigent now since the planning
17:20:35 <steveh> heavy on AI though
17:20:40 <steveh> so the usual suspects there
17:20:44 <keir> steveh, cool. that's where i'd like to go.
17:20:50 <Smerdyakov> Lor, PhD students in top schools in the USA get paid quite reasonable living stipends.
17:20:57 <keir> steveh, what's the usual suspects? my univ seems to have a good AI dept (univ. of Toront)
17:21:06 <keir> s/Toront/Toronto/
17:21:20 <Smerdyakov> Lor, so it's more of good money while learning than increasing marketability by the time you finish.
17:21:36 <Smerdyakov> Lor, though, of course, being eligible for professor jobs vastly increases earning potential within academia.
17:21:54 <Lor> Hereabouts professors don't make that much either.
17:22:07 <Smerdyakov> Much more than I can imagine a reasonable person spending.
17:22:10 <Lor> Then again, I wouldn't complain. Hereabouts education is free.
17:22:26 <Smerdyakov> Free education wouldn't help much.
17:22:31 <Smerdyakov> You still need money to live....
17:22:35 <keir> in canada, profs do reasonably well. most of my profs are on the U of T > 100k list.
17:22:58 <steveh> mit, cmu, osu, I will look into toronto, cornell, uiuc, plenty of places. I will figure out who is doing interesting things in computational linguistics and contact them
17:23:18 <steveh> stanford
17:23:19 <Smerdyakov> People in my office talk about computational linguistics.
17:23:21 <steveh> I have a list somewhere
17:23:24 <Smerdyakov> So maybe you want to apply to Berkeley. :)
17:23:42 <Heffalump> here I think salaries top out at around 40-50K (UKP) without a chair
17:23:49 <Lor> Everyone talks about computational linguistics.
17:24:13 <Lor> It's funny, I'm a computer scientist and a linguist-to-be, but computational linguistics has never interested me. :)
17:24:34 <Smerdyakov> Heffalump, that is an unimaginably high amount of money for me to picture making.
17:24:35 <Heffalump> tell a lie, more like 35-40K
17:24:40 <Lor> Well, I tell a lie, of course it has, but not _particularly_.
17:24:43 <Smerdyakov> Heffalump, I'd be able to retire after 5 years.
17:24:47 <Heffalump> IM lecturing salaries
17:25:00 <Heffalump> Smerdyakov: huh?
17:25:00 <steveh> that depends on whether Bush is reelected ;)
17:25:20 <Smerdyakov> Heffalump, I can live on less than 1/4 of that amount. So I can save up money and then stop working when I get enough.
17:25:31 <Heffalump> remember that's gross salary
17:25:36 <steveh> sure, if your expenses don't go up
17:25:47 <steveh> yet they always do :)
17:25:53 <Heffalump> do you expect to die in 20 years, then?
17:26:12 <mattam> consume less <=> work less
17:26:12 <Smerdyakov> Heffalump, no, I expect to put enough in a certificate of deposit that I can live off the interest ad infinitum.
17:26:13 <Heffalump> 40K gross = about 26K net, at a guess
17:26:21 <steveh> whoa
17:26:22 <Heffalump> errm, what do CDs pay in the US?
17:26:27 <steveh> that'd be one hellacious CD
17:26:53 <Igloo> CD?
17:26:55 <Smerdyakov> But trivial for me to amass enough money if I were to go work in industry now, for instance.
17:26:55 <steveh> you'd need to put  $1,000,000 into it to even consider drawing $50,000/year
17:26:58 <Heffalump> certificate of deposit
17:27:06 <Smerdyakov> Why would I want $50k/year?
17:27:19 <Smerdyakov> I only need less than half that amount to live comfortably.
17:27:22 <steveh> well
17:27:27 <steveh> maybe this will work for you
17:27:33 <Igloo> Oh, duh. Tried to read it as a job title.
17:27:34 <Heffalump> I thought interest rates in the US were less than they are here, and you can barely get 4% here.
17:27:35 <Smerdyakov> It works for anybody.
17:27:36 <steveh> $100000 to draw $5000 a year
17:27:44 <steveh> sooo
17:27:53 <Smerdyakov> You imprison yourself by deciding you want too many material things.
17:27:54 <steveh> $500000 to draw $25,000
17:28:00 <steveh> let's settle on that as a base line
17:28:10 <Smerdyakov> I've seen offers for 7% interest rate for minimum $20k deposit.
17:28:12 <steveh> that means you will have to put away $50,000/year for 10 years
17:28:17 <Heffalump> about the least you can possibly spend on rent in Oxford is £250/month
17:28:50 <Heffalump> another £50-100/month in house-related bills is pretty much unavoidable
17:28:59 <keir> my baseline living expenses here in toronto are a
17:29:08 <keir> about $1000 cdn /mo
17:29:12 <Heffalump> smerdyakov: have you considered the need to index-link this CD?
17:29:26 <Smerdyakov> steveh, that's easy to do with the kind of job I could get if I started poking head-hunters now.
17:29:50 <Lor> I live on $200 a month. :)
17:29:55 <Smerdyakov> Heffalump, I haven't seen it in a while.
17:30:01 <Smerdyakov> Heffalump, are you asking for a link to it?
17:30:11 <Heffalump> no, index-link = adjust for inflation
17:30:38 <Heffalump> if you want to maintain the real value of the income from it, you need to allocate some of the income to making the total value grow with inflation
17:30:39 <Lor> Well, a bit more right now, but could if I had to (and have had to).
17:30:48 <Smerdyakov> I don't think that would be a problem. I could overestimate grossly and still be set within 1/2 of the normal period considered before retiring.
17:31:08 <Heffalump> if inflation stays low, yes
17:31:22 <Smerdyakov> You think inflation would cause prices to double in my lifetime?
17:31:34 <Heffalump> easily
17:31:37 <Smerdyakov> OK.
17:31:41 <Heffalump> does this channel have a calculator?
17:31:52 <Smerdyakov> Another related option which automatically adjusts for that is to only work 3 months out of the year or similar.
17:31:52 <Heffalump> @eval 1.1*1.1
17:31:53 <lambdabot> type error
17:32:01 <Heffalump> @eval 1*1
17:32:02 <Smerdyakov> I think I could start doing this now with no saving period and live comfortably.
17:32:02 <lambdabot> 1
17:32:15 <Heffalump> that's better for tax efficiency too
17:32:24 <Cale> @eval 1/10
17:32:24 <steveh> Smerdyakov: hmm, I'm not so sure. You could be "overqualified" after all.
17:32:24 <lambdabot> 0
17:32:29 <steveh> :-P
17:32:36 <Smerdyakov> steveh, I don't even have a masters yet. :P
17:32:39 <Heffalump> he hasn't got a PhD yet :-)
17:32:50 <steveh> aaaah
17:33:01 <steveh> well, then you'll be needing 10 years J2EE experience
17:33:01 <steveh> ;)
17:33:18 * Heffalump has a PhD and (will have) three years postdoc experience and is now thinking about real world jobs :-/
17:33:32 <Smerdyakov> Three years. Yikes.
17:33:39 <Smerdyakov> Did you purposely avoid finding a "permanent" job?
17:33:42 <Heffalump> I've only got two now
17:33:42 <Smerdyakov> Or couldn't find one?
17:33:49 <Heffalump> didn't try
17:34:18 <Heffalump> it's hard to get a decent permanent lecturing job without having postdoced for a bit
17:34:42 <Heffalump> and anyway I wasn't sure I wanted an academic career (and am now leaning even more on the side of not)
17:34:50 <Smerdyakov> I'm not too enthusiastic about traditional PhD-track jobs. I'm hoping more to do some kind of socially beneficial research thing.
17:35:13 <steveh> and you want to put away money?
17:35:23 <steveh> you are quite the optimist :)
17:35:28 <Smerdyakov> steveh, not necessarily. It's one option I've considered.
17:35:49 <Smerdyakov> I think I can save $50k by the time I graduate, at least.
17:36:02 * TripleDES time to sleep
17:36:05 <TripleDES> bye
17:38:17 <Lor> All this sounds really weird to me. Hereabouts, if you want to make money in IT business, you first sortakinda pretend you're studying at least for a BSc, then you go to an industry job and gradually forget about your studies and make heaps of money.
17:38:37 <Lor> If you study and get a phd and whatnot, you'll just become one sorry-ass researcher with laughable pay.
17:38:48 <Heffalump> degrees on the continent take longer, though
17:39:05 <Heffalump> you're done with an undergraduate degree in 3 years here, but have to do it full-time really
17:39:46 <Lor> I'm actually my eighth year now and still haven't completed my MSc. :)
17:39:55 <steveh> Lor: in the US tenured professors have unbeatable job security and nice hours
17:40:12 <Lor> It's intentional, though. Studying is too fun, graduation spoils it.
17:40:17 <steveh> Lor: compare that to your huge-round-of-layoffs every 5 years in industry
17:40:21 <Heffalump> whereas I'm 24 and have a PhD :-) (but I did get my UG degree early)
17:40:36 <Smerdyakov> Wow. I didn't realize you are so young.
17:40:40 <steveh> plus tenured professors can easily make $100,000
17:40:53 <steveh> minimum is maybe $60,000
17:41:03 <Heffalump> what do assistant profs get?
17:41:07 <keir> is the Monad class special?
17:41:08 <steveh> lower
17:41:09 <steveh> ;)
17:41:18 <Heffalump> keir: yes, in that it enables do syntax
17:41:22 <Lor> keir, no, except that there is inbuilt do-syntax.
17:41:29 <Cale> heh
17:41:48 <keir> so, monads are just syntat sugar?
17:41:55 <keir> syntactic rather
17:41:58 <Lor> No, do is just syntactic sugar.
17:42:01 <Lor> Monads are real.
17:42:12 <Heffalump> Smerdyakov: if I'd started my UG degree at 18, I could reasonably expect to have just finished my PhD now.
17:42:18 * keir shouldn't have figured he could learn haskell in a day
17:42:34 <Heffalump> you sound like you're asking intelligent enough questions to have made a good start...
17:42:37 <steveh> keir: do you know another functional language?
17:42:50 <keir> steveh, i learned scheme in a day
17:43:01 <keir> steveh, and python was my first introduction to semi-functional style
17:43:20 <Smerdyakov> Honk if you dig model theory!
17:43:31 <keir> now i'm just plowing through the type class tutorial on haskell.org
17:43:35 <Lor> I've never seen the point of getting a phd rightaway at full speed. It's nice to have goals in life, not to reach them immediately.
17:43:40 <keir> but there are parts that could certainly been clearer
17:43:46 <keir> s/been/be/
17:43:57 <Smerdyakov> Lor, it's also nice to not dawdle in subordinate positions.
17:44:12 <Lor> Once I get my msc next year, hopefully, I'll prolly start working on my linguistics degree. phd is somewhere far away.
17:44:18 <Heffalump> lor: here it's difficult not to, cos you run out of money
17:44:26 <Lor> Well yeah, point.
17:44:35 <Heffalump> you only get three year's funding normally
17:45:17 * Smerdyakov has his fingers crossed for getting outside fellowships.
17:45:27 <Heffalump> so as to avoid having to teach?
17:45:33 <Smerdyakov> I could get 5 more years after this one funded generously if I made myself sound good enough on paper. :)
17:46:04 <Smerdyakov> No. Getting a prestigious fellowship is prestigious, and it pays more.
17:46:08 <keir> in the tutorial, it says that haskell does not have c++ style function overloading. 
17:46:14 <keir> yet, == seems overloaded to me
17:46:16 <Lor> I guess I'm a sort of a dilettante generalist lazy-ass who just studies everything and doesn't do any real work. :)
17:46:22 <Smerdyakov> keir, it's principled overloading.
17:46:22 <Heffalump> keir: correct, it's not C++ style
17:46:31 <Lor> keir, yeah, it's not c++-style overloading, it's overloading done right.
17:46:37 <Heffalump> it's all based on the static type rather than the runtype type
17:46:43 <Heffalump> s/runtype/runtime/
17:46:48 <Heffalump> C++ overloading can be based on either
17:46:53 <keir> ok
17:46:53 <Lor> heffalump, uh, say what?
17:47:03 <Lor> C++ overloading is quite compile-time.
17:47:04 <Heffalump> I don't think I'd necessarily call it more principled or right.
17:47:10 <Heffalump> Lor: errm, virtual functions?
17:47:11 <keir> so it's not really a practical difference?
17:47:18 <Lor> That's not overloading in C++ terminology.
17:47:24 <Heffalump> oh, ok
17:47:25 <Lor> Even though cardelli would call it that.
17:47:30 <Smerdyakov> Can't type classes be used in a way that involves passing around runtime type information, in a sense?
17:47:45 <Heffalump> Smerdyakov: oh, true, but that's a bit different
17:47:48 <Lor> In a sense, yes.
17:47:56 <Lor> (class Dynamic being a prim example)
17:48:03 <Heffalump> that comes down to using the type class system to simulate runtime types
17:48:27 <Heffalump> keir: I think there's a significant difference in the style in which you define the overloading
17:48:39 <Smerdyakov> Even for cases where a type class using function is compiled only once but called at multiple types, you can't make that rigorous of an argument that this is "more static" than C++ overloading.
17:48:43 <Darius> Actually, the existential type gets the runtimedness.  The typeclass mechanism is just convenience.
17:48:59 <Heffalump> you have to declare "classes" which specify that certain operators/functions have to be defined (e.g. Monad as you saw earlier)
17:49:03 <keir> Heffalump, seems pretty similar to me except that you have to define classes
17:49:17 <keir> :)
17:49:44 <Heffalump> darius: oh, true, I guess
17:50:02 <Heffalump> without existentials even though the type will be passed around at runtime in the dictionary it's still statically deducible
17:50:23 <Heffalump> keir: "default" definitions are something that you don't get in C++, too
17:50:30 <keir> is there anything like shceme's ' operator?
17:50:33 <Heffalump> also the whole hierarchy of classes thing
17:50:54 <Darius> keir: Not in Haskell 98
17:50:58 <Heffalump> keir: not in Haskell 98, no, cos it's expected to be a compiled language (assuming that really is the quote operator and I'm not confused)
17:51:14 <keir> yes, it's the ' operator.
17:51:27 <Heffalump> there's something called Template Haskell which GHC supports that sort of has it, but it's much much more complicated cos of the type system and the need to restrict it to one "stage"
17:51:39 <keir> i read somewhere that haskell is much much slower than, say, ML, even though it's compiled
17:51:48 <Heffalump> yes, laziness hurts
17:52:05 <keir> i wonder if someone could put in a 'lazyness-detector'
17:52:08 <Darius> It's not "much much" slower
17:52:12 <keir> that boosts it if there's no lazyness
17:52:15 <Heffalump> because the language is fully lazy, the default compilation strategy for an expression has to build a thunk
17:52:16 <Darius> And you can get Haskell as fast as C
17:52:18 <Heffalump> keir: they have done
17:52:27 <Heffalump> darius: in general?
17:52:43 <Heffalump> but the analysis required tends to be itself quite hard and rather fragile
17:52:59 <Igloo> It's pretty good in general. Just certain things kill it. Unfortunately Strings and IO make one such thing.
17:53:02 <keir> has anyone tied haskell <-> ATLAS?
17:53:07 <Igloo> (AIUI, at least)
17:53:16 <Heffalump> hmm, I hadn't heard that, but fair enough
17:53:18 <Heffalump> ATLAS?
17:53:43 <keir> http://math-atlas.sourceforge.net/
17:53:50 <keir> used in MATLAB 6.xx
17:53:56 <Darius> Heffalump: Don't know.
17:53:59 <keir> Octave / R / Scilab / etc
17:54:12 <keir> handy if you want to do AI stuff
17:54:29 <Darius> What definitely -is- true, is that it's quite easy to make extremely inefficient Haskell.
17:57:58 <steveh> laziness can throw people for loops
17:58:13 <steveh> at least
17:58:16 <steveh> it throws me for loops
17:58:51 <Smerdyakov> Oh my. I guess no one digs model theory.
17:59:03 <keir> is there a function for m a -> a?
17:59:12 <Darius> steveh: There are other things like (++) and non-tail recursive functions.
17:59:19 <keir> ie getting the contents out of a monad?
17:59:22 <Smerdyakov> keir, bad!
17:59:29 <Darius> keir: Not in general, no.
17:59:36 <Smerdyakov> keir, that would make the language not functional anymore.
17:59:56 <Cale> For many monads, it's okay to take out values. For some, it's not.
18:00:11 <keir> IO Int is the one i'm concerned about
18:00:13 <Cale> For IO, it's not okay.
18:00:14 <Lor> Would it be abominably bad style to pretty-print a -> Double as \mathbb{R}^{a} ?
18:00:33 <Darius> Lor: Depends on the context.
18:00:38 <shrimpx> Cale: what's wrong with the extraction op?
18:00:42 <steveh> Darius: well, those go for any functional language
18:00:57 <Lor> I'm really using functions of that type just to represent finite vectors.
18:01:05 <Lor> It's just nicer to deal with functions rather than arrays.
18:01:33 <Darius> How is a -> Double a vector?
18:01:46 <Lor> You give it the index, it gives the value at that index.
18:01:50 <Lor> a is a finite type.
18:03:00 <Cale> i.e. You can't take an IO Int and turn it into an Int because it's not an Int. It's a computation that if executed would return an Int, and may have side effects.
18:03:14 <Lor> Also, I might use \mathbb{N} for Int.
18:03:22 <Darius> Lor: Well pretty-printing it however you want to pretty-print a vector seems reasonable.  It could always be an abstract type.
18:03:37 <keir> Cale, ok
18:03:57 <keir> Cale, so what i want is do ... IO Int
18:04:09 <Lor> I want to make a haskell program readable to someone who doesn't know haskell but knows math.
18:04:10 <keir> gah, i need to see the expansion of do
18:04:28 <Smerdyakov> Lor, come on, man. Math is so out of style.
18:04:42 <Darius> Lor: Yeah, that was the context I was talking about before.  Then yes, it doesn't seem unreasonable.
18:05:02 <Lor> Wonder if I should also represent the type [a] as a^{*}... :)
18:06:29 <Cale> Suppose f is a function taking Int to String, and myIOInt is your value of type IO Int. Then you could do something like: do { a <- myIOInt; putStrLn (f a); }
18:06:31 <Lor> Hm, is it possible to render a comma in types differently than in terms with lhs2tex?
18:07:08 <Cale> So you can still apply your algorithm to user input without coding your algorithm using the IO monad.
18:09:23 <keir> cale, ok.
18:10:55 <Cale> The basic idea is to write your algorithm without caring about IO, then worry about how IO and system side effects will happen after the fact. (Well, the order doesn't matter, but the separation does)
18:11:49 <keir> Cale, ok. but what if my algorithm needs a bunch of random numbers during it's recursion?
18:12:10 <Lor> Use a state monad for the random number state.
18:12:11 <keir> do a helper version that passes along a randomIO monad?
18:15:52 <Cale> You might just have it take a list of numbers.
18:16:08 <Cale> (Ordinary Integers, say)
18:16:08 <keir> Cale, that's so ugly thougH!
18:16:46 <Cale> What does it need to do?
18:16:53 <Cale> It might just be some fold.
18:16:57 <keir> oke
18:17:02 <keir> i'd like to randomize a list
18:17:21 <keir> i'm sure there's some super clever way
18:17:38 <keir> but what i'd like to do is just randomly pop elements from the first list, and push them to another
18:18:00 <keir> and at the end  your original list is empty and the new list is a randomized version of the first.
18:18:16 <keir> it's like 2 lines in python
18:18:48 <keir> x=[]
18:18:56 <phubuh> There is a function for getting an Int from an IO Int!
18:19:02 <phubuh> @type (>>=)
18:19:03 <lambdabot> (>>=) :: Monad a => a b -> (b -> a c) -> a c
18:19:21 <keir> while y: x.append(y.pop(random.randInt(0,len(y)-1)))
18:19:21 <Cale> phubuh: sort of :)
18:19:51 <Lor> You cannot open the box, but you can go inside the box for a while. You just have to come out of there. :)
18:20:42 <keir> ok i did it in 2 lines of python. can it be done so succintly in haskell?
18:21:44 <Smerdyakov> Misleading question.
18:21:59 <Smerdyakov> Python is a weak enough language that you might need language support to do things like that succinctly.
18:22:20 <Smerdyakov> You can let yourself do most _anything_ that succinctly in Haskell by creating reusable and general functions.
18:22:50 <keir> Smerdyakov, so what? are the functions there? i don't have to write them in python. Why should i have to write them in haskell?
18:23:20 <keir> if haskell claims to be strong anyway
18:23:36 <Smerdyakov> For one thing, you used imperative code there.
18:23:37 <phubuh> Strong doesn't equal having a huge number of built-in things.
18:23:45 <keir> Smerdyakov, so what.
18:23:51 <Smerdyakov> So Haskell is a functional language....
18:25:20 <keir> Smerdyakov, are you implying that functional languages can't do that as succintly as imperative languages?
18:25:31 <keir> so it's an unfair comparasin?
18:25:41 <phubuh> I would agree.
18:25:48 <Smerdyakov> No. I'm probably saying irrelevant things.
18:25:53 <phubuh> Where 'that' is the imperative version of that algorithm.
18:26:27 <keir> anyway
18:26:28 <Smerdyakov> But I think if you consider writing reusable code a waste of time because some other compiler comes with an equivalent in its standard library, you're missing the point.
18:26:41 <keir> Smerdyakov, i agree, writing reusable code is great
18:27:09 <keir> Smerdyakov, it's even better if someone else has already written it. (as is usually the case with python)
18:27:50 <Cale> http://okmij.org/ftp/Haskell/perfect-shuffle.txt -- here's a writeup on how to do really good shuffling
18:27:59 <keir> Cale, i saw that
18:28:03 <Cale> and by really good, I mean perfect :)
18:29:38 <Smerdyakov> keir, I don't think that is a significant advantage.
18:30:48 <keir> Smerdyakov, then... i don't know how to respond. i'd love to reimplement lots of stuff, but lets face it, who has time when time is $$$?
18:31:30 <phubuh> Don't use Haskell, then.
18:31:35 <keir> phubuh, exactly.
18:31:41 <keir> phubuh, i'm learning Haskell for fun
18:31:50 <phubuh> It's pretty obvious that Haskell isn't exactly rich with libraries.
18:32:22 <phubuh> So if your income relies on having a bunch of libraries, it's not the language you want to use.
18:32:30 <keir> :)
18:32:45 <keir> it's never that simple though :(
18:32:57 <Smerdyakov> Creating interfaces to existing libraries is trivial.
18:32:59 <keir> often i miss functional programming when forced to do the odd PHP job or whatever
18:33:20 <Smerdyakov> The only thing standing in your way of implementing interfaces to all libraries you could want is unjustifiable lazyness.
18:33:53 * keir steps off the flamepodium
18:33:57 <keir> this is pointless
18:33:58 <keir> anyway!
18:34:02 <phubuh> Laziness is one of the three virtues. :-)
18:34:11 <Smerdyakov> It's not really pointless.
18:34:24 <Smerdyakov> I don't think "lack of library support" is a valid reason for not using a language that has a good compiler with a good C FFI.
18:34:46 <keir> a good C FFI is great if you only need to access C libs
18:34:57 <phubuh> The entire point of developing new language technology is to let us be lazier.  Heck, technology's express purpose is to let mankind be lazy.
18:35:07 <Smerdyakov> It's rare that you'll want to use a library without a C equivalent.
18:35:47 <keir> Smerdyakov, have you done much high-pressure web work? i'm not proud that i have, but i have.
18:36:36 <Cale> Isn't there also FFI to c++, .net and java as well?
18:36:47 <Darius> \rs -> map snd . sortBy (\(a,_) (b,_) -> compare a b) . zip rs and pass in a list of random numbers (e.g. randoms gen)
18:36:57 <Smerdyakov> keir, depends on your standards. I think I have, though.
18:37:16 <keir> Smerdyakov, did the others in your team program in functional languages?
18:37:17 <Smerdyakov> keir, and frankly, I don't care about anything related to capitalism.
18:37:41 <Smerdyakov> keir, factors that would lead you to make decisions based on lack of clued-in-ness of coworkers don't matter to me.
18:37:55 <keir> :) ok.
18:38:05 <keir> Darius, cool
18:46:00 <Cale> otoh, perhaps Data.Permutation would be a good idea.
18:51:05 <Lor> Not really, it's a three-liner.
18:51:17 <Lor> But lots of similar utilities together might make a sensible module.
18:51:23 <Cale> right
18:51:29 <Lor> I just implemented a multisets function.
18:51:47 <Lor> The trivial version is a three-liner, the efficient one a four-liner
18:52:03 <keir> code online?
18:52:15 <Lor> Uh, I can paste it if you want.
18:52:24 <Cale> I've been thinking about writing something to work with generating series in (arbitrarily many) noncommuting indeterminates.
18:52:28 <Lor> multiSets  _       0  = [[]]
18:52:28 <Lor> multiSets  []      k  = []
18:52:28 <Lor> multiSets  (x:xs)  k  = map (x:) (multiSets (x:xs) (k-1)) ++ multiSets xs k
18:56:19 <Cale> Something for multiplying permutations, generating the kth permutation on 1..n, etc, might be nice to have in a library.
18:56:58 <Cale> Actually, a group theoretic library would be really nice to have.
19:02:23 <keir> what module do i need for the State monad? e doesn't seem to work.
19:02:35 <keir> s/ e /State
19:03:20 <Cale> http://haskell.org/ghc/docs/latest/html/base/Control.Monad.State.html
20:00:37 <keir> ah, it was because i was using hugs.
20:00:51 <keir> an apt-get install ghc6 later, it works
20:03:42 <keir> is there a cleaner way of doing this: [0 | x <- [1..10]]
20:04:55 <Riastradh> @prelude replicate
20:04:55 <lambdabot> ERROR: does not exist
20:04:55 <lambdabot> Action: connect
20:04:55 <lambdabot> Reason: Connection refused
20:04:58 <Riastradh> ...
20:05:01 <Riastradh> @type replicate
20:05:01 <lambdabot> replicate :: Int -> a -> [a]
20:05:08 <Riastradh> @eval replicate
20:05:08 <lambdabot> <<EM Dynamic -> EM Dynamic>>
20:05:12 <Riastradh> @eval replicate 10 0
20:05:13 <lambdabot> [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
20:05:33 <keir> ah, excellent
20:13:25 <keir> what does $ do?
20:14:15 <keir> oh great, my code that worked in hugs doesn't in ghc
20:17:20 <Riastradh> f $ g = f g
20:17:34 <phubuh> $ is just function application with a -very- low precedence.
20:17:36 <Riastradh> But it has the lowest precedence.
20:17:38 <Riastradh> Bah!
20:17:43 <phubuh> Hee hee.
20:17:46 <keir> ah, so same as .
20:17:54 <phubuh> No, . is function -composition-.
20:18:03 <phubuh> f . g = \x -> f g x
20:18:15 <keir> oh, right
20:18:18 <phubuh> err, f (g x)
20:18:49 <keir> using f and g made me think composition
20:18:58 <keir> f $ x = f x would be better ;)
20:19:38 <phubuh> Instead of length (replicate 10 (5 + 1)), you can do length $ replicate 10 $ 5 + 1.
20:19:47 <Cale> $ is somewhat related to composition though, in that when you have a large composition of functions, it's often handy to remove brackets with it.
20:19:49 <phubuh> I nominate that as the world's most contrived example!
20:20:02 <keir> haha
20:20:18 <keir> more appropriately, $ is lo-precidence ' '
20:20:27 * keir cannot type or spell today
20:20:32 <phubuh> Yup.
20:20:54 <keir> i'm still lost with monads
20:21:13 <keir> are there any small example programs that do reasonable amounts of monadic stuff?
20:21:13 <Riastradh> keir, monads are just CPS, but not restricted to functions.
20:21:25 <Riastradh> m >>= k   installs k as the continuation for the computation m.
20:21:43 <keir> oh, interesting
20:21:56 <Riastradh> return x   invokes the current continuation with x.
20:24:01 <Cale> http://haskell.org/hawiki/HaskellNewbie -- I recently answered a question on how to do some directory manipulation stuff there. Not sure if it's what you're looking for, but there's a small example that I've annotated.
20:24:12 <keir> ok
20:26:32 <Cale> http://www.nomaware.com/monads/html/analogy.html -- this analogy is also good
20:26:46 * ayrnieu wonders, very aside, why he feels this compulsion to work with Haskell again when it's so unsuitable for the programs he likes to write.
20:27:01 <phubuh> ayrnieu, what are those programs?
20:27:03 <keir> ayrnieu, hey, haven't talked to you in awhile!
20:27:28 <keir> ayrnieu, or are you the #python person i seem to remember?
20:27:35 <ayrnieu> keir - hello.  erm, do I know you in another name?  I'm sorry if I've forgotten you.  Also, probably.
20:27:51 <keir> ayrnieu, possibly drom?
20:28:00 <keir> ayrnieu, no worries, it's been years
20:28:20 <ayrnieu> keir - you may remember me more recently as cleverdra.
20:28:50 <keir> Cale, yes, i read that analogy. i think it's just the Random module that throws me for a loop
20:29:03 <keir> the examples all seem stupidly obtuse
20:29:15 <Riastradh> OH!  I thought you acted familiarly, ayrnieu!
20:29:53 <phubuh> http://www.nomaware.com/monads/html/meet.html#maybe was helpful for me when I didn't understand monads.
20:29:59 <Cale> You can think of the random generators in a similar way to a user typing in random numbers.
20:30:26 <keir> i understand the idea that you use a monad to handle the state of the RNG
20:30:28 <Cale> yeah, that nomaware tutorial is really good
20:31:03 <isomer> Riastradh: cool way to look at monads; thanks!
20:31:08 <ayrnieu> phubuh - easily extendable UI programs -- an IRC client, for instance, which I could have bring up an $internal 'channel' to write code in that modifies the client.  A server that does almost nothing that could have features piled on it over weeks without ever ever stopping.  This kind of thing I can do in Lisp, Scheme, and Erlang -- but not so much in Haskell.  But I *like* Haskell, and Haskell keeps taking on qualities that m
20:31:08 <ayrnieu> ake me like it more, such as Concurrent Haskell and Template Haskell.
20:32:11 <ayrnieu> phubuh - so obviously I have to fight the compulsion down or discover a development model and an application that I'd like to use Haskell to deal with.
20:32:38 <phubuh> Write an Erlang compiler in Haskell. :-)
20:33:43 <ayrnieu> =) Eventually they'll make a Dynamic Haskell, I'm sure.
20:34:55 <Cale> rollDice :: IO Int
20:34:55 <Cale> rollDice = getStdRandom (randomR (1,6))
20:34:59 <Cale> is a good example
20:37:01 <phubuh> Hey, what temperature should I use to pop popcorn?
20:37:09 <Cale> then rollDice is a little 'box' that you can pull random numbers from
20:38:06 <keir> Cale, yup. i got that one too :) i think i just need to give up and admit that my list randomizer has to be of type IO [a]
20:38:20 <phubuh> It does not!
20:38:26 <Cale> oh, so you need a bunch of random numbers?
20:38:38 <keir> specifically, i need to permute an already-existing list
20:38:42 <ayrnieu> Calc - I think he wants to randomly sort a list.
20:38:47 <phubuh> It can take the seed as an argument.
20:39:06 <keir> phubuh, that would work ok
20:39:10 <ayrnieu> also, randomly permute.
20:40:00 <phubuh> Fight IO when it tries to take over your functions. :-)
20:40:25 <ayrnieu> keir - would taking the seed as an argument really work OK?
20:40:27 <keir> the problem is that i'm too green to haskell to do battle with the standard library
20:40:53 <keir> at this point, i'm not concerned... i just want to get it working!
20:42:04 <phubuh> By all means -- do!  I don't see any particularly convincing reasons to not make it an IO action, I was just pointing out that it's possible.
20:42:54 <ayrnieu> phubuh - the normal temperature, if this is a fire or a microwave -- the important part is to monitor the popping sound.  You'll start with nothing, and then start to hear a little, and then you'll hear a great of popping.  Open the microwave when this great deal of popping slows down.
20:43:16 <phubuh> It's an oven, but thanks!
20:44:09 * ayrnieu doesn't know why he immediately feels that an oven is overkill.
20:45:56 <phubuh> Err, I mean a stove. :-)
20:48:47 <keir> @fst
20:48:48 <lambdabot> Sorry, I don't know the command "fst", try "lambdabot: @listcommands"
20:48:59 <keir> what does fst do?
20:49:11 <keir> http://www.nomaware.com/monads/examples/example15.hs
20:49:20 <keir> at the bottom they use it for some reason
20:49:28 <Cale> gets the first entry of a pair
20:49:39 <Cale> @eval fst (1,2)
20:49:40 <lambdabot> (line 1, column 7):
20:49:40 <lambdabot> unexpected ","
20:49:40 <lambdabot> expecting digit, operator, simple term or ")"
20:49:50 <Riastradh> @type fst
20:49:50 <lambdabot> fst :: (a,b) -> a
20:50:06 <Riastradh> @type (1,'a')
20:50:06 <lambdabot> (1,'a') :: Num a => (a,Char)
20:50:12 <Riastradh> @type fst (1,'a')
20:50:13 <lambdabot> fst (1,'a') :: Num a => a
20:51:50 <keir> man this is so ugly. my whole program is going to have to be IO ...
20:52:07 <Riastradh> Fight it back!
20:52:11 <keir> i plan to
20:52:11 <Cale> keir: what does your program have to do?
20:52:12 <Riastradh> Give it all you've got!
20:52:17 <keir> play cards!
20:52:25 <keir> i've got my Card data definition now! 
20:52:33 <keir> but i have to shuffle the deck
20:52:49 <keir> and then each player gets 12 cards
20:52:51 <Riastradh> Randomness is pretty inherently impure.  Making it pure is just silly and viral.
20:53:59 <keir> then, as the players take turns, they put their cards on a 5x5 grid (where the last card after the 24 delt cards goes in the middle)
20:54:11 <keir> and according to some rules one player wins at the end
20:57:42 <Cale> well, here: http://vx.hn.org/dice.hs -- there's one way to randomly permute a list
21:02:51 <Cale> The idea is to code your actual algorithm outside the IO monad, and the rest of the stuff (UI / IO / getting the random numbers needed, etc) inside it.
21:03:22 <keir> yes, i see! thanks. i've been staring at the code
21:03:38 <keir> it's pretty much exactly how i wanted to do it
21:03:46 <keir> but there was a gap between my head and haskell
21:06:11 <Cale> so your algorithm might take a hand of cards and a partially filled in grid and decide where to play. This can be done without the IO monad.
21:06:23 <keir> yes, that's my plan
21:06:35 <keir> now, to Array or to nest lists...
21:06:55 <keir> are Array's monads?
21:07:30 <Cale> I don't think so.
21:07:33 <Cale> Lists are
21:09:29 <Cale> that is, lists are an instance of Monad - people usually don't think of them that way though
21:10:10 <Cale> I usually find lists a bit more convenient than arrays. Personally, I'd go with the list of lists.
21:10:19 <keir> ok
21:11:48 <keir> hrm...
21:11:51 <keir> this is interesting.
21:12:00 <keir> i want null spaces, or empty cards
21:12:13 <keir> but i can't have a 0 or [] in a list entry, then a card in another
21:12:20 <keir> ie lists are homogenous
21:12:31 <Cale> Maybe
21:12:41 <keir> Maybe Card
21:12:42 <keir> ok
21:17:13 <Cale> hmm... I'm wondering if perhaps an array would be better for you after all. It does have some things like (//) that might be handy.
21:19:07 <Cale> The board would be an Array (Int,Int) Card
21:19:23 <Cale> or an Array (Int,Int) (Maybe Card)
21:21:43 <Cale> though, arrays are a bit stranger than lists.
21:25:27 <Cale> Well, it's up to you -- both have their advantages and disadvantages.
21:30:32 <keir> ok
21:30:57 <keir> where can i find out what things like // do?
21:32:22 <keir> ah, got it
21:40:56 <keir> ahah, so foldl/foldr is like reduce
21:43:49 <keir> say you have a list of functions
21:43:57 <keir> and you want  to apply an argument to each of the functions
21:44:05 <keir> and get a list of the results
21:44:12 <keir> how would you do that? kinda like map, but backwards
21:45:39 <Darius> map ($arg)
21:46:23 <keir> excellent! that's what i htought but i didn't think it would work.
21:48:50 <keir> is there a concise version of length filter (...)
21:48:56 <keir> or should i just use length filter...
21:53:17 <ayrnieu> consiseLengthFilter = length filter
21:53:23 <keir> :)
21:53:29 <ayrnieu> or no?  I'm still compiling.
21:53:34 <Darius> I don't think there's anything more concise, there are certainly things more efficient.
21:53:36 <keir> i was thinking more in terms of not needing to create an intermediate array
21:54:04 <keir> i've been writing too much 68k assembly lately
21:54:16 <keir> and vhdl is never good for the brain
21:54:30 <Darius> Use BlueSpec
21:55:19 <keir> their page seems to be down
21:55:50 <keir> anyway, i've no choice as to vhdl. i'm editing someone else's multi-thousand line vhdl monstrosity
21:56:08 <keir> without comments to boot!
21:57:08 <ayrnieu> OK, I'm going to go ahead and write a mud client in Haskell with a mind towards easy extensibility, and see how that works.  Obviously I'll have to disconnect to update the client -- but with a local re-server I won't miss anything (and it's a mud client, anyway, so constant uptime isn't the point).
21:57:59 <Darius> ayrnieu: Lambdabot uses GHC's internal dynamic loading support
21:58:00 <keir> once i checked and BitchX had an uptime of > 300 days
21:58:11 <Darius> If shapr were awake you could get him to load something
21:58:13 <keir> unfortunately my colo bad some power problems so i lost the uptime
21:58:23 <Darius> @listcommands dynamic
21:58:24 <lambdabot> Module dynamic provides the following commands: ["dynamic-load","dynamic-unload","dynamic-reload"]
22:04:12 <ayrnieu> hm.
22:04:43 <ayrnieu> Verry eeenteresting.
22:39:14 <keir> choose n k | n >= k     = factorial n / (factorial k * factorial (n-k))
22:39:15 <keir>            | otherwise  = 0
22:39:23 <keir> No instance for (Fractional Int)
22:39:24 <keir> odd!
22:43:16 <keir> interesting! how to prove n choose k is integer...
22:49:56 <Darius> Use div
22:50:05 <keir> yup
22:50:10 <keir> just got it going
22:56:43 <ayrnieu> What's the current version?
22:57:44 <ayrnieu> keir - of your code.  curiously.
22:58:23 <keir> current version? uh... total junk code because i'm only slowly understanding haskell
22:58:36 <keir> although now i have one part of the hand scoring function orking
22:58:42 <ayrnieu> curiously =)  You just got it working.
22:58:58 <ayrnieu> ah.  What are you trying to do beyond that function?
22:59:45 <keir> a card playing game
22:59:49 <keir> eventually with AI
23:01:14 <keir> nothing fancy
23:02:23 <keir> just a tester project that i thought would be a good haskell starter
23:08:01 <keir> is where like let*?
23:08:22 <ayrnieu> keir - there's a let, also.
23:08:47 <ayrnieu> keir - 'let' seems more like let* and 'where' more like let, I think.
23:09:06 <keir> so let allows definitions to depend on previous definitions in the let block?
23:09:42 <ayrnieu> I'd love to just write a quick program and tell you, but I'm still compiling.
23:09:52 <keir> hehe, ok np
23:10:30 <ayrnieu> I think that both allow that, though, and that let is special in that you can use it mid-definition -- but that's very fuzzy.
23:11:00 <keir> that's what i was planning ;)
23:12:08 <ayrnieu> I forget how to deal with let/where shadowing or not shadowing outer bindings.
23:17:52 <keir> ghc is pretty slow :(
23:18:23 <keir> my code has a nested let... so ugly.
23:28:16 <ayrnieu> 'where' tends to be much nicer -- and ghc is slow because it's a native-code compiler and has a lot of work to do =)  Try hugs or ghci, maybe.
23:28:20 <Darius> let and where are 'letrecs' all bindings are visible to all others in a group.
23:28:29 <keir> ok
23:28:57 <ayrnieu> I guess you ned nested lets for more complex binding-interaction, then.
23:29:12 <Darius> The only reason for let* is side-effects or non-termination, neither of which can happen when simply defining things in Haskell.
23:29:21 <ayrnieu> keir - use 'where' and multiple functions.
23:29:30 <ayrnieu> Darius - well, let* also differs from let with the scope of bindings.
23:30:06 <Darius> Yes, but the only reason it does that is because of side-effects or non-termination.
23:30:21 <ayrnieu> Darius - err, capitalizing for non-Haskell: a LET* is like a shorthand for nested LETs as far as bindings are concerned, LET bindings are made in parallel.
23:30:43 <ayrnieu> Darius - presumably the part that has any bearing on Haskell is the part of interest =)
23:31:03 <ayrnieu> Darius - how can I do a LET, where no bindings from the LET are visible within the bindings made?
23:31:16 <ayrnieu> a LET, from the let.  sorry.
23:34:10 <Darius> You can't, but the only thing that 'disallows' is something like let' x = x in ... where the inner x refers to something in an outer scope.
23:34:47 <Darius> (actually, you could use lambda)
23:35:15 <ayrnieu> let x = \y->x in ... ?
23:35:23 <ayrnieu> err,
23:35:32 <ayrnieu> let x = (\y->x) x in .. ?
23:35:37 <ayrnieu> NEVERMIND
