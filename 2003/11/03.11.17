01:00:59 <magr> good morning, #haskell
01:02:01 <Lunar^> magr: morning
01:14:58 <phubuh`> hey!
01:24:57 <phubuh`> how do I perform efficient I/O of UArrays on sockets?  the send functions wants a String, but I don't like the idea of consing up a list of like sixty thousand bytes all the time.
01:26:14 <Lunar^> mhhhh
01:29:37 <Lunar^> In unix package : System.Sendfile
01:29:54 <Lunar^> Mhh... you've got an UArray... sorry
01:31:13 <phubuh`> ooh, that's a good suggestion, actually
01:31:40 <phubuh`> the large things I send are files, I could probably just use String for the rest -- they're just short control commands
01:31:55 <Lunar^> I think this one was created for hws
02:07:48 <phubuh`> oh, cool
03:45:42 <ham[home]> shapr: hiho
05:01:17 <shapr> hohi
05:01:18 * andersca_ bounces
05:02:48 <phubuh> zoing
05:04:07 * shapr boings
05:04:30 <Lunar^> hi shapr 
05:06:51 <shapr> hi Lunar^ 
05:06:53 <shapr> what's up?
05:08:19 <Lunar^> shapr: following an intern course on Zope
05:08:30 <Lunar^> shapr: Not that much intrested though
05:08:41 <shapr> well, it's commercially viable
05:08:42 <shapr> that much I know
05:08:48 <Lunar^> I know that
05:09:06 <shapr> I wish I had something better written in Haskell :-)
05:09:43 <Lunar^> shapr: Right
05:10:08 <Lunar^> shapr: There's so much answer I think quite bad to interesting problems
05:10:28 <Lunar^> shapr: I do not see anything not writable in Haskell...
05:12:03 <Lunar^> How speedy is wxHaskell ?
05:12:13 <shapr> I haven't tried it.
05:12:17 <shapr> I heard rumors that earthy has tried it.
05:23:20 * isomer stumbles in
05:23:20 * juhp didn't notice any speed problems with wxHaskell when i tried it a while back...
05:23:24 <isomer> ouch
05:23:29 * isomer bangs chair
05:23:50 <juhp> it was more the lack of unicode/utf-8 support in wxwindows that worried me iirc
05:26:01 <shapr> hi juhp 
05:26:48 * phubuh says something to make the ERC> status thing update itself
05:26:50 <phubuh> ah, there!
05:27:50 <shapr> hi phubuh 
05:27:57 <phubuh> hey shapr!
05:28:01 <phubuh> what's up?
05:28:12 <shapr> work..
05:28:48 <phubuh> fun work?
05:30:16 <shapr> it's Python/Zope, so at least I'm working with open source software
05:30:17 <shapr> and linux
05:30:26 <phubuh> that's nice
05:30:31 <shapr> as things go, that's really nice
05:30:48 <shapr> I used to do Java on Windows, so this is great.
05:30:58 <phubuh> yech!
05:31:34 <Lunar^> juhp: I need to be really really fast : it's for a CoreWar VM display
05:31:54 <shapr> yay corewars!
05:34:25 <Lunar^> shapr: wrote the assembler in less than 24 hours, 389 lines
05:34:56 <Lunar^> shapr: using lazynes to make only one pass to compute expression with label positions
05:35:00 <Lunar^> that rocks :)
05:35:44 <Lunar^> It's a shame not to have a nicer way to write binary files than hPutChar with ord
05:36:08 <Lunar^> It seems to be really better in future standard lib though
05:36:54 <phubuh> yay, I can use a 24 px font and still fit 80 chars on one line
05:37:18 <Lunar^> lol
06:10:36 <shapr> jiihaa
06:11:35 <vardhan> looking for a second hand SOE, can somebody ship to India ?
06:12:15 <shapr> huh?
06:12:22 <shapr> what's SOE?
06:12:38 <phubuh> (the haskell) school of expression?
06:12:41 <shapr> oh
06:12:41 <vardhan> Haskell School Of Expression
06:12:44 <shapr> doh
06:13:19 <shapr> I have only one copy, and I want to hang onto it...
06:13:36 <shapr> vardhan: have you checked out YAHT and the HaWiki?
06:14:08 <vardhan> reading dead-tree can not replace reading online.
06:14:57 <vardhan> the trouble is ... which first program to write ? books provide some problems to work on
06:15:21 <shapr> start with something simple that doesn't do IO
06:15:44 <shapr> or at least, doesn't do much IO
06:17:02 <vardhan> i tried some function which tries to read complete file as list, tried html parsing.
06:17:29 <phubuh> is it just me, or is haskell mode shoddy at indenting case statements?
06:17:36 <phubuh> shoddy as in "completely incapable"
06:17:44 <shapr> vardhan: did those work?
06:17:54 <vardhan> almost (-;
06:17:58 <shapr> phubuh: are you using C-c | ?
06:18:02 <shapr> or C-c o ?
06:18:19 <phubuh> I don't have any idea what those are
06:18:49 <phubuh> oh, I mean regular plain case statements without pipes
06:19:25 <shapr> oh, yes
06:19:29 <shapr> it does suck with those
06:19:44 <phubuh> oh well, I don't have huge case statements anyway
06:20:10 <shapr> vardhan: best thing to do is to come here, and ask about your almost working programs
06:20:17 <shapr> we can probably help you find out what's wrong with them
06:20:22 <Lunar^> phubuh: depends where you put the "of" actually
06:20:25 <phubuh> ooh
06:20:56 <Lunar^> phubuh: If you do "case cond\n of One -> ...\n Two -> ..." it works
06:20:56 <phubuh> where should I put it? case x of\n  Foo -> bar\n  Bar -> baz is what I'm doing now
06:21:02 <vardhan> some tips on how to get around infinite years of C ?
06:21:20 <vardhan> somehow 'thinking in haskell' seems difficult.
06:21:33 <phubuh> Lunar^: nope, it doesn't work there either -- try this:
06:21:47 <Lunar^> phubuh: It works for me I think
06:21:50 <phubuh>           tick (\x -> case x
06:21:51 <phubuh>                 of Just (AsyncRead s) -> putStrLn s
06:21:51 <phubuh>                 Nothing -> return ())
06:22:08 <Lunar^> phubuh: parenthesis kills every indent
06:22:17 <Lunar^> phubuh: doesn't work with "do" either
06:22:20 <phubuh> ohh!
06:22:25 <phubuh> doh!
06:22:31 <Lunar^> $ is your friend
06:22:43 <phubuh> oh hey, it works perfectly without them!
06:23:59 <phubuh> but I realized I need to pass another argument :(
06:24:24 <Lunar^> flip tick arg $ ?
06:24:42 <phubuh> yeah, I could do that, or I could factor the lambda into a let
06:25:01 <Lunar^> in every case.. that sucks
06:25:12 <phubuh> indeed :(
06:42:04 <phubuh> yay, non-blocking I/O works
06:42:30 <Lunar^> phubuh: What trick ?
06:42:51 <phubuh> no tricks here :-)
06:43:09 <Lunar^> What's doing it ?
06:43:26 <phubuh> my soon-to-be Direct Connect client
06:43:41 <Lunar^> In Haskell ? neat ! :)
06:43:46 <phubuh> indeed!
06:46:09 <drlion> hey phubuh, speaking about non-blocking i/o... i gather you've noticed my i/o is slightly blocking :-)
06:46:29 <phubuh> huh?  hi, by the way
06:48:16 <phubuh> I'm trying hard to get that
06:50:00 <phubuh> compiling with GHC verbosity level 5 is exciting
06:50:56 <drlion> i'm having major problems typing this because 1) thiskeyboard has a defect spacebar (among otyher keys) and 2) about 15 torrentsare satiurating our bandwith and givingme like 2 seconds latency
06:51:20 <phubuh> haha
06:54:48 <shapr> coi drlion 
06:54:50 <shapr> ma nuzba
06:55:14 <shapr> xu do tavla mi fo la lojban
06:58:02 <SyntaxPolice> hey shapr
06:59:58 <drlion> dotavlamilenumitavlado
07:00:43 <shapr> geez, speak only when you're spoken to :-)
07:00:43 <drlion> hahathat's cool. lojban is thebest languageever for notrequiring spaces
07:00:47 <shapr> hi SyntaxPolice 
07:00:50 <shapr> komodo
07:04:42 <drlion> la capr. mo
07:04:50 <shapr> la xaskel xamgu lenu do ciska samselpla
07:05:16 <shapr> zo'o la capr xamgue 
07:05:23 <shapr> zo'o la capr xamgu
07:05:41 <shapr> lojban is fun
07:06:18 <drlion> yeah, too bad i suck at it :-)
07:06:48 <shapr> I've been working on learning LogLan/lojban since the late 80s, and I haven't really succeeded yet.
07:07:06 <drlion> haha thanks for the encouragment :-)
07:07:11 <shapr> :-)
07:07:32 <shapr> the lojban community is sort of strange
07:07:45 <shapr> anyways, back to work...
07:12:24 <phubuh> drlion: did you finish porting stringx.ml to Haskell?
07:15:34 <Marvin--> has anybody here used Curry?
07:16:00 <Lunar^> Marvin--: I have to documentation sitting on my paper stack for a while now
07:16:10 <Lunar^> didn't find the time to read it :(
07:17:26 <Marvin--> I just thought that I ought to at least mention it in my report
07:18:17 <Marvin--> but, well, I don't know anything about it :)
07:18:21 <drlion> phubuh: nope, but if you needit now andwant to port it yourself, here's the better version: http://teepee.ath.cx/~drlion/stringx.ml
07:18:29 <phubuh> oh, cool
07:19:45 <harsha> hello all
07:19:49 <harsha> hi shapr :)
07:20:39 <harsha> scarface1 hello
07:20:50 <scarface1> harsha hello
07:22:33 <Marvin--> I'm wondering if Curry can be made to find counterexamples to quickcheck properties
07:23:00 <harsha> yep, you want some intro's ?
07:24:25 <phubuh> forever = sequence_ . repeat should be in Monad :-)
07:24:39 <harsha> shapr u there?
07:24:46 <phubuh> hey harsha
07:24:52 <harsha> hi phubuh , sup?
07:25:01 <phubuh> not much
07:25:19 <shapr> harsha: eh?
07:25:27 <harsha> scarface1 www.debian.org
07:25:36 <harsha> shapr hi
07:25:43 <harsha> scarface1 what?
07:25:50 <harsha> scarface1 download what?
07:25:59 <shapr> I'd like to see a standard QuickCheck property be "for any other input, this function will react in a set way"
07:26:03 <shapr> that would test failure conditions nicely
07:26:41 <Marvin--> shapr: what do you mean?
07:27:20 <shapr> I was just thinking about testing tcp/ip stacks, and how the Oulu guys cracked Nokia phones by sending invalid input
07:27:35 <shapr> QC wouldn't find that class of errors
07:28:10 <harsha> shapr meet my friend scarface1 , hez intersted in functional programming..:)
07:28:14 <shapr> at least, not with the sort of testing shown in the QC papers.
07:28:19 <shapr> hi scarface1, nice to meet you
07:28:37 <harsha> shapr hez been my friend since childhood!
07:28:42 <Marvin--> shapr: um, how so? the properties state "for any x, y and z, ..."
07:29:11 <phubuh> I read that as "shapr has been my friend since childhood!"
07:29:30 <shapr> actually, I don't have any childhood friends, I moved around the US too much.
07:29:40 <shapr> harsha: you're forming your own functional cabal :-)
07:30:15 <shapr> Marvin--: I think there should be the opposite, "for anything other than x, y, and z this function will always throw an exception"
07:30:18 <harsha> shapr : hm.. :) am learning.. hehehe
07:30:27 <harsha> scarface1 hey are you there?
07:30:39 <scarface1> hi shapr nice to meet u 2..
07:31:09 <shapr> scarface1: so, is harsha really as energetic in person as he is on irc?
07:31:16 * shapr grins
07:31:34 <harsha> hehee, energetic? am dull as a snail :)
07:32:07 <harsha> and so is my wisdom
07:32:08 <Marvin--> I'm *so* not going to be able to compile pakcs
07:32:25 <Marvin--> I need sicstus *and* java? WTF?
07:32:30 <scarface1> shapr: he certainli aint tis enrgetic.. hehe 
07:33:44 <shapr> he always seems bouncy here...
07:33:56 <Marvin--> says shapr
07:34:01 <shapr> Marvin--: what do you think? is predictable failure not worth testing?
07:34:11 * shapr bounces
07:34:30 <Marvin--> shapr: it's a whole lot *harder* to do *inside* haskell
07:34:40 <shapr> Marvin--: am I as bouncy in person as I am on irc?
07:35:00 <Marvin--> shapr: since bouncy /= energetic, no :)
07:35:16 <harsha> shapr, scarface1 has an admission in Univ. of michigan, ann arbor what do you think?
07:35:32 <shapr> sounds great
07:35:40 <shapr> I've heard good things about that Uni
07:35:46 <harsha> ok..
07:35:52 <harsha> are they into haskell?
07:35:55 <harsha> or languages?
07:36:16 <shapr> I haven't heard of any FP stuff from there.
07:36:23 <harsha> hmm ok..
07:36:37 <scarface1> harsha: im here dude
07:36:44 <Marvin--> shapr: but seriously, I'm not quite following what you want to do
07:37:01 <harsha> scarface1 ok
07:37:20 <Marvin--> shapr: let's take x ^ y, this should fail for x = y = 0, right? what do you want to do about it with QC?
07:37:33 <shapr> make sure that it does that
07:37:58 <phubuh> shouldn't it just return 1?
07:38:10 <shapr> basically, most software testing checks for correct output when given correct input, not checking for safe output when given incorrect input.
07:38:12 <Marvin--> so, can't you do that with a clever use of catch?
07:38:23 <Marvin--> phubuh: no, 0^0 is undefined in most of the civilized world
07:38:31 <phubuh> oh.
07:38:46 <shapr> happily, I'm not civilized ;-)
07:38:52 <Marvin--> lim{x->0} x^x is well-behaved, but 0^0 is undefined
07:40:30 <Marvin--> actually, I don't know about lim{x->0-} x^x
07:40:35 <Marvin--> anyway
07:40:38 <Marvin--> shapr: can't you do it with catch?
07:41:04 <Marvin--> though that'd put you in IO and you're in a world of trouble
07:41:35 <shapr> I dunno, I'll think about that.
07:42:22 <Marvin--> but isn't it also useful to know *which* error it throws?
07:42:28 <shapr> yes
07:42:49 <shapr> it's most useful to know that it throws the same error for any invalid input
07:43:23 <shapr> some tcp/ip stacks can be put into an invalid state with a very specific set of inputs
07:43:49 <shapr> iirc, that's how the Oulu guys cracked Nokia's stuff
07:43:52 <Marvin--> so, hm, say we have a property p that QC assigns some random arguments e1...eN
07:44:29 * shapr boings
07:44:37 <Marvin--> if you also supply an Exception -> Bool function f, couldn't we have some QC function that does
07:44:49 <Marvin--> hmm
07:45:03 <harsha> brb,going out for dinner
07:45:03 <Marvin--> <internaluglyfunction> `catch` return . f
07:45:12 <Marvin--> and use the result of that
07:45:20 <shapr> sounds right
07:45:27 <shapr> I'd have to try it to see for sure
07:45:45 <Marvin--> well you'd have to hack QC, because there's no Property (IO a) instance :)
07:45:56 <Marvin--> it has to be done internall
07:46:27 <Marvin--> hm, actually, you'll want to know that it actually HAS thrown an exception too, if it doesn't throw an exception, that's an error
07:46:34 <shapr> I could just send an email to JH and see what he has to say about it.
07:46:50 <shapr> you do think I have a valid point though?
07:46:55 <Marvin--> of course
07:46:57 <shapr> yay
07:47:10 <Marvin--> but it also might move QC away from the "lightweight" part ;-)
07:47:35 <shapr> or JH might think up some brilliant way to incorporate it..
07:47:44 <phubuh> JH?
07:47:49 <shapr> John Hughes
07:47:55 <phubuh> ah, duh
07:47:58 <shapr> he wrote the first version of QuickCheck I think
07:48:13 <shapr> though I wish Koen and John would go ahead and merge their versions of QCM
07:49:24 <Marvin--> well, quickCheckFoo p f = do x <- evilfunction p `catch` return . Just . f -- where evilfunction could return Nothing if p does not throw an exception (since basically you have three cases, no exception, the right exception and wrong exception)
07:49:54 <shapr> I'll send him an email, see what he says.
07:50:10 <shapr> thanks for the discussion
07:51:54 <Marvin--> damnation, this problem seems to be too complicated for Eprover
07:54:04 <shapr> @fortune
07:54:05 <lambdabot> SEMPER UBI SUB UBI!!!!
07:54:05 <lambdabot> [ Always wear underwater ]
07:54:19 <shapr> always wear underwear underwater?
07:54:28 <shapr> I think there's a bug in that fortune.
07:54:30 <shapr> @fortune
07:54:30 <lambdabot> Time sure flies when you don't know what you're doing.
07:55:14 * Marvin-- swears
07:55:18 <phubuh> I wonder if I should order functions in top->down order or down->top order
07:56:03 <Marvin--> damn theorem prover can't even handle a 250-clause problem
07:56:22 <shapr> phubuh: I prefer top down because then I get to see the basic idea before the details
07:56:46 <shapr> lots of details before I know how to structure them is much harder for me to understand.
07:57:14 <phubuh> shapr: yeah, that's what I was thinking, but I naturally type the program in bottom-up order.  I suppose I could just start adding new functions spatially above the rest, though
07:59:05 <phubuh> M-x reverse-paragraphs would be useful
08:00:05 <Marvin--> grmbl, half these clauses come from the fact that Haskell function definitions are ordered
08:00:41 <Marvin--> when you have  f p1 = e1 ; f p2 = e2 ; ... ; f pN = eN ; f _ = eX  you have to generate a big load of extra stuff *sigh*
08:02:50 <Marvin--> oh well, I should go cook some dinner
08:15:48 <phubuh> http://www.phubuh.org/~phubuh/AsyncStream.hs.html :-)
08:19:51 <Lunar^> phubuh: neat
08:28:29 <Lunar^> phubuh: I still don't see how do you use it exactly
08:32:22 <phubuh> you presumably call asyncTick in a loop, checking for events, like ev <- asyncTick; case ev of Just (AsyncRead s) -> print ("read " ++ s); Nothing -> print "nothing happened"
08:32:39 <Lunar^> mhh ok
08:33:19 <phubuh> in my specific case, the AsyncRead handler will just stuff the data onto a buffer, and dispatch it when the buffer contains a pipe character
08:36:25 <Lunar^> phubuh: I want this quickly : http://haskell.org/pipermail/libraries/2003-August/001313.html
08:37:38 <phubuh> that would be nice
08:43:11 <scarface1> harsha : u der?
09:22:51 <andrewc> hi.  if anyone's there, could someone explain the following...
09:23:04 <ibid> yes?
09:23:23 <andrewc> yesterday Darius showed me that map.flip($) was the function i needed
09:23:29 <andrewc> for a certain problem
09:23:42 <andrewc> but what does the final ($) do?
09:23:56 <andrewc> @type map . flip ($)
09:23:57 <lambdabot> map . flip ($) :: a -> [a -> b] -> [b]
09:23:58 <Marvin--> ($) is function application
09:24:02 <ibid> $ is function application
09:24:04 <Marvin--> f $ x = f x
09:24:08 <andrewc> @type map.flip
09:24:08 <lambdabot> map . flip :: (a -> b -> c) -> [b] -> [a -> c]
09:24:39 <andrewc> i "understand" that at the simplest level.  like, it seems to do nothing.
09:24:39 <phubuh> f (flip ($)) x = x f
09:24:41 <Marvin--> andrewc: wrong, function application binds harder so it's map . (flip ($))
09:25:03 <Marvin--> @type flip ($)
09:25:04 <lambdabot> flip ($) :: a -> (a -> b) -> b
09:25:17 <andrewc> @type flip
09:25:18 <lambdabot> flip :: (a -> b -> c) -> b -> a -> c
09:26:00 <andrewc> sorry, i don't get it.  how does ($) change the type of flip so.
09:26:00 <Marvin--> the other day I used foldr id :-)
09:26:07 <Marvin--> @type ($)
09:26:07 <lambdabot> ($) :: (a -> b) -> a -> b
09:26:24 <phubuh> flip flips the order of arguments to a argument
09:26:25 <Marvin--> unify flip's a with $'s a -> b, and flip's b with $'s a
09:26:28 <andrewc> oh, hang on, maybe i'm thinking backwards
09:27:00 <andrewc> yes, i think i see.  thanks.
09:27:47 <andrewc> well, i see a new way to think.  i need to think more :o)
09:27:50 <andrewc> cheers.
09:28:11 <Marvin--> setting up equation systems for the unification helps
09:28:17 <Marvin--> (IME)
09:28:40 * Marvin-- deftly avoids working on his thesis by cleaning up the kitchen
09:29:21 <andrewc> i have no idea what that means (no comsci degree).
09:29:26 <Igloo> Boy are you getting desparate
09:30:04 <ibid> Marvin--: vacuumed the cat yet? :)
09:32:15 <andrewc> ok. i 've convinced my self i udnerstand that.  you were right, i had the binding strength mixed up.
09:34:01 <harsha123> scarface hi
09:34:36 <scarface> harsha: its k dude.. 
09:36:33 <Marvin--> andrewc: IME? In My Experience
09:37:49 <harsha123> scarface: why, why did you change your mind
09:38:18 <harsha123> scarface hmm... ok
09:38:27 <Marvin--> andrewc: repeat after me, application always binds hardest :-)
09:38:56 <harsha123> scarface scholarship, is it tuition waiver?
09:39:03 <Marvin--> I. can't. get. this. to. work.
09:39:30 <scarface> harsha:yes
09:39:48 <harsha123> scarface upto how much? is it complete?
09:40:01 <harsha123> scarface 100% waiver?
09:40:11 <ibid> \x -> i(can't(get(this(to(work x)))))
09:40:12 <scarface> 100% 
09:40:33 <harsha123> scarface thats great actually!
09:40:33 <andrewc> Marvin - no, "equation systems for the unification" :o/
09:41:20 <scarface> harsha: dats a mixed bag actualli..
09:41:35 <Marvin--> andrewc: oh. do you know what unification is?
09:41:54 <harsha123> scarface hmm.. i dont think so..
09:42:21 <harsha123> scarface cause your visa is now guranteed.!
09:42:29 <phubuh> I learned about unification by reading http://www-courses.cs.uiuc.edu/~cs321/current/lectures/view.php?num=Unification and doing the http://www-courses.cs.uiuc.edu/~cs321/current/mps/view.php?num=MP3
09:42:45 <phubuh> the machine problem is in O'Caml, though
09:42:47 <Marvin--> oh, goody, then I can go do my laundry instead of explaining it :-P
09:42:59 <phubuh> or you could work on your dissertation!
09:43:06 <andrewc> no.  (phubu: thanks)
09:43:06 <Marvin--> hahahaha
09:43:08 <Marvin--> funny
09:43:28 <Marvin--> (no seriously, I really need to do laundry, bbiab)
09:43:35 <phubuh> oh, bye :-)
09:43:46 <phubuh> gah, I can't type accented characters in stupid XF86
09:44:01 <phubuh> I cañ do tilded characters, though
09:44:11 <phubuh> ´ and ` appear immediately :(
09:44:13 <andrewc> bye, thanks!
09:44:20 <scarface> harhsa: well thks...
09:44:24 <phubuh> I really need to type these characters so I can use babelfish for my spanish homework
09:44:30 <andrewc> ok, yes, i did know what unification was.
09:44:47 <andrewc> hey, i can help with spanish homework (vivo en chile!)
09:44:54 <andrewc> (something i do know!)
09:45:20 <phubuh> I have this silly little booklet to read, and I don't know half the words :-)
09:46:25 <andrewc> what you need is a s. american boy/girl friend.  helps a lot.
09:46:28 <harsha123> scarface :) have fun,you lucky dude
09:47:42 <scarface> harsha: bull dude..im not lucki yet
09:48:14 <harsha123> scarface : ok, be confident man!
09:48:16 <scarface> harsha: luck = unlimetd sexy bitches +unltd $$$ :p
09:49:55 <harsha123> hehehe nevermind
09:54:31 <keverets> phubuh: make sure that you have some key defined as Multi_key (normally the right-Alt), then press (RightAlt), then (accent, eg, '), then the letter (all independantly).
09:56:40 <phubuh> oh, thanks!
09:57:26 <harsha123> scarface good luck man!
10:04:35 <harsha123> scarface ok :)
10:09:09 <harsha123> linux we have iptraf
10:09:31 <harsha123> it gets you both uplink and downlink speeds
11:12:33 <TripleDES> hi
11:29:21 <Igloo> Does ghci have something like hugs :set +s or did I imagine it?
11:30:28 <Marvin--> what does it do?
11:30:39 <Igloo> prints
11:30:39 <Igloo> (2507 reductions, 3741 cells)
11:30:46 <Igloo> after evaluating something
11:30:57 <Marvin--> can't say I've ever used it
11:33:23 <Igloo> Bah
11:36:01 <SyntaxPolice> hey Igloo, how's life?
11:36:19 <Igloo> Not bad
11:36:36 * Igloo is now effectively Debian bug-free  :-)
11:37:08 <Igloo> Oh, and I e-mailed Michael suggesting asking for c2hs to be removed from testing if he hasn't got time to work on it
11:37:42 <Igloo> And other stuff seems to be going swimmingly too, except piano harmonisation which I can't do. Yet.
11:37:57 <SyntaxPolice> what do you mean?
11:38:03 <Igloo> By what?
11:38:07 <SyntaxPolice> harmonize with a piano?
11:38:16 <SyntaxPolice> but the debian stuff sounds good :) I'm glad to hear that.
11:38:17 <Igloo> Writing piano music to harmonise with a melody
11:38:34 <SyntaxPolice> ahh. do you know the theory behind it?
11:38:47 <SyntaxPolice> like what key the melody is in
11:38:48 <Igloo> I have harmonisation theory coming out of my ears
11:38:56 <SyntaxPolice> wow
11:39:04 <SyntaxPolice> that's a convinient place for it to come out :)
11:39:13 <Igloo> I even have assigning chords done. It's the making nice music bit where I'm getting stuck ATM  :-)
11:39:17 <Igloo> lol
11:39:34 <SyntaxPolice> ahh. is the melody also going to be played on the piano?
11:40:13 <Igloo> Not sure  :-)
11:40:21 <Igloo> How musical are you OOI?
11:40:59 <SyntaxPolice> OOI?  I was a music major for 2 years, but gave it up for computers.
11:41:06 <Igloo> Out Of Interest
11:41:17 <Igloo> Oho, interesting!
11:41:53 <SyntaxPolice> I don't play the piano, though :)
11:42:14 <Igloo> What do you play? And can you harmonise in real time?
11:43:59 <SyntaxPolice> I play viola, guitar, and sing tenor. I can harmonize in real time w/ my voice, and can make up melody to a chord progression w/ the guitar
11:44:22 <Igloo> Cool
11:47:09 * Igloo is also hoping to have ghc6 on m68k in around 2 weeks, incidentally
12:04:22 * Igloo finishes going through the profiling documentation and fails to find anything that does what I want  :-/
12:04:50 <phubuh> m68k is what older Macs use, right?
12:21:16 <Igloo> Think so
12:23:09 <tic> jap.
12:23:19 <tic> mac and amiga and atari.
12:45:57 <Lor> Is there some simple way to render a latex math expression as an image?
12:47:59 <Smerdyakov> Hm. Some LaTeX to HTML converters do it.
12:48:04 <Smerdyakov> Like latex2html, for instance.
12:48:17 <Smerdyakov> So you can grab the image it creates out of the HTML/image ensemble. :)
12:48:20 <Lor> Yes, I know. I'm wondering how they do it.
12:48:36 <Lor> I can UTSL of course, I just asked first in case someone knows.
12:49:09 <Smerdyakov> You can probably write an easy wrapper script for latex2html to do it for math expressions alone.
12:49:14 <Lor> Of course I can create an entire latex document, turn it into dvi or ps, and then use imagemagick or something to convert it into bitmap, and then find out the borders of the non-white area, but that's a bit tedious.
12:49:27 <Smerdyakov> I think what I just said is more satisfactory. ;)
12:50:50 <Igloo> Depending on your purpose you might find one of the OS maple-like algebra programs has a library that is easier to use
13:13:50 <Marvin--> "ITP: linux"
13:13:50 <Marvin--> heh
14:05:09 <shapr> @yow
14:05:10 <lambdabot> Yow!  Are we wet yet?
14:05:29 <tic> shapr, http://www.aftonblaskan.se :P
14:05:33 <shapr> I get a stupendous amount of spam.
14:05:53 <shapr> cute, what is it?
14:06:24 <tic> shapr, compare: http://www.aftonbladet.se
14:06:31 <tic> shapr, mocking a tabloid magazine
14:06:38 <shapr> ohh
14:07:36 <shapr> snigelrace.. hmm
14:08:48 <shapr> I just finished my swedish homework
14:08:51 <tic> ahh
14:08:54 <tic> how did it go?
14:08:59 <shapr> now I'm looking for a swedish-english dictionary for my palm pilot
14:09:06 <shapr> it went slowly
14:09:07 <Marvin--> shapr: wow, on time for once?
14:09:08 * Marvin-- ducks
14:09:13 <shapr> Marvin--: well, sort of
14:09:22 <shapr> I was really sposed to do nyheter tomorrow as well.
14:09:31 <shapr> but I'm going to put it off till törsdag
14:09:35 <tic> Torsdag. :)
14:09:39 <shapr> tack :-)
14:09:42 <tic> hehe.
14:09:49 <shapr> I think I may use aftonbladet for my nyheter :-)
14:09:53 <tic> yuck, don't.
14:09:55 <shapr> that would be thoroughly entertaining.
14:09:56 <tic> use GP.se instead.
14:09:58 <tic> yeah.
14:10:05 <tic> aftonbladet is the suxx0r
14:10:28 <shapr> it does look lowbrow at least :-)
14:10:45 <tic> what's lowbrow mean?
14:11:33 <shapr> means something that is designed for people who have very little education
14:13:26 <Marvin--> I usually read dn.se
14:13:36 <shapr> I'll try both of them, thanks.
14:13:50 <tic> dn is right-wing, whereas GP is left-wing.
14:13:55 <tic> (both pretty much to the center)
14:14:05 <Marvin--> both are indendent though
14:14:14 <Marvin--> er, independent even
14:14:39 <tic> yap.
14:14:46 <tic> but that's still their colors.
14:14:51 <tic> s/that's/those are
14:14:55 <shapr> one of our local food stores, domus, is run by a political party
14:14:57 * tic needs to work on his skills
14:14:59 <shapr> that's seriously weird.
14:15:01 <tic> hm.
14:15:03 <tic> Domus == Konsum.
14:15:11 <tic> which one? Miljöpartiet? :)
14:15:19 <shapr> I'm not sure
14:15:19 <tic> can't be (v) ?
14:15:23 <tic> Marvin--, d'you know?
14:15:25 * Marvin-- wonders if her highness the princess will be doing her grocery shopping in the building her boyfriend lives...
14:15:28 <shapr> I think it's related to the NSD paper we have here.
14:15:43 <Marvin--> er, I've never heard of KF being affiliated with a political party
14:15:44 <shapr> national socialist democrat?
14:16:02 <tic> national socialists? yuck.
14:16:03 <shapr> I'm not up on local politics, though I probably should be.
14:16:19 <Marvin--> I don't know how tightly organized the "local" stores are with the national organization though
14:16:24 <tic> hm.
14:16:33 <tic> thermo dynamics. Now!
14:16:34 <tic> argh.
14:16:45 <Marvin--> seriously, Domus still exists? I had no idea, haven't seen one in ages :-P
14:16:59 <tic> isn't domus == coop nowadays?
14:17:05 <shapr> it's the most popular food store in the area
14:17:12 <tic> what's weird is that I've seen a ICA Konsum. What's that about?
14:17:16 <shapr> next bigger is in Luleå
14:17:22 <Marvin--> tic: that's even weirder
14:17:30 <tic> "han jobba' på domus, och jag gick och stämpla"
14:17:37 <tic> shapr, hey, you know andreas! :)
14:17:47 <shapr> tic: you know andreas too?
14:17:50 <tic> shapr, yeah =)
14:17:54 <shapr> he's a cool guy
14:17:59 <tic> yap.
14:18:03 <shapr> I loaned him two of my Python books yesterday :-)
14:18:04 <tic> he used to live down here before.
14:18:06 <tic> ah, cool.
14:18:10 <Marvin--> anyway, we had a Domus in SkÃ¶vde, but that was well over a decade ago
14:18:39 <tic> shapr,  I was surprised to find him in #python. And he thought I was a C++ bitch. =)
14:18:46 <shapr> so once he's learned Python, then I'll teach him Haskell. Unless he escapes to the south again.
14:18:46 <tic> (but we all know Python is inferior C++ :)
14:18:51 <tic> mhm
14:19:02 <shapr> tic: how did you find out I knew him?
14:19:09 <shapr> that's surprising
14:19:12 <shapr> and spiffy
14:19:24 <Marvin--> I'm having a hard time grasping that any shop affiliated with KF would be run by a political party
14:19:26 <tic> shapr, I asked as I know you both live in the cold north
14:19:34 <shapr> yah, but ... how likely is that?
14:19:40 <tic> shapr, heh, dunno :]
14:19:41 <shapr> the cold north is a very large place.
14:19:49 <Marvin--> veerrry large
14:19:58 <shapr> I actually met andreas two blocks from my house
14:20:03 <Marvin--> and very little of it has cell phone coverage *grmbl*
14:20:07 <shapr> he was helping a friend of mine work on his car
14:20:27 <tic> ah, cool.
14:20:50 <shapr> then we went to the heavy metal festival and met a bunch more people....
14:20:54 <shapr> and I had a lot to drink
14:21:01 <Marvin--> heh
14:21:37 * Marvin-- notes that "a lot" in shapr's case means "two beers"
14:21:45 <Igloo> :-)
14:21:50 <shapr> actually, I had SEVEN this time.
14:21:58 <tic> shapr, hm. I think he said I should probably meet you in December or whenever you're coming to down to Gothenbourgh.
14:21:59 <shapr> I had to remind myself where the floor was.
14:22:08 * Igloo saw a philharmonic orchestra the other day, but rather less alcohol was involved. </random>
14:22:13 <shapr> Igloo: cool!
14:22:38 <shapr> Marvin--: did you and I have beer at the same time at ICFP?
14:22:39 <Marvin--> heh, as for <random> I went the the opera last week (no alcohol there either)
14:22:45 <Marvin--> shapr: yes, we did ;)
14:22:49 <shapr> oh!
14:22:53 <shapr> with Igloo no less
14:22:58 <Marvin--> indeed
14:23:02 <shapr> that was fun
14:23:12 <Marvin--> what's this about coming to Gothenburg?
14:23:12 <Igloo> FSVO "with"
14:23:19 * shapr grins
14:23:25 <shapr> Marvin--: europy
14:23:26 <Igloo> But yes, was fun indeed
14:23:26 <Marvin--> FSVO?
14:23:31 <shapr> for some value of
14:23:33 <Igloo> For Some Value Of
14:23:38 <Marvin--> ah
14:23:40 <Marvin--> right
14:23:57 <shapr> since I didn't buy Igloo the beer I promised him, he was without.
14:23:58 <tic> 2 + 2 = 5 for a high enough value of 2
14:24:03 * shapr grins
14:24:08 <Marvin--> but europy won't be until next summer, will it?
14:24:14 <shapr> sounds reasonable
14:24:21 * Marvin-- reminds himself that he has to reply to that mail from Jacob
14:24:29 * Igloo doesn't remember being promised a beer, but seeing as I didn't want one doesn't really care  :-)
14:24:38 <shapr> I heard that Bea is track champion for Python in Business
14:24:44 <shapr> and that she's been swapping emails with Laura
14:24:47 <Marvin--> ooh
14:25:09 <shapr> and that she may take over admin of the Python in Business Forum
14:25:25 <Marvin--> cool :)
14:25:41 <Marvin--> it would be very good to make PBF != Strakt
14:25:57 <tic> Heh.
14:25:57 <shapr> well, Laura seems well liked
14:26:06 <shapr> and very popular
14:26:12 <shapr> fsvo popular
14:26:12 <Marvin--> yeah, well, feels like half the board is Strakt people
14:26:18 <Igloo> Who is Laura?
14:26:20 <tic> When I was at Arbetsförmedligen two years ago, I could fill out a CV with what I knew. And, ye and behold if they didn't list both BeOS and Python!
14:26:28 <tic> (you could fill in checkboxes)
14:26:30 <shapr> Laura Creigthon(sp?)
14:26:37 <shapr> tic: suckage!
14:26:43 <shapr> tic: did they at least list Haskell?
14:26:54 <Igloo> Is she a random Python person I'm unlikely to have ever heard of?
14:26:56 <tic> shapr, I'm not sure, but they actually might've
14:26:58 <shapr> wait they *did* list both BeOS and Python??
14:27:11 <shapr> Igloo: er, she's the scratch monkey person.
14:27:16 <tic> shapr, yeah.  Among Windows, SQL, Access, Linux and so on.
14:27:21 <shapr> tic: wow
14:27:23 <Marvin--> tic: cooool
14:27:23 <Igloo> Ah, OK
14:27:29 <shapr> Igloo: heard of her?
14:27:30 <tic> shapr, computer form where you could tell what stuff you know.
14:27:36 <Igloo> Heard of scratch monkey
14:27:41 <shapr> I've considered trying arbetsförmedligen
14:27:50 <tic> platsbanken.ams.se
14:27:51 <shapr> if they list python and haskell, I gotta get myself listed.
14:28:22 <Marvin--> haskell might take a bit longer :)
14:28:50 <shapr> @jargon "scratch monkey"
14:28:50 <tic> "Haskell's a research language, Python's a scripting language"
14:28:51 <lambdabot> *** "scratch monkey" jargon "Jargon File (4.3.0, 30 APR 2001)"
14:28:51 <lambdabot> scratch monkey n. As in "Before testing or reconfiguring, always mount
14:28:51 <lambdabot>    a {scratch monkey}", a proverb used to advise caution when dealing with
14:28:51 <lambdabot>    irreplaceable data or devices. Used to refer to any scratch volume
14:28:52 <lambdabot>    hooked to a computer during any risky operation as a replacement for
14:28:53 * Marvin-- starts flipping through Designing from both sides of the screen
14:28:53 <tic> "real men use C"
14:28:54 <lambdabot>    some precious resource or data that might otherwise get trashed.
14:28:58 <lambdabot>    This term preserves the memory of Mabel, the Swimming Wonder Monkey,
14:29:00 <lambdabot> [29 @more lines]
14:29:44 <shapr> tic: bah, both are programming languages worthy of everyday use.
14:29:54 * shapr starts a religious flamewar
14:29:54 <tic> shapr, notice the quotes. :)
14:30:00 <tic> (don't kill the messenger etc.)
14:30:08 <shapr> aww, holy wars are fun!
14:30:21 <tic> I use Python daily, but I've learned a lot from Haskell.
14:30:29 <tic> Like, I'd really really like pattern matching in Python.
14:30:33 <shapr> yah, me too
14:30:41 <tic> shapr, I did show you my pattern-matching hack in Python, right?
14:30:45 <shapr> did you find it in the xoltar toolkit?
14:30:54 <shapr> I think you did, but I can't remember anything about it atm :-/
14:31:00 <tic> I've looked through it once before, but I don't like it's syntax.
14:31:06 <tic> like:
14:31:12 <tic> fib = Function()
14:31:33 <tic> fib[0] = 0; fib[1] = 1; fib['n'] = 'fib(n-1) + fib(n-2)'
14:31:36 <shapr> you could talk to the guy, he's a heavy Haskeller.
14:31:51 <shapr> oh, this does look familiar now
14:32:01 <tic> well.. the thing is that I want the exact syntax of haskell.
14:32:05 <shapr> oh
14:32:10 <tic> i don't see anything in the language that doesn't permit it.
14:32:20 <tic> (other than the actual syntax, that is ;)
14:32:36 <tic> it already has built-in lists and tuples. 
14:33:08 <tic> harder to implement in C++ and various other assembly languages, but in Python I don't think there's anything hindering you.
14:33:23 <shapr> does it work?
14:33:27 <tic> which?
14:33:34 <shapr> your hack?
14:33:40 <tic> oh, haven't tried it. :)
14:33:43 <tic> don't see why it shouldn't though.
14:34:02 <tic> just override __getitem__() and the dict-function and finally the call thingy
14:34:17 <shapr> well, I'd like to try it when you write it :-)
14:34:26 <tic> yeah, I'll let you know. :)
14:34:36 <tic> think it's time for physics now though.
14:34:46 <tic> or perhaps.. it's futurama on TV now. Crap. I'm going to fail this exam.
14:35:16 <tic> (TV4)
14:35:23 <ddarius> wow, it's been years since I've seen Futurama.
14:35:32 <tic> :)
14:35:36 <shapr> heya ddarius 
14:36:07 <ddarius> heya
14:36:38 * shapr steals ddarius' greeting yet again
14:43:01 <Lor> Is there any way to port a cvs repository into darcs?
14:46:56 <shapr> if you mean a direct import, just slurp it in
14:47:02 <Marvin--> card trading sites == good
14:47:06 * Marvin-- gets rid of useless cards
14:47:11 <shapr> checkout the files, move to the dir, stick that dir into darcs
14:47:21 <andersca> that's what's good about munchkin
14:47:26 <Lor> I mean I want to retain the change history.
14:47:29 <andersca> no need to trade cards, just play :)
14:47:50 <Marvin--> we played Munchkin-Fu at borcon, that was a weird expansion
14:47:59 <andersca> not really an expansion
14:48:08 <Lor> It's way misbalanced.
14:48:12 <shapr> oh, I want to hear about it!
14:48:14 <andersca> Marvin--: we're gonna play all munchkin games together sometime
14:48:21 <shapr> Lor: I don't know of a way to retain change history
14:48:22 <Marvin--> yeah, true
14:48:30 <shapr> since darcs and cvs have entirely different outlooks on life
14:48:33 <shapr> g'day Pseudonym 
14:48:46 <Pseudonym> G'day.
14:48:58 <shapr> what's up?
14:50:58 <Pseudonym> Release Hell(tm)
14:53:26 <shapr> oh, fun
14:53:33 <shapr> do you get beer and pizza after this one too?
14:56:59 <Pseudonym> Of course.
14:57:12 <Pseudonym> They're talking about Belgian beer this time.
14:57:14 <Pseudonym> Pity I don't drink.
14:58:32 <shapr> hoegaarde?
14:59:00 <Pseudonym> No clue.  There are more varieties of beer than people in Belguim.
14:59:23 <shapr> heh
15:01:53 <Pseudonym> At the moment I'm having a problem with a rack, too.
15:02:16 <Pseudonym> Server is colocated at someone else's place, and his roommates are complaining about heat and noise.
15:03:08 <Pseudonym> I'm thinking that since the rack has fans at the top, a hood + insulation-covered PVC pipe + chimney might help.
15:03:43 <shapr> or colo it somewhere else?
15:03:56 <Pseudonym> Just spent a lot of money getting it installed there. :-)
15:04:06 <shapr> oh
15:15:38 <tic> Is it P = I*I * R?
15:15:47 <tic> or P = I*R*R ?
15:16:11 <Pseudonym> What's P, I and R?
15:16:23 <Pseudonym> Power, current and resistance?
15:16:40 <Pseudonym> E = I*R
15:16:44 <Pseudonym> P = E*I
15:16:51 <Pseudonym> so P = I*I*R
15:16:59 <tic> gotcha. thanks.
15:17:01 <Pseudonym> E = EMF
15:17:26 <shapr> E = mc^2
15:17:38 <tic> heh
15:18:13 <Pseudonym> d/dt(dL/dq') - dL/dq = Fq
15:18:40 <shapr> x = x + 1
15:18:57 <tic> hehe.
15:19:02 --- mode: ChanServ set +o shapr
15:19:04 <Pseudonym> shapr: You just broke Peano arithmetic, thankyou very much.
15:19:10 --- kick: shapr was kicked by shapr (DYSFUNCTIONAL! Kicked by shapr)
15:19:22 <shapr> ahem
15:19:23 <tic> H = lambda * A * (T2 - T1)/d
15:19:25 <shapr> I'm better now. really.
15:19:31 <tic> P = I*I*R => I = sqrt(H/R)
15:19:40 <tic> *hold thumbs*
15:20:01 <Pseudonym> tic: Yes, except... I is a vector.
15:20:12 <Pseudonym> In general.
15:20:15 <tic> hehe.
15:20:15 <tic> I is current.
15:20:26 <Pseudonym> Sure.  Electrical current has a direction.
15:20:26 <tic> well.
15:20:30 <tic> then I use 'i'.
15:20:36 <tic> this current doesn
15:20:38 <tic> doesn't.
15:20:42 <tic> heat stuff.
15:20:44 <Pseudonym> I = dQ/dt where Q is charge flux.
15:20:52 <tic> mhm, I know.
15:21:02 <Pseudonym> Right, so it's a vector. :_)
15:21:03 <tic> I just failed that class a month ago =)
15:22:01 <Pseudonym> The I*I in P = I*I*R is technically a dot product.
15:22:10 <tic> sure.
15:22:31 <tic> but dot product on scalar thingies reduces to mul.
15:22:43 <Pseudonym> Well, yes, but I isn't a scalar.
15:22:50 <Pseudonym> :-)
15:23:04 <tic> s/I/i/g, happy? :)
15:23:09 <Pseudonym> OK, happy now.
15:23:15 <tic> crap. I got i = 2.13e3. That's a bit high, I think.
15:23:25 <tic> can't be correct.
15:23:26 <Pseudonym> That's a lot of amps.
15:23:29 <tic> yeah
15:23:38 <tic> it's supposed to be 43A.
15:23:39 <tic> hrm.
15:23:55 <Pseudonym> 43A is also a lot of amps.
15:24:13 <Pseudonym> It's more than one three-phase line can deliver.
15:24:27 <tic> sure. it's a constructed problem, obviously.
15:24:58 <shapr> how much can a 3-phase line deliver?
15:24:58 <tic> how much current do you have to drive through a metal wire in order to get it 1 K hotter in the middle than at the ends.
15:24:59 <Pseudonym> Actually, maybe you can get 45A three-phase lines.  I'm used to 30A, anyway.;
15:25:23 <Pseudonym> Ah, now that's thermodynamics.  VERY rusty on that.
15:25:24 <tic> s/drive through/run throuh
15:25:27 <tic> yap.
15:25:42 <tic> i have a couple of formulae here, but it turned out not being as easy as a I thought. 
15:25:57 <Pseudonym> What's d and what's lambda?
15:26:03 <Pseudonym> Oh, and what's A?
15:26:44 <tic> it's a 50 cm cable, 8 mm in diam.
15:26:55 <tic> lambda = 385 W/m*K
15:26:59 <Pseudonym> OK, so A is the cross-section?
15:27:01 <tic> R = 1.7e-8
15:27:02 <tic> yeah
15:27:23 <tic> so, the cable has very good isolation
15:27:28 <tic> and only emit heat at the end
15:27:47 <tic> so what we want to know here is how much current you have to run through it in order to make the temp go up by 1 degree Kelvin in the middle
15:28:06 <tic> so I thought I'd set deltaT to 1 K and slice the cable off in the middle, but that turned out not to work very well. :)
15:28:18 <tic> my attempt:
15:28:30 <tic> A = PI*d**2
15:28:44 <tic> H = lambda * A * deltaT/(half-cable-length)
15:28:50 <tic> and then: I = sqrt(H/R)
15:29:01 <tic> but that was definitely not the correct answer.
15:29:14 <tic> I think it's because I can't just cut the cable in half and count on that.
15:29:22 <Pseudonym> No, I don't think so either.
15:29:58 <Pseudonym> If you set d = total-cable-length, what does that give you?
15:30:12 <tic> sec.
15:30:20 <Pseudonym> What's the resistance of the cable?
15:30:32 <Pseudonym> Ah, 1.7e-8... ohms?
15:30:34 <tic> yap.
15:30:37 <Pseudonym> Or ohms per metre?
15:30:46 <tic> resistivity
15:30:56 <Pseudonym> What are its units?
15:31:06 <tic> ohm.
15:31:07 <tic> oh crap.
15:31:12 <tic> he wrote ohm.m.
15:31:19 <Pseudonym> Bingo.
15:31:34 <tic> and I thought he did a typo; but it was supposed to be ohm * m
15:31:37 <Pseudonym> Right.
15:31:43 <tic> hm.
15:31:50 <tic> but I still don't think it'll do me any good.
15:31:52 <Pseudonym> So you have to multiply it by the length and divide by the area to get the resistance of the wire.
15:32:04 <tic> divide by area?
15:32:08 <Pseudonym> Sure.
15:32:08 <tic> like:
15:32:23 <tic> R = 1.7e-8 * 0.5 / (PI*d**2) ?
15:32:29 <tic> why divide by area?
15:32:56 <tic> ah, the *m assumes an infinitesmal thin length?
15:33:12 <Pseudonym> Doubling the cross section of the wire halves the resistance.
15:33:28 <Pseudonym> If you think about it, it's like putting two resistors in parallel.
15:33:39 <tic> okay, now I'm down to the right order of magnitude; I got 15 this time.
15:33:45 <tic> ah, right.
15:33:45 <Pseudonym> Cool.
15:33:54 <Pseudonym> Now try the actual wire length rather than half of it.
15:33:54 <tic> the correct answer is:
15:34:01 <tic> I did that now. :)
15:34:05 <Pseudonym> :-)
15:34:33 <cybermanco> hello
15:34:51 <cybermanco> someone here speaks portuguese?
15:34:58 <tic> I = 2*lambda(PI*r**2)**2 * P(T_0 - T_A) / pl**2
15:35:01 <tic> I = sqrt(I)
15:35:30 <tic> p must be my H.
15:35:39 <tic> but I have absolutely no clue on how he got that number.
15:36:07 <Pseudonym> Try pushing it back through the equation and see what d should be.
15:36:35 <ddarius> cybermanco: I'm pretty sure some do, but I don't know if they are on/here now.  They don't seem to be.
15:37:03 <tic> phubuh, pushing what back=?
15:37:06 <tic> er
15:37:09 <tic> Pseudonym, pushing what back?
15:37:35 <Pseudonym> You know what the answer should be.  RUn your formulae in reverse and see what you get.
15:38:00 <tic> Yeah, it's just that I don't know what T_A is.
15:38:08 <tic> ( T<subscript>A )
15:38:22 <tic> or it isn't really A either. it looks more like Ä)
15:40:28 <tic> aww, crud.
15:40:28 <Pseudonym> Well, reverse your formulaw and find out.
15:41:04 --- topic: set to '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","lots of cool debs in the haskell-experimental archive - see http://www.syntaxpolice.org/haskell-experimental/haskell-experimental.html","new HC&A Report - http://www.haskell.org/communities/","Any user who would like to request any unwritten tutorial please msg shapr","Elec. eng. homework help here!"]' by Pseudonym
15:41:18 <tic> :9
15:41:18 <tic> :)
15:41:31 <tic> "Master of Science in Computer Science in Engineering", even.
15:41:50 <tic> "civilingenjör datateknik" is the lot less fancy name in Swedish.
15:43:01 --- topic: set to '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","lots of cool debs in the haskell-experimental archive - see http://www.syntaxpolice.org/haskell-experimental/haskell-experimental.html","new HC&A Report - http://www.haskell.org/communities/","Any user who would like to request any unwritten tutorial please msg shapr"]' by Pseudonym
15:43:13 <Pseudonym> shapr, I'd like an unwritten tutorial, please.
15:43:36 <cybermanco> hi
15:43:46 <cybermanco> (sorry me bad english)
15:43:50 <Pseudonym> SOmething to do with electronics and thermodynamics.  It's obviously we don't know anything about it.
15:44:00 <cybermanco> can someone explain me this kinf of data: data CDecl = MkCD { cDesc :: String, cArgs :: [Type] } deriving Eq
15:44:04 <Pseudonym> cybermanco: G'day.  Sorry, don't speak Portugese.
15:44:11 <Pseudonym> What you have there is a record.
15:44:32 <cybermanco> I can access this record?
15:44:36 <cybermanco> ops
15:44:40 <Pseudonym> Yes you can.  Hang on.
15:44:44 <cybermanco> how can I access this record?
15:45:15 <cybermanco> imagin that I want the cDesc... how do I do?
15:47:02 <ddarius> You can pattern match, e.g. "f (MkCD { cDesc = x }) = doSomethingWith x" or you can use the field as a function, e.g. "f record = doSomethingWith (cDesc record)"
15:49:06 <cybermanco> what this means: variable not in scope ?
15:49:13 <cybermanco> when I try to load my source
15:51:24 <ddarius> It means you are using a variable you haven't defined, if y is not defined elsewhere it's not in scope in the following, "f g = g y".  You may simply have a typo.
15:51:51 <cybermanco> hm.. but I have this variable defined in other file
15:51:57 <cybermanco> and I use: import file
15:52:04 <cybermanco> that's correct?
15:55:08 <ddarius> Does the other file export it?
15:56:57 <cybermanco> I don't know.. I do I export?
15:57:47 <Kr1st1na> i downloaded ghostscript-7.05.tar.gz and extracted the files, but i dont see any executable program of ghostscript
15:57:59 <Kr1st1na> can anyone help
15:58:54 <ddarius> cybermanco: If it looks like "module TheOtherFile where ..." then it already exports everything.  If it looks like "module TheOtherFile (foo, bar) where ..." then it only exports foo and bar.
16:00:06 <ddarius> cybermanco: Also, unless explicitly written it won't export things it imports from other files.  So "module TheOtherFile where { import SomethingElse (baz) }" won't export baz.
16:01:01 <cybermanco> hm..
16:01:01 <Pseudonym> Sorry, work called.
16:01:08 <Pseudonym> Kr1st1na: You probably have to compile it.
16:02:22 <Kr1st1na> compile what?
16:02:35 <Pseudonym> At a guess, what you have there is source code.
16:02:43 <Pseudonym> This is why there are no executables.
16:03:45 <Kr1st1na> and how do i compile it
16:04:10 <Pseudonym> The documentation should be somewhere there in the packate.
16:04:26 <Kr1st1na> i just want a program to open ps files
16:04:29 <Pseudonym> If you have an appropriate system., though, you probably want a source package.
16:04:39 <Pseudonym> Sorry, you probablyt want a binary package.
16:06:25 <Pseudonym> What OS are you running?
16:07:10 <Kr1st1na> xp
16:07:41 <Pseudonym> And you just want to read PS files?
16:07:45 <cybermanco> imagine that I have file1 and file2 and file3: file2 imports file1 and file3 imports file2! I can access file1 variables^?
16:07:45 <Kr1st1na> yes
16:07:53 <cybermanco> or.. I need to import file1 again?
16:08:00 <Pseudonym> http://www.cs.wisc.edu/~ghost/doc/AFPL/get811.htm
16:08:10 <Pseudonym> About half-way down the page.
16:08:15 <Pseudonym> Also get GSview.
16:08:20 <Pseudonym> Which is just below that.
16:08:43 <Kr1st1na> ok thanks
16:08:51 <Pseudonym> No problem.
16:10:14 <ddarius> cybermanco: You will need to import file1 again (there are other mechanisms as well)
16:22:08 <cybermanco> ok
16:22:10 <cybermanco> thanks
16:22:14 <cybermanco> it is working :)
16:28:07 <Leimy_> what are the rules for whitespace on if's in haskell?
16:28:12 <Leimy_> cuz I am completely baffled
16:30:08 <Igloo> Are you trying to use if in a do block?
16:30:20 <Leimy_> yes in fact :)
16:30:30 <Igloo> And you are putting then on the same line as if?
16:30:33 <Pseudonym> Yes, that's the one place which trips everyone up.
16:30:37 <Leimy_> nope
16:30:40 <Pseudonym>  do  if foo
16:30:43 <Igloo> If so, the "then" is taken as starting a new statement in the do block
16:30:45 <Leimy_> main = do
16:30:45 <Leimy_>         args <- getArgs
16:30:45 <Leimy_>         if (length args) /= 3
16:30:45 <Leimy_>                 then usage
16:30:46 <Pseudonym>       then stuff
16:30:47 <Leimy_> that's it
16:30:55 <Igloo> Oh, you need an else
16:31:03 <Pseudonym> Yes.
16:31:10 <Igloo> You probably want    Monad.when ((length args) /= 3) usage
16:31:38 <Leimy_> heh not that far into the lang to understand monads :)
16:31:40 <ddarius> Who lines up their thens with their ifs?
16:32:00 <Leimy_> main = do
16:32:00 <Leimy_>         args <- getArgs
16:32:00 <Leimy_>         if (length args) /= 3
16:32:00 <Leimy_>                 then usage
16:32:00 <Leimy_>                 else
16:32:00 <Leimy_>                         compoundInt 10 10 1000
16:32:03 <Igloo> I do sometimes
16:32:06 <Leimy_> people who use tab characters?
16:32:25 <Igloo> That should work
16:32:27 <Leimy_> hmm that seems to have gotten it.
16:32:36 <Leimy_> I don't know why that screwed me up so badly before
16:32:45 <Leimy_> oh well... I fought with this for like an hour the other day
16:33:58 <Kr1st1na> can someone help me, im trying to write a show function which outputs a list of a family tree in a readable format
16:35:21 <Kr1st1na> whats a good website with the show class which might help me
16:37:05 <Leimy_> well that did it... thanks guys :)
16:39:48 <cybermanco> hello
16:40:13 <cybermanco> I want to use a func that I think it is called unsafePerformIO
16:40:20 <cybermanco> there is any func like this?
16:43:30 <ski> cybermanco : what do you want to use it for ?
16:43:37 <cybermanco> because
16:44:00 <cybermanco> I have IO [TDecl] and I want only [TDecl]
16:44:06 <ski> (i.e. perhaps there is a better way of doing what you want ...)
16:44:24 <ski> just use do-notation
16:44:29 <ski> is that a problem ?
16:44:56 <whee> I'd go with using the standard monad functions unless you can prove what you're doing with unsafePerformIO is safe in your situation
16:45:10 <cybermanco> hm
16:45:17 <cybermanco> I don't knoe if it is safe
16:45:20 <ski> do tDecls <- makeTDecls
16:45:25 <cybermanco> but I think that I can do this
16:45:48 <ski>    return (doWhatYouWantHere tDecls)
16:46:05 <cybermanco> but my problem is that it says variable is not in scope: unsafePerformIO
16:46:07 <ski> using do-notation / do-blocks is safe
16:46:14 <cybermanco> hm
16:46:22 <whee> what compiler are you using cybermanco?
16:46:26 <cybermanco> ghc
16:46:38 <ski> if you don't *need* to use unsafePerformIO, then *don't* use it !
16:46:58 <cybermanco> ski: this is for a work in my school
16:47:01 <whee> heh
16:47:14 <cybermanco> and I think that my teacher allow me to use this func..
16:47:22 <whee> there's an entry in the faq for ghc (http://www.haskell.org/ghc/docs/latest/html/users_guide/faq.html) about when it's safe to use it
16:48:02 <whee> I forget which module ghc puts that in, but it's there somewhere
16:48:04 <ski> cybermanco : do they require/hint that you should use unsafePerformIO ?  or have you heard about it from someone else ?  (perhaps you found it yourself)
16:48:33 <cybermanco> I heard about it from someone else..
16:48:59 <ski> :)
16:49:32 <whee> if you can do it easily without unsafePerformIO, I'd just do that
16:49:51 <whee> I only use it when it's just a royal pain to do it the normal way and I'm sure it's safe
16:49:59 <ski> well, i think/guess/suspect that you don't need it, just you should use ordinary do-notation ..
16:50:04 <cybermanco> whee.. maybe I can do it withou unsafePerformIO.. but I don't know how to!
16:50:11 <ski> ok
16:50:24 <cybermanco> I am a very lamme haskell programmer :(
16:50:32 <ski> do tDecls <- makeTDecls
16:50:33 <ski> return (doWhatYouWantHere tDecls)
16:50:41 <cybermanco> let me try..
16:50:42 <whee> if you want to learn about monads, I'd recommend reading http://www.nomaware.com/monads/html/index.html first
16:51:28 <ski> makeTDecls has type IO [TDecl], tDecls gets bound to the value of type [TDecl]
16:52:04 <ski> cybermanco : so the "<-" thing extracts the value you want ..
16:53:48 <Leimy> "main = do
16:53:48 <Leimy>         args <- getArgs
16:53:48 <Leimy>         if (length args) /= 3
16:53:48 <Leimy>                 then usage
16:53:48 <Leimy>                 else
16:53:49 <Leimy> "A monad is a way to structure computations in terms of values and sequences of computations using those values."  huh?! :)
16:53:53 <Leimy> damnit
16:53:59 <Leimy> this cut and paste doesn't work well
16:54:45 <whee> indeed
16:55:38 <whee> cybermanco: when you have a function evaluating to something in the IO monad, it's just an indicator that that function most likely isn't referentially transparent and relies on side effects of some sort
16:56:29 <whee> there's nothing stopping you from writing functions that return things in the IO monad but don't fit in those cases, and in those situations it's safe to use unsafePerformIO
16:57:19 <ski> i.e. such functions (returning IO something) most often either depends or modifies the current world state
16:58:13 <cybermanco> "the last statement in a 'do' construct must be an expression"
16:58:26 <cybermanco> I am doing this: createFuncs file = do porra <- readHaFile file
16:58:26 <cybermanco>                    return porra
16:58:45 <ski> yes, it can't be of the form "pattern <- expression"
17:03:40 <whee> I'd probably lean towards using the normal monad syntax in something that simple too :)
17:03:51 <whee> the "do" thing is just syntactic sugar
17:09:44 <ski> cybermanco : you got an idea how to solve your problem now ?
17:36:06 <cybermanco> ski: I'm trying :|
17:39:36 <ski> feel free to ask more, when you need to :)
17:39:49 <cybermanco> ok.. you helped me a lot :)
17:53:35 <Leimy> so in Haskell are new types that would traditionally "inherit" from another type or class actually come into existence via instantiation?
17:53:49 <Leimy> for example... I am reading that Int is an instance of a Num.
17:54:48 <Leimy> is it more like a type class is an interface?
17:54:55 <Leimy> in other languages that is.
17:56:10 <ski> type classes are a bit similar to interfaces in Java and C#, or fully abstract classes in C++, yes
17:56:29 <ski> yes, usually
17:57:34 <Leimy> ok. I am getting this slowly :)
17:57:46 <Leimy> The Maybe thing is interesting
17:57:55 <Leimy> I don't know of any other langauge with it.
17:59:45 <ski> the MLs has option, which is the same thing, only different name ..
18:00:47 <ski> also i think C-- and Nice sortof has it, in a simple form (NULL pointers in C--, object references in Nice)
18:00:50 <Leimy> well... there are default parameters in C++ which can act like an optional argument depending on how you use them.  
18:01:01 <Leimy> but you don't have the same control
18:27:05 <ski> cybermanco : umm, if you haven't already, you could also check up http://haskell.org/hawiki/ThatAnnoyingIoType ::)
19:08:22 <RibenaBoy> hi
19:08:25 <RibenaBoy> bothTrue                 :: Bool -> Bool -> Bool
19:08:25 <RibenaBoy> bothTrue a b | a          = b
19:08:25 <RibenaBoy> 	     | otherwise  = False
19:08:36 <RibenaBoy> why is bothTrue False False = False?
19:12:19 <ski> hi, RibenaBoy !
19:13:29 <ski> because a gets bound to False, so the first guard "| a = b" fails, but the second ("| otherwise = False") succeeds, returning False
19:13:54 * Leimy needs to learn about these guards :)
19:14:38 <ski> the guard "| a = b" is equivalent to "| a == True  = b", but the first is shorter (and, in most cases, better, IMHO)
19:14:46 <Pseudonym> Leimy: Boost for C++ has a Maybe-like type.
19:14:57 <Leimy> I am not terribly surprised :)
19:15:04 <Leimy> they've done neat stuff with templates
19:15:13 <Leimy> I particularly like Spirit
19:15:15 <Pseudonym> And if you're using C++ and you're not using boost, you're wasting your time. :_)
19:15:24 <Leimy> yeah... I agree :)
19:15:30 <Leimy> you are writing stuff you don't need ot write
19:15:31 <Pseudonym> (Or you already have your own home-grown infrastructure which is too expensive to excise, I suppose.)
19:15:37 <Leimy> even the graph library is good
19:15:55 <Leimy> What I have heard as complaints about boost is that its often difficult to extract the pieces you want
19:16:06 <Pseudonym> I think that's true.  The tutorials aren't all good.
19:16:37 <Pseudonym> Some of it is useless.  WHo really uses octonions?
19:16:48 <Pseudonym> Oh, I really like the operator template library.
19:16:49 <Leimy> quite honestly ... I've had no need to write tons of C++ :)
19:16:52 <Pseudonym> That's so handy.
19:17:04 <Leimy> I work for a middleware company 
19:17:07 <Leimy> so C++ is kind of a no no
19:17:10 <Pseudonym> Ah.
19:17:15 <Leimy> ABI incompatibilities :)
19:17:34 <Pseudonym> Well, if you were using DCOM or CORBA like _normal_ middleware companies you'd be okay. :-)
19:17:55 <Pseudonym> I work for a database server company, so C++ is mandatory.
19:18:11 <Leimy> You don't want DCOM or CORBA for what we do :)
19:18:14 <Leimy> too much overhead
19:18:16 <Leimy> by far
19:18:18 <Leimy> I work in HPC
19:18:24 <Pseudonym> Ah, OK.
19:18:28 * Leimy makes MPI implementations
19:18:29 <Pseudonym> What specifically?
19:18:34 <Pseudonym> Ah, interesting.
19:18:41 <Leimy> yeah... we are on Tungsten
19:18:45 <Leimy> #4 in the world
19:18:45 <Leimy> :)
19:19:01 <Leimy> as well as soon to be Big Mac... I am doing the Mac OS X port
19:19:09 <Pseudonym> Cool.
19:19:15 <Leimy> yeah... i am kind of excited about it
19:19:28 <Leimy> we've been on ASCI-Q ... back before it went into production.
19:19:38 <Leimy> Tru64 has some interesting peculiarities... 
19:20:00 <Leimy> it wasn't #2 then :)
19:20:09 <Leimy> and we are actually on ASCI-White...
19:20:13 <Leimy> I was just at LLNL 2 weeks back
19:20:47 <Leimy> but I agree... if we had some kind of IDL... we would have been golden with C++ :)
19:20:59 <Pseudonym> Yes.
19:21:25 <Pseudonym> We're an ASN.1 shop.  Z39.50, to be precise.  So we can use whatever language we like.
19:21:33 <Leimy> nice
19:21:43 <Leimy> I wish I had that kind of flexibilityt
19:22:05 <Leimy> ... but we have a bunch of embedded systems we support... and C++ can be a real PITA there too.
19:22:29 <Pseudonym> Yes, although not as bad as it once was.
19:22:33 <Leimy> actually... the most popular one we support has outstanding C++ at the moment.
19:22:48 <Leimy> They use Green Hills Compiler.
19:22:54 <Leimy> its quite good.
19:23:27 <Pseudonym> Nobody wants to run terabyte-sized text databases on embedded systems, so we're safe there.
19:23:31 <Riastradh> Leimy, are you still confused about monads?
19:23:43 <Leimy> Riastradh: I haven't even really approached the topic yet
19:23:44 <Pseudonym> Having a hell of a time with the Itaniums, though.
19:23:52 <Leimy> Itaniums... we've got a few
19:23:52 <Riastradh> Leimy, OK, never mind, then.
19:24:03 <Leimy> Riastradh: thank's though
19:24:28 <Leimy> that's not sposedabe a contraction :)
19:24:52 <Pseudonym> So, when are we getting MPI for Haskell, then?
19:25:01 <Leimy> heh
19:25:04 <Leimy> I've been thinking
19:25:08 <Leimy> for a really big ass list
19:25:17 <Leimy> foldr on a cluster would be kind of like MPI_Reduce :)
19:25:24 * Pseudonym laughs
19:25:30 <Pseudonym> I don't know that much about MPI.
19:25:45 <Pseudonym> I have been thinking about a Z39.50 binding for Haskell, though.
19:25:49 <Leimy> heh
19:25:53 <Pseudonym> Probably won't support WAIS.
19:26:10 <Riastradh> What exactly is MPI, anyways?  I know it has something to do with multiprocessing, but nothing beyond that.
19:26:18 <Leimy> Message Passing Interface
19:26:28 <Riastradh> Yes, I knew the acronym, too, but I still don't know what it is.
19:26:35 <Leimy> its a standard for writing applications that scale up to 1000's of nodes
19:26:50 <Pseudonym> Think distributed Erlang.
19:26:53 <Riastradh> A 'standard?'  A language, or a library, or what?
19:27:03 <Riastradh> Pseudonym, er, isn't Erlang already distributed?
19:27:17 <Riastradh> s/library/specification of a library/1
19:27:17 <Leimy> its a standard
19:27:23 <Leimy> has C/C++/Fortran bindings
19:27:24 <Pseudonym> Depends on the implementation, I suppose.
19:27:40 <Riastradh> OK, isn't OTP already distributed?
19:27:49 <Pseudonym> I don't know.
19:28:02 <Pseudonym> Maybe.
19:28:02 <Riastradh> (what implementations are there besides ETOP or whatever Marc Feeley's is called and OTP?)
19:28:11 <Pseudonym> Probably.
19:28:17 <Leimy> It abstracts network messages... asynchronous and synchronous modes... One sided communications, File operations [collective], Dynamic process spawning etc. :)
19:28:19 <Riastradh> I asked 'what,' not 'are there.'
19:28:20 <Pseudonym> But MPI, as I understand it, is language-independent.
19:28:29 <Leimy> its for C/Fortran and C++ :)
19:28:33 <Leimy> not really independant
19:28:44 <Pseudonym> Well that's more independent than Erlang.
19:28:48 <Leimy> it specifies 3 language bindings :)
19:28:53 <Leimy> People do Java-MPI
19:28:56 <Leimy> and Python MPI
19:29:02 * Leimy calls that Pympi or pimpy :)
19:29:05 <Riastradh> are dorks?
19:29:07 <Pseudonym> I think I've seen Perl MPI.
19:29:14 <Leimy> Yeah... I think you have
19:29:24 <Pseudonym> I don't like this guy.  He reads minds.
19:29:25 <Leimy> that klingon language supposedly has MPI bindings in the works
19:29:43 <Leimy> hehe
19:29:49 <Leimy> var'aq?
19:29:55 <Leimy> I can't remember its name
19:29:58 <Leimy> that might be it
19:29:58 <Riastradh> Oh, oops, I thought you said 'people _who_ do'; thus, I presumed based on your statements about it being for 3 languages, that it would be dorky to use a different language.
19:30:36 <Riastradh> Or, in other words, it was a cognitive gas discharge.
19:30:42 <Leimy> http://www.geocities.com/connorbd/varaq/varaqspec.html
19:30:47 <Leimy> heh
19:37:47 * Leimy 's boss programs perl like a Klingon
19:37:52 <Leimy> open... or die
19:38:00 <Leimy> print or die
19:38:00 <Leimy> everything is or die
19:38:05 <Leimy> he's a scary guy :)
19:41:53 <Pseudonym> open... or else
19:41:59 <Pseudonym> Unfortunately not syntactically valid.
19:42:06 <Leimy> y = I_oughta
19:42:11 <Leimy> right :)
19:42:17 <Leimy> 3 stooges Perl
19:42:19 <Pseudonym> call(me, ishmael)
19:42:25 <Leimy> hehe
19:42:36 <Pseudonym> I think that's from Alan Holub's book on compilers.
19:42:52 <Smerdyakov> That's nothing. How about THIS? downloaf
19:43:09 <Pseudonym> Downloaf is a lesser known bread product made from duck feathers.
19:43:27 <Leimy> its very light
19:45:58 <Leimy> well my brain has reached capacity for the day... Any more and I will have to empty out precious childhood memories.
19:46:01 <Leimy> later...
19:55:39 <RibenaBoy2> damn..... got disconnected......
19:55:47 <RibenaBoy2> did someone answer my question?
19:56:22 <Smerdyakov> I don't think a question from you got through in the last 20 minutes.
19:56:26 <Smerdyakov> Tehe.
20:16:13 <ski> RibenaBoy2 : well, i made some comments on your problem ..
20:16:34 <ayrnieu> riben - what was your question?
20:17:11 <ayrnieu> riben - also, yes, your question was answered satisfactorily.
20:17:22 <ayrnieu> <ski> because a gets bound to False, so the first guard "| a = b" fails, but the second ("| otherwise = False") succeeds, returning False
20:18:05 <ayrnieu> riben - aside: where are you seeing this code?
20:18:14 <ski> RibenaBoy2 : you know, you can also see the logs for the channel  (link in channel topic)
20:22:21 <ayrnieu> riben - thank you for contributing to the redundancy of this channel's logs.
20:23:55 <RibenaBoy2> thanks
20:23:58 <RibenaBoy2> i get it now......
21:31:03 <ayrnieu> shapr?
21:31:26 <Pseudonym> Asleep.
21:32:54 <ayrnieu> Curse the hateful human weakness that drives such as shapr to the unresponsible timesink, to which not even my most capitalized or C-g riddled speech can reach!  Am I to never understand the title!?
22:09:47 <keir> currying is cool but... does anyone else but me find it leads to hard to read code?
22:09:59 <keir> ie leaving off the actual argument to a function because it can be curried
22:10:19 <Pseudonym> It does not inevitably lead to hard-to-read code.
22:15:25 <ayrnieu> keir - I haven't noticed that, though I could understand that someone coming from a language where radix information is more explicit would have trouble adapting to the new requirement that knowledge of such information be memorized.
22:17:06 <keir> i just find it kind of terse
22:17:24 <keir> jumping into a multi-thousand line python program, i'm productive immedatly
22:17:41 <keir> (but i know python very well)
22:17:56 <Pseudonym> Precisely.  There's your problem.
22:17:59 <keir> it seems that the judicious use of operators like $@! don't lend much to readability.
22:18:12 <ddarius> Pseudonym: Yes, keir should unlearn python.
22:18:13 <ayrnieu> Python requires that you internalize and notice different kinds of information than Haskell does.
22:18:18 <Pseudonym> A stage play is hard to read for someone who is not used to reading them.
22:18:39 <Pseudonym> A screenplay or teleplay even more so.
22:19:00 <keir> :)
22:19:31 <Pseudonym> Hell, a newspaper is hard to read if you've only read novels.
22:19:42 <ayrnieu> keir - on the bright side, not all of the information demands are one-way -- Haskell tends to make it easier to understand when side-effects are happening.
22:20:23 <keir> true!
22:20:23 <ayrnieu> keir - you'll never be caught calling 'reverse' only to discover that it's destructive, for instance.  That may not seem like much, now.
22:20:43 <ayrnieu> eh, actually you *will* discover that it's destructive -- at compile time, as an error.
22:20:45 <keir> yes, the fact that python's reverse has bothered me on more than one occassion
22:21:02 <keir> s/reverse/reverse is in place/
22:22:01 <ayrnieu> Haskell also makes it easier to understand what kinds of data a bit of code can receive, act on, and produce.  Python is a good counterexample language, here =)
22:22:58 <ayrnieu> So if you read a random function you don't have to keep so much about the data structures in-cache, since they're clearer in the code.  I suppose.
22:23:45 <keir> it's pretty hard to beat python for readability ;)
22:23:58 <keir> i learned it because i understood 90% of the examples without having used it!
22:23:59 <keir> anyway
22:24:10 <keir> this is #haskell enough python evangalising
22:24:30 <ayrnieu> but see the "evolution of a haskell programmer" for examples that test the kind of information you're used to remembering about Haskell code.
22:24:48 <ayrnieu> That's pretty weak evangelism, but OK =)
22:25:58 <ayrnieu> Actually, I take that back -- it's pretty good evangalism.
22:26:31 <keir> i understood all the simple haskell examples
22:26:35 <keir> even the quicksort
22:26:44 <keir> i implemented mergesort et al
22:26:47 <keir> for practice
22:26:57 <ayrnieu> What do you want to do, now?
22:26:59 <keir> but for some reason the whole monad / type /classes thing is tripping me up
22:27:01 <keir> well
22:27:08 <keir> i decided to take a break on the card thing for tonigh
22:27:10 <keir> tonight
22:27:18 <keir> and am trying to implement a simple expression parser
22:27:29 <keir> 1 + 2*(3-10) = -13
22:28:23 <keir> that's alot of versions of the factorial function!
22:28:44 <Pseudonym> You wait 'till you see mine.
22:28:57 <Pseudonym> Mine is sheer evil.
22:29:00 <Pseudonym> But very, very fast.
22:29:19 <keir> is itonline?
22:29:25 <ayrnieu> Pseudonym - is yours the one noted as fastest?
22:30:15 <Pseudonym> I don't know.  Where is the list?
22:30:52 <ayrnieu> http://www.willamette.edu/~fruehr/haskell/evolution.html
22:30:56 <Pseudonym> No.
22:31:05 <Pseudonym> http://haskell.org/hawiki/ContinuationPassingStyle
22:31:11 <Pseudonym> The one down the bottom is one of mine.
22:31:14 <ayrnieu> keir - also, this should help with monads: http://www.newadvent.org/cathen/10447b.htm
22:31:50 <Pseudonym> Bleah.  That one is slow compared with mine.
22:36:01 <Pseudonym> Ah, here we are.
22:36:03 <Pseudonym> http://www.mail-archive.com/haskell-cafe@haskell.org/msg03313.html
22:36:18 <Pseudonym> swing computes factorial.
22:37:42 <Pseudonym> There's a little-known thing about factorial, and that's that the usual ways of computing it are all very inefficient.
22:38:01 <Pseudonym> See, the integer libraries are optimised for multiplying similar-sized integers.
22:38:15 <Pseudonym> Multiplying a large integer by a small integer is pessimal.
22:39:20 <keir> i've wondered about that
22:39:21 <ayrnieu> So what do you do?  Break the multiplication up?  1*2*3*4*5 becomes (1*2)*(3*4)*5 ?
22:39:46 <Pseudonym> Well, my simplest fast factorial turns 1*2*3*4*5*6 into (1*2*3)*(4*5*6).
22:39:50 <Pseudonym> Divide-and-conquer.
22:40:02 <Pseudonym> SPlit the range into two and recursively multiply.
22:40:11 <Pseudonym> See recProd in the above page for an example.
22:40:32 <ayrnieu> How many divisions?  Would that be better (err, pretend we're not actually talking about [1..6] here) if it were (1*2*3*4)*(5*6) ?
22:40:53 <Pseudonym> Yes, but it's hard to get a good estimate on the size of each multiplicand.
22:41:24 <Pseudonym> And fact is, when you're in the 10000+ range, the sizes of the two halves of the final multiply are only off by a few decimal digits.
22:41:49 <Pseudonym> See, it's the size of the _representation_ (i.e. log n) which is important, not the size of the _number_.
22:42:18 <ayrnieu> Indeed?  I'd think that your divide-in-half scheme becomes less suitable as x of fact(x) grows.
22:42:24 <Pseudonym> FFT-based multipliers are O(n log n) in the size of the representation.
22:42:48 <Pseudonym> Yes, but it's still faster than naive factorial.
22:43:05 <Pseudonym> I think that swing does better as n grows.
22:43:17 <Pseudonym> It's a little smarter again.
22:43:36 <Pseudonym> In fact, maybe someone can infuriate me by working out how it does it.
22:43:43 <Pseudonym> Must go home.  Nytol.
23:15:46 <ayrnieu> Haskell's GHC-provided documentation definitely leaves much to be desired -- sometimes the many assorted (wonderful!) academic papers don't cut it.
23:57:37 <keir> here's a question i have from reading "Introduction to Functional Programming using Haskell"
23:57:49 <keir> in the section on monads they have a simple expression evaluator
23:58:17 <keir> and they use a monad, 'tick' to count the number of evaluations
23:58:25 <keir> but i totally do not see how it works.
23:58:39 <keir> i'd post the code somewhere or paste it... one sec I have to type it
