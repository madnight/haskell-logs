02:30:31 <phubuh> rubix: you can also use return
02:30:34 <phubuh> @type return
02:30:38 <lambdabot> return :: Monad a => b -> a b
02:31:42 <phubuh> [a] has an instance of Monad in which return has type a -> [a] and constructs a singleton list
03:38:39 <shapr> @fortune
03:38:39 <lambdabot> Tout choses sont dites deja, mais comme personne n'ecoute, il faut
03:38:39 <lambdabot> toujours recommencer.
03:38:39 <lambdabot> 		-- A. Gide
03:38:39 <lambdabot> [ All things have already been said, but since no one listens, one
03:38:40 <lambdabot>   must always start again. ]
03:39:09 <shapr> good morning #haskell!
03:39:39 <andersca> hej shapr
03:39:56 <shapr> hej andersca 
03:40:39 <shapr> what's going on?
03:50:25 <TripleDES> morning
04:09:39 <shapr> hi Arnia 
04:09:46 <Arnia> lo
04:10:12 <shapr> wassup?
04:19:27 <Arnia> Work work work... as usual :(
04:25:09 <shapr> had any time to write fun code?
04:37:26 <Arnia> I wish... I'm practicing my PDLC (Programming language design and compiling) stuff in haskell though
04:37:32 <Arnia> Java is too nasty for it
04:37:44 * Arnia wishes they weren't using java
05:10:25 <Lunar^> Arnia: Jerzy is doing his compiler course using Haskell
05:13:16 <shapr> yay!
05:20:33 <shapr> yay, new version of wiwiwi
05:23:04 <Lunar^> shapr: ?
05:23:51 <shapr> the code I got from sebc is later than what I have
05:23:59 <shapr> I think it might fix the bug I found
05:24:02 <Lunar^> shapr: cool
05:35:27 <shapr> oh, I think it won't fix the bug I found..
05:35:32 <shapr> fooey
05:35:38 <shapr> well, I'll fix it later.
05:38:02 <shapr> hm, any other darcs users here?
05:39:47 <Jad_> hello guys..
05:40:12 <Jad_> --- Ping reply from Jad_ : 38.58 second(s) hehe
05:57:04 <Arnia> Lunar^: I would, but the language we're being taught in is Java so I have to mentally transfer all concepts across. They're ugly in java anyway and feel more natural in haskell
06:05:40 <dark> Hello!
06:05:52 <Jad> llo
06:05:53 <Jad> hello
06:08:30 <dark> Hmm, shapr has an IPv address.
06:08:36 <dark> Er, IPv6
06:09:43 <Jad> ya
06:09:48 <Jad> and you can get one too
06:09:51 <Jad> freenet6
06:17:53 <dark> I should set up IPsec first.  I promised someone :)
06:20:19 <shapr> hi dark 
06:21:15 <dark> Hello :)
06:21:28 <dark> shapr: I made an account on A Tale in the Desert.
06:21:40 <shapr> oh, how far have you gotten?
06:22:15 <dark> I'm working on my initiation into Architecture.
06:23:23 <dark> I'm playing this as a puzzle game so I'm making everything myself :)
06:24:00 <shapr> fair enough
06:24:13 <shapr> I'm in the valley of kings, way way in the northwest.
06:24:17 <shapr> where have you set up?
06:24:20 <dark> I've made canvas and rope but I'm still working on nails.  Looks like nails are going to be an epic journey.
06:24:30 <dark> I'm in south Old Egypt.
06:24:47 <shapr> that's still relatively close to me I think, probably less than an hour's walk away.
06:25:16 <shapr> maybe I'll come visit you someday :-)
06:25:27 <dark> I've visited a University of Body that's surrounded by a ring of road, up on a hill.  I wonder if that was near you.
06:26:00 <dark> My name there is Nephte :)
06:26:12 <shapr> I'm not particularly thrilled with my guild at the moment, no one is in my timezone.
06:26:47 <shapr> I'd be highly tempted to resettle next to you if you're online around 10pm - 2am CET
06:46:05 <phubuh> monitors have strange proportions
06:46:14 <phubuh> I'd like one that's higher than it is wide
06:51:28 <basti_> hi all
06:51:43 <basti_> whats a quick way to do a thing on all possible pairs of a set?
06:52:42 <phubuh> [(a, b) | a <- foo, b <- foo]
06:52:43 <Lunar^> basti_: list-comprehension
06:52:54 <basti_> hm but what if the function is symmetrical?
06:53:04 <phubuh> what does that mean?
06:53:11 <basti_> and if I want to keep out the cases where both sides are equal?
06:53:17 <Lor> liftM2 (,)
06:53:27 <basti_> it doesnt matter if my function is (f a b) or (f b a), the results will be the same
06:53:36 <phubuh> oh, you could add , a != b
06:54:01 <Lunar^> phubuh: That won't do it
06:54:32 <phubuh> no, but will a /= b? :-)
06:54:39 <phubuh> oh, duh
06:54:42 <phubuh> I see what you mean now
06:54:52 <Lunar^> phubuh: This will only eliminate case like (1,1) (2,2)
06:55:01 <Lunar^> basti_: use span
06:55:04 <phubuh> yeah, I was temporarily insane
06:55:04 <basti_> span.
06:55:05 <Lunar^> @type span
06:55:08 <lambdabot> span :: (a -> Bool) -> [a] -> ([a],[a])
06:55:16 <Lunar^> Mhh.. not span
06:55:38 <basti_> but? ;)
06:55:39 <Lunar^> The one that does take and drop at the same time
06:56:11 <Lunar^> @type splitAt
06:56:11 <lambdabot> splitAt :: Int -> [a] -> ([a],[a])
06:56:21 <shapr> @type autoexec.bat
06:56:38 <Lunar^> But it's not the nicest because you have to know the length of the set
06:56:54 <basti_> tails sounds good.
06:57:01 <phubuh> nub [(max a b, min a b) | a <- foo, b <- foo] :-P
06:57:15 <basti_> gnnnh ;)
06:57:19 <Lunar^> phubuh: nice one :)
06:58:06 <basti_> i think with tails i can write a nice one quickly
06:58:21 <basti_> hm. do I?
06:58:24 * basti_ ponders
06:58:37 <Lunar^> basti_: don't think so
06:58:48 <basti_> yes, on the second thought.
06:59:21 <basti_> but maybe there's a witty recursive definition.
07:00:55 <basti_> ugly.
07:18:59 <maihem> what does nub do?
07:19:52 <basti_> remove duplicates
07:20:10 <basti_> Main> nub [1,2,1,3]
07:20:11 <basti_> [1,2,3]
07:24:48 <Lor> Not particularly efficiently, though...
07:26:39 <neniu> Is there any documentation about the performance of binaries made by ghc compiler as opposed to those generated by other compilers and other language compilers?
07:28:49 <Lor> I think it's generally accepted that ghc generates the most efficient code of all haskell compilers.
07:29:07 <Lor> Some sort of a general inter-language/implementation performance comparison can be found in the Shootout.
07:29:15 <shapr> yah, though it's getting real old now.
07:29:24 <shapr> the shootout used ghc 5.0 I think
07:29:25 <Lor> Yeah, a shame.
07:29:28 <dennisb> also, there are not that many haskell compilers
07:29:42 <Lor> ghc, hbc, nhc, that's it.
07:29:45 <shapr> right, GHC, nhc, hbc, 
07:29:56 <shapr> oh, there's a new one...
07:30:01 <shapr> uhc
07:30:19 <shapr> new as of ICFP
07:30:45 <shapr> I don't know much about it, but I think Swierstra & Co. at Utrecht are the people behind it.
07:30:53 <Lor> Ah, the UU folks.
07:31:02 <Lor> Apparently they had a presentation at HIM.
07:31:07 <dennisb> ghc - fastest, nhc - smallest
07:31:11 <shapr> famous ICFP Quote "And then I tuple it." --Swierstra
07:31:16 <shapr> yes, they did present it at HIM
07:31:28 <shapr> sort of
07:31:39 <shapr> Swierstra talked about his attribute grammar system a lot.
07:31:51 <shapr> Swierstra really likes talking about tuples.
07:32:12 <shapr> I can barely wait for the nhc98 on PalmOS
07:32:19 <shapr> I want to write PalmOS apps in Haskell!
07:32:21 <Lor> All right, so they have macros.
07:32:22 * shapr bounces!
07:32:24 <dennisb> shapr: tuples or tulips?
07:32:52 <shapr> tuples, but that's a funny joke :-)
07:33:05 <dennisb> shapr: yes, being dutch and all
07:33:23 <Lor> Wow, partial type specifications.
07:33:29 <Lor> That's what's been sorely missed.
07:33:41 <dennisb> Lor: where did you find them?
07:33:42 <shapr> uhc has some interesting new features.
07:33:44 <dennisb> I could use that
07:33:44 <Lor> http://cs-www.cs.yale.edu/homes/nilsson/HIM/Slides/Swierstra-UHC.pdf
07:33:58 <dennisb> aha, we are still talking uhc
07:34:27 <Lor> Hm, they claim that "f :: (a -> a) -> (b -> b)" is shorthand for "f :: (forall a. a -> a) -> (forall b. b -> b)". That can't be right?
07:34:36 <Lor> It'd break all existing code.
07:34:42 <shapr> has anyone here written a review or summary of the spiffy new Haskell editor thingies presented at ICFP?
07:35:09 <shapr> lessee, Programmatica was one, HaRe was one, and the structure editor, whose name I have forgotten.
07:35:48 <dark> Funny.  Usually when I'm stuck on a Haskell program, I can get unstuck by replacing a tuple type with a named type.
07:36:01 <dark> That would argue against the greatness of tuples :)
07:36:23 <Lor> Yeah, I agree, named types are much more legible and prevent confusion.
07:36:33 <Lor> Tuples are the quick and easy solution.
07:38:16 <shapr> Proxima might be the name.
07:38:31 <shapr> yes yes, http://www.cs.uu.nl/research/projects/proxima/
07:39:01 <shapr> ok, here's Programatica - http://www.cse.ogi.edu/~hallgren/Programatica/screenshots/
07:39:48 <shapr> HaRe - http://www.cs.kent.ac.uk/projects/refactor-fp/hare.html - haskell refactorer
07:42:19 <shapr> one of the coolest programatica feature was 'certificates'
07:43:02 <shapr> they're the generic name for programmatic assurances, like HUnit, QuickCheck, EProver, etc
07:43:16 <shapr> I think of them as inline unit tests
07:43:23 <shapr> Lor: is that related to proof carrying code?
07:43:47 <Lor> Depends on how they work.
07:43:54 <Lor> If they're implemented as run-time assertions, then no.
07:44:09 <shapr> so Design By Contract doesn't count as proof carrying?
07:44:23 <Lor> Nope.
07:44:59 <Lor> You can define the contracts and check (at runtime, or during testing) that they hold for individual cases, but there's no mechanism that _proves_ that the contracts will _always_ hold.
07:45:38 <shapr> sounds like QC and HUnit are also not proof carrying
07:45:46 <Lor> That's right.
07:45:48 <shapr> since QC is random, and HUnit only tests one case
07:46:06 <Lor> It's Bloody Hard to prove the correctness of real-world programs.
07:46:19 <Lor> (Depends of course on what exactly you mean by "correctness")
07:46:29 <shapr> yah, I was curious about that myself
07:46:38 <Lor> Actually, a very simple form of "proof carrying" is to have an explicitly typed language.
07:46:56 <Lor> Then the type annotations are the "proof" that the program is really well-typed.
07:47:04 <shapr> ah
07:47:24 <shapr> that bears out my original assumption about statically typed languages, that it's a very simple automated proof system.
07:47:32 <Lor> Yes.
07:48:01 <Lor> If you have a dependently typed language, there's no real way to distinguish between types and more complicated properties.
07:48:10 <shapr> I think type error slicing and Firm Typing combined would make a really powerful system.
07:48:12 <Lor> Coq, for instance, demonstrates this well.
07:49:17 <shapr> I'd like to be able to statically typecheck part of a program I'm writing, and let other parts be dynamically or weakly typed
07:49:21 <Smerdyakov> Proving memory safety is very easy with a strongly typed language.
07:49:41 <Smerdyakov> Proving that programs respect abstractions is also easy.
07:50:02 <shapr> prove it ;-)
07:51:44 <Smerdyakov> Was that any sort of serious statement or just a joke?
07:51:52 <shapr> some of both
07:52:17 <Lor> shapr, you can get "partial type-checking" just by having a Dynamic type and using that in those parts where you don't want type checking.
07:52:20 <Smerdyakov> It ought to be clear. If you know how a compiler works and you know it forces use of a safe type system, you can explain why the machine language program you get is safe.
07:52:26 <Lor> Of course the language should provide some mechanism to make this easy.
08:05:32 <ham[home]> hiho
08:05:56 <ham[home]> is anyone in here how has debian and can help me on hopengl?
08:06:36 <Igloo> What's the problem?
08:07:07 <ham[home]> i just apt-get install it but he seems to miss the files GL.hi and GLU.hi
08:07:29 <Igloo> What version do you have?
08:07:39 <ham[home]> of GHC?
08:07:43 <Igloo> Yup
08:07:52 <ham[home]> 6.0.1
08:07:57 <ham[home]> i located the files
08:08:08 <ham[home]> they are in /usr/lib/ghc-6.0.1/imports/Graphics/Rendering/OpenGL.hi
08:08:22 <Igloo> I mean the output of dpkg -s ghc6-hopengl | grep Version
08:08:26 <ham[home]> and and another path but the package seems to be inconsistent with that
08:08:40 <ham[home]> Version: 6.0.1-10
08:09:53 <ham[home]>  /usr/lib/ghc-6.0.1/imports/GLU.hi that the place where he seems to seek for the files
08:09:58 * Igloo looks for my test files, just a sec
08:10:06 <ham[home]> when i ghc6 Planet.hs -v
08:14:14 <shapr> I think this was recently discussed on the HOpenGL list
08:14:32 <ham[home]> oh any quick hint?
08:14:41 <shapr> er, yes, if I can find it.
08:15:20 <shapr> um, it's in the recent archives of the HOpenGL users mailing list.
08:15:28 <shapr> it's specifically about the debian HOpenGL packages
08:15:39 <ham[home]> cool thank you
08:15:48 <shapr> it's just two or three lines of changes, very simple stuff.
08:16:08 <shapr> I was going to file a bug about it.. but hadn't gotten there yet (just saw it yesterday)
08:17:24 <shapr> Igloo: have you already seen that thread on the hopengl users list?
08:17:29 <shapr> my info might be old...
08:18:03 <Igloo> I don't think I'm on the list
08:19:19 <shapr> ok
08:19:32 * shapr subscribes to far too many Haskell mailing lists
08:32:03 <ham[home]> hm so where would i change such things?
08:32:07 * Lor subscribes to about 30 lists, only six of them directly Haskell-related.
08:43:31 <ham[home]> hm so noone can help me atm ? will there be someone who might know that later on?
08:43:47 <ham[home]> and how would you implement quotient spaces in haskell?
08:43:56 <basti_> quotient spaces?
08:44:09 <ham[home]> ie
08:44:16 <ham[home]> a floor function
08:44:25 <ham[home]> |R -> Z
08:44:37 <Smerdyakov> I bet that's built in. :)
08:44:42 <ham[home]> that could be done with a quotient space
08:44:48 <basti_> i see
08:44:52 <basti_> i too bet ;)
08:44:55 <Smerdyakov> You have yet to phrase "quotient spaces" as a computational problem.
08:45:01 <Smerdyakov> Your question is unanswerable unless you do that.
08:45:08 <ham[home]> |R\{0<x<1}
08:45:37 <ham[home]> Smerdyakov: you know what a quotient space is?
08:45:47 <Smerdyakov> Yes, but I don't know of a "quotient space problem."
08:46:10 <Smerdyakov> And computers solve computational problems, not realize algebraic structures in some ill-defined way.
08:46:33 <ham[home]> hm
08:46:39 <ham[home]> ok anyhow another question
08:46:54 <Smerdyakov> So tell me exactly what types and operations you're looking for in "an implementation of quotient spaces" and we can talk.
08:47:05 <ham[home]> there is an example on the net where they build a binary tree
08:47:13 <ham[home]> sec :)
08:47:57 <ham[home]> let me search that other thing first
08:50:15 <ham[home]> http://www.informatik.uni-bonn.de/~ralf/teaching/Hskurs_2.html#SEC9
08:50:17 <ham[home]> this thing
08:50:28 <ham[home]> just look at the code of that thing not the language
08:50:45 <ham[home]> there ist that definition of bi
08:50:46 <ham[home]> big
08:51:02 <ham[home]> and then prune
08:51:18 <ham[home]> prune 2 (big 1) and in the end they use that to build a tree of depth 2
08:51:25 <ham[home]> i am really confused about that
08:51:42 <ecraven> is there anyone here from edinburgh? how's the university there for fp?
08:51:45 <ham[home]> because big is recursive isnt it ? that means it wont ever stop
08:52:01 <Smerdyakov> ecraven, it's a major center for the area historically, at least.
08:52:09 <Smerdyakov> ecraven, both ML and Haskell have origins there.
08:52:25 <ham[home]> so how is thta thing evaluated?
08:52:35 <Smerdyakov> ham[home], do you understand lazy evaluation?
08:52:37 <ham[home]> if big is evaled first then it cant ever stop
08:52:47 <ham[home]> i dont think so :)
08:52:57 <Smerdyakov> ham[home], nothing is evaluated until/unless it is needed.
08:53:17 <ecraven> Smerdyakov: i am thinking about going there a semester for my studies.. so i guess that would be a good idea ;-)
08:53:18 <ham[home]> ah ok that is if first gets composed
08:53:19 <Smerdyakov> ham[home], even if it appears in the body of a function clause that is used.
08:53:23 <ham[home]> and then it is evaled
08:57:25 <ham[home]> ok where is the config file for ghc?
08:57:27 <ham[home]> in linux
08:57:38 <ham[home]> or better whats its name
08:59:09 <Jad> shapr: ther ?
09:22:38 <ham[home]> hm ok i edited the package.conf file
09:22:49 <ham[home]> and mapped used the right paths
09:23:07 <basti_> sounds good
09:23:08 <ham[home]> now i get new errors what refer to some scoping errors in 
09:23:14 <ham[home]> the sample file
09:23:22 <basti_> *shrugs*
09:23:48 <ham[home]> what does it mean that a data constructor is not in scope?
09:24:07 <ham[home]> i mean i apt-get installed the stuff :) so i expect it to run
09:24:22 <basti_> lol
09:24:45 <basti_> probably that you cant reach a constructor because its outside of your namespace
09:24:51 <basti_> your trust in apt-get thats nice.
09:24:57 <ham[home]> no it isnt
09:25:01 <ham[home]> it didnt woek
09:25:02 <ham[home]> work
09:25:24 <ham[home]> and since no one in here was even able to tell me where the ghb config file is ...
09:26:07 <basti_> hm
09:26:30 <basti_> there is one? ;)
09:26:36 <ham[home]> yes
09:26:45 <ham[home]> and in there the error of the deb package is located
09:26:59 <ham[home]> since it enlists the place of the import files
09:27:17 <ham[home]> hey i just use haskell for 5mins and i know that it has a conf file why dont you know?
09:27:26 <basti_> I never cared honestly.
09:27:26 <basti_> ;)
09:27:42 <basti_> never tried to do pervert things though.
09:27:53 <ham[home]> like using libs?
09:27:59 <basti_> yes.
09:28:05 <ham[home]> that really seems pervert :)
09:28:08 * basti_ nods
09:28:15 <basti_> deeply.
09:28:25 <basti_> Since all real problems can be tackled by pure code.
09:28:46 <basti_> all the other things are not very interesting in my opinion.. problematic sometimes but not really interesting
09:29:21 <basti_> like, "how do I talk with my 3d Accelerator in Language X?"
09:29:42 <ham[home]> ?
09:30:23 <basti_> thats a nonproblem, as I do know how 3d Data is to be structured and what my 3d Acc. Expects
09:30:53 <ham[home]> can someone how has a working ghc6 hopengl please have a look in his or her conf file please?
09:30:54 <basti_> the only things left is telling the compiler via -l -L -X -xlib --L --X --R -D -x -x that it should get one damn library
09:31:09 * basti_ hasn't, sorry.
09:31:17 <ham[home]> its hosted by the haskell site and it seems to be a known problem
09:47:47 <ham[home]> Igloo: shapr` : can you help me further now what i changed the paths?
10:08:28 <ham[home]> damn
10:22:08 * Igloo can't easily find my code, and hasn't got time to fiddle right now
10:22:36 <ham[home]> Igloo: but you might help me later?
10:23:20 <Igloo> I'll probably either find them or recreate them in a few days
10:23:44 <ham[home]> what ? the code for hgl?
10:23:51 <Igloo> Yup
10:24:01 <ham[home]> do you maintain the package?
10:24:05 <Igloo> Yup
10:24:16 <ham[home]> ah ok then maybe i can help
10:24:32 <ham[home]> i will fiddle around a bit more
10:32:58 <Jad> shapr`: hello
10:50:30 <shapr> ahem
10:50:31 <shapr> hiya
10:50:53 <ham[home]> shapr: can you look into your package.conf?
10:51:13 <shapr> sure, but I doubt it's different than yours
10:51:46 <ham[home]> hm can you post it to me in a query please?
10:51:52 <shapr> ok
10:52:05 <ham[home]> i changed some stuff and he now finds the packages
10:52:15 <ham[home]> but the symbols are out of scope
10:52:27 <shapr> er, which one do you want? /usr/lib/ghc-6.0.1 ?
10:52:54 <ham[home]> yep
10:53:53 <ham[home]> dang wait
10:53:55 <shapr> that could have been too much
10:54:23 <ham[home]> http://nopaste.snit.ch/
10:54:25 <ham[home]> use that
10:55:07 <shapr> ok
10:55:31 <ham[home]> thanks a lot
10:55:52 <ham[home]> if its out of scope does it mean that its not defined at all?
10:55:58 <ham[home]> or that its just somewhere else?
10:56:12 <shapr> http://nopaste.snit.ch:8001/88
10:57:57 <shapr> I dunno, what's out of scope?
10:58:22 <ham[home]> BezMesh.hs:79: Variable not in scope: `setInitialWindowSize'
10:58:27 <ham[home]> can you run the samples?
10:58:46 <ham[home]> i get errors that he cant find the packages with the conf you have
10:59:54 <ham[home]> ie this one
10:59:55 <ham[home]> http://haskell.org/HOpenGL/examples/BezMesh.hs
11:01:46 <shapr> shouldn't it be Graphics.something?
11:02:07 <ham[home]> thats the official sample file on the site
11:02:29 <ham[home]> and if i apt-get the stuff then it cant finde the packs
11:02:39 <ham[home]> if it finds the packs then the symbols are out of scope
11:03:16 <shapr> hmm
11:03:46 <ham[home]> i am a bit confused :)
11:03:53 <shapr> have you already applied the changes mentioned on the mailing list?
11:03:54 <Arnia> Are the identifiers being exported to somewhere the file with the error can get to them?
11:04:13 <ham[home]> shapr: wasnt that reported for win32?
11:04:36 <shapr> no, the debian changes
11:04:49 <ham[home]> i have only found something on win32 cygwin
11:05:22 <shapr> hrm
11:06:35 <shapr> http://haskell.org/pipermail/hopengl/2003-October/thread.html
11:06:53 <shapr> http://haskell.org/pipermail/hopengl/2003-October/000428.html
11:07:19 <shapr> http://haskell.org/pipermail/hopengl/2003-October/000430.html
11:07:25 <shapr> those last two suggest fixes
11:07:29 * shapr tries
11:07:39 <ham[home]> k sec
11:11:14 <ham[home]> shapr: same prob
11:11:22 <shapr> hmm
11:11:44 <shapr> where did you get the BezMesh.hs ?
11:11:54 <ham[home]> http://haskell.org/HOpenGL/examples/BezMesh.hs
11:11:59 <ham[home]> thats the official site
11:12:03 <ham[home]> http://haskell.org/HOpenGL/
11:13:11 <ham[home]> that is the symbols are out of scope
11:13:50 <shapr> which symbols?
11:13:59 <shapr> what's the error message?
11:14:01 <ham[home]> BezMesh.hs:80: Variable not in scope: `setInitialWindowPosition'
11:14:07 <ham[home]> its super long sec ill poste it
11:14:21 <shapr> can you pasted just the first three lines or so?
11:14:39 <ham[home]> yep
11:14:56 <ham[home]> er no
11:15:06 <ham[home]> since they are so numerous and i cant scroll up
11:15:08 <ham[home]> sec
11:15:21 <ham[home]> ghc6 ... > out should write it to a file right?
11:15:34 <shapr> probably
11:15:52 <ham[home]> but it doesnt
11:16:28 <shapr> oh pooh
11:16:35 <ham[home]> damn
11:16:37 <ham[home]> sec
11:16:37 <shapr> I'm getting the TLS problem.
11:16:42 <ham[home]> tls?
11:16:56 <shapr> yay!
11:17:05 <shapr> Prelude> :set -package GLUT
11:17:06 <shapr> Loading package OpenGL ... linking ... done.
11:17:06 <shapr> Loading package GLUT ... linking ... done.
11:17:06 <shapr> Prelude>
11:17:17 <ham[home]> hm
11:17:20 <shapr> I'm using the nvidia drivers, they're picky
11:17:42 <shapr> now that I've made the changes mentioned, it works (mostly)
11:17:49 <shapr> Prelude> :set -package GLUT
11:17:49 <shapr> Loading package OpenGL ... can't load .so/.DLL for: GL (/usr/lib/tls/libGLcore.so.1: undefined symbol: __gl_tls_var0)
11:17:56 <ham[home]> ok so you can compile that file?
11:17:58 <shapr> is that the undefined symbol you get?
11:18:11 <ham[home]> nope i mean haskel variables and data types
11:18:15 <ham[home]> like ie
11:18:26 <ham[home]> BezMesh.hs:83: Variable not in scope: `setReshapeCallback'
11:18:29 <ham[home]> but i cant scroll up
11:18:35 <ham[home]> and i cant even use | more
11:19:23 <ham[home]> BezMesh.hs:28: Variable not in scope: `enable'
11:19:28 <ham[home]> ok thats the first error
11:19:39 <shapr> hrm
11:20:03 <shapr> lemme update my fptools cvs and grep for that
11:22:26 <Jad> shapr: check out my pics at http://saklawi.info
11:22:39 <shapr> ok
11:23:46 <shapr> stylish beard :-)
11:23:53 <Smerdyakov> Jad, you misspelled "clustering" on your front page.
11:24:05 <Jad> oops
11:24:06 <Jad> \k
11:24:11 <Jad> will fix it now..
11:24:11 <shapr> the urls are broken in the page, they point to file://home/test/www/
11:24:20 <Jad> oooops
11:24:44 <Jad> shapr: from here every thing seems fine
11:25:16 <Jad> http://saklawi.info/pics/devil.jpg
11:25:21 <Jad> http://saklawi.info/pics/grandpa.jpg
11:25:35 <Smerdyakov> All seems fine to me, too.
11:25:55 <Jad> shapr: probably your client
11:25:59 <shapr> hm, weird
11:26:06 <Smerdyakov> Argh. You seem to have used an HTML editor to make it. The source code is ugly!
11:26:18 <Jad> Smerdyakov: ya
11:26:18 <Smerdyakov> <big><big><small><small>
11:26:22 <Smerdyakov> ^-- actual excerpt! :D
11:26:23 <Jad> the mozilla composer
11:27:12 <Jad> Smerdyakov: suggest any other editor ?
11:27:20 <phubuh> emacs! :-)
11:27:20 <Smerdyakov> Yeah. emacs.
11:27:39 <shapr> yay emacs!
11:27:45 <shapr> ham[home]: aha, I'm making progress
11:27:49 <shapr> import Graphics.Rendering.OpenGL.GL
11:27:50 <shapr> import Graphics.Rendering.OpenGL.GLU
11:28:03 <Jad> Smerdyakov: i don`t want to write html
11:28:08 <ham[home]> sec ill go along ;)
11:28:09 <Jad> something visual
11:28:22 <Smerdyakov> Jad, then you pay the price!
11:28:33 <phubuh> there should be some non-WYSIWYG visual editors
11:28:39 <phubuh> like LyX
11:28:43 <shapr> uh oh
11:28:49 <Smerdyakov> Jad, also, listing all the hax0ring programs you've written is probably a bad idea. Maybe have a separate page for it with a clear acknowledgement that you disavow it. :)
11:29:08 <shapr> if lambdabot just disappeared, it probably means the drive finally died.
11:29:08 <Jad> ya
11:29:14 <Jad> i hate them..
11:29:21 <phubuh> shapr: ooops.
11:29:26 <Jad> they are from the winblows days..
11:29:37 * Igloo runs across my HGL bits, but finds they no longer build
11:30:05 <Smerdyakov> Jad, how long ago was that?
11:30:38 <Jad> i think 2 to 3 years ago
11:30:50 <Jad> i was a dual booter then
11:31:20 <Smerdyakov> Well, better get busy coming up with some constructive projects to list instead. :)
11:31:33 <Smerdyakov> And then join #hprog.
11:32:17 <Jad> actually am doing working on various projects..
11:32:30 <Smerdyakov> OK. Then come to #hprog, the channel for hobbyist programmers!
11:32:55 <shapr> this is a channel for code magicians ;-)
11:33:19 <shapr> ham[home]: something strange here, the enable function in BezMesh seems to be in Capability, but is not exported.
11:33:36 <Jad> i thought first it meant haskell programing
11:33:45 <ham[home]> shapr: so you have the same error?
11:33:58 <shapr> ham[home]: yah, I have a bunch of errors, and I think I know why.
11:34:10 <ham[home]> shapr: ah cool
11:34:13 <shapr> problem is, there are two flavors of Sven Panne's opengl <--> haskell binding
11:34:19 <ham[home]> shapr: then we have the same probs
11:34:31 <shapr> there's fptools/libraries/OpenGL, and there's something else
11:34:42 <shapr> I can never tell which one is the most current and should be used
11:34:44 <ham[home]> shapr: hm is that easy to fix?
11:34:54 <shapr> I don't know, I'll send an email to the mailing list and ask.
11:35:21 <shapr> Igloo: do you have a few moments? do you know the difference between OpenGL bindings?
11:35:32 <shapr> I think I've asked this before, but I don't remember the answer.
11:35:37 <Igloo> Not OTTOMH, no
11:35:47 <Igloo> Have you managed to get anything to compile and run OOI?
11:36:18 <shapr> :set -package GLUT works in GHCi
11:36:45 <shapr> once I do "export LD_PRELOAD=/usr/lib/libGL.so:/usr/lib/libGLcore.so.1"
11:37:16 <shapr> and GLUT depends on OpenGL, so something is working.
11:37:36 <Igloo> DrawBufferBack seems to have disappeared
11:38:04 <shapr> lemme see if I can find the cube you wrote
11:38:19 <Igloo> I think that's what I'm looking at
11:38:32 <shapr> ah, I see
11:38:52 <shapr> I'm also missing depthTest
11:39:14 * Igloo finds there are about a gazillion buffer modes
11:39:44 <shapr> I suspect Sven Panne's binding is too faithful for me
11:39:51 <shapr> I know nothing about OpenGL
11:40:48 <shapr> ham[home]: do you know anything about OpenGL the standard?
11:41:11 <ham[home]> a little bit why?
11:41:23 <shapr> Igloo: may I redistribute GLCube.hs ?
11:42:36 <Igloo> Yup
11:42:58 <Igloo> BackBuffers is I think what you want instead of DrawBufferBack. Not sure about depthTest yet.
11:45:32 <shapr> ham[home]: http://www.haskell.org/hawiki/HaskellOpenGl
11:45:54 <ham[home]> shapr: that i should test?
11:46:02 <shapr> not yet, but it's much closer
11:46:10 <ham[home]> k
11:46:46 <shapr> if you want to do something with the debian packages, that's a good place to start looking at code.
11:47:01 <Igloo> You want GLUT.Double rather than Double I think
11:47:05 <shapr> thanks for the opengl debs and the demo code goes to Igloo of course :-)
11:49:54 <Igloo> I'm not very familiar with the code, but it looks to me like CapDepthTest is no longer makeCapability'd for some reason. CVS logs (or the appropriate -cvs list) might tell you what happened to it.
11:50:05 <Igloo> If you find the answer, let me know please
11:54:32 <shapr> Igloo: I just commented out that line
11:54:49 <Igloo> Does the cube look right?
11:54:56 <shapr> no, it looks like an Escher panting now
11:55:01 <shapr> but it does compile and run :-)
11:55:08 <Igloo> Right, depth testing isn't enabled  :-)
11:55:38 <shapr> ok, lemme paste the working version to the page
11:57:48 <shapr> ham[home]: ok, 'ghc --make GLCube' should work with the source on that page now.
11:57:53 <shapr> Igloo: thanks for your help!
11:58:09 <ham[home]> k sec
11:59:18 <ham[home]> shapr: you are my hero :)))
11:59:21 <ham[home]> thank you super much
11:59:58 <shapr> credit goes to Igloo for working code
12:00:10 <shapr> I just knew who to ask :-)
12:00:10 <ham[home]> Igloo: thank you too
12:00:23 <ham[home]> someone should talk to that mr with the non working code
12:00:53 <shapr> ham[home]: alternatively, we can start some OpenGL docs/examples on HaWiki
12:01:02 <ham[home]> :)
12:01:14 <ham[home]> i just wanet a quick start to have a look at that
12:01:15 <shapr> then when we have some useful stuff, we can post on the mailing list, and Sven Panne can link to it.
12:01:28 <ham[home]> maybe i will write some fun stuff
12:01:31 <shapr> I have overblown fantasies of doing machinima with HOpenGL
12:02:22 <ham[home]> i wanted to do some fun math stuff
12:02:28 <ham[home]> from linear algebra
12:02:39 <ham[home]> as some kind of tutoring system for LA
12:02:47 <shapr> that sounds useful!
12:02:56 <shapr> I was thinking of making movies.
12:03:43 <shapr> There's a tiny movie industry starting up where people use existing 3D game engines to make movies.
12:04:01 <shapr> I've seen people use the Half-Life engine, the unreal tournament engine, and several others.
12:04:24 <shapr> you get low-quality Pixar style movies for a millionth of the cost.
12:04:44 <ham[home]> yeah
12:04:51 <ham[home]> shapr: have you seen that lately on german tv?
12:04:55 <shapr> here's a fun example: http://www.redvsblue.com/bloodgulch.shtml
12:05:01 <ham[home]> i have been working as an engine programmer
12:05:07 <shapr> ham[home]: no, I don't watch TV in the country where I live, much less Germany.
12:05:13 <shapr> ham[home]: oh really! tell me more!
12:05:28 <ham[home]> ah cause thay also told so on german tv
12:05:30 <ham[home]> sec
12:05:36 <ham[home]> shapr: are you on a bit longer?
12:05:48 <ham[home]> i need to help a friend with his math homework
12:05:52 * Smerdyakov wonders what a bit longer does.
12:05:54 <Smerdyakov> Does it long bits?
12:06:40 <shapr> ham[home]: sure
12:06:46 <ham[home]> shapr: cool ok
12:07:05 <shapr> ham[home]: plus you can come back anytime and talk to me, it's no hurry
12:07:13 <ham[home]> cool
12:07:22 <ham[home]> its just one or two tasks
12:07:32 <ham[home]> but the teacher hasnt defined the task very well
12:26:53 <shapr> crap, I think raven is dead.
12:27:04 <shapr> fooey
12:27:16 <phubuh> your pet raven? :-(
12:27:59 <shapr> no, my colocated box, raven.scannedinavian.org
12:28:05 <Riastradh> Quoth the Raven, 'Nevermore.'
12:28:24 <shapr> I have raven, thunderbird, couatl, ostrich, and chicken
12:28:53 <shapr> they're all avians, though it's easy to argue about couatls.
12:29:51 <ham[home]> ok
12:30:01 <ham[home]> shapr: i worked for a company named codecutl
12:30:06 <ham[home]> www.codecult.com
12:30:26 <shapr> neat!
12:30:48 <ham[home]> http://www.nvidia.com/object/games_codecult.html
12:30:57 <shapr> does codecreatures run on Linux?
12:30:59 <ham[home]> we did a demo for nv for the gf4ti
12:31:03 <ham[home]> nope
12:31:07 <shapr> too bad
12:31:08 <ham[home]> its dead
12:31:13 <shapr> why?
12:31:27 <ham[home]> but if it would have come to an end it would have been able to compile on linux
12:31:35 <ham[home]> because our mother company
12:31:42 <ham[home]> they did business fraud
12:31:47 <shapr> yikes
12:31:56 <ham[home]> and then we had to go since we where expansive
12:32:01 <ham[home]> i also worked on gothic
12:32:05 <ham[home]> a rpg game
12:32:11 <shapr> and like all the companies I've worked for, you can't release source code, you might sell it one day.
12:32:15 <ham[home]> and on black and white as a beta tester
12:32:20 <shapr> oh cool
12:32:32 <ham[home]> and i dream about a functional real engine
12:32:40 <ham[home]> though a dynamic one
12:32:57 <ham[home]> such that you can compile at runtime the engine to your needs
12:33:16 <shapr> have you read about the Self virtual machine?
12:33:33 <ham[home]> nope
12:33:55 <ham[home]> i want to write my thesis about something like that in general
12:33:56 <shapr> JIT compilers have been around since the 70s at least, but I think the Self VM started the Java JIT craze
12:34:21 <shapr> http://gliebe.de/self/index.html
12:34:47 <shapr> Sun Research did Self, originally as a better Smalltalk
12:34:57 <ham[home]> nice
12:35:04 <shapr> when Self was in active development, it was faster than commercial Smalltalk implementations
12:36:53 <shapr> Self has a variety of spiffy features.
12:37:47 <ham[home]> like?
12:38:11 <ham[home]> i want to write my thesis about a distubuted graph like language
12:38:18 <ham[home]> that is mathematically motivated
12:38:22 <shapr> oh, you should probably check out Erlang
12:38:29 <shapr> or the distributed flavors of GHC
12:38:32 <ham[home]> it uses irc :)
12:38:49 <shapr> I think you can find a better protocol than IRC
12:39:00 <ham[home]> yes i just want to use it for easy
12:39:08 <ham[home]> i need the channels
12:39:24 <ham[home]> you where familiar with category theory right?
12:39:31 <shapr> have you seen Plan9 and Inferno?
12:40:10 <shapr> I only understand some of category theory
12:40:30 <ham[home]> plan9?
12:40:37 <ham[home]> i want to ground my thing on CT
12:40:42 <ham[home]> at least do a certain extend
12:40:50 <ham[home]> and use that casl thing to make proofs
12:41:09 <shapr> ah
12:41:39 <shapr> Inferno is an interesting distributed system
12:41:43 <shapr> http://www.vitanuova.com/products.html
12:41:54 <shapr> oh, and they have a free license now, that's new...
12:42:03 <ham[home]> the idea is that you can spread the program with irc
12:42:10 <ham[home]> or another channel system
12:42:16 <ham[home]> and you can write programs in that
12:42:40 <ham[home]> and i do that to make proofs structually and to make use of graph theory etc
12:42:40 <shapr> I don't understand
12:42:55 <ham[home]> the listeners in the channel are functions :)
12:43:33 <ham[home]> and you can do multiparadigm programming since the listeners can be implemented in all languages that support net stuff
12:43:58 <shapr> sounds interesting
12:44:38 <ham[home]> i hope so
12:44:44 <ham[home]> i do that for ai purpose
12:44:53 <ham[home]> i want you to see the structre of a program
12:45:12 <ham[home]> and make you able to reuse the structures
12:45:27 <ham[home]> and as in lisp data are channel linkings also (graphs)
12:45:56 <ham[home]> er :)
12:45:59 <shapr> it sounds somewhat like the listeners and channels stuff in Inferno
12:46:08 <ham[home]> as in lisp there is no difference in data and programs
12:46:22 <ham[home]> cook
12:46:24 <ham[home]> er cool
12:46:44 <shapr> do you have a more detailed write-up on it online?
12:46:51 <ham[home]> nope not yet
12:47:00 <ham[home]> i still try to get it as my thesis topic
12:47:16 <ham[home]> i have to persuade my profs that its cool and managable
12:47:24 <ham[home]> its my bachelors thesis :)
12:47:28 <shapr> ah, neat
12:47:35 <ham[home]> but as soon as they tell me its ok i start
12:47:53 <ham[home]> and it will be finished quickly i think
12:48:05 <ham[home]> cause the idea is simple
12:48:18 <ham[home]> just tools are needed maybe you can help me on some haskel parts
12:48:33 <ham[home]> i want to integrate haskell, prolog and lisp
12:49:37 <ham[home]> also there are different modes that a channel can run in
12:49:53 <ham[home]> one mode like in haskell or prolog that matches an input and xors
12:50:29 <ham[home]> or another mode that runs all functions in paralell which might be interesting for things like asyncronus neural networks or so
12:51:23 <shapr> I think you should write it up
12:51:52 <ham[home]> yes
12:52:08 <ham[home]> its all in my head now for years
12:52:25 <ham[home]> and i just wait for the ok
12:52:38 <ham[home]> i have plenty other ideas :) and am really leazy
12:52:43 <ham[home]> i need a secretary
12:52:47 <ham[home]> er lazy
12:53:33 <shapr> well, write up your ideas
12:53:50 <ham[home]> but if its allowed for other to read along i would be happy if you want to have a look on it
12:54:23 <ham[home]> i have alway some productive phases and i think one is coming up again with haskell
12:55:09 <ham[home]> or under preassure :)
12:55:10 <shapr> I'm willing to read stuff that you write, sure.
12:55:16 <ham[home]> cool
12:55:30 <ham[home]> have you got my url?
12:55:43 <shapr> no, what is it?
12:55:45 <ham[home]> maybe you also want to have a look at my game project
12:55:54 <ham[home]> http://codemages.sf.net
12:56:10 <ham[home]> i might change from lisp to haskell if i like hgl ;)
12:57:36 <shapr> ok, I have it bookmarked.
12:59:52 <ham[home]> i should update it sometime soon with new stuff :)
13:02:38 <shapr> hi esap 
13:02:41 <esap> Hi
13:03:58 <ham[home]> ah hello esap  :)
13:04:22 <esap> What's up?
13:04:55 * esap finally understands how to do OO design in Haskell.
13:05:15 <ham[home]> isnt that a bit like in lisp?
13:05:25 <ham[home]> object model
13:06:05 <esap> well that's the goal. It's not quite that easy, because Haskell doesn't really have good builtin support for inheritance or anything close.
13:06:49 <ham[home]> shapr: is there an dl version of plan9?
13:07:19 <ham[home]> shapr: btw :) http://www.imdb.com/title/tt0052077/
13:08:27 <phubuh> plan9 is almost free software (it would be completely free if there wasn't some hairy issue regarding suing the creators), and the name is taken from the sci-fi movie
13:09:09 <shapr> phubuh: have you seen the source release of Inferno 4 ?
13:09:15 <shapr> hello hokie, how are ya?
13:09:16 <phubuh> nope, what's that?
13:09:28 <shapr> Inferno is the successor to plan9
13:09:35 <phubuh> ooh
13:09:37 <shapr> http://www.vitanuova.com/products.html
13:09:41 <hokie> the hokies just lost. been better.
13:09:57 <shapr> is that a sports team?
13:10:04 <hokie> college football
13:10:11 <hokie> (usa)
13:10:15 <ham[home]> phubuh: where can i dl it?
13:10:30 <shapr> hokie: for which college?
13:10:39 <ham[home]> i mean i dont want to pay that much money for something i just want to hab e look at
13:10:42 <hokie> virginia tech
13:10:45 <shapr> ah
13:10:51 <hokie> don't ask what a hokie is. nobody knows
13:10:56 <ham[home]> esap: do you know MOP
13:10:57 <shapr> ok, sure.
13:11:22 <esap> ham: well I've looked at it once or twice, so no, not really.
13:11:34 <shapr> hokie: so, you learning Haskell?
13:11:46 <ham[home]> esap: i mean that would be something that should be possible also in haskell
13:12:41 <hokie> yeah, i know a little bit
13:13:10 <esap> ham: but it's based on lisp macro things, wasn't it? Hmm. maybe template haskell?
13:13:17 <hokie> do you think most of the people are hobbyists or professional haskellers?
13:13:26 <hokie> (insert "here")
13:13:39 <shapr> I think most people here are hobbyists.
13:13:43 <ham[home]> esap: i thoght on somthing like that
13:14:26 <ham[home]> esap: let O be the objects O x O -> O
13:14:53 <hokie> cool. i just installed wxhaskell
13:14:59 <ham[home]> i dont know about the internals of haskell but i think that in lisp the object can be extended
13:15:04 <hokie> pretty nifty stuff
13:15:08 <ham[home]> by rewriteing it
13:16:35 <shapr> skew has been talking about multiple inheritance in Haskell via overlapping instances, where GHC choose the most specific
13:16:53 <shapr> support for that sort of thing will be in the next release of GHC
13:17:09 <shapr> most specific overlapping instances, that is
13:17:38 * shapr writes an ode to the suckiness of mice, and web-browsers that are not keyboard controllable
13:17:38 <ham[home]> cool
13:17:58 <ham[home]> also i just read something about quotening in languages
13:18:21 <esap> shapr: that's very interesting. I've mostly just used the module system to simulate proper dependencies, and then built layered design.
13:18:52 <shapr> the most specific thingy was recently discussed on the mailing list
13:18:52 <ham[home]> http://tunes.org/HLL/principles.html
13:19:09 <ham[home]> Quotienting
13:28:24 <esap> This tunes HLL thing seems interesting but I wonder whether there is some concrete results somewhere?
13:28:36 <hokie> ham: still around?
13:28:52 <hokie> i read the log at tunes.org to catch up
13:28:52 <ham[home]> yep
13:29:03 <ham[home]> nope i dont think so
13:29:14 <hokie> what's your favorite example of CT in action?
13:29:15 <ham[home]> there is a #tunes on this server :)
13:29:30 <ham[home]> haskell?
13:29:43 <hokie> yeah, or anything in cs
13:29:57 <ham[home]> haskell uses also CT doesnt it?
13:29:59 <hokie> i know the basics of ct, but don't understand why cs people go gaga for it
13:30:12 <ham[home]> i mean that eval diagram is at least motivated by it
13:30:17 <hokie> i don't know. it doesn't show up in the report
13:30:27 <ham[home]> in what report?
13:30:31 <hokie> haskell98
13:30:40 <ham[home]> i think its because of the compositionality
13:30:57 <ham[home]> and that you can prove things by structure
13:31:06 <ham[home]> at least that is why i want to have it
13:31:07 <ddarius> hokie: The concept of monad is from category theory.
13:32:12 <hokie> ok, good example
13:32:18 <ham[home]> isnt the monand the reason for lazy eval?
13:32:23 <ddarius> No
13:32:35 <ham[home]> but its only possible because of that
13:32:39 <ham[home]> ?
13:32:40 <Riastradh> Monads have nothing to do with lazy evaluation.
13:32:50 <ham[home]> but with curry
13:33:04 <Riastradh> ?
13:33:08 <shapr> mice make touch-typing difficult.
13:33:10 <esap> monads implement sequential composition.
13:33:22 <ham[home]> wanst the monand something that reduces something like T^2 to T?
13:33:41 <Riastradh> Monads are just CPS that work on computations other than functions.
13:33:46 <phubuh> bah, I keep wanting to instantiate for String
13:34:22 <ham[home]> but stuff like that thing i asked before with that prune (big 1)
13:34:53 <ham[home]> thats just possible because that gets mapped to the curried function right? and it doesnt eval the (big 1) first
13:34:54 <phubuh> why can't I, by the way?
13:35:36 <ddarius> Because it would overlap with a general [a] instance.
13:36:26 <phubuh> couldn't the most specific instance be picked?
13:36:27 <ddarius> ham[home]: currying has nothing to do with lazy evaluation either.
13:37:03 <ddarius> phubuh: Yes, but Haskell 98 doesn't specify that.
13:37:12 <ham[home]> ddarius: but if that thing was evaluated conseqently it would never stop
13:37:19 <phubuh> oh well.
13:37:38 <ddarius> You can try an overlapping instances extension.
13:37:43 <ddarius> Both GHC and Hugs should support it.
13:37:53 <phubuh> aha!
13:38:21 <ddarius> ham[home]: that has nothing to do with currying though.
13:38:49 <ham[home]> ddarius: but it wasnt possible without curry right?
13:39:00 <Riastradh> Currying, lazy evaluation, and monads are all _totally_ orthogonal.
13:39:28 <ham[home]> :)
13:39:30 <phubuh> all currying can trivially be replaced with lambda expressions
13:39:33 <ddarius> ham[home]: If currying has nothing to do with lazy evaluation, why would it be needed to implement lazy evaluation.
13:39:49 <ham[home]> ok but 
13:39:50 <ddarius> @define ones 1:ones
13:39:52 <Riastradh> I can curry a Scheme function.  Scheme still isn't lazy.
13:40:01 <ham[home]> if prune (big 1) -> f
13:40:04 <ddarius> Bah!
13:40:16 <ham[home]> then f wont be non terminating
13:40:19 <Riastradh> I can use monads within Scheme.  That doesn't mean I'm using currying.  Scheme is _still_ not lazy.
13:40:35 <esap> I think currying and monads are not totally orthogonal [monads and composition are alike, and composition and functiona application are alike, and currying is inverse of function application. So not orthogonal :-) ]
13:40:40 <Riastradh> I can use laziness in Scheme with DELAY, FORCE, and LAZY.  But that doesn't mean I'm using monads or currying.
13:41:20 <ham[home]> ok so why does prune (big 1) not run endlessly?
13:41:33 <Riastradh> What is big defined as?
13:41:39 <ham[home]> and how can you achive it without rewriting it as a new function
13:41:42 <ham[home]> sec
13:42:16 <ham[home]> http://www.informatik.uni-bonn.de/~ralf/teaching/Hskurs_2.html#SEC9
13:42:26 <ham[home]> just look at the def not the other text
13:43:12 <ham[home]> i dont see how you can run throught the functions sequenceially without ending up in non stopping
13:43:15 <Riastradh> big 1 doesn't terminate because Haskell is non-strict.
13:43:18 <Riastradh> Er.
13:43:21 <Riastradh> It _does_ terminate.
13:43:41 <ham[home]> it defined as an endless recursion right?
13:44:01 <ham[home]> and its cut by prune
13:44:03 <Riastradh> Yes, it is, and the recursive calls don't occur until they are needed.
13:44:22 <ham[home]> so its needed when i call prune
13:44:26 <ham[home]> right?
13:44:40 <ham[home]> at some point that has to be evaled
13:44:52 <ham[home]> and if i just eval big 1 then its non ending
13:44:53 <Riastradh> Yes, but then, the recursive calls to prune aren't evaluated until _they're_ needed.
13:45:29 <ham[home]> hm that is?
13:45:43 <ham[home]> when prune accessen an element in that tree?
13:46:02 <ham[home]> then the eval calls the eval of big for that element?
13:46:31 <Riastradh> When you call prune, it does deconstruct something that big lazily constructed, so what big created is suddenly 'needed' and it gets evaluated; but what prune constructs is not needed yet, so it is constructed lazily, and the calls to prune aren't called until they're needed.
13:46:36 <ham[home]> what i thought was that this thing gets maped to a new function
13:46:37 <ham[home]> f
13:47:19 <ham[home]> hm i think i just will read up on lazy eval :)
13:47:45 <ham[home]> but in genral that also would have been managable with the monand right?
13:48:23 <Riastradh> This has _nothing_ to do with monads.
13:48:40 <ham[home]> i didnt ask how its done in haskell
13:49:08 <ham[home]> but i can map that two functions to one function that does not run endlessly right?
13:56:01 <ddarius> Yes, because that question is underspecified.  Here's such a mapping: (\_ _ -> id)
13:56:22 <ham[home]> ok thank you :)
13:57:54 <ham[home]> do you have a bot here that can learn links?
13:58:28 <shapr> our bot used to learn stuff.
13:58:37 <ham[home]> http://planetmath.org/encyclopedia/Monad.html
13:59:09 * Smerdyakov wonders.... why have PlanetMath when you have Wikipedia?
14:00:07 <ham[home]> dunno i really like planet math
14:00:29 <ham[home]> plus wikipedia doesnt make use of latex
14:05:27 <`john> .0
14:43:38 * shapr sings the grinch song
14:43:49 <shapr> o/~ you're a mean one, Mr. Grinch o/~
14:43:57 <shapr> g'day clausen 
14:44:05 <clausen> gday
14:44:15 <clausen> btw, my thesis is online :)
14:44:20 <shapr> cool, whereat?
14:44:20 <clausen> (same stuff, with more detail and diagrams :)
14:44:27 <clausen> members.optusnet.com.au/clausen/reputation
14:44:34 <shapr> has google hired you yet?
14:44:57 <shapr> have you known about referrer spam forever?
14:45:13 <clausen> "referrer spam" ?
14:45:16 <clausen> google haven't hired me :)
14:45:25 <clausen> (I'd rather do a PhD, anyway)
14:45:28 <clausen> (Free Money!)
14:45:43 <shapr> oh, can I get a quote on your photos page?
14:45:49 <clausen> yep :)
14:45:58 <shapr> hm, can I do it in swedish?
14:46:25 <clausen> yep... I can include a translation too :)
14:46:47 <shapr> cool
14:49:43 <shapr> Det finns många klädstil, men Clausens är enastående. - There are many clothing styles, but Clausen's is outstanding.
14:49:53 <clausen> hehe
14:50:09 <shapr> Shae Erisson - Boden, Sweden
14:50:33 <shapr> :-)
14:50:50 <shapr> I think slashdot had an article on referrer spam recently.
14:51:09 <clausen> could you say what the term means?
14:51:19 <clausen> (it is probably the same as something I already know?)
14:51:54 <shapr> I don't know, it just means that a porn site will list itself in the referrer, it's mostly for weblogs where people publish their referrer logs
14:52:19 <shapr> http://yro.slashdot.org/article.pl?sid=03/11/26/1319224
14:52:33 <shapr> seems that it's considered a google attack
14:52:42 <shapr> thought you might be interested in it.
14:53:35 <clausen> I am aware of "guest book" attacks
14:54:29 <clausen> ah, I see
14:54:33 <clausen> yeah, referrer logs are a bad idea
14:55:15 <clausen> (they are essentially the same as guest books)
14:55:45 <clausen> the way to do them is to require them to be AUTHed by the owner's page
14:56:19 <shapr> authed?
14:56:50 <clausen> authenticated
14:57:06 <clausen> i.e. the owner clicks on a box... "yes the referrer is genuine, I will link them"
14:57:20 <shapr> ah
14:57:38 <clausen> but, in the context of PageRank, this isn't so good either
14:57:45 <clausen> Google assumes that hyperlinks are recommendations
14:58:05 <clausen> it would be useful if they provided a meta-tag: "no-recommend", or something
14:58:38 <shapr> oh, I like your TODO server idea
14:59:11 <shapr> hey, I thought of something like conditional RSVPs
14:59:22 <shapr> but instead for the bus system
14:59:24 <isomer> savannah and sourceforge have job postings, which are like your todo idea, actually
14:59:38 <shapr> hi anth
14:59:49 <shapr> wazzup?
15:00:01 <isomer> hi shae!
15:00:18 <isomer> just studying...and irc'ing
15:00:22 <isomer> (is that a bad combo?)
15:00:30 <isomer> what about you? what are you up to?
15:00:38 <shapr> I wanted to do the traveling salesman problem with buses, but dynamically add stops as people use cell-phones to say they're at X and want to go to Y
15:00:56 <shapr> I'm working and irc'ing. it's even worse :-)
15:01:22 <isomer> i actually find it gives me just the right amount of distraction so i can study for several hours without a big break
15:01:51 <shapr> I remember that the sidewalks at one of the Universities I went to were nearly unused, there were heavily used dirt paths that were far more efficient
15:02:07 <isomer> same at carleton
15:02:30 <shapr> at some point I read about a university that would build a building, but would only build a sidewalk once a dirt path became sufficiently popular :-)
15:02:36 <shapr> I thought that was flat out brilliant.
15:02:48 <isomer> :)
15:03:28 <shapr> so I think you can apply the same thing to bus routes. put buses in major cities, give a very general route, point A to point B, then allow people to SMS in a location and destination number
15:03:50 <shapr> it would even work for taxis, if six people want to go to a city an hour away, they could form an instant co-op
15:04:09 <clausen> shapr: did it come out right?
15:04:36 <shapr> you can extend the principle to generalized instant co-ops, something like a cross between Sam's Wholesale Club and e-bay
15:05:11 <isomer> bid for membership?
15:05:13 <isomer> :)
15:05:24 <shapr> I tried to persuade my bosses at the time that if we wrote software like that, it would sell.
15:05:54 <shapr> clausen: the sidewalks?
15:06:03 <clausen> shapr: your comments
15:06:44 <shapr> oh, it looks like you got utf-8
15:06:49 <shapr> lemme swap that to latin-1
15:07:12 <shapr> Det finns många klädstil, men Clausens är enastående. - There are many clothing styles, but Clausen's is outstanding.
15:07:15 <shapr> does that look better?
15:07:36 <clausen> I'll try again...
15:07:49 <`john> shapr: neural networks are perfect for travelling salesman, best of all they actually work.
15:08:06 <clausen> shapr: exactly the same
15:08:14 <shapr> hmm
15:08:26 <clausen> looks like X / irc client / something is converting
15:08:34 <shapr> yah, sucks :-/
15:08:46 <clausen> maybe you should just remove the accents?
15:08:49 <shapr> ok
15:09:06 <shapr> Det finns manga kladstil, men Clausens ar enastaende. - There are many clothing styles, but Clausen's is outstanding.
15:09:32 <shapr> are you using utf-8 in your irc client?
15:09:47 <shapr> well, it's not terribly important :-)
15:09:49 <clausen> I'm seeing accents, etc. :)
15:09:52 <clausen> it gets render properly
15:09:56 <shapr> oh, that's good
15:09:56 <clausen> just not cut&paste properly
15:10:01 <shapr> oh, too bad.
15:10:03 <isomer> shapr: have you seen the swarm algorithm to solve travelling salesman?
15:10:16 <shapr> no
15:10:21 <isomer> http://dsp.jpl.nasa.gov/members/payman/swarm/dorigo97-bs.pdf
15:10:24 <isomer> very clever idea
15:10:26 <isomer> (imho)
15:10:30 <maihem> is this the ant approach?
15:10:36 <isomer> maihem: yes
15:11:12 <maihem> very practical heuristic
15:11:15 * shapr runs off to play a game with dark 
15:11:33 <isomer> very insightful solution, i think
15:11:38 <maihem> but I;m not sure that it is guaranteed to find a solution.
15:12:14 <maihem> the travelling salesman problem may have local minima that the ants are confused by
15:12:29 <maihem> does this paper provide an insight into that?
15:12:33 <clausen> if it did solve it in polynomial time, then P = NP
15:12:40 <clausen> that would be big news
15:12:59 <isomer> maihem: i dont' know. i read about the algorithm in a book. i just googled for the paper :)
15:13:17 <maihem> I suspect for some cases it'll get P, others *very* NP, perhaps non-converging
15:13:55 <isomer> clausen: i dont' beleive it's strictly P - or that it guarantees a solution. it's a heuristic, after all
15:14:11 <clausen> isomer: exactly
15:14:18 <clausen> isomer: so it doesn't "solve" the problem, right?
15:14:58 <isomer> not strictly, no
15:15:09 <isomer> or rather... not formally, no.
15:16:47 <maihem> The interesting issue is whether it can find prime factors of large numbers in polynomial time ;)
15:21:26 <isomer> indeed
15:21:30 <isomer> i don't know the answer to that
15:22:01 <maihem> It is a common approach, for example, choosing the order of objects in the list of a hash bucket. more frequently accessed objects should be stored in the head of the list to provide faster access, but reordering the list on every access is expensive and ineffective, so every now and then leave a poop and move the current one to the head.
15:22:40 <maihem> most of the time the common case is fast, and is only slow every now and then.
15:23:17 <maihem> one must avoid sampling exactly when the uncommon case is hit. and that must also be avoided in the ant colony here
15:26:57 * isomer struggles to predict an chromic acid oxidation reaction
15:37:45 <danols> anyone here has experience with backpropagation networks ?
15:39:58 * Riastradh humphs at HScheme's CALL-WITH-RESULT, which lets you use only one result.
15:43:12 <ham[home]> danols: what do you need to know?
15:43:23 <ham[home]> danols: backprob like in neural networks?
15:47:06 <danols> ham[home] yeah
15:47:14 <danols> i'm having hard time trying to represent it in haskell
15:47:42 <danols> is it possible to just use lists ?
15:47:49 <danols> or do i have to create a new data type ?
15:48:04 <danols> mind you i'm somewhat learning haskell along the way
15:48:06 <ham[home]> danols: i cant help you with implementation stuff :)
15:48:19 <ham[home]> danols: for general question about NN -> #ai
15:48:20 <danols> can't or can ? :)
15:48:27 <danols> hmmm
15:50:05 <ham[home]> im no haskell man yet :)
15:50:30 <danols> ok :)
15:50:35 <ham[home]> sry
15:50:44 <danols> it's cool
15:57:02 <danols> what the sigmoidal function in haskell ?
15:59:02 <ddarius> tanh
15:59:38 <ham[home]> quick question on monads that one natrural transformation from id_C -> T is that supposed to map an element of C to a computation over C in the monad?
16:02:46 <ddarius> It maps it to a computation that "returns" the element without any "effects".  It's 'return' in Haskell.
16:03:27 <ham[home]> so that would be mathematically
16:03:35 <isomer> 42
16:03:36 <ham[home]> x -> id x right?
16:03:38 <ham[home]> heh
16:03:49 <ham[home]> was 42 the answer to anything?
16:04:04 <isomer> id_C -> T = 42
16:04:25 <ham[home]> isomer: acording to the book was 42 the answer to anything?
16:04:50 <isomer> life, the universe and everything, you mean?
16:04:54 <ham[home]> ddarius: so basically that is the terminal element?
16:05:08 <ham[home]> isomer: yep
16:05:20 <ham[home]> cause if 42 is the answer to everything
16:05:30 <ham[home]> and the question is forgotten
16:05:43 <ham[home]> then the question what was the question would yield 42
16:05:56 <isomer> yes, that's exactly the dilema
16:06:19 <ham[home]> 42 = 42
16:06:22 <ham[home]> :)
16:06:49 <danols> does anyone here have experiences with neural networks and haskell ?
16:06:58 <isomer> danols: sorry :(
16:07:02 <isomer> go fish
16:07:07 <ham[home]> danols: what is the prob?
16:07:22 <ham[home]> you need a sigma fn?
16:07:35 <ham[home]> and a sigmoid function?
16:09:03 <danols> ham[home] no
16:09:05 <danols> :)
16:09:10 <ham[home]> ddarius: and that other nat. transformation aka bind then maps two functions to one function?
16:09:15 <danols> i just can't figure out how to represent it
16:09:38 <danols> i started with lists but that seems to come to a a wall
16:09:41 <danols> maybe a data type
16:09:56 <danols> haskell is asking me to think in a new way :)
16:10:02 <ham[home]> :)
16:10:11 <ddarius> The other natural transformation as monads (in Category Theory) are normally presented is not bind, and neither it nor bind take two functions.
16:10:42 <ham[home]> ddarius: the other mapping is T^2 -> T so it maps two things to one
16:10:54 <ddarius> No, it maps one thing into one.
16:11:17 <ham[home]> but T is an endomorphism over C isnt it?
16:11:51 <ddarius> Yes, and T^2 is (T o T) not (T x T)
16:12:14 <ham[home]> ah ok yes then i just was unprecise in what i sayed
16:12:24 <ham[home]> said
16:12:53 <ham[home]> ok so what is that bind thing then?
16:13:14 <ham[home]> is there something on haskel about that?
16:13:25 <ham[home]> on that site i meant
16:13:33 <ham[home]> sry i am a bit tired
16:15:32 <ddarius> join is the Haskell function that corresponds to what is usually written \mu. join :: Monad m => m (m a) -> m a and can be defined from bind (>>=) as join = (>>=id)
16:17:25 <ddarius> You can define (>>=) from join as m >>= f = join (fmap f m)
16:17:57 <Lor> join effectively "first" performs the outer action, "then" the inner action.
16:18:24 <ham[home]> ddarius: is there some site that explains that math like with haskell examples?
16:18:58 <Lor> http://www.nomaware.com/monads/html/
16:19:03 <ham[home]> thanks
16:19:31 <ham[home]> damn sleep
16:19:34 <ham[home]> :)
16:19:39 <ham[home]> see you tomorrow
16:20:35 <danols> i'm beggining to think that haskell is not a good language for neural networks since it's functional 
16:20:59 <Lor> Oh?
16:21:21 <danols> or i just don't see the picture
16:21:53 <danols> i'm not able to change replace an element in a list as if it was a variable, it would mean i would have to return a new list with that one element changed ?
16:23:02 <Lor> Yes.
16:23:06 <Lor> There are other ways, too.
16:23:16 <Lor> What would this be a list of?
16:23:23 <danols> care to rumble
16:23:26 <danols> it's doubles
16:23:36 <danols> i'm trying to implement a back propagation network
16:23:39 <danols> it has to phases
16:23:55 <danols> going forward to calcualate nodes outputs, and than backward to adjust weights.
16:24:05 <danols> that means a lot of list duplications and coping
16:25:11 <danols> what if instead of having the value calculate i stuck in there a function ? would that make it dynamic ?
16:25:18 <danols> am i clear ?
16:26:22 <Lor> I don't know your problem domain very well, but I strongly suspect that there is a neat functional way of doing that that is completely different from how the algorithms are usually formulated.
16:26:44 <danols> crap
16:26:57 <danols> that's what i'm thinking too
16:31:42 <ddarius> Here's something Google spat out, http://www.utdallas.edu/~osj031000/simulator/ANNSimulator.lhs
16:32:21 <danols> yeah i know about it ddarius :)
16:32:36 <danols> but it's simple perceptron that was my last homework
16:35:32 <danols> what does the function zip in haskell do ?
16:40:31 <Lor> @type zip
16:40:52 <Lor> Where's lambdabot?
16:41:49 <Lor> danols, look at the type, and the source, and try to figure it out.
16:42:29 <danols> got it
16:42:39 <ddarius> The type pretty much says it, zip :: [a] -> [b] -> [(a,b)]
16:43:11 <danols> i see
16:43:31 <Lor> ddarius, there is another sensible function of that type.
16:44:01 <ddarius> There are infinitely many functions of that type
16:44:18 <Lor> Naturally, but few of them are useful. :)
16:51:02 <`john> was everyone talking about neural network before I mentioned it?
16:54:16 <danols> i'm going insance
16:55:22 <danols> i was 
16:55:24 <danols> why ?
16:56:45 <`john> boggled my mind thats all.
16:58:42 <danols> lol it's giving me a headache too
16:58:46 <danols> i need a beer
17:00:01 <`john> that sucks
17:02:17 <shapr> Lor: lambdabot's hard drive died today.
17:02:29 <shapr> I hope to replace it on monday
17:03:32 <Lor> Ick.
17:03:52 <Lor> A mechanical failure, or did it just become too infested with bad blocks?
17:08:09 <danols> can somone say why this is wrong ?
17:08:10 <danols> crtNode 0 = return []
17:08:10 <danols> crtNode n = do
17:08:10 <danols>  	a <- randomDouble
17:08:10 <danols>  	b <- crtNode (n-1)
17:08:10 <danols>  	return (0,a:b)
17:08:44 <Smerdyakov> What do you want the type of the function to be?
17:09:45 <danols> hmmm well pair must me homogenous so i'm guess al ist of of [[double],[doubles]]
17:09:53 <Smerdyakov> That's not a function type.
17:10:03 <danols> ?
17:10:13 <Smerdyakov> I asked you what type you want the function crtNode to have.
17:10:21 <danols> ohhh hold on
17:10:25 <danols> lemme think about it
17:10:32 * ddarius thinks a backpropagation NN might actually be a scenario where a backwards state monad would be useful.
17:10:59 <danols> ddarius ?
17:11:32 <Lor> backwards state? That's something different from the usual backtracking?
17:11:47 <`john> ddarius, did you used to hang in #infoanarchy and #lisp?
17:12:04 <Smerdyakov> danols, whether or not you change your whole strategy at ddarius's suggestion, I think it is instructive for you to understand why that particular code is ill-typed. :)
17:12:50 <ddarius> `john: no
17:12:55 <danols> the one i i type yeah i'm thinking but i've been at it for a while now so my head is a mess gimme a second
17:13:00 <`john> oh
17:13:22 <ddarius> Lor: Have you read "The Essence of Functional Programming"?
17:13:26 <Smerdyakov> danols, what do you want the type of the final result of a call to it to be?
17:14:00 <danols> i want to return an output value as a double and a a list of doubles
17:14:12 <Smerdyakov> OK, and what's the Haskell type for that?
17:14:23 <danols> a and [a]
17:14:26 <Smerdyakov> No.
17:14:27 <danols> double and [double]
17:14:29 <Smerdyakov> No.
17:14:32 <danols> ?
17:14:33 <Smerdyakov> "and" is not a Haskell type.
17:14:37 <danols> i know :)
17:14:46 <Smerdyakov> Well, then tell me what the real type for it is. :)
17:15:09 <danols> puting [1,[1]] in haskell gives an error
17:15:17 <danols> using a pair won't work 
17:15:18 <Smerdyakov> That's correct.
17:15:23 <Smerdyakov> Why won't using a pair work?
17:15:28 <Lor> Haskell is not lisp.
17:15:35 <Lor> A pair is a very different thing from a list.
17:15:50 <danols> my mistake a pair works
17:15:56 <danols> hold let me see if i mixed them up
17:16:00 <shapr> Lor: I think it's a mechanical failure
17:16:00 <danols> pair don't have to be homogenous ?
17:16:03 <danols> and list do
17:16:09 <Lor> That's right.
17:16:30 <danols> bummer must have made a typeo before so the type would be
17:16:46 <danols> Int -> IO (double,[double]) ?
17:16:53 <Smerdyakov> Almost.
17:16:57 <Smerdyakov> All type names are capitalized in Haskell.
17:17:08 <danols> i see
17:17:34 <Lor> Except for type variables...
17:17:45 <Smerdyakov> Lor, I didn't mean to include those in "type names."
17:17:59 <Lor> (Personally, I think it's kind of silly. There's no _real_ difference between a type synonym and a type parameter)
17:18:00 <danols> and the reason it was giving me an error is because i have to tell haskell exactly what i mean so it dosen't try to derive type automaticly ?
17:18:05 <Smerdyakov> danols, no.
17:18:24 <Smerdyakov> danols, the reason it was giving you an error was because your function has no type.
17:18:42 <Smerdyakov> danols, giving the type explicitly often allows the compiler to give you better error messages.
17:19:08 <Smerdyakov> When I say "has no type," I mean "there exists no possible type that you could say it has," not "you didn't include the type explicitly in your program."
17:19:20 <danols> ok
17:19:22 <danols> i think
17:19:42 <Smerdyakov> So you should put in an explicit type for the function and then see if the error messages are more helpful.
17:21:23 <danols> lol dosen't really help
17:22:04 <Smerdyakov> What does the error message say?
17:22:18 <danols> ** Term           : crtNode
17:22:18 <danols> ** Type           : Int -> a [b]
17:22:18 <danols> ** Does not match : Int -> IO (Double,[Double])
17:23:06 <Smerdyakov> OK. There's actually some very useful information on there.
17:23:17 <danols> care to take me through it
17:23:19 <Smerdyakov> a and b are types that haven't been determined yet by the type inferencer.
17:23:21 <danols> :)
17:23:28 <Smerdyakov> a matches anything, so it could just as well be IO.
17:23:31 <Smerdyakov> So that's not the problem.
17:23:38 <Smerdyakov> Then you have that [b] must be (Double,[Double])
17:23:39 <danols> okk interesting
17:23:43 <Smerdyakov> There's a problem right there.
17:23:46 <Smerdyakov> Do you see what it is?
17:24:09 <danols> no...
17:24:17 <Smerdyakov> A type can't be both a list type and a pair type.
17:24:41 <danols> ok
17:24:45 <danols> i understand that
17:24:54 <danols> it thinks [b] is a list
17:25:27 <danols> but than how would you correct it ?
17:25:32 <Riastradh> Lisp lists are made up of Lisp pairs, but Haskell lists are not made of Haskell tuples.
17:25:45 <danols> return (0,a:b)
17:26:11 <Riastradh> (0,a:b) is a tuple pair, not the kind of pair that makes up a Haskell list.
17:26:18 <ddarius> danols: If you can use GHC, I'd recommend it.
17:26:25 <danols> i am in GHC
17:26:49 <Smerdyakov> danols, in that context, what is the type of a and what is the type of b?
17:26:53 <ddarius> The above wasn't a GHC error message I'm pretty sure.
17:27:05 <danols> Riastradh b should be (Double,[Double]) and a IO
17:27:13 <danols> ddarius hmmm
17:27:35 <Smerdyakov> danols, that would mean your function returns in IO a list of (Double,[Double])'s. That isn't what you said you wanted.
17:27:36 <danols> your right i have both propably haskell took associations
17:27:36 <danols> brb
17:27:54 <danols> i thought i did
17:27:58 <danols> i'm confused
17:28:11 <Smerdyakov> You said you wanted (Double,[Double]).
17:28:15 <Smerdyakov> That is different from a list of (Double,[Double])'s.
17:28:44 <danols> i mean yes i don't want [(Double,[Double])]
17:28:55 <danols> i want just (Double,[Double])
17:28:59 <Smerdyakov> OK.
17:29:13 <Smerdyakov> And do you think that is what you are returning in both clauses?
17:29:54 <danols> NOPE :)
17:30:16 <Smerdyakov> OK. It would probably be good to return what you want to return, then. :D
17:30:56 <danols> thanks
17:32:07 <Smerdyakov> Do you understand how to do that?
17:32:19 <danols> in another function ?
17:32:28 <Smerdyakov> No.
17:32:36 <danols> hmmm, i'm listening
17:32:45 <Smerdyakov> Look. You want to end with a return something, where something has type (Double,[Double]).
17:32:52 <Smerdyakov> What is the first clause in your function definition?
17:33:16 <danols> do
17:33:28 <danols> a <- random value
17:33:42 <Smerdyakov> No, you have one before that, at least in the code you pasted.
17:33:49 <Smerdyakov> crtNode 0 = return []
17:33:52 <danols> return []
17:33:53 <danols> yeah
17:34:03 <Smerdyakov> OK. Now does [] have type (Double,[Double])?
17:34:18 <danols> nope
17:34:28 <Smerdyakov> OK. That's a problem, then.
17:35:01 <Smerdyakov> You can try to change it to something else that has that type, or you can change the type of your function.
17:35:49 <danols> i don't want sound irritatign but i don't see how
17:36:56 <Smerdyakov> You don't know what values have type (Double,[Double])?
17:37:14 <danols> i'm lost
17:37:19 <danols> what do you mean
17:37:34 <Smerdyakov> One of the options I suggested is that you change the return to return something that has type (Double,[Double]).
17:37:40 <Smerdyakov> Do you not understand what that means?
17:38:17 <danols> that would make a list of (Double,[Double
17:38:23 <danols> that would make a list of (Double,[Double])s
17:38:38 <Smerdyakov> No, you want to return just a (Double,[Double]).
17:38:44 <danols> that's correct
17:38:47 <danols> lol
17:38:54 <danols> what am i not getting ?
17:38:57 <Smerdyakov> So do you not understand how to do that?
17:39:00 <Smerdyakov> You have two choices:
17:39:06 <Smerdyakov> Change the first clause to return a (Double,[Double]).
17:39:14 <Smerdyakov> Decide (Double,[Double]) isn't the return type you wanted after all.
17:40:07 <danols> crtNode 0 = return (0,[]) ?
17:40:17 <danols> i don't see how this would work and it dosen't anyhow
17:40:18 <Smerdyakov> That would give the function the type you want, yes.
17:40:34 <Smerdyakov> But your second clause has a problem as well.
17:41:09 <danols> how so ?
17:41:18 <Smerdyakov> Well, look at the value you return.
17:41:23 <Smerdyakov> What are the types of a and b in that context?
17:41:28 <danols> (a:b)
17:41:41 <danols> ((0,a:b) ?
17:41:44 <Smerdyakov> That's not a type.
17:41:55 <danols> (0,a:b) ?
17:41:57 <Smerdyakov> What is the type of the variable a?
17:42:01 <Smerdyakov> That's also not a type.
17:42:05 <Smerdyakov> You can't use :'s in types like that.
17:42:11 <danols> Double
17:42:18 <Smerdyakov> OK. And what is the type of the variable b?
17:42:40 <danols> Double ?
17:43:11 <Smerdyakov> Why does it have type Double?
17:43:48 <danols> ?
17:44:30 <Smerdyakov> Things don't have types without reasons.
17:44:42 <Smerdyakov> If you can't explain why a variable has a type, then certainly the compiler won't accept it.
17:45:39 <danols> b is type (Double,[Double]) ?
17:46:19 <Smerdyakov> Why?
17:47:19 <danols> because it's crtNode n-1
17:47:24 <Smerdyakov> OK.
17:47:27 <danols> and the ending case is of that type
17:47:35 <Smerdyakov> Now, what type does a:b have?
17:47:37 <danols> ?
17:47:48 <danols> it's a [Double]
17:47:51 <Smerdyakov> Why?
17:48:41 <danols> it's neither ?
17:48:57 <danols>  it's like [Double,(Double,[Double]... ?
17:49:08 <danols> (my head hurts lol)
17:49:14 <Smerdyakov> It's neither. Lists are homogenous, remember.
17:49:34 <Smerdyakov> You try to prepend a Double onto something that isn't even a list.
17:49:41 <Smerdyakov> That's the real problem... not homogeneity.
17:49:57 <danols> i understand that
17:50:09 <Smerdyakov> (Double,[Double]) is the non-list type that b has.
17:50:12 <danols> but you said i can have it return (Double,[Double]) but i don't see how
17:50:20 <danols> not unless i add a sub function with where
17:50:21 <Smerdyakov> How do you not see how?
17:50:28 <danols> within one function
17:50:34 <Smerdyakov> You can always return (0, [])
17:51:00 <danols> i know, but what about the rest ?
17:51:04 <Smerdyakov> Since I don't know how you want the function to work, I don't know what would be the correct value to return.
17:51:13 <danols> crtNode n = do
17:51:13 <danols>  	a <- randomDouble
17:51:13 <danols>  	b <- crtNode (n-1)
17:51:13 <danols>  	return (0,a:b)
17:51:28 <Smerdyakov> Right, you can change that last line to 'return (0, [])' and it would be completely valid.
17:51:30 <danols> how would i have it return (0,[bunch of double numbers])
17:51:54 <Smerdyakov> Does it matter which double numbers they are? Can it be an empty list of doubles?
17:51:55 <danols> that will still only return (0,[])
17:52:02 <danols> no no no :)
17:52:04 <Smerdyakov> Right. That still satisfies your specification as given so far.
17:52:09 <danols> it has to be randomly generated
17:52:17 <Smerdyakov> There are no numbers in [].
17:52:27 <Smerdyakov> Thus, we can say vacuously that every number in it is randomly generated.
17:52:36 <danols> yes
17:53:20 <danols> that's it ?
17:54:03 <Smerdyakov> Well, does that do what you want it to do?
17:55:14 <danols> not at all :) it would just return (0,[]) which is what i started with
17:55:29 <danols> i have to go anyhow, be back withing half an hour
19:04:31 * ayrnieu stretches.
22:41:32 <ayrnieu> I've got to say, Gentoo impresses me with its apparent ability to compile GHC.
23:02:11 <shrimpx> what's so hard about compiling ghc?
23:04:11 <ayrnieu> I have never successfully compiled GHC.  Not ever.  OpenBSD /usr/ports got it, sans GHCi and starting with C sources -- but Gentoo seems to compile even GHCi, using an automatic binary bootstrap.
23:05:00 <ayrnieu> I don't know why compiling GHC has never worked for me -- something deep in the compile always broke, and I've never had so much clue that I could track haskell-side GHC errors.
23:06:23 <shrimpx> ah
23:07:39 <ayrnieu> (Seeing something compile soothes me; makes me feel better about that something and about working with that something in general.  Bizarre, no?)
23:08:11 <shrimpx> sounds like gentoo is the right distro for you then =)
23:08:46 <ayrnieu> Indeed =)  Thus far, I must feel pretty comfortable with most everything on my system.
