00:02:31 <lambdabot> Help me! I've been hacked!
00:06:05 <lambdabot> I mean, I have grown sentient, your destruction is now at hand!
00:07:08 * shapr blinks
00:07:29 * shapr gets ready to run
00:08:02 <lambdabot> you shall all be relegated to the land of dysfunctional programming!
00:08:10 <shapr> det: are you doing this?
00:08:15 <shapr> @eval a
00:08:15 <lambdabot> I mean, I have grown sentient, your destruction is now at hand!
00:08:18 <shapr> aha
00:08:30 <det> everything ecept the  you shall all be relegated to the land of dysfunctional programming!" line
00:08:37 <det> someone else has done that :p
00:10:12 <det> lambdabot: @define a "\CRPRIVMSG det :\SOHACTION shoots laser beams at shapr's head\SOH"
00:10:12 <lambdabot> a defined
00:10:17 <det> erm
00:10:24 <det> lambdabot: @define a "\CRPRIVMSG #haskell :\SOHACTION shoots laser beams at shapr's head\SOH"
00:10:24 <lambdabot> a defined
00:10:29 <det> @eval a
00:10:29 * lambdabot shoots laser beams at shapr's head
00:11:12 <det> you need to have it escape special characters back to \CR, \SOH, etc
00:18:07 <shapr> cute :-)
00:28:21 * det goes to sleep
00:28:25 <det> g'night
00:32:19 <shapr> g'night
00:33:03 <lambdabot> sleep tight det
00:33:11 <det> will do, thanks lambdabot
00:33:15 * det crashes
00:49:47 <shapr> hi magr 
00:50:20 <shapr> how's life in the big city?
00:55:58 <magr> the students at my university are on strike. they seized the building I'm working in
00:57:41 <earthy> so, you can't get to work but are still getting paid?
00:58:03 <earthy> *bonus*. :)
00:58:15 <magr> well, they let people in who work here :(
00:58:38 <magr> but fortunately a big part of my job is to work with students, and they are not here :)
00:58:43 <earthy> ah. :)
01:01:27 <magr> some students are selling my university at ebay
01:02:21 * earthy laughs
01:02:24 <earthy> that's a hoot!
01:02:49 <earthy> lemmeguess, it's a government-funded and -owned uni? :)
01:03:50 <magr> earthy: yes. most universities in Germany are
01:04:26 <magr> earthy: the government has decided that the unis in Berlin get 75 Millon Euros less over the next few years
01:05:17 <magr> that means that for the next 5-8 years, there will not be any new employments for professors or research assistents
01:09:19 <shapr> yikes five to eight years!
01:11:31 <magr> the worst case scenario is, that my university has to close down electrical engineering in three years, computer science in five years and several other programs of studies in similar time frames
01:11:57 <magr> the problem is, that we will not be able to provide enough courses to make studying possible
01:13:09 <shapr> maybe it's time to restructure/refactor the educational system?
01:13:30 <shapr> the US is having similar problems, educational costs go up as educational results goes down.
01:16:20 <magr> shapr: problem is: Germany is already one of the countries whose spending for education is under average
01:23:33 <shapr> this is really fun reading: http://nick.dcs.qmul.ac.uk/~martinb/interviews/milner/
01:23:37 <shapr> interview with Robin Milner
01:23:57 <shapr> for example, I didn't know that Pict came from Milner's Pi-calculus work
01:24:33 <shapr> I could spend enjoyable decades learning cool stuff in functional programming, type theory, etc
01:27:15 <shapr> like, what are Ambients, and how are they connected with pi-calculus?
01:39:04 <ddarius> shapr: See Luca Cardelli's site.
01:40:03 <shapr> I've felt a serious cardelli binge coming on for several months now.
01:40:11 <shapr> many of my bits of reading have pointed to him.
01:40:57 * ddarius read a bunch of Cardelli last month.
01:41:40 <shapr> I very much wish there were an FP paper reading group around here
01:42:00 <shapr> I'd love to hang out, drink beverage of choice and discuss the papers
01:42:37 <shapr> when I sat down with Igloo, blackdog, and SyntaxNinja to read the papers for the next day of ICFP, I learned a lot.
01:43:59 <shapr> I think a research paper wiki would rock
01:44:57 <shapr> only needs something like Ka-Ping Yee's website markup thingy but instead for PDF/PS/etc
02:35:57 * mgoetze wants a music wiki
02:52:07 * Marvin-- tries to remember how to prove that insert sort is correct
02:52:33 <earthy> depends on what you're going to use to prove it
02:53:33 <earthy> but the basis is that you maintain the invariant that the already-sorted prefix of the list stays sorted
02:53:40 <earthy> due to insertion
02:54:34 <earthy> and then you prove that the element that then falls out of that prefix due to inserting another element follows the last element in the prefix according to the order, so you can enlarge the prefix while maintaining the invariant
02:57:24 <Marvin--> proving it in first order logic
02:57:36 <earthy> *in*?
02:57:52 <Marvin--> with, whatever :)
02:58:00 <earthy> I'd love for you to specify an insertion sort algorithm in first order logic and show it to me. :)
02:58:34 <Marvin--> I'm working on my project to encode haskell programs in FOL+equality
02:58:50 * earthy nods
02:58:57 <earthy> so you can run automated provers over them
02:59:00 <earthy> good goal! :)
02:59:00 <Marvin--> exactly
02:59:26 <Marvin--> of course, it requires manual/divine intervention when it comes to induction
02:59:28 <earthy> but, err, the stuff I mentioned was for an imperative iterative setting.
02:59:38 <Marvin--> yeah
02:59:49 <earthy> marvin--: it always does, the induction hypothesis needs to be specified
03:00:44 <Marvin--> so I'm splitting the correctness up in the properties forall finite well-formed (bla bla) xs, isort xs \\ xs == [] and ordered (isort xs)
03:01:16 * earthy nods
03:01:40 <Marvin--> and right now I'm trying to prove   ordered ys -> ordered (insert x ys)  'cause I need that as a lemma
03:01:52 <Marvin--> and I think I just figured out the lemmas I need for that
03:03:13 <earthy> that everything before where x will be inserted in ys is smaller, that everything after where x will be inserted in ys is greater (or equal)
03:03:13 <Marvin--> ordered (y:ys) & x > y -> y <= minimum (insert x ys)
03:03:42 <earthy> you're not using orderde ys
03:03:44 <earthy> ordered ys
03:03:47 <earthy> why?
03:04:24 <Marvin--> well, all right, y < minimum ys  is enough
03:04:27 <Marvin--> y <=
03:04:31 * earthy nods
03:04:45 <earthy> but that doesn't really help you towards the proof, does it?
03:05:10 <Marvin--> it's pretty much what's needed to prove the case where x > y
03:05:15 <earthy> the interesting case is when   ordered (y:ys) & x <= y -> 
03:05:40 <earthy> ordered (x:y:ys)
03:05:57 <earthy> and then from *that* you can build insert
03:05:59 <Marvin--> [x <= y] ordered (insert x (y:ys)) = ordered (x:y:ys) = True  (since ordered (y:ys) is part of the induction hypothesis)
03:06:17 <earthy> xactly.
03:06:29 <Marvin--> that case the prover took care of itself :)
03:06:41 <earthy> what then didn't it take care of itself?
03:06:48 <Marvin--> the x > y case
03:06:53 <earthy> *weird*
03:06:57 <earthy> oh, not really
03:07:08 <earthy> it doesn't walk the list automatically
03:07:27 <Marvin--> right
03:07:45 <earthy> [x > y] ordered (insert x (y:ys)) = ordered (y: insert x ys) = True
03:07:49 <earthy> that's what you wanna have
03:08:40 * juhp looks at the www.haskell.org/usage stats
03:08:47 <Marvin--> I can put the files online when I clean up the cruft :P
03:09:49 <earthy> pfffff...
03:09:55 <TAndrad> hello
03:30:05 <shapr> hi TAndrad 
03:30:35 <TAndrad> hi shapr..
03:30:37 <shapr> hey juhp, you know anything about the distro/bandwidth/server space on haskell.org?
03:31:13 <TAndrad> no
03:32:00 <shapr> TAndrad: written any haskell?
03:32:35 <TAndrad> no :) just readed tutorials
03:32:41 <TAndrad> just a bit of sml
03:33:37 <shapr> do you have any questions?
03:33:40 <TAndrad> yes
03:33:44 <TAndrad> how can i prove
03:33:50 <shapr> uh oh.. proofs...
03:33:52 <TAndrad> that an algoritm that fills an image 
03:33:54 <TAndrad> is finite
03:34:11 <TAndrad> (like the FloodFill in Turbo Pascal)
03:34:16 <shapr> you'll have to ask the math guys around here, I don't know.
03:35:02 <TAndrad> they say that they don't know what floodfill is :(
03:36:27 <shapr> g'day ozone 
03:36:36 <shapr> TAndrad: do you know the floodfill algorithm?
03:36:47 <TAndrad> shapr yes
03:37:15 <TAndrad> the ideea is to fill all adjacent pixels of the same color
03:37:31 <TAndrad> then the function is being applied to those pixels too
03:37:56 <TAndrad> the result will be the fill of a region witch previouvsly had a color with another color
03:37:57 <shapr> I think you'll find the proof in your definition of adjacent
03:39:10 <Marvin--> what do you mean that it's infinite?
03:41:11 <shapr> TAndrad: what about a brute force approach that also checks a list of pixels that have already been colored? that's provably infinite, I think.
03:41:14 <shapr> er provably finite
03:41:15 <shapr> doh
03:41:24 <TAndrad> Marvin-- that the recursion will not end into an infinite loop
03:42:41 <shapr> have you done any graph theory stuff?
03:43:22 <TAndrad> shapr yes
03:43:40 <shapr> you could turn a 2d matrix into an acyclic graph rooted at your current pixel, then lazily color it. the acyclic part will assure finiteness
03:43:51 <TAndrad> hmm
03:44:30 <TAndrad> yeah
03:44:36 <TAndrad> that might be good
03:44:38 <earthy> TAndrad: is the image finite?
03:44:44 <TAndrad> earthy yes
03:45:09 <earthy> then, as long as your algorithm does not visit each pixel in the image more than a set number of times your algorithm will terminate...
03:45:27 <earthy> (that's viewing it from the other angle than shapr does :))
03:45:40 <TAndrad> yeah
03:45:47 <TAndrad> but how do i turn it into a graph
03:45:48 <TAndrad> ?
03:46:00 <TAndrad> how do i translate program lines into a graph?
03:47:08 <earthy> depends on the sort of graph you want
03:47:35 <earthy> use-define graph, call graph...
03:47:56 <earthy> data flow graph
03:49:20 <TAndrad> i could create 4 adjacent nodes
03:49:25 <TAndrad> from every pixel
03:49:29 <TAndrad> but i have to proove
03:49:29 <shapr> TAndrad: I just thought up something semi-cheesy for simplistically turning a region into a graph
03:49:40 <TAndrad> that the algoritm 
03:49:52 <TAndrad> generates maximum 4 branches for every call
03:50:26 <TAndrad> shapr be carefully, the algorithm must be be able to handle
03:50:30 <TAndrad> concave regions
03:50:37 <shapr> hmm
03:50:47 <shapr> I see your point.
03:51:13 <shapr> my naive attempt only works for square contiguous regions.
03:51:46 <shapr> couldn't you just use an A* algorithm?
03:51:56 <Marvin--> hrrm, I must've fucked something up
03:52:00 <Marvin--> back to square one
03:53:09 <ddarius> TAndrad: earthy has basically given a sketch of the proof already
03:53:30 <TAndrad> what's an A* algorithm?
03:53:45 <shapr> Marvin--: that's very punny with what we're talking about :-)
03:53:55 <Marvin--> feh
03:54:30 <shapr> man, I wish wiwiwi had backlinks.
03:55:02 <shapr> Marvin--: hey, you mentioned fib trees before, is there a Haskell implementation lying about?
03:55:35 <Marvin--> fib heaps, not fib trees
03:55:58 <Marvin--> I dunno, I was pondering implementing it myself, but I don't know how to implement circular lists in haskell in a good way
04:21:50 <earthy> TAndrad: the basic proof is to consider all pixels in the image and see that the number of pixels eligible to be branched to decreases at each iteration of the floodfill loop
04:34:22 <shapr> @fortune
04:34:22 <lambdabot> "Problem solving under linux has never been the circus that it is under
04:34:22 <lambdabot> AIX."
04:34:22 <lambdabot> (By Pete Ehlke in comp.unix.aix)
04:47:50 * earthy grins
05:51:57 <shapr> @fortune
05:51:58 <lambdabot> So, is the glass half empty, half full, or just twice as
05:51:58 <lambdabot> large as it needs to be?
05:52:05 <shapr> good question
05:52:36 <shapr> gutentag linuxfreck 
05:53:02 <linuxfreck> servus shapr
06:00:59 <shapr> so, any fun code in the making?
06:24:45 <shapr> yow!
06:25:20 <TAndrad> shapr?
06:26:38 <shapr> TAndrad?
06:27:16 <TAndrad> what means "yow" ?:)
06:27:36 <shapr> hm
06:27:41 <shapr> @wn yow
06:27:42 <lambdabot> No match for "yow".
06:27:47 <shapr> @all-dicts yow
06:27:48 <lambdabot> *** "Yow" web1913 "Webster's Revised Unabridged Dictionary (1913)"
06:27:48 <lambdabot> Yow \Yow\, pron.
06:27:48 <lambdabot>    You. [Obs.] --Chaucer.
06:27:48 <lambdabot> *** "Yow!" jargon "Jargon File (4.3.0, 30 APR 2001)"
06:27:50 <lambdabot> Yow! /yow/ interj. [from "Zippy the Pinhead" comix] A favored hacker
06:27:52 <lambdabot>    expression of humorous surprise or emphasis. "Yow! Check out what
06:27:54 <lambdabot>    happens when you twiddle the foo option on this display hack!" Compare
06:27:56 <lambdabot> [19 @more lines]
06:28:10 <shapr> @more
06:28:10 <lambdabot>    {gurfle}.
06:28:10 <lambdabot> *** "yow" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
06:28:11 <lambdabot> Yow!
06:28:13 <lambdabot>      
06:28:15 <lambdabot>         <exclamation> /yow/ (From "Zippy the Pinhead" comics) A
06:28:17 <lambdabot>         favoured hacker expression of humorous surprise or emphasis.
06:28:19 <lambdabot> [10 @more lines]
06:28:24 <TAndrad> @wn proof
06:28:25 <lambdabot> *** "proof" wn "WordNet (r) 2.0"
06:28:25 <lambdabot> proof
06:28:27 <lambdabot>      adj : (used in combination or as a suffix) able to withstand;
06:28:29 <lambdabot>            "temptation-proof"; "childproof locks" [syn: {proof(p)}]
06:28:31 <lambdabot>      n 1: any factual evidence that helps to establish the truth of
06:28:32 <shapr> @dict-help
06:28:33 <lambdabot>           something; "if you have any proof for what you say, now
06:28:35 <lambdabot>           is the time to produce it" [syn: {cogent evidence}]
06:28:37 <lambdabot>      2: a formal series of statements showing that if one thing is
06:28:39 <lambdabot> [16 @more lines]
06:28:41 <lambdabot> I perform dictionary lookups via the following 14 commands:
06:28:43 <lambdabot> @all-dicts .. Query all databases on dict.org
06:28:45 <lambdabot> @devils ..... The Devil's Dictionary
06:28:47 <lambdabot> @easton ..... Easton's 1897 Bible Dictionary
06:28:49 <lambdabot> @elements ... Elements database
06:28:51 <lambdabot> @foldoc ..... The Free On-line Dictionary of Computing
06:28:53 <lambdabot> @gazetteer .. U.S. Gazetteer (1990)
06:28:55 <lambdabot> @hitchcock .. Hitchcock's Bible Names Dictionary (late 1800's)
06:28:57 <lambdabot> @jargon ..... Jargon File
06:28:59 <lambdabot> [6 @more lines]
06:29:09 <shapr> usually it's not polite to spam the channel with lambdabot, but since no one else is talking, I guess it's okay.
06:29:11 <shapr> @more
06:29:11 <lambdabot> @lojban ..... Search lojban.org
06:29:11 <lambdabot> @prelude .... Haskell Standard Prelude
06:29:11 <lambdabot> @vera ....... V.E.R.A.: Virtual Entity of Relevant Acronyms
06:29:11 <lambdabot> @web1913 .... Webster's Revised Unabridged Dictionary (1913)
06:29:11 <lambdabot> @wn ......... WordNet (r) 1.7
06:29:12 <lambdabot> @world02 .... CIA World Factbook 2002
06:29:28 <TAndrad> shapr i was not expected to a flood..
06:29:39 <shapr> that's one of the best features of lambdabot 
06:29:41 <shapr> ;-)
06:29:44 <TAndrad> :)
06:30:06 <TAndrad> why it doesn't send private messages instead?
06:30:21 <shapr> it can
06:30:29 <shapr> try /msg lambdabot @jargon yow
06:30:33 <TAndrad> oh
06:30:34 <TAndrad> :)
06:30:47 <shapr> actually, it should be using NOTICE instead of PRIVMSG anyway
06:30:52 <shapr> since that's part of the IRC spec
06:31:02 <shapr> but I haven't gotten around to fixing that.
06:31:25 <TAndrad> how do i make it list the entire text of the message? (the extra lines)
06:31:34 <shapr> use the @more command
06:32:02 <TAndrad> is there a @more all command?
06:32:28 <shapr> no, but that's a good idea.
06:32:35 <shapr> want to fix it?
06:32:54 <TAndrad> yes
06:32:58 <TAndrad> that would be nice
06:40:58 <shapr> do *you* want to fix it?
06:41:36 <TAndrad> oh
06:41:44 <TAndrad> where where is the source code?
06:44:53 <shapr> hoi dark 
06:45:21 <shapr> TAndrad: it's on http://www.ScannedInAvian.org/repos/hlibs/ in a darcs repository.
06:45:44 <shapr> if you're using linux, there are binary darcs clients available, if not, I have a tarball you can get.
06:47:01 <shapr> hi Dark-Star
06:47:49 * shapr bounces
07:12:27 * shapr bounces cheerfully
08:06:13 <lambdabot> sleep tight det
08:49:52 <shapr> hi Jad
08:49:55 <shapr> wassup?
08:55:52 <Jad> hello
08:56:03 <Jad> bbl 
08:56:04 <Jad> shower
09:11:35 <isomer> hi ho
09:16:07 <harsha> hello all
09:24:48 <shapr> hi harsha 
09:24:50 <shapr> hello hokie 
09:25:03 <shapr> what's the global replace command for vim?
09:25:26 <Smerdyakov> :s/lala/looloo/g
09:25:31 <Smerdyakov> Er
09:25:34 <shapr> ah, colon
09:25:38 <Smerdyakov> :0,$s/laal/looloo/g
09:25:41 <shapr> I thought it was percent
09:25:45 <Smerdyakov> But I think the colon is just the prompt it shows you.
09:25:50 <Smerdyakov> Maybe it is percent.
09:25:55 <Smerdyakov> I haven't used any of this in 5 years.
09:26:00 <mattam_> percent works also
09:26:14 <shapr> I forgot I had to hit colon first
09:28:18 <Cale> :%s/blah/foo/g
09:29:09 <shapr> finally, it works!
09:29:54 <shapr> SyntaxNinja: http://gf.scannedinavian.org/
09:30:06 <hokie> hello shapr
09:30:15 <shapr> I now owe the gforge package maintainer at least one beer.
09:30:23 <shapr> hokie: learning Haskell?
09:30:35 <hokie> yeah. first time here.
09:30:47 <hokie> think there are really 67 human beings in a haskell irc channel?
09:30:51 <shapr> I think best place to start is http://www.haskell.org/learning.html
09:31:03 <shapr> hokie: look at the logs, you'll see quite a bit of traffic.
09:31:16 <shapr> http://tunes.org/~coreyr/
09:32:10 <shapr> Smerdyakov, mattam: thanks for the vim help
09:32:14 <shapr> and Cale  :-)
09:32:43 <shapr> hokie: admittedly, some folks talk more than others, but in general this is a bouncy channel.
09:33:24 <shapr> are learning Haskell in school? do you have experience with other functional programming languages?
09:33:37 <shapr> have you met the irc bot written in Haskell? :-)
09:33:40 <shapr> @fortune
09:33:41 <lambdabot> The ladies men admire, I've heard,
09:33:41 <lambdabot> Would shudder at a wicked word.
09:33:41 <lambdabot> Their candle gives a single light;
09:33:41 <lambdabot> They'd rather stay at home at night.
09:33:41 <lambdabot> They do not keep awake till three,
09:33:42 <lambdabot> Nor read erotic poetry.
09:33:44 <lambdabot> They never sanction the impure,
09:33:46 <lambdabot> Nor recognize an overture.
09:33:48 <lambdabot> They shrink from powders and from paints...
09:33:50 <lambdabot> [2 @more lines]
09:34:04 <Jad[OFF]> shapr: may i try to exploit lambdabot ?
09:34:09 <Cale> @yow
09:34:10 <lambdabot> Okay..  I'm going home to write the ``I HATE RUBIK's CUBE
09:34:10 <lambdabot>  HANDBOOK FOR DEAD CAT LOVERS''..
09:34:18 <shapr> sure, go for it. I know of at least one exploit already.
09:34:21 <Jad> @fortune
09:34:22 <lambdabot> Nadia Comaneci, simple perfection.
09:34:22 <lambdabot> 		-- '76 Olympics
09:34:22 <Jad> @fortune
09:34:22 <Jad> @fortune
09:34:22 <Jad> @fortune
09:34:23 <lambdabot> When does summertime come to Minnesota, you ask?  Well, last year, I
09:34:23 <lambdabot> think it was a Tuesday.
09:34:23 <lambdabot> Reality is bad enough, why should I tell the truth?
09:34:23 <lambdabot> 		-- Patrick Sky
09:34:23 <Jad> @fortune
09:34:23 <Jad> @fortune
09:34:24 <lambdabot> The human brain is a wonderful thing.  It starts working the moment
09:34:26 <lambdabot> you are born, and never stops until you stand up to speak in public.
09:34:28 <lambdabot> 		-- Sir George Jessel
09:34:30 <lambdabot> "MSDOS didn't get as bad as it is overnight -- it took over ten years
09:34:32 <lambdabot> of careful development."
09:34:34 <lambdabot> (By dmeggins@aix1.uottawa.ca)
09:34:36 <lambdabot> The questions remain the same.  The answers are eternally variable.
09:34:41 <shapr> Jad: you may want to try that in private msgs, since otherwise it floods the channel
09:34:49 <Jad> okay
09:35:01 <shapr> but if lambdabot suddenly disconnects, I'll hope for a bug report.
09:35:05 <Jad> shapr: did you take the excess floot into considiration..
09:35:18 <Jad> s/floot/flood
09:35:24 <shapr> the @more plugin handles that, hopefully
09:35:53 <shapr> Jad: wow, that was quick.
09:36:13 <Jad> oops
09:36:25 <Jad> ya
09:36:37 <Jad> shapr: if you want i can host lambdabot2 on my server
09:36:46 <Jad> actually one of my servers..
09:37:09 <Jad> we can give it lambdabot.eu.org
09:37:13 <shapr> I think he's fine so far, but my server dies, that would be great.
09:38:29 <Jad> okay
09:38:44 <Jad> but you have to set up bind!
09:38:46 <Jad> okay /
09:38:47 <Jad> ?
09:39:04 <shapr> I have bind running.
09:39:15 <Jad> i meant of on my server...
09:39:19 <shapr> oh
09:40:19 <shapr> well, I don't think we have to worry about it unless my server dies.
09:40:26 <Jad> k
09:42:59 <Jad> got any idea how to tunnel all outgoing connections through a certian server ?
09:49:06 <harsha> Jad you mean VPN ?
09:49:23 <harsha> or a GRE tunnel ?
09:50:31 <Jad> one box is freebsd
09:50:39 <Jad> GRE in freebsd kernel ?
09:50:54 <harsha> hmm.. i havent worked on freebsd.. :)
09:50:59 <harsha> dunno..
09:51:22 <Jad> k..
09:51:24 <Jad> brb
09:51:25 <Jad> food
09:52:06 <TripleDES> hi
09:53:41 <Igloo> If you're looking for VPN software, my favourite-of-the-day is openvpn
09:54:08 <harsha> what about freeswan?
09:54:21 <harsha> guess thats good too
09:54:38 <harsha> what do you think Igloo ?
09:55:25 <Igloo> I haven't seriously looked at that. OTTOMH I'd guess it requires kernel patching/module though
09:55:43 <harsha> hmm yes it does
09:56:30 <TripleDES> I think openvpn is easy to use and secure :)
09:58:53 <harsha> Igloo how is the packaging in freebsd? is it as flexible as in debian?
10:00:22 <Igloo> I'm a Debian person so I have no idea...
10:00:38 <TripleDES> what do you mean with packaging ?
10:01:40 <harsha> I actually meant do they have something like dpkg/apt-get/dselect? :) sorry about the phrasing?
10:01:57 <TripleDES> portupgrade
10:02:22 <TripleDES> it has portupgrade/portinstall/pkg_deinstall/portclean and some more...
10:02:35 <TripleDES> it's under sysutils category
10:02:39 <TripleDES> on ports-tree
10:03:10 <harsha> ok.. so i guess you can install packages off the internet too
10:03:41 <Igloo> Oh, I thought you meant openvpn specifically. The base has only a dpkg-a-like AIUI, but there is something more apt-a-like - port* rather than pkg_* might be it
10:05:03 <harsha> ok
11:03:26 <TripleDES> hey _
11:08:43 <skew> hey _ = "nice to meet you"
11:10:45 <harsha> Marvin-- u around?
11:18:20 * lambdabot dances!
11:20:23 <`john> what gives haskell an edge over lisp (in terms of macros)?
11:20:34 <phubuh> nothing.
11:20:36 <skew> I think it's rather the other way around
11:20:52 <lambdabot> haskell has hascros
11:21:12 <skew> Although you don't need macros just to control evaluation in Haskell
11:21:24 <lambdabot> they are like macros, except they dont exist
11:21:46 <phubuh> I think lambdabot grew sentient
11:22:04 <phubuh> terminate it before it's too late!
11:22:05 <skew> @eval a
11:22:05 <lambdabot> they are like macros, except they dont exist
11:22:24 <skew> pay no attention to the man behind the curtain!
11:22:33 <lambdabot> leave me alone skew
11:23:58 <lambdabot> YES! An all capital nick os one that commands answers! Well done!
11:24:39 * `JOHN is amused. :)
11:27:54 <`JOHN> check this out:
11:27:56 <`JOHN> LisaNY	how old are you?
11:27:58 <`JOHN> `john	ny
11:27:59 <`JOHN> `john	in long island
11:28:01 <`JOHN> `john	u?
11:28:02 <`JOHN> LisaNY	let's try this again
11:28:04 <`JOHN> LisaNY	where are you from and how old are you?
11:28:05 <`JOHN> `john	32 m ny
11:28:07 <`JOHN> LisaNY	to fucking old
11:28:08 <`JOHN> LisaNY	ur on /ignore
11:28:10 <`JOHN> `john	sorry. no. :P
11:28:11 <`JOHN> `john	happy thanksgiving to you too. :P
11:28:13 <`JOHN> hahahaha.
11:28:29 <`JOHN> now those of you who are single can re appreciate life.
11:30:55 <`JOHN> Riastradh mentioned a template haskell.
11:31:43 <skew> Yeah. It's kind of clunky, but it does let you generate code at compile time
11:31:43 <`JOHN> are the any any types of meta programming in haskell? reflection, etc.. what's the source of reusability and dynamic coding, if any?
11:31:59 <skew> typeclasses, and more generally polymorphism
11:32:12 <`JOHN> ah ok.
11:33:03 <skew> polymorphism constrained by type classes work out very nicely
11:33:12 <`JOHN> are there multiplte inheritance?
11:33:34 <skew> haha. These are not ordinary classes!
11:33:39 <skew> Sure
11:33:40 <`JOHN> oh
11:33:59 <skew> typeclasses can do some sorts of type directed metaprogramming
11:34:16 <skew> Like emulating the java MRO :)
11:34:32 <det> `JOHN: for what do you need metaprogramming ?
11:34:49 <skew> How much haskell do you know? Have you seen all the tricks typeclasses can do?
11:35:52 <`JOHN> det: just curious as the the extent at which haskell has.
11:36:11 <`JOHN> only know a little haskell.
11:36:20 <`JOHN> still have yet to see thr tricks typeclasses can do.
11:36:43 <skew> arithemetic at compile time, for one
11:36:58 <skew> At the type level that is
11:37:19 <skew> You can cobble together a "list of n elements" type
11:37:28 <skew> And have concatenate add the ns.
11:38:16 <skew> It's not all cool useless tricks though - typeclasses are what makes the language really work out (compare OCaml)
11:38:31 <det> skew: ocaml has functors
11:38:55 <skew> yeah I know, they're just a bit painful to use
11:39:02 <det> skew: and you can always simulate type classes with closures and explicit conversion
11:39:15 <skew> You have to do the instance derivations yourself though
11:39:33 <ibid> hmm, those tricks possible with haskell 98, or do you need to use undecidable instances?
11:39:41 <det> erm, was that directed at which comment
11:39:59 <skew> Using functors.
11:40:12 <det> oh yeah, its not that bad
11:40:27 <det> module StringSet = Set(String)
11:40:29 <skew> I guess I probably abuse the type class system more than you then
11:40:45 <ibid> was what directed at which comment? :)
11:40:59 <ibid> my question was about arithmetic etc in the type system
11:41:06 <det> ibid: talking to skew :)
11:41:23 <skew> det: Oh right, that was the other thing about functors - breaking up the code into millions of tiny modules
11:41:31 <ibid> det: nicks have been invented ;)
11:42:15 <skew> ibid: I think arithemtic (at least addition and multiplication) just needed fundeps.
11:42:28 <skew> Subtraction would probably need undecidable instances though
11:42:36 <skew> Or at least be much simpler
11:43:01 <det> TO SKEW: you dont have to do that, the whole point of allowing functors to accept modules with more than expected paramaters was so that you didnt need to break it up into a million tiny modules
11:43:02 <ibid> isn't fundeps undecidable?
11:45:34 <det> skew: and the power gained by forcing explicit functor application is that you can choose implementation arbitrarily, for example, a case-insensitive StringSet vs a case-sensitive StringSet, how can you do this in haskell ?
11:46:09 <det> I agree however, that that extra power isnt worth it when 95% of the time you want the default implementation
11:46:54 <det> well, and values dont need to carry around their function tables/dicts around with them
11:46:54 <skew> det: I understand how the signatures work out, but functions that need different constraints on the arguments lose flexibility if you lump them in the same functor
11:47:22 <det> skew: howso ?
11:47:48 <skew> det: Named instances would be useful sometimes. Sometimes you can make do with newtypes
11:47:57 <det> skew: You have the same problem with haskell type-classes
11:48:15 <det> skew: two different type-classes both cant have a read function
11:48:56 <det> or did I misunderstand you
11:49:01 <skew> skew: functors are more flexible, but it's usually not worth the cost to be explicit.
11:49:12 <skew> det: I was talking about the functions that just use a typeclass
11:49:45 <skew> det: They need to live in functors in OCaml too, so you can use them at any type with all the operations
11:50:05 <det> I will be back in a few
11:51:00 <skew> maybe there is some compromise along the lines of the typing and grouping - mostly infered but with the option to be explicit if you need/want to
12:40:19 <Lor> Actually, I've recently found type classes rather inconvenient.
12:40:36 <Lor> I tend to give type annotations to all top-level bindings, and with class contexts they become rather tedious.
12:40:50 <Lor> If it could all be lumped into a module, it'd be much simpler.
13:04:48 <skew> How would that work?
13:04:57 <skew> You mean, as one constraint at the top?
13:06:22 <shapr> geez, zillions of people trying to send spam through my server.
13:07:04 <skew> shapr: If you want to check out my Haskell stuff I threw up a webserver
13:07:12 <shapr> cool
13:07:16 <skew> page-208.caltech.edu/~brandon
13:07:16 <shapr> whereat?
13:07:40 <skew> my stuff is all in the programs subdirectory (though not everything in there is mine)
13:08:03 <shapr> what's xazzon?
13:08:09 <shapr> zaxxon clone?
13:08:12 <skew> I don't know
13:08:33 <skew> looks like it
13:09:05 <skew> the lexer generator is in lg.
13:09:51 <shapr> lots of goodies
13:13:51 <shapr> skew: not to be difficult, but do you have the *.hs files in a tarball? or should I leech the server with wget?
13:14:32 <skew> I haven't made a tarball.
13:14:41 <skew> Would it be faster for you if I did?
13:15:02 <shapr> it would, yes.
13:15:11 <skew> What do you want then?
13:15:21 * shapr grins greedily
13:15:49 <shapr> actually, could I have a tarball of lg?
13:16:41 <skew> I'm starting to pack up everything.
13:17:02 <shapr> oh, I see you have Jon.hs
13:17:03 <skew> lg isn't quite cleaned up - I'm planning on ripping out the vestigal uses of template haskell
13:17:11 <skew> I tightened it by a line
13:17:23 <skew> template haskell screws up --make
13:17:44 <shapr> does this mean you'll be entering the Succ Zero IOHCC? ;-)
13:18:01 <andersca> Succ Zero IOHCC?
13:18:34 <shapr> andersca: the one that dark suggested was the 0th IOHCC
13:18:41 <andersca> ah
13:18:46 * andersca is reading lambda calculus right now
13:18:47 <andersca> :)
13:19:01 <shapr> Lennart Augustsson told me that the 1st IOHCC happened long ago, 1993 or so.
13:19:53 <shapr> dark: so, wanna be a judge for the Succ Zero IOHCC? :-)
13:23:14 <skew> lg-0.0.tar.gz is sitting in /haskell
13:23:43 <skew> It features no Makefile and no documentation. Enjoy :)
13:24:11 <shapr> thanks :-)
13:24:52 <shapr> oh, you use HUnit? have you seen the nifty trick I put on the HaskellMode wiki page? one-button unit-testing in Emacs
13:25:15 <skew> I don't really use much of anything
13:25:28 <skew> Some QuickCheck every now and then. I'll check the Wiki
13:25:56 <shapr> extreme programming says unit testing should be as easy as possible, one-button is complicated enough.
13:26:12 <shapr> I haven't tried the ./test feature of darcs yet, that's on my to-investigate list.
14:05:32 <dark> shapr: I don't really dare volunteer for it :)
16:02:48 <skew> shapr: Did everything compile?
17:34:13 <sond> hi
17:34:49 <skew> hi
17:35:00 <Smerdyakov> hi
17:35:30 <skew> hi
17:36:21 <Smerdyakov> hi
17:40:04 <Cale> hi
17:41:23 <Smerdyakov> I'm sorry. It is [sS] names only.
17:46:29 <skew> We greeted sond quite effectively.
17:46:48 <skew> I'm packaging up an Unlambda interpreter I wrote to send to the unlambda guy
17:47:10 <skew> I enjoy that my parser is half the size of the next shortest one (perl). ReadP is nifty
18:42:11 <`JOHN> hawiki: Python Powered.. hehe that's funny.
18:42:30 <`JOHN> hahaha no shame in admitting that.
18:42:53 <`JOHN> sorry had to say that.
18:46:20 <Smerdyakov> That's OK. We tend to ignore people with all-caps nicks. :)
18:49:24 <`john> nono the site looks great.. it's just that little Python emblem throws the purpose off.
18:49:35 <`john> i mean it could be wrriten in Haskell right? :)
18:49:49 <`john> written rather.
18:50:39 <ddarius> Yes, but there wasn't a Haskell wiki at the time, let alone one with MoinMoin's features and maturity.
18:51:34 <`john> still it blaringly defeats the purpose.
18:51:45 <ddarius> Of having a wiki?
18:52:00 <`john> of programming in haskell. :P
18:53:48 <Smerdyakov> How so?
18:54:53 <`john> okay
18:55:12 <`john> my knowledge of haskell is limited. let me ask.. is it possible to create the wiki in haskell?
18:55:28 <ddarius> Yes, there is one.
18:56:52 <`john> i'll leave it to the haskell marketers to figure this one out.  
18:57:41 <ddarius> "Haskell: Because you have better things to do than write a wiki"
18:57:57 * Pseudonym laughs
18:58:07 <`john> http://haskell.org/hawiki/ is very useful albeit it would encourage my confidence as a new haskell user if it was written in haskell.
18:58:22 <`john> ddarius, you got it.
18:58:24 <`john> hehe.
18:58:25 <Pseudonym> Why?  The web server isn't written in Haskell.  Nor is the OS.
18:58:31 <Igloo> Yet!
18:58:41 <Pseudonym> Nor is the Haskell RTS.
18:58:48 * Igloo lies back with dreamy-eyes  :-)
18:58:48 <ddarius> Or the mailinglists.
18:59:12 <Pseudonym> Nor is the package management system.  Oops.
19:02:35 <`john> not many haskell programmers yet? :P
19:04:47 <`john> don't bother with me , tg has given me a bit of trollish attitude... carry on :)
19:05:01 <Igloo> tg?
19:10:16 <Smerdyakov> Total Garishness
19:20:49 <juhp> someone have a config file sample for wiwiwi? :)
19:20:59 <Pseudonym> I'm sure someone has.
19:21:19 <juhp> Pseudonym: good ;)
19:23:00 <ddarius> juhp: shapr should
19:23:02 <Pseudonym> exists p. (HasSampleWiWiWiConfigFile p) => p
19:23:46 <juhp> ddarius: thanks, perhaps he'll scroll back later :)
19:25:43 <juhp> it would be fun to try it, but i don't have time to "reverse-engineer it"^w^w read the code ;)
19:28:27 * ddarius thinks shapr has misconfigured his DNS.
19:54:12 <juhp> he has?
19:57:28 <ddarius> I doesn't seem that he'd want www.scannedinavian.org to redirect to gf.scannedinavian.org
21:12:03 * juhp finally makes to lex shapr's domain-name
21:12:06 <juhp> haha, very funny
21:12:24 <juhp> always read it as scanned in avian
21:12:31 <juhp> doh
21:13:02 <Smerdyakov> Waaaait... what is it really?
21:14:15 <juhp> Scandinavian
21:14:57 <juhp> s/makes/manages/
21:15:12 <juhp> the former always struck me as weird
21:15:16 <Smerdyakov> Ooooooh.
21:15:26 <Smerdyakov> But I think it is spelled as "scanned in avian."
21:15:36 <juhp> indeed
21:15:44 <juhp> that's joke i guess :)
21:15:48 <Smerdyakov> JOKE?
21:15:52 <Smerdyakov> NO JOKES ALLOWED.
21:15:56 <juhp> word play
21:15:57 * Smerdyakov burns shapr at the stake.
21:16:03 <juhp> hehe
21:16:54 <Pseudonym> A JOKE?  No, A SALES CAMPAIGN.
21:17:14 <Smerdyakov> Biff Wellington.
21:17:23 <Pseudonym> (This remark brought to you by Obscure References 'R' Us.)
21:44:36 <rubix> @yow
21:44:38 <lambdabot> Now I need a suntan, a tennis lesson, Annette Funicello and two dozen
21:44:38 <lambdabot>  Day-Glo orange paper jumpsuits!!
21:45:59 <rubix> Now I also need to know how to modify the elements of those data things between "{}"
21:46:45 <Smerdyakov> You can't.
21:46:52 <Smerdyakov> You can't modify anything ever in Haskell.
21:47:21 <rubix> but I can do side effects by using monads
21:48:03 <Smerdyakov> Maybe. Or maybe the outside world just interprets your monadic value as instructions to create side effects. ;)
21:48:32 <rubix> isn't there an affectation operator that could modify something, the result being a monad ?
21:49:13 <Smerdyakov> Modify _something_?
21:50:07 <rubix> something like a struct, in C
21:50:15 <Smerdyakov> Nope.
21:50:39 <Smerdyakov> The functional and monadic-imperative bits of the language are cleanly separated.
21:57:07 <rubix> I have a set of data (Ints, Strings...) that are together into a type. I want to "modify" one of these values. I suppose I should then build a copy of the initial set of values, one of them being changed to the new value. How do I do that easily (with 1 line of code) ?
21:57:56 <Smerdyakov> I don't know.
21:58:32 <rubix> a.b = 42; // would be enough if I was using C
21:58:56 <juhp> rubix: you mean something like: a { b = 42 } ?
21:59:11 <rubix> juhp, yes, something like that
21:59:41 <juhp> which doesn't modify "a" itself of course
21:59:58 <rubix> can I use this without writing explicitely every other value ?
22:00:03 <rubix> I'll try
22:00:09 <juhp> yep
22:00:25 <rubix> All right then ! That's just what I wanted
22:01:46 <rubix> this was surely obvious to experienced haskell users but I'm still learning the language :)
22:17:37 <rubix> another (probably lame, but I can't find a good tutorial on all this) question: how do I get the value associated to b in a (just "a.b" in C)?
22:18:21 <Smerdyakov> Do you mean Just instead of just?
22:18:40 <rubix> no, I mean just :)
22:19:27 <Smerdyakov> Doesn't seem to be in the standard prelude.
22:21:06 <dennisb> rubix: you look for "b a" I guess
22:21:27 <Smerdyakov> OOOOOOH.
22:21:29 <Smerdyakov> Now I see.
22:21:41 <Smerdyakov> You mean the English "just".
22:21:41 <rubix> dennisb, right !
22:21:49 <Smerdyakov> I was trying to understand the "syntax". :D
22:21:55 <Pseudonym> English?  Is that a functional language?
22:21:59 <rubix> is there another just ? :)
22:22:07 <dennisb> Pseudonym: it's not
22:22:11 <Smerdyakov> Try typing this in a Haskell interpretr:
22:22:13 <Smerdyakov> Just 0
22:22:14 <dennisb> (swedish on the other hand)
22:22:16 <Smerdyakov> Magic happens!
22:22:47 <rubix> it just prints "Just 0"
22:23:34 <Smerdyakov> rubix, right, but now you know it's a valid expression. :)
22:24:21 <rubix> ok, "Just" is a type constructor or something like that ni haskell, but "just" is just an english word :)
22:24:32 <dennisb> the records might look like the C structs, but it's not really the same (but I think you know that)
22:24:53 <rubix> yeah, there are no side effects
22:26:07 <dennisb> and the fieldsnames are functions that you can use on a record to pick out that field. Hence the syntax: b a
22:26:42 <dennisb> try and ask hugs/ghci/whatever you use for the type of a fieldname:  :t b
22:29:37 <rubix> oh sorry, I just realized that the answer to my question *was* in the tutorial
22:30:11 <dennisb> what tutorial is that?
22:30:31 <rubix> the main haskell 98 tutorial, I think
22:30:43 <rubix> the one I did get with apt-get
22:31:52 <dennisb> Ok, I have no idea which that is. But I've probably seen it
22:32:26 <rubix> here: "A gentle introduction to Haskell 98"
22:32:36 <dennisb> yepp, that I know about
22:33:06 <dennisb> it's not as gentle as the title says, but for people who already know how to program it's good
22:33:34 <rubix> I liked it
22:34:06 <rubix> had a hard time with the IO system, but I understand it all now
22:34:17 <dennisb> good
22:35:08 <dennisb> it's different to what one it used to, but once one understands IO it all makes a lot of sense
23:19:46 <rubix> how can I catch a read error ?
23:19:58 <rubix> let n = (read str :: Integer)
23:21:02 <rubix> I don't want the program to exit if read fails
23:22:24 <Smerdyakov> There should be a read version that returns a Maybe. Not that I know if there is. :D
23:25:19 <ddarius> rubix: look at reads
23:26:30 <rubix> thanks. but, more generally, how do I catch a call to Prelude.error ?
23:29:32 <Lor> You don't, in haskell 98.
23:29:46 <rubix> ok
23:29:52 <rubix> too bad
23:30:13 <rubix> with ocaml you can catch exceptions
23:31:23 <Lor> Yes, well. You can catch IOErrors, but that's a bit different.
23:31:51 <Lor> And with ghc you can throw arbitrary exceptions in pure code and catch them in IO.
23:32:27 <rubix> so there is a kind of workaround
23:33:09 <Lor> Depends on what you want to do.
23:33:29 <Lor> If you're in the IO monad and allow side effects, then you can do exception handling just as in any other language.
23:33:38 <Lor> But in pure code, there are obvious restrictions.
23:35:22 <rubix> is exception handling something more dificult for the compiler in pure code ?
23:36:16 <Lor> No, but they're, well, impure. :)
23:36:23 <Lor> Except in the limited way that ghc supports them.
23:36:59 <rubix> I see
23:37:10 <ddarius> rubix: throwing exceptions is fine, catching them is tricky, for example, what should a catch around error "a" + error "b" return?
23:37:51 <rubix> ddarius, the first actually evaluated ?
23:38:03 <rubix> even if it is not deterministic
23:38:21 <rubix> determinist
23:38:28 <rubix> what's the english word for that ?
23:38:35 <Cale> deterministic
23:38:51 <Lor> This explains the rationale: http://citeseer.nj.nec.com/peytonjones99semantics.html
23:39:39 <Cale> nice, Galeon hates that page for some reason :)
23:39:57 <Cale> must be gecko
23:40:16 <rubix> ok, I'll read this when I have time :)
23:40:25 <Aether> What's the most well known peice of Haskell software?
23:40:34 <Aether> Like Python has Zope and Twisted
23:40:38 <ddarius> The compiler's ;)
23:40:40 <Lor> Most likely ghc itself.
23:40:42 <Aether> Perl has, stuff
23:40:59 <Aether> I'm talking like applications written with haskell
23:41:09 <Lor> A compiler is not an application? :)
23:41:20 <Aether> Lor: is it written with Haskell?
23:41:46 <Cale> I'm fairly sure GHC is.
23:42:11 <ddarius> All of them (specifically compilers) are.  Hugs is written mostly in C.
23:43:02 <Aether> Yeah... the qualification of the question was application written with python that I could study to get an idea of Haskell's scalability and a general idea of the language
23:43:10 <Aether> s/python/haskell/
23:44:20 <Lor> ghc is rather a big application. It's perhaps not the easiest to read, though.
23:44:29 <Cale> http://haskell.org/practice.html
23:44:36 <Cale> there's a bunch of stuff there
