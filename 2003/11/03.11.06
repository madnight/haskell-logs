01:06:58 <shapr> hi elmex 
01:07:18 <shapr> elmex: found any self descriptive formats?
02:14:37 <elmex> shapr: not yet (i am just in school... be bcak later)
02:14:41 <shapr> ok
02:14:43 <elmex> s/just/at tehe moment/
02:14:57 <elmex> going to have math in some minutes ;)
02:15:23 <Jad> shapr: hello
02:15:36 <shapr> hi Jad
02:15:57 <Jad> busy ?
02:16:08 <shapr> yes
02:16:15 <Jad> k.
02:42:04 <crazney_> hey, you know how when you define a type (either type Foo = (Int, Int) or data Bar = Baz Int | Waz Float, etc...).. if you have a rather complex type, is there any general way for specifying named elements?.. so someone using the type knows what the different elements are?
02:42:54 <crazney_> ie, say if you have a 'type Properties = (Int, Float, Float, Int, Int)'.. thats not very descriptive..  Like you could do 'type Properties = (Frequency, Time, Size, ....)' and then alias all of them to Int or Float or whatever.. but that seems yuk.
02:44:29 <shapr> that's how it's usually done
02:44:47 <crazney_> hrm, ok. thanks dude.
02:45:21 <shapr> you just make sure you declare Frequency etc in your type signatures
02:45:43 <shapr> then you know it's an Int, but it won't take just any Int, only one declared as a Frequency
02:45:57 <shapr> er...
02:46:02 <shapr> I'm not sure I got that right.
02:46:35 <crazney_> i think type synonms only have to be of an equiv type.
02:47:49 <Darius> Why would it seem yuk to have a type Frequency = Int etc.?  Presumably, it'll be used more than once, but if not then just add a comment.
02:48:23 <crazney_> well, it just seems like you would have a lot of them, if there are many different properties..
02:48:51 <Darius> So?
02:48:56 * crazney_ shrugs
02:49:12 <crazney_> ... just uses a lot of space.. didn't know if it was right.
02:50:22 <dennisb> crazney_: you can also take a look at the records in haskell
02:50:40 <crazney_> 'the records'?
02:52:05 <dennisb> here is an example: data Foo = Bar { freq :: Int, size :: Int }
02:52:47 <crazney_> hrm, never seen that syntax before.
02:53:13 <dennisb> if you have x :: Foo then you can say freq x to get that integer
02:54:59 <crazney_> ah ok.. that makes sense, kinda.
02:56:03 <dennisb> it's more or less the same as data Foo = Bar Int Int, except that one can use the labels to get a part of it
02:57:24 <crazney_> right - and 'freq' becomes a function that returns that? (what happens to freq in the rest of the 'namespace')
02:57:54 <dennisb> yes, freq :: Foo -> Int
02:58:47 <dennisb> there is also a way to "update" a record (that is copy an old and change a field, it's still pure haskell)
03:00:44 <crazney_> alright, i'll have a fiddle. thanks!
06:37:32 <Lunar^> Anyone here reading LtU ?
06:38:18 <shapr> Lunar^: me me!
06:38:53 <Lunar^> shapr: Do you know what "catamorphism" means ?!
06:39:31 <smkl> catamorphism is just fold
06:40:21 <Lunar^> ?
06:40:42 <shapr> yup, greek kata is in catastrophe for example
06:40:46 <phubuh> It's a fancy name for foldr. :-)
06:41:06 <Lunar^> How that ?
06:41:08 <shapr> cata means 'gets smaller'
06:41:23 <shapr> cata, ana, hylo, more I can't remember
06:41:59 <phubuh> Sorry, not for the actual function foldr, but a function whose effect is that of right fold.
06:43:08 <Lunar^> I really don't get where that comes from
06:44:36 <phubuh> It could be translated to something like `downwards transformation'
06:44:54 <Lunar^> mhh ok
06:45:10 <shapr> what are all the various morphisms?
06:45:49 <shapr> Lunar^: I think Meijer's Banana, Lenses, Barbed Wire, etc paper talks about these.
06:46:06 <phubuh> If cata means down, ana means up; an anamorphism is an unfold.
06:47:02 <shapr> Lunar^: http://www.cse.ogi.edu/~erik/Personal/classic.htm
06:49:17 <phubuh> Hylomorphism is a catamorphism of an anamorphism
06:49:23 * earthy nods
06:49:29 <shapr> aren't there others?
06:49:36 <Lunar^> shapr: found something nice on tunes.org
06:49:40 <earthy> and then there's a paramorphism... :)
06:50:23 <shapr> an abamorphism is when a band suddenly starts producing swedish pop music.
06:50:27 * shapr snickers
06:50:49 <phubuh> Haha
06:51:09 * shapr tries to think of more
06:51:16 <shapr> halomorphism?
06:51:22 <shapr> when an angel gets its wings?
06:52:04 <steveh> when a talented mac game company turns into Microserfs :-P
06:52:11 <earthy> ;)
06:53:15 <shapr> dogomorphism?
06:53:17 <Segora> droidomorphism - when a talented, young hacker turns into a disgruntled machine turning coffee into code
06:53:23 <shapr> Segora: ohh, evil
06:53:46 * Segora sips on his coffee.
06:53:56 <shapr> of course, this probably doesn't help Lunar^, since he doesn't know them all already :-)
06:54:38 <earthy> anyway, the cata- and anamorphisms are the really important ones
06:55:03 <earthy> hylo- and paramorphisms can be expressed in terms of them (if I read the bananas, lenses and barbed wire paper correctly)
06:55:23 <steveh> has anyone done any work with XML and XSLT in Haskell?
06:55:26 <shapr> me me!
06:55:34 <shapr> steveh: in short, Don't use XSLT
06:55:44 <shapr> it's like mining with a spoon.
06:55:44 <earthy> xslt is slightly nasty
06:55:52 <steveh> no no
06:56:01 <steveh> I want to use XSLT for what it's designed for
06:56:09 <Lunar^> Segora: lol
06:56:09 <shapr> eww
06:56:15 <steveh> I need to turn WSDL files into readable documentation
06:56:17 <Lunar^> shapr: http://cliki.tunes.org/Morphism
06:56:20 <shapr> steveh: http://www.scannedinavian.org/~shae/src/haskell/Test_Hxml.hs
06:56:49 <shapr> steveh: the two tools I know about are HXMLToolbox (toolkit?) and HaXML
06:57:19 <shapr> http://www.cs.york.ac.uk/fp/HaXml/
06:57:31 <shapr> http://www.fh-wedel.de/~si/HXmlToolbox/
06:57:49 <shapr> oh goody, HXMLToolbox 3.01 is out!
06:57:54 <steveh> hm hmm
06:58:01 <shapr> and he's extended the HUnit tests I wrote..
06:58:05 * shapr downloads
06:59:22 <steveh> but the more I think about it the more I think that what I want has to be out there in some form or another
07:01:11 <steveh> hm
07:01:30 <steveh> company firewall blocks philip.greenspun.com
07:10:00 <shapr> steveh: what are you looking for?
07:25:47 <sild> does the 'where foo = ...' directive
07:26:07 <sild> compute the value of '...' for every foo used, or does it calculate it once and use the result each time?
07:27:02 <shapr> for every foo used
07:27:04 <earthy> that is an implementation detail
07:27:09 <shapr> mostly
07:27:28 <shapr> there are cases where it doesn't calculate it for every foo used, but I've forgotten the details
07:27:31 * earthy whacks shapr over the head with referential transparency
07:27:33 <shapr> (this is GHC specifically)
07:27:48 * shapr becomes side-effect shaped
07:27:53 <earthy> sild: semantically, it does not matter.
07:28:00 <sild> oh, ok, I thought it might have been specified in the standard or something
07:29:04 <earthy> (and I'd say GHC shares the foo, as it generates a thunk for the calculation that foo represents, and evaluates that once, and then reuses the result, as it gets stored in the thunk, if I understand the implementation correctly)
07:29:41 <Lunar^> Anyone knows a Haskell source to pretty HTML converter ?
07:29:59 <earthy> lhs2TeX followed by latex2html?
07:30:07 <Lunar^> urg
07:30:08 <shapr> Lunar^: M-x htmlify-buffer
07:30:12 <shapr> works for me
07:30:16 <Lunar^> mhhh nice
07:30:36 <shapr> http://www.scannedinavian.org/~shae/src/haskell/GKSuffixTree.html
07:30:39 <earthy> shapr: but you don't get nice symbols for -> and stuff! :)
07:30:42 <Lunar^> shapr: which mode do I need ?
07:30:44 <shapr> http://www.scannedinavian.org/~shae/src/haskell/GKSuffixTree.hs
07:30:49 <shapr> earthy: that's true.
07:31:04 <shapr> Lunar^: it's standard with XEmacs, I dunno about Gnumacs
07:31:09 <Lunar^> shapr: k
07:31:16 <shapr> hoi mijneer braakman
07:31:30 <shapr> I wonder if I spelled that correctly.
07:31:35 <dark> Goedemiddag shapr.
07:31:35 <sild> Lunar^: try enscript
07:31:55 <shapr> yah, enscript is a good idea
07:32:18 <dark> shapr: I'm not sure if you did :)
07:32:22 <shapr> heh
07:32:24 <earthy> mijnheer or meneer. ;)
07:32:36 <shapr> dark: how much do you speak dutch nowadays?
07:32:38 <dark> I always thought it was either meneer or mijnheer, but I'm getting lots of google hits for mijneer too.
07:32:50 <dark> shapr: Not much.  Only on the phone :)
07:33:02 * shapr calls up dark
07:33:34 <shapr> actually, I don't have your phone number.
07:33:52 <dark> My phone has a tendency to turn itself off, anyway.
07:34:01 <dark> I should probably get a new battery for it.
07:34:16 <shapr> oh, I thought it was just in anticipation of who was calling
07:34:25 <earthy> and that in finland. >:)
07:34:39 <dark> If so, it successfully protects me from knowing who's trying to call :)
07:34:54 <dark> Unless they send an SMS instead.
07:34:58 * shapr tries to google for dark's phone number
07:35:38 * earthy decides not to try sending an SMS
07:35:49 <earthy> (bah, those are expensive, if calculated per bit)
07:35:56 <shapr> per bit? really?
07:36:02 <earthy> shapr: no, per SMS
07:36:15 <shapr> oh
07:36:30 <dark> earthy: Yeah but one of the companies here is offering a deal that includes free SMSing to up to 5 friends.
07:36:44 <earthy> given that there's a max of 160 chars per SMS, and that it is probably encoded with one byte per char there are 1280 bits in an SMS
07:36:49 <dark> earthy: We've been wondering if we could build a network that way and run TCP over SMS.
07:37:05 <dark> earthy: 7 bits per char.  It's 140 bytes.
07:37:17 <shapr> dark: you're not easy to netstalk
07:37:17 <earthy> dark: you *could*, but you'd have *terrible* MTU's.
07:37:20 <dark> earthy: If you have a GSM modem you can hide some more data bits in the headers if you like.
07:37:42 <dark> shapr: This is deliberate :)
07:37:50 <shapr> you seem to have succeeded.
07:37:52 <earthy> 7 bits even? then how the *fuck* do they encode diacriticals? (which e.g. my Sony Ericsson does...)
07:38:01 <dark> earthy: Special character set.
07:38:19 <earthy> and how do you switch? where's the charsetswitchbit?
07:38:43 <shapr> maybe the whole sms charset is special?
07:38:46 <dark> earthy: Similar to ASCII, but most of the control codes have been repurposed.  There are also some escape sequences.  The euro symbol takes up 2 characters; it's amusing to see SMS software struggle with this and fail.
07:38:54 <earthy> anyway, at 15 eurocents per SMS that counts out to about 1/80eth of a eurocent per bit
07:39:05 <earthy> dark: ah. :)
07:39:09 <Smerdyakov> Repurposed. That sounds like a euphemism for "fired from their jobs."
07:39:34 <dark> earthy: There's a fairly complicated "datatype" encoding in some of the bits.  It can select between the 7-bit GSM charset, 16-bit Unicode, or binary data.
07:39:46 * earthy nods
07:40:03 <dark> earthy: There's also an extensible header-bytes format but that takes up part of the space for data.
07:40:10 <earthy> so, in Unicode you only get like 70 chars?
07:40:53 <dark> earthy: Yup.  Less, if you send accented characters as multiple codepoints.
07:41:17 <earthy> anyway, count 1/80th of a cent per bit for SMS against EUR 1.50 per MiB for GPRS...
07:41:41 <earthy> and SMS suddenly sounds like a very bad deal. ;)
07:41:42 <dark> Yeah but SMS has wider reach :)
07:41:49 <shapr> I still haven't gotten GPRS and IR setup on my phone so I can check my email from my palm IIIc
07:41:51 <shapr> I should do that.
07:41:55 <dark> It's also store-and-forward.  Does GPRS do that?
07:42:03 <earthy> dark: not that I know
07:42:30 <earthy> but SMS's are *outrageously* expensive. basically, you pay for the luxury of being allowed to pay.
07:42:39 <dark> The reason I know way too much about SMS is that I worked on Kannel a few years ago.  GRPS is after my time :-)
07:42:48 <earthy> Kannel?
07:42:52 <shapr> kannel.org
07:42:56 <shapr> sms and wap gateway iirc
07:43:07 <shapr> netstalking dark was productive in that at least :-)
07:43:16 <dark> earthy: I think they'v always been cheaper here than in NL, though.  But I don't know the current price.
07:43:22 <dark> shapr: Heh :)
07:44:14 <dark> At the time I was pretty much expecting the first WAP viruses to show up in a year or two.  Good thing that that hasn't happened.
07:44:24 <earthy> back in the day SMS was free. :)
07:44:29 <shapr> how can you write a WAP virus?
07:44:35 <earthy> they wisened up on that damn quick though.
07:44:49 <dark> shapr: The WAP specs include a little javascriptish language that gets bytecoded and then run by the phone.
07:44:52 <shapr> I tried to come up with a J2ME virus, but I don't think it's possible.
07:44:59 <shapr> oh, scary
07:45:36 <dark> shapr: People were going crazy adding features, including letting the scripts access the phone's address book and make new WAP requests.
07:45:56 <dark> shapr: It wouldn't surprise me to find the usual exploits as well, such as buffer overruns.
07:46:28 <dark> shapr: We found some phones that would crash if you sent them a malformed SMS :)  In some cases it would make the SIM unusable until you fixed it with another phone.
07:46:45 <phubuh> Hey, speaking of cool arrows in Emacs: http://www.phubuh.org/~phubuh/haskell-unicode.png
07:46:48 <dark> shapr: But so far, no SMS worms yet.  I guess they're too short, and/or there's too much diversity in phones.
07:46:59 <earthy> hm. kannel is cool. :)
07:47:02 <earthy> phubuh: :)
07:48:15 <shapr> phubuh: have you seen pretty-lambda?
07:48:27 <phubuh> Yup.
07:48:30 <phubuh> http://www.emacswiki.org/cgi-bin/wiki/PrettyLambda
07:48:49 <phubuh> I added the generalization. :-)
07:48:52 <dark> phubuh: You're going to merge Haskell and APL? :)
07:48:54 <shapr> phubuh: that's a really cool screenshot, does that work as a standard haskell-mode?
07:49:29 <phubuh> shapr: Yeah, it uses the method used by pretty-lambda.
07:49:31 <shapr> phubuh: how'd you do that? I wanna know!
07:49:39 <shapr> are you distributing the source?
07:49:46 <phubuh> Of course! :-)
07:49:48 <shapr> that would be a very spiffy standard extension to haskell-mode
07:50:00 <shapr> is it stable enough to submit to Simon?
07:50:11 <Lunar^> cvs login: authorization failed: server cvs.haskell.org rejected access to /cvs for user anoncvs <--- any idea ?
07:50:28 <shapr> Lunar^: I think glass.something.ogi.edu is the anon server
07:50:40 <shapr> I think cvs.haskell.org is only for committers
07:50:44 <shapr> but I could be wrong
07:50:56 <Lunar^> same reply for glass.cse.ogi.edu
07:51:00 <shapr> oh
07:51:23 <phubuh> All the code is at the PrettyLambda page on the EmacsWiki.
07:51:37 <Lunar^> mhh
07:51:51 <Lunar^> If I use the right password (cvs) that works
07:52:26 <phubuh> There's one thing left to do (as far as I can see): notFoo or sqrtFoo will have their nots and sqrts symbolized, even though the regular expression has \\> guards.  I'm not sure why.
07:53:04 <shapr> phubuh: dude, you gotta create an EmacsWiki homepage
07:53:07 <phubuh> It would be easy to fix given a list of identifier boundarys, actually.
07:53:16 <phubuh> Oh, yeah, I've been meaning to do that :-)
07:53:47 <phubuh> s/ys/ies/
07:53:51 <dark> Hmm you refer to PrettyLambda but the lambda is the only thing that's still just a backslash :)
07:53:53 <shapr> wow, this is gorgeous :-) I gotta have it!
07:54:13 <shapr> too bad I'm about to go see the 3rd matrix movie, I want prettyHaskell!
07:54:43 <phubuh> Hee hee :-)
07:55:03 <phubuh> dark: Haha, yeah.  Maybe \x -> ... should be rendered as <lambda>x -> ...
07:55:33 <Lunar^> That works only on XEmacs I think ?
07:55:58 <phubuh> I use GNU Emacs, so I don't think so. :-)
07:56:09 <Lunar^> Neat :)
07:57:55 <shapr> geez, 1988 :-)
07:57:57 <phubuh> It's trivial to make \ render as a lambda, but the lambda sign is pretty ugly in most fonts. :-(
08:00:41 <dark> shapr: 1988 what?
08:00:54 <shapr> is a birthyear far from mine
08:01:16 <phubuh> Oh, I thought you were making fun of GNU Emacs for being ancient. :-)
08:01:40 <phubuh> Hey, where did you find my birth year?
08:02:05 <shapr> phubuh: where do you think?
08:03:38 <phubuh> Hmm...
08:04:03 <phubuh> Ah, EmacsChannelDemographics? :-)
08:04:06 <shapr> yup
08:04:13 <shapr> I wrote mine next to yours, that's why I noticed.
08:04:44 <shapr> I'm not the oldest person mentioned there, but I'm third
08:04:54 <phubuh> Hee hee.
08:05:20 <phubuh> e1f is definitely the youngest!
08:05:44 <dark> Yeah but the thing about being the youngest is that it goes away.  Being the oldest can be maintained indefinitely.
08:05:57 <shapr> phubuh: is he really that young?
08:05:58 <phubuh> I've noticed that. >_<
08:06:23 <shapr> oh, maybe I'm thinking of elf who's older than me
08:07:56 <phubuh> If he is, it's pretty remarkable that he studies Engineering Algorithms and Data Structures at Ryerson University
08:08:20 <dark> Yeah but some people do remarkable things :)
08:08:25 <phubuh> Indeed.
08:08:40 <phubuh> It's also pretty remarkable that he wrote an Emacs tutorial in 1994, when he was three years old. :-)
08:09:22 --- topic: set to '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","lots of cool debs in the haskell-experimental archive - see http://www.syntaxpolice.org/haskell-experimental/haskell-experimental.html","new monads tutorial http://www.nomaware.com/monads/html/","Any user who would like to request any unwritten tutorial please msg shapr", "peakUsers = 72"]' by SyntaxPolice
08:09:32 <phubuh> Hooray!  If it's actually an elaborate prank, I'm still the youngest EmacsChanneler. :-)
08:18:40 <Smerdyakov> Have you worked on any open source projects, phubuh?
08:19:25 <phubuh> Nope.
08:22:26 <Smerdyakov> Then you don't get any more points for being young than Joe Random does. :P
08:22:42 <shapr> who's Joe Random? does he work on opensource projects?
08:22:52 <phubuh> Haha, of course not.
08:22:53 * shapr grins
08:22:54 <dark> Yep.  Famous for it.
08:34:20 <Jad> shapr: saki.easyhttp.com
08:34:33 <Jad> in the articles section is the final version
08:35:02 <shapr> Jad: spiffy
08:35:16 <Jad> what does spiffy mean ?
08:35:39 <shapr> er, pleasurable, entertaining, that sort of stuff
08:35:51 <Jad> ah okay
08:37:24 <Jad> tell me what do you think of the site too
08:38:09 <shapr> sure
08:38:29 <dark> Probably the site will be spiffy too :)
08:38:37 <harsha> hello #haskell
08:38:46 <Jad> hello harsha
08:38:52 <harsha> Jad: Hi
08:38:53 <Jad> shapr: are you busy now ?
08:39:02 <Jad> i got a little project i wanted to suggest
08:39:12 <shapr> tell me
08:39:18 <shapr> I'm sort of busy, but I have to stop soon.
08:39:31 <harsha> hi shapr 
08:39:32 <Jad> ill msg you in private
08:39:36 <shapr> hi harsha 
08:39:40 <shapr> Jad: ok
08:39:50 <harsha> shapr: i recoverd my data.  
08:39:54 <shapr> harsha: yay
08:40:20 <harsha> :) i ran a reiserfsck --fix-fixable :)
08:40:30 <harsha> anyways. laters if ya busy
08:41:54 <harsha> brb guys 
09:03:00 * shapr goes off to see Matrix : Revolutions
09:03:15 <phubuh> Have fun! :-)
09:03:46 <Lunar^> shapr: Don't tell anything on this channel after that :0\
09:08:52 <phubuh> --/-....-/-..- --/---/.-./..././-....-/.-././--./../---/-. ../... --./---/---/-.. ..-./---/.-. .../.--./---/../.-.././.-./.../.-.-.-
09:17:38 <kaninchen> verborge cs 1.5/1.6 server (2on2-3on3) -> wer braucht soll sich melden
09:18:23 <vegai> I wonder if that movie can offer yet another surprise
10:45:34 * isomer is away: class^H^H^H^Hnap time
13:08:08 <Jad> shapr: ther ?
13:12:56 --- topic: '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","lots of cool debs in the haskell-experimental archive - see http://www.syntaxpolice.org/haskell-experimental/haskell-experimental.html","new monads tutorial http://www.nomaware.com/monads/html/","Any user who would like to request any unwritten tutorial please msg shapr", "peakUsers = 72"]'
13:12:56 --- topic: set by SyntaxPolice on [Thu Nov 06 08:09:22 2003]
14:07:29 * isomer is back (gone 03:21:52)
14:30:19 <shapr> wheee
14:35:25 <blackdog> shapr: any good? (no spoilers, i beg)
14:35:39 <shapr> I enjoyed it.
14:36:36 <shapr> he's back!
14:36:44 <shapr> the snowcastle of yore!
14:37:18 * Igloo always screws server changes with irssi up
14:38:07 <shapr> g'day Pseudonym 
14:38:11 <Pseudonym> G'day.
14:40:07 <Pseudonym> Playing with something interesting.
14:40:17 <Pseudonym> Physical simulation.
14:40:40 <shapr> of what sort?
14:40:46 <Pseudonym> Cloth, specifically.
14:40:56 <shapr> url?
14:41:10 <Pseudonym> Not that I know of, no.
14:41:19 <Pseudonym> Unless you have access to the ACM digital library...
14:41:36 <shapr> nope
14:43:16 <Pseudonym> Basically, cloth is a 2D laminar surface which resists bending and stretching.
14:43:34 <Pseudonym> This is mostly so I can play with solvers.
14:43:52 <Pseudonym> I want to understand how preconditioned conjugate gradient solvers work.
14:49:57 <Pseudonym> It's... OK.  How much do you know about solving dynamical systems?
15:31:52 <shapr> Pseudonym: nothing
15:32:54 <phubuh> I know nothing of the actual theory behind it, but I wrote a very kludgy thing for a little SDL game to simulate `ninja rope'. :-)
15:34:30 <Smerdyakov> phubuh, you mean a more physically accurate ninja rope than the one from Worms 2?
15:34:56 <phubuh> Well, at least you couldn't shoot it downwards and prepel yourself upwards.
15:35:37 <phubuh> But I'm sure it was pretty inconsistent with the real world -- I just sketched up some situations on paper and figured out a way to simulate something like it.
15:36:51 <phubuh> It was way too simple to be accurate. :-)
15:45:10 <Pseudonym> :-)
15:45:22 <Pseudonym> Well accuracy isn't imnportant for the entertainment industry.
15:45:29 <Pseudonym> Far more important is keeping the simulation stable.
15:45:44 <Pseudonym> In order: 1) Looks right, 2) stable, 3) fast.
15:46:02 <Pseudonym> "Accurate" is somewhere around the 500 mark.
15:46:28 <shapr> how would you model a ninja rope in Haskell?
15:46:32 <shapr> I don't actually know what one is...
15:46:55 <Pseudonym> I don't either, but here's what I'd do.  In fact it's what I'm doing, only in 2 dimensions instead of 1.
15:47:09 <Pseudonym> Newton's second law: F = ma
15:47:11 <phubuh> Mine was unstable and slow, but it looked pretty neat. :-)
15:47:35 <Pseudonym> So you compute the forces on each particle, then integrate it twice.
15:48:06 <Pseudonym> The simplest way to do this is to use Euler stepping.
15:48:26 <Pseudonym> The acceleration is the second time derivative of x.
15:49:00 <Pseudonym> So you say x(t+1) = x(t) + dt * x'(t)
15:49:10 <Pseudonym> x'(t+1) = x'(t) + dt * F/m
15:49:25 <Pseudonym> Sorry, I emant x(t+dt), not +1.
15:49:33 <Pseudonym> Where dt is fixed.
15:49:37 <Pseudonym> This is decidedly unstable.
15:49:53 <Pseudonym> All it takes is a freak derivative and your simulation of way off in the clouds somewhere.
15:50:13 * shapr stares at that
15:51:06 <Pseudonym> Basically, the idea is that x'(t) ~= (x(t+dt) - x(t)) / dt
15:51:19 <Pseudonym> where dt is some fixed small time interval.
15:52:15 <shapr> ok
15:52:20 <Pseudonym> With me?
15:52:31 <shapr> I think so
15:52:46 <Pseudonym> If you haven't done any physics recently, it can be a bit straining to remember all this stuff.
15:52:49 <Pseudonym> OK.
15:53:08 <Pseudonym> To keep the simulation stable, I'm actually stepping backwards in time instead.
15:53:12 <Pseudonym> Let me explain.
15:53:37 <shapr> oh, I think I understand
15:54:05 <Pseudonym> x(t+dt) = x(t) + x'(t) * dt
15:54:06 <shapr> since the 'total' of the simulation will be smaller, it's much easier to step backwards and keep it stable
15:54:09 <Pseudonym> Instead, I'm using this:
15:54:21 <Pseudonym> x(t+dt) = x(t) - x'(t+dt) * dt
15:54:28 <Pseudonym> Sorry.
15:54:35 <Pseudonym> x(t) = x(t+dt) - x'(t+dt) * dt
15:54:38 <Pseudonym> That's what I meant.
15:54:39 <shapr> right, okay
15:54:49 <shapr> it's an unfold
15:55:04 <shapr> ?
15:55:18 <Pseudonym> The benefit of this is that freak derivatives don't kill you, because at least you end up somewhere which would take you back to where you were, should you step backwards in time.
15:55:33 <shapr> right, I understand.
15:55:37 <Pseudonym> OK.
15:55:48 <shapr> you've set the max by choosing your endpoint rather than your start point
15:55:49 <Pseudonym> So you here are your equations of motion:
15:56:02 <Pseudonym> x(t+dt) - x(t) = -x'(t+dt) * dt
15:56:23 <Pseudonym> x'(t+dt) - x'(t) = - F(t + dt) / m * dt
15:56:35 <Pseudonym> The problem is the forces.
15:57:15 <Pseudonym> If you have x(t) and x'(t), you want x(t+dt) and x'(t+dt), but you can't get them unless you know where you're going, because you need to compute the forces at the place where you're going.
15:57:21 <Pseudonym> If you kind of understand that.
15:58:25 <Pseudonym> Hang on, I'll introduce the notation dx = x(t+dt) - x(t) and similarly for dx'
15:58:32 <shapr> I think I understand that.
15:58:37 <Pseudonym> dx = -x'(t+dt) * dt
15:58:44 <Pseudonym> dx' = -F(t+dt) / m * dt
15:59:00 <Pseudonym> OK, so what we do is expand F using a Taylor series.
15:59:11 <shapr> I don't know what a Taylor series is...
15:59:15 * shapr googles
15:59:35 <Pseudonym> F(t+dt) = F(t) + dF(t)/dx * dx + dF(t)/dx' * dx'
15:59:44 <Pseudonym> That's the first order approximation.
15:59:51 <Pseudonym> dF(t)/dx is a partial derivative, BTW.
16:00:32 <dark> I think it's something where mathematicians say "If you use lots of terms, you end up somewhere close to the real answer", and physicists say "Okay, but I got bored after two terms."
16:00:32 <Pseudonym> See, generally the forces are a function of only position and velocity.
16:00:39 <Pseudonym> Yes. :-)
16:00:55 <shapr> ohh
16:00:56 <Pseudonym> I stopped listening to physicists when one said "pi is about 10".
16:01:08 <phubuh> I didn't even start.
16:01:21 <shapr> I tried to become a physicist at one point.
16:01:22 * shapr shudders
16:01:26 <crass> has anyone gotten ghc to compile and link a haskell program on with glibc 2.3 ?
16:01:29 <Pseudonym> Me too.
16:01:41 <Pseudonym> OK, you with me so far?
16:01:48 <shapr> crass: I think that's discussed on ghc-users at some point recently
16:01:51 <shapr> Pseudonym: sort of
16:02:08 <Pseudonym> OK.  Now if you substitue all this in, you get:
16:02:13 <crass> shapr: thanks, I've been asking this for several months, I'll check the list :)
16:02:41 <shapr> crass: see, you just gotta ask here ;-)
16:02:41 <Pseudonym> dx' = 1/m (F(t) + dF(t)/dx' * dx' - ddF/dx (x' + dx')) * dt
16:02:50 <Pseudonym> Where everything is known except dx'.
16:03:05 <Pseudonym> And moreover, it's _linear_ in dx'.
16:03:35 <Pseudonym> x, x' etc are in general vectors, if you're dealing with a system of many particles.
16:04:03 <Pseudonym> So this is a huge linear equation, so it's easily solved.
16:04:45 <shapr> crass: any other questions?
16:04:55 <crass> shapr: well I'm trying to find the list =P
16:05:31 <shapr> crass: if nothing else works, I think Igloo will know something more about it.
16:06:08 <crass> shapr: thanks, I'll see if I can find anythign on the list, and ask if I can't, thanks for the pointer
16:06:36 * shapr yawns
16:06:45 <dark> crass: Hmm... I've had no problems with ghc6 and glibc 2.3.2.  This is on a Debian system.
16:07:06 <shapr> Pseudonym: so I could use this to solve for a 2D network of interconnected springs?
16:07:09 <crass> dark: that's likely because debian compiled it for 2.3
16:07:18 <Pseudonym> Anyway, I've written the code to handle polygonal meshes and a rudimentary RenderMan interface.  We'll see if I get anywhere.
16:07:32 <phubuh> Are you writing this in Haskell, Pseudonym?
16:07:34 <Pseudonym> shapr: Probably, yes.
16:07:41 <Pseudonym> phubuh: Of course.
16:07:51 <phubuh> I figured. :-)
16:08:08 <shapr> hej drlion 
16:08:12 <Pseudonym> Because the linear system is very sparse, I think it's going to be fairly easy to write in Haskell.
16:08:14 <drlion> hej hej
16:08:19 <Pseudonym> The mesh code uses a lot of IORefs, though.
16:08:24 <phubuh> hej :-)
16:08:32 <shapr> drlion: are you related to phubuh ?
16:08:43 <drlion> in a way, yes
16:08:52 * shapr is curious
16:08:57 <Pseudonym> drlion is phubuh's troll nick.
16:09:04 <Pseudonym> Or is it the other way around?
16:09:19 <drlion> oh god
16:09:19 <phubuh> I use that alias to say stupid things.
16:09:35 <drlion> my reputation on the internet is forever ruined
16:09:37 <Pseudonym> Could be a lambdabot instance, I suppose.
16:09:39 <Pseudonym> drlion: @hello
16:09:43 <Pseudonym> Nope.
16:09:50 <dark> Pseudonym: Maybe it's just a slow one.
16:09:59 <Pseudonym> True.  I will wait.
16:10:06 * shapr snickers
16:10:17 <phubuh> drlion is actually my real-life brother.
16:10:20 <shapr> speaking of which, it's time for another lambdabot release.
16:10:28 <shapr> phubuh: I wondered about that whole similar last name thing.
16:10:41 <Pseudonym> Yes, phubuh is so similar to drlion.
16:10:52 <dark> I wonder if it's somehow related to my name.
16:11:01 <shapr> I wondered that too.
16:11:07 <shapr> maybe your ancestors were swedish.
16:11:07 <phubuh> dark: Hey, that's cool.
16:11:15 <dark> What does it mean in swedish?
16:11:18 <Pseudonym> I have many Danish ancestors.
16:11:31 <Pseudonym> Well, Danish or German, depending on which army was occupying at the time.
16:11:31 <phubuh> Nothing.  I think Brockman is german, originally.
16:11:36 * Pseudonym understands Euro politics
16:11:41 <dark> Pseudonym: That's okay.  Lots of Danes do, too, and they're not embarrassed about it at all.
16:11:54 <shapr> drlion: learning Haskell?
16:11:58 <Pseudonym> No Swedish ancestors that I'm aware of.
16:12:19 <Pseudonym> dark: I'm very proud of my ancestors which I know absolutely nothing about.
16:12:21 <drlion> not really. i was just getting bored of #c++ :-)
16:12:29 * dark has a French pirate in his lineage somewhere.
16:12:40 <shapr> drlion: Haskell is a powerful language. Would you like to see some promotional literature?
16:12:45 * shapr snickers
16:12:54 <Pseudonym> I have a British/Australian pirate.  Bully Hayes was his name.
16:13:08 <dark> Pseudonym: Was he any good?
16:13:08 <shapr> I have bootleggers in my very recent ancestry.
16:13:37 <dark> drlion: Also, Haskell lets you redefine ALL the operators.  You'll feel right at home!
16:13:38 <shapr> drlion: have you seen http://www.haskell.org/complex/why_does_haskell_matter.html ?
16:14:04 <shapr> that url mentions C++ btw
16:14:16 <drlion> dark: i bet it doesn't even have unary operators
16:14:16 <Pseudonym> dark: Actually, now that I look him up on Google, it turns out he was born in Cleveland.  I feel so dirty.
16:15:44 <drlion> shapr: no, but i suppose i will read through it so that i know what you guys are talking about
16:15:57 <dark> ... we haven't talked about Haskell so far :)
16:16:07 <shapr> drlion: the first higher order function is free, then the addiction sets in...
16:16:18 <shapr> and suddenly, before you know it, you want to write your own monads.
16:16:19 <Pseudonym> drlion: When people start mentioning bananas, lenses and barbed wire, then you're allowed to tune out.
16:16:39 <shapr> actually, that came up earlier today.
16:16:46 <dark> banana = foldr lens [] (barbed ++ wire)
16:16:50 <Pseudonym> Yes, it came up on haskell-cafe.
16:17:06 <shapr> I proposed abamorphism (when a band starts playing swedish pop) and dogomorphism (obvious)
16:17:59 <Pseudonym> A dogomorphism is, presumably, a recursive function which drinks out of the toilet.
16:18:04 * shapr laughs
16:18:45 * Pseudonym looks for random Greek prepositions
16:19:15 <Pseudonym> antimorphism
16:19:21 <Pseudonym> I like the sound of that.
16:19:31 <shapr> that's where something suddenly changes back into whatever it was before the last morph?
16:19:44 <Pseudonym> Perhaps it turns on your promorphism.
16:20:01 <shapr> I think I require sleep.
16:20:12 <shapr> as much as I'd like to stay and chat, I'm falling over.
16:20:16 <Pseudonym> metamorphism
16:20:19 <Pseudonym> Now that's a good word.
16:20:20 <dark> It mentions Excel expressions as a functional language I've "probably already used".  I feel so old now.
16:20:23 <shapr> that is a good word
16:20:51 <Pseudonym> upomorphism
16:20:57 <Pseudonym> upo == "instead of"
16:21:05 <Pseudonym> Sorry, uper.
16:21:07 <Pseudonym> upermorphism.
16:21:08 <shapr> sounds like aspects to me
16:21:16 <Pseudonym> Or proxies.
16:21:24 <shapr> aspect oriented programming could use upermorphism
16:21:37 <shapr> crazy formal language
16:21:43 <Pseudonym> diamorphism
16:21:47 <Pseudonym> That sounds like it could be real.
16:22:05 <Pseudonym> dia == "because of"
16:22:14 <Pseudonym> or "through"
16:22:55 <Pseudonym> http://www.biblestudysite.com/Prepositions%20greek%20diagram.gif
16:22:58 <Pseudonym> Good diagram.
16:27:31 <blubb> heya,  am trying to represent some n-ary trees in haskell using nested lists, does anyone know where I can get some info about how to do that?
16:28:00 <Smerdyakov> It's not possible using just lists, since every element of a list must have the same type.
16:28:01 <phubuh> Why do you want to do it using nested lists?
16:28:07 <Smerdyakov> You should create a tree datatype for this purpose.
16:30:50 <blubb> ahh ok, well that was just an idea
16:30:51 * shapr falls over asleep
16:30:54 <drlion> does using operator syntax allow you to partially apply either one of two arguments, as opposed to just the first for normal application syntax?
16:30:55 <Pseudonym> Night.
16:31:00 <blubb> have only just started working with haskell
16:31:15 <Pseudonym> drlion: Yes.  You can use an operator section.
16:31:17 <phubuh> drlion: Yes.
16:31:27 <Pseudonym> There are three forms.
16:31:35 <Pseudonym> (+)_ x y == x + y
16:31:42 <Pseudonym> Sorry.
16:31:46 <Pseudonym> (+) x y == x + y
16:31:57 <Pseudonym> (x+) y == x + y
16:32:04 <Pseudonym> (+y) x == x + y
16:32:20 <drlion> right, but you can't apply the third argument?
16:32:36 <Pseudonym> Infix operators don't have third arguments.
16:32:51 <Pseudonym> Not in the sense you're thinking of.
16:33:05 <drlion> no, but any two-argument function can be used as an infix operator, right?
16:33:11 <Pseudonym> Right.
16:33:32 <Pseudonym> A three-argument function can, too.
16:33:43 <drlion> so you can do this with two-argument functions, but not with three-argument ones. plug in any argument you want to, i mean
16:33:44 <Pseudonym> (x `f` y) z == f x y z
16:34:36 <Pseudonym> This is because f x y z == (f x y) z
16:34:36 <drlion> but how do i get \x y -> f x y z?
16:34:55 <Pseudonym> Probably with a local definition.
16:35:09 <Pseudonym> let g x y = f x y z in a `g` b
16:36:52 <drlion> i see. so there's no syntax for \x y -> f x y z analoguous to (`f` y) for \x -> f x y?
16:40:01 <phubuh> Nope.
16:41:12 <Pseudonym> The lambda calculus "thing" is to put arguments that you're more likely to want to bind first, not third.
16:41:50 <drlion> the problem arises when it's not clear what arguments are "more likely" to be bound early
16:42:15 <Pseudonym> Correct.
16:42:39 <Pseudonym> This may or may not add more information:
16:42:41 <Pseudonym> http://haskell.org/hawiki/AvoidingParameterPassing
16:44:42 <drlion> i have to say that in my limited experience of writing functional code i've written the perhaps biggest annoyance was having to decide this for apparently no reason other than the syntactic constraints
16:45:21 <Pseudonym> Well, most of the time it's no big deal.  You work with functions as if they had n arguments rather than only 1.
16:45:28 <Pseudonym> Most of the time you just ignore currying.
16:45:33 <phubuh> In which case you have to write a lambda expression, which isn't much of a deal.  The major advantage of currying, as I see it, is that it makes it possible for all functions to take a single argument, which is conceptually simpler.  Being able to type `map (+ 1) lst' is just a party trick.
16:45:55 <Pseudonym> Yes, I'd agree with that.
16:46:01 <Pseudonym> It makes the type system simpler.
16:46:51 <drlion> yes, of course. but if you're going to introduce one party trick, why not go all the way and make it a little symmetrical?
16:46:58 <Pseudonym> Occasionally it's actually useful.
16:47:27 <Pseudonym> I'm not really sure how you could make it symmetrical, drlion.
16:47:51 <drlion> or would you say being able to type  map foo bar  is a party trick?
16:47:53 <phubuh> How would that look?  You might be able to write some Template Haskell to create the functions for you.
16:48:19 <phubuh> No, because that doesn't take advantage of currying.
16:48:21 <Pseudonym> I should point out that Haskell easily lets you write combinators.
16:48:32 <drlion> yes, actually it does
16:48:36 <Pseudonym> Combinators let you write as many of these you want.
16:48:44 <drlion> as opposed to map (\x -> foo x) bar
16:48:58 <Pseudonym> bindthird f z = \x y -> f x  z
16:49:09 <phubuh> Do you consider the C++ code `map (foo, bar)' where foo is a function and bar is a list to use currying?
16:49:12 <Pseudonym> Then you use (bindthird f 3) or whatever.
16:49:27 <Pseudonym> Very much like the STL/boost functional binders.
16:50:09 <Pseudonym> phubuh: No, but std::bind1st(map, foo) is kind of like currying.
16:50:16 <Pseudonym> Kind of.
16:50:43 <phubuh> Well, yes.
16:51:14 <Pseudonym> In general, support for closures give you pretty much everything that you'd otherwise want from currying.
16:59:34 <drlion> is  f _ _ z === \x y -> f x y z  such a bad idea?
16:59:53 <Pseudonym> Uhm... probably, yes.
17:00:00 <drlion> it doesn't break up into ((f _) _) z, but does it really have to?
17:00:04 <Pseudonym> f (g _) x
17:00:07 <Pseudonym> What would that mean?
17:00:10 <drlion> nothing
17:00:35 <drlion> you can't have trailing _'s. or perhaps they would add nothing, so that f _ === f
17:00:57 <Pseudonym> OK, what about this:
17:01:00 <Pseudonym> f (g _ y) x
17:01:28 <drlion> that's f (\z -> g z y) x
17:01:39 <Pseudonym> Not \z -> f (g z y) x?
17:01:54 <Pseudonym> OK, that's why it's bad, then.
17:02:11 <Pseudonym> (f _ x) y would be different from (f _ x y)
17:02:49 <dark> This is a bit of a sidetrack, though.
17:02:56 <drlion> yes, but you can always see that immediately, can't you?
17:03:22 <dark> (`f` x) is different from (f x)
17:03:26 <drlion> i mean the code will always look like that, it's not like part of it can be abstracted away and cause major confusion
17:03:34 <dark> drlion suddenly switched from operators to functions.
17:04:54 <dark> Also (`f` x) y is already different from (`f` x y)
17:05:26 <Pseudonym> Well, (`f` x y) is a syntax error.
17:06:43 <dark> Is it?  I assumed it translates to f (x y)
17:06:51 <Pseudonym> Ah, so it does.
17:06:53 <Pseudonym> My bad, yes.
17:06:56 <dark> Er, \z -> f z (x y)
17:07:05 <dark> My confusion thus demonstrating that this is a bad idea :)
17:07:11 <Pseudonym> :-)
17:07:29 <dark> Writing `f` in a section is perverse anyway.
17:07:47 <Pseudonym> drlion: I think you'd have to make a case that it is an improvement on what we have now.
17:07:49 <dark> ... though I vaguely remember actually using it in a few places.
17:08:03 * Pseudonym runs away very fast from dark's code
17:10:09 <dark> Pseudonym: What's wrong with it?  It compiles and runs!
17:10:26 <Pseudonym> If you don't understand your own code, I ain't touching it.
17:10:53 <dark> I thought that's why we had type inference.
17:11:03 <dark> ghc tells me when my code is wrong, so why should I understand it?
17:11:11 <Pseudonym> Good point.
17:11:28 <Pseudonym> Once you've satisfied the byzantine whims of the type checker, your code is perfect.
17:11:43 <Pseudonym> Well, if GHC is happy with it, I guess I'm happy.
17:12:41 <Igloo> undefined: The programmers best friend
17:13:17 <Pseudonym> Yup.  Just remember not to evaluate it and you'll be fine.
17:13:22 <Igloo> s/s/'s/
17:17:25 <drlion> Pseudonym: it think it would provide a useful abstraction. currently, some argument places are more valuable than others, but often several logical arguments have the same importance
17:20:37 <drlion> let's face it: people don't think of multiple-argument functions as taking one argument at a time and returning new functions. that's just how it's implemented. and we already have syntax for defining multiple-argument functions, so why shouldn't the syntax for calling them be equally supportive?
17:26:32 <Pseudonym> Well, for the reason that you say, I think.  Currying is just how it's implemented.
17:26:34 <Pseudonym> There may be an argument for named functions, of course.
17:26:36 <Pseudonym> Sorry, named arguments/.
17:26:40 <Pseudonym> And GHC has implicit arguments, which may or may not help.
17:26:56 <Pseudonym> My take on this is that there are so many ways to do it now, another doesn't really make the language any more expressive.
17:28:44 <drlion> well, neither does \x y -> ... as opposed to \x -> \y -> ..., and a ton of other syntatic sugar
17:30:50 <Pseudonym> I agree with you there.
17:30:54 <drlion> in fact, haskell itself doesn't even make the computer any more expressive :-)
17:30:58 <Pseudonym> No, I disagree.
17:31:00 <drlion> oh, how so?
17:31:00 <Pseudonym> "More expressive" is the quality which makes it easier to get to the same functionality.
17:31:09 <Pseudonym> With the proviso that said functionality must be useful.
17:34:19 <Pseudonym> There's no point, for example, providing easy access to the Pentium F00F bug in your language.
17:34:19 <drlion> but by that definition, \x y -> ... does make the language more expressive
17:34:22 <Pseudonym> Only marginally.
17:34:37 <drlion> okay, i see what you mean
17:34:39 <Pseudonym> In fact, I wouldn't be too sad if the \x y -> syntax went.
17:34:40 <Pseudonym> Except that it's in the standard already.
17:34:59 <drlion> but don't you agree that it would be best to either not support multiple-argument functions at all (throw out \x y -> ...) or provide an as complete and symmetric support for them as possible?
17:35:42 <Pseudonym> Well, \x y -> doesn't provide multiple-argument functions.  It's just a shorthand for \x -> (\y -> ... )
17:35:42 <ozone> dark: named arguments are a great thing
17:35:45 <Pseudonym> Just like how -> in C/C++ doesn't really provide additional functionality over . and *.
17:35:50 <Pseudonym> (Except that in C++ you can overload it separately from *).
17:36:10 <Pseudonym> (We'll ignore that complication.)
17:37:18 <drlion> i disagree. \x y -> z is something conceptually separate from \x -> \y -> z
17:38:07 <Pseudonym> Maybe we'll have to agree to disagree on this.
17:38:34 <dark> You could always duel to the death.
17:38:42 * Pseudonym throws down a gauntlet
17:39:15 <phubuh> I would use \x -> \y -> z if my function was explicitly a function generator, and \x y -> z if my function was just a regular two-argument function that happens to become curried when compiled.
17:39:49 <Pseudonym> Absolutely.
17:40:04 <Pseudonym> From a documentation point of view, the difference is useful.
17:40:19 <phubuh> Because of the conceptual difference between \x y -> z and \x -> \y -> \z. :-)
17:40:51 <Pseudonym> OK, this is like the conceptual difference between a class and a struct in C++.
17:41:02 <Pseudonym> Two keywords for what is basically the same thing.
17:41:34 <phubuh> Yeah, but struct implies dumb data container, while class implies smart object.
17:41:37 <dark> Oh, now I remember where I used sections with `f`
17:41:42 <drlion> haha, yes
17:41:49 <dark> It was something like filter (`isPrefixOf` foo) 
17:42:13 <dark> Confusion was avoided because of the name of the function :)
17:43:13 <Pseudonym> Lunch.  BBIAB
17:43:18 <phubuh> The name of that function is -very- confusing when you don't use it with ``.
17:43:34 <dark> phubuh: Yeah.  It's designed for it :)
17:43:46 <drlion> "sections" meaning "partial application"?
17:43:58 <dark> drlion: The (+ 1) notation is called a section.
17:44:01 <phubuh> Partial application of an operator, specifically.
17:44:11 <drlion> ah
17:44:24 <dark> I have no idea where the term comes from.
17:45:19 <crass> I'm wading through the ghc make system, and I can't seem to find where it determines which object need to be linked to make a spcific binary, any pointers?
17:56:05 <dark> I just know how it works from the outside, not how it's implemented.
18:19:01 <ozone> dark: i'm sure it's stolen from category theory like most things in types/functional languages ;)
