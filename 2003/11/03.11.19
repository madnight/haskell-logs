07:14:50 --- topic: '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","lots of cool debs in the haskell-experimental archive - see http://www.syntaxpolice.org/haskell-experimental/haskell-experimental.html","new HC&A Report - http://www.haskell.org/communities/","Any user who would like to request any unwritten tutorial please msg shapr"]'
07:14:50 --- topic: set by Pseudonym on [Mon Nov 17 15:43:01 2003]
07:14:56 <shapr> yay, clog is back
07:15:20 <Lunar^> SyntaxPolice: I think so
07:16:14 * SyntaxPolice really likes the ghc warnings, especially the one that tells me about stale imports
07:16:51 <shapr> type error slicing (and System E) looks very spiffy
07:16:55 <Igloo> Are you in the second one, Syn?
07:17:14 <shapr> SyntaxPolice: have any more funny pix?
07:17:40 <SyntaxPolice> Igloo: no, I'm not in the 2nd one. i'm taking the picture
07:17:46 <SyntaxPolice> those are all hackers, except for the female
07:17:47 <Igloo> That's OK then  :-)
07:17:51 <Igloo> Pity
07:17:55 <SyntaxPolice> indeed.
07:17:58 <SyntaxPolice> she's pretty cool anyway, though :)
07:18:05 <Igloo> :-)
07:18:09 * shapr grins
07:18:13 <phubuh> mm, pop corn
07:18:30 <phubuh> those indians were on to something
07:18:34 <SyntaxPolice> oh, btw, there's a pumpkin in the picture which is carved like an amobea with eyes
07:18:36 <phubuh> it's so cheap, I could live entirely off of it
07:19:19 <SyntaxPolice> shapr: http://www.syntaxpolice.org/pics/halloween2003/1.html
07:19:24 <shapr> I've decided the best Bond film ever is Long Kiss Goodnight
07:19:25 <SyntaxPolice> that punk is an EE hacker (and a female)
07:19:39 <shapr> wow, neat
07:20:56 <Igloo> Why does your caption go backwards?
07:21:09 <shapr> yah, I was curious about that too
07:21:30 <SyntaxPolice> I don't know. I think that I was avoiding pat because I didn't know his name at first
07:21:41 <Igloo> Heh
07:22:04 <SyntaxPolice> btw, I wrote a haskell program to show me the pictures, ask me for a category and a date and a caption, resize them, rename the files tos omething meaningful, and run igal on them :)
07:23:21 <shapr> spiffy
07:28:35 <shapr> hi anduril1
07:49:33 <andersca> shapr of ipv6 fame
07:49:49 <shapr> oh, did it work?
07:50:00 <shapr> w00h00!
07:50:06 <andersca> --> shapr (~user@3ffe:bc0:8000:0:8000:0:d9d3:cde8) gick in i #haskell
07:50:17 * shapr bounces cheerfully
07:52:26 <shapr> cool, I'll set this up as my default then.
07:52:52 <shapr> I'm tempted to switch our internal network over to IPv6 entirely, since we're doing NAT anyway
07:53:08 <shapr> plus that would allow our office and home computers to talk to each other much more simply.
07:54:12 <dennisb> so, where do you get the ipv6 adresses? same as ipv4 plus some more?
07:54:51 <shapr> freenet6 hands them out, but IPv6 has support for a standard translation of  IPv4 + extra to IPv6
07:55:14 <shapr> now I wonder.. does GHC support IPv6?
07:56:03 <shapr> hej andersca_!
07:56:09 <shapr> du har ipv6 ocksa!
07:56:48 <andersca_> ja
07:56:53 <ski> IPv6 ?
07:57:34 <ski> extended IP ?
07:58:00 <shapr> TCP/IP version 6
07:58:10 <shapr> the current widely used version is 4
07:58:21 <ski> 'k
07:58:23 <dennisb> does rh9 handle it directly?
07:58:31 <andersca> just like leisure suit larry there is no version 5
07:58:32 <andersca> dennisb: sure
07:58:42 <dennisb> then it's time to get connected
07:58:42 <shapr> I don't know, I built a custom kernel with IPv6 as a module
07:58:45 <andersca> dennisb: just add NETWORKING_IPV6=yes to your /etc/sysconfig/redhat
07:58:45 <shapr> yah!
07:59:13 <shapr> and then connect to irc.ipv6.eu.freenode.net
07:59:15 <andersca_> riktig ipv6
07:59:49 <dennisb> so how does the routing work, just because I get a adress does not mean I will get any ip-packages
08:00:48 <andersca> dennisb: I dunno, I'm connected to a real ipv6 network
08:01:01 <andersca_> la la la
08:02:28 <shapr> I installed freenet6
08:02:53 <shapr> the deb has scripts that connect you to freenet6.org, requests an address, etc
08:05:23 <shapr> andersca: how did you get onto a real ipv6 network?
08:05:39 <dennisb> andersca: /etc/sysconfig/what you said?
08:05:41 <andersca> shapr: our student network supports it
08:05:45 <andersca> dennisb: networking
08:05:56 <andersca> oh wait
08:05:57 <andersca> network
08:06:27 <shapr> andersca: jättekul
08:18:44 <shapr> andersca: is your student network connected to the 6bone?
08:18:55 <andersca> dunno, gonna ask
08:18:57 <andersca> but now pizza
08:19:06 <shapr> I wonder if there are any ipv6 native chunks of the 'net
08:19:11 <shapr> or if it's still all tunneled
08:20:32 <norpan> sure there are
08:20:56 <norpan> 6net
08:21:04 <norpan> and 6bone
08:22:12 <shapr> I found 6bone...
08:22:26 <norpan> 6net.org
08:24:45 <sex|more> hi folks
08:24:51 <ski> hi
08:24:53 <shapr> hiya
08:24:54 <TripleDES> hi
08:25:06 <shapr> hmm, swipnet has some ipv6 addresses...
08:25:19 <sex|more> I have some other nice haskell to do :D
08:25:24 <shapr> bredbandsbolaget just installed a box in our house...
08:25:26 <shapr> I wonder...
08:27:52 <shapr> *kalix* has an ipv6 network???
08:28:20 <shapr> oh! luth has one!
08:33:03 <shapr> hm, so does telia
08:38:47 <sex|more> I have some haskell-related question
08:38:50 <sex|more> one
08:39:10 <ski> yes ?
08:39:25 <sex|more> I have a list: [1,2,3,4,5]
08:39:37 <sex|more> I want to add up the numbers that way
08:39:53 <sex|more> 1 + 2, 1 +3, 1 +4, 1+ 5
08:39:54 <sex|more> 2nd
08:39:55 <ski> to 15 ?  or to 12345 ?
08:40:07 <sex|more> 2 + 3, 2+4,2+5
08:40:09 <sex|more> and so on
08:40:13 <ski> ok
08:40:31 <ski> add each possible pair of numbers, i.e., right ?
08:40:39 <sex|more> yes
08:40:52 <sex|more> but with recurring preds
08:41:00 <ski> ok
08:41:01 <sex|more> no 2 + 1
08:41:05 <sex|more> because I did it already
08:41:08 <ski> ok
08:41:45 <ski> have you written any code to try to solve this yet ?
08:42:19 <sex|more> sure, my problem is I don'T know how to skip
08:42:23 <ski> (or have you any idea how to start ?)
08:42:29 <ski> ok
08:42:47 <sex|more> hold on!
08:43:03 <ski> skip the numbers between the first and the second selected ?
08:43:05 <sex|more> my idea is, to write a funktion which
08:43:12 <sex|more> does the following
08:43:57 <sex|more> take 1st: add second, take 1st again add third, take 1st add fourth
08:44:18 <sex|more> every vaule should be an element of a list
08:44:36 <ski> mm
08:44:40 <sex|more> then take 2nd and add third, take second and add fourth
08:44:43 <sex|more> got my point?
08:45:41 <sex|more> is there any funktion not take which takes out the first element of a list?
08:45:44 <ski> sort of, i think
08:46:05 <ski> @type head
08:46:07 <lambdabot> head :: [a] -> a
08:46:15 <Smerdyakov> @type tail
08:46:17 <lambdabot> tail :: [a] -> [a]
08:46:23 <Smerdyakov> I guessed it!
08:46:52 <ski> but it is often easier to use pattern matching to get the head and tail of a list
08:47:51 <sex|more> I can descibe you my whole task I have to implement
08:48:05 <sex|more> if you like
08:48:43 <ski> so is this function supposed to be part of a solution to a bigger problem .. ?
08:49:18 <sex|more> yes
08:49:20 <ski> but perhaps we should concentrate on this one first, yes ?
08:49:28 <sex|more> itis
08:49:42 <sex|more> sure, I want you to get the scope of it
08:50:31 <sex|more> I hope you are familiar with backtracking :d
08:50:48 <ski> so what should your functions name be ?  sumOfAllPairs  ?
08:51:17 <sex|more> the name isn't important, important is that it works :d
08:51:21 <ski> sex|more : have you used Prolog (or other logic prog.lang.) before ?
08:51:38 <sex|more> no
08:51:39 <sex|more> why?
08:51:46 <sex|more> haskell is my frist one
08:51:48 <sex|more> first
08:51:56 <ski> yes, but we have (well, almost) to invent a name for it to be able to implement it
08:52:12 <sex|more> the call it that way
08:52:13 <sex|more> atn = [1..3]
08:52:13 <sex|more> paare atn = [ x+y | x <- atn, y <- atn]
08:52:18 <sex|more> I have this one
08:52:20 <ski> sex|more : because you asked about backtracking
08:52:34 <sex|more> but the problem is, it starts over
08:52:36 <ski> sex|more : and, btw, yes i know backtracking
08:52:56 <sex|more> I get 2 + 1 ord 2 + 2 hwich I don't need
08:53:17 <ski> are you required to implement it using recursion ?  or can you use list comprehensions ?
08:53:35 <sex|more> no requierments given
08:53:39 <sex|more> I can do how I want
08:53:45 <ski> ok
08:54:21 <ski> well, your list compr. above first selects an x from atn, then selects an y from atn
08:54:37 <sex|more> yes, I know
08:54:45 <ski> i think you want the y to be selected from the rest of the list after x, no ?
08:54:55 <sex|more> yes!
08:55:23 <sex|more> set y >x?
08:55:59 <ski> hmm, i forgot, should the list [1,2,3] generate [1+1,1+2,1+3,2+2,2+3,3+3] ?  or only [1+2,1+3,2+3] ?
08:56:07 <ski> no
08:56:49 <sex|more> it should do: [1+2,1+3,2+3]
08:57:08 <sex|more> it should do: [1+2,1+3,1+4,2+3,2+4,3+4]
08:57:46 <ski> that ("set y >x") wouldn't work with the list [1,4,2,8,5,7] e.g.  (I'm assuming that you want it to work the same, regardless the actual relative sizes of the numbers)
08:58:12 <sex|more> atn = [1..5]
08:58:12 <sex|more> paare atn = [ x+y | x <- atn, y <- atn, y > x]
08:58:22 <sex|more> Main> paare atn
08:58:22 <sex|more> [3,4,5,6,5,6,7,7,8,9]
08:58:22 <sex|more> Main> c
08:58:39 <ski> ok, so y isn't allowed to be the same element as x, only a later one, right ?
08:58:46 <sex|more> hold on!
08:58:52 <sex|more> this is the solution I need!
08:58:54 <ski> sure
08:59:04 <sex|more> it works
08:59:33 <pimpbot5000> hi, is anyone one familiar with GHC optimizations, and how to selectively turn them off in code?
08:59:54 <pimpbot5000> ie. i want to turn off this optimization:
09:00:04 <pimpbot5000> let x = alloc n z
09:00:09 <pimpbot5000> let y = alloc n z
09:00:11 <ski> sex|more : so paare [3,1,2] isn't supposed to become [3+1,3+2,1+2], then ?
09:00:20 <pimpbot5000> x and y share the same reference
09:00:42 <sex|more> [3,1,2] isn't allows
09:00:48 <sex|more> the list runs from 1..n
09:01:00 <sex|more> no other possibilties
09:01:56 <sex|more> allowed*
09:02:10 <ski> ok
09:02:35 <ski> then your solution is right, of course  (and easier than the one i had in mind ;)
09:02:50 <sex|more> Main> paare atn
09:02:51 <sex|more> [3,4,5,6,5,6,7,7,8,9]
09:02:51 <sex|more> Main> c
09:02:58 <sex|more> this is the proper list
09:03:15 <sex|more> now my task is use backtraking, let me explain...
09:03:41 <sex|more> those numbers are just the sums of the algorithm I have explained before
09:03:56 <sex|more> you see some numbers appear twice
09:04:49 <sex|more> can follow me by now?
09:05:41 <sex|more> can follow me by now?
09:05:51 <sex|more> sorry, wrong button :D
09:06:06 <ski> pimpbot5000 : so ?  you want x and y to not be merged ??
09:06:39 <ski> i thought you meant the list comprehensions by backtracking ...
09:07:01 <sex|more> now the backtracking part appears
09:07:10 <sex|more> take as first the list 1..3
09:07:22 <sex|more> no number after the funk is twice
09:07:23 <sex|more> good
09:07:29 <sex|more> then take 1..4
09:07:41 <sex|more> oh oh, some numbers are twice
09:07:47 <sex|more> delete the 4 from the list
09:07:52 <sex|more> and use 1,2,3,5
09:07:55 <sex|more> check this
09:07:58 <sex|more> no twice
09:08:02 <sex|more> then 1,2,3,5,6
09:08:05 <sex|more> some twice
09:08:08 <sex|more> kick 6
09:08:13 <pimpbot5000> ski: yes, im hoping there is some pragma that allows me to force the uniqueness of x an dy 
09:08:17 <pimpbot5000> x and y
09:08:19 <sex|more> then 1,2,3,5,6
09:08:21 <sex|more> and so forth
09:08:43 <sex|more> I have to eliminate all numbers out of my list which cause twice results
09:09:47 <sex|more> at the end I want to have a funk: goodnumbers atn = gives me the list with the numbers which do not prodcue twice results
09:10:07 <ski> pimpbot5000 : perhaps NOINLINE in ghc (doc 7.7.2) ??
09:10:43 <pimpbot5000> hmm, this is possible...ill check into it more
09:10:53 <pimpbot5000> but is that really what's causing the shared reference?
09:11:04 <pimpbot5000> im not even sure which optimization is responsible
09:11:22 <ski> sex|more : wait a little, i'll have to parse through all your text first :)
09:11:27 <sex|more> k
09:11:32 <sex|more> if questions, ask!
09:11:44 <ski> pimpbot5000 : i dunno, actually
09:12:18 <pimpbot5000> do any GHC people show up here?
09:12:31 <pimpbot5000> ie, people coding GHC
09:12:59 <sex|more> brb in 5 min
09:13:40 <shapr> pimpbot5000: sure
09:13:53 <ski> sex|more : is your list input to paare always gonna be sorted ascending ?  or perhaps also always contiguous ?
09:14:00 <ski> sex|more : 'K
09:14:06 <sex|more> back
09:14:14 <sex|more> which list do you mean?
09:14:21 <sex|more> the input list?
09:14:24 <ski> the input list to paare
09:14:29 <ski> atn in your code above
09:14:45 <sex|more> always ascending [1..10] for example
09:14:58 <ski> and always contiguous ??
09:15:18 <sex|more> good question
09:15:28 <sex|more> the point is how to handle my problem
09:15:29 <pimpbot5000> shapr: do you work on GHC?
09:15:33 <pimpbot5000> hehe
09:15:36 <shapr> not me
09:15:43 <shapr> my haskillz are too weenie
09:15:56 <shapr> but others here do work on GHC
09:16:00 <sex|more> actually I have to parse the list and then kick all numbers which cause twice results
09:16:02 <pimpbot5000> hehe, after looking at GHC, ill say the same for me
09:16:12 <sex|more> understand
09:16:19 <sex|more> or do you want an example?
09:16:34 <ski> sex|more : 'cuz if it is always gonna be contiguous we could just as well pass around a pair of the min and max number in the list (i.e. first and last one)
09:17:28 <sex|more> or do you want an example to understand me?
09:18:05 <ski> you can make an example if you like ..                    ;)
09:18:20 <sex|more> let's start:
09:18:45 <sex|more> paare [1..3] = [3,4,5]
09:18:56 <sex|more> looks great, no twice numbers on the right
09:18:56 <ski> yes
09:19:26 <ski> is [1,2,6,7], e.g., a legal input to paare ?
09:19:42 <sex|more> the console gives me [1..3] back, means this numbers do not produce twices!
09:19:44 <sex|more> yes
09:19:50 <sex|more> let me explain forth
09:20:19 <sex|more> then use: paare [1..4] = [3,4,5,5,6,7]  
09:20:24 <sex|more> thi is bad
09:20:32 <sex|more> 4 causes twice results
09:20:36 <sex|more> means, delete the 4
09:21:05 <sex|more> then paare [1,2,3,5] = [3,4,6,5,7,8] 
09:21:12 <sex|more> great, no twices
09:21:31 <sex|more> then paare [1,2,3,5,6] = [3,4,6,7,5,7,8,8,9,11]  
09:21:35 <sex|more> bad twice numbers
09:21:37 <sex|more> kill 6
09:21:48 <ski> there is a library function which removes all duplicates from a list, are you allowed to use such a thing ?  or do you have to (or want) to write a similar function yourself ?  (or solve the prob. in another way ..)
09:22:05 <sex|more> then paare [1,2,3,5,6,7] = ...
09:22:26 <sex|more> well in this class I am allowed to use them
09:22:31 <ski> "kill 6" ?
09:22:44 <sex|more> but I would  like rather do understand how that works
09:22:45 <ski> do you want to ?
09:22:59 <sex|more> and write that on my own if I am capable of :d
09:23:02 <sex|more> hold on
09:23:06 <ski> mm
09:23:24 <sex|more> then result is, that only the fibonacci numbers are a eligible input for paare
09:23:54 <ski> err, i can't parse you ..  "then result is .." ??
09:24:10 <sex|more> the last funk takes [1...100] filter, filters -> fibonacci
09:24:21 <sex|more> paare [1,2,3,5,6,7]
09:24:21 <sex|more> [3,4,6,7,8,5,7,8,9,8,9,10,11,12,13]      
09:24:25 <sex|more> just replaced
09:27:29 <sex|more> understand now?
09:28:41 <ski> i have a little trouble understanding some of your utterances, but yes, i think i understand what you want paare to do
09:29:51 <sex|more> paare doesn't have to do all the work but the part it had to do it has done already -> the proper addition
09:30:13 <sex|more> now the next funk should filter out the numbers out of the main list
09:30:21 <sex|more> and here I have absolutely no idea
09:30:21 <ski> so, hmm, i think it would be easiest if you just wrote a function for removing all duplicates from a list, and then having paare pass the list comprehension to that function, in order to remove you much-a-hated duplicates. what do you think ?
09:30:34 <ski> yes
09:30:50 <ski> so ... think recursively
09:31:16 <sex|more> but all I get is the output list without the doubles, this is not really my intention
09:31:18 <ski> e.g. how do you filter out all duplicates from an empty list (the simplest case) ?
09:31:29 <ski> ??
09:31:43 <ski> waht do you mean ?
09:31:54 <ski> s/waht/what/
09:32:06 <sex|more> the output list is just the indicator that the input is not right
09:32:10 <sex|more> here look:
09:32:46 <sex|more> output: [3,4,6,7,8,5,7,8,9,8,9,10,11,12,13]   -> input: [1,2,3,5,6]
09:32:50 <sex|more> causes bad input
09:33:02 <sex|more> which results to double numbers
09:33:17 <sex|more> solution: delete 6 and go on with 7
09:33:29 <ski> but you said above you get the output list *without* the duplicates ??
09:33:44 <ski> yes
09:33:48 <sex|more> input [1,2,3,5,7] -> output [3,4,6,7,8,5,7,8,9,8,9,10,11,12,13]    
09:34:02 <sex|more> either I wrote the wrong one or you misunderstood me
09:34:27 <sex|more> I want to ban all numbers out of the input, which CAUSE double numbers in the output
09:34:50 <sex|more> like the 6 and the 7
09:34:55 <sex|more> the go on with the 8
09:34:57 <sex|more> which is fine
09:35:02 <sex|more> and so forth
09:36:40 <ski> so you want to remove numbers from the input list such that no duplicates arise in the output list ?  (as opposed to, say, filtering duplicates from the output list, after having generated it with the list compr. in paare)
09:36:51 * shapr chortles merrily
09:37:09 <sex|more> exactöy!
09:37:16 <sex|more> exactly!
09:37:29 * ski chewes on his fingers
09:37:35 <ski> ok
09:38:00 <sex|more> good
09:38:00 <ski> that approach seems harder (i.e. requires more thought :)
09:38:34 <sex|more> I know, I have to do it the recursive way and to use some buffer for the new input
09:39:35 <sex|more> I suppose I do not have enough knowledge of haskell to do so
09:41:10 <ski> my idea was writing something along the lines of :
09:41:32 <ski> paare atn = removeDuplicates [ x+y | x <- atn, y <- atn, y > x]
09:42:38 <ski> so removeDuplicates gets the output list *with* duplicates, and gives us back an output list *without* duplicates, which we promptly just return as the result of paare
09:42:56 <ski> what do you think of this idea ?
09:43:29 <diminished> *BSD is for old people!!
09:43:40 <shapr> hey!
09:43:44 <shapr> I'm old, but I'm using Linux.
09:43:54 <sex|more> ok, got you!
09:43:54 <diminished> thats not the point ;]
09:44:02 <sex|more> and what would be the benefit doing so?
09:44:08 <Igloo> emacs sux!
09:44:13 <sex|more> with the filtered output?
09:44:14 <diminished> vim rulez!
09:44:19 <shapr> Igloo: curly braces suck!
09:44:32 <diminished> curly braces are cool!
09:44:32 <Igloo> tabs are for loozers!
09:44:41 <diminished> tabs are pretty ok
09:44:55 <sex|more> ok, stop spamming us!
09:45:07 <diminished> <- ?
09:45:20 <ski> sex|more : well, it seems harder, to me at least, to figure out which (if possible at all) numbers in the input list to remove to get the same output as before, except no duplicates this time ..
09:45:55 <shapr> Igloo: amusingly, the founder of #java has a ritual greeting when he sees me on the channel
09:46:09 <shapr> he says "whitespacesucks!" and I say "curly braces suck!"
09:46:14 <Igloo> :-)
09:46:22 <ski> :)
09:46:41 <sex|more> hmm, damn so you have no real idea to get out the fibonacci numbers at the end?
09:47:17 <ski> hmm, you want to get fibonacci numbers ??
09:47:34 <sex|more> they are the result of this app
09:47:42 <sex|more> the get them by doing what I said!
09:47:52 <ski> how is paare related to fibonacci numbers ?
09:48:29 <sex|more> look, if you keep filtering my input list you will see that the only numbers which remain are fibonacci
09:48:32 <ski> ok, then i suppose i just hasn't got how you intend to use this to compute fibonacci numbers
09:48:33 <sex|more> this is the point
09:48:53 <ski> (i would use a completely different approach, i think ..)
09:49:03 <ski> hmm
09:49:06 <sex|more> fib n = fib (n-1) + fib (n-2) won't do
09:49:08 <sex|more> and which one?
09:49:24 <ski> just by filtering away duplicates ?
09:49:45 <sex|more>  I don'T think this is the solution
09:49:52 <sex|more> like I meantioned
09:49:55 <shapr> 2001:200:0:8002:203:47ff:fea5:3085
09:49:55 <shapr> whoops
09:49:55 <shapr> fib = 1 : 1 : zipWith (+) fib (tail fib)
09:49:57 <ski> why wouldn't something like that do ?   (trying to understand how you think/what you want, here)
09:50:26 <sex|more> why?
09:50:31 <sex|more> pretty easy
09:50:41 <ski> shapr : s/1 : 1 :/0 : 1 :/
09:50:53 <sex|more> my task is to figure out which system is the best not to get duplicates
09:51:10 <sex|more> and it is required to use this filtering method to get fibonacci
09:51:20 <ski> mhmm
09:51:34 <sex|more> the output list is just an indicator wether my last number in the input is ok or not!
09:51:44 <ski> i still don't get how this would give fibonacci numbers .. :(
09:52:09 <sex|more> easy
09:52:15 <sex|more> take this one paare atn = [ x+y | x <- atn, y <- atn, y > x]
09:52:24 <shapr> er, right
09:52:25 <sex|more> and use for atn first [1,2,3]
09:52:27 * ski exclaims "jaha ??"
09:52:29 <sex|more> ok?
09:52:40 <sex|more> then you see no dubs?
09:52:42 <sex|more> right?
09:53:14 <ski> that would yield [3,4,5], right ?
09:53:19 <sex|more> yes
09:53:27 <sex|more> and no dublicates are in!
09:53:30 <sex|more> then let's go on
09:53:31 <ski> so that gives ... ?   what ?  that 3 is a fibonacci number ??
09:53:33 <shapr> diminished: I don't use java, not in the last six month or so
09:53:40 <sex|more> wait
09:53:43 <sex|more> let me go on!
09:53:48 <ski> sure
09:53:58 <shapr> diminished: so my curly braces come from dictionaries in Python and records in Haskell
09:54:02 <sex|more> paare [1,2,3,4] = list with doubles
09:54:21 <sex|more> means 4 is a number which produces doubles -> kick 4 and go on
09:54:37 <sex|more> paare [1,2,3,5] = no doubles -> 5 is good, go on to 6
09:54:58 <ski> so you say :  if paare [1..n] contains no duplicates, then n is a fibonacci number ?  is that waht you say ?
09:55:05 <sex|more> paare [1,2,3,5,6] = doubles -> 6 is not good, kick 7, go on to 8
09:55:07 <ski> what
09:55:39 <sex|more> yes, if the out put list has no doubles you input list are the fibo numbers
09:55:52 <sex|more> try paare [1,2,3,5,8,13,21]
09:56:01 <sex|more> you won't get doubles
09:56:32 <diminished> shapr: hah .. i see
09:56:49 <ski> hmm, ah, your input list to paare is all previously found fibonacci numbers + a extra one which we wanna know if it is a fibonacci number, right ?
09:57:14 <sex|more> yes
09:57:31 <sex|more> from paare [1..21] only the fibos are valid numbers
09:58:45 <ski> so ..  do you want to write a function that gives the nth fib. number ?  or the n first such numbers ?  or all fib. numbers smaller (or equal to) n ?  or perhaps the (infinite) list of all fib. numbers (from 0 and onwards) ?
09:58:52 <shapr> diminished: so, you learning Haskell?
09:59:34 <ski> sex|more : so you wouldn't actually pass [1..21] to paare, but rather [1,2,3,5,13,21], yes ?
09:59:48 <ski> s/[1,2,3,5,13,21]/[1,2,3,5,8,13,21]/
10:00:02 <sex|more> I want a funk which filters from [1..100] all invalid numbers with the algo I said
10:00:18 <sex|more> no, that's not quite my intentio
10:00:49 <ski> ok, hmm
10:00:54 <sex|more> I pass [1..21] after all caclations haskell tells me that only  [1,2,3,5,13,21] are good numbers
10:01:23 <sex|more> the output list we had is no interest for me, it is just for internal indication
10:01:23 <ski> what was not your intention ?  (passing [1,2,3,5,8,13,21] to paare, rather than [1..21] ?)
10:01:50 <sex|more> vice versa
10:02:10 <sex|more> passing [1..21] and get at the end out  [1,2,3,5,13,21]
10:02:17 <ski> but surely, if you pass [1..21] to paare, you will still get duplicates ?  (1+4 and 2+3 e.g.)
10:02:29 <sex|more> this is the result of the whole computation
10:03:00 <sex|more> yes and threreof I use my algorith which detects that and deletes all numbers which cause that
10:03:41 <sex|more> I start with 1 go on with 2...3....4.(bad kill)...5....6.(bad kill)....7.(bad kill)...8...
10:03:42 <diminished> shapr: nope
10:04:31 <sex|more> I can solve this taks in words for my corrector but it is better to have a real computation!
10:04:59 <ski> yes (and often a little bit trickier)
10:06:40 <sex|more> you see any approach on my problem with the algorith descibed above?
10:07:34 <ski> so, you'll begin with passing [1] to paare, right ?  and of course we get no duplicates, so we pass [1,2], still ok .. [1,2,3] ok ... [1,2,3,4] not ok, so we don't include 4 in the following tests ... [1,2,3,5] ok ... [1,2,3,5,6] not ok ... [1,2,3,5,7] not ok ... [1,2,3,5,8] ok ... and so on      do you wanna do something like this ?
10:08:05 <sex|more> EXACTLY!!!
10:08:55 <ski> ok, that means that you do *not* want to pass [1..21] to paare, but rather [1,2,3,5,8,12,21], am i right ?
10:09:07 <ski> s/12/13/
10:09:27 <sex|more> hmmm
10:09:50 <sex|more> let's say I have a funk which does all that and gives me latter bacl
10:09:57 <ski> i.e. you only pass already accepted fibonacci numbers + an extra one to test, to paare, right ?
10:10:07 <sex|more> so I put in [1..21] in and get back [1..fibo21]
10:10:45 <sex|more> no, I pass all contiguous numbers and  paare determines wich are ok!
10:11:02 <sex|more> let's assume that we do not know fibo
10:11:07 <ski> i'm not exactly sure what your top function (or perhaps main function) is gonna look like..  you mentioned something with [1..100] previously ..
10:11:30 <sex|more> yes and it files all fibo numbers out of
10:12:04 <ski> yes, but i was speaking more about an internal function (doing the loop work i tried to describe above)
10:12:43 <ski> (internal, as in my head, as well as to the algorithm ..)
10:12:43 <sex|more> then you are right
10:12:53 <sex|more> yes!
10:15:02 <ski> so, wouldn't it be easier if the top function got, say 100 as argument, and was just required to return a list of all fib. numbers from 1 upto 100 ?  or are you required to accept a list of numbers (e.g. [1..100]) ?  in the latter case waht should happen if someone passes, e.g., [10..100] to the top function ?
10:15:29 <ski> or [10,20..100] ?
10:16:20 <sex|more> this won't happen, you are allowed to pass [1..n] only
10:16:26 <ski> ok
10:16:46 <ski> it just seems easier to me to just pass n in that case
10:16:54 <sex|more> but everything in compliance with the algo given, I think you got the algo
10:17:02 <sex|more> well you can do [100..1]
10:17:09 <sex|more> and reverse the final list then!
10:17:10 <ski> no, you can't
10:17:37 <ski> you'd have to change "y>x" to "y,x" for that to work, i think
10:17:47 <ski> (in the list comprehension)
10:17:52 <ski> aargh
10:18:05 <ski> s/"y,x"/"y<x"/
10:18:22 <sex|more> well, do how you think it's right
10:18:30 <ski> ?
10:18:50 <sex|more> well, I have changed that and then?
10:19:15 <ski> what ?    (sorry, don't understand)
10:20:15 <sex|more> I have changed from y > x to y < x
10:20:20 <sex|more> the result is the same
10:20:56 <ski> hmm, well, it could possibly be better to have to fib. list reversed, at least internally, but i still don't know why you want to pass [1..100] to the top function, instead of, e.g. just 100 ..
10:22:22 <sex|more> ok, let's pass 100 what would the app do then?
10:23:41 <ski> well, i assume that the input number (100) is a limit, that determines when the above loop should stop, right ?
10:23:57 <ski> (assuming you want to stop, i.e.)
10:24:53 <ski> (one could imagine returning an infinite list of all fib. numbers from 1 and up ..)
10:26:39 <ski> there we go again ...
10:26:49 <sex|more> how to use EQ func?
10:27:03 <ski> do you mean == ?
10:27:20 <sex|more> Main> EQ 1 == 2
10:27:20 <sex|more> ERROR - Type error in application
10:27:20 <sex|more> *** Expression     : EQ 1
10:27:20 <sex|more> *** Term           : EQ
10:27:20 <sex|more> *** Type           : Ordering
10:27:21 <sex|more> *** Does not match : a -> b
10:27:23 <sex|more> Main>     
10:27:37 <ski> oh, that
10:27:42 <ski> EQ is not a function
10:27:47 <ski> @type EQ
10:27:48 <lambdabot> EQ :: Ordering
10:27:55 <ski> @type compare
10:27:56 <lambdabot> compare :: Ord a => a -> a -> Ordering
10:28:42 <sex|more> k
10:29:47 <ski> it is a value returned by compare (it tells that the first arg is equal to the second. LT and GT stand for "lesser than" and "greater than", respectively)
10:30:46 <sex|more> yeah
10:30:54 <sex|more> I have some other approach now
10:30:55 <Tomasso> is there any way to make hugs show all the reduction steps??
10:31:02 <sex|more> to relieve me from the work
10:32:11 <ski> Tomasso : not that i know of (unfortunately). (perhaps you can have some help from trace or observe)
10:32:22 <Tomasso> mhmhm
10:33:02 <ski> Tomasso : (DrScheme has a stepper for (a subset of) Scheme, though, IIRC)
10:34:19 <Tomasso> hmmh ski what do you mean?
10:35:59 <ski> Tomasso : see http://www.drscheme.org/tour/tour-Z-H-9.html#node_chap_8
10:36:18 <sex|more> ski: I have an other idea
10:36:25 <ski> ok
10:36:32 <sex|more> to cut the work dramtically
10:36:36 <shapr> diminished: you wanna learn Haskell?
10:36:51 <sex|more> let's say, I have this paare atn = [ x+y | x <- atn, y <- atn, y < x]
10:36:57 <ski> mm
10:36:58 <sex|more> gives me the output
10:37:05 <sex|more> with or without doubles
10:37:10 <sex|more> so far so good
10:37:19 <ski> yes
10:38:11 <sex|more> now I want to define a funk called twice which checks the output if the are doulbes, if there are in it returns "dirty" if no in return "clean"
10:39:28 <ski> wouldn't it be better to just return True or False
10:40:58 <sex|more> or that!
10:41:03 <sex|more> would be better!
10:41:56 <ski> you could call the function something like "hasNoDups" ...
10:42:20 <sex|more> yea
10:42:26 <ski> and then perhaps write something like  "if hasNoDups (blaha ...) then ... else ..."
10:42:43 <Tomasso> ski: let me check
10:43:13 <sex|more> well are there if else in haskell?
10:43:16 <sex|more> never used before
10:43:27 <ski> you can use guards too
10:43:32 <sex|more> my problem is, I cant get the comparsion right!
10:43:36 <ski> like
10:43:36 <sex|more> hold on
10:43:40 <ski> foo args ...
10:43:53 <ski>   | hasNoDups (blaha ...) = ...
10:43:58 <Tomasso> ski: is this program available for download?
10:44:00 <ski>   | otherwise = ...
10:44:07 <Tomasso> is its programming language haskell?
10:44:41 <ski> Tomasso : no it is Scheme. i think it is a part of the DrScheme distro (at least was, some time ago)
10:45:11 <Tomasso> mhhm what do you mean for its a scheme, its not implemented?
10:45:51 <sex|more> I want to do somethink like this: doppelt atn = [ True | x <- atn, y <- atn, x `div` y == 0]
10:45:51 <ski> Tomasso : no, it is the programming language called "Scheme" (which is a Lisp variant)
10:46:04 <sex|more> this code means
10:46:19 <Tomasso> oooooohh i see,,,
10:46:33 <Tomasso> what a pity there is no such a thing implemented for haskell
10:46:36 <sex|more> if there is at least a 0 as result the otuput True and break
10:47:36 <ski> Tomasso : at least not that i can remember :(    'twas quite nice to actually see the reductions happen in front of you .. :)
10:47:53 <ski> sex|more : hmm
10:47:56 <diminished> shapr: i see no reason of doing so.
10:51:59 <ski> sex|more : why do you use div ?
10:53:48 <sex|more> well, I have to show the equality somehow
10:53:55 <sex|more> x div y = 1
10:54:03 <sex|more> if both are equal
10:54:12 <ski> x == y ?
10:54:24 <sex|more> had that too
10:54:35 <sex|more> doppelt atn = [ (x,y) | x <- atn, y <- atn, x == y]
10:54:38 <sex|more> and output what?
10:54:47 <sex|more> instead of (x,y
10:54:49 <sex|more> instead of (x,y)
10:56:27 <ski> you want doppelt to tell if there is any duplicates, right ?
10:56:36 <sex|more> yes!
10:56:53 <sex|more> it is enough if doppelt tell that there is no one or at least one!
10:57:11 <ski> yes
10:58:17 <sex|more> how should I change my filter then?
10:58:28 <ski> but if we do both "x <- atn" and "y <- atn", then doppelt will complain about duplicates in the list [1] !  (x and y gets bound to 1, both of them)
10:58:51 <sex|more> ignore 1 element in the list
10:58:59 <sex|more> we always have at least 2 or 3
10:59:03 <ski> so, either, you want y to only get bound to elements after the x in the list
10:59:27 <ski> or, you can try to write the function with recursion, instead of list comprehension
10:59:31 <sex|more> yes, I think so
10:59:35 <harsha123> hi all
10:59:36 <ski> i think both variants could work
10:59:53 <harsha123> is apt written in perl?
10:59:55 <sex|more> how do I produce a break
11:00:01 <sex|more> I can't get that work: doppelt atn = [ (x,y) | x <- atn, y <- atn, x `div` y == 0]
11:00:10 <sex|more> the output is not the one I want
11:00:18 <sex|more> I can't get that work: doppelt atn = [ (x,y) | x <- atn, y <- atn, x == y]
11:00:41 <ski> say the list [1,2,3], then. x and y are still being bound to 1 in the version sketch above. same problem
11:00:53 <sex|more> ok
11:00:56 <sex|more> how to solve
11:01:04 <ski> well
11:01:22 <ski> you draw x from the list atn  ("x <- atn")
11:01:42 <ski> so y must not be drawn from atn, but from the rest of the list, after x
11:02:14 <sex|more> yes!
11:02:44 <ski> as i said above, i think you _can_ (not must) solve this with list recursion instead of list comprehensions
11:03:02 <ski> you decide what approach you want
11:03:38 <sex|more> ok
11:03:41 <sex|more> letme try
11:04:44 <ski> to make a "break", you can possibly use one of && and ||
11:04:51 <ski> (do you know them ?)
11:05:20 <sex|more> I know them
11:06:01 <ski> (so i assume that you know their laziness then, also ..)
11:06:13 <sex|more> well, I didn't get one point
11:06:30 <ski> mm ?
11:06:46 <sex|more> doppelt atn = [ which output? | x <- atn, y <- atn, y > x, x == y]
11:07:20 <sex|more> damn, y > x doesnt work
11:07:22 <ski> True, i think
11:07:33 <ski> i was just going to say that :)
11:08:18 <ski> i doesn't work because you don't pass lists like [1..100] to doppelt, but instead a list which has duplicates ... :(
11:08:30 <sex|more> yes
11:08:32 <sex|more> damn 
11:08:37 * sex|more whining here
11:08:44 <ayrnieu> What are you trying to do?
11:08:45 * sex|more is whining here
11:08:49 <sex|more> me?
11:08:50 <ski> so in this case you need some other way of only selecting y after x
11:09:00 <ski> sex|more : do you want a hint ?
11:09:08 <sex|more> yes! PLZ
11:09:23 <ski> ayrnieu : he is trying to compute fibonacci numbers by a novel method
11:09:49 <ayrnieu> What is he trying to do, more specifically?
11:10:37 * ayrnieu leaves.
11:11:05 <ski> sex|more : you can look up a library function called "tails", i think it is in the List library file
11:11:20 <sex|more> why not head?
11:11:56 <ski> ayrnieu : still interested ? 
11:12:28 <ski> (note that i said "tails", not "tail")
11:12:37 <sex|more> k
11:13:06 <sex|more>  - Undefined variable "taisl"
11:13:06 <sex|more> Main> tails
11:13:06 <sex|more> ERROR - Undefined variable "tails"
11:13:06 <sex|more> Main> tails 1 2
11:13:06 <sex|more> ERROR - Undefined variable "tails"
11:13:06 <sex|more> Main> tails [1,2]
11:13:09 <sex|more> ERROR - Undefined variable "tails"
11:13:11 <sex|more> Main>
11:13:43 <ski> forgot "import List (tails)" ?
11:14:47 <sex|more> ahh
11:14:50 <sex|more> I got it now
11:15:32 <ski> can you get what it does ?    perhaps even get an idea of how to use it for doppelt ?  :)
11:15:44 <ski> more hints wanted ?  :))
11:16:13 <sex|more> well..look:
11:16:18 <ski> mm
11:16:19 <sex|more> doppelt atn = [ (compare x y) | x <- atn, y <- (tails atn)]
11:16:28 <sex|more>  tails [1,2]
11:16:28 <sex|more> Reading file "C:\Dokumente und Einstellungen\Administrator\Desktop\nummer23.hs":
11:16:28 <sex|more> Type checking
11:16:28 <sex|more> ERROR "C:\Dokumente und Einstellungen\Administrator\Desktop\nummer23.hs":7 - Typ
11:16:28 <sex|more> e error in application
11:16:29 <sex|more> *** Expression     : compare x y
11:16:30 <sex|more> *** Term           : x
11:16:32 <sex|more> *** Type           : a
11:16:34 <sex|more> *** Does not match : [a]
11:16:37 <sex|more> *** Because        : unification would give infinite type
11:16:39 <sex|more> List>  
11:16:44 <ski> yes, type error
11:17:02 <ski> have you tried out tails in hugs (or ghci ??
11:17:14 <sex|more> yes!
11:17:19 <sex|more> tails works
11:17:28 <ski> but what does it do ?
11:18:09 <sex|more> Main> tails [1,2]
11:18:09 <sex|more> [[1,2],[2],[]]
11:18:09 <sex|more> Main>    
11:18:15 <ski> (and how to use it in doppelt ?  (rethoric question, of course))
11:18:23 <ski> yes
11:19:00 <ski> so it gives a list of all tails of its input, do you agree with me ?
11:19:08 <sex|more> yes
11:20:53 --- topic: '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","lots of cool debs in the haskell-experimental archive - see http://www.syntaxpolice.org/haskell-experimental/haskell-experimental.html","new HC&A Report - http://www.haskell.org/communities/","Any user who would like to request any unwritten tutorial please msg shapr"]'
11:20:53 --- topic: set by Pseudonym on [Mon Nov 17 15:43:01 2003]
11:21:09 <ski> suppose that you would select x from the first element in each tail in, say, [[1,2,3],[1,2],[1],[]]
11:21:16 <sex|more> yes
11:21:39 <ski> um, no
11:21:59 <ski> make that [[1,2,3],[2,3],[3],[]], of course :)
11:22:24 <sex|more> hold on, gimme a break
11:22:32 <ski> so x gets successively bound to 1 .. 2 .. 3, right ?
11:22:34 <ski> ok
11:22:57 <sex|more> oh my god, I just don't want to think about that I have to do 2-3-Trees in haskell....
11:23:33 <ski> for this program/problem you are working on now ?
11:23:47 <sex|more> another one for next week
11:24:06 <sex|more> I guess I will leave the recent problem as it is and solve it not in haskell
11:24:28 <ski> actually, when you get used to the haskell way of thinking, i don't think it would be too overly hard ..
11:24:37 <sex|more> I know
11:24:43 <sex|more> I am doing haskell just for a month
11:24:45 <ski> well, doppelt is almost finished
11:26:39 <ski> ok
11:26:54 <sex|more> I guess I got pretty far for a month
11:27:15 <sex|more> the damn thing is
11:27:32 <sex|more> I am spending 2 days every week to get those fucking papers done!
11:27:38 <ski> have you studied haskell for a month, upto now ?
11:27:39 <sex|more> and 2 days are way to much
11:28:11 <ski> mhm ?  scientific papers ?
11:28:42 <sex|more> no, rather assignments every week
11:28:45 <sex|more> with 4 taks on
11:28:50 <sex|more> sometimes 5
11:29:02 <ski> "taks" ?  talks ?
11:29:07 <sex|more> tasks
11:29:10 <ski> ok
11:29:13 <ski> got it
11:29:44 <sex|more> we had to implement rsa key computation in Haskell
11:30:03 <sex|more> public/private en/de cryption
11:30:06 <ski> oh, i have never implemented rsa
11:30:11 <ski> yes, i know
11:30:49 <ski> what kind of course is it ?  a crypto course ? a haskell one ? a prog.lang. one ? other ?
11:31:24 <sex|more> no, course is called Algorithms and Programming I
11:31:47 <sex|more> along with haskell the prof introduced lambda calculus!
11:32:02 <ski> ok, nice ;)
11:32:37 <shapr> diminished: so why are you here on #haskell then?
11:35:49 <ski> sex|more : so ..., you quit for today with haskell, eh ?  ;)
11:36:04 <dennisb> shapr: maybe he already know haskell and thus don't see a reason for learning it
11:36:11 <shapr> oh,that's a good point.
11:36:46 <sex|more> yes, my brain needs rest
11:36:56 <dennisb> shapr: but probably not
11:37:01 <ski> 'k
11:37:01 <shapr> we can hope
11:37:24 <sex|more> an other last non-haskell question
11:37:43 <ski> mm
11:37:44 <sex|more> how to produce: <sex|more> user: .....
11:38:08 <ski> just type "user: ....." i would guess
11:38:24 <diminished> shapr: dunno, you tell me.
11:38:29 <sex|more> ski: let's try
11:38:38 <sex|more> damn, right
11:38:48 <sex|more> I thoght there is a script for
11:38:54 <ski> perhaps your irc client can complete nick-names, also ..
11:38:56 <sex|more> Guess, my brain passed our
11:39:02 <sex|more> mIRC?
11:39:10 <sex|more> yes!
11:39:15 <sex|more> with tab
11:39:46 <ski> try typing a few initial characters of the name, and then press tab, perhaps that'll work
11:39:50 <sex|more> thx
11:39:52 <sex|more> works
11:39:55 <ski> good
11:40:05 <isomer> @arr
11:40:07 <lambdabot> Aye Aye Cap'n
11:40:20 <ski> @yow
11:40:21 <lambdabot> OKAY!!  Turn on the sound ONLY for TRYNEL CARPETING,
11:40:21 <lambdabot>  FULLY-EQUIPPED R.V.'S and FLOATATION SYSTEMS!!
11:40:22 * isomer looks for sympathy from capt lambdabot
11:40:28 <isomer> @arr
11:40:28 <lambdabot> Drink up, me hearties
11:40:32 <isomer> okay!
11:40:35 <ski> @arr
11:40:35 <lambdabot> Smartly me lass
11:48:00 --- topic: '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","lots of cool debs in the haskell-experimental archive - see http://www.syntaxpolice.org/haskell-experimental/haskell-experimental.html","new HC&A Report - http://www.haskell.org/communities/","Any user who would like to request any unwritten tutorial please msg shapr"]'
11:48:00 --- topic: set by Pseudonym on [Mon Nov 17 15:43:01 2003]
12:11:15 --- topic: '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","lots of cool debs in the haskell-experimental archive - see http://www.syntaxpolice.org/haskell-experimental/haskell-experimental.html","new HC&A Report - http://www.haskell.org/communities/","Any user who would like to request any unwritten tutorial please msg shapr"]'
12:11:15 --- topic: set by Pseudonym on [Mon Nov 17 15:43:01 2003]
12:16:04 <esap> hmm.. where can I find an algorithm to compute permutations of a sequence? [not a list, which is trivial]
12:17:09 <sex|more> ski: I have an other task for you
12:17:12 <sex|more> if you like
12:17:12 <Lor> What kind of a sequence?
12:17:26 <Lor> Why not turn the sequence into a list and take permutations of that?
12:17:28 <ski> sex|more : hmm ?
12:17:32 <isomer> http://theory.lcs.mit.edu/~clr/
12:17:33 <sex|more> wanna hear?
12:17:44 <ski> sex|more : why not ?
12:17:49 <esap> lor: because I don't know when it ends, I'm trying to do this for coalgebras! :-)
12:18:15 <ski> esap : sounds like fun :)
12:18:17 <sex|more> write an script for:
12:19:33 <sex|more> you have a list of n number, ascending but not obliged to be contiguous
12:20:13 <ski> esap : so you want all permutations of prefixes of a stream, or what ?
12:20:21 <ski> sex|more : yes
12:20:43 <esap> ski: well no, all permutations of a stream, not any finite prefix of it :-)
12:20:53 <sex|more> calculate the difference of (number(n) + number (n-1) - number (1) + number(2))
12:20:59 <sex|more> the requirements are
12:21:18 <ski> esap : so a possible permutation of [0..] is [0,2..], then ?
12:21:36 <sex|more> the summation of the numbers should be like I told you without duplicates
12:22:17 <ski> esap : (i.e. some elements may be shuffled infinitely away, and thus lost, no ?)
12:22:21 <esap> ski: well I guess I should require that each permuted occurs _eventually_ and exactly once.
12:22:26 <sex|more> and the difference should be close to d = (n(n-1)/2 )-1
12:23:13 <sex|more> e.g. for n = 6, d should be 14
12:23:15 <sex|more> round up
12:23:18 <ski> esap : ok
12:23:19 <esap> ski: element I mean. But yes, you're right, the problem is not that well defined if I don't choose a finite prefix.
12:23:27 <ski> sex|more : hmm
12:23:32 <sex|more> understand?
12:24:58 <esap> ski: but I guess what I mean is that I get a certain stream of permutations where you know that the elements in that stream are each permutations taken relative to some ordering (e.g. lexicographic)
12:28:52 --- topic: '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","lots of cool debs in the haskell-experimental archive - see http://www.syntaxpolice.org/haskell-experimental/haskell-experimental.html","new HC&A Report - http://www.haskell.org/communities/","Any user who would like to request any unwritten tutorial please msg shapr"]'
12:28:52 --- topic: set by Pseudonym on [Mon Nov 17 15:43:01 2003]
12:28:52 <esap> ski: but that there wouldn't be any limit on how far you can go.
12:28:58 <sex|more> no doubles in the output
12:29:04 <sex|more> no calculate the difference
12:29:27 <ski> esap : mm, yes
12:29:36 <sex|more> now*
12:30:05 <ski> sex|more : i'm coming ;)
12:30:14 <sex|more> ski: hell, yes!
12:30:14 <sex|more> :d
12:30:30 <Tomasso> ski: http://168.226.149.171/facultad/2anio/2cuat/Funcional/practicos/practica9/practica9.hs
12:30:40 <ski> "no doubles in the output" ?  what output ?
12:31:16 <sex|more> ski: in this output paare atn = [ x+y | x <- atn, y <- atn, y > x]
12:32:03 * ski : FATAL ERROR: multi-neuronic overheating, begin evacuating now !
12:34:25 <sex|more> I see
12:34:40 <sex|more> you can directly have my assignment, the translation what to do!
12:34:42 <ski> Tomasso : "nodesBin:: (BinTree a) -> Integer", should be "nodesBin:: BinTree Integer -> Integer", no ?
12:35:15 <ski> Tomasso : no, forget that
12:35:43 <ski> Tomasso : no, again ! that is your problem, indeed !
12:36:06 <Tomasso> ski: yes, but i just want to count the number of nodes
12:36:15 <ski> Tomasso : (or rather that you dont do "foldBinTree:: (a -> b -> b -> b) -> b -> BinTree a -> b")
12:36:19 <Tomasso> doesnt mother the contents of the nodes..
12:36:36 <ski> Tomasso : see ?
12:36:50 <ski> sex|more : coming ;);)
12:36:51 <Tomasso> hmhm still dont
12:37:02 <sex|more> k
12:37:40 <ski> sex|more : so what do you want to do with [1,2,3,5,8,13] and [10,12,13,14,18,19] ?    compute 18+19-1+2 ??
12:39:39 <ski> Tomasso : your typing of foldBinTree says that whatever foldBinTree returns must be the same type as the type of the elements in the tree, but the function definition is okay, you just have to change it's type signature to a more general one (or let hugs/ghci infer it for you)
12:39:59 <sex|more> no
12:40:10 <sex|more> almost
12:40:12 <ski> Tomasso : btw, foldTip's type can be generalized in the same way
12:40:29 <ski> then what ?  :)
12:40:52 <ski> Tomasso : that's better
12:41:03 <ski> Tomasso : ain't it ?
12:41:05 <sex|more> ski: I want haskell to create such lists where last+preLast-first+second is as small as possible
12:42:09 <ski> from which list does this (last,preLast, etc) refer to ? the first list ? the second ? the concatenation of them both ? other list ?
12:42:49 <sex|more> from one list, which will be generated!
12:43:01 <ski> Tomasso : i hope you see now what the problem was, and how this (hopefully :) fixed it ..
12:43:03 <sex|more> those 2 are example
12:43:45 <ski> so you want a function with type, say  [Integer] -> [Integer] -> [Integer]   , ok ?
12:44:43 <sex|more> me??
12:45:22 <ski> yes, you.  (i'm talking to both you and Tomasso at the same time, if you hadn't noticed ;)
12:45:43 <sex|more> I had, I didn't know to who you were referring to
12:45:57 <sex|more> [Integer] -> Integr
12:45:59 <sex|more> [Integer] -> Integer
12:46:15 <sex|more> gets a list, does calc and gives a number back
12:46:46 <ski> (well, you didn't use "user: ..." currently, so i (mostly) didn't when speacking to you, but i did, when speaking to Tomasso, fine ?)
12:47:20 <sex|more> k
12:47:24 <ski> ok, so it gets one list, then, not two (at the same time), is that right ?
12:47:31 <sex|more> yes
12:48:36 <ski> and is it for this list that you wish to minimize last+preLast-first+second ?   hmm, i would guess not, on afterthought ..
12:49:14 <sex|more> yes, for the given list
12:49:14 <shapr> diminished: because you really want to learn Haskell, and you just haven't noticed it yet
12:49:58 <ski> Tomasso : btw, why don't you either change  foldTip to foldTipTree  *xor*  foldBinTree to foldTree,  for consistency ?   just a suggestion ..
12:51:23 <diminished> shapr: i see no use of doing so.
12:51:45 <diminished> shapr: i'd rather learn a language another language like C/C++.. C#
12:51:45 <ski> Tomasso : you've changed foldBinTree's type back again ?  why ?
12:52:27 <diminished> shapr: which has a big percent of popularity..
12:53:31 <shapr> diminished: jumping off cliffs is popular in certain circles ;-)
12:53:33 <ski> diminished : you don't want to learn anything different, then ?  (they say that it can make you a better (more ways to think) programmer even in other languages, etc ...)
12:53:55 <ddarius> shapr: I've wanted to jump off cliffs before, though I'd more want to jump out of planes.
12:54:15 <shapr> ddarius: yes, but I suspect you would have safety equipment handy.
12:54:18 <shapr> I was thinking more about lemmings
12:54:19 <diminished> ski: oh ic..
12:54:35 <ski> diminished : (different as in different programming language, i mean)
12:55:06 <shapr> ddarius: have you actually jumped off a cliff or out of an airplane?
12:55:07 <diminished> yeah, i'd want to learn C# :)
12:55:11 <shapr> I'd like to try skydiving.
12:55:16 <ddarius> diminished: Learning Haskell (as well as many other decent languages) doesn't keep you from learning C# or using it.
12:55:29 <diminished> but whats the use, ddarius?
12:55:31 <diminished> :P
12:55:36 <ddarius> Most of the programmers on this channel know many languages.
12:55:38 <diminished> why use up the time to learn it?
12:55:45 <diminished> ddarius: so do i.
12:55:54 <sex|more> gentlemen, I am off!
12:55:59 <sex|more> see ya soon
12:56:01 <ski> sex|more : bye
12:56:23 <shapr> diminished: if you only learned C, you would not know how to do OOP, right?
12:56:57 <shapr> if you only learn imperative and OOP, you'll miss out on other cool ways to structure code, such as functional, logic, and constraint
12:57:35 <shapr> Haskell can teach you a lot about functional, and some about logic and constraint.
12:57:36 <diminished> so languages like Haskell help you in that?
12:57:42 <shapr> sure
12:57:49 <diminished> gotcha.
12:58:04 <shapr> you can only assign a value to a name once in Haskell
12:58:06 <ddarius> Learning a new language in general adds a tool to the toolbox.
12:58:07 <Smerdyakov> Haskell is a much better choice for application programming than anything you already know, diminished.
12:58:24 <Smerdyakov> That in and of itself should be a reason to learn it.
12:59:08 <diminished> and why is that, Smerdyakov?
12:59:45 <shapr> diminished: what prompted you to join #haskell? I'm just curious.
13:00:10 <diminished> shapr: i was curious :)
13:00:11 <diminished> hehe
13:00:17 <shapr> that's a good reason.
13:00:18 <ham[zzz]> shapr: hi :)
13:00:43 <shapr> hi ham[zzz] 
13:00:48 <shapr> what's up?
13:01:48 <Smerdyakov> shapr, he joined #haskell because someone in another channel told him to come ask "which is better: Haskell or OCaml?" and see the response.
13:01:57 <shapr> oh
13:02:03 <shapr> diminished: how did you like the response?
13:02:15 <Smerdyakov> diminished, it's better for most of the same reasons I have at http://www.hprog.org/fhp/MlLanguage
13:03:41 <diminished> shapr: like the response of what?
13:04:04 <shapr> diminished: http://slashdot.org/article.pl?sid=00/07/01/2321210&mode=thread
13:04:16 <shapr> diminished: when you asked whether Haskell or OCaml is better? did you get a good response?
13:04:33 <shapr> http://www.cs.chalmers.se/~rjmh/Papers/whyfp.html
13:05:00 <diminished> shapr: yeah, i did.
13:05:09 <shapr> cool
13:06:25 <diminished> "Moscow ML" hehehe
13:10:21 <ham[zzz]> shapr: have you had a look at casl?
13:10:53 <shapr> no, still not yet
13:10:56 <shapr> have you?
13:11:25 <ham[zzz]> shapr: just a bit but not too much i downloaded the HOL system
13:17:14 <raver> hi
13:17:40 <ski> hi raver
13:19:56 <ski> raver : learning haskell ?
13:20:20 <raver> yeah
13:20:29 <raver> in the uni
13:20:33 <ski> how's it going ?
13:20:50 <raver> i like it
13:20:52 <raver> it's funny
13:20:58 <raver> but also it's hard
13:21:00 <raver> :)
13:21:22 <ski> been programming any other language before ?   (basic, c, java, pascal ??)
13:21:28 <raver> C
13:21:31 <ski> ok
13:21:35 <raver> i'm not a programmer
13:21:48 <raver> but i'm studying the last year of computer science
13:21:56 <ski> mhm
13:22:03 <Lor> Are you a theoretician, then?
13:22:04 <raver> coming from a telecommunications degree
13:22:16 <raver> no no
13:22:20 <raver> i'm a networker
13:22:23 <raver> :)
13:22:29 <raver> but i like programming
13:22:33 <raver> well
13:22:40 <raver> i like to learn it
13:23:01 <ski> that's nice to hear
13:23:09 <raver> cheers
13:23:36 <ski> don't suppose you have any question right now, on haskell, though ..
13:23:50 <ski> have you heard about Erlang ?
13:23:58 <raver> yes
13:24:18 <raver> I studied it in a subject in my telecomms degree
13:24:53 <raver> tarffic unit
13:25:01 <raver> s/tarffic/traffic
13:25:01 <Lor> What an enlightened school.
13:25:09 <ski> so then you probably know that its core is functional (as haskell is) (with nice features like pattern-matching and data immutability)
13:25:49 <raver> yes
13:26:04 <raver> I realize that haskell programming is math programming
13:26:18 <raver> math-like
13:26:20 <raver> sorry
13:26:36 <phubuh> it's easier to do "math programming" in Haskell, but it's very easy not to
13:26:47 <phubuh> easier than in traditional imperative languages, that is
13:26:59 <ski> yeah, i think the functional programming mindset is closer to math  (than, say imperative programming ..)
13:27:29 <raver> it's one of the reasons because i like it
13:27:36 <raver> ;)
13:27:42 <ski> ;)
13:30:27 <ski> raver : well, if (or when ?) you got questions about FP (or haskell in specific), you can always ask here ...
13:34:59 <raver> ok currently i don't have questions, but i'm doing a FP coursework and maybe i will have questions
13:35:04 <raver> thx
13:36:20 <raver> sorry for my english too...:/
13:46:14 <diminished> Is there any official boosk for Haskell or SML?
13:46:18 <TripleDES> hi
13:48:05 <Smerdyakov> There's the Definition of Standard ML.
13:48:13 <Smerdyakov> I guess The Haskell Report is analogous for Haskell.
13:48:20 <Smerdyakov> But neither is meant as a tutorial.
13:48:51 <diminished> so Haskell IS SML right, Smerdyakov?
13:50:13 <Smerdyakov> No.
13:51:17 <diminished> Hmm.
13:51:31 <diminished> A form of SML?
13:51:42 * diminished feels like a n00b
13:51:45 <mattam> a form of ML IIUC
13:52:17 <Smerdyakov> No.
13:52:23 <Smerdyakov> They are like cousins.
13:53:53 <mattam> well, some (teachers!) say haskell is an ML language, maybe they're not 'strictly speaking'
13:54:36 <Smerdyakov> They certainly aren't.
13:54:45 <Smerdyakov> I bet they only say that in France.
13:56:06 <mattam> ;)
13:57:31 <mattam> i've got a teacher who said Haskell was very good at being lazy and it was _widely_ used in anglo-saxon countries
13:58:23 <mattam> (she's a O'Caml develloper and Coq founder)
13:59:05 <mattam> she also said it was very efficient in terms of generated code
13:59:10 <mattam> is that all true ?
14:00:06 <Smerdyakov> I think so.
14:00:16 <Smerdyakov> Also widely used in Scandanavian countries.
14:01:57 <ski> diminished : "Haskell : The Craft of Functional Programming" is the one i learned from, see http://www.haskell.org/bookshelf/ for some more books on haskell
14:02:47 <diminished> ok, ty.
14:04:27 <ski> probably someone else can give references on books on SML
14:04:58 <ski> for OCaml you can see http://caml.inria.fr/books-eng.html (first one is available online, it seems)
14:08:53 * shapr bounces cheerfully
14:09:50 * isomer slides a trampoline in place under shapr
14:11:01 <shapr> dang :-( GHC doesn't seem to work with IPv6
14:19:03 <shapr> asmodai: so, had time to try some promotional literature?
14:19:10 <shapr> re Arnia 
14:21:42 * ski chuckles
14:25:47 <shapr> hi neniu 
14:43:13 <shapr> g'day Pseudonym 
14:46:03 <Pseudonym> G'day.
14:46:25 <Pseudonym> Been thinking about references and typeclasses.
14:46:37 <shapr> anything interesting ?
14:47:12 <Pseudonym> Well, you know how there's been a lot of discussion on trying to get all of the reference monads consolidated using some kind of typeclass.
14:47:28 <Pseudonym> class MonadRef m r where
14:47:33 <shapr> yah, I've seen a bit of that
14:47:35 <Pseudonym>    newRef :: a -> m (r a)
14:47:40 <Pseudonym>    readRef :: r a -> m a
14:47:41 <Pseudonym> etc
14:47:52 <Pseudonym> Trouble is the problem is far too underconstrained.
14:48:10 <Pseudonym> For example, the IO monad has IORefs and MVars.
14:48:24 <Pseudonym> OTOH, STRefs can be used with both strict and lazy ST.
14:48:30 <ski> i've some times now been playing around with ReadReferences and WriteReferences (as separate types)
14:48:32 <Pseudonym> So there are no functional dependencies.
14:49:03 <ski> yes
14:49:12 <Pseudonym> Well, I think I know what the problem is.
14:49:16 <shapr> what?
14:49:26 <Pseudonym> We should change the reference types to fit the typeclass, not the other way around.
14:49:42 <Pseudonym> Here's my reasoning:
14:50:00 <Pseudonym> Every monad, when you get down to it, really has only one "base" reference type.
14:50:11 <Pseudonym> For IO, for example, it's IORefs.
14:50:19 <Pseudonym> "But it has MVars!" I hear you cry.
14:50:38 <Pseudonym> True, it does, but an MVar is, logically, an IORef plus some kind of synchronisation.
14:50:43 <ski> you want MVars in another monad ?
14:50:59 <Pseudonym> If you worked out how to express the synchronisation in Haskell, you could build MVars on top of IORefs.
14:51:23 <Pseudonym> Similarly, suppose you wanted an IORef which was Ord-able, or hashable.
14:51:33 <Pseudonym> You could implement that on top of IORef.
14:52:02 <Pseudonym> No.  What I want is for there to be a base reference type for each monad, and to explicitly build others on top of that.
14:52:12 <Pseudonym> So you have something like this:
14:52:12 <ski> and if i wanted to play with read-only-refs, and write-only-refs ? :-P
14:52:22 <Pseudonym> Well, that would work.
14:52:34 <Pseudonym> Channels are actually like read-only refs and write-only refs.
14:52:37 <shapr> I want to see your base structure idea
14:52:46 <Pseudonym> This is only half-formed atm.
14:52:50 <Pseudonym> But I see it something like this:
14:52:58 <ski> like a pair of them, i take you mean
14:53:08 <Pseudonym> class MonadRefBase m r | m -> r, r -> m where
14:53:18 <Pseudonym>     newRefBase :: a -> m (r a)
14:53:21 <Pseudonym>     {- etc -}
14:53:30 <Pseudonym> ski: Right.
14:53:36 <Pseudonym> Like a Unix pipe.
14:54:20 <Pseudonym> Now of course you could split this into two typeclasses (or three, I suppose) if you wanted to separate read and write functionality.
14:54:26 <Pseudonym> Then you have something like this:
14:54:42 <Pseudonym> class (MonadRefBase m br) => MonadRef m br r where
14:54:50 <ski> (i'm not actually sure how useful rrefs and wrefs would be, but RRef is a Functor and WRef is a CoFunctor, just that is cool !)
14:55:07 <Pseudonym>     refToBaseRef :: r a -> m (br a)
14:55:16 <Pseudonym>     baseRefToRef :: br a -> m (r a)
14:55:26 <Pseudonym> Then, finally:
14:55:51 <Pseudonym> newRef :: (MonadRef m br r) => a -> m (r a)
14:56:04 <Pseudonym> Uhm... OK, we actually want:
14:56:15 <Pseudonym>     makeRef :: a -> m (r a)
14:56:24 <Pseudonym>     getBaseRef :: r a -> m (br a)
14:56:31 <Pseudonym> newRef x = makeRef x
14:56:49 <Pseudonym> readRef r = getBaseRef r >>= \br -> readRefBase
14:56:50 <Pseudonym> Or something.
14:56:58 <Pseudonym> I _think_ this would work.
14:57:05 <ski> in which class  (makeRef and getBaseRef)  ?
14:57:05 <Pseudonym> Need to code it up.
14:57:16 <ski> BaseRef or Ref ?
14:57:16 <Pseudonym> ski: In MonadRef.
14:57:20 <ski> ok
14:57:33 <Pseudonym> And of course there would be an instance for MonadRef corresponding to the base ref.
14:57:38 <Pseudonym> Or there need not be, of course.
14:57:46 <Pseudonym> IORefs might actually be build on top of IOBaseRefs.
14:58:18 <ski> can't IOBaseRef be instance of MonadRef ?
14:58:29 <Pseudonym> ski: No it can't.  Overlapping instances.
14:58:39 <Pseudonym> Tried it, didn't work.
14:58:39 <ski> hmm
14:58:54 <Pseudonym> With -fallow-overlapping-instances it worked. :-)
14:59:16 <ski> i don't see right now how it would be overlapping ..
14:59:41 <Pseudonym> Assuming that all works, the only remaining problem is synchronisation for MBars.
14:59:43 <Pseudonym> MVars
14:59:47 <Pseudonym> What's an appropriate primitive?
15:00:20 <Pseudonym> So, I hereby coin a new type, the Mutex.
15:00:56 <Pseudonym> Or perhaps Monitor.
15:01:07 <ski> Mutex :: * -> *  ?
15:01:17 <Pseudonym> Hang on, bear with me a moment.
15:01:22 <ski> m
15:01:32 <Pseudonym> data Mutex a b = {- abstract -}
15:01:52 <Pseudonym> newMutex :: (a -> IO b) -> IO (Mutex a b)
15:02:01 <Pseudonym> lockMutex :: a -> Mutex a b -> IO b
15:02:04 <Pseudonym> That's it.
15:02:21 <Pseudonym> Sorry:
15:02:29 <Pseudonym> lockMutex :: Mutex a b -> a -> IO b
15:02:41 <Pseudonym> Logically, it's a function :: a -> IO b
15:02:50 <ski> looks a little bit like an arrow, hmm ?
15:02:54 <shapr> hm, I can't get GHC to do an echo server with ::1 or my actual IPv6 address.
15:02:54 <shapr> dang
15:02:55 <Pseudonym> Maybe.
15:03:12 <Pseudonym> The thing is, only one thread can be running this function at any given time.
15:03:25 <Pseudonym> I _think_ that's sufficient.
15:03:34 <ski> but it should have locking semantics when running the function, right ?
15:03:36 <Pseudonym> To implement MVars, that is.
15:03:38 <Pseudonym> Right.
15:03:42 <ski> ok,hm
15:03:55 <Pseudonym> You may need some more stuff to handle IOExceptions.  Not sure about that.
15:04:36 <Pseudonym> It may also be worth making the type of newMutex something like this:
15:04:49 <ski> so lockMutex is almost an inverse to newMutex, then, hmmm
15:04:50 <Pseudonym> newMutex :: (MonadIO m) => (a -> m b) -> IO (Mutex a b)
15:05:05 <Pseudonym> SO that a mutex can propagate state, for example.
15:06:06 <Pseudonym> I need to code this up.  The Mutex is actually fairly straightforward to implement in terms of existing primitives, but I think it should be a primitive in its own right.
15:06:16 <shapr> hi Haldol 
15:06:28 <shapr> looking for Haskell info?
15:06:57 <ski> Pseudonym : hmm, can't remember how MonadIO's defined right now, remember what module it is in ?
15:07:09 <Pseudonym> Control.Monad.Transformer, I think.
15:07:10 <Haldol> just wondering what is it
15:07:43 <shapr> Haldol: Haskell is a purely functional programming language.
15:07:51 <shapr> being purely functional allows for some extranifty tricks.
15:08:24 <shapr> some of my favorite features in Haskell are higher order functions, partial application, and algebraic datatypes.
15:08:51 <shapr> Haldol: have you used something like Lisp or Scheme before? maybe elisp?
15:09:00 <Lor> All of these being standard equipment in ML as well...
15:09:01 <Haldol> nope
15:09:14 <shapr> Lor: right, but he's on #haskell ;-)
15:09:32 <shapr> Haldol: have you used some imperative programming languages? maybe Python, C, Java?
15:09:45 <Haldol> just starting on VB and Java
15:10:08 <Lor> VB? Uh, why?
15:10:19 <Haldol> school
15:10:20 <shapr> I've been doing programming for awhile, and I've seen three major 'flavors,' those being imperative, functional, and logic/constraint
15:10:30 <Haldol> brb
15:10:51 <shapr> I used to have a VB Job for awhile.
15:10:58 <Pseudonym> There's a fourth flavour, IMO.  "Domain specific." :-)
15:11:07 <shapr> hmm
15:11:29 <Pseudonym> In theory, DSLs can be any of the above, but there are plenty of DSLs which don't fit into any of the above categories.
15:11:33 <Lor> shapr, which one does forth belong to?
15:11:36 <shapr> personally I wonder if something like Joy is so far away from Haskell/Scheme/etc to have something else
15:11:46 <Pseudonym> I was thinking of SQL.
15:11:47 <shapr> Lor: I was just wondering that, since Joy and Forth are closely related.
15:12:04 <Pseudonym> They're imperative.
15:12:13 <Pseudonym> You tell it what to do, and it does it.  Imperative.
15:12:15 <shapr> but Joy claim purely functional
15:12:18 <Pseudonym> It's just not _procedural_.
15:12:21 <shapr> hm
15:12:37 <Pseudonym> Just like how logic and functional languages are both declarative.
15:12:56 <shapr> Haldol: anyway, you will be a better programmer if you learn at least enough to write some code in every paradigm
15:13:14 <Pseudonym> Forth is imperative, anyway.
15:13:18 <Pseudonym> Whether Joy is or not.
15:13:25 <shapr> have you ever tried Joy?
15:13:32 <Pseudonym> Me?  No.
15:13:36 <ski> Pseudonym : ("liftIO :: MonadIO m => IO a -> m a" seems to be the only method there,  dunno, perhaps you want "newMutex :: (MonadIO m) => (a -> m b) -> m (Mutex a b)" ?  just a thought)
15:13:37 <shapr> it's cute.
15:13:53 <Pseudonym> ski: Maybe, yes.
15:15:12 <Pseudonym> I see.  OK.  Joy is pure functional.
15:15:41 <shapr> it's fun to write code in Joy.
15:16:02 <shapr> sort of like PostScript and Haskell had a bastard child, and he was raised by Perl
15:16:08 <Pseudonym> Right.
15:16:19 <ddarius> Perl?
15:16:26 <Pseudonym> Well, O'Caml is the bastard child of SML and Modula-3.
15:16:31 <Pseudonym> Raised by Ada.
15:16:34 <shapr> DEFINE approxEqual == 100.0 / rotate [0 =] [pop] [dup rolldown - swap /] ifte > .
15:17:20 <Lor> OCaml is the bastard cousin of SML, rather.
15:18:03 <shapr> ddarius: Joy can easily be write once read never
15:30:01 * ddarius ponders typechecking Joy.
15:30:10 <shapr> oh that sounds interesting
15:30:20 <Pseudonym> ddarius: Were you following the discussion above on reference monads?
15:30:34 <ddarius> shapr: The difficult thing is: [1 2 3 4] [foo] f map
15:31:26 <ddarius> Pseudonym: I read it, though I was afk for the first part.  I'm not sure what it would look like, I'd need to put something together.
15:31:33 * Pseudonym nods
15:31:40 <Pseudonym> I'll put something together and see.
15:31:44 <ski> ddarius : the words in a list-way of passing function arguments ?
15:31:58 <shapr> ddarius: what's difficult about that?
15:33:47 <ddarius> f can be something like [bar] append so you'd get [1 2 3 4] [foo bar] map, i.e. you can construct program phrases at runtime so it's difficult to typecheck them statically.
15:34:29 <Lor> MetaML does that.
15:35:19 <ski> i think it would probably be easier if they distinguished between ordinary lists and (e.g. run-time-assembled) stack-transformers ..
15:35:48 <ddarius> ski: I do too, but I believe this kind of thing is a fairly normal activity with Joy.
15:35:54 <ski> Lor : MetaML distiguishes between code type and other types
15:36:04 <Lor> Well, yes.
15:36:15 <ski> ddarius : i have noticed that :(
15:36:26 <Lor> Can "foo" be something besides code?
15:36:40 <ski> hmm
15:36:49 <ddarius> Lor: depends on how you think of it.
15:36:55 <Lor> Or are they lispish symbols?
15:36:56 <shapr> the number 1 means "push 1 onto the stack"
15:36:56 <ski> well, strictly 1 is code too  :)
15:37:00 <shapr> right
15:37:07 <shapr> so at some level, Joy only has code
15:37:18 <ddarius> Lor: [1 2 3 4] is the syntax for a list, but it's also a quotation of the code to push 1 2 3 and 4.
15:37:23 <shapr> 1 1 1 1 + + + . is perfectly legal Joy
15:37:33 <Lor> Right, so it's essentially lisp-like.
15:37:48 <Lor> Rather difficult to type, I'd say.
15:38:05 <shapr> mixing list and quotes is interesting and strange
15:38:07 <shapr> I like it
15:38:10 <ddarius> Lor: I don't think Lisp takes it to the extent Joy does.
15:38:19 <Lor> I don't.
15:38:20 <ski> i'm not so fond of it
15:38:25 <Lor> m-exprs are much neater.
15:38:48 <Lor> http://citeseer.nj.nec.com/muller92mlisp.html
15:38:51 <shapr> Joy feels nice to me, but I've never gotten around to doing anything with it.
15:38:57 <ski> in lisp a closure isn't an sexpr, though one can pass sexprs to eval
15:39:13 <Pseudonym> There's the rub.  When you actually do stuff with it, that's whtn the cracks show.
15:39:28 <Lor> I think it's a very bad idea to use the same data type both for lists and for quoted code.
15:39:35 <shapr> otoh, an html generation library was written in Joy
15:39:40 <shapr> seems to have worked okay
15:39:52 <ski> e.g. (IIUC) in Joy one can take the length of a code list   (so [1 2 +] isn't the same as [3] :(  )
15:40:31 <shapr> um
15:40:38 <shapr> that's true
15:40:46 <shapr> but isn't that to be expected/
15:40:47 <shapr> ?
15:41:20 <ski> well, it doesn't feel much "referentially transparent"  :(
15:42:27 <ski> (also i'm not sure how well this code-as-lists fit with efficient compilation)
15:44:36 <Pseudonym> Well, it world work fine if Joy were strongly typed.
15:44:56 <Pseudonym> For the most part, anyway.
15:45:15 <Pseudonym> And Lisp compilers aren't exactly inefficient.
15:45:34 <Lor> They aren't exactly simple, either.
15:45:43 <Pseudonym> ski, would it help if you understood Joy as an eager language?
15:45:59 <Pseudonym> So you're looking at the length of a list, not of a thunk (as it would be in Haskell).
15:46:12 <Pseudonym> The length of what's in the list isn't going to change behind you.
15:46:12 <ski> i guess one reason for using lists for code is that it is quite easy to build run-time-generated values into it (analogous with free variables in lambda-expressions)
15:46:13 <ski> one could perhaps imagine things like RTCG for Joy, though
15:46:16 <ski> mm
15:46:20 <ski> actually, i had an idea for closures in a concatenative language, perhaps 2 weeks ago ..
15:46:34 <Lor> ski, that's no reason. You could as well have a distinct data type for reified code.
15:46:35 <ski> (and i'm not talking about introducing named variables, like a lambda-expr)
15:47:42 <ski> Pseudonym : isn't it an eager language ?  (or not applicable ?)
15:49:22 <Pseudonym> ski: DOn't know.
15:49:25 <ski> Lor : i just meant that one could perhaps still make efficient (as in native, e.g.) code generation with Joy's code scheme, just sometimes at run-time
15:51:41 <ski> well, i guess i'm not saying that code-as-list is nessecarily bad, though i would like to know why they employed it in Joy ...
15:52:05 <ski> s/nessecarily/necessarily/   (i think)
15:52:06 <ddarius> ski: I guess I would say it's eager.  1 1 0 / pop will give you a divide by zero exception unless I'm very mistaken.
15:52:24 <ddarius> @eval joy "1 1 0 / pop"
15:52:30 <lambdabot> [1]
15:52:47 <ddarius> @eval joy "1 0 /"
15:52:50 <lambdabot> divide by zero
15:53:17 <ski> perhaps because that is implemented in a lang implemented in haskell, it doesn't fail ?
15:53:27 <ddarius> Yeah.
15:53:56 <ddarius> I think I've deleted the joy interpreter I had so I don't have it handy to test.
15:54:11 <shapr> oh, I have one...
15:54:22 <ski> though i'm not sure how much/to what degree eager or not is applicable, given that much data is single-threaded
15:54:28 <ddarius> (the stack for this would look like, [1 <thunk: 1 0 />] pop
15:54:36 <shapr> 1 0 / .
15:54:37 <shapr> run time error: non-zero divisor needed for /
15:55:05 <ddarius> ski: yeah,  I think before I was thinking it's not applicable.
15:57:14 <ddarius> shapr: and 5 1 0 / pop?
15:58:04 <ski> (anyways, re my closure idea, one way of creating a closure could be like taking n things off the stack to store with the code pointer in the closure, then, when applied, it just automatically pushes these n things back on top of stack.  what do you think of this scheme of closures ?)
15:58:18 <shapr> 5 1 0 / pop .
15:58:18 <shapr> run time error: non-zero divisor needed for /
16:03:06 <ddarius> On the other hand, the problem w.r.t. laziness only comes up for exceptions seemingly.  For example, 5 non-terminating-computation pop can't really be "lazy" because the state of the stack is unknown.
16:05:30 <ski> (so a function similar to "\x -> let y = x*x in map ((2 *) . (y +))" would perhaps be "dup * {1: + 2 *} map")
16:06:01 <ski> yes
16:06:58 <ddarius> If Joy exclusively used error codes I don't think there would be a (semantic) difference between eager and lazy joy (though I'm unsure about IO in Joy).
16:08:38 <ddarius> ski: from how I interpret {1: + 2 *}, how is that not adding bound variables to Joy?
16:08:58 <ddarius> ski: hmm, well maybe.
16:10:26 <ddarius> {1: + 2 *} could be considered syntactic sugar for  [+ 2 *] cons 
16:10:39 <ddarius> (or whatever)
16:10:45 <ski> ddarius : hmm, well the 1 would say that the closure eats one stack element ...  i'm unsure about that bit, though. one could imagine putting all "nonlocals" in a tuple and just have every closure take one elem off the stack ...
16:12:06 <ski> that way would probably be a bit easier to type, but perhaps it would be inconvenient to explicitely tuple and detuple .. :(
16:12:26 <ski> (type as in type check/infer, i.e.)
16:13:33 <ski> also this kind of closure would not be a list, so we can't destruct/use it in any other way than applying it..
16:14:32 <ski> anyway, this idea is still half-baked, i think. haven't put too much thought into it yet, i.e.
16:16:00 <ski> (wonder if i could get something like this to work in my mini-embedding of a concatenative lang in haskell ..)
16:16:35 <shapr> @yow
16:16:36 <lambdabot> Yow!  I want my nose in lights!
16:16:37 <ski> up and down. up and down, yay !
16:16:50 <ski> @yow
16:16:51 <lambdabot> This TOPS OFF my partygoing experience!  Someone I DON'T LIKE
16:16:51 <lambdabot>  is talking to me about a HEART-WARMING European film..
16:22:37 <shapr> that was a relatively normal @yow
16:23:19 <mgoetze> @eval map (mod 5) [1..10]
16:23:19 <lambdabot> (line 1, column 16):
16:23:19 <lambdabot> unexpected "."
16:23:19 <lambdabot> expecting simple term
16:23:32 <mgoetze> was that a relatively normal eval? :)
16:23:39 <ski> shapr : what about  <lambdabot> In Newark the laundromats are open 24 hours a day!
16:23:48 <shapr> that's also quite normal.
16:24:05 <shapr> it's actually weird just because everything else lambdabot says is so far from normal.
16:24:27 * shapr gets into a recursive weirdness loop
16:24:37 <mgoetze> so what's this "simple term" it was expecting? [1..10] seems simple enough to me
16:24:40 * ski : lalala !
16:25:24 <shapr> mgoetze: @eval isn't a Haskell interpreter
16:25:45 <mgoetze> why not? :)
16:26:07 <shapr> well, Lunar^ wrote a lambdabot plugin to allow GHCi access
16:26:21 <shapr> but I'm not willing to run it on my box for some reason...
16:26:46 <tic> man. ATR rewlzor.
16:26:52 <shapr> who's ATR?
16:26:53 <ddarius> @eval map (mod 5) (fromTo 1 10)
16:26:54 <lambdabot> [0, 1, 2, 1, 0, 5, 5, 5, 5, 5]
16:27:10 <tic> shapr, Atari Teenage Riot!
16:27:13 <shapr> oh
16:27:16 <shapr> yah, they're cool
16:27:19 <tic> yap.
16:27:23 <shapr> but I'm in the mood for Soul Coughing atm
16:27:26 <Pseudonym> @ghci system "rm -rf ~shapr"
16:27:27 <lambdabot> Sorry, I don't know the command "ghci", try "lambdabot: @listcommands"
16:27:30 <Pseudonym> Damn.
16:27:38 <shapr> yah, exactly
16:27:47 <mgoetze> ddarius: right, now could you explain how it got those results? :)
16:27:58 <shapr> @get-definition fromTo
16:27:58 <lambdabot> fromTo = enumFromTo
16:28:04 <shapr> @get-definition mod
16:28:04 <lambdabot> mod = \n d.n-(n/d)*d
16:28:09 <shapr> @get-definition map
16:28:10 <lambdabot> map = \f.foldr (\x y.f x:y) []
16:28:15 <shapr> tada!
16:28:24 <ddarius> @get-definition enumFromTo
16:28:24 <lambdabot> enumFromTo = \l h.take (h-l+1) $ iterate (\x.x+1) l
16:29:11 <mgoetze> @eval fromTo 1 10
16:29:12 <lambdabot> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
16:29:46 <mgoetze> @eval mod 3 5
16:29:47 <lambdabot> 3
16:29:51 <mgoetze> @eval mod 53
16:29:52 <lambdabot> <<EM Dynamic -> EM Dynamic>>
16:29:55 <mgoetze> @eval mod 5 3
16:29:55 <lambdabot> 2
16:30:08 <mgoetze> @eval mod 8 5
16:30:08 <lambdabot> 3
16:30:12 <mgoetze> @eval mod 5 8
16:30:12 <lambdabot> 5
16:30:37 <mgoetze> ok, makes sense
16:31:29 <shapr> the @eval plugin got me interested in many deeper parts of FP
16:31:50 <shapr> it's really spiffy to get much of the same functionality as in full Haskell
16:31:58 <shapr> and then see how it works
16:32:06 <ski> like LC implementation ?  ;-P
16:32:14 <shapr> yes! that's the coolest part!
16:32:20 <shapr> Haskell needs @get-definition
16:32:24 <ddarius> @eval zipWith (map . mod) (fromTo 1 10) (replicate 10 (fromTo 1 10))
16:32:27 <lambdabot> [[0, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2], [0, 1, 0, 3, 3, 3, 3, 3, 3, 3], [0, 0, 1, 0, 4, 4, 4, 4, 4, 4], [0, 1, 2, 1, 0, 5, 5, 5, 5, 5], [0, 0, 0, 2, 1, 0, 6, 6, 6, 6], [0, 1, 1, 3, 2, 1, 0, 7, 7, 7], [0, 0, 2, 0, 3, 2, 1, 0, 8, 8], [0, 1, 0, 1, 4, 3, 2, 1, 0, 9], [0, 0, 1, 2, 0, 4, 3, 2, 1, 0]]
16:32:39 <ski> @get-definition get-definition
16:32:39 <lambdabot> get-definition not defined
16:32:45 <ski> @get-definition @get-definition
16:32:45 <lambdabot> @get-definition not defined
16:32:55 <shapr> well, some parts are built-ins
16:33:10 <ski> :)
16:33:21 <ddarius> Most of what's built-in is for printing/efficiency reasons.
16:34:24 <ski> m
16:35:07 <mgoetze> so, how about i ask a question and someone tells me how to answer it with this @eval thingy? :)
16:35:25 <ddarius> @eval "the answer"
16:35:25 <lambdabot> the answer
16:35:33 <ski> Y not
16:35:40 <shapr> ski: silly question, is there any difference between upplysningar and information in swedish?
16:35:54 <mgoetze> i'd like to know for which n you can add an n-permutation to [1..n], modulo n, and get an n-permutation again?
16:36:21 <ski> shapr : what was a silly question ?
16:36:22 <shapr> ta emot information == ta emot upplysningar ?
16:36:29 <tic> japp.
16:36:34 <mgoetze> e.g. [1,2,3] + [2,3,1] = [3,2,1]
16:36:35 <ski> shapr : not much, perhaps only connotations
16:36:36 <tic> mestadels.
16:36:40 <shapr> ok, tack
16:36:43 <mgoetze> but there isn't any for n=4
16:36:52 <mgoetze> and there is again for n=5
16:37:00 <shapr> I doubt the rest of the class will notice the connotations
16:37:01 <tic> information can mean both upplysningar, and just "data"
16:37:28 <tic> i wouldn't say either, though.
16:37:40 <tic> err- I would say neither, though.
16:37:41 <ski> mgoetze : for all n-permutations, given a particular n ?
16:37:53 <mgoetze> ski: no i just want to know whether one exists
16:38:36 <ski> mgoetze : hmm
16:39:44 <ski> shapr : (hmm, "ta emot upplysningar" usually means from a person, i think, while information could be gotten from a machine e.g.)
16:39:48 <shapr> I think "dykt upp" is a funny thing to say.
16:39:58 <ski> yes
16:40:12 <shapr> ski: that's perfect then, I'm writing about a new cybercrime department rikskriminalpolisen and säkerhetspolisen are starting together.
16:40:20 <ski> shapr : have you heard "do you shark ?" yet ?
16:40:27 <shapr> no, what's that?
16:41:25 <ski> (bad (word-for-word)) english translation of jargon : "hajar du ?", i.e. "förstår du ?"
16:41:34 <shapr> interesting
16:42:35 <Pseudonym> What does it mean?
16:42:44 <shapr> do you understand
16:42:48 <Pseudonym> Ah, OK.
16:42:54 <ski> it seems sometimes swedish people translate a swedish saying/way-of-speach to, e.g., and non-swedish people then think they are expressing themselves very weird ..
16:43:10 <shapr> happens in America too
16:43:16 <Pseudonym> Happens all over.
16:43:22 <ski> (often without consciously thinking about it, i.e.)
16:43:30 <shapr> "I'm nervous as a long-tailed cat in a room full of rockers" is common where I come from
16:43:33 <mgoetze> same with german<->english
16:43:34 <ski> yeah, would guess so
16:43:51 <Pseudonym> And where I come from, we request that people "don't come the raw prawn".
16:43:59 <shapr> rockers means rocking chairs in the southeast
16:44:05 <shapr> that's just awesome :-)
16:44:07 <Pseudonym> Gotcha.
16:44:09 <ski> Pseudonym : what does that mean ?
16:44:11 <mgoetze> so noone can tell me how to solve my problem with @eval? guess i'll have to do it with haskell then...
16:44:25 <shapr> we also have "I feel like I been et by a wolf and shit off a cliff" et is really rough slang for eaten
16:44:26 <mgoetze> though, actually, i think scheme would be good for this
16:44:46 <Pseudonym> "to come the raw prawn" means to be a whinger.
16:44:59 <Pseudonym> Someone who complains in an annoying way too much.
16:45:03 <Pseudonym> is a whinger
16:45:09 <ddarius> a whiner?
16:45:16 <shapr> I gotta try this locally.
16:45:16 <Pseudonym> Yes, close enough.
16:45:20 <ski> shapr : (hmm is slang an english word ?)
16:45:32 <shapr> see how unsuspecting swedes handle aussisms
16:45:42 <Pseudonym> My favourite one these days, though, is "to do a Bradbury".
16:45:59 <Pseudonym> I'm trying to get this term inserted in wider jargon.
16:46:02 <ddarius> ski: yes
16:46:06 <shapr> what's a bradbury?
16:46:07 <Pseudonym> On account of it being so useful.
16:46:23 <Pseudonym> Well, it's to win by being just far enough behind that when everyone else falls over, you can overtake them.
16:46:32 <shapr> I'm trying to translate a slashdot article into swedish... whee
16:47:06 <Pseudonym> It describes the technique which Steve Bradbury used to win a gold medal in speed skating.
16:47:07 <ddarius> mgoetze: You could solve it with eval the same way (more or less) you would with Haskell or Scheme.  It probably would be less of a hassle in Haskell or Scheme.
16:47:37 <Pseudonym> Critics are unsure whether it's possible to do a Bradbury by cunning or only dumb luck is allowed.
16:48:30 <Pseudonym> However, it's fairly well-established that the pack ahead of you can fall over anything, though in the original Bradbury, they fell over each other.
16:49:04 <Pseudonym> It could refer, for example, to people who feel they need to be on the bleeding edge, such as during the dot-com bubble.
16:50:11 <Pseudonym> Those who stay behind the bleeding edge and watch everyone else make the mistakes are usually at an advantage.
16:50:14 <shapr> ski: hey, how do I say "made a deal" in swedish?
16:50:32 <Tomasso> hmhm can anyone give me the fold function for the following general tree? data GenTree = Gen a [GenTree a]
16:51:24 <ski> shapr : hmm, "göra en affär" perhaps  (eller "göra en deal", shudder :)
16:51:29 <shapr> heh
16:51:30 <shapr> thanks
16:51:41 <Tomasso> ive been trying to do that for 2 hours...
16:52:02 <shapr> urf, how do I say software license in swedish?
16:52:10 <ddarius> foldGenTree :: (a -> [b] -> b) -> GenTree a -> b
16:52:37 <Pseudonym> Now define the left-fold enumerator.
16:52:45 <ski> Tomasso : mapGen :: (a -> [b] -> b) -> (GenTree a -> b)   ?    (assuming you forgot the a argument to GenTree above)
16:53:00 <Tomasso> hmmhhm
16:53:19 <ski> shapr : "mjukvaru-licens", i think
16:53:25 <ddarius> Tomasso: Also, "GenTree"s are usually called RoseTree and "Branch" or "Node" or something other than "Gen" would be a better name for the constructor.
16:53:33 <shapr> ski: tack!
16:53:48 <ski> (err, foldGen, of course, not mapGen)
16:54:00 <ski> shapr : varsågod !
16:54:07 <Tomasso> hmhm but what would be the function definition?
16:54:29 <ski> start bu writing out the pattern-matching ..
16:54:34 <ddarius> Tomasso: The definition almost follows from the types.
16:54:39 <ski> yes
16:55:15 <Tomasso> mhhm ddarius, yes, but i dont know what to put in the base case..
16:55:35 <ski> i've actually been thinking of making a program-inferrer that would infer part of a program, based on the type .. :)
16:55:37 <Tomasso> im a newbie!! aaah :D
16:56:19 <ski> Tomasso : lucky you :)  you can have the pleasure of learning many cool things
16:56:44 <Tomasso> ahahahah Yeah
16:57:18 <Tomasso> but give me the def!!
16:57:21 <ski> Tomasso : hmm, (not sure, but) i think there is just gonna be one case, if you do it the simple way
16:57:24 <Tomasso> :D
16:57:49 <Tomasso> ski: what do you mean by simple way, is there a more dificult one?
16:57:54 <ski> foldGen (Gen a ...) = ...
16:58:18 <ski> what would you write at the first "..." ?
16:58:36 <Tomasso> i think base case=f gen a []=f a []
16:58:56 <Tomasso> but i have problemes with the inductive case
16:59:08 <ddarius> Tomasso: Look at what is provided to foldGenTree and try to make the types match up.
16:59:12 <ski> (ITYM "foldGen f (Gen a []) = f a []", yes ?)
16:59:52 <ski> (mustn't forgot the f)
17:01:31 <Tomasso> would be the inductive  case = f( gen x xs) = f x[foldgen f xs]
17:02:47 <ski> that doesn't seem to typecheck
17:03:40 * ayrnieu yawns.
17:03:43 <Tomasso> how would you doo it?
17:03:59 * shapr yawns too
17:04:02 <shapr> I want to sleeep
17:04:11 <shapr> but I haven't finished my homework
17:04:48 <ski> well, if you match the [GenTree a] arg of Gen against [] in one case, shouldn't probably you match it against something like (t:ts) in the other case ?
17:05:08 <ayrnieu> shapr - Do you not trust yourself to be able to wake up a little earlier tomorrow to do it on a well-rested mind?
17:05:28 <shapr> no, not really.
17:06:09 <ayrnieu> shapr =)  I just finished re-learning that lesson.
17:06:37 <shapr> it's best that I finish it now, then sleep. then tomorrow I'll see what I actually missed tonight.
17:17:01 <Pseudonym> I actually learned C# last week.  I feel so dirty.
17:17:07 <shapr> Pseudonym: ew!
17:17:13 <Pseudonym> I know!
17:17:14 * shapr gets the eleven foot pole.
17:17:14 <mgoetze>  /kickban Pseudonym 
17:17:18 <mgoetze> oops :)
17:17:24 <Pseudonym> I was paid to do it.
17:17:32 * Pseudonym did not prostitute himself, honestly
17:17:44 <ski> so they all say ..
17:18:17 <Pseudonym> It's kind of the bastard child of Java and C.
17:18:25 <mgoetze> Pseudonym: repenteth! and writeth 500 lines of haskell to cleanse thineself!
17:20:31 <Pseudonym> Believe me, C# programming is its own penance.
17:21:08 <ski> so, what do you think of Properties ?
17:21:20 <Pseudonym> Didn't get that far.
17:21:45 <Pseudonym> I almost threw up when I saw "foreach".
17:21:46 <ski> (guess you didn't get to unsafe and pointers, then, too)
17:21:53 <Pseudonym> No, I didn't.
17:22:09 <Pseudonym> "foreach" itself is fine.  If it supports IEnumerator, you can do "foreach" on it.
17:22:25 * mgoetze likes perl's foreach
17:22:27 <ski> so ?
17:22:28 <Pseudonym> But you can ALSO do "foreach" on anything which looks like IEnumerator, even if it isn't.
17:22:42 <Pseudonym> I has flashbacks of STL concepts.
17:22:55 <Pseudonym> Not good.
17:23:15 <ski> what does "looks like" mean in this context ?  have some methods ?
17:23:25 <mgoetze> foreach $foo (@bar) { push @baz, $foo; }
17:23:32 <Pseudonym> Yes, so long as it supports the same methods as IEnumerator.
17:23:42 <Pseudonym> Even if it doesn't technically support the interface.
17:23:55 <Pseudonym> So what's the bloody point of having IEnumerator at all?
17:24:05 <ski> hmm, what's the point of implementing the interface in that case, one could think ..
17:24:08 <ski> yes
17:24:13 <Pseudonym> Precisely.
17:24:22 <Pseudonym> Type safety?  What type safety?
17:24:51 <mgoetze> well, it's either a scalar, an array, or a hash. sounds safe to me!
17:24:53 <ski> perhaps this is related more to abstraction (boundaries) or encapsulation ..
17:24:53 <ayrnieu> mgoetze - @baz = (@bar, @baz)
17:24:58 <Pseudonym> Oh, and you can use keywords as identifiers by putting @ before them.
17:25:06 <Pseudonym> if (@if) { }
17:25:21 <mgoetze> ayrnieu: TIMTOWTDI :)
17:25:22 <Pseudonym> Unfortunately, I have to concede that there was a good reason for that.
17:25:33 <ayrnieu> push @baz, $_ for @bar
17:25:39 <ski> which was ?
17:25:53 <Pseudonym> C# is designed to glue bits written in other languages together, and they don't necessarily agree with you on what constitutes a keyword.
17:26:26 <Pseudonym> So they _are_ going to export names that are your keywords, and you _will_ have to get access to them.
17:26:34 <Pseudonym> Somehow.
17:26:45 <Pseudonym> Shudder.
17:27:08 <ayrnieu> It's inherited Java's system-more-powerful-than-language genes!
17:27:11 <ski> so @foo is equivalent to foo, then ? (provided foo isn't a keyword)
17:27:23 <Pseudonym> I believe so.
17:28:10 <Pseudonym> Anyway, enough ranting.  Need food.
17:28:11 <Pseudonym> BBL
17:31:32 <ayrnieu> getAddr :: IO (Maybe (String, Integer))
17:32:33 <ayrnieu> It'd easier to understand what this does if it returned (HostName, PortNumber), but that's less useful.
17:38:27 <shapr> ski: um, how do they say "high of 5 degrees and low of 2 degrees" in swedish?
17:38:51 <ski> shapr : what does it mean ? :)
17:39:01 <shapr> hög av 5 grader, minse av 2 grader
17:39:10 <ski> shapr : latitude and longitude on maps ?
17:39:13 <shapr> when the weather person is talking about how hot or cold the day will get
17:39:27 <shapr> on the news
17:39:29 <ayrnieu> Degrees celsius?  That's *cold*
17:39:45 <shapr> ayrnieu: we had -15° a coupla days ago
17:39:54 <ski> shapr : high is positive and low is negative ?
17:40:07 <shapr> I think so
17:40:57 <ski> shapr : hmm, perhaps "5 plus-grader" resp. "2 minus-grader"   (dunno why you used "and" above, between them)
17:42:01 <ayrnieu> shapr av ski minse Pseudonym
17:42:13 <shapr> because the highest and the lowest degrees of the day are said at the same time
17:42:23 <ski> shapr : as in "inatt går temperaturen ner till 2 minus-grader"
17:42:48 <ski> aha, ok, the highest and lowest temp.s
17:43:22 <ski> ayrnieu : heh
17:44:18 <ski> hmm, in what context did/do the above english appear ?
17:48:07 <shapr> I was asking how the news people give their weather report in swedish
17:49:12 <ski> yes, but i currently doesn't remember what/how they say/talk about highest resp. lowest temp.s
17:49:39 <shapr> ok
17:49:48 <ski> so perhaps if you provide a full english sentance (or more), i could perhaps remember   :)
17:50:48 <shapr> the weather people in the US say "today the high for Lulea is 20 degrees, and the low will be 10 degrees. For Haparanda, the high is 22 degrees, and the low is 6 degrees"
17:51:22 <ayrnieu> And today we should have a high of 5 degrees and a low of 2 degrees, thanks to high front coming in from the west.  High for the week is estimated at 7, and the average temperature as 3.25 -- so don't throw all your cold-weather clothing away just yet.
17:51:42 <ayrnieu> also, 'high pressure front'
17:53:25 <shapr> yah, that sort of thing
17:53:36 <shapr> I think I'll give in and finish this tomorrow morning.
17:53:49 <ski> hmm perhaps "dygnets högsta temperatur i Luleå var 20 (plus-)grader, och den lägsta kommer att bli(/vara ?) 10 (plus-)grader. I Haparanda var topp-temperaturen 22 (plus-)grader och den lägsta blir 6 (plus-)grader"   perhaps something like that .."
17:54:23 <ski> 'high pressure front' is 'högtrycksfront'
17:54:25 <shapr> aha
17:54:42 <shapr> that's great! thanks :-)
17:54:55 <shapr> ski: if you ever need help with your homework ;-)
17:54:58 <shapr> feel free to ask me
17:55:13 <ski> no prob ;)
18:07:39 <mgoetze> suomalaiset on outoja.. -20'C on lämmintä. +20'C on paahtavan kuuma ja +80'C saunassa on kylmä.
18:10:39 <ski> ddarius : ((re IO in Joy), i vaguely seem to remember that it was done in a was somewhat similar to Matthias Felleisens evaluation contexts, can't find it one the Joy page right now, though)
18:13:51 <ski> hi flippo
18:14:48 <flippo> ski: howdy
18:14:49 <flippo> ski: you remind me of someone I knew on dalnet :)
18:14:57 <ski> heh
18:14:58 <flippo> (no couldn't be the same person, not on this channel)
18:15:24 <ski> don't think so  (i'm not even sure what exactly dalnet is :)
18:15:52 <flippo> another now almost extinct network
18:16:03 <ski> (well, i guess it is some irc network, but more i don't know)
18:16:09 <ski> ok
18:16:48 <mgoetze> almost extinct? so it does still exist? :)
18:17:00 <ski> so you've used functional before ?  Scheme ? Lisp ?
18:17:14 <ski> (f. programming, i.e.)
18:20:29 <flippo> mgoetze: there are apparently websites where you can find currently active servers, but they don't last long
18:20:50 <flippo> I've decided to pick up Thompson's book again
18:21:24 <flippo> So far, I read books about Haskell as I would read books about group theory.
18:21:34 <ski> (that's the one i have)
18:21:38 <flippo> Fun to read, but I'm not quite sure what to do with it yet.
18:21:45 <ski> :)
18:22:01 <flippo> My favorite book is Rabhi and Lapalme
18:22:17 <ski> on what ?  title ?
18:22:23 <flippo> "Algorithms"
18:22:44 <flippo> "a functional programming approach"
18:23:11 <ski> ok, haven't read that
18:23:36 <flippo> It's not the best first book, but it opened my mind the most
18:24:16 <flippo> http://www.iro.umontreal.ca/~lapalme/Algorithms-functional.html
19:37:25 <ayrnieu> System.Console.Readline seems to stop threading.  Sigh.
19:37:59 <ski> it is blocking all threads ?
19:39:08 <ayrnieu> I wrote a little test program to spawn one thread that emits characters endlessly while the main thread endlessly calls readline and prints what it got.
19:40:39 <ayrnieu> The other thread manages to get in sometimes with emissions before and after "Got: foo!" from the main thread, but emits nothing when the readline prompt comes up.
19:44:17 <ski> hmm
19:44:49 <ayrnieu> also, this is GHC.
19:45:03 <ski> could it be related to the aaabbb example at http://www.haskell.org/ghc/docs/5.00/set/sec-scheduling.html ?   hmmm
19:45:45 <ski> IIRC the standard IO primitives in GHC should not be whole-system-blocking
19:46:22 <ski> no, oops, worng link :(
19:46:38 <ayrnieu> ski - I don't think so, since that would require GHC to lack preemptive threading
19:47:10 <ayrnieu> ski - and the aaabbb example is about threads having control for longer that someone might expect -- not about threads keeping control forever.
19:49:14 <ayrnieu> also, I'm not talking about the 'standard IO primitives' so much as I'm talking about System.Console.Readline =)
19:49:39 <ski> i seem to vaguely remember some gotcha described in ghc doc which was about something like this, i think ...  if i only could find it :(
19:49:45 <ayrnieu> I imagine that the problem is that this library is implemented in terms of GNU Readline, and the C code doesn't no how to interact with GHC threading.
19:52:02 <ski> i can't find the ghc docs for System.Console.Readline RN, link ?
19:52:52 <ayrnieu> They're in a seperate toplevel
19:53:46 <ayrnieu> http://www.haskell.org/ghc/docs/latest/html/readline/index.html
19:55:16 <ski> tnx
19:55:34 <ski> wasn't there a threadsafe in the FFI report ?
19:55:44 <ayrnieu> also, I don't understand 'RN'
19:55:57 <ski> RN = right now
19:57:34 <ski> i can't remember RN exactly what it did, but i was trying to see if it could perhaps be used for making non-system-blocking foreign calls ...
19:59:50 <ski> hmm, see e.g. http://www.haskell.org/pipermail/haskell/2002-March/009140.html
20:01:24 <ayrnieu> I probably don't have --enable-threaded-rts, since this is just the build that OpenBSD ports gave me.  I've never, ever been able to build GHC.
20:01:56 <ayrnieu> But I'll try adding that flag to ports and see if it can manage this.
20:03:33 <ski> mm
20:03:33 <ski> good luck
20:04:36 <ayrnieu> Oh, I can't even do that -- the OpenBSD port works by starting from generated C sources.
20:06:20 <ski> :(
20:59:13 <Pseudonym> OK, that's better.
20:59:18 <Pseudonym> Much simpler Mutex interface.
20:59:21 <Pseudonym> newMutex :: IO Mutex
20:59:25 <Pseudonym> withMutex :: Mutex -> IO a -> IO a
20:59:39 <Pseudonym> It's even exception safe.
21:01:55 <ayrnieu> What Mutex interface were you used to?
21:02:12 <Pseudonym> There wasn't one previously.
21:02:15 <ayrnieu> And what does that do?  I'm not familiar with 'traditional' threading mechanisms.  Can you explain it in terms of MVar?
21:02:19 <Pseudonym> But I proposed one a few hours ago and realised it was way too complex.
21:02:31 <Pseudonym> Actually, even better, I can explain it in terms of QSem.
21:02:50 <Pseudonym> Or even better, I can explain it without that.
21:02:59 <Pseudonym> Basically, withMutex m op runs op.
21:03:27 <Pseudonym> However, it ensures that only one thread is doing a withMutex on a given mutex at any given time.
21:05:04 <ozone> Pseudonym: very nice
21:05:45 <Pseudonym> It's exception-safe because if the operation throws an exception, the mutex is closed.
21:05:45 <ayrnieu> Indeed, that is nifty.
21:05:59 <Pseudonym> The nice thing is that I can implement MVars using this.
21:06:14 <Pseudonym> data MVar a = MVar Mutex (IORefBase a)
21:06:28 <Pseudonym> (Note: IORefBase is like IORef, but for various reasons isn't.)
21:06:37 <Pseudonym> (You can think of it as an IORef.)
21:06:41 <ayrnieu> I've no idea what QSem does, since it's neither described in concurrent-haskell.ps nor in the GHC documentation.  /me ask google.
21:06:53 <Pseudonym> QSem is a semaphore.
21:07:11 <Pseudonym> newtype Mutex = Mutex QSem
21:07:19 <Pseudonym> withMutex (Mutex sem) op = bracket_ (waitQSem sem) (signalQSem sem) op
21:07:24 <Pseudonym> Almost trivial
21:07:29 <ayrnieu> I've already said that I don't understand traditional threading mechanisms -- I've only ever used Concurrent Haskell and Erlang and Forth and such.
21:07:40 <Pseudonym> newMutex = newQSem 1 >>= return . Mutex
21:07:46 <ski> Pseudonym : nice :)
21:07:46 <Pseudonym> Right.
21:09:11 <ski> ayrnieu : so forth has non-traditional threading mechanism ?
21:09:26 <ozone> Pseudonym: what's an IORefBase?
21:10:53 <Pseudonym> Ah, that's part of my grand plan.
21:10:54 <ayrnieu> ski - Forths traditionally use round-robin threading with named tasks that operate with their own HERE and stacks.
21:11:14 <ayrnieu> ski - with a PAUSE (and implicit PAUSE in every IO operation) to task-switch
21:11:21 <Pseudonym> A RefBase associated with some monad is its "standard" reference type.
21:11:35 <Pseudonym> So, for example, IO :: IORefBase as ST :: STRefBase
21:11:49 <ski> ayrnieu : ok. a variant of cooperative, then ?
21:11:50 <Pseudonym> In GHC at the moment, MVar is also a "standard" reference type.
21:12:04 <ski> ayrnieu : HERE ?  heap ?
21:12:12 <Pseudonym> By making it a type built on top of IORef, that makes things a bit cleaner.
21:13:01 <Pseudonym> I checked this stuff into haskell-libs but it hasn't shown up on the web cvs interface yet.
21:14:14 <ayrnieu> ski - you could say that HERE is a pointer into heap
21:15:07 <ski> ayrnieu : mhm
21:15:09 <Haldol> gd afternoon
21:15:33 <ski> Haldol : good morning
21:16:06 <ayrnieu> OK, QSem makes sense.  But what does QSemN do?
21:16:29 <ski> "quantity semaphores"
21:16:44 <Pseudonym> They're not so useful.
21:16:52 <ayrnieu> ski - sure -- but what are they?
21:16:55 <Pseudonym> I'm guessing that somebody wanted them for some specific reason.
21:17:14 <ski> used for representing a resource which is not just like a boolean
21:18:03 <ski> hmm, like the 5 eating-sticks in the classing dining philosopher's problem (with 5 philosophers)
21:18:21 <ayrnieu> erm, my understand of QSem is that it's a mechanism for one thread to wait for another thread's OK before proceeding.  I don't understand what a 'non-boolean' form of this would take.
21:18:38 <Pseudonym> ayrnieu: It's technically more than that.
21:19:20 <ski> to extend the thinking to QSemN, think of a QSem as a sort of variable cell which can only contain 0 or 1
21:19:27 <Pseudonym> You can think of a semaphore as a bucket containing tokens.  There are two operations: Put a token in (i.e. signalQSem) or take a token out, waiting if there are none there (i.e. waitQSem).
21:19:37 <ski> yes
21:19:39 <Pseudonym> However, a QSem can start with more than 0 or 1 tokens.
21:19:52 <Pseudonym> As I understand it, QSemN lets you take N tokens at once.
21:19:57 <ski> a QSem starts with an initial value of 1
21:19:58 <Pseudonym> Waiting if there aren't enough.
21:20:34 <Pseudonym> newQSem :: Int -> IO QSem
21:20:39 <Pseudonym> It starts with whatever value you like.
21:20:46 <ski> a QSem starts with as high a natural value as you want (probably within a word, though)
21:20:49 <ayrnieu> Pseudonym - oh, OK.  A 'source' thread could use QSem to make it known how many tokens it has generated, and a 'sink' thread could use QSem to wait for a certain number of tokens to accumulate before trying to access them.
21:21:00 <Pseudonym> Right.
21:21:11 <ski> and you can require more than one at a time, which is useful
21:22:00 <ski> ayrnieu : say we have   qsemn <- newQSemN 5
21:22:12 <Pseudonym> There's one other operation on semaphores which is occasionally useful: supply a token to anyone who is waiting for one.
21:22:26 <ski> ayrnieu : to be able to eat, a philosopher needs 2 eating-sticks
21:23:09 <ski> ayrnieu : so we could try to aquire (grab) one, and then, after that has succeeded, we grap another one, then we eat
21:24:58 <ayrnieu> Pseudonym - is that not defined in Control.Concurrent.QSem?  I only see waitQSem and signalQSem, which don't seem like they could allow a thread to tell if anyone is waiting for its QSem.
21:25:15 <ski> ayrnieu : but it is better to grab two at the same time. because if there is currently, say 1, free stick, it is unnecessary (and bad) to acquire it and then wait for another. so we wait (block) until at least two is available, then atomically grab 2 of them
21:25:47 <ayrnieu> ski - especially if two philosophers reach and the same time and each get one of the last two chopsticks =)  OK.
21:26:00 <ayrnieu> also, at the same time.
21:26:22 <ski> yes, exactly
21:27:20 <ski> Pseudonym : well ?  (what other operation ?)
21:28:14 <ayrnieu> Maybe with QSemN, and a (waitQSemN 0) -- if that works
21:28:40 <Pseudonym> No, it's not defined.
21:28:49 <ayrnieu> No, I've no idea why I'd think that might work.
21:30:12 <Pseudonym> Sorry, I mentioned the other operation.
21:30:20 <Pseudonym> Basically, give anyone a token who wants one.
21:30:42 <ayrnieu> Wouldn't MVar make more sense for that?
21:30:50 <ski> (hmm, seems the code in hugs Semaphore.hs isn't special-casing  waitQSemN 0)
21:30:55 <Pseudonym> No, not really.
21:31:09 <Pseudonym> What you want this for is a "condition variable".
21:31:14 <ski> Pseudonym : with what interface ?
21:31:21 <Pseudonym> Probably this:
21:31:31 <Pseudonym> broadcastQSem :: QSem -> IO ()
21:31:43 <ayrnieu> Pseudonym - oh.  Sorry, I was still thinking in terms of 'source' and 'sink' threads.
21:32:04 <Pseudonym> Yes.  In this case, broadcast becomes a source for anyone who wants one at that moment.
21:32:28 <Pseudonym> The idea is that a number of threads may be waiting for something to happen.
21:32:41 <Pseudonym> broadcastQSem tells them all that it's happened.
21:33:52 <ayrnieu> (ski - that has funny implicatons on your philosopher example -- where six philosophers can reach and once and each get two chopsticks, and where one philosopher reaching before the other five will get the only two chopsticks.)
21:34:50 <ski> Pseudonym : you sure broadcast had with semaphores to do, and not conditions ?
21:35:25 <Pseudonym> Sorry, didn't understand that question.
21:35:30 <ayrnieu> Pseudonym - that does seem very useful =(  I wonder how it could be simulated with the currently available functions.
21:36:07 <Pseudonym> What I want it for, of course, is to implement condition variables. :-)
21:36:24 * keir can't find the equivalent of the 'map' function in matlab/octave. gah!
21:36:25 <ski> Pseudonym : should broadcastX really be an operation on QSem rather than CondVar ?
21:36:34 <Pseudonym> Why not?
21:36:40 <ayrnieu> This would be more useful for when all the philosophers are waiting for the elevator to arrive on the ground floor.
21:36:43 <Pseudonym> It has a perfectly reasonable semantics.
21:37:37 <ski> hmm, only one thread is actually gonna get the token, hmm ?
21:40:04 <ayrnieu> ski - I think that Pseudonym wishes for broadcastQSem to give as many tokens as threads are listening -- which makes sense for event signaling, when all the philosophers are waiting for the elevator door to open.
21:40:55 <Pseudonym> Right.
21:41:20 <ayrnieu> broadcastQSem q = QSemNListeners q >>= \n -> signalQSemN q n
21:41:24 <Pseudonym> Once everyone who is listening has their token, broadcastQSem returns.
21:41:34 <ski> but there must be that many tokens to begin with, i.e. with QSem, only one is available. with QSemN one say at creation how many is available ..
21:41:46 <Pseudonym> ski: There is no conservation of tokens.
21:41:55 <Pseudonym> You can signal as many times as you like.
21:42:14 <Pseudonym> And you can wait but not return a token.
21:42:55 <ski> hmm, that is very possible. easy to comfuse the many similar-looking concepts.. :(
21:43:03 <ayrnieu> (where QSemNListeners :: QSemN -> IO Int)
21:43:53 <ski> hmm
21:49:06 <Pseudonym> And the problem with that definition is that it's not atomic.
21:49:11 <ayrnieu> I don't see any conceptual difference between broadcastQSem and signalQSem -- except that these would probably be used very differently.
21:49:11 * ski is looking at slides from the "Concurrent Programming" course here at gu/chalmers
21:49:14 <Pseudonym> The number of listeners may have changed.
21:49:46 <ddarius> ayrnieu: signalQSem only signals -one- of the waiting threads, broadcastQSem signals -all- of them.
21:49:51 <ski> Pseudonym : what definition is not atomic ?
21:50:19 <ayrnieu> ddariust - I understand that -- that's the difference that makes them interesting.  That doesn't sound like a confusing conceptual difference.
21:50:33 <Pseudonym> broadcastQSem q = QSemNListeners q >>= \n -> signalQSemN q n
21:50:38 <ayrnieu> Or is it unclear from 'signal' and 'broadcast' which does which?
21:50:45 <Pseudonym> Not atomic.
21:52:06 <ski> (oh, yes, QSemN's can also be used to model bounded Channels/Queues/Buffers)
21:52:43 <ddarius> ayrnieu: I misunderstood what you meant, nor am completely sure I understand now.  You were responding to ski?
21:53:07 <ayrnieu> ddarius - to ski's complaint that these seemed like many easy to confuse similar-looking concepts.
21:54:24 <ski> ayrnieu : no, i meant that simple locks, semaphores, conditions variables, etc  was easy to confuse  (for me, at least)
21:54:49 <ayrnieu> ddarius - I'm assuming that the confusion comes from the Channels/Queues/Buffers/Elevator-openned-yet? that QSem and friends could implement rather than any confusion of the functions of these functions.
21:56:50 <ski> ayrnieu : (because (IIRC :) each provide an acquire-like and a release-like operation, which doesn't behave in exactly the same way (of course). maybe it's just me ..)
21:57:04 <ayrnieu> ski - I suppose that it would be easier to understand QSem if it were better named -- if it didn't imply (since it's barely documented, anyway) that it was only useful for semaphores.
21:58:44 <ski> well, IIRC semaphores was said to be a rather general (and low-level) thing, so they were useful for a lot of different applications ..
21:59:26 <Pseudonym> Semaphores date WAY back.
21:59:33 <Pseudonym> 1950s, I think.
21:59:35 <ski> yes
21:59:51 <Pseudonym> Invented by Dijkstra,
21:59:53 <ski> who was it ?   hoare ? dijkstra ? 
21:59:56 <ski> ok
22:00:06 <ayrnieu> So why do you put them on the same level as simple locks and condition variables? -- though, if I read you correctly, 'condition variables' wouldn't work at all for broadcastQSem, since broadcastQSem only 'gives tokens' to threads that are listening when it (broadcastQSem) is called.
22:00:44 <ayrnieu> Oh, but that would work.
22:01:11 <ski> ayrnieu : hmm, see http://www.hawksoft.com/hawknl/docs/nlCondBroadcast.html in HawkNL
22:01:18 <ayrnieu> (No, nevermind)
22:01:54 <Pseudonym> E.W. Dijkstra, Cooperating sequential processes, Academic Press, 1968.
22:01:57 <Pseudonym> OK, not to the 50s
22:02:40 <ski> ayrnieu : (well, because of the acquire/release similarities, i had some trouble remembering which specific special cases belonged to which of the different abstractions ..)
22:03:06 <ski> and then came Monitors, IIRC
22:03:18 <ayrnieu> aside: what is the use of merge and nmerge?
22:03:35 <ski> where ?
22:03:50 <ayrnieu> defined in Control.Concurrent
22:05:42 <ski> "The mergeIO and nmergeIO functions fork one thread for each input list that concurrently evaluates that list; the results are merged into a single
22:05:42 <ski>  output list."
22:05:52 <ayrnieu> ski - Yes, I read that.
22:07:16 <ayrnieu> also, I suppose that readline stops threading through the simple means of not allocating any memory (and thereby not allowing GHC to thread-switch) while waiting for input.
22:08:22 <ski> ayrnieu : hmm, yes, that may be what i tried to find as some aaaabbbb example in ghc !
22:09:35 <ddarius> ayrnieu:  Presumably, (n)mergeIO is mainly intended for lazy IO.
22:10:09 <ayrnieu> ddarius - how would it be used to that end?
22:10:32 <ski> hGetContents, perhaps ?
22:12:12 <ddarius> yes
22:12:34 <ayrnieu> The description seems to imply that mergeIO might be used to evaluate (and collect the results of) a list of functions -- but the type description doesn't fit with that.
22:14:10 <ski> ayrnieu : yes, see last paragraph there, thats the aaaabbbb example i was looking for (and didn't find) !  :-D
22:14:27 <ayrnieu> is hGetContents supposed to return a string containing everything readable from a handle, then?
22:14:56 <ski> yes
22:15:02 <ski> lazily
22:18:55 <ddarius> ayrnieu: mergeIO could also be used for avoiding getting stuck in an infinite subtree of a non-deterministic computation.
22:21:35 <ayrnieu> 'lazily' implies to me that I could do something like (hGetContents h >>= \s -> forkIO $ hPutStr h s) and instantly have a neat little 'echo' that'd write back to h as long as h writes to me -- but what seems to happen is that hGetContents waits for... something.  EOF?  How is this lazy?
22:22:56 <ddarius> ayrnieu: the problem there is likely hPutStr which is waiting for the end of the string.
22:22:57 <ayrnieu> Oh, nevermind.  Buffering =)
22:23:10 <ayrnieu> hSetBuffering h NoBuffering -- and that works
22:23:35 <ddarius> ayrnieu: or the problem is buffering :P
22:23:35 <ayrnieu> buffering on the output stream, I presume.
22:32:32 <ayrnieu> NoBuffering seems to work like (BlockBuffering $ Just 1) which gives me two writes for every read -- one to write one character (not so good for networking -- the delay is visible!) and then whatever else it finds.  BlockBuffering of anything larger has the same visible artifacts (set it to 2 and notice a slight pause between the write of the first two characters and the rest), and the unfortunate effect that it doesn't do anyt
22:32:32 <ayrnieu> hing until that many characters.  (BlockBuffering Nothing) causes writing to block.
22:33:42 <ayrnieu> What'd I'd like is for this operation to block until some data is received, and then for it to hurry and write as much as it can find all at once before blocking again.  It doesn't look as if I can use hSetBuffering and hGetContents to do this.
22:35:08 <ayrnieu> listenToServer h = hSetBuffering h PacketBuffering >> {- ... -}
22:35:51 <ddarius> Use a separate read handle and write handle (or possibly hSetBuffering when reading and writing though that doesn't seem right)
22:38:55 <ayrnieu> A seperate read and write handle wouldn't help -- the only reason these are the same is so that I can have a little 'echo server' for telnet(1) to communicate with.  More complex code that waits for data to become available and then reads all of it at once (to then write all at once) seems to be the only way to go.
22:39:15 <Pseudonym> Must go home.  Nytol.
22:39:41 <ayrnieu> Before I knew what hGetContents did, I assumed that its purpose was to read everything.
22:40:00 <ski> nonlazily ?
22:41:09 <ayrnieu> No.  Not lazy.
22:41:33 * ayrnieu looks at hWaitForInput ... sigh.  Is documentation too much to ask?
22:41:50 <ayrnieu> or hGetBuf -- that looks like it might be useful.  Any idea what it does?
22:42:55 <ski> (some docs there in ghc library docs seems to be very thin and empty, except for type signatures  :(   )
22:43:20 <ayrnieu> Most of them, yes.
22:43:35 <ski> what module(s) ?
22:43:42 <ayrnieu> It's an astonishing culture of non-documentation.
22:43:56 <ski> (re: hWaitForInput and hGetBuf, i.e.)
22:44:36 <ayrnieu> ski - GHC.IO
22:45:19 * ski yuurgh
22:46:04 <ayrnieu> The plethora of academic papers online about Haskell is really nice, and helpful, but I still waste so much time looking at a function that I could've immediately understood if the writer had so much as one line in documentation.
22:47:13 <ayrnieu> for hWaitForInput, how about "block for at most Int seconds, returning True if (hReadable Handle) is true, and False otherwise"
22:47:24 <ayrnieu> but I don't know if that's correct.
22:48:19 <ski> hmm, i suspect that "hGetBuf h p n" tries to read n (or less, but not more) bytes from the (input) stream associated with the handle h, storing them succesively at the pointer p, and then returns the actual number of bytes it read (which probably is always > 0)
22:48:19 <ayrnieu> hWaitForInput "block until (hReadable Handle) returns True (returning True) or until Int seconds have passed (returning False"
22:48:51 <ayrnieu> ski - yes, that would be *exactly* the function I could use for my networking -- but what is a Ptr?
22:49:32 * jasonw_ is doing a different Honors route than the dept honors, BTW, bjorny although they both work the same as far as capstone, etc.
22:49:40 <jasonw_> Sorry wrong window.
22:50:33 <ddarius> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/GHC/IO.hs?rev=1.19&content-type=text/x-cvsweb-markup
22:50:39 <ddarius> Ptr is an FFI type
22:50:40 <ayrnieu> The GHC.IO document helpfully links Ptr in the type description to the document for the Foreign module -- which still doesn't tell me how to produce a Ptr, where they come from, or even what they are.  I guess that they only come from C-land, and that hGetBuf therefore is only useful in interaction with C-land.
22:51:40 <ski> hmm, i seem to recall that "hWaitForInput h n" checks if at least n bytes are available for input from h, right now, without blocking,  though i'm not totally sure :(
22:52:48 <ski> ayrnieu : http://www.haskell.org/ghc/docs/latest/html/base/Foreign.html#Ptr  it is like a (void *) in C, i think ..
22:52:49 <ayrnieu> Actually, I might have better luck with abandoning the Network module and using low-level sockets.
22:54:10 <ski> ayrnieu : look up the FFI report http://www.cse.unsw.edu.au/~chak/haskell/ffi/  ;)
22:54:22 <ayrnieu> Fortunately I know the interface well enough to deal with the state of Network.Socket's documentation.
22:54:28 <ayrnieu> ski - OK.  Thanks.
22:54:53 <ski> ayrnieu : no, you can malloc and free a Ptr from haskell too :)
22:55:45 <ayrnieu> Oh, phew, somebody wrote an academic paper.
22:55:46 <ski> (that's one thing that marshalling often does (from haskell-side, i.e.))
22:57:57 <ski> ayrnieu : perhaps this page can help a little also http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/lab2-hints.html ?
23:01:59 <ski> ayrnieu : (also http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/lab2.html seems to say some more on Sockets, blocking and webservers)
23:03:20 <ayrnieu> Not really, but it's interesting =)
23:04:47 <ski> also, http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/Lab2-2003/Chunk.hs is a creative use of unsafePerformIO  ;)
23:04:56 <ayrnieu> yowza, but the Chunk.hs hGetBufNonBlocking is interesting
23:10:53 <ski> yes
23:11:21 <ayrnieu> What do you call something that is not automatically generated?
23:11:34 <ski> like what ?
23:12:37 <ayrnieu> A program, or a specification, or documentation, or a database.
23:12:41 <ddarius> manually generated
23:13:07 <ayrnieu> I was hoping for something more concise -- but that works, I guess.
23:13:19 <ski> hand-generated or generated by hand, also
23:14:04 <ski> or programmer-generated / programmer-written  if you like (and applicable)
23:48:17 * shapr yawns
