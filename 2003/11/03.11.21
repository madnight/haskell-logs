01:53:12 <shapr> @yow
01:53:13 <lambdabot> RELATIVES!!
01:54:35 <harsha123> shapr hello
01:54:46 <shapr> hi harsha123 
01:54:50 <harsha123> are you a sqiud expert? :)
01:54:57 <harsha123> squid, sorry
01:56:43 <harsha123> am facing a few problems with squid, need help. i know this is the wrong plz but....
01:56:56 <harsha123> need *help* 
01:57:13 <harsha123> :)
03:17:59 <TripleDES> morning
03:18:10 <shapr> hiya
03:18:52 * Marvin-- ponders if he can hold his breath until this is on /.
03:19:20 <shapr> until what is on slashdot?
03:19:30 <Marvin--> http://cert.uni-stuttgart.de/files/fw/debian-security-20031121.txt
03:19:49 <shapr> yikes
03:19:57 <Marvin--> uh-huh
03:20:14 <Marvin--> I've known it for a few hours
03:20:21 <shapr> have they figured out how the crackers got in, and what was affected?
03:20:23 <Marvin--> (I got up, ate breakfast, read debian-private...)
03:21:40 <Marvin--> of course, it just *had* to coincide with the release of 3.0r2
03:30:51 <Marvin--> ah wlel
03:30:56 * Marvin-- tries to focus on his project
03:32:12 * shapr has the urge to add ipv6 support to GHC
03:32:21 <shapr> I know, If I wait just a bit, this urge will pass.
05:17:46 <ham[let]> moin
05:22:34 <SyntaxPolice> harsha123: I'm alergic to squid
08:19:55 <SyntaxPolice> shapr: what would you think of fgl being hosted at haskell-libs?
08:20:05 <SyntaxPolice> shapr: also, can a bug category for each project be added to the bug list?
08:20:14 <SyntaxPolice> we should puff-up the to-dos and bugs for each item.
08:37:45 <SyntaxPolice> lamer
08:37:46 <SyntaxPolice> ;)
08:53:22 <Igloo> heh
08:55:02 <SyntaxPolice> hey Igloo, how's life.   I haven't played your song yet. I promise I will. If you have a newer version, send it to me.
08:55:04 <SyntaxPolice> is it too late?
08:56:54 <TAndrad> hello
08:56:55 <TAndrad> someone here?
08:59:51 <SyntaxPolice> hi TAndrad
08:59:59 <TAndrad> hi SyntaxPolice
09:00:08 <TAndrad> sorry, but i will ask a dumb question :)
09:00:21 <TAndrad> how do i code f(x:real):=5* (sin(x)/cos(x))
09:00:22 <TAndrad> ?
09:01:31 <SyntaxPolice> f is a function from real to real, right?
09:01:39 <SyntaxPolice> so the type sig is "f :: Double -> Double"
09:02:02 <SyntaxPolice> it can actually be more general, but we don't have to worry about that for now.
09:02:10 <SyntaxPolice> This funciton is very easy to write in haskell.  Is this for a class?
09:02:17 <TAndrad> not actually
09:02:34 <TAndrad> i want to see if the interpreter will return some error
09:02:47 <TAndrad> can you please tell me how to code it?
09:02:51 <SyntaxPolice> which interpreter are you using?  in Hugs, you can't define functions on the top level.
09:03:37 <TAndrad> why?
09:04:00 <SyntaxPolice> it has to do with the idea that Haskell is purely functional :), but you can use ghci to do so, or you can load a file into hugs with the :load command.
09:04:17 <TAndrad> ok
09:04:25 <TAndrad> supposing i have ghc
09:04:29 <TAndrad> what should i type?
09:04:59 <SyntaxPolice> (I personally recommend using hugs w/ emacs and loading in buffers)
09:04:59 <SyntaxPolice> in cany case, your function in haskell is:
09:04:59 <SyntaxPolice> f x = sin x / cos x
09:05:12 <SyntaxPolice> in the ghc top level, you can type: let f x = sin x / cos x
09:05:16 <TAndrad> i mean 5*(sin(x)/cos(x))
09:05:21 <TAndrad> so
09:05:28 <SyntaxPolice> sorry
09:05:31 <TAndrad> let f x = 5 * (sin x / cos x)
09:05:31 <TAndrad> ?
09:05:35 <SyntaxPolice> yeah
09:05:52 <TAndrad> no f :: Double -> Double before?
09:05:53 <shapr> whee
09:05:59 <SyntaxPolice> the type sig is optional
09:06:03 <TAndrad> ok
09:06:05 <TAndrad> wait to check
09:06:16 <SyntaxPolice> the type of f is actually:
09:06:17 <SyntaxPolice> f :: forall a. (Floating a) => a -> a
09:06:26 <SyntaxPolice> unless you restrict it to doubles
09:06:45 <SyntaxPolice> hey shapr did you see my comments up around 11:20?
09:06:46 <Lunar^> hello shapr on ipv6
09:06:49 <TAndrad> but should the compiler generate any error on this function?
09:07:56 <SyntaxPolice> TAndrad: I don't think there are any compile-time errors with that function.
09:08:37 <TAndrad> what i want to know if the compiler is smart enough to infer that because you have a division cos(x) must be <>0 so that means that x must be <>0 
09:08:56 <TAndrad> then the compiler should generate an error: Double include x=0
09:09:12 <shapr> Lunar^: hello Lunar^ on ipv4 ;-)
09:09:12 <TAndrad> error: for x=0 in f, an error would be generated
09:09:16 <shapr> SyntaxPolice: nej, what comments?
09:09:19 * shapr checks logs
09:09:30 <TAndrad> SyntaxPolice? is that possible?
09:09:53 <SyntaxPolice> for the compiler? not really.
09:09:54 <shapr> oh
09:09:57 <SyntaxPolice> at least not in the general case
09:10:05 <SyntaxPolice> but it can catch it at runtime, of course
09:10:06 <shapr> sure, feel free to stick FGL into haskell-libs
09:10:13 <shapr> isn't Martin Erwig the author?
09:10:18 <shapr> are you in contact with him?
09:10:29 <SyntaxPolice> shapr: I found that I couldn't access the bug components to create a component for each project
09:10:34 <shapr> and yes, bug categories can be added for each project
09:10:37 <SyntaxPolice> also, it's unclear from the front page which projects are hosted
09:10:45 <shapr> we have a front page?
09:10:47 <SyntaxPolice> shapr: yeah, I'm in contact with him.
09:10:53 <SyntaxPolice> well, the summary page anyway
09:10:54 <shapr> SyntaxPolice: want me to hook you up with an admin flag? ;-)
09:10:58 <SyntaxPolice> sure
09:11:03 <shapr> ok, just a moment
09:11:14 <shapr> I just got meds
09:11:17 * shapr dances happily
09:11:19 <SyntaxPolice> woohoo!
09:11:24 <SyntaxPolice> sooner than you thought!
09:11:24 <shapr> yes, code will fly :-)
09:11:28 <shapr> much sooner than I thought
09:11:44 <SyntaxPolice> we're expecting Great Things (pressure, pressure)
09:11:51 * shapr laughs
09:12:00 <SyntaxPolice> TAndrad: are you a pascal programmer?
09:12:08 <SyntaxPolice> TAndrad: what is your interest in haskell compilers?
09:12:12 <TAndrad> SyntaxPolice is there any language/compiler that can do that at compile time, not at run time?
09:12:14 <shapr> I'll be happy enough if I can get lambdabot cleaned up and release 2.0
09:12:35 <TAndrad> SyntaxPolice i'm coding in most mainstream lang. but my speciality is asm
09:12:37 <Lunar^> shapr: feel free to improve GHCi interfacing
09:12:44 <shapr> Lunar^: in what way?
09:12:46 <SyntaxPolice> TAndrad: I don't know of one.  in general it is not possible to detect division by zero at compile time.
09:13:03 <SyntaxPolice> in this specific case, it woudl be possible _sometimes_
09:13:05 <shapr> SyntaxPolice: you've got the power!
09:13:08 <Lunar^> shapr: cleaning, polishing, finding why it doesn't respond after a few days
09:13:16 <SyntaxPolice> but personally, I wouldn't want the compiler to reject my program just because I have f x = n / x
09:13:22 <shapr> ghci doesn't respond after a few days?
09:13:29 <shapr> the lambdabot plugin or GHCi itself?
09:13:48 <shapr> SyntaxPolice is now officially an admin of sf.net/projects/haskell-libs/
09:13:53 <SyntaxPolice> w00t
09:14:01 <SyntaxPolice> shapr: so what all are the projects hosted there?
09:14:08 <Lunar^> dunno. Didn't took time to look further, doing @dynamic-reload did the trick
09:14:11 <TAndrad> SyntaxPolice thanks for help
09:14:34 <shapr> SyntaxPolice: hws-wp, lambdabot, bunches of small things from Pseudonym, PDFlib from Lunar^, wiwiwi from sebc, umm...
09:14:59 <SyntaxPolice> shapr: in the popup list under auto-assign, I see only two developers
09:15:06 <shapr> oh, Fractal's crypto stuff is there, I should probably talk to Dominic Steinitz about either ripping it out of hlibs or hosting his cryptolibraries in hlibs
09:15:13 <SyntaxPolice> shapr: who's juhp?
09:15:20 <shapr> try /wi juhp
09:15:25 <SyntaxPolice> TAndrad: no problem!
09:15:43 <shapr> Jens Petersen, red hat/hircules/gtk/haskell/etc
09:15:45 <SyntaxPolice> unknown command :)
09:15:46 <SyntaxPolice> ah OK
09:15:55 <shapr> juhp: hello!
09:16:10 <SyntaxPolice> so OK if I make a category for each "product" we have hosted?
09:16:14 <shapr> sure!
09:16:18 <SyntaxPolice> can you add a list of the "products" to the summary?
09:16:43 <shapr> I
09:16:48 <SyntaxPolice> what's the diff btw category and group?
09:16:49 <shapr>  I dunno if the summary can hold that much of a list
09:16:55 <shapr> where?
09:16:57 <SyntaxPolice> what about a front page?
09:17:02 <SyntaxPolice> on the bug report section
09:17:05 <shapr> yes, a front page is a good idea
09:17:17 <shapr> what about pointing the front page to HaskellLibs or so on HaWiki?
09:17:24 <shapr> then it's easy to admin
09:17:57 <SyntaxPolice> are bug reports separate from feature requests in sf?
09:18:01 <SyntaxPolice> that sounds fine
09:18:10 <shapr> I think feature reqs are a flavor of bug
09:18:27 <shapr> many of these features weren't present when I started this project
09:18:38 <shapr> so I don't necessarily know anything more than you do :-)
09:18:43 <shapr> ah, tracks
09:18:44 <shapr> trackers
09:18:57 <shapr> bugs, feature requests, patches, support requests
09:19:08 <SyntaxPolice> cool, a package tracking system
09:19:18 <SyntaxPolice> this is confusing, we'll never get the haskell community to use it ;)
09:19:31 <SyntaxPolice> we'll need to write an executive summary
09:19:49 <SyntaxPolice> so are groups distinct for each category? i hope not
09:20:07 <shapr> I have no idea
09:20:13 <shapr> let's file some bugs and figure it out
09:20:23 * shapr submits a feature request "please add a home page"
09:20:57 <SyntaxPolice> yup. they are
09:21:06 <SyntaxPolice> damn. that's dum
09:21:07 <SyntaxPolice> b
09:21:23 <shapr> ohh, the "assign to" depends on which members have been listed as tracker people I think
09:21:33 <SyntaxPolice> lets add everyone!
09:21:38 * SyntaxPolice wants to assing you some bugs
09:21:57 <shapr> hehe
09:22:02 <shapr> ok, I think I've addded everyone
09:22:11 <shapr> er, maybe
09:22:35 <shapr> I'm adding everyone as technician
09:22:46 <shapr> or should that be both tech and admin?
09:23:25 <shapr> ok, t&a it is
09:23:35 <shapr> ok, now the pulldown should be larger
09:23:51 <SyntaxPolice> idono
09:24:11 <shapr> yes, pulldown is much larger now
09:24:27 <SyntaxPolice> I don't see anyone for feature requests
09:24:48 <shapr> idono
09:25:08 <shapr> can I submit a bug and categorize it as a FR?
09:25:37 <SyntaxPolice> I can't quite tell. looks like you submit a FR
09:25:49 <SyntaxPolice> they shoudl all share the groups and developers, imo
09:25:50 <shapr> oh
09:26:03 <shapr> I agree
09:26:32 <shapr> ok, I'll add everyone for FReq also
09:26:37 <SyntaxPolice> so odd
09:27:05 <shapr> done
09:27:49 * SyntaxPolice uses mind-powers against sf
09:28:01 <shapr> jedi lightning?
09:29:29 <shapr> Claus asked me why haskell-libs isn't hosted on haskell.org
09:32:07 <SyntaxPolice> it would be useful and good to have such things on haskell.org, but probably too much work for the payoff at the moment
09:32:09 <SyntaxPolice> what didyou tell him?
09:33:29 <SyntaxPolice> I mean, ultimately, haskell.org should have all of:
09:33:31 <SyntaxPolice> phpgroupware
09:33:35 <SyntaxPolice> cvs / darcs / arch repos
09:33:41 <SyntaxPolice> bugzilla-type software
09:33:52 <SyntaxPolice> or whatever; maybe something like savannah could be installed
09:35:46 * SyntaxPolice goes to lunch &
09:42:31 <shapr> I told him it wasn't on haskell.org because SPJ et al are towering mental giants, and occasionally scary to the average geek who wants to show up, write some code, and wander off to the next language
09:43:02 <shapr> and that haskell-libs was designed as a not terribly organized cvs-wiki for whoever wanted to show up and contribute or maintain code
10:01:01 <shapr> @fortune
10:01:01 * shapr pokes lambdabot 
10:01:01 <lambdabot> Whatever doesn't succeed in two months and a half in California will
10:01:01 <lambdabot> never succeed.
10:01:01 <lambdabot> 		-- Rev. Henry Durant, founder of the University of California
10:01:06 <shapr> hello?
10:06:34 <Lunar^> Who's managing haskell.org at this time ?
10:06:44 <shapr> I don't know
10:06:47 <shapr> oh
10:06:52 <shapr> john petersen and olaf chitil
10:06:57 <shapr> says at the bottom of the front page
10:07:05 <shapr> think I should request a darcs installation?
10:07:21 <Lunar^> dunno
10:07:30 <shapr> speaking of which, I gotta ask for better cvs/darcs synchronization from David
10:07:49 <shapr> I'd like to automatically mirror darcs on ScannedInAvian.org and haskell-libs on sourceforge
10:07:50 <Lunar^> But anyway, I really found something amazing with this language _and_ IRC channel
10:08:07 <shapr> yes, we're wonderful and we know it ;-)
10:08:10 <shapr> maybe we're not modest though...
10:08:11 * shapr grins
10:08:28 <Lunar^> A real community. It's sad not to have a website reflecting better this
10:08:46 <Lunar^> By "website" I mean more than that
10:08:48 <shapr> how could a website reflect this better?
10:08:50 <shapr> like what?
10:08:53 <Lunar^> what SyntaxPolice said earlier
10:09:11 <shapr> a list of projects in haskell-libs ?
10:09:18 <shapr> what else?
10:09:33 <shapr> oh, savannah, cvs / darcs / arch 
10:09:38 <shapr> hmm
10:09:39 <Lunar^> yes
10:09:46 <shapr> I'd be happy to host a plone site
10:09:50 <Lunar^> For hosting Haskell projects
10:09:57 <shapr> dunno about savannah or sourceforge
10:10:01 <shapr> but I'm willing to try it
10:10:12 <Lunar^> mhh.. SF is slow
10:10:17 <Lunar^> dunno about Savannah
10:10:20 <shapr> I mean SF the software
10:10:34 <Lunar^> I hate its UI
10:10:44 <shapr> are there better alternatives?
10:10:51 <Lunar^> I find it very very confusing and painful to use
10:11:08 <Lunar^> Couldn't we use our wounderful tool to do it ?
10:11:19 <shapr> ?
10:11:22 <shapr> wiwiwi?
10:11:33 <shapr> WASH?
10:11:35 <shapr> which tool?
10:11:40 <Lunar^> Maybe WASH would be well suited
10:11:47 <shapr> I'd like to try that.
10:11:57 <shapr> I'd feel better about a Haskell projects site written in Haskell.
10:12:05 <Lunar^> so do I
10:12:52 <Lunar^> I was thinking that maybe Template Haskell could be nice for CGI kind of work
10:13:29 <Lunar^> Because you always at least need to put everything in a <form> and then get that results back
10:13:50 <Lunar^> What about some meta-programming here ?
10:14:20 <shapr> like what?
10:14:56 <Lunar^> something higher level that will make both part at once
10:15:12 <Lunar^> Making the form and receiving its result
10:16:10 <shapr> can you make a prototype?
10:16:17 <shapr> or maybe a pseudo-code demonstration?
10:16:17 <Lunar^> geee
10:16:24 <Lunar^> If I could find the time
10:16:26 <shapr> ok
10:16:30 <Lunar^> mhh
10:16:40 <shapr> even something that doesn't work at all, but gives the idea, would be nice
10:18:00 <Lunar^> sometihng like : do user <- input "User:" 30 ; password <- input "Password:" 15
10:18:48 <shapr> hm
10:18:51 <Lunar^> And that would generate the code needed to display HTML, and the code needed to fetch form result
10:18:52 <shapr> sound spiffy
10:18:56 <shapr> yah, I see what you mean
10:19:17 <Lunar^> running what's next in this do construct when submitted
10:20:02 <shapr> that would be neat
10:20:40 <Lunar^> Ok... I've got my next project after corewar then
10:20:47 <Lunar^> damn
10:21:10 <shapr> heh :-)
10:21:16 <shapr> too many projects
10:24:47 <Lunar^> Gonna play with wxHaskell tonight
10:25:07 <shapr> cool
10:25:25 <Lunar^> Hope it'll be fast enough to render the memory state
10:43:14 <Igloo> Is it true to say "ML is generally compiled to bytecode"?
10:44:19 * Igloo tries to think if MetaML could be sensibly compiled to machine code
10:53:55 <Lor> Uh.
10:54:03 <Lor> ML can be implemented in a variety of ways.
10:54:07 <Lor> Like any other language.
10:54:59 <Lor> But I think that most "serious" implementations have native code compilers.
10:55:36 <Lor> I think that metaml or metaocaml could, theoretically, be implemented by actual run time machine code generation.
10:55:53 <Lor> Some lisps do that, I think.
10:58:52 <Lunar^> WxHaskell design pushes Haskell class system really far
11:05:16 <Igloo> OK, ta
11:07:25 <Lunar^> Unboxed tuples are written (# a, b #), right ?
11:14:00 <Igloo> Think so
11:14:45 <SyntaxPolice> shapr, Lunar^: as far as implementing a sourceforge or savannah-type thing in haskell, I'm against it.  There is pleanty of software to write without duplicating things that exist already.
11:15:11 <SyntaxPolice> also, there's a bootstrapping problem.  that's a big project that would require a cohesive community, which is what the project is trying to build :)
11:15:35 <Igloo> :-)
11:15:58 <SyntaxPolice> what do you think, Igloo? :)
11:15:59 <Igloo> If you do it piecewise it's probably not too bad. e.g. start with a decent bug tracker for the various Haskell projects
11:16:11 <Igloo> The SF bug e-mails are atrocious
11:16:26 <Igloo> I don't think the latest comment is necessarily even at one end of the mail or the other
11:16:26 <SyntaxPolice> so that solves the bootstrapping problem, but really, why reimplement shit just to do it in haskell
11:16:31 <SyntaxPolice> we need to take care of what we already have.
11:16:46 <SyntaxPolice> pardon my french
11:16:48 <SyntaxPolice> ;)
11:17:09 <SyntaxPolice> what is the haskell.org web server running anyway?
11:17:11 <Igloo> I would rather see something amazing and new in Haskell, agreed, but an amazing bug tracker would not be a bad thing
11:17:14 <SyntaxPolice> *bsd?
11:17:20 <SyntaxPolice> agreed.
11:17:24 <SyntaxPolice> it would take years, though.
11:17:45 <Igloo> Linux
11:17:54 <Igloo> RH
11:17:57 <SyntaxPolice> I think it would be moderately trivial to put bugzilla on haskell.org if it were debian :)
11:18:09 * SyntaxPolice has set up bugzilla on several debian machines now
11:18:22 <Igloo> Is that better?
11:19:08 <SyntaxPolice> is bugzilla better than sf? I don't know.
11:19:15 <SyntaxPolice> I haven't used sf much.
11:21:08 <shapr> I haven't used bugzilla at all, no idea
11:21:24 <shapr> otoh, I can install both SF and bugzilla on raven and we can try them
11:21:29 <Igloo> http://haskell.org/pipermail/glasgow-haskell-bugs/2003-September/003622.html is an example of one. It first has the original message, then the third message followed by the second message.
11:21:59 <shapr> I don't have the bandwidth to actually host a haskell projects dev site, but I can install things so we can try them
11:22:24 <shapr> hi diminished, got any Haskell questions?
11:22:30 <shapr> hello anduril1 
11:24:25 <SyntaxPolice> shapr: is savannah available to install on end-user systems?
11:24:41 <SyntaxPolice> nice thing about sf is that it integrates a variety of things.
11:24:55 <shapr> I don't know, I can find out.
11:26:24 <SyntaxPolice> it would be awesome if you could set them up on raven, post an email to the mailing list, and ask if ppl want them on haskell.org
11:26:36 <SyntaxPolice> not that this is really much better than using sf itself.
11:27:58 <shapr> no deb or tarball for savannah, only cvs tree
11:28:00 <shapr> hej phubuh 
11:28:06 <shapr> sourceforge has a deb
11:28:17 <phubuh> hej shapr!
11:29:14 <shapr> phubuh: what sort of features would you like to see for a sourceforge-style website for haskell?
11:30:27 <shapr> hiya scarface 
11:30:28 <phubuh> hmm... anonymous version control that lets you in more than once every twenty tries? :-)
11:30:35 <shapr> heh
11:30:47 <shapr> that's easy enough to do, since haskell.org probably won't be as flooded as sf.net
11:30:53 <phubuh> yeah
11:30:56 <scarface> shapr: hi how you doing?
11:31:10 <shapr> scarface: doing well
11:31:23 <SyntaxPolice> another problem w/ sf is that it look overly complicated. I think we need something w/ a really low initial investment.
11:31:31 <SyntaxPolice> (in order to convince ppl to actually use the thing)
11:31:35 <shapr> SyntaxPolice and I are talking about expanding haskell-libs.sf.net into a full sf.net style website
11:31:52 <shapr> what are the most basic features?
11:32:02 <shapr> source control and bug tracking?
11:32:05 <shapr> and web pages?
11:32:37 <shapr> darcs doesn't require user logins for each developer, that's one advantage it has.
11:32:45 <shapr> wiki is easy enough for web pages
11:33:04 <shapr> not good enough for bug tracking, though there may be some macros/processors/etc for moinmoin that do that
11:33:07 * shapr looks
11:33:52 <SyntaxPolice> shapr: actually, bug tracking and source control might be sufficient for now. we will want to expand it later ala library-infrastructure / cpan or whatever, but that'll have to wait anyway
11:34:28 <shapr> problem with haskell-libs is that almost no one really knows what's in there
11:34:30 <SyntaxPolice> otoh, sf has the ability to let many developers control releases without giving them complete access tot he web server
11:34:33 <shapr> so web pages of some sort would be handy
11:34:36 <SyntaxPolice> ja
11:38:46 * SyntaxPolice wonders why no one has packaged savannah
11:39:01 <SyntaxPolice> I get the feeling that a piece of software that's been around for many years and hasn't been packaged is probably not that interesting
11:39:04 <SyntaxPolice> except for haskell software ;)
11:39:44 <shapr> heh
11:40:21 <Lor> It'd be fun if someone packaged all the miscellaneous haskell libraries that are floating around the net into a single easy-to-install package.
11:41:11 <diminished> shapr: nah. don't have any ;]
11:41:33 <shapr> Lor: that's a good idea
11:41:46 <SyntaxPolice> Lor: in Debian, it should be a meta package
11:49:55 <ayrnieu> Does the wiki seem insufficiently indexed to anyone else?  I haven't fully explored it, yet.
11:50:42 <SyntaxPolice> ayrnieu: how do you mean? there could probably be more categories, etc.
11:50:54 <SyntaxPolice> if more should go on the front page, you should feel free to add it :)
11:52:06 <shapr> there's the backlinks you get from clicking the title, and the title and content word search boxes at the bottom of every page
11:52:23 <ayrnieu> OK.  I'll look further.
11:55:16 <shapr> y0 Darius 
11:55:20 <shapr> wassup?
11:55:59 <Darius> not much. Fiddled with the phone line but it still doesn't work right.
11:56:22 <shapr> what's broken?
12:04:30 <Lor> http://blort.org/~kgasso/images/how-to-catch-script-kiddies.gif
12:05:38 <Darius> shapr: 'have no idea.
12:07:01 <Lor> I'm sort of disappointed that none of the gurus on c.l.f have replied to my query on op sem.
12:09:31 <Darius> You may want to look at some of the papers on explicit substitutions, but I don't know how much they talk about operational semantics or how applicable it would be.
12:09:52 <Lor> No, I specifically don't want substitutions. I want an environment.
12:10:46 <Lor> I _can_ do small-step semantics with environments, that's not the problem. The question is just what is the prettiest way of doing it.
12:11:06 <Lor> That "use" hack is kind of icky, and abstract machines are kind of low-level, too.
12:20:00 <Darius> Lor: I would think the most straightforward way would be to add an environment component similar to a state component.
12:22:45 <Lor> Well yes, that's the abstact machine approach.
12:25:58 <SyntaxPolice> is there a nice way to show doubles only to, say, 2 decimal places?
12:26:14 <SyntaxPolice> I mean "show" in the Double -> String sense :)
12:27:25 <Lor> darius, you do know that mutable state can be formalized even without an explicit state component, right?
12:27:53 <Lor> eg. http://citeseer.nj.nec.com/wright92syntactic.html
12:30:06 <pimpbot5000> Lor: how is this?
12:30:28 <pimpbot5000> are you reffering to the GHC's ST monad?
12:30:38 <Lor> Not really.
12:31:10 <Lor> The idea is that you keep the state as part of the entire term, and then do _global_ transformations of the term at each reduction step that modifies the state.
12:31:27 <pimpbot5000> hmm
12:31:41 <pimpbot5000> is there any implementation of this in haskell?
12:31:48 <pimpbot5000> what would it look like?
12:31:48 <Lor> I don't remember what the actual advantage was over the traditional state component.
12:31:59 <Lor> Look at the paper.
12:32:08 <pimpbot5000> the types paper?
12:32:35 <Lor> Page 21.
12:33:17 <Lor> It's not really directly relevant to practical programming, just one way to formalize side effects as reduction rules.
12:33:23 <pimpbot5000> ah cool
12:33:41 <pimpbot5000> yea, the problem is haskell is lazy...that makes side effects painful to the max
12:34:16 <Lor> You could have monadic side effects in a strict language as well.
12:34:43 <Lor> Then again, direct side effects are much easier to use and to implement in a strict language, so those are then used instead.
12:34:55 <Lor> Though without the safety that monadic types provide.
12:35:07 <Lor> That's what effect systems ought to remedy, if someone just implemented them...
12:35:10 <pimpbot5000> right, monads are really the most convenient way to side effect in a lazy language
12:35:41 <pimpbot5000> the type system can't fix some problems with side effects in a lazy language
12:35:55 <pimpbot5000> unless the type system can strictify certain functions
12:36:24 <earthy> such as in clean with its Uniqueness Types.
12:36:33 <pimpbot5000> is clean lazy?
12:36:35 <earthy> yes
12:36:58 <Darius> Lor: (replying to earlier) Wouldn't that just be the state equivalent to substitution?
12:37:02 <pimpbot5000> hmm, so that's what happens in clean...the type system selectively strictifies functions?
12:37:02 <earthy> the stuff they do is really quite clever.
12:37:25 <SyntaxPolice> shapr: should this be deleted? http://www.haskell.org/hawiki/Pishcotec
12:37:39 <SyntaxPolice> actually, maybe this wiki doesn't allow things to be deleted
12:37:47 <Darius> pimpbot5000: The problem isn't strictness (though that makes it easier to not be confused)
12:37:55 <Lor> darius, not quite. substitution is complicated, since you have to have some system of replacing _multiple_ instances of a thing with another thing.
12:38:09 <earthy> pimpbot5000: no, the typesystem restricts the number of references to a certain value to 1.
12:38:13 <Lor> It's much easier to do C[a] --> C[b] (where C is a context)
12:38:18 <pimpbot5000> see here's the problem i encountered with side effects
12:38:21 <Igloo> Syn: I think there are functions for that
12:38:24 <Lor> ie. you replace a single term with another one.
12:38:38 <Lor> That's not really substitution, or then all term transformations are.
12:38:42 <SyntaxPolice> someone should fill in the missing stuff here: http://www.haskell.org/hawiki/FundamentalConcepts
12:38:42 <SyntaxPolice> :)
12:39:02 <SyntaxPolice> Igloo: if there were anything, there  would be functions :)
12:39:07 <SyntaxPolice> functions is what I want!
12:39:10 * Igloo is just looking
12:39:38 <SyntaxPolice> well, you don't have to be unlazy just because I'm too lazy not to be. i'll look it up myself if noone knows offhand
12:39:45 <Darius> SyntaxPolice: Module Numeric
12:39:45 <earthy> due to the fact that you then *know* that returning a different value for that reference does not change semantics, the compiler can then strictly execute it.
12:40:06 <Igloo> showFFloat and similarly named functions
12:40:19 <Igloo> In Numeric
12:40:36 <Igloo> The F means %f like in format strings IIRC
12:40:48 <Igloo> s/%f like/%f-like/
12:43:10 <pimpbot5000> let (t,m)  = readMtx mtx ix in 			   let (x,m') = readMtx m xi in 			   let m'' = writeMtx m' x ix in 			   writeMtx m'' t xi
12:43:40 <pimpbot5000> the readMtx here must be evaluated first for this to work
12:44:22 <pimpbot5000> it is in this case, because m' is passed to writeMtx...but otherwise there is no guarantee of readMtx being evaluated first
12:45:40 <shapr> SyntaxPolice: I dunno who that Pishcotec guy is, feel free to delete it
12:47:46 <SyntaxPolice> maybe I could mark it for garbage collection :)
12:50:14 <shapr> then we can get someone to sweep
12:51:25 <SyntaxPolice> I wouldn't want to delete it if it's someone on here
12:51:37 * shapr dunno
12:52:23 <shapr> I wonder if it's someone on EFNet or QuakeNet
12:58:15 <pimpbot5000> hmm does anyone know much about comonads?
12:59:17 <shapr> ask esap 
13:00:14 <pimpbot5000> k
13:00:26 <SyntaxPolice> thanks for the showffloat advice :)
13:00:42 <pimpbot5000> esap: do you have a simple example of a comonad that has side effects?
13:00:54 <pimpbot5000> and what is the main detractor of using comonads?
13:02:39 <shapr> I got the impression from esap that there aren't any downsides to comonads
13:02:45 <shapr> just that most people don't understand them.
13:02:59 <shapr> hej jrosdahl, behover du hjälp med Haskell?
13:03:17 <pimpbot5000> hmm, on this paper im reading there is one downside.  the program has to be a comonad at the top level
13:03:22 <jrosdahl> shapr: Nope. At least not right now. :)
13:03:24 <shapr> jrosdahl: or maybe you're just learning Haskell? would you like some introductory info?
13:03:45 <shapr> pimpbot5000: on the other hand, Pseudonym said he found some problems with the comonads paper
13:03:57 <shapr> he said some part of it was unsafe when he tried to implement it.
13:04:06 <shapr> so you should probably ask Pseudonym as well when he's around.
13:04:12 <pimpbot5000> ok cool
13:04:13 <pimpbot5000> thanks
13:04:28 <shapr> not that I have any clue about comonads myself.
13:05:12 <jrosdahl> shapr: Oh, thanks for the offer. Maybe another time!
13:05:38 <shapr> the first foldr is free ;-)
13:06:10 <pimpbot5000> hmm this says haskell would need a linear typing system to make use of comonads
13:07:23 <Lor> Hee. file: 203 MB. file.bz2: 21MB. file.bz2.bz2: 1MB
13:07:27 <shapr> jrosdahl: oh, if you're learning Haskell, you might want to check out the lambdabot sources.
13:09:27 * shapr grooves to Soul Coughing
13:15:23 * shapr boings
13:15:37 <shapr> @yow
13:15:38 <lambdabot> ..  Should I get locked in the PRINCIPAL'S OFFICE today --
13:15:38 <lambdabot>  or have a VASECTOMY??
13:15:41 <SyntaxPolice> hm. music would be good
13:15:48 <shapr> SyntaxPolice: yes! Soul Coughing!
13:16:01 <shapr> have you heard them?
13:21:42 <SyntaxPolice> nope.
13:21:49 <SyntaxPolice> good stuff?
13:21:52 <shapr> what sort of music do you listen to?
13:21:54 <shapr> yah, they're great
13:21:57 <SyntaxPolice> good music :)
13:22:43 <shapr> anything specific?
13:23:44 <TripleDES> hi
13:23:47 <shapr> re TripleDES 
13:23:48 <SyntaxPolice> lets see. i'm listening to ladytron rihgt now. I want to hear more techno, but I don't know what's good. like belle & sebastian a lot lately, as well as moxy fruvus
13:24:17 <shapr> TripleDES: writing any cool code?
13:24:53 <shapr> SyntaxPolice: have you tried The Crystal Method?
13:25:08 <TripleDES> shapr: the coursework
13:25:12 * shapr isn't sure what qualifies as techno
13:25:15 <shapr> TripleDES: something fun?
13:25:54 <Darius> damn balanced keyboard layout...
13:26:05 <SyntaxPolice> nope
13:26:09 <TripleDES> well, it have to take a text from the stdin, search for '\t' and replace it for blank spaces, the number of blanks must be given by parameters
13:26:12 <shapr> Darius: ??
13:26:20 <shapr> trying to type with one hand?
13:26:32 <shapr> I think dvorak keyboards should come with straws.
13:26:57 <Darius> straws?
13:27:36 <shapr> Darius: so you can drink fluids and type at the same time ;-)
13:27:44 <Darius> shapr: Actually, yes the balanced layout is annoying when typing one-handed, but I was just referring to the most common mistake I make now, which is typing things out of order.
13:28:05 <shapr> oh, that happens to me too
13:28:05 <Darius> So I get things like www.haskell.rog and such.
13:28:08 <shapr> hehe
13:28:09 <shapr> me too
13:28:23 <Lor> me too.
13:29:22 <shapr> I'm occasionally tempted to hack the location field in galeon to do reverse words so I can tab complete from less letters, org.haskell.www -> o<tab>ha<tab>
13:30:51 <Lor> you don't need the www hostname too much these days.
14:02:56 <det> shapr, maybe a prefix meaning it is in reverse, ",org,haskell,www" or ",o<tab>ha<tab>"
14:08:29 <Darius> Well technically, it's 'www.haskell.org.'
14:24:01 <det> Darius: are you sure that isnt just a bind convention ?
14:28:36 <Darius> Pretty sure.
14:36:37 <TripleDES> any tips to work with IO data as a String or something...?
14:37:36 <SyntaxPolice> TripleDES: what do you mean?
14:37:54 <SyntaxPolice> if you're getting a string from IO, then say outputting the lenght, it might look like this
14:38:04 <SyntaxPolice> do s <- yourIOFunction
14:38:07 <SyntaxPolice>   putStrLn s
14:38:51 <TripleDES> I'm getting text from stdin with getLine or getContents and then I need to search some characters inside of it
14:39:22 <SyntaxPolice> it might look like this:
14:39:27 <SyntaxPolice> do s <- getLine
14:39:42 <SyntaxPolice>     let functionOutput = doSearchFunction s
14:39:50 <SyntaxPolice>     putStrLn s
14:39:55 <SyntaxPolice> or putStrLn functionOutput
14:40:37 <SyntaxPolice> you use "<-" to get the string out of the IO monad, then you can operate on it like a regular string.
14:40:40 <TripleDES> and doSearchFunction can be String -> String ?
14:40:49 <SyntaxPolice> in this case, it would be yeah
14:40:53 <SyntaxPolice> but it could be String -> Whatever
14:40:56 <Lunar^> How does pattern matching on a record work ?
14:41:12 <TripleDES> Thanks SyntaxPolice I'm going to try
14:41:18 <SyntaxPolice> TripleDES: cool. let me know :)
14:41:21 <TripleDES> ok
14:41:25 <SyntaxPolice> TripleDES: remember: whitespace counts in do operations
14:41:34 <TripleDES> :))
14:43:57 <Darius> Lunar^: f (MyRec { foo = x }) = x
14:44:13 <Lunar^> Darius: strange... wasn't working
14:44:44 <Lunar^> Darius: can you do : f (Rec { foo = Cons l }) = .. ?
14:46:42 * Lunar^ hopes Wolfgang will find time to speed GHC on OS X
14:48:55 <TripleDES> SyntaxPolice: it's working thanks ;)))
14:49:25 <SyntaxPolice> cool!
14:50:02 <TripleDES> I can continue now
14:50:05 <TripleDES> :))
14:51:19 <Darius> Lunar^: Don't know, don't think I've ever tried.
14:51:26 <Lunar^> Darius: ok thanks
14:52:41 <SyntaxPolice> TripleDES: you might find htis helpful: http://www.haskell.org/hawiki/ThatAnnoyingIoType
14:54:14 <Darius> Lunar^: yes, f (Rec { foo = (x:xs) }) = x works.
14:55:26 * SyntaxPolice goes home
14:57:29 <TripleDES> thanks SyntaxPolice 
14:57:35 <Lunar^> waow it links
14:57:53 <Lunar^> first try with wxHaskell... see if it'll work
14:58:17 <Lunar^> takes a loooong time to link
15:04:07 * shapr boings
15:06:24 <shapr> @run-away!
15:06:25 <lambdabot> Sorry, I don't know the command "run-away!", try "lambdabot: @listcommands"
15:07:18 <Lunar^> Nice :( It's so slow to draw that it just stalls
15:08:26 <shapr> do you have the code online?
15:08:33 <Lunar^> nope
15:10:43 <Lunar^> I'm going to try to run the quickstart example
15:23:35 <blackdog> dumb question: anyone know of a read function that returns a Maybe type?  I'm thinking readMaybe :: String -> Maybe a
15:24:12 <Lunar^> DYI
15:24:16 <Lunar^> DIY sorry :)
15:25:18 <Darius> blackdog: reads will probably work for you.
15:28:54 <Lunar^> I think I should have listen to sebc
15:29:10 <Lunar^> Haskell seems way too much slow for what I need
15:30:04 <Lunar^> HGL seems faster.. maybe I should try with it
15:34:23 <shapr> hi diminished 
15:36:39 <Lunar^> System.Posix.DynamicLinker is badly documented :(
15:39:49 <Lunar^> How could I run a FunPtr ?
15:43:24 <Lunar^> mhhhh the lambdabot seems better
22:00:02 <mgoetze> if i have a function which takes a paramenter of [[a]], how do i write a pattern to match (1) the first list and (2) the list of the remaining lists?
22:01:31 <Smerdyakov> How is this specific to [[a]]?
22:02:15 <mgoetze> well to be honest it's actually [[Int]], but i thought it's not so important what the lists in the list are of
22:02:50 <Smerdyakov> I think it's not even important that it's a list of lists, unless I've misunderstood your question.
22:03:47 <mgoetze> well my code wasn't doing what i wanted it to... :)
22:05:19 <mgoetze> more specifically i get a non-exhaustive patterns exception currently
22:05:38 <Smerdyakov> Well, you've said you want to match the first list, but there may not be one.
22:05:54 <mgoetze> sortTuple :: [[Int]] -> [[Int]]
22:06:02 <mgoetze> sortTuple [[]] = [[]]
22:06:09 <mgoetze> sortTuple (x:xs) = ...
22:06:28 <mgoetze> that seems to be non-exhaustive according to ghc 6.0
22:06:30 <Smerdyakov> That doesn't cover an empty list.
22:07:15 <mgoetze> oh, so i should change [[]] to []?
22:07:40 <Smerdyakov> If you want to match an empty list, then you should match an empty list. :D
22:07:58 <mgoetze> duh... ok, it works now :)
22:08:58 <mgoetze> right, almost done now...
22:14:55 <mgoetze> not having a delete key sure is annoying
22:18:47 <ayrnieu> mgoetze - you probably don't really want to match [[]]
22:18:54 <ayrnieu> also, what is 'delete key' and what would it do?
22:19:12 <ayrnieu> (or do you mean on your keyboard?)
22:19:35 <mgoetze> ayrnieu: delete key is the one that, when i'm in insert mode, removes the character just after the cursor
22:20:17 <ayrnieu> That's C-d in Emacs =)
22:20:25 <mgoetze> in fact it does that in command mode too but that's not so important since other keys will do the same thing
22:24:45 <mgoetze> hm.... is there such a thing as O(n!) complexity?
22:25:38 <Smerdyakov> What are you asking?
22:26:03 <mgoetze> i'm doing something with permutations :)
22:27:13 <Smerdyakov> Yes, but what did you mean with your question?
22:27:38 <mgoetze> specifically, i'm trying to find out for which n there is an n-permutation which, added in order to the numbers 1..n, modulo n, gives an n-permutation
22:27:53 <mgoetze> well, i'm just wondering whether such things are recognized as existing
22:28:12 <mgoetze> i've only ever heard of O(n^2), O(n ln n) and things like that
22:28:46 <mgoetze> based on the emprirical evidence given by my haskell program, i'd say n needs to be odd
22:28:50 <Smerdyakov> O is a functional defined on any real function of integers.
22:29:37 <Smerdyakov> If you can define a function, then O of it is well-defined.
22:30:33 <mgoetze> now that i've finished the easy part (write a haskell program so i know what to prove), i think i'll take a break before the hard part (proving it mathematically) ;)
22:31:04 <Smerdyakov> You should also review what O is, I think.
22:31:24 <mgoetze> well, i'm not studying computer science, so... :)
22:32:00 <Smerdyakov> Regardless of what you're studying, using notation you don't understand isn't that good of an idea.
22:32:31 <mgoetze> i think asking questions about it is ok, whereas making assertions with it isn't ;)
22:33:34 <clausen> Smerdyakov: what is the type of O?
22:33:54 <clausen> O -> (R -> R) -> (R -> R) -> Bool ?
22:34:17 <Smerdyakov> Do you mean the first -> to be :: ?
22:34:20 <clausen> yes
22:34:20 <clausen> sorry
22:35:22 <Smerdyakov> Looks right.
22:36:07 <clausen> R+ I guess :)
22:37:06 <mgoetze> guess this will take hours for n = 11 and days for n = 12... i really should get the new ghc6 package for mac os x
22:37:51 * mgoetze has an old version which is "unregisterized" or whatever it was called when it's not fully ported to an architecture
22:37:54 * clausen wonders about multi-parameter intput thingies
22:37:59 <clausen> things like O(mn)
22:39:56 <Smerdyakov> I think it works the same with a reasonable ordering on tuples.
22:40:29 <clausen> so, what's its type?
22:41:12 <clausen> eg: O(n) <= O(mn)
22:41:31 <clausen> O : (R^n -> R) -> (R^m -> R) -> Bool ?
22:41:54 <Smerdyakov> Maybe: O :: Ordered t => Ordered s => (t -> s) -> (t -> s) -> Bool
22:42:05 <Smerdyakov> (I don't know if I got the syntax for two type classes correct.)
22:42:17 <clausen> (m, n) tuples need not be totally ordered?
22:42:41 <Smerdyakov> I think that Ordered means "totally ordered."
22:42:50 <clausen> right
22:42:58 <clausen> my point is: is this overly restrictive?
22:43:07 <clausen> (why do we need ordering?)
22:43:19 <Smerdyakov> Because O is defined in terms of ordering on both domain and range values.
22:44:29 <Smerdyakov> Hm. And s needs to be compatible with multiplication by a natural number.
22:44:34 <clausen> in the (m, n) case, isn't it just partial ordering?
22:44:47 <clausen> so, we have a module?
22:44:52 <clausen> (as in algebra)
22:45:28 <Smerdyakov> Maybe a partial order is appropriate. Can't say I've ever thought about this before. :)
22:45:46 <clausen> :)
22:46:00 <clausen> its interesting to imagine a haskell implementation of O
22:46:05 <clausen> (obviously an undecidable problem...
22:46:08 <clausen> but heuristics, etc.)
22:46:37 <Smerdyakov> Not undecidable if you restrict the ways you can construct functions to pass to it.
22:46:48 <clausen> good point
22:47:07 <clausen> is it possible for polynomials?
22:47:15 <clausen> or does it end up being equivalent to finding roots of polynomials?
22:47:36 <Smerdyakov> I was talking more about allowing only symbolic functions.
22:47:43 <Smerdyakov> Not actual Haskell functions.
22:47:48 <clausen> yep
22:47:49 <clausen> me too
22:47:53 <clausen> polynomials :)
22:48:07 <Smerdyakov> Then you just find the highest exponent and it's O(n^that)....
22:48:09 <clausen> polynomials in multiple variables aren't principal ideal domains
22:48:24 <clausen> ooops, obvious :)
22:48:27 <Smerdyakov> Also Theta(n^that).
22:48:48 <clausen> O(mn) <= O(m^2) ?
22:49:15 <Smerdyakov> I don't know. I don't think I've ever read or heard any explanation of what multi-variable asymptotic bounds mean!
22:49:44 <Smerdyakov> But do you mean \subseteq by <=?
22:49:57 <clausen> no, all though that might be sane also
22:50:18 <Smerdyakov> Well, the usual <= isn't exactly applicable there.
22:50:40 * clausen consults Cormen...
22:53:24 <clausen> Cormen claims O notation should only be used on natural numbers
22:53:38 <clausen> (anything else is "abuse" (?))
22:55:07 <Smerdyakov> Well, it's used in a book for which he's listed as an author. :D
22:55:43 <clausen> true...
22:55:51 <clausen> he also claims it's useful to abuse it :0
22:56:21 <clausen> I think for multiple variables, the definition is just the same
22:56:22 <clausen> i.e.
22:56:29 <clausen> O(mn) = O(x) where x = mn
22:56:58 <Smerdyakov> I don't understand what function of a single variable x is meant to denote....
22:57:03 <clausen> but that doesn't explain how to compare O(mn) and O(mn^2)
