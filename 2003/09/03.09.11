00:00:07 <shapr> yah, I need to come up with a new one.
00:00:11 <Pseudonym> I just implemented quicksort.
00:00:15 <shapr> in haskell?
00:00:20 <Pseudonym> No, in C++.
00:00:22 <shapr> eww
00:00:31 <harsha123> shapr: morning
00:00:32 <Pseudonym> It's not your average quicksort, though.
00:00:34 <shapr> I can do it in Haskell in a tiny amount of code :-)
00:00:38 <shapr> goood morning harsha123!
00:00:46 <Pseudonym> EVERYONE has implemented quicksort in Haskell. :-)
00:00:53 <shapr> from the delta to the DMZ, it's freezin outside.
00:00:55 <harsha123> shapr: had a good nite's sleep?
00:01:09 <shapr> yes, I fell asleep on my swedish book.
00:01:16 <Pseudonym> Comfy!
00:01:16 <shapr> did you sleep well?
00:01:17 <harsha123> shapr: hehehe
00:01:26 <Pseudonym> Nothing like curling up with a good Swedish book.
00:01:51 <shapr> this is a book to teach Swedish vocabulary, it's actually surprisingly interesting.
00:02:06 <shapr> it's about this girl who worked on an assembly line and now has a job as a journalist.
00:02:29 * harsha123 needs to cut some sleep :(
00:02:30 <shapr> anyways...
00:03:06 <shapr> Pseudonym: what's different about your quicksort?
00:03:13 <harsha123> shapr: whats diff. from yesterday ? :)
00:03:25 <shapr> harsha123: I'm older?
00:03:42 <harsha123> shapr: hehehe..
00:04:09 <Pseudonym> Well, it's what it's for.
00:04:31 <Pseudonym> We have to handle multiple keys, and the "best" way to sort on some keys depends on the key.
00:05:20 <Pseudonym> So there are two issues here.
00:05:57 <Pseudonym> One is that we need to sort on multiple keys.  There is an issue because down near the "leaves" of quicksort, you don't want to be comparing on top-level keys if you know they're already equal.
00:06:27 <Pseudonym> The other is that occasionally you want to _stop_ quicksort and hand off an interval of equal keys to some other sort algorithm.
00:06:40 <shapr> hm, interesting
00:07:04 <Pseudonym> The solution to both problems is a different partitioning algorithm.
00:07:32 <Pseudonym> "Standard" quicksort picks a pivot element and partitions into two groups: [ x | x <- xs, x <= pivot ] and [ x | x <- xs, x > pivot ]
00:07:35 <Pseudonym> Or something similar.
00:08:09 <Pseudonym> In-place quicksort often allows equal keys in the right-hand partition, too.
00:08:17 <Pseudonym> This one partitions into three groups:
00:08:38 <Pseudonym> [ x | x <- xs, x < pivot ], [x | x <- xs, x > pivot] and [ x | x <- xs, x == pivot ]
00:09:02 <Pseudonym> Then with the "equal" partition, you can either hand it off to some other sort algorithm, or recursively invoke quicksort with the next key in the chain.
00:09:20 <Pseudonym> Of course it's not actually implemented recursively.
00:10:39 <shapr> how do you know when to hand off?
00:11:51 <Pseudonym> Ah, well I treat each chain of keys separately.
00:12:23 <Pseudonym> So the chain for each invocation of quicksort is the maximal subchain for which quicksort is the best algorihtm.
00:12:39 <shapr> and how do you decide that?
00:12:58 <shapr> or is that the commercially valuable part of your code? :-)
00:13:08 <Pseudonym> Well that's complicated.
00:13:27 <Pseudonym> It's all indirect.
00:13:31 <Pseudonym> Let me try to explain.
00:13:35 <Pseudonym> This is a database server.
00:14:00 <shapr> I still have some swedish homework to do, so if it's very complicated, I'll probably have to bail out in the middle....
00:14:13 <Pseudonym> I think I can explain it succinctly.
00:14:21 <shapr> ok, I want to hear it :-)
00:14:31 <Pseudonym> In a relational database server, you have tables with columns.
00:14:39 <shapr> yah
00:15:01 <Pseudonym> To a first approximation, columns are what you search on, what you sort on and also what you extract.
00:15:02 <shapr> I'd guess the query optimizer can figure out which parts of a query need what flavor of sort?
00:15:14 <shapr> that makes sense
00:15:26 <Pseudonym> Right.
00:15:38 <Pseudonym> Now in our text database, none of this is true.
00:15:50 <Pseudonym> Generally, you search on words, but extract whole documents.
00:15:54 <Pseudonym> For example.
00:15:58 <shapr> that makes sense also
00:16:02 <Pseudonym> Right.
00:16:22 <Pseudonym> In fact, there need be no relation whatsoever between what you search on, what you extract and what you sort on.
00:16:48 <Pseudonym> This is, in fact, something we enforce.
00:16:54 <Pseudonym> If you want to query on it, you have to define an index.
00:17:23 <Pseudonym> If you want to extract (in Z39.50 jargon, "present") it, you have to define that too.
00:17:34 <Pseudonym> And, similarly, if you want to sort on it, you also have to define that.
00:17:45 <Pseudonym> We call such a thing a "sortdex", by analogy with "index".
00:17:54 <shapr> nifty
00:18:07 <Pseudonym> And each sortdex knows how best to sort its sort keys.
00:18:14 <shapr> oh
00:18:20 <Pseudonym> Just like how each index knows how best to search for its query terms.
00:18:30 <Pseudonym> e.g. B-trees vs hashing
00:18:35 <Pseudonym> (Not that we use hashing.)
00:18:40 <shapr> that makes sense also
00:18:56 <Pseudonym> So, for example, sorting on record number is very different from sorting on a field in a record.
00:19:09 <Pseudonym> Because sorting on record number doesn't require accessing the record store.
00:19:10 <shapr> right
00:19:22 <Pseudonym> See?  It was succinct.
00:19:34 <shapr> truly :-)
00:19:44 <Pseudonym> I personally don't like the name "sortdex".
00:19:50 <shapr> well, it's descriptive.
00:19:52 <Pseudonym> But nobody could think of anything better.
00:19:57 <Pseudonym> It's also marketing-friendly.
00:20:09 <Pseudonym> But if you think about it, there are a lot of interesting possibilities.
00:20:21 <Pseudonym> An index is basically an on-disk data structure which avoids the need for grepping.
00:20:39 <Pseudonym> Searching is, in theory, possible without an index.
00:20:55 <shapr> yah
00:21:09 <Pseudonym> Similarly, a sortdex is, in principle, any on-disk data structure which avoids the need for extracting keys and then sorting them.
00:21:34 <Pseudonym> Lots of possible ways to do that.
00:23:23 <Pseudonym> Anyway, I'm done.
00:23:28 <Pseudonym> Gotta go home soon.  So night all!
00:23:46 <shapr> cya Pseudonym 
00:27:12 <shapr> hi magr 
00:27:43 <magr> hi
00:28:03 <shapr> how's berlin today?
00:28:15 <magr> shapr: you seem to be never idle--are you a bot? :)
00:28:30 <magr> well, cloudy, sometimes raining
00:28:48 <shapr> hah
00:28:54 <shapr> I don't think I'm a bot.
00:29:18 <Verbed> shapr: That's _exactly_ what a sharp bot would would say.
00:29:35 <shapr> a sharp bot or a shapr bot?
00:29:50 <shapr> gee, I hope I pass my turing test.
00:30:03 <magr> if I wrote a bot, I would not let him know he is one
00:30:21 <magr> is there a lambdabot command to find out?
00:30:39 <shapr> whether he's a bot or not?
00:30:58 <shapr> @y0
00:30:58 <lambdabot> Sorry, I don't know the command "y0", try "lambdabot: @listcommands"
00:31:03 <shapr> lambdabot: hey
00:31:04 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
00:31:41 <Verbed> I think it's a facade lambdabot uses to avoid paying taxes.
00:31:54 <magr> seems he isnt sure, either
00:32:15 <magr> lambdabot: @listcommands
00:32:15 <lambdabot> I react to the following commands: ["all-dicts","define","definitions","del-definition","devils","dict","dict-help","dummy","dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements","eval","foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","lojban","more","msg","part","prelude","quit","reconnect","
00:33:15 <shapr> lambdabot has a decent sized TODO list, including cutting long lines into @more
00:33:23 <shapr> plus @more is broken and I don't know why...
00:34:49 <magr> lambdabot: @elements
00:35:03 <shapr> @elements fr
00:35:04 <lambdabot> No match for "fr".
00:35:07 <shapr> hm
00:35:11 <shapr> @dict-help
00:35:12 <lambdabot> I perform dictionary lookups via the following 14 commands:
00:35:12 <lambdabot> @all-dicts .. Query all databases on dict.org
00:35:12 <lambdabot> @devils ..... The Devil's Dictionary
00:35:12 <lambdabot> @easton ..... Easton's 1897 Bible Dictionary
00:35:12 <lambdabot> @elements ... Elements database
00:35:12 <lambdabot> @foldoc ..... The Free On-line Dictionary of Computing
00:35:14 <lambdabot> @gazetteer .. U.S. Gazetteer (1990)
00:35:16 <lambdabot> @hitchcock .. Hitchcock's Bible Names Dictionary (late 1800's)
00:35:18 <lambdabot> @jargon ..... Jargon File
00:35:20 <lambdabot> [6 @more lines]
00:35:21 <shapr> @more
00:35:22 <lambdabot> wrong type (<<[] Char>>) in ModuleState
00:35:24 <Verbed> @elements Fire
00:35:24 <lambdabot> No match for "Fire".
00:35:29 <shapr> @elements francium
00:35:30 <lambdabot> *** "francium" elements "Elements database 20001107"
00:35:30 <lambdabot> francium
00:35:32 <lambdabot> Symbol: Fr
00:35:34 <lambdabot> Atomic number: 87
00:35:36 <lambdabot> Atomic weight: (223)
00:35:38 <lambdabot> Radioactive element, belongs to group 1 of the periodic table. Found in
00:35:40 <lambdabot> uranium and thorium ores. The 22 known isotopes are all radioactive, with
00:35:42 <lambdabot> the most stable being Fr-223. Its existence was confirmed in 1939 by
00:35:44 <lambdabot> [3 @more lines]
00:35:50 <Verbed> @more
00:35:51 <lambdabot> wrong type (<<[] Char>>) in ModuleState
00:35:59 <shapr> I should really fix that...
00:36:15 <shapr> but it won't happen today before swedish class...
00:37:01 <magr> @get-definitions
00:37:01 <lambdabot> Sorry, I don't know the command "get-definitions", try "lambdabot: @listcommands"
00:37:15 <magr> @get-definition
00:37:15 <lambdabot>  not defined
00:37:19 <shapr> @listcommands eval
00:37:20 <lambdabot> Module eval provides the following commands: ["eval","define","get-definition","definitions","del-definition","dump","set-fuel","resume"]
00:37:26 <shapr> @get-definition S
00:37:27 <magr> @get-definition io
00:37:27 <lambdabot> S = \f g x.f x (g x)
00:37:27 <lambdabot> io not defined
00:37:38 <shapr> @get-definition foldr
00:37:38 <lambdabot> foldr = \c n l.if null l then n else c (head l) (foldr c n (tail l))
00:37:47 <magr> @get-definition mapM
00:37:47 <lambdabot> mapM not defined
00:37:53 <magr> @get-definition mapM_
00:37:53 <lambdabot> mapM_ not defined
00:37:55 <shapr> @type mapM
00:37:55 <lambdabot> mapM :: Monad a => (b -> a c) -> [b] -> a [c]
00:37:57 <shapr> @type mapM_
00:37:57 <lambdabot> mapM_ :: Monad a => (b -> a c) -> [b] -> a ()
00:38:08 <magr> I see
00:38:12 <shapr> magr: the @eval module is a lambda cal interpreter written by Darius 
00:38:27 <shapr> the @type command gives type signatures via Hugs
00:38:42 <magr> @eval (\x->x x) (\x->x x)
00:38:42 <lambdabot> (line 1, column 4):
00:38:42 <lambdabot> unexpected "-"
00:38:42 <lambdabot> expecting letter or digit, identifier or "."
00:38:58 <shapr> I've hacked a bit on a haddock module that would give online docs via irc, but it's still in progress
00:39:08 <shapr> @eval (\x . x + 1) 1
00:39:09 <lambdabot> 2
00:39:12 <magr> @eval (\x.x x) (\x.x x)
00:39:26 <shapr> @eval (\x . x + 1) 1
00:39:29 <shapr> uh oh
00:39:32 <magr> sorry
00:39:35 <shapr> :-)
00:39:35 <lambdabot> out of fuel - use @resume to continue
00:39:35 <lambdabot> 2
00:39:37 <shapr> aha
00:39:49 <magr> I'm still used to Scheme, you know
00:40:13 <shapr> Scheme is a nice language also
00:41:06 <shapr> but I prefer Haskell
00:41:34 <shapr> the sources for lambdabot are available via darcs or cvs
00:43:02 <shapr> magr: how do you compare Haskell to Scheme?
00:43:10 <shapr> any noticeable likes or dislikes?
00:44:51 <magr> What I like about Scheme: It's more dynamic, and sometimes better for prototyping
00:45:18 <magr> for example, you have dynamic typing, _really_ polymorphic data structures, macros
00:45:36 <magr> but I noticed Haskell got Templates
00:45:38 <shapr> Haskell has macros too...
00:45:39 <shapr> yup
00:45:43 <ibid> (anna lindh died)
00:45:47 <shapr> ibid: :-(
00:47:09 <Verbed> shapr: How are the dynamic- family of commands called?
00:47:36 <shapr> @listcommands dynamic
00:47:36 <lambdabot> Module dynamic provides the following commands: ["dynamic-load","dynamic-unload","dynamic-reload"]
00:47:42 <shapr> @dynamic-load dummy
00:47:43 <lambdabot> already loaded
00:47:47 <shapr> @dynamic-reload dummy
00:47:48 <lambdabot> module reloaded
00:48:10 <magr> @dummy
00:48:10 <lambdabot> dummy
00:48:11 <shapr> Verbed: you can change the code in the DummyModule.hs and then reload the module to get the new code.
00:48:40 <shapr> there has been some speculation whether that only works for new functions on existing types, or new types as well. I don't know.
00:49:09 <shapr> as far as I know, lambdabot is the only application in daily use that uses the runtime loader
00:49:11 <shapr> but I could be wrong.
00:49:27 <Verbed> shapr: Can it operate on the MoreModule.hs portion of more?
00:50:04 * shapr wonders
00:50:20 <shapr> I think so.
00:52:58 * Verbed is confusing himself with the Lambdabot sources.
00:53:09 <shapr> well, as long as you're having fun :-)
00:53:48 <Verbed> I _am_ enjoying it, actually.
00:54:44 <shapr> :-)
00:55:23 <magr> haskell-libs seems to be a really cool place for learning haskell
00:55:48 <magr> I like when ppl actually _use_ a language for serious stuff
00:55:52 <magr> (like irc bots)
00:56:10 <shapr> I dunno how serious that is :-)
00:57:01 <shapr> the primary purpose of haskell-libs is to have a cvs-wiki, lately the darcs tree has been the central repository.
00:57:40 <shapr> magr: the darcs repo of haskell-libs is at http://www.ScannedInAvian.org/repos/hlibs/
00:57:55 <shapr> and darcs is from http://www.abridgegame.org/darcs/
01:07:00 <magr> @listmodules
01:07:00 <lambdabot> I have the following modules installed: ["base","dict","dummy","dynamic","eval","hello","karma","more","quote","seen","state","system","topic","type"]
01:22:32 <Verbed> shapr: I don't think that the more module state is ever being set with the overflowing lines, yet they're passed to moreStateSet.
01:45:56 <shapr> Verbed: how so?
01:46:50 <Verbed> shapr: I modified the code to putStr the modulestate when @more is called and it prints nothing.
01:47:00 <Verbed> Even after claiming an active more buffer.
01:47:06 <shapr> hmm
01:48:10 <shapr> the error says there's a type mismatch somewhere...
01:51:51 <shapr> I wonder if the ModuleState type has changed somewhere...
01:52:07 <shapr> anyways, I'll look at it more after class...
02:02:41 <harsha123> shapr: are you there?
02:02:46 <shapr> no
02:02:47 <shapr> er
02:02:58 <harsha123> shapr: hmmm...
02:04:02 <shapr> I'm about to go to class...
02:04:08 <shapr> but if you have some short questions, I'll try to answer them
02:04:36 <harsha123> shapr: nevermind.. when are you back?
02:05:09 <shapr> hm, some hours
02:05:25 <harsha123> shapr: ok goodbye.
02:05:46 <shapr> ok, cya
02:06:36 <RibRib> trees are complicated
02:07:16 <harsha123> RibRib: which trees?
02:07:25 <harsha123> :)
02:07:56 <RibRib> the stuff i was taught today...
02:08:02 <RibRib> trees and branches
02:08:32 <harsha123> RibRib: binary trees,red and black trees,binary search trees,hash trees ?
02:08:52 <RibRib> binary trees i think...
02:13:50 <harsha123> adept: hi
02:14:31 <adept> harsha123: hi
02:20:39 <harsha123> anyone whoz on ERC ?
02:26:22 <adept> harsha123: i was using ERC couple of years ago
02:27:26 <harsha123> adept: can I use ERC without knowing head and tail of Emacs ?
02:27:40 * harsha123 is feeling too ambitious ;)
02:29:35 <adept> harsha123: I suppose you can. Of course you will need to know basic text editing features and file/buffer management, but thats all
02:30:11 <harsha123> adept: i suppose i can get that by type C-h t?
02:31:16 <adept> harsha123: I suppose you can :)
02:31:29 <harsha123> adept: :)
02:33:12 <CowGirl> can someone explain foldl to me in english??
02:34:07 <Lor> You traverse through a list from the beginning to the end, and apply an operation to each element of the list.
02:34:36 <Lor> The operation receives as arguments the element, and the result from the previous operation.
02:34:58 <CowGirl> could u give me an example?
02:35:01 <adept> @type foldl
02:35:01 <lambdabot> foldl :: (a -> b -> a) -> a -> [b] -> a
02:35:25 <adept> @eval foldl (+) 0 [1,2,3]
02:35:25 <lambdabot> (line 1, column 8):
02:35:25 <lambdabot> unexpected "+"
02:35:25 <lambdabot> expecting simple term
02:35:36 <adept> @eval foldl + 0 [1,2,3]
02:35:36 <lambdabot> type error
02:35:43 <adept> hmm ...
02:35:44 <Lor> Thus, foldl (+) 0 [1,2,3] means ((0 + 1) + 2) + 3
02:36:03 <Lor> The zero is the initial argument for the first operation.
02:36:32 <Lor> @eval foldl (\x y -> x + y) 0 [1,2,3]
02:36:32 <lambdabot> (line 1, column 13):
02:36:32 <lambdabot> unexpected "-"
02:36:32 <lambdabot> expecting identifier or "."
02:36:47 <Lor> Uh, it doesn't understand operators _or_ lambda?
02:36:59 <adept> Something fishy is going on ..
02:37:12 <magr> @eval foldl (\x y. x + y) 0 [1,2,3]
02:37:12 <lambdabot> 6
02:37:14 <adept> Lor: seems like it have parsing troubles
02:37:25 <magr> its . not ->
02:37:37 <Lor> Ah, what's that language?
02:37:44 <magr> lambda calculus
02:37:53 <CowGirl> is .    ...mean not??
02:37:55 <Lor> Augmented with lists and numbers?
02:37:55 <CowGirl> like....
02:37:58 <CowGirl> not even
02:38:18 <Lor> Probably not. In what context?
02:38:26 <magr> Lor: seems so, as the foldl above worked
02:38:40 <CowGirl> i saw in a function the other day...
02:38:46 <Lor> Funny. You'd think it'd use haskell syntax.
02:38:48 <CowGirl> i think it was filter...
02:39:07 <Lor> (.) is function composition.   f . g = \x -> f (g x)
02:39:17 <adept> @type (.)
02:39:17 <lambdabot> (.) :: (a -> b) -> (c -> a) -> c -> b
02:39:56 <CowGirl> im trying to recall......something about using filter, to filter out odd numbers..... i'll try and find it
02:40:56 <CowGirl> ok here....
02:41:18 <CowGirl> filter (not.even) [1..10]   = [1,3,5,7,9]
02:41:30 <adept> @eval even 5
02:41:30 <lambdabot> unbound variable: even
02:41:38 <CowGirl> (.)  <- is composition
02:42:08 <Lor> Jes. ((not . even) x) means the same as (not (even x))
02:42:17 <Lor> Which is the same as (odd x).
02:45:49 <CowGirl> how would u write that using $  ??
02:48:08 <Lor> not $ even x
02:48:46 <magr> why would you want to use $ ?
02:48:55 <CowGirl> just for style
02:54:52 <Lor> $ Is not very good style, I think. It's often easier to write than parentheses, but a bit harder to read.
02:56:06 * ibid prefers $ over parentheses
02:56:40 <Lor> When you have really long right-associative chains, then then yes.
02:56:44 <ibid> tends to make expressions easier to read, at least for me
02:56:56 <ibid> i often do :)
02:57:22 <ibid> (really long in the sense that the rhs is longer than the lhs)
02:57:47 <ibid> (and often the length of the whole expression is close to the length of a line
02:59:06 <Lor> Here's another one of my comments on style, which no one ever bothered to reply to. http://www.haskell.org/pipermail/haskell-cafe/2002-November/003617.html
02:59:54 <ibid> i  have been lax in following the lists :)
03:19:23 <kosmikus> Lor: style is really a matter of taste -- I've just read your mail, for instance, and I don't agree
03:19:29 <kosmikus> but then again, I also like $'s
03:21:47 <Lor> I do agree on $ being a matter of taste, but the line break thing is imho less subjective.
03:22:48 <kosmikus> in general, I (but I am aware of the subjectivity involved here :) consider it bad style to end a line with an operator
03:23:58 <Lor> Essentially, I think my argument is that humans perceive the line structure of a document as "down-associative".
03:24:22 <kosmikus> although I can see the logic of having right-assoc ops at the end of lines, and left-assoc ops at the beginnings
03:26:36 <kosmikus> but then it would also be nicer to right-align these lines ending in a right-assoc operator, so your example from the mail should become
03:26:39 <kosmikus> Handle ->
03:26:42 <kosmikus>  Ptr a ->
03:26:44 <kosmikus>    Int ->
03:26:47 <kosmikus>  IO ()
03:27:10 <kosmikus> which will be a problem in general because of Haskell's layout rule ;)
03:29:52 <Lor> And even in irc because I use a proportional font. :)
03:30:24 <kosmikus> bad luck ...
03:31:00 <Lor> But I think this has something to do with the fundamental difference between how humans read a document and how machines parse them.
03:31:22 <Lor> Because we read not only from left to right, but we also see vertical structures, and right-aligned structures.
03:32:02 <Lor> Haskell's syntax is perhaps a bit more adjusted to human perception than most languages, and that's also why parsing it is a bitch.
03:32:52 <Lor> Right sections _can_ be parsed with a recursive-descent parser, but the grammar becomes an utter mess.
03:33:07 <Lor> LR parsers work better there.
03:35:27 <kosmikus> I don't care if a language is hard to parse -- that's not work that needs to be invested too often
03:36:36 <kosmikus> I've written two Haskell parsers, and if I ever write another one, then I don't know yet for what reason
03:39:04 <Lor> I wish I had some moments of idle spare time, so I could write my haskell-syntax preprocessor for ocaml...
03:47:01 <kosmikus> Lor: if you ever do, tell me -- I'd be interested
03:47:38 <Lor> I have this wacky idea about using haskell's class syntax for ocaml's class types, and the instance syntax for actual classes. :)
03:48:16 <Lor> Oh yeah, and using the do notation for all sequencing.
03:48:55 <kosmikus> do you know much about O'Caml? would it be hard to just plug another parser into the compiler?
03:49:20 <Lor> I was thinking of using camlp4, which provides all the required infrastructure already.
03:49:48 <Lor> In particular, it provides a very nifty syntax for generating ocaml syntax trees.
03:52:49 <kosmikus> looks like a cool tool -- what about error messages? does it provide functionality to express errors in terms of your modified syntax?
03:54:12 <Lor> How do you mean?
03:54:34 <Lor> It has its own parsing system, which does have some error reporting facilities.
03:54:54 <Lor> If you mean parsing errors, that is.
03:56:21 <kosmikus> yes, but other errors?
03:56:44 <Lor> I'm not exactly sure how type errors are handled.
03:57:09 <kosmikus> if, for instance, you change the type language to write "[a]" as in Haskell instead of "a list", if would be nice if you didn't get an error complaining about something not being of type "a list"
03:57:41 <Lor> Yep. Have to look into it.
03:57:54 <Lor> (No time right now.)
06:39:07 * shapr explorbs onto the scene
06:40:13 <harsha123> shapr: hiii WB
06:40:26 <harsha123> shapr: what do ya have up ur sleeve today ?:)
06:42:13 * adept hacks Gmap support into recent DrIFT
06:42:38 <shapr> harsha123: arms!
06:42:56 <shapr> Lor: I much prefer $ over parens
06:43:24 <shapr> lots of work to do today
06:43:30 <shapr> harsha123: did you have a specific question earlier?
06:43:57 <harsha123> shapr: not exactly.. anyway.. i got it.. :)
06:44:07 <shapr> ok
06:44:23 <shapr> oh, I have a chance to move part of my web dev stuff to Haskell
06:44:43 <shapr> but I really need some Haskell libraries that don't exist...
06:51:44 * harsha123 is back
06:51:58 <shapr> so harsha123, have you tried writing any Haskell yet?
06:52:20 <harsha123> shapr: Hmmm.. ppl say lisp is better what do ya say ?
06:52:31 <shapr> they each have their advantages.
06:52:44 <harsha123> harsha123: wworks for a linux based company..
06:53:07 <shapr> you work for a linux based company?
06:53:15 <harsha123> shapr: yes..
06:53:26 <shapr> one advantage of the lisp syntax is that data and code have almost exactly the same structure
06:53:38 <shapr> since the parse tree is immediately exposed, processing the source is simpler
06:53:41 <harsha123> shapr: wanna see our website ? ;)
06:53:45 <shapr> sure!
06:53:51 <harsha123> www.deeproot.co.in
06:54:12 <harsha123> shapr: do ya know lisp too?
06:54:55 <shapr> elisp
06:55:01 <harsha123> shapr: ok
06:55:05 <shapr> I've done some Scheme also, I went through SICP
06:55:18 <shapr> but I've written more elisp
06:55:18 <harsha123> shapr: hmmm a lot of stuff. 
06:55:37 <harsha123> shapr--> seems to be a functional programming GURU
06:55:39 <shapr> hah
06:55:40 <shapr> I wish
06:55:48 <shapr> there's so much to learn!
06:55:58 * harsha123 agreees
06:56:01 <shapr> I have only small parts, but I'm willing to share everything I know
06:56:27 <shapr> there are many who have more guruness on this channel.
06:56:35 <Heffalump> BOO!
06:56:38 <harsha123> shapr: what about writing emacs plugin's in elisp ? you've tried it?
06:56:39 <shapr> there's one RIGHT THERE
06:56:50 <harsha123> WHERE ?
06:56:54 * Heffalump pokes shapr with greencard
06:56:55 * shapr points to Heffalump 
06:57:00 <Heffalump> WHO WHAT WHICH WHEN?
06:57:00 <shapr> Heffalump: er, right :-)
06:57:08 * shapr laughs
06:57:24 <harsha123> hehehehe
06:57:41 <shapr> yes, Heffalump has more guruness than I do, especially in functional programming.
06:57:44 <Heffalump> STOP POINTING AT ME!
06:57:55 * shapr points at Igloo 
06:58:03 * shapr grins
06:58:10 <Heffalump> s/especially //, I'm sure shapr knows more about general programming than I do
06:59:02 <shapr> the open source culture is a gift culture, you get status from giving things away
06:59:15 <shapr> especially since code is infinitely reproducable
06:59:30 <Heffalump> not true
06:59:32 <shapr> no?
06:59:34 <Heffalump> there's an entropy cost
06:59:47 <shapr> for reproducing code?
06:59:49 <Heffalump> yes
06:59:57 * harsha123 gains a hell lot my reading you guys..
07:00:01 <Heffalump> and there's only a limited amount of entropy the universe can allow to be produced
07:00:34 <shapr> I dunno if entropy is a significant cost in this particular case...
07:00:57 <Heffalump> I was only quibbling with the "infinitely" aspect of your statement.
07:01:04 <shapr> yah yah, fair enough
07:01:06 <Heffalump> For practical purposes, there's not much of a limit.
07:01:15 <Verbed> shapr: I prodded around Lambdabot's innards without any solution.
07:01:22 <shapr> Verbed: I think it's Heffalump's fault.
07:01:24 <Heffalump> verbed: to what problem?
07:01:30 <Heffalump> oh, everything is my fault.
07:01:30 <shapr> but I've trying to blame everything on him lately ;-)
07:01:35 <Verbed> @more
07:01:35 <lambdabot> wrong type (<<[] Char>>) in ModuleState
07:01:37 * shapr snickers
07:01:40 <reffie> uhm
07:01:42 <Heffalump> oh, that.
07:01:47 <Heffalump> I'm sure that worked after I hacked it.
07:02:01 <shapr> hoi reffie 
07:02:03 <shapr> hoe gaat?
07:02:05 <reffie> hi
07:02:15 <Heffalump> doh
07:02:19 <reffie> ik hou van jou
07:02:21 <Heffalump> @more
07:02:21 <heffalambda> wrong type (<<[[Char]]>>) in ModuleState
07:02:25 <Heffalump> oh. hmm.
07:02:25 <shapr> reffie: wow, thanks :-)
07:02:26 <Igloo> Grrr. "/usr/bin/ar: libHSbase.a: No space left on device"
07:02:28 <harsha123> harsha123: curious about if Haskell was written in C 
07:02:28 <reffie> hehe
07:02:34 <harsha123> heh.. not again.. 
07:02:48 <shapr> Hugs is written in C
07:02:52 <reffie> Your price
07:02:52 <reffie> $1,699.00*
07:02:52 <reffie> IBM Web Price
07:02:53 <reffie> $2,249.00*
07:03:04 <reffie> for that:
07:03:06 <Cowgirl2> shapr, can i check to time the uni comps are set at
07:03:07 <Cowgirl2> ?
07:03:07 <reffie> http://www-132.ibm.com/webapp/wcs/stores/servlet/ProductDisplay?productId=8589316&storeId=1&langId=-1&categoryId=2049168&dualCurrId=73&catalogId=-840
07:03:16 <reffie> i wonder if it's worth it?
07:03:16 <shapr> Cowgirl2: huh?
07:03:16 <Cowgirl2> like using 'time' in DOS?
07:03:27 <shapr> Cowgirl2: have you tried the date command?
07:03:41 <harsha123> Cowgirl2: yes date command
07:03:42 <Cowgirl2> ok... thanx... :)
07:03:47 <reffie> :)
07:03:49 <Igloo> Oh well, at least it looks like the previous error isn't going to recurr
07:04:03 <harsha123> shapr: did you check the URL ?
07:04:05 <shapr> Igloo: you bought a larger drive?
07:04:10 <shapr> harsha123: yes, still looking at it
07:04:18 <harsha123> shapr:  what do ya think ? 
07:04:18 <Heffalump> shapr: so what's the situation with patches to lambdabot? Where should they go?
07:04:39 <Igloo> shapr: No, the previous error was much earlier in the compile. And this is the Debian x86 buildd, not a machine of mine.
07:04:40 <shapr> heffalambda: darcs
07:04:41 <heffalambda> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
07:04:44 <shapr> urf
07:04:45 <Heffalump> :-)
07:04:53 <shapr> heffalambda: @hello
07:04:53 <heffalambda> Hello world. 
07:05:03 <harsha123> lambdabot: @listcommands
07:05:04 <lambdabot> I react to the following commands: ["all-dicts","define","definitions","del-definition","devils","dict","dict-help","dummy","dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements","eval","foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","lojban","more","msg","part","prelude","quit","reconnect","
07:05:23 <harsha123> lambdabot: @echo
07:05:23 <lambdabot> echo; msg:IRCMessage {msgPrefix = "harsha123!~router@61.11.60.52", msgCommand = "PRIVMSG", msgParams = ["#haskell",":lambdabot: @echo"]} rest:""
07:05:41 <Heffalump> is it supposed to do that?
07:05:57 <shapr> yah, that's a testing command
07:06:07 <harsha123> harsha123: is the bot written in Haskell? :p
07:06:12 <shapr> of course!
07:06:21 <harsha123> shapr: Hmmm..
07:06:36 <shapr> echo is designed to show the anatomy of an irc msg as lambdabot sees it.
07:06:39 <Heffalump> did the MoreModule used to work?
07:06:43 <shapr> it did used to work.
07:06:45 <Heffalump> cos it looks like a bug in it to me.
07:06:49 <shapr> could be
07:06:59 <shapr> I wrote it as an afternoon hack
07:07:18 <harsha123> shapr: which client can load Haskell modules?
07:07:24 <shapr> hircules
07:07:38 <harsha123> hirclues??? is that chat-client?
07:07:40 <shapr> yup
07:07:48 <shapr> http://www.haskell.org/hircules/
07:07:52 <harsha123> shapr: works on linux?
07:08:00 <shapr> I think so
07:08:04 <shapr> it's based on the lambdabot sources
07:08:21 <harsha123> shapr: btw what client do ya use ? are ya on linux?
07:08:23 <shapr> speaking of which, I should root through it and see if jens has any fixes we can steal.
07:08:33 <shapr> I use ERC, and I'm on Debian Linux.
07:08:40 <harsha123> shapr: Ok
07:08:56 <Heffalump> I don't understand how MoreModule ever worked
07:09:28 <Heffalump> it stores a list of strings as its state, but tries to use the state as a single string
07:09:42 <Heffalump> I'm fairly sure I didn't fuck that up when I changed stuff
07:09:45 <shapr> it shouldn't store a list of strings
07:09:55 <shapr> who knows, it may have worked accidentally :-)
07:09:58 <Heffalump> newRef <- liftIO . newIORef $ ModuleState [""]
07:10:02 <Verbed> Heffalump: Remove the brackets from [""]
07:10:09 <Verbed> They shouldn't be there.
07:10:14 <Verbed> It still won't work, however.
07:10:34 <Heffalump> but how did they get there?
07:10:42 * shapr dunno
07:10:45 * Heffalump is aware of how to fix it, I'm just confused
07:11:02 <Heffalump> @more
07:11:11 <Heffalump> how do I fill the @more buffer?
07:11:18 <shapr> heffalambda: @jargon "lambda calculus"
07:11:20 <heffalambda> No match for ""lambda calculus"".
07:11:23 <Heffalump> (tell me if the testing on here is annoying you, btw)
07:11:29 <shapr> I'm happy to see the test
07:11:34 <shapr> heffalambda: @wn prognosis
07:11:35 <heffalambda> *** "prognosis" wn "WordNet (r) 1.7"
07:11:35 <heffalambda> prognosis
07:11:35 <heffalambda>      n 1: a prediction about how something (as the weather) will
07:11:35 <heffalambda>           develop [syn: {forecast}]
07:11:36 <heffalambda>      2: a prediction of the course of a disease [syn: {prospect}, {medical
07:11:38 <heffalambda>         prognosis}]
07:11:42 <shapr> oops
07:11:53 <shapr> heffalambda: @jargon hacker
07:11:54 <harsha123> shapr: http://grc.com/dos/grcdos.htm 
07:11:54 <heffalambda> *** "hacker" jargon "Jargon File (4.3.0, 30 APR 2001)"
07:11:54 <heffalambda> hacker n. [originally, someone who makes furniture with an axe] 1. A
07:11:54 <heffalambda>    person who enjoys exploring the details of programmable systems and how
07:11:54 <heffalambda>    to stretch their capabilities, as opposed to most users, who prefer to
07:11:55 <heffalambda>    learn only the minimum necessary. 2. One who programs enthusiastically
07:11:57 <heffalambda>    (even obsessively) or who enjoys programming rather than just theorizing
07:11:59 <heffalambda>    about programming. 3. A person capable of appreciating {hack value}. 4.
07:12:01 <heffalambda>    A person who is good at programming quickly. 5. An expert at a
07:12:03 <heffalambda> [29 @more lines]
07:12:08 <Heffalump> heffalambda: @more
07:12:09 <heffalambda> wrong type (<<[] Char>>) in ModuleState
07:12:14 <Heffalump> umph!
07:12:56 <harsha123> shapr: can ya look up that link ?? its actually unbelibable
07:13:10 <harsha123> unbelivable
07:14:16 <shapr> I'm reading it now
07:14:18 <adept> harsha123: what's unbelivable there?
07:14:40 <harsha123> adept: hmm.. just read it..
07:14:54 <adept> harsha123: i did
07:15:17 <harsha123> adept: can ya imagine a person whoz read the IRC RFC's and hacked into a IRC channel(hidden)
07:15:45 <harsha123> btw he was on the IRC for the first time 
07:15:50 <harsha123> adept: have you read it before ?
07:16:37 * harsha123 is sorry if it is off the topic
07:16:53 * harsha123 felt it intersting.. :)
07:17:44 <adept> harsha123: read IRC RFC as night reading someday .. you'll be thrilled, i promise
07:18:07 <harsha123> adept: ok.. 
07:18:13 <harsha123> adept: are you serious?
07:18:52 <adept> harsha123: dead serious :)
07:18:58 <harsha123> adept: ok..
07:19:23 <harsha123> adept: i ll take your word for it 
07:19:39 <harsha123> harsha123: is experiencing some delay.. 
07:19:44 <harsha123> not again 
07:19:49 <adept> harsha123: almost any sufficiently old specification (from the days when Internet was required to survive mere atomic war and not 12-year old kids) makes a joyful reading
07:20:27 <harsha123> adept: hmm.. 
07:22:51 * Heffalump is confused by this problem too :-)
07:23:11 <harsha123> adept: can you have a velid IP address with an octet as 255 ?
07:23:32 <harsha123> adept: not the broadcast though
07:24:10 <harsha123> hey wherez shapr gone?
07:24:24 <adept> harsha123: define "valid". 255.255.255.255 looks valid enough for me
07:25:05 <Igloo> A host can have an IP address of the form x.y.z.255, yes
07:25:08 * harsha123 is wondering .. about something like 61.255.81.1
07:25:29 <Verbed> Heffalump: Are there any reasons why moreStateSet might need to be in MoreModule ?
07:25:40 <Igloo> Oh, or elsewhere. Not sure about the first one though.
07:26:44 <harsha123> adept's IP is something like 80.255.64.73
07:26:51 <Heffalump> verbed: I imagine the fact that other things need to use it causes the cyclic import problem referred to in the comments
07:27:08 <Heffalump> I just can't find what's writing to the "more" state with something other than a String ModuleState.
07:27:19 <Heffalump> or trying to read from it in that way, more importantly.
07:29:37 <Igloo> You could wrap the state in a datatype with has a constructor Rest String only
07:29:52 <Heffalump> how would that help?
07:30:14 <Igloo> There was a CVS commit (I think) fixing a mis-interaction between 2 different dynamic type environments, but I think ghci had to be involved. Not sure, though.
07:30:29 <Igloo> Well then you would get a static error wouldn't you?
07:30:34 <Heffalump> where?
07:30:46 <Heffalump> I've tried putting static type annotations on all the sites I can find that read/write from the state.
07:31:01 <Heffalump> that (confirmed) one error for me, but it's still buggered.
07:31:49 <Igloo> http://www.haskell.org/pipermail/cvs-ghc/2003-September/018418.html
07:32:47 <harsha123> adept: where are you .. lost ? :)
07:32:51 <Igloo> Can you get it to print the other type in the conflict?
07:32:55 <harsha123> shapr: where are you ?
07:32:56 <Heffalump> but that's a bug that would cause crashes when there should have been a dynamic type error, not dynamic type errors where there shouldn't have been
07:32:58 <Heffalump> I'm just trying to do that.
07:33:05 <Heffalump> It's a bit tricky, the type system is whinging at me atm.
07:33:08 <adept> harsha123: no, not at all. Why are you so surprised by 255 in IP?
07:33:24 <harsha123> adept: nay..just a casual question..
07:33:39 <harsha123> adept: never seen an IP so strange :p
07:35:26 <Heffalump> oh, I know what the problem will be
07:35:35 <Heffalump> where/let bindings are polymorphic, right?
07:36:12 <Igloo> Give or take the MR
07:36:36 * Heffalump turns it into a lambda-abstraction
07:36:53 <Igloo> Can't yo just give it a type?
07:37:08 <Heffalump> I don't know the type
07:37:16 <Heffalump> I'm just trying to make it be the same as the result type of the function.
07:37:26 <Heffalump> hmm.
07:37:31 * Heffalump wonders if this trick has a hope of working
07:37:40 * Verbed waits anxiously.
07:37:46 <Heffalump> verbed: what for?
07:37:57 <Verbed> For the test.
07:38:01 <Heffalump> ah.
07:38:20 <Verbed> I tinkered with the code for an hour, never having any real hope of figuring it out.
07:40:13 <Heffalump> verbed: #joy is the place to watch the shenanigans
08:25:37 <shapr> whee
08:29:48 <isomer> whee?
08:29:57 <whee> indeed
08:30:06 <isomer> :)
08:30:36 <isomer> anyone got any spare motivation lying around?
08:30:48 <whee> if I could get some caffiene, I'd do something
08:31:24 * isomer fidgets
08:32:03 * shapr wiggles
08:32:15 <shapr> I have motivation, but it's tuned towards writing Haskell code.
08:32:24 <isomer> hehe
08:32:31 <whee> I need to grab myself a coffee machine
08:32:44 <isomer> i have a huge pile of paperwork to do. i've got plenty of motivation for coding
08:32:51 <isomer> (suddenly)
08:33:04 * shapr laughs
08:33:06 <shapr> I know the feeling.
08:34:34 * isomer wants some of those little motivation pills
08:34:59 <whee> motivation pills? like jelly beans? :)
08:35:15 <isomer> er...no. like methyl phenidate :)
08:35:34 <isomer> zombie boyscout pills
08:36:41 <isomer> hey, is it just me or is there a more than passing resemblance between monads and aspect-oriented programming?
08:40:07 <shapr> isomer: methyl phenidate?
08:40:16 <isomer> aka ritalin
08:40:23 <shapr> I know, I have a prescription ;-)
08:40:35 <isomer> i wish i had a script :(
08:40:41 <isomer> at least, on days like today
08:40:46 <shapr> I was just wondering if you got a diagnosis too?
08:41:04 <isomer> only a self diagnosis: can't concentrate on boring shit.
08:41:07 <shapr> heh
08:41:22 <isomer> i suppose that just makes me normal, though...
08:42:02 * shapr finds a bug in his C code
08:42:46 <isomer> hey, shapr, can i bug you sometime for some zope/apache help? not today, but ... sometime?
08:42:51 <shapr> sure
08:42:58 <isomer> thanks
08:43:05 <shapr> I dunno anything about running zope on apache though
08:43:08 <shapr> just zope by itself
08:43:11 <isomer> ah :(
08:43:22 <Igloo> Oh, does anyone know a good way to write a wrapper that remove an argument "foo" but otherwise just execs the real program with the arguments?
08:43:35 <isomer> oh...speaking of which... http://etherealplanet.org:9080/wiki/ShirleyLakePhotos -- from this past weekend
08:43:52 * Igloo doesn't know how to do it in sh easily and would rather not fork perl or something each time
08:44:15 <Smerdyakov> Filtering lake water is for wimps.
08:44:27 <isomer> hehe
08:44:49 <shapr> hi esa
08:44:55 <shapr> isomer: nice place to spend the weekend
08:44:56 <esap> Hi
08:45:34 <YveDeLarc> Igloo: use a shell function, shift the first argument
08:45:40 * esap is trying to understand adjunctions better.
08:45:42 <isomer> shapr: yeah, it was great. portaged 5km with apack on my back and a boat on my head
08:46:04 <Igloo> YveDeLarc: No, I want to remove one whose text is "foo", not the first one
08:46:21 <shapr> shell metaprogramming, yay!
08:46:22 <YveDeLarc> ah
08:46:42 <isomer> Igloo: i'm sure you could do it with sed/awk, but i don't know how :(
08:46:47 <YveDeLarc> Igloo: shell function, iterate over the arguments, build new argument vector
08:46:49 <isomer> that wasn't too helpful, was it...
08:47:36 <Igloo> I'm not confident in my ability to do that without possibly screwing up so spaces get collapsed or something
08:47:52 <Smerdyakov> Whoa. I hate when space collapses.
08:48:30 <Igloo> Hmm, I probably only need to do it a few thousand times, it'll probably be easiest just to do it in perl
09:02:47 <shapr> methylphenidate my fairest friend, that dust of laser focus
09:02:59 <shapr> tastes nasty though.
09:03:23 <shapr> there's a new non-stimulant ADHD drug
09:03:30 <isomer> which?
09:03:38 <shapr> I dunno
09:04:03 <shapr> I know wellbutrin has been used for ADD in the past, but it sounds scary to me
09:04:11 <shapr> I don't like SSRIs 
09:04:31 <isomer> you don't want to be on SSRIs for a long time, imho
09:04:39 <shapr> not even a short time, imho
09:04:55 <isomer> a year seems to be fine (according to medline)
09:05:15 <shapr> I tried Paxil for six weeks, didn't like it at all.
09:05:26 <shapr> works far too well, I was boring ;-)
09:05:54 <isomer> antidepresents are tricky - you have to find (a) the right family of drugs, (b) the right drug within that family, and (c) the right dosage
09:06:08 <isomer> it can take quite a while to get one that works for you
09:06:42 <isomer> also, for many people the side effects are worse than the depression
09:06:53 <shapr> yah, boringness.
09:07:19 <isomer> a friend of mine tried mood stabilizers (he's very bipolar) and decided the same thing: he didn't feel like himself
09:07:23 <shapr> on the other hand, much of the point of antidepressants is to give you a break so you can stabilize.
09:07:42 <isomer> have you heard of SAM-e?
09:07:44 <shapr> nope
09:08:09 <shapr> what is it?
09:08:32 <isomer> S-adenosyl-L-methionine 
09:08:41 <isomer> let me find a link for you..
09:08:51 <shapr> ok
09:09:15 <isomer> http://www.biopsychiatry.com/samerev.htm
09:09:47 <isomer> it seems to be quite effective for most people and has negligeable side effects
09:10:18 <shapr> interesting
09:10:51 <isomer> it's been used in europe for (i think) about 20 years. it's just got FDA approval in the US last year. It's still not approved in Canada
09:11:07 <isomer> in fact, i think it's over the counter in europe
09:11:32 * isomer is a molecular biology/medicine nerd too
09:11:43 <shapr> I just a science nerd
09:11:57 <shapr> science news is the greatest thing since sliced type errors.
09:12:06 <isomer> yeah... i love it too
09:12:18 <shapr> though delivery to sweden isn't that speedy
09:12:22 <shapr> their online site is *great*
09:12:34 <mgoetze> isomer: so what does that S- mean?
09:12:38 <SyntaxPolice> compiling this space invadors example is non trivial!
09:12:42 <shapr> SyntaxPolice: that bad?
09:12:48 <shapr> you should complain on the list
09:12:54 <SyntaxPolice> and when I say non-trivial... ;)
09:13:08 <mgoetze> better yet, you should invade the list from space!
09:13:15 <SyntaxPolice> currently I'm working on getting haven installed, though I'm making some better progress
09:13:20 <isomer> mgoetze: S- mean "left handed". the molecule comes as a right handed version too (called R-).
09:13:22 <SyntaxPolice> s/better/
09:13:36 <Igloo> Oh, Syn, I scanned through the library packaging page earlier, and something wasn't clear to me - do the tools make it easy to update a Debian package (e.g. compiler dep changed) as well as to create one from scratch?
09:13:37 <shapr> SyntaxPolice: on debian?
09:13:38 <isomer> mgoetze: usually biologically active molecules are S-. We don't know why
09:14:05 <mgoetze> isomer: but what does "left handed" mean in chemical terms?
09:14:47 <isomer> mgoetze: it means that there is a carbon with 4 different substituents on it. there's a special way to designate that carbon based on the ordering of the substituents in 3d space.
09:15:14 <mgoetze> isomer: so then it's either L- or R-... but what's S-?
09:15:34 <SyntaxPolice> Igloo: haven't thought about that much, but its possible. lostless parsing is always an issue when you go that direction,s o I was assuming for the first version, just from scratch.
09:15:44 <isomer> no, it's R- or S-. R- = Rictus (or right), S- = Sinister (or left) (from latin)
09:16:01 <Igloo> lostless?
09:16:08 <shapr> lossless?
09:16:26 <SyntaxPolice> well
09:16:29 <Igloo> Oh, I see
09:16:43 <SyntaxPolice> like so you can parse a file w/ comments and all kinds of other junk and modify it and write it back
09:16:48 <isomer> mgoetze: confusingly, there is also an L-/D- system, a Z-/E- system, and a couple of others, depending on how the molecule is arranged
09:16:48 <mgoetze> hm, yeah i knew it was something about left and right... you got me confused by dumping an -L- in the molecule name... so what's that? lol
09:17:11 <SyntaxPolice> pesky humans want to be able to read source code for some reason
09:17:21 <Igloo> For things like control files it should be fairly simple to parse fields and look for ones with names you recognise though
09:17:35 <SyntaxPolice> now I have to get gcjni built...
09:17:44 <mgoetze> isomer: so L- means something different than S-?
09:17:48 <Igloo> But yeah, ignoring it for the first release sounds reasonablw
09:17:51 <shapr> SyntaxPolice: are you doing this on win32?
09:17:59 <SyntaxPolice> shapr: whats win32? ;)
09:18:04 <shapr> fair enough :-)
09:18:36 * shapr is starting to come up with swedish words instead of english when writing...
09:18:46 <SyntaxPolice> what is mvg? any ideas?
09:18:51 <SyntaxPolice> shapr: cool!
09:19:04 <shapr> mvg? multiple vector graphics?
09:19:08 <shapr> where do you see mvg?
09:19:23 <isomer> mgoetze: it is yet another designation of chirality at a different carbon
09:19:24 <SyntaxPolice> Igloo: fields in control files have a pretty standard syntax, but we'd still want to retain comments. I guess that wouldn't be too hard
09:19:37 <SyntaxPolice> shapr: in this haven program
09:19:39 <shapr> oh
09:19:50 <SyntaxPolice> I seem to be able to choose between java and mvg graphics libraries, I think.
09:19:58 <Igloo> I don't think I new you could have comments  :-)
09:20:04 <Igloo> Argh, knew
09:20:12 <mgoetze> isomer: yeah but i thought there are only two possibilities, not six (they are all sp3-hybridized, i'm assuming)
09:20:47 <SyntaxPolice> Igloo: hm. maybe you can't...
09:20:57 <SyntaxPolice> Igloo: I promise to think about it :)
09:21:03 <Igloo> :-)
09:21:35 <mgoetze> isomer: so i'm a bit confused by you using both S- and L- in the name of the same molecule
09:21:46 <Igloo> Even just saying "It looks like your deps are wrong/outdated" would be better - and possibly better then fixing it behind your back
09:21:49 <SyntaxPolice> Igloo: do you see everytrhing in H.E. that you expect to see?
09:21:57 <shapr> isomer: are names like that unique enough to write a Read instance for?
09:21:59 <SyntaxPolice> Igloo: do you expect it to run periodically to try to figure that out?
09:22:32 * isomer looks up the nomenclature to be sure
09:22:51 <Igloo> ghc-cvs looks to have gone through as expected. No idea what's up with greencard, but Ganesh didn't seem to bothered about it
09:23:03 <shapr> he keeps asking me to test it...
09:23:06 <isomer> shapr: yes - the system is designed to explicitly identifiy molecules. it's called the IUPAC naming system
09:23:16 <Igloo> Syn: You'd run it when you got new upstream source (i.e. at the same time as you'd run a fix-it-for-me-please script)
09:23:17 <shapr> nifty, that would be a fun Parsec module
09:23:37 <Igloo> Oh, and please don't call it setup.hs - or anything else with a .hs extension  :-)
09:23:44 <SyntaxPolice> Igloo: lhs?
09:23:45 <shapr> setup.lhs
09:23:55 <shapr> for reasons of #!/bin/env haskell
09:23:59 <shapr> ?
09:24:11 <Igloo> Oh, right, so it's actually Haskell source not a compiled program?
09:24:22 <Igloo> I withdraw my request then
09:24:23 <SyntaxPolice> this whole extention thing seems to be the biggest point of contention
09:24:27 <SyntaxPolice> Igloo: thanks :)
09:24:34 <shapr> SyntaxPolice: I say .lhs, so #! works
09:24:41 <isomer> mgoetze: i didn't name it! that's the IUPAC designation :)
09:24:43 <shapr> but anything that works at all is good.
09:24:44 <SyntaxPolice> shapr: agreed!
09:24:56 <SyntaxPolice> I think whatever it is, it shouldn't work on whatever this win32 thing is
09:25:04 <shapr> yes, kill win32
09:25:11 <Igloo> At least I do so long as hugs' portability is a superset of nhc and ghc's
09:25:34 <shapr> Igloo: forever? ;-)
09:25:39 <mgoetze> isomer: IUPAC always confuses me, what with their nitrit, nitrid, nitrat, etc.
09:25:51 <shapr> actually, I gotta ask the nhc98 on PalmOS guys what's up with that...
09:25:54 <Igloo> shapr: For as long as it is used
09:26:09 <shapr> I'd luvvv to write Haskell programs for the Palm
09:26:15 <shapr> even if a single program took up 6mb
09:26:35 * Igloo isn't sure why it isn't compiled where possible anyway - you could always "compile" it to a runhugs script
09:27:04 <isomer> mgoetze: me too. i have to "decode" complex names
09:27:49 <mgoetze> isomer: good thing for us that shapr is writing a IUPAC-parser in haskell! :)
09:27:58 <shapr> heh
09:28:19 <isomer> cool! :)
09:28:31 <shapr> it would be a good way to learn HOpenGL
09:28:34 <shapr> write a molecule viewer
09:29:26 <SyntaxPolice> Igloo: I don't know why greencard is just sitting there :(
09:29:34 <isomer> mgoetze: i'm thinking the S- means that carbon 1 is replaced with a sulphur....
09:29:54 <isomer> talk about confusing
09:30:14 <mgoetze> oh... bastard molecule from hell :)
09:30:14 <Igloo> The .orig.tar.gz seems to be missing so it's presumably waiting for it to appear
09:31:59 <isomer> anything that weighs ~400g/mol is confusing (to me)
09:41:09 <shapr> hi Marvin-- 
09:49:21 <Marvin--> ello
09:49:31 <shapr> wassup?
09:49:49 <mgoetze> yeah, tell us all about it!
09:54:38 <Excalibor> hello
09:55:19 <shapr> hi Excalibor
09:55:31 <shapr> Excalibor: have you suddenly gained an E?
09:55:45 <shapr> hello jak97_ 
09:55:54 <jak97_> hi shapr
09:56:08 <shapr> how's the wonderful britain treating you?
09:56:13 <jak97_> heh
09:56:20 <jak97_> well looks like summer's over!
09:56:34 <shapr> getting cold?
09:58:34 <Excalibor> shapr: i'm connecting from work, and yes, I may have gained an E... I gotta use gaim to enter IRC and there's no way to distinguish accounts into different nets unless I use different nicks :-P
09:59:00 <Excalibor> jak97_: summer's finishing in spain as well, i guess it's harder in the north...
09:59:01 <shapr> oh, I see.
09:59:32 <Excalibor> shapr: so y have many combinations of Excalibor, eXcalibor, Xcalibor, etc... so I know where I am :)
09:59:50 <shapr> ok
10:04:30 <Excalibor> what's up?
10:04:47 <shapr> mostly work...
10:04:54 <shapr> but I'm hacking on a bit of Lua too
10:13:53 <Excalibor> ah, lua, nice
10:14:03 <Excalibor> a cute little language
10:14:24 <shapr> I haven't used it much, but am writing some so I can script ion, my window manager.
10:14:44 <Excalibor> ah, you use ion? :-)
10:14:59 <shapr> yup, my favorite
10:15:02 <Excalibor> I used to maintain redhat rpms of ion-devel for a while, months ago
10:15:12 <shapr> until someone writes one in Haskell :-)
10:15:22 <Excalibor> still subscribed to the list, but it's been a while since I last used it
10:15:34 <Excalibor> yes, well... it may take a while :)
10:24:33 <Excalibor> re's Smerdy
10:26:17 <Excalibor> time to go home, will log on in a couple of hours
10:33:36 <shapr> hi aporna
10:33:47 <shapr> hur r det med dig?
10:34:01 <aporna> hehe.. det r s bra s =)
10:34:05 <aporna> hller p att skriva en frga..
10:34:20 <shapr> or you can try #haskell.se if you prefer :-)
10:34:42 <shapr> what can we help you with?
10:34:48 <aporna> hold on =)
10:34:50 <shapr> ok
10:35:49 <aporna> hi there.. I'm having some problems.. I have a datatype, data Square, that is a square on a chessboard.. I want ta have 2 "constructors", one that takes the square as a string, "a8" or as <row, column>.. how .. ? ? =)
10:36:40 <shapr> you could write a wrapper function for one that translates and calls the other.
10:37:10 <aporna> can't you use data Square Sq1 Int Int | Sq2 String ?
10:37:29 <aporna> that kinda works.. but it won't translate it as I like =)
10:38:18 <aporna> I can use strSq :: String -> Square and then define that func. but.. it's kinda ugly :)
10:38:22 <whee> I would end up doing that with two constructors like you have, then a couple functions to go from one representation to the other
10:39:16 <whee> or maybe use read/show to read the string representation and just store it as row/col
10:39:26 <aporna> mmkay.. and if I have "data Square Sq1 Int Int | Sq2 String", how do I define the Sq2 ? it won't work if I use "strSq (a:b:[]) = Sq ..."
10:39:41 <aporna> that's the way I want to do it..
10:39:42 * shapr swears at postgresql
10:39:53 <aporna> I want to translate the string to row/column..
10:40:32 <shapr> you could use read for the number, and ord for the character
10:41:56 <aporna> ok.. but can you wrap it into the constructor? or is that just unnecessary? I really new to haskell, and it's really differet from what I'm used to =)
10:42:00 <aporna> I'm
10:42:48 <shapr> well
10:42:52 <shapr> depends on what you want to do...
10:43:34 <aporna> the problem is that I'm not sure.. it's for a project in school.. :)
10:43:49 <shapr> I'd guess you're doing the n-queens problem...
10:44:09 <dennisb> I suggest you have one constructor (Sq Int Int) and then you have a function parseSquare :: String -> Square
10:44:18 <dennisb> or String -> Maybe Square
10:44:51 <dennisb> (which is more or less what shapr said)
10:44:55 <aporna> ok.. that's the way I have it right now.. I'll let it be that way I think :)
10:45:12 <aporna> atleast until I learn some more =)
10:46:12 <aporna> thanks..
11:15:24 <Marvin--> dennisb, my man... why weren't you at the multi meeting?
11:16:00 <dennisb> i've got a cold
11:16:13 <shapr> and didn't want to share?
11:16:24 <Marvin--> fair enough :)
11:16:41 <dennisb> I guess I got it from all the new students. Last year one week after I got new students I also got it
11:16:50 <dennisb> now it's a pattern
11:17:05 <dennisb> last year it was just bad luck
11:20:36 <shapr> hi asmodai 
11:20:41 <shapr> wanna learn Haskell? :-)
11:20:52 <asmodai> Hehe
11:20:55 <asmodai> ultimately
11:21:08 <asmodai> right now I am, forced to, learn(ing) Python
11:21:12 <shapr> oh, I like Python.
11:21:17 <shapr> it's a very useful language.
11:21:19 <yazirian> mmmm, python is tasty good stuff
11:21:26 <shapr> for what purpose are you learning Python?
11:21:54 <shapr> asmodai: zope?
11:22:05 <asmodai> Nah, I'm making Bugzilla work on pgsql
11:22:08 <shapr> oh
11:22:15 <asmodai> and one of the GNATS conversion tools is written in Python
11:22:28 <asmodai> and I need to convert about half of FreeBSD's GNATS PRs to Bugzilla for DragonFly
11:22:29 <shapr> are you porting it to another language?
11:22:34 * asmodai spazzes
11:22:41 <asmodai> It all makes sense in my mind!
11:22:41 <shapr> what's a PR?
11:22:45 <asmodai> Problem Report
11:22:57 <shapr> you just want to convert the data?
11:23:14 <asmodai> Well, most of it is done.
11:23:24 <asmodai> Python did it in about 15 mins, 57000 PRs
11:23:33 <asmodai> I need to fix the script to reflect the latest schema
11:23:44 <asmodai> and then go back to making Bugzilla RDBMS agnostic
11:23:52 <asmodai> and finish the support for pgsql and Oracle
11:24:50 <asmodai> It's weird
11:24:53 <shapr> well, sounds like fun...
11:24:57 <asmodai> ultimately it is all to support TenDRA
11:24:59 <asmodai> :)
11:25:12 <shapr> if you're enjoying yourself, more power to ya
11:25:22 <shapr> so, can I point you to some learning Haskell resources? :-)
11:25:27 <asmodai> Sure.
11:25:41 <shapr> http://www.haskell.org/learning.html
11:25:44 <asmodai> I still want to find a good evening based Math course to get a degree in Math
11:25:46 <yazirian> hehehe
11:25:59 <shapr> that's a collection of learning Haskell links
11:26:04 <asmodai> Mathematics is only taught during daytime in NL :(
11:26:11 <yazirian> Haskell: where quicksort is 2 lines, and cat is nigh impossible. :)
11:26:14 <shapr> other handy #haskell toys are the 'bot, lambdabot 
11:26:27 <asmodai> yazirian; LOL
11:26:29 <shapr> and the cvs-wiki 
11:26:44 <shapr> at http://www.ScannedInAvian.org/repos/hlibs/
11:26:48 <shapr> it's a darcs repo btw
11:26:53 <asmodai> So I wonder then
11:27:01 <asmodai> what's the applied use for Haskell outside of Academics?
11:27:09 <shapr> well, lambdabot is written in Haskell
11:27:12 <yazirian> oooh, I want to know too
11:27:22 <shapr> I wrote a bayesian spam filter in about a hundred lines of Haskell
11:27:29 <yazirian> that is cool and a half
11:27:51 <shapr> I wrote most of an RFC822 parser in Haskell
11:28:00 <shapr> but then someone else beat me to it with an RFC2822 parser...
11:28:22 <dennisb> asmodai: applied use? like digging trenches?
11:28:36 * shapr uses a Haskell book to dig a hole in his desk
11:28:53 <yazirian> no language has 'arrived' until it has been used to write an email client nobody uses ;)
11:28:56 <shapr> asmodai: seriously though, I claim that Haskell is very good at parsers, compilers, etc
11:29:09 <shapr> there's an irc client written in Haskell
11:29:19 * shapr considers writing an email client that he will never use
11:29:49 <shapr> that would be a good chance to learn wxHaskell
11:29:53 <asmodai> heheh
11:30:04 <yazirian> okay
11:30:10 <asmodai> dennisb; Applied use like creating real world applications :)
11:30:14 <yazirian> I really was going to try to just lurk until I got this by osmosis
11:30:21 <shapr> yazirian: is it working?
11:30:26 * asmodai is also looking at Pike.
11:30:27 <yazirian> but I feel like a troublemaker today :)
11:30:31 * shapr feels drained from sitting next to yazirian 
11:30:41 <yazirian> shapr: I have learned a metric ton about irc connects and disconnects ;)
11:30:48 <shapr> yay!
11:30:50 <shapr> er
11:31:13 <dennisb> yes, parsers are fun in haskell and really boring in all other languages. Everything where you manipulate structures in some way, the datatypes in haskell are nice
11:31:17 <shapr> asmodai: I haven't looked at Pike before, have an url?
11:31:28 <shapr> yah, algebraic datatypes are really good at holding structure
11:31:36 <shapr> it's like "make your own custom lego block"
11:31:52 <shapr> except better...
11:31:59 <asmodai> http://pike.ida.liu.se/
11:32:12 <shapr> ah, linkoping
11:32:19 <yazirian> putting aside whether or not monads are a good idea (!flame), and putting aside whether I understand them yet (!brain); the fundamental dichotomy in Haskell that I struggle with is this (to be continued...)
11:32:34 * shapr waits for part two of the ongoing saga
11:33:06 <shapr> yazirian: have you seen the Demo.hs I whipped up?
11:33:07 <yazirian> the language espouses a lot of pure functional ideas with clear and compelling arguments behind each, all of which I buy, and which construct a language I find very interesting.
11:33:12 <shapr> it's a scanty intro to the language
11:33:19 <shapr> oh
11:33:23 <shapr> the plot thickens
11:33:50 <yazirian> Then it defines what amounts to a completely second language; in this one, actual work happens. :)
11:34:02 <shapr> what are the two languages?
11:34:04 <yazirian> and ne'er the two shall meet! (sorta)
11:34:25 <dennisb> i guess you talk about monadic stuff?
11:34:40 <yazirian> the little programming I have done in Haskell reminds me of when I was first learning vi, and weaning myself off of pico (for which I am ever grateful, but at the time it was hard)
11:34:54 <yazirian> and the constant concern in vi of, "am I in command mode, or input mode?"
11:35:21 <yazirian> something similar exists, to my brain, when in Haskell-thought. "Am I in functional-land? Or am I behind the electric fence right now?"
11:35:24 <shapr> oh, pure or monadic types?
11:36:16 <shapr> in my opinion, they're both part of the same language, just different parts :-)
11:36:18 <dennisb> they both live in perfect harmony
11:36:29 <yazirian> and I find myself spending a distressing number of cycles thinking about the details of coercing computation to move across that boundary
11:36:53 <shapr> yazirian: in my experience, that is a step along the way
11:37:06 <shapr> happened to me too when I started.
11:37:41 <shapr> monads seem to be totally foreign to the imperative programming mindset
11:37:55 <shapr> or something like that
11:38:07 <yazirian> I would even call them damn strange to other functional languages
11:38:18 <yazirian> this is not an issue I had with lisp, for example.
11:38:27 <dennisb> As I see it the imperative programmers always are in the IO monad
11:38:27 <shapr> true, but lisp is not purely functional
11:38:41 <shapr> lisp is in the middle somewhere
11:38:54 <yazirian> and I understand the choice there, which is to eliminate that boundary at the cost of some safety
11:39:18 <yazirian> but nevertheless, I was productive sooner in lisp due to the obstacle being removed :)
11:39:44 <jak> I suppose the problem is that you can have pure functions represented in the IO monad, but you can't have non-functional actions represented without such a monad.
11:39:45 <shapr> I opine that you would have the same trouble learning lisp/C/Java if you had started with Haskell or some other purely functional language.
11:40:08 <jak> I find designing Haskell programs quite difficult.
11:40:12 <yazirian> I am confident that if you came from Haskell, Java would drive you to drink, yes.
11:40:17 * shapr laughs
11:40:21 <dennisb> to such a programmer you jusr say that in C all functions are -> IO ret_val
11:40:57 <jak> In a way, the monads let fragements of code become first class.
11:40:58 <dennisb> or maybe clearer: ... -> IO ret_type
11:41:07 <jak> (should be fragments)
11:41:30 <shapr> I think monads go even further, you get first class 'actions'
11:41:44 <jak> yeah
11:41:47 <shapr> the 'execution of a piece of code' is a first class value.
11:42:19 <yazirian> that is not only good, but also excellent (god I love first-class functions in python, for example)
11:42:21 <shapr> much like continuations, it's brain-twisting at first
11:42:36 <jak> yes, I haven't understood continuations yet.
11:42:40 <shapr> but imho, it's just a 'higher resolution' than we're used to, just like continuations.
11:43:00 <yazirian> the key to understanding those modes, though... lives in understanding how to provide your program with some data that comes from IO
11:43:13 <yazirian> which is why I use vi as my example 
11:43:25 <jak> I see.
11:43:39 <jak> insert mode is I/O, command mode is the rest?
11:43:49 <yazirian> kinda
11:44:13 <shapr> In my opinion, the best way is to create as much pure code as possible, and then call it from monadic code.
11:44:17 <yazirian> maybe more like, the pure part is my document, and IO provides me only command-mode
11:44:30 <yazirian> which makes actually writing something into my document a tricky proposition
11:44:38 <shapr> can you give an example?
11:44:38 <jak> have you seen the 99 bottles of beer web site?
11:44:56 <yazirian> yep
11:45:59 <jak> I thought it was really good. especially the Cobol and RPG/400 examples.
11:46:28 <shapr> I usually use "val <- readLn" to 'strip off' the IO so I can pass around val as if it were a pure value.
11:46:49 <yazirian> i kiss you
11:46:50 <asmodai> mmm, opera 7.20, beta 10, going nice
11:46:54 <yazirian> hehe
11:48:08 <shapr> yazirian: do you have an example of the tricky proposition?
11:48:24 <yazirian> I'm still looking... might be on my home machine
11:48:37 <shapr> ok
11:48:38 <yazirian> hooray for ssh, let's see shall we? :)
11:49:06 <shapr> hoi Vincenz, ltns
11:49:10 <shapr> hoe gaat?
11:49:15 <asmodai> het
11:49:19 <asmodai> Hoe gaat het
11:49:29 <shapr> bah, can't I just say "how goes?" 
11:49:33 <asmodai> Nope.
11:49:35 <asmodai> Not in Dutch.
11:49:36 <shapr> it works in english...
11:49:40 * shapr grins innocently
11:49:45 <asmodai> Dutch is lingered with 'het', 'er' and such
11:49:55 <shapr> and lots of ij combos
11:49:57 <asmodai> to refer to abstract situations
11:50:15 <shapr> I even have one of those ij combos in my name!
11:50:18 <shapr> Matijs
11:50:38 <asmodai> shapr; Heuh?  You're Dutch or something? :)
11:50:44 <shapr> nah, I'm from Alabama.
11:50:55 <asmodai> <-- confused.
11:51:16 <shapr> well, I'll be in Leuven sometime soon, where are you? ;-)
11:51:21 <shapr> I'd be happy to tell you the story over a beer.
11:51:25 <Vincenz> hey shapr
11:51:26 <Vincenz> :)
11:51:27 <asmodai> shapr; Near Den Haag.
11:51:38 <shapr> oh
11:51:42 * shapr finds a map
11:52:07 * asmodai tries to remember where Leuven was exactly.
11:52:08 <asmodai> Anyway
11:52:24 <asmodai> from Belgium you often drive to Turnhout/Baarle Nassau/Hertog
11:52:27 <asmodai> on to Breda
11:52:28 <shapr> ~200km it seems.
11:52:37 <asmodai> on to Dordrecht, on to Rotterdam, and then Den Haag
11:52:49 <asmodai> or take Antwerpen -> Dordrecht -> Rotterdam
11:53:18 <asmodai> I so like this:
11:53:19 <asmodai> http://pike.ida.liu.se/development/pikefarm/7.5.xml
11:53:55 <asmodai> xenofarms are cool :)
11:55:40 <shapr> Vincenz: how's OCaml treating you?
11:55:46 <Vincenz> like peach
11:55:56 <Vincenz> though I'm planning a project and I need some things that are missing
11:56:01 <yazirian> ocaml: functional programming's answer to C++ ;)
11:56:07 <shapr> asmodai: have you used functional languages before?
11:56:08 <Vincenz> Like 32 bit Floats and 64 bit Doubles
11:56:13 <Vincenz> yazirian: don't like Ocaml?
11:56:14 <asmodai> shapr; mmm, nope.
11:56:28 <asmodai> shapr; procedural, mnemonic/assembler, and OO.
11:56:29 <yazirian> I think it's pretty cool actually.
11:56:33 <Vincenz> shapr: did you know I competed in icfp?
11:56:38 <Vincenz> shapr: in Scheme though
11:56:39 <yazirian> Although I wish I understood better why it has a single pass linker.
11:57:26 <shapr> Vincenz: no, I didn't know that.
11:57:28 <Vincenz> yazirian: hmm, Ocaml uses the linker from gcc or msvc iirc
11:57:40 <Vincenz> shapr: with Riastradh and lambda
11:57:51 <yazirian> hmm, maybe it isnt the linker then
11:57:51 <shapr> asmodai: Haskell would be a pretty radical change from those.
11:58:02 <yazirian> just that the order of linked packages matters powerfully, and cannot refer to one another
11:58:18 <asmodai> shapr; I figured as much :)
11:58:40 <Vincenz> asmodai: if you want to start with a functional language, start with scheme
11:58:44 <shapr> @eval foldl (\x y. x + y) 0 [1,2,3]
11:58:45 <lambdabot> 6
11:59:04 <shapr> I say jump in ;-)
11:59:27 <shapr> but I'm probably biased
11:59:31 * shapr waves the lambda pom-poms
12:00:05 <yazirian> that reminds me of a funny quote
12:00:14 <Vincenz> @eval (\ x x. x x) (\ x x. x x)
12:00:14 <lambdabot> <<EM Dynamic -> EM Dynamic>>
12:00:23 <yazirian> Me? I hate the whole lambda calculus, not because of what it is, but because of what many people think it is. They think that it's the whole of computer science, the ultimate way to express and reason about programs, when in reality it's merely a shabby and incomplete model of how Fortran fails to work. The first thing SICP has to do is teach everyone how bad the lambda calculus model is -- as part of teaching them about a language allegedly 
12:00:28 <Vincenz> @eval (\ x . x x) (\ x. x x)
12:00:30 <yazirian> I'm sorry, was my bias showing again? :-)
12:00:32 <yazirian> William Tanksley, 13 May 2000 
12:00:54 <lambdabot> out of fuel - use @resume to continue
12:01:00 <Vincenz> yazirian: yes.... I do agree however that lambda, while a nice mathematical tool is very unpratical
12:02:56 <shapr> I'm hoping to understand more about type theory by starting with a lambda cal interpreter, and going up to full System F
12:04:02 <shapr> lambda calculus -> simply typed lambda calculus -> polymorphically typed lambda calculus -> whatever System F is...
12:05:08 <shapr> yazirian: have you seen Joy?
12:05:32 <Vincenz> what's System F
12:05:39 <Vincenz> and shapr: whats Joy? I've read about it but cant' remember
12:05:58 <shapr> @foldoc "system f"
12:05:59 <lambdabot> *** "System F" foldoc "The Free On-line Dictionary of Computing (09 FEB 02)"
12:05:59 <lambdabot> System F
12:05:59 <lambdabot>    A {type system} by J-Y. Girard.  Also known as Lambda-2 or the
12:06:00 <lambdabot>    {polymorphic lambda-calculus}.
12:06:04 <lambdabot>    ["Proofs and Types", J-Y. Girard, Cambridge U Press 1989].
12:06:08 <lambdabot> [3 @more lines]
12:06:39 <shapr> Joy is a programming language, http://www.latrobe.edu.au/philosophy/phimvt/joy.html
12:06:59 <shapr> it's fun
12:07:10 <shapr> though maybe a bit too concise.
12:08:19 * yazirian takes a peek
12:11:13 <yazirian> oh neat
12:11:25 <shapr> DEFINE approxEqual == 100.0 / rotate [0 =] [pop] [dup rolldown - swap /] ifte > .
12:11:30 <yazirian> while at the same time, evil
12:11:31 <yazirian> :)
12:12:03 <shapr> I think it'd make a good shell scripting language.
12:12:57 * SyntaxPolice now realizes that he tried 2.5 months ago to build gcjni and failed then too
12:12:57 <yazirian> I think it would shatter the minds of the people who actually use shell scripts (sysadmins) :)
12:13:16 <SyntaxPolice> I guess its compatibility problems w/ greencard
12:13:40 <SyntaxPolice> I keep lowering my standard, hopingg I can get _something_ to build, but now for some reason this makefile is trying to execute a haskell source program (not in a good way) :(
12:13:47 <SyntaxPolice> (afrob makefile)
12:13:57 <shapr> you should post to the list
12:13:59 <Vincenz> shapr: I don't see the difference between Joy and Forth?
12:14:01 <shapr> make Henrik work!
12:14:05 <shapr> Vincenz: lots of difference!
12:14:11 <Vincenz> ?
12:14:31 * Darius had no problem getting Haven/Yampa/etc to work a while back.
12:14:33 <shapr> Joy is a functional language.
12:14:40 <shapr> Forth isn't
12:17:10 <yazirian> it's like functional assembly :)
12:17:15 <mgoetze> YES!
12:17:28 <mgoetze> i just got an audiotrix pro on ebay, for only 3 EUR!
12:19:57 <Vincenz> audiotrix?
12:25:15 <SyntaxPolice> Darius: a while back you might have had the same configuration as they aparently use at yale.
12:25:28 <SyntaxPolice> having newer greencard and ghc6 complicate things somewhat
12:27:11 <SyntaxPolice> and having a newer version of gmake
12:30:04 <shapr> @type (+)
12:30:05 <lambdabot> (+) :: Num a => a -> a -> a
12:30:10 <shapr> @type (1.0 +)
12:30:10 <lambdabot> (1.0 +) :: Fractional a => a -> a
12:30:14 <shapr> @type (1 +)
12:30:14 <lambdabot> (1 +) :: Num a => a -> a
12:30:26 <shapr> @type ((1 :: Int) +)
12:30:27 <lambdabot> (1 +) :: Int -> Int
12:30:48 <Vincenz> wow
12:31:11 <Vincenz> what's a good haskell impl?
12:31:13 <shapr> @type ((1 :: Float Double) +)
12:31:17 <shapr> oops
12:31:21 <shapr> @type ((1 :: Float) +)
12:31:21 <lambdabot> (1 +) :: Float -> Float
12:31:29 <Vincenz>  @type ((1 :: Double) +)
12:31:30 <shapr> Vincenz: I prefer GHC.
12:31:39 <Vincenz> it seems VERY similar to Hugs
12:31:46 <shapr> there are many similarities :-)
12:32:00 <Vincenz> what would you call the blaring differnces? (and I'm on windows..)
12:32:00 <yazirian> ghci makes my mind hurt sometimes though
12:32:12 <shapr> but GHC is a compiler written in Haskell, and Hugs is an interpreter written in C
12:32:27 <Vincenz> compile -> native or bytecode?
12:32:41 <shapr> native for some definition of native
12:32:55 <yazirian> I have seen things that lambdabot likes get spit out by ghci
12:33:06 <Vincenz> such as whot?
12:33:08 <shapr> yazirian: if you mean the @eval plugin, they're not the same thing.
12:33:17 <yazirian> I figured that out pretty quickly :)
12:33:20 <shapr> heh
12:34:58 <Darius> Vincenz:  Actually, GHC compiles to bytecode too, when using GHCi.
12:35:22 <Darius> GHC and Hugs also support different extensions, though they are mostly compatible.
12:35:58 <Darius> Anyways, I much prefer GHCi simply because you can define functions inline.
12:36:43 <shapr> what's up with haskell.org?
12:36:47 <shapr> I get connection refused.
12:37:20 <shapr> @type (1 %)
12:37:20 <lambdabot> (1 %) :: Integral a => a -> Ratio a
12:38:13 <Vincenz> thnx darius
12:38:18 <Vincenz> I have a question about typeclasses
12:38:19 <Darius> seems down
12:38:29 <Vincenz> let's say that Int and String support some operation Fubar, but Num doesnt
12:38:34 <Vincenz> and a function uses the operation Fubar
12:38:39 <Vincenz> what type will the argument be?
12:38:41 <Vincenz> String or Int?
12:38:46 <shapr> it won't be either
12:38:56 <shapr> it'll be Fubar => a
12:39:06 <Vincenz> what if you pass it a Num then?
12:39:12 <shapr> Num isn't a type
12:39:14 <Vincenz> Float
12:39:18 <shapr> @type (+)
12:39:18 <lambdabot> (+) :: Num a => a -> a -> a
12:39:25 <mgoetze> Vincenz: a sound card
12:39:37 <shapr> that means, as long as the type 'a' is an instance of Num, addition will work.
12:39:54 <shapr> if you decide to make an instance of Num for Char, you could.
12:40:14 * Vincenz nods
12:40:28 <Vincenz> so
12:40:30 <shapr> http://kungens.kemi.fi/~shae/src/haskell/Demo.hs
12:40:35 <Vincenz> let's say this:
12:40:47 <shapr> there's some typeclass stuff at the bottom of that file.
12:41:04 <Vincenz> typeclass B supports everything in A (could be called a subclass) and C is not related to A but both B and C have some operation xxx, what type is the parameter to the operation xxx?
12:41:23 <Vincenz> (by typeinference)
12:41:49 <Darius> B and C couldn't both have an xxx method.
12:41:50 <shapr> I think you run into the allow overlapping instances stuff here
12:42:06 <shapr> and that's after what Darius said :-)
12:42:06 <Vincenz> Darius: why wouldn't they?
12:42:27 <Vincenz> take for instance Print
12:42:33 <Vincenz> you can print a string and an int, but not a num
12:43:24 <shapr> @type show
12:43:24 <lambdabot> show :: Show a => a -> String
12:43:40 <shapr> @type (show 1)
12:43:40 <lambdabot> show 1 :: Num a => [Char]
12:43:56 <Darius> You can't have class A a where { xxx :: a } and class B a where { xxx :: b }
12:44:13 <Darius> shapr: do you need to upgrade Hugs?
12:44:18 * shapr dunno
12:44:26 * shapr checks
12:44:40 <Darius> typeclasses are not the same as classes in an OO language.
12:44:52 * Vincenz nods
12:45:16 <Vincenz> Darius: so how does type-inference work?  I maen if all functions are generalized, where does type-checking occur?
12:45:31 <Vincenz> at runtime?
12:45:49 <Vincenz> Show takes a general parameter a, where does it typecheck it that it's not for example a....Foobar
12:46:04 <shapr> @type (show 1)
12:46:05 <lambdabot> show 1 :: Num a => [Char]
12:46:12 * shapr shrugs
12:46:21 <Vincenz> @type (show color)
12:46:22 <shapr> I just upgraded to SyntaxPolice's latest package.
12:46:48 <shapr> sadly, the @type command leaves defunct hugs processes around
12:47:03 <Vincenz> This is very confusing
12:47:14 <SyntaxPolice> shapr: hugs-cvs needs a teeny amount of work. I have a patch from ross that I haven't been able to apply.
12:47:16 <SyntaxPolice> stay tuned!
12:47:24 <shapr> Vincenz: a typeclass is a dictionary of instances, it's easy to typecheck
12:47:27 <Vincenz> Ocaml is very strict on what functions can do, but it does allow for compile-time type-checking with type-inference
12:47:33 <SyntaxPolice> (read h"aven't been able" as "haven't had time")
12:47:59 <shapr> SyntaxPolice: cool, am looking forward to it.
12:48:19 <SyntaxPolice> do you see any problems with that package?
12:48:25 <shapr> ?
12:48:47 <shapr> oh, is hugs-cvs in H-E?
12:48:54 <shapr> hm
12:49:52 <Vincenz> hmmm
12:49:55 <Vincenz> www.haskell.org is down
12:50:13 <shapr> gah, must reboot emacs again.. :-(
12:50:36 * shapr should practice safe computing more often
12:51:00 <Vincenz> use VIM :P
12:51:04 <Darius> A typeclass is like a collection of types that support a function.  Each instance declaration adds a type to that collection.
12:51:19 <Vincenz> darius: so where do you define a typeclas?
12:51:29 <Darius> It's quite easy to tell that show FooBar won't work as FooBar is not in that collection.
12:51:45 <Darius> In a class declaration
12:52:23 <Vincenz> typeclasses are something inherent?
12:52:32 <Vincenz> you don't actually define a typeclass to say which types support show?
12:52:39 <Darius> I don't get what you mean.
12:52:46 <Vincenz> well
12:52:52 <Vincenz> Int supports Num, String supports Num
12:53:01 <Vincenz> (I mean show, not num)
12:53:03 <Vincenz> so there's some typeclass Supports_Show
12:53:20 <Vincenz> you don't actually define that typeclass? It's by defining show in Int and String that they are added to this typeclass?
12:53:30 <Darius> String is not an instance of Num.
12:53:47 <Darius> You have it somewhat backwards.
12:53:48 <Vincenz> %s/supports Num/supports Show/g
12:53:56 <Darius> You add Int and String to the typeclass.
12:54:11 <Vincenz> so typeclasses are defined when defining funcs?
12:54:52 <Vincenz> ok...I'll try with an example
12:55:01 <Vincenz> let's say I make some complex function that supports numbers
12:55:14 <Vincenz> it supports numbers because it uses a function only supported by numbers
12:55:33 <Vincenz> now someone adds this used function to string, does this mean they'll have to edit my source to say that my function now too supports string?
12:56:49 <Darius> Your terminology isn't correct.  A function doesn't "support" numbers.  It can take arguments or return values that can be in the Num class.
12:56:58 * Vincenz nods
12:57:09 <Vincenz> that's what I meant, I'm just a lazy typer
12:57:41 <Darius> While typeclasses aren't like classes in OO, they are somewhat similar to abstract base classes or Java interfaces.
12:57:50 * Vincenz nods
12:58:21 <Darius> print :: Show a -> IO () and is more or less defined as putStrLn . show
12:58:42 <Darius> Er, print :: Show a => a -> IO ()
12:58:47 <Vincenz> hmm
12:59:01 <Vincenz> how does the typechecker know what type a may be?
12:59:07 <Darius> All print needs to know about it's argument is that it's an instance of the Show class.
12:59:14 <Vincenz> oh
12:59:16 <Vincenz> well...
12:59:27 <Vincenz> what if I make some other type that can also be shown?
12:59:32 <Vincenz> how would I add it to this Show class?
13:00:17 <Darius> with an instance declaration, e.g. 'instance Show FooBar where show FooBar = "FooBar"'
13:00:19 <dennisb> you make the type into an instance of the Show class
13:00:30 <Vincenz> ah
13:00:33 <dennisb> the function print stays the same
13:00:39 <Vincenz> but I have to do this manually
13:00:45 <Vincenz> it's not done through type-inference
13:00:45 <Darius> This could be vaguely reminiscent of having FooBar implement a Java interface.
13:00:51 * Vincenz nods at Darius
13:01:05 <Vincenz> I'm just trying to see how Haskell works wrt Ocaml
13:01:17 <Vincenz> alright...
13:01:18 <Vincenz> now...
13:01:21 <Vincenz> my function calls Show
13:01:36 <Vincenz> my_fancy_cool_func a -> something
13:01:57 <Darius> Vincenz: how could it be done throught type-inference?  You can't infer an implementation.
13:02:10 <Vincenz> hmm...so there's no type-inference in Haskell?
13:02:26 <Igloo> There is
13:02:32 <Darius> Yes, Haskell is type-inferred.
13:02:49 <Vincenz> what is there inferred if you have to define everything yourself (not trying to be critical, just trying to learn
13:02:49 <Darius> @type putStrLn . show
13:02:50 <lambdabot> putStrLn . show :: Show a => a -> IO ()
13:03:17 <Igloo> What is it you think can't be done? I'm a little lost
13:03:20 <Vincenz> so if my function uses that statement it knows the parameter has to be of class Show?
13:03:49 <Igloo> There must be a Show instance for the type of the first argument, yes
13:03:53 * Vincenz nods
13:03:54 <Vincenz> so...
13:04:04 <Darius> If you use any method of class Show it knows that your parameter needs to be of class Show.
13:04:08 <dennisb> you can see the "Show a" as an extra argument to print, to use print with a string you send in the string instance for Show and the string
13:04:10 <Vincenz> let's say my special_cool_func is already compiled in a lib...
13:04:21 <Vincenz> so the different instances have been implemented
13:04:31 <Igloo> Not exactly
13:04:36 <Vincenz> and now someone creates a new type supporting show, how is an extra implementation of my special_Cool_func generated?
13:05:04 <Igloo> Think of the real type of print as being   showdictionary_for_a -> a -> IO ()
13:05:19 <Igloo> But the dictionary passing is all handled behind the scenes for you
13:05:21 <Vincenz> so it doesnt' generate different instances for each type int he typeclass?
13:05:32 <Igloo> Compilers might as an optimisation
13:05:36 <Vincenz> ah
13:06:33 <Vincenz> just seems like a lot of code-bloat if every function that supports Show type has to have an extra instance becasue someone made a new type supporting show for just a little code
13:07:01 <dennisb> Vincenz: yes, it would not work very well with separate compiling
13:07:13 <Vincenz> Ah, so there's no separate compiling?
13:07:18 <dennisb> there is
13:07:20 <Darius> That's why Haskell compilers don't typically specialize functions.
13:07:24 * Vincenz scratches hiss head
13:07:31 <Igloo> specialisation is only done if you ask for it with a pragma or if the compiler works out you only ever call it with 1 type
13:07:42 <dennisb> but if you had to recompile every function just because you added an instance it would not work
13:07:45 <Vincenz> Darius: if you don't specialize functions you don't have compile-type checking but runtime-checking like Jvava
13:07:46 <Igloo> (that may not be exactly right, but it certainly doesn't specialise everything for everything in sight)
13:08:04 <Igloo> There's no runtime type checking
13:08:07 <Vincenz> %s/Jvava/Java/g
13:08:13 <Igloo> There is runtime dispatch - that's what the dictionaries are for
13:08:26 <Vincenz> and if it doesn't find a type int he dictionary?
13:08:29 <Vincenz> it throws an exception?
13:08:41 <Darius> Vincenz: You end up with runtime-dispatch -NOT- runtime type checking
13:08:41 <dennisb> Vincenz: the user of the functions sends in the correct dictionary
13:08:42 <Igloo> The dictionary passed is specific to the type
13:08:48 <Smerdyakov> Well, Java does do "runtime type checking" for downcasts.
13:08:48 <Darius> The dictionary is presumed to be correct.
13:08:58 <Igloo> It will be the Show dictionary for Int if an Int is being passed
13:09:11 <Vincenz> hm
13:09:19 <Vincenz> I still don't see exactly how it would work
13:09:28 <Vincenz> either you have runtime-type-checking or you have codebloat
13:09:34 <Darius> -compile-time- typechecking ensures that you can't pass the wrong dictionary.
13:09:54 <dennisb> Vincenz: then you have code bloat with that definition
13:09:54 <Vincenz> Darius: so what of my example of my_special_func already compile in a lib, and someone extends the show-class?
13:10:20 <dennisb> Vincenz: what type does your function have?
13:10:28 <Igloo> What do you mean by "extends"?
13:10:31 <Vincenz> dennisb: none, but it calls show
13:10:33 <Igloo> You can't add new methods to it
13:10:37 <Vincenz> Igloo: define a new instance of Show-class
13:10:48 <Vincenz> add an extra one to the show_class dict
13:10:50 <Igloo> Then your compiled library doesn't change
13:10:55 <Igloo> No!
13:11:04 <Igloo> There is a separate dictionary for each type
13:11:08 <Vincenz> hmm...
13:11:12 <Vincenz> ok...
13:11:12 <Darius> Then my_special_func is passed a different dictionary with different functions.
13:11:22 <Igloo> The dictionary is a list of pairs of method names and functions
13:11:35 <Vincenz> ..
13:12:01 <Darius> It would be like writing: print showFunc a = putStrLn (showFunc a)
13:12:22 <Darius> Adding a new instance of Show, would simply pass a different showFunc.
13:12:34 <Vincenz> my_special_func has NOT been typed in the code...but it calls Show (only show)...plus does some extra none-type-specific stuff....so naturally the type that my_special-func can generate is Show a....   I compile it into a library...someone uses my library and makes a new type that also supports show, how does that reflect upon my_special_func?
13:12:58 <Vincenz> Darius: ah that starts to make sense :)
13:13:08 <Darius> It is passed a different function implementing the show operation.
13:13:14 <dennisb> then your function has type (say): Show a => a -> Bool and the real under the hood type is then ShowDict -> a -> Bool
13:13:24 * Vincenz nods :)
13:13:28 <dennisb> the dictionary is like a vtable in c++
13:13:29 <Vincenz> Thanks for baring with me
13:13:37 <Vincenz> still seems like a lot of runtime computation
13:13:42 <dennisb> it is
13:14:08 <Smerdyakov> Vincenz, but it's completely necessary for many cases of type class usage, and it can be optimized away where relevant information is statically known.
13:14:09 <Vincenz> I guess that's why Ocaml is more performant, it's much stricter
13:14:11 <dennisb> when you want to actually show the a-value you look up the show method in the passed along dict and use that
13:14:12 <Igloo> It's only a single memory lookup per function call
13:14:20 <Vincenz> Smerdyakov: true
13:14:43 <Igloo> Sorry, 2 lookups, although I'd have thought the dictionary was often in a register
13:14:46 <Vincenz> Igloo: hmm, you have to find the correct show function in a table
13:14:55 <Darius> The overhead of runtime dispatch is the same as it is in most OO languages.
13:14:59 <Vincenz> Sorry ofr the many questions
13:15:14 <Igloo> But that's a constant offset
13:15:15 <dennisb> Vincenz: but finding the show table is not hard.
13:15:25 <Vincenz> Darius: and I thought that type-inference was to prevent such things(at least that's the impression I got when I learned Ocaml)
13:15:42 <Darius> And there are only a few cases where it's absolutely necessary for a runtime lookup to be used, however most implementations use the runtime dispatch implementation normally.
13:15:47 <Smerdyakov> Vincenz, if you don't like to use type classes, then don't use them....
13:15:56 * Vincenz nods
13:16:57 <Vincenz> so assuming I'm some newbie (well...not assuming) and I make a function "double_it" that takes an int, and I want to make a second func that takes a list of ints... I can just make two versions of the func double_it and it would work?
13:17:04 <Vincenz> (without using type-classes)
13:17:15 <Darius> No
13:17:23 <Darius> Unless you rename them ;)
13:17:24 <dennisb> nope, you have to use different names then
13:17:27 <Vincenz> ah thxn
13:17:30 <Vincenz> just like ocaml then :)
13:17:40 <Vincenz> I guess you could then compare type-classes to parametrized modules
13:17:49 <dennisb> but you can make your own DoubleIt class
13:17:57 <Darius> Alternatively, you could abstract out the "doubling" function and pass it in ;)
13:18:19 <Vincenz> Darius: that would leave one VERY empty double_it :P
13:18:30 <Vincenz> double_it f x = f x
13:19:12 <Vincenz> but I'm starting to get the idea, thnx for baring with me
13:19:35 <dennisb> and then you make double_int_dict x = 2*x   and double_list_int_dict xs = [x*2|x<-xs]
13:19:54 <dennisb> that you pass in as the first argument depending on what type you want to use it on
13:20:09 <Vincenz> what's the advantage of that instead of just calling the funcs double_int_dict?
13:20:25 <Vincenz> never mind
13:20:31 <Vincenz> it would be for more complex things
13:20:35 * Vincenz bops his own head
13:20:40 <dennisb> with type classes the compiler send in the correct dict for you depending on what type you happend to use
13:20:44 <Vincenz> sort compare list
13:21:02 * Vincenz nods dennisb
13:21:04 <dennisb> so you just call the function with an Int and the compiler knows where the Int-dics is and sends it in
13:21:19 <Vincenz> so my statement that typeclasses are very much like modules is pretty accurate?
13:21:27 <Vincenz> modules in ocaml..
13:21:44 <dennisb> if you add an instance for Foo and use the function on a Foo, then the compiler knows where that dics is and send it in
13:21:46 <dennisb> yea
13:21:49 <dennisb> I guess
13:21:52 <Vincenz> cool :)
13:21:54 <Vincenz> Thanks 
13:21:56 <dennisb> I'm no ocaml guru
13:22:00 * Darius doesn't know OCaml
13:22:47 <Vincenz> do all these questions bother you or do you think they stimulate talk?
13:23:25 <dennisb> Even though i don't really know ocaml i've heard people comparing classes in haskell with modules/functors(?) in ocaml
13:23:30 <dennisb> it's just fun
13:23:30 <Igloo> Asking questions about Haskell is vital
13:23:40 <Igloo> Otherwise people start talking about python and suchlike  :-)
13:23:46 <Vincenz> I might have some other questions
13:23:48 <Vincenz> :P
13:24:17 <mgoetze> or, worse yet, they start talking about timelines and beach volleyball
13:24:45 <Vincenz> I know that Haskell, unlike Ocaml, is purely functional.  What this means is that for IO, you would pass a continuation to tell it what to do with the following function.  I still don't get the full implication on how Monads work.
13:25:01 <dennisb> mgoetze: our own beach volleyball is not here now
13:25:56 <Igloo> I guess you could think of  x >>= y  as x with continuation y
13:26:36 <Igloo> And  do {x; y}  gets rewritten to the above (that's slightly inaccurate, but the gist)
13:27:17 <Vincenz> but purely functional means that calling some func with the same args leads to the same result, how does this work with IO?
13:27:52 <Darius> Here's an interesting paper on what "pure functional" means and how monads maintain it: http://citeseer.nj.nec.com/sabry98what.html
13:27:54 <Igloo> Because there's a hidden value RealWorld which all IO functions take as an argument and return as part of the answer
13:28:04 <Igloo> RealWorld is hidden inside the monad
13:28:45 <Vincenz> funky
13:29:59 <Vincenz> that would go for any state-system? you'd have to pass some supercomplex structure into and out of all funcs...
13:30:01 <Vincenz> must be a pain
13:30:29 <Darius> What supercomplex structure?
13:31:18 <Vincenz> well any state-based system would have to pass the state-structure to all funcs
13:31:36 <Vincenz> and most programs require states
13:31:51 <Darius> And what is the state-structure?
13:31:59 <Vincenz> hmm....
13:32:20 <Igloo> You don't explicit pass the state around though
13:32:43 <Vincenz> for example....an irc server would need to remember all it's users and connections
13:32:46 <Igloo> The >>= operator does it for you
13:33:04 <Vincenz> oh :)
13:33:07 <Igloo> And the monad would have functions to be able to look at it and change it
13:36:48 <Vincenz> so what's the advantage of purely functional if the end you have monads?
13:37:01 <Vincenz> why not allow some impurity like in ocaml?
13:37:23 <Igloo> Because you know exactly where the impurity is
13:37:28 <Vincenz> hmm
13:37:30 <Vincenz> true
13:38:11 <Igloo> And a state monad isn't really impure - you could trivially rewrite it to pass the state explicitly
13:38:36 <Igloo> With the IO monad of course the primitives are actually side-effectful
13:39:48 <Darius> Not only do you know exactly where some impurity is, you can control the amount of it.
13:41:09 <Vincenz> seems like quite a hassle though
13:41:43 <dennisb> types at all is a hassle
13:43:58 <Darius> Having to look through an entire program to find which function flipped some flag that it "shouldn't've" is also a hassle.
13:44:18 <Vincenz> never had that problem
13:44:33 <Vincenz> and I program in C at work, and I've done C++ and JAva in my last project
13:45:11 <Igloo> If you've ever had a segfault you ought to appreciate types  :-)
13:49:52 <Vincenz> never had a segfault :P
13:51:05 <Igloo> Ah, you just write the code, you don't run it?  :-)
13:51:16 <Igloo> Bah, alpha compile broke
13:54:28 * Vincenz grins at Igloo
13:56:46 <Binkley> reneerob we give up
13:59:59 <Binkley> oops, I hate when that happens
14:15:13 <Xcalibor> hiyas
15:08:00 * Vincenz grumbles
15:08:48 <Vincenz> Anyone know anything about hotswapping code?
15:10:29 <whee> I know about it in relation to erlang
15:17:40 <Darius> It's best just to ask questions rather than polling to see who will answer some unknown question.
15:18:57 * Riastradh doesn't even know what 'hotswapping' is.
15:19:51 <whee> Riastradh: replacing code at runtime
15:20:14 <Riastradh> In that case, I, too, know about it in relation to Erlang but nothing else.
15:21:46 <Vincenz> I asked if it's possible in Ocaml, but noone responded.  I read it's possible in Erlang
15:22:21 <Riastradh> It's very easy in Erlang.
15:22:34 <Riastradh> I wish it were like that easy in other languages.
15:22:41 <Riastradh> s/like//1
15:22:58 <whee> it may be possible to do something like it with the Dynlink module
15:25:35 * Vincenz thanks whee
15:25:50 <Vincenz> Riastradh: or the ease of rpc in erlang :P
15:28:24 <Vincenz> just like passing a func to another func in a functional language
15:28:33 * Vincenz drools
15:29:32 <Riastradh> Vincenz, yeah, and just imagine how easily that sort of thing could be exploited...whoa, the process dictionary just emptied!
15:31:54 <Vincenz> well, you have to make sure to apply the appropriate amount of security in your server code
15:32:04 <Vincenz> There ain't such a thing as a free lunch (tm)
15:32:18 <Vincenz> TASATAAFL
15:33:36 <whee> Vincenz: gesundheit
15:33:41 <whee> :)
15:33:49 <Vincenz> hehe :P
15:37:01 <Darius> actually it's TANSTAAFL
15:39:19 <Vincenz> There ain't no such thing?
15:39:43 <Vincenz> sounds very much like AANTAFEL ("to the table"in dutch, as in when you're ready to eat dinner)
15:42:36 <Vincenz> Ik ben een helikopter.
15:44:37 <Darius> yes, "there ain't no such thing as a free lunch"
16:14:32 <kosmikus> Does anyone know a formal analysis of a lambda-calculus with polymorphic kinds?
16:26:11 <Darius> Follow citations in the polytypic and generic literature perhaps.
16:32:49 <kosmikus> yes, I would have expected to find something there, but either it is too late or I am blind or {insert other reason here}
16:33:10 <kosmikus> I should continue my search tomorrow ...
17:02:50 <Riastradh> Hmm.
17:05:32 <Riastradh> Mumble!
17:05:45 <Igloo> ?
17:05:47 <Pseudonym> @yow
17:05:48 <lambdabot> ..  Should I get locked in the PRINCIPAL'S OFFICE today --
17:05:48 <lambdabot>  or have a VASECTOMY??
17:06:50 <Riastradh> Around when did monads supersede CPS in terms of popularity in Haskell?
17:07:52 <Pseudonym> I think around Haskell 1.4.
17:07:56 * Pseudonym might be wrong on that
17:08:00 <Riastradh> ...and when was that?
17:08:03 <mgoetze> Riastradh: you might want to post that question to comp.lang.functional.haskell.history.obscure or something :)
17:08:08 <Igloo> The old reports are online if you want to look
17:08:14 <Riastradh> Where?
17:08:25 <Igloo> Although presumably the change predated the appropriate standard by some amoutn of time
17:08:30 <Pseudonym> Yes.
17:08:39 <Pseudonym> I think monadic IO might have been in gofer first.
17:08:40 <Igloo> http://www.haskell.org/definition/
17:08:48 <Pseudonym> Or maybe that was when they changed gofer to hugs.
17:09:37 * Riastradh grumbles at the fact that you can't browse the old reports...you have to download a tarball!
17:09:50 <Pseudonym> A Google News search might give you the info.
17:09:53 <Pseudonym> Sort by date.
17:10:14 <Igloo> They probably aren't the most frequently accessed documents in the world  :-)
17:11:54 <Pseudonym> OK, monadic IO dates back to 1993.
17:12:00 <Pseudonym> That's earlier than I thought.
17:13:05 <Pseudonym> unsafePerformIO dates from then too!
17:13:19 <Pseudonym> Gofer appeared to implement it first.
17:13:44 <Riastradh> What were some of the arguments of proponents of monads?
17:13:45 <Pseudonym> And it went into 1.3, around 1995.
17:13:52 <Pseudonym> So best guess is 1994.
17:13:58 <Igloo> Bah, Haskell list archives are on porky.devel.redhat.com which seems to have disappeared
17:14:33 <Pseudonym> LOL!
17:14:39 <Pseudonym> >Yes, I think monads are very clever, but since it is taking me longer to
17:14:39 <Pseudonym> >understand them after 5 years in the field than it took me to understand
17:14:39 <Pseudonym> >Prolog as a novice, I don't think they will become very popular. How will
17:14:39 <Pseudonym> >third year undergraduates ever understand them? 
17:15:46 <Riastradh> And what were some of the arguments against CPS?
17:15:53 <Pseudonym> I think the main argument was that they were much simpler than the alternatives.
17:16:02 <Pseudonym> Continuation IO, for example, has a synchronisation problem.
17:16:15 <Pseudonym> If your requests and responses ever get out of synch, you're in real trouble.
17:16:19 <Smerdyakov> I think the author of that blurb must be none too bright.
17:16:37 <Riastradh> OK, barring the topic of IO, what were some of the arguments against it?
17:16:57 <Pseudonym> Well, admittedly, this was in 1993, and in 1993 there were a LOT of people who were confused because the descriptions were all to complicated.
17:17:09 <Pseudonym> All the papers on monads at the time were heavy on the category theory.
17:17:27 <Riastradh> Against CPS, I meant in my last message.
17:17:28 <Pseudonym> And the guy is right in that sense: Third year undergraduates will, on the whole, never understand heavy category theory.
17:18:16 <Pseudonym> Oh, interesting.
17:18:22 <Igloo> UGs at Oxford don't get told about Monads at all, despite Haskell being used in about half the courses
17:18:27 <Igloo> Or was when I did my degree at least
17:18:30 <Pseudonym> The IO monad was originally introduced as a way to do GUIs.
17:18:40 <Pseudonym> I do remember that, now that I re-read this.
17:19:16 <Pseudonym> Continuation-based IO was considered inadequate for GUI stuff.
17:19:34 * Riastradh doesn't care about IO right now!
17:19:46 <Pseudonym> I know, but this is interesting. :-)
17:20:03 <Pseudonym> Another reason, I think was monad comprehensions.
17:20:12 <Riastradh> Monad comprehensions?
17:20:13 <Pseudonym> Which is a kind of predecessor of do notation.
17:20:20 <Pseudonym> Yes.  Consider the code:
17:20:34 <Pseudonym> do { x <- foo; y <- bar; return (f x y) }
17:20:39 <Pseudonym> In monad comprehension notation:
17:20:46 <Pseudonym> [ f x y | x <- foo, y <- bar ]
17:20:54 <Pseudonym> Just like a list comprehension.
17:21:18 <Riastradh> How wouldn't this work with CPS?
17:21:22 <Pseudonym> Monad comprehension notation was thought particularly elegant.
17:21:28 <Riastradh> ...
17:21:29 <Pseudonym> Well, I think it's a question of notation.
17:21:35 <Pseudonym> Of course you can do this with CPS.
17:21:44 <Pseudonym> It's just not particularly elegant.
17:22:19 <Pseudonym> \cont -> foo (\x -> bar (\y -> cont (f x y))
17:22:23 <Pseudonym> Just doesn't look as nice.
17:22:33 <Riastradh> Yes, that's why you'd have syntactic sugar.
17:23:10 <Riastradh> [ f x y | x <- foo, y <- bar ] would expand to your CPS expression.
17:23:18 <Riastradh> Or the 'do' notation would.
17:23:27 <Pseudonym> Yes.
17:23:32 <Pseudonym> Hmmm.
17:23:45 <Pseudonym> I think the reason CPS was dumped was that it was an unnecessary detail.
17:23:55 * Riastradh coughs.
17:24:05 <Pseudonym> If it didn't matter how things happened under the covers, why did it have to be CPS?
17:24:08 <Riastradh> How is CPS any more of an 'unnecessary detail' than monads?
17:24:32 <Pseudonym> It's not an unnecessary detail if it's exposed as the interface.
17:24:33 <Riastradh> Monads are really just syntactic sugar over an anti-generalization of CPS.
17:24:51 <Pseudonym> Hmmm.  Maybe.
17:25:04 <Pseudonym> Many monads are implemented internally as CPS.
17:25:07 <Pseudonym> Many are not.
17:25:29 <Pseudonym> CPS is general in the sense that it can be used to implement pretty much everything under the covers.
17:25:51 <Riastradh> But if you use monads for the interface, you restrict what you can do underneath.
17:26:30 <Pseudonym> How so?
17:27:47 <Riastradh> Do you mind if I give examples in Scheme so that Haskell's type system doesn't get in the way?
17:27:55 <Pseudonym> Uhm, OK.
17:28:06 * Pseudonym doesn't promise he'll be able to grok them, but OK
17:29:00 <Riastradh> OK.  A couple of utility functions before I begin: (cont val ...) returns (lambda (k) (k val ...)); (project k i) returns an n-ary procedure that applies K to the Ith argument of that n-ary procedure.
17:29:26 <mgoetze> Riastradh: you mean "do you mind if i do it in scheme so i don't accidentally make a mistake"? ;)
17:29:33 <Riastradh> ((project id 2) 0 1 2 3 4) would return 2, for instance.
17:29:44 <Darius> Have you read "The Essence of Functional Programming"?
17:29:45 <Pseudonym> OK.
17:29:57 <Riastradh> mgoetze, heh.  No, seriously, it's because of the variable arity procedures.
17:30:26 <Riastradh> Handling successes and failures with the Either type is fairly cumbersome.
17:30:33 <Pseudonym> BTW, interesting news article: http://www.google.com.au/groups?selm=C4ss0o.2Hn%40dcs.glasgow.ac.uk
17:30:52 <Pseudonym> Anyway, with you so far.
17:31:23 <Riastradh> Suppose we have instead of an Either type and Left and Right constructors, two procedures, SUCCEED and FAIL.
17:31:36 <Riastradh> (define (succeed . vals) (project (apply cont vals) 0))
17:31:42 <Riastradh> (define (fail . vals) (project (apply cont vals) 1))
17:32:09 <Pseudonym> Yes...
17:33:01 <Riastradh> Oh, when I said handling successes and failures with the Either type is fairly cumbersome, I meant using monads, not the 'either' function.
17:33:19 * Darius points to his earlier question... points at Riastradh then his earlier question.
17:33:25 <Riastradh> Darius, no.
17:34:01 <Darius> Section 3.4: Monads v. CPS  (actually Monads vs. CPS, damn illiterate Wadler ;)
17:34:08 <Pseudonym> Interesting claim from 1993: IO monads subsume the former approaches namely stream IO and continuation IO.
17:34:08 <mattam> what are you beginning Riastradh ?
17:34:24 <Riastradh> Hrm, wait, I need to think about this some more.
17:34:36 <Riastradh> Darius, is it on the web?
17:34:46 <Pseudonym> Hang on, why is using monads for handling successes and failures cumbersome?
17:35:03 <Pseudonym> You lost me on that point.
17:35:15 <Darius> http://www.research.avayalabs.com/user/wadler/topics/monads.html
17:35:32 <Pseudonym> OK, haskell 1.2 had both stream IO and continuation IO.
17:35:33 <Riastradh> A common Scheme example is with ASS{Q,V,OC} -- the list searchers.
17:35:57 <Pseudonym> I don't understand that notation.
17:36:16 <Riastradh> It's just an ordinary set notation.
17:36:16 <Riastradh> It means: ASSQ, ASSV, ASSOC.
17:36:32 <Riastradh> (ASSQ compares with EQ?, ASSV with EQV?, and ASSOC with EQUAL?)
17:36:35 <Riastradh> Er, I meant alist searchers there.
17:37:03 <Riastradh> (assq 'foo '((baz quux) (foo bar) (zot mumble))) ==> (foo bar)
17:37:22 <Riastradh> (assq 'mumble ((foo bar) (baz quux))) ==> #f
17:37:34 <Riastradh> (well, ok, this particular example would use Maybe, but Maybe is just a specific case of Either, really)
17:38:05 <Riastradh> In Scheme, one might write:
17:38:05 <Pseudonym> Ah, OK.
17:38:14 <Riastradh> (let ((maybe-cell (assq 'foo bar)))
17:38:16 <Riastradh>   (if maybe-cell
17:38:21 <Riastradh>     ...do stuff with it...
17:38:27 <Riastradh>     ...fail...))
17:38:51 <mattam> #f is nil ?
17:38:52 * Pseudonym nods
17:39:02 <Riastradh> Note that the alternative branch of the IF may contain arbitrary expressions.
17:39:19 <Riastradh> mattam, this is Scheme; there is no 'NIL' and #f is the boolean false value.
17:39:38 <mattam> hmmm
17:39:41 <Riastradh> Pseudonym, now, suppose you have an assq in Haskell; write a monadic version of this in Haskell.
17:39:48 <Igloo> It has () or '() or something doesn't it?
17:39:49 <Pseudonym> OK, hang on.
17:39:52 <mattam> Scheme is dinamicaly typed ?
17:39:55 <Riastradh> It should not rely on Maybe in specific.
17:39:57 <mattam> dynam..
17:39:58 <Pseudonym> type Assoc k v = [(k,v)]
17:40:26 <Riastradh> Igloo, I meant that there's no constant referenced with NIL or anything.
17:40:30 <Riastradh> There is of course the empty list.
17:40:34 <Pseudonym> lookup :: (Monad m, Eq k) => Assoc k v -> k -> m v
17:40:48 <mattam> Riastradh: what's the scheme type of assq ?
17:40:49 <Riastradh> Pseudonym, and remember that the alternative branch may contain any arbitrary expression; it shouldn't just return Nothing.
17:41:05 <Pseudonym> lookup ((k',v'):kvs) k = if k' == k then return v else lookup kvs k
17:41:11 <Pseudonym> lookup [] k = fail "Can't find"
17:41:27 <Pseudonym> OK.
17:41:28 <Riastradh> mattam, it might be casually notated as 'Value (list-of (pair-of Value Value)) -> #f | Pair'
17:41:32 <Pseudonym> Now here's the tricky part.
17:41:45 <Pseudonym> You need to embed this in a monad which allows failure to be captured.
17:41:55 <mattam> #f | Pair, so there is an either here
17:41:58 <Pseudonym> Maybe is a monad, and it is available.
17:42:42 <Riastradh> mattam, yes, but you don't need to deal with a specific Either type or anything.
17:43:32 <mattam> it is done for you if i understand correctly
17:43:42 <Pseudonym> Hang on, I hve a solution.
17:44:49 <Pseudonym> http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/hfl/hfl/mtl/
17:44:52 <Pseudonym> Have a look at Negate.hs
17:45:14 <mattam> if fails only on #f Riastradh ?
17:45:30 <Pseudonym> Basically, your problem here is that there aren't any "standard" monad interface thingies to catch a fail, assuming the monad supports it.
17:45:36 <Pseudonym> That's why I wrote my own. :-)
17:45:44 <Riastradh> Schlrmbleglrmblarghlflurblenargloxflork!
17:45:53 * Riastradh hurls curses at SF.
17:46:15 <Riastradh> Can you put it up on the web somewhere else?
17:47:09 <Pseudonym> http://andrew.bromage.org/Negate.hs
17:48:11 <Pseudonym> Using this, you can say:
17:48:34 <Pseudonym> mifPred (lookup foo bar) (\x -> doStuffWith x) doSomethingElse
17:48:38 <Riastradh> Ah, I just remembered what I was planning to say at some point: monads only let you pass one solitary continuation.
17:48:40 <Pseudonym> Which is pretty close to the Scheme version.
17:48:49 <Pseudonym> Hmm?
17:48:50 <Riastradh> Yeah, now what happens if you want three continuations?
17:49:07 <Pseudonym> They do not.  You can pass as many continuations as you want.
17:49:42 * Pseudonym grabs an example
17:49:50 <Pseudonym> Actually, Negate _is_ an example.
17:49:58 <Riastradh> ARGH!
17:50:03 <Pseudonym> If you look at the type, say, of NegateT, you will see two continuations.
17:50:06 * Riastradh flings curses at his AirPort.
17:50:12 <Pseudonym> The "Just" continuation and the "Nothing" continuation.
17:50:52 <Riastradh> But you have to create a new class for every number of continuations.
17:51:07 <Pseudonym> I'm not convinced about that.
17:51:17 <Riastradh> Give me a better suggestion.
17:51:20 <Pseudonym> If you need 'em, monad transformers should do what you want.
17:51:29 <Riastradh> How?
17:51:30 <Pseudonym> Can you give me an example where you need three continuations?
17:51:42 <Riastradh> When there are three possible result types.
17:51:47 <mattam> http://www.bbspot.com/News/2003/08/open_source_virus.html <- funny
17:52:08 <Pseudonym> Ah, OK.  Then an Either-like monad transformer stacked on top of another Either-like monad will do.
17:52:29 <Riastradh> But then you're going to do a whole bunch of stacking, which isn't very elegant.
17:53:12 <Pseudonym> Yes and no.
17:53:22 <Pseudonym> If you really want CPS, it's always there for you to use.
17:53:37 <Riastradh> 'Yes and no' respectively, or both to the whole sentence?
17:53:42 <mattam> in any case you'll use pattern matching if you've got more than 2 distinct paths possible
17:53:51 <Pseudonym> Both to the whole sentence.
17:54:26 <Riastradh> mattam, but, um, the point of having monads at all is to abstract over that sort of thing.
17:54:37 <Pseudonym> To respond to the last point first: The mechanism may be inelegant, but of course that's not what you write.
17:54:57 <Pseudonym> It makes more sense to write an abstraction layer on top of it.
17:55:06 <Pseudonym> Separate mechanism from policy. :-)
17:55:20 <Pseudonym> And that, I think, is what monads really buy you.  Separation of mechanism from policy.
17:55:26 <Pseudonym> It might really be continuation IO underneath.
17:55:35 <mattam> well, I know Riastradh 
17:56:17 <Pseudonym> I should also point out that I _think_ that arrows gives you more flexibility here.  If you have more thant two paths, you can represent them explicitly.
17:56:28 <mattam> it's just that I'm not used to that much abstraction usage :)
17:56:36 <Riastradh> The problem with arrows is they're so damn confusing.
17:56:42 <Pseudonym> True enough.
17:56:48 <Pseudonym> And I couldn't tell you how to do it.
17:56:56 <Riastradh> I think I have understood arrows for about two minutes total.
17:56:57 <mattam> Monads are too, at first
17:57:20 <Pseudonym> See, I like that much abstraction.
17:57:35 <Pseudonym> I don't want to have to worry about the detail of how I'm passing around my three distinct paths.
17:57:37 <Riastradh> mattam, not nearly as much as arrows.
17:57:43 <Pseudonym> I may want to change it later, after all.
17:57:43 <mattam> exercices, exercices... 
17:57:58 <Pseudonym> Incidentally, has anyone else read the new Ralf Hinze paper on binary search trees?
17:58:10 <Pseudonym> Excellent argument for too much abstraction in that paper.
17:58:12 <mattam> Arrows are just a step higher, but it's not so giant IIRC
17:58:22 <Riastradh> mattam, do you understand arrows?
17:58:51 <mattam> i did, when I read the paper and write some Arrow code
17:58:58 <Pseudonym> mattam: The problem with arrows is that they're not (yet) as well motivated as monads.
17:59:09 <mattam> but it would take exercices to get it right on my mind
18:00:32 <Riastradh> And only about four people understand arrows at any given time.
18:00:45 <Pseudonym> See, we can do most things with monads.  So we don't actually need to understand arrows yet,
18:00:54 <Pseudonym> :-)
18:01:03 <mattam> That'll be my next sig Riastradh 
18:01:06 <Pseudonym> I do understand the Fudgets stream processor arrows.
18:01:24 <Pseudonym> But that's like only understanding state monads.
18:02:33 <mattam> What is the thing arrows have not that monads have ? plus ? I can't recall
18:02:56 <Riastradh> Pseudonym, er, wait, did you say a few minutes ago that monads are more abstract than CPS?
18:02:56 <Pseudonym> They have arbitrary topology.,
18:03:10 <Pseudonym> Uhm...
18:03:19 <Pseudonym> I can't remember what I said.
18:03:28 <Pseudonym> I will claim that monadic IO is more abstract than continuation IO.
18:03:51 <Pseudonym> I also claim that monads used on top of continuations is more abstract than continuations alone in general.
18:04:19 <Pseudonym> But monads are not more abstract than CPS in general.  It depends on how they're used.
18:04:44 <Pseudonym> Using monads properly is a great way to abstract away from a CPS-based implementation.
18:05:09 <Riastradh> CPS is _already_ abstract!
18:05:19 <Pseudonym> I disagree.
18:05:30 <Pseudonym> It _can_ be abstract.
18:05:46 <Pseudonym> Just like monads _can_ be abstract.
18:05:49 <Riastradh> In what case is a CPS computation not abstract while a monad is?
18:06:17 <Pseudonym> OK, let me rephrase.
18:06:33 <Pseudonym> In my example above, using MonadNegate, the monad version is _more_ abstract than the CPS version.
18:06:59 <Pseudonym> Another example: http://haskell.org/hawiki/DataStructureFreeTransformation
18:07:19 <Pseudonym> Actually, not a good example.
18:07:22 <Pseudonym> Hmmm.
18:07:41 <Riastradh> How is MonadNegate more abstract than CPS?
18:07:56 <Pseudonym> Because the CPS is just an implementation detail there.
18:08:00 <Pseudonym> It could be implemented with Maybe.
18:08:09 <Pseudonym> The MonadNegate class abstracts away that detail.
18:08:31 <Pseudonym> See, this is why I think "abstraction" is highly contextual.
18:08:40 <Pseudonym> If it's important, then it's not an irrelevant detail.
18:08:43 <Riastradh> I don't get how CPS is an implementation detail there.
18:09:03 <Pseudonym> Well, what those monads are implementing is negation-as-failure.
18:09:14 <Pseudonym> Which is what you wanted in the association list example.
18:09:24 <Pseudonym> Abstractly, you want negation-as-failure.
18:09:37 <Pseudonym> You can implement that using CPS, or you can implement that using, say, Maybe.
18:09:59 <Pseudonym> MonadNegate abstracts away the implementation.
18:10:09 <Riastradh> Oh, I sort of see what you're saying now...
18:10:27 <Pseudonym> OK, here's a good example:
18:10:28 <Pseudonym> http://users.aber.ac.uk/afc/stricthaskell.html#cps
18:10:36 <Riastradh> OK, maybe I'm just ranting against the Haskell type system and the inelegance it will cause (stacked Eithers, for example).
18:10:38 <Pseudonym> CPS as a technique for enforcing evaluation order.
18:10:56 <Pseudonym> Well, of course, you don't really need stacked Eithers.
18:11:01 <Pseudonym> You can implement your own monad.
18:11:20 <Pseudonym> Or you can use stacked Eithers internally but abstract that detail away.
18:11:40 <Riastradh> Yeah, but I think heterogenous lists would be better.
18:11:52 <Pseudonym> There's certainly an argument there.
18:11:58 <Riastradh> Maybe I should just use Scheme.
18:12:05 <Pseudonym> Maybe you should. :-)
18:12:09 <Riastradh> ...which is what I was doing in the first place when I thought this whole argument up!
18:12:33 <Pseudonym> I'll stick with Haskell, you stick with Scheme, and together, we declarative programmers will take over the world.
18:12:57 <Riastradh> But...but...what if I want to use Erlang?
18:13:41 <Pseudonym> Then do that!
18:13:44 <Pseudonym> The more the merrier!
18:14:05 <Pseudonym> Clean, O'Caml, Common Lisp... together we shall rule!
18:14:15 <Riastradh> No, leave Common Lisp out of that.
18:14:22 <Pseudonym> OK, fair enough.
18:14:43 <Pseudonym> The only language with a bigger standard than C++.  (With the possible exception of PL/I.)
18:15:42 <Binkley> PL/I had a standard?
18:16:27 <mgoetze> i know someone who knows PL/I and thinks COBOL is a good language because "anyone can understand it"
18:16:55 <mgoetze> needless to say, i prefer to stick to other topics when talking with that person :)
18:17:01 <Binkley> I remember reading a description of Cobol somewhere saying that it included lots of English words which made programs "easier to understand... for managers"
18:17:32 <Pseudonym> A friend of mine did a degree which he referred to as "Bachelor of Pretending Cobol is Structured".
18:18:38 <mgoetze> well, today, i won 3 ebay auctions and deleted 5mb of spam, so let's not spoil my good mood by talking about COBOL all too much ;)
18:18:58 <Binkley> oh, but I bet that spam would have been easier to delete if you'd written a Cobol program to do it
18:19:31 <mgoetze> i think the combination of perl and c is working just fine, thank you :)
18:19:45 * Riastradh coughs and hacks and wheezes.
18:19:56 <Pseudonym> @karma- mgoetze
18:19:56 <lambdabot> mgoetze's karma has been decremented.
18:20:26 <Pseudonym> How DARE you use C when C++ is available!
18:20:27 <mgoetze> hey, if one of you wants to rewrite spamassassin in haskell or scheme, go ahead :)
18:20:36 <Binkley> that sounds like a challenge
18:20:44 <Pseudonym> It does indeed.
18:21:24 <Riastradh> But...but...what if I want to use Erlang?
18:22:51 <mgoetze> hm, well as long as i can install everything i need nicely via apt-get it's fine :)
18:25:15 * Riastradh grumbles.
18:25:45 * Riastradh wants Orbit to run on his computer!
18:32:05 <Riastradh> Anyone want to port a compiler that compiled to machines from the '80s?
18:32:25 <Pseudonym> Which compiler would that be?
18:33:34 <Riastradh> Orbit.
18:36:37 * mgoetze wonders where the heck his "water music" score got off to
18:37:15 <Pseudonym> It's busy putting out the "fireworks" score.
18:38:30 <mgoetze> Pseudonym: actually, i don't have one of those...
18:39:11 <Riastradh> Yes, mine accidentally went off and started falling towards your 'water music' score.
18:40:49 * Riastradh wants to play with T, damnit!
18:41:30 * mgoetze also wonders whether it's better to pan the horns both to the same side or to opposite sides
18:41:55 <Xcalibor> what's Orbit?
18:42:01 <Riastradh> The T compiler.
18:42:09 <Vincenz> and what's T?
18:42:15 <Riastradh> A Scheme dialect.
18:42:29 <Vincenz> ah
18:42:38 <Pseudonym> Generally, the horns are behind the violas.
18:42:46 <Pseudonym> That's how the layout would have been.
18:43:03 <Pseudonym> http://www3.sympatico.ca/emhall/images/18century_orchestra.jpg
18:43:19 <Pseudonym> The louder instruments are further back from the audience for obvious reasons.
18:43:28 <Xcalibor> ah, yeah... read about it somewhere, pretty interesting...
18:43:58 <Riastradh> It was abandoned in favour of Scheme48, which is also cool, but T had some really cool stuff, too, that I want to play with!
18:44:32 <Xcalibor> Riastradh: why not porting them to r5rs? via srfi maybe?
18:45:02 <Pseudonym> Good orchestration is very hard, though, partly because of the way the orchestra is laid out.
18:45:33 <Riastradh> Xcalibor, it can't be done with R5RS and all the SRFIs.
18:45:39 <Riastradh> s/all/any of/1
18:45:53 <Pseudonym> If you have access to a decent library, try to find a copy of Walter Piston's "Orchestration".
18:46:39 <mgoetze> Pseudonym: well, that's rather too generic for the water music... for instance, there was no harpsichord used originally, since they it would have been rather too much bother to get it on a river barge, and the sound would have gotten lost anyway...
18:47:00 <Pseudonym> Really?  No harpsichord originally?  I did not know that.
18:47:09 <Pseudonym> Now that you mention it, yes, that makes sense.
18:48:10 <mgoetze> Pseudonym: most of the criticisms in schoenberg's harmonielehre apply even more to orchestration books... i think studying masterworks is better...
18:49:09 <Pseudonym> While I agree studying masterworks is the best way, I still think you need some theory first.
18:49:30 <Pseudonym> For example, Piston makes the point that the harmonics of one instrument can interact badly with the harmonics of another.
18:49:51 <mgoetze> don't worry, i'm not a beginner at composition ;)
18:50:23 <Pseudonym> I think you need to study both good and bad.
18:50:26 <Xcalibor> Riastradh: i don't remember the specifics of T, I recall it was done in a summer, sent to the world and left as the author started to work on Lisp compilers, right?
18:50:28 <Pseudonym> And you need to understand why the bad is bad.
18:50:42 <mgoetze> do you compose?
18:50:43 <Riastradh> Xcalibor, no, it wasn't done in a single summer.
18:50:46 <Pseudonym> No, I don't.
18:50:53 <mgoetze> ah, too bad :)
18:50:55 <Riastradh> There were about four authors.
18:51:08 <Pseudonym> I used to do arranging, though.
18:51:13 <Xcalibor> Pseudonym: unless you use just intonation, then all harmonics should match harmonically
18:51:26 <Pseudonym> Xcalibor: Nope.
18:51:29 <Xcalibor> Riastradh: well, read about it on a lisp history somewhere
18:52:00 <Riastradh> One of the authors went with Richard Kelsey to write Scheme48.
18:52:07 <Xcalibor> Pseudonym: nope? i thouht it was the whole point of just intonation, so that harmonics weren't cacophonic with each other
18:52:10 <Pseudonym> For example, if you're trying to score a minor chord, then you don't want the (major third) harmonic of one instrument to be at the same octave level at the minor third fundamental of another.
18:52:10 <Riastradh> It generated a lot of PhD theses.
18:52:40 <Xcalibor> Riastradh: i think i recall reading that, yeah... where did I read about T? can't remember...
18:53:03 <Riastradh> http://www.paulgraham.com/thist.html  <- not sure if that's the right URI...
18:53:18 <Pseudonym> I don't really have the right kind of creativity for composing.
18:53:38 <Pseudonym> I've been told I write fairly good verse, though.
18:53:57 <Xcalibor> Pseudonym: mmm... but if justly intonated, all majors should go along together, they shouldn't overlap with minors (in the same base tone)
18:54:22 <Xcalibor> Pseudonym: same here, I just so clay ocarinas from time to time... :-)
18:54:28 * Pseudonym laughs
18:54:33 * Pseudonym is a cellist
18:54:48 <Xcalibor> Riastradh: graham's web site was probably where I read about T, you are probably right
18:56:43 <Xcalibor> Pseudonym: while I can play the guitar a bit, I'm a wind player, definitely: ocarina, flute, quena, whistle, a bit of bagpipe... etc... if it can be blow, I can make music out of it :-P
18:56:46 <mgoetze> Pseudonym: do you happen to have a decent midi setup?
18:57:06 <Pseudonym> mgoetze: Does one PC and one keyboard count as "decent"?
18:57:15 * Xcalibor admittedly not a great ability, but useful for long, lonely walks :)
18:57:25 <Pseudonym> Probably not, but then I don't really use it much.
18:57:25 <mgoetze> Pseudonym: it depends on the keyboard
18:57:32 <Pseudonym> Oh, it's not a great keyboard.
18:57:44 <mgoetze> what brand?
18:58:07 <Pseudonym> I's a Casio CTK... 671, I think.
18:58:26 <Pseudonym> The action is nice, but the sound isn't great.
18:58:52 <mgoetze> hm, and what kind of sound card?
18:59:00 <Pseudonym> Oh, something cheap.
18:59:24 <Pseudonym> So no, "decent" doesn't apply.
18:59:34 <mgoetze> hm, right, so if i sent you some of my compositions in midi format they would sound really crap... which is too bad, i can always use more input :)
18:59:50 <mgoetze> once i have enough equipment i hope i'll be able to make decent mp3s/oggs
19:00:03 <Pseudonym> What's your setup?
19:01:07 <mgoetze> well, i just recently restarted composing again, and win2k doesn't have decent drivers for my awe 64 gold, so basically at the moment i've just got my roland xv-2020
19:01:26 <mgoetze> however, i've just bought an sb live, an audiotrix pro and a proteus 2xr on ebay
19:01:50 <Pseudonym> Hey, you might know the answer to something.
19:02:01 <Pseudonym> Is there any decent music notation software out there AT ALL?
19:02:19 <Pseudonym> Finale is quite nice, but I was shocked to find that it can't handle a piece with, say, multiple movements.
19:02:33 <Pseudonym> Which is just stupid.
19:02:46 <mgoetze> yes, but if you don't want to pay a lot of money for it we had better leave this public channel now ;)
19:02:53 * Pseudonym laughs
19:03:00 <Pseudonym> Well, depends what you mean by "a lot".
19:03:43 <mgoetze> around $800
19:03:45 <Pseudonym> I didn't like Sibelius either.
19:03:59 <Pseudonym> (Yes, I had a legit copy, sort of.)
19:04:15 <Pseudonym> (My mother, a music teacher, had a site licence so I got to play with it a bit.)
19:04:17 <mgoetze> version 1 or version 2?
19:04:22 <Pseudonym> Probably version 1.
19:05:27 <mgoetze> well, sibelius totally beats the crap out of any other notation software at least
19:05:42 <Pseudonym> I like the Finale quick entry.
19:05:59 <Pseudonym> Personally, I think the world needs something better, and cross-platform, and open source.
19:06:16 <mgoetze> i agree, but it's way too much work :)
19:06:24 <Pseudonym> Maybe, maybe not.
19:06:34 <Pseudonym> I have some thoughts.
19:06:50 <Pseudonym> The trouble is the data model.
19:06:51 <mgoetze> well, i have a lot of thoughts on the matter :)
19:07:04 <Pseudonym> I suspect if you based it on NIFF, that would be a good start.
19:07:11 <mgoetze> NIFF?
19:07:18 <Pseudonym> Notation Interchange File Format
19:07:30 <Pseudonym> It's supposed to be a vendor-neutral music notation format.
19:08:17 <mgoetze> i wouldn't worry about that at first... if you can write a good notation program then the little extra energy to share with other programs will feel like nothing
19:08:35 <Pseudonym> The thing is that NIFF effectively gives you a data model.
19:08:53 <Pseudonym> You could make your internal representation basically an in-memory version of NIFF and then tweak from there.
19:09:04 <mgoetze> well, i haven't looked into it, so i can't tell whether it's any good
19:09:08 * Pseudonym nods
19:09:50 <mgoetze> one reason i was totally turned off by finale is that i'd have to spend hours in a sequencer on every page
19:10:17 <mgoetze> sibelius is pretty good at playback, but i'd like the abillity to change some details
19:10:40 <mgoetze> so i would like a program with two layers, a notation layer and a midi data layer
19:11:43 <Pseudonym> Yeah, but Finale isn't really a midi sequencing program.
19:11:57 <Pseudonym> I suspect that's just for completeness.
19:12:28 <mgoetze> well, i really use sibelius to compose, and i do not need a sequencer program like cakewalk - that's something i really appreciate
19:12:44 * Pseudonym nods
19:12:47 <Cale> Sibelius is nice
19:14:16 <mgoetze> i have a score for sibelius 1 with a movement of the water music, with hundreds of hidden text objects changing note durations
19:14:37 <mgoetze> i just converted it to sibelius 2, and i was able to delete all those text objects and replace them with slurs...
19:16:42 <Pseudonym> Cool.
19:16:52 <Pseudonym> I really should get the sibelius 2 demo, then, and check it out.
19:17:14 <mgoetze> yeah, and let me know about all the things you don't like about it :)
19:17:24 <Pseudonym> :-)
19:17:45 <Pseudonym> Well I didn't like Sibelius 1 that much.  I thought it was clunky.
19:18:02 <mgoetze> "clunky"?
19:18:04 <Pseudonym> It's very possible that Sibelius 2 has fixed all my issues.
19:18:26 <Pseudonym> Yeah.  For example, I didn't like the way that slurs looked on screen.
19:18:52 <mgoetze> oh, yeah, in sib1 you had to position slurs, triplets etc. manually... sib2 does it quite well automatically
19:19:00 <Pseudonym> Oh, good.
19:19:26 <mgoetze> though you still have to move the dynamics and such around, but that's not so difficult
19:20:16 <mgoetze> they also changed the input ui from sib1 to sib2... took me some getting used to but i think the new method is better
19:20:36 * Pseudonym nods
19:20:44 <Pseudonym> Good, I will check it out then.
19:21:19 <mgoetze> and once you get around to writing your new notation software, i have a suggestion for a name :)
19:21:46 <Pseudonym> Oh?
19:22:02 <mgoetze> "rautavaara" (most prominent finnish composer after sibelius) ;)
19:22:09 * Pseudonym laughs
19:22:13 <mgoetze> ok, most people won't get it, but still...
19:22:21 <Pseudonym> I thought that if it was for KDE, it should be called kodaly.
19:22:46 <mgoetze> hm
19:23:52 <mgoetze> think i'd prefer kabalevsky or khachaturian
19:24:05 <Pseudonym> Yeah, you would.
19:24:50 <mgoetze> anyway, if you write it for gnome, do me a favor and don't call it grieg - i hate grieg ;)
19:25:13 * Pseudonym laughs
19:25:17 <mgoetze> geminiani, gershwin or glazunov would be good, though
19:25:24 * Pseudonym almost certainly won't write it
19:25:34 <Pseudonym> What if you wrote it in Haskell, though.
19:25:45 <mgoetze> haydn, obviously
19:26:19 <mgoetze> i mean, i love hummel but ha is better than hu...
19:26:33 <Pseudonym> I'd prefer Holst.
19:26:45 <mgoetze> handel would also be a competitor, of course...
19:26:49 <Pseudonym> Oh, there's Handel, yes.
19:27:38 <mgoetze> HAskell Ynspired Ditty Notation - HaYDN
19:27:46 <mgoetze> yeah, i know, i cheated...
19:28:00 * Pseudonym laughs
19:28:21 <Xcalibor> okay, really late in here, going to bed
19:28:23 <Xcalibor> laters!
19:28:27 <mgoetze> bye Xcalibor 
19:28:28 <Pseudonym> Night.
19:28:39 <Xcalibor> :)
19:29:33 <mgoetze> anyway, the problem is, sibelius' quirks are too minor and my hatred of windows not motivating enough for me to undertake such a huge task
19:29:47 * Pseudonym nods
19:29:58 <Pseudonym> I'm not going to attempt it either.
19:30:04 <Pseudonym> But the point remains: The world needs this.
19:30:44 <mgoetze> a somewhat less gargantuan programming task would be a music wiki
19:31:29 <mgoetze> maybe you could even use lilypond as a text-to-notation engine
19:31:39 <mgoetze> that would be most of the work done already
19:31:59 <mgoetze> because i do think the world needs a music wiki :)
19:32:04 * Pseudonym laughs
19:32:07 <Pseudonym> Gotta go.  BBIAB
19:32:27 <mgoetze> cya
23:13:27 <shapr> goood morning #haskell!
23:16:33 <Pseudonym> G'day!
23:16:45 <Pseudonym> I have to ask.  Did you have anything to do with the Anna Lindh thing?
23:17:02 <Pseudonym> Just checking.
23:18:24 <shapr> no, I've just talked about it a bit in Swedish class.
23:18:30 * Pseudonym nods
23:19:28 <Pseudonym> Some countries don't have a culture of political assassination, so I can imagine it's a pretty big deal.
23:19:45 <shapr> yah, it's a big deal here.
23:22:43 * shapr reads the #haskell logs
23:22:53 <Pseudonym> shapr needs a life
23:26:16 <shapr> hey, my knee is healed enough now for me to ride my unicycle again!
23:26:17 <shapr> yay!
23:26:22 <shapr> it's been FOREVER.
23:26:28 <Pseudonym> Woohoo
23:27:56 <shapr> oh, heffalump found the @more bug yeterday
23:28:19 <shapr> it seems that you can't pass a Dynamic value from a dynamically loaded module to a statically loaded module
23:28:19 <Verbed> @wn necessary
23:28:21 <Pseudonym> Yes, I noticed that.
23:28:21 <lambdabot> *** "necessary" wn "WordNet (r) 1.7"
23:28:21 <lambdabot> necessary
23:28:21 <lambdabot>      adj 1: absolutely essential [ant: {unnecessary}]
23:28:21 <lambdabot>      2: unavoidably determined by prior circumstances; "the
23:28:22 <lambdabot>         necessary consequences of one's actions"
23:28:24 <lambdabot>      n : anything indispensable; "food and shelter are necessities of
23:28:26 <lambdabot>          life"; "the essentials of the good life"; "allow farmers
23:28:28 <lambdabot>          to buy their requirements under favorable conditions"; "a
23:28:30 <lambdabot> [3 @more lines]
23:28:34 <Pseudonym> There you go.
23:28:39 <Pseudonym> Not surprising, actually.
23:29:38 <shapr> I was surprised
23:29:39 <shapr> @more
23:29:39 <lambdabot> wrong type (<<[] Char>>) in ModuleState
23:29:53 <shapr> oh hey
23:30:03 <shapr> I'd like to make an on-disk database for Haskell
23:30:24 <Pseudonym> OK.  What capabilities do you want?
23:30:25 <shapr> do you think the stuff we discussed before would be the best approach for such?
23:30:44 <shapr> I'm not sure
23:31:30 <shapr> what do you suggest?
23:31:30 <Pseudonym> Uhm... what did we discuss before?
23:31:38 <shapr> we talked about inverted indices
23:31:44 <shapr> compressed inverted indices
23:31:46 <Pseudonym> Oh, you want a text database.
23:31:51 <Smerdyakov> shapr, are you assuming that you'll be trying to ape standard RDBMS techniques in an appropriately elegant Haskell way?
23:32:02 <shapr> Smerdyakov: no, no real assumptions at all
23:32:18 <shapr> I guess I'd like to have a useful on-disk backend for HaskellDB
23:32:21 <Pseudonym> Smerdyakov: If he's talking inverted indices, he's not talking relational databases at all.
23:32:58 <shapr> my two purposes would be a) something to stick into lambdabot so it won't need HSQL for @fact
23:32:59 <Pseudonym> I would think that a simple CSV-like thing, kind of like Perl's native database thing, might be the right approach.
23:33:10 <Smerdyakov> I'm ig'nant. Tried to use a saw to turn on the printer.
23:33:12 <shapr> and b) a simple Haskell database
23:33:20 <shapr> Smerdyakov: a saw?
23:33:26 <Pseudonym> To start with, anyway.
23:33:26 <Smerdyakov> shapr, I'm that ig'nant.
23:33:32 <shapr> circular saw? bandsaw?
23:33:43 <shapr> sounds interesting :-)
23:33:51 <Smerdyakov> shapr, the kind wheres you cut with it and it goes zzz-chump, zzz-chump
23:34:24 <shapr> a weighted bandsaw?
23:34:32 <Smerdyakov> A baited WANsaw.
23:34:37 <shapr> heh
23:34:50 <shapr> crap, I'm nearly out of ritalin...
23:35:01 <Smerdyakov> I guess you'll just have to take a deep breath.
23:35:14 <shapr> and hold it till I turn blue.
23:37:09 <shapr> Pseudonym: yes, I agree
23:39:13 <shapr> the Haskell refactoring program hasn't been uploaded yet
23:39:15 * shapr emails Claus
23:39:47 <shapr> oh, I can send him an entry for #haskell as well
23:39:54 <shapr> any suggestions what should be in it?
23:40:09 <Smerdyakov> What kind of entry?
23:41:17 <shapr> I would guess something short that summarizes the #haskell irc channel.
23:43:05 <Smerdyakov> But... why would you sendan entry to this guy in particular?
23:43:25 <shapr> because he's the guy who is(was) writing the Haskell Communities and Activities Report.
23:43:31 <shapr> biannually
23:43:35 <shapr> but this is his last time
23:43:58 <shapr> and I think I'll pick it up if no one more experienced with Haskell wants it...
23:44:31 <Smerdyakov> "Hello. We are here chatting on IRC. Come to chat with us, on Subjects."
23:44:33 <Smerdyakov> There.
23:44:58 <shapr> well, that is succint.
23:45:22 <shapr> I wonder where tmoertel is these days.
23:45:59 <Smerdyakov> It's time for another episode of.... WHERE ARE THEY NOW?
23:46:51 <Smerdyakov> He edited http://community.moertel.com/ss/space/tmoertel 5 days ago, apparently.
23:47:02 <shapr> aha, good point
