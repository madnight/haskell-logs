00:00:08 <shapr> a function is like a machine with some places where you put stuff in
00:00:23 <shapr> add1 is a machine that has only one input space
00:00:30 <shapr> that input spot is named x
00:00:42 <shapr> the name is only important in the rest of the function
00:00:42 <Pseudonym> And we call this "input spot" an "argument".
00:00:46 <shapr> right on
00:00:48 <shapr> groovy
00:00:57 <RibRib> groupfirst :: ([Integer],[Integer])->([Integer],[Integer])
00:00:58 <RibRib> groupfirst ([x],[y])=([x],[y])
00:00:58 <RibRib> groupfirst (x:w:xs) y	| x >= 20   =groupfirst ((x + w) : xs)y
00:00:58 <RibRib>                 	        | otherwise = x : groupfirst (w:xs)y 
00:01:00 <Pseudonym> You get the idea?
00:01:08 <RibRib> so i hav too much arguments for this?
00:01:15 <Pseudonym> No, read the message again.
00:01:24 <Pseudonym> What does it say?
00:01:34 <shapr> gutentag noshadow 
00:01:52 <RibRib> varying number of arguments
00:02:01 <Pseudonym> OK.  So count the arguments.
00:02:07 <shapr> Pseudonym: so, how do I use forall and exists in GHC?
00:02:16 <Pseudonym> shapr: You mean in types?
00:02:18 <shapr> yah
00:02:20 <RibRib> but i need it to perform my function
00:02:39 <Pseudonym> RibRib: How many arguments does your base case have?
00:02:46 <Pseudonym> And how many does the other case have?
00:02:55 <shapr> RibRib: the multiple lines after the type signature are called cases, they are not arguments.
00:03:03 <shapr> one case is "groupfirst ([x],[y])=([x],[y])"
00:03:14 <shapr> the next case is the rest of the function
00:03:44 <RibRib> | x >= 20   =groupfirst ((x + w) : xs)(y:ys)
00:03:44 <RibRib>                 	        | otherwise = x : groupfirst (w:xs)(y:ys) 
00:03:53 <RibRib> these are arguments
00:04:09 <Pseudonym> No, they're clauses.
00:04:13 <Pseudonym> That's something else again.
00:04:36 <RibRib> x and y
00:05:27 <Pseudonym> shapr: The general idea, I think is that you need to decide whether you intend it to be a particular concrete type or not.
00:05:31 <Pseudonym> Consider, for example:
00:05:43 <Pseudonym> data FOO = exists a. (Foo a) => FOO a
00:06:07 <Pseudonym> This means that some specific instance of Foo will be stored here.
00:06:15 <Pseudonym> Not _all_ instances.
00:06:31 <Pseudonym> Though any instance could be stored here, only one will be at a time.
00:06:50 <Pseudonym> I'm not explaining this well.
00:06:58 <shapr> well
00:07:12 <shapr> hey, I met Bernie Pope
00:07:30 <Pseudonym> Oh, cool.
00:07:40 <shapr> he's a nice guy, though very quiet.
00:07:48 <Pseudonym> Yes, he is quiet.
00:07:52 <Pseudonym> He's much louder in email.
00:08:07 <shapr> I think I'm louder in person.
00:08:15 * Pseudonym can believe that
00:08:23 <RibRib> so is the error saying my case doesnt match with my type signature?
00:08:34 <Pseudonym> No.
00:08:45 <Pseudonym> That still might be true, but the error isn't saying that.
00:08:55 <Pseudonym> How many arguments does the base case have?
00:09:03 <Pseudonym> How many arguments does the other case have?
00:09:51 <RibRib> 2 and 3?
00:10:18 * shapr waits for enlightenment
00:10:33 <Pseudonym> RibRib: How did you come up with those numbers?
00:10:43 <Pseudonym> I'm not saying you're wrong, I'm just asking what you counted.
00:11:16 <RibRib> counted x y?
00:11:17 <Pseudonym> shapr: Have you read this paper?
00:11:18 <Pseudonym> http://citeseer.nj.nec.com/laeufer95type.html
00:11:50 <shapr> no, but that's sort of why I'm asking.
00:12:08 <shapr> SPJ made a big HIM presentation about Odersky and Laufer's work.
00:12:20 * Pseudonym nods
00:12:32 <shapr> he found some way to extra-super-spiffy two way type generalizing or something 
00:12:36 <Pseudonym> RibRib: Ah, I see your misunderstanding.
00:12:49 <Pseudonym> Consider this definition:
00:12:51 <Pseudonym> null [] = True
00:12:56 <Pseudonym> null (x:xs) = False
00:13:05 <Pseudonym> How many arguments would you say each case of null has?
00:13:19 <RibRib> argument is the thing after the function name right?
00:13:23 <Pseudonym> Right.
00:13:38 <RibRib> that could be clearer
00:14:08 <RibRib> ok so its saying ([x],[y]) is different to (x:w:xs) y
00:14:23 <shapr> the more I learn about SPJ, the more I'm impressed.
00:14:30 <Pseudonym> Well it's obviously different.
00:14:43 <Pseudonym> See if you can answer my question.
00:14:43 <RibRib> add [ ] to the y
00:15:15 <shapr> able organize small type systems in a single leap (admittedly, an intuitive leap)
00:15:27 <Pseudonym> Yes, he's an impressive guy.
00:15:35 <shapr> and he's fun to hang out with
00:15:39 <RibRib> 2 arguments?
00:15:54 <Pseudonym> RibRib: The first case has one argument, and so does the second.
00:15:55 <shapr> he's been the primary organizer of the pure FP community for years
00:16:13 <shapr> when does he find time to SLEEP?
00:16:20 <Pseudonym> shapr: Yes, since about 1985 at least.
00:17:23 <RibRib> yes ok.. i get that
00:17:27 <Pseudonym> OK.
00:17:35 <Pseudonym> So null expects one argument.
00:17:39 <Pseudonym> Now look at your code.
00:17:45 <Pseudonym> How many arguments in each case?
00:18:04 <RibRib> does this count as 1? ([x],[y])
00:18:16 <Pseudonym> Yes.  It's one tuple.
00:18:34 <RibRib> ok, so i have to make the other one a tuple too
00:18:46 <Pseudonym> Well done!
00:18:54 <RibRib> ((x:w:xs) y )
00:18:57 <shapr> yay
00:19:27 <shapr> @karma+ RibRib 
00:19:27 <lambdabot> RibRib's karma has been incremented.
00:19:55 <shapr> bah, time for work
00:20:49 <Pseudonym> Happy w*rking.
00:20:58 <shapr> I wonder if Haystack might be a really good idea, I'd like to find some way to integrate research papers into my standard info gathering.
00:21:08 <Pseudonym> Haystack?
00:21:29 <shapr> http://haystack.lcs.mit.edu/
00:21:54 <shapr> whether haystack or not, I want some way to search, annotate, etc on text in various formats
00:21:54 <Pseudonym> Oh, interesting.
00:21:57 <RibRib> parse error for groupfirst ((x:w:xs) y)	| x >= 20   =groupfirst (((x + w) : xs)y)
00:21:57 <RibRib>                 	        | otherwise = x : groupfirst ((w:xs)y) 
00:22:34 <shapr> even better, I'd like to be able to add new formats to info collector
00:23:10 <Pseudonym> Interesting.  Must tkae a closer look at this.
00:23:32 <shapr> oh hey
00:23:40 <shapr> did I talk to you about a research paper wiki already?
00:23:46 <Pseudonym> Uhm, no.
00:24:08 <shapr> I realized I know several people who have very interesting thoughts on papers they read that I would like to know
00:24:26 <shapr> afaiu, I can't actually upload papers to a wiki for (c) reasons
00:24:32 <Pseudonym> Oh, interesting.  Some kind of collaborative annotation thing.
00:24:36 <shapr> right
00:24:59 <shapr> but I thought I might be able to let them click a link to download the paper, and their browser could load it from their local drive
00:25:01 <shapr> then it all works
00:25:29 <shapr> for example, I see lots of interesting connections between papers, but I can't always describe them
00:25:45 <shapr> clockless logic and quantum computing is a recent connection
00:25:56 <Pseudonym> I wonder how citeseer gets away with holding copies of papers.
00:26:02 <shapr> good question
00:26:30 <shapr> one important point would be the ability to anchor notes to specific places in a paper
00:26:57 <shapr> is that possible for PS/PDF/Word?
00:27:08 <Pseudonym> In PDF, certainly.
00:28:15 <shapr> I wonder how you can put a note in a wiki and have it interact with the document
00:34:17 <shapr> I should point Konrad Hinsen to the nifty numerical code in hlibs
00:34:24 <shapr> hey Pseudonym, have you tried the darcs repo for hlibs?
00:34:47 <shapr> hm, have I given you write access?
00:35:27 <shapr> oh, I have.
00:35:48 <Pseudonym> Not yet, no.  Been busy.
00:35:53 <shapr> Darius: do you have a public GPG key?
00:36:09 <Pseudonym> Gotta go home.  Night all.
00:36:10 <shapr> Igloo: should I add you also?
00:36:12 <shapr> g'night Pseudonym 
00:36:25 * shapr sproings
00:40:48 <pesco> Good morning shapr!
00:40:52 * pesco stretches
00:40:59 <shapr> good morning pesco!
00:41:10 <shapr> I'm just about to go off to do work
00:41:10 <pesco> How is life?
00:41:18 <pesco> Oh, I'm teleworking today :)
00:41:23 <shapr> sadly, #haskell and work are not compatible, since work is not very interesting.
00:41:30 <pesco> bah :(
00:41:37 <shapr> maybe tomorrow I'll have the necessary focus to do both at the same time
00:41:39 <shapr> bbl
00:59:37 <adept> good time of the day, all
01:41:38 <earthy> and a second try to go to work...
01:50:05 <ski> huh ?
01:58:34 <Lunar^> Is there someone who read glasgow-haskell-users ?
01:59:02 <Marvin--> yeah
01:59:38 <Heffalump> Marvin--: you should have got signed copies of your key by email, btw
02:00:10 <Marvin--> Heffalump: yeah I did, I signed your key and sent it to some key servers
02:00:19 <Heffalump> cool, thanks
02:00:37 <Heffalump> you need to upload your ones yourself, because the emails doubled as address verification
02:00:44 <Marvin--> okay
02:01:08 <semaj> hi to you all :)
02:01:11 <Marvin--> you're still not as paranoid as others who send encrypted mails to each sub and expect replies before signing
02:01:24 <Heffalump> that's what I would have done if I hadn't found a script that did that
02:02:01 <Heffalump> I only started doing anything like it at all when they changed the GPG setup to distinguish between casual and careful checking and said in the manpage that you should verify that the email address belongs to the person
02:02:21 <Heffalump> before that I'd have said it was pointless to do so, but since the documentation now says you should people will assume I have if I say '3', so I do
02:02:30 <ibid> it does?
02:02:42 * Marvin-- admits that he is a bit relaxed about that
02:02:43 <ibid> i didn't see any recommendation on what they mean in the docs
02:02:46 <Heffalump> well, it mentions checking the email address as an example of what careful checking might entail
02:02:54 <ibid> heh
02:03:06 <Heffalump> >> 3 means you did extensive verification of the key. 
02:03:06 <Heffalump> >> For exam-  ple, this could mean that you verified 
02:03:06 <Heffalump> >> the  key  fingerprint  with the owner of the key in
02:03:06 <Heffalump> >> person, and that you checked, by  means of a hard to
02:03:06 <Heffalump> >> forge document with a photo ID (such as  a 
02:03:08 <Heffalump> >> passport)  that the name of the key owner matches
02:03:11 <Heffalump> >> the name in  the user ID on the key, and finally 
02:03:13 <Heffalump> >> that  you  verified  (by  exchange  of email) that
02:03:16 <Heffalump> >> the email address on the key belongs  to the key
02:03:18 <Heffalump> >> owner.
02:04:03 <Heffalump> sending encrypted copies of each signed keyid to the correct email address should be equivalent to sending encrypted mail and waiting for a response
02:12:50 * Lunar^ makes another attempt to get GHC under Debian/PowerPC
02:13:29 * Marvin-- fixes the d-i net retriever *growl*
02:59:44 <RibRib> multelem::([Integer],[Integer])->([Integer])
02:59:44 <RibRib> multelem ([],[]) =([])
02:59:44 <RibRib> multelem ((x:w:xs),(y:z:ys)) = x*y : multelem ((w:xs),(z:ys))
03:00:07 <RibRib> this function only works for 2 numbers in each list, how can i make it work for more than 2 numbers?
03:00:21 <Lunar^> urg this lacks some spaces
03:00:46 <noshadow> What do you want to do?
03:00:46 <Lunar^> Do you really need to use a couple here ?
03:00:56 <RibRib> i must
03:01:10 <RibRib> --Example: ([1,2,3],[10,100,1000]) = [(10,200,3000)]
03:01:27 <noshadow> RibRib: sounds strange
03:01:39 <Heffalump> that looks like it should work fine for more than 2 numbers.
03:01:44 <ski> do you want a funtion that can handle any number of lists, or do you just want to extend it to, say, 3 lists
03:01:47 <Heffalump> oh, no
03:01:51 <Heffalump> it won't work for single element lists.
03:01:55 <Lunar^> @type zipWith
03:01:55 <lambdabot> zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
03:02:00 <Heffalump> try to look at your pattern matching and figure out why that is
03:02:38 <RibRib> ok, so i need to add case?
03:02:47 <RibRib> so it works for single elements?
03:03:43 <RibRib> multelem ([x],[y])=([x*y])
03:04:04 <noshadow> RibRib: what about multelem (l1,l2) = zipWith (*) l1 l2 ?
03:04:43 <RibRib> ok i got it working..
03:04:44 <Lunar^> noshadow: uncurry . (zipWith (*)) ?
03:05:06 <Heffalump> Lunar^: stop giving him homework answers
03:05:06 <noshadow> RibRib: And you stiill did not told, why you have to use a tuple, instead of two arguments?
03:05:17 <Heffalump> ribrib: ok, now try to simplify your definition
03:05:22 <Heffalump> it's now a bit too complicated
03:05:38 <Lunar^> Heffalump: You're right. sorry
03:05:50 <RibRib> because its a function for another function
03:06:04 <RibRib> thats why the type must be exactly that
03:06:45 <noshadow> Lunar^: As you answer did not work anyway..
03:07:12 <RibRib> multelem ((x:w:xs),(y:z:ys)) = x*y : multelem ((w:xs),(z:ys)) Heffalump: you mean this part?
03:07:22 <ski> yes, that can be simplified
03:07:39 <RibRib> is w and z necessary?
03:07:54 <ski> for what ?
03:07:56 <Darius> Lunar^: stop adding unnecessary ()'s ;): uncurry . zipwith (*)
03:08:09 <noshadow> Darius: the . ist still too much...
03:08:18 * Darius needs to make a deparenthesizer of Haskell code
03:08:36 <Heffalump> ribrib: that part and the new line you made to deal with single elements
03:08:39 <Lunar^> Darius: thx
03:08:40 <Heffalump> they can both be handled by a single case
03:08:43 <Darius> noshadow: I wasn't aiming at semantics, just syntax
03:08:59 <Lunar^> die LISP, die ! ;))
03:09:00 <RibRib> hmm
03:10:17 * noshadow prefers to having one parenthese too much than not having one needed...
03:10:39 <RibRib> dunno how to simplify
03:11:29 <ski> your second line of multelem works for list with at least two numbers in, as it stand right now
03:11:42 <Darius> Typically, semantic changing (lack of) parentheses will cause a type error.  However, in Haskell there are plenty of cases where they are pretty superfluous.
03:13:03 <ski> and it just multiplies the first numbers in both lists and pass the rest (including the second elements) on to the recursive call of multelem, right ?
03:13:27 <RibRib> would this work?
03:13:28 <RibRib> multelem ([x],[y])=x*y: multelem ((x:xs),(y:ys))
03:13:28 <noshadow> Darius: and sometimes it will cause parse errors hard to find. When I learned haskell it once took my half a day to find missing parentheses around a -1
03:14:26 <ski> xs and ys don't get a value anywhere, yet you have used them in the body (the right-hand side of the =)
03:15:27 <RibRib> would i still need the w and the z?
03:15:34 <ski> RibRib : do you know, e.g. how to compute the length of a single list ?
03:15:55 <RibRib> length function?
03:15:58 <ski> yes ?
03:16:07 <RibRib> length [ ]
03:16:14 <ski> and ?
03:16:19 <Darius> noshadow: so it's still compile-time; what's the big deal? ;)  Most of the parse errors I get now have to do with mismatched parentheses.
03:17:04 <Darius> anyways, I'm not saying that one should -never- have technically superfluous parens
03:17:14 <ski> length has two defining lines, RibRib, yes ?
03:17:25 <RibRib> yeh...
03:17:37 <RibRib> do i need if then statements?
03:17:41 <ski> the first line begins "length [ ] = ", as you seem to know
03:17:54 <ski> not necessarily
03:18:06 <ski> and the second line begins ?
03:18:36 <RibRib> dunno 
03:18:57 <ski> a list can have two forms :  empty  and  non-empty (i.e. at least one element)
03:19:04 <ski> the empty list is []
03:19:08 <RibRib> oh ok
03:19:13 <ski> the non-empty list is x:xs
03:19:15 <RibRib> length [x]
03:19:39 <noshadow> RibRib: [x] is an other form for x:[]
03:19:49 <RibRib> length (x:xs)
03:20:21 <ski> many times, when writing functions that take a list as input, you just have to say : what will the function give for an empty list  and what will the function do for a nonempty list, right ?
03:20:27 <ski> yes, exactly !
03:21:13 <ski> i.e. the length of the empty list is (by definition/convention) 0 (i.e. zero)
03:22:19 <ski> and the length of any non-empty list can be computed by adding one to the length of that lists tail (that would be "length xs" in your example)
03:22:22 <RibRib> ahuh
03:22:55 <RibRib> yeh...
03:23:04 <ski> RibRib : anyway, what i'm trying to explain here is that many list-functions just need two cases, the empty and the nonempty-case
03:23:12 <ski> like
03:23:20 <ski>   length [] = 0
03:23:31 <ski>   length (x:xs) = 1 + length xs
03:24:17 <ski> and you want a function multelem :: ( [Integer] , [Integer] ) -> [Integer]
03:24:51 <ski> you with me ?
03:25:00 <RibRib> sort of... 
03:25:21 <ski> so your definition was something like this, right ?
03:25:31 <ski>   multelem ([],[]) = ...
03:25:47 <RibRib> multelem ([],[]) =([])
03:25:54 <ski>   multelem ((x0:x1:xs),(y0:y1:ys)) = ...
03:26:04 <ski> yes
03:26:15 <RibRib> i also hav something i want to add to the function...
03:26:35 <ski> okay ?
03:27:02 <RibRib> if first list is non-empty and 2nd list is empty
03:27:12 <RibRib> then element remain the same
03:27:21 <ski> do you want to handle those cases ?
03:27:31 <RibRib> vice versa
03:27:51 <ski> or should the function only work correctly, for sure, for lists of the same length ?
03:27:58 <ski> hmm
03:28:11 <RibRib> ([1,2,3],[10,100,1000,1]) = [(10,200,3000,1)]
03:28:34 <ski> you want  multelem ([1,2,3],[10,100])  ---->  [10,200,3]  right ?
03:28:43 <ski> yes
03:28:59 <RibRib> yes, working for both list
03:29:26 <RibRib> ill show u the mess i created
03:29:28 <Marvin--> why are you writing [(10,200,3000,1)]?  That has the type [(Integer,Integer,Integer,Integer)]  not [Integer]
03:29:34 <ski> perhaps we should first simplify the function definition, and then add the ability to also handle lists of different length
03:30:04 <RibRib> oh sorry i messed up
03:30:16 <RibRib> ([10,200,3000,1])
03:30:19 <RibRib> that is what i mean
03:30:21 <ski> no problem :)
03:30:24 <Marvin--> the parentheses are superfluous
03:30:31 <ski> yes
03:31:02 <RibRib> ive only started learning about lists last wk
03:31:19 <ski> anyway, RibRib, your first definition line handles list which are (both) empty
03:31:32 <RibRib> ahuh
03:31:57 <ski> and your second definition line, it only works for lists of at least two elements (each)
03:32:00 <RibRib> length sum ?
03:32:00 * Marvin-- goes back to cracking a substitution cipher
03:32:03 <ski> can you see that ?
03:32:33 <RibRib> yes i see that
03:33:09 <ski> can you imagine how to simplify it so it works for list of, at least, one element each ?
03:33:25 <RibRib> so i need to change the 2nd definition so any number of elements will work?
03:33:28 <ski> (hint : look at the definition lines of length)
03:34:39 <ski> yes
03:35:08 <RibRib> multelem (x:xs) (y:ys) =
03:35:16 <ski> or perhaps
03:35:30 <ski>   multelem ((x:xs),(y:ys)) =
03:35:45 <RibRib> right... a tuple
03:35:46 <ski> because you want to have right type of the function
03:36:16 <ski> (otherwise the separate arguments style is most often nicer, IMO)
03:36:37 <ski> this can be simplified to (remove paranthesis)
03:36:40 <RibRib> multelem ([],[]) =([]) this line is fine?
03:36:46 <ski>   multelem (x:xs,y:ys) =
03:36:59 <ski> that can be simplified to
03:37:05 <ski>   multelem ([],[]) = []
03:37:26 <ski> but, this was not so important
03:37:35 <RibRib> oh
03:37:50 <RibRib> an empty list doesnt require tuple brackets
03:37:53 <ski> (you dont need parantheses around list, usually)
03:37:55 <ski> yes
03:38:40 <ski> you just need parantheses when you are going to have a "x:xs" thing as argument to a function
03:38:42 <ski> like
03:38:48 <ski>   length (x:xs) =
03:39:22 <ski> so what we have now is this, right ?
03:39:29 <ski>   multelem ([],[]) = []
03:39:40 <ski>   multelem (x:xs,y:ys) = ???
03:39:45 <RibRib> yes
03:39:54 <RibRib> im trying to write that at the moment
03:40:25 <RibRib> multelem (x:xs,y:ys) = x*y : multelem (xs,ys) 
03:40:40 <ski> yes, i think that is correct :)
03:40:54 <RibRib> ahhhh
03:41:16 * Marvin-- runs around looking for his dice and character sheet
03:41:25 <RibRib> ok that worked :)
03:41:29 <ski> ok, now this still doesn't work with two lists of different length
03:41:37 <RibRib> yes i know
03:41:56 <RibRib> need to use if then?
03:41:59 <ski> this current multelem function sort of steps through both lists "side by side"
03:42:01 <RibRib> or new case?
03:42:04 <ski> no
03:42:18 <ski> (you can if you wan't though)
03:42:27 <Marvin--> witness the power of haskell's pattern matching :)
03:42:37 <ski> but in this case, ordinary patternmatching is sufficient
03:43:32 <ski> do you want to tackle the different-length lists now ?
03:43:39 <RibRib> yep :)
03:43:42 <ski> ok
03:44:18 <ski> the first definition/equation of multelem says "what to do"/"what to return" when both lists are empty
03:44:33 <RibRib>  multelem [] (y:ys) = y : ys 
03:44:34 <ski> if we have two lists of different length
03:44:34 <RibRib> ?
03:44:46 <ski> hm
03:44:53 <ski> i think that will work
03:45:07 <RibRib> no recursion needed?
03:45:09 <ski> i.e. when the first list is shorter than the second
03:45:23 <RibRib>  multelem [] (y:ys) = y : multelem ys
03:45:27 <noshadow> multelem [] a = a should also be sufficient...
03:45:54 <noshadow> RibRib: it would be multelem [] (y:ys) = y : multelem [] ys and which case this is you know...
03:45:55 <ski> noshadow : only if we put it after the recursive definition
03:46:07 <noshadow> ski: ?
03:46:32 <ski> noshadow : no sorry, i stupided up :)
03:46:48 <noshadow> ski: this way one can even get rid of the base case...
03:46:52 <RibRib> multelem [] (y:ys) = y : multelem [] ys
03:47:11 <RibRib> and multelem (x:xs) [] = x : multelem [] xs
03:47:28 <Marvin--> argh, where's my d20s?
03:47:29 <ski> yes, this is correct, but unnecessary
03:47:30 <noshadow> RibRib: but you know, what multelem [] ys is: it is just ys
03:47:44 <RibRib> ahh
03:48:22 <ski> if we have two lists and one is empty then the result should be all numbers in the other times one, but that is just the same as the other list
03:48:31 <ski> no need for recursion here
03:49:19 <RibRib> so just multelem (x:xs) [] = x : [] xs
03:49:20 <RibRib> ?
03:49:31 <ski> multelem ([1,2,3],[10,100,1000,10000]) ----> [10,200,3000,10000]
03:49:38 <ski> hm, no
03:50:15 <RibRib> multelem [] (y:ys) = y : ys 
03:50:15 <RibRib> multelem (x:xs) [] = x : xs
03:50:16 <ski>   multelem (xs,[]) = xs
03:50:24 <ski> yes
03:50:31 <RibRib> oh , thats why i got an error :)
03:50:50 <ski> so how many definition lines do you have right now ?
03:51:01 <RibRib> 4
03:51:03 <RibRib> cases
03:51:07 <ski> yes
03:51:43 <ski> the first  multelem ([],[]) can actually be handled by either of the latest two cases, right ?
03:51:55 <ski> like noshadow said above
03:52:06 <RibRib> i got a warning :(
03:52:15 <ski> ?
03:52:18 <ski> from hugs ?
03:52:22 <ski> or ghci ?
03:52:24 <RibRib> ghci
03:52:26 <ski> or teacher ?
03:52:30 <ski> ok
03:52:31 <RibRib> lol 
03:52:59 <RibRib> line : multelem ([],[]) =[]
03:53:24 <ski> the warning is ?
03:54:22 <RibRib> Warning: Patter match(es) are overlapped
03:54:22 <RibRib> In the definition of 'multelem': multelem (xs,[]) = ...
03:54:43 <ski> oh, ok
03:54:57 <RibRib> my fault
03:55:01 <RibRib> typo
03:55:25 <ski> it says that if the order of the definitions didn't matter, it wouldn't know what line to use. because both would match
03:55:57 <RibRib> woo hoo it works :)
03:56:03 <RibRib> learning is fun
03:56:11 <ski> yes :)
03:56:35 <RibRib> now i gotta put the functions ive made today to 1 big function
03:57:21 <ski> ok
03:57:55 <RibRib> thnx alot :)
03:58:04 <ski> no prob
04:02:59 <Lunar^> Urgh link problem
04:03:20 <Lunar^> /home/lunar/ghc-6.0.1/ghc/rts/libHSrts.a(GC.o)(.text+0x1aca): In function `evacuate':
04:03:24 <Lunar^> : undefined reference to `GHCziBase_Izh_con_info'
04:04:55 <Lunar^> seems to be related to gmp
04:05:37 <Lunar^> make[1]: RTS: Command not found
04:15:12 <RibRib> ski you there?
04:15:17 <ski> mm, yes
04:15:27 <RibRib> nlp :: String -> Integer
04:15:27 <RibRib> nlp "one"=1
04:15:27 <RibRib> nlp x = map nlp (words x)
04:15:32 <RibRib> whats wrong with this?
04:15:39 <RibRib> i cant see the problem... 
04:16:15 <Lunar^> urg... it's calling happy without having one
04:16:24 <ski> what kind of problem ? (type error, runtime-error, hangs ?, doesn't do what i want ?)
04:16:41 <RibRib> wait ill type the error out
04:17:25 <RibRib> couldnt match 'Integer' against [Integer]
04:17:30 <ski> ah
04:17:33 <ski> i see
04:17:51 <ski> you are mapping nlp over a string list in the second line
04:18:03 <ski> then you get an integer list, yes ?
04:18:07 <RibRib> let me show u something
04:18:09 <RibRib> nlp :: String -> Integer
04:18:09 <RibRib> nlp "one"=1
04:18:14 <RibRib> if i just hav that
04:18:17 <ski> but nlp want's to return an integer
04:18:27 <ski> then there is no type error
04:18:52 <RibRib> and i type "map nlp (words "one") in ghci, it would work
04:19:09 <ski> but you get a list of numbers, dont you ?
04:19:16 <RibRib> yes
04:19:20 <RibRib> that is wat i want
04:19:45 <ski> but the first line of nlp gives just one number (i.e 1)
04:19:50 <ski> not a list of numbers
04:20:11 <ski> each line has to return something of the same type as all other lines, right ?
04:20:20 <RibRib> okok
04:20:23 <ski> you have
04:20:29 <ski>   nlp "one" = 1
04:20:39 <RibRib> nlp :: String -> [Integer] still wouldnt work
04:21:03 <ski> no, because the number 1 isn't a list of numbers
04:21:07 <ski> perhaps you want
04:21:14 <ski>   nlp "one" = [1]
04:21:16 <ski> ??
04:21:21 <RibRib> oh 
04:21:32 <ski> then it should type-check at least
04:21:42 <RibRib> ohhh i think i get it now 
04:21:46 <RibRib> thnx again :)
04:21:48 <ski> but perhaps it still doesn't do what you want ?
04:32:56 <ski> hello RibRib2
04:33:00 <RibRib2> i got disconnected
04:33:01 <RibRib2> :(
04:33:07 <ski> 'kay
04:34:17 * Heffalump wonders what uni RibRib is at
04:34:30 <ski> some in australia ?
04:34:47 <Heffalump> well, yes, and I'm even guessing one in Sydney :-)
04:34:54 <RibRib2> unsw
04:35:01 <ski> ?
04:35:13 <RibRib2> University of New South Wales
04:35:17 <ski> ah
04:35:26 <RibRib2> this is what i wanna do ..
04:35:27 <RibRib2> words "three million one"
04:35:28 <RibRib2> ["three", "million", "one"]
04:35:28 <RibRib2> map nlp (words "three million five hundred fifty two") 
04:35:28 <RibRib2> [3,1000000,5,100,50,2]
04:36:31 <RibRib2> but the stupid error came up
04:36:58 <ski> so you want to 'translate' english number words to integers
04:37:05 <RibRib2> yes
04:37:12 <RibRib2> thats my whole assignment basically
04:37:13 <d33p> shouldnt that be  [3,1000000,5,100,10,5,1,2]
04:37:55 <ski> d33p : ?
04:38:05 <RibRib2> nlp "zero"=0
04:38:06 <RibRib2> nlp "one"=1
04:38:06 <RibRib2> nlp "two"=2
04:38:06 <RibRib2> nlp "three"=3
04:38:22 <RibRib2> this is what i did to all the single word numbers
04:38:29 <RibRib2> to million
04:38:29 <Heffalump> what stupid error?
04:38:47 <RibRib2> from what i hav, can you spot the error?
04:38:59 <Heffalump> no.
04:39:15 <ski> RibRib2 : do you want nlp "three million five hundred fifty two" to become [3,1000000,5,100,50,2] or 3000552 ?
04:39:32 <RibRib2>  3000552 
04:39:33 <RibRib2> of cos
04:39:37 <ski> ok
04:39:39 <RibRib2> but
04:39:41 <RibRib2> dont help me
04:39:45 <RibRib2> ill be in deep shit
04:39:46 <ski> ok
04:40:07 <RibRib2> im doing it step by step
04:40:16 <ski> good way
04:40:28 <RibRib2> and im already stuck at map nlp (words "three million five hundred fifty two") 
04:40:44 <RibRib2> why cant i get  [3,1000000,5,100,50,2] ??
04:40:47 <RibRib2> thats what i want 
04:40:50 <Heffalump> well, what happens when you try?
04:41:01 <d33p> ski: hm, i messed up, the last two pairs are are reversed, i meant [3,1000000,5,100,5,10,2,1]
04:41:02 <ski> Heffalump : type error
04:41:08 <RibRib2> yeh type error
04:41:17 <ski> Heffalump : he can't return both an integer and an integer list from nlp
04:41:27 <Heffalump> oh.
04:41:33 <Heffalump> well, that's the problem then :-)
04:41:35 <RibRib2> i dont see why though...
04:42:02 <ski> but, RibRib2, you really want to do something more with [3,1000000,5,100,50,2] before returning it from nlp, right ?
04:42:22 <ski> you wan't to somehow convert it to the number 3000552, yes ?
04:42:35 <Heffalump> isn't he saying that map nlp (words ...) doesn't work?
04:42:39 <RibRib2> yes im on the way to be doing that...
04:42:53 <RibRib2> the multelem function  is the last step to it
04:43:01 <ski>   nlp x = map nlp (words x)
04:43:07 <ski> don't work at the same time as
04:43:13 <ski>   nlp "one" = 1
04:43:43 <ski> aha, you are instructed to use your multelem function for this
04:44:06 <RibRib2> when i type map nlp (words "two thousand") in ghci, i get [2,1000]
04:44:51 <RibRib2> therefore i thought map nlp (words x) would give me the same thing...
04:45:03 <ski> it does
04:45:14 <Heffalump> the problem is that the result type is wrong
04:45:24 <RibRib2> ahhhhh
04:45:29 <Heffalump> so yeah, what ski has been saying
04:45:30 <ski> but nlp  is required to have type  String -> Integer , right ?
04:45:35 <RibRib2> i probably need to complete all my functions
04:45:41 <RibRib2> let me think... 
04:47:18 <Heffalump> you shouldn't really be using the same function for the constituent parts and for whole strings
04:47:22 <Heffalump> it's asking for trouble
04:57:50 <RibRib2> woot! it works!
04:58:12 <ski> mm
04:58:49 <ski> can it convert, say "two thousand" to 2000
04:59:01 <RibRib2> yeh 
04:59:04 <RibRib2> wanna see it?
04:59:10 <ski> yes
04:59:59 <RibRib2> ill paste it somewhere
05:00:21 <Darius> and "three hundred twenty two million four hundred twelve"?
05:00:30 <RibRib2> it should i think 
05:00:36 <ski> how many lines is it roughly ?
05:00:42 <RibRib2> 90 :(
05:00:48 <ski> 'kay
05:00:53 <RibRib2> including all the number conversion
05:01:13 <Heffalump> you'd better not put it online if it's homework answers
05:01:19 <Heffalump> other people from UNSW use this channel too
05:01:20 <RibRib2> yeh i better not..
05:01:22 <ski> you could put it on a web page quickly if you have some such handy
05:01:41 <ski> or you could explain how i accept dcc sends :)
05:01:54 <RibRib2> just accept?
05:02:08 <ski> it said "*** DCC SEND (NLP.hs 2762) request received from RibRib2" ..
05:02:22 <RibRib2> yes and you accept it :)
05:02:23 <ski> not sure how to get it
05:02:25 <Heffalump> try "/dcc get ribrib2"
05:02:58 <RibRib2> hmm i shouldnt post it up on the net... 
05:03:24 <ski> RibRib2 : try sending it again
05:03:49 <RibRib2> ok
05:04:18 <ski> Heffalump : will it be saved in a file, or just displayed ?
05:04:28 <RibRib2> save
05:04:40 <RibRib2> i cant believe it works :)
05:04:54 <RibRib2> let me try some huge numbers
05:05:34 <ski> it just hangs after i type /dcc get RibRib2
05:05:43 <Heffalump> might be firewall issues
05:05:45 <ski> had to do Ctrl-C
05:05:45 <Heffalump> if you have one
05:05:46 <RibRib2> do you use icq?
05:05:52 <ski> me ?
05:05:55 <RibRib2> yeh
05:05:58 * Heffalump suggests email
05:06:01 <RibRib2> :)
05:06:08 <RibRib2> ok ill email it to ya
05:06:11 <RibRib2> email address
05:06:12 <RibRib2> ?
05:06:19 <ski> i use a icq client called just icq right
05:06:30 <ski> ok : md9slj@md9slj.chalmers.se
05:06:41 <ac_school> @mdstud.chalmers.se, right? :)
05:06:41 <lambdabot> Sorry, I don't know the command "mdstud.chalmers.se,", try "lambdabot: @listcommands"
05:06:41 <RibRib2> wow
05:06:45 <ski> oh 
05:06:49 <ski> no thats wrong
05:06:52 <RibRib2> :(
05:06:56 <ski> md9slj@mdstud.chalmers.se
05:06:59 <ski> should be
05:07:09 <ski> typed too fast
05:07:29 <RibRib2> im sending from yahoo
05:07:30 <ski> ac_school : yes
05:07:37 <ac_school> :)
05:08:51 <RibRib2> you will see how messy my coding is
05:08:55 <ski> RibRib2 : sent it yet ?
05:09:08 <ski> heh :)
05:09:10 <RibRib2> no, im dial up,
05:09:29 <RibRib2> i havent even deleted functions i dont need
05:09:37 <ski> modem from home ?
05:09:48 <RibRib2> 56K
05:10:19 <ski> ok, same as my bro' has. i haven't a home connection at all right now .. :(
05:10:20 <RibRib2> ok should be sent
05:10:29 <ski> right when you said it
05:10:58 <ski> reading ...
05:11:29 <RibRib2> just test it out :)
05:11:39 <RibRib2> type nlp "any number"
05:11:57 <ski> mm, wait, have to save it first as a file ..
05:12:03 <RibRib2> k :)
05:12:46 <RibRib2> oh crap
05:13:05 <RibRib2> forgot "unknown words"
05:15:32 <ski> the email sender seems to have word wrapped some comments, fixing that now ...
05:16:00 <RibRib2> hmm soz
05:16:12 <RibRib2> thats 90 lines of fixing :(
05:16:30 <ski> fixed :)
05:16:54 <ski> nlp "any number" gives "ERROR - Control stack overflow"  ;)
05:16:57 <ac_school> Avast!
05:17:27 <RibRib2> how do i make an error statement?
05:17:38 <ski> no :)
05:17:46 <RibRib2> for "unknown words"
05:18:31 <Heffalump> error "foo"
05:19:03 <ski> nlp "twelve" don't work
05:19:15 <ski> nlp "three hundred twenty two million four hundred"  ---> 322000400
05:19:16 <RibRib2> oops
05:19:22 <RibRib2> thank you!!!
05:19:40 <ski> nlp "twelth"=12  is the def. line
05:19:48 <ski> changing to twelve
05:19:53 <RibRib2> thnx :)
05:20:11 <ski> nlp "three hundred twenty two million four hundred twelve" ---> 322000412
05:20:22 <RibRib2> :)
05:20:41 <RibRib2> lucky your lucky number is 12
05:20:59 <Darius> three hundred two million four hundred thirty thousand five
05:22:05 <RibRib2> wow
05:22:08 <RibRib2> howd u do that
05:23:24 <RibRib2> i got that wrong! :(
05:23:27 <RibRib2> hmm
05:23:47 <RibRib2> 302435000
05:25:54 <ski> back
05:26:55 <ski> nlp "three hundred two million four hundred thirty thousand five" --> 302435000
05:27:04 <RibRib2> hmm
05:27:19 <RibRib2> the joinsecond function
05:27:35 <RibRib2> make that a x<=y
05:28:42 <ski> joinsecond (x:y:xs)|x<=y = (x*y): joinsecond (y:xs)   ?
05:28:51 <RibRib2> let me think
05:29:08 <RibRib2> one million million aint working either :(
05:29:39 <ski> nlp "one million million" --> 2000000
05:29:42 <ski> yes
05:30:15 <RibRib2> not handling large numbers :(
05:30:34 <RibRib2> can you see how the program work?
05:30:38 <ski> why split in  nlp x = sum (multelem(group(split 100(map nlp(words x)))))  ?
05:30:44 <ski> not yet :/
05:31:04 <RibRib2> the split function does this
05:31:10 <ski> hmm
05:31:14 <ski> @prelude split
05:31:14 <RibRib2> split 100 (map nlp (words "two thousand two"))
05:31:14 <RibRib2> ([2,2],[1000])
05:31:16 <lambdabot> *** "split" prelude "Haskell Standard Prelude Dictionary": text follows
05:31:16 <lambdabot> split
05:31:16 <lambdabot>   class RandomGen g where
05:31:16 <lambdabot>     split ::  g -> (g, g)
05:31:16 <lambdabot>   instance RandomGen StdGen where
05:31:18 <lambdabot>     split = stdSplit
05:31:32 <ski> hmm
05:31:41 <RibRib2> split 100 (map nlp (words "two thousand two"))
05:31:41 <RibRib2> ([2,2],[1000])
05:31:57 <ski> lambdabot : wrong function  :)
05:31:58 <RibRib2> puts all numbers > 100 on the RHS
05:32:13 <ski> RibRib2 : yes
05:32:14 <RibRib2> therefore, they are units
05:32:27 <RibRib2> splits units from numbers
05:32:47 <RibRib2> then the next function
05:32:48 <RibRib2> group
05:33:22 <ski> mm
05:33:22 <RibRib2> that adds up all the numbers such as "twenty", "thirty", "forty" etc... to the next number
05:34:23 <ski> hmm
05:34:29 <RibRib2> following?
05:34:37 <ski> not yet :)
05:35:36 <RibRib2> uh oh
05:35:58 <ski> should the rec. call pass (y:ys) in
05:36:04 <ski> joinsecond (x:y:xs)|x<y = (x*y): joinsecond (y:xs)
05:36:28 <RibRib2> one hundred thousand -> 101000
05:36:53 <RibRib2> this is wats its doing 100000+1000
05:36:55 <RibRib2>  :(
05:37:57 <ski> hmm, i think i would first partition into <=999 chunks each separated with words like : thousand, million, billion, etc
05:38:30 <Cale> ski: what about things like "one million million"
05:38:35 <ski> and write a function to make each chunk into a <=999 number
05:38:49 <ski> Cale : should that be allowed ?
05:38:58 <Cale> I thought it was
05:39:05 <RibRib2> yes it is allowed
05:39:05 <ski> Cale : shouldn't you write billion
05:39:09 <ski> oh, ok
05:39:10 <Cale> can I see the assignment page again?
05:39:18 <ski> i haven't seen it
05:39:56 <ski> so i dont know exact requirements ..
05:40:04 <Cale> In some places "one billion" only means "one thousand million"
05:41:02 <RibRib2> *NLP> nlp "positive one hundred"
05:41:02 <RibRib2> 100
05:41:02 <RibRib2> *NLP> nlp "negative one hundred"
05:41:02 <RibRib2> -100
05:41:02 <RibRib2> *NLP> nlp "five hundred six thousand"
05:41:03 <RibRib2> 506000
05:41:05 <RibRib2> *NLP> nlp "five thousand six hundred"
05:41:07 <RibRib2> 5600 
05:41:09 <ski> Cale : oh, right. i'm confusing things because in scandinavian contries (at least) we do : thousand,million,milliard,billion,billiard   roughtly
05:41:10 <RibRib2> *NLP> nlp "fifty six hundred"
05:41:11 <RibRib2> 5600
05:41:13 <RibRib2> *NLP> nlp "five hundred thousand"
05:41:15 <RibRib2> 500000
05:41:17 <RibRib2> *NLP> nlp "unknown words"
05:41:19 <RibRib2> *** Exception: nlp: parse error
05:41:21 <RibRib2> *NLP> nlp ""
05:41:23 <RibRib2> *** Exception: nlp: parse error
05:41:25 <RibRib2> *NLP> nlp "three million one hundred forty one thousand five hundred ninety three"
05:41:27 <RibRib2> 3141593
05:41:42 <ski> Cale : and i was trying to convert to the million,billion series in my head
05:41:56 <RibRib2> one million million would be the greatest number tested on...
05:42:22 <ski> does it work better ?
05:42:28 <Cale> RibRib2: where was this page?
05:43:15 <RibRib2> Marking Scheme
05:43:15 <RibRib2> Performance   
05:43:15 <RibRib2> SINGLENUM 1 
05:43:15 <RibRib2> TEN TEEN 2 
05:43:15 <RibRib2> HUNDRED,THOUSAND 3 
05:43:16 <RibRib2> MILLION 4 
05:43:18 <RibRib2> Complicated examples 4 
05:43:20 <RibRib2> Sign (positive/negative) 1 
05:43:22 <RibRib2> Style   
05:43:24 <RibRib2> Coding style 2 
05:43:26 <RibRib2> Commenting 2 
05:43:28 <RibRib2> Diary 1 
05:43:30 <RibRib2> Total 20 
05:43:51 <ski> RibRib2 : is it on the web someplace ?
05:43:55 <Cale> Why not just link? It was on the web.
05:44:20 <RibRib2> http://www.cse.unsw.edu.au/~cs1011/assigns/ass1/index.html
05:44:24 <ski> thanks
05:45:50 <RibRib2> *NLP> nlp "unknown words"
05:45:50 <RibRib2> *** Exception: nlp: parse error
05:46:04 <RibRib2> does that mean just an error, or i need to program that in?
05:46:22 <Cale> http://www.cse.unsw.edu.au/~cs1011/assigns/ass1/spec.html -- seems useful
05:47:19 <Rafterman> RibRib2: who's taking 1a this session?
05:47:27 <Rafterman> and are you using map in your solution?
05:47:29 <Cale> It means you should error "parse error"
05:47:50 <RibRib2> erm.. are you doing the same assignment?
05:48:01 <Rafterman> nope
05:48:06 <RibRib2> the russian fat dude
05:48:09 <Rafterman> if I was I'd hope to know who was teaching it :)
05:48:13 <Rafterman> hmmm
05:48:17 <Rafterman> aleks?
05:48:19 <RibRib2> yeh :)
05:48:20 <RibRib2> haha
05:48:22 <Cale> It's very likely that a Haskell program will have "map" somewhere in it :)
05:48:39 <Rafterman> not for someone who's only been using haskell for 6 weeks
05:48:40 <RibRib2> why u asking if i mapped it?
05:48:50 <Darius> Cale: one could uniformly use fmap
05:48:58 <Cale> well, sure :)
05:48:59 <Rafterman> because I wouldn't've thought you'd have been taught it yet
05:49:03 <RibRib2> oh ok
05:49:11 <Rafterman> since in higher 1a we don't teach it until right near the end of the session
05:49:45 <Cale> It's one of the first things I learned about functional programming.
05:49:47 <RibRib2> hmm
05:49:59 <RibRib2> no actually, im learning map and filter now
05:50:02 <Rafterman> Cale: was haskell your first language?
05:50:05 <Cale> No.
05:50:08 <Rafterman> :)
05:50:33 <RibRib2> Rafterman , what yr are u in?
05:50:33 <Cale> It was the first functional language that I tried though.
05:50:39 <Rafterman> 3rd year
05:50:46 <RibRib2> comp science?
05:50:57 <Rafterman> comp eng/physics
05:51:08 <RibRib2> cool 
05:52:03 * ski is back from talking to other person
05:52:34 <Cale> ("zero" | SIGN (NUM (UNIT)?) ((NUM)? UNIT)* )
05:52:38 <Rafterman> RibRib2: www.cserevue.org.au <-- you should get all your friends to come and see the revue
05:53:07 <RibRib2> were u one of the guys who stuck a poster on your chest?
05:53:27 <Rafterman> can't say I was...
05:53:40 <RibRib2> :)
05:54:09 <RibRib2> is it a play or something?
05:54:25 <Rafterman> it's a comedy sketch show
05:54:33 <Rafterman> with a bit of singing and dancing thrown in for good measure
05:54:49 <RibRib2> ahh cool
05:54:56 <RibRib2> i'd love to come along :)
05:55:13 <Rafterman> tell your friends, it's gonna be a fantastic show
05:55:25 <RibRib2> ok sure
05:55:34 <RibRib2> im off to bed now, cya all
06:09:41 <SyntaxPolice> mornin #haskell
06:09:51 <ski> hello, good afternoon
06:10:03 * adept . o O (more like 16:00 ...)
06:10:12 <kosmikus> hi SyntaxPolice 
06:10:22 <ski> 15:10 here
06:10:31 <Heffalump> hi all
06:11:27 <Cale> 9:08 here
06:14:54 <RibRib> hey ski
06:14:59 <ski> hi
06:15:01 <RibRib> i think i solve the problem :)
06:15:05 <RibRib> solved
06:15:11 <ski> ok
06:15:15 <ski> fine :)
06:15:31 <RibRib> learning is fun
06:15:32 <RibRib> :)
06:15:44 <RibRib> im beginning to like haskell now
06:16:03 <ski> good ;)
06:17:26 <ludde> hi ski :)
06:17:32 <ski> hi
06:17:45 <ludde> i saw you in the algorithms class today 
06:18:00 <ski> RibRib : did you do a complete rewrite or just fixed things here and there
06:18:29 <ski> ludde : oh, mm. ok i was not sure it was you
06:19:40 * ski lols
06:31:35 <RibRib> it fixed "one million million"
06:31:59 <RibRib> but anything that doesnt make sense, it wont work...
06:32:04 <RibRib> so ill lose 4 marks
06:32:12 <RibRib> for the complicated examples
06:32:14 <ski> mm
06:32:17 <Heffalump> what do you mean "won't work"?
06:32:29 <RibRib> gives wrong answer
06:32:34 <Heffalump> instead of?
06:32:40 <ski> error ?
06:32:47 <RibRib> "==== complicated ====="
06:32:47 <RibRib> "two thousand six million three hundred thousand sixty four hundred thirty one"
06:32:47 <RibRib> (nlp "two thousand six million three hundred thousand sixty four hundred thirty one")==(2*1000+6)*10^6+(300*10^3)+6400+31
06:32:47 <RibRib> "two hundred million one"
06:32:47 <RibRib> (nlp "two hundred million one")==200*10^6+1
06:32:49 <RibRib> "two thousand million one hundred thousand"
06:32:51 <RibRib> (nlp "two thousand million one hundred thousand")==2000*10^6+100*1000
06:32:54 <RibRib> these are the complicated ones
06:33:35 <Lunar^> ghc-6.0.1: internal error: stg_ap_v_ret <-- snif
06:33:35 <ludde> RibRib: you're making a program to print numbers as ascii strings?
06:33:58 <RibRib> yes
06:34:06 <RibRib> i cant be bothered with the complicated ones...
06:34:08 <ludde> RibRib: in what language?
06:34:12 <RibRib> no
06:34:17 <ski> ludde : more correctly : convert to Integer
06:34:19 <ludde> in haskell?
06:34:22 <RibRib> im converting words in to numbers
06:34:23 <ski> yes, he is
06:34:24 <ludde> oh
06:34:30 <ludde> convert from a string to an integer?
06:34:34 <ski> yes
06:34:36 <ludde> ah.
06:34:40 <ski> nlp :: String -> Integer
06:34:45 <ludde> doesn't sound fully trivial
06:36:43 <RibRib> wow i think i've mastered the complicated numbers
06:37:49 <ski> mm
06:39:34 <RibRib> ahh damn...
06:39:40 <RibRib> "two thousand six million three hundred thousand sixty four hundred thirty one"
06:39:41 <RibRib> got me
06:39:42 <RibRib> ...
06:39:44 <ski> not right ?
06:40:24 <RibRib> can you teach me how to write an error msg
06:41:21 <ski> like
06:41:26 <ski> error "some message"
06:41:51 <ski> does it help ?
06:42:38 <RibRib> im looking at my text book
06:43:33 <RibRib> need to include the function name
06:43:51 <RibRib> error "nlp: blah blah blah!"
06:43:56 <ski> yes
06:46:32 <RibRib> does it hav to be where the otherwise is?
06:46:49 <ski> yes, presumably after a =
06:47:15 <RibRib> nlp x 
06:47:15 <RibRib> 	|fw x == "negative" = -1*(nlp (rw x))
06:47:15 <RibRib> 	|fw x == "positive" = 1*(nlp (rw x))
06:47:15 <RibRib> 	|otherwise= sum (multelem(group(split 100(map nlp(words x)))))
06:47:29 <RibRib> thats what i hav now, so where can i put the error msg?
06:47:37 <ski> hmm
06:48:11 <ski> you put an error at the place you are sure the input string is wrong
06:48:25 <ski> nlp can't see that easily here
06:48:44 <ski> so perhaps another of your functions should print the error message
06:49:21 <RibRib> hmm
06:49:51 <ski> or you could change some of the function(s) that nlp calls so nlp can detect that something is wrong and then do an  error "nlp: blaha"
06:50:10 <ski> error detecting is not so easy sometimes
06:51:22 <Cale> http://www.cse.unsw.edu.au/~cs1011/assigns/ass1/spec.html looks very useful, except that Rule 3 looks misencoded in my browser.
06:52:33 <Cale> You just have to tag each piece as a NUM or a UNIT, and then pattern match to figure out which rule to take.
06:52:59 <RibRib> ive finished the converting to integers part...
06:53:17 <Cale> ah, what other part is there?
06:53:22 <RibRib> error
06:53:50 <Cale> Oh, so you're just going through and correctly handling any missed cases?
06:53:50 <ski> .. detection and reporting
06:54:03 <RibRib> *NLP> nlp "unknown words"
06:54:03 <RibRib> *** Exception: nlp: parse error
06:54:03 <RibRib> *NLP> nlp ""
06:54:03 <RibRib> *** Exception: nlp: parse error
06:54:31 <Cale> At least it doesn't have to be very detailed :)
06:54:46 <ski> RibRib : that's what it should look like, right ?
06:54:59 <RibRib> yes
06:55:10 <RibRib> unknown word means all words :)
06:55:16 <RibRib> not just "unknown words"
06:55:46 <RibRib> if length /= 0?
06:55:53 <RibRib> is that wat ur thinking of?
06:56:05 <ski> sorry ?
06:56:09 <RibRib> nothing
06:56:15 <RibRib> im just being stupid :)
06:58:26 <RibRib> i think i should write another function that detects for negative or postive...
07:05:43 <ski> ah
07:06:06 <ski> you just need to make sure each occuring word is valid
07:06:23 <ski> and otherwise call  error ...
07:07:44 <ski> RibRib : is nlp still the only function that pattern-matches on literal words (like "fifty",
07:09:25 <RibRib> im not sure
07:09:27 <RibRib> :(
07:09:42 <ski> RibRib : i would put the  nlp "eleven"=11  thingies in a different function, and as a last case for that i'd put  someFun _ = error "nlp: parse error"
07:10:05 <ski> m
07:10:13 <RibRib> you mean all of them?
07:10:50 <ski> yes, except the "nlp x = sum (multelem(gr ..." and possibly the  nlp []=0  also
07:11:57 <ski> (or possible one function for SINGLENUM, one for TEENS, etc.  hmm, not sure ..)
07:13:06 <Cale> I'm just coding up a solution now, and I have a little datatype:
07:13:11 <Cale> data NumPart = Zero -- just "zero"
07:13:11 <Cale> 	| Positive
07:13:11 <Cale> 	| Negative
07:13:11 <Cale> 	| SmallNum Integer -- any n < 100
07:13:11 <Cale> 	| SmallSingle Integer -- temporary distinction for 1-9
07:13:13 <Cale> 	| SmallTens Integer -- temporary distinction for 20,30..90
07:13:17 <Cale> 	| Unit Integer -- 100, 1000, 1000000
07:13:55 <ski> Cale : not sure if RibRib has covered datatypes yet ..
07:14:02 <Cale> hmm..
07:14:43 <ludde> i'll make such a parser too, it seems fun
07:15:00 * SyntaxPolice blames ICFP for increasing my dependence on coffee
07:15:07 <Cale> hehe
07:15:20 <ski> heh
07:15:27 <RibRib> im getting varying arguments error
07:15:56 <Heffalump> cale: why bother with the datatype?
07:16:21 <Cale> It helps to parse and pick out more errors.
07:16:31 <RibRib> num x = error "nlp: parse error"
07:16:35 <RibRib> is that right?
07:16:50 <ski> if put in the right place, yes
07:17:25 <RibRib> cooll
07:17:27 <RibRib> works now
07:17:32 <RibRib> thnx 
07:20:02 <SyntaxPolice> all that free coffee...
07:20:14 <SyntaxPolice> I had a headache this morning because I only drank, like, a _normal_ amount of coffee
07:24:20 <Heffalump> how much did you drink at PLI?
07:24:33 <Heffalump> I think I drank two cups a day max
07:27:05 <SyntaxPolice> Heffalump: well, I drank some at breakfast, at all the coffee breaks, and at lunch
07:28:04 <Heffalump> oh, I guess I had some at breakfast too
07:35:27 <SyntaxPolice> I have this stupid thing in my brain that makes me take free things that I usually want, whether I Really want them or not.
07:36:25 <Heffalump> heh
07:36:30 <Heffalump> I liked the pastries.
07:36:46 <Heffalump> but then I don't have a weight problem yet and they were nice
07:37:08 * adept wonders whether SyntaxPolice heard joke about pill from greedness 
07:37:11 <ludde> I don't  quite understand this:
07:37:11 <ludde> (NUM1 UNIT1 бн. NUMn UNITn UNIT(n+1)) UNIT(n+2) (NUM1 UNIT1 бн. NUMn UNITn UNIT(n+1)) x UNIT(n+2) 
07:37:18 <norpan> as we say in sweden "gratis фr gott"
07:37:19 <SyntaxPolice> adept: nope
07:37:22 <ski> ludde : me neither
07:37:59 <Cale> Appears to be a text encoding problem combined with a mistake in the html.
07:39:25 <adept> man enters drugstore with a LARGE duffel bag. "Can I have this bag full with pills from greedness?". (liberal russia->english translation by me)
07:41:16 * adept . o O (apparently, joke is not that funny or everyone is waiting for something more... well, thats it. nothing more)
07:43:06 * ski does see anything funny :(
07:43:30 <ski> perhaps my english understanding is too bad ..
07:44:49 <Cale> Maybe "Can I have this duffle bag filled with greediness reduction pills?"
07:45:15 <ski> what is duffle
07:45:54 <Cale> It's a kind of large bag. You might carry a full set of hockey equipment in it, say.
07:46:22 <ski> mhm
07:46:25 * Heffalump doesn't really get it anyway
07:47:00 <Heffalump> despite being a native English speaker :-)
07:47:00 <Cale> The whole point is that the guy is greedy for pills that will make him less greedy.
07:47:09 <Heffalump> hmm, ok :-)
07:47:15 <ski> hmm
07:47:40 <Cale> But now that I've explained the hell out of it, it's probably not too funny anymore :)
07:47:56 <ski> funny :)
07:50:52 <adept> It's best delivered with really greedy expression and voice, like "put them all here, I want more, MORE!" :)
07:51:10 <Cale> heheh
07:59:02 <Tomasso> is lambda notation useful? i find it dificult and unuseful
07:59:25 <adept> difficult for _what_?
07:59:46 <Tomasso> to implement, not so familiar
08:00:29 <adept> not familiar is non-issue. we are all learning things ... Difficult to implement - where?
08:00:31 <Riastradh> Familiarity and usefulness are completely different.
08:00:56 <Tomasso> f x = x ----- f \x->x ?? is it ok?
08:01:11 <ski> f = \x -> x
08:01:18 <Tomasso> hehe Ok
08:01:47 <ski> e.g. good for short functions only needed one as argument to higher-order function
08:02:06 <ski> s/one/once/
08:02:48 <adept> map (\(a,b,c) -> a+b+c) $ zip3 [0..] [0..] [0..]?
08:02:53 <adept> why only one? ;)
08:02:58 <adept> ah, once.
08:03:10 <adept> sorry, my fingers are faster than my eyes :)
08:03:43 <Heffalump> morning
08:03:44 <norpan> dosomething >>= \x -> dosomethingelsewith x and y
08:04:09 <Tomasso> and how you indicate more than one parameter in lambda notation?
08:04:18 <norpan> \x y -> f y x
08:04:25 <Tomasso> Ok
08:04:36 <norpan> or \x -> \y -> ... of course
08:04:38 <andersca> or \x -> \y
08:04:39 <andersca> arh
08:04:44 <andersca> you beat me to it mr norpa
08:04:49 <Riastradh> Technically it's not 'more than one parametre'; it's just syntactic sugar for what norpan and andersca just wrote.
08:04:54 <norpan> because you are too slow
08:05:01 <andersca> norpan: how about lunch friday?
08:05:08 <norpan> are you asking me out?
08:05:17 <andersca> norpan: yes
08:05:20 <andersca> what does it sound like
08:05:21 <norpan> hmmm
08:05:27 <norpan> i have to think about it
08:05:30 <andersca> norpan: I think rhult might be joining too
08:05:40 <Tomasso> i seeee
08:05:49 <Riastradh> andersca, it sounds like you're plotting to kill him in revenge for him being faster than you.
08:05:56 <andersca> Riastradh: ssssh
08:06:04 <Riastradh> Oops, sorry.
08:06:13 <SyntaxPolice> adept: the joke was funny :) I was away from the keys :)
08:06:18 <Riastradh> ^H^H^H^H^H^H^H^H^H^H^H
08:06:23 <Heffalump> KILLLLLLLLLLLLLLLLLLLLLLLLLL!
08:06:34 <SyntaxPolice> adept: are you in Russia?
08:06:39 <Riastradh> Kill kill! hate hate! murder murder! mutilate!
08:06:42 <Heffalump> (what are we killing?)
08:06:47 <Riastradh> norpan.
08:06:51 <ski> sacrifice to the great Cthulhu
08:07:49 <norpan> i am already dead
08:07:51 <norpan> scary huh?
08:07:53 <Tomasso> ughh
08:08:12 <norpan> so now you know that there is internet in heaven
08:08:33 <ski> do we ?
08:08:40 <andersca> heaven or hell
08:08:48 <ski> or the abyss
08:09:33 <norpan> it must be heaven because there is haskell here
08:10:11 <Tomasso>  iff = \x -> \y -> if x then not y else y (how would it be in haskell notation)?
08:12:14 <Heffalump> that
08:12:14 <ski> iff x y = if x then not y else y   also suffices, of course
08:12:14 <andersca> norpan: good point
08:13:02 <norpan> x `ьff` y
08:13:33 <andersca> @type iff
08:14:30 <hdaume> iff x = if x then not else id   :)
08:14:45 <andersca> that is beautiful
08:14:45 <Tomasso> mhh i see then a function with more than one parameter is in the way f x y ....... f = \x -> \y and not f = \x y right?
08:14:47 * andersca sheds a tear
08:14:51 <norpan> x <-> y
08:15:02 <hdaume> Tomasso: they're the same
08:15:09 <Tomasso> is the same?
08:15:25 <ski> is iff "if and only if" ?
08:15:30 <hdaume> (modulo the monomorphism restriction)
08:15:33 <hdaume> ski: yeah
08:15:39 <Tomasso> hmmh i think it is
08:15:55 <ski> then shouldn't it be if x then y else not y  then  ?
08:16:10 <hdaume> so it should :)
08:16:22 <norpan> niff
08:16:30 <norpan> or xor
08:17:05 <ski> iff is sometimes called xnor
08:18:50 <norpan> nxor seems a more logical name
08:19:06 <ski> but more difficult to pronounce
08:19:06 <hdaume> nxor just sounds like a planet in a bad sci fi movie
08:19:37 <norpan> eor neor
08:20:11 <ski> in 6502 asm there's an eor instruction
08:20:15 <Tomasso> and one more thing, how do you read this? : | x <= y && x <= z = x
08:20:41 <ski> Tomasso : you mean pronounce ?  or understand ?
08:20:44 <Riastradh> Tomasso, confusedly.
08:20:53 <Tomasso> hehe understend
08:21:03 <hdaume> "such that x lt or eq y and x lt or eq z is x"
08:21:23 <hdaume> oh
08:21:24 <hdaume> heh
08:21:24 <Tomasso> whats lt?
08:21:27 <hdaume> it's a "guard"
08:21:29 <ski> lesser-than
08:21:38 <Tomasso> ok
08:21:40 <hdaume> so f x | x <= 10 = x
08:21:48 <hdaume>     f x = 0
08:21:54 <hdaume> will yield x when x <= 10 or 0 otherwise
08:22:02 <hdaume> you could also write it as
08:22:06 <hdaume> f x | x <= 10 = x
08:22:08 <hdaume>      | otherwise = 0
08:22:30 <hdaume> it lets you use arbitrary boolean-valued functions in pattern matching, essentially
08:22:44 <Tomasso> mhhmm i see
08:22:57 <YveDeLarc> maybe it gets clearer when you think of the '| x<=10' as seperate from '= x'
08:23:18 <ski> somewhat like a big if-then-else-if-... chain, if you know
10:18:39 <shapr> ahem, short question... what was the first type system?
10:18:53 <shapr> would simply typed lambda calculus be that?
10:32:14 <earthy> shapr: possibly
10:32:26 * earthy thinks for a sec
10:37:36 <earthy> yep, simply typed lambda calculus was introduced in 1934.
10:41:15 <shapr> who introduced it?
10:41:23 <shapr> have some references?
10:42:14 * Lor would guess, off the top of my head, Church or Curry.
10:42:22 <Lor> Evening, folks.
10:42:44 <shapr> hi Lor 
10:42:53 * Lor has spent the last five hours printing yet more papers on reflection and type analysis.
10:43:07 <Igloo> Oh?
10:43:08 <shapr> gee, I was doing paying work
10:43:12 <shapr> I'm jealous
10:43:18 <Igloo> Have you got URLs handy?
10:43:20 <Lor> Well, you have money.
10:43:28 <shapr> but I want knowledge!
10:43:37 * Igloo wonders what Lor is interested in it for
10:43:42 <Lor> I'll teach you, you'll pay me. Fair deal. :)
10:44:06 <Lor> igloo, I was ranting about my thesis to everyone at icfp, but maybe not to you.
10:44:32 <Lor> You happened to be at the opposite end of the pizza table. :)
10:44:41 <Igloo> Bah  :-)
10:44:48 <Igloo> What language is this in?
10:45:08 <shapr> arghhh, my stitches are ITCHING
10:45:09 <Lor> Um. Maybe system f.
10:45:17 * shapr gets out Leatherman
10:45:22 <Lor> Something nice and abstract and universally applicable.
10:45:59 <Lor> Once you have something working in system F, then you can go on applying the stuff to real world languages.
10:50:56 <shapr> aaahhh, no more itching
10:52:01 <Igloo> So what are you actually trying to do, if it's not too complex to explain over IRC?
10:52:09 <Igloo> :-(
10:52:36 <Lor> Essentially, getting a type-safe eval.
10:53:05 <Lor> With all the features that make us so love the lisp/scheme eval, but without the warts.
10:53:30 <Igloo> By disallowing things like   if b then (expr of type Int to be evaled) else (expr of type Bool to be evaled)   or by doing runtime stuff too?
10:53:36 <shapr> yay, I feel better now.
10:53:45 <Igloo> Cool
10:53:51 <shapr> leathermans are useful.
10:53:56 <Igloo> !
10:54:22 * shapr laughs
10:54:26 <Lor> Isn't any restriction on eval necessarily "runtime stuff"?
10:54:27 <shapr> I'm a DIY kind of guy.
10:54:40 <Lor> Since, after all, the point of eval is that its argument is determined purely at runtime.
10:55:05 <Igloo> True
10:55:27 <Lor> This, btw, is why I don't consider MetaML and its variants to support a true eval.
10:55:34 <shapr> have you guys seen Proxima and Programatica?
10:56:12 <Igloo> The latter was demoed at ICFP wasn't it?
10:56:36 <shapr> I thought they showed both
10:56:48 <Igloo> Ah, right - yes then  :-)
10:56:50 <shapr> oh, and Chameleon, which I haven't tried either.
10:56:53 <Igloo> I couldn't remember the name of the other one
10:57:36 <Igloo> The one that augmented your editor looked like a nice idea, although I think a bit more cooperation from the editor would be nice before it is really usable
10:58:02 <shapr> the refactoring thingy?
10:58:17 <shapr> code for that one isn't available yet :-(
10:58:45 <Igloo> Yeah
10:59:02 <shapr> would be easy to make a menu and keybindings in emacs
11:00:04 <shapr> I dunno about vim
11:00:29 <Igloo> Losing the editting history and suchlike is the sort of thing that would really want to be fixed
11:00:52 <shapr> source changes could be undone in emacs
11:01:35 <shapr> but the original refactoring browser has darcs-style commutable undos
11:01:40 <Igloo> Even though it was reloading the source from disk?
11:02:05 <shapr> hm
11:02:16 <shapr> actually, yes
11:02:32 <shapr> I'd use the shell-command stuff, and pass the buffer as standard in to the refactoring toool
11:02:45 <shapr> then I could use emacs' undo with no problems.
11:03:17 <shapr> shouldn't be too hard to write
11:06:40 <andersca> hej shapr
11:06:45 <andersca> shapr: I'm looking forward to friday!
11:06:52 <andersca> shapr: that's when the course with john hughs starts
11:10:49 * hdaume is jealous
11:11:39 <earthy> typed lambda calculus, introduced by Curry, 1934, refs can be found in Henk Barendregt's chapter in the Handbook of Logic in Computer Science
11:13:29 <earthy> (H.B. Curry, 1934, Functionality in combinatory logic, Proceedings of the National Academy of Science USA 20, 584-590)
11:27:01 <andersca> hdaume: I'm jealous, you get to work at microsoft research!
11:27:02 <andersca> :)
11:33:09 <hdaume> andersca: for two more days :)
11:34:19 <andersca> did you have a microsoft.com e-mail address?
11:34:47 <hdaume> yeah
11:38:38 <reffie> hdaume did you get firedL
11:38:56 <reffie> ?
11:39:02 <hdaume> haha, no...i was just a summer intern
11:39:21 <andersca> so it was @microsoft.com, not @research.microsoft.com?
11:39:24 <reffie> ah
11:39:33 <hdaume> i think either works
11:39:58 <reffie> what did you do?
11:40:17 <hdaume> i'm actually in the machine learning group -- i worked on web search stuff
11:40:37 <reffie> do you have a degree?
11:40:46 <hdaume> i have a BS and MS and am working on my PhD
11:40:56 <reffie> i see
11:41:20 <reffie> BS and MS in what?
11:41:41 <hdaume> math and CS, respectively
11:41:59 <reffie> k
11:50:51 <reffie> is it hard to get into microsoft as an intern?
11:52:32 <hdaume> i have no idea :)
11:52:58 <reffie> how did you get in?
11:53:00 <hdaume> it think it largely depends on the group/project
11:53:13 <reffie> i see
11:55:22 <Igloo> The problem with slow compiles is I spend all my time looking at them
12:14:26 <SyntaxPolice> Igloo: so, do you think I should take over hat, hmake, & nhc in debian?
12:14:35 <SyntaxPolice> Igloo: I think it would make sense for you to sponsor me
12:17:04 <Igloo> Syn: I think someone should, certainly  :-)
12:17:16 <Igloo> And yeah, like I said I'm happy to sponsor you if you do
12:18:12 <SyntaxPolice> :)
12:18:17 <Igloo> Oh, and http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=167658 exists incidentally. I haven't really thought about it yet.
12:18:56 <semaj> hi
12:18:58 <semaj> back
12:19:04 <semaj> :)
12:19:24 <SyntaxPolice> Igloo: what debian needs is a way for the autobuilders to rebuild something in response to a new package upload
12:20:01 <semaj> i was reading the log of hte afternoon while i was away  
12:20:12 <SyntaxPolice> so you should be able to say "when I upload ghc5, you should rebuild x, y, and z" or better yet, in x, y, and z's control files, you should be able to say "rebuild me when there's a new version of ghc"
12:20:33 <semaj> and i notice that you were talking about that "one thousand" problem
12:20:55 <semaj> whell yesterday when i read it i wrote a solution, to it 
12:21:08 <semaj> 25 lines if i recall
12:21:11 <SyntaxPolice> this would solve a lot of problems
12:21:14 <Xcalibor> hellos :)
12:21:52 <semaj> and it sonsidered alot of pitfalls like " one hundred thirty two thousand"
12:22:02 <semaj> this is 132000
12:22:07 * Igloo forsees loops  :-)
12:22:41 <semaj> like one million can be expressed as one thousand thousand
12:23:06 <SyntaxPolice> Igloo: there should't be loops :(
12:23:14 <semaj> other pitfalls, the code is abstracted from the therm, so you can had the trilion
12:23:18 <SyntaxPolice> it should be related to the build-depends; two things can't build-depend on eachother
12:23:25 <semaj> or the quaquazilion :)
12:23:28 <Igloo> So, if someone sets off a bomb at a #haskell meet, there goes Haskell in Debian  :-)
12:23:35 <semaj> or even fractional values :)
12:23:46 <Igloo> Why not? ghc6 and happy do
12:23:47 <semaj> dont no if it interests you :)
12:24:21 <SyntaxPolice> Igloo: huh?
12:24:27 <SyntaxPolice> huh as far as the bomb thing
12:24:56 <semaj> i had it in 18 lines but tooke thinds apart so that with 30 people can understand beter and see where things are going
12:24:58 <semaj> :)
12:24:58 <Igloo> Between us we'd cover all 3 implementations
12:25:06 <SyntaxPolice> hehe
12:25:29 <semaj> but as no one seems interested in this i ll just go now :)
12:25:31 <semaj> :)
12:25:38 <SyntaxPolice> so actually, loops isn't a problem.
12:25:43 <SyntaxPolice> or aren't a problem
12:25:54 <SyntaxPolice> so you upload happy, and ghc gets rebuilt
12:25:57 <SyntaxPolice> you upload ghc, and happy gets rebuilt
12:26:16 <Xcalibor> i am having some trouble installing ghc... it says i need ghc for bootstrapping (but I obviously don't have it yet installed) I have hugs98, though
12:26:32 <SyntaxPolice> Xcalibor: you don't happen to be using Debian, do you? :)
12:26:34 <Igloo> What OS/arch do you have?
12:26:49 <SyntaxPolice> Igloo: what do you think of packaging helium, speaking of which
12:27:10 <SyntaxPolice> that way we'd each have to haskell implementations :)
12:27:12 <SyntaxPolice> s/to/two
12:27:24 <Igloo> Heh, that's an idea. What's it written in?
12:27:27 <Xcalibor> SyntaxPolice: no, I'm using mandrake 9.1,,, why? I read something about all Hasewll Debian users being in #haskell or somethig :-)
12:27:52 <SyntaxPolice> Igloo: not sure. it has a pretty sane build system, though
12:28:04 <Igloo> Xcalibor: Either repent and install Debian or get a binary RPM from the download page
12:28:05 <SyntaxPolice> Xcalibor: well, igloo here takes care of ghc on debian, so you can just "apt-get install ghc6"
12:28:15 <SyntaxPolice> Igloo: surely there's a better way?!
12:28:25 <Igloo> better way?
12:28:37 <SyntaxPolice> for Xcalibor. he can build it from scratch, no?
12:28:45 <Xcalibor> Igloo: AMD Athlon 1.8, using GNU/Linux Mandrake 9.1, Linux 2.4.21
12:28:52 <SyntaxPolice> isn't there a way to amke it bootstrap?
12:28:54 <Igloo> Build GHC from scratch without GHC? Not easily
12:29:28 <earthy> I've come up to 5.04.3 doing that
12:29:28 <Igloo> If you have it on one arch you can go through a convoluted, painful process to port it to another one
12:29:28 <earthy> but that was starting from 4
12:29:28 <Xcalibor> Igloo: yup... for some reason, GHC is not self-bootstrapping
12:29:28 <Igloo> s/arch/machine/
12:29:28 <earthy> and it was painful, yes.
12:29:38 <Xcalibor> I'm going to try and get mandrake's rpm if there's one...
12:29:44 <Igloo> If there are binary RPMs or tarballs, which there are, then that is far easier
12:30:01 <Igloo> You can always just use it to compile a new one and then get rid of it
12:30:02 <SyntaxPolice> Xcalibor: and if you still want to build it yourself, at least you will be able to bootstrap :)
12:30:08 <SyntaxPolice> yeah, like he said
12:35:14 <reffie> so my university is famous now.
12:35:14 <Xcalibor> SyntaxPolice: Igloo: mmm... maybe that will be the way, because I don't seem able to find a Mandrake RPM...
12:35:14 <andersca> how is list comprehension implemented inside of ghc/hugs?
12:35:14 <andersca> is it done through recursion?
12:36:14 <SyntaxPolice> reffie: why is it famous?
12:36:37 <reffie> the 1100 g5 thing
12:37:27 <Igloo> Hmm, the Helium page talks about Java
12:38:10 <Xcalibor> Igloo: so you are Ian?
12:38:22 <Xcalibor> nice to meet ya :)
12:38:22 <Igloo> Yes
12:38:27 * Xcalibor is David
12:38:53 <Igloo> Did I meet you at ICFP?
12:38:55 <Xcalibor> not that I am any famous, but... I used to maintain redhat development rpms of the window manager Ion
12:39:12 <Xcalibor> nope,... did you belong to any team?
12:39:12 <Igloo> Nice to meet you too, anyway  :-)
12:39:17 <Xcalibor> same herte :)
12:39:35 <semaj> for thos interest one more pitfall that i found interesting "one thousand thirty two hundred", 4200 :) my program also cover that, so far all imaginable possabilities whith unlimited words is covered in 30 lines :) well i just did-it to pass the time, if anyone whant to compare versions :) just say
12:39:39 <Igloo> Yes, but I meant the conference not the contest  :-)
12:40:05 <Xcalibor> so Debian, uh? I may try Knoppix one of these days, been talked pretty well about it.... but this Draky is working pretty fine
12:40:25 <SyntaxPolice> gr. helium's configure script seems to be unable to find my ghc for some reason
12:40:42 <Xcalibor> Igloo: nope to none of both conference or contest, though I was this close to go, but my boss finally decided it was too expensive (and it was for me, of course)
12:40:46 <Igloo> Is /usr/bin/ghc correct, Syn?
12:41:00 <SyntaxPolice> well, thats where ghc is, yes
12:41:13 <SyntaxPolice> I've also got one in /usr/local/bin
12:41:15 <SyntaxPolice> I don't know where its looing
12:41:54 <Igloo> In lvm/src?
12:42:27 <SyntaxPolice> no, in heliumNT
12:42:47 <Igloo> Worked for me: checking for ghc... /usr/bin/ghc
12:43:04 * SyntaxPolice shrugs
12:43:19 * SyntaxPolice is too dumb even for helium
12:43:24 <Igloo> lol
12:43:40 <Xcalibor> ok, got a binary one... but there's no ghci (?)
12:43:42 <Igloo> Do you know what the state of Java in Debian is?
12:44:02 <SyntaxPolice> Igloo: umm... you can use blackdown's java
12:44:14 <SyntaxPolice> and there are apt sources, but they aren't very good at making debs, they mostly work.
12:44:38 <Igloo> That's no use for packaging Helium
12:45:25 <SyntaxPolice> does helium really require java?
12:45:43 <Igloo> Only for the graphical interpretter I think
12:45:44 <Lor> No.
12:46:09 <Lor> I compiled it and used it without knowing anything about it having to do with java.
12:46:32 <Igloo> Hmm, ghc is rejecting "infixl 9 \\"
12:46:53 <hdaume> weird
12:47:01 <Igloo> ../../lvm/src/lib/common/Set.hs:137: parse error on input `\'
12:47:33 <SyntaxPolice> oh, actually, somethings wrong w/ my ghc installation :(
12:47:39 * SyntaxPolice kicks Igloo
12:47:55 <Igloo> That's why I asked earlier  :-P
12:48:05 <Igloo> Do update-alternatives --auto ghc
12:48:15 <Igloo> Or do I mean update-alternatives --auto /usr/bin/ghc?
12:48:56 <SyntaxPolice> update-alternatives: unable to open /var/lib/dpkg/alternatives//usr/bin/ghc.dpkg-new for write: No such file or directory
12:49:06 <seafood> hello all!
12:49:08 <SyntaxPolice> the former worked
12:49:10 <SyntaxPolice> seafood: !
12:49:13 <Igloo> OK, cool
12:49:19 <Igloo> Hi seafood
12:49:29 <seafood> hey. how you doin'. I'm kickin' old school in Austria at the moment.
12:49:45 <SyntaxPolice> Igloo: I'm sure you can understand how I had trouble imagining that I didn't have ghc installed :)
12:50:03 <SyntaxPolice> seafood: I'm doing pretty good. rockin' out in Ohio
12:50:23 <seafood> SyntaxPolice: First time I've had internet in days.
12:50:33 <Igloo> Aha, it seems to be cpp breaking it. Somehow.
12:50:43 <SyntaxPolice> seafood: thanks for your mails.
12:51:28 <reffie> anyone use darcs?
12:51:56 <SyntaxPolice> shapr does
12:52:02 <reffie> is it any good?
12:52:46 * SyntaxPolice shrugs
12:52:55 <reffie> *shrug*
12:53:33 <Igloo> Oh, bah, it's treating the last \ as a line continuation character
12:54:13 <reffie> how about arch?
12:55:10 * SyntaxPolice has used subversion a bit
12:55:19 <SyntaxPolice> i hear good things about arch, though
12:56:06 <Lor> Ho hum. Wonder what the chances are of obtaining a document that's referred to as "Personal communication, circa 1980"...
12:56:19 <andersca> does it have a bibtex entry? :)
12:57:28 <Lor> I guess one could make up something... http://citeseer.nj.nec.com/context/36014/0
12:58:05 <SyntaxPolice> seafood: so are you glad to be back home?
12:58:31 <SyntaxPolice> seafood: how did your talk go, I was sorry to have missed it
12:58:55 <Lor> Hi, Sean.
13:02:18 <seafood> SyntaxPolice: Aha, rookie mistake.  I'm in Austria, not Australia. Osterreich (forgive the lack of umlaut). I haven't given my talk yet. But I have squeezed another 8% performance out of PanTHeon!.
13:03:26 <Xcalibor> seafood: you are in .at, not in .au
13:05:26 <seafood> Lor: Hi Lauri
13:06:55 <Xcalibor> seafood: right?
13:07:33 <SyntaxPolice> seafood: hm. you didn't give a HIM talk?
13:08:10 <seafood> SyntaxPolice: Oh yes I did.
13:08:38 <SyntaxPolice> yeah, I had to leave after lunch, so I missed it :(
13:09:11 <SyntaxPolice> I was looking at the schedule yesterday and I was like, "Wow, I don't remember that Objective C talk at all!" I was pretty surprised with myself, before I realized that there was a good reason I didn't remember it.
13:09:34 <Igloo> :-)
13:15:04 <Igloo> Hmm, helium doesn't even have a text-mode interface - it is just a compiler if you don't have the Java bit
13:15:49 <Igloo> Looks like it should be easy enough to package as a compiler at least. Don't know about the interpretter without more research
13:16:44 <Lor> isn't texthint a "text-mode interface"?
13:19:09 <Igloo> Oh, I stand corrected
13:19:25 <Lor> It's bloody slow, though.
13:21:02 <Igloo> Having to get all the env vars set up right and naming files as it wants makes it a lot harder to use out-of-the-box than hugs
13:23:53 <Lor> Yeah, the obligatory TEMP is really silly.
13:24:08 <shapr> hi seafood!!
13:24:56 * Igloo e-mails them with another source bug and mentions Debian packaging
13:25:03 <Igloo> Oh, I should ask about the logging too
13:27:02 * shapr yawns
13:27:50 <SyntaxPolice> shapr: reffie was asking about darcs :)
13:27:54 <shapr> aha
13:27:59 <shapr> reffie: works fine
13:28:10 <shapr> I think I'm going off to be social for a bit.
13:28:16 * shapr tears himself away from his computer
13:35:47 <Lor> He stops communicating with us nice folks and calls that being "social"? :P
13:40:27 <Xcalibor> the binary tarball of GHC is lacking the binaries in the bin directory (there are symlinks and shell scripts, but the binaries themselves are missing (????)
13:42:25 * Xcalibor some tiny weenie little help appreciated :-)
13:45:22 <Igloo> What was the problem with the RPM?
13:46:29 <Igloo> If it was only missing ghci then you could use it to compile the source yourself
13:47:08 <Xcalibor> no, all binaries are missing
13:47:23 <Igloo> From the RPM /and/ the binary tarball?
13:48:30 <Xcalibor> from the binary tarball... the rpm is for redhat 7.x systems which are much older than mine... i may try to download it, but someone tried to use them om Mandrake 9.1 and it didn't work (and it will take longer than 1 hour to download)
13:48:52 <Xcalibor> it's explained in here: http://freshmeat.net/projects/darcs/?topic_id=52
13:51:22 <semaj> :) back
13:51:32 <Xcalibor> wb semaj
13:51:52 <semaj> hi :)
13:52:36 <Xcalibor> frankly, hughs98 was much easier to install :-P
13:52:52 <semaj> is there any ohter problem to solve here in the # ????
13:53:08 <Igloo> GHC isn't designed to be easy to install from scratch - that's why God gave us Debian  :-)
13:53:34 <hdaume> NHC is pretty easy to install from scratch :)
13:53:42 <Xcalibor> Igloo: well, i have even installed Linux From Scratch, and it wasn't as difficult as GHC
13:53:51 <Igloo> As long as you are on a 32-bit arch, yeah  :-)
13:53:58 <hdaume> :P
13:54:15 <Xcalibor> i was looking for a powerful haskell repl where I could define functions without the need to write them in files and load them
13:54:26 <Xcalibor> and they told me ghci was the one, but, man!
13:55:36 <SyntaxPolice> Xcalibor: you should bring up your concerns with the GHC folks. they're v. interested in user feedback.
13:55:58 <SyntaxPolice> Xcalibor: if you use emacs, emacs-mode interacts nicely with hugs and, in my opinion, helps w/ the pain of having to load files.
13:56:17 <SyntaxPolice> s/emacs-mode/haskell-mode
13:56:18 <Xcalibor> SyntaxPolice: I can use Emacs if I have to :)
13:56:32 <semaj> i use LFS as well but never tried to install GHC, i am downloading the src and the rpm binaries to try :)
13:56:41 <Xcalibor> semaj: good luck
13:57:49 <Xcalibor> SyntaxPolice: ok, any idea on how to activate the emacs-mode? does it come with hughs sources?
13:58:12 <semaj> thanks, hope it to be realy dificult, after the "one milion" problem i sotped having something to do, is GHC or ET :)
13:58:15 <semaj> :)
13:59:24 <SyntaxPolice> Xcalibor: btw, have you read section 10 of the building-ghc guide?
13:59:31 <Igloo> "one million" problem?
13:59:42 <semaj> does anyone have any other of those homework problems for haskell, i am still on holidays and it helps pass the time
14:00:01 <SyntaxPolice> Xcalibor: open a haskell file and try M-x turn-on-haskell-hugs
14:00:03 <semaj> that "one milion" -> 1000000
14:00:10 <SyntaxPolice> if that doesn't work, you might not have haskell-mode installed
14:00:18 <Xcalibor> SyntaxPolice: i'm not sure, actually...
14:00:25 <semaj> that was discussed here in the #
14:00:36 <semaj> during the afternon
14:00:36 <SyntaxPolice> well, I guess its enough to note whether you're in haskell-mode when loading a haskell file in emacs
14:00:58 <Igloo> If you have a PPC machine then you could try getting GHC working on PPC Linux  :-)
14:00:58 <semaj> i whent to play soccer and when i came back i wrote a solution
14:01:08 <SyntaxPolice> Xcalibor: section 10 explains how to bootstrap ghc if you don't have a binary for that platform: http://haskell.cs.yale.edu//ghc/docs/6.0.1/html/building/sec-porting-ghc.html
14:01:45 <Xcalibor> SyntaxPolice: ok, no haskell mode on emacs... 
14:02:07 <semaj> i like emacs but prefer vim 
14:02:13 <SyntaxPolice> Xcalibor: so google for haskell-mode and install it. (of course, its apt-get install haskell-mode on debian ;)
14:02:22 <Xcalibor> SyntaxPolice: about the 10 question; i was reading through that document... 
14:02:38 <Xcalibor> SyntaxPolice: yeah, i know apt-get is nice :-P
14:02:54 <SyntaxPolice> Xcalibor: the difficulties you're facing aren't _really_ ghc's fault. its just that you're used to using languags where all the porting to new platforms is already done.
14:03:05 <semaj> the haskell mode for emacs has a link for it at the related projects in the GHC home page at haskell.org :)
14:03:18 <semaj> but you can allways go with google :)
14:06:59 <semaj> http://haskell.org/haskell-mode/
14:08:29 <Xcalibor> yup, found it there (by the lack of an rpm...)
14:08:55 <semaj> :)
14:09:15 <Xcalibor> SyntaxPolice: mmm... I have installed even Icon interpreters, an J language ones under OS/2 Warp or Linux...
14:10:07 <Xcalibor> SyntaxPolice: but I'll give several opportunities to Haskell, I'm interested in FP and Haskell has a lot to offer (since I am more focused on O'Caml or Scheme as of late, but Haskell's on the top of the stack)
14:10:57 <SyntaxPolice> Xcalibor: I'm not familiar with Icon and J; are they self-compiling?
14:11:13 <Xcalibor> Icon was, J wasn't
14:11:20 <SyntaxPolice> so how did it handle the bootstrapping?
14:11:36 <Xcalibor> there was a small C program that parsed a lex/yacc grammer
14:11:53 <Xcalibor> enough to understand the basic stuff, then everything started to compile itself
14:12:20 <Xcalibor> I remember SmallEiffel is also self-hosted... same estrategy was used
14:12:38 <Xcalibor> at least in pretty early versions
14:16:24 <SyntaxPolice> I see. I wonder what version of haskell ghc6 is written in
14:16:43 <Xcalibor> they mention you need at least ghc4.x
14:17:13 <Heffalump> presumably they are careful about using extensions too soon after implementing them
14:17:34 <Igloo> I think CVS now needs 5.x
14:17:37 <Xcalibor> Heffalump: that sounds very sensible
14:18:31 <Heffalump> if and when they start using TH things could get interesting :-)
14:19:54 <Xcalibor> TH?
14:20:04 <SyntaxPolice> in TH, ghc's only one line!! ;)
14:20:19 <Igloo> That's one hell of a line  :-)
14:20:23 <SyntaxPolice> Xcalibor: Template Haskell is a new macro / template system for Haskell.
14:20:27 <Xcalibor> which line? run ?
14:20:36 <SyntaxPolice> main = ghc
14:20:45 <Igloo> Ah, I see
14:20:45 <Xcalibor> ah... have read about it on comp.lang.functional... sounds interesting
14:20:46 <SyntaxPolice> :P
14:20:58 <Xcalibor> SyntaxPolice: of course :-P   :)
14:21:09 <Xcalibor> mmm
14:21:21 <Xcalibor> what? no monads? no main = do ghc ??
14:21:22 <Heffalump> compile file = [d| parse file |]
14:21:27 <Xcalibor> weeeeeird :)
14:21:35 <Heffalump> do ghc and ghc are equivalent
14:21:53 <Xcalibor> really?
14:22:03 <Xcalibor> without any monads nearby?
14:22:17 <Heffalump> do ghc might require ghc to have a monadic type
14:22:21 <Heffalump> but if it does, then the two are equivalent
14:22:31 <Heffalump> do notation only makes a difference when you have more than one line
14:22:34 <Xcalibor> mmm... still pretty stuck around the concept of monad, so i guess it's normal i don't understand that
14:22:51 <Xcalibor> Heffalump: ah, okay, i see now...
14:23:09 <SyntaxPolice> hey, did anyone see SPJ's talk at PPDP? I was looking over the slides and they seemed to suggest that ML is moving toward monads?
14:23:11 <SyntaxPolice> Comments?
14:23:28 <hdaume> do is just used to sequence commands.  if there's only one command in the sequence, there's nothing for it to do, so it leaves it alone
14:23:58 <Igloo> Xcalibor: "do" just starts a block that will get desugared using the monad notation
14:24:05 <Igloo> so
14:24:06 <Igloo> do x
14:24:08 <Igloo>    y
14:24:15 <Igloo> gets desugared to x >> y
14:24:21 <Heffalump> SyntaxPolice: DYM DP-COOL?
14:24:24 <Heffalump> are you sure he wasn't taking the piss?
14:24:28 <Igloo> But do x just gets desugared to x
14:24:36 <SyntaxPolice> Heffalump: that reminds me, wtf does taking the piss mean?
14:24:42 <shapr> making fun of something
14:24:47 <SyntaxPolice> also, wtf does DYM DP-COOL mean?
14:24:54 <shapr> do you mean DP-COOL
14:24:54 <Xcalibor> SyntaxPolice: ML towards monads? and why should it?
14:24:58 <SyntaxPolice> Heffalump: its hard to tell from just the slies :)
14:25:05 <Heffalump> Declarative programming something object oriented languages
14:25:11 <shapr> a pisstake is a parody
14:25:12 * Igloo can't think of the etymology of that or taking the mickey OTTOMH
14:25:13 <Xcalibor> Igloo: does >> work like >>= ?
14:25:20 <Igloo> Yes
14:25:22 <SyntaxPolice> Xcalibor: well, I'm makign this up, but because they are interested in purity and monads are cool
14:25:29 <Igloo> do a <- x
14:25:29 <Igloo>    b <- y
14:25:30 <shapr> Igloo: probably from Disney ;-)
14:25:38 <Igloo>    c
14:25:56 <Igloo> would be desugared as x >>= \a -> y >>= \b -> c
14:25:56 * shapr goes to sleep
14:26:12 <SyntaxPolice> night, shapr
14:26:15 <Igloo> >> is just used when the result is thrown away
14:26:26 <Xcalibor> Igloo: i see now... thanks, it makes much more sense now :)
14:26:45 <Xcalibor> so >> would be used with IO monads, right?
14:26:55 <Igloo> Not necessarily
14:26:59 <Heffalump> you may want to throw the result away in other monads too
14:27:00 <Igloo> You would say   c <- getChar
14:27:33 <Igloo> but you don't care about the result of a putStr as it's always (), so in that case >> would be used
14:27:51 <Xcalibor> ah... mmm... okay, of course...
14:28:08 <Xcalibor> well, yes, it makes all sense
14:28:23 <Igloo> You can get both used in different places when desugaring a single do block, of course
14:28:53 <Smerdyakov> Oooooof course.
14:39:12 <Xcalibor> ok, haskell mode running
14:39:14 <Xcalibor> :)
14:39:22 <SyntaxPolice> Xcalibor: cool!
14:39:35 <SyntaxPolice> so have you used C-c C-l yet?
14:41:57 <Xcalibor> not yet... any modules I should install besides font-lock and hughs?
14:42:40 <Xcalibor> i want to let it finished now so I can forget about configuration...
14:44:15 <Xcalibor> ok, C-c C-l working... very nice :-)
14:46:34 <Xcalibor> ok, i loaded font-lock, indent and hughs modules... what's doc-mode?
14:47:27 <SyntaxPolice> I don't know what doc-mode is
14:47:34 <SyntaxPolice> M-x aprops <ENTER> doc-mode
14:47:36 <SyntaxPolice> that might give you some info
14:48:00 <Xcalibor> turn-on-haskell-doc-mode
14:48:21 <SyntaxPolice> ah. don't know offhand.
14:48:21 <Xcalibor> and also 'turn-on-haskell-decl-scan?
14:49:15 <Xcalibor> well... i'll dig into the documentation... must be written in there, somewhere...
14:49:44 <SyntaxPolice> did you try apropos?
14:50:10 <SyntaxPolice> or M-x describe-function
14:51:29 <SyntaxPolice> OK I'm outta here. ttyl
14:52:24 <Xcalibor> laters SyntaxPolice thanks for all the help!
14:52:56 <Xcalibor> mmm... I am not yet able to write new definitions in the toplevel... :-/
14:54:36 <Igloo> Hmmm, still no on-line ICFP contest results?
15:10:07 <Xcalibor> i read there was a haskell submission this year
15:10:44 <Heffalump> to ICFP?
15:15:11 <hdaume> Xcalibor: you need to say "let ..."
15:15:13 <hdaume> so:
15:15:17 <hdaume> Prelude> let f x = x * 2
15:15:20 <hdaume> Prelude> f 5
15:15:21 <hdaume> 10
15:48:52 <Xcalibor> hdaume: will try (sorry, was doing some cleaning up, my sister and fiancщe are coming tomorrow and my flat's a ratts nest _P  )
15:51:39 <Heffalump> hi
15:51:56 <kosmikus> hi Heffalump 
15:52:22 <kosmikus> will you be at IFL?
15:52:25 <Heffalump> nope
15:52:33 <Xcalibor>  let fact n = | 0 -> 1 | n -> n*fact(n - 1)
15:52:37 <Xcalibor> this fails... why?
15:52:45 <Heffalump> since I don't (implement FLs, that is)
15:52:57 <kosmikus> Heff: :)
15:53:02 <kosmikus> Xcalibor: wrong syntax
15:53:18 <Xcalibor> kosmikus care to elaborate, please?
15:53:22 * Heffalump wonders if he should have been a bit more discerning in his choice of postdoccery
15:53:26 <kosmikus> did you try to enter it in GHCi?
15:53:31 <kosmikus> Heff: ?
15:53:41 <Xcalibor> kosmikus: no ghci... haskell mode in emacs with hugs98
15:53:51 <Heffalump> well, gone somewhere other than Oxford and found something more Haskellish to do
15:54:14 <Heffalump> can you use guards in let bindings?
15:54:37 <kosmikus> guards in lets: yes
15:54:47 <Xcalibor> Heffalump: dunno... but i cannot define functions the usual way in the repl... let will let me do so, as hdaume told me
15:54:59 <Heffalump> your syntax for using | ... is wrong
15:55:18 <kosmikus> but you cannot define values on the command line of Hugs at all, only in a proper module
15:55:27 <Xcalibor> Heffalump: oh?  mmm... the first | is not necessary?
15:55:38 <Heffalump> xcalibor: let only works like that in GHCi
15:55:45 <Heffalump> so you're screwed anyway
15:55:54 <kosmikus> fact n | 0 = 1 | n = n * fact (n-1)
15:56:16 <kosmikus> sorry, not even that
15:56:26 <Xcalibor> kosmikus: nope, not even that :-/
15:56:36 <kosmikus> fact n | n == 0 = 1 | otherwise = n * fact (n-1)
15:56:50 <Heffalump> is that valid syntax either?
15:57:05 <Heffalump> oh, so it is
15:57:12 * Heffalump would have assumed a newline was needed somewhere :-)
15:57:14 <Xcalibor> Main> let fact n | n == 0 = 1 | otherwise = n * fact (n-1)
15:57:14 <Xcalibor> ERROR - Syntax error in expression (unexpected end of input)
15:57:51 <Heffalump> xcalibor: as kosmikus and I already said, you can't do it at all with Hugs
15:58:01 <Heffalump> you can do it with let in the REPL in ghci, but not in hugs
15:58:10 <Xcalibor> Heffalump: not even with rhe emacs mode?
15:58:19 <Heffalump> err, dunno about that.
15:58:26 <Xcalibor> Heffalump: ghci is a hell to bootstrap :-/
15:58:33 <Heffalump> what platform?
15:58:34 <kosmikus> you have to have a module
15:58:50 <Xcalibor> linux 2.4.21 in AMD Athlon
15:59:04 <kosmikus> enter the definition into the file -- you can have a split-screen with the module in the upper half, the interpreter running in the lower half
15:59:05 <Cale> uh, wouldn't there be a nice binary?
15:59:50 <kosmikus> Heff: why are you unhappy with your postdoc? don't you like what you are doing?
16:00:15 <Xcalibor> i downloaded a tar.bz2 that's supposed to have binaries, but the bin/ directory is then with no binaries, and with malfunctioning shell scripts and dangling symlinks... :-(
16:00:30 <Cale> Xcalibor: what distribution?
16:00:34 <Heffalump> I'm not unhappy with it, it's fun. I'm just wondering if I'd have enjoyed Haskell-ish stuff more.
16:01:54 <Xcalibor> Cale: i got a Mandrake 9.1, there's no rpm for it
16:02:00 <Cale> hmm...
16:02:20 <Heffalump> xcalibor: did you run ./configure and make in-place on the unpacked tarball?
16:02:31 <Heffalump> the dangling symlinks get fixed once you do that
16:02:42 <Heffalump> (you can also get it to install to somewhere outside the tarball, if you prefer)
16:03:11 <Xcalibor> the configure says it cannot find an installe dghc
16:03:17 <Xcalibor> installed ghc, I mean
16:03:19 <kosmikus> had you ever thought about leaving Oxford after your PhD?
16:03:22 <Xcalibor> i'll try again
16:03:44 <Heffalump> my main plan was to get a non-research job at that point
16:03:49 <Heffalump> then this postdoc came up and tempted me
16:04:13 <Heffalump> so I hadn't really seriously considered the idea of going elsewhere in academia
16:04:24 <kosmikus> okay
16:04:29 <Cale> http://www.haskell.org/ghc/download_ghc_600.html -- the rpms available here are likely to work, even though they're RedHat.
16:04:30 <Xcalibor> SyntaxPolice: mmm.. it's working this time!!!
16:04:36 <kosmikus> but you've got plenty of time ;) you can do as many postdocs as you like
16:04:37 <Cale> oh, okay then :)
16:04:50 <Heffalump> if I'm sure I want to stay in academia, yes
16:04:53 <Xcalibor> Cale: already proved by another Mandrake 9.1 user, they don't work...
16:04:58 <Heffalump> but I'm not really
16:05:14 <kosmikus> why not?
16:05:46 <Heffalump> lack of original research ideas, mainly
16:06:16 <kosmikus> hey, don't give up too soon on that -- one idea can be enough, at the right moment
16:06:40 <Smerdyakov> I don't like the general academic environment where getting published counts more than making useful discoveries or systems.
16:06:53 <Binkley> Yeah, me neither
16:07:05 <Binkley> Does anyone like it, I wonder? If not, why are things that way
16:08:26 <Heffalump> how do you communicate discoveries without getting published?
16:08:38 <Heffalump> systems are easier, because people can just download and use them, of course
16:09:04 <Binkley> Sure, but publishing encourages people to focus on the 1% improvement to the existing system instead of developing something innovative
16:09:07 <Binkley> Sometimes it does, anyway.
16:09:07 <Smerdyakov> Heffalump, the web!
16:09:24 <Heffalump> Smerdyakov: that's just being published without the peer review process...
16:09:40 <Smerdyakov> Heffalump, then pretend I said "published in refereed thingamabobs."
16:09:54 <Heffalump> Binkley: but innovative stuff gets published too, it's just that most research *is* incremental improvement, with the odd big leap
16:10:06 <Heffalump> Smerdyakov: how do you decide what discoveries are worthwhile without peer review?
16:10:07 <kosmikus> well, I've *heard* that there are universities where job applicants for professorships are actually sorted by the number of publications, but I have not experienced that myself yet at the universities I have been, so I guess the actual environment differs quite a bit from country to country, university to university
16:10:10 <Smerdyakov> Though that's what academic folk mean when they say "get published."
16:10:21 <Igloo> I think the publishing system discourages unis from developing software because papers published is an easily computed metric whereas it's much harder to show you are doing worthwhile when developing something
16:10:22 <Smerdyakov> Heffalump, fancy peer-to-peer systems. :)
16:10:44 <Heffalump> i.e. peer review...
16:11:04 <Cale> Oracular review :)
16:11:26 <Smerdyakov> I guess so. Then I guess I don't have a solution to the problem after all. ;)
16:11:40 <Heffalump> I don't think there's a problem, except perhaps for systems development.
16:12:08 <kosmikus> I don't think that it is the main task of universities to develop software.
16:12:31 <Binkley> Yeah, but who's going to do it, then?
16:12:32 <Heffalump> no, but more systems that provide a good research platform for others would be good
16:12:45 <Binkley> Most companies aren't willing to develop open-source software
16:12:54 <Binkley> And people can only do so much in their spare time
16:13:04 <Heffalump> Universities don't exist to develop open-source software.
16:13:25 <kosmikus> Binkley: is Linux developed by a university? or KDE? or GNOME? or Emacs? you could count TeX, I guess ...
16:13:36 <Heffalump> If you want publicly funded OSS development, you should campaign to make it part of public policy
16:13:56 <Binkley> No, but it might be considered to fall under their realm, since it's something useful and beautiful that might not come into being otherwise
16:14:01 <Heffalump> too many papers have "we implemented a half-assed version because we don't have time to put in all the ground-work to do it properly"
16:14:04 <Igloo> I was thinking what it would be like if MS hadn't funded GHC since it left Ed.
16:14:15 <Heffalump> igloo: YM Glasgow?
16:14:17 <Binkley> kosmikus: yes, but maybe all of these things would be unimaginably better with more support...
16:14:19 <Igloo> Yeah
16:14:30 <Heffalump> and presumably it wouldn't have left if they hadn't lured Simon away
16:15:03 <Smerdyakov> Binkley, see http://freedevelopers.net/ when it's available. (It's cached in Google.)
16:15:04 <Heffalump> binkley: but the declared purpose of universities and the public funding they receive is to do research, not develop software
16:15:27 <Igloo> Ah, OK
16:15:39 <Binkley> Smerdyakov: looks interesting
16:16:05 <Binkley> Heffalump: but software gets developed at universities anyway, it's just a question of how covert it is
16:16:11 <kosmikus> yes, if they'd really be there to build software, why don't engineering departments build dvd-players, or physics departments build reactors (well, they do, but not for the electricity)?
16:16:34 <Heffalump> binkley: but as a by-product of research, not an end in itself
16:16:53 <Heffalump> I dunno how Pine development is funded
16:17:21 <Heffalump> (that being the obvious example of software with no clear research rationale that's written at a uni)
16:17:44 <Igloo> Was that written by a CS dept or a computer services?
16:17:52 <Binkley> Pine was originally written for the benefit of the UW community, I think...
16:17:52 <Heffalump> exim is another example, but I know that Philip Hazel works for CU computer services
16:18:04 <Binkley> It was developed by the information services people and not the CS department IIRC
16:18:08 <Smerdyakov> There is a clear need for some non-university entity to develop forward-looking software.
16:18:30 <Heffalump> Smerdyakov: yes, many companies do this
16:18:41 <Heffalump> M$ particularly. You may not like the way it looks forward, though :-)
16:19:09 <kosmikus> forward is relative to where you're standing ...
16:19:44 <Igloo> And in which direction you are facing
16:20:24 <Smerdyakov> Heffalump, I would add that the software should be created with sound methodologies, AKA, no closed source stuff.
16:20:51 <Smerdyakov> Heffalump, and that it should be done in general away from any environment of competition.
16:21:19 <Heffalump> what mechanism would you propose for deciding which directions to pursue?
16:21:58 <Smerdyakov> Public debate
16:22:07 <Heffalump> amongst the entire public?
16:22:48 <Smerdyakov> Potentially, though of course not many would participate.
16:26:04 <kosmikus> good night
16:26:23 <Heffalump> night
16:26:45 <Heffalump> Smerdyakov: do you think taxes should be raised to pay for it, or some other public funding displaced?
16:27:24 <Smerdyakov> I'm not a fan of taxes period. I think it is very easy for people to organize themselves such that all essential needs are met, and then work on projects like this in the remaining time.
16:28:25 <Heffalump> what are "essential needs"?
16:29:10 <Smerdyakov> Food, shelter, and co..
16:29:21 <Heffalump> co?
16:30:05 <Smerdyakov> "and company"... meaning other things that you'd think of as belonging to the same category.
16:30:27 <Heffalump> so basically you're saying we should abandon the principle of specialisation and have everyone spend some time doing public duties (like farming)?
16:30:57 <Heffalump> do you count medical care under essential needs?
16:31:26 <Smerdyakov> I think the principle of specialization should play less of a role in social organization.
16:31:37 <Xcalibor> res
16:32:15 <Smerdyakov> People would still learn specific skills, but perhaps they would learn several, and everyone could chip in a little for the really necessary stuff that doesn't need in-dept knowledge.
16:32:26 <Heffalump> if the system you are suggesting is to be fair, then everyone (not hampered by disabilities etc) would have to spend an equal amount of time on public duties
16:32:58 <Smerdyakov> Maybe, but I don't think that would be much time.
16:33:05 <Heffalump> what about doctors?
16:33:14 <Heffalump> (going back to my question about medical care)
16:33:49 <Smerdyakov> First of all, teaching everyone healthy lifestyle habits removes most modern instances of professional medical care.
16:34:17 <Smerdyakov> After that, medical specialists could still chip in elsewhere as appropriate.
16:34:20 <Heffalump> being a doctor really does require in-depth knowledge, so if you count medical care under essential needs, then either we'll have to train a lot more doctors than we do now, since each will only be spending a little bit of time on public duties
16:34:34 <Heffalump> or we'll have to have some people spending most of their time on them
16:34:43 <Smerdyakov> OK. I mean essential needs that don't require in-depth training to help satisfy.
16:35:07 <Heffalump> so how do you propose to compensate the people who satisfy the essential needs that do require in-depth training to satisfy?
16:35:19 <Heffalump> and I disagree that healthy lifestyle habits would make that much difference
16:35:22 <Smerdyakov> They do less of the other work.
16:35:31 <Heffalump> what other work?
16:35:50 <Smerdyakov> I think you underestimate the central position of unnecessary psychological stress in causing most "modern" ailments.
16:36:02 <Smerdyakov> Other work includes growing food, etc..
16:36:34 <Heffalump> I think you underestimate the success of modern medicine in helping people live long enough for their lifestyle to really matter to their health
16:36:46 <Heffalump> I was already assuming they wouldn't do any of that other work.
16:36:54 <Heffalump> But how much time would they have to do their own thing?
16:37:12 <Smerdyakov> I don't know. Enough.
16:37:32 <Heffalump> so presumably they'd be spending less than the current length of a working week on being doctors?
16:37:43 <Smerdyakov> Since we live in a society with unemployment and very wasteful methods of production, it seems crystal clear that there is room for everyone to relax.
16:37:58 <Smerdyakov> Yes, they would spend less because there would be less demand for their services.
16:38:17 <Heffalump> I disagree with your claim that there would be significantly less demand
16:38:37 <Heffalump> if people fixed their lifestyle, they'd just live longer and have problems that lifestyle improvements couldn't help with.
16:38:41 --- topic: set to '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","lots of cool debs in the haskell-experimental archive - see http://haskell.org/hawiki/DebianUsers","ghc rpms - http://haskell.org/~petersen/rpms/ghc/","new monads tutorial http://www.nomaware.com/monads/html/"]' by Pseudonym
16:39:03 <Heffalump> and it doesn't seem crystal clear to me that there is room for people to relax
16:39:12 <Heffalump> Maybe if we reduced consumption several-fold, yes
16:39:27 <Heffalump> (which may or may not be a good thing; certainly the people used to high consumption wouldn't like it)
16:39:49 <Smerdyakov> Yeah, reducing consumption is in there, too. :)
16:40:26 <Heffalump> ok, so, concretely, what things would society consume less of?
16:41:17 <Pseudonym> One thing that gets me in software development is that closed source software is called "science".
16:41:36 <Pseudonym> If the source code ain't available, the experiment ain't repeatable.  So it ain't science.
16:41:46 <Darius> It is?
16:41:50 <Pseudonym> Oh, yes.
16:42:06 <Heffalump> most of computer science isn't science at all anyway
16:42:06 <Pseudonym> Companies publish stuff about their proprietary products in supposedly scientific journals.
16:42:25 <Pseudonym> Heffalump: Well that's true.  It's kind of a hybrid of science and engineering, without the benefits of either.
16:42:26 <Heffalump> do they describe the methods underlying the software?
16:42:32 <Heffalump> Pseudonym: and maths
16:42:44 * Heffalump thinks the maths bit is quite important :-)
16:42:50 <Pseudonym> Well, yes. :-)
16:42:53 <Pseudonym> Maths is science, though.
16:42:57 <Heffalump> no, it's not
16:43:01 <Pseudonym> I disagree.
16:43:06 <Heffalump> maths is about building abstract models of nothing at all
16:43:10 <Pseudonym> Maths is the science of formal reasoning.
16:43:24 <Heffalump> Maths can't be falsified.
16:43:29 <Pseudonym> Sure it can.
16:43:35 <Smerdyakov> Heffalump, consume less of gadgets. :)
16:43:45 <Smerdyakov> Heffalump, and no printed material allowed!
16:43:45 <Pseudonym> I've seen lots of mathematical paper which are basically refutations of previous "proofs".
16:43:47 <Heffalump> Smerdyakov: and produce less software?
16:43:58 <Pseudonym> Or conjectures.
16:43:58 <Heffalump> Pseudonym: that's fixing errors, not falsifying theories by experiment
16:44:17 <Pseudonym> Ah, now you're shifting the problem.
16:44:28 <Heffalump> scientific theories are grounded in the real world and can be disproved by reference to that real world 
16:44:30 <Pseudonym> If you think science requires "experiment", then yes, maths isn't a science.
16:44:52 <Pseudonym> Well, I disagree with your definition of "science".
16:45:46 <Pseudonym> Unfortunately, DICT is no help here.
16:45:49 <Pseudonym> @wn science
16:45:51 <lambdabot> *** "science" wn "WordNet (r) 1.7"
16:45:51 <lambdabot> science
16:45:51 <lambdabot>      n 1: a particular branch of scientific knowledge; "the science of
16:45:51 <lambdabot>           genetics" [syn: {scientific discipline}]
16:45:52 <lambdabot>      2: ability to produce solutions in some problem domain; "the
16:45:54 <lambdabot>         skill of a well-trained boxer"; "the sweet science of
16:45:56 <lambdabot>         pugilism" [syn: {skill}]
16:45:59 <Pseudonym> Circular reasoning there.
16:46:13 <Heffalump> the other dictionary answers I found don't help either
16:46:27 <syntax-laptop> Heffalump: your definition sounds like Popper's
16:46:32 <Pseudonym> Etymologically, "science" just means "knowledge".
16:46:46 <Pseudonym> Personally, if it's grounded in the physical world, I call that "hard science".
16:47:00 <Pseudonym> Which IMO is a subset of "science".
16:47:16 <Pseudonym> "Hard" in the sense that it deals with things which you can stub your toe on.
16:47:42 <Heffalump> the definition I'm claiming would encompass social science too
16:47:51 <Heffalump> experiments on human populations etc
16:48:02 <Pseudonym> I think that's reasonable.
16:48:37 <Pseudonym> IMO, most "social science" only pays lip service to scientific principles and method (with some notable exceptions), but that's a different issue.
16:48:45 <Heffalump> yeah
16:48:46 <Pseudonym> There's no reason why "social science" isn't science.
16:50:07 <Verbed> Where may I find the source of lambdabot?
16:51:31 <Pseudonym> Verbed: http://sourceforge.net/projects/haskell-libs
16:51:59 <Verbed> Pseudonym: Thanks.
16:53:39 * Heffalump goes to bed
16:53:45 <Pseudonym> Night.
17:45:51 <Xcalibor> ok, g'night and thx!
18:12:04 <Malik> could someone explain "ifthenelse = (\b x y -> ((b x) y))" to me? i dont get it.... b should be a function with the possible results true or false...
18:13:07 <Malik> my book says that ((b x) y) should result in x if b is true and in y if b is false...
18:14:18 <Malik> is b taking x as an argument?
18:16:00 <Malik> perhaps an example would clear my confusion...
18:17:07 <Riastradh> Given these definitions:
18:17:09 <Riastradh> true x y = x
18:17:11 <Riastradh> false x y = y
18:17:32 <Riastradh> If 'b' is 'true', then when you apply it to 'x' and 'y', it will return 'x', i.e. the 'then' branch.
18:17:45 <Riastradh> If 'b' is 'false', then when you apply it to 'x' and 'y, it will return 'y', i.e. the 'else' branch.
18:19:01 <Malik> uhh... now it seems so easy... thank you :)
18:34:16 <Pseudonym> Malik: Dunno if this would help.
18:34:28 <Pseudonym> http://haskell.org/hawiki/DataStructureFreeTransformation
18:35:38 <Darius> A decent introduction to lambda calculus and logic in lambda calculus would probably be better
18:51:27 <Malik> Darius: well, i think my book is decent... i misread some part, because of that i was confused
18:52:56 <Malik> Pseudonym: mhm... i dont really see a connection to my problem... mhm :)
18:53:03 <Pseudonym> :-)
18:53:21 <Pseudonym> Obviously that page isn't about pure lambda calculus.
18:53:34 <Pseudonym> But if you think about the type Bool in Haskell, there are exactly three things you can do with it.
18:53:39 <Pseudonym> 1) Construct True
18:53:44 <Pseudonym> 2) Construct False
18:53:49 <Pseudonym> 3) case expression
18:53:57 <Pseudonym> Everything else boils down to one of these.
18:54:04 <Pseudonym> Including if-then-else.
18:54:20 <Pseudonym> if b then t else e === case b of { True -> t ; False -> e }
18:54:52 <Pseudonym> That means you can transform the type:
18:54:56 <Pseudonym> data Bool = False | True
18:55:03 <Pseudonym> into CPS form
18:56:03 <Pseudonym> newtype Bool = Bool { ifthenelse :: forall a. a -> a -> a }
18:56:16 <Pseudonym> true = Bool $ \t e -> t
18:56:20 <Pseudonym> false = Bool $ \t e -> e
18:56:50 <Malik> i dont really get what you are trying to tell me... im just starting with functional programming, my 'knowledge' ist very advanced so :)
18:56:51 <Pseudonym> Which is pretty much the same as the pure version that you had.
18:56:55 <Pseudonym> Ah, OK.
18:57:08 <Pseudonym> If you don't know much about Haskell, this probably doesn't help you much. :-)
18:57:19 <Malik> yes...
18:57:25 <Malik> thanks for your try...
23:32:08 <Verbed> @yow
23:32:08 <lambdabot> That's a decision that can only be made between you & SY SPERLING!!
