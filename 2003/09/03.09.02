00:00:06 * shapr boings
00:00:09 <shapr> gooood morning #haskell!
00:00:17 <shapr> from the delta to the lambda, it's cold outside!
00:00:31 <andersca> yeah
00:00:32 * shapr horribly misquotes good morning vietnam
00:00:48 <adept> yeah, and rainy as well ...
00:01:00 <shapr> it's sunny and cold where I am
00:01:06 <shapr> am I to the west of you a bit?
00:01:10 <shapr> probably to the north a bit
00:01:19 <shapr> oh, idea for a lambdabot plugin
00:01:33 <shapr> put in two long/lat numbers and get back time offset and distance
00:03:11 <adept> shapr: where you are now?
00:03:26 <shapr> 800km north of stockholm
00:03:31 <shapr> I've forgotten my long/lat
00:03:46 <adept> almost strictly to the north from me :)
00:03:50 <shapr> wow
00:03:52 <shapr> where are you?
00:03:56 <shapr> hej d-bug 
00:05:38 <shapr> Pseudonym: heeey
00:05:45 <adept> Kiev, Ukraine. long/lat? something like 50 24'/30 27' :)
00:05:53 <shapr> Pseudonym: I suspect you would very much enjoy talking to Fritz Ruehr
00:05:58 <d-bug> hej shapr
00:06:12 <shapr> d-bug: god morgon!
00:07:07 <d-bug> shapr: allt bra?
00:07:18 <shapr> bara bra!
00:08:25 * shapr yawns
00:08:58 <earthy> g'maen
00:09:04 <shapr> y0 earthy, wassup?
00:09:29 <earthy> ceiling, floor, ceiling, floor, ceiling, roof, clouds
00:09:44 <shapr> oh, good answer
00:09:48 <earthy> (if my count isn't off by one)
00:11:47 <shapr> I'm sleepy.
00:12:45 <earthy> then go to bed. ;)
00:12:50 <shapr> I just got up!
00:13:39 <earthy> then take a coldish shower. :)
00:15:53 <shapr> I think I'll write some fun code, that's a motivational thing...
00:16:21 <earthy> yeah, that's another way to try waking up... making your mind *have* to
00:16:25 <shapr> right
00:16:52 <shapr> I'd like to try the fp-refactor stuff I saw at ICFP
00:16:55 <shapr> but it's not online yet
00:17:08 <shapr> does anyone know if proxima or programmatica are online?
00:17:26 <earthy> proxima sounds familiar
00:17:35 <shapr> it should :-)
00:17:40 <earthy> programmatica I don't know.
00:18:04 <earthy> well, familiar in the sense `I've seen a download somewhere'. :)
00:18:37 <Lor> Hm, no download links on the programatica home page...
00:18:41 <shapr> aren't you at uu?
00:18:56 <earthy> ah, I was mistaken. :)
00:19:03 <earthy> `ask martijn schrage' :)
00:19:07 <earthy> shapr: yeah, I am.
00:19:15 <shapr> proxima is there also
00:19:16 <earthy> I'm unsure if it's in the uu cvs. ;)
00:20:41 <shapr> it sort of sucks that three of the demos I saw at ICFP don't have released code online.
00:22:03 <shapr> gutentag pseiko
00:24:14 <earthy> well, yeah, I really should kick people over the head here concerning release management.
00:24:24 <earthy> most of 'm suck badly at it.
00:26:24 * shapr yawns
00:26:26 * shapr drinks coffee
00:26:34 * andersca too
00:32:15 <shapr> whee
00:32:34 <shapr> ah, this requires wxHaskell
00:33:09 <earthy> oh right, that was one of the projects I was working on... getting wxHaskell to work under slowaris.
00:33:45 <shapr> does wxWindows work on solaris?
00:33:50 <earthy> yes
00:34:22 <earthy> but Daan was just going away for his holidays when I started, and I was going to Marktoberdorf a few days later
00:34:43 <earthy> so I kinda put the project in the freezer
00:35:10 <shapr> gutentag apmuf 
00:35:35 <shapr> I had fun drinking beer with Daan.
00:35:38 <shapr> he's entertaining.
00:35:45 <earthy> yeah, he is. :)
00:36:10 <earthy> and he lives as far from Utrecht as I do (or even farther), but in the exact opposite direction. ;)
00:36:49 <shapr> grr, sf.net cvs suxors
00:37:20 * shapr grabs the release
00:41:25 <pseiko> hello shapr and all
00:41:31 <shapr> hiya pseiko
00:45:04 <earthy> hi
00:45:10 <pseiko> i have a question about this journal of functional programming 
00:45:14 <pseiko> i have a question about this journal of functional programming
00:45:30 <shapr> ?
00:45:36 <pseiko> ups
00:45:46 <pseiko> http://titles.cambridge.org/journals/journal_pricing.asp?mnemonic=JFP
00:45:49 <Lor> Yes?
00:45:58 <pseiko> the price seems to be 114$
00:46:19 <pseiko> is this right? do you read this journal?
00:46:28 <pseiko> is it worth such a price?
00:46:32 <Lor> Yes. I subscribe it. Yes, it's bloody expensive.
00:46:51 <Lor> Write to the editors and ask nicely, and they might send you a review copy.
00:46:53 <Lor> They sent me. :)
00:47:03 <shapr> I'd like to subscribe to it also
00:47:09 <shapr> but $114 is a bit much.
00:47:14 <Lor> So join ACM:
00:47:17 <shapr> actually, I thought it was more than that?
00:47:40 <pseiko> hmm, i live in germany, maybe there will be additional costs for shipment
00:47:44 <Lor> If you want print versions of FP papers, you definitely want to join ACM and SIGPLAN.
00:47:53 <Lor> pseiko, nope.
00:47:57 <Lor> That's an international price.
00:48:06 <pseiko> aha
00:48:17 <pseiko> and this is for one year?
00:48:30 <Lor> In SIGPLAN Notices you get the proceedings of POPL, PLDI, ICFP and OOPSLA. And some smaller ones.
00:48:41 <Lor> Yes, one year. Six issues.
00:48:54 <pseiko> hmmm, and is there a discount for students?
00:49:08 <pseiko> what is this sigplan thing?
00:49:09 <Lor> Yes, for joining ACM. :)
00:49:26 <Lor> This year's first five issues of JFP total 959 pages.
00:49:47 <Lor> On the other hand, last year there were only five issues with a total of 624 pages.
00:50:06 <pseiko> but the price is constant, isn't it?
00:50:22 <Lor> It was £50 last year, now it's £56.
00:51:00 <pseiko> oh, i just saw the special prices for acm, its 24$ less
00:51:16 <Lor> I'm not sure if it's worth an individual subscription _if_ you can find it from a library nearby.
00:51:48 <pseiko> the articles seem not to be freely available at the net
00:51:51 <Lor> But AFAIK, there's only one institution in Finland that subscribes JFP, and that's 200km away, so I was pretty much forced to get it for myself.
00:52:03 <Lor> pseiko, actually you can find many of them from the authors' homepages.
00:52:10 <Lor> (Or via citeseer)
00:52:20 <shapr> sounds like we need a research paper 'zine
00:52:26 <shapr> something that gives pointers to all the cool papers
00:52:46 <pseiko> hmm, what about the layout? is it suitable for the bookshelf?
00:52:54 <Lor> http://library.readscheme.org/
00:54:23 <Lor> About 25 cm high.
00:56:57 <pseiko> you said, that it is possible, to get a review copy, can you provide the appropriate contact, please?
00:57:41 <Lor> pseiko, there is that "sample issue" link on the web page.
00:58:20 <pseiko> error scripts/jnlsorderuk.asp was not found??
00:58:29 <earthy> only one institution in finland that subscribes to jfp? that sucsk.
00:58:55 <Lor> To my knowledge, yes.
00:59:12 <Lor> This is not a very good place to be interested in programming languages.
00:59:30 <earthy> indeed it doesn't seem to be
01:00:39 <shapr> Lor: come to sweden! or go to the US!
01:01:07 <earthy> don't go to the US
01:01:12 <Lor> pseiko, hm. write to the editorial assistant, Nasreen Ahmad <nasreen@dcs.glasgow.ac.uk>.
01:01:18 <shapr> I actually like the US.
01:01:24 <Lor> Oops. This gets logged to the web?
01:01:33 <earthy> lor: unfortunately, yes. ;)
01:01:48 <earthy> /msg is your friend. :)
01:02:06 <Lor> Well yeah, I've been thinking about going to chalmers for grad studies.
01:02:12 <Lor> We shall see.
01:02:28 <earthy> shapr: I've got something against the US policies in dealing with foreigners
01:02:53 <pseiko> thank you Lor
01:03:33 <shapr> earthy: oh, so do I
01:03:40 <earthy> such as keeping the parents of a german grad student doing his PhD in the US in custody for 24 hours before putting them back on the plane to germany even though they had done *nothing* whatsoever wrong *and* the mother needs regular medication (which she wasn't given during that time)
01:03:56 <Lor> pseiko, or you could write to Wadler or SPJ, they are the editors-in-chief after all.
01:04:14 <shapr> earthy: I agree, US foreign policy sucks in general and in specific
01:04:56 <earthy> stuff like this makes me warn anyone planning to go to the US. :)
01:05:21 <earthy> (there are benefits, such as great CS groups and stuff as well, but you *have* to weigh the detractions)
01:05:26 <shapr> I wonder if I'm atypical
01:05:36 <shapr> for a US citizen, that is.
01:06:02 <earthy> I'm not talking about US citizens... :) I know a lot of 'm I really like. :)
01:06:06 <Darius> shapr: you are atypical in general
01:06:21 <shapr> Darius: I'll take that as a compliment :-)
01:06:49 * shapr bounces cheerfully
01:11:43 <pseiko> ok, thank you for all the information, I have asked for a free copy, maybe it succeeds, bye and see you :-)
01:22:49 <shapr> I must repeat how much I'd like to have an optional trailing comma in lists.
01:25:21 <earthy> why's that?
01:26:11 <shapr> because I have to treat one end of a list as a special case when editing Haskell sources.
01:26:34 <shapr> either I can use "item", and special case the last, or ,"item" and special case the first
01:26:37 <shapr> that bugs me.
01:27:08 <Darius> Yeah, that's why I have list_ender tests in the EvalModule test suite.
01:27:18 <shapr> in Python, putting a comma after the last item in your list is defensive programming, just in case you stick in a new item and don't notice
01:27:20 <Darius> Of course, I just forget the comma then ;)
01:27:36 <shapr> what does the list_ender test do?
01:27:37 <earthy> or you use list: "[", elements, "]".   elements: item; item, "," elements.
01:27:37 * shapr looks
01:27:45 <Darius> It always succeeds
01:27:47 <earthy> is using a grammar *that* hard?
01:27:58 <shapr> earthy: eh?
01:28:09 <earthy> sorry, Van Wijngaarden notation.
01:28:27 <earthy> list = '[' elements ']'
01:28:39 <earthy> elements = item | item ',' elements
01:28:48 <earthy> (if you prefer BNF)
01:29:01 <shapr> I just want an optional comma after the last item
01:29:06 <earthy> *why*? :)
01:29:18 <shapr> because it gives me a more regular syntax.
01:29:21 <Darius> So you can rearrange a vertically formatted list easily
01:29:31 <shapr> then there's only one rule for each line in a list
01:29:35 <shapr> yes, what Darius said.
01:29:50 <earthy> *ah*
01:29:56 <earthy> okay, understood.
01:30:46 <ibid> long lists are often best formatted vertically, and then the missing last comma breaks the pattern
01:31:04 <ibid> which is not so nice if you decide to add stuff to it later
01:31:07 <shapr> right
01:31:09 <shapr> exactly
01:31:18 <shapr> so many Haskellers special case the first line
01:31:32 <ibid> ahh, in the data pattern :)
01:31:37 <shapr> but then you have the same problem if you decide to add to the front of the list, though that is admittedly less common.
01:31:43 <ibid> true
01:32:18 <ibid> note that (iirc) C99 added trailing comma support to enums for much the same reason
01:32:35 <Darius> It added that?  I thought that had been the norm.
01:32:46 <Darius> Or is/was it for C++?
01:33:53 <ibid> i *think* it was added, but i am not sure
01:34:00 <Lor> gcc did support it previously, but it wasn't standard.
01:34:41 <Lor> Hi, ibid.
01:36:24 <ibid> hi
01:36:44 <ibid> Lor: my fp course starts next monday here :)
01:36:59 <Lor> Cool. What are you using?
01:37:07 <ibid> ähh, hyppään bussiin, bbl
01:37:33 <Lor> Jeps, moi.
01:40:15 * earthy looks through the GHC6 parser
01:40:45 * shapr plays with System.Random
01:40:45 <earthy> at least it is consistently absent, the optional comma at the end. ;)
01:40:46 <ibid> bah, missed the bus
01:41:01 * shapr writes a word game plugin for lambdabot
01:41:37 <earthy> it'd add quite a few shift-reduce conflicts to the grammar though.
01:41:53 <shapr> how so?
01:41:53 <earthy> afaict
01:42:01 <earthy> comma_types1    :: { [RdrNameHsType] }
01:42:01 <earthy>         : type                          { [$1] }
01:42:01 <earthy>         | type  ',' comma_types1        { $1 : $3 }
01:42:07 <ibid> Lor: i'm combining bird, backus and thompson :)
01:42:09 <earthy> now, add 
01:42:19 <shapr> gutentag noshadow
01:42:24 <Lor> ibid, all right, so Haskell.
01:42:29 <Lor> Are you using Helium? :)
01:42:31 <shapr> wie geht es?
01:42:35 <earthy>         | type ','                          { [$1] }
01:42:49 <shapr> isn't Peter Thiemann an uni-freiburg?
01:42:54 <shapr> s/an/at
01:43:06 <earthy> shpar: then *within* that rule you get a shift-reduce conflict.
01:43:13 <ibid> Lor: not as long as it does not support "textbook haskell"
01:43:16 <noshadow> shapr: Yes, I think so.
01:43:32 <Lor> ibid, do you _want_ type classes for a basic course?
01:43:38 <shapr> he wrote a nifty web framework for Haskell.
01:43:41 <earthy> it's not serious, but it's not real nice either.
01:43:54 <noshadow> shapr: Don't remember me of that. That's the most ugly code I've ever seen...
01:44:02 <shapr> noshadow: you've used WASH?
01:44:09 <ibid> Lor: haskell, and a lot of chalk-and-backboard / pen-and-paper stuff
01:44:24 <Darius> Why would you add it within?  Wouldn't you add an optional comma at a higher level? Just an optional comma at the end of the list.
01:44:49 <earthy> darius: that makes it worse. :)
01:44:50 <noshadow> shapr: I've tried to. His lecture was ununderstandable. Only way to understand WASH is to read his paper how he developed it.
01:45:08 * noshadow doesn't like things one cannot understand without their history...
01:45:11 <earthy> b'sides, you *can't* just put it at the end of the list, since there's quite a few places in the grammar that you'd have to add it.
01:45:15 <Lor> ibid, do you have any idea how to get some proper programming language research started in Finland?
01:45:20 <shapr> hm, I heard him talk at ICFP, his talk was understandable.
01:45:48 <noshadow> shapr: I don't talk about him in general. But how he tries to teach studends wash...
01:45:53 <earthy> noshadow: we're talking about the feasibility of adding an optional final comma to all commaseparated lists in the haskell syntax.
01:45:58 <ibid> Lor: i hope to be able to go beyond basic :) but no, not necessarily the full power of type classes - i think i read they promised something in-between for this summer
01:46:31 <ibid> Lor: by teaching people about popl and by doing research ourselves
01:46:39 <shapr> I used WASH a bit some months ago, maybe I didn't try the advanced features?
01:46:43 <shapr> noshadow: where did you have trouble?
01:46:46 <earthy> Lor: exactly. *do* it. :)
01:46:48 <ibid> Lor: my current main research area is formal methods, though
01:47:04 <shapr> my research is informal methods
01:47:09 <shapr> (aka hack on it till it works)
01:47:17 <noshadow> shapr: He tried the "monads are backround, you do not have to understand them" approach...
01:47:40 <shapr> noshadow: that seems to work in Hudak's SOE book.
01:47:52 <earthy> shapr: trial and error, also known as. :)
01:48:01 <shapr> noshadow: most OO programmers don't really understand Objects for example :-)
01:48:03 <ibid> Lor: but i am following popl stuff and i have some ideas i want to try some day :)
01:48:03 <shapr> they just use them
01:48:22 <shapr> noshadow: I'd like to hear more
01:48:29 <noshadow> shapr: And he tried to make the people use to high-level interface of WASH, without telling what the lower are and why the higher work.
01:48:31 <ibid> noshadow: well, some fp people treat monads that way. successfully :)
01:48:34 <shapr> I just recently decided that monads are background myself
01:49:01 <noshadow> shapr: I've not heared of anyone unstanding something in that lecture due to the lecture...
01:49:10 <earthy> monads aren't hard if you don't think about them too much
01:49:11 <shapr> hm
01:49:37 <Lor> I was at ICFP and I was just jealous at all these young people who were researching interesting stuff in a real research group under real authorities...
01:49:41 <shapr> sounds like a research opportunity.
01:49:44 <earthy> and once you understand category theory I gather monads just *klick*
01:49:50 <shapr> Lor: on the downside, they can't change their minds easily
01:50:08 <shapr> for example, I got bored of Python and switched to Haskell, and no one minded.
01:50:17 <ibid> Lor: yeah, well, you have two options: either go to the research groups yourself or do stuff on your own
01:50:19 <noshadow> earthy: Monads are easy, if you explain them. No need for category theory or model theroy...
01:50:32 <shapr> noshadow: that doesn't seem to be true in my experience :-)
01:50:38 <shapr> noshadow: feel free to explain monads to me though :-)
01:50:48 <ibid> Lor: research groups grow around profilic researchers. you could become one, you know :)
01:50:52 <shapr> Lor: let's start the independent researchers group :-)
01:51:17 <noshadow> shapr: Perhaps I come to much from the mathematics side, but handling something one does not elementary understand is just pain...
01:51:44 <shapr> noshadow: I would argue that I can't understand my computer totally, I don't have enough time.
01:51:47 <earthy> noshadow: I have trouble understanding most explanations of monads, if I think about them too hard.
01:52:04 <Lor> Well actually, my problem isn't the research, it's the lack of a real authority to whom one could turn on hairy issues. Since there are no real authorities in Finland.
01:52:17 <shapr> for example, I recently screwed up my soundcard while playing with ALSA settings, but I haven't had time to research the 59 different silders I get for the emu10k chip
01:52:23 <ibid> Lor: here at jyväskylä, we have very little tradition in SE research, so i and a couple of other guys here are just doing stuff on our own (well, you could call us a research group, if you are high:)
01:52:25 <shapr> s/silders/sliders
01:52:28 <earthy> Lor: then find someone who would be willing to guide you from a distance.
01:52:40 <ibid> Lor: and hope that we will in time become a real RG:)
01:52:43 <shapr> Lor: or hang out here, there is much knowledge on this channel.
01:52:49 <noshadow> earthy: I don't tell people have to go very deep, but one should tell the the basics of a monad. And not only "put a CGI in front of the type and then put strange symbols between your elements"
01:52:51 <shapr> for example, look at ibid 
01:53:13 <earthy> noshadow: okay, obviously that wouldn't work. you have to bind and return.
01:53:24 <earthy> and know roughly what that does
01:53:38 <ibid> Lor: 1) science is not authority based :) 2) science is international. you were at ICFP, contact some of the people you met there and establish relations :)
01:53:50 <ibid> shapr: i'm just masquerading here :)
01:53:51 <noshadow> earthy: which can be hidden in other strange symbols, and people be told to use this or that symbol. (I already said I hate this approach?)
01:53:57 <Lor> Yeah, I intend to, the moment I get a bit of free time. :)
01:54:46 <shapr> noshadow: well, if you want to use WASH again, I'd be happy to teach you everything I know :-)
01:54:55 <ibid> no, actually i just tell myself that i am not less, though i may know less - and i go here and tell what i know and ask what i don't :)
01:55:05 <shapr> yah, same for me
01:55:17 <Lor> All right. Can anyone explain how Scott models really work?
01:55:31 <shapr> never heard of 'em, what are they?
01:55:38 <ibid> so, i am arrogant - and that's a feature, not a bug :)
01:55:44 <shapr> heh
01:55:51 <noshadow> BTW, if someone wants to do research and does not know what to do, I'd really like to see a nicer class-structure in haskell. Having to invent operators like *** or times, because * is in Num and is not suitible for vector spaces or modules is really a pain.
01:55:53 <Lor> The standard semantic model for untyped lambda calculus.
01:55:57 <ibid> Lor: i know some scott domain stuff but not much else
01:56:04 <shapr> ibid: do you think John Hughes is arrowgant?
01:56:08 * shapr cackles evilly
01:56:13 <Lor> "Model" here meaning an interpretation of lambda terms as "mathematical objects".
01:56:24 <ibid> Lor: read my popl lecture notes from last autumn?
01:56:34 <earthy> ugh, that'd involve some digging. I *did* know how Scott models work...
01:56:34 <shapr> noshadow: you don't have to do that
01:56:38 <ibid> another bus is coming, bbl (30 min)
01:56:46 <shapr> noshadow: you can use fundeps to get * on vectors
01:56:47 <Lor> And mathematical objects being defined as something unknowable that is nevertheless axiomatized in ZFC.
01:56:55 <earthy> but that was like 6 years ago. ;)
01:57:07 <shapr> noshadow: lemme get you an url....
01:57:19 <ibid> Lor: i know some stuff and i could explain what i know, but whether it is official, i have no clue :)
01:57:22 <ibid> anyway, bbl
01:57:45 <shapr> noshadow: http://www.haskell.org/hawiki/FunDeps
01:57:56 <noshadow> another nice thing would be to make something like [(Bla,Blun)] an instance of a newly defined class.
01:58:13 <shapr> noshadow: have you seen the instance wrappers?
01:58:32 <shapr> basically, if you make (Bla,Blun) an instance, I think you can derive the list
01:58:50 <RibRib> hello
01:58:55 <shapr> hi RibRib 
01:58:58 <noshadow> shapr: but if the objects are not instances?
01:59:11 <shapr> noshadow: I think you can still do it.
01:59:12 * shapr checks
02:03:34 <noshadow> shapr: This fundeps might be a way to implement such nice classes. But what I'm searching is a nice class-hirachy to do mathematics. I've not the time to do this myself...
02:04:01 <Lor> Fundeps seem to be used more and more as a hack when dependent types are what's really wanted.
02:04:22 <shapr> noshadow: you could ask on the haskell mailing list, someone may have already written something like that.
02:05:07 <Darius> Look at DoCon
02:06:59 <Lor> Eeekk! Helium compilation ended with an error!
02:07:09 <Darius> http://haskell.cs.yale.edu/docon/ and the basic algebra proposal ftp://ftp.botik.ru/pub/local/Mechveliani/basAlgPropos/
02:07:11 <Lor> Hm, some weird template haskell stuff...
02:07:23 <shapr> bah, I have to work, and #haskell is far too interesting. bbl
02:09:22 <Lor> Ah. It's got ($x) where ($ x) is meant, and template haskell breaks that...
02:10:09 <Lor> Hm, was there really no sensible syntax for templates that _wouldn't_ have broken existing code?
02:13:00 <noshadow> Darius: thanks this /basAlgPropos looks nice. (Though this licence-text, argl...)
02:23:48 <Lor> Ugh, it takes a couple of seconds to evaluate "1" in helium.
02:26:34 <Darius> In Hint?
02:26:48 <Lor> Yeah.
02:27:05 <ibid> Lor: i mean, i know it makes sense, but whether it's the official word... :)
02:27:41 <Darius> Might just be Java ;).  DrScheme is painfully slow on my computer.
02:28:12 <kosmikus> Lor: that's because Helium *compiles* each input program
02:28:23 <Lor> Yeah, thought so.
02:28:39 <Lor> But still. It doesn't do particularly heavy optimization.
02:28:53 <Lor> And it only compiles to some sort of bytecode, IIUC.
02:28:56 <kosmikus> No. That's not what it has been designed for.
02:29:04 <Darius> It's rather hard to optimize "1" ;)
02:29:11 <xkb_> 0
02:29:20 <Lor> So there's a huge bottleneck _somewhere_ in there.
02:29:36 <kosmikus> Still, it is much faster than Hugs in evaluation.
02:30:16 <Lor> Oh no it isn't.
02:30:21 <Lor> At least for simple expressions.
02:30:24 <Lor> Hugs answers immediately.
02:30:46 <kosmikus> I mean: the real evaluation is faster. You just have a near constant overhead due to the compiler invocation.
02:31:16 <Lor> All right, granted, but that doesn't seem like a sensible tradeoff for an educational system.
02:31:39 <Lor> Even ghci has better latency than textview.
02:32:01 <kosmikus> hmm, on my machine 1 evaluates in less than 1 second
02:32:27 <Lor> Part of the reason might be that textview invokes the compiler and the bytecode interpreter both as separate processes, so you get the initialization costs of _two_ ghc runtimes at every evaluation.
02:32:33 <kosmikus> and you can always try texthint if you don't like java -- actually, that's what I use
02:32:34 <Lor> Well, I have a K6-2/450.
02:32:46 <Lor> Nono, texthint is what I mean.
02:34:27 <kosmikus> I think that in the next release Hint will be integrated with Helium (it has been rewritten in Haskell using wxHaskell already), so only the runtime, not the compiler has to be called externally.
02:35:58 <kosmikus> Lor: strange that it takes so long for you -- texthint has an even faster feeling on my machine, certainly less than .5 seconds
02:36:10 <Lor> What machine do you have?
02:36:49 <kosmikus> have to check :)
02:37:19 <kosmikus> okay, it's faster than I thought it is ... Pentium 4/2.53GHz
02:37:26 <Lor> Well yeah. :)
02:37:28 <Darius> It is rather sluggish on my computer (I'd say more like half a second in the GUI Hint)
02:37:35 <Darius> I have a K6 400
02:40:28 <kosmikus> all I can say is that it will probably be optimized a bit, but efficiency is probably not the main design goal as machines get faster all the time and it seemed to work fine on our student machines
02:40:41 <kosmikus> but I can tell the developers ...
02:42:58 <Lor> It just smells like needlessly inefficient design.
02:44:06 <RibRib> hello
02:44:16 <RibRib> i need help with the logic of a question
02:44:39 <Lor> Shoot.
02:44:40 <RibRib> when we look at numbers, is this true
02:44:41 <RibRib> ?
02:44:43 <RibRib> if first number is smaller than second then = first number multiply the rest of numbers
02:44:43 <RibRib> if first number is larger than second then = first number add the rest of numbers
02:44:53 <RibRib> a number like 202
02:44:59 <RibRib> i mean in words
02:45:02 <RibRib> "two hundred two"
02:45:24 <Lor> Uh, what?
02:45:34 <Lor> Are you talking about digits?
02:45:51 <RibRib> no, i mean numbers as strings
02:46:00 <RibRib> eg "two hundred two"
02:46:19 <Lor> I don't understand at all what you are asking.
02:46:43 <RibRib> how do you know "two hundred two" = 202
02:47:03 <adept> whats "first number' and whats "second number" when we talk about 202?
02:47:16 <adept> and what is "rest of numbers" ?
02:47:18 <RibRib> first word i mean
02:47:28 <RibRib> first = head of string
02:47:30 <adept> just take 202 and tell us
02:47:33 <Lor> So you want to interpret strings where the number is written verbally?
02:47:54 <RibRib> first word = two
02:48:00 <adept> nope
02:48:02 <RibRib> 2nd word = hundred ...etc
02:48:04 <adept> first numer
02:48:15 <adept> you was talking about numbers
02:48:24 <RibRib> i meant word
02:48:37 <Darius> This homework assignment? http://haskell.org/pipermail/haskell/2003-August/012455.html
02:48:38 <Lor> ribrib, please try to express your problem again, this time using complete english sentences.
02:49:33 <RibRib> yeh its for my assignment, just discussing, not like im asking u guys to help me write it
02:49:44 <RibRib> i want to understand the problem
02:51:15 <RibRib> that was the example of "dont do's" 
02:51:25 <RibRib> my lecturer posted up
02:51:27 <RibRib> :)
02:52:33 <Lor> You have to keep in mind, though, that the principle breaks at illions.
02:52:52 <Lor> Actually, it doesn't.
02:53:13 <Lor> So yeah, your approach ought to work fairly well.
02:54:19 <semaj> the question is to convert any guiven integer in a string, right ????
02:54:32 <Lor> The other way, I think.
02:54:34 <xkb> Isnt it the other way around?
02:54:37 <xkb> ah to slow
02:54:38 <xkb> :D
02:54:51 <RibRib> my method doesnt work
02:55:03 <semaj> i have not read the site ....
02:55:15 <semaj> i was deducting from your conversation
02:55:42 <semaj> a string into a integer then
02:55:44 <RibRib> if following my method = 2 * (100+2)
02:55:53 <RibRib> which doesnt equal to 202
02:55:56 <Lor> You have to fold left, not right. :)
02:56:50 <Lor> Essentially, you have to accumulate _two_ values, when traversing the word list. The already parsed "big numbers" (their sum), and the "current" number that the next word might multiply.
02:56:57 <RibRib> ive only created functions for first and second words of strings, will i need a function for the third string?
02:57:28 <Lor> Your function ought to be able to handle arbitrary lengths.
02:58:20 <RibRib> i also made a function to reverse the list
02:58:23 <Lor> I think you could do the problem with one function and one table.
02:58:37 <Lor> If you want to go from the end to the beginning, then you need a slightly different approach.
02:58:45 <Lor> I think it's easier to go from the beginning to the end.
02:59:58 <RibRib> tables...
03:00:08 <RibRib> ill hav to look in to that...
03:00:18 <Lor> An association list is probably the easist way, ie. a list of pairs.
03:00:34 <Lor> Since you of course want to associate each word with a numeric value.
03:00:41 <Darius> There is a relatively simple algorithm to calculate the values once you convert the string into a list of numbers.
03:01:01 <Lor> Ah, wth, I'll implement it.
03:01:33 * Darius did when the mailinglist post came up. It was about 10 lines of Haskell (hard to tell it was in GHCi)
03:02:12 <RibRib> ive already converted my string into numbers...its the algorithm im having problems with
03:02:50 <RibRib> Darius did you really think that post is real?
03:03:04 <RibRib> my lecturer posted it up
03:04:36 <Darius> There were a lot of things odd about it.
03:05:06 <RibRib> what do you mean?
03:05:46 <Darius> The email address, the subject, and, well... the (apparent) gender.
03:06:03 <Darius> I actually deleted (before reading) the first message as I thought it was spam.
03:10:18 <RibRib> ahh this is so pointless...
03:11:05 <Darius> Actually I was thinking of saving the code, it might be nice some time.  But typically entering numerals is easier and more compact.
03:11:35 <RibRib> so i need a table for this?
03:12:01 <Darius> You need some kind of mapping thing as I mentioned in my reply to the post.
03:15:14 <semaj> foldl (\x y -> (ord y - ord '0') + (x*10) ) 0 "4500"
03:15:38 <Darius> if you were doing that, then just read "4500"
03:15:47 <semaj> sorry for leaving the conversation, i was sleeinh
03:15:56 <semaj> its just a solution top of the hat
03:16:23 <semaj> that function convertes any string composed by numbers (no error detection) into a integer
03:16:33 <semaj> i supose thats what you whant right
03:16:46 <semaj> (\n -> foldl (\x y -> (ord y - ord '0') + (x*10) ) 0 n) 
03:17:18 <semaj> if you prefer this notation, you can put any string composed only by number at the end for conversion :)
03:17:24 <semaj> i hope i helped
03:17:44 <RibRib> the mapping thing... is that for converting string into integer? 
03:18:06 <RibRib> cos i've already done the conversion... just the operations im having problems with
03:18:11 <semaj> sorry is that for me
03:18:23 <RibRib> i know :)
03:18:37 <semaj> sorry i am kind of new to this all
03:18:38 <RibRib> i mean what Darius was talkin abt b4
03:18:59 <semaj> ho :)
03:19:28 <semaj> well the solution that i provided is very simple strate forward and it works 
03:19:50 <semaj> lacks only some error detection by option, like i said top of the hat
03:20:53 <semaj> if you need any alteration or explanation to it please say, but i think that a simple solution like this is all that is needed :)
03:21:39 <semaj> hope i am not disturbing :)
03:21:42 <Darius> semaj: it's a solution to the wrong problem, also 'read' is a simpler solution.
03:22:56 <semaj> but was not the problem to convert a string in a  integer
03:23:26 <Darius> It was to convert a string such as "two hundred two" into an integer
03:23:44 <semaj> and basicly what i have done is the declaration in the the class read, so read may seem simpler but it is not
03:23:55 <RibRib> i cant get the algorithm!
03:23:57 <Darius> It's simpler to use
03:24:08 <semaj> at least in my humild opinion
03:24:33 <semaj> should i consider case_sensitive
03:25:00 <RibRib> hey Darius, do i need association list even if i know how to convert string to integer?
03:25:02 <Lor> Hum, my solution is essentially four lines plus the table.
03:26:30 <RibRib> i hav >80 lines
03:26:35 <semaj> still i find funny this kind of question, so i leave to you, and stay with mine not-to-this-problem-solution
03:26:41 <semaj> :)
03:27:45 <RibRib> can someone explain it to me :)
03:28:00 <RibRib> the algorithm
03:28:52 <Lor> ribrib, you stated it yourself
03:29:16 <RibRib> ok ...
03:29:24 <RibRib> how do i overcome my problem...
03:29:33 <Lor> Oops, my algorithm doesn't work. :)
03:29:36 <RibRib> if following my method = 2 * (100+2)
03:30:23 <Lor> If following your method, you first get two, then you see hundred, which is bigger, so you multiply two by hundred, then you see two, which is smaller, so you just add it.
03:30:26 <Darius> Yeah, it took me like two or three tries to get the algorithm right.
03:30:30 <Lor> Remember to traverse from the beginning.
03:31:06 <Lor> My solution breaks at thousands.
03:31:24 <Darius> You didn't even test above thousands?
03:31:42 <Darius> It's supposed to handle billions
03:32:04 <RibRib> how do i  tell the program to complete the mulplication before addition?
03:32:37 <Lor> Actually, I'd prefer to write a real parser for this thing, even though that's a bit of overkill. :)
03:33:02 <Darius> Lor: what do you need a parser for?
03:33:56 <Lor> Well, this _is_ a parsing problem, after all.
03:34:31 <Darius> Not once it's parsed.  The algorithm is more or less the same no matter when you turn the strings into integers.
03:35:02 <Lor> Yes, reading numbers is also a parsing problem. :)
03:35:33 <semaj> dont forget primMaxInt :)
03:36:30 <RibRib> :(
03:36:31 <Lor> Yick, it will get bigger than four lines.
03:38:11 <Darius> There are only two parsing errors that can be made.  1) A word isn't a number word "two dog two" and 2) things like "three three"
03:38:33 <Darius> The first is handled for free, and the second is no easier to solve on strings.
03:38:42 <RibRib> the "three three" is acceptable
03:39:00 <RibRib> do you want to see the site for the assignment?
03:39:09 <Lor> Parsing is not only recognizing a sentence but also generating the right kind of syntax tree.
03:40:50 <Darius> And in this case finding out the right "syntax tree" seems easier to do using the numbers than the strings.
03:41:20 <Lor> Well, the distinction is fairly trivial, in English.
03:42:12 <RibRib> can you help me write one line
03:42:28 <Lor> ...which is a thousand columns wide? :)
03:42:50 <RibRib> one line for "two hundred two"
03:43:12 <RibRib> with functions first and rest
03:43:26 <Lor> Uh, what?
03:43:43 <Darius> first and rest aren't (standard) Haskell functions.
03:44:03 <RibRib> oh we're allowed to create functions
03:44:17 <RibRib> and i've already created them
03:44:51 <RibRib> first "two hundred two" = two
03:44:51 <Darius> What do they do?
03:44:51 <RibRib> i mean 2
03:45:28 <RibRib> can i send you my file?
03:48:37 <Darius> If 'you' is Lor then sure ;)  I'm trying to gain the intuition about coexponentials that I thought I had.
03:49:13 <RibRib> :(
03:50:44 <RibRib> Lor want to see?
03:51:18 <RibRib> |(nlp (fw x))<(nlp(sw x))= (nlp (fw x))*(nlp (rw x))
03:51:18 <RibRib> 	|(nlp (fw x))<100 && (nlp (sw x))>=100 = (nlp (fw x))*(nlp (rw x))
03:51:18 <RibRib> 	|(nlp (fw x))>=100 && (nlp (sw x))>=100= (nlp (fw x))*(nlp (rw x))
03:51:18 <RibRib> 	|(nlp (fw x))>(nlp (sw x))=(nlp (fw x))+ (nlp (rw x))
03:51:40 <Lor> There is something very very wrong with that code.
03:51:53 <RibRib> fw = first word, sw = 2nd word, rw = rest of the words
03:52:08 <RibRib> nlp is the function that converts string to numbers
03:52:19 <Lor> Forget about hard-coded built-in integers. They're a sign that there's something fundamentally wrong.
03:52:20 <RibRib> i know its messy 
03:54:32 <RibRib> too messy?
03:54:52 <RibRib> i should add guards?
03:54:59 <Lor> Nonono.
03:55:29 <Lor> Try to generalize the problem, forget about hundreds and think about billions.
03:55:52 <Lor> Try to solve the problem so that it's trivial to add support for vigintillions.
03:57:33 <RibRib> if you think about it
03:58:13 <kosmikus> has anyone here tried to build ghc from cvs within the last two weeks or so?
03:58:17 <RibRib> when you hav a number <100  and a number >100 that means you multiply them
03:59:15 <Lor> Nonono.
03:59:26 <Lor> Forget about specific numbers.
03:59:29 <RibRib> i dont hav to worry about that?
03:59:38 <Lor> Think about the general principle behind it.
04:00:09 <RibRib> as you can see i hav no idea abt the principle behind this
04:00:25 <RibRib> so what i had before is right
04:00:57 <Lor> Well, not quite.
04:01:21 <Lor> "four thousand four hundred four", now, when you encounter the second four, what do you do?
04:02:18 <RibRib> multiply it to the hundred
04:02:44 <Lor> How do you know, when you haven't seen the "hundred" yet?
04:03:01 <Lor> Or do you mean to traverse the words backwards?
04:03:31 <RibRib> 4 multiplying the remaining?
04:04:06 <Lor> That would result in 416, wouldn't it?
04:04:26 <RibRib> ok.. so what should i do?
04:04:38 <RibRib> thats where im stuck at
04:04:51 <Lor> That is the question. I'm in a slow mood, so I haven't figured out a pretty solution. An ugly one is easy, though.
04:05:50 <RibRib> 4 multiply the next number?
04:06:29 <Lor> Possibly, depending on how you do it.
04:32:24 <RibRib> Lor still here?
04:33:37 <Lor> Yes, but just now going to get some food. bbl.
04:35:48 <RibRib> this is so gay
05:13:39 <RibRib> anyone here?
05:35:19 <Lunar^> Damn... why isn't block defined on MonadIO ?
05:38:23 <RibRib> can you help me with something
05:42:03 <Lunar^> ?
05:42:12 <RibRib> how do i make ["one", "two"]
05:42:13 <RibRib> into [1,2]
05:42:13 <RibRib> i already have a function nlp, which changes a string into integer
05:42:13 <RibRib> nlp "one"=1
05:42:13 <RibRib> nlp "two"=2
05:42:28 <Lunar^> @type map
05:42:29 <lambdabot> map :: (a -> b) -> [a] -> [b]
05:43:03 <Lunar^> Do you need an explaination for this type ?
05:43:30 <RibRib> map :: (a -> b) -> [a] -> [b] thats it?
05:43:48 <Lunar^> nlp has type Sting -> Int
05:43:57 <Lunar^> You've got a list of String
05:44:13 <Lunar^> So applying map to nlp and your list gives you a list of Int
05:44:22 <Lunar^> got it ?
05:49:54 <Cale> Map takes a function on a's and lifts it into a function on lists of a's.
05:50:45 <Cale> It's one of the more important higher-order functions.
05:55:06 <RibRib> map not in score
05:55:07 <RibRib> scope
05:57:25 <Cale> RibRib: it's in the prelude
05:57:35 <Cale> @prelude map
05:57:36 <lambdabot> *** "map" prelude "Haskell Standard Prelude Dictionary": text follows
05:57:36 <lambdabot> map
05:57:36 <lambdabot>   map ::  (a -> b) -> [a] -> [b]
05:57:36 <lambdabot>   map f xs          = [ f x | x <- xs ]
05:57:56 <whee> it's in the prelude, it should be
05:58:43 <RibRib> so what do i type?
05:59:19 <RibRib> to make ["one", "two"] into [1,2]
05:59:28 <Cale> map nlp ["one", "two"]
06:00:36 <RibRib> thnx :)
06:15:19 <Lunar^> RibRib: welcome to the world of high-order programming :)
06:15:37 <RibRib> yeh i just had a tutorial today abt it
06:15:40 <RibRib> map and filtering
06:38:58 <RibRib> is it possible to write a function that checks if an element in a list is greater than a number, if yes then add that element to the next element?
06:39:38 <adept> foldl
06:40:03 <adept> wait a minute ... add to the next element and put result where?
06:41:02 <RibRib> function 20 [1,50,4]
06:41:08 <RibRib> [1, 54]
06:41:50 <Lor> Yes, it is possible to write such a function.
06:42:29 <RibRib> how to get the "next element"?
06:44:00 <Lor> They are all in the list.
06:44:26 <Lor> Really, it is very hard to answer your questions since I have no idea what you actually know of Haskell and what not.
06:44:38 <Lor> It would help very much if you stated your questions more precisely.
06:44:54 <RibRib> ok in that case..
06:45:15 <RibRib> i want ([1,50,4],[100,1000000]) to ([1,54],[100,1000000])
06:45:44 <Heffalump> that's not really very precise
06:46:26 <RibRib> if an element in the first list is >20 then add that element to the next element in the list
06:46:49 <Lor> And what is supposed to be done with that next element?
06:46:56 <Lor> Is it again added to the one following it?
06:47:12 <RibRib> delete it i guess...
06:47:31 <Heffalump> that means [1,50,4] -> [1]
06:47:35 <Heffalump> which isn't what you said
06:48:30 <RibRib> function 20 [1,50,4]
06:48:30 <RibRib> [1, 54]
06:48:51 <Heffalump> right, so you don't delete the next element.
06:48:54 <RibRib> function 20 [1,50,4,100,4]
06:48:55 <RibRib> [1, 54, 104]
06:49:16 <Heffalump> function 20 [1,50,4,100] ?
06:49:41 <RibRib> [1, 54, 100]
06:49:57 <Heffalump> ok, so you need to process the list from the front.
06:50:15 <Heffalump> I suggest you look at the definition of functions like sum and map and try to see how to do it from there
06:50:28 <Heffalump> possibly also something like remDups
06:50:40 <Heffalump> oh, but not that, it doesn't exist
06:50:53 <Darius> nub?
06:51:00 <Lor> Nah, just write it manually.
06:51:06 <Heffalump> no, cos that's not just adjacent elements
06:51:13 <Heffalump> lor: I just meant look at the definitions, not to use them
06:51:20 <Darius> true, where did remDups come from?
06:51:36 <Heffalump> I'm trying to remember the name of what I mean
06:51:51 <Darius> group is kinda like that
06:52:11 <Heffalump> yeah
07:04:28 <semaj> f n []          = []
07:04:29 <semaj> f n (x:y:xs)    | x > n = x + y : f n xs
07:04:31 <semaj>                 | otherwise = x : f n (y:xs)
07:04:48 <semaj> an example of simple recursive method :)
07:05:11 <semaj> i hope i didnt look to this to late
07:05:24 <semaj> it is possible to write this in one line
07:05:49 <semaj> but this way i think you will understand better :)
07:06:01 <Heffalump> you're not supposed to give people homework answers
07:06:18 <semaj> ups, sorry
07:06:30 <semaj> i was just trying to help
07:06:59 <semaj> i didnt thought it was homework, it is extremely simple
07:07:46 <semaj> and i even wrote in its most simple form 
07:07:57 <semaj> i ll start reading better :)
08:35:23 --- topic: '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","lots of cool debs in the haskell-experimental archive - see http://haskell.org/hawiki/DebianUsers","#haskell meetup @ ICFP, HaskellIrcChannel on the wiki","ghc rpms - http://haskell.org/~petersen/rpms/ghc/","new monads tutorial http://www.nomaware.com/monads/html/"]'
08:35:23 --- topic: set by Cale on [Sun Aug 17 06:24:17 2003]
08:36:53 --- topic: '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","lots of cool debs in the haskell-experimental archive - see http://haskell.org/hawiki/DebianUsers","#haskell meetup @ ICFP, HaskellIrcChannel on the wiki","ghc rpms - http://haskell.org/~petersen/rpms/ghc/","new monads tutorial http://www.nomaware.com/monads/html/"]'
08:36:53 --- topic: set by Cale on [Sun Aug 17 06:24:17 2003]
09:41:08 <Lor> What's happened to the iohcc home page?
09:44:37 <Heffalump> @seen mgoetze
09:44:43 <Heffalump> (no idea)
10:08:10 <SyntaxPolice> hi Heffalump
10:08:17 <Heffalump> hiya
10:08:27 <Heffalump> I never exchanged PGP keys with you.
10:08:52 <SyntaxPolice> I know :(
10:08:56 * SyntaxPolice forgot
10:10:51 <Lor> Would you have had any better evidence of each other's identities at a live meeting than otherwise? Would you have shown id:s to each other before taking the keys?
10:11:01 <Heffalump> yes
10:11:04 <Heffalump> (to the latter question)
10:11:14 <Lor> All right.
10:11:27 <Lor> (And hence also to the former.)
10:11:39 <Heffalump> I require government issued photo id (preferably passport for non-UK since I can't easily identify other things as valid)
10:12:05 <Lor> How do you identify a passport as valid?
10:12:15 <Heffalump> they tend to be fairly standard
10:12:28 <Heffalump> at some point you have to accept that there is a vulnerability though
10:12:46 <Lor> My new EU passport is quite different from my previous one.
10:14:00 <reffie> EU?
10:14:13 <Heffalump> European Union
10:14:20 <reffie> what country?
10:14:27 <Heffalump> presumably he means EU-style passport, rather than an actual EU passport
10:14:33 <reffie> ah ok
10:15:06 <ibid> reffie: finland is a recent (1995) new member, so the eu-style passports are fairly new to us
10:15:13 <Lor> Well yeah. It's red and saiys "Euroopan Unioni Europeiska Unionen Suomi Finland Passi Pass" on the cover, whereas the old one was blue and just said "Suomi Finland Passi Pass".
10:15:43 <Lor> Also, the actual identification information is no longer on the inside cover, but on a separate page.
10:15:49 <reffie> chicago style?
10:15:56 <Heffalump> my identification info is on the inside page
10:16:01 <Heffalump> s/inside page/inside cover/
10:16:48 <ibid> reffie: ?
10:17:15 <reffie> mine says "Communaute' Europeene Republique Francaise PASSEPORT"
10:17:42 <ibid> my blue-cover passport is valid until 1996, iirc
10:17:44 <Lor> Also, the one (trivial) authenticity check that even I knew of seems to be gone in this newer version.
10:17:56 <Lor> (It remains in the new id cards though.)
10:17:59 <ibid> until 2006, of course
10:18:31 <reffie> my passport is valid until 2011
10:18:38 <reffie> or something
10:19:27 <Lor> Are the actual inside pages used for anything these days?
10:19:38 <reffie> visas
10:19:51 <reffie> and stamps
10:20:23 <Lor> What are the stamps for?
10:20:57 <reffie> they stamp stuff when you enter and exit certain countries
10:21:15 <Lor> To see that you have entered the country properly?
10:21:29 <reffie> yes
10:28:09 <SyntaxPolice> anyone have a guess as to why nis might stop working after upgrading from stable to unstable debian?
11:41:01 <Heffalump> SyntaxPolice: there's libc6 bugs open on that subject
11:52:25 <SyntaxPolice> yeah, found it now
12:44:02 <Tomasso> can anyone tell me any function that goes from c -> c and is diferent from the Id x = x function???
12:44:14 <Tomasso> does that function exist??
12:44:26 <ibid> yes
12:44:40 <Tomasso> yes???!! examples please :D
12:44:58 <ibid> f _ = undefined
12:44:59 <ibid> :)
12:45:04 <SyntaxPolice> Tomasso: do you know what it means to go from c -> c?
12:45:21 <ibid> and note that Id is not a valid function name :)
12:45:29 <Tomasso> means that goes from any data type to any data type
12:45:39 <Tomasso> id sorry :D hehe
12:46:13 <ibid> to the same type
12:46:24 <Tomasso> exactly, the same
12:46:39 <Vincenz> same TYPE, not necessarily variable
12:46:44 <Vincenz> though if the type is general, it's ahrd
12:46:48 <Vincenz> but if the type is for example int
12:46:55 <Vincenz> x -> x + @
12:46:56 <Vincenz> x -> x + 2
12:47:07 <ibid> i like f _ = undefined :)
12:47:25 <Lor> Also f = undefined.
12:47:33 <Vincenz> f _ = undefined?
12:47:34 <SyntaxPolice> or f _ = error "foo" :)
12:47:44 <Binkley> or f _ = error "bar"
12:47:47 <Binkley> or f _ = error "quux"
12:47:51 <Binkley> the possibilities are endless!
12:47:53 <SyntaxPolice> Binkley: good one!
12:48:23 <Tomasso> hmmh but only works for integer!
12:48:26 <Tomasso> heheheh
12:48:50 <Heffalump> if f _ = undefined , then f has type a -> b
12:49:03 <Heffalump> can anyone give a function of type precisely a -> a that isn't the identity function? :-)
12:49:07 <Lor> tomasso, but more to the point, disregarding errors and bottoms and unsafe things, then yes, essentially the identity function is the only inhabitant of type \forall a . a -> a. That's parametricity.
12:49:23 <mattam> neg
12:50:06 <Igloo> If a type sig is allowed then yes
12:50:18 <Heffalump> it's not
12:50:55 <Igloo> Can you?
12:51:02 <mattam> oh
12:51:03 <Heffalump> no
12:51:22 <ibid> hmm, is this cheating? f x = g x where { g :: a -> a ; g _ = undefined }
12:51:23 <ibid> :)
12:51:27 <Heffalump> oh, yes, actually
12:51:32 <Igloo> Ah, so can I
12:51:34 <Heffalump> ibid: oh, cunning :-)
12:51:36 <Heffalump> I was thinking
12:51:44 <Igloo> That uses a type sig
12:51:51 <Heffalump> oh, so it does
12:52:00 <Heffalump> I read it and thought he meant something else
12:52:01 <Igloo> f x = if False then x else undefined
12:52:04 <Heffalump> yeah, that.
12:52:20 <ibid> yes it does, which is why i said cheating, but it does not type f explicitly :)
12:52:29 <Heffalump> no type signatures at all :-)
12:52:33 <ibid> :)
12:53:21 <ibid> a variant of Igloo's is f x = case x { False -> x ; True -> undefined } -- i just like case better :)
12:53:57 <Binkley> Huh? That requires x to be a boolean
12:54:10 <ibid> no?
12:54:13 <ibid> ahh, yes
12:54:16 <ibid> bah :)
12:54:30 <Heffalump> s/x/True/2
12:54:35 <Igloo> You could say f x = case x { _ -> undefined ; _ -> x }
12:54:45 <Heffalump> oh, yes
12:54:45 <ibid> correction: f x = case True of { False -> x ; True -> undefined } -- i just like case better :)
12:54:52 <ibid> true
12:55:17 <ibid> how many angels ... :)
12:55:27 <ibid> (and i do enjoy this:)
12:56:16 <Heffalump> ok, are there any functions in forall a . a -> a (not necessarily with precisely that type) that aren't equivalent to either f x = x or f x = undefined ?
12:56:30 <Lor> Yes. f = undefined.
12:56:31 <ibid> probably not
12:56:39 <ibid> ahh
12:56:49 <Heffalump> bah :-)
12:57:13 <Lor> Those three and no others, as long as you consider all errors to be the one and same bottom.
12:57:29 <Heffalump> I do. Can you prove that?
12:57:47 <Lor> Well, if I grokked scott models, I might... :)
12:58:00 <Lor> Or the parametricity theorem.
12:58:01 <ibid> why do you need a model for that?
12:58:38 <ibid> i should think a structural case-by-case analysis ought to work
12:58:40 <ibid> messy, though
12:58:50 <Lor> When we talk of functions "in" a type, we clearly are giving some sort of interpretation to terms.
12:59:11 <Lor> We could of course just have a term model of alpha-beta-equivalence classes.
12:59:24 <ibid> Lor: not at all. "in" is precisely the formal operator ::
12:59:33 <Heffalump> but then your argument would need to be based around HM type inference
12:59:52 <ibid> well. yes -- if we are talking about Haskell :)
13:00:15 <Heffalump> and don't forget Haskell lacks principal types :-)
13:00:23 <Lor> ibid, that's bad terminology. Then you should say "how many terms are there that can be given the type a->a".
13:00:58 <Lor> And of course the answer is "infinitely many", as you showed with your variations of \_->undefined.
13:01:40 <ibid> hmm, you do need to consider the semantics, true, to get the equivalence
13:02:00 <ibid> Lor: we are informal here :)
13:04:48 <Lor> One day I really should finish Mitchell's textbook. There are some chapters there that I still haven't managed to delve through.
13:05:18 <Binkley> heh, mitchell
13:05:20 <Binkley> awful
13:05:51 <Vincenz> just to get a feel
13:06:00 <Vincenz> how do you write a function that multiplies it's argument by 2?
13:06:05 <Lor> The exposition isn't what one might hope for, but it's rich in content.
13:06:23 <Lor> vincenz, (* 2).
13:06:25 <Binkley> I suppose, I just haven't been able to get beyond the impenetrable writing style
13:06:39 <Vincenz> Lor: yes but...a named function :P
13:06:42 <Cale> Vincenz: or double x = x * 2
13:06:48 <Vincenz> ah thnx
13:06:51 <Lor> double = (* 2)  :)
13:06:52 <Cale> or double = (* 2)
13:06:55 <Vincenz> hehe
13:06:56 <Cale> yes :)
13:07:35 <Vincenz> do you all believe Haskell > Ocaml?
13:07:54 <Lor> Depends on what kind of a relation > is supposed to stand for.
13:07:56 <ibid> certainly haskell /= ocaml :)
13:07:56 <Binkley> no, Haskell < Ocaml
13:08:00 <Binkley> It comes first in the dictionary
13:08:13 <Vincenz> > = (better)
14:42:25 <stepcut> ERROR - Control stack overflow :(
15:45:09 <shapr> pretty colors!
15:45:30 <shapr> er, hi
15:45:47 <SyntaxPolice> hi shapr
15:46:01 <shapr> is this channel for some teaching language designed for Wirthwhile pursuits?
15:46:23 <shapr> some famous mathematician?
15:46:40 <shapr> oh, maybe I'm thinking of Pascal.
15:46:47 <SyntaxPolice> when I was in london, I saw a book store that claimed to be open on sundays from "12:00 PM - 6:00 PM"
15:46:52 <SyntaxPolice> they don't have a different standard there, do they?
15:47:01 <Lunar^> shapr: I hit the limit of Haskell type system today
15:47:04 <SyntaxPolice> shapr is about to get kicked
15:47:08 <shapr> whoops
15:47:11 <SyntaxPolice> Lunar^: did you turn on extentions?
15:47:12 <SyntaxPolice> ;)
15:47:14 <shapr> Lunar^: cool, was there a stop sign?
15:47:20 <Lunar^> Not exactly
15:47:25 <shapr> did you get pulled over on the information superhighway?
15:47:26 <Lunar^> In fact, it's more related to the standard lib
15:47:45 <Lunar^> http://haskell.org/pipermail/glasgow-haskell-users/2003-September/005638.html
15:47:56 <Lunar^> I tried a lot of gory hacking to bypass this
15:47:57 * shapr thinks "please step away from the computer and have your programming license in your hand"
15:48:13 <Lunar^> lol
15:48:29 <SyntaxPolice> do you ever have the experience of multi-tasking while trying to call someone, then when someone asnwers, totally forget who you're calling and why?
15:48:45 <shapr> I don't have to do multiple things for that to happen to me :-)
15:48:48 <SyntaxPolice> heh
15:48:56 <SammiCheng> where are you guys from?
15:49:00 * SyntaxPolice hands shapr a chill-pill
15:49:07 <shapr> SammiCheng: I'm from abalama! where are you from?
15:49:09 * SyntaxPolice is from Ohio USA
15:49:17 <SammiCheng> Sydney Australia
15:49:20 <shapr> wow, nifty
15:49:26 <Lunar^> SyntaxPolice: yes
15:49:33 <shapr> I heard Sydney has a cool opera house.
15:49:34 <SyntaxPolice> SammiCheng: we met some cool ppl from sydney recently.
15:49:55 <shapr> I thought they were from brisbane?
15:50:03 <SyntaxPolice> whatever.
15:50:03 <SyntaxPolice> ;)
15:50:10 <SammiCheng> are u guys in uni or working?
15:50:11 <SyntaxPolice> they talked about sydney a lot, didn't they?
15:50:12 <shapr> right, distances are small in .au
15:50:21 <shapr> so brisbane must not be too far from sydney
15:50:31 <SammiCheng> about 8 hrs drive...
15:50:35 <shapr> SammiCheng: I'm working, what about you?
15:50:40 <SyntaxPolice> SammiCheng: shapr and I are working, but there are a lot of ppl from uni involved in haskell
15:50:41 <SammiCheng> uni student
15:50:55 <shapr> at least, I claim to work.
15:50:57 <SammiCheng> working as programmers?
15:51:02 <SyntaxPolice> yup
15:51:04 <shapr> people give me money to talk on irc, it's great.
15:51:26 <SammiCheng> how many languages do u know
15:51:39 <shapr> American, some Swedish, some French
15:51:39 <SammiCheng> you know C and C++?
15:51:42 <shapr> oh
15:51:45 <SyntaxPolice> heh
15:51:45 <SammiCheng> :)
15:51:59 <SyntaxPolice> I think you'll find people on here pretty well versed in a wide variety of languages
15:52:00 <shapr> no, I don't know those.
15:52:19 <shapr> or at least, I deny knowing so I won't have to write them for money.
15:52:45 * SyntaxPolice knows C & C++
15:52:56 <SammiCheng> is haskell harder than C?
15:52:59 <hdaume> does anyone really "know" c++?
15:53:11 <Lunar^> hdaume: good point ;)
15:53:15 <SyntaxPolice> hdaume: oh come on :)
15:53:18 <shapr> hdaume: it's just a bunch of bjarney (baloney :-)
15:53:37 <SyntaxPolice> SammiCheng: I think Haskell is easier to write working programs that don't break than C :)
15:53:38 <shapr> hi hal
15:53:42 <SyntaxPolice> SammiCheng: do you know any other languages? 
15:53:49 <hdaume> hi shae :)
15:53:53 <SyntaxPolice> the problem is that C might be closer to other languages you've learned
15:54:00 <SyntaxPolice> s/closer/more similar
15:54:00 <shapr> hdaume: I like that thread you started on the mailing list.
15:54:09 <shapr> I've been tempted to write an application paper lately.
15:54:18 <hdaume> i really didn't intend people to reply to the list, but i guess others don't seem to mind
15:54:25 <shapr> It's great.
15:54:39 <SammiCheng> im currently learning haskell, and will be studying C later
15:54:40 <shapr> so, when's your release date?
15:54:49 <shapr> I heard the Evil Empire is paroling you soon.
15:54:58 <hdaume> yeah, friday's my last day
15:55:01 <SyntaxPolice> SammiCheng: so is Haskell your first language?
15:55:15 <SammiCheng> done a little bit of C++ before
15:55:20 <SammiCheng> that was hard
15:55:27 <shapr> hdaume: are you going to write up your experiences with microsoft now?
15:55:42 <SyntaxPolice> SammiCheng: have you looked into Helium at all?  It is a compiler for a reduced version of Haskell that allows for better error messages.
15:55:57 <SyntaxPolice>  are you using Haskell at a university?
15:56:14 * shapr boings
15:56:21 <shapr> @yow
15:56:26 * shapr blinks
15:56:27 <hdaume> shapr: yeah, it's a pain.  they're making me write the paper in *word*
15:56:31 <shapr> hdaume: oy!
15:56:38 <hdaume> tell me about it
15:56:52 <SyntaxPolice> @google Helium for learning haskell
15:56:58 <SammiCheng> yes im using haskell at university
15:57:01 * SyntaxPolice blinks
15:57:06 <SyntaxPolice> @google Helium for learning haskell
15:57:06 <lambdabot> Sorry, I don't know the command "google", try "lambdabot: @listcommands"
15:57:08 <SammiCheng> its not very popular
15:57:13 <SyntaxPolice> oh, wrong bot
15:57:14 <shapr> SammiCheng: why not?
15:57:25 <SyntaxPolice> we seem to get a lot of students from .au on here
15:57:43 <shapr> hi Binkley 
15:57:48 <Lunar^> SammiCheng: I think you'll fell quite muzzled doing C after Haskell
15:57:59 <SyntaxPolice> trying to pry answers directly from our brains with crow bars (caps lock)
15:58:00 <SammiCheng> not as popular as C and C++
15:58:01 <Binkley> he
15:58:03 <Binkley> +y
15:58:06 <shapr> Binkley: any progress in slash and burn type inferencing?
15:58:32 <Binkley> Yeah, I have some pretty good results, I think
15:58:36 <shapr> yay
15:58:45 <Binkley> improving about 40% of the nofib benchmarks and only making 4 worse
15:58:48 <Binkley> so I think it's time to publish
15:58:54 <SyntaxPolice> @yow
15:58:54 <lambdabot> "THE LITTLE PINK FLESH SISTERS," I saw them at th' FLUORESCENT BULB
15:58:54 <lambdabot>  MAKERS CONVENTION...
15:58:59 <Binkley> @yow
15:59:00 <lambdabot> Yow!  Is my fallout shelter termite proof?
15:59:06 <shapr> I still say you're at least a type magician, is that bearable?
15:59:19 <Binkley> Oh, "magician" is good.
15:59:33 <Binkley> Let's see whether the PLDI program committee agrees, though.
15:59:38 <shapr> :)
15:59:58 <SyntaxPolice> SammiCheng: it is a mistake to only learn the programming language that is popular with the industry while you're int he university.  you should learn several programming languages, so that you can pick up new ones in a matter of days
15:59:59 <shapr> it's @999.95
16:00:02 <shapr> time for bed
16:00:22 <Heffalump> improving them by how much, OOI?
16:00:33 <SyntaxPolice> shapr: how are the cats?
16:00:40 <shapr> SyntaxPolice: fluffy.
16:00:41 <Binkley> anywhere from 5-50%
16:00:49 <Binkley> well, one improves by 93%, but that's a fluke
16:00:51 <SyntaxPolice> my cat is nuts over me. he won't let me sleep; keeps poking me with his claws
16:00:59 <shapr> it's cold and dry here, so staticy fur sticks out.
16:00:59 <Binkley> measuring amount of memory allocated... I haven't looked at time
16:01:13 <shapr> ohh have you guys seen the fluffy bunnies that Binkley found?
16:01:24 <SyntaxPolice> no
16:01:28 * shapr gets url
16:01:33 * SyntaxPolice HATES fluffy BUNNIES!!
16:01:41 <Heffalump> are the disimprovements due to the loss of sharing problems you mentioned?
16:01:43 <Binkley> how can anyone hate fluffy bunnies?
16:01:49 <shapr> Binkley: do you have the url handy?
16:01:50 <Lunar^> SyntaxPolice: I agree
16:01:52 <SyntaxPolice> Binkley: j/k
16:01:53 <Binkley> I'm not sure about the reasons for the remaining disimprovements
16:01:57 <shapr> anyways, those can't possibly be real bunnies.
16:01:59 <shapr> I think the website is a spoof.
16:02:03 <Binkley> It's just not worth looking into
16:02:13 <Binkley> Oh, I believe the bunnies, I've taken care of a bunny who was almost that fluffy
16:02:27 <Binkley> http://home.pacbell.net/bettychu/2003allbreedbisris/BIS.html  <--- fluffy!!!
16:03:37 <shapr> insanely fluffy. unrealistically fluffy.
16:03:57 <shapr> speaking of a need for deforestation...
16:04:28 <shapr> SyntaxPolice: your cat missed you.
16:04:30 <SyntaxPolice> wow
16:04:31 * SyntaxPolice lol
16:04:54 <Binkley> That would be deFURestation
16:04:57 <shapr> heh!
16:05:03 * shapr bounces
16:05:26 <shapr> I still they look like a badly designed stuffed animal.
16:05:41 <Binkley> I want to cuddle them.
16:06:10 * SyntaxPolice wants to EAT them!
16:06:16 <Binkley> boo
16:06:17 <SyntaxPolice> shapr: yeah, my cat missed me I think.
16:06:21 <shapr> I just want to wear them.
16:06:24 <SyntaxPolice> Binkley: just kidding, I love bunnies
16:06:39 <shapr> of course, that brings up issues of hygiene.
16:06:44 <Binkley> I know, but it's my job to chastise anyone who threatens bunnies, even jokingly
16:06:51 <Binkley> yeah, it would, they poop a lot
16:07:17 <Heffalump> dead bunnies!
16:07:25 <Binkley> Can I go home and play with my bunnies now?
16:07:41 <shapr> SammiCheng: hey, I can help you with non-homework stuff, but it would be unethical to help you with homework problems.
16:07:41 * Heffalump hasn't eaten rabbit for ages
16:07:56 <SammiCheng> k then
16:08:01 <shapr> I once chewed on a rabbit fur coat.
16:08:07 <shapr> dunno if that counts.
16:08:29 <shapr> SammiCheng: also, if I helped you with homework problems, you'd still have to learn stuff before the test, right?
16:08:32 <SyntaxPolice> well, I think people don't mind _helping_ with homework.
16:08:38 <shapr> so you'd just be putting off the inevitable.
16:08:45 <Binkley> I'll help you with your homework if you help me write my thesis
16:08:50 * shapr laughs
16:08:56 <shapr> Binkley: I have swedish homework.
16:09:03 <Binkley> bork bork bork
16:09:09 <Binkley> that's all the Swedish I know
16:09:33 <shapr> export LOCALE=se_CHEF
16:10:05 <shapr> Binkley: did you have fun in Sweden?
16:10:13 <Binkley> Oh yeah, I had a fun time
16:11:04 <Binkley> I wish the conference had gone on longer
16:11:09 <Binkley> Not more talks, just more hanging out :-D
16:11:14 <SyntaxPolice> oh Binkley!!
16:11:18 <SyntaxPolice> I forgot that nick :)
16:11:25 <Binkley> heh
16:11:29 <Heffalump> yes, more hanging out would have been good
16:11:34 <shapr> yah, the type er, magician
16:11:36 <SyntaxPolice> we should have a party at my place.
16:11:38 <Heffalump> bit harder to justify claiming expenses for though :-)
16:11:50 <shapr> yes, more hanging out next time.
16:11:58 <Binkley> You're coming next time?
16:12:05 <shapr> if I'm rich.
16:12:07 <SyntaxPolice> I hope its in CHicago!
16:12:23 <shapr> I was unusually profitable this year, so I could afford it.
16:12:30 <SyntaxPolice> SammiCheng: several of us recently returned from an international conference in sweden, which is related to Haskell.
16:12:42 <SyntaxPolice> where many of us met for the first time.
16:12:43 <shapr> how can you have an international conference in one country?
16:12:51 <shapr> wouldn't you have to have it on the border of two countries or something?
16:12:54 <Binkley> well, it's called International, so therefore it is
16:12:54 <SammiCheng> i see
16:12:54 <SyntaxPolice> shapr: bah! the people are from different countries!!
16:12:56 <SammiCheng> thats cool
16:13:13 <shapr> it's like having a fun of programming conference without programming.
16:13:59 <SyntaxPolice> ANyway, I'm going to go home and cook some dinner. talk to you guys later.
16:14:22 <shapr> cya
16:14:27 <shapr> I'm going to bed
16:14:31 <shapr> it's after 1am
16:14:43 <SyntaxPolice> shapr: re you like on some kind of swedish time these days?
16:14:50 <shapr> sort of yes
16:15:02 <shapr> I'm trying to keep the sleep schedule I had at the conference
16:15:05 <shapr> Bea likes it a lot.
16:15:10 <Heffalump> hehe
16:15:14 <shapr> she gets to talk to me.
16:15:15 <SyntaxPolice> heh. strange.
16:15:19 * Heffalump is trying to do it too
16:15:30 * SyntaxPolice thinks that would be impractical on this side of the world
16:15:43 <shapr> SyntaxPolice: you live in a furren country.
16:15:55 <shapr> your time zone is alien and antipathetic to ours!
16:16:16 <shapr> actually, what's the adjective form of antipathy?
16:16:20 <SyntaxPolice> our time zone is better
16:16:31 <Binkley> antipathetic?
16:16:32 <Binkley> hmm
16:16:42 <SyntaxPolice> aaaanyway. i'm outta here.
16:16:43 <SyntaxPolice> peace all
16:16:44 * SyntaxPolice &
16:16:46 <shapr> peace
16:16:47 <shapr> goodwill
16:16:49 <shapr> happiness
16:16:51 <shapr> sleepppp
16:16:55 * shapr falls over
16:23:22 <SammiCheng> does the sum function work with turples?
16:23:44 <Binkley> Turples? Is that like a purple turtle?
16:24:26 <opet> purple turtles are student pubs. yay :)
16:31:40 <Xcalibor> greetings
16:32:51 <hdaume> hi
16:33:03 <Xcalibor> :-)
16:33:43 <Xcalibor> is there a REPL for haskell where I can test functions interactively? the documentation I have read so far isn't very clear about this point (?)
16:33:48 <Binkley> ghci
16:33:54 <hdaume> or hugs
16:34:02 <Xcalibor> mmm... let me check
16:34:18 <Binkley> ghci is better :-)
16:34:26 <hdaume> yes
16:34:28 <Xcalibor> ok, I got hugs.. can I just type functions in there?
16:34:29 <hdaume> but hugs is faster :)
16:34:34 <Binkley> no it's not!
16:34:50 <hdaume> Xcalibor: you can't define functions at the prompt in hugs
16:34:53 <hdaume> you have to put them in a file
16:35:11 <hdaume> and the :load the file
16:35:14 <Xcalibor> hdaume: ah, that's what I was asking for... isn't it possible?
16:35:22 <hdaume> in ghci yes, in hugs no
16:35:32 <Xcalibor> ghci... ok, let me check
16:35:52 <Xcalibor> ok, don't have it -/
16:35:56 <Xcalibor> gotta download it
16:36:35 <Xcalibor> is it an Emacs mode?
16:36:47 <Binkley> no
16:36:48 <Xcalibor> or is it just thatere's an Emacs mode with the same name?
16:36:54 <Binkley> could be
16:37:05 <Xcalibor> do you have an URI for it?
16:37:17 <hdaume> haskell.org/ghc
16:38:54 <Xcalibor> ok, gone for it... it will take a while... thanks :-)
16:39:05 <Xcalibor> a repl is easier to follow the book examples :)
16:41:45 <Darius> Binkley: Hugs is -loads- faster
16:42:00 <Binkley> hmm, I don't believe that
16:42:12 <Binkley> I mean, ghci is just a wrapper around ghc
16:42:14 <Binkley> which is fast
16:42:27 <hdaume> ghc is actually pretty slow, imo :)
16:42:34 <hdaume> compared to, say, ocamlc
16:42:37 <Darius> -loads- not executes
16:42:47 <Binkley> well, depends whether you're talking about compile times or runtimes
16:42:47 <SammiCheng> can someone help me ?
16:42:48 <Riastradh> hdaume, well, ocamlc is insanely fast anyways.
16:42:56 <Riastradh> SammiCheng, just ask your question.
16:43:06 <Pseudonym> Yeah, and gcc is faster than javac, so there.
16:43:08 <Darius> GHCi takes a couple of seconds to start, and a couple of seconds to :load larger files
16:43:15 <Darius> Hugs is instantaneous
16:43:16 <Binkley> oh, I see
16:43:22 <Binkley> I never use either one anyway, I always use ghc
16:43:56 <Pseudonym> Hugs has CAF space leaks.
16:44:06 <Darius> and broken numerics
16:44:11 <Pseudonym> Yep.
16:44:45 <Binkley> yeah, well, so does yo momma
16:44:49 <Binkley> I should really go away now
16:45:03 <SammiCheng> ([Integer],[Integer]), how do i write a function that multiplies the first elements from both list together, then the 2nd elements from both list.. and so on...
16:45:29 <SammiCheng> do i say f (x:xs) (y:ys)
16:45:33 <Pseudonym> Check out zipWith.
16:45:48 <SammiCheng> x*y
16:45:51 <hdaume> if you want to do the recursion explicitly, then yes
16:45:56 <SammiCheng> something like that
16:46:10 <SammiCheng> x*y
16:46:26 <SammiCheng> f xs*ys
16:46:27 <hdaume> if you want to return a list, that better be (x*y) : something
16:47:04 <SammiCheng> x*y : f xs*ys?
16:47:23 <SammiCheng> (x*y) : f (xs*ys)
16:47:28 <hdaume> what is f?  and xs and ys are lists.  you can't multiply them together
16:47:38 <SammiCheng> f = function
16:48:13 <SammiCheng> (x*y) : f [(xs),(ys)]
16:48:26 <hdaume> now you're just pushing symbols around :)
16:48:29 <hdaume> think about what you want to do
16:48:44 <SammiCheng> Example: ([1,2,3],[10,100,1000]) = [(10,200,3000)]
16:48:53 <hdaume> yes, i know what you want :)
16:50:25 <SammiCheng> (x*y) : f [(x:xs),(y:ys)]
16:50:35 <Pseudonym> Think about it.
16:50:38 <SammiCheng> ...
16:50:40 <SammiCheng> :(
16:50:43 <hdaume> if you say "f (x:xs) (y:ys)" then, in that case, x=1, y=10, xs=[100,1000], ys=[200,3000].  you want the first element of the retuned list to be (x*y), certainly.  what do you want to do with xs and ys?
16:50:44 <SammiCheng> im thinking :(
16:50:50 <Pseudonym> Here's a thought.
16:50:55 <Pseudonym> Write the type of f first.
16:51:09 <Pseudonym> Then write a recursive call to f which satisfies that type.
16:51:15 <SammiCheng> --Multiplying n elements in a list
16:51:16 <SammiCheng> --Example: ([1,2,3],[10,100,1000]) = [(10,200,3000)]
16:51:16 <SammiCheng> multelem :: ([Integer],[Integer]) -> ([Integer])
16:51:16 <SammiCheng> multelem [] = []
16:51:35 <hdaume> that doesn't typecheck :)
16:51:43 <hdaume> multelem should take a pair, but there it's taking a list
16:52:13 <Pseudonym> SammiCheng, I don't know if you've been told to write your type declarations first or not, but it's a good idea.
16:52:27 <Pseudonym> It's not just for extra marks, it actually helps you understand what your function does.
16:53:40 <SammiCheng> head xs * head ys ?
16:54:00 <Smerdyakov> SammiCheng, you should go learn Haskell before trying to continue. AKA, read a book or something.
16:55:23 <Pseudonym> Well, I wouldn't go that far.
16:55:33 <Pseudonym> Many people, myself included, learn best by playing.
16:55:57 <Smerdyakov> I think guessing syntax/typing rules is generally not worthwhile.
16:56:02 <Pseudonym> That's true.
16:56:30 <Pseudonym> One thing that I found was valuable with students was practicing pattern matching.
16:56:44 <Pseudonym> Here's a value, here's a pattern.  Does it match?  If so, what bindings do you get?
16:56:57 <Pseudonym> It improved their code no end.
16:57:10 <hdaume> Pseudonym: that's a great idea :)
16:57:13 * Pseudonym meant to say "practising", of course
16:57:56 <hdaume> he did?
16:58:14 <hdaume> hrm...i guess both are right
16:58:16 <hdaume> stupid english :)
16:58:17 <Pseudonym> Yes.  "Practice" is a noun, "practise" is a verb.
16:58:28 <Smerdyakov> Not in the USA :D
16:58:31 <Pseudonym> You practise in your practice.
16:58:40 <Pseudonym> Yeah, well.  That's the USA for you.
16:58:49 <Pseudonym> They don't speak the King's English over there.
17:02:22 <Pseudonym> You know, this might be a good idea for the wiki.
17:02:30 <Pseudonym> Exercises for Haskell newbies.
17:04:04 <Smerdyakov> Or just a picture of a scary monster to scare them away from Haskell to increase the average Haskell user IQ. ;)
17:07:47 <Pseudonym> I vote Smerdyakov for the position of Chief Haskell Apologist.
17:09:58 * Smerdyakov ponders what that means.
17:10:34 <Binkley> You apologize for all the GHC type error messages
17:10:53 <Pseudonym> @wn apologist
17:10:55 <lambdabot> *** "apologist" wn "WordNet (r) 1.7"
17:10:55 <lambdabot> apologist
17:10:55 <lambdabot>      n : a person who argues to defend or justify some policy or
17:10:55 <lambdabot>          institution; "an apologist for capital punishment" [syn:
17:10:56 <lambdabot>          {vindicator}, {justifier}]
17:13:43 <Smerdyakov> Yes, but why am I a Haskell apologist, or why is it funnier to nominate me than someone else?
17:13:56 <Pseudonym> Well, I can just see you defending Haskell.
17:14:19 <Smerdyakov> I see.
17:14:21 <Pseudonym> "Haskell is big and scary!  You must be at least THIS smart [points to place on IQ bell curve] to use Haskell!"
17:17:45 <Smerdyakov> Yeah, if you've already been infected by imperative programming!
17:17:58 <reffie> heh.
17:53:34 <Xcalibor> ok, time for bed, thanks for all
17:55:36 <Xcalibor> btw, there's a function that 'merges' two lists, taking elements from one and the other in turns, right? (zip)  that should solve the problem of the multelem (or whatever the name)
17:55:52 <Xcalibor> anyway, brain not working anymore... g'night!
17:57:50 <Riastradh> zip just turns two lists into a list of pairs.
17:58:09 <Riastradh> You could use it fir multelem, but that would be silly.
17:58:13 <Riastradh> zipWith would be much better.
17:58:36 <Riastradh> Of course, having a zipWith _and_ a map is just silly: a map that takes a function and a list of lists would be better.
17:58:41 <Xcalibor> Riastradh: aha... didn't know there was a zipWith :-)  still learning, but I wasn't too off, right?
18:01:14 * Xcalibor thinks newbies found reassuring they get close to a solution, even if suboptimal... :)
22:25:48 <Pseudonym> http://haskell.org/hawiki/HomeworkHelp
22:26:03 <Pseudonym> Anyone care to proofread?
22:26:05 <Pseudonym> Or add things?
22:33:15 <Lor> "People can tell whether you say it or not" is somehow ambiguous.
22:33:39 <ibid> true :)
22:33:50 <Pseudonym> Good point.
22:34:08 <Lor> It's understandable, of course, but made me stop for a second.
22:34:14 <Pseudonym> How about "they're going to know it's homework anyway".
22:34:42 <Lor> "They're going to recognize it as homework anyway" perhaps.
22:35:00 <Pseudonym> Excellent.
22:35:11 <Lor> s/homework/such/
22:35:26 <Lor> Better avoid excessive repeating.
22:35:36 <Pseudonym> Good.
22:35:45 <Pseudonym> I'll try to remove the two "ways", too.
22:35:55 <ibid> a curious note: i failed to recognize an obvious homework problem on the newsgroup recently :)
22:36:08 <Pseudonym> Oh, yes, I've done that too.
22:36:12 <Pseudonym> But someone will.
22:36:16 <ibid> (probably because i'm self-taught in fp, so my perspective is different)
22:39:11 <Pseudonym> Oh, I should add: Never, ever, EVER ask your question to someone privately.
22:39:32 <Pseudonym> Not sure how to word that.
22:40:05 <d33p> avoid /msg ?
22:40:28 <Pseudonym> Well, it's true of email too.
22:40:37 <ibid> always ask publicly :)
22:41:00 <Pseudonym> Simple and elegant.
22:44:32 <Pseudonym> OK, fixed those things.  Any other suggestions?
22:50:40 <Pseudonym> Thanks, people.
23:22:00 * shapr sings loudly
23:22:06 <Pseudonym> G'day.
23:22:16 <Pseudonym> Do you sing well, or just loudly?
23:22:25 <apmuf> eheh
23:22:27 <shapr> actually, I'm in a choir
23:22:30 <shapr> people say I sing well.
23:22:32 <apmuf> just loudly :)
23:22:32 <Pseudonym> Oh, there you go.
23:22:34 <Pseudonym> What range?
23:22:37 <shapr> tenor
23:22:44 <shapr> I can do Jimmy Page pretty well.
23:22:58 <shapr> and I love to sing Handel's Messiah as loud as possible without distortion
23:23:06 <Pseudonym> Ah, so you're not just a baritone who gets roped into being a tenor, then.
23:23:16 <shapr> no, I really do have a high range.
23:23:24 <Pseudonym> Can you do Jon Anderson or Freddie Mercury?
23:23:31 <shapr> hey, if you could come to the next ICFP, I think you'd really enjoy it.
23:23:32 <Pseudonym> Jimmy Page is impressive.
23:23:44 <Pseudonym> Yeah, getting there is a pain.
23:23:48 <shapr> and I think Fritz Ruehr has a very similar sense of humor to yours.
23:24:16 <shapr> if you guys swapped jokes while I was there, I'd probably injure myself.
23:24:36 * Pseudonym laughs
23:26:25 <Pseudonym> I could sing if I took lessons.
23:26:33 <Pseudonym> Trouble is I have no control.
23:26:49 <Pseudonym> And my throat gets sore, which once again, signals poor technique.
23:26:58 <shapr> I don't know Jon Anderson, though it sounds vaguely familiar
23:27:17 <Pseudonym> Jon Anderson is lead singer of Yes.  Also did some work with Vangelis some time ago.
23:27:24 <shapr> my throat gets sore if I do multiple Led Zeppelin albums at a time :-)
23:27:31 <Pseudonym> :-)
23:28:02 <shapr> oh, I have a question
23:28:12 <shapr> any ideas how I could hash the AST of a type?
23:28:46 <Pseudonym> Erm... sorry, don't understand.
23:28:46 <shapr> there was an ICFP paper about that, some ML guys were using the hash to somewhat verify distributed typing
23:29:03 <shapr> runtime loader in lambdabot just gives a pointer to a memory location (afaiu)
23:29:07 <Pseudonym> What do you mean by "the AST of a type"?
23:29:15 <Pseudonym> AST I get, type I get.
23:29:38 <shapr> I don't want to hash the comments, whitespace, etc
23:29:46 <Pseudonym> Oh, I see.
23:30:03 <Pseudonym> You want to verify that two types are the same quickly.
23:30:30 <Pseudonym> You may wish to check out the implementation of Data.Dynamic.
23:34:54 <Lor> Dynamic doesn't do any _structural_ comparison between the two types.
23:35:28 <Lor> It just gives a name and an id to each typerep, and the typable instances are a hack to give a unique typerep for each type.
23:35:39 <Pseudonym> Right.
23:35:56 <Pseudonym> That means the compare is quick.
23:36:00 <Pseudonym> Just like comparing hashes.
23:39:17 <shapr> will that let me load new types into an RTS at runtime?
23:40:19 <Lor> Types aren't a runtime concept in haskell.
23:40:26 <Pseudonym> Yes, so long as you declare an appropriate instance.
23:40:34 <Pseudonym> Hmmm.
23:40:46 <Pseudonym> Could be a problem if there's an instance declared separately in whatever you load, though.
23:42:05 <shapr> I'd like to find some way to load new modules into lambdabot that didn't exist when that lambdabot instance was compiled.
23:42:39 <Lor> Don't you have that already?
23:42:48 <shapr> not that I'm aware of...
23:42:54 <shapr> can the runtime loader do that?
23:43:17 <Lor> What about the plugin system that loads object files?
23:44:08 <RibRib> hello
23:44:14 <shapr> hi RibRib 
23:44:21 <RibRib> is there anything wrong with this base case?
23:44:22 <RibRib> groupfirst :: ([Integer],[Integer])->([Integer],[Integer])
23:44:23 <RibRib> groupfirst ([],[])=([],[])
23:45:02 <Pseudonym> It's valid Haskell if that's what you mean.
23:45:21 <shapr> Pseudonym: I think you just wrote a wiki page about this, didn't you? :-)
23:45:24 <RibRib> cool ta
23:45:30 <Pseudonym> shapr: Yeah.
23:45:39 <Pseudonym> I don't know if it solves your problem or not.
23:47:32 <shapr> have you seen the "how to solve it" article?
23:47:36 <shapr> that might fit at the end of that paeg.
23:47:56 <shapr> I think there's even a how to solve it functionally
23:48:00 <Pseudonym> No, I haven't.  (THough I have read Polya.)
23:48:34 <shapr> http://www.math.utah.edu/~alfeld/math/polya.html
23:48:48 <Pseudonym> Yes, I've got a copy of the book.
23:49:03 <Pseudonym> http://www.cs.kent.ac.uk/people/staff/sjt/Haskell_craft/probSolving.html
23:49:04 <Pseudonym> Useful.
23:49:37 <shapr> yah, that fits well on that page.
23:49:50 <shapr> imho most of college is about learning that heuristic
23:50:04 <shapr> and then using it to vacuum up some knowledge
23:50:39 <RibRib> i have an error: varying number of arguments for function 'groupfirst' 
23:50:39 <RibRib> Failed, modules loaded: none.
23:50:39 <RibRib> what does that mean?
23:51:07 <shapr> RibRib: do you understand the error?
23:51:15 <shapr> can you guess at what it means?
23:52:07 <RibRib> i dont understand
23:52:31 <shapr> if you were to interpret that error as plain english, what would you see?
23:54:36 * shapr throws a EFAILTURINGTEST error
23:54:36 <RibRib> too much cases?
23:54:55 <shapr> that's one interpretation, that's pretty close even
23:55:02 <Pseudonym> Do you know what is meant by the word "argument"?
23:56:21 <RibRib> if then statements?
23:56:27 <shapr> idea for a good wiki page "anatomy of a function"
23:56:34 <Pseudonym> Good idea.
23:56:53 <shapr> speaking of which, I keep getting forall and exists confused
23:57:03 <Pseudonym> That's because GHC deliberately confuses them.
23:57:15 <shapr> I wonder if wikipedia has a good explanation of them
23:57:35 <Pseudonym> RibRib: No.  An argument has two meanings in this sense, but they're the same thing really.
23:57:48 <Pseudonym> Consider the call: sqrt 3.0
23:57:56 <Pseudonym> "3.0" is the argument to the function sqrt.
23:58:25 <Pseudonym> It's also used to refer to the left hand side of a definition.  So, for example:
23:58:29 <Pseudonym> add1 x = x + 1
23:58:33 <Pseudonym> Here, "x" is the argument.
23:58:34 <shapr> actually, what would I look for on wikipedia to get forall and there exists such that?
23:59:08 <Pseudonym> It's actually fairly straightforward, I thought.  forall x. P means that P is true for any value of x.
23:59:09 <shapr> predicate cal?
23:59:13 <RibRib> the variable?
23:59:20 <Pseudonym> exists x. P means that P is true for some value of x.
23:59:38 <shapr> RibRib: the variable is on both sides of the equation
23:59:43 <shapr> but the left one is the argument
