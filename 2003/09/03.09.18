00:28:51 <Lamarck> Good Afternoon, people of #haskell
00:29:03 <andersca> good morning Lamarck
00:29:10 <Pseudonym> G'day.
00:29:31 <Pseudonym> Almost evening, actually.
00:29:35 <Lamarck> yeah
00:29:43 <Pseudonym> Kinda dark outside, certainly.
00:29:48 <Lamarck> The sun is setting up here
00:30:02 <Pseudonym> Sydney?
00:30:05 <Lamarck> Coffs
00:30:10 <Pseudonym> Ah, lovely area.
00:30:14 <Lamarck> Yep
00:30:23 <Pseudonym> And your bananas are so big!
00:30:28 <Lamarck> Speaking of which, #haskell is so much nicer than #python :)
00:30:37 <Pseudonym> Oh, we must remedy that.
00:30:43 <Pseudonym> You smell!
00:30:46 <Pseudonym> That better?
00:30:52 <Lamarck> Yep. Now I feel at home.
00:30:56 <Pseudonym> Great!
00:31:11 <Pseudonym> Nothing if not obliging.
00:32:16 <Lamarck> Melbourne eh?
00:32:20 * Pseudonym nods
00:33:18 <Lamarck> Coffs may be a lovely place, but its also a giant hole- I may be moving down to Melbourne at end of year when I finish my degree
00:33:43 * Pseudonym can understand that
00:33:58 <Lamarck> hows the job market in melbourne?
00:34:02 <Pseudonym> Coffs is great if you're a tourist.
00:34:17 <Pseudonym> Oh, pretty good.  Not so much for Haskell unless you're planning postgrad work.
00:34:35 <Lamarck> My interest is Haskell is purely hobby :)
00:34:46 <Pseudonym> It's been a couple of years since I've been in the market, though.
00:34:48 <Lamarck> My degree is IT, unfortunately though.
00:35:05 <Lamarck> You in academia?
00:35:25 <Pseudonym> No, R&D.
00:35:34 <Lamarck> Ok, related to Haskell?
00:35:47 <Pseudonym> I work on a former research project which is going to be spun off as a company.
00:35:54 <Pseudonym> No, not related to Haskell unfortunately.
00:35:57 <Pseudonym> C++
00:36:13 <Lamarck> :(
00:36:22 <Pseudonym> I quite like it, actually.
00:36:29 <Pseudonym> Mostly because we're solving interesting problems.
00:36:43 <Lamarck> I guess whatever language, if the problem is interesting, the programming is fun
00:36:48 <Pseudonym> Yeah.
00:36:57 <Lamarck> writing a payroll program would be boring, even in Haskell :)
00:37:07 <Pseudonym> And C++ isn't _that_ bad, which is odd for a Haskell programmer to say.
00:37:28 <Lamarck> I've been doing a C++ assignment, and its really quite fun
00:37:33 <Pseudonym> Fact is, I used to make the same accusations against C++ that I see many people who have never written anything nontrivial in C++ make.
00:37:44 * Pseudonym knows better now
00:37:53 <Lamarck> I've never written anything non-trivial in C++ :)
00:37:55 <Pseudonym> C++ isn't perfect, but it's definitely a local maximum.
00:38:31 <Lamarck> Do you stuff like functors, templates, etc?
00:38:36 <Lamarck> Or just a subset of C++?
00:38:42 <Pseudonym> Not functors so much.
00:38:54 <Pseudonym> Haven't found a lot of use for them, especially the built-in STL functionals.
00:39:00 <Pseudonym> Templates, definitely.
00:39:08 <Pseudonym> We use as much of C++ as we find appropriate.
00:39:40 <Lamarck> Well, sounds good
00:39:49 <Pseudonym> Oh, this is pretty hardcore stuff here.
00:39:56 <Pseudonym> We work with text.  A lot of text.
00:40:09 <Pseudonym> Terabytes of the stuff.
00:40:33 <Lamarck> What could possibly be terabytes of text?
00:40:55 <Pseudonym> If you think hard enough, you could probably think of a few government agencies with that much.
00:40:59 <Pseudonym> And more coming in every day.
00:41:08 <Pseudonym> The ARC is one of our customers, for example.
00:41:14 <Lamarck> OK
00:41:17 <Pseudonym> Grant applications have a complex workflow.
00:41:33 <Pseudonym> Another project we worked on was the Anzac class frigate project.
00:41:43 <Lamarck> Interesting
00:41:57 <Pseudonym> There wasn't terabytes of text there, but there was a lot which had to go through a complex process.
00:42:01 <Lamarck> Well, I just hope I get a job that interesting.
00:42:24 <Pseudonym> Legislation, we do a lot of that, too.
00:43:19 <Lamarck> Does the lack of garbage collection make a difference in your programming?
00:43:27 <Pseudonym> Hmmm.
00:43:48 <Pseudonym> I'd say that when you're writing database servers, lack of garbage collection _can_ be a good thing.
00:44:02 <Pseudonym> Because for a high-performance server environment, you need to free resources as soon as you can.
00:44:19 <Pseudonym> When objects hold files, or locks, you need to kill the objects straight away.
00:44:25 <Lamarck> ok
00:44:34 <Pseudonym> For applications, we have a scripting language with GC, and that's great.
00:46:58 <Pseudonym> I like GC as a rule.
00:47:07 <Pseudonym> It has a positive effect on my programming.
00:47:32 <Pseudonym> However, there are (rare) occasions when it does more harm than good.  For our customers, just about every cycle counts.,
00:47:44 <Pseudonym> And our object lifetimes aren't very complex.
00:48:52 <Lamarck> I suspect my dislike of C++ comes from a lack of experience, and being set in my C ways.
00:49:22 <Lamarck> Oh, and the buggy C++ compiler I used to use :)
00:49:38 <Pseudonym> That wouldn't help.
00:49:50 <Pseudonym> I think you also have to be solving problems which C++ is good for.
00:50:00 <Pseudonym> I tried to write a compiler in C++ once.  Never again.
00:50:11 <Pseudonym> It's a very poor fit, IMO.
00:50:13 <Lamarck> It's a little depressing when your program crashed the *compiler*.
00:50:33 <Lamarck> Er, when my program did I mean.
00:50:45 <Pseudonym> Yeah, I got what you meant. :-)
00:50:51 <Lamarck> :)
00:50:58 <Pseudonym> GCC uses garbage collection internally.
00:52:11 <Pseudonym> Oh, and another thing to note is that you still can use GC techniques in C++.
00:52:15 <Pseudonym> Reference counting is very common.
00:52:22 <Lamarck> Ok
00:52:34 <Pseudonym> Smart pointers make it quite easy.
00:53:02 <Lamarck> Hopefully one day someone will write a perfect GC :)
00:53:12 <Pseudonym> There is no such thing.
00:53:19 <Pseudonym> No single GC will be perfect for every situation.
00:53:19 <Lamarck> Well, it depends on the domain
00:53:24 <Pseudonym> Exactly.
00:53:34 <Pseudonym> Real-time GCs, for example, are very important in some places.
00:53:53 <Pseudonym> But they're going to be suboptimal in other places.
00:54:03 <Lamarck> I like the simplicity of mark and sweep, the low-latency of incremental, and the neatness of tricolour
00:54:13 <Pseudonym> Yeah.
00:54:26 <Pseudonym> I like the efficiency of generational techniques, too.
00:55:03 <Lamarck> I also like to sit and write my code with no knowledge of what the interpreter is going to do with my memory :)
00:55:26 <Pseudonym> Which is good, but not always appropriate.
00:55:33 <Lamarck> yeah
00:55:38 <Pseudonym> Most of the time I think it probably is appropriate, though.
00:55:45 <Pseudonym> To be honest, database servers are atypical.
00:55:45 <Lamarck> It's fine when just writing a newsgroup reader, which is what I'm doing at the moment.
00:56:09 <Pseudonym> Most programs are not interactive.  Those that are spend a lot of the time waiting for the next keystroke or mouse move.
00:56:50 <Pseudonym> Actually, there's a good example.
00:57:18 <Pseudonym> Non-interactive programs want GCs optimised for low overhead and good cache locality.
00:57:32 <Pseudonym> Interactive programs want GCs which can be stopped.
00:57:59 <Pseudonym> The original Sun JVM did this, I think.
00:58:23 <Pseudonym> It would start a GC when the system was idle.  Then if an event happened which needed attention, it would just stop the GC and start again when it was idle next time.
00:58:50 <Lamarck> yep
00:59:01 <Lamarck> Thats my favourite way of doing it actually
00:59:10 <Lamarck> A slow but simple GC which I just turn off most of the time
01:01:06 <Pseudonym> For a compiler, though, that's not always suitable because a compiler is CPU bound.
01:01:13 <Pseudonym> Or RAM bound.
01:02:27 <Lamarck> hmm I've never written a compiler
01:02:35 <Lamarck> Not counting Forth :)
01:02:53 <Pseudonym> I've written several.
01:11:46 <Lamarck> Anyway, I'm off. Have fun!
02:59:37 --- topic: '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","lots of cool debs in the haskell-experimental archive - see http://haskell.org/hawiki/DebianUsers","ghc rpms - http://haskell.org/~petersen/rpms/ghc/","new monads tutorial http://www.nomaware.com/monads/html/"]'
02:59:37 --- topic: set by Pseudonym on [Wed Sep 03 16:38:41 2003]
02:59:37 --- names: list (clog Nate75Sanders shapr Heffalump galority Malik skylan polli keverets apmuf d33p hdaume Flarelocke mattam mgoetze|away YveDeLarc jak yazirian emu SyntaxPolice ludde adept tic Riastradh isomer Darius reffie ibid Hipo phubuh vegai whee asmodai norpan lambdabot Strike xkb dennisb Lor nothome_bob2 el_diego cm earthy Igloo kosmikus gdsx sjj Lunar^ wax andersca o3 Rafterman Cale smkl Smerdyakov)
03:00:38 <Lunar^> shapr: Happy birthday
03:13:55 <shapr> yay!
03:44:58 <Igloo> You know what they say, life begins at 40  :-)  (happy birthday)
03:45:24 <Igloo> (actually you might not know what they say, I dunno)
03:47:04 * shapr grins
03:47:08 <shapr> I didn't know that.
03:51:43 <Igloo> It originates from how some sort of maid in England was thrown out onto the streets when they reached age 40, so it's probably not surprising, although I'm surprised TV hasn't caused it to spread
03:52:03 <d33p> my birthday too too
03:52:12 <shapr> d33p: cool, how old are you?
03:52:15 <Igloo> Cool
03:52:21 <d33p> iam 20 now
03:52:28 <Igloo> base 10?  :-)
03:52:31 <d33p> yes
03:52:59 <shapr> only twelve years younger than me
03:53:17 <d33p> i have to wait 4 years for a ^2 age 
03:53:28 <d33p> er.. make that 12 
03:53:39 <shapr> well, you had one four years back
03:53:40 <d33p> i didnt get smarter.. thats for sure :)
03:53:53 <d33p> word
03:54:06 <d33p> happy birthday shapr
03:55:02 <shapr> thanks!
03:55:14 <d33p> np :)
03:59:59 <Igloo> "if times were normal we'd release 6.2 in two or three weeks. But times are not entirely normal.  Simon M is about to become a father [so it may be longer]" </SPJ>
04:01:03 <Heffalump> I thought the bit about the human child was the best bit.
04:01:14 <Igloo> :-)
04:03:20 <shapr> :-)
04:11:57 <kosmikus> Heffalump: pong
04:13:50 <shapr> hej tic 
04:13:55 <tic> halloj shapr
04:14:02 <tic> shapr, fyller du år idag?
04:14:08 <shapr> ja!
04:14:14 <tic> grattis! :)
04:14:18 * tic noterar i sin Palm.
04:14:22 <shapr> jag är en ålder nu!
04:14:33 <kosmikus> happy birthday shapr
04:14:33 <tic> hur gammal?
04:14:43 <shapr> kanske en gubbe ..
04:15:15 <shapr> trettitvååringen!
04:15:21 <shapr> kosmikus: thanks!
04:15:32 <shapr> Bea brought me a cake shaped like a banana
04:15:38 <tic> 32? heh.
04:15:41 <tic> oh, yum
04:15:45 <tic> i'd like one of them.
04:15:46 <tic> maybe I should
04:15:49 <tic> and skip school today
04:15:50 <shapr> they're quite tasty
04:15:59 <shapr> school is good! don't skip school!
04:16:21 <tic> we only have a two-hour physics session left noday
04:16:22 <tic> today
04:16:34 <tic> I think I'm going to study at home instead, do maths.
04:16:53 <tic> shapr, you're a -71, right?
04:17:11 <shapr> eh?
04:17:21 <tic> shapr, if you're 32?
04:17:31 <shapr> is that a signed int or something?
04:17:41 <tic> 1971?
04:17:46 <Heffalump> kosmikus: I was hoping you might understand Ralf's FOP chapter :-)
04:17:47 <shapr> oh, right
04:17:53 <tic> hehe. real world stuff =)
04:18:11 * tic takes a note: #haskell: shapr fyller, -71.
04:18:16 <shapr> yah :-)
04:18:17 <kosmikus> Heffalump: until now at least I thought I did, but you can certainly convince me otherwise :)
04:18:26 <tic> yearly event. there.
04:18:42 <tic> shapr, then you're 11 years and four days older than I am.
04:18:46 <Heffalump> kosmikus: I'm trying to type the stuff in there in
04:18:55 <Heffalump> so using the translation for "with" based on equality types
04:19:07 <shapr> tic: you have your birthday in four days?
04:19:13 <shapr> oh, they do name days here in sweden, right?
04:19:23 <kosmikus> okay
04:19:32 <Heffalump> the Normalisation by Evaluation section is causing me problems
04:19:43 <kosmikus> I'll have to get the book
04:19:52 <tic> shapr, err. younger, I meant.
04:20:01 <tic> shapr, 14th sept
04:20:12 <tic> shapr, "name days" ?
04:20:12 <Heffalump> do you have time?
04:20:23 <kosmikus> okay, have the book now
04:20:30 <shapr> tic: in Finland, you don't celebrate on your birthday, you celebrate on your 'name day'
04:20:31 <kosmikus> at the moment, I can spare about 15 minutes
04:20:41 <shapr> so all the people named 'Ari' celebrate on the same day
04:20:43 <kosmikus> later this afternoon I have more time ...
04:20:46 <Heffalump> right :-)
04:20:50 <vegai> there's no future in finnish
04:21:00 <shapr> vegai: heh, that's punny.
04:21:01 <vegai> that explains a lot
04:21:05 <tic> shapr, aha. We celebrate both, the birthday a bit more htough.
04:21:06 <tic> though.
04:21:12 <tic> shapr, same thing in poland, they only celebrate on the "name day"
04:21:34 <Heffalump> ok, so the problem I have is with reflect
04:21:46 <Heffalump> translating the datatypes for Type and Term, I get this:
04:21:49 <Heffalump> data Type t =              RBase  (Base   :=: t)
04:21:49 <Heffalump>             | forall a b . TypFun ((a->b) :=: t) (Type a) (Type b)
04:21:51 <shapr> tic: what happens if you have a weird name that doesn't have a name day?
04:21:54 <Heffalump> data Term t = forall a b . App (b      :=: t) (Term (a->b)) (Term a)
04:21:54 <Heffalump>             | forall a b . Fun ((a->b) :=: t) (Term a -> Term b)
04:22:03 <Heffalump> actually, I should put that online instead of spamming the channel
04:22:19 <shapr> unless we can learn something from the discussion :-)
04:22:27 <Heffalump> you can see the URL too
04:22:29 <shapr> the downside of reading channel logs with urls is that the urls go away
04:22:43 <Heffalump> hmm, true
04:22:44 <shapr> that would be the good point of a pastebot
04:22:48 <tic> shapr, you approximate. :)
04:22:51 <shapr> if the pastebot records that sort of stuff
04:22:52 <Heffalump> ok, I'll keep pasting
04:23:06 <Heffalump> anyway, the last clause of reflect in the book is:
04:23:13 * shapr considers a paste plugin for lambdabot 
04:23:22 <Heffalump> reflect (ra :-> rb) e = \x -> reflect rb (App e (reify ra x))
04:23:37 <Heffalump> now, this needs to be translated to pass around the equality witnesses
04:24:24 <Heffalump> so in my code it becomes:
04:24:36 <Heffalump> reflect (TypFun p ra rb) e = from p $ \x -> reflect rb (App ? (to (term p) e) (reify ra x))
04:24:45 <Heffalump> the problem is what ? should be.
04:25:02 <kosmikus> okay, at least I understand the question :)
04:25:02 <Heffalump> p is a proof of (a->b) :=: t
04:25:16 <Heffalump> but ? should be a proof of b :=: t1
04:25:29 <Heffalump> so I need something on proofs of type
04:25:39 <Heffalump> (a->b) :=: (a->c) -> b :=: c
04:25:44 <Heffalump> and it doesn't seem possible to write it
04:26:08 <Heffalump> (or at least, I don't see how to, which is rather different :-)
04:26:10 <kosmikus> yes, this is a problem which is known, I think
04:26:48 <Heffalump> ah. Is it fixable?
04:26:54 <kosmikus> which implementation of :=: do you use?
04:27:10 <Heffalump> the one in the book
04:27:18 <Heffalump> newtype a :=: b = Proof { apply :: forall phi . phi a -> phi b }
04:27:26 <kosmikus> okay
04:28:37 <kosmikus> in this particular case, I think it is possible to fix
04:29:27 <kosmikus> the general problem is that in Haskell, f a == g b always implies f == g and a == b on the type level
04:29:54 <kosmikus> this cannot be implemented generically
04:29:56 <Heffalump> yeah, I understood about trying to get around the first-order unification with type synonyms
04:30:06 <Heffalump> I just couldn't see how to deal with it here
04:36:18 <kosmikus> I have to think about it for a while
04:37:10 <Heffalump> ok :-)
04:38:52 <shapr> g'day CowGirl 
04:38:59 <CowGirl> hey, how are u?
04:39:06 <shapr> I'm awake!
04:39:08 <shapr> and I'm old today.
04:39:12 <shapr> I'm 32!
04:39:17 <CowGirl> what time u usually head to bed?
04:39:21 <CowGirl> happy birthday!!!
04:39:35 <shapr> I have no set time for sleeping
04:39:38 <shapr> it's a variable.
04:39:48 <CowGirl> generally then, what time??
04:40:08 <kosmikus> Heffalump: www.informatik.uni-bonn.de/~ralf/publications/Phantom.pdf contains a discussion of this problem, as far as I remember
04:40:12 <shapr> usually between 11pm to 11am
04:40:28 <CowGirl> u sleep during the day??
04:40:32 <shapr> sometimes, yes
04:40:45 <Heffalump> kosmikus: ta
04:40:52 <CowGirl> i just ask...cause i stay up late to...usually till 3, and eventually it catches up with me
04:41:15 <shapr> I've decided that anything past 6am is too late for me
04:42:12 <CowGirl> so how many hrs a day would u sleep total??
04:42:22 <shapr> anywhere from three to twelve
04:42:33 <CowGirl> can u function on three hrs?
04:42:36 <shapr> sure
04:42:48 <shapr> though that's about the minimum.
04:42:57 <CowGirl> i cant!! 
04:43:04 <shapr> I'm sorry.
04:43:28 <CowGirl> :)
04:43:45 * shapr grins
04:45:56 <CowGirl> what happened to those 2 unsw students...anyone know??
04:46:21 <shapr> I heard their instructors executed them, and then forgot to save them.
04:46:47 <Heffalump> which two UNSW students?
04:46:49 <shapr> er, weren't they irc bots?
04:47:13 <CowGirl> the ones that were killed on barker st. in the apartment
04:47:23 <Heffalump> kosmikus: hmm, is it buried in the typing rules stuff? I can't spot anything obvious about it.
04:47:23 * shapr was joking :-(
04:47:29 <shapr> CowGirl: what are you talking about?
04:51:03 <CowGirl> it was on the news
04:51:09 <CowGirl> around the beginning of the week
04:51:14 <CowGirl> look at the unsw homepage
04:51:15 <shapr> yikes
04:51:17 <Heffalump> we don't all live in Australia
04:51:27 <CowGirl> we had a minute silence today
04:51:36 <CowGirl> i know, but there are a few here from the uni
04:54:46 <kosmikus> Heffalump: look at the function encoding for generalized tries in Section 2.3, and then later at the Section about the "Decomposition rule"
04:55:25 <Heffalump> ahh, ta.
04:56:21 <Heffalump> right, I sort of see.
04:57:04 <Heffalump> so is there actually a fix for the specific code in the chapter?
05:00:50 <CowGirl> whats another way of writing the lines function?
05:09:38 <CowGirl> anyone?
05:10:02 <Darius> What's one way so I know it's not the one you don't want? 
05:10:36 <CowGirl> im looking at the actual prelude function, but dont fully understand it..
05:10:47 <CowGirl> is there another way to do it.... maybe in 2 functions??
05:11:30 <Darius> Lookup the break function
05:11:39 <adept> CowGirl: same code written in two functios will be more clear? :)
05:11:45 <adept> @type break
05:11:46 <lambdabot> break :: (a -> Bool) -> [a] -> ([a],[a])
05:12:05 <adept> @eval break (==' ') "abc 123"
05:12:05 <lambdabot> (line 1, column 8):
05:12:05 <lambdabot> unexpected "="
05:12:05 <lambdabot> expecting simple term
05:12:12 <adept> @eval (break (==' ') "abc 123")
05:12:12 <lambdabot> (line 1, column 9):
05:12:12 <lambdabot> unexpected "="
05:12:12 <lambdabot> expecting simple term
05:12:30 <adept> anyway, that will be ("abc", "123"). Helps?
05:12:30 <shapr> @get-definition break
05:12:31 <lambdabot> break not defined
05:12:48 <adept> shapr: what's the proper syntax for "eval"?
05:12:53 <shapr> eval is a lambda calculus interpreter, not a full Haskell implementation
05:13:00 <adept> shapr: ah
05:13:11 <shapr> I've been tempted to hook up Hugs or ghci, but I don't know how I can make them safe
05:14:00 <Darius> eval doesn't do sections
05:15:29 <Darius> and the prelude is implemented on demand
05:17:18 <Darius> I've been thinking about changing to a slightly more Haskell syntax for lambda abstractions
05:17:20 <Lunar^> (break (==' ') "abc 123") => ["abc", "123"] anyway
05:19:13 <CowGirl> lines :: String -> String
05:19:13 <CowGirl> lines [] = []
05:19:13 <CowGirl> lines (x:xs)
05:19:13 <CowGirl> 	| x ==  ('\n') = (' ') : lines xs
05:19:13 <CowGirl> 	| otherwise = x : lines xs
05:19:13 <CowGirl> lines' :: String -> [String]
05:19:15 <CowGirl> lines' [] = []
05:19:17 <CowGirl> lines' x = words (lines x)
05:19:21 <CowGirl> thats one way i did it
05:19:28 <CowGirl> in 2 functions
05:19:58 <adept> CowGirl: are you sure it works?
05:20:18 <adept> seems like forall x: words x == lines' x
05:20:30 <CowGirl> yeah, hiding the lines function, and use the lines' function to test
05:21:13 <CowGirl> seems to work!
05:22:08 <adept> btw, your lines could be put this way: "lines x = map (\c -> if c == '\n' then ' ' else c) x" 
05:22:33 <adept> CowGirl: what is (lines' "abc 1234\ndef 456") ?
05:22:52 <Darius> @definitions l
05:22:52 <lambdabot> ["last","lcFalse","lcIf","lcTrue","length","lexeme","liftLP","liftS","list","listen","local","lookup","lookupDef","lookupRef","lookupTree"]
05:23:53 <CowGirl> adept: it is   -   ["abc", "1234" , "def" , "456"]
05:25:22 <adept> CowGirl: and it sould be [ "abc 1234", 'def 456"], right?
05:25:54 <CowGirl> yeah... the commas!
05:26:05 <adept> CowGirl: which commas?
05:26:24 <adept> CowGirl: lines' x = words (lines x) seems the wrong way to do it ...
05:27:16 <CowGirl> how could u fix that up?
05:27:32 <Darius> CowGirl: There are two nested loops so you should have two recursive functions.
05:27:45 <adept> CowGirl: first, write program in English ... Then - translate to Haskell
05:28:29 <CowGirl> what about taking the head.....
05:30:28 <adept> CowGirl: yes, what about it?
05:31:33 <CowGirl> drawn a blank!
05:31:41 <adept> ??
05:32:54 <Darius> CowGirl: So take adept's advice, and tell us in English how lines is supposed to work.
05:33:55 <CowGirl> if ur given  =   "\nonetwo\nthree\nfour"
05:34:22 <CowGirl> the output is ["onetwo", "three" , "four"]
05:34:58 <CowGirl> so with the function i did, if x == \n  then  (' ') :  lines xs
05:35:05 <adept> CowGirl: dont try to program by example. Tell us without using examples how lines is supposed to work
05:35:54 <adept> CowGirl: and if you want to stick with examples, take nontrivial ones like "a b\nc 123\n\n\n9\t8\nd".
05:36:39 <CowGirl> takes a string with newlines (\n) and returns a list of strings
05:36:58 <Darius> What list of strings?
05:37:05 <CowGirl> with newline characters removed
05:37:50 <adept> CowGirl: removed? so "a b\nc" -> "a bc" ?
05:38:06 <CowGirl> yeah
05:38:14 <CowGirl> but in a list of string
05:38:17 <CowGirl> ... so
05:38:29 <CowGirl> ["a" , "bc"]
05:38:45 <CowGirl> wait..
05:38:46 <CowGirl> sorry
05:38:49 <adept> CowGirl: so, once again, in English: how "lines" work?
05:39:04 <CowGirl> ["a b" , "c"]
05:39:11 <adept> thats not english
05:39:14 <Darius> Not what it does, but how does it do it.
05:39:22 <CowGirl> no, i was correcting myself from that example
05:40:08 <CowGirl> the program i wrote goes thru the list, if it comes to \n then it removes it and puts a space there
05:40:22 <adept> CowGirl: and then?
05:40:58 <CowGirl> then it turns that into a list of string
05:41:16 <adept> CowGirl: how?
05:41:28 <CowGirl> its turning it into the list that im stuck..where the \n is one string....
05:42:01 <CowGirl> cause before i used words, but that turns each string into a seperate string
05:42:08 * shapr watches his web browser crash and burn
05:42:18 <adept> CowGirl: so your program is wrong. Big deal. Write another one, from scratch. Start with telling us why do you want to replace '\n' with spaces in the first place
05:42:40 <CowGirl> so if u have \nonetwo\n... i want to to output ["onetwo"]  
05:43:28 <CowGirl> why i want to??  its an exercise out of a book
05:43:57 <Darius> shapr: ?
05:44:01 <CowGirl> im going thru them, and got stuck on this one
05:44:20 <shapr> Darius: what?
05:44:33 <shapr> Darius: oh, I just crashed my browser in a spectacular way
05:44:37 <shapr> it looked very cool.
05:46:02 * Darius is reminded of a demo group, I think, called "Creative Reboot"
05:46:15 * Darius is also reminded of the joys of assembly.
05:46:42 <shapr> heheh
05:52:22 <adept> CowGirl: Start with telling us why do you want to replace '\n' with spaces in the first place. Why this is needed to achieve your goal?
05:54:07 <adept> CowGirl: Or I can rephrase - why not, for example, replace '\n' with '9'? What is the reason behind replacing '\n' and why replacement is ' '?
05:55:12 <shapr> emacs is a spiffy editor, I can edit files that are remote, via multiple inbetween hops
05:55:17 * shapr bounces cheerfully
05:55:26 <adept> shapr: tramp?
05:55:29 <shapr> yup
05:55:34 <shapr> stuff like /[multi/ssh:user@host/sudo:root@localhost]/etc/apt/sources.list
05:57:11 <shapr> I wish I had something like gcc/emacs/Linux/etc when I was sixteen and learning about programming.
05:57:18 * andersca did
05:57:18 <andersca> :)
05:57:31 <shapr> I just realized that was sixteen years ago today
05:57:33 <shapr> sheez
05:57:33 * adept _almost_ did :)
05:57:38 <Lunar^> Is there something in the standard lib to get a temp file ?
05:57:47 <andersca> shapr: tomorrow I'll be 22 years old
05:57:51 <shapr> Lunar^: I've seen some code for that go past on the mailing list
05:58:15 <shapr> andersca: in some ways I'm jealous of the 'ease of learning' you yngarna have :-)
05:58:39 <shapr> in other ways, I'm really happy I missed the continually worsening school drug problems in the western culture
05:58:43 <Darius> There's an implementation of a mktemp like function in haskell-libs.
05:58:47 <andersca> shapr: well, I really learned programming on my old 286 machine
05:58:50 <Lunar^> shapr: ghc?
05:59:00 <shapr> Lunar^: yes, it was for ghc
05:59:07 <shapr> right, it was mktemp actually
05:59:17 <shapr> Marvin-- put it into haskell-libs
05:59:36 <shapr> andersca: is it yngarna?
05:59:48 <andersca> shapr: ni ungar = you kids
05:59:52 <shapr> heh
06:00:23 <Darius> shapr: How would a school drug problem affect you substantially?
06:00:50 <shapr> I have a tendency to try new things, and overdo anything I enjoyed the first time.
06:01:00 <shapr> that's great when it's programming...
06:01:46 * Darius remembers adept's (?) advice earlier
06:01:56 <shapr> what advice was that?
06:02:58 <shapr> gutentag Malik 
06:03:01 <Lunar^> http://www.haskell.org/pipermail/cvs-all/2003-May/027345.html
06:03:15 <Lunar^> But I can't see it anywhere now 
06:03:36 <shapr> Lunar^: iirc, it's in the hlibs darcs repo
06:03:46 <Lunar^> nice
06:04:16 <shapr> Malik: nice pic
06:04:42 <Malik> shapr: eehh.... what pic?
06:05:03 <andersca> shapr: rrrrrRRRR!!!
06:05:08 <andersca> shapr: you know what tomorrow is
06:05:14 <andersca> shapr: http://www.talklikeapirate.com/
06:05:18 <Malik> shapr: sure i'm the one you think i am? :)
06:05:27 <shapr> Malik: no, are you Rico?
06:05:33 <Malik> shapr: no
06:05:40 <shapr> andersca: what's tomorrow? other than your birthday?
06:05:44 <shapr> Malik: oh, who are you?
06:05:46 <Darius> shapr: That Bea not get you alchohol for your birthday
06:05:49 <Malik> shapr: i'm just chatting from his host
06:05:52 <shapr> Darius: ah, good point
06:06:06 <andersca> shapr: see the url
06:06:19 <Lunar^> That give an Hadnle
06:06:31 <Lunar^> I would just need a filename actually
06:06:56 <shapr> andersca: heh!
06:07:05 <andersca> Avast!
06:07:08 <shapr> arr!
06:07:10 <andersca> shapr: I bought an eye-patch
06:07:14 <andersca> and a big ear ring
06:07:33 * shapr laughs!!
06:07:33 <Darius> no, it was isomer
06:07:37 <shapr> I want to see pictures of that!
06:07:56 <isomer> heard my name
06:07:59 <isomer> what did i do?
06:08:18 <andersca> shapr: I'm pondering wearing it to the seminar course 
06:09:01 <Darius> * isomer hopes bea doesn't buy shapr any alcohol!
06:09:38 <isomer> hehe...oh yeah :)
06:09:39 <Lunar^> I think I'm gonna interface tmpnam
06:11:18 <isomer> thank god
06:11:28 <isomer> coffee's ready 
06:11:35 * isomer sips happily
06:24:00 <reffie> hi hi hi hi hi hi
06:24:18 <shapr> hello reffie 
06:24:32 <reffie> wassup?
06:24:42 <shapr> hacking on Zope, wassup with you?
06:25:04 <reffie> just came back from class
06:25:18 <reffie> chillin'
06:25:29 <reffie> waitin' for the next class.
06:28:04 * isomer had some major zope success yesterday
06:28:43 <shapr> isomer: what did you do?
06:29:05 <shapr> I'm trying to figure out how to use Archetypes to generate CMFTypes instances on the fly from a database.
06:30:43 <isomer> i got apache to serve zserver pages as if they were being served from apache :)
06:31:06 <isomer> what is/are archetypes?
06:32:18 <shapr> template types
06:32:37 <shapr> he's back!
06:32:54 <shapr> How are you, Mr. Sittampalam?
06:34:48 <shapr> isomer: CMF (Content Management Framework) has complex types that know how to render themselves
06:35:26 <Heffalump> busy :-)
06:35:32 <shapr> they're mostly composed of simpler bits and pieces, and Archetypes makes that explicit, and allows you to construct larger more complicated CMFTypes from existing smaller bits, or bits you've created yourself.
06:36:12 <isomer> shapr: oh, that's cool.
06:36:40 <isomer> i'm really just starting to learn zope. so far, mostly as a lu^H^Huser
06:44:43 <shapr> isomer: I'm not an expert, but I know some stuff. 99% of my income from the last coupla years has been from Zope work.
06:46:32 <shapr> yay! it's ONLINE! http://www.cs.kent.ac.uk/projects/refactor-fp/hare.html
06:46:59 * adept scribbles in the notebook "shapr - Zope expert". Aha ...
06:47:13 <shapr> adept: clueful maybe, but not expert :-)
06:47:31 <shapr> the more I learn about Zope, the more I realize I want it rewritten in Haskell.
06:47:51 <adept> shapr: yes!!!! :))))))))
06:48:00 <isomer> hehe
06:48:03 <Darius> are you sure it's not the more you learn about Haskell? 
06:48:14 <shapr> no, I already know Haskell kicks ass :-)
06:48:23 --- topic: set to '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","lots of cool debs in the haskell-experimental archive - see http://haskell.org/hawiki/DebianUsers","ghc rpms - http://haskell.org/~petersen/rpms/ghc/","new monads tutorial http://www.nomaware.com/monads/html/","Haskell Refactorer - http://www.cs.kent.ac.uk/projects/refactor-fp/hare.html"]' by shapr
06:50:40 <Heffalump> anyone use hugs with cpp?
06:51:13 <shapr> My major question about a Haskell rewrite of Zope is about the Haskell mindset...
06:51:40 <shapr> Zope includes an object database, and all the content and presentation stuff is in there, so it's uniformly addressable
06:51:53 <yazirian> My major question about a Haskell rewrite of Zope is who the hell wants to use DTML? :)
06:51:56 <shapr> but I wonder if that's the right 'Haskellesque' solution
06:52:10 <shapr> yazirian: ZPT is good enough that I'd use it in Hope with very little changes.
06:53:05 <shapr> the time consuming parts of Zope for me are usually tracking through the sources to figure out just where some foo is being set, and what its value should be when the bar is in state baz, etc etc
06:53:07 <yazirian> except if you look up 'scalable' in a thesaurus, it's listed under antonyms :)
06:53:16 <shapr> for ZPT?
06:53:24 <shapr> I think it's scalable.
06:53:34 <shapr> how is it not scalable?
06:53:34 <yazirian> well, I can't talk about Zope 3 'cause I don't know 
06:53:38 <shapr> nor do I
06:54:06 <shapr> like I said, I'm a user, not an expert, so I'd like to hear what you think
06:54:35 <SyntaxPolice> g'mornin' #haskell
06:54:36 <shapr> with Zope, like emacs, I realize it's the solution that sucks the least
06:54:49 <shapr> I haven't actually found much that sucks in Haskell.
06:54:52 * isomer ways to SyntaxPolice
06:55:00 <isomer> waves, even
06:55:00 <SyntaxPolice> isomer: way!
06:55:03 <SyntaxPolice> oh
06:55:04 <shapr> way!
06:55:06 <isomer> :)
06:55:14 <shapr> surfs up on the web...
06:55:32 <shapr> download your free copy of HaRe - the Haskell refactor - today!
06:56:23 <yazirian> I am a user too, but I know two guys who are very experienced with it
06:56:47 <yazirian> One develops and admins it for a high-traffic real estate site, the other is a Plone developer
06:56:52 <Igloo> Syn: I'll probably look at the ghci thing in a few days
06:56:58 <yazirian> and I have heard enough horror stories about DTML to make me stay the hell away from it :)
06:58:47 <SyntaxPolice> Igloo: no hurry, IU don't actually use it on that box, I was just trying it out
06:59:05 <SyntaxPolice> shapr: that is the most rantingist web page I've ever seen 
06:59:11 <SyntaxPolice> well, maybe not the _most_
07:00:41 <yazirian> ZPT might be cool. Don't ask me. :)
07:05:34 <SyntaxPolice> so who was saying that for category theory that the Lawvere book is better than the Pierce book?
07:06:54 <jao> SyntaxPolice: it was me
07:07:19 <SyntaxPolice> jao: and you have both books? can you tell me more?
07:07:20 <SyntaxPolice> :)
07:08:03 <jao> yep, i do. Pierce's book is a quick intro for math savvy readers that
07:08:11 <jao> need the facts quick
07:08:36 <jao> Lawvere's is a tutorial for beginners
07:08:41 <jao> longer
07:09:05 <jao> and, mind you, it doesn't shy away for rather sophisticated stuff
07:09:12 <jao> despite its slower pace
07:09:26 <jao> very rich in examples and concepts
07:09:51 <jao> while Pierce shows you the formalism and explains less the conceptual background
07:10:02 <SyntaxPolice> hm. sounds good. I tried reading the pierce book, and didn't get it, but had a math friend show me through a bit
07:10:06 <SyntaxPolice> s/show/walk
07:10:28 <SyntaxPolice> I see. is Lawvere's more geared toward computer science types?
07:10:52 <jao> hm. not really...
07:11:08 <jao> Lawvere is more geared toward beginners of any field
07:11:42 <jao> matter of fact, prolly Pierce makes more stress on CS stuff
07:11:54 <jao> but is easier to miss the point
07:12:00 <jao> (at least for me)
07:12:17 <jao> i'd first read L. to grasp a sound understanding of the concepts
07:12:34 <jao> and then go for P. for CS particulars
07:14:16 <SyntaxPolice> I see.
07:16:05 <earthy> jao: do you know how Category Theory for Computer Science (Barr & Wells) compares?
07:16:40 <jao> earthy: no, i don't
07:16:49 <earthy> 'kay.
07:18:51 <Heffalump> I thought that wasn't available any more
07:19:03 <earthy> Heffalump: yes, it is, still.
07:19:15 <earthy> see http://www.cwru.edu/artsci/math/wells/pub/ctcs.html
07:21:09 <SyntaxPolice> jao: OK I'm goign to see if I Can get that out of th elibrary :)
07:22:01 <jao> SyntaxPolice: good luck! i hope you enjoy it as much as i did :)
07:22:19 <SyntaxPolice> jao: me too :)
07:22:58 <jao> in any case, i'll be glad of hearing your opinion on it
07:25:02 <SyntaxPolice> I'll let you know.
07:25:07 <SyntaxPolice> @yow
07:25:08 <lambdabot> Wait..  is this a FUN THING or the END of LIFE in Petticoat Junction??
08:06:59 <Igloo> http://yaws.hyber.org # web server in Erlang
08:25:03 <SyntaxPolice> shapr: on #osuoss the bot now has @yow capability. I think you should sue
08:27:54 * shapr laughs
08:28:12 <shapr> there's a surprised party at my house... hmm
08:28:20 <shapr> and I'm the surprised one...
08:28:48 <SyntaxPolice> shapr: wow, cool.
08:28:57 * SyntaxPolice pouts that he didn't get invited ;)
08:29:20 <shapr> well, Bea arranged the guest list
08:29:30 <shapr> you should ask her about it :-)
08:29:39 <shapr> speaking of which, she's on #webwitches in the mornings
08:29:45 <SyntaxPolice> cool
09:00:01 * Flarelocke tests if /me works
09:00:11 * Flarelocke is glad it does
09:13:06 * Cale is away: lecture
09:14:13 <Igloo> Syn: I'll be doing another nhc98 upload soonish to remove the hmake dependency and fix the make clean rules. I conjecture the hppa failure is 64-bit related, although it doesn't seem to be showing the normal symptoms.
09:27:04 * Igloo gets confused about the bitness of hppa
09:40:03 <alanl> helloL
09:40:04 <alanl> ?
09:40:07 <hdaume> hi
09:41:00 <alanl> can someone explain how this works?
09:41:02 <alanl> http://www.xoltar.org/2003/sep/09/haskellLoops.html
09:42:22 <hdaume> what's your question?
09:42:54 <alanl> last time I checked, variables aren't mutable...
09:43:16 <hdaume> when you're in the io monad, you can use IO refs which are references and are mutable
09:43:36 <Igloo> http://www.haskell.org/ghc/docs/latest/html/base/Data.IORef.html
09:43:56 <alanl> right.....now is the category theory in that horific?
09:44:04 <hdaume> ? no
09:44:09 <hdaume> there is no category theory in it
09:44:48 <hdaume> you can do the same without io refs by using a simple state monad
09:45:09 <Igloo> Hmmm, I think you should be able to do something like a C for loop quite incely once you have untyped TH quasi-quotes
09:45:10 <alanl> so IORefs are just plain dirty von neumann variables?
09:45:53 <Igloo> Only nastiness would be the whole thing having to be in a splice
09:46:02 <Igloo> Hmmm, so nesting wouldn't work very nicely
09:46:02 <ski> but still we don't have side-effecting computations
09:47:13 <Smerdyakov> alanl, conceptually, IORef's are stored inside the IO monad value that is passed around.
09:47:25 <Smerdyakov> alanl, in real implementation, they're probably done in the usual imperative way.
09:49:15 <alanl> are there any plans to have while loops and so forth being put in a standard haskell library
09:49:16 <alanl> ?
09:49:40 <alanl> or are they just too evil?
09:50:01 <ski> sometimes i would like a scheme named-let in haskell
09:50:13 <hdaume> i have my own Util.Imperative library which holds stuff like that, but i highly doubt they'd make it into a standard library...most of them are really short anyway and there's no need
09:50:27 <ski> it is a kind of loop (IMO)
09:50:30 <hdaume> 'foreach [1..10] ...' isn't much worse than 'flip mapM_ [1..10] ...'
09:50:48 <hdaume> s/worse/better
09:50:58 <Igloo> The trouble with putting this sort of IORef stuff into a library is that more people would use it
09:51:55 <alanl> true....my lecturer is not going to be pleased when he finds out you can have mutable variables in haskell....at the very least this'll have to be on the "prohibited constructions" list
09:52:23 <Heffalump> your lecturer being Manuel?
09:53:18 <alanl> manuel is quite supportive of io in haskell....its someone called richard you'll probably haven't heard of
09:53:49 <Heffalump> ah, ok
09:54:03 <Igloo> I'm fairly sure they aren't in Haskell 98, although you could do horrible stuff with the filesystem
09:54:52 <alanl> btw, we did some funky stuff with haskell...
09:54:55 <alanl> http://www.cse.unsw.edu.au/~cs1711/project/photos/P7030062.JPG
09:55:28 <alanl> this was the little version...we ended up building this huge thing for open day
09:55:36 <alanl> need to find some photos for that
09:55:55 <ski> is it brio ?
09:56:02 <phubuh> that's a nice chi^H^H^Htrack!
09:56:38 <alanl> and I assume you don't need to be told what the ai was written in
09:57:15 <phubuh> what does the AI do?
09:57:59 <alanl> control the forks and stops so the trains don't crash into each other
09:58:07 <phubuh> ah, i figured
09:58:29 <Igloo> Who's in that photo?
09:58:37 <phubuh> what university is this, if you don't mind me asking?
09:58:41 <alanl> unsw
09:59:04 <alanl> I'll probably do a write up on the mega huge version we had for open day
09:59:40 <alanl> in otherwords, the same place where chilli is
10:01:47 <alanl> here was the original spec
10:01:49 <alanl> http://www.cse.unsw.edu.au/~cs1711/project/spec.html
10:05:45 <alanl> can someone tell me what Data.Generics does?
10:05:56 <alanl> man theres so many new modules
10:10:42 <kosmikus> Heffalump: ping
10:11:00 <Heffalump> pong
10:11:11 <kosmikus> I've finally had time to look at your problem again
10:11:19 <Heffalump> cool, thanks
10:11:26 <kosmikus> I think that you don't need the aforementioned function
10:11:40 <kosmikus> can't you just put "refl" for the "?"
10:11:42 <kosmikus> ?
10:11:46 * Heffalump --> try
10:12:58 <Heffalump> oh, so I can :-)
10:13:08 <kosmikus> ah, so I thought ;)
10:13:19 * Heffalump thinks about why it works
10:13:26 <Heffalump> oh, of course
10:13:37 <kosmikus> reify ra x  gives you a  Term a
10:13:45 <Heffalump> it wouldn't in a more complicated situation, but here the type variable is just being unified with another type variable anyway
10:13:45 <kosmikus> the transformed e is   a -> b
10:13:48 <Heffalump> so it just works
10:14:16 <kosmikus> yes, it works in surprisingly many situations
10:14:37 <kosmikus> I think any of the FOP-paper examples are actually doable with the eq-type encoding
10:14:43 <Heffalump> goodgood
10:15:17 <kosmikus> there is one evil hack that one can use if one wants to do something as I first thought you would need ...
10:15:46 <kosmikus> use an "unsafe" equality type: data a :=: b = Iso { from :: a -> b, to :: b -> a }
10:16:01 <Heffalump> right
10:16:40 <kosmikus> now, if you know that  a -> b :=: a -> c, and want to infer that b :=: c ...
10:16:49 <kosmikus> ... you can "construct" a function "a -> b" from a "b" by using "const"
10:16:54 <ski> can one make an arrow of that ?
10:17:04 <kosmikus> and you can go back from the resulting function by passing "undefined"
10:17:08 <kosmikus> evil, but works
10:17:11 <Heffalump> I was thinking about doing something like that too
10:17:22 <Heffalump> does it actually run OK, though? I thought the undefined would end up causing an error.
10:17:28 <Heffalump> Oh, I guess it ends up being passed to const.
10:18:05 <kosmikus> yes, you put in that knowledge that the undefined will only be applied to a const
10:18:41 <kosmikus> that's why it's unsafe -- because it depends on you doing that correctly, the compiler won't check that
10:19:12 <kosmikus> ski: you want to make the equality type an instance of Arrow?
10:19:20 <ski> yes
10:19:50 <ski> it seems left and first and so on would preserve the bijection
10:20:13 <kosmikus> I don't think you can
10:20:20 <ski> but the evil arr :: (a -> b) -> ar a b is in the way !
10:20:31 <kosmikus> yes
10:20:38 <kosmikus> wouldn't know how to define that
10:20:42 <kosmikus> also doesn't make sense
10:20:46 <ski> that should be relegated to a subclass
10:21:15 <ski> put idAr :: ar a a in Arrow class instead. unit of >>>, good :)
10:22:31 <kosmikus> then it should work, but I guess that the current intuition about Haskell Arrows very much depends on "arr"
10:22:32 <ski> there doesn't seems (yet) to be as much agreement about the structuring of the arrow classes as for the monad ones
10:22:42 <Igloo> Yay, someone might be getting ghci to work on alpha
10:22:50 <ski> kosmikus : why ?
10:23:28 <ski> also, first should not be in Arrow, of course
10:23:43 <shapr> varför inte?
10:24:01 <kosmikus> ski: ;)
10:24:04 <ski> it is dual to left
10:24:08 <shapr> alanl: do you use the dvorak keyboard layout?
10:24:44 <ski> we could have e.g.
10:24:53 <kosmikus> I think an "equivalence relation" class would be more appropriate for :=: ...
10:25:02 <ski> class Arrow ar => ArrowProduct f ar
10:25:05 <ski>   where
10:25:21 <ski>   aFst :: ar (f a b) a
10:25:30 <ski>   aSnd :: ar (f a b) b
10:25:49 <ski>   aPair :: ar x a -> ar x b -> ar x (f a b)
10:25:58 <ski> or something like that
10:26:10 <ski> then we can have
10:26:33 <ski> instance ArrowProduct Either ASP
10:27:19 <ski> (where ASP is Asynchronous Stream Processor IIRC)
10:28:26 <kosmikus> I guess that no one keeps you from designing your own class hierarchy and doing useful things with it; the only good reason I could see to demand that "Arrow" should be defined differently is if you want to use "arrow notation" on something you cannot define a good "Arrow" instance for; but I am not sure whether something like "arrow notation" would make sense for a type like :=: ...
10:28:45 <ski> kosmikus : but it seemed that many (most) arrow operations had a natural definition for :=:
10:29:50 <ski> the problem with Arrows is : what formulation shall we use ?
10:30:05 <ski> not sure what is good/best
10:32:26 <kosmikus> yes, but as I see it, there are pretty convincing examples that you can do useful things with the current Arrow class definition
10:33:10 <kosmikus> I am afraid that :=: is too much different in characteristic, so that if you would redefine Arrow to allow :=: to be a member you would lose other functionality
10:33:31 <kosmikus> for instance, Arrows are inherently a "directed" thing, :=: is not
10:34:21 <ski> kosmikus : so yes of course i can try to develop an own arrow class hierarchy (which i have dome almost umpteen times ;) but i don't know how it should look like. is there some theory, like say category theory, which we can invoke to get a good structure ?  It feels like monads have better backup from that direction ....   just thinking around ..
10:34:25 <kosmikus> for :=:, you have a very natural function a :=: b -> b :=: a, which would not be natural at all for most arrows
10:35:37 <ski> i'm scared of excluding (not too exotic) useful arrows by chosing the wrong structure/framework (like instance ArrowProduct Either ASP)
10:36:31 <ski> kosmikus : but can't we have to usual old functionality of Arrows in a subclass, just not in the base super-class ?
10:36:54 <ski> kosmikus : i'm not sure that Arrows are inherently directed
10:37:23 <kosmikus> what would it buy you? why not just define your own class?
10:38:02 <ski> yes, the just define foo :: a :=: b -> b :=: a outside the class, specific to :=:, no problem
10:38:55 <ski> i want a unified general framework. i want, i want :-P
10:39:09 <kosmikus> I think that there is a design choice to be made between a reasonable simple class hierarchy and one that allows maximal code reuse.
10:40:22 <ski> yes, but is there a greater systematic diversion of arrows than of monads  (in terms of the common general framework, not type-specific operations) ?
10:41:48 <ski> it seem like we easily get a multitude of subclasses to Arrow, while Monad only has MonadPlus (had MonadZero IIRC)
10:42:12 <kosmikus> I agree here -- but if you really want a different class hierachy to become official, you should probably just write one and propose it -- my CT knowledge is far too limited to do such a thing
10:42:28 <ski> hmm, should one count in the MonadState,etc things into the general Monad framework also ?
10:42:51 <ski> mine too ;(
10:43:00 <ski> i think
10:44:25 <kosmikus> personally, I don't use arrows much, not even monads ...
10:45:21 <ski> comonads would be interesting to see more examples of (and better explanations)
10:46:04 <kosmikus> agreed -- however, I never had the time to look at the existing examples and explanations closely, so I guess I am not in a position to complain
10:46:31 <ski> .>> seems evil to me
10:48:30 <kosmikus> what's .>> ?
10:49:04 <kosmikus> ah, already found it
10:49:25 <ski> its on the wiki i think
10:57:37 <kosmikus> Heffalump: your question is completely answered now, right?
10:58:43 <Heffalump> yep, thanks.
10:58:55 <Heffalump> I've been implementing an evil Show instance to go with reify :-)
10:59:23 <kosmikus> what does it do?
10:59:37 <Heffalump> well, prints out lambda terms
10:59:51 <Heffalump> but it uses unsafePerformIO for the name supply
11:00:03 <ski> reify ?
11:00:09 <ski> monadic reify ?
11:00:10 <Heffalump> and is a bit hard to understand cos I tried to make it short and quick to write
11:00:10 <kosmikus> ah, that's why it's evil
11:00:17 <Heffalump> and it only correctly prints out beta-normal terms
11:12:44 <reffie> shitty weather
11:59:56 * Cale is back (gone 02:46:49)
12:59:11 <Xcalibor> hi
13:01:26 <ski> hi
13:02:48 <keverets> lo
13:19:38 <shapr> y0
13:19:42 <shapr> hi Binkley 
13:19:55 * shapr boing
13:20:00 <Binkley> yo
13:20:03 <shapr> wassup?
13:20:12 <Binkley> trying to get GHC to build
13:20:38 <Binkley> and working on grad school applications... I'm not sure which sucks worse
13:20:51 <shapr> heh
13:21:02 <shapr> what sort of GHC building problems are you having?
13:21:18 <Binkley> Well, it would be straightforward if I hadn't made various horrible changes to the code
13:21:39 <shapr> ah
13:22:44 <Binkley> I'm not sure why changing the Prelude definition of (++) to a different, equivalent one would cause stack overflows in compiled programs. But anyway.
13:23:02 <yazirian> Sunspots.
13:23:17 <Binkley> ~~Heh
13:23:19 <Binkley> Good call
13:24:12 * shapr laughs at http://www.cse.unsw.edu.au/~cs1711/project/photos/P7030059.JPG
13:24:19 <keverets> Perhaps because it's not really equivalent?
13:24:41 <Binkley> heh
13:25:02 <Binkley> No, it's equivalent: (++) xs ys = foldr (:) ys xs
13:25:20 <Binkley> I suspect it's because I didn't remove the rewrite rules having to do with (++)
13:25:34 <shapr> can you remove them now?
13:25:42 <Binkley> Yeah, I'm building it without the rules now
14:14:13 <shapr> has Exception changed with ghc6 ?
14:19:00 <Smerdyakov> Binkley, what's the usual (++) definition?
14:19:09 <Smerdyakov> @prelude ++
14:19:11 <lambdabot> *** "++" prelude "Haskell Standard Prelude Dictionary": text follows
14:19:11 <lambdabot> ++
14:19:11 <lambdabot>   See (++)
14:19:15 <Smerdyakov> @prelude (++)
14:19:17 <lambdabot> *** "(++)" prelude "Haskell Standard Prelude Dictionary": text follows
14:19:18 <lambdabot> (++)
14:19:20 <lambdabot>   infixr 5 ++
14:19:22 <lambdabot>   (++) ::  [a] -> [a] -> [a]
14:19:24 <lambdabot>   []     ++ ys      = ys
14:19:26 <lambdabot>   (x:xs) ++ ys      = x : (xs ++ ys)
14:25:42 <ski> bye
14:33:30 <Binkley> Yeah, that's the one :-)
14:45:41 * Igloo remembers how much I hate nhc
14:45:50 <Darius> Has my recent slew of posts on c.l.f gotten my email picked up by several virus infected computers?
15:09:25 <Xcalibor> Darius: i've gotten a lot of viruses/emails this afternoon
15:09:29 <Xcalibor> as well...
15:10:05 <Xcalibor> most from skynet.be (disguised as M$ network patch or as an AOL qmail automatic reply)
15:10:09 <Riastradh> Xcalibor and Darius, were they claiming to be related to Microsoft tech support or security updates or something?
15:10:31 <Riastradh> That's funny.  I got a bunch of them, too, to an address that I'd never gotten any spam in.
15:10:32 <Xcalibor> Riastradh: yup
15:11:31 <Xcalibor> Riastradh: i run a strings on the executable: usual stuff, disguise itself, sent itself by email,,, contained interesting strings like XXX Videos, KazaA, Sircam, Klez, etc...
15:59:22 * Igloo remembers how much I hate hmake
16:00:23 <jewel> x
16:10:41 <Darius> Riastradh, Xcalibur left: yes, as well as ones claiming to be "undeliverable mail".  I've been getting a few every now and then but I've gotten like 20+ today.
16:11:27 <Darius> I wouldn't really care but they are 150kb each and I have a 56k line.
16:44:06 <reffie_> olen omena, olen omena, olen pyöreä omena, olen omena, olen omena, olen punainen omena!
16:50:10 <jewel> olen?
21:08:59 <isomer> @yow
21:09:00 <lambdabot> NANCY!!  Why is everything RED?!
21:09:04 <isomer> @yow
21:09:04 <lambdabot> ..  One FISHWICH coming up!!
21:09:07 <isomer> @yow
21:09:07 <lambdabot> .. If I cover this entire WALL with MAZOLA, wdo I have to give my
21:09:07 <lambdabot>  AGENT ten per cent??
21:22:10 <harsha123> adept: hello
21:22:30 <Pseudonym> G'day.
21:22:46 <harsha123> Pseudonym: hi..
21:23:19 <isomer> hi
21:23:41 <isomer> this is already more fun than chatting with lambdabot in the wee hours of the night :)
21:33:33 <syntax-laptop> isomer: what could BE MORE fun than CHATTING with LAMBDABOT?!
21:34:05 <harsha123> hehehe... thank Pseudonym hez one of the creators.. :)
21:35:02 <harsha123> @karma harsha
21:35:03 <lambdabot> harsha has a karma of 0
21:40:18 <syntax-laptop> @karma SyntaxPolice
21:40:19 <lambdabot> SyntaxPolice has a karma of 0
21:40:21 <syntax-laptop> bah
22:17:38 <harsha123> @help
22:17:38 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
22:17:51 <harsha123> @listcommands
22:17:52 <lambdabot> I react to the following commands: ["all-dicts","define","definitions","del-definition","devils","dict","dict-help","dummy","dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements","eval","foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","lojban","more","msg","part","prelude","quit","reconnect","
22:18:06 <harsha123> @hitchcock
22:18:37 <harsha123> @fortune
22:18:39 <lambdabot> My apologies if I sound angry.  I feel like I'm talking to a void.
22:18:39 <lambdabot> 	-- Avery Pennarun
22:18:50 <harsha123> @fortune
22:19:10 <harsha123> @fortune
22:19:10 <lambdabot> We interrupt this fortune for an important announcement...
22:19:16 <harsha123> @fortune
22:19:16 <lambdabot> "Who is General Failure and why is he reading my hard disk ?"
22:19:16 <lambdabot> Microsoft spel chekar vor sail, worgs grate !!
22:19:16 <lambdabot> (By leitner@inf.fu-berlin.de, Felix von Leitner)
22:19:27 <harsha123> @fortune
22:19:28 <lambdabot> What an artist dies with me!
22:19:28 <lambdabot> 		-- Nero
22:19:32 <harsha123> @fortune
22:19:32 <lambdabot> "The molars, I'm sure, will be all right, the molars can take care of
22:19:32 <lambdabot> themselves," the old man said, no longer to me.  "But what will become 
22:19:32 <lambdabot> of the bicuspids?"
22:19:32 <lambdabot> 		-- The Old Man and his Bridge
22:19:48 <harsha123> @fortune
22:19:49 <lambdabot> You go slow, be gentle.  It's no one-way street -- you know how you
22:19:49 <lambdabot> feel and that's all.  It's how the girl feels too.  Don't press.  If
22:19:49 <lambdabot> the girl feels anything for you at all, you'll know.
22:19:49 <lambdabot> 		-- Kirk, "Charlie X", stardate 1535.8
22:23:42 <vegai> suggestion: apt-get install fortunes (or something to that effect)
22:26:09 <harsha123> vegai: thnx.. was just trying out lambdabot.. wouldnt work here.. so just testing it out
23:47:02 <Pseudonym> harsha123: You know that lambdabot will talk to you privately if you want.
23:47:06 <Pseudonym>  /msg lambdabot @fortune
23:49:36 <harsha123> Pseudonym: Ok :) ill do that.. 
23:50:34 <lambdabot> I can do anything!  I am omnipotent!
23:54:48 <lambdabot> Except solving the halting problem, obviously.
