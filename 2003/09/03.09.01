00:21:48 <Coastal> I've a quick and silly question...
00:22:11 <Coastal> What is the preferred way to convert between strings and ints in Haskell? 
00:22:19 <andersca> read and show?
00:22:36 <Coastal> Hrm.  Ok, thanks.  That means I've another problem.  :/
00:26:15 <Coastal> Heh.  Using read where I should have been using show.
00:33:34 <Heffalump> :-)
00:34:39 <Coastal> Hooya.  First Haskell program compiles.
00:34:56 <Pseudonym> Rejoice!
00:35:00 <Pseudonym> G'day all.
00:35:12 <Heffalump> 'lo
00:35:21 * Heffalump declares it not the weekend
00:35:26 <Pseudonym> How was ICFP?
00:37:33 <Coastal> ICFP?
00:37:39 <Pseudonym> I think we need a new container type Definitely to go with Maybe.
00:38:01 <Pseudonym> International Conference on Functional Programming
00:38:07 <Lor> Morning.
00:38:14 <Pseudonym> Most of #haskell was there last week.  It was really quiet.
00:38:21 <Pseudonym> G'day.
00:38:30 <Pseudonym> Well, most of the noisy ones were there, anyway.
00:38:58 <Coastal> Ah.
00:46:22 <Pseudonym> Night all.
01:25:18 <shapr> coi Igloo 
01:25:25 <shapr> ma nuzba
01:31:17 <shapr> hoi kosmikus !
01:31:19 <shapr> hoe gaat?
01:31:37 <kosmikus> hej
01:31:48 <shapr> heh
01:31:59 <shapr> yay, a swedish response!
01:32:12 <andersca> hej
01:32:21 <shapr> hej andersca 
01:32:42 <shapr> kosmikus gave a cool talk about Generic Haskell at the conference
01:32:53 <andersca> cool
01:42:50 <shapr> hi pseiko 
01:43:02 <shapr> hello Binkley 
01:43:07 * shapr wonders if Binkley is sleeping
01:45:03 <Lor> Hi, Shae.
01:45:16 <shapr> hi Lor!
01:45:28 <shapr> hyvää huomenta!
01:45:34 <Lor> Huomenta.
01:46:42 <shapr> mittä kuuluu?
01:47:29 <shapr> so you did get back to .fi successfully?
01:47:54 <Lor> Eventually, yes.
01:48:52 <shapr> my favorite part of the conference was the way Daan Leijen says "bugs"
01:49:18 <shapr> boogs
01:49:21 * shapr laughs
01:49:52 <shapr> Lor: did you find any interesting pursuits at the conference?
01:49:55 <ibid> how does one pronounce "boogs" :)
01:50:05 <RibRib> hello
01:50:18 <Lor> Pursuits? As in things to pursue further?
01:50:19 <RibRib> is there a function that counts how many elements there are in a string?
01:50:27 <Lor> length
01:50:32 <shapr> ibid: Daan says the u in bugs halfway between ew and oo
01:50:34 <ibid> RibRib: yes
01:50:46 <RibRib> what about in a list?
01:50:48 <shapr> RibRib: did you get a textbook for your course?
01:50:57 <kosmikus> RibRib: strings are lists
01:51:11 <shapr> Lor: yes, things to pursue
01:51:24 <ibid> shapr: my problem is that i cannot really "hear" ew and oo :)
01:51:42 <RibRib> what about a function to count how many words there are in a string?
01:52:07 <ibid> it's all there
01:52:09 <adept> RibRib: what about a function which produces words from string and counts them? ;)
01:52:10 <Lor> Well, yeah. Lots. More than I have the time for right now...
01:52:28 <shapr> hi adept 
01:52:35 <shapr> did you get the ASN.1 stuff figured out?
01:52:36 <adept> shapr: 
01:52:58 <adept> shapr: got vacation for two weeks instead :)
01:53:31 <shapr> yay
01:54:05 <adept> plus, I'm looking forward for Strafunski being remade ...
01:55:07 <adept> RibRib: look up Haskell reference at zvon.org, for instance
02:00:08 <whee> uuh, any clue why "if not $ null matches then putStr "somestring" else return ()" works if on one line, but turns into a parse error on the "else" clause if I put it on multiple lines? heh
02:00:42 <Lor> Depends on how you split it into lines.
02:01:10 <Lor> Align the "then" and "else" and it should work.
02:01:20 <whee> err, hrmf
02:01:34 <whee> I thought you'd align the if and else
02:01:42 <whee> same error, anyway :\
02:01:48 <shapr> if turns into a case statement
02:02:14 <Lor> Actually, I think that "if" is pretty ugly and redundant.
02:02:42 <shapr> it is redundant, but I think it's very clear that you only have two options in the case statement
02:02:48 <shapr> plus it's really short
02:02:54 <shapr> compared to making a full case statement
02:03:02 <shapr> hm, maybe you're right
02:03:07 <Lor> Case matching on a bool is much clearer, and if you want conciseness, then you don't even need special syntax: test t b1 b2 = if t then b1 else b2
02:03:25 <whee> I'll use whichever one parses :P
02:04:00 <Lor> Mind you, this is the one example that is always used with scheme to demonstrate why you need macros. :)
02:04:04 <whee> and case wins :P
02:07:04 * adept . o O ("i rest my 'case' ...")  :)
02:07:22 <shapr> hah
02:10:03 <shapr> I talked to SPJ about using darcs on haskell.org
02:10:41 <adept> whats "darcs" ?
02:10:51 <shapr> http://www.abridgegame.org/darcs/
02:11:00 <Lor> How did the workshop discussion end? I had to leave after the record talk.
02:11:21 <shapr> that was pretty much it
02:11:37 <shapr> HIM was the next two days in Stockholm
02:12:31 <Lor> Did the implementors decide on anything?
02:12:40 <shapr> I don't know
02:12:55 <shapr> oh, you probably don't mean just about records
02:13:12 <adept> shapr: hmm... sounds interesting. actually, much more interesing than svn...
02:13:14 <shapr> the most interesting decision was that wxHaskell seems like the most promising GUI toolkit
02:13:31 <shapr> adept: I'd be happy to give you write access to the #haskell darcs repo on ScannedInAvian.org
02:13:38 <shapr> you just need to give me your public key
02:13:57 <adept> shapr: which email?
02:14:25 <shapr> you can send it to shae  at Scanned In Avian dotcom
02:14:58 <Lor> Uh. Are you afraid of email-stealing spambots even in irc?
02:15:04 <adept> shapr: dot com or dot org?
02:15:11 <shapr> Lor: yes
02:15:20 <adept> Lor: yep. IRC logs tend to get published on web ...
02:15:21 <shapr> adept: send the email to dot com
02:15:31 <shapr> but the darcs repo is on dot org
02:15:51 <shapr> mostly from DNS laziness on my part
02:23:53 * shapr runs in very small circles
02:24:07 <shapr> hey adept, did you see my privmsg?
02:27:19 <shapr> hoi earthy 
02:27:23 <shapr> hoe gaat?
02:28:07 <shapr> the hole in my knee is still too large for unicycling :-(
02:29:13 <shapr> hi semaj 
02:29:19 <shapr> looking for Haskell programmers?
02:29:31 <semaj> hi shapr
02:29:33 <shapr> writing a compiler for PHP?
02:29:45 <semaj> no 
02:29:47 <semaj> :)
02:29:59 <shapr> er, no to which one?
02:29:59 <semaj> i work with php
02:30:07 <semaj> both
02:30:30 <semaj> haskell is an interest in a couple of projects 
02:30:42 <shapr> what sort of projects?
02:31:12 <semaj> at this moment just thinking about it :)
02:31:42 <shapr> I also think Haskell is interesting.
02:31:58 <shapr> I've done some projects in Haskell.
02:33:02 <shapr> do you have any specific questions about Haskell?
02:33:02 <semaj> i belive that the level of abstraction that haskell demands for programming guives us the possibility off pushing forward our ideas in programming :)
02:33:13 <semaj> no thanks
02:33:24 <shapr> well, it doesn't demand abstraction, but it does offer more abstraction than anything else I've seen.
02:33:43 <shapr> well, unless you hire someone else to program something... in that case you have more abstraction :-)
02:34:04 <semaj> i belive it demands abstraction, but like i said i am just here to think about it 
02:34:41 <semaj> you probably are alot more expert in the subject than i
02:34:45 <shapr> have you used Haskell before?
02:35:15 <semaj> yes, i have done somethins with haskell for the past here
02:35:27 <shapr> hm, I need some lambda pom-poms
02:35:32 <semaj> mainly study and researsh
02:35:35 <semaj> :)
02:35:37 <semaj> lol
02:35:44 <semaj> and you what have you done
02:35:58 <shapr> I've written some code in lambdabot
02:36:08 <semaj> nice
02:36:15 <shapr> I've been paid to write some XML transform code in Haskell
02:36:29 <shapr> I wrote a prototype of a bayesian spam filter in Haskell
02:36:39 <shapr> can't think of anything else
02:36:57 <shapr> anyways, you can see all of my released code in the #haskell darcs repo
02:37:04 <shapr> along with code from lots of other people
02:37:45 <shapr> I make most of my money from Zope/Python work, I'd like to switch to Haskell as much as possible
02:38:09 <shapr> sadly, Haskell doesn't have as much support for web development and database integration as Python
02:38:18 <shapr> I guess that's not surprising since the user community is smaller.
02:38:46 <shapr> semaj: if you know what sort of projects you want to do, I can probably direct you to libraries and apps that are related.
02:39:33 <shapr> I can point you to some Haskell demo code I've written, it shows off some basics of Haskell
02:39:44 <shapr> or I can point you to the lambdabot sources, which are much more interesting.
02:41:03 * shapr considers writing an inspirational pamphlet about Haskell.
02:41:22 <shapr> re semaj 
02:41:37 <semaj> re you all
02:41:39 <semaj> :)
02:41:49 <semaj> decided to change server
02:42:06 <shapr> did you get what I said about libraries and sources?
02:42:39 <semaj> nop
02:42:41 <semaj> sorry
02:42:52 <semaj> <shapr> along with code from lots of other people
02:42:56 <shapr> aha
02:43:03 <semaj> thats the last one i got 
02:43:06 <shapr> I said I make money from Zope/Python, would like to switch to Haskell
02:43:30 <shapr> and that I can point you to various haskell sources, from simple to complex
02:43:41 <shapr> and some other stuff
02:43:48 <shapr> but you can read the logs if you really want to see the other stuff :-)
02:44:23 <semaj> i might say that you seem very nice person, :)
02:44:27 <shapr> heh, thanks
02:45:24 <shapr> I think Haskell is powerful and fun tool, and I'd like to share my realization ;-)
02:46:12 <shapr> adept: ok, you have write access to the #haskell darcs repo
02:46:36 <shapr> adept: do you know how to check out the code and commit changes?
02:46:41 <semaj> do you belive that there is a solid market of aplication for sutch knowlege
02:46:52 <adept> thanks a lot. as soon as aptitude -u finished updating my lists, i'll try to checkout and start reading docs
02:46:53 <shapr> it's in the darcs manual, but I dunno if you want to wade through it.
02:46:57 <shapr> ok
02:47:01 <shapr> semaj: yes, very much so.
02:47:05 <adept> shapr: no, not reaaly yet. in progress :)
02:47:23 <adept> shapr: but i know already that first thing is --get :) 
02:48:18 <shapr> I know of two Haskell-specific companies, and several others that use Haskell but just sell a software product.
02:48:37 <shapr> I think PHP is one of the strongest proofs of the power of Haskell actually ;-)
02:48:38 <semaj> could you guive there names pls
02:48:51 <shapr> sure, look for reid consulting and galois connections
02:49:11 <shapr> I've met the guy who runs and owns galois connections, they've recently expanded into a bigger building
02:49:20 <shapr> and I've heard they'll be hiring more Haskell programmers soon.
02:50:02 <shapr> aetion uses Haskell for much(most? ) of their work
02:50:34 <shapr> several companies use Haskell for prototyping and other languages for implementation
02:50:57 <semaj> i am looking at those companies now :)
02:51:29 <shapr> the reason I think PHP is a good proof of Haskell's usefulness is that Haskell is very good at writing Domain Specific Languages
02:51:39 <shapr> and imho, PHP is one of the most profitable DSLs
02:51:41 <whee> fuh, does ghc bundle any gui libraries? :|
02:51:49 <shapr> whee: try wxHaskell
02:51:53 <shapr> wxHaskell.sf.net
02:52:02 <shapr> I don't think any are bundled
02:52:03 <whee> well, I don't want to require anything other than ghc
02:52:18 <shapr> you'll have to require a GUI library of some flavor as well
02:52:29 <shapr> unless you want to be platform specific
02:52:35 <whee> it's a really simple program so heh
02:53:06 <shapr> I think GHC comes with Xlib bindings :)
02:53:41 <whee> http://smaerty.ath.cx/rtest/ <- if you're bored, tell me I'm an idiot :)
02:53:52 <shapr> adept: oh, the repo address is http://www.ScannedInAvian.org/repos/hlibs/
02:54:10 <whee> I want to abstract the whole display part (probably a type class for that), but I'm not sure if it's worth it
02:54:18 <whee> and there's no comments :(
02:54:50 <shapr> @seen syntaxpolice
02:54:50 <lambdabot> I haven't seen syntaxpolice
02:54:54 <whee> all this thing does is read some text files and let you type in a regular expression to match against the strings; it shows all the matches :|
02:55:02 <shapr> neat
02:55:25 <shapr> did you consider using interact?
02:55:32 <shapr> I'm not sure that's the right func name
02:55:32 <adept> whee: regexplorer alike?
02:55:58 <whee> well it's a rewrite of a perl script I wrote a couple years ago, and that used readline; I wanted to provide the same functionality and rerelease
02:56:25 <shapr> oh, I think I saw a minimal readline reimplemenation go by on the lists a month ago or so
02:56:27 <whee> adept: I've never seen regexplorer, maybe
02:57:03 <whee> it's not as complicated as regexplorer, that's for sure :P
02:57:08 <adept> whee: take a look at regexplorer and visual-regexp - they are neat. I've used them on daily basis year ago ...
02:58:03 <shapr> whee: check out interact
02:58:22 <whee> shapr: doesn't that just read in a line and call some function?
02:58:37 <whee> I have the readline part going; that's included with ghc
02:58:53 <whee> I was just hoping there'd be a minimal gui toolkit library that was also included :\
03:04:10 <shapr> actually, SPJ and several others have been trying to trim GHC down to a much smaller size
03:04:29 <shapr> personally, I hope they cut off some of the built-in libraries.
03:04:30 * semaj is away: soccer :)
03:05:35 <whee> I could go for a haskell CPAN
03:06:34 <ibid> CHAN? :)
03:07:03 <whee> works for me :P
03:10:08 <shapr> SyntaxPolice is the head of the Library Infrastructure Project (aka LIP service)
03:10:45 <ibid> heh :)
03:11:14 <shapr> part of his plan is to allow higher level services on top of LIPs, for example, a CHAN
03:12:34 <shapr> he has some very cool ideas
03:13:16 <shapr> right now, hmake does a some of the stuff that LIPs would need to do, so he wants to turn hmake into a library
03:13:24 <shapr> the basic idea is "steal distutils from python"
03:14:42 <whee> I think it'd be nice to be able to distribute programs with a freebsd-style ports system, where things are downloaded as they're needed
03:15:09 <whee> well, could probably even do this easily with something like a-a-p
03:15:20 <shapr> well, work on LIPs and we can easily build that on top
03:15:39 <whee> I'm a horrible haskell coder, I doubt I could help much :P
03:15:54 <shapr> if you write horrible code that works, I'm sure other people can clean it up
03:16:07 <shapr> getting something that works is the most important part
03:23:35 <whee> I suppose
03:24:04 <whee> any web sites for LIPs?
03:24:11 <shapr> mostly a wiki page right now
03:24:24 <shapr> http://www.haskell.org/hawiki/LibraryInfrastructure
03:32:12 <kosmikus> shapr: already downloaded GH? ;)
03:32:19 <shapr> not yet
03:32:25 <shapr> I'm sposed to be doing paying work :-/
03:32:40 <kosmikus> ah
03:32:49 <shapr> but I can take a short break :-)
03:35:46 <shapr> ok, I got it.
03:59:51 <whee> meh, can someone help me with these type classes :|
04:00:40 <whee> wait, nevermind
04:01:23 <mgoetze> whee: ok, i won't
04:01:58 <whee> I think I'm just entirely confused :)
04:02:58 <whee> I want to have a type class that contains two functions, and what they do depends on the instance obviously
04:03:24 <shapr> yah?
04:03:27 <whee> well, anyway
04:04:01 <whee> I'm getting (The instance type must be of form (T a b c) where T is not a synonym, and a,b,c are distinct type variables) errors :)
04:04:35 <whee> I have a "class OutputDevice t a b where ..." declaration, and then "instance OutputDevice TerminalOutput File Flag where ..", and that's where I'm getting that error
04:05:08 <whee> File and Flag are both data types, and TerminalOutput is a newtype TerminalOutput = TerminalOutput () (which is probably the problem)
04:05:20 <shapr> are you using multiparameter typeclasses and functional dependencies?
04:05:41 <shapr> what do your instance methods look like?
04:05:58 <whee> the signatures?
04:06:05 <shapr> and code
04:06:25 <whee> one is :: a -> IO (), other is :: [b] -> IO (); all they do is putStr some things to the terminal
04:06:40 <whee> but adding -fglasgow-exts did seem to let that part work :\
04:06:50 <shapr> you probably want to use class OutputDevice a where
04:07:05 <shapr> and say instance OutputDevice (TerminalOutput File Flag) where
04:07:15 <shapr> oh wait
04:07:20 <shapr> I see
04:07:22 <whee> what about the class declaration
04:07:51 <whee> I just wanted to specify that these are two different times, and may or may not be the same with each instance
04:07:56 <whee> s/times/types/
04:08:24 <shapr> what are your method names?
04:08:38 <whee> showFile and showFlags
04:09:07 <shapr> could you use the Show typeclass?
04:09:09 <whee> the idea is there's an instance of OutputDevice with these functions and it gets the data to show on whatever device it supports
04:09:12 <shapr> hej ski, hur är det med dig?
04:09:14 <ski> shapr : hi
04:09:20 <ski> bra
04:09:28 <whee> so the TerminalOutput just throws it to the terminal, but a GUI one would handle it differently
04:10:13 <shapr> whee: I think it'll make your life easier if you use "class OutputDevice a where" and then pattern match on the TerminalOutput constructor in the left hand side of the showX methods
04:10:39 <shapr> of course, I'm mostly saying that because I don't know how to use multiparameter typeclasses
04:10:44 <shapr> so that's how I would do it.
04:10:47 <whee> and that does sound easier
04:11:06 <whee> I'll have to check the docs on the multiparameter type classes
04:11:14 <whee> I figured since this already requires GHC, can't hurt to get into the extensions :)
04:11:22 <shapr> many people would argue with that
04:12:11 <shapr> one slide at the conference said "Is Haskell defined in terms of GHC?"
04:12:37 <ski> heh
04:12:43 <whee> all the fun stuff ends up in GHC; I don't see it changing until the next version of the haskell standard
04:13:01 <shapr> there's fun stuff in other implementations also
04:13:09 <shapr> like TRex
04:13:11 <shapr> in hugs
04:14:00 <shapr> hej ski, vad gör du?
04:14:08 <ski> and like restricted typesynonyms
04:14:35 <shapr> admittedly, the lack of network support in other implementations limits my actual usage to GHC
04:14:38 <ski> shapr : jag gor nastan inget just nu :)
04:14:45 <shapr> heh
04:14:54 <shapr> har du resat till ICFP ocksa?
04:15:05 <ski> njet :(
04:15:09 <shapr> det var i Uppsala
04:15:15 <ski> horde det
04:15:19 <shapr> crap, I don't know past tense
04:15:30 <ski> (re : rest ?)
04:15:37 <shapr> huh?
04:15:47 <ski> (regarding "rest"/"resat" ?)
04:16:07 <shapr> I wanted to say "it was in Uppsala"
04:16:27 <ski> det var i Uppsala  ar val korrekt
04:16:31 <shapr> jaså
04:16:43 <ski> men resat ar fel
04:17:44 <shapr> rest är rätt?
04:17:54 <ski> yes box
04:18:05 <shapr> box?
04:18:37 <ski> its an old "figure of speak" (of sorts)
04:18:49 <shapr> oh, ok
04:18:57 <shapr> I was at ICFP/HW/HIM, it was fun!
04:19:42 <ski> Svenska Dagbladet have written about it's possible origins not too long ago (the full form is "yes box alright", the origins are debated)
04:19:46 <ski> cool
04:19:59 <whee> shapr: if I use "class OutputDevice a", what should I be using for the types of the two functions, does it matter?
04:20:04 <ski> er, what does HW & HIM stand for ?
04:20:13 <whee> wait, nevermind. heh
04:20:14 <shapr> Haskell Workshop, Haskell Implementors Meeting
04:20:19 <ski> 'kay
04:20:32 <whee> I think multi-parameter type classes are neater than this :)
04:21:05 <ski> whee : what does OutputDevice do ??
04:21:48 <whee> just a couple functions that output devices need to have in this case
04:22:43 <shapr> ski: maybe you'll come to the next ICFP?
04:23:22 <shapr> det var inte så daligt ;-)
04:25:20 <shapr> there was much niftyness at ICFP
04:25:26 <shapr> the coolest parts were the tool demos I think
04:25:36 <mgoetze> where is the next ICFP?
04:25:44 <shapr> probably in Salt Lake City, but it might be Chicago
04:25:53 <mgoetze> oh, over the ocean
04:26:03 <shapr> yah, a short hop to the new world
04:27:46 <whee> hah, something I could actually go to
04:27:58 <whee> although I wouldn't, anyway :\
04:30:01 <shapr> why not?
04:31:23 <whee> I think it'd be all over my head
04:31:35 <shapr> gezeik
04:31:42 * adept wonders if hslibs/chess was ever compiled ...
04:31:50 <shapr> adept: it was... but...
04:32:17 * adept tries to compile with ghc6. omg ....
04:32:36 <shapr> whee: lots of stuff at ICFP was over my head, my plan is that by next year, at least half of this year's stuff won't be over my head.
04:32:54 <shapr> well, except for the stuff that didn't interest me
04:34:06 <adept> whats this: Warning: Definition but no type signature for `scorePos'? Never saw something like this before....
04:34:18 <shapr> adept: at the moment, you probably don't want to try to compile chess
04:34:37 <adept> shapr: ;) But I do :)
04:34:40 <shapr> ah, ok then
04:35:10 <adept> shapr: play even compiles and runs. But I dont like warnings at all, especially when I dont understand them
04:35:34 <shapr> oh, I think something like -Wall is on in the makefile
04:35:43 <adept> shapr: does it mean that there will be moment to compile and run them in the future? :) Or i will have to make one myself?
04:35:50 <shapr> huh?
04:35:55 <shapr> oh, yes..
04:35:59 <shapr> fixing chess is on my list
04:36:22 <shapr> though I practice collective ownership, so if you want to fix it, I'll be thrilled.
04:36:40 <adept> shapr: indeed -Wall is there. I just dont get that warning. Does it mean that i have to provide type sig. by hand?
04:38:22 <shapr> I think it means that scorePos doesn't have a type signature, and since -Wall means "give every warning you can think of" it's telling you that.
04:38:31 <adept> ah
04:38:33 <adept> thanks
04:38:39 * adept turns off Wall
04:38:52 <shapr> obviously, you're not required to give type sigs 99.9% of the time, since type inferencing makes life wonderful
04:39:00 <shapr> re semaj 
04:39:09 <semaj> hi shapr
04:39:12 <shapr> have you seen the light and decided to become a professional Haskell programmer? ;-)
04:39:16 * shapr is joking
04:39:35 <semaj> maybe i dont have what it takes :)
04:39:38 <shapr> ohh, it's lunchtime, yay!
04:40:11 <shapr> semaj: requirements include ability to stare off into nothingness for long periods and think about the code you're writing
04:40:14 <shapr> snoring is optional
04:40:17 <whee> now I'm hungry :(
04:40:32 <shapr> yay, my woman brought me a sandwich
04:40:37 * shapr runs off
04:40:59 <semaj> shapr, whell that i already can do, in fact the landscape is my prefered IDE :)
04:41:22 <semaj> i only use the computer to test and debug 
04:44:44 <semaj> hope you have a nice lunch
04:44:47 <semaj> :)
05:05:23 <semaj> clear
05:06:02 <semaj> clear
05:21:40 * adept forgot his passphrase :(
05:23:50 <Segora> adept: those are the time when one thinks: I really SHOULD have placed a revocation certificate somewhere safe.
05:24:26 <Segora> adept: and of course a copy of the key, without passphrase
05:24:40 <adept> Segora: I have sertificate :) I dont want to revoke key, since i _almost_ remember passphrase 
05:24:46 <adept> ^ser^cer^
05:25:23 <Segora> well... think of something else. it'll spring up in the middle of the night. have paper&pen ready. ;)
05:25:45 <Segora> (and a shredder for later *g*)
05:26:07 * adept tries to find a way to make gpg each phrase from stdin
05:26:31 <Segora> expect?
05:26:41 <adept> I have haskell code which permutes given string. Exactly for situation like this.
05:27:25 <Segora> I'm not sure, but I think I've seen something like 'expect' in Haskell, too.
05:29:18 <adept> Segora: thank. expect forks.
05:29:23 <adept> ^for^wor^
05:29:32 * adept has Dyslexia Day
05:34:10 <YveDeLarc> re
05:44:56 <shapr> bonjour
05:45:48 <shapr> er, gutentag
05:46:08 <shapr> Tomasso: were you at ICFP?
05:47:31 * shapr bounces cheerfully
05:48:17 <Igloo> Hmmm, ./configure on m68k has taken more than an hour already. Why do I think it might take a while to compile GHC?
05:48:55 <Lunar^> Igloo: btw, I tried to compile GHC 4.08 on Debian/PowerPC
05:49:18 <shapr> Igloo: how fast is the m68k box?
05:49:32 <Igloo> 49.8MHz
05:49:36 <shapr> wow
05:49:47 <Igloo> Lunar: And?
05:49:49 <Lunar^> Igloo: I had to add an entry in configure.in for the architecture, but as you may expect, it fails when building because of some assembly code
05:50:02 <Igloo> *nod*
05:50:16 <shapr> can't PPC emulate m68k?
05:50:28 <Lunar^> Is Linux assembly for powerpc different from Darwin assembly for powerpc ?
05:50:44 <Igloo> I assume not or the autobuilders would take advantage of it, shapr
05:50:48 <shapr> good point
05:51:08 <Igloo> Lunar: The register names seemed to be different and I'm not sure if the calling conventions are the same or not
05:53:09 <Lunar^> Igloo: :( 
05:53:43 <Igloo> From the comments I got the impression Wolfgang hadn't been particularly fussed about getting the right one of darwin and powerpc for the ifdefs
05:56:16 <Lunar^> Wish I knew more assembly
06:03:52 <Lunar^> injectMaybe :: Monad m => (a -> m b) -> Maybe a -> m (Maybe b
06:04:00 <Lunar^> I got this... could it be possible to use fmap at some point ?
06:04:40 <Igloo> @type fmap
06:04:40 <lambdabot> fmap :: Functor a => (b -> c) -> a b -> a c
06:05:35 <Igloo> You'd need something like sequence too
06:06:32 <Lunar^> @type sequence
06:06:33 <lambdabot> sequence :: Monad a => [a b] -> a [b]
06:06:40 <Igloo> I don't think there is anything, though
06:06:42 <Lunar^> I don't have a list anywhere
06:08:17 <Igloo> I don't think you could write anything generic to do it
06:08:44 <Lunar^> thanks
06:08:48 <Lunar^> Just wanted to be sure
06:09:15 <Lunar^> injectMaybe f Nothing  = return Nothing
06:09:17 <Lunar^> injectMaybe f (Just x) = liftM Just (f x)
06:11:15 <Lor> Why not just return (x >>= f)?
06:11:25 <Lor> Maybe is a monad on its own, too.
06:12:46 <Lor> Oops, no.
06:15:12 <Lor> return (liftM f x)
06:19:55 <Lunar^> nope
06:20:57 <Lunar^> \f x -> return (liftM f x) :: forall m m1 r a1.
06:20:57 <Lunar^>                               (Monad m, Monad m1) =>
06:20:57 <Lunar^>                               (a1 -> r) -> m1 a1 -> m (m1 r)
06:21:09 <Lunar^> injectMaybe :: Monad m => (a -> m b) -> Maybe a -> m (Maybe b
06:21:28 <Lor> Ah, sorry, I didn't realize f's type.
06:21:38 <Lunar^> don't worry
07:05:37 <shapr> adept: so, what do you think of darcs so far?
07:06:01 <adept> shapr: i'll tell in 10 minutes
07:06:05 <shapr> heh, ok
07:06:08 <adept> coffee break :)
07:06:17 * shapr drinks more RC Cola
07:32:27 <Cale_> http://www.theonion.com/onion3118/rccola.html
07:35:30 <shapr> actually, RC Cola is the programmer's cola of choice in Sweden I've heard.
07:36:23 <Cale> Cool.
07:36:39 <shapr> anyways, I drink enough that our local store was worried when I went away for a week.
07:36:56 <adept> so, speaking of darcs ...
07:37:51 <shapr> ah, you've had coffee.
07:38:06 <YveDeLarc> hmm? release critical cola?
07:38:13 <adept> idea that "every copy is repository in itself" is neat, but I dont see yet how to do branches with this approach ..
07:38:15 <YveDeLarc> release candidate?
07:38:31 <shapr> actually it's "royal crown"
07:38:34 <YveDeLarc> ah
07:38:40 <shapr> but your ideas for names are much more entertaining
07:38:53 <adept> file moving/deleting/... versioning is a great step from CVS.
07:39:02 <YveDeLarc> adept: well, you just make a copy of the tree and continue with that. there's your branch...
07:39:26 <YveDeLarc> adept: since all trees are under revision control, it just works.
07:39:35 <adept> YveDeLarc: and how to merge that into trunk?
07:39:52 <YveDeLarc> adept: you extract changesets from the branch and merge them back.
07:42:21 <adept> YveDeLarc: "extract" == take them from _darcs or what?
07:42:38 <shapr> you could probably diff the two dirs
07:42:57 <adept> shapr: and do merge in xemacs/ediff? thanks :)
07:43:06 <YveDeLarc> shapr: that's what I meant
07:43:17 <shapr> there isn't an emacs mode for darcs yet
07:43:47 <YveDeLarc> maybe someone already has started to write pdarcs? ;)
07:44:08 <adept> taking into account how "darcs record" forks - there is little left for xemacs mode :) basically, i've been doing "cvs recods" with xemacs/vc all the time :)
07:44:19 <adept> ^for^wor^
07:46:01 <adept> thing is, branches are mostly usefull for multiple developers on one tree, and i think that selective pull replaces that (i'm not completely sure yet)
07:47:46 <shapr> I think it would
07:48:08 <shapr> you and I could pull a subset of changes from each other
07:48:10 <shapr> that's what darcs is best at
07:48:29 <shapr> making sure the 'swappable' patches are swapped, and the unswappable is not
07:52:20 <adept> and when you start re-working large subset of source tree, i could just postpone pulling your patches if I dont want to do it right now, right?
07:53:07 <shapr> yup
07:54:50 <adept> great. so far i'm thrilled :)
07:59:01 <shapr> hiiii syntax-laptop!
07:59:10 <shapr> long time no see!
08:03:41 <Lor> Hi, Isaac.
08:03:52 <shapr> he must be getting coffee.
08:08:11 <shapr> hi isomer 
08:08:14 <shapr> hello jak 
08:08:18 <jak> hi shapr
08:08:30 <isomer> hi again
08:08:52 * isomer crashed X with ksnapshot... that'll learn me to run k applications, huh?
08:09:10 <andersca> yes
08:10:22 <syntax-laptop> yoyo!
08:10:32 <shapr> wassup syntax-laptop?
08:10:38 <syntax-laptop> not much, back in Columbus
08:10:51 <syntax-laptop> how are you, shapr
08:10:57 <shapr> I am... unfocussed.
08:10:59 <shapr> how are you?
08:11:24 <jak> brb, trying out this identify stuff
08:11:29 <syntax-laptop> not bad, a little tired
08:11:32 <syntax-laptop> who's Lor?
08:11:48 <Lor> Lauri.
08:11:55 <Lor> (/whois has been invented, y'know.)
08:13:07 <syntax-laptop> HI Louri!
08:13:18 <syntax-laptop> I try not to know anything about irc :)
08:13:45 <Lor> A very sensible attitude. Learning about it only makes you more aware of how much it sucks.
08:14:02 <syntax-laptop> exactly :)
08:14:17 <Lor> It's an absolutely horrendous protocol, with hack upon hack of impromptu extensions.
08:15:31 <shapr> and mostly developed in Oulu
08:15:58 <Lor> Well, um.
08:16:10 * shapr grins evilly
08:16:20 <Lor> I'm not sure how much Jarkko Oikarinen had to do with the development of CTCP...
08:16:44 <Lor> Without any extensions, irc is just a Badly Designed protocol, not the awful mess it is today.
08:18:03 <earthy> well, it was based off of Relay, which was quite horrible in and of itself already
08:18:56 <Lor> Btw, one of the prime motivations for the subject of my MSc thesis was realizing why I wouldn't want to write an irc client in Haskell as it currently stands.
08:19:11 <shapr> there is already an irc client written in Haskell.
08:19:16 <earthy> unfortunately WWCN seems to have died a untimely death.
08:19:20 <shapr> but I would be interested in reading what you wrote.
08:19:27 <Lor> No doubt. There's an irc client written in just about anything.
08:19:36 <shapr> but not written in Joy
08:20:07 <Lor> Actually I never got further than writing datatypes for the protocol.
08:20:32 <adept> have a nice day
08:20:38 * adept heads home ...
08:20:47 <shapr> cya later
08:20:58 * shapr hacks up a silly lambdabot plugin
08:21:11 <Lor> Is lambdabot written in haskell?
08:21:17 <shapr> of course!
08:21:29 <Lor> Does it have dynamically loadable plugins?
08:21:32 <shapr> yes it does
08:21:43 <shapr> @listcommands dynload
08:21:43 <lambdabot> No module "dynload" loaded
08:21:45 <shapr> er
08:21:47 <shapr> @listmodules
08:21:48 <lambdabot> I have the following modules installed: ["base","dict","dummy","dynamic","eval","hello","karma","more","quote","seen","state","system","topic","type"]
08:21:50 <shapr> aha
08:21:53 <Lor> Are they _type-safe_? :)
08:21:54 <shapr> @listmodules dynamic
08:21:55 <lambdabot> I have the following modules installed: ["base","dict","dummy","dynamic","eval","hello","karma","more","quote","seen","state","system","topic","type"]
08:22:08 <shapr> Lor: depends on what you mean by type-safe
08:22:32 <Lor> I mean that no matter what the module is like, it cannot cause bogus run-time behavior.
08:22:36 <shapr> from what Heffalump has said, they are relatively type-safe, but you could still screw them over if you really try.
08:22:47 <shapr> ie. not type-safe against malicious intent
08:23:05 <Lor> Well, there's no way to distinguish malice and stupidity...
08:23:14 <shapr> feel free to look at the sources and fix them ;-)
08:23:32 <shapr> have you seen the darcs repo?
08:23:38 <Lor> Yeah, I'll have a look. I want to see how the modules are implemented.
08:24:15 <shapr> feel free to suggest improvements, submit diffs, etc
08:26:12 <Lor> Hm, the SF cvs server just says "end of file".
08:26:55 <shapr> we have a darcs repo :-)
08:27:02 <shapr> sf.net cvs is *way* overloaded
08:27:54 <Lor> Hm, and they don't have daily snapshots?
08:28:25 <Lor> Is lambdabot-1.0.tar.gz hideously outdated?
08:28:30 <hdaume> hi folks
08:29:01 <shapr> hi hal
08:29:09 <shapr> Lor: yes, hideously.
08:29:14 <hdaume> how was icfp?
08:29:18 <shapr> Lor: are you using debian?
08:29:21 <shapr> hdaume: it was FUN
08:29:42 <Lor> shapr, yeah.
08:29:50 <hdaume> coo
08:30:25 <shapr> # darcs
08:30:25 <shapr> deb http://http.abridgegame.org/debian/ unstable/
08:30:25 <shapr> deb-src http://http.abridgegame.org/debian/ unstable/
08:30:33 <Lor> Righto, thanks.
08:35:42 <Lor> All right. Where's the darcs repo, and how do I use it?
08:36:02 <shapr> well, you could read the manual :-)
08:36:11 <shapr> actually
08:36:33 <shapr> try "darcs get http://www.ScannedInAvian.org/repos/hlibs" in the dir where you want it
08:36:39 <Lor> I could, and I would, if I were actually interested in Yet Another Revision Control System and not just a way to get the lambdabot sources...
08:36:56 <shapr> imho, darcs is the best
08:37:01 <shapr> it is at least worth investigating.
08:40:56 <kosmikus> shapr: wow, that darcs get command completed in less than 2 seconds
08:41:21 <shapr> see, we need more source in the repo so people are more impressed :-)
08:42:39 <shapr> kosmikus: actually, that box is colocated on a 10Mbit line, so it'd take a lot of source to make it slow.
08:45:02 <Lor> Hm, all right, so the magic is in RuntimeLoader.hs.
08:45:06 <shapr> yes it is.
08:45:11 <kosmikus> well, you can keep it fast if you ask me ;)
08:46:10 <shapr> it's colo'd for our business, so it will stay fast.
08:47:58 <Lor> Hm. Essentially, it just looks up a symbol and gives the resulting Ptr any type that you might ask for, so if the actual address contains some other kind of data, you're screwed.
08:48:22 <shapr> is there a good way to fix it?
08:48:28 <Binkley> oh, wow, i'm still logged in
08:48:41 <Smerdyakov> Use a package system that someone has taken the time to do right....
08:48:53 <shapr> hi Binkley!
08:49:01 <Lor> The only language I know that supports safe dynamic loading with some kind of static typing is Java.
08:49:01 <shapr> goood morning to the Left Coast!
08:49:10 <Smerdyakov> Lor, Alice
08:49:30 <Lor> Don't know it.
08:49:32 <Binkley> hello, hello
08:49:45 <shapr> wassup?
08:49:53 <Binkley> *yawn*
08:50:16 * shapr bounces fruvously
08:50:40 * Lor starts studying Alice.
08:50:48 <Binkley> heh
08:50:56 <Binkley> bouncing in the manner of jian ghomeshi?
08:50:58 <shapr> Lor: you could Data.Dynamic
08:51:08 <shapr> Binkley: who?
08:51:29 <Binkley> a member of moxy fruvous
08:51:33 <shapr> oh!
08:51:34 <Lor> Nope. Dynamic is still dependent on all modules having been compiled in the same kind of environment.
08:51:38 <Binkley> i assumed that was what you meant by "fruvously", but never mind ;-)
08:51:43 <shapr> yes, that is what I meant
08:51:48 <shapr> I saw them live in Seattle
08:51:52 <shapr> but I don't know the members names.
08:52:18 <Binkley> well, he's one of them :-)
08:52:24 <shapr> cool!
08:53:49 <Lor> Hm, looks interesting.
08:54:07 <shapr> Lor: how is Dynamic dependent on that?
08:57:53 <Lor> Essentially, a Dynamic's just a bundle of the value, a type name and a pseudo-unique key for that type. When you read in externalized Dynamic data, you have to trust that the same type name actually means the same representation in both the loading program and in the module.
08:58:45 <shapr> would the type hashing paper from ICFP fix that?
08:59:39 <Lor> It would take us closer to real structural equivalence between the types instead of just checking the names. So yes, it'd be better.
08:59:50 <Lor> But still, there'd be no guarantee that the hash is actually _correct_.
08:59:55 <shapr> but how do you hash a type representation?
09:00:16 <Lor> With generic haskell something ought to be possible.
09:00:17 <shapr> they did it in ML, I got the impression you have access to the AST there.
09:00:26 <shapr> can I hash the AST in Haskell?
09:01:58 <Lor> Well, they hashed module types, which are essentially spiced-up records. In Haskell (without extensions), everything is either a ground type or a basic union-of-tuples, which Generic Haskell ought to be able to traverse.
09:02:21 <shapr> kosmikus: does that work?
09:02:23 <kosmikus> have I heard Generic Haskell?
09:02:29 <Lor> I don't know about polymorphic types, though.
09:02:46 <shapr> kosmikus: hey, I found this cool thing called Generic Haskell on someone's homepage.
09:02:48 <Lor> There's lots of papers on type analysis on fully polymorphic types, at least.
09:02:54 <shapr> lesse, the guy was named... Andres or something
09:03:04 <kosmikus> he must be cool :)
09:03:11 <shapr> yah, he gave a talk at ICFP
09:03:15 <shapr> that takes a lot of cool.
09:03:29 <kosmikus> I did not follow your discussion
09:03:37 <kosmikus> Can you ask a summarized question?
09:03:56 <Lor> Can you traverse any Haskell type to give it a pseudo-unique hash value?
09:03:58 <syntax-laptop> kosmikus: hey, tell Clara I said 'goodbye', I was sorry I didn't get a chance to tell her myself :)
09:04:18 <kosmikus> syntax-laptop: will do
09:04:22 <shapr> there was a "distributed type-safety" paper at ICFP. They hashed the AST of the type in ML. Can I do that in GH?
09:04:48 <Smerdyakov> You haven't defined hashability enough to answer that, shapr.
09:04:52 <kosmikus> hmm, and it should work on polymorphic types?
09:05:00 <Igloo> I can't remember the details, but was it not implementation-level rather than library-level?
09:05:15 <Lor> But again, all this hash-based type safety requires that you _trust_ the originator of an incoming hash code.
09:05:26 <shapr> afaiu, ML has first class modules, allowing you to hash a type
09:05:29 <Lor> And that's not really optimal if you want to load in arbitrary code.
09:05:44 <Lor> SML doesn't have _first class_ modules.
09:05:47 <Smerdyakov> shapr, no, SML does not have first class modules. Alice does.
09:05:57 <Igloo> Lor: You can check it corresponds to a valid instance of that type quite easily I imagine
09:06:01 <shapr> Lor: yes, the paper said "this is not designed against malice"
09:06:17 <Igloo> Checking the value is correct is obviously impossible without trust
09:06:30 <Lor> igloo, only if you also encode the entire type with it.
09:06:39 <Lor> And then this brings us to proof-carrying code.
09:06:47 <shapr> what does Data.Dynamic encode with it?
09:06:48 <Lor> (Which is the Right Way to do it, in some distant future.)
09:07:29 <shapr> in the near future (next five minutes) RuntimeLoader.hs works.
09:07:40 <Igloo> You don't need to encode the type, you just need a decision procedure on the list of bits
09:07:41 <Lor> shapr, it just bundles the value with the type name, and a unique integer for that type.
09:07:50 <shapr> oh
09:08:01 <Igloo> I guess alignment and suchlike might make it tricky in practice
09:08:03 <Lor> (Only unique within that particular process, and even then only due to unsafePerformIO hackery)
09:08:14 <shapr> kosmikus: I don't know about polymorphic types.
09:08:43 <Lor> Trifonov, Shao and Saha had a paper in ICFP 2000 describing a technique for analyzing polymorphic types.
09:09:39 <shapr> anyways, is there an incremental step of some sort that would allow me to write new types in a module, and then dynload that module?
09:09:48 <shapr> afaiu, only functions can be dynloaded right now
09:09:52 <kosmikus> it would be quite easy to extend Generic Haskell so that it can handle kind-* quantifiers, but everything above that seems complicated to me
09:10:32 <kosmikus> that would be done by just treating the forall as a *->* type constructor
09:10:57 <Lor> The way TSS treated it was as a constructor of kind (*->*)->*.
09:11:14 <Lor> Actually, make that (K->*)->*, for any kind K.
09:11:16 <kosmikus> sorry, that's what I meant
09:11:45 <kosmikus> Lor: yes, that would be the general approach, but in GH you cannot define cases for kind-polymorphic type constructors
09:11:46 <ski> forall :: forall K. (K->*)->*   ?  :)
09:11:57 <kosmikus> ski: yes
09:12:20 <ski> looks recursive (but isn't, yes)
09:12:39 <Lor> The foralls are of different sorts. :)
09:12:48 <ski> yes ;)
09:13:56 <ski> how do one distinguish the different levels of -> in dependant type systems (or perhaps one don't ?) ?
09:14:45 <Lor> There's only ->, and that's at the kind level.
09:14:57 <Lor> At other levels, -> is just syntactic sugar for forall. :)
09:15:50 <ski> yes  forall x : e0 . e1  (or  (x : e0) -> e1)  same thing, no
09:16:02 <ski> just different syntax
09:16:41 <Lor> Yep.
09:16:43 <shapr> so... the conclusion is...?
09:16:55 <Lor> At least in CoC. Don't know much about other dependently typed systems.
09:17:13 <shapr> what's CoC?
09:17:15 <kosmikus> @fact CoC
09:17:18 <lambdabot> Sorry, I don't know the command "fact", try "lambdabot: @listcommands"
09:17:20 <Lor> Calculus of Constructions.
09:17:24 <ski> Calculus of Constructions,  no ?
09:17:28 <shapr> kosmikus: sorry, I have fact turned off for the moment
09:17:38 <shapr> I'll bring it back up in the next few days.
09:17:49 <Lor> It's essentially F_omega with depedent types.
09:18:09 <kosmikus> Lor: is there a paper?
09:18:13 <shapr> I have only a vague idea about System F, is there a full description somewhere?
09:18:19 <Lor> Several.
09:18:37 <kosmikus> shapr: look at Pierce's book, for example
09:18:40 <shapr> actually, I have only a vague idea about Damas-Milner for that matter, can you point me to a good tutorial for that also?
09:18:45 <shapr> anything online?
09:18:50 <Lor> There's F_2 and then there's F_omega, and no doubt a plenty of variants.
09:19:18 <kosmikus> Lor: okay, let me rephrase then: is there a single paper I can read and know all I need to know about CoC?
09:19:20 <Smerdyakov> shapr, you don't have a textbook on type systems?
09:19:26 <shapr> no, I don't
09:19:32 <shapr> would be nice though.
09:19:33 <Smerdyakov> shapr, you should buy one!
09:19:37 <shapr> yes, I agree!
09:19:39 <Smerdyakov> Pierce's is cheap!
09:19:40 <shapr> what do you recommend?
09:19:48 <Lor> kosmikus, I only learned about it by playing with Coq and reading the manual.
09:19:50 <Smerdyakov> The people in the know recommend Pierce's these days.
09:19:55 <Lor> The original CoC is by Martin-Löf, I think.
09:20:25 <Lor> Pierce's book is nice.
09:20:40 <kosmikus> okay, I should finally read the original Martin-L"of papers, then -- they're on my ToDo list for quite some time
09:20:41 <ski> alfa here at chalmers/GU uses some dep. type system.  don't know exactly which though
09:20:56 <Lor> Yeah, it has a slightly different system.
09:21:00 <shapr> Chameleon?
09:21:06 <Lor> There was something you couldn't do in alfa/agda, I don't recall what.
09:21:21 <shapr> I want a tutorial for type theory in general.
09:21:22 <Lor> The agda home page describes the system they use, iirc.
09:21:25 <shapr> I have very little clue.
09:21:34 <Lor> shapr, then you want Pierce's book, definitely.
09:21:39 <shapr> ok, sounds good.
09:21:58 <Lor> I have heard some critique towards it, but it's probably the best all-around introduction.
09:22:07 <ski> is it *the* Pierce (logician) ?
09:22:14 <shapr> oh hey, didn't he give a paper at ICFP?
09:22:19 <Smerdyakov> Benjamin Pierce
09:22:58 <Lor> http://google.com/groups?selm=slrn83mhj0.1n9.la%40la.pp.htv.fi
09:23:06 <ski> is there any paper about combining dep.types and continuations ?
09:23:30 <Lor> Pierce answered me by email and sent the manuscript for his book. It was really helpful.
09:23:44 <Lor> (So yes, he _does_ read comp.lang.functional :)
09:24:07 <shapr> ah yes, he's connected to XDuce
09:24:18 <Smerdyakov> I wish my Internet access weren't mostly broken right now. Or I'd read the page at that URL!
09:24:50 <shapr> Smerdyakov: how is it broken? maybe I can help?
09:24:56 <Lor> ski, with "*the* Pierce", do you mean Peirce?
09:25:02 <shapr> do you need an http proxy or what?
09:25:06 <kosmikus> Pierce has also written unison, which I can really recommend ...
09:25:17 <Smerdyakov> shapr, I have a feeling it's worms degrading some aspect of my path to most everything.
09:25:32 <ski> Lor : perhaps, not sure of spelling. 'twas someone in america (perheps dead by now ??)
09:25:39 <shapr> Smerdyakov: how do you get to irc?
09:25:41 <Smerdyakov> shapr, the DNS servers I was told to use have been down intermittently for the last few days, etc.
09:25:53 <shapr> Smerdyakov: oh, try 138.26.134.2 as one of your nameservers.
09:25:53 <Smerdyakov> shapr, this connection has been open for a while. I don't know if I could make it again.
09:26:14 <Smerdyakov> The nameservers work now, just very slowly.
09:26:18 <Smerdyakov> But I can't connect to most IP addresses.
09:26:26 <shapr> traceroute'd the problem?
09:26:30 <ski> Lor : yes, it seems i though of Charles Peirce ..
09:27:34 <shapr> wow, bcpierce wrote an emacs spreadsheet
09:27:48 <shapr> oh, I had some thoughts on spreadsheets in quantum computing
09:27:53 <shapr> but I don't think they're original
09:27:59 <Lor> His latex macros for type rules are also nice.
09:28:11 <Smerdyakov> shapr, traceroute can't contact anything.
09:28:38 <shapr> Smerdyakov: are you behind a NAT or full SOCKS proxy?
09:29:08 <Smerdyakov> No. I'm behind 20 thousand undergraduates starting to use their net connections and a bazillion worm related attacks a second on everything.
09:29:13 <shapr> oh
09:31:11 <shapr> I don't think I can airdrop an 802.11 card to you :-)
09:31:38 <shapr> Lor: so, what was the conclusion? can GH do it?
09:31:56 * shapr wonders if kosmikus has his irc client automatically highlight occurences of "generic haskell"
09:32:15 <Lor> For monomorphic types, apparently. For polymorphic types, not at the moment.
09:32:18 <Lor> ...I think.
09:32:19 <Lunar^> I can't find anything that satisfies me to do CGI in Haskell
09:32:25 <shapr> Lunar^: tried WASH?
09:32:39 <shapr> c'est chouette :-)
09:32:45 <Lunar^> Can't find a way to use it correctly
09:32:49 <shapr> what's the problem?
09:32:55 <Lor> For web applications, if for anything, scheme is the finest language.
09:32:56 <Lunar^> I want to implement something simple as sortable tables
09:33:10 <Lor> (Now I'll get kicked out as a heretic...)
09:33:29 --- mode: ChanServ set +o shapr
09:33:38 * shapr puts on his boots of kicking
09:33:43 --- mode: shapr set -o shapr
09:33:46 <Lunar^> I can't see an easy way to actually make simple links to the same page
09:33:49 <shapr> Lor: just teasing :-)
09:34:06 <shapr> Lunar^: do you have your current code online?
09:34:15 <Lunar^> shapr: There's no code for the moment
09:34:22 <shapr> hej Gnabbe 
09:34:36 <Gnabbe> hej hej
09:34:37 <shapr> hur Ã¤r det med dig?
09:34:54 <Lor> Uh, is utf-8 the official encoding here?
09:35:10 <shapr> Lor: I just switched so I can read the chat on #haskell.se
09:35:17 <Gnabbe> =)
09:35:19 <Lunar^> shapr: I'm just trying to see how that could be done, there's no simple links (just <a href="...) in any of the examples
09:36:37 <shapr> Gnabbe: have you posted to the haskell mailing list? were you at ICFP?
09:36:44 <shapr> Gnabbe: or maybe you're just learning Haskell?
09:37:05 <Gnabbe> i'm just learning haskell... just signed up for a course today
09:37:08 <shapr> cool!
09:37:27 <Lor> Are you using Helium?
09:37:35 <shapr> whether you end up using Haskell for fun or not, it'll stretch your brain in interesting ways.
09:37:46 <Gnabbe> so i've heard =) 
09:37:57 <shapr> we're here to help that process along with various orthopaedic contraptions.
09:38:22 <shapr> ok, not really.
09:38:22 <Gnabbe> well, if i get stuck with my assignments i know where to get help =)
09:38:34 <shapr> oh, we have cool toys here too
09:38:38 <shapr> lambdabot is written in haskell.
09:38:40 <shapr> @yow
09:38:41 <lambdabot> The PINK SOCKS were ORIGINALLY from 1952!!
09:38:41 <lambdabot>  But they went to MARS around 1953!!
09:39:17 <shapr> Gnabbe: do you have a textbook for your class?
09:39:27 <shapr> Gnabbe: if you don't mind me asking, who's your teacher?
09:40:07 <Gnabbe> hold on, i have to check the home page for the course
09:40:09 <shapr> ok
09:40:19 * shapr looks at WASH docs in the meantime
09:40:26 <Gnabbe> how come, have you studied in Lund?
09:40:38 <shapr> no, I just know a lot of Haskell people.
09:41:12 <shapr> actually, my first visit to the south of sweden was last week.
09:41:24 <shapr> spent some time in Uppsala and in Stockholm.
09:41:36 <Gnabbe> okay, the lecturer is Lennart Ohlsson and we are using the book "Haskell - The Craft of Functional Programming, 2nd edition"
09:41:48 <shapr> ah cool, Simon Thompson's book.
09:42:02 <Gnabbe> is it any good?
09:42:06 <shapr> yah, it's how I learned.
09:42:19 <ski> i had a hard time stopping reading that book :)
09:42:24 <Gnabbe> how long ago was that? 
09:42:31 <shapr> if you have a strong math background, Hudak's School of Expression might be more fun for you.
09:42:42 <shapr> hm, when did I learn Haskell?
09:42:57 <shapr> oh, about two years ago I think.
09:43:05 <Lor> Hm, how did I learn Haskell? Via the gentle introduction, I think.
09:43:18 <Lunar^> shapr: There's no need for a strong math background for SOE
09:43:21 <shapr> I complained it was a brickbat, not a gentle intro :-)
09:43:29 <shapr> Lunar^: hah, you haven't seen any weak background like mine ;-)
09:43:33 <Lor> I recall using hbc, since at the time it was the only implementation that supported existential types.
09:43:37 <Lunar^> shapr: We should compare then ;)
09:44:32 <shapr> I had a calculus class once.
09:44:42 <shapr> in 1992 I think...
09:44:51 <Gnabbe> well i'm off to watch metropolis now... maybe i'll see you guys later on
09:44:53 <Gnabbe> bye bye
09:44:58 <shapr> cya!
09:45:59 <shapr> I have heard of Lennart Ohlsson
09:46:03 <shapr> but I don't remember where...
09:46:42 <Lor> Was he at ICFP?
09:47:19 <shapr> oh, he's into the patterns community, that's probably where
09:57:37 <Lor> And the world fell apart.
09:57:57 <syntax-laptop> IRC rulz
09:59:32 <Lor> Oh, btw, anyone have urls for people's icfp pictures?
10:00:23 <shapr> yah, I know two
10:00:58 <shapr> http://www.cse.unsw.edu.au/~sseefried/seafood/photos/people/
10:01:36 <shapr> actually, I've forgotten the other one.
10:02:36 <shapr> there's a picture of syntax-laptop on there
10:02:52 * syntax-laptop looks at me
10:03:08 <shapr> heh
10:04:54 <ski> nice pics
10:05:24 <syntax-laptop> somehow the background in my picture looks to me like a science fiction movie
10:05:53 <Lor> Because of the plastic?
10:09:16 <andersca> wow
10:09:16 <andersca> http://www.cse.unsw.edu.au/~sseefried/seafood/photos/people/people-Pages/Image2.html
10:09:20 <andersca> where can I get a t-shirt like that
10:10:10 <Lor> http://www.cafeshops.com/doitmonad
10:14:18 <andersca> woo
10:15:38 <hdaume> anyone know why, when i run a csh script from cron, i get errors like "SHLVL: Undefined variable"?
10:17:33 <syntax-laptop> how do you spell the name that sounds like Sean Seafried?
10:17:38 <syntax-laptop> SeaFreed
10:18:41 <syntax-laptop> nm
10:27:42 <shapr> hej Marvin-- !
10:27:48 <Marvin--> hejhej
10:27:50 <shapr> long time no see
10:27:57 <Marvin--> I just signed and uploaded your key
10:28:01 <shapr> yay!
10:28:21 <shapr> I haven't done the keysign thing yet
11:33:12 <Binkley> @yow
11:33:13 <lambdabot> My mind is making ashtrays in Dayton....
11:34:40 <Lor> Hi, Kirsten.
11:34:49 <Binkley> Hey
11:40:24 <Lor> binkley, did you have some icfp pictures posted somewhere? Or who was it in addition to Sean?
11:41:06 <Lor> Oh, sorry, you had a film camera, right?
11:41:14 <reffie> mmm
11:42:06 <Igloo> film...how quaint  :-)
11:46:18 <Marvin--> heh
11:51:52 <Lor> Bah. Why didn't I have the time to read all the papers _before_ the conference? Then I might even have had something meaningful to say.
11:52:59 <Marvin--> heh
11:53:31 <Binkley> No, I haven't posted any pictures yet
11:53:35 <Lor> But it'd have required searching the web for all the individual papers, since we didn't get the proceedings until monday...
11:53:43 <Binkley> I will when I develop and scan them, but I don't have that many
11:55:44 <Igloo> Has anyone else found building GHC takes ages "checking for DocBook CATALOG..."? And if so, what OS/arch?
11:56:34 <Binkley> Igloo: I get that sometimes, but then I just hit CTRL-C and start again and it's not so slow
11:57:04 <Binkley> With RedHat 7.1
11:57:12 <Igloo> Oh, interesting. Ta
13:11:04 <Lunar^> shapr: We're looking at hws-wp with sebc
13:27:40 <phubuh> hello!
13:34:20 <Igloo> hiya
13:41:32 <syntax-laptop> woop
13:41:57 <syntax-laptop> how are you haskellers doing?
13:52:01 <Heffalump> 'lo
13:59:21 <phubuh> sometimes i think i really am the center of the world. i have a pattern of joining a lively channel, and then leaving it for a while, to return to a mostly dead one :-)
14:03:12 <Lunar^> hehe
14:03:19 <Heffalump> :-)
14:03:21 <Lunar^> tips for darcs : use lecdit !
14:03:27 <Lunar^> s/lecdit/ledit/
14:46:00 <syntax-laptop> anyone know why nub is called nub?
14:46:56 <Igloo> I think it's some rather obscure etymology. wordnet's last definition is the best one I have to hand
14:48:54 <hdaume> http://www.m-w.com/cgi-bin/dictionary?book=Dictionary&va=nub+
14:49:07 <hdaume> defn. 3 is "GIST, POINT"
14:54:29 <Lunar^> @type nub
14:55:04 <Igloo> Eq a => [a] -> [a]
14:55:16 <Igloo> It removes duplicates from a list
14:57:55 <Heffalump> ISTR some really weird acronym was posted on the mailing list when someone asked
15:34:48 <Lunar^> @prelude uncurry
15:34:50 <lambdabot> *** "uncurry" prelude "Haskell Standard Prelude Dictionary": text follows
15:34:50 <lambdabot> uncurry
15:34:50 <lambdabot>   uncurry ::  (a -> b -> c) -> ((a,b) -> c)
15:34:50 <lambdabot>   uncurry f p     = f (fst p) (snd p)
15:53:05 <Darius> uncurry f ~(a,b) = f a b would be prettier
16:11:40 <Lunar^> I was planning to do that first
17:02:42 <shapr> hi syntax-laptop 
17:04:18 <shapr> bye heffalump
17:06:32 * shapr updates his darcs repo
17:07:52 <Lunar^> shapr: sebc should have commited a new makefile for hws-wp
17:08:17 <shapr> Lunar^: you sent the patch to me
17:08:23 <shapr> actually, sebc did
17:08:52 <syntax-laptop> hi :)
17:09:15 <shapr> if you do "darcs push --verbose --sign http://www.ScannedInAvian.org/repos/hlibs" in the top level hlibs dir, it should all work
17:09:56 <Lunar^> I don't think that you've got my GPG key
17:10:19 <Lunar^> I went through hws-wp source code (quite fast, but I did)
17:10:38 <Lunar^> There's a lot of clean up to do with recent GHC extensions
17:10:51 <shapr> I have sebc's key in there
17:11:00 <shapr> if you'll give me the fingerprint for yours I'll add it.
17:11:19 <Lunar^> 7BDD 6FEE B2CD 00AA 4254  E4F3 775A DC8C D5A0 7564
17:11:33 <Lunar^> :)
17:12:19 <shapr> what's the short bit?
17:12:29 <shapr> oh, I wonder if it'll work if I take the spaces out..
17:12:35 <shapr> erm...
17:13:05 <shapr> aha
17:13:08 <shapr> Lunar^: ok, you're in.
17:13:18 <shapr> Lunar^: try it, bug me if it doesn't work.
17:13:21 <shapr> hello rpr 
17:13:49 <shapr> rpr: learning Haskell? long-time user?
17:14:08 <shapr> hi syntax-laptop 
17:14:11 * shapr is sleepy
17:14:29 <Lunar^> shapr: :) Nothing to commit for now
17:14:37 <shapr> Lunar^: oh, I told Martin Sulzmann about type error slicing, I don't think he'd heard of it before.
17:14:47 <shapr> Lunar^: well, there's the patch that's in my inbox :-)
17:14:47 <Lunar^> shapr: Who's Martin Sulzmann ?
17:15:01 <shapr> he's the guy who wrote Chameleon.
17:15:24 <shapr> http://www.comp.nus.edu.sg/~sulzmann/
17:15:28 <Lunar^> shapr: I think I'm going to commit my (and sebc's) extensions to HToolkit's HSQL quite soon
17:15:44 <Lunar^> What does he think about it ?
17:16:16 <rpr> played with it on and off.  Love the syntax, hate the IO monad, purity be damned, could careless about the lazy.  I wish OCaml had Haskell's syntax??? or Haskell had Ocaml's speed.
17:16:16 <Lunar^> damn... another paper to read
17:16:27 <shapr> Lunar^: more than one :-)
17:16:48 <Lunar^> rpr: that's quite a troll ;)
17:17:19 <shapr> afair, chameleon is called that because it has a modular type-system
17:17:25 <shapr> you can change the rules
17:17:30 <rpr> It was an answer and a wish.
17:17:31 * Darius needs to download Chameleon to get it's type debugger.
17:17:44 <shapr> Darius: sulzmann is a nice guy, but very intense
17:17:45 * Darius assumes it comes with the language implementation.
17:18:00 <shapr> his talk on chr was very nifty
17:18:48 <shapr> oh, I gotta send mail to Claus Reinke...
17:18:50 <Darius> Constraint solving systems look cool all around.
17:18:51 * shapr boings
17:19:07 <shapr> Darius: you should come next year :-)
17:19:17 <Lunar^> Chaemelon seems quite related to sebc thesis
17:19:23 <shapr> Lunar^: yes, that's why I mentioned it.
17:20:28 <Lunar^> But why sebc is at ULTRA is because they're thinking that System I/E will be able to do incremental typing
17:20:46 <Lunar^> Which is closely related to incremental compiling
17:21:07 <Lunar^> Which is related to our plain to have an operating system without files
17:21:21 <Lunar^> s/plain/plan/
17:21:31 <Darius> how?
17:22:14 <Darius> or what do you mean "without files"?
17:25:55 <Lunar^> In the case of programming, the smallest thing you could manipulate will be functions
17:26:12 <Lunar^> Some kind of database
17:26:14 * shapr is tired
17:26:26 <shapr> Lunar^: sounds like smalltalk at first thoguht
17:26:27 <shapr> thought
17:27:09 <Lunar^> This kind of filesystems are coming with Longhorn and Reseir4
17:27:31 <shapr> Darius: hey, did you hear Karl-Filip Faxen's paper on why Haskell doesn't have principal types?
17:27:51 <Lunar^> But I think this kind of design choice has impact on the whole
17:28:13 <Lunar^> brix-os.sourceforge.net also talks about it
17:28:30 * shapr goes to sleep
17:28:39 <Lunar^> good night
18:58:42 <Lunar^> Type constructor `ReaderT' used as a class
18:58:51 <Lunar^> In the type: forall m a b. (ReaderT m) => m a -> m b -> m a
18:58:57 <Lunar^> What should I use then ?
19:06:54 <syntax-laptop> Lunar^: not sure what you're asking.  Monad maybe?
19:07:43 <Lunar^> I'm trying to write a generic version of 'bracket' which could be used with all ReaderT
19:08:21 <Darius> Use MonadReader
19:09:07 <Lunar^> MonadReader r m => m a -> m a -> m a ?
19:10:18 <Darius> Something like that.  You could just ask for the type of the expression.  Why do you need the monad to be an instance of MonadReader.
19:10:20 <Darius> ?
19:10:55 <Lunar^> Darius : to have some config and MVar running around
19:11:26 <Lunar^> It's not enough because I use liftIO for block, catch and unblock
19:14:11 <syntax-laptop> does anyone know if there was a reply about taking over nhc/hat/etc? in debian?
19:14:37 <Smerdyakov> I bet the name "hat" was chosen by a non-native English speaker.
19:15:43 <syntax-laptop> hm. judging from the logo, I'd say not :)
19:20:00 <Smerdyakov> But no one could take seriously something named "hat."!
19:20:26 <syntax-laptop> hehe
19:20:41 <syntax-laptop> who could take something named "unix" seriously!
19:22:05 <Smerdyakov> It's not an English word. :P
19:22:23 <Darius> But something named "Java" should be taken seriously?
19:22:39 <Smerdyakov> Yeah. "Hat" is just a funny word.
19:23:06 <syntax-laptop> it sounds like an english word
19:23:26 <syntax-laptop> (unix, that is)
19:23:53 * syntax-laptop wonders if Igloo is going to take over that stuff
20:08:54 <Lor> Morning, folks.
21:47:26 <prologic> if I were to rank Ada, ML and Occam in order of lowest to highest, would Ada, Occam, ML be correct ?
21:48:06 <Lor> In order of what?
21:48:17 <Lor> That is, what are you measuring?
21:48:31 <prologic> measuring the level of the language from lowest to highest
21:48:46 * Pseudonym laughs
21:48:54 <prologic> yeh it's pretty funny
21:49:04 <prologic> they're all high level languages to some extent
21:49:15 <Pseudonym> There's a wonderful paper by David Parnas entited: On a "Buzzword": Hierarchical Structure
21:49:30 <prologic> hrmm
21:49:34 <prologic> must find it and read it then :)
21:49:44 <Pseudonym> Choice quote: It would be nice, if the next person to use the phrase "higher level language" in a paper would define the hierarchy to which he refers.
21:49:52 <Lor> The distinction between high- and low-level languages is real, but very hard to define precisely.
21:49:58 <prologic> I know
21:50:07 <prologic> but come now, how would you two rank them ?
21:50:21 <Lor> Don't know anything about Occam, sorry.
21:50:22 <Pseudonym> His suggestions include "less efficient than" or "has a bigger compiler than".
21:50:34 <prologic> Occam is a parralell language
21:50:38 <Pseudonym> Which are valid hierarchy relations.
21:50:51 <Lor> For implementations, not for languages.
21:50:57 <prologic> I guess I can't really go wrong in this question then
21:50:58 <prologic> lol
21:51:03 <prologic> I could argue my way through it
21:51:14 <Pseudonym> I think your ranking is as good as anyone else's.
21:51:20 <prologic> I'd have to agree :)
21:51:24 <Lor> Ie. not worth squat. :)
21:51:28 <prologic> I mean Ada is just a plain old OO language
21:51:31 <prologic> with strong tping
21:51:34 <prologic> typing
21:51:49 <Lor> And some sort of parametric polymorphism, and simple abstract types.
21:51:57 <prologic> ML of course is a functional language we all know FPL's are higher than OO :P
21:52:18 <Lor> "ML" here presumably meaning SML?
21:52:26 <prologic> no just ML
21:52:40 <Pseudonym> I _think_ that the phrase "higher level" refers to the amount of abstraction that the abstract machine provided by the language provides.
21:52:48 <Lor> What is "just ML"? Some eighties version?
21:52:58 <Pseudonym> But quantifying an amount of abstraction is really vague.
21:53:06 <prologic> lol
21:53:15 <prologic> since he hasn't specified
21:53:19 <prologic> I assume "just" ML
21:53:21 <Pseudonym> I think "just ML" means Standard ML.
21:53:38 <prologic> yeh
21:53:41 <prologic> there's a huge family of them
21:53:45 <Pseudonym> http://www.smlnj.org/sml97.html
21:53:58 <Lor> I think it's usually conceptualized so that the hardware is at the "bottom", and the closer the language's conceptual structure is to the hardware's workings, the "lower" it is.
21:54:09 <prologic> that's right
21:54:11 <Pseudonym> SOmething like that.
21:54:15 <prologic> that's usually how we think of levels of languages
21:54:23 <Pseudonym> Which suggests that the "is a higher level than" relation is not a total ordering.
21:54:37 <Pseudonym> In particular, I'm not convinced that Ada and Occam are comparable.
21:54:38 <Lor> But then again, this means that the "level" of a language is _relative_ to an implementation machinery.
21:54:46 <Pseudonym> Though I'd probably put ML above both of them.
21:55:05 <Lor> In particular, a non-deterministic language would be "low-level" if you had non-deterministic hardware, right?
21:55:16 <Pseudonym> Yes.
21:55:28 <Pseudonym> Symbolics made machines that basically ran LISP.
21:55:31 <Darius> Lor: indeed, we had a similar discussion a while back.  For example, at what "level" would programming using only S and K combinators be?
21:55:32 <prologic> I'd still put Ada lower than ML and Occam
21:55:40 <prologic> since with Ada you can have assignments
21:55:41 <Pseudonym> People have even made hardware which execute SK combinators natively.
21:55:44 <prologic> thus changing values in memory
21:55:47 <Lor> Wow.
21:55:51 <Pseudonym> Doesn't Occam have assignments?
21:55:58 <prologic> not sure
21:56:04 * Pseudonym thought it did
21:56:06 <prologic> haven't looked at it's language syntax
21:56:13 <Darius> ML has references.
21:56:18 <prologic> ahh it does
21:56:25 <Lor> Isn't Kolmogorov complexity measured by the size of a turing machine required to generate or recognize a piece of data?
21:56:29 <Pseudonym> I know Occam has the distinction of being one of the first languages with an offside rule. :-)
21:56:32 <prologic> then I'll put them as Ada, Occam, ML
21:56:38 <Pseudonym> Lor: Yes.
21:57:00 <Pseudonym> You might like to object to the question, though.
21:57:07 <Lor> Probably turing machines are currently thought of as the "natural" means of computation. Even though it is in expressiveness equal to many other things.
21:57:09 <prologic> oh I will
21:57:13 <prologic> it's a rather stupid question
21:57:38 <Pseudonym> Lor: You'd think so, but IMO they're no more "natural" than random access machines or lambda calculus.
21:57:46 <Pseudonym> Who wants to write TM code, for heaven's sake?
21:57:55 <Pseudonym> Whereas we DO write lambda calculus.
21:58:44 <Lor> Well, no one in his right mind would write everything in pure LC either.
21:59:02 <Lor> But granted, LC is much nicer to deal with than TMs.
21:59:06 <Pseudonym> Right.
21:59:21 <Darius> Not if it needs executing, but otherwise it's not too bad except for numbers.
21:59:28 <Pseudonym> And I would have said once that nobody would write pure RAM code either, but Don Knuth's MIX is pretty close to it.
21:59:43 <Lor> MIX? The original?
21:59:46 <Pseudonym> Yes.
22:00:26 <Lor> Uh. I thought that MIX represents all the idiosyncracies of the processors of 60s and 70s.
22:00:37 <Pseudonym> Well, yes.
22:00:52 <Lor> Never thought of it as a pure abstraction, the way ram machines are supposed to be.
22:01:04 <Pseudonym> And MMIX represents the quirks of a 90s processor. :-)
22:01:07 <prologic> 3 questions to go :)
22:01:16 <Pseudonym> Thank goodness that DEK hadn't heard of EPIC.
22:01:30 <Pseudonym> Can you imagine?
22:01:47 <Pseudonym> Still, RAM machines are actually pretty close to "real" machines.
22:01:59 <Lor> Well yeah, that's the problem with them. :)
22:01:59 <Pseudonym> Except that it has infinite memory, you could build one in theory.
22:02:07 <prologic> btw guys off the top of your head, why hasn't ML, Occam and Ada become as popular as C or Java ? because not as much money was poured onto them as C and Java ?
22:02:36 <Lor> That, and inertia.
22:02:43 <prologic> inertia ?
22:02:44 <Pseudonym> Occam was designed for architectures which aren't really useful any more.
22:03:00 <Pseudonym> It was popular on transputer arrays, for example.
22:03:01 <prologic> parrallel architectures
22:03:06 <prologic> yep
22:03:19 <Pseudonym> Well not parallel architectures as such.  We still have parallel architecturers.
22:03:39 <Pseudonym> But the current thinking is coarse-grained SMP/AMP machines, or vectorised processors.
22:03:57 <Pseudonym> Not large arrays of inexpensive PEs.
22:04:20 <Pseudonym> As for Ada, much money was indeed poured into it.
22:04:43 <Pseudonym> For a while, you couldn't get a US DoD software contract unless it was written in Ada.
22:04:59 <Pseudonym> The trouble was, as I recall, that the software tools weren't "there" yet.
22:05:29 <Pseudonym> The whole thing fizzled out when people realised that they didn't want to develop mission-critical software with immature tools.
22:05:39 <Pseudonym> Ada is still widely used, though.
22:05:45 <prologic> hrmm interesting
22:05:54 <Pseudonym> This is from memory.  I could be wrong with this.
22:05:57 <prologic> obviously not enough people were interested in Ada
22:06:03 <prologic> or the tools would be matured and been developed
22:06:03 <Pseudonym> Now ML.  Where do I start.
22:06:10 <Pseudonym> ML has found its niche.
22:06:26 <Pseudonym> It is definitely used, if you work in the right industries.
22:06:39 <Pseudonym> Mostly biotech.
22:06:46 <Pseudonym> Gene sequencing, that sort of thing.
22:07:44 <Pseudonym> ML started off life as a meta language (hence ML) for a theorem prover.
22:07:50 <Pseudonym> That's always a bad sign.
22:08:04 <Lor> ML makes a fairly nice compromise between theoretical purity and practical usefulness. I think people use it as a base for their research partly because then they can make some sort of claims of practical applicability for whatever it is they're working on.
22:08:13 <Pseudonym> Yeah.
22:08:26 <prologic> yeh ML isn't popular for the same reason Haskell isn't
22:08:33 <Pseudonym> But the problem is that, as one person on LtU put it, programming languages tend to develop implicit theories about what they're useful for.
22:08:33 <prologic> when compared to languages such as C and Java of course
22:08:41 <Lor> Haskell is a bitch to implement when compared to ML.
22:08:59 <Pseudonym> People got the idea that ML was useful for THIS sort of task, and then didn't try it out on anything else.
22:09:26 <Pseudonym> Really, the question you _should_ be asking is why C and Java are so popular.
22:09:34 <Pseudonym> Being popular is the more uncommon case.
22:09:36 <Lor> C is popular because of Unix.
22:09:38 <Pseudonym> Right.
22:09:41 <prologic> yeh
22:09:46 <Pseudonym> C is the system programming language that came with Unix.
22:09:55 <Pseudonym> Unix is pretty much a C virtual machine.
22:09:55 <prologic> Java is popular because of the money poured onto it
22:10:00 <Pseudonym> Not just that.
22:10:04 <prologic> and because of the java virtual machine allowing web applciations
22:10:05 <Pseudonym> Java came along at the right time.
22:10:10 <prologic> yeh
22:10:11 <prologic> web development
22:10:16 <Pseudonym> Right.
22:10:22 <Pseudonym> Particularly on the client side.
22:10:26 <prologic> yup
22:10:34 <Lor> Java was originally designed more for the client side, but nowadays it's much more used at the server side. 
22:10:43 <Pseudonym> And because Sun was smart enough to provide the libraries that you need to write your middleware.
22:10:52 <Pseudonym> Java was buzzword-complete.
22:11:12 <prologic> now it's way too big and complex :P
22:11:23 <Lor> (In actuality, of course, the perfect web application language is scheme. :P )
22:11:31 <Pseudonym> The language itself isn't too big and complex.
22:11:46 <Pseudonym> Lor: Some would say it's Perl. :-)
22:11:47 <Lor> Pseudonym, have you looked at the latest additions?
22:11:49 <prologic> the libraries are
22:11:58 <Pseudonym> Lor: No.  I stopped around 1.1.
22:12:05 <prologic> the langauge itself is rather nice
22:12:06 <Lor> Enumeration types, special syntax for iterating.
22:12:22 <Lor> And of course parametric polymorphism, the one thing java's been sorely missing since day one.
22:12:34 <Pseudonym> They don't seem too bad.
22:12:37 <prologic> what is parametric polymorphism ?
22:12:48 <Pseudonym> prologic: Do you know C++?
22:12:52 <prologic> I do
22:12:57 <Pseudonym> Think templates.
22:12:59 <prologic> I do not use it though
22:13:12 <Lor> Having special built-in syntax for all kinds of idioms is, uh, perlish.
22:13:13 <d33p_> it means you dont have to downcast when you remove stuff out of a container
22:13:35 <Darius> Or think ML/Haskell
22:13:39 <prologic> show me a simple example of parametric polymorhpism in java ?
22:13:44 <Pseudonym> Lor: No, being Perlish is having your syntax highly overloaded.
22:14:10 <Pseudonym> Darius: I'm working on the theory that if you think in ML/Haskell, you've heard of parametric polymorphism.
22:14:17 <Darius> point
22:14:30 <Lor> prologic: Map<String,String> map = new HashMap<String,String>(); map.put("foo", "bar"); String s = map.get("foo"); // note: no cast
22:14:50 <Lor> Also note the verbosity of the type annotations. :)
22:15:02 <Pseudonym> Yes.
22:15:03 <prologic> hrmm I see
22:15:09 <prologic> kinda like STL with C++ ?
22:15:14 <Pseudonym> I would not be surprised if Java gets type synonyms next.
22:15:15 <prologic> and those bloody templates
22:15:21 <Lor> Kinda, but done right. Or at least better than c++.
22:15:26 <prologic> hrmm
22:15:32 <prologic> that's the one thing that's turned me off C++
22:15:36 <Pseudonym> Once you have parametric polymorphism, you REALLY need type synonyms.
22:15:39 <prologic> STL and it's templates
22:15:59 <prologic> and name spaces
22:16:01 <prologic> argg
22:16:27 <Lor> Too bad they chose to use GJ pretty much as it stood, and not any of the fancier proposals, like nextgen.
22:16:46 <prologic> don't you think we need a new paradigm ?
22:16:51 <Pseudonym> I quite like C++.
22:16:58 <prologic> I hate it :)
22:17:02 <Pseudonym> I know it's blasphemy to say that around here.
22:17:10 <Darius> C++ is the only other language I've programmed in continuously.
22:17:12 <Lor> "My project is a paradigm." "My project is a paradigm, too." -Dilbert.
22:17:23 <Darius> It's my (I guess second now ;) favorite language.
22:17:30 <Pseudonym> C++, IMO, hits a local optimum (as opposed to a global one).
22:17:44 <Lor> C++ is okay for certain things _if_ you know it well enough not to shoot yourself in the foot.
22:17:53 <Pseudonym> Yeah, that's the kicker.
22:17:53 <prologic> precisely
22:17:58 <Pseudonym> You really have to know what you're doing.
22:18:03 <Lor> C++ gives you all the efficiency of C with a bit better abstractions.
22:18:12 <prologic> only slightly though
22:18:14 <prologic> not much better
22:18:20 <prologic> it's still as dangerous as C
22:18:21 <Pseudonym> Mind you, you really have to know what you're doing no matter what general purpose language you're programming in.
22:18:38 <prologic> hehe unless it's VB
22:18:39 <Lor> However, there is one thing that _really_ turns me off: the inability to only specify the _interface_ of a class in a header without providing its internal structure.
22:18:47 <Lor> That makes for horrendous dependencies.
22:18:48 <Darius> better (abstractions) than Java did and (probably) does, in my opinion
22:19:04 <Pseudonym> prologic: If you're "programming" (for lack of a better term) in VB, you deserve what you get.
22:19:21 <prologic> true
22:19:24 <Darius> "scripting"?
22:19:28 <prologic> good thing I don't then :)
22:19:34 <Pseudonym> Lor: Yes, I'd agree with you there.  The biggest problem in C++ is the lack of a real module system.
22:19:34 <prologic> yes scripting is a better term
22:19:49 <Pseudonym> Never trust the product of a VB script kiddie.
22:20:04 <Lor> pseudonym, in pure C you can do pretty well just providing a forward declaration for a struct, and then some functions that operate on struct pointers.
22:20:06 <prologic> most viruses are written in it bloody stupid teenage kids
22:20:10 <Darius> Never use the product of a VB script kiddie
22:20:11 <Lor> But then you don't get subtyping.
22:20:29 <Pseudonym> Lor: That's true, though it's still not a "real" module system.
22:20:44 <Pseudonym> And, of course, C doesn't have exceptions.
22:21:00 <Lor> I'd so love just to be able to say class Foo : public Bar; as a forward declaration.
22:21:24 <Pseudonym> Actually, I don't even want forward declarations.
22:21:36 <prologic> FPC has a nice module system, exceptions and syntax. don't think it has parametric polymorphism though
22:21:47 <Lor> Well yeah, getting rid of manual header management would be nice.
22:21:53 <Pseudonym> Memory is cheap these days.  You can hold all your definitions in memory while compiling.
22:21:54 <Lor> That's the problem with sml and ocaml, too.
22:22:01 <Pseudonym> Oh, yes.  I hate SML.
22:22:06 <Pseudonym> Actively hate.
22:22:18 <Lor> I _don
22:22:28 <Pseudonym> Having to declare mutually recursive functions together is very, very wrong.
22:23:02 <Lor> Memory may be cheap somewhere.
22:23:27 <Pseudonym> I mean that you get more memory for your money than you did in the days of the PDP 11.
22:23:34 <Lor> I have 96 megs of ram on my machine, and don't want to be forced to get more just so I can hold all the gazillion definitions of a huge application in memory.
22:23:41 <Lor> That completely breaks the idea of separate compilation.
22:23:52 <Pseudonym> Ah, I did not make myself understood.
22:23:57 <Pseudonym> Not the whole application.
22:23:57 <prologic> if a new paradigm were created where the language was pure component based (just as haskell is a pure FL), it'd be hard to make mistakes ?
22:24:05 <Pseudonym> Just those of the modules that you import.
22:24:38 <Pseudonym> You shouldn't need a forward declaration if you're defining the thing that you're declaring in the same compilation unit.
22:24:49 <Lor> pseudonym, isn't that essentially what all systems do now? The only difference being, whether you have to write the interface files (headers) by yourself (c, sml) or if they're generated automatically (java, haskell).
22:25:27 <Lor> Ah, naturally forward declaring something you _define_ in the same compilation unit ought to be unnecessary.
22:25:39 <Pseudonym> Yes, exactly.
22:25:44 <Pseudonym> Or even in the same module interface.
22:25:48 <Lor> No one does a completely streaming compiler anyway.
22:26:04 <Pseudonym> Not any more, anyway.
22:26:21 <Lor> But forward declarations are useful in C to declare abstract types.
22:26:24 <Pseudonym> Interprocedural optimisation is important these days.
22:26:31 <Lor> The same way in ML you just say "type Foo"
22:26:59 <Pseudonym> Well that's true, but they shouldn't be necessary.
22:27:09 <Lor> Yeah, manual interface files are a pain.
22:27:22 <Lor> You have to keep them in sync with the separate source file...
22:27:30 <Lor> And in ML you end up duplicating lots of stuff.
22:27:55 <Pseudonym> In Haskell there's a related problem which continually annoys me.
22:28:11 <Pseudonym> I think it's the biggest defect in the language, actually.
22:28:33 <Pseudonym> The problem is that you can export symbols which don't have explicit type declarations.
22:28:53 <Pseudonym> Moreover, you can do this with symbols in mutually recursive modules.
22:29:21 <Pseudonym> This effectively means that you, in general, need intermodule analysis in order to typecheck Haskell.
22:29:34 <Lor> Ah. Yeah, that's a wart.
22:29:39 <Pseudonym> GHC has the .hi-boot files as hacks.
22:30:01 <Pseudonym> You should be able to work out a module's interface from the source of the module alone.
22:30:09 <Lor> It'd arno be nice to have type declarations in the export clause.
22:30:11 <Lor> also
22:31:34 <Pseudonym> It'd also be nice to control which typeclass instances are exported.
22:31:51 <Lor> Frankly, I'd like best a syntax where you don't need to list your exports separately, but you just add a visibility qualifier to the type annotation. "public length :: [a] -> Int" or something
22:32:23 <Lor> Having magic unique instances somehow bothers me anyway.
22:32:44 <Pseudonym> Interesting idea.  You'd need some creative syntax for data types, depending on whether or not you want the implementation exported.
