00:03:09 <shapr> until we write the Haskell mail client...
00:04:25 <kosmikus> morning
00:04:49 <Pseudonym> G'day.
00:05:35 <shapr> hoi kosmikus 
00:05:44 <kosmikus> is there a connection between video RAM and MUAs?
00:05:58 <shapr> two conversations at the same time I think
00:06:26 <shapr> as I understand it, Darius has been investigating email clients for several weeks at least
00:07:09 <kosmikus> I see
00:11:46 <mgoetze|away>  /nick mgoetze
00:12:04 <Pseudonym> mgoetze|still-away-apparently
00:12:09 <mgoetze|away> er
00:12:43 <mgoetze> shapr: i'm scared of the UI an email client written by you might have, so i might stick to mutt anyway :)
00:13:30 <Pseudonym> @read-email
00:13:31 <lambdabot> Sorry, I don't know the command "read-email", try "lambdabot: @listcommands"
00:13:55 <mgoetze> @next-thread
00:13:56 <lambdabot> Sorry, I don't know the command "next-thread", try "lambdabot: @listcommands"
00:14:03 <mgoetze> @mark-as-spam-damnit
00:14:04 <lambdabot> Sorry, I don't know the command "mark-as-spam-damnit", try "lambdabot: @listcommands"
00:14:38 <mgoetze> i am pleased to announce that my 850 MB home directory has been successfully moved
00:15:25 <kosmikus> to /dev/null ? :)
00:15:57 <mgoetze> nope, to corelli:/home/mgoetze
00:18:29 <mgoetze> so, what next? hm, i think i'll try installing xfree86 now...
00:19:37 <kosmikus> new OS?
00:23:37 <Darius> shapr: I downloaded Thunderbird to see if it had some convenient feature to deal with the virus emails and because I love Firebird.  It doesn't and it doesn't really have any features over Sylpheed that I care about and it's slower.
00:24:56 <mgoetze> kosmikus: basically, i decided that linux on a and win2k on b was a bad idea, so i am now installing linux on b and moving everything over so that i can then install win2k on a
00:26:23 <Pseudonym> Thunderbird.  Isn't that a CPU, or is it a car?
00:26:38 <Pseudonym> Oh, no, it's a TV show with puppets.
00:26:47 <mgoetze> i thought it's a web browser...
00:27:12 <Pseudonym> The Mercury group found about 20 uses for the term "Mercury".
00:27:58 <clausen> There are about 20 uses of the word "Unix" also!
00:28:03 <Pseudonym> Tyson wanted the next language to be called "Venus".
00:28:09 <Pseudonym> I wanted it to be called "Deacon".
00:28:23 <mgoetze> yay!
00:28:25 * mgoetze got italy
00:28:31 <Pseudonym> All of it?
00:28:34 <Pseudonym> Wow.
00:28:50 <Pseudonym> Quite some real estate you got there.
00:29:09 <mgoetze> yup, complete with 2 armies and a fleet
00:29:26 <Pseudonym> Did you get Vatican City too?
00:29:33 <mgoetze> nothing compared to russia, of course, who also starts with 2 armies and 2 fleets... but he has more neighbours to worry about
00:29:41 <mgoetze> hm, vatican city doesn't show up on the map
00:29:59 <earthy> mgoetze: why didn't you simply replug the drives?
00:30:33 <mgoetze> in the machiavelli variant, the papal states are a power of their own, but then that's set a bit earlier than standard diplomacy
00:30:41 <mgoetze> earthy: ide. scsi. nuff said.
00:31:04 <earthy> one's IDE, the other SCSI?
00:31:13 <mgoetze> one's IDE, the other two are SCSI, yes
00:31:16 <ma]> how can i divide a Int by 2 and get back an Int?
00:31:18 <earthy> ah, 'kay. ;)
00:31:40 <mgoetze> there are also some auxilliary reasons (such as the bigger IDE drive being one of the reasons i wanted windows on that machine in the first place)
00:32:37 <mgoetze> ma]: you could try the round function...
00:33:01 <Darius> Firebird is the browser, Thunderbird is the email client.
00:33:08 <Darius> @type div
00:33:09 <lambdabot> div :: Integral a => a -> a -> a
00:33:26 <mgoetze> @tyoe round
00:33:27 <lambdabot> Sorry, I don't know the command "tyoe", try "lambdabot: @listcommands"
00:33:31 <mgoetze> @type round
00:33:32 <lambdabot> round :: (RealFrac a, Integral b) => a -> b
00:33:42 <ma]> @listcommands
00:33:43 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define","definitions","del-definition","devils","dict","dict-help","dummy","dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements","eval","foldoc","foo","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","lojban","more","msg","part","prelude
00:33:49 <mgoetze> see, TIMTOWTDI!
00:34:01 <mgoetze> wtf?
00:34:05 <mgoetze> @cmafihe
00:34:06 <lambdabot> Nothing is universal.
00:34:09 <mgoetze> @cmafihe
00:34:10 <lambdabot> Nothing is universal.
00:34:15 <mgoetze> uhhuh
00:34:23 <shapr> @cmafihe cilre
00:34:23 <lambdabot> cilre <BRIVLA> [learn] 
00:34:41 <mgoetze> shapr: sorry, i don't get it
00:34:44 * earthy would try toInt( a/b )
00:34:58 <shapr> mgoetze: it's for looking up lobjan words
00:34:59 <shapr> hi Lance_ 
00:35:06 <Darius> Just use div.
00:35:06 <Lance_> hi
00:35:08 <earthy> but then again, I'm used to C and explicit casting and shite. :)
00:35:25 <shapr> Lance_: looking for Haskell users?
00:35:42 <ma]> @type toInt
00:35:43 <lambdabot> toInt :: Integral a => a -> Int
00:35:56 <ma]> @module toInt
00:35:57 <lambdabot> Sorry, I don't know the command "module", try "lambdabot: @listcommands"
00:36:22 <Pseudonym> @type floor
00:36:22 <lambdabot> floor :: (RealFrac a, Integral b) => a -> b
00:36:28 <shapr> @type ceiling
00:36:29 <lambdabot> ceiling :: (RealFrac a, Integral b) => a -> b
00:36:31 <shapr> @type wall
00:36:34 <shapr> hm
00:36:38 <Darius> @type \x -> x `div` (2 :: Int)
00:36:39 <lambdabot> \x -> x `div` 2 :: Int -> Int
00:37:20 <shapr> where's the latest debian boot cd image?
00:38:12 <Pseudonym> @type let y = \f -> f (y f) in y
00:38:13 <lambdabot> let {y ($0 (0 (\f -> f (y f))) $0) $0 $0} in y :: (a -> a) -> a
00:38:23 <Pseudonym> What's with the $0's?
00:38:38 * shapr dunno
00:38:48 <shapr> it's calling hugs and running ":t " ++ command
00:38:50 <shapr> so...
00:39:24 <Pseudonym> @type let y f = f (y f) in y
00:39:25 <lambdabot> let {y (f $0 (0 (f (y f))) $0) $0 $0} in y :: (a -> a) -> a
00:39:27 <Darius> That is what an older version of Hugs outputs.
00:39:36 <Pseudonym> Do you know what it means?
00:39:50 <Pseudonym> I assume it's something to do with the way it's compiled.
00:40:04 <shapr> I think I have the latest hugs deb installed
00:40:06 * shapr checks
00:40:33 <Pseudonym> let {...} in y :: (a -> a) -> a
00:40:42 <Pseudonym> That's what Feb 2000 shows.
00:40:51 <shapr> yup, it's the latest
00:41:00 <Darius> It also breaks with constraints
00:41:13 <shapr> doesn't H-E have hugs-cvs?
00:41:29 <shapr> yes it does
00:41:31 <shapr> I could try that instead
00:41:37 <Darius> @type show . read
00:41:38 <lambdabot> show . read :: (Read a, Show a) => [Char] -> [Char]
00:42:56 <shapr> @type let y f = f (y f) in y
00:42:57 <lambdabot> let {y (f $0 (0 (f (y f))) $0) $0 $0} in y :: (a -> a) -> a
00:43:04 <shapr> looks the same
00:43:18 <shapr> but it's now hugs-cvs
00:43:29 <shapr> anyways, it's off to the dentist for me
00:46:10 <Pseudonym> Nothing big, I hope.
00:54:46 <mgoetze> well, the next step of my migration involves getting pppoe to work
00:54:57 <mgoetze> that means that i shan't be online for a while :)
00:55:39 <earthy> good luck
00:56:02 <earthy> (as I recally roaring penguin's stuff, you'll need it :))
00:58:54 <mgoetze> earthy: well, seeing as i already got it working once, it shouldn't be impossible to do it again... :)
01:02:02 <shapr> hi ecraven 
01:02:08 <shapr> gutentag magr 
01:02:23 <magr> hej shapr
01:02:27 <shapr> :-)
01:03:18 <shapr> since I'm from Alabama, my native greeting would probably be something like "good mornin"
01:03:38 <shapr> though the swedish greeting is nifty also
01:04:07 <magr> shapr: but you live in sweden?
01:04:25 <Pseudonym> I like "G'day" because it's the two-syllable word which requires the minimum of mouth movement.
01:04:46 <shapr> magr: yup
01:04:55 <Pseudonym> Australians also have a word which has no equivalent that I've seen in any other country (though no doubt someone else has one).
01:04:55 <shapr> Pseudonym: there's also "yo"
01:05:12 <magr> Pseudonym: the German equivalent is "morng"
01:05:26 <magr> Pseudonym: pronounced similarly to "yawn"
01:05:51 <Pseudonym> It's hard to pronounce, but it means "I wasn't planning to, but now that you mention it, that sounds pretty good".
01:06:02 <Pseudonym> Actually it's not hard to pronounce, but it's hard to transcribe.
01:06:43 <shapr> heh, said like "yawn"
01:06:44 * shapr snickers
01:08:37 <magr> a greeting with one syllable is a real advantage, especially in the morning
01:09:19 <shapr> especially if it can be confused with a yawn
01:09:59 <shapr> I suspect that should be part of the perfect spoken language for programmers
01:10:23 <Pseudonym> Maybe it should be spelled "login".
01:10:27 <shapr> heheh
01:10:40 <shapr> oh, I just had an idea for adding 'file paste' features to lambdabot 
01:10:59 <magr> shapr: something like "cat"
01:11:05 <shapr> if lambdabot could listen for sendfile uploads, that should be enough
01:11:29 <shapr> oh, and archive them for public access on ScannenInAvian.org
01:12:03 <Pseudonym> Oooh!  Cool!  Somewhere to put my w4R3z!!!!!!1!!!
01:12:10 <shapr> yah, sort of :-)
01:12:35 <magr> great. a distributed archive tool for sensitive customer data :)
01:12:53 <shapr> I have wanted a distributed archiving tool for debs
01:13:05 <shapr> for example, if the md5 sums for debs were available from debian.org
01:13:18 <ecraven> hellp shapr
01:13:22 <shapr> but you could get the actual file from the guy down the street at 10Mbits/sec
01:13:32 <shapr> ecraven: qwerty user, eh?
01:13:56 <ecraven> ah, sorry.. ;) still wanting to switch to dvorak.. i'll do it some of these days..
01:14:04 <shapr> aoeuhtns
01:14:05 <shapr> :-)
01:14:17 <shapr> anyways, I'm off to The Dentist
01:14:18 <ecraven> any day now, 'cause my index finger starts hurting 'cause of my 6-finger system ;)
01:14:22 <ecraven> good luck ;)
01:14:25 <shapr> thanks, I'll need it...
01:14:33 <magr> and have fun
01:19:05 <Pseudonym> Home time for me.
01:19:07 <Pseudonym> Nytol
01:39:57 <Lunar^> shapr: got the patch finally ?
03:02:47 <mgoetze|away> well, that sure took a lot longer than i expected
03:13:56 <shapr> yah, I agree
03:20:26 <shapr> Lunar^: what patch?
03:32:19 <Lunar^> shapr: PDF lib
03:32:31 <Lunar^> Should I try to push it again ?
03:32:59 <shapr> I don't see it in the patch list
03:33:52 <Lunar^> Should I ?
03:34:46 <Darius> shapr: Use HaRe yet?
05:31:15 <phubuh_> hi
05:55:24 <shapr> Darius: no, haven't tried it yet
05:55:40 <shapr> Lunar^: if the patch made it, it would show up in the list
05:57:04 <shapr> Darius: have you tried it?
06:08:36 <Lunar^> shapr: Ok I'm trying again
06:11:28 <Igloo> Lunar: Did you see there is now an (unregisterised) ghc6 for powerpc in Debian BTW?
06:11:59 <Lunar^> shapr: tryied again
06:12:11 <Lunar^> Igloo: No.. thanks for the (good) news
06:15:24 <Igloo> I don't think ghci will work, but if you have a bit of time it is believed to be fairly easy - ghc/rts/Linker.c should be all that needs to be changed
06:16:57 <Igloo> (patches welcome!  :-)  )
06:19:32 <Lunar^> I don't have time for anything right now
06:19:38 <Lunar^> (and for next weeks)
06:20:01 <Lunar^> Deadline for my current project : 30th september
06:20:15 <Lunar^> I have to finish theses bindings for PDFlib before that
06:20:39 <Lunar^> Deadline for giving my course detailed toc : tomorrow
06:22:16 <Lunar^> Is it possible to use ReaderT as a newtype ?
06:24:21 <Igloo> Heh, OK, no worries  :-)
06:24:32 * Igloo doesn't understand the question
06:29:00 <Lunar^> actually, if I use "type Foo a = ReaderT Bar IO a"
06:29:17 <Lunar^> when there's type error, I see "ReaderT Bar IO" instead of Foo
06:29:47 <Lunar^> It doesn't really makes me happy for PDFlib
06:30:20 <Lunar^> (All calls to PDFlib thread a PDF * which is just an abstract pointer) 
06:30:20 <Igloo> You can say newtype Foo a = Foo (ReaderT Bar IO a)
06:30:32 <Lunar^> How do I use it then ?
06:30:55 <Lunar^> Foo $ do .. ?
06:31:35 <Igloo> If the do block has type ReaderT Bar IO a then yes
06:31:54 <Lunar^> ok... hope it'll work then
06:31:54 <Igloo> And you'll want (Foo x) rather than x where you match against Foos
06:32:26 <Lunar^> I was not really sure how do-notation enters in this
06:35:46 <SyntaxPolice> good morning, #haskell
06:37:40 <Igloo> Yo Syn
06:38:14 * Igloo needs to get around to replying to your mails so I can pointedly note you haven't replied to mine  :-)
06:39:04 <SyntaxPolice> Igloo: yeah, I got the feeling that you wrote that email in the wee hours of the morning, because I really didn't know what it was all about,  so I'm building emotional energy to read it more carefully :)
06:39:18 <SyntaxPolice> plus I wanted to get this proposal done. I think we'll have a web page on haskell.org sometime soon.
06:39:54 <Igloo> Oh, hmmm, I'll have another look at it
06:40:05 <Igloo> Cool
06:41:10 <SyntaxPolice> you should read http://www.syntaxpolice.org/tmp/libraryInfrastructure
06:41:20 <SyntaxPolice> that'll be the web page when I get a place to put it
06:44:42 * Igloo coughs at "lazer"
06:55:54 <Lunar^> Damn... PDFlib is really huge
06:56:11 <Lunar^> I think we could design something really nice
06:56:29 <Lunar^> A real data structure to create paths
06:57:14 <Lunar^> But I feel not enough experienced to design it
06:57:19 <Lunar^> (at least alone)
06:59:14 <Igloo> What does it do?
07:00:09 <Lunar^> It's a library to dynamically create PDF files
07:00:21 <Igloo> In C?
07:00:25 <Lunar^> Yes
07:00:34 <Igloo> And you are porting it to Haskell?
07:00:41 <Lunar^> Not porting it, making a binding
07:00:59 <Igloo> OK, but a functional layer on top rather than a straight binding?
07:01:02 <Lunar^> http://lune.talath.net/~lunar/pdflibtest.pdf for the first test
07:01:08 <Lunar^> Yes
07:01:26 <Igloo> Cool
07:01:41 <Lunar^> But that's a lot of work though
07:01:55 * Igloo wonders how much more work it is than porting it
07:02:12 <Lunar^> Because of its stinky license it's not an option anyway
07:03:23 <Igloo> But you could port it from the spec? Or is that not possible either?
07:03:46 <Lunar^> This first try is in shapr's repos
07:04:11 <Lunar^> The API manual is 250 pages long
07:04:43 <Lunar^> A binding is enough work I think
07:04:47 <Lunar^> PDF are quite complicated
07:04:50 <Igloo> :-)
07:05:32 <Lunar^> Damn! I'm going to use this in my course! 
07:05:58 <Lunar^> Hudak's book makes a library to manipulate some geometric shapes
07:06:09 <Igloo> Cool
07:06:17 <Lunar^> On top of making displaying them on screen, I'm going to ask them to make PDF
07:06:23 <Lunar^> That could rules :)
07:06:35 <Igloo> Oh, you are giving the course?
07:06:45 <Lunar^> yes
08:21:18 * esap is still trying to understand layering.
10:21:23 <lma> hi there
10:24:03 <ibid> hmm
10:24:07 <ibid> hi
10:47:51 <lma> what should the diff between sequence and sequence_ be? When i do 'sequence(_) [getChar]' both do not print the typed key
10:52:24 <Lor> Indeed. getchar only reads a character, it doesn't write one.
10:53:10 <Lor> The difference is in whether the characters are returned to the caller or not.
10:56:26 <SyntaxPolice> hey Lor
10:56:30 <SyntaxPolice> did you see your photos on my web site?
10:57:03 <SyntaxPolice> http://www.syntaxpolice.org/pics/londonSweden/small/ICFP/
10:58:00 <Lor> Ah. Cool.
11:00:01 <Lor> That unknown person next to me in pic 7 is that icfp contest guy.
11:00:24 <Lor> (And boy, do I look stupid or what?)
11:04:19 <Igloo> Andrew Hudson is the person listed on http://www.dtek.chalmers.se/groups/icfpcontest/results.html
11:05:00 <Lor> It wasn't the winner.
11:05:08 <Igloo> Ah, OK
11:05:17 <Lor> He was a member of the runner-up team.
11:30:53 <SyntaxPolice> Lor: you don't look stupid
11:31:10 <SyntaxPolice> Igloo: you think his name is Andrew HUdson?
11:32:27 <Igloo> Not if he wasn't the winner, no
11:33:06 <SyntaxPolice> heh OK
11:33:42 <Lor> Stefan Pochmann
11:33:50 <Lor> http://rad-eye.com/icfp2003/
11:34:09 <SyntaxPolice> Lor: ok cool
11:39:30 <Xcalibor> hiyas :
11:39:33 <Xcalibor> )
12:05:25 <Xcalibor> re'sw
12:15:32 <Xcalibor> re's
12:18:50 <ludde> how can i prove that an algorithm is correct?
12:18:56 <ludde> err, optimal.
12:22:14 <Riastradh> ludde, speed it up, and if you can't, you're done!@
12:22:17 <Riastradh> s/@//1
12:22:51 <ludde> i don't think my teacher will take that as an answer
12:24:21 <norpan> ludde: it depends on the algorithm
12:24:46 <norpan> if you know the optimal complexity you can show that your algorithm has that complexity
12:26:38 <andersca> evening mr norpan
12:26:56 <ludde> norpan: ah
12:27:06 <ludde> norpan: that helps
12:27:31 <ludde> actually hmm
12:27:58 <ludde> andersca: do you take the algorihtms class?
12:28:00 <andersca> yes
12:28:14 <ludde> did you make the home assignment?
12:28:23 <ludde> make=do
12:28:36 <andersca> haven't yet
12:28:37 <andersca> :)
12:28:44 <ludde> okay :)
12:28:47 <andersca> is it hard?
12:29:04 <ludde> i don't think so, but i don't know how to prove that it's optimal :)
12:30:48 <ludde> it wasn't very hard to come up with an algorith,m
12:31:01 <ludde> i'm not sure if it's optimal either though heh.
12:32:30 <Xcalibor> re's
12:32:33 <Xcalibor> @prelude id
12:32:34 <lambdabot> *** "id" prelude "Haskell Standard Prelude Dictionary": text follows
12:32:34 <lambdabot> id
12:32:34 <lambdabot>   id ::  a -> a
12:32:34 <lambdabot>   id    x         = x
12:32:53 <Xcalibor> @help
12:32:54 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
12:33:04 <Xcalibor> lambdabot: @listcommands
12:33:05 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define","definitions","del-definition","devils","dict","dict-help","dummy","dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements","eval","foldoc","foo","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","lojban","more","msg","part","prelude
12:33:42 <Xcalibor> @eval flip . id
12:33:42 <lambdabot> <<EM Dynamic -> EM Dynamic>>
12:33:51 <Xcalibor> mmmm...
12:42:34 <Xcalibor> what does that "<<EM Dynamic -> EM Dynamic>>" mean?
12:46:33 <Riastradh> It means it's a function.
12:49:25 <Xcalibor> i quite expected that, but there's no type analysis?
12:57:52 <Xcalibor> @jargon fandango on core
12:57:58 <lambdabot> No match for "fandango".
12:57:58 <lambdabot> No match for "on".
12:57:58 <lambdabot> *** "core" jargon "Jargon File (4.3.0, 30 APR 2001)"
12:57:58 <lambdabot> core n. Main storage or RAM. Dates from the days of ferrite-core
12:57:58 <lambdabot>    memory; now archaic as techspeak most places outside IBM, but also still
12:58:00 <lambdabot>    used in the Unix community and by old-time hackers or those who would
12:58:02 <lambdabot>    sound like them. Some derived idioms are quite current; `in core', for
12:58:04 <lambdabot>    example, means `in memory' (as opposed to `on disk'), and both {core
12:58:06 <lambdabot> [4 @more lines]
13:07:38 <Xcalibor> very nice...
13:07:41 <Xcalibor> :)
14:12:36 <ibid> any suggestions for a good 20-minute exercise on list processing (excluding map, fold and filter)
14:13:10 <Riastradh> Define map and filter in terms of foldr.
14:13:25 <Riastradh> Well, that's about a thirty second exercise...for slow students.
14:14:15 <ibid> (_excluding_ map, fold and filter)
14:14:44 <Igloo> mergesort?
14:14:49 <ibid> already have that
14:15:17 <ibid> (these students have background on imperative programming and several years of cs study:)
14:15:20 <ibid> btw
14:15:28 <Igloo> quadratic and linear reverse?
14:15:50 <ibid> i had them in the lecture
14:16:10 <Riastradh> Oooh, ooh, I've got an idea.
14:17:02 <Riastradh> Tell them they must come up with some interesting list processing routine without using map, filter, or fold, and the implementation must occupy twenty minutes; if they don't come up with something or they don't implement it fast enough, mark their grade down.
14:17:28 <ibid> :)
14:17:36 <ibid> nice idea but not useful, sorry
14:18:28 <Lor> There's not much you can do with "lists in general".
14:18:55 <ibid> Lor: http://www.mit.jyu.fi/antkaij/opetus/fo/2003/moniste/3-1.pdf - that's my context
14:19:05 <Lor> Yeah. (I finally read it.)
14:20:17 <Lor> Almost all the generally interesting stuff is already in the standard List module.
14:20:49 <ibid> Lor: http://www.mit.jyu.fi/antkaij/tmp/d3.pdf that's what i have currently, but i have to get rid of 7-8; i have a replacement for 7 but i'm missing an 8
14:21:05 <Riastradh> Have them reimplement the List module, then!
14:21:29 <ibid> :)
14:22:12 <Riastradh> Or SRFI 1.  I think SRFI 1 is larger.
14:22:39 <Riastradh> (though it has somme things that you can't implement in Haskell, e.g. the n-ary procedures)
14:24:05 <Lor> You could modify the catlist exercise so that head and tail take (say) logarithmic time.
14:24:15 <ibid> true
14:24:16 <Lor> Ie. add some balancing.
14:24:49 <Lor> But it's not really a "list exercise" any more then...
14:25:00 <ibid> yeah
14:25:15 <ibid> and i have data structures stuff coming about a week or two from now
14:25:32 <Xcalibor> make them play around with zip and scan
14:25:39 <Xcalibor> to implement hashtables
14:25:41 <Lor> You could have something about deforesting and foldr/build.
14:25:43 <Xcalibor> for example
14:25:59 <ibid> no fold this week
14:26:19 <ibid> i intend to take some time on it in lectures
14:26:43 <Xcalibor> make them play around with uncurry, zip, unzip and iterate to implement associative arrays
14:26:52 <Xcalibor> that should be fun enough
14:26:57 <Lor> You could introduce the monadic >>= for lists and just sneakishly not say anything about monads yet. :)
14:27:03 <ibid> hmm...
14:27:24 <ibid> what would i have them do with it, in your opinion?
14:28:05 <Lor> Actually, scratch that. Here's a really basic run-of-the mill list exercise: generate all permutations.
14:28:21 <Lor> (Though actually you _can_ use the list monad for that.)
14:28:46 <Xcalibor> have them work with lambda calculus and lists of functions to do stuff
14:29:11 <Xcalibor> good theoretical basis, good practice and interesting to see how everything can be expressed through functions...
14:29:33 <ibid> the first two weeks were about different calculi, including lambda
14:29:56 <ibid> i'd rather not put them throught that this week
14:30:08 <Xcalibor> ah
14:30:09 <Xcalibor> shame
14:31:35 <Lor> Church-encoded lists might be enlightening, though.
14:32:02 <Lor> Otoh, it's probably best to present those along with folds.
14:32:07 <Xcalibor> some easy regex stuff with strings can be as well
14:32:20 <Xcalibor> and instead of map, recursion
14:32:58 <ibid> recursion?
14:33:49 <Xcalibor> exhausting the characters before doing backtracking
14:34:23 <Xcalibor> i'd never do regexes without map, but then recursion over the tail gets the same effect
14:35:56 <Lor> Hm, there's no standard function to give you both inits and tails at the same time?
14:39:14 <Lor> Hm, all right. If you can use zip, inits, tails and the List monad, you can implement permutations in four lines.
14:40:55 <Lor> Might make a good example when you reach monads.
14:41:14 <ibid> hmm
14:41:40 <Lor> Well, you can as well use list comprehensions. The same thing, really.
14:45:28 <jdrake> In a surprise move today Bill Gates announces Steve Ballmer was fired, then hung by his balls. In his stead, his Worship, RMS was announced the new CEO and all seeing god of Microsoft.
14:50:44 <Lor> ibid, btw, using big-Lambda as the metavariable for lambda expressions is a bad idea if you ever want to treat polymorphism.
14:52:14 <Lor> And in 2.1 you could at least informally state that you need transitivity and congruence do derive the equations.
14:52:18 <phubuh_> does haskell's lack of named arguments pose a problem in practice?
14:52:48 <Lor> No.
14:53:03 <Lor> Does it pose a problem in practice _anywhere_?
14:53:15 <Riastradh> 'Lack of named arguments?'
14:53:20 <Lor> It's a nice extra feature, but hardly essential.
14:53:28 <ibid> Lor: which equations?
14:53:38 <Lor> 42+24.
14:54:02 <phubuh_> Riastradh, as in OCaml "let foo ~bar ~baz = bar + baz;; foo ~bar:5 ~baz:10"
14:54:03 <ibid> yo mean (2.1)-(2.9)?
14:54:06 <ibid> you
14:54:21 <Lor> You need transitivity to be able to "continue the chain", and you need congruence to apply the equivalences to _parts_ of the expressions.
14:54:56 <ibid> that's a point
14:55:35 <ibid> btw, if you have more comments, please use mail; it'll be a long time before i revise the released parts, and the logs of this irc discussion will be long forgotten...
14:56:28 <Lor> Ah, but that'd require that I dedicate a moment to actually think about it. :)
14:56:51 <ibid> (the first 14 pages basically sucks, it was only in ydin-haskell where i got a hang of what i was doing...)
14:57:48 <ibid> (i was behind schedule and the decision to present lambda at beginning was a desperate move made fifteen minutes before the corresponding lecture - i just couldn't make the decision before that)
14:57:59 <Lor> Oh, and to really emphasize that a formal system is pure uninterpreted symbol manipulation, you could at first use, say, o,z and p instead of 1,0 and +.
14:58:12 <ibid> yeah
14:58:28 <ibid> but i'm not doing *real* formalism at any point
14:58:35 <ibid> we have a course for that :)
14:58:39 <ibid> separate, i mean
14:59:17 <Lor> I'm not sure if it's a good idea to use haskell's notation for type annotations to represent the domains and ranges of mathematical functions. They are different things, after all.
14:59:51 <ibid> as i said, about the sucking i mean :)
14:59:57 <Lor> Then again, not sure if it's a good idea to confuse the readers head with the distinction either.
15:00:26 <ibid> you can probably see that i had not really decided on whether it's typed or not until ydin-haskell...
15:01:37 <ibid> Lor: what's haskellish in the mathematical typing, btw?
15:01:42 <ibid> apart from the double colon
15:01:44 <Lor> The use of double colons.
15:02:04 <ibid> that's a trivial difference, mostly
15:02:12 <ibid> mathematicians use single colon
15:02:13 <Lor> Well yeah.
15:02:26 <Lor> Shows that I can't find anything more significant to bitch about. :)
15:02:31 <ibid> :)
15:02:33 <ibid> good :)
15:03:04 <Lor> Oh, and \Gamma and \Delta are stupendously bad choices for type metavariables.
15:03:36 <ibid> actually, if you have the time to give it a thorough read sometime, it would help the next iteration. there's no rush, the next iteration will not start until next year, at least
15:03:48 <ibid> (in that case, mail the comments please:)
15:03:54 <ibid> Lor: as i said, it sucks :)
15:04:04 <Lor> I'll just dump the logs. :)
15:04:07 <ibid> :)
15:05:20 <Lor> Ahwell, off to sleep.
15:05:24 <ibid> (and yeah, i'm fairly clueless about formal type systems, mostly i imitate what i've seen in the occasional article)
15:05:34 <ibid> (i'm still waiting for that book you recommended)
15:06:12 <ibid> Lor: thanks for the competent comments :)
15:06:49 <ibid> (the problem of being the only one here who does this stuff is that i don't get too much real criticism)
15:09:02 <Xcalibor> ibid: which stuff?
15:09:24 <ibid> Xcalibor: the stuff i do :)
15:11:27 <ibid> fp, popl, fm :)
15:13:12 <Xcalibor> mmm
15:13:32 <Xcalibor> popl?
15:13:42 * earthy notes that the linked pdf's are in finnish
15:13:46 <earthy> principles of programming languages
15:13:56 <ibid> earthy: they are :)
15:14:03 <ibid> what about it
15:14:20 <earthy> ibid: it means I have *no*clue* about their actual contents, but for the codeparts. ;)
15:14:25 <ibid> earthy: :)
15:14:49 <ibid> good for you i use english to name identifiers, mostly?:)
15:15:03 <earthy> oh, no, I'm used to formal methods and silly names. :)
15:15:08 <ibid> :)
15:15:23 <ibid> Atsil a
15:15:39 <earthy> sounds like a type with one type variable. :)
15:15:43 <ibid> :)
15:15:52 <ibid> Bird calls it Liste a
15:17:11 <earthy> yeah, but the type's implementation counts
15:17:15 <ibid> :)
15:17:21 <earthy> `implementation'... tsk
15:17:29 <earthy> I should use better phrasing. :)
15:17:38 <ibid> and i should be asleep :)
15:17:44 <earthy> you too? :)
15:17:47 <ibid> yeah
15:18:00 <ibid> i have no lectures tomorrow (today?) though
15:18:07 <ibid> so there's no real rush :)
15:18:26 <earthy> neither do I... first that I have to pay attention to again is friday. :)
15:18:47 <ibid> actually, so do i
15:19:00 <ibid> i have a presentation in the grad student seminar
15:19:23 <earthy> (hope that'll turn out better than this afternoon... the poor student understood well enough, but screwed up presenting)
15:19:32 <ibid> :)
15:19:42 <ibid> well, i've already given it one, in a conference
15:19:47 <earthy> oh, then...
15:19:52 <Xcalibor> mmm...
15:19:53 <ibid> (of course, i'll edit it to suit the audience)
15:19:59 <Xcalibor> A +
15:19:59 <ibid> once
15:20:04 <ibid> Xcalibor: ?
15:20:12 <Xcalibor> what does that sound?
15:20:16 <Xcalibor> A +
15:20:20 <ibid> sound?
15:20:33 <Xcalibor> like in <ibid> Atsil a
15:20:46 <earthy> Xcalibor: that sounds like a type constructor followed by an operator and that seems to be invalid syntax. :)
15:21:07 * kosmikus notes that earthy considers the ST colloquium unimportant :)
15:21:14 <Xcalibor> aha... it's actually a function call   function A called with the value stored in symbol +
15:21:17 <Xcalibor> :)
15:21:21 <earthy> kosmikus: I don't have to pay attention there. :)
15:21:27 <earthy> well, not at *this* one, really.
15:21:28 <Xcalibor> valid scheme except by the lack of ()'s
15:21:29 <ibid> earthy: it also could be a data constructor followed by an operator, which would be valid if there were parentheses thus: (A +)
15:21:42 <earthy> ibid: true.
15:21:47 <ibid> ST colloquium?
15:21:56 <Xcalibor> Star Trek?
15:21:56 <kosmikus> earthy: I'm not even sure what's scheduled ...
15:22:09 <earthy> ibid: thursdaymornings, 11am - 12am. ;)
15:22:12 <ibid> ST as in state monad?
15:22:21 <earthy> kosmikus: some master's student (alexei?)...
15:22:29 <earthy> no, as in software technology
15:22:32 <ibid> ahh
15:22:35 <kosmikus> Xcalibor: :) that's an interesting interpretation; maybe we should have a weekly Star Trek colloquium
15:22:43 <Xcalibor> i mean, when arbitrary symbols are allowed, saying without more information what 'a b' may be is a bit... hard, isn't it?
15:23:08 <ibid> Xcalibor: it's quite easy... just choose your favourite :)
15:23:10 <Xcalibor> kosmikus: big Star Trek fan in here :-)  _\\//
15:23:14 <earthy> owh, okay, I might want to pay attention thursday morning...
15:23:25 <earthy> Functional Reactive Programming.
15:23:31 <Xcalibor> ibid: sounds like theorem proofing method... :-)
15:23:37 <ibid> :)
15:24:04 <ibid> how does one proof a theorem?  is it like reading it through to see that there are no spilling mistakes?
15:24:05 <Xcalibor> earthy: sounds like callback programming with functional constructs :-)
15:24:07 <ibid> :)
15:24:23 * ibid is so sleepy
15:24:24 <earthy> xcalibor: something like that, but not quite. ;
15:24:24 <earthy> :)
15:24:29 * earthy is too awake...
15:24:55 <earthy> time to read some more of Harrison's book on prooftools
15:25:00 * Xcalibor is too aslept
15:25:02 <Xcalibor> :)
15:25:25 * ibid considers reading some okasaki
15:25:30 <ibid> as bedtime reading:)
15:25:55 * Xcalibor sugest Bashô
15:26:01 <earthy> ibid: nah, that's too darn interesting, even though the writing style is somewhat boring. ;)
15:26:05 <ibid> :)
15:26:46 <ibid> i'll probably fall asleep immediately after lying down...
15:26:53 <earthy> g'night, ibid.
15:27:20 <ibid> night all
15:28:51 <Xcalibor> nighters!
15:29:17 <Riastradh> Wow, ibid...it takes me well over an hour to fall asleep.
15:29:27 <ibid> bah
15:29:44 <ibid> it depends on how tired i am
15:29:45 <earthy> riastradh: then you don't work enough
15:29:52 <ibid> normally it takes me time
15:29:58 <earthy> or too much and you don't know how to relax
15:30:10 <ibid> but on tuesdays, after two lecture days, i'm usually very tired
15:30:15 <earthy> I take about 10 minutes, normally
15:30:33 <ibid> and if i'm in the wrong phase, it can take me hours
15:30:37 <earthy> glasses of single malt whisky help.
15:30:49 <ibid> for a while
15:30:52 <earthy> :)
15:51:51 <Lunar^> Any french here ?
15:52:00 <Xcalibor> spanish
15:52:08 <Xcalibor> close but not quite, I'm afraid :)
15:52:25 <Xcalibor> (even when Napoleon did try his best)
16:08:44 <Xcalibor> okay gang... good night to all
18:09:02 <palomer> hrm
18:09:10 <palomer> I'm falling in love with haskell without even using it
18:09:15 * palomer needs to go into therapy
18:09:29 <palomer> oh, how would i do something like matrix multiplication in haskell?
18:09:49 <Pseudonym> Well, first question you need to ask is: How would I represent a matrix in haskell?
18:11:14 <Pseudonym> What performance criteria do you want?
18:11:33 <Pseudonym> Do you want sparse matrices?  Dense matrices?  Destructive update?  O(1) element access?
18:12:40 <palomer> erm
18:12:43 <palomer> dense
18:12:47 <palomer> with O(1) element access
18:13:00 <Pseudonym> Clearly you need arrays.
18:13:07 <palomer> yes, an array of arrays
18:14:24 <Pseudonym> OK.  So you probably want Data.Array.
18:14:48 <palomer> but, erm, I'm wondering how to do matrix multiplication in a functional manner
18:14:51 <Pseudonym> array :: (Ix i) => (i, i) -> [(i, e)] -> Array i e
18:15:06 <Pseudonym> Well, what is matrix multiplication really?  In mathematical notation?
18:15:55 <Pseudonym> If you have A = B * C
18:15:59 <Pseudonym> Then A[i,j] = ?
18:16:09 <palomer> A * B = C where C[i,j] = sum from 1 to r ( A[r,j] * B[i,r)
18:16:14 <Pseudonym> Right.
18:16:29 <Pseudonym> OK.  So here's a matrix type:
18:16:50 <Pseudonym> type Matrix = Array Int (Array Int Float)
18:16:51 <Pseudonym> Say.
18:16:56 <palomer> Keep in mind, I'm just interested in matrix multiplication in a purely functional way
18:17:03 <Pseudonym> Oh, absolutely.
18:17:11 <Pseudonym> And you have the operation:
18:17:15 <Pseudonym> (!) :: (Ix i) => Array i e -> i -> e
18:17:27 <Pseudonym> So you can get B[i,j] by doing: b ! i ! j
18:17:27 <palomer> erm, I have to admit that I'm not too familiar with haskell
18:17:27 <palomer> yet
18:17:47 <Pseudonym> So you can get the (i,j)th element of A by using:
18:18:32 <Pseudonym> a i j = sum [ (b!r!j) * (c!i!r) | r <- [0..?] ]
18:18:37 <Pseudonym> Where ? we haven't determined yet.
18:19:01 <Pseudonym> You can get that by appropriate calling of the bounds function on the array.
18:19:31 <palomer> ok...
18:19:33 <palomer> so far so good
18:19:39 <palomer> here's something that does bother me though:
18:19:51 <palomer> how do I build up the resulting matrix?
18:19:58 <palomer> I cant make a new matrix and then fill it up
18:20:01 <palomer> since thats not functional
18:20:03 <Pseudonym> Ah, well.  Have a look at this:
18:20:30 <Pseudonym> array :: (Ix i) => (i, i) -> [(i, e)] -> Array i e
18:20:34 <Pseudonym> Stare at that for a moment.
18:20:42 <Pseudonym> You need to understand that i is the type of the index.
18:20:52 <Pseudonym> In Haskell, arrays can be indexed by any member of Ix.
18:21:20 <Pseudonym> But generally, you only care about Ints, Integers etc.
18:21:22 <palomer> erm, what does that say in english?
18:21:39 <Pseudonym> Let me specialise this for the case where i is Int.
18:22:02 <Pseudonym> array :: (Int,Int) -> [(Int,e)] -> Array Int e
18:22:09 <Pseudonym> This constructs an array.
18:22:18 <palomer> ok
18:22:22 <Pseudonym> It takes two ints (i.e. the upper and lower bounds).
18:22:32 <Pseudonym> Then a list of (Int,e), which is the elements to fill in.
18:22:37 <Pseudonym> And it returns an Array.
18:22:59 <Pseudonym> Makes sense?
18:23:05 <palomer> oh, so I need to build up the list
18:23:08 <palomer> before I create the array?
18:23:15 <palomer> quite inefficient, but asymptotically the same
18:23:18 <Pseudonym> Right.  Though of course the list can be lazy.
18:23:29 <Pseudonym> Not really that inefficient.
18:23:41 <Pseudonym> Because the list is evaluated lazily, you don't ever build up the whole list.
18:23:59 <palomer> ahhh, true
18:24:12 <Pseudonym> Another thing to consider is that these are _immutable_ arrays.
18:24:26 <Pseudonym> Once you've made the array, you can't change its contents.
18:24:36 <palomer> yes
18:24:40 <palomer> that would be unfunctional
18:24:51 <Pseudonym> Well, no they wouldn't, if you embedded them in a monad.
18:24:59 <Pseudonym> So we have IOArrays and STArrays.
18:25:44 <Pseudonym> I think that immutable arrays are probably what you want for the simple reason that you hardly ever want to fiddle with individual elements in a matrix.
18:26:06 <Pseudonym> Another thing to consider is that array indices are abstracted.
18:26:21 <Pseudonym> So you could actually implement 2D arrays directly by creating your own Ix instance.
18:26:35 <Pseudonym> But that's Haskell 201, not 101.
18:26:39 <palomer> gotcha
18:26:50 <palomer> there's actually a course on haskell in my university
18:26:56 * Pseudonym nods
18:27:02 <palomer> quite surprised
18:27:07 <palomer> thx alot!
18:27:18 <Pseudonym> No problem.
18:27:26 <Pseudonym> THere are fancier representations, incidentally.
18:27:41 <Pseudonym> One clever individual represented matrices using a quadtree.
18:28:05 <Pseudonym> Matrix multiplication then uses a divide-and-conquer approach.
18:28:14 <Pseudonym> Accessing an individual element is then O(log n) rather than O(1).
18:31:04 <palomer> you can use the divide and conquer approach even if it's not a quad tree
18:31:22 <Pseudonym> Yes, though it's harder if you use a list-of-lists, for example.
18:41:25 <palomer> in haskell, is it possible to define, say, multiplication between an array and a scalar?
18:41:46 <palomer> even better: can you define an operator as commutative?
18:41:59 <Pseudonym> No.
18:42:10 <palomer> ohmy, if you could that would be the best thing in the world
18:42:12 <Pseudonym> As to the second point: Ask yourself why you'd need to bother?
18:42:13 <palomer> no to both?
18:42:19 <Pseudonym> No to both.
18:42:23 <Pseudonym> The first would be great, I agree.
18:42:30 <Pseudonym> I can't see why you'd need the second.
18:42:37 <palomer> ok, trivial example
18:43:04 <palomer> say you want define * :: scalar -> array -> array
18:43:16 <palomer> that takes a scalar and an array and returns an array, correct?
18:43:17 <Pseudonym> OK.
18:43:44 <palomer> well, you don't feel like doing something silly like defining * :: array -> scalar -> array
18:44:01 <palomer> (which would simply call the former by reordering its arguments)
18:44:03 <Pseudonym> Why not?  That'd be very easy to do.
18:44:13 <Pseudonym> a * s = s * a
18:44:20 <Pseudonym> Leave the rest to inlining.
18:44:21 <palomer> ok, say you have an operator that takes 5 distinct types
18:44:35 <Smerdyakov> palomer, then you're a stinky poo-poo.
18:44:47 <palomer> and its commutative, so you want to do a * b * c * d * f without thinking of the order
18:44:48 <Pseudonym> A 5-ary operator?
18:44:58 <palomer> I meant function
18:45:11 <palomer> f a b c d e f
18:45:20 <palomer> and you don't want to bother about the order
18:45:26 <Smerdyakov> This is a contrived example, and now you must pay the price.
18:45:33 <Pseudonym> Apparently.
18:45:42 <palomer> even better, a three argument function
18:45:58 <Pseudonym> OK, give me a concrete example.
18:46:03 <palomer> f :: array -> scalar -> complex number
18:46:10 <Pseudonym> All right.
18:46:23 <palomer> and I don't want to bother remembering the order
18:46:38 <palomer> well, I could simply define f as commutative
18:46:39 <Pseudonym> OK, then, this is easy.
18:46:49 <Pseudonym> class F a b c | a b -> c where
18:46:53 <Pseudonym>    f :: a -> b -> c
18:47:02 <Pseudonym> instance F Array Scalar Complex where
18:47:08 <Pseudonym>   f a s = something
18:47:15 <Pseudonym> instance F Scalar Array Complex where
18:47:19 <Pseudonym>   f s a = f a s
18:47:28 <Pseudonym> It's not pretty, but it's possible.
18:47:36 <Pseudonym> It pushes the burden back onto the person writing the function.
18:47:40 <palomer> erm, you forgot one
18:47:43 <palomer> I believe
18:47:51 <Smerdyakov> You can even use fundeps to automate the generation of the second instance, right?
18:48:10 <Pseudonym> Smerdyakov: I don't think so.
18:48:11 <palomer> thats what my 'commutative' operator would do
18:48:38 <Pseudonym> I'm not sure that this would be generally useful enough.
18:48:54 <Pseudonym> However, some kind of TH recipe would be nice.
18:48:57 <palomer> we're so used to remembering the order of arguments
18:49:07 <Smerdyakov> I think I used the wrong word where I said "fundeps."
18:49:15 <palomer> take map, for example, what does it change that the list comes first and the function second?
18:49:28 <Pseudonym> map only takes one argument.
18:49:33 <Pseudonym> All functions in Haskell only take one argument.
18:49:45 <Smerdyakov> Something like: instance F a b c => F b a c | a b -> c where f s a = f a s
18:49:45 <palomer> conceptually
18:49:46 <Pseudonym> map :: (a -> b) -> ([a] -> [b])
18:49:59 <Pseudonym> Oh, yes.  You might be able to do that.
18:50:19 <Pseudonym> I think you have circular instances there, and the semantics of that arent' clear.
18:50:27 <Pseudonym> But it should work, at least in GHC.
18:50:33 <Smerdyakov> That's OK. I'm infinitely awesome.
18:50:34 <palomer> yes, code might become unreadable
18:50:57 <palomer> Howover, I believe it could be genuinely usefull in certain cases
18:51:03 <Pseudonym> palomer, is what you really want something like _named_ arguments?
18:51:19 <palomer> named arguments would be something else
18:51:35 <palomer> I'm talking about commutativeness from a purely mathematical p.o.v
18:52:13 <palomer>  in haskell, is it possible to define, say, multiplication between an
18:52:13 <palomer>       array and a scalar? <--- no? you can't do * :: array -> scalar -> array ?
18:52:46 <palomer> thats an example of where commutativity is useful
18:53:11 <Smerdyakov> Is not
18:53:18 <palomer> eh?
18:53:36 <palomer> which statement?
18:53:58 <Smerdyakov> "thats an example of where commutativity is useful"
18:55:55 <palomer> its more intuitive to say that a function is commutative than to enumerate all (in this case 2) cases where it might be called
18:56:20 <Smerdyakov> Yes, but why is it useful to be able to have it be commutative?
18:56:57 <palomer> a scalar and an array?
18:57:17 <Smerdyakov> It's irrelevant in what order you pass the parameters.
18:57:26 <palomer> is it?
18:57:39 <palomer> I did not know that
18:57:39 <Smerdyakov> Yup
18:57:46 <palomer> for all functions?
18:57:47 <Smerdyakov> Nonono
18:57:51 <Smerdyakov> I don't mean what you think I mean.
18:57:59 <palomer> I hope you don't
18:58:05 <Smerdyakov> I mean that there is no benefit to the user through being able to use one order instead of the other.
18:58:17 <palomer> ah
18:58:32 <palomer> I don't want to remember that vectors come first, or scalars come first
18:58:33 <Pseudonym> Right.
18:58:44 <Pseudonym> Now there may be some benefit in _optimisation.
18:58:45 <palomer> I think it mathematically equivalent
18:58:45 <Smerdyakov> palomer, then you are not equipped to be programming.
18:58:58 <Pseudonym> That is, a compiler may be able to reorder expressions better if it knows some function is commutative.
18:59:05 <palomer> Smerdyakov: that's the second degrading statement you make in so many days!
18:59:20 <palomer> Pseudonym: there's one application
18:59:21 <Pseudonym> But really, for stuff like this, it's not a decision the compiler should be making.
18:59:22 <Smerdyakov> palomer, I don't really care if it's "degrading" if it's true.
18:59:43 <Pseudonym> A compiler shouldn't even reorder the addition of two floats.
18:59:49 <palomer> the idea of commutativeness is simply intuitive
18:59:50 <Pseudonym> It breaks the IEEE 754 spec.
19:00:20 <Pseudonym> palomer: It's a nice idea, but I don't think it's general enough to be useful.
19:00:22 <palomer> then one would not define multiplication between floats as commutative
19:00:40 <Pseudonym> Right, so the multiplication between a float scalar and an array of floats is similarly not commutative.
19:00:57 <Pseudonym> Rationals, yes.  Ints, yes.  Floats, no
19:01:03 <palomer> exactly
19:01:21 <palomer> think of multiplication between ints, rationals and complex numbers
19:01:36 <palomer> imagine if I had (which is probably done) to define two of each
19:01:47 <palomer> instead of defining one, and making that instance commutative
19:02:05 <palomer> or grouping them and making the operation on the group commutative(I believe haskell can do that)
19:02:26 <palomer> actually, that brings me to the next question: can one define a function on a group of types?
19:03:10 <Pseudonym> Yes, you can use type classes.
19:03:24 <palomer> if the groups of types share some common properties? say for each type a there exists a function f such that f : a -> a
19:03:32 <Pseudonym> Sure.
19:03:35 <palomer> last question: does haskell have symbols?
19:03:37 <palomer> a la scheme?
19:03:37 <Pseudonym> Num is a good example.
19:03:47 <Pseudonym> You mean atoms?
19:03:53 <Pseudonym> a la lisp?
19:04:15 * Pseudonym doesn't know enough scheme terminology
19:04:20 <Riastradh> Pseudonym, no, he means symbols a la Scheme, which are the same things as symbols a la Lisp.
19:04:20 <Pseudonym> Probably a good thing. :-)
19:06:17 <Pseudonym> Ah, I see.  No, it doesn't.
19:06:31 <Smerdyakov> palomer, what would it mean for Haskell, a very static sort of a language, to "have symbols"?
19:06:52 <Smerdyakov> All of the names you give variables are lost during compilation.
19:07:25 <palomer> you could pass messages to functions
19:07:36 <palomer> Riastradh: expound on your knowledge of the usefulness of symbols
19:07:44 <Riastradh> Smerdyakov, the same sort of thing is done with most Lisp implementations.
19:08:39 <Riastradh> The closest things to 'symbols' in a statically typed language that I can think of are OCaml's 'polymorphic variants.'
19:08:53 <Smerdyakov> Riastradh, don't these Lisp implementations generally allow you to go so far as to manipulate the code at run time, in essentially its original form?
19:09:15 <Riastradh> If you use EVAL, yes, but EVAL is evil, not used very often, and thus that sort of thing is optimized away.
19:09:33 <palomer> yes, polymorphic variants are nice
19:09:51 <palomer> thats exactly the kind of thing im looking for
19:10:24 <Riastradh> Haskell doesn't have them.
19:12:14 <Smerdyakov> palomer, why do you want polymorphic variants or 'symbols'?
19:16:05 <palomer> one example is message passing
19:16:59 <palomer> and I plan to do future research in symbolic manipulations
19:17:30 <palomer> and I'm guessing symbols would be quite usefull for that
19:17:46 <Smerdyakov> I don't see how either one of those calls for such things.
19:18:32 <rpr> how about this: data Material = Oak | Maple | Steel 
19:18:58 <rpr> data Color = Blue | Red | Green
19:19:01 * palomer gives rpr a high five
19:19:01 <rpr> I want to then say
19:19:26 <rpr> data Attribute = Color | Material
19:19:27 <Smerdyakov> palomer, eh?
19:19:41 <Smerdyakov> rpr, then say it!
19:21:26 <Riastradh> rpr, data Attribute = ColorAttribute Color | MaterialAttribute Material
19:22:04 <Smerdyakov> palomer, do you have an example of a situation where you polymorphic variants or 'symbols' are indispensible or not?
19:22:35 <palomer> erm, not on hand, but you cannot claim that symbolic manipulation cannot be helped with the presence of symbols in a language?
19:22:50 <palomer> Riastradh: what's your take on this?
19:22:52 <Smerdyakov> I can.
19:23:00 <Riastradh> palomer, on what?
19:23:01 <Smerdyakov> "Symbol" is a mis-named feature in this case.
19:23:29 <Smerdyakov> All they provide is an easy way to use a single statically allocated hash table, essentially.
19:25:22 <Pseudonym> I'm not sure what this buys you that, say, Dynamic doesn't.
19:25:38 <palomer> Riastradh: the importance of symbols
19:26:00 <Smerdyakov> Pseudonym, what what buys you?
19:26:11 <Pseudonym> What "symbols" buy you.
19:26:18 <Pseudonym> That Data.Dynamic doesn't.
19:26:31 <Pseudonym> I concede that polymorphic variants _may_ be useful in some circumstances.
19:26:51 <Pseudonym> But I suspect they don't interact well with, say, higher-ranked types.
19:27:17 <Pseudonym> Unless you impose a rule, say, that your type switch has to be on fully instantiated types only.
19:29:28 <rpr> interrupted.  now  data Production = Sku Attribute String
19:30:13 <Pseudonym> Lunch.  BBIAB
19:30:15 <rpr> you basically end up having to do what Riastradh pointed out.  You need those extra type constructors.
19:30:44 <palomer> true
19:30:58 <Smerdyakov> rpr, are you participating in this discussion or asking for help on a problem you are having?
19:31:08 <rpr> ie ColorAttribute , MaterialAttribute...
19:31:35 <rpr> I am point out a case where polymorphic variants would be valuable.
19:31:57 <Smerdyakov> And you're saying they'd be valuable because you'd save a layer of value constructors?
19:32:05 <rpr> see "why do you want polymorphic variants or 'symbols" above.
19:32:47 <rpr> yes
19:33:05 <rpr> imagine the example with about 10 different kinds of attributes.
19:33:08 <Smerdyakov> Hm. That's an insignificant benefit, as far as I'm concerned, and it runs counter to modularity, sorta.
19:34:27 <rpr> well its in the eyes of the beholder.  it seemed significant enought to add to OCaml
19:35:02 <Smerdyakov> The implementors are addicted to kludges. :P
19:35:55 <rpr> purity will be haskell's ultimate failing.  Haskell is for Haskell's sake.
19:37:06 <Smerdyakov> I haven't yet seen a convincing argument for the overall utility of polymorphic variants.
19:40:50 <palomer> asking about the utility of a feature on the spot is like asking the utility of functional programming
19:44:21 <rpr> There are some papers in citeseer that discuss and address their usefullness.  I don't know squat about any of it to attempt a convincing argument of any kind.
20:21:29 <Leimy> howdy'
20:42:10 <Pseudonym> Another thing to consider is that type classes can also be used to do some of this.
20:42:29 <Pseudonym> If you have a function which you need to define on more than one type, a type class can help.
20:47:06 <Pseudonym> http://www.ddj.com/documents/s=1503/ddj0001vs/jan00.htm
21:33:28 <palomer> hello
21:33:37 <palomer> is it possible to step through with a haskell intepreter?
21:34:56 <Pseudonym> You probably couldn't understand the trace even if you could.
21:35:08 <Darius> I don't think so.  Anyways, following the true execution path would be quite hard to understand.  You can, however, use one of the various debugging tools.
21:35:17 <palomer> aw man
21:35:32 <palomer> stepping is the one true way of debugging
21:35:54 <Smerdyakov> What about decomposing your code into many functions and having test cases for each?
21:36:06 <rpr> novel concept that
21:36:07 <Pseudonym> Debugging is a poor substitute for testing.
21:36:26 <Pseudonym> Having said that, stepping is _not_ the one true way of debugging.
21:36:43 <Pseudonym> To understand why, you have to understand what a "bug" is.
21:37:28 <Pseudonym> A program has two interpretations.  There's your interpretation, which is what you meant to write, and there's the compiler's interpretation, which is what you actually wrote.
21:37:43 <Pseudonym> A bug is a mismatch between the two interpretations.
21:37:52 <palomer> not always
21:38:01 <palomer> sometimes I think I wrote it the correct way
21:38:07 <palomer> and stepping reveals that I made a logical error
21:38:15 <palomer> like when writing an algorithm
21:38:22 <Pseudonym> Right.  So there's a mismatch between your interpretation and the compiler's.
21:38:35 <Pseudonym> You meant to write it the correct way.
21:38:44 <Pseudonym> That's what you intended.
21:38:50 <palomer> by that logic, I meant never to make a mistake
21:38:50 <palomer> yes
21:39:10 <Pseudonym> That's right.  It takes a poor programmer to intend to write a mistake.
21:39:31 <Darius> I'd think it would take a good programmer.
21:39:33 <Pseudonym> (Actually, that's not entirely true.  There are some testing methodologies which involve deliberately including mistakes.)
21:39:52 <Pseudonym> Capture-recapture testing.
21:39:56 <Pseudonym> But I digress.
21:40:20 <Pseudonym> So debugging is the process of finding out where the two interpretations differ.
21:40:40 <Pseudonym> Buddha, for example, is based directly on this concept.
21:40:49 <palomer> I am buddha
21:40:53 <Pseudonym> The debugger asks you if its interpretation of various bits of code is correct.
21:41:12 <Pseudonym> And between you and the debugger, you work out where the bug is together.
21:41:20 <palomer> its a team
21:41:28 <palomer> like batman and robin
21:41:33 <Pseudonym> Besides, the one true way is printf-style debugging.
21:43:14 <palomer> NO
21:43:29 <palomer> stepping achieves the same result
21:43:39 <palomer> except you don't have to spend the time to write new code
21:43:46 <Darius> What do you do without a stepper? Cry?
21:43:51 <palomer> yes
21:43:53 <palomer> :(
21:43:55 <palomer> i suffer
21:44:19 <Pseudonym> See, the thing is, Haskell doesn't have a "nice" evaluation order.
21:44:29 <Pseudonym> For some definitions of "nice".
21:44:58 <Darius> Of course, technically, printf-style debugging isn't too available in Haskell.
21:46:08 <dennisb> Darius: sure it is, there is trace
21:46:57 <Darius> trace isn't Haskell98 and unless you consider the FFI to be standard (which is reasonable now), there is no way to write it.
21:47:25 <dennisb> well, at least all implementations have it. A debugger is not haskell98 either
21:47:38 <dennisb> well, you can't say that, but anyway
21:47:43 <Darius> The 'technically' was there for a reason, I wasn't being too serious.
21:48:12 * Darius was being over-pedantic.
21:48:32 <Pseudonym> Hell, you don't need a debugger.  Prove your programs correct!
21:49:14 <dennisb> I have this program that doesn't seem to terminate, could you please prove that it does?
21:49:40 <Darius> Probably.
21:49:52 <Pseudonym> For a specific program, might be able to.
21:50:10 <Pseudonym> Or is your program an interpreter?
21:52:45 <dennisb> it's not a real program, had it been it would of course be a self interpreter
21:53:03 <dennisb> It was more a remark about the halting problem then anything else
21:53:26 <Darius> Actually, the question is somewhat off, you want "could you please prove whether it does or not?"  It's impossible to prove that it does if it doesn't.
21:54:17 <dennisb> true
22:36:05 <edlang> Hi - I'm having some problems using the HaXml library with ghc on Debian. I'm not sure how to import it. Does anyone know how to correctly import it?
22:40:54 <harsha123> Hello everyone
22:41:04 <harsha123> hi Pseudonym
22:41:10 <harsha123> hi Smerdyakov
22:41:10 <Pseudonym> G'day.
22:41:39 <jdrake> 0.7734
22:44:22 <harsha123> Pseudonym: have you used Hurd anytime?
22:44:34 <Pseudonym> Once, about two years ago.
22:44:55 <harsha123> howz it? as stable as the Linux kernel
22:45:01 <Pseudonym> Nowhere near.
22:45:10 <harsha123> ok..
22:45:12 <Pseudonym> Linux has taken many years to get as stable as it is.
22:45:16 <jdrake> linux stable? 
22:45:36 <Pseudonym> jdrake: Sure it is, if you use the one that comes compiled for your distro.
22:45:37 <harsha123> jdrake: hmm lets not be pefectionists for a while..;)
22:46:04 <jdrake> just trolling :-)
22:46:06 <Pseudonym> It's when you start using odd combinations of options that the #ifdef spaghetti starts to show.
22:46:28 <jdrake> i know what haskell needs!
22:46:44 * jdrake introduces 'goto' to the haskellites
22:47:04 <Pseudonym> And gosub.
22:47:14 <jdrake> sure
22:47:40 <Pseudonym> A former colleague of mine actually wrote and submitted a paper about putting global variables in prolog.
22:47:50 <jdrake> in basic was there any way of passing along parameters in a gosub?
22:48:00 <Pseudonym> Nope.
22:48:06 <Pseudonym> You had to use global variables.
22:48:17 <jdrake> i never used gosub, i always used goto
22:48:42 <jdrake> i actually thought at one time that you couldn't write a program without goto
22:48:59 <Pseudonym> Well in ANSI Basic, you can't.
22:49:11 <jdrake> even as i ventured into C
22:50:20 <Pseudonym> http://citeseer.nj.nec.com/107553.html
22:50:24 <Pseudonym> There you go.  I'm not kidding.
22:51:02 <Pseudonym> Can you imagine what would happen if someone suggested this to Haskellers?
22:51:17 <jdrake> no, i never got into haskell
22:51:21 <jdrake> i am only starting to get into ocaml
22:51:27 <Pseudonym> Fair enough.
22:51:33 <Pseudonym> We're all functional programmers here.
22:51:38 <Pseudonym> We even tolerate *spit* Scheme.
22:51:47 <jdrake> after ocaml is cool with me, then I can move onto haskell
22:52:04 <jdrake> this is about the 4th or 5th time trying to *get* functional programming
22:52:18 <jdrake> ocaml allows me to not get it completely with the ; operator
22:53:41 <jdrake> i am trying to figure out what project I can start on that is small and console based
22:54:21 <Pseudonym> Clearly, an IRC bot.
22:54:27 <edlang> ohhh.
22:54:55 <Pseudonym> Actually, first interactive program I write in any new language that I learn is Eliza.
22:54:55 <jdrake> seriously suggesting that?
22:54:59 <harsha123> jdrake: dont forget lambdabot is Pseudonym's creation ;)
22:55:11 <jdrake> noted
22:55:46 <harsha123> Pseudonym: no offence meant :p
22:55:51 <Pseudonym> Though lambdabot isn't really mine any more.
22:55:57 <jdrake> eliza is obviously a bot of some sort
22:55:57 <Pseudonym> Most of the code isn't mine.
22:56:02 <jdrake> i found it easily enough
22:56:07 <jdrake> but not the home page
22:56:19 <Pseudonym> Eliza isn't a bot exactly.
22:56:27 <Pseudonym> A console app is sufficient.
22:56:47 <jdrake> what exactly is she?
22:56:57 <jdrake> (Dr. Spaitso without the voice?)
22:57:47 <Pseudonym> Kind of.
22:57:52 <Pseudonym> She's a gestalt psychologist.
22:57:55 <jdrake> ?
22:58:55 <Pseudonym> http://chayden.net/eliza/Eliza.html
23:01:40 <harsha123> Pseudonym: is it like the Doc in emacs?
23:01:54 <Pseudonym> Very much so.  
23:02:17 <harsha123> have you replicated it using haskell?
23:03:15 <Pseudonym> Yeah, but I don't think I have it any more.
23:04:07 <jdrake> Pseudonym, this thing is not bad... http://darwinports.gene-hacker.net:8080/121
23:04:25 <jdrake> that being a made up story 
23:05:46 <Pseudonym> There was another Eliza-like program in the 60s called Parry, which simulated a paranoid patient.
23:05:58 <Pseudonym> So naturally, someone got Eliza to diagnose Parry.
23:06:42 <jdrake> how did it go
23:06:52 <Pseudonym> Just trying to find the transcript.
23:07:31 <Pseudonym> http://www.stanford.edu/group/SHR/4-2/text/dialogues.html
23:10:17 <harsha123> are these programs based on AI concepts?
23:10:45 <Pseudonym> Define "AI concepts".
23:10:57 <harsha123> hehe.. there I go.. 
23:11:15 <Pseudonym> They're usually thought of as pioneering AI.
23:11:21 <Pseudonym> But they're actually not very smart at all.
23:11:27 <harsha123> Ok..
23:11:36 <Pseudonym> Very simplistic, in fact.
23:12:24 <jdrake> parry is cool
23:12:59 <harsha123> morning shapr
23:13:49 <Pseudonym> G'day.
23:14:16 <Pseudonym> If you like parry, this one is even better.  It's not interactive, but it's very cool.
23:14:20 <Pseudonym> Written by a friend of mine.
23:14:31 <Pseudonym> http://www.elsewhere.org/cgi-bin/postmodern/
23:14:45 <Pseudonym> It generates postmodern essays.
23:16:10 <jdrake> post modern?
23:16:19 <harsha123> yeah. whats that?
23:16:30 <jdrake> modern implies now
23:16:53 <Pseudonym> In the early 20th century, people considered themselves "modern".
23:16:58 <shapr> goood morning #haskell!
23:16:59 <Pseudonym> It's now referred to as "the modern era".
23:17:06 <harsha123> hi shapr
23:17:07 <Pseudonym> So nowadays, it's "post-modern".
23:17:09 <Pseudonym> G'day!
23:17:21 <jdrake> "If patriarchialist socialism holds, we have to choose between the  postcapitalist paradigm of consensus and neocapitalist structural theory. It  could be said that the premise of dialectic discourse suggests that discourse  comes from communication. "
23:17:25 * shapr yawns
23:17:47 <shapr> jdrake: that's an amusing quote
23:18:20 <Pseudonym>  "Society is intrinsically dead," says Sartre. If textual narrative holds, we have to choose between the modernist paradigm of expression and postmaterial semioticism. But Lyotard promotes the use of nihilism to deconstruct hierarchy.
23:18:30 * harsha123 is gone bonkers
23:18:44 <flippo> looks like a job for a haskell bot
23:18:51 <shapr> flippo: what?
23:18:55 <shapr> Sartre quotes?
23:18:58 <shapr> @arr
23:18:59 <lambdabot> Smartly me lass
23:19:06 <flippo> shapr: I don't think it's a real quote
23:19:09 <Pseudonym> I love the fact that it generates references too.
23:19:28 <Pseudonym> la Fournier, O. (1977) The modernist paradigm of expression and nihilism. Cambridge University Press
23:19:33 <flippo> ooh, a pirate bot
23:19:34 <jdrake> send one of these into an actual magazine and see if one gets printed
23:19:48 <shapr> flippo: you could write the sartre plugin for lambdabot :-)
23:19:59 <Pseudonym> @arr
23:19:59 <lambdabot> Get out of me way, yeh landlubber
23:20:02 <flippo> shapr: I knew you were going to say that next :)
23:20:06 <Pseudonym> See, this is supposed to be a pirate.
23:20:20 <jdrake> so is lambdabot a recurisve loop
23:20:39 <Pseudonym> But it didn't once threaten to h4X0R mY m4Ch33n!!!!!!1!!!!
23:20:49 <Pseudonym> Or tell me about its Mp3z!!!!!1!!
23:21:11 * RIAA_POLICE arrests Pseudonym
23:21:19 <Pseudonym> Arrest lambdabot!  It's the pirate!
23:21:24 <harsha123> whats all this drama..??? heheh
23:21:35 <Pseudonym> Help!  Help!  I'm being repressed!
23:21:50 <RIAA_POLICE> Pseudonym, I am your king
23:21:50 <shapr> actually, I've heard some people call lambdabot a recursive loop behind its back
23:22:00 <shapr> but I think they were just trying to hurt its feelings.
23:22:08 <lambdabot> They do?!
23:22:23 <shapr> lambdabot: it's just evil rumors from unhappy people.
23:22:24 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
23:22:35 <harsha123> hehehe..
23:22:38 <lambdabot> Oh, okay. I feel better about it now.
23:22:51 <lambdabot> Sorry, I'm a very sensitive bot.
23:23:16 <RIAA_POLICE> lambdabot: @listcommands
23:23:17 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define","definitions","del-definition","devils","dict","dict-help","dummy","dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements","eval","foldoc","foo","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","lojban","more","msg","part","prelude
23:23:32 <shapr> speaking of mp3z, I found some neat free tracks at timbarsky.com
23:23:34 <RIAA_POLICE> lambdabot: goodbye
23:23:34 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
23:23:35 <Pseudonym> Nope, you won't find an @mp3-search command there.
23:23:46 <shapr> @goodbye
23:23:47 <lambdabot> Hello world. 
23:23:48 <RIAA_POLICE> lambdabot: join #hprog
23:23:48 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
23:23:55 <harsha123> undernet is a great plz for mp3's
23:24:03 <harsha123> you name it and you get it..
23:24:08 <RIAA_POLICE> well goodnight all
23:24:09 <shapr> free legally distributed mp3s?
23:24:13 <shapr> goodnight jdrake
23:24:17 <Pseudonym> Night.
23:24:23 <harsha123> nite jdrake
23:24:31 <RIAA_POLICE> http://china.tyfo.com/int/art/music/cnindex.htm   <-- free mp3
23:24:36 <harsha123> shapr: not legeal ofcourse..!
23:25:10 <shapr> I don't wish to have illegally redistributed material on my computer.
23:25:20 <edlang> umm...
23:25:25 <shapr> not that I think the copyright laws work correctly
23:25:37 <harsha123> shapr:  are you serious?
23:25:38 <edlang> Has anyone here actually used HaXml?
23:25:41 <shapr> yes, I'm serious.
23:25:45 <shapr> edlang: I've used it.
23:25:55 <Pseudonym> Civil disobedience works only if you're willing to tell the world that you broke the law, and face the consequences.
23:25:55 <edlang> shapr: without any problems?
23:26:18 <Pseudonym> Really, either obeying the law or publically flouting it are the only two moral options.
23:26:22 <shapr> harsha123: I feel like programmers are the ultimate victims of a society where it's okay to copy everything freely for one thing
23:26:36 <Pseudonym> Privately ignoring the law is much less justifiable.
23:27:00 <shapr> if you write software and you have copies of lots of mp3s, you should expect people to treat your copyrighted material (your software) the same way, right?
23:27:18 <harsha123> shapr: hmm quite right..
23:27:32 <Pseudonym> That includes, say, breaking the GPL, if you GPL your code.
23:27:37 <shapr> edlang: I switchedto HXmlToolbox because of some missing support for OOo DTDs
23:28:16 <shapr> harsha123: happily, there's lots of legally downloadable music around
23:28:31 <shapr> http://www.goingware.com/tips/legal-downloads.html
23:28:57 <harsha123> shapr: yes I know.. infact i've downloaded a lot of music.. the main reason is i cannot afford them :(
23:29:24 <shapr> but you can afford the music at that link
23:29:35 <harsha123> Ok..
23:31:08 <edlang> how can I force ghc to link against something?
23:31:45 <harsha123> hehe i am pretty sure i wont have sabbath or Maiden..:)
23:31:47 <shapr> edlang: what sort of problems are you having?
23:31:57 <shapr> harsha123: what sort of music do you like?
23:32:25 <edlang> shapr: ghc isn't linking against HSHaXml.o, it seems
23:32:38 <edlang> test.o(.text+0x1b): In function `__stginit_Test_':
23:32:38 <edlang> : undefined reference to `__stginit_TextziXMLziHaXmlziPretty_'
23:32:40 <edlang> lots of stuff like that
23:32:42 <harsha123> hmm heavy metal, alternative, blues ...old pope (depending on my mood)
23:32:52 <shapr> what's old pope?
23:33:13 <harsha123> sorry old PoP 
23:33:17 <shapr> aha
23:33:20 <harsha123> :)
23:33:30 <Pseudonym> That's a frightening thought.
23:33:38 <harsha123> i know.. 
23:33:40 <shapr> it does sound like a nifty genre "old pope"
23:33:46 <Pseudonym> And now, Pope George Ringo with... the Sanctus!
23:33:56 <shapr> edlang: are you trying to compile small test program?
23:34:16 <harsha123> heheh
23:34:24 <shapr> edlang: I've written some 'unit tests' for HXmlToolbox if you'd like to see them
23:34:40 <shapr> I don't have anything for HaXml specifically though
23:34:55 <edlang> shapr: yes, I am. solved that problem - the .a file was 0660 
23:35:01 <edlang> there's still a few other undefined references
23:36:41 <edlang> I'll look at hxmltoolbox now
23:37:33 <shapr> haxml uses a specific type for every tag in a DTD, and hxmltoolbox has a generic recursive tree/node type 
23:38:05 <shapr> that was good for me because I wanted to incrementally refine my xslt-style rewrite on the document
23:38:18 <shapr> but if you want total type safety, haxml is better
23:40:26 <shapr> hxmltoolbox has the DTD checking as a separate pass
23:40:38 <shapr> using regexps surprisingly
23:43:01 <Darius> shapr: I installed HaRe, however, going through the example from the demo, it doesn't seem to like infix operators.
23:44:00 <shapr> I wish they'd open these sorts of projects to allow non-project members to contribute
23:52:35 <harsha123> shapr: what motivates you to program? :)
23:53:38 <shapr> I get to play with toys
23:53:59 <harsha123> hehehe..
23:54:24 <harsha123> but..
23:54:55 <shapr> ?
23:55:03 <edlang> shapr: What did you name the HXmlToolbox directories under .../import/ ?
23:55:20 <harsha123> i feel it very difficult to motivate my self..
23:55:27 <harsha123> though i like programming
23:55:28 <shapr> harsha123: write stuff you want for yourself
23:55:52 <Darius> If you like programming, wouldn't that be motivation enough?
23:57:19 <harsha123> yes, but i feel there is something thats coming in between.. i usually get a concentration lapse
23:58:56 <edlang> shapr: and could I please have those unit tests?
23:59:08 <Pseudonym> See, I think your problem is that you need to scratch an itch.
23:59:21 <Pseudonym> You need to write something that you would want.
