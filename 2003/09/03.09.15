00:14:33 * shapr yawns
00:16:53 <Verbed> http://strangeloop.dnsalias.net:8080/Poetry/Lowe/TheAssertion
00:20:09 <harsha123> shapr: hmm take a nap.. you worked long last nite :)
00:20:26 <shapr> actually, I was reading fun stuff, cryptonomicon
00:20:38 <harsha123> shapr: whatz that?
00:20:43 <shapr> you could call it motivational material maybe...
00:20:48 <shapr> it's a book by Neal Stephenson
00:21:01 <harsha123> shapr: hmm.. ok..
00:21:14 <harsha123> shapr: were you reading it online?
00:21:47 <shapr> nope, I have a dead tree version.
00:22:11 <harsha123> ok
00:23:50 <shapr> this is his website: http://www.well.com/user/neal/
00:26:18 <harsha123> shapr: hmm i have to check it out.. :) i need motivation..:)
00:26:57 <shapr> Snow Crash is motivational coding material.
00:27:19 <shapr> http://www.wikipedia.org/wiki/Neal_Stephenson
00:30:59 <harsha123> brb guys.. trying a new kernel
00:39:29 <Heffalump> 'lo
00:41:10 <earthy> a few notes with regard to Neal Stephenson: he's a fair coder himself, and did some cool stuff on BeOS
00:55:27 * shapr boings
00:55:40 <ski> hi shapr
00:55:45 <shapr> hi skylan
00:55:47 <shapr> er, ski
00:55:52 <ski> :)
00:56:15 <ski> what is "boings" ?
00:56:22 <shapr> jag hoppar
00:56:27 <shapr> jag studsar
00:56:29 <ski> fysiskt ?
00:56:30 <shapr> I boing
00:56:35 <shapr> yes, I bounce up and down on my chair
00:56:55 <ski> ooo'kay    ;)
00:57:01 <shapr> usually from one or more of impatience, frustration, distraction, enthusiasm, etc
00:58:29 <ski> i sometimes sort of vibrate my feet (i.e the (sv.) "led" between the foot and the lower part of the leg)
00:58:37 <shapr> calf
00:58:45 <shapr> yes, I do that too
00:59:04 <ski> isn't calf the lower part of the leg (or perhaps the big muscle on it) ?
00:59:15 <shapr> oh, you mean ankle
00:59:23 <shapr> the joint that joins the foot and the calf
00:59:30 <ski> yes, that's definitely it !
01:00:09 <ski> i'd momentarily forgotten that word "ankle" ..
01:00:25 <ski> and joint is "led", i think
01:00:33 <shapr> ok
01:00:56 <ski> as in "handled","fotled",etc
01:01:42 <ski> i'm having a small test "tentamen" in logic today ..
01:02:27 <ski> probably should soon look up exactly what we are supposed to have on it .. ;)
01:03:45 <ski> i think i knw most of it perhaps some exact terminology and particular syntax (like which parens can be omitted)
01:03:51 <ski> s/knw/know/
01:05:09 <ski> shapr : which of the reason did you now have for boinging(?) ?
01:05:28 <ski> s/reson/resons/
01:28:45 <earthy> shapr always boings, just for the heck of it
01:28:55 <ski> heh :)
01:43:41 <shapr> hey, can anyone else see the images on HaWiki?
01:43:46 <shapr> or have they only disappeared for me?
01:44:11 <shapr> I have been trying to do some i18n website stuff, so it could just be my settings...
01:44:20 <ski> what images ?  like the lambda on 
01:44:25 <ski> Frontpage ?
01:45:06 <ski> if so, then yes i can see it.
01:46:02 <shapr> http://www.haskell.org/moinwiki/img/moin-updated.gif
01:46:11 <shapr> can you see the images here: http://www.haskell.org/hawiki/RecentChanges ?
01:46:35 <earthy> I see a lambda
01:46:43 <ski> 404 on the first link
01:46:47 <earthy> but not the marks
01:47:04 <ski> no marks here either
01:47:16 <shapr> ok
01:47:22 <shapr> I'll send an email to Keith Wansbrough then
01:49:19 <earthy> and in the hawiki FrontPage there are quite a few broken images as well (such as the link to python.org)
01:49:31 <earthy> (why is the hawiki in python?)
01:49:43 <shapr> because there wasn't a wiki written in Haskell at the time
01:50:04 <earthy> ah. :)
01:50:21 <shapr> speaking of which, I don't have the latest wiwiwi code
01:50:33 <shapr> Lunar^: do you have the latest wiwiwi code? or is it online somewhere?
02:08:54 <Lunar^> shapr: I used your darcs repository
02:35:35 <ski> bye
03:39:16 <shapr> twisted
03:39:30 <shapr> hey harsha123, are you running 2.4.22 now?
03:39:38 <Lunar^> shapr: Just finished my first working CGI :)
03:39:49 <shapr> Lunar^: yay! do you have the source online?
03:39:51 <harsha123> shapr: lots of problems.. hmm not able to get my sound working
03:39:56 <shapr> harsha123: using ALSA?
03:40:01 <Lunar^> understanding WASHHTML is sharp though
03:40:12 <harsha123> shapr: Hey i dont have that option in my 2.4.20
03:41:18 <harsha123> when I run mpg123 on my mp3 .. i dont get any sound. i dont get any error either.
03:42:03 <shapr> did you enable either ALSA or the OSS modules when you configured your kernel?
03:42:40 <harsha123> shapr:  i didnt find any ALSA stuff in my 2.4.20.. I found lots of OSS modules..
03:43:29 <harsha123> shapr:  and didnt know which to choose from?
03:43:40 <shapr> which sound card do you have?
03:44:19 <harsha123> hmm my lspci gives me " 00:01.4 Multimedia audio controller: Silicon Integrated Systems [SiS] SiS PCI Audio Accelerator (rev 02"
03:44:35 <shapr> sounds like an SiS card to me.
03:44:46 <harsha123> shapr:  hmm yes it is
03:44:47 <shapr> I think there's an OSS module for that card.
03:45:46 <harsha123> lspci -n gave me "00:01.4 Class 0401: 1039:7018 (rev 02)"
03:46:10 <harsha123> vendor 7018.. ie Trident -D
03:46:33 <harsha123> shapr: this thing has taken me more than an hour :(
03:46:54 <shapr> go into your configure menu, enable OSS modules, look for the SiS module
03:46:56 <shapr> enable it
03:47:11 <harsha123> hmm Ok brb. give me some time
03:47:38 <shapr> you'll have to rebuild your modules, but maybe not your kernel
03:48:26 <harsha123> shapr: i do not want it as a module..
03:48:41 <harsha123> shapr: i thought would be better in the kernel
03:49:05 <shapr> personally, I don't think it makes so much difference, but I've never done detailed tests of both ways.
03:49:29 <shapr> I try to build everything as a module, and enable lots of extra modules, but only load the ones I need
03:49:49 <shapr> then when I suddenly have to work on a windows NTFS drive and fix it, I can just load the module, but before it wasn't using up memory.
03:50:14 <harsha123> shapr: am not sure how to do it.. have some time to help me ?
03:50:28 <shapr> a little bit
03:50:28 <harsha123> :)
03:50:37 <harsha123> shapr: ok
03:50:44 <shapr> how do you configure your kernel?
03:50:48 <shapr> menuconfig? xconfig?
03:50:54 <harsha123> menuconfig
03:51:21 <harsha123> i ll select it as a module.. 
03:51:25 <harsha123> dunno after that
03:51:31 <shapr> that's pretty much it.
03:51:45 <shapr> then you rebuild just the modules, or everything if you prefer.
03:51:46 <harsha123> shapr: btw whats OSS ?
03:52:02 <shapr> 'Open Source Sound' I think
03:52:09 <harsha123> shapr: Ok..
03:52:12 <shapr> ALSA is Advanced Linux Sound Architecture
03:52:19 <harsha123> Ok
03:53:58 <harsha123> shapr:  dont see any SiS styff in OSS
03:54:03 <shapr> I don't either...
03:54:25 <harsha123> hehehe
03:54:57 * shapr searches
03:55:04 <adept> are you people discussing 2.4.22 here?:)
03:55:29 <harsha123> adept: 2.4.20
03:56:18 <shapr> looks like SiS drivers exist in ALSA
03:56:30 <harsha123> shapr: where did you find AlSA ?
03:56:36 <shapr> I have it installed
03:56:39 <shapr> it's what I use
03:56:40 <harsha123> shapr: I dont see them
03:56:47 <shapr> which distro are you using?
03:56:56 <harsha123> debian unstable main
03:57:03 <shapr> I'm also using debian unstable
03:57:11 <harsha123> hmmm..
03:57:11 <adept> harsha123: then get alsa-source and make modules
03:57:17 <shapr> try apt-get -uf install alsa-source
03:57:18 <shapr> yah
03:57:24 <harsha123> Ok brb
03:57:25 <shapr> what adept said :-)
03:57:31 * shapr goes off to lunch with his woman
03:57:33 <shapr> bbl
03:57:33 <adept> harsha123: i can provide you with script i'm using for that matter
03:57:57 <harsha123> adept: ok.. what should i do?
03:59:06 * harsha123 is downloading alsa-source
03:59:45 <harsha123> adept: i got a config. screen
04:00:04 <harsha123> adept: blue color.. :)
04:00:04 <adept> harsha123: choose your soundcard there, that all for now
04:00:10 <harsha123> Ok
04:00:22 <adept> harsha123: and reply to my msg, i dont want to post shell scripts here :)
04:00:51 <harsha123> msg???
04:00:55 <harsha123> i havent got any
04:20:58 <harsha123> or use --with-kernel=dir option to specify another directory with kernel
04:20:58 <harsha123> sources (default is /usr/src/linux).
04:21:48 <shapr> do you use make-kpkg?
04:22:33 <adept> shapr: yep. this is escapee from private chat we are having behind the curtains :)
04:22:40 <shapr> ah ok
04:27:01 <d33p> ewr
04:37:33 <cm> hiho * :)
04:37:45 <shapr> wassup?
04:39:32 <cm> nada
04:39:53 <shapr> ghc-cvs debs in unstable
04:39:57 <shapr> includes -farrows support, yay!
04:40:32 <Igloo> Hmmm, messages to glasgow-haskell-users@ are making it to the archives but not my inbox
04:40:41 <Igloo> Anyone else about on it?
04:41:20 <shapr> I have messages from yesterday
04:41:46 <Igloo> Including  GHC 6 on sparc-*-*   Donald Bruce Stewart  ?
04:41:48 <harsha123> adept: thx.. hehehe.. 
04:41:52 <shapr> Igloo: yup
04:42:08 <Igloo> Hmmm
04:42:12 <Igloo> Ta
04:42:48 <adept> shapr: can you recommend article about arrow which is a breath-taking reading? :)
04:43:04 <shapr> I think so
04:43:27 <shapr> arrow basics: http://www.haskell.org/arrows/biblio.html
04:43:30 <adept> shapr: well, please do recommend :)
04:43:34 <adept> ah, thanks :)
04:43:42 <shapr> arrows applied: http://www.haskell.org/yampa/
04:43:52 <harsha123> adept: thanx a many :)
04:44:27 <shapr> the two Yampa papers are cool, though only the second one really qualifies as breath-taking to me
04:44:49 <adept> harsha123: dont mention it
04:44:50 * harsha123 feels like kicking his ass
04:45:35 <shapr> whose?
04:45:35 <harsha123> adept: how do i get a kernel provided by debain?
04:45:44 <shapr> install a kernel-image?
04:45:52 <harsha123> Ok
04:45:59 <harsha123> shapr: my ass :))
04:46:09 <adept> harsha123: apt-get kernel-image-2.4.22-1-686-smp in your case
04:46:10 <shapr> oh
04:46:18 <shapr> yay smp!
04:46:19 <adept> harsha123: do you really have multi-CPU box?
04:46:30 <cm> mm arrows
04:46:31 <harsha123> adept: no
04:46:47 <shapr> I have a multi-CPU box.
04:46:54 <cm> it's mean that you are inventing new stuff once i half-way got monads :p
04:46:55 <shapr> it's great for heating my apartment.
04:47:20 <shapr> I can wear biker shorts in my office even when there's a meter of snow in front of my windows.
04:47:55 <adept> harsha123: then "apt-get install kernel-image-2.4.22-1-686"
04:48:05 <adept> harsha123: and then "apt-get install kernel-headers-2.4.22-1-686"
04:48:12 <Igloo> shapr: Can you forward me that mail with full headers please?
04:48:16 <shapr> sure
04:48:21 <adept> shapr: how many CPUs?
04:48:23 <Igloo> ta
04:48:33 <shapr> adept: just two
04:49:12 <shapr> Igloo: standard earthly address?
04:49:25 <harsha123> adept: says "E: Couldn't find package kernel-image-2.4.22-1-686"
04:49:36 <adept> harsha123: "apt-get update" :)
04:49:49 <harsha123> eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeekssssssss :((
04:50:25 <adept> shapr: "Two Yampa papers" = AFPLectureNotes.pdf + "Functional Reactive Programming, Continued" ?
04:50:30 <shapr> yup
04:50:37 <Igloo> Oh, looks like it was just me screwing up my procmail rule actually, unless it changed again
04:51:36 <Igloo> Ooops, only changed admin to bounces on one of the two lines
04:51:53 <adept> shapr: and breathtaking one is "Continued"?
04:52:21 * harsha123 wants to give a GURU status to adept and shapr :)
04:52:48 <shapr> adept: yup
04:54:36 <adept> shapr: and syntax in ghc-cvs is after Ross Paterson?
04:55:38 <shapr> yup
04:56:18 <earthy> arrows look nice
04:56:28 <earthy> as in `hey, I've wanted that'
04:58:43 <Lunar^> I agree about Yampa papers
04:59:04 <harsha123> adept: whats with the initrd image now?
04:59:19 <adept> harsha123: yes, whats with initrd image? :)
04:59:26 <Lunar^> The one about Fruit is also interesting (in the way that it makes you think think think)
04:59:34 <harsha123> initrd - INITial RAMdisk
04:59:42 <harsha123> :))
04:59:53 <adept> harsha123: i know :) what is with it?
05:00:13 <harsha123> hmm says have to add initrd=/initrd.img
05:00:17 <harsha123> into lilo.conf
05:00:38 <adept> harsha123: yep. wise thing to do
05:00:47 <harsha123> Ok
05:01:37 * shapr wonders what just happened to lambdabot
05:01:39 <harsha123> adept: where do i add it ?
05:02:07 <adept> under each line with substring 'vmlin' :)
05:02:11 <harsha123> adept: which kernel ?
05:02:18 <adept> harsha123: 2.4.22
05:02:23 <harsha123> adept:  ok
05:02:40 <Igloo> Anything interesting on the line above on any channel it's on?
05:03:01 <shapr> not that I can see
05:03:56 <Igloo> And you weren't keeping a log of lines received/sent?
05:04:06 <shapr> no
05:04:27 <Igloo> No idea then  :-)
05:04:29 <shapr> but then, lambdabot has been running for several weeks at a time, I thought I didn't need too
05:05:58 <shapr> is ghc-cvs only in HE?
05:06:04 <Igloo> No
05:06:06 <shapr> yay
05:06:26 <shapr> g'day CowGirl 
05:06:31 <CowGirl> hey
05:06:37 <CowGirl> how are u?
05:06:48 <shapr> I'm sleepy, how are you?
05:06:56 <CowGirl> me to, just got home from uni
05:07:31 <harsha123> screwed up big time guys :(
05:08:06 * harsha123 is having a bad day :(
05:08:06 <adept> harsha123: ?
05:10:00 <harsha123> adept: "E: dpkg was interrupted, you must manually run 'dpkg --configure -a' to correct the problem.
05:10:50 <adept> harsha123: you indeed interrupted it? just run proposed command ...
05:11:08 <CowGirl> this isnt haskell related....but anyone have any idea why i netscape wont email thru hotmail...i hit send, the bar down the bottom shows some activity, then stops
05:13:17 <Lunar^> Because Microsoft is evil(tm) ;)
05:14:03 <Lunar^> It always amaze me to say this kind of thing here, knowing that a lot of Haskell dev. is funded by Microsoft
05:14:19 <shapr> yes, I agree.
05:14:22 <shapr> it feels weird.
05:14:25 <CowGirl> it worked before,  but then it just wont send anymore.
05:15:00 <CowGirl> i'd use IE,  but thats worse...it freezes when i type in boxes and hit tab or return
05:18:22 <adept> sound like networking proble to /me
05:19:00 <CowGirl> how could i check that??
05:21:09 <shapr> mmm, I like darcs
05:21:28 <Lunar^> shapr: i.e.?
05:22:15 <shapr> it feels nicer than cvs
05:22:30 <shapr> I get to choose which patches to pull, and any local changes I've made won't be affected.
05:22:50 <shapr> since darcs checks to see if any of my local changes conflict with the remote patches
05:29:46 <Darius> well, we all suspected it.
05:29:58 * lambdabot laughs
05:30:26 <shapr> I was just registering the nickname :-)
05:30:51 <Igloo> Yeah, shapr is clearly just lambdabot's AI module
05:31:49 <Lunar^> lol
05:37:14 <shapr> weird, lambdabot doesn't do anything when I run it now.
05:37:18 * shapr wonders
05:42:09 <harsha123> sorry guys. having a pretty bad day today 
05:42:15 <shapr> that's strange, it works with ghc6 but not with ghc-cvs
05:42:17 * shapr tries again
05:44:07 <harsha123> adept: are you there?
05:44:11 <harsha123> hehehe
05:45:19 <harsha123> shapr: whats up with you?? am having a pretty awful time 
05:45:46 <shapr> what's the problem?
05:46:09 <harsha123> shapr: not today.. my head is in pieces.. :))
05:46:21 <shapr> ok
05:46:37 * harsha123 prefers to leave you guys alone.. 
05:46:49 <shapr> I'm learning a new Zope product in hopes it will transparently persist and restore objects in a database
05:47:01 <harsha123> ok
05:48:00 <harsha123> i need some Tea .. BRB
05:48:47 <cm> tea mmm
05:48:55 <shapr> hi crazney 
05:48:57 <shapr> wassup?
05:49:00 <crazney> hey shapr
05:49:13 <crazney> haskell theoretical question, sec ;-)
05:49:25 <Lunar^> Would a syslog binding be hard to do ?
05:49:55 <shapr> I dunno how syslog works
05:50:09 <Lunar^> $ man syslog
05:50:27 <Lunar^> void openlog( char *ident, int option, int  facility)
05:50:34 <Lunar^> void syslog( int priority, char *format, ...)
05:50:41 <Lunar^>  void closelog( void )
05:50:51 <shapr> hm, complicated ;-)
05:51:22 <crazney> i've been playing around with haskell a bit, and i'm trying to think how best to implement a weird data structure.. in that say i have a dynamically sized grid of NxM blocks.. i want the data structure to be efficient in that i'll be able to run over it finding rows or columns that match a given pattern... i found the most effective way to do this in c was just to allocate a blob of memory and run through it like a 2d matrix.. s
05:51:22 <crazney> o what would be the most effective way of doing something like this in haskell?
05:51:45 <shapr> probably an Array
05:51:48 <Lunar^> openlog and closelog are optionnal
05:51:57 <crazney> the only way i can think of is a list of lists,.. but thats incredibly inefficient..
05:52:05 <shapr> arrays are O(1) to read, I think
05:52:08 <Lunar^> crazney: look at Data.Array
05:52:14 <crazney> hrm
05:52:26 <Lunar^> crazney: It's like array in Ada if you know them
05:52:32 <crazney> i don't.
05:52:42 <crazney> where can i find info on this Data.Array?
05:52:51 <Lunar^> http://www.haskell.org/ghc/docs/latest/html/base/
05:53:00 <shapr> yah, arrays are really straightforward imho
05:53:09 <shapr> I've written various modules that use them
05:53:27 <shapr> I usually construct an array from a list, or from a list comp
05:53:53 <Lunar^> shapr: urg... syslog is vararg.. don't think this would be straightforward
05:54:49 <Lunar^> crazney: any tuples derives Ix, so you just have to use (x,y) for coordinates
05:55:10 <crazney> hrm
05:55:43 <crazney> i don't really get it..
05:55:54 <shapr> Lunar^: I've never looked at the FFI, it might be easy
05:56:45 <shapr> crazney: http://www.haskell.org/ghc/docs/latest/html/base/Data.Array.html
05:57:15 <crazney> shapr: yeah i'm there
05:57:51 <shapr> myarray = array (0,5) [((index),index) | index <- [0..5]]
05:58:14 * crazney blinks
05:58:16 <shapr> myarray2 = array ((0,0),(3,3)) [((x,y),x-y) | x <- [0..3], y <- [0..3]]
05:58:18 <crazney> god i suck at haskell
05:58:26 <shapr> just takes some practice
05:58:31 <shapr> like anything else in programming
05:58:35 <shapr> everyone sucks at first
05:58:37 <Lunar^> crazney: shapr use list comprehension here
05:58:42 <shapr> unless you're Simon Peyton-Jones
05:59:17 <Lunar^> crazney: [x | x <- [0..5]] means the list where x take all the value from 0 to 5
05:59:29 <crazney> ah ok
06:00:10 <Lunar^> [(x, y) | x <- [0..5], y <- [0..3]] means a list of tuples
06:00:24 <crazney> right
06:00:40 <crazney> uhmm.. but how does that work exactly when x is from 0 to 5 and y is from 0 to 3?
06:00:41 * crazney tries
06:00:48 <Lunar^> whose values are (0, 0), (0,1), (0,2), (0,3), (1,0), ...
06:01:04 <crazney> so it loops?
06:01:25 <Lunar^> loops?
06:01:29 <crazney> oh
06:01:30 <crazney> nm :)
06:01:35 <crazney> it does all of them..
06:01:40 <crazney> like, all possible combinations?
06:02:14 <earthy> even Simon Peyton-Jones must've sucked at it once...
06:02:58 <earthy> crazney: yes.
06:03:36 <Lunar^> crazney: You can also add tests here
06:04:09 <Lunar^> [x, x <- [0..100], x `mod` 2 == 0]
06:04:18 <Lunar^> oups
06:04:20 <Lunar^> [x | x <- [0..100], x `mod` 2 == 0]
06:04:48 <crazney> cool
06:05:46 <earthy> or even [ x | x <- [0..], x `mod` 2 == 0 ]
06:05:52 <crazney> how do i actually use this array data type anyway?.. the line you masted doesn't work.
06:06:04 <earthy> for *all* uneven numbers. :) (one has to love laziness)
06:06:07 <crazney> array (0,5) [((index),index) | index <- [0..5]]
06:06:07 <crazney> ERROR - Undefined variable "array"
06:06:09 <Darius> shapr: ghc-cvs has -fparr right?
06:06:37 <crazney> agh
06:06:39 <Darius> import Data.Array (or Array if you wanna be H98)
06:06:53 <crazney> i shouldn't try what earthy said ;-)
06:07:01 <Lunar^> crazney: What environnement are you using ?
06:07:05 <crazney> hugs
06:08:09 <shapr> Darius: I dunno, haven't looked
06:08:16 <earthy> err, even numbers, ofcourse.
06:08:20 * earthy puts his mind back in order
06:08:25 <shapr> Darius: looks like it does
06:08:53 <earthy> crazney: no, but take 700 [ x | x <- [0..], x `mod` 2 == 1 ]  *will* give you the first 700 uneven numbers
06:09:09 <crazney> earthy: yeah thats cool ;-)
06:09:52 <Darius> Wouldn't 'odd' be much clearer (and more efficient) than 'x `mod` 2 == 1'
06:10:05 <earthy> darius: err, yeah. :)
06:10:41 <shapr> is odd part of the Prelude?
06:10:42 <shapr> @type odd
06:10:43 <lambdabot> odd :: Integral a => a -> Bool
06:10:45 <shapr> guess so
06:10:53 <Lunar^> hehe
06:11:20 * Lunar^ really enjoy spending time on this channel :)
06:12:05 <shapr> it must be our sense of humor.
06:12:06 <earthy> more efficient, I don't think so.
06:12:30 <Igloo> shapr: Did it work with ghc-cvs in the end?
06:12:34 <shapr> nope
06:12:38 <shapr> and I don't have time to play with it right now
06:12:54 <Igloo> What did you do, just make clean and then make?
06:13:06 <earthy> given  n `mod` d = r where (q,r) = divMod n d
06:13:09 * Igloo wonders how I get the latest source these days
06:13:14 <shapr> yup, after %s/ghc6/ghc-cvs/ in the Makefile
06:13:33 <shapr> Igloo: darcs get --verbose http://www.ScannedInAvian.org/repos/hlibs
06:13:41 <earthy> divMod n d = if signum r == - signum d then (q-1, r+d) else qr where qr@(q,r) = quotRem n d
06:13:58 <earthy> and  odd = not .  even
06:14:27 <earthy> even n = n `rem` 2 === 0        and     n `rem` d = r where (q,r) = quotRem n d
06:14:42 <Igloo> Hmm, isn't darcs in unstable?
06:15:09 <shapr> no
06:15:12 <shapr> deb http://http.abridgegame.org/debian/ unstable/
06:15:12 <shapr> deb-src http://http.abridgegame.org/debian/ unstable/
06:16:18 <crazney> hrm
06:16:19 <crazney> thats odd
06:16:22 <Igloo> How do I update what I've checked out incidentally?
06:16:31 <crazney> can i paste something?
06:16:37 <Lunar^> go on
06:16:40 <shapr> darcs pull --verbose ...
06:16:46 <crazney> readName :: IO String
06:16:46 <crazney> readName = do
06:16:46 <crazney>               name <- getLine
06:16:46 <crazney>               if name == "" then
06:16:46 <crazney>                 putStrLn "thats no name!"
06:16:48 <crazney>                else
06:16:49 <crazney>                 putStrLn ("hello " ++ name)
06:16:52 <crazney>               return name
06:16:55 <crazney> see the if then else statement..
06:17:02 <crazney> it complains if the else isn't indented an extra space..
06:17:03 <crazney> however
06:17:04 <Igloo> ta
06:17:09 <crazney> checkName :: String -> Bool
06:17:09 <crazney> checkName name =
06:17:09 <crazney>                  if name == "" then
06:17:09 <crazney>                    False
06:17:11 <crazney>                  else
06:17:14 <crazney>                    True
06:17:16 <crazney> is ok.
06:17:18 <crazney> like, it doesn't need to be indented there..
06:17:19 <crazney> why is the do block special?
06:17:35 <Lunar^> Because of indentation matters in Haskell
06:17:39 <crazney> yeah..
06:17:41 <crazney> i get that..
06:17:49 <Igloo> Because do starts an implicit indentation section
06:17:55 <crazney> hrm
06:17:56 <Igloo> It's really do { foo; bar; baz }
06:18:14 <Igloo> So it would put a ; before the else if it started on the same line as the if
06:18:17 <shapr> and the else is really case (name == "") of True -> ... False -> ...
06:18:28 <Lunar^> I usually indent ifs that way : if p \n    then ... \n    else ...
06:18:39 <shapr> if then else is just a sugary case statement 
06:18:56 <crazney> uhm, i haven't learnt about 'case' yet..
06:19:24 <Igloo> shapr: Are you pointing it at a 6.0.1-compiled HToolkit?
06:19:26 <Lunar^> crazney: The way you wrote your code, if you line up if and else in a do notation, that means that "else" is the next "statement" of the do blocl
06:19:31 * Igloo can't test it because I don't have HToolkit
06:19:43 <Lunar^> Igloo: remove FactModule
06:20:11 <crazney> Lunar^: hrm, alright
06:20:27 <shapr> Igloo: no, I don't have HToolkit built at the moment.
06:20:34 <shapr> crazney: case is pretty simple..
06:20:38 <shapr> bim x = case x of
06:20:38 <shapr>                1 -> "it's a 1"
06:20:38 <shapr>                2 -> "it's a 2"
06:20:38 <shapr>                _ -> "it's something else"
06:21:03 <Igloo> Oh, it doesn't build for me without it
06:21:26 <shapr> I had to comment out the FactModule in several places to build without it
06:21:49 <crazney> so case is just like inline pattern matching or something?
06:21:59 <shapr> actually, pattern matching is case also
06:22:40 <Lunar^> Haskell is not sugar free ;)
06:22:53 <crazney> agh
06:22:55 <crazney> too many features
06:23:00 <crazney> well
06:23:04 <earthy> crazney: yeah, you're right. :)
06:23:15 <earthy> but most of the features don't bite you
06:23:15 <crazney> i think i'll go to bed now, it seems safer than fiddling around with haskell for another few hours :)
06:23:19 <shapr> heh
06:23:25 <Lunar^> hehe
06:23:30 <crazney> yeah.. but its kinda got that 'you can do anything 1000 ways' feeling like perl
06:23:33 <shapr> what sort of patterns did you want to look for anyway?
06:23:55 <Lunar^> crazney: If you can grab Hudak's book, it's a great way to learn
06:24:04 <crazney> shapr: probably just rows of items that are the same..
06:24:06 <shapr> crazney: I think the feeling is different from Perl because Haskell is good at making domain specific stuff
06:24:16 <Igloo> Hmmm, yup, looks broken alright
06:24:16 <crazney> domain specific stuff?
06:24:18 <shapr> duplicate rows? or duplicate items?
06:24:31 <crazney> well.. say we pretend its a matrix..
06:24:43 <crazney> and you have a row of all 3's, i'd like to know that.
06:25:02 <shapr> Haskell lets you change the language, that's the primary way to do bigger things. You remold Haskell into the language you want to work with.
06:25:10 <crazney> and columns aswell..
06:25:18 <crazney> possibly diagnals, but i'm not sure yet.
06:25:23 <Lunar^> @type and
06:25:24 <lambdabot> and :: [Bool] -> Bool
06:25:31 <Igloo> Although with ghc6 I just get "Exception: unknown module"
06:26:18 <shapr> crazney: Hudak's book has some excellent examples of domain specific thingies, like Haskore, that gives you music combinators
06:26:31 <Lunar^> Igloo: you have to remove factModule from the list of modules as well
06:26:32 * crazney blinks
06:26:43 <crazney> shapr: i might see if my uni library has it.
06:26:48 <crazney> anyway.. i need sleep now.
06:26:54 <crazney> thanks for all your help everyone!
06:26:54 <shapr> ok, come back and see us
06:27:00 <crazney> much appreciate it :)
06:27:04 <Igloo> I commented it out in BotConfig.hs
06:27:05 <crazney> shapr: i will.
06:27:09 <shapr> :-)
06:27:54 <shapr> speaking of DSELs, I've been thinking about a generalized approach to 'structs' that takes network connections into account also
06:27:58 <crazney> i really do wanna be able to grasp haskell.. i'm doing it as a subject at uni.. and since i've been coding c for many many years, its really odd.. but i'm kinda enjoying it - though finding it dificult..
06:28:00 <Igloo> Oh, I missed a lowercase one in that file
06:28:10 <crazney> must people in the subject are just really cynical of it
06:28:12 <crazney> anyway
06:28:15 * crazney is away: zzzZZZzzz
06:29:07 <shapr> oh, arrows are algebraic datatypes for sequenced structures?
06:29:34 * shapr wonders if that's just a low-sleep hallucination
06:31:48 <Lunar^> row a y = let minX = fst . fst . bounds a ; maxX = snd . fst . bounds a in map (a !) [(x, y) | x <- [minX..maxX]]
06:31:55 <Lunar^> Maybe that'll do it
06:33:04 <Igloo> Oh, I think it's due to the new names Main things get
06:33:16 <shapr> ?
06:33:20 <shapr> Main.main ?
06:33:41 <Igloo> No, the object names
06:33:55 <Igloo> I think it's taking Main.o from genStaticModules
06:35:36 <Igloo> Right, quick hacky fix is to append "-rm Main.o Main.hi" to the Makefile rule for genStaticModules
06:35:52 <Igloo> Still gives "EvalModule/LMEngine.o: unknown symbol `__stginit_TextziParserCombinatorsziParsecziError_'" but otherwise looks to be working OK
06:43:37 <shapr> gutentag galority 
06:46:05 <shapr> hi anth
06:59:18 <shapr> y0 Isaac
06:59:19 <shapr> wassup?
07:02:57 <SyntaxPolice> hey shapr
07:03:06 <SyntaxPolice> no euro for you!
07:04:00 <shapr> yah, it sucks
07:04:43 <harsha123> shapr: did your country vote agains Euro ??
07:04:53 <shapr> yes
07:04:54 <Igloo> Why do you want it?
07:05:01 <shapr> well, not my country, but the country I live in.
07:05:10 <harsha123> shapr: Sweden ?
07:05:13 <shapr> yup
07:05:22 <shapr> imho, the euro is good for business.
07:05:38 <shapr> especially for people like me, all of my clients are in southern europe.
07:05:44 <harsha123> hehehe.. nevermind. you always have the universal $ ;)
07:06:06 <shapr> Sweden has kronor, but is part of the European Union.
07:07:04 <harsha123> did poland go all for Euro?
07:07:48 <shapr> I don't know.
07:07:52 <ibid> all new members get euro as part of the package
07:07:56 <SyntaxPolice> shapr: so why did they turn it down? is their economy more healthy than the rest of europe right now?
07:08:13 <shapr> no, the kronor is dropping against the euro
07:08:26 <ibid> SyntaxPolice: they feel they lose their independence if they lose the krona
07:08:29 <shapr> yup
07:08:30 <harsha123> kroner has always been healthy
07:08:45 <ibid> SyntaxPolice: iow, sheer irrationality :)
07:08:59 <shapr> many people in this area believe that switching to the euro will take jobs away from them.
07:09:11 <SyntaxPolice> when we were on a tour of stockholm, our tour guide said that there are a lot of sweeds who want the king to rule again
07:09:12 <ibid> probably would have happened here too if they had asked the people
07:10:01 <shapr> in my opinion, changing money from kronor to euro is one of the accidental difficulties of business, not one of the essential difficulties, and so is a negative factor.
07:10:11 * tic agrees
07:10:37 <tic> all the stores are going to change everything dealing with money to a new currency. Who'll pay that?  The store? No, we do.
07:10:41 * ibid has a coin from greece in his pocket and it's legal money here :)
07:10:54 <shapr> tic: no, I mean it the other way :-)
07:11:12 <shapr> I do business in all of europe, kronor gets in my way.
07:11:15 <ibid> tic: euro did not raise prices here
07:11:33 <shapr> do you think it costs more to print euro than it costs to print kronor?
07:11:36 <ibid> (though somebody think so)
07:11:48 <tic> shapr, no, but to change all computer systems
07:11:52 <SyntaxPolice> er. you know that little space invadors program that was posted to the yampa list
07:11:56 <shapr> SyntaxPolice: yah?
07:12:05 <SyntaxPolice> and then there was a paper about it with some little examples
07:12:23 <shapr> tic: it would save me lots of time and money, I would be willing to pay extra taxes one year.
07:12:27 <SyntaxPolice> well, they'r enot the same program actually. the real space invadors program is several thousand lines long
07:12:31 <shapr> heh
07:12:35 <shapr> SyntaxPolice: funny
07:13:02 <tic> shapr, time and money, how?
07:13:08 <shapr> at the moment, all of my income comes from germany, greece, and belgium.
07:13:16 <tic> aha
07:13:31 <tic> remote work somehow?
07:13:43 <shapr> when I lived in .fi, sending euro to another euro using country was less expensive, and less trouble
07:14:23 <shapr> yes, I make websites for EU Projects
07:15:02 <shapr> In my opinion, sticking with the krona is an isolationist outlook.
07:15:30 <shapr> of course, I'm not a swedish citizen, and I don't get to vote, so my opinion isn't so important :-)
07:15:41 <shapr> but I do pay taxes.
07:15:46 * SyntaxPolice votes for shapr
07:15:46 <harsha123> shapr: where are you from ? US ?
07:15:51 <shapr> harsha123: yes, Alabama.
07:15:56 * shapr can't vote
07:16:02 * harsha123 remembers now
07:16:10 <tic> shapr, how come you ended up in Sweden?
07:16:16 <harsha123> shapr: but how come sweden 
07:16:25 <shapr> there was this woman (fifty thousand words omitted) and now I live in Boden.
07:16:44 <harsha123> shapr:  hmmm :)
07:17:00 <tic> shapr, and Boden of all places, cold and isolated. :)
07:17:05 <shapr> warm summers
07:17:07 <shapr> nice people.
07:17:10 <shapr> massive taxes
07:17:14 <tic> yeah, people are nice, I guess.
07:17:26 <tic> shapr, taxes massive? 33%?
07:17:35 * harsha123 wonders if they can be better than shapr
07:17:36 <ibid> shapr: near-free health care etc :)
07:17:37 * adept wonders what is massive taxes
07:17:46 <tic> shapr, we have 32% where I live, that's normal for Sweden.
07:17:50 <shapr> ibid: true, free health care, free school.
07:17:58 * adept has 40%
07:18:11 <ibid> tic: isn't sweden's taxation progressive like in finland
07:18:13 <harsha123> do ya guys have tax slabs?
07:18:20 <ibid> what is a tax slab?
07:18:31 <tic> ibid, yeah, it is.  Up to 27500 kr/mo you pay ~33%
07:18:33 <ibid> (may even have it, the term is not familiar though)
07:18:59 <tic> bleh.  work time now, 16.30 - 22.00 in a warehouse.  Not really what I'd like to do the rest of my life. :)
07:19:26 <shapr> tic: we're self-employed, 33% kommunal tax, 25% self-employee costs. if you make more than 250,000kr you have to pay state tax as well.
07:19:30 <harsha123> shapr: whats the kroner, dollar equation ?
07:19:46 <tic> shapr, that's normal.
07:19:53 <shapr> not in the US :-)
07:20:08 <harsha123> shapr: since how long have you been in Sweden?
07:20:10 <tic> sure, but this is sweden.
07:20:37 <shapr> aka, massive taxes :-)
07:20:45 <Lunar^> unsafePerformIO $ getEnv "PWD" <-- do someone have a whip ? ;)
07:20:46 <tic> perhaps -- think about what you get for them.
07:21:18 <ibid> 33 % communal tax? that *is* massive
07:21:29 <Igloo> That should be fine as long as you never setEnv it
07:21:35 <shapr> yes, the taxes pay for good things, but in the US, you get the choice
07:21:38 <ibid> in finland, 20 % is large
07:21:52 <Igloo> Although calling the getDirectory function or whatever it's called would be better  :-)
07:22:01 <shapr> I can buy a range of health insurance plans in the US, depending on how much money I want to spend
07:22:13 <Lunar^> Igloo: Everytime I use unsafePerformIO I'm scratching myself
07:22:15 <shapr> anyways, I doubt this is a profitable discussion :-)
07:22:31 <Lunar^> shapr: I really like Sweden tax system
07:22:36 <shapr> Lunar^: really?
07:22:58 <Lunar^> Do you want to compare with the french one ?
07:22:58 <shapr> why?
07:23:05 <shapr> no, I'm scared to :-)
07:23:12 <shapr> I've heard about the french system already.
07:23:13 <Lunar^> It's damn more simple
07:24:01 <harsha123> adept: i still havent got my sound kicking 1 :(
07:24:59 <harsha123> adept: awake ?  
07:25:29 <adept> harsha123: yep
07:25:31 <shapr> tic: can you get a programming job?
07:26:03 <harsha123> adept: hmm sorry if you were sleepin.. 
07:26:12 <adept> harsha123: it's 17:22 here :)
07:26:20 <harsha123> adept: prolly.. may need ya help tomorrow..
07:26:24 <shapr> it's @643 here
07:26:28 <adept> harsha123: ok
07:26:41 <harsha123> adept: where are ya from?
07:27:23 <adept> harsha123: Kiev, UA
07:27:34 <harsha123> Ok..
07:27:47 <harsha123> Ukraine
07:28:05 <harsha123> 'cause its 2000hrs here
07:29:36 <shapr> reffie: interesting hostname
07:29:52 <harsha123> shapr, adept .. everyone.. bye.. 
07:30:04 * harsha123 has to go home..  :)
07:30:08 <adept> harsha123: wait :)
07:30:18 <harsha123> adept: ok.. am here..
07:30:28 <shapr> cya
07:30:35 * shapr has to finish work
07:31:41 <harsha123> shapr: happy hacking..
07:31:53 <shapr> as soon as I port it to Haskell, sure :-)
07:32:00 <harsha123> :)
07:56:55 <reffie> shapr thanks :)
08:09:15 * Lunar^ wants polymorhic records !
08:42:15 <cm> re
08:42:15 <cm> god my cs teacher sucks.
08:42:15 * cm cries
08:42:15 <yazirian> those who can, do; those who can't, teach? ;)
08:43:09 <cm> i showed him sieve of erathostenes in haskell, he went like "yeah we gonna do that later in delphi, too, and it will be as short as in haskell"
08:43:40 <yazirian> heh, I love that
08:43:52 <yazirian> "Do it in X language." "Why?" "So I can grade it without learning anything."
08:44:47 <yazirian> let me tell you about my school's functional programming course. this will make you laugh. a lot.
08:45:24 <cm> :)
08:45:37 <yazirian> first of all, it doesn't exist. The only functional you get anywhere, is in the Programming Languages class. Which... their idea of 'Programming Languages' is: every other class is in either C or Java, so we'll show them some other languages for a couple weeks apiece.
08:45:55 <yazirian> so in my entire curriculum, I got 6 weeks of functional, specifically lisp
08:46:30 <ibid> we used to be that way
08:46:39 <yazirian> the project was: convert 'postfix lisp', i.e. (2 (7 4 *) +), into normal lisp that will run
08:46:44 * ibid is trying to change that by teaching our very first fp course
08:46:47 <yazirian> if you successfully could do this, you pass
08:46:56 <yazirian> the end
08:47:08 <cm> lol :)
08:47:22 <cm> that must be a lie :p
08:47:28 <yazirian> it's not, I promise
08:47:35 <ibid> that programming languages class sounds like a simple comparative languages, which is a useful thing to have
08:47:46 <yazirian> the final project, you chose from doing in lisp, or prolog (the other 'not Java or C' language)
08:47:53 <ibid> :)
08:48:27 <yazirian> I chose lisp, and he gave me, "now convert the other direction"
08:48:29 <ibid> (it used to be that here the only place where you got odd languages was the ai course, which was mainly about programming lisp and prolog:)
08:48:32 <yazirian> I got an A :)
08:48:43 <ibid> which school?
08:48:51 <yazirian> http://www.nmu.edu/
08:49:14 <ibid> you know what i did?
08:49:33 <ibid> i complained, so they  hired me and now i teach fp :) (well, not so simple but :)
08:50:01 <yazirian> at least now there will be some exposure
08:50:29 <yazirian> even in languages like Java and C, it's better to know how this stuff works; recursion, at least, still works in these languages :)
08:50:39 <yazirian> but, to lunch with me, back in a bit 
08:50:43 <ibid> not very well, though
08:51:23 <Darius> My advice (for C++) is only use recursion if you'd need an explicit stack otherwise.
08:58:20 <Igloo> yazirian: If you mean what I think you do (re "other direction") then that must have been very easy...
09:01:43 <Lunar^> Haskell rules !
09:01:52 <ibid> debian/rules :)
09:02:16 <Lunar^> I had freeToken :: (Token a, MonadPlus m) => Pool a -> a -> m (Pool a)
09:03:02 <Lunar^> to write freeTokens :: (Token a, MonadPlus m) => Pool a -> [a] -> m (Pool a)
09:03:26 <Lunar^> you just have to do freeTokens = foldM freeToken :)
09:16:05 <Lunar^> @prelude mplus
09:16:07 <lambdabot> *** "mplus" prelude "Haskell Standard Prelude Dictionary": text follows
09:16:07 <lambdabot> mplus
09:16:07 <lambdabot>   class Monad m => MonadPlus m where
09:16:07 <lambdabot>     mplus ::  m a -> m a -> m a
09:16:08 <lambdabot>   instance MonadPlus Maybe where
09:16:10 <lambdabot>     Nothing `mplus` ys = ys
09:16:12 <lambdabot>     xs      `mplus` ys = xs
09:16:14 <lambdabot>   instance MonadPlus [ ] where
09:16:16 <lambdabot> [3 @more lines]
09:19:45 <__Ace__> Im just wondering about the function "maybe".. I dont get the point of it... all I got so far is that it seems to be for "grabbing" errors..
09:20:22 <__Ace__> Or "deal with illigal values"
09:20:26 <__Ace__> is that all?
09:20:45 <ibid> @prelude maybe
09:20:46 <lambdabot> *** "maybe" prelude "Haskell Standard Prelude Dictionary": text follows
09:20:46 <lambdabot> Maybe
09:20:46 <lambdabot>   data Maybe a = Nothing | Just a
09:20:46 <lambdabot>   	       deriving (Eq, Ord, Read, Show)
09:20:48 <Darius> maybe can be used any time you want to analyze a Maybe value
09:20:49 <lambdabot> maybe
09:20:51 <lambdabot>   maybe ::  b -> (a -> b) -> Maybe a -> b
09:20:52 <Smerdyakov> Do you know the strchr function in C?
09:20:53 <lambdabot>   maybe n f Nothing  = n
09:20:55 <lambdabot> [3 @more lines]
09:21:13 <__Ace__> um
09:21:41 <ibid> that's an case-insensitive search? argh
09:21:43 <Smerdyakov> __Ace__, you should probably ignore what the others said.
09:21:44 <__Ace__> the example: maybe 0 (+1) (Just 1) = 2 dont give me much of a "aha" experience
09:21:50 <Smerdyakov> __Ace__, can you answer my question, though?
09:22:10 <__Ace__> yea
09:22:13 <__Ace__> think so
09:22:26 <__Ace__> take a character from a string?
09:22:33 <Smerdyakov> __Ace__, no.
09:22:47 <Smerdyakov> __Ace__, what programming language do you know the best?
09:22:55 <cm> strchr() searches for a char in a string, returns a pointer to the first occurance if found, returns 0 if not found.
09:23:01 <__Ace__> php, java.. :)
09:23:12 <__Ace__> aha
09:23:13 <cm> that would be comparable to Just <position> versus Nothing
09:23:30 <Smerdyakov> __Ace__, OK, so you know Java String.indexOf?
09:23:31 <__Ace__> hmm
09:23:37 <__Ace__> yea
09:23:54 <Smerdyakov> __Ace__, it returns an int, BUT, one int (-1) is reserved as having a special meaning, which is hackish.
09:24:04 <Smerdyakov> __Ace__, in Haskell, it returns a Just Int instead.
09:24:15 <Smerdyakov> __Ace__, the Nothing case corresponds to the -1.
09:24:23 <Smerdyakov> __Ace__, everything else is inside a Just.
09:24:41 <__Ace__> um
09:24:54 <ibid> Smerdyakov: he asked about maybe, not Maybe :)
09:25:22 <Smerdyakov> __Ace__, is your problem just with maybe, or do/did you also wonder about Maybe?
09:25:31 <__Ace__> maybe 0 (+1) (Just 1) = 2   whats the point of 0 here?
09:25:40 <__Ace__> maybe.. there is a Maybe too? 
09:25:46 <Smerdyakov> ibid, see :D
09:26:09 <__Ace__> oh
09:26:10 <Smerdyakov> __Ace__, do you understand what Maybe is now? The maybe function is only used on Maybe's, so you need to understand this first.
09:26:27 <__Ace__> gah, its Maybe Im supposed to learn..
09:26:30 <__Ace__> mixed it with maybe
09:27:06 <ibid> Smerdyakov: he said "function maybe", i usually trust people to say what they mean :)
09:27:08 <__Ace__> no wonder Im confused..
09:27:15 <__Ace__> yea, well
09:27:24 <__Ace__> didnt think "Maybe" and "maybe" was different functions
09:27:30 <Smerdyakov> Maybe isn't a function.
09:27:35 <Smerdyakov> It's a type constructor.
09:27:41 <__Ace__> aha
09:27:51 <Smerdyakov> And if you don't know what that means, don't ask us; ask your teacher.
09:27:56 <__Ace__> ok, I have to rethink.. can we do this again? :)
09:28:59 <Smerdyakov> If this is hard for you to grasp conceptually, then you should go over the information you already have, and then ask an instructor for the class if that fails.
09:30:28 <__Ace__> int indexOf(String str)  - Returns the index within this string of the first occurrence of the specified substring.
09:30:36 <__Ace__> so far is ok
09:31:05 <__Ace__> same in haskell then?
09:31:41 <__Ace__> Just x when found, Nothing else?
09:32:07 <__Ace__> am I right?
09:32:12 <Smerdyakov> OK
09:32:22 <Smerdyakov> I don't know what you mean by "same in haskell," though.
09:32:27 <Smerdyakov> That's not valid Haskell code.
09:33:10 <__Ace__> hmm
09:33:53 <Smerdyakov> And if you thought it was Haskell code, you've put no time into thinking about this yourself, so don't expect any help here...
09:34:40 <__Ace__> I thought what beeing Haskell code?
09:34:46 <Smerdyakov> int indexOf(String str)
09:34:48 <__Ace__> that I pasted is from javadoc
09:34:52 <Smerdyakov> I know.
09:34:54 <__Ace__> I know that
09:35:02 <Smerdyakov> And then you proceeded tio say "same in haskell then?"
09:35:09 <__Ace__> just starting over from what you compared with
09:35:21 <__Ace__> and there are several indexOf methods
09:35:29 <Smerdyakov> Well, it's not the same in Haskell. If you didn't mean that, then you shouldn't have said it.
09:35:48 <__Ace__> why mention it then for the "Maybe" ?
09:36:04 <Smerdyakov> Because the idea behind it is the same, not the _code_.
09:36:23 <__Ace__> lol, I KNOW its not the same code
09:36:33 <Smerdyakov> OK! You should be more specific when you say things.
09:36:34 <__Ace__> ok, idea same
09:36:40 <__Ace__> sorry 
09:37:20 <Smerdyakov> You've been asked to learn about Maybe in a class but not given anything to read about it, or told how to go about learning about it?
09:38:07 <__Ace__> "The next choice would be the other standard libraries. In this assignment we will for example make heavy use of the prelude datatype Maybe including the associated function maybe. Make sure you understand their purpose and what they do.
09:38:09 <__Ace__> "
09:38:20 <__Ace__> thats about it
09:38:45 <Smerdyakov> Well, if it's stated like that in the assignment, you should probably have been taught how to learn about it on your own...
09:39:13 <__Ace__> standard libraries is a link to http://haskell.org/onlinereport/ where Im trying to understand it
09:40:01 <__Ace__> you know, its not easy to go from "java, C, php, Basic" thinking to functionprograming
09:40:10 <Smerdyakov> OK. Since I've already given you an analogy from Java, do you understand the idea of it now?
09:40:15 <__Ace__> yea
09:40:20 <Smerdyakov> Well, it's easy for some people. ;)
09:40:27 <__Ace__> ;)
09:40:43 <Smerdyakov> So what part don't you understand, then?
09:42:10 <__Ace__> hmm
09:42:15 <dennisb> the datatype Maybe is very simple, you usually use it as a return value from a function. Instead of always returning a value, you either return the value "Nothing" or the value "Just x" where x is the actuall value you want to return
09:42:54 <__Ace__> hmm, ok
09:43:16 <golya> Which tutorial would you recommend for a guy knowing about FP and SML?
09:43:17 <__Ace__> Im looking at: mmap :: (a -> b) -> Maybe a -> Maybe b
09:43:21 <Smerdyakov> __Ace__, are you doing this without running any actual Haskell code?
09:43:38 <__Ace__> uh, no, got GHCi ready for testings..
09:43:47 <Smerdyakov> golya, I think "A Gentle Introduction to Haskell"
09:44:04 <dennisb> for exampel instead of always returning an Int you return a Maybe Int which lets your function return a value or nothing at all
09:44:19 <Smerdyakov> __Ace__, OK. Do you understand literally what mmap does, even if you don't know why you'd want to use it?
09:45:18 <__Ace__> Im afraid not that either.. was hoping to learn Maybe, and then maybe (funny :) ) learn mmap
09:45:39 <Smerdyakov> :prelude mmap
09:45:43 <Smerdyakov> @prelude mmap
09:45:44 <lambdabot> No match for "mmap".
09:45:52 <__Ace__> since mmap is based on Maybe
09:46:06 <__Ace__> mmap takes 2 arguments apparently
09:46:25 <Darius> mmap is the specialization of fmap to Maybe, it isn't a standard function (well at least not by that name).
09:46:34 <Smerdyakov> Yes. It takes a Maybe that might hold a value of type a, and it also takes a function from type a to type b.
09:46:39 <Smerdyakov> If the Maybe is Nothing, it returns Nothing.
09:46:54 <Smerdyakov> If the Maybe is Just x, then it returns Just (f x). (where f is the first parameter)
09:47:11 <__Ace__> ok
09:47:27 <__Ace__> also, there is:
09:47:29 <__Ace__> mmap f  Nothing  = Nothing
09:47:29 <__Ace__> mmap f (Just x)  = Just (f x)
09:47:40 <Smerdyakov> Yup.
09:47:47 <dennisb> which is exactly what Smerdyakov wrote in english
09:47:59 <__Ace__> ah, yea
09:47:59 <__Ace__> true
09:48:50 <__Ace__> well, I think I get how they work, but would be nice to have some example.. Just to realize in what context this is usefull
09:49:00 <dennisb> look at the lookup function
09:51:01 <dennisb> it's used to lookup a value in a list of tuples. Say that you have the list xs = [ (1,"dennis"), (2,"ace") ], now you do  lookup 1 xs  and it returns "dennis", but what should it return if you do  lookup 3 xs  ?
09:51:16 <dennisb> hmm, or was it mmap you asked about and not the Maybe type?
09:51:55 <__Ace__> well, both :)
09:52:21 <dennisb> well, what should lookup return if you try to look up the tuple with value 3 (that does not exist)
09:52:33 <__Ace__> hmm
09:52:39 <__Ace__> [] ?
09:52:43 <dennisb> it can not just invent a string
09:53:03 <dennisb> well, that is the string "", but that was not in the list. Had there been a (3,"") then yes
09:53:17 <__Ace__> aha
09:53:23 <dennisb> the solution is to change so that lookup does not return a string, instead it returns a Maybe String
09:53:57 <dennisb> then it can return the value Nothing when you call lookup with 3, but if you call it with for example 1 it returns Just "dennis"
09:54:08 <__Ace__> ahh
09:54:19 <__Ace__> else it gives some kind of error?`
09:54:25 <dennisb> there is no error case
09:54:54 <dennisb> the function always returns something
09:55:10 <__Ace__> but if we dont use Maybe... what is returned then?
09:55:28 <dennisb> that is a good question
09:55:37 <__Ace__> :D
09:55:44 <dennisb> there is nothing good to return. The solution is to use Maybe for examples like this
09:55:46 <Darius> *Error: tail of empty list*
09:56:02 <__Ace__> aha, sounds logical
09:56:03 <dennisb> well, yes. Terminating the whole program is an alternative
09:56:05 <__Ace__> :)
09:56:18 <__Ace__> ok, and if we go on with the "maybe" ?
09:56:27 <Darius> or more likely, 'Non-exhaustive pattern match in lookup'
09:56:40 <dennisb> maybe is just a stupid function, just look at the definition
09:56:51 <__Ace__> maybe 0 (+1) (Just 1) = 2 apparently
09:56:57 <Darius> maybe is damned convenient
09:57:03 <__Ace__> dont get what 0 is doing there
09:57:04 <dennisb> Darius: which is also just terminating the program
09:57:26 <dennisb> __Ace__: that is a usage of the function
09:57:39 <Darius> __Ace__: What is maybe 0 (+1) Nothing?
09:57:40 <dennisb> the definition of the maybe function is something else
09:58:51 <__Ace__> 0 apparently
09:58:56 <__Ace__> :)
10:00:21 <__Ace__> aha, so if its Nothing that first one is returned
10:00:23 <Darius> Now, and maybe "hello" ("hi "++) (lookup [(1,"ace"),(2,"dennisb")] x) for various values of x
10:02:43 <__Ace__> eh
10:02:47 <__Ace__> seems complicates
10:02:53 <__Ace__> *complicated
10:03:56 <keverets> don't you mean: maybe "hello" ("hi "++) (lookup x [(1,"ace"),(2,"dennisb")])
10:04:32 <Darius> yes, I always mix up lookup.
10:05:41 <__Ace__> em
10:05:50 <__Ace__> Variable not in scoop 'x'
10:05:56 <keverets> replace the x
10:06:06 <keverets> with a 1, a 2, or some other number
10:06:24 <keverets> or make a function: testingMaybe x = (the above)
10:06:36 <__Ace__> ok, I see a pattern here..
10:06:42 <__Ace__> hi ace for x = 1
10:06:50 <__Ace__> hi dennisb for x = 2
10:06:59 <__Ace__> just hello for x > 2
10:07:46 <keverets> well, for anything other than 1 or 2 ... (-42) would give you the same.
10:08:28 <__Ace__> ah, yea
10:08:51 <keverets> is there a : command to show the Prelude definition in hugs, ghci, or similar?  A :t only gives you so much info ...
10:09:10 <keverets> if not, I guess there's always lambdabot 
10:09:18 <Darius> :info gives a bit more information, or you could just ask lambdabot
11:52:20 <__Ace__> damnit
11:52:37 <__Ace__> Im having trouble figureing out some "replace" function..
11:53:00 <__Ace__> replace chr text = ..?
11:53:12 <__Ace__> where all characters in text are replaced with chr
11:53:32 <__Ace__> anyone wanna give me some hints?
11:57:31 <meep_> what problem are you having, __Ace__?
11:57:45 <__Ace__> well
11:57:55 <__Ace__> that I said :)
11:58:10 <meep_> i think i missed most of it
11:58:20 <__Ace__> I dont wanna cheat so I splited the problem
11:58:24 <__Ace__> well
11:58:56 <__Ace__> how can I make a function like replace where I replace all characters in a string with the other argument?
11:58:58 <__Ace__> like:
11:59:03 <__Ace__> replace chr text = ..?
11:59:25 <__Ace__> uh
11:59:27 <__Ace__> hmm
11:59:32 <meep_> so you want to create a new string where all the characters are the same?
11:59:52 <__Ace__> I was hoping of creating something not exactly like the assignemtn.
12:00:02 <__Ace__> oh well
12:00:07 <__Ace__> substitute wildcard l1 l2
12:00:37 <__Ace__> here I want to replace all "wildcards" in "l1" with "l2"
12:01:03 <meep_> so you start off with a string which contains wildcards?
12:01:22 <__Ace__> the wildcard is a character (Char)
12:01:27 <__Ace__> the others are lists
12:01:48 <__Ace__> or Strings (= [Char) )
12:01:57 <__Ace__> or Strings (= [Char] )
12:02:23 <meep_> ok, what do you want to do with this string?
12:02:23 <__Ace__> so
12:02:26 <__Ace__> for example
12:02:32 <__Ace__> substitute 'x' "3*cos(x) + 4 - x" "5.37" = "3*cos(5.37) + 4 - 5.37"
12:03:22 <meep_> oh i think i get what you mean
12:03:23 <__Ace__> x is replaced with 5.37
12:03:29 <__Ace__> I bet its easy
12:03:40 <__Ace__> but having trouble thinking in "functionprograming"
12:05:03 <__Ace__> ideas? suggestions? hints?
12:05:55 <meep_> so the problem is, the wildcard is a single chracter, bbut you want to replace it with a string
12:05:55 <Lunar^> meep_: I don't think it's a real problem
12:06:11 <Lunar^> Ace : do you know the pattern to travel a list ?
12:06:24 <__Ace__> maybe
12:06:30 <__Ace__> got some Utilities.hs here
12:06:48 <__Ace__> but go ahead and explain
12:07:07 <Lunar^> If f is a function of type [a] -> ...
12:07:12 <Lunar^> you can write
12:07:27 <Lunar^> f [] = ... <- things to return when list is empty
12:07:53 <Lunar^> f (x:xs) = ... f xs ... <- things to do when list isn't empty
12:08:11 <__Ace__> aha
12:08:40 <Lunar^> You recursively call the function until it its the empty list
12:08:54 <Lunar^> because [1,2,3] is 1:2:3:[] really
12:09:09 <__Ace__> in what way does that help me now?
12:09:26 <__Ace__> to grab character by character in the list?
12:09:31 <Lunar^> yes
12:09:33 <__Ace__> head:tail thingy?
12:09:35 <__Ace__> hmm
12:09:44 <meep_> you need to iterate through the list to check for the wildcard character
12:09:55 <__Ace__> yea
12:09:55 <Lunar^> "xs" stands for the plural of x
12:10:11 <__Ace__> but can be called whatever?
12:10:28 <meep_> yes
12:10:28 <Lunar^> Yes, it's just the convention
12:10:32 <__Ace__> :)
12:10:35 <__Ace__> just checling
12:10:35 <Lunar^> @prelude tail
12:10:37 <lambdabot> *** "tail" prelude "Haskell Standard Prelude Dictionary": text follows
12:10:37 <lambdabot> tail
12:10:37 <lambdabot>   tail ::  [a] -> [a]
12:10:37 <lambdabot>   tail (_:xs)       = xs
12:10:37 <__Ace__> checking
12:10:59 <__Ace__> hmm
12:11:22 <Lunar^> Do you know what guards are ?
12:11:29 <__Ace__> but I cant compare a 'x' to a "x"
12:11:36 <__Ace__> hmm
12:11:41 <__Ace__> these? | ?
12:11:46 <Lunar^> yes
12:12:26 <__Ace__> yea, was thinking about those too, but not sure still what to do..
12:12:37 <__Ace__> hmm
12:14:39 <__Ace__> substitute wildcard l1 l2 = 
12:14:40 <__Ace__> 	where
12:14:45 <__Ace__> something..
12:14:48 <__Ace__> damnit
12:14:54 <meep_> maybe this would just be confusing, but you could write your function as a fold using foldr, if you've looked at folds
12:15:10 <meep_> but i guess you probably haven't
12:15:24 <Lunar^> What's l2 ?
12:15:49 <__Ace__> substitute 'x' "3*cos(x) + 4 - x" "5.37" = "3*cos(5.37) + 4 - 5.37"
12:15:59 <__Ace__> "5.37" in that case :)
12:16:21 <Lunar^> I would better call this substitute needle haystack replacement
12:16:26 <Lunar^> anyway
12:17:19 <Lunar^> You need to travel through haystack, each time you encounter needle, you append replacement instead of needle
12:17:48 <__Ace__> yea, I know that
12:18:14 <Lunar^> Ok, so you need to deconstruct haystack, so start with something like
12:18:34 <Lunar^> substitute _ [] _ = []
12:18:55 <Lunar^> substitute needle (x:xs) replacement ...
12:19:20 <Lunar^> The first line is because, if the list is empty, you know that there's no needle
12:19:36 <Lunar^> So you can't replace anything, the result is just the empty list
12:21:24 <_Ace_> crap
12:21:39 <_Ace_> got disconnected
12:23:46 <_Ace_> is {- the only way of commenting?
12:23:58 <meep_> no, you can use --
12:24:04 <meep_> it goes up to the end of the line
12:28:38 <Xcalibor> hiyas
12:28:51 <meep_> hi
12:56:26 * Cale is away: be back in a bit
13:11:28 * Cale is back (gone 00:15:02)
13:19:02 <Tomasso> mhm
13:19:09 <Tomasso> seven x = 7
13:19:14 <Tomasso> (/0) (seven seven)
13:19:21 <Tomasso> whar is /0 ?
13:19:35 <Tomasso> and how can seven take seven as parameter?
13:19:55 <Lunar^> Tomasso : seven x = 7 <=> seven _ = 7 
13:20:11 <Tomasso> seven anything = 7
13:20:18 <Lunar^> Tomasso: You could even use (seven (fail ""))
13:20:23 <Riastradh> (/0) is equivalent to (\x -> x / 0)
13:20:23 <Tomasso> its type is polymotphic
13:20:39 <Tomasso> but can i do seven nothin = 7 ?
13:21:10 <Tomasso> Riastradh: ??!!! its equivalent to all this?
13:21:23 <Lunar^> sure
13:24:21 <Cale> yeah, like (*3) is the function that multiplies its argument by three.
13:25:23 <Tomasso> mhmh Riastradh: you said that (/0) is (\x -> x / 0), but then in the expression  (/0) (seven seven)?
13:25:34 <tic> moo?
13:25:49 <Tomasso> it is:  (\x -> x / 0) (seven seven)
13:25:54 <Riastradh> Yes.
13:26:05 <Tomasso> dont see what it does
13:26:07 <Riastradh> And then that's 'seven seven / 0', which is '7 / 0', which is an error.
13:26:15 <Lunar^> Riastradh: it's not an error
13:26:24 <Lunar^> @prelude (/)
13:26:25 <Tomasso> hhmm
13:26:25 <lambdabot> *** "(/)" prelude "Haskell Standard Prelude Dictionary": text follows
13:26:25 <lambdabot> (/)
13:26:25 <lambdabot>   instance (RealFloat a) => Fractional (Complex a) where
13:26:25 <lambdabot>     (x:+y) / (x':+y')  = (x*x''+y*y'') / d :+ (y*x''-x*y'') / d
13:26:26 <lambdabot>   infixl 7 /
13:26:28 <Tomasso> bottom?
13:26:28 <lambdabot>   class (Num a) => Fractional a where
13:26:30 <lambdabot>     (/) ::  a -> a -> a
13:26:32 <lambdabot>     x / y         = x * recip y
13:26:34 <lambdabot> [8 @more lines]
13:27:01 <Lunar^> depends on what class of number you work, but you can get Infinity
13:27:12 <Tomasso> hhhm
13:28:45 <Lunar^> @more
13:28:45 <lambdabot>   instance Fractional Float where
13:28:45 <lambdabot>     (/)          = primDivFloat
13:28:45 <lambdabot>   instance Fractional Double where
13:28:45 <lambdabot>     (/)          = primDivDouble
13:28:45 <lambdabot>   instance Integral a => Fractional (Ratio a) where
13:28:46 <lambdabot>     (x:%y) / (x':%y')   = (x*y') % (y*x')
13:28:50 <_Ace_> there is no thing as "if .." in haskell right?
13:29:04 <Tomasso> if then else
13:29:12 <_Ace_> how about looping?
13:29:18 <Tomasso> recursion
13:29:19 <Lunar^> recursion !
13:29:21 <Tomasso> no looping
13:29:28 <_Ace_> ok
13:29:29 <_Ace_> :)
13:29:49 <Cale> well, you can construct loops monadically
13:29:51 <Tomasso> recursion makes us verify when a program work as expected by using induction
13:29:57 <Tomasso> am i right?
13:30:09 <Tomasso> if we used loops it would be imposible?
13:30:16 <Cale> no, it's not impossible
13:30:31 <Tomasso> if loops are written in recursive...
13:30:52 <Cale> but it's maybe more tricky to check that a loop does what it's supposed to
13:31:12 <_Ace_> Im still trying to solve this "replace" problem
13:31:19 <Tomasso> yeah.. we could write a loop2recursion translator
13:31:19 <Lunar^> isInfinite $ 7/0
13:31:23 <Lunar^> => True
13:31:39 <_Ace_> substitute _ [] _ = []
13:31:39 <_Ace_> substitute needle (x:xs) replacement
13:31:42 <Lunar^> defined in RealFloat classe
13:31:43 <_Ace_> then what? :)
13:32:02 <Lunar^> then use your mind :)
13:32:09 <_Ace_> Im trying
13:32:13 <Lunar^> You got to make substitute appear in the second equation
13:32:53 <_Ace_> yea, recursive somehow
13:32:59 <_Ace_> taking the tail, right?
13:33:09 <_Ace_> substitute needle (x:xs) replacement
13:33:10 <_Ace_> 	| x == needle = replacement
13:33:10 <_Ace_> 	| otherwise = x
13:33:15 <_Ace_> this aint right but still :)
13:33:28 <Cale> well, okay
13:33:34 <Lunar^> your on the good way, now make substitute appear
13:33:43 <Cale> you just haven't decided what to do with xs
13:33:50 <_Ace_> hmm
13:33:52 <_Ace_> kewl
13:33:56 <_Ace_> finally some progress
13:33:58 <_Ace_> :)
13:34:13 <_Ace_> I get errors on that though
13:35:49 <_Ace_> substitute needle (x:xs) replacement
13:35:49 <_Ace_> 	| x == needle = replacement
13:35:52 <_Ace_> 	| substitute needle xs replacement
13:35:53 <_Ace_> 	| otherwise = x
13:35:56 <_Ace_> whops
13:36:50 <Lunar^> after a guard, you need a Bool
13:37:07 <_Ace_> say what?
13:37:15 <_Ace_> ah
13:37:16 <_Ace_> yea
13:37:20 <_Ace_> hmm
13:37:41 <_Ace_> but I dont see how I can do this recursivly then
13:38:07 <_Ace_> 	| x == needle = replacement
13:38:07 <_Ace_> 	| otherwise = substitute needle xs replacement
13:38:10 <_Ace_> :)
13:38:42 <_Ace_> hmm
13:38:43 <_Ace_> almost :)
13:39:02 <Cale> okay
13:39:12 <_Ace_> or, do I type like: | otherwise = substitute (needle xs replacement) ?
13:39:12 <Cale> think of it this way:
13:39:26 <Lunar^> remember that substitute is constructing a list
13:40:42 <Lunar^> Ace : your last line means : substitute ((needle xs) replacement) <-- this is not what you want
13:41:05 <_Ace_> ok, so the first one was right?
13:41:09 <Lunar^> yes
13:41:14 <_Ace_> ok
13:41:25 <_Ace_> but there is something missing..
13:41:29 <Lunar^> yes
13:41:37 <_Ace_> hmm
13:42:00 <Lunar^> substitute :: Char -> String -> String -> String
13:42:16 <Lunar^> Remember that your building a String (= [Char])
13:42:37 <_Ace_> 	| x == needle = replacement
13:42:37 <_Ace_> 	| x /= needle = x
13:42:37 <_Ace_> 	| otherwise = substitute needle xs replacement
13:43:00 <Lunar^> @prelude otherwise
13:43:01 <lambdabot> *** "otherwise" prelude "Haskell Standard Prelude Dictionary": text follows
13:43:01 <lambdabot> otherwise
13:43:01 <lambdabot>   otherwise ::  Bool
13:43:01 <lambdabot>   otherwise    = True
13:43:13 <Lunar^> otherwise is just a synonym for True
13:43:13 <Cale> (substitute needle xs replacement) is already done with. You just need to figure out what to tack on to the front of it.
13:43:21 <_Ace_> oh
13:43:32 <_Ace_> hmm
13:43:42 <_Ace_> x /= needle = x didnt work
13:43:53 <Cale> yeah, because it's not a list
13:43:53 <_Ace_> but something like that must be right?
13:44:31 <Lunar^> if x == needle, then x cannot be needle
13:44:55 <_Ace_> huh?
13:44:56 <Lunar^> if x /= needle, then x can only be needle
13:45:04 <_Ace_> hmm
13:45:15 <Cale> suppose that I hand you (substitute needle xs replacement), and tell you that you need to compute (substitute needle (x:xs) replacement)
13:45:22 <Cale> what do you do?
13:45:41 <Cale> I've already finished the rest of the list for you
13:45:42 <_Ace_> uh
13:46:18 <_Ace_> hmm
13:46:34 <_Ace_> I dont get what you mean
13:46:36 <Cale> okay
13:46:49 <_Ace_> I've already seperated the list
13:46:54 <_Ace_> to (x:xs)
13:46:57 <Cale> okay, look at it this way...
13:47:09 <_Ace_> ok..
13:47:34 <Cale> you need to compute substitute 2 [2,2,3,2,5] 7
13:48:02 <_Ace_> yea
13:48:19 <Cale> now I give you the solution to substitute 2 [2,3,2,5] 7. It's [7,3,7,5]
13:49:27 <_Ace_> uh, but x == needle = replacement takes care of the case where it finds the needle..
13:49:59 <_Ace_> otherwise = substitute needle xs replacement     takes the tail..
13:50:29 <Cale> so (x:xs) = 2:[2,3,2,5]
13:50:35 <_Ace_> now, all that is left is when x isnt the needle.. meaning I should just take next..
13:50:52 <_Ace_> hence the x /= needle = x
13:51:04 <_Ace_> or Im WAAAY off? :)
13:51:19 <Cale> yeah, you want to return a completed list from the function
13:51:40 <Cale> so if I handed you this mostly completed list...
13:51:49 <Cale> what would you do to finish it?
13:52:18 <_Ace_> uh, return xs?
13:52:22 <_Ace_> no idea
13:52:22 <_Ace_> :)
13:52:45 * _Ace_ is thinking hard
13:52:51 <Cale> okay, so I've handed you (substitute needle xs replacement) = [7,3,7,5]
13:53:02 <_Ace_> yes
13:53:25 <Cale> you're working on computing (substitute needle (x:xs) replacement)
13:53:34 <Cale> what should that be?
13:54:07 <_Ace_> um, [7],[3,7,5]
13:54:10 <_Ace_> err
13:54:20 <_Ace_> um, 7:[3,7,5]
13:54:52 <_Ace_> hmm
13:55:09 <_Ace_> w8 a minute
13:55:21 <Cale> remember that (x:xs) is [2,2,3,2,5]
13:55:23 <_Ace_> you mean I got the whole list and you only got the tail?
13:55:26 <Cale> yeah
13:55:31 <Cale> I took care of the tail
13:55:54 <_Ace_> well, then you probably want my head..'
13:55:59 <_Ace_> maybe
13:56:18 <_Ace_> or?
13:56:26 <Cale> I want the whole finished list
13:56:37 <_Ace_> hmm
13:57:10 <_Ace_> Im abit lost again
13:57:54 <Cale> so, you know that you want to switch that 2 at the start for a 7, right?
13:58:41 <_Ace_> yes, thats my: 	| x == needle = replacement
13:59:04 <Cale> sure, but now "replacement" isn't the whole list now is it?
13:59:10 <Cale> it's just the head
13:59:19 <_Ace_> oh
13:59:21 <_Ace_> hmm
13:59:22 <Cale> but you're lucky, because I gave you the tail.
13:59:35 <_Ace_> uh
14:00:32 <Cale> so you just tack that on using the : operator
14:00:52 <_Ace_> I do what?
14:01:04 <_Ace_> 	| x == needle = (replacement:xs)
14:01:07 <_Ace_> :p
14:01:13 <Cale> not quite, remember
14:01:36 <Cale> The tail is just (substitute needle xs replacement)
14:01:47 <_Ace_> yes
14:01:55 <Cale> that's all done for you
14:02:19 <Cale> so you just tack the head onto it.
14:02:39 <Lunar^> Cale : I'm not really found of the way you teach it, but it's interesting to see another approch
14:03:00 <_Ace_> hehe, hes doing good :D
14:03:07 <_Ace_> I think
14:03:37 <_Ace_> tack the head to what?
14:04:35 <_Ace_> | x == needle = x:replacement is quite interesting :)
14:04:48 <Lunar^> damn
14:04:57 <_Ace_> hmm
14:05:04 <Lunar^> x is what you want to replace !
14:05:13 <_Ace_> lol
14:05:13 <_Ace_> yea
14:05:18 <_Ace_> nead to clear my mind here
14:05:40 <_Ace_> ok.. hmm, I got.. (substitute needle xs replacement)
14:06:24 <_Ace_> jesus
14:06:27 <_Ace_> it doesnt klick here
14:07:39 <_Ace_> Cale
14:07:40 <_Ace_> ?
14:08:05 <Cale> hm?
14:08:21 <_Ace_> can we take another approach?
14:08:29 <_Ace_> or there is none?
14:08:32 <Riastradh> If you have 'tail' (i.e. substitute needle xs replacement), and x == needle, what list do you want to make?
14:09:26 <_Ace_> um, I want to split that tail so I only get 1 character
14:09:38 <_Ace_> to compare that with the needle..
14:09:57 <Lunar^> You did it before the guard (|)
14:10:06 <Lunar^> now you need to build another list
14:10:53 <_Ace_> aha..
14:10:55 <_Ace_> hmm
14:11:35 <_Ace_> | x == needle = replacement:xs
14:11:45 <_Ace_> just thinking out loud :)
14:12:22 <Lunar^> your coming to it
14:12:32 <_Ace_> um
14:12:42 <Lunar^> What you wrote will stops at the first needle, you need to do the whole list
14:13:38 <_Ace_> but I only got the tail..
14:13:43 <_Ace_> and x
14:13:52 <_Ace_> x:xs is the whole list
14:14:15 <Lunar^> sorry to mess up
14:14:22 <Lunar^> You need to "work" on the whole list
14:14:38 <_Ace_> aha
14:14:42 <Lunar^> travelling, folding the whole list
14:15:39 <_Ace_> | x == needle = replacement:xs cant be right
14:16:07 <Lunar^> It would replace only the first needle
14:16:23 <_Ace_> Im out of ideas
14:16:44 <_Ace_> still only got:
14:16:44 <_Ace_> substitute needle (x:xs) replacement
14:16:44 <_Ace_> 	| x == needle = replacement
14:16:45 <_Ace_> 	| otherwise = substitute needle xs replacement
14:17:28 <Lunar^> *sigh*
14:17:34 <_Ace_> yea, I know
14:17:48 <Lunar^> Should we do that in C ?
14:18:02 <_Ace_> uh
14:18:04 <_Ace_> why?
14:18:12 <_Ace_> there I just do some for loop
14:18:14 <_Ace_> and if
14:18:17 <_Ace_> statment
14:18:35 <Lunar^> loop in a functionnal programming language is recursion
14:18:45 <_Ace_> ok
14:18:46 <Riastradh> OK.  Let's just call 'substitute needle xs replacement' 'tail'.  If x == needle, what do we add to 'tail'? (remember, 'tail' is the xs with the substitution of replacement for needle; x:xs is the original list; if x == needle, we want to substitute 'replacement' for x)
14:20:58 <Xcalibor> ok, the same problem as in ocaml :-)    how do I find the reverse of a number? say reverse 134 -> 431
14:22:08 <Riastradh> x:xs is the whole list.  tail is all of the list modulo x, and with replacement substituted for needle.  tail is our entire list but missing one element: x.  If x == needle, we want to substitute replacement for x; otherwise, we want to leave x in there.  How do we add one element -- either replacement or x, depending on whether or not x == needle -- to tail?
14:22:42 <Lunar^> Xcalibor: You want it the nice way or the hacky way ?
14:23:02 <Lunar^> Xcalibor: (hacky way means use String ;))
14:25:32 <_Ace_> hmm
14:26:07 <Xcalibor> Lunar^: whichever you like the most :-)
14:26:33 <Xcalibor> I even accept things of the likes of reverse (string_of 123)  :-)
14:26:38 <Riastradh> _Ace_, just answer the question: how do you add an element to a list?
14:27:00 <Lunar^> Xcalibor: search something to do Integer -> String, and something to do String -> Integer
14:27:24 <Riastradh> Say I want to add 'foo' to the front of the list 'l'.
14:27:29 <Riastradh> How do I do this, _Ace_?
14:27:43 <_Ace_> foo:l
14:28:02 <Riastradh> If x == needle, we want to add replacement to the list 'tail'.
14:28:18 <Riastradh> Complete this line:
14:28:24 <Xcalibor> Lunar^: yup... that's the trick... in OCaml was rather elaborated... i was hoping working with strings in Haskell would make it easier...
14:28:26 <Riastradh>   | x == needle = 
14:29:01 <Lunar^> Xcalibor: Do you what type classes are ?
14:29:37 <_Ace_>  | x == needle = replacement:xs
14:30:02 <Riastradh> No, not 'xs'.
14:30:09 <Riastradh> We want to add replacement to the list _tail_.
14:31:01 <Xcalibor> Lunar^: i have a bare understanding of what type classes are...
14:31:05 <_Ace_> _tail_ ??
14:31:17 <_Ace_> xs is the tail?
14:31:47 <Riastradh> No, no, no.
14:31:47 <Riastradh> We have a list tail.
14:31:55 <Riastradh> It is the value of 'substitute needle xs replacement'.
14:32:23 <Lunar^> Xcalibor: type classes are different from OO classes, they're more like Java interfaces
14:32:34 <_Ace_> ok
14:32:43 <Lunar^> Xcalibor: It means that a type has some properties
14:32:45 <Xcalibor> Lunar^: they are a kind of formal interfaces that define the behavior of a type to be of that class...
14:33:02 <_Ace_> | x == needle = replacement:substitute needle xs replacement
14:33:04 <_Ace_> ?
14:33:17 <Xcalibor> Lunar^: yup... 
14:33:27 <Riastradh> OK, that works, I guess.
14:33:48 <Lunar^> Xcalibor: In the prelude, you've got a type class "Show", which defines a function "show" that works on all types that belongs to class "Show"
14:33:55 <Riastradh> Now, in the otherwise branch, we want to add x, not replacement, to 'substitute needle xs replacement'.
14:33:59 <Riastradh> Complete the line:
14:33:59 <Lunar^> Xcalibor: show :: Show a => a -> String
14:34:03 <Riastradh>   | otherwise = 
14:34:31 <_Ace_>  x == needle = replacement:substitute needle xs replacement     doesnt work though
14:34:40 <_Ace_> 	| otherwise = substitute needle xs replacement
14:34:43 <_Ace_> as before
14:34:44 <Riastradh> No...
14:34:55 <Riastradh> We want to add x to the list 'substitute needle xs replacement'.
14:35:14 <Lunar^> Xcalibor: your friend the prelude defines all kinds of number to be of class Show :)
14:35:27 <_Ace_> aha
14:35:33 <Riastradh> In the previous line, we did 'replacement : substitute needle xs replacement'; now, instead of adding replacement to 'substitute needle xs replacement', we want to add x to it.
14:35:59 <_Ace_> | otherwise = x:substitute needle xs replacement
14:36:02 <_Ace_> then I guess
14:36:12 <Riastradh> OK, now put the whole thing together.
14:36:32 <_Ace_> substitute _ [] _ = []
14:36:32 <_Ace_> substitute needle (x:xs) replacement
14:36:36 <_Ace_> 	| x == needle = replacement:substitute needle xs replacement
14:36:36 <_Ace_> 	| otherwise = x:substitute needle xs replacement
14:36:42 <Riastradh> Now try it.
14:36:48 <_Ace_> I get errors trying to load it
14:37:04 <Riastradh> What errors?
14:38:02 <Xcalibor> Lunar^: okay, but reverse expects [a] and not a... thus I need to convert 123 to "123" so reverse gives me "321" and back to 321 so I can sum them both...
14:38:20 <_Ace_> Cannot unify the type-signature `a' with the type ^[a]'
14:38:31 <_Ace_> Exp, type: [a]
14:38:33 <Riastradh> _Ace_, could you paste the whole error?
14:38:40 <_Ace_> cant select the damn text
14:38:50 <Lunar^> Xcalibor: String eq. [Char] in Haskell
14:39:18 <Xcalibor> Lunar^: right... but Num not eq. [Digits] :-/
14:39:28 <Riastradh> Xcalibor, that's why we have Read and Show.
14:39:30 <Lunar^> Xcalibor: the opposite operation of "show" is "read", defined for type class "Read"
14:39:45 <Riastradh> read . show $ 123
14:39:52 <_Ace_> cant u test it ?
14:40:39 <Xcalibor> Riastradh: ghci doesn't like that code :-/
14:40:55 <Lunar^> Xcalibor: what does it said ?
14:41:08 <Xcalibor> Ambiguous type variable `a' in these top-level constraints:
14:41:08 <Xcalibor>   `Read a' arising from use of `read' at <interactive>:1
14:41:08 <Xcalibor>   `Show a' arising from use of `print' at <No locn>
14:41:14 <Riastradh> Oh, bah.
14:41:39 <Riastradh> _Ace_, works for me.
14:41:46 <Lunar^> Xcalibor: It can't infer what Read or Show it should use
14:42:04 <Riastradh> Xcalibor, '(read . show $ 123 :: Integer)'
14:42:12 <_Ace_> hmm
14:42:14 <_Ace_> w8
14:42:19 <_Ace_> gonna try to paste it
14:42:20 <Lunar^> Xcalibor: what definition, exactly, because 123 could be an Integer, an Int, a Float, ...
14:42:38 <Xcalibor> okay, Riastradh now it works
14:43:28 <kosmikus> _Ace_: if the type error message tells something about a "type signature", this indicates that you have additional code (a type signature) in your source file
14:44:23 <_Ace_> so what do I do then?
14:44:35 <_Ace_> substitute :: Eq a => a -> [a] -> [a] -> [a]
14:44:39 <_Ace_> you mean that=
14:44:40 <_Ace_> ?
14:45:12 <kosmikus> yes
14:45:17 <kosmikus> that's wrong
14:45:22 <Riastradh> _Ace_, 'a' refers to 'needle'; '[a]' refers to the list; the second '[a]' refers to 'replacement,' but what is 'replacement'?
14:45:39 <Lunar^> The type signature is right
14:45:47 <Riastradh> Lunar^, no it isn't.
14:45:53 <Lunar^> It's right for what he wants to do
14:46:01 <Riastradh> No, it isn't.
14:46:03 <Lunar^> replacement is not a single char
14:46:12 <Lunar^> It's a String
14:46:24 <_Ace_> Cannot unify the type-signature variable ` a' with the type `[a]'
14:46:24 <_Ace_> Expected type: [a]
14:46:24 <_Ace_> Inferred type: a
14:46:34 <_Ace_> In the first argument of `substitute', namely `needle'
14:46:34 <_Ace_> In the second argument of `(:)', namely
14:46:34 <_Ace_> `substitute needle xs replacement'
14:46:46 <Lunar^> Ace : that's because replacement is a String
14:46:56 <_Ace_> complaints on:
14:46:57 <_Ace_> 	| x == needle = replacement:substitute needle xs replacement
14:47:01 <_Ace_> ah
14:47:04 <_Ace_> hmm
14:47:21 <Riastradh> _Ace_, if you're putting 'replacement' in the place of 'x', and 'needle' has the same type as 'x', and 'needle's type is 'a', what should 'replacement's type be?
14:47:22 <_Ace_> how do I make a String a Char then?
14:47:34 <Lunar^> Ace : you don't want to do that !
14:48:01 <Lunar^> Ace : In terms of type, you have -> a : [a]
14:48:04 <_Ace_> Riastradh: hmm
14:48:20 <_Ace_> damnit
14:48:22 <_Ace_> allways something
14:48:27 <Lunar^> Ace : if replacement is [a], then you need something that would take a list in the left
14:48:27 <Riastradh> _Ace_, 'needle' will have the same type as 'x'.
14:48:32 <Riastradh> 'x' has a type of 'a'.
14:48:44 <Riastradh> Er, no, let me rephrase.
14:49:03 <Riastradh> With the type signature, 'needle' will have a type of 'a'.
14:49:14 <Riastradh> Because you're comparing 'needle' and 'x', they must have the same type.
14:49:15 <Smerdyakov> Maybe one of you could stop trying to help at the same time as the other. :P
14:49:24 <Lunar^> Smerdyakov: you're right :)
14:49:46 <Riastradh> 'replacement' might go into the place where 'x' used to be, so 'replacement' must have the same type as 'x'.
14:50:24 <Lunar^> Riastradh: he wants to do substitute 'x' "3*cos(x) + 4 - x" "5.37" = "3*cos(5.37) + 4 - 5.37"
14:50:48 <Riastradh> Oh.
14:50:56 <_Ace_> uh
14:50:58 <_Ace_> lol
14:51:12 <_Ace_> then I have to forgett all you just said Riastradh?
14:51:29 <Riastradh> No, you'll just have to change one thing.
14:52:02 <Riastradh> If x == needle, then you want to add the entire list 'replacement' to 'substitute needle xs replacement', not just add one element.
14:52:06 <Riastradh> How do you append lists?
14:52:19 <_Ace_> no idea
14:52:24 <Lunar^> @prelude (++)
14:52:25 <lambdabot> *** "(++)" prelude "Haskell Standard Prelude Dictionary": text follows
14:52:25 <lambdabot> (++)
14:52:25 <lambdabot>   infixr 5 ++
14:52:25 <lambdabot>   (++) ::  [a] -> [a] -> [a]
14:52:26 <lambdabot>   []     ++ ys      = ys
14:52:28 <lambdabot>   (x:xs) ++ ys      = x : (xs ++ ys)
14:52:33 <_Ace_> aha
14:52:45 <Riastradh> So instead of adding a single element using (:), you'll add an entire list using (++).
14:52:52 <Riastradh> Modify this line so it's correct:
14:53:02 <Riastradh>     | x == needle = replacement : substitute needle xs replacement
14:53:08 <_Ace_> well
14:53:12 <_Ace_> can it be this easy?
14:53:14 <Riastradh> (remember, you're just using (++) instead of (:))
14:53:16 <Riastradh> Yes.
14:53:23 <_Ace_>    | x == needle = replacement ++ substitute needle xs replacement 
14:53:28 <Riastradh> Yup.
14:53:29 <Riastradh> Now try it.
14:53:31 <_Ace_> ok
14:54:13 <_Ace_> kewl
14:54:15 <_Ace_> works
14:54:23 <Lunar^> *sigh*
14:54:32 <_Ace_> but it feels I have to reread it all here
14:54:34 <_Ace_> :D
14:55:10 <_Ace_> Lunar: Why signing?
14:55:28 <Xcalibor> okay, done :-)    thnks for the help, guys :-)
14:55:53 <Lunar^> Because I'm going to do an Haskell course of 37.5 hours soon
14:56:06 <_Ace_> thanx ppl
14:56:11 <_Ace_> need this "lession" :)
14:56:13 <Lunar^> Hope my students will be quickier to catch ;)
14:56:20 <_Ace_> lol
14:56:25 <_Ace_> :p
14:56:43 <Lunar^> (or I'm going to take some Valium ;))
14:56:48 <_Ace_> its a different way of thinking
14:58:18 <Xcalibor> Lunar^: Riastradh: wanna see the solution to the palindromes problem?
14:59:45 <Lunar^> go on
15:00:34 <Xcalibor> okay: it's 3 simple functions...
15:00:42 <Xcalibor> nreverse n = 
15:00:42 <Xcalibor> 	read . reverse . show $ n
15:00:54 <Xcalibor> so we go from 123 to 321
15:01:01 <Xcalibor> is_pal n =
15:01:02 <Xcalibor> 	if n == (nreverse n) then
15:01:02 <Xcalibor> 	   True 
15:01:02 <Xcalibor>  	else False
15:01:13 <Xcalibor> is a palindromic number?
15:01:20 <Xcalibor> palindrome n =
15:01:20 <Xcalibor> 	if n > 10000000 then 
15:01:20 <Xcalibor> 		   -1
15:01:20 <Xcalibor> 	else
15:01:20 <Xcalibor> 	       if is_pal n then n else
15:01:21 <Xcalibor> 			  palindrome (n + nreverse n)
15:01:26 <Xcalibor> and that's all... very elegant :-)
15:01:57 <Xcalibor> well... copy&paste spoiled the indentation somehow...
15:02:12 <Lunar^> That's not really the nicest way
15:02:28 <Lunar^> but it works
15:02:30 <Xcalibor> Lunar^: probably... but it works... now I can work on improving it
15:02:33 <Xcalibor> ;(
15:02:36 <Lunar^> :)
15:02:37 <Xcalibor> i mean :-)
15:03:34 <Lunar^> I think I've seen something using the lazyness for this problem somewhere
15:04:21 <Xcalibor> i got to solve this problem in C++, using the STL... and I got a recursive solution, thus i thought it should be nice and straightforward in a FL...
15:05:16 <Xcalibor> another way that comes to mind is lazily constructing the list of terms of the form n :: n + nreverse n and testing the palindromic nature on those...
15:05:51 <Xcalibor> doing a filter until we get True or something like that
15:06:01 <Lunar^> n + nreverse ?!
15:06:14 <Xcalibor> n + (nreverse n)
15:06:25 <Xcalibor> okay, i was being informal... :-)
15:06:46 <Lunar^> uuhhh 123 + 321 = 444 
15:07:03 <Xcalibor> Lunar^: yup... but 28 + 82 = 110
15:07:27 <Lunar^> You should do it in base 18 ;)
15:07:34 <Xcalibor> when the sum of digints 'carries' to the next one you gotta apply the method again.. the theorem guarantees such a number exists
15:07:47 <Xcalibor> hehe... :-)
15:07:56 <Lunar^> which method ?
15:09:04 <Xcalibor> it's a theorem, apparently: for every Nat n such as n is a palindrome there exist numbers m and c such as n == n + (nreverse n) applied c times
15:09:47 <Lunar^> Going to bed now.. seeing Steve Jobs tomorrow
15:09:56 <Xcalibor> really? good luck
15:10:03 <Lunar^> Apple Expo Keynote
15:10:11 <Xcalibor> aha... nice :-)
15:10:14 <Lunar^> :)
15:10:19 <Xcalibor> good night, thenb
15:13:07 <Xcalibor> hiyas whee
15:15:55 <Xcalibor> 28 -> 28 + 82 -> 110 -> 110 + 011 -> 121 QED
15:15:57 <Xcalibor> :)
15:16:36 * Xcalibor brb phone
15:23:23 <Nairda> pero/u
16:37:11 <Xcalibor> okay, time for bed... thanks for all the help
16:37:15 <Xcalibor> laters!"
17:16:42 <steveh> hi syntax-laptop...
17:17:00 <steveh> what kind of laptop is that anyway? :)
17:19:39 <syntax-laptop> steveh: gateway centrino thingy
17:19:44 <syntax-laptop> Debian GNU/Linux of course
17:19:47 <syntax-laptop> running apt-secure ;)
17:19:53 <syntax-laptop> silver
17:20:01 * steveh needs a laptop
17:20:18 <syntax-laptop> I would recommend this one, but the built-in wireless doesn't work in Linux yet :( :(
17:21:09 <steveh> hmm
17:21:24 <steveh> I think I need a winders machine first though
17:23:42 <syntax-laptop> why would anyone need one of those? 
17:30:44 <steveh> well
17:31:06 <steveh> the job market for inexperienced unixheads is kind of slow
17:31:26 <steveh> plus I get frustrated with people who only do word documents :)
17:32:17 <steveh> "your [plaintext] resume doesn't come out quite right in word, it wraps around..."
17:32:29 <steveh> [to myself] THEN CHANGE THE FONT SIZE!!!
17:32:38 <steveh> "ok, let me send you a word version..."
17:33:00 <Strike> use openoffice or abiword
17:33:15 <steveh> I have Word v.X
17:33:18 <Strike> abiword does a bang-up job :)
17:33:24 <steveh> but I don't compose my resume in it
17:33:32 <Strike> perhaps you should ;)
17:33:33 <steveh> or would prefer not to
17:33:37 <Strike> why not?
17:33:38 * steveh does his resume in LaTeX
17:33:45 <Strike> steveh: ooh, got a good .sty file for it?
17:33:52 * Strike has looked for one to no avail
17:34:04 <steveh> Strike: heh, no, but I suppose I could make one
17:34:09 <steveh> the resume itself does look badass
17:34:16 <Strike> steveh: well, how do you do it then?
17:34:18 <steveh> I do take some liberties with some parameters though
17:34:27 <Strike> oh, and I don't know why I'm addressing you ... we're the only ones talking
17:34:36 <Strike> it's this crappy new xchat coloring logic, grrr
17:35:24 <Strike> they can't take PDF?
17:35:33 <steveh> let me put the .tex and .pdf output on the web
17:35:37 <steveh> it's hard to explain
17:36:29 <steveh> http://mulder.homeunix.net/~steve/huwig-resume.tex
17:36:32 <Strike> @commands
17:36:32 <lambdabot> Sorry, I don't know the command "commands", try "lambdabot: @listcommands"
17:36:36 <Strike> @listcommands
17:36:36 <lambdabot> I react to the following commands: ["all-dicts","define","definitions","del-definition","devils","dict","dict-help","dummy","dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements","eval","foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","lojban","more","msg","part","prelude","quit","reconnect","
17:36:38 <steveh> http://mulder.homeunix.net/~steve/huwig-resume.pdf
17:36:41 <Strike> damn, no larting
17:36:42 <steveh> now don't go stalking me :)
17:36:47 <Strike> muahaha
17:37:10 <steveh> notice things like \setlength{\parindent}{-.2in}
17:37:27 <steveh> but there's actually very little customization going on
17:37:33 <steveh> i made up a nicer bullet list
17:37:39 <Strike> hey, that's not bad at all
17:37:40 <steveh> since the default's spacing is way too big
17:37:48 <Strike> looks pretty nice, reallyt
17:37:51 <Strike> s/yt/y/
17:37:53 <steveh> it's actually very close to what my resume was in Word
17:38:06 <steveh> but I thought
17:38:15 <Strike> and as a bonus, you get "LaTeX" to render precisely as it's intended to be rendered ;)
17:38:21 <steveh> "you know, it looks kinda dumb to write 'LaTeX' instead of using the logo"
17:38:24 <steveh> EXACTLY
17:38:28 <steveh> that's what started my crusade
17:38:29 <steveh> :)
17:38:33 <Strike> hehe
17:39:09 <Strike> eek, the .tex source is pretty hefty
17:39:30 <Strike> oh no, you are contributing to the evil!  "converting LaTeX documents to Microsoft Word"
17:39:36 * Strike holds up two fingers in shape of cross
17:40:01 <syntax-laptop> hehe
17:40:25 <syntax-laptop> steveh: but surely WOrd can't be the only reason you feel you need a windows machine.  I guess you mentioned somethign about the job market too.
17:41:02 <steveh> yeah
17:41:08 <steveh> .NET looks intriguing
17:41:12 <steveh> I don't have a windows machine right now
17:41:13 <Strike> seriously though, OpenOffice.org and Abiword both do pretty outstanding jobs at importing relatively simple Word docs
17:41:21 * Strike scoffs at .NET
17:41:31 <steveh> once in a while I like to play a game
17:41:55 <steveh> and there are even fewer Unix jobs than there are MS-oriented jobs
17:41:58 <steveh> which is pretty bad
17:48:01 <steveh> Strike: I know it's openstep and java warmed over, but as you can see from my resume I have had to deal with MFC(!)
17:48:06 <steveh> .NET must be a godsend
17:48:22 <Strike> well yeah, for Win32 programming it is probably a huge step up
17:48:31 <Strike> but that's not saying much :)
17:50:11 <Strike> so instead of getting kicked in the head with a steel-toed boot repeatedly, you're just getting kicked in the head with a regular tennis shoe or something :p
17:50:51 <steveh> it's a huge step up indeed
17:50:58 <steveh> plus I think VS is a pretty nice tool
17:51:04 <steveh> don't get me wrong, I like emacs
17:51:08 <steveh> but VS has its moments
17:51:09 <steveh> :)
17:51:13 <Strike> I'm not a huge fan of either :)
17:51:29 <Strike> though emacs definitely has its moments
18:00:32 <yazirian> emacs?! vi!!! ;)
18:00:49 <syntax-laptop> NO! Emacs!!
18:00:56 <yazirian> NO! vi!!
18:01:00 <yazirian> haha
18:01:07 <syntax-laptop> :P
18:07:19 <yazirian> seriously though, I can't live without a delete-line operation. Either 'dd' or 'ctrl-k' will do the trick, but 'home, shift-end, delete' just sucks.
18:07:53 <steveh> couldn't you make a macro?
18:08:20 <yazirian> probably
18:09:00 <yazirian> but gvim exposes an OLE component of itself on win32, so even on VS... why? :) ...although I haven't heard if they got it working with VS7 yet.
18:10:44 <steveh> bleh, gvim
18:10:46 <steveh> :-D
18:11:29 <yazirian> I noticed today that emacs now includes a screensaver. I figure the Terminator movies are actually talking about emacs when they say 'SkyNet'.
22:05:26 <harsha123> hi everyone..
22:17:16 <harsha123> hi shapr
22:17:20 <harsha123> hi adept
22:17:26 <harsha123> you guys there?
22:18:07 <Verbed> Are you okay?
22:18:38 <harsha123> Verbed: who?
22:19:30 <Verbed> I remember you mentioning earlier that you're having a bad day.
22:20:05 <harsha123> omg.. yeah.. try to get my sound working.. but couldnt 
23:55:15 <adept> re all
23:55:34 <harsha123> hi adept
23:57:45 <adept> harsha123: hi. how your sound is doing?
23:58:08 <harsha123> hehehe.. not yet working..
