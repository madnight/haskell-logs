00:00:04 <shapr> sure!
00:03:32 <shapr> gru√ügott ecraven 
00:03:52 <ecraven> good morning :-)
00:04:06 <shapr> are you learning Haskell?
00:05:05 <ecraven> yes.. i also know some Clean
00:05:12 <shapr> I haven't tried Clean
00:05:26 <Darius> well, now my Prolog interpreter has higher-order features...
00:05:43 <shapr> Darius: cool, will your prolog interpreter end up as a lambdabot plugin also? :-)
00:05:55 <ecraven> i like functional languages better than most other types
00:05:56 <Pseudonym> http://www.seg.rmit.edu.au/research/download.php?manuscript=23
00:06:02 <Pseudonym> That one is quite good.
00:06:11 <Darius> I already stuck it temporarily in the dummy module earlier.
00:06:17 <Pseudonym> shapr: I can see it now.
00:06:23 <Pseudonym> <lambdabot> Fail.
00:06:50 <shapr> or maybe lambdabot can use the cut operator on the list of users if we get too many homework seekers
00:07:21 <shapr> ecraven: I also like FP languages better.
00:07:28 <Darius> I haven't implemented cut.  Only the pure core.
00:08:23 <ecraven> shapr: i still prefer s-expr like syntax though..
00:08:40 <shapr> ecraven: I prefer significant whitespace, in my experience it's better for humans.
00:08:47 <shapr> admittedly, sexps are better for computers.
00:09:12 <shapr> Pseudonym: oh, this looks wonderful, thanks!
00:18:08 <shapr> gutentag magr 
00:19:38 <Pseudonym> Gotta go.  Nytol
00:30:06 <magr> G'day
00:31:51 <shapr> heh, random national greeting :-)
00:32:50 <magr> Oui, salut!
00:32:58 <shapr> hoi kosmikus 
00:32:58 * shapr grins
00:33:50 <magr> Ahoi.
00:34:10 <shapr> hola
00:35:42 <magr> what about a lambdabot greeting plugin
00:35:57 <magr> maybe I'll look into this.
00:36:01 <shapr> sounds good to me
00:36:08 <Darius> looks like the HaRe snapshot has been updated again.  I wonder if they've fixed the infix operator problem.
00:36:14 <kosmikus> hej shapr
00:36:38 <Darius> oo, they added some basic documentation this time
00:36:39 <magr> shapr: this would be nearly the same as @yow, I suppose
00:37:03 <shapr> magr: I think so
00:37:22 <shapr> the @arr plugin is just a list and a getRandom call
00:38:12 <shapr> hoi earthy 
00:39:18 <Darius> aha, the new screenshots show the truth.
00:43:25 <shapr> where are the new screenshots?
00:43:58 <shapr> the figlets logo in the README is cute
00:45:12 <Darius> The GVim screenshots at the bottom of the page weren't there last time.
00:45:48 <shapr> too bad they don't have linux screenshots
00:46:36 <shapr> it looks quite tasty so far
00:48:17 <Darius> Yes but in the slides they have sum n (x:xs) = x + sum n xs -=> sum n c (x:xs) = x `c` sum n c xs which doesn't work yet unless this new snapshot fixes it.
00:55:32 <Lor> Is there a tool to transform a bibtex file directly into a bibliography without having to write a latex document that references everything?
00:58:38 <magr> Lor: do you know about \nocite{*} ?
00:58:59 <Lor> No.
00:59:01 <Lor> Do tell.
00:59:22 <Darius> hmm, I might as well tell the HaRe folk that it works on Win2k/vim6.1/ghc6 modulo some additional whitespace.
01:00:04 <magr> \nocite{*} is equivalent to a \nocite{key} for each key in bibtex file
01:00:53 <Lor> Ah, right.
01:01:14 <magr> Lor: you have to write a document, but it's short
01:01:27 <Lor> I guess I can live with that. Thanks.
01:03:02 <Darius> It'd be nice if they provided a 'send HaRe related email here' note somewhere
01:05:29 <shapr> send it to Claus
01:07:26 <Darius> Claus has a talk on the pi-calculus and Pict.
01:07:49 <shapr> oh neat
01:13:33 <shapr> hej dennisb 
01:13:42 <andersca> hej dennisb!
01:13:56 * andersca saw dennisb the other day
01:14:08 <shapr> what does he look like?
01:15:40 <andersca> he used to have a picture on his web page
01:15:50 <andersca> shapr: did you know that dennisb wrote the win95 look for wine
01:16:06 <shapr> really?
02:12:39 <shapr> g'day clausen 
02:12:50 <clausen> gday shapr
02:13:40 <shapr> what's up?
02:15:30 * clausen giving a talk tommorrow...
02:15:39 <shapr> what are you talking about?
02:15:44 <clausen> PageRank
02:15:50 <clausen> (and reputation metrics in general)
02:15:58 <clausen> it's a tutorial
02:17:59 <clausen> did you ever see my paper?
02:18:13 <shapr> I don't think so
02:18:20 <shapr> what's the url?
02:18:25 <clausen> members.optusnet.com.au/clausen/ideas/google/google-subvert.pdf
02:19:33 <shapr> oh, that's nifty
02:19:41 <clausen> :)
02:20:54 <shapr> I like the mention of unsuccessful lawsuits
02:21:05 <clausen> hehe
02:23:42 <shapr> hah --> "should the google toolbar show reputation in dollars or other local currency"
02:24:30 <andersca> shapr: who did the X11 bindings?
02:25:05 <shapr> andersca: Reid
02:25:12 <shapr> HSX11
02:25:17 <andersca> and who's Reid?
02:25:18 <andersca> is he here?
02:25:39 <shapr> http://www.reid-consulting-uk.ltd.uk/projects/HSX11.html
02:25:44 <shapr> Alistair Reid
02:27:17 <shapr> clausen: what's the 'trusted third parties' about?
02:27:29 <clausen> in the url?
02:27:33 <clausen> or my paper?
02:27:37 <shapr> in your paper
02:27:42 <clausen> ah
02:28:02 <clausen> I think "decentralized, mutually trusted" third parties could be useful
02:28:17 <clausen> (I think they are necessary)
02:28:19 <clausen> consider this:
02:28:33 <clausen> imagine a world where everone had a really good reputation metric
02:28:39 <clausen> if you ripped anyone off
02:28:44 <clausen> everyone would know
02:28:49 <clausen> and no-one would trust you anymore
02:29:12 <clausen> in such a world we hope, no-one would ever rip anyone off :)
02:29:18 <shapr> truly
02:29:23 <clausen> now, there is a problem:
02:29:36 <clausen> if I complain to "the world" that you ripped me off
02:29:38 <shapr> andersca: are you thinking of starting a WM project? I'd be interested in joining such.
02:29:42 <clausen> who is available to assess this claim?
02:29:50 <clausen> I might be blackmailing you
02:29:59 <clausen> i.e. pay up, or I'll complain to The World
02:30:16 <clausen> conversely, you might think no-one would ever believe my howling
02:30:20 <shapr> so do you rate each person according to how closely to yourself they've been in the past?
02:30:36 <clausen> shapr: if you do that, you're no longer talking about reputation
02:30:41 <shapr> hm
02:30:54 <clausen> so, my solution to the problem is this:
02:31:08 <clausen> (1) make an individual complaint "weak" in such a reputation system
02:31:24 <clausen> (2) for a complaint to be strong, it would require many people to condemn
02:31:47 <clausen> (3) before starting a contract, the two parties find several other mutually trusted/reputable parties to oversee the transaction
02:32:07 <clausen> you can use public key/private key to bind them to the transaction, etc.
02:32:12 <clausen> this way, you can limit the scope of a complaint
02:32:28 <clausen> (eg: if I claim I sent you $1000, and I only set $100...
02:33:00 <shapr> makes sense
02:33:24 <clausen> ... I would need to produce the signed contract countersigned by the trusted third parties
02:33:33 <clausen> if I wanted them to add their weight to the complaint)
02:33:41 <clausen> anyway, my research hasn't really extended this far yet...
02:33:49 <clausen> it's just a pie-in-the-sky idea ATM
02:33:55 <shapr> sounds nifty so far
02:33:56 <clausen> lots of other details to sort out before then :)
02:34:07 <clausen> :)
02:34:29 * clausen off to eat dessert (BBIAB)
02:47:39 <mgoetze> hm
02:47:53 * mgoetze scrolls back to read what clausen is talking about
02:47:56 <harsha123> hi haskell
02:49:08 <harsha123> shapr: hi
02:49:20 <harsha123> Smerdyakov: hello
02:51:34 <shapr> hello harsha123 
02:51:36 * mgoetze thinks that clausen chap has some interesting ideas
02:51:41 * shapr gets ready for swedish class
02:51:51 <tic> http://www.mini-itx.com/news/computex2003-1/images/computex2003-1-0001L.jpg -- yummie mainboard.
02:52:28 * mgoetze thinks GPG keys should be made mandatory for government-related tasks on the internet
02:53:09 <harsha123> hey.. does anyone know how I can get the number of columns in awk?
02:53:27 * harsha123 forgets for a while that its a haskell room :)
03:13:02 <ecraven> is there any way i can use haskell interactively like an interpreter?
03:14:19 <ecraven> i tried ghci but it seems i am doing something wrong...
03:14:45 <harsha123> ecraven: ghci6 or gchi5 on debain
03:15:12 <Igloo> Just ghci should work too
03:15:38 <ecraven> i tried to enter <  inc n = n + 1   > 
03:16:02 <Darius> You need to put definitions in a file typically, though in GHCi you can use let
03:16:17 <ecraven> :-(
03:16:39 <Darius> In this case you can just do, let inc n = n + 1
03:17:04 <ecraven> so i can't define new functions?
03:17:10 <Darius> But if you want to add a new datatype, class, or instance you need to put it in a file.
03:17:25 <ecraven> thanks :-(
03:17:33 <Darius> you can use let.
03:18:47 <Darius> If you type let inc n = n + 1 <enter>, inc will be defined.
03:19:31 <shapr> let shapr = IrcUser
03:19:45 <shapr> yay, class is canceled today
03:19:48 <shapr> I can keep working
03:36:46 <clausen> mgoetze: thanks :)
03:44:46 <RibRib> hello
03:44:52 <RibRib> what does :t do?
03:45:41 <Lor> It gives you the type of an expression.
03:46:54 <mgoetze> clausen: how was your dessert? :)
03:47:04 <RibRib> ic thanks
03:48:22 <clausen> mgoetze: sugar is nice :)
03:59:37 <RibRib> damn its hot
04:03:06 <harsha123> hot?? RibRib is it the weather?? or??
04:03:12 <harsha123> :p
04:03:21 <RibRib> weather :)
04:03:37 <harsha123> can't get hotter than here. :(
04:12:05 <RibRib> and there is?
04:12:38 <ski_> barbados ?
04:15:00 <shapr> yeehaa
04:15:12 <shapr> I'd like to live in a warm place
04:15:38 <RibRib> most ppl do...
04:19:13 <Darius> add (!ask) (!add (!ask) (!ask)) -=> do t1 <- ask;t2 <- ask;t3 <- ask;t4 <- add t2 t3;add t1 t4
04:20:28 <RibRib> When you finish all these three modules type make, it'll do the intergration test for you. The make test would give you sample output which would look like this.
04:20:53 <RibRib> is "make" a haskell keyword? or is it unix?
04:22:49 <Darius> make is a utility program that is typically associated, but certainly not limited to, unix.
04:23:50 <RibRib> im on my PC, will i be able to use make?
04:24:26 <ski> if you have a make installed ..
04:24:59 <ski> from e.g. cygwin, djgpp, mingw, ...
04:25:08 <RibRib> oh ok..
04:26:06 <ski> i suppose/presume that it is also available somewhere as a standalone (i.e. not included in a package)
04:29:44 <RibRib> the tutor didnt explain properly :(
04:31:56 * mgoetze drinks peach nectar
04:32:07 * shapr drinks RC Cola
04:32:39 * shapr drinks the blood of THE INFIDELS.
04:33:26 <shapr> hoi kosmikus 
04:33:30 <shapr> are you AN INFIDEL?
04:33:33 <earthy> @yow
04:33:34 <lambdabot> Uh-oh!!  I'm having TOO MUCH FUN!!
04:33:40 <shapr> @fortune
04:33:41 <lambdabot> Keep grandma off the streets -- legalize bingo.
04:33:44 <shapr> heh
04:34:00 <mgoetze> lol
04:34:11 <Riastradh> @yow
04:34:12 <lambdabot> I've got a COUSIN who works in the GARMENT DISTRICT...
04:34:17 <shapr> @arr
04:34:17 <lambdabot> Get out of me way, yeh landlubber
04:34:26 <shapr> I want more Pirate quotes.
04:34:34 <shapr> oh, I could check in the @arr changes
04:34:52 <shapr> @yow
04:34:53 <lambdabot> OKAY!!  Turn on the sound ONLY for TRYNEL CARPETING,
04:34:53 <lambdabot>  FULLY-EQUIPPED R.V.'S and FLOATATION SYSTEMS!!
04:34:57 <shapr> @fortune
04:34:57 <lambdabot> Q:	What's buried in Grant's tomb?
04:34:57 <lambdabot> A:	A corpse.
04:35:00 <shapr> @fortune
04:35:01 <lambdabot> My doctorate's in Literature, but it seems like a pretty good pulse to me.
04:35:05 <shapr> hah
04:41:22 <ski> shapr : like : This is the END for you, you gutter-crawling cur!  ?
04:41:31 <shapr> hmm
04:41:34 * shapr adds that
04:41:57 <ski> you can look at http://www.geocities.com/TimesSquare/Lair/5529/hints.htm
04:44:34 <ski> heh
04:50:24 <earthy> 'May the clap make ye incapable of Cracking Jenny's Tea Cup.'
04:50:48 <earthy> 'Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.'
04:50:57 <earthy> and more such at http://com1.akheva.com/bthefoyer.fmainchat.t198%7Coffset=10
04:51:04 * earthy hugs google
04:51:46 * Darius has found a use for 'do stmt'
04:51:52 <ski> can hugs google anything ?  :)
04:54:18 <shapr> actually, a SOAP lib would let lambdabot google
04:55:38 <Heffalump> whee.
04:55:39 <Heffalump> I'm not here.
04:56:44 <earthy> hm. seems like there's no way to open a socket from hugs
04:56:49 <shapr> I don't think so
04:57:14 <earthy> unless one 'd use the FFI
04:58:30 <Igloo> Darius?
05:00:56 <Darius> I'm hacking a TH thing to do a commutative monad syntax.  I use a '!' section as an indicator.  Anyways, one issue is what e.g. local (f (!ask)) means; is it ask >>= local . f or local (ask >>= f)
05:01:39 <Darius> (add in a function to modify the environment)
05:02:22 <shapr> hey o3, ltns
05:02:55 <Darius> So, the first idea I've had is to use do to tell the differenc, so local x (f (!ask)) is ask >>= local x . f and local x (do f (!ask)) is local x (ask >>= f)
05:03:09 <Igloo> Ah, I see
05:04:21 <ski> is ! a sort of unquote/reflect ?
05:04:50 <Igloo> No, just an operator
05:05:08 <shapr> hm, neat: http://www.emacswiki.org/cgi-bin/wiki.pl/FlyMake
05:05:38 <ski> Igloo : with what type ?
05:06:12 <Igloo> Whatever type it's given - it's not in the Prelude
05:06:43 <ski> but what would it's type be in darius snippet ?
05:07:23 <Darius> It has no meaning, I only use it as a marker (though it would be a problem if I import Array where it's the index operator)
05:07:31 <Darius> It's defined as: _ ! _ = undefined
05:08:53 <ski> if it has no meaning, then why define it ?  :)
05:09:23 <Igloo> Because the Template Haskell code will look for it
05:09:31 <Darius> TH not only looks up free identifiers in quoted code blocks, but it also typechecks them.
05:10:39 <ski> aha, you can tell template haskell to rewrite exprs containing !, in certain ways, yes ?
05:10:44 <o3> hi shapr, *
05:11:04 <Darius> more or less, yes
05:11:14 <ski> k
05:25:29 <Igloo> Does anyone know of something I can cite to say you can't type all programs-that-won't-go-wrong?
05:26:06 <ski> something authorative ?
05:26:46 <o3> ski: i guess somebody more authoratative than igloo ;)
05:27:12 <Igloo> Just something to save me muttering incoherently about decidability and stuff  :-)
05:27:23 <Igloo> Something canonical would be nice, though
05:27:37 <ski> does http://citeseer.nj.nec.com/14244.html qualify ?
05:28:08 <o3> Igloo: if you're talking in the context of lazy programs, i'm sure bob harper has something to say on that :)
05:28:35 <ski> (that paper is not very formal or authorative)
05:30:01 * Igloo scans through that backwards and raises an eyebrow at page 18/19
05:30:47 <ski> heh, yeah that type is big
05:31:51 <harsha123> shapr: do you know of a GUI tool to manage all the startup programs in debian?
05:32:14 <harsha123> shapr: something .. that exists in redhat?
05:32:15 <mgoetze> harsha123: please expound upon the term "startup programs"
05:32:34 <harsha123> mgoetze: /etc/init.d/*
05:34:05 <mgoetze> harsha123: there's rcconf but i don't think it's a GUI tool
05:34:27 <harsha123> mgoetze: is it based on curses ?
05:34:29 * earthy thinks
05:34:50 <earthy> what's wrong with file-rc and using an editor on the file with the start- and stop data?
05:35:19 <harsha123> earthy: i dont need it.. a friend of mine asked me.. 
05:35:27 <harsha123> hez new to linux
05:36:16 <earthy> ah... well...
05:36:51 <mgoetze> harsha123: no, it uses whiptail
05:37:01 <harsha123> mgoetze: ok..
05:37:11 <harsha123> mgoetze: am just installing it
06:02:06 <shapr> wheee
06:02:30 <shapr> harsha123: I can just explain to you how the startup process works, and then you can change it yourself
06:13:17 <mgoetze> shapr: i don't think that's what he was looking for :)
06:18:03 * harsha123 is back.. :)
06:18:22 <SyntaxPolice> mornin'
06:18:27 <harsha123> tea has made me fresh.. :)
06:18:31 <phubuh_> Herllio
06:18:43 <harsha123> its evening here.. :)
06:20:49 <shapr> it's afternoon here
06:25:09 <Lunar^> shapr: I'm starting my course next wednesday finally
06:25:15 <Lunar^> shapr: 3 hours a week
06:25:38 <Lunar^> shapr: You can look at its toc (in french) at http://lune.talath.net/~lunar/Plan.html
06:26:05 <harsha123> what course Lunar^? 
06:26:27 <Lunar^> harsha123: about Haskell 
06:26:40 <Lunar^> harsha123: to our 2nd year (on 5)
06:26:51 <harsha123> Ok.. at University?
06:28:23 <Lunar^> It's a private  engineering school
06:28:44 <harsha123> Ok... here in india.. haskell is not taught.. :(
06:29:09 <harsha123> infact i dont think you can find even a bunch fo func. programmers.
06:30:34 <Lunar^> harsha123: Haskell is not much taught everywhere
06:31:01 <Lunar^> In France, the problem is that the functional programming place is trusted by Caml people (which France is homeland)
06:31:47 <harsha123> hmm.Ok
06:32:04 <harsha123> is it used for research? or at Universities ?
06:32:58 <Lunar^> both
06:33:14 <Lunar^> Didier Remy et al
06:33:20 <Lunar^> Hindley-Minler people
06:33:35 <Lunar^> INRIA labs
06:33:53 <harsha123> hmmm
06:45:38 * harsha123 feels the haskell compiler is slow.. 
06:45:45 <harsha123> what do ya guys think?
06:45:57 <harsha123> hmm considerably slow..
06:46:15 <Igloo> What compiler are you using on what OS/arch?
06:46:27 <Igloo> GHC isn't the fastest thing in the world, particularly if you tell it to optimise
06:46:47 <harsha123> ghc6 debian intel arch
06:49:28 * harsha123 thinks it does not make a diff to him 'cause hez still learning :)
06:49:57 <Darius> Don't use -O/-O2 and GHC is reasonable.
06:50:37 <phubuh_> harsha123, you might want to try hugs. it's very fast, but not as complete as ghc. the runtime performance is worse as well.
06:50:52 <phubuh_> i think it generates more readable error message too
06:51:21 <harsha123> hugs is dos based??? am not sure plz tell me
06:51:22 <Igloo> "not as extended", not "not as complete"
06:51:33 <Darius> Actually, I have the impression that Hugs is notorious for it's poor error messages.
06:52:04 <phubuh_> oh. i haven't experienced it myself (real programmers don't get errors!)
06:52:08 <Darius> harsha123: -Nothing- is DOS based anymore.
06:52:09 <phubuh_> Igloo, ah, yes.
06:52:41 <Igloo> Having 2 different error messages is often useful. I'm not sure if one is generally better than the other or not.
06:52:42 <harsha123> hehehe okay.. got ya
06:53:40 <Darius> phubuh_: Sure real programmers make errors because real programmers can read a raw core file to debug.
06:54:20 <Darius> Though I'll admit, they don't get type errors.
06:54:27 <phubuh_> that's because unreal programmers tend to break things, and the real programmers have to fix them!
06:56:03 <Darius> What's a real programmer doing using code that he doesn't understand at the machine code level?  Let alone someone else's code.
06:57:29 <phubuh_> $$$
08:44:27 <esap> hmm.. how should I represent pullbacks in Haskell?
08:46:57 <ski> what is a pullback ?
08:47:26 <ski> (something in cat.theory, i know)
08:48:23 <esap> it's a concept from category theory. I think it's a generalization of the concept of product, where the elements of the product may overlap (for AxB, you have A -> D and B -> D such that the diagram commutes)
08:49:17 <ski> not D -> A,D -> B  ??
08:49:34 <esap> ski: no, that's the definition of product.
08:50:57 <ski> isn't is like  f : D -> A , g : D -> B |-  <f,g> : D -> AxB  ?
08:51:12 <esap> ski: yes, that's the product.
08:51:44 <ski> you said A -> D,B -> D earlier.  ???
08:51:52 <esap> ski: yes, that is for pullback.
08:53:28 <esap> ski: You have AxB -> A -> D  and AxB -> B -> D  in a pullback. The B->D and A->D, C->A, C->B are given beforehand, and the AxB->A and AxB->B and C->AxB are produced.
08:53:28 <ski> then what is the generalization/similarity with products ?  is it on a more abstract level ?  (natural transf. ? adjoint ? (i don't understand these yet))
08:54:19 <esap> ski: I think the similarity is that you give more constraints than in the product, but otherwise it's very much like the product.
08:55:08 <ski> esap : so why do we include D. it hasn't anything to do with what is produced, no ?
08:55:40 <ski> esap : hmm, so you have more constraints, including D ?
08:55:52 <esap> ski: yes it has, AxB is actually more like A x_D B.
08:56:19 <ski> esap : 'the D-pullback of A and B' ?
08:56:48 <esap> ski: well the usual saying is "the pullback of f : B->D and g:A->D', I guess.
08:57:09 <ski> esap : hmm, ok
08:57:54 <ski> esap : do you have some concrete (relative to cat.theory i.e.) example ?
08:59:02 <ski> esap : also, what is the corresponding things to unique existence of med. morph. for product ?
08:59:24 <esap> ski: well I guess if you have in Haskell something like \x -> (x+1,x-1), I guess that would suffice as a pullback [of \x -> x +1 and \x -> x-1 , because you can always find 'x' from both elements of the product.
08:59:25 <phubuh_> haha, concrete
08:59:53 <ski> esap : i.e. what is the constraints and fullfills ?
09:00:14 <ski> phubuh_ : fun intended :)
09:00:17 <esap> ski: it's the unique existence of the C -> AxB for each C->A and C->B such that A->D and B->D exist.
09:00:45 <emu> hilarity ensues
09:01:09 <ski> esap : in the category of programming types ?
09:01:36 <esap> ski: you mean my example in Haskell? yes.
09:01:43 <ski> esap : yes
09:02:21 <ski> esap : hmm
09:02:55 <esap> ski: oh and the diagram has to commute [i.e. C->A->D = C->B->D]
09:03:28 <ski> esap : oh, yes the morph.s should commute. in this case the function paths be the same  (i was thinking that just the type should be the same ..)
09:03:44 <ski> esap : yes :)
09:05:25 <ski> esap : would  \xs -> (length xs+1,length xs-1)  be a pullback of \n -> n+1 and \n -> n-1 ?
09:06:01 <esap> ski: I suppose not.
09:06:18 <ski> esap : hmm...   why not ?
09:06:33 <esap> ski: but hold on, I think I mixed C->A and A->D paths :-)
09:07:02 <ski> esap : i your head, or in your previous explanation ?
09:07:10 <esap> ski: in my previous explanation.
09:09:21 <ski> esap : what part should be changed ?
09:09:25 <esap> ski: The pullback of length : [a] -> Int and length : [b] -> Int   for f : C -> [a]   and g : C -> [b]  would be the least such h : C -> ([a],[b]) such that length(f(c)) = length(g(c)) for every c.
09:10:49 <ski> esap : wait, lemme think
09:11:00 <esap> and fst(h(c)) = f(c) and snd(h(c)) = g(c)
09:13:01 <ski> ok,hmm
09:13:34 <ski> was it the "it's the unique existence of the C -> AxB for ..." part that was wrong ?
09:13:53 <esap> ski: no, it was my example.
09:14:04 <ski> the haskell one ?
09:14:08 <esap> yes
09:14:31 <esap> Maybe I'm still not saying it clearly enough.
09:15:22 <ski> is it an object or morphism or diagram that is called a pullback ?
09:16:28 <esap> I think it's the diagram. There are things like "if there exists a pullback of f and g" and also "let C be a category with all pullbacks"...
09:17:20 <esap> But I think it's somewhat confused, sometimes I see the object A x_C B also called pullback.
09:17:37 <esap> A x_D B I mean.
09:17:52 <ski> yes, at least AxB is called a product of A and B, that i know
09:18:14 <ski> (i.e. the product is an object)
09:18:19 <esap> ski: Maybe you need to distinguish "pullback diagram" from the "pullback object".
09:18:32 <ski> perhaps :)
09:18:54 <esap> ski: where the pullback diagram is the AxB -> A -> D  and AxB -> B -> D ; whereas the pullback object is just the AxB part.
09:19:25 <esap> ski: Anyway, the pullback construct somehow defines the AxB object and the C->AxB arrow.
09:19:46 <ski> shoulnd't we have the C in the diagram, as well
09:20:19 <esap> ski: well yes, but often that is not drawn [it's assumed due to the pullback property]
09:20:42 <ski> esap : in my example attempt, C was meant to be [a], and A,B,D was meant to be Int
09:21:11 <ski> wait
09:22:33 <esap> ski: I guess the length example wouldn't do, because you have to have the "last" object AxB that satisfies the constraints (like in product, but the constraints are different)
09:22:55 <ski> hmm, yes, the implied/defined objects,arrows seems to often be omitted
09:23:16 <ski> judging from my dead-tree print-out of A Categorical Primer
09:23:44 * esap also learned everything from the categorical primer :-)
09:23:45 <ski> esap : what length example ? yours or mine ?
09:23:50 <esap> ski: yours.
09:24:02 <ski> esap : Chris Hillman ?
09:24:13 <esap> ski: yes. Hillman has many good papers.
09:25:10 <ski> esap : i found it only a couple of days ago. hadn't had time to actually start reading it properly yet, though
09:26:16 <esap> ski: the sheaf and topos parts are a bit heavy compared to the beginning, but I think otherwise it's a great paper.
09:27:17 <esap> ski: But all of it is very important and basic category theory stuff.
09:34:02 <ski> esap : hmm, still not sure what is bad in my ex.  hmm
09:40:18 <esap> ski: I think the reason is that it doesn't satisfy the universal property.
09:40:25 <esap> ski: or UMP.
09:40:43 <ski> what is the M ?
09:41:19 <esap> "universal mapping property". See the categorical primer, page 15.
09:41:34 <ski> k
09:41:56 <esap> the definition of product is one example of the use of the UMP.
09:42:34 <ski> yes, hmm
09:43:07 <ski> hmmm, aha ?!
09:43:38 <ski> on p. 19
09:43:54 <esap> heh, yes.
09:44:33 <ski> they have ^Z -> X -> Z , ^Z -> Y -> Z , yes ?
09:44:54 <esap> yes.
09:45:35 <ski> and below a mod. diagram, with ^Z replaced with W, yes ?
09:45:59 <esap> yes, W can be anything.
09:46:10 <esap> as long as it satisfies the diagram.
09:46:36 <esap> and you have an UNIQUE arrow W->^Z for each choice of W.
09:46:42 <ski> then there should be an unique arrow W -> ^Z ?  is this the UMP  ?
09:47:08 <esap> the ^Z in that then satisfies UMP.
09:47:52 <esap> ^Z is the object being defined.
09:48:07 <ski> for e.g. products i had seen a composite diagram :  X -> A , X -> B , X -> AxB , AxB -> A , AxB -> B
09:49:00 <ski> so i sort of wondered why, for pullbacks, we didn't have a W -> Z   , or something
09:49:26 <esap> yes. You can also draw such composite thing from the pullback, then oyu have both W and ^Z in the same diagram but X,Y and Z are the same, and you have arrow W->^Z.
09:50:11 <esap> The UMP is the important thing in the definition of the pullback.
09:51:19 <ski> but the more general way, with respect to general UMP, is to have a diagram with one special marked object, and then make a shadow object above it (in 3D), with arrows going to the same places as the special obj.  is this right ?
09:51:19 <esap> ski: in the diagram on pg. 19 of categorical primer, think of drawing ^Z between X and Y in the lower picture.
09:51:23 <phubuh_> yeah, you gotta have the UMPH
09:51:55 <ski> (and mirrored, for co-things, of course)
09:52:43 <esap> ski: for an arbitrary choice of "shadow object", yes I guess.
09:52:52 <ski> i was thinking of drawing the W (shadow) (3D-)above the ^Z (marked)
09:53:30 <ski> UMPH ?  H ?
09:53:48 <phubuh_> never mind :)
09:54:08 <esap> ski: The idea is that when you bring W somehow closer to Z while retaining the diagram property, you eventually reach the "last" object (^Z)
09:54:57 <ski> hah, now the figures on p. 25 seems to make more sense
09:55:02 <esap> ski: and this "bring W somehow closer" is formalized by considering all choices of W.
09:55:48 <ski> esap : but should there really be filled circles above the unfilled, in 'final' ?
09:55:58 <ski> esap : (p. 25)
09:56:32 <esap> ski: yes, I think there should be.
09:56:53 <esap> ski: the idea is that from "every" object there is an arrow to the final object.
09:58:05 <ski> so the filled ones there are examples of non-last obj (w. resp. to final). as W was on p. 19 ?
09:59:24 <esap> ski: well yes, but in the case of 'final', the distinction between "arbitrarily chosen objects" and "given object" is not that visible.
09:59:34 <Darius> Yes, the diagrams aren't completely consistent.
10:00:07 <ski> so the 'no-lasts' are explicit for final, but not for the others ?
10:00:12 <esap> ski: the black things try to describe given objects, but I guess for the 'final' case, there is no such given objects, only arbitrarily chosen ones.
10:00:14 <ski> non-lasts
10:00:45 <ski> yes.
10:01:00 <ski> just what i thought ;)
10:01:10 <Darius> If the diagrams were consistent, then final/initial would just be an open dot; however, that wouldn't be very intuitive.
10:02:18 <ski> why not, if it's o'kay to imply the non-lasts in the others, why not there ?  i think i would be less puzzled by that
10:02:33 <Darius> The equivalent in the pullback diagram, say, to the filled dots in the 'final' diagram, would be the W from before and would have an arrow going to the open dot.
10:02:57 <ski> yes
10:03:05 <Darius> (as well as, technically, arrows going to the other dots)
10:03:18 <ski> and to the objects, pointed at by the open dot
10:03:21 <ski> yes
10:03:46 <ski> but we should really have many W's then, no ?
10:04:13 <Darius> Yes
10:04:17 <ski> ok
10:13:34 <esap> So what do you think, can I represent pullback using  data Pullback b c a = Pullback (b a) (c a)  together with function: pullback :: (a -> b a) -> (a -> c a) -> a -> Pullback b c a  and pullback_fst :: Pullback b c a -> b a   and pullback_snd :: Pullback b c a -> c a ?
10:13:42 <ski> um, eeh : on p. 19, it says "Exercise: if X <-mu- Z -nu-> Y ...". shouldn't the arrows be reversed ?
10:14:25 <esap> ski: Yes, the pullback part of the description has many problems.
10:14:46 <ski> i mean, it is a typo, right ?
10:14:53 <esap> I guess yes.
10:15:14 <esap> as I think are the constraints just below the diagram with W.
10:16:10 <ski> hmm, yes, that seems mad
10:17:08 <ski> ^mu starts in ^Z but alpha.ypsilon starts in W
10:18:41 <ski> should be  alpha = ^nu.ypsilon  and beta = ^mu.ypsilon  i think
10:19:39 <ski> do you agree ?
10:19:42 <esap> right.
10:19:45 <Darius> yeah, that's what I'd say
10:21:29 <ski> esap : hmm, why you use b,c :: * -> * ?
10:21:36 * ski not understand
10:21:41 <ski> good
10:22:34 <esap> ski: because that was the only way I could encode in type the constraint that you must have a common structure in both.
10:23:36 <ski> i'm trying to sort out what parts of your def. corresponds to what part of the diagram ..
10:24:06 <ski> the Pullback b c a is the pullback object, i guess
10:24:09 <esap> ski: 'b a' and 'c a' correspond to X and Y in pg. 19.
10:24:22 <esap> ski: 'a' corresponds to Z.
10:24:23 <ski> the a is the W ?
10:24:29 <ski> ah, ok
10:25:51 <ski> that can't be right, no ?  the a is the ^Z or the W, right ?
10:26:25 <ski> otherwise i don't understand how the arrow's are mapped
10:27:07 <esap> ski: oh actually, I've used 'a' for both purposes :-( On the definition of 'b a', a corresponds to Z, but the function 'pullback' actually uses it for both purposes. Hmm...
10:27:45 <ski> definition of 'b a' ?
10:28:07 <esap> data Pullback b c a = Pullback (b a) (c a), 'b a' and 'c a' here.
10:28:48 <ski> ok
10:28:54 <esap> So I should rewrite this. Hold on.
10:29:19 <ski> so b,c gives X,Y from Z, right ?
10:30:27 <esap> data Pullback x y z = Pullback (x z) (y z)  together with function: pullback :: (w -> x a) -> (w -> y a) -> w -> Pullback x y a  and pullback_fst :: Pullback x y z -> x z   and pullback_snd :: Pullback x y z -> y z ?
10:30:40 <ski> yes
10:32:15 <ski> isn't it better, then, if you rename the a's in pullback's type to z as well ?
10:32:42 <esap> yes you're right.
10:33:04 <ski> hmm, how do we assure the commutability ?
10:33:08 <Darius> Instantiating for a product and for an equalizer seems to work
10:33:32 <ski> Darius : what ?  how ?
10:34:39 <ski> Darius : unifying z with truth (absurd ?)  resp. unifying x with y ?
10:35:50 <Darius> Yes, Pullback a b () is isomorphic to (a,b)
10:35:57 <esap> ski: I think the only way to ensure commutability is when you define the arguments to 'pullback', then you can use 'let x = ... in ...' to do it.
10:36:02 <ski> Darius : ok
10:36:34 <esap> ski: I mean, of course, let z = ... in ...   :-)
10:36:46 <Darius> and Pullback x x y should be an equalizer
10:37:09 <ski> Darius : ok   (i.e. this seems plausible)
10:37:30 <ski> esap : hmm
10:38:59 <ski> esap : so the user of pullback, has to ensure some property
10:39:30 <esap> ski: yes. I don't know how to prevent that. How do you ensure in types that the user has to use 'let'? :-)
10:39:35 <ski> esap : i'm not seeing exactly what you mean by the let-in
10:40:55 <esap> I mean you would use the 'pullback' function something like    my_obj :: Pullback IO IO Int,  my_obj = let x = 10 in (return x,return x)
10:41:08 <ski> esap : perhaps, 'cuz i've forgotten (again) what the commutability means for pullbacks..  (hey, i haven't looked at them, until now)
10:41:48 <esap> oh my example is not correct.
10:41:55 <ski> (i.e. at pullbacks)
10:42:28 <ski> no prob, haven't understood it (and the point) yet  ;)
10:43:36 <esap> oh actually, I'm not sure the let thing is needed, the implementation of 'pullback' function does it already.
10:43:41 <ski> hmm, should x and y be functors ?  just a thought.
10:44:05 <esap> pullback :: (w -> x z) -> (w -> y z) -> w -> Pullback x y z   pullback f g x = Pullback (f x) (g x)
10:44:36 <ski> no fair, i just just going to infer the def. of pullback from it's type :(
10:44:43 <ski> s/just/was/
10:44:55 * esap is not sure this works.
10:45:08 <Darius> So, using the earlier diagram, where are mu and nu (not the hatted versions)
10:45:41 <ski> mu :: x z -> z  ,  nu :: y z -> z  i think
10:45:44 <esap> oh no, it doesn't do it properly. You still need the let.
10:45:59 <ecraven> zj
10:46:25 <ski> hm
10:47:03 <ski> z is nowhere, it seems
10:48:17 <ski> should we really use mu,nu ?  isn't it sufficient to know that they exist (satisfying commutability) ?  (may be totally wrong here)
10:48:58 <esap> ski: mu and nu should be inputs to one of the operation, I guess.
10:49:22 <Darius> Well, in the case of an equalizer, mu and nu are the functions you are equalizing.
10:49:27 <ski> what are some motivating examples of pullback (as cart.prod. is one for prod.) ?
10:50:03 <esap> What if I do  data Pullback x y z = Pullback (x z) (y z) (Either (x z) (y z) -> z)
10:50:18 <Darius> { (x,y) | mu(x) == nu(y) } is the set theoretic pullback as mentioned.
10:50:39 <ski> Darius : well, i have even less intuituion about equalizers (i.e. nada) right now, than i have for pullbacks
10:50:49 <ski> yes
10:51:07 <ski> but what's it good for ?  :)
10:51:35 <esap> ski: equalizer is basically same as unification.
10:51:40 <Darius> Equalizers are pretty straightforward in Set
10:52:04 <ski> esap : should it be Either ? not (,) ?  not sure at all
10:52:33 <esap> ski: the idea is that the function represents both mu and nu.
10:52:54 <Darius> yeah, I was thinking of that earlier.
10:53:10 <ski> so mu and nu is e.g. substitutions, that when applied to x and y, makes them equal ?
10:53:37 <Darius> Wondering if pullbacks could be thought of as equalizers of sums.
10:53:41 <ski> esap : sorry, brain lapse
10:54:58 <esap> darius: I don't know. My current intuition is just a product whose elements can overlap.
10:55:48 * ski is looking up equalizers on p. 17
10:56:38 <Darius> Stealing an example: let's say mu = \(x,y) -> x^2+y^2 and nu = \(x,y) -> 1; X=Y=(Double,Double) and Z=Double, their equalizer is the set { (x,y) | x^2+y^2==1 } (i.e. the points on the unit circle)
10:57:30 <Darius> The equalizer is the last/largest thing that can be fed into mu & nu to get an equivalent result.
10:57:33 <ski> equalizer : what is the arrow from 'open circle' to the middle circle good for ?
10:58:18 <Darius> The equalizer is just an object that represents the solution to equating mu and nu.
10:58:44 <Darius> (plus a morphism that takes that object to the input type of mu and nu)
10:58:59 <ski> don't understand
11:01:03 <ski> Darius : in your last example : is the arrow from the 'equalizer object' to X=Y id ?
11:01:24 <ski> (arrows, for pullback)
11:01:55 <Darius> No the arrow from the equalizer object is an inclusion into (Double,Double), the Equalizer object would be something with a type like UnitCircle.
11:02:33 <Darius> It's probably better to think set theory rather than Haskell here
11:03:00 <ski> but could be implemented with \x -> x  if UnitCircle is a subtype of (Double,Double) ?
11:03:24 <Darius> The equalizer is a set that holds all the points that make mu and nu equal (in this case the unit circle since all the point (x,y) that make x^2+y^2=1 hold are on the unit circle)
11:03:34 <Darius> ski: Yes
11:03:39 <ski> ok
11:03:40 <Darius> It's just an inclusion in this case.
11:06:34 <ski> esap : so what we should ensure is that x z + y z -> z returns the same z, for a given Pullback x y z object ?
11:07:30 <esap> ski: it's hard, some stuff with let, I guess. But I'm still thinking about it.
11:07:39 <ski> should we change the type of some of the existing primitives ?  should we add some more ?    (i.e. to accomodate for the addition of the x z + y z -> z function)
11:07:53 <Darius> You can't really do it at the object level
11:07:54 <ski> (some more primitives, i.e.)
11:08:34 <Darius> I believe you'd need dependent types.
11:09:24 <ski> ty.classes w/ fun.dep. i'nnt 'nuf ?   ( :) )
11:10:06 <Lor> Using fundeps to simulate dependent types is a hack similar in abominability to all the template metaprogramming stuff in c++.
11:10:46 <Lor> Especially since dependent types are a much simpler concept than type classes.
11:11:03 <Darius> ski: that would be doing it at the type level
11:12:13 <esap> lor: I wonder why there aren't many languages that would support dependent types properly? Are they that badly known?
11:12:36 <esap> lor: for example, last time I looked at cayenne, it didn't support case in dependent types.
11:12:38 <Lor> I guess they wreak havoc to type inference.
11:12:46 <Darius> Most languages do not have undecidable type systems
11:13:05 <ski> Darius : didn't you say we prop. can't ensure it on the obj. level ?  i.e. if poss. it should be done on type lev.
11:13:24 <Lor> And when you do have a complete dependently typed system like in theorem provers, then programming becomes rather tedious.
11:13:45 <Lor> You don't want to write real programs in Coq.
11:13:46 <Darius> You could dynamically ensure it on the object level.
11:14:00 <esap> lor: I would think that would be very good thing. Who wouldn't want a programming language that prevented you from breaking your program? :-)
11:14:27 <dennisb> some have a typesystem that has an exponential complexity (like haskell)
11:14:30 <Darius> If the specification is just as hard as programming, what have you gained?
11:14:49 <esap> darius: correctness?
11:15:18 <Lor> Is it easier to write a correct specification than a correct program?
11:15:27 <Darius> What good is a program that meets an incorrect specification?
11:15:33 <ski> 'twould perhaps be interesting/good (?) to have laws in an FP-lang, the type of the law is what it says, the impl. is the proof.  i'm mostly thinking of equiv. proofs here.  (there's some synt.sugar for that in cayenne IIRC)
11:15:38 <esap> that is, once you get your specification and program ready, it's sure that the program and the specification match.
11:16:08 <Darius> Then call the programming language a specification language and you are done.
11:16:47 <esap> darius: At least you can look at the specification and see where the problem is.
11:17:01 <esap> darius: I'd still say the specification is shorter than the program itself.
11:17:05 <ski> Darius : yes, i know. but i was thinking statically ...
11:18:04 <dennisb> esap: i've seen plenty of cases where the specification is much longer then the program
11:18:06 <esap> The problem you'd normally see is that you cannot write a correct specification. I'd like to even be able to write the correct specification, and then try to implement it.
11:18:10 <ski> esap : correctness is correctness of impl. respective/relative to spec., no ?
11:19:05 <esap> I mean, even if you knew what you want, you have no way of expressing that.
11:20:12 * ski has now caught up with the flooding ;)
11:20:16 <esap> ski: yes. I think you can't demand correctness relative to some vague idea of what you want.
11:20:28 <ski> mm
11:21:03 <Darius> Yes, but you need a specification for the specification, how do you know your specification means what you think?
11:21:52 <esap> darius; I think this is how type systems help. If you have to write both the program and its type, you are likely to get some problems if you don't really understand what you want.
11:22:14 <esap> darius: which causes that you must think about the issue.
11:22:29 <ski> hopefully the spec. is written differently than the impl. so it increases chances of finding inconsistencies
11:22:46 <esap> ski: right, that is why types and programs are different.
11:23:22 <Lor> There are many type systems where types and programs look almost exactly the same..
11:23:34 <ski> i guessed so
11:23:34 <dennisb> it's also that for one type/specification you can write many different implementations
11:23:37 * esap is designing one where they look the same, but mean different things.
11:23:56 <Lor> What's it for?
11:23:58 <ski> esap : what ?  :)
11:25:32 <ski> (interpolating from source2source transf. of code, where the initcode could be considered a spec. and the finalcode an impl.)
11:26:02 <Lor> This may be relevant, or then not: http://flint.cs.yale.edu/flint/publications/tscb.html
11:26:29 <Lor> (Never mind the abstract, the actual system in the paper isn't very "binary")
11:27:05 <ski> Lor : is it related to typed assembly langs, like TALx86 ?
11:27:19 <esap> lor: hmm.. that looks like an interesting paper 
11:27:35 <Lor> It's an example of a system where the kinds have been "shifted one level up".
11:27:43 <Lor> ski, not directly.
11:27:54 <ski> Lor : huh ?
11:28:20 <Lor> I mean, they only present a system for encoding proofs of properties of programs, but they only show a term-level lambda-based language.
11:28:36 <Lor> It can be adapted to other languages, of course, but in the paper they don't deal with assembly.
11:28:56 <esap> that's an interesting approach.
11:29:02 <ski> Lor : i mean, what you mean with shifted kinds ?
11:29:45 <esap> What I thought was that I should provide all levels, so that the programmer could write specifications at different levels, and the lowest would be interpreted as the program.
11:29:54 <Lor> Ah. Essentially, the types and terms are almost isomorphic: the type says "this term acts like this".
11:30:02 <Lor> The "conventional" types are really kinds here.
11:30:12 <Lor> Sorry, I meant shifted _sorts_ in general.
11:31:06 <ski> is there univ. quant. e.g. in the specs. ?
11:32:11 <esap> It seems they define inductive kinds. Are those consistent?
11:32:32 <Lor> ski, they write it as \Pi, but essentially yes.
11:32:46 <ski> ok
11:33:00 <Lor> esap, given the positiveness restrictions, I think they are.
11:33:22 <ski> esap : which page ?
11:33:31 <esap> ski: 4
11:34:56 <ski> what is omega ?  * ?  "subclassifying object" ?
11:35:49 <ski> seems like * i think
11:36:08 <ski> yes
11:37:14 * esap wonders what would happen if you'd add the concept of adjunction to that language.
11:37:32 * ski has no idea
11:40:33 <ski> esap : you could perhaps make a type class of pullbacks ..  :)
11:40:51 <esap> ski: ehehe, maybe :-)
11:43:07 <ski> esap : 'cuz others seems to have nothing against adding extra unchecked constraints into common type-classes  ;)
11:43:45 <esap> ski: I've done it many times, accidentally.
11:45:44 * esap thinks adjunctions properly express the concept of "up-to-isomorphism".
11:46:51 <Lor> Did you know that you can express real type equality in haskell?
11:47:17 <esap> lor: how?
11:47:28 <Darius> You can get close
11:47:32 <Lor> Cheney & Hinze's HW2002 paper shows a neat trick for expressing leibniz equality.
11:47:39 <Darius> Haskell isn't a consistent logic
11:48:23 <Lor> Well, modulo bottom, of course.
11:48:26 <Darius> hhat may not matter here, though
11:49:48 <esap> this one? http://citeseer.nj.nec.com/cheney02lightweight.html
11:49:48 <Lor> newtype TEq a b = Eq (forall x . x a -> x b)
11:50:11 <Darius> esap: yes
11:50:28 <Lor> eq_refl a = Eq (\x -> x)
11:50:46 <esap> That's a neat trick.
11:52:28 <Lor> Oops, that 'a' is pretty vacuous.
11:52:35 <esap> Hmm.. would it be better to have: newtype TEq a b = Eq (forall x y. (Adjunction x y) => x a -> y b), hmm.. have to think about this thing.
11:52:42 <Darius> Yeah, I just noticed that.
11:53:18 * Darius retroactively adds "Lor: "
11:57:28 <ski> Lor : A Lightweight Implementation of Generics and Dynamics ?
11:58:03 * ski just answered yes to myself
12:07:14 <esap> What is the relationship between function application and type equivalence?
12:07:45 <Lor> Uh, what?
12:07:57 <Lor> You mean regarding that leibniz trick?
12:08:01 <esap> yes.
12:08:20 <Lor> With a Teq a b you can convert anything of type Foo a into a Foo b.
12:08:31 <Lor> So you get type substitutions.
12:08:39 <Darius> It's type application
12:08:59 <Lor> Yes, but you apply the actual value of type Teq a b.
12:09:26 <esap> ok, because I have the following Haskell type for function application: apply :: (Adjunction path space) => space bot -> path top -> bot ; apply = rightAdjunct . const
12:10:03 <esap> Which looks too much like the inverse of the type equivalence thing [but not quite]
12:10:04 <Lor> Are we supposed to understand what space and path are?
12:10:33 <esap> yes, 'space' is a generalization of an arbitrary function, and path is a generalization of an arbitrary argument.
12:10:34 <Darius> Lor: yes, but it's the type application that would matter.  There an analog at the value level with function application and value equivalence.
12:10:58 <Lor> Uh?
12:11:15 <Lor> No no, a value of type Teq a b is a proof that _types_ a and b are equivalent.
12:11:46 <Lor> You'd need dependent types to prove the equalities of _values_.
12:11:56 <Darius> Lor: I know, but (though not expressible in Haskell) the same thing would work for values
12:12:13 <Darius> In which case it would be function application and value equality
12:12:54 <Lor> Inductive eq [A : Set; x : A]  : A->Prop :=  refl_equal : x=x
12:13:16 <Lor> "x=x" is here syntactic sugar for (eq A x x)
12:14:03 <Lor> (That's from coq)
12:14:21 <Darius> The 'Prop' was a tip-off
12:20:37 <esap> rightAdjunct :: (Adjunction path space) => (top -> space bot) -> path top -> bot
12:21:16 * esap might have the names swapped though :-)
12:38:28 <palomer> is there a gui builder for haskell?
12:43:29 <Heffalump> 'lo
12:43:40 <ski> hi
12:48:43 <ski> hi jdrake
13:09:45 * shapr boings
13:09:56 <shapr> kosmikus: there's two of you
13:10:45 <Heffalump> he's doing the quantum kosmikus thing again
13:10:53 <shapr> wow, nifty
13:11:26 * Heffalump wonders if anyone here submitted a paper to POPL.
13:11:30 <kosmikus> there's often two of me in here
13:11:41 <shapr> you can't know both the position and wakefulness of a kosmikus at the same time?
13:12:03 <Heffalump> kosmikus: and you're frequently both here and not here?
13:12:11 <kosmikus> most people don't even know one of the two :)
13:12:18 <shapr> heh
13:12:20 <kosmikus> Heffalump: sort of ..
13:12:23 <Smerdyakov> Heffalump, no, but I proof-read one that got in. ;)
13:12:41 <Heffalump> Smerdyakov: don't suppose you know if they got the referees' reports yet?
13:12:50 <Smerdyakov> Heffalump, hadn't as of Tuesday.
13:12:56 <Heffalump> right
13:13:08 <Heffalump> the notification we got on Friday said "in a few days"
13:13:17 <Heffalump> kosmikus: well, everyone here knows you're awake :-)
13:13:31 <shapr> when I start lambdabot locally, I get Exception: Prelude.head: empty list
13:13:32 <kosmikus> you'd be surprised how much I can talk while asleep
13:13:38 <shapr> I've forgotten how to fix that
13:13:40 <Heffalump> and I further surmise that you're at home - of course, I have no idea where that is, beyond "somewhere in or near Utrecht"
13:13:42 <kosmikus> maybe I even could type, who knows
13:13:50 <Heffalump> shapr: errm, have you changed anything lately?
13:14:06 <Smerdyakov> shapr, always use a pattern match that gives a useful error message for an empty list, instead of head :P
13:14:13 <shapr> Smerdyakov: hah, that would be too easy
13:14:23 <shapr> Smerdyakov: it's much more fun to find every place that lambdabot uses Prelude.head
13:14:52 <shapr> Heffalump: no, haven't changed anything that I know of, and the same sources build and run on raven (www.ScannedInAvian.org)
13:14:54 <Heffalump> Smerdyakov: was the paper that got in on anything interesting, anyway?
13:15:15 <Heffalump> shapr: interesting. Can you connect to the irc server it's trying to use yourself from the machine that it's breaking on?
13:15:30 <shapr> yes, I am connected.
13:15:45 <Heffalump> shapr: odd.
13:15:51 <Smerdyakov> Heffalump, yeah. Are you familiar with Craig's Interpolant Theorem?
13:15:58 <Heffalump> Smerdyakov: nope
13:16:00 <shapr> I think I've had this problem before, and I've forgotten the fix.
13:16:38 * shapr tries the 'comment out everything, see if it works' approach
13:16:49 <Smerdyakov> Heffalump, well, it's from model theory. It said that is the formula (A AND B) is unsatisfiable, then there is some C such that (A IMPLIES C) and (C AND B) is unsatisfiable, and C uses no variables but those found in both A and B.
13:17:21 <Smerdyakov> Heffalump, they use that to produce small sets of predicates to be tracked in a counterexample-driven predicate abstraction model checker.
13:17:54 <Heffalump> hmm, right
13:17:54 <Smerdyakov> Heffalump, the theorem (and a constructive implementation of it) can give the predicates relevant at each program point.
13:19:07 <Smerdyakov> Did I explain it well enough? :)
13:19:16 <Heffalump> I don't entirely see the point :-)
13:19:27 <Heffalump> but I guess I'll hear the talk at POPL anyway :-)
13:19:45 <shapr> oh, what's the haskell-utils package?
13:19:48 * shapr looks
13:20:09 <Smerdyakov> Heffalump, well, the model checker works by abstract interpretation of a program, keeping track of which predicates are true at each point.
13:20:22 <Smerdyakov> Heffalump, it's a big efficiency win to limit the predicates that need to be tracked.
13:21:30 <Igloo> It hopefully allows hmake to work sensibly. You'll want to look at the source to see anything interesting.
13:21:50 <Smerdyakov> Heffalump, Craig's theorem in an intuitive sense captures the most local predicates that are relevant on a per program point basis.
13:22:09 <Heffalump> right.
13:22:33 <Smerdyakov> Do you see the point now? :\
13:22:42 <Heffalump> errm, sort of :-)
13:22:56 <Smerdyakov> It's just a way of keeping the abstract state space size down. :D
13:23:03 <Heffalump> I got that far.
13:23:10 <Heffalump> I'll listen to the talk.
13:27:05 <kosmikus> Heffalump: you didn't sumbit anything?
13:27:25 <Heffalump> to POPL?
13:27:30 <shapr> Lunar^: nice plan!
13:27:44 <SyntaxPolice> hey shapr!
13:28:16 <shapr> hiya SyntaxPolice 
13:31:39 <kosmikus> Heffalump: yes
13:31:50 <kosmikus> SyntaxPolice: hi
13:31:58 <Heffalump> kosmikus: no, we did, and we got in, which was nice :-)
13:32:19 <shapr> gutenabend kosmikus|away
13:32:22 <kosmikus> ah, congratulations
13:32:28 <SyntaxPolice> yoyo kosmikus
13:32:38 <kosmikus> kosmikus|away is away ...
13:32:47 <kosmikus> ... he's here
13:32:48 <shapr> heh
13:32:51 <shapr> ok :-)
13:34:00 <kosmikus> I'm a bit confused -- why do you know who got in before the referee reports are out?
13:34:27 <Heffalump> they sent notifications out early, saying "referee reports to follow in a few days" (paraphrase)
13:34:38 <kosmikus> ah okay
13:34:50 <kosmikus> what's your paper about
13:34:53 <Heffalump> the notifications were due last Monday, but they actually came the previous Friday - but still no referee reports
13:35:00 <Heffalump> "Incremental execution of transformation specifications"
13:36:00 <Heffalump> Basically, we have this declarative language for specifying side conditions for imperative program transformations (things like "you can propagate this constant value if the variable it's in doesn't change inbetween", and an incremental algorithm for executing these specifications after you make a change to the program (e.g. from an edit, or from applying a transformation)
13:36:36 <kosmikus> greetings to the people who were at ICFP from Clara, BTW -- Debian is up and running on her computer now, no more SuSE :)
13:36:56 <Igloo> Cool  :-)
13:36:57 <shapr> wow
13:36:58 * Igloo waves ot Clara
13:37:00 <Heffalump> goodgood :-)
13:37:01 <shapr> hi Clara!
13:37:03 * Heffalump returns the greetings
13:37:18 <Heffalump> (is she in Muenster or Utrecht?)
13:37:29 <kosmikus> in Utrecht atm
13:37:53 <kosmikus> but she forgot to backup her nethack save files :(
13:37:59 <shapr> oh :-(
13:38:01 <shapr> the horror :-(
13:38:12 <kosmikus> yes, indeed
13:38:18 <shapr> does she use hearse?
13:38:21 <Heffalump> I bet she was on level 1 with the Amulet of Yendor too, right?
13:38:27 <shapr> heh, that would suck
13:38:49 <kosmikus> just at the stairs ... 
13:38:59 <shapr> I keep meaning to try nethack-el (since nethack is impossible with dvorak) but I'm afraid I'll never work again.
13:39:03 <shapr> hi lektu 
13:39:18 <Lor> No it isn't.
13:39:23 <lektu> Hi
13:39:27 <Lor> You just have to use the numpad.
13:39:32 <kosmikus> what's nethack-el? rewritten in Emacs-Lisp?
13:39:32 <shapr> I don't have a numpad.
13:39:39 <shapr> nah, it's just an elisp wrapper
13:39:41 <shapr> it's pretty cute
13:39:47 <Lor> Ah. A laptop? Or happy hacking?
13:39:49 <shapr> lektu: how's cod?
13:39:57 <shapr> Lor: neither, it's a kinesis contoured
13:39:59 <lektu> Nethack Haskell hackers? :-)
13:40:04 <Lor> Wow.
13:40:09 <lektu> Cod?
13:40:13 <Lor> Pricy toy, that.
13:40:18 <shapr> Lor: I have two.
13:40:34 <shapr> lektu: we speak and read fluent typo here :-)
13:40:47 <shapr> I'm a strong proponent of the kinesis contoured keyboard.
13:40:50 <kosmikus> what? two amulets of yendor? I had at least 5 once ;)
13:40:58 <shapr> no, the keyboard :-P
13:41:09 <shapr> http://www.kinesis-ergo.com/images/elan.jpg
13:41:22 <lektu> shapr: I'm not a native (English) speaker, so I didn't catch the bit about "cod"... :(
13:41:31 <shapr> lektu: oh, what's your native language?
13:41:44 <lektu> kosmikus: "fake" AoY, I suppose.
13:42:06 <lektu> shapr: Spanish.
13:42:15 <shapr> lektu: habla espa√±ol?
13:42:20 <shapr> ok, a bit late
13:42:27 <lektu> shapr: SÌ, mejor que inglÈs :)
13:42:42 <shapr> hm, I have utf-8 turned on, I missed all the spiffy letters
13:42:54 <shapr> anyways, I don't speak spanish ;-)
13:42:58 <lektu> Sorry
13:43:05 <kosmikus> lektu: WHAT? there are fake amulets??? ;)
13:43:17 <lektu> No problem, I can read/write english quite reasonably.
13:43:19 <shapr> lektu: I'd like to speak spanish one day, it's a nice language.
13:43:48 <lektu> kosmikus: Sure. In fact, most of them are fakes. Getting the real one is *hard*. I've been playing Nethack on and off since 1990 and I've never had one on my hands.
13:43:56 <shapr> Lor: I want one of the new models: http://www.kinesis-ergo.com/images/500-blk.jpg
13:44:02 <shapr> they look so cool
13:44:15 <shapr> I actually beat nethack in 1989 sometime
13:44:18 <kosmikus> lektu: you saw the ;), did you?
13:44:31 <lektu> shapr: Yeah, it is. 
13:44:48 <lektu> kosmikus: No, I didn't :) Silly me. Anyway, Nethack is great.
13:44:55 <kosmikus> I have to admit, my last ascension was also a long time before 3.0 came out, and I think it was much easier back then
13:45:09 <shapr> when did 3.0 come out?
13:45:15 <lektu> I've never ascended. I'm a hurry player.
13:45:44 <shapr> in my opinion, the easiest way to get powerful is to find an equally aligned altar and sacrifice stuff till you get a good weapon
13:45:55 <shapr> or polymorph your dog into a dragon and get goodies
13:46:02 <lektu> 3.0? I don't know, but 3.2.2 is from 1996, so 3.0 I'd say perhaps 1991 or 1992.
13:47:02 <shapr> lektu: so, are you a Haskell programmer?
13:47:07 <shapr> I think I may have asked you this before..
13:47:10 <lektu> I'm a Haskell beginner.
13:47:19 <shapr> ah, how far have you gotten?
13:47:24 <lektu> (No, I don't think so; it's only the second/third time I'm here)
13:47:26 <shapr> have you written a lambdabot plugin? ;-)
13:47:37 <lektu> shapr: No :)
13:47:37 <shapr> lektu: I usually pick on people the first time they show up
13:48:12 <lektu> I've been a programmer for quite a few years, unfortunately with "lesser" languages (mostly C, C++, and Perl)
13:48:38 <lektu> But I do like functional (or alike) languages. Not only Haskell, but Scheme, Common Lisp...
13:49:09 <lektu> shapr: Still, I think I didn't talk with anyone last time.
13:49:22 <shapr> maybe so... maybe I was working ;-)
13:49:27 <lektu> :)
13:49:53 <shapr> do you have any Haskell questions?
13:50:22 <shapr> have you reached green belt yet?
13:50:34 <lektu> No, not exactly. I'm getting my brain around monads, like any newbie. Not that I don't understand what they are or what they are usefull for...
13:50:34 <phubuh_> valkyries are particularly easy, since they're guaranteed mjollnir as first gift
13:50:54 <lektu> The thing is, I'm not used yet to think functional.
13:50:56 <phubuh_> lektu, when you do understand them, you'll curse because everyone makes them out to be so hard.
13:51:03 <phubuh_> when they're actually very simple.
13:51:07 <shapr> lektu: the monads tutorial in the topic is good
13:51:41 <lektu> Yeah, I know they're not hard. Is just... It's not evident when to use a monad. Not IO, because if you need IO, you need the IO monad, but other monads.
13:51:49 <phubuh_> ah
13:52:05 <lektu> Yeah, I've read one or two tutorials.
13:52:49 <phubuh_> when you have state being passed around a lot inconveniently, basically
13:53:31 <shapr> hej Marvin-- 
13:53:37 <Marvin--> hello from Germany
13:53:37 <lektu> I've seen a couple examples which used mapM/mapM_ and foldM/foldM_, for example.
13:53:37 <shapr> you're in .de !
13:53:51 <lektu> And I thought: nice, but I would never had thought of using that...
13:54:08 <lektu> I suppose is just being a beginner :)
13:54:19 <phubuh_> i'm probably in your position as well
13:54:54 <Marvin--> We're having a debian-installer work camp
13:55:00 <lektu> phubuh_: What I'm doing is trying to *use* Haskell. I had a program to compute some histograms (in Perl), and I did a Haskell version of it.
13:55:01 <Marvin--> though tonight we've just had beer so far
13:55:59 <lektu> (Pretty slow, but I'm not used to optimizing with GHC: fully polymorphic functions, not a single unboxed datum in sight, etc. :)
13:57:01 <shapr> lektu: I wrote a simple bayesian spam filter in Haskell
13:57:12 <shapr> histograms are very easy with FiniteMaps
13:57:23 <shapr> Marvin--: I want to install Debian on a new box, what's the best way?
13:57:40 <lektu> The biggest problem I'm having with Haskell is lack of tutorials. Yeah, there are quite a few tutorials in monads, but not ones to start doing... let's say "useful programs".
13:57:41 <Marvin--> a woody netinst CD perhaps?
13:57:57 <lektu> shapr: yeah, I used FiniteMaps.
13:58:19 <shapr> lektu: have you looked at the hlibs source repository?
13:58:29 <lektu> shapr: Where's located?
13:58:51 <lektu> AFAICS, libraries are very poorly documented, too.
13:59:14 <shapr> lektu: if you have darcs, 'darcs get --verbose http://www.ScannedInAvian.org/repos/hlibs'
13:59:15 <Marvin--> heh, I got a mail from Peter Simons
13:59:22 <Marvin--> he asked "Do you still maintain HWS?"
13:59:24 <shapr> heh
13:59:27 <lektu> (Anyway, I've bought Haskell School of Expression in Amazon, I hope it'll arrive any week now :)
13:59:36 <Marvin--> I replied "I didn't know I ever maintained it"
13:59:46 <lektu> shapr: I don't know what darcs is.
14:00:18 <shapr> http://www.abridgegame.org/darcs/
14:01:30 <lektu> shapr: Ah, I understand. I'm on Windows, though. Would it work? The page says "tested on Linux and MacOS X".
14:03:23 <tic> Isn't area pi*r^2?
14:04:06 <lektu> shapr: My God, someone wrote a brainfuck interpreter in Haskell? :-)
14:04:17 <kosmikus> shapr: that was quite hard to find out ... but Nethack 3.0 seems to be from 1989
14:04:37 <lektu> What's next, befunge 98?
14:04:54 <lektu> kosmikus: even older than I thought.
14:05:12 <Riastradh> tic, no, that's circumference.
14:05:24 <tic> Riastradh, okay, then A = 2*pi*r
14:05:27 <tic> thanks
14:05:41 <Riastradh> Er, wait, no, maybe that is area and 2pir is circumference.
14:05:48 * Smerdyakov laughs.
14:05:58 <Smerdyakov> tic, you were right to begin with.
14:06:15 <Smerdyakov> 2*pi*r has the wrong dimensionality to be an area.
14:06:41 <phubuh_> circumference is diameter * pi, area is radius squared * pi
14:11:03 <Lor> What I've never figured out is how the cross product of two vectors can be a vector. One would think that it has the wrong dimensionality.
14:12:31 <Lor> 1m ◊ 1m orthogonally gives you a 1m vector orthogonal to both of the previous ones, but 100cm ◊ 100cm gives you 10000cm?
14:12:50 <Lor> Somewhat confusing, I'd say. :)
14:14:19 <shapr> lektu: you could write a befunge98 interpreter :-)
14:15:30 <ski> Lor : hmm, isn't the unit of the cross product different ?
14:16:38 <phubuh_> that'd let you use a State monad :-)
14:16:56 <Lor> It'd have to be, but then it would be in a completely different vector space, and elementary schoolbooks typically seem to say just that vector ◊ vector = vector.
14:17:11 <lektu> shapr: No, thanks :)
14:17:15 <Lor> MathWorld says that the result of a cross product is a "pseudovector" but doesn't say anything about the dimensions.
14:17:39 <ski> Lor : the vector spaces can still be compared in what direction the vector points, no ?
14:17:53 <lektu> It would be fun to write a roguelike, but I cannot start to think how would one would a rogue, even small, in Haskell...
14:19:23 <shapr> lektu: there's already the beginnings of one that dark started
14:19:26 <shapr> it's called mage
14:19:32 <shapr> I have a copy if you'd like to see it
14:19:51 <phubuh_> i'd like to take a look at that
14:20:03 <phubuh_> (i actually started writing one myself a while ago)
14:20:18 <ski> shapr : is it a befunge interpreter ?
14:20:49 <shapr> http://raven.ScannedInAvian.org/~shae/src/haskell/mage-1.0pre35.tar.gz
14:21:00 <shapr> ski: no, it's a 'nethack'
14:21:25 <phubuh_> thanks :)
14:21:52 <ski> shapr : plugin(?) to the game ?
14:21:53 <shapr> actually, dark also wrote 'harc' and 'uncc' in Haskell
14:22:09 <shapr> no, it's a partial rewrite of a nethack-like game in Haskell
14:22:17 <ski> k
14:22:29 <shapr> dark also wrote some of an SDL binding in Haskell, following 'Programming Linux Games' by overcode
14:23:04 <shapr> it's quite spiffy, it can read info from my nine axis joystick
14:23:49 <lektu> shapr: (sorry, I was out for a while) Yes, I'd like to see "mage".
14:25:45 <lektu> I've got it from ScannedInAvian.
15:13:13 <shapr> yargh
15:14:05 <Riastradh> Blargh!
15:14:08 <Riastradh> Snargh.
15:14:25 <ski> yuurgh
15:14:46 <ski> rogntudjuu
15:15:35 <shapr> aeouths
15:15:55 <ski> kr‰miltudjuu
15:16:37 <Igloo> What axes does a nine axis joystick have?
15:16:50 <Heffalump> nine? wow.
15:17:25 <Riastradh> Forwards and backwards in time, maybe?
15:17:32 <esap> That sounds like the infamous paddle.
15:17:38 <Heffalump> I recall having a three axis one that had a separate wheel for something or another.
15:17:49 <shapr> it's a force feedback joystick
15:18:14 <shapr> not that the linux drivers support the force feedback stuff
15:18:30 <shapr> which is too bad, I thought it would be a cool CPU/RAM meter
15:19:18 <shapr> actually, I think it's only a six axis joystick
15:19:38 <shapr> x,y,twist, x and y on the hat, and the throttle
15:19:55 <shapr> I wonder where I got nine...
15:21:03 * esap would like to play nethack using those nine axis controls.
15:22:09 <andersca> shapr: I'm pondering doing the WM as my AFP project
15:22:30 <shapr> cool!
15:22:39 <ski> WM ?
15:22:43 <shapr> window manager
15:22:44 <andersca> window manager
15:23:09 <ski> window manager for what ?  X ?
15:23:36 <andersca> yeah
15:23:37 <ski> (you said *the*)
15:23:47 <andersca> since shapr knows about it
15:24:02 <shapr> yah, we've been talking about it.
15:24:04 <ski> 'kay
15:24:07 <shapr> I'd like to have one
15:26:11 <shapr> andersca: I think HaWM would a codetoy to equal lambdabot 
15:26:16 <shapr> er "would be a"
15:26:27 <andersca> yeah
15:27:04 <shapr> just need to design a domain specific language to represent managing windows I think
15:32:32 <shapr> hi Ray.
15:32:59 <GreyLensmen> lo
15:35:16 <shapr> what's up?
15:45:41 <shapr> hey steveh
15:53:12 <shapr> good morning Binkley 
15:53:18 <ski> well, i'm going home now
15:53:24 <shapr> yah, I'm going to sleep.
15:53:25 <Binkley> good afternoon
15:53:28 <ski> goodbye all
15:53:32 <shapr> hej da
15:53:38 <ski> hej dÂ
15:53:43 * shapr yawns
15:53:50 <shapr> I'll work on this tomorrow
15:54:07 <shapr> er?
15:55:08 <shapr> huh, weird
16:13:00 --- topic: '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","lots of cool debs in the haskell-experimental archive - see http://haskell.org/hawiki/DebianUsers","ghc rpms - http://haskell.org/~petersen/rpms/ghc/","new monads tutorial http://www.nomaware.com/monads/html/","Haskell Refactorer - http://www.cs.kent.ac.uk/projects/refactor-fp/hare.html"]'
16:13:00 --- topic: set by shapr on [Thu Sep 18 06:48:22 2003]
16:13:00 --- names: list (clog blackdog arguile Heffalump isomer Binkley steveh GreyLensmen jdrake Marvin- mattam__ palomer d33p Arnia esap phubuh_ o3 kosmikus|away tez norpan dennisb polli earthy edlang ludde wax tic Darius Riastradh Flarelocke apmuf lambdabot Lunar^ el_diego shapr whee andersca Lor gdsx galority SyntaxPolice skylan Cale themus xkb nothome_bob2 Igloo reffie smkl Smerdyakov phubuh Rafterman Malik keverets mgoetze YveDeLarc jak emu cm Strike asmodai)
16:13:00 --- names: list (vegai ibid)
16:17:47 <steveh> mph
16:17:59 <steveh> i am unimpressed with my CS GRE score of a couple years ago
16:18:05 <steveh> but I wonder if I should bother with it again
16:18:09 <Binkley> me too
16:18:19 <Binkley> I don't think it matters... admissions committees realize it's a dumbass test
16:18:28 <steveh> probly
16:18:38 <steveh> and I'm not applying to cal tech or anything
16:19:07 <Binkley> I only scored in the 75th percentile and I got in almost everywhere I applied
16:19:43 <steveh> congrats :)
16:19:56 <steveh> i am above the middle
16:19:57 <Binkley> heh
16:19:58 <steveh> not by much
16:20:10 <steveh> of course
16:20:17 <steveh> I got 40 correct and 10 incorrect
16:20:21 <steveh> those 20 omits kill me
16:20:25 <steveh> I take my time on tests
16:20:50 <Binkley> standardized tests only measure your ability to take standardized tests, anyway
16:20:53 <steveh> I like to spin it as being a conscientious worker
16:20:57 <Binkley> heh
16:21:20 <steveh> i would get 100s on my homeworks at school all the time
16:21:27 <steveh> because I could spend hours on a few problems
16:21:36 <steveh> then I wouldn't do so great on the tests
16:24:00 <steveh> man
16:24:10 <steveh> this online application isn't secure...
16:24:17 <steveh> and it asks for SSN, financial information, etc
16:24:24 <Binkley> heh
16:24:26 <Binkley> what school?
16:24:30 <steveh> yale
16:24:41 <Binkley> i'm applying there too
16:24:42 <Binkley> i thought it was secure, though
16:24:50 <steveh> maybe I am just missing the icon
16:24:51 <Binkley> i don't give out my ssn anyway... legally, you don't have to
16:25:01 <steveh> but I really don't see it
16:25:07 <Smerdyakov> Can the law prevent schools from refusing to admit you if you don't supply it?
16:25:11 <steveh> where are you applying, and what are you apply for?
16:25:12 <Binkley> dunno
16:25:32 <Binkley> I'm applying to OGI, Northeastern, Yale, Indiana, BU, Cambridge, Penn, and CMU
16:25:34 <Binkley> In no particular order
16:25:37 <Binkley> for a Ph.D in CS
16:25:50 * steveh is trying for a master's in same
16:25:58 <Smerdyakov> Binkley, why not Princeton?
16:26:14 <Binkley> Appel is mostly working on PCC, it seems, and I'm not so interested
16:26:48 <Igloo> What can they do with your SSN?
16:26:57 <Smerdyakov> Binkley, what about Walker?
16:27:02 <Binkley> They can use it to steal your identity
16:27:10 <Binkley> Walker is mainly security, no?
16:27:28 <Smerdyakov> Not anymore, I don't think.
16:27:37 <Smerdyakov> He had a paper about aspect-oriented programming in ICFP.
16:27:40 <Smerdyakov> (the last one)
16:27:43 <Binkley> Yeah, I heard that
16:27:54 <Smerdyakov> He's just a general type theory enthusiast, I think. :)
16:27:54 <steveh> damn, CS at yale doesn't look at writing samples ;)
16:28:08 <Binkley> Are there any CS programs that do?
16:28:21 <Binkley> Hmm, you're right about the Yale application not being secure
16:30:12 <Binkley> !play
16:30:15 <Binkley> oops, wrong window
16:30:16 <steveh> that's the thing, maybe they should look at writing samples ;)
16:30:23 <Binkley> Why?
16:30:30 <steveh> it's all research, research, research
16:30:38 <Binkley> well, that's what grad school is about! :-)
16:30:46 <steveh> I don't give a crap about research; I want to teach...
16:30:55 * steveh decides to leave that out of his personal statement
16:30:59 <Binkley> heh
16:31:32 <Binkley> Well, you'll still have to do some sort of research to get a graduate degree
16:31:42 <steveh> that is precisely the issue
16:31:45 <Binkley> and writing just isn't particularly important in CS, except for general cultured-ness
16:31:54 <steveh> i am interested in quite a few things enough to do theses on them
16:32:22 <steveh> but now I have to figure out what to talk about, and to whom, in these statements of intent
16:32:43 <Binkley> Yeah, I hate writing those
16:33:00 <Binkley> Especially the part where you name-drop potential advisors
16:33:13 <Binkley> It's like, "blah blah blah blah SO-AND-SO blah blah blah"
16:33:45 <steveh> i have to find advisors and areas that i can wax poetic about
16:34:00 <Binkley> it's all Web searching
16:35:07 <steveh> hmm
16:35:39 <Binkley> fortunately, CS people have detailed web pages
16:35:46 <Binkley> I'd hate to be applying to grad school in, say, musicology
16:35:50 <steveh> except at my alma mater
16:35:50 <steveh> bleh
16:35:53 <Binkley> heh
16:37:55 <steveh> i am interested in structured text, but it is not as sexy as some other topics so you don't hear about active research
16:38:00 <steveh> at least I don't
16:38:10 <steveh> but I have been out of the loop for a couple years
16:38:17 <Binkley> What does that mean... markup languages, that sort of thing?
16:38:39 <steveh> yes, processing, indexing, manipulating, searching, applications
16:38:39 <steveh> etc
16:39:20 <Binkley> so you'd probably be working in a database group?
16:40:14 <steveh> there are aspects of databases involved
16:42:25 <Smerdyakov> Well, Binkley, I don't know why you don't like PCC. I'm working on a TAL module for a general PCC system by George et al., and I'm having a blast seeing a GUI representation of abstract interpretation of TAL code. :)
16:42:50 <Binkley> I just don't want to do research that's centered around safety/security
16:43:47 <Smerdyakov> Oh, it's just an excuse to use theorem provers. I promise. :D
16:45:03 <steveh> also interested in NLP
16:45:09 <Binkley> well, I need to be able to see how my work will contribute to allowing people to write more beautiful programs
16:45:18 <steveh> this is much fuzzier stuff than most of the things i see whizzing by on #herew
16:47:29 <steveh> arg
16:47:34 <steveh> that's natural language processing
16:47:40 <steveh> not neuro-linguistic programming!
16:47:45 <steveh> damn google
16:47:56 <Binkley> heh
16:48:37 <Smerdyakov> Binkley, that's easy! By working on security, you make it even more clear to the masses that they should be using safe languages, and funtional languages gain market share.
16:49:24 <Binkley> eh, I don't know that anything is necessarily going to help functional languages gain market share
16:49:33 <Binkley> Tools that are based on types and other functional language ideas, yes
16:49:54 <steveh> ah
16:49:59 <steveh> computational linguistics
16:50:00 <Binkley> But at this point I don't really care whether functional languages catch on. What's popular isn't always what's best.
16:50:02 <steveh> there's the better term
16:51:09 <blackdog> hey all. possibly a stupid question, but is there a good resource on haskell+emacs? I'm a vim guy, but shapr's convinced me to check out xemacs... atm, though, i can't really see much benefit.
16:51:21 <steveh> emacs is like sex in text editor form
16:51:41 <blackdog> not sure i want to be that intimately involved with a bitstring...
16:51:48 <Binkley> I've used the emacs haskell mode but it doesn't seem to help much
16:51:52 <steveh> haskell-mode isn't as nice as the modes for other languages
17:46:53 <shapr> ahem
17:55:20 <shapr> blackdog: man, you always show up when I should be asleep :-)
17:57:06 * shapr yawns
17:58:15 <Pseudonym> Go sleep then.
17:58:35 <shapr> yes, I will. I was hoping blackdog would unidle so I could help him with emacs' haskell-mode
17:58:48 <blackdog> shapr: g'day.
17:58:53 <shapr> g'day blackdog 
17:59:09 <Binkley> ICFP 2004 deadline is April 1, 2004... start writing now! ;-)
17:59:14 <blackdog> sorry about that. i'm abusing screen: news, mail and irc share screenspace...
17:59:26 <shapr> I use ion, it's the screen of window managers
17:59:42 <blackdog> yeah, i abuse that too.
17:59:47 <shapr> you use ion?
17:59:54 <blackdog> yah.
17:59:56 <shapr> nifty
18:00:03 <shapr> are you using ion-devel with lua scripting?
18:00:16 <blackdog> uh... no. am i missing out?
18:00:39 <blackdog> i thought the whole point of ion was to be simple and predictable. why would you want to script it?
18:00:43 <shapr> Just curious, I've edited my startup files heavily
18:01:00 <shapr> I've realized I like to use only the apps I'm dealing with directly, but I want to have others open at the same time
18:01:13 <shapr> so I'd like to 'fold' some apps into my unused workspace
18:01:23 <shapr> and then 'unfold' them back into my main workspace when I want them again
18:01:48 <blackdog> i'm a lazy, lazy man. i tend to use stock everything whenever i can get away with it.
18:01:56 <shapr> that does make sense
18:03:13 <shapr> did you figure out the indentation in emacs?
18:03:52 <blackdog> not a clue. i was about to ask you...
18:04:04 <shapr> tab indents a line
18:04:35 <shapr> have you seen this: http://www.haskell.org/hawiki/HaskellMode
18:04:36 <shapr> ?
18:04:37 <blackdog> is this indent mode or simple-indent?
18:05:18 <shapr> I'm using indent
18:05:22 <shapr> not simple-indent
18:05:35 <blackdog> no, i hadn't. thanks, that looks useful...
18:05:40 <shapr> and it's 3am now, I'm going to go fall over asleep...
18:05:54 <shapr> there are many emacs users on this channel, hopefully one of them can help you
18:06:19 <blackdog> ooh, now i get it. sweet. thanks dude.
18:06:23 <shapr> if you come back when I'm awake, I'll help you more :-)
18:06:35 * shapr disappears into the land of dreams....
18:07:56 <palomer> to never return!
18:08:08 * palomer wonders if there's a gui builder for haskell
18:29:44 <RibRib> hello
18:29:55 <RibRib> whats parse error in pattern?
18:30:32 <Pseudonym> That means your syntax is wrong.
18:30:42 <Binkley> It means your pattern has a parse error.
18:30:57 <Pseudonym> What Binkley said. :-)
18:31:00 <Pseudonym> Can you post the pattern?
18:31:19 <RibRib> how do i post a pattern?
18:31:27 <RibRib> like the line with the error?
18:31:43 <RibRib> getID (newPassenger id src dest) = id
18:31:54 <Pseudonym> That's wrong.
18:32:15 <RibRib> whats wrong with it?
18:32:34 <Pseudonym> newPassenger is a function symbol.  I think you want a constructor symbol.
18:32:40 <Pseudonym> i.e. something which starts with a capital letter.
18:33:04 <RibRib> i was thinking that
18:33:17 <RibRib> but i had to use newPassenger
18:33:17 <Pseudonym> Well, why didn't you try it? :-)
18:33:21 <Pseudonym> Why?
18:33:27 <RibRib> its given
18:33:49 <RibRib> getID (newPassenger 161 10 14)
18:33:50 <RibRib> 161
18:33:56 <RibRib> thats what i need to do..
18:34:19 <Pseudonym> What does newPassenger do?
18:34:29 <RibRib> i hav no idea
18:34:42 <RibRib> im given codes without any desciption
18:34:55 <Pseudonym> I suggest you have a look at its source and try to figure out what it does.
18:35:12 <RibRib> Compiling Passenger        ( Passenger.hs, interpreted )
18:35:12 <RibRib> Ok, modules loaded: Passenger.
18:35:12 <RibRib> *Passenger> :t newPassenger
18:35:12 <RibRib> PassengerID -> SrcLevel -> DestLevel -> Passenger
18:35:12 <RibRib> *Passenger> getID (newPassenger 161 10 14)
18:35:12 <RibRib> 161
18:35:14 <RibRib> *Passenger> getSrc (newPassenger 161 10 14)
18:35:14 <Smerdyakov> And I suggest you ask your teachers if they give you badly explained assignments.
18:35:16 <RibRib> 10
18:35:19 <RibRib> *Passenger> getDest (newPassenger 161 10 14)
18:35:20 <RibRib> 14
18:37:08 <Pseudonym> Are getSrc and getDest given?
18:37:26 <Pseudonym> Or do you have to write them too?
18:38:06 <RibRib> yep, newPassenger is a function that converts those numbers into  ID Src and Dest i assume
18:38:25 <RibRib> i should start off with that
18:39:11 <Pseudonym> Why don't you look at the source code of newPassenger and try to figure out what it does.
18:39:36 <RibRib> newPassenger :: PassengerID -> SrcLevel -> DestLevel -> Passenger
18:39:36 <RibRib> newPassenger = error "implement me"
18:39:40 <RibRib> thats all i hav..
18:39:45 <Pseudonym> Ah.
18:39:50 <Pseudonym> Well, I suggest you implement it, then.
18:40:31 <RibRib> im trying :)
18:40:44 <Pseudonym> In fact, I suggest you implement that _first_.
18:40:52 <Pseudonym> Then try to figure out how to write getID.
18:41:43 <RibRib> yes i know
18:43:39 <RibRib> can i ask a question
18:43:52 <RibRib> *Passenger> getID (newPassenger 161 10 14)
18:43:53 <RibRib> 161
18:44:13 <RibRib> and im given....getID :: Passenger -> PassengerID
18:44:41 <Pseudonym> OK
18:44:43 <RibRib> should Passenger be a tuple?
18:44:55 <Pseudonym> That's one way to do it.
18:45:05 <Pseudonym> If it's the way you know how, it's probably the best.
20:38:30 --- topic: '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","lots of cool debs in the haskell-experimental archive - see http://haskell.org/hawiki/DebianUsers","ghc rpms - http://haskell.org/~petersen/rpms/ghc/","new monads tutorial http://www.nomaware.com/monads/html/","Haskell Refactorer - http://www.cs.kent.ac.uk/projects/refactor-fp/hare.html"]'
20:38:30 --- topic: set by shapr on [Thu Sep 18 06:48:22 2003]
20:38:30 --- names: list (clog yazirian RibRib Pseudonym blackdog arguile Heffalump isomer steveh jdrake palomer d33p Arnia esap phubuh_ o3 kosmikus|away norpan dennisb polli earthy ludde wax tic Riastradh Flarelocke apmuf lambdabot Lunar^ el_diego shapr whee andersca Lor gdsx galority SyntaxPolice skylan Cale themus xkb nothome_bob2 Igloo reffie smkl Smerdyakov phubuh Rafterman Malik keverets mgoetze YveDeLarc jak emu cm Strike asmodai vegai ibid)
21:17:18 <RibRib> hello
21:17:20 <RibRib> *Passenger> :t newPassenger
21:17:22 <RibRib> PassengerID -> SrcLevel -> DestLevel -> Passenger
21:17:22 <RibRib> *Passenger> getID (newPassenger 161 10 14)
21:17:22 <RibRib> 161 
21:17:44 <RibRib> just by looking at that, can anyone see what the function newPassenger does?
22:59:47 <RibenaBoy> hello
22:59:48 <RibenaBoy> *Passenger> :t newPassenger
22:59:48 <RibenaBoy> PassengerID -> SrcLevel -> DestLevel -> Passenger
22:59:48 <RibenaBoy> *Passenger> getID (newPassenger 161 10 14)
22:59:48 <RibenaBoy> 161 
22:59:48 <RibenaBoy> just by looking at that, can anyone see what the function newPassenger does?
23:04:17 <dennisb> it creates a Passenger
23:05:38 <dennisb> looks like a program that runs an elevator
23:06:15 <Darius> I'd be scared by an elevator that identified me.
23:14:40 <RibenaBoy> why is it necessary?
23:14:51 <RibenaBoy> i mean the newPassenger function
23:16:13 <dennisb> it works just like a constructor
23:16:54 <dennisb> Darius: would it be better if it let you in, closed the door and forgot all about you :-)
23:18:10 <RibenaBoy> im confused
23:19:24 <dennisb> why is it not needed you think?
23:19:29 <Darius> meh. I prefer stairs.
23:20:47 <RibenaBoy> yeh
23:20:58 <RibenaBoy> if i want to get id
23:21:10 <RibenaBoy> cant i just grab it from the 3 numbers in passenger
23:21:52 <RibenaBoy> if i type newPassenger 1 2 3 , it'll just return 1 2 3, wouldnt it?
23:21:52 <dennisb> but you don't have any passenger before you have called newPassenger, right?
23:22:14 <dennisb> no, it would return something of type Passenger
23:22:33 <dennisb> exactly what that is I don't know
23:22:58 <RibenaBoy> its data
23:30:55 <blackdog> You could ask your tutor, you know. There are lots of us round.
23:35:48 <RibenaBoy> how do i implement data Passenger?
23:39:13 <Pseudonym> http://haskell.org/hawiki/HomeworkHelp
23:39:27 <Pseudonym> Should probably have a read of that first
23:57:05 <Pseudonym> I think we scared him off.
