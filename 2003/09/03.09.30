00:33:10 --- topic: '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","lots of cool debs in the haskell-experimental archive - see http://haskell.org/hawiki/DebianUsers","ghc rpms - http://haskell.org/~petersen/rpms/ghc/","new monads tutorial http://www.nomaware.com/monads/html/","Haskell Refactorer - http://www.cs.kent.ac.uk/projects/refactor-fp/hare.html"]'
00:33:10 --- topic: set by shapr on [Thu Sep 18 06:48:22 2003]
00:33:10 --- names: list (clog asmodai_ phubuh__ Doraemon harsha123 sandos mgoetze|away ecraven isomer dennisb SyntaxPolice_ skylan blackdog themus_ keverets ibid mattam vegai Lor Rafterman phubuh_ Maddas galority Cale yazirian emu Heffalump reffie kosmikus|away smkl tic earthy TDT Igloo Riastradh el_diego Strike shapr cm phubuh Smerdyakov gdsx Lunar^ lambdabot apmuf wax ludde arguile andersca whee norpan nothome_bob2 xkb Malik)
00:36:47 <harsha123> blackdog: yep. finite state machines.. 
00:38:19 <harsha123> i was stuck in creating a FSM that accepts only an even number of 0's and odd number of 1's 
00:39:51 <harsha123> a non-deterministic finite automaton acutally.. 
00:45:43 <earthy> harsha123: that's rather easy, right?
00:46:03 <earthy> you need 4 states, with appropriate transitions
00:46:25 <earthy> only 1 of the 4 states is accepting
00:49:39 * earthy thinks a bit deeper
00:50:17 <harsha123> earthy: i tried a bit.. but in vain..
00:50:44 <earthy> well, 4 states is sufficient, one to encode each of the four possible combinations of even/odd for both 0 and 1
00:51:29 <earthy> start state is even 0's even 1's, and you make transitions to even 0's odd 1's, odd 0's even 1's and odd 0's odd 1's
00:51:49 <earthy> point is that this is deterministic, really. :)
00:52:03 <earthy> non-deterministically you might get away with fewer states. :)
00:52:42 * harsha123 thinks..
00:53:28 <harsha123> earthy: do ya first generate a general language.. and then construct an automaton?
00:54:00 <earthy> nope
00:54:16 <earthy> you specified quite exactly what the automaton should do
00:56:34 <earthy> then it's a matter of reasoning. oh, I'm assuming your alphabet to be {0,1}
00:56:49 <harsha123> yes {0,1}
00:58:17 <earthy> well, you specified exactly `accept on even 0's odd 1's'
00:58:51 <harsha123> yes..
00:59:03 <earthy> this implies not accepting on even 0's even 1's, odd 0's even 1's, odd 0's odd 1's.
00:59:46 <earthy> this then implies 4 states with appropriate transitions
01:00:33 <earthy> and, given that your machine is nondeterministic, you don't even have to specify all transitions
01:00:46 <earthy> only those that actually change your state
01:00:49 <harsha123> will that be a combination of (11)^* (00)^*0
01:01:01 <harsha123> is that correct?
01:01:17 <earthy> why are you already turning it into a regular expression?
01:02:00 <earthy> and, no, what you specified is incorrect. :) e.g. 111000100
01:02:00 <harsha123> hmm..
01:02:15 <earthy> err... flip the 1's and 0's in that. :)
01:03:00 <harsha123> yep..
01:05:42 <earthy> so, do you have the automaton written down yet? (it's a simple square, really)
01:05:42 * harsha123 is lost 
01:05:53 <earthy> put down for dots. :)
01:06:29 <harsha123> ok
01:06:29 <earthy> draw 2 lines between neighboring dots in the square, one in each direction
01:06:38 <earthy> so you have a square with double sides
01:07:01 <harsha123> ok
01:07:08 <earthy> then you simply label the dots with even 0's even 1's, even 0's odd 1's, odd 0's even 1's, odd 0's odd 0's
01:07:27 <earthy> then you mark the accepting state with a circle around the corresponding dot
01:07:46 <harsha123> hmm Ok.. i think i got it now. 
01:07:50 <earthy> and label each of the arrows with the appropriate letter in your alphabet...
01:08:04 <earthy> so the semantics of the state change work. :)
01:08:34 <earthy> 'kay. then the *next* thing is to turn that into a fully deterministic automaton, and *then* you can think of turning it into a regexp. :)
01:09:38 <earthy> got it?
01:09:51 <earthy> think it through. the procedure isn't hard, but it is somewhat subtle.
01:11:42 <harsha123> earthy: but insnt the solution to this different from solutios to other automatas for other languages??
01:12:13 <harsha123> cause we are not considering every alphabet in the languge?
01:13:31 <earthy> what do you mean, not considering every alphabet? there is but one alphabet, and it is {0,1}, as you just said...
01:13:55 <harsha123> ok got ya
01:13:58 <earthy> if you mean not considering every string in the language: who cares? we follow the specification the string should conform to...
01:14:24 <earthy> (read word or production for string, if that tickles your fancy)
01:14:41 <harsha123> hehehe..Ok
01:14:42 <harsha123> :
01:14:47 <harsha123> :) thnx
01:17:15 <harsha123> ok hmm .. it works.. :)
01:17:35 <earthy> why wouldn't it? :)
01:17:45 <harsha123> hehehe.. thnx 
01:18:22 * earthy puzzled by a typing error...
01:18:49 <earthy> how the *heck* does the typer figure out that an array declared as Int[] suddenly has a bool type?
03:43:43 * harsha123 is back
04:02:05 <shapr> y0
04:02:09 <shapr> hi antidote 
04:02:57 <shapr> antidote: learning Haskell? or a long time user?
04:03:19 <antidote> hi! I'm still learning. :-)
04:03:34 <shapr> antidote: are you taking classes in Haskell?
04:03:49 <antidote> Yes
04:03:59 <shapr> I would assume so, since luth teaches Haskell.
04:04:13 <shapr> I've heard H친kan Jonsson is one of the Haskell teachers there.
04:04:55 <antidote> Exactly
04:05:04 <shapr> is H친kan teaching your class?
04:05:48 <antidote> Yep
04:06:00 <shapr> anyways, have you seen the 'learn haskell' url in the channel topic?
04:06:00 <antidote> http://www.sm.luth.se/csee/courses/smd/108
04:06:13 <shapr> do you have any Haskell questions?
04:06:26 <harsha123> hi shapr
04:06:33 <shapr> hey harsha123, what's up?
04:07:10 <harsha123> hmm nothing much shapr.. learning how to create a debain package..infact trying to make one
04:07:27 <shapr> oh, I should learn that too.
04:07:56 * harsha123 is surprised
04:08:04 <antidote> shapr: Not at the moment... Most students seems to hate Haskell, but I like it. :-)
04:08:17 <shapr> I like it also.
04:08:22 <shapr> it's my favorite language.
04:08:43 <shapr> I'm thinking of taking classes at luth also, once my swedish is good enough.
04:08:49 * harsha123 thinks shapr has a godly status in #haskell
04:08:51 <harsha123> :)
04:09:22 <shapr> harsha123: I just try to contribute to the community, that's all :-)
04:09:27 <Igloo> harsha123: What are you packaging?
04:09:42 <harsha123> Igloo: rsync :)
04:09:52 <shapr> isn't there already an rsync package?
04:10:15 <harsha123> shapr: yes i think it is.. but i needed something to package.. so rsync
04:10:23 <shapr> antidote: have you written anything interesting in Haskell lately?
04:10:50 <shapr> I worked on my spam filter some last night, I want to add multiple ham paths.
04:12:13 <harsha123> shapr:  is your spam filter done?
04:12:21 <shapr> not yet
04:12:43 <harsha123> Igloo: have you packaged before?
04:13:00 <shapr> yes, he has :-)
04:13:12 <shapr> harsha123: look at apt-cache show ghc for example ;-)
04:13:25 <harsha123> Ooo.. got ya..  hehehe
04:14:41 <harsha123> shapr: Igloo is a debain developor.. !
04:14:45 <harsha123> :)
04:14:49 <antidote> shapr: unfortuntaly not, I haven't written anything meaningful. Is there any place on the net with lots of Haskell sources? 
04:15:27 <harsha123> antidote: shapr is a haskell guru.. and one of the prime accused in creation of lambadbot 
04:15:38 <harsha123> ;-)
04:15:44 <antidote> Oh, ok. :-)
04:18:14 <harsha123> antidote: http://www.scannedinavian.org/repos/hlibs/
04:18:39 <harsha123> antidote: shapr gave me this link before. 
04:19:32 <antidote> How is Haskell compared to Lisp? I have to learn lisp for Emacs, but is it realistic to implement Emacs in Haskell?
04:19:33 <shapr> I don't think I a haskell guru, but I have written some plugins for lambdabot 
04:19:41 <antidote> hashra123: Thansk!
04:19:49 <shapr> antidote: depends on what you mean by realistic :-)
04:19:55 <shapr> emacs is a very large piece of software
04:20:07 <harsha123> shapr's being humble ;-)
04:20:20 <shapr> on the other hand, michael sperber has done some work on autoconverting elisp into scheme
04:20:36 <shapr> it's possible that could be subverted into autoconverting elisp into Haskell
04:21:12 <shapr> or maybe hacking ashley yakeley's HScheme (scheme implemented in Haskell) into an elisp interpreter
04:21:54 <shapr> hi Darius 
04:23:39 <antidote> would haskell as effective as elisp? I don't know the difference except for all those parenthesis. :-)
04:23:47 <shapr> I think it would be much more effective.
04:24:01 <shapr> I've written some elisp and some scheme
04:24:10 <shapr> I would much prefer to write Haskell
04:24:21 <harsha123> shapr: the other day i was watching a program on NGC.. i was amazed by the tiny robot that were created by Cornell/MIT and could play soccer.. 
04:24:46 <shapr> harsha123: have you read the yampa and yampa continued papers?
04:24:51 <shapr> they have some nifty Haskell robot stuff in there
04:25:08 <harsha123> shapr: can ya get me the link?
04:25:11 <antidote> Isn't there already a haskell text editor out there? What is it's name?
04:25:57 <shapr> there's hIDE
04:26:04 <shapr> and programmatica
04:26:07 <antidote> HMm ok
04:26:14 <shapr> hIDE uses emacs or vi as the front end
04:27:59 <antidote> What is Editor Combinators?
04:28:12 <antidote> http://haskell.org/hawiki/HaskellEditor
04:29:38 <antidote> Ah, http://www2-data.informatik.unibw-muenchen.de/EdComb/
04:30:20 <harsha123> Igloo: is it possible to build a deb package with out having  the debina/rules file?
04:30:50 <Igloo> Well, in theory you could make a binary deb without having one, but it's a very strange thing to want to do
04:32:07 <harsha123> Igloo: i have a shell script that i want to make a deb, so do i need a debian/rules ?
04:32:24 <Igloo> Yes
04:32:28 <Heffalump> why?
04:32:32 <Heffalump> (does he need it)
04:32:41 <Heffalump> if he wants his package to be a proper Debian source package, he does
04:32:43 <Igloo> Because dpkg-buildpackage calls it
04:33:10 <Igloo> Like I say, you could make a binary deb without one, but I don't see any reason to
04:33:51 <Igloo> harsha123: I generally start with /usr/share/doc/debhelper/examples/rules
04:36:43 <harsha123> Igloo: hmm Ok
04:45:55 <harsha123> Igloo: is debian/rules used when you want you build a debian (binary package) directly from the source ?
04:46:23 <shapr> antidote: oh, you use erc?
04:46:40 <antidote> yes! its great
04:46:49 <shapr> I actually wrote a small part of ERC :-)
04:46:54 <shapr> very small part admittedly...
04:46:56 <antidote> cool :-)
04:47:17 <shapr> anyways, there's a collection of Haskell sources in the darcs repo at http://www.ScannedInAvian.org/repo/hlibs
04:47:31 <shapr> and darcs itself is at http://www.abridgegame.org/darcs
04:47:42 <shapr> or if you use debian I can give you the apt.sources line
04:48:02 <antidote> repos/hlibs works :-)
04:48:22 <shapr> oh, and www.ScannedInAvian.org is physically located on sandviksgatan btw :-)
04:48:33 <antidote> hehe okay
04:49:48 <Igloo> harsha123: Yes
04:50:11 <harsha123> so that implies i need it cause i dont have any right??
04:50:25 <Igloo> Don't have any what?
04:50:28 <harsha123> sorry I dont need it..
04:50:39 <harsha123> dont have any source
04:51:43 <Igloo> Different sort of use of the word source. Your shell script is your source, debian/rules will (amongst other things) create a "binary" deb, i.e. one that can be installed
04:52:36 <harsha123> Ok..
04:53:58 <shapr> gutentag YveDeLarc 
04:56:21 <shapr> antidote: so, are there many Haskellers at luth?
04:59:56 <YveDeLarc> hi shapr
05:00:58 <antidote> Perhaps 3-4 among the staff... But I don't know.
05:01:42 <antidote> I think it's only H친kan who is really into it.
05:04:17 <shapr> cool, I'll look him up the next time I'm in the building.
05:04:30 <shapr> hi Vardamir 
05:09:40 <phubuh__> hello
05:09:49 <phubuh__> sandviksgatan? where's that?
05:10:09 <shapr> phubuh: in lule친
05:10:19 <phubuh__> oh. i live in sandviken :-)
05:10:29 <shapr> oh, nifty
05:10:56 * shapr boings
05:13:26 <shapr> I want an xearth map of #haskell :-)
05:13:29 <shapr> that would be fun
05:20:35 <shapr> is haskell.org down?
05:22:39 <shapr> http://www.haskell.org/hawiki/HaskellUserLocations
05:27:17 <Heffalump> if you can be bothered to look up the location of Oxford, feel free to add me :-)
05:27:42 <shapr> heh
05:27:53 <shapr> well, the idea is to add yourself :-)
05:28:29 <Heffalump> yes, but I'm lazy and I don't really care about the list :-)
05:28:36 <shapr> fair enough
05:28:51 <shapr> c'est votre choix
05:32:33 <earthy> weedlededee
05:33:24 <Igloo> If someone doess Heff they could do me too  :-)
05:34:27 <Heffalump> http://www.cliki.net/xearth has Daniel Barlow at the top :-)
05:34:56 <Heffalump> oh, I guess I ought to do it properly accurately though
05:35:26 <shapr> hoi earthy 
05:35:47 <shapr> Heffalump: I'm only somewhat accurate, that's the hotel two blocks over :-)
05:36:20 * earthy was reasonably accurate... it's the location data for ftp.cs.uu.nl, two floors up and some 20 meters further south
05:37:19 <earthy> Igloo: where are you anyway?
05:37:42 <Igloo> Down and left a bit from Heff
05:37:47 <shapr> heh
05:37:52 <shapr> precise instructions :-)
05:38:06 <Igloo> Or left 1m or so if we're at work  :-)
05:38:12 <earthy> well, the both of you are at roughly 51.46 -1.15 :)
05:38:15 <earthy> as is now in the list. ;)
05:38:18 <Heffalump> I just put something more accurate in for me
05:38:36 <shapr> wow, that's accurate, do you have GPS in your wristwatch?
05:38:48 <Heffalump> no, I used multimap
05:39:44 * Heffalump looks up Igloo more carefully
05:40:41 <Heffalump> there you go
05:40:58 <shapr> nifty!
05:41:39 <Igloo> Am I a round number West then?
05:41:43 <Igloo> Well, roundish
05:42:20 <earthy> hm. I can't use the multimap method to improve on the guess that's in there already. :)
05:42:39 <earthy> (and I've guessed kosmikus to not mind me putting him in at the same location, as we're in the same room... ;))
05:42:59 <shapr> seems sensible
05:43:53 <RibenaBoy> i hav a question: data Product = one two three
05:43:54 <RibenaBoy> can any of these "one", "two", "three" be empty?
05:44:26 <earthy> hmm. my xearth says Igloolump. :)
05:44:37 <shapr> heh
05:44:56 * shapr bounces cheerfully
05:45:04 <Igloo> Can you specify where the label should go for each point individually?
05:55:07 <earthy> igloo: Pull it from the hawiki again. ;)
05:55:44 <Igloo> Cool
05:56:09 <earthy> okay, back to finding that typing error
05:56:57 <harsha123> Igloo: i just downloaded a hello-debhelper source....but the debian/rules files is a bit confusing..
05:56:58 * earthy hates typeinferencers that try to equate :bool with :int
05:57:11 <earthy> especially as I only deal with :int
05:58:20 <Igloo> harsha123: You should only need to worry about the bits where it has ./configure, make and make install for now. The rest is just calling debhelper bits that do stuff for you.
05:59:19 <harsha123> Igloo: Hmm Ok i'll look at only those parts..
06:00:07 <Igloo> Oh, and make clean
06:00:12 <RibenaBoy> is this allowed? data Product = One Two Three | One Two
06:01:37 <Igloo> No
06:01:48 <Igloo> What are you trying to do?
06:02:24 <Igloo> You might mean data Product a = Three a a a | Two a a
06:03:13 <RibenaBoy> lets say the "Three" is the product colour
06:03:17 <RibenaBoy> and some dont hav it
06:03:59 <Igloo> Do you want  data Product = WithThree One Two Three | WithoutThree One Two   ?
06:04:00 <RibenaBoy> hmm
06:04:20 <Igloo> You need to have a constructor in each case, and then a list of types of values
06:04:24 <RibenaBoy> ohh
06:04:33 <RibenaBoy> i need different constructors
06:04:40 <Igloo> What you said defined two constructors with the same name which is illegal
06:04:48 <RibenaBoy> oh ok
06:04:50 <RibenaBoy> thanks
06:04:59 <RibenaBoy> thats what i was trying to figure out
06:05:21 <Igloo> And you couldn't have had a value of type One on either branch, it just holds the other bits together
06:10:47 <shapr> hoi kosmikus 
06:11:15 <shapr> hoe gaat het met jou?
06:11:24 <shapr> @yow
06:11:25 <lambdabot> ..  Now I think I just reached the state of HYPERTENSION that comes
06:11:25 <lambdabot>  JUST BEFORE you see the TOTAL at the SAFEWAY CHECKOUT COUNTER!
06:11:45 <shapr> @fortune
06:11:46 <lambdabot> Why do mathematicians insist on using words that already have another
06:11:46 <lambdabot> meaning?  "It is the complex case that is easier to deal with."  "If it
06:11:46 <lambdabot> doesn't happen at a corner, but at an edge, it nonetheless happens at a
06:11:46 <lambdabot> corner."
06:44:48 <harsha123> shapr: whats #joy about?
06:50:48 <shapr> harsha123: it's the lambdabot testing channel.
06:51:05 <harsha123> shapr: ok :)
06:54:19 <ski> i thought joy was a concatenative prog.lang. ..
06:54:32 <Lor> "concatenative"?
06:54:40 <ski> yeah
06:55:39 <Lor> What do you mean with that?
06:56:09 <ski> http://www.latrobe.edu.au/philosophy/phimvt/joy.html
06:56:43 <ski> joy is a functional language
06:56:48 <Lor> I know what joy is.
06:57:02 <Lor> I asked what you mean with "concatenative".
06:57:26 <ski> it is concatenative, i.e. you concatenate functions, instead of applying them, as in most FPLs
06:57:45 <ski> f g
06:57:52 <ski> is not application but concatenation
06:58:13 <Lor> You  mean composition?
06:58:19 <ski> this group discusses joy : http://groups.yahoo.com/group/concatenative/
06:58:21 <ski> yes
06:58:46 <ski> but they call it concatenation/concatenative on the pages regarding joy
06:58:53 <Lor> Hm, all right, apparently "concatenative" refers to the ability of terms to return multiple values.
06:59:08 <ski> what ?
06:59:17 <Lor> http://tunes.org/~iepos/joy.html
06:59:37 <Lor> Because the first adjective that I'd use to describe joy would be "combinatory".
06:59:46 <Lor> (Or perhaps "algebraic"?)
07:00:30 <ibid> algebraic is often used to describe algol-style syntax :)
07:00:48 <ski> or algebraic datatypes
07:00:59 <Lor> With algebraic I mean that there are no binding constructs.
07:01:24 <ski> i think combinatory is better
07:01:57 <ibid> Lor: backus style?
07:01:59 <ski> (but it's special combinators, stack combinators)
07:02:16 <ski> or SKI combinatory logic style
07:02:17 <Lor> ibid, what's that?
07:02:27 <harsha123> good bye everyone.. my eyes need rest
07:02:32 <ski> backus "FP" language
07:02:39 <ibid> Lor: read his turing lecture :)
07:02:46 <ski> harsha123 : bye
07:02:49 <ibid> Lor:  he advocates a no-variables style
07:02:56 <ibid> Lor: for functional programming
07:04:37 <Lor> Hm, right.
07:04:55 <Lor> With algebraic I simply meant that the language is an algebra.
07:05:05 <ibid> i think he called that applicative style
07:05:19 <ibid> yeah, backus talks about algebras too :)
07:05:32 <ski> it is applicative
07:19:36 <shapr> ok, I admit, #joy is for that language.
07:19:41 <shapr> but no one ever showed up
07:38:12 <ski> :(
09:35:44 <Lunar^> Does any now how to use h(Put|Get)Buf ?
09:41:12 <Smerdyakov> @type hPutBuf
09:41:38 <Smerdyakov> No!
09:41:51 <Lunar^> hPutBuf :: Handle -> Ptr a -> Int -> IO ()
09:41:54 <Lunar^> hGetBuf :: Handle -> Ptr a -> Int -> IO Int
09:42:13 <Lunar^> My question is in fact, how do you create the buffer
09:42:15 <Lunar^> ?
09:42:25 <Smerdyakov> Well, I guess you find ways to create Handles and Ptrs. :)
09:42:58 <Lunar^> @type openFile
09:43:21 <Lunar^> Any
09:43:55 <Lunar^> sorry.. getting Handle is easy, you just have to use openFile or sockets
09:44:07 <Lunar^> But I don't know how to create buffers
09:44:12 <Smerdyakov> You mean Ptr a?
09:44:50 <Lunar^> Foreign.Marshal.Alloc.mallocBytes :: Int -> IO (Ptr a)
09:45:09 <Lunar^> the "a" is just a way to use Haskell type system in a way that you don't mess different pointers
09:45:18 <Lunar^> you can use Ptr (), that doesn't matter
09:46:05 <Smerdyakov> OK, so then this looks simple.
09:46:11 <SyntaxPolice_> hi #haskell
09:46:14 <Smerdyakov> Create a pointer to the data you want to put.
09:46:20 <Smerdyakov> And use that for hPutBuf.
09:47:22 <Igloo> Yo Syn, are you aware that HE is still broken?
09:47:48 <Igloo> Oh, and I should be uploading nhc98 tonight (to Debian) BTW
09:48:11 <Lunar^> Smerdyakov: The point is that I don't know whats is the proper way to create a pointer
09:48:18 <Lunar^> s/pointer/buffer
09:48:38 <Smerdyakov> Lunar^, probably to anything. Seems odd, though.
09:49:37 <Smerdyakov> Forget I just said that. So I guess you malloc the right number of bytes and use that.
09:50:56 <Lunar^> Mhhhh I know where to find the answer
09:50:59 <Lunar^> hws-wp
09:51:20 <Smerdyakov> You think it's more complicated than determining how many bytes you need and malloc'ing that?
09:52:01 <Lunar^> I wonder if its C malloc
09:52:13 <Smerdyakov> Does it matter?
09:52:15 <Lunar^> because C malloc is really unefficient compared to the RTS
09:55:25 <Lunar^> hws use newCharArray
09:56:08 <Smerdyakov> Which probably just calls mallocBytes..
09:56:56 <Lunar^> dunno where it is though
09:57:05 <Lunar^> byte array
10:06:34 * shapr boings
10:10:14 <Lunar^> Data.Array.IO <--- this seems to do the tric
10:14:01 <Igloo> Wassup, shapr?
10:14:08 <shapr> hackin
10:14:12 <shapr> jammin to new music
10:15:51 <shapr> workin on the spam filter, I'd like to release it, even though there are already more than enough spam filters already.
10:16:13 <Darius> shapr: What music?
10:16:40 <shapr> Darius: I got irate.sf.net, so all varieties of good stuff.
10:16:56 <shapr> Zack de la Rocha did a nice track with DJ Shadow
10:17:14 <shapr> Ruth Willis recorded the song "Boobs" in the 1950s, and it's equally spiffy.
10:40:26 <kosmikus> donedonedone :)
10:46:05 <Igloo> What's done?
10:49:22 <kosmikus> a couple of things that had to be done "by the end of September"
10:49:41 <kosmikus> among them, submitting the final version of Parsing Permutation Phrases to JFP
10:50:40 <Igloo> Cool, congrats  :-)
10:53:04 <Marvin--> yay, go you
10:53:10 * Marvin-- is still hideously behind on everything he should do
10:54:12 <kosmikus> thanks -- I really hope that we never have to modify this paper again ;)
10:55:17 * Marvin-- signs some more keys, urgh
10:57:37 <kosmikus> on the other hand, this means that I have one excuse less not to write my thesis
10:57:48 <Marvin--> heh
10:58:09 <Marvin--> The problem with going to Debian happenings is that when you get back you have a shitload of keys to sign
11:02:01 <Marvin--> jebus, are they already putting out a CFP for icfp2004??
11:02:58 <phubuh_> CFP?
11:03:04 <kosmikus> call for papers
11:03:05 <Marvin--> call for papers
11:03:07 <phubuh_> ah
11:03:11 <phubuh_> heh
11:03:38 <Marvin--> ah hell, Koen is on the program committee? Makes it a bit harder to coauthor a paper with him, I guess
11:05:35 <Igloo> Given you have a laptop I'm not sure why you don't do them in real time, Marvin
11:05:54 <Marvin--> though wait a sec, that's the icfp program comittee, so we could still submit a paper for HW, I guess?
11:06:07 <Marvin--> Igloo: I was busy :)
11:06:18 <Igloo> Fair enough  :-)
11:07:22 <Marvin--> I didn't go to Germany to sleep, I went there to work on d-i
11:08:07 <kosmikus> Marvin--: you can still submit to ICFP
11:08:23 <Marvin--> kosmikus: but can I submit a paper that we've written together?
11:08:32 <kosmikus> Koen will just be excluded from the PC meeting during the review of that particular paper
11:08:37 <Marvin--> ah
11:08:53 <Marvin--> well, it still remains to be seen if we'll *write* a paper, so I guess I shouldn't worry about it already :)
11:10:17 <kosmikus> you can't plan ahead long enough :)
11:22:15 <phubuh_> bj他n lisper is such a cool name
11:22:27 <phubuh_> well, if you're a lisper, that is
11:22:31 <[1]sandos> huh?
11:22:36 <[1]sandos> thats my teacher! ;)
11:22:38 <[1]sandos> mdh?
11:22:58 <phubuh_> oh, cool! no, i was just looking at his home page
11:23:03 <phubuh_> is he a lisper? :-)
11:23:08 <[1]sandos> ah ok. taking the course right now
11:23:11 <[1]sandos> haha, dont know actually
11:23:20 <[1]sandos> he hasnt mentioned it on lecutres afaik
11:23:56 <[1]sandos> how come you looked at his page?
11:24:19 <phubuh_> hmm, i'm not sure. i'll hit the back button a bunch of time
11:24:20 <phubuh_> s
11:24:25 <[1]sandos> 빧aha
11:24:29 <phubuh_> ah, got linked from http://www-users.cs.york.ac.uk/~colin/icfp2003.html
11:25:25 <[1]sandos> ah, ok
11:50:56 <Lor> What's a good proof assistant for dealing with classical mathematics?
11:53:54 <Markus> hehe, nice chan here =)
11:58:45 <SyntaxPolice> hi Markus
12:01:51 * esap is again trying to find whether the implementation in http://haskell.org/hawiki/ControlOperation works or not.
12:04:29 <Darius> esap: Well another thing to be worried about is does GHC allow an exception to be caught twice/once you are out of its scope.
12:06:52 <esap> darius: hmm.. what would be the situation where you'd get this problem?
12:07:16 <esap> darius: because I think the typing does ensure you can't do that.
12:08:37 <Darius> You should be able to implement call/cc with control in a fairly straightforward way and from there any Scheme example that requires full continuations would be such a situation.
12:09:16 <Markus> SyntaxPolice: hello
12:25:23 <esap> darius: I tried to return the 'continuation' from the control operation by sending an inner continuation into an outer one. I get occurs check problems.
12:26:06 <esap> darius: here's what I tried: control $ \x -> label (const $ control (\y ->  label (const (Left y)) x) "foo") x "bar"
12:30:53 <Darius> Here's one example using Control.Monad.Cont: makeF = callCC (\k -> return (\x -> k (\_ -> return x))) :: Cont r (a -> Cont r a); test = flip runCont id $ do f <- makeF;mapM f [1,2,3]
12:31:49 <Darius> This should be typeable and should test both the ability to use "return" twice and the ability to use a "continuation" outside of it's enclosing scope.
12:36:11 <esap> darius: hmm.. makeF is not directly typeable in my implementation. I get "No instances of 'Monad (Either a)' and 'DeepSeq (m (a1 -> a1))'". Hmm..
12:36:56 <Darius> Then make them.  And where does Monad (Either a) come from.
12:37:27 <esap> darius: control :: (Typeable a, DeepSeq b) => (Subtract a x -> b) -> x -> Either a b
12:39:20 <shapr> @yow
12:39:20 <lambdabot> Now KEN is having a MENTAL CRISIS beacuse his "R.V." PAYMENTS are
12:39:20 <lambdabot>  OVER-DUE!!
12:40:47 <Darius> So?  That doesn't say where a Monad constraint comes from.  Given a callCC makeF would be callCC (\k -> \x -> k (\_ -> x))
12:41:05 <shapr> hi Markus, are you learning Haskell?
12:41:14 <Markus> yup, i am.
12:41:28 <shapr> are you somewhere in Sweden?
12:41:42 <shapr> I'm curious, since I am also somewhere in sweden :-)
12:41:43 <Markus> Im studiying Haskell at Chalmers
12:41:46 <shapr> oh cool
12:41:53 <shapr> nice university for studying functional programming.
12:42:05 <Maddas> Heh. Ours is good too!
12:42:06 <Markus> why is that?
12:42:08 <esap> darius: I think it was something I did wrong, I forgot one argument to the control :-), because this version of control requires those in different format.
12:42:13 <Markus> Where are you from?
12:42:25 <shapr> I'm from Alabama originally, but I live in Boden.
12:42:38 <Markus> Ok.
12:43:03 <Markus> I need to study some dig-o-dat and mathemathics now
12:43:17 <Markus> bye
12:43:22 <shapr> Maddas: which uni are you at?
12:43:24 <shapr> Markus: cya
12:43:24 <Markus> *away*
12:43:26 <esap> darius: I translated your makeF into makeF = control (\k -> return (\x -> label (\_ -> Left (\_ -> return x)) k)) "foo"
12:43:46 <Maddas> the ETH in Zurich,starting next month. We learn great functional languages like C++ and Java!
12:43:49 * Maddas snickers
12:43:57 <shapr> wow, that's purely... something :-)
12:44:05 <Maddas> :)
12:44:08 <Maddas> (and C of course)
12:44:22 <esap> darius: and still it requires DeepSeq (m (a -> b)) and Typeable (t -> m1 a) instances.
12:44:29 <shapr> I've heard C is purely functional if you think that each function implicitly uses the IO monad.
12:44:34 <Maddas> haha
12:44:45 <emu> i've seen /. posters describe COBOL as a functional or OO language
12:44:47 <shapr> :-)
12:44:47 <phubuh_> C is just syntactic sugar for Haskell
12:44:54 * shapr snickers
12:44:59 <phubuh_> it's akin to the do notation, but slightly more complex
12:45:06 <Riastradh> I wonder if there are any C->Haskell compilers.
12:45:16 <shapr> -fvia-C ?
12:45:17 <Maddas> shapr: at least you allow me to feel better while coding C then
12:45:21 <Maddas> knowing that it's functional after all :-)
12:45:28 * shapr snickers
12:45:33 <yazirian> hey, C has recursion
12:45:36 <yazirian> that's functional right?
12:45:53 <Maddas> and it supports functions, that's a start already!
12:45:54 <phubuh_> i heard this guy named Greenspun realized how to make C functional
12:46:11 <yazirian> how much more -functional- can you get than a language that HAS FUNCTIONS?
12:46:15 <Darius> esap: You shouldn't need the returns.
12:46:15 <yazirian> yeah!
12:46:32 <Riastradh> yazirian, how about anonymous functions? closures?
12:46:50 <yazirian> bah, all sugar
12:46:58 <yazirian> magic is bad for maintainability
12:46:59 <phubuh_> Riastradh, easy!
12:47:02 <shapr> well, all functions are anonymous once compiled...
12:47:02 <Maddas> heh, I was about to say that yazirian 
12:47:14 <shapr> I admit, C is desperately looking for closure.
12:47:18 <yazirian> haha
12:47:36 * shapr grins
12:47:37 <Maddas> phubuh_: you mean as easy as in you write a compiler for a language that supports closures? :-)
12:47:51 <phubuh_> Maddas, well, slightly easier -- interpretation will do.
12:48:13 <Maddas> Oh, of course. I always try do things the hard way, it seems
12:49:59 * esap is writing instances for Typeable (a -> b) and DeepSeq (a -> b).
12:50:25 <Darius> There should already be instances for Typeable (a -> b)
12:50:43 <esap> hmm.. where is it defined?
12:51:36 <Darius> What do you mean? Data.Dynamic (or with newer CVS versions though still exported by Data.Dynamic, Data.Typeable)
12:52:35 <esap> Hmm. interesting. Because I'm importing Data.Dynamic, and it's still complaining about the instance of Typeable (t -> t1).
12:53:57 <Darius> toDyn (id :: Int -> Int) works fine for me.
12:54:06 <Darius> it'd better ;)
12:54:11 <Darius> @eval s
12:54:11 <lambdabot> unbound variable: s
12:54:16 <Darius> @eval S
12:54:17 <lambdabot> <<EM Dynamic -> EM Dynamic>>
12:55:43 <esap> darius: hmm.. it works for me too. Hmm.. maybe it's because of the universally quantified type variables. Need to fix some specific type I guess.
12:57:13 <Darius> Yes, but you should be getting an ambiguous type variable then, as toDyn 4 :: Num a => Dynamic (or would)
12:58:15 <Igloo> If you're in Haskell that would be defaulted
12:59:01 <Igloo> (assuming toDyn works on Integer)
13:03:16 <esap> darius: hmm.. when I fixed the types of your two lambda abstractions, I got makeF :: Either (Integer -> Integer) (Integer -> Integer)
13:04:07 <esap> darius: let makeF = control (\k -> (\x -> k `nlabel` ((\_ -> x) :: Integer -> Integer)  ) :: Integer -> Integer  ) "foo"
13:04:22 <esap> darius: oh sorry, nlabel x y = label (const (Left y)) x
13:06:04 <Darius> If your control is somewhat like the normal control, it should only return when the "continuation" is applied which would suggest that you need two labels.
13:06:44 <Darius> You also should be able to get makeF (which should be renamed to f or something) to have type (Int -> Int) (or whatever)
13:08:05 <shapr> how do most people here store their mail? maildir?
13:08:30 <Igloo> I use the standard one (mbox?)
13:08:36 <shapr> ok
13:08:49 <Igloo> I'd like to use something better, but I'll probably wait until I have a fancier FS
13:09:02 <esap> darius: ok, if I add a function to join the branches of the Either, then I get Integer -> Integer. Hmm.. And actually I get a problem "makeF 10" will produce an "*** Exception: (unknown)". hmm...
13:09:04 <Igloo> And it will probably require careful consideration
13:10:20 <Igloo> If this is for spam filter training then it's probably easiest to have it read an mbox on stdin and have something else convert anything else when you run it
13:10:40 <Igloo> Although it does mean you will get the ">From" mangling
13:11:12 <shapr> Igloo: eh?
13:11:30 <Igloo> At which bit? (I'll probably answer after eating)
13:11:57 <shapr> the interface I've been using so far is the mail on stdin and return the mail on stdout with an X-Bogosity: header giving the bayesian score
13:12:12 <shapr> since I'm used to writing filtering rules in Gnus, that's the simple solution
13:13:19 <shapr> any other suggestions?
13:22:23 <shapr> @yow
13:22:23 <lambdabot> LOOK!!  Sullen American teens wearing MADRAS shorts and
13:22:23 <lambdabot>  ``Flock of Seagulls'' HAIRCUTS!
13:25:55 <Binkley> @yow
13:25:56 <lambdabot> Now I'm telling MISS PIGGY about MONEY MARKET FUNDS!
13:34:16 <Igloo> I was talking about training, though, which I assumed was the reason for the question
13:47:16 <esap> darius: oh btw, should there be an instance of DeepSeq for (a -> b)? What should that do?
13:48:24 <Igloo> The same as seq
13:49:44 <esap> Well I'm just wondering, I had to add an instance of DeepSeq for the function type, the control operator thing didn't compile without it. I'm just wondering if that deepSeq should actually force evaluation of something (I don't think seq for functions does anything)
13:50:44 <esap> Well the obvious choice would be that it would have to enumerate all possible arguments and evaluate those! :-)
13:51:13 <esap> I mean, evaluate the function with those arguments.
13:52:04 <Darius> Why?  A function is a value.  And seq is necessary as it distinguishes undefined from \x -> undefined.
13:53:02 <esap> The reason is, I think everything inside the control operation should be strictly evaluated [Which is why I use DeepSeq in the first place]. And lambda abstraction seems to force delayed evaluation
13:53:43 <esap> Correctness of my implementation depends on that.
13:54:50 <esap> If something is not strictly evaluated, I will allow the exception that I use to implement it to be performed after unsafePerformIO, so I should disallow that.
13:55:18 <Darius> In a strict language, you don't enumerate all possible arguments to a function when you pass it to another.
13:56:14 <esap> darius: what if I just implement deepSeq f y = f undefined `seq` y, would that work?
13:57:12 <Igloo> It would give an error if f is strict
13:58:29 <esap> So are you saying I have no way of forcing that someone doesn't pass a lambda abstraction outside of the control operator (to ensure that unsafePerformIO is valid)
13:58:54 <esap> Except if I don't have an instance of DeepSeq at all for functions?
14:00:33 <Igloo> I don't understand the question
14:01:34 <esap> igloo: see the code at http://haskell.org/hawiki/ControlOperation. The unsafePerformIO should be made harmless.
14:05:03 <esap> igloo: THe only way I know is to ensure that 'f' in that function is fully strictly applied [such that you cannot pass bindings made in f ouside from the control operation.
14:05:40 <Darius> If you can't pass bindings outside, then you don't have something powerful enough to make full continuations.
14:07:42 <esap> Actully, I'm hoping that this is a bit less powerful [I implemented the "normal" version of control [with typing Neg (Neg a) -> a], but this had the same problem, the unsafePerformIO was not safe].
14:08:12 * Igloo doesn't get    control x. 1 + [x]5   -- evaluates to  5
14:09:00 <esap> no my version doesn't. Remove the 'Left' and 'Right' from the implementation, and you'll get the normal version of control.
14:10:39 <esap> control_prim f = unsafePerformIO (newUnique >>= \uniq -> catchDyn (evaluate $!! f (throwDyn . Exceptional uniq)) (control_handler uniq)) does it [typed  control_prim :: (Typeable a, DeepSeq a) => (forall bot. (forall b. a -> b) -> bot) -> a. But the unsafePerformIO is not safe there either.
14:11:41 <esap> But I prefer the version in the wiki, because you get a bit of nasty universal quantification problems in GHC with this version.
14:12:12 <esap> In particular, control x. 1 + [x] 5 doesn't work in that either.
14:13:20 <esap> [x]y is the same as ($!) for that version.
14:18:37 <esap> Another reason is that I think the typing in the wiki works better than the original [due to the symmetry with lambda abstraction].
14:18:57 <Igloo> Can you explain control x. 1 + [x] 5 in words please?
14:20:51 <esap> The idea is that "control x." part declares x :: Top \\ A  (or A -> _|_, depending on typing), which represents a continuation. [x]5 applies this continuation (and has type _|_). So 1 + [x]5 has type _|_, which the control operator expects. The idea is that [x]5 "jumps" into the control, and the control operator then returns '5'.
14:22:28 <Igloo> Oh, so this only makes sense when you have sideeffects?
14:22:44 <Igloo> It's perform 1+5 then return 5?
14:23:34 <esap> no, in a sense the context of [x]5 is 'ignored'. [x]5 is like throwing an exception, and 'control x' catches it and returns the thrown value.
14:24:49 <Igloo> But surely it needs side-effects to be useful?
14:24:59 <kosmikus> hmm
14:25:19 <Darius> It can be useful without side-effects, but it is itself a side-effect.
14:25:20 <esap> igloo: why?
14:25:56 <kosmikus> can you have multiple occurences of [x] in the body of the control?
14:26:05 <Igloo> Otherwise you might as well throw away everything except the [x]y bits
14:26:05 <esap> kosmikus: yes.
14:26:08 <kosmikus> ah
14:26:30 <kosmikus> so it is a bit like "return"
14:27:06 <kosmikus> only that you can have nested controls and jump to different surrounding contexts depending on certain conditions?
14:27:33 <Darius> Igloo: That's the point, but what if it's: 3*if p x then 4 else [k]0
14:27:36 <esap> kosmikus: yes, that's the basic idea, this is a control flow construct that allow you quite a bit of flexibility.
14:27:47 * shapr jams along with The Seatbelts
14:27:58 <Igloo> Hmm, fair enough
14:28:01 <shapr> blackdog: cowboy bebop series music is awesome.
14:28:35 <kosmikus> yes, so what happens if you do not "return"?
14:29:08 <kosmikus> like in control x. True || [x]False
14:29:37 <Igloo> That's not well typed
14:29:44 <Igloo> True has to have type bottom there, no?
14:29:57 <esap> kosmikus: well in the ordinary typing, you would have to have the type _|_ for the body of the control operation.
14:30:00 <Igloo> Oh, sorry, I misread || as being metasyntax
14:30:47 <esap> kosmikus: since [x]False is evaluated, it returns False.
14:31:03 <Darius> So what is control x.[x]1+[x]2?
14:31:23 <Igloo> esap: But his point is [x]False isn't evaluated in Haskell
14:31:33 <esap> sorry, I missed that.
14:31:45 <kosmikus> yes, that's what I meant ...
14:32:04 <kosmikus> but Darius's question is also interesing
14:32:27 <esap> darius: it depends on the order of evaluation of arguments of (+). either 1 or 2.
14:32:44 <esap> darius: but GHC actually gives a type error because _|_ + _|_ is somehow not valid.
14:32:48 <blackdog> shapr: yeah, it's not bad.
14:33:37 <shapr> blackdog: did he say which are best for hacking and which for theory?
14:33:59 <blackdog> shapr: check out the decemberists, man, they're awesome. Hurrah for songs about feeding your kids through selling your body to sailors!
14:34:04 <Darius> It isn't valid, what instance of Num should be used for that.  But anyways, if that is non-deterministic than the whole control expression is as well.
14:34:12 <esap> darius: and also, my implementation requires some more specific types for the constants.
14:34:27 <shapr> blackdog: any free and legal online songs of theirs?
14:35:15 <blackdog> shapr: no, he didn't say.
14:35:55 <blackdog> shapr: there are some samples at http://www.decemberists.com/music.html
14:36:28 <esap> Here is the way to test that: control_prim (\x -> (x $! (1 :: Integer)) + (x $! (2 :: Integer)) :: Integer )
14:36:56 <esap> It says "Cannot unify 'bot' with the type Integer".
14:37:22 <shapr> yay, I like free&legal samples.
14:38:02 <Igloo> What if you remove the outer :: Integer?
14:38:25 <kosmikus> the lambda expression alone typechecks for me
14:38:26 <esap> igloo: it cannot deduce "Num bot" from context ().
14:38:27 <Igloo> Oh, I see
14:38:35 <Igloo> Do you really mean bot not Bot?
14:38:48 <esap> igloo: yes.
14:39:05 <Igloo> What type does control_prim have?
14:39:19 <esap> control_prim :: (Typeable a,DeepSeq a)  => (forall bot. (forall b. a -> b) -> bot) -> a
14:39:21 <Darius> Does it typecheck with only one [x]
14:39:58 <esap> yes, but then you don't have the '+' either.
14:40:21 <Darius> No, as in 1+[x]5
14:40:25 <Igloo> Is that infered or given?
14:40:32 <esap> given.
14:40:56 <Darius> GHC doesn't infer rank-n types.
14:41:41 <esap> The inferred type is: control_prim :: forall a1 b a. (Typeable a1, Typeable (Exceptional a), DeepSeq a1, Typeable (Exceptional a1)) => ((a -> b) -> a1) -> a1
14:41:43 <Igloo> Why is it forall bot?
14:42:21 * Igloo doesn't actually know anything about quantified types
14:43:48 <kosmikus> yeah, control_prim expects a function that is polymorphic in its result type, but you give it a function that produces an Integer
14:44:51 <esap> igloo: that is actually the traditional type for the control operation, I guess ((a -> _|_) -> _|_) -> a.
14:46:23 <Darius> Another thing you could do is use a data type with no constructors.
14:50:10 <Darius> And Filinski used the SML equivalent to data Void = Void Void which also should get the same effect.
14:50:34 <kosmikus> I think you should quantify "bot" at top-level ...
14:51:52 <esap> then  I get "inferred type is less polymorphic than expected".
14:52:39 <Darius> (forall bot.(a -> bot) -> bot) -> a should be enough.
14:52:55 <kosmikus> yes, I was wrong
14:53:22 <Darius> The only reason you are adding it is to say that these functions don't return (their return type is empty)
14:57:27 * esap thinks I'll post the other version of the control as well to wiki.
14:58:36 <esap> done.
15:09:16 <esap> control_prim (\x -> 1 + label_prim x 10) will produce "quantified variable 'bot1' escapes.
15:10:35 <esap> I think the behaviour changed when I changed the use of quantification.
15:11:12 <esap> if the inner function is separately quantified, this error doesn't occur.
15:20:50 <esap> actually, the inner function has to be separately quantified, or the whole operation doesn't work.
15:21:14 <Darius> It typechecks with control_prim :: (Typeable a, DeepSeq a) => (forall bot1. (forall bot2.a -> bot2) -> bot1) -> a and label_prim :: (forall bot. a -> bot) -> a -> b?
15:21:39 <esap> yes.
15:22:20 <Darius> I mean the control_prim (\x -> 1 + label_prim x 10) example.
15:23:18 <esap> no, that doesn't.
15:24:35 <esap> There are both "cannot unify 'bot' with Integer" and the 'Cannot deduce (Num bot)' problems.
15:25:02 <esap> control_prim (\x -> (1 :: Integer) + label_prim x (10 :: Integer))
15:25:14 <esap> that one will give 'Cannot unify'.
15:27:02 <esap> but even control_prim (\x -> label_prim x (10 :: Integer)) doesn't typecheck if you don't have the inner forall.
15:35:14 <esap> Here's an interesting case: control_prim (\x -> x $ control_prim (\y -> x "foo")) will produce "Exception: (unknown)" but control_prim (\x -> x $! control_prim (\y -> x "foo")) will produce "foo".
15:40:07 <esap> ... so correctness is clearly based on evaluation order.
15:43:33 * shapr falls over asleep
15:43:48 * whee boings on shapr
15:45:59 <Binkley> get a room!
15:55:16 <Smerdyakov> Now there was an interesting hostname for this channel.
15:55:46 <whee> heh
16:07:27 <Binkley> heh
19:22:20 * Cale is back (gone 23:57:46)
20:27:05 --- mode: jordan.freenode.net set +b *!23kjhkjf@*
23:53:51 <shapr> @yow
23:53:51 <lambdabot> Life is selling REVOLUTIONARY HAIR PRODUCTS!
23:56:55 <shapr> good morning #haskell!
23:57:23 <blackdog> g'morning, shapr. it's miserable and rainy here. How's life in boden?
