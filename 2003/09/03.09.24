00:00:43 <harsha123> Yes.. I think i need a shake .. rather a good start for myself
00:02:46 <shapr> harsha123: just write something you think would be fun
00:02:51 <shapr> then get bored partway in
00:02:53 <shapr> start something else
00:03:06 <shapr> till you have a nice seed crop of projects to work on/get unstuck on
00:03:07 <edlang> ...
00:03:08 <shapr> :-)
00:03:32 <shapr> edlang: ,,,
00:03:49 <shapr> http://www.scannedinavian.org/~shae/src/haskell/Demo_Hxml.hs
00:04:01 <shapr> I wish my browser would keep case on an url
00:04:21 <Darius> Hack it
00:04:26 <shapr> mm!
00:05:20 <shapr> so now I have lots of different projects I can work on whenever I feel like it
00:05:34 <Darius> shapr: If you download the HaRe snapshot I could probably make diffs without too much effort if you intend to compile with GHC6
00:05:47 <shapr> that would be interesting
00:06:54 <edlang> shapr: thanks
00:07:05 <harsha123> thankx guys..
00:07:11 <shapr> edlang: do you already know HUnit?
00:07:54 <edlang> shapr: no... but I'm about to learn
00:08:04 <shapr> spiffy
00:08:50 <shapr> edlang: do you know other aussie Haskellers?
00:09:20 <shapr> just curious if you're a grad student or what
00:11:52 <edlang> shapr: 3rd year, haskell is used for a softeng course I'm at the moment
00:12:01 <shapr> oh neat
00:12:04 <shapr> how do you like it?
00:12:12 <edlang> shapr: only other serious haskellers I know are my lecturer, and martin schwenke
00:12:40 <shapr> well, schwenke is a nice guy
00:12:44 <shapr> I've swapped some email with him
00:12:53 <shapr> who's your lecturer?
00:13:09 <edlang> clem baker-finch
00:13:17 <shapr> haven't heard of him
00:13:33 <shapr> but I've used HasChorus some
00:13:35 <shapr> have you?
00:14:25 <shapr> gutentag magr 
00:14:28 <shapr> wie geht es?
00:15:18 <edlang> no
00:16:04 <Pseudonym> http://cs.anu.edu.au/research/ProgLang.php
00:16:09 <Pseudonym> Great change control they have there./
00:18:50 <shapr> yah, I think clem baker-finch needs to put in some project info
00:18:59 <shapr> actually, I should put up some project info also
00:19:03 <shapr> lambdabot needs docs
00:22:30 <edlang> shapr: HdomParser - what's that?
00:23:12 <edlang> the union of hdom and hparser?
00:23:23 <shapr> I don't remember at the moment
00:23:32 <shapr> I'm actually writing for-pay Python code :-)
00:27:47 <magr> morgn
00:29:22 <harsha123> shapr: how critical writing dox for lambdabot? do you have deadlines? :p
00:29:27 <edlang> I'm going to say yes, it is
00:29:55 <shapr> harsha123: no, but if I want people to use it, I should furnish useful dox
00:30:10 <harsha123> hmm..
00:30:44 * Darius puts on a User hat to avoid getting told to it himself
00:30:49 <edlang> oh no
00:30:50 <edlang> hmm
00:30:51 <Darius> shapr: And a @help command
00:31:03 * shapr laughs
00:32:49 <shapr> yes, @help is a good idea
00:32:59 <andersca> @yow
00:33:00 <lambdabot> Please come home with me...  I have Tylenol!!
00:33:10 <shapr> it's also pretty easy to write, so I've been leaving it out there for a learning experience.
00:33:47 * harsha123 thinks its a chance for him
00:33:51 <shapr> right!
00:33:52 <harsha123> :p
00:33:56 <harsha123> hehehe
00:34:07 <shapr> it's a chance for anyone who wants to write a lambdabot plugin
00:40:41 <edlang> how do you install HUnit
00:40:41 <edlang> ?
00:41:01 <shapr> download it from hunit.sf.net
00:42:02 <edlang> yes, then what - it's a bunch of literate haskell scripts, how do you compile and install them?
00:43:39 <shapr> put them in your path
00:44:08 <shapr> build the Demo script, then they should be compiled, since they're part of the dependencies
00:45:59 <edlang> ok
00:50:52 <Pseudonym> Gotta go home.  Nytol
00:50:56 <shapr> cya
01:02:46 <shapr> hi ecraven 
01:02:57 <shapr> @yow
01:02:58 <lambdabot> Send your questions to ``ASK ZIPPY'', Box 40474,
01:02:58 <lambdabot>  San Francisco, CA 94140, USA
01:03:04 <shapr> oh, I wonder if that really works
01:13:21 <shapr> @arr
01:13:22 <lambdabot> Arrr!
01:13:40 <shapr> hej tomasj 
01:14:08 <shapr> I was just in Lulea two days ago.
01:14:43 <andersca> @arr
01:14:44 <lambdabot> Aye Aye Cap'n
01:15:50 <shapr> I live in Boden
01:16:09 <shapr> tomasj: are you aware of more haskellers in the area?
01:19:07 <harsha123> shapr: are you a haskell evangelist? :)
01:19:55 <shapr> hmm, probably.
01:19:56 <mgoetze|away> 225 MB of incoming SMTP so far this month *groan*
01:20:19 <shapr> harsha123: I suspect the essence is that I advertise whatever I believe is good.
01:20:33 <shapr> that being haskell, linux, emacs, etc
01:21:06 <mgoetze> eeeevilmacs :P
01:21:07 <harsha123> ok.. :) 
01:21:25 <shapr> mgoetze: have you tried emacs?
01:21:39 <mgoetze> yes, for a few hours
01:22:00 <shapr> I think a month or so is required to get the real feeling for something, but maybe I'm just slow :-)
01:22:17 <shapr> I still go through vim tutorials/help files to learn stuff I don't know
01:23:31 <harsha123> shapr:  do you use emacs to program haskell?
01:23:42 <andersca> hugs-mode in emacs rocks
01:24:04 <shapr> harsha123: yes
01:24:09 * harsha123 is a vi guy
01:25:54 <mgoetze> bah, vi. vi is such a PITA. i prefer vim :)
01:26:42 * harsha123 laughs at the acronym PITA
01:30:13 <Lor> That's right. Prepositions and articles shouldn't be capitalized. Thus, PitA.
01:31:34 <harsha123> Pita incidentally means father in Hindi :p
01:31:59 <Lor> And it's the name of a bread.
01:32:13 <harsha123> and its also Pita itself.. 
01:33:14 <edlang> uh, I guess DB support for haskell isn't the greatest?
01:41:59 <harsha123> shapr: whats the diff between ghc6 and ghci6?
01:42:09 <harsha123> is ghci interactive?
01:44:16 <shapr> yup, ghci is the interactive part
01:55:40 <phubuh> OH GOD.
01:55:48 <phubuh> i think i understand why people turn into mass murderers.
01:56:07 <phubuh> hint:  it has to do with microsoft excel and computer classes in high school.
01:56:45 <phubuh> it is also very closely related to things as "completely unintuitive and annoying UIs", "segmentation faults", and "incompetent teachers"
01:57:44 <phubuh> and "microsoft windows".
02:05:46 <shapr> yes, that last one is rough
02:06:00 <shapr> phubuh_: are you in high school?
02:06:56 <phubuh> the swedish equivalent of it, gymnasiet.
02:07:10 <phubuh> grade 10--13 usually.
02:07:16 <shapr> I hope it's more fun than the US equivalent
02:07:31 <shapr> happily I escaped from that prison some fourteen years ago
02:08:04 <phubuh> swedish high schools are specialized, e.g., i'm in the math/computers specialization of the science line
02:08:11 <phubuh> okay, class is out, bye
02:08:52 <shapr> cya
02:45:11 <harsha123> shapr: don't ya have anything like printf in haskell? :)
02:45:49 <harsha123> jhoij
02:46:41 <shapr> there is a printf in Haskell
02:46:54 <shapr> I don't think it's standard in GHC though
02:47:29 <harsha123> Ok..
02:47:47 <harsha123> how do ya print to the the terminal?
02:48:01 <harsha123> standard output
02:49:57 <ski> harsha123 : re printf : http://www.informatik.uni-bonn.de/~ralf/talks/fullcircle.4.ps.gz  ?
02:50:45 <ski> putStr,putStrLn
02:50:58 <harsha123> Ok
03:27:53 <shapr> @yow
03:27:56 <shapr> hrm
03:31:34 <Lunar^> shapr: My patch made it :)
03:31:52 <Lunar^> shapr: I'm still working on the bindings though
03:32:16 <Lunar^> shapr: I'm searching a nice way to encapsulate the threading of PDF
03:38:50 <shapr> Lunar^: yes, I saw your patch, yay!
03:40:19 <Lunar^> shapr: I think I've got the time to do a real nice binding
03:40:33 <Lunar^> shapr: The final test would be to recreate the logo on Haskell homepage
03:40:46 <Lunar^> shapr: being able to generate PDF from fp code will be really nice IMHO
03:50:11 <det> shapr: yo
03:54:17 * Lunar^ is lost trying to put a ReaderT into a newtype
03:56:17 <Darius> Lunar^: why? and why bother?
03:56:41 <Lunar^> Darius: I'm making a binding for PDFlib
03:56:56 <Lunar^> Darius: which is a C lib to dinamically make PDF files
03:57:13 <Lunar^> Darius: The library threads an abstract (PDF *) through all its calls
03:57:37 <Lunar^> Darius: So I was thinking of making a monad to thread this poiner
03:57:47 <Lunar^> Darius: But I want to make it abstract for the lib users
03:59:42 <Lunar^> Do you see ?
04:00:31 <Darius> Well, implement the binding functions with type MonadReader PDFPtr m => Foo -> m Bar, and make your runPDFMonad :: Monad m => ReaderT m a -> m a
04:00:55 <Darius> or runPDFMonad :: MonadTrans t => ReaderT (t IO) a -> t IO a
04:01:16 <Darius> or whatever the constraints would be
04:02:26 <Darius> of course, Haskell will infer these types automatically
04:02:28 <Lunar^> I want to have something like continueText :: String -> PDF ()
04:02:55 <Lunar^> And if there any type mistake, I don't want ReaderT to appear
04:04:35 <Darius> It would be better not to use type PDF a as opposed to (at least) Monad m => PDF m a
04:05:08 <Lunar^> MonadIO m => PDF m a then?
04:05:12 <Darius> But the binding functions should be as polymorphic as possible in the monad they use
04:06:09 <Darius> so continueText should have type (MonadIO m, MonadReader PDFPtr m) => String -> m () or somesuch.
04:06:46 <Lunar^> I don't get it sorry\
04:07:13 <Lunar^> I would prefer to mark the function as a "PDF" function
04:13:22 <Darius> Well, I guess there isn't too much of a gain being able to slip a monad under the PDF one
04:13:55 <Lunar^> I think so
04:14:25 <Lunar^> What would be the best then ?
04:15:05 <Darius> Anyways, the simplest thing would be to use type PDF a = ReaderT PDFPtr IO a.  GHC usually uses type synonyms in type errors.
04:15:43 <Lunar^> Not in my experience
04:15:51 <shapr> hi det 
04:16:39 <Lunar^> But I'm starting with this... doing this bind is already though enough
04:19:03 <kosmikus> why is it a problem to make PDF a newtype?
04:20:28 <Darius> With GHC newer extensions, you could do: newtype PDF a = ReaderT PDFPtr IO a deriving (Monad,MonadReader,MonadIO) possibly
04:21:01 <Darius> add a data constructor in there
04:22:05 <ski> (hmm, would that work with restricted type synonyms instead of newtype ?)
04:23:31 <Darius> as far as type errors go: GHC uses the types given in an explicit signature as much as it can in type errors.
04:24:27 <Darius> Thus f :: String -> String;f x = x; f 'a' will give you an error with String, but f :: [Char] -> [Char] will give you an error with [Char]
04:25:01 <ski> True : "abcd"  gives me an error with [Char] in ghci
04:25:29 <ski> (version 5.02.2, though, perhaps this is better in newer versions ?)
04:27:48 <Darius> ski: what do you mean "abcd" gives you an error? in what expression?
04:28:28 <ski> True : "abcd"  gives an error  (the boolean value True consed onto the string "abcd", clear ?)
04:29:03 <Darius> oh, I misread you sentence.  But "abcd" has type [Char].
04:29:40 <Darius> You need to use a function that has an explicit type signature using a type synonym
04:30:01 <ski> hmm, i supposed that string literals would be given the type synonym String as type, perhaps this is a bad test/example ..
04:30:41 <ski> yes, True : ("abcd" :: String), gives a better-looking error :)
04:31:00 <ski> yes
04:32:22 <Darius> Obviously inferred types can't use type synonyms
04:33:32 <ski> i, wrongly it seems, assumed that string literals had an inferred type synonym (i.e String) ...
04:34:35 <det> shapr: so, that whole "intersection of the greek pantheon with my last name" thing .. poorly crafted joke? :p
04:35:16 <Darius> I believe if it did that, then the String type synonym would infect other types.  Typically, that's what is meant, but in some cases "foo" is used as a list of characters.
04:36:32 <ski> how often is it used like that ?  would it be too hard to write ['f','o','o'] instead in these cases .. ?
04:37:12 <ski> when i see the qoutation marks, i automatically think : string ...
04:37:22 <ski> s/qoutation/quotation/
04:37:50 <Darius> doing (`notElem` "0123456789xy") is one case, writing that out explicitly as a list of characters would be tiresome.
04:38:18 <ski> hmm, ok
04:39:01 <Darius> Also I wouldn't be surprised if "ab" is already translated into 'a':'b':[] by the time the type checker sees it.
04:39:28 <ski> hmm, now that i think of it, that seems very possible ..
04:47:41 <shapr> det: no, completely serious.
04:48:12 <shapr> det: it is a carefully crafted joke. took me seven years to think about it.
05:06:21 <det> shapr: you need to explain it to me then
05:16:43 <harsha123> shapr: module Main
05:16:43 <harsha123> main =  putStrLn "Hello World"  gives parse error " Test.hs:2: parse error on input `main'  "  
05:19:06 <ibid> you are missing "where"
05:22:29 <Darius> the proper response to that being "where?" :P
05:22:40 * earthy grins
05:23:52 * shapr grins
05:23:59 <shapr> det: greek goddess of chaos
05:24:42 <ski> all hail eris ?
05:25:33 <shapr> hail discordia!
05:26:01 <ski> which name is the greek version and which is the roman ?  i forgot
05:26:09 <shapr> eris is the greek, discordia is the roman
05:26:16 <ski> k
05:28:09 <ski> shapr : what last name ?
05:28:13 <shapr> my last name
05:28:56 * ski can't remember it, so searches the web
05:29:20 <shapr> you can also try /whois shapr
05:29:28 <ski> Erisson ?
05:29:44 <shapr> yup
05:30:09 <shapr> ski: do you get the joke?
05:30:25 <ski> yes
05:30:29 <shapr> ok :-)
05:31:11 <ski> but i'm not sure if your (real) surname is Erisson or Eriksson (Ericsson ?) ..
05:31:23 <shapr> my real surname is Erisson
05:31:28 <ski> oh
05:31:41 <ski> :)
05:31:47 * shapr bounces
05:32:42 * ski is trying to write a home-page (bad looking, 'tis)
05:33:22 <shapr> are you using WASH?
05:33:40 <ski> no, just plain html in emacs
05:33:47 <Lunar^> Darius: Can't make a derived instance of `MonadReader Test'
05:34:37 <Lunar^> Darius : deriving (Monad, MonadReader PDFPtr, MonadIO)
05:34:41 <Lunar^> works :)
05:34:43 <Lunar^> Thanks a lot !
05:35:27 <ski> shapr : now a pic of me would be handy.  *mental note* : remember to get a pic of me taken by my bro's digital camera ..
05:37:27 <SyntaxPolice> hi all
05:37:29 <SyntaxPolice> hey shapr
05:37:41 <shapr> hi SyntaxPolice 
05:38:01 <shapr> ski: I use a wiki, then it's easy to change stuff
05:39:33 <ski> shapr : hmm
05:40:25 <Darius> Lunar^:  The problem with those deriving clauses is that they are specific to GHC6+
05:41:00 <Lunar^> Darius: mhh... I'm a GHC6 user anyway... If I've got the time, I will try to do some #ifdefs
05:44:21 <det> shapr, I return!, Shae is Eris's son? :p
05:49:58 <SyntaxPolice> shapr: how's life?
05:50:15 <phubuh_> finally, i'm back from school.
06:00:59 <det> well, Eris's son is strife
06:01:04 <det> now to relate that to shae
06:03:14 <ski> same initial and final letter ..
06:07:26 <phubuh_> robert shae wrote the illuminatus books, didn't he?
06:08:13 <phubuh_> err, maybe that was robert shea
06:10:04 <mgoetze> probably it was robert shapr!
06:10:11 <phubuh_> :o
06:15:27 <phubuh_> NO!
06:15:40 <phubuh_> EU approved software patents :~(
06:15:46 <phubuh_> so much for all the protesting :~(
06:16:02 <ibid> phubuh_: with changes
06:16:33 <phubuh_> oh! where can i read about them? i heard the news on irc
06:16:38 <ibid> phubuh_: people who know about it tell me that it's mostly a victory for the anti-software-patent camp
06:16:47 <ibid> phubuh_: if you find such a place, tell me too :)
06:16:50 <phubuh_> ok :)
06:21:24 <phubuh_> The European Parliament approves the patentability of the software STRASBOURG (Reuters) - the European Parliament approved Wednesday the draft Directive very disputed on the patentability of the software inventions, after having amended it to limit its field of application to the "true inventions" having a technical range. The text, presented in first reading, was approved by 364 votes, against 153 and 33 abstentions. 
06:21:24 <phubuh_> It specifies the European Commission proposal, which establishes a distinction between the pure, famous software nonpatentable in European right, and the "inventions implemented by computer", which would become it, with the proviso of presenting a technical projection, likely to receive an industrial application. The text of origin was considered to be "fuzzy" and "ambiguous" by considerable members of Parliament who f
06:21:25 <phubuh_> eared that it too largely does not open the way with the taking out of patents on the software, with the risk to constitute a brake with l"innovation in this key field of the economy. Eurodeputes added a paragraph specifying that a "invention implemented by computer (a software) is not regarded as contributing a technical share only because it implies the use of a computer". In light, so that a data-processing program 
06:21:30 <phubuh_> is patentable, it is not enough that it is new, it is necessary still that it allows a technical innovation independently of its own execution. Another amendment specifies that the use of a patented technique is not regarded as a counterfeit if it is necessary to ensure the communication between various systems or data-processing networks. It acts for eurodeputes to prevent the monopoly which certain giants of the soft
06:21:39 <phubuh_> ware could exert on the data-processing networks, Microsoft being named but probably not aimed. The European Parliament being a colegislator in this field which concerns the domestic market, the text must now be examined by the Council of Ministers, before returning in second reading to Strasbourg. The European police chief charged with the domestic market, 
06:21:44 <phubuh_> oh no, sorry about that
06:21:54 <Lunar^> That plainly succks
06:21:56 <Lunar^> -c
06:22:13 <phubuh_> i thought my buffer held the URL, oh well, you won't have to move your eyes as much :-)
06:22:25 <Lunar^> (I was talking about this news)
06:22:31 <phubuh_> i figured :)
06:22:39 <phubuh_> there's a thread about it on slashdot
06:22:51 <phubuh_> it's not as bad as in the US, though
06:27:14 <ibid> phubuh_: url?
06:27:42 <phubuh_> http://yro.slashdot.org/yro/03/09/24/1253227.shtml?tid=155&tid=185&tid=99
06:28:19 <ibid> i mean for what you quoted
06:28:34 <phubuh_> http://yro.slashdot.org/comments.pl?sid=79769&cid=7042798
06:29:10 <ibid> found it, thanks
06:31:10 <ibid> http://yro.slashdot.org/comments.pl?sid=79769&cid=7042870
06:43:36 <yazirian> Is there a standard RDBMS DBI for Haskell?
07:12:15 <shapr> HaskellDB?
07:15:50 <yazirian> Hmm... ok. "haskell database interface" doesn't have that on at least the first 2 pages
07:16:09 <shapr> I'm sort of joking :-)
07:16:16 <shapr> I think HaskellDB should be the DBI
07:16:39 <shapr> but there hasn't been enough database stuff done with Haskell to really form one
07:16:42 <yazirian> it just occurs to me that I notice there are several RDBMS bindings out there, and I wasn't aware that they conformed to any particular standard
07:16:47 <shapr> that's true
07:16:56 <shapr> I think they should all have backend plugins to HaskellDB
07:17:00 <yazirian> which is Unfortunate :)
07:17:09 <shapr> since it's a database agnostic set-ops layer
07:17:29 * shapr sends email to Daan
07:19:50 <shapr> hi Heffalump 
07:20:01 <yazirian> um
07:20:06 <shapr> ?
07:20:26 <yazirian> my first impression from the Examples page here is that this is an excellent way to talk people out of using Haskell for database applications. :)
07:20:32 <shapr> you think so?
07:20:40 <shapr> whyfor?
07:20:49 <yazirian> I haven't gotten into the docs yet, gimme a minute or two more.
07:21:00 <shapr> ok
07:21:01 <yazirian> er, nevermind, there's not much docs
07:21:08 <shapr> for HaskellDB, you mean?
07:21:12 <yazirian> yeah
07:21:46 <shapr> the paper that describes it is pretty short
07:22:33 <shapr> I'm not thrilled with the trex syntax, but I like the idea of set based ops rather than actual sql queries
07:23:18 <shapr> since HaskellDB generates a SQL query anyway, seems like that would be a nice way to be independent of the actual database, or the specific brand of SQL used in a certain database.
07:23:35 <shapr> yazirian: what do you think?
07:24:10 <shapr> I've done your average SQL queries to postrgesql with HSQL, but I'd like something higher level
07:25:19 <yazirian> I don't think most of the world would choose higher level
07:25:40 <yazirian> Because it robs you of any advantages that a specific RDBMS may give you underneath the library.
07:25:52 <yazirian> Like... say I need to return a result set from a stored procedure.
07:26:07 <shapr> I disagree, you can put your knowledge of database X specifics into the driver for HaskellDB
07:26:10 <yazirian> I'm not really seeing how that fits into this model, especially if I need to provide some arguments.
07:28:30 <yazirian> Also, the paper and examples only talk about select statements. 
07:28:41 <yazirian> That leaves insert, update, delete... much less create table, create view, etc.
07:28:54 <yazirian> unless I just skimmed past that without notice :)
07:33:26 * shapr looks
07:34:21 <yazirian> in fact, the words 'update' and 'delete' aren't even in the paper :)
07:35:32 <shapr> they're in the Sql.hs file in the sources
07:37:04 <Lunar^> I still have questions about my PDFlib binding
07:37:27 <Lunar^> The lib restricts some functions to be within a particular scope
07:37:37 <Lunar^> (= library state)
07:38:37 <Lunar^> Would it be interesting to appear in the type ?
07:38:47 <shapr> ?
07:38:52 <Lunar^> s/to appear/to make it appear/
07:39:10 * shapr doesn't know
07:39:35 <Lunar^> Currently, I have only one monad PDF
07:39:56 <Lunar^> I could make another one for the page scope called PDFPage
07:40:20 <Lunar^> with an helper function like withPage :: PDFPage a -> PDF a
07:41:11 <shapr> sounds reasonable to me
07:41:23 <Lunar^> Ok.. here comes the complicated part
07:41:28 <shapr> I've never tried to limit some operations to a certain scope in Haskell
07:41:39 <Lunar^> there's function that you could use in several different scope
07:42:10 <Lunar^> the straight way would be have a different function for each scopes
07:42:14 <shapr> yazirian: after cruzing through the HaskellDB sources, it appears to support all the major operations
07:42:37 <Lunar^> But I think that with some type class play...
07:42:44 <shapr> I say go for the straight way first and make it better later
07:42:58 <shapr> I try to get working code first, and the pretty code later.
07:43:08 <yazirian> I would cruise through 'em too, but haskell.cs.yale.edu has become offended by my remarks, and is showing me nothing but Firebird's throbber spinning. :)
07:43:45 <Lunar^> shapr: that's one of my problem ;)
07:43:54 <shapr> http://www.ScannedInAvian.org/~shae/haskelldb.zip
07:44:24 <yazirian> Oh happy day.
07:44:27 <yazirian> Thanks :)
07:44:53 <shapr> there's the minor problem that HaskellDB requires Hugs and only has an ADO backend at the moment
07:45:02 <yazirian> well
07:45:04 <yazirian> nevermind then :)
07:45:14 <shapr> Sigbjorn Finn wrote a MySQL backend, but has not found time to release it to the public
07:45:24 <shapr> I tried to persuade him to do so at ICFP, he said he'd consider it
07:45:27 <yazirian> I've seen one for Pg somewhere
07:45:39 <shapr> lambdabot is using HSQL from htoolkit.sf.net
07:46:45 <Lunar^> shapr: I should send a patch for the MySQL binding to HToolkit's people
07:46:52 <shapr> yes
07:46:53 <shapr> good idea
07:46:54 <Lunar^> shapr: I made a few improvment to the binding
07:47:01 <Lunar^> shapr: Once I finished my current project
07:47:07 <shapr> right
07:50:28 <Lunar^> 2muchWork
08:04:50 <harsha123> shapr: is it possible to run a haskell binary as a daemon??
08:05:44 <shapr> what's special about running as a daemon?
08:07:57 <harsha123> shapr: maybe to listen to certain type of connections.. something like that..
08:08:09 <shapr> I think normal binaries can do that too.
08:08:22 <harsha123> shapr:  ok
08:09:19 <shapr> whee
08:09:24 * shapr zings around the room
08:09:30 <shapr> Jolt cola ROCKS
08:09:35 <phubuh_> i agree :-)
08:09:51 <shapr> Battery is better, but I'm lucky enough to have both at the same time.
08:10:00 <phubuh_> there's a nice little shop on the way to school that sells the 2x caffeine variant of jolt in 50cl bottles
08:12:56 <phubuh_> to daemonize in haskell, i imagine you could use forkProcess and setProcessGroupID 0
08:13:04 <phubuh_> oh and exitImmediately in the parent
08:18:55 <mgoetze> shapr: hm, i dunno, i only see it once a year, and i don't think it's all that exciting
09:49:39 <shapr> w00h00
10:31:33 <phubuh_> woo
10:54:24 <Flaggle> can anyone take a look at a program and tell me where im going wrong here?
10:54:37 <ski> hmm ?
10:54:43 <ski> ok
10:55:08 <ski> show your problem
10:58:55 <yazirian> your problem is sunspots.
10:59:00 <yazirian> I recommend chicken sacrifice.
11:00:04 <Flaggle> firstborn, imho, always work better
11:01:37 <ski> import ParseLib
11:01:37 <ski> runIt :: [Char] -> [a]
11:01:37 <ski> -- runIt x | (length (check (x ++ "p")) == (sum [product (1,2,3,4), product (2,3,4), 1])) = False = mzero
11:01:37 <ski> --         | otherwise = result [papply code2 x]
11:01:37 <ski> runIt x = if (length (check (x ++ "p")) 
11:01:37 <ski> == (sum [product (1,2,3,4), product (2,3,4), 1])) 
11:01:39 <ski> then False = mzero
11:01:41 <ski>         else result [papply code2 x]
11:01:43 <ski> check :: [a] -> [a]
11:01:45 <ski> check b = init b
11:01:46 <yazirian> I try to save those for the REALLY tough ones :)
11:01:47 <ski> ooops
11:01:49 <ski> sorrry
11:26:32 * ski my X server crashed !
11:38:34 <Igloo> Hmm, I can't run something and grab stdout, stderr with H98, right?
11:48:01 <Igloo> In fact, I can't see how to do it at all
11:53:22 <Lor> There's no popen in the posix library?
11:54:39 <Igloo> I can't see it in the "Hierarchical Libraries" section of http://www.haskell.org/ghc/documentation.html - maybe I am looking in the wrong places
11:57:17 <Igloo> Hey Marvin
11:57:34 <Marvin--> heyoo
11:57:47 <Igloo> How's darcs packaging going OOI?
12:01:21 <Igloo> OK, nothing defines popen in libraries/
12:01:49 * Igloo mutters
12:01:52 <Marvin--> haven't had time to look at it yet, alas
12:02:01 <Igloo> :-(
12:02:02 <Marvin--> and tomorrow I'm leaving for Germany
12:02:21 <Igloo> Any idea how to get stdout/stderr from things you run in Haskell?
12:02:24 <Igloo> Cool - how come?
12:02:46 <Marvin--> debian-installer work camp over the weekend
12:03:00 <SyntaxPolice> Marvin--: are you the one who takes care of the packagse that are linked from the home page?
12:03:08 <SyntaxPolice> the apt sources sources I mean
12:03:17 <Marvin--> the what from where?
12:03:46 <SyntaxPolice> let me try again.  There are packages for darcs here for instance: deb http://http.abridgegame.org/debian/ unstable/
12:04:06 <SyntaxPolice> I was just about to email the author to ask whether he wanted to move them to the haskell-experimental archive
12:04:15 <SyntaxPolice> but maybe I should be talking to you instead?
12:04:18 <Marvin--> ah, no, those are David's packages
12:04:39 <Marvin--> I mailed him and asked him if he wanted me to look at them and sponsor an upload
12:05:09 <Marvin--> after discussing back and forth a bit, we concluded that he probably didn't have time to become a Debian developer, so I'm going to be the maintainer for it instead
12:05:47 <SyntaxPolice> OK. I'll ask him if he wants to move to H.E.
12:07:34 <ludde> Marvin--: did you write an "insändare" in GT recently?
12:12:35 <SyntaxPolice> I'm goign to make a real web page for the haskell-experimental archive and remove some of the stuff on the wiki. 
12:12:42 <SyntaxPolice> can anyone think of why it shouldn't be at: http://www.syntaxpolice.org/haskell-experimental/index.html
12:13:24 <Marvin--> ludde: no
12:13:42 <ludde> Marvin--: ok just wondering :) cause there was one with the name Martin Sjö.. something
12:13:57 <ludde> it was a few days ago i don't remember exactly
12:14:15 <Marvin--> freaky :)
12:14:49 <ludde> actually i'm not even sure if it was GT :) it might have been some other newspaper
12:19:27 * shapr boings
12:19:31 <shapr> hej Marvin-- 
12:19:32 <shapr> ltns
12:19:41 <shapr> Flaggle: did your question get answered?
12:20:41 <shapr> hm, where did RegularFile go?
12:22:15 <shapr> oh right, it's isRegularFile now
12:29:40 <Igloo> Syn: Can you name it something else so the directory listing is visible please?
12:29:56 <shapr> hm, lambdabot isn't happy...
12:30:19 <Igloo> Oh, who did the emotion module? Woo!
12:34:03 <SyntaxPolice> Igloo: OK, I was wondering if directory listing was for some reason a desirable feature.
12:34:03 <Marvin--> shapr: hey
12:35:55 <shapr> Igloo: hah!
12:36:18 <shapr> just that I can't get lambdabot to start with ghc-cvs or ghc6 for some reason
12:36:23 <shapr> most likely user error...
12:36:40 <phubuh_> i compiled it with ghc6
12:37:14 <shapr> the latest ghc6 in debian/unstable?
12:37:36 <phubuh_> hmm, no, the latest one (as of about two days ago) in gentoo
12:37:41 <shapr> oh, hm
12:58:48 <Igloo> shapr: Did you change the Makefile as I said a few days ago (or something equivalent)?
13:07:34 <Xcalibor> hiyas
13:11:31 <phubuh_> hey hey
13:12:25 * Marvin-- looks in his quotes book and giggles
13:39:35 <palomer> could haskell do something like, say, parse a piece of text from a grammar thats given while the application is running?
13:42:21 <phubuh_> yes.
13:42:24 <Riastradh> palomer, uh, why not?
13:43:53 <ski> shapr : I've been busy for some time now answering/helping him out :) 
13:44:56 <palomer> I always thought a grammar had to be defined before the application was compiled
13:46:23 <phubuh_> how do you imagine regular expressions work? i can certainly pass runtime generated patterns to those.
13:49:46 <Xcalibor> phubuh_: regular expressions are state machines
13:50:10 <palomer> what happens if the grammar I want parsed isn't larl compliant?
13:50:10 <phubuh_> regular expression /engines/ are state machines. regular expressions are grammars.
13:50:30 <palomer> is an exception thrown?
13:50:41 <Xcalibor> you have a pattern, and advance the target text one character at at time until the pattern matches, then yo ufolow until it breaks, backtracking and follow (perhaps) a different branch of the grammar until the (usually) biggest match is returned
13:51:11 <Xcalibor> phubuh_: well, okay, distinction agreed
13:51:18 <phubuh_> :)
13:51:48 <Xcalibor> palomer: you have lots of trouble (for example perl, which is not larl and only perl can parse perl code)
13:52:00 <phubuh_> heh
13:52:05 <phubuh_> i can parse perl!
13:52:10 <phubuh_> (mostly)
13:52:15 <Xcalibor> there :-)
13:52:25 <palomer> I'll have lots of trouble?
13:52:38 <palomer> will an exception be thrown or will it simply give me the wrong answer?
13:52:39 <Xcalibor> only perl 5.8.1 can parse perl 5.8.1... (and maybe parrot one of these days, through pony)
13:52:56 <Xcalibor> palomer: who's parsing the grammar?
13:53:11 <Xcalibor> larl grammars are simply convinient, not law
13:53:42 <palomer> so wait, there's a library in haskell to parse any grammar?
13:54:22 <phubuh_> there are several regular expression engines :-)
13:54:42 <palomer> I'm talking about a context free language!
13:55:34 <Xcalibor> but you are talking about exceptions
13:55:40 <Xcalibor> who's throwing the exception?
13:55:50 <palomer> ok, here's what I want to do:
13:55:59 <palomer> input a set of productions
13:56:03 <palomer> and then parse a text
13:56:16 <palomer> is that achievable?
13:57:36 <Xcalibor> probably
13:57:48 <Xcalibor> i don't know how, but surely Haskell can
13:58:10 <palomer> that was my original question!
13:58:16 <palomer> usually a grammar is compiled
13:58:40 <phubuh_> would it be possible to do in a turing machine? :-)
14:00:12 * palomer kills phubuh_
14:00:21 <palomer> was wondering if it was something easy to do
14:00:23 <phubuh_> :~(
14:00:49 <JyP> Huh?
14:01:35 <palomer> you can't cry! you're 6 feet under
14:02:22 <Xcalibor> mmm...
14:04:43 <JyP> http://www.cs.uu.nl/~daan/papers/parsec.html
14:07:03 <sandos> or write a brute-force parser :)
14:08:44 <palomer> hrm, parsec says nothing about gerenarating a new lexical analyzer during runtime
14:09:12 <phubuh_> make a BNF parser, and then write a grammar for BNF in BNF, input the grammar to the parser, and pass the grammar as input.
14:09:25 <JyP> I'm sorry, but what's the point exactly?
14:11:42 <palomer> I want to write an application that takes a set of productions, and tells the user if a piece of text is part of the language
14:14:05 <JyP> Well, parsec does not generates a lexical analyser at runtime; but it may not be relevant.
14:14:51 <JyP> you may want to chek http://www.haskell.org/alex/
14:16:58 <Smerdyakov> palomer, if you want to implement context free language membership checks, it's trivial to do that with no special tool or library support.
14:18:48 <palomer> oh, and I would like to get the parse tree
14:18:49 <palomer> :o)
14:18:55 <Smerdyakov> Yup, still trivial.
14:19:03 <palomer> of a piece of text, from a grammar decided during runtime
14:19:10 <Smerdyakov> This is the kind of programming assignment that might be made in a formal languages class.
14:19:26 <palomer> oh, you mean grammar -> pda coversion
14:19:27 <palomer> yes
14:19:33 <palomer> but then parsing would take O(n^3)
14:19:41 <Smerdyakov> No, because pda's aren't much fun to use for checking.
14:19:42 <palomer> which is really, really slow
14:19:50 <palomer> why?
14:20:16 <Smerdyakov> They're nondeterministic.
14:20:31 <Smerdyakov> There is a simple dynamic programming algorithm for context free membership checking.
14:20:55 <Smerdyakov> With a length n string to check and p productions, the running time is O(pn^2)
14:20:56 <palomer> their non determism makes them slow
14:20:57 <palomer> thats it
14:21:39 <Smerdyakov> Well, what I said at least holds of p is the total length of productions.
14:21:50 <Smerdyakov> In any case, I'm not sure if there is a known better method.
14:23:17 <Smerdyakov> Do you know that algorithm I mean?
14:23:28 <palomer> yes
14:23:34 <palomer> you first put it in chomsky normal form
14:24:42 <Smerdyakov> OK. So why aren't you busy implementing this now? :)
14:24:57 <JyP> Nonetheless, parser generators / libraries saves you a lot of time
14:25:11 <Smerdyakov> JyP, how so?
14:25:28 <JyP> Are you a bot?
14:25:36 <Xcalibor> re's
14:25:50 <palomer> lol
14:25:56 <palomer> Smerdyakov: because its incredibly slow
14:26:24 <palomer> O(n^2) isn't very nice when n=10^6
14:27:05 <JyP> Well, generated parsers for lalr grammars have O(n) behaviour in average
14:27:45 <Smerdyakov> JyP, you weren't clear on what you meant by "saving time." Development time? Runtime?
14:27:54 <JyP> Dev
14:28:11 <Smerdyakov> palomer, but do you know of an algorithm with better worst-case time?
14:28:38 <JyP> Actually I don't care :)
14:28:42 <Smerdyakov> JyP, the problem is that palomer has said only that he wants to deal with context-free grammars. He can't use a tool that can't handle all the required inputs.
14:29:55 <JyP> Well, I think that "happy" should do the trick then?
14:30:32 <Smerdyakov> Beats me.
14:30:43 <JyP> http://www.haskell.org/happy/#what
14:31:01 <Smerdyakov> I don't think that is designed to handle grammars dynamically at runtime, though.
14:31:36 <JyP> Ok; I just didn't knew the grammar was dynamic
14:31:59 <JyP> How does it change at runtime?
14:32:11 <palomer> Smerdyakov: yes, even for the general case there are much more efficient algorithms
14:32:28 <palomer> but the whole point of forcing a grammar as being lalr compliant is so that you may parse it in O(n)
14:32:33 <palomer> without much trouble
14:32:47 <Smerdyakov> palomer, yup, but you haven't said you will require lalr'ness.
14:32:51 <Smerdyakov> palomer, will you?
14:36:07 <palomer> nope
14:37:00 <palomer> and I don't think that the dynamic programming algorithm for membership will give me the parse tree
14:37:21 <Smerdyakov> Of course it will.
14:37:41 <palomer> hrm, ok
14:37:46 <Smerdyakov> You determine the parse tree for every substring of the input.
14:38:24 <palomer> a substring being a symbol in the grammar?
14:38:33 <palomer> but that's what I need in the first place
14:38:47 <palomer> or if a substring is any substring, then it might not have a parse tree
14:45:47 <JyP> So, you want to re_implement ASF+SDF ? :)
14:46:53 <Smerdyakov> A substring of the input string you are testing to see if it is in the CF language.
14:47:20 <Smerdyakov> Not all substrings have parse trees. I meant to imply that you keep a "Maybe ParseTree". :)
14:50:53 <jdrake> i love it when quake3 segfaults
14:56:27 <JyP> Time to go!
15:42:03 <Xcalibor> laters
17:49:10 <gonzoid> i'm trying to track down a site, perhaps someone on this channel can help.  it was called something like 'smart code' and had links to and short descriptions of really neat little programs.  google hasn't been any help, as i don't remember the exact name.
18:08:26 <edlang> What significance does the dollar sign have in Haskell?
18:09:30 <edlang> Oh, sequence.
18:09:42 <Riastradh> f $ g = f g
18:16:05 <keverets> eliminates parethesis in nice ways.
18:16:32 <edlang> so f $ g x = f (g x) ?
18:16:40 <Riastradh> Yes.
18:18:36 <edlang> well, it's a nice trick, but I wish people wouldn't use it; being still in the beginner stage parenthesis make code a lot clearer ...
18:23:30 <keverets> unless there's many many parentheses.
18:25:36 <Pseudonym> One common use is when you're putting something in a data constructor.
18:25:48 <Pseudonym> Foo (f g h x) becomes Foo R f g h x
18:25:55 <Pseudonym> Foo $ f g h x
18:26:09 <Pseudonym> The argument is that tha latter is more readable.
23:28:21 <shapr> wheee
23:28:29 <shapr> hey tmilford, I think it was sweetcode.org
23:29:12 <Pseudonym> G'day.
23:29:20 <shapr> hi Pseudonym 
23:30:45 <shapr> tmilford: or it might have been boing-boing.net
23:30:57 <shapr> er 'boingboing.net'
23:35:42 <tmilford> shapr!
23:36:02 <tmilford> that's it.  thanks so much, especially given the very vague desc!
23:36:10 <tmilford> (sweetcode)
23:37:31 <shapr> there are only a few of those sites anyway, slashdot.org, sweetcode.org, memepool.com, boingboing.net, lambda.weblogs.com
23:37:38 <shapr> do you know of any others?
23:41:23 <Pseudonym> What do you mean by "those sites"?
23:41:40 <shapr> ADD theater sites :-)
23:41:53 <Pseudonym> I like kuro5hin.org
23:41:58 <shapr> collections of interesting things
23:43:52 <Pseudonym> Also, one maintained by a friend of mine: techdirt.com
23:47:03 <tmilford> sorry shapr, but i don't know of any more...
23:50:06 <shapr> Pseudonym: ok, those are nice
23:58:13 * shapr quickly slurps a Jolt in preparation for morning
23:58:24 <Pseudonym> Mmmm... jolt...
23:58:35 <Pseudonym> Not sure how you can slurp it quickly, though.
23:58:45 <shapr> oh what day was that where you dsecribed that spiffy text index to me?
23:59:04 <shapr> I want to improve my mailing list search plugin for lambdabot in a way that it doesn't take so much memory
23:59:12 <shapr> and those compressed text indexes sounded great
23:59:48 <Pseudonym> Can't remember offhand.
23:59:58 <Pseudonym> But I can point you at some papers if you like.
