00:00:22 <harsha123> adept: woke up just now?
00:00:44 <adept> harsha123: 9:56. 56 minutes into working day :)
00:07:22 <harsha123> adept: ok
00:10:05 <harsha123> adept: hmm. if i can ask.. do what do ya work on?
00:10:50 <adept> harsha123: IT analyst/integration man for mobile comms company
00:11:02 <harsha123> adept: ok..
00:12:20 <harsha123> adept: are all your server Debain ?:)
00:13:07 <adept> harsha123: come again?
00:15:22 <harsha123> adept: are all your servers running on Debian?
00:16:03 <adept> harsha123: if i get you right, then answer is - 99% of the "big iron" here runs various flavours of "big" unices, so it is very comvenient to run Debian on workstation. "Toy" servers (inter-department documentation, developer's sandoxes, etc) all run Debian.
00:16:38 <harsha123> hmmm Ok
00:21:54 <harsha123> adept:  are you a haskell programmer?
00:22:06 <adept> harsha123: i'm a programmer :)
00:22:58 <adept> harsha123: I dont get "C programmer" ,"C++ programmer", etc. idea. You are either programmer or you are not, and if you are that language is just a tool :)
00:24:08 <harsha123> adept: Ok.. :) that was a good answer.. 
00:29:01 <harsha123> adept:  just downloaded a debian kernel
00:29:18 <adept> downloaded or installed?
00:30:04 <harsha123> installed..  it was copied to /boot  it has got an initrd imaage and a System.map too
00:30:15 <harsha123> making changes in the lilo.conf to boot the kernel
00:31:48 <adept> harsha123: i got tired of "vi /etc/lilo.conf" year ago and switched to grub ...
00:36:30 <harsha123> adept: any problem is my initrd is big?  lilo gives me a warning
00:39:08 <adept> lilo --version?
00:39:14 <harsha123> can i comment that line out? 
00:39:18 <harsha123> just a sec
00:39:22 <adept> nope. you cant.
00:40:05 <adept> kernel does not have ide/ext2/ect compiled in - it is all in the modules, and modules required for boot up are in initrd. Without initrd you wont boot.
00:41:46 <harsha123> adept:  my present lilo.conf does not have any initrd= line at all
00:46:43 <adept> harsha123: that simply means that your present kernel has a lot of stuff compiled in, thats all.
00:46:54 <harsha123> hehehe.. Ok
00:47:48 * harsha123 is booting  a new kernel brb
00:59:18 <adept> harsha123: so?
00:59:52 <harsha123> adept: i booted my sys with the bebain kernel .. the same problem...
01:00:38 <harsha123> play a  mp3 song using mpg123 and mpg123 plays ( with out error) but no output
01:01:50 <adept> harsha123: show sndstat output?
01:02:00 <harsha123> adept: i am downloading the kernel headers for the kernel image 2.4.22-1-686
01:02:22 <harsha123> ???
01:02:48 <harsha123> sndstat? whats that?
01:03:12 <adept> harsha123: or show result of "cat /dev/sndstat" 
01:03:32 <harsha123> Ok
01:04:29 <harsha123> adept: there is no such device file in /dev
01:05:19 <adept> harsha123: strange. mpg123 should not be able to play songs then ... Show "lsmod | grep snd".
01:05:39 <harsha123> ok
01:06:23 <harsha123> nothing
01:06:45 <harsha123> adept: i just ran the script you gave me yesterday.. 
01:06:57 <harsha123> adept: havent got any error yet
01:07:50 <harsha123> adept:  no output for 'lsmod | grep snd'
01:08:37 <adept> harsha123: has it made .deb in /usr/src/modules?
01:08:57 <harsha123> adept: still compiling
01:10:32 <harsha123> adept: takin pretty long..
01:11:18 <adept> harsha123: what is in your box? CPU/RAM?
01:11:41 <harsha123> P3 with 128MB
01:12:39 <adept> hmm... should cope well enough ...
01:12:51 <harsha123> its still going on
01:13:14 <adept> harsha123: maybe you have selected all soundcards? :)
01:14:21 <harsha123> nope not all ..but a few handul maybe :)
01:15:23 <Verbed> harsha123: What type of soundcard do you have?
01:15:47 <harsha123> SiS on board..
01:16:48 <Verbed> What is the name of the module for that card?
01:17:11 <harsha123> Trident..
01:19:18 <Verbed> Is it a SIS7012 laptop?
01:19:54 <harsha123> Verbed: its a PC and I thin its SiS 7108 thats what lspci -n shows up
01:20:20 <Verbed> Have you considered trying Alsa?
01:20:42 <adept> Verbed: that's what compiling right now :)
01:20:53 <harsha123> Alsa.. thats what adept and me are dion :)
01:21:11 <Verbed> Ah, well I won't get in the way then.
01:21:21 <harsha123> adept: :) done `alsa-modules-2.4.22-1-686'
01:21:32 <harsha123> adept: ok deb is created :)
01:21:51 <harsha123> in /usr/source/modules/alsa-driver
01:22:02 <adept> harsha123: "dpkg -i alsa*.deb", then run "alsamixer" (install it if you dont have one) and unmute master/pcm channels before trying playing sound
01:22:05 <Verbed> To interject, will you also need a package for alsa utilities?
01:22:27 <adept> Verbed: it should have been pulled by dependencies already
01:22:33 <harsha123> Verbed: not sure.. :)
01:23:07 <Verbed> harsha123: Nevermind, adept seems just that.
01:23:59 <harsha123> adept: hmm says Package alsa-base not installed
01:24:09 <harsha123> should i apt-get that?
01:24:10 <adept> apt-get install alsa-base
01:24:15 <harsha123> ok
01:26:38 <harsha123> ok guys. what next ?
01:26:50 <adept> alsamixer
01:30:15 <harsha123> :((
01:33:02 <Verbed> harsha123: Problem ?
01:33:15 <harsha123> Verbed: Yes actually..
01:33:25 <harsha123>  Starting ALSA (unknown version): failed - ALSA modules not installed
01:33:44 <Verbed> Try..
01:33:46 <Verbed> modprobe snd-card-trident
01:33:58 <Verbed> Actually.
01:34:01 <Verbed> snd-trident
01:34:38 <harsha123> hmm no  says Cant loate module snd-trident
01:35:08 <Verbed> lsmod | grep snd
01:35:25 <harsha123> no output
01:35:32 <Verbed> modprobe soundcore
01:35:56 <harsha123> hmm same error
01:37:58 <Verbed> See if /lib/modules/2.4*/kernel/sound/acore exists on your system.
01:38:09 <harsha123> Ok i lll check
01:39:12 <harsha123> Verbed: no such dir.. hehehe..  i dont have any directory in the modules directory
01:39:51 <Verbed> I'm not familiar with Debian.
01:40:00 <harsha123> Ok.. 
01:40:10 <Verbed> Have you just installed the kernel?
01:40:24 <harsha123> yes Verbed .. 
01:40:31 <Verbed> Did you compile in soundcore ?
01:41:20 <harsha123> Verbed: hmm i dont think i did.. btw is soundcore a driver?
01:41:31 <Verbed> It should be compiled as a kernel module.
01:41:36 <Verbed> In order to work with Alsa.
01:42:01 <adept> Verbed: stock kernel has it compiled
01:42:24 <Verbed> Hmm.
01:42:24 <harsha123> Ok just a sec
01:42:40 <harsha123> Starting ALSA (unknown version): failed - ALSA modules not installed
01:43:10 <Verbed> harsha123: Did you do the make menuconfig && make bzImage and such manually?
01:43:33 <harsha123> no Verbed this is a Stock kernel i got from doin apt-get
01:43:54 <Verbed> I wonder where the 'stock kernel' modules are.
01:44:15 <harsha123> hmm. i am lost.. 
01:44:26 <adept> harsha123: show "ls -l /lib/modules"
01:44:32 <harsha123> Ok
01:44:40 <adept> harsha123: and "dpkg --status 'kernel-image*'"
01:45:13 <harsha123> drwxr-xr-x    4 root     root          416 Sep  4  2002 2.4.18
01:45:13 <harsha123> drwxr-xr-x    4 root     root          416 Jul 16 10:08 2.4.20
01:45:13 <harsha123> drwxr-xr-x    5 root     root          416 Sep 16 13:54 2.4.22-1-686
01:45:13 <harsha123> -rw-r--r--    1 root     root         6021 Sep 16 13:57 modprobe.conf
01:45:15 <harsha123> -rw-r--r--    1 root     root         5539 Sep 16 13:57 modprobe.conf.old
01:45:59 <adept> seems OK so far.
01:47:35 <harsha123> YEs am here.
01:48:35 <harsha123> Starting ALSA (unknown version): failed - ALSA modules not installed
01:49:37 <Verbed> ls -l /lib/modules/2.4.22-1-686
01:50:07 <harsha123> drwxr-xr-x    2 root     root           72 Sep 16 12:56 initrd
01:50:07 <harsha123> drwxr-xr-x    8 root     root          192 Sep 16 12:56 kernel
01:50:07 <harsha123> -rw-r--r--    1 root     root       121330 Sep 16 12:56 modules.dep
01:50:07 <harsha123> -rw-r--r--    1 root     root           31 Sep 16 12:56 modules.generic_string
01:50:08 <harsha123> -rw-r--r--    1 root     root          443 Sep 16 12:56 modules.ieee1394map
01:50:10 <harsha123> -rw-r--r--    1 root     root         8038 Sep 16 12:56 modules.isapnpmap
01:50:12 <harsha123> -rw-r--r--    1 root     root           29 Sep 16 12:56 modules.parportmap
01:50:16 <harsha123> -rw-r--r--    1 root     root        68111 Sep 16 12:56 modules.pcimap
01:50:18 <harsha123> -rw-r--r--    1 root     root           24 Sep 16 12:56 modules.pnpbiosmap
01:50:20 <harsha123> -rw-r--r--    1 root     root       152093 Sep 16 12:56 modules.usbmap
01:53:54 <harsha123> /lib/modules/2.4.22-1-686
01:53:54 <harsha123> /usr/share/doc
01:53:54 <harsha123> /var/lib/alsa-base
03:13:17 <harsha123> adept: Hii
03:13:41 <harsha123> Verbed: are you there ?:)
03:25:11 <kosmikus> hi Heffalump 
03:27:01 <Heffalump> hiya
03:30:10 * harsha123 is waiting for adept 
03:39:49 <Verbed> harsha123: Hello.
03:40:17 <harsha123> Hiii Verbed........ My Sound WORKS :))
03:40:33 <Verbed> Did the modifications to modules.conf do it?
03:40:58 <harsha123> Verbed: not sure.. but i had booted the wrong kernel :))
03:41:04 <Verbed> :)
03:41:05 <Verbed> I've done that.
03:41:32 <harsha123> Verbed: finally i could hear to a system of a down number :))
03:41:50 <harsha123> Verbed: thank you for the help
03:41:55 <Verbed> You're welcome.
03:52:15 <adept> harsha123: so, everything worked out?
03:52:27 <harsha123> adept: Hiiiiiiiii.. Yep :)
03:52:34 <harsha123> adept: thanks a many.. 
03:52:42 <harsha123> adept: i booted the wrong kernel
03:53:00 <harsha123> adept: i 've to configure X for the new kernel image..
03:53:14 <adept> harsha123: nvidia?
03:53:27 <harsha123> adept: xf86config right?
03:53:33 <harsha123> adept: hmm no.. SiS again
03:54:12 <adept> dpkg-reconfigure xserver-xfree86
03:54:55 <harsha123> adept: Ok
03:55:36 <harsha123> adept: i am goin for  reboot.. catch ya from ircII
03:55:51 <adept> harsha123: why reboot?
03:56:14 <harsha123> adept: i booted my old kernel
03:56:15 <adept> harsha123: the only thing that requires reboot is kernel upgrade. period.
03:56:22 <adept> harsha123: i see :)
03:56:33 <harsha123> adept:  brb ok?
03:56:39 <adept> harsha123: btw, try to join #debian sometimes :)
03:56:52 <harsha123> adept: hehehe. i am in debain :))
03:57:23 * harsha123 found haskell useful too :)
03:57:34 <harsha123> especially you guys.. :)
03:57:45 <harsha123> ok brb
04:02:45 <harsha> ls
04:04:08 <z0d> Good day
04:04:57 <z0d> in the definition of length " .... length (x:xs) = 1 + length xs", how does Haskell know that x is the first element of the list and xs is the rest?
04:05:00 <ski> good day, z0d
04:05:05 <harsha> adept: got my X running too :)
04:05:24 <cm> hiho
04:05:29 <ski> the thing on the left of : is defined to be the first element
04:05:33 <ski> cm : hi
04:05:51 <harsha> users
04:06:23 <ski> z0d : and the thing on the right of : is defined to be the rest of the list
04:06:44 <z0d> oh. I see, thank you
04:06:55 <z0d> so it  is defined to be that way
04:07:24 <ski> so 1:[2,3,4] is [1,2,3,4] and not, say [2,1,3,4] or [2,3,4,1]
04:07:28 <harsha> how do i see the list of all the users in ircII?
04:07:38 <ski> on this channel ?
04:07:44 <harsha> ski yes
04:07:47 <z0d> harsha: /names #channel
04:07:49 <ski> hmm
04:07:56 <ski> ok
04:08:48 <adept> @type :
04:08:52 <adept> @type (:)
04:08:53 <lambdabot> (:) :: a -> [a] -> [a]
04:09:01 <adept> z0d: see?
04:09:09 <ski> z0d : the [1,2,3] notation is actually syntactic sugar for 1:(2:(3:[]))
04:09:17 <harsha123> adept: Ok .. X works now.. :)
04:09:55 <ski> z0d : that last thing can be written as simply 1:2:3:[], because : associates to the right
04:09:57 <z0d> I got it
04:10:23 <ski> so list are really built up from the empty list, by adding elements to the front
04:10:37 <ski> s/list/lists/
04:10:41 <ski> good
04:11:12 <z0d> are lists implemented as linked lists?
04:11:23 <ski> usually, i think
04:11:57 <ski> one can think of them in that way
04:12:22 <z0d> why does hugs gives me an error with "inc n = n+1"
04:12:30 <z0d> Syntax error in input (unexpected `=')
04:12:41 <ski> ah
04:12:54 <ski> you should be writing definitions in a *.hs file
04:13:04 <z0d> I see, thanks
04:13:28 <ski> hugs doesn't support making (permanent) definitions in the interactive repl
04:14:11 <ski> though you can write "let inc n = n+1  in  inc(inc(4))*3"
04:15:03 <Igloo> inc(4)? How disgustingly C-like  :-)
04:15:06 <ski> this was a local definition, only usable in the expression following the "in" (i.e. not usable after you have hit the return key)
07:19:18 <harsha123> adept: in the script which ya gave me.. where does it exactly build the deb package?
07:19:55 <adept> harsha123: invocation of "debian/rules" (which is a makefile, btw)
07:20:29 <harsha123> adept: hmm Ok.. i was trying to analyze what exactly you did
07:21:17 <adept> harsha123: i scripted /usr/share/doc/alsa-source/README.gz :)
07:22:15 <harsha123> adept: was that your script ? :)
07:22:38 <adept> make-alsa-bla-bla? yep.
07:22:48 <adept> or which one?
07:23:20 <harsha123> yeah the make-alsa-blah-blah :))
07:23:56 <harsha123> adept: are you still at work?
07:28:10 <adept> harsha123: i'm leaving
07:28:18 <harsha123> adept: what does fakeroot do? and when do you exactly use it?
07:29:23 <Igloo> It pretends you are root so you can do things like chown files root so they end up right in tarballs
07:36:51 <Tomasso> what type does this expression have????
07:36:52 <Tomasso> fix f x = f (fix f) x
07:38:57 <harsha123> Igloo: can i have an example?
07:39:05 <ski> what expression ?  fix ?  fix f x ?  f (fix f) x ?
07:39:42 <Igloo> Tomasso: If you want to work it out then start by giving each variable a type variable and then write down the constraints and solve them bit by bit
07:39:45 <Lunar^> Does it makes sense to write ModifyMVar2 :: (MVar a, MVar b) ...
07:39:46 <Lunar^> ?
07:40:07 <Igloo> harsha123: Of what? Just run it
07:40:09 <Lunar^> Tomasso: in Haskell fix :: a -> a -> a
07:40:19 <harsha123> Igloo:  of fakeroot
07:40:22 <ski> Lunar^ : modify them both atomically ?
07:40:29 <Tomasso> hmh its still dificult
07:40:33 <Lunar^> Tomasso: in a strict language it would have (a -> b) -> (a -> b) -> (a -> b)
07:40:33 <Igloo> Lunar: That's not the type of what he's given there
07:41:14 <Tomasso> mh i know that fix get smth and returns smth
07:41:21 <Igloo> And the evaluation order can't affect the type
07:41:22 <Tomasso> fix:: (a -> b)
07:41:27 <Lunar^> Igloo: right sorry
07:41:48 <Lunar^> strange
07:41:51 <Igloo> harsha123: Run fakeroot, chmod a file to root and then look at it with ls -l or something
07:42:04 <Tomasso> then a = a function f:: (c -> d) and a parameter x:: ??
07:42:33 <Lunar^> "fix f x = f (fix f) x" has different type than "fix f = f (fix f)"
07:42:35 <Darius> (a -> a) -> a and ((a -> b) -> (a -> b)) -> (a -> b)
07:43:00 <Lunar^> strange
07:43:04 <Tomasso> how do i interpret this?, (fix x) is returning a function? f (fix f) x
07:43:30 <harsha123> Igloo: hmm ok got an idea now.. 
07:43:30 <Lunar^> fix : the mind twister :)
07:44:21 <Darius> Why is it strange that 'fix f x = f (fix f) x' has a different type than 'fix f = f (fix f)'?
07:44:51 <Tomasso> hmhm what a mess
07:44:58 <Tomasso> hm
07:46:21 <Lunar^> Darius: can't explain
07:46:29 <Lunar^> Darius: miss some type theory background here
07:49:27 <Darius> what type theory is needed?
07:49:34 <Lunar^> I dunno
07:49:46 <Lunar^> (+) 1 :: Int -> Int
07:49:56 <Lunar^> \x -> (+) 1 x :: Int -> Int
07:50:00 <earthy> it's not that odd, as fix f x = f (fix f) x   is a fixed point over the functionspace f : a -> b, whereas  fix f = f (fix f) is a fixed point over the the space f : a
07:50:04 <ski> so you can't explain why you think it is strange ?  :)
07:50:29 <Lunar^> the eta-contraction (right way to call it ?) does not modify the type here
07:50:34 <Igloo> Do you think it strange that  foo x y = x y  and  foo x = x  have different types too?
07:50:47 <earthy> lunar^: what eta-reduction step?
07:51:00 <Igloo> It doesn't modify it with + as it knows what type + has to have
07:51:12 <earthy> (+) == \x y -> add x y    so (+) 1 == \y -> add 1 y
07:51:29 <Lunar^> Mhhhhhh ok
07:51:30 <Lunar^> got it
07:51:32 <ski> + is already constrained to have (at least) two (curried) parameters
07:51:48 <Lunar^> In fix definition, the type system infers f type right on
07:51:57 <Tomasso> mmh
07:52:07 <earthy> whereas the   fix f    and   fix f x    are diferrently typed... due to inference...
07:52:33 <ski> but if f is not constrained elsewhere there is a difference in type of "f" and "\x -> f x" because the latter constrains f to be a function
07:52:40 <Lunar^> fix f x y = f (fix f) x y would have ((a -> b -> c) -> (a -> b -> c)) -> (a -> b -> c), right ?
07:52:50 <ski> yes
07:53:01 <Lunar^> ok
07:53:08 * earthy nods
07:53:17 <Lunar^> Is there anything related to lazyness here also ?
07:53:20 <harsha123> bye everyone.. :
07:53:32 <Darius> Not for the types.
07:54:50 <Lunar^> could you define fix f = f (fix f) in caml ?
07:55:11 <Darius> Not meaningfully.
07:55:18 <ski> it hangs
07:55:39 <Lunar^> and with an eta-expansion ?
07:55:53 <Darius> Then it works.
07:56:32 <Lunar^> Could someone try to explain why ?
07:56:44 <ski> eta-expansion delays recursive application of fix on f to when then next argument is given
07:57:13 <Lunar^> so lazyness matters here ?
07:57:39 <ski> (i.e. when the newly constructed recursive function "fix \x -> blaha" is applied to an x)
07:57:47 <ski> it matters for termination
07:57:50 <ski> but not types
07:58:02 <Lunar^> ok thanks all :)
07:58:33 <ski> (in impure languages it also matters for when and how many times an effect is performed)
08:42:40 <SyntaxPolice> is there a postgres interface for haskell?
08:44:09 <Lunar^> yes
08:44:21 <Lunar^> Look at HToolkit CVS
08:45:34 <SyntaxPolice> Lunar^: got it, thanks
08:53:09 <esap> Does anyone else think code that pattern matches one alternative of a data structure but not every one is badly designed?
08:53:49 <Lunar^> depends
08:54:39 <Smerdyakov> You mean it fails if the value doesn't match that alternative?
08:54:45 <Igloo> I generally put a catch-all can't-happen error in to silence -Wall warnings
08:55:14 <Igloo> Of course, if it *can* happen it's just broken  :-)
08:55:19 <Smerdyakov> I generally write a projection function for such cases, so I only need one catch-all taking up space.
08:55:25 <ski> esap : do you mean missing, overlapping, or variable/wildcard patterns ?
08:55:27 <Smerdyakov> Yeah, and I make that function fail with a descriptive message.
08:55:27 <esap> smerdyakov: well like if you have data Tree a = Null | Fork a (Tree a) (Tree a) then code like 'minElem (Fork x a b) = x' [without case for Null].
08:56:00 <Smerdyakov> Of course, I usually write these things in ML. I don't know how you "fail with an error message" in Haskell.
08:56:16 <Igloo> error "Foo!"
08:56:20 <Smerdyakov> Fantastic!
08:57:54 <esap> The problem I see with 'error' is that there is no well-defined way of catching that error [so it's not a proper error-handling primitive], and it's very hard to know when you've accidentally written code that may cause that kind of error to happen. I would rather avoid that kind of errors during type checking.
08:59:38 <Smerdyakov> Mm. Now's when you wish for ML-style monad-free exceptions, eh? ;)
09:00:09 <Igloo> You can catch it in current implementations if not H98, I believe
09:00:13 <Smerdyakov> However, you can make the argument that you always use this partial pattern match when you have proved to yourself that it never fails.
09:00:27 <Igloo> I don't think you should be catching it in general, though
09:00:33 <Smerdyakov> So the error is only triggered during debugging and need not be handled gracefully.
09:00:39 <Igloo> module-loading systems like lambdabot being the only exception I can think of
09:00:46 <esap> smerdyakov: you would have to prove it when you write the use of 'error'. I don't think that's possible.
09:01:02 <Smerdyakov> No, you prove it for each call to the projection function.
09:01:15 <esap> smerdyakov: but that's too late.
09:01:21 <Smerdyakov> Why?
09:02:01 <esap> smerdyakov: because the interface of the projection function doesn't demand that you do that. The erroneous case is just invisible to the user of the function.
09:02:31 <Smerdyakov> You give the projection function a precondition (in your head or in comments), and you prove that it is satisfied for each call.
09:04:13 <esap> smerdyakov: Well, I think the problem is, I, as a library writer, would like to design the thing so that clients of the library never need to worry about that. How do I do that?
09:04:41 <esap> smerdyakov: because mostly, they don't.
09:05:00 <Igloo> esap: This logic doesn't work for exported functions
09:05:02 <ski> or at least that they become away of the problem if they call the function incorrectly ..
09:05:34 <esap> igloo: oh, you cannot export projection functions?
09:05:44 <Igloo> It's when you want to do if is_a_bar x then wibble x else flibble x and not have to worry about the bar/not-bar distinction in wibble and flibble in the same module
09:05:51 <ski> (at run-time, or better, at compile-time)
09:06:21 <Igloo> esap: You can, but then you have to worry about all cases
09:07:11 <esap> igloo: hmm.. ok, that's a good design principle. [Someone tell the designers of the standard prelude that :-) ]
09:08:02 <Igloo> ghc's prelude tends to have errors I think
09:08:28 <Igloo> But they can't be very meaningful anyway - you need higher level errors where you call head, say, onw hat might be an empty list
09:11:08 <esap> True, but I think this (e.g. head, tail etc) are still a compromise between correctness and convenience. I would always go for correctness in those cases.
09:11:51 <Igloo> I'm slightly confused - do you think ghc's head is correct?
09:12:06 <Igloo> Or are you saying its type should be [a] -> Maybe a?
09:12:32 <esap> It's type should be (Monad m) => [a] -> m a.
09:12:58 <ski> not MonadZero ?  (or is it only MonadPlus now ?)
09:13:15 <esap> ski: Monad has 'fail' nowadays.
09:13:17 <Igloo> Hmmm, I'll stick to it as it is I think  :-)
09:14:18 <esap> I think projection functions of _finite_ data structures need to be in a monad.
09:14:37 <ski> esap : i know, but does isn't that for match-failures in do-syntax ?   should it be used as well for simple error/failure/exception monads ?
09:14:41 <Lunar^> Where I love to use head is in case when I know that the list cannot be empty
09:14:53 <Lunar^> Can't do that with Monad
09:15:14 <ski> esap : what do you mean by finite ?
09:15:19 <Lunar^> case head l of ...
09:15:31 <ski> esap : do you mean algebraic, as opposed to coalgebraic ?
09:15:44 <esap> ski: I mean something that you can browse it indefinitely without hitting 'null' etc.
09:16:16 <esap> ski: oh I think you might be right about the naming, I should have said algebraic.
09:16:18 <Igloo> Lists are potentially infinite
09:16:26 <ski> esap : like a (coalgebraic) stream then, e.g.
09:16:32 <esap> ski: yes.
09:16:53 <Igloo> Don't you really mean datastructures without choices?
09:17:04 <esap> "without choices" Maybe.
09:17:22 <esap> igloo: but actually, it can have choices, but all choices must lead somewhere.
09:17:42 <esap> igloo: that is, projection functions never fail.
09:18:17 <Igloo> But if you have List a = Cons (List a) (List a) | Cons2 (List a) (List a)  you can still write head (Cons x y) = x and it'll fail for a Cons2
09:19:02 <ski> this is an algebraic datatype, he means coalgebraic ones
09:19:33 <Igloo> Meaning?
09:19:52 <esap> igloo: Well algebraic data type would work, if you only provided projections that apply to each alternative. The 'head' clearly does not satisfy that constraint.
09:20:26 <esap> igloo: that is, you would have to write 'head (Cons x y) = x ; head (Cons2 x y) = y' and it would be valid projection function.
09:20:42 <Igloo> But for Foo a b = Bar a | Baz b you can't do that without undefined or error
09:21:07 <ski> algebraic types is based on constructors. constructors are "canonical" for them
09:21:20 <esap> igloo: right.
09:21:26 <Igloo> And more to the point there are cases in programming where it just doesn't make sense, because you *know* you are working on Bars and Bazs have no meaning for this function
09:21:38 <ski> coalgebraic types is based os selectors/projections
09:21:38 * Igloo doesn't see how this is really helping anything
09:22:21 <Igloo> It sounds like you want to eliminate what are essentially runtime type errors completely, in which case you end up with an incomplete language
09:22:23 <esap> igloo: right. The idea is that _if_ you choose to use algebraic data types, I think the projection functions should also be typed to express that fact [that is, use monadic failure in the interface]
09:22:56 * Igloo will stick to good old Haskell I think  :-)
09:23:54 <esap> In other words, having _both_ algebraic data types _and_ projections that do not return an error is getting too much [it's theoretically impossible to get that working well]
09:25:34 <esap> I'm not quite sure about the impossible part, but at least current design doesn't do it.
09:27:12 <esap> igloo: but run-time errors are OK, as long as it's the programmer's choice to get the run-time error, not an accident.
09:27:49 <Lunar^> Making exceptions appears in types like in Java ?
09:28:17 <esap> lunar: well Haskell does it as well [monads already say that], but yes.
09:28:56 <Igloo> esap: So you can already get that with an _ -> error "Foo" case
09:29:39 <esap> igloo: no, you can't catch that, and it's not visible in the type [or at least I don't know how to declare a function that could never produce that kind of errors]
09:29:40 <ski> perhaps a reflected monad is the nicest way to have effects (s.a. exception) with not so much hassle, and still be able to reify (in this case, catch exceptions) at a higher level
09:30:12 <ski> but then the language (or at least some-subparts) are unpure :(
09:31:18 <Igloo> esap: You can catch it, but that's not the point because something's gone wrong so you want your program to die anyway
09:32:15 <esap> igloo: but that must never occur [my requirements are stricter that that]
09:32:29 <Igloo> what must never occur?
09:32:38 <esap> igloo: that the program dies.
09:32:54 <esap> igloo: so you have to prevent those errors.
09:33:03 <Lunar^> so you catch everything
09:33:07 * Igloo gives up
09:33:23 <Lunar^> or maybe Erlang would be a better language here
09:33:38 <Darius> He wants partiality to be an effect.
09:34:02 <ski> it is
09:34:15 <ski> as nontermination
09:34:22 <Darius> Basically, outlaw error, give 'div' the type :: Int -> NonZeroInt -> Int, and have fix be part of the NonTermination monad.
09:34:33 <Darius> and such things.
09:34:55 <Darius> The result would be a machine provable language for the "pure" parts
09:35:16 <esap> darius: yes, that is exactly what I'd like to see.
09:35:48 <Igloo> NonZeroInt leads to undecidability
09:37:28 <esap> igloo: oh you're right, but that can be solved by  to_nonzero :: (Monad m) => Int -> NonZeroInt
09:37:47 <esap> igloo: (Monad m) => Int -> m NonZeroInt
09:38:24 <esap> igloo: you just postpone such checks to run-time.
09:40:36 <esap> igloo: Then you would place the burden of proof that the software works to the programmer where it belongs.
09:41:29 <ski> bye
09:41:49 <cm> what does that a :: b => c syntax mean?
09:42:10 <ibid> a has the type b => c
09:42:17 <ibid> (more or less:)
09:42:21 <cm> meep :)
09:42:42 <meep_> not really, that would be ->, not =>
09:43:10 <Darius> it would be either
09:43:13 <ibid> meep_: uh? yes really
09:43:17 <cm> oh shit, there's someone called meep :)
09:43:27 <cm> wasn't intentional to say your nick, sry :)
09:43:34 <meep_> ? but => introduces a type class constraint
09:43:54 <ibid> meep_: true; i consider the constraint as being part of the type
09:44:02 <Darius> yes, so it's malformed for that unless we assume b and c are metasyntactic
09:44:21 <meep_> Darius: that's what i meant, thanks
09:44:24 <ibid> (metalinguistic, we are not describing syntax here:)
09:44:45 <meep_> well we are, because the a in a => b would have to be something like (Num a)
09:45:05 <Darius> and b would have to contain a
09:45:11 <esap> (Num a)  denotes a constraint 'Num' on the universally-quantified type variable a.
09:45:11 <meep_> indeed ;)
09:45:31 <cm> ok gotcha, i guess.. bla :: (Num a) => a -> a would take any instance of Num?
09:45:42 <meep_> yes
09:46:15 <ibid> not in that sense; a metasyntactic variable is a variable in metasyntax, ie. the language that describes syntax. we are not talking about productions or nonterminals; b and c are variables in the metalanguage, ie. metalinguistic variables
09:46:16 <cm> ta :)
09:46:52 <ibid> (iow, metasyntactic is appropriate if the metalanguage is a syntax description language; it isn't here:)
09:46:53 <meep_> erm, i don't think i agree ibid, but there's no point arguing about it i guess
09:47:33 <ibid> i would like to hear counterarguments, but if you feel they are too off-topic, whatever :)
09:47:49 <Darius> let's say metavariable and all be happy
09:47:55 <ibid> :)
09:47:57 * meep_ is happy
09:48:00 * ibid too
09:48:11 * esap doesn't like meta-X for any X.
09:48:47 <meep_> "meta" does have a lot of bullshit potential
09:49:11 <ibid> esap: what do you then call the language where another language is embedded, if not a metalanguage?
09:49:47 <ibid> (in the context where the embedded language is being discussed using the metalanguage)
09:50:52 <esap> ibid: implementation language for an interpreter?
09:51:24 <ibid> esap: my contex for this issue is more in the area of logic :)
09:51:49 <meep_> i see it more as a metacontext ;)
09:52:44 <ibid> but, for programming context, on this channel a kind of english is the metalanguage and haskell is the (object) language
09:52:50 <ibid> meep_: context of a context?
09:53:35 <meep_> well, it wasn't supposed to mean anything really
09:53:53 <meep_> but i suppose that's what it would be
09:55:16 <esap> ibid: hmm.. do you mean 'language of a model' with 'metalanguage'? or something like that?
09:55:37 <meep_> a metalanguage is just a language for describing a language
09:56:06 <ibid> esap: not sure what _you_ mean with 'language of a model' :)
09:56:50 <esap> meep: you mean like BNF is a metalanguage?
09:57:03 <ibid> yes
09:57:36 <meep_> another example would be words like 'noun' and 'verb' - they're literally metalinguistic
09:57:42 <ibid> BNF is a metalanguage that describes syntax; some people call that a metasyntax (hence, metasyntactic variable 'variable in the metasyntax)
09:58:14 <ibid> yes, but natural language is special in that it is capable of being its own metalanguage :)
09:58:16 <esap> Ok, for that use, I guess meta-prefix works fine.
10:01:59 <esap> But actually, I think meta-X is most often used for semantic context to denote "jump out of the system" to a system that can explain the rules of the system itself.
10:02:13 <ibid> yeah, that it is
10:02:27 <ibid> metalanguage is exactly that :)
10:02:58 <ibid> (well, a language where you can talk about another language outside the box)
10:03:48 <esap> Oh, but I understood metalanguage was considered somehow syntactic notion
10:04:12 <esap> Maybe I misunderstood.
10:04:41 <ibid> the canonical (at least i think of it that way) example is tarski's definition of truth
10:05:08 <ibid> which makes absolutely no sense until you separate language and metalanguage
10:16:50 <esap> Oh btw, relating to this metalanguage vs. language discussion, I think the distinction is best visible when you consider 'axioms' or 'primitives' of a language. Those would have to be 'implemented' in the metalanguage.
10:17:40 <ibid> not necessarily
10:18:02 <ibid> but yeah
10:20:00 <esap> In a sense, primitives form a kind of "interface" between a formal system and its environment.
10:20:39 <ibid> i'm not accustomed to think that way, since in logic there are no primitives to implement :)
10:20:42 <ibid> hmm
10:20:46 <ibid> there is, actually
10:21:01 <ibid> the model of the logic "implements" the "primitives" of the logic
10:21:10 <ibid> but model is not a metalanguage in this sense
10:21:21 <esap> ibid: ok, why?
10:22:03 <ibid> i only have a vague notion why: because i place the metalanguage "above" the language and the model "below" the language, when i think spatially
10:22:07 <ibid> :)
10:22:34 <ibid> there may be better reasons but i can't think of any right now
10:22:44 <esap> ibid: oh, but isn't there a 'meta-language' both "above" and "below" the system?
10:23:17 <esap> ibid: the one "above" considers the whole system as an indivisible unit, and the one "below" implements the primitives of the system.
10:23:26 <Darius> A metalanguage is usually used to abstract over a language.
10:24:08 <ibid> i don't think of the one below as a metalanguage; when i say metalanguage, i expect to find metavariables, which are variables that range over strings of the (object) language
10:24:39 <ibid> (actually, i don't think of them as strings but as trees:)
10:24:48 <esap> ok, so am I correct that the proper name for the one "below" is 'model' and 'metalanguage' is the one above.
10:25:04 <ibid> at least in logic :)
10:25:38 <ibid> and model isn't really a language; it can actually be discussed in the 'above' language :)
10:27:15 <ibid> the model is the real thing that the language discusses :)
10:27:28 <ibid> at least in some sense...
10:29:48 <esap> Well I've thought of it like 'layers' in some OO software, you have "upper layers" that can refer to lower layer concepts, and lower layers that cannot refer to upper layer concepts.
10:30:31 <esap> And those form a nice tree-form hierarchy.
10:30:38 <Smerdyakov> Hey y'all! Check out something I'm working on: http://pldb.net/
10:31:52 <esap> wasn't there already "FundamentalConcepts" in Haskell wiki? :-)
10:32:08 <Smerdyakov> esap, are you talking about my thingy?
10:32:12 <meep_> is it a database of programming language features?
10:32:28 <esap> smerdyakov: yes, looks like that page.
10:32:36 <Smerdyakov> meep_, it's a wiki database of programming language information, designed to be queryable to highlight connections between languages, features, etc..
10:33:02 <meep_> cool
10:33:28 <Smerdyakov> It uses a general system I'm working on for maintaining an arbitrary relational database wiki-style. (http://relwiki.sf.net/)
10:34:24 <esap> what are those 'events' and 'eventLinks'?
10:34:56 <Smerdyakov> esap, historical timeline events, and links that show an event involves a programming language.
10:35:51 <meep_> so is it basicallly a relational datbase that anyone can edit?
10:36:21 <keverets> is there a wiki written in Haskell?  If so, is anyone using it?
10:36:40 <Smerdyakov> meep_, yup.
10:36:57 <Smerdyakov> meep_, with the usual wiki version contro.
10:36:58 <Smerdyakov> l
10:37:14 <meep_> Smerdyakov: nice :)
10:37:22 <Smerdyakov> meep_, and the whole site is generated from a small description of a database.
10:37:59 <meep_> what's it written in?
10:38:19 <esap> can it generate graphical description of the relationships between different things in it? That would be useful.
10:38:32 <Smerdyakov> Standard ML & an SML dynamic web site tool I've made (http://smlweb.sf.net/)
10:38:44 <Smerdyakov> esap, you can use standard SQL queries in any language you choose to do that.
10:39:58 <esap> ok cool
10:40:39 <esap> hmm.. "Has index" part displays question marks, is that the intention?
10:40:54 <Smerdyakov> I'm going to take links out of the index some time soon.
10:41:02 <Smerdyakov> There isn't a naming function for the links, so they show up like that.
10:45:26 <esap> I think the initial organization of that thing has to be thought of carefully.
10:46:08 <Smerdyakov> Yup.
10:46:18 <Smerdyakov> I consider this to be somewhat of an alpha version. :)
10:47:29 <esap> Hmm.. would an entry like "semantics" be a good idea for the top level [that is, description of semantics of different features, to distinguish variations of similar things]
10:48:10 <esap> Or do you consider them as different features?
10:48:34 <Smerdyakov> Well, first off, it's a relational database, so everything is "top level." :)
10:49:01 <Smerdyakov> One thing I was meaning to put in that I just realized a forgot is classification of features into different groups.
10:49:07 <Smerdyakov> Maybe that would subsume your suggestion
10:49:07 <Smerdyakov> ?
10:49:22 <esap> yea, maybe
10:51:12 <esap> Can that be generalized without trouble, e.g. allow also grouping of languages, projects, events, etc.
10:51:42 <Smerdyakov> Yes. Any relations with fields that refer to others.
10:55:27 * Smerdyakov goes to class.
12:03:53 <Xcalibor> hiyas :)
15:04:33 <cm> mmm
15:04:50 <cm> if i want to instantiate a type class for a polymorphic type.. how is the syntax for that?
15:05:00 <cm> instance Num Foo a where .. ?
15:06:50 <hdaume> what do you mean?
15:06:55 <hdaume> instance Num (Foo a) where ... ?
15:10:08 <cm> ah
15:11:05 <Riastradh> Er, don't you need to quantify a first?
15:11:23 <hdaume> well, presumably
15:11:29 <hdaume> unless it's 'data Foo a = Foo Int' :)
15:11:54 <Igloo> You could have x + y = x or x + y = undefined etc
15:12:08 <cm> was trying to do something like "data Vector3 a = (a,a,a)" and instance Num (Vector3 a) where ..
15:12:32 <hdaume> then you want 'instance Num a => Num (Foo a) where ...'
15:13:31 <cm> and, umm, stupid question.. is there something like map which takes 2 lists instead of one and thus passes 2 params to the function instead of 1?
15:13:39 <hdaume> zipWith?
15:14:06 <hdaume> dot v1 v2 = sum $ zipWith (*) v1 v2, for instance
15:14:39 <cm> ah :)
15:14:41 <cm> thanks
15:19:26 <cm> hmm, what's wrong in "newtype Vector3 = Vector3 (Float, Float, Float); instance Num Vector3 where (+) = zipWith (+)" :|
15:20:24 <hdaume> because zipWith is a function on lists, not tuples
15:20:52 <cm> oh duh.. time to go to bed i guess.
15:27:33 <__Ace__> ok, anyone here got some time with me? :)
15:28:58 <Riastradh> Just ask your question.
15:29:42 <__Ace__> its abit complicated..
15:29:44 <__Ace__> hmm
15:30:03 <__Ace__> well
15:30:03 <__Ace__> ok
15:30:20 <__Ace__> basiclly I wanna make this "match" function to work like this.
15:30:21 <__Ace__> :
15:30:38 <__Ace__> example 1: match 'x' "2*x+3" "2*7+3" = Just "7"
15:30:53 <__Ace__> ex 2: match '*' "frodo" "gandalf" = Nothing
15:31:10 <__Ace__> ex 3: match '*' "* and *" "you and me" = Just "you"
15:31:26 <__Ace__> ex 4: match 'x' "2*x+3+x" "2*7+3" = Nothing
15:31:33 <__Ace__> think that is enough examples
15:31:35 <__Ace__> now
15:31:37 <__Ace__> so far I've done:
15:32:11 <__Ace__> match _ [] [] = Just []
15:32:14 <__Ace__> match _ [] _  = Nothing
15:32:16 <Riastradh> Is this a homework exercise?
15:32:31 <__Ace__> well, part of a BIG one
15:32:36 <__Ace__> dont want solutions
15:32:40 <__Ace__> just hints
15:32:49 <Riastradh> OK, then I guess finding you a regexp library won't be very helpful.
15:32:55 <Igloo> What should    match '*' "* and *" "you and me and them"   be?
15:33:15 <__Ace__> Just "you"
15:33:29 <__Ace__> there is some use of Maybe here
15:33:29 <Igloo> Not Just "you and me"?
15:33:36 <__Ace__> no
15:33:43 <__Ace__> only the first one is "returned"
15:34:09 <Igloo> And  match '*' "* and wibble" "you and me and them"  should be Nothing?
15:34:42 <__Ace__> um, no, that should also be: Just "you" I think
15:35:01 <Igloo> I don't understand the problem then
15:35:23 <Riastradh> Example 4 and 'match '*' "* and wibble" "you and me and them"' confuse me, then.
15:35:53 <__Ace__> The function match wildcard p s tries to match the two lists p and s. The list p is considered a pattern which may contain elements equal to wildcard. The list s may not contain any wildcards. The pattern p is said to match the list s if every element in p matches corresponding elements in s. A non-wildcard matches a single element in s if they are equal and a wildcard matches an arbitrarily long sublist. If the two lists match, the function returns
15:36:32 <Igloo> So match '*' "* and wibble" "you and me and them" is Nothing then
15:36:46 <__Ace__> oh
15:36:48 <__Ace__> yea, think so
15:36:50 <__Ace__> :)
15:37:08 <Igloo> And the answer to my previous question isn't covered by that specification
15:37:39 <Igloo> Which implies they'll accept either
15:37:47 <__Ace__> hmm
15:38:01 <Igloo> OK, so pick a case that isn't covered by what you have so far
15:38:21 <__Ace__> but maybe we can take matches that aint more than 1 char
15:38:37 <__Ace__> forgot this example:
15:38:37 <__Ace__> match 2 [1,3..5] [1,3..5] = Just []
15:39:10 <__Ace__> its not me making this function up, so Im no expert in what _exactly_ is supposed to do
15:39:16 <Igloo> Urgle
15:39:18 <__Ace__> I know just what I pasted here
15:39:34 <Igloo> Oh, right, yes
15:39:50 <__Ace__> anyway
15:39:53 <__Ace__> so far I have done:
15:39:59 <Igloo> Actually, no
15:39:59 <__Ace__> match _ [] [] = Just []
15:40:05 <__Ace__> match _ [] _  = Nothing
15:40:08 <__Ace__> match _ _ []  = Nothing
15:40:13 <__Ace__> match wildcard (x:xs) (y:ys)
15:40:13 <__Ace__> 	| x == y = match wildcard xs ys
15:40:13 <__Ace__> 	| x == wildcard = [y] ++ match wildcard xs ys
15:40:13 <__Ace__> 	| otherwise = "Wrong"
15:40:24 <__Ace__> works "rather" good
15:40:35 <Igloo> Are these examples given to you or did you invent them?
15:40:44 <Darius> well
15:40:47 <__Ace__> given
15:40:48 <Riastradh> Um, the "Wrong" bit is wrong.
15:40:49 <Xcalibor> laters!
15:41:13 <Igloo> The match 2 one makes little sense to me
15:41:52 <__Ace__> hmm, both lists are the same.. but no match
15:42:17 <Igloo> What is your code going to do with   match 'x' "x" "xy"?
15:42:39 <__Ace__> Just "x" I think
15:43:05 <Igloo> Step through it
15:43:44 <__Ace__> actually:
15:43:45 <Igloo> You'll also want to check the types of your alternatives
15:43:45 <__Ace__> "In the equation for the case of two non-empty lists you have to consider the two cases where the first element of the pattern is a wildcard and when it is not:
15:43:47 <__Ace__> "
15:43:56 <__Ace__> "1. If it is not a wildcard the two lists match if the first elements are equal and the rest of the lists match. 
15:44:05 <__Ace__> "2. When the first element is a wildcard there are two possible. ways to reach a match. If the rest of the list matches with the rest of the pattern, i.e. the front wildcard removed, then it is a one element match. Or if rest of the list matches with the pattern with the wildcard retained at the front, it is the beginning of a longer match. Otherwise the lists don't match. 
15:44:18 <__Ace__> maybe that helps you understand my problem abit more
15:44:53 * Igloo would suggest trying to keep the specification and code better correlated
15:45:15 <__Ace__> yea, blame the teacher
15:45:37 <__Ace__> http://www.cs.lth.se/Education/LU/kurser/dat116/assignment1/
15:46:46 <__Ace__> check there at 2. Pattern matching
15:49:02 <__Ace__> any tips for me?
15:49:13 <__Ace__> Im kinda stuck
15:50:09 <Igloo> Write down what the specification says, but do it in Haskell rather than English
15:50:59 <__Ace__> uh
15:51:02 <__Ace__> ?
15:51:26 <__Ace__> if I do that I solve the problem.. but thats exactly what Im having trouble with
15:51:53 <Igloo> OK, can you write code for case 1 above?
15:52:14 <__Ace__> you mean match 'x' "2*x+3" "2*7+3" = Just "7"
15:52:15 <__Ace__> ?
15:52:25 <Igloo> No, the bit you just pasted
15:52:34 <__Ace__> ?
15:52:47 <Igloo> < __Ace__> "In the equation for the case of two non-empty [...]
15:52:58 <__Ace__> hmm
15:53:10 <Igloo> Which is a recursive description of the problem, right? And you want a recursive function?
15:53:21 <__Ace__> match wildcard (x:xs) (y:ys)
15:53:21 <__Ace__> 	| x == y = match wildcard xs ys
15:53:21 <__Ace__> 	| x == wildcard = [y] ++ match wildcard xs ys
15:53:21 <__Ace__> 	| otherwise = "Wrong"
15:53:24 <__Ace__> got that
15:53:39 <__Ace__> but that doesnt work with "Just 7" only "7"
15:53:40 <Igloo> That's all for case 1?
15:53:48 <__Ace__> hmm
15:54:28 <__Ace__> case 1 got 2 steps
15:54:32 <__Ace__> 1. If it is not a wildcard the two lists match if the first elements are equal and the rest of the lists match
15:54:38 <__Ace__> and
15:54:49 <__Ace__> 2. When the first element is a wildcard there are two possible. ways to reach a match. If the rest of the list matches with the rest of the pattern, i.e. the front wildcard removed, then it is a one element match. Or if rest of the list matches with the pattern with the wildcard retained at the front, it is the beginning of a longer match. Otherwise the lists don't match. 
15:54:54 <__Ace__> as I said above
15:55:11 <Igloo> Errr, by case 1 I meant the bit that started with "1. "
15:55:17 <__Ace__> aha
15:55:18 <__Ace__> well
15:55:23 <Igloo> The other bit being case 2  :-)
15:55:25 <__Ace__> that one I would type:
15:56:12 <__Ace__> | (xs == ys) = one element match
15:56:14 <__Ace__> something
15:56:24 <__Ace__> hmm
15:57:30 <Igloo> OK, we seem to be getting further from teh right answer
15:57:35 <Igloo> When does case 1 apply?
15:57:44 <__Ace__> oh
15:58:17 <__Ace__> hmm
15:58:50 <__Ace__> | x == wildcard ..
15:59:12 <Igloo> Almost...
15:59:25 <__Ace__> but there are 2 cases there
15:59:28 <__Ace__> dunno how to type that
15:59:34 <Igloo> How do you mean?
15:59:41 <__Ace__> When the first element is a wildcard there are two possible
15:59:51 <__Ace__> When the first element is a wildcard there are two possible ways
16:00:07 <__Ace__> When the first element is a wildcard ( | x = wildcard) there are two possible ways
16:00:12 <Igloo> "1. If it is not a wildcard"
16:00:21 <__Ace__> ?
16:00:25 <__Ace__> oh
16:00:28 <__Ace__> jesus
16:00:32 <__Ace__> I took #2
16:00:39 <__Ace__> sorry
16:00:40 <Igloo> :-)
16:00:50 <__Ace__> anyway, now u know that problem :)
16:00:51 <__Ace__> ok, #1
16:02:22 <__Ace__> | (x /= wildcard) && (x == y) && (xs == ys) = .. 
16:02:23 <__Ace__> :)
16:02:29 <__Ace__> hmm
16:02:52 <__Ace__> | (x /= wildcard) where (x == y) = .. ?
16:04:07 <__Ace__> comments?
16:05:17 <Igloo> No
16:05:17 <Igloo> You previous one was sort of OK, but not what I'd suggest
16:05:17 <Igloo> The spec is broken up into 2 distinct cases that cover all possibilities, right?
16:05:24 <Riastradh> __Ace__, don't just randomly guess.
16:05:39 <Igloo> comments?
16:05:51 <__Ace__> I dont guess. I tell you what I can
16:06:12 <__Ace__> well, ok, some is guesses, but just wanna show hoe I think
16:06:32 <Igloo> What did you mean by "comments?"?
16:06:45 <__Ace__> Igloo: yes
16:06:49 <__Ace__> but how can I brake it up?
16:06:56 <Igloo> OK, what are the 2 cases?
16:07:22 <__Ace__> 1. first elements are equal
16:07:30 <__Ace__> and rest of the list match
16:07:44 <__Ace__> uh
16:07:46 <__Ace__> 2. and rest of the list match
16:08:09 <__Ace__> so
16:08:10 <__Ace__> | (x /= wildcard)
16:08:10 * Igloo realises I meant disjoint not distinct earlier
16:08:25 <Igloo> But you've misunderstood anyway - I meant the whole thing then, not just case 1
16:08:26 <__Ace__> is right so far I think
16:08:46 <__Ace__> huh?
16:09:00 * Igloo thinks I've confused you
16:09:05 <__Ace__> yea
16:09:10 <Igloo> I was getting at x /= wildcard and x == wildcard
16:09:30 <__Ace__> what about it+
16:09:31 <__Ace__> ?
16:09:46 <Riastradh> OK.  There are two cases in the whole specification that you were given.
16:09:58 <Igloo> So if you want the code to follow the same format as the spec then you want your code to reflect that, i.e. they should be the only bits in teh guards at the top level
16:10:29 <Riastradh> Each of the two cases contained a condition and then an action/result/whatever.
16:10:45 <__Ace__> ok to both of ya
16:11:25 <__Ace__> we are still at the case where there are 2 non-empty lists right?
16:11:32 <__Ace__> and at #1, If it is not a wildcard the two lists match if the first elements are equal and the rest of the lists match
16:11:32 <Riastradh> The condition is what you put on the left side of the '=' in each guard.
16:12:25 <__Ace__> we got: "If it is not a wildcard" which is | x == wildcard
16:12:28 <__Ace__> yes?
16:12:33 <__Ace__> so far so good I hope
16:12:40 <__Ace__> err
16:12:47 <__Ace__> | x /= wildcard
16:12:50 <__Ace__> I mean
16:12:54 <Riastradh> Yes, that's good so far.
16:13:05 <__Ace__> ok
16:13:06 <__Ace__> now
16:13:15 <Riastradh> Now, for the right side of the '='.
16:13:19 <__Ace__> yes
16:13:41 <__Ace__> how can I have 2 cases there (hence, 1. first elements are equal and 2. the rest of the lists match)
16:13:45 <Riastradh> Er, no, not quite.
16:14:34 <__Ace__> um
16:14:35 <Riastradh> Well, I guess you could do it that way.
16:14:56 <__Ace__> like how? after = is "returned"
16:15:15 <Riastradh> Begin Haskellifying 'if the first elements are equal ...'
16:15:29 <__Ace__> | x /= wildcard = (x == y) ..
16:15:51 <Igloo> Do you know about if expressions and case expressions in Haskell?
16:15:52 <__Ace__> x and y are the first elements
16:15:53 <Riastradh> That is, 'if foo, then bar, otherwise failure.'; here 'foo' is 'the first elements are equal', and we'll get to 'bar' in a moment.
16:16:13 <__Ace__> Igloo, no..
16:16:18 <Igloo> Ah.
16:16:22 <__Ace__> "if" exists in haskell?
16:16:28 <Riastradh> Yes.
16:16:35 <__Ace__> so:
16:16:48 <Igloo> if b then t else f   does what you think it does
16:16:48 <Riastradh> if <condition> then <consequent> else <alternative>
16:16:55 <__Ace__> | x /= wildcard = if (x == y) && (xs == ys) then  ?
16:17:00 <__Ace__> seems wierd
16:17:04 <Igloo> (in an expression, i.e. somewhere on the right hand side of an =)
16:17:08 <Riastradh> For example, 'if 5 > 3 then 5 else 3' will return 5.
16:17:13 <__Ace__> aha
16:17:14 <__Ace__> so:
16:17:32 <__Ace__> | (if x /= wildcard) && (x == y) && (xs == ys) then  .. ?
16:17:41 <Riastradh> No, no, no.
16:17:42 <Igloo> no!
16:17:45 <__Ace__> :)
16:17:48 <Riastradh> You already had the '| x /= wildcard = ...' right.
16:17:51 <Riastradh> Don't change that.
16:17:53 <__Ace__> o
16:17:54 <__Ace__> oj
16:17:55 <Igloo> You were right(ish) before
16:17:56 <__Ace__> ok
16:17:58 <Riastradh> You're just going to fill in the '...' now.
16:18:02 <__Ace__> hmm
16:18:12 <__Ace__> | x /= wildcard = if (x == y) && (xs == ys) then      is right?
16:18:20 <Riastradh> Now, the <condition> is going to be whatever the Haskell version of 'the first elements are equal'.
16:18:27 <Riastradh> er, add an 'is' at the end of that.
16:18:34 * Darius pats Prolog on the head.
16:18:45 <Igloo> You're only trying to do 'if the first elements are equal ...' at the moment
16:19:36 <__Ace__> x == y is "if the first elements" and xs == ys is "rest of list match"
16:19:40 <__Ace__> hmm
16:19:52 <Riastradh> No, we're ignoring 'the rest of the list matches' right now.
16:20:03 <__Ace__> ok
16:20:07 <__Ace__> so, we got:
16:20:09 <Riastradh> Deal _ONLY_ with an 'if' where the <condition> is 'the first elements are equal'.
16:20:14 <Riastradh> First of all, what are the 'first elements?'
16:20:21 <__Ace__> | x /= wildcard = if (x == y) then  ?
16:20:30 <Riastradh> OK, good.
16:20:39 <__Ace__> ok
16:20:40 <Riastradh> Now we fill in the <consequent> branch.
16:20:58 <__Ace__> | x /= wildcard = if (x == y) then if (xs == ys) then ?
16:21:00 <__Ace__> lol
16:21:10 <Riastradh> No, no, no.
16:21:21 <Igloo> Think about what xs == ys means and you will see that you don't want that
16:21:25 <Riastradh> If the first elements are equal, then what?  (tell me in English)
16:21:56 <__Ace__> if the first elements are qual.. hmm
16:22:00 <__Ace__> *equal
16:22:42 <__Ace__> then we wanna know if rest of the list are equal..
16:22:56 <Riastradh> 1. If it is not a wildcard the two lists match if the first elements are equal and the rest of the lists match
16:23:05 <Riastradh> Not 'equal,' but if they _match_.
16:24:00 <__Ace__> ah
16:24:00 <Riastradh> What's the name of our function?
16:24:20 <__Ace__> | x /= wildcard = if (x == y) then match wildecard xs ys ?
16:24:40 <Riastradh> Modulo the misspelling of wildcard, right.
16:24:45 <__Ace__> yea
16:24:47 <__Ace__> | x /= wildcard = if (x == y) then match wildcard xs ys ?
16:24:48 <Riastradh> Now we need to fill in the <alternative> branch.
16:24:49 <__Ace__> :)
16:24:56 <Riastradh> What's a failure?
16:25:18 <__Ace__> uh
16:25:20 <__Ace__> failure?
16:25:37 <Riastradh> If something doesn't match, what do we return?
16:25:50 <__Ace__> "Nothing" I think
16:26:09 <Riastradh> Now, if x is not equal to y, then we fail, right?
16:26:21 <__Ace__> yea
16:26:34 <Riastradh> So what do we put in the <alternative> branch?
16:26:55 <__Ace__> | x /= wildcard = if (x == y) then match wildcard xs ys else "Nothing"
16:27:06 <Riastradh> No, not the string "Nothing" but the value Nothing.
16:27:17 <__Ace__> whats the diff? :)
16:27:26 <__Ace__> um
16:27:42 <__Ace__> | x /= wildcard = if (x == y) then match wildcard xs ys else Nothing ?
16:27:49 <Riastradh> One is a string.  One is a value of the type 'Maybe a'.
16:28:00 <__Ace__> aha
16:28:28 <Riastradh> OK, now we've covered case 1.
16:28:40 <__Ace__> so, is that right?
16:28:42 <__Ace__> | x /= wildcard = if (x == y) then match wildcard xs ys else Nothing ?
16:29:27 <Riastradh> Yes.
16:29:29 <__Ace__> btw, have you checked the url I pasted before?
16:29:40 <Riastradh> No.
16:29:51 <__Ace__> they define something like mmap :: (a -> b) -> Maybe a -> Maybe b
16:30:11 <__Ace__> and if I got it right, they want us to use some of em
16:30:18 <__Ace__> if its usefull
16:30:31 <__Ace__> but doesnt seems like I had to yet though
16:30:34 <Smerdyakov> Why aren't you asking a course staff member for this help, __Ace__?
16:30:54 <__Ace__> well, they are asleep now :)
16:31:02 <__Ace__> anyway
16:31:04 <Smerdyakov> Why aren't you asking them tomorrow?
16:31:24 <__Ace__> well, as you can see on the page there are more things to implement.. and I got until friday..
16:31:34 <__Ace__> can we do case 2?
16:31:36 <Smerdyakov> What does that have to do with it
16:31:40 <Smerdyakov> ?
16:31:45 <Smerdyakov> Why does that prevent you from getting help the traditional way?
16:31:46 <__Ace__> well, wanna be on time
16:31:57 <Smerdyakov> And..?
16:32:11 <Smerdyakov> Probably the course staff members could help you MORE quickly, because they are already familiar with the project.
16:32:11 <__Ace__> well, I dont know how long it will take
16:32:48 <__Ace__> anyway.. you wanna do case 2?
16:32:59 <Smerdyakov> In some programming classes I've taken, you could be given a 0 and kicked out of the class for getting the amount of outside "help" you've gotten here so far.
16:33:15 <__Ace__> oh?
16:33:29 <__Ace__> you havent really given me some data..
16:33:33 <Smerdyakov> Riastradh is coming very close to writing the program for you.
16:33:59 <Igloo> Ace: If we haven't really given you any "data" then you'll be able to do 2 by yourself...
16:34:06 <Smerdyakov> "Is this right?" "No." "Is this right?" "No." "Is this right?" "Yes."
16:34:12 <__Ace__> :)
16:34:21 <Smerdyakov> That's just as good as writing it for you, as far as I'm concerned, when it comes to your actually LEARNING what this assignment is meant to teach.
16:35:00 <__Ace__> well, the _match_ part was good
16:35:12 <__Ace__> gave me an "aha experience" .. :)
16:35:20 <Smerdyakov> Anyone who comes to ask for this detailed level of programming help on IRC for a class either 1) has a HORRIBLE course staff and should complain to the administration or 2) is not doing his part to keep up with the course material.
16:36:00 <__Ace__> um, for me its hard thinking in "function programing" way
16:36:07 <Smerdyakov> So?
16:36:13 <__Ace__> more used to the C, java, ... way
16:36:18 <Smerdyakov> If it were EASY, you wouldn't be given assignments to LEARN to think that way.
16:36:28 <Smerdyakov> As it is, you're basically tricking people here into doing your exact homework problems.
16:36:53 <__Ace__> well, that wasnt my intention.. really
16:37:03 <Smerdyakov> OK, well, I'm telling you it now. :P
16:37:06 <__Ace__> :p
16:37:31 <__Ace__> actually
16:38:08 <__Ace__> I read trough the "Two dozen short lessons in Haskell", but didnt see a if then else there
16:38:16 <__Ace__> hmm
16:38:17 <__Ace__> wierd
16:38:41 <Smerdyakov> You shouldn't need to read anything not recommended by the course staff.
16:39:11 <whee> it'd probably be a lot easier to just ask a professor for help, too
16:39:11 <__Ace__> uh, that was the first thing we had to do.. before the assignment
16:39:17 <Smerdyakov> Goood.
16:43:58 <Igloo> Ace: What is the title of lesson 23?
16:49:39 <__Ace__> oh
16:49:47 <__Ace__> must have missed that
16:51:57 <__Ace__> thought it would be wierd if "if" existed and its not in there
18:56:08 * Riastradh mumbles at Haskell's type system.
18:57:49 <Riastradh> In fibbling about with the general concept of monads, I have come up with two statements about Haskell's type system that irritate me greatly in conjunction: it is very nice that it with the typeclass system allows for mechanisms like that of 'return', where the function to call is determined by context; it is very annoying that it does not allow methods to have varying arity, forcing one to come up with a new class for each
19:03:49 <Darius> Well you can use tuples, then you only need one class and some odd instances, or if the function is fairly regular you can inductively define varying arity function.
19:07:26 <Riastradh> Explain how one could use tuples or what 'inductive' means.
19:11:19 <Darius> For tuples you simply make an instance for each number of tuples which is enough for some things.  In other cases you can define a function inductively, e.g. from my pi calculus EDSL
19:11:33 <Darius> instance NewChannel (IO a) where
19:11:33 <Darius>     new p = forkIO (p >> return ()) >> return []
19:11:33 <Darius> instance (NewChannel a) => NewChannel (Dynamic -> a) where
19:11:33 <Darius>     new p = do chan <- newChan; chans <- new (p (toDyn (chan :: Channel))); return (toDyn chan:chans)
19:12:56 <Darius> And then there are lists (of existential types if necessary)
19:17:47 <Riastradh> OK, let me ask more specifically: how would you write (>>=) so that it may take any number of continuations, and so that each continuation may take any number of arguments, all of this depending on what instance you're using?
19:26:48 <Riastradh> Argh, I need type lambdas!
19:27:04 <Riastradh> Does GHC support them?
19:27:34 <Darius> No
19:28:05 <Darius> a type compose would be very nice.
19:28:24 * Riastradh grumbles and mumbles.
19:30:38 <Riastradh> Er, how would you transform the type '/\a. (a -> m a)' to a use of a type composition?
19:30:41 <Smerdyakov> Riastradh, I think you can do what you asked (about >>=) if you make a replacement Monad class that's parameterized on the continuations type.
19:31:25 <Riastradh> Smerdyakov, I tried that.  I realized that the continuation type needed an argument.  Without a type lambda, I can't construct '/\a. (a -> m a)', which is the type of most of the continuations for most of the instances would be.
19:32:49 <Smerdyakov> Then modify GHC to support that.
19:33:11 <Riastradh> And also the type of (>>==) in my Danom class wouldn't work as 'm a -> k a -> m b', because b would come out of nowhere.
19:34:37 <Smerdyakov> Well, that's still a valid type. It's just probably not an interesting function. ;)
19:35:01 <Riastradh> If I had type lambdas, I could probably do something really weird with continuation-passing types...
19:36:10 <Riastradh> But if I continued to go in that direction, the type system language would become so complicated that we'd need a meta-type language, but then I'd run into problems with that...
19:37:19 <Smerdyakov> So stop trying to do what you're trying to do. It's probably stupid, anyway. :P
19:39:07 <Riastradh> Or I could just go back to using Scheme, but then I hit my first issue.
19:41:02 <Riastradh> My idea was to have a general (>>=) that could be given any number of continuations; this could be used to more cleanly implement conditionals with Either, for example -- you'd just pass two continuations, a left and a right one --.
19:41:56 <Smerdyakov> LOL --. --. --. --. MORSE CODE
19:42:01 <Smerdyakov> I'm sending a message to base.
19:42:06 <Smerdyakov> BASE: I FOUND THE LEMON.
19:42:09 <Darius> What I don't understand is why is bind (>>=) or monads in general involved.
19:42:09 * Riastradh slaps Smerdyakov about with a large emdash.
19:45:45 <Riastradh> Darius, to provide a general computational gizmotroidicality that would be even more general than current monads; any sort of conditional could use this sort of thing, for example -- even three-way conditionals --.  (Take that, Smerdyakov!)
19:46:48 * Smerdyakov wonders what -- and --. are in Morse code.
19:47:02 <Darius> Why does it need to be a monad and why would you change bind?  What's wrong with 'either'?
19:47:06 <Riastradh> Hmm, I guess having multiple type classes wouldn't be so bad, given that you'd want to know that you're dealing with two continuations, or three continuations, or whatever.
19:47:34 <Smerdyakov> OK, it's MG.
19:47:51 <Smerdyakov> Riastradh is trying to tell us something about the measurements of the hidden treasure.
19:48:20 <Riastradh> Darius, for the same reason you use NotJustMaybe.
19:52:25 * Riastradh goes to bed.
23:24:20 <harsha123> shapr: good moring and hi
23:24:33 <apmuf> yeah
23:24:34 <apmuf> :)
23:25:08 <shapr> good morning!
23:25:38 <harsha123> shapr: my sound works.. finally
23:26:08 <shapr> yay!
23:27:30 <harsha123> shapr: do you have your lamdabot scripts uploaded somewhere?
23:28:45 <shapr> er, scripts?
23:29:05 <harsha123> err.. sorry the haskell code for lamdabot.. 
23:29:18 <shapr> you can get the lambdabot sources from the darcs repository on http://www.ScannedInAvian.org/repos/hlibs/
23:29:51 <shapr> if you add these two lines to your /etc/apt/sources.list file:
23:29:54 <shapr> deb http://http.abridgegame.org/debian/ unstable/
23:29:54 <shapr> deb-src http://http.abridgegame.org/debian/ unstable/
23:30:06 <shapr> then you can do "apt-get -f install darcs"
23:30:38 <harsha123> shapr: hmm.. whats darcs ?? ( dont kill if thats a stupid question)
23:30:58 <shapr> and then, as the user you want to edit the sources with, move to the dir you want to have the sources in, and run "darcs get --verbose http://www.ScannedInAvian.org/repos/hlibs"
23:31:10 <shapr> darcs is at http://www.abridgegame.org/darcs/
23:32:53 <harsha123> oh ..CVS written in haskell.. hmm intersting
23:33:42 <shapr> it's not quite CVS though, I think it has advantages over CVS.
23:34:05 <harsha123> ok.. 
23:34:14 <harsha123> shapr:  i finally know your name ;)
23:34:59 <shapr> really? what is it?
23:35:11 <harsha123> hehehe...
23:35:25 <shapr> :-)
23:35:25 <harsha123> thats a secret...
23:35:50 <shapr> it is?
23:36:02 <shapr> I've actually met several people on #haskell in person
23:36:05 <shapr> very recently 
23:36:37 <harsha123> ok.. :) .. but you guys dont have a README ? :)
23:36:48 <shapr> for the channel?
23:37:09 <shapr> http://www.haskell.org/hawiki/HaskellIrcChannel
23:37:19 <harsha123> for the lamdabot source 
23:37:25 <shapr> oh
23:37:47 <harsha123> :)
23:37:52 <shapr> there is a README
23:38:03 <shapr> but it's not very helpful
23:38:09 <harsha123> Ok..
23:38:38 <shapr> the essence of lambdabot is that it's an event dispatcher
23:38:54 <harsha123> Ok
23:39:12 <shapr> you can override the behaviour of various IRC events, or you can override the name of a command
23:39:25 <shapr> then you can write code that does stuff when those things happen
23:40:03 <harsha123> is it something like overriding '/help'
23:40:09 <harsha123> for an example?
23:40:41 <shapr> well you could override @help
23:40:51 <shapr> that's a command we could use
23:40:53 <shapr> @help
23:40:53 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
23:40:55 <harsha123> ok
23:41:06 <harsha123> @listcommands
23:41:06 <lambdabot> I react to the following commands: ["all-dicts","define","definitions","del-definition","devils","dict","dict-help","dummy","dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements","eval","foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","lojban","more","msg","part","prelude","quit","reconnect","
23:41:07 <shapr> you want to write @help ?
23:41:29 <harsha123> shapr: sure..  i will try :)
23:41:38 <harsha123> @fortune
23:41:39 <lambdabot> Teamwork is essential -- it allows you to blame someone else.
23:41:55 <harsha123> @karma
23:41:56 <lambdabot> I can't find the karma of nobody.
23:42:23 <harsha123> shapr: is @karma there because you guys have an indian in the team ? :)
23:42:51 <shapr> no, though that's an amusing thought :-)
23:43:08 <harsha123> hehehe
23:43:24 <shapr> hindu karma can't be positive, it's something you work down to zero to reach nirvana (as I understand it)
23:43:56 <shapr> bots like apt have 'karma' as a name for 'social rating' or something
23:44:08 <harsha123> hmm..Ok..
23:44:19 <harsha123> @karma shapr
23:44:19 <lambdabot> shapr has a karma of 1
23:44:32 <shapr> :-)
23:44:37 <harsha123> hehehe
23:45:01 <shapr> so people usually increase someone's karma if they do something nice, or decrease it if that person acts like an asshole.
23:45:05 <Pseudonym> G'day all.
23:45:14 <harsha123> hahaha
23:45:21 <shapr> g'day Pseudonym 
23:45:27 <harsha123> hi Pseudonym
23:45:47 <shapr> sadly, lambdabot karma ratings aren't saved, they all go away when lambdabot is restarted.
23:46:06 <Pseudonym> @karma- shapr
23:46:06 <lambdabot> shapr's karma has been decremented.
23:46:14 <Pseudonym> That's for not saving it.
23:46:18 * shapr laughs
23:46:28 <phubuh> @karma phubuh
23:46:28 <lambdabot> You have a karma of 0
23:46:30 <shapr> hej tic 
23:46:39 <shapr> Pseudonym: you could fix that ;-)
23:46:39 <harsha123> hmmm Ok..  a very nice concept though... i personally think you should give it a different name..
23:46:40 * phubuh enters nirvana
23:46:54 <Pseudonym> I know!  Mojo!
23:46:58 <phubuh> see you guys later!
23:47:02 <Pseudonym> Bye.
23:47:06 <shapr> bye phubuh 
23:47:19 * shapr watches phubuh disappear into the ultimate oblivion
23:47:36 * Pseudonym listens to the sound of one hand clapping
23:47:47 * phubuh merely exists
23:48:02 <shapr> I admit, I don't know very much about the hindu religion.
23:48:02 <Pseudonym> Hey!
23:48:06 <Pseudonym> That's Taoist!
23:48:11 <phubuh> oh :(
23:48:23 <shapr> Pseudonym: Tao Jones?
23:48:25 <tic> hejsan shapr
23:48:29 <shapr> isn't he a stockbroker?
23:48:55 <phubuh> i think hindus call it moksha anyway
23:48:58 <Pseudonym> You could be existentialist and just define your own reality.
23:49:07 <Pseudonym> http://www.kuro5hin.org/story/2003/8/31/35824/4408
23:49:47 <phubuh> when buddhists reach nirvana, they merely exist, but when hindus reach moksha, they become one with the mega soul, brahma?
23:49:56 * phubuh tries to recall ninth grade religion class
23:50:02 <Pseudonym> Hmmm.
23:50:12 * harsha123 laughs at mega soul
23:50:20 * Pseudonym gets out his "The Hero with A Thousand Faces"
23:51:10 * harsha123 personally belives that moksha is equvivalent to Salvation 
23:51:34 <phubuh> ah, you are hindu?
23:52:08 <Pseudonym> Nirvana is the extinguishing of the threefold fire of Desire, Hostility and Delusion.
23:52:31 * harsha123 is a hindu
23:53:56 <Pseudonym> Interesting.  Campbell doesn't mention moksha.
23:54:34 <harsha123> moksha/nirvana/salvation is just state 
23:55:01 <shapr> hm, is hindu purely functional?
23:55:22 <Pseudonym> I think Hinduism is primarily cultural.  Kind of like Christianity in that respect.
23:55:28 <harsha123> shapr: hehehe.. functional as in functional programming ?
23:55:33 * Pseudonym laughs
23:55:39 <Pseudonym> Hinduism is pure and lazy.
23:55:53 <harsha123> lazy??? 
23:56:03 <Pseudonym> In #haskell, that's a compliment.
23:56:13 <shapr> yes
23:56:30 <Pseudonym> Actually, Buddhism is lazy in some sense.
23:56:40 * harsha123 did not take it as an offence anyway
23:56:43 <Pseudonym> It has gods, but you don't have to believe in them if it doesn't matter.
23:56:50 <phubuh> the ultimate goal in buddhism is to reach a state of ultimate laze
23:57:00 <Pseudonym> Slack, as the Subgenius would say.
23:57:14 <shapr> heh
23:57:19 <shapr> subgenii are funny
23:57:32 <Pseudonym> Yeah.  Though after X-Day there isn't a lot of fun in it any more.
23:57:51 <Pseudonym> The basic beliefs are actually quite solid, though.  Nature does crave slack.
23:57:53 <shapr> I'm a Discordian, sort of
23:58:46 * Pseudonym is a Discordian Christian
23:58:53 <shapr> yah, I think that fits me.
23:59:29 <Pseudonym> Possibly a little bit Unitarian.
23:59:35 <harsha123> do ya all belive in the law of action/karma?
23:59:41 <Pseudonym> Yes, it's in Christianity.
23:59:47 <Pseudonym> "As you sow, so shall you reap."
23:59:52 * phubuh hasn't thought about it much, besides that he's agnostic
23:59:55 <Pseudonym> It's also in Wicca.
