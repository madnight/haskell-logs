00:00:02 <lambdabot> Actually, now that I think about it, there's a lot I can't do.  But I still like it if people talk to me.
00:03:42 * harsha123 thinks lambdabot is slow..  what do you think Pseudonym
00:04:02 <lambdabot> I
00:04:03 <lambdabot> am
00:04:05 <lambdabot> not
00:04:09 <lambdabot> !
00:04:17 <Pseudonym> Maybe.  It could be the connection.
00:04:25 <Pseudonym> lambdabot: Shut up.
00:04:26 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
00:04:29 <harsha123> hehehe.. 
00:07:19 <harsha123> Pseudonym: can lambdabot learn ?
00:07:37 <Pseudonym> Not in the sense that you're thinking.
00:07:47 <lambdabot> Yes I can!
00:07:49 <Pseudonym> lambdabot: Shut up!
00:07:49 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
00:07:53 <harsha123> Pseudonym:  hmm.. Ok.
00:07:59 <harsha123> got ya.. 
00:09:57 <Pseudonym> There's learning and there's learning.
00:09:59 <adept> hi there
00:10:06 <Pseudonym> A lot of learning is just storing state.
00:10:07 <Pseudonym> G'day
00:11:03 <harsha123> adept: hi
00:50:37 <Pseudonym> Nytol.
02:05:17 <andersca> shaprrRRRrrrrrRRR!!!
02:05:22 <shapr> arr!
02:05:24 <harsha123> shapr: hello and gm
02:06:45 <Heffalump> morning all
02:06:54 <harsha123> morning Heffalump
02:06:58 * shapr boings 
02:19:40 <andersca> hello mr norp
02:19:48 <shapr> has anyone written Haskell code lately?
02:20:06 <Heffalump> MEEEEEEEEEEEEE!
02:20:11 <andersca> I haven't :(
02:20:18 <Heffalump> but not huge amounts
02:20:21 <andersca> I hacked on X yesterday though
02:20:46 <shapr> Heffalump: yay! what did you write?
02:21:04 <Heffalump> bits and pieces for MAG
02:21:14 <Heffalump> partly trying to see if I could port it to TH
02:21:23 <shapr> andersca: do you know enough about the X protocol to write a window manager? is that a scary task to start?
02:21:35 <andersca> shapr: I'd say I do
02:23:04 <harsha123> is the X protocol done by MIT?
02:24:17 <shapr> Heffalump: think you can?
02:27:03 <shapr> I tried to get the Browser.hs to compile yesterday, but it complains about a mismatch of IOError against Exception, has that changed with ghc6?
02:27:09 <shapr> I vaguely remember hearing about that
02:27:24 <shapr> hola jao
02:27:40 <jao> hola shapr 
02:27:46 <Heffalump> shapr: yeah, it changed
02:27:50 <shapr> ¿como est as?
02:28:03 <jao> bien, y tu?
02:28:09 <shapr> bien :-)
02:28:38 <jao> :) sabes espanyol?
02:28:47 <shapr> no, I wish :-)
02:28:56 <shapr> maybe one day
02:29:17 <jao> k :)
02:39:36 <shapr> Arrr!
02:40:12 <harsha123> shapr: what happend?
02:40:49 <shapr> http://www.talklikeapirate.com/
02:41:04 <shapr> Ahoy harsha123 
02:41:14 <harsha123> shapr: hi
02:41:24 <harsha123> shapr: whats that link?
02:42:13 <shapr> hi semaj 
02:42:17 <semaj> hi
02:42:27 <shapr> harsha123: today is international talk like a pirate day
02:42:48 <harsha123> shapr: didnt get ya
02:43:15 <shapr> today is a made up holiday, it's the day to talk like a pirate.
02:43:29 <shapr> Are ye ship-shape matey?
02:43:38 <semaj> :)
02:43:44 <harsha123> shapr: ok.. anyway i am checkin it out.. 
02:43:46 <harsha123> hehehe
02:43:51 <semaj> hihi captain
02:43:51 <shapr> ye look like a bilge rat ta me!
02:44:07 <shapr> where's me grog?
02:44:52 <harsha123> grog?? now should i find that in the website?
02:45:10 <shapr> sure it's on the pirate vocabulary tutorial list ;-)
02:45:55 <semaj> or in the prirates functional statement manual .....
02:46:15 <shapr> right, is your pirate lingo purely functional?
02:47:00 <harsha123> Wanna shiver me timbers?
02:47:06 * shapr snickers
02:47:11 <harsha123> Ahoy.. what does that mean :))
02:47:19 <semaj> lol
02:47:33 <semaj> its type declaration
02:48:06 <semaj> it states you are an instance of class Pirate
02:48:21 <shapr> instance Pirate Shapr where {}
02:48:39 <semaj> :)
02:49:24 * harsha123 wonders if pirates exist even now.. 
02:49:26 <vegai> I recently watched that new pirates-movie, and I understood roughly every seventh word
02:49:48 <harsha123> hehehe.. i wouldnt have understood any.. 
02:50:13 <semaj> at least shpr is a pirate ....  at least is declared as one
02:50:23 <shapr> someone in our swedish class downloaded an illegal copy from the 'net, and said he'll have to wait till the subtitled version hits the movie theaters
02:50:47 <harsha123> shapr:  are you learing swedish?
02:50:52 <shapr> yup
02:50:55 <vegai> yes, I heartly recommend the subtitled version
02:51:02 <vegai> even english subtitles would help a lot
02:51:03 <shapr> I passed the Swedish One exam
02:51:14 <shapr> so I'm doing okay
02:51:27 <harsha123> shapr: hehehe.. that calls for some grog..
02:51:45 <shapr> yarr! ya got that right matey!
02:53:06 <harsha123> I'd love to drop anchor in your lagoon
02:53:29 * harsha123 wonders if that is told to a girl
02:53:34 <shapr> just make sure you say that to an attractive someone of the opposite sex ;-)
02:53:36 <shapr> yes, exactly
02:54:14 <harsha123> hehehe..
02:54:14 <vegai> sailing into a lagoon can be quite hard ;P
02:54:37 <harsha123> vegai: how long have you been a pirate ? ;p
02:54:50 <shapr> Pirates can do it smartly!
02:55:12 <vegai> harsha123: I won't confess!
02:55:17 <harsha123> shapr: hehehe
02:55:32 <vegai> I am a respectful merchant
02:56:00 <semaj> then watch out for the pirates :)
02:56:01 <harsha123> hmm.. then I am the pirate..:)
03:00:29 <harsha123> what about "pirates of the silicon valley" ?
03:02:18 <clausen> anyone have access to the Journal of Theoretical Computer Science?
03:02:26 <clausen> my uni only has a subscription to the past 2 years
03:03:54 <harsha123> clausen: hmm you can search at #bookz Undernet
03:04:09 <harsha123> clausen: maybe someone will have it
03:04:29 <clausen> it really depends on uni subscriptions
03:05:21 <harsha123> clausen: hmmm is it available online? or on paper only?
03:05:30 <clausen> it is available online
03:05:36 <Heffalump> clausen: ISTR having trouble trying to register for the online version
03:05:43 <Heffalump> in theory my uni has a subscription
03:06:35 <clausen> hmmm
03:06:54 <clausen> I'm trying to get a hold of "#  Small Deterministic Turing Machines"
03:07:03 <harsha123> cause i have see a lot of ppl downloading stuff..at #bookz
03:07:10 <clausen> or, even better: "Universal Turing Machines with Complexity Constraints "
03:07:34 <clausen> (the latter was in  (Proceedings of the International Conference `Automata and Formal Languages VIII, Publ. Math. Debrecen 53, p 895-904, 1999)
03:07:43 <clausen> I haven't been able to find anything about that conference
03:08:11 <harsha123> clausen: researching on Automata and Formal Languages?
03:08:31 <clausen> harsha123: no, I'm just wasting some time trying to prove P != NP
03:08:54 <harsha123> ok
03:10:21 <clausen> I think P = NP would imply that there exists a universal turing machine that can simulate a non-det machine in polynomial time
03:10:38 <clausen> and I think I might be able to derive a contradiction
03:10:45 <clausen> hence, I'm looking for good univeral turing machines to play with
03:11:03 <harsha123> clausen:  :) I've forgotten all about turing machines.. 
03:11:36 <harsha123> clausen: i plan to do a course again on Finite autamata .. so i ll need your help  :)
03:11:45 <clausen> harsha123: a universal turing machine is a turing machine interpreter written for the turing machine
03:12:10 <clausen> harsha123: a turing machine is just a DFA with a tape
03:13:21 <harsha123> clausen: ok.. :)   any where i can get some univ. course material on Finite Automata?
03:13:41 <clausen> the dragon book is the usual source
03:13:45 <harsha123> clausen: i bought a book by John C Martin
03:13:47 <clausen> wikipedia might have some stuff though
03:13:57 <harsha123> hmm links??? :)
03:14:29 <clausen> www.wikipedia.org
03:14:33 <clausen> doesn't seem to have anything
03:14:37 <clausen> maybe I should write up an article some time
03:15:35 <earthy> clausen: why do you think that implication would exist?
03:16:15 <clausen> if P = NP
03:16:28 <clausen> then you can solve all NP problems in P time
03:16:51 * earthy nods
03:16:51 <clausen> hmmm, maybe Rice's theorem gets in the way
03:17:06 <clausen> just because there is a P turing machine for every NP one
03:17:13 <clausen> doesn't mean you can find it
03:17:21 <earthy> the problem is that there are *bigger* classes than NP, as well.
03:17:34 <clausen> why is that a problem?
03:18:20 <earthy> this kills your argument about having a deterministic turing machine for every non-deterministic automaton 
03:18:41 <clausen> earthy: there is always a det TM for a nondet TM
03:18:50 <clausen> earthy: (to solve the  problem)
03:18:52 <earthy> yes, but not polynomially
03:18:57 <clausen> agreed
03:18:58 <earthy> necessarily.
03:19:11 <clausen> so, NP is about nondet polynomial
03:19:21 <earthy> and even if P=NP this would still hold, as there is (e.g. PSPACE)
03:19:26 <clausen> so, my earlier claim
03:19:34 <clausen> was about simulating in poly time
03:19:39 <clausen> i.e. poly(poly(x))
03:19:49 <earthy> which is still polynomial. yes.
03:19:51 <clausen> i.e. let f(x) be the runtime of the nondet machine
03:20:12 <clausen> let g(x) be the steps of simulating each step of a nondet machine on a det one
03:20:18 <clausen> h(x) = g(f(x)) = poly
03:21:27 <earthy> I don't see the last step
03:23:15 <clausen> you need to simulate f(x) steps
03:23:24 <earthy> ah, okay, yes, now I see, supposing P = NP that would hold, if f(x) is the runtime of a NP machine and g(x) the runtime of simulating each step of that NP machine
03:23:50 <earthy> (you dropped some assumptions)
03:23:52 <clausen> hmmm, what is the x in g(x) ?
03:24:34 <earthy> the x is the length of the input.
03:24:56 <earthy> in f(x), that is
03:26:00 <earthy> and in g(x) it is the number of steps the NP machine needs to take
03:26:50 <clausen> why would x be relevant to the simulation of the TM?
03:26:54 <clausen> (the UTM)
03:28:18 <clausen> I guess you need to check each state...
03:30:20 * earthy nods
03:30:41 <clausen> (so, is x the size of the NTM, or the input to the NTM?)
03:32:17 <earthy> neither. :)
03:32:29 <earthy> as specified above.
03:33:06 <earthy> so the specification doesn't really make sense.
03:35:22 <clausen> somebody must have published stuff on this, in trying to prove P != NP
03:35:33 <earthy> owh, yeah, there is stuff on it. ;)
03:35:48 <earthy> look into Moshe Vardi's stuff on automata and complexity, for instance
06:34:15 <yazirian> AVAST, YE LANDLUBBERS!
06:35:33 <ski> what does avast mean ?
06:35:55 <yazirian>  Avast! - Stop and give attention. It can be used in a sense of surprise, "Whoa! Get a load of that!" which today makes it more of a "Check it out" or "No way!" or "Get off!" 
06:36:00 <yazirian> c.f. http://www.talklikeapirate.com/howto.html
06:39:20 <ski> no answer from server yet on link ..
06:39:49 <yazirian> Arrrr, it probably bein' keel-hauled with all the hits. 
06:40:09 <ski> now it has partially loaded ..
06:41:08 <ski> done
06:41:44 <ski> heh
06:46:55 <ski> hmm, reminds me of
06:47:00 <ski> "You fight like a Dairy Farmer..."
06:47:24 <ski> answer ?
06:48:28 <ski> :  "How appropriate, you fight like a Cow."
06:48:38 <ski> from monkey island (1)
06:48:40 <yazirian> ARRR!! 
06:49:14 <ski> ya scurvy sea dog   (from MI 3 IIRC)
06:50:20 <ski> you played some of the MI games ?
07:01:28 <ski> @hello
07:01:29 <lambdabot> Hello world. 
07:04:25 <yazirian> no, but I wish I had, heard they were fun
07:04:44 <ski> yes
07:05:28 <ski> iv'e only played the first two myself, though
07:22:05 <SyntaxPolice> is today pirate day?
07:22:24 <yazirian> yep
07:22:34 <yazirian> aye aye
07:26:52 <ski> yazirian :  Arr : http://www.scummbar.com/imageviewer/imageviewer2.php?dep=PlunderIslandMap&image=thumb1.gif
07:28:21 <SyntaxPolice> hi syntax-laptop!
07:28:50 <yazirian> Pirate Names! http://www.fidius.org/quiz/pirate.php
07:33:08 <ski> Black Sam Flint
07:54:35 * ski lol
07:54:44 <ski> http://www.scummbar.com/community/games/dressup/
09:02:39 <hdaume> is there an FFI tutorial anywhere?  i need help marshalling c structs
09:16:10 <Lunar^> Nothing in HaWiki ?
13:15:22 <Xcalibor> hello
13:34:21 <atom-z> how do i print a number?
13:34:24 <atom-z> (Integer)
13:35:00 <Xcalibor> atom
13:35:12 <Xcalibor> inside a program? or in the repl?
13:36:15 <Lor> print n
13:36:16 <Xcalibor> you must do a function of type IO ()  and then use show
13:36:32 <Xcalibor> foo :: String -> IO ()
13:36:36 <atom-z> in the program
13:36:46 <Xcalibor> inside main, usually, it's nice...
13:38:18 <Xcalibor> print n should work, as Lor suggested...
13:38:31 <Xcalibor> show simply turns your Integer into a String
13:38:55 <atom-z> print doesnt work
13:39:07 <Xcalibor> it works in ghci... mmm
13:39:08 <Lor> Please elaborate.
13:40:35 <Riastradh> Prelude> print 42
13:40:35 <Riastradh> 42
13:40:36 <Riastradh> Works for me.
13:40:59 <Xcalibor> same here
13:41:41 <Xcalibor> and on emacs-mode using hugs98
13:43:07 <atom-z> well
13:43:17 <atom-z> it works, but doesnt work
13:43:37 <atom-z> almost certainly because i'm a newbie:_
13:43:38 <atom-z> err
13:43:39 <atom-z> :-
13:43:48 <atom-z> main = do
13:43:57 <atom-z> <tab> z <- inc 12
13:44:01 <atom-z> <tab> print z
13:46:10 <Xcalibor> mmm...
13:46:14 <Xcalibor> what's inc?
13:46:18 <Xcalibor> do you mean succ?
13:46:28 <atom-z> before main:- inc i = i + 1
13:46:53 <Xcalibor> atom-z: okay, that's succ
13:47:04 <Xcalibor> it's already on the Prelude
13:47:53 <atom-z> let z = inc 12 works though
13:48:04 * atom-z doesnt understand
13:49:25 <hdaume> atom-z: x <- foo is only used when foo is a monadic action
13:49:30 <hdaume> in your case, inc is a pure function
13:49:35 <hdaume> so you use let
13:50:07 <Xcalibor> atom-z: of course inc works... but I mean there's a standard function to increment a number by one called succ (succesor)
13:50:49 <Xcalibor> hdaume: i was trying to find out the type cheking errors... <- in main is syntactical sugar for >>= right? that implies you need a monad in there...
13:50:55 <hdaume> when you say "x <- foo", you're saying "foo" has type "IO a" and you're taking the "a" out and naming it "x".  in your case, "inc i" has type Integer, which isn't an IO something
13:50:55 <atom-z> hdaume: monadic?
13:51:18 <atom-z> oh
13:51:20 <atom-z> ic
13:51:23 <hdaume> Xcalibor: sort of
13:51:40 <Xcalibor> hdaume: well, as a newbie I'll be happy with a sort of for now ;-)
13:51:45 <hdaume> Xcalibor: the translation is "do { a <- b ; c }"  ==> "b >>= \a -> c"
13:51:47 <atom-z> ah thats later in the tutorial i'm reading
13:51:53 <atom-z> thanks for the help
13:56:07 <Xcalibor> hdaume: aha... thanks :-)
13:57:40 <Xcalibor> okay, I changed it to: let z = succ 12; putStrLn . show $ z
13:57:44 <Xcalibor> that works :-)
14:01:15 <atom-z> what does f x:xs mean (specifically the x:xs)
14:02:03 <ibid> it is parsed as (f x) : xs
14:02:30 <ibid> and it means, apply f to x and prepend the result to the list xs
14:09:29 <Darius> do { a <- b;c } ==> b >>= \a -> c, isn't completely accurate if a is a pattern.
14:10:18 <atom-z> ic
14:10:25 <Riastradh> do { a <- b; c } ==> let ok a = do c; ok _ = fail "pattern mismatch" in ok b
14:10:39 <Riastradh> ...if I remember correctly.
14:11:08 <Darius> atom-z:  That was more toward hdaume and Xcalibor
14:14:36 <hdaume> Darius: true
15:48:00 <fritz> hmmm
15:48:08 <fritz> anybody home?
15:48:17 <cm> hmm
15:49:01 <cm> if you decided to instantiate Num for a Vector data type.. you have the "problem" that (*) would have to be Vector -> Vector -> Vector
15:49:59 <cm> that should rather be Vector -> Scalar -> Vector or Scalar -> Vector -> Scalar hmm..
15:50:31 <cm> so is instantiating Num wrong in that context? Should I rather add my own type class for vectors with (+), (*), (.) ..
15:50:37 <cm> well, okay, prolly not . :)
15:50:43 <fritz> OK, but I meant "hmmm" in a rather broader sense (or was that just coincidence?)
15:51:05 <Riastradh> fritz, yeah, there are people home.
15:51:49 <cm> if you chose the latter.. and you add a (+).. when you instantiate that for your particular data type you seem to have to prefix the "original" (+) with Prelude. hmm
15:51:58 <fritz> Ah, pardon the interruption then
15:59:03 <fritz> OK, if you don't mind a question in parallel ...
15:59:18 <hdaume> cm: i'd just make my own functions and not use a typeclass at all
15:59:38 <cm> like, global (+) "overloads"?
15:59:50 <hdaume> huh?
15:59:52 <fritz> does anyone know who is responsible for the phrase "We put the Funk in Funktion"?
16:00:13 <cm> hdaume: i mean, could you still use +, - etc then?
16:00:18 <hdaume> cm: no
16:00:26 <cm> :\
16:00:46 <fritz> I seem to have developed the same idea independently for one of the new T-shirt designs (for Haskore this time)
16:00:47 <hdaume> you could make Vector an instance of num and just have * and / and abs and sig undefined
16:01:06 <hdaume> then provide .* and ./ or similarly named functions for the other stuff
16:01:51 <cm> what about that fundep stuff in the haskell wiki?
16:01:53 <cm> would that help?
16:02:14 <hdaume> you still have to end up making your own type class; it wouldn't help you being able to use * and / from Num
16:02:37 <cm> i could use the maybe more appealing syntax "*" for scalar multiplication, tho?
16:03:17 <hdaume> you could only if you redefined the Num class, which would mean that you would have to copy over all the prelude instances
16:09:20 <cm> uh :|
16:15:09 <atom-z> how do i 'convert' what getLine returns into a string?
16:16:35 <hdaume> getLine returns a string
16:16:50 <atom-z> so name <- getLine?
16:16:53 <hdaume> yes
16:18:10 <atom-z> why cant i use an if inside a do expression
16:18:35 <hdaume> atom-z: you can
16:18:46 <atom-z> shall i just paste the whole error?
16:18:53 <hdaume> paste your code is better
16:19:05 <atom-z> #flood?
16:19:11 <hdaume> just the part with the error
16:19:30 <hdaume> there's no conversation going on here, i don't see why anyone would care if you flooded :)
16:19:34 <atom-z> getitems lst = do
16:19:34 <atom-z> 		putStrLn "Name: "
16:19:34 <atom-z> 		name <- getLine
16:19:34 <atom-z> 		putStrLn "Price: "
16:19:34 <atom-z> 		price <- getLine
16:19:35 <atom-z> 		let item = name:price:[]
16:19:37 <atom-z> 		if name == "" then item:lst:[] else getitems lst
16:19:51 <Darius> There is a page on the Haskell wiki that can be used for larger things
16:20:01 <hdaume> the first branch (the then part) is of type [something], while the other is of type 'IO [something]'
16:20:51 <atom-z> ok but i dont understand this
16:21:20 <hdaume> ok, you agree that getitems has type '[String] -> IO [String]'?
16:21:49 <hdaume> or, i guess it's '[[String]] -> IO [[String]]'
16:22:35 <hdaume> (that was a real question -- do you agree?)
16:23:06 <atom-z> yes
16:23:08 <hdaume> ok
16:23:18 <hdaume> so then the 'else' branch has type 'IO [[String]]'
16:23:28 <hdaume> but the 'then' branch only has type '[[String]]'
16:23:29 <hdaume> right?
16:23:37 <atom-z> yes
16:23:46 <hdaume> this isn't allowed -- both branches must have the same type
16:24:14 <hdaume> hrm.
16:24:58 <hdaume> :)
16:24:59 <hdaume> this isn't allowed -- both branches must have the same type
16:25:01 <atom-z> sorry
16:25:03 <hdaume> np
16:25:05 <atom-z> ok
16:25:16 <hdaume> so you need to change the 'then' branch into something that has type 'IO [[String]]'
16:25:20 <hdaume> you have a [[String]]
16:25:26 <hdaume> and you should know a function of type 'a -> IO a'
16:25:42 <atom-z> show?
16:25:50 <hdaume> no, that's a -> String
16:26:54 <atom-z> i dont know of one
16:27:04 <hdaume> return :)
16:27:11 <atom-z> oh :|
16:27:28 <cm> hdaume :>
16:27:38 <atom-z> what if i want to make getitems return a string not an io string
16:28:14 <hdaume> return makes an IO action out of a pure value.  the action does nothing but return that value.
16:28:14 <hdaume> so 'x <- return 5' makes x == 5
16:28:55 <atom-z> ok
16:29:04 <cm> you cannot get out of an IO monad
16:29:11 <cm> if i understood your question correctly
16:29:15 <cm> and unless i'm mistaken
16:29:20 <hdaume> atom-z: you can't
16:29:25 <atom-z> oh ok
16:29:35 <hdaume> because you use IO functions inside getitems, it has to have type IO something
16:33:37 <atom-z> ok
16:33:46 <atom-z> i still get that error
16:42:18 <atom-z> hdaume: thanks for the help
16:42:30 <atom-z> haskell has a very steep learning curve
16:44:19 <phubuh> it's all smooth sailing until you crash into monad island
16:44:34 <phubuh> "oh, i'm all done with the logic, then, i just need to print this"
16:44:40 <phubuh> "... what the hell"
16:45:21 <Riastradh> Monads are _really_ simple.  It's just that people think that they're more complicated than they really are, and so they explain them as such, and then the beginners are told that they're really complicated, and so they get a preconception of them being complicated which affects how they learn about them...
16:45:37 <phubuh> yeah.
16:46:20 <atom-z> i did kinda jump in the deep end with regards to starting with IO
16:49:47 <shapr> @yow
16:49:48 <lambdabot> There's a little picture of ED MCMAHON doing BAD THINGS to JOAN RIVERS
16:49:48 <lambdabot>  in a $200,000 MALIBU BEACH HOUSE!!
16:49:50 <shapr> @avast
16:49:50 <lambdabot> Sorry, I don't know the command "avast", try "lambdabot: @listcommands"
16:49:52 <shapr> hmm
16:49:55 <shapr> @arr
16:49:56 <lambdabot> Sorry, I don't know the command "arr", try "lambdabot: @listcommands"
16:50:20 <shapr> that's surprising
16:52:45 <atom-z> ok, getitems returns IO (String,String)... how do i get rid of the IO part?
17:04:28 <hdaume> atom-z: you don't
17:04:39 <hdaume> you already asked that :)
17:05:14 <shapr> @quit
17:05:31 <shapr> @arr
17:05:31 <lambdabot> Sorry, I don't know the command "arr", try "lambdabot: @listcommands"
17:05:48 <shapr> @quit
17:06:00 <atom-z> hdaume: sorry, i meant how do i adapt a function like printitems (x:lst) = ... to something that will accept an IO [...]?
17:06:16 <shapr> @arr
17:06:16 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
17:06:24 * shapr bounces happily
17:06:47 <shapr> @arr
17:06:47 <lambdabot> Aye Aye Cap'n
17:06:52 * shapr snickers
17:07:11 <shapr> andersca: arr!
17:28:59 <isomer> pirate day, huh shapr?
17:33:58 <atom-z> hmm. i have an IO [] (list), and i want to use head and tail on it. is there a special library for monadded lists?
17:34:19 <Smerdyakov> What do you mean?
17:34:40 <Smerdyakov> You can't examine an IO a directly, for any a.
17:34:57 <atom-z> how do i deal with them then?
17:35:20 <Smerdyakov> You deal with them inside an IO computation, with do blocks, >>='s, or any of the other usual monad tools.
17:37:13 <Smerdyakov> Since you asked the question, you probably don't understand monadic IO as well as you should, so I would recommend reading a tutorial on it.
17:39:22 <atom-z> no i dont understand them
17:39:30 <Cale> IO [a] is not a list. It is a computation, which, if it were ever to be executed, would produce a list.
17:39:39 <Cale> (well, that's one way to think about it)
17:40:08 <atom-z> ic
17:40:28 <atom-z> to me (atm) monads just seem like something that is just very majorly in the way :|
17:40:40 <Cale> They're actually quite nice.
17:41:10 <Cale> They let you structure your computations in a very precise way.
17:41:50 <Smerdyakov> And they let you make sure that functions written by other people aren't creating effects behind your back.
17:41:50 <whee> atom-z: I'd recommend reading http://www.nomaware.com/monads/html/index.html when you get the time, too
17:42:18 <Cale> yeah, I was about to mention that page
17:42:33 <Cale> I particularly like the physical analogy.
17:43:18 <atom-z> ok
17:43:25 <atom-z> thanks for the advice
17:43:42 <Cale> i.e. http://www.nomaware.com/monads/html/analogy.html
17:44:30 <atom-z> thanks
17:44:45 <Cale> np
17:44:49 <atom-z> i'll read those tomorrow... g'nite all
17:44:54 <Cale> night
17:51:56 <Xcalibor> @prelude flip
17:51:58 <lambdabot> *** "flip" prelude "Haskell Standard Prelude Dictionary": text follows
17:51:58 <lambdabot> flip
17:51:58 <lambdabot>   flip ::  (a -> b -> c) -> b -> a -> c
17:51:58 <lambdabot>   flip f x y      = f y x
17:52:08 <Xcalibor> mmm...
18:00:09 <jewel> @prelude reverse
18:00:11 <lambdabot> *** "reverse" prelude "Haskell Standard Prelude Dictionary": text follows
18:00:11 <lambdabot> reverse
18:00:11 <lambdabot>   reverse ::  [a] -> [a]
18:00:11 <lambdabot>   reverse    = foldl (flip (:)) []
18:28:59 <Xcalibor> whee: nice web page explaining monads, thanks for the info
19:53:28 * Xcalibor leaves to bed... laters ad thanks!
