00:00:01 <Strike> not much, playing with my neuros (www.neurosaudio.com) to see if I can get my oggs on it
00:31:21 <shapr> hi Arnia 
00:34:43 <shapr> RibenaBoy: have you read the HomeworkHelp page on the the Haskell wiki?
00:35:48 <RibenaBoy> yes
00:52:00 <RibenaBoy> i dont get why multiple declaration error occurs
00:53:27 <shapr> I think you should get a timeslot with a tutor.
00:54:54 <RibenaBoy> wats the difference between learning through a tutor and asking on irc
00:55:10 <RibenaBoy> im not asking ppl to help me do my hw
00:55:17 <shapr> it appears to me that you are.
00:56:15 <RibenaBoy> i would've sent u my homework and say help me do it if i want it done that way
00:56:20 <dennisb> RibenaBoy: you need to understand what happens when you call that function
00:56:25 <shapr> RibenaBoy: I already get that a lot.
00:56:50 <RibenaBoy> why do programmers get so sensitive when asked a question
00:57:17 <shapr> RibenaBoy: http://www.catb.org/~esr/faqs/smart-questions.html
00:57:25 <RibenaBoy> in maths channels they answer the question straight away
00:57:39 <Lor> RibenaBoy, because we want you to learn, not only to get the solution.
00:57:58 <Lor> (Morning, folks.)
00:58:09 <RibenaBoy> im not asking for solution
00:58:16 <RibenaBoy> im asking why errors occur
00:58:32 <dennisb> it's because you have made two definitions of that function
00:58:37 <shapr> RibenaBoy: when I have a programming problem to solve, and I have an error, I find similar cases where I do get the error, and where I do not get the error, then I try to figure out the general principle behind the similarities and differences shown.
00:59:08 <dennisb> you can only define "the thing" once
00:59:21 <shapr> huomenta Lor 
00:59:38 <shapr> gutentag Marvin-- :-)
01:00:06 <ludde> hi marvin
01:00:23 <ludde> what are you doing in .de?
01:02:22 <shapr> RibenaBoy: it looks like you're asking us to do your homework for you, because you don't seem to make any progress by yourself.
01:02:49 <Marvin--> guten morgen
01:02:55 <Marvin--> ludde: hacking on Debian stuff
01:03:00 <ludde> oh
01:03:13 <ludde> you had to go to .de to do that?
01:03:33 <shapr> Limited Edition Debian stuff?
01:04:52 <Marvin--> ludde: yeah, it's a developer meeting, it's amazing how much more you can get done if you stuff people from around the world in the same room
01:05:06 <ludde> oh neat :)
01:06:44 <shapr> I should have said "looks that way to me"
01:21:33 <Marvin--> bah
01:21:52 <shapr> humbug
01:23:28 <phubuh_> i've never been this bored
01:23:41 <shapr> phubuh_: write code!
01:23:43 <Marvin--> good for you
01:28:00 <shapr> phubuh_: what about a @help plugin for lambdabot? ;-)
01:28:01 <shapr> @yow
01:28:01 <lambdabot> Yow!  Are we wet yet?
01:31:38 <shapr> @fortune
01:31:39 <lambdabot> No one can feel as helpless as the owner of a sick goldfish.
02:57:59 <phubuh_> i posted some haskell code on a message board: "what language is that? some sort of VB clone?"
02:58:13 <shapr> haha
02:58:49 <phubuh_> this is all i posted, by the way, i don't know how he got the VB idea:
02:58:53 <phubuh_> main :: IO ()
02:58:53 <phubuh_> main = getContents >>= putStrLn . concat . intersperse " " . lines
02:59:11 <shapr> looks like Haskell to me, and not much like VB
02:59:14 <Darius> How do you get VB from anything Haskell?
02:59:28 * shapr dunno
02:59:32 <phubuh_> Darius, beats me. this guy isn't exactly known for his programming expertise, though.
02:59:42 * shapr snickers
03:00:04 <phubuh_> i remember some loop he wrote, whose body was:
03:00:15 <phubuh_>   array[i] = malloc(sizeof(char) * x);
03:00:19 <phubuh_>   array[i] = "NULL";
03:00:42 <phubuh_> he never used array again.
03:04:35 <shapr> hi bigodes 
03:04:42 <bigodes> hey
03:05:39 <shapr> haskell questions?
03:05:55 <shapr> blackdog: g'day
03:06:39 <bigodes> is there any way to make wxHaskell execs with a smaller size?
03:07:23 <shapr> on windows you may be able to use split-objs
03:08:23 <bigodes> hmm. i'm using mac os x, and the HelloWorld.app is 6 Mb 
03:08:42 <shapr> that is unusually large.
03:09:38 <shapr> have you asked on the wxHaskell message board or mailing list?
03:09:51 <shapr> I have no suggestions, I haven't used Haskell on Mac
03:10:37 <bigodes> nopes, i just remembered this question now because you hasked for questions. but now i'm getting a bit intrigued...
03:10:48 <shapr> ah
03:12:07 <bigodes> when i have more time i'll try to repeat the process and see what happens.
04:42:48 <ludde> bigodes: try strip
04:59:14 <o3> bigodes: see how big it is after stripping
04:59:25 <o3> bigodes: otherwise, are you statically linking in wxwindows?
06:14:00 <j0st> http://screenshots.scorpionn.com unix/linux screenshots & cool wallpapers :DD
06:19:19 <Marvin--> j0st: get lost
06:19:38 <Marvin--> lambdabot: op
06:19:38 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
06:19:40 <Marvin--> dang
06:20:48 <shapr> irc spam
06:20:56 <shapr> bonjour cinema 
06:21:10 <cinema> bonjour shapr
06:21:21 <shapr> comment ça va?
06:21:32 <Marvin--> so, how do I get op on this channel to kick out such bastards in the future?
06:21:41 <mgoetze> Marvin--: /quote cs op #haskell
06:21:49 <cinema> well, everything is OK when Haskell is the subject
06:22:12 <shapr> cinema: heh
06:22:22 <mgoetze> Marvin--: go ahead and try it :)
06:22:51 <cinema> I'm trying to implement Simon PJ's paper about financial contracts
06:22:56 <shapr> oh, nifty
06:23:05 <shapr> mgoetze: did you k-line that guy?
06:23:20 <shapr> somebody k-lined him.
06:23:22 <Darius> That's one I haven't read yet.
06:23:32 <mgoetze> shapr: no, it was Md. i don't have kline power :(
06:23:49 <cinema> It is a seminal paper
06:23:56 <shapr> mgoetze: I'm just a lowly chanop
06:24:17 <shapr> not even an ircop much less someone with k-line power.
06:24:54 <mgoetze> shapr: i know :)
06:25:04 <mgoetze> hey, at least i have UNkline power... lol
06:25:08 * shapr flexes his micromuscles
06:25:31 <shapr> cinema: have you had any success?
06:26:02 <shapr> asmodai: you've been terribly silent lately
06:26:22 <cinema> Well, I have been working on it for a long time. And it seems I need much more work before success
06:26:46 <cinema> In fact it involves all the techniques of DSEL
06:27:57 <cinema> My models are "Embedding SQL...", Pan, Vertigo (both extraordinary interesting papers, by Conal Elliott et al.)
06:28:50 <cinema> And now people use TH (Chakraverty et al.)
06:30:33 <cinema> I hoped Heffalump had worked in the same direction in his new paper, but apparently his interests now are just in .NET (treason !)
06:31:29 <shapr> !
06:31:39 <shapr> rewriting MAG for .NET?
06:31:58 <shapr> hi ray.
06:32:06 <cinema> no, optimising intermediate language in .net
06:32:40 <cinema> It seems he is rewriting MAG in TH, but no visible result yet
06:34:26 * Darius wonders if all of the Fun of Programming is available spread out across the web :P
06:35:45 <cinema> I have the book, but I downloaded several papers contained in it to takes notes (Elliott, Simon PJ)
06:37:14 <Lunar^> cinema: Where are you working ?
06:38:10 <cinema> I am working in a company which deals with payrolling - it is very complicated in France
06:40:13 <shapr> I heard rumors Lunar^ is from France also.
06:40:45 <cinema> 2 Haskellers in France ! That's good news
06:41:00 <shapr> possibly even three when sebc isn't in Edinborough
06:41:05 <asmodai> shapr; Hard at work
06:41:28 <shapr> asmodai: profitably at work? :-)
06:41:35 <shapr> asmodai: have you had any time to check out Haskell more?
06:42:11 <cinema> Haskell is spreading then. It will soon have replaced Cobol (in France)
06:42:19 <shapr> heh, yay!
06:42:32 <asmodai> shapr; Well, work's been insane, had 36 hours in 3 days the week before this, and one day of 15 hours in the last week.
06:42:49 <asmodai> shapr; And busy finalizing the Bugzilla/PostgreSQL port
06:42:57 <shapr> oh fun
06:43:24 <asmodai> uh huh
06:43:33 * asmodai has been hacking his SAN
06:43:46 <asmodai> we're going to migrate our serverroom to a new building
06:43:51 <shapr> Haskell gives SAN points :-)
06:45:57 <asmodai> ehehe
06:46:17 <lektu> I bet there's not many Haskellers from Spain :(
06:46:32 <shapr> actually, I met one at ICFP.
06:46:36 <shapr> Alberto something
06:46:40 <clausen> lektu: I think there are quite a few
06:46:46 <clausen> Juan Quintela
06:48:30 <lektu> I know there's people at the university who learns Haskell; but I don't think many of them try to use it afterwards.
06:49:35 <esap> I guess the problem is the same everywhere. The industry hasn't understood it needs Haskell.
06:50:29 <shapr> g'day shurik 
06:51:07 <shapr> g'bye shurik
06:51:48 <lektu> One newbie question: To manipulate dates (not time, specifically dates), what should I use? System.Time?
06:54:37 <shapr> CalendarTime ?
06:54:59 <shapr> there was a big discussion on the libraries mailing list about Time and Date manipulation
06:55:37 <lektu> shapr: I'll search the archives, then.
06:56:17 <shapr> esap: yes, I agree.
06:56:22 <lektu> But, for what I see about CalendarTime (or System.Time, in general), it doesn't seem to be very complete.
06:56:30 <shapr> I want to persuade the web dev industry that they need Haskell.
06:56:39 <shapr> lektu: I think that was mentioned in the discussion.
06:57:25 <Darius> shapr: Then I think you have a lot of libraries to write.
06:57:33 <shapr> I agree.
07:00:35 <phubuh_> merd is so yucky
07:00:49 <shapr> ?
07:01:18 <phubuh_> http://merd.net/
07:01:42 <phubuh_> it has some cool stuff, though
07:01:56 <shapr> the name is funny
07:03:49 <lektu> shapr: I was thinking of (pretty easy) stuff to do normal things: compute Easter, know if a year is leap or not, add/substract to a date, convert to Julian... All this is just a few lines of code, but is not supported by CalendarTime.
07:16:05 <Lunar^> cinema: I'm starting a course about Haskell this mercredi
07:16:18 <Lunar^> (I never remember how to spell wed...)
07:16:50 <cinema> Lunar^: Where are you studying ?
07:19:59 <Lunar^> cinema: It's a private engeenering school. I'm giving this course to the second year (out of 5 : prépa intégré)
07:21:01 <cinema> Sorry, I thought you were following the course !
07:21:32 <Lunar^> cinema: I'm still a student though
07:21:38 <cinema> I'm happy to hear that Haskell is taught in frech schools
07:22:01 <Lunar^> I made some lobying to get it
07:22:23 <Lunar^> Caml everywhere in France
07:22:26 <cinema> I'm living in Paris. Where are you living ?
07:22:28 <Lunar^> thanks to the INRIA
07:22:30 <Lunar^> same
07:23:15 <cinema> I know Caml is everywhere. I don't want to use/earn it, I love Haskell too much
07:23:34 <Smerdyakov> You will never earn it!!!! MUahahaha!
07:23:41 <cinema> (sorry, I meant use/learn)
07:23:49 <Lunar^> getChar : () -> Char <-- that sucks badly
07:24:03 <Smerdyakov> Lunar^, why?
07:24:40 <Lunar^> Smerdyakov: Because you can't really see that it's unpure as in Haskell
07:25:13 <Lunar^> Smerdyakov: For this particular example you can, but readFile : String -> String
07:26:26 <Smerdyakov> Lunar^, sure, but for systems programming, worrying about purity will just give you a headache.
07:26:56 <Lunar^> Smerdyakov: I think there's a lot of resaerch to do here
07:27:11 <Lunar^> Smerdyakov: I was thinking about Arrows as a way to make drivers
07:27:45 <whee> I think someone has implemented monads in ocaml
07:27:56 <phubuh_> whee, indeed
07:28:05 <whee> if you really want to take that approach, there's nothing stopping you
07:28:33 <phubuh_> no do notation, though
07:28:42 <whee> you've got camlp4, you can add it
07:28:46 <phubuh_> though with camlp4, yeah
07:29:48 <whee> I'd take ocaml over haskell for actually getting work done, anyway :)
07:29:52 * whee ducks
07:30:09 <phubuh_> i would as well, but that might be because i'm much better at ocaml than i am at haskell :)
07:30:22 <phubuh_> but academia isn't the place for real work!
07:30:23 <whee> I just find monads and all too much thought for something so simple
07:30:38 <phubuh_> i find monads simple and intuitive, actually
07:30:57 <whee> the concept is, but they always add up to overhead in  my mind
07:31:23 <Lunar^> I'm in the end of a quite large project, 2 000 lines of Haskell code
07:31:24 <phubuh_> they are definitely more work than just allowing side effects whereever, but c'est la vie :)
07:31:29 <Lunar^> 90% monadics
07:31:40 <whee> Lunar: that's my problem.
07:31:47 <whee> I don't want the majority of my code to be part of a monad
07:32:35 <Lunar^> Why not ? In Caml you just use a lot of ";" instead of writing "do"
07:33:10 <mgoetze> in scheme you just switch between functional and imperative whenever you want and wherever you want :)
07:33:17 <whee> because it's too much thought when you have a lot of monads combined and you're trying to figure out how to lift to get the one you want :P
07:33:27 <whee> while I'd rather just go and slap in a side effect and forget about it
07:34:32 <Smerdyakov> Lunar^, what kind of project is this? It sounds poorly designed if 90% of the code is in IO! Did you mean other monads for most of that?
07:34:47 <phubuh_> what's the easiest way to turn True into "1" and False into "0"? actually, '1' and '0' would work fine too.
07:35:07 <whee> somefunction True = '1'
07:35:12 <phubuh_> well, yeah :)
07:35:13 <whee> and the other obvious one :)
07:35:33 <Darius> mgoetze: Your sentence is self-contradictory.
07:37:21 <Lunar^> Smerdyakov: Yes, I'm not using straight IO
07:37:48 <Smerdyakov> Lunar^, is there a custom monad that makes up most of that 90%?
07:38:03 <Lunar^> Smerdyakov: right
07:38:35 <Lunar^> whee: I try to always have aliases with appropriate name for lifting
07:39:04 <whee> Lunar: I just don't like writing code in a monadic style, regardless of how many plugs are in place to make it easy
07:39:37 <Lunar^> whee: ok.. I would like to understand why exactly.. but it seems a personal taste
07:40:54 <mgoetze> Darius: how so?
07:41:16 <Darius> whee:  That could be taken to mean you don't like to program imperatively.  You could take OCaml as syntactic sugar for monadic code.
07:41:42 <Darius> mgoetze:  If you can use side-effects anywhere your code isn't functional.
07:42:16 <mgoetze> Darius: if that's how you choose to define functional...
07:42:18 <whee> Darius: most of the time I find I'm writing code, and go "hey, I could use a random number here or maybe grab some user input", and realize that I'm 10 function calls down and there's no way I'd get the appropriate monad at that point without ripping every
07:42:53 <Smerdyakov> Darius, given natural human information processing capabilities, it is ludicrous to call OCaml imperative constructs "syntactic sugar for monads."
07:43:37 <Smerdyakov> Darius, if for no other reason than that keeping track of whether or not a function is effectful requires more mental storage space than not keeping track of it.
07:44:10 <whee> Smerdyakov: and that's my other point. I, as a programmer, don't care. I care that it works; if it helps the compiler to know about the effects, then let the compiler deal with it
07:44:30 <Darius> Smerdyakov: But doing so is exactly what OCaml requires and Haskell doesn't!
07:44:46 <whee> I'll still write clean code, but I don't want some style enforced
07:45:59 <shapr> I vote with Darius, but then I am on #haskell and not #ocaml
07:46:03 <Smerdyakov> Darius, but it's possible to skip the bookkeeping if you are left to do it mentally, and the code can end up working in the end anyway. :)
07:46:05 <shapr> so no surprise there.
07:46:21 <shapr> Smerdyakov: you could do the same thing in asm
07:46:27 <Smerdyakov> shapr, yup
07:46:52 <shapr> the guy who wrote Forth thinks that types are just crutches for programmers
07:47:28 <shapr> the point is, I want to move as much of the mental bookkeeping to the compiler
07:48:38 <Lunar^> It's not only for bookkeeping
07:48:49 <shapr> phubuh_: nice to see you on ET :-)
07:48:56 <Lunar^> If the compiler knows where side effects are, it can also more easily optimize
07:48:56 <shapr> phubuh_: do you play on that server much?
07:48:57 <Smerdyakov> I'm not taking a stand on the superiority of methods.
07:49:19 <phubuh_> shapr, i don't know -- i just pick a suitable one in the server list :-)
07:49:30 <phubuh_> i'm horrible at ET-like games
07:49:32 <whee> Lunar: well, it should go find out. I don't want to keep track of it :)
07:49:35 <Smerdyakov> I'm only taking issue with the idea that OCaml imperativity is "syntactic sugar," since in reality it is possible not to keep track of effects and end up with working programs.
07:49:38 <phubuh_> i'm horrible at most games, in fact :-)
07:49:54 <shapr> phubuh_: I'm decent at ET, I get medals most of the time.
07:50:05 <phubuh_> i don't even know what a medal is
07:50:23 <phubuh_> well, of course i know what it is, but i didn't know they existed within ET :-)
07:50:49 <shapr> it's easiest to start out with a medic in my opinion
07:50:53 <whee> you get medals at the end based on your performance in ET
07:51:10 <Smerdyakov> And there are situations where you can determine that an operation only depends on a local set of mutable values, and so the effects of functions called can't possibly have any relevant effect on the computation.
07:51:28 <phubuh_> shapr, really? i assumed medics would be entirely useless for truistic purposes, as in most other games
07:51:35 <shapr> truistic?
07:51:41 <Smerdyakov> In Haskell, you'd have to keep track of which functions were monadic anyway.
07:51:56 <phubuh_> err, unaltruistic
07:52:29 <Darius> No, just use them and if you get a type error they are monadic.  In OCaml, if you have code that's impure and you expect it to be pure, the compiler won't tell you.
07:52:54 <Darius> What's wrong with OCaml being syntactic sugar (perhaps a slight exagerration) for monadic code?
07:53:16 <Darius> It's syntactic sugar (definitely exaggerated here) for some byte code.
07:54:28 <Smerdyakov> For bytecode, maybe, but not for language constructs.
07:55:31 <Smerdyakov> The empirical fact is that people find programming with IO monads more limiting, so it would be unhelpfully elitist to pretend that there isn't some essential reason behind that based on human capabilities.
07:55:52 <Smerdyakov> It could be a sheer amount-of-code factor.
07:56:27 <Darius> What does this have to do with the possibility of the existence of a transformation to monadic style of imperative code?
07:56:38 <Darius> I didn't say it was a good idea to think of it that way.
08:00:11 <Smerdyakov> I guess I generally think of "syntactic sugars" as treating input code in a context free way, or close to it.
08:00:28 <Smerdyakov> You need to do a global analysis for the kind of transformation you're proposing.
08:01:24 <Darius> Are you sure?
08:01:58 <phubuh_> shapr, i think the master server is down :( do you know the address of any servers?
08:02:11 <shapr> phubuh_: not off the top of my head, no
08:03:12 <Smerdyakov> Darius, yes. The need for global analysis to determine what's imperative is what forces the value restriction in ML, I think.
08:03:47 <Smerdyakov> Darius, any abstract data type could have references in it.
08:03:49 <Darius> Smerdyakov:  Why find out what's imperative?  Just assume everything is.
08:04:02 <shapr> phubuh_: 212.69.237.133
08:04:20 <phubuh_> shapr, thanks :-)
08:04:35 <phubuh_> i hope i can paste into et
08:05:19 <Smerdyakov> Darius, why not do the same in Haskell? It seems like doing so erases advantages that are commonly cited for functional programming, like some optimizations.
08:06:07 <Darius> Smerdyakov: I agree.  Perhaps you should look at what phrase I was responding to.
08:07:21 <whee> I'd be happy determining side effects was done automatically and done in the compiler; for example, if I need to use the IO monad in some function, it could look at all functions that call this particular one and see if it's possible to get it there
08:07:43 <whee> do it for all monads, and I'd be happy :)
08:07:58 <Smerdyakov> Darius, yeah, I see. It just seems untrue to make everything monadic when the programmer knows that parts are functional and has coded accordingly.
08:09:15 <Darius> Smerdyakov:  It was a bit of a joke.  Taking whee's statement to it's logical, but absurd conclusion.
08:11:58 <shapr> I wish I had Maybe in Python
08:12:16 <shapr> would be so nice to foldM over a bunch of Maybe valued stuff.
08:12:52 <Darius> It should be implementable.
08:12:58 * Darius doesn't know Python.
08:13:03 <shapr> python is pretty easy
08:13:35 * Darius doesn't really have any intention to learn Python.
08:13:50 <vegai> you really don't have to, just start writing ;)
08:16:42 <shapr> hi dullard 
08:16:50 <dullard> hello there
08:16:57 <shapr> how may we assist you?
08:17:59 <dullard> I'm wondering about which are the standard libraries for haskell. I'm a newbie and not too sure what to invest my time in learning
08:18:13 <dullard> specifically at the moment gui libs
08:18:42 <shapr> wxHaskell seems to be the recommended lib.
08:18:51 <shapr> look at http://wxHaskell.sf.net/
08:19:13 <dullard> does that have a high level functional flavoured interface?
08:20:13 <Darius> It's considered mid-level.  It's definitely not a Fudgets or Fruit.
08:21:35 <dullard> what about objectIO in the src distribution ( that I accidentally downloaded thinking it could bootstrap from c sources)
08:21:57 <shapr> only works on win32
08:22:08 <dullard> oh dear
08:24:02 <dullard> Are they working on Unix/other flavours - there seems to be a directory in there called Linux - obviously, I can only guess at what's going on since I am not yet au fait with the language
08:26:55 <shapr> the effort failed
08:27:07 <shapr> it seems that ObjectIO is too specific to win32 for some reason
08:31:16 <Lunar^> ObjectIO is considered mid-level as well, right ?
08:35:27 <Darius> Yes
08:40:01 <phubuh_> i would really love a high-level wxWindows-like library, in that it worked seamlessly with GTK2, Win32, etc
08:40:15 <shapr> wxWindows is cross platform
08:40:33 <phubuh_> yeah
08:40:41 <shapr> we should try it
08:40:44 <shapr> but I only have linux
08:40:50 <shapr> oh wait, I have a win32 laptop
08:40:54 <phubuh_> me too :/
08:40:55 <shapr> with a 1gb drive
08:41:04 <phubuh_> i suppose i could install windows in a VMware machine, though :-)
08:41:06 <shapr> I wonder if I could get wxHaskell on that.
08:41:22 <shapr> just before I cruelly rip off win32 and install linux.
08:45:25 <phubuh_> tee hee
08:53:27 * shapr discusses Zope's ancestry in an uncharitable fashion
08:54:11 * shapr questions the intelligence of some Zope authors
08:54:18 <phubuh_> hee hee
08:55:11 <phubuh_> i like giving the answers to my friends' C questions in C first, then in Haskell
08:55:45 <shapr> heh
08:56:13 <phubuh_> he needed help tracking down some off-by-one error in a fifteen-line function to do this: reverse . concatMap (show . flip mod 2) $ takeWhile (/= 0) $ iterate (`div` 2)
08:56:32 <phubuh_> :-)
08:59:58 <Darius> why did you flip mod 2, you could use a section like div
09:01:25 <phubuh_> ah!
09:01:38 <phubuh_> but i like that it almost says flip mode!
09:01:57 <phubuh_> i don't really know what flip mode is but busta rhymes says it, and busta rhymes is pretty awesome
09:03:02 <Darius> a collectWhile p f = takeWhile p . iterate f seems like it would be a useful library function.
09:03:27 <phubuh_> i agree
09:03:50 <d33p> flip mode squad
09:03:58 <d33p> its a group
09:04:50 <phubuh_> interesting
09:09:16 <dullard> thanx for the tip on wxWindows... looks good, must dash
10:41:45 <phubuh_> how do i get the square root of an Integer?
10:42:17 <shapr> sqrt?
10:42:42 <phubuh_> Prelude> sqrt (4 :: Integer)
10:42:42 <phubuh_> ERROR - Illegal Haskell 98 class constraint in inferred type
10:42:42 <phubuh_> *** Expression : sqrt 4
10:42:42 <phubuh_> *** Type       : Floating Integer => Integer
10:42:49 <shapr> fromIntegral?
10:43:02 <phubuh_> oh :)
10:43:12 <shapr> @type sqrt . fromIntegral (1 :: Integer)
10:43:17 * shapr pokes lambdabot 
10:43:18 <phubuh_> this still works for gigantic numbers?
10:43:22 <shapr> I don't know
10:43:26 <shapr> @type sqrt
10:43:26 <lambdabot> sqrt :: Floating a => a -> a
10:43:30 <shapr> @type sqrt $ fromIntegral
10:43:35 * shapr blinks
10:43:43 <shapr> @type (1 :: Integer)
10:43:43 <lambdabot> 1 :: Integer
10:43:55 <shapr> @type sqrt (1 :: Integer)
10:44:02 <shapr> @type fromIntegral (1 :: Integer)
10:44:03 <lambdabot> fromIntegral 1 :: Num a => a
10:44:11 <shapr> @type sqrt $ fromIntegral (1 :: Integer)
10:44:11 <lambdabot> sqrt $ fromIntegral 1 :: Floating a => a
10:44:30 <phubuh_> ah i think it does work for enormous numbers
10:44:35 <shapr> @type sqrt $ fromIntegral (99999999999999999999999999999999999999999999999 :: Integer)
10:44:36 <lambdabot> sqrt $ fromIntegral 99999999999999999999999999999999999999999999999 :: Floating a => a
10:44:40 <shapr> I think so.
10:50:16 <phubuh_> hmm... how would i declare a function isSquare? Integral a => a -> Bool doesn't work:
10:50:23 <phubuh_> ERROR "findgah.hs":5 - Inferred type is not general enough
10:50:23 <phubuh_> *** Expression    : isSquare
10:50:23 <phubuh_> *** Expected type : Integral a => a -> Bool
10:50:23 <phubuh_> *** Inferred type : Integral Double => Double -> Bool
10:50:39 * esap just finished an implementation of the control operation [and it works!]
10:51:07 <Darius> phubuh: just use whatever type it infers
10:51:33 <Darius> phubuh: In GHCi/Hugs you can use :t to get it to print the type or you can just not provide a type
10:51:38 <phubuh_> that doesn't work so well either:
10:51:39 <phubuh_> Main> isSquare 5
10:51:39 <phubuh_> ERROR - Unresolved overloading
10:51:39 <phubuh_> *** Type       : (Integral a, Floating a) => Bool
10:51:39 <phubuh_> *** Expression : isSquare 5
10:51:53 <phubuh_> isSquare n = sqrt (fromIntegral n) ** 2 == n, by the way
10:52:05 <phubuh_> oh, i need to fromIntegral the rhs
10:53:51 <phubuh_> (sqrt (fromIntegral 3) ** 2) == (fromIntegral 3) returns False...?
10:53:59 <phubuh_> 3.0 == 3 returns True though
10:54:10 <Darius> Also, ^^ would be better than **.
10:54:17 <Darius> phubuh: That's not suprising.
10:54:56 <Darius> Prelude> sqrt 3 ** 2
10:54:58 <phubuh_> oh, when i use ^^ instead of **, it works as expected
10:55:02 <Darius> 2.9999999999999996
10:55:32 <phubuh_> Main> sqrt 3 ** 2
10:55:32 <phubuh_> 3.0
10:55:32 <phubuh_> Main> (sqrt 3 ** 2) == 3
10:55:32 <phubuh_> False
10:56:26 <Darius> That's coincidence in this case.  You shouldn't use exact equality (==) on floating point values.
10:56:33 <phubuh_> okay
10:56:40 <Darius> (that being ^^ working)
11:09:50 <phubuh_> uniqueCountBetween x y = length $ filter isUnique $ enumFromTo x y
11:10:23 <phubuh_> will that needs to cons up a list of y - x elements?
11:10:46 <phubuh_> or does the laziness make it O(1) wrt memory?
11:15:14 <Darius> It should be O(1)
11:15:23 <phubuh_> great
11:15:45 <phubuh_> i'm running it on 10^^9 and 10^^10, you see :-)
11:15:53 <phubuh_> i wonder how many months that'll take
11:16:01 <phubuh_> does anyone happen to have a super computer? :/
11:16:56 <Darius> Why didn't you use the [x..y] syntax?
11:17:08 <phubuh_> oops, i was experimenting with making it points-free
11:21:49 <Darius> ((length . filter isUnique) .) . enumFromTo or curry (length . filter isUnique . uncurry enumFromTo) or you could take out the curry and change the type; using a pair wouldn't be that bad of an idea.
11:22:32 <Darius> Not that I'd recommend writing contorted code to get point-free style.  I only use it when it doesn't require twisting.
11:22:41 <phubuh_> yeah, so do i
11:22:52 <phubuh_> this is certainly weird
11:23:07 <phubuh_> running it with 10^^9 and 10^^10 takes about 10 seconds and then it just prints 0
11:23:19 <phubuh_> err, (sqrt 10^^9) and (sqrt 10^^10)
11:23:52 <Darius> It does have to actually make and filter the elements
11:24:06 <phubuh_> :/
11:24:47 <Darius> It only needs to keep one or two in memory at a time.
11:27:10 <phubuh_> oh.
11:43:44 <phubuh_> show gets me scientific form when used on huge numbers -- how do i get it in plain form?
11:48:45 <Darius> Possibly one of show(E|F|G)Float in Numeric
12:51:27 * shapr yawns
12:51:35 * Igloo bahs
12:51:39 * esap blinks.
12:51:50 <shapr> busy place :-)
12:52:08 <Igloo> crest's disk broke 6 days into compiling ghc6
12:52:18 <shapr> er, *six days* ?
12:52:41 <shapr> is that an m68k build you were doing?
12:52:41 <Igloo> It's an m68k machine doing a couple of other things at the same time (and possibly swapping to boot)
12:52:46 <shapr> wow.
12:52:48 <shapr> scary.
12:53:11 * esap has finally correctly (I think) implemented the control operation.
12:54:50 * esap hates unsafePerformIO :-)
13:19:05 * esap just posted a working implementation of control operation to wiki.
13:35:43 <Darius> Aren't exception handlers dynamically scoped?  If so, unless you are going for Felleisen's version of control, I doubt that implementation does the right thing.
13:40:16 <esap> darius: Well I didn't really look very closely at what version this is :-) I had trouble implementing even this one .-)
13:42:12 <esap> darius: for example, the use of deepSeq is essential there, otherwise it doesn't do what it's supposed.
13:56:32 * esap had some typos there, fixed.
14:01:47 <esap> darius: oh actually, you're right, I would have to add an identifier to the thrown object.
14:02:02 * esap wonders why I again did the same error :-(
14:04:41 <esap> But actually, now I guess it's easier than in my last attempt.
15:05:51 * esap fixed the control operator http://haskell.org/hawiki/ControlOperation . Now it can also skip those handlers that are not the correct target.
15:30:37 <phubuh_> i don't understand how monad transformers work :(
15:33:46 * shapr doesn't either
15:36:05 <phubuh_> http://www.math.chalmers.se/~rjmh/Combinators/Monads/sld019.htm tries to explain it, and i'm trying to understand it :)
15:38:01 <esap> Well a monad transformer is basically just a monad parametrized with another monad.
15:40:20 <phubuh_> yes
15:47:52 * shapr throws monads around the room
15:48:43 * Riastradh slices shapr apart with a comonad.
15:49:01 * phubuh_ quivers some arrows
15:49:18 <shapr> monad transformer reassemble!
15:49:24 <shapr> arrow attack!
15:49:51 * Riastradh duals!
15:50:06 <shapr> higher side order of fries grease attack!
15:50:34 <shapr> polymorph the parrot squawk!
15:50:40 * Riastradh knock's shapr's head off with a large comonad and then jumps through a shift and reset.
15:50:43 * shapr pretends to be a curried pokemon
15:50:59 <Riastradh> Knocks, even.
15:54:15 <esap> Hmm.. strange. I managed to get an expression where it doesn't matter how many arguments are applied to it. I didn't think that was possible.
15:56:35 <esap> control_prim (\x -> x "foo" "bar" "baz") and control_prim (\x -> x "foo" "bar" "baz" 10) are both valid and both return "foo". Very interesting expression.
15:56:54 <phubuh_> consider the function "inf = inf"
15:57:08 <phubuh_> :)
16:03:20 <Lunar^> lol
16:04:15 <Lunar^> phubuh_: The transform I use most often is ReaderT
16:04:55 <Lunar^> phubuh_: wrap it around IO and you've got a nice way to access a lot of MVar
16:05:36 <phubuh_> yeah, i've used state transformers (StateT), but i don't really understand how they work... i'm reading "The Essence of Functional Programming" now though :-)
16:06:27 <Lunar^> phubuh_: :)
16:09:10 <Lunar^> So many thing to learn... I don't catch control for the moment
16:34:17 <Potasso> can anyone answer me a question?
16:34:55 <Rafterman> not until you ask it
16:35:00 <Potasso> haha Ok
16:35:59 <Potasso> does the function curry return a function or the value returned by aplying the function received as parameter?
16:36:44 <Potasso> because the type is: curry:: ((a,b)->c) -> a -> b -> c
16:37:16 <Rafterman> it depends on how many arguments you actually supply to it I believe
16:37:38 <Potasso> if it returned a function shouldnt it be ((a,b)->c) -> (a -> b -> c) ??
16:37:57 <Rafterman> if you supply just the function ((a,b) -> c) it will return a function but if you supply the a and b, it'll return the value
16:38:54 <Rafterman> you can get functions as outputs without putting the brackets around the types
16:39:43 <Potasso> Rafterman, and how do you know it is a fuunction?
16:39:55 <Potasso> and not the value of aplying that funnction
16:40:19 <Rafterman> it depends on how many parameters are passed when curry is called
16:40:28 <Rafterman> you can do this trick with any function
16:40:38 <Potasso> hmhm
16:41:05 <Rafterman> if you only supply the first few inputs and not all of them, you will get back a function which takes in the remaining inputs and provides the output
16:42:54 <Potasso> hmhmhm
16:44:30 <Rafterman> do you want curry to return a function or the value?
16:44:52 <Potasso> Rafterman, hmhm why does it happen?
16:45:10 <Potasso> Rafterman, what is curry supposed to return?
16:45:21 <Potasso> i thought it returned a function...
16:45:55 <Potasso> im confused with the parentheses in the type definitions
16:46:51 --- mode: simak.freenode.net set +b *!23kjhkjf@*
16:46:52 <Rafterman> check out a reference on partial application of functions
16:47:18 <Rafterman> I've gotta run now, hopefully someone else here can pick up the ball and explain things better than i have :)
16:47:22 <Rafterman> good luck
18:05:17 <TDT> Hey all.  I'm a major haskell newb - literally very very new and don't understand this language very well, lol.  I'm trying to understand the major basics of haskell like even how to output to a screen and basic function structure.  Are there some 'easy' tutorials that can help me?  I read a lot of stuff at haskell.org and stuff - and nothing is making much sense.  Does anyone have other tutorials that are on the web that I could mess with (that 
18:05:46 <Smerdyakov> I/O is not basic in Haskell.
18:05:57 <TDT> what about outputting something?
18:06:08 <TDT> like lets say I want to have two lists, and output one of the lists to the screen?
18:06:19 <Smerdyakov> You can "output" a value by evaluating an expression that evaluates to it.
18:06:27 <Smerdyakov> (at the top level)
18:07:19 <Smerdyakov> So, in summary, instead of "printing" something, have it be the overall value of an expression you evaluate.
18:07:27 <TDT> so something like outputFunction x[] y[]  <cr> then | x
18:07:38 <TDT> i don't think that will work, but something on those lines?
18:08:00 <Smerdyakov> I have no idea, since that isn't valid Haskell code.
18:08:18 <Smerdyakov> Here's an example.
18:08:29 <Smerdyakov> You want to "Take 2 integers as input and print their sum."
18:08:35 <Smerdyakov> So you write a function:
18:08:40 <Smerdyakov> let addInts x y = x + y
18:08:43 <Smerdyakov> Then you type:
18:08:44 <Smerdyakov> addInts 0 1
18:08:50 <Smerdyakov> You "inputted" 0 and 1
18:08:55 <Smerdyakov> And the "output" of 1 is printed.
18:09:25 <TDT> if I wanted that to be in a function would it be:
18:09:31 <TDT> addInts x y
18:09:39 <TDT>     = x + y
18:09:53 <Smerdyakov> Oops
18:10:00 <Smerdyakov> Yes. I didn't mean to put the "let" there.
18:10:52 <TDT> err, hugs is complaining about a 'show function'
18:11:25 <Smerdyakov> Try putting this line before the function definition:
18:11:31 <Smerdyakov> addInts :: Int -> Int -> Int
18:13:48 <TDT> got the addInts function working, still not liking what i'm doing with lists though
18:14:00 <Smerdyakov> You can do the same thing with lists.
18:14:10 <Smerdyakov> Just evaluate an expression for the list you want printed.
18:15:11 <TDT> addInts x[] y[]
18:15:12 <TDT>         = x[] + y[]
18:15:28 <TDT> Main> addInts [1,2] [1,2]
18:15:28 <TDT> ERROR - Type error in application
18:15:28 <TDT> *** Expression     : addInts [1,2] [1,2]
18:15:28 <TDT> *** Term           : [1,2]
18:15:28 <TDT> *** Type           : [c]
18:15:30 <TDT> *** Does not match : [a] -> b
18:15:33 <TDT> lol
18:16:35 <Smerdyakov> Please do us all a favor and don't try to guess syntax in Haskell.
18:16:40 <Smerdyakov> Curl up with a nice tutorial.
18:16:50 <TDT> lol doing that now.
18:17:00 <blackdog> has anyone tried the helium environment for newbs?
18:17:37 <blackdog> apparently the error messages tend to be a bit more informative for those who don't curl up with HM typesystems at night...
18:17:42 <TDT> i'm on some 'two dozen question answer thing'
18:18:16 <TDT> i've also looked at haskell.org, and other sites too.  haskell for me is much harder than c++, don't ask me why, lol
18:19:09 <Smerdyakov> It's harder because you know C++ and you expect it to look and act like C++.
18:19:15 <TDT> spent many hours on this, and I can't even barely output anything lol
18:19:25 <Smerdyakov> If you were just starting with programming, you would find Haskell much simpler.
18:19:53 <Smerdyakov> For instance, the idea that "input and output" are central concepts of programming is a nasty consequence of C++'s infestation of your mind.
18:20:26 <TDT> lol, yeah
18:20:35 <blackdog> to be fair, the infestation belongs originally to turing machines, not C++. if only turing had used lambda calc instead... :)
18:20:58 <TDT> it's required for out class, and the teacher really doesn't go over any of this, we are expected to learn it on our own.
18:21:14 <TDT> that and we have weekly assignments, one being tomorrow, lol
18:21:22 <Smerdyakov> TDT, then your teacher is don't a bad job, and you should complain to the appropriate parties.
18:21:28 <Smerdyakov> s/don't/doing
18:21:43 <Smerdyakov> TDT, of course, since you waited so long to do the assignment, you're as much to blame.
18:22:00 <TDT> yeah, for a undergrad level course, this course is dang hard.  
18:22:39 <TDT> so yeah, just trying to get through this work somehow, lol.  especially the list concept is right now the main thing I need to learn to do the work
18:36:46 <TDT> wahoo! got a list function declared!
18:36:55 * TDT does happy dance
18:39:43 <TDT> it did an output! lmao, ok - i'm confident now that ( ) = lists.
18:40:02 <Smerdyakov> ?
18:40:03 <Smerdyakov> No
18:40:17 <TDT> pfft, ok bursting my ego bubble, lmao
18:40:30 <TDT> dunno what ( ) == then, but it's working :P
18:41:00 <Smerdyakov> OK, but you're probably not completing the exercise assigned to you.
18:41:36 <TDT> well, in very small steps I am, lol.  taking a risk trying this expression that's from the tutorial postscript files, maybe not work, but dunno lol
18:42:46 <TDT> well, tried the expression and got blew out of the water, lol.  
18:43:08 <Smerdyakov> I hope you realize that by all rights you deserve to fail this assignment for waiting this long. :P
18:43:17 <TDT> lol
18:44:07 <TDT> not sure I understand fully why i should spend a week on an assignment.  Finally coming to the conclusion that most of these teachers expect their homework to take a full week to do.
18:44:39 <Smerdyakov> You should start early enough to ask the teacher questions if you get stuck.
18:45:31 <TDT> yeah, I ask him tons of questions, and have, lol.
18:45:57 <TDT> i barely understand it even when he helps, lol.  
18:46:36 <Smerdyakov> So complain to the right people.
19:06:38 <TDT> I'm going through the tutorial right now about how to remove a character from a list.  I'm readying this tutorial and I'm not understanding something [c | c <- str, c /= chr]  -- I'm trying to do this with two lists [list1 | list1 <- list2, list1 /= list3] -- according to this tutorial, this should be correct.  This isn't the assignment, I'm just trying to learn how to take two lists and remove the duplicates and put them into another list.
19:20:46 <arguile> TDT: In the first you have Char and String, which we can generalise to a type of a and [a]
19:21:28 <arguile> Using list comprehension we compare a against each of the list of a's in the second argument
19:21:55 <arguile> You can think of it filter, you could do the same with a for loop
19:22:20 <arguile> In that context, think about what you are trying to do
19:23:17 <TDT> hmm...i think I see what you mean.  time to look up for loops in haskell, thanks.
19:23:25 <arguile> There aren't any
19:23:32 * TDT grumbles
19:23:38 <TDT> lol, dang :-/
19:23:39 <arguile> This is functional not imperative programming
19:23:48 <arguile> Use recursion
19:24:12 * arguile is bending the truth slightly but it will help in the long run
19:24:41 <TDT> k, i'll look my recursion example, and see if I can get that working
19:24:44 <TDT> htanks
19:24:46 <TDT> *thanks
19:26:14 <arguile> remove_char :: Char -> String -> String could also be written as:
19:26:56 <arguile> remove_char chr (c:str) | chr == c  =     remove chr str
19:26:56 <arguile>                         | otherwise = c : remove chr str
19:27:17 <arguile> If an example using primitave recursion instead of list comprehension helps you
19:27:27 <arguile> s/primitave/primative/
19:28:54 <TDT> interesting example.  looking up the stuff I don't understand in that, and hopefully that helps.  thx again.
19:29:33 <arguile> You get the basics of it though? List comprehension is just syntactic sugar for map . filter
19:30:02 <TDT> i'm pretty much a major newbie at this stuff.  going through tutorials to just understand this stuff to a small degree.
19:30:06 <arguile> What text do you have for this class?
19:30:30 <TDT> programming languages - principles and practice.
19:30:55 <TDT> good book, but doesn't go over much of this language
19:31:13 <arguile> I'd suggest "Haskell: The Craft of Functional Programming" if you want a good text for this
19:31:28 * arguile has no idea how long your functional programming bit is
19:31:52 <TDT> pretty much the whole class
19:32:12 <TDT> Not sure if I'll be using this stuff outside of this class, I don't know much about haskell or the uses, so I'm not sure at this point
19:32:53 <TDT> found the book on amazon
19:33:47 <arguile> It has a very good introduction for people new to functional programming in general
19:34:11 <arguile> Most of the online stuff for Haskell like http://www.haskell.org/tutorial/ assumes some knowledge of the concepts before hand
19:34:38 <arguile> ie. people coming from Scheme, LISP, Miranda, etc.
19:34:53 <TDT> most of my knowledge is in object oriented concepts.  I did a lot of functional programming in the past, but nothing on this sort of level
19:35:23 <TDT> who ever knew such a problem in the homework would cause such problems lol ::grumbles::
19:35:26 * arguile thinks schools way overstress OO
19:35:45 * Riastradh thinks just about everyone overstresses the very ill-defined concept of 'OO.'
19:35:54 <TDT> heh
19:35:55 <arguile> Riastradh: true that
19:36:18 <arguile> Though I must admit Eifel has some very interesting concepts
19:36:21 <Smerdyakov> I'll type type classes over OO any day. :)
19:36:30 <TDT> yeah, I just spent way too much time doing it.  qbasic/asic/gwbasic are the only 'functional' programming types I really messed with in the past heavily.
19:36:44 <Smerdyakov> Those aren't functiona..
19:36:45 <Smerdyakov> l
19:36:50 <arguile> Those are all imperative
19:37:18 <arguile>  /procedural (whichever term you like better)
19:37:37 <TDT> ah, ah ok, procedural i'm familiar with, imperative i was just looking up.
19:38:50 <TDT> unfortunately these basic haskell concepts are still confusing as heck.  if nothing else, this language will open my mind to other types.
19:38:53 * arguile wonders what they're teaching in that school
19:39:33 <TDT> here it's first and 2nd semester Java, 3rd c++, 4th is this class and comp organization and hardware.
19:40:03 <TDT> I've been doing solid OO programming since 9th grade, and haven't messed with anything else until now.  this is one heck of a hard conversion
19:40:26 <Smerdyakov> Again, the relevant difference is "imperative vs. functional."
19:40:30 <Smerdyakov> OOness is orthogonal.
19:41:15 <TDT> functional I haven't used solid til pre-9th grade for the most part, lol.  even that's been a long time ago :-/
19:41:54 <Smerdyakov> What functional language have you used?
19:42:04 <arguile> What confuses me is that they teach OO to such a high degree, release them into the world, then most do business apps which rely heavily on RDBMSs which are orthogonal to OO
19:42:19 <TDT> QB/gwbasic/basic/visual basic (half oo, but not really)
19:42:28 <Smerdyakov> None of those are functional at all, like we said.
19:42:30 <Riastradh> TDT, those aren't functional languages!
19:42:35 <arguile> TDT: Again, those aren't functional! Listen :)
19:42:40 <TDT> hmm...though tyou said they were :P
19:42:41 <TDT> lol
19:42:57 <TDT> imperative is procedural...nm
19:42:59 <Riastradh> 22:25 < Smerdyakov> Those aren't functiona..
19:43:00 <Riastradh> 22:25 < Smerdyakov> l
19:43:00 <Riastradh> 22:25 < arguile> Those are all imperative
19:43:06 <TDT> lol
19:43:25 <TDT> sorry, definitions are confusing me slighly :P
19:43:48 <arguile> Did they not teach the four main classes of programming?
19:44:19 <TDT> probably in computer science 1, skipped that because the teacher said that my programming skill was a bit too high for the class.
19:44:29 <TDT> missed some stuff i'm sure.
19:45:06 <Smerdyakov> I'm willing to bet it's been covered in your current class.
19:45:25 <Smerdyakov> And that you've suddenly reached the point where you can't just use your high school knowledge in college CS.
19:45:40 <Smerdyakov> So you've been skipping class, not paying attention, etc..
19:46:44 <TDT> heh, paying quite a bit of attention - as much as I can hear that is.  first few weeks of class were torture untl it got cold enough to keep the windows closed during construction
19:47:55 <arguile> Speaking of not paying attention, I have ~100 pages of the OS design principles book to read for next class. Going back to school is fun ;)
19:48:06 * arguile wanders off to read
19:48:19 <TDT> lol
19:48:45 <TDT> yeah, prolly would help slighly if I read the book for this class.   So far I haven't found anything he goes over in class even remotely available in this book
19:50:44 <TDT> maybe better do my comp organization hw.  that at least I'm understanding.  never messed with assembly, and this stuff is pretty easy to get through so far.  
