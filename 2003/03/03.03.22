01:39:58 <shapr> wheeee
01:43:07 <Arnia> Wheeee?
01:43:12 <shapr> it's morning!
01:43:14 <shapr> yay morning!
01:43:55 <debug> gmorning
01:44:19 <shapr> hi debug 
01:44:28 <shapr> did you see the extended version of your raytracer?
01:44:52 <debug> no?
01:45:11 <shapr> <Pseudonym> Real dielectric surfaces reflect more at grazing angles.
01:45:18 <debug> yes, I read that
01:45:36 <debug> it's not like I'm going to turn it into anything larger than it is now though
01:45:38 <shapr> lemme get the url
01:45:49 <debug> I just wanted to see if I could make it smaller than the equivalent program in C
01:46:07 <shapr> http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/rt/rt.hs
01:47:22 <shapr> I hope you don't mind a derivative of your code being in the sf.net cvs tree
01:48:35 <debug> well, since I'm going to send in a similar thing to IOCCC it might not be too good
01:48:36 <debug> hm
01:48:45 <debug> the code is not the same however
01:49:17 * debug reminds himself to put copyright notices on all his files
01:49:20 <debug> =]
01:49:53 <shapr> I've started putting copyright notices in all my code
01:50:02 <debug> anyway the goal was not to make a raytracer. it was to make it smaller than the C equivalent. and I have not succeeded yet
01:50:15 <shapr> I think the code could be smaller
01:50:21 <debug> yes
01:50:38 <debug> I'm not a haskell person, so someone else could probably rewrite it a lot
01:50:48 <shapr> it does look a bit like C right now
01:51:57 <debug> :)
01:52:48 <debug> hm
01:52:59 <debug> actually, maybe it would be best if he took it away
01:53:10 <shapr> I'll take it away
01:53:12 <debug> I don't know how strict the ioccc is in regards to previous art
01:53:26 <shapr> you should work up an entry for the iohcc ;-)
01:53:38 <debug> (I don't like keeping code secret though)
01:53:42 <debug> hm
01:54:36 <debug> the C version does not use macro definitions or anything like that, but it is still a lot smaller. hm
01:54:59 <shapr> is it smaller in total characters?
01:55:05 <debug> yes
01:55:16 <debug> that's with using single-letter variable names, of course
01:55:21 <debug> but it does more than the haskell version
01:55:40 <debug> slightly.
01:55:59 <shapr> I think refactoring the haskell version could make it much smaller
01:56:31 <debug> lambda expressions :)
01:56:39 <shapr> and more pattern matches
01:56:54 <shapr> and some case statements instead of if then else
01:57:15 <debug> haskell doesn't have any ?: operator, I presume?
01:57:26 <shapr> you could write one :-)
01:57:39 <debug> it's trinary, not binary
01:57:56 <shapr> I've seen trinary operators written, though I don't remember how they worked
01:57:57 <dennisb> haskell do have a ?:
01:58:02 <dennisb> it's called if .. then .. else
01:58:29 <debug> yes, but it takes up too much space :)
01:58:30 <debug> hehe
01:58:34 <dennisb> what we don't have is the c-if since everything is expressions in haskell
01:59:09 <dennisb> f b t e = if b then t else e
02:00:04 <dennisb> monadic "when" is similar to c-if though
02:00:07 <debug> but that would require lots of parentheses when actually used
02:00:15 <dennisb> yes, or $
02:00:36 <debug> you usually don't need () if you use ? and : in C
02:00:42 <dennisb> true
02:01:55 <dennisb> what code are you trying to shrink?
02:02:02 <dennisb> the one on SF?
02:02:31 <debug> no, my original
02:02:41 <debug> but I think I'll not waste time on it. :)
02:03:03 <debug> it was 52 lines I think
02:03:05 <debug> 2.3KB
02:09:26 <shapr> debug: ok, it's been removed
02:09:52 <shapr> I'm off to clean the apartment, and then work on lambdabot...
02:09:58 * debug would have submitted his ioccc entry last year, but OBVIOUSLY there was no ioccc last year
02:09:59 <shapr> I want to get factoids working today :-)
02:10:00 <debug> Murphy's law
02:10:08 <debug> shapr: have a nice day :)
02:10:17 <shapr> what other features should an irc bot have?
02:10:29 <shapr> well... time to clean, bbl
03:11:33 <o3> vd
03:11:41 <o3> oops
03:21:51 <kyagrd> hell
03:21:54 <kyagrd> hello
05:35:20 <Janni> hi!
05:51:56 <shapr> whee
05:52:06 <shapr> hi Janni 
06:02:19 <Igloo> Hi guys
06:05:17 <shapr> hello Igloo 
06:05:19 <shapr> wassup?
06:07:12 <Igloo> Making more webpages validate
06:08:04 <shapr> yay
06:08:10 <shapr> are you using WASH-HTML ?
06:08:38 <Igloo> Sadly not
06:09:00 * Igloo only has access to safeperl and SSI on this server, and future maintainers might complain if it was all in Haskell  :-)
06:09:40 <Igloo> The WDG validator will validate whole sites at once which is handy
06:09:53 <Igloo> Especially coupled with hiding valid results
07:34:00 <shapr> stupid question
07:34:28 <shapr> ...
07:34:30 <shapr> um
07:34:42 <shapr> maybe I should write some more test code...
07:34:58 <Igloo> ?
07:35:07 <shapr> I'm trying to return a monadic value from a case
07:35:14 <shapr> I think that's my problem at least.
07:35:26 <Igloo> Nothing wrong with that
07:36:20 <shapr> http://kungens.kemi.fi/~shae/src/haskell/ProtoPostgres.hs
07:36:33 <Igloo> Oh, cool
07:36:42 <shapr> in that url I just pasted, I can putStr the value from postgres
07:36:47 <shapr> inside the case statement
07:36:50 <shapr> but..
07:37:03 <shapr> this is *functional* code, I really want to return the value rather than just call forward with it.
07:37:04 <shapr> is that silly?
07:37:10 <shapr> am I approaching this incorrectly?
07:37:25 <Igloo> I don't understand
07:38:11 <shapr> value <- getFieldValue statement "field name"
07:38:21 <shapr> I think I would normally just return value then
07:38:38 <shapr> and then it would be String -> IO String
07:38:58 <Igloo> That makes sense
07:39:18 <Igloo> Well, actually, it's a strange way to do a database interface I think
07:39:41 <shapr> I've been doing DB stuff in procedural languages for a looong time, this is really twisting my brain :-)
07:39:52 <Igloo> It doesn't really make sense, I think you want a get_row functino and then a non-monadic get_field_value
07:40:25 <shapr> I think getFieldValue is a wrapper around the raw libpg function in C
07:40:44 <Igloo> Ah, OK
07:40:58 <shapr> so I don't know how I could make it a non-monadic getFieldValue
07:41:03 <Igloo> You certainly want getFieldValue of all fields to give you a consistent view of the row
07:41:36 <Igloo> If getFieldValue is a pure function you can make it non-monadic just by telling the FFI it's pure (i.e. not giving it an IO type)
07:42:18 <shapr> it's not pure
07:42:38 <shapr> statement will return a number of rows according to the query it's been given
07:42:49 <shapr> getFieldValue returns values from the fields in this row
07:43:43 <shapr> so if it were INSERT INTO ( nick, name, isp ) VALUES ( 'shapr', 'Shae', 'telia')
07:43:54 <shapr> and the query were select * from ircusers where nick = 'shapr'
07:44:10 <shapr> then getFieldValue "isp" would return "telia"
07:44:28 * shapr suspects that wasn't helpful information
07:45:11 <shapr> I'll play with it more, I think I need to figure out my question first ...
07:50:50 * shapr repeatedly crashes ghci
08:21:12 <Igloo> Ah, I see
08:21:19 <shapr> ?
08:22:27 <shapr> I'm still not sure why factGet isn't returning anything.
08:23:13 <Igloo> I see the design of it now
08:23:20 <shapr> ?
08:23:33 <Igloo> libpg
08:23:37 <shapr> oh
08:23:43 <Igloo> Sorry, I AFKed for a bit
08:23:46 <shapr> no worries
08:23:50 <shapr> irc is inherently asynchronous
08:24:12 <Igloo> And I'm about to do so again  :-)
08:24:16 <Igloo> *gone*
08:24:18 <shapr> cya
08:47:18 <shapr> hiya
08:47:24 <DrNerdware> Hiya
08:47:30 <shapr> do you have a livejournal?
08:47:36 <DrNerdware> yep
08:47:38 <shapr> aha
08:47:40 <shapr> cool
08:48:06 <shapr> I'm users/shae on livejournal
08:49:55 <shapr> are you done with your tree searching code?
08:50:04 <DrNerdware> http://nerdware.livejournal.com
08:50:18 <DrNerdware> i'm still working on it
08:50:30 <DrNerdware> trying to put it into a library form 
08:50:42 <DrNerdware> messing about with automake/autoconf
08:51:08 <DrNerdware> i'm thinking of writing a tool to create the automake files for buidling ghc packages
08:51:23 <shapr> sounds useful to me.
08:51:28 <shapr> not that I have much clue about automake.
08:51:34 <DrNerdware> getting tired of editing it all by hand
08:51:54 <shapr> ghc can output dependencies
08:51:55 <shapr> I tihnk
08:51:56 <DrNerdware> nor do i have much of a clue, but i've got a few things working
08:52:11 <shapr> ghc -M
08:52:22 <DrNerdware> i can't get automake/autoconf to use haskell dependencies
08:52:42 <DrNerdware> the GNU tools make too many assumptions about the build process
08:53:04 <DrNerdware> Haskell is too different from C, so the assumptions break
08:53:18 <DrNerdware> i use "ghc -M" a lot
08:53:25 <DrNerdware> more recently, i've been using hmake
08:53:41 <shapr> I like hmake
08:54:25 <shapr> I'm wrestling with monads at the moment
08:54:41 <shapr> I have a tenuous understanding of them...
08:54:47 <DrNerdware> yeah, you can always wrestle with monads ;)
08:55:21 <DrNerdware> i learned a lot about monads from hudak's soe book
08:55:35 <shapr> I have that book, and I've read most of it.
08:55:48 <DrNerdware> i started writing networking code after reading it
08:56:08 <DrNerdware> that's some more code to add to my library
08:56:45 <shapr> there's a neat echo server online somewher
08:57:27 <DrNerdware> i found some irc client code a few weeks ago
08:57:51 <DrNerdware> after writing my own very basic code, it was fascinating
08:57:59 <shapr> there's an irc 'bot in the cvs tree of http://sf.net/projects/haskell-libs/
08:58:09 <DrNerdware> that's probably where i saw it
08:58:16 <shapr> there's also a web server with apache-style pluggable modules
08:58:23 <DrNerdware> tasty
08:58:52 <shapr> I require a deeper understanding of monads to be able to effectively use those things though...
08:59:19 * DrNerdware grins
09:02:39 <shapr> at the moment, I'm being confused by this code:
09:02:41 <shapr> baz :: Int -> IO Int
09:02:42 <shapr> baz z = case z of
09:02:42 <shapr>                5 -> (readLn :: IO Int)
09:02:42 <shapr>                _ -> return 5
09:02:51 <shapr> when I run this in ghc: liftM putStr (liftM show (baz 5))
09:02:53 <shapr> and type 1
09:02:56 <shapr> nothing happens.
09:03:17 <shapr> hmm
09:03:23 <shapr> oh
09:03:35 <shapr> er
09:03:43 <shapr> shouldn't it be working?
09:04:04 <Janni> I have a problem with the class-system:
09:04:06 <Janni> class A a where
09:04:10 <Janni>         x :: X
09:04:11 <Janni>         f a = use x
09:04:32 <Janni> that doesn't work, because x isn't defined
09:04:48 <Janni> isn't it possible to leave the definition of x to instances?
09:05:00 <Janni> I don't want a default for x
09:05:40 * shapr doesn't know
09:06:00 <shapr> Janni: have you tried using a default implementation?
09:06:06 <shapr> hi whee 
09:06:08 <Janni> but I don't want do define f for every instance
09:06:45 <Janni> shapr: yes, it works with x = y, but I don't want every instance to have to define x
09:06:57 <Janni> s/don't//
09:07:15 <dennisb> Janni: the Monad class works like that, >> uses >>= in the default def. and >>= has no default def
09:07:20 <Janni> understandable: I want that every instance of A has to define x
09:07:32 <dennisb> I'm surprised it does not work for you
09:07:37 <whee> shapr: halo!@
09:07:47 <shapr> whee: statue
09:07:49 <whee> cvs ghc appears to finally work :))
09:07:53 <shapr> yay!
09:07:55 <Janni> dennisb: going to test a simple example...
09:10:38 <Janni> ah, the problem even exists in this example:
09:10:38 <Janni> class A a where
09:10:39 <Janni>         x :: Int
09:10:59 <Janni> what's the problem with it?
09:11:00 <Janni> ERROR "test.hs":2 - Ambiguous type signature in class declaration
09:11:00 <Janni> *** ambiguous type : A a => Int
09:11:00 <Janni> *** assigned to    : x
09:11:12 <andersca> dennisb: ziigo ziigo
09:11:58 <shapr> Janni: x:: Int and x = 5 works for me
09:14:04 * Janni is confused
09:14:18 <dennisb> Janni: so x does not depend on the type a?
09:14:44 <dennisb> why is it in the class?
09:15:59 <Janni> dennisb: every instance defines it to modify the "main-function" of the class
09:16:57 <Janni> So I can do s.th. like "instance A B where x = 5" and "instance A C where x = 6".
09:17:44 <dennisb> and how do you use x afterwards?
09:17:56 <dennisb> I see what you are trying to do
09:18:29 <dennisb> but what would it mean to write main = print x, which x will it print?
09:18:51 <Janni> ??? It's working in another example (more complicated code). gimme some time til I figure it out
09:20:24 <Janni> oh, it's working with ghci but not with hugs!
09:20:47 <shapr> Janni: this compiles http://kungens.kemi.fi/~shae/src/haskell/ProtoClass.hs
09:20:56 <shapr> I don't think it's quite what you want though
09:21:41 <shapr> you're trying to keep state inside the class instance, I think
09:22:29 <dennisb> each method in the class must refer to the class type
09:23:17 <dennisb> (with class type I of course mean the a above)
09:23:23 <dennisb> I think this is a bug in ghc
09:23:35 <Janni> dennisb: but i like this bug :)
09:23:51 <Janni> but I'll keep to the spec of course
09:23:55 <dennisb> so, what if I write my main program: main = print x
09:24:06 <dennisb> what would it print? Or should you get an error then?
09:25:05 <Janni> the definitions of the instances overwrite the classes definitions
09:25:12 <dennisb> also, even if your other default function uses x, which x should it be. There is nothing saying that the default method can only use other methods for the same class
09:25:17 <Janni> (didn't try it but I know they should)
09:25:44 <dennisb> for example, the overloaded show method for lists may use another show to "show" the elements in the list
09:26:12 <dennisb> I think it's natural to not allow x :: Int and such
09:26:46 <dennisb> you can always trick it, by defining a -> Int :-)
09:27:05 <dennisb> then you just have to call it with something of the correct type so it chooses the correct x
09:27:24 <Janni> ah, now I see. ghci allows x = 5 but not using this x in a "class function"
09:27:36 <Janni> so the x = 5 is useless
09:27:54 <dennisb> class Foo a where
09:27:54 <dennisb>    x :: a -> Int
09:27:54 <dennisb>    x _ = 3
09:28:16 <dennisb> sorry, the x _ = 3 should be in an instance
09:28:35 <Janni> yeah, I got it, thanks
09:29:14 <dennisb> or or why not:    x :: (a,Int)
09:29:28 <dennisb> it's a bit stupid, but hey :-)
09:29:54 <shapr> http://kungens.kemi.fi/~shae/src/haskell/ProtoClass.hs
09:29:59 <shapr> this is getting weirder fast :-)
09:30:23 <dennisb> shapr: class A is wrong
09:30:53 <dennisb> ghc should complain about it, but doesn't
09:30:58 <shapr> interesting
09:31:23 <shapr> aha
09:31:30 <shapr> I have -fglasgow-exts in my ~/.ghci
09:31:40 <Janni> shapr: as I said: hugs complains. ghc doesn't. it only complains when _using_ xA
09:31:52 <shapr> Janni: try it with -fno-glasgow-exts
09:32:07 <Janni> but as you see if you don't use xA it's pointless
09:32:08 <shapr> hm
09:32:30 <shapr> oh, nm
09:32:35 <dennisb> The haskell 98 spec clearly states that a must be mentioned in the type
09:32:40 <shapr> the glasgow-exts don't make a difference
09:33:06 <shapr> well, that's an interesting bug
09:40:22 <shapr> can someone tell me why this doesn't work: http://kungens.kemi.fi/~shae/src/haskell/ProtoReturn.hs
09:40:39 <shapr> how can I get a monadic value back from something that happens inside a case statement?
09:41:26 <dennisb> return
09:42:36 <dennisb> shapr: what is wrong?
09:43:07 <shapr> the last two functions in that url, baz and qux
09:43:14 <dennisb> looks fine
09:43:15 <shapr> neither give anything
09:43:21 <shapr> when called interactively in ghci
09:43:32 <dennisb> you just don't see the result
09:44:21 <dennisb> try: baz 5 >>= print
09:44:48 <dennisb> andersca: baz 2 >>= print
09:44:59 <dennisb> hmm, I wanted to write and:
09:45:19 * shapr is confused
09:45:56 <dennisb> the function returns a IO Int, ghci doesn't show IO Int-values
09:46:18 <shapr> not even with: liftM putStrLn $ liftM show (baz 5)
09:46:19 <shapr> ?
09:46:58 <dennisb> that has type: IO (IO ())
09:47:22 <shapr> !
09:48:59 <dennisb> this you can try: do f <- liftM putStrLn $ liftM show (baz 5); f
09:49:28 <dennisb> f is the IO () you get back and it is then called
09:50:22 <shapr> tackar
09:50:31 <shapr> jag forsta!
09:50:35 <shapr> kanske ;-)
09:50:50 <dennisb> jag förstår!
09:51:02 <shapr> ja, det
09:51:59 <shapr> jag har studerat svenska tre månader
09:52:24 <dennisb> jag har studerat svenska i tre månader
09:52:31 <shapr> tack
09:52:38 <dennisb> still, your swedish is good
09:52:46 <shapr> yay!
09:52:54 <shapr> svenska är kul.
09:53:04 <shapr> Jag trivs med svenska.
09:53:25 <shapr> dennisb: will you be at ICFP/HW in uppsala?
09:55:49 <dennisb> shapr: i don't know
09:58:51 <debug> hm
09:59:16 <shapr> I'm planning to show up at HW at least.
12:22:55 * shapr wades through the monads
12:25:23 <Marvin--> evening shapr
12:25:35 <mgoetze> hiya
12:25:41 <shapr> göd eftermiddag Martin
12:25:43 <shapr> y0 mgoetze 
12:25:56 <Marvin--> shapr: god ;)
12:25:56 <mgoetze> shapr: it's evening already :)
12:26:10 <shapr> yes, but I don't know that word in swedish ;-)
12:26:16 * shapr checks the online dictionary
12:26:40 <shapr> oh yah
12:26:46 <shapr> gödkväll
12:26:57 <Marvin--> shapr: god == good, göda == feed up
12:27:03 * shapr laughs
12:27:08 <mgoetze> gouda == cheese
12:27:12 <Marvin--> yes
12:27:25 <shapr> gouda kväll ;-)
12:27:28 <shapr> jag vil gouda!
12:27:44 <mgoetze> anyone up for a game of go?
12:28:14 <shapr> I'm still trying to make a factoid thingy for lambdabot
12:28:44 <Marvin--> I'll be damned... there seem to be interpretations of Swedish law that says that spam is "wide-spread information to the public" and has is thereby under the freedom of speech legal
12:28:51 <shapr> scary
12:29:22 * Marvin-- sends a mail to abuse@home.se anyway, hmmpfh
12:29:25 <whee> still working on that bot? heh
12:29:47 * mgoetze squashes swedish law with EU
12:30:10 <Marvin--> mgoetze: yes please
12:30:54 * mgoetze also squashes blair, aznar, berlusconi and other friends of bush.
12:31:34 <Marvin--> yay
12:34:57 <shapr> boy I'm crashing ghci every five minutes with this postgres stuff
12:39:46 * Marvin-- is listening to Finnish powermetal, yay
12:39:51 <shapr> which band?
12:42:04 <Marvin--> Timo Tolkki's solo project
12:45:34 * mgoetze is listening to corelli
12:45:44 * shapr is listening to Nine Inch Nails
12:46:12 <shapr> this is frustrating
12:46:31 <shapr> the postgresql binding in HToolkit is alpha quality :-(
12:46:39 <shapr> it crashes all over the place
12:49:20 <mgoetze> fix it! :)
12:49:30 <shapr> I don't know what the problem is...
12:50:55 <Smerdyakov> You ought to be able to find out....
12:51:47 <shapr> how?
12:52:07 <shapr> Smerdyakov: do you know how to debug hs2c FFI thingies?
12:52:32 <Smerdyakov> No, but I've debugged SML/NJ FFI thingies.
12:52:47 <shapr> how did you debug them?
12:53:23 <Smerdyakov> Find out where it crashes.
12:53:29 <Marvin--> heh
12:53:34 <Marvin--> debugging in a nut shell :-)
12:53:58 <shapr> Smerdyakov: any more details and I'd be overwhelmed ;-)
12:54:17 <Smerdyakov> Well, if you don't know how to do that, then you're in trouble....
12:54:41 <shapr> I know where it crashes in the Haskell code
12:54:51 <Smerdyakov> And then look in the C code....
12:55:40 <Smerdyakov> If it crashes in C code, you can use gdb to easily see exactly where the problem is.
13:16:17 <Marvin--> trExp (HsTuple es) = foldl HsApp tuple (map trExp es)
13:16:18 <Marvin--> yay, foldl
14:45:00 <Marvin--> hey cool, Stratovarius are playing here on Thursday
14:45:27 <andersca> nice
14:45:35 <andersca> although I'm in Umeå then
14:46:17 <Marvin--> what're you doing in Umeå?
14:46:35 <andersca> work thingy
14:46:52 <Marvin--> 'k
14:51:12 * andersca is fooling around with C#
14:51:36 <jlouis> andersca: warning: it makes you dumb :)
14:51:37 <Marvin--> iiik
14:51:45 <andersca> well, it's kinda cool
14:51:49 <andersca> in a non-haskell way of course
14:51:57 <andersca> http://carbon.hemmet.chalmers.se/Code/pinvoke.cs
14:52:01 <andersca> stuff like this is pretty impressive
14:52:34 <shapr> D Flat language
14:54:49 <Marvin--> andersca: foreign import ccall "math.h sin" c_sin :: Double -> Double
14:54:57 <andersca> hmm right
14:54:57 <andersca> :)
14:56:40 <Marvin--> andersca: D does things like that too
14:57:07 <andersca> http://carbon.hemmet.chalmers.se/Code/emit.cs
14:57:10 <andersca> this is pretty cool too
15:00:20 * Marvin-- swears at quickcheck for being so damn good
15:00:31 <shapr> what happened?
15:00:33 <andersca> never happy, eh? ;)
15:00:43 <andersca> http://www.guadec.org/paper-list.html <- guadec's gonna be a blast!
15:01:06 <Marvin--> I find bugs that I don't want to find
15:01:21 <andersca> Marvin--: kinda like D-BUS then :)
15:06:56 <Smerdyakov> Ah, for a moment I thought "guadec" would be "Graphical ___ ___ Declarative programming" =)
15:08:33 * Marvin-- blinks
15:15:16 * shapr fights the monads
15:24:08 <shapr> hi clausen 
15:24:40 <Marvin--> argh, I must have screwed something up after all
15:24:48 * Marvin-- really has to write that damn parser
15:25:12 <Marvin--> there are things that are more fun than writing programs in an abstract syntax
15:25:13 <clausen> gday
15:25:14 <shapr> what are you parsing?
15:25:30 <Marvin--> the helium subset of haskell, almost
15:25:39 <Marvin--> not bothering with the intricate things yet
15:25:52 <shapr> oh
15:25:53 <Marvin--> it's the master project
15:27:39 <Marvin--> wow, my translation functions are smarter than I remembered, cool
15:31:14 <Marvin--> AH, Proof found, phew
15:44:42 <Marvin--> my god what an awful movie
15:44:50 <shapr> which movie?
15:45:44 <Marvin--> The Phantom of the Paradise
16:00:40 <shapr> I have a type problem
16:00:45 <shapr> monadic confusion again, I assume
16:00:54 <shapr> *FactModule> :t ircPrivmsg "foo" 
16:00:54 <shapr> String -> IRC ()
16:00:54 <shapr> *FactModule> :t factoid3 "foo"
16:00:54 <shapr> IO [Char]
16:01:05 <mgoetze> shapr: write in perl, then :) no type problems there
16:01:22 <shapr> so, I want to get the result of (factoid3 "foo") into the second argument of ircPrivmsg
16:01:30 <shapr> *FactModule> :t liftM2 ircPrivmsg "foo" (factoid3 "foo")
16:01:30 <shapr> Couldn't match `String' against `Char'
16:01:30 <shapr>     Expected type: [String]
16:01:30 <shapr>     Inferred type: [Char]
16:01:30 <shapr> In the second argument of `liftM2', namely `"foo"'
16:01:36 <creature> Hey mgoetze.
16:01:37 <shapr> should liftM2 work there?
16:01:49 <mgoetze> hi creature
16:01:55 <mgoetze> sup?
16:01:56 <shapr> mgoetze: that would solve my problem, but I'm trying to be fluent in Haskell
16:02:15 <shapr> though at the moment I feel like I'm stuck in pidgin or patois
16:02:43 <creature> mgoetze - not much, I'm really bored and am jibbling with PHP at the moment.
16:02:51 <mgoetze> ewww, php
16:02:57 <mgoetze> you should learn go instead :)
16:03:08 <Marvin--> shapr: factoid3 "foo" >>= ircPrivmsg "foo"
16:03:18 <Marvin--> uh, no, wait
16:03:23 <Marvin--> what's IRC () ?
16:03:42 <shapr> it's a monad in lambdabot
16:03:51 <creature> mgoetze - PHP's a lovely language. 
16:04:02 <Marvin--> well, sure, but what kind of monad is it?
16:04:02 <creature> OK, I always feel like I'm writing really crap code in it, but I do like it. :)
16:04:14 <danols> how can I display IO action result it give back a list ? show just says <<IO ACTION>>
16:04:15 <shapr> Marvin--: state monad, I think
16:04:29 <shapr> danols: is kingston.net in jamaica?
16:04:45 <danols> no no no, it's in canada
16:04:51 <shapr> oh, ok...
16:04:55 <danols> i wish it was lol
16:04:56 <danols> so cold here
16:05:14 <danols> k <- ioaction don't work in haskell prompt
16:05:23 <shapr> Marvin--: so I can't just liftM2 ? I have to integrate with the other monads involved?
16:05:42 <creature> mgoetze - so what's up with you, then? 
16:05:47 <Marvin--> shapr: first of all, it'd be liftM, since you've already partially applied ircPrivmsg
16:06:08 <mgoetze> creature: well, i decided to drop computer engineering and start studying maths instead
16:06:38 <shapr> Marvin--: that was just for illustration purposes, in the third :t statement, I really do need liftM2 (I think)
16:06:42 <creature> What happened, did you have a blow to your head or something? :)
16:06:43 <shapr> *FactModule> :t liftM2 ircPrivmsg "foo" (factoid3 "foo")
16:06:51 <shapr> mgoetze: seriously?
16:07:12 <mgoetze> well, computer engineering was too little computer and too much engineering :)
16:07:34 <Marvin--> shapr: thing is, you'll get IO (IRC ()) from that...
16:07:39 <shapr> oh
16:08:25 <shapr> type IRC a = StateT IRCRWState (ReaderT IRCRState IO) a
16:08:36 <shapr> hm
16:08:57 <mgoetze> besides, i really like maths...
16:09:25 <shapr> that's a good reason.
16:10:17 <creature> mgoetze -> PM. That's my biggest change in my life of late; Libby. 
16:10:30 <shapr> prime minister?
16:10:31 <Marvin--> shapr: ah, it's a transformer thingy, then you can probably use liftIO and trickery :-)
16:10:54 <danols> how can I display a list generated by an IO action ?
16:10:57 <shapr> er, that's a monad transformer?
16:11:02 <shapr> oboy
16:11:12 <Marvin--> shapr: StateT and ReaderT are transformers
16:11:20 <shapr> yow
16:11:37 <shapr> any hints on using liftIO?
16:12:12 <mgoetze> shapr: PM is secret yahoo chat refugee jargon :P
16:12:18 <shapr> oh
16:12:21 <shapr> ok
16:12:29 <Marvin--> do s <- liftIO (factoid "foo"); ircPrivmsg ...
16:12:45 <shapr> Marvin--: tackar :-)
16:13:05 <danols> how can I display a list generated by an IO action ?
16:13:15 <danols> genChromo a = 
16:13:16 <danols> 	if a == []
16:13:16 <danols> 	then return []
16:13:16 <danols> 	else do element <- randomRIO (0::Int, (length a - 1)) -- select which trait are we going to use
16:13:16 <danols> 		rest <- genChromo (filter (/= (a !! element)) a) -- get the rest
16:13:16 <danols> 		return (a !! element : rest)
16:13:20 <shapr> yow
16:13:22 <shapr> d00d
16:13:40 <danols> ya ?
16:14:09 <shapr> just don't paste too much :-)
16:14:13 <shapr> five lines is about max
16:14:15 <shapr> imho
16:14:21 <shapr> not that I always follow that myself ;-)
16:14:22 <danols> ok
16:14:26 <danols> haha
16:14:36 <danols> it's that this IO action is a bit tricky for me still
16:14:37 <shapr> with lots of lines, it's best to invite people to #flood and paste there
16:14:44 <shapr> yah, IO is tricky for me too
16:15:08 <danols> the above returns an [a] IO, now how can I display it as [a]
16:15:15 <shapr> you mean IO [a] ?
16:15:16 <Marvin--> danols: you'll need something like  do l <- genChromo (...); print l
16:15:18 <danols> or just display it
16:15:18 <danols> yeah
16:15:42 <danols> Marvin-- any way to stop using the do ?
16:16:05 <danols> i.e. get out of the IO 
16:16:14 <Marvin--> danols: genChromo (...) >>= print
16:16:23 <Marvin--> danols: no, once you're in IO, you can't get out :)
16:16:23 <danols> wooha 
16:16:30 <danols> >>= means what ?
16:17:36 <Marvin--> danols: it's the same thing as do
16:18:28 <danols> Marvin-- it has a type of  a b -> (b -> a c) -> a c , how do you read that ?
16:19:14 <Marvin--> danols: "take an action producing a b, feed it to a function returning an action producing a b, and return that action"
16:19:54 <danols> a b is one action or two functions ?
16:21:04 <shapr> mmmm, it compiled!
16:21:16 * shapr bounces happily
16:21:20 <Marvin--> danols: a b is a monad action returning a b
16:21:56 <danols> print only works with IO actions ?
16:22:05 <danols> or is it overloaded
16:26:07 <Marvin--> print :: a -> IO ()
16:26:29 <shapr> lambdabot: @fact news
16:26:29 <lambdabot> nothing
16:26:34 <mgoetze> lambdabot: hi
16:26:34 <lambdabot> Sorry, I'm not a very smart bot yet.
16:26:42 <shapr> lambdabot: @fact lambdabot now has factoid support using PostgreSQL
16:26:43 <lambdabot> set
16:26:51 <shapr> lambdabot: @fact lambdabot
16:26:52 <lambdabot>  now has factoid support using PostgreSQL
16:26:57 * shapr cackles happily
16:27:15 <shapr> lambdabot: @listmodules
16:27:15 <lambdabot> I have the following modules installed: ["fact","hello"]
16:27:20 <shapr> lambdabot: @hello
16:27:20 <lambdabot> Hello world. 
16:27:30 * shapr dances ecstatically
16:27:41 <shapr> lambdabot: @fact shapr
16:27:41 <lambdabot> nothing
16:27:47 <shapr> w00
16:28:02 <Marvin--> shouldn't it be Nothing? :)
16:28:16 <mgoetze> Marvin--: _|_
16:28:47 <shapr> lambdabot: @fact foo
16:28:47 * Marvin-- negates mgoetze
16:28:47 <lambdabot> bar
16:28:52 <shapr> lambdabot: @fact test
16:28:52 <lambdabot> test
16:29:33 <shapr> yay! I wrote a lambdabot factoid plugin!
16:29:39 <shapr> now it just needs simpler syntax
16:29:45 <shapr> that liftIO did the trick instantly
16:35:46 <shapr> lambdabot: @martin
16:35:46 <lambdabot> Sorry, I don't know that command.
16:35:52 <shapr> lambdabot: @fact martin
16:35:52 <lambdabot> nothing
16:35:55 <shapr> lambdabot: @fact marvin--
16:35:55 <lambdabot> nothing
16:35:57 <shapr> lambdabot: @fact marvin
16:35:58 <lambdabot>  martin sjogren
16:35:59 <shapr> aha
16:36:46 <Marvin--> yay, I guess
16:37:07 <shapr> lambdabot: @fact marvin knows haskell
16:37:07 <lambdabot> set
16:37:10 <shapr> lambdabot: @fact marvin
16:37:10 <lambdabot>  martin sjogren
16:37:21 <shapr> need to add multiple rows, and deletion
16:47:28 <danols> what does this mean ?*** Term           : (genChromo traits,calcFit criteria 0) : genPop (popsize - 1
16:47:28 <danols> ) traits
16:47:28 <danols> *** Type           : [(IO [c],d -> d)]
16:47:28 <danols> *** Does not match : ([a],[b])
16:47:46 <danols> tjat my calcFit criteria 0 should return an IO or that genPop should not return an IO action
17:05:27 <inkedmn> who's bot is that?
17:05:35 <inkedmn> and what language is it in?
17:05:40 <shapr> my bot
17:05:43 <shapr> well, not mine
17:05:49 <shapr> written by Andrew Bromage
17:05:54 <shapr> aka Pseudonym
17:05:57 <shapr> it's written in Haskell
17:06:02 <inkedmn> ooh...
17:06:07 <inkedmn> any way i can see the source?
17:06:16 <inkedmn> @source
17:06:19 <shapr> sure
17:06:30 <shapr> it's in the cvs tree of http://sf.net/projects/haskell-libs/
17:07:51 <inkedmn> dude, that's hot...
17:08:10 <shapr> I wrote the factoid support in just a few hours
17:08:25 <shapr> with help from #haskell of course
17:09:08 <inkedmn> heh
17:09:17 <inkedmn> hmm, no cvs tarball?
17:09:21 <shapr> nope
17:09:24 <inkedmn> ok
17:09:28 <shapr> anonymous checkout from cvs 
17:09:30 <inkedmn> yeah
17:09:49 <shapr> I don't know how to do cvs tarballs on sf.not
17:09:52 <shapr> er, sf.net
17:11:29 <inkedmn> grabbing now
17:11:41 <shapr> future plugins: search haskell-wiki, citeseer, and hopefully a local database of research papers
17:13:58 <inkedmn> who knows, maybe i'll contribute :)
17:13:58 * inkedmn checks out licensing
17:14:44 <inkedmn> looks like a BSD license, sweet :)
17:15:56 <mgoetze> shapr: how about a karma system? :)
17:16:07 <shapr> oh, good idea
17:22:07 <whee> shapr: how are you handling events? any threading?
17:22:20 <shapr> I think so..
17:23:02 <shapr> yes, looks like IRC.hs is threaded
17:23:21 <whee> neat
17:23:36 <shapr> I just wrote a plugin, I don't completely understand the internals
17:24:05 <shapr> various transformed stacked monads in there
17:24:08 <shapr> over my head
17:24:13 <whee> heh
17:26:16 <shapr> looks like there's at least a reader thread and a writer thread
17:27:14 <whee> irc bots are one of those things that basically have to be done concurrently somehow, otherwise you're blocking on the network or blocking for some other thing
17:39:06 <inkedmn> most of the ones i've worked on have used asynchronous sockets
17:39:49 <whee> well yeah you can do that for the networking, but handling things initiated by users needs to be done without interrupting other users' requests
17:40:14 <inkedmn> hence the threads :)
17:40:18 <whee> indeed :P
17:40:45 <inkedmn> well, unless the bot is looking stuff up on the web or using a database, threading shouldn't really be necessary
17:41:58 <whee> if you assume the bot's on multiple servers dealing with tons of requests, it'd be nice :)
17:44:12 <inkedmn> well, that's a big "if" :)
17:44:52 <inkedmn> i suppose threads would be a good idea if you were going for scalability
17:57:55 <danols> *** Does not match : ([a],[b])
17:58:03 <shapr> ?
17:59:18 <danols> *** Term           : (genChromo traits,calcFit criteria 0) : genPop (popsize - 1
17:59:18 <danols> ) traits
17:59:18 <danols> *** Type           : [(IO [c],d -> d)]
17:59:18 <danols> *** Does not match : ([a],[b])
17:59:21 <danols> sorry
17:59:24 <danols> what does that mean ?
18:00:10 <danols> i need to make calcFit, an IO ?
18:02:23 <shapr> what does ":t calcFit criteria 0" give you?
18:04:00 <danols> Part2> :t calcFit
18:04:00 <danols> calcFit :: (Eq [a], Num b) => [a] -> (a -> b) -> b -> b
18:04:26 <danols> can I have a touple of (IO a, b) ?
18:04:32 <danols> can I have a touple of (IO [a], b) ?
18:04:39 <shapr> looks to me like (genChromo traits,calcFit criteria 0) :: [(IO [c],d -> d)]
18:04:55 <danols> yeah
18:05:07 <danols> calcFit just returns an Int
18:05:17 <shapr> so the error is saying that all the items in a list have to have the same type
18:05:24 <shapr> and the first item has that type
18:05:31 * inkedmn goes to have a smoke, then returns to work on some haskell...
18:05:42 <shapr> but the second item, genPop etc, has a different type
18:05:48 <shapr> inkedmn: whatcha writing?
18:06:06 <inkedmn> shapr: nothing, just trying going through the book i have trying to learn the language
18:06:08 <danols> genPop popsize traits criteria
18:06:08 <danols> 	| popsize == 0 = ([],[])
18:06:08 <danols> 	| otherwise = (genChromo traits, (calcFit criteria 0)) : genPop (popsize - 1) traits
18:06:14 <inkedmn> just little exercises, etc.
18:06:17 <danols> is it my default cause that is incorrect ?
18:06:55 <shapr> danols: I don't know, just that you're trying to make a list that has different types in the items
18:07:01 <shapr> inkedmn: which book are you reading?
18:07:59 <shapr> danols: what type should genPop have?
18:08:22 <danols> a touple of (IO a, Int) (IO a since I used IO to generate a)
18:08:28 <shapr> danols: is this homework? or are you learning Haskell for fun?
18:08:29 <danols> IO [a] I mean
18:08:36 <danols> both
18:08:39 <danols> well not for learning
18:08:46 <danols> cause it was handed in already
18:08:56 <danols> i mean for learning 
18:09:32 <shapr> your base case and your otherwise case need to have the same types
18:09:53 <danols> that's what I thought was the problem, how should my base case look ?
18:10:02 <danols> (IO [], b) ?
18:10:22 <danols> or just [] ?
18:10:23 <shapr> it should have the same type as your tuple
18:10:52 <inkedmn> shapr: Haskell: The Craft of Functional Programming
18:11:05 <shapr> ah, that's the one I read first.
18:11:07 <shapr> good book.
18:11:12 <shapr> hi bd_ 
18:11:29 <bd_> How do I get hugs to work with the examples in 'a gently introduction to haskell'? It says things like 'ERROR - Syntax error in expression (unexpected keyword "data")
18:11:29 <bd_> '
18:11:39 <bd_> hi shapr
18:12:03 <shapr> bd_: some things need to be written into a file and loaded into hugs
18:12:11 <shapr> data declarations are one of those things
18:12:19 <danols> shapr i know that the base case should be the same type as otherwise, how do you specify a base case of type (IO [a], Int)
18:12:30 <bd_> oh. What interpreter do you know of that would allow me to do that?
18:12:43 <shapr> bd_: none that I know of
18:12:45 <inkedmn> bd_: i don't think any haskell interpreters allow you to create functions
18:13:00 <shapr> I use emacs so I can load my file with one keystroke
18:13:03 <inkedmn> you have to write them in a file and load them into hugs (like shapr said)
18:13:11 * inkedmn uses vim
18:13:48 <shapr> lambdabot: @fact #haskell
18:13:49 <lambdabot> nothing
18:14:00 <mgoetze> vim rulz!
18:14:12 <inkedmn> @fact source
18:14:12 <shapr> lambdabot: @fact #haskell everyone's favorite purely functional channel
18:14:13 <lambdabot> SqlError {seState = "E", seNativeError = 7, seErrorMsg = "ERROR:  parser: parse error at or near \"s\" at character 64\n"}
18:14:16 <shapr> whoops
18:14:23 <inkedmn> heh
18:14:28 <danols> shit
18:14:33 <danols> crap
18:14:57 <danols> i don't get this
18:14:59 <shapr> lambdabot: @fact #haskell everyone\'s favorite purely functional channel
18:14:59 <lambdabot> set
18:15:06 <shapr> lambdabot: @fact #haskell
18:15:10 <shapr> uh oh
18:15:19 <shapr> lambdabot: @hello
18:15:19 <lambdabot> Hello world. 
18:15:21 <shapr> whew
18:15:35 <shapr> lambdabot doesn't like unescaped single ticks
18:15:39 <danols> my list will be of type [(IO [a], b], how do I make the base case match that type ? ([],[]) don't work
18:15:59 <inkedmn> shapr: regarding the book, i seriously can't think of a worse example to start with than the picture thing
18:16:11 <inkedmn> and he's always referring back to it
18:16:20 <shapr> inkedmn: have you tried Hudak's SOE?
18:16:28 <inkedmn> dunno what that is
18:16:28 <inkedmn> :)
18:16:36 <inkedmn> @fact
18:16:59 <danols> is my question even making sense ?
18:17:01 <inkedmn> @fact #haskell
18:17:23 <inkedmn> danols: i'm a total newbie, otherwise i'd try to help :)
18:17:41 <shapr> lambdabot: @fact SOE Haskell School of Expression by Paul Hudak
18:17:41 <lambdabot> set
18:17:47 <shapr> lambdabot: @fact SOE
18:17:55 <inkedmn> shapr: is that a book?
18:17:56 <shapr> hrm :-/
18:18:02 <inkedmn> or a tut online someplace?
18:18:03 <shapr> http://www.haskell.org/soe
18:18:05 <bd_> ah, here's a hack in hugs to define things on-the-fly: :load /dev/stdin, end with EOF
18:18:07 <shapr> it's a book
18:18:16 <inkedmn> ah
18:18:24 * inkedmn is unemployed and can afford no more books :(
18:18:25 <shapr> crap, that unescaped single tick has really upset lambdabot
18:19:40 <danols> a list of touples i.e. [(a,b)] what is the last empty elemnt represented as ?, i.e. in [a] it is []
18:20:26 <mgoetze> danols: []
18:20:49 <danols> genPop popsize traits criteria
18:20:49 <danols> 	| popsize == 0 = []
18:20:49 <danols> 	| otherwise = (genChromo traits, (calcFit criteria 0)) : genPop (popsize - 1) traits
18:20:55 <danols> give me a type error i don't see why ?
18:21:13 <danols> otherwise returns (IO a,b)
18:21:22 <danols> ohhhh FUCK
18:21:24 <shapr> lambdabot: @fact soe
18:21:25 <danols> nevermind
18:21:25 <lambdabot> nothing
18:21:26 <danols> i see it
18:21:27 <shapr> lambdabot: @fact SOE
18:21:33 <shapr> hrm :-/
18:23:31 <shapr> bah humbug
18:24:15 <inkedmn> shapr: ok, so i'm writing a function that gives the minimum of 3 integer arguments
18:24:26 <inkedmn> now, i know i could do something like:
18:24:41 <inkedmn> | x < y and x < z = x
18:24:48 <inkedmn> or however that's supposed to be
18:24:59 <inkedmn> but there has to be an easier way
18:25:21 <inkedmn> hmm, maybe not
18:25:33 <shapr> you could partially apply >
18:25:52 <inkedmn> well, the books example of getting the max of 3 integers does it like i just kinda did
18:26:03 <shapr> and $ map (x >) [y,z] 
18:26:04 <shapr> :-)
18:26:35 <inkedmn> well, i don't want to get ahead of the book
18:27:41 <inkedmn> hmm...
18:28:06 <shapr> time for me to go to sleep
18:28:27 <shapr> g'night all
18:29:16 <inkedmn> later man
18:33:19 <danols> genPop :: Int -> [a] -> [b] -> (IO [a], b)
18:33:19 <danols> genPop popsize traits criteria
18:33:19 <danols> 	| popsize == 0 = []
18:33:19 <danols> 	| otherwise = (newchromo, calcFit newchromo criteria 0) : genPop (popsize - 1) traits criteria
18:33:19 <danols> 		where newchromo = genChromo traits
18:33:26 <danols> man what gives , is this wrong ?
18:35:10 <danols> is anyone able to tell me why i get type errors ?
18:36:08 <danols> *** Expression     : (newchromo,calcFit newchromo criteria 0) : genPop (popsize
18:36:09 <danols> - 1) traits criteria
18:36:09 <danols> *** Term           : genPop (popsize - 1) traits criteria
18:36:09 <danols> *** Type           : (IO [b],c)
18:36:09 <danols> *** Does not match : [a]
18:36:22 * inkedmn has no idea
18:36:40 <danols> fuck!
18:38:31 <danols> newchromo = genChromo where genChromo returns a IO type
18:38:36 <danols> thoes this help ?
18:39:58 <inkedmn> i'm still trying to figure out how to do simple if->then->else stuff
18:40:09 <inkedmn> so i'm afraid what you're doing is outside my current haskell skillset
18:40:12 <danols> man, it's a tought ride i tell you
18:40:34 <inkedmn> yeah, i'm getting that impressino
18:40:37 <inkedmn> er
18:40:39 <inkedmn> impression
18:40:47 <inkedmn> i know python and java, but haskell is a whole different animal
18:42:12 <inkedmn> RROR "/home/inkedmn/code/haskell/code/Practice.hs":17 - Instance of Num Char required for definition of isLowercase
18:42:19 <inkedmn> any idea what that's about?
18:42:36 <inkedmn> isLowercase :: Char -> Bool
18:42:37 <inkedmn> isLowercase a = if ord a < 97 || a > 122 then False else True
18:42:45 <inkedmn> there's the code in question
18:43:12 <inkedmn> bah, n/m
18:43:14 <danols> beats me lol
18:43:24 <inkedmn> i wasn't calling "ord" on the second a
18:46:50 <danols> FUCK
18:52:00 <danols> do | when working with IO actions ?
18:53:06 <danols> can you use | when working with IO actions ? or if then else statements must be used ?
18:55:05 <kawfee> you use do
18:55:38 <danols> i need to make a function that takes in an IO action result, i need to convert the following function
18:55:46 <danols> calcFit chromo criteria score 
18:55:46 <danols> 	| chromo == [] = do return score
18:55:46 <danols> 	| otherwise    = do return (calcFit (tail chromo) criteria (score + criteria (head chromo)))
18:55:52 <danols> crhomo is an IO action result
18:55:54 <inkedmn> kawfee: is there some magic way to turn a char into it's int value?  like '8' -> 8
18:56:08 <kawfee> inkedmn: there is a way
18:56:09 <whee> inkedmn: read?
18:56:11 <danols> inkedmn try read
18:56:18 <kawfee> or reads
18:56:22 <kawfee> reads works better
18:56:33 <kawfee> in the sense that it doesn't fail
18:56:39 <danols> kawfee can a function take an IO action result as a parameter ?
18:56:46 <kawfee> danols: sure
18:56:59 <danols> what is the general approach , layout 
18:57:01 <kawfee> it can even take a list of them
18:57:18 <kawfee> are you using hugs?
18:57:21 <danols> yes
18:57:28 <inkedmn> Practice> reads '8'
18:57:29 <inkedmn> ERROR - Type error in application
18:57:29 <inkedmn> *** Expression     : reads '8'
18:57:29 <inkedmn> *** Term           : '8'
18:57:29 <inkedmn> *** Type           : Char
18:57:29 <inkedmn> *** Does not match : [Char]
18:57:42 <inkedmn> so it has to be a list?
18:57:43 <danols> try "8"
18:57:50 <kawfee> nm
18:58:09 <inkedmn> Practice> reads "8"
18:58:09 <inkedmn> ERROR - Unresolved overloading
18:58:09 <inkedmn> *** Type       : Read a => [(a,[Char])]
18:58:09 <inkedmn> *** Expression : reads "8"
18:58:23 <danols> like my function takes chromo which is an IO action result
18:58:33 <kawfee> danols: ok
18:58:34 <danols> and I want to do something on it
18:58:38 <kawfee> then do it
18:58:54 <danols> hahah, i can't nomads are a pain in the ass
18:59:24 <kawfee> ever heard the story of the little train that said "I think I can"
18:59:34 <danols> ahhh ok
18:59:48 <kawfee> you'll never get anywhere if you don't try
18:59:55 <kawfee> what's your problem?
18:59:55 <danols> trust me I am
18:59:59 <danols> hold on
19:00:16 <danols> calcFit chromo criteria score 
19:00:16 <danols> 	if chromo == [] then do return score
19:00:16 <danols> 	else do return (calcFit (tail chromo) criteria (score + criteria (head chromo)))
19:00:24 <kawfee> yeah, what about it?
19:00:30 <danols> is that correct ?
19:00:41 <kawfee> oh, that's your answer?
19:00:50 <danols> yes to my problem
19:00:54 <danols> my best guess
19:00:57 <kawfee> what's the type?
19:01:04 <danols> it retruns an IO Int
19:01:14 <kawfee> what is the type of the parameters
19:01:16 <danols> takes an IO [a], function, Int
19:01:30 <danols> -> IO Int
19:01:43 <kawfee> give me the entire type of the function
19:02:22 <danols> shit i'm guessing IO [a], (a ->b), b ?
19:02:45 <kawfee> what should the function do?
19:04:03 <danols> for example it takes a list of [2,2] function (+2) and 0, it adds +2 to [2,2] ands it up and return an 8, i had this working in non IO mode
19:04:07 <kawfee> how can you do "score + criteria (head chromo)"
19:04:35 <danols> the problem arose when I tried passing it the list which was a result of an IO action
19:04:41 <kawfee> yeah, foldr should do that
19:04:52 <kawfee> ahhhh
19:04:54 <danols> i know 
19:05:03 <danols> but foldr is limited for what I'm planing to use it with
19:05:04 <kawfee> so, what's in th list?
19:05:08 <danols> anything
19:05:15 <kawfee> even IO actions?
19:05:19 <danols> IO [a] 
19:05:22 <danols> no IO [a]
19:05:27 <kawfee> so it isn't [Int}
19:05:29 <kawfee> so it isn't [Int]
19:05:33 <danols> nope
19:05:34 <danols> it's general
19:05:45 <danols> i'm trying to toy with genetic algorithims
19:05:49 <kawfee> so it could take [Int] ?
19:06:11 <danols> calcFit yes ? or [Char] depending on the function it will return still an Int score
19:06:37 <kawfee> how can you get an Int from a [IO]
19:06:52 <inkedmn> can i cast an int to a float in haskell?
19:06:55 <danols> it simply takes an IO [a], apllies a function to a which returns b , and that b accumulates and the finall Int value is returned
19:07:00 <kawfee> inkedmn: fromInt
19:07:07 <inkedmn> kawfee: ah...
19:07:07 <kawfee> in hugs that should do it
19:07:16 <danols> kawfee what do you mean ?
19:07:45 <danols> are you telling me that i need to use IO Int ?
19:07:50 <danols> for the result ?
19:07:52 <kawfee> I don't see how you will get an Int from an IO, unless you're doing something odd
19:07:55 <kawfee> no
19:08:33 <kawfee> I don't understand what you're doing sorry
19:08:40 <danols> calcFit chromo criteria score 
19:08:40 <danols> 	| chromo == [] = score
19:08:40 <danols> 	| otherwise = (calcFit (tail chromo) criteria (score + criteria (head chromo)))
19:08:45 <danols> is a function that works
19:08:49 <kawfee> if you're trying to add a list of Int's that's one thing
19:08:53 <kawfee> ok
19:09:03 <danols> i just need to make it work with chromo that is IO [a] not [a]
19:09:12 <whee> why?
19:09:27 <kawfee> whee: ?
19:09:32 <whee> the function calling calcFit is dealing with IO, right?
19:09:38 <danols> because the list i feed it is IO
19:09:39 <danols> yes
19:09:40 <danols> whee
19:09:52 <whee> so why not just get rid of IO from there before you call calcFit?
19:09:52 <kawfee> danols: do you know what IO is?
19:10:11 <danols> an action, imperitive part of haskell, nomadic they called it ?
19:10:11 <whee> otherwise you have this IO monad all over the place, where it really doesn't need to be
19:10:15 <kawfee> do the IO and then pass it to your old function
19:10:37 <kawfee> I agree with whee
19:10:52 <danols> ok ok ok , that's what would make this perfect
19:11:08 <danols> what is the idea with that ?
19:13:02 <danols> ok see this is what pisses me off, to get rid of IO you do foo <- io result, but to use <- you need to use do and stuff so doesn't that make it an IO function already ?
19:13:43 <whee> if you use an IO function in another function, that function must also be IO
19:13:59 <danols> so how the hell do you get rid of IO , you said to convert it or something
19:14:16 <whee> using do, like yous aid
19:14:25 <whee> or the other notation 
19:14:32 <danols> but than you said it makes it an IO function ?
19:14:40 <whee> yes
19:14:42 <kawfee> danols: IO as input
19:14:47 <danols> hmmmm
19:14:50 <kawfee> you can make it output anything
19:15:00 <kawfee> or return anything
19:15:03 <kawfee> depending
19:15:29 <danols> ohhhh OK, i think i see what you are saying
19:15:58 <danols> but beofre i tackle this <- takes the IO result and makes it usable in normal functions ? right ?
19:16:15 <whee> yes
19:16:31 <danols> and | don't work in IO functions because they are 'order' independent ?
19:16:42 <whee> | should work fine
19:16:50 <danols> ok
19:17:45 <danols> whee
19:18:50 <danols> genPop popsize traits criteria
19:18:51 <danols> 	| popsize == 0 = []
19:18:51 <danols> 	| otherwise = newchromo <- genChromo traits
19:18:51 <danols> 		(newchromo, calcFit newchromo fit 0) : genPop (popsize - 1) traits criteria
19:19:10 <whee> you don't have a do in there
19:19:37 <whee> you probably want to return something too
19:19:39 <danols> see it's reqursive function dosen't that mean it will have to return an IO ?
19:19:52 <danols> and since return makes it into an IO action
19:20:02 <whee> if genChromo is IO, then genPop has to be
19:20:03 <danols> that it's like the circle is repeating, i don't see a way out of IO
19:20:04 <danols> damn it
19:20:11 <danols> yes i see that
19:20:23 <whee> you get rid of the IO monad as soon as you don't need it anymore
19:20:24 <danols> now how do I make genPop return a not IO list
19:20:36 <danols> i don't need it after genPop
19:20:44 <whee> does genChromo need it?
19:20:52 <danols> definetly uses the randomIO
19:21:09 <danols> it simply takes a list and returns random orders of it
19:21:21 <whee> well, add another function that calls genChromo and goes on to call genPop
19:21:29 <whee> so genPop doesn't need the IO monad
19:21:31 <danols> for what ?
19:21:43 <whee> it'll sit in between and get rid of IO for you
19:21:47 <whee> heh
19:21:52 <danols> that could work
19:22:09 <danols> hmmm genPop should return a list of those randomized version of original list
19:22:38 <whee> er, wait
19:22:46 <whee> maybe you can't get rid of IO there
19:22:53 <danols> huh ?
19:22:58 <danols> let me say what I want to do ok ?
19:23:25 <danols> genChromo takes a list returns a random order of it's elemnts, genpop should put them in a big list
19:24:02 <danols> i.e [2,3] -> [3,2] -> genPOP [[3,2]...]
19:26:08 <whee> for some reason I'm thinking you can use some prelude or some monadaic function to do what genPop does
19:26:09 <danols> this is crap, helper method also needs to return an IO
19:26:23 <danols> whee true but i need a touplet
19:26:39 <danols> [([3,2],b),...
19:26:53 <whee> that shouldn't be a problem D:
19:26:53 <danols> i really don't see a way out of IO hahah
19:27:13 <danols> whee well let's humour me and let me figure it out, at least i'll learn something
19:27:52 <danols> i have an IO [Int] list how can i change it into [Int] using a helper method
19:28:53 <whee> that function would have to return IO, yes, but I was thinking genPop could be done without IO at that point
19:29:03 <danols> HOW ?
19:29:12 <whee> but I don't think so on second thought, since genPop needs a new one each time
19:29:47 <danols> well how about genPop returning a [[Int]] is that possible, or an IO function MUST return an IO 
19:30:04 <whee> it must return IO
19:30:25 <danols> that means lol my entire thing is an imperitive language equivlent,
19:30:47 <whee> everything directly dealing with that random part
19:31:11 <danols> well how could a function based on genPop return a NON IO result ?
19:31:37 <whee> you'd never return a non IO result 
19:31:43 <danols> let's say just a few elemnts from the genPop list
19:31:50 <whee> you'd just get rid of the IO monad when you don't need it
19:32:00 <danols> when would I not need lol ?
19:32:16 <whee> whenever you're done with the random generation of all that
19:32:17 <danols> i mean I don't see how you can... since my results depend on this IO function results
19:32:41 <whee> at some point in the call chain you won't be dealing with the IO monad
19:32:45 <danols> it's like IO can't integrade witht he normal stuff, how can you really make something usefull than
19:34:01 <danols> i don't ever see a functional part being able to use an IO result
19:34:12 <danols> since that would make it a IO action 
19:34:50 <whee> the idea is to separate the things dealing with IO from the other code that doesn't need it
19:35:08 <danols> give me an example, because that sound like to different program lol
19:35:17 <danols> to=two
19:35:51 <whee> well, just look at any input function
19:36:03 <whee> say you read a string from stdin, want to reverse it and print it out again
19:36:12 <danols> because if I want to use a function on some of the IO input, that makes an IO monad
19:36:13 <danols> ok
19:36:21 <whee> you get the string in some IO function, pass that string to another function (which has no idea it was IO), and deal with the result
19:36:29 <danols> but see
19:36:43 <danols> how is this different than what I am doing
19:36:44 <danols> ?
19:36:58 <whee> it's not
19:37:02 <whee> you just have to determine at what point you can drop the IO monad
19:38:04 <danols> i want to drop it after genPop, it generates this IO [[a]] and pass it to another function, but that function would have to become an IO monad aswell I just don't see it end
19:38:30 <danols> that is the function would simply need to take [[a]] 
19:38:58 <whee> then you'd have some IO function get the result from genPop and pass it on to another function
19:39:36 <danols> whee ok , listen this is how I see, back to your example, the IO input returns an IO String, to use it a function has to take an IO String, and must return an IO action , 
19:39:43 <danols> i just don't see how reverse could work
19:40:14 <danols> reverse will work with String, but you pass it an IO String she will throw an error
19:40:46 <whee> because you aren't giving it the IO monad
19:40:56 <danols> what am I giving it then ?
19:41:00 <danols> a String ? how ?
19:41:01 <whee> you're using do notation and <- to strip that before passing it to reverse
19:41:07 <whee> or using >>=
19:41:34 <danols> like this ? 
19:41:53 <danols> genPopHelper = do temp <- genPop ?
19:42:26 <danols> but then do wants a return (...) which generates a IO action lol
19:42:31 <danols> am I wrong or something ?
19:42:50 <whee> I think you're looking at it wrong
19:42:57 <danols> i think so too
19:43:07 <whee> you handle the result of genPop with functions that wouldn't deal with IO
19:43:37 <danols> come again ?
19:45:14 <danols> i think i see, it
19:45:26 <danols> temp <- genPop
19:45:36 <danols> than i can do SOMESUPER COMPLICETED FUNCTION (temp)
19:45:39 <danols> return temp
19:45:53 <danols> i have to keep using IO, but intermediate steps can be done with normal functions ?
19:46:05 <whee> probably wouldn't return temp, but yeah
19:46:20 <danols> yeah i mean return some result that i wanted
19:46:42 <danols> but that seems not to change anything compared to imperative languages 
19:47:34 <danols> anyhow i need a brake , sleep maybe will solidify this crazy pardigm
19:47:43 <danols> thanks you for entertaining me whee
19:51:37 * inkedmn is trying to write a "between" function
19:51:41 <inkedmn> gives the middle number of 3
19:52:55 <whee> what, heh
19:53:40 <inkedmn> sorry
19:53:43 <inkedmn> 3 numbers
19:53:57 <inkedmn> like 2, 3, 4 would return 3
19:53:59 <inkedmn> for example
19:54:11 <whee> median of a list or just a fixed number of numbers?
19:58:21 <inkedmn> median of a list
19:58:42 <whee> I'd just sort it and grab the one in the middle
19:58:50 <danols> inkedm try a !! ('length a' mod 2) or something like that
19:59:36 <inkedmn> whee: well, it's not a list
19:59:42 <inkedmn> it's just 3 arguments
19:59:58 <danols> ohhh fun x y z = y ?
20:00:04 <inkedmn> exactly
20:00:16 <danols> you mean you need to know the syntax ?
20:00:34 <inkedmn> well, i'm doing this as an exercise from my haskell book
20:00:42 <danols> good luck :)
20:00:45 <inkedmn> having a hard time figuring this out
20:00:53 <danols> stay away from IO's :)
20:00:56 <whee> you'd just have to do some comparisons there
20:00:59 <danols> what can I help you with ?
20:00:59 <inkedmn> heh
20:01:06 <whee> just write it on paper
20:01:18 <whee> given three numbers, how would you determine which is the median
20:02:08 <inkedmn> whee: well, programmatically, i'd put them in a list and sort them
20:02:17 <danols> fun x y z | x < y < z = y
20:02:20 <danols> ...
20:02:33 <inkedmn> ok
20:02:41 <danols> fun x y z | y < x < z = x
20:02:42 <inkedmn> heh, that makes perfect sense :)
20:02:47 <inkedmn> thanks
20:02:53 <danols> fun x y z | otherwise = ... :)
20:03:12 <danols> it does , but remember STAY AWAY FROM IOS
20:03:19 <danols> aka nomads
20:03:41 <kawfee> why?
20:03:52 <kawfee> nothing wrong with IO
20:03:55 <danols> kawfee haha, cause they are pain in the but for me lol
20:04:07 <kawfee> yeah, I've run into difficulties as well
20:04:11 <danols> but I think i'm getting the idea after talking to whee
20:04:12 <kawfee> and it's monads
20:04:17 <kawfee> I got more monads than you!
20:04:28 <inkedmn> hmm...
20:04:39 <danols> kawfee haha ok
20:04:50 <inkedmn> ERROR "/home/inkedmn/code/haskell/code/Practice.hs":35 - Ambiguous use of operator "(<)" with "(<)"
20:05:01 <inkedmn> i can paste the code if you want
20:05:04 <inkedmn> it's short
20:05:13 <danols> ohhh yeah
20:05:17 <inkedmn> between :: Int -> Int -> Int -> Int
20:05:18 <inkedmn> between a b c
20:05:18 <inkedmn>     | a < b < c = b
20:05:18 <inkedmn>     | a < c < b = c
20:05:18 <inkedmn>     | otherwise = a
20:05:36 <danols> i forgat that it don't do that
20:05:41 <danols> hmmm try this
20:05:55 <danols> foo | a < b && b < c = b
20:06:08 <whee> that won't work, anyway
20:06:16 <danols> why not ?
20:06:22 <whee> what if c < b < a?
20:07:00 <danols> c < b && b < a ?
20:07:15 <whee> function gets to be a bit longer, then :)
20:07:24 <inkedmn> heh, he's right
20:07:25 <danols> yes :)
20:07:29 <inkedmn> my logic is effed
20:07:32 <danols> i just forgat you can't do directly a < b < c
20:07:36 <danols> you have and or or them
20:07:46 <whee> just slap them in a list, sort it, grab the middle :)
20:07:54 <danols> haha 
20:08:18 <danols> try anding them inkedmn
20:09:23 <inkedmn> danols: did that, and it works, but i think it's much longer than it needs to be...
20:09:26 <inkedmn> no offense :)
20:09:39 <danols> sure, i was never strong at logic stuff
20:09:43 <danols> what do you recommend ?
20:10:13 <inkedmn> well, i'm kinda leaning toward the sort-the-list method...
20:10:33 <danols> ok hmm but you said it takes 3 parameters only right ?
20:10:36 <inkedmn> but i'm not entirely sure how to grab the middle element out of a list
20:10:39 <inkedmn> yep
20:11:17 <danols> try length [a] that gives the length than use 'mod' because / will return a float and use !! to grab the nth elemnt from the list
20:11:35 <inkedmn> danols: you're going to have to show me an example of what you mean :)
20:11:35 <danols> [2,3,4] !! 1 = 3
20:11:44 <danols> ohhh ok hold on
20:11:59 <inkedmn> oh, !! is used to index lists...
20:12:00 <inkedmn> i got it
20:12:17 <inkedmn> now, how to sort...
20:12:51 <danols>  [2,3,4] !! ((length [2,3,4]) `mod` 2)
20:13:12 <whee> there's a sort function already provided
20:13:15 <danols> ohhh there is a awsome way to represent quicksort in one line using list comperhension hold on i'll grab the code for you
20:13:20 <danols> there is ? cool
20:13:23 <whee> with ghc it's List.sort
20:13:36 <whee> might just be sort with hugs or whatever
20:13:40 <danols> qsort :: (Ord a) => [a] -> [a]
20:13:41 <danols> qsort [] = []
20:13:41 <danols> qsort (x:xs) = qsort [y|y <- xs, y < x] ++ [x] ++ qsort [y|y <- xs, y >= x]
20:15:13 <inkedmn> heh
20:15:41 <dennisb> if it's always 3 elements one could write: between a b c = x where [_,x,_] = sort [a,b,c]
20:16:09 <kawfee> dennisb: get that from haskell.org 
20:16:10 <kawfee> ?
20:16:26 <dennisb> kawfee: what?
20:16:34 <kawfee> there is code like that on haskell.org
20:17:05 <kawfee> /usr/share/hugs98/lib/Prelude.hs
20:17:06 <dennisb> you are taking to danols I guess?
20:17:07 <kawfee> er
20:17:11 <kawfee> yeah
20:17:12 <kawfee> sorry
20:17:13 <dennisb> talking
20:17:24 <kawfee> qsort []     = []
20:17:24 <kawfee> qsort (x:xs) = qsort elts_lt_x ++ [x] ++ qsort elts_greq_x
20:17:24 <kawfee>                  where
20:17:24 <kawfee>                    elts_lt_x   = [y | y <- xs, y < x]
20:17:24 <kawfee>                    elts_greq_x = [y | y <- xs, y >= x]
20:17:41 <kawfee> which is the same as what he put above
20:17:49 <kawfee> http://www.haskell.org/aboutHaskell.html
20:17:57 <inkedmn> yeah, i've seen that before...
20:46:12 <inkedmn> ok, i'm using the !! operator wrong here...
20:46:23 <inkedmn> between :: Int -> Int -> Int -> Int
20:46:23 <inkedmn> between a b c = !! 1 (List.sort (a: b: c:[]))
20:46:30 <inkedmn> thought i was being really clever :)
20:48:31 <inkedmn> sweet, figured it out
21:23:09 <inkedmn> all you guys afk?
21:23:44 <dennisb> nope
21:23:49 <inkedmn> :)
21:23:54 <dennisb> but you figured it out you said!
21:23:58 <inkedmn> evenin' :)
21:24:06 <inkedmn> well, this is a general question (sorta)
21:24:35 <inkedmn> i'm working through the exercises in my haskell book, and i'm a bit tripped up on this one
21:24:45 <inkedmn> it wants a function called howManyEqual
21:25:03 <inkedmn> so, i give it a list and it wants to know now many of the 3 integers are equal to each other
21:25:25 <inkedmn> howManyEqual 35 35 36  - would return 2, for example
21:26:08 <mgoetze> what does howManyEqual 35 35 35 36 36 return?
21:26:29 <inkedmn> well, this exercise only takes 3 args
21:26:41 <mgoetze> oh
21:26:43 <inkedmn> so i'm not going to get ahead of myself if i can help it :)
21:27:07 <mgoetze> so it's Int -> Int -> Int -> Int ?
21:27:14 <inkedmn> yep
21:27:20 <mgoetze> that should be easy :)
21:28:03 <inkedmn> if i just do comparisons, yeah it probably is
21:28:14 <inkedmn> i was just wondering if there was some way i could use map or filter
21:28:24 <inkedmn> (probably should've said that at the get-go, sorry :) )
21:28:49 <kawfee> inkedmn: what are you trying to do?
21:29:17 <inkedmn> an exercise from my book
21:29:23 <inkedmn> it wants a function called howManyEqual
21:29:23 <kawfee> you could probably use foldr
21:29:39 <inkedmn> would comparisons be the least mickey-mouse way of doing it?
21:29:57 <kawfee> what does 35, 35, 36, 36 36 return?
21:30:19 <kawfee> 3 or 2?
21:30:30 <mgoetze> or 4
21:30:41 <kawfee> how could it be 4?
21:30:56 <mgoetze> a b c d e, a=b, c=d, c=e, d=e
21:31:37 <kawfee> that would be a bit tricky to code
21:31:47 <kawfee> you could compare pairs
21:32:04 <kawfee> I think what you meant it, a=b, c=d, e=f ?
21:32:37 <inkedmn> kawfee: well, i'm only doing what the book is telling me (3 args)
21:32:40 <kawfee> takeWhile would work in his case, just grab the first element and take while the rest
21:32:56 <inkedmn> and i wrote something that works, but it just does a bunch of comparisons
21:33:01 <inkedmn> which isn't bad
21:33:10 <kawfee> 3 args, the first arg is the element to compare, the next is x the next is xs
21:34:10 <kawfee> Prelude> length (takeWhile (==35) [35,35,35,35,35,36,36])
21:34:10 <kawfee> 5
21:34:49 <kawfee> oh wait, that doesn't work in all cases
21:35:28 <mgoetze> wouldn't you need to sort it first?
21:35:52 <kawfee> yeah
21:36:00 <kawfee> actually, no
21:36:09 <mgoetze> you could use a list comprehension
21:36:19 <inkedmn> but you'd have to check each element against the rest
21:36:22 <kawfee> possibly
21:36:31 <inkedmn> you wouldn't have a static number to compare each element to
21:36:35 <inkedmn> at least, not in my case
21:36:55 <mgoetze> howManyEqual (x:xs) = length [y|y<-xs, y=x] + 1
21:37:06 <kawfee> Prelude> map (==35) [35,35,34,36,37]
21:37:07 <kawfee> [True,True,False,False,False]
21:37:11 <kawfee> there is a map one
21:37:19 <kawfee> you could count the True's
21:38:14 <mgoetze> what haskell really needs is a 'foreach' :)
21:38:35 <inkedmn> haskell needs looping in general
21:38:39 <inkedmn> "while" and "for"
21:39:08 <mgoetze> nah, while and for are too non-functional for my taste
21:45:15 <dennisb> foreach sounds like map
21:45:35 <mgoetze> dennisb: well, i was thinking of something that works more like where
21:46:31 <dennisb> like where?
21:47:05 <mgoetze> as in 'if x == 25 then 0 else x foreach x <- xs'
21:48:35 * dennisb don't get it
21:48:47 <dennisb> [if x == 25 then 0 else x | x <- xs]
21:49:54 <mgoetze> hm
21:50:10 <mgoetze> i'm too tired to think about it properly :)
21:51:19 <dennisb> I think haskell has all the looping one could even need
23:02:47 <kawfee> looping can be done with recursion
23:03:54 <kawfee> what does that list comprehension statement do?
23:22:54 <kawfee> inkedmn:  all your looping needs can be taken care of with recursion
23:23:15 <inkedmn> kawfee: yeah, that's the impression i'm getting
