01:53:50 <resolve> hey folks! i'm just trying to play with data constructors, but i'm getting messages about "data constructor not in scope". could this be because i've moved to ghci from hugs? it doesn't work in hugs either ;-)
01:54:36 <Marvin--> I'd say it's because it can't find the constructor
01:55:06 <resolve> *donk, the sound of a head on wall*
01:55:32 <Marvin--> hey, be careful with the wall :)
01:55:53 <Marvin--> Where is the data type defined? Are you sure you loaded that file in hugs/ghci?
01:57:25 <resolve> i was trying to use a "data" statement, but my understanding is very feeble and i've probably missed something. i'll summon the energy to get up and find my haskell book .. :)
01:57:41 <Marvin--> well, if there was a syntax error, it should have told you that
01:58:01 <Marvin--> remember that in 'data D = C1 ... | C2 ...', it's C1 and C2 that are constructors, not D
01:59:22 <resolve> ah, that'd be it :-)
01:59:41 <Marvin--> hehe
01:59:46 <Marvin--> common mistake :)
02:04:49 <resolve> thanks :-) hobbled my way along to defining a tree datatype (which i've delt with before, but forgotten how to use ;-)
02:05:01 <Marvin--> hehe
02:11:13 <resolve> i'm doing an exercise now where i need to invent a rational number datatype. i've come up with something like: "data Ratno = RatCons Int Int deriving (Show, Read)", but the example reads "data Ratno = Int :/: Int deriving (Show, Read)"
02:11:24 <resolve> is that some special read syntax, or just the cons operator?
02:11:44 <Marvin--> You can create infix constrocturs if they start with ':'
02:11:48 <Marvin--> constructors even
02:11:53 <resolve> ah
02:12:01 <Marvin--> and cons (':') obviously starts with ':' ;)
02:12:14 <Marvin--> so :/: is just an infix constructor
02:12:32 <Marvin--> there's a complex number infix constructor :+ or something, I think
02:13:26 <resolve> forgive my naivity; some infix operators need to be surrounded in backticks, like "3 `mod` 4", right? i'm back to scope errors now :)
02:13:32 <resolve> *Main> 3 :+ 4
02:13:33 <resolve> <interactive>:1: Data constructor not in scope: `:+'
02:13:33 <resolve> :)
02:13:40 <Marvin--> yes, you need the Complex module
02:14:14 <resolve> ah
02:14:15 <Marvin--> well, the thing is this, a two-place prefix function (like mod) or prefix constructor (like your RatCons) can be turned into an infix function/constructor using back ticks
02:14:38 <resolve> cool, i get it now. i was trying "3 / 4" as a constructor, but getting back 0.75 and thinking my data definition hadn't worked
02:15:37 <Marvin--> :)
02:15:44 <Marvin--> no, you have to write :/:
02:16:11 <resolve> ah, brilliant :-)
02:17:15 <Marvin--> note that with your original data type, you could say  3 `RatCons` 4
02:17:41 <Marvin--> and with the :/: you can also say  (:/:) 3 4  since the parentheses turns it into a prefix constructor
02:17:45 <resolve> ah, so backticks can turn any two-arg function into an infix operator?
02:17:48 <Marvin--> for some reason you can't say (`RatCons`) :-)
02:17:52 <Marvin--> yes
02:17:56 <resolve> nifty!
02:18:08 <Marvin--> too bad it doesn't work with partial application
02:18:15 <Marvin--> so if f is a three-place function, you can't say `f 3` :(
02:19:22 <resolve> could you do some magic with ``s and flip? but yeah, shame it doesn't work that way :)
02:47:01 <resolve> http://repose.cx/dump/Ratno.hs is my progress! :-) would anyone mind taking a peak and offering any constructive criticisms? stylistic, algorithmic or otherwise, it's a good way to learn :)
02:47:18 <resolve> igcd might have been clearer with guards
02:48:56 <Marvin--> I'd say it'd be even clearer with pattern matching
02:49:11 <Marvin--> igcd x 0 = x (new line) igcd x y = ...
02:49:54 <Marvin--> and stylistically, I think that form of if isn't widely used, I think the form
02:49:56 <Marvin--> if E
02:49:59 <Marvin-->   then E1
02:50:00 <Marvin-->   else E2
02:50:02 <Marvin--> is more common
02:50:05 <resolve> ah yep, good point. i'd forgotten euclid's algorithm, so i went and looked it up from the place i remembered it - that was my transcription of the scheme it was written in ;-)
02:50:12 <Marvin--> heh
02:51:08 <resolve> hmm, the haskell mode in emacs seems to want to align the then with the if
02:51:56 <Marvin--> eh, okay
02:52:04 * Marvin-- isn't an emacs user
02:52:13 <Marvin--> if E then E1
02:52:17 <Marvin-->      else E2
02:52:19 <Marvin--> is probably quite common too
02:52:52 <resolve> gah, it still wants the else with the if ;-)
02:53:15 <Marvin--> *shrug*
02:53:34 <resolve> thanks, though!
02:53:45 <resolve> i'll grapple with haskell-mode.el's whims later
02:54:49 <Marvin--> I could be far off too
02:55:16 <resolve> *Main> (3 :/: 4) == normalise (75 :/: 100)
02:55:16 <resolve> True
02:55:18 <resolve> *bounces*
02:55:43 <Marvin--> if you want to do cooler testing, take a look at quickcheck
02:56:23 <resolve> to be honest i don't yet understand how haskell knew equality in that case. i told it to derive eq, does that just check that the "structure" of a data type is the same?
02:56:59 <resolve> (i hadn't yet redefined (==))
02:57:00 <Marvin--> it checks every part of the tree
02:57:17 <resolve> so it's a deep equality?
02:57:26 <Marvin--> so in your case,  data Ratno = Int :/: Int  there's only one constructor so that's easy, then it compares the Ints separately
02:57:29 <Marvin--> yes, deep equality
02:57:55 <resolve> cool :-) now to write a == which auto-normalises :-)
02:58:08 <Marvin--> if you'd have several constructors, like data Maybe a = Nothing | Just a, it would first see if the constructors match, then check if all the arguments to the constructors match
02:58:44 <resolve> i took a peak at IO/monads earlier today, but that and maybe i'm not quite up to yet :)
02:59:08 <Marvin--> Maybe is quite easy, IO and monads is trickier
03:16:22 <resolve> instance Eq Ratno where
03:16:22 <resolve>   (==) x y = (normalise x) == (normalise y)
03:16:36 <resolve> in a definition like that, how do i get at the "default" == operator?
03:16:44 <Marvin--> you don't
03:16:54 <Marvin--> note that you can write   x == y  in the lhs
03:17:23 <resolve> *scratches head*  - i think what i've got at the moment is recursive
03:17:26 <resolve> cool
03:17:45 <Marvin--> yes, that's very recursive, since normalise is Ratno -> Ratno :)
03:17:53 <Marvin--> so it uses the same == over and over
03:18:47 <resolve> it would be nice if i could use the behavior you get when inheriting eq on the rhs
03:18:55 <Marvin--> sorry, no can do
03:19:22 <resolve> okay, so where to from here? :) is there an alternative way to test for equality when == isn't available?
03:19:51 <Marvin--> you can compare the Ints the Ratno:s consist of
03:20:49 <resolve> ah, i was hoping not have to deconstruct them :-)
03:21:05 <Marvin--> sorry
03:22:23 <resolve> oh well :-) how can i get at the various parts of data from the RHS?
03:22:59 <Marvin--> with a let expression or where construction
03:23:17 <Marvin--> let a :/: b = E in ...  or  ... where a :/: b = E
03:23:21 <resolve> ah, perfect. i don't know let, but know where
03:25:15 <resolve> sorry for all the questions :)
03:25:44 <Marvin--> hey if I think you're asking too much I'll tell to you to shut up or ignore you :-)
03:25:58 <Marvin--> ('course, ignoring might also be a side effect of me being AFK)
04:20:06 <debug> hm
04:30:35 <resolve> hmm, how do i use the Bounded class?
05:14:39 * Igloo bounces
05:47:06 <debug> Marvin-- the quitter
05:47:19 <andersca_> why? is he bitter?
05:47:20 <andersca_> ;)
05:47:25 <Marvin--> Marvin-- the oops-I-should-go-get-something-done
05:47:34 <debug> what day is it today
05:47:34 <debug> ?
05:47:39 <debug> saturday?
05:47:54 * debug just had his morning shower
05:48:18 <mgoetze> debug: wednesday
05:48:22 <debug> hm
05:48:50 <Janni> h*
05:49:27 * debug always has problem finding good English translations of "kramsnö" and such words
05:49:32 <debug> huggable snow
05:49:42 <resolve> wow, cool word! :)
05:49:54 <debug> and sötnos. cute nose?
05:49:59 <debug> sweetheart
05:50:01 <debug> hm
05:50:03 <Janni> debug: what language are those words?
05:50:06 <debug> swedish
05:50:16 <debug> the Primal Language
05:50:22 <debug> ;)
05:50:38 <Janni> debug: _after_ Haskell ;)
05:50:43 <debug> :)
05:51:45 <debug> heh... I was asked to leave #tunes, because I wanted to lurk.
05:52:22 <resolve> understandable in social cliques
05:52:22 * debug feels the strong sence of "openness"
05:52:43 <debug> yeah, but still
05:53:14 <resolve> oh, i agree ;-) just saying they're probably using the channel more as a social gathering than for the project
05:53:43 <Smerdyakov> Loonie Tunes!
05:54:23 <debug> have a nice day muppets
05:54:28 * debug disappers
06:01:22 <Janni> debug: you could have tried this one:
06:01:38 * Janni has left channel #Haskell ("Client Exiting")
06:01:41 <Janni> ;)
06:07:00 <tic__> hey hey guys :)
06:07:51 <Gorgar> hello
06:08:12 <mgoetze> Janni: you are aware that different clients have very different ways of displaying quit messages?
06:08:53 <Gorgar> I know this is a little off topic, but some here might know.  Anyone knows any good resources on line for studying ARS and TRS (Abstract Reduction Systems / Term Rewriting Systems)
06:17:13 <Janni> mgoetze: yeah, but I said "try" and on the other hand didn't mean it too seriously.
06:19:40 * Janni is wondering if it has to be "serious" in this case or if "seriously" is correct but during writing this message he is coming to the result that "serious" should be correct because an adverb is wrong in that context but still isn't sure and definitively writing far too much...
06:20:16 <Janni> ... and not sure about how many mistakes this message contains
06:20:48 <mgoetze> using "but" twice in the same sentence is, of course, a grave stylistic error. ;)
06:21:16 <mgoetze> Janni: "seriously" was correct
06:21:18 <Janni> mgoetze: s/error/device
06:21:41 <Janni> mgoetze: fuckit! :)
06:21:57 <mgoetze> no no, you made a grave stylistic error by using a kludge rather than a proper stylistic device.
06:24:02 <Janni> mgoetze: are you sure it's an error to use two butts? <- on purpose
06:24:21 <mgoetze> it's not wrong per se, just bad style.
06:24:50 <Janni> OK, I guess you're right...
06:25:29 <Janni> s/use/have <- that's what I should have said two sentences above...
06:27:13 <mgoetze> "use" is ok if you're talking about yourself, "have" as in "error to have 2 'but's in a sentence"
06:28:41 <Janni> I'm definitively not able to parse that phrase.
06:30:28 <mgoetze> i mean, your sentence with "mgoetze: are you sure..." was fine as it is, with s/use/have/ it would have a slightly different emphasis
06:30:48 <Janni> Maybe my parser is not fault-tolerant enough
06:31:34 <Janni> mgoetze: yeah, it should have been more ambiguous
07:37:56 * shapr bounces
07:39:11 * opet goes on a type signature spree
07:39:27 <shapr> yay!
07:39:42 <shapr> resolve: hiya!
07:39:55 <shapr> lambdabot: @fact resolve
07:39:55 <lambdabot> Nothing
07:40:08 <resolve> yo!
07:40:28 <shapr> lambdabot: @fact resolve Damien Elmes
07:40:29 <lambdabot> set resolve to Damien Elmes
07:40:52 <shapr> lambdabot: @help
07:40:53 <lambdabot> Sorry, I don't know that command.
07:41:00 * shapr thinks
07:41:19 <shapr> lambdabot: @fact resolve http://repose.cx/
07:41:19 <lambdabot> set resolve to http://repose.cx/
07:45:08 <Igloo> lambdabot: @fact resolve
07:45:08 <lambdabot> Damien Elmes, http://repose.cx/
07:45:15 <Igloo> Is overwriting impossible then?
07:45:23 <shapr> at the moment, yes
07:45:32 <shapr> there's "@fact delete foo"
07:45:51 <Igloo> Ah, right
07:46:01 <shapr> do you think I should allow deletion of separate items?
07:46:12 <shapr> like "@delete foo 2" or something?
07:46:22 <shapr> have you done anything with Haddock?
07:46:46 <whee> shapr: you should do it infobot style with some leetness
07:47:00 <whee> have the ability to add, remove, rearrange individual things
07:47:15 <shapr> whee: suggest a syntax?
07:47:29 <shapr> I could use fsbot syntax.
07:48:07 <whee> maybe prepend a tilde to the fact to indicate a modification
07:48:17 <shapr> hm
07:48:18 <whee> like @fact ~blah del 3
07:48:34 <shapr> and +blah for append?
07:48:47 <shapr> I think the current syntax is too verbose
07:48:56 <whee> well, I was thinking just ~ for all modifications
07:49:00 <whee> adding, removing, swaping, whatever
07:49:28 <shapr> I think I'll change "lambdabot: @fact " to ", "
07:50:16 <shapr> whee: ok, I'll try the tilde thing
07:50:16 <Igloo> Do you mean ": @fact " to ", "?
07:50:24 * Igloo has done nothing with Haddock, no
07:50:39 <shapr> Igloo: no, I mean ", " would be the whole lambdabot plugin prefix
07:50:52 <Igloo> That would look very strange
07:50:53 <whee> shapr: so the tilde just indicates that you want to change or add something, without it it'll go and retrieve the current value
07:51:07 <shapr> and if the first word is a plugin name, send the rest of the msg to the plugin, otherwise call the factoid plugin
07:51:36 <whee> but I don't know how to handle multiple word facts with that syntax
07:52:09 <shapr> only way I can think of to handle multi-word facts is to use "key is value"
07:52:19 <shapr> split the whole input at "is"
07:52:23 <whee> well, with the tilde syntax
07:52:26 <shapr> oh
07:52:35 <shapr> maybe is also or is now
07:53:11 <shapr> Igloo: it would be a lot easier to type though... do you know of something easier/better ?
07:53:33 <shapr> , igloo
07:53:36 <whee> I propose requiring full sentences
07:53:38 <shapr> should be the same as
07:53:43 <shapr> lambdabot: @fact igloo
07:53:44 <lambdabot>  Ian Lynagh,  Template Haskell Guru
07:53:58 <whee> "lambdabot: Hello! I would like to retrieve the current represntation of the fact, "shapr". Thank you."
07:54:02 * shapr laughs
07:54:10 <debug> mh
07:54:11 <debug> hm
07:54:14 <shapr> whee: ok, as long as you write the parser ;-)
07:54:18 <whee> :P
07:54:27 * shapr grins
07:56:04 <shapr> hej tic, hur är det med dig?
07:57:07 <tic> finemang tack :)
07:57:09 <tic> shapr, själv?
07:57:10 <Igloo> I think the syntax should use let but not in to illustrate that it's being executed in a monadic context
07:57:20 <shapr> je ne peux pas parler français comme je parle swedois.
07:57:36 <Igloo> let foo =  and let foo += or similar maybe  :-)
07:57:36 <shapr> Igloo: actually, that's an excellent idea :-)
07:57:55 <tic> Igloo, I have a little problem, still... :)
07:58:03 <shapr> would be so much easier to parse
07:58:16 <shapr> and would be amusingly Haskellic (?)
07:58:25 <Igloo> No concept of addition or deletion in Haskell really - IORefs are as close as it gets
07:58:26 <shapr> Haskellesque (?)
07:58:39 <Igloo> tic?
07:58:41 <tic> Igloo, can I use something I got from a monadic function in a pure function as a paremeter? e.g.: value <- somethingMonadic; pureFunction value
07:58:50 <Igloo> Yes
07:59:04 <tic> so why doesn't this code work? *hmm*
07:59:05 <Igloo> Well, you probably want return $ pureFunction value
07:59:13 <Igloo> To lift the result into the monad
07:59:23 <Smerdyakov> Referring to "monadic functions" and "pure functions" is a little misleading.
07:59:37 <Smerdyakov> Better to distinguish between functions that return monad values and functions that don't.
08:00:04 <tic> okay
08:00:23 <tic> Igloo,  Type: IO (Tree [Char] [Int])  does not match: Tree a b
08:00:30 <Igloo> Correct!
08:00:43 <Igloo> Did you put the return in?
08:00:43 <tic> Igloo, the line was : get "blah" tree
08:00:53 <tic> and I had a tree <- readTree
08:01:15 <tic> Igloo, in a function that returns a monadic value, I -have- to put the pure function at the end?
08:01:42 <tic> the code I have is :
08:01:44 <tic>          tree <- addFilesToTree files
08:01:44 <tic>          print (get "addFilesToTree" tree)
08:01:50 <Igloo> Ermmm, the last (non-empty) statement must be a value in the monad
08:01:52 <tic> where get is a function that returns a pure value.
08:02:04 <tic> I have return () as the last value, it's my main
08:02:14 <Smerdyakov> I suggest you don't even think about functions... it looks like your problem is within a single do block.
08:02:27 <tic> hugs complains about tree not having the correct type.
08:02:42 <Igloo> What type does get have?
08:02:46 <Igloo> And addFilesToTree
08:02:49 <tic> I thought that when I get a value using the syntax value <- function, the IO gets removed?
08:02:49 <Smerdyakov> Perpahps addFilesToTree doesn't have the type you wanted?
08:02:53 <tic> "addFilestoTree" is a string
08:02:57 <tic> or hm
08:02:58 <tic> ah
08:03:00 <tic> sec. :)
08:03:08 <Igloo> lol
08:03:39 <tic> hrm
08:03:41 <tic> well
08:04:01 <tic> I removed the definition of addFilesToTree just before testing this, because hugs wouldn't let me go pass that function. So now I have another problem:
08:04:43 <tic> Type: [String] -> a (IO (Tree [Char] [Int])) does not match: [String] -> IO (Tree [Char] [Int])
08:04:51 <tic> where did that a come from? 
08:05:04 <Smerdyakov> It doesn't tell you where in the code that occurs?
08:05:11 <Igloo> It's an outer monad
08:05:21 <tic> it does.
08:05:26 <tic> but I can't make any sense of it
08:05:29 <Smerdyakov> Then you can look at the code and see where...
08:06:00 <tic> addFilesToTree files = return $ foldM (\tree fn -> do x <- readFile fn; return (addLinesToTree (lines x) tree)) Empty files
08:06:14 <Igloo> foldM alreayd returns a monadic value
08:06:23 <tic> hrm.
08:06:33 <tic> so how do I just get at the IO monad?
08:06:48 <Igloo> Huh?
08:06:49 <tic> I was given the foldM solution here last night, but appearently I can't really use it.
08:06:58 <Smerdyakov> Take off the "return $"....
08:07:01 <tic> ah
08:07:12 <Igloo> return lifts a value into a monad, so you are lifting an IO a into a further monad to get a b (IO a)
08:07:22 <tic> -into- a monad
08:07:24 <tic> ah
08:07:33 <tic> just a generic monad?
08:07:39 * tic hasn't really grasped the concept of monads
08:07:55 <Smerdyakov> This is more of a general type class issue than a monad issue.
08:08:07 <Smerdyakov> return is defined for every instance of the Monad class.
08:08:15 <Smerdyakov> Type inference will figure out which it is in this case.
08:09:21 <tic> a-ha.
08:09:52 <tic> that line I just pasted generates an IO error when called with a list of file names.
08:10:02 <tic> but it gives the error at a really strange place
08:10:21 <tic> the (lines x) part should just give me the lines in the contents of the file fn
08:10:39 <tic> but the error message I get is: Program error: {addLinesToTree (lines (_hreader {handle})) Tree_Empty}
08:10:49 <Igloo> You have an unhandled case
08:10:49 <tic> the _hreader {handle} part.
08:13:10 <tic> I wonder what it is :)
08:13:39 <Igloo> It should be obvious given the error and the code, but I can't remember how to interpret it OTTOMH
08:13:59 * tic googles¨
08:19:25 <tic> Igloo, it is allowed to do a  "print (pureFunction args)", right?
08:19:42 <Igloo> If pF :: Show b => a -> b
08:20:00 <Igloo> And you want to return an IO ()
08:20:33 <tic> yap.
08:20:34 <tic> okay
08:26:31 <shapr> hey, we (webwitches.com) are having our Grand Opening on Friday.
08:26:43 <shapr> if anyone here is in the area, you're welcome to drop by.
08:27:08 <Igloo> Well, I'm on the same planet, but that's about as far as it goes  :-/
08:27:37 <shapr> I'll take a picture of our new office and put up somewhere.
09:12:25 <shapr> yow
09:17:17 <shapr> hi esap 
09:17:19 <shapr> wassup?
09:18:23 <esap> not much.
09:19:41 * esap is having a bad case of flu. Not getting much done.
09:20:00 <shapr> :-(
09:25:59 * Igloo had a nice, useful chat with Conal today  :-)
09:26:07 <Igloo> Which I've just realised would have been 3 hours
09:27:34 <Janni> re
09:28:10 <Igloo> Hi
09:44:22 <tic> foldM fun list last-value, right?
09:44:35 <tic> is there a foldM function list first-value?
09:46:03 <tic> and as a last value adds nothing?
09:49:22 <Janni> tic: hmm. I'm not sure if my English parser is broken or if your statement has syntactical deficiencies...
09:50:06 <tic> heh
09:50:23 <tic> I found that I misunderstood the definition of fold
09:50:29 <tic> s/misunderstood/misread
09:51:02 <tic> Janni, any idea about this error message: Program error: {doStuff "Main.lhs" Tree_Empty} ?
09:51:21 <tic> it doesn't really say which part that it errors on
09:51:40 <tic> the code line looks like:
09:51:41 <tic> addFilesToTree files = foldM (\tree fn -> return (doStuff fn tree)) Empty files
09:51:42 <Janni> tic: I guess you are doing pattern matching and there's no function which matches the pattern above
09:51:59 <Janni> (the same goes for guards or case of course)
09:52:09 <tic> mhm
09:52:19 <tic> maybe it complains when it reaches Empty
09:52:39 <Janni> tic: yeah because doStuff is not defined for Tree_Empty (as I said)
09:53:03 <Janni> tic: look at you doStuff function. What does it do with a Tree_Empty?
09:53:56 <tic> ah
09:54:14 <tic> Janni, now I understand. Thanks! See if that helps.  
09:54:26 <tic> Janni, I'm not really used to functional thinking; I'm mostly coding Python otherwise. :)
09:54:51 <Janni> tic: do you understand data-types? I mean those defined by the keyword "data"
09:58:12 <tic> Janni, pah
09:58:15 <tic> Janni, yeah
09:58:41 <tic> Janni, I do. And I solved the problem. Turned out I didn't match for Empty in any function where I passed in my Tree data type.
09:58:46 <tic> which is Bad Thing :(
09:58:48 <tic> :)
10:01:47 <Janni> tic: yes, in you case it was. But not letting match every possible pattern is a very good way to express the mathematical notion of "this function is (not) defined for this/these range(s)".
10:02:21 <Janni> I only want to tell you, that it is s.th. bad in general...
10:02:36 <Janni> s/is/isn't
10:03:17 <tic> ah, yeah.
10:03:40 <tic> Though, in my case, where I have a base case of an empty tree, I really do need to match against it.
10:03:46 <tic> :]
10:05:06 <Marvin--> yes, it's generally a Good Thing to have definitions for your base cases ;)
10:05:53 <tic> :)
10:05:58 <tic> hm.
10:06:06 <tic> I have a Just [Int]
10:06:28 <tic> can I mapM print on it?
10:06:46 <Darius> tic: what compiler/interpreter are you using?
10:06:51 <tic> Darius, hugs
10:06:53 <tic> appearently not.
10:06:57 <tic> (couldn't use it)
10:07:32 <Darius> tic: hmm, I don't know about hugs, but for GHC you can use -fwarn-incomplete-patterns to due the obvious
10:07:47 <tic> Darius, oh, thanks!
10:09:47 <tic> I wan to print the ints, like: "These are the values: 1 3 3 5 1 5"
10:09:59 <tic> and the Ints are in a Just [Int]
10:10:13 <tic> I have absolutely no clue on how to do it. :)
10:11:16 <Marvin--> let Just xs = foo in print xs
10:11:26 <Marvin--> or do you want them on separate lines?
10:11:30 <Marvin--> then you want mapM_ print xs
10:12:22 <tic> Marvin--, I want them printed after anothing string, as in "These are the values: 1 2 3 4 5"
10:12:31 * tic checks up quickly on the let ... in syntax
10:13:13 <Darius> The let binding pattern matches off the Just, so change it to print $ "these ..." ++ show xs
10:13:25 <tic> a-ha
10:13:28 <Darius> of course if foo returns Nothing...
10:13:28 <tic> sweet.
10:13:33 <Marvin--> putStrLn, not print
10:13:39 <Marvin--> print calls show, and show on a string is probably not what you want
10:13:41 <Darius> :er yeah
10:13:43 <tic> yap.
10:14:06 <Marvin--> in the Maybe module, there are some handy functions like isJust and fromJust
10:14:41 <tic> thanks!
10:14:47 * shapr trips over the Binary module
10:17:26 <tic> foldl (show . (++)) "" xs -- my attempt at transforming [1,2,3,4,...] into "1 2 3 4 5"
10:17:37 <tic> doesn't work, though. :)
10:17:53 <Marvin--> ummm :)
10:18:10 * tic gets embarassed over his complete lack of functional programming skills
10:18:25 <Marvin--> how about concat (map (' ':) xs)
10:18:36 <Marvin--> er, with a show too
10:18:38 <shapr> I thought ghci would load a .o file for a module if it could?
10:18:50 <Marvin--> concat (map ((' ':) . show) xs)
10:18:58 <Marvin--> shapr: if it's up to date, yes
10:19:04 <shapr> I'm sure it is.
10:19:24 <shapr> Compiling FastMutInt       ( FastMutInt.hs, interpreted )
10:19:24 <shapr> ghc-5.04.2: panic! (the `impossible' happened, GHC version 5.04.2):
10:19:24 <shapr> 	ByteCodeGen.schemeE StgByteArray
10:19:25 <shapr> :-(
10:19:38 <Marvin--> whhoops
10:19:48 <shapr> happens everytime I try to load FastMutInt into ghci
10:20:16 <shapr> works fine when compiled, but won't load the matching .o file into ghci
10:20:16 <shapr> hm
10:21:20 * Marvin-- shrugs
10:22:04 <shapr> I should try it with 5.04.3
10:22:13 <shapr> I wonder when we'll get a 5.04.3 deb
10:24:44 <Marvin--> file a wishlist bug
10:25:13 <shapr> ok
10:48:12 <ludde> *** Exception: does not exist
10:48:13 <ludde> Action: getHostByAddr
10:48:13 <ludde> Reason: no such host entry
10:48:20 <ludde> why does "accept" throw that exception?
10:54:01 <ludde> any clues?
10:54:28 <esap> I guess the argument to getHostByAddr was wrong.
10:54:58 <ludde> but, I never explicitly called getHostByAddr ?
10:55:05 <ludde> I just did this:
10:55:06 <ludde> 	list <- listenOn $ PortNumber 1235
10:55:06 <ludde> 	putStr "Waiting for client to connect\n"
10:55:06 <ludde> 	(cli,_,_) <- accept list
10:55:14 <esap> accept calls it.
10:55:28 <ludde> so.. this is a bug in accept then?
10:56:08 <esap> hmm.. I'd guess the argument to accept is wrong.
10:57:59 <ludde> but, accept just wants a socket to wait on
10:58:50 <Darius> Using windows and GHC?
10:58:55 <ludde> no, on freebsd
10:58:57 <esap> yea, it's a bit interesting behaviour. What hostaddr it is looking for (maybe the address of localhost?)
10:59:06 <ludde> the thing is
10:59:15 <ludde> the client that connects comes from: 195.162.88.249
10:59:22 <ludde> and it doesn't work to resolve that IP
11:07:24 <Rapiere> hi haskellers
11:08:15 <ludde> what's a simple way to run a monad forever?
11:11:38 <Segora> ludde: do you mean an IO action?
11:11:44 <ludde> any monad
11:11:47 <ludde> like
11:11:56 <ludde> forever m = do m; forever m
11:12:02 <ludde> is there some built in such one?
11:12:13 <Segora> not as far as I remember
11:12:34 <ludde> mapM_ (const main) [1..]
11:12:39 <Segora> :)
11:13:00 <Segora> what's wrong with the do-loop?
11:13:11 <ludde> I can't use that from ghci
11:13:17 <Segora> hmm?
11:13:32 <ludde> I can't write that as a one-liner in ghci
11:13:39 <ludde> the interactive mode
11:13:54 <ludde> I want to run main repeatedly
11:14:02 <ludde> bbl
11:14:06 <Segora> works like a charm for me
11:14:13 <ludde> oh, what do you write?
11:14:15 <Segora> let forever m = do { m; forever m }
11:14:23 <Segora> forever (putStr "a")
11:14:31 <Segora> aaaaaaaaaaaaaaaaaaaaaaInterrupted.
11:14:35 <ludde> oh, I can use let in ghci ?
11:14:39 <ludde> cool
11:14:55 <Darius> That's the reason I use GHCi as opposed to Hugs
11:15:15 <Segora> even if not, you could place the definition in a file and add it with :m
11:15:41 <Darius> I know, it's just a pain for quickies
11:15:52 <Segora> yeah, right
11:16:10 <Segora> did I already mention today that I hate C++?
11:17:03 <Darius> I was just thinking about C++ and Haskell in relation to the quickies
11:17:19 <Darius> There was a recent post on c.l.c++ about goto 
11:17:28 * Segora was presented with a hairy problem today: configurable values strewn all over the place with a cental registry and interdependent default values
11:19:11 <Darius> one example as a time to use goto was to break out of nested loops
11:20:02 <Darius> similar haskell would be hd [(a,b,c) | a <- [1..10], b <- [1..10], c <- [1..10], f a b c == g a b c]
11:20:21 <Darius> hd being hd = foldr (const . Just) Nothing
11:20:49 <Darius> technically, I believe list comprehensions being good producers and foldr certainly a good consumer
11:21:06 <Darius> this may very well be completely deforested...
11:27:52 <shapr> hi Explodey 
11:28:57 <shapr> bonjour Rapiere
11:29:21 <shapr> ludde: fix is the loop forever monad
11:29:31 <ludde> cool
11:29:31 <ludde> thanks
11:29:38 <shapr> putStr $ fix ("HELLO\n"++)
11:29:40 <shapr> er
11:29:42 <shapr> yah
11:30:01 <shapr> that's from my .signature :-)
11:30:18 <shapr> http://haskell.org/wiki/wiki?SillySignatures
11:32:43 <Rapiere> Bonjour shapr 
11:32:53 <shapr> comment ça va?
11:33:11 <shapr> do you have any Haskell questions?
11:33:13 <Marvin--> shapr: actually, my current is   let hello = "hello" : hello in putStr (unlines hello)
11:33:19 <Segora> shapr: what about (mapM_ putStrLn (iterate id "HELLO")) ;)
11:33:31 <shapr> Segora: quick, add it!
11:33:34 <Rapiere> très bien merci, je regardais un peu les documents à propos d'Haskell, et jouais avec ghci et hugs :)
11:33:52 <shapr> tres chouette
11:34:01 <shapr> Marvin--: it's a wiki... 
11:36:08 <Marvin--> meh
11:36:49 <Darius> I made one using goto, but it wasn't very satisfying
11:38:41 <Explodey> iterate id == repeat
11:38:45 <Explodey> isnt it?
11:43:17 <Darius> [x,id x, id (id x),...] == [x,x,x,...]
11:43:25 * shapr investigates System.Random
11:45:36 <Segora> putStrLn $ cycle "HELLO"   <- should've come up with that earlier...
11:46:30 <shapr> putStrLn $ cycle "HELLO\n"
11:46:34 <shapr> very cute
11:46:58 <Darius> Damn, I was close, I didn't think to think of "Hello\n" as already a list...
11:47:05 <shapr> yah, same here
11:47:37 <Darius> otherwise cycle ["Hello"] is just repeat "Hello" and not interesting
11:47:42 <Segora> there's really lots of useful stuff hidden in the Prelude
11:47:52 <shapr> yah, I should spend more time browsing the Prelude
11:50:15 <Darius> You can shave two characters off that last one, just putStr $ cycle "Hello\n"
11:50:36 <shapr> oh right
11:58:33 <Explodey> thats the same length (if you include the spaces)
11:58:50 <Explodey> oh no ignore that
11:58:59 <shapr> Marvin--: you busy?
11:59:25 <shapr> Marvin--: I was wondering if I can store an RNG inside the StateT with the same liftIO trick
12:00:08 * Rapiere bbl
12:00:23 <Marvin--> shapr: yeah, I guess... state is state is state...
12:00:40 <shapr> hi Vincenz 
12:00:41 <Marvin--> shapr: what's up, a fortune cookie plugin?
12:00:47 <shapr> Marvin--: how did you know? :-)
12:00:58 <Marvin--> what else could it be? :-)
12:01:00 <Vincenz> hiya shapr
12:01:10 <Vincenz> I have to let you down, I have decided to learn ocaml first...
12:01:14 <Vincenz> but!
12:01:16 <Vincenz> on a good note
12:01:18 <Marvin--> infidel!
12:01:22 <Marvin--> smite the infidel!
12:01:22 <Vincenz> I have also decided to learn emacs 
12:01:22 <shapr> Vincenz: that's okay with me.. do what's fun for you.
12:01:31 <Marvin--> Vincenz: I rest my case! ;)
12:01:38 <shapr> I'm a great fan of emacs.
12:01:43 <Vincenz> :)
12:02:03 <Vincenz> I'm a great fan of VIM, but Emacs seems to have some nice things (like shells in windows....could be useful for hugs or ghc)
12:03:17 * Marvin-- is a vim user
12:03:42 * Vincenz too
12:03:59 <Vincenz> But Emacs seems to have some nice things (I used to be an Emacs-hater...)
12:04:17 <Igloo> emacs leads to LISP...LISP leads to impurity...impurity leads to sufffffering
12:04:28 <Marvin--> I'm not an emacs hater, I just like vim better
12:04:32 <Explodey> ISTR someone used both editors in one presentation at FoP
12:04:40 <shapr> Igloo: happily, the HTk guys have figure out how to script xemacs with Haskell
12:04:40 <Explodey> Which is unusual
12:04:41 <Marvin--> *gasp*
12:04:53 * Marvin-- goes dammit at i18n+serial install
12:05:16 <Igloo> Oh, cool  :-)
12:05:41 <Explodey> igloo: not as impure as VIM's macro language
12:05:50 <Marvin--> it's using UTF-8 and I do have a UTF-8 locale, shouldn't that work? :/
12:06:14 <Igloo> Ssshhhh  :-)
12:06:26 <Igloo> Surely they're both just not pure, anyway?
12:06:38 <Marvin--> I think someone's a bit obsessed
12:07:11 <BlitzNL> I have this 'pattern' in which a string occurs I want to substract from a different datatypes. The always are like A(B(C "this string")), but the constructors differ, is this possible?
12:07:15 <Igloo> Me? With purity, vim or anti-emacs?
12:07:16 <Vincenz> Igloo: Lisp is my BIGGEST reason -not- to use emacs
12:07:28 <Explodey> Is unsafePerformIO required by the H98 library report?  If so then H98 isn't pure either
12:07:42 <Vincenz> especially cause it's lisp and not evne scheme, and because it's ...LISP(lost in silly parentheses)
12:07:50 <Igloo> Blitz: No
12:07:57 <Igloo> You could do it with a class and TH
12:08:01 <Riastradh> Vincenz - Use Edwin, then.
12:08:08 <BlitzNL> Igloo: ok thnx
12:08:13 <Igloo> uPIO isn't in the report IIRC
12:08:43 <Vincenz> Riastradh: what's the diff?
12:08:54 <Vincenz> ah...scheme
12:08:59 <Riastradh> Vincenz - Edwin is written in Scheme.
12:09:07 <Vincenz> just read it :P
12:09:10 <Marvin--> and that's better...how?
12:09:11 <Marvin--> ;)
12:09:30 <Vincenz> less macro shit
12:09:32 <Riastradh> Marvin-- - Real lexical scoping, functions and variables share a namespace, it's simpler, et cetera.
12:09:39 <Vincenz> that too
12:09:45 <shapr> won't I have to add a new field to the record that gets passed to StateT if I want someplace to save this RNG?
12:10:33 <Marvin--> shapr: yes?
12:10:48 <shapr> I was thinking of Python instances, 'just add a post-it'
12:11:03 <Marvin--> with Haskell's type system? you're kidding
12:11:24 <shapr> I know :-)
12:11:34 <shapr> I haven't retrained all my reflexes yet
12:11:38 * Igloo gets a headache working through core that uses TH constructors to build values representing TH types
12:11:50 <shapr> Igloo: wow, just a headache? :-)
12:11:57 <Igloo> :-)
12:12:14 <Marvin--> I get a headache just from core
12:12:24 <shapr> well f00
12:12:37 * Marvin-- sighs
12:12:38 <Igloo> It doesn't help when there's comething called Cons and I pronounce : as "cons"  :-)
12:12:47 <Marvin--> I don't *quite* know how to get these overlapping patterns to work
12:13:05 * Marvin-- swears at his master project
12:13:05 <shapr> I need some generic way for each module to be able to save useful stuff inside the StateT monad...
12:13:18 <shapr> how can I add a scratch area for every irc plugin?
12:14:10 * shapr thinks
12:14:34 <Marvin--> you could stack your own StateT on top of it inside the module :-)
12:18:03 <shapr> Memento is all about State Monads
12:18:32 <Darius> I didn't see that when I could've
12:18:42 <shapr> it's worth seeing
12:18:53 <Darius> that's what I heard... after, I'll see it sooner or later
12:19:04 <shapr> yah, that's how I see movies
12:20:54 <shapr> Marvin--: how would that work?
12:21:02 <shapr> can you give me a hint?
12:21:08 <Marvin--> I don't know if it will
12:21:42 <Marvin--> given that all operations take place in IRC (), I guess it'll be tricky
12:22:00 <Marvin--> you'd have to runStateT all the time, which makes it moot
12:22:52 <Marvin--> but wait a sec
12:23:10 <Marvin--> why don't put it in the module type?
12:23:16 <shapr> I was wondering about that
12:23:18 <Marvin--> or do you need to change it?
12:23:27 <shapr> yah, I would need to change the state
12:23:39 * Marvin-- goes hmm
12:23:45 <shapr> for a fortune plugin I need to stick the new RNG in there
12:23:52 <shapr> every time I use this one
12:24:12 <shapr> could I hack ircLoadModule to make a space for the module it's loading in the IRCRWState record?
12:24:15 <Marvin--> well, given that IRC is already IO, you can use the IO version rng...
12:24:18 <shapr> can I extend records on the fly like that?
12:24:21 <Marvin--> no
12:24:24 <shapr> oh
12:24:35 <tic> how would I print out a binary tree easiest?
12:24:39 <tic> so it's sorted?
12:24:55 <tic> say you have (LeftTree key value RightTree)
12:25:05 <tic> and a function traverse which takes a Tree
12:25:07 <Marvin--> you want to print a ordered binary tree in sorted order? that sounds just like a preorder traversal?
12:25:16 * Igloo can't see a way of doing what shapr wants with H98 other than read/show and a map of some sort
12:25:37 <tic> Marvin--, think you could explain, or would I be better off reading up on some theory behind?
12:26:19 <shapr> I think I came up with a very cheesy way :-)
12:26:22 <tic> Marvin--, do I first traverse the left-hand side and after that all right-hands (when the left-hand call returns)
12:26:42 <shapr> since ircModules is part of the IRCRWState, I could unload the module, and reload it with the new state.
12:26:54 <shapr> and make the state part of the Module type, as you suggested
12:26:56 <Marvin--> shapr: eeeewwww
12:27:01 <shapr> yah, it's extracheesy
12:27:21 <Marvin--> tic: preorder means first traverse left sub-tree, then visit this node's value and then traverse the right sub-tree
12:27:40 <tic> Marvin--, aha.
12:27:45 <shapr> there must be a better way.
12:28:03 <tic> Marvin--, but my tree looks as such : data Tree a b = (Join left a b right) | Empty
12:30:31 * tic tries
12:32:32 <Darius> preorder is m l r, inorder l m r, and postorder l r m
12:35:58 <Marvin--> yes, sorry
12:36:00 * Marvin-- is tired
12:36:44 <Marvin--> "A movie star can be anything, short, tall, thin - or skinny"
13:06:47 * shapr reads about SOAP
13:06:55 <whee> shapr: it's for cleaning!
13:07:45 <shapr> is there some way to automatically convert an XMLSchema into a DTD?
13:08:10 <shapr> or even better, can one of the Haskell XML toolkits handle XMLSchemas already?
13:09:43 <Riastradh> shapr - No, because XML Schemas do more than DTDs.
13:10:43 <shapr> well, I can hope.
13:29:17 <shapr> wow, neat
13:29:20 <shapr> http://thaiopensource.com/relaxng/derivative.html
14:51:41 * Pseudonym yawns
14:53:55 <Pseudonym> I wish I had my copy of "Adventures in the Screen Trade" here.
14:54:06 <Pseudonym> William Goldman has a lot of evil things to say about "movie stars".
15:05:33 * Pseudonym must be tired
15:10:04 <kawfee> ?
15:10:17 <shapr> hi Pseudonym 
15:10:18 <shapr> wasssup?
15:10:33 <shapr> lambdabot question... where can I save per-module state?
15:10:38 * kawfee bounces
15:10:41 * shapr bounces
15:10:49 <Pseudonym> At the moment, I don't think you can anywhere.
15:10:56 <shapr> I want to make a fortune plugin, but I can't figure out where to save the RNG
15:11:13 <shapr> I'd also like to keep the database connection persistent somewhere
15:11:37 <shapr> the only thing I could think of was to keep state in the Module itself, and unload/reload the module when the state changes
15:11:44 <Pseudonym> I'd add an element to the RWState:
15:11:45 <shapr> and that's an ugly hack :-(
15:12:50 <Pseudonym> forall a. (Typeable a) => IRCRwState { ... ; ircModuleState :: FiniteMap String (IORef a) ... }
15:13:03 <Pseudonym> Hmmm.
15:13:08 <Pseudonym> Actually, that's wrong.
15:13:26 <Pseudonym> data DYNAMIC = forall a. (Typeable a) => DYNAMIC a
15:13:34 <Pseudonym> ircModuleState :: FiniteMap String DYNAMIC
15:13:44 <Pseudonym> That's more like it.
15:13:55 <kawfee> what is that?
15:14:15 <Pseudonym> This is how you do traditional OO in Haskell. :-)
15:14:20 * shapr laughs
15:14:40 <shapr> do you think I'm approaching the problem the wrong way?
15:14:45 <shapr> is there a better way?
15:14:46 <Pseudonym> No.
15:14:50 <Pseudonym> Possibly.
15:14:59 <shapr> like what?
15:15:08 <Pseudonym> I don't know.  Let's think about it for a moment.
15:15:18 <shapr> I wanted to have ircLoadModule 'extend' the IRCRWState record on-the-fly
15:15:22 * Pseudonym nods
15:15:32 <shapr> that would make the most sense to me
15:15:34 <Pseudonym> I think it makes sense to use IORefs.
15:15:47 <Pseudonym> SO a module can grab its IORef, then do what it wants without modifying the IRCRWState.
15:15:59 <Pseudonym> It only needs to be modified when a module is loaded or unloaded.
15:16:04 <Pseudonym> And sometimes not even then.
15:16:45 <shapr> I also made ircPrivmsg handle newlines in the msg correctly
15:16:48 <shapr> lambdabot: @fact foo
15:16:49 <lambdabot> bar
15:16:49 <lambdabot> baz
15:16:57 * Pseudonym laughs
15:17:08 <Pseudonym> lambdabot: @fact shapr
15:17:08 <lambdabot> Shae Erisson, wrote the factoid plugin for lambdabot
15:17:22 <Pseudonym> lambdabot: @fact recursion
15:17:22 <lambdabot> see recursion
15:17:23 <shapr> lambdabot: @fact author
15:17:23 <lambdabot>  Andrew Bromage aka Pseudonym
15:17:28 <shapr> :-)
15:17:31 <Pseudonym> Kewl.
15:18:32 <Darius> Hmm...
15:18:40 <Darius> lambdabot: @fact lambdabot
15:18:40 <lambdabot> the coolest (only) irc 'bot written in Haskell., is rude
15:18:55 <shapr> lambdabot: @fact source
15:18:55 <lambdabot>  http://sf.net/projects/haskell-libs/
15:19:01 <Pseudonym> You could probably load the jargon file into it.
15:19:20 <shapr> yah, that would seed the database nicely
15:19:27 <Pseudonym> Or FOLDOC.
15:19:31 <Pseudonym> Or both, hey.
15:19:32 <shapr> that would be fun
15:19:37 <Pseudonym> Actually...
15:19:39 <Pseudonym> Now here's a fun project.
15:19:44 <shapr> uh oh :-)
15:19:47 <Pseudonym> A lambdabot to DICT gateway.
15:20:01 <shapr> well, I've been trying to figure out a lambdabot to google gateway just now
15:20:20 <shapr> but I can't figure out if any Haskell XML libs support XML Schemas
15:20:29 <shapr> so far, I can only find DTD support
15:20:40 * Pseudonym nods
15:20:58 <shapr> I played with a Haddock plugin for a bit, but the Binary module in Haddock makes ghci explode
15:21:09 <Pseudonym> DICT might be a lot simpler.
15:21:18 * shapr looks
15:21:20 <Pseudonym> RFC 2229, I believe.
15:21:52 * shapr reads that rfc
15:22:26 <shapr> well, before I start on a DICT module, lemme try the per-module state thingy
15:22:31 * Pseudonym nods
15:22:55 <shapr> I haven't used IORefs before
15:23:04 <Pseudonym> They're very handy.
15:23:14 * Pseudonym would be lost without them
15:23:26 <Pseudonym> Though I am frequently annoyed that they're not memebers of Ord.
15:23:34 <Igloo> Euch
15:23:47 <shapr> why would you want them to be member of Ord?
15:23:54 <Igloo> What sort of thing do you use them for?
15:23:58 <Pseudonym> Hash consing.
15:24:09 <Pseudonym> Or, in my case, FiniteMap consing.
15:24:33 <Igloo> Oh, I was told what I'm doing is hash consing today
15:24:38 <Pseudonym> Oh, there you go.
15:24:51 <Pseudonym> Can you see why making IORefs a member of Ord would help you there?
15:25:04 <Igloo> And as it happens I'm implementing what my supervisor implemented with IORefs as 9essentially) a pair of FiniteMaps  :-)
15:25:44 * Pseudonym laughs
15:25:57 <Pseudonym> Yup.  A pair of FiniteMaps and an Int counter does the trick, mostly.
15:25:58 * Igloo thinks about that
15:26:06 <Pseudonym> Don't forget the counter.
15:26:14 <shapr> ok, so the IORefs thingy was the forall a. (Typeable a) => thingy, yes?
15:26:18 <Igloo> No, I don't think I see
15:26:33 <Igloo> (the Ord thing)
15:26:41 <Pseudonym> Hang on.
15:26:44 <Pseudonym> shapr: Yes.
15:26:48 <Igloo> Yeah, I keep the next address to be used in the datastructure
15:27:00 * Igloo has it working, just need to make it cover all the cases I need now
15:27:03 <Pseudonym> The idea is, you put a FiniteMap in the IRCRWState, which gives you an IORef.
15:27:11 <Pseudonym> The IORef is the "real" state.
15:27:26 <Pseudonym> Or it points to it, anyway.
15:27:50 <Pseudonym> Igloo, the thing about hash consing, is the problem of "child" references.
15:27:58 <Pseudonym> Suppose, for example, you want regular expressions.
15:28:02 <Pseudonym> You'd have something like this:
15:28:20 <shapr> Can't combine named fields with locally-quantified type variables
15:28:21 <shapr> :-(
15:28:25 <Pseudonym> data RE = Term Char | Star RERef | Cat [RERef] | Or [RERef]
15:28:37 <Pseudonym> Oh, that's right.
15:28:44 <Pseudonym> You can do this though:
15:29:11 <Pseudonym> ircModuleState :: forall a. (Typeable a) => FiniteMap String (IORef a)
15:29:12 <Pseudonym> I think.
15:29:15 * Pseudonym hmmms
15:29:28 <Pseudonym> Maybe it's the typeclass constraint which it doesn't like.
15:29:34 <Pseudonym> Sorry, Igloo, back to you.
15:29:45 <Pseudonym> RERef is the type of the thing that you can dereference.
15:29:48 <Pseudonym> With me so far?
15:30:12 <shapr> wow, that worked
15:30:36 <Pseudonym> shapr: Except that it's wrong.
15:30:41 <shapr> it is?
15:30:44 * Pseudonym nods
15:30:48 <Igloo> Yup
15:30:51 <shapr> how so?
15:30:59 <Pseudonym> This constrains FiniteMap to map to IORef a where a is the same type no matter what the key is.
15:31:05 <Pseudonym> What you want is this:
15:31:20 <Pseudonym> data ModuleState = forall a. (Typeable a) => ModuleState a
15:31:30 <Pseudonym> ircModuleState :: FiniteMap String (IORef ModuleState)
15:31:41 <shapr> aha
15:31:48 <Pseudonym> Igloo: OK.  In your case, type RERef = Int or something.
15:31:58 <Pseudonym> Suppose you want type RERef = IORef RE
15:32:19 <Igloo> OK
15:32:26 <Pseudonym> Then to do data RE = {- ... -} deriving (Ord), you need RERef to be a member of Ord.
15:32:40 <Pseudonym> Otherwise your only option is to manually create an instance of Ord.
15:32:43 <shapr> yay
15:32:44 <Pseudonym> Which is double maintenance.
15:32:45 <shapr> it compiles
15:32:48 * shapr dances happily
15:32:52 <Pseudonym> Cool.
15:33:11 <shapr> silly question... how do I get to these guys now?
15:33:13 <Pseudonym> Igloo: Hence, IORef needs to be an instance of Ord.
15:33:13 <Igloo> Oh, of course, I was looking in the wrong place  :-)
15:33:33 <Pseudonym> shapr: What you probably want to do is fetch the IORef first.
15:33:40 <shapr> ok
15:33:41 <Igloo> Because I have something like FiniteMap (IORef a) b which require it directly
15:33:42 * shapr reads about IORefs
15:34:33 <shapr> Pseudonym: do you have any more interesting Haskell bitz like lambdabot hanging around?
15:34:36 <shapr> lambdabot is seriously spiffy
15:35:39 <Pseudonym> process stuff = do  myref <- gets (\s -> just (lookupFM (ircModuleState s) "modulename"))
15:35:52 <Pseudonym> Uhm.
15:35:55 <Pseudonym> Actually, not quite.
15:35:59 <Pseudonym> That gives you the ModuleState.
15:36:08 <Pseudonym> You get the idea, though.
15:36:14 <shapr> then I call readIORef I think...
15:36:24 <shapr> this is great, thanks :-)
15:36:29 <Pseudonym> Sure.
15:36:35 <Pseudonym> I have a few things hanging around.
15:36:43 <shapr> oh really?
15:36:47 * shapr is intensely curious
15:36:52 <Pseudonym> I have a program which produces the optimal game tree for the old Nokia GSM phone "Logic" game.
15:37:00 * shapr grins
15:37:24 <shapr> is the source online somewhere?
15:37:27 <Pseudonym> Let's see... some arbitrary precision real code, but it doesn't handle transcendental functions.
15:37:41 <Pseudonym> Only standard arithmetic.
15:37:53 <Pseudonym> I didn't use LFTs, I used continued fractions.
15:38:13 <shapr> cool
15:38:21 * shapr wonders what an LFT is
15:38:52 <Pseudonym> Linear fractional transformation.
15:38:57 <Pseudonym> OK, here's the deal:
15:39:28 <Pseudonym> Representing an arbitrary precision real isn't rocket science so long as you only want to do simple arithmetic.
15:39:42 <Pseudonym> The problem is when you want to compute a function like sin or exp.
15:39:45 <Pseudonym> Or even sqrt.
15:40:01 <Pseudonym> You require an infinite series, or possibly some kind of fixpoint iteration.
15:40:25 <Pseudonym> Either way, you need an infinite amount of simple arithmetic before you get an answer.
15:40:29 <shapr> I understand that
15:40:48 <Pseudonym> LFTs are a cute way which overcomes this limitation.
15:41:00 <Pseudonym> An LFT is a function of the form:
15:41:03 <shapr> some sort of symbolic transformation?
15:41:11 <Pseudonym> f z = (a*z+b)/(c*z+d)
15:41:15 <Pseudonym> No, it's not symbolic.
15:42:02 <Pseudonym> OK.
15:42:46 <Pseudonym> If you take the range (-infinity,infinity) and put all values through this function, you get a different range.
15:42:49 <shapr> break down infinite series into finite chunks that represent them?
15:42:53 <Pseudonym> Which may be finite.
15:42:56 <shapr> ah yes
15:43:42 <Pseudonym> LFT reals give you a representation for real numbers as a possibly infinite list of LFTs, where you take the intersection of the ranges as the "number".
15:43:56 <Pseudonym> Because it's the intersection, you can add more precision by using more transformations.
15:44:11 <Pseudonym> Moreover, you can actually work out how much precision you have.
15:44:15 <shapr> wow
15:44:34 <shapr> did you learn that in college?
15:44:37 <Pseudonym> You can even compute with fixpoint recursion if you want.
15:44:41 <Pseudonym> No, I read a paper on it. :-)
15:44:53 <Pseudonym> Say you want to compute the square root of a number.
15:45:02 <Pseudonym> You can use the Newton-Raphson formula:
15:45:07 <shapr> I'm beginning to think reading academic papers is the only way to a good education.
15:45:14 <Pseudonym> s x = (x + n/x) / 2
15:45:16 <shapr> college is optional
15:45:37 <Pseudonym> So sqrt x is the intersection of:
15:45:50 <Pseudonym> let r = (-inf,inf) in intersection [r, s r, s (s r), ...]
15:46:02 <Pseudonym> Take as many LFTs as you need to get the precision you want.
15:46:24 <Pseudonym> Bloody clever technique.
15:46:52 <shapr> sounds like it.
15:47:01 <shapr> makes me wish I could find a use for it sometime :-)
15:47:27 <Pseudonym> This actually came up on haskell-cafe today.
15:47:30 <shapr> I've wondered about an RPC protocol that doesn't use float, int, etc but only rational numbers
15:47:32 <Pseudonym> http://www.doc.ic.ac.uk/~ae/exact-computation/
15:47:50 <Pseudonym> In particular: http://www.doc.ic.ac.uk/~ae/exact-computation/Haskell
15:48:05 <Pseudonym> Actually, you might want to contact this guy and ask if you can put his code in haskell-libs.
15:48:10 <Pseudonym> Or I can.
15:48:17 <shapr> yes please!
15:49:04 <Pseudonym> OK.
15:49:25 <Pseudonym> I occasionally find that I need high precision floats.
15:49:48 <Pseudonym> For example, if I need to compute some coefficients for Gaussian quadrature or something.
15:50:27 <shapr> I can barely wait till I get that google plugin working for lambdabot 
15:50:55 <shapr> hey, what about the ircUnloadModule code that's commented out in lambdabot?
15:51:09 <shapr> did you have a different plan in mind? or what?
15:51:25 <Pseudonym> Can't remember.
15:51:28 <Pseudonym> Does it compile?
15:51:33 <Pseudonym> Actually...
15:51:45 <shapr> nope
15:51:52 <Pseudonym> That's probably why it's commented out.
15:51:56 <shapr> oh wait, I think it might be user error
15:52:10 <Pseudonym> You may want to consider a refactoring.
15:52:19 <Pseudonym> We've got a lot of module-specific stuff in here.
15:52:29 <shapr> yah, I'd like to factor a lot of stuff out of Main
15:52:38 <Pseudonym> You may want to factor all that out into one record.
15:52:41 <shapr> and out of IRC.hs into a module thingy
15:52:57 <shapr> and a better command processor, as you originally suggested
15:53:08 <Pseudonym> At the moment, a MODULE is this:
15:53:09 <Pseudonym> data MODULE = forall m. (Module m) => MODULE m
15:53:15 <Pseudonym> You could actually make that a record.
15:53:20 <shapr> ?
15:53:27 <Pseudonym> Uhm...
15:53:32 <Pseudonym> Hang on.
15:53:42 <Pseudonym> You could add an initialisation method to the Module typeclass.
15:53:50 <Pseudonym> And let each module store what it wants in there.
15:53:51 <shapr> if you get the sudden urge to refactor lambdabot or any other code in haskell-libs, collective code ownership is one thing I practice.
15:53:52 <Pseudonym> Like the IORef.
15:54:05 <Pseudonym> Save yourself a FiniteMap lookup.
15:54:11 <shapr> that's true
15:55:16 <shapr> I still don't understand everything happening in lambdabot, but it has been very educational so far.
15:55:18 <shapr> thanks :-)
15:56:30 <shapr> the unload code is very much like the load code..
15:56:32 * shapr tries to fix it
15:56:33 <Pseudonym> Glad to be of service.
15:56:44 <Pseudonym> Oh, Igloo: I actually wrote a version of IORef which supports Ord.
15:56:48 <Pseudonym> I might put it in HFL.
15:59:28 --- topic: set to '["mo' nads than you", "We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/", "New Hat 2.02 http://www.haskell.org/hat/", "New Learning Haskell page - http://www.haskell.org/learning.html", "GUI Demos - http://repetae.net/john/computer/haskell/gui/", "Order Haskell 98 Report in Hardcopy - http://titles.cambridge.org/catalogue.asp?isbn=0521826144", "GHC 5.04.3 released!"]' by shapr
15:59:39 <shapr> new Hat 2.02 http://www.haskell.org/hat/
16:00:11 <shapr> now supports MPTC, fundeps, existential quantification of datatype declarations
16:00:52 <shapr> it's amazing how much Haskell code has been sponsored by Microsoft Research
16:00:58 <shapr> sort of worrisome sometimes 
16:01:40 <Pseudonym> The thing you have to understand about Microsoft is that they're a bit like the DoD.
16:01:52 <Pseudonym> They have no idea what the Next Big Thing(tm) is, but they want to have it first.
16:02:04 <Pseudonym> Or at least have the option of swallowing it up first.
16:02:24 <shapr> I guess I could stand being paid lots of money to write Haskell code.
16:02:34 <shapr> what about you?
16:02:52 <Pseudonym> If I had to write papers and tech reports too, it'd have to be a lot of money.
16:02:56 * shapr grins
16:03:33 <shapr> I really hope I can find a Haskell to JVM bytecode thingy somewher
16:03:33 <shapr> e
16:04:49 <Darius> Haskell -> GCC -> JVM?
16:04:55 <shapr> hm!
16:05:13 <shapr> I think gcj only compiles from jvm -> binary
16:05:18 <shapr> rather than the other way around
16:05:38 <shapr> if GCC can compile to JVM I'd be very happy to hear that.
16:05:59 <andersca_> it can
16:06:06 <shapr> !
16:06:30 <shapr> from C code? or what?
16:06:31 * shapr googles
16:07:24 <shapr> wow
16:08:08 <shapr> http://www.itee.uq.edu.au/~cristina/uqbt.html#gcc-jvm
16:08:47 <creature> Now this is interesting. 
16:08:55 <creature> Everything on my PC is segfaulting. 
16:09:01 <creature> Which means I can't su to root to shutdown -r . 
16:09:39 <mgoetze> creature: uhm... what did you do?
16:09:47 <creature> Nothing. :/
16:09:54 <mgoetze> can you ssh in as root?
16:09:56 <creature> But it seems like I can't spawn any new processes. 
16:10:19 <creature> No, and I've just made sshd seg by trying. 
16:10:36 <whee> sounds like bad memory?
16:10:41 <creature> Though it's just killed off its spawned process. 
16:11:03 <shapr> that happened to me when my CPU overheated
16:11:06 <whee> my desktop machine's ram has been deteriorating over time and did that once
16:11:14 <whee> needed to swap the sticks around and boost voltage
16:11:20 <Pseudonym> Sorry, that was me.
16:11:34 <creature> I've only had this ram for about 6 months, though. 
16:11:41 <creature> It shouldn't be deteriorating. 
16:11:44 <Pseudonym> I hAx0R3d uR mACh33n!!!!1!!!
16:11:52 <creature> Anyway, bright ideas on how to do a neat shutdown? 
16:11:57 * Pseudonym 0wNZ u!!!!1!!!!
16:11:59 <creature> Pseudonym - no, you didn't.
16:12:05 <Pseudonym> No, I didn't.
16:12:09 <creature> :)
16:12:13 <Pseudonym> Do you have console access?
16:12:19 <creature> I'm on the console now. 
16:12:19 <Pseudonym> Or are you elsewhere?
16:12:27 <Pseudonym> Try ctrl-alt-delete.
16:12:32 <creature> I've disabled it. 
16:12:34 <Pseudonym> Ah.
16:12:37 <Pseudonym> Don't do that.
16:12:43 <mgoetze> creature: sysrq-u, sysrq-b
16:12:43 <creature> Someone thought it was funny to restart my box, so I stopped it doing that. 
16:12:49 <Pseudonym> Gotcha.
16:12:59 <shapr> sysreq-s  first
16:13:10 <shapr> sync sync halt
16:13:14 <mgoetze> shapr: sysrq-u will do that, too
16:13:19 <shapr> oh, I didn't know that
16:13:22 <creature> Do I need to do anything swish to get to SysRq? shift, alt, etc. 
16:13:25 <creature> I've already ran sync. 
16:13:34 * shapr remebers doing sync sync halt on unix machines long ago
16:13:42 <mgoetze> creature: alt-, and you need kernel support :)
16:13:44 <shapr> Pseudonym: how old are you, if you don't mind me asking :-)
16:14:03 <creature> mgoetze - Alt and SysRq flips me between the last used tty and this one. 
16:14:25 <shapr> creature: have you enabled the magic SysReq key in your kernel config?
16:14:28 <mgoetze> eh? why would it do that?
16:15:03 <creature> shapr - I don't think so.
16:15:08 <Pseudonym> shapr: 29, going on 14.
16:15:09 <creature> Care to give me something to grep for? 
16:15:21 <mgoetze> creature: cat /proc/sys/kernel/sysrq
16:15:39 <shapr> Pseudonym: are you seriously 29?
16:15:43 <Pseudonym> Yup.
16:15:46 <shapr> wow
16:15:47 <Pseudonym> Why, what did you think?
16:15:50 <creature> Doesn't exist. 
16:15:56 * mgoetze suddenly wonders how old shapr is
16:16:01 <mgoetze> creature: you're out of luck, then
16:16:03 <shapr> Pseudonym: for some reason I assumed you were significantly older than me :-)
16:16:11 <shapr> not younger ;-)
16:16:16 <creature> Oh well, I'll BRB.
16:16:18 <Pseudonym> You're older than me?
16:16:23 <Pseudonym> Geez.
16:16:24 <shapr> yah, I'm 31
16:16:28 * Pseudonym is married with children
16:16:35 <shapr> I'm unmarried, no kids
16:16:35 <Pseudonym> That could have something to do with it.
16:16:36 <mgoetze> Janni is the youngest in the channel?
16:17:16 <Pseudonym> I also look older than I am.
16:17:20 <Pseudonym> Especially with the beard.
16:17:21 <shapr> I look younger than I am
16:17:38 <Pseudonym> My wife persuaded me to grow the beard with the following wise words:
16:17:49 <Pseudonym> "OK... Blackadder II... Mr Bean... you choose."
16:17:50 <shapr> people sometimes think I'm too young to drink.
16:17:54 * shapr laughs
16:18:14 <shapr> I am unable to grow a beard.
16:18:19 * mgoetze thinks everyone is too young to drink ;)
16:18:26 <shapr> see shae - http://kungens.kemi.fi/~shae/foto/
16:18:30 <creature> Back.
16:18:47 <creature> mgoetze - how old is Janni? 
16:18:49 <Pseudonym> Yes, you look about 23.
16:19:07 <mgoetze> creature: 17 or 18?
16:19:22 * whee is 19 :|
16:19:29 * mgoetze is 19 as well
16:19:31 <shapr> whee: you're a young'un
16:19:32 <Pseudonym> http://infotrope.net/album/netizen/netizen-wake2.jpg
16:19:37 * creature is 18.
16:19:40 <mgoetze> of course, Janni might be 19 as well.
16:19:41 <creature> So a contender for youngest. :)
16:19:43 <Pseudonym> The guy with the baby on his head is me.
16:19:47 <whee> haha
16:19:51 <shapr> Pseudonym: cool!
16:19:51 <Pseudonym> I don't look 27 in that photo.
16:19:51 * mgoetze says Janni and creature battle it out :)
16:20:45 <shapr> well, I hope to be married with kids sometime soon.
16:22:27 <mgoetze> shapr: is there a particular female you have in mind? ;)
16:22:36 <shapr> yes, I've been living with her for four years ;-)
16:22:39 <Pseudonym> He moved to Europe for her.
16:22:43 <shapr> yes, exactly.
16:22:44 <Pseudonym> Now that's love.
16:22:54 * Pseudonym managed to get his SO to move country for him instead
16:22:54 <shapr> mgoetze: she's from Saarbrucken
16:23:11 <mgoetze> shapr: oooh, say "guten abend" for me :)
16:23:17 <shapr> :-)
16:23:28 <shapr> she's asleep already
16:23:41 <shapr> she has this weird schedul where she wakes up everyday at 7:30am
16:23:59 <shapr> I'll tell her tomorrow.
16:24:00 * Pseudonym does that
16:24:10 <Pseudonym> I have to commute an hour or so to work, though
16:24:10 <shapr> have you done that all your life?
16:24:15 <Pseudonym> No.
16:24:25 <shapr> my commute is about five seconds.
16:24:25 <Pseudonym> I'd far prefer to wake up around 10.
16:24:25 <mgoetze> shapr: oh, probably need to make it "guten morgen" then :)
16:24:47 <shapr> depends on how long it takes me to go down the stairs.
16:25:24 <shapr> Pseudonym: where's your SO from?
16:25:27 <Darius> Hmm, if you call someone on the other side of the world and say Good Morning, do they respond Good Evening?
16:25:41 <shapr> I just say "hi"
16:26:30 <shapr> yay, I got the ircUnloadModule code to compile.
16:26:35 <shapr> I wonder if it works too
16:26:59 <Pseudonym> The USA.
16:27:15 <shapr> cool
16:27:17 <Pseudonym> Her father was in the air force, so all over the USA and a few years in Germany.
16:27:36 <shapr> my father was in the air force also, but I've just been all over the USA
16:27:51 <shapr> 'zoomer brats' is the colloquialism
16:27:55 * Pseudonym nods
16:28:21 <Pseudonym> People who have lived all over seem to transplant to another country fairly easily.
16:28:35 <Pseudonym> I've also found that expatriate Americans tend to be more critical of the US government.
16:28:42 <Pseudonym> No matter who is in power.
16:29:08 <shapr> I think, a) never had a 'home' to begin with and/or b) home is wherever you are
16:29:14 * Pseudonym nods
16:29:36 <shapr> the downside is that I get restless again after I've been in one place for a year.
16:30:52 <shapr> o3: hey, you planning on upgrading runtime_loader to ghc5.04.3 ?
16:59:40 <Pseudonym> I want to visit Imerial College someday.  I've always thought they have the best domain name.
16:59:52 <shapr> ?
17:00:06 <shapr> what domain name would that be?
17:00:27 <Pseudonym> ic.ac.uk
17:00:48 <shapr> very phonetic
17:00:54 <Pseudonym> There's only one way to pronounce it, I reckon.
17:00:59 * shapr grins
17:01:03 <shapr> ick ack uck ?
17:01:18 <Pseudonym> Though a friend of mine (hosted on my machine, too) owns dev.null.org.
17:01:28 <shapr> cool
17:01:40 <shapr> I think I've seen an email address on that domain
17:01:51 <Pseudonym> Probably hum.
17:01:53 <Pseudonym> him
17:32:13 <shapr> what's the difference between Data.IORef and GHC.IOBase ?
17:32:30 <shapr> it seems the IORef constructor isn't in Data.IORef
17:34:36 <shapr> it looks like they're not the same thing?
17:36:06 <shapr> w00, it compiles
17:36:40 * shapr successfully pulls off some voodoo programming
17:41:21 * shapr crosses fingers
17:46:24 <shapr> hm
17:49:24 <shapr> ok, stupid question... how do I get the string out of ModuleState?
17:49:32 <shapr> data ModuleState = forall a. (Typeable a) => ModuleState a
17:49:44 <shapr> say I have ModuleState "foo"
17:49:57 <shapr> how do I get "foo" back out of that?
17:50:11 <kunphuzil> Anyone know anything about Helium?
17:50:24 <shapr> kunphuzil: I know a bit about it, what do you need to know?
17:51:05 <kunphuzil> Just wondering if it is any useful for beginners.. I know it is farely new.
17:52:17 <kunphuzil> Also, can it be run as an interpreter?
17:52:29 <shapr> I think so
17:52:49 <kunphuzil> Do you think it would be good helping me?
17:52:55 <kunphuzil> Hmm.. worth a try anyway.
17:53:04 <kunphuzil> I have ghc, I will just compile it and see.
17:53:13 <shapr> yah, go for it.
17:54:07 <kunphuzil> Hmm.. I think maybe the interpreter is only graphical?
17:54:20 <shapr> that would surprise me, but it's possible
17:54:27 <shapr> Hugs is also a haskell interpreter
17:54:40 <kunphuzil> Yeah, I am using that right now.
17:56:15 <shapr> I'm used to pulling things out of complex types with pattern matching
17:56:19 <shapr> but this isn't working
17:56:22 <shapr> data ModuleState = forall a. (Typeable a) => ModuleState a
17:56:22 <shapr> x = ModuleState "foo"
17:56:22 <shapr> stripit (ModuleState x) = x
17:58:26 <shapr> I think the problem is that I don't know how forall works.
17:59:16 <Darius> yeah
17:59:25 <shapr> Darius: do you know how it works?
17:59:36 <Darius> I wouldn't claim that yet...
17:59:52 <shapr> can you tell me how to get that string back out of a ModuleState type?
18:00:41 <Darius> Um, from what I see.  You can't.  a could be anything as long as it's Typable, so the only operations you can apply to a are the ones in class Typeable
18:01:40 <Darius> Is ModuleState an instance of any classes?
18:01:52 <shapr> nope
18:02:02 <shapr> but you may have solved my problem :-)
18:02:16 <Darius> Well, using Typeable, you can find the type with typeOf
18:03:05 <Darius> However, this is where I get foggy, 'cause I don't use Dynamic and Typeable often (read: at all) 
18:03:12 <shapr> same here
18:05:41 <shapr> er
18:05:47 <shapr> typeOf x returns [Char]
18:05:51 <shapr> but I already knew that.
18:08:45 <shapr> I'm lost.
18:11:13 <Darius> (btw. "Putting Type Annotations to Work" is a decent covering of higher-ranked types if you haven't read it)
18:11:33 <shapr> I'll check it out, thanks.
18:12:52 <shapr> I cheated
18:12:57 <shapr> but I think it works.
18:13:20 <shapr> I'll ask Pseudonym for a real solution. This one sucks.
18:13:31 <Darius> Um, I think I figured it
18:13:37 <shapr> yes yes?
18:13:39 * shapr bounces
18:13:56 <Darius> if stripModuleState someMS == typeOf (undefined :: [Char]) then True else False
18:14:18 <Darius> Now the question is can you convert...
18:14:27 <Darius> Well, I'm getting there...
18:14:30 <shapr> :-)
18:15:04 <shapr> here's how I cheated:
18:15:11 <shapr> data ModuleState = forall a. (Typeable a, Show a) => ModuleState a
18:15:14 <shapr> instance Show ModuleState where
18:15:14 <shapr>     show (ModuleState x) = show x
18:15:37 <shapr> the downside of that is that you're limited to Show instances in your ModuleState
18:15:45 <shapr> that's a cheesy hackish way to do it.
18:16:35 <Darius> Actually, it's the better way to work with existential quantification, now the question is is it necessary here? and what's Typeable for then?
18:16:41 <shapr> there's probably a good way to get the string out, rather than breaking the window and stealing it.
18:17:46 <shapr> well, I'm partway there
18:17:51 <shapr> lambdabot: @state blah
18:17:56 <shapr> lambdabot: @state whee
18:17:56 <lambdabot> "blah"
18:18:01 <shapr> lambdabot: @state yumm
18:18:01 <lambdabot> "blah"
18:18:50 <shapr> oh, user error
18:24:05 <shapr> lambdabot: @state blah
18:24:05 <lambdabot> "if"
18:24:13 <shapr> lambdabot: @state boo
18:24:14 <lambdabot> "blah"
18:24:24 <shapr> it's a cheesy example, but it works :-)
18:24:48 <Darius> where's the "if" come from?
18:25:13 <shapr> after a few spectacular failures, I started testing lambdabot on an unused channel first ;-)
18:25:36 <shapr> lambdabot: @listchans
18:25:36 <lambdabot> I am on these channels: ["#haskell","#joy"]
18:28:47 <shapr> hi Sonarman 
18:28:59 <Sonarman> hi
18:29:14 <shapr> looking for Haskell help?
18:29:14 <Sonarman> hey kunphuzil :)
18:29:36 <Sonarman> shapr: not really, thanks though
18:29:49 <shapr> ok
18:30:55 <Darius> ack!, my stripArb doesn't make any sense anyways...
18:32:37 <Darius> Okay! I did it.
18:32:46 <shapr> you did it??
18:32:51 * shapr jumps
18:32:56 <shapr> what is it?
18:32:57 <Darius> data Arb = forall a. (Typeablea) => Arb a
18:33:02 <Darius> let t = Arb "hi"
18:33:12 <Darius> let stripArb (Arb x) = toDyn x
18:33:30 <Darius> putStr $ fromJust $ fromDynamic $ stripArb t
18:33:36 <Darius> ==> Hi
18:33:39 <shapr> coool!
18:33:40 <Darius> er hi :P
18:33:47 * shapr tries that
18:34:23 <kunphuzil> Sonarman: Hey. Are you going to learn Haskell too?
18:34:32 <shapr> yes, Haskell is good.
18:34:35 <Sonarman> kunphuzil: yep :)
18:34:38 <shapr> it builds character.
18:34:51 * shapr has 18/00 strength
18:34:55 <Sonarman> it's also rich in vitamin c
18:35:01 <kunphuzil> Sonarman: Cool. :)
18:35:10 <shapr> oh well.
18:35:12 <shapr> never mind then :-P
18:35:18 <shapr> Vitamin C = Code
18:35:21 <kunphuzil> Heh.
18:35:33 <kunphuzil> Hmm, I think this interpreter is only GUI.. :/
18:35:36 <shapr> I must be sleepy
18:35:47 <shapr> data Vitamin a = 
18:36:40 <Riastradh> newtype Vitamin = Vitamin Char   -- vitamins come in characters, so that's all you need, really.
18:36:48 <shapr> oh yes!
18:36:51 <shapr> that's right
18:36:53 <shapr> thanks
18:37:08 * shapr wonders about B Complex
18:37:14 <Riastradh> B Complex?
18:37:32 <shapr> bComplex :: [Vitamin]
18:37:44 <Riastradh> What is 'B Complex,' though?
18:38:11 <shapr> b6 b12 and some others
18:38:24 <shapr> I think riboflavin and niacin are two of them.
18:38:38 <Riastradh> Ah, the vitamins can have numbers, too?
18:39:23 <Riastradh> In that case:   data Vitamin = Vitamin Char Number
18:40:32 <shapr> bComplex = map (curry Vitamin) [('b',12),('b',6),('b',2)]
18:40:44 <shapr> curried vitamins, mm
18:41:20 <shapr> lambdabot: @state vitamin
18:41:24 <shapr> lambdabot: @state curry
18:41:25 <lambdabot> vitamin
18:41:30 <shapr> lambdabot: @state sugar
18:41:31 <lambdabot> curry
18:41:31 <Riastradh> What does @state do?
18:41:43 <Riastradh> Returns the previous thing that you said after @state?
18:41:57 <Riastradh> lambdabot: @state foobar
18:41:57 <lambdabot> sugar
18:42:01 <Riastradh> Apparently.
18:42:17 <shapr> Riastradh: it's demonstration module, Pseudonym told me how I could do per module state that's saved in the IRCRWState StateT
18:42:19 <Riastradh> Is there any point to it other than to play with state monads or something?
18:42:36 <shapr> Riastradh: yes, it means that I can now write a fortune plugin
18:42:45 <kunphuzil> Hm.. My WUSB Adaptor sucks :( It always overheats (as you can see by all my joins and quits).
18:42:46 <shapr> and I can stick the database connection for @fact into that also
18:42:51 <shapr> Darius: thanks much :-)
18:43:02 * kawfee bounces
18:43:10 * shapr boings
18:43:20 * Riastradh sproings
18:43:38 * kunphuzil sprounces ? ;)
18:43:47 <Riastradh> Sure, why not?
18:44:02 * Riastradh sprouts
18:45:17 <shapr> ok, StateModule is now in lambdabot CVS
18:45:39 <shapr> http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/lambdabot/StateModule.hs
18:45:51 <Pseudonym> Woohoo and stuff.
18:46:04 <shapr> hii Pseudonym!
18:46:11 <shapr> it worksss!
18:46:36 <shapr> for some reason, lambdabot development doesn't seem to take very long.
18:46:46 <Riastradh> Well, duh: it's in Haskell.
18:46:49 * shapr grins
18:47:50 <shapr> tomorrow (or whenever I get another chunk of time) I'll make the database connection persistent 
18:48:02 <shapr> and now I have a place to stick my RNG, so I can write a fortune plugin
18:48:16 * Riastradh curses at sf.net for being so slow.
18:48:24 <Pseudonym> One thing I might look into, if I get a chance, is eliminating one of the state transformer layers.
18:48:43 <Pseudonym> We've got IO underneath, so you can get R/W state by putting IORefs in read-only state.
18:48:55 <Pseudonym> The ref doesn't change, only what it points to.
18:49:12 <Riastradh> Why is sf.net so horrible?  Argh!
18:49:29 <shapr> I think it's because va linux is running out of cash
18:49:46 <Riastradh> va linux?
18:49:53 <shapr> the guys who own sf.net
18:49:58 <shapr> I think?
18:50:08 <Pseudonym> It's VA Software now.
18:50:10 <Riastradh> Is there any chance of haskell-libs being moved to a different CVS repository?
18:51:28 <Pseudonym> We could move it onto savannah.
18:51:36 <Pseudonym> http://savannah.nongnu.org/
18:52:24 <Pseudonym> It's kinda beta, but it's not sourceforge.
18:53:02 <shapr> would nightly tarballs be sufficient?
18:53:08 <shapr> er, nightly cvs tarballs?
18:54:07 <Riastradh> I haven't found savannah to be that good either when trying to acquire sunterlib, but maybe it's better than sf.net (which isn't saying much).
18:58:34 <shapr> I could host a cvs repo on my gateway box
18:58:54 <shapr> lambdabot: @state wiggy
18:58:54 <lambdabot> thinkso
18:59:02 * shapr bounces happily
18:59:06 <shapr> yay, another plugin
18:59:18 <Riastradh> Don't you ever get exhausted from bouncing so much, shapr?
18:59:39 <shapr> no, but I do have large leg muscles.
19:01:40 <Pseudonym> And a high ceiling, apparently.
19:01:52 <shapr> ok, everything is checked in and the latest lambdabot is what's now playing
19:01:56 <shapr> and it's 4am
19:02:06 <Pseudonym> lambdabot: @fact sleep
19:02:07 <lambdabot> Nothing
19:02:09 <Riastradh> It probably wasn't very high at first, Pseudonym.  And by now it's probably rather...bumpy.
19:02:10 <shapr> heh
19:02:11 <shapr> fitting
19:02:45 <shapr> my woman does sometimes tell me to either stop fidgeting or go do exercises
19:03:30 <Riastradh> I was under the impression you fidgeted so much that you didn't need any exercises.
19:03:32 <shapr> I wonder if I should announce the latest table of contents of haskell-libs on libraries@haskell.org
19:03:54 <shapr> Maybe Tomorrow
19:04:11 <shapr> tomorrow :: Maybe Announcement
19:04:33 <shapr> sleep time, g'nite folks
19:04:48 <Riastradh> Vale!
19:04:54 <Pseudonym> Night.
19:05:00 * Pseudonym mailed the guy who wrote the LFT library
19:05:10 <Pseudonym> Unfortunately his code has no licence attached.
19:05:18 <Pseudonym> So I don't know if I can check it in yet.
