00:00:19 <dennisb> then when you give it the first two arguments you get back the \z function
00:00:56 <danols> yeah but add x y = x+y will work with 5 6 1
00:01:00 <dennisb> no
00:01:03 <danols> so you still are confusing me
00:01:15 <dennisb> it will not work with: add 5 6 1
00:01:28 <dennisb> because that would be the same as to write (5+6) 1
00:01:53 <dennisb> add takes the first two arguments and return 5+6 (or 11 if you evaluate it)
00:02:05 <dennisb> then you try to use that as a function by calling it with argument 1
00:02:16 <dennisb> it does not work
00:02:36 <dennisb> had (add 5 6) returned a function then it would have worked
00:02:37 <danols> hmmm why the hell was I under the impression it would work
00:02:46 <danols> hold on
00:02:58 <dennisb> add x y = \z -> x+y+z
00:03:05 <dennisb> that one you can call with add 5 6 1
00:04:17 <danols> that makes sense , jesus why was I under the impression that add x y = x+y would work for more than two parameters
00:04:26 <danols> where is that damn book
00:04:37 <dennisb> this is the functional part of haskell, we work with functions like any other values, and pass them around just like most people pass around integers in other languages
00:06:12 <dennisb> danols: hard to know why you tought so, but there is no way it works so you just have to accept it :-)
00:06:50 <dennisb> if you try it you will get an type error
00:07:40 <dennisb> the result of add 5 6 is an Integer, and you try to use it as a function so it would say something like: Type error, found Int expected Int->Int
00:08:48 <dennisb> something like that would be the error if you try "add 5 6 1", excpet that add actually work woth not only Int but also other kinds of numbers
00:09:23 * dennisb runs to the shower, have to get to work today also!
00:09:37 <danols> no no this is GOOD
00:09:49 <danols> it is so much clearer now that I know what I thought is not correct
00:09:51 <danols> thanjk you
00:09:58 <danols> i probpably just missread the book
00:10:04 <dennisb> no problem
00:10:14 <danols> translate :: [DicWord] -> Sentance -> Int -> String
00:10:14 <danols> translate dic [] lang =	""
00:10:14 <danols> translate dic (sen:sens) lang 
00:10:14 <danols> 	| lang == 1 = toOtherLang (findWord sen 1) ++ translate dic (sens) lang
00:10:14 <danols> 	| lang == 2 = toOtherLang (findWord sen 2) ++ translate dic (sens) lang
00:10:14 <danols> 	| otherwise error "Incorrect Language Selection"
00:10:18 <danols> syntax error here how come ?
00:10:26 <danols> it expects } at the end or something
00:10:32 <dennisb> otherwise =
00:10:38 <danols> ohhh yeah :)
00:10:39 <danols> so tired
00:10:40 <danols> goodnight
00:11:10 <dennisb> it's morning here, i'm not tired at all!
00:11:17 <danols> hahah it's 3 am here
00:11:57 <Cryptor> is there a haskell compiler that I might be able to compile within 30megs of space on a shell account, which I don't have root access to?
00:18:56 <dennisb> Cryptor: not ghc at least
00:19:11 <dennisb> maybe you can find a precompiled version of ghc
00:20:18 <dennisb> I've never compiled nhc but it might work. It's know for being small and fast
00:36:22 <Cryptor> dennisb: I should of mentioned, its on a SunOS sparc.
02:16:24 <debug> hm
02:41:16 <Janni> peace!
03:02:45 <shapr> yay
03:03:02 <systems> hah, the learning page is a 404
03:03:13 <systems> yay!! wussup with you shapr
03:05:10 <shapr> I'm starting a company with two other people, we just got our new logo
03:05:13 * shapr bounces happily
03:06:32 <debug> :)
03:17:07 <Arnia> Oooh :)
03:25:34 <shapr> new logo --> http://kungens.kemi.fi/~shae/webwitcheslogo.jpg
03:30:34 <Arnia> Will look as soon as the uni network's webcache comes back
03:31:56 <shapr> :-)
03:34:47 <Arnia> Cool logo :)
03:35:00 <shapr> yay!
03:35:03 * shapr bounces happily
03:35:49 * Arnia likes
03:41:32 <shapr> I want to write some open source software for my new company in Haskell
03:47:06 <Janni> do you have s.th. special in mind?
03:47:08 <Arnia> What sort of software/
03:48:12 <shapr> I was thinking of some e-learning stuff
03:48:49 <shapr> write software to teach people better via the internet
03:49:35 <shapr> I know a lot of companies that are coming up with custom software to make online courses
03:55:21 <debug> a guy who's very much into haskell told be something about "timber", a new language. has anyone heard of it? (google doesn't find much)
04:07:17 <shapr> I think I've heard of it
04:07:41 <shapr> http://www.tt.luth.se/staff/nordland/TimberCourse/
04:07:59 <shapr> it's a derivative of O'Haskell
04:08:04 <shapr> I should tell pseiko about that 
04:20:59 <shapr> I'd like to come up with some sort of open-source real-world usable application that would put Haskell 'on the map'
04:21:02 <shapr> like Zope did for Python
04:27:32 <debug> hm
04:28:16 <shapr> the only one I could do myself would be an online e-learning platform
04:28:57 <shapr> debug: hey, did you see Pseudonym was hacking on your raytracer?
04:29:58 <debug> no?
04:30:08 <debug> hey, forget it, the tracer was just a quick hack
04:30:12 <debug> :)
04:30:41 <shapr> he said he changed the reflectance model, and used a pixel filter
04:30:43 <debug> it was just a test to see if I could write one in just one page of haskell code. it is possible in C.
04:30:45 <shapr> whatever that means :-)
04:30:48 <debug> ok
04:31:07 <shapr> he said he'd send me the code
04:31:12 <shapr> I wonder if he did
04:31:14 <shapr> I can't find it...
04:31:44 <shapr> debug: are you looking for something like O'Haskell?
04:31:49 <shapr> or specifically Timber?
04:34:10 <debug> I'm not looking for anything, I just wanted to check it out
04:34:19 <debug> :)
04:34:50 <shapr> ok
04:35:25 <shapr> ok, let's see if I can make this command parser work now that I have the secret ingredient...
04:35:53 <shapr> debug: ska du går till ICFP i Uppsala?
04:36:07 <shapr> er
04:36:08 <shapr> oops
04:36:12 <shapr> ska du gå
04:36:33 <shapr> hi mgoetze 
04:37:14 <mgoetze> hi shapr
04:37:20 <shapr> wassup?
04:37:21 * mgoetze bounces big-time!
04:37:37 <mgoetze> after a year-long odyssey, i finally have internet access at home!
04:37:39 <shapr> yay!
04:37:40 <debug> icfp?
04:37:51 <shapr> debug: international conference on functional programming
04:38:02 <debug> no, I'm not really into functional programming
04:38:07 <shapr> oh, ok
04:38:09 <debug> :)
04:38:12 <shapr> tyvarr
04:38:30 <shapr> jag ska traffa många människor i Uppsala
04:38:35 <debug> ok
04:39:20 <shapr> jag har studerat svenska tre månader sedan. svenska är kul.
04:39:24 <debug> eller alltså, genom att kombinera olika genrer av programmeringsstil så skriver man bättre kod såklart, så såsätt är funktionell programmering värdefullt, men jag är inte helfrälst i "rena" funktionella språk
04:39:35 <debug> ojoj, då har du lärt dig snabbt :)
04:39:47 * shapr grins
04:41:08 <shapr> debug: I saw some notes on your website about a kernel
04:41:18 <debug> http://193.11.248.54/blog/new_lang.html
04:41:19 <shapr> microkernel specifically
04:41:21 <debug> (in swedish)
04:41:29 <debug> yes, I've not worked on the kernel since december :(
04:41:30 <shapr> cool, more practice for me :-)
04:41:41 <debug> the new language would have "alternative types"
04:41:57 <debug> like, the expression     if b then 1 else 1.0   would have the type  int|double
04:42:23 <debug> it's just thoughts so far.
04:44:18 <debug> expressions like  a; b; c  would evaluate all of a b and c but only return c
04:44:28 <debug> a,b,c  however would return a tuple of a, b, and c
04:46:26 <shapr> ok, two questions.. whats såsätt, and what's helfrälst ?
04:46:36 <debug> helfrälst = totally sold out
04:46:38 <shapr> ah
04:47:05 <debug> I should have written "så på så sätt" = "so because of that"
04:47:12 <shapr> I see
04:47:25 <debug> I think.
04:47:31 <debug> :)
04:47:42 <shapr> ok, now I understand what you said.
04:48:12 <shapr> three months is enough to learn the structure of swedish, but not yet enough vocabulary
04:48:12 <debug> check the 99 bottles code at the end of the new_lang.html page
04:48:32 <debug> vocabulary is the most important part in mastering a language, I think
04:48:59 <shapr> jag har bott i Boden fyra månader sedan
04:49:25 <debug> var bor du nu då?
04:49:30 <shapr> I'd argue that structure is most important
04:49:36 <shapr> er
04:49:41 <shapr> maybe I said that incorrectly
04:49:46 <shapr> jag bor i Boden.
04:49:51 <debug> haha, ok
04:50:00 <debug> "jag bor i Boden sedan fyra månader"
04:50:06 <shapr> ah, yes
04:50:11 <debug> otherwise it sounds like "I lived in boden four months [ago]"
04:50:20 <shapr> right, I make that mistake too often :-)
04:50:35 <shapr> I keep treating sedan as "since"
04:50:37 * debug studied Russian one semester
04:50:43 <shapr> neat, did you like it?
04:50:48 <debug> yes
04:50:59 <debug> AAAAARG! I have to go to school
04:51:03 <shapr> have fun
04:51:05 <shapr> cya later.
04:51:05 * debug had a lecture at 10
04:51:10 <debug> it's almost 14 now
04:51:10 <shapr> oops
04:51:18 <debug> operating systems class at 15
04:51:38 <shapr> du måste gå!
04:51:47 <debug> ja
04:51:57 <debug> where were you born?
04:52:05 <shapr> Selma, Alabama
04:52:10 <shapr> och du?
04:52:18 <debug> I'm a native Swedish prick.
04:52:21 <shapr> heh
04:52:22 <debug> :)
04:52:34 <shapr> I lived in finland three years before this.
04:52:50 <shapr> ten minutes walk from haparanda
04:52:57 <debug> but you didn't learn finnish in 3 months, I presume
04:53:05 <shapr> no, finnish is difficult.
04:53:07 <debug> ehe
04:53:08 <debug> hehe
04:53:17 <shapr> agglutinative languages blow my mind
04:53:35 <shapr> I can do the basic day-to-day stuff in finnish
04:53:37 <debug> I don't know what agglutinative is, but it sure sounds like it would blow my mind too
04:53:37 <shapr> but not much more
04:53:50 <debug> agglutinative = without glues?
04:53:51 <shapr> it's sort of like unresolved partial application :-)
04:53:56 <debug> heheh, ok
04:54:00 <shapr> nah, more like with lots of extra glue
04:54:05 <debug> hm
04:54:40 <shapr> http://c2.com/cgi-bin/wiki?AgglutinativeLanguage
04:54:49 <shapr> sauna = bast
04:55:07 <shapr> my sauna = saunani
04:55:14 <shapr> at the sauna = saunassa
04:55:23 <shapr> at my sauna = saunassani
04:55:33 <shapr> I always get the order of the endings wrong
04:55:40 <shapr> so it might be the other way around
04:55:58 <shapr> prepositions stick to the end of words rather than being separate
04:56:38 <shapr> iirc, there are seventeen of those word endings, and they can be combined to form 144 or so different combinations on a single word
04:56:52 <debug> hm
04:57:00 <debug> russian only has 6 or so
04:57:24 <shapr> only fifteen of those endings are daily use stuff
04:57:29 <debug> ok
04:57:36 <debug> anyway I'm off. see you later
04:57:39 <shapr> cya
04:57:40 * debug disappears
04:58:20 <mgoetze> reboot, brb
05:06:22 --- topic: set to '["mo' nads than you", "We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/", "New nhc98-1.16 - http://www.haskell.org/nhc98", "New Learning Haskell page - http://www.haskell.org/learning.html", "GUI Demos - http://repetae.net/john/computer/haskell/gui/", "Order Haskell 98 Report in Hardcopy - http://titles.cambridge.org/catalogue.asp?isbn=0521826144", "GHC 5.04.3 released!"]' by shapr
06:21:00 <Smerdyakov> Hm... if a professor has been at a school for 22 years and is only an associate professor, is that a Bad Sign?
06:21:22 <shapr> maybe he has better things to do instead of politics
06:21:45 <Smerdyakov> Or maybe he sux!!
06:21:57 <Smerdyakov> I'm figuring out whom I want to ask to meet at Cornell when I visit.
06:22:46 <shapr> I've learned that politics is usually required for promotion
06:23:14 <shapr> some of the best programmers don't want to be managers
06:23:48 <Smerdyakov> Being a full professor is not being a manager, as far as I can tell.
06:23:58 <Smerdyakov> You have to make a case that you've been successful in research.
06:24:09 <Smerdyakov> And teaching, emphasized more or less depending on the case
06:24:18 <Smerdyakov> case->place
06:53:06 <SyntaxPolice> morning all.
07:01:02 <mgoetze> hi SyntaxPolice 
07:05:15 <shapr> hi SyntaxPolice 
07:48:33 <SyntaxPolice> mgoetze: shapr: how's it going?
07:49:00 <shapr> I'm trying to get lambdabot to call its modules
07:49:04 <shapr> what's up with you?
07:49:31 <SyntaxPolice> have to write some documentation, still testing & debugging project.
07:50:10 <shapr> sounds like you've adjusted to developing with Haskell 
07:50:44 <shapr> have you tried buddha?
07:52:41 <SyntaxPolice> shapr: no. remind me please what buddah is?
07:53:10 <shapr> http://www.cs.mu.oz.au/~bjpop/buddha/
07:53:15 <shapr> it's a declarative debugger
07:53:23 <shapr> I haven't tried it either
07:53:36 <shapr> what tools do you use now? 
07:58:12 <shapr> hi Marvin-- 
07:58:25 <Marvin--> afternoon
07:58:41 <SyntaxPolice> shapr: the problem is that I'm using some extentions, like MPTypeClasses, and Hat doesn't work w/ them. Neither does Buddah if I remember correctly.
07:58:47 <shapr> oh
07:58:49 <shapr> that sucks
07:58:56 <SyntaxPolice> Hat is working on it.
07:59:21 <SyntaxPolice> yeah, I just looked at buddah's page, and seem to remember it now. it also doesn't work w/ MPTC
07:59:40 <SyntaxPolice> so I use trace, hunit, and my brain.
08:00:01 <shapr> that last one is the best tool
08:00:11 <SyntaxPolice> ha!
08:00:22 <shapr> what about quickcheck?
08:00:45 <SyntaxPolice> I haven't really played w/ QC yet.  it seems like hunit has basically the same abilities.
08:00:54 <SyntaxPolice> I think I will switch to QC eventually since it comes w/ ghc :)
08:01:03 <shapr> they're different critters
08:01:28 <shapr> with QC you give rules for generating input to your code, and assert that for any input, your code should behave a certain way
08:01:37 <shapr> so QC generates random input data
08:02:01 <shapr> prop_RevApp :: [Int] -> [Int] -> Bool
08:02:01 <shapr> prop_RevApp xs ys = 
08:02:01 <shapr>     reverse (xs ++ ys) == reverse ys ++ reverse xs
08:02:10 <SyntaxPolice> hm. that would be nice.  one problem I have w/ hmake and my project is that generating input is annoying and difficult.
08:02:19 <SyntaxPolice> s/hmake/hunit
08:02:20 <shapr> right
08:02:35 <shapr> *ProtoQuickCheck> quickCheck prop_RevApp
08:02:41 <shapr> OK, passed 100 tests.
08:02:55 <shapr> you can also do verboseCheck to see the randomly generated output
08:02:58 <Marvin--> well, prop_RevApp is all well and good, but for more complicated programs you basically always have to write custom test data generators
08:03:10 <shapr> yup, I agree.
08:03:32 <Marvin--> or at least you need clever usage of ==> to cut down on the number of trivial tests you do
08:03:37 <shapr> that's true
08:04:01 * SyntaxPolice looks into quickcheck
08:04:08 <shapr> the frequency changer and coarbitrary method are important there also
08:05:03 <shapr> SyntaxPolice: here are the QC tests we wrote for the 2002 ICFP #haskell entry: http://kungens.kemi.fi/~shae/src/haskell/Tests.hs
08:05:21 <shapr> they generate random instances of Board, Terrain, etc
08:05:42 <mgoetze> SyntaxPolice: good, now that i figured out why my internet connection stopped working after dist-upgrade :)
08:06:37 <shapr> SyntaxPolice: btw, if the quickcheck test running script on the website doesn't work for you, it's because I broke it :-/
08:06:41 <Marvin--> heh
08:06:48 <shapr> Marvin--: speaking of which...
08:06:57 <Marvin--> shapr: have you talked to John about it?
08:07:01 <shapr> no, still not
08:07:13 <shapr> the urgency dropped from my project yesterday
08:07:15 <shapr> so now is the time
08:07:26 <shapr> where's your really smart unlit function?
08:07:49 <Marvin--> how so? I'd prefer mailing it myself
08:07:54 <shapr> oh, ok
08:08:14 <shapr> the current script only needs to change ./ghci to hugs
08:08:53 <Marvin--> looking at Tests.hs, why both an instance Arbitrary Char and the elem c [...]?
08:10:10 * shapr looks
08:10:21 * esap blinks.
08:10:27 * shapr boings
08:10:29 * opet sways
08:10:37 <shapr> Good Day, Mr Pulkinnen.
08:10:54 <esap> Good evening.
08:11:15 <esap> what's up?
08:11:15 <shapr> oh, I'm in a different time zone, right...
08:11:37 <shapr> I've been trying to figure out how to get lambdabot to call its modules
08:11:41 <shapr> what's up with you?
08:12:01 <shapr> Marvin--: truly, it looks like that elem is unneeded
08:12:36 <esap> hmm.. not much happening, should be doing some unification algorithm stuff again.
08:13:39 <esap> Been thinking about scopes and variables lately. Causing some trouble.
08:14:39 <Marvin--> shapr: though in that case, I'd write  prop_ReadTerrain = forAll (elements ".~#@") $ \c -> ...
08:17:20 <SyntaxPolice> mgoetze: why did your internet connection stop working?
08:17:57 <SyntaxPolice> oh. You were answering "how are you" I get it. heh
08:18:02 <Marvin--> heh, every time I've had a meeting with Koen, my inbox is full of mails with URLs for subjects
08:18:02 <SyntaxPolice> I thought I was somehow to blame...
08:18:18 <mgoetze> SyntaxPolice: because the new /etc/hotplug stuff messed up the pppoed
08:21:20 <shapr> Marvin--: I worked on those tests for four hours or so, and then Heffalump worked on them for a few hours
08:21:43 <Marvin--> heh
08:22:04 <shapr> if they suck, it's probably because I was a complete Haskell weenie at the time :-)
08:25:43 <shapr> I hope to be able to contribute more this time
08:28:34 <Marvin--> "WARNING: This game contains violence and may cause excessive noise or involuntary urination."
08:28:52 <shapr> that's a new one.
08:29:11 <Marvin--> SJGames :)
08:29:26 <shapr> heh
08:29:26 <shapr> cool
08:29:27 <Marvin--> I bought Frag, thought it a fitting birthday present for a friend of mine
08:29:57 <Marvin--> "For 2-6 players. You'll need many, many 6-sided dice."
08:30:05 <shapr> sounds like fun
08:30:10 * shapr looks for thewebsite
08:30:11 <Marvin--> it's hilarious :-)
08:30:16 <Marvin--> www.sjgames.com iirc
08:31:21 <shapr> http://www.sjgames.com/frag/
08:31:30 <shapr> "if it moves, shoot it"
08:31:31 * shapr laughs
08:31:34 <Marvin--> :)
08:32:02 <Marvin--> "Computer Games Are Mindless And Violent. This Is Even Better."
09:36:46 <Janni> re
09:46:22 <shapr> yay!
09:46:29 <shapr> I can call plugin modules!
09:46:31 * shapr dances happily
09:46:40 <shapr> hi dash 
09:47:18 <dash> shapr: your evil static-typing mind control powers have sucked me back in again
09:47:21 <shapr> w00
09:47:32 <dash> shapr: have you read this paper on modular monadic action semantics?
09:47:34 * shapr turns off the mind control lasers before they burn out
09:47:42 <shapr> dash: probably not, which one?
09:48:42 <dash> http://www.cl.cam.ac.uk/users/kw217/research/msc/thesis/
09:49:35 <shapr> haven't read it, it looks cool
09:49:55 <dash> it may get me back to writing haskell code
09:49:58 <dash> grrrrr :)
09:50:00 <shapr> yay!
09:50:12 <shapr> wanna work on this irc bot with me? ;-)
09:50:19 <shapr> hey, did you get my /msg about HScheme?
09:50:19 <dash> nah
09:50:22 <dash> yes
09:50:25 <dash> their code is a mess
09:50:30 <shapr> well, tell him
09:50:39 <dash> hmm?
09:50:52 <shapr> it's all written by one guy
09:51:10 <dash> oh
09:51:15 <shapr> HScheme, HBase, Truth, and some other sf.net projects in Haskell have all been written by Ashley Yakeley
09:51:18 <shapr> of semantic.org
09:51:21 <dash> well it's not bad code afaict
09:51:31 <dash> just not organized in the fashion i'm looking for
09:51:44 <dash> he's writing for speed and simplicity
09:51:52 <dash> i want clarity and completeness :)
09:51:56 <shapr> ah
09:52:09 <shapr> maybe you could hack his code into what you want?
09:52:17 <dash> not really
09:52:24 <dash> i want to reify storage and environments and all that
09:52:29 <dash> not a practical interpreter
09:52:46 <dash> something i can attempt to prove certain properties of
09:52:58 <dash> so this MMAS stuff may be the ticket
09:53:20 <dash> because it looks like they use monads to separate various semantic bits
09:53:28 <dash> no clue how it works yet :)
09:56:03 <shapr> I might read that paper this weekend
09:56:45 <dash> anyone played with this Language Prototyping System?
09:56:48 <dash> http://lsi.uniovi.es/~labra/LPS/LPS.html
09:57:01 <shapr> I've tried to play with it, but I don't understand it.
09:57:10 <dash> apparently it's related
09:57:42 <dash> when papers start using words like "catamorphisms" in their titles i get a little nervous
09:58:19 <shapr> catamorphism just means "something that contracts"
09:58:28 <shapr> cata -> catastrophic
09:58:37 <shapr> for example, foldr is the ultimate catamorphism
09:58:44 <dash> heh heh
09:58:46 <shapr> foldr1 (+) [1,2,3,4,5]
09:59:07 <dash> shapr: so anyway, in the abstract, it says they implement a language then add a call/cc monad-thingy
09:59:20 <dash> which strikes me as a little bizarre, to say the least :)
09:59:29 <shapr> to add call-cc afterwards?
09:59:37 <dash> yes
09:59:48 <shapr> you've piqued my interest
10:00:05 <shapr> shh, I'm writing fun code ;-)
10:00:12 <dash> irc bots are not fun code
10:00:14 <dash> everybody has one
10:00:19 <shapr> I've never written one before.
10:00:19 <dash> ;)
10:00:25 <dash> me neither :)
10:00:35 <shapr> lambdabot: @listmodules
10:00:35 <lambdabot> I have the following modules installed: ["hello_module"]
10:00:40 <shapr> lambdabot: @hello_module
10:00:41 <lambdabot> Hello world.
10:00:42 <shapr> yay!
10:01:16 <shapr> real pluggable modules! w00!
10:01:42 <shapr> I bet I could write a quick factoid module with the new postgresql stuff in htoolkit
10:01:43 <Janni> Janni: @stupid_shit_module
10:01:47 <Janni> mooooooooooooooooooo!
10:02:02 <shapr> Janni: hey, you wanna write a module for lambdabot?
10:02:17 <Janni> shapr: in Haskell?
10:02:20 <shapr> sure
10:02:29 <shapr> lambdabot is written in haskell.
10:03:09 <Janni> yea, maybe, but I have other things to do at the moment.
10:03:11 <shapr> ok
10:03:39 <shapr> dash: I didn't write this one either, I'm just plugging in small bits
10:04:51 <shapr> hi systems
10:04:57 <shapr> wassup?
10:05:05 <systems> :) fine 
10:05:11 <systems> you wussup
10:05:19 <shapr> workin on an irc 'bot
10:05:38 <systems> :) good luck
10:05:46 <shapr> lambdabot: @hello_module
10:05:46 <lambdabot> Hello world.
10:05:48 <shapr> yay
10:06:18 <systems> hehe
10:06:25 <systems> thats your bot 
10:06:28 <shapr> yup
10:06:39 <shapr> written by Pseudonym, I'm just extending it some.
10:06:44 <systems> hello lambdabot
10:06:52 <shapr> lambdabot: y0
10:06:53 <lambdabot> Sorry, I don't understand.
10:06:58 <shapr> lambdabot: @y0
10:06:59 <lambdabot> Sorry, I don't know that command.
10:07:28 <systems> pesudonym ? what is that
10:07:43 <shapr> it's the ircnickname of someone who shows up here on #haskell
10:08:08 <systems> aha, made in haskell i bet
10:08:12 <shapr> yes!
10:08:18 * Marvin-- leaves for a birthday party
10:08:24 <shapr> the source is available on sf.net/projects/haskell-libs/
10:10:38 <dash> shapr: so anyway, if you didn't catch it earlier, the reason i'm back into haskell is because i want to write a lisp interpreter with some novel semantics
10:10:53 <dash> shapr: and i have this vague hope that writing it in haskell will allow me to reason about its behaviour
10:11:35 <dash> (specifically, i want to add linear objects)
10:12:13 * shapr lags horribly
10:12:13 <shapr> dash: cool!
10:12:13 <shapr> I think referential transparency makes it easier to reason about programs
10:12:56 <dash> well, referential transparency is easy
10:13:44 <dash> if that was enough, i'd just use lisp and be done with it :)
10:16:00 <shapr> monads?
10:17:26 <dash> well, apparently (i dont know how yet) you can do modular monadic semantics in scheme, too
10:17:38 <dash> as Espinosa did in his paper "Semantic Lego"
10:18:06 <shapr> yah, I've some of Espinosa's work
10:18:10 <shapr> er "read"
10:20:58 <dash> so in other words, this vague hope is totally unfounded
10:21:01 <dash> we'll see what happens
10:24:04 <shapr> iirc, Espinosa did 'stratified monads' which were one of three flavors of monad transformers at the time
10:24:46 <shapr> the two other main monad transformer guys (Mark Jones might have been one of them) found a way to fold his ideas into a larger structure of monad transformers
10:25:01 <shapr> at the time, stratified monads couldn't be implemented in Haskell, I forget why.
10:26:22 <dash> well in this paper they aren't either
10:26:25 <dash> they use gofer
10:26:43 <dash> because it had constructor classes
10:38:12 <shapr> hi dark 
10:38:17 <dark> Hello :)
10:38:20 <shapr> what's up?
10:39:09 <dark> Nothing much.  I'm recovering from a trip to Stockholm.  And I'm following the news for a change.
10:39:15 <shapr> ah
10:44:56 <dash> have things changed since this paper was written?-)
10:45:03 <dash> i assume so, since gofer is unmaintained
10:45:31 <shapr> you may want to check citeseer and see which papers reference that one
10:49:40 <dash> true that
11:08:28 * shapr bounces happily
11:09:25 <dash> zoorg
11:09:32 <shapr> eh?
11:09:39 * dash just read the description of the state monad transformer
11:09:55 <dash> i think understand monads, but this is making my head spin ;)
11:09:59 <shapr> oh
11:14:32 <shapr> hm, I think I just found a bug in haskell-mode
11:15:08 <mgoetze|away> shapr: yeah, emacs sux0rs ;)
11:15:16 <shapr> :-P
11:34:31 <shapr> dash: most of the time I'm not sure if I really understand monads
11:39:29 <shapr> I'm having one of those unconvinced moments right now
12:16:01 <danols> what can you do with new data types that you can't do with type synonyms ? what's the adventage of using data types ?
12:23:45 <Igloo> You can hide the implementation details
12:28:50 <hdaume> you can give things nicer names
14:10:58 * Heffalump wonders if norpan is about
14:11:10 <andersca> he was 20 minutes ago
14:11:34 <Heffalump> he is the person with homepage     newlib_search_path=
14:11:36 <Heffalump> aargh
14:11:43 <Heffalump> he is the person with homepage http://www.dtek.chalmers.se/~d95mback/, isn't he?
14:11:51 <Smerdyakov> No.
14:11:51 <andersca> yep
14:11:56 <Smerdyakov> That's actually a very popular URL to use.
14:12:03 <Heffalump> :-p
14:12:04 <Smerdyakov> I know at least 6 people who have their home pages with that URL.
14:12:26 <Heffalump> I was googling for help with a completely non-Haskell-related problem I'm having and I found a post by him asking for help with the same issue
14:12:34 <Heffalump> so I was hoping he'd found a solution :-)
14:13:05 <Heffalump> (http://mail.gnu.org/archive/html/libtool/2001-10/msg00042.html)
14:27:48 <shapr> hiii Heffalump!
14:27:50 <shapr> ltns!
14:28:17 <Heffalump> hiya :-)
14:28:31 <shapr> what's up in your life?
14:28:58 <Heffalump> lots of stuff :-)
14:29:05 <Heffalump> FoP next week
14:29:08 <shapr> yay!
14:29:12 <shapr> still writing lots of SML?
14:29:14 <Heffalump> (who's going to be there?)
14:29:16 <Heffalump> yep
14:29:38 * hdaume will be there in spirit
14:31:03 <Smerdyakov> FoP = ?
14:31:12 <shapr> fun of programming
14:35:14 <shapr> is there any sort of automagic persistence for Haskell types?
14:35:24 <Heffalump> nope
14:35:26 <shapr> I'd like to save a FiniteMap to disk 
14:35:28 <shapr> aw shucks
14:35:44 <Heffalump> well, deriving Read and Show, I guess
14:35:44 <Smerdyakov> This is easy thing.
14:35:44 <Heffalump> but that's sick
14:35:52 <Smerdyakov> Shameful for shapr to not do it quick self!!
14:35:56 <dash> Heffalump: hmm. what's a non-sick way to do it, then?
14:36:04 <shapr> Smerdyakov: eh?
14:36:16 <shapr> oh
14:36:19 <Heffalump> there's been talk about this on the list recently, I think
14:36:23 <Smerdyakov> If you can't write a map to disk, you're a mega weenie!
14:36:35 <shapr> Smerdyakov: yes, it's an easy thing to do, but it would be even easier if I didn't have to
14:36:48 <shapr> Smerdyakov: I never claimed that I wasn't a hot dog.
14:36:55 <Smerdyakov> Easy as in one minute to write....
14:37:02 <shapr> Smerdyakov: ok, show me.
14:37:26 <shapr> I want to save and load FiniteMap to afile
14:38:13 <shapr> Smerdyakov: yes?
14:38:21 <hdaume> writeFile "foo" (show $ toList fm)
14:38:31 <hdaume> readFile "foo" >>= return . listToFM . read
14:38:49 <shapr> hdaume: you are obviously not a mega weenie ;-)
14:38:51 <Heffalump> ICK!
14:39:15 <shapr> hdaume: thanks, I'll try that
14:39:18 <shapr> I can always clean it up later.
14:39:28 <shapr> it's either this or use Postgres
14:39:47 <hdaume> :)
14:43:51 <hdaume> shapr: you could also use my modified FiniteMap implementation which supports Binary and Show natively, so you don't have to go through strings (unfortunately, i haven't written Read for it)....www.isi.edu/~hdaume/haskell/FiniteMap.hs
14:44:02 <hdaume> erm,i mean through lists
14:44:49 <Heffalump> does Binary do input and output?
14:44:56 <hdaume> yes
14:45:42 <shapr> neat
14:45:54 <shapr> hi Pseudonym!
14:45:58 <Pseudonym> G'day.
14:46:03 <shapr> hey, I've been hacking on lambdabot
14:46:15 <shapr> it can call modules now
14:46:23 <Pseudonym> Cool!
14:46:27 <shapr> though it's just a quick hack
14:46:30 <shapr> not pretty
14:46:42 <shapr> I've just been trying to put together a factoid module
14:47:52 <Pseudonym> Do you prefer your Haskell raytraced pictures gamma corrected or not?
14:48:09 * shapr isn't picky
14:48:20 <Smerdyakov> I prefer them gamma incorrected.
14:49:12 <shapr> Pseudonym: http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/lambdabot/Main.hs.diff?r1=1.1&r2=1.2
14:49:16 <shapr> is that an ugly hack or what?
14:49:26 <Pseudonym> http://mds.rmit.edu.au/~ajb/rt.png
14:49:55 <shapr> wow, coool
14:50:01 <Pseudonym> shapr: That's cool.
14:50:01 <shapr> yes, you're right
14:50:05 <Pseudonym> XP and all that.
14:50:08 <shapr> the reflections are much improved in that version
14:50:12 * Pseudonym nods
14:50:20 <Pseudonym> I'll check this in.
14:50:26 <shapr> spiffy
14:50:35 <Pseudonym> You know what's changed?
14:50:46 <Pseudonym> Real dielectric surfaces reflect more at grazing angles.
14:50:46 <shapr> nah, I don't really know how it worked in the first place :-)
14:50:51 <shapr> debug wrote the code :-)
14:51:03 <shapr> oh, interesting
14:51:09 <Pseudonym> So, for example, if you look straight at your monitor, you don't get as much reflection from the environment as when you look at it from the side.
14:51:17 <shapr> good point
14:51:38 <shapr> I have four steel ball one-third kilo bearings that I use for contact juggling
14:52:04 <shapr> I've seen that a lot
14:52:11 <Pseudonym> There you go. :-)
14:52:16 <Igloo> Oooo, MPEG! MPEG!
14:52:58 <shapr> Igloo: of contact juggling?
14:53:11 <Igloo> Yup yup
14:53:23 <shapr> I'll see what I can do ;-)
14:53:32 <shapr> probably easier to wait till ICFP
14:53:35 <shapr> I'll bring them with me.
14:53:40 <Igloo> Ah, yes  :-)
14:53:53 * Igloo really should finish a paper for that, *sigh*
14:54:23 <Heffalump> isn't the deadline kind of close?
14:54:44 <Igloo> I mean Haskell Workshop
14:54:50 <Heffalump> ah, yeah
14:55:09 <shapr> Pseudonym: that's gorgeous, have you ever written a larger raytracer in Haskell?
14:55:30 <Pseudonym> No.
14:55:40 <Pseudonym> I don't like raytracers that much, to be honest.
14:56:01 <Pseudonym> More of a micropolygon kind of person myself.
14:56:41 <Pseudonym> Someone is writing a Reyes-based renderer in Haskell, oddly enough.
14:56:45 <Pseudonym> http://www.brunslo.com/cessen/rendercat/rendercat_news.php
14:58:25 <shapr> neat
14:59:03 <Pseudonym> This guy hangs around the rendering theory mailing list.
14:59:28 <Pseudonym> I'm kinda impressed that he's got this far.  The traditional reyes architecture is very un-functional.
14:59:53 <Pseudonym> I don't appear to have write access to haskell-libs.
15:00:04 * Pseudonym hmms
15:00:37 <Pseudonym> I think I need "Developer" role.
15:01:17 <Pseudonym> Or something.
15:01:49 <shapr> ok, I'll change it
15:02:28 <shapr> ok, try it
15:03:06 * shapr puts Pseudonym in charge of the Bug and Patch trackers ;-)
15:03:31 <mgoetze|away> yeah, always make other people responsible for things :)
15:03:54 * shapr snickers
15:05:47 <shapr> Pseudonym: works?
15:06:20 <shapr> mgoetze|away: the bug and patch trackers are empty, and have been for a long time, so it's not such a big job.
15:06:37 <Pseudonym> OK, it's in now.
15:06:40 <shapr> yay
15:06:56 <Pseudonym> Feel free.  I'll make sure they stay empty.
15:07:05 <Pseudonym> Drop... drop... drop...
15:07:21 * shapr grins
15:09:20 <Pseudonym> The concept of "privileged users" is something I haven't fully worked out yet.
15:09:24 <Pseudonym> In lambdabot.
15:09:42 <Pseudonym> The general idea is that only privileged users should be able to tell it to join and leave channels, quit etc.
15:10:03 <Pseudonym> At the moment, anyone can boss lambdabot around.
15:10:45 <shapr> yup
15:11:25 <shapr> hostmasks are the standard way of limiting access in IRC 
15:11:35 <shapr> nick!user@host
15:11:43 * Pseudonym nods
15:11:54 <Pseudonym> Though in principle, privileged users should be able to hand over privilege.
15:12:08 <Pseudonym> Or authenticate with a password if they're coming from the wrong host.
15:12:09 <shapr> as nickserv does now
15:12:11 <Pseudonym> Or something.
15:12:16 * Pseudonym nods
15:12:18 <shapr> yah
15:12:24 * Pseudonym didn't think about it too hard
15:15:14 <shapr> at the moment, I just want to get this factoid module working
15:15:17 <shapr> and saving to disk
15:15:27 <shapr> usefulness before access checking
15:15:58 <Pseudonym> That's what I thought.
15:16:12 <Pseudonym> I didn't bother with access control because it didn't do anything critical.
15:16:20 <shapr> yah, I agree
15:18:14 * shapr stares at this code.
15:18:21 <shapr> it was all so clear an hour ago.
15:19:35 <Smerdyakov> Buy more memory
15:19:58 * shapr dubs Smerdyakov court jester
15:20:18 * Igloo is thoroughly confused by strictness
15:20:28 <shapr> Igloo: you writing SML?
15:20:40 <Igloo> No, Haskell
15:21:01 <Igloo> GHC's strictness inference - I can cope when everything is just strict  :-)
15:21:09 <shapr> oh
16:18:01 <shapr> hi systems 
16:18:15 <systems> hi shapr 
16:18:36 <shapr> have any Haskell questions?
16:19:20 <systems> hehe no 
16:19:23 <shapr> ok
16:20:02 <systems> you have any questions? 
16:20:19 <shapr> not at the moment, no
16:20:56 <Pseudonym> ANyone want to say anything at all?
16:21:01 <shapr> me me!
16:21:11 <shapr> I want to say that Haskell is really great.
16:21:19 <systems> comment 
16:21:26 <shapr> I enjoy writing code in Haskell more than any other language I've used.
16:21:31 <systems> :)
16:21:39 <systems> I believe you
16:22:23 <Pseudonym> Cool.  That's something, at least.
16:22:40 * Igloo has lots of questions  :-)
16:22:53 <systems> about haskell ?
16:23:16 <Igloo> Well, about GHC really
16:23:32 <Heffalump> so what happened to the IOHCC?
16:23:55 <systems> so why aint you askin, waitin for invitation !
16:24:14 <shapr> Heffalump: two judges have finished judging
16:24:17 <shapr> we're waiting for the others
16:24:23 <Heffalump> ah
16:24:34 <Heffalump> I assumed you'd have a big meeting and decide all together
16:24:35 * Igloo plans to be done by the end of the week
16:25:05 * Pseudonym hasn't really done his judging
16:25:10 <Pseudonym> But I figured I could get it done before Igloo.
16:25:15 <shapr> heh
16:25:17 <shapr> yah, me too
16:25:22 * shapr grins
16:25:48 <Igloo> systems: If you know stuff about GHC internals, in particular strictness, then I'll ask, but bar the Simons putting in a reappearence (or maybe chilli popping up) I figured it would be a waste of time  :-)
16:26:08 <Igloo> I was expecting to feel more pressure by other people finishing, but that doesn't work if everyone else does it too  :-)
16:26:20 <Heffalump> lol
16:26:28 <shapr> we're low pressure people.
16:26:40 <Igloo> I thought only shapr had finished actually, must have missed the other one
16:27:02 <shapr> I had a lot of fun playing with the entries
19:00:15 <lament> K
19:05:21 <shapr> Y
19:05:52 <lament> S
19:05:59 <shapr> I thought we were spelling kyckling
19:06:16 <lament> i thought we were listing famous combinators!
19:06:19 <mgoetze> what's kyckling?
19:06:20 <shapr> oh
19:06:27 <shapr> mgoetze: swedish for chicken
19:06:40 <shapr> bah, I'm going to sleep
19:06:43 <shapr> I have swedish class in five hours.
19:06:49 <shapr> g'night folkes
19:06:50 <mgoetze> fine, if it pleases you.
21:09:22 <danols> if i want type Trait = a to be anything is that the syntax ? it gives me a undefined
21:14:24 <danols> anyone alive ?/
21:17:42 <danols> shtui
21:17:56 <mgoetze> all dead
21:21:27 <Pseudonym> I don't understand the questin.
21:26:57 <dennisb> danols: you can't have a type for any value
21:30:00 <danols> hmmmm 
21:30:14 <danols> well i want it to be a list of either character or int or whatever ?
21:31:58 <danols> and another question is how can I remove an element from a list ? and return the rest, filter seems not what I really need
21:33:24 <danols> wow GOT IT
21:33:28 <danols> filter is what I need :)
21:38:19 <dennisb> in a list all the elements must be of the same type
21:39:04 <dennisb> but that type can be a type with different constructors so it can contain different values
21:39:30 <dennisb> for example, there is a standard type called "Either a b" that one can use
21:40:03 <dennisb> so you can have a list with this type:  [Either Int String]
21:40:40 <dennisb> Every value in the list is now tagged with Left or Right (that's how Either is defined)
21:41:09 <dennisb> Here is a list in that type: [Left 4, Left 5, Right "Dennis", Left 42]
21:41:37 <danols> hmmmm
21:42:07 <danols> so to have a char list and int ? i would have [Either Char Int] ?
21:42:24 <danols> no hmmm
21:42:47 <danols> well i want a list of very general type, i.e. a, that will hold all Ints if needed or all Chars if needed or all functions if needed
21:42:51 <dennisb> yes
21:43:04 <dennisb> then you can use some other type instead of Either
21:43:24 <danols> that's what i maen why type Trait = a won't work ? i want it to be of any type
21:45:46 <danols> so how can I have type Trait of any time ? 
21:46:20 <dennisb> you need a type with constructors
21:46:30 <dennisb> look at the definition of Either
21:46:49 <danols> dennisb i don't think we understand eachother
21:47:00 <dennisb> http://www.haskell.org/onlinereport/standard-prelude.html#$tEither
21:47:01 <danols> i want simply type Trait = ANYSHIT 
21:47:07 <dennisb> you can not have that
21:47:26 <danols> how come ?
21:47:31 <danols> how is that illogical ?
21:47:32 <dennisb> Haskell is a strongly typed language, you can not have a value of unknown type
21:47:48 <dennisb> how do you write a function that works on any value
21:48:03 <danols> hmmmm, 
21:48:31 <danols> hmmm MAN
21:48:50 <dennisb> dynamically typed languages can check the argument to the function at runtime and throw an exception or something if it's wrong. But that is slow, haskell checks all types during compile time
21:49:07 <danols> i figured that when you said STRONGLY TYPED
21:49:14 <dennisb> it is also much safer, since you don't get a result that dies when you run it
21:49:16 <danols> now i just kind of am stuck , 
21:49:23 <danols> ture
21:52:28 <dennisb> if you want a list with Integers, characters and functions you can make it like:
21:52:49 <dennisb> [Num 3, Chr 'd', Num 33, Fun (\x -> x+2)]
21:53:23 <dennisb> but you have to define a type like Either first that has constructors Num, Chr, Fun
21:54:07 <dennisb> also it can not be any function there, it must be the same kind of functions. Otherwise you maybe can have several different constructors for Fun
21:55:22 <danols> ahhh jesus this thing is relly restricitng me
21:55:32 <danols> i need a brake and re-evaluate some things
21:55:35 <danols> thanks for the clarification
21:57:21 <dennisb> you could not have a list with any kind of value in C either. You must know what it us to use it in any way
21:58:11 <dennisb> if you have a list and you don't know if the first element is an integer or a string, you can never use that value
21:59:11 <dennisb> The constructor is just a Tag saying what kind of value it is, so that you can check it at runtime and do different things for say integers and strings
22:00:47 <dennisb> I don't believe you can use that kind of list in any language actually
22:03:01 <danols> i see so i can't even say [a] ?
22:04:00 <mgoetze> maybe if you have some constraint, like Num a => [a]?
22:04:12 <mgoetze> on second thought, don't listen to me, i have no clue :)
22:04:22 <danols> hahah same here but man am i learning
22:06:23 <danols> what's the difference between data and type synonyms ?
22:06:31 <danols> what can one do that the other can't ?
22:13:56 <danols> why is this a bad layout ?
22:13:57 <danols> genRoute :: Points -> Points
22:13:57 <danols> genRoute points = do
22:13:57 <danols> 	if points == []
22:13:57 <danols> 	  then do return []
22:13:57 <danols> 	  else do 
22:13:59 <danols> 	    point <- randomRIO (0::Int, (length points)) -- select which trait are we going to use
22:14:01 <danols> 	    rest <- genRoute (filter (/= (points !! point)) -- get the rest
22:14:03 <danols> 	    return (points !! point : rest)
22:15:22 <dennisb> danols: you can have functions that takes an [a] as input, but that it can not use the elements in the list. For example length::[a]->Int
22:15:49 <danols> HMMM
22:15:54 <dennisb> you can not have a list that actually is of type [a]. You can call length with for example a [Int] or [Float], and so on
22:16:18 <danols> can I have it generate a list ? i.e. [a] -> [a] ?
22:17:28 <dennisb> type is just a shorthand, data defines a new type
22:17:40 <danols> what are the adventages ?
22:18:01 <dennisb> reverse have type [a] -> [a]
22:18:16 <danols> hmmm so maybe I can do what I wanted in the begining...
22:18:24 <dennisb> you can reverse a list without knowing what type of element it has
22:18:26 <danols> anyhow that's beside the point what's wrong with my layout above
22:18:47 <dennisb> I don't see directly what's wrong
22:19:09 <danols> it's says a missing ;
22:19:29 <dennisb> except that the types are wrong. You are going to get into trouble with that...
22:19:47 <danols> Points IO ?
22:20:21 <dennisb> well, the type of genRoute can never be Points -> Points of you do IO in the function
22:20:39 <dennisb> then it can be for example Points -> IO Points
22:20:54 <danols> i see, still don't see why it's bad layout bummer
22:20:57 <danols> i'm tired screw this
22:21:01 <danols> for tonight atleast
22:21:47 <dennisb> all the things have to be aligned under a do, and you have to use tabs that is 8 spaces in your editor
22:22:43 <dennisb> or one can use explicit syntax where one inserts all the { ; } that "should" be there, but it's much more ugly
22:22:56 <dennisb> the first do I think you can remove
22:23:36 <danols> forgenRoute :: Points -> Points
22:23:36 <danols> genRoute points = do
22:23:36 <danols> 	if points == []
22:23:36 <danols> 	  then do return []
22:23:36 <danols> 	  else do 
22:23:36 <danols> 	    point <- randomRIO (0::Int, (length points)) -- select which trait are we going to use
22:23:38 <danols> 	    rest <- genRoute (filter (/= (points !! point)) -- get the rest
22:23:40 <danols> 	    return (points !! point : rest)
22:23:42 <danols> fuck sorry
22:23:49 <dennisb> also, "do return []" is the same as writing just "return []"
22:24:57 <danols> what do you mean do's have to be allinge ?
22:25:26 <dennisb> do cmd1
22:25:26 <dennisb>    cmd2
22:25:26 <dennisb>    cmd3
22:25:33 <dennisb> all the cmd:s must be aligned
22:25:42 <danols> how about this ?
22:25:43 <danols> do
22:25:45 <danols>   cmd1
22:25:48 <danols>   cmd2
22:25:48 <dennisb> if you indent one of the commands to another level you get a layout error
22:25:50 <danols> is this ok still ?
22:25:53 <dennisb> should work
22:26:01 <dennisb> (I think)
22:26:03 <danols> how do you usally keep your layout ?
22:26:14 <dennisb> I write as I pasted above
22:26:23 <danols> genChromo a = 
22:26:23 <danols> 	if a == []
22:26:23 <danols> 	then return []
22:26:23 <danols> 	else do element <- randomRIO (0::Int, (length a)) -- select which trait are we going to use
22:26:23 <danols> 		rest <- genRoute (filter (/= (a !! element)) -- get the rest
22:26:24 <danols> 		return (a !! element : rest)
22:26:41 <danols> dennisb what editor you use ?
22:26:41 <dennisb> also I use emacs that understands the syntax which makes it easier to write code for haskell
22:26:48 <danols> ohhh
22:26:50 <danols> there you go
22:26:57 <dennisb> but any editor should work
22:27:14 <danols> damn looks like i have to get back to linux
22:27:26 <dennisb> but it's nice with colored syntax, and indention help
22:27:30 * dennisb uses emacs in windows too
22:27:45 <danols> i'm getting vim
22:27:55 <danols> to bad linux is not ready for desktop
22:27:56 <dennisb> there is a haskell mode for vim too
22:28:05 <danols> i figured that out hope it's included
22:28:12 <dennisb> it all depends on you needs, it's ready for me
22:28:34 <dennisb> I can't use windows, it's too limited for a programmer...
22:28:43 <danols> dennisb true 
22:29:03 <danols> it's all need based, used gentoo for over a year, got to frustrated...but to each it's own
22:29:05 <dennisb> I feel lost whenever I use a windows machine. Been using only linux at home for 3 years now
22:29:21 <danols> hahah true
22:31:20 <dennisb> At least microsoft is working on a new terminal and script language. DOS windows and BAT-files should have died with the french revolution
22:31:23 <danols> dennisb someone said that i should setup tab to be spaces 
22:31:36 <dennisb> danols: then there should not be a problem
22:32:15 <danols> is vim setup like that automaticly ?
22:32:26 <danols> haven't used it in ages
22:32:36 * dennisb is an emacs guy
22:32:48 <dennisb> I've never used vim any longer period of time
22:33:39 <dennisb> genRoute (filter (/= (a !! element))
22:33:44 <dennisb> missing a )
22:33:54 <danols> ohhh shit
22:34:03 <dennisb> filter (/=) (a !! element)
22:34:09 <dennisb> no
22:34:10 <dennisb> sorry
22:34:18 <dennisb> still missing a ) though
22:34:37 <dennisb> but you should know, there are many type errors here
22:35:10 <danols> i've noticed this thing just threw them back at me, anyhow I really can't fight with this tonight, i guess i'll just give up on the bonus marks
22:35:13 <danols> thanks for the help
22:35:14 <danols> goodnight
22:35:15 <dennisb> one have to know exactly what type every subexpression has, and that you don't know yet
22:35:23 <dennisb> night!
22:35:27 <danols> no , that's why i'm learning
22:35:29 <danols> jesus,
22:35:33 <danols> haha
22:35:37 <danols> haskell is a though cookie
22:36:01 <dennisb> well, at least one get the errors at compile time instead of runtime
22:36:08 * dennisb said to himself
23:15:14 <debug> hm
