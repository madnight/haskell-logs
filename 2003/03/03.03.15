00:02:29 * Arnia hasn't slept yet :(
01:03:57 <pseiko> hi all
01:04:45 <pseiko> can anybody point me to a location where i can download hugs 1.3 (don't laugh)?
02:21:24 <rabbit^^off> pseiko perhaps http://www.haskell.org/hugs/
02:25:26 <Marvin--> clausen: libblkid seems really nifty... too bad it's unofficially-integrated with e2fsprogs though...
02:27:13 <andersca> what's that?
02:27:44 <Marvin--> http://www-mddsp.enel.ucalgary.ca/People/adilger/blkid/
02:27:56 <Marvin--> andersca: help, how do I unpack a .src.rpm again?
02:28:15 <andersca> rpm2cpio | cpio --extract ?
02:28:28 <andersca> or rather
02:28:34 <andersca> rpm2cpio filename | cpio --extract
02:28:47 <Marvin--> eh
02:29:02 <Marvin--> the 'rpm' command doesn't do things like that for me?
02:29:36 <andersca> you could install the .src.rpm
02:29:49 <Marvin--> but then I would need root
02:30:08 <andersca> [andersca@carbon andersca]$ cat .rpmmacros
02:30:08 <andersca> %_topdir    /home/andersca/.rpm
02:30:14 <andersca> that's what I use
02:31:49 <clausen> Marvin--: why?
02:31:52 * clausen with a friend
02:32:19 <Marvin--> clausen: makes it harder to debian package it
02:32:27 <Marvin--> since there's no real "upstream" distribution
02:37:06 <Marvin--> someone should tell the e2fsprogs people about this thing we call 'config.h'
02:51:31 <pseiko> rabbit^^off:  there are only recent versions at haskell.org/hugs
02:51:51 <rabbit^^off> so you need an older version ? why that ?
02:51:53 <pseiko> sorry, my connection was disturbed, but the question is still valid
02:52:35 <rabbit^^off> so you need an older version ? why that ? pseiko ?
02:52:35 <pseiko> hmm, need its parser.y file :-)
02:52:45 <rabbit^^off> aha
02:53:09 <rabbit^^off> hmm so which date was hugs-3 released ?
02:53:25 <rabbit^^off> :s/wich date/when/
02:53:54 <rabbit^^off> aehh I mean hugs 1.3 as you sai
02:53:55 <rabbit^^off> d
02:54:13 <pseiko>  January 1998
02:54:22 <rabbit^^off> oo
02:54:31 <rabbit^^off> so this is quit long ago
02:54:51 <rabbit^^off> and what do you need such an old parser.y for ?
02:54:55 <pseiko> it seems to me that there are only links in the web pointing to dev/null
02:55:25 <pseiko> i want to make a diff with the parser.y of ohugs to see the changes in the grammar
02:55:41 <rabbit^^off> oo
02:55:54 <pseiko> http://www.cs.chalmers.se/~nordland/ohugs/
02:56:26 <pseiko> if i make a diff with the parser.y of recent hugs there are to many differences i don't have to care for
02:56:48 <pseiko> so hugs98 is as the name says haskell98 compliant and hugs1.3 not
02:57:41 <pseiko> so, are there any ideas out there?
02:57:56 <rabbit^^off> I don't have any
02:58:12 <rabbit^^off> for I do not think that you can still find such an old version out in the net ...
02:59:51 <pseiko> :-(
03:05:54 <Marvin--> andersca: er, redhat question... a friend of mine hs installed redhat (8.0 I think) and is having problems with getting his via82cxxx_audio card working
04:35:21 <ludde> how do I do interprocess communication between two separate haskell programs ?
04:37:07 <Marvin--> that's not really a language-level decision, is it?
04:37:18 <buggs> you look what the one prints and types it in the other ?
04:38:58 <ludde> Marvin--: what do you mean?
04:39:17 <ludde> you mean i should write ghc programs ?
04:39:38 <ludde> I have one haskell program that forks another.. and i need to communicate between them
04:40:09 <Marvin--> I'm asking you what the difference is between IPC between two haskell programs and IPC between, say, two C programs
04:40:17 <Marvin--> or indeed, one C and one Haskell
04:40:27 <ludde> well, in C I have direct access to the system calls
04:41:11 <ludde> my main problem is how to achieve the same thing in haskell.. and i guess it gets pretty messy if I have to use FFI
04:41:16 <Marvin--> *which* system calls?
04:41:37 <Marvin--> if you have separate processes they don't share memory, so you still have a problem
04:41:49 <Marvin--> first you have to decide *by what means* they should communicate
04:42:04 <ludde> pipe(), or the redirect stdin/stdout ones (whatever they are called)
04:42:20 <Marvin--> right, so you're talking about communication over file descriptors
04:42:35 <Marvin--> you can do that in haskell, look at the posix package
04:43:20 <Marvin--> or so I think
04:43:29 <Marvin--> you can definitely use popen
04:43:56 <Marvin--> but that's not two-way
04:43:59 <Marvin--> hmm
04:55:17 <ludde> Marvin--: does popen really exist in ghc? there's no mentioning about it on http://www.haskell.org/ghc/docs/latest/html/base/GHC.Posix.html
04:56:21 <Marvin--> ludde: look in the "old libs" category
04:58:28 <ludde> runProcess looks nice
05:00:47 <ludde> do you know what I have to import to get this?
05:02:04 <Marvin--> run ghc/ghci with -package posix (if it's in posix) and import the module it says it's in?
05:02:34 <ludde> yaeh. i use -package posix already, but i don't know which pacakge to import
05:03:22 <Marvin--> don't the docs say what module it's in?
05:03:38 <Marvin--> I think you can just import Posix
05:05:47 <ludde> yeah, import Posix works..
05:05:55 <ludde> if I found it in the docs i wouldn't have had to askl
05:06:53 <Marvin--> point ;)
05:37:45 <Janni> hello!
05:38:50 <liiwi> yo
05:39:30 <ludde> hah
05:39:30 <ludde> ghc-5.04.1: panic! (the `impossible' happened, GHC version 5.04.1):
05:39:30 <ludde>         interactiveUI:buffering
05:42:51 <listener> maybe ( not Maybe ). How does it work.
05:49:05 <ludde> is there some way to make functions in a "where" clause, without tabbing in?
05:50:38 <ludde> normally you write
05:50:46 <ludde> a :: Int -> Int
05:50:52 <ludde> a = ...
05:50:54 <ludde>   where
05:51:00 <ludde>     b = 678
05:51:11 <ludde> but if you want to have b at the same tablevel as a, how can you do?
05:52:07 <OuterMind> anda
05:52:12 <OuterMind> ups, sorry
05:53:06 <OuterMind> where is a local declaration
05:53:14 <OuterMind> it has to be local to something
05:53:33 <OuterMind> b is local for a
05:53:35 <ludde> asking me?
05:54:41 <OuterMind> no no
05:54:47 <OuterMind> the answer
05:54:53 <OuterMind> :P
05:54:59 <OuterMind> "where" is a local declaration
05:55:02 <ludde> i don't quite understand what you mean.
05:55:03 <ludde> yeah
05:55:07 <ludde> i know
05:55:14 <ludde> but I want to avoid tabbing in
05:55:27 <ludde> so I'm wonder if there's is some syntactic way to do it without tabbing in?
05:55:35 <andersca> I don't think so
05:58:15 <listener> <listener> How does maybe ( not Maybe )?
05:58:30 <Marvin--> listener: huh?
05:58:32 <listener> Sorry /?/work ?/
05:58:50 <Marvin--> what do you mean  maybe (not Maybe)  ? That's not valid Haskell
05:59:13 <listener> :t maybe
05:59:41 <Marvin--> yes,  a -> (b -> a) -> Maybe b -> a
05:59:45 <ludde> hmm
05:59:48 <ludde> seems like I can use { around 
05:59:52 <listener> So what does it do?
05:59:58 <Marvin--> listener: maybe x f Nothing = x
06:00:05 <Marvin--> listener: maybe x f (Just y) = f y
06:00:14 <Marvin--> (if I recall correctly)
06:04:26 <listener> Yeah that fits.
06:05:00 <listener> It's a bit annoying. I can seem to find references on these things.
06:07:04 <listener> The lib documentation mentions it, but just the signature. Sometimes the signature is enough to describe a function clearly. But sometimes not.
06:07:24 <ludde> I HATE LAYOUT!
06:07:32 <andersca> just use emacs
06:07:48 <ludde> how does that help
06:07:59 <andersca> hugs-mode does automatic indentation for you
06:08:06 <andersca> s/hugs/haskell/
06:08:11 <ludde> I want to avoid indent :(
06:08:53 <listener> andersca: emacs mode is good. If you don't mind "f x y" taking up 200 columns.
06:09:45 <andersca> ludde: um, then don't use haskell
06:09:55 <ludde> well
06:10:07 <ludde> i have to use haskell
06:10:42 <andersca> and haskell uses indentation as part of its syntax
06:10:44 <ludde> i just want to avoid having to indent functions if they're part of where
06:11:04 <ludde> since I get almost no columns left on my screen if I indent all the time
06:14:40 <shapr> I like layout
06:14:52 <shapr> imho, significant whitespace is a good thing
06:14:58 <listener> http://zvon.org/other/haskell/Outputglobal/index.html 
06:15:06 <listener> a real clear example.
06:16:05 <shapr> hi thaddeus
06:16:38 <listener> hi shapr
06:17:26 <resolve> hello!
06:17:29 <shapr> hi resolve!
06:18:01 <resolve> should i ask again? :)
06:18:05 <shapr> yes please
06:18:21 <resolve> Prelude> (until (> 25) (\x -> x*x) [1..2])
06:18:21 <resolve> <interactive>:1:
06:18:21 <resolve>     No instance for (Num [t])
06:18:21 <resolve>     arising from use of `*' at <interactive>:1
06:18:21 <resolve>     In a lambda abstraction: x * x
06:18:22 <resolve> have i mucked something up, or is ghc5 different?
06:18:42 <resolve> i did something similar before.. originally using [1..] but i was trying to figure out what was wrong :)
06:19:07 * shapr looks at until
06:19:52 <resolve> installing ghc4 to test, i think this is what i had before
06:20:08 <shapr> resolve: it's not about ghc5 vs ghc4
06:20:41 <resolve> i wonder what i was doing previously that worked :-)
06:21:05 * shapr tries to jumpstart his brain
06:21:15 <resolve> is [t] in this instance a type variable?
06:21:19 <OuterMind> resolve: did you used an anonymous function the other time?
06:21:30 <OuterMind> resolve: did you use an anonymous function the other time?
06:21:42 <resolve> yep, i think so, because there is no `square'
06:21:58 <listener> I'm looking at a  reference here. The chapter is 4 ( page 32 ) and the chatper title is Type Basics. I printed out the first part and like it, but can't figure out where it came from. Anyone help?
06:22:54 <OuterMind> ok, because sometimes haskell can't infer the type of an anonymous function
06:23:16 <OuterMind> it depends on how until is defined
06:25:11 <resolve> ah, good point. hmm
06:26:01 <shapr> resolve: oh, I figured it out I think
06:26:23 <shapr> (until (> 25) (\x -> x*x) 2)
06:26:36 <listener> Yeah you need map
06:26:39 <resolve> okay, my memory was really bad
06:26:45 <resolve> i was remembering having written this yesterday: fst (splitAt 10 (map (\x -> x*x) [1..]))
06:26:45 <OuterMind> of course
06:26:48 <OuterMind> xDDD
06:27:04 <listener> Sorry. You don't need map.
06:27:11 <resolve> sorry for the silly question :-)
06:27:17 <OuterMind> [1..2] returns a list
06:27:21 <resolve> listener: hmm, the semantics of the until would be different
06:27:32 <OuterMind> \x->x*x cannot take a list as parameter
06:27:40 <resolve> it would base the next square on the previous one, rather than the next sequential number, afaik
06:27:51 <resolve> OuterMind: *nods*, just my brain having switched off
06:28:09 <OuterMind> <resolve>     No instance for (Num [t])
06:28:18 <OuterMind> <resolve>     arising from use of `*'
06:28:35 <OuterMind> * takes two Num parameters
06:29:01 <resolve> yeah, so [t] in this case was a type variable? i saw the t and it looked like a truth value in lisp, and was led astray.. ;-)
06:29:06 <OuterMind> and the compiler says he cannot find an instance for Num [t]
06:29:14 <OuterMind> yeah, i thing so
06:31:45 <OuterMind> [t] is the type of [1..2]
06:32:07 <OuterMind> the compiler cannot evaluate [1,2]*[1,2]
06:32:40 <resolve> i appreciate your elaboration, but i get the concepts :) it was just a thinko on my part
06:33:06 <OuterMind> ok, :P
06:33:29 <listener> OutMind I don'
06:33:40 <listener> t think that's what happened.
06:34:02 <listener> *::(Num a)=> a->a->a
06:34:06 <OuterMind> I'm almost sure about it
06:34:10 <OuterMind> explain your point
06:34:27 <listener> so \x->x*x::(Num a )=>a->a
06:34:30 <OuterMind> aham
06:34:40 <OuterMind> yeah
06:34:56 <OuterMind> and the compiler says than [1,2] is not instance of Num
06:35:08 <OuterMind> so he can't do [1,2]*[1,2]
06:35:17 <listener> until:(a->Bool)->(a->a)->a->a
06:35:19 <OuterMind> so it can't do
06:35:42 <listener> So the third argument has to be Num[a]
06:35:56 <OuterMind> yeah
06:36:08 <OuterMind> it's the same i told
06:36:31 <listener> But the compiler never gets that far ( trying []*[] ) because it already knows that \x->x*x returns a "Num[a]"
06:36:58 <OuterMind> we are in agree :)
06:37:13 <listener> So it says "the third argument is a Num[a]".
06:38:49 <OuterMind> well, it may i didn't explain my point
06:40:40 <listener> Is there a way to get a filesize without opening a file?
06:40:48 <andersca> stat?
06:41:41 <listener> I couldn't find stat in the libraries.
07:00:49 <listener> Can you define a Y combinator for Haskell?
07:10:51 <Marvin--> let y g = g (y g) ? 
07:11:57 <ibid> does that type?
07:12:03 <shapr> I can type that!
07:12:20 <ibid> but can it type you? :-)
07:12:25 <shapr> heh, probably not
07:12:28 <Marvin--> ibid: sure it does, y :: (a -> a) -> a :-)
07:12:56 <Vincenz> isn't that recursive until infinity?
07:13:01 <shapr> hi Vincenz!
07:13:06 <Vincenz> hiya shapr!
07:13:11 <ibid> Marvin--: it seems so
07:13:11 * Vincenz the newb shows up
07:13:42 <resolve> hi, vincenz!
07:13:51 <Vincenz> hello resolve?
07:14:00 <Marvin--> let fac f n = if n == 0 then 1 else n * f (n-1)
07:14:07 <resolve> Vincenz: what are you unsure of? :)
07:14:09 <Marvin--> :t y fac
07:14:10 <Marvin--> forall a. (Num a) => a -> a
07:14:16 <Marvin--> > y fac 5
07:14:16 <Marvin--> 120
07:15:04 <Vincenz> well I know shapr, sorta...
07:15:06 <Marvin--> "implementing recursion using recursioN"
07:15:35 <listener> >Doh no wonder I get stack overflow. I forgot the test for 0.
07:15:40 <Vincenz> but....
07:15:43 <Marvin--> listener: :-)
07:16:00 * shapr grins
07:16:26 <resolve> Vincenz: i was just being friendly :)
07:16:30 <Vincenz> alright :)
07:16:31 <Vincenz> but...
07:16:38 <Vincenz> let y g = g (y g)
07:16:44 <Vincenz> doesn't that recurse until infinity?
07:16:59 <listener> Vincent: It's a lazy language.
07:17:02 <Marvin--> depends on what g does
07:17:07 <Vincenz> I know...but what's the use?
07:17:22 <Marvin--> Vincenz: explicit recursion
07:17:24 <resolve> Vincenz: an example from before on how laziness works: fst (splitAt 10 (map (\x -> x*x) [1..]))
07:17:40 <resolve> even though that map is mapping an infinite list, only 10 elements are printed out
07:17:45 <Vincenz> resolve: I know lazyness, never progged it but I had a course on compiler-construction :)
07:17:52 <resolve> cool. :-)
07:17:55 <listener> Vincent: let fac k n = if n == 0 then 1 else n * k (n-1)
07:18:09 <listener> y fac 5
07:18:35 <Vincenz> I know
07:18:37 <Vincenz> but if g is a function
07:18:42 <Vincenz> let y g = g (y g)...
07:18:44 <Marvin--> however, let y' f = (\x -> f (x x)) (\x -> f (x x))  doesn't work
07:19:11 <listener> I'm suprised iut's so easy. In ML typing makes it harder.
07:19:18 <Vincenz> hmm
07:19:22 <Vincenz> how hard is Haskell?
07:19:31 <shapr> Vincenz: as compared to what?
07:19:36 <Vincenz> hmm
07:19:40 <Vincenz> as compared to...
07:19:42 <Vincenz> not knowing FP
07:19:55 <Vincenz> the most I've done was this introductory course in first yaer of college
07:19:58 <Vincenz> which was based on scheme
07:20:03 <Vincenz> but mostly just car, cdr, and oop
07:20:21 <Vincenz> you know...create a lambda which you can pass a message
07:20:28 <shapr> I don't think Haskell is hard.
07:20:36 <Vincenz> I don't know...
07:20:42 <Vincenz> you can't create vars and stuff...
07:20:47 <shapr> you can create them
07:20:57 <shapr> you can create new ones with the same name
07:21:08 <Vincenz> I just fail to see how you can write haskell prorgams that cannot be computed at compile time
07:21:17 <shapr> like what?
07:21:24 <shapr> what do you mean?
07:21:43 <Vincenz> well...
07:21:46 <Vincenz> you define all these functions
07:21:48 <Vincenz> and data etc
07:22:01 <Vincenz> but basically there's not much intereaction so in theory it could be calculated at compiletime
07:23:23 <ludde> Vincenz: IO is not deterministic
07:23:24 <Marvin--> interactive programs can't be computed at compile time
07:23:31 <Marvin--> what he said
07:23:40 <Vincenz> ludde: IO seems to be an exception than a rule
07:24:02 <Marvin--> Vincenz: but why couldn't you do that with non-IO imperative programs too?
07:24:25 <Vincenz> because the way prorgams are designed in oop-languages is much different
07:24:34 <shapr> not so much different
07:24:34 <Vincenz> I don't know, I guess it's a big mindset change
07:24:41 <Marvin--> I'd say it's pretty hard to write the compiler in both cases
07:24:55 <Marvin--> a compiler that optimizes away computations that is
07:25:16 <shapr> Vincenz: http://c2.com/cgi-bin/wiki?FunctionalModelingExamples
07:25:43 <Vincenz> for example
07:25:49 <Vincenz> the biggest application I would see for FP
07:25:51 <Vincenz> is DSP
07:25:57 <Vincenz> but is it efficient enough?
07:26:20 <shapr> there are DSP libraries for Haskell
07:26:24 <shapr> what counts as efficient enough?
07:26:32 <ludde> DSP ?
07:26:36 <Vincenz> shapr: efficient as in C efficient
07:26:38 <shapr> digital signal processors
07:26:42 <Vincenz> or processing
07:26:43 <resolve> Vincenz: you should spend some time learning haskell before you try and see what it's useful for - it's hard to make a decision until you get to know it. FP is an abstraction like OOP. it can be quite powerful
07:26:48 <shapr> Vincenz: only assembly is more efficient than C
07:26:49 <Vincenz> my background is electronics and sp
07:26:50 <Vincenz> dsp
07:26:51 <ludde> is haskell good at that?
07:26:58 <ludde> err
07:27:05 <ludde> are functional programming languages in general at that
07:27:06 <Vincenz> shapr: you can't do global dataflow analysis as well in assembly :P
07:27:18 <shapr> Vincenz: sure is fast though ;-)
07:27:24 <listener> shapr: ocaml advocates woyuld debate that.
07:27:24 <shapr> isn't that what you wanted? ;-)
07:27:25 <Vincenz> hmm
07:27:32 <Vincenz> ocaml is supposeldy really fast
07:27:33 <shapr> listener: happily there aren't any here.
07:28:04 <listener> Yep. Hate the French ;)
07:28:15 <Vincenz> just I don't know how well global dataflow analysis would work in FP
07:28:16 <shapr> listener: I'm married to a french woman.
07:28:52 <shapr> Vincenz: of what sort? process networks?
07:28:56 <Vincenz> no
07:29:05 <shapr> hardware design with Haskell?
07:29:05 <Vincenz> wrt dsp-algorithms
07:29:07 <Vincenz> no no
07:29:17 <Vincenz> dsp doesnt' just stand for the hardware side
07:29:45 <Vincenz> but...
07:30:00 <Vincenz> you can gain like factor 2-5 if you do global dataflow analysis by keeping your cache clean and such
07:30:04 <Marvin--> shapr: good code is faster than bad code :-P
07:30:06 <Vincenz> without looking at hardware specific sutff
07:30:20 <Marvin--> haskell programs can be faster than C programs
07:30:23 <Vincenz> DTSE - data transfer and storage exploratin
07:30:32 <Marvin--> just as C programs can be faster than assembly programs if you suck at writing assembler
07:30:35 <Vincenz> Marvin--: java programs can be faster than c programs
07:30:37 <shapr> Vincenz: http://www.google.com/search?ie=ISO-8859-1&q=haskell+%22dataflow+analysis%22&btnG=Google+534R%28H
07:30:51 <Marvin--> Vincenz: now THAT I have a hard time believing ;)
07:31:01 <Vincenz> Marvin--: if you're good at java and suck at c :P
07:31:08 <Vincenz> what's haskells main domain of programming?
07:31:24 <listener> One thing to remember though. Lisp in "the real world" does not look like Lisp in the books.
07:32:04 <shapr> Vincenz: I'd say Haskell is a multi-paradigm general purpose programming language
07:32:06 <Vincenz> lisp is yucky
07:32:22 <shapr> it doesn't have a single main domain
07:32:26 * Vincenz nods
07:32:31 <Vincenz> but there must be a domain it excels at
07:32:33 <Vincenz> like java
07:32:37 <Vincenz> easy to write gui and network stuff
07:32:42 <shapr> java excels at something other than irritating programmers? 
07:32:59 <listener> I have a CGI script in Haskell, which needs to read an initialization function and assign "global" variables it's values. How can I do that?
07:33:20 <shapr> listener: read John Hughes paper for your global var answer.
07:33:35 <listener> Which one?
07:33:45 <Vincenz> shapr: java is fast to develop in, at least for me
07:34:02 <shapr> listener: heuristic: use google with the relevant keywords
07:34:07 <Vincenz> I guess it's a matter of personal flavor
07:34:13 <Vincenz> especially with eclipse :
07:34:15 <Vincenz> :)
07:34:35 <shapr> Vincenz: I've been using Java since the beta, I think its strength is not network programming.
07:34:59 <Vincenz> no, ruby is easier in that
07:35:02 <Vincenz> less typing and stuff
07:35:21 <Vincenz> java is very handy to develop in and design, and refactor, IMHO
07:35:36 <Vincenz> but that could be because it's the language I'm most proficient in
07:35:59 <shapr> in my experience, I can write a java program in Jython in half the time, and one-third the equivalent source code size.
07:36:00 <Vincenz> I've tried squeak, while it's a neat concept I don't see myself using it on "serious" projects
07:36:11 * Vincenz nods at shapr
07:36:27 <Vincenz> well I've chosen to learn ruby instead of python, so I guess that doesn't go for me yet
07:36:27 <shapr> I wrote a tiny PowerPoint clone in Jython in two weeks
07:37:56 <resolve> why is lisp yucky? (/me pokes his head back into the conversation :)
07:38:07 <Vincenz> I don't know, syntactically
07:38:10 <resolve> and why does "real world lisp" look different?
07:38:11 <Vincenz> plus the macro system
07:38:21 <resolve> macros are yucky?
07:38:34 <resolve> how long have you played with lisp?
07:38:35 <Vincenz> yes wrt readability of code
07:38:35 <resolve> :)
07:38:39 <Vincenz> not much at all
07:38:49 <resolve> any foreign language is unreadable until you learn it
07:39:22 <listener> Vincenz: squeak is not a good example of ST. If you really want to get an idea of ST try VisualWorks or VisualAge
07:39:30 <listener> ( both free for noncomercial ).
07:39:34 <Vincenz> I got cincom's one
07:40:01 <Vincenz> haven't spent much time with it yet
07:40:38 <Vincenz> I'd like to learn an fp tho
07:40:47 <Vincenz> but I can't decide on ocaml, haskell or scheme
07:40:56 <listener> resolve: in "the real world" you generally access 'data structures' radomly not sequentually. So you see a lot of arrays instead of lists. 
07:41:04 <listener> Plus macros.
07:41:08 * Vincenz nods at listener
07:41:14 <Vincenz> p
07:41:19 <listener> Look at an example in Horn.
07:42:06 <listener> It's made to make basic Lisp look good, but a real world app pushes on the stress points on that style. So real
07:42:12 <resolve> hmm, i think you're generalising too much
07:42:30 <listener> worls apps use more advanced Lisp features. Which make it look very different.
07:42:33 <resolve> a "real world" example is paul graham's team doing the yahoo store for some $50 million in lisp
07:42:52 <listener> Yeah and have you seen the code?
07:43:27 <resolve> not to the shopping cart, i imagine the price per line is a bit above my price range ;-)
07:43:40 <Vincenz> hehe
07:43:40 <Vincenz> :P
07:43:54 <resolve> lisp is an interesting academic exercise on paper, but that's not where the appeal lies
07:44:02 <resolve> the appeal lies that it's actually pretty good for developing things!
07:44:20 <Vincenz> so...ocaml, haskell or scheme?
07:44:27 <shapr> Vincenz: any haskell info you want?
07:44:31 <resolve> not that i want to proselytize too much in a haskell channel, but i couldn't just let "lisp is ugly" pass ;-) i think it's more beautiful in its simplicity than most languages out there
07:44:34 <Vincenz> shapr well in fact yes
07:44:35 <Vincenz> a nice ide
07:44:40 <Vincenz> where I can test code at runtime
07:44:42 <listener> Since he doesn't like "loop" his code may be closer to text book style then general. But he also loves macroes.
07:44:45 <Vincenz> like ..drscheme for scheme
07:44:46 <resolve> Vincenz: all three!
07:44:48 <shapr> Vincenz: I use emacs + ghci 
07:44:58 <Vincenz> talking to the wrong person
07:45:01 * Vincenz uses VIM
07:45:07 <Vincenz> resolve: I don't have that amount of time
07:45:18 <listener> I didn't say lisp was ugly, I said that "lisp in practice" looks very different from "lisp in theory".
07:45:27 <resolve> listener: what's wrong with macros? a language that better fits a given schema is a better language to address problems in that schema
07:45:45 <shapr> Vincenz: have you tried hugs or interactive ghc?
07:45:53 <resolve> <Vincenz> lisp is yucky :)
07:45:55 <Vincenz> I've got three compilers, hugs, ghc and another one
07:46:07 <shapr> Vincenz: would you like some walkthroughs?
07:46:09 <listener> But it doesn't look like the Lisp in Tourestsky's book or the Lisp in Winston & Horn.
07:46:17 <Vincenz> which do you suggest installing?
07:46:25 <resolve> anyway, feel free to remove iterative constructs from other "real world only" languages and see how useful they become ;-)
07:46:25 <shapr> Vincenz: you may want to start with hugs
07:46:30 <Vincenz> al;right
07:46:36 <shapr> Vincenz: I've used both hugs and ghc at different times.
07:46:37 * Vincenz surfs to his own little coding folder
07:46:53 <Vincenz> (more than a cdfull of progging stuff... should I ever need it)
07:47:01 <resolve> hugs has really bad error reporting and isn't as nice at evaluating expressions interactively. are there reasons (apart from speed) not to use ghci over hugs?
07:47:08 <listener> Just as I suspect Haskell  progs look different from Haskell examples ( most being done in the monad ).
07:47:22 <shapr> listener: you could learn Haskell and see if that's true.
07:47:39 * Vincenz installs
07:47:48 <Marvin--> resolve: ghci is horribly slow on an Ultra 10 with little memory :/
07:48:03 <shapr> resolve: I haven't used hugs much lately
07:48:05 <Vincenz> alright
07:48:07 <Vincenz> I've got hugs
07:48:08 <listener> Vincenz: if you can only install one use ghc. Otherwise install both.
07:48:10 <shapr> ghci might be a better solution in general
07:48:10 <Vincenz> three progs though
07:48:41 <listener> shapr: I'm looking at the SImulator for this years ICFP. Looks mostly in monads to me so far.
07:48:55 <Vincenz> listener: the one for robost?
07:48:57 <Vincenz> robots?
07:49:04 <listener> Yep.
07:49:08 <Vincenz> Hugs (Hugs mode)
07:49:10 <Vincenz> Hugs (Haskell mode)
07:49:14 <Vincenz> Hugs (new libs mode)
07:49:38 <shapr> listener: how does that compare with the haskell examples?
07:49:49 <listener> It would be an insterasting execise to pick a couple of apps and see how much time is spent in the monad and
07:49:56 <listener> how much time not in it.
07:50:19 <Marvin--> "the monad"? there's monads and there's monads
07:50:26 * shapr grins
07:50:35 <shapr> Vincenz: ok, open up hugs
07:50:36 <Marvin--> in a large application you typically use several different monads, including the IO monad on top level
07:50:54 <Vincenz> alright
07:50:57 <listener> The point is not that it's bad necessarily. But that monads are Chapter 8 (?) in THompson. You read a whole lot
07:51:00 <Vincenz> I tried it last time all I could do was load files
07:51:02 <Marvin--> in our compiler, there's probably an auto-generated parser monad, we have a type checking monad, and different monads for different backends et.c.
07:51:23 <shapr> Vincenz: I mostly edit files in emacs, and hit a button to load them into ghci
07:51:24 <listener> about Haskell before you see what it's like when you start writing programs.
07:51:32 <shapr> Vincenz: can you do that with vim?
07:51:40 <Vincenz> hmm
07:51:47 <Vincenz> most likely yes
07:51:56 <o3> Vincenz: no, you can't
07:52:00 <Vincenz> you can't?
07:52:01 <Vincenz> ???
07:52:03 <o3> not in the way that shapr is talking about, anyway
07:52:03 <Vincenz> how so?
07:52:13 <o3> you can do :!ghci %, sure
07:52:18 <Vincenz> a good Ide would greatly benefit the language
07:52:23 <shapr> I don't know anything about using vim with haskell
07:52:29 <o3> but ghci mode in emacs runs ghci in a subwindow of emacs, so to speak
07:52:35 <Vincenz> ah, I see
07:52:35 <shapr> Vincenz: you may want to try hIDE
07:52:43 <Vincenz> hIDE isn't it based no emacs?
07:52:49 <o3> which you can't do with vim, at least, unless you have the code sitting on my hard disk ;)
07:52:50 <shapr> either emacs or vim
07:52:52 <Vincenz> I had lisp once, or scheme, the MIT version...
07:52:55 <Vincenz> and....UGH
07:53:01 <Vincenz> it had emacs as ide
07:53:22 <Marvin--> I tried to use Isabelle/HOL a while ago, but gave up because it had an emacs UI, and I didn't understand a thing
07:53:27 <o3> religious wars -> waste of time
07:53:32 <listener> The one complaint I have about ghc and emacs is that you have to read a whole file. You can't just send a chunk.
07:53:34 <shapr> o3: yay
07:53:38 <Vincenz> no, not that, I'm not saying emacs is bad, I'm just saying I can't useit
07:53:42 <Vincenz> I'm emacs-impaired
07:53:44 <shapr> heh
07:53:50 <shapr> I'm vim-impaired ;-)
07:53:55 <Marvin--> Vincenz: me too
07:53:57 <shapr> but we all want to use Haskell
07:53:58 <resolve> i know both, and recommend both!
07:54:03 <resolve> programming in vim is a pain, though.
07:54:04 <listener> Were you using I-lisp mode?
07:54:15 <Vincenz> resolve: I use eclipse for java!
07:54:34 <shapr> Vincenz: ok, so you have hugs open
07:54:36 <Vincenz> now that's a great ide
07:54:41 <o3> listener: oh, just because you're in the IO monad doesn't mean that you're at some sort of disadvantage with non-monadic code
07:54:44 <Vincenz> yup
07:54:52 <shapr> Vincenz: I've heard rumors of a haskell plugin for eclipse
07:54:57 <o3> you still benefit from haskell's features, like strong type checking, etc
07:55:00 * Vincenz hits google
07:55:03 <shapr> Vincenz: have you done any Haskell examples so far?
07:55:13 <listener> Vincenz: The advantage of emacs/vim is that you can write code in one buffer and send it to the interpreter in another.,
07:55:18 <Vincenz> No, I got turned down by the interface and the inability to use it
07:55:52 <shapr> Vincenz: would you like to go through some interactive stuff?
07:56:19 <Vincenz> only if you feel like it
07:57:04 <listener> BTW eclipse copies a lot of ST. That's where it gets it's inspiration from.
07:57:12 <Vincenz> I know
07:57:19 <shapr> Vincenz: some cute tricks you can do are: filter (> 5) [1..9]
07:57:26 <shapr> that shows off partial evaluation
07:57:32 <Vincenz> but...
07:57:32 <shapr> and higher order functions
07:57:37 <shapr> and enumerations
07:57:40 <Vincenz> oh!
07:57:42 <Vincenz> doh!
07:57:47 <Vincenz> you -can- run code in the interpreter
07:57:53 <Vincenz> last time I tried somtehing off the net it wouldn't work
07:58:00 <Vincenz> I tried to define a function
07:58:00 <Vincenz> to no avail
07:58:17 <listener> You need to put "let" in front of it.
07:59:17 <Vincenz> ah
07:59:29 <Vincenz> hehe
07:59:29 <o3> ok, night *
07:59:32 <o3> 3am -> bed!
07:59:35 <shapr> g'night o3
07:59:39 <Vincenz> shapr: well I tried your thing....and it didn't show partial eval
07:59:43 <Vincenz> so what I did was
07:59:48 <Vincenz> fliter (> 5) [1..]
07:59:50 <Vincenz> :P
07:59:52 <shapr> nooo
07:59:56 <Vincenz> I have CTRL+C
08:00:12 <shapr> if you use (< 5) that will work
08:00:24 <Vincenz> nope
08:00:25 <Vincenz> it doesn't
08:00:26 <Vincenz> it hangs
08:00:29 <Vincenz> until I press CTRL+C
08:00:45 <shapr> filter (< 5) [1..9]
08:00:53 <shapr> ah, I see
08:00:57 <Vincenz> Prelude> filter (< 5) [1..] 
08:01:01 <shapr> filter (> 5) [1..9]
08:01:05 <Vincenz> [1, 2, 3, 4(Interrupted)
08:01:22 <shapr> head (filter (> 5) [1..])
08:01:24 <shapr> what about that?
08:01:35 <Vincenz> yup :)
08:01:38 <shapr> yay
08:01:40 <Vincenz> must be because of the print routine
08:02:12 <shapr> probably so
08:02:18 <Vincenz> let ones = 1::ones
08:02:27 * shapr watches smoke come out of Vincenz's computer
08:02:34 <shapr> print ones
08:02:35 <shapr> boom!
08:02:38 <shapr> :-)
08:02:50 <Vincenz> nono
08:02:52 <Vincenz> it doesn't work
08:02:55 <Vincenz> compile error
08:03:03 <shapr> maybe let ones = 1 : ones
08:03:04 <Vincenz> too bad I can't copy paste from the terminal
08:03:26 <Vincenz> ERROR - Syntax error in expression (unexpected end of input)
08:03:39 <listener> can you make circular lists?
08:03:45 <shapr> ghc will let you do that at the prompt
08:03:55 <shapr> in hugs you have to load a file that has that definition
08:04:09 * shapr creates Test.hs
08:04:12 <Marvin--> listener: you can't say xs = [xs] because that'd have an infinte type, but if you create a new data type, yes
08:04:13 <Vincenz> ah 
08:04:15 <Vincenz> that sux
08:04:17 <Vincenz> well
08:04:24 <Vincenz> I'll install ghc
08:05:17 <Vincenz> I installed hugs last time I wanted to try haskell
08:05:21 <Vincenz> and it didn't work (the defs)
08:05:22 <Marvin--> ... or so I think
08:05:34 <Vincenz> and then I installed ghc and the interface looked the same so I assumed it wouldn't work either
08:06:05 <Vincenz> woo!!
08:06:05 <Vincenz> it owrks
08:06:13 <Vincenz> let ones = 1 : ones
08:06:14 <Vincenz> head ones
08:06:15 <Vincenz> 1
08:06:17 <shapr> yay
08:06:21 <shapr> or take 5 ones
08:06:23 <Vincenz> I'm so proud of myself
08:06:28 <shapr> that gets five items from the front of the list
08:06:32 <Vincenz> that sounds like english
08:06:33 <Vincenz> hehe
08:06:36 <Vincenz> take 5 ones
08:06:42 <Vincenz> just make sure your variable names are clear
08:06:55 <shapr> take 5 onesList
08:07:05 <Vincenz> I know, the var is named ones
08:07:12 <Vincenz> it just sounds so much like english :)
08:07:31 <Vincenz> what's the advantage of hugs over ghc?
08:07:47 <Vincenz> and is nhc any good (have the installf files for that one too)
08:07:51 <shapr> hugs is an interpreter written in C
08:07:57 <shapr> ghc is a compiler written in Haskell
08:08:18 <Vincenz> euhm...but ghc does more interpreting than hugs
08:08:21 <Vincenz> so hugs is faster?
08:08:29 <shapr> ghc is faster actually
08:08:41 <shapr> each has advantages
08:08:48 <shapr> for example, hugs runs on the Sharp Zaurus
08:08:55 <shapr> ghc is far too large to fit on the Zaurus
08:09:09 <resolve> but the compiled binaries ghc generates.. :)
08:09:10 <listener> Actually ghc comes in two flavors ghc/ghci. ghci is an interpreter and ghc is a compiler.
08:09:17 <Vincenz> ah :)
08:09:21 <Vincenz> thanks for helping this newb
08:09:24 <Vincenz> and nhc?
08:09:54 <shapr> actually, ghc is a compiler, and ghci compiles binaries and loads the chunks into ghci for interactive use.
08:10:03 * Vincenz nods
08:10:11 <Vincenz> alright
08:10:12 <shapr> ghci is just a small extension of ghc
08:10:16 <Vincenz> I'm going to try something complexer
08:10:17 <listener> Just a compiler. But I think it produces faster code.
08:10:26 <Vincenz> fibonacci without looking at the defintion on the web
08:10:29 <listener> shapr: Same difference.
08:10:41 <shapr> listener: no, it's not.
08:11:42 <Vincenz> what's the opposite of head?
08:11:42 <Vincenz> tail?
08:11:57 <Vincenz> damn
08:11:57 <shapr> yes
08:11:58 <Vincenz> doesn't work
08:12:03 <shapr> what did you try?
08:12:06 <Vincenz> oh wait
08:12:07 <Vincenz> duh
08:12:13 <Vincenz> damn
08:12:22 <Vincenz> let fib = 1 : 1 : head fib + head tail fib
08:13:01 <Vincenz> damn
08:13:04 <Vincenz> can't copy paste the error
08:13:14 <Vincenz> cannot construct infinte type a = [a]
08:13:20 <shapr> what's the code you used?
08:13:21 <resolve> 'night everyone
08:13:24 <shapr> g'night resolve 
08:13:26 <Vincenz> let fib = 1 : 1 : head fib + head tail fib
08:13:30 * Vincenz waves at resolve
08:13:37 * resolve will stay here and hopefully accumulate knowledge by osmosis
08:13:51 <Vincenz> logging huh :)
08:14:50 <Vincenz> or wait
08:14:52 <Vincenz> : 1 :
08:15:06 <Vincenz> Couldn't match [t -> t1] against [a] -> [a]
08:15:22 <Vincenz> gosh darnit
08:17:33 <Vincenz> I tried this too
08:17:44 <Vincenz> let fib = 1 : ( 1: head fib + head tail fib)
08:18:17 <shapr> I would suggest you write down why you think this code should work
08:18:37 <shapr> and after you've played with it for a bit, look at the fib code on the web
08:18:39 <shapr> and compare them
08:18:46 <Vincenz> it's obvious no?
08:19:48 <listener> Vincanez: Assuming hugs/ghc/ghci accepted it, what would head fib look like? head head fib? head head head fib?
08:20:08 <Vincenz> oh
08:20:09 <Vincenz> duh
08:20:11 <Vincenz> yu're right
08:20:12 <Vincenz> duh duhg
08:21:25 <Vincenz> the third argument is a number
08:21:30 <Vincenz> head fib is a number
08:21:32 <Vincenz> and so is head tail fib
08:21:34 <Vincenz> thanks :)
08:23:05 <Vincenz> any suggestions?
08:23:09 <Vincenz> I can't do
08:23:12 <Vincenz> tail fib + tail tail fib
08:24:30 <Vincenz> I give up
08:26:07 <shapr> Vincenz: ready to look at the fib on the web?
08:26:15 * Vincenz nods
08:26:19 <Vincenz> I'm looking it u
08:26:56 <Vincenz> I forgot the site, but once I saw this page how it's chasing it's tail but that could've been ocaml or scheme
08:27:04 <shapr> http://www.stat.cmu.edu/~minka/PLE/haskell/stream.html
08:27:13 <shapr> add_lists x y = zipWith (+) x y
08:27:19 <shapr> fibs = 0:1:(add_lists (tail fibs) fibs)
08:27:34 <Vincenz> how's that different with what I do?
08:27:51 * shapr looks
08:28:12 <Vincenz> let fib = 1 : ( 1: ((tail fib) + (tail (tail fib)))
08:28:17 <Vincenz> )
08:28:22 <Marvin--> ++, not +
08:28:47 <Vincenz> ack
08:28:48 <Vincenz> crash
08:29:03 <Marvin--> ?
08:31:14 <listener> shapr: I couldn't find that paper on global variables. ( Could find lot's of other itneresting stuff though. )
08:32:01 <shapr> listener: what search terms did you use?
08:32:12 <shapr> it's the first item in my google search.
08:33:39 <listener> John Hughes
08:33:47 <listener> I actually found his web site.
08:34:12 <Vincenz> woo, fib works :)
08:34:46 <shapr> listener: it's listed on the front page of his website.
08:35:06 <shapr> Vincenz: yay! what does your code look like now?
08:35:22 <Vincenz> let fib = 1 : 1: (zipWith (+) fib (tail fib))
08:35:23 <Vincenz> :)
08:35:34 <shapr> yay!
08:36:03 <shapr> I wonder if I could use that same trick with Haskore
08:36:19 <shapr> to offset a canon by one note
08:36:51 <Vincenz> hmm I tried the perm example on their site
08:36:59 <Vincenz> and the function remove doesn't work
08:37:20 <Vincenz> ah never mind :(
08:37:21 <Vincenz> :)
08:38:07 <shapr> ?
08:38:16 <Vincenz> remove x = filter (/= x)
08:38:17 <Vincenz> :)
08:38:32 <shapr> cheesy, but effective
08:38:54 <shapr> there's a set-wise subtract operator \\
08:39:23 <Vincenz> darn
08:39:24 <Vincenz> doesn't work
08:39:33 <shapr> you need to import List first
08:39:44 <shapr> try :module List
08:39:45 <shapr> in ghci
08:39:52 <Vincenz> remove x = filter (/= x)
08:39:52 <Vincenz> permutations [] = [[]]
08:39:52 <Vincenz> permutations xs = [x:p | x <- xs, p <- permutations (remove x xs)]
08:39:53 <shapr> then
08:39:57 <shapr> [1..9] \\ [3,5]
08:40:05 <Vincenz> I placed the filter inline
08:40:08 <Vincenz> and it doesn't work..
08:40:20 <Vincenz> (with lets of course...)
08:41:20 <Vincenz> perms [1, 2]
08:41:21 <Vincenz> []
08:41:24 <Vincenz> perms []
08:41:27 <Vincenz> some big error
08:41:33 <shapr> I don't think you can use let with pattern matching
08:41:36 <shapr> I think you have to load a file
08:41:42 <Vincenz> oh
08:41:43 <Vincenz> :(
08:42:07 <shapr> you could creat a file named Test1.hs or something
08:42:15 <shapr> edit it with vim, load it into ghci
08:42:24 * Vincenz nods
08:42:24 <shapr> and everytime you make some updates, do :reload
08:42:33 <shapr> or :r for a short command
08:42:58 <shapr> or you could script vim to kill ghci and restart it with the current file ?
08:43:06 * shapr has never tried scripting vim
08:43:11 <shapr> I'm used to scripting emacs though
08:43:22 <Vincenz> it's ok:)
08:43:24 <Vincenz> :r would work
08:44:17 <listener> shapr: does :reload ( in both hugs and ghci ) totally restart the interpreter? same state as start?
08:45:12 <shapr> no, it just reloads the current file
08:45:47 <Vincenz> hmm
08:45:48 <Vincenz> I can't load from directories with spaces
08:46:02 <Vincenz> not even if I use "dir"
08:46:10 <listener> so it's better to stop and restart the interpreter.
08:46:30 <listener> other wise things like pattern matching cases are still there.
08:47:52 <Vincenz> woo
08:47:56 <Vincenz> perms (perms [1..3])
08:48:47 <shapr> listener: no
08:49:06 <shapr> it's not better to stop and restart the interpreter
08:49:30 <shapr> Vincenz: maybe if you put quotes around the load argument
08:49:57 <listener> example: fac i = case i of
08:50:04 <listener> i==0->0
08:50:07 <Vincenz> shapr: no doesn't work
08:50:18 <listener> n->n* fac n-1
08:50:44 <listener> if you rewrite as fac i = n* fac n-1
08:50:54 <listener> then you can't be sure if it works for 1.
08:51:07 * listener thinks it is a dumb example but shows the point.
08:53:30 <listener> nhc only runs on Linux?
08:55:27 <ibid> no?
08:56:20 <listener> Sorry, meaning not on Windows?
08:59:19 <shapr> Vincenz: I'm off to work on my new office, I hope you've enjoyed the first steps of playing with Haskell :-)
08:59:41 <Vincenz> take care, and thanks :)
09:00:39 <shapr> glad I could help :-)
09:01:56 <listener> g2g Been a very intersting session. Thanks for the help. See you
09:02:08 <listener> arrivaderci. Aloha. au revior.
09:02:17 <listener> ta ta. g'day.
09:02:28 <listener> ....^C
09:02:39 <listener> sorry stuck on infinite recursion. Bye.
10:40:31 <Vincenz> let Vincenzknowledge = Vincenzknowledge * 2
10:40:32 <Vincenz> WOO
10:40:37 <Vincenz> I'm getting recursively smarter
10:43:24 <Marvin--> good on ya'
12:56:58 <kaninchen> hi to ll
12:56:59 <kaninchen> ll
12:57:00 <kaninchen> all
12:57:13 <kaninchen> baa I was never really good in typing :)
12:57:25 <Vincenz> how do you code then?
12:57:27 * Vincenz grins
12:57:42 <kaninchen> I do not code anymore :-)
12:57:48 <kaninchen> I have my slaves .... :)
12:57:53 <Vincenz> Neat
12:58:01 <Vincenz> do they get you coffee and such?
12:58:53 <kaninchen> btw I don't drink coffee but they do some exiting things :-)
12:59:04 <Riastradh> Exiting things?
12:59:18 <Vincenz> he means exciting
12:59:23 <Vincenz> fortunately I read typo
12:59:24 <kaninchen> you do not want to know it ! I asure you :-)
12:59:29 <kaninchen> ops
12:59:40 <kaninchen> I said that I cannot write ...
12:59:43 <Riastradh> Heheh.
13:00:03 <kaninchen> but my real question was. do we want to register #haskell ?
13:00:57 <ibid> i thought it is registered?
13:01:25 <kaninchen> really ?
13:01:31 <kaninchen> who registered it then ?
13:01:41 <ibid> at least it has been registered to my knowledge
13:01:43 <ibid> shapr?
13:02:10 <kaninchen> yep
13:02:16 <kaninchen> shapr was the founder
13:02:37 <kaninchen> type /msg Chanserv info #haskell and you get the information
13:02:46 <kaninchen> so my question was then answered ... :-)
13:03:07 <kaninchen> shapr if you are the founder, why don't you have op then ?
13:05:03 <ibid> why should he?
13:05:20 <kaninchen> because he registered the channel and is the founder ...
13:05:55 <ibid> so?
13:06:00 <kaninchen> ibid if you have the possibility between having op or not. what would you chose ?
13:06:09 <kaninchen> :s chose/choose
13:06:11 <ibid> on OPN and OFTC, no ops
13:06:23 <kaninchen> OPN ? OFTC ?
13:06:38 <ibid> on IRCnet everybody well known to behave should have ops
13:06:50 <ibid> sorry, meant Freenode instead of OPN
13:07:29 <ibid> OPN is an abbrev of the old name of Freenode
13:08:26 <buggs> it's a question of style and i like shapr's style :)
13:08:26 <kaninchen> so if you say everybody well known to behave should have ops, than why shouldn't shapr take his ops then ?
13:08:31 <kaninchen> hehe
13:08:36 <ibid> because we are not in IRCnet
13:08:41 <ibid> this is Freenode
13:09:05 <kaninchen> buggs: that's a possible attitude
13:09:30 <kaninchen> ahhh sorry forgot something :-)
13:09:42 <ibid> ops are good for channel maintenance on nets where there is no chanserv
13:09:56 <ibid> with chanserv, ops can be requested if necessary, and they are seldom necessary
13:10:01 <ibid> on IRCnet there is no chanserv
13:10:24 <kaninchen> ahh ok then shapr style is good :-)
15:16:58 * shapr laughs about "shapr style"
15:17:19 <Riastradh> 'shapr style?'
15:17:49 <shapr> Riastradh: earlier discussion about whether people should have ops on #haskell
15:18:19 <det> Riastradh: so I hear you learned pascal when you were 6
15:18:27 <shapr> hi det
15:18:41 <Riastradh> det - Er, I did?
15:18:44 <Riastradh> News to me...
15:18:55 <det> Riastradh: something like that..
15:19:06 <det> shapr: hello. how goes 822? :)
15:19:07 * Riastradh racks his brains for knowledge of Pascal...but can only think of stuff about Modula-3.
15:19:15 <shapr> I'm going to sleep early tonight...
15:19:20 <Riastradh> Where did you hear this?
15:19:23 <shapr> be back tomorrow
15:20:05 <det> Riastradh: #python I believe
15:20:27 <det> shapr: night.
15:20:37 <det> you crazy european
15:20:39 <Riastradh> C'est bizarre!  Was it radix or lament who said it?
15:20:46 <shapr> det: d00d, I'm from alabama
15:20:51 * shapr really goes to sleep now
15:21:39 <det> shapr: refering to the fact that it is afternoon for _sane_ people
15:21:59 <Riastradh> Better yet, what range of dates do you think this was said during?
15:22:55 <Marvin--> det: He's not a crazy European, he's a sane American, i.e. he's in Europe ;)
15:23:05 <det> :)
15:23:35 <det> Riastradh: last week
15:23:58 <Riastradh> Ack, I can't seem to find #python logs to search.
15:24:58 <Riastradh> Hm, well, anyways, I never learned Pascal.
15:25:37 <Riastradh> I -did-, however, start learning Scheme in fifth grade, when I was around 9 or so.
15:25:54 <det> Riastradh: maybe it was scheme when you were 9 :)
15:26:01 <Riastradh> Was that perhaps what you heard, and let your mind corrupt it to Pascal?
15:37:55 <det> ok
15:38:01 <det> how do you reverse search in less?
15:38:10 <det> n/m
15:38:42 <Marvin--> oh, yeah, sleep
15:38:44 <Riastradh> ?pattern, if I remember correctly.
15:38:47 <Riastradh> Bah.
16:11:38 * det returns
16:11:43 * Riastradh explorbs.
16:12:07 <det> @1047537279 <radix!~chris@adsl-64-123-27-105.dsl.austtx.swbell.net> Riastradh learned Scheme when he was 6
16:12:08 <det> @1047537285 <radix!~chris@adsl-64-123-27-105.dsl.austtx.swbell.net> *he's* one messed up dude
16:12:09 <det> :p
16:14:31 <det> I was only half distorted
16:33:07 <Riastradh> radix lies!
16:43:12 <palomer> :o
16:45:26 <buggs> AFAIR it was BASIC and he implemented LISP in it
16:48:15 <Riastradh> ?
16:50:33 <buggs> and of course when he was young, there was now BASIC, so he had to burn it on a ROM with a a needle that was heated by a candle
16:50:50 <buggs> s/now/no/
16:52:29 <Riastradh> ??
16:58:04 <buggs> just ignore me, i found out i debugged the wrong function the whole day ... which kinda got me confused about which monad i'm in
17:00:32 <det> buggs: You are in the universe monad
23:47:59 <shapr> wheee
23:48:07 <resolve> hey shapr!
23:48:34 <resolve> check out my gnus key down the bottom of http://www.emacswiki.org/cgi-bin/wiki.pl?SwitchToGnus
23:49:50 * shapr looks
23:50:38 <shapr> resolve: using escreen.el?
23:50:50 <resolve> yep!
23:50:55 <shapr> very spiffy
23:50:57 <resolve> it's handy
23:51:06 * shapr grabs
23:51:45 <shapr> resolve: have you tried ECB again?
23:51:51 <resolve> not yet :)
23:53:08 <shapr> resolve: since C-num and M-num work the same, I have:
23:53:21 <shapr> (global-set-key [(control ?1)] 'escreen-goto-screen-1) for 1,2,3,4,0
23:54:15 * shapr cranks up ghci
23:54:19 <resolve> i find m-<num> easier to hit, but yeah, that's a good idea
23:54:34 <resolve> currently i'm only using escreen for gnus, it's all transparent
23:54:48 <resolve> haven't thought about other places i want to preserve window configuration yet, though
23:55:20 <shapr> I've been running with input, output, notes, and mail/irc  screens
23:56:08 <resolve> input/output?
23:56:16 <shapr> I'm doing xslt
23:56:27 <resolve> my 'toggle notes key' handles the notes stuff without mucking up my buffers
23:56:35 <resolve> and the "irc screens" are handled by erc-track
23:56:43 <shapr> so I have xml input, xsl stylesheet, output and the xml source for an openoffice file I created in openoffice itself
23:57:35 <shapr> and I'm trying to get the output to match the openoffice created file
23:58:03 <shapr> hey, have you heard of Haskore?
23:59:13 <shapr> if I had a larger screen with a higher resolution, I'd probably go with less escreens and more windows
