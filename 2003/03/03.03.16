00:00:24 <shapr> aw, I missed dnm
00:00:24 <shapr> didn't see him
00:02:49 <resolve> haskore? nope
00:03:04 <resolve> i prefer the one-window-at-a-time philosophy most of the time
00:03:18 <resolve> sometimes i use 2, when i need to reference something while typing something else
00:03:29 <resolve> stuff like looking at a diff when filling in an changelog
00:08:05 <shapr> haskore is a scoring and music creation program in Haskell
00:08:27 <shapr> last time I started reading Godel, Escher, Bach I got distracted halfway through
00:08:29 <shapr> this time
00:08:35 <shapr> I have Haskore handy
00:08:44 <shapr> so I've been playing around with making my own canons
00:09:01 <shapr> it's really easy to make a canon
00:09:21 <shapr> for example, the Ssf module has a chunk of Stars and Stripes Forever 
00:09:26 <resolve> nifty
00:09:44 <resolve> the guy who looked after me when i did a week's work experience at linuxcare australia was into haskell and using it to compose music
00:09:45 <shapr> and creating a retrograde canon from it is as easy as "ssf :=: revM ssf"
00:09:59 <shapr> who was it?
00:10:17 * shapr tries to remember Haskore users in .au
00:11:08 <shapr> Haskore can save music to midi and csound
00:11:10 <resolve> http://meltin.net/hacks/haskell/
00:11:17 <shapr> oh cool!
00:11:22 <shapr> he's the guy who wrote HasChorus
00:11:40 <resolve> yep, he's cool :-)
00:15:48 <shapr> he's written a lot of elisp stuff too
00:18:05 <resolve> yeah, our university's eiffel courses uses his hacked up eiffel mode
00:18:10 <shapr> neat
00:21:44 <shapr> resolve: hey, can you play midi files? 
00:22:08 <resolve> i can once i install timidity
00:22:47 <shapr> http://kungens.kemi.fi/~shae/src/midi/
00:23:09 <shapr> ssf is the raw stars and stripes forever, and retro is the retrograde canon of it
00:24:28 <shapr> my task for today is to score King Friedriech's Royal Theme, and try to figure out Bach's canons 
01:20:05 <shapr> hi dnm 
01:20:17 <dnm> hey shapr
01:20:31 <dnm> so remember you asked me to write stuff for haskell-libs?
01:20:35 <shapr> yes?
01:20:39 <dnm> that doesn't seem like a bad idea.
01:21:04 <shapr> I like haskell-libs
01:21:51 <dnm> 5.04.3 have any major new frobnitzes that I should update from 5.04.1?
01:22:00 <shapr> dnm: are you already a developer on haskell-libs? if not, do you have an sf.net userid?
01:22:40 <shapr> iirc, there are some nice bugfixes in .2 and .3
01:23:25 <dnm> I'm not in haskell-libs as a developer. My SourceForger userid is "dmoniz", IIRC. Check vapour or beepcore-ruby projects.
01:25:26 <shapr> tada
01:25:32 <shapr> welcome to the collective.
01:25:42 <Marvin--> assimilation complete?
01:25:48 <shapr> Marvin--: mostly
01:26:20 <shapr> dnm: nifty stuff already in cvs is a web server with apache style plugins, the plugin stuff was written by Marvin-- 
01:26:40 <shapr> and we have an irc bot that needs a command parser, but works other than that
01:26:44 <shapr> written by Pseudonym
01:26:57 <shapr> and some email libs that I've been hacking on semi-successfully
01:27:17 <shapr> feel free to hack on anything in cvs
01:27:37 <shapr> dnm: did you have something specific in mind?
01:29:04 <shapr> oh, we have the haskellLibTracker by SyntaxPolice 
01:29:19 <Marvin--> andersca: gconf-editor is really neat
01:29:59 <Marvin--> needs search functionality though
01:30:48 <dnm> shapr: Eh, nothing that I specifically had allocated to Haskell per se, just things I tend to write in n programming languages for personal edification.
01:31:31 <resolve> i'm a bit disappointed with how gconf-editor is organised
01:31:45 <resolve> "apps" is far too logical, i would have preferred something like _HKEY_LOCAL_APPLICATIONS
01:31:47 <resolve> ;-)
01:32:52 * shapr laughs
01:33:12 <shapr> resolve: evil
01:33:33 <shapr> I like the bookmark ability in gconf-editor
01:33:38 <resolve> you guys tried galeon-snapshot yet?
01:33:51 <resolve> or did i ask that yesterday? i think i did :o)
01:33:59 <resolve> shapr: after about 12 hours i finally got mozilla and galeon compiled
01:34:09 <resolve> i think it's a wee bit faster, but not enough to make it easily noticable
01:34:24 <shapr> twelve hours??
01:34:34 <resolve> something like that, yeah
01:34:39 <resolve> this is on my laptop's celeron 1ghz
01:34:42 <shapr> oh
01:34:46 <shapr> I think it took me two hours
01:34:53 <shapr> and I had a really large speedup
01:34:55 <resolve> my desktop would do it a lot faster, but that's not where i need the speed so much :)
01:34:57 <shapr> maybe SMP makes a difference?
01:35:06 <resolve> yeah, i'll try it on my XP2000 and see if it makes a bigger difference
01:40:47 <dnm> You should all go and buy all the _Trans Am_ and _TRS-80_ albums you can.
01:41:40 <shapr> ?
01:41:59 <shapr> do they have publically available online tracks?
01:42:03 <shapr> er, legally
01:42:09 <shapr> dnm: have you tried Haskore?
01:42:32 <dnm> I know TRS-80 has snippets online in RealAudio and a few in MP3. Trans Am is likely to have same in some fashion.
01:43:07 <dnm> No, I haven't tried Haskore. Someone did mention it to me recently though. And some of the FFTW Haskell wrapper code.
01:45:19 <resolve> hmm
01:45:32 <shapr> dnm: http://kungens.kemi.fi/~shae/src/midi/ ssf.mid is direct from the Ssf module that comes with Haskore
01:45:37 <resolve-> test
01:45:40 <resolve> test
01:45:46 <resolve> shapr: erc-reuse-buffers nil
01:45:54 <shapr> and retro.mid is my first experiment with retrograde canons
01:46:01 <shapr> resolve: aha, thanks
01:46:40 <resolve> that might cause troubles when reconnecting
01:46:44 <shapr> resolve-: though a better solution is to have ercKey rebind itself to erc-next-track-buffer or whatever it's really called
01:47:09 <resolve> bit of a pain that it creates lots of channel buffers if you join and part, though
01:48:14 <shapr> dnm: retrograde canon with ssf is like this: (ssf :=: revM ssf) verbosely "ssf in parallel with ssf reversed"
01:49:19 <shapr> transposition (offset up or down by notes) is (Trans 5 ssf) 
01:50:38 <shapr> what things do you write in n programming languages for personal edification?
01:51:33 <resolve> hello world :-)
01:53:02 <Marvin--> yes, that's probably the only one
01:53:11 <Marvin--> unless n == 1
01:59:57 <dnm> shapr: Right now I'm thinking about a lot of a) highly optimized and/or unconventionally interesting data structures and algorithms code, b) crypto code in non-traditional languages (which is to say, not C, C++, Perl, Python, Java, Assembly), c) various "high-order" hacks.
02:01:59 <shapr> dnm: like what?
02:02:10 <shapr> multidimensional suffix trees?
02:02:21 <shapr> b sounds like fun
02:02:36 <shapr> got any examples of c?
02:02:49 <Marvin--> I don't see why crypto in Haskell would be harder than an imperative language, and surely not slower than e.g. Python, Perl or Java?
02:03:09 <Marvin--> s/than an/than in an/
02:03:22 <shapr> isn't there an rc5 implementation in haskell?
02:04:13 * Marvin-- hacks in some evms and raid support in partconf
02:09:30 <shapr> I just found a DES in Haskell
02:09:38 <shapr> downloaded, but haven't looked at it yet
02:14:45 <Marvin--> RSA in haskell is quite easy ;) the hard part is the prime numbers, of course
02:17:42 <shapr> hi Smerdyakov 
02:18:09 <shapr> ok, so far I've found RSA and DES in haskell
02:18:20 <dnm> Blowfish is out there.
02:18:36 <dnm> http://www.hcsw.org/haskell/
02:18:48 <shapr> cool, anything else?
02:18:49 <andersca> Marvin--: there's a patch in bugzilla that implements search. I haven't looked closely at it though
02:19:06 <Marvin--> andersca: neato
02:21:50 <shapr> Fractal: hey, you wrote Blowfish and friends in Haskell?
02:22:53 <dnm> shapr: URLs for DES and RSA?
02:23:39 <Marvin--> I have a dumb implementation of RSA somewhere
02:23:50 <shapr> rsa http://www.electronconsulting.com/rsa-haskell/
02:24:15 <shapr> des http://www.cs.bris.ac.uk/~bradley/publish/des_hs/deshs.tar
02:24:25 <shapr> I haven't looked at them yet though.
03:07:56 * shapr boings
03:46:10 <Igloo> HazGuard on my website contains (fairly crap IIRC) CAST5 code if that's any use
04:20:57 <andersca> Marvin--: ugh, I think I have to lower my spam threshold
04:21:03 <andersca> Marvin--: lots of stuff to dum@ coming through right now :/
04:22:41 <resolve> start to use +smtpcomments or if you have your own domain, just give out different email addresses
04:23:18 <resolve> almost all my spam comes directed to sendmail-usenet@mydomain (guess where i used that), and the address i had posted on my website
04:23:27 <Marvin--> andersca: procmail on piggy is broken
04:23:41 <resolve> now i use web&#0064;mydomain which should foil most harvesting bots
04:26:32 * Igloo raises an eyebrow at "First movements towards self-modifying code for specbranch."
04:32:38 <shapr> ??
04:54:48 --- mode: ChanServ set +o shapr
04:55:00 --- mode: shapr set +b *!*@*.interaccess.com
04:55:04 --- mode: shapr set -o shapr
05:18:52 <Marvin--> interaccess?
05:19:38 <shapr> yup
05:19:54 <Marvin--> whazzat?
05:20:00 <shapr> thaddeus l. olczyk
05:20:14 <andersca> whozzat?
05:20:24 <Marvin--> oh :)
05:20:32 <Marvin--> andersca: annoying fellow
05:20:49 <Marvin--> haskell-sucks-because-it-doesn't-do-what-I-think-it-should-do-olczyk
05:20:52 <shapr> aka listener, bubba101, TLO, etc
05:21:17 <shapr> my patience with him has passed.
05:21:21 <Marvin--> oh, he's one of those annoying multi-nick-people
05:21:34 <Marvin--> we had tons of problems with people like that on our mud
05:25:56 <shapr> what's the deal with multi-nick-people?
05:26:53 <shapr> I would guess once someone starts to be reviled under one nick, they switch so people are nice to them again
05:27:11 <Marvin--> probably
05:27:51 <andersca> shapr: that is so true
06:41:56 <pseiko> hi all
06:42:05 <shapr> hiya pseiko 
06:42:09 <shapr> what's up?
06:42:51 <shapr> o3: any plans to release an update ghc5.04.3 compatible runtime loader?
06:43:21 <pseiko> :-) i'm a little confused, the ghc internals are as beasty as i was told
06:44:01 <shapr> what are you trying to do?
06:45:43 <pseiko> i have to adapt parser, typechecker and compiler as well :-(
06:46:54 <pseiko> because i want to build in the OHaskell features
06:51:20 <shapr> oh yeah
06:51:36 <shapr> pseiko: have you been trying small things first?
06:51:43 <shapr> pseiko: what have you learn so far? cool stuff?
06:52:01 <shapr> you may want to grab a copy of Manuel Chakravarty's GHC Internals notes and update them as you
06:52:04 <shapr> go along
06:52:16 <shapr> in fact, you could copy them to a wiki and update them, and then people would argue and fix them :-)
06:52:55 <pseiko> good idea
06:53:05 <pseiko> but at first i have to understand this baby :-)
06:54:40 <pseiko> problem: there are no haskell archives in the web
06:55:31 <pseiko> e.g. if you are looking for an old release of hugs you are really lost
06:59:38 <shapr> pseiko: have you asked the Hugs maintainers?
07:00:31 <pseiko> no, but i will do so :-) sorry, i have to leave, will be back soon
07:23:24 * shapr boings
07:23:48 * shapr tries to figure out how to do database calls in HWS-WP
07:27:21 <ibid> hws-wp?
07:31:42 <shapr> haskell web server - with plugins
07:31:43 <jlouis> never heard of it either
07:31:48 <ibid> ah
07:32:10 <shapr> Marvin-- added an apache style loadable module system to Simon Marlowe's Haskell Web Server
07:32:26 <shapr> it's in the cvs tree of haskell-libs
07:32:29 <ibid> hm, would there be a posgresql binding for haskell? ;-)
07:32:35 <shapr> yes, in fact there is
07:32:43 <ibid> hm
07:32:45 <shapr> that's what I'm trying to stick into hws-wp
07:32:53 <ibid> url?
07:32:56 <ibid> or other pointer
07:33:01 <shapr> sf.net/projects/htoolkit/
07:33:11 <ibid> (please use proper urls;-)
07:33:15 <shapr> ok ok
07:33:19 <shapr> http://sf.net/projects/htoolkit/
07:33:23 * Marvin-- notes this tab got blue again
07:33:33 <ibid> thanks
07:33:41 <shapr> Marvin--: I was using your name in vain
07:33:50 <Marvin--> in vain?
07:33:50 * shapr grins
07:34:25 <shapr> something of a religious joke, nm
07:34:52 <shapr> not funny enough to explain 
07:35:59 <Marvin--> ri...ight
07:36:30 * Marvin-- looks at how much a boxed set of season 1 B5 DVDs costs and goes "ynk"
07:37:00 <shapr> how much?
07:37:32 <Marvin--> 799 SEK
07:37:40 <Marvin--> and that does *not* include the pilot
07:37:52 <Marvin--> which is on a DVD of its own and costs 180 SEK
07:37:54 <Marvin--> sheesh
07:37:59 <shapr> urf
07:38:05 <shapr> of course..
07:38:12 <shapr> a full season of ST:TNG is more than that
07:38:14 <Marvin--> still, it's the whole first season...
07:38:21 * Marvin-- drools
07:38:22 <shapr> $110 euro
07:38:32 <Marvin--> too bad my only DVD player is the one in the laptop
07:38:38 <shapr> we have a playstation 2
07:38:45 <shapr> it was cheaper than buying a DVD player
07:38:53 <Marvin--> lol!
07:38:59 <Marvin--> but is it region free?
07:39:04 <shapr> I think so
07:39:12 <shapr> plus you can run linux on it
07:39:53 <Marvin--> I watched a blooper show yesterday and there was this great blooper from B5 :P
07:40:06 <Marvin--> "Where's general Haig?" "General Haig is doing Deep Space Nine, so you're stuck with me"
07:40:08 <shapr> Marvin--: ok, stupid question, I want to try writing something like freshmeat with hws-wp
07:40:12 * shapr laughs
07:40:45 <shapr> do you think I should hack up a Haskell Scripting Pages plugin?
07:41:06 <shapr> what's the best way to stick together database calls and hws-wp?
07:41:22 <Marvin--> you could use the CGI plugin
07:41:54 <Marvin--> database calls? There's no way to make it efficient if that's what you mean, but the server is multithreaded, isn't it?
07:42:52 <shapr> I don't really care about efficiency
07:42:57 * Marvin-- ponders having a cup of coffee
07:42:57 <shapr> hm
07:43:15 <Marvin--> but a scripting plugin would be awesome
07:43:23 <Marvin--> don't quite understand how it'd work though
07:43:43 <shapr> java server pages are actually classes flipped inside out
07:43:54 <Marvin--> would it in turn load dynamic objects, or would it call on some external interpreter to execute?
07:44:39 <shapr> my first thought is that the scripting plugin should compile the .hsp into a .o files
07:44:43 <shapr> load that, and execute it
07:45:06 <shapr> hm, does that mean you'll end up with a zillion mod_page kind of plugins?
07:46:17 <shapr> java server pages execute everything between <% %> tags and expect it to turn into a string
07:46:18 <Marvin--> how's the weather up there btw, we've got beautiful spring weather down here
07:46:36 <shapr> after which all the pieces are concat'ed and returned as one single string
07:46:48 <shapr> the snow is finally melting
07:46:55 <Marvin--> compiling JIT will be incredibly slow
07:46:58 <shapr> we had lovely blinding sun yesterday
07:47:02 <shapr> Marvin--: only the first time
07:47:10 <shapr> after that it'll be as fast as loading a .o file
07:47:11 <Marvin--> yeah of course you'd cache it, but still
07:47:23 <Marvin--> but then you have to use the plugin interface anyway
07:47:30 <shapr> better idea?
07:47:53 <shapr> I wonder how the HSP for IIS works...
07:48:11 <Marvin--> no idea
07:48:24 * shapr reads the PDF
07:48:25 <Marvin--> there's mod_haskell for apache too, but that requires the hugs source iirc
07:49:07 <shapr> yah, it just calls hugs to interpret
07:49:14 <shapr> hws-wp could be much better
07:51:16 <Marvin--> gnngh, I hate writing programs with user interfaces
07:51:21 <Marvin--> half the bloody code is error handling
07:51:47 <shapr> you have the Maybe monad
07:51:49 <shapr> oh wait
07:51:53 <shapr> you're not writing in Haskell, eh?
07:52:03 <Marvin--> no, this is C
07:52:20 <Marvin--> and I'm not talking about just functions returning error codes and stuff
07:52:40 <Marvin--> most of the code is figuring out whether the error is fatal and presenting the errors in a reaonable way to the user
07:53:31 <Marvin--> http://193.11.232.159:8080/partconf.templates
07:54:20 <shapr> whee funn
07:54:28 <Marvin--> saay now that you opened up that URL, you might as well comment on the messages ;)
07:54:44 * shapr reads
07:55:52 <shapr> for "Template: partconf/partitions" you need a comma after create on the last line
07:56:35 <Marvin--> oh, right, Swedishism
07:56:53 <Marvin--> you don't put commas before "och" in an enumeration in Swedish
07:57:04 <Marvin--> "1, 2, 3 och 4"
07:57:28 <shapr> for "Template: partconf/create-filesystem" are you sure that the Default choice will always be one of ${FSCHOICES} ?
07:58:05 <shapr> what if it's not? does your code explode trying to set an non-existing option to selected?
07:58:10 <Marvin--> if ext2 isn't available, something's broken, and in that case there won't be a default
07:58:21 <shapr> ok
07:58:23 <Marvin--> no, cdebconf handles the default not being among the choices
07:59:00 <shapr> ok
07:59:13 <Marvin--> mmm, coffee
08:00:21 <shapr> looks good
08:00:53 <shapr> I don't see anything else
08:01:02 <Marvin--> wonder if it's possible to extend the ramdisk after creating swap space
08:01:24 <Marvin--> oh well, not my problem, rather the problem of the poor m68k people
08:02:28 <shapr> ya know, TAL would be nicest for HSP
08:02:38 <shapr> <% %> tags just suck
08:02:47 <Marvin--> TAL?
08:03:18 <shapr> template attribute language
08:03:28 <shapr> it's what Zope Page Templates use
08:03:39 <Marvin--> oh
08:11:34 <shapr> hi tmoertel 
08:11:35 <shapr> what's up?
08:11:46 <tmoertel> not too much, just having fun
08:11:50 <shapr> fun code?
08:11:59 <shapr> fun games?
08:12:03 <tmoertel> fun code
08:12:20 <shapr> whatcha writing?
08:12:20 <tmoertel> I was at a PerlMongers meeting last week ...
08:12:36 <tmoertel> and I tried to get the regulars to take a look at Haskell
08:12:45 <tmoertel> I was only partially successful
08:12:51 <shapr> what happened?
08:13:29 <tmoertel> for fun, I wrote a LayoutRule perl module
08:13:45 <shapr> does prettyprinting of Haskell?
08:13:54 <shapr> or does Layout of Perl?
08:13:58 <tmoertel> it brings Haskell-style layout-based blocks and statements to perl
08:14:00 <Janni> hi, guys
08:14:01 <shapr> cool!
08:14:02 <shapr> hi Janni
08:14:09 <tmoertel> i.e., no need for }'s or ;'s
08:14:26 <opet> tmoertel: are you tmoertel from k5?
08:14:33 <tmoertel> opet: yes
08:14:56 <shapr> the famous XSLT, Perl, and Haskell article
08:15:17 <Marvin--> tmoertel: sort of like Python's layout rules?
08:15:35 <shapr> speaking of which, I learned XSLT two weeks ago, and have spent many hours working with it.
08:15:44 <Marvin--> shapr: sucks to be you
08:15:49 <shapr> Marvin--: yah, pretty much
08:15:49 <tmoertel> Marvin--: yes, but I based the rules on Haskell, since I don't use Haskell
08:15:58 <shapr> imho, XSLT is like digging holes with a spoon
08:16:05 <opet> ahh.. I knew I recognised the nick from somewhere
08:16:10 <Marvin--> a dull spoon
08:16:13 <tmoertel> shapr: XSLT isn't bad if you can use extensions
08:16:21 <resolve> shapr: you said you were working with it earlier?
08:16:24 <shapr> but sometimes the bowl breaks off in interesting ways and you get to dig with the stick.
08:16:26 <resolve> input and output screens?
08:16:33 * resolve grins
08:16:52 <shapr> tmoertel: yes, I agree, I've given in to grep :-)
08:17:28 <shapr> resolve: yah, I needed xml input, xsl, and xml output screens. and a notes buffer for recording what I learned
08:18:14 <ibid> shapr: i see nothing database-related in http://htoolkit.sourceforge.net/
08:18:26 <shapr> tmoertel: have you seen http://fxsl.sf.net/ ?
08:18:34 * tmoertel looks . . .
08:18:58 <shapr> ibid: it has MySQL and PostgreSQL modules
08:19:03 <shapr> ibid: look in the cvs tree
08:20:05 <tmoertel> shapr: yes, I looked at the paper last year. it would seem that there is much progress since
08:20:30 <ibid> one would expect the web page talk about that:-)
08:20:49 <shapr> ibid: I agree, I've wondered why it doesn't mention the HSQL stuff
08:20:55 <resolve> shapr: so are you applying xslt to something real world?
08:21:09 * resolve knows nothing bar a very vague outline of what it's supposed to do
08:21:26 <shapr> resolve: I guess so, I'm getting paid to write up an XSLT to turn a custom xml format into OOo docs
08:21:32 <shapr> (OpenOffice.org)
08:21:42 <resolve> interesting
08:22:01 <shapr> tmoertel: I didn't mean to interrupt your PerlMongers story, I wanna hear more :-)
08:22:23 <tmoertel> shapr: I'm giving a tech talk at their next meeting
08:22:38 <tmoertel> shapr: so I think I'm going to talk about the LayoutRule module
08:22:41 <shapr> cool
08:22:52 <tmoertel> shapr: and perhaps try to port other Haskellish things to Perl
08:22:59 <shapr> monads!
08:23:07 * shapr grins
08:23:23 <tmoertel> first I'd have to port the type system !
08:23:38 <tmoertel> ;-)
08:23:53 <shapr> hm, it wouldn't be much like perl after that...
08:23:58 <Marvin--> tmoertel: what's the difference between the LayoutRule module and Python's layout, then?
08:23:59 <shapr> what would you like to port?
08:24:27 <resolve> yeah, i was wondering similar, marvin
08:24:33 <tmoertel> Marvin--: If I knew what's Python's layout rules were, I might be able to tell you. ;-)
08:24:41 <resolve> haskell's layout rules seem like a trivial matter compared to some of the other stuff it offers over perl
08:24:50 <resolve> tmoertel: similar
08:24:52 <tmoertel> resolve: quite right
08:25:05 <Marvin--> tmoertel: pretty simple actually
08:25:08 <Marvin--> if expression:
08:25:10 <Marvin-->   stmts
08:25:11 <resolve> show them what lazy & partial evaluation can do
08:25:12 <resolve> :)
08:25:23 <Marvin--> or
08:25:26 <tmoertel> shapr: 1st class lazy lists would be nice to have
08:25:27 <Marvin--> if expression: stmt
08:26:06 <Marvin--> that's really all there is to it, indents after colons
08:26:08 <tmoertel> Perl has an if expression in the form of <test> ? <true_val> : <false:val>
08:26:50 <Marvin--> C style, yes, Python doesn't have that, but because of how booleans and 'and' and 'or' work, you can write  <test> and <true_val> or <false_val>  if you want
08:26:52 <tmoertel> Marvin--: whoops! got confused in the crosstalk
08:27:38 <Marvin--> tmoertel: ?
08:28:13 <tmoertel> Marvin--: you were explaining Py's layout rule and I thought you were saying what Haskellisms you wanted ported to Perl
08:28:29 <tmoertel> Perl has no layout rule by default
08:28:36 <tmoertel> It uses { and } to open an close blocks
08:28:48 <tmoertel> And all statements (except the last in a block) must be closed with a semi ;
08:29:01 <Marvin--> tmoertel: oh, no I'm not a perl user, I was trying to figure out what parts of the haskell layout rules you had put in LayoutRule that's different from what python does
08:29:23 <tmoertel> Marvin--: my guess is that they are similar
08:29:45 <tmoertel> LayoutRule uses {| to open a block (eqiiv to Py's :)
08:30:09 <tmoertel> The next non-whitespace char defines the block's active column
08:30:22 <tmoertel> The block remains open until a non-whitespace char appears in an earlier col
08:30:44 <Marvin--> sounds exactly like python
08:31:41 <Marvin--> now if I could remember what my lexer looked like when I wrote an interpreter for a python-like language, I'd be even more helpful ;)
08:32:52 <Marvin--> I think that python requires that the dedent is as long as the indent
08:33:01 <Marvin--> so that when the block ends, you're back in the same column as the if
08:34:05 <tmoertel> Haskell and LayoutRule.pm do it differently:
08:34:29 <tmoertel> Any char to the left of the active column closes the block
08:34:55 <Marvin--> yes, sure, but take a monadic example...
08:34:59 <Marvin--> do m1
08:35:02 <Marvin-->    x <- do m2
08:35:09 <Marvin-->    m3
08:35:31 <Marvin--> the m3 must be aligned with the x, no matter what the m2 "block" looks like
08:35:45 <Marvin--> it's a bit different in Haskell and Python because, well, Python is imperative :-)
08:36:55 <Marvin--> Python disallows something like
08:36:58 <Marvin--> if foo:
08:37:00 <Marvin-->     bar
08:37:01 <Marvin-->   baz
08:47:40 * shapr reads HSP.pdf
08:48:02 <tmoertel> HSP?
08:48:09 <tmoertel> Haskell Server Pages ?
08:48:11 <shapr> yup
08:48:27 <shapr> I'm trying to figure out how to stick together the new postgresql bindings in HToolkit and HWS-WP
08:48:43 <shapr> I want to have something like freshmeat.net for Haskell
08:48:51 <shapr> but I want to *cache* the libraries
08:48:58 <shapr> since they have a habit of disappearing off the 'net forever
08:49:21 <shapr> and I want wiki-style any-user-editable entries
08:49:55 <shapr> tmoertel: have you seen HWS-WP?
08:50:21 <tmoertel> I was looking thru the CVS a few days ago
08:50:32 <tmoertel> but haven't seen it running
08:50:32 <shapr> I wonder if I can rip out HSP wholesale and stuff it in as a plugin
08:51:09 <tmoertel> it would be nice to be able to split it out into a container of sorts
08:51:26 <shapr> ?
08:52:17 <tmoertel> it would be nice to have Java-style "containers" in which other haskell-components could live
08:52:29 <shapr> ah
08:52:35 <shapr> good point
08:52:39 <tmoertel> the containers could be connected to the web server but live in a separate space (or on a different server)
08:52:57 <shapr> that would be nice
08:52:59 <tmoertel> so the plug-in would be a connecter to the container
08:53:10 <shapr> would require some sort of RPC
08:53:54 <tmoertel> yup
08:54:05 <shapr> I'd like to see XMLRPC support
08:54:38 <tmoertel> it would be nice to have a communications layer that could use RPC for remote containers
08:54:46 <tmoertel> and yet scale back to local call for co-resident containers
08:57:39 <Vincenz> Hello
08:57:59 <shapr> hi Vincenz
08:58:08 <shapr> tmoertel: how could you do that?
08:58:16 <shapr> er "how could that be done" ?
08:58:28 <tmoertel> all calls would look local
08:58:42 <tmoertel> but if the container was remote, the comm-layer would make local proxies
08:58:56 <tmoertel> that communicate with the remove container
08:59:28 <shapr> I've been trying to figure out how to do that with TwistedHaskell
08:59:38 <tmoertel> TH?
08:59:41 <shapr> how do you make decent local proxies that look like the real thing?
09:00:23 <shapr> tmoertel: a Haskell implementation of Twisted.Spread from http://www.twistedmatrix.com/products/spread
09:00:34 <tmoertel> you could write them by hand for each container-resident library
09:00:49 <tmoertel> and the user could use the proxy-stubs for a remote container or the
09:00:58 <tmoertel> real local version for co-residency
09:01:17 <tmoertel> or -- dreaming -- 'deriving RemoteProxy'
09:02:32 <shapr> Template Haskell could do that
09:02:58 <tmoertel> Interesting ...
09:03:16 <shapr> Igloo showed me some cool code that gave a proof of concept for "deriving XML"
09:04:25 <shapr> Template Haskell is powerful stuff
09:04:41 <shapr> the paper shows zipN, liftMn, that kind of stuff
09:05:04 <tmoertel> not to mention a type-safe printf for Haskell
09:05:07 <shapr> that too
09:08:41 <shapr> I just want a library tracker that uses postgres atm
09:09:04 * shapr gives in to CGI
09:15:08 * tmoertel must depart for a while . . .
09:15:11 <tmoertel> bye
09:16:12 <shapr> cya!
09:16:46 <shapr> Vincenz: any new Haskell questions?
09:16:56 <Vincenz> hmm not at the moment no :)
09:17:00 <Vincenz> too busy refactoring c++-code for work
09:29:21 <shapr> ok
09:47:38 * shapr plays with WASH-CGI
09:50:46 <Marvin--> cool, four gold medals for Sweden
09:51:34 <shapr> yay sverige!
09:52:10 <Marvin--> women's high jump, men's high jump, women's pentathlon and men's triple jump
09:55:58 <buggs> pantathlon what a good name for a processor ...
09:56:20 <Marvin--> penta as in five, duh
09:56:58 <buggs> like in 586
09:57:22 <shapr> pantathlon sounds like an athlon that's "pants"
09:57:39 <shapr> that being a UK word for "low quality"
09:57:57 <buggs> ya ok i misspelled, i am deeply sorry
09:58:23 <shapr> no, I think it's a cool word :-)
09:58:30 <shapr> misspellings sometimes get nifty
10:10:12 <shapr> buggs: whatcha working on?
10:10:50 <buggs> still working on the melcuk based semantic grep
10:12:03 <buggs> think i will start to port it to haskell this week
10:12:06 <shapr> yay
10:13:18 <buggs> you still working on that commercial programm ?
10:13:24 <shapr> ?
10:13:45 <shapr> I'm trying to figure out WASH-CGI at the moment
10:14:34 <buggs> thought you did a project for some company
10:14:53 <shapr> in Haskell? I wish.
10:19:12 <buggs> i dunno but i could grep my logs to tell you ;)
10:19:31 <buggs> maybe just my memory was shot by alpha particles
10:19:40 <shapr> I've been working on some XSLT for a client
10:20:09 <buggs> hey that's a functiolnal language, so don't cpmplain
10:20:24 <buggs> just implement haskell in it and go go go
10:21:32 <shapr> heh
10:21:43 <shapr> have you seen http://fxsl.sf.net/ ?
10:21:57 <shapr> someone already wrote bits and pieces of Haskell in XSLT
10:22:07 <shapr> thing is, this xsl will be maintained by my clients
10:24:24 <buggs> you have to see it as an investment in your future
10:24:39 <buggs> next time they let you do it in haskell from the beginning
10:25:23 <shapr> heheh
10:25:36 <shapr> my clients just jumped from visual basic to java
10:25:45 <shapr> I don't want to scare them off :-)
10:25:50 <buggs> lol
10:26:36 <buggs> interestingly they didn't move to c#
10:26:50 <shapr> they're moving towards open source and linux
10:26:57 <shapr> I pushed them really hard
10:27:08 <shapr> they used to use microsoft stuff exclusively
10:27:30 <shapr> I saved their butts by developing a website for an EU Project in three weeks using Zope
10:27:33 <shapr> on Linux
10:28:54 <shapr> it's a decent website for being my first zope website
10:29:27 <shapr> http://www.education-observatories.net/lchange/index.pt
10:30:06 <Marvin--> woohoo, partconf seems to be working
10:30:09 <shapr> yay!
10:30:15 <Marvin--> http://193.11.232.159:8080/di-partconf-result.png
10:31:05 <shapr> whee!
10:35:24 <Janni> re
10:35:33 <shapr> y0
10:53:59 * shapr gets frustrated at WASH-CGI
10:55:35 * Marvin-- looks at xpde.com and goes "iiih"
10:58:26 <shapr> yah, really
10:58:26 <shapr> ewww
11:01:55 * shapr grombles
11:02:01 <shapr> bitz missing from WASH-CGI 1.2
11:02:09 <shapr> looks like some of the subdirs didn't get included in the distribution
11:03:16 <Marvin--> what I don't get is how they can have so incredibly much time to spend on this... I mean, it looks *exactly* like windows
11:03:29 <Marvin--> and they've written lots and lots of accessory programs too
11:03:34 <Marvin--> like the task manager and calculator and stuff
11:04:32 <Marvin--> http://www.getfreereports.com/images/mirror/turnoff.jpg  "turnoff" indeed
11:04:53 <shapr> very scary
11:05:03 <Marvin--> these people are insane
11:05:07 <Marvin--> INSANE I TELL YOU
11:05:14 <shapr> yup
11:05:19 <shapr> they could be doing something useful
11:05:38 <Marvin--> like making GNOME or KDE prettier
11:05:49 <Marvin--> or writing useful programs
11:09:51 <Marvin--> okay, they are not just insane, they're mentally ill
11:09:57 <Marvin--> *they've reinvented notepad*
11:10:11 <Vincenz> LOL
11:10:17 <Marvin--> http://www.getfreereports.com/images/mirror/notepad.jpg
11:11:57 <Marvin--> ah, they've done it in Kylix... not so strange that it has the exact look& feel of windows then
11:12:22 <Vincenz> that;s just xp, no?
11:14:11 <Marvin--> if the screenshots are XP with theme, it's a very good hoax :)
11:15:10 <Riastradh> That's -not- XP?!
11:15:31 <Marvin--> XP Desktop Environment
11:15:35 <Marvin--> for X
11:15:36 <Marvin--> or so they say
11:15:49 <Marvin--> www.xpde.com
11:16:38 * Riastradh can't connect.
11:17:15 <Marvin--> it's slashdotted ;)
11:17:23 <Marvin--> but the screenshots are mirrored on the above place
11:18:32 <Riastradh> Since I can't connet, would you mind telling me what this 'XP Desktop Environment' is?
11:19:15 <Marvin--> it's a desktop environment for X that looks like XP with the classic theme
11:19:25 <Riastradh> For 'X'?
11:19:31 <Marvin--> X Window System
11:19:37 <Marvin--> Linux
11:20:04 <Riastradh> OK, just making sure it was X11 -- there are lots of things that 'X' refers to.
11:20:09 <Riastradh> Ewww.
11:20:10 <Marvin--> ah
11:54:15 * shapr tries the CGI library that comes with GHC
12:13:52 <Janni> re
12:14:16 <shapr> hi Janni 
12:14:26 <shapr> has anyone used the CGI lib that comes with GHC?
12:26:31 <ludde> how can I implement a hGetLine :: Handle -> IO String ?
12:26:43 <shapr> implement it?
12:26:48 <ludde> yeah, but how
12:26:54 <shapr> you want to write your own hGetLine?
12:26:57 <Vincenz> openup notepad?
12:27:01 <ludde> there is no hGetLine
12:27:11 <shapr> hm, I thought there was.
12:27:27 <ludde> hmm
12:27:28 <ludde> maybe there is
12:27:31 <ludde> google shows something
12:27:43 <ludde> ah, module IO
12:28:01 * shapr fights with CGI.lhs
12:28:56 <Vincenz> UPPERCUT!!!
12:29:05 <ludde> tiger uppercut!
12:29:06 * shapr falls over unconscious
12:29:07 <ludde> yoga flame!
12:29:10 <shapr> CGI wins!
12:29:17 <ludde> or what did they say
12:29:24 <ludde> har-yoken
12:29:24 <shapr> oogaa fire!
12:29:38 <shapr> master combo!
12:29:43 <shapr> ring out
12:29:44 <ludde> :)
12:29:53 <shapr> finish him!
12:30:02 <shapr> babality
12:30:19 <shapr> I love playing those games
12:30:23 <ludde> :)
12:31:14 <shapr> I was third best mortal kombat player in a city of a million people
12:31:22 <ludde> oh, cool
13:00:24 <dnm> shappr
13:00:26 <dnm> err
13:00:29 <dnm> you still around?
13:01:21 <jlouis> he is playing some friggin game :)
13:01:29 <Vincenz> jup
13:01:33 <Vincenz> mortal kombat against CGI
14:10:08 <shapr> dnm: what?
14:11:02 * shapr goes back to his movie
15:56:16 <ChoJin> what is the flag to produce debug info with ghc?
15:58:21 <andersca> -g ?
15:58:55 <ChoJin> no :)
16:00:22 <andersca> ok
16:37:00 <Pseudonym> What do you want debug info for?
16:37:05 <Pseudonym> Prove your programs correct!
16:37:37 <Igloo> Because no-one has proven GHC correct  :-)
19:18:39 * emu proves his program correctly destroys the world
19:18:56 <emu> with a horde of nasal demons
19:29:17 <Pseudonym> I haven't proven my prover correct yet.
19:37:00 <emu> that has puzzled me
19:37:13 <emu> but then goedel came along..
19:38:25 <emu> not quite in that order
21:36:11 <inkedmn> ok, so i'm going to attempt to write a merge sort in haskell...
21:36:28 <inkedmn> you think i'd need a "split" function and a "merge" function?
21:53:42 <Pseudonym> Something like that, yes.
21:53:59 <Pseudonym> You need some way to create runs, then some way to merge them.
21:54:41 <inkedmn> ok
21:54:58 <inkedmn> just trying to wrap my head around how it actually works...
21:55:01 <Pseudonym> Sure.
21:55:11 <Pseudonym> Do you have any more spec than this?
21:55:17 <Pseudonym> Or is this just for your own enjoyment?
21:55:25 <inkedmn> just for fun/edification
21:55:28 <Pseudonym> Cool.
21:55:40 <Pseudonym> If you just want something that works, there's a lot of code out there. :-)
21:55:47 <inkedmn> yeah, i figured
21:56:04 <Pseudonym> Could I suggest that for a first cut, an easy way to make runs is this:
21:56:12 <inkedmn> i'm an imperative guy (java/python) and i'm trying to make sense of all this "functional programming" broo-haha :)
21:56:12 <Pseudonym> split xs = map (:[]) xs
21:56:26 <Pseudonym> They're not very good runs, but they'll work.
21:56:30 <Pseudonym> You can make better runs later.
21:56:52 <inkedmn> ok, can you "translate" that into plain english for me?
21:56:57 <inkedmn> i'm still learning the syntax
21:57:00 <Pseudonym> Sure.  You know about operator sections?
21:57:12 <inkedmn> haven't heard of that, no
21:57:18 <Pseudonym> Ah, OK.
21:57:40 <Pseudonym> (+1) is the function which adds one to a number.
21:58:04 <Pseudonym> (1-) is the function which subtracts a number from one.
21:58:09 <Pseudonym> Seen that before?
21:58:31 <inkedmn> i think so, yes
21:58:42 <Pseudonym> Right.  You can think of it like this:
21:58:47 <Pseudonym> (+1) = f where f x = x + 1
21:58:55 <Pseudonym> (1-) = f where f x = 1 - x
21:59:01 <inkedmn> ok
21:59:15 <Pseudonym> There's also the (+) form.
21:59:21 <Pseudonym> (+) = f where f x y = x + y
21:59:29 <Pseudonym> Anyway.
21:59:39 <Pseudonym> (:[]) is the function which conses an element onto [].
21:59:46 <Pseudonym> Effectively, it's the same as this:
21:59:51 <Pseudonym> split xs = [ [x] | x <- xs ]
22:00:09 <Pseudonym> Actually, I like the list comprehension version better now that I look at it.
22:00:16 <inkedmn> ok
22:00:28 <Pseudonym> You turn your list into a list of single-element lists.
22:00:50 <Pseudonym> Since single-element lists are always sorted, instant merge runs.
22:01:13 <inkedmn> ok
22:01:18 <Pseudonym> Makes sense?
22:01:32 <inkedmn> so, split returns a list of single element lists
22:01:36 <Pseudonym> Right/.
22:01:41 <Pseudonym> split :: [a] -> [[a]]
22:01:49 <inkedmn> now how would that work with merge?
22:01:55 <inkedmn> doesn't merge need 2 lists?
22:02:08 <Pseudonym> Have you coded merge sort in an imperative language before?
22:02:50 <Pseudonym> If so, did you do it bottom-up or top-down?
22:05:35 <inkedmn> no, i haven't
22:05:43 <inkedmn> (sorry, stepped away for a sec)
22:05:51 <Pseudonym> That's OK.
22:06:01 <Pseudonym> Well, there are two general ways to implement merge sort.
22:06:18 <Pseudonym> The top-down way looks something like this:
22:06:21 <Pseudonym> msort [] = []
22:06:24 <Pseudonym> msort [x] = [x]
22:06:38 <Pseudonym> msort xs = let (xs1,xs2) = split xs in merge (msort xs1) (msort xs2)
22:06:44 <Pseudonym> For suitable values of split and merge.
22:06:54 <Pseudonym> That's what you had in mind?
22:07:08 <inkedmn> hmm...
22:07:45 <Pseudonym> The idea is you split the list in two, recursively sort the halves, then merge them.
22:07:47 <inkedmn> are xs1 and xs2 the first two elements in xs?
22:08:00 <Pseudonym> No.
22:08:07 <inkedmn> ok, didn't think so
22:08:11 <Pseudonym> xs1 and xs2 is xs "split".
22:08:29 <Pseudonym> You want something where length (xs1 ++ xs2) == length xs
22:08:34 <inkedmn> yeah
22:08:38 <Pseudonym> And xs1 and xs2 contain all of the elements of xs.
22:08:46 <inkedmn> ok
22:08:52 <Pseudonym> Roughly, you want to split xs in half.
22:09:03 <Pseudonym> OK, that's top-down.
22:09:03 <inkedmn> ok
22:09:21 <Pseudonym> With bottom-up, you split xs into runs, which are sorted sub-lists.
22:09:43 <Pseudonym> In my example above, the first set of runs are single-element lists.
22:10:13 <Pseudonym> Once you have a set of runs, you pull them out two at a time, merge them, then insert the merged run back in the list.
22:10:33 <Pseudonym> Keep going until you only have one run.
22:10:48 <inkedmn> sorry, could you define "run" for me? i'm having trouble inferring the definition
22:11:15 <Pseudonym> OK.  When you split xs in the top-down approach, then merge sort the two halves, you end up with two sublists which are sorted.
22:11:27 <inkedmn> ok
22:11:33 <Pseudonym> In bottom-up merge sort, you actually produce a number of sublists which are sorted.
22:11:45 <Pseudonym> Not just two, necessarily.
22:11:56 <inkedmn> ok
22:12:10 <Pseudonym> In the example above, I suggested single-element lists.
22:12:18 <inkedmn> yeah
22:12:24 <Pseudonym> An example might help.
22:12:28 <Pseudonym> Give me a list to sort.
22:12:48 <inkedmn> [2,4,6,4,3,7,7,9,11,132]
22:12:52 <Pseudonym> OK.
22:13:18 <Pseudonym> Initial runs are [[2],[4],[6],[4],[3],[7],[7],[9],[11],[132]]
22:13:25 <inkedmn> ok
22:13:51 <Pseudonym> Now, what you do is take the elements from this list two at a time and merge them.
22:14:00 <inkedmn> ok\
22:14:07 <Pseudonym> [[2,4],[4,6],[3,7],[7,9],[11,132]]
22:14:16 <Pseudonym> Then merge again.
22:14:26 <Pseudonym> [[2,4,4,6],[3,7,7,9],[11,132]]
22:14:36 <Pseudonym> Note there were an odd number of runs that time.
22:14:44 <inkedmn> ok
22:14:49 <Pseudonym> So we just stick the last one back in.
22:14:52 <Pseudonym> Keep going:
22:15:03 <Pseudonym> [[2,3,4,4,6,7,7,9],[11,132]]
22:15:08 <Pseudonym> And finally:
22:15:11 <Pseudonym> [[2,3,4,4,6,7,7,9,11,132]]
22:15:20 <Pseudonym> One run in the list, so that's the sorted list.
22:15:27 <Pseudonym> Get the idea?
22:15:28 <inkedmn> ok, i see
22:15:29 <inkedmn> yes
22:15:43 <Pseudonym> THis is technically a bottom-up polyphase merge sort.
22:15:51 <inkedmn> heh, ok
22:15:51 <Pseudonym> It's used in sorting large files on disk.
22:16:04 <Pseudonym> You write out runs in files, then merge two files to get another file.
22:16:23 <Pseudonym> Especially good if you have more data than will fit in memory.
22:16:38 <Pseudonym> But it turns out to be quite efficient as a general sort in Haskell, too.
22:17:00 <inkedmn> did you learn haskell in school?
22:17:06 <Pseudonym> Kind of.
22:17:06 <inkedmn> or teach yourself?
22:17:20 <Pseudonym> We actually learned Miranda.
22:17:24 <Pseudonym> Which is Haskell's direct ancestor.
22:18:50 <inkedmn> ah, ok
22:18:52 <inkedmn> are you in the US?
22:21:49 <Pseudonym> No.
22:22:04 <Pseudonym> Melbourne, Australia
22:22:08 <inkedmn> ah, right on
22:24:21 <Pseudonym> Gotta go.
22:24:31 <Pseudonym> Happy merge sorting.
22:24:40 <Pseudonym> You might actually want to try implementing it both ways.
22:24:53 <Pseudonym> When I was tutoring Haskell, I did this as an extended exercise.
22:25:10 <Pseudonym> Note that in bottom-up merge sort you can actually pick the merge runs however you want.
22:25:20 <Pseudonym> In the example, we did it as single-element lists.
22:25:27 <inkedmn> ok, thanks for your help my friend :)
22:25:31 <inkedmn> have a good one
22:25:42 <Pseudonym> However, in class, we did it by extracting natural runs.
22:25:55 <Pseudonym> So, say, in [2,4,6,4,3,7,7,9,11,132]
22:26:11 <Pseudonym> We have an ascending run [2,4,6] dollowed by a descending run [4,3] and so on.
22:26:20 <Pseudonym> Reverse the descending runs, and you have a natural set of initial runs.
22:26:23 <Pseudonym> Gotta go.
