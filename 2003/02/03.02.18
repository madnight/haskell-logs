00:03:12 <Marvin--> hello shapre
00:03:15 <Marvin--> er, -e
00:03:21 <andersca> hi marvin and shapr
00:03:24 <ibid> hi
00:06:54 <shapr> hej hej
00:07:00 <shapr> var gör du?
00:07:07 <ibid> hej på dej sanotaan täälläpäin :-)
00:07:38 <shapr> minä ei puhu suomea :-P
00:07:39 <Marvin--> Does anybody know of a paper describing the semantics of Core?
00:07:54 <shapr> Marvin--: there's a core spec in a paper somewhere
00:08:13 <ibid> jag skriver föreläasningmaterial
00:08:24 <ibid> shapr: ei se mitään, kirjoittaminen riittää ;-)
00:08:52 <shapr> it's nothing, writing-something something
00:09:08 <ibid> shapr: "no matter, as long as you can write it :-)
00:09:08 <ibid> "
00:09:16 <shapr> heh
00:11:13 * shapr bounces
00:12:20 <shapr> hi buggs|afk
00:12:24 <shapr> too bad you're not here.
00:12:27 <Marvin--> shapr: well, the abstract syntax is briefly described in the paper about the concrete syntax of Core, but not much about the semantics
00:12:39 <Marvin--> as I recall, the evaluation of case is strict in Core for example...
00:12:50 <shapr> you should ask on ghc-users
00:13:11 <Marvin--> yeah I guess
00:13:39 <shapr> did you ever find modules for working with Core?
00:14:50 <Marvin--> I haven't really looked a lot... My latest take on it is to use helium and parse .core file it spits out
00:15:00 <shapr> hm
00:15:31 <Marvin--> Using helium is attractive in the sense that there's no overloading
00:17:18 <eivuokko> Just out of curiosity, what are you doing? :)
00:21:12 <Marvin--> translating quickcheck properties into theorem proving search problems
00:21:53 <shapr> yay!
00:22:06 <eivuokko> Oh, asked you once before.  Sorry, forgot. :)
00:23:01 <eivuokko> It's way too much over my head.  (How does overloading matter for that except that ast is simpler?)
00:24:55 <Marvin--> well, it's one thing less to worry about... Doing this for full Haskell will mean lots and lots of trickery, I prefer starting with a small subset and get something to work!
00:25:23 <shapr> good idea
00:25:26 <eivuokko> Oh, that makes sense, of course.
00:26:02 <Marvin--> and dropping overloading makes it a LOT simpler I think :)
00:26:21 <Marvin--> eqInt and eqList are easier to work with than (==)
00:26:47 <eivuokko> Yes, I guess so.  But I come from c++ and haskell overloadind feels childs play over that one ;-)
00:28:09 <Marvin--> that's because C++ is insane
00:28:30 <Marvin--> I noticed that jdk 1.5 will support parametric polymorphism
00:28:46 <eivuokko> It's insanely fun when you learn the rules and have a *good* compiler :-)
00:28:50 <Marvin--> as our course assistant said: "They implemented a sane subset of C++ templates"
00:28:53 <ibid> based on which proposal?
00:28:58 <ibid> generic java?
00:29:32 <Marvin--> I don't know much about it, but the way I understood it, you'd be able to say things like  Vector<String> foo  much like templates in C++, but much more limited
00:29:45 <eivuokko> Generic java, as I remember it, seemed too complex and yet not expressive enough.
00:30:13 <ibid> Marvin--: yes of course. that's what parametric polymorphism is :-)
00:30:34 <ibid> eivuokko: any specific info on what they chose?
00:30:51 <eivuokko> Nah, I don't watch java too closely these days.
00:31:09 <Marvin--> ibid: well, yes...
00:31:32 <ibid> how is generic java "not expressive enough"?
00:31:58 <Marvin--> I guess you'll still be able to pass in subtypes so you could do nifty things with interfaces and visitors I guess..
00:32:14 <eivuokko> As I recall, they don't have c++ "typedef" and specialisations (pattern matching) lacked.
00:33:18 <ibid> well, typedef should be easily fixed
00:33:26 <eivuokko> Last time I checked, they still seemed to try to make it work so that generics were implemented mainly as casts, which seemed to fail because of "impossible" happened.
00:33:39 <eivuokko> If they don't have typedef, they don't have it.  What can one do?
00:33:40 <ibid> hmph
00:33:48 <ibid> eivuokko: add it?
00:33:56 <eivuokko> Oh, sure.
00:35:58 <Marvin--> speaking of helium... There I would definitely want to be able to say  `f x`  as eqList is ternary
00:36:08 <Marvin--> it'd be nice to be able to say  xs `eqList eqInt` ys
00:36:57 <shapr> mmm, there's almost sunlight outside
00:39:13 <Marvin--> oh dear, the new grep breaks a lot
00:40:17 <ibid> hm?
00:40:31 <ibid> i hope the new grep-dctrl is solid as rock ;-)
00:40:40 * shapr upgrades grep-dctrl
00:40:54 <shapr> and grep also
00:41:38 <shapr> I can't upgrade in gnome-terminal for some reason
00:41:49 <shapr> it keeps switching the font to a bunch of colored boxes. whee.
00:41:59 <Marvin--> devpts didn't mount when I booted up
00:42:08 <Marvin--> because of grep incompatabilities I think
00:42:15 <shapr> yikes
00:43:03 <Marvin--> I gotta say that helium's concrete syntax for Core is easier to read than GHC's :)
00:43:45 <Marvin--> someone is fond of Z's
00:43:52 <ibid> ?
00:44:11 <Marvin--> 	   (tpl1::GHCziPrim.ZLzmzgZR
00:44:11 <Marvin--> 		  (GHCziBase.ZMZN a)
00:44:11 <Marvin--> 		  (GHCziPrim.ZLzmzgZR (GHCziBase.ZMZN a) GHCziBase.Bool))
00:44:14 <shapr> DragonBallZ?
00:44:24 <Marvin--> lots of Z and z and stuff
00:44:35 <shapr> sleepiness
00:44:39 <ibid> jaah
00:44:54 <shapr> joo
00:45:08 <shapr> finnish has lots of cool ways of saying yes
00:45:19 <shapr> and mixing lojban style attitudinals in at the same time
00:45:27 <ibid> ööh, "jaah" is not a way to say yes
00:45:59 <ibid> neither is jaa (unless taking a vote in the parliament:-)
00:46:31 <shapr> what does it mean?
00:47:00 <ibid> approximately "oh"
00:47:43 <ibid> often with an air of boredom :-)
00:47:54 <ibid> but that depends on the tone of voice
00:48:39 <eivuokko> Yea, some use "jaah" as "continue, this is boring, let's get over it."
00:57:50 <Marvin--> "Contributing well-engineered Core-manipulating libraries would be a Good Thing." (SPJ)
00:58:05 <Marvin--> nice :(
00:58:28 * shapr grins
00:59:10 <shapr> well, now you have license to rip modules out of GHC and take the hedge clippers to them.
01:00:07 <Marvin--> heh
01:00:29 <Marvin--> ah, nice, I didn't know of -fno-code, that'll speed things up a LOT
01:00:46 <shapr> it's good to read the directions... several times...
01:00:57 <shapr> as I've said before, GHC has more flags than the UN.
01:01:36 <Marvin--> yeah
01:05:05 <Marvin--> er, so...I'm looking at utils/ext-core
01:05:30 <Marvin--> it wants to read PrelBase.hcr et.c....where do I find PrelBase?
01:05:56 <shapr> locate PrelBase ?
01:06:06 <shapr> I've seen it in the GHC sources
01:06:32 <Marvin--> find -name \*PrelBase\*  didn't find anything
01:06:45 <Marvin--> or is it autogenerated somehow?
01:06:55 <creature> Morning all.
01:08:05 <shapr> g'mornin creature 
01:08:34 * creature is mostly deaf in one ear. :/
01:08:38 <shapr> what?
01:08:45 * shapr makes stupid jokes
01:08:57 <Marvin--> creature: ouch?
01:08:59 <shapr> Marvin--: lib/ghc-5.02.3/imports/std/PrelBase.hi
01:09:08 <shapr> creature: good concert last night?
01:09:43 <Marvin--> shapr: but there's no 'std' in 5.04...
01:09:46 <creature> shapr - it was a rather mediocre evening out clubbing. 
01:09:49 <creature> But good fun anyway. 
01:09:55 <creature> Apart from that, and all the other bruises. 
01:10:13 <creature> I mean, if I can get partially deafened and battered around like that in the Balcony Bar, imagine if I ever went moshing. :/
01:10:17 <creature> Tue Feb 18 09:10:17 GMT 2003
01:10:23 <creature> On the plus side, I'm up bright and early.
01:10:42 <shapr> I like moshing.
01:10:50 <Marvin--> moshing good
01:10:54 <shapr> haven't had a chance lately though.
01:10:59 <shapr> not many mosh pits in Boden.
01:11:49 * shapr digs a hole in the snow and tries to book some popular mosh music
01:12:20 <creature> Heh.
01:22:28 <shapr> this thread on comp.lang.functional about political leanings affecting language choice is bizarre.
01:23:51 <creature> Heh, sounds it. 
01:24:27 <creature> I was in the pub the other day. 2 friends of mine had chained themselves together with karabiners, another 2 were sitting there swapping ice cubes, and there was a man on stage playing a corkscrew. 
01:24:38 <creature> I thought "My God, I'm living in a Dali painting". 
01:24:45 <creature> It really was quite surreal.
01:25:28 <Marvin--> hahaha
01:26:00 <Marvin--> dang, can't use --make with -fno-code
01:26:09 <Marvin--> wonder how I can get it to chase dependencies then
01:27:45 <creature> Ow.
01:27:54 <creature> Note to self: don't eat satsumas when you have a mouth ulcer. 
01:29:42 <Marvin--> does anyone know the *real* way you're supposed to use threadWaitRead?
01:29:54 <Marvin--> it takes an *Int* argument of all stupid things
01:29:59 <shapr> not me
01:30:24 <Marvin--> The only way I found translating a Handle to an Int is to go via the posix libs, getting a Fd and then fdToInt
01:30:31 <Marvin--> which seems kinda...stupid
01:32:25 <pancake> wops :)
01:32:58 <Marvin--> wops what?
01:33:21 <pancake> it's an expression ;)
01:34:12 * Marvin-- mutters
01:34:55 <shapr> hi pancake 
01:35:45 <pancake> I discover haskell yesterday ...now I'm reading few examples
01:35:51 <pancake> it seems interesting
01:35:57 <shapr> I agree.
01:36:13 <shapr> http://haskell.org/learning.html
01:36:25 <shapr> pancake: do you have some questions?
01:36:35 <pancake> a lot of them :)
01:36:41 <Marvin--> shapr: do you know if there's a -hcrdir flag?
01:37:06 <shapr> -hcdir I think
01:37:11 <shapr> dunno about -hcrdir
01:37:28 * shapr looks for a 'flags of the haskell world' document
01:37:58 <Marvin--> isn't -hcdir for the C files?
01:38:13 <shapr> I don't know.
01:38:27 <Marvin--> and there doesn't seem to be a -hcdir flag either
01:38:49 <pancake> how could I call a function?
01:39:10 <Marvin--> pancake: if f is a function taking an Int argument you can say  f 3  for example
01:39:17 <pancake> for example the basic: add (x,y) = x+y
01:39:29 <Marvin--> then you just say add (2,3)
01:39:45 <pancake> l=add(2,3)
01:39:45 <pancake> ?
01:39:46 <Marvin--> but you don't need to put it in tuples,  add x y = x+y  works just as fine, then you call it with  add 2 3
01:41:00 <Marvin--> GHC/Base.lhs:84: parse error on input `#'
01:41:01 * Marvin-- sobs
01:41:06 <Marvin--> how do I get ghc to understand its own files?
01:41:16 <shapr> Marvin--: you want to slurp Core back in?
01:41:27 <pancake> mmm it does'nt works...
01:42:03 <creature> pancake - I've been learning Haskell recently, and so have some sample code you could look at if you liked. 
01:42:20 <pancake> +ok
01:42:51 <creature> If you /msg me your email addy, and I'll see what I can produce. 
01:42:55 <shapr> Marvin--: what are you trying to do?
01:43:04 <Marvin--> shapr: no, right now I want to generate a list of all the files that Prelude.hs imports (recursively) so I know which files I have to turn into .hcr files
01:44:44 <Marvin--> and with ghc --make ..., ghc doesn't bloody understand its own syntax
01:44:49 <shapr> heh
01:44:59 <shapr> is it confused about a pragma?
01:45:08 <shapr> or an unboxed array or something?
01:45:12 <Marvin--> Both I think
01:45:20 <shapr> hm
01:45:20 <Marvin--> well, unboxed int, but ssdn
01:45:28 <shapr> n?
01:45:34 <shapr> ssdd I know
01:45:36 <shapr> ssdn ?
01:45:37 <shapr> name?
01:45:44 <Marvin--> yeah
01:46:03 <Marvin--> or perhaps in this case, ssds  (s for syntax) is more appropriate
01:46:19 <Marvin--> or whatever
01:46:22 * shapr grins
01:46:31 <Marvin--> it still fails to parse 0#
01:47:43 * shapr dunno
01:55:37 <Marvin--> I'll just keep terrorising ghc-users until it works :P
01:55:55 <Marvin--> oops, I said terror, hope I don't have to go to any conferences in USA the next ten years or so
02:04:25 <Marvin--> ugh, I replied to the wrong message, now I fucked up the threading even more
02:09:13 <creature> Bah@broken nail. :/
02:14:39 <shapr> Marvin--: reading directions + asking questions = results :-)
02:45:14 <Marvin--> wow, mighty flamewar on debian-user-swedish about CD writers in linux/debian
02:45:47 <Marvin--> well, maybe not yet, but it has the potential to be
03:16:51 <shapr> how do I compose characters like å in X?
03:18:00 <Marvin--> map something to a compose button and use a+*, a+", o+"?
03:18:15 <Marvin--> or do you have a Swedish keyboard?
03:18:29 <shapr> nah
03:18:30 <shapr> dvorak
03:19:20 <Marvin--> I have no idea how dvorak mixes with Swedish characters
03:29:50 * shapr bounces
03:30:07 <shapr> Marvin--: I got it to work, I was trying to type your name in a haskell-libs news item :-)
03:31:08 <Marvin--> lol
03:31:46 <shapr> https://sourceforge.net/news/?group_id=44807
03:31:47 <shapr> yay
03:34:52 <Marvin--> heh
03:37:16 <radix> yay haskell-libs!
03:37:22 * shapr bounces
03:38:03 <mgoetze> hm...
03:38:14 * mgoetze goes to check how much has been submitted to iohcc...
03:38:59 <shapr> whee: no, lambdabot doesn't load plugins while running, but it wouldn't be too hard to change.
03:47:18 <radix> whoah
03:47:28 <radix> SF's viewcvs has haskell source highlighting
03:47:35 <shapr> yah, it does
03:47:49 <shapr> someone said last week that it uses enscript, which has haskell source support
04:11:33 <shapr> hi ChilliX
04:11:34 <shapr> what's up?
04:11:39 <ChilliX> Moin shapr
04:11:55 <shapr> moin moin!
04:12:34 <ChilliX> I am just catching up with Gtk+HS stuff
04:12:41 <ChilliX> Is Igloo around?
04:13:03 <shapr>  /whois says he's been idle for nine hours
04:13:18 <shapr> you could try /msg Igloo hello
04:13:21 <shapr> might wake him up
04:13:58 <ChilliX> not that important
04:15:36 <ChilliX> shapr: so, what are you up to?
04:16:32 <shapr> oh, about five foot nine ;-) what about you?
04:17:21 <shapr> actually, I have a bunch of XML work to write in Java, so I'm procrastinating and looking at this Haskell IRC bot instead.
04:20:56 <shapr> hi dark 
04:21:00 <dark> Hello :)
04:21:05 <shapr> what's up?
04:21:07 <dark> We should decide whether it's iohc or iohcc.
04:21:18 <shapr> I think it's iohcc
04:21:25 <shapr> has there been confusion?
04:21:46 <dark> Well the list is iohc-jury, and the url in the topic says iohc.mgoetze.net
04:21:47 <mgoetze> well, at the time i created the mailing list, "iohc" was floating around
04:22:02 <shapr> yah, and then Igloo said "you're missing a C"
04:22:03 <shapr> and we were
04:22:04 <mgoetze> international obfuscated haskell contest
04:22:13 <shapr> international obfuscated haskell code contest
04:22:17 <mgoetze> and then people started mentioning ioccc more
04:22:37 <mgoetze> and thus implying that "code" would be an important word to have in the name...
04:23:05 <shapr> dark: think we should add an iohcc alias for the hostname and mailing list?
04:23:21 <shapr> I can see where people might misspell one way or the other.
04:23:37 <mgoetze> just tell me which one's canonical...
04:23:38 <dark> I guess it could save some entries.
04:24:05 <ChilliX> shapr: you are writing an irc bot in H?
04:24:20 <shapr> ChilliX: not me, Pseudonym already did, I'm just looking at how its plugins work.
04:24:32 <ChilliX> ic
04:24:43 <shapr> I realized I'd like to have on-channel search functions for both research papers and #haskell channel logs
04:24:44 <ChilliX> does he use o3's plugin stuff?
04:24:52 <shapr> nah, he doesn't
04:25:01 <shapr> HWS-WP does use o3's plugin stuff.
04:25:10 <shapr> that's Marvin--'s HWS with Plugins
04:25:20 <shapr> it's in haskell-libs cvs, along with lambdabot
04:26:34 <shapr> I think lambdabot could use o3's plugin stuff without much trouble
04:26:51 <shapr> and it would be a good platform to experiment with runtime *re*loading of modules.
04:27:49 <dark> Hmm I haven't seen clausen in a long time.
04:27:58 <shapr> neither have I
04:28:05 <shapr> send him an email?
04:28:08 <mgoetze> so, realizing this is the wrong channel and all... anyone know where i can find docs on guilereadline?
04:28:22 * shapr dunno
04:29:15 <dark> Hmm in which country does he live?
04:29:47 <dark> Oh, it's on his homepage :)
04:30:33 <shapr> he's in .au last I heard
04:30:38 <dark> I wonder if the patents that interfere with tux2 hold in Australia.
04:39:32 <Marvin--> man, this looks lisp with all these parentheses
04:39:53 <mgoetze> Marvin--: iohc submission? :)
04:40:32 <Marvin--> mgoetze: no, subset-of-C to JVM compiler
04:41:14 <dark> Marvin--: ewww.
04:42:19 * mgoetze suddenly gets a vision of an obfuscated brainfuck interpreter, written in haskell.
04:42:27 <shapr> yow
04:42:42 <dark> I have a non-obfuscated one to start with...
04:43:06 <dark> It might be interesting to try to define the brainfuck operators as Haskell operators.
04:43:22 * mgoetze hides from dark.
04:43:44 <dark> I'm not sure it's possible to get the types right.
04:44:03 * shapr runs from the horror
04:44:50 <mgoetze> well, brainfuck only has one type, i think
04:51:52 <radix> woot
04:52:10 <radix> shapr: i'm reading haskell intro material
04:52:29 <radix> I just grokked a haskell program for the first time ;-)
04:53:15 <radix> (well, one that was more than just a listcomp :))
04:57:03 <dark> Hmm, skew binary random access lists look too complicated for a filesystem.
04:57:12 <dark> At least, for a filesystem written by me :-)
04:57:47 <dark> Also, the "cons" operatr would be wasted.
05:05:16 <shapr> Radek: yay!
05:05:20 <shapr> er, "radix"
05:05:34 <shapr> I'm trying to figure out how lambdabot plugins work
05:06:09 <radix> yay
05:08:29 <radix> hey
05:08:37 <shapr> ?
05:08:38 <radix> Can I get a support contract or a help-line?
05:08:40 <radix>     Sadly no; well not yet anyway.
05:08:52 <radix> Why not set up a page with a listing of people who are willing to contract?
05:09:02 <shapr> hm, good idea
05:09:31 <Igloo> I'm here
05:09:56 <Igloo> I wasn't voting in favour of 2 Cs, just noticing an inconsistency
05:11:11 <shapr> yes, I voted in favor of the two Cs for consistency with the IOCCC
05:15:26 <mgoetze> lemme know when you've decided... :)
05:16:57 <Igloo> Well, allowing both in e-mail addresses and web adresses would be sensible if there's confusion
05:17:06 <shapr> yah, I agree.
05:17:28 <shapr> mgoetze: can you make iohcc the canonical name, and forward iohc to the canonical?
05:19:42 <mgoetze> ok
05:32:46 * dark adjusts his .procmailrc
05:33:33 <radix> data Color              = Red | Green | Blue | Indigo | Violet -- so, er, Red, Green, etc, are all types?
05:33:53 <Igloo> No
05:33:56 <Igloo> data constructors
05:33:59 <Igloo> Color is a type
05:34:21 <radix> ok, I must have been confused by a mention that all capitalised words are types...
05:34:53 <Igloo> They can be classes or modules too
05:35:02 * mgoetze wonders how to rename a list in mailman
05:38:49 <mgoetze> ah yes, there's a nice, lengthy faq entry...
05:39:02 <shapr> yow
05:39:16 <shapr> you could just create iohcc-jury and forward that to iohc-jury :-)
05:40:02 <radix> sorry, I got a phone call
05:40:05 <mgoetze> yeah, i think i will
05:40:23 <mgoetze> apparently, renaming a list is a real PITA
05:40:39 <radix> "[The reader will note that we have capitalized identifiers that denote specific types, such as Integer and Char, but not identifiers that denote values, such as inc. This is not just a convention: it is enforced by Haskell's lexical syntax. In fact, the case of the other characters matters, too: foo, fOo, and fOO are all distinct identifiers.]"
05:41:01 <radix> so how does the Red, Green, etc stuff fit in there?
05:41:54 <shapr> the type is Color, instances of the type are Red, Green, Blue, etc
05:41:57 <Igloo> That doesn't talk about constructors
05:42:02 <shapr> like 'a' is an instance of Char
05:42:16 <radix> Igloo: well, they're identifiers, aren't they?
05:42:22 <shapr> btw, does Haskell really call those instances? or is there a better name?
05:42:42 <Igloo> It means variables
05:43:00 <Marvin--> shapr: I like "value"
05:43:02 <radix> hrm hrm
05:43:03 <Igloo> It really doesn't call them instances, because instances are something else  :-)
05:43:17 <shapr> right, good point
05:43:20 <Marvin--> the type Color has the values Red, Green, Blue, Indigo and Violet
05:43:37 <Marvin--> just as Bool has the values False and True
05:43:37 <radix> so is `Red' a first-class object?
05:43:51 <dark> Marvin: But what about Just?
05:44:05 <Igloo> Yes
05:44:08 <Marvin--> dark: Just x is a value of Maybe t if x is a value of t, IMO
05:44:14 <radix> Igloo: was that to me?
05:44:17 <Igloo> Yup
05:44:24 <radix> ok :)
05:44:33 <dark> Hmm, there's already a distinction between types and type constructors, I guess this would be a similar distinction.  That would make Just a value constructor :-)
05:44:48 <Igloo> Just is a value of type t -> Maybe t
05:45:03 <Marvin--> that's another way of looking at it, I guess
05:45:13 <Marvin--> well, actually they're pretty much equivalent
05:45:30 <dark> Or you could get all technical and say that Just is a _constructor_ for a value of type t -> Maybe t.
05:45:53 <dark> I guess that's how data constructors originally got their name.
05:46:04 <mgoetze> ok, iohcc works now
05:46:08 <shapr> mgoetze: thanks!
05:46:25 * mgoetze should fix up httpd.conf, though
05:47:18 <radix> is `a' pre-defined, or is this intro relying on `(forall a)[a]' appearing somewhere in the program?
05:47:41 <radix> hrm
05:47:45 <radix> maybe I misunderstood that part :)
05:49:29 <Igloo> Type variables have an implicit forall
05:51:18 <mgoetze> ok, all done
05:52:00 <shapr> yay!
05:54:56 <radix> Igloo: oh
05:55:26 <radix> so in a type context, `a' isn't actually a first class object, but it's effectively computed each time it's encountered?
05:55:50 <radix> that's a weird way to say it, isn't it
05:55:53 <radix> probably incorrect, too
05:56:11 <Igloo> It's not actually computed, but that's the right idea
05:56:33 <radix> so there's nothing special about `a', I could also use `tooty'?
05:57:00 <Igloo> Yup
05:57:14 <radix> *grokkage*
06:01:09 <radix> Igloo: ok, so _this_ is where the capitalization matters, right?
06:01:30 <radix> if I used `Tooty', it would expect Tooty to be a type that was defined somewhere
06:02:15 <Igloo> Capitalisation *also* matters here
06:02:43 <radix> so where doesn't it matter? only in data constructor names?
06:03:05 <Igloo> It matters there too
06:03:14 <radix> but `Blue' isn't a type. :-(
06:03:14 <Igloo> You can't say data Foo = foo
06:03:30 <Igloo> Correct
06:04:00 <radix> so what's the *real* rule for captilization? this guide is lying to me :)
06:04:24 <Igloo> Types, data constructors, classes start with upper case letters or :
06:04:42 <Igloo> And type constructors
06:04:44 <radix> ok :):)
06:04:55 <Igloo> Oh, and modules
06:04:58 <radix> heh
06:05:09 <radix> I guess I'll email the maintainer of this document
06:06:54 <SyntaxPolice> good morning all.
06:08:15 <mgoetze> hi SyntaxPolice :)
06:08:56 <shapr> heya SyntaxPolice
06:09:06 * radix boggles as he tries to access Joseph Fasel's web site
06:09:18 <radix> "The site you are trying to access may have moved behind the firewall.
06:09:21 <radix> You are being asked to authenticate in order to view the information."
06:09:26 <radix> anyone know where I can get his email?
06:09:40 <shapr> google?
06:09:59 <radix> gonna try the lanl search
06:24:43 <radix> Ok, email sent
06:24:47 <radix> Igloo: thanks for clearing things up :-)
06:26:02 <Igloo> np
06:27:25 * shapr bounces
06:39:47 <shapr> radix: tried writing something?
06:41:01 <radix> not yet
06:43:08 <radix> wow, the type signature of map is totally boggling
06:43:17 <radix> i grok the definition, but not the type...
06:43:49 <shapr> what's the type?
06:44:02 <radix> map                     :: (a->b) -> [a] -> [b]
06:44:14 <shapr> what parts of that do you understand?
06:44:44 <radix> well... I think the (a->b) means "takes an argument of a function that takes an a and returns a b"
06:44:52 <shapr> yup
06:45:02 <radix> after that... I'm lost :)
06:45:28 <radix> or hm
06:45:30 <radix> oh wait
06:45:50 <shapr> ?
06:45:55 <radix> then returns a function that takes a list of a! which itself returns a list of b
06:45:57 <radix> w00t!
06:46:03 <radix> ima smartey!
06:46:13 <shapr> right!
06:46:20 * radix does a jig
06:46:44 <shapr> though usually people say something like "map (+ 1) [1,2,3]" so they fill in the first two arguments at the same time.
06:46:55 <radix> yeah, exactly
06:47:02 <radix> I just now finally grokked function application
06:47:08 <radix> that is _so damn cool_ :)
06:47:19 <shapr> radix: ok, for extra brain stretching, do you know what currying is?
06:47:22 <radix> f 1 2 is really calling two functions
06:47:25 <shapr> yes!
06:47:28 <radix> heh :DDD
06:47:33 * radix dances around!
06:47:37 <radix> happy-dance happy-dance
06:47:48 <shapr> radix: so you get this built-in trick called partial application
06:48:04 <shapr> for example: (+ 1)
06:48:16 <radix> yeah.. .returns a function that adds 1 to something else
06:48:18 <shapr> since (+) :: Int -> Int -> Int
06:48:25 <radix> i already knew about PA from elsewhere
06:48:31 <shapr> now you *really* know about PA
06:48:34 <radix> yes
06:48:39 <radix> it's much neater how haskell does it :D
06:48:44 <shapr> yah, it's very cool.
06:49:05 <shapr> for extra credit, look up currying
06:49:53 <radix> shapr: the Gentle Intro already told me the origin :)
06:50:04 <shapr> ah, ok :-)
06:50:10 <radix> Haskell Curry! what a weird name
06:50:21 <shapr> do you know what Currying does?
06:50:22 <radix> especially since I knew about both "haskell" and "currying" before I heard his name :D
06:50:26 <shapr> heh
06:50:35 <radix> shapr: huh? I thought I did
06:50:37 <shapr> some people call it "schoenfinkelling"
06:50:54 <shapr> I think there are dots over the o or the first e
06:51:13 <radix> i thought "currying" a function is the same as "partially applying" a function, and "a curried function" is a function with a type something like foo -> bar -> ...
06:51:43 <dark> shapr: I think there are dots over the o if you leave out the first e :)
06:52:09 <dark> radix: Haskell only has curried functions so it's hard to tell.  You can simulate non-curried functions with tuples.
06:52:57 <radix> oh man! haskell has infix pattern matching
06:53:07 <radix> that's _so cool_
06:53:13 <radix> I've wanted something like that for lisp for a looong time
06:53:21 <radix> so I could write a proper `if' that contains an `else' in the middle :))
06:53:54 <dark> Heh... I think that's something Haskell still can't do.
06:54:40 <radix> huh?
06:54:45 <radix> oh..
06:54:51 <radix> you would need both `if' and `else'...
06:54:57 <radix> is that what you mean?
06:57:35 <radix> "map (+) [1,2,3] (the reader should verify that this returns a list of functions!)"
06:57:37 <radix> *mindblow*
06:58:13 <Marvin--> well, (+) is a function taking two arguments, so (+) 1 is a function taking one argument
06:59:00 <radix> yeah, I grokked it
06:59:05 <radix> but it was still a mindblow :)
06:59:25 <shapr> radix: what about fun stuff like "map (.) [...]" ?
06:59:53 <radix> aaagh
07:00:07 * shapr grins
07:00:12 <shapr> radix: it gets better ;-)
07:00:20 <radix> shapr: does anyone actually _use_ stuff like that? :):)
07:00:23 <shapr> sure
07:00:38 <shapr> want some educational urls?
07:01:12 <radix> let me get through this first :)
07:01:37 <shapr> ok, read this afterwards - http://www.kuro5hin.org/story/2002/1/15/1562/95011
07:01:48 <shapr> Tom Moertel does "foldr1 (.) ..." in there
07:02:41 <shapr> actually, here's what he really does:
07:03:00 <shapr> doSubstitutions = foldr1 (.) (map (uncurry substitute) substitutions)
07:03:06 <shapr> which is even more fun :-)
07:03:12 <radix> `bot = bot' is l33t
07:03:22 <dark> eek, `' quotes.
07:03:26 <radix> much cooler than crazy lispy lambda thingy
07:04:01 <radix> what is it? ((lambda (x) (x)) (lambda (x) (x))?
07:04:10 <radix> oops, I misbalanced the parens
07:04:19 <Marvin--> I like the definition of undefined in hugs
07:04:23 <radix> or did i
07:04:48 <radix> nope, my lambda was right
07:04:52 <radix> but yes, bot = bot is better ;)
07:05:21 <Marvin--> undefined | False = undefined
07:05:35 <radix> o.O
07:05:40 <radix> I'm not familiar with that syntax :)
07:05:47 <Marvin--> '|' is a guard
07:05:57 <Marvin--> it basically says, "if False is True, then undefined is undefined"
07:06:03 <radix> i only know what `guard' means in the context of listcomps...
07:06:09 <radix> boggle!?
07:06:43 * radix 's brain twists
07:07:14 <radix> Marvin--: but how is `undefined' useful later, then?
07:07:23 <radix> or is it just a joke no-op? :)
07:07:50 <Igloo> undefined is for when you want error "Foo" but can't be bothered to think of Foo
07:08:22 <Marvin--> exactly, it can be used pretty much as a short-hand for  error "This shouldn't happen"
07:08:38 <radix> but, well
07:08:44 <Igloo> error and unique strings are more useful, though
07:08:56 <radix> wouldn't saying `undefined' later be just as good *without* the (non-)definition?
07:09:11 <shapr> radix: I use it lots when I'm making unit tests "thisFunction = undefined"
07:09:29 <radix> ok, so `undefined' actually _is_ a first-class object after that non-definition?
07:09:30 <Igloo> If undefined isn't defined type checking will fail
07:09:40 <shapr> and my unit test complains bitterly when executed
07:09:49 <shapr> then I go back and fill in the actual definition of the function.
07:10:04 <shapr> right, undefined is a first class error ;-)
07:10:20 <radix> shapr: wouldn't saying `thisFunction = not_a_defined_name' be just as good?
07:10:23 <Marvin--> radix: exactly, 'undefined' is defined :-)
07:10:30 <radix> Marvin--: hrm
07:10:33 <Igloo> No, type checking would fail
07:10:41 <Marvin--> undefined is a function as any other
07:11:09 * radix whimpers
07:11:33 <radix> i'll think about it again once I understand guards :)
07:11:37 <radix> first! breakfast
07:11:43 <shapr> guards are just if
07:13:08 <Marvin--> shapr: not really, but maybe we don't want to scare him too much...
07:13:30 <shapr> heh
07:13:33 <shapr> well
07:13:44 <shapr> case
07:15:04 <Igloo> It's like if/elseif with a falling through else, or something
07:15:28 <Marvin--> yeahg
07:16:32 <Marvin--> I like the extended guards
07:19:41 <Igloo> The ones that can match patterns?
07:20:00 <Marvin--> yeah
07:25:51 <radix> yeah, I could already see that it was more than just `if'
07:26:07 <radix> because `if True==False: undefined=undefined' in Python would never do anything useful :)
07:26:15 <radix> but btw
07:26:24 <radix> I just figured out the best waffle-topping EVER
07:26:37 <radix> cottage cheese and apple-butter!
07:26:40 <radix> YUM!
07:31:46 * SyntaxPolice gets hungry
07:31:56 <shapr> me too
07:32:46 <radix> :D
08:36:37 <hdaume> hi all
08:36:53 <shapr> hi hal
08:36:55 <shapr> what's up?
08:37:14 <hdaume> not a whole lot....debuggin like usual :)
08:37:15 <Riastradh> Hi.
08:37:30 <shapr> what's on the debugging menu today?
08:37:54 <hdaume> figuring out why my program simply stops running after ~10 hours and just seems to sit there :).
08:38:08 <shapr> that's a new one.
08:38:10 <eivuokko> Really nice.
08:38:23 * mgoetze is trying to write a program... in scheme...
08:38:30 <shapr> (really?)
08:38:36 <eivuokko> Do you get paid waiting it? ;-)
08:38:39 <shapr> (works? 'program)
08:38:50 <hdaume> it uses MPI, so it's a parallel program, so it's probably getting stuck in some sort of deadlock, but i can't figure out where
08:38:58 <mgoetze> shapr: #f
08:39:08 * mgoetze is having trouble with (case)
08:39:55 <Riastradh> What trouble hast thou?
08:40:08 <mgoetze>    (case (read-line) (
08:40:08 <mgoetze>       (("i" "I") ((init-db) (main-menu)))
08:40:08 <mgoetze>       (("q" "Q") (write-line "Goodbye!"))
08:40:08 <mgoetze>       (else (main-menu)))))
08:40:14 <mgoetze> what's wrong with that?
08:40:19 <Riastradh> You've got an extra parenthesis after '(read-line)'.
08:40:42 <mgoetze> oh, that isn't supposed to be there?
08:40:58 <Riastradh> Also in:  ((init-db) (main-menu))  init-db must return a function, otherwise an error will be signalled there.
08:41:01 <shapr> mgoetze: should I direct you to HScheme, the scheme interpreter written in Haskell?
08:41:07 <Riastradh> I believe you meant:  (begin (init-db) (main-menu))
08:41:17 <mgoetze> shapr: i'm happy with guile, thanks :)
08:41:25 <mgoetze> Riastradh: yeah, that's what i meant
08:41:42 <Riastradh> Or, because, if I remember correctly, each case clause can contain any number of expressions, you don't even need to begin surrounding it; it could be:
08:41:49 <Riastradh> (("i" "I") (init-db) (main-menu))
08:42:04 <mgoetze> ok... but it's still not matching
08:42:06 <Riastradh> But there's another problem:  strings can't be compared by eqv? properly.
08:42:36 <mgoetze> so how would i go about solving that problem?
08:42:55 <Riastradh> It would make more sense for 'read-char' to be used and use (#\i #\I) etc.
08:43:06 <Riastradh> So it would now look like:
08:43:08 <Riastradh> (case (read-char)
08:43:18 <Riastradh>  ((#\i #\I) (init-db) (main-menu))
08:43:31 <Riastradh>  ((#\q #\Q) (write-line "Goodbye!"))
08:43:37 <Riastradh>  (else (main-menu)))
08:43:58 <mgoetze> in that case, i'll have to get stdin unbuffered
08:44:05 <Riastradh> Why?
08:44:35 <mgoetze> well, because else it won't do anything until i press enter, and then there'll still be an enter to get picked up by the next read-whatever
08:44:56 <Riastradh> In that case:
08:45:09 <Riastradh> (case (let ((c (read-char))) (read-line) c)
08:45:16 <Riastradh>  ((#\i #\I) ...)
08:45:18 <Riastradh>  ...0
08:45:20 <Riastradh> er:
08:45:22 <Riastradh>  ...)
08:45:39 <Riastradh> read-line will discard all of the stuff at the rest of the line.
08:46:04 <Riastradh> Some Scheme implementations provide a 'begin0' or something:  (begin0 (read-char) (read-line)), and it will return the char read, not the line read.
08:46:17 <Riastradh> It's not difficult to define as a macro, though:
08:46:19 <Riastradh> (define-syntax begin0
08:46:21 <Riastradh>   (syntax-rules ()
08:46:26 <mgoetze> that's alright, i get the point :)
08:46:26 <Riastradh>     ((_ ?e1 ?e2 ...)
08:46:34 <Riastradh>      (let ((tmp ?e1))
08:46:42 <Riastradh>        ?e2 ... tmp))))
08:46:56 <Riastradh> I suppose this should have all been said in #scheme, though, not #haskell.
08:47:26 <mgoetze> well, people usually sleep in there afaict
08:48:51 <mmc_> hah
09:56:34 <shapr> Marvin--: yay, binkley has suggestions
10:06:52 <Marvin--> ?
10:15:56 <shapr> binkely on ghc-users
10:17:26 <Marvin--> who's binkely?
10:17:45 <Marvin--> Kirsten?
10:17:47 <shapr> yes
10:18:39 <Marvin--> well, that mail only told me what SPJ had already said... right now, I'm more worried about how to actually get all the .hcr files I need :P
10:18:43 <shapr> oh
10:18:59 <shapr> you could use code from hIDE
10:19:09 <shapr> it has code to get all imports from a file
10:19:31 <Marvin--> hmm, nice
10:19:42 <Marvin--> is it in fptools?
10:19:51 <shapr> no, sf.net/projects/haide/
10:20:04 <hdaume> how is hide coming, btw
10:20:20 <shapr> duncan did some work on it this weekend
10:21:01 <shapr> Marvin--: see hIDE in action: http://kungens.kemi.fi/~shae/hIDE.png
10:22:14 <Marvin--> yeah I've seen it before
10:22:39 <shapr> specifically, Imports.hs
10:23:00 <hdaume> does it work in windows?
10:23:04 <Marvin--> yeah, I found it, but is it recursive?
10:23:20 <shapr> I dunno
10:23:24 <shapr> to both of those questions
10:24:26 <Marvin--> doesn't seem to be
10:32:58 * Marvin-- proceeds to write a recursive counterpart
10:33:02 <shapr> yay!
10:33:49 <steele> hi
10:35:09 <Marvin--> heh, funny how when I google around and find interesting haskell papers they always seem to be linked from our AFP course homepage
10:37:50 <Marvin--> oh heck, I'm going to have to do cycle detection
10:38:37 <Marvin--> I mean I guess I could use IORefs to keep track of which modules I've visited and so on, but that's...imperative
10:39:27 <shapr> I thought Haskell modules can't have cycles?
10:40:31 <shapr> or did I imagine that?
10:40:39 <Marvin--> the way I can see here, GHC.Base imports GHC.Err which imports GHC.Base
10:41:03 <Marvin--> but maybe the SOURCE part in  import {-# SOURCE #-} GHC.Err  is the black magic?
10:41:06 <hdaume> modules can be mutually recursive, but for instance ghc requires you to have hi-boot files to handle that
10:41:20 <Marvin--> yeah, GHC.Err has a hi-boot
10:41:23 <shapr> oh
10:41:25 <hdaume> there was a discussion about this on one of the mailing lists recently
10:42:31 <Marvin--> and since the Prelude is a file I'm going to need to process...
10:43:29 <Marvin--> oh dear, this DFS implementation is in the ST monad
10:43:39 <Marvin--> maybe I should just use IORefs instead
10:43:50 <Marvin--> or an IOArray
10:45:42 <Marvin--> but that's just too evil :(
10:45:49 <hdaume> Marvin--: do you need to use the GHC prelude or could you get away with using just the basic definitional prelude as is found in the library defs?
10:46:28 <Marvin--> hdaume: I have a Haskell module and need the Core code for it and everything it uses
10:47:27 <Marvin--> well, theoretically I don't need *Core* but I want to work with a simpler language than Haskell, so Core seems like a good choice
10:53:15 <ludde> what does core look like?
10:54:03 <ludde> does haskell's garbage collector handle cyclic references properly? (or is it reference counted like erlang?)
10:54:31 <Marvin--> core is just lambda calculus plus letrec and case
10:54:40 <Marvin--> the concrete syntax for it is awful though :)
10:54:54 <ludde> is it much more verbose than haskell syntax
10:54:56 <ludde> ?
10:55:18 <Marvin--> ghc -fext-core -fno-code Foo.hs  will give you Foo.hcr to look at
10:55:42 <ludde> oh
10:55:59 <Marvin--> lots of mangling there
10:57:56 <ludde> wow
10:58:02 <ludde> that's a lot of junk
11:10:31 * Igloo reads things into Simon Marlow saying "The lexical syntax is correct w.r.t. Haskell 98, except that it doesn't handle Unicode (yet)"
11:10:57 <Marvin--> that doesn't sound like "correct" :)
11:12:59 <SyntaxPolice> Igloo: what are you reading into it?
11:21:05 <Igloo> That unicode support might appear soon
11:21:16 <shapr> would be nice
11:21:32 * shapr looks forward to Tengwar.lhs
11:23:43 <SyntaxPolice> shapr: how's the contest going?
11:24:33 <shapr> we have two entries submitted, and several more expressions of interest and enquiries into the rules.
11:25:07 <shapr> I think it's going well for a 0th IOHCC
11:25:36 <shapr> I hope Lennart Augustsson has time to come up with an entry.
11:25:55 <shapr> both of the entries we already have are quite cool.
11:26:15 <shapr> I can barely wait till we get to show off the winners :-)
11:29:10 <SyntaxPolice> neato
11:29:16 * SyntaxPolice is looking forward to it too.
11:42:22 * Marvin-- growls at vasttrafik.se
11:42:53 <Marvin--> why do the stupid morons have  alert("HEJ!")  in their stupid fucking javascript code?!
11:42:54 * Robert read that as vänstertrafik.se
11:43:01 <Robert> Haha
11:43:11 <Marvin--> Can't they at least have the decency to write  alert("This cannot possibly happen you moron")  so I can at least bugreport it
11:43:17 <Robert> Because they're Swedes!
11:43:48 <ibid> any native swedish people present? (for a brief non-haskell-related question)
11:43:56 <Marvin--> ibid: yes
11:44:16 <ibid> Marvin--: "Föreningen av konstnäriga programmeringens vänner" - does that make sense, and does it have an appropriate style?
11:44:20 * Robert
11:44:32 <Robert> Heh.
11:44:34 <Robert> Naaah.
11:44:41 <ibid> suggest something better?
11:44:42 <Marvin--> ibid: "Föreningen för den konstnärliga programmerings vänner" might make a bit more sense
11:44:47 <ibid> okay
11:44:49 <Marvin--> err, programmeringens
11:45:04 <Marvin--> assuming I understood what you want
11:45:13 <Robert> "Föreningen konstnärlig programmerings vänner", maybe.
11:45:31 <Robert> That's what I'd use.
11:45:39 <ibid> Marvin--: do you  agree with Robert?
11:45:39 <Robert> Even though it doesn't sound very good.
11:45:40 <Marvin--> yeah, makes sense too
11:45:44 <Igloo> I need a with clause, like where but before the guards
11:46:19 <ibid> well, the finnish original doesn't sound very good either, but it's best i've come up with :-)
11:47:14 <ibid> i'll use robert's suggestion unless someone speaks up :-)
11:47:15 <ibid> thanks
11:47:24 <Robert> Finnish never sounds sane.
11:48:23 <ibid> "Taiteellisen tietokoneohjelmoinnin ystävien yhdistys"
11:49:03 <ibid> Robert: what's the problem with your suggestion?
11:49:16 <Robert> Argh!
11:49:57 <Robert> Uhm..
11:50:03 <Robert> Well.. it just doesn't sound sane :)
11:50:35 <Robert> I'd just call it "Föreningen för konstnärlig programmering" or something.
11:51:18 <engstad> May I suggest something in Norwegian? "Vennskapsforeningen for artistisk programmering."
11:51:40 <shapr> can I suggest something in French or Lojban? =)
11:51:59 <engstad> Norwegian and Swedish not that far away from eachother.
11:52:36 <engstad> Why "konstnariga" btw?
11:53:11 <ibid> well, finland's sami would be nice too :-)
11:53:17 <Robert> engstad: Hehe... "Vänskapsföreningen" doesn't make much sense in Swedish, though.
11:53:21 <Marvin--> It's not very strange to start these names with "Föreningen för..." or ending them with "vänner", but I don't think I've seen the combination...
11:53:24 <Robert> And.."artistisk", nah.
11:53:25 <engstad> Ok.
11:54:00 <engstad> There are lapps in Norway as well, Ibid. In fact, I'm 1/8 lapp.
11:54:19 <ibid> one of the potential founders has made it a condition for his support that the association have a swedish name
11:54:34 <Robert> Heh.
11:54:36 <engstad> Ok.
11:54:39 <ibid> engstad: i know there are lapps in norway, but i believe that there are different languages in different sami cultures
11:54:55 <engstad> Yes, and quite a big difference.
11:54:59 <ibid> and i agree with him, btw, swedish is one of the two main languages here
11:55:24 <ibid> in this country i mean
11:55:26 <Robert> Heh.
11:55:27 <engstad> Like "north sami" and "south sami" (in Norway) are as far away from eachother as say Swedish and Japaneese.
11:55:28 <ibid> not locally
11:55:35 <Robert> Most people know that, ibid :P
11:55:52 <shapr> only if they live here
11:55:53 <ibid> Robert: most people where you live, probably :-)
11:55:56 <shapr> right
11:55:59 <engstad> In an case, why did you guys want to bring in "konstnerlig" in the name?
11:56:05 <Robert> ibid: Yes! We're Swedish imperialists all of us.
11:56:10 <ibid> engstad: it's the whole point
11:56:14 <shapr> I heard someone in #debian ask if german was the official language of finland.
11:56:21 <Robert> shapr: Haha!
11:56:22 <ibid> engstad: programming as a form of art
11:56:23 <Marvin--> *snicker*
11:56:23 <shapr> negative clue abounds.
11:56:33 <engstad> And "konstnarlig" means artistic?
11:56:44 <ibid> engstad: according to my dictionary yes
11:56:46 <engstad> ok.
11:56:49 <Marvin--> engstad: yes
11:56:50 <ibid> it's one of the choices it have me
11:56:52 <ibid> gave
11:57:19 <ibid> i'll probably ask liw too
11:57:39 <engstad> Hmm.. I see your problem.
11:58:05 <ibid> engstad: ?
11:58:15 <engstad> Do you have the verb "koding" (coding) in Swedish?
11:58:25 <ibid> i have no idea :-)
11:58:26 <Robert> "koda"
11:58:36 <ibid> but no, coding is not what we're after
11:58:43 <engstad> Foreningen av konstnarlige kodare.
11:58:44 <ibid> at least in the finnish equivalent
11:58:44 <engstad> ?
11:59:06 <Robert> "Konstnärliga programmakare" :P
11:59:12 <engstad> dator-kodare?
11:59:41 <engstad> It's hard --- I don't know Swedish well enough I am afraid.
11:59:41 <ibid> Robert: does that not make the program-makers artistic, instead of their products?
11:59:49 <shapr> jag koder xslt
12:02:32 <andersca> oj
12:02:36 <engstad> I think I have a problem with the translation of "programming as an art" to "konstnerlig programmering", do they actually mean the same??
12:02:39 <shapr> jag hatar xslt
12:04:51 <ibid> engstad: programming as an art is not exactly what we're after; there is no direct translation to english of what we want.  the swedish one is closer afaict
12:05:45 <engstad> Explain (remember, I am Norwegian).
12:06:13 <ibid> i doubt i can unless you know finnish :-)
12:07:08 <engstad> Oh...
12:07:25 <engstad> I'm afraid not.
12:09:33 <Robert> Finnish is for finns :)
12:09:46 <Robert> And various lunatics lurking around the world.
12:09:58 <shapr> minakin
12:10:08 * Robert tries not to think about what ibid said earlier.
12:10:15 <ibid> Robert: ?
12:10:20 <Robert> Taiteellisen tietokoneohjelmoinnin ystävien yhdistys
12:10:28 <Robert> That almost made me cry :)
12:10:31 <ibid> hö
12:11:31 <ibid> "Vännerna av konstnärlig programmering" came from liw
12:16:03 <engstad> That sounds ok to me.
12:16:42 <ibid> good
12:55:23 <Marvin--> oh &"%#"
12:55:54 <Igloo> ?
12:56:16 <mgoetze> sup?
12:56:20 <Marvin--> I forgot that Language.Haskell.Parser doesn't support .lhs files
12:57:29 <Marvin--> maybe I could parse .hi files instead
12:58:30 <hdaume> Marvin--: you could just run unlit
12:59:13 <Marvin--> is that a program or a function in some obscure module?
13:01:36 <giedi> /usr/lib/ghc-.../unlit here
13:01:50 <giedi> executable
13:03:05 <giedi> shapr: you actually speak lojban?
13:03:11 <Marvin--> hmm, so I need sort of a popen
13:03:33 <Marvin--> I think I wrote one for hws-wp *digs around*
13:03:37 <hdaume> Marvin--: i don't think it would be too difficult to implement unlit...the sources probably exist in fptools anyway
13:08:28 <Marvin--> bah, popen is 1337
13:11:36 <Marvin--> I just don't want to go to all of this fuss just to get a damn list of imports! :)
13:12:31 <Marvin--> so right now I'm leaning in the direction of  find -name \*.hs | xargs ghc -fext-core -fno-code 
13:27:59 <hdaume> Marvin--: what's wrong with 'map (drop 7) . filter ((=="import ").take7) . map (dropWhile isSpace . (\x -> case x of { '>':xs -> xs ; _ -> x })) . lines' or something like that?
13:28:23 <hdaume> (you could be moderately more intelligent about handling literate files, but...)
13:31:17 <Marvin--> heh
14:37:51 <shapr> aw, I missed yazirian!
14:37:53 <shapr> crap!
14:41:18 <shapr> hi Pseudonym!
14:41:44 <shapr> oh, I remember my question!
14:42:56 <Pseudonym> G'day.
14:43:03 <shapr> g'day Pseudonym 
14:43:27 <shapr> Pseudonym: hey, how do I call a lambdabot plugin?
14:43:45 <Pseudonym> At the moment, you don't.
14:43:52 * Pseudonym never got around to writing a real command parser
14:44:29 <shapr> hm
14:44:43 <shapr> that explains why I couldn't get it to say "Hello World" eh?
14:44:44 <jlouis> HAPPY!
14:44:49 <shapr> jlouis: PARSEC!
14:44:53 <jlouis> HAPPY!
14:45:01 <shapr> JOY JOY?
14:45:02 <Riastradh> lambdabot?
14:45:04 <jlouis> hehe
14:45:16 <shapr> Riastradh: Pseudonym wrote an irc bot in Haskell
14:45:28 <jlouis> how is the memory consumption of the bot?
14:45:31 <jlouis> does it leak?
14:45:32 <Riastradh> Where can I acquire its code?
14:45:50 <shapr> Riastradh: the bot is in cvs on sf.net/projects/haskell-libs
14:45:55 <Pseudonym> jlouis: It doesn't leak.  It doesn't do enough to leak.
14:46:05 <jlouis> okie
14:46:10 <shapr> Riastradh: it's part of my evil plan to lure haskell programming to join the haskell-libs project and work on code together.
14:46:20 <shapr> look look! the blue spotted lambdabot!
14:46:23 <shapr> lambdabot: hello!
14:46:24 <lambdabot> Sorry, I'm not a very smart bot yet.
14:46:35 <jlouis> hehe
14:46:36 <Riastradh> What does lambdabot do?
14:46:39 * jlouis pokes lambdabot 
14:46:42 <shapr> lambdabot: @listmodules
14:46:43 <lambdabot> I have the following modules installed: ["hello_module"]
14:46:45 <lambdabot> Hey!
14:46:48 <shapr> lambdabot: @listchans
14:46:48 <lambdabot> I am on these channels: ["#haskell"]
14:47:36 <Pseudonym> That's about all it does.
14:47:39 <SyntaxPolice> lambdabot performUnsafeIO!
14:47:43 <shapr> nooo!
14:47:45 <SyntaxPolice> ;)
14:47:47 * shapr watches the bot explode
14:47:49 <lambdabot> SyntaxPolice: You first.
14:47:54 * shapr snickers
14:47:58 <SyntaxPolice> hmm
14:48:01 <shapr> hey, that bot has a smart mouth
14:48:41 <lambdabot> Must get going. Bye everyone.
14:48:45 <shapr> bye lambdabot!
14:49:46 <shapr> cool trix
14:49:49 * Pseudonym notices his productivity plummet
14:50:26 <Riastradh> Did you expect anything else from being on IRC?
14:50:46 * shapr grins
14:51:05 <shapr> I've found a solution.
14:51:08 <Pseudonym> Apart from wAr3z and cRaC|<z?
14:51:20 <shapr> create an irc channel for your job, and persuade your coworkers to join.
14:51:35 <Pseudonym> At a previous job, we had our own IM system.
14:51:48 * Riastradh is curious as to how stuff is done on IRC without state.
14:51:49 <Pseudonym> http://www.csse.monash.edu.au/~tym/goofey.html
14:51:50 <jlouis> We use IRC at my job for many things
14:52:24 <jlouis> all from venting steam to cooperate on problems
14:53:36 <Riastradh> How does lambdabot keep track of, say, who is in what channel, or whether or not someone has ops?
14:53:37 <shapr> in my last job, we had three branches, 200 and 800 kilometers from me
14:53:51 <shapr> Riastradh: see, you should join haskell-libs and work on lambdabot :-)
14:54:11 <Pseudonym> I can beat that.
14:54:26 <Pseudonym> At my last job, there was me in Australia, my boss in Hawaii and my cow orker in Germany.
14:54:40 <Riastradh> shapr - I probably will end up doing so, or possibly porting it to my version of IRC, but meanwhile I'm rather curious as to how it handles a, for example, 'MODE #channel -o User'.
14:55:10 <Pseudonym> It ignores it.
14:55:24 <Pseudonym> There is only one thing it currently keeps track of, and that's what channels it's not.
14:55:31 <Pseudonym> Sorry, what channels it's _on_.
14:55:52 <Riastradh> Can it join new channels and part old channels?
14:56:26 <Pseudonym> Yes.
14:56:48 <Riastradh> How does it keep track of the channels it's in, though, if that list of channels can change?
14:56:48 <Pseudonym> You do that by sending it a remote message: /msg lambdabot @join #haskell
14:56:59 <Pseudonym> State monad.
14:57:05 <Riastradh> Oh, I see.
14:57:17 <Pseudonym> type IRC a = StateT IRCRWState (ReaderT IRCRState IO) a
14:57:18 <Riastradh> Haskell, then, -isn't- purely functional, even when you forget about IO?
14:57:33 <Pseudonym> IrcRState is the read-only state and IRCRWState is the read-write state.
14:57:46 <Pseudonym> Sure it is.
14:58:00 <Riastradh> But the list of channels must be mutable, mustn't it?
14:58:06 <Riastradh> Or rather, in some way mutable.
14:58:09 <Pseudonym> Haskell supports state in the same way that it supports FiniteMaps.
14:58:17 <Pseudonym> It's not in the base language, but you can simulate it.
14:58:23 <Riastradh> Hm..
14:58:30 * Riastradh kicks his dot key.
14:58:35 * shapr dots his kick key.
14:58:42 * Pseudonym keys his dot kick
14:58:44 <Riastradh> Ooooh, where's that kick key?
14:59:03 <Pseudonym> That'd be handy.
14:59:05 * Riastradh wants a keyboard with a kick key.
14:59:18 <shapr> well, kinesis has a three pedal plugin
14:59:20 <Pseudonym> I think it's control-alt-windows key.
14:59:29 <Riastradh> But I don't have a windows or an alt key.
14:59:37 <shapr> C-M-BS
14:59:45 <Riastradh> Nor do I have a 'backspace' key.
14:59:50 <shapr> control meta backspace works well for me
14:59:55 <shapr> since that kills X
15:00:07 <Pseudonym> Or under emacs, it's Escape-Meta-Control-X Shift-Meta-E.
15:00:24 <Riastradh> No, it's Escape-Meta-Alt-Control-Shift!
15:00:32 <Pseudonym> I have a key that says "WWW".
15:00:40 <Pseudonym> That's probably close to "kick".
15:00:56 <Pseudonym> And my mouse has two buttons that I've never found a use for.
15:01:01 <Pseudonym> One of those might be "kick".
15:01:24 <shapr> my mouse has only two buttons
15:01:27 * Riastradh has only ever had one-button mice.
15:01:38 <Pseudonym> You're a filthy mac user, aren't you!
15:01:42 <Pseudonym> Admit it!
15:01:44 * whee is too
15:01:50 <Riastradh> No, I won't admit the 'filthy' part.
15:01:57 <Riastradh> I'll gladly 'admit' that I'm a Mac user.
15:02:02 <Pseudonym> OK, cool.
15:02:13 <Riastradh> But hey, I've never needed a two-button mouse, so why should I have one?
15:02:13 <shapr> I used to use Macs
15:02:38 <whee> Riastradh: dude, we don't have tabs in our browser or more than one button on our mouse! we're obviously inferior
15:02:42 * Riastradh has twelve Macs and one ancient [, broken] Pentium II.
15:02:47 * Pseudonym wishes Macs were higher up his personal cost-benefit tradeoff curve
15:02:56 <shapr> last mac I used was a Mac IIci
15:08:28 <shapr> Pseudonym: I like your response to our latest submission.
15:08:46 <Pseudonym> Yeah, I was a bit puzzled about that one.
15:08:50 * shapr snickers
15:14:26 <shapr> hi det 
15:14:28 <shapr> what's up?
15:15:21 <Robert> Det..
15:15:22 <Robert> Hah.
15:15:44 <Robert> Never read the book, but I like the movie.
15:15:55 <shapr> ?
15:16:55 <Robert> "It", by Stephen King.
15:17:02 <Robert> Swedish title is "Det".
15:17:21 <Marvin--> heh, yeah
15:17:26 * Marvin-- hides from det
15:17:56 <Marvin--> I have IT on my book shelf though I haven't managed to read more than a few chapters, I really really don't like his way of writing
15:18:34 <Robert> Hehe.
15:18:52 <Robert> I like "Pestens tid".
15:19:32 <Marvin--> haven't read it, I liked the first episodes of the TV version, then it turned into religious post-apocalyptic mumbo-jumbo
15:20:58 <Robert> Hehe.
15:21:20 <Robert> It is kind of crazy, that's what I like with it.
15:21:39 <Marvin--> I prefer e.g. Neil Gaiman's crazy, have you read American Gods?
15:21:55 <Robert> Nope.
15:22:04 <Marvin--> I liked it a lot :)
15:22:17 <Robert> What is it about?
15:22:52 <shapr> hi dkl 
15:23:00 <shapr> dkl: are you really irc'ing as root?
15:23:14 <shapr> hmm
15:25:27 <Marvin--> Robert: exactly what the title says :P
15:25:43 <Marvin--> well, actually a lot of European Gods in American
15:25:47 <Marvin--> err, America
15:25:53 <Pseudonym> Marvin: So is "It", for that matter.
15:26:32 <Marvin--> Pseudonym: "exactly what the title says"?
15:26:35 <Robert> Uh... okay.
15:26:39 <Pseudonym> Yes.
15:28:06 <Pseudonym> Gotta go to a seminar.
15:28:13 <Pseudonym> About inverted file compression, oddly enough.
15:28:32 <shapr> yay
15:29:04 <Pseudonym> At the moment, our DBS is running at about 8 bits per index pointer.
15:29:07 * det returns
15:29:13 <Pseudonym> Apparently this guy has worked out a way to compress it further.
15:29:19 <det> shapr: hi, got ocamlsdl working under windows!
15:29:24 <Pseudonym> BBIAB
15:29:26 <det> shapr: now I get to write a 2d game :)
15:30:45 <shapr> yay!
15:31:16 <det> shapr, and to some degree lablgl works, I am running ocamlsdlgears right now :)
15:34:19 <det> shapr, how goes rfc228 ?
15:40:48 * dark bings.
15:41:51 <Igloo> Do you mean 822?
15:42:19 <Igloo> 228 is 4 lines and about a FORTRAN program  :-)
16:40:36 <det> Igloo: yes 822, I was fooling around :)
17:20:11 <engstad> Is there a better fig tool than xfig?
19:38:14 <Riastradh> Is there a 'fold' function defined in the Standard Prelude?
19:38:41 <whee> Riastradh: foldl and foldr
19:39:26 <whee> and foldl1, foldr1, but I can't remember what the difference is
19:51:06 <Pseudonym> And there's foldl', but I don't think it's standard.
19:51:14 <Pseudonym> foldl1 and foldr1 don't use defaults.
19:51:20 <Pseudonym> They require non-empty lists.
21:35:25 <emu> and then there's fold, which requires a PokerHand
