00:23:20 * creature returns. 
00:23:29 <creature> Sorry about last night, guys.
00:23:32 * creature is sober now.
00:24:39 <creature> Incidentally, why is there no unix-like manpage system for Haskell?
00:27:26 <pseiko> in the interpreter environment?
00:31:42 <pseiko> hmm, one may define a function which greps the documentation from literate haskell files or something else, therefore comments are extremely necessary
00:33:33 <creature> pseiko - on the commandline.
00:33:53 <creature> I'd like to be able to do "man fold" and get syntax, description, and maybe an example or two.
00:34:21 <Marvin--> I'm sure they'd love it if someone contributed man pages :)
00:34:42 <creature> Heh, I don't know Troff. :)
00:37:11 <creature> Though it could be a nice mini-project.
00:38:09 <Marvin--> I wouldn't say it's "mini" :P
00:38:13 <pseiko> it would be helpful to base on some comments in the sources, but for example http://haskell.cs.yale.edu/ghc/docs/latest/html/base/Prelude.html shows impressively that haskell hackers are even more lazy in commenting than in evaluation
00:38:24 <pseiko> *g*
00:39:26 <Marvin--> bah, it's self-explanatory :)
00:40:47 <pseiko> oh, i think as self-explanatory than all the other haskell stuff 
00:41:57 <Marvin--> *g*
00:42:53 <pseiko> you see, we have to start from the scratch, because this is the point where beginners may fail
00:43:28 <creature> It's self-explanatory as far as "It's what the code says".
00:43:36 <Marvin--> what, because reverse = foldl (flip (:)) [] ? ;)
00:43:53 <Marvin--> that one took me a while :-)
00:44:08 <pseiko> *this was really socratically*
00:45:04 <pseiko> *has to say good bye because of a lecture*
00:45:13 <creature> Heh, enjoy pseiko.
00:46:06 <creature> You'll all be glad to know I beat what I was struggling with last night. 
00:46:17 <creature> I can code like a God when under the influence, but I can't debug for anything. 
00:47:09 <Marvin--> aaaeaeeeeiiiiieh, of 11 new mails to sv@li.org, 9 were from big@boss.com
00:59:26 <creature> Heh.
01:13:11 <shapr> goood morning!
01:13:19 <shapr> hi pseiko 
01:13:54 <shapr> Marvin--: what's sv@li.org?
01:17:33 <Marvin--> shapr: Swedish translator group
01:17:40 <shapr> oh
01:19:38 <Marvin--> li == linux i18n or something
01:19:59 <shapr> ah
02:50:49 <shapr> hi Arnia
02:53:27 <Arnia> Heya
02:53:32 <shapr> what's up?
02:53:47 <Arnia> I can't solve a rather urgent and annoying problem :/
02:53:58 <shapr> anything I can help with?
02:53:58 <Arnia> I need to create a Quiz content type for plone
02:54:23 <Arnia> This quiz needs to hold an arbitary set of short answer and multiple choice questions
02:54:37 <Arnia> Somehow I have to mark this quiz
02:54:54 <shapr> I could do it easily in pure python
02:54:58 <Arnia> And display the marks
02:55:13 <shapr> how urgent is this?
02:55:15 <shapr> like, an hour?
02:55:25 <Arnia> I need a design by 2pm
02:56:48 <Arnia> A multiple-choice question is easy to mark. A short-answer question should just display a 'model' answer.
02:57:20 <shapr> and should trim and lowercase the answer (unless it's case dependent)
02:57:51 <shapr> sounds easy enough :-)
02:58:55 <Arnia> How should I do it? Its the combination of any order of multiple choice and short answer questions that's doing my head in.
02:59:09 <Arnia> I want to know how the marking function should work with that.
03:00:06 <shapr> er, what do you mean?
03:04:59 <Arnia> I think I may have a solution but its a little awkward
03:09:13 <Arnia> The page that displays the results of marking calls a 'marked' function that returns a list of questions. For each question, it checks the type and then displays the appropriate form of reply
03:26:35 <shapr> Arnia: what kind of interaction do you want?
03:27:18 <shapr> Arnia: I'd make a superclass of Question, and subclasses of multiple and short answer
03:27:34 <Arnia> They share no implementation though
03:28:59 <shapr> Arnia: does it have to be plone based?
03:29:24 <shapr> I could probably make a decent zpt implementation in an hour or so
03:30:12 <Arnia> Yes, it has to be plone based...
03:30:26 <shapr> Arnia: I've never written ZClases or Zope Products, so I don't know how they're different
03:31:01 <Arnia> Don't worry... I just needed someone to talk it through with. I think better when I talk
03:31:15 <shapr> heh, ok :-)
03:33:15 <Arnia> I think I've found a solution to the problem. I'll probably end up hacking around with it over the next couple of weeks or so.
03:34:55 <shapr> ok
03:36:46 <Arnia> This project is scaring me a bit
03:36:57 <shapr> why?
03:37:07 <shapr> I wrote something like that before that used Python to generate javascript 
03:37:21 <shapr> and then posted the javascript values back to the server to stick into a database :-)
03:37:26 <shapr> zope is so much simpler than that :-)
03:39:05 <Arnia> It scares me cos its not just my degree on the line but four other people's and its much bigger than just a quiz product, its a courseware product
03:39:14 <shapr> ohh
03:39:35 <shapr> I'm planning on writing a courseware product also
03:39:42 <shapr> but not for zope initially
03:40:11 <Arnia> Aha
03:40:44 <shapr> I'm starting a new company, we're about two weeks away from our grand opening
03:41:07 <Arnia> That's cool
03:41:23 <shapr> one of our strong points appears to be building e-learning solutions
03:41:44 <shapr> we can do content and frameworks
03:42:31 <shapr> hi dark !
03:42:41 <shapr> dark: I think we're ready to announce, any objections?
03:47:05 <dark> shapr: No objections :)
03:47:09 <shapr> yay!
04:45:44 <shapr> I don't know how detailed I should make my types.
04:47:11 <mgoetze> as detailed as necessary, but not more :)
04:47:35 <shapr> when I first started with OOP, I tried to make huge object hierarchies
04:47:48 <shapr> nowadays I know when to make something an object, and when it's just not necessary
04:48:03 <shapr> I haven't yet figured out that level for creating types in Haskell 
04:52:10 <shapr> hi ustenzel 
04:53:06 <ustenzel> hi
04:54:02 <shapr> what's up?
04:56:19 <ustenzel> not much.  haven't put haskell to good use recently.
04:56:40 <shapr> written any code you want to put into haskell-libs ?
04:57:04 <ustenzel> no, nothing.
04:57:13 <shapr> haskell-libs is trying to be a wiki-style cvs tree
04:57:32 <ustenzel> oh, nice idea.  URL?
04:57:48 <shapr> sf.net/projects/haskell-libs
04:58:31 <shapr> there's an irc bot, a haskell library tracker, and the beginnings of an rfc822 parser in there so far
04:58:37 <mgoetze> shapr: what's the status of iohc?
04:58:47 <shapr> mgoetze: about to start
04:59:06 <shapr> I do have two questions I'm not sure about
04:59:22 <shapr> a) should we move the deadline up so people have time to write new code?
04:59:31 <shapr> b) how long should the judging period be?
04:59:52 <shapr> I assume I should announce the iohc-jury list as the submission address?
04:59:56 <ustenzel> shapr: an rfc822 parser?  nice, i was about to write one myself.
05:00:11 <Igloo> New code good
05:00:11 <shapr> ustenzel: yay!
05:00:21 <shapr> ustenzel: I want some email tools
05:00:34 <shapr> maybe even a rudimentary mua and mta
05:01:24 <shapr> I've been doing this parser in Parsec to learn Parsec, rfc822, and how to write larger chunks of code with Haskell.
05:01:32 <mgoetze> shapr: yeah, it's open to mails from anywhere, so fine for submissions. if you need me to run spamassassin or something on it, let me know
05:01:38 <ustenzel> i want a list archiver.  i have experience with pipermail, mostly bad experience, though.
05:01:41 <shapr> mgoetze: ok, cool.
05:01:54 <Igloo> Does the POSIX stuff (or other GHC libraries) include file locking functions?
05:02:03 <Igloo> Although I guess you can use the FFI anyway
05:02:08 <mgoetze> shapr: also, if you need webspace or anything, let me know as well :)
05:02:12 <ustenzel> so i was about to build one in haskell.  WASH is already there, with an rfc822 parser it's almost done :)
05:02:29 <shapr> ustenzel: want me to add you to the haskell-libs project? I'd be happy to turn my efforts towards your list archiver project
05:02:50 <shapr> do you have a sourceforge userid?
05:03:26 <ustenzel> no, not yet.
05:03:59 <ustenzel> shapr: well, that's a good reason to get one.  i'll get back to you one i have one.
05:04:08 <shapr> if you register for one, you can be in haskell-libs in less than an hour :-)
05:04:16 <shapr> ok, cool
05:04:57 <norpan> haskell-libs!
05:05:00 <shapr> yay!
05:05:15 <shapr> hej norpan, vad gör du?
05:05:22 <norpan> jobbar
05:05:26 <shapr> whee
05:05:41 <shapr> jag kodar ;-)
05:06:04 <shapr> hi ChilliX 
05:06:05 <norpan> de två sakerna är oftast ekvivalenta för mig
05:06:12 <ChilliX> Hi Shapr!
05:06:27 <shapr> ChilliX: we have a mailing list
05:06:27 <Igloo> Hey Chilli
05:06:42 <shapr> http://www.mgoetze.net/mailman/listinfo/iohc-jury
05:07:25 <ChilliX> Hi Igloo
05:07:43 <norpan> there are indeed some hakell library projects on sourceforge
05:07:45 <shapr> norpan: det ar brå!
05:07:53 <shapr> yah, wxHaskell is a new one
05:08:23 <shapr> ChilliX: I've set the submission deadlide for march 1st, that's about 2.5 weeks, do you think it's too short?
05:08:32 <norpan> i'm only a member of haskell-i18n :)
05:08:32 <shapr> how long do you think the judging period should be?
05:08:35 <ChilliX> shapr: ok, subscribed
05:08:40 <shapr> yay!
05:08:44 <mgoetze> oh, work to do :)
05:09:28 <shapr> someone on c.l.f created alt.comp.lang.haskell, but it hasn't arrived at my news server yet.
05:09:34 <norpan> obfuscated haskell, sigh
05:09:39 <ChilliX> If there are not many subs at 1 March, you can always extend
05:09:44 <shapr> good point
05:10:01 <ChilliX> judging...difficult to say, depends much on the number of the subs
05:10:19 <shapr> what do thing is a good round number?
05:10:31 <shapr> one week? two weeks? a month?
05:10:39 <ChilliX> more like 2-3 weeks
05:10:41 <shapr> long enough for us all to learn about comonads? =)
05:10:46 <ChilliX> hehehe
05:10:54 <norpan> where is this contest, google doesn't find it
05:11:03 <shapr> norpan: it hasn't been announced yet
05:11:09 <norpan> oh, that's why
05:11:18 <shapr> it will be announced in less than an hour though :-)
05:11:32 <ChilliX> Tata!  C->Haskell 0.11.1 is out!
05:11:42 <shapr> you can see the current rules and info here: http://haskell.org/wiki/wiki?ObfuscatedHaskellContest
05:11:43 <ChilliX> Igloo: your patch is in - thanks!
05:11:54 <mgoetze> ChilliX: you, uhm, subscribed?
05:11:56 <shapr> yay! new code!
05:12:05 <Igloo> Cool, and thank you  :-)
05:12:08 <norpan> yay! new incompatibilities!
05:12:19 <ChilliX> mgoetze: well, I filled in the mailman form, I guess, I still need to reply to the auth email
05:12:35 <mgoetze> ah, right
05:12:43 <mgoetze> (because after that i will need to approve you :)
05:13:29 <shapr> mgoetze: er, what's my iohc-jury password? I think you added me manually, so I don't have one.
05:13:52 <ChilliX> mgoetze: done
05:13:54 <dark> You'll get mailed about it every month :)
05:13:54 <shapr> norpan: planning on entering the IOHCC, yes?
05:14:01 <shapr> dark: I don't want to wait that long ;-)
05:14:13 <dark> I've been thinking of putting mailman password mails in my spam rules.
05:14:29 <shapr> ok, the iohc-jury members are: ChilliX, dark, Igloo, shapr, and Pseudonym
05:14:44 <mgoetze> actually, i've disabled password reminders...
05:14:52 <Igloo> What I need is something that replaces an existing password list with a new one as long as the informatino in the new one is a superset of the old
05:14:53 <shapr> dark: I have a gnus-sorting method to dump mailman reminders in a single group
05:15:04 <shapr> Igloo: you could do that with gnus I think
05:15:43 <shapr> I think it's cool we have five jurors from five countries, and three continents
05:15:44 <Igloo> I want my MDA to do it, not my MUA
05:15:49 <mgoetze> hm, so yeah, what is shapr's password? lol
05:15:49 <Igloo> :-)
05:16:02 <Igloo> Can you not get yoru password e-mailed from the list webpage?
05:16:20 <shapr> oh, duh!
05:16:22 <shapr> yes I can :-)
05:16:59 <shapr> ok, all jurors who are awake, take a moment to look at the wiki page and tell me if you see anything out of order
05:17:15 <shapr> if no one sees anything, I'll announce on haskell@haskell.org and comp.lang.functional
05:17:39 <norpan> i think March 1 is a bit short of time
05:17:50 <mgoetze> yeah, maybe 1. April?
05:18:03 <shapr> it's a short amount of time because this is the 0th contest
05:18:07 <norpan> March 31 so no one thinks it's an aprils fool
05:18:10 <Igloo> Missing a C in IOHC
05:18:36 <norpan> International Obfuscated Haskell Contest
05:18:37 <Igloo> Could link to IOCCC
05:18:39 <shapr> some people have said that they weren't sure the IOHCC was going to be interesting to people, and some said it might really be possible to write obfuscated code in Haskell
05:19:07 <mgoetze> HaskellIrcChannel needs to be updated (irc.freenode.net, and number of people)
05:19:09 <shapr> I don't know how the haskell community will react, so this is the prototype
05:19:13 <norpan> i've seen some seriously obfuscated code, and that was not even meant to be
05:19:15 <shapr> mgoetze: oh, good point.
05:19:30 * Igloo -> comlab
05:19:35 <ChilliX> judging from the average assignment submission in COMP1011 at UNSW, you surely can write obfuscated Haskell code!
05:19:40 * shapr laughs
05:20:09 <dark> Any language that allows you to define new infix operators on the fly has obfuscation capabilities :)
05:20:27 <ChilliX> dark: good point :-)
05:20:36 <shapr> Pseudonym said it was hard to choose between judging and entering :-)
05:22:23 <norpan> let f=f f in `f`f`f`
05:22:23 <eivuokko> Well, template haskell and ghc pragmas for rules can do nice job too ;-)
05:22:23 <shapr> so I figure we'll get some fun entries
05:22:23 <shapr> eivuokko: yah, TH scares me =)
05:22:23 <Marvin--> well, I've handed in the application *gulp*
05:22:23 <shapr> but I haven't been able to build TH locally :-(
05:22:23 <dark> I think template haskell is cheating :)
05:22:23 <shapr> that's why it's limited to 'latest released implementations' only
05:22:23 <norpan> let f=f in f`f`f is actually a valid haskell expression
05:22:23 <shapr> I don't want to install ghc3 ;-)
05:22:32 <norpan> why can't i use GOFER? :)
05:22:35 <shapr> oh, I need to specify that each submission should include a short description so that the judges aren't totally mystified.
05:22:43 <shapr> the 'hints' file of IOCCC
05:24:11 <norpan> gofer230a is as recent as 1994
05:24:35 <norpan> postdates haskell 1.2
05:25:18 <dark> shapr: What about public domainness?
05:25:58 <dark> I think the contest results should be siggable, if of appropriate length :)
05:26:07 <shapr> oh, good point
05:26:42 <shapr> is public domain an acceptable license?
05:27:07 <dark> This is a frequently debated point :)
05:27:37 <mgoetze> if it's public-domained in a sufficiently obfuscated manner? :)
05:27:42 <shapr> heh
05:27:55 <shapr> ok, anyone have problems with specifying a public domain license?
05:27:57 <dark> I've heard it's not possible to place works in the public domain in all countries.
05:28:18 <eivuokko> I think that it must contain "license" that gives competition holders ability to relicense as they wish.
05:28:56 <shapr> that sounds ok to me
05:29:40 <dark> The IOCCC rules have this:
05:29:41 <dark> 7) The program must be of original work.  All submitted programs are
05:29:42 <dark>        are thereby put in the public domain.  All explicitly copyrighted
05:29:42 <dark>        programs will be rejected.
05:30:11 <shapr> yah I think I'll put that as the first rule point.
05:31:33 <shapr> ok, anything else?
05:31:49 <Marvin--> you haven't gotten started YET? :)
05:31:54 <shapr> Marvin--: :-P
05:32:19 <shapr> Marvin--: take a look at the wiki page and see if you can spot anything we've missed :-)
05:32:28 <Marvin--> URL again?
05:32:33 <shapr> http://haskell.org/wiki/wiki?ObfuscatedHaskellContest
05:33:13 <Marvin--> you might want to put the real names of the jurors and nicks in parentheses :P
05:33:57 <Marvin--> er, that is, put the real names of the jurors there, and only have the nicks in parentheses
05:34:04 <Marvin--> damn ambigous natural languages 
05:34:32 <shapr> ok
05:36:28 <shapr> done
05:36:53 <shapr> anything else?
05:37:15 <Marvin--> not that I can think of right now
05:37:26 <shapr> ok then, I'll announce
05:37:32 <Marvin--> but then, I'm way too nervous to think straight at all
05:39:59 * galority likes the International Obfuscated Haskell Code Contest Idea and has made it already public on the university's newsserver.
05:40:18 <shapr> yay!
05:41:04 <galority> unfortunatly I have not enough time at the moment to code for that :-(
05:41:20 <Marvin--> who does
05:41:49 <galority> hopefully a lot of people ;o)
05:42:08 * galority waiting for the winner in the "signature" category
05:56:00 <Jadrian_> hello
05:56:09 <shapr> hiya
05:56:21 <Jadrian_> hi shapr
05:56:26 <Marvin--> bah, josef complains we have code that's hard to read
05:56:31 <Marvin--> maybe we should submit it
05:56:32 <Jadrian_> any idea why I can't do this?
05:56:36 <Jadrian_> type CTPar = ([Double],Int,Int)
05:56:37 <Jadrian_> ctPar          ::(?ctPar::CTPar)=>CTPar 
05:56:37 <Jadrian_> ctPar@(us,n,j) = ?ctPar
05:56:45 <Marvin--> dang, it's 22k :)
05:56:57 <Jadrian_> don't understand how the mono. rest. is afecting me here...
05:57:30 <Jadrian_> I got a triple as an implicit parameter and I want to refer to each of their components...
05:58:16 <Jadrian_> I can't use pattern matching in anyway and there are no projections for triples and such
05:58:47 <Smerdyakov> Why can't you use pattern matching
05:58:58 <Jadrian_> well that's my question! :)
05:59:21 <Smerdyakov> Why are you using => in a type?
05:59:26 <Jadrian_> I have that implicit par. ctPar
05:59:30 <mgoetze> Jadrian_: hey, that looks like you could submit it to the obfuscated haskell contest :)
05:59:36 <Jadrian_> lol
05:59:39 <Smerdyakov> Oh, this is a type class thing?
05:59:43 <norpan> case ?ctPat of (a,b,c) -> use a b c
06:00:16 <Jadrian_> norpan: not quite
06:00:23 <norpan> or let (a,b,c) = ?ctpat in 
06:00:29 <Jadrian_> norpan: try it and you'll understand it
06:00:53 <Jadrian_> norpan: I want to refer to the fst componet of the implicit par. as a, the second as b etc
06:01:21 <Marvin--> Jadrian_: *globally*?
06:01:26 <Jadrian_> norpan: yeap
06:01:37 <Jadrian_> Ok without implicit parameters
06:01:47 <Marvin--> I don't follow
06:01:53 <norpan> Jadrian_: so, what's wrong with using case or let?
06:02:18 <Jadrian_> type CTPar = ([Double],Int,Int)
06:02:18 <Jadrian_> ctPar          ::CTPar 
06:02:18 <Jadrian_> ctPar@(us,n,j) = someCTPar
06:02:24 <Jadrian_> this works
06:02:55 <Jadrian_> and from now on I can refer to the fst comp of someCTPar as us, second as n etc
06:03:02 <Jadrian_> ok?
06:03:13 <norpan> darn that's ugly
06:03:24 <Jadrian_> ugly? how would you do it?
06:03:25 <Marvin--> doing that on top level seems very ugly to me
06:04:12 <Jadrian_> not if you keep needing to refer to each component individualy
06:04:14 <Marvin--> so what you want is that you want top-level bindings us,n,j having types (?ctPar :: CTPar) => [Double]/Int/Int ?
06:04:23 <Jadrian_> yeap!
06:04:25 <Jadrian_> exactly
06:04:44 <Jadrian_> I can't do it like I did it above
06:05:04 <Marvin--> I still think it'd be weird with top level bindings for components of an implicit parameter
06:05:20 <Jadrian_> well I need it
06:05:31 <Jadrian_> the thing is I have 3 implicit par
06:05:46 <Jadrian_> but I want to group them in a triple to +pass it around or signatures will get huge
06:05:55 <Jadrian_> but I want to refer to each one of them
06:06:33 <Marvin--> what do you care if the types are huge?
06:06:53 <Jadrian_> well I do, sigature become unreadable 
06:07:09 <norpan> three implicit parameters cries for a better solution
06:07:17 <Jadrian_> and I can bind the implicit parameter by generating the triples
06:07:17 <Smerdyakov> Unfortunately, I don't know what an implicit parameter is.
06:07:18 <norpan> like a state monad
06:07:27 <Marvin--> a :: (?foo :: (Int,Int,Int)) => Int
06:07:27 <Marvin--> a = let (a',_,_) = ?foo in a'
06:07:33 <Jadrian_> and then making a let ?triple=mytriple in something
06:07:44 <Marvin--> norpan: agreed
06:07:57 <Jadrian_> norpan: I could explain to you why I need it but no time now
06:08:11 <Jadrian_> I'll come back later to explain why the implicit parameter
06:08:15 <Marvin--> Jadrian_: I think you're stuck with putting a line for each component
06:08:29 <Jadrian_> Marvin--: yeap that's what I wanted to avoid
06:08:38 <Marvin--> Jadrian_: then redesign your code :-)
06:08:42 <Jadrian_> Marvin--: but I still don't understand why the mon. restriction problem there...
06:08:47 <Jadrian_> Marvin--: nope
06:08:52 <Marvin--> who says it's the DMR?
06:08:54 <Jadrian_> Marvin--: the code is just fine IMO
06:09:06 <Jadrian_> ghci says
06:09:10 <norpan> can you write (?(foo,bar,baz)::(Int,Int,Int)) =>?
06:09:24 <Jadrian_>     Illegal overloaded type signature(s)
06:09:24 <Jadrian_>         in a binding group for ctPar, us, n, j
06:09:24 <Jadrian_>         that falls under the monomorphism restriction
06:09:24 <Jadrian_>     When generalising the type(s) for ctPar, us, n, j
06:09:28 <Marvin--> okay, hugs says "Explicit overloaded type for "foo" not permitted in restricted binding"
06:09:59 <Jadrian_> but where is the overload here??
06:10:32 <Marvin--> I don't claim to understand implicit parameters in full, do you?
06:10:57 <Jadrian_> nope
06:11:02 <norpan> f :: (?foo::Int, ?bar::Int, ?baz::Int) => Int is too long for you?
06:11:08 <Jadrian_> I don't claim to understand anything in full
06:11:10 <Jadrian_> norpan: yes!
06:11:30 <Marvin--> then you haven't seen any long types :-)
06:11:50 * Marvin-- had a type with five monad transformers in the result, and quite a few arguments
06:12:58 <shapr> Marvin--: does the kliesli bit of a monad lifted into an arrow mean you could use it to automatically build monad transformers?
06:14:34 <Jadrian_> In fact, I came here because I was not understanding the problem with that pice of code
06:14:37 <Jadrian_> (and I still don't)
06:16:37 <ChilliX> 'night!
06:16:56 <Jadrian_> Marvin--: by the way, with your code:
06:16:59 <Jadrian_> ghc-5.04: panic! (the `impossible' happened, GHC version 5.04):
06:17:10 <Jadrian_>         tcSplitTyConApp
06:17:10 <Jadrian_>     {?ctPar{-rdgV-} :: ([GHCziFloat.Double{-3u-}],
06:17:10 <Jadrian_>                         GHCziBase.Int{-3J-},
06:17:10 <Jadrian_>                         GHCziBase.Int{-3J-})}
06:17:10 <Jadrian_> Please report it as a compiler bug to glasgow-haskell-bugs@haskell.org,
06:17:11 <Jadrian_> or http://sourceforge.net/projects/ghc/.
06:17:13 <Jadrian_> f*ck
06:17:21 <Jadrian_> type CTPar = ([Double],Int,Int)
06:17:22 <Jadrian_> us :: (?ctPar :: ([Double],Int,Int)) => [Double]
06:17:22 <Jadrian_> us = let (us',_,_)= ?ctPar in us'
06:17:27 <Jadrian_> oh well
06:17:34 <norpan> I have yet to see a problem that needs implicit parameters
06:18:04 <norpan> I find them hard to use, and the code using them hard to read
06:18:08 <shapr> mgoetze: hey, can you setup that webspace and give me the address?
06:18:28 <Jadrian_> norpan: later I'll tell you some, btu now I need to get some stuff ready in 45 min
06:18:32 <shapr> mgoetze: I just thought of one thing we all overlooked... where will the winners and possible rule updates be announced?
06:18:37 <norpan> Jadrian_: ok
06:19:19 <norpan> use the wiki so that anyone can change the rules!
06:19:22 <emu> anyone happen to know how to write truncated subtraction operator in latex?  it's a minus sign with a dot above it
06:20:32 <mgoetze> shapr: sure, do you prefer iohc.mgoetze.net or www.mgoetze.net/iohc?
06:20:58 <mgoetze> shapr: (better would be to get iohc.haskell.org CNAMEd to haydn.mgoetze.net of course)
06:21:13 <shapr> mgoetze: I'd say the first one, iohc.mgoetze.net
06:21:30 <mgoetze> ok
06:21:43 <mgoetze> shapr: got an ssh key handy?
06:21:53 <shapr> yup
06:25:13 <Marvin--> emu: can't you use \stackrel or whatever it's called?
06:27:16 <emu> it doesn't look quite right--too far apart
06:27:52 <Marvin--> okay
06:28:04 <Marvin--> there's \doteq, have you tried the obvious \dotminus? :)
06:28:38 <shapr> emu: google found two papers from  '"truncated subtraction" latex'
06:28:49 <shapr> they were bothin .ps but maybe you could find the sources for them
06:28:55 <emu> heh
06:29:38 <galority> \dot{-}
06:29:59 <galority> still too far apart?
06:30:27 <emu> yeah
06:31:13 <emu> frickin mathematicians and their symbol fetishes
06:31:52 <Marvin--> heh
06:34:24 <Jadrian_> ok, I understand why it can't be done
06:34:40 <Jadrian_> of course
06:35:50 <Jadrian_> I'd need to explicit the type signatures for us,j,n because of the context
06:35:50 <Jadrian_> argh
06:35:50 <Jadrian_> :(
06:42:31 <galority> emu: Maybe overkill: {\raisebox{0.5ex}{$\cdot$}$\!\!\!-$}
06:43:51 <Igloo> I think TH entries shold be allowed, and the short description should be in a file so people can try to decipher it without
06:44:13 * emu dies
06:44:32 <Smerdyakov> galority, not overkill if you define a new command for it
06:44:34 <shapr> Igloo: well, you're part of the jurors, if you can convince two other jurors, I'll update the rules 
06:45:03 <galority> Smerdyakov: of course, but I bet there is an easier way.
06:45:39 <galority> maybe as part of amslatex
06:45:42 <Igloo> We can always exclude TH entries from some set of awards, but I think we'll get more entries if we allow it, which may be important
06:46:38 <eivuokko> It's not "big" breakage of rules to submit TH, just that it's not compilable by released compiler :-)
06:47:07 <emu> I will just ask my professor later today
06:47:54 <Smerdyakov> Who is that?
06:48:39 <shapr> Igloo: It's okay with me, if you'll test TH submissions, and/or help me get TH compiled on my box...
06:48:55 <Igloo> shapr: What problems do you have?
06:49:23 <shapr> same problem I posted before, the build process explodes on -march=athlonmp 
06:49:36 <shapr> I've been unable to figure out why it's exploding on that
06:49:45 <Igloo> Can you not build for i386 or something?
06:49:51 <shapr> I ran -v -fvia-C Foo.hs and it is using gcc3.2
06:50:00 <shapr> I'd be happy to... how do I specify that?
06:50:27 * shapr looks at the building guide
06:51:17 <Igloo> When you run configure, what do you have instead of
06:51:17 <Igloo> checking host system type... i686-pc-linux-gnu
06:51:17 <Igloo> checking target system type... i686-pc-linux-gnu
06:51:17 <Igloo> checking build system type... i686-pc-linux-gnu
06:51:27 <Igloo> Oh, and: Canonicalised to: i386-unknown-linux
06:52:08 <shapr> I get the i686-pc-linux-gnu 
06:53:27 <Igloo> Oh, OK, that's annoying
06:53:28 <shapr> dang, I posted to haskell@ from a non-member address.
06:53:56 <shapr> Igloo: what?
06:54:06 * Igloo wonders if you reported it and if the output that goes wrong is online anywhere
06:54:14 <Igloo> It getting the same system types
06:55:05 <shapr> I removed config.cache, now it's canonical to i386-unknown-linux
06:56:10 <Marvin--> so give the host as argument
06:56:19 <Marvin--> ./configure i686-pc-linux-gnu
06:56:24 <Marvin--> (iirc)
06:56:49 <shapr> if i386 skips the athlonmp stuff, I'll be fine.
06:57:02 <Marvin--> I'm not thrilled by the "unknown" part
07:05:39 <SyntaxPolice> thats twice now I got here in the morning and someone has said my name, but it scrolled off the screen :)
07:05:50 <SyntaxPolice> (Good morning all)
07:06:13 <shapr> hi SyntaxPolice!
07:06:30 <shapr> the IOHCC has been announced! yay!
07:06:46 <Marvin--> SyntaxPolice: congratulations :)
07:11:41 <SyntaxPolice> Marvin--: thank you (for what?)
07:12:01 <Marvin--> SyntaxPolice: for the scrolling, happens to me too sometimes
07:12:27 <SyntaxPolice> Its exciting... makes me feel like a part of something, but I don't know what.
07:37:20 <Janni> huyguys
07:44:40 <norpan> harch on my athlon reports (wrongly) athlon-Linux when it should report ix86-Linux
07:44:56 <norpan> although arch reports i686
07:45:19 <norpan> this means that i can't build stuff
07:45:43 <norpan> if i add athlon as a case in the harch script it works
07:46:05 <shapr> norpan: tell me how!
07:46:25 <norpan> uname -p reports athlon though
07:46:29 <norpan> shapr: how what?
07:50:10 <jlouis_> it should report i686
07:54:40 <andersca_> norpan: is it the uname runner
07:54:41 * Marvin-- decides to have a look at helium
07:56:53 <Marvin--> compiling compiling
07:59:40 <jlouis_> helium is a subset of Haskell, right?
08:00:05 <norpan> jlouis_: where are allowed values from uname -p defined?
08:02:32 <norpan> and where is the value defined
08:03:45 <norpan> perhaps harch should use "uname -m" instead of "uname -p"
08:04:36 <norpan> or, uname -i may be even better
08:05:15 <Marvin--> jlouis_: yeah
08:06:31 <jlouis_> norpan: I am not sure if the flags are POSIX
08:07:27 <jlouis_> hler % uname -a
08:07:30 <jlouis_> HP-UX hler B.11.00 A 9000/780 2005524444 two-user license
08:07:35 <jlouis_> hler % uname -p
08:07:37 <jlouis_> uname: illegal option -- p
08:07:40 <jlouis_> so there
08:07:55 <jlouis_> uname -m works though
08:08:04 <norpan> so you cant way reporting athlon on uname -p is wrong then
08:08:32 <norpan> i'd say it's more correct than reporting i686
08:08:55 <jlouis_> depends. I think most of the x86 numbering is flawed anyway
08:08:59 <norpan> even though it obviously breaks (wrong) scripts
08:10:01 <jlouis_> I'd let it up to someone else to build decent processor determination systems. I dont think we have a good one yet though
08:10:24 <norpan> just changing the uname call in harch, or adding a line for athlon will work atm
08:10:40 <jlouis_> yup
08:10:52 <jlouis_> there is still something ''workaroundish'' about it
08:10:54 <Marvin--> time to go
08:11:12 <norpan> uname -i gives i386 for all machines i've tried it on now
08:11:29 <norpan> and SUNW,Sun-Blade-100 on my sun blade :)
08:11:44 <norpan> uname -p says sparc and uname -m says sun4u
08:12:16 <jlouis_> heh
08:12:44 <jlouis_> HP-UX is incompatible beyond hell as usual :)
08:14:44 <mgoetze> jlouis_: oh, you just have to compile a few gnu things... *evilgrin*
08:14:48 <norpan> posix flags are -a -m -n -r -s -v
08:15:10 * mgoetze has not managed to compile perl or bash on hpux, even though it is reportedly doable.
08:15:11 <jlouis_> mgoetze: hehe ;)
08:15:21 <mgoetze> (zsh, of course, was easy)
08:15:29 <jlouis_> mgoetze: HP has some site devoted to porting to HP-UX
08:15:35 <jlouis_> zsh rocks
08:16:03 <mgoetze> jlouis_: i don't want to port. i want to ./configure; make; make install :)
08:17:01 <norpan> so, using "uname -m" is the only choice
08:17:52 <jlouis_> mgoetze: then bug the GPL people for not having built their ./configure correctly
08:17:58 <jlouis_> norpan: exactly
08:18:13 <jlouis_> which does not give you the subclass of athlon, though
08:18:21 <norpan> and harch tries -m if -p gives unknown
08:18:29 <jlouis_> welcome to the real world
08:18:38 <jlouis_> -p is not even guaranteed to exist
08:18:40 <norpan> jlouis_: which we don't need
08:18:48 <norpan> we only need ix86 at the end
08:18:59 <norpan> who maintains harch
08:19:23 <norpan> hmmmm seems to be hmake
08:19:23 <jlouis_> yeah, lets build a model world in which we have an unlimited amount of memory and functional programs all terminates in constant time
08:20:06 <norpan> jlouis_: i will report this to malcolm wallace
08:30:30 <jlouis_> norpan: ok, he might have a better view of things than me though
09:36:08 * shapr bounces
09:48:28 <shapr> hi pseiko 
10:04:29 <shapr> hi esap 
10:04:33 <esap> Hi
10:04:37 <shapr> wassup?
10:05:20 <esap> hmm.. I'm reading philosophy (Divers: Possible worlds). Seems very good from the first 30 pages or so.
10:06:46 <pseiko> hi all
10:08:06 <shapr> I'm just coding on my parser
10:08:12 <shapr> I'm learning lots
10:08:19 <esap> shapr: what parser?
10:08:23 <shapr> rfc822
10:08:26 <shapr> email headers
10:09:08 <shapr> esap: it in cvs on sf.net/projects/haskell-libs if you want to look at it.
10:10:04 * esap is browsing.
10:12:08 <esap> hmm.. much more comments on the code than I write :-)
10:12:54 <shapr> well, I'm hoping other people will want to work on it also
10:14:20 <esap> what's the target of the project?
10:14:37 <shapr> creating standard libraries that seem to be missing
10:14:43 <shapr> I'm starting on email tools
10:14:53 <shapr> but there's lots of stuff we could use
10:15:03 <esap> do you think email tools need to be on a standard library? hmm..
10:15:15 <esap> seems quite specialized.
10:15:16 <shapr> I want all the libraries that come with Python
10:15:28 <radix> batteries included == yes.
10:15:45 <radix> hrrm, maybe I shouldn't use that syntax here >)
10:15:56 <shapr> esap: what do you think would be more general purpose?
10:16:11 <shapr> what would everyone use that isn't currently available?
10:17:15 <esap> well how about object model? Or support for architecture specificatoin languages?
10:17:58 <shapr> such as the ABNF used in RFCs nowadays?
10:18:06 <shapr> what sort of object model?
10:18:22 <shapr> can you give me some examples?
10:18:48 <esap> Well like O'Haskell but with reflection and meta-object facilities
10:19:07 <pseiko> hey, thats my task :-)
10:20:11 <shapr> Template Haskell gives you reflection
10:20:31 <shapr> what sort of meta-object facilities do you mean?
10:20:51 <esap> well like in CLOS, I guess.
10:21:00 <esap> But strictly typed.
10:21:32 <shapr> I don't know much about the CLOS metaobject setup.
10:21:34 <esap> Hmm.. I wasn't aware of template haskell. Thanks for the ref.
10:22:44 <esap> Clos has multimethods and allows you to define metaclasses that can describe new meaning for different facilities of the system. A bit like implementing new instances of a Monad, but for OO-style syntax.
10:25:56 <shapr> well, sounds good...
10:26:18 <esap> CLOS has quite complex method dispatching mechanism which chooses methods based on types of arguments in an OO subtyping mechanism.
10:26:27 <shapr> even so, I want to use Haskell to solve the problems I have right now.
10:26:41 <shapr> yah, I'm aware of multimethods and metaclasses
10:27:47 <shapr> I think specification language support in Haskell would be useful right now
10:28:10 <shapr> specifically, I'd like to have IETF ABNF support
10:28:49 <esap> I'm doing a specification language :-) Though I think it becomes an independent language of its own.
10:29:00 <shapr> do you have any source online?
10:29:06 <shapr> what sort of spec lang?
10:29:43 <esap> Well, actually, the idea is to build a programming language with a type system that works like a specification language (oh and the term language is the same as the type system :-)
10:30:08 <shapr> do you have some examples of programs written in that language?
10:30:35 <esap> Well I only have for an old version, my new version changed too much.
10:31:36 <esap> let me put one snippet on the web, a sec.
10:31:41 <shapr> ok
10:35:36 <esap> hmm... the ADSL provider has changed location of the web pages :-) I have to look it up where they actually are now :-) takes a bit longer :-)
10:35:44 <shapr> ok
10:38:58 <esap> ok. try http://212.246.110.78/Module1.test [I'm not sure it works, I quickly set-up the web server :-) ]
10:40:13 <esap> That's the old syntax. I don't have examples for the new syntax.
10:40:20 <shapr> connection refused :-(
10:40:41 <esap> hmmm huh. Wait a sec, maybe I have to enable inetd to accept it :-)
10:42:52 <esap> hmm. try now
10:43:44 <shapr> still refused
10:43:55 <esap> ok, I'll move to another site.
10:48:52 <esap> try http://modeemi.cs.tut.fi/~esap/Module1.test
10:50:22 <shapr> interesting
10:50:51 <shapr> looks a lot like haskell at first glance
10:50:57 <shapr> I see what you mean about a spec language
10:52:03 <esap> The design is not nearly ready, but it's very close to Haskell and cayenne [semantics is closer to cayenne than haskell though]
10:52:16 <shapr> neat
10:52:36 <esap> but I have plans for a very powerful type system for it.
10:53:25 <emu> anything interesting?
10:54:20 <esap> I use symmetries very much for designing the language. It means for example that everything (and I mean everything) has a dual in the category theory sense.
10:55:03 <emu> category theory isn't offered until next spring
10:55:10 <emu> so i haven't taken it yet
10:58:34 <esap> Well category theory is not hard. It's just very abstract :-)
10:59:15 <esap> But it's ideally suited for designing powerful programming languages.
11:01:15 <emu> how about implications of such a system =)
11:01:19 <emu> what does it mean to the programmer
11:01:20 <eivuokko> What's your meaning for "powerful" programming language?
11:01:59 <pseiko>  You have joined channel #haskell
11:01:59 <pseiko> *** #haskell topic: ["mo' nads than you", "We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/", "buddha debugger 0.4 http://www.cs.mu.oz.au/~bjpop/buddha/", "new  #sml channel for all your ML topics", "Helium 1.0 - Haskell for Students http://www.cs.uu.nl/~afie/helium/index.html", "New HTk release http://www.informatik.uni-bremen.de/htk/", "New DSP libs - http://users.snip.net/~donadio/haskell/"]
11:01:59 <pseiko> *** #haskell: topic set by shapr, 17:25:56 01/31/03
11:01:59 <pseiko> *** Users on #haskell: pseiko smkl Radek giedi Janni andersca_ jlouis_ argv[0] Jadrian_ ChilliX dark Chilli galority creature andersca skylan panoramix mgoetze kawfee Fractal eivuokko ludde flippo shapr Smerdyakov norpan Robert jlouis xkb dennisb gdsx SyntaxPolice steele clog emu Segora whee Igloo radix LoganH 
11:01:59 <esap> emu: It means that the system can express, in the types, very complex specifications (and then enforce that the program satisfies those).
11:02:03 <pseiko> *** #haskell modes: +n 
11:02:36 <emu> for what values of complex =)
11:03:29 <esap> eivuokko: powerful == you can express very specific and complex constraints (such as termination, execution time etc.).
11:03:50 <dark> How can a constraint on termination be enforced by a type system?
11:04:09 <emu> maybe there is a timeout enforced ? =)
11:04:31 <esap> dark: if you specify that your program must terminate, then the programmer must prove it. The compiler just checks that the proof is correct.
11:05:08 <dark> Aha :)
11:05:55 <esap> dark: of course, if you cannot prove it, well, then the programmer can express a weaker constraint.
11:05:58 <emu> what about programs for which you cannot..
11:06:25 <emu> is this a purely functional language, btw?
11:06:55 <esap> emu: the idea is that I provide the whole range of expressibility so that it's possible to express many things. Yes, it's a purely functional language (but I do provide I/O; the current design is not that far though).
11:07:03 <dark> Can you express conditional termination?  "function terminates if argument is finite"
11:07:15 <esap> dark: of course.
11:08:58 <emu> okay, i'm not all that experienced with this stuff but: how would proving that a program terminates differ from careful examination of the program?
11:10:09 <esap> emu: well proving that a program terminates is the same as giving a program (built from terminating building blocks) that type checks.
11:10:10 <emu> f(0) = 0; f(n+1) = f(n)  -- examination would show that for all values of n >= 0, the base case is reached
11:10:32 <esap> emu: recursion is the hard case for termination.
11:10:36 <emu> that's a primitive recursive function
11:10:51 <esap> emu: I provide separate syntax for primitive recursion and general recursion.
11:11:15 <emu> so with primitive recursion, you could ensure that it is only built out of primitive recursive parts
11:11:34 <emu> but even then you can have a program which does not terminate
11:12:04 <esap> emu: yes, and then the type system can determine that it terminates. You cannot build a non-terminating program from terminating building blocks.
11:12:35 <emu> f(0) = 0; f(n+1) = f(n+1) -- I think is a primitive recursive function too, I haven't verified it
11:12:36 <esap> emu: of course, I have to classify general recursion as non-terminating (and also infinite data structures!)
11:15:17 <esap> emu: declrations are in general quite complex and powerful mechanism. It's actually one of the major problems with the language to distinguish between different kinds of declarations in the type system. But I think I have a formalism that does close to that.
11:18:24 <esap> emu: note that x = f(x) is the same as rec x. f(x)  [that is, it uses general recursion]
11:24:02 * esap goes back to reading "Possible worlds".
11:25:14 <emu> crappy keyboards,  dangerous chairs
11:25:22 <emu> computer labs... sigh.
11:45:29 <giedi> contact computing
11:46:51 <emu> ha
11:47:31 <giedi> get them to invest in some of those old ibm model m keyboards
11:47:55 <emu> the Dells they have are alright.  it's just that they are sticky
12:11:14 <det> 3/exit
12:11:16 <shapr> hi det 
12:11:25 <shapr> whoops
12:11:57 <shapr> re det
12:12:05 <det> hi :)
12:12:09 <det> had to fix my TERM
12:12:13 <shapr> ah
12:12:17 <det> doesnt reconize "msys"
12:12:22 <shapr> nor do I
12:27:45 * shapr types himself into a corner
12:28:01 <shapr> hrm, I've never made a big tree of algebraic datatypes before
12:28:05 <shapr> I'm not sure I'm doing this correctly
12:31:19 <det> what are you making ?
12:31:30 <shapr> the type tree for this rfc822 parser
12:31:52 <shapr> I think it's like the first time I dove into objects, I tried to make *everything* an object
12:31:54 <det> oh
12:32:10 <det> objects ?
12:32:36 <shapr> when I first learned about OOP, I wanted to use that to do everything
12:32:48 <shapr> I'm making my first really useful algebraic types right now
12:33:01 <shapr> I think I'm suffering from the same malady
12:33:05 <det> oh, I see
12:33:11 <det> I read that incorectly
12:35:10 <jlouis_> Algebraic types?
12:35:47 <shapr> data SourceFields = TraceField Traces [Returns] 
12:35:48 <shapr>                   | OriginatorField Authentic [ReplyTos] 
12:35:48 <shapr>                   | ResentField ResentAuthentic [ResentReplyTos]
12:36:02 <jlouis_> ok, that is simple
12:36:19 <jlouis_> I have a similiar type tree in my program
12:36:26 <shapr> question is, is it the best way to match the RFC822 structure?
12:36:38 <shapr> I'm building up the types, then tearing them down again, rinse until done
12:37:00 <shapr> I have the parser nearly finished
12:37:00 <det> shapr, probally try to parralel their ABNF hierarchy
12:37:06 <shapr> det: I am trying that
12:37:17 <shapr> I'm not sure if I'm succeeding though
12:37:52 <shapr> for one thing, the more 'deeply' typed this is, the more I'll need need to add convenience functions to construct defaults, or operate on instances of the types
12:38:00 <det> shapr, what the world really needs is another RFC1459 parser!
12:39:09 <shapr> oh, we've got one of those already.
12:39:16 <jlouis_> :P
12:39:27 <emu> what this world needs is more programs that do more than parsing
12:39:27 <jlouis_> there must be billions of RFC1459 parsers
12:40:11 <shapr> truly
12:42:03 <shapr> det: see lambdabot in cvs of sf.net/projects/haskell-libs
12:49:19 * shapr stares at the types
12:52:38 <shapr> hi
12:52:53 <shapr> CrashChaos: looking for static types?
12:53:08 <CrashChaos> I'm trying to learn haskell and got the hugs interpreter. but when I try 'succ :: Int -> Int' it complains about some 'show' function
12:53:23 <CrashChaos> shapr: hey ho.. nope.. looking into functional programming in general
12:53:23 <shapr> ah
12:53:29 <shapr> FP is spiffy
12:54:00 <shapr> CrashChaos: first of all, I think you need to write that into a file and load the file into hugs
12:54:04 <CrashChaos> I'm trying to realize that.. however it's kinda disappointing right from the start when the first tutorial line doesn't want to work :)
12:54:25 <CrashChaos> shapr: tried that too.. gave me Definition of variable "succ" clashes with import
12:54:32 <giedi> heh
12:54:42 <shapr> also, I think succ is included in the Prelude, so you can't redefine without explicitly hiding it.
12:54:51 <ibid> hi
12:54:55 <shapr> hi ibid 
12:55:02 <galority> hi
12:55:13 <CrashChaos> gee it is defined indeed.. who can make so stupid mistakes in a tutorial *grrr*
12:55:20 <ibid> anybody have references on introductory fp courses at graduate level (are there any?)
12:55:22 <shapr> CrashChaos: it's like trying to redefine dir() in the python interpreter, python lets you do it, but hugs complains unless you say it's ok
12:55:44 <shapr> CrashChaos: try naming it succ1
12:55:47 * CrashChaos imagines that he's about to learn haskell in a way that would mean learning c++ by first overloading the + operator
12:56:11 <shapr> which tutorial are you following?
12:56:24 <CrashChaos> german one from uni bonn
12:56:35 <shapr> oh, I don't know it (I don't speak german)
12:56:51 <shapr> I can point you to some english tutorials
12:56:55 <CrashChaos> however it's not hugs specific.. so maybe succ isn't defined for other interpreters maybe
12:57:00 <shapr> and I can show you code I've written.
12:57:12 <shapr> nah, I'm pretty sure succ is defined for every haskell implementation
12:57:14 <CrashChaos> shapr: would be fine for me too.. do they work in hugs out of the box? :)
12:57:19 <giedi> chaos http://www.cs.lth.se/Education/LU/kurser/dat116/TwoDozenLessons/
12:57:49 <ibid> no such courses?
12:57:52 <giedi> try that one for awhile
12:58:38 <shapr> http://www.haskell.org/learning.html
12:58:42 <ibid> the students here want a course on fp and the profs say that there is no room for an undergrad course
12:59:04 <shapr> ibid: the gentle intro to Haskell might work for them.
12:59:12 <CrashChaos> shapr: got that german one from there
12:59:32 <ibid> shapr: i write my own material :-) i'm just looking for similar courses i can use as a comparison
12:59:32 <CrashChaos> giedi: thanks
12:59:47 <shapr> I've read the "Yet Another Haskell Tutorial" it's nice
13:00:07 <ibid> the only way i know how long it'll take for me to lecture something is to prepare lecture notes...
13:00:13 <shapr> makes sense
13:00:15 <ibid> five pages equals 1.5 hours for me :-)
13:00:19 <shapr> wow
13:00:21 <CrashChaos> shapr: btw.. how much 'functionality' does python have? from what I got out of the lecture today it has about all except the static typing ?
13:00:28 <ibid> shapr: fast or slow?
13:00:41 <shapr> ibid: seems like a lot of material packed into 5 pages
13:00:43 <ibid> note that i do not read or most of the time even look at the notes
13:00:54 <shapr> CrashChaos: python has some functional bits
13:01:13 <ibid> i regenerate it at the spot... but having written it gives me a benchmark on how much i can expect to cover in the 1.5 hours
13:01:15 <shapr> map, reduce, filter, lambda are the functional bits
13:01:28 <CrashChaos> and list comprehensions, higher order functions.. 
13:01:33 <shapr> right
13:01:45 <ibid> shapr: well. one 1.5 hours covered an informal version of ZFC without the obscure axioms
13:01:49 <shapr> but.... it's like doing marijuana instead of crack cocaine ;-)
13:01:52 * shapr laughs
13:01:54 <shapr> ok, bad comparison
13:02:01 <ibid> in the graduate course on formal methods that i'm coteaching
13:02:21 <CrashChaos> shapr: yeah.. definitely place for improvement in that comparison :)
13:02:28 <shapr> CrashChaos: Haskell is lazily evaluated
13:02:37 <ibid> shapr: no, haskell is nonstrict
13:02:38 <shapr> you get to play with infinite lists
13:02:44 * CrashChaos didn't yet grasp what that really means
13:02:46 <ibid> shapr: implemetations are lazily evaluating
13:02:47 <shapr> ibid: ok, close enough :-)
13:02:51 <shapr> hm, good point
13:03:08 <ibid> there is eager haskell, which afaik does not alter the semantics
13:03:09 <shapr> if you create an infinite list in Python
13:03:12 <shapr> it explodes
13:03:26 <CrashChaos> yeah.. tell me :/
13:03:37 <shapr> in Haskell, it only takes the parts of the list that it needs
13:03:57 <shapr> head (filter (> 5) [1..])
13:04:17 <shapr> that pulls [1..6] out of the list
13:04:28 <shapr> and you get 6
13:04:33 <shapr> head means "get the first item in a list"
13:04:35 <CrashChaos> yeah.. makes sense.. when it reaches the six the head tells the filter to stop
13:04:37 * ibid is considering a format based on few lectures, several projects with weekly workshops, and a final project & seminar
13:04:41 <ibid> comments?
13:04:52 <shapr> ibid: sounds good to me
13:05:01 <shapr> I like the combination of lectures and actual workshops
13:05:01 <mgoetze> ibid: eh? teaching something somewhere?
13:05:08 <ibid> mgoetze: yeah
13:05:22 <ibid> mgoetze: currently coteaching formal methods graduate course
13:05:25 <shapr> koulotus is often not about doing :-(
13:05:41 <ibid> mgoetze: but this is me planning a possible grad course on introductory fp
13:05:48 <ibid> shapr: koulutus?
13:05:53 <shapr> er, "education"
13:06:04 <shapr> did I spell it that badly?
13:06:06 <ibid> yeah, koulutus, not koulotus
13:06:10 <shapr> oh, whoops
13:06:46 <ibid> grading based on project & seminar
13:07:05 <shapr> CrashChaos: so, the whole approach in Haskell is different, for several reasons
13:07:21 <shapr> it's great fun to learn
13:07:35 <CrashChaos> shapr: I'll take your word for it :)
13:07:54 <shapr> CrashChaos: http://kungens.kemi.fi/~shae/src/haskell/Mandelbrot-0.1.hs <-- first code I wrote
13:08:15 <ibid> btw, i think some of you might want to know that i was given the "best master's thesis 2002" award by the department
13:08:21 <shapr> ibid: yay!
13:08:30 * mgoetze cheers ibid!
13:08:59 <shapr> CrashChaos: learning Haskell improved my Python code
13:09:01 <ibid> there were two recipients this year
13:09:12 <shapr> ibid: url to your thesis?
13:10:11 <ibid> http://www.mit.jyu.fi/antkaij/pubs.html
13:10:17 <ibid> (also in citeseer:-)
13:11:39 <shapr> ah, I've read part of your thesis.
13:11:55 <ibid> yeah
13:13:45 <shapr> ibid: hey, writing any cool code in your copious free time?
13:13:59 <ibid> not really
13:14:16 <ibid> i'm planning yet another pl and a yet another portable intermediate code...
13:14:23 <shapr> heh
13:14:33 <shapr> have you seen Daan Leijen's Lazy Virtual Machine?
13:14:47 <shapr> or Alan Kay's opencroquet.org ?
13:14:59 <ibid> probably not
13:15:52 <shapr> opencroquet is about portable code, you may want to check it out
13:16:39 <shapr> CrashChaos: did renaming to succ1 work?
13:17:10 <CrashChaos> shapr: of course :)
13:17:30 <CrashChaos> shapr: I mean honestly.. which python tutorial starts with defining a dir() method !?!
13:17:31 <shapr> yay
13:17:47 * CrashChaos now starts over again with that 24-lessons text
13:17:50 <shapr> you should try the Yet Another Haskell Tutorial
13:18:00 <shapr> or the 24 lessons :-)
13:18:09 <shapr> most importantly, ask questions here
13:18:24 <ibid> bah
13:18:31 <shapr> imho, the community or culture around a language is one of the most important factors.
13:18:48 <eivuokko> ibid, I read your thesis partly sometime ago.  It's sort of entertaining, even though I didn't understand all (most, maybe) of it.
13:18:57 <ibid> any clues why apache would issue 403 forbidden? the directory has o+x and the file has o+r
13:19:10 <CrashChaos> shapr: at least until it reaches a reasonable community size imho
13:19:14 <shapr> ibid: all recursive dirs have o+x ?
13:19:37 <ibid> eivuokko: it's not really written to be entertaining, glad it's more than it was supposed to be :-)
13:19:38 <shapr> CrashChaos: nah, I think it's the same then... look at the PHP code culture
13:19:46 <shapr> we got advertised on?
13:19:47 <ibid> shapr: the parent dir files are accessible
13:20:07 * CrashChaos saw how #python evolved.. basically gave me the rest
13:20:16 <shapr> gave you the rest?
13:20:37 <CrashChaos> sorry.. german saying.. like shocked me
13:20:40 <shapr> oh
13:20:42 <shapr> well
13:21:16 <shapr> there are nice people here
13:21:23 <mgoetze> CrashChaos: ja, woertliche uebersetzungen sind die schoensten, nicht? ;)
13:21:40 <shapr> and the people who are responsible for this channel try hard to keep it that way.
13:21:44 <CrashChaos> mgoetze: man versuchts eben immer wieder ;)
13:22:06 <ibid> ahh!
13:22:06 * emu is a mean person
13:22:14 <shapr> ibid: what was it??
13:22:16 * emu snuck here, under the careful watch
13:22:21 <shapr> emu: hah!
13:22:23 <CrashChaos> shapr: it was a great channel in the beginning.. to me it started to become aweful when twisted came up
13:22:23 <ibid> it seems that when multiviews is on, o+r is required for directory access
13:23:12 <emu> whats twisted
13:23:13 <shapr> CrashChaos: I saw it too, but I'm still not sure what happened.
13:23:15 <ibid> shapr: http://www.mit.jyu.fi/antkaij/tmp/bsrep.pdf - here's my intermediate code spec incomplete draft
13:23:43 <mgoetze> yeah, emu is very mean. he killed lots of my stones :(
13:23:55 <CrashChaos> emu: you best ask in #python.. I never got an answer better than "it's a big code box that does everything you ever dreamt of"
13:24:41 <shapr> twisted is a network toolkit, sort of
13:24:51 * shapr reads ibid's spec
13:25:12 <emu> what's the big deal
13:26:00 <galority> emu: any news about your \dot{-}?
13:26:10 <CrashChaos> the problem just was that once it came up I could not get _any_ useful answer anymore.. whatever I asked the answer was twisted.. whatever approach I made it was smashed down because twisted can do that.. anyways.. oughta read the 24 lessons rather than rambling
13:26:18 <emu> why are people so obsessed about a language that the implementors  dont care enough to provide a compiler for?
13:27:00 <shapr> ibid: nifty stuff
13:27:06 <emu> galority: not yet
13:27:11 <shapr> ibid: you may also be interested in idel by Darius Bacon
13:27:16 <emu> galority: i was going to ask, but decided not to bother in class
13:27:29 <ibid> somebody once said about an algol 60 implementation: "made for fun and call by name"
13:27:35 <galority> emu: k ;o)
13:27:35 <ibid> this is something like that ;-)
13:27:40 <ibid> shapr: urls?
13:29:42 <shapr> http://accesscom.com/~darius/software/idel/index.html http://opencroquet.org/summary.html http://www.cs.uu.nl/~daan/papers/lvm.pdf
13:30:20 <ibid> having unsigned words and signed doublebytes gives one fun load instruction mnemonics:
13:30:26 <ibid> LUW - load unsigned word
13:30:33 <ibid> LSD - load signed doublebyte
13:31:53 <ibid> shapr: my goals with CPIC is closer to pcode than JVM or Idel: i'm interested in bootstrap portability, not sandboxing untrusted code
13:32:54 <shapr> hm
13:33:01 <shapr> I've thought about that some
13:33:07 <shapr> but I haven't come up with any conclusion yet.
13:33:11 <ibid> ...?
13:33:43 <shapr> how to write a system that given the spec for a new CPU can cross-compile and bootstrap itself.
13:34:03 <ibid> well i'm not interested in that
13:34:13 <shapr> ok, I'm confused then :-)
13:34:17 <shapr> explain?
13:34:59 <ibid> more like getting a bootstrap compiler for a new arch easily: you have a portable compiler targeting the portable intermediate code, which you can easily make run on the new platform. then you retarget it.  no need for cross compilation
13:35:26 <ibid> (and also i'm hoping cisis to be usable as introductory language, so it's important to have an absolutely portable implementation)
13:37:33 <shapr> sounds nifty, I suspect I don't understand all the implications
13:37:50 <ibid> ask? :-)
13:39:20 * shapr thinks
13:40:08 <shapr> compiler targets icode, icode can easily run on the new platform, yes?
13:40:14 <steele> ibid: thats how ocaml bootstraps, the bytecode interpreter is about 10k lines of c
13:40:34 <shapr> I think I don't understand the bootstrap process
13:40:48 <whee> erlang may also do it that way, the runtime is in C while the rest in erlang or beam bytecode
13:40:59 <whee> I don't really understand what you're talking about :)
13:41:06 <ibid> steele: ugh, your nick nearly gave me a heart attack
13:41:14 * shapr grins
13:42:02 <shapr> ibid: did you see Simon PJ and Simon M show up here? 
13:42:10 <ibid> no
13:42:20 * ibid was solely in OFTC for a month
13:42:23 <shapr> oh
13:42:28 * ibid is alone in #haskell there
13:42:32 <shapr> oh no!
13:42:48 <shapr> ibid: write an echo plugin for lambdabot
13:43:03 <ibid> too much workload already :-)
13:43:19 <shapr> yah, I'm trying to get email libs together myself
13:43:35 <shapr> I want to add a keyword search for FP papers to lambdabot
13:43:57 <shapr> CrashChaos: any other questions?
13:44:23 <shapr> ibid: oh, hey, there's a new haskell contest
13:44:27 <shapr> the IOHCC !
13:44:30 <ibid> hm?
13:44:36 <ibid> url?
13:44:46 <shapr> http://iohc.mgoetze.net/
13:44:46 <mgoetze> ibid: #haskell is just way too cool for oftc ;)
13:44:51 * shapr grins
13:45:26 <ibid> heh
13:45:34 <CrashChaos> shapr: not atm thanks :)
13:45:35 <shapr> ibid: think you'll submit an entry? :-)
13:45:46 <ibid> UUUUUUUUUUUUUUUUUUUUUUUUGGGGGGGGGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH!!!!!!!!!!!!!!!
13:45:50 * shapr snickers
13:46:04 <shapr> I think that's a no.
13:46:30 <ibid> no, that's just me fainting
13:46:39 <ibid> i'll think about it :-)
13:46:52 <shapr> I'm especially interested in the .signature category
13:47:03 <shapr> since I might see something extra cool I can use
13:48:05 <shapr> actually, I'm looking forward to any submissions that we get
13:48:20 <shapr> I know I'll learn something cool I didn't know before.
13:51:38 * shapr fights the type system
13:55:50 <emu> hard battle
14:00:57 <SyntaxPolice> don't fight it, man... go with it...
14:05:31 <emu> fight the power!
14:05:43 <emu> don't let the Man push you around
14:32:03 <CrashChaos> shapr: q: why doesn't reverse True work?.. is there some relation to reverse handling strings like lists of chars?
14:32:52 <dark> Well... True is not a string.
14:33:20 <CrashChaos> so true is kinda like a template working on list structures?
14:33:28 <CrashChaos> s/true/reverse/
14:35:58 <Igloo> It uses parametric polymorphism. It has type [a] -> [a], i.e. it takes a list of some type a and returns a list of that type a
14:41:07 <Jadrian_> hello
14:41:28 <Jadrian_> where can I get some info about the Random Number generator that ghc uses
14:41:41 <Jadrian_> (well for generating Doubles)
14:42:07 <Jadrian_> I can find anything in its documentation, and the standard libraries report doesn't seem to define it
14:42:13 <dark> I tend to look in /big/dark/ghc5-5.04/upstream-ghc/libraries/base/System/Random.hs :)
14:44:30 <shapr> CrashChaos: reverse works on any list
14:44:57 <Jadrian_> dark: sources?
14:45:27 <Jadrian_> dark: I'm not really interested in the implementation, just want to know what kind of rand. num. generator it is
14:45:39 <dark> Jadrian: I think there are comments in the source.
14:45:43 <Jadrian_> ah
14:48:41 <shapr> oh we have our first IOHCC entry!!
14:48:53 <shapr> oh it's nice tooo
14:48:56 <shapr> ooohh
14:48:59 <dark> Yeah, and I think it proves that there is such a thing as obfuscated haskell :)
14:49:05 <shapr> truly it does!
14:49:20 <shapr> and he claims it's not very obfuscated
14:49:25 <shapr> I haven't figured out what it does yet.
14:49:39 <Jadrian_> eh, the coments are just html stuff... the same that is in the report :(
14:49:40 <dark> He sent another mail with an explanation.  But you might not want to look yet :)
14:49:46 <shapr> yes, good point
14:49:49 <shapr> I must run it first!!
14:49:51 <Igloo> I think discussing it in public is probably bad form?
14:49:55 <shapr> Igloo: oh, right
14:49:56 <dark> Jadrian: Oh, then I misremembered.  I thought there was something relevant near the split function.
14:49:58 <Jadrian_> wait
14:49:58 <shapr> sorry :-(
14:49:59 <Jadrian_> lol
14:50:01 <Jadrian_> never mind :)
14:50:30 <Igloo> No problem, I meant talking about how it works somewhere there might be other people who want to enter which you didn't do  :-)
14:50:59 <shapr> Igloo: you're absolutely right, I just wasn't thinking
14:51:05 <shapr> thanks for pointing that out
14:51:20 <shapr> Igloo: come to #iohcc
15:21:04 * shapr bounces happily
15:21:55 * Robert makes shapr bounce even more.
15:23:32 * shapr bounces off the walls
15:40:12 <shapr> heya Pseudonym!
15:40:16 <Pseudonym> G'day.
16:04:36 * shapr yawns
16:10:11 <shapr> hi kawfee 
16:30:53 <shapr> hi Heffalump 
16:30:58 <shapr> what's up?
16:35:23 <Heffalump> not much, just saw the announcement and thought I'd drop in :-)
16:38:02 <kawfee> hello
16:41:13 <shapr> Heffalump: we're online!
17:00:11 <shapr> must sleep....
17:00:15 <shapr> g'nite all
17:04:54 <Pseudonym> Night.
17:19:57 <engstad> How do you force strictness, like e.g.: foldr (+) 0 [1..1000000].
17:20:18 <engstad> Is there a way for ghc to precalculate that?
17:20:27 <Pseudonym> Try foldl' instead.
17:20:32 <engstad> ghci?
17:20:34 <Pseudonym> Or even better: sum
17:21:07 <engstad> Well, yes I know, but that's not the point - how do you force strictness.
17:21:36 <Pseudonym> Have a look at the definition of foldl' in the prelude.
17:22:09 <engstad> Ok.
17:22:48 <engstad> sum = foldl' (+) 0
17:23:19 <Pseudonym> That's the definition of sum.
17:23:22 <Pseudonym> Not foldl'.
17:23:26 <engstad> Oh, foldl' f a (x:xs) = (foldl' f $! f a x) xs
17:23:31 <Pseudonym> Note the $!
17:23:42 <engstad> So, what does the '$!' do? Same as '$'?
17:23:53 <Pseudonym> Yes, except it strictly evaluates its argument first.
17:24:06 <Igloo> Same as $ but forces the RHS to weak head normal form
17:24:26 <engstad> WHNF?
17:24:30 <Igloo> Yup
17:24:31 <engstad> What's that?
17:24:42 <Pseudonym> Weak Head Normal Form
17:24:58 <Pseudonym> At a first approximation, that means it evaluates it.
17:25:02 <Igloo> If you think of it as a tree it means it works out what sort of node is at the root of a tree
17:25:04 <engstad> Yes, I've seen that term before - but I'm from ML land, not Haskell land. :-)
17:25:25 <Igloo> So rather than being <something> a list is either [] or <something>:<something>
17:25:38 <Igloo> And an integer is the actual integer
17:25:53 <engstad> Ah, ok so it is kind of like "one-level evaluation".
17:26:56 <Igloo> If you like  :-)
17:28:18 <engstad> So: strict f x = f $! x
17:28:35 <Smerdyakov> Or just: strict = $!
17:28:35 <Smerdyakov> :P
17:28:36 <Smerdyakov> er
17:28:40 <Smerdyakov> Or just: strict = ($!)
17:28:42 <engstad> ;-)
17:29:32 <engstad> That reminds me, I understand the 'const' function, but why is it nescessary?
17:33:35 <Pseudonym> Same reason as "id".  It's for putting in higher-order calls.
17:34:03 <engstad> Hmm, yes I suppose.
17:34:41 <Igloo> I think I used it a lot in parser combinators and parser, but I could be wrong
17:34:55 <Igloo> I certainly use it, but that's the only example I can think of OTTOMH
17:39:50 <Pseudonym> It's actually the K combinator from SK combinators.
17:40:53 <Pseudonym> Take, for example, "length".
17:41:10 <Pseudonym> It can be expressed as: length xs = sum (map (const q) xs)
17:41:19 <Pseudonym> length xs = sum (map (const 1) xs)
17:41:34 <Pseudonym> Sorry.
17:41:51 <Pseudonym> This isn't a good example, but there are real situations where you only have the equivalent of "map", and it's just easier to put "const" in there than define another visitor.
17:42:18 <engstad> How come one can't write: length xs = sum (map 1 xs)
17:42:45 <Pseudonym> map takes a function as its first argument
17:42:48 <Pseudonym> 1 isn't a function
17:43:43 <engstad> In math 1 is... or rather you treat 1 as a the constant function 1.
17:43:59 <Pseudonym> Kind of the same in Haskell.
17:44:12 <Pseudonym> You can think of 1 as a function which takes no arguments.
17:44:22 <engstad> Like, if I write 1(x), you know that I mean 1(x) = 1 for all x.
17:44:31 <Pseudonym> Yes, I see what you mean.
17:44:36 <Pseudonym> I guess you could overload that.
17:44:44 <Pseudonym> Still, that's what "const" is. :-)
17:44:51 <engstad> Yes.
17:45:14 <engstad> I guess error messages would be even more cryptic, because you can't know how many args there should be after "1".
17:45:33 <engstad> Like: (1 2) == 1
17:45:48 <Pseudonym> Yes.  Besides, (1 2) is almost always an error.
17:45:55 <Pseudonym> You want the compiler to catch errors.
17:45:57 <engstad> Exactly.
17:46:09 <engstad> I guess that explains it then.
17:46:14 <Pseudonym> Making it mean something may make for good mathematical notation, but it's not necessarily a good idea in a programming language.
17:46:41 <engstad> *nod*
17:47:10 <engstad> I wish Haskell didn't use the '.' for composition though.
17:47:27 <engstad> Hate writing 0.0, 1.0, etc.
17:48:19 <Igloo> Huh?
17:48:35 <engstad> You can't write: .0 + 3.
17:48:45 <Heffalump> DYM 0.1 not 1.0 ?
17:49:18 <Igloo> Ah. Well, forces the code to be more readable at least
17:50:28 <engstad> That's unreadable, you think?
17:52:10 <Pseudonym> I think that mixing syntaxes is unreadable.
17:52:15 <Pseudonym> .0 + .5 is arguably readable
17:52:19 <Pseudonym> 0. + 5. is, too
17:52:25 <Pseudonym> As is 0.0 + 5.0
17:52:29 <Pseudonym> But .1 + 3.?
17:52:35 <Pseudonym> Looks like a FORTRAN operator.
17:52:50 <Pseudonym> OK, not "unreadable".
17:52:54 <Pseudonym> More like "less readable".
17:53:41 <engstad> It's probably hurting your eyes, because the comma represents composition to you., so you "see" <something> "pipe" 0 + 3 "pipe" <something else>.
17:53:48 <engstad> s/comma/dot.
17:54:12 <Pseudonym> No, it looks to be like "1 + 3" with dots for bookends.
17:54:26 <engstad> :-)
17:55:45 <engstad> Well, at least it's not so bad as Lisp.
17:55:55 <Pseudonym> Nothing is so bad as Lisp when it comes to syntax.
17:56:18 <engstad> Tell me about it...
17:56:55 <engstad> It's interesting that Haskell doesn't "need" macros in the same way Lisp does. HOFs do the job instead.
17:57:27 <Heffalump> well, it depends on what your compiler guarantees
17:57:27 <Pseudonym> Yes.  Though a textual preprocessor is occasionally useful.
17:57:33 <Pseudonym> Mostly when you need to port between compilers.
17:58:39 <engstad> *nod*
23:40:26 * shapr yawns
23:40:44 <shapr> good morning #haskell!
23:41:22 <creature> Morning shapr.
23:46:24 <galority> morning
23:49:58 <ChilliX> Moin shapr
23:50:44 * shapr bounces
23:51:19 <Robert> You bounce way too much, shapr.
23:51:28 <shapr> I'm a hyperactive kind of guy.
23:52:19 <shapr> but now, I have to go to swedish class
23:53:14 <Robert> Ooh,.
23:53:17 <Robert> Have fun!
23:53:30 <shapr> jag ska!
23:53:33 <Robert> :)))
23:53:41 * Robert will go to an English class soon.
23:54:16 * creature has an Electronics lecture in about an hour.
