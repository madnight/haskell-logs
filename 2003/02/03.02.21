01:00:48 <shapr> good morning!
01:19:27 <Hase^^on> morning
01:27:14 <Marvin--> ugh, every damn function is becoming monadic
01:29:40 <shapr> hi Fractal6
01:29:44 <Fractal6> Hello.
01:29:56 * shapr bounces
01:30:07 <shapr> Marvin--: you could switch to arrows
01:30:19 <Fractal6> shapr ?
01:30:34 <Fractal6> It's cool how freenode.net has ipv6 support now
01:31:02 <Fractal6> It's especially cool. Stops the kiddies from nmapping me. :)
01:31:24 <Fractal6> Not so bad on freenode, though...
01:32:48 <Marvin--> shapr: ugh
01:33:11 <Marvin--> I have to measure the stack usage of the instructions
01:33:21 <Marvin--> leading to counter-intuitive code like  incStack 2; incStack (-2)
01:33:37 <shapr> Fractal6: I haven't tried irc'ing via ipv6 yet
01:33:54 <Marvin--> so I'm thinking perhaps I should put the instruction sequence in the state instead and have a monadic function for adding instructions, that would also take care of the stack usage
01:33:57 <Marvin--> but that's ugly ugly ugly
01:34:44 <Marvin--> but probably less ugly than inserting incStack stuff all over the code
01:34:59 <Marvin--> and less risk for errors
02:11:56 * shapr bounces impatiently
02:18:21 <Marvin--> bounce impatiently?!
02:18:31 <shapr> yes, that's a much less vertical bounce
02:18:39 <shapr> many more horizontal vibrations
02:19:25 <Marvin--> oh
02:21:34 <shapr> I'm doing xslt today
02:21:53 <shapr> it's like digging a hole with a spoon.
02:23:30 <shapr> hi tez 
02:26:20 <tez> Hi
02:26:39 <shapr> wasssup?
02:27:31 <tez> Not much really
02:28:49 <shapr> written any cool code lately?
02:29:49 <tez> No, afraid not.
02:30:11 <shapr> written any code lately?
02:30:57 <tez> No, afraid not :)
02:37:48 <shapr> what are you doing with your life?
03:18:59 <eivuokko> shapr, you don't like xslt? :)
03:20:07 <shapr> I haven't really used it enough to have a definite opinion
03:20:26 <shapr> but it feels like a purely functional language that is missing a lot of pieces
03:23:48 <eivuokko> Yea, it is :)  But I like how easy it's make small tweaks to xml structure or debug xml stuff with it.
03:24:17 <eivuokko> Especially if you got browser that can do the processing, without other steps.
03:28:02 <shapr> I've heard that's possible, but I haven't gotten it to work yet
03:28:16 <shapr> I hacked up an emacs solution that's extracheesy
03:28:33 <shapr> compile-command: "java org.apache.xalan.xslt.Process -IN main.xml -XSL x2o.xsl -OUT out.xml && cat out.xml"
03:28:48 <shapr> since I have F12 bound to compile, I have a one-button process and display function
03:29:05 <shapr> it does not even approach elegance though
03:31:27 <shapr> eivuokko: do you know a better way?
03:31:29 <eivuokko> I dunno about other browsers, but ie6 can load and run xslt or css for xml if the xml file got appropriate tag.
03:31:59 <shapr> what tag do you use?
03:33:14 <eivuokko> <?xml-stylesheet type="text/xsl" href="style/people.xsl" ?> 
03:34:35 <eivuokko> At my workplace, we have a lot of data that can be dumped into xml, using xslt if pretty nice for debugging.
03:34:56 <eivuokko> *using xslt is pretty
03:36:25 <shapr> ah, I didn't even see the typo at first :-)
03:36:50 <shapr> does that line go just after the initial <?xml ...> line ?
03:37:21 <eivuokko> Yea.
03:37:45 <shapr> I'll try that, thanks.
03:47:06 <eivuokko> Are you trying some other browsers?  If you do, please, tell me.  It's good to get rid of explicit html imho :-)
03:50:58 <shapr> I haven't tried them yet.. I'll be trying galeon at least.
03:51:06 <shapr> oh, I had a thought last night about the Maybe monad
03:51:53 <shapr> if I wanted the failure case of a Maybe monad to do cleanup, I'd just call the cleanup function in the "case result -> Nothing" branch, right?
03:52:43 <shapr> how could I define a cleanup function for every function I want to string together with Maybe?
03:52:48 <shapr> typeclass?
03:53:14 <shapr> I'm thinking of Noel Winstansley's database monad tutorial
04:48:24 <shapr> http://www.topxml.com/xsl/articles/fp/1.asp#Major_FP_design_patterns/functions_in_XSLT
04:48:58 <shapr> this is seriously spiffy.
04:49:08 <shapr> I wonder if my coworkers would kill me if I used this.
04:49:57 <eivuokko> whoa
04:50:40 <jlouis_> whats so spiffy?
04:53:06 <eivuokko> Doing computation on the clientside, with xslt ;p
05:42:45 <shapr> hi dark
05:43:11 <shapr> jlouis_: oh, you missed the url: http://www.topxml.com/xsl/articles/fp/1.asp#Major_FP_design_patterns/functions_in_XSLT
05:46:24 <jlouis_> the best design pattern in FP is the CPS :)
05:59:23 <shapr> mmm, partial application in xslt
06:03:05 <shapr> http://fxsl.sourceforge.net/
06:19:44 <jlouis_> mmmm
06:19:45 <jlouis_> nice
06:26:02 <dark> shapr: Hello :)
06:26:56 <dark> I still haven't really come to terms with the halting problem.
06:28:09 <dark> In _Shadows of the Mind_, Penrose uses it to prove that human mathematicians can't be using a knowably sound algorithm to determine the validity of proofs.
06:29:21 <dark> He then spends the next 500 pages on making his case that human intelligence must therefore be non-algorithmic.
06:30:05 <dark> But I keep going around in circles around his proof, there must be a hole in it somewhere :)
06:31:35 <shapr> I'd like to read some of his books.
06:32:54 <dark> shapr: I've read _The Emperor's New Mind_, but I've forgotten most of it :)  The neat part is that he ends up explaining all of physics (from Aristotle to now) to support his thesis.
06:33:23 <shapr> sounds interesting
06:33:32 <shapr> I like penrose tiles, they're very cool.
06:33:40 <shapr> I like the way they apply to quasicrystals.
06:33:51 <dark> Reading some books by Hofstadter is probably a good counterpoint to Penrose's books.
06:33:57 <shapr> I like hofstadter
06:34:00 <shapr> and pirsig
06:34:13 <shapr> though I think pirsig is light reading compared to hofstadter
06:35:01 <dark> I've never heard of Pirsig, what would you recommend?
06:35:16 <shapr> zen and the art of motorcycle maintenance is his first book.
06:35:26 <Marvin--> Hofstadter is cool
06:35:34 <Marvin--> I like all the quotes he throw around
06:35:45 <Marvin--> "This sentence contains exactly threee erors."
06:36:01 <shapr> haha!
06:36:04 <shapr> that's cute.
06:36:27 <shapr> I have GEB around here, but haven't looked at it in a long time.
06:36:28 <Marvin--> I haven't read the Zen/motorbike book but I've heard it's good
06:36:44 <shapr> ZATAOMM is about scheme vs haskell...
06:36:46 <Marvin--> I think you can read GEB any number of times :)
06:36:46 <dark> shapr: Ah, then I have heard of him, just not his name :-)
06:36:46 <shapr> or something like that.
06:38:25 <dark> I liked Hofstadter's "A Person Paper on Purity in Language".
07:16:54 * shapr bounces
07:20:49 * shapr yodels
07:24:44 * Riastradh explorbs.
07:27:57 * shapr enspheres
07:39:49 * opet collapses
07:40:15 <andersca> did I walk into a mud?
07:40:28 * Marvin-- casts Fireball on andersca
07:41:26 * opet runs away from the grue
08:16:57 <dark> I've been thinking about filesystems all week and I'm having urges to hack the kernel :)  I think it's all clausen's fault.
08:48:55 * mgoetze wonders whether a PhD in maths after a diploma in computers&engineering is feasible
08:59:11 <Marvin--> mgoetze: probably not
09:02:14 <mgoetze> Marvin--: so you think i'd need to get a MSc in maths first?
09:02:37 <mgoetze> i mean, i am planning to make my ce-studies as maths-intensive as possible... :)
09:07:57 <Marvin--> I would suggest a master in maths, yes
09:09:07 <shapr> yow
09:09:44 * shapr bounces more
09:09:57 <mgoetze> hm... "M. Goetze, Dipl.-Ing., MSc"
09:10:01 <mgoetze> sounds fun, lol
09:10:14 <mgoetze> or MA
09:14:32 <shapr> hm, now I want to implement that Truck the wiki guys are asking for...
09:18:25 <bubba1034> Hey dudes. Does anyone know the URL for the Web server that Peyton-Jones wrote when
09:18:40 <bubba1034> he contributed monads?
09:18:49 <shapr> there's simon marlow's web server.
09:19:09 <shapr> other than that, you'll have to google.
09:19:32 <bubba1034> It's not there. Unless he has one that is not the MS one.
09:19:47 <shapr> I don't know.
09:20:15 <bubba1034> Do you know what he called it?
09:20:27 <shapr> nope, where did you find the info on this web server?
09:22:26 <bubba1034> I started by looking at Haskell.org. Sigh. I was looking at one of the "monad" papers.
09:22:31 <shapr> which paper?
09:22:32 <bubba1034> Now I have to figure out which.
09:22:41 <redcrosse> doesn't he build one in http://www.haskell.org/~simonmar/papers/web-server.ps.gz
09:22:53 <redcrosse> http://research.microsoft.com/Users/simonpj/Papers/marktoberdorf/
09:24:35 <shapr> I'm pretty sure that web server was written by Simon Marlow.
09:24:49 <redcrosse> yeah, it looks like
09:24:49 <redcrosse> it
09:24:56 <redcrosse> ~simonmar
09:25:25 <shapr> bubba1034: if you're looking for that web server, it's available in fptools cvs tree, and a version that can load apache style plugins at runtime is available at sf.net/projects/haskell-libs/
09:25:40 <shapr> hi redcrosse, what's up?
09:25:47 <redcrosse> oh nothing
09:25:53 <redcrosse> reading that wiki page
09:26:01 <shapr> the truck page?
09:26:03 <redcrosse> thinking about trucks
09:26:04 <redcrosse> yeah
09:26:10 <shapr> I'm trying to write the code for it right now..
09:26:21 <shapr> lemme throw this code online and you can tell me what you think...
09:26:51 <redcrosse> upload away
09:26:57 <shapr> http://kungens.kemi.fi/~shae/src/haskell/Truck.hs
09:28:01 <shapr> that lower Truck class was written by Pseudonym, using functional dependencies.
09:28:19 <shapr> aka, I'm not really sure what to do with it ;-)
09:28:20 <redcrosse> yeah, i think i remember seeing that yesterday
09:28:47 <shapr> redcrosse: do you understand fundeps?
09:29:19 <redcrosse> don't recognize the term, so probably not
09:29:53 <bubba1034> shapr: Very funny.
09:30:46 <shapr> bubba1034: what?
09:31:04 <bubba1034> Go to the link you posted. 
09:31:19 <shapr> works fine for me.
09:31:34 <bubba1034> I guess I have to check the papers again and find the reference.
09:31:52 <bubba1034> shapr: Try downloading the source or going to the home page.
09:32:06 <shapr> of haskell-libs ?
09:32:25 <bubba1034> Yes.
09:32:44 <shapr> bubba1034: try looking a little harder at the project page.
09:33:57 <shapr> there aren't any file releases, and there's no html page that says anything
09:34:05 <shapr> I'm aware of that, I started haskell-libs :-)
09:35:16 <shapr> I also put the haskell web server with plugins into haskell-libs, so I'm sure it's there ;-)
09:37:54 <bubba1034> Yeah. I just hate to use CVS for such things. There's always some dufus on a project that
09:37:59 <bubba1034> checks in broken stuff.
09:38:25 <bubba1034> So I preffer to get snapshots.
09:38:28 <bubba1034> Thanks.
09:39:17 <shapr> bubba1034: I have HWS-WP running locally, so I'm sure it works.
09:39:55 <Marvin--> bubba1034: check it out, make sure it works, then remove the CVS dirs
09:41:11 <bubba1034> Marvin: I am more interested in inspecting the code. Getting an idea of how a program using monads looks.
09:41:18 <bubba1034> Instead of just looking at snippets.
09:41:47 <shapr> I think you should start smaller than HWS-WP to understand monads.
09:41:58 <Marvin--> uh, yeah
09:42:01 <Marvin--> :)
09:42:08 <Smerdyakov> bubba1034, the data flows through it in order. Simple =)
09:42:55 <bubba1034> I'm just interested the top-level. 
09:43:20 * shapr shrugs
09:43:22 <bubba1034> But you're probably right. 
09:43:32 <bubba1034> Lambdabot looks simpler.
09:43:34 <radix> shapr! my good friend
09:43:36 <radix> how are you doing
09:44:06 <bubba1034> Smerdyakov: You're joking right. Order is not supposed to have meaning in an FP. ( Which
09:44:12 <shapr> hey radix, what's up?
09:44:21 <Smerdyakov> It does if the semantics of an IO monad say it does!
09:44:26 <bubba1034> is why it makes a good monads example. )
09:44:46 <radix> bubba1034: Monads are special :-)
09:44:48 <Smerdyakov> Monads let you make things happen in order, sorta.
09:46:35 <bubba1034> Keep in mind that monads are not FP, in fact they're sort of antiFP.
09:46:48 <radix> bubba1034: Yes. keep that in mind.
09:48:36 <bubba1034> Is there a good example program where two monads are being used at the same time?
09:49:15 <shapr> I suspect there are many monads being used in HWS-WP
09:52:11 <bubba1034> Which is why I think it would be a good sample program.
09:53:43 <shapr> redcrosse: any thoughts on that source?
09:54:01 <redcrosse> i'm reading about fundeps at the moment
09:54:18 <redcrosse> http://www.cs.chalmers.se/~hallgren/Papers/wm01.html
10:01:24 <bubba1034> Thanks. Bye.
10:01:27 <shapr> bye
10:08:50 <shapr> redcrosse: do you understand it?
10:09:20 <redcrosse> kind of
10:09:33 <redcrosse> i need to think on it a bit more
10:09:47 <shapr> ok
10:21:27 * shapr rereads page 6 over and over
10:23:26 <Marvin--> is it the kind of type system where you can express things like  length (xs ++ ys) == length xs + length ys?
10:24:04 <shapr> I think so
10:24:16 <Marvin--> Hmm, Jan-Willem talked about it on the last multi meeting
10:24:24 <Marvin--> but I got the impression that it was only semi-decidable, not decidable
10:24:49 <shapr> it seems to be standard stuff
10:25:06 <Marvin--> standard and standard...are there any such implementations yet? :)
10:26:04 <shapr> ok, it's implemented in GHC :-)
10:26:11 <Marvin--> it is?
10:26:24 <shapr> I'm 99% sure it is
10:26:34 <shapr> http://www.cs.chalmers.se/~hallgren/Papers/wm01.html
10:26:35 <Marvin--> append :: List a n -> List a m -> List a (n+m)
10:26:38 <Marvin--> can you express that kind of thing?
10:26:42 <redcrosse> this one seems a bit better: http://www.cse.ogi.edu/~mpj/pubs/fundeps.html
10:27:16 <Marvin--> oh, it's about multi-parameter type classes
10:27:22 <redcrosse> yeah
10:27:26 <Marvin--> I was thinking of something entirely different, sorry :)
10:27:41 <shapr> ok, what are you thinking about?
10:27:59 <shapr> I think functional dependencies is what you're talking about
10:28:01 <shapr> but I'm not sure
10:28:19 <shapr> it's saying that types in a typeclass have a relation
10:28:25 <shapr> class Truck truck tyre | truck -> tyre where { ... }
10:28:40 <shapr> that says there's one kind of tire for every kind of truck
10:28:49 <shapr> that's what Pseudonym told me...
10:29:17 <shapr> it's a function that maps the relationship between pieces of a type class.
10:29:20 <shapr> I think :-)
10:30:36 <shapr> radix: I think this is *all* about Adapters
10:31:10 <shapr> radix: that last url redcrosse pasted discusses subtyping with a two parameter typeclass called Coerce
10:31:20 <Marvin--> yeah, I was thinking of other type systems thingies
10:31:27 <shapr> Marvin--: like what?
10:31:59 <Marvin--> shapr: the kind of type system where you can epxress the append type signature above? :)
10:33:03 <Marvin--> http://www.cs.chalmers.se/Cs/Research/Functional/MultiMeeting/2003/  dependent types is what I'm thinking about
10:33:27 <shapr> I'm pretty sure this is the same thing
10:33:42 <shapr> the difference here is that you use a function to specify the relation
10:33:54 <shapr> supposedly that lets you dodge some of the undecidability problems.
10:35:01 <shapr> or maybe I'm wrong and fundeps are different from type deps...
10:35:26 <ludde> Marvin--: I had a lecture about dependent types today
10:35:38 <Marvin--> ludde: oh? What course?
10:35:42 <shapr> ludde: oh oh, tell us about it!
10:36:12 <ludde> Marvin--: it's a computer languages seminar course.. peter dybjer had today's lecture.
10:36:35 <Marvin--> ah
10:36:45 <ludde> Marvin--: i think he has a PhD course about dependent types?
10:36:57 <ludde> Marvin--: he said something about it starting next monday
10:37:12 <Marvin--> cool
10:37:23 <ludde> but maybe it's just for chalmers students?
10:38:40 <ludde> maybe you could mail him and ask if you're interested, i'm not sure if the exact topic was dependent types.
10:41:09 <Marvin--> the PhD course is probably open for anybody interested, but I really don't have the time right now
10:41:17 <shapr> me me! I do!
10:41:25 <shapr> well, except for the commuting problem.
10:41:27 <Marvin--> but for some stupid reason, that computer language seminar course is only open for chalmers students
10:42:36 <shapr> I wonder if synchronous irc seminars would work
10:43:07 <radix> I hate synchronous IRC conversations
10:43:41 <shapr> radix: well, what about a scheduled hour or so where people get together and we discuss a certain topic?
10:44:20 * Marvin-- starts singing Swedish progg
10:44:32 <radix> that's fine :)
10:44:54 <radix> When I think "synchronous IRC" i think "only one topic at a time"
10:44:58 <shapr> oh
10:45:01 <radix> or rather
10:45:06 <shapr> I just meant people doing stuff at the same time.
10:45:21 <radix> one, uhm, interaction at a time -- like, waiting until one question is answered before other discussion can go on
10:45:27 <radix> I'm thinking of the typical "IRC interviews"
10:45:28 <shapr> oh, no way
10:45:43 <shapr> I don't think I'm that disciplined/organized.
11:44:39 <shapr> hi pesco 
11:44:41 <shapr> ltns
11:44:48 <pesco> hey there shapr
11:45:26 <pesco> What's happening on the functional side of the moon?
11:45:55 <shapr> trying to understand functional dependencies at the moment
11:46:01 <pesco> Oh.
11:46:05 <shapr> what's up with you?
11:46:26 <pesco> I've been sticking my head into CORBA.
11:46:45 <shapr> playing with the haskell-corba bridge? 
11:46:52 <pesco> No, unfortunately not.
11:47:10 <shapr> C? C++?
11:47:14 <pesco> C++.
11:47:30 <pesco> And Python for interactive testing.
11:47:48 <shapr> cool
11:47:50 <Riastradh> shapr, how far along is the Haskell PB implementation?
11:48:02 <pesco> PB?
11:48:08 <Riastradh> Persistent Broker or something.
11:48:09 <shapr> Riastradh: banana works, jelly doesn't, not even close to PB itself
11:48:16 <Riastradh> A part of the Python Twisted Matrix framework.
11:48:23 <pesco> Ah, I remember.
11:48:26 <Riastradh> Do you have any code for Jelly?
11:48:30 <radix> Perspective Broker :-)
11:48:31 <shapr> I think Marvin--'s idea on how to write code for Jelly will work.
11:48:41 <shapr> Riastradh: sort of... it's an abortive mess...
11:48:56 <shapr> Riastradh: http://kungens.kemi.fi/~shae/src/haskell/Jelly.hs
11:49:08 <Riastradh> I'm trying to figure out if the Scheme implementation is farther ahead or behind than the Haskell implementation, so I can either gloat to you or run off and code madly.
11:49:19 <radix> haha
11:49:38 <shapr> heh
11:49:47 <shapr> Riastradh: why don't you steal code from the elisp implementation?
11:49:55 <Riastradh> shapr - Yuck, elisp.
11:50:37 <shapr> it worked at one point...
11:50:53 <radix> shapr: I showed him my goo implementation
11:50:59 <shapr> ah, I see.
11:51:12 <shapr> radix: help me with Jelly.hs ! :-)
11:51:16 <radix> Eep.
11:51:28 <radix> Jelly in Haskell is about the scariest thing I can imagine. :-)
11:52:24 <pesco> What _is_ Jelly?
11:53:02 <radix> pesco: Object -> Lists of strings and numbers
11:53:05 <shapr> it's part of an RPC system
11:53:15 <jlouis_> some sort of marshalling?
11:53:19 <shapr> yah, that
11:53:28 <pesco> Oic, why is that scary in Haskell?
11:53:32 <radix> Banana: List of strings and numbers -> bytes
11:53:42 <shapr> because jelly was designed and written in python
11:53:58 <shapr> so it has some particular ideas about the world...
11:54:18 <pesco> Ahum.
11:54:19 <shapr> which are a pain in the ass to deal with in Haskell.
11:54:40 <pesco> Just dump the Python ideas and do it the real way then! ;)
11:55:10 <radix> Nah. I don't think it's that conflicting with Haskell
11:55:18 <shapr> the whole point is to talk to the Python server....
11:55:31 <radix> I mean, if you wanted to implement an RPC in Haskell, you'd have to do most of the same things.
11:57:30 <pesco> shapr: Ok, as an example tell me one of your current problems.
12:00:01 <shapr> the one thing I tripped on was turning a list of Integers such as [1,2,3] into ["list",1,2,3]
12:00:09 <shapr> I didn't know where to go from there.
12:01:00 <pesco> Obviously there is no ["list",1,2,3] in Haskell. How much room is there for alternatives?
12:01:27 <pesco> Did I get it right that Jelly transforms objects to lists that contain only strings or ints?
12:01:34 <shapr> well.. banana is designed to do bit level encoding below jelly
12:01:37 <Marvin--> that's not really a problem, you can just as well use constructors instead of that string
12:01:44 <shapr> huh?
12:01:53 <Marvin--> shapr: what's really going to bite you is that python doesn't have parametric polymorphism like Haskell
12:02:15 <shapr> Marvin-- suggested yesterday that I merge jelly and banana into a single encoding process so I never have to worry about weird intermediate value like the one above.
12:02:16 <shapr> Marvin--: eh?
12:02:23 <Igloo> Do you mean ad-hoc polymorphism?
12:02:42 <Marvin--> shapr: [2, "foo", somefunction] is valid in python
12:02:42 <pesco> shapr: That though has already occured to me.
12:02:54 <Igloo> I don't quite see how a language that allows ["foo", 3] wouldn't allow parametric polymorphism
12:03:27 <shapr> how would I deal with that in Haskell?
12:03:41 <shapr> I've been using a unification type in Banana
12:03:55 <shapr> and saying the lists are :: BananaType
12:03:56 <Marvin--> Igloo: well, of course you could "allow" it, but in python you can put anything in a list
12:04:21 <pesco> What is parametric polymorphism?
12:04:36 <Igloo> I think I'm missing your point
12:04:51 <Igloo> parametric polymorphism is like length
12:04:58 <Igloo> ad-hoc polymorphism is like (+)
12:04:58 <shapr> I think Marvin-- switched the two languages in the sentence above
12:05:32 <Marvin--> Igloo: I don't see how you can have an appropriate haskell representation of the python list ["foo", 3, someclass, someinstance, ...]
12:05:33 <pesco> Igloo: Please be more specific.
12:05:46 <Igloo> pesco: length works for a list of any type a
12:05:57 <Igloo> (+) works for multiple types, but differently for each one
12:06:16 <shapr> oh
12:06:19 <shapr> that makes sense.
12:06:34 <shapr> one implemenation for many types
12:06:34 <Igloo> Marvin: So did you really mean "python doesn't have parametric polymorphism like Haskell"?
12:06:37 <Marvin--> Igloo: thing is, in python, everything's a PyObject, and that's what you put in lists
12:06:42 <shapr> versus many implementations for many types
12:06:57 <Marvin--> Igloo: Haskell has parametric polymorphism, in python there's no such thing as "list of int" or "list of string", only "list"
12:07:10 <Marvin--> but sure, maybe "parametric polymorphism" isn't the suitable term
12:08:45 <Marvin--> if you want to have a "list of several things" you have to put the "several things" in a datatype with a constructor for every type
12:24:22 <shapr> Marvin--: so, does that mean I won't be able to pretend that a PB connection is just socket I can send data to?
12:25:05 <Marvin--> huh?
12:25:14 <Marvin--> I have no idea how much of what you want to do
12:25:55 <shapr> hm, I guess I don't either...
12:26:34 <Igloo> :-)
12:26:58 <Igloo> While you have a list of such things you will need to wrap them up in a datatype. More than that I can't say without details
13:03:16 <jlouis_> Python doesnt even sport a decent type system.
13:03:25 <jlouis_> or... its dynamicly typed
13:03:28 <jlouis_> hey Smerdyakov 
13:10:35 <shapr> hey clausen 
13:10:46 <shapr> we've been dying to hear your latest thoughts on purely functional filesystems.
13:12:10 <clausen> gday shapr
13:12:24 <clausen> I just gave a talk on it two days ago, hehe
13:12:28 <shapr> oh, cool
13:12:32 <clausen> well, I've decided to do another topic for my honours research project
13:12:34 <shapr> do you have notes for your talk?
13:12:38 <clausen> nope :/
13:12:42 <shapr> aww :-(
13:12:45 <clausen> basically, my 2 ideas are:
13:12:54 <clausen> (1) use skew binary random access lists for inode block lists
13:13:05 <clausen> (2) store all open inodes in a separate B+ tree to closed ones
13:13:20 <clausen> basically, these are changes to NetApp's WAFL file system
13:13:26 <clausen> (which is a purely functional filesystem, really)
13:13:29 <dark> clausen: I've been having filesystems on the brain and it's all your fault :)
13:13:33 <clausen> hehe
13:13:44 <dark> clausen: I found an archive of the tux2-dev mailing list, it's pretty interesting.
13:14:09 * clausen read through it, IIRC
13:14:21 <clausen> one thing I don't understand about tux2
13:14:27 <clausen> is how they plan to implement snapshots
13:14:38 <dark> Yeah it's unclear to me, too.
13:14:41 <clausen> it seems incompatible with their incremental garbage collection approach
13:14:44 <clausen> ("defree lists")
13:14:48 <dark> Snapshots are useful when making backups, right?
13:14:52 <clausen> yep
13:15:01 <clausen> also, "undo that rm you did 5 minutes ago"
13:15:15 <dark> I don't know if defree lists count as garbage collection.  There's never a scanning phase, the list is actively managed.
13:15:38 <clausen> well, whatever you want to call it...
13:15:41 <clausen> resource deallocation
13:15:43 <dark> True garbage collection would be useful for tail sharing :)
13:16:31 <dark> I've been thinking of a scheme where there's strong support for fragment packing, and inodes are just another kind of fragment.  Then you could store small files (< 4000 bytes) in one block together with their inode.
13:17:21 <clausen> since inodes are copy-on-write in "functional" file systems
13:17:26 <dark> Of course, this loses when you have to stat all files but don't need to inspect their contents.
13:17:27 <clausen> this actually makes a fair bit of sense
13:18:19 <dark> Yeah, another thing I realized is that with a copy-on-write filesystem, it's not necessarily an error for files to share data blocks.  cp could become very cheap :-)  Unfortunately that creates a garbage collection problem so I don't know if it's worth it.
13:18:30 * shapr get Self running on Linux
13:18:57 <clausen> dark: it doesn't create problems in WAFL, IIRC
13:19:17 <clausen> (hmmm, maybe it does)
13:19:22 <dark> clausen: WAFL is by the ones with the patents, right?
13:19:26 <clausen> yep
13:19:30 <clausen> but I doubt it's a problem
13:19:33 <clausen> there is so much prior art
13:20:00 <clausen> maybe I should send a list to tux2-dev
13:20:04 <clausen> btw, I've written a bit here:
13:20:07 <dark> But isn't that why Daniel Phillips stopped?
13:20:10 <clausen> members.optusnet.com.au/clausen/ideas/functional-fs.txt
13:20:14 <clausen> dark: I doubt it
13:20:29 <dark> clausen: Yeah I've read that long ago :)
13:20:39 <clausen> ok :)
13:20:41 <clausen> just checking :)
13:20:59 <dark> clausen: It was my inspiration :)
13:21:08 <clausen> thanks :)
13:21:38 <clausen> since I'm doing a research project on something else, I shouldn't spend *too* much time on it
13:21:43 <clausen> but, I think I'd find it hard to avoid, hehe
13:25:35 <clausen> dark: so, do you grok skew binary random access lists?
13:25:48 <clausen> okasaki's explanation of them is very incremental on other stuff
13:25:56 * clausen thinking about writing a "quick description"
13:26:03 <dark> I wonder if it would be Bad to use half the block addressing space for fragments.  Then the maximum filesystem size would be 8TB instead of 16TB.
13:26:03 <clausen> (that doesn't require 100 pages of background)
13:26:25 <clausen> btw, why have "fragments" as opposed to blocks?
13:26:32 <clausen> (you can set the block size arbitarily)
13:26:46 <clausen> secondly, why not have a 64-bit address space?
13:27:17 <clausen> the only reason to have blocks IMHO is to provide a unit of ACID
13:27:18 <dark> Well a block index would be direct, while a fragment index would go through a lookup table.  (You need a lookup so that you can do copy-on-write for fragments that are referenced from arbitrary locations)
13:27:29 <clausen> it doesn't really make a difference to allocation, IMHO
13:27:40 <clausen> (ACID, as in atomicity, consistency, isolation, durability)
13:27:49 <dark> Having big blocks is a win with something like tux2 because it keeps the trees flatter.
13:28:04 <clausen> dark: I don't think it matters
13:28:19 <clausen> dark: I think you can have "hot-routes" allocated next to each other
13:28:26 <dark> Hmm, on the other hand only inodes and file tails will be in fragments, so it should be easy to mark them.
13:28:35 <clausen> dark: and having my working-set tree idea, I think it gives you a pretty good win anyway
13:28:41 <clausen> by this hot routes thing,
13:28:59 <clausen> I mean you can write things in adjacent blocks
13:29:14 <clausen> I'm still not understanding you
13:29:56 <clausen> so, lets go from the beginning:
13:29:57 <dark> I think I grok skew binary random access lists, but I don't understand what problem they'd solve in a filesystem.
13:29:59 <clausen> why do we have blocks?
13:30:19 <clausen> dark: they have O(1) copy-on-writes on append
13:30:32 <dark> We have blocks to reduce the size of addressing data.
13:30:36 <clausen> (as opposed to btrees, which have O(log n))
13:30:47 <clausen> dark: so why not use 64-bit?
13:30:51 <clausen> I disagree with you
13:30:55 <clausen> the reason we have blocks
13:30:59 <clausen> is to provide a unit of locking
13:31:08 <clausen> 1 bit isn't enough to lock
13:31:15 <clausen> (hmmm, maybe it is...)
13:31:23 <clausen> and a unit of copy-on-write
13:31:45 <dark> Well, tux2 maintains consistency even if the drive writes garbage into the metaroot when it powers down.
13:31:46 <clausen> maybe I should start thinking in terms of bits after all, hehe
13:31:52 <dark> So obviously it doesn't need blocks as a locking unit :)
13:32:10 <dark> Blocks reduce fragmentation by fitting everything into uniform sizes.
13:32:27 <clausen> ok, now you're talking
13:32:36 <clausen> hmmm, I don't really know much about block allocation
13:32:50 <clausen> I haven't been able to find a great deal of literature on it
13:32:57 <clausen> particular in a copy-on-write environment
13:34:30 <clausen> the netapp guys must have thought about this lots, but haven't published on it :(
13:34:45 <dark> ext2's main strategies for block allocation are: 1. divide the filesystem into contiguous block groups and try to keep data blocks in the same group as their inode, and keep inodes in the same group as their directory.
13:35:31 <clausen> yep
13:35:33 <dark> 2. when allocating a block for a file, try to preallocate 8 contiguous ones, to be released when the file closes.
13:35:35 <clausen> and that seems to be state-of-the-art
13:35:40 <dark> As far as I can tell, that's it.
13:35:49 <dark> Simplicity is a virtue in filesystems, it seems :)
13:36:01 <clausen> well, there's also delayed allocation
13:36:04 <clausen> (a la xfs)
13:36:11 <dark> tux2 adds a requirement that's important for it: allocate bitmap blocks in the region they describe.
13:36:24 <dark> Without that, you get nasty recursion in your copy-on-write for bitmap blocks.
13:37:10 <dark> I don't know what xfs does :)  But at a guess... it delays allocation until it has some idea of how much space it will need?
13:37:42 <clausen> right
13:38:00 <clausen> I think this is a fundamental issue, btw:
13:38:05 <clausen> durability latency
13:38:07 <dark> This is a win for another reason, sometimes you won't need the space at all :)  (i.e. /tmp)
13:39:42 <clausen> basically: if you delay commits, then you can do a better job
13:40:01 <clausen> tux2 has a fairly high commit latency, due to it's phase tree stuff
13:40:09 <clausen> (unless you add an NVRAM journal...)
13:41:20 <dark> Yeah, I realized that tux2 would perform pretty poorly on a file that's being written out in synchronous mode.
13:41:58 <dark> You might need a phase for every block.
13:42:22 <dark> It wouldn't be so bad if other stuff is going on at the same time.
13:42:23 <clausen> yep
13:42:44 <clausen> btw, do you understand my argument for skew-binary random access lists now?
13:43:18 <clausen> synchronous writes to the end of a file would take O(log(open files)) + O(1) writes
13:43:41 <clausen> (well, synchronous or otherwise)
13:43:49 * clausen wondering how to explain it on his website
13:43:51 <dark> Hmm, about skew binary random access lists... I did some calculations, and even with a 4 GB file and 512-byte blocks, you'd need only 3 levels of metadata to address it as a tree.
13:44:16 <dark> I'm not sure if O(log(n)) is relevant in that context :)
13:44:19 <clausen> maybe
13:44:30 <clausen> but 3 levels is 3 writes vs 1
13:44:37 <clausen> (I think it comes down to that)
13:44:44 <dark> So it's actually 1 and not just O(1)?
13:44:48 <clausen> I think so
13:44:55 <dark> That would indeed be handy.
13:45:08 <clausen> well, 1 seems achievable to me
13:45:17 <clausen> but, there's some hard work / tricky details
13:45:21 <dark> But, is this in a phase tree context?
13:45:36 <clausen> well, tux2 or wafl
13:45:53 <clausen> (this doesn't include maintaining block bitmaps)
13:45:56 <dark> You'd still need to update the inode and the allocation bitmaps, though?
13:45:59 <clausen> right
13:46:23 <clausen> btw, with the 3 levels of a b-tree
13:46:32 <clausen> you need to write 3 blocks...
13:46:38 <clausen> but perhaps the 3 blocks can be allocated contiguously
13:46:41 <clausen> so it's really only one write
13:46:48 <clausen> so, perhaps it's a non-issue after all
13:46:51 <dark> ext2 inodes seem very inefficient that way, btw :)  The pointers in the inode are mostly wasted on direct pointers.  It'd be nicer to have a 'level' marker in the inode that says what kind of pointers these are.
13:47:18 <clausen> I think it'd be better for ext2 to have those direct blocks at the end of the file
13:47:24 <clausen> you always have to write the inode, to update file size
13:47:36 <clausen> so you may as well write to the inode only, and not to indirect blocks
13:48:06 <clausen> dark: email address?
13:48:09 <dark> clausen: Did I mention the idea on tux2-dev to write the whole phase out as a contiguous sequence?  The idea would be to keep frequently used data together, rather than trying to keep files together.  (OTOH, "write" isn't "use", it might be unrelated to reading)
13:48:11 <clausen> (BTW, can I add you to my database?)
13:48:25 <clausen> dark: no
13:48:27 <dark> clausen: My email address is dark@xs4all.nl.  What database?
13:48:30 <clausen> (but it had occured to me)
13:48:38 <clausen> dark: I maintain a database of my friends/contacts
13:48:43 <clausen> it is private
13:48:45 <clausen> (only I can read it)
13:48:50 <clausen> (in theory, anyway ;)
13:49:03 <clausen> there is more info here:
13:49:04 * dark hax0rz clausen's box.
13:49:33 <clausen> http://members.optusnet.com.au/clausen/ideas/contactdb/index.html
13:50:02 <dark> Having at least the first data block directly in the inode would be good for reading, though.  Less latency on the first block, then you can go looking for the next blocks in the background.
13:50:24 <clausen> dark: does read latency matter that much?
13:50:29 <clausen> like, everything gets cached anyway
13:50:47 <clausen> effectively, you just get open(2) latency
13:52:11 <clausen> obviously, we could go to the other extreme, and implement a logfs
13:52:12 <dark> If you think of something like grep, as soon as it gets the first block it can start processing.
13:52:32 <dark> By the time it's ready for the next block, the next block is probably ready, because grep spent time processing.
13:52:32 <clausen> you always need to read 2 blocks anyway
13:52:38 <clausen> (inode + first block)
13:52:44 <clausen> who cares if it's log(n) blocks instead?
13:52:55 <clausen> you don't read block-by-block anyway
13:53:00 <clausen> hopefully you're doing massive read-ahead
13:53:09 <dark> Yeah but it's hard to read-ahead when descending a tree :)
13:53:14 <clausen> why?
13:53:20 <dark> Whereas the second data block is probably right after the first data block.
13:53:23 <clausen> (it's a file system policy decision)
13:53:40 <clausen> oh, "hard" as in "expensive" ?
13:53:50 <dark> Not really, it's disk level.  The disk tends to grab a whole track.
13:53:55 <clausen> dark: so, do you want to go in my db?
13:54:02 <dark> Yes, it's fine with me :)
13:54:31 <clausen> (do you want to give me more info?  real name would be nice, but I can store lots of stuff, like age, gender, phone, interests, friends...)
13:54:58 <dark> With a file's data blocks you can try to keep them contiguous.  When descending a tree, there's no way to keep every path contiguous, so it's hard to grab the whole path at once when reading the inode.
13:55:18 <clausen> hmmm
13:55:20 <dark> clausen: Yes but not via irc :)
13:55:35 <clausen> but if you allocate the indirect blocks along with the direct blocks
13:55:36 <clausen> then you
13:55:44 <clausen> 'd expect the entire path to be contiguous
13:57:16 <clausen> actually, that's an interesting problem
13:57:35 <clausen> making sure all required metadata always appears before the corresponding data
13:57:55 <clausen> but, anyway, I think the big issue is: read vs write latency
13:58:39 <clausen> you can get low write latency by having a log (and nothing else)
13:58:45 <clausen> you can get low read latency via mkisofs
14:00:58 <dark> Probably lower with mkcramfs :)
14:01:17 <dark> Actually, compression is probably a win for both read and write.
14:01:37 <dark> Unless you're doing heavy computation on the same machine.
14:02:32 <dark> clausen: AFAIUI, NTFS is exactly the "only a log" model.
14:02:46 <clausen> no, I disagree
14:02:53 <dark> clausen: For speed, it scans the whole log when it boots and constructs a model of the filesystem tree.
14:02:57 <clausen> NTFS is a very highly indexed file system
14:03:43 <dark> I wonder if we've read about the same NTFS :)
14:04:24 <clausen> yeah, maybe I'm talking rubbish
14:04:35 <clausen> so, you've got the MFT
14:04:39 <clausen> which basically contains everything
14:09:33 <dark> Hmm, I studied NTFS about 1.5 years ago when I was helping my girlfriend convert to linux, I don't remember much of it :)
14:10:09 <clausen> hehe
14:19:07 <clausen> dark: got my email?
14:26:15 <dark> clausen: Just did :)
14:26:50 <clausen> :)
14:28:50 <dark> Hmm, looks like tux2 handles snapshot allocations by keeping the snapshot's allocation map intact, and when freeing a block, it makes a separate check in that allocation map.
14:29:42 <dark> If it's found there, it doesn't mark that block as free, but queues it in the snapshot's free list instead.  (I'm not sure how it does that atomically)
14:29:55 <clausen> dark: ah, interesting
14:29:56 * clausen breakfast
14:30:19 <dark> I first thought this means it can have only one snapshot... but I guess the most recent snapshot has all the previous snapshot's blocks marked allocated, for the same reasons that the current tree does.
14:30:29 <dark> Yeah I'm off for a while too :)
14:59:05 <clausen> dark: so, can you email me more personal info?
15:10:47 <Marvin--> dark: watch out, he's coming on to you!
15:11:52 <dark> I'm back :)
15:16:13 <clausen> dark: re
15:27:13 * shapr bounces
15:28:03 <clausen> Marvin--: I come onto everyone *grin*
15:28:24 <Marvin--> fair enough I guess :P
15:28:38 <clausen> I guess, if I have a long conversation with someone
15:28:45 <clausen> and I just happen to meet him in 10 years (small world and all)
15:28:48 <clausen> it would be nice to remember
15:29:06 <clausen> also, if I happen to find a job that he would be good at, for example
15:29:12 <clausen> it'd be nice to be able to tell him about it
15:29:15 <clausen> (or her?)
15:29:19 <dark> Heh, took me a while to figure out what was meant with "COW snapshots".
15:29:34 * dark mooos.
15:29:36 <clausen> yeah, COW isn't very stfw-able
15:30:06 <dark> clausen: That reminds me, I need to update my resume :-)
15:30:14 <dark> I think it still says I work at SSH.
15:30:34 <clausen> dark: ah, I can probably hunt you down now :)
15:30:37 * clausen tries to stalk dark :P
15:31:07 <clausen> done :)
15:31:27 <dark> clausen: stalkers freeze to death over here :)  Every morning we collect the stalker icicles from the garden.
15:31:54 <clausen> hehe
15:32:12 <dark> Hmm, I used to have my resume as the first google hit on my name.
15:32:25 <dark> It's now down to 4th or something.  I need to fix this too :)
15:32:35 <clausen> dark: if you gave out your contact details more
15:32:39 <clausen> dark: then you'd get more links
15:32:42 <clausen> dark: and a higher page-rank
15:33:01 <dark> clausen: Heh, I simply had a link to it in my signature.  All Debian's mailing lists have a web archive..
15:33:38 <clausen> dark: yeah, not a bad strategy
15:33:47 <clausen> maybe I should write a program to put random links to my website in my sig
15:33:51 <clausen> so all my pages get a good PR
15:35:47 <dark> I wonder why "Ben Clifford's(old) Flotsamfest" is the second hit on my name.
15:36:03 <Marvin--> ugh, kernel bug
15:36:11 <dark> Marvin: I doubt it's that.
15:36:19 <Marvin--> dark: no, I'm talking to myself
15:36:51 <Marvin--> IDE CD readers are listed in /proc/partitions - they shouldn't be
15:37:03 <clausen> all block devices are
15:37:11 <Marvin--> not SCSI CD readers
15:37:17 <clausen> /proc/partitions should be called /proc/block-devicesw
15:37:25 <clausen> Marvin--: well they should be!
15:37:50 <Marvin--> so still a bug ;)
15:37:58 <clausen> yep
15:41:47 <dark> Hmm 2.5 will finally let me drop this ide-scsi stuff, right?
15:42:55 <dark> I searched for my name combined with "sucks" :)  Interesting reading, but no rants.  I seem to have no enemies.
15:43:24 <clausen> hehe
15:44:37 * shapr tries that
15:44:51 <shapr> oh dear
15:44:54 <shapr> 20 hits
15:46:41 <shapr> 384 hits with just my name...
15:46:46 <shapr> that's a nice power of 2 number.
15:47:25 <Marvin--> it is?
15:47:44 <Marvin--> time for some googlefight? :)
15:47:57 <clausen> all the pages with "GNU Parted" "sucks" are saying that parted is good, and other things suck
15:47:58 <clausen> *grin*
15:48:11 <Marvin--> debian list archives tend to give you quite a few hits
15:48:19 <shapr> yah, no way I can win a google fight
15:48:44 <Marvin--> cdebconf_0.31_i386.changes ACCEPTED
15:48:45 <Marvin--> yay
15:51:25 <dark> I remember that Debian had an unfair advantage on the sucks-rules-o-meter :)
15:52:39 <Marvin--> heh
15:58:33 <shapr> http://c2.com/cgi/wiki?WhimsicalUnitsOfMeasurement
16:05:02 <Marvin--> reminds me when I and my ju-jutsu trainer were drunk at a party and tried to invent a 'pile' data structure
16:14:55 <shapr> Marvin--: that's cute :-)
17:07:38 * Vincenz quietly says "Hello"
17:08:41 <Vincenz> Hmm..
17:09:46 <Robert> Hoi :)
17:19:22 <shapr> oy
17:20:01 <shapr> hej ludde 
17:20:17 <Vincenz> Why are Hugs and GHC so similar?
17:20:46 <shapr> because they're both implementations of the Haskell language?
17:21:00 <radix> Heh!
17:21:07 <shapr> Hugs is an interpreter, and GHC is a compiler with interpreter extensions.
17:21:18 <shapr> originally, ghc didn't have any interactive features at all.
17:21:31 <lament> i thought hugs was an implementation of Gofer :)
17:21:45 <radix> snrk
17:21:47 <shapr> hi dmiles 
17:21:57 <dmiles> oh hey ltns
17:22:37 <shapr> what's up?
17:22:57 <dmiles> not much .. working on a planner
17:23:15 <Vincenz> They look the same though
17:23:15 <dmiles> but was thinking maybe there was an implimnetnation of a planner in Haskell
17:23:28 <Vincenz> and isn't there a nicer environment? Where I can defend functions and such at runtime?
17:23:33 * Vincenz is a complete Haskell newb
17:23:51 <dmiles> (well i am assuming it in haskell would be faster then prolog)
17:23:51 <lament> yes
17:23:53 <lament> ghci
17:24:17 <lament> can defend (and attack) functions at run-time
17:24:22 <dmiles> shapr: but not yet sure if it would be worth the trouble yet
17:24:29 <shapr> dmiles: there's calender code in hslibs, but I don't know of a planner.
17:24:59 <dmiles> a planner is more step by step action sequances for like automatic fiction generation
17:25:10 <dmiles> (the kind i need)
17:26:34 <dmiles> we'll see what i can come up with
17:27:03 <shapr> I'm still not sure what you're asking for...
17:27:17 <shapr> uERC> automatic fiction generation?
17:27:19 <shapr> urf
17:27:32 <radix> See? ERC sucks!
17:27:49 <shapr> watch me use erc to kick you off the channel ;-)
17:27:53 * shapr is joking of course
17:27:54 <radix> Emacs needs a real GUI toolkit. :-)
17:27:57 <radix> heehee
17:28:28 <dmiles> yes.. like you set up move_to(Person,Room) removes location(person,OldRoom) and location(person,roo)
17:28:37 <whee> radix: they're still working on the rest of the OS. then they need to do the text editor :)
17:28:56 <dmiles> then you tell the end of the story like the person is in the room.. it comes up with the sequance of actions
17:29:27 <dmiles> like move_to(joe,room2)
17:29:47 <shapr> I don't know of any haskell code like that
17:29:50 <shapr> sounds neat though
17:29:59 <dmiles> most planners are wrttien in prolog and lisp
17:30:39 <dmiles> i wrote a planner in prolog.. but it may be too slow for complex real world thinking
17:30:40 <shapr> it sounds like pretty printing a path description
17:31:03 <dmiles> yeah that could be what the implimentation looks like
17:31:12 <dmiles> unlooping a canonical path
17:31:24 <dmiles> so that you get the shortest one
17:31:54 <dmiles> planners see the actions and states like roadway maps
17:32:01 <dmiles> then they find the shortest distance
17:33:43 <shapr> cool
17:33:49 <Vincenz> so....where does one get an easy to use environment for haskell for haskell newbies?
17:34:37 <shapr> Vincenz: do you use emacs or vim or so?
17:34:43 <Vincenz> I use vim
17:35:00 <shapr> I know there's haskell support for vim
17:35:02 <radix> so shouldn't you be used to a lack of environment? :)
17:35:23 <shapr> I use emacs, so I edit a file and then hit a button to load it into ghci
17:35:33 <shapr> I don't know if vim supports the same kind of thing...
17:35:46 <radix> Is it a big red button?
17:35:50 <shapr> in any case, check out hIDE which is a haskell ide that works with vim and emacs ...
17:35:52 * shapr gets url
17:35:53 <whee> there's plugins to load shells within vim
17:36:02 <whee> and other things, I guess
17:36:33 <shapr> hIDE -> http://www.dtek.chalmers.se/~d99josve/hide/
17:37:28 <shapr> Vincenz: check out the screenshots, is that what you're looking for?
17:38:05 <Vincenz> ooh nice
17:38:09 <Vincenz> though...I have winblows
17:38:42 <shapr> oh, I don't know if that will work.
17:38:45 <shapr> I doubt it will :-/
17:47:23 <shapr> I've been doing too much XSLT lately...
17:47:39 <shapr> trying to figure out how to XPath selection on External Core
17:47:47 <Vincenz> xpath...use java
17:47:51 <Vincenz> it's in...jaxb
17:47:53 <Vincenz> I think
17:48:16 <shapr> I understand XPath, but it's not how I should be thinking about generating External Core
17:52:25 <Vincenz> heh...and I thought haskell would be eas
17:52:41 <shapr> easy?
17:52:42 <Vincenz> I mean...nothing like DrScheme (and I've also -just- started learning scheme)
17:52:48 <Vincenz> an editor...where you can make definitions as you go
17:52:50 <Vincenz> and test around a bit
17:52:52 <Vincenz> would be VERY handy
17:53:01 <Vincenz> but code wise
17:53:06 <Vincenz> haskell seems easier than scheme
17:53:10 <lament> heh
17:53:30 <lament> radix: smite him!
17:57:07 <shapr> I suddenly realize that any parser generator for Haskell could be made to generate instances of Arbitrary without too much extra work.
17:57:08 <shapr> hm, neat.
17:57:16 <radix> smite smite
17:57:21 <radix> wait a second
17:57:27 * radix shrugs :)
17:57:41 <Vincenz> What's Arbitrary?
17:57:56 <shapr> it's a typeclass used for generating random data to test programs with.
17:58:03 <shapr> I don't know if that made any sense...
17:58:29 <shapr> Vincenz: you may want to start here: http://www.haskell.org/learning.html
17:58:42 <shapr> there's some good stuff there.
17:59:07 <Vincenz> yeah...but it'd be nice if there were an interactive environment that I could try it in
17:59:21 <Vincenz> I tried typing in the quicksort code in HUGS but it wouldn't take definition
17:59:22 <Vincenz> s
17:59:44 <shapr> Vincenz: you need to put the code in a file, and load the file into hugs.
17:59:53 <shapr> then you can interactively call the functions.
18:00:02 <Vincenz> I know....
18:00:09 <Vincenz> but it's sort of a pain if you want to experiment
18:00:20 <shapr> that's why it's handy to use vim or emacs to load the file you're editing into your interactive session.
18:01:05 <shapr> I don't know vim, so I can't tell you how it can be easier...
18:01:33 <steele> Vincenz: what about :load and :e?
18:02:16 <Vincenz> and do you suggest hugs or ghc?
18:03:11 <shapr> I've heard that hugs has better error messages.
18:03:23 <shapr> I used hugs a lot when I was first learning Haskell.
18:03:35 <shapr> later I switched to GHC to make standalone binaries.
18:04:08 <Vincenz> ah I see, thanks :)
18:23:30 <shapr> any quickcheck users here who are familiar with the idea of unit test first?
18:46:19 <jlouis> shapr: not entirely right. hugs just made an error whereas ghc showed the kind failure
18:46:29 <jlouis> which was better in my case
18:46:30 <shapr> oh
18:46:48 <jlouis> an the other hand, I am just a dumb SML programmer ;)
18:46:56 <shapr> yah, sure ;-)
18:47:42 <jlouis> that the thing were bound to multi-parameter type classes is another thing, hehe
18:53:47 <shapr> I wish haskell-mode could tab complete typeclass instances
18:56:38 <jlouis> I'll rather have type classes killed
18:56:58 <shapr> type classes are great
18:57:00 <shapr> I luv 'em
18:57:14 <jlouis> well you have my view
18:57:19 <shapr> heh, true
19:06:54 * shapr bounces
19:15:19 * kawfee bounces
19:16:17 * shapr rebounds 
19:16:31 * shapr reads quickcheck.ps for the zillionth time.
19:16:34 * Riastradh explorbs.
19:16:47 <shapr> that's a great word.
19:16:55 <Riastradh> Indeed.
19:17:04 <shapr> I realize I want to try verboseCheck
19:18:09 <shapr> I need to hack a verbosity switch into this quickcheck script.
19:20:57 <shapr> wow, verboseCheck is cool!
19:45:23 <jlouis> hmm, a load of 3... I need to process more data
19:45:52 <shapr> ?
19:45:56 <shapr> what are you doing?
19:46:30 <jlouis> Compiling programs, compiling kernel, compiling MLton, running 2 cvs updates
19:46:38 <shapr> oh
19:46:41 <jlouis> swapping galore
19:47:06 <shapr> you could build GHC while you're at it...
19:47:10 <jlouis> ;)
19:47:11 <shapr> that always keep my machine busy.
19:47:15 <jlouis> MLton is more evil
19:47:20 <shapr> more evil?
19:47:22 <shapr> wow
19:47:24 <jlouis> when compiling by mlton that is
19:48:05 <shapr> aha, this should tell me how to construct monads with QuickCheck
19:48:06 <jlouis> all optimizing compiler. Take all 100k lines of source code into memory and perform intermodule optimization on them
19:48:23 <jlouis> eat up 600 mb of mem, heheh
19:48:27 <shapr> yow
19:48:56 <jlouis> It produces fast code though
19:50:15 <jlouis> as FP is dependent on inlining and tail recursion as hell
19:54:37 <lament> hi
19:54:42 <lament> radix wants to ask a question
19:54:54 <lament> why are monads purely functional?
19:55:13 <shapr> er, radix is here..
19:56:11 <lament> yes
19:56:13 <shapr> monads are purely functional because they explicitly pass state
19:56:29 <radix> don't you mean implicitly?
19:56:44 <shapr> no, explicitly.
19:56:54 <shapr> the monad does it, it really does.
19:56:58 <shapr> you just don't see it.
19:57:02 <lament> hehe
19:57:08 <radix> that sounds like `implicit' to me..
19:57:12 <shapr> well, ok then..
19:57:16 <radix> but that distinction doesn't matter
19:57:20 <lament> it's not implicit
19:57:25 <shapr> look at a monadic calculator
19:57:25 <lament> because it's done with language constructs
19:57:30 <shapr> you pass the state in as 0
19:57:31 <radix> as long as it happens, it happens :)
19:57:38 <shapr> and each operation results in a new state
19:57:59 <radix> shapr: so is it like an implicit `number of times called' parameter?
19:58:15 <shapr> nah, that's the number on the display of the calculator.
19:58:26 <radix> (to ensure the rule that f(p) returns the same thing every time, by ensuring that f(p) is never called twice..)
19:58:59 <shapr> that sounds more like uniqueness types
19:59:21 <shapr> a function always returns the same result for the same inputs, right?
19:59:45 <shapr> if one of the inputs is the state
20:00:05 <radix> yes..
20:00:24 <shapr> you've effectively 'faked' side effects, by pretending that the function can return different results for the same input
20:00:39 <shapr> but in fact, for any given combination of state and input, the function still returns the same result.
20:00:59 <whee> that's no fun.
20:01:08 <shapr> radix: make sense?
20:01:13 <radix> sure.
20:01:26 <radix> I guess I was confusing "FP" with "The advantages that FP give you"
20:01:37 <shapr> ok, so, you wanna know how that makes readLn a pure function? :-)
20:02:20 <radix> shapr: sure, the stream is state, so if the stream changes, the result changes
20:02:27 <radix> right?
20:02:29 <shapr> nope
20:02:32 <shapr> there is no stream...
20:02:39 <radix> uh?
20:02:52 <shapr> it does exactly what I said above
20:03:00 <shapr> it passes the state around explicitly
20:03:06 <radix> ok....
20:03:12 <radix> that doesn't conflict with what I said :)
20:03:35 <radix> `the state' being `the stream'
20:03:40 <shapr> the state is inside the "IO" monad
20:03:54 <shapr> it's called ....
20:03:55 <shapr> ...
20:03:59 <shapr> The World
20:04:03 <radix> heh :)
20:04:11 <radix> so, I guess `the stream' is _part_ of the state
20:04:17 <shapr> happily, you can modify the world in place, so you don't have to make copies.
20:04:20 <shapr> isn't that nice?
20:04:32 <radix> Yes :)
20:04:47 <shapr> let's just hope the runtime system never crashes and tries to make copies.
20:05:28 <radix> heh
20:05:35 <radix> death of the universe :)
20:05:40 <shapr> yah, scary...
20:06:27 <shapr> so a state monad is this thing that only allows access to the state it's holding in certain FP-safe ways 
20:06:43 <shapr> that's why there are those three monad rules that I can never remember.
20:07:47 <shapr> they tell you how you can do it safely
20:08:21 * shapr goes back to finding the most efficient way to crash GHC
20:08:35 <jlouis> injection/binding and something else?
20:08:55 <jlouis> shapr: easily done. ghc eats memory like a fat ass
20:09:06 <shapr> jlouis: you're thinking way too small ;-)
20:09:24 <shapr> I'm using QuickCheck to randomly generate code to feed to GHC
20:09:29 <jlouis> you mean segfault enconsistencies?
20:09:40 <shapr> this should find everything.
20:09:47 <shapr> and keep my computers busy for weeks.
20:10:03 <shapr> and make my name infamous on ghc-users.
20:10:04 <jlouis> heh, have fun :)
20:10:37 <shapr> I'll send you a copy when I get this finished :-)
20:11:28 <jlouis> jlouis@diku.dk
20:23:23 <shapr> collect in quickcheck is a powerful tool
20:28:27 <shapr> sheez
20:28:37 <Vincenz> pour guy
20:28:40 <Vincenz> poor even
20:33:04 * Vincenz pats Chilli on the back
20:34:03 <shapr> the australian servers must be having problems.
20:41:04 <shapr> wheee
20:49:24 <Vincenz> hehe
20:49:35 <Vincenz> I bet Chilli feels like a yoyo
20:49:49 <shapr> http://c2.com/cgi-bin/wiki?PurelyFunctionalExtremeProgramming
20:50:05 <shapr> for any one who wants to comment...
20:57:16 <Vincenz> ah!
20:57:25 <Vincenz> you're the one that told me to come on tihs channel shapr
21:00:52 <shapr> I am??
21:00:57 <shapr> !
21:01:48 <shapr> Vincenz: are you Christophe Poucet?
21:02:00 * shapr doesn't think so
21:02:01 <Vincenz> yup
21:02:10 <Vincenz> say Why not?
21:02:12 <shapr> oh!
21:02:13 <Vincenz> What not?
21:02:18 <Vincenz> urgh
21:02:22 <shapr> because your /whois information says Vincenz Sunshiro
21:02:23 <Vincenz> it's late I can't type anymore
21:02:28 <Vincenz> Ah...that's my nick 
21:02:31 <shapr> yah, it's 6am
21:02:36 <Vincenz> there too?
21:02:42 <shapr> I have to work on my new office at noon today
21:02:49 <shapr> yes, I live in Sweden.
21:03:01 <shapr> ik ben een buitenlander
21:03:03 <Vincenz> heh, I've got the day off
21:03:06 <Vincenz> aha
21:03:07 <Vincenz> ik ben een belg
21:03:32 <shapr> ja, ik vet
21:03:33 <shapr> er
21:03:38 <Vincenz> weet
21:03:40 <Vincenz> not vet
21:03:41 <shapr> I don't know much dutch :-)
21:03:45 <Vincenz> it's alright
21:03:49 <Vincenz> you impressed me
21:03:53 <shapr> but I'm learning swedish, and that's really confusing me.
21:04:29 <Vincenz> where are you originally from?
21:04:32 <shapr> Alabama!
21:04:36 <Vincenz> holy cow
21:04:41 * shapr laughs
21:04:42 <Vincenz> A la bama
21:04:46 <Vincenz> with a SOUTHERN accent
21:04:51 <shapr> non! pas moi!
21:05:04 <shapr> I have a very neutral american accent.
21:05:13 <shapr> I can speak with a deep southern accent if I want to
21:05:26 <shapr> parlez vous franais aussi?
21:06:04 <shapr> I have a friend in Leuven I'm hoping to visit this summer sometime.
21:06:27 <shapr> Vincenz: nice to meet you online in realtime :-)
21:06:57 <Vincenz> ayup
21:07:10 <Vincenz> oui je parles francais
21:07:13 <Vincenz> e anche italiano
21:07:17 <Vincenz> and I live in leuven
21:07:22 <shapr> oh cool!
21:07:34 <Vincenz> yup I'm all and even more
21:07:35 <shapr> I have not even one word of italian
21:07:35 * Vincenz grins
21:08:09 <Vincenz> nd I ramble when it's late
21:08:16 <shapr> well, if we show up in leuven I'll buy you a beer and talk about Haskell :-)
21:08:21 <Vincenz> cool
21:08:28 <Vincenz> as I don't know one iota about it
21:08:38 <shapr> this is a good place to learn about it.
21:08:45 <shapr> I'm happy to help as much as have time for...
21:11:31 <shapr> Vincenz: do you have any other haskell questions before I go away to sleep?
21:11:40 <Vincenz> euhm....not really
21:11:43 <Vincenz> except for..everything
21:11:46 <shapr> hah
21:11:53 <shapr> I don't have time to explain everything ;-)
21:11:58 <Vincenz> I've never done FP-programming, while I get the concept
21:12:04 <Vincenz> I don't get the haskell syntax, libs
21:12:10 <Vincenz> or the fact you can't code live
21:12:21 <shapr> http://kungens.kemi.fi/~shae/src/haskell/Mandelbrot-0.1.hs
21:12:32 <Vincenz> thanks :)
21:13:18 <shapr> that's the first thing I wrote in Haskell
21:13:27 <shapr> took me eight hours and lots of help from this channel =)
21:13:40 <Vincenz> ir'a axhwmw
21:13:40 <Vincenz> Mandelbrot> sequence_ $ map putStr (map printLine (cutLines 50 (getPoints 50)))
21:13:43 <Vincenz> I mean..
21:13:45 <Vincenz> it's scheme
21:14:07 <shapr> ah, you use qwerty
21:14:42 <shapr> Haskell has some common ideas with Scheme
21:14:48 <shapr> they're both functional languages.
21:15:15 * emu set!s shapr correct
21:15:34 <lament> please don't use this evil term
21:15:40 <shapr> and the $ symbol works mostly like parentheses also.
21:15:49 <lament> functional languages, scripting languages, foo languages... :|
21:15:53 <emu> except it's far more confusing
21:16:04 * emu sets out to create the foo paradigm
21:16:47 <shapr> Vincenz: there's other code in that dir if you want to play with some other stuff.
21:17:27 <Vincenz> thanx :)
21:17:45 <shapr> time for sleep, I'll be back tomorrow (today :-)
21:17:48 <Vincenz> cya
21:17:51 <Vincenz> sleep well
21:35:53 * Vincenz heads for bed himself
21:44:11 <lament> hmm.
21:44:20 <lament> is vincenz using lisp or something?
