03:25:57 <shapr> yargh
03:26:01 <shapr> good morning
03:47:11 <liiwi> mornin
03:48:30 <Chubben> hello
03:51:55 <shapr> hiya
03:52:07 <shapr> Chubben: sorry, I was away from my keyboard
03:54:33 <Chubben> i forgive you
03:54:37 <Chubben> i am eating =)
03:55:00 <shapr> Chubben: do you use Haskell?
04:00:29 <Chubben> no =)
04:00:38 <shapr> would you like to use Haskell? 
04:00:44 <Chubben> no =)
04:00:47 <shapr> haha
04:00:47 <shapr> ok
04:00:57 <Chubben> i am just here observing you haskell weirdos =)
04:01:52 <shapr> we are dedicated to elegance and simplicity of expression.
04:05:45 <shapr> food, brb
04:41:41 * shapr bounces
04:43:59 <shapr> I would rather write an instance of Arbitrary to generate External Core instead of working.
05:15:36 <shapr> hi whee 
05:20:44 <whee> hola
05:20:51 <shapr> como est as?
05:21:00 <shapr> hej, vad gor du?
05:21:04 <whee> I don't know what that means :((((((
05:21:09 <whee> I just know 'hola' L>
05:21:12 <shapr> oh, ok
05:21:13 <whee> :)
05:21:23 <shapr> I said "how are you" in spanish, then swedish
05:21:37 <whee> getting ready to go to class :\
05:21:54 <whee> and thinking about writing an ogg/mp3 streaming server for fun
05:22:08 <shapr> in Haskell?
05:22:50 <shapr> I bet hws-wp would do a good job of that
05:23:19 <whee> no, not haskell :)
05:23:23 <shapr> awww
05:24:35 <whee> ghci is still pretty much broken, and I don't think the language would be a good match
05:24:35 <shapr> oh, I wrote up some philosophical paragraphs of text describing my viewpoint of why I prefer Haskell over anything in the ML family.
05:24:36 <whee> I'd be going for erlang in this one again
05:24:41 <shapr> ok
05:24:49 <whee> also, did you seee http://smaerty.ath.cx/wooo/ ?
05:25:02 <shapr> it wasn't there last time I looked
05:25:06 <whee> I didn't feel like adding searching even though it'd be easy :)
05:25:11 <shapr> http://smaerty.ath.cx/wooo/list.yaws
05:25:11 <shapr> boom
05:25:17 <whee> der, started it in the wrong path
05:25:43 <whee> there
05:26:01 <shapr> haha, I got a ripoff link =)
05:26:13 <whee> yes :)
05:26:17 <shapr> I particularly like the :wq at the bottom of the submission page.
05:26:23 <whee> heh
05:26:58 <whee> I think the submission breaks if you don't fill everything out too
05:27:02 <whee> too lazy to fix that one :)
05:28:25 <shapr> http://www.o-t.us/upload/guest/cnnsucks.jpg
05:28:39 <whee> haha
05:30:50 <shapr> whee: your page works
05:30:50 <shapr> nice
05:30:56 <shapr> I still want one written in Haskell :-)
05:31:00 <whee> :D
05:31:16 <whee> going to go to class now (and take that down) :)
06:42:33 <SyntaxPolice> good morning :)
06:42:48 <shapr> goooood morning #haskell!
06:43:05 <shapr> I love the smell of referential transparency in the morning.
06:43:28 <shapr> GHC: something that goes thunk in the night.
06:55:18 <shapr> there's a lot to know about lambda calculus
07:01:21 <shapr> I'd rather be writing QuickCheck tests...
07:02:49 <Igloo> Than learning about lambda calculus?
07:03:15 <Smerdyakov> I'd rather do something useful :P
07:03:29 <mgoetze> SyntaxPolice: at work? boss around?
07:03:38 <shapr> oh Smerdyakov, I had a eureka moment last night....
07:03:53 <shapr> I wrote up something to say why I prefer Haskell over ML
07:04:06 <shapr> though I haven't yet offloaded it from my Palm III
07:04:09 <Smerdyakov> OK. Private message me the URL and I'll read it when I get back from class =)
07:04:15 <Smerdyakov> [[gone]]
07:04:40 <shapr> ok
07:05:05 <shapr> Igloo: I haven't yet organized all the bits of lambda calculus together into a big picture...
07:05:55 <shapr> if I could figure out how hnf, whnf, lambda lifting, call-by-need, etc all fit together
07:06:14 <shapr> I think I'd be much more informed
07:07:06 <shapr> oh, what's the word for a reversible transformation? not idempotent...
07:07:16 <shapr> something like that ...
07:07:43 <shapr> means "a transformation that preserves all information" or something to that effect
07:08:39 <SyntaxPolice> mgoetze: yeah, I'm at work.  I played some good games over the weekend, though :)
07:12:11 <mgoetze> SyntaxPolice: i'm not on all that much on weekends :)
07:12:57 <SyntaxPolice> mgoetze: yeah, I played in real life actually. At a coffee shop, and I'm teaching a friend who is learning pretty quick.
07:13:51 <mgoetze> SyntaxPolice: ah cool. i was at the chess cafe here fr and sa evening :)
07:16:30 <SyntaxPolice> that place sounds like tons of fun.
07:17:56 <shapr> Marvin--: what's your quote website again?
07:28:37 <Marvin--> shapr: http://193.11.232.159:8080/quotes/
07:29:02 <shapr> ah, thanks
07:30:54 <SyntaxPolice> mgoetze: this program's for you : http://www.syntaxpolice.org/~ijones/screenShots/smallGoBoardShot.jpg
07:31:07 <SyntaxPolice> (it just draws and takes turns, no rules)
07:31:09 <mgoetze> maybe i should forward there from from quotes.mgoetze.net or something...
07:32:07 <Marvin--> mgoetze: heh
07:32:24 <mgoetze> oh, of course i can't cut and paste between these programs... they're running on different computers... :)
07:33:25 <shapr> Marvin--: I'm not sure if the quote I added is worthwhile or not, feel free to delete it if it sucks.
07:33:44 <mgoetze> SyntaxPolice: cool, can you dcc it over?
07:35:07 <Marvin--> shapr: heh
07:35:31 <SyntaxPolice> mgoetze: I can send it now since it sort of does something, but I was going to do a little bit more first.
07:35:41 <SyntaxPolice> either way.
07:36:31 <mgoetze> SyntaxPolice: sure, whenever you're ready
08:50:56 <shapr> hi det 
08:52:47 <det> heya
08:52:51 <det> how's it going ?
08:53:23 * mgoetze is winning at go, as usual :)
08:58:24 <shapr> I'm working.
08:59:10 <shapr> det: what's up with you?
08:59:40 <det> shapr, trying to get ocamlc working
08:59:53 <shapr> what's that?
09:00:04 <det> the ocaml compiler :)
09:00:16 <det> but it is giving me an error
09:00:16 <shapr> ah
09:01:26 <det> but nothing _ver_ works, blah :(
09:01:40 <det> s/ver/ever/
09:01:51 <shapr> did you get HOpenGL to work?
09:02:54 <det> nope, wouldnt compile on windows
09:03:08 <shapr> suckage :-(
09:03:58 <whee> det: ocaml works fine in windows if you go and use cygwin or something else
09:05:05 <det> whee, you mean compile from ocaml source ?
09:05:10 <whee> yes
09:05:18 <det> argh, guess I will do that
09:05:21 <det> thanks
09:05:30 <whee> ocaml compiles very quickly
09:05:44 <det> it's the download I dont want :)
09:05:51 <det> just downloader the 6 meg installer
09:06:14 <det> and from the cygwin bash i cant get it to compile anything saying it cant find pervasives.cmi
09:06:17 <det> erm, cant open
09:06:41 <whee> well pervasives is one of the core libraries, so there might be a path that's incorrect
09:07:05 <det> I tried -I and -dllpath options with the directory it is in
09:07:06 <det> no dice
09:08:04 <whee> -I /path/to/blah should do it, where blah is the dir containing an ocaml subdir
09:17:45 <Janni> hi guys...
09:17:55 <Janni> and gals! ;)
09:18:09 <shapr> hi hi
09:18:11 <shapr> wassup?
09:18:30 <Janni> nothing but listening to music
09:20:16 <Janni> and grabbing music (a friend gave me "Brad". curious what it's like...)
09:40:00 * shapr bounces
09:40:16 <Smerdyakov> Where's that little essay you wrote, shapr?
09:40:42 <shapr> er, I got distracted by paying work...
09:41:13 <shapr> Smerdyakov: have you read the lapalm and rabhi book that shows algorithms in Haskell?
09:41:17 <shapr> er, "lapalme"
09:41:24 <Smerdyakov> Now, why does it sound like you are bragging about having to do what someone pays you to do? =D
09:41:35 <shapr> er, I wasn't...
09:41:39 <Smerdyakov> shapr, no. Have you read Chris Okasaki's functional data structures book? =)
09:41:51 <shapr> nah, it's at the top of my wish list though.
09:42:01 <shapr> it's the next book I'll purchase.
09:42:16 <Smerdyakov> I haven't read any of these, but Chris was a grad student here (the book is based on his dissertation), and it sounds interesting =)
09:42:35 <shapr> the Edison library is from him as well.
09:42:43 <shapr> I like his latest stuff
09:42:58 <shapr> he's writing a lot about postfix ops in Haskell
09:43:06 <shapr> flattening combinators I think
09:43:11 <Smerdyakov> Yes, I saw his paper in ICFP 2003
09:43:13 <Smerdyakov> 2002
09:43:13 <Smerdyakov> that is
09:44:19 <shapr> in any case, the crux of my essay is just "ease and simplicity of expression increases the chances that something will be written, and then later read by someone else (or even the author)"
09:44:39 <Smerdyakov> Indeed. Some would say that monads are anti-simplistic =)
09:45:01 <shapr> I haven't decided where I fall on that issue.
09:45:13 <Smerdyakov> Have you used ML?
09:45:20 <shapr> I do know that the jump to monadic IO is hard for many programmers.
09:45:23 <shapr> no, I haven't
09:45:30 <Smerdyakov> And... now you're writing about why it's bad?
09:45:33 <Smerdyakov> Seems odd to me
09:45:34 <shapr> have you used Haskell? :-)
09:45:40 <shapr> no no, I'm not writing about why ML is bad
09:45:43 <Smerdyakov> A little, and I've read a tutorial all the way through.
09:45:53 <shapr> I'm just saying why I would rather use Haskell.
09:46:02 <Smerdyakov> [Notice that I'm not writing a document about why I'd rather use ML.]
09:46:32 <shapr> well, call this introspection then...
09:47:39 <shapr> have you seen any comparisons of ML and Haskell?
09:51:14 <Smerdyakov> No.
09:51:30 <Smerdyakov> I think the differences are rather obvious, but I can't be sure since I haven't really used Haskell.
09:52:42 <shapr> would you mind mentioning some of the differences?
09:52:55 <Smerdyakov> lazy vs. strict
09:53:07 <Smerdyakov> Which sort of maybe includes laxness about order of bindings
09:53:18 <Smerdyakov> pure functional vs. impure
09:53:30 <Smerdyakov> syntactic conveniences
09:53:30 <Smerdyakov> That's it =)
09:54:35 <shapr> sounds simple enough
09:54:54 <shapr> for me, I prefer lazy and pure, and syntax conveniences such as type classes.
09:55:20 <shapr> I can't say whether one or the other makes it easier to express ideas, as I don't know ML.
09:55:29 <Smerdyakov> Expressing ideas is hardly the important bit.
09:55:31 <Janni> shapr: Haskell isn't purely functional, is it?
09:55:31 <Smerdyakov> Understanding them is.
09:55:35 <shapr> Janni: sure it is
09:55:47 <Janni> shapr: what about Monads?
09:55:56 <Janni> i consider them not really functional
09:55:58 <shapr> Smerdyakov: I think both of those are important, expressing and understanding
09:56:05 <shapr> monads are purely functional
09:56:22 <shapr> even though you get to do side effects with them :-)
09:57:04 <shapr> Smerdyakov: my ease and simplicity of expression allows me to return to what I have written and understand it
09:57:10 <shapr> and allows others to understand it.
09:57:17 <Janni> shapr: hmm. a function has the property that if you call it with a specific argument twice it will always have the same result. monads don't fit that property
09:57:29 <shapr> source is communication with other programmers as much as with the computer
09:57:55 <Smerdyakov> shapr, that's nice. A more organized explanation with a convincing argument could be nice.
09:57:59 <Smerdyakov> r
09:58:04 <shapr> yah, I agree
09:58:18 <shapr> I'll fix up the text I wrote yesterday.
09:58:29 <shapr> and bug you when I've done that
09:58:48 <shapr> Janni: a monad isn't a function
09:59:13 * Janni has to learn a lot about Monads (hasn't needed them yet too much)
09:59:24 <shapr> monads are very nifty
09:59:51 <Janni> then i really have to learn s.th. about them (I like nifty things ;)
10:00:31 <Smerdyakov> shapr, at this point, I get the impression that the dominating factor for you is aesthetic preference.
10:01:01 * shapr considers that
10:02:08 <shapr> the dominator factors for me are simplicity and ease of expression
10:02:15 <Marvin--> ooh, cool, music video made in lego
10:02:21 * Janni can spend a lot of time beautify code
10:02:36 <Janni> s/beautify/beautifying
10:02:54 <Smerdyakov> shapr, yet we've established no difference there compared to ML
10:03:12 <shapr> actually, simplicity and ease of expressing and understanding
10:03:47 <Marvin--> shapr: remind me to show you our compiler code when it's finished :P
10:03:57 <shapr> I'd say I haven't even looked at ML enough to know whether there's a difference or not.
10:04:02 <shapr> Marvin--: good deal :-)
10:05:42 <emu> everyone knows that Haskell is /the/ way
10:05:46 <shapr> heh
10:05:53 <shapr> except Smerdyakov 
10:05:53 <shapr> ;-)
10:05:56 <Smerdyakov> At least, everyone knows that Lisp isn't.
10:06:11 <shapr> no arguments there
10:06:13 <Smerdyakov> Ahem
10:06:18 <emu> it's alright
10:06:20 <Smerdyakov> emu is a humanities major.
10:06:21 <shapr> Smerdyakov: you know rahul?
10:06:21 <emu> on #lisp, Lisp is the way
10:06:28 <Smerdyakov> His opinions don't count :D
10:06:39 <emu> I know rahul
10:06:48 <Smerdyakov> shapr, I've sent messages with him
10:06:52 <shapr> ah, excellent
10:06:54 <Janni> emu: but #lisp isn't the way either :)
10:06:57 <Smerdyakov> shapr, I can't say "conversed," because he pretty much just talks to himself.
10:07:01 * shapr grins
10:07:06 <Janni> or have i to user "neither" here?
10:07:13 <emu> Janni: I think it's a type error
10:07:26 <shapr> Janni: you said it correctly
10:07:57 <Janni> when would i have to use "neither" (example pleease?)
10:08:01 <Marvin--> either the kylie minougs in this video walk around in circles, or there's something very Escher about this block
10:08:06 <emu> neither this nor that
10:08:14 <Janni> aahh!
10:08:15 <Janni> thx
10:08:37 <emu> and Marvin-- demonstrated either-or
10:08:47 <emu> which is exclusive or
10:09:03 <Marvin--> heh
10:09:10 <Marvin--> glad to be of service :P
10:09:38 * emu is a humanities major, and therefore interested in humanitarian languages
10:09:52 <Marvin--> studying maths/cs we tend to use xor in daily talking
10:10:01 <emu> how do you pronounce it
10:10:13 <Janni> ex-or
10:10:16 <Marvin--> ex-or
10:10:29 <emu> exorcist?
10:10:35 <Smerdyakov> sex-or
10:10:41 <Smerdyakov> I sex0r you
10:10:49 <Marvin--> sex-or-what?
10:10:53 <emu> ew, smelly CMU CS student
10:11:12 <Smerdyakov> Tehe. I went in the undergrad CS lounge for the first time today.
10:11:13 <Smerdyakov> O_o
10:11:13 <Janni> in germany some say "ex-odern" for "to ex-or". sound crazy
10:11:52 <Marvin--> is that the "surprised manga" smiley?
10:12:18 <emu> first time?
10:12:18 <Janni> s/surprised/really\ idiotic
10:12:26 <emu> I used to go in there to get cheap soda
10:12:35 <shapr> yah, what's up with those smileys?
10:12:51 <Marvin--> Janni: I thought "really idiotic" was encompassed in "manga"?
10:13:01 <shapr> I've heard some people like manga
10:13:05 * Marvin-- curses the packet loss on the student network gateway
10:13:11 <Marvin--> yeah, I know some of them too
10:13:48 <emu> surprised manga smiley?
10:13:58 <Janni> let's consider, that the possibility of a readable manga _could_ exist.. (i think you didn't read too much yet (neither I))
10:14:09 <Marvin--> I've only seen the odd movie
10:14:13 <shapr> I've been reading manga...
10:14:17 <emu> Oro???
10:14:29 <shapr> a DragonBall book translated into swedish.
10:14:30 <Marvin--> Oro?
10:14:58 <Janni> shapr: like it?
10:15:03 <Marvin--> in Swedish, "oro" means "anxiety"
10:15:07 <shapr> well, it's interesting
10:15:10 * emu suspects that DragonBall is not the greatest manga in the world
10:15:11 <shapr> I like Akira
10:15:32 <shapr> Akira is pretty, even though the plot is rather lame
10:15:52 <emu> I didn't like the movie, but maybe I'm being too harsh
10:16:03 * Janni considering shapr as a reasonable human changes his view towards manga
10:16:16 <shapr> my take on anime is "pretty but rarely logical"
10:16:23 <Janni> s/as// (right?)
10:16:29 <Marvin--> shapr: like star trek?
10:16:34 <shapr> yes, exactly
10:16:43 <Janni> s/towards/<wtf>/
10:16:55 <emu> FLCL <-- pretty but completely illogical
10:16:59 <shapr> fun to watch, not meant for mental improvement
10:18:01 <shapr> Janni: of
10:18:11 <shapr> Janni: nah, I'd use towards in that context
10:18:36 <Janni> when i ever saw s.th. manga-like, I was always deterred by typical things like _really_ big sweat drops running on the side of one's head.
10:18:51 <shapr> it does look very silly on first glance
10:18:59 <shapr> actually, I think it always looks silly
10:19:05 <shapr> but it can be lots of fun also
10:19:16 <emu> looking realistic is overrated
10:19:16 <Janni> yah, whatever...
10:19:27 <Smerdyakov> Manga can't beat good old fashioned novels.
10:19:37 <shapr> I agree
10:19:40 <emu> /good/
10:19:49 <shapr> I still like both :-)
10:19:49 <emu> but it's a different medium anyway
10:20:04 <emu> I don't think you can do the same sort of stories in them
10:20:07 <shapr> oh, I read the latest Terry Pratchett last week, it's great!
10:20:17 <emu> (well there is some overlap, obviously)
10:20:19 <Smerdyakov> *ahem* I said *good*, shapr :P
10:20:24 <shapr> and I read a Sheri S. Tepper novel two days ago that I also really enjoyed.
10:20:39 <shapr> hey, Pratchett is the most fun you can have in printed form.
10:20:50 <Smerdyakov> Sci fi is pretty universally trash.
10:20:58 <Janni> *disagree*
10:21:02 <shapr> what about Snow Crash?
10:21:03 <emu> we have here someone who doesn't know science fiction
10:21:14 <shapr> or Cryptonomicon?
10:21:17 <emu> blah
10:21:27 <Marvin--> Snow Crash is cute :)
10:21:36 <Smerdyakov> This Sheri S. Tepper.... I read that she is a "feminist" SF author.
10:21:39 <shapr> what about Earthweb?
10:21:40 <Smerdyakov> Pray tell, what does that mean?
10:22:06 <shapr> I didn't notice that while reading her book.
10:22:22 <shapr> she has truly excellent characterization in that book.
10:23:17 <Smerdyakov> It's possible. I doubt it compares to Dostoyevsky's.
10:23:43 <shapr> so, read Dostoyevsky before you read her :-)
10:24:32 <Smerdyakov> First step accomplished
10:26:03 <Smerdyakov> I'm always interested in what someone means when he calls something "feminist."
10:26:10 <Smerdyakov> Quite often he has no idea what he's talking about.
10:26:31 <emu> there are a number of different kind of ideas calling themselves feminist these days
10:26:42 <emu> but I haven't made any intensive study of it
10:26:47 <Smerdyakov> ... and most are utter balderdash
10:26:54 <emu> shapr: I mostly picked up anime and manga for passive entertainment
10:27:25 <shapr> yah, I agree
10:27:44 <shapr> passive entertainment can contribute to balance
10:28:15 <Janni> i only read some really funny online-comics. (some of them are a _bit_ manga-like)
10:28:18 <emu> I'm having a tough time imagining Ranma as an ordinary novel
10:28:52 <emu> or even Kenshin
10:33:16 <emu> it's the whole show-rather-than-tell thing
11:03:11 <SyntaxPolice> hmm.. some very strange thing came with my bodum coffee press and I can't figure out what it is.
11:14:35 <shapr> what does it look like?
11:14:54 <shapr> is it bigger than a breadbox?
11:17:29 <SyntaxPolice> no, smaller than a breadbox.  It has a plastic hinge and a clip on one end.  It fits nicely into my hand like a handle. I can't find anything to clip it to or put in it.  It opens and closes, and if you put a coffee bean inside it and close it, the coffee bean gets smashed.
11:26:57 <shapr> maybe it's for grinding your own coffee, bean by bean?
11:27:14 <shapr> it could be for per-cup coffee cooking
11:27:17 <shapr> not brewing
11:29:46 <SyntaxPolice> hmm... coffee cooking... It really may be meant for smashing things... coffee beans are split in half before cooked, right? Maybe its for that?
11:29:57 <SyntaxPolice> this might split something soft... I don't know anything about making coffee.
11:30:20 <shapr> I didn't start drinking coffee till after I moved to europe...
11:30:50 <shapr> I know that they sell two types of coffe, brygg (brew) and kok (sp?) (cook)
11:31:15 <shapr> for brew you put the grounds into a filter and run water through the grounds and filter combo 
11:31:45 <shapr> for cook, you put the grounds and water into the pot, and strain it only when you pour
11:32:18 <shapr> also means the last cup in a pot has dregs, and is extracrunchy (and very stimulating)
11:32:54 <SyntaxPolice> hehe
11:33:15 <shapr> maybe you already know all that stuff though :-)
11:33:32 <SyntaxPolice> nope.
11:33:53 <SyntaxPolice> Maybe I can take a picture of this sometime and show you guys what it is.
11:33:59 <shapr> yah good idea!
11:52:18 <flippo> I read an article about smalltalk this morning.  It complains that static types have poor granularity.  Some methods require types with more methods than necessary, or else you have a proliferation of too many types.  Too many types leads to poor extensibility.  Hadn't thought about that before.
11:52:45 <flippo> If the pain of defining a new type is small, perhaps it doesn't matter.
11:53:01 <shapr> can you give an example?
11:53:38 <flippo> shapr: Let's say containers.  Many container methods require different subsets of available operations.
11:53:51 <SyntaxPolice> shapr: this is the set, but the "item" is not pictured here.http://www.bodum.com/shop/home.asp?CHK=1600&SLT=&mscssid=EE6JG6UJ6XSR2M3G000CM9L4BAMUEMN9
11:55:15 <flippo> shapr: all the comparisons were against java, which indeed makes defining new types a burden
11:55:17 <Janni> SyntaxPolice: maybe it's a device for smoking or injecting coffee beans?
11:55:35 <shapr> SyntaxPolice: is this it? http://www.bodum.com/shop/home.asp?CHK=1600&SLT=&mscssid=EE6JG6UJ6XSR2M3G000CM9L4BAMUEMN9
11:56:14 <shapr> flippo: did they give an example?
11:56:18 <flippo> shapr: http://wiki.cs.uiuc.edu/VisualWorks/Mark+Fussell+Dynamic-vs-Static+Typing+Message
11:56:23 <shapr> ah, excellent
11:56:34 <whee> haha, I actually read that last night too
11:56:45 <flippo> whee: weird :)
11:56:56 <whee> I was looking for another language to learn, then decided that I still hate OO :)
11:57:05 <flippo> http://www.chimu.com/publications/short/whyDynamicTyping.html  A slightly different version of the same material
11:57:17 <SyntaxPolice> shapr: what am I looking at in that URL. I don't see the "thing" pictued there.
11:57:27 <SyntaxPolice> Janni: cool. now I need to learn to use it.
11:59:51 <Janni> SyntaxPolice: just crunsh it in that thing at put it into a pipe and smoke it (*searching the web for "smoking coffe beans"*)
12:04:14 <Janni> there don't seem to be many coffee smokers out there (anymore? :)
12:04:49 <whee> maybe they're all dead from smoking coffee :)
12:06:15 * Marvin-- is getting mad at his C code
12:06:17 <flippo> whee: Haskell has more OO than it usually advertises
12:06:19 <Marvin--> maybe I should smoke some coffee
12:06:22 <shapr> flippo: I think some of these static typing problems are solved in Haskell with type classes, and type inferencing
12:06:38 <whee> flippo: still it doesn't force you to use an OO style
12:07:29 <flippo> shapr: I'm going to watch for the proliferation of narrow types though.  And I do worry about merging with someone else's world of narrow types.
12:08:00 <Janni> i loved OO until I got to know Haskell. now it seems to be just... pointless...
12:08:05 <shapr> what's a narrow type?
12:08:25 <flippo> shapr: a type defined to support just enough operations for given method
12:08:39 <whee> I don't mind languages which allow you to structure things with objects, but the pattern really doesn't work with everything
12:09:08 <flippo> shapr: I'm just using "narrow type" as a shorthand.  It's not a real term
12:10:06 <shapr> ok
12:10:15 <shapr> I was looking for a more specific definition :-)
12:11:41 <Marvin--> Janni: I like the idea of tying data and operations together in a separate scope... It'd be nice if you in Haskell could say  stack.push x  instead of  push stack x
12:12:29 <shapr> I think at that point, you start needing dynamic typing
12:13:57 <Marvin--> I don't understand how I manage to trash the stack in this code *confused*
12:14:33 <flippo> shapr: I like the way Eq defines a default for both (==) and (/=) and requires only one.  That makes such a "narrow" type much more friendly.
12:14:50 <shapr> yah, I've thought about type classes a lot
12:15:17 <shapr> they seem to get around most of the limitations I've seen in C and Java, but I'm not sure yet.
12:16:14 <flippo> shapr: I'm very encouraged.  I'll trade the burden of defining types up front to the burden of checking for errors when someone passes my function the wrong type of object.
12:16:33 <flippo> shapr: Rather, I prefer the former to the latter
12:17:48 <shapr> two things that I find interesting about this
12:17:56 <shapr> python has "the honor system"
12:18:28 <shapr> in typeclasses you specify an operation(?) rather than a type
12:19:08 <shapr> in python you can say "accepts a file-like objects" and everyone knows that means the object needs to implement read(), seek(), tell() and not much else.
12:19:38 <Smerdyakov> No Java-style interfaces in Python?
12:19:40 <shapr> in a lot of cases you only have to implement read() and nothing else to have a fake file object
12:19:46 <shapr> nope, no interfaces
12:19:50 <shapr> just the honor system
12:20:36 <flippo> shapr: I always find the documentation of python methods inadequate.  I have to experiment with the command line before I am sure what is required of method arguments
12:22:07 <shapr> for Haskell typeclasses, if you want an existing type to support an 'operation' defined by a typeclass, you can often just define an empty instance, and it just works (unless it's a really complicated datatype)
12:22:40 <shapr> or you can actually write whatever code is needed for that type to support that 'operation'
12:23:21 <flippo> I suppose it is better to implement too many methods than too few
12:25:03 * shapr tries to bring that all together with the a) b) c) d) items in the dynamic typing article
12:25:48 <shapr> well, I think Haskell covers A) and D) obviously
12:26:25 <shapr> I don't think C) happens either (does it?)
12:27:12 <shapr> is C) about subclasses being upcast to more general types?
12:27:20 <flippo> shapr: I'm not sure.  Does haskell ever require something like isinstanceof? 
12:27:49 <shapr> not that I know of...
12:27:56 <flippo> shapr: yes, it's about upcasting.  But I think generic functions make that unnecessary.
12:28:02 <shapr> yah, I think so too
12:28:33 <shapr> I still don't really understand the B) item
12:29:05 <flippo> shapr: B is the main one.  That's what I mean by the proliferation of narrow types
12:29:29 <flippo> shapr: different methods may require different subsets of all the methods in a given typeclass.
12:29:42 <shapr> I think you can get around that one with the way typeclasses are already defined
12:30:05 <SyntaxPolice> my simple HTk Go board in Haskell can be gotten from here (includes an i386 Linux executable) http://www.syntaxpolice.org/~ijones/simpleGoBoard.tgz
12:30:06 <flippo> shapr: because of the ease of defining defaults?  Or a fine grained tree of typeclasses?
12:30:31 <SyntaxPolice> with a screen shot here: http://www.syntaxpolice.org/~ijones/screenShots/smallGoBoardShot.jpg
12:31:05 <shapr> I think the fine grained tree of typeclasses is most important to getting around the narrow types problem.
12:31:18 <shapr> have you looked at the implementation of Ord for example?
12:31:28 <shapr> er, the declaration, whatever you call it
12:31:43 <flippo> shapr: yes, I was just looking at Ord.  I like it very much :)
12:31:44 <andersca> yay, a gnome user
12:32:26 <flippo> shapr: such a fine-grained tree would be a burden in java or C++
12:32:51 <shapr> flippo: I think the essence of C) is that you encode some to many of your design decisions in your typeclass tree
12:33:03 <shapr> and in Smalltalk or Python, you don't
12:33:35 <shapr> SyntaxPolice: looks nice 
12:33:43 <flippo> shapr: Merging code could be a problem, with so many specific types defined.  What do you think?
12:33:48 <flippo> SyntaxPolice: purty
12:33:59 <shapr> merging when?
12:34:04 <shapr> with other developers? or what?
12:34:15 <flippo> shapr: merging with other independently developed code
12:34:55 <SyntaxPolice> thanks :-)
12:35:19 <shapr> I think the only times you'd have problems merging, is if you try to combine modules that cover the same problem domain
12:35:35 <flippo> shapr: that's an excellent point
12:35:43 <shapr> because then, decisions on how to represent the data are tied up in the typeclass tree
12:35:52 <flippo> shapr: The author of the article has obviously never looked at Haskell :)
12:36:00 <shapr> :-)
12:36:14 <shapr> on the other hand, this discussion has made a great many things much more clear to me
12:36:20 <shapr> so I'm happy he didn't!
12:36:49 <flippo> shapr: heh.  It was well argued, comparing smalltalk and java anyway
12:37:38 <shapr> well, I already agreed with him
12:37:50 <flippo> shapr: smalltalk does require lots of unit test code to catch all cases where the wrong type object might be passed along
12:37:59 <shapr> I've been calling Haskell 'compile-time dynamically statically typed'
12:38:19 <shapr> I think Haskell requires just as much unit testing
12:38:26 <shapr> I could be wrong
12:38:40 <flippo> I like heavy unit testing anyway
12:39:03 <shapr> me too
12:39:10 <shapr> have you seen QuickCheck?
12:39:11 <flippo> I think I'd emphasize the type-inference rather than use the word "dynamically"
12:39:35 <flippo> never saw QuickCheck
12:39:44 <shapr> well, is python is run-time statically typed?
12:40:14 <flippo> shapr: no python is run-time dynamically checked
12:40:30 <shapr> http://www.math.chalmers.se/~rjmh/QuickCheck/
12:40:35 <shapr> extra spiffy way to test your code.
12:40:41 <flippo> every object is a suprise in python.  Thus, methods should check their arguments carefully
12:40:43 <Heffalump> run-time statically typed makes no sense
12:41:01 <shapr> I think QuickCheck could subsume Design by Contract and Unit Testing with some work.
12:41:50 <shapr> actually, the Self VM did do runtime static typing
12:42:18 <flippo> I assumed static checking only made sense at compile time
12:42:39 <shapr> afaiu, every time a new combination of types hit a slot, it would compile the slot to binary code that was specific to that combination of types
12:42:47 <shapr> and it saved all of the combinations
12:42:52 <flippo> Once compiled, values no longer know their type.
12:43:00 <shapr> I think it's called poly-inline caching
12:43:12 <shapr> and I think it's what the HotSpot JVM uses
12:43:34 <flippo> shapr: okay
12:44:02 <shapr> anyways...
12:44:08 <shapr> quickcheck is nifty
12:44:18 <flippo> I'll look into it
12:44:31 <flippo> I don't have enough code yet to give it much exercise
12:44:54 <shapr> there's also HUnit @ hunit.sf.net
12:48:32 * shapr goes from thinking deeply to being sleepy
12:49:43 <shapr> flippo: what kind of stuff do you write?
12:50:16 <flippo> shapr: scientific programming, numerical methods, signal processing
12:50:30 <flippo> shapr: doesn't really require haskell :(
12:50:40 <shapr> have you seen the DSP libs in the topic?
12:51:51 <shapr> chakravarty's parr lib is promising
12:51:52 <flippo> shapr: no, I'll look.  We implemented standard DSP algorithms long ago though.
12:53:01 <flippo> shapr: we have all those algorithms in multiple languages, but maybe I can learn some numerical haskell style from those examples.
12:55:41 <shapr> I wonder what Pseudonym would say about that article.
12:56:01 <flippo> Hmm.  Those lhs files are almost empty.
12:56:20 <shapr> note that haskell code is usually much more dense than something like Python
12:56:37 <flippo> shapr: these look unimplemented
12:56:53 <shapr> oh..
12:58:10 <flippo> Why would he put > at the beginning of lines of code?
13:00:02 <flippo> shapr: I might have just started with the wrong files.  The formatting is all messed up though.  Some are html.  Others are not.
13:00:09 <shapr> it's literate haskell
13:00:15 <flippo> ah
13:00:20 <shapr> there are two styles of literate haskell
13:00:29 <shapr> one where > has to be in front of lines of code
13:00:55 <shapr> and the LaTeX style, where actual code starts with \{code} (I think)
13:01:14 <flippo> Okay.  That's dandy.
13:01:14 <Igloo> \begin{code}
13:01:19 <shapr> I haven't used the latex style yet, I don't know latex :-)
13:01:25 <shapr> Igloo: thanks
13:02:26 <flippo> That Levinson recursion is very dense
13:02:44 <shapr> can you read it?
13:03:23 <flippo> shapr: I don't understand the use of !
13:03:45 <flippo> shapr: oh, for complex numbers
13:03:46 <shapr> er, I think it's an array index in that case
13:05:19 <flippo> (!)      :: Ix a => Array a b -> a -> b
13:05:26 <shapr> yup
13:06:02 <shapr> makes me wish I had a clue about signal processing :-)
13:06:53 <flippo> It's fun stuff  :)
13:08:03 <flippo> data (RealFloat a) => Complex a = !a :+ !a  -- I don't understand this use of !
13:08:23 <flippo> infix  6  :+
13:08:37 <shapr> I think that's a strictness annotation
13:08:59 <Heffalump> are you sure about that = ?
13:09:02 <flippo> strictness?
13:09:04 <Heffalump> oh yes, sorry.
13:09:16 <Heffalump> yes, it's a strictness annotation
13:09:20 <shapr> haskell is lazily evaluated by default
13:09:21 <Heffalump> the Report explains them
13:09:28 <flippo> ah
13:09:47 <shapr> like the famous lecture "Today's lecture is on lazy evalution. Any questions?"
13:09:56 <Marvin--> heh
13:10:13 <Heffalump> lol
13:10:15 <Heffalump> who gave that?
13:10:21 <shapr> I've forgotten...
13:10:25 <flippo> I had a professor like that
13:10:29 <shapr> I heard it here, so it must be in the logs somewhere
13:12:32 <YveDeLarc> hi
13:12:36 <shapr> hi YveDeLarc 
13:13:01 <YveDeLarc> hi shapr, did you get my new code?
13:13:15 <YveDeLarc> (IrcM)
13:13:22 <shapr> silly question, if you have the ! strictness annotion in a constructor, does it use seq, or something like DeepSeq?
13:13:26 <shapr> YveDeLarc: yes I did
13:13:48 <shapr> I haven't looked at it yet, work has gotten in the way
13:13:51 <YveDeLarc> ah
13:13:57 <Heffalump> it doesn't use either
13:14:08 <YveDeLarc> it's not that special yet, no protocol demux yet
13:14:16 <Heffalump> though it's most similar to seq
13:14:48 <shapr> YveDeLarc: oh, Pseudonym wrote an irc bot that can say hello and not much else, shall I forward the code to you?
13:15:13 <shapr> I'll be many hours on the bus tomorrow, I'm planning on reading lots of code then.
13:15:21 <shapr> Heffalump: what does it do?
13:15:33 <YveDeLarc> shapr: yes, please
13:16:03 <shapr> YveDeLarc: thanks for sending me the code, I'm looking for lots of before and after explicit passing and monadized versions so I can compare.
13:16:37 <dark> shapr: Can I see that bot code?  I might want to play with a megahal-like bot.
13:16:58 <shapr> yah, I'll put the tgz online
13:17:03 <YveDeLarc> well, I find the example mainloop with the ping handler somewhat cute. ;)
13:18:25 <YveDeLarc> it's basically: mainloop = do (IM (_, pdu)) <- recv; basehandler pdu; mainloop)   and   basehandler (Ping a) = send $ pong a
13:18:27 <YveDeLarc> *g*
13:18:51 <shapr> http://kungens.kemi.fi/~shae/src/haskell/lambdabot.tar.gz
13:18:59 <YveDeLarc> shapr: thx
13:19:03 <shapr> yah
13:21:47 <YveDeLarc> hmm. that code is interesting, far more advanced than mine.
13:22:42 <shapr> maybe I should throw it into the haskell-libs cvs tree 
13:24:29 <shapr> time for TV, bbl
13:24:36 <YveDeLarc> have fun
13:35:31 <YveDeLarc> bye
13:45:00 <SyntaxPolice> shapr: any news wrt that libraries script?
13:51:17 <dark> Hmm, where can I find libraries to tries?
13:51:26 <dark> I'm assuming they have been written already :-)
13:51:32 <dark> s/to/for/
14:39:12 <stepcut> exit
14:39:15 <stepcut> ack
14:39:16 <stepcut> sorry
14:42:21 <camold> cu all und gn8 !
14:42:50 <dark> Ooh, tokenized english.
15:17:06 <shapr> wow, a monad written in Java
15:17:08 <shapr> http://c2.com/cgi-bin/wiki?OnMonads
15:17:16 <dark> That's almost evil.
15:17:29 <dark> Well, "in Java" tends to imply at least a low-grade evilness.
15:19:53 <whee> I better start using java again now that I can combine the worst language and the most confusing topic :)
15:20:04 <shapr> write arrows in java
15:21:03 <shapr> flippo: I think narrow types are a new technical term
15:21:05 <shapr> I'll be using them
15:55:37 <shapr> suddenly I realize I've never spoken Haskell source outloud...
15:55:58 <shapr> I have no idea how to describe most of these operators in spoken language
15:56:58 <dark> Read the Intercal manual for inspiration?
15:57:03 * shapr snickers
15:57:11 <shapr> I was reading HaskellLanguage on TheWiki
15:57:35 <shapr> and they said | and <- in list comps are "such that" and "drawn from"
15:57:38 <shapr> I didn't know that.
15:58:23 <dark> I think that's based on set notation.
15:58:31 <shapr> spiffy
15:58:33 <dark> math teachers have had to read those aloud in class :)
15:58:56 <dark> Though I think set notation would use "element of", and "drawn from" is an accuratization for the list context.
15:59:09 <dark> "accuratization" is a word I just made up.
16:00:18 <shapr> nice word
16:00:18 <dark> In the Intercal tradition, I propose reading "=" as "eep".
16:00:25 * shapr snickers
16:00:48 <dark> ! remains "bang", so list indexing is "bang bang".
16:01:06 <shapr> that could be much fun to read
16:01:09 <dark> sections, because they're parenthesized, are introduced with "by the way"
16:01:14 * shapr snickers
16:01:25 <Heffalump> :-)
16:02:33 <dark> sum eep foldl by the way plus zero
16:02:45 <dark> Hmm, not the shining gem of clarity I'd hoped for.
16:02:52 * shapr grins
16:03:06 <shapr> hey dark, are you a fan of dynamic typing?
16:03:28 <dark> I've been known to use FiniteMap Dynamic Dynamic
16:03:35 * shapr grins
16:03:43 <shapr> that's not quite what I meant, but it is funny
16:03:44 <dark> Er, FiniteMap String Dynamic, sorry :)  I wasn't _that_ ambitious.
16:04:16 <dark> Well I did it because I realized that I didn't have to use perl just to get its dynamic hashes :)
16:04:29 <shapr> that's true
16:05:11 <Smerdyakov> dark, this with a compiler with explicit support for runtime type tags?
16:05:51 <dark> It's actually quite nice in Haskell, you just define the "get" operation where the desired type is treated as a part of the key.
16:06:09 <Smerdyakov> So it's unsound?
16:06:11 <dark> Smerdyakov: Yeah, it uses ghc's Data.Dynamic library.  But I think that library is pure Haskell.
16:06:43 <dark> Smerdyakov: No, it's sound -- it returns (Typeable a) => Maybe a, which will be (Just a) if the type matches and the key is present, otherwise Nothing.
16:07:09 * dark violently mistreats the distinction between type and data constructors.
16:07:09 <Smerdyakov> Is this based on Weirich's tricks for encoding dynamic types in Haskell?
16:07:44 <shapr> er, what's the max size for a memo pad note?
16:08:17 <dark> Oh, it's not pure Haskell :)  It uses unsafeCoerce :: a -> b internally.
16:08:46 <Heffalump> Weirich's tricks unfortunately require passing around an identity function everywhere as witness to the convertibility of two types
16:09:17 <dark> But a Dynamic value contains the type as well as the data, and fromDynamic fails if the type doesn't match.
16:09:21 <Smerdyakov> Heffalump, were you at the last ICFP?
16:09:24 <dark> So it's safe.
16:10:06 <Heffalump> Smerdyakov: yeah
16:10:13 <Smerdyakov> Heffalump, do you have a picture online? =)
16:10:16 <Heffalump> (the one where someone gave almost an exact copy of them? :-)
16:10:23 <Smerdyakov> Heffalump, moi: http://www.schizomaniac.net/
16:10:27 <Heffalump> http://www.ox.compsoc.net/~ganesh/
16:10:36 <Heffalump> Smerdyakov: yeah, I've looked at it, don't recall seeing you there
16:10:39 <Smerdyakov> Heffalump, yes, and Karl Crary (whom I sort of work for) was getting all riled up over it =)
16:10:47 <shapr> nice picture
16:11:06 <dark> Riled up over what?
16:11:39 <Heffalump> the fact that someone was giving a presentation that was almost entirely a copy of something that had been presented at the same conference 2 years previously, with the addition of one not hugely important result
16:12:01 <Heffalump> there was also a fairly similar presentation at the Haskell workshop :-)
16:12:35 <Heffalump> mind you, Weirich was on the PC, so maybe she really thought the new bit was worthwhile
16:13:13 <Smerdyakov> I knew 0 Haskell at that time, so I pretty much just watched and enjoyed the political intrigue =)
16:13:51 <Heffalump> you had to love Wadler's contribution
16:14:06 <Smerdyakov> You mean his remarks after everything?
16:14:10 <Heffalump> yeah
16:14:31 <Smerdyakov> I thought it was cool that he did that, until someone pointed out that he was always congratulating people on extending his own ideas =)
16:15:30 <dark> Heh.
16:15:45 <Heffalump> His congratulations always seem to have something of a "I'm really brilliant so my praise must mean something" to it
16:15:51 <shapr> heh
16:15:55 <shapr> that's kind of scary
16:16:30 <shapr> I'm most impressed with stuff I would never have thought of
16:16:34 <shapr> what are you impressed with?
16:16:53 <dark> Is this a family channel?
16:17:03 <Heffalump> oh, and http://urchin.earth.li/photopub/range?range=/users/ganesh/events/afp2002/240&style=/down
16:17:28 <Heffalump> shapr: that too, or stuff where someone has put in lots of work and come up with nice conclusions
16:19:30 <shapr> is that wadler?
16:22:37 <Heffalump> yeah
16:22:42 <shapr> um,
16:22:46 <shapr> is he wearing a shirt?
16:22:55 <Heffalump> no...
16:22:59 <shapr> just shorts?
16:23:07 <shapr> oh, and shoes
16:23:15 <shapr> I'm scared.
16:24:07 <Smerdyakov> And he did that to match a talk title?
16:24:36 <shapr> cool :-)
16:28:24 <shapr> yah, I agree
16:28:26 <shapr> g'night all
16:29:16 <Heffalump> smerdyakov: yeah, about XQuery
16:29:30 <Heffalump> well, the caption wasn't the talk title
16:29:47 <Heffalump> it's just a quote of what he said as he pulled the T-shirt off
19:46:26 <kawfee> anyone here familiar with innermost and outermost evaluation?
19:46:38 <kawfee> I'm trying to evaluate the following expressions by hand: 
19:47:00 <kawfee> let f x y = if x > 0 then x else x*y in f(3+7) (f 8 4)
19:48:48 <engstad> kawfee: and what's the problem?
19:49:12 <kawfee> I don't know how to evaluate it
19:49:19 <kawfee> I was thinking substitution
19:49:22 <engstad> Do you know C or Pascal?
19:49:28 <kawfee> I know C
19:49:36 <engstad> That's your problem. :-)
19:49:42 <engstad> Don't think in C. 
19:50:04 <Heffalump> substitution on an outermost basis is roughly right
19:50:08 <kawfee> f f(3+7) (f 8 4) = if f(3+7) > 0 then f(3+7) else f(3+7)*(f 8 4)
19:50:15 <kawfee> you aren't being very helpful here
19:50:16 <Heffalump> though it ignores the sharing effects of graph reduction
19:50:22 <kawfee> I need to do leftmost outermost
19:50:25 <engstad> The main problem you have is the expression: f (3+7) (f 8 4) right?
19:50:29 <kawfee> yes
19:50:46 <kawfee> so you do a textual substitution
19:50:49 <kawfee> without evaluating 
19:50:51 <engstad> See, in C it is the same as:   f(3+7, f(8,4)).
19:50:55 <kawfee> but it doesn't make sense
19:51:02 <kawfee> don't tell me C
19:51:04 <kawfee> I want to know haskell!
19:51:17 <kawfee> haskell haskell haskell!
19:51:22 <engstad> Of course, but since you know C it's easier. :-)
19:51:27 <kawfee> hrm
19:51:27 <kawfee> ok
19:51:59 <engstad> So, if I read it out it is: the function "f" with the two arguments: a) (3+7) and b) f 8 4.
19:52:08 <kawfee> right
19:52:11 <engstad> Does it make more sense?
19:52:12 <kawfee> x and y are the args
19:52:19 <kawfee> I know that already
19:52:36 <kawfee> I need to do an leftmostoutermost evaluation on it
19:52:44 <kawfee> I need to do an leftmost-outermost evaluation on it
19:52:49 <engstad> ok.
19:53:04 <kawfee> right
19:53:23 <engstad> And what does that mean? 
19:53:28 <kawfee> heh
19:53:59 <engstad> Nono, you did something silly up there.
19:53:59 <kawfee> outermost means  substitute each argument unevaluated for each occurence of the corresponding parameter
19:54:03 <kawfee> no I didn
19:54:04 <engstad> Look at it again:
19:54:11 <kawfee> well maybe I did
19:54:12 <engstad> let f x y = if x > 0 then x else x*y in f(3+7) (f 8 4)
19:54:15 <engstad> f f(3+7) (f 8 4) = if f(3+7) > 0 then f(3+7) else f(3+7)*(f 8 4)
19:54:19 <engstad> That's wrong.
19:54:35 <engstad> Do you see the error?
19:54:37 <kawfee> f(3+7) (f 8 4) = if f(3+7) > 0 then f(3+7) else f(3+7)*(f 8 4)
19:54:50 <kawfee> had a typo
19:54:53 <engstad> ok.
19:54:57 <kawfee> sorry
19:55:06 <kawfee> now that looks wrong to me
19:55:19 <kawfee> but I did what I thought I was supposed to do
19:55:27 <engstad> hmm.
19:56:12 <engstad> The x and y on the left of the equal sign shouldn't be substituted.
19:56:43 <kawfee> right
19:57:15 <kawfee> it still isn't right
19:57:23 <kawfee> there isn't a way to evaluate f(3+7)
19:57:43 <engstad> Well it's missing a parameter.
19:57:44 <Smerdyakov> Why do I feel like you haven
19:57:49 <Smerdyakov> 't looked at any examples, kawfee? =)
19:58:04 <Smerdyakov> engstad, balderdash. Every function takes a single parameter.
19:58:05 <kawfee> I am looking at them now, I even went to the professors office today and went over them with him
19:58:25 <engstad> ;-)
19:58:40 <kawfee> here's the example in the notes: 2 +(\x -> (x+3)/(5-x)) (7-3)
19:58:47 <kawfee> so we do an outermost eval
19:59:06 <kawfee> 2 +(\x -> ((7-3)+3)/(5-(7-3)))
19:59:26 <kawfee> 2 +(4+3)/(5-4))
19:59:37 <kawfee> 2 +(7)/(5-4))
19:59:40 <kawfee> 2 +(7)/(1))
19:59:51 <kawfee> 2 + 7
19:59:53 <kawfee> 9
19:59:56 <kawfee> viola
20:00:01 <kawfee> I get that one
20:00:15 <kawfee> but the if substitutions confuse me
20:00:20 <Smerdyakov> I'm not with you on keeping the \x in the first step.
20:00:49 <engstad> There's nothing special about the if.
20:00:52 <kawfee> yeah it shouldn't be ther
20:00:55 <kawfee> e
20:01:02 <kawfee> sorry
20:01:04 <engstad> Yes, first step is wrong.
20:01:08 <kawfee> right
20:01:22 <kawfee> I concur
20:01:59 <engstad> Btw:  let f x y = ... in f a b ===> (\x y -> ...) a b in Haskell.
20:02:50 <Smerdyakov> Which ===> (\x -> \y -> ...) a b, yes? =)
20:02:57 <engstad> Yes.
20:02:58 <kawfee> what
20:03:04 <kawfee> please stop confusing me
20:03:11 <kawfee> we haven't gotten to ==> yet
20:03:11 <Smerdyakov> If you have a question, ask it, kawfee.
20:03:20 <Smerdyakov> That just signifies a reduction step.
20:03:26 <kawfee> I don't think my evaluation is correct
20:03:26 <engstad> Oh, I just use it as a reduction step.
20:03:28 <Smerdyakov> It goes between the lines in your example.
20:03:30 <kawfee> so I'm confused
20:03:37 <engstad> 2 + 7
20:03:37 <engstad> 9
20:03:39 <Smerdyakov> Which evaluation?
20:03:41 <engstad> 2 + 7 ===> 9
20:03:44 <engstad> Get it?
20:03:50 <kawfee> let f x y = if x > 0 then x else x*y in f(3+7) (f 8 4)
20:04:00 <kawfee> leftmost-outermost
20:04:16 <Smerdyakov> kawfee, first change all syntatic sugar to the underlying forms.
20:04:31 <engstad> Ok, here's an easier one first: let abs x = if x > 0 then x else -x in abs (-3)
20:04:33 <kawfee> not sure wher ethe  syntactic sugar is
20:05:57 <Smerdyakov> Haskell evaluation rules are unnecessarily complex.
20:06:01 <kawfee> I was thinking this: f(3+7) (f 8 4) = if f(3+7) > 0 then f(3+7) else f(3+7)*(f 8 4)
20:06:05 <Smerdyakov> All these nutty uses of names defined later :P
20:06:07 <kawfee> but it doesn't seem to make sense
20:06:18 <Smerdyakov> kawfee, do engstad's example!
20:07:03 <kawfee> if -3 > 0 then -3 else -(-3)
20:07:07 <kawfee> I did it!
20:07:37 <kawfee> that one was easy
20:07:45 <kawfee> the one I have confuses me
20:07:49 <Smerdyakov> Not really different from the one you asked about first.....
20:08:09 <engstad> nono, not done yet: if -3 > 0 then -3 else -(-3) ==> if False then -3 else -(-3) ==> -(-3) ==> 3
20:08:24 <engstad> we cant do your home-work, see. :-)
20:08:40 <engstad> we can give you similar excercises to help you though. 
20:08:43 <Smerdyakov> Honestly, kawfee, go find some examples.
20:08:55 <Smerdyakov> If they're not provided by the instructors, complain to them.
20:09:13 <Smerdyakov> If you only find that one anywhere, then I'm guessing you've been skipping lectures, if you're supposed to be able to do this now.
20:09:34 <kawfee> right
20:09:44 <kawfee> I'm not asking you to do my homework, then I wouldn't learn anything
20:09:51 <engstad> ok, so the abs one was easy. try this on:
20:10:04 <kawfee> Smerdyakov: actually I've attended every lecture
20:10:11 <engstad> let f x y = if x < y then x else x * y in f 4 3
20:10:15 <kawfee> I don't like missing class
20:10:25 <Smerdyakov> kawfee, and have more examples been done in class?
20:10:36 <kawfee> if f 4 3 < y then f 4 3 else f 4 3 * y
20:10:38 <kawfee> yes 
20:10:43 <engstad> nope.
20:10:45 <engstad> do it again.
20:10:54 <kawfee> but nothing as extensive as the one I have
20:11:02 <kawfee> oops
20:11:03 <kawfee> sorry
20:11:24 <kawfee> if 4 < 3 then x else 4 * 3 
20:11:30 <engstad> almost!
20:11:38 <kawfee> if 4 < 3 then 4 else 4 * 3 
20:11:38 <kawfee> heh
20:11:44 <engstad> and then?
20:11:57 <kawfee> ok I see what you are saying, but the part I don't understand is mine is the first substitution
20:12:10 <kawfee> if False then 4 
20:12:18 <kawfee> 4
20:12:24 <kawfee> wait
20:12:36 <kawfee> if False then 4 else 4 *3
20:12:40 <engstad> Yes!
20:12:42 <kawfee> 4 *3
20:12:44 <kawfee> 12
20:12:47 <engstad> Perfect.
20:12:49 <kawfee> you gave me a trick question
20:13:18 <kawfee> let f x y = if x > 0 then x else x*y in f(3+7) (f 8 4)
20:13:18 <Smerdyakov> ?!
20:13:22 <engstad> Final one: let f x y = if x < y then x else x * y in f 4 ( (f 4 3) - 8 )
20:13:27 <kawfee> x = f(3+7), y = (f 8 4)
20:13:30 <kawfee> right?
20:13:37 <engstad> No,
20:13:40 <kawfee> oh
20:14:06 <engstad> "f(1)" is the same as "f (1)" which is the same as "f 1" in Haskell.
20:14:37 <emu> what a strange string equivalence
20:14:38 <kawfee> if 4 < f(4 3) - 8) then 4 else 4 * f(4 3) - 8)
20:14:54 <kawfee> that doesn't look right
20:15:03 <engstad> So "f(3+7) (f 8 4)" is the same as "f (3+7) (f 8 4)" which is the same as "f (3+7) b" where "b = f 8 4".
20:15:07 <kawfee> and here comes my confusion
20:15:29 <Smerdyakov> kawfee, you just forgot parentheses.....
20:15:31 <Smerdyakov> emu, why?
20:15:33 <engstad> I'm really telling you what to do there.
20:16:42 <emu> Smerdyakov: "f (1)" is equal to "f 1" ?
20:16:43 <emu> =)
20:16:52 <Smerdyakov> emu, why strange?
20:16:57 <kawfee> please explain
20:17:01 <engstad> Try it. 
20:17:14 <kawfee> emu: who let you in here? 
20:17:14 <Smerdyakov> kawfee, your answer was right if you just put in 2 more ('s.....
20:17:19 <kawfee> Smerdyakov: what!
20:17:34 <emu> Prelude> "f (1)" == "f 1"
20:17:35 <emu> False
20:17:37 <kawfee> Smerdyakov: how?
20:17:39 <engstad> That's the main difference between C/Pascal like languages and Haskell. Btw, in Scheme/Haskell you write it like (f 1).
20:17:42 <kawfee> how does f 4 evaluate?
20:17:59 <kawfee> engstad: then you define f as 1
20:18:16 <engstad> Read it as "f of one".
20:18:23 <kawfee> I do
20:18:30 <kawfee> but you still need a def in scheme
20:19:32 <engstad> emu: Of course the _strings_ aren't the same. 
20:19:50 <Smerdyakov> Duh, emu.
20:19:53 <emu> Prelude> "f (1)" == "f 1"
20:19:54 <Smerdyakov> Stop being an iiiiidiot.
20:19:56 <emu> oops
20:19:59 <emu> 23:19 < emu> what a strange string equivalence
20:20:00 <kawfee> so could someone tell me where I am going wrong?
20:20:07 <kawfee> emu: chicken!~
20:20:19 <emu> I was just punning you guys
20:20:44 <kawfee> heh
20:20:49 <kawfee> emu is a trouble maker by nature
20:21:07 <emu> yup
20:21:09 <emu> i'm a rebel
20:21:16 <kawfee> I think it's the fact that he has a long neck and legs and can't fly
20:21:22 <kawfee> rebel without a cause
20:21:27 <emu> cliche
20:21:33 <kawfee> click!
20:21:46 <emu> continue your studies, kawfee 
20:21:51 <kawfee> I'm trying to
20:21:55 <kawfee> thanks for interrupting
20:22:06 <kawfee> I'm still confused though
20:22:30 <kawfee> let f x y = if x > 0 then x else x*y in f(3+7) (f 8 4)
20:22:49 <engstad> Why are you confused?
20:22:59 <kawfee> if f(3+7) > 0 then f(3+7) else f(3+7)*(f 8 4)
20:22:59 <Smerdyakov> Maybe if you just bloody compiled it into abstract syntax, the world would be a better place.
20:23:08 <kawfee> isn't that what it would  be?
20:23:23 <engstad> How did you bring the f in there!! 
20:23:25 <kawfee> like an abstract syntax tree>
20:23:27 <Smerdyakov> Why are you making the function variable being called part of the parameter?!
20:23:28 <engstad> Jeez.
20:23:31 <kawfee> hrm
20:23:36 <kawfee> it found it's way in...
20:23:44 <engstad> Why??
20:23:44 <kawfee> so I can't substitute funcitons?
20:23:47 <kawfee> no one told me that
20:23:54 <Smerdyakov> kawfee
20:23:57 <kawfee> Smerdyakov
20:24:04 <Smerdyakov> Look at the expression f(3+7) (f 8 4)
20:24:07 <Smerdyakov> What does it mean?
20:24:10 <kawfee> ok
20:24:19 <kawfee> it means oh...
20:24:23 * emu wonders what the difficulty is
20:24:27 <kawfee> oh my gosh
20:24:30 <kawfee> I can't believe I did that
20:24:36 <Smerdyakov> Well, I can.
20:24:37 <kawfee> you know I solved the one for innermost
20:24:38 <Smerdyakov> Since you're in #lisp.
20:24:41 <kawfee> shhh
20:24:46 <kawfee> I just sit in there and watch
20:24:49 <Smerdyakov> Whatever
20:24:56 <Smerdyakov> You serve them grapes
20:25:00 <Smerdyakov> Tons and tons of grapes
20:25:01 <emu> it's yummy
20:25:01 <kawfee> which ones?
20:25:05 <kawfee> I like grapes
20:25:10 <kawfee> they give you diabetes
20:25:14 <Smerdyakov> You stuff grapes into Zhivago's ORIFICES
20:25:36 <engstad> So, what's the answer so I can leave for today?
20:25:39 <kawfee> ok ok
20:25:42 <kawfee> I have it!
20:26:10 <kawfee> if (3+7) > 0 then (3+7)  else (3+7) * (f 8 4)
20:26:24 <engstad> Wow... Go on.
20:26:31 <kawfee> if 10 > 0 then (3+7)  else (3+7) * (f 8 4)
20:26:38 <emu> let's see if he can do the multiplication in his head
20:26:39 <kawfee> if 10 > 0 then 10  else (3+7) * (f 8 4)
20:26:42 <kawfee> 10
20:26:52 <kawfee> wait
20:26:52 <Smerdyakov> Skippppper
20:26:57 <Smerdyakov> Skiiiiiiiiippppppppppppper
20:27:02 <kawfee> if True then (3+7)  else (3+7) * (f 8 4)
20:27:03 <kawfee> I saw it
20:27:04 <engstad> Yihaaa!
20:27:07 <emu> Yes, private?
20:27:12 <kawfee> if True then 10  else (3+7) * (f 8 4)
20:27:13 <kawfee> 10
20:27:14 <kawfee> sorry
20:27:23 * Smerdyakov lines up his privates, all in a row.
20:27:37 <Smerdyakov> :) 8) 8>[ %P
20:27:41 <kawfee> waitr\
20:27:45 <engstad> Ok, so for extra credit: what's the deal about which ones you evaluate first? Why is it important?
20:27:46 <kawfee> I skipped another
20:27:49 <kawfee> if (3+7) > 0 then (3+7)  else (3+7) * (f 8 4)
20:27:56 <kawfee> if 10 > 0 then (3+7)  else (3+7) * (f 8 4)
20:27:56 <Smerdyakov> engstad, Jesus said so
20:28:01 <kawfee> if True then (3+7)  else (3+7) * (f 8 4)
20:28:06 <kawfee> 3+7
20:28:06 <kawfee> 10
20:28:08 <kawfee> like that
20:28:20 <kawfee> I think I understand it now
20:28:22 <kawfee> thanks guys
20:28:27 <kawfee> forgive my stupidity\
20:28:30 <engstad> No prob.
20:28:30 <emu> Jesus said `When evaluated, return the other argument'
20:28:38 <kawfee> too mush stress
20:28:41 <engstad> See yas.
20:28:42 <Smerdyakov> Uh oh
20:28:47 <Smerdyakov> H&SS "joke" :D :P
20:28:53 <emu> H&SS?
20:29:04 <emu> Uh oh.  "CS" "joke"
20:29:06 <Smerdyakov> emu \in Majors(H&SS)
20:29:10 <kawfee> now time for lazy eval
20:29:41 <Smerdyakov> I think the CS version of the "joke" would have to involve anime somehow :P
20:29:52 * emu ponders
20:30:04 <emu> or obscure computer references
20:30:26 <Smerdyakov> Undergraduates can be the most strangest of creatures.
20:30:57 <kawfee> wait I did that last one wrong
20:31:00 <emu> graduate students sometimes escape from their lab cages, I hear
20:31:03 <kawfee> I used lazy eval on it
20:31:18 <kawfee> I hear emu's are eaten 
20:31:21 <kawfee> I hear emus are eaten 
20:36:13 <Smerdyakov> Does anyone know where to find anarchist type IRC channels of High Quality??
20:39:17 <Smerdyakov> Reply timeout
20:40:44 <kawfee> heh
20:40:50 <kawfee> #anarchist ?
20:41:09 <kawfee> you could probably find them in some anarchist type net
20:43:50 <kawfee> anyone know how you can find out if an expression is evaluated?, I want to test the strictness of the || and it's operators
20:44:02 <kawfee> so I am doing something like (1 <2) || True
20:44:15 <kawfee> so I am doing something like True || (1<2)
20:44:21 <kawfee> and then changing True to False
21:41:42 <kawfee> anyone?
21:42:09 <kawfee> (if (1 < 2) True else False ) || False
21:42:15 <kawfee> I was thinking of something like that as well
21:42:30 <kawfee> but I don't know wheater it evaluates
21:45:29 <kawfee>  True || let x = False in error "error" 
21:45:33 <kawfee> nm, I got it to work
21:45:49 <kawfee> that worked nicely
21:46:06 <emu> you're welcome
21:46:12 <kawfee> heh
21:46:27 <kawfee> if I could only get my hands on you I'd cook you like a chicken
21:46:50 <emu> hot boiling kawfee?
21:48:11 <kawfee> yeah
21:49:33 <kawfee> would you like some cream while you are cooking?
22:40:42 <kawfee> this channel is about as dead as #lisp on efnet
22:47:07 <Logan> Smerdyakov: I'm an anarchist.  What sort of anarchism are you looking for?
