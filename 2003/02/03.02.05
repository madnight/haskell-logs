01:05:15 <mgoetze> hi Marvin-- 
01:10:15 <Marvin--> morning
01:10:38 <mgoetze> how's things?
01:11:21 <Marvin--> way tired, didn't sleep well
01:11:33 <Marvin--> and it seems that going up an hour later didn't help
01:12:00 <mgoetze> no, it usually doesn't ;)
01:13:13 * Marvin-- grumbles
01:13:58 * mgoetze gives Marvin-- some hot chocolate with cream.
01:15:04 <Marvin--> I'm drinking tea, thank you :)
01:16:17 * mgoetze is drinking coke. :)
01:17:07 <Marvin--> heehee, we're going to buy lots and lots of cards today
01:17:09 * Marvin-- happy
01:17:34 <mgoetze> cards? you mean, like, ibm punch cards? :)
01:17:48 <Marvin--> no, as in Game of Thrones CCG cards
01:17:54 <Marvin--> four of us are going to split a box
01:18:06 <Marvin--> http://www.cardcollector.nu/ccg_rpg/got/got_box.asp
01:19:33 <mgoetze> oh... is that a new wotc invention? :)
01:19:40 <Marvin--> wotc?
01:19:45 <Marvin--> oh, wizards
01:19:45 <mgoetze> wizards of the coast
01:20:01 <Marvin--> no, it's fantasy flights
01:20:28 <mgoetze> is it one of those online ccgs or is it for real?
01:21:08 <Marvin--> real cards dammit :)
01:24:43 * mgoetze gave up on CCGs some 4 years or so ago :)
01:25:17 <Marvin--> so did I, but I got better ;)
04:32:14 <dark> Hmm, terminology question: if a Markov model has order 2, does it implicitly contain order-1 and order-0 models (in order to start generating)?
04:32:24 <dark> Or would that be a collection of three models?
05:55:45 <mgoetze> dark: still got a headache? :)
06:12:26 <dark> mgoetze: No but I'm coding :)  This is a sufficiently rare event these days that I don't want to disturb it.
06:14:46 <dark> Heh, I actually have a use for "zip (inits xs) (tails xs)".  I wonder if that's slow.
06:14:51 <mgoetze> lol
06:15:20 <mgoetze> xs :: [a]?
06:15:36 <dark> Yeah.
06:16:18 <dark> Hmm, actually... I end up reversing the inits.
06:23:03 <dark> splits :: [a] -> [([a], [a])]
06:23:03 <dark> splits list = splits' [] list
06:23:03 <dark>   where
06:23:03 <dark>     splits' ctx [] = []
06:23:03 <dark>     splits' ctx l@(x:xs) = (ctx, l) : splits' (x : ctx) xs
06:23:07 <dark> I wonder if that does what I want :)
06:24:06 <dark> Hmm, splits' ctx [] = (ctx, []) at least.
06:24:42 <mgoetze> what's ctx?
06:25:27 <dark> "context" :)  It's the elements preceding x in list, reversed.
06:26:42 <dark> There's definitely a pattern here that I should be able to capture  splits' ctx l is always (ctx, l) on top of something.
06:33:05 <Marvin--> dark: sounds like a weird function to need
06:33:49 <Smerdyakov> What is @ in a pattern?
06:34:17 <Marvin--> Smerdyakov: it means that l and (x:xs) refer to the same argument
06:34:46 <Smerdyakov> OK
06:35:17 <dark> Marvin: It's for teaching Markov chains :)
06:35:51 <dark> So the list is a list of symbols, and I want to pair each symbol in the list with the context in which it could be generated.
06:36:10 <dark> ... but I just realized that (inits (reverse xs)) does that just as well :-)
06:36:38 <dark> As long as I make it implicit that the symbol under scrutiny is the head of the list.
06:37:37 <dark> So instead of [([a],[a])] I generate a much friendlier [[a]]
06:44:55 <Smerdyakov> !!!Muy frendlioso!!!
07:05:29 <Marvin--> oookay, that was a weird Simpsons ep
07:07:00 <andersca> Marvin--: it was a cool one
07:07:51 <Marvin--> oh yes
07:34:46 <shapr> here in sweden, when someone elbows you they say "orsakta" (sp?)
07:34:59 <shapr> I found out yesterday that means 'reason' or 'cause'
07:35:21 <shapr> so at first I thought that meant "I had a good reason to elbow you"
07:37:29 * shapr yodels happily
07:37:42 <shapr> hi Chilli! ltns!
07:40:40 <Marvin--> shapr: ursäkta
07:40:49 <shapr> yah, that one :-)
07:40:57 <Marvin--> shapr: "reason"/"cause" is orsak :)
07:41:09 <Marvin--> close but no cigar ;)
07:41:09 <shapr> then I realized it's a short form, originally from "no reason"
07:48:14 <shapr> well, one of the Simons (PJ?) suggested a way to do TREX-style code in GHC, so it looks like we might get HaskellDB on top of HToolkit soon
07:53:17 <SyntaxPolice> good morning.
07:53:37 <shapr> gooood morning SyntaxPolice!
07:54:03 <shapr> what's hi in the middle and round at both ends?
07:54:35 <Logan> Yer mother.
07:54:40 <shapr> hi Logan 
07:54:40 <Logan> Or Ohio.
07:54:49 <shapr> bing! you get the gold monad.
07:54:55 <shapr> er, star...
07:55:08 <shapr> we only hand out Kleene stars here of course.
07:55:12 <Logan> Haha.
07:55:51 <shapr> hi Logan, written any neat code lately?
07:56:10 <Logan> http://planetmath.org/encyclopedia/KleeneStar.html
07:56:21 <Logan> shapr: Not much, still working on http://ircquotes.com
07:58:17 <shapr> I'm discovering that reading and understanding an RFC is often the hardest part of implementing said RFC.
07:59:15 <Logan> Sometimes.
08:00:14 <shapr> some of my rfc822 fields won't accept a space between the field name and the field body
08:01:00 <Logan> rfc822 is email?
08:01:13 <shapr> yah, email headers
08:01:22 <shapr> http://kungens.kemi.fi/~shae/src/haskell/RFC822.hs
08:02:07 <Logan> What would be the type of a generic wrapN function?
08:02:35 * Igloo had great fun with RFC1951
08:02:48 * shapr looks up rfc1951
08:03:08 <Igloo> Inflate, used by gzip and OpenPGP
08:03:12 <shapr> oh!
08:03:18 <shapr> I didn't know that was an rfc
08:04:37 <shapr> Logan: good point...
08:04:42 <shapr> wrapN 0 x = [x]
08:04:42 <shapr> wrapN n x = [wrapN (n - 1) x]
08:04:59 <shapr> that seems sensible at first... 
08:05:04 <Logan> Yeah, but I doubt it'd compile.
08:05:09 <shapr> it doesn't
08:05:10 <Igloo> Not typable
08:05:29 <shapr> Would require TH 
08:07:46 * Igloo happens to notice [[[p]],[[[[":"]]]],mb,[[[[":"]]]]] in shapr's code and wonders what an Earth it's doing
08:08:05 <shapr> heheh
08:08:16 <shapr> Igloo: possibly being very silly :-)
08:08:20 <SyntaxPolice> shapr: thanks for the Ohio joke, there are far too few of these ;)
08:08:36 <shapr> SyntaxPolice: I suspect I heard sarcasm in there ;-)
08:08:47 <SyntaxPolice> but we did win the championship in college football!
08:08:51 <Igloo> It may well be sensible, but it looks very peculiar!
08:08:54 <shapr> Igloo: thing is, I started out just returning the parsed apart bits 
08:09:03 <SyntaxPolice> shapr: no actually, I can't really think of any other Ohio jokes...
08:09:30 * Igloo wonders what the type of group is
08:09:30 <shapr> Igloo: as the list depth increases, I begin to wonder if I should have gone ahead and decided on complex datatype structures so I wouldn't have to worry about matching the list depths
08:10:23 <shapr> everytime I get frustrated with the billions of lists I think "I'll just wait till it parses correctly, and then construct the types"
08:11:09 <Igloo> The way I'd do it (probably) is to start with a subset of the final datatypes and make a parser for that, then extend the types and parser until it was done
08:11:30 <Igloo> I don't really see what you're doing, but suspect that datatypes are teh way forward  :-)
08:11:35 <shapr> truly
08:12:57 <Igloo> I think ":" might either want to be not there or Colon where data Somethings = Colon | ..., depending on what you do with it later
08:14:50 <shapr> I think it doesn't want to be there
08:16:20 * Igloo decides to polish off inflate while waiting for Chilli to wake up
08:17:23 <Igloo> Oh yes, I was going to profile it
08:25:09 <SyntaxPolice> shapr: I'm grabbing a semiphore on the library CGI :)
08:25:33 <shapr> right
08:25:40 <shapr> want me to tar up what I have and send it to you?
08:27:57 <SyntaxPolice> shapr: have you changed anything?
08:28:16 <SyntaxPolice> or send me a patch
08:28:25 <SyntaxPolice> do you have access to cvs.haskell.org?
08:29:07 <shapr> no, I do not.
08:31:07 <shapr> yes, I have changed a few things
08:31:17 <shapr> probably not enough to make it worth sending a patch
08:32:14 <SyntaxPolice> shapr: I may have a machine we could put a cvs repo on if you want
08:32:32 <shapr> we could use haskell-libs on sf.net if that's easier/better
08:33:12 <SyntaxPolice> hmm... sf... never used it. that might be a good idea. we could make it a sort of home for the meta project of cleaning up haskell libraries in general.
08:33:19 <SyntaxPolice> unless there is such a home already
08:33:57 <shapr> I'd like to make haskell-libs open to any #haskell developers who want to stick Haskell code up there and share it, for whatever reason or purpose.
08:34:40 * Igloo should look into seeing if any of my stuff could fit in a larger archive somewhere
08:35:23 <shapr> Igloo: do you have a userid on sf.net?
08:35:39 <norpan> yes, use sourceforge
08:35:40 <shapr> SyntaxPolice: do you?
08:35:55 <Igloo> Probably
08:35:59 <SyntaxPolice> yeah, we coudl try to impose some kind of organization... portable libraries, non portable, etc. This should be pretty portable AFAIK
08:36:01 * shapr grins
08:36:04 <SyntaxPolice> shapr: no dont' have an account.
08:36:13 <Igloo> I still have a project there AFAIK, but they took so long setting it up I'd lost momentum by the time they did so
08:36:33 <SyntaxPolice> Igloo: oh really? So we can't just create the repo right now?
08:37:04 <dark> shapr: Maybe check out some of the alternatives to sourceforge?  Or run a haskell-specific one?
08:37:20 <dark> shapr: There's a Debian package for it.
08:37:22 <Igloo> It takes a day or so to create it, I think, but something went wrong with some feature in mine and they took ages to fix it
08:37:46 <shapr> dark: sounds tempting, but I don't really want to run a repo, just use one.
08:37:58 <SyntaxPolice> can you create categories on sourceforge? LIke the Haskell category?
08:38:04 <shapr> I created the sf.net/projects/haskell-libs in january 2001
08:38:05 <dark> shapr: I think at least Debian and the FSF run alternatives.  
08:38:17 <shapr> not that anything has happened there
08:38:21 * SyntaxPolice bounces, shapr like, with anticipation.
08:38:27 <shapr> yay!
08:38:29 <shapr> bouncing!
08:38:36 <Marvin--> what fun things are you talking about now?
08:38:52 <shapr> there isn't a Haskell Language category, but I suspect there could be with some prodding
08:38:57 <SyntaxPolice> Marvin--: we're going to start a huge flamewar and use sourceforge.net to keep it ina  cvs repository.
08:39:02 <shapr> yah!
08:39:18 <shapr> so we need flamewar generating software, since perl and python are running out of steam.
08:39:23 <Marvin--> SyntaxPolice: yay!
08:39:34 <SyntaxPolice> Marvin--: actually me & shapr are working on a CGI for trakcing haskell libraries and we need a place where both of us can get at it.
08:39:36 <Igloo> Do you know how this is going to fit in with the heirarchial library stuff?
08:39:55 * SyntaxPolice notes that simple idea is quickly spirling out of control.
08:39:59 <shapr> I'm thinking of a wiki-style cvs repo, where you can just show up and drop stuff in
08:40:20 <shapr> SyntaxPolice: quick! get an sf.net userid
08:40:25 <SyntaxPolice> ok
08:40:27 <shapr> I'll add you to haskell-libs as a developer
08:40:59 <SyntaxPolice> but
08:41:03 <shapr> uh oh..
08:41:08 <shapr> :-)
08:41:10 <shapr> yes?
08:41:12 <SyntaxPolice> maybe the debian one or FSF one would be better?
08:41:16 <SyntaxPolice> I don't know anything about this :)
08:41:26 <shapr> the advantage of haskell-libs is that it already exists.
08:41:30 <SyntaxPolice> oh
08:41:35 <SyntaxPolice> since when?
08:41:39 <shapr> http://sourceforge.net/projects/haskell-libs/
08:41:46 <shapr> january 2001, when I created it.
08:42:23 <shapr> if you don't like using sf.net, or wish to switch to another site, that's fine by me
08:42:25 <SyntaxPolice> heh, didn't realize this had been on your midn that long
08:42:32 * SyntaxPolice gets sf user id
08:42:58 <shapr> yah, this has been on my mind that long, but up until recently my haskillz have been too small to make anything happen by myself.
08:44:03 * Marvin-- has a sf.net userid too *hint hint* ;)
08:44:08 <shapr> Marvin--: what is it?
08:44:31 <Marvin--> shapr: msjogren
08:45:46 * shapr adds msjogren as a developer
08:46:05 <shapr> ok, you're added.
08:46:55 <Marvin--> yay
08:47:01 <shapr> the cvs repo is effectively empty, feel free to stick code in there that you might want others to see or work on.
08:48:06 <SyntaxPolice> shapr: looks like I'll be ijones.
08:48:19 <SyntaxPolice> shapr: go ahead and add the cgi code if you want.
08:48:39 <Igloo> Can anyone explain this (in a Makefile)?
08:48:39 <Igloo> `which ghc` --version
08:48:40 <Igloo> The Glorious Glasgow Haskell Compilation System, version 5.05
08:48:40 <Igloo> ghc --version
08:48:40 <Igloo> The Glorious Glasgow Haskell Compilation System, version 5.02.2
08:49:08 <shapr> SyntaxPolice: ok
08:49:36 <SyntaxPolice> shapr: OK I exist.
08:49:49 <SyntaxPolice> Igloo: what shell are you using?
08:49:52 <SyntaxPolice> type ghc
08:49:53 <SyntaxPolice> which ghc
08:49:59 <SyntaxPolice> which isn't always right.
08:50:15 <Igloo> make uses sh doesn't it?
08:50:36 <dark> On Debian, which is some horrendous shellscript.
08:50:36 <shapr> SyntaxPolice: ok, you are added
08:50:56 <dark> Igloo: make might be going through shell if it sees metacharacters like `, and execing directly if it doesn't.
08:51:15 <dark> Igloo: So, if you have PATH initialization code in weird places, it might interfere.
08:51:27 <Igloo> I have no such wierdness
08:51:32 <SyntaxPolice> Igloo: on linux also sh is bash, I believe.
08:51:53 <dark> SyntaxPolice: Yes but bash behaves differently when executed as sh :)
08:51:55 <SyntaxPolice> Igloo: if you have aliases or the thing is hashed, which mightb ewrong.  see what 'type ghc' tells you.
08:52:03 <SyntaxPolice> dark: really? Wow.
08:52:04 <Igloo> But I've just realised this is an old versino of make, and I think I've seen make stopping being too clever for its on good on upgrades in the past now I think about it
08:52:06 <SyntaxPolice> shapr: thanks.
08:52:51 <Marvin--> http://www.idleworm.com/nws/2002/11/iraq2.shtml <- very ambitious flash thingy!
08:53:10 <dark> The combination "flash" and "worm" made me expect Bad Things :)
08:53:39 <SyntaxPolice> dark: but I note that iraq doesn't bother you ;)
08:53:40 * shapr grins
08:55:17 <dark> SyntaxPolice: Iraq has been there a long time, it hasn't moved as far as I know :)
08:55:42 <dark> Anyway, "flash worm" is explained in http://www.silicondefense.com/flash/
08:55:47 <dark> 0wn the net in 30 seconds.
08:57:29 <SyntaxPolice> heh
08:58:44 <shapr> Marvin--, SyntaxPolice: you may want to upload your ssh public key(s) so that you don't have to login everytime you use CVS to do something
08:58:48 <dark> "We have run out of hyberbolic adjectives to describe how seriously vulnerable the Internet is to security disruptions, so we won't comment further on the social implications of this."
08:59:04 <shapr> dark: do you have a userid on sf.net?
08:59:21 <Smerdyakov> It's only vulnerable if people run Microsoft software!
08:59:22 <SyntaxPolice> shapr: what do you think about organizing this repository... once we have a Sane Build System we can try to force library authors to use that...
08:59:31 <SyntaxPolice> or fptools
08:59:44 <SyntaxPolice> we could organize it by compatability
08:59:52 <SyntaxPolice> ghc, nhc, hugs, portable, etc.
09:00:39 <shapr> SyntaxPolice: I think it's best to go wiki-style at first... just get some code in, then we can reorganize later.
09:00:58 <Igloo> I think it should be organised in the same way as the HL, with multiple implementations at the leaves, e.g. haskell98/, ffi/, ghc/
09:01:14 <Igloo> (ffi/ being for interfaces to implementations in other languages)
09:01:31 <Igloo> And a default/ symlink to "the best"
09:01:55 <Igloo> But that would need a tweak to all the implementations to work nicely
09:02:10 <dark> shapr: No.  I'm not sure I want one :)
09:02:39 <shapr> dark: ok, bug me if you change your mind... I'd love to play with dev versions of uncc and haSDL :-)
09:02:56 <dark> shapr: I'll set up a proper homepage at some point :)
09:02:57 <Igloo> What's uncc?
09:03:26 <shapr> just what it sounds like :-)
09:03:29 <dark> Right now I'm working on eviltwin, a haskell version of (and perhaps improvement on) megahal.
09:03:39 <shapr> dark: oh, are you going to plug it into lambdabot?
09:03:54 <dark> shapr: Yeah, that's my intent.
09:03:57 <shapr> neato!
09:04:10 <shapr> I need to run a lambdabot from somewhere
09:04:21 <shapr> I'll be putting lambdabot into haskell-libs cvs as well
09:04:21 <Smerdyakov> Why
09:04:23 <Smerdyakov> ?
09:04:27 <dark> I'm even thinking of specializing it a bit for irc, so that it knows that "foo:" is probably a reply to something foo said.
09:04:31 <shapr> cuz it's a fun project to hack on
09:04:47 <Smerdyakov> That's why you "need" to run it?
09:04:53 <shapr> yes
09:05:01 <shapr> increased motivation = better code
09:05:15 <dark> Igloo: uncc is my uncompiler.  It'll go from machine code to C.
09:05:15 <shapr> or at least more code
09:05:26 <dark> And... more code is better code!
09:05:32 <shapr> dark: so, when do you releas unghc? =)
09:06:03 <dark> shapr: I'll wait for someone else to write a C to GHC unghc, and then bolt them together :)
09:06:09 * shapr snickers
09:07:34 <Igloo> Cool
09:09:35 <dark> unghc --pointless
09:09:57 <Igloo> :-)
09:11:36 <SyntaxPolice> shapr: what do you think about putting the numeric-quest libraries on the sf repo?
09:12:37 <Marvin--> dark: does that generate pointless^H^H^H^Hfree code?
09:13:37 <dark> Marvin: That's the point.
09:13:46 <Marvin--> yay
09:14:17 <Marvin--> "pointless programming - taking obscurity to new heights"
09:39:06 <shapr> SyntaxPolice: good idea!
09:39:45 <shapr> I've wanted a full copy of those libs, I got part of them from the wayback machine
09:42:26 <SyntaxPolice> shapr: I'm working on recovering everything fromt he wayback machine... not sure about the license on them, though.
09:43:04 <shapr> good point, I wonder if the author, jan zawinski(sp?) has an email address.
09:57:55 * Igloo gets laziness headaches
09:58:54 <radix> Igloo: whoah, is _that_ how I've been getting these headaches recently?
09:59:10 <radix> I'd never thought of that.
09:59:29 <liiwi> raydex got haskelled
10:00:19 <Smerdyakov> If you get headaches, it's probably because you're a student or you have a job.
10:00:44 <hdaume> hi all
10:03:08 <Smerdyakov> Hm.... this isi.edu looks like an odd place for a Haskeller =)
10:06:42 <Igloo> head $ fromM (do x <- foo; y <- bar; return (x ++ y))    shouldn't evaluate bar if x /= [] should it?
10:07:46 <shapr> hi hal
10:08:48 <hdaume> Smerdyakov: it is ;)
10:09:12 <hdaume> Igloo: what is fromM?
10:09:47 <hdaume> Igloo: it depends on whether the monad you're in is strict or not.  if it's strict, it will evaluate bar; if it's not, it won't (i think)
10:10:24 <Igloo> fromM takes the value out of something that is essentially (I think) a state monad
10:10:29 <hdaume> Smerdyakov: but i was at one point a CMUer too :)
10:10:48 <Smerdyakov> hdaume, ah. What happened? ;-)
10:11:00 <Igloo> hdaume: Do you know how to tell if a monad is strict?
10:11:08 <shapr> see if it has a ruler?
10:11:18 <hdaume> Smerdyakov: i graduated :)
10:11:20 <Igloo> I mean by looking at the source rather than trying it
10:11:22 <hdaume> Igloo: should be in the documentation
10:11:31 <Igloo> I wrote it myself  :-)
10:11:35 <hdaume> Igloo: does it use "let" or "case"?  :)
10:11:40 <Smerdyakov> hdaume, are you a student or employee of ISI?
10:11:47 <hdaume> Smerdyakov: student
10:11:57 <Smerdyakov> hdaume, what's your area?
10:12:03 <hdaume> Smerdyakov: natural language processing
10:12:09 <Igloo> Ah, you mean in the definition of (>>=)?
10:12:13 <hdaume> Igloo: yah
10:12:16 <Smerdyakov> I guess you didn't get bitten by the PL bug at CMU?
10:12:23 <Igloo> case, so it'll be strict. Thanks!
10:12:30 <hdaume> Smerdyakov: well, I *am* in #haskell :)
10:12:45 <Smerdyakov> But you're not doing research in it :P
10:13:01 <hdaume> no, not really
10:14:51 <hdaume> Smerdyakov: i would say that PL stuff is my secondary interest
10:15:19 <Smerdyakov> Bah
10:15:26 <esap> ooh google gives nice references on the word 'monad': http://www.newadvent.org/cathen/10447b.htm
10:17:35 * Igloo gets a prettier, and slightly better, profile
10:22:35 <dark> Heh, I named one of my types "Map" and I keep wanting to call parameters of that type "map".
10:22:48 <hdaume> dark: i've done that :)
10:23:27 <Igloo> I do it all the time with exp, which isn't a problem execept for -Wall warnings
10:24:39 * esap does it all the time with 'id'.
10:25:16 <dark> import Prelude hiding (map);
10:25:53 <esap> that's too dangerous, map is way too common.
10:26:27 <dark> Yeah, I settled on calling my maps "mmap" :)
10:27:11 <hdaume> does anyone know if you can use IO exception handline when in a monad of the form 'StateT IO s a'?
10:44:17 <shapr> ok, haskellLibTracker and lambda bot are both in haskell-libs cvs
10:44:48 <shapr> SyntaxPolice: you should be able to check out the tree
10:45:36 <shapr> maybe I should make a cute front page.
10:47:54 <Igloo> Anyone happen to know what a closure type of Inflate.sat_s2KV means (or rather how I can map it back to the source name)
10:49:00 <esap> why would you need to know that? [no I don't know]
10:50:12 <shapr> Igloo: maybe if you run it out as external Core you'll find that name?
10:50:13 <Igloo> Because profiling says it's what's taking up linear (with time) space 
10:51:36 <Igloo> Cunning plan shapr, ta
10:53:06 <shapr> can you combine ext-core and profiling?
10:53:53 <hdaume> shapr: i don't see why not
10:54:03 <hdaume> shapr: scc info just comes out as annotations in Core
10:54:53 <Igloo> Neither sat nor s2KV appears in Foo.hcr though  :-(
10:55:26 <shapr> Igloo: if you combine profiling and ext-core, does that expensive thing have a different name that does show up in the ext-core source?
10:56:39 <shapr> oh, someone posted to ghc-users today about how to explicitly make something be a 'cost centre' and how he wanted that to be simpler, even automatic if possible.
10:58:31 <Igloo> Damn, got to go out - I'll prod this more when I get back - thanks for your suggestions
10:58:42 <shapr> maybe move where functions to top-level functions?
10:58:48 <shapr> I think that might do it..
10:58:50 <shapr> have fun
11:05:26 <dark> shapr: Isn't it automatic already?
11:06:06 <shapr> I don't know.
11:06:34 <shapr> oh, this guy was asking about profiling how prelude functions are used in his lib, so he was making top level aliases in his own module.
11:06:40 <shapr> that's why I was thinking of that
11:06:47 <shapr> may not be related at all
11:08:16 * dark painfully learns the difference between "inits" and "tails".
11:08:30 <shapr> :)
11:35:58 <SyntaxPolice> shapr: what is the cvsroot for our repo?
11:38:16 <shapr> export CVS_RSH=ssh
11:38:16 <shapr> cvs -z3 -d:ext:ijones@cvs.sourceforge.net:/cvsroot/haskell-libs co libs
11:38:22 <shapr> that'll get you the whole thing
11:39:17 <shapr> you can upload your public key on your user page, then you don't have to login for every cvs transaction
11:39:35 <SyntaxPolice> thankya much.
11:39:41 <SyntaxPolice> yeah I'll get around to that :)
12:07:29 <SyntaxPolice> shapr: adding a simple install.sh to the libraries thing, since I can never remember where to put things.
12:27:15 <camold> I'm going to bed ! cu all and good night !!!
12:27:20 <shapr> good night
12:34:50 <SyntaxPolice> shapr: want to make a page on the sourceforge thing about how to add libraries to the sourceforge thing?
12:34:51 <SyntaxPolice>  :)
12:39:34 * SyntaxPolice checks-in
12:40:27 <SyntaxPolice> shapr: did you touch any of the "awaiting approval" stuff?
12:40:48 <shapr> hm, lemme look
12:41:19 <dark> My Markov model learned from ["how", "now", "brown", "cow"] :)
12:41:39 <shapr> I hacked on the makeStaticPage script, but I think that's the only part.
12:42:22 <SyntaxPolice> shapr: OK :)
12:57:34 <shapr> SyntaxPolice: you mean a webpage describing the process of creating a new dir in the cvs tree?
12:58:04 <SyntaxPolice> no, just a thing like who to contact about adding your project to the cvs tree, assuming that you know nothing about the haskell-libs project.
12:58:16 <SyntaxPolice> the idea is to make a link from the forms page inviting people to add their libraries.
13:13:35 <dark> Madkiss: Cutting :)
13:14:18 <dark> Hmm, I wonder what the license is on the haskell irc logs.
13:14:29 <dark> They'd make an ideal learning set for eviltwin :)
13:20:15 <shapr> oh, I have a freenode question, do we need admin permission to run a bot?
13:20:29 <radix> no
13:20:32 <shapr> ok
13:20:34 <shapr> hi Radek
13:20:37 <shapr> er, radix 
13:20:43 <radix> not usually, anyway
13:20:47 <radix> #python and #Twisted never got permission, afaik
13:23:35 <dark> we need channel founder permission, I guess :)
13:23:41 <dark> But now I have to go read to my girl.
13:24:02 <radix> oh, shapr's founder?
13:24:20 <radix> wow, "Successor: Heffalump"
13:24:22 <radix> that's interesting :)
13:24:27 <dark> I don't think shapr has a founder.
13:24:39 <radix> >chanserv< info #haskell
13:24:41 <radix> -ChanServ-      Channel: #haskell
13:24:41 <radix> -ChanServ-      Founder: shapr, last seen: 1 week (7h 33m 30s) ago
13:24:54 <radix> or were you making a bad joke about English ambiguity? ;-)
13:25:08 <dark> radix: The latter :)
13:25:12 <radix> heh heh
13:25:28 <dark> freenode admins might get unhappy if a bot causes trouble, like excessive bandwidth usage.
13:25:36 <radix> well
13:25:48 <radix> we run a pretty hefty bot in #python, and never had trouble
13:25:50 <dark> Though I guess it'll get rate-limited like any other client...
13:25:51 <radix> lilo even knows about it
13:26:01 <radix> (it's a bridge-bot to other networks)
13:26:01 <dark> radix: lilo knowing about it probably makes it better, not worse :)
13:26:12 <radix> well, we didn't explicitly tell him
13:26:19 <radix> but he joins #python sometimes
13:26:34 <radix> and he never showed annoyance
13:29:59 <SyntaxPolice> shapr: I added a little bit of category support. Still working on it.
13:37:54 <shapr> radix: surprised by the founder and successor settings?
13:38:20 <radix> well, I never knew about "Successor"
13:38:24 <radix> it's an interesting feature
13:38:33 <shapr> just in case I get run over by a bus, etc
13:42:25 <SyntaxPolice> shapr: no bouncing in front of busses.
13:42:32 <shapr> heheh
13:42:36 <shapr> I surely hope not :-)
13:44:55 <shapr> SyntaxPolice: I'd like to skip the approval process, just generate the page from awaitingApproval.txt
13:45:02 <shapr> what do you think?
13:46:15 <SyntaxPolice> shapr: its probably a good idea... I guess that I'm a little worried about security issues that I haven't thought much about.
13:56:37 <shapr> if we have some way to edit or delete records, we can get rid of crap if it gets put in
13:56:42 <shapr> or edit records with missing info
14:01:33 <SyntaxPolice> shapr: you are probably right that this is the way to go, but let me think about it a little first.
14:02:03 <whee> how about requiring moderation before something gets officially added?
14:02:12 <whee> just a quick list of checkboxes to go through
14:03:03 <shapr> whee: would you like to implement that? ;-)
14:03:20 <whee> shapr: it's not that hard for me :)
14:03:29 <whee> I don't know about whatever code you're working with, though
14:03:41 <shapr> it's in the haskell-libs cvs repo
14:04:07 <whee> I wouldn't attempt doing something like this in haskell :)
14:05:23 <SyntaxPolice> whee: I don't understand your suggestion.  Who would check the boxes, and what would they say?
14:05:46 <whee> this is for that project listing, right? :)
14:05:59 <shapr> yup
14:06:41 <whee> well someone would submit something and it just wouldn't make the main database until someone verifies the entries
14:07:06 <whee> could do a quick web interface to verification
14:08:07 <whee> hell you could cut off lazy spammers by partially checking entered urls
14:08:25 <whee> like the page at the location they enter probably will contain the project name in some form
14:11:45 <SyntaxPolice> whee: shapr's contention is that we should let it be freeform unless / until someone does something bad.
14:11:58 <shapr> yay, the ICFP and Haskell Workshop are mentioned on haskell.org frontpage now.
14:12:08 <shapr> I'm a great fan of YAGNI
14:13:33 <whee> SyntaxPolice: that's just asking for something to go bad, though
14:13:43 <shapr> not necessarily
14:13:50 <shapr> look at comp.lang.functional
14:13:58 <shapr> anyone can post articles there, but how many are totally off-topic
14:13:59 <shapr> ?
14:14:04 <shapr> same for the wikis
14:14:10 <shapr> easy to destroy, but rarely damaged.
14:14:17 <whee> it only takes one bored idiot to screw up the entire thing
14:14:42 <shapr> in which case we restore the backups and add an approval process
14:14:44 <shapr> :-)
14:14:48 <whee> heh
14:15:03 <radix> right, but just look at what happens in actuall deployments of community stuff like that
14:15:04 <shapr> most bored idiots wouldn't go to a Haskell Library input form and add crap for very long
14:15:14 <radix> arguments against community-editable content are mostly unfounded
14:16:12 <shapr> SyntaxPolice: if you think we should keep the approval process, I won't be upset :-)
14:16:57 <SyntaxPolice> shapr: no, I'm definitely leaning toward wiki-style on this... more than screwing up the database, I'm scared of someone hacking the hosting box.
14:17:06 <SyntaxPolice> which is why I want to think about it.
14:17:13 <SyntaxPolice> s/hacking/cracking :)
14:17:32 <shapr> if they figure out how to hack their way in through hugs we should probably recruit them to work on haskell-libs
14:17:47 <radix> hugs?
14:17:54 <shapr> haskell interpreter
14:17:57 <radix> hmm, interesting type of social engineering there
14:17:59 <radix> oh :D
14:18:04 <shapr> it's our cgi engine
14:18:22 <radix> CGI??
14:18:26 <shapr> yah
14:18:32 <radix> argh :)
14:18:32 <whee> heh
14:18:37 * shapr grins
14:18:41 <radix> don't you have a Haskell web app server to run that stuff on? :)
14:18:45 <shapr> yah we do
14:19:00 <eivuokko> Ha
14:19:02 <shapr> but, this is existing code we were retrofitting
14:19:36 <shapr> good code is working code.
14:21:28 <SyntaxPolice> speaking of working code, I added more support for categories and the output page looks like this: http://www.syntaxpolice.org/~ijones/tmp/HaskellLibTracker.html
14:21:33 <SyntaxPolice> (don't complain that its ugly yet)
14:22:21 <shapr> nice :-)
14:23:50 <shapr> Igloo: I think you're right, next time I'll start with a subset of types and parser, and extend from there. thanks for the advice.
14:24:03 * Marvin-- is back
14:24:08 <shapr> I like the categories support
14:27:57 <shapr> SyntaxPolice: haha, I like the "if not, why not?"
14:31:00 <Marvin--> SyntaxPolice: I get a 'Context-type: text/html' on top of that page, do you have a newline too much somewhere?
14:31:01 <SyntaxPolice> hehe.
14:31:37 <SyntaxPolice> Marvin--: yeah, I get that too.  I vaguely seem to remember removing it once... but I'm not too worried about it yet. I'd like that entire output page to be redone in some pretty way.
14:31:49 <Marvin--> pretty schmetty
14:57:11 <shapr> hi Pseudonym!
14:57:37 <shapr> Pseudonym: is it okay with you if I put lambda bot into sf.net/projects/haskell-libs cvs tree?
15:23:50 <Pseudonym> G'day.
15:23:54 <Pseudonym> Absolutely.  Go for it.
15:24:08 <Pseudonym> It's MIT licenced.  You can do what you want with it so long as you don't remove the copyright message.
15:24:59 <Pseudonym> I think you'll want to split it into an IRC library and an IRC bot system.
15:26:02 <Pseudonym> Did I just start a flamewar?
15:27:02 <shapr> er, where?
15:27:12 <Pseudonym> On haskell-cafe.  Over separate compilation.
15:27:57 <Pseudonym> I guess it doesn't count as a flamewar yet.
15:38:58 * shapr finds a cute quote on c.l.f
15:39:03 <shapr> No problem - you again made me think about where/let - where you 
15:39:03 <shapr> had written "let f = foo in bar", I had written "bar where f = foo".
15:39:03 <shapr> I should look again into where to use which.
15:39:18 <shapr> I get a kick out of that last line :-)
15:39:35 <Pseudonym> :-)
15:40:07 <shapr> oh Pseudonym!
15:40:10 <shapr> I had an epiphany!
15:40:17 <Pseudonym> Oh?
15:40:28 <shapr> yah, flippo pasted a link to a smalltalk article about dynamic typing
15:40:31 * Pseudonym notices the beams of light surrounding shapr
15:40:35 <Pseudonym> OK.
15:40:35 <shapr> =)
15:40:51 <shapr> the article lists the failings of static typing from the viewpoint of this guy
15:41:19 * Pseudonym nods
15:41:28 <shapr> it took me a little while to work it out, but I think Haskell covers all of the good points of dynamic typing just as well as Smalltalk or Python
15:41:37 <Pseudonym> Interesting.
15:41:48 <shapr> mostly from the combination of type inferencing, and typeclasses
15:41:59 <Pseudonym> I find a lot of the supposed arguments against static typing, from Smalltalk or Lisp people, boil down to "it doesn't solve every problem".
15:42:12 <Pseudonym> My reply: Well duh.
15:42:13 <shapr> well, that's true of any solution.
15:42:16 <shapr> yah, exactly :-)
15:42:21 <emu> uh no
15:42:24 <emu> it gets in the way ;)
15:42:33 <shapr> ah, here it is...
15:42:35 <shapr> http://www.chimu.com/publications/short/whyDynamicTyping.html
15:42:46 <emu> it gets in the way of interactivity
15:43:05 <shapr> if you scroll down to "problems with type-checking"
15:43:11 <shapr> this guy makes four points
15:43:17 <Pseudonym> I agree that dynamic typing is one appropriate way to construct programming languages.
15:43:25 <shapr> I agree also.
15:43:30 <Pseudonym> Especially languages designed for dynamic scripting environments.
15:43:31 <shapr> I even prefer dynamic typing.
15:43:38 <shapr> and yet, I prefer Haskell over Python
15:43:39 <Pseudonym> I prefer static typing.
15:43:53 <Pseudonym> Yes, it occasionally gets in the way.
15:44:04 <Pseudonym> However, I find that satisfying the compiler actually helps me find problems in my code.
15:44:28 <Smerdyakov> You could at least say something original, Pseudonym ;-P
15:44:30 <Pseudonym> Dynamic typing and large applications don't really mix, IME.
15:44:34 <emu> python isn't a very wonderful dynamically typed language
15:44:34 <Pseudonym> :-)
15:44:44 <Pseudonym> Lisp is a better example.
15:44:44 <shapr> emu: it seems so to me
15:44:50 <Pseudonym> People have written large applications in Lisp.
15:44:54 <emu> it doesn't even have a decent condition system
15:44:58 <Pseudonym> Large here means a million or more lines.
15:45:13 <shapr> I don't know if there's a million line Python system.
15:45:20 <Pseudonym> I doubt it.
15:45:31 <shapr> yah, me too
15:45:32 <Pseudonym> Python is mostly glue.
15:45:33 <Smerdyakov> Is a "condition system" something related to dynamic typing?
15:45:38 <shapr> it's good glue
15:45:41 <emu> it makes it tolerable
15:45:43 <emu> =)
15:45:47 <Pseudonym> It is good glue, yes.
15:46:30 <Pseudonym> Yes, Haskell does solve most of these concerns.
15:46:36 <shapr> so, flippo made up a term to describe something he'd noticed, he called it "narrow types"
15:46:53 <Pseudonym> In particular, one of the things I really, really like about Haskell is that it doesn't cost much in programmer time to make a new type.
15:46:59 <shapr> it's the B) part of the static typing problems in that url
15:47:18 <Pseudonym> For many types, it's a one-liner.
15:47:22 <Smerdyakov> Pseudonym, in what languages _does_ it cost much?
15:47:32 <shapr> C
15:47:33 <Pseudonym> Well it depends what you mean by "much".
15:47:33 <shapr> hah
15:47:35 <shapr> or Java
15:47:37 <Pseudonym> C, sure.
15:47:58 <emu> types which can be statically checked are a subset of possible types, too
15:47:59 <Pseudonym> In C++, for example, it costs to construct a functional.
15:48:25 <Smerdyakov> Oh, come on. Those aren't even in the arena of consideration. =)
15:48:39 <Pseudonym> Concern D) is ameliorated by decent design.
15:48:41 <shapr> I get *really* tired of explicitly declaring types in Java, when a Joe Schmoe's type inferencing system could tell what they are...
15:48:45 <Pseudonym> I don't even thing that's a real concern.
15:48:51 <emu> statically typed languages usually redefine "type" to mean "that which can be statically checked"
15:49:02 <shapr> D) is covered by typeclasses even more
15:49:09 <Pseudonym> emu: That's true up to a point.
15:49:10 <Smerdyakov> emu, no.
15:49:19 <Pseudonym> The _language_ define "type" as X.
15:49:21 <emu> oh a lot of people complain about static typing because of Java's retardedness
15:49:23 <Smerdyakov> emu, they just give a type system which can be statically checked.
15:49:28 <Smerdyakov> emu, there's a big difference.
15:49:29 <Pseudonym> Programmers, however, think in terms of types as contracts.
15:49:30 <Pseudonym> Or they should.
15:49:36 <emu> Smerdyakov: no you just restated what I said
15:49:42 <Pseudonym> Types as elements in the solution domain.
15:49:55 <Pseudonym> Hence, the abstract data type "FiniteMap" is very different from the Haskell type "FiniteMap".
15:50:05 <Smerdyakov> emu, no.
15:50:23 <shapr> in java, you have to implement a typeclass (java sez interface) at compile time of the implementing object, and inside the class itself
15:50:28 <Smerdyakov> emu, if I tell you "here's a set of integers" and they're all positive, that doesn't mean I've redefined "integer" to mean "natural number."
15:50:48 <shapr> meaning an existing class cannot be retrofitted to be an instance of an existing typeclass
15:51:07 <shapr> you have to either edit the source, or write a wrapper class that holds an instance of the earlier class inside it.
15:51:20 <Smerdyakov> shapr, you can implement type classes at runtime in Haskell?
15:51:33 * shapr thinks about that.
15:51:38 <Smerdyakov> I sure hope not.
15:51:41 <Smerdyakov> What a mess that would be.
15:51:56 <Pseudonym> Concern C) is true for languages without parametric polymorphism, but even C++ has that.
15:51:57 <emu> that's a restriction :-P
15:52:03 <shapr> that's a good question, I'll get back to with specifics.
15:52:04 <emu> Smerdyakov: not sure what you're getting at
15:52:20 <Smerdyakov> emu, I'm getting at that what you originally said is strictly wrong.... nothing more than that
15:52:30 <Pseudonym> Smerdyakov: I don't understand the question.
15:52:34 <shapr> I think C) is talking about upcasting
15:52:38 <emu> that's nice, but it doesn't really explain anything ;)
15:52:47 <shapr> where you have an array of type Object
15:52:54 <shapr> that's a major sucking point in Java
15:53:05 <Pseudonym> Do you mean can you implement type classes within the languages that is Haskell-minus-typeclasses?
15:53:12 <Pseudonym> You sure can.
15:53:19 <Pseudonym> So I suspect that's not what you meant.
15:53:20 <Smerdyakov> Pseudonym, no
15:53:31 <shapr> I think he meant, can you implement typeclasses while the RTS is running
15:53:37 <shapr> and I think I know how, but I have to check to make sure
15:53:45 <Pseudonym> Well it depends on the implementation.
15:53:49 <Smerdyakov> Pseudonym, I mean can you generate new types at runtime, and have them be type class instances.
15:54:08 <shapr> Smerdyakov: right, exactly.. I think I know how to do that.
15:54:09 <Smerdyakov> Liike...
15:54:35 <shapr> I think Andre Pang's runtime loader will let you do that.
15:54:48 <shapr> but I don't understand the type safety concerns about Dynamic, so I might be wrong.
15:54:52 <Smerdyakov> myEquality dummy = let type newGuy = NewGuy deriving Equality in NewGuy = NewGuy
15:54:56 <Pseudonym> You can, in the sense that you can write a facade around any time.
15:55:12 <Pseudonym> Sorry, around any _type_.
15:55:18 <Smerdyakov> Or something like that, with everything changed to be valid Haskell
15:55:32 <Pseudonym> Well, can you write that without the "deriving" part in valid Haskell?
15:55:51 <dark> shapr: type safety concerns about runtime loading and Dynamic?
15:55:54 <Smerdyakov> Eventually I could, but I don't want to =)
15:55:57 <Pseudonym> :-)
15:56:06 <shapr> dark: yah
15:56:07 <Smerdyakov> shapr said: <shapr> in java, you have to implement a typeclass (java sez interface) at compile time of the implementing object, and inside the class itself
15:56:20 <Smerdyakov> That's all I'm talking about. The definition that interests me is whichever one he meant.
15:56:47 <Pseudonym> shapr: The type safety concerns about Dynamic are that in Haskell, run-time type information is programmer-supplied, not automatically generated by the compiler.
15:56:52 <dark> shapr: The Dynamic type encodes type information with its value.  But that encoding is generated at compile-time.  If you dynamically load a module that was compiled separately, it's going to have different encoding rules in its Dynamic type.
15:56:57 <Pseudonym> This means the programmer can lie about RTTI.
15:57:00 <shapr> if you want to make a type an instance of a typeclass in Java, you have to have the source of that class, and you have to add the implementation into the source.
15:57:12 <Pseudonym> If the programmer can lie, the compiler can exact its revenge.
15:57:22 <shapr> heheh
15:57:24 <shapr> I like that quote.
15:57:28 <Pseudonym> I do too.
15:57:44 * emu just points at CLOS and says `can this be static?' =)
15:57:50 <shapr> I'll have to play with the Runtime loader and try to cheat...
15:57:56 <shapr> then I'll probably understand.
15:58:05 <shapr> in any case..
15:58:14 * Smerdyakov points at CLOS and says "why would I want to use this?"
15:58:25 <shapr> I can make a type from a haskell module an instance of a typeclass even if I only have the .hi and .o files.
15:58:35 <Pseudonym> Smerdyakov: I don't understand what you mean by "generating new types at runtime" in a static language.,
15:58:46 <Pseudonym> Do you mean loading them from a DSO or something?
15:58:58 <dark> What annoys me in Java is that something that's a class can never be treated as an interface.  So I can't supply my own implementations of those classes.
15:59:14 <Smerdyakov> Pseudonym, I mean a semantics that distinguishes between them at compile time, but conceptually has them "generated" at runtime.
15:59:22 <shapr> dark: truly, that does suck.
15:59:26 * Pseudonym is lost, sorry
15:59:29 <dark> And nearly every class I've seen that's used as a type should have been an interface instead :)
15:59:32 <Pseudonym> I think I need more caffeine.
15:59:33 <shapr> that's one thing I like about Haskell, it's willing to get out of your way if you wish.
15:59:35 <Pseudonym> Brain is slow today.
15:59:46 <Smerdyakov> Pseudonym, like generativity of datatypes in ML
15:59:49 <emu> Smerdyakov: well you've brainwashed yourself out of the usefulness of such a thing, so I dunno.  Much like a Visual Basic person can look at SML and say ``why would I want to use this?''
15:59:53 <Smerdyakov> Pseudonym, I don't know if Haskell has the same thing
15:59:59 <Pseudonym> Right.
16:00:11 <Pseudonym> Er...
16:00:21 <Smerdyakov> Pseudonym, again, it's _shapr's_ distinction. I'm trying to understand what it means as much as you are :P
16:00:29 <Pseudonym> CLOS :: Haskell as Haskell :: Visual Basic?
16:00:29 <dark> autocerbrohygiene is a natural part of learning new skills.
16:00:37 <Pseudonym> I can't even scan that.
16:00:44 <Pseudonym> Right. :-)
16:00:45 <emu> Pseudonym: who said that?
16:00:45 <shapr> autocerebrohygiene??
16:00:54 <dark> shapr: washing one's own brain :-)
16:00:58 <shapr> cute
16:01:45 <shapr> Smerdyakov: I mean that I can't implement an interface on a class that's in a .class file
16:01:45 <Smerdyakov> emu, if someone asks me why he would want to use ML, I have a URL for him.
16:01:51 <dark> eviltwin is chugging along at 99% cpu usage with 600 MB in use.  Maybe I should optimize it a bit :)
16:02:00 <Smerdyakov> shapr, ah
16:02:08 <Pseudonym> dark: What is it?
16:02:27 <emu> Smerdyakov: if you want reading, I can give you stuff to read ;)
16:02:38 <dark> Pseudonym: It's going to be a conversation simulator similar to megahal.
16:02:49 <Smerdyakov> Something of comparable length to my page, explaining why someone would want to use CLOS.
16:02:52 <Pseudonym> Cool.
16:02:52 <shapr> dark: let me run it on my dual Athlon 1.5GHz w/threaded RTS  ;-)
16:02:57 <Smerdyakov> (Without assuming he's using Lisp in the first place)
16:02:57 <emu> Smerdyakov: whole books
16:02:57 <dark> Pseudonym: I figured out some possible improvements on megahal's algorithm but I didn't want to hack on its rickety C code :)
16:03:09 <shapr> Smerdyakov: rahul likes it. that's enough for anyone.
16:03:20 <Pseudonym> :-)
16:03:27 <shapr> Pseudonym: do you know rahul?
16:03:31 <Pseudonym> I once tried to convert SHRDLU into common lisp.
16:03:42 <Pseudonym> I got lost somewhere deep inside the inference engine.
16:03:49 <Pseudonym> shapr: Not personally.
16:03:54 <shapr> heard of him?
16:04:03 <shapr> is he famous on the newsgroups or something?
16:04:05 <dark> Now I wish I'd given it a progress indicator.
16:04:05 <Pseudonym> Nope.
16:04:17 <Pseudonym> Who is he?
16:04:19 <Smerdyakov> rahul isn't famous.
16:04:24 <Smerdyakov> He's Some Punk Kid =D
16:04:34 <shapr> rahul has a firm belief that CL is the correct solution for any problem.
16:04:56 <shapr> I nearly kickbanned him from #emacs once for extra-firmness.
16:04:59 <radix> he's also a nutcase
16:05:02 * radix coughs.
16:05:13 <Pseudonym> I see.
16:05:25 <Pseudonym> Apparently every problem is a nail.
16:05:25 <Smerdyakov> I had a very memorable conversation with him.
16:05:48 <Smerdyakov> He told me that the HM type system was simply unacceptable for real programming.
16:05:51 <radix> does anyone know what the name of the PG article is where he talks about the fact that certain technologies/programming languages are better than others?
16:05:52 <Smerdyakov> He couldn't supply an example.
16:06:26 * Pseudonym is currently reading "Multi-Paradigm Design for C++"
16:06:31 <Smerdyakov> I pressed him, he gave some half-assed thing he hadn't been able to do in ML, I asked "have you tried using [some feature] of ML?", and he said "no"
16:06:35 <radix> Pseudonym: HURK
16:06:38 <Pseudonym> I'm becoming more and more convinced that Haskell is a multi-paradigm language in disguise.
16:06:42 <shapr> me too!
16:06:51 <Pseudonym> And it's only getting more so.
16:06:54 <shapr> yah, I agree
16:06:58 <shapr> I'm looking forward to TH
16:07:12 <radix> there's a very small number of languages that _aren't_ multi-paradigm, I think
16:07:18 <shapr> and when my haskillz reach the right level, I want to add reloading to the runtime loader.
16:07:18 <radix> brainfuck, for example
16:07:31 <Smerdyakov> shapr, do you ever discuss anything but Haskell in your leisure time?
16:07:40 <shapr> yes.
16:07:47 <radix> I can vouch for that
16:07:49 <dark> Hmm, it seemed to have slurped its input file all at once, and is now thinking hard before producing its first brain entry :)
16:07:57 <shapr> I also do contact juggling, lots of reading, metacognition, etc, etc
16:07:59 <dark> I suspect large numbers of closures.
16:08:06 <Smerdyakov> shapr, OK. You come across as totally obsessed =)
16:08:06 <Pseudonym> C isn't multi-paradigm.
16:08:09 <Pseudonym> Forth isn't.
16:08:11 * Pseudonym thinks
16:08:13 <Pseudonym> COBOL isn't.
16:08:16 <Pseudonym> Fortran isn't.
16:08:18 <shapr> Smerdyakov: d00d, you see me only on #haskell
16:08:28 <Pseudonym> All modern languages are, I think.
16:08:45 <Smerdyakov> One doesn't need multiple channels of input to perceive obsession.
16:08:45 <shapr> Smerdyakov: come visit me, I will teach you contact juggling michael moschen style...
16:08:47 <Pseudonym> I've noticed a lot of my own design flaws while reading this book.
16:09:04 <shapr> I will introduce you to Icehouse, Fluxx, Set, Go, and many other games.
16:09:11 <shapr> oh, and munchkin!
16:09:13 <dark> I notice a lot of my design flaws when I try to run soon after eating.
16:09:20 * Pseudonym laughs
16:10:14 <radix> Smerdyakov: he's not obsessed, he's just good at being passionate
16:10:21 * shapr grins
16:10:26 <dark> Ah, passion.
16:11:02 <shapr> Smerdyakov: hey, are you showing in Uppsala in August?
16:11:07 <radix> I've been trying to build up the guts to ask people I don't know "what's your passion?" when I meet them
16:11:11 <Smerdyakov> Is that ICFP?
16:11:13 <shapr> yah,
16:11:15 <shapr> it is
16:11:25 <radix> it's a much better question than "What do you do?" i think :)
16:11:43 <Smerdyakov> Well, definitely if my grad school yet-to-be-determined pays for it.... I don't know if I'll be an official student at that point =)
16:12:03 <shapr> well make sure you show up, and I'll introduce you to some of my other passions.
16:12:41 <emu> scary
16:13:00 <shapr> ?
16:13:04 <emu> ;-)
16:14:05 <dark> radix: I've always felt confined by this idea that a profession defines a person :)
16:14:16 <radix> dark: exactly
16:14:19 <dark> On the other hand, "I'm a programmer" would describe me pretty well.
16:14:33 <dark> Even when I'm not programming, I mean :)
16:14:47 <dark> I am definitely not, however, a Software Engineer.
16:14:49 <radix> asking what a person's passion is would be a much better specification of what a person is like
16:14:59 <radix> dark: woohoo
16:15:11 <radix> we must destroy that dirty word ;-)
16:15:18 <dark> At one time I considered identifying myself as a "software craftsman" :)  After all, software is built by hand.
16:15:29 * radix likes dark.
16:15:46 <dark> Later I realized that good software is grown, not built, so "software gardener" might be better.
16:15:56 <radix> o.O
16:15:58 <dark> But then people wouldn't understand :-)
16:16:02 <Pseudonym> :-)
16:16:04 <radix> yeah ;-)
16:16:14 <radix> I don't like analogies, though
16:16:20 <radix> so "gardener" is just as bad as "architect", IMO
16:16:23 <Pseudonym> I think that "software engineer" is appropriate, actually.
16:16:25 <radix> "craftsman", however, is generic
16:16:42 <Pseudonym> Building a software system (not just "a program") is much like building anything else.
16:16:45 <lament> analogies are like faucets.
16:16:46 <lament> they leak :)
16:17:05 <Pseudonym> It's at least as creative as civil engineering.
16:17:16 <Pseudonym> But then, every work of engineering has some creative aspect.
16:17:30 <Pseudonym> Someone had to design your phone and your toaster.
16:18:00 <lament> I want to be a toaster designer.
16:18:04 <emu> =)
16:18:21 * Pseudonym wants to implement it in Haskell for Toaster
16:18:23 <dark> Pseudonym: Heh, that reminds me of something my girlfriend pointed out.
16:18:38 <emu> Pseudonym: that's what design majors are for
16:18:39 <Pseudonym> OH?
16:18:41 <dark> We were in a train, and I remarked how the little hooks for the jackets were of non-useful shape and placement.
16:18:48 <dark> She said "Yeah, they're designed."
16:18:53 * Pseudonym laughs
16:19:31 <Pseudonym> Yes, industrial and graphic designers, architects, human-computer interface designers, web designers and so on do that sort of thing.
16:20:34 <lament> janitorial equipment designers suck.
16:21:49 * shapr looks for the separate compilation flamewar
16:23:04 <shapr> I've noticed that programming skills often double as "process analysis" in the 'real world'
16:23:36 <shapr> I'm used to build a connected graph of effects in my head finding the worrisome spots.
16:24:21 <Smerdyakov> Who uses you that way?
16:24:34 <dark> Hmm.  I see that as a negative personality trait in myself.  I'm always much better at spotting problems than at giving encouragement.
16:25:01 <shapr> dark: non-determinism monad can show good as well as bad.
16:25:34 <shapr> Smerdyakov: no one uses me that way, but I often spot problems in a plan or solution someone else has come up with.
16:25:56 <shapr> in the book "the pragmatic programmer" they say "give options, not excuses"
16:26:16 <shapr> I think that applies to spotting problems... 
16:26:39 <shapr> try to have several possible solutions available when you tell someone about a problem
16:28:05 <dark> "The photos show conclusive proof that Iraq already has functioning yellow arrows."
16:28:35 <radix> hahaha
16:28:37 <radix> man
16:28:46 <radix> there was a spoof on a radio station here too
16:29:30 <radix> it was about a 14 year old boy, Billy, violating (whatever) 1221, in that he owned and was hiding massive amounts of Pornography :-)
16:30:49 <shapr> a separate compilation thread could be illuminating.
16:30:57 <dark> Why would a 14 year old boy need his own stash of porn?  Doesn't his father have Playboys in the closet?
16:31:30 <shapr> g'nite all...
16:31:38 <radix> night
16:31:51 <radix> dark: Well, not only did he own and hide it
16:32:05 <radix> he was supplying other Evil Children
16:32:13 <Pseudonym> Night.
16:32:29 <Smerdyakov> Yes, it is, isn't it?
16:33:13 <radix> Indeed.
16:36:29 * Pseudonym is trying to imagine Billy's hidden pornography factory
16:39:19 <Smerdyakov> You don't need to imagine. Hop on board my Magic Rickshaw.
16:42:44 * Pseudonym throws some more fuel on the fire
17:08:32 <dark> After all these years, linux still reacts badly to running out of memory.
17:08:39 <radix> indeed
17:08:49 <radix> it's a little more configurable now, thouh, IIRC
17:09:10 <dark> I guess I'll test eviltwin with a smaller dataset :)
19:34:09 <Smerdyakov> Hello, Logan.
19:37:10 <Smerdyakov> jemfinch says: <jemfinch> there's a hidden dictionary mapping types to instance methods that's passed to every function taking a typeclass.
19:37:15 <Smerdyakov> What does it mean?
19:37:49 <jemfinch> (he's asking about the implementation of typeclasses)
20:00:51 <Pseudonym> OK.
20:01:18 <Pseudonym> Do you know how conventional OO languages are implemented?
20:01:23 <Pseudonym> Like, what a vtable is?
20:02:21 <jemfinch> I do.
20:02:26 <Pseudonym> OK.
20:02:27 <jemfinch> Smerdyakov: he's talking to you :)
20:02:36 <Pseudonym> :-)
20:02:45 <Pseudonym> Smerdyakov: Do you know what a vtable is?
20:09:19 <lament> gasp
20:10:00 <lament> aren't vtables the opposite of 'conventional oo'?
20:10:09 <lament> (aka runtime dispatch)
20:10:28 <Pseudonym> Obviously I'm referring to how they're implemented, not what's visible to the programmer.
20:10:33 <Pseudonym> (Except possibly as link errors.)
20:10:34 <lament> but i'm probably trolling, so ignore me
20:13:04 <Pseudonym> BRB
20:13:31 <jemfinch> lament: um, vtables *are* runtime dispatch.
20:13:44 <lament> I told you I was trolling :(
20:13:56 * lament rtfms
20:14:41 <lament> ah the difference is in mutability of vtables right?
20:16:20 <jemfinch> not really.
20:16:38 <jemfinch> the difference is that the vtable could be for any subclass of the abstract (or partially abstract) class.
20:17:27 <lament> i'm talking about the difference between languages like C++ and like Python
20:17:33 <lament> (or smalltalk)
20:22:24 <jemfinch> Python or smalltalk *always* do runtime dispatch.
20:22:33 <jemfinch> C++ does runtime dispatch when you declare a method to be virtual.
20:23:11 <jemfinch> the only time Java doesn't do runtime dispatch is when you declare something final.
20:23:47 <jemfinch> it's definitely the common case for everything to be runtime dispatched.
20:41:10 <lament> but in C++ it only works for classes related by inheritance
20:41:15 <lament> and in Java, interfaces as well
20:41:35 <jemfinch> yes, and?
20:42:15 <lament> without that restriction, can vtables still be used?
20:42:24 <jemfinch> not as such.
20:42:33 <lament> ok, this is what i meant then.
20:42:36 <Pseudonym> In C++/Java/whatever, vtables are part of the type.
20:43:00 <Pseudonym> There will be a field of every structure which points to the "type information", which will be the vtables, the RTTI and so on.
20:43:12 <lament> jemfinch: then why did you say vtables are runtime dispatch?
20:43:22 <Pseudonym> In Haskell, vtables are not part of the type.  They're separate.
20:43:22 <jemfinch> lament: because that's what they are.
20:43:27 <Pseudonym> We call them "dictionaries".
20:43:33 <Pseudonym> But they're basically vtables.
20:43:56 <radix> lament: without a vtable, you'd just have a `jump' instruction or something, right?
20:44:17 <lament> radix: i have no clue whatsoever how python and smalltalk do it.
20:44:31 <jemfinch> lament: runtime dispatch means, "We don't know at compile time exactly which method will be called." -- an vtables enable that.  The C++ compile knows which methods are virtual, and thus knows their *index* into the vtable, but it doesn't know exactly which subclass will be used in a method call, and thus at runtime has to lookup the proper method in the class's vtable.
20:44:41 <radix> lament: python and smalltalk do it with a vtable (a dict)
20:44:42 <radix> err, well
20:44:44 <jemfinch> lament: Python just maintains a string->object dictionary.
20:44:46 <radix> i don't know how smalltalk does it: )
20:44:49 <radix> but that's how _python_ does it
20:46:26 <Pseudonym> It amounts to the same thing, though.
20:46:38 <Pseudonym> A table mapping "method id" to code pointer.
20:47:01 <Pseudonym> Where "method id" may be an index (if it's a static language like C++) or a string (if it's a dynamic language like Python).
20:47:03 <radix> so yes
20:47:07 <radix> some vtables are more dynamic than others :)
20:47:10 <Pseudonym> Sure.
20:47:41 <Pseudonym> In Haskell, a dictionary (i.e. vtable) is conceptually a tuple.
20:48:06 <lament> that's what i said (i think)
20:48:08 <lament> <lament> ah the difference is in mutability of vtables right?
20:48:17 <Pseudonym> You probably did, yes.
20:48:18 <radix> shapr was trying to explain to me how FiniteMap works
20:48:23 <det> radix, hi, your presense made me think I ws in #twisted for a second :)
20:48:24 <radix> it boggled me
20:48:27 <radix> det: :D
20:48:51 <radix> IIUC, FiniteMap doesn't use hashing, but rather something to do with order?
20:50:01 <Pseudonym> Right.
20:50:09 <Pseudonym> It's a bounded balance binary search tree.
20:50:51 <Pseudonym> BBB tree for short.
20:51:04 <radix> ah.
20:51:35 <radix> I'm not really familiar with most of those exotic datastructures
20:51:56 <det> ~radix, learning haskell ?
20:52:01 <radix> well, basically any kind of tree :)
20:52:01 <radix> det: nope
20:52:17 <Pseudonym> http://www.swiss.ai.mit.edu/~adams/BB/
20:52:20 <radix> I just decided to troll around in here, because I like shapr.
20:52:21 <Pseudonym> If you're curious.
20:52:31 <radix> Pseudonym: cool
20:52:37 <Pseudonym> It's basically a balanced binary tree which uses a different balancing criterion.
20:52:45 <Pseudonym> Which happens to be easier to maintain in a functional language.
20:52:47 <det> radix, I do it because I hate shapr!
20:53:00 <radix> heh :D
20:53:14 <Pseudonym> Apparently everyone is here because of shapr in some capacity.
20:53:20 <Pseudonym> Strong personality.
20:53:27 <Pseudonym> To arouse such emotions.
20:53:31 <det> so does anyone have any idea how ocaml constructs vtables ?
20:53:41 <det> that is what I am trying to figure out right now
20:53:57 <det> it all seems very magical
20:54:24 <Pseudonym> I think it is magic.
20:54:33 <Pseudonym> O'Caml has a little pixie inside the compiler.
20:54:46 <Pseudonym> She casts spells over the generated code.
20:54:55 <det> neat
20:59:46 <whee> mmm, magic
21:10:25 <det> this is horrible ..
21:10:25 <det> http://caml.inria.fr/oreilly-book/html/book-ora142.html#toc204
21:10:25 <det> Every method name in an application is given a unique id that serves as an index into the methods table. 
21:11:01 <det> so the size of a vtable for any object grows for the total number of methods in your application ?
21:11:19 <det> maybe I should ask in ocaml
21:54:42 <Pseudonym> If you find out, please let us know.
21:58:33 <Pseudonym> G'day.
21:59:34 <Chilli> Moin
