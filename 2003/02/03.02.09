03:47:52 <buggs> hoi
03:51:05 <Sucht`on|Hase> hi
04:33:59 <Janni> tadaa!
04:34:02 * Janni is back!
04:54:35 <Marvin--> Janni: good for you ;)
05:07:57 <Sucht`on|Hase> nice Janni ^^
06:10:24 * shapr yawns
06:10:33 <shapr> whee: hey, gimme back my wallet
06:12:18 <shapr> goood morning #haskell!
06:12:49 <Heffalump> 'lo
06:12:53 <shapr> hi Heffalump!
06:13:05 <shapr> what do you think?
06:13:12 <Heffalump> sorry, I don't think I have time :-/
06:13:17 <shapr> awww :-(
06:13:48 <shapr> ok, if we have a 1st IOHCC after this one maybe you'll have time...
06:18:52 <Heffalump> YM 2nd?
06:18:59 <shapr> nah, this is the 0th
06:19:23 <shapr> as you said, it may not work in Haskell
06:19:38 <shapr> so we'll have a 0th contest to see if a 1st is worthwhile.
06:19:48 <Marvin--> heh
06:36:29 <shapr> hi Robert 
06:36:42 <Robert> Good afternoon to you.
06:37:10 <shapr> I don't think I've seen you here before, are you new to haskell?
06:38:10 <Robert> I sure am...
06:38:31 <Robert> Got a boring task to do for my C++ class, so I thought I'd see how much easier it would be to write in Haskell.
06:38:50 <Marvin--> that's the spirit!
06:38:56 <Robert> Now I'm stuck at reading a decimal number from stdin.
06:39:01 <Robert> Marvin--: ;)
06:39:18 <Marvin--> do you know of the function read?
06:39:19 <Robert> Marvin--: It's a linked list program, including sorting, so...
06:39:25 <Robert> Nope.
06:39:28 <Robert> How is it used?
06:39:40 <Marvin--> read :: Read a => String -> a
06:39:46 <Marvin--> basically it parses something
06:39:58 <Marvin--> an Int, a Float, a Double, a list of something et.c.
06:40:16 <Robert> Hm.
06:40:33 <Marvin--> so if you've got the string "3.14",  read "3.14" :: Double  will be the double value 3.14
06:40:54 <shapr> Robert: are you in university in .se?
06:40:59 <Robert> Can "3.14" be a String, previously read by getLine.
06:40:59 <Smerdyakov> Robert, do you know of IO monad?
06:41:01 <Robert> shapr: No.
06:41:05 <Robert> Smerdyakov: No.
06:41:05 <Marvin--> Robert: yep
06:41:14 <Smerdyakov> Robert, then you don't know how to read anything yet =)
06:41:16 <Robert> shapr: I'm just a small baby.
06:41:31 <Marvin--> Robert: well, provided you use it correctly, you can't read an IO String
06:41:41 <Robert> Smerdyakov: Awww... But I like starting without the theory!
06:41:44 <Smerdyakov> Robert, anything with "global state" has to hide inside a monad in Haskell.
06:42:01 <Smerdyakov> Robert, so you will at least need to learn how to use do blocks
06:42:02 <jlouis> no IO monad, and your world will be hard to interact with
06:42:18 <Robert> I guess I should read that chapter, then.
06:42:27 * Robert returns to haskell.org
06:42:39 <jlouis> Monads are central to understanding Haskell
06:44:15 <Smerdyakov> jlouis, I think the web server on your host is broken.
06:44:24 <Marvin--> I'm not sure I agree with that, you can write a lot of programs without knowing anything about monads, I don't see a problem with beginners consider IO to be magic
06:44:36 <Marvin--> in fact, seen from the context of Haskell source code, it IS magic
06:44:46 <Marvin--> the whole point of it is that it's magic
06:45:12 <Marvin--> it reminds me of how oracles are used in logics
06:45:20 <Robert> Heh.
06:45:23 <Heffalump> hmm.
06:45:26 <Heffalump> I disagree.
06:45:37 <Marvin--> "okay, so haskell is purely functional, so we can't have any side effects, but IF we could have side effects they would look like this..."
06:45:55 <Marvin--> Heffalump: I agree that I'm oversimplifying :)
06:45:57 <Heffalump> from the context of Haskell source code, writing code in IO is basically saying "produce this stream of IO interactions and respond in this way"
06:46:22 <Heffalump> so I think it's very clear what's expected from IO and how it might do it
06:46:41 <shapr> IO confused me to no end at the beginning.
06:47:02 <Robert> How did you get to understand it?
06:47:11 <shapr> at first I didn't
06:47:20 <shapr> I treated it like a black box
06:47:26 <Marvin--> Heffalump: but it's implemented "outside" Haskell, primitively, just like Int, Int is also magical
06:47:35 <shapr> people said "follow this recipe, and you get what you want"
06:47:47 <Marvin--> shapr: yah, and black boxes are exactly what I mean with magic
06:47:54 <shapr> yah, I think that's a good way to start.
06:48:06 <Heffalump> hmm, possibly
06:48:20 <Marvin--> if people prefer "black box" to "magical", by all means ;)
06:48:31 <jlouis> Smerdyakov: mongers.org?
06:49:13 <jlouis> It is not exactly mine. It provides shell logins for convenience.
06:49:36 <Robert> How do I magically write a function to read a decimal number, and then print it? :)
06:50:20 <Marvin--> main = do { s <- getLine; {- a this point, s :: String -} }
06:51:43 <Robert> Nothing more?
06:53:06 <Marvin--> well, that was just reading the string
06:53:14 <Marvin--> then you can use read to get a double
06:53:39 <Heffalump> I think calling every black box an oracle is stretching things a bit
06:54:34 <jlouis> Marvin--: IO String, right?
06:55:10 <Marvin--> Heffalump: I said I was oversimplifying things, and besides, I don't know much about oracles :)
06:55:16 <Robert> What is the syntax for that? How do I read a string, and then convert that to number, put into a variable?
06:55:22 <Marvin--> jlouis: no, s :: String since it's been bound
06:55:31 <Robert> +a
06:55:42 <Marvin--> Robert: in this case, let d = read s :: Double
06:56:15 <Heffalump> Marvin--: fair enough :-) (neither do I, anyway)
06:56:29 <Robert> Thanks. :)
06:57:48 <Robert> I'll read up a bit better before I harass you again.
07:00:00 <Marvin--> Robert: the explicit type notation is needed because read is overloaded
07:00:10 <jlouis> big time indeed
07:02:38 <dennisb> main = do s <- getLine; print (4.2 + (read s))
07:09:32 * Janni greets everybody: "Hi, everybody!"
07:10:21 <Robert> Hi Janni.
07:10:47 <Robert> addItem (xs) = do putStr "\nNumber: "
07:10:47 <Robert>                   s <- getLine
07:10:47 <Robert>                   let n = read s :: Int
07:10:48 <Robert>                   return (n:xs)
07:11:14 <Marvin--> Robert: you don't need the parentheses around the argument xs
07:11:19 <Robert> Okay.
07:11:29 <Robert> But, why dosn't that return the correct list?
07:11:40 <Robert> I.e. xs appended to n.
07:12:39 <Marvin--> are you using hugs?
07:13:34 <Marvin--> hugs doesn't print the result of an IO action, so you'll want to do something like   addItem [] >>= print
07:13:46 <Marvin--> or use ghci
07:14:26 <Marvin--> hmm, ghci doesn't print it either, never mind
07:14:55 <Robert> Oh!
07:14:57 <Robert> Thanks.
07:15:16 <Marvin--> note, only use the  >>= print  when testing in the interpreter, not in a finished program :-)
07:15:24 <Robert> :)
07:18:19 <giedi> anyone here use vim?
07:18:25 <Marvin--> yeah
07:18:38 <giedi> think i could get a copy of your vimrc? 
07:18:39 <jlouis> vim, indeed
07:18:58 <Marvin--> giedi: it's kinda messy :)
07:19:12 <jlouis> giedi: http://j.mongers.org/pub/dotfiles/2003-01-09/
07:19:21 <Robert> Hrm. How do I make vim uses spaces instead of tabs?
07:19:27 <jlouis> though you will need the 'vimdir' too
07:19:28 <Robert> use*
07:19:30 <Marvin--> Robert: set expandtab
07:19:36 <Robert> OK, thanks.
07:19:36 <jlouis> set expandtab
07:19:42 <Robert> Hehe, thanks again ;)
07:19:47 <Janni> All the time I'm thinking about a concept, which could be called "eager compilation". i'll try to describe it and maybe someone can tell me what's its real name (I guess someone already invented it). I'm thinking of a compiler/processor which processes the whole program during compile time while holding all possible values and thus is able to eliminate all euphemisms (<- strange)
07:20:07 <shapr> Janni: what do you mean?
07:20:20 <Janni> i expected that question :)
07:20:26 <giedi> euphemisms?
07:20:40 <Janni> giedi: true AND a is ...?
07:20:47 <shapr> Janni: you mean eliminate values that might happen between input and result?
07:21:01 <Janni> (true && x) => x
07:21:07 <Janni> an easy one
07:21:12 <giedi> Janni: sounds like prolog or similar
07:21:17 <jlouis> optimization?
07:21:19 <Marvin--> Janni: that sounds like "optimization" to me ;)
07:21:24 <Janni> jlouis: yes
07:21:40 <Janni> Marvin: yeah. for this example it is _just_ optimization, but...
07:21:46 <Marvin--> it also sounds like partial evaluation
07:21:52 <Janni> exactly
07:21:58 <jlouis> indeed
07:22:10 <shapr> yah, partial evaluation
07:22:11 <jlouis> though you need a static input there
07:22:39 <Janni> shapr: so should i google for "partial evaluation"?
07:22:39 <Marvin--> I'm going to go have a cup of coffee and read in Okasaki's book
07:22:46 <Janni> is this a fixed expression
07:23:45 <jlouis> Marvin--: purely functional data structures?
07:23:58 <Marvin--> jlouis: yeah
07:24:02 <jlouis> that book rocks
07:24:03 <shapr> Janni: yes, look for partial evaluation.
07:24:07 <Marvin--> jlouis: indeed :)
07:25:05 <giedi> jlouis: you've used this rc file while editing haskell code?
07:25:15 <jlouis> yup
07:25:22 <giedi> jlouis: thanks :)
07:25:29 <jlouis> as long as your tab is 8 chars it works well
07:26:00 <Marvin--> bah, set expandtab tabsize=8
07:27:10 <Marvin--> the library didn't have the book *mutter* so I borrowed it from Koen
07:27:49 <jlouis> I have a hardback version of that book.
07:28:21 <shapr> I bought rabhi and lapalme's book, but I don't have okasaki's book yet.
07:29:08 <Smerdyakov> jlouis, are you affiliated with some research organization?
07:29:43 <shapr> watchit, Smerdyakov is an undercover agent for SML
07:29:50 <giedi> jlouis: you use dvorak?
07:29:57 <shapr> aoeu?
07:29:58 <Janni> me too, me too! :)
07:30:17 <giedi> heh
07:30:24 <jlouis> giedi: yup
07:31:15 <jlouis> Smerdyakov: not exactly. I work in the sysadmin part at the CS department of the University of Copenhagen
07:31:31 <Smerdyakov> jlouis, oh. And do you want to stay with that job?
07:31:34 <jlouis> smedapart from that I am an undergrad
07:31:43 <Smerdyakov> Oh
07:31:55 <Smerdyakov> Well, I think "student" is a kind of affiliation. =)
07:32:01 <jlouis> ;)
07:32:16 <jlouis> We are taught SML primarily in fact
07:32:35 <Smerdyakov> I know.
07:32:44 <Smerdyakov> Do you know Sune Kirkeby?
07:32:51 <jlouis> indeed :)
07:33:10 <giedi> jlouis: do you have a dvorak vim layout I could use? one of the main reasons I never tried to learn it was because my brain is so wired to vim command locations.
07:33:23 <Smerdyakov> jlouis, ever been to http://www.tpu.org/ ?
07:33:36 <jlouis> giedi: you are lookuing at my vim layout
07:33:55 <jlouis> giedi: I combine that with a setxkbmap dvorak in .xsession on my UNIX box
07:34:23 <jlouis> Smerdyakov: now I have ;)
07:34:52 <Smerdyakov> jlouis, that site used to be hosted at Sune's house, since his parents have a T1 =)
07:35:06 <giedi> so 
07:35:42 <giedi> 't' 'h' on your keyboard move the vim cursor up and down? 'j' 'k' on qwerty.. sorry.. I've always been intrested in this somewhat :)
07:35:53 <Janni> as far as i have read about partial evaluation it doesn't seem to be exactly the same as what i am thinking of. example: <gimme some time>
07:36:48 <jlouis> giedi: exactly
07:36:57 <shapr> Janni: for extra credit, tell me what happens when I do "addOne = (+ 1)" in Haskell.
07:37:17 <Smerdyakov> What "happens"?
07:37:26 <Smerdyakov> I think you have bad terminology =)
07:37:36 <jlouis> Curry Curry Curry!
07:37:55 <Smerdyakov> jlouis, do you want to join #sml?
07:38:12 * shapr envisions Smerdyakov with a black mask saying "come to the dark side!" ;-)
07:38:30 <Janni> f 1 = a; f 2 = b; f 3 = c; g x | x <= 0 = f 1;    x > 0 = f 2. now the compiler knows, that f will never be called with 3 as argument and it can discard the third line of f. do actual compilers do that?
07:38:59 <Smerdyakov> If that's your whole program, it knows that.
07:39:14 <Heffalump> GHC would inline f and probably then throw away the entire definition
07:39:17 <Smerdyakov> If f escapes as a parameter to another function, then in general it has no idea.
07:40:08 <shapr> Janni: in more exact terminology, do you know the difference between partial application and partial evaluation?
07:40:25 <Janni> no idea. guess, i'll start reading...
07:40:57 <Robert> Hmm... How would I send a "function pointer" as an argument to a function, and then execute it there? Like Forth's  ' F EXECUTE
07:41:40 <Janni> Robert: just pass the function (isn't it that, what you want?)
07:42:08 <jlouis> functions are first class citizens in Haskell
07:42:10 <Robert> Yes, something in that direction.
07:42:20 <Smerdyakov> Robert obviously hasn't read much of the tutorial he is reading....
07:42:26 <Robert> Sorry, I'm not used to high level languages.
07:42:29 <Robert> Smerdyakov: Correct.
07:42:30 <Smerdyakov> There will be chapters and chapters dedicated to just this topic :P
07:42:38 <Janni> Robert: that's the main idea of functional programming
07:43:00 <shapr> Smerdyakov: hey, at least he's started, and is working on it...
07:43:11 <Robert> shapr: Better than nothing, eh?
07:43:15 <Robert> Well, I
07:43:16 <Robert> Well, I
07:43:17 <shapr> It took me quite some time to wrap my head around first class functions
07:43:18 <Robert> Argh
07:43:29 <Robert> I will (1) learn to type, (2) read the tutorial.
07:43:30 <Janni> Robert: http://www.cs.ou.edu/cs1323h/textbook/haskell.shtml
07:43:32 <Smerdyakov> shapr, tehe. Your head must have been full of SAND!!!
07:43:44 <Janni> Robert: it's my favourite
07:43:54 <shapr> Smerdyakov: or maybe potatoes
07:44:57 <Robert> OK, thanks.
07:45:26 <Smerdyakov> The link Janni gave is for a course for people who have never coded before.
07:45:38 <Smerdyakov> Perhaps it's not appropriate, and Robert should just read the one he has :P
07:46:03 <Robert> I was reading that one at haskell.org.
07:46:10 <Robert> A Gentle Introduction to Haskell 
07:46:19 <Smerdyakov> I think it's a good choice.
07:46:37 <Janni> Smerdyakov: it's perfect for functional programming beginners
07:47:27 <Smerdyakov> Janni, that's true. I haven't really found any elements of functional programmers too hard to grasp, myself.
07:47:37 <Smerdyakov> Janni, when did you first learn to code?
07:47:45 <Smerdyakov> s/programmers/programming
07:47:49 <Janni> Smerdyakov: hmm. lemme think
07:47:51 <Smerdyakov> I don't generally grasp programmers ;-)
07:47:57 <Marvin--> Smerdyakov: I was wondering :P
07:48:08 <Smerdyakov> Marvin--, but special arrangements are possible......
07:48:09 <Janni> Smerdyakov: 5 or 6 years ago?
07:48:23 <Janni> Smerdyakov: but i started haskell half a year ago
07:48:36 <shapr> I like to think I learn slowly but thoroughly
07:48:41 <Smerdyakov> Janni, oh, that could be the problem. I learned at age 6, 13 years before learning functional programming. =)
07:48:42 <Janni> hmm. rather 4 or 5 years
07:48:48 <shapr> at least I'm sure about the slowly part ;-)
07:49:03 <Marvin--> I started programming Pascal when I was 14, (insert plenty of other languages and years here), Haskell when I was 19, and now I'm 22
07:49:28 <Janni> Smerdyakov: i tried a bunch of tutorias (Gentle Introduction amongst them) and i didn't really get into FP until I found the tutorial mentioned above
07:49:32 * Robert is 16, learned to program 5 years ago. Probably the least experienced here.
07:49:45 <jlouis> C at 14, sml at 18, haskell at 20, now 22
07:49:58 <shapr> I did BASIC on Sinclair Spectrum and Commodore 64
07:49:58 <Marvin--> jlouis: you started with C? poor bastard
07:49:58 <Smerdyakov> Robert, yes, so it's unsure whether or not you have the necessary engrams that "native programmers" have =)
07:50:26 <Smerdyakov> Just like learning a natural language before a certain age
07:50:26 <jlouis> Marvin--: I can wrap pointers around like no-one. And make pointer errors like no one
07:50:28 <Robert> Smerdyakov: I really doubt you have to be born into it.
07:50:32 <Marvin--> jlouis: :)
07:50:55 <Smerdyakov> Robert, oh, no, not "born" at all.... that doesn't follow the analogy with natural language
07:51:00 <shapr> I've done very little C
07:51:02 <Janni> Well, I guess I'm real language traveller. having started with 13 or 14(?) i really learned many languages. now knowing Haskell (with 18), maybe i'll settle down for a while
07:51:03 <Smerdyakov> Robert, you just need to start before a certain age
07:51:06 <shapr> but I've heard about three star programmers
07:51:17 <Janni> i'm always looking for s.th. better
07:51:27 <Marvin--> I do plenty of C in debian-installer, but I tend to make errors... Languages like Haskell and Python spoils you
07:51:41 <Smerdyakov> I'm writing C for OS class this semester ;-)
07:51:43 <shapr> Janni: if you find something better than Haskell, tell me!
07:52:06 <Robert> Smerdyakov: Tell that to all those old men and women sitting out there.
07:52:10 <giedi> Anyone here ever attempt Erlang?
07:52:26 <Janni> shapr: ok. but it's kind of hard to imagine ;)
07:52:32 <Smerdyakov> shapr, you really should stop bandying "better" about like that.
07:53:19 <Marvin--> giedi: we used it in our concurrent programming course, pretty nifty language
07:53:30 <Marvin--> Smerdyakov: our OS course was a big disappointment, though the assignments were fun
07:54:13 <Marvin--> a shell with basic job control, and a scheduling threading lib
07:55:28 <shapr> Smerdyakov: bah, much like Humpty Dumpty, I just pay more.
07:55:46 <Smerdyakov> I think our projects are an initial one involving interrupts and basic device interaction, a user level thread library, a kernel supporting concurrency, and adding file system support to the kernel.
07:56:05 <Smerdyakov> Marvin--, if you want concurrent programming, then you want CML. =)
07:57:02 <Janni> The need for CHaOS is growing from day to day.
07:57:10 <Janni> It just has to be done...
07:58:51 * Janni just has too big vision and too less knowledge
07:59:00 <Janni> s/vision/visions
07:59:34 <Smerdyakov> Too less knowledge of English ;-)
07:59:50 <Janni> yea. that too. it just sounds strang. it has to be wrong
08:00:41 <Smerdyakov> * Janni just has too much vision and too little knowledge
08:00:57 <Janni> well... shit!
08:01:16 <Janni> Smerdyakov: but i think "too much vision" is not what i meant
08:01:54 <Smerdyakov> I think it is.
08:02:02 <Janni> i mean s.th. like "great aims". is that the same?
08:02:29 <shapr> the point of languages is to communicate effectively
08:02:49 <shapr> as long as you get the point across you're doing okay
08:03:00 <Janni> s/aims/goals (better)
08:03:18 <shapr> I can get my point across in english, french, swedish, and finnish; in order of how well I do it...
08:03:36 <Smerdyakov> Janni, yes
08:04:19 <Janni> shapr: but aesthetics must not miss
08:04:29 <Janni> (sounds strange too)
08:05:03 <Marvin--> shapr: oh, you know Swedish better than Finnish?
08:06:01 <shapr> yah sure
08:06:07 <shapr> finnish is freakin hard
08:06:24 <shapr> swedish is like a mix of dutch, german, and english
08:06:36 <shapr> most of the swedish structures work like engish structures
08:06:41 <shapr> english even
08:06:52 <Marvin--> true
08:07:00 <shapr> have you tried to learn finnish?
08:09:04 <Marvin--> no
08:09:07 <Marvin--> too scary :)
08:09:24 <shapr> I think it's just liberal in it's use of eta expansion or something
08:09:44 <Marvin--> haha
08:13:37 <jlouis> Finnish is evil
08:14:10 <jlouis> Norwegian, Danish and Swedish are almost nothing but dialects and syntactic sugar of a more general language
08:15:25 <Marvin--> yeah they're pretty much the same language
08:32:50 <jlouis> does anybody in here know a lot about kindsL
08:32:51 <jlouis> ?
08:33:02 <Heffalump> how much is a lot?
08:33:05 <jlouis> it seems my multi-parameter type class problem is rooted in it
08:33:27 <Heffalump> I /might/ be able to help but don't hold your breath
08:33:51 <jlouis> I just want to know how a multi parameter type class is kind inferred
08:34:28 <shapr> kindsL
08:34:37 <shapr> ^^^^ dvorak typo
08:35:02 <jlouis> shapr: indeed, L and ? is next to each other
08:35:32 <Heffalump> ok, I don't know the answer to that
08:36:06 <jlouis> I know that kinds are used to infer correctness of the type system
08:36:33 <jlouis> so that given data Tree a ...
08:36:39 <jlouis> we have Tree is * -> *
08:36:41 <jlouis> as
08:38:03 <jlouis> when you create an instance of a MP type class, and mess it up, ghc errors in the kind inference, which was what hinted me
08:38:33 <Heffalump> hmm
08:38:53 <Heffalump> so a type class will expect parameters of a particular kind
08:38:59 <Heffalump> but I'm not sure what inference is required
08:39:16 <Heffalump> e.g. the Monad class requires parameters of kind * -> *
08:39:26 <Heffalump> what was the error?
08:41:52 <jlouis> there was no error. I had some code I could not understand how the kind system inferred
08:41:52 <phubuh> hey duders
08:42:40 <jlouis> Monad is simple. I am battling things more like:
08:42:48 <jlouis> class Collection c a where...
08:43:06 <jlouis> class FiniteMap m k where...
08:43:10 <jlouis> and friends
08:43:28 <Heffalump> so presumably c is of kind * -> * and of kind *
08:43:34 <Heffalump> IM a of kind *
08:43:38 <shapr> if you ask on the main mailing list, you can get quick answers
08:43:52 <jlouis> shapr: which is?
08:44:09 <shapr> haskell@haskell.org
08:44:09 <jlouis> it is not ever pure Haskell 98 :)
08:44:12 <jlouis> ok
08:46:27 <jlouis> Heffalump: yes, I think so. It makes sense
08:48:32 <jlouis> Though in the Finitemap case, we have:
08:48:36 <jlouis> class FiniteMap m k where
08:48:41 <jlouis>   empty :: m k a
08:48:56 <jlouis> which hints m must be of kind * -> * -> *
08:49:14 <Heffalump> what is k?
08:49:16 <Heffalump> oh, the keys
08:49:17 <Heffalump> yeah
08:49:20 <jlouis> yup
08:50:11 <jlouis> the trick is we can instance the keys with individual constraints for different instances
08:50:48 <jlouis> data List k a = L [(k,a)]
08:50:48 <jlouis> ...
08:50:59 <jlouis> instance Eq k => FiniteMap List k where ...
08:51:22 <jlouis> instance Ord k => FiniteMap Tree k where
08:51:28 <jlouis> or something like that
08:51:44 <Heffalump> ah, hmm
08:52:21 <jlouis> But then, Chris Okasaki creates a trie structure by data structural bootstrapping:
08:52:42 <jlouis> data Trie mk ks a = TRIE (Maybe a) (mk (Trie mk ks a))
08:52:45 <jlouis> ...
08:53:00 <jlouis> instance FiniteMap m k => FiniteMap (Trie (m k)) [k] where...
08:53:14 <jlouis> then the inference gets above my head
08:56:06 <Heffalump> well, Trie is of kind (* -> *) -> * -> * -> *
08:56:33 <jlouis> yes
08:57:04 <jlouis> so Trie (m k) is of kind * -> * -> *
08:57:25 <jlouis> and (Trie (m k)) [k] is of kind * -> *
08:57:27 <Heffalump> and m must have been * -> * -> *, which fits with what we expect from FiniteMap
08:57:29 <jlouis> which is what we want
08:57:45 <Heffalump> (Trie (m k)) [k] doesn't exist
08:57:51 <jlouis> ok
08:57:54 <Heffalump> FiniteMap takes two parameters
08:58:07 <Heffalump> which are (Trie (m k)) and [j]
08:58:10 <Heffalump> s/j/k/
08:58:31 <jlouis> where m must be of kind * -> * -> * and k of kind *
08:59:14 <shapr> I wish there were a Parsec mailing list...
08:59:18 <shapr> maybe I should just ask on haskell-cafe
08:59:25 <jlouis> and (Trie (m k)) abides that structure as well as [k]
08:59:59 <jlouis> Heffalump: it becomes much clearer now
09:02:40 <giedi> '(foldr (.) [] [f,g,h]) "abcd"' isn't this equivelant to the function composition '(f.g.h) "abcd"' I know this is wrong.. what would [] be replaced with?
09:03:20 <jlouis> the identity functionL
09:03:20 <jlouis> ?
09:03:35 <jlouis> id x = x
09:04:17 <jlouis> alternatively, cant you use foldr1?
09:04:17 * Marvin-- hands jlouis an L
09:05:27 <giedi> thanks :)
09:07:03 <Heffalump> you can prove that that's equivalent to foldr ($) "abcd" [f,g,h]
09:07:28 * giedi should read one page further before asking questions next time.
09:08:05 <jlouis> $ is in the Prelude?
09:08:20 <jlouis> yup
09:08:40 <giedi> $ is apply?
09:09:10 <jlouis> ($)            :: (a -> b) -> a -> b
09:09:14 <jlouis> f $ x           = f x
09:09:19 <jlouis> yes :)
09:39:26 <Sucht`on|Hase> cu all ! I will be back in approximately two hours
09:57:33 * shapr bounces
09:58:04 * Robert studsar.
10:10:57 <shapr> is there case insensitive matching support in Parsec? or some simple way to do it?
10:20:18 <jlouis> is Parsec a parser of some kind?
10:20:33 <jlouis> I just used happy for that
10:22:12 <shapr> yah, parsec is monadic parser combinators
10:22:26 <shapr> http://www.cs.uu.nl/~daan/papers/parsec.html
10:22:31 <shapr> it comes with GHC
10:22:42 <shapr> I haven't tried Happy yet, I'll try it for my next parsec.
10:22:45 <shapr> er, parser
10:23:15 <shapr> I'm trying to write an rfc822 parser, the code is in the cvs tree of sf.net/projects/haskell-libs
10:23:29 <shapr> speaking of which, I was hoping to write a front page for that this weekend.
10:25:07 <jlouis> happy is yacc-like
10:25:25 <shapr> yah, I've read about it, but I haven't used yacc/bison/happy/etc at all.
10:25:35 <jlouis> mlyacc
10:25:47 <jlouis> ;)
10:25:53 <shapr> parsec seems straightforward to me
10:25:59 <shapr> simple, easy, fun, etc
10:26:07 <shapr> yacc source looks scary
10:26:20 <shapr> er, yacc input that is
10:26:52 <Marvin--> the advantage of happy is that you get a bottom-up parser, parsec is top-down isn't it?
10:27:01 <shapr> I don't know
10:27:12 <jlouis> LALR(1) i suppose
10:27:13 <Heffalump> yep.
10:27:22 <shapr> seems fast enough so far
10:29:24 <shapr> daan leijen also wrote Pbench, a parser benchmark program
10:29:47 <shapr> he had a comparison of parsec, happy, and something else on his page I thought.. but I can't find it right now.
10:30:23 <jlouis> the reason I used happy the last time was I had the parser grammer in mlyacc already Converting it to happy and let happy do the dirty work were more straightforward, than to redesign the code
10:31:01 <shapr> makes sense
10:31:25 <shapr> reason I'm using Parsec is that I had already gone through the tutorial and used it for some very small stuff.
10:32:59 <steele> shapr: you can set caseSensitive in makeTokenParser if you use ParsecToken
10:33:05 <jlouis> furthermore, I am more fluent in yacc-style grammars than in monadic parser combinators
10:33:24 <jlouis> why are you writing an rfc822 parser?
10:33:35 <shapr> steele: I'm not using parsec token because it has some assumptions that don't fit rfc822, but I did just steal the case insensitive code from it :-)
10:33:42 <shapr> jlouis: haskell doesn't have one.
10:33:59 <shapr> I want Haskell to have all the libraries Python has, so I can switch over entirely.
10:34:09 <shapr> ergo, I get to write them.
10:34:38 <jlouis> why?
10:34:46 <shapr> jlouis: feel free to create an sf.net user id and drop your haskell libs into the haskell-libs project.
10:34:47 <jlouis> I do not think it makes sense
10:35:02 <shapr> what, to write an rfc822 parser?
10:35:06 <shapr> or to write libs for haskell?
10:35:17 <jlouis> no, to try make Haskell ''take over'' Python
10:35:43 <jlouis> they are different tools, suited for different tasks. Heck, you can do it, but it will be a lot harder
10:35:54 <shapr> I don't want to 'take over' Python, I just want to be able to write anything in Haskell that I can in Python.
10:36:19 <shapr> python comes with lots of basic useful libraries for nearly any task
10:36:50 <shapr> I can just 'import email' for example
10:37:19 <shapr> someone recently hired me to suck the contents of an nntp server into an ms access database
10:37:29 <jlouis> yes, though Haskell seems centered around the academic crowd, so most libraries written for it are of language theoretic nature
10:37:35 <shapr> It would have taken very long to write in Haskell because the libraries weren't there
10:37:47 <shapr> yes, that's true.
10:37:52 <shapr> but I want to get paid to write Haskell.
10:38:00 <jlouis> ;)
10:38:08 <jlouis> Prototyping
10:38:11 <shapr> and I make my living by doing contract programming.
10:38:18 <jlouis> I've got paid using Haskell a couple of times
10:38:24 <shapr> oh, I'm jealous!!
10:38:33 <Marvin--> me too, but I'm not sure TA counts ;P
10:38:34 * shapr bounces 
10:38:39 <jlouis> Marvin--: ;)
10:38:50 <shapr> jlouis: tell me how to get paid to write Haskell ;-)
10:38:58 <shapr> I must learn the inner mysteries...
10:39:09 <Marvin--> ... which reminds me that I have to finish that letter of application
10:39:27 <jlouis> I made a prototype of some web-management system in Haskell. We rewrote it in Perl afterwards, when we were sure the prototype worked
10:39:33 <shapr> yow
10:39:41 <shapr> you rewrote it in perl????
10:39:44 <jlouis> yes
10:39:51 <shapr> I would have kept it in Haskell.
10:40:09 <jlouis> A prototype only exists for proving your points correct, showing that your data structures work etc
10:40:15 <shapr> steele: thanks for the pointer to caseSensitive
10:40:21 <shapr> oh, I agree
10:40:34 <shapr> I use prototyping also.
10:40:56 <jlouis> shapr: most stuff will be imperative interaction anyway, where the side effect is the important thing. Haskell is suited for that as a language
10:41:05 <jlouis> is not
10:41:14 <steele> jlouis: what about the linecount? haskell vs perl
10:41:20 <shapr> yah, I'm curious also
10:42:00 <shapr> have you seen the haskell web server?
10:42:03 <jlouis> I think I proved the base parts of the code in less than 300 lines of Haskell
10:42:07 <shapr> wow
10:42:07 <shapr> neat
10:42:13 <Heffalump> monadic IO still gives you many of the benefits of functional programming
10:42:59 <shapr> yah, I like to think that monads can cover the hard parts of side effects in Haskell
10:43:04 <jlouis> Heffalump: yes, but it soon becomes an imperative hell, when 90-95% of your code is acting with the ''real world''
10:43:08 <shapr> I haven't proven that to myself yet though
10:43:19 <shapr> jlouis: can you show an example of that?
10:43:34 <jlouis> shapr: a window manager in Haskell is hell for instance
10:43:40 <shapr> ever tried it?
10:43:47 <shapr> there are Xlib bindings already
10:44:16 <jlouis> my synchronisation is lost entirely between the X server and me
10:44:17 <shapr> I would think a web server would hit the 'imperative hell' if anything, but Simon Marlow's webserver is really quite elegant and simple
10:44:18 <Heffalump> jlouis: generally one writes a small imperative loop that does the interaction and do the rest in functional code
10:44:20 <shapr> and it's really fast too
10:44:56 <Marvin--> maybe I should stop fiddling with my laptop and go make dinner
10:45:05 <shapr> I'm not totally convinced either way yet.
10:45:15 <shapr> but I am rooting for Haskell :-)
10:45:48 <jlouis> Heffalump: you still need to pass on calls to XLib, which is side-effect oriented
10:47:31 <shapr> jlouis: I'd have to see code to be convinced.
10:47:50 <jlouis> shapr: speed does not matter that much. The reasons for choosing perl was: 1) everybody knew that language well, 2) libraries for our tasks, 3) good DB interaction, 4) most tasks were imperative in nature
10:48:14 <shapr> I agree with the first three
10:48:15 <Heffalump> jlouis: but you can make the decision of what to do in functional code, and execute it in imperative code
10:48:41 <shapr> I am not yet convinced of the fourth item (though I could be with suitable examples)
10:49:46 * Marvin-- is patching the kernel source, eek
10:49:56 <shapr> yow
10:50:13 <Heffalump> Marvin--: what for?
10:50:14 <Marvin--> not my own patch fortunately
10:50:25 <Heffalump> ah.
10:50:27 <Marvin--> trying to get swsuspend to work
10:50:57 <Marvin--> it's very cute, it saves the suspend image on a swap partition :)
10:51:06 <jlouis> We did think of the FFI method though
10:51:13 <shapr> yah, I was wondering about that
10:51:20 <shapr> or using one of the ML family
10:51:27 <shapr> since it seems to be more imperative in nature.
10:51:39 <jlouis> it has a subset of the core language imperative
10:51:44 <jlouis> it is hard to work with though
10:55:04 <jlouis> yet I still dont see why you want to parse rfc822 with a monadic parser combinator. It screams overkill to me. Some simple Trie match of kludges would be appropriate I think
10:55:32 <shapr> I want full scale email tools for Haskell.
10:56:12 <shapr> and I get to play with Parsec
10:56:13 <jlouis> full scale? mta? mua?
10:56:24 <shapr> yah, also usable for mta and mua 
10:56:42 <shapr> plus I get to find out if you're right, it could be total overkill :-)
10:56:48 <shapr> and it may not be flexible enough
10:57:37 <shapr> common knowledge says that Haskell is the best language for writing compilers, is it true?
10:57:48 <jlouis> Dunno, never tried
10:58:03 <jlouis> I've done it in SML though, and SML rocks for writing compilers in
10:58:05 * Marvin-- gulps and builds the kernel
10:58:14 <shapr> same here, but I'm in the midst of trying to do a parser with it, which is the first step along the way.
10:58:26 <jlouis> yup
10:58:30 <Heffalump> ML is rather more common than Haskell.
10:58:59 <jlouis> I am currently writing a Literate programming tool in Haskell (re-writing from SML in fact)
10:59:01 <Marvin--> lisp is common ;) *ducks*
10:59:07 <shapr> jlouis: what kind of tool?
10:59:10 <jlouis> scheme! *ducks*
10:59:16 <jlouis> shapr: tangle, weave
10:59:23 <shapr> haskell has birdtracks and latex so far
10:59:55 <jlouis> shapr: yep, but they can not do what I want, so I am writing up my own
11:00:02 <jlouis> ;)
11:00:07 <shapr> what features are you missing?
11:00:57 <jlouis> the original weave and tangle is based around macros. A macro is a piece of code, which in turn can call other macros and so on
11:01:21 <jlouis> I want my macros to be functions, so I can pass arguments to them
11:01:40 <Heffalump> Haskell doesn't really have Knuth-style literate programming, since it doesn't allow arbitrary semantically-incomplete fragments
11:02:05 <jlouis> there exists some (badly coded) C tools for this in the excess of 18K lines. I think I can do that in haskell in less than 1000 lines
11:02:05 <Heffalump> but OTOH it can be argued that first class functions make that unnecessary and even undesirable
11:02:24 <jlouis> Heffalump: I tend to use the tool for other languages than Haskell
11:03:17 <jlouis> so I simply need those features. I dont think I will use it for haskell though
11:03:41 <Heffalump> ah, right
11:04:15 <shapr> hi radix
11:06:24 <radix> hello!
11:07:15 <Janni> jlouis: how do you mean that "other languages than Haskell" (comeback from a long journey ;)
11:07:24 * shapr wonders whether food processors would be used to implement the bindM operation on food combinators.
11:08:17 <shapr> custard :: Food Eggs -> Food Milk -> Food Cake
11:08:49 <Heffalump> that's not got a generic enough type :-)
11:08:53 * shapr snickers
11:08:57 <shapr> ok, improve it ;-)
11:09:12 <koukoutsi> anyone familiar with Xilinx? (CAD)
11:09:22 <shapr> isn't that a hardware design package?
11:09:45 <koukoutsi> yes
11:09:51 <shapr> does it use Haskell?
11:10:09 <shapr> or are you wanting to port some designs from Xilinx to BlueCode?
11:10:14 <shapr> or Lava, or Hawk?
11:10:51 <koukoutsi> i dont think so... but it happens some EECS students at uni learn haskel and Xilinx  :)
11:12:26 <shapr> I've never used Xilinx myself.
11:12:35 <kawfee> anyone know why hugs would allow me to use a file without the > ?
11:12:52 <shapr> kawfee: you mean a non-literate file?
11:12:54 <Heffalump> .hs files don't need the >
11:12:57 <Heffalump> .lhs files do
11:13:01 <shapr> yah, what he said.
11:13:04 <kawfee> oh yeah
11:13:06 <Heffalump> koukoutsi: what uni?
11:13:07 <kawfee> ok
11:13:10 <kawfee> hrm
11:13:23 <kawfee> maybe I should change the name =]
11:15:25 <whee> haha
11:15:33 <whee> Loading package base ... linking ... unknown reloc
11:15:33 <whee> zsh: abort (core dumped)  ghci
11:15:38 <shapr> yow
11:15:46 <shapr> hey whee, you owe me a wallet :-P
11:15:50 <Heffalump> what version?
11:15:52 <whee> the day I can use TH will be the day pigs fly.
11:15:58 <whee> cvs 5.05 Heffalump
11:16:09 <Heffalump> talk to Igloo, he can probably help with problems
11:20:46 * shapr finds the error he's been staring at for an hour
11:21:08 <shapr> man I hate it when errors parade around pretending to be useful code.
11:22:26 <Marvin--> yeah, we need better syntax highlighting of bugs
11:22:35 * shapr snickers
11:23:41 <Marvin--> yum, bacon-wrapped chicken fillet with brussel sprouts
11:27:34 <shapr> yay, fixed case sensitivity issues
11:28:06 * Marvin-- notes where shapr's priorities are
11:28:13 <shapr> ?
11:28:23 <Marvin--> I'm trying to think of food here :P
11:28:26 <shapr> oh :-)
11:28:34 <Marvin--> bah, I'll be in the kitchen instead :)
11:29:18 <shapr> beatrice has been successfully experimenting with pasta sauces lately. I must start going to the gym or buy new clothes.
11:29:22 <shapr> hi ke 
11:30:22 <ke> hi
11:30:55 <shapr> new to haskell?
11:31:04 <ke> never tried it!
11:31:20 <shapr> would you like to?
11:32:04 <ke> i've used scheme a little (in the university)
11:32:21 <Marvin--> shapr: :)
11:32:42 <shapr> did you like scheme?
11:32:59 <shapr> Marvin--: what, do you think I'm a rabid proselytizer?
11:33:24 <jlouis> I did not like scheme, I loved ml/haskell
11:33:39 <ke> i think i liked it, is haskell similar? 
11:33:42 <shapr> sort of...
11:34:02 <shapr> Haskell takes the ideas of Scheme much further.
11:34:19 <kawfee> if I have the following:: 
11:34:20 <kawfee> > dollar w c = where a = c `div` 10
11:34:20 <kawfee> >     b = c `mod` 10
11:34:21 <kawfee> >     d = w - ((length a) + length b)
11:34:45 <kawfee> how can I print d, then a then b ?
11:34:53 <shapr> ke: to me, Haskell is much like writing an equation.
11:35:01 <kawfee> and d needs to be printed using a sertain symbol?
11:35:06 <kawfee> symbol. 
11:35:34 <shapr> ke: if you want to learn Haskell, I would suggest that you download the Helium interpreter and read the Gentle Introduction.
11:35:59 <shapr> ke: or I can show you some samples of code I've written and you can see if that interests you or scares you away.
11:37:03 <ke> shapr: what kind of application is it?
11:37:08 <shapr> my code?
11:37:09 <Marvin--> kawfee: er, you can't start an expression with 'where'
11:37:14 <jlouis> kawfee: ERROR "test.hs":1 - Syntax error in expression (unexpected keyword "where")
11:37:18 <shapr> I wrote a tiny fractal grapher
11:37:34 <Marvin--> time to eat
11:37:59 <shapr> http://kungens.kemi.fi/~shae/src/haskell/Mandelbrot-0.1.hs <-- my fractal program
11:38:22 <shapr> that's the first code I wrote in Haskell, so it's not very pretty.
11:40:13 <shapr> ke: what do you think, scary? nifty?
11:42:32 <ke> i don't exactly understand it, for example what "->" is
11:42:52 <shapr> in this code:
11:42:54 <shapr> add :: (Integer,Integer) -> Integer
11:42:54 <shapr> add (x,y) = x + y
11:43:02 <shapr> the top line is a type declaration
11:43:02 <jlouis> ke: it depends
11:43:18 <ke> ok i see
11:43:20 <shapr> in means that function takes a tuple of two Integer, and returns one Integer
11:43:22 <jlouis> add is a function from a pair of integers to an integer
11:43:27 <kawfee> well then how can I do it?
11:43:47 <ke> but in "itimesf :: Integer -> Float -> Float" ?
11:43:53 <shapr> in Haskell, type declarations are rarely necessary, since Haskell can usually infer the types automatically
11:44:16 <shapr> ke: in short, it means, takes one Integer, one Float, and returns one Float
11:44:46 <jlouis> longer version: takes one integer and returns a new function that takes one float and produces a float
11:44:51 <shapr> in long, the -> symbol really means "return a new function with one argument filled in"
11:45:00 <ke> ok, i understand
11:45:09 <ke> function returns a function
11:45:15 <shapr> so with add :: Int -> Int -> Int
11:45:28 <shapr> I could do "addOne = (add 1)"
11:46:00 <ke> is there a lambda statement too?
11:46:02 <shapr> yes
11:46:07 <jlouis> kawfee: dollar w a = (a, b, c) where ...
11:46:12 <shapr> (\x -> x + 1)
11:46:19 <kawfee> ahhh
11:46:36 <jlouis> which is another place where the -> symbol is abused ;)
11:46:43 <shapr> ke: Haven't I seen you on #python?
11:46:57 <jlouis> Python is ugly *hides*
11:47:07 <shapr> I like Python :-P
11:47:14 <ke> shapr: maybe
11:47:32 <shapr> ke: does that mean you already know about first class functions, map, etc?
11:47:44 <kawfee> ERROR "hw3.lhs":15 - Illegal Haskell 98 class constraint in inferred type
11:47:44 <kawfee> *** Expression : dollar
11:47:44 <kawfee> *** Type       : Integral [a] => Int -> [a] -> ([a],Char,[a],Int)
11:47:46 <steele> shapr: what would you use for web stuff in python? is there something smaller than zope?
11:48:00 <ke> shapr: i know about map but not sure about first class functions?
11:48:12 <shapr> steele: what do you want to do?
11:48:24 <shapr> steele: there are *many* web stuffs for python
11:48:37 <jlouis> kawfee: you should write a type definition to it: dollar :: <something>.
11:48:47 <steele> shapr: that's my my problem ;)
11:48:49 <shapr> ke: 'first class function' means you can put a function into a variable
11:48:56 <ke> steele: maybe spyce? i'm going to try to use it
11:49:12 <shapr> steele: what sort of web thingy do you want to build?
11:49:32 <ke> shapr: ok
11:49:44 <steele> shapr: login stats with DB backend
11:49:45 <shapr> so, if you've used map, then you know about first class functions.
11:50:15 <shapr> oh, you just want to generate html from a database?
11:50:31 <ke> shapr: great :)
11:50:43 <ke> is there a mysql module for haskell?
11:50:59 <shapr> there is one, but it's not yet stable.
11:51:04 * jlouis mumbles something about postgresql
11:51:14 <kawfee> jlouis: I tried that
11:51:26 <shapr> haskell has good odbc support on win32
11:51:27 <kawfee> dollar :: Int->Int->([Int], Char, [Int], [Int] 
11:51:38 <jlouis> kawfee: you neet to constrain to Integral
11:51:41 <jlouis> need
11:51:44 <jlouis> even
11:51:44 <ke> jlouis: the postgresql module works better?
11:51:46 <kawfee> what do you mean?
11:51:52 <jlouis> ke: dunno, havent tried
11:51:58 <jlouis> kawfee: do you know about type classes?
11:52:05 <kawfee> not really
11:52:19 <shapr> database libs on linux aren't that great yet, but I think they'll be usable in a month or two.
11:52:23 <jlouis> kawfee: type classes is what bites you there
11:52:42 <kawfee> so how can I get around it?
11:54:36 <jlouis> well the concept of type classes is simple: A type class is a set of types, which admit some kind of operation.
11:55:10 <jlouis> So, we have the type class Eq, for all types that admits equality, Ord for all types that admits ordering and so on
11:55:25 <kawfee> like the Num class?
11:55:28 <kawfee> I know of that
11:55:38 <jlouis> unfortunately I am not that fluent in Haskell yet, so I dont know what Integral precisely is
11:55:46 <kawfee> Num
11:55:49 <kawfee> Numeric
11:55:51 <jlouis> Num is the type class of Numbers
11:55:56 <jlouis> or Numeric
11:55:57 <kawfee> It's part of the Numeric class
11:56:51 <kawfee> maybe I have learned about them
11:57:22 <jlouis> mod is a member of Integral
11:57:43 <kawfee> ERROR "hw3.lhs":18 - Type error in application
11:57:49 <jlouis> so the type you take 'mod' on must be in the type class Integral
11:57:51 <kawfee> I think I fixed it, had forgotten a > 
11:57:56 <jlouis> hehe
11:58:04 <kawfee> *** Expression     : length b
11:58:04 <kawfee> *** Term           : b
11:58:04 <kawfee> *** Type           : Int
11:58:04 <kawfee> *** Does not match : [a]
11:58:28 <jlouis> b is an Int, length is defined on alpha lists
11:58:46 <kawfee> I just want the length of the integer string
11:58:55 <kawfee> variable a is an integer
11:58:59 <kawfee> and I want the number of digits
12:00:10 <jlouis> poor mans solution might be something like (length (show b)). Wise mans solution would be to rethink your algorithm
12:02:06 <kawfee> heh
12:02:26 <kawfee> ERROR "hw3.lhs":18 - Type error in application
12:02:26 <kawfee> *** Expression     : length show b
12:02:26 <kawfee> *** Term           : length
12:02:26 <kawfee> *** Type           : [a] -> Int
12:02:26 <kawfee> *** Does not match : b -> c -> d
12:03:57 <jlouis> use ()
12:05:36 <kawfee> maybe there is a integer to string function?
12:06:40 <kawfee> how can I print the variables without  the , in between?
12:07:50 <kawfee> how can you make a counter ?
12:07:59 <kawfee> I need someway of looping n times
12:08:43 <shapr> you could use until
12:08:48 <kawfee> > dollar w c =  a'.'b d
12:09:03 <kawfee> that is what I want the output to be, all the variables without anything in between
12:09:09 <kawfee> syntax?
12:09:30 <kawfee> I want to print out n '*' until a certain number is reached
12:09:45 <jlouis> the word 'loop' makes me tick
12:09:57 <jlouis> use recursion or some kind of list comprehension instead
12:10:51 <jlouis> kawfee: replicate 6 '*'
12:18:57 * shapr bounces
12:19:26 <kawfee> > dollar w c =  putStr(replicate w '*') (Show a) (putStr'.') (Show b)
12:19:29 <kawfee> is that legal?
12:19:38 <kawfee> where a and be are Integrals
12:19:40 <jlouis> nope
12:19:42 <kawfee> hrm
12:19:48 <kawfee> well that is what I want to do
12:20:05 * shapr keeps reading "Intercals"
12:20:20 * kawfee pokes shapr 
12:20:31 * shapr drinks kawfee 
12:20:42 <jlouis> kawfee: screw input/output if you are new to the language. IO takes monads to do
12:21:23 <kawfee> ERROR "hw3.lhs":15 - Improperly terminated character constant
12:21:37 * kawfee gets digested
12:21:42 * shapr snickers
12:21:43 <kawfee> monads?
12:21:48 <kawfee> would you like some cream?
12:22:56 <kawfee> how can I print the following:  ('$', replicate w '*', a, '.', b)
12:22:59 <kawfee> on opne line
12:23:07 <kawfee> without the (), and ' 
12:23:21 * dark wakes up.
12:23:31 <shapr> dark: must have been an awesome party
12:23:44 <dark> shapr: It was pretty cool :)
12:23:47 <kawfee> yay! I got it
12:23:52 <shapr> kawfee: what is it?
12:23:54 <kawfee> I bet I could map car over it somehow?
12:23:58 <kawfee> does haskell have map and car?
12:24:02 <shapr> it has map
12:24:11 <jlouis> kawfee: you use hugs right?
12:24:14 <kawfee> shapr: it's the return values
12:24:16 <kawfee> jlouis: yeah
12:24:32 <jlouis> kawfee: try to start the interpreter and type :type concat
12:24:38 <shapr> kawfee: one thing about tuples, they're their own type
12:24:43 <kawfee> Main> :t concat
12:24:44 <kawfee> concat :: [[a]] -> [a
12:24:48 <jlouis> kawfee: exactly
12:24:49 <jlouis> :)
12:24:55 <kawfee> so..
12:24:56 <shapr> so I'd make an explicit show function for a tuple like the above.
12:25:21 <jlouis> concat ["foo", "bar"]
12:25:38 <kawfee> hrm
12:26:18 <jlouis> kawfee: I'd play with the read-eval-print loop for a start :)
12:26:19 <kawfee> I have no idea what that means
12:26:34 <kawfee> this exercise is supposed to be easy
12:26:42 <jlouis> what is it about?
12:26:45 <kawfee> I may be doing it the wrong way
12:26:51 <shapr> kawfee: what he's saying is that you're writing a bunch of code, and then trying to fix the code..
12:27:05 <shapr> but it might be easier to get each small piece to work interactively in hugs first
12:27:15 <shapr> and then write the code with smaller pieces that already work
12:27:19 <kawfee> I have to take two parameters and print out the dollar amount, the first parameter tells how it should be justified, and the second one is the number of cents, I need to print it out like you would see on a check
12:27:33 <kawfee> I already divided and conquered
12:27:40 <kawfee> well I still need to conquer
12:27:46 * shapr grins
12:28:27 <jlouis> kawfee: ok, so you would create a function of type Integer -> Integer -> String
12:28:44 <jlouis> or (Integer, Integer) -> String
12:28:50 <kawfee> right
12:28:53 <kawfee> I got that
12:29:07 <kawfee> dollar :: Integer->Integer->String
12:29:11 <jlouis> exactly
12:29:14 <kawfee> I already have the string
12:29:19 <shapr> what are the ways it can be justified?
12:29:25 <jlouis> 100 cents is one dollar right?
12:29:41 <kawfee> dollar 10 250 outputs, $*****2.50
12:29:55 <kawfee> dollar 10 2 outputs $*****0.02
12:30:08 <kawfee> dollar 1 250 outputs $2.50
12:30:20 <shapr> ah, I see
12:30:23 <kawfee> yeah
12:30:27 <kawfee> take the first one...
12:30:35 <kawfee> Main> dollar 10 250
12:30:35 <kawfee> ('$',"**********",2,'.',50)
12:30:37 <kawfee> I have that
12:30:49 <kawfee> I have all the values in the ( ) now I need to extract
12:31:21 <jlouis> dollar w c = concat ["$", l, a, ".", b] where ...
12:31:26 <jlouis> could be a framework
12:31:35 <jlouis> l a and b still needs to be defined
12:31:54 <shapr> (\(a,b,c,d) -> concat [a,b,c,d])
12:31:54 <shapr> ?
12:32:05 * shapr is just guessing
12:32:36 <dark> Looks like using a tuple is making it more difficult.
12:32:40 <shapr> yah, I think so
12:32:44 <dark> I find that this is generally the case with tuples :-)
12:32:49 <shapr> I would stay away from tuples if I were you.
12:32:54 <shapr> they're a pain in the butt
12:32:59 <shapr> since they're a type, not a sequence
12:33:40 <dark> I tend to use tuples in only two contexts: when I actually want a Pair type, and when I'm constructing lists for use with "lookup".
12:33:59 <dark> oh, sometimes when I'm zipping lists together but then the tuples are implicit :)
12:34:03 <shapr> I tend to use tuples as heterogenous lists.
12:34:11 <whee> no easy way to convert tuples to lists?
12:34:16 <shapr> whee: nope
12:34:16 <dark> whee: Nope.
12:34:25 <whee> odd
12:34:26 <shapr> tuples are types, not sequences
12:34:29 * whee wonders how erlang does it D:
12:34:29 <dark> shapr: My grammar is faster than your grammar.
12:34:32 <shapr> :-P
12:34:42 <shapr> dark: I'm debugging at the same time
12:34:47 <shapr> well, trying to...
12:34:57 <shapr> and I just remapped my keyboard a few hours ago.
12:35:01 <dark> If I find myself making large tuples, it's often a sign to introduce a record type.
12:35:05 <shapr> yah, I agree
12:35:16 <jlouis> dark: indeed
12:35:21 <dark> shapr: Remapped?  Away from dvorak?
12:35:26 <kawfee> > dollar w c = (\e,w,a,r,b) -> concat[e,w,a,r,b]
12:35:26 <kawfee> >       where a = c `div` 100
12:35:26 <kawfee> >     b = c `mod` 100
12:35:26 <kawfee> >     d = w - (length (show b) + length (show a))
12:35:26 <kawfee> >     e = '$'
12:35:28 <kawfee> >     w = replicate w '*'
12:35:30 <kawfee> >     r = '."
12:36:14 <dark> kawfee: That doesn't look like it'll work syntactically.
12:36:28 <shapr> dark: nah, I unmapped home, end, pgup, pgdn, and replaced them with hyper_l, super_l, hyper_r, and super_r
12:36:33 <kawfee> it doesn't
12:36:41 <shapr> I've already moved shift onto delete
12:36:45 <dark> shapr: But... how will you do shift-pgup for scrollback?
12:36:57 <dark> shapr: So now you can do a double bucky?
12:36:58 <shapr> I don't know..
12:37:04 <shapr> what's a double bucky?
12:37:41 <shapr> theory: all modifier keys should be under my thumb, since pinkies were never designed to hold down modifier keys
12:38:07 <shapr> practice: buy a kinesis contoured keyboard, swap shift_l and delete, and unmap shift_r
12:38:10 <whee> hrmf, these conversions must be done in the VM with erlang
12:38:46 <dark> shapr: http://www.huis.hiroshima-u.ac.jp/jargon/LexiconEntries/Space-cadet_keyboard.html
12:38:47 <whee> yep, heh
12:39:11 <whee> just another reason we really should have TH in a release version of ghc :)
12:39:22 <shapr> dark: I want one of those..
12:40:05 <shapr> I've been trying to figure out how I can refactor my setup to get access to Alt as well
12:40:43 <shapr> I haven't quite gotten to the point of buying a hacksaw and soldering iron....
12:41:39 <shapr> I can actually hit S-H-M-C-# with one hand.
12:41:51 <dark> Heh, I can no longer find the original place where I read about the double bucky.  The Jargon dictionary has taken over google...
12:41:54 <shapr> two fingers even =)
12:42:00 <whee> is that the key sequence to move the cursor left in emacs?
12:42:01 <whee> :)
12:42:18 <shapr> no, that's the key sequence to delete all copies of vim in a three-mile radius.
12:43:46 * shapr laughs about quadruple-bucky-cokebottle
12:44:00 <dark> whee: Still a lot simpler than in vi :)
12:44:12 <whee> yes, simplier than hitting h :P
12:44:15 <dark> http://www.dina.dk/~abraham/religion/vi-tutorial.html "How to move the cursor one character forward in vi"
12:44:30 <steele> can't we all get along and make fun of ed users ;)
12:44:49 <shapr> truly :-)
12:45:17 <shapr> I'm just never quite finished with my keyboard layout and keybindings, there's always an improvement I'm thinking about trying.
12:45:37 <dark> ed users should never be made fun of.
12:45:39 <jlouis> shapr: you will grow older and stop fiddling
12:45:46 <shapr> I sort of doubt that.
12:45:48 <dark> To laugh about their misery is needless cruelty.
12:45:51 <shapr> jlouis: how old are you?
12:45:53 <jlouis> 22
12:45:54 <jlouis> :)
12:45:58 <shapr> how old do you think I am?
12:46:06 <whee> I'd say 72
12:46:10 <whee> :D
12:46:14 <shapr> :-P
12:46:18 <dark> (I know whereof I speak; I used ex for several years.)
12:46:18 <shapr> am I that cranky?
12:46:27 <jlouis> dark: hehe
12:46:35 <jlouis> I feel sorry for ed users
12:46:46 <shapr> jlouis: I'm 31
12:47:12 <shapr> I think I've grown out of most of the things I ever will grow out of.....
12:47:12 <jlouis> shapr: okie, you'll grow older and stop eventually. You scare me a bit, since I havent stopped fiddling yet :)
12:47:30 <shapr> why stop fiddling?
12:47:36 <shapr> that way lies the old people's home.
12:47:43 <jlouis> It takes a lot of time
12:48:02 <dark> What better to spend it on?
12:48:07 <shapr> yah, really
12:48:08 <jlouis> vi UnbalTree.lhs
12:48:14 <dark> jlouis is unmasked.
12:48:41 <shapr> I know people who learned as little as necessary to get by in high school, college, etc
12:49:34 <dark> shapr: Actually I assume they were learning other things.
12:49:35 <radix> hey, i'm in the channel you know
12:49:48 <dark> In some cases, the best way to drink a beer in 3 seconds, but still.
12:49:53 <radix> heh :D
12:50:33 <shapr> dark: we had 'study period' where we spent one class in the library.
12:50:56 <shapr> most people just stared out the window
12:51:05 <radix> i slept
12:51:19 <whee> haha
12:51:25 * radix was horribly dehydrated and tired through most of high school
12:51:28 <whee> I read books during that time D:
12:51:32 <dark> Heh, nice anti-java fuel linked to from slashdot: http://www.internalmemos.com/memos/memodetails.php?memo_id=1321
12:51:33 <jlouis> but had there been a computer with Haskell on, everyone would use the language today ;)
12:51:45 <jlouis> dark: I think it is a hoax
12:52:04 <shapr> the points made in that doc are valid, whether it's a hoax or not.
12:52:09 <whee> indeed
12:52:27 <shapr> I read books in study period also.
12:52:55 <shapr> I read through the library (very small school) and started checking books out from the college
12:53:52 <whee> I'm running out of things to read at the campus library already
12:55:18 <dark> I think it looks like an attempted power grab :)
12:55:20 <shapr> I think I've found an error in rfc822
12:55:40 <jlouis> shapr: they have no formal semantics. You probably have
12:55:58 <shapr> hm
12:56:01 <shapr> good point.
12:56:05 <whee> time to recompile ghc and hope it works :|
12:56:13 <shapr> go whee :-)
12:56:22 <shapr> next time I have build problems with ghc, I know who to ask.
12:57:42 <dark> shapr: Did you also look at rfc2822?
12:57:52 <shapr> not yet
12:58:15 <shapr> I figured I'd do rfc822 as a prototype, since I've never written a parser before.
12:59:14 <shapr> I'm regularly having to go rip out big chunks and rewrite them
12:59:21 <shapr> so I guess that was a good idea.
13:01:58 <Marvin--> "Hello World written in Java2 requires 9M for this most basic support infrastructure. By comparison, this is slightly larger than automountd on Solaris8." heh
13:02:08 <whee> heh
13:02:49 <shapr> "NOTE: The response to this e-mail was to suggest moving to a different build of Java 1.2.2 since the indicated build on Solaris 8 had a known bug; it should be noted, however, that the 9GB memory footprint for Solaris7 is still unusually large."
13:04:02 * shapr gives in and looks at rfc2822
13:04:21 <whee> I think you need to rewrite it in java :)
13:04:45 * shapr dislikes java very much
13:05:30 <whee> java reminds me of a crippled c++
13:06:15 <jlouis> The memory usage of those applications are exceptionally high
13:06:42 <jlouis> I think they never did think about how much memory their app is going to take
13:07:07 * steele should play a bit with http://nice.sourceforge.net/ some day
13:12:23 <shapr> hm, rfc2822 is a refactored rfc822
13:14:32 <jlouis> instance Ord k => Finitemap Tree k where... finished
13:17:06 <kawfee> how do you pass a list a parameter?
13:17:15 <shapr> huh?
13:17:26 <shapr> a list is data
13:17:28 <whee> eeh
13:17:46 <Fractal> Not always. Do you mean a lamda expression?
13:18:12 <Heffalump> a list is never a function
13:18:34 <kawfee> as a parameter
13:18:36 <kawfee> sorry
13:18:45 <Heffalump> just pass it
13:18:55 <Janni> Heffalump: a list is a function which takes no parameters and returns a list ;)
13:18:57 <kawfee> [ ] ?
13:19:06 <Heffalump> janni: ok :-)
13:19:09 <Heffalump> kawfee: wdym?
13:19:15 <kawfee> ?
13:19:20 <kawfee> wdym??????
13:19:25 <jlouis> what do you mean
13:19:30 <Janni> wha dafuck you meaning!
13:19:34 <kawfee> I need to pass a list to a function
13:19:43 <jlouis> you just do that
13:19:44 <kawfee> like func a = 
13:19:47 <kawfee> where a is a list
13:19:48 <whee> heh
13:20:12 <jlouis> you just do that
13:20:29 <jlouis> length [] = 0
13:20:43 <jlouis> length (x:xs) = 1 + (length xs)
13:21:10 <jlouis> but a list is nothing but a type
13:21:45 <Janni> GOOD BEGINNERS-TUTORIAL SERVICE: http://www.cs.ou.edu/cs1323h/textbook/haskell.shtml
13:28:14 <kawfee> ERROR "hw3.lhs":17 - Instance of Integral [Char] required for definition of dollar
13:29:32 <whee> hooray, ghc still doesn't compile  :)
13:29:38 <jlouis> kawfee: you could look at the solution I sent you privately
13:29:47 <kawfee> jlouis: yeah
13:29:52 <kawfee> I think mine matches it thouh
13:31:12 <kawfee> how can I turn an integer to a [Char]
13:31:24 <whee> show?
13:34:08 * Marvin-- goes mmm at his beer
13:34:26 <jlouis> > type DTable = (Integer, Integer, Trie (Tree Char) [Char] MacroBlock) <-- More type fun
13:34:36 * jlouis hacks on to his code
13:36:46 <Marvin--> heh, "snoc", nice operation name
13:38:06 <shapr> I can't get ghc to compile either :-(
13:38:18 <whee> heh
13:38:34 <whee> I'm going to stop trying until an official release
13:38:39 <whee> so no haskell for me until then :\
13:38:43 <shapr> it still complains that it can't deal with -march=athlonmp
13:39:23 <kawfee> Main> dollar 10 250
13:39:23 <kawfee> "$***2.50"
13:39:24 <kawfee> yay!
13:39:32 <kawfee> I got it to work
13:39:32 <jlouis> Marvin--: snoc, the reverse of cons ;)
13:39:43 <Marvin--> jlouis: I know, that's what so funny :)
13:40:00 <jlouis> Marvin--: Chris Okasaki is funny I think
13:40:15 <Heffalump> snoc is fairly standard, I think it's been around since well before Chris Okasaki
13:40:20 <kawfee> it's off by three though
13:40:24 <jlouis> Heffalump: ok
13:40:30 <jlouis> was not aware of that
13:40:47 <kawfee> I wonder why it's off by 3
13:40:49 <jlouis> Marvin--: I have some data structural bootstrapping in my code now :)
13:40:59 <kawfee> what will  d = w - (length (show b) + length (show a)) return?
13:41:12 <kawfee> or ==
13:41:22 <kawfee> oh wait
13:42:00 <kawfee> nm, I got it
13:42:24 <jlouis> kawfee: I think we will have a hard time helping you without even knowing what you are trying to do with the above
13:43:20 <dark> Obviously kawfee is trying to Get Rich Quick, with all this dollar code.
13:43:24 <Marvin--> SkewBinaryRandomAccessList...nice name
13:44:10 <jlouis> Marvin--: around the point where he introduces Myersstacks
13:44:39 * Heffalump disappears
13:44:46 <kawfee> what does the following mean: (<= m)
13:45:46 <kawfee>  n' >= n   = (<= m)
13:45:54 <kawfee> sorry, should have written the above
13:46:03 <kawfee> not quite sure how the  (<= m)
13:46:06 <kawfee> works
13:47:06 <dark> kawfee: It's a section.  (<= m) is equivalent to \x -> x <= m
13:47:16 <kawfee> ok
13:48:08 <dark> (+1) is the common example.  It's a function that adds one to its argument.
13:53:05 <kawfee> what does iterate do?
13:53:56 <dark> kawfee: It's best to look at the library to see what it does.
13:54:08 <dark> I think it's in the Standard Prelude; if not, it's in the List module.
13:58:30 <whee> heh, I hate that response :)
13:58:48 <whee> there should be an easy way to figure out what a function does given the name
13:58:49 <kawfee> hah
13:59:37 <dark> whee: It's haskell.  The easy way is to look up the definition :)
14:00:15 <whee> :p
14:00:33 <jlouis> it is amazing how much you can figure out by probing the type information
14:00:52 <whee> sometimes
14:01:11 <whee> given pie :: a -> b -> [(a, b)], ther's not much you can tell :)
14:01:31 <jlouis> whee: bad naming of the function
14:01:58 <Janni> yay! somehow "iterate (2*) 1 !! 7000" is fun :)
14:02:38 <dark> jlouis: apple_pie?
14:05:12 <kawfee> is ther a counter function?
14:05:25 <Marvin--> counter?
14:05:28 <whee> what do you want to do?
14:07:07 <kawfee> I want to make a variable i such that I can increment everytime I find an element
14:08:09 <kawfee> I need to iterate down a list and check it's elements
14:08:13 <Janni> kawfee: if you mean mine: iterate (2*) 1 = map (2^) [1..]
14:08:27 <whee> kawfee: perhaps a foldl?
14:08:37 <kawfee> what's a foldl?
14:08:46 <Marvin--> the typical way to do that is to use a state monad, but it's a bit tricky
14:08:59 <kawfee> I've made a counter in scheme
14:09:01 <kawfee> it's neat
14:09:06 <Janni> kawfee: you should really read a good tutorial
14:09:26 <kawfee> Janni: I'm in a class where we are learning haskell
14:09:38 <kawfee> I think I am doing things a tricky way or somehting
14:10:17 <Janni> kawfee: it's just that functions like foldl are quite basic (and mighty)
14:10:40 <kawfee> yeah, ok
14:11:29 <Janni> kawfee: look at Prelude.hs. Haskell code is easily understandable
14:11:45 <Janni> .oO(bad English again?)
14:12:03 <Marvin--> oh yeah, look at reverse, it's very easily understandable :P
14:12:12 <Marvin--> reverse xs = foldl (flip (:)) []
14:12:18 <Marvin--> er +xs
14:13:14 <Sluug_> hi there, how can i check a parameter, if it is i.e. a Int or another type ?
14:13:23 <dark> kawfee: Sounds like you just want to count the number of elements that match a certain condition?
14:13:30 <Janni> Marvin: in this case it isn't too hard, because the function name already implies its function
14:13:46 <Marvin--> Janni: sure, but it took at least me a while to work out how it did it
14:14:01 <Janni> Sluug_: you don't have to
14:14:12 <dark> Marvin: ghc's optimized reverse is actually easier to understand :)
14:14:22 <Marvin--> dark: oh?
14:14:45 <Sluug_> i know, the problem is, that ive to check, if its a variable or an konstant (selfdefined types)
14:15:11 <Janni> Sluug_: you really didn't get the point of functional programming.
14:15:19 <Marvin--> dark: what does it look like, then?
14:15:28 <dark> reverse l =  rev l []
14:15:28 <dark>   where
14:15:28 <dark>     rev []     a = a
14:15:28 <dark>     rev (x:xs) a = rev xs (x:a)
14:15:38 <Janni> s/didn't/haven't/ (correct English)
14:15:40 <Marvin--> ah
14:15:46 <Marvin--> standard tail recursion
14:16:14 <Marvin--> I guess that's pretty much what you get if you inline foldl in the definition of reverse?
14:17:04 <whee> haha
15:29:15 <shapr> hi Pseudonym 
15:34:48 <Pseudonym> G'day.
15:35:10 <Pseudonym> We should probably close off the jury mailing list archive.
15:35:37 <shapr> yah, I agree.
15:35:46 <shapr> I hadn't thought of that
15:36:10 <shapr> we have four jurors, heffalump doesn't have time, and I haven't heard from wli.
15:36:17 <shapr> I'd like to have an odd number to break any ties.
15:36:52 <Pseudonym> How about Chilli?
15:37:20 <Pseudonym> Or we could pick someone not in IRC. :-)
15:37:42 <shapr> the advantage of someone on irc is ease of communication
15:37:54 <shapr> at least, I think so...
15:37:55 <Pseudonym> True, but that's what the mailing list is for, surely?
15:37:58 <shapr> good point
15:38:08 <Pseudonym> We're going to have time zone problems anyway.
15:38:12 <shapr> yah, that's true
15:38:49 <shapr> chilli is a good suggestion
15:39:22 <shapr> I'll send him an email and ask him if he has time.
15:39:32 <shapr> any other suggestions in case he doesn't?
15:39:51 * Pseudonym thinks
15:40:37 <Pseudonym> I can think of a few non-IRC people to ask, but I have a suspicion they'd prefer to enter.
15:41:04 <Pseudonym> I know bjpop, for example, but I reckon he'd want to put in an entry.
15:43:07 <shapr> er, bjpop, the guy who wrote buddha?
15:43:18 <shapr> ah, yes.. of course 
15:43:23 <Pseudonym> Yes.
15:43:25 <Pseudonym> Bernie Pope
15:43:33 * Pseudonym tutored him as an undergrad
15:43:39 <shapr> shall we put him on the list after chilli?
15:43:55 <shapr> I'm also tempted to drop out and let the odd number be three
15:43:59 <shapr> that would speed up the process.
15:44:13 <Pseudonym> For the 0th contest that might be appropriate, if Chilli can't do it.
15:44:22 <Pseudonym> For the 1st contest, we'd want at least 5, I think.
15:44:31 <shapr> ok
15:44:37 <Pseudonym> I say _might_.
15:44:51 <shapr> I'm impatient as usual :-)
15:44:54 <Pseudonym> :-)
15:45:17 <shapr> ok, I'll talk to chilli, and if he's busy, let's decide on either three jurors or bjpop
15:47:16 <Pseudonym> OK.
15:51:27 <jlouis> =c 7
15:51:29 <jlouis> damn
15:51:36 <jlouis> mistype as usual
16:06:38 <num_tenho> where can i find a good example on how to use the ST monad?
16:07:17 <num_tenho> anyone?
16:08:17 <num_tenho> i'll wait
16:12:12 <shapr> num_tenho: http://www.haskell.org/pipermail/haskell-cafe/2002-January/002599.html
16:12:14 <shapr> what about that?
16:13:27 <shapr> num_tenho: I just put 'state monad haskell example' into google
16:13:30 <shapr> with no quotes
16:14:43 <andersca> shapr: sliff sloff
16:15:20 <shapr> eh?
16:21:10 <num_tenho> tanks shapr, lol
16:27:56 <shapr> sometimes I think the power of monads is just learning them.
16:28:17 <shapr> by the time you understand them, you've learned enough about writing combinators that you can do it yourself
16:28:45 <Pseudonym> I dunno.  Learning monads wasn't hard for me.  Learning how to implement them properly... that was nasty.
16:28:50 * Pseudonym still isn't all the way there
16:29:05 <dark> I still haven't figured out list monads.
16:29:09 <shapr> hi dark!
16:29:13 <Pseudonym> G'day.
16:29:26 <Pseudonym> Nondet monads make more sense than list monads, IMO.
16:29:34 <Pseudonym> dark: You mean you don't understand what they're for?
16:29:41 <Pseudonym> Or how to use them?
16:29:41 <shapr> dark: we've got four jurors, have you looked at the updated wiki page for new rules/ideas?
16:30:38 <dark> Pseudonym: Both :)
16:30:38 <Pseudonym> I think I'll add a "best abuse of category theory" award.
16:30:40 <shapr> Pseudonym added some good stuff and reorganized the page a bit.
16:30:41 <Pseudonym> As one possibility.
16:30:54 <shapr> Pseudonym: I hope you understand comonads, cuz I sure don't :-)
16:31:09 <shapr> what if someone hits us with some Arrow transformers?
16:31:11 <Pseudonym> I understand them a bit.
16:31:15 <shapr> I'll be lost without a compass =)
16:31:31 <Pseudonym> I'm still convinced that comonadic IO kills referential transparency.
16:31:38 * Pseudonym never got a straight answer on that one
16:31:42 <shapr> I'm almost tempted to drop out of the committee so I'll be able to submit Arrow transformers.
16:31:45 * shapr grins
16:31:53 <shapr> I must resist the temptation :-)
16:31:59 * Pseudonym laughs
16:32:31 <dark> Pseudonym: Wasn't an example given on one of the haskell lists?
16:32:56 <Pseudonym> Yeah, I gave it.
16:33:07 <Pseudonym> I have the impression that I'm one of the few people who read the paper and actually tried programming with the comonads.
16:34:11 <Pseudonym> I think the problem with comonads for IO is that very few operations if any are actually "projections".
16:34:22 <shapr> Haskell is the only thing in computers that has encouraged me to buy a printer.
16:35:07 <shapr> some of these research papers are worth many hours of work just to understand.
16:35:15 <Pseudonym> THis is true.
16:35:19 <Pseudonym> You learn a lot.
16:35:23 <shapr> truly
16:35:31 <shapr> I feel like a jedi ;-)
16:35:42 <Pseudonym> The paper wasn't worthless.  The codata section was very interesting.
16:35:46 <shapr> an ascetic programmer monk :-)
16:35:56 <Pseudonym> It put a lot of stuff we take for granted on a good theoretical basis.
16:36:04 <Pseudonym> ADTs, really.
16:36:23 * shapr gives in...
16:36:35 <shapr> is there a single comonad paper?
16:36:40 <shapr> or are there several?
16:36:41 <Pseudonym> Er...
16:37:44 <Pseudonym> http://citeseer.nj.nec.com/240567.html
16:37:49 <Pseudonym> That's the one I was referring to.
16:38:35 * shapr downloads
16:39:30 <Pseudonym> shapr, while I think of it, could you add me to haskell-libs please?
16:39:35 <shapr> sure!
16:39:55 <Pseudonym> Thanks.
16:40:01 <Pseudonym> I'm pseudonym, in case you couldn't guess.
16:40:14 <shapr> I think I asked you before :-)
16:40:21 <Pseudonym> Probably, yeah.
16:40:41 <Igloo> I remember the days when 3 people jumped up with the answer to technical questions you asked on OPN
16:40:53 <Igloo> Now they just seem to talk expletives to each other
16:40:59 <Pseudonym> OPN?
16:41:04 <shapr> Igloo: it's freenode now
16:41:07 <shapr> Igloo: what happened?
16:41:09 <radix> fuck off
16:41:09 <Pseudonym> Ah, right./
16:41:15 <Pseudonym> darn you
16:41:16 <shapr> radix: :-P
16:41:25 <Pseudonym> darn you all to heck!
16:41:29 * radix >)
16:41:30 <Igloo> It was OPN when you got useful answers  :-)
16:41:39 <shapr> Igloo: good point
16:41:50 <dark> Igloo: Presumably this varies by channel.
16:41:55 <shapr> Pseudonym: done
16:42:16 <Pseudonym> Thnaks.
16:42:31 * Igloo is trying to work out why time thinks I'm using 23s of system time but strace -c says a total of 0.2s is spent by syscalls; this could be because my idea of what system time is is wrong
16:42:33 <radix> Igloo: I've noticed that younger / smaller communities are much more likely to put more effort into helping random people
16:42:48 <Igloo> dark: I meant the generic linuxy channels, yeah
16:43:00 <dark> radix: They haven't been disillusioned yet :)
16:43:13 <shapr> I think it's a matter of the community policing itself.
16:43:24 <Pseudonym> System time includes time spent processing interrupts and other tasks running inside kernel space.
16:43:52 <shapr> if I start treating someone badly, I expect everyone else here to tell me to get over it and come back when I'm not pissy
16:44:01 <Pseudonym> Reclaiming memory, defragmenting IP packets, etc etc.
16:44:22 <Pseudonym> Actually, I think we tell you to go to sleep.
16:44:26 * shapr grins
16:44:30 <creature> radix - everyone here has been very good to me. It's quite refreshing. 
16:44:38 <Pseudonym> creature: You suck.
16:44:41 * shapr laughs
16:44:49 <dark> Pseudonym, get over it.  Go to sleep and come back when you're not pissy.
16:44:55 <creature> I've seen too many places reduce into just places for "RTFM". And an offensive RTFM at that.
16:44:57 * shapr laughs more
16:45:02 <creature> Pseudonym - heh. 
16:45:05 <Pseudonym> Actually, it's jsut about midday.  Sleep sounds pretty good right now.
16:45:10 <Igloo> Pseud: So how do I work out what's using all the time?
16:45:12 <dark> Haskell -- for the kinder, gentler RTFM.
16:45:17 <Igloo> (actually on topic as it's a Haskell program  :-)  )
16:45:21 <Pseudonym> Igloo: What OS?  Linux?
16:45:25 <Igloo> Yup
16:45:58 <dark> Igloo: If you do a write, then strace might count only the queueing time, while time counts all the time used to commit the write to disk.  (guessing)
16:46:35 <Pseudonym> Short answer is, I don't know.  I could tell you how to do it under Solaris.
16:46:46 <Pseudonym> Might have to turn on kernel profiling or something.
16:47:14 * Igloo doesn't recall seeing anything to do that
16:48:09 <shapr> Pseudonym: lambdabot is in cvs, I don't know if I already told you that.
16:48:13 <jlouis> if it is system time, you are counting how the kernel behaves
16:48:28 <Pseudonym> shapr: I saw it there.
16:48:39 <shapr> ok
16:48:54 * jlouis just found out he needs to add a typing system to his weave and tangle literate program
16:49:01 <jlouis> 2 types, so it is possible to do fast ;)
16:49:59 <Igloo> Actually, only rt_sigprocmask and sigreturn have non-trivial numbers of calls, so I guess it must be them
16:50:59 <shapr> hey, I've never submitted a news item...
16:50:59 <jlouis> signal handling?
16:51:06 <shapr> oh, I'll make a lambdabot news item
16:51:31 <dark> Igloo: Hmm, lots of sigreturn in a Haskell program sounds like garbage collection.
16:51:49 <Igloo> That's possible, I'll try forcing a heap size
16:51:55 <dark> Igloo: Do you get lots of SIGVTALRM?
16:52:26 <dark> Hmm, I guess you'll get those at regular times anyway.
16:52:45 <dark> jlouis: Call them () and [], just to confuse everyone?
16:53:02 <Igloo> 496 of them, 522 sigreturns
16:53:13 <Pseudonym> What punctuation doesn't Haskell use yet?
16:53:35 <Igloo> It covers it all with unicode symbols
16:53:40 <Pseudonym> Oh, I know.  We don't use the Windows key yet.
16:54:01 <Pseudonym> Call the types Windows-1 and Windows-2.
16:54:19 <whee> just start using unicode :)
16:54:38 <whee> Haskell2 should require unicode, heh
16:55:09 <Igloo> +RTS -M10M -H10M didn't help
16:55:36 <Pseudonym> Perfect, then.  Call your types MODIFIER LETTER REVERSED GLOTTAL STOP and CJK RADICAL MEAT.
16:55:43 * shapr entertains himself writing ad copy
16:56:49 * shapr chortles happily
16:57:17 <shapr> cool, haskell-libs is at 52% activity.
16:57:27 <Pseudonym> The 2% was probably you adding me.
16:57:33 * shapr grins
16:57:37 <Pseudonym> It was 50% when I previously checked.
16:57:51 <jlouis> dark: the types?
16:57:56 <shapr> speaking of which, I need to check in my rfc822 fixes from today.
17:00:39 <jlouis> it is funny, what I tried to do was to handle types in the syntax-tree converter. That surely hurts a lot
17:00:59 <jlouis> case-o-rama
17:01:23 <Pseudonym> What do you need the types for?
17:03:28 <jlouis> Pseudonym: Macros which produce files on the disk should not be able to be referred to by other macros. By ensuring this early on, I can kill a lot of tests later on.
17:03:40 <jlouis> s/by/from/
17:03:53 <Pseudonym> OK, makes sense.
17:05:23 <jlouis> I had so many case-sentences something said I should stop coding and think
17:05:44 <jlouis> 10 minutes later it hit me I was type checking in the middle of ''code-generation''
17:05:49 <jlouis> hehe
17:06:53 <Pseudonym> Good point.
17:07:14 * Pseudonym is looking through some of the unicode code point names to look for good ones to use in the future
17:07:22 <Pseudonym> I think I like KANGXI RADICAL DEATH.
17:07:41 <jlouis> hehe
17:08:25 <whee> EATH.
17:08:28 <whee> erf :(
17:08:51 <whee> one of these days I'm going to misclick and blow up the world.
17:09:28 <Igloo> Hmmm, as far as I can tell, of the 7680 rt_sigprocmask calls all but 1 have no effect
17:09:53 <Pseudonym> ELECTRIC ARROW sounds like an 80s disco-techno group.
17:10:24 * shapr grins
17:10:28 <Pseudonym> CYLINDRICITY.  That's a word I'll have to use in everyday conversation.
17:11:03 <Pseudonym> APL FUNCTIONAL SYMBOL UP TACK JOT.  Remind me not to read APL code to anyone.
17:11:09 <whee> haha
17:11:27 <Pseudonym> Even better: APL FUNCTIONAL SYMBOL LEFT SHOE STILE
17:11:56 <Pseudonym> RIGHT ANGLE WITH DOWNWARDS ZIGZAG ARROW is at least descriptive.
17:12:39 <Pseudonym> SQUARE FOOT sounds painful.
17:12:44 <jlouis> haha
17:13:23 <Pseudonym> DENTISTRY SYMBOL LIGHT UP AND HORIZONTAL WITH TRIANGLE.  I'll never look at my dentist the same way again.
17:16:13 <Igloo> "hsdebug is now starting to become useful." (cvs-ghc@haskell.org)
17:16:58 <shapr> how does it work?
17:17:08 <shapr> no, I should go to sleep instead....
17:17:11 <Pseudonym> Better than it did, apparently.
17:17:18 * shapr snickers
17:18:42 <Igloo> It uses speculatieve evaluation so it's almost debugging imperative code, I think
17:23:46 <Pseudonym> Lunch.
17:23:55 <shapr> sleep
17:26:20 <radix> `speculative evaluation' sounds way cool.
17:26:23 <radix> :-)
17:43:57 <dark> Heh.  The first utterance of eviltwin:
17:43:58 <dark> lol
17:44:12 <dark> Apparently it has learned everything it needs to know about IRC conversation :-)
17:44:18 <Igloo> :-)
19:59:19 <kawfee> Type error in application
19:59:19 <kawfee> *** Expression     : showTable n * facTableT (n - 1) (k + 1)
19:59:19 <kawfee> *** Term           : showTable n
19:59:19 <kawfee> *** Type           : Integer -> [Char]
19:59:19 <kawfee> *** Does not match : [Char]
19:59:31 <kawfee> I keep getting errors like this, and I keep trying to change the types
20:00:13 <whee> what's the type on showTable?
20:01:00 <kawfee> showTable :: Integer->Integer->[Char]
20:01:17 <whee> you're only giving it one argument in the code you just pasted before
20:01:40 <kawfee> showTable n * facTableT (n-1) (k+1)
20:01:43 <kawfee> I tried that
20:02:01 <whee> and that's wrong, because showTable n evalulates to Integer -> [Char]
20:02:09 <kawfee> then: showTable (n * facTableT (n-1)) (k+1)
20:02:12 <whee> which is not applicable to *
20:02:15 <whee> heh
20:02:23 <kawfee> and then I get a different error
20:02:30 <kawfee>  huh?
20:02:31 <whee> which is?
20:02:40 <kawfee> - Type error in application
20:02:41 <kawfee> *** Expression     : n * facTableT (n - 1)
20:02:41 <kawfee> *** Term           : n
20:02:41 <kawfee> *** Type           : Integer
20:02:43 <kawfee> *** Does not match : Integer -> [Char]
20:02:51 <whee> and what's the type on facTableT?
20:02:58 <kawfee> > facTableT :: Integer -> Integer ->[Char]
20:03:04 <kawfee> oh
20:03:05 <kawfee> wait
20:03:23 <kawfee> bah, that didn't work
20:03:32 <kawfee> I was thinking the parenthesization was messing it up
20:03:51 <whee> you can't possibly do this correctly with only three inputs
20:04:07 <kawfee> what do you mean
20:04:23 <whee> you have three inputs in the two lines of code you pasted, n, n-1, and k+1
20:04:29 <whee> while each function expects two inputs
20:04:33 <whee> you're missing one.
20:04:39 <kawfee> right, it does
20:04:43 <kawfee> I have three functions
20:04:47 <kawfee> the first one takes one arg
20:04:59 <kawfee> then it makes another arg and passes two params to the other func
20:05:46 <whee> bth facTableT and showTable are Integer -> Integer -> [Char] and you've only partially applied one of them in the code fragments you pasted
20:06:02 <whee> so you're attempting to multiply a function by a [Char] which really doesnt work
20:06:36 <kawfee> I see what you are saying now
20:06:50 <kawfee> I need one type of value until the last recursive step then I need a different
20:06:52 <whee> I think you're just moving terms around and not thinking about what you're doing
20:08:05 <kawfee> ok
20:08:17 <kawfee> what I want to be able to do is two function calls for an else statement, can I do that
20:08:26 <kawfee> like if.. then.. else func1; func2
20:08:57 <kawfee> I couldn't figure out how to do that so I tried a different way
20:09:03 <whee> for what reason? what would disregard the result of func1
20:09:21 <kawfee> I don't need a result
20:09:34 <whee> then why do the call?
20:09:44 <kawfee> oh wait..., I need the result on the way back up
20:09:53 <kawfee> showTable (n * facTableT (n-1) (k+1))
20:09:58 <kawfee> which is what I was trying to do 
20:10:03 <whee> that's entirely invalid
20:10:05 <kawfee> up or down, either
20:10:08 <whee> showTable expects two integer arguments
20:10:13 <whee> facTableT returns [Char]
20:10:21 <whee> n is an Integer, * is Integer -> Integer -> Integer
20:10:27 <whee> you're attempting Integer * [Char]
20:10:33 <whee> and even then it's a partial application of showTable
20:10:36 <kawfee> I see what you are saying
20:12:31 <whee> I don't see what you're trying to do
20:12:53 <kawfee> basicaly what I want to do is this: if n ==0 then I want to showtable, else I want to make a recursive call to facTableT and then after that call is made on the way back up I want to call showTable
20:13:38 <kawfee> I want showTable to be my return value, I just need facTable to send the results down through the recursion
20:13:55 <whee> what are the two arguments to showTable?
20:15:02 <Pseudonym> Can I ask what problem it is that you're solving?
20:15:23 <whee> I think it's factorial in some form
20:17:09 <kawfee> I'm trying to produce a factorial table
20:17:40 <kawfee> showTable n k  n is the factor and k is the number of factors that have been computed so far
20:17:53 <Pseudonym> What kind of table is it?
20:18:04 <kawfee> n    n!
20:18:12 <kawfee> 1     1
20:18:13 <Pseudonym> I mean how is it implemented?
20:18:14 <kawfee> so on...
20:18:27 <kawfee> want me to paste my implementation?
20:18:31 <Pseudonym> No.
20:18:33 <kawfee> ok
20:18:34 <Pseudonym> I'm just curious.
20:18:38 <Pseudonym> Is it an array or something?
20:18:42 <kawfee> no
20:18:47 <kawfee> something I guess
20:18:51 <whee> I think this can be done with a list comprehension, ending up with a list of tuples
20:18:52 <Pseudonym> Oh, you're just printing it out.
20:18:54 <Pseudonym> Gotcha.
20:19:02 <kawfee> yeah, I am printing it out
20:19:03 <whee> err, maybe foldl
20:19:13 <Pseudonym> whee: Yes.
20:19:26 <Pseudonym> [ (n, product [1..n]) | n <- [1..] ]
20:19:28 <whee> not sure which would be the quickc way
20:19:35 <Pseudonym> That isn't the quick way.
20:19:43 <Pseudonym> But I think that's the shortest.
20:20:57 <Pseudonym> I looked into fast factorial algorithms some time ago.
20:21:19 <Pseudonym> It turns out that for large n, a very odd effect comes into play.
20:21:46 <whee> anyway, it sounds like you just want to compute all the factorials and then display that at the end kawfee
20:22:05 <kawfee> yes,
20:22:15 <whee> so it's really quite simple
20:22:16 <Pseudonym> The multiply operation used in GMP does not work efficiently if you multiply a very large number with a very small one.
20:22:29 <kawfee> for a given n I want to produce a table from 0! to n!
20:22:39 <Pseudonym> It's more efficient if the numbers are of approximately equal size.
20:22:44 <Pseudonym> Very odd.
20:33:29 <whee> mmm that took me all of two minutes :)
20:38:53 <whee> oh, yeah
20:39:05 <whee> it was the foldl with the accumulator that would work well
20:39:17 <whee> can't remember the name of it :\
20:43:29 <Pseudonym> whee: Was yours a one-liner?
20:52:58 <Pseudonym> My solution is 88 chars including lots of whitespace.
20:53:10 <Pseudonym> And that includes the call to putStr.
21:42:55 <kawfee> \
21:42:57 <kawfee> hrm
21:43:07 <kawfee> well each line has to be right jsutified
21:43:14 <kawfee> is there a way to index into a list?
21:57:41 <Pseudonym> Right justified?  Ah, OK, my one-liner doesn't do that.
21:57:56 <Pseudonym> Yes, you can use !!
21:57:59 <Pseudonym> xs !! i
22:00:34 <Pseudonym> I run out of spaces around 60! or so.
