02:37:55 <Sucht`on|Hase> hi to all ! does anybody have a router before his connection ?
02:38:42 <Sucht`on|Hase> if so can you please have a try whether you can upload to ftp://lotux.homelinux.org/pub/incoming/ ?
03:45:47 <ibid> morning :-)
04:08:06 <shapr> g'mornin
04:08:38 <shapr> g'mornin
04:08:52 <shapr> well, maybe not good enough to say it twice.
04:08:57 <eivuokko> Good day.
04:09:10 <radix> Hello!
04:09:39 <shapr> hyv‰‰ huomenta!
04:10:28 <Marvin--> it's called "ugh"
04:10:30 * Marvin-- groans
04:10:59 <shapr> Marvin--: feeling good this morning?
04:11:33 <Marvin--> no :)
04:11:41 <Marvin--> but it was very fun last night
04:14:36 * shapr makes a small bounce
04:29:26 <Robert> Good day, shapr 
04:29:48 <shapr> good afternood Robert 
04:29:56 <shapr> god eftermiddag
04:31:14 <Robert> :)
04:31:25 <ibid> huomenta huomenta!
04:31:33 <ibid> iltap‰iv‰‰
04:31:47 <shapr> wassup?
04:32:06 <ibid> Debian bug#174853
04:32:16 * shapr looks
04:35:33 <shapr> ibid: whew
04:37:37 <ibid> reactions? :-)
04:38:50 <shapr> well, I think that points out the importance of up-front communication
04:38:57 <shapr> especially in package maintaining
04:39:16 <shapr> what packages of yours haven't been adopted yet?
04:40:34 <ibid> i think that's the last (there's sablecc, but i have somebody in miind for that)
04:40:48 <ibid> but i'm now reconsidering whetherr i wnt to give up greep-dctrl
04:41:02 <ibid> i probably would have given it to that guy if he  hadmn't stepped on my toes
04:41:03 <shapr> it sounds like you should hang on to it
04:41:09 <shapr> yah, I understand that.
04:41:10 <ibid> why?
04:41:46 <shapr> it sounds like you do still have enough energy for grep-dctrl
04:42:14 <shapr> at least, assuming interest == energy
04:42:25 <ibid> well, i have more than i had at the beginning of the year
04:42:30 <ibid> well, interest /= energy
04:45:58 <shapr> for men, interest does equal energy
04:46:23 <shapr> though things I'm less interested in tend to get overlooked.
04:46:43 <ibid> well, i am a man
04:47:00 <ibid> if you have other information, please share it with me ;-)
04:47:46 <ibid> interest may equal energy if you are not operating at 100 %
04:48:07 <shapr> er, that was a misspelling
04:48:08 <shapr> for "me"
04:48:09 <shapr> sheez
04:48:14 <shapr> I must not be awake yet
04:48:22 * shapr laughs
04:48:32 <ibid> or if you don't have any time-consuming long-term commitments...
04:48:39 <ibid> heh
05:00:39 <Hase^^on> //amsg\\\ Im going to bed ! cu in an hour or so
05:08:28 <jlouis> Q: When does one know he has programmed too much Haskell? A: When he uses == and /= in everyday IRC chat
05:09:17 <jlouis> or when he tries to fix a relationship by passing himself as a continuation
05:09:58 <eivuokko> heh
05:33:27 * shapr grins
05:37:27 <Janni> bonjour, mesdames et mademoiselles...
05:37:49 <shapr> bonjour, comment Áa va?
05:37:59 <shapr> parlez vous franÁais?
05:38:07 <jlouis> argh!
05:38:10 <Janni> oui, un peu
05:38:13 <jlouis> OCaml people in here?
05:38:17 <Janni> je suis bien
05:38:30 <shapr> jlouis: kanske #ocaml ?
05:38:40 <Igloo> I know some OCaml
05:38:50 <Igloo> (enough to know Haskell is better  :-P  )
05:38:53 <jlouis> it is a rather good language
05:39:00 * shapr grins
05:39:05 <jlouis> though I find Haskell more expressive
05:39:33 <Igloo> OCaml tries to trick you into writing imperative programs while you aren't thinking
05:39:38 <Janni> is there a pre-defined function to get the basename of a path?
05:40:36 <esap> igloo: Haskell does that also, to an extent [I've been writing monadic stuff that didn't need to be].
05:41:15 * shapr wonders if skylan is a bot
05:41:52 <Igloo> It is probably a pure monad, then, which isn't as bad, although I prefer not doing so if it's not necessary
05:42:16 <Janni> shapr: make the turing test.
05:42:27 * shapr grins
05:42:46 <shapr> I should run the code test on myself.
05:42:54 <shapr> Can I actually produce some useful code today? ;-)
05:42:57 <shapr> that would be more useful.
05:43:08 <Marvin--> SPJ's remarks about commutative monads make sense
05:43:29 <shapr> Marvin--: the stuff about a good notation for monads that don't need to be sequenced?
05:43:36 <Marvin--> yeah
05:43:43 <shapr> I noted yesterday that HBase already has commutative monads
05:43:49 <Marvin--> HBase?
05:43:56 <shapr> Ashley Yakeley's lib
05:44:01 <shapr> I think he's trying to replace the Prelude
05:44:07 <shapr> he's doing a good of it at least
05:44:26 <shapr> already has lots of Unicode support, appears to have all the Time functions that anyone could ever want
05:44:32 <shapr> it has XML parsing, MIME parsing
05:44:53 <shapr> it's worth looking at
05:45:26 <jlouis> Ashley Yakeley is quite intelligent
05:45:42 <shapr> yes he is...
05:46:03 <shapr> I suspect he's somewhat abrasive in person.
05:46:22 <shapr> though I'm beginning to wonder if that might be necessary to get stuff done.
05:48:32 * Igloo wonders if shapr thinks I'm abrasive
05:48:54 * Marvin-- doesn't even know what abrasive means
05:48:59 <shapr> no, I think there are two ways to get stuff done
05:49:13 <shapr> be abrasive, and you can get lots of people to do stuff along with you
05:49:29 <shapr> or ignore dissenters and do stuff by yourself :-)
05:49:30 <esap> I think the way to get stuff done is by doing it.
05:49:42 <Marvin--> esap: damn you're smart
05:49:48 * shapr grins
05:49:51 <esap> heh
05:49:53 <shapr> esap: truly
05:49:59 * shapr quotes that
05:50:29 <Marvin--> "skrovlig, irriterande"
05:50:30 <Marvin--> oh
08:00:16 <shapr> hi dark!
08:01:55 <dark> Hello :)
08:02:29 * Marvin-- is reading a 9M strace log
08:02:43 * shapr is starving
08:02:50 <shapr> must tear myself away from irc and get food!
08:03:45 <shapr> Marvin--: hws-wp is in haskell-libs cvs
08:04:10 <shapr> I wrote INSTALL and MAINTAINER files, and then hackishly threw the whole thing in
08:04:34 <dark> shapr: It's always sad when people die from overuse of irc.
08:04:48 * shapr laughs
08:04:54 <Marvin--> shapr: nice
08:05:25 <shapr> Marvin--: one of the items in the TODO file is to get the source of your report and turn it into real docs :-)
08:06:10 * shapr goes for food
08:08:46 <Marvin--> shapr: oh, I can mail you the .lyx file
08:13:29 <Marvin--> 118714 fewer lines
08:13:29 <Marvin--> eep
09:15:15 <shapr> um
09:15:41 <shapr> ?
09:18:07 <Hase^^on> sharp: hi
09:21:22 <shapr> hi!
09:53:37 * shapr bounce
10:19:24 <Janni> revertus sum (could this be right (long time ago))
10:25:40 <Igloo> "I'm back"?
10:37:35 <Janni> yah, but i'm not completely sure about the grammar (had latin 3 years ago in school. i should still know this...)
10:41:02 <Igloo> Well, I understood, which is the most important thing. And I didn't even do Latin  :-)
10:43:58 <Janni> even if i suffered learning latin i'm happy i did. thinking about it just "reverti" should work, too. revertus sum would be the somewhat emphasized version, but who cares dead languages? Haskell lives!
10:48:31 <dark> Janni: Oh, so you didn't mean it as code :)  I thought you were doing some clever haskell trick.
10:50:11 <Janni> dark: cool. programming and telling a story. i should do that :)
10:50:58 <dark> Janni: I think it was the "sum" that got me.  And the nested parens, of course.
10:52:15 <Janni> rabbits running in and out of here. strange...
10:52:42 <dark> Those are hares, actually.
10:53:19 <Janni> oh, nice to know
11:02:57 <esap> hmm.. what is this obfuscated haskell stuff ("best abuse of category theory"). Huh, that's tough.
11:55:11 <Hasilein> //amsg\\\ good night to all ! cu tomorrow ...
11:55:25 <ibid> Hasilein: could you clean up your away messages please
11:55:27 <ibid> augh
11:57:08 <dark> "Hasilein"?  Is this the same hare guy?
11:57:29 <Janni> ~camold@p3EE226ED.dip.t-dialin.net == ~bnccamold@pD9508B9D.dip.t-dialin.net? i think so...
11:58:42 <dark> Probably an NSA spy.
11:59:39 <Marvin--> the show yesterday made me want to pick up music again
12:09:34 <Janni> Marvin: what show?
12:12:21 <Marvin--> Janni: a student farce... I have friends on stage, in the orchestra and in the production
13:16:36 <Smerdyakov> The students here are a farce every day. ;-)
13:40:12 <buggs> funny what they get taught at yours then :-)
14:16:12 <esap> hmm.. what would be the best way to implement layering in Haskell?
14:20:11 <Marvin--> what do you mean?
14:21:19 <esap> I mean, I want to implement an OO-style data layering mechanism. Express it.
14:21:58 <esap> So that I could express programs that use that idiom at high level of abstraction.
14:26:18 <esap> Well, function composition is almost it. Monad bind operation is also close. But I think those do not accurately capture the idea.
14:28:22 <esap> I need to be able to express the idea that code at higher layers can depend on code at lower layers but not vice versa.
14:30:03 <Smerdyakov> What's data layering?
14:30:07 <jlouis> it is not computational, but you need to protect part of your code by namespace segregation and encapsulation
14:30:14 <jlouis> or am I wrong?
14:30:37 <jlouis> Smerdyakov: I am not familiar with the term either
14:30:58 <esap> jlouis: well I don't mean encapsulation. It's more like one interface built on top of another interface etc.
14:31:29 <jlouis> esap: and you are damn sure the class system in Haskell cannot do what you want?
14:32:04 <esap> jlouis: Well it might. But I don't know how.
14:33:06 <esap> think about protocol stacks. They are a classic example of data layering. THe low layers get the data in raw data. Then upper layers build more abstraction to it.
14:33:26 <jlouis> esap: You need to be certain, that your high level layer can access functions, f_1, ..., f_n in the low-level layer?
14:33:52 <Smerdyakov> I'm not sure this is a practice that requires special language support, esap.
14:33:54 <esap> jlouis: yes. And that low level layers cannot use the high-level layer facilities.
14:34:22 <esap> smerdyakov: no, I'd hope it doesn't require extra language support.
14:34:32 <jlouis> You can always get around it with dicipline
14:35:20 <esap> well sure. But I'd like to express the idiom so that it's easy to use. Like function composition is easy to use :-)
14:35:22 <Smerdyakov> esap, so, then... why are you asking here? =)
14:35:42 <Smerdyakov> In SML, you'd probably want to use functors....
14:37:40 <jlouis> mmmm, functors
14:38:15 <esap> Well, currently, the best I've come up with is to have separate interface for each layer, then build instances that depend on the next lower layer. But this does not seem to me like a clean solution.
14:38:45 <jlouis> esap: you should create a low-level class
14:38:56 <jlouis> and let the high-level class be constrained to it
14:40:26 <jlouis> be aware, though, that it is most effective when multi-parameter classes are allowed. Which they are not in standard Haskell 98
14:41:19 <esap> Well I've found out it's very hard to live without multi-parameter classes anyway.
14:41:27 <jlouis> yup
14:42:12 <jlouis> I am a C programmer originally. I dont care that much about code protection
14:42:42 <Smerdyakov> Any UK'ers here?
14:42:46 <esap> It's not about code protection. It's more like a way to structure the code.
14:43:22 <Smerdyakov> jlouis, saying "I'm a C programmer" here is like saying "I'm a nazi"
14:43:45 <whee> what's an assembly programmer then? :)
14:43:50 * whee likes assembly
14:43:52 <Smerdyakov> Retarded nazi
14:43:57 <whee> hooray!
14:44:22 <jlouis> hehe
14:44:36 * esap moved away from C++ after understanding sizeof.
14:44:45 <Smerdyakov> Saying "I use C" is fine
14:45:00 <Smerdyakov> But conceptualizing yourself mainly as "a C programmer" shows some major personal problens.
14:45:02 <Smerdyakov> problems
14:45:06 <jlouis> Smerdyakov: I saw the true path with SML. Though I think Haskell is superior in some respects
14:45:50 <jlouis> And yes, I use C, when it suits the cause. In this case it does not :)
14:47:07 <dark> I'm a C programmer.
14:47:13 <radix> get him!
14:48:01 * jlouis replaces dark with a very small higher order function
14:54:08 <esap> ok, here's a harder question: How should the language handle recursion? I think it's not done well currently [because of lack of good typing].
14:54:24 <Smerdyakov> Hrm?
14:54:43 <Smerdyakov> If we were talking about ML, I'd ask you if you meant recursive modules. =)
14:55:12 <esap> Heh, I'm talking about all uses of recursion, including recursive modules.
14:56:38 <esap> But I think the ordinary rule for fixed point is not well-typed, because you can easily hide infinite computation within values. You should not be able to do that.
14:57:17 <Smerdyakov> Heh. A usable type system that ensures program termination is not a trivial undertaking to design :D
14:58:29 <esap> I actually read a paper that (I understood) did close to that, by considering recursion as inverse to "swap" operation on pairs.
14:59:07 <Igloo> You can't guarantee termination of Turing complete languages can you?
14:59:27 <Smerdyakov> Right, I think =)
14:59:44 <esap> no you can't. But you can make the type system ensure that the responsibility for guaranteeing it in hard cases is placed on the programmer.
15:00:39 <esap> Or he may declare that the problem is too hard, and lose some useful properties from those programs.
15:01:14 <Smerdyakov> Hm.
15:01:17 <esap> But I have a problem with a type system that does this automatically by default.
15:01:21 <Smerdyakov> I don't know about that, esap.
15:01:24 <steele> esap: you're thinking about somethink like that: http://www.math.chalmers.se/~rjmh/Papers/popl-96.ps
15:01:50 <Smerdyakov> I think undecidability of halting means that no proofs exist for some programs, right?
15:01:55 <Smerdyakov> (proofs of halting)
15:02:02 <esap> true.
15:02:22 <Smerdyakov> Soooo.... you do lose something by ensuring halting, however you do it.
15:03:08 <esap> I think it's a compromise between getting the halting property and losing expressive power.
15:03:47 <esap> The question is who chooses which one you want.
15:04:23 <esap> Hmm.. the paper you cited seems very interesting. I have to look closer at that.
15:04:42 <steele> you lose something by using a static type system too, the question is how much you loose. with a language where termination is guaranteed you loose turing-completeness
15:04:53 <steele> s/loose/lose/
15:06:05 <esap> No I mean, I would like the language to offer both a terminating subset where good properties could be used and a non-terminating part where you get more expressive constructs.
15:06:25 <esap> It is not up to language designers to make this choice, IMHO.
15:06:47 <Smerdyakov> That's easy, esap.
15:07:09 <Smerdyakov> Create primitive recursion functions, give them to the user, and disallow recursion in his own functions.
15:08:40 <esap> My first idea was that you'd have a part that expresses I/O computations that could use general recursion and a subset for computing with values where only weaker constructs are allowed.
15:12:01 <esap> But then I bump into a paper by Hasegawa: "Recursion from Cyclic sharing" (http://citeseer.nj.nec.com/hasegawa97recursion.html). It seems to solve some problems.
15:13:40 <esap> But maybe I've just misunderstood the idea of that paper (the abstract doesn't interpret it that widely)
15:16:49 <jlouis> hmmm, I need to thread a monad through Happy now
17:13:59 <Smerdyakov> Are there any extensible IRC clients written in Haskell?
17:16:10 <Igloo> extensible in what sense (not as far as I know)
17:16:29 <Smerdyakov> Like mIRC scripting =)
18:42:26 <Pseudonym> There's lambdabot.
18:44:15 <Pseudonym> It's the only IRC client in Haskell that I'm aware of. :-)
22:14:26 <kawfee> det: hi
