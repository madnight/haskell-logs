01:25:46 <Marvin--> Failed to find interface decl for `ParsecPrim.GenParser'
01:25:46 <Marvin--> from module `ParsecPrim'
01:25:47 <Marvin--> ")/&¤#
01:31:09 <Marvin--> Great, helium's core parser can't read the files it produces
01:54:42 * Arnia bounces at his new DSEL
01:54:52 <radix> Bouncey bounce
01:55:29 * Marvin-- swears at people wanting to complicate d-i beyond reason
01:56:52 <Arnia> d-i?
01:57:32 <Marvin--> debian-installer
02:01:49 <Arnia> Ah
02:03:54 <Marvin--> why-oh-why would we need to prompt the poor user for *fallback languages*? Isn't one enough?
02:06:02 <Marvin--> well, I should be off
02:07:41 <mgoetze> lol@fallback languages
02:09:41 <Marvin--> well, it might be valid on, say, a Norwegian school system set up by an expert, you could have nb (norwegian bokmål) as primary language and fall back to nn (nynork) if programs lack nb translations
02:09:47 <Marvin--> but I hardly see it useful *in the installer*
02:11:19 * mgoetze thinks the right way to do it is just to make sure that no programs used during installation need a fallback...
02:11:25 <Marvin--> exactly
02:11:47 * Marvin-- tries to mediate the argument into asking the stupid fallback question with as low priority as possible, so only control freaks see it
02:12:15 <Marvin--> oh, right, I was going to leave, see you :-)
02:12:22 <mgoetze> bye!
02:57:12 * shapr bounces
02:57:50 <Arnia> shapr: Lots of logic good
02:58:05 <Arnia> shapr: Jackendovian unification good
02:58:12 * Arnia is please
02:58:19 <shapr> Arnia: quickcheck good
02:58:31 <mgoetze> postgresql good :)
02:58:40 <Arnia> All is good
02:59:20 <shapr> code is good
02:59:23 <shapr> math is good
02:59:36 * mgoetze wants to see someone rewrite www.mgoetze.net/~mgoetze/resultscgi.pl in haskell... that would be good
03:00:10 * Arnia goes to get a drink
04:31:01 <mgoetze> is it just me or did the iohc-jury list die?
05:23:42 * shapr boings
05:29:37 <mgoetze> shapr: get people to submit things to iohcc for my entertainment!
05:29:44 <shapr> um, ok!
05:43:34 <shapr> mgoetze: you have to advertise too!
05:45:32 <mgoetze> Riastradh: submit something to iohcc!
05:45:35 <mgoetze> shapr: i did :)
05:46:14 <shapr> yay!
06:45:18 <shapr> I want a refactoring browser for haskell
06:45:37 <mgoetze> shapr: rewrite my script first!
06:46:13 <shapr> eh?
06:46:19 <shapr> what script?
06:46:34 <mgoetze> shapr: www.mgoetze.net/~mgoetze/resultscgi.pl
06:46:35 <shapr> oh
06:46:41 <shapr> where's the source?
06:46:42 <mgoetze> shapr: i can query you the source if you want
06:46:50 <shapr> ew, it's perl
06:46:54 <shapr> sure, mail it to me
06:46:59 <shapr> you know my email?
06:47:07 <mgoetze> yeah
06:47:10 <shapr> ok
06:47:23 <shapr> I got QuickCheck to generate instance of Core
06:47:40 <shapr> now I need to generate something that won't throw a parse error everytime I stuff it into ghc
06:48:24 <mgoetze> sent
06:48:28 <shapr> cool
06:54:06 <mgoetze> shapr: recieved?
07:19:03 <shapr> mgoetze: no, not yet
07:22:15 * shapr bounces
07:26:05 <shapr> hi opet 
07:26:07 <shapr> how's the moo?
07:26:19 <opet> moo
07:26:48 <opet> I just made an imap folder of 8000 messages by mistake
07:26:56 <opet> and it's taking rather a long time to open
07:27:56 <shapr> yay
07:28:25 <SyntaxPolice> morning all.
07:28:40 <opet> yay indeed
07:30:08 <mgoetze> hi SyntaxPolice 
07:30:10 <shapr> is there a specific name for a tree map?
07:30:15 <shapr> like.. um
07:30:34 <mgoetze> SyntaxPolice: wanna haskellize my cgi script?
07:31:08 <shapr> mgoetze: still hasn't reached me
07:31:18 <mgoetze> shapr: weird
07:32:30 <jlouis_> shapr: You mean a Ordering constrained FiniteMap ;)
07:32:51 <shapr> I do?
07:32:57 <jlouis_> tree map?
07:32:58 <mgoetze> www.mgoetze.net/~mgoetze/resultscgi.txt
07:33:22 <shapr> jlouis: I was thinking of running a map on a tree structure so that it hits all the leaves
07:33:26 <mgoetze> if anyone wants to haskellize that... ;)
07:33:40 <jlouis_> yeah, but hits the values right?
07:33:54 <jlouis_> or you are going to destroy your ordering pretty surely ;)
07:33:55 <shapr> er
07:34:04 <jlouis_> class Functor?
07:34:11 <jlouis_> fmap?
07:34:14 <shapr> yah
07:34:46 <shapr> I could write an instance of Functor that operated on an algebraic Tree type, and would apply itself to the entire set of nodes in a tree, right?
07:35:03 <jlouis_> yes, but beware of changing the keys
07:35:18 <shapr> well, assuming it's just a bunch of trees in a list, it wouldn't be a problem, right?
07:36:11 <jlouis_> depending on how your f function is
07:36:17 <jlouis_> map f <target>
07:37:04 <shapr> hm
07:37:12 <shapr> mgoetze: that's pretty scary code
07:37:44 <mgoetze> shapr: what's scary about it? the sql, the perl, or the html?
07:37:54 <shapr> the perl part
07:39:27 <mgoetze> hm
07:40:15 * mgoetze can't see what's particularily scary about it... it just grabs the output of a program, substitutes something, and dumps it to stdout with some html wrappings
07:43:20 <SyntaxPolice> mgoetze: how hard is the cgi script?
07:43:46 <SyntaxPolice> mgoetze: hmm. it has sql?
07:43:49 <mgoetze> SyntaxPolice: in perl, incredibly easy. in haskell, i don't know.
07:44:01 <mgoetze> SyntaxPolice: it uses an external program for all the sql grunt work
07:45:15 <shapr> perl scares me =)
07:45:23 * mgoetze waits for SyntaxPolice to download code from webserver
07:45:40 <mgoetze> shapr: this is a really harmless specimen ;)
07:46:00 <shapr> yah, I agree
07:46:17 <shapr> I did some for-pay perl database library support once long ago
07:46:48 <mgoetze> ooh... perl database libraries are very chewy.
07:46:55 <shapr> mgoetze: have you tried rewriting this in haskell?
07:47:11 <shapr> wash/html has spiffy html combinators
07:47:30 <shapr> you could do the same regex tricks in the haskell version
07:48:07 <mgoetze> shapr: i've never done anything like it in haskell and was hoping someone could show me how it's done
07:48:22 <SyntaxPolice> mgoetze: I can't really take the time right now. maybe if I get bored later today?
07:48:56 <SyntaxPolice> did you want to use the cgi library, or just wanted a haskell example?
07:48:58 <shapr> I get the best support here when I do as much as I can first, and then ask someone to look at what I have so far.
07:48:59 <mgoetze> SyntaxPolice: sure, sometime while i'm sleeping :)
07:49:01 <andersca> hey shapr
07:49:06 <shapr> hi andersca, what's up?
07:49:11 <mgoetze> SyntaxPolice: i wanted any working haskell code :)
07:49:13 * SyntaxPolice played diplomacy for the first time recently
07:49:19 <mgoetze> oh, neat
07:49:21 <andersca> shapr: seen my blog? it's got a picture of koen ;)
07:49:27 <shapr> andersca: where where??
07:49:35 <andersca> http://carbon.hemmet.chalmers.se/Blog/
07:49:56 <shapr> cool!
07:50:15 <shapr> does he know he's pictured on your blog? :-)
07:50:40 <andersca> don't think so 
07:50:52 <mgoetze> SyntaxPolice: see www.mgoetze.net/~mgoetze/resultscgi.pl - and that's just a small excerpt from the tournament scene
07:51:09 * shapr looks for pictures of andersca 
07:52:12 <jlouis_> is that some kind of pornomodel that andersca thing?
07:52:26 <andersca> shapr: there's one at http://www.gnome.org/~gman/photojournal/
07:52:28 <andersca> for example
07:52:54 <andersca> shapr: how's the weather in boden?
07:52:59 * mgoetze notes that shapr and SyntaxPolice use the same version of the same browser :)
07:53:36 <shapr> andersca: getting warmer.. all the snow is melting.
07:53:43 <shapr> andersca: how's the south?
07:53:57 <shapr> andersca: which one of those is you?
07:54:13 <shapr> aha
07:54:16 <shapr> anders
07:54:43 <shapr> with beer
07:54:45 <shapr> http://www.gnome.org/~gman/photojournal/images/anders-800x600.jpg
07:54:46 <andersca> the one with the big beer glass
07:54:46 <andersca> yeah
07:55:29 <shapr> cool!
07:55:41 <shapr> are you going to show up at ICFP/HW in Uppsala?
07:55:48 <andersca> when's that?
07:56:11 <shapr> um, end of august
07:56:31 <shapr> http://www.functional-programming.org/HaskellWorkshop/cfp03.html
07:56:48 <shapr> immediately following http://www-users.cs.york.ac.uk/~colin/icfp2003.html
07:56:54 <Smerdyakov> That's lame.
07:57:02 <shapr> Smerdyakov: what, you don't like beer?
07:57:04 <Smerdyakov> That guy uses www.functional-programming.org for his home page.
07:57:21 <shapr> well, I guess no one else had it..
07:57:28 <Smerdyakov> Well, it's an ugly domain, anyway =)
07:57:31 <shapr> I seriously thought about getting monad.org recently =)
07:57:50 <Smerdyakov> I already got my dream domain a year ago: schizomaniac.net
07:58:02 <shapr> I want erisson.com
07:58:10 <shapr> sadly, someone else got it first
07:58:18 <Smerdyakov> Why do you want that?
07:58:34 <shapr> because it's my last name.
07:58:35 * mgoetze would have liked goetze.de, but of course, that wasn't to be had.
07:58:45 <Smerdyakov> That explains why they let you into Scandanavia =D
07:58:54 <shapr> Smerdyakov: well, it's not the one I started with...
07:58:56 <shapr> hi mindcrime_work 
07:59:09 <shapr> used to be gilliam
07:59:14 <shapr> but that was boring.
07:59:16 <Smerdyakov> shapr, hm... are you male?
07:59:21 <shapr> Smerdyakov: why do you ask?
07:59:33 <Smerdyakov> To understand if you changed it by marriage, as is the USA custom
07:59:42 <shapr> I did not change it by marriage.
07:59:50 <Smerdyakov> You did some unusual legal thing?
07:59:59 <shapr> yah, I did.
08:00:27 <Smerdyakov> Should have chosen Abomination King when you had the chance
08:00:31 <shapr> heh
08:00:36 <shapr> nah, I like the one I have :-)
08:00:58 <SyntaxPolice> mgoetze: shapr has good taste.
08:00:58 <mgoetze> shapr: should have looked out a domain name first, *then* changed your name...
08:01:07 <shapr> haha
08:01:08 <mgoetze> SyntaxPolice: bah :P
08:01:29 <mgoetze> so, if my perl code is so ugly, someone turn it into pretty haskell code!
08:01:44 <shapr> mgoetze: you try it, we'll heckle you from the sidelines? ;-)
08:02:11 <mgoetze> shapr: no, i'm going home very soon, and then i will sleep for about 24 hours. :P
08:02:15 <shapr> oh, ok
08:02:23 <shapr> well, if you start converting it, I'll help some :-)
08:03:03 <mgoetze> maybe another day
08:03:07 <shapr> ok
08:03:21 <mgoetze> but probably i'll produce more perl code instead, so don't get your hopes up :)
08:03:31 <shapr> ah well
08:04:23 <mgoetze> unless someone shows me a cool haskell/pgsql interface
08:04:35 <shapr> there's HToolkit
08:04:51 <shapr> Daan said he was thinking of putting HaskellDB on top of it
08:04:54 <shapr> that would *rock*
08:05:00 <shapr> no SQL required, only set operations
08:05:35 <shapr> I don't know how far he's gotten thouh.
08:05:54 <shapr> last I checked, I could use HToolkit to do SQL queries, but anything out of place crashed
08:06:19 * mgoetze already had a long adventure trying to use guile with pg
09:17:10 <shapr> hi hal
09:17:16 <shapr> hi redcrosse 
09:17:18 * shapr bounces 
09:18:30 <redcrosse> hello shapr
09:19:34 <shapr> what's up?
09:19:39 <shapr> exciting life?
09:19:48 <redcrosse> just reading about relational databases
09:19:49 <redcrosse> you?
09:19:53 <shapr> same actually
09:19:59 <shapr> playing with HToolkit
09:19:59 <redcrosse> ooo
09:20:08 <shapr> looking at the Postgresql support
09:21:14 <redcrosse> think any more about trucks?
09:21:42 <shapr> a bit
09:21:47 <shapr> but I haven't messed with that source
09:21:54 <shapr> I'd like to put up something for that page
09:22:05 <shapr> more trucks for you?
09:22:22 <redcrosse> heh, that got said by the soup nazi in my head
09:22:29 <redcrosse> no trucks for you!
09:22:49 <redcrosse> umm, it lead me to read more about where type classes came from
09:23:01 <redcrosse> but i didn't spend much time on that problem in particular
09:25:11 <shapr> how would you model a truck and tires that can have their pressure checked?
09:29:44 <shapr> I've writted simple types
09:29:55 <shapr> and a typeclass
09:30:01 <redcrosse> yeah, i'd probably do that
09:30:07 <shapr> I still don't really know what to do with the functional dependencies thingy though
09:30:09 <redcrosse> but i think i'd need more info
09:30:36 <redcrosse> i mean if that's all the functionality you need, then it seems pretty easy
09:30:57 <shapr> well, part of the challenge could be to see how simple it is to extend the various modelling techniques
09:31:04 <shapr> that could be very nifty 
09:31:29 <redcrosse> yeah, that would be neat to see
09:32:21 <redcrosse> i'd like to see teams representing various paradigms model and implement a problem
09:32:26 <redcrosse> and write up there steps
09:32:29 <redcrosse> their
09:32:35 <shapr> yah, me too
09:34:59 <esap> I think the problem description already assumes some way of approaching the problem (the truck and tires example, I mean).
09:36:04 <shapr> http://kungens.kemi.fi/~shae/src/haskell/Truck.hs
09:36:08 <shapr> that's what I've got so far.
09:36:27 <redcrosse> what's the wiki page again? FpVsOo?
09:36:33 <shapr> yah, I think so
09:36:40 <shapr> http://c2.com/cgi-bin/wiki?FunctionalIsPoorAtModeling
09:38:14 <shapr> esap: how would you model it?
09:40:15 <esap> shapr: well, I could use many different ways of modelling it. You could start from describing a data view, a functional view, a abstraction view etc. Then look at all of them and decide how to model it.
09:40:42 <shapr> what do you think about the stuff I put in Truck.hs ?
09:40:52 <shapr> do you think that accurately describes any of those?
09:41:55 <esap> Well to me, it's not clear whether it does actually capture what is intended. It does describe *one* way of seeing things.
09:42:12 <shapr> do you any suggestions for improving it?
09:42:53 <esap> Yes, what if you get new types of tires? What if you need new information from different tires?
09:43:28 <esap> The problem is, to me it's not clear what parts must be extended in various ways.
09:43:37 <redcrosse> yeah
09:43:48 <hdaume> random emacs question (probably for shae): when i run shell mode, if i type a command (like 'ls'), before it executes the command, it re-echos it on it's own line...how can i disable this behavior?
09:44:10 <shapr> yay, I'm a famous emacser!
09:44:19 <shapr> hdaume: using eshell?
09:44:27 <hdaume> yeah
09:45:05 <shapr> hdaume: er, wait.. M-x shell or M-x eshell ?
09:45:13 <hdaume> oh.  sorry, no, just shell
09:45:47 <shapr> I don't know, I only use eshell
09:45:48 * shapr looks
09:45:49 <hdaume> shapr: i just tried eshell and it seems to be better than shell anyway, and doesn't have that problem...i'll just use that :)
09:45:54 <shapr> eshell r0xx0rs
09:46:21 <shapr> I've bound eshell-toggle-cd to a key, it's very useful
09:46:31 <hdaume> what does that do?
09:46:49 <shapr> it jumps into the dir that contains the file for the buffer you're working on
09:46:59 <shapr> hit a 2nd time, eshell is full screen
09:47:08 <shapr> 3rd time, it goes back to before you hit it the first time.
09:47:22 <shapr> as in, restores your window configuration
09:47:37 <shapr> also, you can freely mix elisp and shell commands in eshell
09:47:44 <shapr> makes for some very cool tricks
09:47:58 <hdaume> cool
09:48:22 <shapr> have you seen EmacsNiftyTricks on emacswiki.org ?
09:48:38 <hdaume> nope
09:49:24 <shapr> hdaume: http://emacswiki.org/cgi-bin/wiki.pl?EmacsNiftyTricks
09:49:36 <shapr> since I wrote most of that page, I'd be happy to help you with any specific questions :-)
09:49:45 <shapr> hello EtherNet 
09:49:53 <EtherNet> hello
09:49:57 <shapr> does irc count as CSMA/CD ?
09:50:27 <shapr> EtherNet: learning Haskell? long-time user?
09:50:57 <shapr> esap: the Tire typeclass allows for easy extension
09:50:57 <EtherNet> shapr no no.. even I do not know what it is
09:51:15 <shapr> EtherNet: it's a programming language. 
09:51:30 <EtherNet> shapr I imagined
09:51:40 <shapr> you can find info from http://www.haskell.org/ and you can ask questions here on #haskell as well.
09:52:11 <EtherNet> thanks you
09:52:16 <EtherNet> does it have networking support ?
09:52:18 <EtherNet> for example
09:52:37 <shapr> yes, it does.
09:52:46 <shapr> support for tcp/ip v4
09:52:51 <EtherNet> very nice
09:53:00 <EtherNet> how is it? easy ?
09:53:04 <EtherNet> does it seem to C ?
09:53:10 <esap> shapr: well sure. It does. If your extensions are to the getPressure operation.
09:53:10 <shapr> no, it's very far away from C
09:53:28 <shapr> esap: ah, an extensible typeclass somehow?
09:53:36 <shapr> EtherNet: have you used lisp or scheme?
09:53:42 <EtherNet> shapr a bit
09:53:55 <shapr> in those languages, functions can be values just like numbers
09:54:00 <EtherNet> shapr is it compiled or interpreted 
09:54:02 <EtherNet> ?
09:54:06 <shapr> it can be both
09:54:15 <shapr> there are compilers and interpreters
09:54:17 <emu> anything can be both
09:54:23 <EtherNet> shapr have you made some app ?
09:54:31 <shapr> I have made some code, would you like to see?
09:54:44 <EtherNet> shapr yes
09:54:59 <EtherNet> I was checking this: http://www.cs.chalmers.se/~rjmh/QuickCheck/QuickCheck.hs
09:54:59 <esap> shapr: no. I mean maybe you would want to extend the *kinds* of pressure you have [like new formats to represent pressure, if your choice of integer doesn't work well?]
09:55:00 <shapr> the first thing I wrote in Haskell --> http://kungens.kemi.fi/~shae/src/haskell/Mandelbrot-0.1.hs
09:55:23 <shapr> EtherNet: I use QuickCheck, it's a very cool piece of software.
09:55:29 <esap> shapr: or maybe you want to extend the properties of *michelin* tires?
09:55:41 <shapr> esap: how would you do that in Haskell?
09:56:19 <shapr> with the pure type example, Pressure could be a unified type
09:56:36 <shapr> data Pressure = Integer | Double
09:56:41 <EtherNet> shapr it looks pretty good
09:56:44 <shapr> something like that would let you add more types of pressuer.
09:57:08 <shapr> hdaume: nice hostname, when did you get that?
09:57:34 <esap> shapr: yes, that would work. What I'm saying is that the requirements are not clear, therefore I cannot choose a particular solution.
09:57:38 <Joerg> Hey Guys
09:57:45 <shapr> hi Joerg
09:58:03 <Joerg> I've got a problem with haskell lists....lets say i'm a newbie....
09:58:41 <emu> assume that Joerg is a newbie
09:58:44 <esap> shapr: or have to be prepared for all kinds of extension.
09:58:50 <emu> prove by contradiction that this is not true
09:58:53 <shapr> EtherNet: here's a basic echo server in Haskell: http://kungens.kemi.fi/~shae/src/haskell/Echo2.hs
09:59:24 <Joerg> Can someone explain to me, how i gain access to elements of a data structure....for example:
09:59:49 <emu> then write a constructive proof
10:00:01 <esap> shapr: and to me, preparing for all kinds of extensions will result in a bad design.
10:00:03 <shapr> esap: truly, I can't find a simple way to extend Michelin tires directly.
10:00:08 <shapr> esap: that's a good point.
10:00:38 <Joerg> data Flight = MKFlight Source Destination Time 
10:00:50 <Joerg> how gain i access to Time....????
10:01:04 <emu> patty match
10:01:56 <shapr> esap: I agree.
10:02:20 <shapr> even so, I'd like to have a bunch of different ways that Truck and Tire could be modeled in Haskell.
10:02:31 <shapr> just to show the unbelievers on TheWiki
10:02:41 <Joerg> hmh can you explain it more in detail ?
10:02:50 <shapr> Joerg: pattern matching
10:03:03 <shapr> data Tires = Michelin Pressure | Pirelli Pressure
10:03:06 <shapr> checkPressure (Michelin pressure) = pressure
10:03:09 <Joerg> i know.....
10:03:53 <hdaume> or even better: data Tires = Michelin { checkPressure :: Pressure } | Pirelli { checkPressure :: Pressure }
10:03:58 <esap> shapr: ok, I guess I can do a couple of ways you could model tires, pressure and the car.
10:04:56 <shapr> hdaume: cool, I'll add that.. are those are records?
10:06:22 <esap> shapr: class Tire a where createTire :: Pressure -> a ; getPressure :: a -> Pressure     How about that?
10:06:40 <shapr> hm, neat
10:07:39 <esap> the one problem with that is that it will cause some problems for the user (he has to choose a representation, that is, getPressure (createTire x) does not work.
10:09:31 <esap> shapr: Another approach is: class Tire a where getPressure :: a -> Pressure. class TireFactory f where createTire :: f a -> Pressure -> a
10:10:02 * shapr adds that also
10:10:25 <esap> shapr: you could embed Pressure in the factory as well, so that constructing factory will be the place where the pressure is required.
10:10:31 <shapr> this is neat, could show OO programmers designs from very simple to more complex
10:12:12 <emu> objection oriented
10:12:26 <shapr> heheh
10:12:26 <shapr> truly
10:12:42 <emu> oddball oriented
10:13:25 <esap> shapr: then you could have a design where a car encloses all tire and pressure handling: class Car c t where getTires :: c -> [t]; getPressure :: c -> t -> Pressure 
10:14:47 <esap> shapr: or you could use class Car c where getTires :: c t -> t ; getPressure :: c t -> t -> Pressure
10:14:59 <esap> shapr: I mean getTires :: c t -> [t]
10:15:55 * shapr adds all this
10:16:32 <esap> shapr: but that has a problem that it does not properly describe the connection between a tire and a car [or you have to handle error cases where you ask a pressure from a tire that is not in the same car that you specified :-)]
10:17:50 <esap> shapr: the big question is whether a specification of a tire describes uniquely which car it was taken from or whether it's independent.
10:18:05 <shapr> hm, interesting point.
10:18:35 <shapr> http://kungens.kemi.fi/~shae/src/haskell/Truck.hs
10:18:38 <shapr> lots more there now
10:20:31 <shapr> I think this should keep the FunctionalIsPoorAtModeling guys busy for a bit.
10:20:46 <shapr> Joerg: did that explanation help you?
10:21:18 <shapr> esap, hdaume: thanks for the help and code :-)
10:21:51 <Joerg> shapr: hmh  found much about patty match, but i dont know how to use your hint.....
10:22:13 <esap> shapr: those all have quite different characteristics. And It's really hard to choose between all the alternatives. And it does not even begin to describe what kinds of issues you might have with modelling that.
10:24:27 <shapr> Good Day Mr. Sjögren.
10:25:01 <shapr> esap: I think it's good to make some of those explicit in the code so that other people can get a rough idea of the issues that are seen in FP
10:25:59 <esap> shapr: hmm.. actually, now that I think more closely, I think the TireFactory case does not quite work that way (it might be hard to define instances of that class).
10:27:17 <shapr> I think I'll paste the code into a wiki page so we can all edit it.
10:31:14 <ludde> how many different possible integer values are there for x_1,x_2,...,x_n such that x_i >= 0 and sum(x_i) = N ?
10:31:59 <shapr> esap: http://c2.com/cgi-bin/wiki?FunctionalModelingExamples
10:32:24 <esap> ok, I'll edit that.
10:32:31 <shapr> esap: did I mispell your name? I thought you have a wiki page?
10:33:26 <esap> hmm.. I guess I don't have.
10:39:02 <hdaume> ludde: do we know anything about how N compares to n or n^2?
10:39:32 * esap did some edits, forgot about the two-word rule :-(
10:43:18 <esap> hmm.. can you get rid of those question marks on it somehow without breaking Haskell's naming rules? :-)
10:43:37 <shapr> yes, use six ''''''
10:43:44 <shapr> between words to break up the matching rules
10:43:50 <shapr> gotta go exercise, bbl
10:48:14 <ludde> hdaume: no..
10:48:35 <ludde> hdaume: but n is typically much smaller than N
10:48:43 <ludde> hdaume: but i don't want to restrict the proof
10:51:01 <ludde> my guess is N+n-1 over n-1
10:51:03 <ludde> but i'm not sure
10:51:08 <ludde> err
10:51:11 <ludde> my guess is N+n-1 choose n-1
10:52:07 <hdaume> are these positive integers or non-negative integers?
10:52:21 <ludde> n and N are positive
10:52:29 <hdaume> but can x_i be 0?
10:52:34 <ludde> yes
10:54:55 <hdaume> i don't think there's a closed form solution.  you can calculate it fairly straightforwardly using dynamic programming though... i could be wrong though.
10:55:02 <ludde> hmm
10:55:07 <ludde> I did it like this.
10:55:17 <ludde> I represent the x_i:s using 0 and 1.
10:55:41 <ludde> if x_1 to x_4 is (2,2,2,4) I would get 0010010010000
10:55:59 <ludde> (the number is the number of 0:s between the 1:s)
10:56:12 <ludde> so the total number is N+n-1
10:56:22 <ludde> and from that I choose n-1 positions where I place a 1
10:56:43 <ludde> is this bad?
10:56:58 <hdaume> actually that sounds reasonable :)
10:57:01 <hdaume> lemme think for as sec
10:58:01 <hdaume> yeah that seems right
10:58:04 <ludde> oh good
11:19:08 <engstad> ludde: heh, that's really smart.
11:20:09 <engstad> ludde: you should test yourself on the putnam quizes (google on william lowell putnam mathematical).
11:20:23 <ludde> okay
11:48:55 * Riastradh is a little confused about the '.' operator.
11:49:04 <Riastradh> Or infix function, rather.
11:49:56 <esap> It's just function composition.
11:50:15 <Riastradh> I know, but that doesn't keep me from being confused about it.  A simple example of it might help.
11:50:55 <esap> You have to understand that the first thing executed in f . g . h is 'h', then result of that is passed to 'g' and then 'f' takes the result of that. So read it from right to left.
11:51:33 <esap> I think that should clear most of confusion, does it?
11:51:36 <Riastradh> Ah, now I get it.
11:51:52 * Riastradh understands function composition, but nevertheless '.' confused him for a bit.
11:52:35 <esap> also, there are some situations where you need to be careful with precedence.
11:53:37 <esap> for example, in f . g a . h i, both g and h take two arguments.
11:53:59 <engstad> h?
11:54:07 <Riastradh> And f takes one.
11:54:18 <engstad> Oh, I see.
11:54:41 <esap> riastradh: right.
11:55:20 <engstad> f . g a . h i === f . (g (a . h) i) ??
11:55:48 <esap> engstad: f . g a . h i === f . (g a) . (h i)
11:55:50 <Riastradh> No, it should be:  f . g a . h i   <=>   f . (g a) . (h i)
11:56:17 <esap> endstad: and it's not (f . g a . h) i
11:56:54 <engstad> Hmm, I would have automatically thought it was: f . (g a) . (h i)
11:57:03 <engstad> So, where's the confusion?
11:57:29 <engstad> Is it because (g a) must be a function?
11:57:44 <esap> engstad: I've sometimes written f . h a when I should have written (f . h) a
11:57:55 <engstad> Oh, I see.
11:59:40 <esap> Well anyway, I guess for that, f $ h a is better style anyway.
11:59:54 <engstad> I wish there was a small-o symbol on most keyboards..
12:00:05 <Riastradh> What does $ do?
12:00:12 <Marvin--> it's function application :=)
12:00:19 <Marvin--> f $ x = f x
12:00:22 <engstad> Same thing as ., except that its precendence is different.
12:00:57 <esap> engstad: no, not the same as function composition, it's function application.
12:01:16 <Riastradh> application /= composition
12:01:33 <engstad> U're right.. sorry.
12:07:42 * emu has just raped GnuGo
12:07:54 <emu> W+40.5
12:09:22 <esap> is gnugo strong? (I've never tried it).
12:23:10 <emu> i say it's about 21k IGS
12:23:31 <esap> ok.
12:46:09 <kawfee> could someone help me with the following:
12:46:10 <kawfee> > getLine = do r <- getChar
12:46:10 <kawfee> >       if (r == '\n') then return ""
12:46:10 <kawfee> >       else return r:getLine
12:46:23 <kawfee> the if and else are lined up under the r
12:46:31 <hdaume> that last line should be 'else do rest <- getLine ; return r:rest'
12:46:50 <hdaume> getLine is of type IO String and r is of type Char.  you can't ":" a Char to an IO String
12:48:07 <kawfee> sam error
12:48:08 <kawfee> ERROR "hw4.lhs":146 - Syntax error in expression (unexpected `;', possibly due to bad layout)
12:48:11 <kawfee> saqme
12:48:13 <kawfee> same even
12:48:31 <kawfee> I've been fighting with this for some time
12:48:34 <hdaume> try indenting the 'else' an extra space or two
12:48:42 <Marvin--> I'm not sure you can use a semicolon without braces
12:48:48 <hdaume> Marvin--: you can
12:49:22 <Marvin--> okay
12:49:43 <hdaume> kawfee: i would write that as:
12:49:46 <opet> I've been caught out by that space thing
12:49:51 <hdaume> getLine = do
12:49:54 <hdaume>   r <- getChar
12:49:59 <hdaume>   if r == '\n'
12:50:01 <Igloo> The if needs to be in line with the do
12:50:03 <hdaume>     then return ""
12:50:09 <Igloo> I mean the e
12:50:09 <hdaume>     else do rest <- getLine
12:50:10 <Igloo> r
12:50:12 <hdaume>           return (r:rest)
12:50:21 <Igloo> And the else nested deeper
12:50:32 <hdaume> (that last return should be lined up with the "r" in "rest")
12:50:45 * shapr bounces
12:51:41 * kawfee splashes
12:52:55 <kawfee> hrm
12:53:12 <kawfee> thanks for the help, I was working with that for hours, indentation really matters in do
12:53:32 <hdaume> yup
12:57:55 <shapr> hm, not a HalDaume wiki page
12:58:54 <hdaume> shapr: huh?
12:59:42 <shapr> does not exist --> http://c2.com/cgi-bin/wiki?HalDaume
12:59:54 <hdaume> ah.  why would it?
13:00:35 <shapr> I put your name in the FunctionalModelingExamples as HalDaume...
13:00:50 <shapr> just noticing :-)
13:01:14 <hdaume> oh okay :)
13:02:30 <shapr> you'd probably like TheWiki but it sure can suck away a lot of time
13:09:21 <kawfee> *** Binding             : hex2Int
13:09:22 <kawfee> *** Outstanding context : Enum b
13:09:25 <kawfee> what does that mean?
13:09:52 <kawfee> > hex2Int = foldl f 0 
13:09:52 <kawfee> >  where
13:09:53 <kawfee> >  f n d = fromEnum d - fromEnum '0' + 16*n
13:13:07 <hdaume> kawfee: it basically means that hugs can't figure out what instance of Enum you want to use in this definition.  try adding a type signature
13:13:20 <kawfee> ok
13:13:22 <hdaume> alternatively, 'hex2Int l = foldl f 0 l' may do the job
13:21:01 <kawfee> I got mine to work, I am trying to convert a hexadecimal string to a decimal string, I already have a decimal converter
13:32:34 <kawfee> how could I convert A to 10 on the command line?
13:32:50 <kawfee> I don't really understand the code above, so I'll do it another way
13:44:26 <kawfee> ds2Int = fold1 f 0
13:44:48 <kawfee>     where f n d = fromEnum d - fromEnum '0' = 10*n
13:44:55 <kawfee> could someone explain that to me?
13:45:03 <kawfee> how does it convert a decimal string to hexadecimal
13:48:27 <hdaume> how well do you understand foldl?
13:50:36 <hdaume> here's a basic explanation: (fromEnum d - fromEnum '0') conversts the character '5' into the integer 5.  in the 'f' function, n is the "accumulated" value so far and d is the character we're converting right now.  first, we convert d to it's integer form (say 5) and then multiply the previous accumulated value by 10 and add the 5. (more)
13:51:16 <hdaume> the reason this works is because as we go right-to-left on a string "123", we first take 1, then multiply it by 10 and add 2, yielding 12.  we then multiply this by 10 and add 3 yielding 123, as desired.
13:51:24 <hdaume> does that make any sense?
14:14:02 <kawfee> yes
14:14:05 <kawfee> I get that part
14:14:20 <kawfee> I just didn't understand how the fromEnum worked to give the result
14:14:42 <hdaume> perhaps replacing 'fromEnum d - fromEnum '0'' with 'ord d - ord '0'' would make more sense
14:14:59 <kawfee> then for hex I change 10 to 16 and it should work, but it isn't
14:15:02 <hdaume> fromEnum simply takes a character and returns an integer value representing it.  ord does the same thing
14:15:16 <hdaume> no, because fromEnum '9' /= fromEnum 'A' - 1
14:15:27 <hdaume> you need to do something special to handle the alphabetics
14:15:32 <kawfee> ahhh
14:15:39 <hdaume> :)
14:16:16 <kawfee> some sort of case statement?
14:17:07 <hdaume> yeah, or if...you could just check if 'd' is between '0' and '9' and if so do the first part, otherwise subtract off fromEnum 'A' + something
14:17:42 <kawfee> I was thinking of mapping A to 10
14:17:46 <kawfee> B to 11
14:18:03 <hdaume> yeah, that's the proper thing to do
14:18:21 <hdaume> or you could do ....if 'A' < d then fromEnum d - fromEnum 'A' + 10 (or something like that)
14:18:44 <kawfee> so if x isdigit then do fromEnum d - fromEnum '0' else getHex
14:19:23 <hdaume> sounds resonable :)
14:26:31 <kawfee> >  f n d = getNum d + 10*n - 7*n
14:26:43 <kawfee> > getNum x = if (isDigit x) then fromEnum x - fromEnum '0'
14:26:44 <kawfee> >     else 
14:27:00 <kawfee> it returns the value of the hex digit, i.e. A returns 10
14:27:25 <kawfee> I guess I still don't understand the decimal conversion one
14:29:28 <hdaume> well i've got to go to class...perhaps someone else can help
14:29:49 <kawfee> that would be nice
14:41:42 * shapr bounces
14:41:47 * shapr sproings
14:42:06 * Riastradh explorbs.
14:42:28 <shapr> that's a great word
14:42:33 <Riastradh> Indeed.
14:42:46 <Riastradh> Especially since you can construct just as great words from it, like 'explorbulent.'
14:43:00 <shapr> mmm, nice
14:43:13 <radix> explorbastic
14:43:18 <shapr> ooh, ahh!
14:43:19 <whee> explorbtacular.
14:43:25 * radix goes to eat.
14:43:33 <shapr> microsoft explorber
14:43:34 <Riastradh> Or you could even take out the 'tac' -- explorbular.
14:43:34 <whee> that one didn't work too well :(
15:00:33 <esap> whoa, google finds 38 hits for explorb
15:08:30 <shapr> scary
15:08:36 <shapr> we need a google bot
15:08:43 <Pseudonym> Eeek.
15:08:49 <shapr> hi Pseudonym!
15:08:51 <shapr> you're awake!
15:08:52 <Pseudonym> G'day.
15:08:54 <Pseudonym> Yes.
15:09:02 <Pseudonym> Only just.
15:09:08 <shapr> can I request that fundep Truck?
15:09:40 <shapr> http://c2.com/cgi-bin/wiki?FunctionalModelingExamples
15:10:48 * shapr suddenly realizes that monads with functional dependencies could be codependant
15:12:40 <Pseudonym> Eek.
15:12:50 <shapr> good morning Pseudonym!!
15:12:56 <Pseudonym> I don't like the first or the third design.
15:13:06 <Pseudonym> Sorry. :-)
15:13:15 <Pseudonym> Commonality analysis and all that.
15:13:24 <Pseudonym> All tyres have pressure.
15:13:42 <Pseudonym> It doesn't make sense, therefore, to make Pressure a property of the tyre brand.
15:13:55 <Pseudonym> Because it's not dependent on the brand.
15:14:05 <Pseudonym> data Tyre = Tyre Brand Pressure
15:14:10 <Pseudonym> Brand = Michelin | Pirelli
15:14:23 <Pseudonym> ?
15:14:33 <shapr> it's a wiki :-)
15:14:37 <Pseudonym> True./
15:15:08 <shapr> though I'm happy to hear your explanation, since that improves my code.
15:15:35 <Pseudonym> Do you understand what I mean by commonality here?
15:15:37 <Marvin--> overflow, overflow... there's way too many movies I want to see right now
15:15:49 <shapr> yes, I think so
15:15:57 <Pseudonym> If a property is common in the problem domain, it should also be common in the code.
15:16:00 <shapr> tires have pressure, not instances of tires
15:16:12 <Pseudonym> No, it's not that.
15:16:37 <Pseudonym> Instances of tyres do have pressure.  My tyres are at 38psi, yours are at 40psi.
15:16:41 <Pseudonym> Even if they're the same brand.
15:16:49 <shapr> oh!
15:17:01 <Pseudonym> Or did I misunderstand the problem?
15:17:12 <shapr> no, I think you're right
15:17:26 <radix> Yeah. There's instance property "current pressure" and class property "standard pressure" ;-)
15:17:34 * Pseudonym hmms
15:17:42 <Pseudonym> I think the problem was poorly specified.
15:17:54 <shapr> that's what esap said also
15:18:14 <Pseudonym> Perhaps FunctionalIsPoorAtModelling should be reworded as WikiUsersArePoorAtSpecifying.
15:18:18 <shapr> I think we're just looking for ways of modelling in FP
15:18:22 <shapr> heheh
15:18:48 <Pseudonym> As mentioned previously, I started mapping out a paper on precisely this topic.
15:19:10 * Pseudonym has written all of the headings already :-)
15:19:32 <Marvin--> what's the DRY principle?
15:19:39 <shapr> don't repeat yourself
15:19:50 <shapr> I should have linked to OnceAndOnlyOnce though
15:19:54 * shapr fixes
15:20:13 <Pseudonym> There's DRY and there's DRY, though.
15:20:27 <Pseudonym> I'm of the opinion that it's acceptible to repeat yourself if you actually mean two different things.
15:20:30 <Pseudonym> Even if they look the same.
15:20:32 <shapr> that's true
15:21:16 <Pseudonym> So, for example, a "list" and a "stack" may in principle share code, but if they mean something different, it's okay to repeat.
15:21:17 <shapr> ya know.. I'll never be able to repeat that codependant joke anywhere else (well, maybe ICFP and HW) 
15:21:30 <Pseudonym> Probably not, no. :-)
15:22:02 <shapr> it's sad how many computer jokes just don't translate out of IRC
15:22:18 <Pseudonym> http://c2.com/cgi-bin/wiki?LanguagePissingMatch
15:22:22 * Pseudonym loves it
15:22:52 <Pseudonym> Should add FunctionalVsObjectOriented to the pissing match.
15:22:53 <shapr> TheWiki rocks
15:22:56 <shapr> yes, do it!
15:23:05 <shapr> and FpVsOo
15:23:27 <shapr> I started reading the wiki a looong time ago
15:23:34 <shapr> I think '95
15:25:05 * Pseudonym made ParadigmPissingMatch
15:26:02 <shapr> heh, cute
15:27:19 <Pseudonym> What do you know. http://c2.com/cgi-bin/wiki?MultiParadigmDesign
15:29:40 <shapr> the wiki is the best programming website in existence
15:30:05 <esap> agreed.
15:30:57 * esap thinks maybe only google does better :-)
15:31:33 <shapr> heh, good point
15:32:34 <shapr> Pseudonym: I probably shouldn't point you to TheWiki while you're in ReleaseHell
15:32:47 <Marvin--> http://c2.com/cgi-bin/wiki?UnLambdaLanguage  cute :)
15:34:18 <shapr> http://c2.com/cgi-bin/wiki?SuperCombinators
15:36:42 <Marvin--> yes?
15:36:47 <Marvin--> heck I know lambda calculus
15:37:20 <shapr> it's spiffy :-)
15:40:32 <shapr> hi timd 
15:40:48 <timd> back again - got ghc workin, next is HOpenGL
15:40:50 <shapr> yay
15:42:04 <Pseudonym> Just wrote a manual page in 5 mins.
15:42:24 <Pseudonym> Nobody reads man pages, anyway.
15:42:32 <shapr> yay
15:42:42 <shapr> man, I have to get a better cheerful interjection.
15:42:45 <shapr> whee
15:42:49 <Pseudonym> w00t?
15:42:52 <Pseudonym> Uhm...
15:42:55 <shapr> w00t
15:43:02 <shapr> feels right...
15:43:14 <Pseudonym> Man, I must be stressed.
15:43:21 <Pseudonym> First joke I thought of was a slashdot troll line.
15:43:42 * shapr snickers
15:43:47 * Pseudonym ahems
15:43:50 <Pseudonym> In Soviet Russia, cheer interjects you!
15:43:54 * whee gets the hot grits
15:45:00 <Marvin--> oh dear
15:47:08 <shapr> there's some neat stuff on FpVsOo
15:48:41 <timd> damn HOpenGL segv whenever it tries to show a window..
15:49:18 <Marvin--> man I should get some sleep
15:49:59 <shapr> me too
15:50:06 <shapr> swedish class tomorrow
15:50:11 <shapr> haven't done my läxa yet
15:50:21 <Marvin--> :)
15:57:52 * shapr gets sleepy
16:11:51 * Arnia bounces
16:11:59 * shapr bounces too
16:14:10 <Arnia> shapr: Got my unification system unifying... I'm happy :)
16:14:50 <shapr> yay!
16:15:51 <Arnia> It behaves wonderfully correctly... its great.
16:16:23 <esap> what kind of unification system are you doing?
16:16:40 <Arnia> All I need now is to be able to check that two structures subsume or unify so that I don't try and unify something that doesn't :)
16:17:31 <Arnia> esap: A feature-based unification system for the implementation of some of the ideas of Peter Cullicover, Ray Jackendoff, Paul Callaghan and Zhauhui Luo
16:18:17 <esap> arnia: sounds interesting. [I'm not familiar with feature-based unification]
16:21:04 <Arnia> esap: The last two people are lecturers here at Durham, whereas Peter Cullicover and Ray Jackendoff are linguists.
16:25:08 <Arnia> Unification systems are cool to study
16:25:38 * esap has written an unification algorithm. I'm actually currently writing one.
16:26:15 <Arnia> Oh? What for?
16:26:39 <esap> For a language I'm designing and writing a compiler for.
16:26:48 <Arnia> What's this language like?
16:27:47 <esap> pure functional language based on category theory. A bit like a simplification of cayenne.
16:27:56 <Arnia> Oooh... I'm interested
16:28:19 * Pseudonym wrote quite a bit of a logic language :-)
16:28:28 <Pseudonym> Can you explain feature-based unification briefly?
16:30:42 <Arnia> The idea is that a data-structure consists of a number of features or is one of the base types of void, number etc
16:31:07 <Pseudonym> OK
16:31:13 <Arnia> Each feature consists of a label and another datastructure, possibly with variables and references.
16:31:19 <Pseudonym> A feature is like an atom?
16:31:25 <Pseudonym> Oh, OK.
16:31:32 <Pseudonym> Like a Prolog term kind of thing.
16:32:34 <Arnia> Similar, only its more general. Unification involves finding the unique maximal structure that is subsumed by its two source structures
16:32:46 <Pseudonym> Sure.
16:33:05 <Pseudonym> I mean a "feature" is like a Prolog term.
16:33:43 <Pseudonym> So to get this straight, a data structure is a mapping of atom to data structure.
16:33:48 <Pseudonym> Where the data structure may be a variable too.
16:34:05 <Arnia> No... I'll use pseudo-haskell to describe it:
16:34:50 <Pseudonym> :-)
16:34:53 <Arnia> data Structure = StructList [Feature] | Variable Label Structure | Referent Label Structure | (BaseTerm)
16:35:05 <Pseudonym> OK.
16:35:08 <Arnia> data Feature = (Label,Structure)
16:35:51 <Pseudonym> What I was thinking was something more like:
16:36:14 <Pseudonym> data Structure = StructList [(Label,Structure)] | Referent Label Structure | Variable | BaseTerm
16:36:27 <Pseudonym> You appear to have variables with internal structure, though.
16:36:46 <esap> arnia: in that definition of a structure, what is the relationship between 'Variable' and 'Referent'?
16:36:53 <Arnia> Yes... when you substitute a value into a variable then you do a unification
16:36:55 <Pseudonym> Coming from a logic programming point of view, I don't understand that.
16:37:02 <Pseudonym> Oh...
16:37:09 <Pseudonym> So it's just an indirection pointer, kind of thing.
16:37:48 * esap looks everything from category theory point of view. Are 'Variable' and 'Referent' duals or inverses or something :-)
16:37:58 <Pseudonym> See, in Prolog, free variables are different from instantiated structures.
16:38:15 <Arnia> Not quite... variables are unified rather than being leaves on the tree because of my desire to use this for various Cognitive AI needs
16:38:24 <Pseudonym> Oh, OK
16:38:30 <Pseudonym> Fair enough.
16:38:58 <Pseudonym> I assume you're not dealing with free variable aliasing in this Pseudo-Haskell.
16:39:00 <Arnia> Variables are used in rules in my computational model (of which this is part) and are simply used to 'copy' structures from one side of a rule to another when the rule fires
16:40:14 <Arnia> esap: A referent is simply an index saying that two structures (maybe in different types) are somehow linked. Its like a trace and it can be used by rules to refine their matches
16:40:28 <Arnia> Pseudonym: how do you mean by aliasing?
16:42:01 <Pseudonym> In Prolog, you can write this:
16:42:03 <Pseudonym> f(X,X)
16:42:18 <Pseudonym> If you unify that with, say, f(1,Y), you get the binding Y=1.
16:42:35 <Pseudonym> That's because the arguments of f/2 are aliased.
16:43:57 <Arnia> No, although its something to consider
16:44:55 <Pseudonym> Of course if you're doing that, you're probably after a more general constraint mechanism.
16:46:41 <Arnia> Really, the only constraints I'm interested in are the constraints of subsumption and unification
16:46:47 <Pseudonym> Sure.
16:46:58 <Pseudonym> Hence my reflection that you probably don't need aliasing.
16:47:06 <Pseudonym> For general logic programming, you do.  Otherwise you don't.
16:47:06 <Arnia> I'm doing this to see how far things can be stated using only those.
16:47:27 <Arnia> I reckon that I can state most things using just those (even if not in base types)
16:51:00 <Arnia> I've just got to define subsumption and the conditions on unification and I'll be able to write the rule running component.
16:51:12 <Arnia> Be interesting to see how well it works.
16:51:29 <Arnia> esap: what is your language for?
16:51:35 <Pseudonym> Yes, I'd be very interested in what you find.
16:52:48 <esap> arnia: Well I'm intending it to be general-purpose language. But I'm aiming for a very powerful type system.
16:53:11 <Arnia> esap: What are you basing the type system on?
16:53:59 <Arnia> Pseudonym: I believe I've told you before what I'm interested in research-wise. I think you can guess what I'm going to use the system for :)
16:54:05 <esap> arnia: well I've taken ideas from many places. Subtractive logic [by Crolard] was the basis.
16:54:37 <esap> arnia: but I've made quite many changes to it, basically simplified it using symmetries.
16:55:43 <esap> arnia: see http://modeemi.fi/~esap/good-papers.bib, it has references to most of the interesting information I've used.
16:55:50 <Arnia> esap: I'm currently looking for a good introduction to category theory, can you recommend one
16:56:50 <esap> arnia: sure. Hillman: "A categorical primer" is a good one. And "Categories for types" is a classic book.
16:58:22 <Arnia> Any available online?
16:58:49 <esap> arnia: those in the good-papers.bib have url's for all that are online.
16:59:25 <esap> arnia: citeseer actually has most papers that I usually find anyway :-)
17:00:36 <Arnia> Yes, Citeseer is great :)
17:00:59 <Arnia> Although I have ATHENS access so I get lots of e-journals as well :)
17:01:52 <Pseudonym> Gotta go.  Too busy to IRC.
17:02:01 <Pseudonym> Never thought I'd ever say that.
17:02:05 <Pseudonym> Bye everyone.
17:03:12 <Arnia> Bye
17:04:49 <esap> Another good paper on category theory (and especially on its applications to type theory) is Pitts: Categorical logic. But it might be somewhat hard to read if you don't have previous experience with category theory. Took me about a year to read it.
17:06:19 <esap> Hmm... there was actually some book that described category theory in great detail available on the web, wait a sec, I'll look it up.
17:07:54 <esap> It is Barr&Wells: Toposes, Triples and Theories. http://www.cwru.edu/artsci/math/wells/pub/ttt.html
17:13:00 <Arnia> Thanks :)
17:14:35 <kawfee> if I have a list of IO actions how can I apply each of those IO actions sucessively?
17:15:05 <Arnia> Fold using >>= I believe
17:15:22 <kawfee> huh
17:15:38 <esap> kawfee: sequence
17:15:47 <kawfee> right
17:16:01 <kawfee> I want to perform them in sequence
17:16:56 * Arnia needs to brush up on his standard functions :/
17:17:16 <esap> kawfee: no, I mean that is the name of the standard prelude function you need.
17:17:23 <kawfee> oh
17:17:28 <kawfee> let me look
17:19:06 <kawfee> sequence       :: Monad m => [m a] -> m [a]
17:19:17 <esap> arnia: oh btw, Coguen: "A categorical manifesto" has a good introduction if the other papers are hard to understand. http://citeseer.nj.nec.com/goguen91categorical.html
17:19:45 <kawfee> sequence (c:cs) = do x  <- c
17:19:49 <kawfee> oh wow
17:25:07 <kawfee> ERROR "hw4.lhs":205 - Missing binding for variable "doAll" in type signature
17:25:14 <kawfee> > doAll :: [IO()] -> IO()
17:28:56 <kawfee> could someone help me with converting hexadecimal to decimal?
17:29:05 <kawfee> I know how to do it by hand, just not in haskell
17:29:46 <esap> kawfee: is the problem the above error message?
17:32:53 <shapr> hi metal-grid 
17:33:27 <kawfee> not in converting hex to decimal, that's another problem
17:33:39 <kawfee> shapr: hi
17:33:54 <shapr> hi kawfee 
17:34:17 <metal-grid> hi - anyone ever use Haskell in an embedded environment?
17:34:35 <kawfee> metal-grid: real time processing?
17:34:49 <metal-grid> at least pseudo real-time...
17:37:51 <kawfee> am I only allowed 1 question every 4 hours in here?
17:38:04 <shapr> kawfee: yes, sorry ;-)
17:38:06 * shapr laughs
17:38:19 <shapr> metal-grid: you should ask on the haskell mailing list
17:38:34 <kawfee> seriously though, I get one answer and that's it, I'm not expecting you to be here to every question, but most channel seem a little more alive
17:38:37 <shapr> I know that Yampa was used to control industrialrobots
17:39:06 <metal-grid> i'll give it a shot - here's another way of maybe asking my question if you are a practitioner...
17:39:38 <metal-grid> what kinds of memory requirements does a typical "hello world" haskell program incur?
17:40:19 <kawfee> type :s +s
17:40:23 <kawfee> check yourself 
17:40:32 <kawfee> show "Hello World"
17:40:52 <kawfee> Prelude> "Hello World"
17:40:52 <kawfee> "Hello World"
17:40:53 <kawfee> (213 reductions, 289 cells)
17:40:56 <kawfee> how's that?
17:41:05 <shapr> is that hugs?
17:41:08 <kawfee> yes
17:41:19 <shapr> neat
17:41:29 <shapr> hello world here is a 291k binary.
17:41:51 <metal-grid> what's a "reduction" and a "cell"
17:42:06 <kawfee> that's a good question =]
17:42:18 <radix> so, with ghc, is the Prelude actually textually included with each program, or is it off in some haskell.so?
17:43:00 <metal-grid> well 291k is not so bad - I'm assuming there a lot of NRE in there
17:43:07 <metal-grid> here's another question...
17:43:22 <metal-grid> are the evaluations of haskell programs always deterministic?
17:43:38 <kawfee> you mean lazy?
17:43:40 <shapr> no, haskell is lazily evaluated
17:43:50 <kawfee> evaluation-by-need
17:43:58 <kawfee> haskell like to procrastinate
17:44:00 <shapr> heh
17:44:01 <kawfee> likes
17:44:05 <shapr> nice way to put it :-)
17:44:15 <shapr> metal-grid: have you used haskell before?
17:44:18 <radix> well, even if it's lazy, it could be deterministic if you take into consideration the implementation, unless you have I/O that decides what your code does :-)
17:44:28 <metal-grid> is the lazy evaluation only on interpreted haskell compilers or is it inherent in the language?
17:44:35 <shapr> it's inherent
17:44:38 <kawfee> metal-grid: inherent
17:44:47 <shapr> and radix has a good point
17:45:01 <shapr> you may not consider lazy evalution to be non-deterministic
17:45:06 <kawfee> metal-grid: it's a combination of the safety of outermost evaluation and the speed of innermost
17:45:22 <shapr> but I suspect you're asking how it compares to something like reference counting
17:45:40 <metal-grid> wrt prior usage - I am a novice, but very interested
17:45:45 <esap> So basically 'evaluation' is deterministic, but what is evaluated depends on what I/O is done.
17:46:23 <esap> And I/O is most often deterministic, but might not be (getContents is not, for example).
17:46:37 <metal-grid> my interest is in network processing - packet processing in the "data plane"
17:46:43 <whee> haha, I just thought of the lamest way of doing base conversions
17:46:50 <shapr> whee: tell us
17:47:03 <shapr> metal-grid: heavy duty routers?
17:47:14 <kawfee> how can I use sequence to define a function printList so that printList xs is an action which displays the elements of xs on successive lines?
17:47:36 <metal-grid> shapr: routers and edge network processing for radio networks
17:47:45 <shapr> kawfee: http://kungens.kemi.fi/~shae/src/haskell/Mandelbrot-0.1.hs
17:47:48 <whee> well, say you have a decimal number and need to go to hex, you just assume you have n positions to place this decimal number, and each position only holds 15
17:47:51 <shapr> kawfee: look at the bottom of that source
17:48:14 <whee> so you just recurse and keep adding and filling and moving on as the spots become full, then do a digit->char translation afterwards
17:48:16 <shapr> oh, for wireless networks...
17:48:20 <shapr> that sounds like fun
17:48:34 <shapr> routing algorithms for wireless ethernet should be very different
17:48:54 <shapr> whee: write a demo
17:49:03 <kawfee> shapr: ahh, I could map a print function over a list?
17:49:12 <shapr> kawfee: try it
17:49:19 <whee> shapr: it won't be in haskell, but if you really want it :p
17:49:29 <shapr> whee: which language?
17:49:29 <metal-grid> I think that Haskell is a great langauge for describing the processing of packet streams - it focuses more on what to do and not "how" to do
17:49:35 <whee> ocaml, probably
17:49:47 <shapr> well, ok, I forgive your heresy :-P
17:49:54 <whee> heh
17:49:58 <whee> if ghc worked, I'd use haskell :p
17:49:58 <metal-grid> the key problem is that most embedded guys don't know functional programming - they're all C programmers and ASM programmers
17:50:07 <shapr> whee: oh, that's a low blow...
17:50:26 <shapr> metal-grid: that's true of most programmers
17:50:34 <shapr> even so, if you think it's the best tool for the job
17:50:55 <shapr> if it can make your company more profitable than the next company
17:51:07 <metal-grid> well - not sure if it's good for embedded stuff - that's why I was wondering if anybody's done it before...
17:51:34 <shapr> I don't know for sure.
17:51:41 <shapr> I would recommend asking on the main haskell mailing list
17:51:50 <shapr> you should get some answers from the robotics guys at least
17:52:01 <shapr> they'll probably be able to tell you what kind of minimum hardware you'd need for embedded haskell
17:52:24 <metal-grid> is anybody aware of a port to a XScale or PPC?
17:52:43 <shapr> GHC runs on Linux/PPC
17:53:46 <shapr> I do agree that Haskell could do some amazing things for packet stream processing
17:53:49 <shapr> have you heard of Arrows?
17:54:01 <metal-grid> no - what's Arrows?
17:54:20 <shapr> they're a generalization of Monads
17:54:33 <kawfee> sequence_  (map putStr [0..9])
17:54:38 <shapr> one cool trick they can do is monads with static type info included
17:54:40 <kawfee> something like that should work?
17:54:50 <shapr> kawfee: try it
17:55:01 <kawfee> I did
17:55:03 <kawfee> I get an error
17:55:04 <shapr> what happened?
17:55:14 <kawfee> ERROR - Illegal Haskell 98 class constraint in inferred type
17:55:14 <kawfee> *** Expression : sequence_ (map putStr (enumFromTo 0 9))
17:55:14 <kawfee> *** Type       : (Num [Char], Enum [Char]) => IO ()
17:55:20 <shapr> why do you think that happened?
17:55:45 <kawfee> dunno, I don't understand the error =[
17:55:59 <kawfee> I don't think the interpreter likes me
17:56:00 <shapr> look at the type of putStr and the type of the list you gave to putStr
17:56:06 <kawfee> oh!
17:56:17 <whee> heh
17:56:53 <shapr> kawfee: when you run into a situation like that, break it down into a smaller problem
17:56:53 <kawfee> well, the list is a list of Ints
17:57:06 <kawfee> yeah, well these error messages boggle me
17:57:21 <shapr> for example, your next step could have been to take the "sequence_" away
17:57:31 <kawfee> I tried that
17:57:46 <kawfee> It complained
17:57:47 <shapr> and then to try one piece of the "map" call explicitly
17:58:08 <kawfee> yeah, I need to remember to go smaller and smaller
17:58:11 <kawfee> intot the hobbit hole
17:58:16 <shapr> yes, it helps
17:58:32 <kawfee> well, how can I write a digit to the screen with an IO action?
17:58:33 <kawfee> heh
17:59:22 <shapr> can you write a string to the screen?
17:59:51 <kawfee> putStr "lll"
18:00:08 <shapr> so, can you turn a number into a string?
18:00:32 <kawfee> yeah, use show
18:00:51 <shapr> well?
18:00:55 <kawfee> map show [0..9]
18:00:59 <kawfee> ["0","1","2","3","4","5","6","7","8","9"]
18:01:16 <kawfee> yay
18:01:19 <kawfee> I'm gettingt here
18:01:22 <kawfee> I think I have it
18:01:33 <kawfee> sequence(map putStr(map show [0..9]))
18:01:36 <kawfee> thanks
18:01:42 <shapr> does that work?
18:01:52 <kawfee> sort of, now all I need it to add some newlines
18:02:00 <kawfee> yeah it works, but not the way I want it to
18:02:05 <kawfee> 0123456789
18:02:10 <shapr> that's a start.
18:02:15 <kawfee> yes it is
18:02:52 <whee> errr; some nut decided to make the exponentiation operator deal with floats
18:03:38 <kawfee> *** Outstanding context : Monad b
18:03:43 <kawfee> do I need to load something?
18:03:46 <shapr> metal-grid: any other questions before I go to sleep?
18:04:51 <shapr> ok, time to fall over...
18:05:14 <kawfee> is there a standard function to find the last element before the end of the list?
18:05:21 * kawfee pushes shapr 
18:05:42 * shapr trips over a function named 'last'
18:05:55 <metal-grid> shapr - thanks, just waiting for you to finish up...
18:06:13 <kawfee> yeah, but I need to insert something into the last, a newline
18:06:16 <kawfee> I think I have it
18:07:20 <shapr> ok, unless there's something else, I'm off to sleep
18:07:39 <metal-grid> no - thanks for all you help - g'night!
18:07:50 <shapr> g'night all
18:15:47 <kawfee> ni ni
18:24:23 <kawfee> is there a way to make a line show with a newline in it?
18:51:29 <kawfee> is there a way to make an infinite list of IO actions?
18:52:15 <kawfee> I want to define a function readSort  which reads integers on successive lines until is encounters a line which is not an integer.
19:31:52 <esap> hmm.. is the iohcc mail address really written with one 'c' and not two?
19:32:14 <radix> either work, IIRC
19:32:25 * esap is just submitting the entry.
19:32:38 <radix> "International Obfuscated Haskell Contest", right?
19:33:16 <esap> heh :-) the web page disagrees.
19:36:37 <emu> cpan.net hosts the obfuscated perl contest
19:36:49 <esap> but perl is too easy.
19:36:49 <emu> confusing perl archive network
19:37:25 <esap> there is no challenge in writing an obfuscated program in perl.
19:37:54 <emu> the challenge is to get something that is understandable and useful
19:38:14 <Riastradh> Perligata!
19:38:16 <emu> the literate perl programming contest
19:45:10 <kawfee> is there a way to make an infinite list of IO actions?
19:47:48 <kawfee> is there a way to test if something is an integer?
19:53:15 <kawfee> nm, I got it
19:58:01 <kawfee> ERROR "hw4.lhs":241 - Syntax error in input (unexpected `<-')
19:58:10 <kawfee> > readSort = x <- getLine
19:58:10 <kawfee> >     if  (not(isDigit2 x)) then return ""
19:58:11 <kawfee> >else do xss <- readSort; return (x:xss)
20:03:47 <kawfee> nm
20:03:50 <kawfee> I think I got it
20:13:09 <kawfee> how can I turn a list of: IO [Char] into a list of integers that they represet?
20:16:39 <kawfee> lah lah lah
20:16:56 <kawfee> you wouldn't mind if I took off all my clothes and jumped in the bath would you?
20:40:32 <kawfee> I have the following: 
20:40:33 <kawfee> > readSort2 = do xs <- getLine
20:40:33 <kawfee> > if (not(isDigit2 xs)) then return ""
20:40:33 <kawfee> >  else do xss <- readSort2; return (xs++xss)
20:40:55 <kawfee> it returns to me a list of Char, but I would like a String, how can I make it return a Srting?
21:10:11 <palomer> I've decided the only way to improve my functional programming is to learn haskell
21:15:26 <flippo> palomer: a natural decision
21:18:24 <palomer> since ocaml has some imperative elements to it
22:18:48 <kawfee> ERROR "hw4.lhs":284 - Syntax error in pattern (unexpected `->')
22:19:00 <kawfee> >      -       -> do putStrLn "no good!"
22:23:43 <Binkley> heya
22:25:12 <kawfee> hello
22:47:07 <kawfee> I'm using the parser library, and I get back [(n,"")], where n is an Int, what is the proper way to extract n ?
22:48:51 <Binkley> case result of { [(n,_)] -> n; _ -> error "foo" }
22:48:56 <Binkley> is something like that what you're looking for
22:48:57 <Binkley> ?
22:51:19 <kawfee> it's complaining about the pattern I suppose
22:51:31 <kawfee> It's actually from my notes, I don't know what's wrong with it
22:51:43 <kawfee> it should work, I don't think the prof would give us code that didn't
22:52:00 <Binkley> what error are you getting?
22:52:05 <kawfee> Syntax error in pattern (unexpected `->')
22:52:32 <kawfee> know anything about the Parsing lib?
22:52:43 <kawfee> btw these are two different questions 
22:52:44 <Binkley> i haven't used it, i've mainly used Happy for parsing
22:52:49 <kawfee> happy?
22:52:54 <Binkley> what does the code that's causing the error look like?
22:53:01 <Binkley> it's a parser generator for haskell, like yacc
22:53:05 <kawfee> > getInt :: IO Int
22:53:05 <kawfee>  > getInt = 
22:53:05 <kawfee>  >    do s <- getLine
22:53:05 <kawfee>  >case reads s of 
22:53:05 <kawfee>  >  [(n,"")] -> return n
22:53:07 <kawfee>  >  -   -> do putStrLn "no good!"
22:53:10 <kawfee>  > getInt
22:53:14 <kawfee> but it's all indented properly, I think
22:53:27 <kawfee> oh
22:54:09 <Binkley> you need a _, not a -
22:54:32 <kawfee> heh
22:56:13 <kawfee> thanks a lot!
22:56:20 <Binkley> sure
22:56:22 <kawfee> I struggled with that for quite some time
22:56:43 <kawfee> how's your evening?
22:57:36 <Binkley> eh, i'm trying to debug some code
22:57:43 <Binkley> if only it were as easy to solve as that problem was :-)
23:02:36 <kawfee> Instance of Num [Int] required for definition of getInts
23:02:42 <kawfee> oh, hehe
23:02:53 <kawfee> > getInts :: IO [Int]
23:02:53 <kawfee> > getInts = do n <- getInt
23:02:53 <kawfee> >       if (n == 0) then return 0
23:02:54 <kawfee> >  else do ns <- getInts; return (n:ns)
23:03:00 <kawfee> I would like a list of Int
23:03:15 <kawfee> are you in Grad school at Berk?
23:03:49 <Binkley> right, you need to return [0] in the first clause
23:03:55 <Binkley> yeah, and not very happy there...
23:04:28 <kawfee> wow, I can't believ changing that to [0] fixed it
23:04:34 <kawfee> why not?
23:04:50 <Binkley> there's no one here doing functional languages...
23:04:55 <kawfee> oh
23:05:04 <kawfee> there is here at UT
23:05:09 <Binkley> which i should have known when i was choosing schools, but i didn't really know what i wanted to do until it was too late
23:05:10 <Binkley> texas?
23:05:12 <kawfee> yes
23:05:20 <kawfee> The University Of Texas
23:05:33 <Binkley> huh, when i was looking at schools they didn't seem to have much PL stuff going on
23:05:37 <kawfee> you could always transfer
23:05:51 <Binkley> yeah, i'm thinking of leaving with a masters and applying to Ph.D programs elsewhere
23:06:01 <Binkley> but my husband is in grad school here, so that makes it complicated
23:06:05 <kawfee> sounds like a plan
23:06:13 <kawfee> oh
23:06:28 <kawfee> I would have never guessed you were a woman, it's such a male dominated field
23:06:35 <kawfee> no offense meant
23:06:47 <kawfee> so how'd you know to do [0] ?
23:06:59 <kawfee> I'm somewhat of a beginner in Haskell
23:07:01 <Binkley> well, i don't really consider myself a woman or a man, but i can get away with getting "opportunities for women" scholarships :-)
23:07:10 <Binkley> the two clauses of the if have to have the same time
23:07:14 <Binkley> the same type, even
23:07:26 <Binkley> and so if you want a list, you have to return [0]
23:07:37 <kawfee> right, I was thinking [] though
23:07:43 <kawfee> [] is the end of the list
23:08:17 <kawfee> I want nothing at the end of the list, not [0]
23:08:24 <kawfee> which is probably what will be there 
23:08:53 <Binkley> in that case, you can just return  [] instead of [0]
23:10:29 <kawfee> oh
23:10:51 <kawfee> heh, I missed that part, I see it now
23:10:53 <kawfee> thanks
23:11:12 <Binkley> sure
23:21:34 <kawfee> where did you get your undergrad?
23:21:55 <Binkley> wellesley
23:22:10 <kawfee> never head of it
23:22:12 <kawfee> heard 
23:22:32 <lament> "<Binkley> well, i don't really consider myself a woman or a man"
23:22:33 <lament> ahem.
23:23:10 <radix> o.O
23:23:42 <Binkley> well, being at a women's college made me realize i wasn't one
23:23:57 <radix> hah
23:23:58 <lament> I thought it's all about the genitalia.
23:24:06 <Binkley> nope
23:28:25 <kawfee> anyone know how to use Parselib and extract [(1,"")] the 1 from there, I have the following which gives it to me: > numeral2 = decimal +++ octal +++ hexadecimal
23:28:43 <kawfee> I forgot  how to get it out of there though
23:29:19 <kawfee> > numeral = do num <- numeral2
23:29:19 <kawfee> >       return num
23:29:28 <kawfee> I thought it was something like that but it doesn't work
23:29:46 <Binkley> what error does it give you?
23:31:45 <kawfee> I don't get one =
23:31:48 <kawfee> =]
23:32:12 <kawfee> it actually works, but my end result is a list of (n,"") where n is an integer
23:32:37 <Binkley> so if l is the result, do: (fst (unzip l))
23:32:58 <Binkley> unzip splits a list of pairs into a pair of two lists, one containing the first elements of the pairs and the other containing the second elements
23:33:10 <Binkley> then fst selects the first list from the pair
23:33:26 <kawfee> right
23:33:40 <kawfee> but I think there is a way to extract it using Parselib
23:33:53 <kawfee> I could just take the head and fst of it =]
23:34:22 <Binkley> there might be... or you can define your own function that corresponds to (fst (unzip l)) if you want it to look nicer :-)
23:38:44 <kawfee> yeah, but I have to define a parser, so I think there's a way to do it
