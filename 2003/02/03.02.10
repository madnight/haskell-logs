03:15:04 <shapr> goood morning #haskell!
03:16:02 <radix> honk
03:16:20 <radix> FORTH IF HONK THEN
03:23:23 <mgoetze> ok, iohc-jury now has 4 members
03:24:00 <creature> Hey Mike.
03:24:36 <mgoetze> hi there :)
03:24:39 <mgoetze> anyone for go?
03:24:49 <emu> where do you play?
03:25:16 <mgoetze> nngs
03:25:46 <emu> can you play as unreg?
03:25:59 <mgoetze> yeah
03:26:08 <emu> im mrd
03:26:19 <mgoetze> how good are you?
03:26:34 <emu> 18kyu on IGS
03:26:54 <mgoetze> hm...
03:27:27 <mgoetze> i'll give ya some komi then :)
03:27:41 <emu> want to play a smaller game?
03:27:47 * mgoetze has no idea how good igs ranks are, really
03:28:09 <mgoetze> hm, i'm getting a bit tired of smaller games, really
03:28:33 <mgoetze> in rl almost everyone i meet is too good for me to be able to play 19x19 against them
03:28:48 <mgoetze> and my old school friends are all so bad i have to play 9x9 with them... :)
03:30:05 <creature> And I can't even play...
03:30:06 * shapr bounces
03:30:10 <mgoetze> creature: learn :)
03:36:23 <creature> No time.
03:36:30 <creature> Or, far too little time. 
03:36:34 <shapr> it's easy to learn
03:36:41 <shapr> takes about fifteen minutes.
03:36:42 <creature> It's one of those games that's easy to learn but difficult to get good at. 
03:36:49 <shapr> yah, that's true.
03:41:02 * mgoetze wonders what emu is thinking about...
03:41:44 <shapr> I'm sure he's thinking of programming.
03:41:47 <emu> snapbacks =)
03:42:17 <mgoetze> uhm... yeah gee, i was thinking about it from the other side...
03:42:35 <emu> when you didn't respond to my hane to protect, you had already lost one of them
03:42:46 <mgoetze> yeah, i know
03:42:51 <emu> I was just trying to decide which one
03:43:06 <mgoetze> but i didn't have to lose both of them... i know
03:43:08 * mgoetze bangs head
03:43:20 <creature> It's like some strange foreign language!
03:43:27 <shapr> creature: programming?
03:46:21 <mgoetze> hm... connection is rather laggy
03:47:00 <creature> shapr - their "Go" conversations. 
03:47:07 <creature> hanes to protect, I can't follow that.
03:47:25 <emu> hane is "bending around the corner of a stone"
03:47:25 <mgoetze> creature: hoshi! komoku! sansan! tengen!
03:48:21 <mgoetze> creature: atari! seki! semeai! komi!
03:49:06 <creature> Argh!
03:49:12 * creature 's head explodes. 
03:51:50 <mgoetze> i'm alive! :D
03:56:45 * mgoetze is making use of his SENTE
03:58:07 * mgoetze makes a daring move at sansan
03:59:10 <creature> Anyway, lessons,
04:11:57 <mgoetze> hm...
04:12:01 * mgoetze thinks emu has an evil plan
04:16:41 <mgoetze> yup... evil plan alright
04:23:39 <mgoetze> er... oops
04:27:51 <shapr> hi jemfinch 
04:30:11 <mgoetze> emu: ping
04:40:53 <emu> btw, the lower right didn't have to die.  I think you could've lived by diving under rather than attacking the extension
04:42:02 <mgoetze> yeah, i know. it was a case of "saw my mistakes right after i made them" :)
04:43:50 <mgoetze> we'll have to play again when i've had some more sleep :)
04:47:29 <mgoetze> i see you're paying at least some attention to the clock :)
04:48:42 <mgoetze> creature: byo-yomi!
04:50:07 <emu> can't believe i managed to live, after placing 5 stones in 10 seconds
04:51:08 <mgoetze> problem was you'd already been messing things up too long :)
04:51:24 <emu> you build weak walls
04:51:25 <emu> :-P
04:51:58 <mgoetze> well hey, there's a price to pay for playing everywhere at once :)
04:52:11 <mgoetze> in this case it was too high... but, as i said, haven't had much sleep
04:53:00 <mgoetze> so we're in the endgame now? :)
04:53:06 <emu> i guess
04:55:57 <mgoetze> uhm... hold on... that corner was supposed to be alive...
04:56:05 <emu> not in a tight formation
04:56:39 <mgoetze> should let you fill in those liberties, then cover
04:59:54 <emu> that's not a weak spot
05:00:35 <mgoetze> that's ok, i want you to prove it anyway :)
05:02:48 <mgoetze> geez, i make an effort to improve the ko threat situation, and what do you do? close the ko :(
05:03:03 <emu> all of 1/2 point =)
05:03:18 <emu> but you filled in your territory, so make that 1.5 pts to me
05:03:22 <emu> :-P
05:03:58 <mgoetze> i lost anyway :P
05:05:43 * mgoetze will want a rematch eventually :)
05:07:15 <mgoetze> #193 was the move that changed it all
05:07:31 * mgoetze just wasn't paying attention properly
05:07:33 <emu> tnx fer game
05:07:41 <emu> the one that started the Ko?
05:08:18 <mgoetze> no, the one that didn't close the ko when you threatened to retake it
05:08:39 <mgoetze> which lost me the whole lower right
05:09:17 <mgoetze> i think i was winning up until that point
05:10:12 <emu> there was no ko until I took that point
05:10:22 <mgoetze> yeah
05:10:34 <mgoetze> and there wouldn't have been a ko if i had just covered
05:10:43 <mgoetze> i mean, it wouldn't have been easy after that
05:10:50 <mgoetze> but i'm pretty sure i would have survived
05:11:14 <emu> i still had the shot at the lower-right
05:12:08 * emu made all sorts of dumb mistakes
05:13:12 <mgoetze> with r7? i think that could have been handled
05:13:21 <mgoetze> like what? letting me live on the left? :)
05:13:26 <emu> yeah
05:13:40 <emu> and in the upper corner
05:14:52 <mgoetze> hm... can't see how you could have prevented the corner
05:15:19 <mgoetze> maybe if you played b18 before me
05:15:40 <emu> I think there was a way, at one point I realized i misplayed a hand
05:16:06 <mgoetze> in any case, you didn't make nearly as many mistakes as i did :)
05:16:40 <emu> I just took advantage of your mistakes really well =)
05:16:51 <emu> 30 point ko =)
05:17:30 <mgoetze> well, turned out to be more
05:17:46 <mgoetze> and i *did* have a 25-point ko threat... ;)
05:18:33 <emu> I decided that saving those 4 stones on the right, for certain, outweighed the corner
05:18:47 <emu> besides the captured points
05:19:21 <mgoetze> yeah, they really did damage afterwards
05:19:36 <mgoetze> actually, i was surprised you considered my ko threat as long as you did :)
05:19:59 <emu> counting up my ko threats
05:20:51 <mgoetze> i didn't see any for you which were big enough :)
05:21:18 <emu> right =)
05:22:17 <mgoetze> well, by all means let's play again some other time, and thanks for this one :)
05:22:41 <emu> k
05:22:49 <emu> arigato
07:08:47 * shapr boings
07:09:05 * Robert bojngar
07:09:20 * shapr springer
07:11:53 <Robert> :)
07:12:14 <shapr> jag är amerikanske!
07:13:30 * dark vinkar svansen.
07:13:39 <Robert> Just leeching from our welfare system, eh? :P
07:13:47 <shapr> nah, I pay lots of taxes.
07:13:58 <shapr> er
07:14:05 <Robert> Liar. Americans are filthy thieves, we all know that.
07:14:15 <Robert> Ehmm.. Simpsons :) brb
07:14:16 * shapr sniffles piteously
07:14:41 <Robert> Awww. Poor little shapr.
07:15:06 <shapr> Americans all know that swedish people are tall, blond, and have Ericsson phones.
07:16:21 <dark> Americans know that the word that comes after "Swedish" is "porn".
07:16:34 <shapr> I thought it was "bikini team"
07:17:12 * mgoetze thinks norwegian girls are even better-looking
07:17:45 <shapr> hey mgoetze, can you unpublic the archives for the iohcc-jury list?
07:18:15 <mgoetze> oh, uhm, yeah
07:18:29 <dark> Norwegian girls have more oil.
07:19:04 <shapr> I haven't heard from either wli or Chilli about being a juror
07:19:29 <shapr> should I ask Pseudonym to recruit Bernie Pope, or drop out and we go with three jurors?
07:19:47 <mgoetze> shapr: should anyone be allowed to send to the list?
07:19:56 <shapr> mgoetze: I don't know
07:20:18 <mgoetze> i mean, there's got to be some way to submit things...
07:20:32 <shapr> yah, that's true.
07:20:44 <shapr> yah, leave it open for the moment.
07:22:13 <mgoetze> archive is private now
07:22:18 <shapr> thanks :-)
07:30:06 <SyntaxPolice> hehe, you guys talking about the Evil Haskell contest?
07:30:39 <mgoetze> SyntaxPolice: send me the go thingy
07:35:43 <shapr> SyntaxPolice: yes! are you going to enter? :-)
07:37:16 <eivuokko> Evil Haskell?
07:37:45 <shapr> eivuokko: the 0th International Obfuscated Haskell Code Contest
07:39:11 <eivuokko> Hmmm.
07:39:33 <shapr> due to open very soon
07:39:48 <mgoetze> eivuokko: i presume you will be submitting an entry? :)
07:41:52 <eivuokko> I'm not sure.  I usually don't find such things enjoyable (ugly code).
07:42:22 <shapr> it's not really about ugly code
07:42:22 <eivuokko> I'm not sure if haskell has enough loopholes, either ;)
07:43:25 <shapr> heffalump said something along those lines also
07:43:30 <shapr> that's why this is the 0th contest
07:43:33 <eivuokko> It's very subjective what is ugly.  If you can compare it with c counterpart, my definition of ugly most probably would match.
07:43:53 * Igloo doesn't think there will be many good entries either  :-(
07:44:52 <eivuokko> But I guess it would be fun if one could apply template haskell and ghc-rules ;-)
07:45:45 <shapr> I think TH would be great for IOHCC, but our rules currently say "only latest released versions"
07:46:19 <shapr> Igloo, dark: do you think we should hold out for a fifth juror? or should I drop out and just do the advertising?
07:46:48 <eivuokko> That reminds me, is there some guidelines when to use let and where?  It seems that most examples and stuff use them totally randomly - which seems messy to me.
07:46:57 <SyntaxPolice> mgoetze: the go thing can be gotten from HTk's CVS repo now as I understand it... but also from my home page: http://www.syntaxpolice.org/~ijones/haskell/simpleGoBoard.tgz
07:47:00 * mgoetze thinks 3 jurors will probably be enough for now
07:47:11 <SyntaxPolice> mgoetze: remember, its just for show :)
07:47:44 <SyntaxPolice> shapr: I don't know if I'll enter... the worst Haskell is no Haskell :)
07:47:47 <mgoetze> oh yeah, i forgot, this is the thing i need a new libc for :)
07:47:57 <Igloo> eivuokko: Roughly speaking uses where whenever you can IMO
07:48:13 <Igloo> Which seems to match most of the styles I see
07:48:27 <SyntaxPolice> personally I use let when I have only one variable to bind, or a two very small binding lines.
07:48:28 <shapr> originally where and let worked differently, nowadays they should be equal
07:48:41 * Igloo has no opinion on 3v5 jurors
07:48:44 <eivuokko> Hrm, have I misunderstood then?  Are there limitations using where over let?
07:48:59 <shapr> eivuokko: not in the standard :-)
07:49:02 <Igloo> where scopes over guarded functions/cases
07:49:06 <SyntaxPolice> eivuokko: not as far as I know. I just think it looks better.
07:49:19 <Igloo> let can be used deep inside any expression
07:49:23 <shapr> Igloo: oh, I thought they were totally equal now?
07:50:05 <Igloo> I'm not sure what you mean by "worked differently", shapr?
07:50:21 <shapr> I saw a discussion on haskell@ about let vs. where
07:50:25 <shapr> some months ago
07:50:59 <Igloo> You can't do
07:51:01 <Igloo> foo x
07:51:05 <Igloo>  | f y = 1
07:51:11 <Igloo>  | g y = 2
07:51:16 <Igloo>  where y = h x
07:51:28 <Igloo> with just a let
07:53:10 <shapr> good point
08:01:36 <eivuokko> Somewhat funnily I couldn't find the pieces of code that bothered me.  In the wiki, there's TyingTheKnot which uses let and where.
08:02:15 <eivuokko> I'm pretty sure I saw some other place, that used both let and where and it got me terribly confused.
08:02:52 <Igloo> URL?
08:03:19 <eivuokko> TyingTheKnot: http://haskell.org/wiki/wiki?TyingTheKnot
08:04:07 <Igloo> It's just a stylistic thing
08:04:38 <Igloo> Nested wheres tend to look ugly
08:04:43 <eivuokko> Yea, well.  That kind of thing was pretty hard to read, imho.
08:12:04 <shapr> going back to doing Python and Java is making me realize how very spiffy and useful the Maybe monad is.
08:12:43 <Igloo> As a monad or just a datatype?
08:13:22 <shapr> I have six steps, each can fail, I'm doing it all explicitly in Python.
08:14:18 <shapr> I really like this page --> http://www.dcs.gla.ac.uk/~nww/Monad.html
08:16:49 <Igloo> Ah, right
08:19:51 * Igloo notes people with CVS commit access have an advantage for "#  best exploit of a compiler bug"  :-)
08:20:00 * SyntaxPolice was teaching Maybe to someone the other day, but he didn't understand type constructores so I had to back up.
08:20:08 <dark> Igloo: "released versions" :-)
08:20:45 <Igloo> Ah, now getting a suitable bug into a release might be harder, unless you're SimonM  :-)
08:22:48 * Janni is very impolite and just joins the channel without greeting anybody
08:23:28 <shapr> hi Janni!
08:24:12 <shapr> dark: opinion on one more or one less juror?
08:24:14 <Janni> *stare*
08:24:53 <shapr> Janni: not having a good day?
08:25:07 <shapr> Janni: stayed up late reading about partial application?
08:25:59 <Janni> no. it's a good day. it's just because original greetings are going out
08:26:12 <shapr> ah, I see.
08:29:27 <dark> shapr: No opinion.
08:29:37 <dark> shapr: Lack of opinions might make me a bad juror :-)
08:30:47 * shapr grins
08:30:56 <shapr> you have strong opinions on Haskell source though
08:33:11 <dark> Who, me?  *innocence*
08:39:47 * dark wonders if anyone ever uses some of these x86 instructions.
08:44:51 <dark> I need to learn how to chop onions with my eyes closed.
08:46:00 <emu> you need to learn to love onions
08:46:29 <liiwi> dark: cold, running water helps.
08:46:31 <eivuokko> That sounds somewhat risky :)  You could try having some water on the ... board or whatever you have under onion when you chop them.
08:46:39 <Igloo> Learning to hate them would work too
08:51:58 <emu> Hate leads to the dark side
08:52:09 <emu> but I guess he's already there
08:57:15 * shapr snickers
09:10:26 <hdaume> 'morning all
09:12:27 <Igloo> Hi Hal
09:33:52 <shapr> hi hal
09:47:20 <shapr> hm, what's swedish for 'web page' ?
09:56:54 * shapr sends a broken link report in swedish to the guy who wrote the bnf to Happy converter
09:57:39 <Smerdyakov> Oo. Just got an admission notice to the CMU CS PhD program.
09:58:00 <shapr> Smerdyakov: yay! you're a PhD student!
09:58:06 <Smerdyakov> I will be.
09:58:12 <Smerdyakov> In the fall =)
09:58:18 <shapr> congraduations!
09:58:31 <Robert> Grattis!
09:58:53 <Smerdyakov> I was just about to call Princeton to make sure some sillyness with missing application materials got worked out... but I don't know if I care now ;-)
09:59:32 <jlouis> Smerdyakov: gratz :)
09:59:50 <Smerdyakov> This also means I can slack off even more on the research project I'm doing, since it can't influence this. =D
10:00:02 <shapr> you could learn Haskell!
10:00:08 <shapr> you could even enter the IOHCC!
10:00:11 <Smerdyakov> I already basically know Haskell, goofball.
10:00:17 * shapr teases Smerdyakov viciously
10:00:18 <Janni> what's PhD?
10:00:46 <shapr> Doctor of Philosophy
10:00:59 <Smerdyakov> It's "learn to be a researcher by being an apprentice to some for 6 years" =)
10:01:07 <shapr> yah, what he said.
10:01:27 <Smerdyakov> Generally required to get a job as a professor or research scientist
10:01:28 <Janni> s/Philosophy/Physics?
10:01:38 <shapr> Janni: in the US, you get a four year degree first, and then spend 3 to 7 years getting a PhD
10:01:50 <Smerdyakov> "Philosophy" is used in an archaic sense here to encompass most all of human knowledge.
10:02:26 <Janni> nice
10:03:34 * shapr reads http://www.cs.chalmers.se/~aarne/BNF/
10:04:41 * jlouis gets more hot chocolate for his throat
10:05:08 <jlouis> .plan: type checker
10:06:56 * Janni is looking for a good email provider which provides an account in a "alternative" TLD (less spam)
10:08:14 <jlouis> spam-checker in haskell?
10:08:29 <jlouis> there must be possibilities for shapr's lib there :)
10:08:39 * shapr grins
10:09:18 <shapr> actually, I think dark's HMM code might be more useful for a paul graham style spam checker.
10:09:37 <jlouis> HMM?
10:09:50 <shapr> hidden markov model
10:10:12 <jlouis> hmm
10:10:13 <shapr> er, wait...
10:10:32 <shapr> does paul graham use bayesian statistics in his spam checker?
10:10:42 <jlouis> his first version did
10:10:53 <jlouis> I think he has rethought the alogrithm
10:11:06 <jlouis> I've seen some based on chi-square too
10:12:37 <dark> I've seen a critique that showed Paul Graham never used Bayesian calculations :)
10:13:14 <jlouis> hehe
10:13:14 <dark> On the other hand, I think Paul made some good points for the algorithms he actually used, and the people who seek to "improve" on it have missed some of them.
10:13:18 <jlouis> _that_ is news
10:13:41 <dark> I don't have any HMM code, but I think it'd be a neat basis for a spam filter.
10:13:48 <shapr> I realize I don't actually know whether bayesian statistics and HMMs are related.
10:14:01 <shapr> they seem to be conceptually related, are they at all similar mathematically?
10:14:11 <shapr> how does megahal work?
10:14:13 <jlouis> the abstract idea of statistically filtering spam is certainly interesting, though It needs to be trained
10:14:21 <shapr> for some reason I thought megahal was using an HMM
10:14:30 <dark> shapr: Hmm, you know, it might be.  I didn't think of that.
10:14:32 <shapr> I have enough spam to train very many spam filters.
10:14:39 <jlouis> shapr: hehe, me too
10:15:11 <dark> But megahal doesn't use it to find correlations, it uses it for babbling.
10:15:27 <dark> And I've stared at its code enough to find points where its algorithms don't make sense mathematically :)
10:15:45 <shapr> you generate the babbling from correlations, don't you?
10:16:20 <dark> For example, it selects a new word from a weighted set by picking a random number in the range 0 .. total_weights, then going through the list until it finds the picked number or it finds a keyword.
10:16:55 <dark> As far as I can tell the chance of a keyword occurring earlier or later in the list depends on accidents of training and memory allocation.
10:17:47 <eivuokko> That sounds pretty reasonable for generating human interaction (for fun).
10:17:57 <dark> eviltwin's algorithms make more sense but don't seem to work as well :-)  this might be one of the great principles of software design.
10:19:43 <jlouis> nothing works?
10:20:03 <dark> jlouis: Maybe "if you can prove it, it wasn't worth proving".
10:20:39 <jlouis> hehe
10:20:43 <jlouis> Pairing heaps
10:20:50 <jlouis> proof of concept
10:22:55 <dark> shapr: By the way, do you know that oft-misquoted quote that contains "And then they came for the Jews, but I was not a Jew"?
10:25:19 <shapr> I've heard it once
10:25:30 <shapr> I don't know if I heard the original or a misquote, or what
10:27:46 <dark> shapr: I was wondering if there's any awareness in the US that the original started with "First they came for the Communists" :)
10:27:46 <whee> I remember that quote
10:27:55 <whee> heh
10:28:20 <whee> dark: 99% of the US doesn't know where australia is
10:28:24 <whee> we refer to it as "fosters"
10:29:07 <Fractal> "Oh marge, it's easy to miss Canada on the map, all tucked away down there..."
10:29:18 <jlouis> hehe
10:30:35 <shapr> dark: I haven't been back to the US in 1.5 years, I don't know.
10:31:55 <shapr> I've spent four weeks or so in the US in the last 3.5 years, I can tell you more about swedish and finnish attitudes than US attitudes.
10:32:17 <Janni> whee: even over 80% of the US don't know where the USA are...
10:32:25 <hdaume> dark: a bit late, but there's nothing wrong with that method of selecting words
10:32:36 <SyntaxPolice> shapr: I hear you mentioned our haskellLibTracker on comp.lang.functional :)
10:32:38 <dark> Janni: Wouldn't "here" be a sufficient answer?
10:32:44 <shapr> SyntaxPolice: wow, you already heard that? :-)
10:32:47 <Janni> dark: on the map of course
10:32:59 <Janni> dark: but i know what you mean
10:33:05 <dark> hdaume: But the chance of seeing a keyword before the selected item is essentially arbitrary.
10:33:11 <whee> dark: it's pretty bad, most people don't know where most of the states are
10:33:19 <Smerdyakov> whee, why does that matter?
10:33:23 <whee> and these are the same people who probably want a war in some place over there :)
10:33:27 <dark> Janni: Finding it on the map is more an indication of knowing where everywhere else is :)
10:33:38 <Janni> dark: exactly
10:33:40 <shapr> hi Marvin--
10:33:48 <Marvin--> hello
10:34:01 <whee> Smerdyakov: it's good to know where you are in relation to everything else, and what everything else is
10:34:05 <shapr> Marvin--: I've given in and started looking at LBNF and RFC2822...
10:34:08 <Smerdyakov> whee, justify.
10:34:13 <Marvin--> shapr: heh
10:34:17 <whee> I think I'll go eat lunch instead :)
10:34:23 <shapr> do you know if anyone has tried to use LBNF to do IETF ABNF?
10:34:34 <Smerdyakov> OK. You probably don't have a reason, like the rest of the people who act appalled at failure in "map finding" exercises.
10:34:39 <Janni> Smerdyakov: IMHO it is not too bad, that people don't know, where the states are, but it's an indicator that they don't care other states in the world but the USA
10:34:54 <Marvin--> guh
10:35:09 <Smerdyakov> Much more useful would be "place your country's society/government in the spectrum of applicable philosophies"
10:35:17 <shapr> also, when I can I apt-get bnfconv? :-)
10:35:26 <dark> Smerdyakov: It's much harder to define the correct answer to that :)
10:35:35 <Marvin--> somehow my computer has decided that it's a good idea to route all traffic through eth1
10:36:34 <shapr> cool!
10:36:58 <Janni> Marvin: don't we all want to have computers which do, what we want and not, what me tell them to do?
10:37:10 <Marvin--> shapr: sorry, I haven't had time... And I probably need to talk to Aarne about licensing
10:37:14 <Marvin--> Janni: amen
10:37:23 <Janni> plural + which <- is that correct?
10:37:25 <shapr> Marvin--: just hoping you still wanted to package it :-)
10:37:32 <Janni> s/me/we (of course)
10:37:58 <Marvin--> shapr: yeah, I will
10:38:23 <jlouis> eth1... linux.... yuck!
10:38:35 <jlouis> gimme xl0 instead thankyou ;)
10:38:39 <Marvin--> HAHA, "I'm a level 5 vegan, I don't eat anything that gives a shadow"
10:39:00 <jlouis> Marvin--: hehe
10:39:10 <Janni> jlouis: not everybody's using 3com
10:39:43 <Janni> jloius: hmm. doesn't ethX appear for other ethernet cards in BSD?
10:40:16 <Smerdyakov> The need to consider "hardware compatibility" in creating OS's is yet another indication of how horribly wrong capitalism is.
10:41:10 <dark> Smerdyakov: Uh...
10:41:27 <Marvin--> oh wait, I think I've got it, I'm not supposed to have 'auto eth1' in the interfaces file :P
10:41:31 <Smerdyakov> dark, ?
10:41:45 <dark> Smerdyakov: I don't see how that follows from anything.
10:41:57 <eivuokko> Just out of curiosity, does "wrong", by your definition, mean that it's also inferior compared to something else?
10:42:08 <Smerdyakov> dark, capitalism promotes many groups producing incompatible hardware.
10:42:15 <Smerdyakov> eivuokko, yes. http://www.anarchismfaq.org/
10:44:23 <jlouis> Janni: nope, you dont logically map to ethX, you use the <driver>#
10:44:35 <shapr> anarchism promotes everyone building their own transistors, right?
10:44:44 <eivuokko> iiik.
10:45:05 <dark> I think it depends on whether you're using "capitalism" as shorthand for "free market" or as shorthand for "state-backed corporate power".
10:45:51 <dark> A free market encourages compatible hardware, because hardware which is incompatible with customers' software is at a disadvantage.
10:47:11 <Marvin--> no wait, when I don't have auto eth1 I can't reach the laptop
10:47:38 <dark> Marvin: Sounds to me like it's more likely to be a routing problem than a kernel module problem.
10:47:52 <Smerdyakov> Anarchism promotes people working together to develop optimal solutions to problems.
10:48:03 <Marvin--> I just wonder what to configure and where
10:48:34 <Marvin--> I mean, obviously I want both eth0 and eth1 configured, but does the order matter? How do I tell everything where to route?
10:48:46 <Smerdyakov> I don't know if it's too helpful for me to specify exactly what I mean by "capitalism," but I mean something that includes the current situation in the USA, for example.
10:51:42 <dark> Marvin: Which part of your system brings the routes up?  You need to have exactly one default route.
10:52:52 <shapr> hi pseiko
10:52:55 <Marvin--> dark: ... I don't know how this works... I've just fiddled with /etc/network/interfaces
10:53:14 <shapr> pseiko: new to haskell? or long-time user?
10:53:41 <dark> Marvin: What does /sbin/route say?
10:54:39 <Marvin--> dark: gimme a sec, have to fiddle files and stuff quickly
10:55:17 <Marvin--> er
10:55:27 <Marvin--> when I have both eth0 and eth1 up, /sbin/route hangs
10:56:05 <shapr> try it with route -n
10:56:54 <Marvin--> hmm
10:57:07 <Marvin--> ah, this seems to be working
10:57:20 <Marvin--> I commented out the 'gateway' line for eth1 from interfaces
10:57:58 <Marvin--> phew :)
10:58:20 <dark> Marvin: Sounds about right.
10:58:29 <Marvin--> now I have to figure out why my unofficial-acpi-and-suspend-patched kernel didn't boot
10:58:35 <dark> Heh, this made me notice that I have two routes for the local network in my table.
10:58:48 <Marvin--> heh
11:00:56 <Marvin--> hmm, is there a kernel option regulating whether the kernel should use an initrd or not?
11:01:43 <Marvin--> or is it all in make-kpkg --initrd?
11:02:21 <dark> That's outside my experience.
11:02:40 <Marvin--> I'm starting to wonder if it was a bad idea to copy the config file from a debian kernel :)
11:02:49 <Marvin--> I usually build without initrd since I don't know anything about it
11:03:58 <shapr> SyntaxPolice: I think haskellLibTracker will be a great success once it gets the ability to edit individual existing entries. I think local cached copies of the libs will contribute to long-term success.
11:08:07 <pseiko> hi everybody, does anyone here use the ghc? and is a littlebit advanced in it, too?
11:09:08 <Marvin--> let's try building one with initrd instead
11:10:49 <dark> pseiko: I think most people here use ghc.
11:11:03 <pseiko> shapr: a long-time user, i would say :-)
11:11:17 <Marvin--> "By default, I asume you know what you are doing, and I apologize for being so annoying. Should I abort[Ny]?"
11:11:42 <dark> Marvin: Whiny software :)
11:12:13 <Marvin--> Manoj's sense of humor
11:12:26 <pseiko> ok, than I have a little question, I want to implement the OHaskell-concepts into the ghc, what do you all think about that plan?
11:13:18 <Marvin--> considering how long it took to compile the damn kernel last time, I'd better plug in the adapter
11:16:14 <shapr> pseiko: some of it will be easy, some of it will be hard :-)
11:16:39 <Marvin--> pseiko: it means you have to dig around in the ghc internals
11:16:45 <Marvin--> pseiko: which in turn means you're insane :)
11:16:56 <shapr> pseiko: one of the Simons recently expressed interest in implementing something like TREX for GHC
11:17:06 <shapr> that would help you along the way
11:17:20 * Marvin-- watches his laptop chew chew chew
11:17:38 <shapr> I suspect you could fake an inheritance tree of classes with Template Haskell
11:18:06 <pseiko> shapr: i want to do this job in the context of my diploma thesis and i am prepared to do a lot of work *g*
11:18:10 * shapr looks for the list of OHaskell features.
11:18:28 <Marvin--> "If anyone in the area wants to meet, have a beer etc. do not hesitate to
11:18:28 <Marvin--> contact me. I am French but nice." hahaha
11:18:39 <shapr> hm, what's the OHaskell url again?
11:18:44 <shapr> Marvin--: hah!
11:18:54 <shapr> I've met some very nice french people.
11:19:02 <shapr> and other french people.
11:19:25 <Marvin--> shapr: cs.chalmers something, I don't remember who
11:19:26 <shapr> pseiko: sounds like a great diploma project to me
11:19:33 <shapr> yah, I'm trying to remember also
11:19:43 <shapr> I'll give in and use the other half of my brain
11:19:44 * shapr googles 
11:19:53 <Marvin--> what, the creative one? the lazy one?
11:19:58 <shapr> no, google
11:20:00 <shapr> http://www.math.chalmers.se/~nordland/ohaskell/
11:20:02 <shapr> that was too easy.
11:20:46 <Marvin--> ah, yes, Nordland
11:21:27 <Marvin--> cool, I've gotta try O'Hugs
11:21:27 <pseiko> do you have any suggestions how to get in the ghc internals?
11:21:43 <shapr> read manuel chakravarty's guide to the GHC internals.
11:21:44 <Marvin--> wikkan sacrifices
11:21:46 <shapr> buy a lot of alcohol
11:21:52 <shapr> and a lot of coffee
11:21:57 <pseiko> Marvin: but this is an old project not maintained afaik
11:22:20 <pseiko> shapr: i have already started in doing so
11:22:32 <shapr> pseiko: send expensive whiskey to the Simons and Manuel
11:22:38 * shapr grins
11:22:53 <Marvin--> shapr: or even better, whisky
11:23:18 <shapr> my american ispell says whiskey
11:24:11 <pseiko> but do you think it can be possible to do this job in half a year?
11:24:35 <Marvin--> shapr: your problem is in "american"
11:25:21 <shapr> jag är amerikanske!
11:25:26 <Marvin--> shapr: American whiskey is whiskey, real whisky, from Scotland, is whisky
11:25:29 <Robert> Heh.
11:25:39 <shapr> men, jag bor i Boden
11:25:44 <Robert> shapr: "amerikan", or possibly "amerikans". :)
11:25:50 <Robert> +k
11:25:56 <Robert> amerikansk*
11:26:01 <shapr> amerikanske == american + maybe
11:26:13 <Robert> Bah... That sucks.
11:26:22 <Marvin--> yay, someone to help me correct shapr's lousy Swedish :P
11:26:24 <Robert> It's not even funny :)
11:26:26 <shapr> it's not a good swedish pun?
11:26:27 <eivuokko> Haha.
11:26:28 <shapr> awww
11:26:34 <Robert> Hehe.
11:26:37 <shapr> I thought it was funny :-)
11:26:48 <Robert> Well, americans aren't supposed to be funny, so I guess I will have to forgive you.
11:26:52 * shapr laughs
11:27:31 <shapr> pseiko: I think much of O'Haskell can be implemented with Template Haskell
11:27:46 <Marvin--> now that's evil
11:28:04 <shapr> Template O'Haskell?
11:28:59 <pseiko> would you use the OHaskell features once implemented? shapr: i am sorry to say that i don't know about template haskell up to now
11:29:50 <eivuokko> Hmm.  Can you add notes with template haskell, to be used later?
11:30:17 <shapr> huh?
11:31:07 <Igloo> I realised you can't manipulate pragmas the other day, but I don't think their position is restricted, so it would be a nightmare to do right
11:31:31 <eivuokko> I think that ghc, like most compilers, can add "notes" to internal tree structures, they are just passed around.
11:31:46 <hdaume> eivuokko: you can't add generic notes
11:32:06 <hdaume> (and simonpj doesn't seem to thrilled about allowing it -- i had a rather lengthy discussion with him about it very recently)
11:32:16 <hdaume> (but one solution is to just use the SCC pragma)
11:32:17 <Igloo> I don't see what you're looking to gain from it
11:32:40 <shapr> I like the implicit concurrency of actions in OHaskell
11:33:25 <pseiko> do you think "typing haskell in haskell" is a good starting point for my long and heavy way?
11:33:55 <Marvin--> if not, at least it's a very interesting paper :)
11:34:43 <pseiko> i have already read it but i wonder if i should try to implement it in this framework first
11:37:01 <Marvin--> I think a good starting point would be to decide on a subset and implement that first
11:38:12 <shapr> yah, I'd suggest trying to write a small and dirty implementation of each feature, that way you get to see which ones will be hardest, and work on those first.
11:39:40 <pseiko> dirty sounds like all having to start from the beginning again *g*
11:40:28 <shapr> in my experience, it's best to first write a tiny barely working implementation of something that I've never written before.
11:40:35 <shapr> because usually, my first attempt sucks very much.
11:40:47 * Robert agrees with shapr.
11:40:59 <shapr> but teaches me a lot about what my second 'real' implementation should be
11:41:38 <pseiko> sounds like a good plan to me
11:44:30 <shapr> does GHC have IPv6 support?
12:12:58 <dark> shapr: I didn't find any IPv6 support when I looked for it.
12:13:11 <dark> shapr: Obviously we should fix this :)
12:13:22 <shapr> I agree.
12:13:32 <shapr> especially since there's that big IPv6 contest on
12:13:46 <dark> Let's refer to the excellent documentation on IPv6 socket functions...
12:14:00 <shapr> there are docs?
12:14:14 <dark> Not as far as I know.
12:14:16 <shapr> oh
12:14:29 <dark> Everyone follows the traditional method of copying someone else's network code.
12:14:34 <shapr> I see.
12:14:43 <shapr> I guess we get to commit some original sins then.
12:14:59 <dark> I once divided MUD drivers into three main trees on the basis of the errors in their telnet code :)
12:15:11 * shapr snickers
12:15:29 <dark> Diku was the winner with its LFCR line termination.
12:15:36 <shapr> !
12:16:02 <shapr> hm, I have some free time now..
12:16:18 <shapr> do I play with ABNF, haskellLibTracker, or look at IPv6?
12:17:10 <dark> Which is least likely to drive you insane with cosmic horror?
12:17:21 <shapr> well, they're all fun
12:18:36 <shapr> I'll take 'community building' for $100, Dave.
12:19:00 <dark> Have you ever played "You Don't Know Jack"?
12:19:13 <shapr> yes!
12:19:14 <shapr> great fun!
12:19:27 <shapr> I can kick butt with that game.
12:19:28 <dark> We organize parties around YDKJ tournaments :)
12:19:38 <shapr> cool!
12:20:40 <dark> I wish I could find the British version, though.
12:20:54 <dark> For one thing, I have an unfair advantage with American trivia :-)
12:21:04 <shapr> how so?
12:21:24 <dark> I've actually lived in Texas and had American history in school.
12:21:29 <shapr> oh cool
12:22:53 <dark> There's one episode that seems to have endless amounts of questions about the Brady Bunch.
12:23:35 <Sucht`on|Hase> http://lotux.homelinux.org/~camold/ !!! sorry for amsg :-<
12:23:48 <dark> Heh, kuro5hin has an article about the history of the pointy stick.
12:33:23 * dark looks for an x86 instruction that moves ZF into a register.
12:34:05 <jlouis> a flag into a reg?
12:34:15 <jlouis> that arch is fatally flawed anyway :)
12:36:07 <dark> jlouis: It's easy with the carry flag :)
12:36:47 <jlouis> hmm
12:37:01 <jlouis> I happen to dont know the flawed arch very well ;)
12:37:09 <jlouis> CISC is dark dark land to me
12:38:32 <dark> Hmm, maybe with a REPZ on an instruction that always sets ZF to 0
12:39:02 <dark> Like: set ax to 0, then repz inc ax
12:40:07 <jlouis> could do it
12:45:01 <dark> Hm, no.  REPZ is only defined to work on string instructions, and the flag is only checked after the first iteration anyway.
12:48:39 <jlouis> heh
12:49:10 <jlouis> You are definitely not following the true path of the CISC programmer
12:49:15 <jlouis> then again... who is?
12:49:51 <mgoetze> jlouis: don't think anyone has been since the pdp-10 died out
12:50:32 <jlouis> not _real_ CISC'ers for sure mgoetze 
12:50:42 <dark> The true path would be to campaign for the inclusion of a movzf instruction :)
12:51:19 <dark> I want to avoid using a jump because that means fiddling with local labels :)
12:52:11 <jlouis> impurist. may you burn in hell ;P
12:53:04 * mgoetze wants a CISC processor with a DWIM command
12:53:23 <dark> Double Wide Immediate Move?
12:53:33 <mgoetze> Do What I Mean :)
12:55:55 <dark> x86 has "INVLPG"
12:56:10 <mgoetze> meaning...?
12:56:56 <dark> "Invalidate TLB entry", apparently.
12:57:12 <mgoetze> hm... itneresting :)
13:14:06 <dark> Bah.  All this effort for an instruction that nobody uses.
13:14:14 <dark> Not even the linux kernel uses "verr" or "verw".
13:14:45 <dark> You know, I think I'll just not support it.  Muah-ah-ah-hahah.
13:17:56 <mgoetze> dark: wanna play go? :)
13:21:49 <dark> mgoetze: No.  I guess I'm in a non-Go phase.
13:22:44 <dark> mgoetze: I seem to dig the game only about once a year :)
13:23:36 <mgoetze> dark: oh, well, lemme know when it comes up again :)
13:25:28 <pseiko> bye everybody
13:29:03 <dark> "Half of us fail the Turing Test on an average day."
13:29:15 <dark> mgoetze: Certainly :)
13:30:02 <Igloo> Where's that from, dark?
13:35:29 <dark> Igloo: Comment on kuro5hin
13:37:53 <dark> Bah.  I'm stuck because I think that eventually I'll need a way to decompile code that was originally an asm statement, and I suspect this will require redesigning the whole disassembler.
13:38:18 <dark> I should probably apply the refactoring principle and just ignore the issue until I actually need it.
13:50:52 <Igloo> Ah, OK, ta
14:04:41 <ac_fosdem> oh right, I'm back
14:05:16 <Marvin--> fosdem?
14:05:41 <andersca> yeah
14:05:45 <Marvin--> whassat?
14:05:48 <andersca> free software conference in belgium
14:05:51 <andersca> www.fosdem.org
14:05:53 <Marvin--> oh
14:06:24 <mgoetze> s/conference/conspiracy/
14:36:16 <Pseudonym> G'day.
14:36:41 <Pseudonym> dark: Nobody uses IN and OUT in normal programming either.
14:36:56 * Marvin-- kinda likes the error handling we implemented in our compiler frontend
15:36:47 <jlouis> phew, I am a lazy guy after all
15:51:49 <Sucht`on|Hase> //amsg\\\ good night to all ! have a nice sleep and see you tomorrow ...
16:51:58 <dark> Pseudonym: Yeah but they're found in inline asm in the linux kernel :)
16:52:17 <dark> Pseudonym: binary-only kernel modules are one of my targets for uncc, so I want to be able to deal with that.
16:58:29 <Pseudonym> Sorry, what's uncc?
16:59:00 <Pseudonym> The Sparc has STBAR.
16:59:10 <Pseudonym> If you're after weird ops.
16:59:43 <jlouis> Pseudonym: STBAR?
16:59:48 <Pseudonym> Store barrier.
17:00:10 <Pseudonym> It ensures that all stores to memory that occur before the stbar operation are written to memory before the ones that come after it.
17:00:11 <jlouis> to ensure write-back?
17:00:18 <jlouis> yup
17:00:23 <Pseudonym> No, it doesn't ensure write back.
17:00:35 <Pseudonym> It ensures that when write back does happen, the order is predictable.
17:00:41 <jlouis> ah
17:00:46 <jlouis> quirk there
17:01:09 <Pseudonym> It makes sense when you think about it.
17:01:31 <Pseudonym> When you release a spin lock, you want the data written before the spin lock is released to occur before the spin lock is actually released.
17:02:00 <jlouis> so an unlock goes: STBAR, unlock()
17:02:42 <Pseudonym> Right.
17:02:52 <Pseudonym> And that's basically its only use.
17:03:24 <jlouis> though it is a good use
17:03:30 <Pseudonym> The alpha has two NOP operations, nop an unop.
17:03:41 <jlouis> nop is the usual
17:03:44 <jlouis> what about unop?
17:04:13 <jlouis> afair it has some nifty mem-barriers too
17:04:20 <Pseudonym> Universal nop.
17:04:24 <jlouis> aha
17:04:26 * Pseudonym has no idea if there's any difference.
17:05:01 <Pseudonym> Manual section 1: No Operation has no effect on the machine state.
17:05:10 <Pseudonym> Manual section 2: Universal No Operation has no effect on the machine state.
17:05:15 * Pseudonym shrugs
17:05:26 <jlouis> heh
17:05:32 <jlouis> very explanative
17:06:37 <jlouis> hehe
17:06:52 <Pseudonym> Yes, the alpha has mb and wmb.
17:07:01 <Pseudonym> It also has exception barriers and trap barriers, which are cool.
17:07:25 <jlouis> whoa
17:07:29 <Pseudonym> An exception barrier makes sure that all code before the barrier runs without raising an exception before any code after the barrier.
17:07:36 <jlouis> in general, the alpha is quite nice
17:07:40 <Pseudonym> Yes, it is.
17:07:54 <Pseudonym> I think it's nice because they deliberately didn't try anything fancy.
17:07:55 <jlouis> We programmed kernels from scratch on some 21164's
17:08:14 <jlouis> Was too easy due to the pal layer
17:10:11 <Pseudonym> I haven't looked into that sort of thing.
17:10:42 <jlouis> they have a EPROM filled with assembly for the ''harder'' parts
17:10:52 <jlouis> system call traps, interrupt traps etc
17:10:53 <Pseudonym> Oh, very cool.
17:10:57 <dark> Pseudonym: uncc is my decompiler project (machine code to C).  So far I'm just focusing on static i386 ELF binaries, but I plan to adapt it to whatever I need to decompile in the future.
17:11:01 <jlouis> context switches
17:11:06 <Pseudonym> dark: Gotcha.
17:11:19 <Pseudonym> Nice, so it's basically the nanokernel.
17:11:30 <dark> I think the smart thing is to ignore all the difficult instructions until I get the normal ones right :)
17:11:31 <Pseudonym> And it's automagically optimised for your CPU.
17:11:34 <jlouis> Pseudonym: yes
17:11:58 <Pseudonym> Very, very neat.
17:12:34 <jlouis> intelligent. Makes it a lot easier to do a lot of things. I think we had about 80 lines of alpha assembly
17:13:16 <jlouis> and we did not use the pal_ctxswtch, so the context switch is accounted for in those 80 lines
17:13:22 <jlouis> no float savings though
18:17:49 <kawfee> Syntax error in declaration (unexpected `;',
18:17:56 <kawfee> why do I keep getting those?
18:18:39 <kawfee> > sumAndLength ns = sumAndLength2 ns x y 
18:18:40 <kawfee> >     where x = 0
18:18:40 <kawfee> >   y = 0
18:18:48 <jlouis> indent y = 0
18:19:09 <jlouis> the y should be under the x
18:19:32 <kawfee> yeah it is
18:19:48 <kawfee> > sumAndLength ns :: [Int]-> (Int, Int)
18:19:48 <kawfee> > sumAndLength ns = let x = 0
18:19:48 <kawfee> >y = 0
18:19:49 <kawfee> >in sumAndLength x y
18:19:56 <kawfee> still not showing indentation
18:20:03 <kawfee> that y and in are under the x
18:20:14 <kawfee> is there a scrtipt that will automagically indent?
18:20:25 <kawfee> I'm using emacs, and I tried haskell mode but it isn't doing the job
18:20:27 <jlouis> then make explicit {}'s
18:20:43 <kawfee> ?
18:20:49 <kawfee> what do you mean?
18:21:06 <jlouis> you can surround blocks of code by { and } almost like C
18:21:14 <jlouis> to show where the scope begins and ends
18:21:23 <jlouis> though normally it will be able to figure it out
18:21:39 <jlouis> it can normally deduce the line ok
18:21:55 <kawfee> hrm
18:22:01 <kawfee> well I think I know how to indent
18:24:12 <jlouis> ERROR "TypeCheck.lhs":43 - Syntax error in expression (unexpected `;', possibly due to bad layout)
18:24:17 <jlouis> I can too ;P
18:28:03 <jlouis> I had a let..in block with no indentation. It was not happy about that
18:31:55 <kawfee> how do you use the haskell-indent, what button indents?
18:32:08 <kawfee> tab?
18:32:40 <kawfee> hrm
18:32:44 <kawfee> they aren't lining up very nicely
18:41:00 <kawfee> these errors wont go away
18:41:01 <kawfee> > sumAndLength ns = (1,2)
18:41:06 <kawfee> I get the same error for that
18:41:34 <kawfee> it was the line above
18:41:36 <kawfee> heh
18:41:43 <kawfee> sumAndLength ns :: [Int]-> (Int,Int)
18:43:36 <kawfee> fixed
18:43:38 <kawfee> thanks 
18:48:10 <kawfee> anyone know of a site where I can search for functions?
18:48:24 <Pseudonym> www.lotsoffunctions.com?
18:48:26 * Pseudonym shrugs
18:49:02 <kawfee> hah
18:49:07 <kawfee> you're funny
18:49:10 <Pseudonym> What sort of functions?
18:49:12 <kawfee> I need float div
18:49:16 <kawfee> dunno what it is
18:49:19 <Pseudonym> It's /
18:49:21 <kawfee> I know Int div is `div`
18:49:24 <kawfee> okj
18:49:25 <kawfee> ok
18:52:30 <kawfee> Type error in explicitly typed binding
18:52:30 <kawfee> *** Term           : average
18:52:30 <kawfee> *** Type           : [Int] -> Int
18:52:30 <kawfee> *** Does not match : [Int] -> Float
18:52:35 <kawfee> > average :: [Int]->Float
18:52:43 <kawfee> I have it defined nad it is complaining
18:53:03 <kawfee> I'm using /
18:53:17 <kawfee> > average ns = let a = fst x
18:53:18 <kawfee> >   b = snd x
18:53:18 <kawfee> >   x = sumAndLength ns
18:53:18 <kawfee> >   in a/b 
18:53:38 <kawfee> is there some typing I need to do with a and b >?
18:53:48 <Pseudonym> Yes.  You need to convert them to floats.
18:54:06 <Pseudonym> I use this handy function:
18:54:06 <kawfee> how?
18:54:15 <Pseudonym> fromInt :: (Num a) => Int -> a
18:54:20 <Pseudonym> fromInt = fromInteger . toInteger
18:54:31 <kawfee> they are defined in the prelude?
18:54:57 <Pseudonym> fromInteger and toInteger are.
18:54:59 <Pseudonym> fromInt isn't.
18:55:35 <kawfee> yeah
18:55:37 <kawfee> hrm
18:55:47 <kawfee> what does that . do?
18:56:16 <Pseudonym> It's function composition
18:56:20 <kawfee> hrm
18:56:23 <Pseudonym> f . g = \x -> f (g x)
18:56:30 <Pseudonym> It's pronounced "of" in maths.
18:56:45 <Pseudonym> So in this case:
18:56:48 <Pseudonym> fromInt = fromInteger . toInteger
18:56:59 <Pseudonym> fromInt x = fromInteger (toInteger x)
18:57:55 <kawfee> I think we are due to discuss that
18:58:24 <kawfee> so fromInt = fromInteger . toFloat 
18:58:47 <Pseudonym> No.
18:58:57 <Pseudonym> fromInt = fromInteger . toInteger
18:59:10 <kawfee> primitive primIntToFloat     :: Int -> Floatprimitive primIntToFloat     :: Int -> Float
18:59:17 <kawfee> it's defined in the prelude =]
19:00:18 <Pseudonym> There you go.
19:00:24 <Pseudonym> But it's not standard.
19:00:27 <kawfee> it didn't do it
19:00:42 <kawfee> RROR "hw3.lhs":103 - Undefined variable "primIntToFloat"
19:00:49 <Pseudonym> Probably not exported.
19:01:46 <kawfee> how would I export it?
19:05:13 <Pseudonym> You don't.,
19:05:19 <Pseudonym> It's private to a module.
19:05:36 <Pseudonym> You use fromInt. :-)
19:11:42 <Pseudonym> Greetings.
19:11:45 <shapr> greetz
19:11:47 <shapr> wassup?
19:11:56 <shapr> I haven't heard from either Chilli or wli
19:14:26 * Pseudonym nods
19:14:32 <Pseudonym> Aaargh.  Killer heartburn.
19:14:47 <shapr> Pseudonym: I think you should ask bjpop
19:15:01 <shapr> if he says no, or doesn't respond, then we go with three jurors
19:15:23 <Pseudonym> For the 0th contest, would it be so bad to have only four?
19:15:31 <shapr> no, it wouldn't
19:15:35 <shapr> I like that idea.
19:15:43 * Pseudonym is trying to weasel out of doing anything here
19:15:46 * shapr snickers
19:15:49 <Pseudonym> Apart from judging, of course.
19:15:59 <Pseudonym> Laziness is a programmer virtue.
19:15:59 <shapr> it's okay with me.
19:16:07 <shapr> lazy evaluation especially
19:16:31 <Pseudonym> I have a job going trying to evaluate the optimal game tree for the Nokia GSM phone "logic" game.
19:16:50 <shapr> ohno
19:16:53 <Pseudonym> Basically mastermind, only with blank moves.
19:16:56 <shapr> nokia is everywhere
19:17:00 * Pseudonym nods
19:17:07 <Pseudonym> I note that the game isn't on the more recent phones.
19:17:13 <Pseudonym> Mine is ~5 years old.
19:17:22 <shapr> mine is very recent
19:17:41 <shapr> I was working for a company that worked primarily for Nokia
19:17:45 <Pseudonym> Aha.
19:17:49 <Pseudonym> You have "logic"?
19:17:51 <shapr> no
19:17:55 * Pseudonym nods
19:18:04 <shapr> but I have J2ME and bluetooth on my phone.
19:18:09 <shapr> not that they can talk to each other
19:18:18 <Pseudonym> I have very little on mine.
19:18:30 <shapr> I can write Java programs for mine.
19:18:35 <Pseudonym> Woohoo.
19:18:41 <shapr> not that I want to, unless the GHC java bytecode backend starts working.
19:18:57 <Pseudonym> Or, you could write your own compiler which compiles to JVM.
19:19:03 <shapr> that's true
19:19:36 <shapr> should we leave the jurors list open so people can submit that way?
19:19:45 <shapr> should we have a separate submission address?
19:19:47 <Pseudonym> Or make an alias.
19:20:07 <Pseudonym> I think the separate address, currently pointed to the list, would be fine.
19:20:19 <shapr> sounds good to me.
19:20:46 <shapr> ok then
19:26:00 <Pseudonym> BBIAB.  Gotta get something for this heartburn.
19:26:10 <shapr> ok
19:36:19 <shapr> hi flippo 
19:37:22 <flippo> howdy, shapr.  I'm halfway through reading Rabhi and Lapalme.  Great stuff
19:39:04 <shapr> yah, I love that book.
19:39:34 <shapr> I'm planning to follow it up with Chris Okasaki's "Functional Data Structures"
19:39:44 <shapr> Pseudonym told me a neat thing
19:40:22 <shapr> said that Okasaki's greatest contribution to FP is realizing that amortized complexity is real complexity
19:40:30 <shapr> hrm, I'm not sure I got that right.
19:40:45 <flippo> heh
19:41:05 <shapr> in essence, with lazy evalution, anything you can put off till tomorrow is profit for today.
19:42:12 <shapr> flippo: are you planning on entering the 0th obfuscated haskell code contest?
19:42:17 <flippo> shapr: I haven't seen many reasons to use the $! very often
19:42:35 <shapr> I've never used $!
19:42:43 <shapr> I probably will at some point
19:43:30 <shapr> oy, it's 5am
19:43:43 <shapr> be back tomorrow....
19:44:03 <flippo> sleeeep
19:44:10 * shapr falls over
19:47:52 <kawfee> let x = [i | i <- [0..], i*i <= n]
19:48:00 <kawfee>  Undefined variable "i"
19:48:26 <kawfee> anyone know what is wrong?
19:51:01 <kawfee> how can I multiply all the elements in one list by all the elements in another list?
19:54:46 <Pseudonym> Back.
19:58:48 <kawfee> let x = [i, z | i <- [0..], z <- [0..] i*z <= n]
19:58:53 <kawfee> is that legal?
19:59:55 <whee> doubt it.
20:00:04 <whee> I have no idea what you're trying to do
20:01:30 <kawfee> make a list containing all reals multiplied by all reals
20:01:39 <kawfee> 1*2, 1*2, 3*4, 4*4
20:01:40 <kawfee> so on
20:02:19 <whee> get rid of i*z < =n and put i*z before |
20:02:20 <whee> heh
20:02:27 <radix> wow
20:02:48 <whee> although that'll just multiply 1*1, 2*2, 3*3, ...
20:02:54 <whee> I think.
20:02:57 <radix> is that possible because of lazy evaluation?
20:03:05 <whee> radix: yes
20:03:12 <radix> that's totally neat. :)
20:05:34 <kawfee> no no no
20:05:38 <kawfee> I want all multiplies
20:05:42 <kawfee> 1*2 2*3
20:16:35 <Pseudonym> In what order?
20:22:33 <kawfee> why would I get something like the following: [0,1,2{Interrupted!}
20:22:44 <kawfee> I used the defs above but the list doesn't seem to end
20:23:35 <kawfee> y = [k | k <- [1..], k <= n] 
20:23:36 <kawfee> that list
20:23:46 <kawfee> it should end, but it prints out the above
20:23:53 <kawfee> it sists after the 2 and does nothing
20:24:26 <kawfee> oh wait, let me see if I can fix it
20:25:57 <kawfee> nope
20:25:59 <kawfee> I dunno what it is
20:27:14 <kawfee> fixed it
20:28:22 <whee> why do k <- [1..] and then restirct k to n?
20:28:29 <whee> why not [1..n]?
20:32:45 <kawfee> bah
20:33:01 <kawfee> I'm stuck on using list comprehension to make a list of factorials
20:33:10 <kawfee> I did 1..n
20:33:15 <kawfee> I already got that part
20:33:34 <whee> <Pseudonym> [ (n, product [1..n]) | n <- [1..] ]
20:33:45 <kawfee> yeah
20:33:47 <whee> heh
20:33:49 <kawfee> from last night
20:33:52 <kawfee> but I don't understand it
20:34:11 <whee> it's a list of (n, product [1..n]) where n is [1..]
20:34:59 <kawfee> it gives me an err
20:35:02 <kawfee> or
20:35:07 <kawfee>  Illegal Haskell 98 class constraint in inferred type
20:35:08 <kawfee> *** Expression : facTable
20:35:08 <kawfee> *** Type       : (Num (a,a), Num a, Enum a, Enum (a,a), Ord a) => (a,a) -> [Char]
20:35:30 <Smerdyakov> Wow
20:35:32 <Smerdyakov> That's quite a doozy.
20:35:56 <kawfee> yeah
20:35:57 <whee> I agree :)
20:36:02 <kawfee> I don't quite get it
20:36:12 <kawfee> so the above doesn't work =]
20:36:22 <Pseudonym> Very impressive.
20:37:20 <kawfee> ?
20:38:02 <Pseudonym> Works for me.  What implementation are you using?
20:38:17 <Pseudonym> I did that on the command line in GHC and in Hugs and it worked fine.
20:39:15 <kawfee> HUGS
20:39:19 <kawfee> hrm
20:39:29 <kawfee> yup
20:40:18 <Pseudonym> So it's not my code which is buggy. :-)
20:40:24 <kawfee> got it
20:43:05 <kawfee> that makes it so much easier
20:43:13 <kawfee> explain?
20:43:18 <kawfee> I looked at the def of product
20:54:00 <Pseudonym> product [a,b,c,d] = a*b*c*d
20:54:14 <Pseudonym> It's not very efficient.
20:54:20 <kawfee> ok
20:54:25 <kawfee> ERROR "hw3.lhs":41 - "z" multiply defined
20:54:29 <Pseudonym> BTW, can you, without looking, guess what product [] would be?
20:54:43 <kawfee> It's either 0 or 1
20:54:46 <kawfee> I think it's 1
20:54:54 <kawfee> we discussed it in class today
20:55:02 <kawfee> yeah it's one
20:55:02 <Pseudonym> Did you get an explanation why?
20:55:08 <whee> it's 5. 5!! :(
20:55:09 <kawfee> something about the rule of *
20:55:21 <Pseudonym> Product obeys this rule:
20:55:29 <Pseudonym> product xs * product ys = product (xs++ys)
20:55:56 <Pseudonym> If you set xs = [5], ys = [], you find that product [] must be 1.
20:56:19 <kawfee> hrm
20:56:25 <kawfee> I think I'm going brain dead
20:56:33 <kawfee> I've been looking at haskell all day
20:56:53 <Pseudonym> Basically, 1 is the identity for *.  x*1 == 1*x == x
20:56:58 <Pseudonym> Similarly, sum [] = 0
20:57:07 <Pseudonym> Because x+0 == 0+x == x
20:57:16 <Pseudonym> Moreover, concat [] = []
20:57:25 <Pseudonym> Because xs++[] == []++xs == xs
20:58:19 <kawfee> hah, I can't believe I missed the multiply defined error
20:58:21 <kawfee> just found it
21:10:35 <kawfee> *** Type           : [(a,b)] -> a -> [Char]
21:10:35 <kawfee> *** Does not match : [(a,b)] -> [Char]
21:10:38 <kawfee> what does that mean?
21:10:46 <kawfee> what's that middle a for?
21:13:18 <kawfee> I have this u = concat[w, show b, v, show r,"\n"] 
21:13:32 <kawfee> and if I do "in show u" at the ned of the let it works fine
21:13:48 <kawfee> but it's when I try to do u:func1(..) is when I get an error
21:14:26 <kawfee> how does 1 being the identity for * make [] = 1 ?
21:15:17 <whee> when product is done recursing down the list it needs to multiply by something that won't change the result
21:15:47 <whee> return something that won't change the result when multiplied, even
21:17:00 <kawfee> *** Expression     : putStr ' '
21:17:00 <kawfee> *** Term           : ' '
21:17:00 <kawfee> *** Type           : Char
21:17:00 <kawfee> *** Does not match : [Char]
21:17:20 <whee> putStr expects [Char], ' ' is Char
21:17:52 <whee> it might help to read those errors :)
21:19:23 <kawfee> bah
21:19:52 <kawfee> can I paste 15 lines of code?
21:20:44 <kawfee> > showLists a n = let x = head a
21:20:44 <kawfee> >      b = fst x
21:20:44 <kawfee> >      in if (a == [] || b > n)
21:20:44 <kawfee> > then []
21:20:44 <kawfee> > else
21:20:46 <kawfee> > let x = 20 
21:20:49 <kawfee> >     q = head a
21:20:52 <kawfee> >     b = fst q 
21:20:54 <kawfee> >     r =snd q
21:20:57 <kawfee> >     y = length (show b)
21:20:59 <kawfee> >     z = length (show r)
21:21:02 <kawfee> >     w = replicate (x - y) ' '
21:21:04 <kawfee> >     v = replicate (x - z) ' '
21:21:07 <kawfee> >     u = concat[w, show b, v, show r,"\n"] 
21:21:09 <kawfee> >  in u:showLists (tail a)
21:21:12 <kawfee> it's all indented correctly on my screen
21:21:15 <kawfee> ERROR "hw3.lhs":39 - Type error in function binding
21:21:17 <kawfee> *** Term           : showLists
21:21:20 <kawfee> *** Type           : [(a,b)] -> a -> [[Char]]
21:21:22 <kawfee> *** Does not match : [(a,b)] -> [[Char]]
21:21:25 <kawfee> I get that, and I don't know why, could someone please help me?
21:21:27 <whee> that really looks like a job for pattern matching
21:21:34 <whee> but it's obvious what's wrong from here
21:21:41 <kawfee> not from here
21:21:47 <whee> look at the type of showLists and how you actually call it
21:21:53 <kawfee> how is it a pattern matching job?
21:22:00 <kawfee> oh!
21:22:01 <kawfee> bah
21:22:11 <kawfee> thanks
21:22:20 <kawfee> I'm sorry, I've been looking at this for sometime
21:22:43 <whee> well q, b and r are easily gotten with pattern matching
21:22:59 <whee> and you could probably move the if statement up a level too
21:23:03 <kawfee> how can I make it write out with putStr instead of show?
21:23:09 <whee> which would eliminate the if/then/else
21:23:18 <kawfee> hrm
21:23:35 <whee> you could putStr the result of showLists
21:23:48 <kawfee> q = (_, x)
21:24:22 <whee> I'd do it in the actual function declaration (where you bind inputs to names)
21:29:00 <kawfee> got it thanks
21:29:07 <kawfee> I had to do some tother things as well though
21:29:17 <kawfee> thanks
21:45:35 <kawfee> how can I turn : "\"                                                 \"n\"                                                \"n!\n"
21:45:55 <kawfee> into a list with only the spaces and n and n! in it?
21:45:59 <kawfee> that output is from show
22:04:31 <kawfee> how can I do this: as:insert a y
22:05:00 <kawfee> nm
22:16:47 <kawfee>  Type error in application
22:16:48 <kawfee> *** Expression     : insert [5,4,3,2,1]
22:16:48 <kawfee> *** Term           : [5,4,3,2,1]
22:16:48 <kawfee> *** Type           : [a]
22:16:48 <kawfee> *** Does not match : Int
22:33:15 <kawfee> ERROR - Garbage collection fails to reclaim sufficient space
22:35:52 <kawfee> that's a first
22:35:56 <kawfee> I broke haskell
23:25:38 <kawfee>  Syntax error in expression (unexpected keyword "then")
23:47:31 <kawfee> *** Expression     : insertSort2 (middle y)
23:47:31 <kawfee> *** Term           : middle y
23:47:31 <kawfee> *** Type           : ([a] -> [a],[b] -> [b])
23:47:31 <kawfee> *** Does not match : ([c],[d])
23:47:37 <kawfee> anyone know what is up with that?
