00:23:07 <shapr> Chilli: hiya!
00:25:01 <shapr> SyntaxPolice: the arrow syntax changed from the draft paper
02:13:32 <shapr> I like this SimonPJ "15 years of Haskell" retrospective
02:14:29 <shapr> looks like crap when passed through ppthtml though :-(
02:14:52 <shapr> anyone have access to a real copy of powerpoint and is willing to convert this ppt to html?
02:15:52 * shapr wonders if openoffice supports ppt
02:17:27 * shapr laughs "Shirts off to Wadler"
02:17:29 <shapr> bwahaa
02:17:49 <shapr> hey Marvin-- do you have access to a real copy of MS Powerpoint?
02:17:55 <Marvin--> nope
02:18:00 <shapr> hmmm
02:18:18 <shapr> http://www.research.microsoft.com/~simonpj/papers/haskell-retrospective/index.htm
02:19:39 <Marvin--> heh, I was looking at that exact page yesterday
02:19:59 <Marvin--> try ppthtml?
02:20:00 <shapr> yes
02:20:02 <shapr> it sucks bad
02:20:14 <shapr> maybe I should check out its options
02:20:16 <Marvin--> dang
02:20:29 <Marvin--> argh, I have to write a letter of application
02:20:29 <shapr> the 'save as html' option in powerpoint turns out quite nicely
02:20:35 <shapr> so now I want someone to do that :-)
02:21:14 <Marvin--> yeah... I'll second that...
02:21:39 <shapr> any windows users here who have access to a copy of MS Powerpoint?
02:21:42 * shapr yells into the silence
02:21:58 <radix> hummm
02:22:04 <shapr> radix: you do?
02:22:06 <shapr> hi buggs 
02:22:07 <radix> I think I have Office 97 lying around here somewhere
02:22:14 <Marvin--> I wonder if some windows something can preview ppt
02:22:16 <radix> is PP on that?
02:22:18 * Marvin-- fires up the laptop
02:22:20 <buggs> hoi shapr :)
02:22:21 <shapr> radix: I think so
02:22:26 <shapr> oh, I could try openoffice also
02:22:35 <Marvin--> oh, yeah
02:22:46 <radix> yeah, I was going to suggest openoffice
02:23:07 <Marvin--> looks pretty good
02:23:27 <Marvin--> well, the slides look horrible, but I bet they do in ppt too
02:24:02 <shapr> yay! openoffice is happy!
02:26:12 <radix> hoorj!
02:28:22 <Marvin--> great, X started looping and taking 99.9% CPU! :(
02:32:00 <Marvin--> will there be a html copy soon? :P
02:39:56 <shapr> Marvin--: there may be, lemmee see if openoffice will export as html
02:40:15 <shapr> I just got OOo to do the slide show thing, there's some spiffy new stuff in here.
02:40:18 * Marvin-- really really really has to write that letter of application
02:40:27 <shapr> Marvin--: go forth and write!
02:40:36 <Marvin--> yeah, if only I knew what to put in it
02:40:43 <shapr> what are you applying for?
02:40:50 <Marvin--> a PhD student position at cs.chalmers
02:41:03 <Robert> Oooh.
02:41:10 <Robert> :)
02:41:37 <shapr> Marvin--: I'd do it like an interview letter, but maybe one of the PhD students here could tell you how they did theirs.
02:42:35 <Marvin--> a problem is that I'll have to hand this thing in tomorrow :P
02:42:40 <shapr> oh!
02:42:54 <Marvin--> at least I've gotten plenty of recommendations and references
02:42:56 <shapr> so, any PhD students here? :-)
02:43:06 <Marvin--> dennisb?
02:45:29 <Marvin--> I got a very nice recommendation from jacob@strakt
02:50:16 <shapr> ok, this is kind of sucky, but at least it works:
02:50:18 <shapr> http://kungens.kemi.fi/~shae/retro/HairShirt.html
02:50:30 <Marvin--> the text is the relevant parts...
02:50:44 <shapr> well, yeah
02:50:51 <radix> Marvin--: hey, are you coming to PyCon?
02:51:03 <shapr> I think "our biggest mistake" is funny
02:51:25 <Marvin--> radix: heh, moshez asked too... No I don't think I have the time and the money
02:51:31 <shapr> as well as the "shirts off to wadler" slide
02:52:49 <shapr> it's cool to hear what Simon PJ wants for the future of Haskell
02:52:59 <Marvin--> heh, "Motto: avoid success at all costs"
02:53:47 <radix> hah
02:53:56 <radix> this looks like it was a good talk :-)
02:54:18 <shapr> yah, I think it was
02:57:46 <Marvin--> "Laziness keeps you honest" haha
03:01:45 <Marvin--> hmm, a formalization of commutative monads would indeed be nice
03:02:12 <shapr> I don't understand why oversequentialization is a big deal...
03:02:30 <Marvin--> well, unless you've got an SMP machine...sure
03:02:41 <shapr> ah
03:02:58 <Marvin--> but one of the flags many pure-functional-programming people keep waving is "it's good for parallelization!"
03:03:05 <shapr> right, now I see :-)
03:03:19 <Marvin--> heh, "Warm fuzzy thing"
03:03:24 <shapr> yah, that cracks me up
03:03:57 <Marvin--> but yes indeed, the term "monad" scares many
03:04:13 <Marvin--> from the very start, people learn that monads are tricky things
03:04:52 <shapr> but they're not that tricky actually
03:05:11 <shapr> it's just 'these set of rules allow you to safely subclass function application'
03:05:17 <Marvin--> no, of course not, I like using Maybe and the Identity monad as examples
03:05:46 <Marvin--> but if people get the feeling from the very start when using Haskell that monads is tricky, it's hard to beat that out of them
03:06:05 <Marvin--> hahaha, nice diagram over "Type classes over time"
03:06:05 <shapr> yah, everyone I know is convinced monads are hard.
03:06:11 <shapr> yes, that's a great one :-)
03:07:59 <Marvin--> I think the problem is that in newbie courses in Haskell, people who want to do I/O (people always want to do I/O) are told to use the do notation as black magic
03:08:07 <Marvin--> "this is done with monads, you don't have to understand them"
03:09:20 <shapr> how could it be done better?
03:09:31 <shapr> monadic IO really is confusing at first
03:09:45 <Marvin--> I don't konw
03:09:46 <mgoetze> shapr: do a 3-year math course first, then teach people haskell :)
03:09:46 <Marvin--> know
03:09:57 <shapr> I've never had any math classes.
03:10:03 <shapr> well, I had algrebra in high school
03:10:28 <shapr> even so, I can understand monadic IO
03:10:34 <shapr> I'm not sure that the difficulty is math related
03:10:48 <shapr> I think it's conceptually unusual
03:11:03 <Marvin--> I think the first point to make is to get the student(s) to understand what the problem is
03:11:09 <shapr> yah, I agree with that.
03:11:18 <shapr> explain referential transpareync
03:11:23 <Marvin--> then show them >>= and when they get sick and tired of it, show them do notation
03:11:29 <shapr> show why that makes IO difficult
03:12:04 <Marvin--> exactly
03:12:12 <shapr> I realized on monday that I could replace fifteen lines of explicit checking in Python with three lines of Haskell that uses the Maybe monad
03:12:55 <shapr> I wonder if it would be better to explain state monads first thing in a Haskell course.
03:13:03 <shapr> and then IO
03:13:18 <Marvin--> tricky
03:13:28 <Marvin--> you have to motivate it somehow, IO is easy to motivate
03:13:29 <shapr> hm, maybe not, it's hard to figure out how useful they are if you don't understand the good sides of the pure stuff
03:14:02 <eivuokko> That's why using interpreter as complex "calculator" might be easiest start :-)
03:14:14 <shapr> eivuokko: yah, I agree with you
03:14:53 <shapr> explicitly paste in anything that should be read/written
03:15:03 <Marvin--> that's usually the way courses start
03:15:03 <shapr> I do that for test data
03:15:51 <shapr> off to swedish class, jag ska kommer tillbaka
03:16:00 <Marvin--> shapr: drop the 'ska' :)
03:16:03 <shapr> oh
03:16:18 <shapr> shouldn't I say "I shall come back" ?
03:16:21 <shapr> future tense?
03:16:37 <Marvin--> then it'd be "komma"
03:16:40 <shapr> ohh
03:16:42 <shapr> thanks :-)
03:16:47 <shapr> jag ska komma tillbaka
03:16:52 <Marvin--> but that sounds weird
03:16:58 <shapr> heh, ok :-)
03:17:08 <Marvin--> trying to figure out how to translate it to English to carry the meaning
03:17:12 <shapr> jag kommer tillbaka
03:17:18 <shapr> efter skolan
03:17:30 <eivuokko> I believe that the hard part is not because people wouldn't understand referential transperency or monads.  They simply don't seem to understand any order-dependant questions.  I've seen a lot of newbies being confused by "side effect" issues in C++.
03:18:47 <Marvin--> wow, I wonder what Koen's been up to now
04:03:14 <Marvin--> should I jot down "master project" (in progress?) under education in a CV?
04:17:52 * Igloo finally parses that correctly
04:18:33 <Igloo> I'd say not, but talk about it in the letter if it's relevent
04:21:57 <Marvin--> sigh, that damn letter
04:25:29 <Marvin--> what should I write in it? :(
04:40:57 <panoramix> hello everyone
04:41:43 <panoramix> i have a question. What is wrong with the statement length [(1,2),(3,4),(5,6)]?
04:42:03 <dennisb> panoramix: nothing
04:42:22 <dennisb> we usually call it an expression in haskell
04:42:29 <panoramix> :)
04:42:31 <panoramix> ok
04:42:33 <panoramix> well
04:42:39 <panoramix> i type this:
04:43:25 <panoramix> [(1,2),(3,4),(5,6)] !! length [(1,2),(3,4),(5,6)]
04:43:36 <panoramix> shouldn't it give me
04:43:41 <panoramix> (5,6)?
04:44:13 <panoramix> ok
04:44:15 <panoramix> i got
04:44:15 <panoramix> it
04:44:20 <panoramix> it is a numbering thing
04:44:23 <panoramix> no worries
04:44:31 <dennisb> Marvin--: about the application I think you can write pretty much anything. The only important thing is that you are called in for an intervju and since you have recomendations I would be surprised if you were not
04:44:57 <dennisb> panoramix: what is the value of length [(1,2),(3,4),(5,6)]
04:45:02 <dennisb> panoramix: what is the value of: length [(1,2),(3,4),(5,6)]
04:45:14 <panoramix> 3
04:45:17 <panoramix>  i got
04:45:18 <panoramix> it
04:45:28 <dennisb> aha. ok
04:45:28 <Marvin--> dennisb: okay, so you're saying I should stop worry? :)
04:45:42 <panoramix> :)
04:45:43 <dennisb> Marvin--: A little bit. But of course it shoud be not to bad
04:46:18 <dennisb> Marvin--: But I don't know anything about the process. I'm not involved. So don't read anything into it
04:46:24 <Marvin--> I'm trying to tell them why I would make a good PhD student, what I think my research interests would be and mention something about my master project...
04:46:34 <Marvin--> dennisb: heh, well, at least you're *in* :)
04:46:34 <dennisb> Sounds just fine
04:46:46 <Marvin--> so obviously you did *something* right :P
04:47:10 <dennisb> I didn't write a very long letter or anything, just like you said above
04:47:37 <dennisb> It was like half a page of my own writing.
04:47:40 <Marvin--> well, letters shouldn't be long, that's the tricky part
04:48:16 <Marvin--> <insert mandatory Pascal quote>
04:48:38 <dennisb> Marvin--: true
04:50:36 <panoramix> another thing
04:50:39 <panoramix> i want to do
04:50:50 <panoramix> put c ls!!0 xss
04:50:54 <panoramix> put c ls!!1 xss
04:50:58 <panoramix> put c ls!!2 xss
04:51:01 <panoramix> untill
04:51:12 <Marvin--> put?
04:51:15 <panoramix> put c ls!!length ls-1 xss
04:51:21 <panoramix> does not matter
04:51:27 <panoramix> do i use
04:51:32 <panoramix> recursive function
04:51:39 <panoramix> or list comprehension?
04:51:40 <dennisb> I think you want to create a list with all the results first and then do the printing
04:51:58 <dennisb> if put is for printing as I assume
04:52:03 <Marvin--> panoramix: using ls!!k for k in [0..length ls-1] is a bad idea
04:52:16 <panoramix> how come?
04:52:22 <Marvin--> panoramix: since (!!) takes linear time in k, so you'd end up using quadratic time
04:52:30 <panoramix> put :: a -> (Int,Int) -> [[a]] -> [[a]]
04:52:31 <panoramix> put c (x,y) xss = (take (y-1) xss) ++ turnl(replace c (x) (xss!!(y-1)))  ++ (drop (y) xss)
04:53:32 <Marvin--> map (\y -> put c y xss) ls   is one way of doing it
04:53:45 <Marvin--> or with an LC,   [ put c y xss | y <- ls ]
04:53:49 <dennisb> May I suggest that you get rid of turnl and write:
04:54:04 <dennisb> put c (x,y) xss = (take (y-1) xss) ++ [replace c (x) (xss!!(y-1))]  ++ (drop (y) xss)
04:54:34 <panoramix> ok
04:54:40 <dennisb> you can also drop some of the ()
04:54:48 <panoramix> ok
04:54:52 <dennisb> put c (x,y) xss = (take (y-1) xss) ++ [replace c x (xss!!(y-1))]  ++ (drop y xss)
04:55:02 <panoramix> Marvin: what does \y mean?
04:55:19 <Marvin--> panoramix: \y -> ...  is a lambda function taking y as an argument
04:55:35 <panoramix> hm
04:56:02 <Cryptor> paroramix: (\x -> x^2) 2 == 4
04:58:19 <panoramix> i can understand what cryptor said but cannot see it in what marvin said
04:58:22 <dennisb> You have seen functions written like:
04:58:22 <dennisb>    f x = 2*x
04:58:22 <dennisb> another way to write that is:
04:58:22 <dennisb>    f = \x -> 2*x
04:58:22 <dennisb> It's the exact same thing written in another way. f is the function that takes an x and returns 2*x
04:58:29 <Marvin--> [ if n == y-1 then replace c x xs else xs | xs <- xss | n <- [0..] ]
04:58:35 <Marvin--> yay, parallel LCs
04:59:06 <Marvin--> [ if n == y-1 then replace c x xs else xs | (xs,n) <- zip xss [0..] ]  in standard haskell
05:03:35 <dark> I think we need some map and filter primitives that work with list indices.
05:04:13 <dark> I get tired of fiddling with [0..] all the time :)
05:04:35 <panoramix> well
05:04:36 <Marvin--> it's suboptimal, but a kinda neat usage of infinite lazy lists :)
05:05:12 <Marvin--> panoramix: my code only iterates over xss once, your code iterates over it three times... which is easier to understand is left as en exercise I guess...
05:05:38 <dark> Marvin: You speak imperatively :)
05:06:03 <Igloo> So does your CPU  :-)
05:06:04 <dark> The compiler could probably generate the same code for both.
05:06:26 <dark> Also, scanning once slowly might be worse than scanning three times quickly :)
05:07:44 <Marvin--> dark: my code also avoids ++ *shrug*
05:08:05 <Marvin--> I have no idea how much it can be deforested (is that a word?:)
05:09:25 <Igloo> Yes
05:09:35 <dark> deforestation is what we do to the Amazon region.
05:10:26 <Marvin--> I'm trying to figure out the pros and cons of using -fext-core + my own parser, or ripping out the code from ghc and use that
05:11:16 <Igloo> I think there is some core-parsing stuff around - try asking SPJ or the woman whose name begins with K
05:11:28 <Igloo> Kirsty something or similar
05:11:50 <Marvin--> well, parsing core isn't the problem, that's the easy part, I could probably hack together one myself in just a few minutes
05:12:53 <Marvin--> how do I tell ghc to generate external core and only that?
05:13:42 <Marvin--> -E -fext-core?
05:14:59 <Marvin--> hmm, nope
05:15:20 <Marvin--> I mean, the advantages of using -fext-core are obvious, but the disadvantage is that my tool will require ghc to be installed
05:17:37 <panoramix> ok guys i type what marvin said: puts c ls xss=   [ put c y xss | y <- ls ] but it produces an error
05:17:53 <panoramix> because the results are different
05:18:02 <panoramix> [[a]] and [[[a]]]
05:18:05 <panoramix> ?
05:18:27 <dark> I think the code you'd have to rip out of ghc would be most of it, though.  Doesn't core code include most of the optimizations?
05:19:36 <Marvin--> panoramix: well, I'm still not sure what you want to do...
05:19:58 <panoramix> ok one sec
05:19:59 <Marvin--> dark: I think I could replace most of the optimizations by "id"
05:20:18 <panoramix> the puts function should do the following
05:20:36 <panoramix> given a character c, a list of integer tuples ls and a list of lists xss returns xss such that for all (x,y) in ls the x-th element of the y-th list is changed to c
05:20:45 <Marvin--> dark: What I need is haskell parsing, haskell type-checking, and translation to a simpler language so I don't have to work with full haskell... doesn't that sound pretty much like Core? :)
05:21:19 <Marvin--> panoramix: oh, then you want to chain the put:s
05:21:41 <dark> Marvin: Hmm, depending on what you're going to do with it, you might get better results without optimization :)  At least, I guess that most of them will complicate the core.
05:21:43 <Marvin--> panoramix: you said you wanted to do put c (ls!!0) xss and put c (ls!!1) xss
05:21:55 <panoramix> yes in puts
05:22:07 <panoramix> i will use put in puts
05:22:45 <Marvin--> panoramix: sure, but what you need to do is  put c (ls!!1) (put c (ls!!0) xss)... put will not *modify* xss, only return a modified copy of xss
05:23:29 <Marvin--> panoramix: but that's fairly easy to do with recursion
05:23:36 <Marvin--> panoramix: and without !!
05:23:42 <dark> For example, strictness analysis will add a lot of case expressions.
05:24:00 <panoramix> :)
05:24:19 <steele> is template haskell in ghc HEAD?
05:24:53 <Marvin--> dark: yeah... What I want is pretty much the simplest possible representation... I'm still wondering if I should go the whole way to lambda calculus
05:25:19 <Marvin--> panoramix: think in terms of the two cases "ls is empty" and "ls is not empty", you know about patten matching?
05:25:21 <dark> Marvin: Is laziness important?
05:25:57 <Marvin--> dark: probably :/ what I want to do is some sort of structured search over data types to find counter examples to quickcheck properties
05:26:00 <panoramix> marvin: yes 
05:27:45 <Marvin--> dark: after translating to Core (or something else) I want to turn it into a search problem and either implement some sort of breadth-first search myself or hand it to a first-order theorem prover
05:29:02 <Cryptor> panoramix: the only way I can find to approach this is to convert the input list into an array.
05:29:15 <Cryptor> panoramix: that would make things easier.
05:29:53 <Cryptor> panoranix: then do the work needed on the array, and then convert it back to a list and return it.
05:30:00 <panoramix> hm
05:31:03 <Cryptor> panaramix: if you insist on using indicies, particularly unsorted ones, that your only efficient option.
05:31:45 <Marvin--> but you don't need to use indices
05:31:57 <Marvin--> given put, puts is very easy to write
05:32:28 <Cryptor> aren't the indicies an argument of the puts function?
05:32:46 <panoramix> yes
05:33:24 <Cryptor> yeah, that was more directed at marvin...
05:35:03 <Marvin--> yes, it might make sense to do that in put, but not in puts
05:35:32 <Cryptor> Marvin--: do what?
05:37:27 <Marvin--> to work with arrays
05:37:59 <Marvin--> and as I showed with an LC, you don't have to do that either, you can implement put in a single pass using an LC
05:38:08 <Igloo> steele: Yes
05:40:05 <Marvin--> you can also implement put pretty easily with recursion
05:40:42 <Cryptor> yes, but if you take the arrays option, then 'put' isn't needed.
05:46:20 <Marvin--> we can generalize put to  put :: (a -> a) -> Int -> [a] -> [a]
05:47:43 <panoramix> Marvin can youo explain how pattern matching could be useful for puts
05:47:45 <panoramix> i cant see it
05:48:39 <Marvin--> well, think inductively, you've got a list of indices right? What do you want the function to do when that list is empty?
05:48:56 <Marvin--> that's the case  puts c [] xss  right?
05:49:00 <panoramix> yes
05:49:12 <Marvin--> what should puts do in that case?
05:49:18 <panoramix> i suppose return the modified xss
05:49:29 <panoramix> or do nothing
05:49:35 <Marvin--> ah, but if there are no indices, xss will not be modified, will it?
05:49:46 <panoramix> ino
05:49:49 <panoramix> no
05:49:56 <Marvin--> so you just have  puts c [] xss = xss
05:50:04 <panoramix> correct
05:50:19 <Marvin--> the induction step is with a non-empty list, in haskell we write this  puts c (l:ls) xss
05:50:59 <Marvin--> but we can call puts recursively,  puts c ls xss  will return the result of xss being modified according to ls
05:51:28 <Marvin--> all we have to do is take that result and apply the changes from the index in l
05:51:36 <Marvin--> but that's exactly what put does, isn't it?
05:51:42 <Marvin--> am I going too fast?
05:51:48 <panoramix> yes
05:51:50 <panoramix> :)
05:51:57 <panoramix> one sec to figure it out
05:51:59 <panoramix> :)
05:52:19 <Marvin--> it's just like an induction proof in mathematics
05:52:22 <panoramix> (actually quite more than a sec!!)
05:52:24 <panoramix> :)
05:52:40 <Marvin--> ask on
05:53:37 <Marvin--> maybe we should take a much smaller example instead
05:53:51 <Marvin--> you know the length function. We can define it as
05:53:59 <Marvin--> length [] = 0  -- the length of the empty list is 0
05:54:14 <panoramix> ok
05:54:17 <Marvin--> length (x:xs) = length xs + 1 -- if xs has length n, then x:xs must have length n+1
05:54:44 <panoramix> ok
05:55:03 <Marvin--> d'you see that? If you don't understand that example, don't say "ok" ;)
05:55:15 <panoramix> no i do
05:55:29 <panoramix> in the cas ewhen we type
05:55:39 <panoramix> length (x:xs)
05:55:49 <panoramix> x is always something right?
05:55:57 <Marvin--> yup, x is the first element of the list
05:55:57 <panoramix> i mean
05:56:02 <panoramix> oh ok#
05:56:22 <Marvin--> if we didn't have the [] case, and called length [] it will report back an error about pattern match failing
05:56:35 <panoramix> ok
05:56:59 <Marvin--> so in the case  puts c (l:ls) xss  we know that l is a pair of Ints, and ls is some list (maybe empty, but that's okay)
05:57:25 <panoramix> ok 
05:57:26 <panoramix> one sec
05:59:43 <Marvin--> dennisb: hmm, feb 27... is there no multi talk tomorrow?
06:01:26 <Marvin--> panoramix: put it this way instead, in the case  puts c (l:ls) xss  we can call  put c l xss  and get back a new list, right?
06:01:56 <panoramix> right
06:02:36 <Marvin--> so let's feed that list into puts c ls... that'd be  puts c (l:ls) xss = puts c ls (put c l xss)
06:02:57 <panoramix> one sec
06:06:05 <panoramix> ok i got it
06:09:15 <panoramix> i works!!!!
06:09:32 <panoramix> i love you guys a love the whole world
06:09:36 <panoramix> !!!
06:09:39 <Marvin--> do you understand *why* it works? :)
06:09:52 <panoramix> yes
06:09:57 <panoramix> that is the best part!!!!!!!!!!!!!!1
06:10:14 <panoramix> thank you all
06:12:06 <emu> aiee
06:12:13 <emu> my bandwidth is taken up by !!!
06:12:45 <Marvin--> hahaha
06:32:21 <dennisb> Marvin--: I havn't checked but I don't think so.
06:32:38 <dennisb> I'm sure you can take the spot if you hurry!
06:32:48 <Marvin--> in your dreams
06:32:52 <dennisb> :-)
06:33:10 <Marvin--> I don't exactly have anything worthwhile to talk about
06:33:18 <Marvin--> the only remotely interesting thing would be hws-wp
06:34:24 <dennisb> hws-wp?
06:36:51 <Marvin--> My AFP project: http://www.dum.chalmers.se/~marvin/hws-wp/
06:37:18 <dennisb> Marvin--: aah, i've seen that
06:37:53 <SyntaxPolice> good morning
06:38:23 <dennisb> Marvin--: actually, you could give a nice talk about that. Run time loading and such things is fun
06:38:55 <dennisb> And the rest. I would come and listen
06:40:20 <Marvin--> oh dear
06:40:30 <dennisb> don't worry
06:40:46 <dennisb> I won't tell anyone, so you don't have to .-)
06:41:43 <Marvin--> heh
06:48:12 <Smerdyakov> Hm
06:48:25 <Smerdyakov> Marvin--, when do you plan to start a PhD program?
06:48:55 <Marvin--> I don't know when it starts... some time during summer or fall I guess
06:49:00 <Marvin--> the application has to be in the 15th
06:49:04 <Marvin--> (Feb that is)
06:49:19 <Smerdyakov> Ah. Is that the usual deadline in Europe?
06:49:32 <Smerdyakov> They're all no later than Jan 7 here.
06:50:46 <Marvin--> I think it's different all around :) I think the deadline at the maths dept here is March 1
06:51:10 <Smerdyakov> I've never seen any PhD deadline for any program later than mid-January in the US>
06:51:25 <Smerdyakov> You're only applying to your current school?
06:51:57 <shapr> I bet I could make a living as a M-x yow replacement.
06:53:11 <Smerdyakov> Well, class now
06:53:12 * Smerdyakov goes away: class
06:53:18 <dark> shapr: What's the going rate for a yow?
06:53:32 <shapr> sadly, they're free
06:54:51 <dark> We should design an enforce a framework of intellectual property rights to create an artificial scarcity of yows, and cash in on them.
06:55:02 <shapr> excellent idea!
06:55:05 <dark> Only then can the shaprs of the world be free.
06:55:10 <shapr> dark: oh, Chilli is on board
06:55:13 <shapr> yay!
06:55:15 <dark> Great :)
06:55:19 <shapr> dark: let's announce
06:56:08 <dark> What was the wiki link again?
06:56:37 <dark> It seems to have mysteriously escaped from my browser history.
06:57:13 <shapr> dark: http://purl.org/wiki/haskell/
06:57:22 <shapr> If that doesn't work, I should fix it.
06:57:41 <shapr> therefore, http://purl.org/wiki/haskell/ObfuscatedHaskellContest
06:58:05 <dark> Hmm I found the old link again, which is http://haskell.org/wiki/wiki?ObfuscatedHaskellContest
06:58:08 <shapr> purl = permanent universal resource locater
06:58:18 <dark> Oh
06:58:18 <shapr> purl.org is just a forwarding address
06:58:49 <shapr> I also created wiki/python wiki/emacs wiki/lojban and some others that I've forgotten
06:59:28 <dark> Does it enforce any penalties for non-permanence? :-)
06:59:44 <shapr> nah
06:59:48 <shapr> it's just a convenience
07:00:01 <shapr> amusingly, it's run by OCLC, the american library mafia
07:06:37 <Marvin--> hahaha, what a crazy music video
07:06:51 <Marvin--> lots and lots and lots of action figures
07:07:02 <Marvin--> and censored naked female action figures
07:09:32 * shapr grins
07:09:53 <Marvin--> Sum 41
07:09:54 <Marvin--> they're insane
07:22:33 <SyntaxPolice> shapr: I wrote some pretty ugly haskell yesterday.
07:22:39 <shapr> oh oh, I wanna see!
07:24:45 <SyntaxPolice> one sec.
07:26:05 <Igloo> Now you see, if we were talking about perl in #perl the response would have been "Yeah? And?"  :-)
07:28:34 * shapr laughs
07:28:55 <shapr> I'm trying to explain monads as 'function call subclassing' on another channel
07:29:02 <shapr> I don't think it's working out
07:29:15 <dark> On the other hand, try "I wrote some hideously perverse perl code yesterday" in #perl.
07:29:23 <dark> It's a matter of scale.
07:29:31 <SyntaxPolice> tick' = do n <- get
07:29:31 <SyntaxPolice> 	   put (n+1)
07:29:31 <SyntaxPolice> 	   return n
07:29:31 <SyntaxPolice> plus n x = snd $ runState (sequence $ replicate n tick') x
07:29:53 <SyntaxPolice> I was playing w/ the state monads example in that arrows paper by hughes
07:30:02 <shapr> well, that's not terribly horrible
07:30:13 <SyntaxPolice> shapr: its the best I could do!!
07:30:15 <dark> hmm I wonder how far the optimizer gets with that.
07:30:33 <Igloo> Mixing tabs and spaces like that is horrible if you ask me, but we've had this discussion^Wargument  :-)
07:30:50 * shapr grins
07:30:57 <SyntaxPolice> talk to haskell-mode :)
07:31:01 <shapr> SyntaxPolice: so, is that youn IOHCC entry? ;-)
07:31:18 <SyntaxPolice> shapr: nono, I was just writing some ugly code and thought of you :)
07:31:22 * shapr laughs
07:31:30 <shapr> I'm afraid to ask why you think of me when you see ugly code ;-)
07:31:41 <SyntaxPolice> no other reason than the IOHCC
07:31:45 <SyntaxPolice> (of course)
07:31:46 <shapr> ah, whew!
07:32:32 <shapr> actually, what's so bad about that code?
07:32:54 <SyntaxPolice> are you telling me that I can't even write ugly code when I try?
07:33:19 <shapr> it's a bit indirect, but I wouldn't call it ugly
07:33:21 <SyntaxPolice> I think just the "I really really really want to use state to create a 'plus' function" aspect to it.
07:33:32 <shapr> yah, I think that's neat :-)
07:33:41 <SyntaxPolice> ahwell. I tried.
07:33:49 <shapr> truly, it's an abused of the state monad.
07:33:55 <shapr> er, "an abuse"
07:34:02 <shapr> man, I'm trying to think in swedish, argh
07:34:10 <shapr> men, jag kan inte :-(
07:34:13 <SyntaxPolice> what does argh mean in swedish?
07:34:15 <shapr> haha
07:34:22 <SyntaxPolice> oh
07:35:10 <Marvin--> lol
07:35:15 <shapr> SyntaxPolice: I still don't understand why the laws are necessary for monads and arrows
07:35:32 <shapr> I just know that someone figured out that with those laws, it's safe to use monads for the things they do
07:35:42 <shapr> and arrows
07:35:58 <shapr> SyntaxPolice: do you understand why the various laws are the way they are?
07:36:28 <SyntaxPolice> shapr: I don't understand arrows yet.
07:36:37 <shapr> you do understand the reasons behind the monad laws?
07:37:14 <shapr> do you know of a good explanation of the reasons behind the monad laws I could read somewhere?
07:37:32 <SyntaxPolice> well, return x can't have any side effects, right?
07:37:49 <shapr> right
07:38:13 <SyntaxPolice> it sounds like a good idea...
07:38:46 <SyntaxPolice> the explanation in craft of functional programming seemed to make sense to me at the time
07:39:02 * shapr opens that book
07:39:02 <SyntaxPolice> but I probably couldn't tell you the reasons behind the laws off the cuff.
07:39:08 <SyntaxPolice> pg 403 :)
07:39:13 <shapr> heh
07:39:18 <shapr> but you know the page off the cuff
07:39:42 <SyntaxPolice> umm yeah...
07:39:50 * SyntaxPolice wasn't looking at the book to try to answer shapr's question
07:42:25 <SyntaxPolice> I sort of get the feeling that the laws are to make all monads uniform, since they can't be inforced in the language, in a way that makes them not do unexpected things.
07:43:23 <SyntaxPolice> like say if "return x = x + 1" or something like that, this would be very distressing to a programmer using such a monad.
07:44:10 <SyntaxPolice> or return () = putStr "byebye" 
07:44:50 <shapr> I've heard that monadic laws can't be enforced by haskell, they have to be enforced by the programmer who created them
07:45:05 <SyntaxPolice> right
07:45:24 <SyntaxPolice> btw, shapr, you're not thinking about breaking the laws of monads for the contest, are you?
07:45:28 <Marvin--> checking whether your implementation obeys the laws is probably undecidable
07:45:32 <SyntaxPolice> That would be going too far.
07:45:39 <Marvin--> SyntaxPolice: oh no, "best abuse" :)
07:46:32 <shapr> Marvin--: couldn't you check it with quickcheck?
07:46:58 <shapr> is that possible or not...
07:47:21 <shapr> SyntaxPolice: I'm suddenly curious how things could fail with a broken monad
07:47:54 <SyntaxPolice> I think you would just have confusing behavior, nothting worse. 
07:48:37 <Marvin--> shapr: well of course you can specify the laws as quickcheck properties if you know the internal representation of the monad... whether the tests make sense is a different question
07:48:54 <shapr> Marvin--: huh?
07:48:58 <shapr> %-?
07:49:37 <Marvin--> well you'll have to be careful about the test data generation, won't you?
07:49:55 <Marvin--> I don't remember the exact laws
07:49:56 <shapr> one of my favorite things about Haskell is that I'm not even close to learning all the stuff it offers
07:50:04 <Marvin--> bbiab, gonna hop into the shower
07:50:40 <shapr> Haskell beats the crap out of emacs in both top-end complexity, and orthogonality
07:50:41 <shapr> imho
07:51:40 <shapr> is the 'subclassing function call' anywhere close to an accurate description of monads?
07:55:03 <shapr> SyntaxPolice: oh, did you notice that the syntax for arrows has changed since the draft paper?
07:57:42 <SyntaxPolice> shapr: I definitely noticed that :) I haven't actually been able to get examples to work.
07:58:14 <shapr> I've seen the differences mentioned on the mailing lists, but I don't remember them myself
07:58:26 <shapr> and I've only read the draft paper.
07:58:34 <shapr> SyntaxPolice: what do you think of arrows so far?
07:59:19 <shapr> I have a weird question about arrows
07:59:29 <SyntaxPolice> shapr: I don't know yet.  I'm reading this paper but it starts w/ monads and this monadic parser example. I want to skip over the monads, but can't since you have to understand the monadic parser before you read the arrows section.
07:59:43 <shapr> I've read that Arrow transformers are a natural property of the basic Arrow
07:59:53 <shapr> and I've read that Arrows are a superset of Monads
08:00:27 <shapr> does that mean I could 'lift' any Monad to an Arrow, and then make monad transformers from them?
08:01:29 <shapr> is it possible to lift a monad to an arrow?
08:03:46 * SyntaxPolice doesn't know.
08:05:18 <Robert> Hmm... how do I solve the equation  y' = k*(y^2)  ?
08:05:29 <shapr> Robert: ask someone smarter than me ;-)
08:05:43 * Robert asks someone smarter than shapr.
08:05:43 * shapr runs from the evil math equation
08:05:46 <Robert> Hehe
08:05:47 * shapr laughs
08:06:02 <shapr> jag studerade svenska idag.
08:06:12 <Robert> We're the terribly uneducated semi-swedes.
08:06:14 <Robert> Yay
08:06:20 <Robert> Did you learn anything important?
08:06:26 <SyntaxPolice> Robert: what are you solving for?
08:06:29 <shapr> we learned about how to make substantiv plurals
08:06:53 <Robert> shapr: En nörd, flera nördar.
08:06:57 <shapr> penna, pennor; lärare, lärare
08:06:59 <Robert> SyntaxPolice: What do you mean?
08:07:06 <shapr> what's a nörd?
08:07:16 <Robert> shapr: Bastardization of "nerd".
08:07:20 <SyntaxPolice> well, the equation has 3 unknowns, right? and you want to 'solve' it?
08:07:40 <Robert> SyntaxPolice: Ah, k is a constant, and we want the function y(x).
08:07:59 <shapr> oh, good word to know
08:08:11 <Marvin--> shapr: yes, don't you get a Kleisli Arrow from lifting a Monad?
08:08:30 <shapr> oh, so you do!
08:08:32 <shapr> good point
08:09:14 <SyntaxPolice> sorry Robert, I don't think I understand the problem.
08:09:29 <Marvin--> SyntaxPolice: it's a differential equation
08:09:45 <Robert> SyntaxPolice: It's just a differential equation, y is an unknown function, y' its derivative, and k a constant.
08:09:49 <Marvin--> y' is dy/dx
08:10:33 <SyntaxPolice> ic. for some reason I was thinking y' was just another unknown :-) (reading a haskell paper at the moment, you must forgive me)
08:10:54 <Robert> I forgive you ;)
08:11:01 <SyntaxPolice> woohoo!
08:11:02 <Marvin--> a good starting point is usually to set y(x) = Ce^(ixD) if I remember correctly :P
08:11:13 <SyntaxPolice> you swedes are so forgiving.
08:11:31 <Robert> SyntaxPolice: We're very nice. At least on IRC.
08:11:53 <Robert> Ask shapr about how we treat foreigners IRL.
08:12:34 <SyntaxPolice> heh
08:14:34 <Marvin--> Robert: wait a sec, it's separable... there's not even any x in it
08:16:21 <Robert> Hm, okay
08:16:26 * Robert should look this up
08:16:48 <Robert> Found it in a book
08:16:56 <Robert> Thanks.
08:27:02 <Marvin--> oh dear
08:33:27 <shapr> Marvin--: ?
08:34:09 <shapr> yay, http://research.microsoft.com/~simonpj/Haskell/TH.html
08:36:04 <Marvin--> shapr: oh, nothing, flamewa^Wpolitics on debian-devel
08:36:15 <Marvin--> the micq upstream and debian micq maintainer are having...issues
08:36:37 <shapr> oboy
08:40:10 <dark> The code also has issues :)
08:40:23 <Marvin--> yeah
08:40:35 <shapr> dark: any reason I shouldn't announce the contest on haskell@ and c.l.f?
08:40:39 <Marvin--> the way I understood it, the main problems are a) the maintainer made some mistakes, and b) upstream is an asshole
08:40:45 <Marvin--> food
08:41:56 <dark> No, go for it :)  But how much time for submissions?
08:42:04 <shapr> um
08:43:06 <shapr> march 1st would be 2.5 weeks
08:43:12 <shapr> dark: too small?
08:45:33 <shapr> dark: I want a quick contest so we can see if it's a good idea to do it again, or even a good idea at all.
08:46:13 <shapr> well hmm
08:47:01 <shapr> I think it'll be popular...
08:48:05 <dark> shapr: With that time limit you're likely to only get submissions of existing code, though.
08:48:10 <shapr> that's true
08:48:13 <shapr> excellent point
08:48:32 <shapr> dark: do we want that? or do we want to give time to create new obfuscated code?
08:51:33 <SyntaxPolice> you could consider having a 'dry run' where people submit and talk about their submissions live (on irc?), get new ideas, etc. Then next time you'd have a core of people interested and excited about the game.
08:52:05 <shapr> yah, this is the 0th IOHCC, so it is a dry run
09:02:31 <Marvin--> I'm off to play some D&D
09:22:53 * shapr bounces
09:25:55 <shapr> hi Sucht`on|Hase 
09:26:14 <Sucht`on|Hase> hi
09:26:25 <Sucht`on|Hase> do you have some knowledge about latex ?
09:26:29 <shapr> no
09:26:36 <Sucht`on|Hase> thats a pitty
09:26:41 <shapr> someone else here might
09:27:49 <Sucht`on|Hase> I need to know how I can bring latex to use horizontal page format
09:36:23 <Igloo> I can't remember the exact incantation, but I'm sure it's in the FAQ at tex.ac.uk
09:37:03 <Igloo> Assuming you mean landscape
09:51:04 <Sucht`on|Hase> ok thx
09:55:57 <shapr> yay, page views for haskell-libs are up
09:56:02 <shapr> people are noticing us!
10:09:28 * shapr snickers
10:13:35 * shapr cranks up The Crystal Method for extra codey fun
10:15:24 <shapr> I'm creating types for rfc822
10:15:37 <shapr> I've created a Domain type
10:15:54 <shapr> I'd like to also do "data From = Domain" in another part of the same module
10:16:07 <shapr> but I get a complaint about "multiple declarations of Domain"
10:16:23 <shapr> is there a better way to make 'alias' types like I want?
10:16:29 <shapr> is there some other solution entirely?
10:17:19 <shapr> I've noticed I can do "data From = From Domain" and that seems to work, but it seems overly complicated.
10:17:59 <shapr> I wonder if I'm treating types too much like objects
10:31:39 <hdaume> shapr: you use python a lot, right?
10:31:52 <Igloo> You might want type From = Domain
10:32:11 <Igloo> Whish gives you ease at the expense of type checking
10:38:07 <shapr> hdaume: yes, I use python a lot
10:38:12 <shapr> hdaume: how may I assist you?
10:39:15 <hdaume> shapr: (a) do you think it's worth learning (over, say, getting better at perl) and (b) if so, can you point me to a good place to learn from?
10:39:30 <shapr> yes, and I've heard good things about diveintopython.org
10:40:18 <shapr> hdaume: you may want to go through the tutorial that comes with the docs, I predict it'll take you less than a day to start being productive with python
10:40:28 <shapr> http://python.org/doc/current/tut/tut.html
10:40:29 <hdaume> shapr: cool, thanks
10:40:41 <shapr> hdaume: also, I'd be happy to answer any questions you have
10:42:29 <shapr> mgoetze: what's a halfop?
11:03:20 <panoramix> hello again guys.I'm afraid i need your helpl again with something.Can you explain to me the following line?
11:03:28 <panoramix> del (a:as)  = (a,as) : (map (\b -> (fst b,a:( snd b))      ) (del as))
11:03:43 <panoramix> i cant figure out what the lamda function does.
11:04:36 <hdaume> the lambda can also be written (\ (x,y) -> (x, a : y))    maybe that helps
11:05:30 <panoramix> can you rewrite it in another way preferably without using the \
11:05:33 <panoramix> ?
11:06:38 <hdaume> del (a:as) = (a, as) : map f (del as)     where f (x,y) = (x, a:y)
11:12:15 <panoramix> hm
11:12:19 <panoramix> i still dont get it
11:12:33 <hdaume> what don't you understand?
11:12:39 <panoramix> can you describe it with words if it not too much trouble?
11:13:00 <panoramix> what it does
11:15:17 <shapr> panoramix: have you tried subsets of that code interactively in Hugs or Helium?
11:16:04 <panoramix> sorry what do you mean?
11:16:15 <panoramix> testing it?
11:16:16 <Smerdyakov> hdaume, your code will cause some troubles if you actually look at its return value =)
11:16:54 <shapr> panoramix: test each of pieces that make up that code
11:17:04 <panoramix> ok
11:17:36 <hdaume> if you give it the list (a:b:c:d:...), the first element of the returned list will be (a, b:c:d:...); the second will be (b, a:c:d:...); the third will be (c, a:b:d:...); etc.  (i think...i'm not sure)
11:17:42 <hdaume> Smerdyakov: then maybe you could try helping out
11:18:11 <Smerdyakov> hdaume, you mean you don't know how to write it?
11:18:34 <shapr> Smerdyakov: I think he's saying that if you know how to do it better, you should write it into the channel
11:19:17 <Smerdyakov> ... doesn't anyone else see that there's no case for an [] parameter?
11:19:30 <shapr> Smerdyakov: write one that works and paste it into the channel
11:19:36 <Smerdyakov> No, it's too obvious.
11:19:52 <hdaume> Smerdyakov: originally he was asking about the lambda expression, so i figured that the base case was another line he didn't bother pasting
11:20:09 <Smerdyakov> OK
11:20:38 <hdaume> panoramix: does my explanation make any sense?
11:20:53 <shapr> yay: http://www.cs.uu.nl/~afie/haskell/LearningHaskell.html
11:21:44 <panoramix> hdaume: you mean what it is meant to do?
11:21:45 <panoramix> yes
11:21:56 <panoramix> i know what the function does 
11:22:08 <panoramix> i just dont get how it does it
11:22:29 <panoramix> i didn't understand the lamda function at first and then
11:22:56 <shapr> panoramix: which parts do you understand?
11:23:00 <panoramix> i couldn't figure out the explanation that hdaume gave me
11:24:01 <shapr> well, what parts of that code do you understand?
11:24:06 <panoramix> i know what map does and the functions makes sence as bits of pieces rather than a whole
11:24:08 <shapr> can you give me a partial explanation of what it's doing?
11:24:12 <hdaume> oh okay.  think of it this way: you have a (non-empty) list with a head and a tail.  suppose (recursively) you can get the appropriate values for the tail.  that is, for the tail 'as', you can get a list of pairs whose first element is an element from as and whose second element is as without that first element.  now, in order to include 'a' in this jumble, first we add (a,as) to the front (to account for that pair), then we have to add 'a' on to the begin
11:24:44 <hdaume> ements (that's what the map does)
11:27:36 <hdaume> panoramix: it's actually kind of a complicated function (it took me a while to figure out what it was doing).  you might be best served by working out the derivation by hand for a short list like [1,2,3]
11:27:53 <panoramix> ok i'll try
11:28:01 <panoramix> one sec
11:30:13 <hdaume> if you give it [1,2,3], you know that 'del [2,3]' will return [(2,[3]), (3,[2])].  the original call will add (1,[2,3]) to the front of this and add (though the map) 1 to the beginning of each second component, giving [(1,[2,3]), (2, 1:[3]), (3, 1:[2])] = [(1,[2,3]), (2,[1,3]), (3,[1,2])] as we want
11:32:54 <panoramix> one moment...
11:37:39 <panoramix> if i didn't want to use map then i would have to define the f function on its own?or is this not possible?
11:41:16 <hdaume> if you didn't want to use map, you would write "del (a:as) = (a,as) : del' a (del as)"  and then "del' [] = [] ; del' ((x,y):xs) = (x, a:y) : del' xs"
11:43:16 <Smerdyakov> You could?
11:43:22 <Smerdyakov> Looks like a type error to me =)
11:44:13 <hdaume> erm, sorry.  it should be "del' a [] = [] ; del' ((x,y):xs) = (x,a:y) : del' a xs"
11:44:48 <shapr> yay http://wxhaskell.sourceforge.net/doc/wxh/
11:45:18 <Smerdyakov> shapr, why yay?
11:45:34 <shapr> wxHaskell sounds spiffy to me
11:45:51 <shapr> it means the guys on the GUI list are beginning to align on a solution
11:47:59 <Smerdyakov> OK. I was expecting that it would have a link to your common library page ;-)
11:50:17 <shapr> haha
11:50:27 <shapr> good idea!
11:58:03 * shapr begins to see the fun of static typing
11:58:13 * Smerdyakov arches an eyebrow.
11:58:54 * shapr props up that eyebrow with toothpicks
12:16:58 <shapr> hi argv[0] 
12:17:07 <camold> hehe jo
12:17:36 <camold> its funny that everybody knows everybody else ^^
12:18:35 <Smerdyakov> Hase|work, no, I don't know you.
12:18:47 <Hase|work> hehe
12:19:01 <Sucht`work|Hase> now ?
12:19:02 <Sucht`work|Hase> ^^
12:19:20 <Smerdyakov> Nope
12:19:26 <Sucht`work|Hase> what a pitty ^^
12:49:29 * shapr bounces
14:38:01 <Hase|work> //amsg\\\ good night to all ! cu tomorrow ...
14:38:27 <Hase|work> n8 sharp
14:57:05 * shapr yawns
14:57:58 * shapr bounces
14:59:34 * shapr kodez
15:07:16 * shapr sings happily
15:07:33 * Robert asks shapr for a dance
15:08:01 <shapr> I can't sing, I can't dance... only thing about is my lack of pants.
15:08:07 <shapr> er, that's not the lyrics...
15:08:37 <Robert> I can niether sing nore dance, and as a matter of fact, I wear no pants.
15:08:45 <Robert> s/nore/nor/
15:08:58 <shapr> I have a spiffy pair of biking shorts.
15:21:28 <shapr> hi det
15:26:51 <det> hiya
15:26:55 <shapr> wassup?
15:27:06 <det> so I have come to the conclusion it is impossible to do anything in windows
15:27:13 <shapr> no argument there.
15:27:24 <shapr> have you been able to afford your own computer yet?
15:28:10 <det> I am happy that I made $80 dollars the other day for food :p
15:28:28 <shapr> yay!
15:28:32 <whee> $80 is a lot of food 
15:28:53 <det> indeed
15:29:13 <det> and $80 dollars is redundant!
15:29:28 <det> where are the haskell grammar police
15:29:35 <shapr> we only have SyntaxPolice 
15:29:40 <whee> eh oh
15:29:58 <det> oh, neat
15:30:02 <det> surely TypePolice also
15:33:07 <det> shapr, what do you think of ocaml, C-like speed calls to me
15:33:23 <shapr> I think you should do whatever motivates you most.
15:33:39 <whee> ocaml is nice
15:33:42 <shapr> the internet is about zealot oriented programming above all else.
15:34:07 <shapr> I like Haskell best, but that's just me :-)
15:34:21 <det> shapr, I seem to like haskell better, but ghc seems to be the suck
15:35:28 <shapr> I like ghc
15:35:33 <shapr> how can I help you with ghc?
15:35:37 <det> I think hellow world, stripped was like 1 meg
15:35:44 <shapr> ah, you want dynamic linking?
15:35:54 <shapr> from what I've heard, ghc could do that without too much effort
15:36:03 <det> and yes, dynamic linking :)
15:36:20 <shapr> there are several potential improvements that have been discussed
15:36:38 <shapr> thing is, someone needs to do them.
15:36:56 <shapr> the people who wrote GHC are doing thing like Template Haskell right now.
15:37:02 <det> well, it seems like the GHC people dont want dynamic linking
15:37:06 <shapr> nah, they do
15:37:10 <shapr> I'd like it myself.
15:37:16 <shapr> lots of people would like to have it.
15:37:22 <shapr> just that no one has done it.
15:37:26 <det> "the only advantage is disk space"
15:37:47 <det> does ghc use gcc for linking ?
15:37:59 <shapr> I think so, but I'm not sure.
15:38:16 <shapr> I've never retained much of those discussions because I don't want to hack on GHC right now.
15:38:34 <shapr> I think writing general use libraries is better contribution to the community.
15:38:39 <shapr> for me at least
15:39:45 <shapr> over the last year or so, I've seen at least three separate discussions about adding dynamic linking to GHC
15:40:47 <det> I think inria should make a haskell compiler :)
15:40:51 <shapr> heh
15:40:52 <shapr> maybe so
15:41:06 <shapr> I will hack on GHC
15:41:07 <shapr> just not yet.
15:43:19 <whee> fix it for me while you're at it shapr :)
15:43:37 <shapr> I bet GHC on MacOS X will be stable by the time I get to it ;-)
15:43:47 <whee> I hope so
15:44:08 <shapr> I want to write a QuickCheck External Core checker.
15:44:09 <whee> I've put haskell away until an official TH release so I can complain for real
15:44:13 <whee> heh
15:44:26 <shapr> after that, I want to write a QuickCheck Haskell checker.
15:44:49 <shapr> try to generate code that breaks the compiler, save that code, email the code and the error to ghc-users
15:44:56 <det> QuickCheck ?
15:45:08 <shapr> det: the coolest testing tool ever written ;-)
15:45:21 <det> what does it do ?
15:45:21 <whee> my problems with ghc are all over the place
15:45:30 <whee> but the common trend is that ghci doesn't work because of the problems
15:45:31 <det> the above ?
15:46:52 <det> does ghc have a unit type, like ocaml ?
15:47:01 <shapr> http://www.math.chalmers.se/~rjmh/QuickCheck/
15:47:10 <whee> det: doubt it
15:47:28 <shapr> whee: ghc-users someone just posted about MacOS X problems.
15:47:47 <whee> hah
15:48:01 <whee> just reecntly?
15:48:11 <whee> guess it hasn't hit the archives yet
15:48:56 <whee> oh, the "Building snapshot ..." one?
15:50:02 * shapr looks
15:50:31 <shapr> yah, that one
15:50:42 <whee> I've been fixing that one manually :\
15:51:02 <shapr> you should mention these things on ghc-users
15:51:19 <whee> pfft :P
15:51:21 <det> whee, I would imagine ghc would work better on MacOS X, it being unixy
15:51:23 <shapr> open source needs feedback ;-)
15:51:56 <det> I mean, than windows
15:51:57 <whee> det: it was working at some point, but around 10.2.3 I've had nothing but library loading problems
15:52:13 <whee> ghc is of course the only thing that has problems, heh
15:52:19 <shapr> well, report bugs
15:54:25 <shapr> otherwise they won't get fixed :-)
15:54:46 * shapr wants a haskell refactoring tool
15:54:52 <whee> that would require attempting a build of ghc again, which takes ages :)
15:55:41 <shapr> what are you doing in the meantime?
15:56:13 <whee> I took time to learn cyclone, and been mostly bogged with school work since then
15:56:37 <shapr> can't you build ghc in the background while you're sleeping?
15:56:38 <det> shapr, it would be neat if you could give a refactoring tool 20 files of code and have it find redundant code and refactor everything :)
15:56:47 <whee> yes, but I know it won't work :P
15:56:50 <shapr> det: already been done, originally in Self
15:57:04 <shapr> whee: you could report the parts that don't work
15:57:31 <shapr> det: the downside of a tool like that is that it autogenerates names for functions, and that sometimes you just want redundant code for human reasons.
15:57:32 <det> shapr, wow
15:58:03 <det> shapr, that is cool as hell :)
15:58:09 <det> shapr, practical or not
15:58:24 <shapr> http://c2.com/cgi-bin/wiki?AutomatedRefactoring
15:58:36 <shapr> Ivan Moore wrote the code in Self
15:58:57 <shapr> det: it's pretty easy to reimplement with any existing refactoring browser.
15:59:03 <shapr> assuming you have access to the source of the RB
15:59:16 <shapr> all you need to do is a recursive similarity analysis
16:00:41 <shapr> det: human directed semi-automated refactoring would be far superior
16:01:12 <det> yeah
16:03:00 <shapr> det: you should read the refactoring browser thesis, it's great fun
16:05:52 <det> is that referenced on the wiki ?
16:06:01 <shapr> yes
16:06:22 <shapr> but I can find the url if have trouble finding it
16:07:44 <det> oh, I havent looked at the wiki yet, thanks
16:10:17 <det> bbiab, shake time
16:16:49 <jadrian> hello
16:16:53 <shapr> hiya
16:16:56 <jadrian> hi shapr
16:17:01 <shapr> wassup?
16:17:13 <jadrian> do you know how to bind 2 implicit values in ghci
16:17:14 <jadrian> ?
16:17:36 <jadrian> imagin f as an implicit value n
16:17:46 <jadrian> then you call it like
16:17:59 <jadrian> let ?n=something in f
16:18:10 <jadrian> and this works in ghc and ghci
16:18:23 <jadrian> but if you need two implicit values and n1, n2
16:18:29 <jadrian> then in ghc this works:
16:18:33 <hdaume> let { ?n = something ; ?m = something } in f?
16:18:46 <jadrian> hmmm I didn't use the {
16:18:50 <shapr> hi Arnia 
16:18:52 <jadrian> didn't need them in ghc
16:18:55 <jadrian> let me try
16:19:00 <Arnia> Hey shapr
16:19:04 <shapr> what's up?
16:19:18 <Arnia> Election hell...
16:19:28 <Arnia> I hate being Senior Returning Officer
16:19:54 <jadrian> werid, now it is working even without the {}
16:20:01 <jadrian> thanks hdaume
16:20:20 * jadrian wonders what went wrong before...
16:20:23 <hdaume> i'm a miracle worker ^_^
16:20:53 <jadrian> :)
16:20:56 * shapr nominates hdaume for Saint Haskell 
16:21:17 <hdaume> all you need to do is ask a question and then without doing anything, i've solved it :)
16:21:34 * Arnia tries to write an STV program in Haskell
16:21:36 <jadrian> by the way, any special reason why we can't just bind implicit values like 'normal' values in ghci?
16:21:40 <jadrian> like
16:21:42 <shapr> hdaume: how do I get a refactoring browser for Haskell?
16:21:47 <jadrian> like
16:21:51 <hdaume> shapr: *grin*
16:22:00 <jadrian> let ?n1=sometstuff
16:22:04 <jadrian> let ?n2=sometstuff
16:22:06 <jadrian> f bla
16:22:40 <jadrian> that way you wouldn't need to specify themm all, all the time...
16:22:51 <jadrian> anyway, this is good enough for now.
16:22:52 <hdaume> jadrian: because things entered into ghci with let are statements (like in do notation) and imp param binding only works in the let/in expression construction (this is a hypothesis)
16:23:25 <hdaume> jadrian: it's for the same reason you can't (i don't think) say " do foo ; let ?n = something ; bar" where bar uses ?n
16:23:41 <jadrian> hdaume: ah, right, two different kinds of let
16:24:06 <hdaume> yup
16:24:30 <jadrian> hdaume: by the way, those operators definitions I sent you had quite a few typos... (thought I'd tell you just in case)
16:24:59 <hdaume> jadrian: ah don't worry about it.  i saved it but haven't looked at it seriously yet
16:25:05 <jadrian> hdaume: oh, and they were missing the infix declaration!!
16:25:09 <hdaume> :)
16:25:53 <jadrian> hdaume: k, just thought I'd let you know. I almost forgot abou that one (the operator priorities)
16:26:53 * jadrian is gone now. work to do...
16:26:56 <jadrian> bye!
16:51:04 <creature> Evening, all.
16:51:18 <shapr> hiya
16:51:37 <creature> I have but a quick question for tonight, which is A Good Thing on the whole given that I'm slightly drunk.
16:52:03 <creature> I've got a custom data type Form, that's along the lines of "Atm A | Or Form Form | And Form Form | Not Form Form"
16:52:09 <radix> hoorj drunken haskelling
16:52:15 <creature> I'm using pattern matching to write functions for this 
16:52:34 <creature> Is there a quick way to say "Not an Atm", or do I have to do a line for And, a line for Or, etc? 
16:52:53 <shapr> huh?
16:53:09 <creature> OK, consider: 
16:53:29 <creature> data Form = Atm Atom |
16:53:29 <creature>             And Form Form |
16:53:29 <creature>             Or  Form Form |
16:53:29 <creature>             Not Form
16:53:29 <creature> data Atom = A | B | C | D | E | F
16:53:30 <creature>     deriving(Show,Eq)
16:54:19 <creature> With me so far? 
16:54:32 <creature> I'm using pattern matching to write functions like this: 
16:54:38 <creature> showAtoms :: [Atom] -> String
16:54:38 <creature> showAtoms (Atm a)   = " a "
16:54:38 <creature> showAtoms (Or x y)  = showAtoms x ++ showAtoms y
16:54:38 <creature> showAtoms (And x y) = showAtoms x ++ showAtoms y
16:54:38 <creature> showAtoms (Not x)   = showAtoms x
16:55:23 <creature> Is there a quick way to say "Everything that's not an Atm", or do I have to do a line for each, like this? 
16:55:39 <creature> like that, even?
16:55:51 <shapr> you could do "showAtoms _"
16:55:55 <shapr> that matches anything
16:56:05 <shapr> that way you can get away with two lines
16:56:22 <shapr> showAtoms (Atm a) = ...
16:56:24 <creature> I suppose the big problem is the Not only takes one argument, whereas Or and And take two.
16:56:27 <shapr> showAtoms _ =
16:59:35 <hdaume> you could do "data Form = And { v1 : Atom ; v2 : Atom } | Or { v1 : Atom ; v2 : Atom } | Not { v1 : Atom }"  then "showForm (Not v) = showAtom v        showForm f = showAtom (v1 f) ++ showAtom (v2 f)"
16:59:44 <creature> brb, food. 
16:59:51 <creature> And I'm not allowed to redefine the data type.
17:00:17 <hdaume> then you could define v1 and v2 yourself and use that solution...the complexity then goes in to v1 and v2, but at least it's reusable complexity
17:00:24 <hdaume> other than that, you're sol
17:01:59 <shapr> sleep for me
17:16:36 <creature> Back.
17:16:37 <creature> sol?
17:20:16 <creature> Argh@drunken haskell.
17:20:45 <creature> It makes it so much more difficult.
17:22:07 <creature> What's that function that sticks an operator between each element of a list? 
17:22:12 <creature> It's zipWith, isn't it? 
17:22:35 <jlouis> less /usr/local/lib/hugs/lib/Prelude.lhs
17:23:14 <creature> You think my co-ordination is up to that? :)
17:23:39 <jlouis> cut-and-paste
17:23:54 <jlouis> you cannot do drunkcoding in a static type inferred language
17:24:04 <jlouis> Scheme is a far better choice for that ;)
17:25:46 <creature> Heh. 
17:26:48 <creature> There's a language called APL where you can just roll your head around
17:26:48 <creature> on the keyboard and the compiler will say "Yeah, that's fine".
17:26:48 <creature>         -- Ian Utting talking about Java syntax
17:27:11 <jlouis> hehe
18:09:57 <det> creature, fold ?
23:08:59 <kawfee> hello
