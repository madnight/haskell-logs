03:55:58 <Smoking_K> Hey guys, easy Q. I have a list of strings, where it is full of '1' and '0'. How would I make a new list, where the 1=True and 2=False??
04:03:12 <Smoking_K> hello? Can I paste my code in??
04:03:25 <Rafterman> [x == "1" | x < list]
04:03:37 <Smoking_K> hmmm
04:03:39 <Smoking_K> I'll try that
04:03:39 <Rafterman> [x == "1" | x <- list]
04:04:23 <Rafterman> do you understand what that's doing?
04:05:22 <Smoking_K> yea, check if x=="1" for all values in the list
04:05:32 <Rafterman> ok cool
04:05:36 <Smoking_K> but, would that replace x with True  or False?
04:05:42 <Smoking_K> or just check?
04:05:49 <Rafterman> mu
04:05:55 <dennisb> it produces a new list with booleans
04:06:01 <Rafterman> it would return a new list of .. yeah
04:06:01 <Smoking_K> cool cool
04:06:28 <Smoking_K> ok, well this is my full line and it has a nother prob... if you don't mind
04:06:30 <Smoking_K> > buildMaze a = group (a!!2) ([x == "1" | x <- (drop 3 a)])
04:06:47 <Smoking_K> you see, the 1,0's only start at position 3
04:06:51 <Rafterman> ewwww
04:06:53 <Smoking_K> I mean 4
04:07:14 <Smoking_K> group is another function... but I  know it works
04:08:01 <Rafterman> is this for coursework, or just for personal use?
04:09:35 <Smoking_K> coursework. 
04:09:49 <Smoking_K> man, I doubt I will ever use Haskell again in my life
04:09:58 <Smoking_K> but, I still want to know how to do it properly
04:10:00 <Rafterman> coz I'd jump up and down on my students if they did something like that :-)
04:10:17 <Smoking_K> lol.... well, my lecturer has already seen it. He gave me the idea
04:10:35 <Rafterman> either way, what's the problem with that line exactly?
04:11:04 <Smoking_K> I'll just be a sec, I'm trying to just get your line to work
04:11:06 <Smoking_K> won't be a sec
04:11:21 <Rafterman> k
04:12:07 <Smoking_K> Ok, I'll show you the 2 lines, that I've shrunk it down too, and I'll copy the error I get
04:12:14 <Smoking_K> > swapIntToBool :: [a] -> [Bool]
04:12:14 <Smoking_K> > swapIntToBool a = [x == "1" | x <- (drop 3 a)]
04:12:43 <Smoking_K> Expected Type  : [a] -> [Bool]
04:13:00 <Smoking_K> Inferred Type : [[char]] -> [Bool]
04:13:11 <Rafterman> *nod*
04:13:21 <Rafterman> you're type sig for sqapIntToBool is incorrect
04:13:23 <Smoking_K> So I guess that the x=="1" isn't a Bool in the new list?
04:13:26 <Rafterman> what must the type of x be?
04:13:37 <Rafterman> == will always give you a bool
04:13:46 <Smoking_K> ok... thats what I want
04:13:49 <Rafterman> but it has the property that the thing on the left has to be comparable to the thing on the right
04:14:00 <Rafterman> in this case, a string (or [Char])
04:14:19 <Smoking_K> ok.... well [a] will be a list of strings. But, it doesn't even get that far
04:14:24 <Smoking_K> yea, ok... 
04:14:28 * Smoking_K is listening intently
04:14:35 <Rafterman> why will [a] be a list of string
04:14:41 <Rafterman> [a] just implies it's a list of any type
04:14:53 <Smoking_K> yea, it will be a list of string when I run the thing
04:14:53 <Rafterman> s/any/some/
04:15:00 <Rafterman> yeah, so you should tell it that
04:15:11 <Rafterman> since that's a restriction on the function
04:15:20 <Rafterman> it can't take in any old list, it has to take in a list of strings
04:15:28 <Smoking_K> oh.... got ya!
04:15:31 <Smoking_K> brb
04:16:21 * Smoking_K learns something everyday... sometimes 2 things!
04:16:31 <Smoking_K> Thanks, I'll probably be back though :)
04:19:35 <dennisb> well, you stated that the function could take any list and return a list of booleans, then the function you wrote could not work on any input list, and that is exactly what the error messages says
04:20:27 <dennisb> He expexted it to be the type you said it should be ([a] -> [Bool]) but the function you wrote had type [[char]] -> [Bool]
04:20:41 * dennisb loves the error messages from haskell errors
04:23:36 <Smoking_K> can anyone tell me how to set a string in Hugs98 so that I can use it to pass to a function
04:23:45 <Smoking_K> and in particular is \n the new line character?
04:28:35 <d33p> set a string? what do you mean?
04:28:50 <Rafterman> a) I don't get the question and b) yes, \n is newline
04:28:50 <Smoking_K> well, in hugs is there a way that I can do something like
04:29:00 <Smoking_K> set temp :: String = "kjdsfjkhsdfkjdhsfkjdsafa"
04:29:06 <Smoking_K> then when I call a function I can type
04:29:13 <Smoking_K> functionname temp
04:29:22 <d33p> Smoking_K: f s = s 
04:29:41 <d33p> then f s gives you s.. 
04:29:55 <dennisb> Smoking_K: in your haskell file you write:  temp = "kjdsfjkhsdfkjdhsfkjdsafa"
04:30:14 <Smoking_K> just that? I don't need to define it as a string?
04:30:19 <dennisb> you have to load that file in hugs, you can't do it on the command line
04:30:31 <dennisb> that you can do on the live above: temp :: String
04:30:47 <dennisb> (you don't have to, but it can be a good idea)
04:31:02 <Smoking_K> oh ok.... cool, thanks for your help guys
04:37:33 * Heffalump appears
04:37:41 <Heffalump> who Heffalumped?
04:39:39 <prologic> If you cannot modify variables (ie: haskell being a pure functional language), how do you convert the function QTRAP (shown at: http://daisy.ods.org/~prologic/INT.FOR) into haskell ?
04:39:50 <prologic> also I'm still not that good even with recursion...
04:40:09 <prologic> anything to get me on the right track would be appriciated :)
04:40:43 <prologic> functions can be passed as parameters to other functions too right ?
04:41:16 <Rafterman> yep
04:41:46 <dennisb> prologic: generate a list with better and better approximations
04:42:32 <Smoking_K> ok, I'm back... this should be easy though
04:42:48 <Smoking_K> with the code you guys gave me before
04:42:51 <Smoking_K> [x == "1" | x <- (drop 3 a)]
04:43:06 <Smoking_K> this returns a list of boolean?
04:43:12 <Rafterman> *nod*
04:43:14 <Smoking_K> if I put in my own function, such as
04:43:34 <Smoking_K> [getWhatver x| x <- List] 
04:43:48 <Smoking_K> but getWhatver returns say Ints, would that create a list of ints?
04:43:53 <Rafterman> yes
04:43:53 <dennisb> yes
04:43:59 <Smoking_K> cool....
04:44:04 * Smoking_K is starting to understand
04:44:27 * Smoking_K feels all warm and fuzzy... oh, I wet myself :)
04:45:38 <Heffalump> Marvin--: there is WLAN here, yes, but you have to sign up for it
04:45:52 <Heffalump> but I'm not sure if they verified that I was an attendee first
04:46:29 <prologic> dennisb, I've seen this done before, why do you people say "generate a list" ? is it one of the only ways to do it ?
04:46:55 <Marvin--> Heffalump: :) I don't have time to buy a card before Wednesday anyway
04:48:09 <dennisb> prologic: it's just a pretty way to do it. but there are plenty of ways, including ones that look almost like your program
04:48:31 <dennisb> prologic: but writing it like that when you can do it in a beautiful way is a crime :-)
04:48:37 <prologic> dennisb, well I'd like to learn both ways :) I do a lot of imperitive programming as it is.
04:48:56 <prologic> dennisb, I haven't learnt that yet, so you have to show me the other way without using a list :P
04:49:55 <dennisb> prologic: it's way to much work for me to do that, and the concepts is a bit complicated. It's better to begin with easier programs
04:50:18 <dennisb> like generating a list
04:50:40 <prologic> ok
04:51:17 <dennisb> all you do with loops in other languages you usually do with lists in haskell
04:51:18 <prologic> could you show me a similar function, not the one displayed on my webpage (using a generated list) ?
04:51:26 <prologic> I've figured that so far :)
04:51:39 <dennisb> or recursion of course
04:51:47 <prologic> recursion confuses me sometimes, I never use it in imperitive languages
04:51:55 <Smoking_K> ahhh, this is just something I've been thinking about. I've checked out a few tutorials, about using if, else.. and I can't see how you are supposed to do a if -> else if... only if and else???
04:52:01 <prologic> thanks much appriciated
04:52:15 <dennisb> recursion is just as easy as loops, or even easier
04:52:23 <Rafterman> Smoking_K: try to avoid if/else if at all possible
04:52:31 <prologic> not for someone from an imperitive background :P
04:52:36 <Smoking_K> yea, I've been using guards.... they work well
04:52:44 <Rafterman> yeah, they're much nicer
04:52:59 <dennisb> prologic: I too had been writing C/Asm/You name it before i started with functional programming
04:53:00 <Smoking_K> but, I keep going back to Java and C++'s if's I can't help it :)
04:53:42 <dennisb> prologic: here is a list with numbers: xs = [1..100]
04:53:55 <prologic> yup that much I know :)
04:53:59 <dennisb> prologic: here is a list with squared numbers: xs = [x*x | x <- [1..100]]
04:54:07 <prologic> k
04:54:18 <prologic> what about a recursive function that generates a list ?
04:54:29 <Smoking_K> hmmm, how do I recursively make, and the add to list??
04:54:34 <Smoking_K> yea, good thinking 99
04:54:44 <prologic> lol that's an example I want to see :P
04:54:49 <dennisb> now, take the first squared number bigger then 200: head (dropWhile (<=200) xs)
04:55:36 <dennisb> it's hard to just come up with nice examples..
04:55:41 <dennisb> prologic: easy to write
04:56:02 <prologic> k
04:56:10 <prologic> well thanks though, but gotta go cook and eat dinner :)
04:56:15 <dennisb> here is one: f x = (x * x) : f (x+1)
04:56:24 <Smoking_K> yea, I've seen that ex
04:56:30 <Smoking_K> can I give you what I've done??
04:56:49 <dennisb> sure, if it's not to big to paste in the channel
04:56:55 <Smoking_K> nah...
04:57:06 <Smoking_K> > getGoodNeighbours :: Maze -> Trail -> Point -> [Point]
04:57:06 <Smoking_K> > getGoodNeighbours m t (c,r) = getGoodNeighbours2 (getNeighbours m (c,r)) t
04:57:06 <Smoking_K> > getGoodNeighbours2 :: [Point] -> Trail -> [Point]
04:57:21 <Smoking_K> where point = (Int,Int)
04:57:25 <dennisb> ok
04:57:30 <Smoking_K> and Maze = [[Bool]]
04:57:40 <Smoking_K> and Trail = [Point]
04:57:50 <dennisb> what does it do? (in english)
04:57:50 <Smoking_K> I'm doing a maze, and how to get out of it
04:58:02 <Smoking_K> thats the overview anyway
04:58:05 <Smoking_K> anyway
04:58:16 <Smoking_K> I get a maze, and trail and a point
04:58:42 <dennisb> and a trial is the path that you have walked so far?
04:58:49 <Smoking_K> yea
04:59:11 <Smoking_K> I need to return a list of points that aren't on the trail, and is still a neighbour
04:59:21 <Smoking_K> and not a wall.
04:59:22 <dennisb> ok
04:59:36 <Smoking_K> Now I have functions that work, that will tell me if a point is a wall, or on the trail
04:59:55 <Smoking_K> a I have a function that will tell me all my neighbours (but now if they are 'good')
05:00:08 <Smoking_K> so, here was my plan
05:00:20 <Smoking_K> I get the Maze, Trail and Point...
05:00:50 <Smoking_K> Then using the maze and point I can get all the neighbours in a [Point]
05:01:15 <Smoking_K> now, I need to check those [Points] against isWall and isInTrail which both return bools
05:01:33 <prologic> dennisb, with a recursive function like the last one you showed, how do you get it to stop ?
05:01:36 <Smoking_K> originally I had [isInTrail t x | x <- p] ... but I need the points not the bool it returns
05:01:43 <prologic> all the functions I need to write need to stop eventually
05:02:09 <dennisb> prologic: you can for example take the 100 first elements: take 100 (f 1)
05:02:32 <Smoking_K> then I was going to use a recursive function checking the first point in the neighbours, and returning the point if good... but I couldn't return an empty point... it died on me
05:02:49 <dennisb> Smoking_K: you need to find the filter function in the doc, or read more about list comprehensions
05:03:24 <Smoking_K> filter? ok
05:03:50 <dennisb> filter is a function you can use to select out some of the elemens in a list
05:03:57 <dennisb> say, those that are not walls
05:04:22 <prologic> dennisb, ok, that'd be in the interpreter though. but say one like qtrap it has to stop when the accuracy is reached a limit...
05:04:56 <dennisb> prologic: then you traverse the list until you find an element that you want
05:05:15 <dennisb> for example when the difference to the previous element is small enough
05:05:57 <prologic> hrmm k
05:06:22 <prologic> you've probably gathered by now it's an assignment, but I'm not getting noone to do it :P
05:06:39 <prologic> however, it says "Your program should use the same general strategy as the FORTRAN program INT.FOR" ...
05:06:45 <dennisb> prologic: sure, we get assigment workers here all the time
05:06:49 <Lunar^> @prelude filter
05:06:51 <lambdabot> *** "filter" prelude "Haskell Standard Prelude Dictionary": text follows
05:06:51 <lambdabot> filter
05:06:51 <lambdabot>   filter ::  (a -> Bool) -> [a] -> [a]
05:06:51 <lambdabot>   filter p xs       = [ x | x <- xs, p x ]
05:06:54 <prologic> would writing functions to return lists etc be using the same strategry ?
05:07:06 <dennisb> prologic: and we usually help them a little, but never give whole solutions
05:07:17 <prologic> I wouldn't let you anyway ;P
05:07:22 <prologic> defeats the purpose
05:07:42 <Darius> I think they are talking about the overall algorithm, e.g. symbolically integrating and writing a program to calculate the answer.
05:07:42 <prologic> but would using lists still be in accordance to "using the same general strategy as the fortran program" ?
05:07:48 <dennisb> prologic: I think it would, you would generate better and better approximations until you get a small difference between two of them
05:07:57 <prologic> ok
05:08:03 <prologic> I'd have to agree with you both then :)
05:08:05 <prologic> excellent
05:08:51 <dennisb> I think it is just so you do not just link in some math package and call the integration function
05:09:06 <prologic> hah
05:09:09 <prologic> you mean there is one ?
05:09:18 <dennisb> I don't know
05:09:41 <prologic> ah k
05:09:55 <dennisb> you can call C libraries from haskell (with a little work) so there must be
05:10:14 <prologic> k
05:10:35 <Smoking_K> dennisb: Do you know the filter function off the top of your head? I'm having a bit of trouble implementing it the way I want
05:11:00 <dennisb> Smoking_K: lunar showed it above
05:11:16 <dennisb> or rather, he got the lambdabot to do it
05:11:29 <prologic> @prelude filter
05:11:31 <Smoking_K> yea, I can get a basic function to work, but when I add my own, I don't know how to get it to use the array in the function?? that didn't make sense
05:12:09 <Smoking_K> hmmm, I'll see if I can find another tutorial
05:12:26 <dennisb> prologic: strange, it didn't work. Maybe he didn't like it when I talked about it
05:12:36 <prologic> lol
05:12:41 <prologic> I put a  in front
05:12:46 <prologic> didn't really want to execute it again
05:12:54 <prologic> err %0 rather
05:12:57 <dennisb> aah, that explains it :-)
05:16:13 <Smoking_K> ok, ok.... I'm getting there. This is what I've tried.. but doesn't work :(
05:16:21 <Smoking_K> > getGoodNeighbours2 :: [Point] -> Trail -> [Point]
05:16:21 <Smoking_K> > getGoodNeighbours2 p t = [x == x | x <- p , (isInTrail t x) && (isEmpty t x)]
05:16:29 <Smoking_K> oh
05:16:38 <dennisb> ooh?
05:16:44 <dennisb> ook!
05:16:59 <Smoking_K> hmmm... that wouldn't work would it?? 
05:17:11 <dennisb> you would get a type error
05:17:23 <Smoking_K> what I want is for it to only add x when (isInTrail) && (isEmpty) are true
05:18:02 <Smoking_K> if I use the filter command how would I use it... I need to do something like...
05:18:23 <dennisb> filer and the above is just the same (Except that the above does not work)
05:18:28 <Smoking_K> lol
05:18:40 <dennisb> you got a type error, right?
05:18:42 <Smoking_K> yea
05:18:52 <dennisb> and what was the error?
05:19:41 <Smoking_K> (int,Int) doesn't match (Bool)
05:20:15 <dennisb> So somewhere there is mixup with a Point and a boolean value
05:20:20 <Smoking_K> yea
05:20:29 <dennisb> the thing is that your function should return a list of points, but it does not
05:21:06 <dennisb> instead it returns a list of booleans
05:21:35 <Smoking_K> yea...
05:21:40 <Smoking_K> I think I may have it... brb
05:23:30 <elmex> what does 'Inferred type is less polymorphic than expected' mean?
05:23:58 <Darius> It means your type signature is too general
05:24:11 <elmex> and how to make it less general?
05:24:47 <dennisb> In 5 straight hours there have been a big hammer machine outside my window trying to turn a cliff into small rocks.. Damn what noise it makes..
05:25:28 <Darius> Presumably you have an explicit type signature for a reason, so usually you don't want to make the type less general.
05:25:45 <norpan> hi all
05:25:52 <dennisb> norpan!
05:25:56 <norpan> dennisb!
05:26:03 <dennisb> what's up with you?
05:26:08 <dennisb> any fun news?
05:26:11 <norpan> not much
05:26:27 <norpan> i'm coding haskell at a never before seen rate though
05:26:37 <dennisb> if you want to see a big stone being turned into dust you should come this way :-)
05:26:39 <norpan> my fingers are flying and i have made 0 errors today
05:27:07 <dennisb> nothing wrong with that
05:27:15 <norpan> i think i have hindley-milner built into my brain
05:27:30 <dennisb> but you made an error when you came here instead of writing more haskell
05:27:47 <norpan> i am waiting for the Big Compile
05:28:11 <dennisb> so maybe it's just type correct
05:28:26 <norpan> but coming here is not a type error, maybe a context error though
05:28:32 <dennisb> true
05:29:30 <dennisb> writing type correct but non working programs is simple (not that I think your programs don't work)
05:29:37 <norpan> No instance for (Chat Norpan)
05:29:59 <dennisb> nerd alert: to too little humor detected
05:30:04 <Smoking_K> sorry guys, can I jump in and ask a quick Q?
05:30:06 <norpan> arising from use of `chat' at <interactive>:1
05:30:15 <norpan> Smoking_K: i think you can
05:30:19 <Smoking_K> lol
05:30:25 <Smoking_K> I have this working...
05:30:26 <Smoking_K> (filter (isEmpty m) p)
05:30:38 <Smoking_K> what if I want it to be (not isEmpty) ???
05:30:43 <norpan> filter (not.isEmpty)
05:30:55 <norpan> (not.isEmpty m) i mean
05:30:56 <Smoking_K> oh... I never used a . before
05:31:09 <norpan> try it - you'll like it!
05:31:14 <dennisb> hoho
05:31:17 <Smoking_K> lol, ok thanks
05:31:44 <norpan> poor man's version is (\x -> not (isEmpty m x)
05:31:47 <norpan> )
05:32:07 <norpan> but i suppose you haven't used \ either
05:32:21 <dennisb> isEmpty sounds like it takes just one argument
05:33:14 <norpan> but if the filter stuff worked before then it has two
05:33:24 <norpan> at least...
05:33:25 <Smoking_K> it does have 2
05:33:35 <Smoking_K> ummm, how do I filter a filter?
05:33:47 <norpan> how do you mean
05:34:03 <Smoking_K> well, I need to check that it isEmpty and not.isWall 
05:34:40 <Smoking_K> well, actually isEmpty and not.isInTrail, type by me
05:34:41 <dennisb> Smoking_K: write a help function that does both and use in the filter call
05:34:45 <norpan> well you can use filter on the result of the filter
05:35:10 <norpan> or you can write both functons as (\x -> isEmpty x && not (isInTrail x))
05:35:14 <Smoking_K> norpan : Yea, thats what I meant. But I need to somehow use p (from above) in both calls
05:35:29 <Smoking_K> hmm, what does the \x mean?
05:35:30 <norpan> Smoking_K: filter f1 (filter f2 p)
05:35:47 <Lunar^> Smoking_K: "\" stands for lambda
05:36:09 <norpan> Smoking_K: \x is lambda abstraction, (\x -> f x) is a function that takes an argument x and produces (f x)
05:36:20 <dennisb> when can we compile programs in haskell (ghc) written in utf-8?
05:36:37 <Smoking_K> ok, I'll be back
05:36:39 <dennisb> so I can start to use a real lambda
05:36:41 <norpan> dennisb: when i understand the code
05:37:04 <dennisb> norpan: really, that would be great
05:37:09 <Lunar^> dennisb: GHC does only supports iso-8859-1 if I read the release notes correctly
05:37:19 <dennisb> the coolnessfactor would be so big
05:37:38 <Lunar^> dennisb: A big coolness factor would be an arrow graphical editor IMHO
05:37:57 <dennisb> well, one can be cool in different ways
05:38:04 <Lunar^> dennisb: something like Overflow ( http://freespeech.sourceforge.net/overflow.html )
05:40:03 <norpan> dennisb: i don't really see the need for using "real" lambda though
05:40:24 <norpan> but I see the need for using unicode in strings, i will address that first
05:40:33 <dennisb> norpan: need and coolness has nothing to do with each other
05:40:45 <norpan> being able to write utf-8 string constants for instance
05:41:00 <dennisb> sure
05:41:14 <norpan> the need for utf-8 identifiers is not too big either
05:41:43 * dennisb knows, but doesn't care. He want it anyway
05:41:53 <Smoking_K> ok, I got it guys... I did dennisb idea of a help function then calling filter on that... much nicer to read and easier to implment
05:44:55 <Lunar^> Smoking_K: that's where "where" are useful IMHO
05:45:26 <Lunar^> Smoking_K: but sometimes using anonymous functions are easier because you can't find an appropriate name
05:46:16 * Lunar^ is really annoyed by his poor english
05:46:17 <Smoking_K> heheh yea
06:08:58 <Smoking_K> ok... anyone still awake here?
06:09:15 <dennisb> maybe
06:09:18 <Smoking_K> lol
06:09:43 * Rafterman invokes the lol-free zone rule on Smoking_K
06:09:43 <Smoking_K> I need to create a recursive function.... easy right?
06:09:53 <Smoking_K> ok, ha ha ha
06:10:11 <Rafterman> oh wait, we're in #haskell, not #python
06:10:19 <Rafterman> I think lol'ing is allowed in here
06:10:23 <Rafterman> but that's no excuse to do it :-)
06:10:38 <Smoking_K> ok... back to me, look at me! But, what if I have 3 different paths to test for? :P
06:10:51 <Smoking_K> or 2, or 1... I have those in a list
06:10:51 <Rafterman> so have 3 different gaurds
06:11:03 <Smoking_K> is a guard a if, or else if?
06:11:15 <Smoking_K> I thought it was a else if
06:11:21 <Smoking_K> so it wouldn't do all of them
06:11:41 <Rafterman> gaurds get evaluated in order, and the first one which is true gets taken
06:12:01 <Smoking_K> oh righto... I thought they were like, ifs and else if's
06:12:08 <Rafterman> yeah
06:12:41 <Smoking_K> ok, 1 more....
06:12:51 <Smoking_K> > type Trail = [Point]
06:12:55 <Smoking_K> and I have another point
06:13:04 <Smoking_K> why doesn't this work...
06:13:18 <Smoking_K> myFunction trail : point
06:13:20 <Rafterman> becuase it's a point, not a list of point </guess>
06:13:38 <Smoking_K> well, how do I add it to the end of the list?
06:13:42 <Smoking_K> I thought it was ++ or :
06:13:51 <Lunar^> @prelude (++)
06:13:52 <lambdabot> *** "(++)" prelude "Haskell Standard Prelude Dictionary": text follows
06:13:52 <lambdabot> (++)
06:13:52 <lambdabot>   infixr 5 ++
06:13:52 <lambdabot>   (++) ::  [a] -> [a] -> [a]
06:13:53 <lambdabot>   []     ++ ys      = ys
06:13:55 <lambdabot>   (x:xs) ++ ys      = x : (xs ++ ys)
06:14:00 <Rafterman> xkb: list will add the element x onto the front of list
06:14:11 <Rafterman> list1 ++ list2 will concatinate the two lists
06:14:22 <Rafterman> erk
06:14:26 <Rafterman>   x:list will add the element x onto the front of list
06:14:45 <Smoking_K> yea, I tried ++ didn't work... I'll get back to ya though... thanks
06:15:22 <Smoking_K> hmmm, is there a for each type loop? Like in Java?
06:15:31 <Smoking_K> ah don't worry
06:15:32 <Lunar^> @prelude foldl
06:15:34 <lambdabot> *** "foldl" prelude "Haskell Standard Prelude Dictionary": text follows
06:15:34 <lambdabot> foldl
06:15:34 <lambdabot>   foldl ::  (a -> b -> a) -> a -> [b] -> a
06:15:34 <lambdabot>   foldl f z []      = z
06:15:34 <lambdabot>   foldl f z (x:xs)  = foldl f (f z x) xs
06:15:34 <Smoking_K> I'm thinking out load
06:16:00 <Lunar^> There's also foldr if you want to go from the right
06:16:27 <Lunar^> I need help to understand how to use Maybe as a monad
06:16:52 <Rafterman> i think fold is a little advanced at this point
06:16:54 <Rafterman> walk, then run
06:17:03 <Marvin--> Lunar^: what about it?
06:17:05 <Meep> map might be easier to start with?
06:17:26 <Lunar^> I have a list of function which mail fail, returning Nothing
06:17:43 <Lunar^> But they can succeed returning Just a
06:17:57 <Lunar^> I want the evaluation to stop as soon as we got the first Just
06:18:17 <Lunar^> I don't see what is the nicest way to do it
06:18:34 <Marvin--> then you basically have to use mplus
06:19:26 <Lunar^> foldM1 mplus [firstFun, secondFun, ...] ?
06:20:59 <Meep> just use foldl, I think
06:21:29 <Meep> foldl mplus Nothing [firstFun, secondFun...]
06:22:05 <Meep> or foldl1 mplus [firstFun, secondFun,...]
06:22:06 <Lunar^> ok nice
06:22:12 <Marvin--> not functions, actions
06:22:28 <Meep> oops, sorry
06:22:35 <Marvin--> > :t foldl1 Control.Monad.mplus forall m a. (Control.Monad.MonadPlus m) => [m a] -> m a
06:23:32 <Marvin--> use foldr1 if you want to be able to use infinite lists
06:24:18 <Smoking_K> ahhh, I'm still stuck... Can I try and explain what I need to do and maybe you guys will know a better way of doing it?
06:24:23 <Lunar^> @prelude foldM
06:24:25 <lambdabot> *** "foldM" prelude "Haskell Standard Prelude Dictionary": text follows
06:24:25 <lambdabot> foldM
06:24:25 <lambdabot>   foldM ::  (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
06:24:25 <lambdabot>   foldM f a []      = return a
06:24:26 <lambdabot>   foldM f a (x:xs)  = f a x >>= \ y -> foldM f y xs
06:24:46 <Lunar^> Smoking_K: go on :)
06:25:07 <Smoking_K> ok, I have a type maze, that is either wall or not, using true or false.
06:25:15 <Lunar^> Marvin--: strange, I read a foldM impl. with foldr
06:25:44 <Smoking_K> and I have trail (where I've walked, I can go up, left, right and down)... not through walls obviously
06:26:09 <Smoking_K> I have a bunch of functions telling me if that point is out of the maze etc...
06:26:16 <Smoking_K> now I have a function such that
06:26:24 <Smoking_K> > type ExitPair = (Bool, Trail)
06:26:24 <Smoking_K> > searchExit :: Maze -> Point -> ExitPair
06:26:24 <Smoking_K> > searchExit m p = searchExitWithTrail m [] p
06:26:30 <Lunar^> What is exactly your current Maze type ?
06:26:48 <Smoking_K> > type Maze = [[Bool]]
06:26:58 <Lunar^> What means the Bool in ExitPair ?
06:27:26 <Smoking_K> if I can get out on that trail
06:27:35 <Lunar^> Smoking_K: Ok, so you should use Maybe here
06:27:44 <Rafterman> erk
06:28:00 <Lunar^> Maybe a means that you've got either Nothing, or Just a
06:28:26 <Smoking_K> ummm, still confused
06:28:30 <Lunar^> type Exit = Maybe Trail
06:28:46 <Smoking_K> oh got ya
06:28:47 <Rafterman> I think Maybe will only confuse the matter further
06:28:49 <Lunar^> If there's no Exit, you have Nothing, if there's an exit, you've got a trail, so Just Trail
06:29:01 <Marvin--> Lunar^: I think that'll be hard to unify
06:29:05 <Rafterman> Maybe is nice, but not if you're a n00b to the language
06:29:07 <Smoking_K> the lecturer stated that if the bool = false, then the trail = []
06:29:23 <Smoking_K> probably not to confuse me :)
06:29:51 <Lunar^> Rafterman: dunno, it's one of the first thing a programmer with some experience catch... each of us already has impl. a function to lookup
06:30:21 <Lunar^> Rafterman: to my experience, indeed
06:30:22 <Rafterman> for an experienced programmer, sure
06:31:01 <Smoking_K> well, where I'm stuck is... I've got my point where I am, I can get all my good neighbours (where I can go, that isn't where I was, and not a wall)... but how do I recursively call myself with all of the neighbours, when I don't know them, or how many there are?
06:31:24 <Smoking_K> until I run the prog that is.
06:31:36 <Lunar^> Smoking_K: I don't understand how your Maze type works
06:31:48 <Rafterman> presumably you're function will have a list of neighbours as input
06:32:08 <Rafterman> s/you're/your/
06:32:16 <Smoking_K> I have the following
06:32:25 <Smoking_K> > searchExit :: Maze -> Point -> ExitPair
06:32:26 <Smoking_K> > searchExit m p = searchExitWithTrail m [] p
06:32:26 <Smoking_K> > searchExitWithTrail :: Maze -> Trail -> Point -> ExitPair
06:32:26 <Smoking_K> > searchExitWithTrail m t p | isInBorder m p == True = (True, (t ++ p))
06:32:48 <Smoking_K> now the next line I need to recursively call myself with something like
06:33:33 <Smoking_K> >                     | searchExitWithTrail m (t ++ p) All of these-> GetGoodNeighbours(m t p)
06:33:49 <Smoking_K> that is what I can't do..... ??? Am I still explaining it really badly?
06:34:31 <Lunar^> I don't think so
06:34:52 <Lunar^> But I would have done the Maze type so differently
06:35:01 <Smoking_K> yea, I don't have a choice in that :)
06:35:12 <Smoking_K> I wouldn't have done it in Haskell .....
06:35:16 <Lunar^> You can still do you own Maze ;)
06:35:18 <Cale> How is the Maze type defined?
06:35:30 <Cale> oh, [[Bool]] ?
06:35:38 <Smoking_K> [[Bool]] It is like a 2D maze, true is a wall, false isn't
06:35:54 <Smoking_K> in a grid shape?? you get it?? 
06:36:01 * Smoking_K really bad at explaining
06:36:05 <Cale> ah, hmm. Yeah.
06:36:54 <Smoking_K> I was thinking that the map function would work, but I'm not sure how to use it in this situation with all these var's running arounmd the place
06:37:32 <Lunar^> I would have done it that way I think : data Maze = [(Direction, Maze)]
06:38:08 <Cale> yeah, actually, building Lunar^'s construction using what you have might make things easier.
06:38:23 <Smoking_K> unfortunately I think I will lose marks if I do that
06:38:37 <Smoking_K> I suspect that the markers have some sort of batch file to mark the assignment
06:38:43 <Lunar^> damn.. using the right data structures are penalized now ?!
06:38:48 <Cale> haha
06:38:55 <Smoking_K> I'd say so....
06:39:17 <Smoking_K> what I would like to know really, in short is how to implement map in the following manner
06:39:27 <Cale> Yeah, we have some of the same ridiculousness at my university, too. :)
06:39:31 <Lunar^> Anyway, writing something like buildMyMaze :: Maze -> MyMaze would be pretty straightforward
06:39:45 <Lunar^> Ok... sorry for bothering
06:39:54 <Smoking_K> map function var var (Function to get array)
06:40:18 <Lunar^> @type map
06:40:18 <lambdabot> map :: (a -> b) -> [a] -> [b]
06:40:41 <Smoking_K> yea, that works good for the examples they had, like add etc... but not for this :)
06:41:13 <Cale> map lifts a function on values to a function on lists of those values.
06:41:21 <Smoking_K> see, I get some stupid error for this code
06:41:38 <Smoking_K> > searchExitWithTrail :: Maze -> Trail -> Point -> ExitPair
06:41:39 <Smoking_K> > searchExitWithTrail m t p | isInBorder m p == True = (True, (t ++ p))
06:41:39 <Smoking_K> >			    | map searchExitWithTrail m (t ++ p) (getGoodNeighbours m (t ++ p) p)
06:42:02 <Meep> you're calling map with too many arguments
06:42:41 <Smoking_K> well the thing is, searchExitWithTrail has 3...
06:42:56 <Smoking_K> so how do I say, searchExitWithTrail you take these 2, and map you take this one?
06:43:01 <Lunar^> You should use a let somewhere to make this more readable, like let t' = t ++ p
06:43:26 <Cale> Smoking_K: do you mean use parens?
06:43:26 <Meep> Smoking_K: just use brackets?
06:43:56 <Smoking_K> ahhh, hang on... I noticed a prob too....
06:44:25 <Smoking_K> I changed it to
06:44:31 <Smoking_K> >			    | True = map (searchExitWithTrail m (t ++ p)) (getGoodNeighbours m (t ++ p) p)
06:44:45 <Smoking_K> but still (t ++ p) doesn't like it ....
06:44:49 <Lunar^> @prelude otherwise
06:44:50 <lambdabot> *** "otherwise" prelude "Haskell Standard Prelude Dictionary": text follows
06:44:50 <lambdabot> otherwise
06:44:50 <lambdabot>   otherwise ::  Bool
06:44:50 <lambdabot>   otherwise    = True
06:45:07 <Smoking_K> yea, I've got another otherwise underneath
06:45:11 <Lunar^> When using guards we generally use otherwise
06:45:22 <Smoking_K> oh ok
06:45:24 <Meep> you can't have two otherwises
06:45:25 <Smoking_K> thats cool
06:46:12 <Smoking_K> well, I want it to do this, then this, then this... type iteration
06:47:09 <Smoking_K> don't worry fixed it
06:47:15 <Smoking_K> the otherwise prob
06:47:24 <Smoking_K> still not getting me out of this maze ! :(
06:47:49 <Cale> does the program typecheck yet?
06:47:57 <Smoking_K> yea...
06:48:01 <Smoking_K> it doesn't like t ++ p
06:48:32 <Cale> one is a Trail and the other a Point?
06:48:36 <Meep> that's because t and p are of different types isn't it
06:48:45 <Smoking_K> yea trail is [Point]
06:48:57 <Cale> so you want t ++ [p] perhaps
06:49:13 <Meep> or (p:t) ?
06:49:22 <Cale> that'd be more efficient
06:49:30 <Cale> (p:t) would
06:49:32 <Meep> you could always reverse the list at the end
06:50:04 <Smoking_K> hmmm, ok I'll try that
06:51:47 <Lunar^> "No instance for (Control.Monad.MonadPlus IO)" <-- urgh.. my Maybe is inside IO
06:51:52 <Smoking_K> ok, getting there, that worked... now another prob. I'll give it ago by myself first
06:52:13 <Cale> alright
06:53:35 <Smoking_K> ok, I give up
06:53:44 <Smoking_K> this is the line, I know the prob, just not how to fix it
06:53:48 <Smoking_K> >			    | map (searchExitWithTrail m (p:t)) (getGoodNeighbours m (p:t) p) == ????? = (True, tr)
06:54:08 <Lunar^> liftM2 rulez
06:54:12 <Smoking_K> since it returns its own type of ExitPair... how do I compare it?
06:55:10 <Cale> this is in searchExitWithTrail?
06:55:15 <Smoking_K> yea
06:55:24 <Smoking_K> when it finds an exit, how can I tell???
06:55:48 <Meep> type ExitPair = (Bool, Trail), is that right?
06:55:52 <Smoking_K> yea
06:56:18 <Meep> well replace the ???? with (x, y), where (x, y) is an ExitPair
06:56:32 <Meep> oh no
06:56:34 <Meep> i'm being silly
06:56:48 * Smoking_K whacks Meep for being silly.
06:56:49 <Lunar^> Smoking_K: how can you detect an exit ?
06:57:01 <Smoking_K> in the line above,
06:57:17 <Smoking_K> > searchExitWithTrail m t p | isInBorder m p == True = (True, (p:t))
06:57:30 <Smoking_K> isInBorder means that it is out of the maze
06:57:48 <Smoking_K> to it returns True and the current point put on to the current trail which is passed recursively
06:57:48 <Cale> okay, and the True represents that you're finished the maze.
06:57:52 <Smoking_K> yea
06:57:55 <Smoking_K> or else false
06:59:58 <Smoking_K> have I stumped you guys? or pissed you off with all my q's?
07:00:05 <Smoking_K> or both?
07:00:08 <Cale> okay, so in that case, you just want to pick out the True solution from the list of possibilities as your recursion starts working its way back up the tree.
07:00:24 <Smoking_K> yea, exactly
07:00:47 <Smoking_K> well, as soon as it gets a true will do
07:01:08 <Meep> probably want to use filter somewhere
07:02:02 <Cale> map (searchExitWithTrail m (p:t)) (getGoodNeighbours m (p:t) p) -- this returns a list of possible trails starting at the given point, right?
07:02:05 <Smoking_K> too filter out the true? hmmm, that could work
07:02:15 <Meep> then take the head of that list
07:02:27 <Smoking_K> Meep : yea...
07:02:57 <Smoking_K> Cale : That will call itself back adding the current point to the trail, and using a new point from the array it will receive from getGoodNeighbours
07:04:50 <Smoking_K> Meep : I would still have the same prob as here, not being able to compare it as true since it returns a ExitPair not a Bool
07:04:56 <Cale> Well, you have map in there, so it returns a list with searchExitWithTrail applied to each of the good neighbors.
07:05:11 <Smoking_K> yea, thats exactly what I want
07:05:23 <Cale> Smoking_K: getting a bool from an exitpair is not hard
07:05:31 <Meep> yeah, you just need to compare the boolean bit, not the whole thing
07:05:39 <Smoking_K> yea, how do I do that?
07:05:47 <Meep> pattern matching
07:06:08 <Meep> or jsut use fst and snd
07:06:09 <Cale> or something like (\(b, t) -> b)
07:06:11 <Smoking_K> that is a word I only learnt a few days ago
07:06:12 <Cale> yeah
07:07:23 <Smerdyakov> Smoking_K, the weekend is over! You can get help from instructors for this class!
07:07:44 <Smoking_K> hahaha, I did, I harrassed him for an hr in the arvo
07:07:59 <Smoking_K> it is tuesday.... holy crap!
07:08:03 <Meep> sounds like it's been a long day of haskell
07:08:13 <Cale> Monday here
07:08:43 <Smoking_K> yea, I had 1 exam on monday, 1 on tuesday, 2 science pracs on wednesday, 2 assignments on thursday and a exam on friday!
07:08:50 <Smoking_K> thats this week
07:09:04 <Cale> You probably need sleep.
07:09:24 <Smoking_K> yea, I'm going to go soon
07:09:29 <Smoking_K> this code has an error
07:09:31 <Smoking_K> >			    | fst(filter (searchExitWithTrail m (p:t)) (getGoodNeighbours m (p:t) p)) == True = (True, t)
07:09:49 <Cale> you dropped the map
07:10:05 <Meep> it's because filter returns a list
07:10:17 <Smoking_K> oh crap didn't mean to
07:10:53 <Smoking_K> >			    | fst(map (searchExitWithTrail m (p:t)) (getGoodNeighbours m (p:t) p)) == True = (True, t)
07:11:11 <Cale> not quite yet.
07:11:14 <Smerdyakov> That is truly, truly ugly.
07:11:24 <Meep> shhhhh, we're almost there ;)
07:11:25 <Smoking_K> Smerdyakov : I do try
07:11:36 <Smerdyakov> You're apparently mapping over a whole list just to look at the result of applying a function to the first element!
07:12:02 <Meep> yes, you could just take the first element of the list and drop the map?
07:12:06 <Smoking_K> yea, kinda... you confused me in that
07:12:18 <Smerdyakov> Smoking_K, confused how?
07:12:23 <Cale> no, he's actually searching for the first element of the list for which fst x = True
07:12:50 <Meep> so why do you need a map to do that? (i never quite got that bit, sorry)
07:13:11 <Cale> you don't necessarily
07:13:14 <Smerdyakov> I've never been a fan of guards.
07:13:21 <Smerdyakov> They make the code an uglyness.
07:13:42 <Cale> I'm not used to having anything but trivial guards.
07:14:07 <Meep> all the code so far seems to be applying fst to a list, anyway, i think that needs  fixing
07:14:29 <Smerdyakov> Thus, I suggest as usual that Smoking_K get his help from an instructor, and complain to someone at his university if the class is taught unfairly.
07:15:03 <Smoking_K> what the
07:15:17 <Smoking_K> anyway guys, I'm falling asleep... 12:15am
07:15:32 <Smoking_K> my mrs has probably already given my side of the bed away to the dog as it is
07:15:39 <Cale> okay, get some sleep. It's probably more important.
07:16:02 <Smoking_K> well of the 15% I've got 10% so I'm happy for now.. probably be back in about 20hrs
07:16:08 <Smoking_K> thanks for your help guys.
07:16:09 <Cale> okay
07:16:10 <Smoking_K> Later
07:16:18 <Meep> bye
07:16:21 <Cale> later
07:16:54 <Meep> :S that was hard work
07:16:54 <Smerdyakov> You guys don't have a problem with helping someone so directly with his homework?
07:17:10 <Meep> well, it started as just hints i think
07:17:18 <Lunar^> Marvin--: mplus does not seem to work as intendeed
07:17:58 <Smerdyakov> Meep, when someone is showing you his code and you are telling him how to fix it, that becomes unethical to me.
07:18:25 <Lunar^> @prelude Maybe
07:18:26 <lambdabot> *** "Maybe" prelude "Haskell Standard Prelude Dictionary": text follows
07:18:26 <lambdabot> Maybe
07:18:26 <lambdabot>   data Maybe a = Nothing | Just a
07:18:26 <lambdabot>   	       deriving (Eq, Ord, Read, Show)
07:18:29 <lambdabot> maybe
07:18:31 <lambdabot>   maybe ::  b -> (a -> b) -> Maybe a -> b
07:18:33 <lambdabot>   maybe n f Nothing  = n
07:18:35 <lambdabot> [3 @more lines]
07:18:42 <Lunar^> @prelude mplus
07:18:44 <lambdabot> *** "mplus" prelude "Haskell Standard Prelude Dictionary": text follows
07:18:44 <lambdabot> mplus
07:18:44 <lambdabot>   class Monad m => MonadPlus m where
07:18:45 <lambdabot>     mplus ::  m a -> m a -> m a
07:18:47 <lambdabot>   instance MonadPlus Maybe where
07:18:49 <lambdabot>     Nothing `mplus` ys = ys
07:18:51 <lambdabot>     xs      `mplus` ys = xs
07:18:53 <lambdabot>   instance MonadPlus [ ] where
07:18:55 <lambdabot> [3 @more lines]
07:19:19 <Lunar^> I want the opposite... I want my evaluation to stop just after the first Just
07:19:30 <Lunar^> dropWhile Nothing maybe ?
07:19:34 <Meep> Smerdyakov: I suppose you're right
07:19:48 <Marvin--> Lunar^: but Just x `mplus` something = Just x
07:20:04 <Marvin--> Lunar^: so if you use foldr, it *will* stop after finding the first Just 
07:20:08 <Lunar^> Marvin--: mhh...
07:20:31 <Lunar^> Marvin--: actually it doesn't :( maybe because my funs operate in a ReaderT IO
07:20:58 <Smerdyakov> Lunar^, you mean "side effects" are what you are trying to avoid?
07:21:06 <Lunar^> Marvin--: I had to liftM2 mplus
07:21:28 <Lunar^> Smerdyakov: I've got a list of function, I want to run them until the first result is found
07:21:46 <Lunar^> Smerdyakov: they're doing side effects
07:21:59 <Smerdyakov> Lunar^, yes, and folding mplus will work fine for that, UNLESS you want to avoid side effects of the functions after the first one to return Just.
07:22:20 <Lunar^> Uh.... ;'(
07:22:34 <Smerdyakov> Why "Uh"?
07:22:43 <Lunar^> Do you have another suggestion ? 
07:23:03 <Smerdyakov> Yes. Write your own function to do this. It's trivial, and yet of general usefulness.
07:23:23 <Meep> it would something like a while loop in an imperative language
07:23:30 <Meep> (i think)
07:23:31 <Smerdyakov> Meep, ?!
07:23:39 <Meep> it would sort of
07:23:42 <Smerdyakov> I would say you want more a function to pick out the first Just from a list.
07:23:44 <Smerdyakov> Not so complicated!
07:24:10 <Meep> i just meant in the sense that you keep going until some condition is true
07:24:30 <Lunar^> I though that it was the place to use MonadPlus feature
07:25:02 <Smerdyakov> Lunar^, maybe, but you can see that it's not meant for "stopping early" with fold.
07:25:26 <Smerdyakov> Lunar^, or maybe it is, and you've made some mistake elsewhere..
07:25:53 <Lunar^> possible
07:25:59 <Smerdyakov> I guess I've been typing without any knowledge of this and without thinking about it.
07:26:14 <Smerdyakov> It does look like fold_left should work there.
07:27:59 <Smerdyakov> @prelude liftM2
07:28:00 <lambdabot> *** "liftM2" prelude "Haskell Standard Prelude Dictionary": text follows
07:28:00 <lambdabot> liftM2
07:28:00 <lambdabot>   liftM2 ::  (Monad m) => (a -> b -> c) -> (m a -> m b -> m c)
07:28:00 <lambdabot>   liftM2 f          = \a b -> do { a' <- a; b' <- b; return (f a' b') }
07:28:01 <lambdabot>                                    (m a -> m b -> m c -> m d)
07:28:26 <Lunar^> Smerdyakov: I rely too much on type checking, I know
07:28:45 <Smerdyakov> Lunar^, that's not the "typing" I meant..
07:29:39 <Lunar^> Smerdyakov: I know :)
07:30:39 <Smerdyakov> I'm not sure of the semantics of the <- arrow.
07:31:11 <Lunar^> What do you mean ?
07:31:11 <Smerdyakov> For a value in an IO monad, does it force evaluation of any effectful actions, or is that only if the variable that gets the result is used?
07:31:31 <Meep> i think it's only if it's used
07:31:39 <Lunar^> true
07:31:49 <Meep> because you can use (foo <- getContents ...) to get a lazy list of a file
07:31:59 <Lunar^> Smerdyakov: thanks, using foldl made it works
07:32:11 <Smerdyakov> Lunar^, what were you using before?
07:32:19 <Lunar^> Smerdyakov: Marvin-- told me to use foldr (because of infinite list) and I just followed it
07:32:47 <Smerdyakov> Lunar^, didn't you realize that foldr folds from right to left, so it would give the first Just from the end..?
07:33:13 <Smerdyakov> Lunar^, and foldr would loop forever on an infinite list, I think.
07:33:29 <Lunar^> Smerdyakov: I think I need another cup of coffe
07:33:39 <Lunar^> It does not avoid side effect
07:33:48 <Lunar^> (after checking)
07:34:08 <Smerdyakov> The side effects of all list elements take place?
07:34:47 <Lunar^> Smerdyakov: let me see
07:35:47 <Smerdyakov> Eh, well, I need to sleep. Good luck.
08:08:06 <Marvin--> what are you talking about?  foldr1 mplus [Just 1, Just 2] -> Just 1  isn't that the desired result?
08:10:22 <Lunar^> Yes, but 
08:11:58 <Lunar^>  foldr1 (liftM2 mplus) [putStr "1" >> return (Just 1), putStr "2" >> return (Just 2)]
08:12:04 <Lunar^> This display "12"
08:12:14 <hdaume> yes.  as it should be
08:12:21 <Marvin--> different layers of monads
08:12:58 <Marvin--> you can see that "Just 2" is not evaluated in my example, by noting that   foldr1 mplus [Just 1, undefined] -> Just 1
08:13:56 <Lunar^> ok
08:14:07 <Lunar^> But unfortunately this does not work in my case
08:14:25 <Marvin--> you didn't specify what you wanted :)
08:15:40 <Smerdyakov> And now you must... pay the price!
08:16:16 <Lunar^> Marvin--: yes ;)
08:16:23 <Lunar^> Marvin--: anyway, I understand mplus better now
08:18:49 <Lunar^> @prelude join
08:18:50 <lambdabot> *** "join" prelude "Haskell Standard Prelude Dictionary": text follows
08:18:50 <lambdabot> join
08:18:50 <lambdabot>   join ::  (Monad m) => m (m a) -> m a
08:18:50 <lambdabot>   join x            = x >>= id
08:19:16 <Lunar^> Could someone explain me this one ?
08:19:34 <Smerdyakov> x is a monad that stores monads.
08:19:40 <Smerdyakov> Join grabs the inner monad out of it.
08:20:54 <Smerdyakov> Perhaps imagine that m is IO, and the input to join is a calculation of a particular IO action to take at some point in the future.
08:20:57 <Cale> Is join = mu?
08:21:39 <Smerdyakov> So join lets you take that calculation and turn it into the actual action.
08:21:57 <Lunar^> ok.. do you know an example of its use somewhere ?
08:22:10 <Smerdyakov> No. I've never seen it before, actually. :)
08:22:22 <Smerdyakov> I guess a simple example would be:
08:23:29 <Smerdyakov> join (do { s <- somethingUsingIO ; return (putStr s) })
08:24:14 <Smerdyakov> Only imagine that this IO (IO ()) was calculated earlier and you saved it until now to turn into a real IO ().
08:25:09 <Smerdyakov> Does that make sense?
08:26:42 <hdaume> join = concat for lists
08:27:05 <hdaume> join on Maybe is useful; turns Just (Just a) into Just a and anything else into Nothing
08:27:14 <hdaume> i've never found it useful for IO tho
08:27:29 <Smerdyakov> But you can craft an IO action based on the contents of a file, and then package it for repeated use elsewhere!
09:52:29 <Cale> yeah, eta = return and mu = join
09:54:28 <Cale> So join is actually part of the traditional definition of what a monad is.
15:29:16 <polli> ls
15:29:18 <polli> ek
19:53:05 <whee> finally learning monads now :\
19:53:16 <Riastradh> Yay!
19:53:25 <Riastradh> Any questions on the matter?
19:53:33 <whee> not yet
19:53:52 <whee> I found a nice tutorial on lambda that should work well
19:58:21 <Smerdyakov> Man, monads are about as complicated as counting to 6. Don't sweat it!
19:59:44 <mattam> well, counting to 6 was hard at first :)
19:59:52 <whee> still is ;)
20:06:54 <whee> so how do these arrow things compare to monads?
20:07:02 <Riastradh> They're a generalization.
20:10:49 * turtles is away: (Auto-Away after 10 mins) [BX-MsgLog On]
20:16:34 <turtles> i am starting with haskell and don't undertand how it manipulates types...
20:16:35 * turtles is back from the dead. Gone 0 hrs 5 min 46 secs
20:19:28 <turtles> somebody say something about it?
20:19:44 <whee> what's the problem?
20:21:05 <turtles> i want only a brief description of types manipulation in haskell
20:22:33 <turtles> just to start
20:22:47 <whee> I'm not clear on what you're looking for :\
20:25:08 <turtles> i am reading a book what i don't understand because i don't know what means "polymorphicly" and words like this
20:26:01 <whee> oh, hm
20:27:15 <turtles> is polymorphicly like in oo programing?
20:28:12 <whee> polymorphism is like in most other languages,  yes
20:28:23 <whee> I can't seem to find a nice general reference on those types of things
20:28:40 <whee> @type map
20:28:40 <lambdabot> map :: (a -> b) -> [a] -> [b]
20:29:20 <whee> that's an example of a simple parametric polymorphism
20:29:24 <whee> I think it's that one :)
20:30:01 <whee> it operates on any types as long as it satisfies that signature
20:30:23 <Smerdyakov> @type id 
20:30:23 <lambdabot> id :: a -> a
20:30:27 <Smerdyakov> Simpler example ;)
20:31:22 <Smerdyakov> turtles, the main polymorphism in Haskell is parametric polymorphism, where types of functions and other things have blanks you can fill in with any types of your choosing.
20:34:26 <turtles> some good introductory text about this?
20:35:01 <Smerdyakov> Haskell tutorials should be fine if your purpose is to learn Haskell.
20:36:27 <turtles> know any url ?
20:37:08 <Smerdyakov> Always start at http://www.haskell.org/
20:37:18 <Smerdyakov> For tutorials, http://www.haskell.org/learning.html
20:38:11 <turtles> tank's
20:48:48 * turtles is away: (Auto-Away after 10 mins) [BX-MsgLog On]
21:35:21 <whee> okay, finally a question on monads :)
21:36:50 <whee> I'm looking at an example of usage of a Writer, and it has some code like "do { tell blahblah ; return Nothing }"
21:37:25 <whee> now what's throwing me off is the fact that this whole function ends up evaluating to a Writer type; is it just non-obvious because of the do syntactic sugar?
21:37:49 <whee> basically, does the do notation thread this monad through the computation for you?
21:38:42 * Smerdyakov reads the question.
21:39:11 <Smerdyakov> The do notation threads the monad through, yes.
21:45:36 <Darius> @type (>>=)
21:45:37 <lambdabot> (>>=) :: Monad a => a b -> (b -> a c) -> a c
21:46:05 <Smerdyakov> Why did you just do that, Darius?
21:51:58 <Darius> Well, a better choice of type variable names would help, but if one knows how to desugar do-notation and has a basic handle on types then the why of the result type should be easy to figure out from them, well (>>) would be better especially for this instance.
