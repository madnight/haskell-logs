02:21:29 <kaol> @eval reverse [1 2 3 4 5]
02:21:30 <lambdabot> type error
02:23:44 <tez> @eval reverse [1,2,3,4,5]
02:23:45 <lambdabot> [5, 4, 3, 2, 1]
02:24:29 <kaol> of course...
02:24:46 <kaol> I got confused by another programming language
03:24:24 * Darius thinks he's finally got the right hold on the SLC.
04:49:53 * Heffalump waves
04:50:22 * ski waves too
08:11:08 <hdaume> anyone know the results of icfp?
08:14:15 <Cale> I'd be interested to know as well. It was fun to watch the teams' progress.
09:25:34 <hdaume> anyone know how to check for a file's size in perl?
09:36:43 <hdaume> nm
09:38:27 * Riastradh whacks hdaume with a large monad.
09:38:59 * Cale fires an arrow at hdaume. :)
09:39:15 * Riastradh stabs hdaume unsafely with a small comonad.
09:39:51 * hdaume executes s/arrow|monad/nothing/g
09:40:08 <hdaume> hrm...what is a conothing?
09:40:16 <Riastradh> Everything.
09:40:33 <hdaume> that's somewhat ill defined :)
09:40:43 <Cale> * Riastradh stabs hdaume unsafely with a small everything.
10:21:46 <ski> hdaume :  conothing ?  dual to what nothing ?  the Nothing in the Maybe a type ?
10:22:10 <ski> s/what/which/
10:22:56 <Cale> The philosophical nothing :)
10:23:31 <ski> like the dual to the type () (i.e. unit in SML) ?
10:23:47 <Cale> sure :)
10:24:34 <ski> have you folks been talking about comonads much of late ?
10:25:27 <ski> I just read (actually skimmed) through the paper link on it from HaWiki
10:25:49 <Cale> I'm not sure. I haven't. I'm still not sure that a system based on comonads would have to be unsafe. (in contemporary Haskell, it would, though)
10:26:23 <ski> why would it be unsafe  (or why wuold it not be unsafe ?) ?
10:27:50 <Cale> Well, since main is currently of monadic type, it seems it is presently impossible to have an OI comonad that can be used in an entirely safe manner.
10:28:29 <Cale> You'd want something like comain as an alternate way to specify the computation to be performed.
10:28:59 <ski> is there any other reason besides that (rather accidential one, IMO) ?
10:29:09 <Cale> I'm not sure.
10:29:42 <Cale> There was a lot of discussion on it on various mailing lists, iirc. I'll see if I can dig it back up.
10:30:19 <Cale> I don't feel that there should be any reason that comonadic IO should be inherently unsafe.
10:30:26 <ski> e.g. some paper by Wadler discusses various ways of interacting with the world in a pure (probably nonstrict) functional language, and he has no problem thinking of main's of different types
10:31:02 <ski> nor do I, as little as I've looked at it
10:32:25 <Cale> otoh, mixing monadic and comonadic IO seems dangerous.
10:33:15 <ski> In the papers he talks about 'codata'. Has anyone looked at the papers by Erik (Erich ?) Poll regarding data,codata,induction,coinduction,inheritance,co-..,etc ?
10:33:33 <ski> mhmm
10:33:53 <Cale> I've heard of codata from one paper that I've read on comonads.
10:34:55 <Cale> In the category theoretic sense, the dual is a pretty simple concept. If you have some category theoretic construction, you take the dual by reversing all the arrows.
10:35:00 <ski> I don't think Erik Poll has mentioned comonads, this was my first papers regarding it (actually, i have wondered if a dual could be made)
10:35:12 <ski> very fun !
10:37:49 <ski> anyway, Erik Poll's papers got me playing with a nice extension of Haskell syntax
10:38:53 <ski> one could perhaps call it 'message matching' or something similar (it is sort of dual to ordinary pattern matching on ordinary Haskell datatypes)
10:39:47 <ski> anyone care to hear (err read) about it ?
10:40:40 <Cale> sure
10:40:46 <ski> ok :)
10:41:07 <ski> say we want to define a type for infinite streams
10:41:15 <ski> (for example)
10:41:25 <Cale> okay
10:41:32 <ski> we can do this in haskell like
10:41:46 <ski> data Stream a = Cons a (Stream a)
10:42:07 <ski> and selectors/destructors/whatever :
10:42:18 <ski> head :: Stream a -> a
10:42:29 <ski> head (Cons a _) = a
10:42:33 <ski>  
10:42:44 <ski> tail :: Stream a -> Stream a
10:42:55 <ski> tail (Cons _ as) = as
10:43:05 <Cale> sure
10:43:35 <ski> and to define some streams to pass as input to these functions can e.g do :
10:43:55 <ski> ones :: Num a => Stream a
10:44:01 <ski> ones = Cons 1 ones
10:44:05 <ski>  
10:44:21 <ski> from :: Num a => a -> Stream a
10:44:35 <ski> from n = Cons n (from (n+1))
10:44:47 <ski>  
10:45:10 <ski> we can also use haskells "records", like
10:45:12 <ski>  
10:45:32 <ski> data Stream a = Cons {head :: a,tail :: Stream a}
10:45:34 <ski>  
10:45:48 <ski> now we get head and tail for free
10:45:59 <Cale> yeah
10:46:32 <ski> but for consistency we should perhaps use the field names head,tail also when constructing a stream, like
10:46:34 <ski>  
10:46:59 <ski> from n = Cons {head = n,tail = from (n+1)}
10:48:13 <ski> but haskells data declaration does really constructs an inductive/constructive datatype (aka algebraic datatype).
10:49:14 <ski> i.e. it's specific feature is the ability to have several variants of a datatype, namely those constructed with the different (possible more than one) constructors
10:49:54 <ski> but we could defined Stream as an coninductive/destructive dataype (aka coalgebraic datatype)
10:50:15 <ski> imagine :
10:50:36 <ski> codata Stream a = Head :: a
10:50:50 <ski>                 | Tail :: Stream a
10:50:53 <ski>  
10:51:02 <ski> almost the same as before
10:51:38 <ski> i think O'Haskell does something similar (though they call it record or struct or something)
10:52:33 <ski> Now, the nice idea : instead of constructing a stream like a record (like above), we do :
10:52:41 <ski> Head ones = 1
10:52:47 <ski> Tail ones = ones
10:52:48 <ski>  
10:52:54 <ski> Head (from n) = n
10:53:03 <ski> Tail (from n) = from (n+1)
10:53:04 <ski>  
10:53:36 <ski> this looks like pattern matching, but "the other way around", so to speak :)
10:54:19 <ski> (NB : Head and Tail isn't constructors, they are destructors/selectors))
10:54:30 <Cale> Yes, codata types are ADTs.
10:55:01 <ski> yes
10:55:33 <Cale> This seems like it would be really nice -- are there any plans to add it to Haskell, or reasons why it is not being added?
10:56:24 <ski> I have no idea, i saw some syntax somewhat like this in Erik Poll's paper, and *aha* !)
10:56:57 <ski> I haven't heard of any plans to consider it for adding to e.g. Haskell
10:58:00 <ski> Erik Poll's paper is the only source i have seen for this kind of thing yet (I haven't searched very much yet, though)
10:58:40 <ski> you could, of course consider small syntactical variations
10:58:49 <ski> e.g. in O'Haskell
10:59:03 <Cale> http://www.cse.ogi.edu/PacSoft/publications/phaseiiiq10papers/codata.pdf
10:59:12 <Cale> is where I first saw the concept
10:59:41 <ski> selections are written like "someStream.tail" instead of my hypothetical "Tail someStream"
11:00:15 <ski> thats the comonad paper, right ?
11:00:21 <Cale> Yes.
11:00:41 <Cale> I think that I prefer "Tail someStream" in this case. It emphasizes the fact that we're working with an ADT a bit more.
11:00:53 <ski> from would look like this in a O'Haskell like syntax :
11:01:00 <ski> (from n).Head = n
11:01:10 <ski> (from n).Tail = from (n+1)
11:01:13 <ski>  
11:01:52 <ski> (starting to look like a class (from) implementing an interface (Stream) in OO speak, no ?)
11:02:27 <Vincenz> O'Haskell: A breed of O'Caml and Haskell?
11:02:35 <ski> I personally also prefer "Tail someStream", it seems more Haskell like
11:02:40 <Cale> yes
11:03:50 <ski> Vincenz : at the moment just a syntactical extension to Haskell (i.e. no code inheritence or overriding or partial implementations (abstract classes) (i.e. yet :). )
11:03:52 <Cale> I don't really care too much for the x.y notation for object-property selection.
11:04:19 <Vincenz> ski: neat, who's it coming from?
11:05:18 <ski> Vincenz : what ? the syntax ?  Erik Poll, and me  for the moment  (I'm not associated with him. I'm only a CS student who have read some papers by him :)
11:05:42 <Cale> ski: I think he means O'Haskell.
11:05:48 * Vincenz nods
11:06:06 <Cale> O'Haskell is currently being developed at Oregon Graduate Institute and Chalmers University of Technology by Johan Nordlander, Magnus Carlsson, and Björn von Sydow.
11:06:10 <Cale> (apparently)
11:06:13 <Cale> http://www.math.chalmers.se/~nordland/ohaskell/
11:06:14 <Vincenz> yeah I just read that
11:06:17 <ski> O'Haskell is (or perhaps was ?) developed by at least Johan Nordlander , etc ,....
11:06:26 <ski> yes :)
11:07:34 <Vincenz> How far has it progressed?  What sort of concurrent model does it have?  Does this mean I should learn O'Haskell instead of Erlang?
11:07:36 <ski> (I haven't really looked into O'Haskells Reactive,etc stuff. Just noticed that they added a destructive/coalgebraic type definition (i.e. records))
11:07:41 <Cale> I do like the subtyping/supertyping that O'Haskell has.
11:08:53 <ski> Vincenz : IIRC Bjoern von Sydov (at least) is now working on a superseding (?) language called Timber (Timbre ?) 
11:09:11 <Vincenz> ?
11:09:22 <Vincenz> superceding over which language?
11:09:32 <ski> Vincenz : In a concurrency course he did a guest talk ...
11:09:34 <Cale> Timber sounds right. Superceding O'Haskell.
11:09:38 <ski> superseding O'Haskell
11:09:38 <Vincenz> Oh
11:09:52 <Vincenz> too many languages...argh
11:09:59 <Cale> heh
11:10:05 <Vincenz> I think I'll stick to learning Erlang next
11:10:06 <ski> Vincenz : ... about Timber, though I don't rememember much :(
11:10:21 <Cale> I like the variety actually. It's good to have lots of options.
11:10:45 <ski> Vincenz : Though I seem to recall that no operation in the language was blocking (including io operations !)
11:10:54 <Cale> http://www.tt.luth.se/staff/nordland/TimberCourse/ seems to have all the relevant links :)
11:11:01 <ski> thanks
11:12:48 * Vincenz sighs
11:12:50 <ski> Anyway the prefix syntax of selectors/destructors can easier be extended to multi-dispatching than the dot-notation, IMO
11:12:52 <Vincenz> And I finished studying last year
11:12:56 <Vincenz> and I never had any neat languages
11:13:01 <Vincenz> (though I did study electronics)
11:14:04 <Cale> one thing that bothers me about mathematical function notation is that it's backwards :)
11:14:16 <ski> backwards ?
11:14:23 <ski> application or abstraction ?
11:14:51 <Cale> If you have functions like f: A -> B, and g: B -> C, their compisition is g.f
11:15:13 <Vincenz> how would you do it then?
11:15:16 <Cale> or g(f(x))
11:15:19 <ski> ahh, that. i've been bothered too by that, but it seems not to be accidental
11:15:31 <Vincenz> I doubt it's possible in another way
11:15:32 <Cale> I'd have arguments come in on the left
11:15:44 <Cale> i.e. Rather than f(x), xf
11:15:52 <Vincenz> xfg?
11:15:59 <Cale> yes
11:16:12 <Cale> xfg rather than g(f(x))
11:16:26 <ski> but with pattern- matching on large arguments we might have the function name a long way to the right in a function definitions, no ?
11:16:50 <Cale> Oh, in programming, yes, that would be a concern.
11:17:10 <Cale> I think it would still work out.
11:17:14 <Vincenz> I don't see the big problem with mathematical notation, after all it has been drilled into us since first grade, so we're used to it
11:17:31 <Cale> Yeah, but I'm a mathematics student.
11:17:45 <ski> i think you can agree that the "head" of the definition should be in the beginning of a line (i.e. left for us left->right readers),  no ?
11:17:47 * Vincenz is on the lookout for a doctorate
11:18:21 <Cale> In the case of definitions, it should be first. The pattern matching bit is a good point.
11:18:53 <Cale> Usually in math, you'll see a "type" given for a function, like f: C -> C
11:18:55 <ski> 'cause the "body" might be many rows large and we don't want to search to the bottom to see what's defined. especially not for recursive definitions
11:19:08 <Cale> followed by some definition of how f works
11:19:15 <ski> yes
11:20:00 <ski> oh, rats ...
11:20:18 <Cale> So that naturally provides the context early. Also, it's uncommon to have a complicated function variable in the definition of a function.
11:20:30 <Cale> i.e. one to pattern match agains
11:20:31 <Cale> t
11:20:44 <Cale> (at least, in mathematics)
11:21:09 <ski> it's uncommon that the patterns are larger than the body also, IMO (even in programming)
11:21:35 <ski> (except perhaps for very small definitions, where it doesn't matter anyway)
11:22:40 <Cale> It makes reading things easier when you have a diagram (i.e. from category theory) and you're following a complicated function composition around.
11:23:24 <ski> Cale : i assume you mean "(x f) g" rather than "x f g" above, or do you propose that application should associate the other way
11:24:29 <ski> perhaps one could make a visual source interface so that one can actually write such functions as a category diagram ;)
11:24:30 <Cale> that should be fine. x (f g) would be the same, would it not?
11:24:37 <Vincenz> Any doctorate students here?
11:25:20 <ski> s/"x f g"/"x (f g)"/    (is this what you meant ?)
11:26:04 <ski> Cale : 'cause I don't think "(x f) g" and "x (f g)" are the same
11:26:43 <Cale> (x f) g is computed by first applying f to x, then applying g to the result.
11:27:02 <ski> Cale : though often i define (>.>) = flip (.) and use >.> instead of .
11:27:03 <Cale> x (f g) is taken by forming the composition of f and g, then applying it to x.
11:27:26 <Cale> So they are the same.
11:27:57 <ski> Cale : ah, you mean that kind of syntax. ok, but then juxtaposition doesn't unambigously mean application, no ?
11:28:28 <Cale> it means application or composition
11:28:41 <Cale> you can stick little dots in between the functions if you want
11:29:03 <ski> in a "mirrored" haskell "x (f g)" would mean : applt the function g with f as an argument, then apply the result of that, which should be a function, to x, no ?
11:29:29 <ski> I think Charity has syntax like this
11:29:45 <Cale> ah, yeah, without knowing the types of everything, it's ambiguous.
11:30:01 <Cale> Generally in math, that doesn't come up.
11:30:04 <Cale> :)
11:30:06 <ski> Also one can be lured into that Forth,Postscript,Joy also has it, but no.
11:31:17 <ski> IMSNHO much of current math syntax is ambigous and irritating
11:31:40 <Cale> it allows one to think of group/monoid properties of sets of functions more easily if those are there. I.e. if you have some group of functions, then composition and group multiplication look the same.
11:32:10 <Cale> Most current math syntax doesn't bother me so much.
11:32:30 <Cale> It's often minimalist - it leaves things out that can be implied by context.
11:33:10 <Cale> while this is irritating if you're not reading along, it's also less distracting.
11:33:14 <ski> Sometimes i wonder how the poor math students can grasp many things, regarding the bad syntax,terminology, etc
11:33:35 <Cale> Oh, it mostly makes perfect sense.
11:33:52 <Cale> (to us math students :)
11:33:54 <ski> It leaves too much out in my opinion
11:34:08 <Cale> Could you give an example of what you mean?
11:34:18 <ski> like the evil confusion between a function and a function's result
11:34:37 <ski> using y' and f' in the same section
11:34:44 <ski> when
11:34:46 <Cale> oh, that. Real math students and professors write f for a function and f(x) for the result.
11:34:48 <ski> y = f(x)
11:35:36 <ski> yes, but some idiots (IMO) use the ' (derivative) on both y and f. IMO they have to decide on at most one
11:35:44 <Cale> oh
11:35:57 <ski> and they write
11:36:16 <ski> dy/dx  and df/dx  and df(x)/dx
11:36:35 <ski> eeeviiil !  bwahahaha ;)
11:36:38 <Cale> the last two mean different things
11:37:00 <ski> i've seen all three of them
11:37:42 <ski> and then we have the cos^2 idiocy
11:38:01 <Cale> That's irritating to me. I find that most people are avoiding it these days.
11:38:13 <ski> (at the same time as f^-1 mean inverse function)
11:38:32 <Cale> f^-1 makes sense, cos^2 does not.
11:38:58 <ski> both can make sense, but not at the same time
11:39:21 <ski> f^-1 alludes to the group of invertible functions
11:39:28 <Cale> well, if you want to allow products to occur that way, you should probably indicate it in the exponent.
11:40:12 <ski> the cos^2 thing can actually make sense also, if we see cos (or whatever) as an action in an environment monad
11:40:20 <Cale> Like, I have seen f^{\otimes 2}
11:40:44 <Cale> to mean the tensor product of f with itself
11:41:04 <ski> then cos^2 should be written at "mmap (^2) cos", where mmap :: Monad m => (a -> b) -> (m a -> m b)
11:41:38 <ski> hmm, i'm not sure what you mean
11:41:47 <Cale> Do you use TeX at all?
11:41:48 <ski> is f a function or a tensor ?
11:42:06 <Cale> as in, one would get the pair (f,f)
11:42:07 <ski> haven't learned it yet :(
11:42:32 <Cale> I mean sticking a little tensor product sign up in the exponent next to the 2.
11:42:38 <ski> so (^{\otimes 2}) :: a -> (a,a) then ?
11:42:47 <Cale> sure
11:43:34 <ski> this can perhaps be reasonable.. hmm
11:43:59 <Cale> where if f: S -> S, then (f,f): S×S -> S×S
11:44:01 <ski> (a,a) is often written a * a or even a ^ 2
11:44:25 <ski> (though cartesian product usually uses an "x" like times sign)
11:44:44 <ski> hmm
11:44:44 <Cale> like ×, if the encoding works right
11:44:45 <Cale> :)
11:45:23 <ski> my font displays ? like a question mark in "(f,f): SA?S -> SA?S" and "like A?"
11:45:31 <Cale> ah
11:45:46 <Cale> I'm encoding my messages to IRC in UTF-8.
11:46:06 <Cale> you might not be using a UTF-8 irc client :)
11:46:17 <Cale> that was supposed to be S (cross) S
11:46:22 <ski> is (f,f) like bifunctor map in category theory ?
11:46:45 <Cale> I believe so.
11:47:18 <ski> like  f * g :: a * c -> b * d  -|  f :: a -> b  ,  g :: c -> d
11:47:29 <Cale> (f,f) (x,y) = (f x, f y)
11:47:37 <ski> yes, thats it
11:47:56 <ski> mm, no, shouldn't that be
11:48:05 <ski> (f,g) (x,y) = (f,x,g y)
11:48:14 <ski> s/f,x/f x/
11:48:25 <Cale> yeah
11:48:31 <Cale> I hadn't used a g.
11:48:52 <Cale> (so your statement is more general)
11:48:56 <Cale> :)
11:49:06 <Cale> We agree though.
11:49:40 <ski> i saw it as a definition of cartesian bimap though patternmatching on a value pair
11:50:03 <Cale> This sort of thing came up in my third Calculus course.
11:50:05 <ski> but logically the seconds of course entails the first
11:50:22 <ski> yes
11:50:52 <Cale> Though they didn't use the tensor product symbol, which irritated me greatly. The professor was a nice guy, but his use of notation was awful.
11:51:07 <ski> ok, i wasn't aware of these things in calculus. i haven't studied it as much yet
11:51:19 <ski> ok :(
11:51:59 <Cale> However, when I looked up the same topics on the net, the tensor product symbol in the exponent looked pretty standard.
11:52:30 <Cale> It comes up in defining multiple derivatives of maps from R^m to R^n.
11:52:34 <Cale> er...
11:52:41 <ski> is ^{\otimes 2} supposed to be an exponent containing an x sign and a 2 ?
11:52:56 <Cale> a circled x sign and a 2
11:53:11 <ski> yes, a (x) :)
11:53:21 <Cale> :)
11:53:44 <ski> also used for multiplicative conjunction in linear (and other substructural/relevent) logics :)
11:53:58 <Cale> my friend has a key with that sign on his keyboard - I think it's supposed to mean "stop" rather than "tensor product", but we joke about it anyway.
11:54:10 <ski> :)
11:54:47 <Cale> I want a space-cadet keyboard with unicode mappings.
11:55:21 <Cale> http://world.std.com/~jdostale/kbd/SpaceCadet.html
11:55:22 <ski> I'm sorry to declare that i don't know what a space-cadet is
11:55:39 <ski> tnks
11:55:56 <Cale> It was so named because it had so many keys (and hence might appear in some spacecraft)
11:56:23 <ski> reminds me a little of C64 keyboards
11:56:26 <Cale> It's basically the reason why the keybindings in emacs are so hard to use.
11:56:43 <Cale> (it's because we're missing the shifting keys that keyboard had)
11:57:01 <Cale> It had Shift, Ctrl, Meta, Super, Hyper, Top, and Greek.
11:57:15 <ski> 7 bits
11:57:19 <Cale> Yeah
11:58:06 <Cale> handy for typing any strange symbol like "cokebottle" :)
11:58:31 <ski> did it have such a symbol ?
11:58:57 <Cale> I don't think it really did, but it's been joked about.
11:59:05 <ski> kay
11:59:38 <Cale> http://www.faqs.org/docs/jargon/C/cokebottle.html
12:00:08 <ski> (The C64 had lots of graphical symbols on the front of the keys, that's why i associated with it)
12:00:14 <Cale> yeah
12:00:17 <Cale> I remember those.
12:01:14 <ski> There are still people developing for the C64, you know ?
12:01:40 <Cale> I seem to remember there being a programmable unit being used to emulate a C64.
12:01:42 <ski> There's at least two native browser it think
12:01:51 <Cale> heh
12:02:26 <Cale> I was joking around a while back that Commodore should come back and do a 64-bit architecture machine and call it the C64.
12:02:30 <ski> and of course telnet so one can command the slave (i.e. unix jar), e.g. using lynx
12:02:38 <ski> heh
12:03:05 <Cale> Nice high-end server with 64-gigs of memory. :)
12:03:08 <ski> there are some mini-unixes-sortof also (Ace,Lunix,..)
12:03:21 <ski> :)
12:04:01 <ski> and yet another OS (Geos) with a window system
12:04:29 <ski> (usable with mouse, also ram expansion, etc ..)
12:05:08 <Cale> Ah, I remember Geos.
12:05:50 <Cale> terribly hard to use with only one floppy disk drive :)
12:06:13 <ski> I grew up with C64 and Amiga. (Two older brothers was quite involved in the demo scene, if you know about it)
12:06:46 <ski> Ah, but one can easily daisy-chain four floppy drives into the system
12:06:56 <ski> (If one has that many, i.e.)
12:08:41 <Cale> yeah
12:09:12 <Cale> I wasn't involved in the demo scene, but I watched a lot of demos.
12:09:40 <ski> And intros, i presume ?
12:10:48 <ski> They in Horizon first, and later FairLight (might be more that i don't recall)
12:10:59 <ski> s/in/were in/
12:11:06 <Cale> ah
12:11:27 <ski> youv'e heard about those demo groups ? :)
12:12:01 <Cale> I might have :) I don't remember the names of the groups too well, but they sound somewhat familiar.
12:12:13 <ski> mm
12:12:53 <Cale> There's a former demoscene group called Guild that's working on a cool cross-platform space mmorpg.
12:13:06 <ski> I often play old demo music at home, and sometimes play old games and watch old demos ...
12:13:43 <Cale> Have you heard of Vendetta Test?
12:13:56 <ski> Though, iv'e never personally been involved in the demo scene. was to small for that. born in 1980
12:14:02 <ski> no, can't say
12:14:59 <Cale> That's the name of their test for the mmorpg to be. It runs on linux, mac os and windows.
12:15:11 <Cale> (and it's free to download)
12:15:34 <ski> mmorpg is massive multiplayer online role playing game, isn't it ?
12:15:38 <Cale> yeah
12:16:14 <Cale> It's not much of an RPG yet, but the next few releases will see those aspects of it start coming about.
12:16:52 <Cale> So far, it's mostly a 3D/Physics engine, some AI, and very basic gameplay elements to keep testers interested.
12:17:06 <Cale> (right now it's capture the flag)
12:17:14 <ski> ok
12:17:35 <Cale> Sort of fun to see what demoscene people are working on today :)
12:18:12 <ski> yeah, i haven't kept up to date in any way really
12:19:24 <Cale> I mostly only know about Vendetta test because I run only Linux on my machine, and there are only so many games that run on Linux :)
12:20:28 <ski> ok, i really haven't gotten around to installing linux (or *BSD or some other unix) yet :(
12:20:51 <ski> too lazy, and can't decide which distribution (to begin with ?)
12:21:17 <Cale> You probably want debian unstable (that is, the up-to-date debian)
12:21:28 <Cale> (If you're going with linux)
12:21:30 <ski> i assume i'm perhaps too perfectionistic ..
12:21:49 <ski> i have been considering debian lately
12:22:10 <ski> (considering mainly GNU issues i.e.)
12:23:50 <ski> but i don't really know yet what would suit me best. i'll guess i'll have to bite the bullet and try some first ;)
12:24:40 <ski> perhaps the diffs aren't so large (regarding linux distros, i.e.)
12:24:44 <Cale> Yeah, I've tried Slackware, and Redhat (those in the old days, mostly) and now Debian, and Debian by far seems the easiest to maintain.
12:24:56 <Cale> The differences aren't that large.
12:25:09 <Cale> It's mostly in package management and installation.
12:26:42 <ski> When I got my PC computer my brother installed 98,NT,Red Hat  but there was some problem with X not starting and i didn't know any unix yet so it temporarily scared me off ...
12:26:42 <Cale> Debian doesn't have quite as gentle an initial installation (though it's not so bad, imo) as say Mandrake, but when you have it up and running, installing new packages, and upgrading your system is mostly trivial.
12:27:43 <Cale> X should run out of the box on any modern linux distro. In the past it could be hard to get it working.
12:28:15 <ski> perhaps it was some problem with the monitor, i don't recall now ..
12:28:41 <ski> (i.e. monitor and X combination)
12:29:26 <Cale> You used to need to know your monitor's hsync/vsync and whatnot. Nowadays they tend to hide that from you, and just pick reasonable settings.
12:30:24 <Cale> If the monitor was working at all then it would be possible to get X running on it. It could just be tricky. I know a guy that got X running with a television for a display.
12:31:06 <ski> regarding monitors, i just hate it that buggy software can destroy my carefully configured monitor (i.e. size,pos,color temp.,etc ...)
12:31:50 <Cale> That's more the fault of the way that video hardware works.
12:31:57 <ski> in my uninformed opinion it should not be possible to reset the monitors config via software (at least there should be a disable option for this)
12:32:50 <Cale> well, you can't do that, really. But you can send signals at different rates to change the shape of the display.
12:32:55 <ski> (of course, also, the reset / on/off button shouldn't be trappable)
12:33:20 <ski> several programs in windows have done just that !
12:33:44 <Cale> In windows?
12:34:00 <Cale> That's interesting. I didn't know that windows exposed that.
12:34:19 <ski> usually when crashing, but sometimes when switching between fullscreen and windowed mode
12:34:43 <ski> it shouldn't be accessible to windows in the first place !
12:35:17 <Cale> It's generally necessary at this point for the various tuning parameters for the video display signal output to be accessible through software (i.e. the frequencies and timings)
12:35:59 <Cale> Seeing as you want to be able to plug in a variety of different monitors of different sizes and rates, there's not much that can be done about it.
12:36:10 <ski> you mean info flow from monitor config to window manager, right ?
12:36:46 <Cale> I mean, from display driver to video card.
12:37:30 <Cale> It's necessary that the display driver be able to change the tuning parameters of the video card to configure it to work with different devices.
12:37:45 <ski> do you mean that monitor config is stored in video card (in computer) ? i was under the impression that it was stored in the monitor..
12:38:19 <Cale> The monitor has some configuration settings, but those ones are only accessible from the monitor.
12:38:45 <ski> (by monitor config i mean (most) of those options configurable from physical buttons on the monitor)
12:38:51 <ski> noo
12:39:12 <ski> programs in windows have resetted those repeatedly !
12:39:22 <Cale> One can also change the size and shape of the screen from software by altering the tuning parameters that the video card sets.
12:39:57 <Cale> i.e. how long to wait between scans/at the end of a line
12:40:21 <ski> hmm, perhaps it really is the case that that is what happened
12:41:33 <ski> i simplistically thought that the video card just sent a digital (or perhaps analog) stream of data to the monitor, which took care of the ray times as long as data didn't arrive too slowly
12:42:36 <Cale> If you're talking about brightness/contrast/gamma, it might be the case that the software settings for these have been altered. Many video cards these days have their own colour control settings.
12:42:45 <ski> to test this, one would probably have to try switch the computer connected to the monitor of such a config reset, to see if it's in the monitor or in card the chages are made
12:42:59 <ski> yes
12:43:33 <ski> though i don't recall seeing any such software config, perhaps iv'e just not looked carfully enough
12:43:39 <Cale> There are digital displays, but they're uncommon except in high-end LCDs.
12:43:55 <Cale> and they have different connectors.
12:43:55 <ski> by digital you mean ?
12:44:18 <Cale> I mean that the pixel values are sent to the monitor, which takes care of everything else.
12:44:20 <ski> digital data feed from video card ?
12:44:24 <Cale> yeah
12:44:26 <ski> ok
12:44:44 <Cale> Normally, that's analog, and the video card controls the timing, etc.
12:45:05 <Cale> (so a misconfigured video card can result in a screenful of gibberish)
12:46:03 <ski> hmm, but i seem to recall that to config numbers on the monitor config was altered back to default numbers
12:46:16 <Cale> (It's easy to get this to happen by messing with the modelines in the X configuration file, if you don't care too much about possibly hurting your monitor.)
12:46:19 <Cale> hmm...
12:46:44 <Cale> It's possible also that your monitor has some extra communication with the software of your machine.
12:47:02 <ski> so for this theory to be true, the card must have transmitted its config to the monitor, no ? (at least if the monitor has an own monitor memory at all)
12:47:53 <Cale> I seem to remember getting some OSD software with my monitor that would hypothetically let me do the same things as the monitor's front controls if I was running windows.
12:48:19 <Cale> I don't know how that was supposed to work, but it might be something new.
12:48:34 <ski> (not sure what OSD means. open software display ??)
12:49:09 <Cale> On-Screen-Display - usually the name given to the box that the controls bring up when you mess around with them.
12:49:21 <ski> 'kay
12:50:07 <Cale> I suppose that the software in question would allow that to be a windows application, rather than the simplistic OSD that the monitor normally has.
12:50:52 <Cale> So that would indicate some means of communicating those settings.
12:51:05 <ski> mm
12:51:44 <Cale> Are your monitor's controls digital?
12:51:56 <Cale> i.e. not knobs.
12:52:22 <ski> mine is yes (means it shows numbers and a bar-panel)
12:52:31 <ski> knobs ?
12:52:33 <ski> ah
12:52:40 <ski> you mean physical knobs
12:52:42 <Cale> yeah
12:53:26 <ski> i thought of number-based versus only an approximate waxing/shrinking bar controlled by buttons
12:53:57 <Cale> I suppose it's possible that your monitor has some way of being controlled through software, but before I had this LCD display, I hadn't heard of it.
12:54:18 <ski> usually knobs have a direct "physical memory" :)  (though i've seen exceptions)
12:54:29 <ski> mm
12:55:04 <Cale> and stranger still that a crashing application would interface with it.
12:56:00 <ski> perhaps the bad application would, via the video card, sent some signal (e.g. reset all or something) to the monitor ..
12:57:09 <Cale> hm, possibly. For some reason I doubt it, but I suppose that it's possible. Perhaps the monitor itself sets itself to default settings if it's getting a bad signal.
12:57:26 <Cale> I don't know why it would do that either.
12:57:49 <ski> hmmm
12:59:50 <ski> to bad i forgot a floppy disk with a little (hmm 46 k) HTML file i've written to clarify (to myself) the duality between algebraic and coalgebraic datatype (using the abovementioned message-matching(/dispatching?)
13:00:38 <ski> otherwise i could have put it on the web someplace, if you were interested i.e.
13:00:51 <Cale> Yeah, that would be interesting.
13:01:39 <ski> hmm, but this stupid sun machine they have switched to at uni doesn't have a floppy (aka disk) drive, rats
13:01:59 <Cale> I'm usually in this channel idling - if you're able to get it at some point, you might /msg me.
13:02:08 <ski> perhaps i can remember to bring it somehow, another day
13:02:11 <ski> yes
13:02:32 <Cale> Or simply say my name, which will alert me :)
13:03:08 <Zeenix> hi
13:03:13 <Cale> hello
13:03:21 <ski> mind you, most of that HTML file is different variants of code examples, with changes pedagogically highlighted
13:03:28 <ski> hello Zeenix
13:03:33 * Zeenix just got the haskell bug from its intro..
13:04:18 <Cale> are you looking for a tutorial?
13:04:22 <ski> Cale : so there isn't very much normal text yet..  (i have very many color and font tags in the html source right now)
13:04:30 <Cale> ah
13:04:45 <Zeenix> Cale: me? no, just got its tutorial's link from the channel's topic
13:05:09 <ski> Cale : but it's quite symmetric and nice even now, methinks
13:05:20 <Cale> there are a number of good tutorials around. I seem to remember hdaume having written a good one.
13:06:00 <ski> Cale : (about name alert) my brother has some such feature in his irc client, i'm still using a console based one called irc ;(
13:06:59 <Cale> I use X-Chat - it's quite nice, and runs on any platform. It also has the bonus of UTF-8 support so that I can read and send Japanese characters (I'm learning Japanese).
13:07:04 <Zeenix> i am a C programmer/lover and therefore am ignorant of functional programming langs. like Haskell, so any advices anyone?
13:07:18 <ski> is there some tutorial link in the topic ? missed that
13:07:23 <Cale> http://www.isi.edu/~hdaume/htut/
13:07:36 <Cale> that tutorial is pretty good, iirc.
13:07:59 <Cale> The important thing to do if you're a C programmer, is forget how to program temporarily.
13:08:16 <Cale> :D
13:08:33 <Zeenix> ski: no i didnt but just wanted to listen to live advices :)
13:08:48 <Zeenix> Cale: i'll remember that
13:09:12 <Cale> It's rather different, and if you try to do things the same way, you'll often miss the easy way.
13:09:45 <Zeenix> Cale: is it simillar to when you are writing gramers for parser generaters like bison?
13:10:08 <ski> hmm
13:10:39 <ski> more different at many times i think
13:10:43 <Cale> That's a rather abstract question. It's not directly *like* that, but it's very different.
13:11:10 <Cale> In the way that writing a grammar for bison is different from coding in C.
13:12:24 <ski> but writing a grammar/parser with a combinator library in a functional programming language *can* be at least somewhat similar to writing a grammar in bison, no ?
13:12:34 <Cale> Oh, for sure.
13:12:35 <Cale> :)
13:12:35 <Zeenix> ok, and how about rule-based programming we do for AI? in C its quite possible but very hard to do, how about when its done in Haskell?
13:13:37 <Cale> hmm...
13:13:49 <Cale> These are tricky questions :)
13:14:22 <Cale> I think probably they're more easily answered by reading a tutorial and following along, and writing a few small programs.
13:14:33 <ski> i presume that is at least somewhat simpler in logic programming that in functional programming. but it should probably be simpler in, say Haskell, than in C   (of course, i don't really know, 'cause i haven't actually coded such AI things myself)
13:15:12 <Cale> I do know that there are AI people using Haskell.
13:15:43 <Zeenix> thanks guys, if you people remain so helpfull than learning Haskell will surelly pay-off :)
13:15:44 <ski> Zeenix : do you mayhaps have any direct questions (i.e. how to do in some specific problem) ?
13:16:36 <Zeenix> ski: no, i just came to know of it an hour ago :( and am reading its intro and the tutorial..
13:17:12 <Zeenix> ski: but dont worry, i'll have some prety soon :)
13:17:31 <ski> 'kay :) good luck and feel free to come here and ask/discuss whenever you wonder something :)
13:17:44 <ski> sure
13:18:30 <Cale> Yeah, the tutorial link I just posted is probably my favourite tutorial.
13:18:51 <Zeenix> Cale: ok, i'll dig into that too
13:18:55 <ski> i don't think i've seen it before
13:19:06 <Cale> It's hdaume's
13:19:25 <Cale> He's not here right now, but he's often on this channel.
13:20:20 * Zeenix just added it to his favourites..
13:20:34 <ski> yes, but i haven't actually looked a lot at so many haskell tutorials. i got started using Thompsons book and had difficulty to stop reading it :)
13:26:01 * ski reading a little in hdaume's tutorial
13:41:21 <ski> Hi stepcut
13:49:30 * ski has to get something to drink
13:58:29 * ski : ahh
14:36:17 <stepcut> hello, ski
14:36:26 <ski> hello
14:36:38 <stepcut> did you have a nice drink?
14:36:48 <ski> yes :)
14:37:32 <ski> chocolate and yoghurt (though separately, not mixed :)
14:47:19 <Zeenix> ski: afaik none of them could be drunk :)
14:50:23 <ski> Zeenix : ?  .. heh .. chocolate milk (or whatever it's called)  and  Yoggi (a drink-yoghurt, no ?) ..
14:50:37 <ski> :)
14:51:11 <Zeenix> ski: yeah i got jelous of you and brought myself some grapes :)
14:51:31 <ski> Zeenix : nice
14:52:29 <Zeenix> ski: i think jelousy is just like knife, its negetive use makes it negetive. agree?
14:52:53 <ski> Zeenix : Have you gotten anywhere into the tutorial yet ?  or perhaps spering it for a later time ?  busy installing hugs/ghc/nhc ?
14:53:29 <ski> Zeenix : umm, not sure what you mean. care to elaborate ?  negative use ?
14:54:16 <Zeenix> ski: not got into the tutorial yet but looking into many other things like the intro, faqs, other things i am searching out in google like "AI in Haskell" etc
14:55:33 <Zeenix> ski: a knife could be used to both cut vegetables and cuting someone's throat
14:56:15 <ski> Zeenix : you are aware there is a haskell wiki, yes ?   at : http://www.haskell.org/hawiki
14:56:16 <Zeenix> ski: former is the 'positive' use and later is the 'negetive', so the knife itself is not 'negetive'
14:56:47 <Zeenix> ski: thanks, that would be another good source of help
14:57:53 <ski> Zeenix : you mean it is neutral, in itself. like they say knowledge is  (just think about The Tree Of The Knowledge Of Good And Evil :)
14:59:11 <Zeenix> ski: yeah
15:05:42 <Zeenix> ski: what you use for creating GUI in Haskell? Gtk+?
15:06:51 <ski> Zeenix : There are some different GUI libraries (both highlevel and lowlevel) 
15:07:23 <ski> Zeenix : Unfortunately there isn't (yet, at least) a standard one
15:08:16 <ski> Zeenix : I think there is a library which is more or less a haskell binding of Tk (~= same as Gtk+ ??)
15:08:34 <ski> Zeenix : Hugs has a GUI library
15:08:45 * stepcut is bleeding egde today
15:09:22 <Zeenix> ski: no tk is not same as GTK+
15:09:25 <ski> Zeenix : there is one called the "Fudget"s library that is implemented fully (or mostly ?) in haskel
15:09:43 <ski> s/haskel/haskell/
15:10:31 <ski> Zeenix : http://www.haskell.org/libraries/#guigs lists them better than me :)
15:10:58 <Zeenix> well if merging C language stuff with Haskell turns out to be easy then anything not yet supported wont be a big problem
15:11:22 <ski> Zeenix : "Gtk2HS: A Haskell binding for Gtk Version 2" and "Gtk+HS: a Haskell binding for GTK+" perhaps match your likening ?
15:12:08 * stepcut would like a haskell binding to Qt, but no one has implemented the FFI for C++ yet (as far as i know)
15:12:53 <ski> Zeenix : i've heard that Haskells FFI is better/easier/whatever than SML's (and O'Caml's ??)
15:13:36 <whee> O'Caml's FFI is pretty painless, don't know about SML
15:13:54 <ski> whee : 'kay
15:14:00 <stepcut> O'Camls seemed easier to used, but perhaps less powerful?
15:14:22 <stepcut> Clean seems to have a really nice FFI, but I have only used it a tiny bit
15:15:02 <whee> stepcut: http://caml.inria.fr/ocaml/htmlman/manual032.html could read and compare :)
15:16:47 <stepcut> ah yes, O'Caml makes you do all the marshalling in C code, whereas Haskell lets you do it in Haskell if you want
15:17:26 <reffie> ffi?
15:18:06 <stepcut> foreign function interface -- ie. calling C (or C++, etc) code from Haskell or O'Caml or something like that
15:18:09 <ski> which can be easier/nicer, even if it can feel weird to program low-level things like malloc in haskell
15:18:38 <ski> or the other way around !  C can call Haskell !
15:18:45 <stepcut> that too
15:18:46 <whee> couldn't you just implement the marshal routines to go back to ocaml code?
15:19:30 <stepcut> ?
15:20:02 <whee> well, you wouldn't have to write the marshalling in C, just have the C serialize/deserialize/* functions call ocaml code that does the work
15:20:46 <stepcut> not sure
15:21:14 <ski> i suppose that'll work, if O'Camls FFI supports C to O'Caml calls
15:21:25 <whee> ski: it does, of course
15:22:14 <stepcut> yes, but if you need to lay things out in a specific way in RAM, that could be hard with ocaml
15:22:21 <stepcut> and play with pointers
15:22:26 <ski> whee : what ?  (what are you responding to ? my statement about c->ocaml ?)
15:22:39 <whee> the last statement you wrote :P
15:23:51 <ski> whee : 'kay :D
15:24:11 <stepcut> someday, when i have time to burn, I am going to write a program in haskell and ocaml (linked via FFI)
15:25:10 <ski> does ocaml have a type of c-pointers, like Ptr a (or old Addr) in Haskells FFI and marshall lib
15:26:52 <whee> I don't think it has a wrapper library around C pointers; it has a reference type which is mostly the same thing as a C-style pointer, though
15:27:06 <ski> like haskells FFI function IIRC  :  new :: Storable a => a -> Ptr a
15:27:19 <ski> mhmm
15:27:51 <stepcut> the pointer stuff is what makes haskells FFI hard to understand. withForeignPtr and stuff
15:28:02 <stepcut> and alloca vs malloc
15:28:28 <whee> those are things I don't think I'd want to do in haskell; it'd probably be easier to just do that in C
15:28:43 <ski> with Ptr a in haskell we have the usual evil functions adding and subtracting an offset to a pointer and taking the difference of two pointers .. :/
15:29:34 <Zeenix> thanks everyone for helping me specially ski, bye
15:30:00 <stepcut> whee: the pointers can be useful though, because C does not have tuples.
15:30:53 <stepcut> so if you want your C function to return an array and the length of the array, you need a way to return two values
15:30:56 <whee> stepcut: yes, but with ocaml's ffi you can use ocaml tuples within C :)
15:31:17 <stepcut> true
15:32:19 <ski> Koen Claessen (who showed me some marshalling code in haskell) seemed to think that even if the marshalling code looks like lowlevel memory-management imperative code in haskell syntax
15:32:59 <ski> we still have the good things of haskell helping us more, than C
15:33:21 <ski> such as type inference, polymorphism, higher-orderness, etc ...
15:33:40 <whee> yes, but when the code in question is memory management, I don't think any of that is as useful as it could be
15:34:03 <ski> mayhaps ..
15:34:24 <whee> if you're writing haskell code that looks a lot like typical imperative C code, then that could be telling you something
15:35:08 <stepcut> I think you can do all the marshalling in C if you want.
15:38:12 <ski> some example and code (though not the one i was looking for) is at http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/lec-20020924-4-Tue.html and http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/Lab2/Chunk.hs
15:41:32 <ski> The one thing i both miss much in e.g. C and which wouldn't require a big change in semantics and pragmatics in tuples (and patternmatching for tuples, or perhaps a tuple-lvalue)
15:41:43 <ski> s/in tuples/is tuples/
15:41:56 <whee> ski: ever used cyclone?
15:42:12 <ski> or at least lightweight multiple return values
15:42:55 <ski> whee : no, only read a little about it.  doesn't C-- has tuples BTW (or at least multi-retvals) ?
15:43:28 <whee> cyclone should interface just as easily with languages with a C FFI, so it might be worth spending more time with
15:44:16 <ski> I've even managed to convince my younger brother (who right now only programs in C, and seems allergic to all things functional, perhaps because i've been talking much about it) ...
15:44:38 <ski> ... that tuples would be a very good thing to have in e.g. C
15:45:12 <whee> well, you could emulate tuples with some structs I suppose
15:45:17 <stepcut> yeah, C should have tuples, first-class functions, automatic garbage collection and hindley-milner type-checking. Then it would rock
15:45:26 <ski> very irritating
15:45:34 <whee> stepcut: that's what cyclone is for (mostly) :)
15:45:41 <Riastradh> stepcut...why not just use Haskell or ML?
15:46:04 <whee> I don't think any of that should be added to C, though
15:46:13 <whee> C is better without those features as a system language
15:46:32 <Riastradh> whee, not even multiple return values/tuples?
15:47:09 <whee> Riastradh: I think it's a lot easier to do things in the style of tuples with the latest c99 standard
15:47:39 <ski> automatic garbage collection and closures would change much of C's spirit/pragmatics/... as a rather lowlevel imperative language. but tuples and perhaps some for of type-inferencing can more easily be imagined to fit well with the existing language constructs
15:49:06 <ski> whee : i'm not sure of what extensions C99 has over C89/C90 (or was the previous C94 ?)
15:49:12 <Riastradh> The type system would make C typesafe, and no one will ever consider accepting _that_, because of all those [my tongue is poking a hole through my cheek now] incredibly cool tricks you can do with type unsafety!
15:49:27 <ski> whee : e.g. i've no idea what 'restrict' does
15:49:47 <whee> I think C as a language should have no safety; it should be a higher level assembly
15:51:05 <ski> I would like parametric polymorphism (at least for pointers) and existensial type quantification (to emulate closures correctly, using structs/tuples)
15:51:11 <ski> in C
15:53:51 <ski> whee : have you heard of TAL (typed assembly language, e.g. : http://www.cs.cornell.edu/talc/papers.html) where the assembly level is statically typed (and code addresses is of course first-order (i mean non-closure) continuations) ?
15:57:52 <whee> ski: I would hate that :)
15:58:11 <ski> thought so ;)
15:58:17 <whee> when I was doing 68k asm coding, the last thing I'd want is a typing system getting in my way
15:59:35 <ski> and 68k asm is considered by many as quite readable for an assembler
16:00:03 <Riastradh> PDP-10 or something assembly language had anonymous subroutines...
16:02:23 <ski> I assume that in the best of all worlds, C (or some language holding a similar position) would of course include tuples,polymorphism,existensials,perhaps continuations  but would probably still have an unsafe loophole in the type-system, it's just that we can refrain from using it more often ;)
16:03:11 <ski> Riastradh : anonymous subroutines ?  do you perhaps mean locally scoped labels ??
16:03:31 <Riastradh> No, I mean anonymous subroutines.
16:03:42 <Riastradh> I meant what I said.
16:03:45 <ski> like how ?  me not understand
16:04:12 <Riastradh> It had a syntax for creating code data which could be stored in memory.
16:04:22 <Riastradh> For conveniently creating code data, rather.
16:04:41 <ski> RTCG (run-time code generation) ??
16:06:20 <whee> ski: I think you should try cyclone :)
16:07:20 <whee> it supports everything you said, except maybe not continuations
16:07:25 <ski> whee : probably, when i think i have time :)
16:10:07 <ski> whee : i have though looked a little at C-- which tries to be what C was said to be by some from the start, a portable assembler. useful e.g. for producing as output for higher-level languages, to implement their features, not as an application language in itself..
16:15:10 <ski> (IIRC C-- has (lowlevel, i.e. non-closure) continuations (probably not infinite extent, though).  But i should probably have a look at Cyclone sometime ..)
16:15:39 <whee> cyclone  is a lot like "C meets O'Caml", which is why I like it
16:17:07 <stepcut> personally I am looking for "Befunge meets Perl"
16:17:39 <ski> heh
16:17:48 <mattam> ouch
16:18:08 <whee> stepcut: I think that's perl already :)
16:18:17 <stepcut> whee: exactly ;)
16:19:49 <mattam> i tried learning Perl last week and found there's nothing to learn. I like most Perl Hacker's humour and some designs though :)
16:22:18 <stepcut> that'll teach me to diss perl ....
16:22:23 <whee> mattam: that's my problem with many of the languages out there; there's no new concepts to learn, it's just a matter of learning the syntax and what libraries are available
16:22:57 <ski> boooring (Baldurs gate quote)
16:23:11 <ski> :)
16:24:07 <stepcut> Someday I will learn prolog
16:24:16 <mattam> well, perl's particular syntax (for variables, indirections...) has to be 'learned' the hard way, otherwise it's impossible to code. Seems it is a language feature (linguists...)
16:25:06 <ski> stepcut : Prolog is cool. but IMO Mercury,LambdaProlog,Oz is cooler
16:26:17 <mattam> that made it particularly different from other languages
16:26:31 <mattam> make even
16:26:44 <ski> ?
16:27:09 <stepcut> well, by prolog, I really mean 'some logical style programming language'
16:27:48 <ski> 'kay thats 'nother thing for me..
16:28:08 <mattam> ski: i finished my phrase and corrected a grammatical error
16:31:15 <ski> mattam : hmm (not sure i understood completely, but what the heck)
23:30:58 <Riastradh> Is anyone here familiar with the SHIFT and RESET operators?
23:37:43 <dennisb> Riastradh: in haskell?
23:37:57 <dennisb> nope, never heard of it
23:38:01 <Riastradh> In any language.
23:38:11 <Riastradh> They're mentioned on some HaWiki page, but only in brief.
23:38:31 <Riastradh> (which is not where I first heard about them, though)
23:39:13 <Riastradh> Actually, can anyone just tell me, in the context of 'reflect' being the unsafe monadic 'run' operation, what 'reify' means?
23:43:04 <kkhawi> ICFP 2003: What are the results?
23:43:25 <Riastradh> Some guy claims he won with C++.  That's all I've heard.
23:43:29 <whee> kkhawi: I don't think contest results are that widespread yet
23:43:34 <whee> that's what I've heard, as well
23:43:42 <kkhawi> it was due last night
23:45:14 <kkhawi> how about 2nd and 3rd places?
23:48:09 <whee> kkhawi: http://tro.dyndns.org/icfp/viewtopic.php?t=32
23:49:22 <kkhawi> whee: thanks 
23:49:31 <kkhawi> I know Hudson would do some damage
23:49:36 <kkhawi> knew
