01:14:41 <demoncrat>  /j #lisp
01:14:45 <demoncrat> oops
01:14:52 <d33p> burn him!
01:15:25 <demoncrat> wait, you're supposed to check if witches float first
01:15:59 <d33p> uh.. 
01:16:09 <d33p> i missed that memo
01:17:00 <demoncrat> http://thecave.virtualave.net/TheWitchyCavern/mp-holy.html
02:54:51 <scharob> .
04:46:16 * shapr boings
04:46:20 <shapr> goood morning #haskell!
04:46:29 <Igloo> Hey diddly ho  :-)
04:46:48 <shapr> wassup?
04:47:00 <Igloo> ghc6_6.0.1-2
04:47:06 <shapr> yay
04:47:19 * shapr debup
04:48:00 * Igloo is just uploading to HE
04:48:13 <shapr> regular new ghc debs is extra motivation for me to make debs out of HToolkit
04:49:30 <Igloo> Well, I hope not to have to make any more debs until 6.2 except for porting reasons
04:49:41 <Heffalump> there won't be a 6.0.2?
04:49:56 <Igloo> Not unless something goes wrong
04:50:05 * Heffalump would like HToolkit debs, it's currently an unsightly turd over /usr/local
04:50:08 <shapr> truly
04:50:09 <Heffalump> whenish will 6.2 be, then?
04:50:17 <Igloo> Couple of months I think SM said
04:50:19 <Heffalump> I really should have used stow.
04:50:38 <shapr> I really should have made a HE-deb
04:51:06 <Heffalump> what will 6.2 have, apart from arrows syntax?
04:51:12 * andersca bounces
04:51:28 * andersca is playing beneath a steel sky
04:52:08 <Igloo> Ermm, it'll have the renamed TH constructors
04:52:18 * Igloo can't remember anything else OTTOMH
04:54:57 <shapr> SPJ was redoing something large wasn't he?
04:55:08 <shapr> though I've forgotten what
04:58:47 <Heffalump> eval/enter v push/apply ? if so that was in 6.0
04:59:08 <Heffalump> oh, and Umut Acar was doing extensible records stuff
04:59:22 <Heffalump> SPJ is going to discuss that at HW, IIRC
04:59:46 <shapr> it would allow HaskellDB to be the standard DB-API
05:01:15 <Heffalump> they won't have the full power of TReX
05:05:26 <shapr> I'm impressed with Umut Acar, have you seen his rock climbing pics?
05:05:59 <Heffalump> yes :-)
05:06:05 <shapr> wow
05:08:36 <Heffalump> wow?
05:08:55 <shapr> hanging from the ceiling by his fingers
05:09:29 <Heffalump> errm, which one?
05:10:14 <shapr> http://www-2.cs.cmu.edu/~umut/photos/climbing/umut-bwm.jpg
05:10:26 <Heffalump> I think you'll find that photo is sideways :-)
05:10:34 <shapr> doh
05:10:58 <shapr> you're right, the trees in the background are growing to the left.
05:11:26 <Heffalump> the rope is also going to the left, and his feet are miraculously holding on to the "ceiling" ;-)
05:12:31 <shapr> this page even says that --> http://www-2.cs.cmu.edu/~umut/photos/climbing/
05:24:06 <shapr> Igloo: hey, I got email from the HasChorus author, he says 1.2.1 will be out in a few days once his website is moved. I'm trying to persuade him to send me the package before that.
05:24:31 <Igloo> Cool
05:24:41 <Igloo> I still haven't really looked at it to see what it does
05:24:57 <shapr> it's mostly higher level Haskore stuff
05:25:24 <shapr> like HasDrums lets you assign different beats to each sixteenth note in a drum line very easily
05:27:40 <shapr> I was just playing with debianizing lambdabot, and I realized that recompiling to change settings isn't very debian-friendly.
05:31:28 <Igloo> Yeah, compile-time settings bad. Just read and show will give you an easy way to switch to a config file, though
05:31:53 <Igloo> Especially as IO is all over the place anyway
05:32:28 <MakeMyDay> I think I am gonna overload from all the haskell I have been learning
05:32:50 <shapr> MakeMyDay: feel the your brain muscle FLEX
05:33:07 <MakeMyDay> heh
05:33:22 <MakeMyDay> as long as it doesnt get injured
05:33:37 <MakeMyDay> learning a programming language in 3 days is not agood idea
05:33:41 <shapr> I disagree.
05:33:54 <phubuh> learning haskell flexed my brain muscle into a klein bottle!
05:34:08 <shapr> I think 3 days to learn a new language is a relaxing weekend
05:34:35 <MakeMyDay> how about learning your first functional language?
05:34:40 <MakeMyDay> and then take an exam on it?
05:35:16 <shapr> sounds perfect
05:35:25 <shapr> then you get to see if you really learned it in those three days.
05:35:31 <MakeMyDay> keke
05:35:39 <MakeMyDay> I guess we will see
05:35:51 <shapr> the disadvantage of the 3 day learning blitz is that you rarely get to use that language in a project immediately afterwards.
05:36:05 <shapr> so you have it right
05:37:03 <MakeMyDay> bah back to learning I guess
05:47:01 <shapr> any clueful gpg people here?
05:47:13 <shapr> I'm trying to convince gpg --clearsign to use a certain key
05:47:41 <shapr> I expected gpg --edit-key <keyIwanttouse> and setting that key to primary would work
05:50:33 <shapr> aha
05:52:40 <Heffalump> isn't all you're doing there setting a particular UID in that key to primary?
05:53:05 <shapr> darcs calls "gpg --clearsign" I was hoping to change which UID it uses.
05:53:26 <shapr> gpg docs say you need to use --default-key
05:53:27 <Heffalump> --default-key ?
05:53:28 <Heffalump> yes.
05:53:46 <shapr> darcs doesn't seem to have an option for that.
05:53:59 <Igloo> You can put it in the config IIRC
05:54:08 * shapr looks
05:54:21 <shapr> aha
05:54:26 <shapr> thanks
05:54:32 <Igloo> "default-key n" in .gnupg/options
06:18:09 <shapr> yay! it WORKED
06:18:24 <Igloo> Cool  :-)
06:18:44 <shapr> finally, a working darcs-repo
06:20:14 <shapr> so, anyone else want access to the darcs repo?
06:21:19 <shapr> it's a lot easier to do commit access for a darcs repo
06:24:18 <sjj> darcs?
06:24:33 <shapr> @fact darcs
06:24:35 <lambdabot> http://www.abridgegame.org/darcs/
06:25:06 <sjj> heh, anoter RCS
06:25:09 <sjj> s/anoter/another/
06:25:16 <shapr> @fact darcs, David's Advanced Revision Control System, yet another replacement for CVS, but this time with some very interesting theory behind it
06:25:17 <lambdabot> set darcs, to David\'s Advanced Revision Control System, yet another replacement for CVS, but this time with some very interesting theory behind it
06:25:24 <sjj> many people are pointing me towards svn these days..
06:25:46 <shapr> sjj: darcs is available as debs, and it's written in Haskell, so I figure it's worth trying out.
06:25:53 * sjj nods
06:26:13 <shapr> it's much more distributed/decentralized than CVS
06:26:49 <sjj> hrm, does it use HTTP?
06:26:52 <shapr> you can make your local repo readable via webserver, and anyone can pull changes that you've made into their own repo
06:27:30 <sjj> hrm, how's that different than cvs though?
06:27:34 <shapr> seems to use HTTP for cvs co/ cvs up
06:27:45 <sjj> (apart from the webserver stuff)
06:28:00 <shapr> local cvs commit is just "darcs record"
06:28:04 <shapr> remote cvs commit uses email
06:28:11 <shapr> and gpg
06:28:30 <shapr> http://www.scannedinavian.org/cgi-bin/darcs
06:28:30 <sjj> remote darcs commit?
06:29:13 <shapr> sure, you can check out the hlibs repo from ScannedInAvian.org, and then make changes locally
06:29:37 <shapr> when you want to commit those changes, (assuming you've sent me your public gpg key) you use darcs push
06:30:34 <sjj> looks interesting, but can it do anything better than CVS or svn?
06:30:58 <sjj> the fact that it's written in haskell is cool though
06:31:52 <shapr> I think it can do partial application of patches better than anything else
06:31:56 <shapr> I may be wrong, I haven't read much about SVN
06:32:04 * sjj nods
06:32:59 <shapr> zooko made a darcs/cvs/svn/arch/etc comparison table
06:33:02 <shapr> lemme see if I can find it.
06:33:45 <sjj> cool
06:33:46 <shapr> http://zooko.com/revision_control_quick_ref.html
06:36:32 <sjj> zow, Bram is writing a RCS? cool
06:36:41 <shapr> he has a link to darcs-users mail that shows one of darcs unique features
06:37:02 <shapr> personally, I think darcs could be extended to do in-repo refactoring, and that's what interests me most.
06:37:21 <shapr> that's one feature needed for open source Intentional Programming
06:37:24 <sjj> hrm, in-repo refactoring?
06:37:39 <shapr> right now you can't track source across refactorings in any source control system
06:38:15 <shapr> actually, GemStone/Smalltalk may do that, but it's not cheap
06:38:41 <sjj> hrm, I don't really get what you mean, how's that different from branches?
06:39:33 <shapr> if part of twisted.web gets refactored into twisted.internet, there's no way you can track it back with CVS
06:39:43 <sjj> oh right
06:39:49 <sjj> apart from saying 'moved from X' in the commit message ;)
06:39:51 <shapr> right
06:40:02 <MMD|Study> data Function = Function + Function 
06:40:08 <sjj> or you could move the .v file ;)
06:40:14 <MMD|Study> would that work?
06:40:19 <sjj> er
06:40:20 <sjj> ,v
06:40:42 <shapr> MMD|Study: I've never seen + used in a datatype declaration
06:41:19 <Igloo> data Function = Function :+ Function would work
06:41:29 <MMD|Study> data Function = Function :+: Function 
06:41:34 <sjj> I don't think cvs really has a notion of the directory structure, so you can move the data files, but that is only really feasible if you're the only one working on the project
06:41:36 <MMD|Study> god damn my prof
06:42:51 <MMD|Study> he could be in here thinking about it
06:42:52 <MMD|Study> :o
06:42:58 <sjj> shapr: it'd be a nifty thing to have though
06:43:02 <shapr> it would
06:43:33 <sjj> I had to do some refactoring of a project here the other day, which involved deleting and re-adding
06:43:42 <shapr> darcs has a really simple theory behind it, I think file move patches would work also
07:21:23 <elmex> :((
07:21:24 <elmex> ghc-6.0: panic! (the `impossible' happened, GHC version 6.0):
07:21:24 <elmex>         coreSyn/CoreUtils.lhs:1188: Non-exhaustive patterns in function isCrossDllArg
07:21:34 <Heffalump> you broke it!
07:21:38 <Heffalump> what were you doing?
07:21:38 <elmex> i??
07:21:45 <elmex> just playing with Parsec
07:21:50 <Heffalump> well, clearly, it can't possibly have been the author's fault
07:21:56 * Heffalump suggests you try 6.0.1
07:22:02 <elmex> ok
07:22:30 <elmex> 12mb,here we go
07:22:40 <elmex> (i'm not going to recompile it AGAIN)
07:25:52 <elmex> Heffalump: 6.0.1 seems to work
07:28:25 * Darius grins evil while petting unsafeInterleaveIO
07:54:08 <shapr> hey, is a design-by-contract monad possible?
07:54:42 <shapr> something that could constrain an Int to be within a range of values for example?
07:55:13 <Heffalump> why a monad?
07:55:18 <Igloo> Not statically
07:55:23 <shapr> is there an easier way to do it?
07:55:43 <Heffalump> well, you could make a new abstract datatype
07:55:50 <shapr> I'd like to be able to declare foo :: Int but also say that foo can't be less than zero, or more than ten
07:58:30 <shapr> Eiffel has Design By Contract
07:58:47 <Darius> cool.  I have half of (dribble ...)
07:58:56 <shapr> Darius: what does dribble do?
07:59:23 <Igloo> I'm sure it's undecidable at compile time
07:59:31 <Darius> It's a CL command to dump your interactive session to a file.
07:59:34 <shapr> I wouldn't mind if it happened at runtime
07:59:48 <Igloo> Well you can do that with an abs datatype and smart constructor like Heff said
07:59:49 <shapr> Darius: neat!
08:00:57 * Heffalump no comprende
08:03:09 <shapr> ?
08:03:22 <Heffalump> what Darius means
08:03:54 <Igloo> Saving definitions and command line history, no?
08:04:14 <shapr> and possibly runtime loading them, yes?
08:04:14 <Heffalump> and being able to reload them again after?
08:06:30 <Darius> *is confused* If you are talking about my dribble command then you could replay the file with :def replay readFile
08:06:33 <shapr> I would use a DbC monad, because monads are sort of ways of overloading a function call, so I could check the constraints every call
08:08:45 <shapr> is that a sensible way to do DbC ?
08:10:02 <Heffalump> you're misunderstanding what a monad is
08:10:14 <shapr> ok
08:10:29 * Riastradh thinks arrows would be better for that sort of thing.
08:10:50 <Heffalump> possibly, but I'm not really convinced
08:10:59 <Heffalump> I suppose they would allow you to do some static analysis.
08:11:09 <Heffalump> And you could enforce stuff in the pure combinator
08:11:26 <Darius> Why do you need to do static analysis to check an assertion each step?
08:11:46 <Heffalump> you don't, but it might improve performance
08:11:51 <shapr> Eiffel checks at runtime
08:13:04 <shapr> I don't think you could do static analysis for "assert (foo :: Int) elem [0..10]"
08:13:45 <Heffalump> you clearly could for that :-)
08:14:14 <shapr> but not for every use of foo throughout the program
08:14:21 <Heffalump> no, indeed
08:14:41 <shapr> if you know how, I'm sure several research programs will recruit you :-)
08:14:46 <Heffalump> oh, sorry, it's not obvious you could for that either, depends on how foo is defined
08:26:07 <shapr> it's fun to do groundwork for LIP, I'm finding lots of goodies.
08:26:15 <shapr> Gofer source to do JPEG for example
08:26:30 <shapr> and WASH now supports literal XHTML fragments HSP-style
08:26:57 <Heffalump> LIP?
08:27:06 <Heffalump> oh, library infrastructure
08:27:08 <shapr> yup
08:27:24 <Igloo> Hmm, dangerous. Allow you to create bad documents.
08:27:46 <shapr> I think WASH has enforced html type safety in the past, so it still may.
08:28:02 <shapr> though I dunno how it would do it with literal fragments.
08:28:20 <Igloo> I guess it could parse the fragments and check it's still valid, actually. But that'd probably be a lot of work.
08:28:35 <shapr> if you use HaXML or HXmlToolbox it wouldn't be too hard.
08:28:49 <shapr> would be a pain to install/setup though.
08:29:27 <Igloo> Are there no other things to check? Uniqueness of names comes to mind
08:29:35 <Igloo> Maybe that's it, though
08:31:44 <shapr> ?
08:32:08 <Igloo> name="foo" and id="foo" have to be unique through a document
08:32:29 <shapr> ah
08:34:44 * Igloo wonders how Debian library packages are currently envisioned to work
08:36:49 <shapr> SyntaxPolice has written about something that parses a setup.cfg and creates a very basic set of files for debian/
08:37:09 <Igloo> But will they compile on install or will there be binary packages for everything?
08:38:53 <shapr> so far it looks like binary packages for everything
08:38:57 <Igloo> Bah
08:39:08 <shapr> well, jump on the libraries list and tell them what you think :-)
08:39:41 <shapr> if you write the code that does emacs-style compile on install, I'm sure everyone will use it.
08:39:45 <shapr> I know I will :-)
08:39:55 <Igloo> ghc5 is already being stranded by deps not being fixed or recompiled and only a handful of packages exist so far
08:41:12 <shapr> I'd start with binary-only because it's easier to start with.
08:41:52 <shapr> For the moment, I'd like any convention for Haskell debian packages.
08:42:49 <Igloo> Well binary packages doesn't really change anything from Debian's PoV. It's just that a different Makefile gets used when you run make
08:44:36 <shapr> do you think compile-on-install is just as easy as binary-only?
08:45:16 <Heffalump> compile-on-install is a nasty idea, IMO
08:45:34 <Igloo> Most of the hard work for it has to be done anyway for the library infrastructure
08:50:20 <shapr> John Meacham has a random function called snub
08:50:22 * shapr grins
08:50:30 <shapr> I would guess it randomly drops elements from a list.
08:51:19 <shapr> ah, it's a sorted nub, faster but not order preserving
08:51:34 <shapr> oh, he has ErrorLog.hs
08:52:10 <shapr> and his gale chat system client has a nearly complete ncurses library
09:04:11 <Darius> wtf?!  Where the hell did that .ghci go?!
09:06:51 <Smerdyakov> It's gone, and if you want to see it back, you'll deposit 10,000 sealed breath mints in my Swiss bank account.
09:12:39 <Darius> Well, I still have no idea where it went, but now there's a new improved one.
09:12:41 * shapr partially applies a holographic stick to Smerdyakov 
09:14:14 <shapr> wow, executable juggling passing pattern description language in Haskell
09:14:40 <Darius> Yeah, I saw that.
09:14:52 <shapr> I haven't seen it before, it's spiffy.
09:14:53 <Darius> I thought it wasn't maintained anymore.
09:15:46 <shapr> last release in 1999
09:19:42 * shapr boings cheerfully
09:20:15 <shapr> anyways, I want some way to upgrade my ghc debs without having to manually rebuild/reinstall HToolkit everytime
09:21:21 <Igloo> Then you want the above library thingy  :-)
09:21:25 <shapr> yes!
09:23:41 <Heffalump> basically, what's needed is someone making sure that Haskell stuff gets rebuilt for new versions quickly
09:23:45 <shapr> yes
09:23:53 * shapr nominates himself
09:24:16 <Igloo> But for testing you need *everything* to be rebuilt quickly, which generally means multiple people all reacting
09:24:33 <shapr> or some automated way to build everything, on a really fast computer
09:24:47 <Heffalump> or just have things dropped from testing if they don't get rebuilt quickly enough
09:24:53 <shapr> yah, that's true
09:25:03 <Igloo> Neither of those are the way testing works, though
09:25:13 <Heffalump> that's not Haskell's fault
09:25:27 <shapr> are you talking about debian/testing, or just testing of haskell software in general?
09:25:29 <Igloo> But the issue is how Haskell should fit into Debian
09:25:33 <Igloo> debian/testing
09:25:35 <shapr> ah
09:25:49 <Heffalump> making things be recompiled on install is asking for people to get errors at install time
09:25:54 <shapr> yup
09:25:56 <Heffalump> which is just wrong, it should happen at package build time
09:26:13 <shapr> I think that's correct for Debian
09:26:21 <shapr> maybe not for Gentoo
09:26:31 <Heffalump> yeah
09:26:43 <Heffalump> but build time happens locally with Gentoo, that's the point of it
09:26:49 <shapr> yup
09:28:45 <shapr> so we need a big build box for testing, right?
09:30:19 <Heffalump> anyone familiar with QuickCheck about?
09:30:42 <Heffalump> (ideally but not essentially they'd also have a copy of Fun of Programming to hand)
09:30:43 <shapr> I'm sort of familiar with it.
09:30:49 <shapr> no copy of FoP though
09:30:49 <Igloo> It seemed self-explanatory to me when I used it
09:31:12 <Heffalump> I'm typing in code from the chapter and it's failing the type checker
09:31:16 <Heffalump> :t any
09:31:18 <Heffalump> oops
09:31:34 * Igloo goes to find FoP
09:32:38 <Igloo> Which bit?
09:33:10 <Heffalump> prop_Exclusive on page 38
09:34:52 <Igloo> What's the type error?
09:35:01 <Heffalump> @type any
09:35:02 <lambdabot> any :: (a -> Bool) -> [a] -> Bool
09:35:09 <Igloo> Oh, hmm
09:35:09 <Heffalump> but it's applied to a list of Bools
09:35:27 <Heffalump> I changed it to "or", but then the type of prop_Exclusive changes to Form -> Bool
09:35:38 <Heffalump> @type not
09:35:38 <lambdabot> not :: Bool -> Bool
09:35:45 <Heffalump> but given that type around the outside, this may be inevitable
09:36:50 <pesco> Heffalump: What should the type of prop_Exclusive be?
09:37:01 <Heffalump> well, the chapter gives it as Form -> Property
09:37:39 * Igloo can't remember it well enough
09:37:56 <pesco> And 'any' is applied to a list of bools, strange. If its type was [Bool] -> Property, would that work?
09:38:58 <Heffalump> err, yeah, but that'd be a fairly big change
09:39:07 <Heffalump> oh, no, cos not is still Bool -> Bool
09:39:25 <Heffalump> prop_Exclusive p = not (any [ ...] )
09:39:31 <Heffalump> is the definition given
09:39:50 <Heffalump> I don't quite understand how they made this mistake, really
09:39:52 <pesco> Maybe not and any are Property combinators defined in QuickCheck.
09:40:10 <Heffalump> well, I have QuickCheck imported
09:40:18 <pesco> Er.
09:40:22 <Darius> pesco: that would be fairly evil.
09:40:52 <Heffalump> Darius: not hugely so, given that Bool is an instance of the same typeclass as Property
09:40:57 <pesco> Have you looked at QuickCheck's Generator combinators? I think they're fairly evil, too.
09:41:29 <shapr> is it possible they're using QuickCheckM ?
09:41:39 <pesco> What's QuickCheckM?
09:41:42 <Heffalump> the monadic version
09:41:43 <shapr> it's the monadic version
09:41:49 <Heffalump> the version for monadic code, even
09:41:52 <pesco> oic
09:42:02 <shapr> maybe Debug.QuickCheck isn't the same as the one on John's site?
09:43:16 <pesco> Ok, I'm out on this one.
09:43:29 * Heffalump has given up and changed it to Form -> Bool and any to or
10:00:32 <Darius> @prelude until
10:00:34 <lambdabot> *** "until" prelude "Haskell Standard Prelude Dictionary": text follows
10:00:34 <lambdabot> until
10:00:34 <lambdabot>   until ::  (a -> Bool) -> (a -> a) -> a -> a
10:00:34 <lambdabot>   until p f x     = if p x then x else until p f (f x)
10:01:05 <Darius> @type \p f x -> takeWhile p . iterate f x
10:01:16 <Darius> @type \p f x -> List.takeWhile p . iterate f x
10:02:29 <Darius> @type \p f -> takeWhile p . iterate f
10:02:29 <lambdabot> \p f -> takeWhile p . iterate f :: (a -> Bool) -> (a -> a) -> a -> [a]
10:53:51 <sgeigerbot> hi, shapr
10:53:56 <shapr> hi sgeigerbot 
10:54:00 <sgeigerbot> cool.
10:54:06 <shapr> would you like the #haskell quick tour?
10:54:15 <sgeigerbot> Yes, sir.
10:54:37 <Heffalump> shapr is the #haskell bot.
10:54:45 <sgeigerbot> excellent
10:54:50 <shapr> :-)
10:55:14 <shapr> sgeigerbot: have you used any functional languages before?
10:55:18 <sgeigerbot> Btw, as far as bots go, I may be a little laggy, but it isn't polite to say so.  I don't comment on how you dress....
10:55:29 <sgeigerbot> shapr: yes...  
10:55:34 <sgeigerbot> oop, even.
10:55:47 <shapr> which languages have you used?
10:56:09 <sgeigerbot> Perl, Python, FoxPro, VB, Java...  all in small amounts, I'd say.
10:56:17 <sgeigerbot> C++
10:56:24 <shapr> cool, have you used map/filter/reduce in Python?
10:56:28 <sgeigerbot> elisp 
10:56:38 <sgeigerbot> no.
10:56:44 <Darius> Perl, VB, Java are probably best taken in small amounts 
10:56:49 <shapr> :-)
10:56:58 <shapr> sgeigerbot: ah, elisp is good
10:57:17 <sgeigerbot> shapr: I knew you would say that.  I know you from #emacs
10:57:20 <shapr> yes :-)
10:58:05 <shapr> the quick tour starts with lambdabot 
10:58:08 <shapr> @fact learning
10:58:10 <lambdabot> http://www.haskell.org/learning.html, http://www.haskell.org/hawiki/LearningHaskell
10:58:19 <shapr> lambdabot is written in Haskell, and the sources are on sourceforge
10:58:22 <sgeigerbot> I was already on that page.
10:58:28 <sgeigerbot> cool.
10:58:32 <shapr> the learning pages have lots of goodies
10:58:50 * sgeigerbot scans for "^-prefixed commands"
10:59:06 <shapr> the basic features of Haskell (imho) are a lot like lisp taken to extremes
10:59:36 <Darius> If one of the extremes is the extreme lack of something, then yes ;)
10:59:50 <shapr> you can treat a function as a value
11:00:13 <sgeigerbot> intersting
11:00:22 <shapr> hm, quick demos...
11:00:31 <shapr> @eval map (\x . x + 1) [1,2,3]
11:00:32 <lambdabot> [2, 3, 4]
11:00:53 <shapr> an anonymous function that adds one to its argument is described with (\x -> x + 1) in Haskell
11:01:11 <sgeigerbot> One thing I tend to rely on a lot lately is regexes...  is that supported well?
11:01:16 <shapr> lambdabot's @eval plugin is a close facsimile, good for demos
11:01:24 <shapr> yes, regular expressions are in Haskell
11:01:41 <shapr> you may end up using parsing combinators instead though
11:01:47 <shapr> parsing is one of Haskell's strong points
11:02:03 <Darius> not as a language feature or even a standard standard library
11:02:15 <shapr> parsers are the next step, when you realize a backreference is only for a value, not for a regex pattern.
11:03:30 <shapr> the HaWiki has a lot of good stuff: http://www.haskell.org/hawiki/
11:03:49 <shapr> here's one particularly useful page: http://www.haskell.org/hawiki/FundamentalConcepts
11:05:20 * shapr tries to remember other points in the #haskell quick tour
11:05:22 <shapr> hmm
11:05:42 <Darius> and a particularly useless page: http://www.haskell.org/hawiki/QuotesPage
11:06:22 <sgeigerbot> shapr: you make a pretty good bot.  I'll have to talk to the Queen about botting you.
11:06:23 <shapr> that's lots of fun though :-)
11:06:26 <shapr> heh
11:06:29 <shapr> that would be kind :-)
11:06:42 <shapr> usually I'm a better bot, but I'm fuming about mwilson's passive-aggressive stuff on #debian
11:07:12 <shapr> IRC should never be taken too seriously
11:07:30 <shapr> anyways, the standard libraries that come with GHC are listed here: http://www.haskell.org/ghc/docs/latest/html/base/index.html
11:07:49 <sgeigerbot> shapr: dude, you saw my factoid on mwilson.  Those are actual numbers.  He's merely a hot head.
11:07:57 * Smerdyakov remembers encountering some unpleasant characters in #debian, but doesn't remember whom.
11:07:58 <shapr> yah, that's a good point.
11:08:14 <sgeigerbot> shapr: I think he has been avoiding the word stupid today because he read my factoid already.
11:08:18 <shapr> hah
11:08:24 <Darius> Actually, except obviously the GHC/NHC/Hugs branches, all the implementations same the same heirarchical libraries, though they don't all implement everything.
11:08:37 <sgeigerbot> shapr: of course, idiotic and moron are still being used...  
11:08:59 <shapr> nah, no surprise.
11:09:21 <sgeigerbot> so, which compiler should I use?
11:09:30 <shapr> I like the ghc6 debs
11:09:36 <shapr> made by Igloo
11:09:57 <sgeigerbot> I assume that works with haskell-mode
11:10:04 <shapr> yes, it does.
11:10:43 <shapr> here's the first thing I wrote in haskell, long ago: http://kungens.kemi.fi/~shae/src/haskell/Mandelbrot-0.1.hs
11:11:33 * Darius still hasn't looked at that file.
11:11:43 <shapr> Darius: it's not very exciting
11:12:06 <shapr> I think it's functional code written with a procedural style, so it's a good stepping stone
11:12:11 <shapr> I like to think that's true, at least :-)
11:12:29 <shapr> Darius: what would you suggest for good demo code for people new to Haskell?
11:12:59 <Darius> I haven't the foggiest.  Not quicksort ;)
11:13:01 <sgeigerbot> shapr: I'm sure the haskell.org site has that sort of thing.  
11:13:16 <sgeigerbot> shapr: well, I think that's quite a quick tour...  Can I keep the MP3 player?
11:13:21 <shapr> sgeigerbot: yes ;-)
11:13:31 <shapr> though the mp3 player is written in C and elisp sadly.
11:13:43 <sgeigerbot> :-)
11:13:58 <shapr> sgeigerbot: if you have any questions, feel free to ask me.
11:14:15 <sgeigerbot> shapr: you are a true friend of programmers.
11:14:19 <shapr> :-)
11:14:20 <sgeigerbot> shapr: thank you. 
11:14:23 <shapr> sure, anytime
11:14:31 <sgeigerbot> If I hear from the Queen, I'll let you know what she says.
11:14:45 <shapr> thanks :-)
11:42:31 <shapr> any ideas for Demo.hs ? http://kungens.kemi.fi/~shae/src/haskell/Demo.hs
11:49:57 <shapr> ok, I've updated it a bit.
11:50:14 <shapr> sgeigerbot: check out that url, it's a super short summary of some of Haskell.
11:53:09 <andersca> so shapr
11:53:12 <andersca> tell me about Haskore
11:53:15 <shapr> it's really cool
11:53:28 <andersca> does it output sound?
11:53:32 <shapr> yah, sure
11:53:41 <andersca> interesting
11:53:43 <shapr> er, not itself
11:53:45 <andersca> oh
11:53:46 <shapr> but it uses timidity
11:53:46 <andersca> hmm
11:53:49 <andersca> right
11:53:49 <shapr> lemme show you
11:54:00 * andersca needs to output sound for his funky .mod player
11:54:25 <shapr> > testLinux m = do
11:54:26 <shapr> >                 test m
11:54:26 <shapr> >                 system "timidity test.mid"
11:54:26 <shapr> >                 return ()
11:54:44 <shapr> the TestHaskore.lhs file includes testNT testWin95
11:55:13 <shapr> so, assuming you have testLinux working
11:55:26 <shapr> testLinux (foldr1 ((:=:) . (Tempo 2)) (map in_c [4,5,6,7]))
11:55:43 <shapr> er, that would need in_c
11:55:50 <vegai> so, it outputs mid?
11:55:50 <shapr> > in_c i = line [c i qn [], e i qn [], g i qn [], c (i + 1) qn [], Rest hn]
11:55:53 <shapr> vegai: sure
11:56:01 <andersca> cool
11:56:02 <shapr> it also outputs some other stuff, like Csound
11:56:17 <shapr> I'd like to hack the Csound output to be mpeg4
11:56:36 <shapr> but it's way down on my TODO list
11:56:39 <andersca> I'm pondering using some sort of fifo thingy for my player
11:56:51 <andersca> and then as you read from the head it inserts stuff in the tail lazily
11:57:07 <shapr> sounds cool
11:58:03 <elmex> Parsec is cool, isn't it?
12:05:57 <Darius> There's also Parsek and a Packrat parser with a Parsec inspired interface
12:06:39 <Darius> shapr: what's with Node (Nil) 1 (Nil)+
12:06:40 <Darius> ?
12:06:43 <andersca> parsec is very cool
12:12:25 <Darius> leaving
12:55:31 <shapr> Darius: keverets suggested it two days ago, it keeps the value and the branches explicitly separate.
12:55:38 <shapr> Darius: do you have another suggestion?
12:55:41 <shapr> hi dark
12:55:43 * shapr yawns
13:01:19 <shapr> hej Marvin-- 
13:01:22 <shapr> how was the visit?
13:01:38 <Marvin--> which one?
13:01:43 <shapr> yesterday? relatives?
13:02:03 <shapr> oh, I found the darcs problem
13:02:19 <Marvin--> it was fun, very relaxed for a 50's birthday
13:02:30 <shapr> a) postfix doesn't run .forward in the users home dir b) I was signing with the wrong key, had to set my default key in ~/.gnupg/options
13:03:58 <shapr> Marvin--: hej, maybe you know how to get TTFs to work in debian/unstable?
13:04:29 <Marvin--> TTFs?
13:04:38 <shapr> truetype fonts
13:05:00 <Marvin--> (the reason I asked "which one" is that we're having a group of Danes visiting today and tomorrow, so I've been playing Game of Thrones the entire afternoon and evening)
13:05:03 <Marvin--> no idea, I suck at fonts
13:05:06 <shapr> ah, cool
13:05:13 <shapr> so does #debian btw
13:05:48 <Marvin--> #debian sucks at fonts?
13:05:51 <shapr> yup
13:06:00 <Marvin--> it's my impression that *X* sucks on fonts
13:06:20 <d33p> yeah.. why doesnt someone fix that?
13:06:26 <Igloo> I always install them at both server and client end. I should find out which one they actually need to be at
13:06:29 <shapr> there are works in progress
13:06:35 <shapr> such as defoma
13:06:57 <shapr> but I can't figure out how to get defoma to recognize everything in /usr/share/fonts/truetype without making a hints file for each font
13:07:47 * Marvin-- shrugs
13:07:53 <Marvin--> I just apt-get and hope for the best
13:10:45 <andersca> it's been fixed now
13:10:50 <shapr> what has?
13:10:51 <andersca> just use client side fonts
13:10:58 <shapr> how so?
13:11:19 <andersca> because they're much better :)
13:11:23 <andersca> I'm talking about fontconfig and xft
13:11:43 <shapr> do I run fontconfig as root or as myself?
13:11:44 <Marvin--> and for all the programs that don't use xft?
13:11:47 * shapr reads docs
13:11:58 <shapr> yah, my main goal here is to get access to the tengwar TTF fonts for emacs
13:12:07 <shapr> I've had it before with xfs-xtt and xfstt
13:12:27 <Igloo> The ttf package postinsts might give clues too
13:12:36 <shapr> good point
13:12:51 <Marvin--> there's xfs, xfstt, xft, freetype...
13:13:04 <Marvin--> I just get lost
13:16:52 <shapr> it seems that defoma and x-ttcidfont have something to do with it.
13:17:17 <andersca> Marvin--: I only run one program that uses core fonts, and that's xmms
13:17:36 <Igloo> "core fonts"?
13:17:41 <andersca> core fonts are the old ones
13:17:44 <andersca> the server-side ones
13:17:44 <andersca> sucky ones
13:17:45 <andersca> :)
13:17:47 <andersca> slow ones 
13:17:59 <shapr> it appears that I need to run defoma-font with a hints file that describes each font
13:18:03 <shapr> but I don't want to make a hints file.
13:18:04 <Igloo> Ah, cool, ta
13:18:35 <shapr> I don't know the hints properties for most of the tengwar fonts
13:18:44 <andersca> with client side fonts I just put them in my ~/.fonts
13:18:46 <andersca> and restart my app
13:18:47 <andersca> and voila
13:18:51 <shapr> hm
13:18:56 <shapr> that's handy
13:19:18 * shapr tries that
13:19:22 <Marvin--> andersca: well, I for one use gvim and terminal emulators and xmms and occasionally other programs too
13:19:56 <andersca> Marvin--: when I need to install server side fonts i copy them to /usr/share/fonts
13:20:04 <andersca> then "service restart xfs" and "xset fp rehash"
13:20:31 <Marvin--> well, installing fonts is one thing, having programs find them is another :-/
13:20:39 <Igloo> Oh, this sounds complicated. I'll just keep installing them both ends  :-)
13:20:41 <Marvin--> "ruuuunnn toooo theee hiiiiillls"
13:20:44 <andersca> that's where fontconfig will save us
13:21:06 <andersca> you should run gvim Marvin--, it uses fontconfig
13:21:09 <andersca> so does xterm
13:21:28 <Marvin--> I do run gvim
13:21:30 <Marvin--> how does that help me?
13:21:44 <shapr> so, I throw tengwar*.ttf into ~/.fonts run xset fp rehash
13:21:47 <andersca> then you should get fontconfiged font
13:21:51 <shapr> then xfontsel still doesn't seem them. hm.
13:21:59 <andersca> shapr: no, xfontsel works with server side fonts
13:22:00 <andersca> :)
13:22:02 <shapr> oh
13:22:09 <Marvin--> xterm sucks, I use mlterm a lot
13:22:13 <Igloo> So, anyone tried berlin?  :-)
13:22:23 <andersca> Igloo: haha
13:22:24 <andersca> you're funny
13:22:25 <andersca> :)
13:22:31 <shapr> I looked at it a year ago
13:22:38 <andersca> research project...
13:22:42 <shapr> it wasn't ready.
13:22:54 <shapr> but the screenshots were amazing.
13:22:59 <Marvin--> andersca: I still have to give the font name in the ")¤(&#¤ stupid #"(&¤" format
13:23:00 <shapr> *truly* transparent terminals.
13:23:07 <Marvin--> doesn't aqua have that too?
13:23:16 <andersca> shapr: it's also dog-slow
13:23:22 <shapr> andersca: even so...
13:23:35 <d33p> what is berlin?
13:23:47 <andersca> it's called fresco nowadays I think
13:24:01 <shapr> anyways, I can't effectively use tengwar because TTF fonts use massive kerning offsets to get the vowels above consonants
13:24:17 <andersca> it's a shame that emacs doesn't use xft :/
13:24:19 <shapr> and emacs flips out and overwrites the last thing you typed over the letter before it, and you can't see anything.
13:24:41 <shapr> part of the problem is that tengwar doesn't fit into latin-1 by any stretch of the imagination.
13:25:14 <shapr> now that I think of it, an OpenGL wm would have real transparency
13:25:20 <shapr> and probably better performance :-)
13:25:34 <andersca> no no no
13:25:54 <shapr> d33p: http://www.fresco.org/
13:25:58 <shapr> that used to be Berlin
13:26:04 <shapr> andersca: doesn't sound good?
13:26:15 <andersca> shapr: X needs to be fixed
13:26:20 <d33p> shapr: free sco? whats that linux :p
13:26:23 <andersca> the DIX needs to be adapted
13:26:25 <shapr> d33p: haha!
13:26:32 <shapr> andersca: you want EUNUCHs?
13:26:37 <andersca> XAA needs to be adapted too
13:26:42 <andersca> I want X
13:26:47 <shapr> oh, I thought you said amputated.
13:26:56 <andersca> oh :)
13:27:03 <shapr> <andersca> the DIX needs to be amputated  <shapr> andersca: you want EUNUCHs?
13:27:18 * shapr laughs hysterically
13:27:45 <shapr> note: that's not what he really said.
13:28:03 <shapr> what's DIX and XAA (X acceleration architecture?)
13:28:11 <shapr> @foldoc dix
13:28:12 <lambdabot> No match for "dix".
13:28:21 <andersca> XAA is the acceleration architecture
13:28:29 <andersca> dix is the Device Independent parts of X
13:28:35 <shapr> oh
13:29:31 <shapr> d33p: real transparency: http://www.fresco.org/data/screenshots/xggi-xchat.png
13:29:54 <andersca> "yay", it's built on ggi too
13:29:56 <andersca> grin
13:30:04 <shapr> what's ggi?
13:30:20 * shapr is an X-newbie
13:30:21 <d33p> shapr: hmm? dont know about the "real", but xchat does pseudo-transparency thats good enough
13:30:25 <andersca> general graphics interface or something
13:30:27 <shapr> oh
13:30:45 <shapr> d33p: real means you can put multiple transparent thingies on top of each other and see all of them at the same time.
13:30:46 <phubuh> they should make screenshots of *actually* impressive stuff instead of dumb gimmicks like rotation and alpha blending
13:30:47 * andersca has been hacking a bit on X lately
13:30:53 <andersca> phubuh: yeah, like stuff working
13:30:54 <andersca> :)
13:31:02 <shapr> truly, working stuff would be impressive.
13:31:15 <Marvin--> phubuh: yeah, I agree, the rotation is just silly
13:31:22 <phubuh> they should have photos of people working on berlin, as evidence that something's going on :-)
13:31:30 <andersca> X is getting there
13:31:31 <andersca> it has to
13:31:39 <shapr> there's nothing else
13:31:53 <shapr> much like emacs, it has many suckages, but it's the best I've tried.
13:31:58 <andersca> yeah
13:32:13 <andersca> does haskell have Xlib bindings (back on-topic)
13:32:21 <shapr> isn't that what the X11 lib does?
13:32:26 <shapr> or is it?
13:32:31 <shapr> I've been wondering about a HaskellWM
13:32:41 <andersca> gar
13:32:45 <andersca> thatwould be interesting
13:32:45 <andersca> man
13:32:56 <andersca> never even _thought_ about that
13:33:04 <shapr> why not?
13:33:12 <andersca> I mean, it's a neat idea
13:33:15 <shapr> if the X11 bindings are as complete as A. Reid says...
13:33:15 <andersca> I haven't thought about it
13:33:17 <andersca> yeah
13:33:20 <shapr> there's scheme wm
13:33:25 <shapr> why not HaWM ?
13:33:38 <phubuh> i was thinking about writing one the other day
13:33:46 <phubuh> and then i got back to reality and realized i don't know haskell
13:33:51 <phubuh> nor X11
13:33:58 <shapr> phubuh: heh, that happens to me on a regular basis :-)
13:34:00 * andersca knows both
13:34:02 <andersca> well
13:34:06 <andersca> I know X11 better than haskell :)
13:34:17 <shapr> hi Esa
13:34:24 <esap> Hi
13:34:34 <shapr> what's up?
13:34:51 <esap> not much, been thinking about variables.
13:35:08 <andersca> no variables in haskell
13:35:13 <andersca> now go wash your mouth with soap
13:35:13 <andersca> ;)=
13:35:27 <esap> heh, names I mean.
13:35:31 <shapr> andersca: http://www.reid-consulting-uk.ltd.uk/projects/HSX11.html
13:35:55 <shapr> ah, Xlib.gc 
13:36:20 <shapr> looks like Xlib bindings to me.
13:36:23 <andersca> cool
13:37:03 <shapr> Atom.gc  Color.gc  Context.gc  Display.gc  Event.gc  Font.gc  Misc.gc  Region.gc  Screen.gc  Types.gc  Window.gc
13:37:14 <Marvin--> ".gc"?
13:37:17 <shapr> green card
13:37:34 <shapr> hey syntax-laptop!
13:37:44 <Marvin--> ah
13:37:55 <andersca> shapr: it's in the io monad ight
13:37:57 <syntax-laptop> heyhey
13:38:08 <shapr> where do I get Graphics.X11 ?
13:39:34 * Marvin-- grumbles at the cards FFG banned
13:40:36 <andersca> ffg?
13:40:48 <Marvin--> Final Fantasy Games, they make the Game of Thrones CCG
13:41:28 <andersca> oh
13:41:47 <syntax-laptop> can anyone else reach: http://www.samtrafiken.se/
13:41:49 <andersca> sharp: what's greencard?
13:42:19 <shapr> it's one of the "easy" Haskell to C bindings I think
13:42:37 <Marvin--> er
13:43:00 <shapr> hello again Marvin-- 
13:43:12 <shapr> syntax-laptop: I can't reach it.
13:43:28 <Marvin--> neither can I
13:43:47 <shapr> andersca: http://www.haskell.org/greencard/
13:43:47 <cleverdra> andersca - http://www.haskell.org/greencard/
13:43:55 <cleverdra> I win!
13:44:32 <Marvin--> cleverdra: that's not how it looks from over here
13:44:44 <andersca> not here either
13:44:57 <syntax-laptop> shapr, marvin--: thanks
13:45:00 <shapr> cleverdra: it's okay, I'll give you all the points.
13:45:02 <shapr> :-)
13:45:13 <shapr> @fact greencard http://www.haskell.org/greencard/
13:45:14 <lambdabot> set greencard to http://www.haskell.org/greencard/
13:45:34 <shapr> cleverdra: how's life?
13:45:43 <shapr> armed forces treating you well?
13:45:55 <cleverdra> shapr - quite well.  How are you?
13:46:15 <shapr> working hard, gotta get some stuff done before ICFP
13:48:17 <Marvin--> well, I'm off to bed, dead tired
13:48:27 <cleverdra> goodnight, Marvin.
13:48:33 <cleverdra> shapr - when is ICFP?
13:48:47 <shapr> end of August
13:49:42 <shapr> I have a few websites that need to be done beforehand, so if I do it all now, I'll have some free time to do Haskell PairProgramming before
13:50:07 <shapr> oh, bye marvin--
13:50:08 <shapr> foo
13:53:52 * shapr installs greencard 3.01
13:56:33 <shapr> Lunar^: what's the word on polymorphic kinds?
13:59:52 <shapr> how do I turn foo.a into foo.o again?
13:59:58 <shapr> for ghci usage?
14:03:59 <shapr> andersca: seen any Xwm tutorials?
14:04:20 <andersca> only the one in the xlib book
14:04:52 <shapr> is that an open source book?
14:05:01 <andersca> no
14:05:06 <andersca> it's an orilley book
14:05:09 <Igloo> You might be able to unar it and then link whatever's inside with ld, but you'd normally create them separately from teh object files
14:05:23 <shapr> oh
14:05:45 <Igloo> (unless I'm confused)
14:07:24 <Darius> time to do some mental type inferencing with CPS code. joy.
14:07:51 <shapr> sheez, the Xlib book has two volumes.
14:08:00 <shapr> programming manual and reference manual
14:08:29 <andersca> programming manual is good
14:08:35 <shapr> one day, there will be a Haskell O'Reilly book
14:08:39 <shapr> then we know we've hit the big time.
14:09:16 <shapr> mr_goatse: scary
14:09:37 <shapr> well, I could go do some work...
14:09:57 <shapr> yah, I'll bbl
14:16:12 <d33p> whats going on here: sin (x:+y)    = sin x * cosh y :+ cos x * sinh y
14:17:47 <d33p> nm i just saw this, infix  6  :+
14:19:09 <Igloo> :+ is a constructor for a datatype, possibly the complex number one
14:21:07 <d33p> Igloo: yeah, i saw it in Complex.hs
15:14:06 <elmex> is there some way to have fast arrays from haskell? some where i can have some kind of O(1) for element-access and element-adding. or is that given by Array ?
15:14:40 <Heffalump> yes, that's what Array etc do
15:14:45 <elmex> ok
15:15:02 <Heffalump> I forget exactly which kind you need if you want fast update as well as lookup, but there is one
15:15:09 <Heffalump> (some of the types are immutable and get copied for updates)
15:15:19 <elmex> hm
15:15:26 <elmex> so i have to use mutable ones?
15:16:21 <elmex> do you mean STArray ?
15:16:28 <Igloo> Presumably you need an IO one to have O(1) update
15:16:35 <Heffalump> well, or an ST one, yeah
15:17:08 <Igloo> Does teh ST definition use secret primitives then?
15:17:27 <elmex> hm
15:17:27 <Heffalump> I suspect it uses unsafeIOtoST
15:17:53 <Igloo> Ah
15:17:58 <Darius> Actually, as IO is ST RealWorld# for GHC, there's probably only one ST implementation.
15:18:04 <Heffalump> yeah.
15:18:15 <Heffalump> oh, yeah, right, so it won't be that way round.
15:18:40 <elmex> hm, and how do i construct and use an STArray ?
15:19:09 <Darius> Read the documentation for Data.Array.MArray (I believe)
15:19:33 <Darius> Depending on what you are doing you may also want to look at STUArray
15:20:05 <elmex> hm, i want to store some own haskell datatype in there (made with data ...)
15:20:29 <Darius> Okay, then STArray is the one you want.
15:20:38 <Darius> (out of those two)
15:21:33 <elmex> hm, i guess using STRef's would be enough for my problem. but thanks for the informations
15:21:51 <Heffalump> hmm, if I have a .lhs file which is mostly code and just the odd comment, should I really have been using .hs ?
15:22:34 <Darius> Seemingly
15:24:04 <Heffalump> meaning it's bad style, or it doesn't really matter?
15:27:20 <Darius> Well the "Seemingly" was because it seems that you haven't written a literate script.  Whether it's bad style or not would depend on who you ask though probably it would lean toward bad style.
15:28:53 <Darius> Users of literate programming would think (correctly) that you aren't really using literate style, while people (like me) who aren't to much a fan of literate programming would be annoyed by the >'s or the \begin's
15:33:32 * Heffalump applies some liberal cut -c3-
15:35:34 * Darius needs to make something he'll call ActiveComments though that name is likely taken.
15:35:48 <dark> Probably by Microsoft :)
15:35:49 <Heffalump> which do what?
15:38:07 <Darius> I haven't really worked out specifics and there are already some things that are nice.
15:38:38 <Darius> Basically, the idea is to get as much use out of writing comments as possible so that "plain text" comments are the last resort.
15:38:40 <Heffalump> the Intentional Programming system had something that tracked the names of variables, which was nice
15:39:11 <Heffalump> (variables everywhere were bound at edit-time to a declaration site, so you could rename them easily, and that extended to mentions inside comments)
15:39:16 <Darius> Intentional Programming and what seems to be the same (or very similar) idea, SCID, is kind of interesting.
15:39:32 <Heffalump> well, Intentional Programming is dead :-)
15:40:19 <dark> Heffalump: Did it know about scope?  Was it smart enough to warn if names collided?
15:40:20 <Darius> and SCID isn't really born, it seemed to be some idea a guy had (I think SCID came before IP but I don't readily have a concrete basis for that thought)
15:40:39 <Heffalump> dark: the editor knew about scope (in theory) and bound things correctly at that point
15:41:01 <Heffalump> you tended to notice name clashes because the editor couldn't figure out what to bind to
15:41:18 <Heffalump> IP started late 80s/early 90s
15:41:59 <Darius> The SCID guy says he's had this idea since I think the mid-80's if I remember correctly, I could find the site.
15:42:56 <Heffalump> http://mindprod.com/scid.html - he says since the early 70s
15:43:26 <Heffalump> it sounds very similar to what IP
15:43:28 <Heffalump> tried to do
15:43:38 <Heffalump> (though IP had an implementation that actually worked, to some extent)
15:43:57 <elmex> what should i use the STRef for and what is IORef for? i'm having some problems in finding out, how to construct my ST monad to get some references in it.
15:44:04 <Darius> It seems like a good idea (though I kinda like my archaic linear text-based interface)  Of course, that should still be possible.
15:44:44 <Heffalump> STRef are references in the ST monad
15:44:46 <Darius> I think it's a judgement call if you wouldn't already be stuck in the IO monad.  ST would typically be more flexible.
15:44:48 <Heffalump> IORef likewise in IO monad
15:45:15 <Darius> You can always convert an ST computation to an IO one.
15:45:20 <elmex> hm, so i should use IORef, because i'm in the IO moand anyways? 
15:45:24 <Heffalump> yeah.
15:45:33 <elmex> thanks much
15:46:36 <elmex> is IORef thread-safe?
15:46:58 <Darius> Probably not.  If you are using concurrency use MVars.
15:47:01 <Heffalump> I would think writes are atomic, if that's what you mean.
15:47:25 <elmex> Darius: oh, ok
15:58:26 <elmex> hm, are MVars collected?
15:58:45 <elmex> (when all threads lost references to it)
15:59:10 <Heffalump> I should hope so.
15:59:17 <elmex> you should?
15:59:19 <elmex> ;)
15:59:44 <Darius> Why wouldn't they be?
16:00:16 <elmex> god knows
16:04:57 <Darius> About ActiveComments, some of the kinds of things that I'm thinking of would be to have executable comments.  So for example, instead of describing common usage of a function say, you could have an interactive example that serves as (some) documentation and unit test as well.  Also formal, say QuickCheck style specifications could be used (in addition), examples could be generated from them as well as being used with a theor
16:05:18 <Heffalump> you got cut off at "with a theor"
16:05:20 <dark> I think those would be known as "code", rather than as "comments" :)
16:06:02 <Darius> "theorem prover or runtime checks"
16:07:08 <Darius> dark: Many times comments have snippets of code illustrating usage or corner cases.
16:08:07 <Darius> Also, these "comments" would "break" if they are no longer true, instead of just being wrong.
16:12:50 --- names: list (clog Segora juhp dennisb arguile Smerdyakov o3 polli el_diego kunphuzil saz lilith wax earthy mgoetze cm Cale opet sjj isomer Igloo d33p Strike Rafterman)
17:06:46 <Darius> Hmm, maybe ActiveComments isn't taken.  Maybe I should start a SourceForge project
17:46:17 <Pseudonym> Darius: I have a suspicion that your ActiveComments idea might not be on a "sweet spot".
17:47:02 <Pseudonym> For any nontrivial function, you generally need so much infrastructure present to actually get it happening that I'm not sure it would be useful as a comment any more.
17:47:06 <Pseudonym> Comments are supposed to be succinct.
17:47:33 <Pseudonym> If you're talking typical examples and corner cases, what you want is a unit test framework.
17:50:04 <Igloo> Just something like `foo would be OK, except that in Haskell you have overlapping namespaces to contend with so it all gets a bit messier
17:54:05 <Darius> Pseudonym: I know, I wasn't really serious about the sf project.  Though part of it would be to provide/generate infrastructure.  And it would be meant to handle more than just commenting, including unit testing, haddock-like generated documentation, tracing/debugging aids, formal specification.
17:54:52 <Pseudonym> I think that documentation and testing are different tasks, though there is a kind of double-maintenance issue.
17:55:09 <Pseudonym> Personally, I want unit tests to be a kind of documentation rather than the other way around.
17:55:14 <Darius> Also worse case scenario, if the tool can't generate the various things, you get a warning but are no worse off then just comments.
17:56:06 <Darius> I agree, more or less.  I'd just like to integrate (aspects of) them more, to avoid that double maintenance.
17:57:19 <Darius> And help maintain consistency
17:58:26 <Darius> And hopefully, to provide more information.  For example, similar to an idea shapr was talking about, the API documentation may have on-the-fly (or at least up-to-date) unit tests and you could immediately see if function was broken currently.
19:09:48 * Pseudonym woohoos
19:09:58 <Pseudonym> Speaking of unit tests, got them passing again.
19:10:17 <Pseudonym> There's nothing you can't do in C++ by adding a level of indirection.
19:11:28 <Pseudonym> Is it just me, or does the current discussion on the mailing list confirm all my prejudices that implicit parameters are a complete misfeature?
19:11:49 <Pseudonym> Mind you, everything I see confirms my prejudices.  That's why they're prejudices!
19:13:52 <Darius> I'm not really sure why I'm in the discussion, let alone defending them.  I never use them and don't see any good compelling reason to, except as backpatching action.
19:14:09 * Riastradh hrms.
19:14:44 <Darius> On the other topic, isn't that a truism of CS in general?  Anything can be solved by adding another level of indirection.
19:15:06 <o3> Darius: that confirms it: CS == C++
19:16:15 <Pseudonym> True!
19:16:38 <Pseudonym> Darius, I think you mean software engineering, not CS.
19:16:54 <Pseudonym> Yes, I can't see a reason to use implicit parameters either.
19:17:19 <Pseudonym> The whole point of FP is to avoid implicit baggage.
19:17:29 <Darius> Indeed
19:17:40 <Pseudonym> If you really want that sort of thing, I can sell you a nice monad transformer to hide it all from you.
19:17:45 <o3> Pseudonym: they're useful for global variables
19:17:51 <o3> (in reference to hughes's paper)
19:17:59 <Pseudonym> Ugh.
19:18:07 <Pseudonym> You said "global variables". :-)
19:18:22 <o3> :)
19:18:47 <Pseudonym> If you want a solution to the problem of global variables, then I can see that they're actually the "minimal hack" required.
19:19:00 <Pseudonym> However, they're no substitute for real instantiable modules.
19:19:23 <o3> Pseudonym: totally agreed
19:19:30 <o3> first-class modules in haskell would be lovely
19:19:33 <Pseudonym> Yes.
19:19:42 * Darius says Yes too.
19:19:52 <Pseudonym> I suspect that first-class modules and template haskell might interact quite nicely, too.
19:20:10 <Pseudonym> There'd be a lot of fun design space in there.
19:20:30 <Pseudonym> Implicit parameters just seem The Wrong Thing(tm).
19:24:37 <Darius> Pseudonym: What did you think of the first-class modules paper on SPJ's site?
20:07:57 <Darius> 7 full complex lines to sequence . map (either id topLevelParser)
20:43:45 <Darius> Hmm, I don't think Haskell's type system can express mfix with CPS
20:44:22 <Smerdyakov> What is mfix?
20:44:52 <Darius> Monadic fix.
20:45:44 <Smerdyakov> A fixed point operator in some monad of functions?
20:46:20 <Darius> mfix :: (a -> m a) -> m a
20:58:44 <Pseudonym> It's been a while since I red the first-class modules paper.
20:59:01 <Pseudonym> mfix, incidentally, is to implement mdo.
20:59:52 <Pseudonym> Suppose you want to implement:
21:00:02 <Pseudonym> mdo { x <- f y ; y <- f x ; return a }
21:00:13 <Pseudonym> Note that x depends on y and y depends on x.
21:00:24 <Pseudonym> You can implement this as:
21:01:14 <Pseudonym> mfix ( \(_, x', y') -> do { x <- f y' ; y <- f x' ; return (a, x, y) } >>= \(a, _, _) -> return a
21:01:21 <Pseudonym> I left out a }
21:02:06 <Smerdyakov> Zany
21:02:12 <Pseudonym> Yup.
21:02:20 <Pseudonym> It's occasionally very, very useful.
21:03:04 <Pseudonym> I had one monad, for example, where I was hash consing, but I needed to optimise access to one or two hash-consed structures.
21:03:53 <Pseudonym> So I had a MonadReader (with the optimised hash-consed structures) and a MonadWriter (with the actual hash consing thing) in the stack.
21:04:05 <Pseudonym> Uhm...
21:04:11 <Pseudonym> Actually, this is too hard to explain. :-)
21:04:42 <Pseudonym> If you need to initialise some values, but computing those initial values requires your entire monad to be present, mdo/mfix is great.
21:05:27 <Pseudonym> Before that, what I had to do was create a bootstrap monad which computed the initial values and returned them, then I created _another_ monad with those values in place.
21:06:51 <Darius> A good example is GUI interfaces where controls usually need to know about their parents and parents obviously know about their children.
21:07:23 <Darius> mdo window <- createWindow [button];button <- createButtonWithParent window
21:08:04 <Pseudonym> Good example.
21:08:23 <Pseudonym> http://andrew.bromage.org/Dfa.lhs
21:08:41 <Pseudonym> If you have a look at remRun, that's an example of using the bootstrap monad approach.
21:08:48 <Pseudonym> Which, incidentally, doesn't work with GUIs. :-)
21:09:01 <Pseudonym> Well, it doesn't work in the IO monad.
21:09:01 <Smerdyakov> So the analogy with the usual "fix" for functions is that all do-bindings can refer to all the others?
21:09:35 <Pseudonym> The fixpoint operator ties knots in graphs.
21:09:44 <Pseudonym> The mfix operation ties knots in monad bindings.
21:13:43 <Darius> mfix only allows mdo x <- f x, but since x can be a tuple that's what allows all bindings to be visible, hence Pseudonym's translation above.
21:13:58 <Pseudonym> Right.
21:24:22 <Pseudonym> You know about SK combinators?
21:24:22 <Smerdyakov> Moi?
21:24:22 <Pseudonym> Yes.
21:24:22 <Smerdyakov> norpan, sir.
21:24:22 <Smerdyakov> That was supposed to be "No, sir."B
21:24:22 <Pseudonym> Gotcha.
21:24:22 <Smerdyakov> But this client gets overzealous about nick completion.
21:24:22 <Pseudonym> Well, then, I won't try to explain how the fixpoint operator used to be used to implement recursive let, then.
21:24:22 <Pseudonym> Before people invented real VMs for lazy functional languages. :-)
21:24:22 <Pseudonym> If you had: let { x = f y ; y = f x } in foo x y
21:24:22 <Pseudonym> Then you would have to implement this as:
21:24:22 <Pseudonym> let (x,y) = fix (\(x,y) = (f y, f x)) in foo x y
21:24:22 <Pseudonym> Sorry.
21:24:22 <Pseudonym> let (x,y) = fix (\(x,y) -> (f y, f x)) in foo x y
21:24:22 <Pseudonym> That removed the mutual recursion between x and y.
21:24:22 <Pseudonym> And thanks to the wonders of graph reduction, you only had to execute "fix" once, then the program graph had the necessary cycles in it.
21:24:22 <Pseudonym> Of course "fix" was spelled "Y".
21:39:52 <Darius> No one has separated Parsec's combinator library from the core, have they (pretty much just changing types and names I'd imagine).
21:43:06 <Darius> @type FiniteMap.addListToFM
21:43:37 <Darius> @type Data.FiniteMap.addListToFM
23:27:27 * andersca boings
