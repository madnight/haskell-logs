03:48:26 <shapr> y0
03:48:38 <shapr> Heffalump: you guys still around?
03:49:55 <shapr> I'm in Uppsala, where is everyone?
03:50:09 <andersca> hey
03:51:00 <shapr> @yow
03:51:00 <lambdabot> If you STAY in China, I'll give you 4,000 BUSHELS of "ATOMIC MOUSE"
03:51:00 <lambdabot>  pencil sharpeners!!
03:51:05 <shapr> hey andersca 
03:51:17 <shapr> jar ar i uppsala! det ar sa kul!
03:52:27 <andersca> :)
03:52:29 <andersca> har du träffat nån
03:54:23 <shapr> bara SyntaxPolice 
03:54:33 <shapr> han sover i samma rum som mig
03:55:47 <Marvin--> hej shapr :)
03:55:55 <shapr> hej Marvin-- !
03:55:58 <shapr> vi ar har!
03:56:05 <shapr> uppsala is a nifty place
03:56:12 <Marvin--> Fatal error: Maximum execution time of 30 seconds exceeded in /server/squirrelmail/1.4.0/sw/functions/imap_general.php on line 84
03:56:13 <shapr> we're in a net cafe called port 22
03:56:16 <Marvin--> oh for the LOVE OF GOD
03:56:21 <Marvin--> heh, cute
03:56:24 <andersca> Marvin--: lotsa mail?
03:56:42 <andersca> shapr: I heard there's a cafe called port 23
03:56:44 <Marvin--> andersca: this "medic" organization seems to suck as much as md's old sysadmin group
03:56:44 <shapr> but I had to ask about a secure shell client
03:56:45 <andersca> where they never lock the doors
03:56:48 <Marvin--> god damn this sucks
03:57:00 <shapr> andersca: the door was locked before noon
03:57:02 <Marvin--> shapr: odd, with a name like that you'd think they had ssh installed
03:57:13 <shapr> truly, I'll have to tell them
03:57:36 <Marvin--> jävla ekorrpost
03:57:45 <andersca> hehe
03:58:07 <Marvin--> shapr: do they have wlan?
03:59:09 <shapr> dunno, we have no wlan cards
03:59:25 <shapr> well, I've checked my email...
03:59:36 <Marvin--> I'm considering buying a wlan card for my laptop
03:59:40 <shapr> I think I'll go bug SyntaxPolice ...
03:59:56 <shapr> hey Marvin-- you know my phone number?
04:00:08 <Marvin--> shapr: no, could be good to have
04:01:41 <Marvin--> ...
04:01:53 * Marvin-- wonders if shapr has forgotten his own number
04:02:09 <Marvin--> shapr: mine's 0739-169191
04:02:38 <Marvin--> shapr: I was hoping you'd meet me at the station on Wednesday and tell me where to go ;)
04:03:49 <Marvin--> shapr: :)
04:04:03 <shapr> thats the danger of giving me your number
04:04:08 <Marvin--> yeah :)
04:04:16 * shapr grins evilly
04:04:40 <Marvin--> I'm impressed by your Swedish
04:04:52 * shapr watches his ego swell
04:05:18 <shapr> wait till wednesday, we'll see how good it rerally is
04:05:24 <shapr> gah, swerty
04:05:28 <shapr> can't type
04:06:31 <shapr> hey, have Heffalump and Igloo left already?
04:06:36 <Marvin--> no idea
04:06:48 <shapr> would be handy to have their numbers too
04:07:01 <Marvin--> maybe, you never know how and when planes fly around
04:07:10 <shapr> yah
04:07:20 * Marvin-- is still obsessed with the idea of going to Bremen via Amsterdam
04:07:25 <shapr> heh
04:07:28 <Marvin--> stupid KLM :)
04:07:52 <shapr> my half hour is almost up, I'll go bug SyntaxPolice now
04:08:00 <Marvin--> see you Wednesday
04:08:04 <shapr> yah!
04:37:17 * Marvin-- ponders wlan
13:33:42 <tomasso> when i load a .hc file in hugs, it returns
13:33:55 <tomasso> sintax error in line 6
13:34:05 <tomasso> and it has:
13:34:07 <tomasso> seven :: Int -> Int
13:34:08 <tomasso>  seven x = 7
13:34:18 <tomasso> ERROR "practica1.hc":6 - Syntax error in input (unexpected `=')
13:34:37 <andersca> should probably not indent that second row
13:35:06 <tomasso> is indent obligatory?
13:35:32 <tomasso> ???
13:35:37 <andersca> it's a part of the language, yes
13:36:02 <tomasso> hmmh didnt know, and whats the rule for indentation?
13:36:05 <tomasso> two blank spaces??
13:38:35 <andersca> no indentation at all in your case3
13:39:37 <tomasso> andersca: what do you mean??
13:39:44 <andersca> seven :: Int -> Int
13:39:46 <andersca> seven x = 7
13:40:16 <tomasso> it worked...
13:40:36 <tomasso> hh \mm that thing of identation may be bothering... or not?
13:43:10 <Lunar^> damnly not bothering eg when using case and do together
13:45:44 <tomasso> hmhm cannot find nothing on indentation in the haskell tutorial
13:46:13 <Lunar^> What editor are you using ?
13:46:17 <tomasso> why isnt that topic covered...? its important
13:46:32 <tomasso> im using kate with haskell sintax highlighting
13:46:34 <tomasso> (for linux)
13:46:46 <Lunar^> ok... Do you know how to use Emacs ?
13:46:58 <Lunar^> Haskell-mode for emacs does the indentation for you
13:47:02 <tomasso> a little,
13:47:18 <tomasso> emacs and xemacs are the same?
13:47:29 <Lunar^> You just have to use "tab" (more than once if needed) to get proposed indentation
13:47:30 <Riastradh> No.  They're different branches.
13:47:40 <Lunar^> haskell-mode works on both
13:47:49 <tomasso> ok, let me check
13:48:23 <Lunar^> Anyway, indentation is really important when using where, pattern matching and the do notation
13:48:34 <Lunar^> as far as I can think
13:57:49 <Darius> layout only matters after 'where', 'of', 'do', and 'let' and it's not mandatory.
13:58:28 <Lunar^> What's the difference between (^) and (^^) ?
13:58:36 <Darius> @type (^)
13:58:36 <lambdabot> (^) :: (Num a, Integral b) => a -> b -> a
13:58:40 <Darius> @type (^^)
13:58:40 <lambdabot> (^^) :: (Fractional a, Integral b) => a -> b -> a
13:58:47 <Darius> @type (**)
13:58:47 <lambdabot> (**) :: Floating a => a -> a -> a
13:59:03 <Lunar^> Only types ?
13:59:21 <Riastradh> @prelude (^)
13:59:21 <Marvin--> ** is implemented in a different way
13:59:23 <lambdabot> *** "(^)" prelude "Haskell Standard Prelude Dictionary": text follows
13:59:23 <lambdabot> (^)
13:59:23 <lambdabot>   infixr 8 ^
13:59:23 <lambdabot>   (^) ::  (Num a, Integral b) => a -> b -> a
13:59:24 <lambdabot>   x ^ 0           = 1
13:59:26 <lambdabot>   x ^ n  | n > 0  = f x (n-1) x
13:59:28 <lambdabot>   		  where f _ 0 y = y
13:59:30 <lambdabot>   			f x n y = g x n where
13:59:32 <lambdabot> [5 @more lines]
13:59:46 <Riastradh> But all you needed were the types, anyways.
13:59:49 <Marvin--> meh, not the simplest possible implementation
14:00:01 <Lunar^> I have the definitions in front of my eyes, I'm reading the prelude again ;)
14:00:09 <Darius> Lunar^:  Yes, they all do more or less the same thing, but obviously it can be done more efficiently if you restrict the types some.
14:00:20 <Lunar^> understood, thanks
14:00:35 <Marvin--> basically, ^ and ^^ are implemented with repeated multiplication, whereas ** is more general
14:00:49 <Marvin--> and implemented with exp and log or something like that I guess
14:01:13 <Darius> I wonder if three different functions are necessary with multiparameter type classes.
14:04:01 <Meep> i think they are, because you could, say, have a type which implemented Integral and Fractional
14:04:43 <Meep> if that makes any sense...
14:16:50 * Cale is away: going to waterloo to clean up my old apt and get it ready for moving stuff on the 30th
14:22:13 <tomasso> when i load a file with a function of the form:
14:22:15 <tomasso> and :: Bool -> Bool -> Bool
14:22:23 <tomasso> it returns:
14:22:32 <tomasso> ERROR "practica1.hc":29 - Syntax error in expression (unexpected `;', possibly due to bad layout)
14:22:37 <tomasso> what am i doin wrong ?
14:30:35 <Meep> that's probably another indentation error
14:33:11 <tomasso> hahaha mhmh
14:48:47 <tomasso> this is an emergency, can anyone tell me what let, in, where mean in haskell??
14:49:07 <Riastradh> let x = y in z   binds the value y to the variable x in the expression z
14:51:26 <Riastradh> z where x = y    is similar to    let x = y in z    but 'where' can be placed in many more places than 'let'
14:52:46 <tomasso> hhmmh and in f x = let (y,z) = (x,x) in y ? hmmh
14:53:32 <tomasso> i think i see...hhm
14:54:42 <Riastradh> Both 'let' and 'where' let you do pattern matching.
14:55:05 <tomasso> im understending
14:55:17 <tomasso> that thing seems to be powerfull
14:57:48 <tomasso> i understend now what let in and where do
14:58:48 <tomasso> now, if you were me, how would you redefine f x = let (y,x) = (x,x) in y  without using let  and in ?
14:59:05 <Riastradh> f x = x
14:59:33 <tomasso> do i have to go trough the expresion y and every time i find (y,x) replaze it by (x,x) ?
14:59:56 <Riastradh> let (y,x) = (x,x) in ...   binds y to x and x to x in ...
15:00:02 <tomasso> hmhm f x = x???  why??
15:00:24 <Riastradh> Evaluate 'let (x,y) = (5,3) in x' in Hugs or GHCi or something.
15:02:02 <tomasso> hmmh
15:03:11 <Riastradh> What does it produce?
15:03:17 <tomasso> 5
15:03:32 <tomasso> (i see in), but..
15:04:02 <tomasso> i understand
15:04:24 <Riastradh> What does 'let (x,y) = (5,3) in y' produce?
15:05:17 <tomasso> 3 :)
15:05:32 <tomasso> THANK YOU
15:27:52 <tomasso> just one more question,
15:28:19 <tomasso> how would you redefine the function power4 x = let sqr y = y * y in sqr (sqr x) using where ?
15:28:57 <Riastradh> power4 x = sqr (sqr x) where sqr y = y * y
15:29:32 <tomasso> hahaha thank you  again
15:48:45 <andersca> 1st jolta
15:48:46 <tomasso> how do i write nested comments in haskell?
15:49:07 <Jolta> andersca: Eh... 1st? "take 1 jolta"?
15:49:19 <Jolta> or rather "head jolta"
15:50:12 <Lunar^> tomasso: {- toto {- blip -} blup -}
15:50:33 <Lunar^> tomasso: But most colorizers goes wrong
15:50:38 <tomasso> like pascal thanx
15:58:37 <tomasso> and :: Bool -> Bool -> Bool returns ERROR "practica1.hc":66 - Syntax error in expression (unexpected `;', possibly due to bad layout)
16:01:03 <Lunar^> Something is wrong in your indentation
16:01:48 <Lunar^> Anyway, if you have any doubt, you can make it explicit
16:02:08 <Lunar^> case foo of { bar -> True ; _ -> False }
16:02:15 <Lunar^> same for the do notation
16:02:49 <tomasso> mhmh talking on identatiion
16:02:53 <Lunar^> btw, Haskell files are labeled .hs usually
16:04:48 <tomasso> cannot find any place to lear its rules
16:06:13 <Lunar^> I need code to see what's wrong
16:11:16 <tomasso> Lunar, here it is http://168.226.148.145/practica1.hs
16:13:06 <Lunar^> Drop all your tabs before functions definition
16:13:10 <Lunar^> see my private reply
16:26:50 <tomasso> l
16:28:13 <Jolta> k
16:30:54 <petete> hello ??
16:32:22 <petete> i need to know how to code a random function
16:32:33 <petete> does anyone have any idea??
16:34:59 <mattam> random x = ...some random code... ?
16:35:05 <mattam> :)
16:35:18 <petete> HAHAHHAHAHAHA
16:35:44 <petete> given an interval, it has to return a random value
16:36:20 <petete> hmh is there any way to use the cpu's clock, or smth from haskell??? i think its the only way...
16:36:40 <mattam> well, look in the library doc
16:37:03 <petete> and i think that a random function is NOT a function
16:37:32 <petete> because for one element of the domain exists more than one element in the codomain
16:38:36 <Lunar^> ??
16:38:42 <mattam> exists more ?
16:38:49 <Lunar^> GHC have System.Random module
16:39:10 <mattam> petete: forget my question
16:39:19 <Lunar^> randomIO :: IO a (think I miss a class here)
16:39:39 <petete> hmhm
16:39:54 <Lunar^> If you want something really random, you'll need to work in the IO monad
16:40:09 <Lunar^> Thus, you may want to use unsafePerformIO if you need to be out of it
17:00:39 <Lunar^> petete: Did you find it ?
17:05:12 <petete> is this ok?
17:05:15 <petete> let a = mod x 10 and b = mod a 10
17:07:05 <Lunar^> What do you mean ?
17:07:21 <petete> sintactically
17:08:11 <Lunar^> You don't need "and"
17:08:25 <Lunar^> Just align a and b
17:08:34 <petete> just let a = mod x 10 b = mod a 10  ??
17:09:07 <Lunar^> If you want it to be single lined write it let { a = mod x 10 ; b = mod a 10 }
17:09:29 <Lunar^> but you can use indentation
17:09:47 <petete> indentation and braces are the same?
17:10:02 <Lunar^> yes
17:10:07 <petete> hhm
17:10:20 <petete> i see
17:10:35 <petete> and without braces it should be:
17:10:37 <petete> let
17:10:45 <petete>   a = mod x 10
17:11:01 <petete>   b = mod a 10
17:11:03 <petete> ??
17:11:47 <Lunar^> It should work. But I would not put a newline between let and a
17:12:02 <Lunar^> style anyway
17:12:31 <petete> hmm ok, where can i find more info on indentation rules? there is nothing on some tutorials
17:13:21 <polli> petete: are you using emacs?
17:13:21 <Lunar^> dunno exactly
17:13:37 <Lunar^> It's so simple that you get it just by looking at 2-3 examples
17:13:44 <petete> not using emacs
17:14:01 <polli> petete: nevermind then :)
17:14:05 <petete> mhhm examples??
17:14:37 <Lunar^> In the Prelude and standard librairies there's a lot of example
17:15:03 <Lunar^> You should know the Prelude anyway if you want to use Haskell
17:15:35 <petete> Ok
17:16:03 <Lunar^> functions like fold, map, all list manipulation, monads are so tied with the language
17:16:13 <petete> ok
17:16:22 <Lunar^> http://www.haskell.org/onlinereport/standard-prelude.html
17:16:38 <Lunar^> Do not worry if you don't understand anything
17:16:39 <petete> le me check
17:17:13 <Lunar^> This is really like a fog at first sight
17:17:47 <petete> it is HEHEH
17:17:51 <Lunar^> Then after your mind goes through the swamp of functionnal programming, you start rewriting code fragments with the Prelude enlightenment
17:17:52 <petete> it uses classess!!!!
17:18:01 <petete> what classes!!??
17:18:06 <Lunar^> type classes
17:18:25 <Lunar^> These are not the same as object classes
17:18:27 <Lunar^> Not at all
17:18:34 <Lunar^> It's more like Java interfaces
17:20:31 <petete> mhhm never written java code...
17:21:18 <Lunar^> anyawy, type classes just say that some types have things in common
17:21:31 <Lunar^> One of Haskell simpliest type class is "Show"
17:21:59 <Lunar^> It means that you can convert this type into a String using the function "show" 
17:22:10 <Lunar^> @prelude show
17:22:11 <lambdabot> *** "show" prelude "Haskell Standard Prelude Dictionary": text follows
17:22:11 <lambdabot> Show
17:22:11 <lambdabot>   class Show a where
17:22:11 <lambdabot>       show      :: a -> String
17:22:12 <lambdabot>       showsPrec :: Int -> a -> ShowS
17:22:14 <lambdabot>       showList  :: [a] -> ShowS
17:22:16 <lambdabot>       -- Minimal complete definition: show or showsPrec
17:22:18 <lambdabot>       show x          = showsPrec 0 x ""
17:22:20 <lambdabot> [16 @more lines]
17:22:26 <Lunar^> Just look at the first def
17:22:54 <Lunar^> Int is a type which belongs to the Show class
17:23:25 <Lunar^> together with String, Char, Float, Bool, ...
17:27:50 <Pseudonym> Type classes are actually more like CORBA/COM interfaces than Java interfaces.
17:28:37 <Pseudonym> But even then, they're not.
17:28:45 <Pseudonym> Type classes are like type classes. :-)
17:30:59 <Lunar^> Pseudonym: I don't know neither CORBA nor COM, so it's the best analogy I could found
17:31:22 <Pseudonym> Fair enough.
17:31:35 <Pseudonym> There are two critical differences between Java-like interfaces and type classes.
17:31:56 <Pseudonym> One is that Java-esque interfaces must be attached to a type where the type is declared.
17:32:03 <Pseudonym> Type classes can be attached anywhere.
17:32:23 <Pseudonym> So in Haskell you can extend a type with a new interface after the fact.
17:32:34 <Lunar^> I see
17:32:43 <Pseudonym> This is very, very powerful.
17:33:18 <Lunar^> What is the other ?
17:33:23 <Pseudonym> The other difference is that because a type class is a constraint on a type, it doesn't support subclass polymorphism directly.
17:33:34 <Pseudonym> To translate that into English...
17:34:09 <Pseudonym> Suppose you have a class Dictionary which is the class of dictionary types (e.g. binary search trees, hash tables etc).
17:34:24 <Lunar^> k
17:34:29 <Pseudonym> Ignoring the parametric polymorphism for the moment, you might write this:
17:34:35 <Pseudonym> class Dictionary d where { etc etc }
17:34:49 <Pseudonym> Then if you want to use it:
17:35:00 <Pseudonym> f :: (Dictionary d) => {- something involving d -}
17:35:25 <Pseudonym> Now this doesn't mean "d is a Dictionary", it means "d is a type which supports the operations of Dictionary".
17:35:49 <Pseudonym> There is a difference.
17:35:59 <Pseudonym> If you consider, for example, this type:
17:36:04 <Pseudonym> (Dictionary d) => [d]
17:36:11 <Pseudonym> That doesn't mean "a list of Dictionaries".
17:36:16 <Lunar^> Ok
17:36:20 <Lunar^> I see exactly
17:36:29 <Pseudonym> It means "a list, all members of which are the SAME TYPE, where that type is a Dictionary".
17:36:48 <Pseudonym> If you wanted a list of dictionaries, you'd have do something else.
17:36:54 <Pseudonym> e.g. use higher-ranked types
17:37:19 <Lunar^> Thanks for making it clear
17:37:28 <Pseudonym> As a result, there is one feature which you'll find in OO languages for which there is basically no support in Haskell, and that's dynamic downcasting.
17:37:39 <Pseudonym> In Java, if you have:
17:37:44 <Pseudonym> public Foo implements Bar
17:37:47 <Pseudonym> Or something
17:38:09 <Pseudonym> Then if you have a Bar, you can cast it to a Foo.  (The cast might fail at run-time, but you'll be able to catch it).
17:38:15 <Pseudonym> You can't do that in Haskell
17:40:29 <Pseudonym> Mind you, you almost couldn't do it in C++ either.  Dynamic downcasting was opposed by the standards committee, but they relented because users wanted it so much.
17:52:05 * Cale is back (gone 03:35:14)
18:10:28 <Lunar^> You can do that in Haskell using Dynamic I think
18:11:06 <Pseudonym> No.
18:11:24 <Pseudonym> Using Dynamic, you can recover a concrete type, but not a typeclass instance.
18:11:43 <Pseudonym> Believe me, I know.  I tried. :-)
18:11:50 <Lunar^> uh... still improvement for typesystems so :)
18:12:00 <Pseudonym> Well, kind of.
18:12:26 <Lunar^> Type classes are powerfull, but they seem to put a lot of noise around typesystem theories
18:12:33 <Pseudonym> What You Want(tm) (I am one of the world's foremost experts on What You Want, incidentally) is a typeclass which you _can_ attach to a type where it's declared.
18:12:53 <Pseudonym> Or, perhaps, a way to do this with newtype.
18:13:01 <Pseudonym> Hey, that's not a bad idea.
18:13:04 <Pseudonym> Hmmm.
18:13:04 <Lunar^> Actually I don't want anything. I never has been limitated by Haskell for the moment
18:13:21 <Pseudonym> Yeah.  Fact it, I haven't missed dynamic downcasting.
18:13:59 <Pseudonym> Most of the uses for dynamic downcasting in languages like Java or C++ are when you're trying to simulate algebraic data types.
18:14:00 <Lunar^> And I'm in the middle of my first real program in Haskell (1400 lines now)
18:14:23 <Lunar^> Pseudonym: In Java, every container class forces use of downcasting
18:14:29 <Pseudonym> I've hit my head on some of the limitations of Haskell once or twice.
18:14:33 <Pseudonym> Oh, yes, that's true.
18:14:47 <Pseudonym> Because Java has no parametric polymorphism thing.
18:14:55 <Pseudonym> Java Generics, or whatever it's going to be called.
18:14:59 <Lunar^> yep
18:15:06 <Pseudonym> OK, I'll rephrase:
18:15:29 <Pseudonym> Most of the uses for dynamic downcasting in Java/C++ are when you're trying to simulate something else, which is easier to do some other way in Haskell.
18:16:33 <Lunar^> http://lune.talath.net/cgi-bin/darcs/darcs?recofax*./src/Sql.hs*Fix_Sql_module_DATETIME_handling.-lunar9lautre.net-Fri_Aug_22_14.51.01_CEST_2003*./src/Sql.hs*Initial_revision.-lunar9lautre.net-Thu_Aug_21_21.30.52_CEST_2003 <-- this make use of GHC exts to Haskell type system in a way that it blow my mind
18:16:51 <Pseudonym> Eeek!
18:16:54 <Lunar^> (one of my friend wrote it for my project, sources are not meant to be public)
18:17:05 <Pseudonym> I bet your friend didn't write that URL. :-)
18:17:17 <Lunar^> darcs' url
18:17:30 <Lunar^> Darcs is really nice but lack a real web interface
18:18:22 <Pseudonym> Nice!
18:19:03 <Lunar^> The original printf was posted on some ghc list
18:19:07 * Pseudonym nods
18:19:17 <Lunar^> instance (SqlFormat a, SqlRequest b) => SqlRequest (a -> b) where
18:19:30 <Lunar^> ^--- This is crazyness :)
18:19:38 <Pseudonym> Not really.
18:19:45 <Pseudonym> This is a pretty old technique, actually.
18:19:55 <Pseudonym> Before monadic IO there was continuation based IO.
18:20:05 <Pseudonym> main :: [Response] -> [Request]
18:20:38 <Lunar^> type classes appeared before monads ?
18:20:46 <Pseudonym> Let me think...
18:20:51 <Pseudonym> Yes.
18:21:04 <Pseudonym> Type classes appeared before constructor classes.
18:21:19 <Pseudonym> Technically, type classes and constructor classes are actually different.
18:21:26 <Pseudonym> But we now just call them both "type classes".
18:21:47 <Pseudonym> http://citeseer.nj.nec.com/jones95system.html
18:21:49 <Pseudonym> If you're curious.
18:22:02 <Lunar^> Yes I am. :)
18:22:43 <Pseudonym> Constructor classes you can think of as type classes extended to higher kinds.
18:22:50 <Pseudonym> You know what a "kind" is?
18:23:00 <Lunar^> *, -> and # in Haskell right ?
18:23:10 <Pseudonym> Well, # is GHC-specific, but yes.
18:23:32 <Pseudonym> It's the "type of types".
18:23:45 <Pseudonym> So, for example, "Maybe" has kind * -> *
18:23:52 <Pseudonym> Because it takes a type and returns a type.
18:25:36 <Pseudonym> Have you ever had a browse through the "CommonHaskellIdioms" section of the wiki?
18:25:44 <Lunar^> This gets clearer mpw
18:25:47 <Lunar^> now
18:25:48 * Pseudonym nods
18:26:32 <Lunar^> I'm going to
18:26:45 <Pseudonym> I suspect that a lot of them are less "common" than the name suggests.
18:26:53 * Pseudonym must share some of the blame for this
18:27:17 <Lunar^> Is there any page about "our small functions for everyday use" ?
18:27:28 <Pseudonym> Er...
18:27:39 <Pseudonym> What kind of small functions do you mean?
18:27:50 <Lunar^> like rMap fs x = map ($ x) fs ?
18:28:09 <Lunar^> which applies a list of function to the same value..
18:28:24 <Pseudonym> Not that I know of.
18:28:38 <Lunar^> Think I'm going to start it after the end of my project
18:28:45 <Pseudonym> Cool.
18:28:57 <Lunar^> getting new ideas that way
18:29:47 <Lunar^> I really want to work on arrows also. The papers I read (Fruit especially) really got me saw possibilities
18:29:52 <Lunar^> But we really need an editor
18:30:07 <Lunar^> Arrows should be handled graphically I think
18:30:19 <Pseudonym> My personal take is that if you need a special editor, programmers shouldn't use it natively.,
18:30:31 <Pseudonym> I realise I may be in a minority here. :-)
18:30:43 <Pseudonym> BTW, this freaked me out first time I saw it: http://haskell.org/hawiki/TheZipper
18:31:55 <Lunar^> I met one of the developper behing this project :
18:32:16 <Lunar^> http://freespeech.sourceforge.net/overflow.html
18:32:33 <Pseudonym> Interesting.
18:32:35 <Lunar^> It's C++ but it's a graphical editor for flow based algorithms
18:34:30 <Lunar^> I want to make a Debian package for it
18:34:33 <Lunar^> got to find the time
18:34:47 <Pseudonym> I'm going to need some speech processing stuff soonish.
18:34:54 <Pseudonym> This looks like an interesting thing.
18:35:09 <Lunar^> :)
18:37:55 <Pseudonym> I was really happy last week.  Someone posted a homework problem to haskell-cafe.
18:38:34 <Pseudonym> I have a long proud history of homework trolling in comp.lang.prolog style.
18:39:03 <Pseudonym> Meaning you give an answer which is a 100% correct answer to the homework question which is about 1% useful.
18:39:40 <Lunar^> example ?
18:39:55 <Pseudonym> Let me see...
18:40:35 <Pseudonym> http://www.haskell.org/pipermail/haskell-cafe/2003-August/004978.html
18:40:41 * Pseudonym is particularly proud of that one
18:41:20 <Lunar^> in terms of trolling?
18:41:38 <Pseudonym> "Trolling" perhaps isn't quite the right word.
18:43:02 <Lunar^> if you mean that it's only a working answer which doesn't let you learn anything I understand
18:43:08 * Pseudonym nods
18:43:17 <Pseudonym> Actually, the code is really, really efficient.
18:44:00 <Pseudonym> Just almost completely impenetrable.
18:44:03 <Lunar^> I stopped maths 4 years ago now, so I don't know neither what exactly is Pascal triangle nor algotithms to write it
18:44:16 <Pseudonym> Well, if it helps, my first solution was two lines long.
18:44:32 <Lunar^> But here, I even don't see exactly what techniques this code involves
18:44:48 <Pseudonym> Well, the "swing" function actually computes factorial.
18:44:57 <Pseudonym> Believe it or not.
18:45:59 <Pseudonym> Most of the code in pascalLine actually does memoisation.
18:46:08 <Lunar^> lol
18:46:10 <Pseudonym> If you call pascalLine 10000, say, it will run slow.
18:46:14 <Pseudonym> The second time, it runs fast. :-)
18:46:38 <Lunar^> a FiniteMap would have made the trick
18:46:45 <Pseudonym> No, it wouldn't.
18:46:53 <Pseudonym> Because pascalLine takes an Integer argument.
18:46:56 <Pseudonym> FiniteMap is finite.
18:47:02 <Lunar^> uhhh ok
18:47:06 <Pseudonym> The memo structore in pascalLine is infinite.
18:47:58 <Pseudonym> But it's efficient.  Looking up a value n takes O(log n) time.
18:48:09 <Lunar^> see that
18:48:43 <Pseudonym> recProd is actually fairly straightforward.
18:49:03 <Pseudonym> It computes b*(b+1)*...*(b+n-1)
18:49:19 <Pseudonym> Except that it uses a divide-and-conquer algorithm for speed.
18:49:41 <Lunar^> ... did someone post what you're explaning to me right now ?
18:49:48 <Pseudonym> Yes, that was me.
18:50:57 <Lunar^> Ok :) Because I was thinking that I maybe not the most interested in this kind of explanation
18:51:02 <Pseudonym> :-)
18:51:08 <Pseudonym> Fair enough.
18:51:16 <Pseudonym> I'm just trying to avoid w*rking.
18:51:21 <Lunar^> hehe :)
18:51:57 <Smerdyakov> Pseudonym doesn't like his job because he works for the Man.
18:52:04 <Pseudonym> Yes.
18:52:15 * Pseudonym works for the Millitary-Industrial Complex(tm)
18:52:25 <Lunar^> hehe
18:54:03 <Pseudonym> Actually, I do like my job.
18:54:20 <Pseudonym> I'm surrounded by a lot of smart people, I have no personality clashes with any of them, and none of them are stupid.
18:54:35 <Pseudonym> I wear what I like, I work whatever hours I like...
18:54:55 <Lunar^> But you do not feel well about who could use what you doing ?
18:55:01 <Lunar^> (or for what)
18:55:10 <Pseudonym> I know full well who uses what I'm doing.
18:55:17 * Pseudonym does tech support for them occasionally
18:55:25 <Pseudonym> I don't know what they're doing, exactly.
18:56:17 <Pseudonym> But they're not our only clients.
18:56:45 <Pseudonym> We also, for example, work on projects to let the public access government information, like legislation.
18:57:32 <Pseudonym> You use the same software to do that, as you do to manage maintenance documentation for warships.
18:58:06 <Pseudonym> I figure it's the price of freedom.
18:58:21 <Pseudonym> Freedom of speech means freedom of speech that you hate.
18:58:43 <Pseudonym> Open source software has the same dilemma.
18:58:57 <Pseudonym> To a lesser extent, so does proprietary software.
18:58:59 <Lunar^> Voltaire said "I hate what you're saying but I will fight for you to do so"
18:59:03 <Pseudonym> Right.
18:59:17 <Pseudonym> At least that's what I tell myself.
18:59:32 <Pseudonym> Most of the time I just tell myself "Oooh!  Cool tech!"
18:59:36 <Lunar^> Look at the freenet project
19:00:11 <Lunar^> It allows chinese dissident to spread informations, but it also allows pedophiles to trade pictures
19:00:16 * Pseudonym nods
19:00:55 <Lunar^> I'm going to be now... cya
19:01:19 <Pseudonym> Night.
19:28:00 <petete> how do i switch to haskell mode using emacs???
19:29:19 <Riastradh> M-x haskell-mode
19:29:38 <petete> let me check
19:29:46 <Pseudonym> There should be some magic you can put in a comment which does it, too.
19:30:25 <Riastradh> On the first line of a file, put:  -- -*- mode: Haskell -*-
19:31:01 <petete> is there any tool to autoindent a haskell source written using other editor?
19:31:03 <Riastradh> Or put in your .emacs:  (setq auto-mode-alist (append '(("\\.hs" . haskell-mode) ("\\.lhs" . literate-haskell-mode)) auto-mode-alist))
19:31:52 <Riastradh> petete, what do you mean 'written using other editor?'
19:32:46 <petete> i wrote a haskell source using kate, and i would like to indent it properly
19:33:34 <Pseudonym> How big is the program?
19:34:14 <petete> most lines are comments
19:34:30 <petete> they are just function definitions... more or less 90 lines
19:34:36 <Pseudonym> OK.
19:34:59 <Pseudonym> I don't know about emacs, but VI has a command to move blocks of text left and right.
19:35:13 <Pseudonym> For 90 lines, that's goign to be easiest, I think.
19:35:28 <Pseudonym> Just do it by hand, using whatever commands help for shifting blocks of text around.
19:35:29 <petete> hmmh...
19:35:48 <petete> what are the features the haskell mode offers?
19:36:25 <Riastradh> The problem with having a program to indent a Haskell file in one go is that with Haskell's 'layout' stuff, different indentations have different semantics.
19:36:26 <Pseudonym> I suspect that most of the features relate to when you're typing in code.
19:36:47 <Pseudonym> Riastradh: While that's true, I'm not sure that it matters.
19:36:54 <Pseudonym> Fact is, you can always check your answer.
19:37:12 <Pseudonym> Parse the first version, parse the second version, see if there's a difference.
19:37:21 <petete> hhmhm
19:37:33 <Pseudonym> But yes, it would be hard to write.
19:38:53 <Pseudonym> I think for 90 lines, it's best to do it by hand.
19:39:13 <petete> (the problem is that dont know how to do it..)
19:39:30 <Pseudonym> Well, you'll be using "delete" and "tab" a lot. :-)
19:39:39 <petete> mhm
19:40:11 <Riastradh> In Emacs, with haskell-mode, it has a feature whereby if there be any possible ambiguity for various indentations it cycle through each one.
19:42:47 <Pseudonym> Must go for a walk.  BBL
