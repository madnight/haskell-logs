00:00:18 <Pseudonym> Oh, hang on.
00:00:21 <Pseudonym> No, that's the wrong one.
00:00:50 <Marvin--> I've tried to have a look at existing open source indexing/querying engines, but I haven't found any that supports everything that we want to do, and I have *no* idea how much work it'd be extending one compared to writing our own from scratch
00:01:05 <Pseudonym> Did you have a look at the mg source code?
00:01:25 <Marvin--> yeah, somewhat, the biggest problem with it is that it has no unicode support at all, as far as I could see
00:01:30 * Pseudonym nods
00:01:31 <Pseudonym> That's true.
00:01:38 <Pseudonym> Also, the code is crap.
00:01:45 <Pseudonym> I know.  My boss wrote most of it.
00:01:48 <Marvin--> heh
00:02:04 <Pseudonym> He's improved orders of magnitude since then. :-)
00:02:19 <Marvin--> I've been looking at mnoGoSearch and Namazu, they seem to have some decent support for i18n (seeing as mno is a Russian project and Namazu a Japanese...)
00:02:36 <Pseudonym> All I can show you is stuff to help you roll your own.
00:02:45 * Pseudonym doesn't know much about the small off-the-shelf systems
00:03:25 <Marvin--> right
00:03:38 <Marvin--> I guess I should have a closer look at the open source ones and see what indexing methods they use et.c.
00:03:43 * Pseudonym nods
00:04:35 <Marvin--> heck, Namazu didn't even support stop words
00:04:43 <Marvin--> that was quite surprising
00:05:15 <Pseudonym> Interesting.
00:05:31 <Pseudonym> Though our philosophy is not to use stop words if you can afford it.
00:05:48 <Pseudonym> They're useful in phrase queries, for example.
00:05:52 <Marvin--> yeah
00:06:04 <Pseudonym> And they compress really well.
00:06:21 <Marvin--> well, the list of stop words will be configurable of course, it's probably sane to drop stop words from non-phrase queries
00:06:30 * Pseudonym nods
00:08:01 <shapr> was that the boss key?
00:09:33 <Marvin--> man, big X fuckage
00:11:36 <shapr> ok, time to go home and sleep.
00:12:21 <Pseudonym> Night.
00:12:23 <Pseudonym> Go sleep.
00:13:02 <kosmikus> good morning :)
00:13:21 <Marvin--> shapr: grmbl, I just went to work
00:13:22 <Pseudonym> Just about time for me to go home, actually.
00:15:50 <Marvin--> Pseudonym: thanks for the pointers, though I managed to crash mid-talking, I'll look at the list of papers
00:16:20 <Pseudonym> No problem.  Have fun.
00:16:30 <Marvin--> crappy WindowMaker and its crappy race conditions or something
00:42:11 <Marvin--> any comonad revelations since I went to bed last night?
00:58:03 <Pseudonym> Were you asking anyone in particular?
01:00:45 <Marvin--> not really, I guess the involved people aren't here yet :) well, except for cale
01:00:52 <inkedmn> are haskell people generally also emacs people?
01:01:08 <Pseudonym> About the same proportion as anyone else, I would think;.
01:01:16 <inkedmn> hmm
01:01:20 * Marvin-- is a vim people
01:01:24 * inkedmn is also
01:01:27 * Pseudonym is also a vim people
01:01:47 <inkedmn> because the wiki has a page about a haskell editor that is supposed to "replace emacs"
01:01:52 <Pseudonym> There may be a marginally higher proportion because emacs has a functional language as its scripting system.
01:02:03 <inkedmn> hmm
01:02:05 <Pseudonym> OTOH, there's the factor that more people are taught vi at university.
01:02:16 <inkedmn> really?
01:02:19 <inkedmn> wasn't aware of that
01:02:21 <Pseudonym> I believe so.
01:02:22 <Marvin--> here it's emacs
01:02:26 <Pseudonym> Interesting.
01:02:33 <Marvin--> but I was a vim user before I came to univ
01:02:41 <Pseudonym> At any rate, I suspect the proportions are probably the same as in the wider geek community.
01:02:45 <cale> At my uni, they show us both.
01:03:01 <Pseudonym> We were force-fed vi as an undergrad.
01:03:07 <cale> I was also already hooked on vim.
01:03:12 <Pseudonym> Mind you, emacs was considered very resource-hungry at the time.
01:03:42 <Marvin--> I was thinking, does it really matter whether we fork the IO (Char,Char) "token" or not, since we use .>> which is supposed to ensure sequentiality
01:03:47 <Pseudonym> 100 undergrads all running emacs on a 1990-era server wouldn't be fun.
01:03:53 <inkedmn> heh
01:04:15 <inkedmn> i've honestly barely even given emacs a fair shake
01:04:32 <cale> inkedmn: I think the comment on the wiki regarding such an editor is only trying to get across the fact that it should be programmable.
01:04:40 <inkedmn> ah, ok
01:05:00 <Pseudonym> I think that it doesn't matter which editor you use so long as a) it's decent, and b) you know it well.
01:05:07 <Pseudonym> I wouldn't go back to vi after using vim, for example.
01:05:08 <inkedmn> yeah
01:05:13 <Marvin--> Pseudonym: indeed
01:05:17 <inkedmn> agreed
01:05:38 <cale> Having muscle-memory for your editor's keys tends to make switching hard.
01:06:09 <Marvin--> (and obviously I mean OI (Char,Char) not IO (Char,Char)
01:07:18 <inkedmn> Pseudonym: ok, about that stuff you gave me earlier (to read/try to implement)...
01:07:40 <Pseudonym> Yes?
01:07:41 <inkedmn> i just finished implementing my own versions of "map" and "filter" :)
01:07:45 <Pseudonym> :-)
01:07:46 <Pseudonym> I see.
01:07:49 <inkedmn> (just to give you an idea where i'm at)
01:08:12 <Pseudonym> Guess that wasn't so helpful, then.
01:08:22 <inkedmn> heh, you had no way of knowing :)
01:08:36 <inkedmn> i'm very much a beginner (at FP/Haskell)
01:09:08 <inkedmn> though i'm pretty comfortable with python/java
01:09:12 <Marvin--> ``External sorting with on-the-fly compression''  this could be interesting
01:11:21 <Pseudonym> imkedmn: Still, did you find that stuff interesting? :-)
01:11:53 <inkedmn> honestly, the vast majority of it flew right over my head
01:12:57 <Marvin--> what stuff?
01:13:52 <Marvin--> Pseudonym: btw, 'Gigabytes talks very little about dynamic collections, surely there has been research on that?
01:14:41 <Pseudonym> Yes.  Our system is a dynamic system, for example.
01:15:38 <Pseudonym> There are basically two things you need to worry about: 1) Use funky file formats, and 2) Use static codes.
01:15:53 <Pseudonym> We, for example, store our lexicon in a B-tree rather than using perfect hashing.
01:15:55 <Marvin--> I mean, obviously it's hard to update the index in real time so you keep a secondary index and then merge when the system is under less load...
01:16:09 <Pseudonym> And we use gzip rather than word-based huffman coding.
01:16:21 <Pseudonym> And we use gamma codes rather than Golomb coding.
01:16:34 <Marvin--> hmm, interesting, how is the B-tree stored on-disk?
01:16:38 <Pseudonym> Though we should use variable byte coding.
01:17:06 <Pseudonym> Oh, the normal way.  You split a file into pages and store one node per page.
01:18:21 <Marvin--> I know very little about this...
01:18:23 <Pseudonym> You know, a B-tree. :-)
01:18:26 <Pseudonym> Oh, OK.
01:18:28 <Pseudonym> Uhm...
01:18:35 <Marvin--> well, I know what a B-tree is
01:18:38 <Pseudonym> Right.
01:18:46 <Pseudonym> Well, it's one of those. :-)
01:19:04 <Pseudonym> Each internal page is basically a whole lot of (key,pointer) pairs.
01:19:40 <Marvin--> what do you mean page?
01:19:47 <Marvin--> (this may just be a terminology problem..)
01:20:13 <Pseudonym> Well a "page" in this sense is any convenient multiple of the disk block size and VM page size.
01:20:32 <Pseudonym> The VM page size is important because we use mmap() to access the btree file.
01:21:23 <Pseudonym> There are good reasons for that, BTW.
01:21:40 <Pseudonym> But anyway, it's just a fixed size which we use to carve up the file space.
01:21:59 <Marvin--> oh
01:22:26 <Pseudonym> The term "page" is historical, from the days when you could have stream files or random-access files.
01:23:12 <Pseudonym> For the postings entry, we have a variable-length record manager.
01:23:17 <Pseudonym> entries
01:23:24 <Pseudonym> Which again works on pages.
01:24:25 <Pseudonym> But it basically gives you a way to turn "pointers" into variable length records.
01:24:26 <Pseudonym> Because postings entries can be of varying lengths.
01:24:26 <Pseudonym> Oh, we also use the VLRM to store the actual documents.
01:25:40 <Pseudonym> The postings entries themselves are actually reference-counted.
01:26:25 <Pseudonym> Because we can have one user inserting while anoher one is querying concurrently, you actually copy the entry and work on that.
01:28:10 <Marvin--> http://yro.slashdot.org/article.pl?sid=03/06/18/2328233&mode=nested   okay, now I'm scared
01:28:30 <Pseudonym> That's pretty bizarre.
01:28:35 * Pseudonym has to go home
01:28:38 <Pseudonym> My family awaits.
01:29:27 <cale> And I thought that Sweden was a pretty sensible country, too.
01:29:35 <Pseudonym> Night everyone.
01:30:54 <Marvin--> cale: that's what I thought too :-/
01:37:13 <Marvin--> ah, phew, the article makes it sound much worse than it actually is
01:38:22 <Marvin--> it's still legal to copy legally obtained media for fair use, it's still legal to "circumvent" encryption on legally obtained media for the purpose of using the medium (but not for the purpose of illegally redistributing it)
01:38:41 <Marvin--> i.e. you can still use decss, and you can still have a region-free dvd player
01:39:59 <Marvin--> oh, and it makes it explicitly illegal to claim "fair use" when you're copying something that hasn't been legally obtained
01:45:51 <cale> ah, so mostly just bad /. reporting then
01:46:30 <Marvin--> so all in all, it sounds pretty sensible
01:46:38 <buggs> it's still legal to "circumvent" encryption ?
01:49:48 <Marvin--> still legal to circumvent encryption for the purpose of using the product if you came by it legally
01:49:49 <emu> rot13?
01:49:57 <Marvin--> e.g. using decss
01:50:38 <inkedmn> @type map
01:50:39 <lambdabot> map :: (a -> b) -> [a] -> [b]
01:50:39 <Marvin--> but it won't be legal to circumvent encryption for the purpose of redistributing or for using an illegally obtained product
01:50:43 <Marvin--> or so I understood it
01:50:54 <inkedmn> @hi
01:50:54 <lambdabot> Sorry, I don't know the command "hi", try "lambdabot: @listcommands"
01:51:01 <inkedmn> @listcommands
01:51:01 <lambdabot> I react to the following commands: ["all-dicts","board","define","definitions","del-definition","devils","dict","dict-help","dump","easton","echo","elements","eval","fact","flip-board","foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","lojban","more","msg","part","ply","prelude","quit","reset-chess","resume","set-fuel","st
01:51:03 <inkedmn> wow
01:51:31 <earthy> marvin--: however, eucd requires banning of programs that allow you to circumvent the encryption
01:52:33 <Marvin--> earthy: again, only for the purpose of doing something illegal, is the way I understood it
01:52:59 <earthy> that'd be *extremely* hard to codify correctly into law.
01:53:08 <earthy> ah well...
01:53:17 <Marvin--> yeah
01:53:35 <Marvin--> but it doesn't make sense to allow circumventing encryption without allowing tools that do it
01:53:44 <earthy> yes it does. :)
01:53:58 <earthy> owning, growing, using marihuana is legal in .nl
01:54:05 <earthy> *selling* it isn't officially legal.
01:54:23 <earthy> but, I'm running late... gotta run.
01:54:58 <inkedmn> dude, it seems like the exercises in this tut went from manageable to "wtf?"...
01:55:16 <inkedmn> (going through Yet Another Haskell Tutorial)
01:56:35 <Marvin--> heh
02:05:52 <Marvin--> I wonder if berkely db implements B-trees well enough to use for indexing
02:18:02 <inkedmn> buenos noches
03:52:23 <sjj> hrm, what would be a conventional way to represent an empty node in a binary tree in Haskell? I'm thinking something like, data BinTree a = Node [a] (BinTree a) (BinTree a) | Leaf [a]  and using [] to represent an empty node.
03:53:10 <sjj> I guess the other way would be to use Maybe a ...
03:53:13 <sjj> is there anything nicer?
03:53:45 <cale> data BinTree a = Branch a (BinTree a) (BinTree a) | Leaf
03:54:07 <cale> Or do you need empty nodes anywhere?
03:54:08 <sjj> hrm.
03:54:10 <Heffalump> DYM that your nodes hold data but occasionally you want them not to?
03:54:17 <Heffalump> and do your leaves hold data too?
03:54:45 <sjj> actually I think that's a good solution, having Leaf denote the 'end' so to speak.
03:55:10 <sjj> I guess I was going about it the wrong way ;)
03:56:00 <cale> I thought maybe that's what you needed. :) If you need to have empty nodes anywhere just use BinTree (Maybe a)
05:37:30 <TheDD> hello
05:38:18 <thornber> does 'sort' maintain the ordering for equal elements ?
05:39:16 <Marvin--> if they're equal, who cares? :)
05:39:46 <Marvin--> (no, I don't know whether sort is stable)
05:40:04 <TheDD> i have a question: i use error "msg" when unexcpected things ahappens, but no message are printed on the console
05:40:27 <Marvin--> TheDD: are you sure the unexpected thing did happen?
05:40:35 <TheDD> yes
05:40:49 <TheDD> because i have a trace mode, and in trace mode, the message is printed
05:42:00 <thornber> Marvin--: thx
05:42:01 <esap> maybe your trace mode causes the unexpected thing to occur by forcing some evaluation that would not otherwise happen?
05:42:23 <TheDD> hum
05:43:03 <Marvin--> thornber: not a whole lot to thank for :)
05:43:31 <thornber> well you defined 'stable' for me, which is mentioned in the h98 report :)
05:43:36 <Marvin--> ah
05:43:52 <Marvin--> yeah, "stable sort" means that it preserves the order of equal elements
05:45:34 <cale> does error use stderr for output? how about trace?
05:46:12 <cale> Just wondering whether TheDD's problem might have something to do with redirection.
05:46:42 <TheDD> hum trace is on stderr
05:46:54 <TheDD> error , i don't know
05:47:01 <TheDD> it's a builtin
05:47:14 <TheDD> (i'm new to haskell)
05:48:07 <TheDD> thx, i will search in this direction, i have to leave, i'll be back ;)
05:48:07 <TheDD> ++
06:54:55 <SyntaxPolice> morning all.
06:55:19 <Heffalump> yo
06:55:51 <steveh> morning SyntaxPolice
06:56:21 <SyntaxPolice> hi steveh
06:56:34 <SyntaxPolice> did anyone want a link to more information about that patch to Apt I was talking about?
06:56:44 <Marvin--> what patch?
06:58:22 <SyntaxPolice> Marvin--: to check the authenticity of debs & stuff
07:02:12 <Marvin--> well, I think I'll take off early today seeing as it's midsummer tomorrow
07:02:26 <Marvin--> (as in, now)
07:59:48 <noss> anyone ever written a layout manager that can calculate position for a tree of different layout diciplines, given a maximum bounding box?
08:00:18 <noss> im not be very specific, but i can fill in the details.
08:00:49 <Heffalump> have a look at Haskell pretty-printing libraries
08:01:24 <earthy> and http://www.cs.uu.nl/groups/ST/Software/PP/
08:01:52 <noss> pretty-printing? hmm, from lisp that makes me think about auto-indented output of trees on the console. :)
08:02:24 <earthy> owh, wait, you mean layout as in laying out a tree of graphical objects?
08:02:31 <noss> yah.
08:02:42 <earthy> as in java's GridBagLayout and friends?
08:03:27 <noss> somewhat, yes.
08:03:54 <earthy> can't say I've even heard of it, but honestly, I know zilch.
08:04:20 <noss> i read something about haskell fudgets for doing guis in haskell.
08:04:27 <noss> is that backended in tcl/tk ?
08:04:56 <SyntaxPolice> hm. where do I get Database.PostgreSQL.HSQL to build lambdabot?
08:05:45 <Heffalump> well, I meant just have a look to get an idea of the algorithms used
08:11:13 <dennisb> noss: it's native (old) XWindows
08:12:46 <noss> dennisb: really? there is a haskell binding of the x11 protocol as well?
08:13:32 <dennisb> I don't know what they used, but it's calling xlib or something. I guess thet made the binding themself
08:13:50 <dennisb> but I know it's not using some other toolkit
08:13:59 <noss> cool, it was even funded by a swedish agency.
08:14:20 <tims> Does the following scenario happen a lot?  Someone joins channel.  They shout, "I grok Monads!!!".  They sign off.
08:14:43 <dennisb> tims: not really, maybe in other channels :)
08:15:04 <tims> dennisb: It took me a week but I finally understand them.
08:15:42 <Heffalump> If I ever figure out comonads I'll make sure to do that.
08:16:10 <steveh> "Further, there is no way of explaining how a Monad can be altered in quality or internally changed by any other created thing; since it is impossible to change the place of anything in it or to conceive in it any internal motion which could be produced, directed, increased or diminished therein, although all this is possible in the case of compounds, in which there are changes among the parts."
08:16:13 <steveh> :-P
08:16:53 <SyntaxPolice> tims: congrats!
08:17:52 <tims> thanks
08:20:55 <dennisb> Heffalump: I have a HSQL.hs file, but I don't know where I found it, I thought it was in haskell-libs something, but I can't find it now
08:22:54 <SyntaxPolice> dennisb: you talking to me? :)
08:23:46 <dennisb> SyntaxPolice: of course :-)
08:23:50 <Heffalump> I'm wondering why he's talking to me :-)
08:24:36 <earthy> ah, yes, monads. one other thing I need to put on the `list of stuff to be grokked'. ;)
08:25:41 <dennisb> SyntaxPolice: I could send you my file if you want
08:26:47 <SyntaxPolice> dennisb: sure
08:41:49 <shapr> dennisb: it's from htoolkit.sf.net
08:41:55 <shapr> I think
08:42:13 <SyntaxPolice> shapr: !
08:42:16 <shapr> SyntaxPolice: !
08:42:37 * SyntaxPolice stared at htoolkit for a while and couldn't figure out how to download it or whether it contained the code I was seeking
08:42:49 <shapr> yup
08:42:52 <shapr> that's what @fact uses
08:43:12 <SyntaxPolice> yeah, I was trying to build lambdabot :)
08:43:57 * shapr yawns
08:44:05 <Riastradh> How do the IO systems of Haskell and Clean compare?
08:44:47 <shapr> clean uses uniqueness types
08:45:00 <Riastradh> Which are...?
08:45:12 <shapr> linear types I think
08:45:22 <Riastradh> Which are...?
08:45:34 <shapr> following the american way, they're disposable single-use values
08:46:07 <shapr> I'm not completely sure of that though :-)
08:47:15 <Riastradh> Do you know how to read a character from stdin and write it back out to stdout in Clean?
08:48:31 <Riastradh> (i.e., the Clean equivalent of: main = do { c <- getChar; putChar c } )
08:51:34 <Riastradh> The garbage collector realloc()'d you?
08:51:39 <tims> yes!
08:51:55 <tims> I think I still had a weak reference?
08:53:53 * shapr boings
08:54:06 <shapr> yah, I got a weak reference from my last job ;-)
08:55:00 <steveh> ba-dum-bum
08:55:07 * shapr grins
09:00:08 <hdaume> morning folks
09:00:12 <shapr> hi hal
09:00:45 <hdaume> it's funny....i think this is the one nerdy channel from which i have no fear of getting booted for having a .microsoft.com host :)
09:00:55 * shapr grins
09:01:32 * SyntaxPolice wishes he had ops right now...
09:01:33 <SyntaxPolice> ;)
09:01:39 <hdaume> :)
09:01:54 <steveh> whoa, who boots *!*@*microsoft.com ? or are you being facetious? :)
09:01:54 --- mode: ChanServ set +o SyntaxPolice
09:02:03 <Riastradh> It's for a horrible reason, though -- Microsoft is eating up the research field, by just throwing money all over the place, and in doing so managed to gobble up several major Haskellers.
09:02:18 <hdaume> Riastradh: true
09:02:37 <shapr> microsoft has had some beneficial effects on the PC world
09:02:48 * Riastradh doesn't use x86.
09:02:49 <shapr> the first benefit was hardware standardization
09:03:13 <steveh> Riastradh: I don't think the Haskellers are gone for good... :)
09:03:17 <cale> I think that microsoft would be a much better company if they didn't try to put out so many products :)
09:03:30 <steveh> from what I hear MS has a rather high burnout rate at all levels
09:03:43 <shapr> another benefit is that rich burnouts go into open source
09:03:54 <cale> (They should stick to research.)
09:04:33 <shapr> if you pay the best database designers in the world to write sql server 7.0, they usually end up with enough cash to write software for free
09:12:55 * shapr boings
09:13:01 * shapr bonks vegai 
09:44:00 * shapr bounces happily
09:50:48 <hdaume> hey...i'm using ghcimode in emacs for windows...when i hit Ctrl-A it goes to the real beginning of the line "*Prelude>" at the *...in *nix it used to only go to the end of the ">"...how do i fix this?
09:51:19 <shapr> something about the prompt regexp
09:51:34 <shapr> since I think it's a comint derived mode
09:54:01 <hdaume> i copied my haskell-mode directly from my *nix account...
09:54:08 <shapr> oh
09:55:15 <Vincenz> Hiya
09:55:37 <shapr> y0
10:04:24 <shapr> hdaume: I'd suggest you grab it from haskell.org/haskell-mode
10:04:30 <shapr> maybe that will change something?
10:56:37 * shapr bounces
10:59:39 <TheDD> hello 
10:59:41 <Riastradh> Hi.
11:01:21 <TheDD> i have a problem :/
11:01:28 <Riastradh> State your problem.
11:01:52 <TheDD> when i compile my program with the cmd: ghc -i.:. -odir. -hidir. --make -package data ./Main.hs -o havm
11:02:00 <TheDD> ghc delete Main.hs
11:02:03 <TheDD> with -v:
11:02:14 <TheDD> link: done
11:02:14 <TheDD> *** Deleting temp files
11:02:14 <TheDD> Deleting: ./Main.hs
11:02:14 <TheDD>     Result size = 10
11:02:14 <TheDD>     Result size = 10
11:02:15 <TheDD>     (...)
11:02:28 <TheDD> but Main.hs is not a temp file!
11:04:10 <TheDD> any idea?
11:08:45 <esap> Try reorder the options (--make vs. -package)
11:09:25 <TheDD> ok 
11:10:29 <shapr> with 'ghc --make Main' it expects to find Main.hs and compile it to a binary named Main
11:10:33 <TheDD> nope, doesn't work
11:11:01 <shapr> what about "ghc --make Main -package data" ?
11:11:04 <TheDD> i put --make at the end?
11:11:19 <TheDD> well to keep the name of my binay 
11:11:46 <shapr> or try 'ghc -c Main.hs -o havm'
11:11:56 <esap> try put all other options first, then --make Main.hs
11:11:57 <shapr> --make is for simple uses
11:12:41 <TheDD> ghc -i.:. -odir. -hidir. -package data -o havm --make ./Main.hs => doesn't work
11:12:56 <esap> does it do the same thing as before?
11:13:00 <TheDD> yes
11:13:04 <TheDD> delete the Main.hs
11:13:11 <TheDD> compilation work
11:15:10 <shapr> did you try 'ghc -c Main.hs -o havm' ?
11:15:37 <shapr> --make Main.hs will try to make an .hs file from something else
11:15:42 <shapr> such as an .hsc file
11:15:52 <shapr> I think that's why it's considering Main.hs a temp file
11:15:53 <shapr> because it would be in that situation
11:16:09 <shapr> re hal
11:17:35 <TheDD> 'ghc -c Main.hs -o havm => Failed to load interface for `Posix' ...
11:18:05 <shapr> ghc -c Main.hs -o havm -package posix
11:18:12 <shapr> I was just giving you the basic idea :-)
11:18:33 <TheDD> ghc -c Main.hs -o havm -package data => wroks and doesn't delete Main.hs
11:18:36 <TheDD> ok :)
11:18:42 <shapr> c'est bien
11:18:56 <TheDD> tu parle francais?
11:19:00 <shapr> un peu
11:19:12 <TheDD> bravo :)
11:19:12 <shapr> je suis un cours
11:19:25 <TheDD> t es étudiant ?
11:19:37 <shapr> non, je suis geek :-)
11:19:42 <TheDD> lol
11:19:47 <TheDD> moi aussi :=)
11:19:50 <shapr> je travail pour moi
11:19:56 * esap lost track of the discussion once it turned to french.
11:20:17 <TheDD> moi je sui sfeignant
11:20:22 <Riastradh> 'c'est bien' -- it is well
11:20:24 <TheDD> je travaille peu :)
11:20:28 <TheDD> woow ;)
11:20:28 <Riastradh> 'tu parle francais?' -- you speak french?
11:20:33 <Riastradh> 'un peu' -- a bit
11:20:47 * shapr tries to remember some finnish
11:21:00 <shapr> minä tarvitsen suklaata
11:21:15 <TheDD> tu veux pas continuer en francais plutot ;)
11:21:28 <shapr> minulla olen ohjelmointia
11:21:56 <shapr> parlez vous suidois(?)
11:22:08 <TheDD> minolu 
11:22:09 <TheDD> ;)
11:22:14 <shapr> bah, I'm forgetting all my finnish.
11:22:25 <shapr> it's a cool language, I must find refresher courses.
11:22:27 <esap> shapr: the second one was not quite correct.
11:22:37 <shapr> esap: I am unsurprised :-)
11:22:45 <shapr> I'm impressed it was even understandable :-)
11:22:59 <esap> shapr: heh, almost :-)
11:23:05 <shapr> the hardest thing about finnish is that you can't say anything badly and expect people to understand.
11:23:29 <esap> shapr: well you can, but you have to make the right kind of mistakes...
11:23:33 <shapr> heheh
11:23:50 <shapr> maybe it's just that my american mistakes map onto finnish badly
11:24:19 <shapr> TheDD: j'aime les française ;-)
11:24:27 <TheDD> lol
11:24:37 <Riastradh> Je detest le francais.
11:24:39 <TheDD> tu es sur que tu es un vrai geek ? ;)
11:24:53 <shapr> hahah
11:25:09 <Riastradh> Vrai?  Hrm...
11:25:21 <TheDD> Hrm ?
11:25:23 <shapr> oui oui! les vrai geek aimerons(?) les femmes!
11:25:26 <Riastradh> What does 'vrai' mean?
11:25:30 <shapr> Riastradh: true
11:25:33 <Riastradh> Oh.
11:25:42 <shapr> btw, I was making a bad joke
11:25:54 <TheDD> oui oui! nous les vrai geek, aimons les femmes!
11:26:01 <shapr> les française actually means "the females french people"
11:26:26 <shapr> but if you don't speak french very well, most native french speakers are not sure if you really meant that or just "the french language" :-)
11:26:35 <shapr> it's fun to leave them guessing =)
11:27:06 <esap> heh. Try that with the haskell compiler, I'd expect the results are approximately the same :-)
11:27:14 <shapr> j'habite avec une femme française et allemagne
11:27:24 <TheDD> et allemande
11:27:29 <shapr> merci
11:27:37 <TheDD> pas de problème
11:27:38 <TheDD> :)
11:27:51 <shapr> je ne parle pas bien :-)
11:27:57 <shapr> it's been a long time since I've studied french.
11:28:11 <TheDD> to get back on ghc, i would like to avoid the use of "-c" instead of --make, is there any way ?
11:28:25 <TheDD> shapr: si, tu te débrouille pas mal
11:28:40 <shapr> sure, name your file Havm.hs and use 'ghc --make Havm'
11:28:53 <shapr> :-)
11:29:05 <TheDD> lol
11:29:06 * shapr looks up débrouille
11:29:32 <TheDD> tu te débrouille pas mal = you are doing pretty well
11:29:46 <shapr> heh, thanks :-)
11:29:55 <shapr> one day I'll spend some time in france and learn more.
11:30:10 <TheDD> :)
11:30:43 <TheDD> shapr: is it common to live with 2 women in USA?
11:30:47 <shapr> no no
11:30:49 <TheDD> in the USA?
11:30:55 <shapr> one woman who is both french and german :-)
11:31:01 <TheDD> lol ok
11:31:03 <shapr> whew
11:31:14 <shapr> j'habite en suide
11:31:20 <shapr> suide is right?
11:31:23 <TheDD> suède
11:31:26 <shapr> aha
11:32:20 <shapr> ma fiancée pere habite en sud france, peut-etre nous visitons quelque chose
11:32:25 <shapr> er quelque fois
11:33:27 <shapr> TheDD: OCaml seems to be the french functional language, why have you chosen Haskell?
11:33:32 <TheDD> le père de ma fiancée habite dans le sud de la france, nous visiterons peut-être quelque chose
11:33:32 <shapr> not that I disagree of course :-)
11:33:44 <shapr> ah, merci :-)
11:34:06 <TheDD> 1/ i don't chosse langage depending of the nationality of the inventor ;)
11:34:18 <shapr> that's very fair of you :-)
11:34:29 <TheDD> 2/ it's not my langage, i'm a student, and i'm trying to improve a teacher made program
11:34:33 <TheDD> thx :)
11:34:35 <shapr> ah, I see.
11:34:49 <shapr> I really like Haskell.
11:35:13 <shapr> c'est chouette :-)
11:35:14 * shapr grins
11:35:21 <TheDD> well when i saw quisort in thre lines ... i though i must learn this langage
11:35:29 <TheDD> Tout à fait :)
11:36:24 <shapr> Haskell is worth learning.
11:38:05 <jlouis> 4 lines normally :)
11:41:02 <TheDD> 4 ?
11:41:22 <TheDD> type, empty list, other list
11:41:59 <Riastradh> qsort :: [a] -> [a]
11:41:59 <Riastradh> qsort [] = []
11:42:12 <Riastradh> qsort l  = qsort xs ++ qsort ys
11:42:14 <Riastradh>   where
11:42:26 <Riastradh> Er.
11:42:29 * Riastradh did something wrong there.
11:42:32 <TheDD> yes ;)
11:42:35 <cale> Yeah, if you include the type it's three. Drop the type and it's two.
11:44:03 <TheDD> qsort (x:xs) = qsort [y | y <- xs, y < x] ++ [x] ++ [y | y <- xs, y >= x]
11:44:14 <cale> I wonder why Shae's quit messages always have an extra space at the beginning.
11:44:17 <Riastradh> Yeah, that.
11:44:57 <Riastradh> Of course, that qsort does way more comparisons than necessary.
11:45:28 <TheDD> hum, maybe
11:45:31 <TheDD> ;)
11:45:47 <Riastradh> qsort (x:xs) = qsort ys ++ [x] ++ qsort zs
11:45:48 <Riastradh>   where
11:45:53 <Riastradh>     ys,zs = separate xs
11:46:08 <Riastradh>     separate [] = []
11:46:18 <Riastradh>     separate (y:ys)
11:46:55 <Riastradh>         | y < x = let (a,b) = separate ys in (y :: a, b)
11:47:10 <Riastradh>         | otherwise = let (a,b) = separate ys in (a, y :: b)
11:48:51 <hdaume> Riastradh: i'm guessing that's going to be a lot slower :)
11:48:58 <Gaucho> hello
11:49:10 <Gaucho> functional languages use dynamic binding isn't?
11:49:16 <Riastradh> 'Dynamic binding?'
11:49:17 <TheDD> "ys,zs = separate xs" is valid and is eq to "(ys,zs) = separate xs" (i'm new to hasekll, remenber)
11:49:27 <Riastradh> TheDD, yes.
11:49:32 <TheDD> ok :)
11:49:45 <Gaucho> dynamic, no need of define variable types, just assign the values and the program does the rest...
11:49:57 <Riastradh> Haskell is statically and safely typed.
11:49:58 <Gaucho> C uses static binding i.e.
11:50:12 <Riastradh> 'Functional' has nothing to do with the type system.
11:50:23 <Gaucho> i don't understand that of typed or not typed, where can i get a definition for that?
11:50:24 <TheDD> Gaucho: maybe you think to Smalltalk ?
11:51:03 <Riastradh> Haskell has what you seem to be calling 'static binding.'
11:51:20 <Gaucho> really?but i'm not declaring variables
11:51:24 <Gaucho> how can that be?
11:51:24 <cale> Gaucho: "binding" usually refers to mapping definitions to names.
11:51:46 <Riastradh> Haskell infers the type.
11:52:04 <Gaucho> isn't that what makes dynamic binding?
11:52:10 <Riastradh> No.
11:52:10 <Gaucho> i've read something like that
11:52:19 <Gaucho> then the definition was wrong
11:52:29 <Riastradh> 'Dynamic binding,' first of all, is a very misleading term, and not very descriptive.
11:53:04 <cale> bindings in Haskell (at least top-level ones) don't tend to change a whole lot
11:53:33 <cale> lower level names can be bound exactly once in each context
11:53:56 <Riastradh> When I say 'static type[d, system, ing, etc]' I mean that the compiler will somehow (whether it be by explicit type annotations or type inference or something else) find type errors at compile-time.
11:54:11 <Riastradh> 'Dynamic type' indicates that the program finds type errors at run-time.
11:54:47 <Gaucho> an example of dynamic type would be...?
11:54:56 <Riastradh> Scheme has a dynamic type system.
11:55:10 <Gaucho> scripting languages count?
11:55:17 <Gaucho> interpreted languages i meant
11:55:21 <Riastradh> The style of language doesn't matter.
11:55:36 <Riastradh> Haskell has a static type system; Scheme has a dynamic type system -- but they're both functional languages.
11:55:56 <Gaucho> what about prolog?
11:55:57 <Riastradh> Goedel has a static type system; I think Prolog has a dynamic type system -- but they're both logic languages.
11:56:09 <Riastradh> ...et cetera.
11:56:21 <Gaucho> is there a place with a list or something about that?
11:56:24 <tic_> C has a dynamic system, Java has a static system, so does haskell.
11:56:48 <Riastradh> tic, no, C has a static type system, but it's very unsafe and lots of type junk can happen at run-time.
11:56:54 <Gaucho> C dyamics??
11:56:58 <cale> heh, C is actually a bit hard to call
11:57:13 <Riastradh> Labeling a type system with one name generally doesn't suffice.
11:57:20 <tic_> Riastradh, well, yeah, but given the casting....
11:57:31 <Riastradh> tic, it is nevertheless a static type system.
11:57:43 <Riastradh> You can make lots of type errors at run-time, yes -- it's an -unsafe- static type system.
11:57:52 <Riastradh> But nonetheless a static type system.
11:58:22 <cale> You can even make a lot of perfectly unchecked type errors at run time :)
11:58:34 <Riastradh> Yes -- it's very unsafe.
11:59:27 <cale> But, hey, so is assembly, and C is just high-level assembly :)
12:00:01 <cale> what's up with kunphuzil?
12:00:16 <Riastradh> I dunno.
12:00:22 <cale> his join/part noise is starting to overwhelm the channel
12:00:56 <d-bug> BAN HIM!
12:01:01 <d-bug> :)
12:01:27 <cale> at least temporarily with a message that tells him who to message to get back in.
12:01:48 <Riastradh> Whom to message, cale.
12:01:56 <cale> Sorry :)
12:03:46 <Gaucho> thanks
12:25:21 <tims> I'm trying to find a shell (e.g. bash, zsh) and was wondering if there are any shells built on Haskell.
12:25:30 <polli> scre -r
12:25:40 <polli> ops
12:27:08 <Igloo> Not for serious normal use, I don't think
12:27:27 <tims> igloo: thanks :-(
12:27:42 <SyntaxPolice> there is something new called shell-haskell, but I think its more for running programs. if you were going to write a shell, this page might help: http://www.haskell.org/hawiki/ExternalCommands
12:28:15 * SyntaxPolice does the "wow-my-function-works" dance
12:28:18 <SyntaxPolice> who gave me ops?
12:28:30 <tims> SyntaxPolice: thanks!
12:28:30 <Igloo> I think so much of a serious shell would be in the IO monad that you might as well be writing in ML
12:28:54 * SyntaxPolice wonders if he's supposed to kickban everyone with microsoft.com in their addresses now, as per our earlier conversation
12:29:06 <tims> igloo: Do you know of a shell in ML?
12:29:12 <Igloo> Does your function do anything exciting, SP?
12:29:21 <Igloo> tims: No, but I wouldn't do
12:30:04 <SyntaxPolice> Igloo: hrm. its exciting to me :-) but its a small part of a big program, so it would probably be hard to excite anyone else out of context.
12:30:14 <Igloo> Ah, OK  :-)
12:30:23 * Igloo does a little bounce for you regardless  :-)
12:31:26 <SyntaxPolice> thanks!
12:33:14 * Marvin-- looks through his quote book and giggles
12:39:38 <Heffalump> SyntaxPolice: I suggest you kickban anyone who gets money from them.
12:40:14 <Heffalump> ML doesn't have typeclasses
12:40:39 <cale> Doesn't spj work at ms research?
12:41:27 <Marvin--> doesn't hdaume work at ms research right now? :)
12:42:06 <keverets> tims: CASH: the caml shell
12:42:19 <Heffalump> I phrased it that way to include Igloo too :-)
12:42:24 <keverets> http://pauillac.inria.fr/cash/
12:42:28 <Marvin--> Heffalump: heh
12:42:49 <steveh> ML has functors though, yes?
12:43:09 * Marvin-- wonders if he's got any ice cream
12:45:21 <Marvin--> yay, mission accomplished
12:53:18 <tims> keverets: I'll check it out.  Thanks!
13:07:05 * dbagnell is away: I'm busy
13:11:21 <shapr> @yow
13:11:22 <lambdabot> Psychoanalysis??  I thought this was a nude rap session!!!
13:14:02 <dbagnell> shapr: You pinged me earlier?
13:16:01 * dbagnell is back (gone 00:08:56)
13:18:02 <shapr> dbagnell: just made the connection with your posts on pragprog, and wanted to say "hi!"
13:18:51 <dbagnell> shapr: Oh! Who are you? Do you go by shapr there too?
13:18:58 <shapr> no, I'm Shae Erisson there.
13:19:05 <dbagnell> shapr: I see.
13:19:10 <dbagnell> shapr: Did we agree? :)
13:19:21 * shapr grins
13:19:44 <shapr> I don't think we've had any direct disagreements at least.
13:20:47 <shapr> I'm usually the one singing the praises of functional programming and Haskell, I think.
13:21:22 <dbagnell> dbagnell: Then I am on your side.
13:21:44 <dbagnell> dbagnell: I was defending FP from Olyzk (can't remember how he spells it)
13:21:53 <dbagnell> shapr: just today
13:21:55 <shapr> urf, Olczyk
13:21:59 <shapr> I banned him from #haskell
13:22:48 <steveh> wow, do you find yourself banning a lot of people from #haskell?
13:22:49 <dbagnell> shapr: Really?
13:23:04 <shapr> I think he has potential, or at least passion and ambition, but his approach to learning/understand is not helpful.
13:23:05 * SyntaxPolice looks around for someone to ban
13:23:11 <shapr> steveh: he's the only one I've banned
13:23:18 <dbagnell> Wow.
13:23:24 <dbagnell> He is kindof grumpy.
13:23:34 <shapr> dbagnell: that's and understatement :-)
13:23:37 <dbagnell> Sometimes he's observations are keen, if grumpy.
13:23:39 <shapr> s/and/an
13:23:40 <dbagnell> :)
13:25:24 <dbagnell> shapr: Naive bayes in haskell eh?
13:25:29 <shapr> yup
13:25:33 <shapr> not very exciting
13:25:41 <shapr> but I did write a spam filter in 127 lines of Haskell, so I was happy.
13:25:42 <dbagnell> shapr: Nor very hard I would imagine.
13:25:54 <dbagnell> shapr: That's kindof long isn't it?
13:26:08 * steveh started on that but got bogged down in the whole learning-haskell thing
13:26:14 <shapr> well, first time I've ever done anything with bayesian stats, or email processing
13:26:21 <shapr> I can probably cut it down with a second draft
13:26:38 <inkedmn> howdy friends
13:26:45 <inkedmn> quick type signature question...
13:26:47 <shapr> hi inkedmn
13:26:57 <inkedmn> @type foldl
13:26:58 <lambdabot> foldl :: (a -> b -> a) -> a -> [b] -> a
13:27:08 <dbagnell> shapr: Whats most of it? Dealing with the imap server?
13:27:08 <inkedmn> the first part in the parentheses...
13:27:18 <Riastradh> ...means it takes a function as an argument.
13:27:20 <inkedmn> does that represent the operator? (+), etc.
13:27:30 <steveh> yes
13:27:41 <inkedmn> hmm, ok
13:27:57 <shapr> dbagnell: most of the code is dealing with token promotion as PG suggests.
13:28:08 <dbagnell> shapr: Can you summarize?
13:28:27 <dbagnell> shapr: I've done a fair amount of text learning but I apparently don't know PG's particular trick
13:28:39 <shapr> FREE in the subject becomes Subject*FREE
13:28:44 <shapr> giving it a separate probability
13:28:49 <dbagnell> shapr: Oh.
13:28:55 <steveh> smart
13:28:57 <dbagnell> shapr: We don't have a name for that trick. :)
13:29:00 <shapr> and any unknown tokens get demoted to more general forms
13:29:22 <dbagnell> shapr: Really? He never induces new ones?
13:29:27 <shapr> so , Subject*FREE!!!!! gets the !s pulled off one by one, then the case dropped, then the field dropped
13:29:30 <shapr> until something is found.
13:29:42 <kunphuzil> I want to tell everyone sorry for all my joins/quits. My internet connection was going insane. 
13:29:53 <shapr> kunphuzil: no one has complained
13:30:01 <kunphuzil> Ok, well i got banned from some channels
13:30:05 <shapr> dbagnell: induces new tokens? how so?
13:30:15 <dbagnell> shapr: Oh. That's clever. Can you get crazy sub-words?
13:30:16 <shapr> oh, you mean in training?
13:30:25 <shapr> not too crazy
13:30:38 <dbagnell> Like Subject*Freedom becomes Subject*Free? 
13:30:40 <shapr> he does deal with price ranges and IP addresses separately
13:30:49 <shapr> no, he hasn't done that
13:31:07 <shapr> from what he's saying, it's not that important
13:31:10 <dbagnell> shapr: I see. I'll have to look up what his little hacks are.
13:31:21 <dbagnell> shapr: It generally isn't in text.
13:31:32 <shapr> iirc, the guys who studied Bayesian spam filtering before him tried it, but found no advantage
13:31:46 <dbagnell> shapr: It's a dirty little not-so-secret that naive bayes does better than it should.
13:32:08 <shapr> PG spoke of CRM114 as the best classifier he's seen yet
13:32:22 <steveh> peace on earth
13:32:24 <dbagnell> shapr: CRM114?
13:32:26 <steveh> purity of essence
13:32:29 <dbagnell> shapr: What the heck is that?
13:32:39 <shapr> it's a poly-binary-bucket something classifier thingy
13:32:41 <shapr> :-)
13:32:42 <dbagnell> shapr: I know a lot of classifiers but that's not one of them.
13:32:48 <shapr> it's at http://crm114.sf.net/
13:32:49 <dbagnell> shapr: ????
13:33:07 <steveh> bah, it's the transmission blocker on B52s
13:33:10 <shapr> it uses some interesting algorithm that seems to naively do better than anything else according to PG
13:33:11 <steveh> everyone knows that ;)
13:34:23 <shapr> once I figure out how to do on-the-fly training and not use so much space, I'll write a lambdabot plugin and see how it works on per-user irc text ;-)
13:34:26 <dbagnell> shapr: I don't know what BCR is either. I can guess...
13:34:47 <shapr> I've also wondered whether a personal bayesian web search tool would be cool
13:34:52 <dbagnell> shapr: Even more clever. 
13:35:10 <shapr> where it finds groups of webpages that would interest the user who has training the search agent.
13:35:44 <steveh> i want to apply a filter to a web forum with moderation (a la slashdot) and figure out what combination of words has the best chance to get moderated positively ;)
13:35:46 <dbagnell> shapr: That's a reasonable amount of work.
13:35:59 * shapr shrugs
13:36:03 <shapr> I'm doing this for fun :-)
13:36:15 <dbagnell> steveh: We tried that. Its shockling easy to predict.
13:36:34 <dbagnell> steveh: It's also easy to predict what comments I would bother to read.
13:36:58 <dbagnell> dbagnell: Any use of Micro$oft, for example guarrantees it's a numbskull.
13:37:35 <steveh> hehe
13:38:12 <steveh> did you scrape for moderation categories too? (insightful, informative, etc.) or just the numeric moderation?
13:38:20 <shapr> dbagnell: actually, I don't think it would be difficult to write a personal bayesian/markov web search tool like that.
13:38:21 <dbagnell> numeric
13:38:33 <dbagnell> shapr: Be more specific. What should it do?
13:38:40 <steveh> so what 25 words are most likely to get you moderated up? ;)
13:38:57 <shapr> it should slowly crawl the web all the time, trying to find web pages that the user will enjoy reading
13:39:41 <shapr> it would be easy enough to do something like junkbuster, just a proxy that adds a frame at the top allowing you to click on "nifty" or "sucks" buttons
13:39:56 <shapr> and then do the same with the crawl results
13:40:44 <shapr> dbagnell: what do you think?
13:41:11 <shapr> I've never tried to write one of those, I could be totally wrong :-)
13:42:59 <dbagnell> dbagnell: One sec. My office mate is talking...
13:43:11 <shapr> no worries, IRC is asynchronous.
13:46:33 * Marvin-- finds some funny War3 sounds he's missed before, hehehe
13:47:00 <steveh> it's not warcraft in space!
13:47:04 <steveh> i know it's not 3d!
13:47:40 <Marvin--> "This warhammer costs 40k! Heheh"
13:47:44 <shapr> haha
13:47:58 <Marvin--> or the Blademaster shouting "Wasabi!"
13:48:15 <shapr> I can't understand some of the stuff the blademaster says.
13:48:20 * steveh doesn't have war3 :(
13:48:38 <Marvin--> shapr: http://www.lordaeron.com/war3/
13:48:49 <Marvin--> he's not terribly fun
13:49:42 <Marvin--> "We must kill the dwarves! - We are the dwarves." (mortar team)
13:50:08 <dbagnell> shapr: Yeah. that would probably work. I'm not sure it would be as effective as googling though. :) We did similar things looking for jobs postings.
13:50:11 <steveh> wonder why dwarves are always blowing things up
13:50:22 <Marvin--> steveh: it's in their blood
13:50:34 <steveh> myth had pyromaniac dwarves too
13:52:34 <Vincenz> adios
16:00:09 <tims> leave #haskell
16:27:10 <Gaucho> hello
16:27:13 <shapr> y0
16:27:39 <Gaucho> i'm getting inferred type it's not general enough and i don't know how to fix this... can i paste something or put something somewhere?
16:27:53 <Heffalump> how big is it?
16:28:01 <shapr> there's a paste page on HaWiki
16:28:06 <Heffalump> oh, neat
16:28:26 <shapr> @fact pastepage
16:28:26 <lambdabot> Nothing
16:28:28 <shapr> hm
16:28:57 <shapr> http://www.haskell.org/hawiki/HaskellIrcPastePage
16:29:03 <shapr> @fact pastepage http://www.haskell.org/hawiki/HaskellIrcPastePage
16:29:03 <lambdabot> set pastepage to http://www.haskell.org/hawiki/HaskellIrcPastePage
16:31:31 <Gaucho> it's not too big
16:31:52 <shapr> if it's less than five lines, feel free to paste it
16:32:06 <Heffalump> otherwise stick it on that page
16:32:16 <shapr> if it's more than eight lines, it's better to put it on the HaWiki, or paste it on #flood
16:34:18 <syntax-laptop> if ts between five and eight lines, you get a non-exhostive pattern match exception
16:34:31 <Gaucho> i've pasted something on flood, can someone take a look?
16:35:55 <Riastradh> Gaucho, what's going wrong with the type inference?
16:36:13 <TheDD> ++ all
16:36:14 <Gaucho> it's not allowing me to use that
16:36:15 <shapr> Gaucho: you have to ask people to come to #flood before you paste :-)
16:36:17 <Heffalump> is #flood logged?
16:36:27 <Heffalump> put it on the wiki page, much easier
16:36:27 <Gaucho> shapr: petit detach:P
16:36:40 <Gaucho> Heffalump:i was about to do that but i though flood was easier
16:36:41 <shapr> pas de problem
16:37:06 <Heffalump> well, I'll look at it if it's on the wiki page but #flood would be hassle, I don't have any spare windows
16:37:30 * shapr gets Heffalump a nice door
16:40:25 <Riastradh> Gaucho, surround your code with {{{ <code> }}}.
16:40:54 <Heffalump> I just edited it
16:41:00 <Heffalump> what are compara and aplica?
16:41:18 * Riastradh was about to ask that.
16:41:34 <Heffalump> basically, what's going on is that you gave a type signature that said "this function will work for any a and b", but in fact the types of compara and aplica mean that it can only work for a and b both Int
16:41:55 <Gaucho> Heffalump:other functions
16:42:02 <Riastradh> What are their definitions or types?
16:42:02 <Gaucho> compare and apply
16:42:29 <Riastradh> And their definitions or types?
16:44:00 <Gaucho> i get it now
16:44:11 <Gaucho> if i return [Int] in that functions i'm gonna have problems isn't?
16:44:28 <Riastradh> Yes.
16:45:05 <Gaucho> pretty clever language:P
16:45:48 <Gaucho> but
16:48:00 <Riastradh> But...?
16:48:18 <Gaucho> i'm trying to fix this given the definitions
16:48:53 <Gaucho> if i have something::[a]->[b] and suppose i send something [1,2,3] [1,2,3] is that an error?
16:49:01 <Riastradh> No.
16:49:14 <Gaucho> or another question, if i do something::[a]->[a] and i send [1,2,3] "hello" that's an error isn't?
16:49:20 <Riastradh> Yes.
16:49:38 <Riastradh> Well.
16:49:42 <Riastradh> Both of those are errors.
16:49:55 <Riastradh> I think you mean:  something :: [a] -> [b] -> <something else>
16:50:04 <Riastradh> and:  something :: [a] -> [a] -> <something else>
16:50:11 <Gaucho> yes
16:50:50 <Riastradh> What are the types or definitions of compara and aplica?
16:51:08 <Gaucho> compara::Eq a=>[a]->[a]->Bool
16:51:18 <Riastradh> And aplica?
16:51:22 <Gaucho> aplica::(a->a)->[a]->[a]
16:51:29 <Gaucho> i'm modifying that now
16:51:30 <Gaucho> heh
16:54:45 <Riastradh> @prelude ($!)
16:54:47 <lambdabot> *** "($!)" prelude "Haskell Standard Prelude Dictionary": text follows
16:54:47 <lambdabot> ($!)
16:54:47 <lambdabot>   infixr 0 $!
16:54:56 <Riastradh> ...
16:54:59 <Riastradh> @prelude ($)
16:55:00 <lambdabot> *** "($)" prelude "Haskell Standard Prelude Dictionary": text follows
16:55:00 <lambdabot> ($)
16:55:00 <lambdabot>   infixr 0 $
16:55:00 <lambdabot>   ($) ::  (a -> b) -> a -> b
17:01:26 <Riastradh> @yow
17:01:26 <lambdabot> ..Wait 'til those  ITALIAN TEENAGERS get back to their HONDAS &
17:01:26 <lambdabot>  discover them to be FILLED to the BRIM with MAZOLA!!
17:03:51 * Riastradh thought it said 'honads' for a moment there...
17:04:11 <Pseudonym> Which, presumably, is a tawdry dual of monads.
17:04:23 <Riastradh> Of course.
17:04:25 <Gaucho> i think i'm rounding in circles
17:06:43 <Pseudonym> There's a cheap and obvious joke in there about circles being round somewhere, but I'm damned if I'm going to make it.
17:07:02 * Riastradh damns Pseudonym, forcing him to make it.
17:17:10 <Heffalump> Pseudonym: did you ever get a reply from Dick Kieburtz to your question about the OI comonad being unsafe?
17:17:24 <Pseudonym> Nope.
17:20:26 * Riastradh is wondering...what's the point of comonads?
17:21:33 <cm> ..and i thought that was misspelled "command" :/
17:21:52 <Pseudonym> Comonads are supposedly equivalent to monads.
17:22:04 * Heffalump has provisionally decided that they are a waste of space.
17:22:18 <Riastradh> So why use them if monads can do the same thing?
17:22:19 <Pseudonym> I don't think anyone is suggesting they are superior.,
17:22:46 <Pseudonym> Riastradh, I think the idea is that _some_ things that we currently model as monads might be more "naturally" expressed as comonads.
17:23:07 <Riastradh> Like what?
17:23:08 * Heffalump doesn't believe any of the examples to that effect in the paper
17:23:16 <Pseudonym> Comonads are a kind of codata, and we structure abstract data types as codata all the time.
17:23:17 <Riastradh> What paper?
17:23:24 * Pseudonym does agree with Heffalump, though
17:23:33 <Pseudonym> None of the examples in the paper appear to be sufficient motivation.
17:23:42 <Heffalump> (especially since the OI one just seems wrong)
17:23:44 <Riastradh> Can anyone give an example?
17:23:45 * Pseudonym nods
17:23:53 * cm cries
17:24:05 <Heffalump> also, the .>> operator needing to circumvent lazy evaluation seems just *wrong*
17:24:07 <Pseudonym> http://haskell.org/hawiki/CoMonad
17:24:32 <Heffalump> though I'm not entirely convinced by his explanation of that anyway
17:25:28 <Riastradh> Gah.
17:25:32 <Pseudonym> I'm not sure if these are problems with comonads per se, or just an artifact of how Haskell is based on monads at the moment, so you have to jump through hoops to do it the other way.
17:25:36 <Riastradh> That paper looks HORRIBLE.
17:25:46 <Riastradh> Did they convert it badly from PostScript or something?
17:26:08 <Gaucho> a list of functions would be something like: [(a->b)] isn't?
17:26:13 <Heffalump> change .pdf to .ps in the URL
17:26:19 <Riastradh> Yes.
17:26:26 <Smerdyakov> Gaucho, you don't need the parentheses.
17:26:33 <Heffalump> it's the usual fonts problem, you'd need the dvi file to make a nice PDF
17:26:49 <Pseudonym> But then you lose all the advantages of PDF.
17:27:15 <Pseudonym> You really need to use PostScript fonts in the original LaTeX.
17:27:22 <Heffalump> Pseudonym: no, I think it's a consequence of the fact that we can easily make copies of any value in Haskell, but we can't easily merge two values
17:27:29 <Pseudonym> OK.
17:27:31 * Pseudonym can buy that
17:27:34 <Heffalump> yeah, pdflatex is ideal
17:27:53 <Heffalump> Pseudonym: as is shown by your example - splitting w breaks things completely
17:27:58 <Pseudonym> Right.
17:28:13 <Heffalump> of course you could use linear types to stop that, but then you don't need any other structure to encapsulate IO anyway
17:28:13 * Pseudonym might look up the codata references in the paper
17:28:55 <Heffalump> Pseudonym: in particular, however one implements getChar/putChar etc your example is still valid
17:29:06 <Pseudonym> Right.
17:29:10 <Pseudonym> Although...
17:29:31 <Pseudonym> I did suspect that the signature for getChar might actually have been wrong in the paper.
17:29:38 <Heffalump> oh?
17:29:44 <Pseudonym> getChar isn't a projection.  It actually alters the state of the world.
17:29:53 <Heffalump> oh, yeah
17:30:12 <Heffalump> I was trying to work out how to view OI in terms of CoSt (like the way that IO is St World)
17:30:17 * Pseudonym nods
17:30:24 <Heffalump> but I just couldn't come up with a sensible way of doing it
17:30:54 <Heffalump> (having tried CoSt World and CoSt (World -> ())
17:31:05 <Pseudonym> Right.
17:31:26 <Pseudonym> And then, of course, there's the issue that I felt the same way about monads the first time I encountered them. :-)
17:31:56 <Heffalump> oh, that didn't apply to me
17:32:08 <Pseudonym> It just took a while in my case.
17:32:12 <Heffalump> it took me a while to get my head around them, but they always "smelled" sort of right
17:32:19 <Pseudonym> Mind you, the first time I saw monads, they didn't support "bind".
17:32:27 <Heffalump> and the more I looked into them, the more right they seemed
17:32:37 <Pseudonym> It was the three-operation basis, unit, map and join.
17:32:49 <Pseudonym> They made a lot more sense when I saw bind. :-)
17:32:52 <Heffalump> heh :-)
17:36:54 <Gaucho> let's say i have a function that goes bla::[a]->a if it's [] = nothing, how do i return nothing?
17:37:56 <Heffalump> you need to make it [a] -> Maybe a
17:38:08 <Heffalump> data Maybe a = Just a | Nothing
18:29:57 <Pseudonym> Would someone care to proofread this for me?
18:29:58 <Pseudonym> http://haskell.org/hawiki/TraitsTypeclass
19:22:46 <Riastradh> Hmm...why are things like State not implemented in terms of StateT and MonadIdentity?
19:25:52 <cale> Riastradh: Perhaps State was around before StateT and it never got changed.
19:26:38 <Riastradh> But it seems that there's a general convention of writing ordinary monads and then transformer monads.
19:49:04 <cale> http://www.cwru.edu/artsci/math/wells/pub/ttt.html - this looks interesting (triples == monads, btw)
20:33:45 <sjj> jdk: hello
20:38:32 <jdk> hi :)
20:40:32 <jdk> I am doing research on Information Retrieval using Haskell
20:40:35 <sjj> jdk: QUT staff or student?
20:40:54 <jdk> How did you know I was from QUT?
20:41:00 <sjj> your hostname ;)
20:41:21 <jdk> I am both staff and student.   
20:41:34 <jdk> I am a masters student and I teach as well
20:41:46 <sjj> ahh, cool.. I'm attending QUT as well ;)
20:42:09 <sjj> are you doing research under Yeufeng?
20:42:20 <jdk> Yep, I probably know you then
20:42:29 <sjj> doubtful, I generally attend the CA campus ;)
20:42:50 <jdk> Is that Glenn Smith?
20:43:13 <sjj> well, i'm just a student, but he was one of my lecturers yeah.
20:43:31 <jdk> Were you at the CITI retreat last week?
20:43:44 <sjj> nope.
20:44:10 <sjj> I'm just doing IT21.
20:44:19 <jdk> Ahh, someone there had some Haskell types on an overhead slide, I didn't get to talk to him though
20:45:14 <sjj> hey, does Yeufeng have any IT21 projects on offer using Haskell?
20:45:20 <jdk> I am using GHC for my work, it is faster and I can use bigger files
20:46:22 <jdk> You will have to ask him, he had a masters by coursework doing some Java work, but I am sure he woul have things needing to be done in Haskell
20:46:37 * sjj nods.
20:47:04 <jdk> You can get 12 credit points doing research for a semester if you are a masters student
20:47:54 <jdk> It would be good if we could get more Haskell research going at QUT
20:48:05 <sjj> yeah!
20:50:18 <Pseudonym> jdk: What kind of information retrieval?
20:50:19 <jdk> At the moment I am prototyping some algorithms to improve collection selection performance
20:51:21 * Pseudonym works in IR for a living, incidentally
20:51:47 <jdk> Basically I build an inverted index which I train with some data
20:51:52 <Pseudonym> OK.
20:52:09 <Pseudonym> BTW, we're in Melbourne.  Send me a copy of your thesis when you're done and we might offer you a job. :-)
20:52:14 <jdk> Then I feed more documents in and try to get a match to a category
20:53:10 <jdk> I test the results for precision and recall over 5,10,20,30,40,50,100,150 results
20:53:13 <Pseudonym> How do you build categories?
20:54:46 <jdk> At the moment it is fairly simple, I do a search for six different IT related categories, and use the top 100 results as training data
20:55:00 <jdk> top 100 results from each category
20:55:19 <jdk> Where do you work Pseudonym?
20:55:36 <Pseudonym> http://www.teratext.com.au/
20:56:37 <Pseudonym> OK, so you're looking at some kind of automatic categorisation.
20:56:46 <Pseudonym> Interesting.
20:58:06 <jdk> Something like that.  I have also built a 1000 node tree structure and plan to see if that improves performance
20:58:16 <Pseudonym> Cool.
20:58:17 <jdk> Do you know of any Haskell matrix libraries?  I need Singular Value Decomposition
21:00:44 <jdk> Actuall Haskell is excellent for working with inverted indexes
21:01:21 <Pseudonym> I don't know offhand if there is anything which implements SVD specifically.
21:01:25 <Pseudonym> You might want to try this:
21:01:29 <Pseudonym> http://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR433
21:01:43 <Pseudonym> Which is actually in Gofer, not Haskell as such.
21:01:43 <jdk> You just create a type and derive Show and Read.  No needs
21:01:55 <jdk> no need for slow databases
21:02:07 <Pseudonym> Except space, I would think.
21:03:22 <jdk> When I started I first wrote parsers to read and write the data to file, then realised that Haskell does it all in one line
21:04:01 <Pseudonym> On the 100Gb collections per CPU that we handle, I expect that Show and Read would be somewhat inefficient. :-)
21:04:37 <Gaucho> can anybody give me a hand?cause don't know how to fix this, i'm getting inferred type is not general enough, my code it's in the page aplica2::[(a->b)]->c->[b]
21:04:38 <Gaucho> aplica2 [] _ = []
21:04:38 <Gaucho> aplica2 (f:fs) x = (f x ):aplica2 fs x
21:04:43 <Gaucho> oppps
21:04:45 <jdk> True, but for research purposes it is great
21:04:50 <Gaucho> that's the code anyway
21:05:08 * Pseudonym nods
21:05:11 <Pseudonym> SOunds interesting.
21:05:19 <Pseudonym> I'm going to be afk for a while.
21:06:00 <cale> Gaucho: maybe you meant [(a->b)]->a->[b] ?
21:06:20 <Gaucho> but it shouldn't be necessary
21:07:06 <Gaucho> and besides if i do that i get another error
21:09:52 <cale> well your function takes a list of functions of type a->b and applies each to x, right?
21:09:59 <Gaucho> yes
21:10:06 <Gaucho> and returns a list with the results
21:10:16 <cale> so x has to be type a.
21:11:03 <Gaucho> darn
21:11:05 <Gaucho> you're right
21:11:11 <Gaucho> i miss that stupid things
21:12:38 <Gaucho> it shouldn't be an error if i use a function with Int->Int isn't?
21:12:46 <Gaucho> cause i think is complaint of that
21:12:55 <cale> You mean if both a and b are Int?
21:12:56 <Gaucho> s/complaint/complaining/
21:12:59 <Gaucho> exactly
21:13:11 <cale> no, that won't be a problem.
21:13:11 <Gaucho> it's saying don't match
21:14:35 <cale> it works for me
21:15:06 <cale> try aplica2 [(+ 2), (* 3)] 6
21:16:24 <Gaucho> it works
21:17:18 <Gaucho> but not for factorial
21:17:35 <Gaucho> yes it works
21:17:38 <Gaucho> sorry
21:38:32 <Gaucho> if i have to do Eq for two variables, how should i do?Eq a=>Eq b=> it's not working
21:41:18 <Gaucho> what's this:Program error: {rata instEq_v25 [flip primMulInteger 2,flip primPlusInteger 3]?
21:42:01 <cale> It's "(Eq a, Eq b) =>" I think.
21:42:51 <cale> the error message is a bad error reporting on the part of hugs - usually it means that there are missing cases for a function.
21:46:29 <Gaucho> missing cases?
21:50:48 <cale> as in, f is applied to something that matches with the type of f, but it doesn't pattern match against any of f's definitions.
21:51:44 <Gaucho> but the definition of f is a->b
21:56:00 <Gaucho> can i ask like, x == y == z?
22:00:35 <Pseudonym> No, but you can ask x == y && y == z
22:00:57 <Gaucho> yep, i've done that, just being curious, this haskell thing is new to me:)
22:32:33 <Gaucho> what's this:Program error: {sopa 'a' "a"} ?
22:34:25 <Pseudonym> Again, probably a missing case.
22:42:12 <cale> Gaucho: I find that GHC generally gives much more meaningful errors than hugs in these cases.
22:42:55 <Darius> You may also want to check out Helium
22:43:24 <Gaucho> i'm bothering that much huh?:)
22:43:37 <Gaucho> where do i download that?
22:44:11 <Darius> http://www.haskell.org/learning.html has a link.
22:45:19 <Pseudonym> You're not bothering, incidentally.  It's just that the error messages in hugs are complete crap.
22:45:34 <Pseudonym> They admit it, too.
22:45:50 <cale> are they working on fixing them?
22:49:58 <Pseudonym> I don't think so.
22:50:29 <Pseudonym> The thing about hugs is it's probably the simplest Haskell implementation that's actually practical to use.
22:50:42 <lament> ...out of two? :)
22:51:06 <cale> there are more than two implementations of haskell :)
22:51:23 <Pseudonym> http://haskell.org/hawiki/HaskellImplementations
22:56:37 <Gaucho> what's the best implementation?
22:57:13 <Pseudonym> Define "best".
22:57:21 <Gaucho> for learning
22:57:27 <Pseudonym> Probably Helium.
22:57:27 <Gaucho> more didacti 
22:57:30 <Pseudonym> GHC is the most popular.
22:57:45 <Pseudonym> But Helium was designed specifically for learning.
23:00:24 <lament> what does it do?
23:00:29 <lament> Hold your hands, like drscheme?
23:00:57 <Pseudonym> I think it spends a lot of effort on explaining the cause of errors.
23:02:59 <Darius> lament: They put a lot of effort into the inferencer to give better error messages.
23:03:33 <Darius> Also the (current) lack of type classes makes many error messages simpler
23:06:32 <Gaucho> sopa z (x:y:xs) | x == z && x == y = x:sopa z xs
23:06:33 <Gaucho> 		| otherwise = x:sopa z (y:xs)
23:06:50 <Gaucho> i'm trying to eliminate repetitions, like, if it's "helooooo" just shows "helo"
23:06:57 <Gaucho> but that's not working, any ideas?
23:07:19 <Gaucho> the definition it's sopa::Char->[Char]->[Char]
23:08:42 <Pseudonym> Are you trying to filter all repetitions or just adjacent ones?
23:09:09 <Pseudonym> e.g. "abracadabra" -> "abrcd"?
23:09:31 <Gaucho> just adjacent ones
23:10:03 * Strike meekly suggests using "group"
23:10:11 <cale> nub wil do that
23:10:14 <Strike> meekly because I have no clue if that's right
23:10:14 <Gaucho> can use predefined functions or that stuff
23:10:23 <Strike> cale: but it does nonadjacent ones as well, doesn't it?
23:10:38 <Pseudonym> Yes, it does.
23:10:40 <cale> oh, perhaps it does, yeah
23:10:43 <Pseudonym> "group" might be better
23:10:56 <Strike> map head . group
23:10:58 <Strike> or something
23:11:43 <cale> yeah, that works
23:11:48 <Gaucho> any help?
23:12:28 <cale> Gaucho: (map head . group) seems to work
23:12:37 <Gaucho> can't use predefined functions
23:12:46 <Gaucho> i have to create all auxiliar functions myself
23:16:21 <cale> Gaucho: so you're creating a function uniq :: [Char] -> [Char], right?
23:17:03 <Gaucho> something like that, it's a function uniq::Char->[Char]->[Char], which receives something like, uniq ',' "hello,,,buddies" and gives "hello,buddies"
23:17:25 <Pseudonym> Oh, I see.
23:17:27 <cale> ah. So it only removes repetitions of the character that it's given.
23:17:38 <Pseudonym> So the map group thing wouldn't have worked anyway.
23:17:39 <Gaucho> yep
23:19:50 <Pseudonym> What problem were you getting with the version you had?
23:20:35 <Gaucho> first, it's not doing the job, and when it does something similar it says:Program error: {sopa 'a' "a"} 
23:20:55 <cale> Gaucho: you forgot about the base case I think.
23:20:55 <Pseudonym> Well the second problem is an easy fix.
23:20:58 <Pseudonym> You left out a case.
23:21:07 <Pseudonym> Actually, there are _two_ base cases here.
23:21:11 <Pseudonym> You left one of them out.
23:21:27 <Pseudonym> (THough it's possible to write it with only one base case.)
23:21:51 <Gaucho> what case?
23:22:05 <Pseudonym> Look at the error message.
23:22:14 <Pseudonym> Is there a case which matches sopa 'a' "a"?
23:22:39 <Pseudonym> 'Cause that's what hugs says is missing.
23:22:45 <Gaucho> oh
23:23:21 <Gaucho> done, anyway it's working half
23:23:35 <Pseudonym> OK.  What does it return now?
23:23:45 <Gaucho> now it's not returning errors
23:23:52 <Pseudonym> :-)
23:24:17 <Pseudonym> I worked out that much by myself.
23:24:35 <Gaucho> what?
23:25:14 * Pseudonym shoots the middle mouse button
23:25:27 <cale> :) gotta love the primary selection
23:25:54 <Pseudonym> Unfortunately, I have a five button mouse.
23:26:05 <Pseudonym> And the fourth and fifth buttons paste also.
23:26:09 <cale> My middle mouse button is even better, when clicked it tends to click more than once.
23:26:26 <Pseudonym> And the fourth button is right under my thumb.  If I hit the mouse against the keyboard, the paste button presses.
23:26:35 <cale> :)
23:26:38 <cale> Explorer?
23:26:58 <Pseudonym> No, it's a Microsoft IntelliMouse Optical.
23:27:28 <cale> Close enough, that's pretty much what I have.
23:27:45 <Pseudonym> You know exactly what I'm referring to then. :-)
23:28:09 <Pseudonym> First time it's ever caused an IRC flood, though.
23:28:27 <cale> yeah, but I'm left handed, so I don't tend to run them into the keyboard, but it's really awkward to use them at all.
23:29:45 <cale> Gaucho: Not quite getting rid of all the repetitions?
23:31:14 <Gaucho> only half
23:32:09 * Pseudonym LOL
23:32:16 <Gaucho> don't laught
23:32:26 <Pseudonym> No, I just read the haiku on LtU.
23:32:51 <Pseudonym> Theorem proving and / sanity; Oh, my! What a / delicate balance
23:33:07 <Pseudonym> Should put that on the quotes page.
23:33:35 <cale> Gaucho: yeah - I think what you should maybe do, is write out what your function is doing on paper.
23:33:36 <Pseudonym> Ah, there's a page full of them.
23:34:21 <Gaucho> done:)
23:34:23 <Pseudonym> It's blatantly clear / You stupid machine, that what / I tell you is true
23:34:28 <Gaucho> i'm doing all in paper first
23:36:24 <cale> so when you do sopa 'a' ('a':'a':"aa"), what does it immediately do? It returns the first case, which is 'a':sopa 'a' "aa"
23:36:44 <Gaucho> it's working now
23:36:55 <cale> ah, figured it out then?
23:37:04 <Gaucho> brute force programming...
23:37:07 <Gaucho> just kidding, yep
23:45:04 <cale> Perhaps length, take, drop, splitAt, (!!) and replicate should be replaced with their generic versions. Is there a downside? I seem to remember some controversy over it, though I can't remember the arguments.
23:50:22 <Pseudonym> What do you mean by "generic"?
23:50:37 <Pseudonym> What would be the generic version of "length"?
23:50:42 <Pseudonym> Or, at least, what's its type?
23:50:58 <cale> the ones defined in List
23:51:06 <Pseudonym> class Length l where
23:51:09 <Pseudonym>     length :: l
23:51:17 <Pseudonym> instance Length ([a] -> Int) where { ... }
23:51:23 <Darius> genericLength :: Num a => [b] -> a
23:51:26 <Pseudonym> That's pretty generic.
23:51:31 <Pseudonym> Oh, I see.
23:51:33 <Darius> length :: [a] -> Int
23:51:59 <Pseudonym> evenMoreGenericLength :: (Enum a) => [b] -> a
23:52:07 <cale> genericLength           :: (Integral a) => [b] -> a
23:52:20 <cale> is how it currently is
23:52:38 <Darius> @prelude genericLength
23:52:40 <lambdabot> *** "genericLength" prelude "Haskell Standard Prelude Dictionary": text follows
23:52:40 <lambdabot> genericLength
23:52:40 <lambdabot>   genericLength ::  (Integral a) => [b] -> a
23:52:40 <lambdabot>   genericLength            = foldl' (\n _ -> n + 1) 0
23:52:40 <lambdabot>    where
23:52:42 <lambdabot>     foldl'           :: (a -> b -> a) -> a -> [b] -> a
23:52:44 <lambdabot>     foldl' f a []     = a
23:52:46 <lambdabot>     foldl' f a (x:xs) = (foldl' f $! f a x) xs
23:52:48 <lambdabot> [there's @more]
23:53:17 <Pseudonym> evenMoreGenericLength [] = fromInt 0
23:53:29 <Pseudonym> evenMoreGenericLength (_:xs) = succ (evenMoreGenericLength xs)
23:53:43 <Pseudonym> Though of course you'd want to make it accumulator recursive.
23:54:01 <Gaucho> it's almost 4 in the morning and it's the negation stage, i hate logic and functional languages
23:54:18 <Pseudonym> What are you doing here, then?
23:54:54 <Gaucho> like i've said, it's the negation stage, it's only temporary
23:55:04 <Pseudonym> :-)
23:55:08 <Gaucho> especially when things don't go as fast as i want to...
23:56:18 <Gaucho> of course i rather preffer haskell to prolog
23:58:33 * Pseudonym isn't surprised
