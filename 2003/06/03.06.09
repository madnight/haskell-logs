00:30:54 <o3> hullo
00:31:06 <o3> quick q: what's the name of the >>= operator?  monadic bind?  monadic composition?
00:44:02 <Darius> typically it's called bind.
00:48:59 <o3> ok, thanks darius
02:58:06 <TheDD> hello
02:59:10 <cale> hi
02:59:29 <TheDD> i have a question, but not on haskell
02:59:40 <cale> okay
02:59:54 <TheDD> does anybody know an algorithl to perform alpha-conversion?
03:00:00 <TheDD> algorithm
03:00:37 <TheDD> i've serach with google, and the only thing i found is macro expansion in lisp wihch is way beyond my skill
03:03:06 <TheDD> any idea?
03:03:20 <cale> hm... you just want an algorithm that changes the name of the variable bound in a lambda expression? Can't it just be done recursively?
03:05:07 <cale> what language is this in/what does the data structure you're using to hold lambda expressions look like?
03:06:41 <TheDD> ex:
03:06:51 <TheDD> ([x1] P(x1)) & R(x1) with [] => forall
03:07:19 <TheDD> i must "extract" the for all
03:07:22 <TheDD> i must "extract" the forall
03:07:41 <TheDD> but without renaming, i make a name capture
03:08:05 <TheDD> i do this in Caml
03:08:13 <Heffalump> does your renaming need to be efficient?
03:08:14 <TheDD> i have an Ast (a sum type)
03:08:17 <TheDD> nope
03:08:22 <Heffalump> then just do a recursive traversal
03:08:35 <TheDD> yeah but i don't know how
03:08:41 <cale> you need some way to determine an unused variable?
03:08:44 <Heffalump> in Haskell, it'd be something like this:
03:09:26 <TheDD> cale: no, i need to put in prenex form (= all forall in the begining, outside any parenthesis) without name capture
03:09:26 <Heffalump> data Term = Forall Varid Term | Apply Funid Term | Var Varid
03:09:53 <Heffalump> rename a b (Var v) = Var (if v==a then b else v)
03:10:04 <Heffalump> rename a b (Apply f t) = Apply f (rename a b t)
03:10:29 <Heffalump> rename a b (Forall v t) = Forall v (if v==a then t else rename a b t)
03:11:26 <TheDD> hum
03:12:11 <TheDD> wow
03:12:21 <cale> rename just performs the actual alpha-conversion. You'll want to use it together with some method of choosing a good b if you want to lift the forall.
03:12:23 <TheDD> (haskell is new to me)
03:12:39 <Heffalump> oh, yes, use a namesupply
03:13:01 <Heffalump> but I'll leave that to you since it's best done imperatively in Caml, whereas in Haskell I'd pass around an infinite list
03:13:28 <Heffalump> or if you really don't care about efficiency then just scan the term for an unused variable
03:15:36 <TheDD> if v==a then t ?
03:18:24 <Heffalump> that's to avoid renaming the second x in [x] (P(x) || [x] Q(x))
03:18:29 <Heffalump> because it's a different x
03:20:29 <cale> rename as it stands only renames free variables.
03:20:42 <TheDD> but i have to do it, in the end of the treatment, all varaible id must be "defined" (in a forall for example) only one, and must be linked to only one forall max
03:22:10 <Heffalump> well, I'll leave you to work out how to generalise it :-)
03:22:44 <TheDD> ok :)
03:22:46 <TheDD> thx
03:25:38 <Heffalump> (hint: you'll probably want another recursive traversal, that itself invokes rename)
03:26:41 <TheDD> ok
03:32:21 <cale> TheDD: if you want to see how to put things in prenex form on paper, there's a description here: www.csd.uwo.ca/~lila/prenexw.ps (but it doesn't specify exactly how to implement anything, just says what should be done)
03:42:21 <TheDD> ok thx :)
03:58:17 <Marvin--> heh, I have 98 unread mails in my haskell folder
03:58:33 * shapr yawns
04:00:36 <shapr> goood morning #haskell!
04:01:49 * Marvin-- can't be bothered reading all these zillions of mails
04:02:14 <shapr> I have lots of unread mails in my haskell folders
04:02:32 <Marvin--> I've been away since Wednesday, and I just returned
04:02:33 <shapr> I almost always get to them.
04:02:39 <shapr> what did you do?
04:02:40 * Marvin-- has lots and lots and lots of unread mail
04:02:57 <Marvin--> visited my parents, and then went cheering on my cousin who graduated from high school
04:03:14 <shapr> cool
04:03:38 <Marvin--> http://www.userfriendly.org/cartoons/archives/03jun/uf005608.gif *g*
04:04:32 <shapr> :-)
04:06:24 <shapr> anyone written any cool code lately?
04:06:58 <shapr> I didn't know John Hughes wrote a paper with Eugenio Moggi
04:09:36 <shapr> re Marvin-- 
04:09:45 <Marvin--> grmbl
04:21:41 <Marvin--> gawd I hate people with auto-reply-mail things
04:22:01 <Marvin--> particularly when I get it when posting to a list
04:27:12 <shapr> yah that does suck
04:33:46 <shapr> oy
04:33:50 * shapr sings
04:43:31 <shapr> hi d-bug
04:43:39 <shapr> hur är det med dig?
04:44:35 <d-bug> det är bra tack
04:44:44 <d-bug> hur mår du?
04:45:48 <shapr> jag känner mig pigg.
04:45:55 * shapr wonders if that was right.
04:49:08 <d-bug> det var det :)
04:51:11 <shapr> d-bug: how's the code treating you?
04:52:23 <d-bug> i sat a few hours yesterday doing my first client-side JavaScript ever
04:52:36 <shapr> what did you think?
04:53:19 <d-bug> JavaScript isn't bad at all
04:53:28 <d-bug> i expected something much simpler
04:53:47 <shapr> it begins to suck when you want something that works in several browser/version combinations.
04:54:15 <shapr> it is a nice language, especially the prototype stuff
04:55:26 <d-bug> i just discovered that my code doesn't work in IE6 :-/
04:56:18 <shapr> it seemed to me that microsoft tried to make a not-quite-compatible javascript implementation.
05:00:23 <d-bug> a simple onchange on a <input type="text" doesn't trig in IE6, works in mozilla
05:01:05 <shapr> if you search places like javascript.com etc, you can find cross-browser javascript libraries
05:06:18 <shapr> hi Arnia 
05:06:23 <shapr> how's code?
05:06:52 * shapr is writing a website summary for an EU Project Report
05:06:57 <Arnia> Its good... found I've got a good first for my SEG project
05:07:13 <shapr> I feel like I'm in school, writing a book report.
05:07:17 <shapr> What's SEG?
05:07:31 <Arnia> Software Engineering Group
05:07:36 <shapr> oh, neat
05:07:58 <Arnia> Every second year computer scientist has to take part in a group SE project with a customer
05:07:58 <shapr> what's the project?
05:08:17 <shapr> that sounds like an eye-opening experience.
05:08:40 <shapr> do you get repeat customers?
05:08:40 <Arnia> This year it was a piece of courseware for the charity that runs the British Sign Language qualifications (they're based in Durham)
05:09:26 <Arnia> We only have one customer... and we have to take the software from Domain Analysis through to acceptance testing
05:10:00 <shapr> language/platform constraints?
05:10:59 <Arnia> There can be... this year we were given free reign as long as we could make a business case for using the technology we did. We opted to use Plone in the end
05:11:27 <shapr> I could easily see why you chose Plone.
05:11:44 <shapr> I would have myself.
05:13:00 <Arnia> Gave us a wonderful framework. Plus, being a Plone developer it made things easier for me :)
05:13:14 <shapr> :-)
05:14:59 <Arnia> Ugh... its hot here :(
05:15:21 <shapr> I wish it were warmer here.
05:15:54 <Arnia> It claims its only 16 degrees C... that's a bloody lie. Its currently in the twenties at night
05:16:03 <shapr> sounds nice :-)
05:16:26 <shapr> have to wear a jacket or sweater at night here.
05:16:32 <Arnia> Ah... thats the temperature at Aberdeen :)
05:16:41 <shapr> still stays sunny at night of course.
05:17:09 <Igloo> Ug
05:17:16 <shapr> I should be outside photosynthesizing... saving up till winter.
05:17:21 <shapr> hi Ugloo, what's up?
05:18:03 * shapr pokes Igloo 
05:18:23 <Igloo> Not much
05:18:30 <shapr> Arnia: tried z3 ?
05:18:51 * Igloo should do something useful
05:18:52 <Arnia> Not yet... will do soon thhough
05:18:58 <shapr> Igloo: ghc6 debs!
05:19:04 <shapr> or HEAD if you prefer
05:19:34 <shapr> Igloo: have you tried using darcs?
05:19:53 <Igloo> shapr: Waiting on a reply to my mail saying it broke  :-(
05:19:56 <Igloo> No
05:20:06 <shapr> I haven't either
05:21:53 * Igloo goes to see if the HEAD looks like it'll build
05:23:15 <Igloo> Hmm, nope
05:34:46 <shapr> oy
05:34:57 <shapr> cleverdra: hey, does hugs run on your Zaurus yet?
05:39:58 <shapr> hoi
05:40:00 <shapr> to both of you
05:40:16 <shapr> how's the Netherlands today?
05:40:30 <kosmikus> better than yesterday ...
05:40:52 <BlitzNL> kosmikus: what was wrong yesterday?
05:41:23 <kosmikus> the weather could have been nicer ...
05:41:38 <BlitzNL> Ic. Anyway, if I have some `let x = <bla> in True` is there some way to force the avaluation of x ?
05:42:00 <BlitzNL> s/avaluation/evaluation
05:42:06 <Igloo> seq
05:42:24 <Igloo> Possibly recursively depending on what you want
05:42:52 <Igloo> But you should only use it with reference to profiling output
05:47:54 <shapr> how many words fit onto an A4 sheet of paper?
05:49:33 <BlitzNL> Igloo: well the what I do is something like ' .. -> seq (checkerror xs) 1', checkerror is a functoin that can exit the program is there is a 'problematic' value is xs.. Is this correct usage?
05:49:54 <BlitzNL> shapr: that depends on the size of  .. ;)
05:50:15 <Igloo> No
05:50:55 <Igloo> You should either be in the IO monad or passing back a Maybe a
05:51:16 <Igloo> Or Either a String where the String is an error message or whatever
05:52:39 <BlitzNL> Igloo: mm ok i'll reconsider
05:58:04 * shapr bouncs happily
05:58:13 <shapr> anyone written any cool code lately?
05:58:34 * Igloo released Printf 0.1.0
05:58:48 <shapr> yay!
05:58:53 <shapr> what's the url?
05:59:10 <Igloo> http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/Printf/
05:59:33 <shapr> @topic-snoc http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/Printf/
05:59:35 <Igloo> But it probably won't compile with any release or CVS snapshot of GHC yet
05:59:40 <shapr> @topic-snoc #haskell http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/Printf/
05:59:40 <lambdabot> topic doesn't parse
05:59:47 <shapr> silly bot
06:00:25 <shapr> state problems in lambdabot 
06:00:34 <Heffalump> " It should build with CVS GHC from around 4/6/2003."
06:00:42 <Heffalump> has a snapshot not appeared since?
06:01:06 <Igloo> I hadn't realised that the HEAD was broken when I checked the TH fixes into it at that point
06:01:10 <shapr> speaking of which, delYsid suggested that lambdabot state could be just a nested tuple, so modules could look up their own state
06:01:23 <Heffalump> make it a record, not a tuple
06:01:24 <shapr> it would mean lambdabot wouldn't need Dynamic anymore.
06:01:26 <Igloo> By snapshot I meant cvs co -D x for any x
06:01:37 <Heffalump> ah
06:01:41 <shapr> Heffalump: doesn't work unless a module can add its own record
06:01:51 <shapr> which Hugs TREX can do...
06:02:00 <Heffalump> how would nested tuples help, then?
06:02:10 <Heffalump> and YM its own field, not its own record
06:02:15 <shapr> right, sorry
06:02:35 <shapr> nested tuples like the extensible union type in the modular monad transformers interpreters paper
06:02:37 <Heffalump> you can do anything with nested records that you can do with nested tuples, but there's less dependency on the precise structure of each record
06:02:46 <Heffalump> I forget how that worked
06:03:21 <shapr> basically, (modulename :: String, moduleState :: whoknows, othertuples)
06:03:39 <shapr> the problem is that a module can have any type of state
06:04:08 <shapr> tuples are the only way I know to save a random collection of data
06:05:00 <Igloo> Tuples just mean type inference on the "the rest" bit will be done for you
06:05:15 <shapr> with nested tuples, you just walk down till you find the name of the state you want, then you use it.
06:05:30 <Igloo> Although you could just make it an argument to the datatype
06:05:32 <shapr> ?
06:06:02 <Igloo> Oh, that's true too
06:06:44 <shapr> tuples are the only heterongenously typed collections
06:06:49 <shapr> mostly because they aren't really :-)
06:06:51 <Igloo> Is this for initialisation or while it's running?
06:06:56 <shapr> while it's running
06:07:02 <Igloo> Ah. Hmm.
06:07:18 <shapr> obviously building the next state to pass around will mean building a new nested tuple
06:07:19 <Heffalump> records are also hetereogenously typed collections, in that sense...
06:07:22 <shapr> which could be expensive
06:07:43 <Igloo> O(number of modules)
06:07:44 <Heffalump> they have the same modularity properties, but can save on some syntax
06:07:58 <Igloo> But lookups are too
06:08:03 <Heffalump> anyway, haven't extensible records just been implemented in GHC?
06:08:07 <shapr> ?
06:08:25 <shapr> If so, I'll be very happy.
06:08:26 <Heffalump> Umut Acar was doing that, I thought.
06:08:31 * shapr googles
06:08:34 <Igloo> records are not going to save much over 3-tuples
06:08:40 <Heffalump> oh, true
06:08:49 <Heffalump> if they're always 3-tuples, then it doesn't matter
06:09:00 <Heffalump> anyway, aren't your modules dynamically loaded?
06:09:04 <shapr> no, not yet :-/
06:09:08 * shapr pokes o3
06:09:20 <shapr> runtime loader only works in ghc 5.04.2
06:11:15 <Heffalump> you could use dynamics anyway, and just keep a list of (modulename,modulestate) pairs that way.
06:30:03 <shapr> Heffalump: part of the problem with dynamics is that I can't keep a postgresql connection that way.
06:30:50 <Heffalump> ah
06:31:10 <Heffalump> what's the type of one of them, then?
06:31:11 <shapr> right now the per-module state is a FiniteMap of String (IORef Typeable (Dynamic?))
06:31:59 <shapr> Pseudonym wrote up a nifty ModuleState datatype that is Typeable a =>
06:32:12 <shapr> data ModuleState = forall a. (Typeable a) => ModuleState a
06:35:16 <Heffalump> IM what's the type of a postgresql connection
06:35:26 <shapr> oh
06:37:00 <shapr> it's just wrapped libpg types
06:38:28 <shapr> Connection
06:38:32 <BlitzNL> \quit bye
06:38:36 <shapr> bye BlitzNL 
06:38:44 <BlitzNL> bye
06:39:51 <Heffalump> wrapped in what sense?
06:40:02 <Heffalump> are the libpg types just Ptr?
06:41:32 <shapr> HToolkit uses a bunch of .hsc files, I assume that's c2hs ?
06:41:51 <Igloo> No, hsc2hs
06:42:01 <shapr> type PGconn = Ptr ()
06:42:10 <Heffalump> so yes.
06:42:15 <shapr> newtype Connection = Connection PGconn
06:42:24 <Heffalump> so why can't they be wrapped into Dynamics?
06:43:09 <shapr> I guess I just assumed a database connection couldn't be an instance of Typeable
06:43:26 <Heffalump> I don't know if Ptr is or not.
06:43:32 <Heffalump> but if it isn't, I'd like to understand why
06:44:14 <shapr> the way I understand Dynamic, you turn the value into a string of bits, and then reconstruct it later with the type constructor
06:44:52 <Heffalump> a Ptr is a string of bits, isn't it?
06:45:06 <Heffalump> I guess there could be GC issues.
06:45:06 <shapr> er, I guess so.
06:45:33 <shapr> but it doesn't seem like it's a value that could be serialized and reconstructed safely.
06:45:41 <shapr> wouldn't locations in memory change?
06:46:13 <Heffalump> hence "GC issues"
06:46:18 <Marvin--> argh, I'm so sick and tired of forgetting things all the fscking time
06:46:24 <shapr> Marvin--: what did you forget?
06:46:30 <Heffalump> though a pointer that a library returned ought not to, anyway
06:46:30 <shapr> Marvin--: use korganizer on your laptop!
06:46:38 <Heffalump> Marvin--: how goes the project?
06:47:08 <Marvin--> shapr: I left stuff behind at my parents' :/
06:47:24 <Marvin--> Heffalump: it's kinda dormant right now
06:47:38 <Marvin--> but it looked promising before I decided to take a break :)
06:48:52 <shapr> I think I'll switch lambdabot to hiermodules
06:49:23 <shapr> and I think I'll never ever use the Util module name again.
06:50:16 <Marvin--> ?
06:50:55 <shapr> I had some very confusing bugs recently
06:51:16 <shapr> finally I discovered that lambdabot, HXmlToolbox, and wli have Util.hs files.
06:51:28 <Marvin--> ouch
06:51:31 <shapr> and they were all on my include path at the same time.
06:51:45 <Marvin--> *cough*hiermodules*cough*
06:52:10 <shapr> I hope they switch hiermodules to python-style relative
06:52:11 <Marvin--> hate to say it, but Java does have a point with its org.foo.bar.baz hierarchy :)
06:52:19 <Marvin--> yeah I like Python's way too
06:52:26 <shapr> so I can just import Lambdabot.Util ever after
06:52:46 <shapr> Marvin--: say so on libraries@haskell.org, or it may never change :-)
06:52:57 <Marvin--> well, you'd still import Util, since they'd be in the same "package"
06:53:06 <shapr> oh, Uwe Schmidt is building a cookbook/unit test module for HXmlToolbox now, yay!
06:53:06 <Marvin--> (package being a python or java style package, not a ghc style package)
06:53:21 <Marvin--> btw, I still don't understand ghc's packages
06:53:28 <Marvin--> are they completely flat?
06:53:38 <shapr> you mean -package data stuff?
06:53:48 <Marvin--> yeah
06:53:59 <Marvin--> oh, and the mail I got from Uwe was totally unhelpful :/
06:54:01 <shapr> yeah, they're flat.
06:54:04 <shapr> what did he say?
06:54:15 <shapr> look at ghc-pkg -s data
06:54:28 <Marvin--> "here's some unit tests that don't do what you want" basically
06:54:38 <Marvin--> and he didn't answer my questions
06:54:52 <shapr> a ghc-pkg.conf is just a set of import,source,library,hs,include,extra,etc
06:55:22 <Marvin--> packages seem kinda useless to me... why not just use separate name spaces instead?
06:55:45 <Marvin--> you'd still have to hope for a separate namespace per third party package...
06:56:15 <Marvin--> packages make sense from a distribution point of view, but I prefer .debs anyway! ;)
06:57:51 <Marvin--> shapr: and re posting to libraries@h.o... I don't really have any arguments :/
06:58:51 <Heffalump> being a voice in support might be worthwhile, though
06:59:01 * Heffalump sort of sees both sides so isn't sure which way to go
07:00:10 <SyntaxPolice> hi all
07:03:16 <Igloo> Is there something summarising the libraries distribution conversation thus far somewhere?
07:03:48 <shapr> SyntaxPolice has a HaWiki page
07:04:04 <shapr> that's the best summary yet
07:04:37 <shapr> Marvin--: interesting point, hiermodules would allow you to keep more than just source files in a dir
07:04:47 <shapr> you could also keep .o .hi and everything else
07:05:36 <shapr> Would that be simpler/easier than ghc-pkg?
07:06:37 <Marvin--> I don't know what ghc-pkg does
07:07:06 <shapr> have you installed anything like green-card, htoolkit, etc without using a deb?
07:07:16 <Heffalump> records package installations in a global conf file
07:08:10 <shapr> yah, HToolkit puts .a .hi and more into /usr/local/imports/HToolkit and it requires -package base
07:08:35 <Marvin--> shapr: no, I'm scared to death of putting random files somewhere without putting them in .debs
07:08:53 <shapr> so ghc -package HToolkit expands to all the -i -I etc statements you'd have to insert to get stuff to compile
07:09:08 <shapr> mgoetze|away: w00, IPv6 
07:09:10 <Marvin--> what are the arguments against relative module names?
07:09:12 <Marvin--> shapr: aha
07:09:44 <shapr> my argument against non-relative module names is that it sucks to put module Foo.Bar.Baz in the source itself.
07:10:11 <shapr> means you have to change all the sources to change the hierarchy, and makes it harder to reuse sources for the same reason
07:11:55 <Marvin--> maybe python's dynamism makes it easier with relative names?
07:11:58 <Marvin--> somehow
07:12:26 <shapr> even so, ghc 'dynamically' looks in the dir for the .hs or .hi files
07:12:32 <Heffalump> the counter-argument is precisely that it sucks not to have it, because then the module file on its own doesn't completely specify what it is
07:13:51 <Igloo> I think the name shold be in the module for Haddock anyway
07:18:00 <Marvin--> Heffalump: but that's the thing, isn't it? Some people want the module file to determine its location and others don't
07:18:15 <Heffalump> yeah.
07:18:19 <Marvin--> damn
07:21:24 <shapr> you could do both I guess
07:21:32 <cale> yes
07:21:42 <shapr> you could even combine them
07:22:04 <cale> I think that the solution might be in the form of being able to specify both the immediate parent and children of the module.
07:22:05 <shapr> so Foo/Bar.hs would be Foo.Bar unless Bar.hs says module Bar.Baz where
07:23:26 <Heffalump> umm
07:23:35 <Heffalump> won't that break horribly if you really want Foo.Bar.Bar.Baz?
07:23:43 <cale> I'm not so sure that I entirely agree with filenames themselves mattering as much as they do, though.
07:23:59 <shapr> Heffalump: yes, that could suck.
07:24:07 <shapr> is there a better way?
07:24:52 <shapr> probably just say the module name given in the source file is appended onto the relative dir path
07:25:03 <shapr> then module Bar.Bar.Baz would do it.
07:25:49 <Marvin--> I'm going to play some War3
07:25:50 * Marvin-- waves
07:26:00 <shapr> have fun
07:26:18 <cale> Could we perhaps have a system where filenames would be completely ignored, and only the module declarations they contain would matter?
07:26:59 <Heffalump> I think you have to choose one or ther other solution.
07:27:08 <Igloo> That's what shapr doesn't like I think
07:27:16 <Heffalump> yeah.
07:27:27 * Igloo is for it as the module docs and comments should be able to talk about itself
07:27:34 <Heffalump> cale: then you don't have modules whose name is determined by filesystem position
07:27:49 <shapr> Igloo: couldn't relative modules still talk about themselves?
07:27:57 <cale> Heffalump: maybe that's a good thing?
07:28:34 <shapr> as long as the module docs only depend on sources in this file/dir or subdirs, it would work.
07:28:46 <Igloo> shapr: Things like quick sample programs need to have full module names in
07:29:57 <Igloo> For example, whatever unsafePerformIO is in should be able to have little programlets that show safe and unsafe uses including the import declarations
07:30:48 <Heffalump> cale: well, that's the whole debate
07:31:27 <SyntaxPolice> Igloo: the LibraryInfrastructure page is as good as the summary gets, there's a lot thats not on there, and there's some stuff on there that will probably go away
07:32:56 * Igloo will look for it later, thanks
07:33:43 <cale> If you want to transfer modules over the internet, say, then you have to be careful to put them in packages that preserve directory structure. They can't simply be saved off of web servers as .hs files without extra packaging if packages are filesystem dependent.
07:34:15 <shapr> yes, and you won't find a filesystem on PalmOS, though the nhc98 runtime does work there.
07:34:31 <cale> good point.
07:35:13 <shapr> I still really like the flexibility of relative modules.
07:35:26 <shapr> I've used it in Python for years, it's really useful there.
07:36:01 <shapr> sounds like this needs a HaWiki page where we can compare the good and bad points.
07:37:53 <cale> I think it would be nice if there were things in the syntax to describe all the relevant context for the module, so that it can be fit into the hierarchy in the most convenient way. (i.e. specify parent, specify children, or both, as long as there's enough info combined to build the tree)
07:42:14 <SyntaxPolice> hi steveh
07:42:35 <steveh> good morning!
07:44:17 <steveh> ah, it's a hoppin' day on #haskell
07:44:18 <steveh> :)
07:44:31 <Heffalump> BOO!
07:44:59 * shapr hops 
07:45:16 <shapr> Heffalump: you are being the eponymous nightmare today?
07:45:38 <Smerdyakov> Anyone who wants to see mattam try to write Scheme code (and can run Java 1.3+ applets) can come to http://www.hprog.org/fhp/sessions.php and go to the default session. :-)
07:45:47 <shapr> geez, enough advertising...
07:46:22 <Smerdyakov> :-(
07:46:42 <shapr> it's better if it's somewhat on-topic
07:46:47 <shapr> like, if it were Haskell code or something
07:46:57 <cale> Smerdyakov: I get a wiki.
07:47:02 <Smerdyakov> It might be soon!
07:47:06 <Smerdyakov> cale, oops
07:47:12 <shapr> Smerdyakov: that's cool
07:47:12 <Smerdyakov> cale, take out the /fhp
07:47:28 <Smerdyakov> shapr, can I run hugs in a sandboxed way?
07:47:58 <Smerdyakov> I'm only using Scheme now because of the availability of a Java interpreter that can run in an applet.
07:49:01 <shapr> Smerdyakov: I have some info about that, but it's currently swapped out, I'll get back to you in the next coupla days
07:49:53 <SyntaxPolice> shapr mentioned that Smerdyakov went to ICFP last year and registration was around 400 USD? Does anyone else have any guess as to the cost of registration?
07:50:23 <Smerdyakov> SyntaxPolice, hm. I wonder if last year's page is gone.
07:54:00 * SyntaxPolice wonders if ICFP actually goes to the 27th or the 29th
07:54:33 <SyntaxPolice> the little calendar on the front page for PLI'03 seems to indicate the 27th
07:58:11 <Heffalump> anyone know when the contest will be?
07:58:17 <Smerdyakov> The Wayback Machine has cached ICFP 2002 pages, but apparently not late enough to have the registration fees.
07:58:28 <Heffalump> $400 sounds about right, maybe more in fact
07:58:40 <Heffalump> I remember the hotel was very expensive, but Smerdyakov wouldn't have had to pay for that :-)
07:58:43 <Smerdyakov> I paid the student late registration fee... it was around $200, I think.
07:59:13 <Smerdyakov> PLDI is going now. It's probably similar to that fee.
08:05:28 <shapr> Heffalump: I think the nested tuples thing would solve per-module state for any types that weren't typeable
08:05:32 <shapr> even though it is sort of cheezy
08:06:56 <shapr> Smerdyakov: I've been looking for an interactive Haskell environment that works on IRC
08:07:12 <shapr> buggs hacked up a ruby irc wrapper for GHCi, whee did one in erlang
08:07:30 <shapr> they were both full GHCi interpreters though, no sandbox
08:07:56 <shapr> so far Darius' @eval plugin for lambdabot is the best tradeoff.
08:10:07 <shapr> I think it would be possible to hack GHCi into a lambdabot plugin that only allows /dcc of input files and uses a tiny ramdisk or something, but that would still leave CPU/RAM DoS problems.
08:10:13 <Smerdyakov> So they let people read /etc/password and stuff? :)
08:10:19 <Smerdyakov> er /etc/passwd
08:11:14 <shapr> I think a weenie Haskell written from S and K up would be a great teaching tool
08:11:54 <SyntaxPolice> shapr: off topic; did you get anywhere w/ haskell xmlrpc?
08:12:57 <Smerdyakov> Maybe I'll ask afie, that Helium guy.
08:13:18 <shapr> SyntaxPolice: no, not yet.
08:14:43 <shapr> do you have a specific use-case in mind?
08:16:11 <shapr> Marvin--: back so soon?
08:16:32 <Marvin--> yeah, it went straight to hell
08:16:52 <shapr> yow
08:16:55 <Marvin--> or rather, the first map I played I won big, the second I lost big
08:27:47 * Marvin-- can't wait for the new GoT expansion
08:28:07 <shapr> I want Frozen Throne
08:28:14 <Marvin--> me too
08:28:25 <shapr> I'm nearly ready to join the weenies that pre-ordered ;-)
08:28:32 <Marvin--> weenies like me, you mean? :-)
08:28:43 <shapr> heh, you already ordered? :-)
08:29:11 <Marvin--> more like booked one of the copies that'll end up at Tradition in Göteborg
08:29:24 <shapr> I'm thinking of doing the same for tradition in Luleå
08:29:32 <shapr> I don't even own my own copy of w3 yet :-)
08:29:41 <Marvin--> Arthas is on the cover, that can't be bad :-D
08:29:48 <shapr> I want to try running it on winex on my system.
08:30:19 <shapr> transgaming.com w3 forum says it works 4 of 5
08:30:49 * shapr refuses to purchase another copy of the win32 OS
08:31:25 <Marvin--> I got XP Home preinstalled on my laptop, so I'd say it's "okay" that I have XP on this computer too
08:31:44 <Marvin--> at least "okay" as in "not illegal in Sweden", the moral of it can be discussed of course
08:31:48 <shapr> heh
08:33:26 <shapr> hey Marvin--, what do you think about nested tuples for per-module state in lambdabot?
08:34:25 <Marvin--> I didn't understand it :)
08:34:33 <d-bug> i downloaded Rise Of Nations yesterday, they say it is an excellent RTS
08:34:48 <shapr> per-module state in lambdabot uses Dynamic right now
08:34:57 <shapr> would that still work for a Ptr?
08:35:52 <shapr> in any case, nested tuples of (moduleName :: String, moduleState :: whatever, anotherTuple) would work for any types, right?
08:37:09 <Marvin--> I don't follow
08:37:27 <shapr> data ModuleState = forall a. (Typeable a) => ModuleState a
08:37:33 <shapr> ircModuleState     :: FiniteMap String (IORef ModuleState)
08:37:57 <shapr> that's how it is right now, but I don't think that will work for a postgresql database connection
08:38:18 <Marvin--> why not?
08:38:36 <Marvin--> is this one of those TREX discussions? :)
08:38:40 <shapr> sort of, yes
08:38:46 <jlouis> TREX?
08:39:11 <shapr> extensible records
08:39:32 <Smerdyakov> TREX... this is a name that should never have been chosen.
08:40:16 <shapr> hugs has TREX
08:40:18 <shapr> ghc does not
08:41:48 <shapr> I think nested tuples and TREX are closely connected actually.
08:43:04 <jlouis> Tuple-Record-EXtensible?
08:43:15 <shapr> I don't know the acronym
08:43:22 <jlouis> damn, Haskell is so bloated
08:43:30 <shapr> really?
08:44:14 <shapr> Daan used TREX for HaskellDB, I'd like to run HaskellDB on GHC.
08:44:45 <Heffalump> TREX is a pre-processor extension
08:44:50 <Heffalump> it's not part of the language
08:45:17 <Marvin--> Heffalump: oh, yuck
08:53:23 <Igloo> Hmm, is size of generated binaries the only issue with not splitting libraries when building GHC?
08:53:56 <Heffalump> "splitting libraries"?
08:55:28 <Igloo> GHC compiles the libraries to assembler, splits them into chunks, compiles each one individually and then links them back together
08:56:00 * Igloo has discovered that they actually work it you disable splitting and is contemplating making the initial debs with it disabled
08:56:01 <shapr> how/why does it split and then recombine them?
08:56:18 <Igloo> With perl, and that was my question  :-)
08:56:22 <shapr> Is this related to GHC-built binaries being so huge?
08:56:38 <shapr> ah, the Evil Mangler
08:57:02 <Igloo> No, the evil mangler is before that
08:57:10 <shapr> hi o3
08:57:11 <Heffalump> ah, yes, size of binaries is likely to be the only issue, then
08:57:12 <o3> morning
08:57:16 <shapr> wassup?
08:57:17 <Igloo> This is more like the Scary Splitter  :-)
08:57:21 <shapr> haha
08:57:23 <Heffalump> "initial debs"?
08:57:28 <Heffalump> oh, because of 2-stage builds?
08:57:29 <Heffalump> hi o3
08:57:36 <o3> i have a question about iorefs and unsafeperformio
08:57:40 <o3> (now that's a good combination)
08:57:48 * shapr puts on his seatbelt
08:57:55 <o3> i have the following code, which seems to work fine:
08:57:59 <o3> counter :: IORef Int
08:57:59 <o3> counter = unsafePerformIO $ newIORef (42 :: Int) 
08:57:59 <o3> increment = modifyIORef counter (+1) 
08:57:59 <o3> decrement = modifyIORef counter (+ (-1))
08:58:00 <o3> getCounter = readIORef counter
08:58:49 <o3> *IORefTest> a <- getCounter
08:58:49 <o3> *IORefTest> print a
08:58:49 <o3> 42
08:58:49 <o3> *IORefTest> increment
08:58:49 <o3> *IORefTest> a <- getCounter
08:58:51 <o3> *IORefTest> print a
08:58:54 <o3> 43
08:58:57 <o3> *IORefTest>
08:59:04 <o3> my question: is this a safe thing to do? :)
08:59:14 <Marvin--> o3: iirc yes
08:59:33 <Heffalump> no.
08:59:39 <Heffalump> well, possibly in current implementations
08:59:39 <o3> Marvin--: i don't understand what is going on underneath
08:59:51 <Heffalump> but there's no guarantee that counter won't be duplicated by an implementation
09:00:04 <Heffalump> or that another counter defined in the same way won't be merged with that one
09:00:10 <o3> well, what i'm after is a variable which can hold state
09:00:32 <Heffalump> there was a thread about this on the haskell list a few months ago, IIRC
09:00:40 <Heffalump> I forget the conclusion
09:00:58 <Igloo> initial in the sense that the final thing should be built with splitting enabled
09:01:17 <Marvin--> I was under the impression that newIORef was one of the "safe" uses of uPIO
09:01:23 <o3> so that a c program which links in a haskell module can call functions in the haskell module to do stuff (like increment/decrement/getCounter), and the haskell module will retain some sort of state
09:01:40 <Heffalump> the correct test of absolute safety wrt unsafePerformIO is whether each occurrence could be freely CSEd or copied without affecting the behaviour of your program (i.e. that equational reasoning still applies)
09:01:57 <Heffalump> can't you just expose an entirely IO-based interface to the C program?
09:02:51 <o3> Heffalump: i'm not sure how to retain the state after a function called from C finishes, and exits back to the C environment
09:04:13 <Heffalump> ah, hmm.
09:04:42 <o3> if you have a function 'mkCounter = do counter <- newIORef (42 :: Int); return ()', and another function 'increment = modifyIORef counter', that obviously won't work, since counter is only within the scope of the mkCounter function
09:04:56 <Heffalump> hmm, yeah
09:05:32 <Heffalump> I suspect that in practice you'll be ok, but in theory you're in danger.
09:05:37 <o3> the only way i can see of doing it is passing some data type back to the C environment which has all the relevant variables
09:05:45 <o3> which is ok, but i'm wondering if there's another way
09:06:29 <Heffalump> you could always build a thin C wrapper that holds onto that state for you :-)
09:06:56 <Heffalump> it feels like there ought to be a safe way to do this in Haskell, but I can't think what, and I don't recall seeing this on the list before
09:07:18 * Heffalump tries to remember what the thread he was thinking of was
09:07:43 <o3> hmm
09:07:49 <o3> Heffalump: http://www.haskell.org/ghc/docs/latest/html/base/Foreign.html looks interesting
09:08:52 <Heffalump> the polymorphism issue doesn't apply here
09:09:00 <Heffalump> but the fact that newIORef is side-effecting does
09:09:07 <o3> indeed
09:10:32 <o3> reading the haskell-cafe thread on it now; thanks for the pointer
09:14:06 <Marvin--> it's kinda annoying if you can't do it, because creating an IORef inside a function and then passing it around feels a bit pointless...
09:15:23 <o3> hmm
09:15:41 <o3> i wonder if Chilli will kick my ass if i advocate the usage of 'unsafePerformIO $ newIORef ...' in my thesis ...
09:15:59 <Marvin--> it's not unpossible :-)
09:17:28 <Heffalump> blame the FFI spec for encouraging it :-)
09:17:47 <o3> Heffalump: erk, let's not get into _that_ issue :)
09:19:52 <Marvin--> Heffalump: exactly, so let's blame Chilli, hooray ;)
09:25:58 <o3> oooh
09:26:01 <o3> implicit parameters
09:27:57 <o3> yes, this is probably better than talking about using unsafePerformIO :)
09:28:21 <Heffalump> implicit parameters won't help you here, will they?
09:28:31 <Heffalump> C doesn't know how to pass implicit parameters to Haskell :-)
09:28:51 * o3 frowns
09:29:01 <o3> right you are
09:29:10 <Heffalump> using implicit parameters is a syntactic convenience, AIUI, it doesn't really affect generated code
09:32:40 <shapr> does the type of a recursive 3-tuple change if one of the nested tuples is removed?
09:32:42 <shapr> I think it does.
09:32:59 <Igloo> Yes
09:33:30 <shapr> is there such thing as an algebraic nested tuple? ;-)
09:34:00 <shapr> that means the state type can't change at runtime :-(
09:34:01 <Igloo> You what?
09:34:21 <Igloo> Indeed
09:34:28 <shapr> (a, b, (a, c, ()))
09:34:58 <Heffalump> you'll need dynamics if you literally want the type of the state to change at runtime.
09:35:00 <o3> i wonder if it is appropriate to use the word 'fearsome' in a thesis
09:35:09 <o3> as in 'the fearsome unsafePerformIO ...'
09:35:14 <Heffalump> yeah, do it :-)
09:35:19 <shapr> yeah, do it!
09:35:21 <Heffalump> academic writing is too dry anywa
09:35:21 <Heffalump> y
09:35:24 <shapr> truly
09:35:36 <o3> i'll blame you guys if i get a bad mark :)
09:35:38 <shapr> hah
09:36:19 <o3> Heffalump: you would not believe the amount of agony i went through to make my writing more dry
09:36:25 <Igloo> Oege crosses out anything interesting I write
09:36:30 <o3> "technical writing is to the point!  your writing is too flourished!"
09:36:30 <shapr> heh
09:36:43 <SyntaxPolice> o3:  you are referring to ghc as the Glorious Glasgow Haskell Compilation System, right?
09:36:45 <shapr> I like reading fun stuff.
09:37:00 <o3> hmm, chilli is on the channel.  maybe i should be quiet :)
09:37:09 <o3> SyntaxPolice: hey, good idea
09:37:09 <Heffalump> I think you have to be careful in use of "casual" phrases.
09:37:26 <Heffalump> being too chatty is dangerous because it detracts from your message
09:38:08 <o3> Heffalump: if the message concerned is using unsafePerformIO to have global variables, i think perhaps being chatty is a fearsome idea!
09:39:25 <Igloo> "Template Haskell extends a plain old Haskell 98 system, giving the user power previously undreamt of." is the one that springs to mind he didn't like
09:39:37 <shapr> aww
09:40:15 <o3> Igloo: s/dream/nightmare/ :)
09:40:21 <shapr> Heffalump: on the other hand, I chose the LaPalme/Rabhi book over the Okasaki book because it looked like more fun to read.
09:41:16 * Marvin-- sighs at *yet another* "sexy" decon scene
09:41:48 <Heffalump> igloo: that's vague and non-scientific, though.
09:41:50 <shapr> decon?
09:42:06 <Marvin--> shapr: decontamination, I'm watching Enterprise
09:42:08 <shapr> oh
09:42:16 <shapr> it was great the first time
09:42:18 <Igloo> It was just the opening, eye-catching line of an introduction
09:42:20 <Heffalump> "fearsome" refers to the existing wisdom about unsafePerformIO that's well-known
09:42:40 <Heffalump> but if everyone tried to be eye-catching then introductions would just end up trying to outdo each other
09:42:45 <Marvin--> shapr: it was?
09:42:59 <shapr> Marvin--: sure, understated, relaxing, comfortable.
09:43:06 <Marvin--> shapr: I just found it silly
09:43:17 <shapr> they even got the Vulcan chick to persuade Doctor Phlocks(?) to let them stay in a bit longer.
09:43:32 <Marvin--> I repeat, silly
09:46:44 <shapr> how do you load plugins at runtime if you need to create the per-module state at compile-time ?
09:46:56 <shapr> is there any way around Dynamic?
09:47:15 <o3> shapr: runtimeloader
09:47:17 <o3> :D
09:47:38 <Marvin--> shapr: the *type* of the state has to be static at compile time
09:48:29 <shapr> that means all possible plugin state types have to be known at compile time though.
09:48:33 <shapr> riht?
09:49:59 <Heffalump> doesn't runtimeloader require dynamics?
09:50:04 <shapr> other than using Dynamic, is there some way for a plugin to know its own state type without the main program needing to know?
09:50:08 <Heffalump> shapr: right.
09:50:10 <shapr> hi sailor
09:50:15 <Heffalump> shapr: no.
09:50:22 <shapr> fooey
09:50:34 <Heffalump> oh, hangon, unless you do something cunning with abstract types
09:50:39 <Heffalump> but I suspect it's not possible.
09:50:39 <shapr> like?
09:50:55 <shapr> can you give me some pointers to the abstract type stuff?
09:50:55 <Heffalump> I can't think of anything right now.
09:51:05 <Heffalump> not really, no.
09:51:17 <shapr> the name is enough
09:51:19 * shapr googles
09:51:27 <shapr> hello sailor, learning Haskell?
09:51:49 <sailor> nope.. 
09:52:03 <shapr> Already know Haskell?
09:52:24 <sailor> shapr not a bit.. actually, im checking it out,, :)
09:52:54 <shapr> Have any questions?
09:53:29 <shapr> I'd suggest you start with http://www.haskell.org/learning.html
09:53:51 <sailor> not yet.. and i'm currently: Session started Sat Mar 29 20:08:03 2003
09:53:51 <sailor> [20:08] <BigBozz> du har mitt divine divinity din jefel!
09:53:51 <sailor> [20:08] <BigBozz> tror jag iaf
09:53:51 <sailor> [20:08] <Svarth> jope.. sant
09:53:51 <sailor> [20:29] <Svarth> eller, jag tror det.. vet inte om jag har kvar skivorna..
09:53:52 <shapr> I can point you to some simple code I've written.
09:53:56 <sailor> oopss.
09:54:19 <sailor>  where?
09:54:27 <shapr> are you studying for a computer science degree?
09:54:37 <sailor> I am
09:54:46 <shapr> http://kungens.kemi.fi/~shae/src/haskell/Mandelbrot-0.1.hs
09:55:02 <shapr> Which university do you go to?
09:55:14 <shapr> Chalmers? KTH? LUTH?
09:55:52 <shapr> That code is a text fractal grapher
09:55:56 <sailor> nope.. "JAG studerar på ett gymnasium :) " 
09:56:00 <shapr> it's the first thing I wrote, it's not very exciting
09:56:53 <shapr> Do you know some functional programming languages?
09:57:01 <shapr> maybe lisp, elisp, scheme?
09:57:10 <sailor> nope, sure dont
09:57:54 <shapr> some other programming languages?
09:58:08 <sailor> C, C++ and pascal 
09:58:21 * Heffalump wonders if shapr is the Spanish Inquisition
09:58:46 <shapr> Heffalump: bah, I'm just trying to help :-)
09:59:06 <Heffalump> :-)
09:59:21 * sailor *Host* tumskruvar *Host*
09:59:24 <dennisb> NOBODY expects the Spanish Inquisition!
09:59:44 <shapr> tumskruvar?
09:59:58 <shapr> aha
10:00:02 * shapr grins
10:00:12 <shapr> thumbscrew :-)
10:00:13 <sailor> :)
10:00:33 <shapr> jag kan tala lite svenska, jag studerar på SFI
10:00:54 <shapr> Svenska för Invandrare, aka Swedish for Invaders ;-)
10:01:16 <sailor> he :)
10:01:35 <jlouis> :P
10:01:39 <jlouis> sure funny fe are
10:01:42 <jlouis> ye ;)
10:01:49 <jlouis> friggin' dvorak :)
10:01:52 <sailor> shapr SFI?
10:02:32 <shapr> hey, I like dvorak
10:02:51 <shapr> sailor: as I said, Svenska för Invandrare
10:03:51 <sailor> Ohh, so it was a something-funny flying straight over my head!
10:05:41 <jlouis> sailor: I will recommend you to learn a functional language. It will help you program better programs for sure
10:05:51 <shapr> I agree.
10:06:30 * jlouis is the enemy :P
10:06:52 <shapr> ?
10:07:02 <sailor> Then maybe i will.. 
10:07:06 * jlouis is member of the whole cult of SML!
10:07:18 <shapr> I am not a member of the Haskell Secret Underground.
10:07:25 <shapr> In fact, the HSU doesn't even exist.
10:07:32 <jlouis> holy, my hand-eye-brain coordination sucks today
10:08:00 <jlouis> though I like Haskell a lot
10:08:04 <jlouis> and Scheme
10:08:07 <shapr> did you poke your eye when trying to scratch your head?
10:08:12 <shapr> Scheme is nifty.
10:08:19 <shapr> I had fun with Joy also.
10:08:22 <jlouis> I like the simplicity
10:08:37 <jlouis> and call-with-current-continuation ;)=
10:08:47 <Smerdyakov> SML/NJ has that.
10:09:00 <jlouis> Smerdyakov: yeah, CML is implemented with help from it :)
10:09:09 <Smerdyakov> Bad way to implement CML...
10:09:12 <jlouis> SML/NJ also has Okasakis $-notation
10:09:13 <Smerdyakov> Muchos SLOWOS
10:09:14 <shapr> does GHC support restricted data types?
10:09:41 <shapr> yay, it does!
10:09:44 * shapr bounces cheerfully
10:09:53 <Marvin--> restricted data types?
10:09:53 <keverets> TINC
10:09:57 <shapr> data Eq a => Set a = Set [a]
10:09:57 <jlouis> Smerdyakov: they might have changed it. I think I read that was implemented by call-CC
10:10:02 <Marvin--> oh
10:10:15 <shapr> I'm still trying to find some way to beat the system.
10:10:32 <shapr> keverets: TINC?
10:10:34 <Smerdyakov> jlouis, it is, and it's not bad given existing compiler design decisions. But they have no usual runtime stack and use garbage collected stack-like heap things instead, which makes it slow.
10:10:46 <keverets> shapr: in reference to the HSU
10:11:02 <shapr> There Is No Challenge?
10:11:14 <jlouis> Smerdyakov: ouch!
10:11:20 <shapr> @jargon tinc
10:11:21 <lambdabot> *** "TINC" jargon "Jargon File (4.3.0, 30 APR 2001)"
10:11:21 <lambdabot> TINC // [Usenet] Abbreviation: "There Is No Cabal". See {backbone
10:11:21 <lambdabot>    cabal} and {NANA}, but note that this abbreviation did not enter use
10:11:21 <lambdabot>    until long after the dispersal of the backbone cabal.
10:11:25 <shapr> oh
10:11:35 <shapr> cool
10:12:02 <shapr> I wonder if I could use fundeps to construct a parameterized module state type
10:12:26 <o3> ah, there we go
10:12:34 <o3> \item Use the fearsome \inline{unsafePerformIO (newIORef \emph{x})} hack\cite{HUGH03} to enable mutable, top-level (global) variables in Haskell.  The use of this technique is neither advocated or disapproved of, and there is much debate in the Haskell community\cite{CAFE03} about properties of its usage.  This technique is, however, only recommended for Haskell programmers who truly understand its consequences.
10:13:17 <shapr> the number of people who truly understand the consequences is smaller than the number of those who think they do.
10:13:58 * shapr counts himself in there somewhere.
10:14:17 <o3> maybe i'll just take out the last line
10:18:02 <Marvin--> ugh, I so need to start working on my report
10:18:14 <Marvin--> and I so need to take my break from the project serious
10:20:18 <Marvin--> -ly... seriously
10:21:45 <Marvin--> shapr: I hope you've listened through all the sounds of the War3 units? :P
10:22:01 <Marvin--> I realized the other day that I hadn't listened through all the heroes
10:22:07 <Marvin--> most of them are pretty boring, but the dreadlord was fun
10:22:31 <Marvin--> "For the last time, I'm a *Dread Lord*, not a *Drug Lord*"
10:47:08 <d-bug> Marvin--: :-))
10:47:12 <steveh> mph
10:47:19 <d-bug> is that from WC3?
10:47:22 <steveh> offside rule is killing my use of this book I think
10:52:14 <Marvin--> d-bug: yes
11:23:39 <jameson> Hmm... is there a way in Haskell98 to define an algebraic type with a constrained type parameter?
11:24:00 <jameson> Something like "type Eq a => MyType a = ..."
11:25:01 <Smerdyakov> I don't think so.
11:25:13 <Smerdyakov> Type classes only matter for what operations you can perform with certain types.
11:25:18 <Smerdyakov> They aren't properties of the types.
11:25:41 <Smerdyakov> What you probably want is a rule for making an instance of MyType a whenever Eq a.
11:25:54 <Smerdyakov> (er, an instance of Eq (MyType a)
11:26:56 <jameson> Hmm... can I do that when I'm using typecons which already are of that class?
11:27:20 <steveh> I can't tell what this type checking error is trying to tell me...
11:27:29 <jameson> (i.e. when giving a name to a constructed type).
11:27:33 <steveh> Instances of (Floating Int, RealFrac Int) required
11:28:04 <jameson> Smerdyakov: Other than that, your justification makes sense, although it would have been convenient to be able to get the restriction on function types implicitly in that fashion.
11:29:23 <Smerdyakov> jameson, you want to have two different Eq interpretations of one type>
11:29:23 <jameson> steveh: Don't know about RealFrac, but Floating is a typeclass parameterised by Int, so 'RealFrac Int' is a typeclass.
11:29:33 <Smerdyakov> ?
11:29:46 <steveh> hm
11:31:14 <jameson> Smerdyakov: No. But I think I see where my mind went wrong now...
11:32:02 <jameson> steveh: Sorry, meant 'Floating Int', but it's the same with 'RealFrac Int'. You need values of types matching these typeclasses.
11:33:15 <jameson> Smerdyakov: Just using the default implementation will work, I just wanted to make sure it's available (and to get type errors as early as possible).
11:33:44 <Smerdyakov> Well, there is no default implementation for new types, unless you use 'deriving Eq'.
11:35:09 <steveh> mph
11:36:30 <jameson> steveh: Re-reading what I said earlier, it's complete garbage, my apologies.
11:37:09 <jameson> steveh: What the type system tells you is that it needs, in some place, values of types within the type classes Floating and RealFrac.
11:37:21 <jameson> Further, it tells you that it encountered values of type 'Int'.
11:37:44 <jameson> As such, it deduces that Int is required to be a type of type class Floating (and RealFrac).
11:37:54 <steveh> ok
11:38:09 <steveh> so the best way to fix it is a fromIntegral on the offending value?
11:38:12 <jameson> Since you must explicitly provide the witnesses for membership in a typeclass, it tries to look for an 'instance' declaration where you do that.
11:38:22 <jameson> It doesn't find one, that's where the error comes form.
11:38:47 <steveh> at least that's a way I've discovered that works
11:38:53 <steveh> was wondering if it's best stylistically
11:38:59 <jameson> steveh: Not sure, that may work.
11:39:09 <steveh> definitely works
11:39:26 <jameson> It's possible that you're just using literals without decimal points...
11:40:01 <jameson> ...but if that's not the problem, you'll need a conversion function, and if fromIntegral compiles, it'll probably work, too ;-)
11:40:33 <steveh> no, I specify Int in a type signature and then use it in the expression "round (size / sqrt 3.0)"
11:40:47 <steveh> where size is the argument specified as Int
11:41:07 <steveh> "fromIntegral size" was the fix that worked
11:41:29 <steveh> at the prompt things like round (5 / sqrt 3.0) work
11:41:40 <steveh> actually round (5 / sqrt 3) too, I think
11:41:56 <steveh> but that's probably because 5 and 3 weren't explicitly declared as Int
11:42:00 <steveh> whereas size was
11:42:03 <Igloo> Yes
11:42:06 <Igloo> @type (/)
11:42:07 <lambdabot> (/) :: Fractional a => a -> a -> a
11:42:09 <steveh> the error message was just very, very bad
11:42:16 <Igloo> So the two arguments must have the same type
11:42:16 <steveh> asking for things that don't exist and whatnot :)
11:42:44 <steveh> I was thinking "WTF is a Floating Int?"
11:42:46 <steveh> :)
11:42:54 <Riastradh> It's an int suspended in midair.
11:43:00 <steveh> heh
11:43:03 <steveh> indeed
12:55:30 <shapr> ow
12:56:03 <shapr> hi bea 
12:56:09 <shapr> would you like to learn Haskell?
12:56:29 <bea> hi shapr... no, I've come to talk to SyntaxPolice behind your back :)
12:56:45 <bea> hi SyntaxPolice
12:56:56 <SyntaxPolice> hi bea!
12:57:23 <bea> SyntaxPolice: I had to quit my game to come talk to you, so it'd better be good :)
12:57:59 <SyntaxPolice> first things first, does Shapr really bounce as much as he claims?
12:58:05 * shapr snickers
12:58:13 <bea> SyntaxPolice: more
12:58:18 <Riastradh> Wow!
12:58:44 * Riastradh is awed that it's possible to bounce more than shapr does on IRC without sudden disintegration of one's legs.
12:59:03 <shapr> well, I have very strong legs.
12:59:05 <bea> Riastradh: he has a solid set of legs
12:59:20 * bea rests her case
12:59:26 <Riastradh> How does blood get to his feet if they're solid?
12:59:54 <bea> Riastradh: they don't need to be homogeneous to be solid, do they?
12:59:56 <Riastradh> OK, go on.
13:00:13 <Riastradh> Never mind.
13:02:01 <Igloo> Oh, a bea!
13:02:11 <bea> oh, an icehouse!
13:02:32 <Riastradh> No, just a house -- 'igluvigak' or something is an ice house.
13:03:24 <bea> wasn't the bot called lambdabot?
13:03:38 <Riastradh> lambdabot: @hello
13:03:39 <lambdabot> Hello world. 
13:04:47 <lambdabot> And hi bea, too.
13:06:17 <bea> Riastradh: I am still not impressed :)
13:06:27 <Riastradh> @yow
13:06:28 <lambdabot> YOW!!  I'm in a very clever and adorable INSANE ASYLUM!!
13:06:32 <Riastradh> Is that more impressive?
13:06:59 <bea> Riastradh: absolutely. That one got a laugh, albeit a _very_ unwilling one...
13:08:28 <bea> Igloo: I am sorry, Riastradh sidetracked me with a lambdabot-showoff. Hello!
13:08:57 <Igloo> Hello. Have you decided to learn Haskell yet?
13:09:13 * Riastradh tends to sidetrack the discussion in most channels he's in besides the functional language ones.
13:09:34 <Riastradh> I guess it's spilling in here, too.
13:09:39 <Igloo> :-)
13:11:36 <bea> Igloo: I am from a dysfunctional family. It wouldn't work.
13:13:49 <Igloo> Oh well, I'm sure a little longer living with shapr will convince you otherwise
13:14:15 <Riastradh> And more discussion about monadic and arrow stuff will only encourage your curiosity!
13:14:18 <Igloo> Well, to be more precise I'm sure you'll learn it whether you decide to try to or not  :-)
13:14:41 <bea> Igloo: he's rammed Linux and Zope down my neck in no time flat, so who knows
13:14:45 * Igloo notices shapr has gone to sleep
13:15:01 <Igloo> Do you work, bea?
13:15:04 * bea adds that shapr is reading over her shoulder and snickering
13:15:22 <bea> Igloo: naa, shapr likes them barefoot and pregnant
13:15:40 * Igloo blinks
13:16:11 <Marvin--> yowz, what's happening here?
13:16:20 <shapr> actually, bea and I own parts of the same company
13:16:28 <bea> Igloo: I am the managing partner of the company that shapr works with
13:16:31 <shapr> hiya Marvin--, have you met Bea before?
13:16:39 <Igloo> Oh, cool
13:16:53 <Marvin--> shapr: nope
13:16:59 <bea> Igloo: so that means that shapr works and I make the dough
13:16:59 <Marvin--> hi bea
13:17:05 <shapr> Marvin--: hon kan tala lite svenska ocksa
13:17:12 <Marvin--> :)
13:17:15 <Marvin--> hej bea :)
13:17:21 <Igloo> :-)
13:17:23 <shapr> yah, bea just talks on the phone all day, and I write code in the background.
13:17:26 <shapr> :-P
13:17:41 <Marvin--> shapr.code &
13:17:51 * Marvin-- groans at himself
13:17:54 <shapr> ?
13:17:57 <Igloo> Marvin: We're subtly introducing bea to Haskell. For example, if we talk about typing "hugs" then "map (1+) [2,3,4]" in a shell then she'll get curious and have to try it
13:18:06 <Marvin--> Igloo: heh
13:18:29 <Marvin--> shapr: you know... shell + &... background...
13:18:41 <Riastradh> She'll get especially curious when we talk about monad and arrow stuff.
13:18:42 <shapr> heh
13:18:51 <shapr> yes, arrows, monads... yay!
13:18:59 * Igloo wonders if bea has tried it yet
13:19:05 <bea> Hej Marvin! så, är du svensk?
13:19:10 <Marvin--> bea: japp
13:20:07 <bea> jättebra. Nu ska vi se hur mycket shapr har lärt sig ;)
13:20:22 <shapr> tilrackligt
13:20:23 <jlouis> jeps, det kan vi da godt ;)
13:20:44 <Marvin--> jlouis: :)
13:20:48 <shapr> jlouis: jag tror du är dansk?
13:21:33 <Marvin--> and people don't agree with me when I say that Swedish, Danish and Norwegian are the same language, sheesh
13:21:52 <tic> heh
13:21:55 <jlouis> shapr: bingo :)
13:21:57 <Igloo> Yeah, they're all forrun  :-)
13:22:12 <tic> Danish definitely isn't Swedish.
13:22:39 <bea> Danish sounds like Swedish spoken by a German with an aristocracy complex
13:22:49 <el_diego> hehe
13:23:29 <shapr> there are a large number of europeans on #haskell
13:23:47 <bea> Riastradh: shapr monologues about arrows and monads over breakfast cereals and picks up speed from there, every day. My excitement is contained :)
13:23:47 <jlouis> bea: bow before my will!
13:24:29 <Riastradh> bea, oh, darn, so he's already tried monad and arrow talk and it won't be new if we try it.
13:24:37 <bea> jlouis: you one of those nasal-speaking guys, too?
13:24:39 <wli> I just hack the kernel all day while not actually writing Haskell.
13:24:52 <Riastradh> Blasphemer!
13:24:58 <shapr> wli: but you keep threatening too. I've heard it.
13:25:10 <shapr> er "threatening to write haskell"
13:25:13 <bea> Riastradh: it wouldn't get you anywhere anyhow... shapr has a way with arrows...
13:25:15 <wli> I think I threatened Janni with writing Haskell the other day.
13:25:18 <shapr> oy
13:25:19 <wli> It didn't get very far.
13:25:23 <jlouis> bea: well, my girlfriend is German... might be I just happen to have that complex :)
13:25:34 <shapr> ich habbe keine ahnung
13:25:57 <bea> jlouis: so you would call me beääää too then. I believe that's what Danes call me
13:26:05 * Riastradh is American and knows only English...blah.
13:26:18 <bea> Riastradh is a sad individual
13:26:21 <shapr> Riastradh: and Haskell.. that probably counts as a furren language.
13:26:27 <jlouis> bea: rather a flat 'a' sound
13:26:30 <Riastradh> Furren?
13:26:32 <bea> Riastradh est un pauvre individu
13:26:39 <shapr> you know, not from the same town, as in furreners.
13:26:44 <bea> Riastradh ist ein armes Individuum
13:26:47 <Riastradh> bea est un navet defile.
13:26:58 <bea> Riastradh: got me :)
13:27:36 <Riastradh> Votre mere etait un hamster et votre pere a senti des baies de sureau!
13:28:01 <Riastradh> That's the most useful French sentence you'll ever know.
13:28:16 <jlouis> "f..." ++ "this"
13:28:17 * Marvin-- laughs at Scrubs
13:28:25 <jlouis> probably with a " " in there also
13:28:45 <Marvin--> jlouis: unwords ["f...","this"]
13:29:36 <jlouis> Marvin--: unfortunately, my knowledge of the Haskell prelude is not what I would want it to be
13:29:57 <Marvin--> jlouis: what, you mean you're not sleeping with a copy of Prelude.hs under your pillow?
13:31:20 * Riastradh sleeps with a copy of R5RS, the Haskell report, the entire Cocoa documentation, the OCaml manual, -and- the SML basis report under his pillow.
13:31:30 <Riastradh> It's getting pretty difficult for blood to go to my head in the night.
13:32:29 <Marvin--> Riastradh: I bet
13:33:53 * bea won't even venture in the general direction of things that she could add to that
13:40:40 <Riastradh> ...tumbleweed...
13:41:29 * shapr yawns
13:41:58 <shapr> hey, I got an email from Carl Witty, he pointed out to me that the Numeric Quest libraries *are* GPL licensed, but at the end of the file.
13:42:04 <shapr> for some reason I never thought of looking there.
13:43:10 * bea yawns too. Sleepytime
13:43:20 <Marvin--> tail-licensing? :-P
13:43:27 * Riastradh curses.  It's early in the afternoon for him, as he doesn't live in Europe.
13:45:14 <bea> Riastradh: not every one can be lucky
13:46:31 <shapr> heh
13:47:44 <bea> shapr: call it a night?
13:47:49 <Riastradh> And that's why I'd prefer to live in a more Socialist nation!
13:48:52 <Marvin--> Riastradh: I fail to see the connection
13:49:37 <bea> Marvin--: I was too sleepy to ask...
13:49:47 <Riastradh> 'not everyone can be lucky' -- a more Socialist nation will protect against being -horrifically- unlucky.
13:49:53 <Riastradh> Er, well, protect against the results thereof.
13:50:07 <shapr> bea: must... watch... tv!
13:50:11 <Marvin--> Riastradh: heh
13:50:17 <Marvin--> shapr: Futurama at 23.30!
13:50:17 * bea is surpassed by that much philosophy
13:50:24 <bea> 'nightnight
13:50:34 <Riastradh> Yuck, TV.
13:50:35 * shapr yawns more
13:50:47 <shapr> Riastradh: Star Trek :-)
13:51:21 <Marvin--> shapr: yuck, Star Trek
13:51:39 * Marvin-- watched the last episode of season two of Ent
13:52:11 * shapr yawns
13:52:19 <shapr> see you guys tomorra
13:53:25 <Riastradh> Bye.
14:04:08 <Marvin--> damn negations
14:37:48 <cale_> Marvin--: negations? Are you referring to the issues using (-) in sections?
14:37:57 <Marvin--> cale_: no, totally unrelated
14:39:30 <jameson> Is it possible to define classes of equally-kinded type constructors, similar to type classes, in Haskell?
14:40:22 <Igloo> Yes, if I understand you correctly
14:40:27 <jameson> I'd like to write something like "typeclass Cl (Con a) where  f :: Con a -> Con b -> Con (a, b)"
14:40:34 <Igloo> That's what Monad does
14:41:07 <Igloo> You don't want the a in the head
14:41:31 <jameson> Igloo: Yes, exactly-- Monad does just that. Thanks!
14:44:28 <Marvin--> heh, fun Futurama episode, a tiny civilization takes residence on Bender, and then die in atomic wars
14:47:20 <cale> oh yeah, I remember that one :)
14:48:32 <TheDD> Heffalump: ?
14:48:35 <Marvin--> heh, Bender can't speak binary
14:49:07 <TheDD> % cat tests/capture2.in && ./ovide -p < tests/capture2.in
14:49:07 <TheDD> ({x1} P(x1)) & ([x1] Q(x1))
14:49:07 <TheDD> ({z1} ([z2] (P(z1) & Q(z2))))
14:49:07 <TheDD> :))
14:50:46 <cale> TheDD: cool :)
14:50:58 <TheDD> thx :)
15:02:23 <Heffalump> thedd: hmm?
15:02:43 <TheDD> it works :)
15:02:47 <Heffalump> ah, cool.
15:11:37 <TheDD> ++
15:16:06 <cale> weird - the server says I got dropped for excess flood at a point in time that I was sleeping.
15:25:18 <Darius> Perhaps you were snoring.
15:26:42 <Riastradh> And your voice recognizer, being stupid like most are, picked it up as 'send HELLO, WORLD! to ChanServ' at every crest of your sound waves from snoring.
15:27:25 <mgoetze|1way> shapr: hm, indeed. maybe that's why i keep getting disconnected :)
15:39:40 <cale> heheh
17:05:26 <Darius> Pseudonym: you've programmed in Mercury right?
17:05:53 * Smerdyakov chuckles.
17:33:38 <Pseudonym> Uh, you could say that.
17:34:42 <Darius> Have you programmed in any other functional logic languages?
17:35:32 <Pseudonym> Yes, Haskell. :-)
17:35:40 * Pseudonym wrote a logic programming monad transformer for the purpose
17:35:58 <Pseudonym> Apart from that, no.  I've read the Goedel book, but I never used it.
17:36:22 <Pseudonym> Interesting story about how Mercury was bootstrapped, incidentally.
17:36:34 <Pseudonym> Fergus started off with a Mercury -> Goedel translator.
17:36:50 <Pseudonym> The first cut of the compiler was written in the subset of Mercury which is also Prolog.
17:37:44 <Pseudonym> Erm.
17:37:55 <Pseudonym> He used Goedel's type checker to effectively get a typed subset of Prolog.
17:38:04 <Pseudonym> It was kinda cool.
17:39:40 <Pseudonym> I think the netsplit is fixed.
17:41:56 <Smerdyakov> Pseudonym, for what domains would you recommend Mercury over Haskell?
17:42:04 <Igloo> Yeah, I'm afraid I'm back
17:42:28 <Pseudonym> Smerdyakov: I'm not sure that I would, any more.
17:42:36 * Riastradh supposes he should probably read Goedel, Escher, Bach.
17:42:43 <Pseudonym> Yes, you should.
17:43:22 <Pseudonym> Especially if you know anything about music.
17:43:30 <Pseudonym> Anyway.,
17:43:45 <Pseudonym> Smerdyakov: There's something quite nice about predicates compared to functions.
17:44:27 * Igloo keeps seeing that mentioned
17:44:43 <Pseudonym> Most nontrivial procedures/functions/predicates/call them what you will need to return more than one value.  Haskell's solution is to return a tuple.  C++'s solution is to pass a few references.
17:44:52 <Pseudonym> There's soemthing nice about just returning multiple values.
17:45:24 <Pseudonym> It's very clean.
17:45:36 <Pseudonym> Having said that, I don't think that Mercury is quite there yet.
17:46:02 <Pseudonym> I said at the time that it's going to be Mercury's successor which will be the logic language of the future.
17:46:24 <Riastradh> Scheme's solution is to...return multiple values!
17:46:27 <Pseudonym> Programming in Mercury today, IMO, is like programming in ML thirty years ago.
17:46:41 <Pseudonym> It's kinda rudimentary.
17:47:02 <Pseudonym> There are a couple of research hurdles still to be gotten over before it hits the sweet spot.
17:47:07 <Smerdyakov> ML thirty years ago? I didn't know ML existed in 1973.
17:47:08 <Fractal> Forth's solution is to ... return multiple values!
17:47:30 <Pseudonym> Riastradh: How do you return multiple values in Scheme?
17:47:51 <Riastradh> Pseudonym, with the VALUES function, or by applying a continuation reïfied into a procedure multiple arguments.
17:48:21 <Riastradh> (an example definition of VALUES as given by R5RS is:  (lambda vals (call/cc (lambda (k) (apply k vals))))
17:48:32 <Pseudonym> Well of course you can do a continuation in Haskell, too.
17:48:35 <Pseudonym> But that's a bit ugly.
17:49:10 <Pseudonym> In Mercury, returning multiple values is done exactly the same way that you pass multiple values.
17:49:28 <Pseudonym> You load "in" parameters into registers, call, and the "out" parameters are in registers when you're done.
17:49:32 <Riastradh> Pseudonym, you can reïfy a continuation, but you can't apply it to multiple arguments or return multiple values with it.
17:49:42 * Smerdyakov smacks Riastradh for using dotty-things.
17:49:58 * Pseudonym would have to actually use it to get what Riastradh is talking about
17:51:15 * Riastradh bahs at Smerdyakov and states that they're called diareses.
17:52:13 * Smerdyakov states that you're King of the Pedants.
17:52:24 <Pseudonym> It depends on their purpose.
17:52:32 <Pseudonym> In German, of course, they're umlauts.
17:52:48 <Darius> But Germans don't put umlauts over i's.
17:52:55 <Pseudonym> Correct.
17:53:59 <Pseudonym> I didn't get a diaresis.  I must have a terminal that's too smart for its own good.
17:54:14 <Riastradh> If they indicate that the vowel over which they are written is to be pronounced in a different syllable than the vowel directly prior to it, it is a diaresis; if it changes a vowel's sound, it is an umlaut; if otherwise, then the person who wrote it needs to learn what it means.
17:54:14 <Pseudonym> Oh, yes, ML dates from about 1973.
17:54:29 <Smerdyakov> Pseudonym, odd. I saw 1983 given as the inception date.
17:54:40 <Pseudonym> 1983 was Standard ML
17:54:44 <Smerdyakov> OK
17:54:44 <Pseudonym> From memory.
17:55:05 <Riastradh> Knew you not that Caml was from before SML thus allowing you to infer that ML was around before 1983?
17:56:43 <Pseudonym> Anyway, back to Mercury. :_)
17:57:03 <Pseudonym> Mercury's biggest problem is that to do anything semi-complex requires nontrivial instance declarations.
17:57:08 <Pseudonym> And they're horrible to work with.
17:57:27 <Pseudonym> It doesn't help that Mercury can't really handle polymorphic modes very well.
17:58:03 <Pseudonym> You can do most things with just ground modes, of course.
17:58:29 <Pseudonym> If I need a list of values, for example, I can hand in a number and get a list with that many values back.
17:58:49 <Pseudonym> But it's a logic language!  I want to hand it a list with N free variables and not have to count them.
17:59:04 <Pseudonym> Mercury can't handle that.
17:59:10 <Pseudonym> Not yet, anyway.
17:59:33 <Pseudonym> I also found that higher-order programming is unnecessarily painful a lot of the time.
18:00:25 <Pseudonym> Because a higher order predicate doesn't have a ground inst.  It also has the mode of the predicate attached.  So you can't just say "in".
18:00:49 <Pseudonym> The dataflow of functional programming simplifies a LOT of things.
18:09:28 <Riastradh> What logic language do you suggest one learn first?
18:09:44 <Pseudonym> Definitely Prolog.
18:09:49 <Pseudonym> It's the most ubiquitous.
18:10:17 <Pseudonym> And most other logic languages' tutorials are written assuming you already know Prolog.
18:10:26 <Pseudonym> "Here's how we fix serious problem X that you find in Prolog!"
18:10:42 <Riastradh> OK.
18:10:47 * Riastradh started reading a Mercury tutorial.
18:10:55 <Pseudonym> Go for it.
18:11:03 <Darius> Prolog is so disgusting.
18:11:08 <Pseudonym> Oh, it is.
18:11:28 <Riastradh> Is there an official Prolog website or anything?
18:11:34 <Pseudonym> Uhm, probably not.
18:11:48 <Darius> I'm checking out Curry right now, which was part of the reason for my initial question.
18:11:49 * Riastradh arghs, must go.
18:11:57 <Darius> There is a Prolog book online.
18:12:31 <Pseudonym> When we were doing literature reviews for Mercury, we discovered just how bad the situation is with Prolog.
18:13:03 <Pseudonym> They talked, for example, about static analyses and you'd read something like "yes, we know it's superlinear, but it runs fast, even on large 1000 line programs".
18:13:20 * Pseudonym almost choked on his coffee when he read that
18:13:42 <steveh> hey, a thousand lines of logic is pretty damn long
18:13:43 <steveh> :)
18:13:54 <Pseudonym> Well the Mercury compiler was 13,000 lines at the time.
18:13:58 <Pseudonym> It's now about 130,000 lines.
18:14:00 * Smerdyakov has just installed Vindigo on his PDA.
18:14:26 <Pseudonym> Actually, it now targets .net, so it's probably close to 200 KLOC now.
18:14:39 <Pseudonym> Haven't kept up with it lately.
18:34:11 <Smerdyakov> What about this: http://www.everything2.com/index.pl?lastnode_id=124&node_id=21650
18:34:19 <Smerdyakov> Someone claims ML was "born" in 1983.
18:44:05 <Pseudonym> M. Gordon, Robin Milner, L. Morris, M. Newey, C. Wadsworth: A Metalanguage for Interactive Proof in LCF. POPL 1978: 119-130
18:44:18 <Pseudonym> That's the earliest paper specificially on ML (i.e. Metalanguage) that I can find.
18:44:25 <Pseudonym> But I'm pretty sure it dates back to about 1973.
18:44:34 <Smerdyakov> It had polymorphic type inference then?
18:44:45 <Pseudonym> Robin Milner: A Theory of Type Polymorphism in Programming. JCSS 17(3): 348-375 (1978)
18:44:56 <Pseudonym> Yes. :-)
18:45:06 <Pseudonym> I'm pretty sure.
18:45:20 <Pseudonym> Oh, and this.
18:45:28 <Pseudonym> oRobin Milner: Fully Abstract Models of Typed lambda-Calculi. TCS 4(1): 1-22 (1977)
18:46:43 <Smerdyakov> Ooo.
18:47:14 <Pseudonym> By 1983, Milner was off the basics and was working on concurrency.
18:49:41 <Pseudonym> Now that I think of it, ML was a plug-in language for the LCF theorem prover.
18:50:00 <Pseudonym> I'd be very, very surprised if ML didn't have type inference, given that it had a theorem prover sitting right there. :-)
18:52:26 <Darius> Yeah, unification is small potatoes.
18:52:51 <Pseudonym> OK, this paper claims that ML was designed in 1975.
18:53:07 <Pseudonym> It's the O'Caml tutorial.
18:53:15 <Pseudonym> 1975 sounds about right.
18:56:16 * Pseudonym should really learn O'Caml some time.
18:57:25 <kip> i tried writing a decent size project in O'Caml.  the thing that bothered me most was like of mutually recursive modules
18:57:43 <kip> lack of
18:58:07 <Pseudonym> Well you have that in Haskell too.
18:58:18 <Darius> Haskell 98 has mutually recursive modules, but there are no Haskell 98 compilers.
18:58:22 <Pseudonym> Right.
18:58:31 <Pseudonym> Mercury has it!
18:58:50 <Pseudonym> It's had mutually recursive modules since the year dot.
18:59:33 <Pseudonym> This, IMO, is one of the things that Mercury did right.  We mandated that all exported modules had to have all of their declarations explicit.
18:59:49 <Pseudonym> Sorry, all things exported from modules.
19:00:09 <Pseudonym> That way, you can extract a module's "interface" without having to do static analysis.
19:00:28 <Pseudonym> That makes separate compilation almost trivial.
19:41:51 <ddarius> The CGI library for Curry is pretty cool.
19:51:45 <ddarius> Hmm, I wonder how much trouble adding type classes would be.
20:02:46 <Darius> Hmm, it appears Curry doesn't have uncurry (or at least they didn't use it in this example for some reason).
20:30:03 <Darius> Pseudonym: Read "Typed Logical Variables in Haskell" by Koen Claessen and Peter Ljungloef?
22:32:08 <Darius> Extensive use of rank-2 types is twisted.  With some CPS thrown in too!
23:32:47 * shapr boings
23:33:13 <Darius> holy crapola, I got it working.
23:33:19 <shapr> what?
23:33:48 <Darius> Copying (and filling in the blanks) of the typed logical variables from the paper I mentioned above.
23:34:12 <shapr> yay!
23:34:22 <shapr> can I get a copy of the code?
23:34:43 <Darius> want me to email it to you?
23:35:04 <shapr> yes please!
23:35:08 <Pseudonym> G'day shapr.
23:35:13 <shapr> g'day Pseudonym!
23:35:26 <shapr> it's 8:35am here, are you staying late at work?
23:35:38 <Pseudonym> It's 4:35pm here.
23:35:48 <Pseudonym> And I'm not planning to stay too late.
23:45:31 <Darius> Hmm, I add an instance of Unify for Type and I can probably rewrite my HM inferencer using these.
23:47:09 <shapr> Pseudonym: read any nifty papers lately?
23:48:22 <shapr> Pseudonym: hey, someone sent me an email pointing out that the Numeric Quest code is license at the very end of the files, and I never noticed... d'oh!
23:48:43 <Pseudonym> Not realy.
23:48:48 <Pseudonym> Oh, interesting.
23:49:16 <shapr> so now I can add all the numeric quest libs to haskell-libs
23:49:47 <Pseudonym> Woohoo
23:51:04 <Pseudonym> To answer your question, no, haven't read an interesting papers lately.
23:52:31 <Darius> shapr: it works in 6.1 too and (not surprisingly) minus a warning
23:54:10 <Darius> Ouch.  I really need to recompile GHC6
23:55:35 <shapr> Pseudonym: I've been trying to understand monad transformers lately, they're exciting.
23:55:41 <Pseudonym> They are, yes.
23:56:07 <Pseudonym> They're also bloody hard to write if you want to do anything nontrivial.
23:56:44 * Darius needs to rewrite the Cont(T) monad and play with his shift/reset code again.
