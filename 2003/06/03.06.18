01:02:01 <d-bug> morning
01:02:23 <Pseudonym> G'day.
01:06:39 <Marvin--> Pseudonym?
01:11:28 <Pseudonym> Yes.
01:11:36 <Pseudonym> Though I'm leaving in a minute.
01:14:17 <Pseudonym> Gotta go.  Bye all.
01:16:06 <Marvin--> damn
01:38:30 <Marvin--> ugh
01:47:39 <kosmikus> ?
01:49:36 <Marvin--> we made a release Monday
01:49:41 <Marvin--> so we went out for release beer yesterday
01:50:10 <Marvin--> the good thing about release beer is that the company pays for it, the bad thing is that that tends to make you drink a lot of it
02:10:39 <kosmikus> hehe -- congratulations anyway ...
02:11:30 <Marvin--> well, I wasn't involved in the release, I was designing new things :)
02:13:29 <kosmikus> doesn't matter, release is release
02:14:58 <Marvin--> yup :)
02:15:26 <Marvin--> it was quite dramatic at times, since someone had managed to screw up a file thanks to bad interaction between CVS and Samba
02:17:44 <Marvin--> interesting, Reiser4 seems to be going in some sort of plan9ish direction of "everything is a file"
02:19:11 <Marvin--> oh dear, files can be both directories and regular files
03:23:07 <Marvin--> hey ac
03:23:15 <andersca> hey
03:29:42 <sjj> hrm, is it possible to use multiple patterns in lambda notation?
03:30:02 <Heffalump> YM have a case expression, effectively?
03:30:21 <Heffalump> as far as I know, you can't
03:30:24 <sjj> yeah.
03:30:36 <Heffalump> \x -> case x of ...
03:30:43 <Heffalump> isn't too much extra crap, though
03:30:59 <sjj> *nod*, just wondering if it was possible.
03:40:20 <shapr> oy
03:41:50 <Heffalump> oy?
03:43:02 <shapr> little sleep + dentist = oy
03:43:07 <Heffalump> ah :(
03:43:30 <shapr> on the good side, I napped in the chair.
03:56:05 * shapr yawns
03:56:10 * andersca boings
03:57:17 * elmex giggles
06:33:47 <d33p> f4 x y = snd x > - last y 
06:34:01 <d33p> does this function make much sense? the > - throws me 
06:35:31 <cale> @yow
06:35:31 <lambdabot> Where's the Coke machine?  Tell me a joke!!
06:35:53 <Igloo> It's snd x > (-last y)
06:36:09 <Igloo> Or snd x > (negate (last y)) if you like
06:36:22 <d33p> oh, - is negation ? 
06:36:24 <d33p> :\
06:36:30 <Igloo> Yes
06:36:39 <d33p> i see
06:36:43 <d33p> thankyou :)
06:36:48 <Igloo> Otherwise things like -4 wouldn't work  :-)
06:36:58 <d33p> (-4) i thought
06:37:11 <Igloo> Depends on the context
06:37:19 <d33p> thats the first time i'd seen - used that way
06:37:22 <d33p> ah
06:37:55 <Igloo> You can't say   id -4   because that gets parsed with - being subtraction
06:38:10 <d33p> Igloo: yep
06:38:26 <d33p> its a bit confusing
06:38:30 <Igloo> But where that can't happen -4 is fine
06:38:53 <d33p> many thanks igloo
06:40:06 <Marvin--> er... what's an N-way merge?
06:40:54 <Igloo> I imagine n-way-merge = foldr merge []  where merge merges 2 sorted lists to produce a sorted list
06:43:27 <Marvin--> hmm
06:44:16 <ludde> foldr1 merge :)
06:44:44 <Igloo> You think n-way-merge [] should be an error rather than [] then?
06:44:51 <ludde> hmm
06:44:56 <ludde> whatever
06:45:00 <Igloo> :-)
06:45:03 <ludde> heh
06:45:33 <ludde> it's probably more efficient to split it in two equal pieces though..
06:45:34 <Igloo> In actual fact I suspect you'd want to do pairwise merging recursively for efficiency
06:45:35 <Marvin--> it's this book on text indexing and querying that makes a difference between "sort-based inversion" and "sort-based multiway merge inversion"
06:45:37 <SyntaxPolice> good morning
06:46:05 <ludde> Igloo: yeah that's what i meant
06:46:33 <Igloo> I'd typed it before I read what you wrote  :-)
06:46:50 <Igloo> Marvin: What exactly do you mean by inversion here?
06:47:22 <Marvin--> Igloo: constructing the word index
06:48:04 <steveh> n-way merge is a merge of n lists
06:48:09 <Marvin--> sort-based inversion is based on working against an on-the-fly compressed temporary file
06:48:40 <steveh> if you sort using n-way merge you reduce the number of times a given element is accessed/compared
06:48:56 <Marvin--> and according to the numbers in the book, doing multiway merging cuts the running time by half
06:49:46 <steveh> if you reduce the number of times a given element is accessed, and access times are a big time drain, well, it'd be a good thing
06:50:18 <steveh> foldr merge would be different than n-way merge afaict
06:51:18 <Igloo> Do you mean it does something different or just that it is less efficient?
06:51:20 <steveh> mmm netsplit
06:51:28 <steveh> it does something different
06:51:50 <Igloo> Oh, OK. I'm confused then
06:51:55 <steveh> it will do a binary merge of two lists, then binary merge it with another, then binary merge it with another 
06:51:56 <Marvin--> Igloo: the sorting is different, so it takes less time, but I'm having a hard time understanding the text
06:52:08 <steveh> n-way merge merges n lists all at once
06:52:53 <Igloo> steveh: Is it true that forall inputs xs   n-way-merge xs == foldr merge [] xs?
06:53:01 <Marvin--> ah, so you'd put the first element of each list in a priority queue and stuff?
06:53:31 <steveh> Igloo: yes, but the implementation is different.
06:54:01 <Igloo> Hmm, I guess by that argument mergesort == quicksort, though
06:54:30 <Igloo> So giving specifications like that doesn't really work if you're talking about named algorithms, although I didn't realise it actually was a named algorithm initially
06:54:43 <steveh> http://www.nist.gov/dads/HTML/kwaymergsort.html has some info
06:55:14 <steveh> it's better than 2-way because it requires fewer repeated accesses of the same element
06:55:25 <steveh> if you're reading the things from disk that's a bad thing
06:55:33 <steveh> er
06:55:40 <steveh> having more accesses is a bad thing
06:55:41 <steveh> :)
06:56:04 <Marvin--> yeah
06:56:19 <Igloo> Hmm, even with seeking?
06:56:36 <steveh> disk access is measured in ms
06:56:43 <steveh> memory access is measured in ns
06:56:48 <Marvin--> so, I guess the idea is to take the temporary files of N records, split it in k blocks that fit in memory, sort the blocks one by one, and then merge the blocks by using a priority queue?
06:57:03 <Igloo> But seeking is a lot slower than reading
06:57:17 <Igloo> Although you'll have to be seeking between two files anyway
07:13:38 <steveh> Marvin--: that's the idea
07:18:44 <jlouis> My bet would be: as much data as possible into the memory, use sorting with good locality of reference, write data to file, n-way-merge the files or something like that
07:18:53 <jlouis> probably repeated 2-way merging
07:19:13 <steveh> no, n-way merge the files
07:19:15 <jlouis> or some divide-and-conquer like merging
07:19:25 <steveh> repeated 2-way merging will give you many accesses
07:19:32 <jlouis> steveh: yes, that is bad
07:19:48 <jlouis> n-way merging is best I think
07:20:11 <steveh> there is another variation called polyphase merge sort but I am not too familiar with it
07:20:34 <jlouis> but the assumption is that you cannot have the stuff inside memory. Else it is simple
07:20:46 <jlouis> steveh: ah, Knuth should be a good source for that
07:21:13 <steveh> i wish i had a copy of knuth to confirm!
07:21:23 <Marvin--> I only have volumes one and two, and they're at home :-/
07:21:42 <Rafterman> i have all three sitting next to me here but I'm not sure what the question is :)
07:21:53 <Igloo> lol
07:22:09 * Rafterman flips the the index of vol 3
07:23:00 <Marvin--> vol 3 is what'd be needed I guess
07:23:13 <jlouis> Marvin--: correct
07:23:16 * Marvin-- goes to look in the boss's office
07:23:31 <jlouis> around the fold-out page with merging times I guess
07:24:55 <Rafterman> *5.4.2 The Polyphase Merge
07:25:16 <steveh> heh
07:25:19 <Marvin--> yep, he had it ;)
07:25:22 <steveh> I gotta get me a copy of that book
07:25:22 <steveh> :)
07:26:06 <Rafterman> I'll let Marvin-- explain it, I'm gonna go to bed :)
07:26:22 <Marvin--> dang
07:29:21 <Marvin--> "Let us consider first the process of external sorting when magnetic tapes are used for auxiliary storage."
07:29:24 <Marvin--> damn these books are old ;)
07:30:11 <steveh> heheh
07:31:01 <steveh> true, n-way merge isn't so necessary now that you have 60gig HDs for cheap
07:31:27 <Marvin--> well, that depends on how much text you're indexing :)
07:31:43 <steveh> hehe
07:32:00 <Marvin--> our application/framework should easily be usable with text sizes of 100GB
07:32:16 <steveh> a cluster of slave machines, each being a "Tape" for a master  sorting machine? :)
07:32:37 <Marvin--> but then, we're operating under the mantra that "disks are cheap"
07:33:12 <steveh> are you still bound by a file size limitation?
07:34:08 <Marvin--> I have no idea what'll happen, I haven't calculated much on it yet :/
07:35:05 <steveh> well e.g. ext2 has 2gb max filesize IIRC
07:35:07 <Marvin--> but the 100GB I'm guessing on, is all text in the system, but we won't put all text in one index anyway, so hopefully we're safe<tm>
07:35:30 <vegai> steveh: can't have
07:35:45 <Marvin--> surely there's LFS support for ext2?
07:35:59 <vegai> gotta look that up, though
07:36:08 <steveh> my memory of linux is hazy and 3 years old
07:36:32 <vegai> what system are you on?
07:36:35 <steveh> but make sure you don't exceed max file size for the brokenest OS you expect to host your application :)
07:36:45 <steveh> i have a freebsd machine and a mac
07:36:53 <steveh> and I use XP regularly as well
07:37:00 <vegai> UFS doesn't have filesize limit anymore?
07:37:02 <vegai> hmm
07:37:18 <Marvin--> this will be server-side, and I think we're way unix-bound for the server already
07:37:19 <steveh> it does as far as I know
07:37:31 <Marvin--> the server support right now is for linux and solaris
07:39:21 <vegai> 32-bit limits the filesize as well
07:39:26 <steveh> aah nm, FFS in FreeBSD can go up to 8 or so terabytes I think
07:39:42 <Marvin--> "Operator changing tapes" heh
07:39:48 <Marvin--> gotta love it when that's part of an algorithm
07:39:50 <jlouis> steveh: UFS2 is insane
07:39:51 <vegai> steveh: fs size or file size?
07:39:53 <steveh> I'm sure there has been an extension to EXT2 to fix filesize issues
07:40:04 <jlouis> 64 bit or something
07:40:09 <vegai> reiserfs has 1EB max filesize
07:40:19 <vegai> JFS 4PB
07:40:31 <jlouis> UFS is 20 years old and stable
07:40:41 <vegai> indeed
07:41:04 <steveh> vegai: I have "The maximum size of a single ffs file is approximately 1G blocks (4TB) if the block size is 4K. " and that's pretty old information
07:41:20 <vegai> aye, with older ones that's true
07:41:36 <vegai> "ReiserFS 3.6 has a max filesize of 2^60 bytes"
07:41:53 <opet> steveh: that sort of stuff appears on the hackers@ list a couple of times a year.. I'm sure you'll find lots of conflicting answers :)
07:42:08 <steveh> so unless you're on old unices this shouldn't be a problem Marvin-- :)
07:42:40 <vegai> this might be a good source: http://www.suse.de/~aj/linux_lfs.html
07:44:08 <Marvin--> hmm, wonder how I check the block size
07:44:41 <vegai> my earlier JFS source was bad
07:46:33 <Marvin--> eep, coroutines
07:47:31 <Marvin--> I wonder about the efficiency of implementing the indexing in C, C++ and Haskell
07:47:46 <Marvin--> (or Python + C or Python + C++)
07:48:29 <steveh> only profiling can really tell you what's up there
07:48:48 <Marvin--> yeah
07:49:21 <steveh> my philosophy is to implement in your language of choice, profile, and reimplement specific routines in C or whatever is more efficient.
07:50:14 <Marvin--> mine too
07:51:04 <steveh> i am so far behind in mailing lists...
07:51:29 <steveh> actually maybe only 5 days but that's about 100 digests :-P
09:21:49 * shapr bounces happily
09:21:54 <shapr> goood morning #haskell!
09:22:06 <Heffalump> BOO!
09:22:11 * shapr yikes
09:22:18 <tic> man
09:22:20 <tic> i'm soo tired
09:22:31 <shapr> me too.
09:22:38 <shapr> I just returned to semi-consciousness from a nap.
09:22:41 <shapr> naps help.
09:23:15 <tic> mhm
09:23:18 <tic> i'm thinking of one
09:23:25 <tic> i'm going to fall asleep soon anyway
09:23:35 <tic> so it might be best if I do it on the couch
09:23:57 <shapr> instead of on your keyboard
09:24:10 <shapr> keyprints in the forehead look strange in public
09:25:35 <tic> yeah
09:25:38 <tic> plus I damage the computer
09:25:42 <tic> (laptop)
09:25:46 <shapr> oh, good point.
09:26:19 <tic> yup
09:26:49 <SyntaxPolice> shapr!!
09:27:02 <shapr> SyntaxPolice!!
09:27:09 <shapr> how are ya?
09:27:13 <kosmikus|away> so as soon as I'm away everyone awakes? ;)
09:27:15 * SyntaxPolice bounces around so shapr can't catch him
09:27:23 <SyntaxPolice> shapr: did you hear something?
09:27:28 * shapr springs after SyntaxPolice, crashing furniture.
09:27:30 * esap blinks furiously.
09:27:31 <SyntaxPolice> ;)
09:27:43 <shapr> SyntaxPolice: yes, it was the sound of kosmikus going to sleep.
09:27:49 <shapr> now we can party!
09:27:56 <shapr> whoops, he's awake again!
09:28:06 * SyntaxPolice stops partying
09:28:17 * shapr stops crashing furniture.
09:28:24 * shapr pretends to be a calm person.
09:28:35 * shapr explodes from inactivity.
09:29:08 <shapr> actually, there must be a place on of the wiki pages for haskell sourceforge projects
09:29:37 <SyntaxPolice> there is LibrariesAndTools, which is starting to get crowded thanks to Awesome Alastair
09:29:44 <shapr> yes, it's good.
09:29:51 <shapr> you think it needs to split?
09:30:18 * Heffalump wonders how hard setting up anonymous CVS securely is
09:31:02 <shapr> I like Binkeley's description of her first experience with the HM t-shirt.
09:31:23 <SyntaxPolice> shapr: idono, probably not yet. we could just add a TOC to the top
09:31:57 <SyntaxPolice> did binkeley buy a shirt?
09:34:32 <shapr> yes, she did.
09:34:47 <Heffalump> what'd she say about it?
09:35:06 <shapr> 'when I was walking down Ridge with wintersweet and her Clint on our way to Brewed Awakenings, one of the scruffy-looking guys who usually hangs out on Euclid and Ridge in front of the Seven Palms asked me, "hey, what's that on your shirt?"'
09:35:17 <shapr> So I started explaining that it was the Hindley-Milner type inference algorithm for the polymorphically typed lambda calculus, but it turned out he just wanted to know what the letters on the front were. So I said, "Lambda, tau." And he said, "that's right."
09:35:23 <shapr> And later when I walked by there again on my way to get food, he yelled out, "LAMBDA TAU!"
09:35:28 * shapr snickers hysterically
09:35:55 <shapr> Berkeley, where even the street bums know type theory. Or know enough Greek letters to do it, anyway
09:35:55 <hdaume> morning all
09:35:56 <shapr> hi hal!
09:36:22 * shapr was slow today.
09:36:27 * SyntaxPolice looks over at hdaume
09:36:39 <hdaume> SyntaxPolice: stop looking at me like that
09:36:59 * shapr looks over kosmikus
09:37:08 <shapr> actually, I'm not very tall, that might not work.
09:37:21 <Heffalump> kosmikus is quite tall
09:37:37 <Smerdyakov> I'm not very tall, either!!
09:37:38 <Heffalump> assuming he's the person I think he is, anyway
09:37:40 <shapr> I'm 176 I think.
09:37:46 <shapr> Andes Loeh, yes?
09:37:47 <shapr> er
09:37:51 <Heffalump> yeah.
09:37:52 <shapr> I missed some letters.
09:38:02 <shapr> Andres Löeh?
09:38:14 <Heffalump> I don't think you need both the umlaut and the 'e', BICBW.
09:38:18 <shapr> oh
09:38:27 * shapr checks kosmikus' web page
09:38:33 <kosmikus|away> 194
09:38:40 <shapr> whoa
09:38:42 <SyntaxPolice> hdaume: so the problem I have w/ the ghc6 sparc thing now is that it seems to want to create a directory loop and then gives up when it gets too big. this is different from the hard-coded path problem I had with the first version...
09:38:45 <Heffalump> people tend to use the 'e' when they can't get the umlaut it
09:38:47 <shapr> kosmikus|away: you are *so* much taller than me.
09:38:58 * shapr gets a stool
09:39:02 * shapr looks over kosmikus
09:39:04 * kosmikus|away now *really* is away
09:39:15 <hdaume> SyntaxPolice: yikes
09:39:35 * shapr notes hdaume's exciting new hostname.
09:39:46 <hdaume> SyntaxPolice: i'll try to look into it in a few days...i'm pretty busy right now
09:39:55 <shapr> have you seen the Pike Place Pig? :-)
09:40:06 <hdaume> shapr: yeah, i'm up here in redmond now, and no, i haven't seen the pig thing yet :)
09:40:12 <SyntaxPolice> hdaume: maybe its because I am building it in a directory that is a symlink
09:40:23 <SyntaxPolice> ./configure --prefix=~/lair/ijones/usr
09:40:28 <SyntaxPolice> make install
09:40:30 <SyntaxPolice> and eventually...
09:40:39 <shapr> hi noss
09:40:44 <SyntaxPolice> mkdir: Failed to make directory "~/lair/ijones/usr/share/ghc-6.0/~/lair/ijones/usr/share/ghc-6.0/~/lair/ijones/usr/share/ghc-6.0/~/lair/ijones/usr/share/ghc-6.0/~/lair/ijones/usr/share/ghc-6.0/~/lair/ijones/usr/share/ghc-6.0/~/lair/ijones/usr/share/ghc-6.0/~/lair/ijones/usr/share/ghc-6.0/~/lair/ijones/usr/share/ghc-6.0/~/lair/ijones/usr/share/ghc-6.0/~/lair/ijones/usr/share/ghc-6.0/~/lair/ijones/usr/share/ghc-6.0/~/lair/ijones/usr/share/ghc-6.0
09:40:45 <SyntaxPolice> /~/lair/ijones/usr/share/ghc-6.0/~/lair/ijones/usr/share/ghc-6.0/~/lair/ijones/usr/share/ghc-6.0/
09:40:46 <SyntaxPolice> (etc.etc)
09:40:47 <shapr> hur är det med dig?
09:40:56 <SyntaxPolice> are"; File name too long
09:40:56 <noss> hello, im not writing in haskell, but i have a q related to fp.
09:41:07 * Heffalump wonders what hdaume is doing in Redmond
09:41:10 <noss> shapr: bra antar jag.
09:41:10 <shapr> SyntaxPolice: maybe it's not expanding ~ ? does it change when you make it literal?
09:41:20 <SyntaxPolice> I'll try :)
09:41:22 <shapr> noss: kan vi hjälpa dig?
09:41:31 <hdaume> SyntaxPolice: could be the "~"...did you try using "/home/" or whtaever?
09:41:39 <noss> anyways, given a list of numbers, how do i return a list consisting of all those long numbers.
09:41:40 <hdaume> ah, shapr beat me to that :)
09:41:48 <shapr> hdaume: must be jetlag ;-)
09:41:56 <Heffalump> "all those long numbers"?
09:42:17 <noss> or rather, given a list of {N,Item}, how do i return the {N,Item} for those N that are longest
09:42:35 <Heffalump> I still don't understand your problem.
09:42:36 <noss> so you have a reason to return the exact object of every item.
09:42:48 <SyntaxPolice> so you get a list of numbers, and a number n, and you want to return the n longest numbers?
09:43:03 <noss> okay, given a list of objects that you have a function f you can apply on to get a number.
09:43:14 <noss> how do you get those objects that returned the highest number.
09:43:33 <esap> noss: how about sorting based on the number?
09:43:49 <noss> say it is a list of strings and the function is length.
09:44:00 <Igloo> maximum $ map f xs  will give the highest, then filter ((== the_max) . f) xs
09:44:01 <Heffalump> oh, that's what hdaume is doing in Redmond :-)
09:44:33 <Marvin--> say what?
09:45:25 <noss> Igloo: i dont see how that works.
09:47:23 <noss> a good example is ["foo", "hello", "tjena"] and the function length, i would like to have the longest strings in this case. i.e. ["hello", "tjena"]
09:47:55 <SyntaxPolice> what language are you using noss?
09:48:20 <noss> erlang.
09:48:40 * Marvin-- tries to get into erlang mode
09:48:45 <Igloo> Which bit don't you understand?
09:48:52 <Igloo> It's Haskell code
09:49:14 <Marvin--> I have no idea what kind of functions are available builtin in erlang, been way too long
09:49:34 <noss> what does maximum do?
09:49:53 <Marvin--> noss: finds the largest number in a list
09:49:59 <hdaume> stupid flakey network connection :(
09:50:18 <Igloo> Gives you the maximum value of a list
09:50:25 <Marvin--> what's this I hear about Redmond?
09:50:30 <noss> aha, well that would work.
09:52:20 <SyntaxPolice> noss: how do you like erlang? have you used other functional languages?
09:52:38 <hdaume> Marvin--: i'm up in the machine learning & applied statistics group for the summer in ms redmond
09:52:51 <Marvin--> hdaume: cool
09:54:50 <noss> N = lists:max([Fun(El) || El <- List]), list:filter(fun(El) -> case Fun(El) of N -> true; Else -> false end end, List). something like that.
09:55:48 <noss> SyntaxPolice: i used haskell to learn fp, studied some lisp and erlang and found erlang to be the most practical of them.
09:57:55 <SyntaxPolice> I see. how is it more practical, out of curiosity?
09:59:55 * shapr reboings
10:00:39 <noss> SyntaxPolice: well, csp is useful. i know there is something called O'haskell, but erlang is more alive and there is some excellent code written for it.
10:01:07 <shapr> erlang has runtime upgrading of software, really gorgeous network transparency. It doesn't have referential transparency though.
10:02:14 <noss> another thing that made me chose erlang is that i like the syntax better. :)
10:03:11 <shapr> imho, Haskell has a more academic community, and I prefer that.
10:03:18 <shapr> on the other hand, erlang has Luke Gorrie.
10:03:41 <Marvin--> who's he?
10:03:46 <shapr> He's a cool guy.
10:04:00 <Marvin--> so's SPJ :P
10:04:06 * SyntaxPolice notes lots of cool guys in the Haskell community :)
10:04:06 <shapr> that's true.
10:04:16 <shapr> Luke Gorrie --> http://www.bluetail.com/~luke/
10:04:20 <shapr> all in all, I prefer Haskell.
10:04:32 <noss> i think i had some problem accepting io monads. basically haskell was a bit too functional for me.
10:05:08 <vegai> looked at ocaml?
10:05:58 <shapr> noss? or me?
10:06:19 <noss> yah, only a little. its a langauge i consider learning at some point in time.
10:07:09 <noss> does ocaml have something that makes it different among fp langauges?
10:07:33 <shapr> I wish several of the Erlang features were in Haskell.
10:07:41 <shapr> o3's RuntimeLoader is the first step in that direction.
10:08:07 <shapr> The "dream of a database" post talks about serializing stuff, that's another step along those lines.
10:08:47 <shapr> step 3: world dominatio
10:08:49 <shapr> n
10:09:47 <shapr> step 4: ??? step 5: PROFIT
10:18:06 <vegai> noss: the implementation is quite excellent in terms of memory and cpu efficiency
10:18:28 <vegai> the language as such is not necessarily as elegant as some others imho
10:19:13 <noss> that's not something i currently need, and when i need it i mostly need it so bad that i need better down to assembly optimizations.
10:19:53 <noss> blah. primary selection was the problem i just mentioned, secondary selection is worse.
10:20:16 <vegai> hm?
10:22:35 <noss> im writing an implementation of X resource files for configuration, i have narrowed down what resources are applicable to a widget's setting. now i just need to find which is the best match.
10:23:40 <noss> a longer one is a better match than shorter ones, and after that i need to select the one that has most specific matching, i.e. foo.?.bar is less specific that foo.baz.bar
10:28:19 * shapr boings happily
10:35:54 <noss> i really should not have taken on writing this, else i could have been implementing some interesting widgets without configuration ability. sigh.
10:37:21 * vegai bonks shapr for stealing his boingy routine.
10:37:31 <shapr> ?
10:37:59 <vegai> I used to boing happily!
10:38:03 <vegai> now I just bonk.
10:38:09 * shapr bonks vegai 
11:14:28 * shapr boings
11:47:07 * esap just wrote a comment to http://haskell.org/hawiki/CoMonad. Please comment.
11:49:38 <cale> Yes, there was confusion over that.
11:50:03 <esap> what was the conclusion? Is the intention that the type of .>> is w a -> b -> w b?
11:50:52 <cale> I don't know, but based on the characterisation in terms of seq it certainly wouldn't have that type.
11:51:20 <esap> right. My interpretation is that the type is correct but the characterization is inaccurate.
11:53:43 <cale> It could be either way. .>> is apparently supposed to propagate demand for evaluation to whatever is on its left.
11:53:59 <shapr> also, HXmlToolbox is using .>> for filter composition
11:54:15 <shapr> I want to import all the Haskell sources I can find at the same time and see what collides :-)
11:54:41 <esap> cale: I think you could interpret the paper as trying to say that the type of 'seq' in Haskell has the wrong type.
11:54:51 <shapr> my first style comment in Haskell programs would be "don't use Util.hs, everyone else already does" 
11:59:08 <cale> I didn't find any instance of the operator actually used in the paper, and it doesn't appear fundamental, so I couldn't judge what exactly the intention was. Does anyone know of any other instances of comonadic programming?
12:00:00 <esap> I've been trying comonads a bit, and it does seem quite hard to use. But I didn't have the .>> operation.
12:00:38 <Riastradh> How does the OI comonad work?
12:00:49 <shapr> first it explorbs your head.
12:00:53 <esap> well I haven't done that :-(
12:01:43 <esap> Well my current understanding is that both monads and comonads can be generalized to something that expresses layering.
12:01:59 <cale> The OI comonad should work the same way that the IO monad does, only in reverse :) (not entirely joking)
12:02:13 <esap> cale: yes, that is how I understood as well.
12:02:27 <Riastradh> Does the program run backwards?
12:02:42 <cale> No, all the types are reversed though.
12:02:46 <Riastradh> Will a 'hello world' program print out:  '!dlroW ,olleH' ?
12:03:15 <steveh> it's times like these I wish I had more Haskell-fu than a green belt.
12:03:23 <cale> hPutChar' :: OI Handle -> OI Char -> ()
12:03:28 <cale> for example
12:03:39 <hdaume> wouldn't it just be OI Handle -> Char -> () ?
12:03:43 <Riastradh> How would you get an OI Handle or an OI Char in the first place?
12:03:54 <shapr> I have the same question.
12:04:12 <cale> by lifting them with =>>
12:04:15 <hdaume> how asbout "openFile' :: OI String -> IO (OI Handle)"?  :)
12:04:21 <cale> =>>)  :: w a -> (w a -> b) -> w b
12:04:25 <hdaume> (joking, obviously :P)
12:04:47 <esap> How I like to think about it is that you would have three "layers" in the system, "OI", "values" and "IO". If you look at just values and IO, you get the current Haskell system. If you look at OI + values, you get the comonad stuff. And then you can use "OI a -> IO b" and get another scheme.
12:05:00 <shapr> =>>)  looks like ascii art for a flamethrower
12:05:16 <cale> heh. I missed the (
12:05:46 <cale> The only trouble is getting a value of type  a to begin with.
12:05:49 <cale> w a
12:06:07 <esap> But what you should be writing is   w a -> m b, where both 'w' and 'm' can be chosen as any layers you wish.
12:06:59 <Riastradh> How do you get w a?
12:07:24 <cale> Riastradh: the top-level execution has to hand it to you on a silver platter
12:07:42 <Riastradh> Do I have to ask in French, or are they not that high-class?
12:07:54 <esap> cale, riastradh: right, just like the IO () of main.
12:08:58 <cale> esap: I was thinking about having such a  (w a -> m b) execution model the other day. It seems like the most natural thing.
12:09:25 <Marvin--> niam = w a -> ()  or what was it?
12:09:26 <cale> That way your program draws from context and produces actions.
12:09:49 <Marvin--> or rather, OI a -> () (or OI () -> ()?)
12:10:13 <esap> cale: yes. have you seen http://www.kotiposti.net/epulkkin/Functionality.lhs ?
12:10:30 <Riastradh> Yikes.
12:10:35 <Riastradh> My browser renders it all on one line.
12:10:50 <esap> riastradh: view the source.
12:11:27 * Riastradh has looked at that file a lot and never figured anything out about it.
12:11:44 <shapr> I figured out some stuff. but then I lost too many SAN points and had to reboot.
12:12:47 <cale> Oh, that's cool.
12:14:10 <Marvin--> talk about misconfigured web server
12:14:56 <Marvin--> (>>>>)  okay... this is getting silly
12:15:00 <Marvin--> next we'll have (>>>>>)
12:15:25 <esap> heh
12:15:26 <shapr> no, just >n
12:15:30 <Riastradh> >>>>>>>>>>>>!
12:15:39 <shapr> >>> = >n 3
12:15:43 <Riastradh> >>>>>>>>>>>>>>>>>>>>> is for the arrows that were generalized to nuclear warheads.
12:15:50 <shapr> yes, those.
12:16:01 <shapr> oh, I have a very silly idea...
12:16:04 <Riastradh> >>>>> is just for spears.
12:16:04 <shapr> very silly.
12:16:23 <shapr> what characters can be used for operators in Haskell?
12:16:25 <cale> (>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>) :: HyperSuperMetaFunctor a b c d e f g h -> HyperSuperMetaFunctor b c d e f g h i -> HyperSuperMetaFunctor a b c d f g h i
12:17:50 <cale> "They've gone plaid."
12:18:02 * esap has a newer version of that file, but I would say it's even harder to understand than that one :-(
12:18:21 <cale> Perhaps we need unicode operators.
12:18:29 <mattam> maybe haskell programmers should look more at WEB style of programming
12:18:51 <cale> I think it would be great to have things like \oplus
12:19:17 * esap just uploaded an update for that.
12:21:32 * Heffalump doesn't understand how comonads preserve referential transparency.
12:22:21 <shapr> too silly --> http://kungens.kemi.fi/~shae/src/haskell/Rocket.hs
12:22:42 <cale> It's important to understand that when w is a comonad, applying a function of type w a -> b is safe.
12:24:02 <cale> shapr: You should use that operator extensively in an IOHCC entry.
12:24:08 * shapr grins
12:24:17 <Heffalump> getChar :: OI Handle -> Char, yes?
12:24:19 <Riastradh> shapr, does it work?
12:24:29 <shapr> Riastradh: I don't think operators can have embedded whitespace :-)
12:24:34 <SyntaxPolice> cale: "...plaid." lol
12:24:35 <Riastradh> Darn.
12:24:38 <shapr> though admittedly, I didn't actually try.
12:24:59 <shapr> if you could embed \n in an operator, weird things could be done.
12:25:17 <cale> Heffalump: sure
12:25:35 <esap> What this "OI Handle" stuff actually requires is that the compiler implements a framework in which these things can work. Just like monads require that the compiler implements the low layers.
12:26:05 <shapr> bah, I have to go work again...
12:26:08 <Heffalump> so what does (getChar h,getChar h) produce?
12:27:54 <Heffalump> I'm also extremely suspicious of any framework that has to have an operator to circumvent lazy evaluation
12:28:29 <Riastradh> http://www.bloodandcoffee.net/campbell/images/Functionality.lhs.tiff
12:29:34 <esap> riastradh: yes, I actually get the same thing. I can't help it though, it's not my web server to configure :-(
12:30:08 <esap> in Galeon, it helps to use the 'view-source' feature.
12:30:49 <cale> Heffalump: evaluation of objects of type w a is unsafe.
12:31:24 <Heffalump> wdym "evaluation"?
12:32:18 <cale> constructing a value of type w a causes a side effect, and hence is unsafe
12:33:07 <Heffalump> right, but I'm not doing that, I'm just duplicating one
12:33:21 <esap> heffalump: duplicating does construct a copy.
12:33:54 <Heffalump> well, not necessarily, in most implementations it just duplicates a pointer, but that's not really the point
12:34:15 <Heffalump> duplication of values is a fundamental part of Haskell, and you appear to be saying that it's unsafe
12:34:56 <esap> Well you can't duplicate IO a either.
12:35:01 <Heffalump> yes, I can
12:35:18 <Heffalump> it's perfectly safe to duplicate it, because nothing will actually happen unless it gets run
12:35:33 <Heffalump> and the only safe way to run it is to propagate it back to main
12:35:33 <esap> oh sorry. I meant, you can't *destroy* IO a either.
12:35:55 <Heffalump> I can, I can just throw it away...
12:36:06 <demoncrat> esap - sounds like you're talking about uniqueness types instead
12:37:08 <esap> demoncrat: hmm.. basically, yes. ok maybe it's not exactly the same thing, it's just one way of thinking about the monadic values.
12:37:52 <esap> the idea is that once you _use_ an IO value, you cannot get rid of the IO monad.
12:38:12 <esap> and the same idea has to be expressed for the comonadic case as well.
12:38:50 <esap> otherwise the sequentiality can be broken.
12:39:20 <cale> After all, they're category-theoretic duals of one another, so every theorem about monads says something about comonads as well.
12:39:28 <esap> Of course, the idea that needs to be expresesd for the comonad case is _parallelism_ and not sequentiality.
12:41:13 <Heffalump> but you can control sequentiality in Haskell by forcing one thing to demand the output of another thing
12:41:17 <Heffalump> how do you control parallelism?
12:42:09 <esap> I think comonad is it :-) I think it should be like this: The comonad represents a 'context' that you can pass to each "parallel thread", which each can read from it (but cannot write).
12:43:58 <esap> so read operations should be expressed as a comonad, so it allows concurrent reads from multiple thresds.
12:44:07 <Heffalump> main oi = let x = stdGetChar oi in stdPutChar oi x    
12:44:13 <Heffalump> is that legal?
12:45:28 <esap> It depends on the types. if stdPutChar should have type Char -> IO () as always. stdGetChar should have type OI Char -> Char.
12:45:29 <Heffalump> and how do I write:
12:45:30 <Heffalump> stdPutTwoChars (x,y) :: OI (Char,Char) -> ()
12:45:53 <Heffalump> I'm following the types in Kieburtz's paper.
12:46:00 <esap> OI () I mean for stdGetChar.
12:46:10 <Heffalump> oh, hangon.
12:46:13 <Heffalump> right, it's not legal.
12:46:16 * Heffalump --> fix it
12:46:39 <esap> ok, I was using a different conceptual model than Kieburtz.
12:48:18 <esap> What I would do would not allow you to read using IO monad and would not allow writing using the OI comonad.
12:48:19 <Heffalump> ahah
12:48:26 * Heffalump starts understanding what's going on.
12:49:05 <Heffalump> talking about parallelism is a red herring, it's just as much a sequentiality issue
12:49:07 <cale> then you'd just have the O monad and the I comonad. :)
12:49:21 <esap> cale: oh right.
12:49:26 <cale> :)
12:50:04 <Heffalump> the types of the comonad class restrict where "pure" values can come from
12:50:20 <Heffalump> (if they are to influence the input/output behaviour of the program)
12:50:36 <Heffalump> oh, hmm.
12:52:23 <esap> the idea is that (>>=) should really have the type  (>>=) :: (Monad m, Comonad w) => m a -> (w a -> m b) -> m b
12:54:16 <cale> esap - perhaps you might want to add some text to the wiki regarding this. I like the idea.
12:54:37 <esap> sure. that's a good idea.
12:54:45 <Heffalump> I don't, it makes no sense to me :-)
12:55:01 <Heffalump> what type would main have in your view of the world?
12:56:16 <cale> It would be w () -> m (), if I'm understanding correctly
12:56:53 <Heffalump> what's the point, though?
12:57:02 <esap> cale: or it could be w a -> m (). It's not clear you should be able to invoke eval successfully for that.
12:57:43 <Heffalump> ok, so given either of those types, write a program that writes a single character to stdout.
12:59:18 <esap> heffalump: main ctx = hPutChar (eval $ stdout ctx) 'c'
12:59:49 <Heffalump> what are the types of each of those things?
13:01:22 <esap> heffalump: hPutChar :: Handle -> Char -> O (), eval :: (Comonad w) => w a -> a. stdout :: w a -> w Handle. main :: I a -> O ().
13:03:47 <esap> heffalump: although I'm not sure if stdout should actually be I a -> I Handle.
13:04:05 <Heffalump> I suspect not.
13:06:14 <esap> then you could have 'fork :: (Comonad w) => w a -> (w a, w a)', which would be pretty powerful operation.
13:07:04 <Heffalump> fork x = (x,x)
13:07:14 <esap> right :-)
13:07:50 <esap> It all comes down to how to intepret values of comonads.
13:08:39 <esap> If the run-time system interprets those as 'handles to contexts', then forking is simply duplicating the context.
13:09:34 <Heffalump> you can fork it fine, the thing is you can't do anything with it once you fork it
13:10:02 <Heffalump> or rather, whatever you do with it can never be involved in any input/output
13:11:07 <demoncrat> cool - an event horizon
13:11:08 <esap> you need some operation in output side as well, to join two threads. That operation will be something like  join_threads :: I a -> I b -> IO (a,I b)
13:11:27 <Heffalump> my problem above is a non-issue, because while I can call coGetChar h until I'm blue in the face, I can't write any program that demands the value of more than one of them without using >>=
13:11:31 <Heffalump> IM =>>
13:11:51 <Heffalump> so what's the benefit of combining monads and comonads?
13:13:13 <esap> You mean the new type for the bind operation?
13:14:44 <Heffalump> sorry?
13:15:17 <esap> I mean the one I proposed: (>>=) :: (Monad m, Comonad w) => m a -> (w a -> m b) -> m b
13:15:54 <Heffalump> well, what's the benefit in general
13:16:11 <Heffalump> oh, and how would you implement that?
13:17:11 <esap> The benefit is that you get a good model of concurrency and layering-type constructs. I don't have an implementation in mind [not that far in thinking yet].
13:17:34 <Heffalump> layering-type constructs?
13:18:35 <esap> well you can consider each Monad and Comonad as layers, where Comonads are used 'before' you can use the input and monads are used after. This forms a hierarchy of layers.
13:19:11 <Heffalump> I still don't see what this gives you.
13:20:04 <cale> It seems more natural to me somehow, that a comonad be used for input and a monad be used for output.
13:20:07 <esap> well the application I've tried to do is OO. I'm aiming to build OO concepts to the language with this kind of mechanism.
13:21:43 <esap> OO is very closely related to layering. That is why I talk about layering.
13:23:43 <esap> What this would do is it would provide formal foundation to OO concepts such that you could use it for expressing OO design (objects, subtyping, inheritance, etc.) using monadic and comonadic types.
13:24:33 <esap> But of course, most of it is not yet fully developed, I have to think about it a bit more to get it fully working.
13:25:39 <Heffalump> but you need to be careful that input and output are interleaved correctly
13:26:40 <esap> heffalump: Of course. There is a lot of details to be worked out.
13:38:47 <Heffalump> grr
13:39:00 <Heffalump> could someone tell me how to write putTwoChars :: OI (Char,Char) -> () ?
13:39:12 * Heffalump is completely stuck
13:42:15 <esap> heffalump: you need to use .>> to be able to evaluate two expressions.
13:43:56 <Heffalump> that doesn't help me understand how to write that
13:44:22 <esap> let me think a sec about that.
13:48:49 <cale> hmm... putTwoChars x = stdPutChar (fst $ coeval x) .>> stdPutChar (snd $ coeval x)
13:49:06 <cale> ?
13:49:55 <Marvin--> this seems pretty complicated
13:50:03 <Heffalump> stdPutChar :: OI Char -> ()
13:50:07 <cale> err, not quite finished.
13:50:07 <Heffalump> so that's not type correct
13:50:15 <cale> yeah
13:50:55 <cale> I suppose you would probably coeval that whole lot.
13:51:47 <cale> so...  putTwoChars x = coeval $ stdPutChar (fst $ coeval x) .>> stdPutChar (snd $ coeval x)
13:52:39 <Heffalump> that's still not type correct, for the same reason
13:53:20 <esap> hmm.. would this work: putTwoChars ctx = ctx .>> stdPutChar (fst $ coeval ctx) .>> stdPutChar (snd $ coeval ctx)
13:54:41 <Marvin--> but if stdPutChar takes an OI Char, how could you pass  fst (coeval ctx) ?
13:54:41 <Heffalump> that's still not type correct, for the same reason :-)
13:55:48 <Marvin--> this is interesting, but a fair bit over my head :)
13:56:11 <Heffalump> it's a fair bit over my head too, I still have no idea what's going on
13:56:14 <cale> Marvin--: yeah, that's what we're having trouble with :)
13:56:42 * Riastradh imagines this would all be understood more easily had he knowledge of category theory.
13:57:15 <esap> riastradh: well it helps, but Haskell already has all the category theory stuff :-)
13:58:11 <Marvin--> don't you sort of have to push the fst/snd into the comonad rather than lifting out the value?
14:02:45 * Heffalump unconvinces himself of his earlier argument that you can't do anything with both values you got from using stdGetChar twice.
14:03:01 <cale> How about putTwoChars x = coeval ((fst $ coeval x) =>> stdPutChar) .>> ((snd $ coeval x) =>> stdPutChar)
14:03:56 <Heffalump> (fst $ coeval x) :: Char
14:04:02 <Heffalump> stdPutChar :: OI Char -> ()
14:04:14 <Heffalump> (=>>) :: OI a -> (OI a -> b) -> OI b
14:04:29 <Marvin--> putTwoChars w = ((w =>> (fst.coeval)) =>> stdPutChar) .>> ((w =>> (snd.coeval)) =>> stdPutChar)
14:04:40 <Marvin--> (that type-checks anyway)
14:04:49 <Heffalump> that's more promising
14:04:59 <Heffalump> ta.
14:05:06 <cale> yeah, that's looking more correct.
14:05:07 <Heffalump> oh, hangon.
14:05:14 <Heffalump> what's the type of .>> ?
14:05:28 <Marvin--> w a -> w b -> w b
14:05:44 <Heffalump> I think that's actually wrong, and it should be w a -> b -> w b
14:05:44 <esap> or should it be w a -> b -> w b?
14:05:53 <cale> yeah
14:05:56 <Heffalump> but it doesn't matter, since coeval :: w b - >b
14:05:58 <Marvin--> well, stick another coeval in there
14:06:17 <cale> the paper was unclear as to which it is.
14:06:29 <Marvin--> putTwoChars w = ((w =>> (fst.coeval)) =>> stdPutChar) .>> coeval ((w =>> (snd.coeval)) =>> stdPutChar)
14:06:29 <Marvin--> eek
14:06:31 <Heffalump> anyway, Pseudonym's program still causes problems, whichever way you look at it
14:06:52 <esap> Pseudonym's program?
14:07:15 <Heffalump> http://haskell.org/pipermail/haskell-cafe/2003-January/003794.html
14:07:48 <Heffalump> the fundamental problem is duplication of w
14:08:01 <Marvin--> hmm
14:10:24 * esap just argued that duplication of w should be the same as forking. So you'd expect it to cause some problems.
14:10:37 <Marvin--> > > So is Kieburtz smoking crack, or are we writing OI-style programs incorrectly?
14:10:37 <Marvin--> > I mailed him the example and asked.  (I phrased the question a bit differently, though.)
14:10:41 <Marvin--> heh, how diplomatic
14:11:00 <cale> heh
14:16:26 <Marvin--> I just don't see how to "factor out" the w here
14:17:34 <Heffalump> the thing is, that we effectively can write unsafeMakeOI :: a -> OI a, simply by distributing the w we get at the beginning everywhere
14:18:20 <Marvin--> well, the threading the token around is what's supposed to be "safe", isn't it?
14:18:24 <Marvin--> otherwise I don't see the point at all
14:18:27 <Heffalump> yeah.
14:18:33 <Heffalump> But there's nothing to enforce threading of it.
14:18:49 <Marvin--> indeed
14:19:08 <Heffalump> fundamentally, IO is safe because if we have two IO values, there's no operation in pure Haskell that can turn them into one IO value - we have to use the IO monad's bind, which sequences them
14:19:26 <Heffalump> but OI seems not to be, because dually we ought not to be able to turn one OI value into two, but we can.
14:20:34 <esap> It's possible to turn one OI value into two, but it has to be intepreted as forking two threads. That is, then you have to ensure that those threads will synchronize when necessary.
14:21:19 <Marvin--> so how the heck do we make sure we coeval w only once?
14:21:41 * Heffalump suggests magic pixie dust
14:22:59 <cale> x .>> y = seq x (coeval y) ? is this what the paper meant?
14:23:27 <esap> I think what should be done is that the coeval function will really be implemented using "lock, eval, unlock" sequence, so that other 'threads' must wait for it.
14:24:47 <esap> actually, you cannot include unlock part in the coeval itself :-)
14:25:17 <Heffalump> errm, look at the State comonad in Kieburtz's paper.
14:25:29 <Heffalump> his implementation isn't even close to type correct, AFAICT
14:25:43 <Marvin--> maybe he IS smoking crack :)
14:26:22 <esap> I think he just reveresed the order of arguments to co-ext compared to what he wrote elsewhere.
14:26:23 * Heffalump is getting closer and closer to that conclusion ;-)
14:26:35 <Heffalump> esap: that bit is documented
14:26:44 <Heffalump> co-ext and =>> have reversed arguments compared to each other
14:26:56 <Heffalump> but co-ext still ought to be able to take two arguments...
14:27:21 <Heffalump> I guess his lambda could be in the wrong place.
14:27:54 <esap> oh right, the open parenthesis should be after the lambda.
14:28:15 <Heffalump> ok:
14:28:26 <Heffalump> (g,s) =>> f = (\s' . f (g,s') , s)
14:28:47 <esap> right, I intepreted it that way.
14:31:10 <Heffalump> ok, in the same way as we can interpret IO as St World, shouldn't we be able to interpret OI as CoSt World ?
14:32:11 <esap> heffalump: well I'd intepret it as CoSt CurrentContext or something like that [but yes, the idea should be the same]
14:32:25 <Heffalump> so you think CurrentContext wouldn't be the same type as World is?
14:32:39 <Heffalump> given just getChar and putChar as primitives, World = ([Char],[Char])
14:32:50 <Heffalump> where the first element is the input stream and the second element the output stream
14:33:18 <esap> hmm.. I'd expect the CurrentContext only contains the input stream and the World only contains the output stream.
14:33:22 <Heffalump> (that intepretation ignores the correct interleaving of input and output effects, but is otherwise correct, isn't it?)
14:33:40 <esap> But yes, basically you could use the same type, if you don't care for interleaving.
14:33:41 <Heffalump> esap: stop confusing me with your mixed monadic/comonadic view of the world ;-)
14:34:10 <esap> ok.
14:34:16 <Marvin--> haha
14:35:11 <Marvin--> given  coeval (g, x) = g x   it feels pretty natural that coeval forks...
14:35:44 <Heffalump> because?
14:37:08 <Marvin--> I sort of thought of it like the 'local' combinator in Reader
14:37:16 <Marvin--> but maybe I'm way out
14:38:24 <esap> I never understood what local actually does :-)
14:39:24 <Marvin--> my understanding of it is that it works like if you explicitly passed state as a parameter
14:40:22 <Marvin--> for example, you could have, in an interpreter   exec env (Block ss) = exec' ([]:env) ss
14:40:31 <Marvin--> if you see what I mean
14:41:54 <esap> Yea, I think I see the point. [though I'm wondering why it's not local :: ((a,r) -> m (b,r)) -> m a -> m b
14:42:34 <esap> no I mean ((a,r) -> (b,r)) -> m a -> m b.
14:43:57 * esap is not that familiar with Reader.
14:44:25 <Marvin--> me neither, really
14:44:58 <Marvin--> but I guess it's a sort of lifting, so  (r -> r) -> m a -> m a  might make sense
14:45:24 <esap> ok true.
14:48:11 <Marvin--> I'm off to bed
14:55:41 <SyntaxPolice> does anyone have experience w/ ghc on sparc? is it slower than on linux?
14:56:00 <esap> Hmm.. I wonder if x .>> v = x =>> \a -> a `seq` v
14:56:06 <Heffalump> "linux" and "sparc" are orthogonal contexts.
14:57:27 * esap has only used ancient sparcs so performance comparisons are pretty moot.
14:58:02 <SyntaxPolice> as far as I know,t he only linux that ghc works on is the i386  one
14:58:06 <SyntaxPolice> maybe I'm wrong
14:58:24 <Heffalump> I think it got ported to sparc recently-ish
14:58:30 <Heffalump> ICBW though
14:58:35 <Heffalump> so you meant Sparc Solaris?
14:58:38 <SyntaxPolice> yeah
14:59:16 <SyntaxPolice> well my program does almost nothing when running on sparc solaris, but works like a charm on i386 linux :(
14:59:45 * Heffalump hasn't tried it
15:00:18 <SyntaxPolice> yeah, I don't think its slowness at this point :(
15:04:27 * SyntaxPolice runs Debian-sparc on a sun-blade at home actually, which is kinda cool.
15:04:40 * SyntaxPolice disappears. peace all
15:33:47 <hdaume> has there been very little traffic on h@h.o today?
15:35:19 <Heffalump> there was a lot of stuff about times
15:35:35 <hdaume> other than that?
15:35:50 <Heffalump> bit about the library infrastructure, possibly? (that might have been on l@)
15:38:01 <hdaume> k
15:38:15 <hdaume> i switched the mailing list over to my @ms account and i wanted to make sure it wasn't broken
15:39:36 <Heffalump> bad move ;-)
15:39:54 <Heffalump> is your exchange server a beta version?
15:40:26 <hdaume> got me :)
15:40:37 <Heffalump> sorry?
15:40:43 <hdaume> i don't know :)
15:40:50 <Heffalump> ah :-)
15:41:35 <Heffalump> really, I would strongly advise not trusting your M$ email account with anything you don't have to
15:41:55 <hdaume> Heffalump: why?
15:42:20 <Heffalump> it has the potential to be /very/ unreliable
15:42:49 <Heffalump> especially if you are currently or get put on a server running a beta version of Exchange
15:43:30 <hdaume> ok
15:43:32 <hdaume> good to know
15:44:14 <Heffalump> when I was there, I used it for all my M$-work related correspondence, but everything else was kept in my personal email account
15:44:26 <Heffalump> which turned out to be a very good thing when they did precisely that to me :-)
15:44:32 <hdaume> :)
16:56:00 <inkedmn> ok, this is a really dumb question
16:56:18 <inkedmn> i'm trying to rewrite 'map' for fun
16:56:20 <inkedmn> mymap f l = f (head l) :: f (tail l)
16:56:27 <inkedmn> that's what i've got
16:56:50 <Heffalump> you're missing a recursive use of mymap
16:56:53 <whee> you probably want to recursively apply mymap
16:57:17 <inkedmn> oh, duh...
16:58:27 <inkedmn> mymap f l = f (head l) :: mymap f (tail l) 
16:58:33 <inkedmn> like that?
16:58:57 <Riastradh> That won't work, either -- what happens if you get a null list?
16:59:08 <inkedmn> well, i have a base case
16:59:10 <whee> also, wouldn't that reverse the list?
16:59:16 <inkedmn> heh
17:01:59 <Riastradh> whee, er, no.
17:02:07 <inkedmn> mymap f l = f (head l) ++ mymap f (tail l) 
17:02:21 <inkedmn> i had my cons operator jacked up
17:02:27 <Riastradh> mymap f l = mymap' f l []
17:02:28 <Riastradh>   where
17:02:35 <Riastradh>     mymap' f [] x = x
17:02:48 <Riastradh>     mymap' f (x:xs) r = mymap' f xs (f x : r)
17:02:51 <Riastradh> ...that will reverse the list.
17:03:44 <steveh> ++ isn't cons either ;)
17:04:16 <inkedmn> sweet!
17:04:23 <Riastradh> ++ is append.
17:04:28 <inkedmn> well, [1] ++ [2,3] gave me [1,2,3]
17:04:28 <inkedmn> ah
17:04:33 <inkedmn> super
17:05:01 <inkedmn> oh, ok
17:05:02 <inkedmn> :
17:05:17 <whee> oh, hrm
17:05:57 <whee> yeah, you're right
17:05:58 <inkedmn> ok, this works, but my type signature is bork3d
17:06:03 <whee> I don't know why I was thinking it would reverse
17:06:16 <inkedmn> not sure how to represent a function in a type signature
17:06:19 <Riastradh> What's your type signature?
17:06:36 <inkedmn> mymap :: a -> [b] -> [b]
17:06:44 <Riastradh> No, no, no.
17:06:49 <inkedmn> heh, yeah :)
17:06:51 <Riastradh> What's its first argument?
17:06:55 <inkedmn> function
17:06:58 <steveh> @type map
17:06:58 <lambdabot> map :: (a -> b) -> [a] -> [b]
17:07:00 <steveh> ;)
17:07:04 <inkedmn> heh
17:07:05 <Riastradh> Blah!
17:07:09 <steveh> oops
17:07:10 <steveh> sorry
17:07:13 <inkedmn> it's ok, i'm ignoring him :)
17:07:17 <inkedmn> continue
17:07:18 <steveh> screwed up the pedagogy
17:07:18 <Riastradh> OK.
17:07:26 <Riastradh> OK, so, describe its first argument in more detail.
17:07:55 <inkedmn> i'm not sure what you mean, it's just a function
17:08:13 <inkedmn> it's argument and result types are the same
17:08:16 <Riastradh> How many arguments do you apply it with in the body?
17:08:32 <inkedmn> several, but one at a time
17:09:25 <inkedmn> oh, i get it i think
17:09:30 <Riastradh> OK, I mean, when you apply it (each time), how many arguments do you apply it to?
17:09:35 <inkedmn> one
17:09:51 <Riastradh> OK.
17:10:17 <Riastradh> How do the type of its argument and the type of the elements in the list passed to 'map' relate?
17:11:00 <inkedmn> they're the same (if i understand your question correctly)
17:11:06 <inkedmn> type, i mean
17:11:08 <Riastradh> Yes.
17:11:14 <Riastradh> So, we'll call that type 'a'.
17:11:22 <inkedmn> ok
17:11:48 <Riastradh> How do the type of what it returns and the type of the elements in the resulting list relate?
17:12:55 <Riastradh> e.g., if I were to do:   map (\x -> x + 1) [1,2,3,4]   tell me how the type of the result of (\x -> x + 1) and [2,3,4,5] (the resulting list) relate.
17:13:58 <inkedmn> they're also the same
17:14:02 <Riastradh> Yes.
17:14:16 <inkedmn> so we'll call that type 'b'? :)
17:14:17 <Riastradh> Are they necessarily the same as the arguments to the function or the elements in the list passed to 'map?'
17:14:25 <inkedmn> no
17:14:30 <Riastradh> Right.
17:14:33 <Riastradh> So, 'a' and 'b'.
17:14:42 <inkedmn> yeah
17:14:45 <Riastradh> What's the type of f?
17:15:04 <inkedmn> a -> b
17:15:16 <Riastradh> What's the type of l?
17:15:25 <inkedmn> [a]
17:15:37 <Riastradh> What's the type of the result?
17:15:40 <inkedmn> [b]
17:15:55 <Riastradh> OK, now, 'map f' will return what?
17:16:10 <inkedmn> an item of type b
17:16:11 <Riastradh> (note the passing of just one argument)
17:16:13 <Riastradh> No.
17:16:23 <inkedmn> oh, sorry
17:16:37 <Riastradh> You know what currying is, right?
17:16:46 <inkedmn> heard the term, unsure of the definition
17:17:31 <Riastradh> Instead of having an ordinary function that takes n arguments, have an ordinary function that takes one argument and returns a curried function of n-1 arguments.
17:17:52 <Riastradh> e.g.:  let g = map (\x -> x + 1) in g [1,2,3,4]  -- returns [2,3,4,5]
17:18:17 <Riastradh> Did that example make sense?
17:19:00 <inkedmn> yes
17:19:08 <Riastradh> Good.
17:19:12 <Riastradh> So, what's the type of 'map f'?
17:19:42 <inkedmn> (thinking)
17:20:08 <Riastradh> It's a function that takes one argument, [a], right?
17:20:12 <inkedmn> yes
17:20:22 <Riastradh> What will it return?
17:20:35 <inkedmn> [b]?
17:20:55 <Riastradh> OK, so how do you notate that?
17:21:02 <Riastradh> It takes [a] and returns [b].
17:21:09 <inkedmn> [a] -> [b]
17:21:12 <Riastradh> Yes.
17:21:18 <Riastradh> Now, that's what 'map f' returns.
17:21:22 <inkedmn> ok
17:21:28 <Riastradh> And remember that the type of 'f' is a -> b.
17:21:32 <inkedmn> yeha
17:21:33 <inkedmn> er
17:21:33 <inkedmn> yeah
17:22:06 <Riastradh> So, 'map' takes a function of type a -> b, and returns a function that takes an argument of type [a] that returns a value of type [b].
17:22:11 <Riastradh> Turn that into a type notation.
17:22:54 <inkedmn> (a -> b) -> [a] -> [b]
17:22:57 <Riastradh> Yes.
17:23:08 <Riastradh> And how do you say 'mymap' has that type?
17:23:21 <inkedmn> mymap :: (a -> b) -> [a] -> [b]
17:23:30 <Riastradh> Yes.
17:23:48 <Riastradh> Now put that together with its definition.
17:25:34 <inkedmn> thanks man, works like a champ :)
17:31:06 <clausen> inkedmn: btw, the hugs prelude is quite a good read
17:31:21 <clausen> inkedmn: it has all this stuff in it
17:31:39 <inkedmn> clausen: that's a damn good idea...
17:31:48 <inkedmn> maybe i'll take a few pages to class with me :)
17:32:02 <clausen> inkedmn: yeah, I recommend you do that :)
17:32:15 <Riastradh> inkedmn, you're taking a class on Haskell?
17:32:54 <inkedmn> Riastradh: heh, i wish
17:33:02 <inkedmn> i meant to my math class to read during the break
17:33:07 <Riastradh> Oh, I see.
17:33:17 <inkedmn> i'd LOVE to take a Haskell class
17:33:36 <clausen> it used to be the first CS subject at my uni
17:33:39 <clausen> (that everyone had to take)
17:33:54 <clausen> they switched it to half of the second CS subject
17:34:28 <inkedmn> are you in the US?
17:35:44 <clausen> clausen: no, australia
17:35:49 <whee> I'd kill to have taken any CS course with a functional language :|
17:35:54 <clausen> s/clausen/inkedmn/
17:35:57 * clausen isn't talking to himself!
17:36:06 <inkedmn> clausen: heh
17:36:14 <clausen> whee: we also have honours-level logic and functional programming subjects
17:36:16 <clausen> (two of them!)
17:36:34 <clausen> also, a compulsary second year logic programming subject
17:36:36 <Riastradh> clausen, it's ok to be schizophrenic.
17:36:37 <clausen> so that's a total of four
17:36:47 <whee> we might have fun courses, but they're not obvious if we do
17:37:03 <whee> I had to take three java based CS courses and one with C++
17:37:31 <clausen> what were the subjects?
17:37:39 <clausen> (were they generic, or things like "network programming"?)
17:37:50 <whee> that was just CS[1-4]
17:38:15 <whee> start with basics in 1, more data structures and threads in 2, guis and more fun in 3, then cs4 was just throwing a new language at us
17:38:39 <clausen> aha
17:38:57 <clausen> our CS degree is fairly hardcore
17:39:00 <whee> it wasn't really a challenging line of courses
17:39:40 <clausen> but not as hardcore as the maths degree at our uni
17:40:22 <whee> engineering is the big thing here
17:54:41 <clausen> whee: here also, actually *grin*  (but I chose CS, not SE)
17:55:14 <Smerdyakov> SE? For what?
17:55:21 <whee> I went with CE
17:55:40 <whee> the SE program here looks like CS with more TPS reports
17:55:46 <Smerdyakov> TPS?
17:55:57 <whee> never seen Office Space? :(
17:56:07 <Smerdyakov> I have, but I don't remember it and I didn't like it.
17:56:23 <clausen> Smerdyakov: ?
17:56:25 <whee> useless paperwork that noone cares about,  heh
17:57:05 <whee> I had to take one of the SE courses, and we were told to implement a bowling simulator and maintain weekly status reports and the like
17:57:16 <whee> nothing that couldn't be gleaned from the CVS logs and thrown at someone
17:58:09 <inkedmn> lol, TPS reports
17:58:19 <inkedmn> office space was great
17:58:34 <whee> I loved the movie :)
17:58:47 <Riastradh> Smerdyakov, do you just dislike movies that lots of other people like?
17:58:54 <inkedmn> i'm hoping my wife will buy me the dvd for my birthday
18:00:09 <inkedmn> anyway, off to class
18:00:15 <inkedmn> thanks again for the help, friends...
18:00:17 <Smerdyakov> Riastradh, no, I just didn't like Office Space.
18:00:42 <Riastradh> Smerdyakov, that's not the only movie you've stated that you didn't like that lots of other people liked.
18:03:04 <Smerdyakov> Riastradh, so? You seem to lack an understanding of the difference between causation and correlation. :-)
18:03:39 <Heffalump> the "that" in what he said above didn't imply causation.
18:05:13 <Smerdyakov> Heffalump, I'm referring to the "just" in his 2nd most recent line.
18:11:47 <Heffalump> that still could be a question about correlation
18:11:49 <Heffalump> anyway, bedtime
18:13:02 <Smerdyakov> I am using my knowledge of idiomatic English to interpret what Riastradh said.
18:14:09 <Heffalump> I think it's ambiguous
18:14:30 <Smerdyakov> Riastradh, which one of these interpretations did you mean, or was it another yet? :)
18:14:54 <Riastradh> To rephrase, I might have said:  do you dislike movies -just because- lots of other people like them?
18:15:10 <Heffalump> bah :-)
18:16:04 <Smerdyakov> See.
18:16:11 <Smerdyakov> Heffalump is too old to understand Riastradh.
18:16:46 <Riastradh> Smerdyakov is under the impression that I'm a 13-year-old wimp whose mom tells never to give out information to avoid the child-abusers that roam the internet.
18:17:08 * Heffalump wonders how old Riastradh and Smerdyakov are
18:17:15 * Riastradh cryptically grins.
18:17:26 <Heffalump> oh yes, I'd forgotten you're the cryptic one.
18:17:28 <Smerdyakov> No, I think Riastradh is in the 16-22 range.
18:17:38 <Smerdyakov> I don't really know, though.
18:17:42 <Smerdyakov> I'm 99% sure that I'm 21, though.
18:17:47 <Heffalump> only 99%?
18:17:53 <Smerdyakov> Yeah. It's a crazy world out there.
18:18:20 <Riastradh> No one on IRC actually knows how old I am.
18:18:54 <Riastradh> Only one person who knows me in real life (whatever that be) is occasionally found in the same channels as I frequent.
18:19:04 <Riastradh> Whatever that may be, even.
18:21:08 * syntax-laptop wonders how this came up.
18:21:13 <syntax-laptop> was someone not acting their age :)
18:21:34 <Riastradh> Smerdyakov was throwing food at me, really!
18:21:55 <Smerdyakov> syntax-laptop, I said that Heffalump was too old to interpret what Riastradh said.
18:22:12 <Riastradh> Yeah, you're going to believe the immature food-throwing one, aren't you?
18:24:07 <syntax-laptop> I don't belive anything anyone says unless they're around the same age as me...
18:24:39 <Smerdyakov> syntax-laptop, I see!
18:25:14 <Riastradh> syntax-laptop, well, how old are you?
18:25:28 <syntax-laptop> unfortunitely, this makes it very hard to believe anything anyone says on irc or on the internet (bootstrappoing problems, you see) which is probably a good thing...
18:26:00 <syntax-laptop> but since I like the story better, I'll choose to side with Riastradh. Smerdyakov, how dare you?!
18:26:38 * Heffalump is more than 99% sure that he's 24, btw
18:27:00 <Riastradh> In an unprovoked fit of rage, Smerdyakov picked up the durian I was about to feast upon and hurled it at my head, maiming the left side thereof!
18:27:39 <Riastradh> And then he threw a raspberry at my shoulder.
18:27:47 <Smerdyakov> I'm a trying tasteful turnips in a tan tin tumbler.
18:28:00 <Riastradh> And now he's practising his alliterations on us, damnit!
18:28:36 <Heffalump> I'm immune to alliteration, I'll protect you from them
18:28:45 * Riastradh hides behind Heffalump.
18:29:01 * Riastradh throws an Arrow instance at Smerdyakov.
18:29:15 * syntax-laptop UnsafePerformsIO
18:29:37 <Heffalump> monomorphically or polymorphically?
18:30:03 <Riastradh> Polymorphically, of course.
18:30:07 <Smerdyakov> Does GHC have a function to do casts? :)
18:30:13 <Riastradh> Polymorphism will overcome monomorphism!
18:30:32 * syntax-laptop polymorphs
18:30:36 <Heffalump> well, you can write unsafeCoerce by using unsafePerformIO polymorphically.
18:30:49 <Heffalump> I think that if you use it monomorphically all that can happen is you get odd results.
18:31:43 <Smerdyakov> SML/NJ has an Unsafe.cast : 'a -> 'b function for endless fun. :D
18:32:23 <Heffalump> is that intended for implementing dynamics?
18:33:34 * Heffalump really goes to bed
18:34:07 <Smerdyakov> I think it's used in some system libraries, probably.
18:34:08 * Riastradh drags the bed into #haskell.
18:34:19 <Heffalump> it won't fit through the door
18:34:29 <Smerdyakov> Maybe you can disable the Unsafe structure if you want. I'm not sure.
18:34:40 * Riastradh throws a grenade, generalized from an arrow, at the door, and now the bed will fit.
18:35:02 <Heffalump> no, now it'll just fall down the stairs
18:35:19 * Riastradh uses a hovercraft, generalized from a grenade, to hover it back into the channel.
18:37:02 <syntax-laptop> ooh ooh, can I generalize a flying carpet from a hovercraft?
18:37:12 <syntax-laptop> if I use -fglasgow-exts
18:38:35 <Riastradh> No, -fglasgow-exts only goes up to model rockets.
18:38:44 <Riastradh> You need -fedinburgh-exts for hovercraft.
18:39:04 <Riastradh> And -finverary-exts for flying carpets.
19:12:05 <Smerdyakov> Hm. I guess he just had to find himself. (In reference to quit message)
19:18:00 <clausen> does anyone know of any good algebra libraries for haskell?
19:18:31 <Smerdyakov> More detail on what you want would help. One can view the Haskell language itself as pretty algebraic!
19:18:58 <clausen> things like working on some standard rings
19:19:02 <clausen> (eg: polynomial rings)
19:19:08 <clausen> galois fields, etc.
19:19:22 <clausen> like GAP
19:19:43 <clausen> http://www-gap.dcs.st-and.ac.uk/~gap/
19:54:24 <Smerdyakov> Gosh. It's amazing how hard that site makes it to figure out what language GAP is a library for!
19:54:27 <Smerdyakov> I still don't really know.
19:55:54 <Smerdyakov> Oh. Maybe it's not a library.
19:56:10 <clausen> it isn't a library
19:56:14 <clausen> it's a self-contained system
19:56:27 <clausen> the manual is pretty good
19:56:37 <clausen> but will be pretty meaningless if you don't know much about algebra
19:56:49 <Smerdyakov> I know moderately much about algebra.
19:56:56 <clausen> (even I find it tricky, and I've taken 4 courses on algebra)
19:57:17 <Smerdyakov> I've taken linear algebra, plus at least 3 classes that included 2 weeks on algebra each. :-)
19:57:34 <clausen> Smerdyakov: that isn't much
19:57:47 <Smerdyakov> Yup, but, of course, it all depends on the pace of classes.
19:57:51 <clausen> linear algebra isn't scratching the surface
19:58:04 <clausen> (it's more an application of algebra)
19:58:24 <Smerdyakov> So is Haskell, really.
19:58:28 <clausen> eg: you use algebra to prove that the minimal polynomial divides the characteristic polynomial
19:58:38 <clausen> Smerdyakov: haskell seems more a result of category theory
19:58:59 <Smerdyakov> Yeah, yeah, I am almost a mathematician. I do know what algebra is. :D
19:59:19 <Smerdyakov> (I did a math minor and concentrated somewhat in theory for my CS major.)
19:59:25 <clausen> aha
19:59:33 <clausen> by algebra, I mean groups, rings, modules, fields, etc.
19:59:37 <Smerdyakov> Yup, I know.
20:01:35 <clausen> ah Pseudonym, you know all :)
20:01:40 <clausen> any algebra libraries for haskell?
20:01:44 <clausen> (is it even a good idea?)
20:01:47 <Pseudonym> What kind of algebra?
20:01:51 <clausen> groups, rings, etc.
20:02:15 <Pseudonym> Not that I know of, probably because it's pretty simple.
20:02:15 <clausen> eg: if you define a euclidean domain, it gives you a factorization algorithm
20:02:19 <Pseudonym> Oh.
20:02:21 * Pseudonym hmms
20:02:25 <Pseudonym> I have a typeclass for that.
20:02:26 <Smerdyakov> clausen, what are you envisioning? How many algorithms do you think are worth including in such a library?
20:02:46 <clausen> Smerdyakov: well, I'd like a lot of standard groups and rings defined
20:02:50 <Pseudonym> The difficulty with this is that you can't use the "standard" operators.
20:02:57 <clausen> Smerdyakov: and a convenient notation, etc.
20:03:02 <clausen> Smerdyakov: eg: permutation groups would be nice
20:03:24 <clausen> or automorphism groups on finite sets
20:03:41 <clausen> (could be nice in haskell, since haskell has lots of higher-order facilities)
20:04:00 <Pseudonym> See, when you said "algebra library", I was thinking symbolic integration. :-)
20:04:07 <Pseudonym> Or something like that.
20:04:44 <Pseudonym> Incidentally, not all Euclidean domains have factorisation algorithms.
20:04:55 <clausen> they don't?!
20:05:00 <Pseudonym> Though I believe they all have square-free factorisation.
20:05:08 <Pseudonym> No, I don't think so.
20:05:10 * clausen thinks
20:05:28 <Smerdyakov> Pseudonym, you mean you can prove factorisation undecidable, even though there are always answers?
20:05:41 <Pseudonym> I think factorisation may not be unique in general.
20:05:56 <clausen> in a euclidean domain it is
20:06:20 <clausen> if a irreducibles are primes, then factorization is unique
20:06:25 <clausen> (in a commutative ring)
20:06:36 <Pseudonym> Hmmm.
20:06:43 <clausen> so, principal ideal domains and hence euclidean domains have unique factorization
20:07:02 <Pseudonym> Oh, I know.  I think that there isn't a simple algorithm for factorisation of polynomials with integer coefficients.
20:07:03 * steveh claws out his eyes.
20:07:08 <Pseudonym> Squarefree factorisation, yes.
20:07:11 * steveh audited an abstract algebra class.
20:07:13 <clausen> http://www.wikipedia.org/wiki/Unique_factorization_domain
20:07:58 <Pseudonym> clausen, how do you factor a polynomial with integer coefficients?
20:08:13 <Pseudonym> I'm genuinely curious.
20:08:20 * Pseudonym is very willing to be proven wrong
20:08:25 <Pseudonym> Since I probably am wrong.
20:08:31 <clausen> actually, I think it probably is undecidable
20:08:34 <clausen> maybe a result of galois theory
20:08:36 * clausen thinks
20:08:39 <Smerdyakov> Pseudonym, is that a "Euclidean domain"?
20:08:49 <Pseudonym> Smerdyakov: Yup.
20:09:17 <clausen> in any case, all polynomials with integer coefficients that can be facorized into polynomials with rational coefficients can also be factored into poly's with integer coefficients
20:09:26 <Pseudonym> You can think of a Euclidean domain as a ring with the division-with-remainder operation.
20:09:40 <clausen> i.e. if p(x) \in Z[x] can be factored in Q[x], then it can also be factored in Z[x]
20:09:40 <Smerdyakov> Ah
20:09:51 <clausen> Smerdyakov: the wikipedia is good
20:09:51 <Smerdyakov> clausen, isn't that obvious? :)
20:10:05 <clausen> Smerdyakov: it isn't obvious how to prove it
20:10:37 <clausen> anyway, to factor something, I guess it roughly equivalent to finding it's roots
20:10:51 <Smerdyakov> clausen, hm... you can't just take all the denominators of coefficients in the factoring and multiply by their product?
20:11:12 <Pseudonym> Yes, but if none of the roots of a polynomial with integer coefficients are integers, then the polynomial is irreducible.
20:11:16 <clausen> Smerdyakov: well you can, but it isn't trivial to show that the resulting poly will be bigger
20:11:27 <clausen> (i.e. you might get 2(x+2) rather than x+2, so to speak)
20:11:32 <clausen> Pseudonym: right
20:11:44 <clausen> Pseudonym: and there isn't an algorithm for testing irreducibility
20:11:45 <clausen> (AFAIK)
20:11:48 <Smerdyakov> clausen, hm.. what does "bigger" have to do for it?
20:11:48 <clausen> hmmm
20:11:51 <clausen> there's the rational root test
20:11:56 <Pseudonym> Oh, hang on.
20:12:01 <Pseudonym> I see.
20:12:15 <Pseudonym> In UFDs, every irreducible element is prime.  The converse is _not_ necessarily true.
20:12:17 <clausen> Smerdyakov: well, if you want to factor 2x? + 5x
20:12:23 <clausen> Pseudonym: yes it is
20:12:31 <clausen> Pseudonym: the converse is true in any integral domain
20:12:41 <clausen> (UFDs are a special kind of integral domain)
20:12:46 <Pseudonym> But a Euclidean domain isn't necessarily integral.
20:12:53 <clausen> Pseudonym: yes it is
20:12:56 <Pseudonym> Is it?
20:12:58 * Pseudonym hmms
20:13:05 <clausen> ED => PID => UFD => ID => commutative ring
20:13:07 <Pseudonym> It's been a while since I last knew all this.
20:13:19 * Smerdyakov is a member of the popular "how can algebra possibly be useful?" club. :)
20:13:21 <clausen> fair enough :)
20:13:24 <clausen> I did an exam on this last week
20:13:34 <Pseudonym> This is from the page you showed me:
20:13:39 <Pseudonym> In UFD's, every irreducible element is prime (the converse is true in any integral domain). 
20:13:49 <clausen> UFD's are a special type of integral domain
20:13:58 <Pseudonym> Oh, I see.
20:13:59 <Pseudonym> Duh.
20:14:00 <Pseudonym> Right.
20:14:10 <Pseudonym> So what's a Euclidean domain?
20:14:26 <clausen> it's an integral domain with a "degree" function that follows some rules
20:14:31 <Pseudonym> It's a ring plus division-with-remainder, right?
20:14:53 <clausen> that isn't the definition... that is a consequence
20:14:56 <Pseudonym> I know.
20:15:00 <Pseudonym> I'm taking operationally.
20:15:02 <clausen> http://www.wikipedia.org/wiki/Euclidean_domain
20:15:08 <clausen> yep
20:15:11 <Pseudonym> I'm thinking in Haskell typeclasses. :-)
20:15:15 <clausen> *grin*
20:15:55 <clausen> Smerdyakov: algebra is rather foundational
20:16:10 <clausen> Smerdyakov: I've actually run into lots of practical problems it has helped me with
20:16:15 <clausen> Smerdyakov: it's also very pretty :)
20:16:33 <Pseudonym> I have too.  I found a bug in Pixar's Photorealistic RenderMan once, which was entirely algebraic.
20:16:41 <Pseudonym> Caused me no end of gried.
20:16:44 <Pseudonym> grief
20:17:19 <clausen> so, the rational root test applies to polynomials
20:17:28 <clausen> what about euclidean domains in general?
20:18:00 <Pseudonym> What is required for factorization to be possible?
20:18:08 * Pseudonym hmms
20:18:15 <clausen> well, it has to be a unique factorization domain
20:18:19 <clausen> all ED's are UFD's
20:18:30 <clausen> s/possible/to exist/
20:18:31 <Pseudonym> Yes.
20:18:34 <clausen> (that's what I answered)
20:18:50 * Pseudonym hmms
20:18:59 <clausen> so, if there are a finite number of elements of each degree
20:19:05 <clausen> then it's clear that it is decideable
20:19:20 <clausen> (because you can try dividing by each element)
20:19:25 <Pseudonym> Right.
20:19:34 <Pseudonym> For polynomials there aren't, though.
20:19:39 <clausen> right
20:20:29 <Pseudonym> Anyway, I'll check my Euclidean typeclass into haskell-libs.
20:20:32 <Pseudonym> Hang on.
20:22:10 <Pseudonym> Yeah, I think the solution for polynomials is somewhere deep inside Galois theory.
20:22:32 <Pseudonym> So you can't really do something as simple as "here's a Euclidean domain, now factor this".
20:22:52 <Pseudonym> Unless each degree is finite, as you say.
20:25:03 <Pseudonym> Doesn't appear to be in viewcvs yet.  But it's in haskell-libs/libs/maths/euclidean/
20:25:15 * clausen phone
20:25:19 * Pseudonym nods
20:31:49 <clausen> thanks
20:31:53 * clausen lunch + gf
20:33:58 <Pseudonym> No problem.
20:39:40 <inkedmn> evening all 
20:47:21 <Pseudonym> G'day.
20:48:16 <inkedmn> i'm seriously going to put up a site FULL of small things people can write when learning new languages
20:48:36 <inkedmn> because i have the hardest damn time coming up with things to write
20:49:02 <Pseudonym> I can find you something if you like.
20:49:55 <inkedmn> that'd be awesome :)
20:52:03 <Pseudonym> Let me have a look...
20:52:17 <inkedmn> thank you :)
20:52:51 <Pseudonym> Oh, I know!  Balanced sets.
20:53:18 <Pseudonym> http://www.swiss.ai.mit.edu/~adams/BB/
20:53:24 <Pseudonym> Implement all that in Haskell.
20:53:32 <Pseudonym> There's not a lot there.
20:53:44 <inkedmn> ok, will do :)
20:53:49 <inkedmn> thanks very much my friend!
20:53:54 <Pseudonym> No problem.
20:54:05 <Pseudonym> I suggest going from the paper rather than from the ML source code.
20:54:17 <Pseudonym> Next time you need something to do, ask me.
20:54:19 * Pseudonym has a LONG list
20:54:45 <inkedmn> heh, you got it :)
20:55:42 <Pseudonym> www.cs.uu.nl/~johanj/publications/TheWeb.ps
20:55:50 <Pseudonym> We could also do with an implementation of that.
20:55:54 <Pseudonym> :-)
20:57:16 <inkedmn> heh
20:57:25 <inkedmn> reading over that balanced sets thing
20:57:34 <inkedmn> but i must warn you, i'm not a CS student (yet)
20:57:39 <Pseudonym> That's okay.
20:57:40 <inkedmn> i'm totally self-taught
20:58:15 <Pseudonym> I don't think you have to be unless you want to work your way through the proofs.
20:58:18 <inkedmn> so what i'm saying is, in a roundabout way, i don't know what a "set" is :)
21:03:30 <inkedmn> heh, is this at the TOP of your LONG list? ;)
21:05:15 <inkedmn> this is a little more advanced than i was thinking...
21:06:39 <Gaucho> hi, can i ask hugs questions in here as well?
21:06:54 <inkedmn> go for it
21:07:04 <inkedmn> i doubt i'll be much help, i'm pretty new
21:07:10 <Pseudonym> his isn't at the top.
21:07:15 <Pseudonym> You could do the web one if you want.
21:07:20 <Pseudonym> That's pretty simple.
21:07:30 <Pseudonym> Gaucho: Just ask.
21:07:35 <Gaucho> i'm doing elementary programs... solving simple one task problems
21:08:21 <Gaucho> i've done a little one that given a list and a number it returns a list of numbers(should) and each of that numbers are the position of the given number in the given original list...
21:08:49 <Gaucho> but i'm getting instance of Num [Int] required for definition of giveListPos
21:09:18 <Pseudonym> That's definitely a bug.
21:09:22 <Pseudonym> In your code. :-)
21:09:45 * Gaucho bangs his head against the desktop
21:09:54 <Gaucho> where can i paste the code?
21:09:57 <Pseudonym> How many lines in your function?
21:10:07 <Gaucho> 3
21:10:12 <Gaucho> well 4
21:10:13 <Pseudonym> Do it here, theb.
21:10:55 <Gaucho> darListaPos::Char->[Char]->[Int]
21:10:56 <Gaucho> darLista _ [] = [0]
21:10:56 <Gaucho> darListaPos x (y:ys) | x==y = 1:darListaPos x ys
21:10:56 <Gaucho> 		     | otherwise = 1+darListaPos x ys
21:11:09 <Gaucho> darListaPos equivalent to, giveListPos
21:11:33 <Pseudonym> The problem is in the "otherwise" cas.e
21:12:06 <Pseudonym> What type does "darListaPos x ys" have?
21:12:10 <Gaucho> the thing is that i'm returning an int rather than a list of ints isn't?
21:12:27 <Pseudonym> Well, darListaPos actually returns a [Int].
21:12:31 <Pseudonym> And you're trying to add 1 to that.
21:12:36 <Pseudonym> You can't add 1 to [Int].
21:12:37 <Gaucho> oh
21:12:46 <Gaucho> i was searching for other error
21:13:00 <Pseudonym> Do you know what the error that you got means?
21:13:36 <Pseudonym> Saying that an instance of Num [Int] is required basically means that [Int] isn't a number.
21:13:36 <Gaucho> yes, that the returning type should be Int in order to be able to sum
21:13:42 * Pseudonym nods
21:13:43 <Gaucho> right
21:13:55 <Gaucho> i was thinking inside the box
21:14:03 <Pseudonym> Except I think that you actually want to return [Int], don't you?
21:14:49 <Gaucho> yes i want to return a list of positiojns
21:14:54 <Gaucho> positions, sorry
21:15:11 <Pseudonym> Right.  So what do you actually want to do in the "otherwise" case?
21:16:39 <Gaucho> well nothing, i mean, i just want to get all the positions of a given element, like, darListaPos '3' "3 it's a nice number, 3 times" , returning [1,22]
21:16:58 <Pseudonym> You can't want to do nothing in the "otherwise" case.
21:17:03 <Pseudonym> You have to do _something_.
21:17:40 <Gaucho> i mean, in case i'm in the position i return 1 concatenated with the other positions
21:17:54 <Pseudonym> Right.
21:18:03 <Gaucho> if i'm not in the right position i just need to jump to the next position increasing the counter of positions
21:19:03 <Pseudonym> What counter would that be?
21:19:33 <Gaucho> well, don't have variables so the counter it's just the value in the stack that i'm storing
21:19:51 <Pseudonym> Sorry, what stack?
21:20:26 <Gaucho> the program stack, isn't that the way functional programming works when using recursive stuff?it's declarative but internally it works just like prolog isn't?
21:20:45 <inkedmn> you'll need an accumulator, i think
21:20:47 <Pseudonym> Oh, I see what you mean, right.
21:21:24 <Pseudonym> Well you don't "need" one.
21:21:31 <Gaucho> i shouldn't use variables
21:21:36 <Gaucho> i need to do it without variables
21:21:36 <inkedmn> it'd make it easier, no?
21:21:37 * Pseudonym can think of about three other ways to solve it
21:21:49 <Pseudonym> What do you mean "without variables"?
21:21:55 <inkedmn> Pseudonym: are there more of these "Functional Pearl" things on the web anywhere?
21:21:55 <Pseudonym> "x" is a variable, and you're using that.
21:22:04 <Gaucho> auxiliar variables
21:22:19 <Pseudonym> inkedmn: We really should come up with a list of them.  Google will help you out.
21:22:29 <Pseudonym> Hmm, OK.
21:22:58 <Pseudonym> Let's suppose your "otherwise" case looked like this:
21:23:08 <Pseudonym>      | otherwise = darListaPos x ys
21:23:11 <Pseudonym> Without the "1+"
21:23:31 <Gaucho> that should work?
21:23:31 <Pseudonym> Your function is going to return some 1's followed by a 0.  So, for example:
21:23:38 <Pseudonym> darListaPos '3' "3 it's a nice number, 3 times" = [1,1,0]
21:23:48 <Gaucho> that should work?
21:23:50 <Pseudonym> I don't think that's what you want.
21:24:05 <Pseudonym> No, it won't work.
21:24:06 <Gaucho> well nop:)
21:24:10 <Pseudonym> :-)
21:24:25 <Pseudonym> First off, I don't think yo uneed the "0".
21:24:30 <Gaucho> question, when returning, when should i write [0] or (0)?
21:24:42 <Pseudonym> What do you want to return for that case?
21:24:54 <Gaucho> what case?
21:25:07 <Pseudonym> Where you are looking for some element in an empty list.
21:25:13 <Pseudonym> darLista _ [] = ?
21:25:17 <Pseudonym> What's the "?"
21:25:30 <Gaucho> the value in case i'm given the empty list
21:25:38 <Pseudonym> And what should you return?
21:26:06 <Gaucho> a 0 in that position
21:26:12 <Pseudonym> Why?
21:26:13 <Gaucho> cause that's not in the list
21:26:26 <Pseudonym> Is that what you are supposed to return?
21:26:43 <Pseudonym> darListaPos '3' "foo bar" = [0]?
21:26:50 <Gaucho> well, yes, cause it returns the positions of the elements...
21:26:54 <Gaucho> yes
21:27:07 <Pseudonym> You sure about that?
21:27:10 <Gaucho> well, that or empty ' ', but as Int ' ' it's no good
21:27:21 <Gaucho> the only thing for sure it's that nothing is for sure
21:27:22 <Pseudonym> Why not return the empty list?
21:27:41 <Gaucho> it's the same i guess
21:27:45 <Pseudonym> No it's not.
21:27:50 <Pseudonym> [0] is not the same as []
21:28:10 <Gaucho> the same in functional purpose i meant, not in programming environment
21:28:45 <Pseudonym> I don't agree.  I think there's a crucial difference.
21:28:57 <Pseudonym> [] means no matches, [0] means one match which makes no sense
21:29:04 <Gaucho> that's not important for this matter
21:29:57 <Gaucho> it's giving me an error nevertheless
21:30:05 <Pseudonym> What error?
21:30:23 <Gaucho> Program error, besides it's printing, [1,1
21:30:41 <Gaucho> no more than that, and the error says, program error (darListaPos 'a' [])
21:30:51 <Pseudonym> Did you delete that case?
21:31:01 <Gaucho> not at all
21:31:08 <Pseudonym> Hmmm.
21:31:22 <Pseudonym> http://www.nomorepasting.com/
21:32:34 <Gaucho> the program continues being the same, but if you would like to i can put the code there
21:32:53 <Gaucho> let's see, i'm in delphi right?
21:32:57 <Gaucho> *kidding*
21:33:02 * Pseudonym laughs
21:33:08 <Pseudonym> Oh.
21:33:09 <Pseudonym> I see.
21:33:15 <Pseudonym> No, don't paste.  I see the problem.
21:33:23 <Pseudonym> <Gaucho> darLista _ [] = [0]
21:33:23 <Pseudonym> <Gaucho> darListaPos x (y:ys) | x==y = 1:darListaPos x ys
21:33:26 <Pseudonym> Look carefully.
21:33:42 <Pseudonym> What it's telling you is that it can't work out what to do for darListaPos 'a' []
21:33:46 <Pseudonym> Can you see why?
21:34:28 <Gaucho> shouldn't darListaPos 'a' [] go in [0]?
21:34:30 <Gaucho> or []?
21:35:38 <Pseudonym> Look carefully at your code.
21:36:18 <Gaucho> i'm wrong in my late guess?
21:36:38 <Pseudonym> Look.  Try to find a rule which matches "darListaPos 'a' []"
21:37:20 <Gaucho> darListaPos _ [] = [0] should match
21:37:29 <Gaucho> afaik and iirc
21:37:32 <Pseudonym> It should, if that's what you'd written.
21:37:47 <Pseudonym> But it isn't.
21:37:48 <Gaucho> holly
21:37:52 <Gaucho> lol
21:37:58 <Gaucho> can believe this
21:38:08 <Gaucho> i deserve a beer for this
21:38:23 <inkedmn> Pseudonym: in this The Web thing, he talks about "some term type"
21:38:41 <inkedmn> i'm not sure what that means
21:39:00 <Pseudonym> inkedmn: Yes.  Uhm... it might help if you looked at the zipper first.
21:39:08 <inkedmn> ok
21:39:13 <Pseudonym> http://haskell.org/hawiki/TheZipper
21:39:30 <Pseudonym> That'll give you the idea of what the web is trying to do.
21:39:52 <Pseudonym> The "term type" used in the zipper example is a binary tree.
21:40:11 <Pseudonym> The idea is the web is trying to make that work for _any_ term type.
21:45:20 <Gaucho> Pseudonym: do you know can i make this work?
21:45:28 <Gaucho> cause i'm seeing the code but ...
21:45:49 <Pseudonym> What's the problem you're having?
21:46:24 <Gaucho> well, in the otherwise part, i need to sum the position but can't
21:46:40 <Pseudonym> WHat do you mean "sum the position"?
21:48:14 <Gaucho> i mean add the position, like, the position if i'm not in the correct position is 1+position in the list in the future
21:48:23 <Pseudonym> Right.
21:48:33 <Pseudonym> You originally put 1 + darListaPos x ys
21:48:38 <Pseudonym> Which doesn't work.
21:48:46 <Pseudonym> What did you mean by that?
21:49:43 <Gaucho> that won't work, i mean, i can't add, and without that addition i don't know another way
21:50:00 <Pseudonym> Like I said: What did you MEAN?
21:50:08 <Pseudonym> Here, let me let you in on a secret.
21:50:21 <Pseudonym> You want your program to mean something.
21:50:34 <Pseudonym> Hugs understands your program as meaning something else.
21:50:45 <Pseudonym> A "bug" is what happens when those two meanings are different.
21:50:48 <Gaucho> how can i make hugs understand?
21:51:05 <Pseudonym> You need to be clear about what you mean.
21:51:08 <Smerdyakov> Tie it to a chair and play it movies with its eyelids taped open.
21:51:12 <Pseudonym> So I ask again: What did you mean like that?
21:51:21 <Pseudonym> Oh, that's a good idea!
21:51:35 <Gaucho> i was thinking on breaking fingers but... that's an idea
21:51:49 <Pseudonym> Threaten to cut its electricity off.
21:52:01 <Pseudonym> So what did you mean by that?
21:52:07 <Smerdyakov> Threaten to force evaluation of all its expressions!
21:52:13 <Gaucho> heh
21:52:15 <Pseudonym> Aaargh!  Nooooo!!!
21:52:26 <Pseudonym> Threaten to make it impure.
21:53:02 <Gaucho> you have became addicted to this jokes:)
21:53:19 <Pseudonym> Understand, or I'll... use unsafePerformIO in a discouraged way!
21:54:17 <Smerdyakov> I have the best one yet!
21:54:28 <Smerdyakov> Understand or I'll write a C-to-Haskell translator and force you to compile all my C programs!
21:54:39 <Gaucho> i don't know how to get the position, the thing should be, 1+position from now on....
21:54:41 <Pseudonym> You're truly evil.
21:55:11 <Gaucho> well C it's mean
21:55:14 <Gaucho> evil
21:55:15 <Pseudonym> Sorry, back to you Gaucho.
21:56:17 <Pseudonym> I'll give you two possibilities.
21:56:27 <Pseudonym> One is that you don't just put "1" in the list when elements match.
21:56:38 <Pseudonym> Put the actual position instead.
21:57:05 <Pseudonym> Too hard to explain the other one.
21:57:07 <Pseudonym> :-)
21:57:13 <Pseudonym> So I'll leave it as one.
21:57:21 <Gaucho> but i'm giving the actual position, when it matchs the position in the sublist it's the first, that's why it's 1
21:57:42 <Pseudonym> Yes, I see that.
21:57:54 <Pseudonym> But when you pop up one recursive step, it's no longer 1.
21:58:04 <Gaucho> i'm already doing that, in a declarative recursive amazing astonishing pretty organized form
21:58:25 <Gaucho> what do you mean pop up one recursive step?
21:58:45 <Pseudonym> Consider this:
21:58:52 <Pseudonym> darListaPos '2' "12"
21:59:02 <Pseudonym> That matches the second case, which is:
21:59:09 <Pseudonym> darListaPos '2' "2"
21:59:24 <Pseudonym> Which should return [1], I believe.
21:59:33 <Pseudonym> But when you then return to the caller, you still get [1].
21:59:54 <Gaucho> well, it's 1+the return
22:00:04 <Gaucho> but as i have a list, can do the addition
22:00:09 <Gaucho> and that's killing me softly
22:00:27 <Pseudonym> What do you mean "1+the return"?
22:00:42 <Pseudonym> What do you want it to do?
22:00:47 <Pseudonym> Try to be clear about this.
22:01:03 <Gaucho> if it's '2' "12", then it returns 1 when the sublists it's "2", but that's 1+the return value of the sublist, which is 1, so that's 1+1 = 2
22:01:25 <Pseudonym> OK, so you want to add 1 to some number.
22:01:28 <Gaucho> the thing is that i'm not returning a number as a position, i'm returning a list
22:01:34 <Pseudonym> But what you have is a list of numbers.
22:01:38 <Pseudonym> So how can you do that?
22:02:10 <Gaucho> i'm thinking
22:25:49 <cale> Heh, people at my university have recently changed to using only PDF for various documents (like exam schedules) because they think it's somehow "secure" against modification as opposed to things like HTML and text. I sent them a copy of the exam schedule modified with my suggestions as to what they actually might try in order to allow people to detect alterations.
22:26:27 <Smerdyakov> MD1000 checksums!
22:26:58 <cale> yeah, pretty much.
22:47:57 <vegai> cale: it's more secure in the sense that idiots can't change it =)
22:50:20 <cale> Well, at least poor idiots - rich idiots could just buy Adobe's software - that stuff is pretty easy to use.
22:51:38 <cale> And even poor people of average intelligence can get copies of Adobe's software. :)
22:59:39 <Gaucho> how can you measure intelligence?
23:00:05 <Gaucho> don't take me the wrong way, i'm being curious
23:00:46 <lament> with a bat.
23:01:05 <lament> You count how many times you have to hit somebody with a bat to turn them into an imbecile.
23:01:15 <lament> For many people, you don't even need a bat.
23:01:50 <Gaucho> mmmm
23:02:02 <Gaucho> you marilyn vos savant was hit 218 times?
23:06:22 <cale> An extension of that idea would be to use a gun. It's usually safe to say that someone who is dead is not intelligent anymore.
23:06:55 <Gaucho> intelligence it's a mith
23:07:53 <Gaucho> you can distinguish people with a lot of knowledge or people with a lot of bright to solve problems, that's all... and when the two mix, there's gauss, newton, ramanujan, euler, etc, etc...
23:07:58 <cale> Intelligence is just not a quantitative thing.
23:08:17 <Gaucho> it's like an iq test, it's subjective and not assertive
23:28:27 <Pseudonym> Back.  Fire alarm went off.
23:28:37 <Pseudonym> The announcement told me to "prepare to evacuate the building".
23:28:45 * Pseudonym felt like he was in a bad sci-fi show
23:28:48 <Gaucho> really?
23:29:24 <Pseudonym> Intelligence is hard to capture.  If you can think of a definition, you may be able to test that.
23:29:43 <Pseudonym> This, incidentally, is why organisations like Mensa accept all sorts of tests.
23:29:57 <Gaucho> mensa is stupid
23:30:08 <Pseudonym> Arguably, yes.
23:30:14 <Pseudonym> Though not in the IQ sense. :-)
23:30:26 <Gaucho> i think the iq doesn't define a person
23:30:35 <Pseudonym> Well nothing defines a person.
23:30:38 <Gaucho> a person with an iq of 120 it's not better than one with an iq of 119
23:30:48 <Gaucho> that's just another reason to fight each other
23:31:02 <Pseudonym> That's even true statistically.  The difference between 119 and 120 isn't statistically significant.
23:31:40 <Pseudonym> Nothing "defines" a person except the whole.
23:32:01 <Gaucho> the hole?
23:32:03 <Gaucho> ;P
23:33:34 <Pseudonym> I've never heard of a war fought over IQ.
23:33:48 <Pseudonym> People have been beaten up over science before, of course.
23:34:09 <Gaucho> example, there's no need to say that newton was 180 and leibniz 195
23:34:21 <Gaucho> that's just something that human kind don't need
23:36:10 <Pseudonym> Were they formally tested?
23:36:20 <Pseudonym> Oh, I agree with you, BTW.
23:36:39 <Gaucho> not at all, they weren't tested, i still don't know how they get to that
23:36:59 <Pseudonym> There's a famous quote which went to the effect that I don't care how many brain cells Einstein had.  I care more about all of the smarter people who have died in sweatshops and on cotton fields.
23:37:59 <Pseudonym> G'day.
23:38:11 <shapr> g'day Pseudonym 
23:39:42 <Gaucho> i'm going to sleep, was nice to talk to you all
23:40:21 <shapr> good night.
23:41:08 * shapr still has a bit more to do before sleeping.
23:41:25 <dennisb> shapr: it's morning you know...
23:41:32 <shapr> really?
23:41:43 <shapr> the sun never goes down, it's hard to notice.
23:41:47 <dennisb> maybe not up north where you are...
23:41:49 <Pseudonym> Night.
23:51:09 <shapr> goood morning Marvin-- 
23:51:11 <Marvin--> Pseudonym: hey, you said you could give me some good references on indexing&querying when I'd read the Gigabytes book
23:51:13 <Marvin--> morning
23:51:48 <Pseudonym> G'day. :-)
23:51:53 <Pseudonym> You've finished the book?!
23:54:34 <Marvin--> well, I haven't read anything about the image compression/indexing/searching stuff since it's not relevant to me
23:54:57 * Pseudonym nods
23:55:08 <Marvin--> but I've skimmed the rest and read the chapters on indexing carefully
23:55:33 <Marvin--> not carefully as in I'm ready to take an exam on the topic, but as in I have a better understanding of it than before
23:56:13 <Pseudonym> Sure.
23:56:17 * Pseudonym did an exam on the topic
23:56:20 <Marvin--> and seeing as I get to read the book while at work... :)
23:57:11 <Pseudonym> Let's see.  Unfortunately, Alistair Moffat's research isn't published electronically.
23:57:24 <Marvin--> dang
23:57:27 <Pseudonym> He's of the opinion that it's good to hoard these things so you can publish them in a book later.
23:57:53 <Pseudonym> Two decent researchers, however, are Justin Zobel and Hugh Williams.
23:58:10 <Pseudonym> Both at this fine university.
23:58:43 <Pseudonym> http://www.seg.rmit.edu.au/research/research.php
23:58:49 <Pseudonym> Some good stuff there.
23:59:15 <Marvin--> I'm not sure that what I need is bleeding edge research though, something pragmatic would be good, since we're no way near the extreme sizes you guys are working on :)
23:59:21 <Pseudonym> True.
23:59:44 <Pseudonym> If you have a look at the "A General-Purpose Compression Scheme for Large Collections" paper, I think that's enough.
