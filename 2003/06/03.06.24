02:06:19 * esap answered some duality questions at http://c2.com/cgi/wiki?OoVsFunctional. Comments?
02:12:29 <vegai_> "the code is easier to write" is something I might argue with
02:13:12 <vegai_> granted, I've written 'regular' programs for 15 years, and functional programs less than 1 year
02:15:40 <vegai_> oops, you didn't ask about that
04:40:21 * Marvin-- goes "ARGH"
04:43:03 * Marvin-- sniffs and wants pattern matching in python
04:52:32 <jlouis> then write it
04:53:03 <jlouis> it is easy to create a pattern match compiler and rewrite it to the original language (provided you can define what a constructor is in Python)
05:28:43 <vegai_> is there a cookbook sort-of thingie on Haskell? 
05:28:57 <vegai_> ie. a site that holds recipies for doing useful tasks 
05:31:19 <Marvin--> well, there's http://www.haskell.org/hawiki/CommonHaskellIdioms but I don't know how much info there is
05:34:09 <vegai_> this would be much more useful pedagogically than the more mathematically oriented tutorials
05:34:18 <vegai_> I'll check that out, thanks
05:40:26 <S-> mathematically oriented?
05:40:45 <S-> does haskell require more math knowledge than any other programming language?
05:40:58 <vegai_> pedagogically mathematically oriented =)
05:41:16 <vegai_> I meant, haskell tutorials look very much like math literature -- to me, at least
05:42:42 <S-> oic.
05:43:52 <S-> how would you compare haskell to scheme?
05:44:02 <S-> (it's the only other declarative language i know)
05:44:05 <S-> (i think)
05:44:17 <vegai_> don't ask me, I just came here ;P
05:44:22 <S-> hehe.
05:45:38 <kosmikus> I don't know Scheme well, but the major differences are: Scheme is strict (and impure), Scheme has a much less readable syntax, and Scheme is dynamically typed.
05:45:57 <S-> looks more readable to me. :/
05:46:01 <S-> but i don't know haskell.
05:46:11 <S-> just looks like there is more syntax to remember.
05:46:26 <S-> what do you mean by strict and impure?
05:46:28 <vegai_> well, just look at monad syntax and anything is prettier ;-/
05:46:46 <kosmikus> okay, lets start discussing syntax ;)
05:47:00 <kosmikus> first of all, strict and impure, that's easier:
05:47:13 <vegai_> of all the computer languages so far, python has the most elegant one 
05:47:15 * vegai_ ducks.
05:47:39 <kosmikus> if you have a function application, in a strict language, the arguments are evaluated before the function is evaluated
05:47:44 <tic> vegai_, I agree
05:48:02 <kosmikus> in Haskell (as in some other languages), arguments are only evaluated when actually needed
05:48:16 <S-> i see.
05:48:32 <kosmikus> this allows you, among other things, to deal with potentially infinite data structures
05:48:37 <S-> is that for efficiency?
05:48:43 * vegai_ raises his head, wondering why no-one shot at him.
05:48:51 <kosmikus> in Haskell, you can write "take 5 [1..]
05:48:55 <kosmikus> sorry
05:49:06 <kosmikus> in Haskell, you can write "take 5 [1..]" to get [1,2,3,4,5]
05:49:15 <Rafterman> yes
05:49:22 <kosmikus> [1..] denotes an infinite list, but it is never evaluated completely
05:49:37 <vegai_> =) obviously
05:49:41 <S-> is that kind of like a lazy evaluated stream?
05:50:18 <kosmikus> this choice is a philosophic one; I don't think efficiency is a good argument for laziness, as experience shows that it performs worse in most cases, or at least is harder to calculate
05:51:34 <kosmikus> S-: yes, that is similar. Other languages have lazy features within well-defined boundaries. Haskell has it automatically everywhere. In turn, you can force strict evaluation by manual annotation in certain places.
05:51:54 <vegai_> eg. ocaml has class Lazy
05:53:29 <S-> so is defining essentially infinite data structures a common thing in haskell?
05:53:52 <tez> Happens from time to time.
05:53:54 <kosmikus> I don't know, but I do it very often.
05:54:49 <kosmikus> For many of the programs I am writing, I am using an attribute grammar system that makes extensive use of lazy evaluation.
05:55:18 <kosmikus> Instead of computing a visit sequence, lazy evaluation will ensure that attributes are evaluated in the right order.
05:58:00 <kosmikus> impurity is related to lazy/strict evaluation: most strict languages choose to have functions with side effects.
05:58:37 <kosmikus> i.e. I/O is handled by a function like "print :: String -> ()" that takes a string and produces nothing, but performs a side effect that outputs the string
05:58:41 <steveh> apparently that's because laziness helps with efficiency in pure FPLs?
05:59:13 <kosmikus> steveh: how do you mean?
06:00:09 <steveh> i am reading the okasaki book and he is showing how lazy evaluation is essential to have data structures with good amortized efficiency
06:00:39 <steveh> but you know, I think his work comes after the decision to make haskell lazy :)
06:02:20 <steveh> and scheme's syntax is very readable ;)
06:04:00 <kosmikus> yes, but although I agree that laziness might allow some data strcutures with elegant design and nice efficiency properties, I doubt that laziness really wins over strict languages with destructive updates ...
06:04:12 <vegai_> steveh: what do you need? Have you looked at ocaml?
06:04:51 <steveh> vegai_: Right now I don't need anything :)
06:05:05 <S-> scheme syntax is pretty match matching up parens
06:05:08 <S-> can't get much easier than that. :)
06:05:23 <kosmikus> about syntax: I believe that one can get used to Scheme syntax and read it fluently, but it is really surprising to me that it should appear more readable as Haskell to someone with comparable experience in both languages
06:05:39 <kosmikus> easy /= beautiful
06:06:04 <kosmikus> XML isn't beautiful either
06:06:19 <Marvin--> XML is neither easy nor beautiful
06:06:34 <steveh> you said readable, not beautiful :)
06:06:39 <kosmikus> Marvin--: you're right, of course. Scheme is much easier
06:06:52 <steveh> obviously haskell has more attractive syntax
06:07:22 <steveh> but in the same way that Baskerville is more beautiful than Verdana, yet Verdana is more readable ...
06:07:28 <kosmikus> my sentences still express my opinion if you substitute readable for beautiful
06:07:33 <steveh> ok :)
06:08:07 <kosmikus> I agree that the two concepts are different ones, though :)
06:09:18 <vegai_> my definition of 'beautiful' is pretty close to 'easy' -- only for computer languages, of course
06:09:56 <kosmikus> vegai_: why not write in binary then? ;)
06:10:40 <steveh> I like the fact that scheme's order of evaluation is explicit in any piece of scheme code
06:11:18 <steveh> haskell code often uses the default precedence which must be known by the programmer for the code to be well understood
06:11:27 <steveh> IOW: I like the damn parentheses :)
06:11:28 <kosmikus> okay -- I see that this can be an advantage
06:11:47 <steveh> my haskell code has superfluous parentheses
06:12:24 <steveh> i am trying to clean that up of course, though
06:12:26 <steveh> when in rome...
06:12:53 <vegai_> kosmikus: huh? binary is easy?
06:13:04 <kosmikus> of course, without static typing you are much more likely to make programming errors due to misplaced parentheses than in Haskell
06:13:22 <kosmikus> vegai_: you only have two tokens ;)
06:13:43 <kosmikus> ... but I was not at all serious 
06:14:14 <vegai_> yay, ok =)
06:15:07 <steveh> OTOH you don't have to go through typing contortions to adapt code to new situations 
06:15:26 <steveh> but I like the typing in haskell
06:15:45 <steveh> it certainly makes one think clearly about what one is doing
06:16:53 <earthy> which usually helps in the long run
06:18:01 <steveh> plus type inference goes a long way to making development as quick as it would be with dynamic typing
06:20:14 <S-> type inference?
06:20:20 <S-> if you don't include a type it guesses?
06:20:46 <Marvin--> heh, no it doesn't guess, it calculates the most general type
06:22:59 <steveh> yes, it infers :)
06:23:15 <steveh> it might be more general than you intend but it's always correct
06:27:00 <S-> hm.
06:27:07 <S-> so is that any different than int being the implicit type for C?
06:28:23 <steveh> yes
06:30:01 <steveh> with C something can default to being considered "int" without really being an int
06:30:14 <steveh> this is not possible with type inference
07:15:21 <CowGirl> which of the following does not apply to ADTs??   A. the interface is defined by a type signature     B, modularity is improved       C. Decomposition is facilitated      D. information can be hidden     E. the concrete type is not made visible  ?????
07:18:43 <saz> CowGirl: what do you think?
07:20:22 <CowGirl> well i dont think its a, b...not sure about c...., dont think its d...
07:20:30 <CowGirl> e, not sure about either
07:22:30 <CowGirl> dont think its c, e,  not sure of d.
07:23:08 <CowGirl> am i right so far?
07:23:40 <SyntaxPolice> good morning
07:24:12 <Marvin--> morning syntax
07:25:28 <SyntaxPolice> how's it going?
07:26:05 * SyntaxPolice thinks that monk.debian.net is just about fixed up, so we'll maybe get a Haskell Unstable apt source set up :)
07:27:11 <CowGirl> anyone know the answer?
07:27:28 <Marvin--> I'm doing some indexing&querying prototyping
07:27:34 <Marvin--> fun stuff
07:42:19 <CowGirl> anyone?
07:43:12 <saz> CowGirl: well, think about the words concrete, visible and abstract, and see if your answer makes sense
07:44:14 <CowGirl> whats C mean though??
07:44:42 <CowGirl> this is just a past exam paper Q, i have the exam tomorrow..
07:44:50 <saz> do you remember top-down design?
07:45:14 <saz> CowGirl: i know, it looks rather.. familiar
07:45:31 <CowGirl> top-down.....no.
07:45:42 <Rafterman> 1011 or 11711?
07:45:48 <CowGirl> 1011
07:45:48 <Rafterman> 1711 even...
07:45:52 <CowGirl> when did u do the course saz???
07:46:00 <Rafterman> hmm.. not sure if they explicitly cover top down design in 1011
07:46:18 <CowGirl> no, it doesnt ring a bell at all
07:46:53 <CowGirl> this past paper was a 1711 course paper
07:47:07 <CowGirl> but its a past exam paper for 1011 to go over
07:47:11 <saz> Rafterman: but the multiple choice qns were in common
07:47:20 <saz> CowGirl: um, a while ago
07:47:25 <saz> i think that was our paper actually
07:47:30 <Rafterman> saz: yeah, but top-down != ADT design
07:48:16 <saz> hmm
07:48:19 <saz> i guess
07:48:49 <CowGirl> this is 2001 session 1 paper for 1711
08:38:57 <hdaume> g' morning
08:41:26 <SyntaxPolice> hi hdaume :)
08:55:55 <steveh> helloooo haskell
08:56:13 <SyntaxPolice> hihi steveh
08:56:16 <hdaume> hellooooooooooo steveh
08:56:29 * steveh looks at stevehu.
08:56:39 <steveh> Time to terminate with extreme prejudice...
09:03:24 <kunphuzil> Strange, hugs made me change this:
09:03:42 <kunphuzil> then do  putStrLn "Too low!" 
09:03:47 <kunphuzil>       doGuessing num
09:03:50 <kunphuzil> to:
09:04:09 <kunphuzil>  then do
09:04:14 <kunphuzil>         putStrLn "Too low!"
09:04:27 <kunphuzil>      doGuessing num
09:04:34 <kunphuzil> er, spacing is messed up
09:04:58 <kunphuzil> but anyway i had to put it on two lines.. i am copying it just how the tutorial says. maybe they are using GHCi or something
09:05:11 <Riastradh> Spacing being messed up will kill your program.
09:05:17 <Riastradh> ...unless you use the explicit syntax.
09:05:20 <steveh> which tutorial is that?
09:06:14 <kunphuzil> Riastradh: No, spacing messed up when I pasted it, it is fine in the code. i know what you mean
09:06:24 <kunphuzil> steveh: Yet Another Haskell Tutorial by Hal Daume 
09:06:42 * steveh makes the inference that this is hdaume here :)
09:06:55 <kunphuzil> ?
09:07:10 <steveh> in channel at this time
09:07:25 <kunphuzil> ah.. 
09:07:29 <steveh> said hi to me about 10 minutes ago
09:07:29 <kunphuzil> didn't notice.
09:08:01 <kunphuzil> hdaume: in your tutorial, are you using GHCi?
09:11:15 <hdaume> sorry, was afk
09:11:27 <hdaume> kunphuzil: i use both.  you have a spacing issue.  are you using tabs or spaces?
09:11:58 <hdaume> if you put it on two lines, the 'd' must be in the same character position as the 'p'
09:12:06 <hdaume> (i.e., same column)
09:12:13 <kunphuzil> yeah, that is what i did to get it to work
09:12:18 <kunphuzil> i just pasted it wrong in irc
09:13:05 <hdaume> kunphuzil: i mean in the first case (do putStrLn "..."   /    doGuessing ...); the do and putstrln can be on the same line, but you need to make sure the 'd' in 'doGuessing' is in the same column as the 'p' in putstrln
09:13:51 <hdaume> ....then do putStrLn "_"
09:13:51 <hdaume> ............doGuessing _
09:14:00 <kunphuzil> oh, i see
09:14:07 <hdaume> (if you're using a fixed-width font, that will appear correctly)
09:14:22 <kunphuzil> yeah, works now
09:14:30 <hdaume> okay :).  i'll put a note about that.
09:14:37 <kunphuzil> thanks
09:15:08 <hdaume> anyone know if there's been any development on hIDE recently (or haIDE or whatever it's called now)?
09:15:37 <kunphuzil> there is a haskell IDE?
09:15:46 <hdaume> kunphuzil: not yet :)
09:16:11 <kunphuzil> ah. right now i just use haskell-mode for emacs
09:16:18 <hdaume> me too :)
09:16:19 <pesco> If there was, would it be able to cooperate nicely with emacs?
09:16:47 <kunphuzil> it looks like someone just took a marker and wrote over what you said, pesco 
09:16:51 <hdaume> pesco: i would hope so
09:17:09 <pesco> kunphuzil: What?
09:17:33 <Riastradh> pesco, your text is inverted.
09:17:45 <pesco> Ew, sorry, that was not intended.
09:17:51 <kunphuzil> pesco: here i see a black bg for your text on black words. i can still read it tho
09:18:47 <pesco> I haven't set up emacs keys on my irssi properly, so I sometimes get ^F's and ^B's in somewhere.
09:20:35 * steveh wonders what would be in a haskell IDE that wouldn't be doable in emacs...
09:20:56 <steveh> maybe a nifty module browser or something
09:20:59 <hdaume> steveh: a lot :)
09:21:15 <steveh> hdaume: what do you have in mind?
09:22:33 <hdaume> you could get a lot of information from the compiler at various states (type info, strictness info, etc.); you could presumably have some sort of haddock interface; you could have built-in refactoring...i mean, a lot you *could* do in emacs, but (a) people don't know elisp that well and (b) it would involve a lot of shelling out to a compiler/other tools
09:23:10 <steveh> yeah
09:23:17 <hdaume> for instance, writing ghci's :i or :b in elisp would be very hard
09:23:58 <hdaume> also, i believe haIDE will have the same plugin style stuff that lambdabot does, so people can write (in haskell!) plugins
09:24:28 <hdaume> i know that kde has a texteditor pane based on vi...if such a thing existed for emacs, it would be very nice
09:24:50 <steveh> i know xemacs can be embedded somehow
09:25:01 <hdaume> cool : )
09:25:32 <steveh> http://www.cs.indiana.edu/elisp/gui-xemacs/images/embedded-xemacs.jpg
09:25:50 <hdaume> cool
09:25:58 <hdaume> i wonder how well you can control it
09:26:03 <steveh> i think they make it as a gtk widget
09:26:10 <steveh> and it's still in development
09:26:52 <steveh> oh cool
09:27:04 <steveh> you can make gtk widgets from within lisp
09:27:09 <steveh> http://www.cs.indiana.edu/elisp/gui-xemacs/
09:29:21 <steveh> I know haskell-mode has rudimentary interfacing with hugs to get type information
09:29:43 <hdaume> steveh: really?  i thought it just looked at your type signatures
09:29:50 <steveh> no
09:29:57 <steveh> it comes with the prelude built in 
09:30:03 <steveh> and can interface with hugs
09:30:11 <steveh> maybe it looks at explicit signatures too
09:30:29 <steveh> i was glancing at the code a couple days ago
09:30:48 <steveh> but I am a culprit in the "(a) people don't know elisp that well" 
09:30:49 <steveh> :)
09:30:52 <hdaume> erm, where do you see this?
09:32:31 <SyntaxPolice> steveh: are you sure it interfaces w/ hugs? I was under the impressoin that it just looked at your code
09:32:35 <SyntaxPolice> and had the prelude built in
09:32:42 <steveh> haskell-doc.el
09:32:44 <hdaume> i believe SyntaxPolice is correct :)
09:32:57 <steveh> oh nm
09:33:00 <steveh> I misread the comments
09:33:02 <steveh> y'all are right
09:33:03 <steveh> :)
09:33:07 <hdaume> darn
09:33:10 <hdaume> :)
09:34:01 <steveh> ;; The preferred usage of this package is in combination with 
09:34:02 <steveh> ;; `haskell-hugs-mode'. 
09:34:02 <steveh> ;; In that case `haskell-doc-mode' checks an internal variable updated by 
09:34:03 <steveh> ;; `imenu' to access the types of all local functions. In `haskell-mode' this 
09:34:03 <steveh> ;; is not possible. However, types of prelude functions are still shown. 
09:34:03 <steveh> :-P
09:35:59 <steveh> is there a page for this hIDE?
09:36:08 <steveh> or is it still a gleam in #haskell's eye?
09:37:03 <SyntaxPolice> steveh: http://www.dtek.chalmers.se/~d99josve/hide
09:40:54 <steveh> interesante
09:43:44 <steveh> hah, security update done, time to restart...
09:44:58 <SyntaxPolice> isn't there a way to write GUIs in Haskell that uses Java?
09:45:16 <hdaume> SyntaxPolice: yeah, ashley has code to do that
09:45:44 <hdaume> the jdk bindings do it and i believe there's examples
09:46:44 <SyntaxPolice> any pointers?
09:50:47 <hdaume> google.com/search?q=ashley+yakeley+jdk
09:50:49 <hdaume> :)
09:52:17 <SyntaxPolice> thanx
10:22:16 <tims> Has anybody heard of CiteSeer?  It's at: http://citeseer.nj.nec.com/cs  It's a repository of technical articles.  Lots of papers on FP, Haskell, etc.
10:22:38 <hdaume> tims: yeah, it's pretty much a common repository for technical papers
10:22:49 <hdaume> or i guess you just said that :)
10:22:53 * hdaume 's mind isn't here today
10:23:33 <hdaume> it's also just www.researchindex.com
10:24:03 <tims> hdaume : Thanks, I'll check that out.
10:32:27 <Vincenz> Hello
10:34:52 <cale> hi
10:35:11 * Vincenz spams here too
10:35:12 <Vincenz> I'm trying to decide on a linux-distro
10:37:04 <SyntaxPolice> hi Vincenz
10:37:13 <SyntaxPolice> debian rulz
10:37:22 <cale> How familiar are you with unix/linux? I'd recommend debian in general, but if you're new to linux, try something easier to get set up (like RedHat or Mandrake for instance).
10:37:22 * esap also recommends Debian.
10:38:02 <cale> Also, if you have a friend that can help you get set up with it, try Debian.
10:38:27 <SyntaxPolice> along those lines, I usually tell people that the best Linux distro is the one your friends are using.
10:38:30 <Vincenz> what's debian got that mandrake doesn't (besides the registering crap I just noted on their site)
10:38:41 <esap> Debian is easy once you get past the first-time installation.
10:39:19 <SyntaxPolice> and you can bug Marvin-- if debian installer is too hard :-)
10:40:22 <Vincenz> debian installer isn't hard
10:40:27 <SyntaxPolice> Vincenz: two big things, in my mind, make Debian different. 1) the community is very open and cool, and 2) apt is used for installing and updating software, and it is really nice
10:40:40 <Vincenz> does apt take care of dependencies?
10:40:43 <SyntaxPolice> yeah
10:41:12 <SyntaxPolice> if you run "apt-get install hugs", then it'll install the dependancies and install hugs
10:41:41 <andersca> apt exists for red hat too you know
10:42:06 <cale> but it doesn't seem that red hat is built around using apt.
10:42:56 <SyntaxPolice> andersca: yes, I know :)
10:43:19 <cale> I can do apt-get -u dist-upgrade and have all the packages on my system upgraded to the most recent versions, which is nice.
10:43:24 <SyntaxPolice> Vincenz: another example, "apt-cache show hugs|grep Maintainer" will tell you who takes care of a package.  Each package is supposed to have a maintainer, and you can harass them with any problems.
10:43:39 * Vincenz nods
10:43:50 <SyntaxPolice> or more properly, file a bug report directly on the bug database which will get sent to the maintainer
10:43:50 <Vincenz> can you do apt-get uninstall?
10:43:52 <Vincenz> or apt-remove?
10:43:55 <SyntaxPolice> apt-get remove
10:44:07 <Vincenz> I've heard tho that mandrake puts it all nicely into a control center
10:44:25 <Vincenz> only prob is...I went to the site of mandrake, asked for download and asked me if I wanted to register to pay!
10:46:02 <cale> Vincenz: you sure it wasn't optional?
10:46:25 * esap updates all packages about once every two weeks. I can't imagine doing it without apt.
10:46:40 <Vincenz> esap: gentoo has an identical principle
10:46:41 <Vincenz> emerge
10:46:55 <Vincenz> mandrake puts a nice control center around it with extra stuff to config other things
10:47:26 <SyntaxPolice> Vincenz: Debian has three versions, Stable, Testing, and Unstable, with the usual trade-offs among stability and cutting-edgeness.  Three options is nice.  Stable gets security updates frequently which are easy to install.
10:47:56 <andersca> and stable is old as hell
10:48:30 <Vincenz> or should I just stick to the gentoo that is already installed?
10:48:36 <kunphuzil> Gentoo's unstable is pretty new, yet very stable ;)
10:48:45 <andersca> kunphuzil: haha
10:48:46 <andersca> you're funny
10:48:54 <kunphuzil> andersca: ?
10:49:13 <Vincenz> prob is, installing any app requires recompile :/
10:49:13 <Riastradh> Ack, no lambdabot?!
10:49:30 <kunphuzil> andersca: what are you saying? 
10:49:32 <andersca> kunphuzil: just that as a gnome developer I've come across a lot of people who are using gentoo and who have problems 
10:49:39 <kunphuzil> Oh
10:49:43 <kunphuzil> I don't have any .. 
10:50:09 <esap> In debian, it's possible to build from source if you want, but I think I've ever only once or twice done that (to fix a bug in one of the software).
10:50:30 <esap> And it's really easy. apt-get source XXX ; debian/rules binary.
10:50:33 <kunphuzil> esap: Hmm, I never knew that.. 
10:50:46 <andersca> it's just time wasting ;)
10:51:13 <Vincenz> yup
10:51:21 <kunphuzil> Well, I'm not going to argue. I'm fine with gentoo. 
10:51:26 <Vincenz> I think it's faster for me to install debian than add gnome to my gentoo distro
10:51:51 <Vincenz> debian it is
10:52:02 <andersca> yeah
10:52:27 <Vincenz> time to download a minimal iso
10:52:35 <SyntaxPolice> andersca: stable is old, but stable, testing is pretty OK.
10:52:53 <SyntaxPolice> I mean, if I run a web server, which I do, then I want stable, and I don't care how old it is really, as long as there are security updates.
10:53:06 <SyntaxPolice> on my desktop, I run unstable, and its pretty damn stable :)
10:53:08 * cale is reading about O'Haskell and finds the record type and super/sub typing stuff cool.
10:54:17 <cale> I tend to think that the stability refers to how often the packages change on you.
10:54:51 <esap> cale: I think the major point of O'Haskell is the message-passing approach to OO.
10:55:15 <cale> Probably, but I haven't read to that point yet :)
10:56:20 <Vincenz> should I go for stable or testing?
10:57:13 * esap recommends testing.
10:58:58 <cale> at least testing, unstable is also quite nice
10:59:27 <cale> If it's to be your desktop machine, unstable will get really stale after a while.
10:59:56 <cale> (it only gets updated very rarely, so you find yourself wanting new packages)
11:00:09 <esap> cale: you mean stable?
11:00:15 <cale> yes
11:00:21 <cale> sorry
11:01:21 <Marvin--> "unstable will get really stale" hahaha
11:01:30 <cale> unstable gets updated reasonably soon after new versions of the programs come out upstream, testing usually updates a few weeks later
11:01:46 <Vincenz> I'll go for stable for now
11:01:51 <Marvin--> If you want to go for testing, please realize there's no security support for it
11:01:53 <cale> Yeah, sorry about that - I just woke up and haven't had coffee.
11:02:02 <Vincenz> just have to figure out which iso to use
11:02:06 <Vincenz> there's no official one
11:02:16 <Marvin--> use jigdo
11:02:42 <Vincenz> ?
11:04:36 <Marvin--> http://www.debian.org/CD/jigdo-cd/
11:05:22 <Vincenz> thnx
11:07:21 <Vincenz> hmm...that's 7 iso's
11:07:22 <Vincenz> grr
11:07:26 <Vincenz> I just want a netinst iso
11:08:49 <esap> there is a network install thing as well.
11:09:15 <vegai> then there's knoppix
11:09:21 <kunphuzil> hdaume: are you around?
11:09:44 <Vincenz> it's alright, I got sarge-i386.iso it's 80MB
11:09:49 <Vincenz> means my system will be a testing system
11:09:50 <cale> http://www.debian.org/CD/netinst/
11:10:01 <Vincenz> testing have security patches too, right?
11:10:12 <Marvin--> Vincenz: it also means you won't be able to install it, 'cause the new installer is in alpha
11:10:15 <Marvin--> Vincenz: no
11:10:21 <Marvin--> Vincenz: <Marvin--> If you want to go for testing, please realize there's no security support for it
11:10:26 <Vincenz> ah missed that
11:10:51 <cale> packages are generally new enough that security problems will take care of themselves though
11:10:52 <Marvin--> believe me, even if you want sarge, install woody first and then apt-get dist-upgrade
11:11:02 <Marvin--> cale: uh, after two weeks, if you're lucky
11:11:16 <vegai> Vincenz: what software do you need, btw? 
11:11:28 <cale> yeah, I suppose if you're in a jam you could grab the unstable package.
11:11:44 <Vincenz> hmm, devel, desktop, mp3, net, maybe multimedia
11:12:05 <vegai> I guess it is not vital that the software is the newest?
11:12:20 <Vincenz> alright, i'm getting woody
11:12:53 <vegai> if you want the same versions that gentoo has, you need unstable
11:13:28 * Vincenz is downloading at only 330kb
11:13:38 <Marvin--> heck, you need the so-experimental-that-it'll-blow-your-socks-off to keep up with gentoo
11:13:56 <Vincenz> hmm, woody is from sept 2002
11:13:57 <andersca> should have a Debian Broken
11:14:02 <vegai> haha
11:14:03 <andersca> a dist that is always broken
11:14:10 <Marvin--> andersca: well, we do have 'experimental'
11:14:17 <hdaume> kunphuzil: yeah
11:14:22 <andersca> Marvin--: worse than unstable?
11:14:31 <vegai> don't be so hard on the distro, unstable is up to gentoo in terms of software age
11:14:53 <Marvin--> vegai: I'm a Debian developer, I'm not trying to be hard on Debian :)
11:15:11 <Marvin--> andersca: yeah, most developers tend to run unstable, so all hell breaks loose when someone breaks it, so it's fixed rapidly
11:15:28 <Marvin--> andersca: whereas 'experimental' is where people upload random things that they have no idea if they'll work or not
11:15:31 <Vincenz> Marvin--: most developers run unstable?  why?
11:15:41 <Vincenz> I assume stable has ocaml 3.06
11:15:55 <vegai> debian unstable is not that unstable... at least last time I was on that land
11:15:57 <Vincenz> and mzscheme the newest
11:16:22 <vegai> testing has 3.06 also
11:16:53 <Marvin--> Vincenz: because the packages we upload to 'unstable' must be built on 'unstable' systems, and what's the point of having 'unstable' if nobody runs it?
11:17:19 <Riastradh> Is it possible to do:
11:17:21 <Vincenz> I guess
11:17:23 <Riastradh> instance Foo a => [a] where
11:17:24 <Marvin--> vegai: as I said, it's kept mostly sane, because developers notice when it's broken instantly
11:17:26 <Riastradh> Er.
11:17:31 <Riastradh> instance Foo a => Foo [a] where
11:17:34 <Riastradh>     ...
11:17:41 <Marvin--> Riastradh: yes
11:17:41 <Riastradh> instance Foo [SomeOtherTypeWithoutAFooInstance] where
11:17:43 <Riastradh>     ...
11:17:50 <Marvin--> hmm
11:17:53 <Riastradh> Marvin--, you didn't even get to the end of my question.
11:17:57 <Marvin--> Riastradh: sorry :)
11:18:06 * Riastradh awards Marvin-- the jumpiest-to-conclusions person of the week.
11:18:11 <Marvin--> yay!
11:18:16 <Marvin--> wait, is that good or bad?
11:18:39 <Riastradh> Actually, since this weekend is the ICFP contest weekend, it might be a good thing -- you'd get into the lightning division...
11:18:40 <cale> The "unstable" simply means that the packages are new, and so haven't been rigourously tested yet. I've only ever run into one or two cases in the whole time I've used debian when I was unable to upgrade for a little while because it would break a package I needed.
11:18:55 <Marvin--> Riastradh: anyway, I think you'll need overlapping instances for that, since there's no telling where SomeOtherTypeWithoutAFooInstance might instantiate Foo
11:19:03 <cale> (and the problems went away quickly)
11:19:17 <Riastradh> Marvin--, suppose I know that there will never be an instance of SomeOtherTypeWithoutAFooInstance for Foo.
11:20:16 <Marvin--> Riastradh: no, wait, it's illegal for other reasons... "The instance type must be of form (T a b c) where T is not a synonym, and a,b,c are distinct type variables"
11:20:23 <Marvin--> Riastradh: I don't know why, but that's how it is
11:21:02 <Vincenz> I'm booting to linux
11:21:04 <Riastradh> Er, so I can't do 'instance Foo [SomeOtherType] where'?
11:21:04 <Vincenz> see you there
11:21:20 <Marvin--> Riastradh: I guess not
11:21:24 <Riastradh> Argh!
11:21:34 <Marvin--> Riastradh: works with -fglasgow-exts though
11:21:38 <Riastradh> Oh, good.
11:21:47 <Marvin--> Riastradh: but you'll also need -fallow-overlapping-instances
11:22:39 <hdaume> Marvin--: why wouldn't you be able to.  T = [] is not a type synonym
11:22:55 <Marvin--> hdaume: no, but SomeOtherType is not a type variable :)
11:23:03 <hdaume> ah, right
11:23:20 * Marvin-- hands hdaume a cup of coffee
11:23:23 * hdaume has -fallow-overlapping-instance and -fallow-undecidable-instances in his .ghci file anyway
11:23:30 * hdaume is very tired today, for no good reason
11:25:58 <kunphuzil> hdaume: oh, sorry. was away. the code right before Exercise 10 (askForWords) upon not entering anything, is that supposed to return the whole list of things you have entered? because it looks like the list is cleared each time.. 
11:26:20 <hdaume> eek, lemme check :)
11:26:41 <hdaume> what chapter is that in?
11:27:02 <kunphuzil> Ch 3
11:27:22 <hdaume> it does return everything
11:27:38 <kunphuzil> Hmm, doesn't here :/
11:27:54 <hdaume> lemme actually run it :)
11:28:06 <kunphuzil> thanks
11:28:21 <Riastradh> Is it possible with -fglasgow-exts to do:  data Foo = ... | Constructor (forall f. Floating f => f)  -- or something similar?
11:28:48 <hdaume> works for me:
11:28:48 <hdaume> *Main> foo
11:28:49 <hdaume> foo
11:28:49 <hdaume> a
11:28:49 <hdaume> foo
11:28:49 <hdaume> b
11:28:50 <hdaume> foo
11:28:52 <hdaume> c
11:28:54 <hdaume> foo
11:28:56 <hdaume> *Main> it
11:28:58 <hdaume> ["a","b","c"]
11:29:00 <hdaume> *Main> 
11:29:02 <hdaume> (sorry for the flood)
11:29:04 <hdaume> (i called it foo instead of askForWords)
11:29:18 <kunphuzil> hmm, i'll try it in GHCi
11:29:34 <hdaume> there's no reason it wouldn't work in hugs
11:30:14 <kunphuzil> *Main> askForWords 
11:30:14 <kunphuzil> Enter a word: 
11:30:14 <kunphuzil> test
11:30:14 <kunphuzil> Enter a word: 
11:30:14 <kunphuzil> word
11:30:16 <kunphuzil> Enter a word: 
11:30:19 <kunphuzil> *Main> 
11:30:42 <kunphuzil> :/ i wonder what i am doing wrong
11:30:50 <andersca> prolly gentoo
11:30:50 <hdaume> yes, because the result is an IO action which you have to run to get the result out.  in ghci you can do that by typing 'it'.  in hugs there's soemthing like that
11:30:53 * andersca RUNS
11:31:01 <hdaume> do :
11:31:09 <Marvin--> Riastradh: rank-2 polymorphism? yeah
11:31:12 <hdaume> askForWords >>= print
11:31:27 <Riastradh> Marvin--, I was referring more to the '=> f' bit.
11:31:42 <hdaume> or define 'f = do v <- askForWords /    print v' and run 'f'
11:31:51 <Marvin--> Riastradh: well, you can't do it without the forall, so...
11:31:53 <kunphuzil> hdaume: hmm, maybe you should tell that in the tutorial? 
11:31:58 <hdaume> kunphuzil: okay
11:32:03 <kunphuzil> thanks
11:32:16 <hdaume> it's like how if you evaluate 'putStrLn "foo"', it doesn't echo the () return value
11:32:30 <Riastradh> Marvin--, but it's legal to just have 'f' after the arrow?
11:32:43 <Marvin--> Riastradh: sure, why not?
11:32:46 <hdaume> Riastradh: yeah, that's fine
11:32:51 <hdaume> (but i'm tired, so don't trust me ;))
11:34:19 <Marvin--> hdaume: I think we've all understood that by now ;-)
11:34:51 <hdaume> :)
11:34:53 <Riastradh> hdaume, are you tired or something?  You've made lots of silly remarks rather seriously lately..
11:34:56 <Riastradh> .
11:35:43 <hdaume> Riastradh: a bit :)
11:35:57 * hdaume should just take a nap :)
11:36:25 <kunphuzil> Oh my, hdaume is at microsoft?
11:36:32 <hdaume> kunphuzil: just for the summer
11:36:39 <Riastradh> SPJ works at Microsoft, too.
11:36:48 <Riastradh> 'Tis very unfortunate, but it gets Haskell gobs of dough.
11:36:54 <hdaume> Riastradh: i'm in redmond though... he's in cambridge
11:36:59 <kunphuzil> i heard something about someone working at microsoft.. :p
11:37:07 <Riastradh> hdaume, which Cambridge?
11:37:13 <Marvin--> Redmond sounds a lot scarier than Cambridge :)
11:37:13 <Heffalump> *the* Cambridge.
11:37:30 <Riastradh> The one with a bridge over the river Cam?
11:37:48 <Heffalump> indeed.
11:37:54 <Heffalump> several bridges, indeed.
11:38:09 <Marvin--> so it should be Cambridges instead? :)
11:38:15 <Riastradh> Darn.  I'm often around the ripoff Cambridge, but not exactly very often around the original Cambridge.
11:38:50 <Heffalump> there may only have been one when it was named :-)
11:39:08 <Marvin--> tsk, so the name is outdated
11:39:45 <Riastradh> Hmm...how does one convert from Int to Integer and vice versa?
11:39:48 <Igloo> Hey, our favourite language's name is 5 years old too  :-)
11:39:50 <Heffalump> I doubt Oxen ford the river at Oxford any more, either
11:39:52 <Igloo> fromIntegral
11:40:02 <Heffalump> not only that, the bloke who gave rise to the name is dead.
11:40:24 <Riastradh> Igloo, fromIntegral for both?
11:40:57 * andersca reads about polymorphic functions in C#
11:41:12 <Igloo> Yeah, or from/toInteger if you prefer
11:41:34 <Marvin--> fromIntegral is heavily overloaded :)
11:41:48 <Igloo> I imagine it gets specialised, though
11:41:51 * hdaume is going out for a bit...maybe he'll be remotely intelligent when he returns
11:41:55 <cale> Heffalump: you sure about that? Maybe the oxen are just very small now, so you can't see them very well.
11:42:44 <Heffalump> Oxen are quite big beasts.
11:43:02 <Marvin--> maybe they're japanese miniature-oxen
11:43:08 <cale> Yeah
11:43:10 <andersca> bonsai oxen
11:43:46 <cale> The wonders of miniaturization!
11:43:58 * Marvin-- is going to reboot to that other OS and play some War3
12:34:23 <Riastradh> Is there an arithmetic shift function in (Haskell 98|GHC|something else)?
12:35:38 <tmoertel> Riastradh: see Data.Bits: http://www.haskell.org/ghc/docs/latest/html/base/Data.Bits.html
13:04:01 * hdaume is back
13:07:24 <Heffalump> 'lo
13:10:47 * Marvin-- grumbles
13:11:04 <Marvin--> stupid people wanting to replace perfectly working, simple code with something complicated just because it's got better complexity
13:11:18 <jlouis> whom?
13:11:23 <hdaume> ME!
13:11:24 <hdaume> :)
13:11:39 <Marvin--> oh, just a bit of a fight on #debian-boot
13:12:00 <jlouis> boot? that is easy. There is only one true way of bootstrapping a UNIX
13:12:10 <Marvin--> I just don't see the point of replacing O(N^2) code with O(N) code when N < 100 and memory is a bigger issue than speed
13:12:26 <hdaume> hehe
13:12:36 <jlouis> ''Dont bother optimizing when N is small, and N usually is''
13:12:43 <Marvin--> exactly
13:12:49 <hdaume> for some definition of "usually" :)
13:13:00 <jlouis> hehe
13:13:09 <jlouis> But it is partly true
13:13:13 <hdaume> certainly
13:13:24 <hdaume> i'd say 96.2% of the time it's not worth optimizing
13:13:35 <hdaume> but that extra 3.8%.  man.  if you don't optimize.  man.
13:13:38 <jlouis> and booting a unix is best done by booting the kernel and executing an SH script...
13:13:44 <steveh> it really depends on how many times you plan on calling that O(N^2) code ;)
13:17:38 <Marvin--> hdaume: funny figures, 96.2%
13:55:17 <kosmikus> today I've tried to read "Theory of Patches" seriously ... 
13:57:11 <hdaume> kosmikus: what is that?
13:58:13 <Heffalump> the darcs stuff?
13:59:01 <kosmikus> yes
13:59:27 <kosmikus> however, I have a hard time understanding it -- can anyone else here help me?
14:01:38 <Heffalump> I thought it made sense to me when I read it, but I need to go home now - back in 30 mins or so
14:02:02 <kosmikus> maybe I'm still here then ... I don't know yet
14:02:32 <kosmikus> it seems a bit too vague to me at places -- I guess I just need a push in the right direction
14:03:43 * Marvin-- wonders since when it's popular to use negative criticism to promote TV shows
14:07:30 <kosmikus> hdaume: do you know darcs?
14:09:09 <hdaume> kosmikus: nope
14:09:41 <hdaume> it's like cvs though, right?
14:09:52 <kosmikus> yes, and written in Haskell :)
14:24:56 <kl4rk> sorry for asking such a stupid thing but i need it alot, how do i put a newline in a string? tried ++ "\n" but that won't work
14:25:50 <Igloo> Err, that's how you do it
14:26:03 <kl4rk> damn
14:26:05 <Riastradh> How are you using ++ "\n"?
14:26:44 <kl4rk> main2 = "asdf" ++ "\n"
14:26:55 <Igloo> Oh, you actually have to print it for it to look like a newline, though
14:27:02 <kl4rk> ah
14:27:02 <Igloo> i.e. use something like putStr
14:27:15 <kl4rk> okay, thanks a lot
14:27:21 <Riastradh> putStrLn automatically inserts a newline, I think.
14:27:28 <Riastradh> e.g.:   main = putStrLn "asdf"
14:27:34 <Riastradh> instead of:   main = putStr "asdf\n"
14:27:42 <kl4rk> thanks a lot
14:28:21 <kl4rk> yeah works perfectly now
14:28:29 * Riastradh has an idea for a way to manipulate handles and sockets.
14:29:55 * Heffalump appears
14:30:03 <Riastradh> Does anyone want to hear it?
14:30:27 <Igloo> Depends exactly what you mean, but probably  :-)
14:30:36 <Riastradh> OK.
14:30:50 <Riastradh> At the very heart of this will be ordinary handles and sockets as defined by Haskell 98 and GHC's network stuff.
14:31:52 <Riastradh> There will be three typeclasses introduced, HandleAbs, ClientSocketAbs, and ServerSocketAbs -- maybe more.
14:32:01 <Riastradh> 'Abs' here stands for 'Abstraction.'
14:32:24 <Riastradh> class HandleAbs h a | h -> a where   -- this uses multiparametre type classes and fundeps
14:32:32 <Riastradh>     abstract :: HandleAbs h' a' => h' -> h
14:32:40 <Riastradh>     hlPut :: h -> a -> IO ()
14:32:44 <Riastradh>     hlGet :: h -> IO a
14:32:52 <Igloo> What's the difference between Client and Server?
14:33:08 <Igloo> And what problem are you trying to solve?
14:33:11 <Riastradh> Um, one of them is for client sockets and the other is for server sockets.
14:33:28 <Igloo> Do you mean one started off life as a listen and one as a connect?
14:33:38 <Riastradh> Yes, sort of.
14:33:43 * Igloo doesn't really see the relevence
14:33:44 <Riastradh> Let me describe HandleAbs first.
14:33:52 <Igloo> And I don't think it makes sense for UDP either
14:33:55 <Igloo> OK
14:34:04 <Riastradh> OK, so there'll probably be another thing for UDP.
14:34:51 <Riastradh> 'abstract' produces an abstraction over another handle, which may itself be an abstraction.
14:35:00 <Riastradh> (there should probably be a better name for that)
14:35:15 <Igloo> Is abstract's type legal incidentally (not mentioning a)?
14:35:17 * hdaume doesn't see how 'abstract' would be implemented
14:35:26 <hdaume> Igloo: h -> a
14:35:40 <Riastradh> Er, I'm not sure.
14:35:42 <hdaume> (i.e., determines, not function arrow)
14:36:07 <Igloo> OK, that makes sense but I wasn't sure
14:36:08 <hdaume> the type is legal, but i think it's impossible to implement unless you have a closed set of instances
14:36:23 <Riastradh> Suppose you wanted to have a handle that would put 'Hello, World! ' before every string sent.
14:36:35 <Riastradh> And prepend 'Goodbye, World! ' to every string received.
14:36:39 <Riastradh> You might do:
14:36:48 <hdaume> okay, i see that
14:36:51 <Riastradh> newtype HelloHandle = HelloHandle ()
14:37:50 <Riastradh> instance HandleAbs h String => HandleAbs HelloHandle String where -- er, can you require a to be String in the context?
14:37:56 <Riastradh> Er, oops.
14:38:19 <Riastradh> newtype HelloHandle = forall h. HandleAbs h String => HelloHandle h
14:38:21 <Riastradh> ...something like that.
14:38:36 <Riastradh> instance HandleAbs h String => HandleAbs HelloHandle String where
14:38:46 <Riastradh>     abstract = HelloHandle
14:39:00 <Riastradh>     hlPut handle str = hlPut handle ("Hello, World! " ++ str)
14:39:12 <Riastradh> Er.
14:39:22 <Riastradh>     hlPut (HelloHandle handle) str = hlPut handle ("Hello, World! " ++ str)
14:39:23 <hdaume> i think you're going to have a problem with the as....because you don't know that the 'a' associated with 'h'' is the same as the one associated with 'h'
14:39:39 <hdaume> (unless you specify it directly in the instance, as you did in that example)
14:39:53 <Riastradh>     hlGet (HelloHandle h) = hlGet h >>= \str -> return ("Hello, World! " ++ str)
14:40:24 <Riastradh> It needn't be the same.
14:40:35 <Riastradh> Oh, I see what you're saying.
14:40:49 <hdaume> but unless you know the type of handle you're wrapping, you won't be able to do anything
14:41:37 <Riastradh> Is it possible to do:   instance HandleAbs h String => HandleAbs HelloHandle String where   -- i.e., ensure that a is String here?
14:41:47 <hdaume> ...and i'm not sure, but i don't think that type sig is valid...
14:42:02 <hdaume> because the rhs of the => doesn't contain the type variable on the left
14:42:15 <Riastradh> Er, oh, duh.
14:42:23 <hdaume> you're also claiming that the method is valid "for *all* h", not just the one you've specified on the LHS of the instance decl
14:42:26 <Riastradh> newtype HelloHandle h = HelloHandle h
14:42:28 <hdaume> clearly it isn't :)
14:42:41 <Riastradh> instance HandleAbs h String => HandleAbs (HelloHandle h) String where
14:42:53 <hdaume> still you won't be able to write abstract
14:43:05 <hdaume> because the 'h' in abstract is *not* the 'h' in the instance declaration
14:43:07 <Riastradh> Why not?
14:43:25 <Riastradh> Er, it isn't?
14:44:19 <Igloo> Did I miss the need for a Client/Server distinction?
14:44:39 <hdaume> simplify.  do:
14:44:41 <Riastradh> Igloo, the client one would have a 'connect' method and the server one would take a third parametre and have 'listen' and 'accept'.
14:44:43 <hdaume> class Foo a b | a -> b where { foo :: Foo a' b' => a' -> a }
14:44:43 <hdaume> newtype Bar a = Bar a
14:44:59 <hdaume> write me an instance of Foo on Bar which gets past the typechecker and i'll give you $US10 :)
14:45:14 <Igloo> Ria: I think they should be 2 functions both returning NetworkHandles, though
14:45:18 <hdaume> (by instance i obviously mean one with the intended functionality)
14:47:15 <Igloo> This feels like it should be a job for O'haskell
14:47:35 <hdaume> Igloo: i agree.  this is basically subtyping, right?
14:47:43 <Riastradh> hdaume, but, er, what is 'foo' supposed to do?
14:47:49 <Riastradh> No, it's not really subtyping.
14:49:20 <hdaume> the same thing abstract is supposed to do
15:00:33 <Riastradh> Argh.
15:00:45 <Riastradh> I guess I can't put actual types in the context.
15:01:19 <hdaume> i don't think you can when using them in fundeps unless they are on the lhs of the dependency (though i could be really wrong here)
15:02:34 * Riastradh sort of sees now after thinking about it how this could sort of be subtyping.
15:09:04 * Riastradh was hoping it could be done just by layering abstractions over and over.
15:09:30 <Riastradh> Well, I guess subtyping sort of is that.
15:09:32 <hdaume> i think it can; just not with those type signatures :)
15:09:50 <Riastradh> OK, can you think of better type signatures? -- do you get what I'm trying to do?
15:10:54 <Igloo> You could have both 'a's in the type at the expense of abstraction
15:11:24 <Riastradh> ...er...but the idea is to make -use- of abstraction, not lose abstraction.
15:11:32 <Igloo> Or you could have both 'a's the same in abstract and have separate functions to convert
15:11:35 <hdaume> Riastradh: probably.  i'm too tired to do anything *con*structive right now, though
15:12:04 * Igloo is in the middle of something else so can't think about it properly now either
15:12:09 <Riastradh> Blah.
15:13:05 * Riastradh is reading about O'Haskell and doesn't like the fact that it gets rid of type classes.
15:13:33 <Igloo> I've never looked at it, it just sounds like what it should be good for  :-)
15:14:19 <Riastradh> Subtyping (or as it really is, 'supertyping') algebraic datatypes is weird.
15:14:22 <Riastradh> data BW = Black | White
15:14:32 <Riastradh> data Colour > BW = Red | Orange | Yellow | Green | Blue | Violet
15:33:38 * esap doesn't think supertyping is at all weird. It's just dual of subtyping.
15:34:39 * esap might confuse duality with inverses though.
15:37:09 * Riastradh doesn't like what he has seen of O'Haskell so far.
15:37:27 <esap> what is the problem?
15:38:10 <Riastradh> It looks to me like it's just syntactic sugar over pretend imperative stuff to make it look like it really is imperative.
15:38:24 <Riastradh> OK, the struct stuff I don't find that bad.
15:38:40 <Riastradh> But in the documentation, from templates down, I don't really like it.
15:40:16 <esap> I thought it was a bit too restricted. It didn't capture the fundamental OO design principles correctly (say, layering).
15:40:31 <Riastradh> Well.
15:40:45 <Riastradh> The term 'OO' is too ill-defined for there to be many 'fundamental design principles thereof.'
15:41:28 <esap> Sure, but I'm specifically objecting to the metaphor from the Templates and methods chapter: "we will also use the metaphor sending a message as a synonym for invoking a method")
15:42:33 <Riastradh> What's wrong with that?
15:42:59 <esap> sending a message is more like destroying an object.
15:43:17 <Riastradh> Er...how so?
15:43:48 <esap> The idea is that when you send a message, you have to convert it to very low level representation. This is essentially also what destroying an object does.
15:44:26 <esap> It removes all the abstraction layers.
15:44:41 * Riastradh doesn't get this.
15:45:12 <esap> It all relates to how I view OO and how I build a mapping between FP and OO concepts.
15:45:41 <Riastradh> I don't get this 'low level representation' or 'destroying an object.'
15:45:56 <cale> I think that the struct stuff and super/sub-typing is actually pretty cool looking. It seems to take some stuff that's currently somewhat tricky and make it easy. Removing the concept of typeclasses wholesale does seem like it might be a bit much though.
15:46:10 <esap> A low level representation is just a collection of bytes, without a specific interpretation.
15:47:34 <esap> like you would represent something as 'String' data format. That is what you need to be able to send a message. Now destroying an object takes a fully constructed and working object, and turns it into this kind of collection of bytes.
15:48:02 <esap> Ideally, you would then be able to use those bytes to construct another object from that data.
15:48:21 * Riastradh is really confused, so he goes back to fibbling with his handle and socket abstraction stuff.
15:48:58 <esap> So, sending a message would be: 1) you would destroy an existing object [with state], getting a low-level representation from it. 2) you send it though the network 3) the receiving end _constructs_ an object from those bytes.
15:50:32 <cale> esap: is that generally a safe thing to do? Wouldn't it be more appropriate to serialize the objects more explicitly?
15:51:10 <esap> cale: what I'm saying is that destroying an object is the same as serializing it.
15:51:23 <esap> cale: the object should no longer exist after that.
15:51:34 * Riastradh is -REALLY- confused now.
15:52:44 <esap> The point is, if you serialize an object, you don't want to leave the existing object live.
15:52:48 <cale> Well, sure, but if you're allowed to take those bytes and cast them back into an object, that doesn't particularly feel type-safe.
15:53:06 <Riastradh> What does this have to do with message-passing OOP?
15:53:12 <esap> cale: you don't "cast". You will parse it, signalling an error if those bytes are not valid.
15:53:50 <hdaume> Riastradh & esap: i think you two are thinking of two different meanings of "message"
15:53:50 <esap> riastradh: well message passing does send messages :-) This is a model of how to send messages.
15:54:02 <hdaume> ...or not :)
15:54:16 <Riastradh> I'm not talking about how to send messages over a network or anything...
15:54:36 <esap> riastradh: but OOP built on message passing does use the same model.
15:54:52 <Riastradh> It does?
15:55:15 <esap> riastradh: Well that is my understanding.
15:55:33 <cale> you'd have to be really careful about unique representations of objects in memory then - you wouldn't want to be able to accidentally parse an object of a different type successfully just because it was the same length, say.
15:55:35 <Riastradh> In all my experience with Smalltalk hacking, with Objective-C runtime hacking, and with Scheme object system designing, I have never run into serializing objects or selectors or anything.
15:56:46 <Riastradh> Er, when sending messages, that is.
15:57:16 <esap> riastradh: maybe that part is handled behind the scenes and not visible? [Well I don't really know smalltalk that well].
15:57:30 <Riastradh> Now, when sending messages to other threads or to objects on other machines, say, with Cocoa's Distributed Objects things, then yes, stuff would be serialized.
15:57:41 <kosmikus> I'm more with Riastradh, I think. Message passing OOP is about sending messages *to* objects, as opposed to sending objects as messages.
15:59:06 <esap> My model includes that as well (but I call them methods and not messages).
15:59:27 <Riastradh> But even with Distributed Objects, the object to which the message is sent isn't serialized -- there are just ghost objects that you're sending messages to, that serialize the message and the arguments thereof, send them off to the real object (over the threads or over the network or whatever), and then receiving a serialized result and unserializing that.
15:59:27 <cale> kosmikus: That's how I generally viewed it, though I suppose that one could treat messages as objects, just taking their bits and firing them across the network feels dangerous, if possible.
16:00:27 <esap> riastradh: no, the operation that the message sending in my model does is it _transfers_ an object from one place to another.
16:00:37 <Riastradh> Why?
16:00:57 <Riastradh> It seems like it would be easier to just transfer the message and the arguments thereto.
16:01:01 <esap> riastradh: Maybe your clients will expect it to be somewhere else.
16:01:08 <Riastradh> ?
16:01:51 <esap> The thing is, when you communicate with an object, you have to first find it somewhere. If it doesn't happen to be located in the same place that the clients will expect it, then those clients do not find it.
16:02:25 <esap> An object is always located in some one place. Sometimes that place changes during the lifetime of the object.
16:02:54 <esap> Of course, if you know where the object is, then you can send requests and receive replies from it.
16:03:17 <cale> What if that object's representation in memory involves pointers to other things on that machine? Do you pack them up along with it and rewrite the pointers? Do you need some sort of a linker?
16:03:20 <esap> The movement of the objects needs to occur if your objects are _very_ long lived.
16:03:45 <esap> cale: of course, you have to have a way to serialize references to objects.
16:03:50 <Riastradh> Er, are you referring to the object's position in a machine's memory/registers?
16:04:06 <esap> riastradh: well you might store those objects in a database.
16:04:43 <esap> riastradh: or it might be in memory, or it might be somewhere else. The point is, it is not necessarily obvious to clients where to find it.
16:05:53 <esap> riastradh: and you might have some administrator moving data between two databases or something. The OO system must cope with it.
16:06:26 <cale> esap: What do you do with unevaluated closures that an object might contain?
16:06:27 <esap> riastradh: well normally, of course, objects do not move.
16:06:28 <Riastradh> I'm really confused again.
16:07:02 <esap> cale: you have to have some way of serializing those, of course.
16:08:11 <esap> riastradh: you can use "object location services" or something to keep track of where the object is located. CORBA, for example, provides those.
16:09:14 <Riastradh> Er, what makes this specific to OOP? -- you're going to have to deal with this stuff for -ANY- values.
16:09:33 <cale> It seems really complicated to serialize those in a way that ensures that they will be readable on some arbitrary other machine.
16:10:36 <esap> riastradh: of course. The problem is, OO encapulates data in the objects. This makes it more difficult to deal with things like this. The solution is to understand how OO and sending messages interact.
16:11:05 <esap> riastradh: And this includes sending "any" data in the system from one place to another.
16:11:30 <esap> including the data encapsulated in the objects.
16:11:51 <cale> I suppose though, that if you could ensure that the machines were architecture-compatible, then it wouldn't be so bad.
16:12:17 * Riastradh is no less confused and really goes off to fibble with his abstracted handle stuff.
16:12:20 <esap> To send data, you must have some common representation between the two parts of the system. You can't get away with it.
16:13:41 <esap> This seems at first that OO and sending data does not interoperate at all. But that is not true.
16:14:32 <esap> You can either keep the object at a single location (and only send requests to the object), or move the object itself. Both are equally valid.
16:14:47 <esap> And both require some support from the OO system.
16:15:44 <esap> Moving object is harder since it usually invalidates all references.
16:16:12 <esap> So references to objects need to support the moving for it to work.
16:17:10 <esap> That is, clients might be impacted.
16:18:58 <esap> The point was, destroying an object is really part of moving an object from one location to another.
16:24:55 <cale> esap: One thing that I think was confusing me there was that I was reading "destroying" as "freeing the memory of" early on in the discussion.
16:26:43 <esap> cale: yea, it's not the same thing. To me, destroying has nothing to do with releasing resources. It just cleans up and strips the encapsulation, so that the state of the object can be directly accessed [of course, the constraints the the object held are no longer valid after that]
16:28:13 <esap> cale: To me, the "object" itself is just a kind of layer of encapsulation that hides the state of the object + the interface.
16:28:49 <cale> but yeah, I think I can see how transmitting objects would be possible if complicated, but I'm not sure when it would be particularly advantageous to do so, especially as you're going to incur a good hit of overhead for doing so.
16:29:34 <esap> cale: well it depends on how often you need to do that. If you need to send 1 million method invocations to that object, it might be better to have the object close to the client.
16:29:37 <cale> (you might even have to use interpreted bytecode rather than native machine code for portable objects)
16:29:51 <cale> yeah, I suppose that's true
16:31:00 <esap> Of course, the overhead of method invocations is not very significant unless made across network or something.
16:31:20 <esap> Or if you cannot keep all the objects in memory (i.e. have to store it to the database).
16:33:40 <cale> It might actually be interesting to see this put to use in something like X, where it would be nice if the server could at least do part of the computation for things that needed to be highly responsive.
16:34:11 <esap> True.
17:15:42 <Pseudonym> @yow
17:15:42 <lambdabot> Just to have MORE FUN, I'll pretend I am JAMES CAGNEY and I am having
17:15:42 <lambdabot>  a tense, UP-TIGHT EXPERIENCE!!
17:16:03 * shapr drops in a for few moments
17:16:07 <Pseudonym> G'day.
17:16:15 * Pseudonym is proposing a language extension
17:16:28 <shapr> g'day Pseudonym 
17:16:44 <Riastradh> Ooh, ooh, I wanna hear!
17:16:50 <Pseudonym> It's very simple.
17:17:01 <Pseudonym> At the moment, you can specify types like this:
17:17:04 <Riastradh> Then explain it!
17:17:07 <Pseudonym> foo :: !Int -> Int -> Int
17:17:18 <Pseudonym> The ! means that the first argument to foo is strict.
17:17:18 <Riastradh> The ! makes it eager, right?
17:17:24 <Pseudonym> Right.
17:17:36 <Pseudonym> And implementations can choose to evaluate that argument before foo is called.
17:17:51 <Pseudonym> And perhaps call a special version of foo which _assumes_ that it's evaluated.
17:18:12 <Pseudonym> My proposal is to introduce a new kind of !.
17:18:16 <Pseudonym> foo :: ~Int -> Int -> Int
17:18:20 <Pseudonym> I just pulled ~ out of the air.
17:18:40 <Pseudonym> What this means is that the first argument of foo is never even looked at.
17:18:43 <shapr> I would think a question mark would be opposite, but that's just out of my air
17:18:47 <Igloo> ! can't be used like that in H 98
17:18:55 <Pseudonym> Igloo: I know.
17:19:04 <Pseudonym> But this is a language extension proposal, not a H98 proposal. :-)
17:19:07 <Riastradh> Er...never looked at?
17:19:10 <Pseudonym> Right.
17:19:15 * Igloo doesn't follow that either
17:19:17 <Pseudonym> So implementations can choose not to pass it.
17:19:17 <Riastradh> Even when foo uses that argument?
17:19:28 <Riastradh> What's the point?
17:19:29 <Igloo> But that can be inferred
17:19:30 <Pseudonym> No, it's an assertion that foo _doesn't_ use that argument.
17:19:35 <Pseudonym> Igloo: Not always.
17:19:40 <Riastradh> OH!
17:19:43 <Riastradh> In the traits thing!
17:19:45 <Riastradh> I get it!
17:19:47 <Pseudonym> Rioght.
17:19:51 <Riastradh> And then you pass any value to it.
17:19:55 <Riastradh> ...or something.
17:19:58 <Igloo> traits?
17:20:00 <Pseudonym> It can't be inferred, for example, in type classes.
17:20:04 <Riastradh> @fact traits
17:20:05 <lambdabot> Nothing
17:20:16 <Pseudonym> Where you call a type class method, but all _instances_ ignore the argument.
17:20:23 <Riastradh> http://www.haskell.org/hawiki/TraitsTypeclass
17:20:23 <Pseudonym> http://haskell.org/hawiki/TraitsTypeclass
17:20:27 <Pseudonym> Right. :-)
17:20:28 <Igloo> You don't give type signatures to instances if that's what you mean
17:20:32 <Igloo> s/don't/can't/
17:20:43 <Pseudonym> Right, so I want to declare this property in the class.
17:20:50 <Riastradh> class FloatTraits a where
17:20:56 <Riastradh>     mantissaDigits :: ~a -> Int
17:21:01 <Pseudonym> Exactly.
17:21:03 <Igloo> Oh, like Bounded, I see
17:21:13 <Pseudonym> mantissaDigits doesn't consult the value you pass it at all.
17:21:20 <Pseudonym> No matter what type a is.
17:21:37 <Pseudonym> But you can't infer this because you can't inspect all instances of FloatTraits.
17:22:01 <Pseudonym> The only tricky part is that this isn't an advisory declaration.  It has to be statically checked.
17:22:09 <Pseudonym> But the analysis is very simple.
17:22:22 <Igloo> Would it not be nicer to be able to indicate what instance you want to use some other way?
17:22:30 <Pseudonym> Yes it would.
17:22:37 <Pseudonym> Can you think of a way of doing this?
17:22:42 <Igloo> Maybe have an explicit optional dictionary passing operator
17:22:45 <Riastradh> This sounds like a job for...
17:22:47 <Riastradh> Template Haskell!
17:22:50 <Riastradh> <insert fanfare here>
17:23:05 <Pseudonym> Riastradh: Possibly, but I can think of situations where you want to resolve this at run time.
17:23:10 <Igloo> Or allow some way of specifying it as something like a type signature but a bit different
17:23:14 <Pseudonym> FloatTraits is just a simple example.
17:23:26 <Pseudonym> Igloo: The thing I want to avoid is Mercury-like mode declarations.
17:23:37 <Pseudonym> One signature per function is enough.
17:23:44 <Riastradh> $(trait "mantissaDigits" "Float")
17:24:05 <Pseudonym> Riastradh: Like I said, sometimes you want to resolve this at run time.
17:24:18 <Riastradh> Pseudonym, yeah, I heard you.
17:24:18 <Pseudonym> For example, an l10n'd application where you change locales.
17:24:30 <Riastradh> This sounds like a job for another Haskell extension.
17:24:34 <Riastradh> l10n'd?
17:24:41 <Riastradh> You mean i18n'd?
17:24:50 <shapr> localization?
17:24:51 <Pseudonym> i18n == internationalisation, l10n == localisation
17:24:52 <Riastradh> Or does l10n'd mean something different?
17:24:59 <Riastradh> Oh, ok.
17:25:11 <Pseudonym> What do you think?  Is this a good idea/.
17:25:12 <Pseudonym> ?
17:25:17 <Riastradh> Yes!
17:25:23 * Riastradh is enthusiastic tonight.
17:25:26 <Pseudonym> I think this is the minimal extension required.
17:25:34 <Riastradh> Probably due to excessive quantities of capsaicin.
17:25:38 <Riastradh> ...consumed earlier tonight.
17:25:48 * Pseudonym won't ask
17:26:15 <cale> Habanero peppers?
17:26:20 <Riastradh> I think there should be two extensions.
17:26:35 <Riastradh> cale, yes, though not limited thereto.
17:26:43 <shapr> I want a telescoping extension.
17:26:58 <Riastradh> I want two extensions for this, actually.
17:27:00 <cale> Excellent :)
17:27:09 <Riastradh> The ~ thing and a 'trait' syntax.
17:27:11 <Pseudonym> Actually, my inbox tells me of all sorts of extensions that I can get.
17:27:27 <Riastradh> trait TypeName traitName
17:27:31 <shapr> hair extensions?
17:27:55 <Pseudonym> Deadline extensions.
17:27:55 <Pseudonym> Now THERE would be a good language feature.
17:27:56 <cale> shapr: probably something like that :)
17:28:30 <shapr> Pseudonym: yes, that would be something worth building into any language.
17:28:34 <Pseudonym> Riastradh: What is this trait syntax for?
17:28:42 <cale> Procrastilog - the logic procrastination language
17:28:44 <Pseudonym> That can't be done using the typeclass technique?
17:28:57 <Pseudonym> Or can't be done elegantly?
17:29:00 <shapr> procrastination is illogical
17:29:22 <Pseudonym> shapr: You're an ML programmer in disguise, aren't you.
17:29:25 <Riastradh> Pseudonym - So you don't have to do:   traitName (undefined :: TypeName), which in my opinion is really ugly.
17:29:31 <shapr> uh oh
17:29:46 <Pseudonym> Persecute!  Kill the heretic!  He doesn't believe in laziness!
17:29:48 <shapr> that's like mistyping :wq in #emacs
17:30:20 <cale> heh, I'll have to try that sometime :)
17:30:25 <Pseudonym> Riastradh: The thing is, you only have to do that once.
17:30:33 <Riastradh> Pseudonym, ?
17:30:38 <Pseudonym> Take the language example from the TraitsTypeclass page, for example.
17:30:42 <shapr> cale: see the IrcChannelQuotes on emacswiki.org, I already did it :-)
17:30:51 <Pseudonym> You only need to pass the language parameter explicitly at the _top_ level.
17:30:58 <Pseudonym> The rest of the time, you just pass around a variable.
17:31:20 <shapr> cale: http://emacswiki.org/cgi-bin/wiki.pl/EmacsChannelQuotes
17:31:21 <Pseudonym> So in real programs (and yes, the technique was motivated by a real program), the ugliness is pretty contained.
17:32:24 <shapr> "All power is derived from the barrel of a Gnu." - Mao Tse Stallman
17:33:37 <Riastradh> I don't get it.
17:33:51 <Riastradh> The last example isn't what I'm talking about.
17:34:37 <Riastradh> I'm referring to, for example, the mantissaDigits thing.
17:34:41 <Pseudonym> Right.
17:34:48 <Pseudonym> Which, IMO, is just a motivating example.
17:34:53 <Riastradh> You'd have to do:   mantissaDigits (undefined :: Float)
17:35:05 <Pseudonym> Hell, if you wanted to, you could just implement FloatTraits this way:
17:35:10 <Riastradh> I'd much rather do:   trait Float mantissaDigits
17:35:10 <cale> er, I can't find the :wq quote there
17:35:20 <Pseudonym> data FloatTraits a = FloatTraits { Int :: mantissaDigits }
17:35:28 <cale> though there are some other pretty good quotes :)
17:35:36 <Pseudonym> Without the need for passing undefined.
17:35:49 <Riastradh> Er, I think you mean 'mantissaDigits :: Int'.
17:35:53 <Pseudonym> Er, yes.
17:36:03 <Riastradh> What's the point of the 'a' there/
17:36:04 <Riastradh> ?
17:36:26 <Pseudonym> data FloatTraits a = FloatTraits {  mantissaDigits :: int, epsilon :: a }
17:36:46 <Riastradh> ...Int...
17:37:30 <Pseudonym> Uhm.
17:37:30 <Pseudonym> Did I mean ;?
17:37:30 * Pseudonym needs caffeine if he can't even remember record syntax
17:37:58 <Riastradh> Hmm, well, I suppose so.
17:38:07 <Pseudonym> You need 'a' because mantissaDigits is only one trait.
17:38:26 <Pseudonym> What this is, of course, is an explicit type dictionary.
17:40:12 <Riastradh> But...with that putting traits in a type class is kind of pointless.
17:41:00 <Pseudonym> Not really.
17:41:08 * Riastradh is confused now.
17:41:14 <Pseudonym> In a multi-paradigm language, there's always more than one way to do it.
17:41:22 * Pseudonym used to hack Perl for a living, can you tell?
17:41:36 <Riastradh> Yuck.
17:41:56 <Pseudonym> I could argue that type classes are all pointless.
17:42:07 <Pseudonym> Because you can always pass type dictionaries explicitly.
17:42:17 <Pseudonym> Certainly hidden variables are pointless.
17:42:37 <Pseudonym> Hell, if you've got universally quantified types and newtype, data constructors are pointless!
17:43:32 <Pseudonym> Typeclasses are convenient.
17:43:43 <Pseudonym> Traits typeclasses I find particularly convenient.
17:50:34 <Heffalump> this is of course an argument for using the ML module language rather than type classes
17:54:58 <Pseudonym> Probably, yes.
17:58:58 <Riastradh> Type classes are in -LOTS- of instances better than functors or interfaces -- just put the Monad m => context on some function instead of wrapping it in a functor that takes a monad module, for example.
17:59:10 <Riastradh> (no pun intended on the 'instances' bit)
18:00:41 <Heffalump> oh, sure
18:00:53 <Heffalump> I think there's a place for functors too, though
18:01:08 <Riastradh> I agree.
18:01:33 <Riastradh> That's why I said 'lots of' and not 'all.'
18:01:52 <shapr> Java just sucks. They're adding lots of stuff now, but I think it'll never be the right solution. The bad decisions of the past constrain the new additions.
18:02:08 <shapr> I like the way Haskell is different.
18:03:18 * shapr shrugs, wanders off to sleep
18:10:01 <Fractal> 4
18:10:06 <Riastradh> 4?
18:10:06 <Fractal> Er...
18:10:10 <Fractal> Ignore that
18:10:11 <Riastradh> 42.
20:05:54 <Riastradh> What's 'mdo' as mentioned on the HaskellTwo wiki page?
20:15:05 <inkedmn> evening all
20:29:31 <inkedmn> pyreverse :: [a] -> [a]
20:29:31 <inkedmn> pyreverse xs = aux [] xs
20:29:31 <inkedmn>                where aux acc [] = acc
20:29:31 <inkedmn>                      aux acc (x:xs) = aux (x:acc) xs 
20:29:50 <inkedmn> oops, sorry
20:35:57 <inkedmn> anybody here?
20:35:57 <inkedmn> i'm trying to think of the most effecient way to reverse a list
20:35:57 <inkedmn> my friend recommends using an accumulator
20:35:57 <Riastradh> That's probably the most efficient way.
20:35:57 <inkedmn> hmm, ok
20:35:57 <inkedmn> the above code is how he said it should be done
20:36:57 <inkedmn> and i'm honestly having a really hard time understanding what his code is doing...
20:37:19 * Riastradh would explain it but he has to depart very soon.
20:37:36 <inkedmn> hehe, that's fine
20:37:55 <inkedmn> what about using a list comprehension?
20:38:42 <cale> inkedmn: have a close look at what aux is going to do
20:39:32 <inkedmn> cale: i'm pretty sure aux is the reversed list
20:39:43 <cale> have a look at aux "" "abc"
20:40:13 <cale> aux "" "abc" = aux "a" "bc"
20:40:26 <cale> aux "a" "bc" = aux "ba" "c"
20:40:48 <cale> aux "ba" "c" = aux "cba" ""
20:40:51 <inkedmn> is aux a builin function?
20:40:59 <cale> aux "cba" "" = "cba"
20:41:10 * Pseudonym just read an amusing paper
20:41:14 <cale> no - it's defined in the code you pasted above
20:41:20 <Pseudonym> Has anyone else read the paper about BLOWHARD?
20:41:27 <inkedmn> oh, ok
20:41:34 <cale> Pseudonym: heh, no
20:41:47 <Pseudonym> It's an old paper.  Like, 30 years old or something.
20:42:00 <Pseudonym> And it describes the ultimate programming language, called BLOWHARD.
20:42:04 <cale> heh
20:42:18 <inkedmn> OHH, ok...
20:42:21 * inkedmn thinks he's got it
20:42:42 <Pseudonym> It's by David Parnas.  He goes through all the requirements, then concludes that the ultimate programming language is a processor of empty lines... plus an extension mechanism (not described in this paper).
20:43:31 <cale> heh
20:43:42 <inkedmn> hmm...
20:46:18 <cale> the effect of aux is to reverse its second argument as it prepends it to its first argument.
20:47:33 <inkedmn> ok, that makes sense
20:47:38 <inkedmn> cale: thanks :)
20:47:45 <cale> no problem :)
20:49:36 <cale> @yow
20:49:38 <lambdabot> Kids, the seven basic food groups are GUM, PUFF PASTRY, PIZZA,
20:49:38 <lambdabot>  PESTICIDES, ANTIBIOTICS, NUTRA-SWEET and MILK DUDS!!
21:10:24 <cale> @yow
21:10:25 <lambdabot> My BIOLOGICAL ALARM CLOCK just went off..  It has noiseless
21:10:25 <lambdabot>  DOZE FUNCTION and full kitchen!!
21:10:33 <Riastradh> @yow
21:10:33 <lambdabot> Now I'm having INSIPID THOUGHTS about the beautiful, round
21:10:33 <lambdabot>  wives of HOLLYWOOD MOVIE MOGULS encased in PLEXIGLASS CARS
21:10:33 <lambdabot>  and being approached by SMALL BOYS selling FRUIT..
21:13:22 <cale> The first time I saw zippy quotes, I thought they were the results of Mad Libs.
23:45:43 <Marvin--> Pseudonym: interesting idea
