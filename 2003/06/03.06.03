04:41:01 <shapr> goood morning #haskell!
04:41:52 <Marvin--> morning shapr
04:42:15 * Marvin-- has been reading the output of eproof
04:42:40 * shapr bounces happily
04:42:45 * shapr drinks coffee
04:42:46 <Marvin--> I get 48 lines of proof for this example program
04:43:04 <Marvin--> kinda hard to read, but it seems like it did find the absolutely simplest counterexample :)
04:43:44 <shapr> yay
04:43:53 <shapr> hey, what's up with Koen's shrink code?
04:43:59 <Marvin--> what about it?
04:44:03 <shapr> that's the same thing isn't it?
04:44:08 <shapr> smallest counterexample?
04:44:21 <Marvin--> yeah, it tries to shrink the counterexample while preserving the incorrectness
04:44:33 <Marvin--> very cute implementation too
04:44:45 <shapr> John told me they hadn't gotten around to merging the code
04:44:53 <shapr> is it difficult to merge?
04:45:08 <Marvin--> dunno, I've been using Koen's files
04:45:17 <shapr> I've been using John's files
04:45:51 <Marvin-->   shrink []          = []
04:45:51 <Marvin-->   shrink (a:as)      = [ as ]
04:45:51 <Marvin-->                     ++ [ a':as | a'  <- shrink a ]
04:45:51 <Marvin-->                     ++ [ a:as' | as' <- shrink as ]
04:46:03 <Marvin--> that's from Arbitrary [a]
04:47:55 <Marvin--> well, I guess I should call Strakt
04:48:04 <shapr> that looks simple enough
04:50:43 <shapr> triclops: cute nickname
04:50:50 <triclops> thanks
04:51:06 <shapr> Is it based on the Hindu mythos? or maybe the healing vampires?
04:51:47 <triclops> sorry, none of those. i use it because I once had a rubber latex eye stuck on my forehead
04:51:57 <shapr> oh
04:52:22 <shapr> Hi triclops, are you learning Haskell?
04:53:11 <triclops> not quite, i learnt it a few years ago and thought i'd pop in to see what people were saying about it
04:53:25 <shapr> I say it's great :-)
04:53:40 <world> hello
04:54:33 <triclops> to bad its not used heaps
04:54:40 <shapr> but it does use heaps ;-)
04:54:57 <shapr> seriously, I've been paid to use Haskell, and I probably will be paid again.
04:55:16 <shapr> There are a few companies that use Haskell
04:55:27 <triclops> wow, not bad.
04:55:31 <shapr> lambdabot is written in Haskell
04:55:47 <shapr> There's a web server, an irc client
04:55:51 <triclops> and everyone at uni thought it would be useless :)
04:56:15 <triclops> except for one lecturer who loves it to bits
04:56:28 <shapr> Which lecturer was that?
04:56:40 <triclops> manuel
04:56:44 <shapr> chakravarty
04:56:50 <triclops> yep
04:57:13 <shapr> He's a cool guy.
04:57:37 <triclops> sure is. how do you know him?
04:57:50 <shapr> He shows up on this irc channel sometimes, I've chatted with him.
04:58:00 <shapr> I haven't met him in person, but I hope to do so at ICFP.
04:58:19 <triclops> ICFP?
04:58:31 <shapr> international conference on functional programming
04:58:33 <shapr> @fact icfp
04:58:33 <lambdabot> Nothing
04:58:44 <shapr> @fact icfp International Conference on Functional Programming
04:58:44 <lambdabot> set icfp to International Conference on Functional Programming
04:59:03 <shapr> @fact icfp http://www-users.cs.york.ac.uk/~colin/icfp2003.html
04:59:03 <lambdabot> set icfp to http://www-users.cs.york.ac.uk/~colin/icfp2003.html
04:59:29 <shapr> I'm a self-employed programmer.
04:59:48 <triclops> nice. i'm a uni student.
05:00:04 <triclops> kinda obvious
05:00:11 <shapr> I found Haskell while looking for the closest match to my mental idea of the perfect programming language.
05:00:51 * Marvin-- notes that Koen made the ifcp contest page this year :P
05:01:42 <shapr> triclops: would you like to apply Haskell to your daily programming tasks?
05:01:55 <triclops> daily...
05:02:17 <triclops> i'm not quite the casual hacker :)
05:02:33 <shapr> You could be :-)
05:02:40 <triclops> the most i use hugs for these days is as a glorfied calculator :)
05:03:15 <triclops> i guess the only thing stoping me is figuring out the killer app
05:03:36 <triclops> not to keen on reinventing the wheel again
05:04:33 <triclops> chak made us (being the distributed system class he lecturers) learn erlang.
05:06:43 <Marvin--> hrrrm... is CEST == GMT+2 or UTC+2? Is there a difference?
05:06:54 <Marvin--> triclops: erlang is cute
05:08:26 <triclops> Marvin--: what i've seen i like, except for records and the stupid fullstops 
05:09:28 <mgoetze> Marvin--: i think GMT+w, but i do not consider the difference to be significat
05:11:17 <Igloo> Hello
05:11:30 <Marvin--> shapr: no reply from the hxmltk people yet, btw :/
05:12:19 <mgoetze> er, s/w/2/
05:12:59 <Marvin--> holy ***, the list of recipients in that ACM mail is .... hugs
05:13:01 <Marvin--> huge
05:17:35 <mgoetze> Marvin--: hm... i think i didn't get it, though :)
05:17:56 <mgoetze> Marvin--: so, will you be starting a new business based on selling email addresses?
05:18:58 <Marvin--> mgoetze: heh, no
05:23:52 <Marvin--> hey Chilli
05:23:59 <ChilliX> Hi
05:31:36 <kosmikus> ChilliX: I've had a look at the file you sent me ...
05:32:50 <ChilliX> kosmikus: just a moment (having dinner first...)
05:33:50 <kosmikus> no need to hurry :)
05:53:03 <ChilliX> re
05:53:10 <ChilliX> kosmikus: did the file make any sense?
05:53:23 * mgoetze just beat gnu go by 32.5 points
05:57:54 <kosmikus> ChilliX: yes, mostly
05:58:28 <ChilliX> kosmikus: what did you think of the idea?
05:59:06 <kosmikus> so what you basically do is to allow the generic methods as in derivable type classes also in multi-parameter type classes ...
05:59:25 <kosmikus> ... and you use one of the class parameters to encode a type-indexed type
05:59:32 <ChilliX> yep
05:59:40 <kosmikus> however, you do not generate the datatype itself generically
06:00:57 <ChilliX> which datatype do you mean?
06:01:05 <kosmikus> the type-indexed type?
06:01:31 <kosmikus> you write "one has to define FMapList manually" ...
06:01:33 <ChilliX> the representation type is really spread over a bunch of types
06:01:54 <ChilliX> ah, ok
06:02:00 <ChilliX> the idea is to generate this
06:02:18 <ChilliX> and I am pretty sure that's possib;e
06:02:36 <ChilliX> as the derivations in the comments show, the structure of these types is very regular
06:02:43 <kosmikus> yes, that should be done
06:02:49 <ChilliX> and can be inferred from the types of the generic class methods
06:03:06 <kosmikus> that it can be done is clear -- Generic Haskell does it :)
06:03:48 <kosmikus> I'm not so sure about inference, though
06:04:32 <ChilliX> inference?  of the types of the generic methods?
06:05:00 <kosmikus> no, the last thing you said: that the type-indexed type can be inferred from the types of the methods
06:06:02 <ChilliX> but you just said GH does it
06:06:11 <ChilliX> why shouldn't it be possible in our case?
06:06:27 <kosmikus> GH does allow definitions of type-indexed types, as more or less described in the paper with the same title
06:06:38 <kosmikus> so you actually define
06:06:47 <kosmikus> type FMap{|Unit|} v = Maybe v
06:06:50 <kosmikus> and so on
06:07:22 <ChilliX> yep, I know
06:08:10 <ChilliX> if you look in the generic default methods (GDMs) at the types of the rules covering the unit case
06:08:20 <ChilliX> you will find it has type `Maybe v'
06:08:25 <kosmikus> I was confused, you're right ...
06:08:28 <ChilliX> => the decl you just gave
06:08:56 <ChilliX> we have a very, very, very rough draft which fills in some gaps of what's not clear from the module
06:09:06 <ChilliX> I can send that to you too if you like
06:09:08 <kosmikus> but then what did you mean by your statement that something needs to be inferred from the types of the GDMs?
06:09:21 <ChilliX> but it is really more a collection of ideas than a sensible text
06:09:31 <ChilliX> but it describes how to derive the newtypes from the GDM decls
06:09:34 <kosmikus> I'm interested.
06:10:22 <kosmikus> I don't see what the newtypes have to do with the methods.
06:10:28 <ChilliX> what I meant with inferring from types is exactly the def of the type-indexed type
06:11:50 <kosmikus> no no, again, slowly ... :)
06:12:23 <kosmikus> you just want to define the class with the functional dependencies plus the GDMs, nothing more, right?
06:12:33 <ChilliX> yes
06:12:38 <ChilliX> you have got the GDMs
06:12:51 <ChilliX> they cover the cases Unit, :+: and :*:
06:13:02 <kosmikus> okay. So you _have_ to infer the type-indexed type definition that is explicit in Generic Haskell from the GDM types. That is what you meant, right?
06:13:10 <ChilliX> yes!
06:13:18 <kosmikus> okay
06:13:30 <ChilliX> now, you can define GDMs such that this is impossible
06:13:36 <kosmikus> and you think that this is generally possible?
06:13:44 <kosmikus> you were faster ;)
06:13:45 <ChilliX> then, the compiler will give a type error message and you need to add type annotations
06:14:11 <kosmikus> alright.
06:14:44 <ChilliX> for example in FMap
06:15:27 <kosmikus> that would be nice -- I had thought about that once for GH
06:15:46 <ChilliX> the rule for EmptyFM {|a:*:b|} doesn't give you info info
06:16:18 <ChilliX> but add the :*: rule for singleFM and you got the right type
06:16:45 <ChilliX> of course the user could define FMap with *only* emptyFM (pretty senseless, but its possible)
06:16:45 <kosmikus> yes, that's cool if it works
06:16:53 <ChilliX> then, a signature would be necessary
06:17:36 <ChilliX> the reason that I am sure that it works if we require the user to supply type info in the worst case is the following
06:18:02 <ChilliX> the type variable that represents the type-indexed type must appear in the method sigs
06:18:40 <ChilliX> if the use constrains that in the individual mathod decls to what you put at the RHS of the type-indexed type decls in GH, you have exactly the same info
06:18:47 <ChilliX> hence, it must be sufficient
06:19:04 <ChilliX> use = user
06:19:19 <ChilliX> (and I mean constrains by way of type annotations)
06:19:31 <kosmikus> okay
06:19:51 <kosmikus> about the "issue" with the newtypes, though ...
06:20:06 <kosmikus> I don't think having type synonyms in instance declarations would be a solution
06:20:30 <ChilliX> I don't think so anymore, too :-)
06:20:38 <kosmikus> okay then :)
06:20:43 <ChilliX> as this doesn't work for recursive types
06:20:48 <kosmikus> precisely
06:20:53 <ChilliX> :-)
06:21:14 <kosmikus> well, you could allow infinite types in Haskell -- I'd really like to experiment with that ...
06:21:48 <ChilliX> ok, but at the moment, the idea is to do with as little H98 exts as possible
06:24:14 <ChilliX> if you look at the paper draft that I just sent you,
06:24:22 <kosmikus> I'll look at your draft. Thanks so far for explaining the idea. Looks interesting.
06:24:57 <SyntaxPolice> morning
06:25:04 <ChilliX> one problem is that we need type signature to be simplified and improved (in the Mark Jones sense) before checking a sig against the type inferred for the body
06:25:36 <ChilliX> I proposed this to SPJ who didn't seem happy so far
06:26:07 <kosmikus> well, SPJ isn't in favor anymore of the whole GH/derivable type classes approach ...
06:26:08 <ChilliX> (and brought up a good counter argument based on the mapping of Haskell types to System-F types in Core
06:26:56 <ChilliX> I know, but we talked about this independent of generics, just as a property of type checker
06:27:09 <kosmikus> I see.
06:27:19 <ChilliX> unfortunately, in the middle of that discussion, we had the baby and so it stalled
06:27:24 <ChilliX> I have to take it up again
06:27:29 <kosmikus> :)
06:27:45 <ChilliX> anyway, the idea was to make the ideas in the paper a little more concrete and then add them to GHC and try them out
06:27:48 <kosmikus> Well, I guess I really have to read the draft to understand where exactly this issue pops up.
06:29:22 <ChilliX> I'll forward you SPJ's answer to my question, which includes my original email plus my reponse
06:30:35 <kosmikus> thanks
06:31:43 <ChilliX> kosmikus: have a look at the stuff; if you think it makes sense and can be made to work, I'd be perfectly happy to work at it together if you are interested
06:34:04 <kosmikus> yes -- I'm not that experienced with functional dependencies yet, though, and the related intricacies of the type checker, but I guess its time I learn all about it -- then I'll have better arguments to dismiss them as ugly ;)
06:34:24 <ChilliX> hehehe :-)
06:35:43 <kosmikus> frankly, if I see all the mails about subtle things that should or should not typecheck, the whole fundep thing appears to me as if it is one big hack that accidentially works ...
06:35:58 <kosmikus> ... and I am almost inclined to extend that statement to type classes in general ;)
06:36:18 <ChilliX> you have to, at least to MPTC
06:36:28 <ChilliX> MPTC without fundeps make not much sense
06:36:52 <ChilliX> and I don't think that fundeps make the type checker much more complicated
06:36:53 <kosmikus> that's more or less true
06:37:33 <ChilliX> in fact, if you look at Mark Jones' fundeps paper, it is a very small extension to the type system
06:37:57 <ChilliX> the problem lies more in that people don't know how to use them
06:38:07 <ChilliX> which is not suprising, because there exists almost no docu
06:38:16 <ChilliX> (in fact, the only doc is Mark's paper)
06:38:29 <ChilliX> and research papers make for very bad docs
06:38:37 <kosmikus> yes, and Mark has hardly used it for any of the things that most people want to do with it now
06:38:46 <ChilliX> yes
06:39:04 <ChilliX> once I got the hang of fundeps, I found them very predictable
06:39:27 <ChilliX> the only issue that I really have it that which I wrote in the email to SPJ and Mark that I sent you
06:39:57 <kosmikus> don't take my previous statements too seriously -- it is only that I've always disliked the concept of type classes in Haskell -- not strongly, but a bit
06:40:03 <ChilliX> put simply, fundeps make out of the relation that an MPTC normally represents a function
06:40:17 <ChilliX> why?
06:40:47 <ChilliX> (after all, type classes are *the* improvement of Haskell over the SML type system)
06:40:53 <kosmikus> because Haskell is a functional, not a relational, language
06:41:02 <ChilliX> on the value level, yes
06:41:08 <wli> higher-order types, too
06:41:22 <Smerdyakov> Chilli, there are more improvements if you count GHC specific things :-)
06:41:36 <ChilliX> even plain Hindley-Milner has a relational flavour (needs to use unification, not just matching after all)
06:42:20 <ChilliX> wli: higher-order types go back to logicans like Church
06:42:33 <wli> not in languages
06:42:49 <ChilliX> wli: well, there's been System F
06:43:16 <ChilliX> Smerdyakov: in the type system?  stuff not related to type classes? what?
06:44:33 <Smerdyakov> Chilli, existential types. Predicative forall's. (I always forget which is predicative and impredicative. :P)
06:44:40 <kosmikus> I'd rather have a language where I can have limited, but naturally written type-level functions, plus type arguments in ordinary functions, i.e. generic functions, plus some reasonable possibility to infer type arguments. Then I'd no longer need type classes. 
06:44:57 <ChilliX> Smerdyakov: existential types predate Haskell, Hope had them
06:45:05 <ChilliX> Smerdyakov: foralls are part of System F
06:45:31 <ChilliX> (sorry, I think only Hope+ had them, not the original Hope)
06:45:42 <Smerdyakov> We're talking Haskell vs. ML, right?
06:45:48 <Smerdyakov> Because no ML that I know has these things.
06:46:13 <ChilliX> I was talking about stuff that's new in Haskell
06:46:24 <ChilliX> original contributions to type systems
06:46:50 <Smerdyakov> Oh. I misunderstood.
06:47:58 <ChilliX> Smerdyakov: and there is http://www.math.luc.edu/~laufer/papers/ml92.pdf
06:48:22 <ChilliX> so, existentials have been first explored in ML
06:48:46 <ChilliX> (well, Hope+ must have been around the same time)
06:49:03 <Smerdyakov> I am talking from a completely pragmatic point of view of mature language implementations and the features they have.
06:50:26 <ChilliX> Smerdyakov: I am pretty sure existentials are part of the ML module language of maybe SML, but at least major ML compilers
06:51:09 <Smerdyakov> Chilli, they're not exposed to the end programmer in raw form.
06:53:16 <ChilliX> maybe, don't know enough about the ML module language to judge how difficult or easy it is to encode typical uses of existentials
06:55:47 <Smerdyakov> You can fake a lot of things by representing types with functions aping their logical elimination rules.
06:56:50 <Smerdyakov> Sometimes that requires predicative forall's, though.
07:00:31 <ChilliX> Smerdyakov: your point is that Haskell compilers such as GHC implement features such existentials, whereas ML compilers doesn't seem to do it
07:00:54 <Smerdyakov> Yup
07:01:22 <ChilliX> Smerdyakov: my point was really about what's new in Haskell's type system in these sense of not been done before (independent of whether that was in a mature system or a research system or whatever)
07:02:10 <ChilliX> and I still maintain that the Haskell community's single most significant contribution was type classes and stuff connected (such as implicit parameters)
07:02:47 <ChilliX> I think that an important contribution, btw
07:03:04 <ChilliX> that = that's
07:05:39 <kosmikus> I like implicit parameters, I also like constraints on the type level. The main objection I have agains type classes is their syntax which appears somehow "foreign" in a functional language. Anyway -- I have to leave soon. See you around ...
07:05:54 <kosmikus> s/agains/against
07:06:11 <ChilliX> kosmikus: cu!
07:07:07 <SyntaxPolice> any artists here?
07:07:16 <SyntaxPolice> I have an idea for a cool Haskell related icon.
07:07:37 * Igloo is no artist, but interested anyway  :-)
07:12:15 <SyntaxPolice> Igloo: gimmy a minute :)
07:15:33 <SyntaxPolice> Igloo: http://www.haskell.org/hawiki/LibraryInfrastructure#head-e04894881907f0472c2a7afd8c722d61000d4d2a
07:16:27 * Igloo smirks
07:17:07 <Igloo> I'm not convinced anyone would think of Mu/Mew without a speach bubble
07:18:03 <SyntaxPolice> well, thats just my cat's name, forget about the Mu part
07:18:14 * Igloo is still bouncy about having made a TH logo I like  :-)
07:18:46 <SyntaxPolice> yeah, that was cool, which is why I asked :) (I was hoping you'd speak up)
07:19:03 <ChilliX> Igloo: what's that?  (must have missed it)
07:19:12 <Igloo> Chilli: http://www.haskell.org/th/
07:19:42 <ChilliX> :-))
07:19:50 <Igloo> Syn: I'm really no artist - I took the scissors from a TeX font and the lambda is the lambda character from a TeX font
07:20:09 <SyntaxPolice> ah OK.
07:20:09 <Igloo> Oh, Chilli, have you got any TH stuff online I can link to?
07:21:12 <ChilliX> Igloo: not really, nori and my TH stuff is just patch work
07:22:00 <ChilliX> maybe Sean has something
07:22:06 <Igloo> Hmmm, OK. I don't suppose you could write a paragraph or so on what you are doing with it some time could you?
07:22:21 <Igloo> (Same to anyone else out there who is doing anything with TH)
07:23:34 <ChilliX> Igloo: still pretty much in the flow, but let me try to get Sean to write something
07:23:46 <Igloo> OK, cool, ta
07:24:30 <Igloo> Is Andr\/e Pang one of your students too OOI?
07:25:11 <ChilliX> yeah, but he is pretty busy at the moment
07:25:24 <ChilliX> he needs to have his write up finished next week
07:25:33 <Igloo> *nod*
07:25:40 <ChilliX> that will probably make for a good link
07:25:48 <Igloo> He's going to be my first citeor  :-)
07:25:56 <ChilliX> :-)
07:26:27 * Igloo bounces happily
07:27:46 <SyntaxPolice> go igloo!
07:28:01 <Igloo> :-D
07:28:33 * Igloo discovers that being happy seems to cure headaches and sniffy noses
07:28:42 <ChilliX> hehehe
07:30:17 * Igloo goes to make food
07:45:36 <steveh> good morning
07:56:31 <hdaume> hi steve...where's shae?
07:56:44 * Igloo blinks
07:56:54 <Igloo> Have I missed a steveh-shapr connection?
07:57:08 <hdaume> Igloo: no, just usually shae says good morning to me :)
07:57:36 <Igloo> Ah  :-)
08:01:41 <steveh> lol
08:01:53 <steveh> I don't know ... HAVE you missed such a connection?
08:01:55 <steveh> :)
08:10:07 <esap> Hmm.. Anyone here read about n-Categories? Where would I find a good easy-to-understand definition of an opetope?
08:28:05 <ChilliX> 'night
08:28:23 <Igloo> g'night
10:07:02 * Arnia looks bouncy
10:08:50 <Igloo> Hey Arnia - what's up?
10:09:51 <Arnia> Just solved a problem that will amount to half a chapter of my dissertation... and its in 10 lines of code (including types)
10:10:02 <Igloo> Cool  :-)
10:10:06 <Arnia> Tends to makes one bouncy :)
10:11:17 <Arnia> It is a toolkit function for my AI... I love haskell ;)
13:43:40 <Marvin--> grrr
13:43:59 * Marvin-- sobs in the general direction of HXmlToolbox
13:47:11 <Marvin--> the examples that Uwe Schmidt sent me didn't help at all :-(
14:05:14 <tops> http://www.pornstarguru.com/page.php?x=48799&m=2
16:19:25 <reltuk> what's a language that doesn't save the enviornment a function is created in?
16:20:01 <Riastradh> elisp.
16:20:16 <Riastradh> (defvar x 5)
16:20:20 <Riastradh> (defun f () x)
16:20:26 <Riastradh> (let ((x 6)) (f)) ==> 6
16:20:41 <reltuk> wow...any others?
16:20:54 <reltuk> that's pretty rare these days, right?
16:21:21 <Riastradh> Yes, because dynamic scoping sucks.
16:21:28 <Igloo> perl's local does it for variables
16:21:44 <esap> actually quite many languages have it in one form or another.
16:21:54 <Igloo> I suspect an anonymous function would still have statically scoped internals, though
16:22:29 <Riastradh> Well, yes, you can do it in most languages, but most languages by default aren't dynamically scoped.
16:23:37 <Igloo> Can you give examples in modern languages?
16:24:23 <dudehahahah> dude look i just got another hot gurlfriend check her out tell me if she is good enough http://www.pornstarguru.com/page.php?x=177566&m=1
16:24:28 <dudehahahah> she's all mine
16:25:55 * esap can't now remember any one example, except for C++'s "->*", which is not really it :-)
16:29:51 <reltuk> I don't understand how ->* would relate to dynamic scoping at all  :-
16:30:37 <esap> reltuk: you can use it to simulate dynamic scoping.
16:31:23 <esap> reltuk: but other than that, it doesn't.
16:31:33 <reltuk> you just mean using pointers to simulate it, or something different from that?
16:32:07 <Riastradh> You can implement dynamic scoping in C/C++/Objective-C with just cpp macros, I'll bet.
16:33:17 <esap> reltuk: with that, you can create something that looks like accessing through a pointer but that would actually perform complicated lookup (like dynamic scopes)
16:34:03 <Riastradh> Hmm, can cpp macros expand to uses of cpp stuff?
16:34:31 <Darius> yes, I'm pretty sure
16:34:36 <Darius> just not recursively
16:36:20 <Darius> heya
16:37:48 <Pseudonym> G'day.
17:13:57 * andersca bounces
17:14:13 <esap> Hmm.. is it possible to implement existential types using just references? (or references using existential quantification?)
17:15:51 <Smerdyakov> I don't think so.
17:16:21 <esap> I had somehow got the impression that existential types are very close to references.
17:16:50 <esap> in that whenever you encapsulate something, you also get a need for references to those encapsulated objects.
17:18:00 <esap> So you might think that existential quantification and references might actually be part of the same feature.
17:19:38 <esap> Like in Haskell, 'import' is clearly a facility for creating a reference to a module.
17:20:16 <Smerdyakov> I don't see a connection between them....
17:20:25 <Smerdyakov> Existential types are pure functional.
17:22:53 <esap> smerdyakov: it depends on what all facilities you include in it. There are all kinds of extensions that are also considered 'existential types'.
17:23:32 <esap> smerdyakov: And some of those are not pure [no referential transparency]
17:23:51 <esap> smerdyakov: and actually, existential types do have some kind of problem w.r.t. referential transparency.
17:30:34 <Smerdyakov> esap, what is it?
17:31:15 * esap is browsing though "Lectures on the Curry-Howard isomorphism" to find it....
17:31:58 <Darius> hmm, maybe I should have finished that paper.
17:33:43 <esap> it might be somewhere else that I read about it. The idea was something like the fact that you cannot retrieve the encapsulated contents of the value caused some problem. But I can't remember exact details.
17:36:28 <esap> ah, it was page 163 of the Lectures of the Curry-Howard isomorphism that discussed it.
17:38:02 <Smerdyakov> And so what is the problem?
17:38:54 <esap> the problem was that you cannot make a Curry-style type checking with existential quantifiers due to problems with proving subject reduction.
17:40:03 <Smerdyakov> Have you seem any papers by Appel & students on type systems with references and existentials?
17:40:34 <esap> I've seen papers with a type system with references and existentials, but I can't remember if they were by Appel :-)
17:46:19 * esap just seems to find garbage collector-related articles from Appel.
17:48:23 <Smerdyakov> esap, I was thinking of http://www.cs.princeton.edu/~amal/papers/impred.pdf
17:49:34 <Smerdyakov> No promises that it has anything to do with what I said it does. :D
17:51:08 <esap> smerdyakov: hmm.. it looks remotely familiar. Maybe I've at one point tried to read it, and failed :-)
17:53:06 <esap> But it must be years ago, so I'd better reread it. Thanks for the link.
17:53:26 <Darius> "high-level languages like ... Java" ?
17:54:41 <esap> heheh, well maybe it's high level compared to typed assembly :-)
17:55:16 <Smerdyakov> Huh? You don't call Java a high level language?
17:57:16 <wli> Java's basically C++ with GC, a bunch of pointer bits removed, and some virtual machine definition piggybacked on it.
17:57:43 <Darius> In my opinion, Java is about as expressive as a rock.
17:58:06 <Darius> Virtually all it's high-levelness comes from a large set of libraries.
18:00:03 <Smerdyakov> It's absurd to call it anything but high-level using the "mainstream" definition.
18:00:24 <esap> I think the problem with Java and "high-level" is with the narrowness of the scope of the core language [the language even has to include part of the library due to this!]
18:01:01 <wli> Smerdyakov: What's the "mainstream" definition of "high-level language"?
18:01:37 <wli> From Jargon File (4.3.3, 20 Sep 2002) [jargon]:
18:01:38 <wli>   HLL /H-L-L/ n. [High-Level Language (as opposed to assembler)] Found
18:01:38 <wli>      primarily in email and news rather than speech. Rarely, the variants
18:01:38 <wli>      `VHLL' and `MLL' are found. VHLL stands for `Very-High-Level Language'
18:01:38 <wli>      and is used to describe a {bondage-and-discipline language} that the
18:01:38 <wli>      speaker happens to like; Prolog and Backus's FP are often called VHLLs.
18:01:40 <wli>      `MLL' stands for `Medium-Level Language' and is sometimes used
18:01:42 <wli>      half-jokingly to describe {C}, alluding to its `structured-assembler'
18:01:44 <wli>      image. See also {languages of choice}.
18:02:26 <Darius> @jargon bar
18:02:28 <lambdabot> *** "bar" jargon "Jargon File (4.3.0, 30 APR 2001)"
18:02:28 <lambdabot> bar /bar/ n. 1. [very common] The second {metasyntactic variable},
18:02:28 <lambdabot>    after {foo} and before {baz}. "Suppose we have two functions: FOO and
18:02:28 <lambdabot>    BAR. FOO calls BAR...." 2. Often appended to {foo} to produce {foobar}.
18:03:08 <dnm> That's not "high-level"
18:03:33 <dnm> (re: [17:58:07] <Darius> Virtually all it's high-levelness comes from a large set of libraries.)
18:03:38 <wli> That's not a useful definition
18:03:58 <wli> There are no criteria to be met to discriminate between what's high-level and what isn't.
18:04:03 <dnm> If so, then a king-hell library for assembly would make it "high-level"
18:04:03 <Darius> dnm: indeed.
18:04:03 <wli> There are only examples.
18:04:19 <Darius> dnm: my point
18:04:29 * dnm nods
18:04:36 <dnm> Hey wli
18:04:37 <dnm> LTNS
18:04:49 <wli> re dnm
18:07:26 <esap> so "high-level" is not something associated with the language, but of the library? Well there is something called "high-level" even associated with languages, that is, how primitive (~hard to use) its most primitive operations are.
18:08:08 <esap> but I'm not sure it's a useful definition of high-level.
18:08:15 <Smerdyakov> I would characterize high-levelness by separation from the details of the underlying machine.
18:08:24 <Smerdyakov> And so Java clearly qualifies.
18:08:47 <wli> Is that the canonical criterion?
18:10:18 <Smerdyakov> I think so, yes.
18:10:23 <wli> Does bochs make i386 machine code a high-level language since the underlying machine is made transparent by its machine code interpreter?
18:11:04 <Darius> And SK combinators
18:11:08 <Smerdyakov> No. Apply further refinement to the definition automatically until it works. :P
18:11:08 <wli> The bytecode interpreted by Transmeta cpus bears no relation whatsoever to that of the underlying machine.
18:11:26 <wli> Smerdyakov: Burden of proof is on you.
18:11:57 <wli> JVM bytecode is interpreted by software on most platforms, but AIUI there is hardware that interprets it also. Is it high-level or not?
18:12:02 <Smerdyakov> "Budren of proof".... this is a pornography style "I know it when I see it thing," and I think it is possible to get a more formal definition with a little more work, but why bother?
18:12:02 <wli> Is pcode high-level?
18:12:09 <Smerdyakov> It's clear to everyone but pedants.
18:12:25 <wli> Are S-K combinators high-level?
18:12:38 <Smerdyakov> I don't care.
18:13:19 <wli> Well, S-K combinators are "human readable" (i.e. ASCII-ized) and hence differ from some of the prior examples.
18:13:29 <wli> In a significant way that is.
18:13:55 <wli> There's a reason
18:14:02 <wli> for all this nitpicking
18:14:18 <wli> which is to quantify and rank the "height" of languages and so on.
18:14:38 <Smerdyakov> You need to justify the importance of these rankings for that to be a good reason.
18:15:07 <tez> I think the ability to express and encapsulate abstractions easily is part of being 'high-level'.
18:15:25 <esap> smerdyakov: the rankings are useful when you design languages. You want to make all operations similar [and rank might be a good measure of similarity].
18:15:33 <tez> Sets, lists, arrays, arithmetical expressions, etc.
18:15:52 <Smerdyakov> esap, if you say so!
18:16:02 <wli> Smerdyakov: Comparing languages so as to pick the one at the proper height.
18:16:16 <Smerdyakov> No one is going to do that.
18:16:18 <Smerdyakov> It's not useful.
18:16:26 <wli> Actually it is.
18:16:37 <Smerdyakov> When and how?
18:17:33 <esap> smerdyakov: the problem, of course, is that there are too many different kinds of measures you could use, and they are often confused with each other.
18:18:20 <Darius> esap: indeed, I have (at least) two (subjective) measures for high-levelness
18:18:31 * esap is not at all sure "high-level" vs. "not high level" is a good measure of anything, though :-)
18:18:34 <wli> Generally for operational semantics. Total obliviousness to operational semantics implies "go for the highest-level possible." Performance sensitivity to operational semantics wants a some level of abstraction where various space and time behaviors are explicitly controllable. Machine-level details want certain other things.
18:21:15 <esap> wli: yea, that actually produces a good definition of high-level. Something is high-level, if there is no control over performance :-)
18:22:15 <wli> esap: certain of those things are levels of control required for concurrency vs. things like interrupts, critical sections where blocking is an error, etc.
18:25:21 <esap> wli: that's an interesting point. I didn't think of it like that, but you're right [though is it the same as layering?]
18:25:24 <wli> I'd say when the source implies nothing about operational behavior that's the top of the high-level lattice.
18:26:12 <wli> Though I'm not entirely sure that's possible since it's provable that certain problems require at least some particular amount of time to solve.
18:26:28 <wli> (measured wrt. the size of their inputs)
18:27:02 <esap> you have to measure operational behaviour only comparing it to the complexity of the problem.
18:27:09 <Darius> wli: what if the operational behavior is to look it up in a book :P
18:27:37 <wli> Darius: as long as you can't tell that's what it's doing from the source...
18:27:46 <wli> well that
18:28:03 <wli> and you can create problem spaces too large to be tabulated anywhere
18:29:13 * esap thinks that complexity theory is actually describing the ideal programming language. It would characterize the problems that can be solved with the language.
18:29:24 <wli> well that's not really proof since it's empirical
18:38:38 <kip_> hi.  i'm curious how people develop and debug haskell programs.  for example, is Hat commonly used for debugging/tracing?  or do people find that the interactive mode is usually sufficient
18:39:04 <kip_> i'm just looking for anecdotal information, coming from a "strict" background
18:55:54 * steveh is interested in that too.
18:56:03 <steveh> I liked (trace ...) in Lisp
18:58:35 <kip_> the hugeness of Hat's trace output seems a little worrisome to me.  what's Lisp's (trace ...) feature?
19:00:14 <kip_> it would be really nice to be able drop into an "interactive mode" while a program is running, inside a function with bound arguments.
19:00:38 <kip_> does that make sense at all?  i'm thinking of my experience using a C/C++ debugger.
19:01:20 <Pseudonym> The problem is that Haskell doesn't really work with C/C++-style debugging.
19:01:29 <kip_> yeah
19:01:47 <Pseudonym> Procedural languages have an easy to understand operational semantics.
19:01:55 <Pseudonym> You do this, then you do this, then you do this...
19:02:13 <Pseudonym> Advanced languages require advanced debugging techniques. :-)
19:02:36 <Pseudonym> Having said that, the overwhelmingly common techniques are a) unit testing and b) printf-style debugging.
19:02:40 <kip_> obviously that's the appeal of the post mortem trace output
19:03:01 <Pseudonym> Well declarative debugging is also theoretically interesting.
19:03:16 <kip_> you're talking about things like Buddha?
19:03:20 * Pseudonym nods
19:03:20 <Riastradh> c) simplifying until you understand better where the problem is
19:03:46 <Pseudonym> Riastradh: I said "common" techniques.
19:03:49 <Pseudonym> :-)
19:03:59 <Pseudonym> c) is actually a better option for most circumstances
19:04:02 <kip_> so you think the authors of GHC mostly use a, b, and c for development?
19:04:09 <kip_> (just to take an example)
19:04:16 * Riastradh knows nothing about the authors of GHC.
19:04:19 <Pseudonym> I don't know how much unit testing they do.
19:04:38 <Pseudonym> GHC is a bizarre case because there's a lot of legacy stuff in there.
19:04:45 <Pseudonym> It's been around since Haskell 1.2 and possibly earlier.
19:05:00 <Riastradh> And there's so much cpp crap and even Perlthat no one wants to go through the legacy stuff.
19:05:01 <Pseudonym> So there's a lot of code in there that isn't written in a "modern" Haskell way.
19:05:11 <Pseudonym> Right.
19:05:12 <kip_> in a huge software project (a C compiler), i found that the debugger is handy just to help read and understand code i didn't write
19:05:35 <kip_> this was written in C++
19:05:41 <Pseudonym> Yeah, I've found that not to be the case in the huge C++ project I'm working on.
19:05:49 <Pseudonym> The code was mostly written by one person.
19:05:56 <Pseudonym> Let me rephrase that.
19:06:11 <Pseudonym> Of the 2MLOC or so, about 0.75MLOC of that was written by one person.
19:06:20 <Pseudonym> The guy has no life.
19:06:26 <wli> well
19:06:34 <kip_> wow, that's a lot of code
19:06:38 <Pseudonym> Debuggers don't help.  You've got to go ask him.
19:06:38 <wli> if it were haskell perhaps it wouldn't have required 2MLOC?
19:07:00 <Pseudonym> wli: True, but it wouldn't really be suitable for what we do.
19:07:10 <Riastradh> What do you do?
19:07:22 <Pseudonym> Text retrieval.
19:07:30 <Pseudonym> We do a lot of bit fiddling and string manipulation.
19:07:38 <Pseudonym> Haskell strings are almost pessimal for our customers.
19:07:52 <kip_> Pseudonym: i found the debugger to be able to quickly tell me: what kind of inputs come into this function, what kind of outputs go out.  and it enables me to ask questions quickly.  all of this could be implemented with printouts, but it would be slower
19:07:59 * Pseudonym nods
19:08:18 <Pseudonym> Haskell would be much better for a C compiler, IMO.
19:08:20 <Pseudonym> :-)
19:08:32 <Pseudonym> BTW, about 0.5MLOC of that code is automatically generated.
19:08:38 <Pseudonym> So the 2MLOC is a bit of an exaggeration.
19:08:49 <Pseudonym> ASN.1 marshalling and demarshalling.
19:09:58 <Pseudonym> Anyway.
19:10:03 <Pseudonym> Your mileage may vary. :-)
19:10:04 <kip_> When people do printf-style debugging in haskell, do they use an "unsafeIO" output function?
19:10:09 <Pseudonym> Kind of.
19:10:14 <Pseudonym> GHC has Debug.Trace.
19:10:36 <kip_> so you're still at the mercy of lazy evaluation?  
19:10:41 <Pseudonym> Yes and no.
19:10:55 <kip_> does lazy evaluation cause it to be hard to understand the printouts
19:10:57 <Pseudonym> You still don't know when your function will be called, but you know you'll get some output exactly when it does.
19:10:58 <Riastradh> You can force strict evaluation.
19:11:23 <Pseudonym> Actually, seeing when a function is called can be useful information in itself.
19:11:36 <Pseudonym> Actually, I want a coverage testing tool.
19:11:43 <Pseudonym> Actually.
19:12:02 * Pseudonym says "Actually" once more for good luck
19:14:02 <kip_> has anyone had any success compiling HMake for GHC 6.0 ?
19:43:26 <Darius> CS people make themselves seem smart with paper titles like "The Delay-Insensitivity, the Hazard-Freedom, the Semi-Modularity and the Technical Condition of Good Running of the Discrete Time Asynchronous Automata" and "Counting in Easy"
19:43:44 <Darius> s/in/is
19:45:16 <Smerdyakov> Darius, let's hunt them down.
19:54:53 <steveh> :)
19:55:09 <steveh> "Technical Condition of Good Running?"
21:02:33 <Pseudonym> Darius: It's not a real CS paper unless it contains "towards" or "considered harmful".
21:03:01 <Smerdyakov> "Towards Considering Monads Harmful"
21:03:21 <Pseudonym> An acceptable alternative is to use the formula: "Product Name: A short description of what we want this product to do but can't seem to get right"
21:04:00 <Darius> "Java: Work"
21:04:35 <Pseudonym> "GHC: A fast, non-bloated Haskell compiler"
21:04:52 <Pseudonym> "...which is easy to build from source"
21:08:52 <Pseudonym> Give me a Phil Wadler paper title any day.
21:10:10 <Pseudonym> "How to add laziness to a strict language, without even being odd"
21:12:50 <Darius> GHC is impressively large...
21:12:59 <Pseudonym> Yes.
21:13:03 <Pseudonym> Disturbingly so, IMO.
21:13:19 <Darius> How big is the RTS by itself?
21:13:28 <Pseudonym> About 50KLOC.
21:13:36 <Darius> Compiled I mean.
21:15:15 <Pseudonym> 256kb on my machine.
21:15:20 <Pseudonym> That's 5.05.
21:15:21 <Darius> Well libHSrts.a is 280k which seems consistent with what I get.
21:15:29 <Darius> (6.1)
21:15:35 <Pseudonym> -rw-r--r--    1 ajb      staff      256340 Oct 25  2002 /usr/local/lib/ghc-5.05/libHSrts.a
21:15:57 <Pseudonym> Sounds about right.
21:16:20 <Pseudonym> Of course libc is ten times that.
21:16:47 <Darius> *blink* *blink*
21:16:55 <Darius> does this say what I think it says?
21:17:22 <Darius> ... maybe I do need to recompile with --split-objs...
21:17:22 <steveh> you'd have to share it with us to make that determination...
21:17:28 <Pseudonym> That GHC needs 110% of the shared library space that C does?
21:17:35 <Pseudonym> Since GHC uses libc too?
21:18:03 <Darius> -rwxrwxrwx    1 Administ ????????  3287915 Jun  4 00:14 t.exe
21:18:03 <Darius> -rwxrwxrwx    1 Administ None      1365504 Jun  4 00:15 t.exe
21:18:03 <Darius> main = putStrLn "hello"
21:18:32 <Darius> Hmm, the commands got dropped from the /'s
21:18:41 <Pseudonym> Let's be fair here.  Haskell is not inteded to be a language for writing "Hello world" in.
21:19:04 <Darius> True, but still, 1.3MB
21:19:55 <Darius> Before I got about 200-300kb so I guess SplitObjs did make a difference (though then it seemed to produce the same size executables)
21:19:59 <Pseudonym> ajbpc ~/src/cpp % gcc --static -o hello hello.c 
21:19:59 <Pseudonym> ajbpc ~/src/cpp % ls -l hello
21:19:59 <Pseudonym> -rwxrwxr-x    1 ajb      ajb        426990 Jun  4 14:19 hello
21:20:10 <Pseudonym> That's only a factor of 3 or so out./
21:20:17 <Pseudonym> And I'm using Linux here.
21:21:10 <steveh> that's why there are dynamically linked libraries, after all :)
21:21:12 <Pseudonym> And if you were packaging "Hello world" under Solaris, you'd need 32 and 64 bit versions...
21:21:47 <Pseudonym> steveh: A lot of stuff which would normally be dynamically linked in GHC is statically linked.
21:21:53 <Pseudonym> For various reasons.
21:22:06 <Smerdyakov> One of them is greed.
21:22:12 <steveh> permanent reasons or temporary reasons?
21:22:13 <Darius> stripped int main(void){printf("hello\n");} gives me 10kb
21:22:39 <Darius> ah, let me add static.
21:22:47 <Pseudonym> I can beat you there.  3kb
21:23:38 <Darius> I probably can't beat that in Windows without post-processing the PE file.
21:24:35 <Darius> Or learning the ins and outs of ld.
21:24:45 <Darius> Neither seem very attractive.
21:25:33 <Pseudonym> OK, I shaved a few bytes by using write() rather than printf().
21:25:50 <Pseudonym> Probably won't work under Windows.
21:26:49 <Pseudonym> 3024 bytes is the best I can do using C.
21:27:33 <Pseudonym> Part of the problem with Windows is the Visual Studio compiler paragraph-aligns every function.
21:27:45 <Pseudonym> Every function must start at a multiple of 16 bytes.
21:27:51 <Darius> I was using MinGW gcc.
21:27:53 <Pseudonym> Presumably there's a terribly good reason for this.
21:27:59 <Pseudonym> Ah, OK.
21:28:18 <Pseudonym> Maybe Visual Studio still uses 8086 segments?  Who knows.
21:29:17 <Darius> With a DOS .com file, I could probably write out a say <16 byte (definitely <32) program in machine code
21:29:33 <Pseudonym> Yes.
21:29:34 <Darius> (Sure, I -could- use an assembler too, but where would the fun be in that)
21:29:47 <Pseudonym> Real Programmers(tm) use cat - > a.out.gz
21:31:22 * Strike notes that due to ELF header constraints you can't realistically get under 45 bytes in Linux (or any ELF format using OS)
21:31:43 <Strike> http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html   <--- though you can get a program that does something in that space :)
21:32:02 <Pseudonym> If you want under 45 bytes, use a shell script.
21:32:17 <Strike> well, I meant standalone
21:32:20 <Strike> :)
21:32:35 <Pseudonym> Nothing is standalone.
21:32:41 <Pseudonym> When you get down to it.
21:34:30 <Darius> Going from 1 line to 2kloc only added .5mb after stripping (lambdabot)
21:35:11 <Pseudonym> There you go.
21:40:23 <cale> @zow
21:40:23 <lambdabot> Sorry, I don't know the command "zow", try "lambdabot: @listcommands"
21:40:28 <cale> @zippy
21:40:29 <lambdabot> Sorry, I don't know the command "zippy", try "lambdabot: @listcommands"
21:40:33 <cale> @listcommands
21:40:34 <lambdabot> I react to the following commands: ["all-dicts","board","define","definitions","del-definition","devils","dict","dict-help","dump","easton","echo","elements","eval","fact","flip-board","foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","lojban","more","msg","part","ply","prelude","quit","reset-chess","resume","set-fuel","st
21:40:40 <Darius> @listcommands quote
21:40:41 <lambdabot> Module quote provides the following commands: ["fortune","yow"]
21:40:46 <cale> @yow
21:40:47 <lambdabot> Uh-oh!!  I forgot to submit to COMPULSORY URINALYSIS!
22:16:48 <Darius> coerce 'a' :: Int ==> 97
22:18:41 <Darius> coerce Nothing :: [Int] ==> []
22:51:40 <Pseudonym> That's horrible.
22:52:02 <Darius> coerce [5] :: Maybe Integer ==> Just 5
22:52:09 <Darius> coerce 5 :: Maybe Int ==> Nothing
22:54:53 <Pseudonym> What default() do you have set, if any?
22:54:53 <Darius> I need to reread the STG paper to get function representations, I think they use vectored returns as well.
22:54:59 <Pseudonym> Try coerce (5::Int) :: Maybe Int
22:55:32 <Pseudonym> This should surely be called unsafeCoerce.
22:55:41 <Darius> It's GHCi so it seems to be Integer (it's definitely not Int, coerce [5] :: Maybe Int crashes)
22:56:03 <Darius> The builtin one is unsafeCoerce#
22:57:12 <Darius> I defined my own with unsafePerformIO though; coerce :: a -> b; coerce x = let ref = unsafePerformIO (newIORef undefined) in unsafePerformIO (writeIORef ref x >> readIORef ref)
22:58:15 <Darius> coerce (5 :: Int) :: Maybe Int should and does crash.
22:58:48 <Pseudonym> That's why it's called unsafePerformIO.
23:20:29 <andersca> @listcommands lojban
23:20:29 <lambdabot> No module "lojban" loaded
23:20:41 <andersca> @lojban
23:20:46 <andersca> @lojban hello 
23:20:47 <lambdabot> ERROR: 501 Syntax error, illegal parameters
