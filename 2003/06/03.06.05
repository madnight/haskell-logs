02:55:51 <dennisb_> Does anybody know why hugs prints this after evaluation? Elapsed time (ms): 0 (user), 10 (system)
02:55:57 <dennisb_> And how do I turn it off?
02:58:40 <creature> I know I've seen it before, but can't recall how to turn it off. 
02:58:41 <creature> Sorry.
03:00:38 <dennisb_> it's ugly, I want it to stop, now :-)
03:06:09 <dennisb_> hmm, seems like it's a compile time option
03:08:29 <creature> I think you can turn it on and off. 
03:08:33 <creature> I know I have. 
03:22:53 <dennisb_> I looked in the code and i'm pretty sure you can't turn it of. What you can turn on/off is that it prints the number of reductions
03:23:57 <creature> Ah, that may be what it was printing. :/
03:52:57 * shapr boings
03:53:01 <shapr> good morning #haskell!
03:53:10 <creature> Morning. 
03:56:44 <shapr> mmm, great quote from Andrew Cooke
03:57:18 <shapr> The idea isn't to blunder into a language looking for evidence to support a bunch of preconceived misconceptions.  the idea is to understand why things are the way they are. -- AndrewCooke
04:04:38 <creature> Hey Mike. :)
04:05:02 <mgoetze> hi alex :)
04:05:09 <mgoetze> sup?
04:05:15 <creature> Zope, Plone, Python. 
04:05:16 <creature> And laundry. 
04:05:19 <creature> You? 
04:06:08 <mgoetze> go, go and go :)
04:06:20 <creature> Heh. Done with exams for this year? 
04:06:39 <mgoetze> yesterday my local group, today the university group, tomorrow the chess cafe, and saturday-monday tournament
04:06:51 <mgoetze> oh, well, actually, haven't been studying this semester
04:07:05 <mgoetze> want to switch to math but it only starts in the winter term
04:07:30 <creature> Heh. What are you doing at the moment? CS? 
04:07:40 <mgoetze> CE
04:07:57 <creature> I see. 
04:08:38 <mgoetze> which was rather too much E for my taste, and not enough C :)
04:08:48 <creature> I take it that's like CSE? 
04:08:54 <creature> CSE -> Computer Systems Engineering.
04:09:15 <mgoetze> well, basically it's an engineering degree but you do lots of stuff with computers
04:09:22 <creature> Yeah.
04:09:49 <mgoetze> so you end up doing stuff like calculating how much weight a bridge can hold, etc.
04:11:38 <mgoetze> anyway, i found out that i really wasn't all that into engineering, and also that i was quite happy with the way my computer skills were going without some university telling me to learn java or whatever
04:12:05 <mgoetze> and that the fun part was the maths, so why not study that...
04:14:45 <creature> Sounds like a plan.
04:28:04 * shapr boings happily
04:29:15 * mgoetze gives shapr a cookie
04:29:34 * shapr chomps down the cookie
04:29:39 <shapr> mmmm
04:44:20 <shapr> I compiled the runtime loader with ghc5.04.2 yesterday, linking took more than twenty minutes.
04:44:39 * andersca bounces
04:47:00 <shapr> hi jofo 
05:20:45 * shapr bounces happily
05:20:46 <shapr> wheee
05:35:52 <shapr> geez, constructor classes rock
05:36:01 <shapr> do they exist in Haskell? or only in Gofer?
05:36:28 <shapr> I've tried to use typeclasses as constructor classes before.
05:43:12 <shapr> what's injection and projection in relation to a summand?
05:50:24 <cale> shapr: hmm... maybe take a look at the definition of coproduct and see if you can line up the concepts.
05:50:51 <shapr> ok, thanks
05:51:35 <cale> the arrows going from the summands to the coproduct object might be called projections (although it's more comfortable to say that with the product).
05:52:32 <cale> I don't really know. I've studied a bit of category theory, but I don't know what it is that you're looking at, so I don't know if it lines up at all.
05:52:48 <shapr> I'm reading http://www.cse.ogi.edu/~mpj/pubs/modinterp.html
05:53:18 <cale> alright, I'll have a look at it.
05:53:27 <shapr> it's spiffy stuff.
05:55:39 <cale> I find it really cool that category theory has found applications so quickly.
05:55:53 <shapr> I really don't understand category theory at all.
05:56:08 <shapr> but I have acquired pointers to some intro papers
05:56:10 <shapr> so maybe soon :-)
05:58:29 <cale> If you have access to a university library, pick up the yellow book by Mac Lane. It's decent. There's also another that I'd recommend, but I'm trying to recall the name.
05:58:50 <Smerdyakov> Why study category theory?
05:59:23 <shapr> Because it's the underpinnings of monads?
05:59:27 <cale> Because it is the ultimate abstraction.
05:59:33 <shapr> Because it's interesting mostly.
05:59:54 <cale> Most mathematical objects are categories.
06:00:49 <Smerdyakov> So? :-)
06:02:07 <cale> So by learning about categories, you are simultaneously learning about many things, and can form a viewpoint from which you can spot connections between otherwise seemingly unrelated areas.
06:02:34 <Smerdyakov> OK. Maybe I'll take a course in it some time.
06:02:57 <cale> So you can get a proof from one area and maybe move it to another area. That's the idea anyway.
06:05:09 <Smerdyakov> I think most of the interest is, in truth, from the same cause that makes people like gadgets, but OK. ;-)
06:06:34 <cale> Possibly. :) I'm a math student, so the reasons I'd have for studying it might be slightly different from a CS student's reasons, too.
06:07:22 <Smerdyakov> Well, I think the same reason is behind a lot of people's reasons for studying math.
06:07:40 <mgoetze> Smerdyakov: really? tell me more
06:08:56 <Smerdyakov> I think a lot of people study math, CS, and related areas for very "masculine" reasons.
06:09:06 <shapr> it makes my dick bigger?
06:09:06 <Smerdyakov> Wanting control and understanding, liking to play with "toys," etc..
06:09:12 <shapr> I disagree.
06:09:35 <cale> Well, I don't know too much about others, but I study math, I think, for probably the same reasons people study music, or art. Simply because I like it, and find it to be beautiful.
06:09:36 <shapr> well, hm, maybe you're right.
06:09:51 <mgoetze> studying math will make my dick bigger?
06:09:56 * mgoetze hurries to sign up
06:10:03 <shapr> mgoetze: no, not that :-P
06:10:09 <Smerdyakov> cale, have you ever introspected at length about it?
06:10:46 <shapr> my central motivation is twofold, I like to know why things work the way they do, and I like juggle concepts in my head to come up with new combinations.
06:11:05 <mgoetze> Smerdyakov: so what will studying math give me control over?
06:11:33 <shapr> Smerdyakov: does the 'masculine' stuff boil down to 'knowledge is power' ?
06:11:42 <Smerdyakov> mgoetze, if you believe that math is the foundation of everything, then it gives you control over the whole universe.
06:11:59 <Smerdyakov> shapr, maybe.
06:12:07 <mgoetze> Smerdyakov: yes, much like being a catholic will give you control of your afterlife
06:12:20 <mgoetze> Smerdyakov: however, i am not religious and still want to study math
06:12:26 <shapr> I think programming has the coolest toys.
06:12:38 <Smerdyakov> mgoetze, we're talking about subconscious feelings here. They don't have to make sense. It's the same as getting fast cars to try to appear more "in control" or whatever.
06:13:37 <mgoetze> oh. well, having studied wittgenstein, i think my feelings on the matter are anything but subconscious. but then, that's the point of studying wittgenstein and i'll agree that far too few people have done so. ;)
06:14:05 <Smerdyakov> So you don't think your feelings are based on wanting to control the world?
06:14:15 <cale> I don't believe that math gives me control over the whole universe. As soon as you try to actually prove something, anything of that form leaves your mind. It's a great feeling to prove something, but it becomes clear that things simply couldn't be any other way.
06:14:34 <mgoetze> Smerdyakov: uhm, nope, don't think so :)
06:14:46 <Smerdyakov> cale, I think in your "things simply couldn't be any other way," you give away your bias towards the kind of thinking I'm describing.
06:15:08 <cale> Like shining a light on a crystal - you get to see more of it, and it's beautiful, but it doesn't change it.
06:15:32 <Smerdyakov> cale, by the way, I study math farily heavily myself, so I'm not making entirely ignorant accusations.
06:25:23 <mgoetze> cale: but you fix them anyway?
06:25:23 <cale> I don't mean the "repair" sense of fix.
06:25:23 <Smerdyakov> shapr, ugh. I've taken a course where I was tested on understanding of it much deeper than that page gives.
06:25:23 <cale> I mean the "make constant" sense of fix.
06:25:30 <cale> Or "select"
06:25:31 <shapr> I haven't read that page, just the stuff in Hofstadter's book.
06:25:44 <Smerdyakov> shapr, these theorems already assume a lot about math.
06:26:01 <mgoetze> cale: so you don't think that every time you choose an axiom, you are limiting your horizons?
06:26:04 <Smerdyakov> shapr, they might even be proved in non-constructive logic. I'm not sure.
06:26:16 <shapr> what's significant about non-constructive logic?
06:26:43 <Smerdyakov> You can't compile its proofs into programs to give you witnesses to the truth of existential statements.
06:26:52 <cale> You're limiting your horizons, but you dont see very far without a telescope. :)
06:27:13 <shapr> today's toy is Gofer's constructor classes. If they don't exist in Haskell, I want them.
06:27:25 <shapr> I wanted them before, but didn't know their name.
06:27:47 <mgoetze> cale: so, you're performing a depth-first search of the logischer raum (however that's translated) :)
06:27:48 <cale> You pick some axioms, take that road a while and see where it goes. Once you're tired, try some other axioms.
06:28:03 <cale> Sort of.
06:28:12 <shapr> cale: have you read Brent Kirby's paper on concatenative combinators?
06:28:34 <shapr> sounds related to what you just said.
06:28:39 <cale> shapr: I don't think so, but I have an answer to your earlier question.
06:28:46 <shapr> yes??
06:28:56 * shapr wants more toys.
06:29:09 <cale> you're referring to the "subtype, supertype" thing?
06:29:11 * shapr sings along with Jimmy Eat World
06:29:13 <shapr> yes!
06:29:34 <shapr> I've seen the same stuff in Darius' lambda calculator, but I have no idea what it does.
06:29:38 <shapr> well, some idea
06:29:56 <shapr> the OR type programmatically makes union types (niftytrick)
06:29:57 <cale> The "injection" maps values from the subtype to the supertype - like an embedding. Similar to how the integers are a subset of the reals.
06:30:13 <shapr> aha
06:30:23 <cale> The projection maps values back to the subtype from the supertype if possible.
06:30:31 <shapr> umm
06:30:33 <shapr> huh?
06:30:45 <cale> i.e. 1::Real |-> 1::Integer
06:31:26 <shapr> I think I understand that.
06:31:41 <shapr> in the context of the paper, how does inj and prj work?
06:31:45 <cale> of course, they use Maybe here, because you can't map 3/2 to an integer for example.
06:31:52 <shapr> hmm
06:31:53 <mgoetze> Smerdyakov: so anyway, i think you have a lot of wittgenstein left to read :)
06:32:36 <shapr> the |-> is prj, yes?
06:33:09 <cale> That's bad ascii art for the standard math "maps-to" symbol, yes. 
06:33:20 <shapr> oh, I don't know much about math symbols
06:33:23 <Smerdyakov> mgoetze, I think I would have all of it, if I chose to read it, which would include agreeing that I need other people's approval to have a view of the world....
06:33:45 <shapr> I'm just a self-taught programmer.
06:33:58 * mgoetze understood about 0% of what Smerdyakov just said
06:34:18 <cale> Saying SubType Integer Rational say, requires you to define both how to take an Integer and map it to the corresponing rational value, and how to take rational values that happen to be integers and make them integers again.
06:34:23 <Smerdyakov> mgoetze, 1) I've never read Wittgenstein, so I'd have to read all of it if I wanted to.
06:34:33 <shapr> cale: what's a summand? is that the new programmatically produced union type?
06:34:39 <Smerdyakov> mgoetze, 2) I don't agree that it's important for me to read "famous philosophers" to have my own views.
06:34:42 <shapr> cale: OH
06:34:45 <shapr> that makes sense!
06:34:49 <cale> summand + summand = sum.
06:35:08 <shapr> oh that's easy enough once you know what it is.
06:35:10 <shapr> nifty
06:35:11 <shapr> thanks!
06:35:16 <cale> no problem
06:35:23 <mgoetze> Smerdyakov: 1) i don't see why 2) of course not, i'm just saying that wittgenstein has a lot of insight on the topics you seem to be interested in
06:40:22 <cale> See the diagram on page 9 involving the four arrows arranged in a box? Such diagrams come from category theory. I think one reason to study category theory is just to acquire the notation it brings. Commutative diagrams like that are fairly simple, but they don't have to get much more complicated in order to express some really interesting stuff effectively.
06:52:12 <cale> xml2 is cool: wget -q -O- http://www.slashdot.org/slashdot.rdf | xml2 | grep "item/title" | cut -d= -f2
07:00:43 <shapr> hiii Igloo 
07:01:13 <Igloo> Yo shapr
07:01:31 * Igloo has a lovely new blue carpet
07:01:49 <shapr> yay! do you have pix of your new carpet?
07:01:54 <Igloo> No  :-(
07:02:11 * Igloo also has a pile of old carpet that I can't persuade to magically move itself to the dump
07:02:14 <shapr> heh
07:12:28 <shapr> hi buggs
07:15:38 * shapr bounces happily
07:16:40 <Igloo> Written anything interesting lately, shapr?
07:17:04 <shapr> several emails to andrew cooke
07:17:15 <shapr> some Python code
07:17:19 <shapr> that's all today
07:17:34 <shapr> oh! do you know if Gofer's constructor classes are available in Haskell?
07:17:38 <shapr> they're *cool*
07:18:07 <shapr> I've been reading the Liang, Hudak, Jones paper; _Monad Transformers and Modular Interpreters_
07:18:09 <Igloo> What do they do?
07:19:03 <shapr> you can pattern match on a type constructor in a class method
07:19:22 <shapr> hm, can Haskel already do that?
07:19:42 * shapr quickly writes a prototype to check
07:20:09 * Igloo would need an example
07:20:33 <shapr> in the paper, they use it to implement map on a tree
07:23:46 <shapr> hmm
07:23:47 <steveh> goood morning
07:23:55 <shapr> goood morning steveh!
07:23:59 <shapr> instance Functor Tree where
07:23:59 <shapr>     fmap f (Leaf x)   = Leaf (f x)
07:23:59 <shapr>     fmap f (Node l r) = Node (map f l) (map f r)
07:25:08 <pesco> One thing I've been wondering: Why is there a seperate function map instead of just the Functor method (which could in the absence of current map be renamed to map)?
07:25:53 <pesco> blaeh, why does GHC take forever to compile?
07:26:24 <pesco> Life sucks.
07:26:50 <Igloo> That looks like valid Haskell, shapr
07:29:18 <pesco> shapr: But those are data ctors in the patterns...
07:30:29 * Igloo was wondering whether shapr meant the instance header
07:31:14 <Igloo> fmap could be written as fmap f x = case x of ... so disallowing it to be written as above wouldn't gain anything
07:40:53 <shapr> data Tree a = Leaf a | Node (Tree a) (Tree a)
07:41:23 <shapr> I thought typeclasses were limited to types rather than constructors?
07:42:23 <pesco> No.
07:42:24 <Smerdyakov> Why do you think the constructors are in the class instance?
07:42:45 <shapr> hm, I must be confused.
07:43:49 <steveh> Okasaki doesn't have remove functions in his set implementations.
07:44:08 <pesco> class Functor a where fmap :: (b -> c) -> a b -> a c
07:44:58 <pesco> shapr: So a functor must be a unary type constructor. Right?
07:45:17 <shapr> the code seems to work just fine.
07:45:27 <pesco> Yes, it's perfectly normal.
07:45:33 <shapr> neat
07:45:36 <pesco> Consider monads. They have an argument, too!
07:45:53 <pesco> class Monad m where return :: a -> m a ...
07:46:59 <pesco> instance Monad Maybe {-Maybe = m in the class decl, takes result type as arg-} where...
07:49:23 <cale> pesco: good question about fmap - I have no idea either.
07:50:10 <shapr> yes, I've wondered why there's fmap and map also
07:50:24 <Smerdyakov> map is probably optimized.
07:51:08 <shapr> hej andersca 
07:51:27 <andersca> hej
07:51:53 <cale> If the compiler had extra optimizations to do for the list implementation of map, I'm pretty sure it has enough information to detect this case, don't you think?
07:52:34 <cale> s/had/has/
07:52:53 <cale> @prelude fmap
07:52:55 <lambdabot> *** "fmap" prelude "Haskell Standard Prelude Dictionary": text follows
07:52:55 <lambdabot> fmap
07:52:55 <lambdabot>   instance (Ix a) => Functor (Array a) where
07:52:55 <lambdabot>     fmap = primAmap
07:52:55 <lambdabot>   class Functor f where
07:52:57 <lambdabot>     fmap ::  (a -> b) -> (f a -> f b)
07:52:59 <lambdabot>   instance Functor Maybe where
07:53:01 <lambdabot>     fmap f Nothing  = Nothing
07:53:03 <lambdabot> [there's @more]
07:53:07 <cale> @more
07:53:07 <lambdabot>     fmap f (Just x) = Just (f x)
07:53:07 <lambdabot>   instance Functor [] where
07:53:09 <lambdabot>     fmap = map
07:53:09 <Smerdyakov> Possible, but I don't know if it would, in the interest of reducing code size.
07:53:11 <lambdabot>   instance Functor IO where
07:53:13 <lambdabot>     fmap f x = x >>= (return . f)
07:53:29 <shapr> so, map is a subset of fmap?
07:53:41 <cale> fmap *is* map on the list type.
07:53:42 <steveh> map implements the Functor fmap over []
07:53:48 <steveh> is how I would put it
07:53:52 <cale> yeah
07:55:02 <steveh> [] is a functor by virtue of having an fmap defined, which happens to be the standard map function ?
07:56:29 <cale> Yeah, but why not call the list specific case something else (or not define it separately from the functor implementation at all) - it would seem reasonable to leave "map" as the nice general case that works on all functors.
07:56:41 <shapr> have you guys seen the nifty functor thread on haskell@haskell.org ?
07:56:56 <cale> nope - does it explain this?
07:57:15 <shapr> no, but it is about functors, fmap, folds, etc
07:57:40 <steveh> cale: probably because the "map" nomenclature is old.
07:57:52 <steveh> cale: it's in other FPLs as well I think
07:58:09 <steveh> cale: also the majority of maps are done on lists, I'll warrant
07:58:33 <cale> It wouldn't break anything though. [] is a functor, and would inherit map from its typeclass, so no code would break.
07:59:22 <cale> shapr: when did it occur?
07:59:56 <shapr> two days ago
08:00:04 <pesco> One would have to look out for functor people's functor instance decls breaking.
08:00:09 <shapr> Subject: Collecting values from Functors?
08:00:20 <pesco> But that could be avoided by leaving fmap in as a synomym for map.
08:00:29 <steveh> cale: from a quick browse of google groups, it used to be the way you are describing
08:00:48 <steveh> the first hit on "haskell fmap map" has the line
08:01:00 <steveh> "In older versions of Haskell fmap was called map , and other functions
08:01:00 <steveh> were similarly more overloaded. AFAIK currently map works only
08:01:00 <steveh> for lists for (1) more friendly error messages, especially as list
08:01:01 <steveh> processing is a good area for introducing to beginners, (2) less
08:01:01 <steveh> cases where an explicit type signature must resolve an ambiguity
08:01:01 <steveh> (of a type which is used internally through overloaded functions only,
08:01:03 <steveh> and does not appear in the type of the thing which uses it)."
08:02:15 <shapr> I wonder what the explicit type sig cases are about.
08:03:21 <steveh> another relevant comment
08:03:25 <steveh> "I think this one is historical:  map already existed before Haskell
08:03:25 <steveh> was powerful enough to type fmap, and the decision was not to affect
08:03:25 <steveh> existing programs too much.  Presumably Haskell 2 will have them
08:03:25 <steveh> merged."
08:03:34 <shapr> ah
08:03:42 <steveh> google groups is da bom
08:03:45 <shapr> yah, good stuff.
08:04:32 <cale> also, it would be nice if functor were a derivable type.
08:04:52 <shapr> hey, they just added Typeable, I'm thrilled.
08:05:04 <shapr> that cuts down on code in lambdabot.
08:07:08 <shapr> yow, that gmap stuff in that thread looks scary.
08:08:10 <cale> shapr: what are you looking at?
08:08:24 <shapr> the rest of that same thread.
08:10:14 <shapr> hi kawfee 
08:11:01 <Smerdyakov> Anyone know if there's an IRC channel for the Open Directory Project somewhere?
08:11:22 <shapr> have you asked chanserv?
08:11:36 <Smerdyakov> What do you mean?
08:11:50 <shapr> something like /msg chanserv list *dir*
08:12:41 <shapr> or maybe *odp*
08:17:47 <Smerdyakov> #odp is empty Optimized Debian Project =D
08:19:26 <Smerdyakov> I want to find out if the link I submitted was rejected, or if the editors are just slackers. :-(
08:23:14 <Smerdyakov> Oh, look, they approved it. :-)
08:27:06 <shapr> hi Logan 
08:53:40 <shapr> hiii Heffalump!
08:53:43 <shapr> wassup?
08:53:44 <Heffalump> 'lo
08:53:48 <Heffalump> stuff :-)
08:53:51 <shapr> is it the weekend already?
08:53:54 <Heffalump> nope
08:54:01 <Heffalump> but I haven't been here for lots of weekends either
08:54:04 <shapr> that's true.
08:54:21 <shapr> I've been wondering if you were abducted by procedural programmers or something.
08:55:00 <shapr> Have you written any Haskell lately?
08:55:20 <Heffalump> not that I can remember :-(
08:56:10 <shapr> What sort of stuff are you doing?
08:56:32 <Heffalump> usual SML stuff
08:59:15 <shapr> have you seen the ghc6 announcement?
09:00:14 <Heffalump> yep
09:00:36 <Heffalump> just waiting for it to appear in Debian :-)
09:01:11 <shapr> SyntaxPolice has tried to contact michaelw
09:01:16 <shapr> I'd like to see ghc6 in debian also.
09:27:01 <shapr> hey Logan, can I contribute my xmms-shell.el to the xmms-shell distro?
10:36:29 <d33p> is it possible to declare a function that takes no argument?
10:37:13 <esap> d33p: any value will do. Or you could use () as the argument type.
10:37:50 <d33p> esap: so would it be it like func :: () -> someType ? 
10:38:05 <esap> d33p: like that, or f :: someType.
10:38:17 <d33p> esap: okay, thankyou. 
10:38:54 <esap> d33p: if you declare it with func :: () -> someType, then you actually have to apply it (with () as argument)
10:39:29 <d33p> esap: okay
10:41:46 <Darius> d33p, a function of no argument would be a constant
10:41:57 <d33p> Darius: yes, thats what i was trying to implement :)
10:42:13 * esap thinks implementing constants is actually not that simple thing :-)
10:42:45 <d33p> iam a newbie.. so iam bound to make some false starts 
11:12:47 * shapr boings
11:21:54 * Riastradh unboings
11:22:39 <shapr> hi Riastradh 
11:22:43 <shapr> guten abend kosmikus 
11:22:47 <Riastradh> Hi.
11:25:31 <kosmikus> hoi shapr
11:25:44 <shapr> hoe gaat?
11:25:45 <shapr> wie geht?
11:25:58 <kosmikus> just installing a new machine in my office
11:26:04 <shapr> oooh, new hardware
11:26:09 <shapr> will you be able to build GHC faster?
11:26:14 <kosmikus> I hope so
11:26:21 <shapr> how fast?
11:26:24 <kosmikus> it just compiles ...
11:26:25 <shapr> is it SMP?
11:26:42 <kosmikus> nono, it is not very good, but better than my old Sun ...
11:27:27 <kosmikus> now I finally have two Linux computers, so I can compile on one, work on the other :)
11:30:25 <shapr> yay!
12:00:24 <d-bug> kosmikus: use FreeBSD instead so background compiles are not noticeable
12:01:42 <d-bug> it sounds silly, i know, but freebsd excels at multitasking
12:04:37 <buggs> d-bug, the vm, scheduler and interrupt handling, is more balanced in fbsd
12:04:52 <d-bug> i know
12:05:00 <buggs> but i heard they fixed some of that in lunux 2.5
12:05:55 <d-bug> yes, 2.6 will be good, and after a few releases it will probably be tuned into something much better
12:06:50 <buggs> after the 2.4 (imho 2.4.18 was last useable) series i think i will switch rather fast, even on the servers
12:08:35 <d-bug> i'm older and more lazy these days, that's why I decided to run debian after 5 years of fbsd
12:11:22 <buggs> you could have run freebsd from packages only, really a charm with portupgrade (though debian might be even more for the lazy ones ;)
12:11:52 * shapr is a happily lazy Debian user.
12:15:35 * esap thinks laziness is a virtue.
12:16:01 <shapr> laziness, hubris, forgetfulness.
12:16:03 <shapr> um. no.
12:16:12 <shapr> impatience, I think.
12:16:14 <shapr> Hi Esa
12:16:19 <esap> Hi!
12:16:27 <shapr> How's the code treating you?
12:17:19 <esap> still only 21 out of about 35 files compile :-(
12:18:02 <esap> But it's progressing at a steady pace.
12:18:06 <shapr> that's good.
12:19:13 * esap has 12kLOC of code, and it's notoriously hard to get to compile.
12:21:49 <shapr> I haven't written much Haskell lately.
12:31:38 <shapr> has anyone seen a diff written in Haskell?
12:32:03 <shapr> hm, actually... maybe I could use HXmlToolbox for my evil plan.
12:42:29 <keverets> I've got to deal with some Xml documents (a subset of Xml, described by a DTD).  I've looked at HaXml a little... what do people here think of the various Xml toolboxes for Haskell?
13:10:38 <stepcut> I have played with HaXml, its pretty good ...
14:38:42 <Heffalump> is it just me, or did someone just send a virus to the Haskell list with a question about Category Theory at the top?
14:51:15 <juhp> Heffalump: yea, looks like it ;)
14:51:57 <juhp> might be caused by some virus of course...
14:52:15 <Heffalump> and there was me thinking it was a comment on Category Theory...
14:57:47 <Darius> The virii are getting smarter.
15:46:14 <tootalltimmy> In Haskell can I create a list of differently typed elements that are all instances of the same class?  For example, I'd like to create a list of elements that all support the Show class.
15:46:42 <Darius> You can't in Haskell 98
15:47:25 <tootalltimmy> Darius: Thanks.  Here's where I admit that I'm a C++ programmer and that they really like doing that sort of thing.
15:47:44 <Darius> I'm a C++ programmer.
15:47:53 <tootalltimmy> Cool.  Then you feel my pain?
15:48:08 <tootalltimmy> Is there a more Haskell-ish idiom?
15:48:25 <cale|afk> what are you trying to do?
15:48:51 <tootalltimmy> I'm just taking a tour of the language and seeing what it can do.  
15:49:24 <tootalltimmy> I guess I'm trying to translate my C++ techniques into Haskell.  That's probably not the wisest thing to do but...
15:49:55 <tootalltimmy> After all, C++ to Haskell is a paradigm shift and a half, from what I can tell already.
15:50:12 <cale|afk> Yes.
15:51:02 <tootalltimmy> Thanks all!
15:51:06 <cale> Well, I suppose you could show the elements before making them into a list.
15:51:50 <cale> it's not the same, but if that's all that's common between the different elements, that's about all you could do with a list of them anyway.
15:52:02 <Darius> In that case there isn't much reason not to show them first a string now or a string later won't make a difference.
15:52:28 <Darius> Though it could for space usage I guess.
15:53:23 <cale> hmm... would it, or might lazy evaluation save the day there?
15:53:47 <Darius> Lazy evaluation would only save the day the first time.
15:54:19 <Darius> print theList; do other stuff; do something with the list.
15:55:10 <cale> Yeah.
15:55:32 <Darius> tootalltimmy: One way you could get something close is with existential types.
15:56:18 <Darius> (they aren't Haskell 98 hence my original statement)
15:56:54 <tootalltimmy> I'll check that out.  Thanks!
15:59:44 <Heffalump> why do you actually want to do this?
16:00:05 <Heffalump> (there may be a better way of solving the same problem)
16:00:20 <cale> Heffalump: I think he's mostly just playing around with the language.
16:18:00 * Igloo reads scrollback and worries that viruses are closer to understanding category theory than I am
16:22:54 <Igloo> Ho humm, surely there is some nice way of doing what sequence does for pairs
16:24:44 <Darius> It's a little iffier.  Which should be done first?
16:43:22 <Heffalump> igloo: TH, surely?
16:43:43 <Heffalump> do you mean homogeneous or heterogenous pairs?
16:43:46 <Igloo> Not in THSyntax.hs (yet)
16:43:54 <Heffalump> what aren't?
16:43:59 <Igloo> Does it matter?
16:44:09 <Igloo> That's where I want to do it
16:44:16 <Heffalump> oh, I guess not
16:44:34 <Heffalump> do what?
16:44:48 <Igloo> What sequence does for pairs
16:45:42 <Heffalump> YM you can't use TH in THSyntax.hs, because of a bootstrap problem?
16:45:59 <Heffalump> you could just write seqtuple, of course
16:46:24 <Igloo> Yes
18:16:59 <joifu> @minimax
18:16:59 <lambdabot> Sorry, I don't know the command "minimax", try "lambdabot: @listcommands"
18:17:05 <joifu> @listcommands
18:17:05 <lambdabot> I react to the following commands: ["all-dicts","board","define","definitions","del-definition","devils","dict","dict-help","dump","easton","echo","elements","eval","fact","flip-board","foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","lojban","more","msg","part","ply","prelude","quit","reset-chess","resume","set-fuel","st
18:17:21 <Pseudonym> @foldoc minimax
18:17:58 <Pseudonym> Erm.
18:18:15 <keverets> @jargon minimax
18:18:27 <Pseudonym> lambdabot is hung.
18:18:32 <Pseudonym> Don't load it up with stuff.
18:18:33 <joifu> isnt there an actual minimax function?
18:18:35 <keverets> now you did it ;)
18:18:48 <Pseudonym> Possibly the dict server is offline or something.
18:19:05 <Pseudonym> Is there?
18:19:18 <joifu> no idea :O
18:19:19 <Pseudonym> There's something in nofib.
18:19:28 <Pseudonym> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/nofib/parallel/minimax/
18:19:31 <joifu> im at the zvon website
18:19:33 <Pseudonym> That might help.
18:19:40 <joifu> it doesnt have it in the index
18:20:31 <lambdabot> ERROR: timeout
18:20:31 <lambdabot> Action: connect
18:20:31 <lambdabot> Reason: Connection timed out
18:20:39 <Pseudonym> There you go.
18:20:54 <Pseudonym> shapr: Install a local dict server!
18:21:20 <Pseudonym> http://www.mail-archive.com/haskell@haskell.org/msg11341.html
18:21:24 <Pseudonym> That also looks interesting.
18:23:40 <lambdabot> ERROR: timeout
18:23:40 <lambdabot> Action: connect
18:23:40 <lambdabot> Reason: Connection timed out
18:24:15 <Pseudonym> @yow
18:24:16 <lambdabot> MMM-MM!!  So THIS is BIO-NEBULATION!
18:24:20 <Pseudonym> We live!
18:24:22 <joifu> ummm
18:24:28 <joifu> but the minimax.hs
18:24:34 <joifu> its in german lol
18:24:45 <Pseudonym> Yeah, but the code looks pretty self-explanatory.
18:25:01 <Pseudonym> If you know what Schwarz and Weiss mean, anyway.
18:25:08 <joifu> no i dont
18:25:36 <Pseudonym> black and white
18:26:35 <Darius> Damn HaXml aux.dtd.
18:30:11 <joifu> Schwarz -> -- absteigend sortieren (d. h. größtes zuerst)
18:30:11 <joifu> 	          sortFstBy (flip compare) $ ( minfty, Nothing ) : opts
18:30:11 <joifu> 	      Weiss   -> -- aufsteigend (kleinstes zuerst)
18:30:11 <joifu> 	          sortFstBy compare        $ ( pinfty, Nothing ) : opts
18:30:21 <joifu> anybdoy tell me what that means?
18:30:55 <Pseudonym> If you delete the contents, and translate Schwarz as Black and Weiss as White, it actually makes quite a bit of sense. :-)
18:31:07 <Pseudonym> Note sortFstBy sorts a list of pairs by the first element.
18:31:24 <Pseudonym> Sorry, delete the _contents_.
18:31:32 <Pseudonym> You know how minimax works, right?
18:31:38 <joifu> nop :(
18:31:41 <Pseudonym> Ah.
18:31:52 <Pseudonym> OK, we'll assume a two-player game with perfect information.
18:32:14 <Pseudonym> So it's not like canasta or poker, where you don't have access to some information.  It's more like tic-tac-toe or chess.
18:32:32 <joifu> can we use chess
18:32:38 <Pseudonym> It's also two-player.  Three+-player games are harder because players can collude.
18:32:42 <Pseudonym> OK, chess.
18:33:00 <Pseudonym> Assume for a moment that each board has some kind of "value", which is how good the position is for you.
18:33:12 <joifu> yup
18:33:18 <Pseudonym> We don't know what this value is at the moment, but we'll get ther.
18:33:35 <Pseudonym> OK, you can always win chess by making the move which maximises the value of the board.
18:33:53 <Pseudonym> Right?
18:34:14 <joifu> yeh
18:34:18 <Pseudonym> Right.
18:34:21 <joifu> but its not always the best move
18:34:25 <Pseudonym> Yes it is.
18:34:36 <Pseudonym> Remember, we don't know how to compute the "value".
18:34:43 <Pseudonym> It could be a horribly complex function.
18:34:49 <joifu> what i mean is, what appears to be best move NOW, isnt the best move for the long run
18:34:56 <joifu> okok i'll shut up :O
18:35:13 <Pseudonym> Right, in which case some other move is actually best.
18:35:32 <Pseudonym> This notion of "value" takes into account which moves will lead you to a win (or draw, if a win is impossible).
18:35:49 <Pseudonym> Or, I suppose the least-worst defeat. :_)
18:35:56 <Pseudonym> ANyway.
18:36:13 <Pseudonym> So all you have to do is make the move which maximises this value.
18:37:00 <Pseudonym> So what's the value of the board _before_ you make your move?
18:37:12 <joifu> err...
18:37:14 <Pseudonym> Assuming you play perfectly, it's the value of the board after you make the best possible move.
18:37:15 <Pseudonym> Right?
18:37:28 <joifu> wait
18:37:46 <joifu> <Pseudonym> So what's the value of the board _before_ you make your move? <-- values gunna be LESS than ur next move?
18:37:55 <Pseudonym> No.
18:38:04 <Pseudonym> Let's assume it's your move.
18:38:24 <joifu> oki
18:38:29 <Pseudonym> OK, let's assume a perfect "value" function.
18:38:35 <Pseudonym> value :: Board -> Int
18:38:51 <Pseudonym> value board | canAlwaysWin board = 100
18:39:00 <Pseudonym>             | mustLose board = -100
18:39:07 <Pseudonym>             | otherwise = 0  -- draw case
18:39:27 <Pseudonym> The implementation of "canAlwaysWin" and "mustLose" we will leave for now.,
18:39:35 <Pseudonym> We'll get back to those later.
18:40:15 <Pseudonym> If you can make a move which will result in you always winning, then the value of the board before you make your move is that you can always win.
18:40:24 <Pseudonym> Right?
18:40:48 <joifu> yeh i guess
18:41:06 <Pseudonym> For the "real" implementation, incidentally, this "value" function is going to be an approximation.
18:41:23 <Pseudonym> Because clearly implementing canAlwaysWin and mustLose are, in general, going to be intractible.
18:41:36 <joifu> intractible meaning ...?
18:41:52 <Pseudonym> Meaning can't be computed exactly using a reasonable amount of computing resources.
18:42:30 <joifu> ok
18:42:45 <Pseudonym> I meant to spell that "intractable".
18:42:49 <Pseudonym> Anyway.
18:43:14 <Pseudonym> OK.  So the "value" of the current board is the value of the board after you make the best move.
18:43:34 <Pseudonym> So you can compute the value of the current board by considering all moves, evaluating the value of the board after the move, and picking the best one.
18:43:39 <Pseudonym> The one that maximises the value.
18:43:44 <Pseudonym> With me so far?
18:44:04 <Pseudonym> That also, incidentally, gives you the best move to make (which is clearly the one you _should_ make).
18:44:05 <joifu> yeh
18:44:07 <Pseudonym> OK.
18:44:19 <Pseudonym> Now let's assume it's the opponent's move.
18:44:39 <Pseudonym> The reasoning here is exactly the same, except your opponent is going to try to _minimise_ the value of the board.
18:45:04 <joifu> yup
18:45:07 <Pseudonym> Right.
18:45:30 <Pseudonym> So back to when it's your move.
18:45:44 <Pseudonym> You can compute the best move by evaluating the value of the board after all possible moves.
18:46:07 <Pseudonym> And you can compute those values by evaluating the value of the boards after all of _their_ possible moves and minimising.
18:46:32 <Pseudonym> In general, you act to maximise the value and they act to minimise the value. Hence, minimax.
18:46:46 <Pseudonym> With me?
18:47:25 <joifu> hmm
18:47:30 <joifu> not the hence minimax bit
18:47:37 <Pseudonym> Well that's where the name comes from.
18:47:58 <Pseudonym> You evaluate the game tree by alternately minimising and maximising the value of the board.
18:48:50 <joifu> u mean
18:48:57 <joifu> maximising it after minimising it
18:48:59 <Smerdyakov> I haven't been following this conversation, but I doubt IRC expositions beats even a large fraction of descriptions of minimax available on the web....
18:49:07 <Pseudonym> Very possibly.
18:49:11 <Pseudonym> But I'm bored.
18:49:13 <Pseudonym> :-)
18:49:23 <joifu> so let me get this straight
18:49:33 <Pseudonym> Any "introduction to AI" textbook should have a good explanation, too.
18:49:40 * Pseudonym won't get into alpha-beta pruning here, though
18:49:45 <Pseudonym> go on.
18:50:21 <joifu> minimax tries to get the best move by minimising the value in the opponents shoe, assuming thats the move that the opponent is going to make, and then makes MY best move according to that?
18:50:38 <Pseudonym> Right.
18:50:57 <Pseudonym> It works because if the opponent makes any other move, the value of the board is going to be at least as good for you.
18:51:01 <joifu> but wouldnt u need to assume that ur opponent is not stupid too?
18:51:04 <Pseudonym> Possibly better.
18:51:16 <joifu> ahh
18:51:41 <Pseudonym> If you evaluate the game tree right down to all possible final outcomes, you will play perfectly.
18:51:52 <Pseudonym> Unfortunately, the game tree for chess is very, very big.
18:52:08 <Pseudonym> For tic-tac-toe it's very small.
18:52:11 <joifu> somebody here made that game of chess on lambda bot
18:52:15 <joifu> what the heck is tic tac toe
18:52:20 <reltuk> depends on how big your tic-tac-toe board is  :-p
18:52:25 <Pseudonym> True!
18:52:29 <tez> noughts-and-crosses
18:52:35 <joifu> ic
18:52:39 <reltuk> anyway, chess branching looks like childs play compared to go   :)
18:52:44 <joifu> go?
18:52:49 <Pseudonym> Someone has evaluated the entire game tree for "connect 4".
18:52:51 <tez> Japanese game.
18:52:55 <Pseudonym> Apparently it's a theoretical first player win.
18:53:01 <tez> Yeah, it is.
18:53:14 <tez> I've got some windows program that plays the strategy.
18:53:19 <reltuk> I think chess is a theoretical draw...but we don't really know
18:53:28 <joifu> hmm
18:53:32 <Pseudonym> We'll never know, IMO.
18:53:48 <Pseudonym> That's what makes the game so interesting!
18:53:50 <reltuk> go is probably a win to the first player
18:53:55 <joifu> reltuk - in ur definitions, im certainly a newborn baby
18:53:58 <joifu> :O
18:54:06 <Pseudonym> Anyway.  Back to minimax.
18:54:10 <reltuk> which is why there's a 7.5 point handicap at master level play
18:54:29 <Pseudonym> Since you can't really evaluate the game tree right to the end in general, you use an approximation to "value".
18:54:30 <joifu> MINIMAX!
18:54:45 <Pseudonym> And you evaluate the game tree down to a certain depth.
18:54:46 <reltuk> but yeah, if you're looking for 2 million dollars, write a go ai that can beat a master...that's the current prize pool for it
18:54:52 <Pseudonym> So, for example, you might look 10 moves ahead.
18:54:56 <joifu> but is it best to use trees for board games like chess n stuff?
18:55:07 <Pseudonym> Well, that's hard to say.
18:55:24 <Pseudonym> "Real" computer game players use game-specific stuff to try to avoid evaluating a lot of the tree.
18:55:24 <reltuk> trees are the natural structures which represent progressive moves
18:55:32 <Pseudonym> Yes, reltuk is right there.
18:55:51 <joifu> but
18:55:52 <reltuk> a node represents a position, and all the children are all the possible positions that could result from one move given the parent position
18:56:10 <joifu> that gets exponentially large as the board gets larger n larger
18:56:24 <Pseudonym> Yes it does, which is why you try to avoid storing it all.
18:56:36 <reltuk> it depends on movement rules, but yeah, in general it grows hella-fast
18:56:37 <Pseudonym> Assuming your opponent is any good, for example, means you only have to keep their best moves around.
18:56:59 <joifu> but what if u assume ur opponent is stupid who only knows how to make forward moves?
18:57:06 <Pseudonym> Using alpha-beta pruning means that you can often avoid evaluating whole subtrees.
18:57:23 <joifu> how/why
18:57:36 <Pseudonym> Google is your friend.  Look it up.
18:57:43 <Pseudonym> It's hard to explain without a whiteboard.
18:57:56 <Pseudonym> Writing tree diagrams in IRC is difficult at the best of times.
18:57:56 <joifu> Googling it ey! :O
18:58:12 <joifu> only if uni lecturers and tutors could be more helpful
18:58:13 <joifu> :O
18:58:15 <reltuk> basically, you take shortcuts like, if a position is really bad for white directly after a move, then it's bad for white for all that positions children as well
18:58:16 <Darius>  @tree!
18:58:50 <reltuk> so you don't spend any time on that branch
18:59:02 <reltuk> that's an oversimplification...but that's the general idea
18:59:05 <joifu> i see
18:59:44 <Pseudonym> You keep around the values of some of the moves you've considered, and sometimes you'll find a subtree early on which you can prove is definitely going to be worse than anything you've tried so far.
19:00:27 <Pseudonym> The values are called alpha and beta, hence the name.
19:00:36 <joifu> alpha = good, beta = bad?
19:00:41 <Pseudonym> Something like that.
19:00:57 <joifu> u mean as in
19:01:04 <joifu> subtrees of MY moves or my opponents?
19:01:07 <Pseudonym> alpha is the value of the best move you can make and beta is value of the best move the opponent can make
19:01:12 <Pseudonym> Or something.
19:01:47 <Pseudonym> Real chess programs also try to think a bit more like grandmasters.
19:02:09 <joifu> like that IBM Blue?
19:02:14 <Pseudonym> Real chess grandmasters generally don't search widely on the game tree.  They have an intuitive feel for which moves are good and prefer to expand good moves "down" the tree.
19:02:44 <Pseudonym> Ooh, controversy.
19:02:50 <Pseudonym> Nobody really knows how deep blue worked.
19:03:03 <keverets> they just have a good (fuzzy) evaluation function
19:03:12 <joifu> not even the people that made it? :O
19:03:13 <Pseudonym> In fact, Kasparov accused the IBM team of interfering during one match.
19:03:26 <reltuk> he never said that
19:03:34 <Pseudonym> True, he never actually accused them.
19:03:35 <reltuk> he just said he didn't think a computer would make that move
19:03:39 * Pseudonym nods
19:03:45 <joifu> yeh but then
19:03:50 <joifu> wouldnt u think
19:03:54 <joifu> if its a human
19:04:05 <joifu> then he definitely wouldnt be able to beat Kasparov anyway?
19:04:13 <Pseudonym> Not necessarily.
19:04:24 <reltuk> no, if it was multiple humans with computer aid, they would have whooped him
19:04:26 <Pseudonym> The combination of a good player and a computer might be able to beat a grandmaster.
19:04:26 <joifu> unless its another Chess Master
19:04:47 <joifu> ic
19:04:51 <reltuk> but I think deep blue was real...he had so much processing power...
19:04:59 <joifu> but whats the point of creating Deep Blue
19:05:06 <joifu> to illustrate AI?
19:05:14 <Pseudonym> To promote IBM, I think.
19:05:20 <reltuk> just recently kasparov played a computer that was less than half of the machine deep blue was, and he came out tied
19:05:24 <Pseudonym> To sell RS/6000s.
19:05:39 <Pseudonym> reltuk: That's true, but the program was a lot better.
19:05:41 <Pseudonym> We think.
19:05:50 <joifu> whats RS6000s?
19:05:58 <tez> An IBM product...
19:06:02 <reltuk> Pseudonym : obviously, or it wouldn't have tied him   ;)
19:06:05 <Pseudonym> Deep Blue was a suitably programmed RS/6000, from memory.
19:06:38 <reltuk> Pseudonym : who's "we"?
19:06:38 <Pseudonym> Deep Fritz, the more recent player, was actually running on a standard SMP PC.
19:06:46 <Pseudonym> reltuk: Royal plural.
19:06:52 <joifu> but what good is a program that only knows how to play chess?
19:07:03 <reltuk> heh, thought maybe ya wrote it   *g*
19:07:13 <Pseudonym> joifu: That's an excellent point.
19:07:23 <Pseudonym> And it highlights the concerns that I have with AI research.
19:07:29 <reltuk> joifu : that's a good point...lots of money spent in making computers play chess...kinda weird
19:07:47 <joifu> u cant call it AI unless it can do what real intelligence does: Learn.
19:07:50 <Pseudonym> If you ask Kasparov, he'll tell you that chess is a field where computers and humans have no inherent advantage.
19:08:23 <Pseudonym> joifu: Here's a can labelled "worms" and a tin opener.  You do what you think is best.
19:08:38 <keverets> minsky just had a rant about ai.
19:08:41 <Pseudonym> :-)
19:08:47 <Pseudonym> The history of AI goes like this.
19:08:58 <Pseudonym> Person A: It requires intelligence to do task X.
19:09:09 <Pseudonym> Person B: [hack hack hack] OK, I've written a program which does X.
19:09:17 <keverets> http://www.wired.com/news/technology/0,1282,58714,00.html
19:09:18 <Pseudonym> Person A: Oh, I guess that didn't require intelligence after all.
19:09:28 <Pseudonym> Person A: What about task Y?
19:09:32 <Pseudonym> [wash, rinse, repeat]
19:09:45 <joifu> just say
19:09:46 <joifu> make a program
19:10:00 <joifu> that can do X y Z and a b c d and this that and whatever at the same time
19:10:39 <Pseudonym> One of these days, someone is going to learn that it doesn't require intelligence to be human. :-)
19:11:02 <Darius> Look at all the people who get by without it.
19:11:02 <joifu> having intelligence just means u have the most valuable ability: Learning
19:11:19 <joifu> if that "thing" cant learn, its not 'intelligent'
19:11:22 <Pseudonym> joifu: No it doesn't.  People write programs which learn all the time.
19:11:29 <joifu> really?
19:11:32 <joifu> in all sorts of applications
19:11:35 <Pseudonym> Gzip learns the properties of your file in order to compress it.
19:11:38 <joifu> and circumstances?
19:11:39 <Pseudonym> To pick but one.
19:11:54 <Pseudonym> Look up "case-based reasoning" some time.
19:12:09 <Pseudonym> Case-based reasoners not only learn, but they can also get bored, if they have to.
19:12:44 <Pseudonym> Say, if you're looking for documents on some topic, a case-based parser can skim if it looks like the document is going to be no use.
19:20:38 <Smerdyakov> Ooo
19:22:01 <Pseudonym> Ooh?
19:35:19 <jofo> tks alot pseudo
19:35:41 <joifu> gotta head off, take care
23:49:43 <d-bug> morning
23:57:05 <Pseudonym> G'day.
