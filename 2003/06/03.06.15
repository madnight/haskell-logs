03:05:31 * shapr yawns
03:05:36 * andersca bounces
03:05:40 * shapr boings
03:05:49 * andersca is in dublin now
03:05:51 <Marvin--> shapr: apparently I need a nocd crack to get war3 working in wine...
03:05:53 <shapr> nifty!
03:06:01 <shapr> Marvin--: that sucks :-/
03:06:03 <Marvin--> (I've managed to do the *installation* but it hangs when I try to start it)
03:06:15 <shapr> what was the secret for the installation?
03:06:37 <Marvin--> don't get me started... you need some win98 dlls and shit
03:06:55 <shapr> weird
03:07:51 <Marvin--> I basically followed this: http://www.transgaming.com/showthread.php?msg=11638&forum=6&thread=11638  but I also had to read and use lots of hints from  
03:07:54 <Marvin--> http://appdb.winehq.org/appview.php?appId=897&versionId=1177
03:09:40 <Marvin--> so now I need a nocd crack but I'm hopelessly worthless at finding cracks
03:10:48 <Marvin--> all I can find is german porn sites
03:11:13 <shapr> yuck
03:11:53 <shapr> hi Tony__ 
03:11:58 <Tony__> hiya
03:12:08 <shapr> are you learning Haskell?
03:12:32 <Tony__> nah, thought I'd pop in and see if Simon was around
03:12:40 <shapr> oh
03:12:49 <Marvin--> Simon or Simon? :)
03:12:52 <shapr> which Simon?
03:12:56 <shapr> or Simons?
03:14:19 <Tony__> Simon FreeBSD/x86
03:14:51 <sjj> Marvin--: maybe try here: http://awpost.com/games/pc_warcraft_3_roc.shtml (although i'm not sure if they have any)
03:15:00 <shapr> hi sjj 
03:15:02 <shapr> how's code?
03:15:13 <sjj> shapr: hey ;)
03:15:17 <sjj> shapr: studying for exams ;(
03:15:22 <shapr> yay
03:15:28 <Marvin--> sjj: it seems a friend had it
03:15:49 <Marvin--> sjj: I seemed to remember installing war3 for him, so it was a good guess that he had a crack :P
03:15:50 <Tony__> shapr: Does Simon use this channel ever?
03:15:55 <shapr> Marvin--: awesome air show in Luleå yesterday, Viggens, Grippens, F16s, F15s, lots of stuff.
03:16:01 <sjj> Marvin--: :)
03:16:04 <andersca> shapr: cool
03:16:29 <shapr> Tony__: Peter Simons shows up here occasionally, Simon Peyton-Jones and Simon Marlow have been here once many months ago.
03:16:49 <shapr> Those are all the Haskell Simons I can think of off the top of my head.
03:16:59 <andersca> Marvin-- still needs to yell at koen
03:16:59 <andersca> :)
03:17:32 <sjj> what about Simon Thompson?-)
03:17:33 <Marvin--> I do?
03:18:15 <Marvin--> ugh, "progress", now it doesn't hang, but I get a GL error
03:19:06 <shapr> yay
03:21:40 <Marvin--> WOOH
03:21:44 <Marvin--> I got it running!
03:21:47 <shapr> yay!
03:21:57 <shapr> did you find the nocd crack?
03:21:59 <Marvin--> can't get the campaigns going (no buttons :P) but I'm playing a custom game right now
03:22:16 <Marvin--> and it's really trippy, I can't tell *any* speed difference to windows *at all*
03:22:23 <shapr> wow
03:22:25 * sjj wishes he had a computer powerful enough to run WC3 ;)
03:22:55 <Marvin--> this works even better than SC!
03:22:55 <shapr> sjj: what do you have?
03:23:19 <sjj> 466
03:23:47 <shapr> I've been playing wc3 on a 400 for weeks
03:23:56 <sjj> oh?!
03:24:08 <shapr> it lags painfully occasionally
03:24:12 <sjj> does it require a decent graphics card?
03:24:15 <d-bug> sjj: WC3 was hardly playable on my old 366MHz Celeron + Vodoo3 2000, but ran like a dream on a Athlon XP2000+ with the same old Vodoo3 2000 card
03:24:38 <shapr> I'd like to try it on my dualie with a geforce4
03:25:18 <sjj> i'll need a new box when DX2 comes out ;)
03:25:40 <shapr> deus ex?
03:25:45 <sjj> yeah.
03:29:50 <Marvin--> this is really trippy :-P
03:47:18 <Marvin--> hrrm
03:47:30 <Marvin--> copying a profile from windows made me able to start the campaigns, but it hangs somewhere
03:49:09 <Marvin--> damn!
03:56:08 * shapr boings
03:56:30 <Marvin--> weird, now I just get a black screen whenever I start it
03:56:49 * andersca booms
04:06:09 * shapr sparsk
04:08:30 <Marvin--> question is, can I be bothered to reinstall the damn thing
04:08:44 <robert_> hello, anyone know whether something like (\ g f -> (\ x y -> g $ f x y)) exists in the Haskell libraries?
04:09:00 <robert_> sort of (.) for two argument functions
04:09:17 <Marvin--> no, but there is a tricky way of doing it that I don't remember
04:11:17 <Heffalump> \g -> ((g.).)
04:11:43 <robert_> nice
04:12:03 <Heffalump> just keep adding (   .) around the outside if you want more arguments
04:12:34 <Marvin--> ah, nice
04:12:39 <robert_> thanks!
04:14:50 <Marvin--> the wonders of partial application
04:17:56 <Heffalump> oh, you can also write it as
04:17:58 <Heffalump> (.).(.)
04:19:28 <bojohan> :( i was just going to say that!
04:19:53 <shapr> hej bojohan 
04:19:59 <bojohan> hi
04:20:02 <shapr> hur är det med dig?
04:20:10 <bojohan> jotack, bra.
04:20:51 <shapr> are you new to Haskell? or a long-time user?
04:21:03 <shapr> (no one expects the functional inquisition)
04:21:05 <bojohan> hur funkar den där lambdabot:en?
04:21:07 <Heffalump> presumably reasonably experienced if he worked out (.).(.) for himslef :-)
04:21:18 <shapr> Heffalump: good point.
04:21:28 <shapr> bojohan: det funkar bra :-)
04:21:37 <Heffalump> why are you talking about bras?
04:21:38 <shapr> vill du ha dena sources?
04:21:57 <shapr> it's one of those mysterious things guys will never understand.
04:21:57 <bojohan> är den programmerbar?
04:22:12 <shapr> what's a programmerbar?
04:22:12 <bojohan> för oss, alltså?
04:22:29 <bojohan> can we program it?
04:22:35 <shapr> sure
04:22:38 <shapr> write a plugin
04:22:40 <shapr> @fact source
04:22:40 <robert_> and the next one's (.)((.).(.))(.)  :)
04:22:41 <lambdabot> http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/lambdabot/
04:22:52 <shapr> speaking of bras... isn't that ascii art for...
04:22:59 <bojohan> can i do it right at the prompt?
04:23:40 <shapr> the only part of lambdabot that you can interactively program while it's running is the @eval plugin definitions
04:23:40 <Heffalump> isn't it just (.).(.).(.) ?
04:24:21 <robert_> seems to work too
04:24:23 <shapr> @get-definition first
04:24:23 <lambdabot> first = head
04:24:24 <Heffalump> oh, same thing
04:24:39 <Heffalump> first is not head, first is all but the last element
04:24:46 <shapr> @get-definition head
04:24:47 <lambdabot> head not defined
04:25:02 <Heffalump> first [] = error "..."
04:25:04 <shapr> @get-definition S
04:25:04 <lambdabot> S = \f g x.f x (g x)
04:25:04 <Heffalump> first [x] = x
04:25:12 <Heffalump> first (x:xs) = first xs
04:25:16 <shapr> the @eval plugin is a lambda calculus interpreter
04:25:43 <bojohan> we programmed the bot at #emacs to play russian roulette.
04:25:44 <Heffalump> oh no, that's last
04:25:55 <Heffalump> first [x] = []
04:26:00 <Heffalump> first (x:xs) = x:first xs
04:26:15 <shapr> you can write a russian roulette plugin for lambdabot too.
04:26:23 <shapr> we can even rewrite @quit to do that.
04:26:28 <Heffalump> @eval SII
04:26:28 <lambdabot> unbound variable: SII
04:26:36 <Heffalump> @eval (\x.x) 1
04:26:36 <lambdabot> 1
04:26:43 <shapr> @eval S I I
04:26:43 <lambdabot> <<EM Dynamic -> EM Dynamic>>
04:26:56 <Heffalump> @eval (\f x . f (f x)) (\a -> a+1) 1
04:26:56 <lambdabot> (line 1, column 22):
04:26:56 <lambdabot> unexpected "-"
04:26:56 <lambdabot> expecting identifier or "."
04:27:02 <bojohan> is there a user's manual?
04:27:02 <Heffalump> @eval (\f x . f (f x)) (\a . a+1) 1
04:27:02 <lambdabot> 3
04:27:08 <shapr> for the 'bot?
04:27:11 <shapr> no, not really.
04:27:14 <bojohan> yup?
04:27:22 <Heffalump> do you mind if I try to crash it?
04:27:24 <shapr> but there is demonstration code.
04:27:26 <shapr> Heffalump: go for it.
04:27:35 <Heffalump> @eval (\x . x x) (\x . x x)
04:27:37 <lambdabot> out of fuel - use @resume to continue
04:27:43 <bojohan> :-)
04:27:44 <Heffalump> aww, no fun :-)
04:27:53 <Heffalump> but a cool message
04:30:08 <bojohan> can i give it monadic code?
04:30:36 <shapr> the easiest way to expand lambdabot is to write new plugins for it.
04:30:38 <shapr> @listmodules
04:30:38 <lambdabot> I have the following modules installed: ["chess","dict","eval","fact","hello","karma","more","quote","state","system","topic","type"]
04:30:45 <shapr> @listcommands eval
04:30:45 <lambdabot> Module eval provides the following commands: ["eval","define","get-definition","definitions","del-definition","dump","set-fuel","resume"]
04:30:49 <bojohan> like a random number generator?
04:31:08 <shapr> the @yow and @fortune commands already use a random number generator.
04:31:13 <shapr> @yow
04:31:14 <lambdabot> LIFE is a never-ending INFORMERCIAL!
04:31:16 <shapr> @fortune
04:31:17 <lambdabot> Of what you see in books, believe 75%.  Of newspapers, believe 50%.  And of
04:31:17 <lambdabot> TV news, believe 25% -- make that 5% if the anchorman wears a blazer.
04:31:26 <bojohan> i have to write a file?
04:33:14 <shapr> to add new commands to lambdabot, yes.
04:34:29 <bojohan> you can give the emacs-bot new definitions on the fly
04:34:57 <shapr> yes, because it's written in elisp
04:35:06 <bojohan> yes
04:35:26 <shapr> most of the fsbot stuff is patterned responses. lambdabot could do the same thing with the right plugin.
04:35:32 <shapr> you want to write that plugin?
04:35:44 <jlouis> shapr: where is the code for the bot?
04:35:48 <shapr> @fact source
04:35:48 <lambdabot> http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/lambdabot/
04:35:52 <bojohan> don't know if i could
04:36:27 <shapr> the @fact plugin is a little bit like it, but not enough.
04:36:29 <jlouis> @fact cvsroot
04:36:29 <lambdabot> Nothing
04:36:37 <jlouis> damn
04:37:22 <shapr> jlouis: http://sourceforge.net/cvs/?group_id=44807
04:37:32 <shapr> cvs -d:pserver:anonymous@cvs.sourceforge.net:/cvsroot/haskell-libs login
04:37:49 <shapr> cvs -z3 -d:pserver:anonymous@cvs.sourceforge.net:/cvsroot/haskell-libs co libs
04:38:08 <shapr> jlouis: if you'd like, I could add you to haskell-libs as a developer. Then you could commit code to the bot directly.
04:39:10 <jlouis> not yet, I have to fool around a bit first :)
04:39:12 <shapr> ok
04:39:23 <shapr> bojohan: no way to find out except to try :-)
04:39:37 <jlouis> there are too many SML specifics in my coding style I think
04:39:52 <bojohan> where can i find what @-commands the bot knows?
04:40:27 <shapr> @listcommands
04:40:27 <lambdabot> I react to the following commands: ["all-dicts","board","define","definitions","del-definition","devils","dict","dict-help","dump","easton","echo","elements","eval","fact","flip-board","foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","lojban","more","msg","part","ply","prelude","quit","reset-chess","resume","set-fuel","st
04:40:44 <shapr> that's only part of the commands
04:40:50 <shapr> @listmodules
04:40:50 <lambdabot> I have the following modules installed: ["chess","dict","eval","fact","hello","karma","more","quote","state","system","topic","type"]
04:40:58 <shapr> you can get the list of commands for one module with
04:41:02 <shapr> @listcommands quote
04:41:02 <lambdabot> Module quote provides the following commands: ["fortune","yow"]
04:41:17 <bojohan> no online help, like "describe eval"?
04:41:27 <bojohan> docstrings
04:42:01 <shapr> no, but you could write it :-)
04:42:05 <shapr> it would be easy to do.
04:49:57 <bojohan> let say i want it to say "hello <my-name>" instead of "hello world". how would i do that?
04:51:46 <shapr> @hello we are receiving you.
04:51:46 <lambdabot> Hello world. we are receiving you.
04:52:15 <shapr> the @hello plugin shows you how to send static text, and how to send back input you got from irc.
04:53:34 <bojohan> but can it know the name of the one who invoked it?
04:55:50 <shapr> yes
04:55:57 <shapr> @karma+ shapr 
04:55:57 <lambdabot> You can't change your own karma, silly.
04:56:04 <shapr> @karma+ bojohan 
04:56:04 <lambdabot> bojohan's karma has been incremented.
04:56:09 <shapr> @karma bojohan 
04:56:09 <lambdabot> bojohan has a karma of 1
04:56:26 <bojohan> *whitout* me passing it as an argument
04:56:53 <shapr> yes, look at @karma+ shapr
04:57:04 <bojohan> ah
04:57:04 <shapr> I didn't tell it who the message is coming from.
04:57:54 <andersca> @karma andersca
04:57:55 <lambdabot> You have a karma of 0
04:57:57 <andersca> :(
04:58:35 <shapr> @karma+ andersca 
04:58:35 <lambdabot> andersca's karma has been incremented.
04:58:38 <andersca> yay
04:59:18 <shapr> basement jaxx is great
05:01:29 <shapr> cvs.sf.net is soo unreliable :-(
05:01:54 <andersca> yeah
05:01:57 <jlouis> @type liftIO
05:02:12 <jlouis> hrm
05:02:38 <shapr> the @type plugin needs some work
05:04:26 <Heffalump> what module is that in?
05:04:37 <shapr> @listcommands type
05:04:37 <lambdabot> Module type provides the following commands: ["type"]
05:04:46 <Heffalump> IM liftIO, not @type
05:04:49 <shapr> oh
05:04:59 <shapr> Control.Monad or so?
05:05:27 <jlouis> IM?
05:05:46 <shapr> I Mean
05:05:46 <Heffalump> "I mean"
05:05:57 <jlouis> ah
05:08:50 <Marvin--> bah, I thin I've wasted enough time on this now
05:10:08 <shapr> Marvin--: at least it sort of works :-)
05:10:19 <shapr> can you play battle.net and lan games with it?
05:10:27 <shapr> that's what's important to me.
05:10:58 <Marvin--> shapr: no, it doesn't work anymore, after I started fiddling with the campaigns, all I get when I start war3 now is a blank screen (I hear the sound effects and music, but no picture)
05:11:52 <shapr> :-/
05:28:09 <Marvin--> what the...
05:28:18 <Marvin--> I've been trying to write down what I've done
05:28:23 <Marvin--> now it mysteriously works
05:30:17 <shapr> yay
05:35:11 <vegai> wine emulates that too =)
05:39:14 <Marvin--> apparently
05:39:42 <Marvin--> wooh, when I fiddled with the video settings from within war3, even the font weirdness went away and it's as pretty as you could wish for :-)
05:40:00 <shapr> yay!
05:47:15 <robert_> another question: is it possible to catch non-IO errors (e.g. generated by  head []) in the IO monad?
05:48:36 <Marvin--> god I love giving away sarcastic gifts :P
05:49:23 <robert_> they seem to get past "catch", for example in catch (putStrLn (undefined::String)) (\ e -> putStrLn "exception")
05:51:21 <vegai> what is that, gpl wine or winex?
05:51:29 <Marvin--> WineX
05:51:36 <vegai> bought or cvs?
05:51:47 <Marvin--> I've been testing various versions of Wine and various versions of WineX
05:51:51 <Marvin--> CVS HEAD
06:18:21 <shapr> robert_: I think you have to catch errors in the IO monad
06:18:26 <shapr> though I've forgotten why
06:18:46 <robert_> I was meaning to, just can't manage currently
06:18:56 <Marvin--> shapr: sequentiality?
06:18:59 <robert_> getting closer though, with Control.Exception.evaluate
06:19:42 * andersca gaboings
06:19:49 <Marvin--> don't the papers on imprecise exceptions talk about this?
06:21:25 <robert_> yay, using Control.Exception.catch instead of Prelude.catch works
06:22:17 * shapr kersplats
07:16:28 * Riastradh boings and departs.
07:22:04 <shapr> hey Vincenz 
07:22:11 <Vincenz> hiya shapr :)
07:22:21 <Marvin--> shapr: now I've managed to screw up the install again :P
07:23:36 <Marvin--> maybe I should put the .reg files under version control :P
07:31:19 * shapr snickers
07:31:51 * shapr sings the copyright song by Presidents of the United States of America
07:34:39 <Marvin--> pretty soon I will know my War3 CD key by heart
07:47:36 <andersca> so what are people doing to h-c
07:47:39 <andersca> subscribing it to stuff?
08:05:11 <Marvin--> h-c?
08:06:05 <andersca> haskell-cafe
08:09:19 <Heffalump> well, at least someone removed it again
08:14:59 <d33p> can someone help me grok this error: 
08:14:59 <d33p> sub :: (Int, Int) -> [a] -> [a]
08:15:09 <d33p> - Missing binding for variable "sub" in type signature
08:16:30 <Heffalump> is that the entire program?
08:16:35 <d33p> no
08:16:43 <Heffalump> how big is it?
08:16:59 <d33p> but if i comment out that line, the file loads flawlessly
08:17:04 <d33p> um.. about 100 lines
08:17:51 <Marvin--> grr, war3 seems to consistently hang after about three minutes
08:18:17 <Heffalump> is that line indented at all?
08:18:28 <d33p> hmm.. lets see
08:18:33 <d33p> no
08:20:05 <Heffalump> what does hugs/ghci say about the type of sub if you load it up with the line commented?
08:20:37 <d33p> it doesnt load, for me to find out
08:20:54 <d33p> ERROR "stuff.hs":94 - Missing binding for variable "subLiz" in type signature
08:21:06 <Heffalump> I thought you just said the file loads flawlessly?
08:21:12 <d33p> only if i comment that line out
08:21:16 <d33p> 94
08:21:19 <d33p> which is what i pasted
08:21:20 <Heffalump> right, that was what I asked
08:21:23 <d33p> yep
08:21:39 <Heffalump> with it commented out, what's the type of sub?
08:22:07 <d33p> um.. it isnt defined 
08:22:21 <Marvin--> if it isn't defined, you can't give it a type signature
08:22:44 <d33p> Marvin--: isnt the type signature the definition?
08:22:57 <Marvin--> d33p: no, that's just a type signature, it's optional
08:23:02 <d33p> k
08:23:13 <Marvin--> d33p: a definition would be something like   sub (a,b) xs = ...
08:23:19 <d33p> but the problem is with the type signature 
08:23:24 <d33p> Marvin--: right, i commented that out for now
08:23:38 <Marvin--> d33p: if you comment out the definition of sub, you must comment out the type signature too
08:23:49 <d33p> ohh
08:23:50 <Marvin--> d33p: that's what the error is about, it complains about sub not being defined
08:24:01 <d33p> i see.. *grin*
08:24:30 <d33p> well that didnt change the error message
08:25:25 <d33p> i mean, i still get an error but a different one
08:25:44 <d33p> argh.. sorry for being such a newbie
08:25:47 <Marvin--> can you put the file on a website somewhere?
08:25:53 <d33p> Marvin--: yes
08:27:55 <d33p> http://members.webace.com.au/~d33p/stuff.hs
08:29:27 <d33p> the function on the bottom
08:30:08 <Marvin--> (\\) needs Eq a
08:30:24 <d33p> i see
08:30:25 <Marvin--> so you'll want to say   subLiz :: Eq a => (Int, Int) -> [a]  -> [a]
08:31:13 <d33p> ohh
08:31:41 <d33p> thanks
08:31:45 <Marvin--> brb
09:37:40 <andersca> shapr?
09:37:44 <shapr> you screamt?
09:38:14 <andersca> how do I change my default font in emacs?
09:38:27 <shapr> (set-face-font 'default "-*-lucidatypewriter-medium-r-normal-*-*-140-75-75-m-*-iso8859-1")
09:38:32 <andersca> oh lovely
09:39:06 <shapr> if you're using the ERC emacs irc client, you can just put your cursor at the end paren there and hit C-x C-e
12:02:33 <shapr> hi Darius 
12:02:46 <Darius> heya
12:02:50 <shapr> what's up?
12:03:35 <Darius> Not much, the second phone line seems to be out of order.
12:04:03 <shapr> how's the DSL fund?
12:14:07 <steveh> hey, anyone want to hold my hand and explain how type classes are working in Okasaki's haskell code?
12:14:19 <steveh> I am mostly at a loss as to where to begin
12:14:23 <shapr> which code?
12:14:47 <steveh> well, the example I am dealing with is Sets, since I think it'd be a good exercise to add a delete function
12:15:01 <Marvin--> what's the problem?
12:15:02 <steveh> unfortunately I can't figure out exactly how to work with what he's got
12:15:09 <Marvin--> (disclaimer: I don't have the book, but I've read it)
12:15:35 <steveh> well, I'm trying to make a variable be a simple "Empty" red-black tree, using the interface he's got
12:15:36 <steveh> namel
12:15:38 <steveh> y
12:15:47 <steveh> module Set (Set(..))
12:15:47 <steveh> where
12:15:51 <steveh> class Set s a where 
12:15:51 <steveh>     empty  :: s a
12:15:51 <steveh>     insert :: a -> s a -> s a
12:15:51 <steveh>     member :: a -> s a -> Bool
12:16:45 <steveh> and in RedBlackSet there's the line instance Ord a => Set RedBlackSet a where ...
12:17:33 <steveh> so RedBlackSet a is an instance of the Set class, which has such-and-such functions defined over it, right?
12:18:28 <steveh> I think a big thing is that this is using multiparameter type classes, and the documentation for that is a bit above my comprehension right now
12:19:03 <steveh> but anyway, all I'm trying to do is "let x" be an empty RedBlackSet
12:19:18 <Heffalump> x = empty
12:19:24 <steveh> aaah
12:19:31 <steveh> Ambiguous type variable(s) `s', `a' in the constraint `Set s a'
12:19:40 <steveh> and that's where I'm stuck
12:20:27 <Heffalump> ok, so you need to write some code to use it
12:20:36 <Heffalump> that'll cause those variables to be constrained
12:21:12 <Marvin--> well, if you only use Set functions on x it'll still be unresolved...
12:21:16 <steveh> what kind of code would that be though?
12:21:41 <Heffalump> Marvin--: oh, true
12:21:50 <Heffalump> you could just do
12:22:04 <Heffalump> x = empty :: Set RedBlackSet Int
12:22:16 <Heffalump> no, I don't mean that
12:22:17 <Heffalump> I mean
12:22:20 <Marvin--> no, you don't :)
12:22:24 <Heffalump> x = empty :: RedBlackSet Int
12:22:34 <Heffalump> (for example, if you want Ints in the set)
12:22:45 <steveh> aaaah ok
12:22:48 <steveh> hmm hmm
12:22:52 <Marvin--> I had some scary code a while ago when I had a type class for queues and had a recursive function that used queues internally, and never instantiated the type
12:23:02 <Marvin--> ghc gave me some *really* funky error messages for that
12:23:06 <Heffalump> :-)
12:23:11 <steveh> where is the syntax for that specified, so I can figure out what's going on?
12:23:37 <Heffalump> steveh: the :: syntax just says "the value on the left, constrained to have the type on the right"
12:23:42 <steveh> I am only used to seeing :: in functional type signatures really
12:23:45 <Heffalump> I guess it's in the report somewhere reasonably obvious
12:24:10 <Heffalump> ok, so you can use :: in both declaration and expression context
12:24:15 <Heffalump> you've seen it in declaration context already
12:24:27 <steveh> that is very useful information. thank you.
12:24:42 <Heffalump> in expression context, it does pretty much the same thing, but it also makes an expression that is the same as the left-hand argument
12:25:28 <Marvin--> Heffalump: the scariest thing was that when I gave the function a type signature, it complained, but when I commented out the type signature, ghc accepted the code and gave the function the same type that I gave it
12:25:38 <Marvin--> I don't remember what happened when I ran it, probably something scary
12:25:43 <Heffalump> there's been some instances of that on the mailing list
12:25:53 <Heffalump> oh, YM it accepted it even though it was ambiguous? That's bad.
12:26:46 <Marvin--> exactly
12:28:54 <Marvin--> I wonder if I can reproduce it *ponder*
12:36:49 <Marvin--> Heffalump: http://193.11.232.159:8080/Th.hs
12:37:09 <Marvin--> ghci -package util  loads it just fine if runTh and the type signature of runRR are commented out
12:37:35 <Marvin--> ah, maybe that's because without type signature runRR will get monomorphic recursion
12:42:52 <Heffalump> ah, and without runTh there's no code that uses it
12:43:36 <Marvin--> yeah
12:45:00 <Marvin--> but it still scary that even with instance Queue []  and saying [] instead of new in runTh, I can't give runRR a type
12:58:59 <Blitz> I was wondering if there is an editor with code completion available for Haskell..
14:06:11 * shapr boings
14:06:25 <shapr> Blitz: emacs does word completion, but it's not 'smart completion' 
14:07:34 <Igloo> What is it? keyword completion?
14:08:38 <shapr> yah, keyword, line, list, word-in-buffer, visible-word, lots of stuff
15:02:27 <cl1dev> whoa
15:02:30 <cl1dev> howdy everyone
15:02:44 * cl1dev was just checking to see if there was a #haskell channel
15:02:53 <cl1dev> i'm quite supprised to see so many people
15:03:26 * cl1dev is about to start learning haskell
15:25:37 * whee loves ghc
15:25:51 <whee> screen after screen of stage2/nativeGen/MachCode.o(.text+0x5): undefined reference to `__DISCARD__'
15:26:05 <whee> different object files, of course
15:26:27 <cale> whee: where is that occurring?
15:27:51 <whee> it's trying to create the stage2 binary
15:29:40 <shapr> hi demoncrat 
15:29:48 <shapr> what's up?
15:30:11 <demoncrat> not much... about to go out looking for cholesterol test and pda batteries
15:30:24 <demoncrat> been hacking on secure scripting language
15:30:28 <shapr> what's that?
15:30:39 * shapr googles
15:30:43 <shapr> ah
15:30:46 <shapr> E
15:31:01 <demoncrat> oh, well, this is a much simpler thing of my own
15:31:18 <demoncrat> less ambitious
15:31:53 <shapr> idel?
15:32:02 <demoncrat> even less than that :)
15:32:15 <whee> sigh
15:42:01 <shapr> demoncrat: do you have any code online?
15:42:15 <demoncrat> well, i could upload it
15:42:23 <shapr> written in scheme?
15:42:26 <demoncrat> c
15:42:36 <demoncrat> if you don't mind playing with a totally different forth dialect
15:42:42 <shapr> sounds like fun
15:43:49 <demoncrat> ok http://accesscom.com/~darius/tmp/tusl.tar.gz
15:44:03 <shapr> cool, thanks
15:44:23 <demoncrat> um, consider it gpl or something - haven't stuck in a license yet
15:44:37 <shapr> ok
15:46:01 <shapr> g'day Agent Jones
15:49:18 <syntax-laptop> shapr: how's it going?
15:49:27 * shapr bounces
15:49:33 <shapr> life is good
15:49:37 <shapr> how are you?
15:50:22 <syntax-laptop> I'm good.  Having a pretty good weekend so far, though I had to get up at 3:30 (!) to drive someone to the airport yesterday.
15:50:30 <shapr> yikes
15:51:18 <syntax-laptop> went indoor rock climbing in an old church the other day, which was neat.
15:51:39 <shapr> typing muscles used for good purposes, eh?
15:52:30 <syntax-laptop> yup!
15:53:08 <syntax-laptop> I also did a little hacking on the apt patch me & walters are writing.  Hoping to do some hacking on library infrastructure today.
15:53:21 <shapr> cool
15:56:51 <demoncrat> oh, actually i did stick a little license notice in
15:56:52 <demoncrat> hurray
15:56:56 <Heffalump> apt patch?
16:05:40 <syntax-laptop> Heffalump: me & walters have patched apt to check the gpg signatures of the release files and thereby assure the authentity of the downloaded debs.
16:05:52 <shapr> oh, that's cool
16:05:53 <shapr> I want that.
16:06:06 <syntax-laptop> right now they suffer from a variety of attacks, including man-in-the-middle which would allow your machine to be taken over.
16:06:14 <syntax-laptop> s/they/apt
16:06:43 <syntax-laptop> we're trying to get them to integrate it into the cvs tree for apt, but we're getting some resistence.  hopefully, it'll happen soon.
16:06:44 <Heffalump> oh, cool
16:06:49 <Heffalump> why resistance?
16:07:47 <syntax-laptop> not sure really.  there are some policy decisions to make and some stuff to clean up, but that shouldn't be enough to keep it out of cvs.  it actually pretty much works now, but probably doesn't look exactly like it will look in the end.
16:22:15 <cale> Hmm, I think it would be cool if someone wrote a k5 article on Haskell. Perhaps I'll try and see where I get with it.
16:22:27 <shapr> tmoertel has written some
16:22:30 <shapr> have you seen his?
16:22:50 <shapr> especially his Haskell, Perl, and XSLT article, that one's nifty.
16:23:11 <cale> no, I'll have a search for it.
16:38:06 <syntax-laptop> shapr:have you & peti done any talking or thinking or writing about the haskell distribution stuff?
16:38:24 <shapr> nope
16:39:37 <syntax-laptop> OK. let me know when anything happens.
16:40:11 <syntax-laptop> if things work out well, we may have three 2 person teams for the library infrastrucutre project
16:40:26 <shapr> neat, what's the third team doing?
16:40:26 <syntax-laptop> shapr: you & peti for distribution
16:40:42 <syntax-laptop> alastair & nilsson for the makefiles
16:41:07 <Heffalump> "distribution"?
16:41:33 <syntax-laptop> and I'm hoping that malcolm wallace will work together on "distutils" (I think hmake is a good starting place)
16:41:45 <syntax-laptop> I mean malcolm wallace and I.
16:41:53 <syntax-laptop> I sent him an email, so we'll see what he thinks.
16:41:58 <shapr> Heffalump: content
16:42:28 <shapr> g'day Pseudonym 
16:42:31 <Pseudonym> G'day.
16:42:51 <shapr> what interesting thoughts are you having today?
16:43:27 <Pseudonym> No caffeine yet, so nothing interesting.
16:43:32 <shapr> heh
16:43:36 * syntax-laptop is not sure what content means
16:43:44 <Pseudonym> In what context?
16:44:35 <shapr> syntax-laptop: distribution meaning we collect and classify stuff?
16:44:39 * shapr may be confused
16:46:01 <syntax-laptop> shapr: right, thats what I meant by distribution
16:46:07 <shapr> ok
16:46:09 <syntax-laptop> Pseudonym: in the context of an ongoing conversation :)
16:48:07 <Pseudonym> Today is looking to be a deep productivity loss.
16:48:15 <Pseudonym> So I might go look at the logs. :-)
16:48:24 * shapr grins
16:48:50 <Pseudonym> A couple of guys from our US affiliates are here today.  Hence, no work gets done.
16:49:06 <Pseudonym> Seems to me like we should actually be showing them how hard we work.
16:51:56 <Pseudonym> Ah, I see.
16:52:29 <Pseudonym> Content == data, infrastructure == metadata
16:54:06 <syntax-laptop> ahh. is that what you meant, shapr?
16:54:12 <shapr> yop
16:54:55 <cl1dev> what file extension does emacs like for haskell files?
16:55:09 * cl1dev wants to use haskell-mode in emacs
16:55:10 <shapr> .hs
16:55:14 <shapr> .lhs
16:56:28 <cl1dev> ok, that's not my problem
16:56:35 <cl1dev> thanks
16:56:36 <cale> .hs is for plain haskell scripts, .lhs would be for literate haskell - where everything without ">" at the start of the line is a comment.
16:56:52 <cl1dev> i have 2 versions of emacs on here, the one i use and the one debian has
16:57:24 <Pseudonym> Does haskell-mode work with the LaTeX-style literate scripts?
16:57:26 <syntax-laptop> cl1dev: so its not in haskell-mode automatically?
16:57:28 <Pseudonym> \begin{code}
16:57:46 <cl1dev> syntax-laptop: nope
16:57:55 <cl1dev> GNU Emacs 21.3.50.2
16:58:03 <cale> Pseudonym: I don't know
16:58:08 <cl1dev> /opt/local/emacs/bin/emacs
16:58:13 <cl1dev> that's the version i use
16:58:20 <cl1dev> debian installs it somewhere else
16:58:29 <syntax-laptop> Pseudonym: yeah, I do believe it does, but it needs to know which version of literate script its using.
16:58:33 <Pseudonym> I know the vim haskell stylesheet doesn't.
16:58:37 * Pseudonym nods
16:58:42 <syntax-laptop> ie if you make a new file Foo.lhs, it won't know how to highlight it.
16:58:49 <syntax-laptop> but there's a default you can set.
16:59:09 <syntax-laptop> cl1dev: so do you have haskell-mode installed via debian?
16:59:18 <cl1dev> syntax-laptop: yeah
16:59:27 <syntax-laptop> does it work in /usr/bin/emacs or whatever?
16:59:38 <cl1dev> syntax-laptop: i would presume so
16:59:41 <syntax-laptop> (debian's version)
16:59:59 <cl1dev> i just wanna copy over the major mode or do what ever to get it so that my version can use it
17:00:10 <syntax-laptop> OK.  so do you have a copy of it in the area that /opt/local/bin/emacs looks for elisp files?
17:00:13 <shapr> cl1dev: just need to put it on your load-path
17:00:21 <shapr> yah what he said.
17:00:24 <syntax-laptop> :)
17:00:50 <whee> ghc sure takes a while to compile even on a faster machine :|
17:01:02 <whee> I hope it works this time
17:01:21 <cl1dev> syntax-laptop: nope, what file would i need to look for so that i can copy it over?
17:02:19 <syntax-laptop> cl1dev: its probably in /usr/share/emacs/site-lisp/haskell-mode.el
17:02:33 <cl1dev> syntax-laptop: thanks
17:02:42 <shapr> yah, you can find out the files in a debian package with dpkg -L package-name
17:02:56 <shapr> cl1dev: why not use the debian emacs?
17:02:58 <syntax-laptop> so you could add (load "/usr/share/.../haskell-mode.el") to your .emacs file I think?
17:03:18 <Igloo> Pseud: I have a tiny lhaskell syntax file for vim
17:03:39 <syntax-laptop> or add /usr/share/emacs/site-lisp to your load path and then (require 'haskell-mode)
17:03:50 <shapr> yah, that would be simplest.
17:04:14 <syntax-laptop> extra points if you figure out a way to make it not load the file redundantly in the /usr/bin/emacs case :)
17:04:23 <whee> anyone know of any problems with ghc and openbsd (ELF)?
17:04:38 <whee> I've seen mention of a ghc6 port for -current but I haven't seen it
17:04:43 <cl1dev> i could ln to the file :)
17:04:53 <shapr> syntax-laptop: maybe /etc/emacs/site-start.d ?
17:06:16 <polli> hmmm, anyone who can help me fool ghc's type system=
17:06:18 <polli> ?
17:06:37 <polli> I don't want to paste the error message here :)
17:06:41 <bojohan> syntax-laptop: why would it "load it redundantly"?
17:06:49 <shapr> monads are all about bindage and discipline
17:06:58 <cl1dev> hmm, i copied the files, but they aren't being used
17:07:06 <cl1dev> do i need to compile them or something?
17:07:19 <shapr> cl1dev: M-x ielm <enter> load-path <enter>
17:07:22 <shapr> or alternatively
17:07:26 <shapr> C-h v load-path
17:08:59 <cl1dev> shapr: thanks
17:10:30 <Pseudonym> polli: What's the problem?
17:12:51 <Pseudonym> What's the type of allModule?
17:13:48 <polli> allModules :: Module m => (m -> IRCMessage -> IRC ()) -> IRCMessage -> IRC ()
17:14:09 <shapr> Pseudonym: polli is working on a new plugin interface for lambdabot ;-)
17:14:19 <Pseudonym> Ooh, excellent.
17:14:23 <polli> :)
17:14:26 <Pseudonym> :-)
17:14:39 <Pseudonym> There's gonna be none of my code left soon.
17:15:01 <polli> Pseudonym: there'll be plenty to debug after this patch :)
17:15:25 <Pseudonym> I think your type might be wrong.
17:15:29 <Pseudonym> Hmmm.
17:15:58 <Pseudonym> allModules :: (forall m. (Module m) => m -> IRCMessage -> IRC ()) -> IRCMessage -> IRC ()
17:15:59 <Pseudonym> Try that.
17:16:43 <Pseudonym> Unsure if that's even legal.
17:17:15 <polli> Main.hs:209: Illegal class assertion
17:17:49 <Pseudonym> Right.
17:18:24 <Pseudonym> See, the current problem is that it expects all calls to f to take the same type as the first argument.
17:18:51 <Pseudonym> Whereas you want to be able to call f with different types, so long as they are all members of Module.
17:19:09 <Pseudonym> The simplest solution is to change the definition to this:
17:19:09 <polli> yes
17:19:18 <Pseudonym> allModules :: (MODULE -> IRCMessage -> IRC ()) -> IRCMessage -> IRC ()
17:19:38 <polli> hmm.. ok 
17:19:54 <Pseudonym> I think this is one of those situations where "forall" is a lie.
17:19:58 <Pseudonym> It should be "exists".
17:20:07 <Pseudonym> And differentiating them is important here.
17:20:28 <polli> hmm..
17:20:31 <Heffalump> the forall isn't a lie, it's just inside brackets
17:20:45 <polli> that's not that good
17:20:54 <Heffalump> forall in "negative" position is exists in "positive" position
17:21:06 <Pseudonym> True.
17:21:16 <Pseudonym> -> is kind of implication
17:21:26 <Pseudonym> Though even that interpretation irks me a bit.
17:21:38 <Heffalump> Curry-Howard isomorphism and all that :-)
17:21:43 <Pseudonym> Yeah.
17:22:11 <Pseudonym> Type theory was never my strong point.  Possibly because when you implement a type checker, you're basically doing some kind of resolution-based theorem proving.
17:22:18 <Pseudonym> And there, -> isn't implication, it's a functor.
17:22:25 <Pseudonym> Very confusing.
17:22:54 <Heffalump> "forall m. (Module m) => m -> IRCMessage -> IRC ()" is the type that says for any m, you can take an m and an IRCMessage and get an IRC ()
17:23:12 <Pseudonym> Yes.
17:23:22 <Heffalump> so the type of allModules says that given such a function, which *must* be that polymorphic, it can do the rest of whatever it does
17:23:50 <Heffalump> I'm not preaching to you :-)
17:23:55 * Pseudonym grins
17:24:04 <Pseudonym> I don't know how to express what polli wants to express.
17:24:20 <Heffalump> what does he want to express?
17:24:28 <polli> Heffalump: 1 sec
17:24:38 <Pseudonym> He wants to now pass things of that type to a function.
17:24:40 <Igloo> You want the forall and the functino to be bracketted together don't you?
17:24:53 <Igloo> Oh, like you had earlier
17:24:54 <Heffalump> which type?
17:24:56 <Pseudonym> If you have:
17:25:08 <Pseudonym> some_f :: forall m. (Module m) => m -> Something
17:25:18 <Pseudonym> Then he wants to write a function like this:
17:25:26 <Pseudonym> Oh, hang on.
17:25:31 <Pseudonym> Just had a thought.
17:26:05 <Pseudonym> No, that doesn't work.
17:26:14 <Pseudonym> Suppose you have a function of this type:
17:26:25 <Pseudonym> foo :: (Module m) => m -> SomeConcreteType
17:26:44 <Pseudonym> You want to pass this as a parameter to some function:
17:26:54 <Pseudonym> bar :: type_of_foo -> SomeOtherConcreteType
17:26:57 <Pseudonym> How do you do that?
17:27:08 <polli> Heffalump:         ircModules         :: FiniteMap String MODULE
17:27:16 <Pseudonym> Given that you may want to call foo with _different_ instances of Module inside bar.
17:27:19 <Heffalump> and MODULE is an instance of Module?
17:27:28 <Pseudonym> No.
17:27:30 <polli> Heffalump: nope
17:27:36 * Heffalump looks confused
17:27:37 <Pseudonym> data MODULE = forall m. MODULE m
17:27:41 <Pseudonym> data MODULE = forall m. (Module m) => MODULE m
17:27:42 <Pseudonym> Sorry.
17:27:49 <Heffalump> oh, right, yes.
17:28:05 <Heffalump> what's wrong with giving the type with the explicit forall for allModules, then?
17:28:13 <Heffalump> it sounds to me like that's precisely what you need
17:28:19 <Pseudonym> Sorry, what should its type be, in full?
17:28:39 <Heffalump> errm, what you first said, with the forall in negative position
17:28:57 <Heffalump> cos you _need_ an f like that for it to work
17:29:18 <Pseudonym> allModules :: (forall m. (Module m) => m -> IRCMessage -> IRC ()) -> IRCMessage -> IRC ()
17:29:20 <Pseudonym> That, you mean?
17:29:23 <Heffalump> yes.
17:29:33 <Pseudonym> I think that caused some kind of malformed type error.
17:29:34 <polli> Main.hs:212: Illegal class asserti
17:29:37 <polli> on
17:29:39 <Pseudonym> Right.
17:29:42 <Heffalump> and data MODULE = ... didn't?
17:29:56 <Heffalump> I've never actually used this GHC extension, but I had the impression it was legal.
17:32:14 * shapr notices the number of people on both #emacs and #haskell is increasing
17:32:42 <Pseudonym> Guess it's time to fork #haskell-mode
17:32:56 <shapr> that would be amusing
17:33:34 <shapr> I'm still amazed by the number of large applications written in elisp
17:33:50 <shapr> well, for some definition of large :-)
17:33:52 <Pseudonym> Amazed that it's possible, or amazed that anyone would bother?
17:33:58 <Pseudonym> How large is large?
17:34:07 <whee> I find it amazing that people can use emacs.
17:34:09 * whee ducks
17:34:18 <shapr> well, look at gnus, bbdb, ecb, semantic bovinator...
17:34:28 <Pseudonym> I find it amazing that anyone would _want_ to use elisp for reasonable-sized applications.
17:34:33 <shapr> semantic is a full fledged lex/yacc written in elisp.
17:34:51 <Pseudonym> How useless.
17:34:54 <shapr> actually...
17:35:10 <shapr> I think it's a brilliant idea with the wrong implementation
17:35:19 <Pseudonym> BTW, lex/yacc isn't as hard to write as you think.
17:35:21 <shapr> I think editors should be doing parse tree ops anyway
17:35:44 <shapr> the MetaEnivorment is a good step in that direction
17:35:55 <shapr> so was Simonyi's Intentional Programming
17:35:57 <Pseudonym> I wrote an LR parser generator in under 500 lines of Haskell, and that's including all the type declarations.
17:36:06 <shapr> well, Haskell is awesome :-)
17:36:10 <shapr> lesser languages just cannot compete.
17:36:11 <Pseudonym> True!
17:36:29 <Pseudonym> The LR(0) generator weighs in at 137 lines.
17:36:33 <Pseudonym> Which is hardly anything.
17:36:40 <shapr> I wrote a bayesian spam filter in 127 lines of Haskell.
17:36:49 <shapr> including comments, blank lines for spacing, etc
17:36:54 <Pseudonym> Right, there you go.
17:37:06 <Pseudonym> Actually, I just noticed one comment from my LR(0) generator.
17:37:10 <Pseudonym> -- XXX Horribly inefficient
17:37:22 <Pseudonym> So this may not be a good example.
17:37:50 <Igloo> :-)
17:37:51 <shapr> during my first steps with Haskell I asked Heffalump to look at a short bit of Haskell code, just a few hundred lines.. I was used to reading and writing Python.
17:39:29 * Pseudonym assumes there's a punchline here
17:40:20 <shapr> I thought it would take ten minutes to discuss a few hundred lines of Haskell.
17:40:25 <shapr> and about that long to read it.
17:40:45 <cale> heh
17:40:49 <whee> okay, ghc must not work on openbsd
17:40:54 <whee> heh
17:41:27 <shapr> I wonder how fast SPJ reads Haskell sources.
17:41:50 <Pseudonym> Depends on the source, I suppose.
17:42:08 <Pseudonym> It'd take him longer to read the IOHCC entries.
17:42:18 <shapr> :-)
17:42:28 <shapr> speaking of which, he didn't have time to be a juror.
17:42:30 <Pseudonym> Took me a while to read the bits of GHC which use the C preprocessor heavily.
17:42:33 * Pseudonym nods
17:42:50 <shapr> did you read the Evil Mangler?
17:42:58 <Pseudonym> No.
17:43:03 <Pseudonym> Should I?
17:43:06 <shapr> I don't know.
17:43:20 <shapr> I've been staying away from it, trying to save up my SAN points.
17:43:27 <Heffalump> ahah, done it.
17:43:27 <Igloo> Reading something as big and tangled as GHC without a mental overview is tricky
17:43:40 <Heffalump> 7 line paste OK?
17:43:46 <Pseudonym> Fine with me.
17:43:48 <shapr> sure, go for it.
17:43:53 <Heffalump> module Foo where
17:44:02 <Heffalump> class Foo f where
17:44:03 <Heffalump>   unfoo :: f -> Int
17:44:07 <Heffalump> data FOO = forall f . (Foo f) => FOO f
17:44:11 <Heffalump> sumfoos :: (forall f . (Foo f) => f -> Int) -> [FOO] -> Int
17:44:12 <Heffalump> sumfoos f foos = sum [f foo | FOO foo <- foos]
17:44:23 <Igloo> tricks like having the lexer insert the opening braces for the layout rule and the parser insert the closing one don't help either  :-)
17:44:24 <Heffalump> sumfoos appears to do roughly what polli needs
17:44:31 <Pseudonym> Isn't that what we had?
17:44:36 <Pseudonym> Hmmm.
17:44:39 <Heffalump> yes, but ghc accepts it
17:44:53 <Heffalump> which appeared to be the problem before
17:44:58 <Pseudonym> It could have been a typo.
17:45:01 <Heffalump> If I'm confused about that, then I've just wasted 10 mins playing :-)
17:45:12 <Pseudonym> You never waste time playing
17:45:16 <shapr> yah, really
17:45:17 <Pseudonym> Playing == learning
17:45:28 <Heffalump> true, but I do have more important things to be doing :-)
17:45:46 <shapr> fun stuff?
17:46:08 <Heffalump> somewhat, though doing anything for your day job tends to take some of the fun out
17:46:28 <shapr> I wonder if doing Haskell for my day job would be less fun.
17:47:04 <Heffalump> well, on the flip side, I get paid for doing something I generally do enjoy.
17:47:34 <shapr> I very much enjoy programming.
17:47:36 <Heffalump> though I have a suspicion that postdoccing isn't really very good for my future prospects outside academia
17:47:43 <shapr> Even writing Java is more fun than digging ditches.
17:49:10 <Pseudonym> Depends what kind of ditch.
17:55:32 <syntax-laptop> back & better than ever :)
17:56:39 <syntax-laptop> cl1dev: did you get haskell-mode figured out?
17:56:57 <cl1dev> syntax-laptop: yup :)
17:57:38 <syntax-laptop> cool!
17:57:58 * syntax-laptop maintains haskell-mode for debian, so let me know if there are any problems with that end.
17:59:28 <Pseudonym> Who maintains vimacs?  Is that you?
17:59:44 <syntax-laptop> nope
17:59:55 <cl1dev> GNU Emacs 21.3.50.2
17:59:55 <cl1dev> Copyright (C) 2002 Free Software Foundation, Inc.
17:59:55 <cl1dev> GNU Emacs comes with ABSOLUTELY NO WARRANTY.
17:59:55 <cl1dev> You may redistribute copies of Emacs
17:59:55 <cl1dev> under the terms of the GNU General Public License.
17:59:56 <cl1dev> For more information about these matters, see the file named COPYING.
17:59:58 <cl1dev> DOH
18:00:00 <cl1dev> sorry
18:00:17 <syntax-laptop> Pseudonym: Matt Hope maintains it vimacs
18:00:23 <Pseudonym> Ah, OK.
18:00:33 <Pseudonym> I got the impression it was someone on this channel.
18:00:37 <cl1dev> i did emacs --version | head .. instead of head -1
18:01:04 <Pseudonym> I have a bone to pick with whoever it is.  It overwrote my help tags file.
18:01:18 <cl1dev> syntax-laptop: i'm sure i would be most likely to have problems with it, if they should arise
18:01:35 <syntax-laptop> heh
18:04:05 <Heffalump> Matt Hope has been on here before, if you mean the UNSW guy.
18:04:14 <Heffalump> at least I think he has
18:04:23 <Pseudonym> OK, I'm not crazy then.
18:04:29 <Heffalump> nick of dopey.
18:04:38 <Pseudonym> (WARNING: Old joke follows.)  Or at least not for this reason.
18:04:39 <Heffalump> I could be confused, though, since I may have run into him elsewhere on OPN.
18:09:17 <Pseudonym> Cool.  Managed to kill the "horribly inefficient" comment.
18:09:27 <Pseudonym> And the code is no longer, either.
18:10:06 <cl1dev> i don't see what is so difficult about functional programming
18:10:16 <cl1dev> i thought the concept was supposed to be difficult to grasp
18:10:22 <cl1dev> i'm having no trouble with it
18:10:27 <shapr> that's great
18:10:37 <shapr> too many dysfunctional programmers maybe ;-)
18:10:40 <Pseudonym> The only difficulty is that some people have stuff to unlearn.
18:10:43 <cl1dev> maybe so
18:10:48 <cl1dev> Pseudonym: that should be me
18:11:01 <Pseudonym> You probably knew about recursion, though.
18:11:08 <shapr> you have many years of procedural programming?
18:11:41 <cl1dev> shapr: i just finished writing a gtk+ widget in C using OO programming methods (now THAT will mess with your head)
18:11:44 <Heffalump> I think monads are confusing.
18:11:52 <shapr> actually, OO in C isn't that bad.
18:11:54 <Heffalump> for any newbie, procedurally-inclined or not.
18:11:57 <Pseudonym> shapr: Yes it is.
18:12:00 <cl1dev> i was hoping it might make it into gtk+ but alas it did not :/
18:12:06 <shapr> Pseudonym: I just use Python.
18:12:09 <Pseudonym> I used to use Xt.  Now there's confusing.
18:12:14 <Heffalump> and since you need monads to do anything in Haskell, I think Haskell has an built-in problem with reaching out to new programmers
18:12:17 <cl1dev> Heffalump: i haven't made it to monads yet
18:12:23 <shapr> monads are nifty.
18:12:39 <Pseudonym> shapr: That's cheating.
18:12:40 <cl1dev> Pseudonym: not so much confusing as poorly documented
18:12:40 <Heffalump> that doesn't make them easy to learn
18:12:51 <Pseudonym> cl1dev: True.
18:12:56 <shapr> I think monads are to function calls what continuations are to function calls, meaning, a further separation you never expected.
18:13:14 <Heffalump> if anything, continuations are easier to understand
18:13:26 <shapr> well, continuations seemed obvious to me when I first read about them.
18:13:28 <Heffalump> though Olivier Danvy's papers about them always confuse me.
18:13:31 <Pseudonym> Bring back continuation-based IO, I say.
18:13:43 <Pseudonym> main :: [Response] -> [Request]
18:13:54 * Pseudonym shudders
18:14:03 <Heffalump> so the continuations were implicit in the lazy lists?
18:14:19 <shapr> how can the response be the input?
18:14:24 <shapr> did you wind the program backwards?
18:14:35 <Pseudonym> This is from Gofer, incidentally.
18:14:36 <Heffalump> shapr: it's all lazy, remember
18:14:39 <Pseudonym> Right.
18:14:49 <shapr> oh
18:14:50 <Pseudonym> getChar might read something like this:
18:14:52 <shapr> nifty
18:14:57 <Heffalump> main generates an output Request, and then inspects the first Response on its input
18:15:16 <Pseudonym> getChar resps = GetCharRequest : case resps of (GetCharResponse c : rs) of ...
18:15:22 * Heffalump can imagine seriously confusion from programs not terminating here
18:15:41 <Pseudonym> Even worse is if your request/response lists got out of sync.
18:15:55 <Pseudonym> Which they would occasionally do if you had a bug in your code.
18:15:57 <Heffalump> I guess you could use a monad to hide the details ;-)
18:16:11 <Pseudonym> Also, the IO system wasn't extensible.
18:16:24 <Pseudonym> You could, I suppose, use existential types.
18:16:26 <cl1dev> why does every language call the starting function main, why can't they call it "begin" or "start" ?
18:16:45 <Pseudonym> cl1dev: Hysterical raisins.
18:16:50 <shapr> plus it means "Hand" also
18:17:03 <cl1dev> i know in C main is most often NOT the main function
18:17:05 <Heffalump> Hand?
18:17:13 <shapr> Heffalump: as in main gauche, right?
18:17:19 <Heffalump> oh, right
18:17:22 <Heffalump> in French.
18:17:54 <Pseudonym> cl1dev: In C++ using ELF, of course, you get _init() run before main.
18:18:14 <Pseudonym> Plus there's DllMain under Win32.
18:18:29 <Pseudonym> Why is uninitialised data called BSS?
18:18:40 <Pseudonym> Why is the head of a list called CAR?
18:18:44 <Pseudonym> All hysterical raisins.
18:19:06 <cl1dev> *pukes* on win32
18:19:28 <cl1dev> at least _init() is named properly
18:19:40 <Pseudonym> What about _fini()/
18:19:46 <cl1dev> it does initialization
18:19:57 <cl1dev> what's _fini()?
18:20:03 <Pseudonym> Finalisation.
18:20:04 <shapr> should be end.
18:20:34 <cl1dev> _fini() is only quasi-correct
18:20:39 <cl1dev> :)
18:21:06 <cl1dev> my haskell prompt is a honda :)
18:21:43 <cl1dev> ok, i know i'm really tired now. i'm acting stupid.
18:21:47 <shapr> my haskell prompter is curried chicken.
18:34:46 * shapr gets tired
18:35:30 <Pseudonym> Go sleep then.
18:36:17 <Heffalump> that's no fun
18:36:47 <shapr> good night
18:36:54 * shapr falls over asleep
18:36:58 <Heffalump> weakling!
18:37:09 <polli> thanks for the help guys
18:37:15 <Heffalump> did you get it working?
18:37:22 <polli> no
18:37:36 <polli> but you helped me anyway didn't you :)
18:38:04 <polli> g'night
18:38:08 <Pseudonym> Can you paste the type declaration?
18:38:54 <polli> allModules :: (forall m. (Module m)) => (m -> IRCMessage -> IRC ()) -> IRCMessage -> IRC ()
18:39:01 <polli> - the forall
18:39:08 <Heffalump> ok, try this:
18:39:29 <polli> what? :)
18:39:30 <Heffalump> allModules :: (forall m . (Module m) => m -> IRCMessage -> IRC ()) -> IRCMessage -> IRC ()
18:39:38 <Heffalump> give me time to type it :-)
18:41:46 <polli> omg
18:41:57 <polli> it's working
18:42:03 <polli> no w8
18:42:21 <polli> hadn't uncommented it
18:42:31 <polli> hmm..
18:42:45 * polli checks again
18:44:04 <polli> it works
18:44:12 * polli gives Heffalump a hug
18:45:28 <Heffalump> :-)
18:56:35 <polli> good night 
21:15:16 <CowGirl> which of these does not match :   ([("a",1),("b",2)], "c")     ......  A. (x1:x2:y2:ys)    B. (x,y1:y2:ys)  C. ((x1,x2):xs,y)   ???
21:16:13 <CowGirl> is it B?
21:16:28 <Strike> no, B matches (I think)
21:16:51 <Strike> wait, nevermind
21:16:54 <CowGirl> u know which it is??
21:16:56 <Strike> ignore me :)
21:17:05 <CowGirl> :)
21:17:47 <CowGirl> these match right?? : (x,y)      and    (x:xs,y)     ......im stuck with the other three
21:18:37 <cale> A appears to be a list, so it shouldn't match.
21:18:50 <Strike> yeah, that's what I was thinking
21:19:03 <CowGirl> ohhh ok...i see
21:19:27 <cale> In B the first component matches, but the second component is a list with at least 2 elements, but "c" doesn't have 2 elements, so B doesn't match.
21:20:38 <CowGirl> but only one cant match, its a multiple choice Q, which asks which of these patterns does not match the expression.
21:21:19 <cale> In C, the first component matches, because [("a",1),("b",2)] is a list of pairs with at least 1 element. The second component matches, for sure.
21:21:33 <cale> Hmm... typo?
21:21:55 * Strike thinks so too
21:22:07 <cale> If it was (x1:xs, y1:ys) it would match.
21:22:22 <CowGirl> nope....its right C-   ((x1,x2):xs,y)
21:22:23 <Strike> even (x, y1:ys) would, no?
21:22:33 <CowGirl> thats what the question has, i typed it exact
21:22:35 <cale> Oh, which one matches then.
21:23:46 <CowGirl> here are the choice from the whole thing  (x,y)     (x:xs,y)      (x1:x2:xs,y)     (x,y1:y2:ys)    ((x1,x2):xs,y)
21:24:24 <CowGirl> the first 2 match..
21:24:30 <CowGirl> its the last 3, that im stuck with
21:25:11 <cale> the third matches
21:25:21 <CowGirl> i thought (x,y1:y2:ys)  didnt match, but not sure
21:25:23 <cale> the 4th doesn't match.
21:25:51 <CowGirl> yeah, thats the one i think to...so i guess thats right
21:26:14 <cale> yeah
21:26:32 <CowGirl> im just going over past exams!
22:21:21 <Strike> hmm, why would "uniquifyList = map head $ group" be wrong?
22:21:30 <Strike> because when I apply it manually to actual lists .. it works
22:21:42 <Strike> <flood>
22:21:45 <Strike> *** Expression     : map head $ group
22:21:45 <Strike> *** Term           : map head
22:21:45 <Strike> *** Type           : [[b]] -> [b]
22:21:45 <Strike> *** Does not match : ([a] -> [[a]]) -> [b]
22:21:45 <Strike>  
22:21:47 <Strike> List> map head $ group ["111", "111"]
22:21:49 <Strike> ["111"]
22:21:51 <Strike> </flood>
22:23:59 <Strike> (and just for giggles, if there's a more standard idiom for removing dupes from a list, like using list comprehensions or something, that'd be cool to know too)
23:02:44 <Pseudonym> strike: I think you mean map head . group
23:02:45 <Pseudonym> Not $
23:03:05 <Strike> ah, you know .. that makes sense
23:03:27 <Strike> hmm, but does it work?
23:03:42 <Pseudonym> The standard idiom for removing duplicates is nub.
23:03:55 <Strike> oh, is that what "nub" means?
23:04:07 * Pseudonym nods
23:04:16 <Pseudonym> Note that nub is O(n^2)
23:04:17 <Strike> heh, I wondered what that function was
23:04:53 <Pseudonym> If you need something more efficient, you can sort then write a function which removes adjacent duplicates.
23:05:08 <Pseudonym> Though personally I find a function which sorts and removes duplicates at the same time to be very useful.
23:05:09 <Strike> nah, I don't, but thanks
23:05:35 <Strike> really I was just working on a permutation function and I need to remove dupes from the generated list at the end
23:08:33 * Pseudonym nods
23:08:36 <Strike> ah, group only groups them in a common list if they are adjacent (i.e., mapping head onto the result of group is only equivalent to nub for sorted lists)
23:08:43 <Pseudonym> Right.
23:08:50 <Strike> so, group [1, 2, 1] doesn't make [[1,1], 2] like I thought it did
23:08:54 <Strike> probably should have checked that :)
23:08:55 <Pseudonym> So map head . group . sort might work nicely.
