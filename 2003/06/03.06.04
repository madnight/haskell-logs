00:05:39 <kip_> anybody know how to set the "command line arguments" inside the hugs interpreter?
00:06:34 <resolve> hello folks!
00:07:02 <resolve> is it possible to temporarily rebind a function definition? i have two interpreters which differ only by which functions they apply
00:07:20 <resolve> it'd be cool to just rebind the same  function and save redefining the structure
00:07:46 <resolve> i'd like to do something like let * = *# \n ... code as before
00:08:04 <resolve> well, absFunc = let * = *# oldFunc
00:08:12 <kip_> resolve, you don't happen to know how to set the command line arguments in Hugs, do you?
00:08:26 <resolve> kip: "set"?
00:08:34 <resolve> arent' command line args just read from?
00:08:41 <kip_> oh
00:08:42 <resolve> oh, to the program you're invoking? nope, sorry
00:09:15 <resolve> i just run "runhugs program arg1 arg2" ...
00:09:26 <kip_> ahh, ok
00:09:29 <kip_> thanks
00:09:34 <kip_> it's easy to set them in ghci
00:14:42 <Pseudonym> resolve: I really don't understand the question.
00:14:57 <Pseudonym> Do you want two programs which are the same except for the definition of one or two functions?
00:15:41 <resolve> Pseudonym: picture something like:
00:15:41 <resolve> interpret' (Mul e1 e2) e = interpret' e1 e * interpret' e2 e
00:15:41 <resolve> interpret' (Add e1 e2) e = interpret' e1 e + interpret' e2 e
00:15:47 <Pseudonym> OK.
00:15:57 <resolve> say you want another function, foo', which is the same as interpret', but use *# and +#
00:16:19 <Pseudonym> With you so far.
00:16:40 <resolve> so i'm just wondering about ways i can do that with minimal code repetition. i gather that it won't work with let, due to scoping rules
00:16:50 <Darius> abstract
00:16:57 <Pseudonym> You want both interpret' and foo' available at the top level.
00:17:01 <kip_> resolve, you can pass the operators (+), (*) as arguments
00:17:03 <Pseudonym> OK, here are two solutions.
00:17:12 <Pseudonym> OK, kip beat me to one of them.
00:17:23 <Pseudonym> So you can have:
00:17:45 <Pseudonym> fooSkeleton opTimes opPlus x e
00:17:54 <Pseudonym>     = fooSkeleton' x e
00:17:55 <Pseudonym>     where
00:18:10 <resolve> for a large number of parsing rules, that'd probably need to be put in a table, i gather. but that'd be workable
00:18:20 <Pseudonym>         fooSkeleton' (Mul e1 e2) e = interpret' e1 e `opTimes` interpret' e2 e
00:18:30 <Pseudonym> resolve: Then there's the second solution.
00:18:43 <Pseudonym> You can do it by passing a "phantom" operation.
00:18:53 <Pseudonym> Get Haskell to implement the record for you.
00:18:59 <Pseudonym> Here's the idea:
00:19:06 <resolve> *watches*
00:19:07 <Pseudonym> class Operations op where
00:19:19 <Pseudonym> What's the type of Mul?
00:19:27 <resolve> data Exp = Num Int | Mul Exp Exp | Add Exp Exp | Var Id | Let Id Exp Exp
00:19:29 <Pseudonym> I assume e is some kind of enironment.
00:19:29 <resolve>   deriving (Read, Show)
00:19:30 <Pseudonym> OK.
00:19:32 <Pseudonym> class Operations op where
00:19:46 <Pseudonym>     times :: op -> Exp -> Env -> Whatever
00:19:50 <Pseudonym>     plus :: op -> Exp -> Env -> Whatever
00:19:56 <Pseudonym> With me so far?
00:20:06 <Pseudonym> Oh, hang on.
00:20:11 <Pseudonym> Sorry, got that wrong.
00:20:20 <Pseudonym> I assume interpret' :: Exp -> Env -> Value
00:20:22 <Pseudonym> or something
00:20:37 <Pseudonym> Right?
00:21:49 <Pseudonym> Hello?
00:22:05 <Pseudonym> Oh, hang on, it's Int.
00:22:06 <Pseudonym> OK.
00:22:12 <Pseudonym> class Operations op where
00:22:26 <Pseudonym>     mulOp :: op -> Int -> Int -> Int
00:22:31 <Pseudonym>     addOp :: op -> Int -> Int -> Int
00:22:34 <Pseudonym> Right.
00:22:42 <Pseudonym> Then you make instances:
00:22:51 <Pseudonym> data InterpretOps = InterpretOps
00:22:58 <Pseudonym> instance Operations InterpretOps where
00:23:03 <Pseudonym>     mulOp _ = (*)
00:23:08 <Pseudonym>     addOp _ = (+)
00:23:13 <Pseudonym> Note you ignore the first argument.
00:23:19 <Pseudonym> OK.  Then you can write this:
00:23:43 <Pseudonym> skeleton' ops (Mul e1 e2) e = mulOp op (skeleton' ops e1 e) (skeleton' ops e2 e)
00:23:46 <Pseudonym> etc
00:23:53 <Pseudonym> Ten:
00:24:04 <Pseudonym> interpret' = skeleton' InterpretOps
00:24:10 <Pseudonym> Get the idea?
00:24:34 <Pseudonym> I haven't thought up a name for this yet, but I think I'm going to call it the "traits idiom" by analogy tot he C++ idiom of the same name.
00:25:45 <Pseudonym> The neat part about this is you can get GHC to {-# SPECIALISE #-} the skeleton function so it's just as fast as the duplicated code version.
00:26:20 <Darius> And perhaps implicit parameters to make it as parsimonious.
00:26:27 <Pseudonym> Perhaps.
00:26:36 <Pseudonym> You might be able to get away with passing it in the environment, too.
00:27:38 <Pseudonym> I have a deep distrust of implicit parameters, personally, but YMMV.
00:27:50 <Pseudonym> http://www.haskell.org/hawiki/AvoidingParameterPassing
00:27:52 <Darius> I've never used them.
00:28:12 <Darius> This is a specific instance of the idea I was thinking on before that seems to be very close to named instances.
00:28:42 <Pseudonym> ANyway, gotta go home.
00:29:42 <resolve> just catching up on what you said
00:29:44 <resolve> thanks for that :)
01:33:14 <d-bug> tjena Marvin--
01:33:30 <Marvin--> morrn
02:41:12 <Marvin--> hrrrm, I can't seem to load hierarchical modules in hugs?
02:47:06 <dust-puppy> does a command named E ring a bell to you guys ?
02:47:19 <Marvin--> as in the E prover?
02:47:23 <dust-puppy> E -cpp > HappyTemplate.hspp GenericTemplate.hs
02:47:23 <dust-puppy> E: not found
02:47:34 <Marvin--> nope, can't say I know of THAT E
02:47:56 <Marvin--> I'm familiar with the E FOL prover though, if that helps :-)
02:51:52 <Marvin--> aha, hugs +N
02:51:54 <Marvin--> shesh
02:56:02 <pesco> heh
05:39:51 <d33p> Can someone please recommend a free Haskell book?
05:56:51 <d33p> should i intepret this silence to mean no such book exists? 
05:57:02 <Segora> hmm
05:57:08 <Segora> maybe nobody knows of one.
05:57:17 <Segora> did you look at www.haskell.org?
05:57:22 <d33p> yeah, i have.
05:57:36 <d33p> they just want me to whip out my credit card
05:57:41 <Segora> hmm?
05:58:26 <Segora> did you try 'Gentle Introduction to Haskell' ?
05:58:27 <d33p> just a bunch of links to paper books that are sold in bookshops
05:58:56 <d33p> yeah, i think so
05:59:16 <Segora> it's linked from the learning page (tutorial column in the table) -> http://www.haskell.org/tutorial/
05:59:25 <Segora> You can download it for free.
05:59:47 <d33p> ok.. it sounds familiar, i'll look it up
06:00:14 <Segora> have fun
06:01:37 <d33p> thanks :)
06:05:17 <d33p> this is more of a tutorial it seems
06:05:35 <Segora> well, it's called a tutorial. ;)
06:05:44 <d33p> hehe
06:05:52 <Segora> for what kind of material were you actually looking?
06:06:16 <d33p> hmm.. somethign comprehensive 
06:06:22 <Segora> (move the 'for' to the end if this sentence feels strange to you)
06:06:38 <Segora> hmm
06:07:44 <Segora> if tutorial + reference material are not enough, I'd suggest going to a library and getting one of the books that are mentioned on the site or maybe even buy one.
06:08:10 <d33p> Segora: iam going to go buy the craft of haskell tomorrow
06:08:33 <d33p> i'd rather not spend any money learning a language though.. seems kind of silly
06:09:39 <Segora> well, there's a tradeoff: Either you spend more time or more money.
06:10:05 <Segora> The table of contents of the book looks promising, though.
06:10:27 <d33p> Segora: okay, i dont mind spending money if its a gook book
06:10:33 <d33p> but i've had a bad experience with programming books
06:10:42 <d33p> bought some useless java books :\
06:10:51 <saz> /w 3
06:10:54 <saz> hmm
06:10:56 <Segora> well, there sure are many of these
06:10:56 <saz> oops
06:11:16 <d33p> Segora: indeed
06:12:18 <Segora> Sometimes, I try to get a feel for a book im thinking about buying by using a library-lent version first. If I find it suitable, I go out to the bookstore.
06:13:11 <d33p> Segora: well, my public library has few technical books and my school library will invariably have such books loaned out already
06:13:25 <Segora> :(
06:13:43 <Segora> you live in the U.S.?
06:13:53 <d33p> no, australia
06:14:08 <Segora> didn't know it was as bad there, too.
06:14:28 <d33p> yeah, things could be better :\
06:14:32 <Segora> situation is getting worse even here in germany.
06:15:04 <d33p> yeah mostly due funding cuts, government is too busy fighting wars 
06:16:12 <Segora> hmm
06:16:23 <Rafterman> d33p: which school are you at?
06:16:39 <d33p> Rafterman: UWA - Uni of Western Australia
06:16:53 <Rafterman> ah ok, they do haskell there do they?
06:17:03 <d33p> yeah, haskell is pretty big here
06:17:06 <Rafterman> cool
06:17:11 * Rafterman tutors haskell at UNSW
06:17:37 <d33p> nice
06:18:15 <Igloo> We'll have the whole department here at this rate  :-)
06:18:24 <Rafterman> hehe
06:32:23 <||zeus||> can anyone think of a function that returns a function as a result?
06:32:33 <tez> map id
06:33:25 <ChilliX> ||zeus||: (.)
06:33:29 <tez> In fact, almost any curried function will return a function as a result.
06:34:08 <||zeus||> like what?
06:34:14 <tez> map id
06:34:19 <tez> foldr
06:34:21 <tez> foldl
06:34:26 <tez> (.)
06:34:34 <tez> (+) 1
06:34:37 <||zeus||> no it wont it will return an updated list
06:34:46 <tez> what, map id?
06:34:50 <tez> I don't think so.
06:35:05 <tez> map id [1,2,3] will return an updated list.
06:35:08 <ChilliX> *Main> :t map id
06:35:08 <ChilliX> forall a. [a] -> [a]
06:35:15 <ChilliX> Doesn't look like a list to me...
06:35:54 <ChilliX> Technically, every curried function with more than one argument returns a function
06:36:06 <ChilliX> that's the whole point
06:39:23 <||zeus||> Chilli: removeStuff str = (remove ' ' . remove ',')str, where?
06:39:34 <||zeus||> ChilliX: ?
06:40:09 <||zeus||> remove cha str = [x | x <- str, x /= cha]
06:41:45 <||zeus||> ChilliX: where?
06:42:15 * ChilliX blinks.
06:42:28 <||zeus||> removeStuff "tw,at" - will return a string, wont it?
06:43:12 <ChilliX> will work on any list
06:43:21 <||zeus||> No.
06:43:25 <ChilliX> no, remove will
06:43:30 <ChilliX> removeStuff returns a list
06:43:31 <ChilliX> so?
06:43:34 <||zeus||> any string yes
06:43:36 <ChilliX> list = string
06:44:15 <||zeus||> so......List is a data type not a function?
06:44:19 <keverets_> not necessarily.
06:44:35 <ChilliX> list's are a datatype, yes.  so?
06:44:52 <ChilliX> map id has type [a] -> [a]
06:44:59 <ChilliX> that's not a list, it is a function over lists
06:45:21 <ChilliX> but if you prefer take (.) as an example
06:45:44 <ChilliX> takes two functions and composes them into a new one
06:46:03 <ChilliX> maybe easier to see how this returns a function
06:46:49 <steveh> @type (.)
06:46:50 <lambdabot> (.) :: (a -> b) -> (c -> a) -> c -> b
06:47:13 <ChilliX> good bot :-)
06:48:05 <||zeus||>  removeStuff str = (remove ' ' . remove ',')str,  so this alone returns a function?
06:48:29 <||zeus||>  remove cha str = [x | x <- str, x /= cha], and this strings?
06:48:33 * ChilliX throws lambdabot a fixed point
06:49:17 <||zeus||> am i correct?
06:49:28 <ChilliX> no, "remove ' ' . remove ','" returns a function
06:49:39 <ChilliX> removestuff doesn't because of the argument str
06:49:49 <steveh> removeStuff = (remove '' . remove ',') would return a function
06:50:01 <ChilliX> which is the nicer definition anyway
06:50:07 <||zeus||> would it work the same?
06:50:10 <ChilliX> yes
06:50:13 <steveh> in this case anyway :)
06:50:37 <||zeus||> why is it a nicer defintion?
06:50:58 <ChilliX> short answer: because it is point-free
06:50:59 <steveh> zeus: the name of the formal parameter doesn't clarify things in this case
06:51:08 <steveh> aka "pointless" :)
06:51:32 <ChilliX> steveh: hehe
06:52:28 <ChilliX> ||zeus||: essentially, it is nice (at least in an FP language) to argue about function and not about data if you can avoid it
06:53:19 <||zeus||> ok thx
07:02:19 <Smerdyakov> Does anyone know whether the Eiffel language once influenced by ML and/or Haskell progenitors?
07:02:22 <Smerdyakov> s/once/was
07:03:05 <ChilliX> A while ago I sat in a talk by Bertram Meyer
07:03:22 <ChilliX> he was talking about extension to the original Eiffel language
07:03:44 <ChilliX> and said that they can also do closures now; I think, he mentioned haskell in this context
07:04:07 <ChilliX> (not sure I got the details right)
07:04:13 <Smerdyakov> Oh. What about the first version in 1986?
07:04:22 <ChilliX> don't know
07:04:27 <Smerdyakov> It has parametric polymorphism, which makes me wonder.
07:05:04 <ChilliX> yeah, would be interesting to know
07:05:26 <Igloo> Oh, if anyone has a minute can you message me where you would go from http://www.haskell.org/ if you wanted to find a page on Template Haskell please (or what link you'd expect to see if there isn't an obvious path)?
07:06:31 <Smerdyakov> Tough one..
07:06:59 <steveh> well
07:07:14 <steveh> I think ML was the first language to have parametric polymorphism
07:07:26 <Smerdyakov> Not sure if it's compilers or libraries.
07:07:28 <steveh> So I'd expect there'd be some influence on Eifell
07:07:32 <steveh> Eiffel even :-P
07:08:44 <tez> Igloo: I went to 'The Future of Haskell' link.  I didn't find it in there.
07:09:42 <steveh> hello SyntaxPolice
07:09:49 <SyntaxPolice> steveh: howdy :)
07:09:52 <Smerdyakov> The logo on www.haskell.org is ugly, tome.
07:09:54 <Smerdyakov> to me
07:10:04 <mgoetze> hi SyntaxPolice :)
07:10:14 <SyntaxPolice> mgoetze: morning morning :)
07:10:34 <Igloo> tez: Bah, a concensus on one of the existing possibilities was meant to emerge, not more options  :-)    But seriously, thanks
07:10:45 <mgoetze> well. can't say i quite agree with you there, but good afternoon to you anyhow :)
07:10:45 <tez> lol, sorry.
07:11:08 <Igloo> Oh, the extensions page got merged into there - that looks most appropriate then
07:11:23 <steveh> Smerdyakov: better than the logo at http://www.research.att.com/~bs/C++.html :)
07:11:59 * Igloo strokes his lovely TH logo again and wonders how long before you all get sick of me  :-)
07:12:03 <SyntaxPolice> mgoetze: thanks. its getting on toward afternoon here too. had a power outage and my alarm didn't wame me up
07:12:13 <SyntaxPolice> Igloo: make me a lambda-cat logo! :)
07:12:16 <Igloo> steveh: Which logo? Or is that the point?
07:12:22 <steveh> Igloo: bingo
07:13:08 <Igloo> Syn: Sadly although I can generally visualise what I want I can't actually do the graphics side of it
07:13:37 <Smerdyakov> Igloo, if a fellow called "moondude" is ever on freenode, you might want to ask him.
07:14:04 <Igloo> Smerdyakov: Ask him what, and why?
07:14:11 <Smerdyakov> Igloo, he made some nice logos here: http://www.youngprogrammers.net/phpBB/viewtopic.php?topic=1284&forum=11&5
07:14:22 <Igloo> Ah, you mean SyntaxPolice then
07:14:44 <Smerdyakov> Oh
07:14:45 <Smerdyakov> OK
07:14:48 <Smerdyakov> Then SyntaxPolice, "
07:14:48 <Smerdyakov> :-)
07:15:04 * SyntaxPolice looks around in confusion
07:15:40 * Igloo can't see the new logos on that page
07:15:53 <Smerdyakov> Yes. It's odd. Was working yesterdayish.
07:16:27 <Igloo> Oh, they're just on a dead site
07:16:35 <Smerdyakov> :-(
07:17:04 <||zeus||> Smerdyakov: hi 
07:17:31 <SyntaxPolice> shapr: you have a blog somwehere?
07:17:34 <SyntaxPolice> where is shapr anyway
07:17:35 <Smerdyakov> ||zeus||, hi!!
07:17:56 <||zeus||> Smerdyakov: how are u?
07:18:10 <||zeus||> Smerdyakov:what u up to??
07:18:20 <Smerdyakov> ||zeus||, I'm fine! I'm up to nothing!
07:35:53 <hdaume> morning
07:54:28 <mgoetze> hdaume: btw, i think i've neglected to mention this so far... i hate your tutorial!
07:54:45 <hdaume> mgoetze: why?
07:55:04 <mgoetze> "there are several options: emacs and xemacs." like, come on.
07:55:10 <hdaume> haha
07:55:25 <d33p> where is your tute?
07:55:27 <hdaume> i haven't touched that in like ayear and never really wrote that section
07:57:29 <hdaume> mgoetze: what do you use?  vim?
07:57:53 <mgoetze> hdaume: yeah.
07:58:21 <mgoetze> wouldn't really know what to say about it if someone asked me what makes it really stand out for haskell
07:58:27 <hdaume> mgoetze: doyou know what other common ones are?  i know someone out there uses BEdit; there's also that JDeveloper hack...
07:58:27 <mgoetze> it just works, and i use it for everything
07:58:42 <mgoetze> nope, no idea
07:59:28 <hdaume> yeah....about 5 or 6 years ago i had to decide whether to learn vim or emacs and chose the latter for no apparently good reason and now i'm pretty much so used to it that to change would be quite difficult
07:59:41 * hdaume likes run-on sentences :)
08:00:20 * Igloo chose vi(m) for everywhereness and low overhead mainly
08:00:32 <Igloo> I'll learn emacs at some point, but I haven't finished learning vim yet
08:00:52 <hdaume> does vi(m) support, eg., japanese input?  (this is another thing that emacs does pretty well that i need.)
08:00:56 * mgoetze tried emacs briefly but didn't really like it
08:01:01 <mgoetze> hdaume: yup
08:01:13 <hdaume> maybe i'll learn it at some point
08:01:15 <mgoetze> hdaume: everything's utf-8 internally
08:01:19 * hdaume googles for "vim for emacs users" :)
08:01:23 * Igloo doesn't know anything about internationalised stuff at all
08:02:08 <Igloo> But I managed to make it show Hebrew letters at one point for no particular reason
08:02:40 <mgoetze> Igloo: in command mode, :dig to get a list
08:02:53 <mgoetze> then in insert mode, ctrl-k followed by two letter combination
08:02:58 <shapr> SyntaxPolice: eh?
08:04:39 <Igloo> mgoetze: ... because I have no reason to do so  :-)
08:04:59 <shapr> vim for emacs users is M-x viper-mode
08:05:10 <Igloo> Although when a Haskell 98 implementation is released I might start writing my code in Klingon
08:05:15 <shapr> hdaume: hey, I want access to the tute again
08:05:40 * Igloo suspects there might be a lack of vocabulary though, unfortunately
08:05:46 <mgoetze> Igloo: things like 1/2 are still fun, or the copyright symbol, etc.
08:05:47 <shapr> actually
08:05:53 <shapr> I have the klingon dictionary handy
08:06:06 <mgoetze> shapr: oh, what's foldl in klingon?
08:06:15 <shapr> nuQ'neH
08:06:22 * shapr is lying through his teeth
08:06:44 <shapr> hm, foldl could be interesting
08:07:15 <mgoetze> aren't klingons always lying through their teeth?
08:07:15 <Igloo> I guess you could just do it all phoenetically
08:07:30 * hdaume is off to work
08:07:41 <Igloo> But you'd never get rid of English keywords  :-(
08:08:27 <shapr> hm
08:09:37 * andersca bounces
08:09:49 * shapr boings
08:14:23 <keverets_> I would descripbe viper-mode as "emacs for vi users"
08:14:31 <keverets_> s/descripbe/describe/
08:17:28 <SyntaxPolice> shapr: I recall that you used ot have a blog on advogato, now you have a blog elsewhere. comments / reasons?
08:17:45 <shapr> the elsewhere blog was first
08:18:18 <shapr> I stopped using advogato because I can't seem to stick to software blog entries.
08:19:04 <SyntaxPolice> I see
08:19:19 <shapr> I think I'd prefer to have a personal wiki that has some blog support.
08:19:35 * Igloo smiles
08:20:10 <shapr> hi Igloo!
08:20:18 <shapr> hello polli
08:20:21 <shapr> ahem, polpo 
08:20:41 <Igloo> Hey shapr
08:20:58 <shapr> has anyone else said anything about the new TH logo?
08:21:48 <Igloo> Heh, not since Chilli said ":-))". Someone did e-mail to say they read the report from teh field and thought it was interesting though, so hopefully the HW guys will agree with them  :-)
08:42:47 <shapr> well now
08:42:50 <shapr> that was exciting
08:49:28 <shapr> SyntaxPolice: I like the mascot
08:49:58 <shapr> I want relative libraries
08:50:04 <shapr> is that how the python-style imports work?
08:51:17 <shapr> specifically, if I have bar/foo.py and there's also bar/__init__.py then I can add bar/ to my library search path, and import bar.foo to get everything in foo.py
08:51:39 <shapr> and foo.py doesn't have to explicitly say that it's Module bar.foo
08:52:50 <shapr> hi hal
08:52:53 <hdaume> hey shae
08:52:58 <shapr> how's work?
08:53:04 <hdaume> meh
08:53:09 <shapr> that good :-)
08:54:29 <shapr> I've considered inviting Ross Paterson or John Hughes to #haskell for a short chat on arrows, you think people would be interested in that?
08:54:44 <hdaume> probably
08:55:22 <shapr> cool
09:13:50 <shapr> hi buggs 
09:14:27 <buggs> hoi shapr
09:15:24 <dennisb> shapr: I've talket to John about the channel, and he is a little interested. I've even offered to help him get a irc program running and so on. The problem is that he has very little time for things like this
09:16:19 <shapr> dennisb: I can understand that. I think I'd prefer to read his next paper on Arrows, rather than distract him with lots of IRC chat.
09:16:24 <dennisb> So I don't expect him to be here as much (id any) as some of us
09:16:51 <shapr> Maybe he would be interested in scheduled chats.
09:17:02 <andersca> dennisb: when are we gonna have lunch with norpan, john and koen? :)
09:17:13 <dennisb> well, he is interested to see how it works with irc, and to see what "ordinary" people talk about when they talk about haskell
09:17:24 <shapr> dennisb: he could look at the logs
09:17:40 <shapr> http://tunes.org/~coreyr/
09:17:44 <shapr> that's the nicest interface
09:17:54 <dennisb> andersca: sure, but I'd rather help him find the channel first
09:18:01 <dennisb> shapr: that was to you
09:18:15 <shapr> ?
09:18:21 <dennisb> andersca: why not when hell freezes over, are you free then?
09:18:44 <dennisb> shapr: who know, maybe he will stay here for ever, always online :-)
09:18:48 <shapr> heh
09:19:40 <shapr> I notice that only #emacs and #lisp have more regular traffic than #haskell
09:20:02 <shapr> given the relative age and popularity, I think #haskell is doing very well.
09:23:02 <dennisb> but to invite people and have some prepared questions to ask is not a bad idea
09:23:13 <shapr> cool :-)
09:23:25 <dennisb> I'm sure John would come
09:23:28 <shapr> neat!
09:23:59 <dennisb> to invite them and not have any questions would be bad (if nobody asks anything :-)
09:24:00 <andersca> the seminar course next semester is gonna be fun
09:24:13 <dennisb> but to make a list of question beforehand might be a good idea
09:24:26 <shapr> If John comes, I'd have lots of questions about QuickCheck at least.
09:25:11 <dennisb> I can ask him tomorrow (to see if he is interested)
09:25:21 <shapr> yes please!
10:15:59 <shapr> hi mattam_
10:18:05 <shapr> hoi BlitzNL 
10:18:13 <BlitzNL> hoi shapr
10:20:32 <ludde> i don't think john has time to be on IRC all the time :)
10:22:40 <shapr> hi baha 
10:37:42 <BlitzNL> I used to write lookups myself, but I think it is nicer to use the prelude functions as much as possible. So I did and came up with this : lookup' xs a = maybe (error "some nice msg") id (lookup a xs), is this the way to go or does anyone have a nicer solution?
10:39:43 <shapr> BlitzNL: is that the same as elem?
10:41:01 <shapr> BlitzNL: maybe you want find?
10:41:08 <shapr> @prelude find
10:41:13 <lambdabot> *** "find" prelude "Haskell Standard Prelude Dictionary": text follows
10:41:13 <lambdabot> find
10:41:13 <lambdabot>   find ::  (a -> Bool) -> [a] -> Maybe a
10:41:13 <lambdabot>   find p                   = listToMaybe . filter p
10:41:24 <shapr> @prelude elem
10:41:25 <lambdabot> *** "elem" prelude "Haskell Standard Prelude Dictionary": text follows
10:41:25 <lambdabot> elem
10:41:25 <lambdabot>   infix  4 `elem`
10:41:25 <lambdabot>   elem ::  Eq a => a -> [a] -> Bool
10:41:26 <lambdabot>   elem              = any . (==)
10:41:33 <BlitzNL> shapr: hehe nice bot ;)
10:41:40 <shapr> yah, lambdabot is great
10:42:16 <BlitzNL> shapr: I'll stick to the lookup, but thnx anyway
10:42:31 <shapr> I don't quite understand what lookup does
10:44:01 <BlitzNL> shapr: lookup works on tuples and compares the fst item in the tuple
10:44:18 <shapr> oh, you want an associative lookup? like Data.FiniteMap ?
10:44:51 <shapr> like this? --> http://www.haskell.org/ghc/docs/6.0/html/base/Data.FiniteMap.html
10:47:05 <BlitzNL> shapr: it looks like it
10:53:51 * shapr boings
10:54:18 <shapr> BlitzNL: oh, there are other associative data structures if you don't like the balanced set 
11:01:43 <shapr> silly question, how much is a subscription to the Journal of Functional Programming?
11:10:32 <shapr> ack
11:11:17 <shapr> 164 pounds sterling for electronic, 182 pounds for print
11:12:45 <steveh> wow
11:12:55 <steveh> I wish I had that kind of money :)
11:13:10 <shapr> yah, I'm too poor.
11:13:29 <shapr> if it were fifty bucks a year, I'd get it.
11:14:50 <shapr> Darius: have you implemented monads in @eval ?
11:22:34 <shapr> g'day Agent Jones
11:22:57 <SyntaxPolice> hiya shapr.
11:23:27 * SyntaxPolice is very frustrated because his mail server is crashing on a regular basis, his home computer went out because of electricity going out, and his laptop is not correctly configured to send & receive mail yet.
11:24:23 <SyntaxPolice> (so this is why the mail from me on libraries@h.o might look bad)
11:25:26 <shapr> what's wrong with your mail server?
11:26:01 <SyntaxPolice> we think its hardware problems. one of the CPU fans went bad a few weeks ago,t hen spammers attacked our machine and sent tons of spam from it :(
11:26:07 <shapr> oh :-(
11:26:21 <SyntaxPolice> so I'm not convinced yet that its not some kind of load problem w/ spammers who are still trying to connect to our machine several times a second
11:26:23 <shapr> that could easily have fried a CPU
11:26:57 <SyntaxPolice> yeah, so its at a colo, and we're going to take my home machine there and take that machine down for a while to investigate.
11:27:08 <SyntaxPolice> sometimes computers are against us.
11:27:26 <d-bug> shapr: few CPU's burn from being overheated, Intel processors slow down the clock or turns off itself
11:44:03 <shapr> hey Smerdyakov, where did you get prices for PLI/ICFP ?
11:52:35 <Smerdyakov> I registered very late.... maybe the day before or something. They were on the page.
11:53:52 <shapr> where's the registration page?
11:56:49 <shapr> http://www.it.uu.se/pli03/register.shtml
11:56:49 <shapr> ?
12:00:14 <Smerdyakov> I'm talking about PLI 2002.
12:00:21 <Smerdyakov> I know less about this year's than you do, I'm sure.
12:00:24 <shapr> oh!
12:00:25 <shapr> whew
12:00:35 <Riastradh> Heh, afraid it already happened?
12:00:38 <shapr> yes :-)
12:01:00 <||zeus||> Smerdyakov: i am struggling to write a haskell function to get the minimum value in a list, can you help?
12:01:43 <||zeus||> I am actually
12:02:00 <Riastradh> Doesn't the Prelude already define a 'minimum' function?
12:02:21 <hdaume> Riastradh: presumably this is an exercise :)
12:02:26 <Riastradh> hdaume, well, yeah.
12:02:31 <||zeus||> Riastradh: yeah. Where to go from there?
12:02:59 <Riastradh> Well, if it's an exercise don't use it.
12:03:28 <||zeus||> Riastradh: ok what to do then?
12:03:37 <hdaume> ||zeus||: use 'min' from the prelude together with a fold
12:03:54 <hdaume> min 5 10 = 5; min 50 2 = 2
12:04:23 <Riastradh> fold won't work.
12:04:42 <Riastradh> Unless there's a negative infinity value in Haskell.
12:04:58 <hdaume> foldr1 or foldl1 will work
12:05:23 <Riastradh> Are they like REDUCE-RIGHT and REDUCE, respectively, from SRFI 1? -- http://srfi.schemers.org/srfi-1/srfi-1.html
12:05:28 <hdaume> or if you're allowed to make an assumption that, say, all the elements inthe list are >0
12:06:07 <hdaume> Riastradh: presumably
12:06:10 <hdaume> @definition foldr2
12:06:11 <lambdabot> Sorry, I don't know the command "definition", try "lambdabot: @listcommands"
12:06:18 <hdaume> @define foldr1
12:06:19 <Riastradh> @prelude foldl1
12:06:20 <shapr> @prelude foldr2
12:06:20 <lambdabot> *** "foldl1" prelude "Haskell Standard Prelude Dictionary": text follows
12:06:20 <lambdabot> foldl1
12:06:20 <lambdabot>   foldl1 ::  (a -> a -> a) -> [a] -> a
12:06:20 <lambdabot>   foldl1 f (x:xs)   = foldl f x xs
12:06:25 <lambdabot> (line 1, column 1):
12:06:27 <lambdabot> unexpected end of input
12:06:29 <lambdabot> expecting white space or simple term
12:06:31 <lambdabot> No match for "foldr2".
12:06:36 <shapr> @get-definition foldr2
12:06:36 <lambdabot> foldr2 not defined
12:06:38 <shapr> @get-definition foldr1
12:06:38 <lambdabot> foldr1 = \f l.if null (tail l) then head l else f (head l) (foldr1 f (tail l))
12:06:49 <Riastradh> @prelude foldr1
12:06:51 <lambdabot> *** "foldr1" prelude "Haskell Standard Prelude Dictionary": text follows
12:06:51 <lambdabot> foldr1
12:06:51 <lambdabot>   foldr1 ::  (a -> a -> a) -> [a] -> a
12:06:51 <lambdabot>   foldr1 f [x]      = x
12:06:51 <lambdabot>   foldr1 f (x:xs)   = f x (foldr1 f xs)
12:14:47 <hdaume> anyone know if there's anything like parsec for ocaml?
12:15:03 <SyntaxPolice> he said the O word!
12:15:07 <shapr> run away!
12:15:08 <SyntaxPolice> ;)
12:15:31 <mattam> OCaml
12:15:34 <mattam> *fear*
12:15:48 * SyntaxPolice has noticed a pattern among open source type people that when they don't know the answer to something, they make a lame joke :)
12:16:00 <shapr> that's an accurate observation.
12:16:05 <mattam> at least i tried
12:16:57 <mattam> too ;)
12:17:16 <SyntaxPolice> :)
12:17:23 <Riastradh> SML!  OCaml!  Scheme!  Erlang!
12:17:33 <mattam> what's parsec ?
12:17:34 <andersca> Java
12:17:48 <Riastradh> That's not a very functional language.
12:17:57 <steveh> andersca: that ought to get you banned ;-)
12:18:17 <shapr> @fact parsec http://www.cs.uu.nl/~daan/parsec.html
12:18:17 <lambdabot> set parsec to http://www.cs.uu.nl/~daan/parsec.html
12:18:25 <mattam> thx
12:18:49 <steveh> continuing SyntaxPolice's train of thought, can Haskell make the Kessel run in less than twelve of them?
12:19:11 <mattam> nice, i haven't read anything about combinator parsers yet !
12:19:13 * shapr googles for Kessel
12:19:24 <steveh> shapr: that's a line from Star Wars :)
12:19:31 <shapr> oh DUH
12:19:34 * shapr smacks himself
12:20:09 <shapr> for some reason I thought it was a camel race, relating to the OCaml question
12:20:15 <steveh> heh
12:20:29 <steveh> the "them" was purposefully vague :)
12:24:21 <andersca> shapr: I LOVE my keyboard
12:24:24 <shapr> andersca: yay!
12:24:32 <shapr> have you tried any remappings?
12:24:34 <andersca> yes
12:24:38 <andersca> switched alt and alt gr
12:25:21 <shapr> do you use emacs?
12:25:23 <andersca> yes
12:25:38 <shapr> I've rebound hippie-expand to caps_lock
12:26:07 <shapr> I've swapped Shift_L and Delete, and put iswitchb-buffer on Shift_R
12:26:09 <andersca> yeah, I'm thinking about that
12:26:13 <andersca> hippie-expand that is
12:26:19 <steveh> what keyboard is this?
12:26:24 <shapr> kinesis contoured
12:26:24 <andersca> I use delete a lot
12:26:40 <steveh> hmm
12:27:02 <shapr> http://www.kinesis-ergo.com/images/500-blk.jpg
12:27:16 <shapr> pesco: hey, you like your kinesis?
12:27:18 <steveh> wow
12:27:31 <pesco> shapr: yay
12:27:32 <steveh> that's a radically nonstandard keyboard :)
12:27:42 <shapr> steveh: it's radically better
12:28:03 <steveh> wonder if I can give one a shot somehow
12:28:07 <shapr> I have two white models, I want a black model.
12:28:34 <shapr> andersca: how long did it take you to adjust?
12:28:54 <shapr> I still have some trouble hitting the wrong function key
12:29:17 <pesco> I keep hitting F1 when I want ESC in vi.
12:29:38 <pesco> Resulting in the Gnome Help program opening. gar, I have to fix that some time.
12:29:40 <shapr> the function keys could be improved
12:29:43 <shapr> heh
12:29:53 <shapr> I wish I could feel the difference
12:30:15 <shapr> I wonder if I could make a dent in alternating sides of the fkeys
12:30:17 * steveh doesn't type enough to really get hurt by his keyboard...
12:30:57 <shapr> I've bound lots of stuff to the fkeys, since they're so handy
12:31:08 <pesco> I should do that, too.
12:31:19 <||zeus||> can anyone give me an example of lazy evaluation?
12:31:20 <shapr> I can reach everything on my keyboard without moving my palms.
12:31:35 <shapr> ||zeus||: foo = 1 : 2 : zipWith (+) foo (tail foo)
12:31:39 <steveh> ||zeus||: I would but it's too much effort.
12:31:43 <shapr> er
12:31:47 <steveh> thanks folks, I'm here all night!
12:31:51 <steveh> :)
12:31:53 <shapr> steveh: hah!
12:32:05 <andersca> haha
12:32:16 <steveh> let x = [1..]
12:32:21 <steveh> there, that's lazy :)
12:32:25 <mattam> from what I read combinator parsers accept only LL languages. Is that right ?
12:32:36 <shapr> I heard about someone giving a guest lecture, they stood up and said, "Today we'll talk about lazy evaluation. Any questions?"
12:32:49 <steveh> hehe
12:33:36 <||zeus||> can anyone give me an easy example
12:33:37 <||zeus||> ?
12:33:39 <dennisb> shapr: mark jones?
12:33:41 <steveh> shapr: did you know how to type beforehand?
12:33:53 <steveh> shapr: I mean really type?
12:34:10 * steveh does a modified hunt-and-peck, in that hunting is no longer necessary...
12:37:27 <||zeus||> how about this
12:37:37 <||zeus||> take var [1..]
12:37:48 <||zeus||> is that a good one?
12:38:38 <||zeus||> anyone have an opinion?
12:39:13 <||zeus||> is that an example of lazy evaluation?
12:39:20 <||zeus||> am i still connected?
12:39:23 <pesco> The sieve of erathostenes is a pretty good example, too I think.
12:39:23 <tic> yes
12:39:36 <tic> zeus, that's an example, yes.
12:39:46 <andersca> yeah
12:39:55 <||zeus||> a good one?
12:40:54 <||zeus||> if not please gimmie a good one :)
12:41:22 <||zeus||> but a simple one
12:42:03 <shapr> steveh: I learned to hunt'n'peck on a qwerty IBM clicky keyboard, later I learned to touchtype dvorak in 1992
12:42:23 <pesco> It demonstrates lazy evaluation in the fact that the calculation wouldn't terminate with eager eval.
12:42:30 <shapr> I got a kinesis in '99 I think
12:42:35 <andersca> I learned to type the alphabet really fast on an IBM clicky keyboard
12:42:39 <andersca> it was like 1.98s 
12:42:39 <pesco> zeus: So I'd say it's "good enough"
12:42:58 <||zeus||> ok thanks :)
12:45:55 <pesco> sieve (x:xs) = x : sieve [y | y<-xs, y`mod`x /= 0]
12:46:07 <pesco> is that correct?
12:52:24 <||zeus||> thats the sieve of erathous?
12:52:40 <pesco> eratosthenes
12:52:44 <||zeus||> is it?
12:52:47 <wli> let primes = 2 : 3 : 5 : [ p | p <- [7,9..], all ((/=0) . (mod p)) (takeWhile (<=(ceiling . sqrt . fromInteger $ p)) primes)] in take 10 primes
12:52:48 <pesco> yes
13:14:52 <pesco> Anyone here up for some netris?
13:32:07 <keverets_> is there a netris clone written in Haskell?
13:32:15 <keverets_> might be a fun project if not...
13:32:36 <kip_> has anyone played with fudgets?  they look neat
13:33:30 <Smerdyakov> No, but how about: http://www.hprog.org/fhp/CodeApplet !!
13:34:24 <kip_> that looks cool
13:35:32 <Smerdyakov> I am developing it.
13:37:17 <kip_> are you writing this in scheme compiled to java?
13:37:45 <kip_> i'm looking at the SISC interactive applet
13:37:48 <Smerdyakov> No.
13:38:28 <Smerdyakov> Regular Java language.
13:46:08 <||zeus||> Smerdyakov: can you think of how to use recursion to capitalise a string?
13:46:20 <||zeus||> Using recusion
13:46:27 <||zeus||> I could do it like this
13:47:36 <||zeus||> that question to anyone else?
13:48:32 <||zeus||> any ideas?
13:54:42 <mattam> i suppose match with ' ':char:tl -> ' ':Capitalize char:aux tl ?
13:54:56 <mattam> ml/haskell mixed
14:05:45 <keverets_> ||zeus||: sounds awefully like homework.  What's this for?
14:07:33 <keverets_> ||zeus||: you could pattern match to break the first character off, capitalise that and concatenate it with the capitalised rest of the string.
14:43:37 <Darius> cale have you got your SK reducer to get to normal form?
14:44:01 <cale> Oh, I haven't played with it for the last couple days now, so no.
14:44:42 <cale> were there any ideas regarding that?
14:45:24 <cale> The source is a bit of a mess at this point, and needs some major cleaning up, but I could put it online if you want to have a look.
14:45:49 <Darius> There are five axioms that need to be added to make SK combinators extensional.
14:46:03 <cale> okay
14:48:20 <Darius> actually these are for SKI, but it shouldn't take (any?) much effort for just SK
14:48:21 <Darius> E1)     S(S(KK)x)y = K
14:48:21 <Darius> E2) S(S(S(KS)x)y)z = S(Sxz)(Syz)
14:48:21 <Darius> E3)          S(KI) = I
14:48:21 <Darius> E4)         S(Kx)I = I
14:48:21 <Darius> E5)          K(xy) = S(Kx)(Ky)
14:49:10 <cale> great!
15:08:56 <Darius> @prelude concat
15:08:58 <lambdabot> *** "concat" prelude "Haskell Standard Prelude Dictionary": text follows
15:08:58 <lambdabot> concat
15:08:58 <lambdabot>   concat ::  [[a]] -> [a]
15:08:58 <lambdabot>   concat            = foldr (++) []
15:13:05 <||zeus||>  @prelude :
15:13:20 <||zeus||>  @prelude sum
15:17:47 <mattam> is Gopher the same as haskell ?
15:18:38 <Darius> More or less.
15:18:55 <Darius> Hugs is the Haskell User's Gopher System (or was)
15:19:05 <mattam> hmmm
15:19:59 <mattam> reading an introduction to combinator parsing... i found the resemblance intriguing
15:27:41 <cale> Darius: where did you get those rules, btw?
15:31:04 <creature> Evening all. 
15:31:56 <Darius> From some PDF file on citeseer, after googling for 'axiomatization "combinatory logic" extensionality'.  Lectures on the Curry-Howard Isomorphism and Foundations of FP both referred to them, but didn't list them.
15:31:58 <creature> I don't suppose there's anyone around who also does Python? I've been dropped in the deep end, and am learning whilst working. I'd like to use a Haskell-style pattern matching method of doing a function, but don't know if Python supports anything like it. Can anyone tell me what I should be reading? 
15:32:32 <Darius> There a (quite?) a few python users here, e.g. shapr.  I'm not one though.
15:32:39 <creature> Darn. :)
15:33:00 <creature> I want to do a foo [] = []    foo (x:xs) doStuff x : foo xs    style thing.
15:34:02 <Darius> @type ShowS
15:34:12 <Darius> @prelude ShowS
15:34:14 <lambdabot> *** "ShowS" prelude "Haskell Standard Prelude Dictionary": text follows
15:34:14 <lambdabot> ShowS
15:34:14 <lambdabot>   type ShowS   = String -> String
15:34:14 <lambdabot> shows
15:34:16 <lambdabot>   shows ::  Show a => a -> ShowS
15:34:18 <lambdabot>   shows         = showsPrec 0
15:44:27 <creature> Ah, figured it out. 
15:49:32 <Dark-Star> how do I tell hugs to output an unescaped string? I.e. I want an output that looks like this: "\"
15:49:45 <shapr> what about putStrLn ?
15:50:03 <shapr> putStrLn $ show $ "\\5"
15:50:30 <Dark-Star> ok that works, thanks!
15:51:15 <Riastradh> putStr "\"\\\""  -- to get an output of:   "\"
15:51:27 <Riastradh> putStrLn outputs an extra newline.
15:51:33 <Riastradh> Er, not an 'extra' newline.
17:58:56 <steveh> ping?
17:59:02 <cale> pong.
17:59:08 <Smerdyakov> poing.
17:59:20 <steveh> wow
17:59:34 <steveh> 2 hours of silence yet low latency :)
17:59:50 <Smerdyakov> Don't shoot the messenger.
17:59:57 <steveh> my copy of Okasaki just came :)
18:22:15 <cale> @yow
18:22:15 <lambdabot> Were these parsnips CORRECTLY MARINATED in TACO SAUCE?
19:56:59 <cale> @prelude fixedpoint
19:57:01 <lambdabot> No match for "fixedpoint".
19:57:38 <cale> is there something similar to "fixedpoint f = until (\x -> x == f x) f" in the prelude that I don't know about?
20:07:49 <Pseudonym> Not really.
20:08:21 <Pseudonym> In general you want to abstract over the termination condition.
20:08:38 <Pseudonym> e.g. by comparing the previous two values for closeness, say when doing Newton-Raphson root finding
20:08:44 * steveh boggles at the okasaki book
20:08:46 <Pseudonym> You could use scanl
20:08:59 <Pseudonym> And go through the list until you find something you like.
20:09:01 <steveh> his set implementations don't have removal functions!
20:09:06 <Pseudonym> Don't they?
20:09:10 <steveh> nope
20:09:11 <Pseudonym> Huh.
20:09:23 <steveh> i wrote one for my naive finite-map
20:09:30 <steveh> it was pretty thankless :)
20:09:40 <Pseudonym> I wrote an even more naive one with removal.
20:09:51 <steveh> with lists? :)
20:09:54 <Pseudonym> Nope.
20:09:55 <cale> It's just that I've defined that function in a few of my programs now, wondered whether I was repeating myself needlessly.
20:09:58 <Pseudonym> Even more naive than lists.
20:10:08 <Pseudonym> http://www.haskell.org/hawiki/ChainOfResponsibility
20:10:49 <Pseudonym> cale: I don't think so  Fact is, "until" really does the job you want in general.
20:11:31 <steveh> that's a list in disguise, isn't it?
20:11:35 <cale> yeah it's not hard to get from until to fixedpoint.
20:12:11 <Pseudonym> steveh: Kind of.
20:12:27 <Pseudonym> Lists are another way to implement stacked delegation.
20:12:35 <Pseudonym> But my naive solution is much harder to manipulate.
20:12:46 <Pseudonym> You can't, for example, "pop" a list using this method.
20:14:35 <steveh> you can't get more functional than your solution though :)
20:14:41 <Pseudonym> Yup.
20:15:01 <steveh> if haskell is a sugaring of lambda calculus then your finitemap is bran flakes
20:15:10 <Pseudonym> :-)
20:15:20 <Pseudonym> Actually, it would be even better if I could eliminate the need for Maybe.
20:15:28 <Pseudonym> Unfortunately, that's part of the interface.
20:15:35 <steveh> i wonder if there is a specific reason that the sets in okasaki don't have removal functions
20:15:46 <Pseudonym> Probably brevity.
20:15:51 <steveh> they're not even listed as exercises for the reader
20:16:02 <Pseudonym> Although, to be honest, many data structures have more complex removal operations than insertion operations.
20:16:05 <steveh> I guess so
20:16:14 <Pseudonym> e.g. search trees
20:16:15 <steveh> that is quite true
20:16:18 <steveh> right
20:16:27 <steveh> I am specifically talking about his red-black tree
20:16:44 <steveh> which is impressive in its brevity, but it doesn't have deletion!
20:17:02 <steveh> I always thought that deletions were part of having sets/dictionaries
20:17:52 <Pseudonym> When I implemented ternary tries, I found deletions quite hard.
20:18:19 <Pseudonym> There's an argument for mapping from keys to Maybes and just overwriting with "Nothing". :-)
20:18:35 <steveh> ternary trees == binary but with a child for insertions equal to parent?
20:18:41 <Pseudonym> Right.
20:18:47 <steveh> makes sense
20:18:51 <Pseudonym> BTW, "tries", not trees.
20:19:01 <steveh> what's the difference?
20:19:27 <Pseudonym> A trie is a tree which only compares on part of the key.
20:19:29 <Pseudonym> For each level.
20:19:42 <steveh> I've never heard of them
20:19:45 <steveh> Fascinating
20:20:06 <Pseudonym> Well, here's the motivating idea.
20:20:22 <steveh> How is "trie" pronounced?
20:20:27 <saz> try
20:20:36 <Pseudonym> Suppose you need a dictionary of strings.  This is a very common case.
20:20:36 <Pseudonym> It's pronounced "try".
20:20:37 <steveh> thanks
20:20:49 <Pseudonym> OK.  So you might consider binary search trees.  This requires a string comparison at every node.
20:20:59 <Pseudonym> String comparisons are more expensive than you think.
20:21:04 <steveh> yes
20:21:08 <Pseudonym> Or possibly precisely as expensive as you think.
20:21:28 <Pseudonym> Especially when you get down near the leaves of the tree.  You're probably comparing strings with basically the same prefix.
20:22:11 <Pseudonym> The idea behind ternary tries is what you do is construct a binary search tree on the first character only.
20:22:31 <Pseudonym> Then, when you get a match, you go down the "middle" branch, and keep going on the next character.
20:22:32 <steveh> hm
20:22:52 <steveh> I see
20:23:01 <Pseudonym> You never have to do a full string comparison, either.
20:23:16 <Pseudonym> And you only scan the key once.
20:23:59 <Pseudonym> I did an implementation in C++ first and I found it to be about 30% more efficient than hashing.
20:24:10 <steveh> impressive!
20:24:24 <Pseudonym> The main reason is that you only scan the key once.  When hashing, you need to scan it at least twice: once to compute the hash, and once to see if you've got a match.
20:25:03 <Pseudonym> There are drawbacks, of course.  In a ternary trie, for long keys, you need one node per character, which can be expensive.
20:25:19 <Pseudonym> And unlike hash tables, they're much harder to lock for concurrency.
20:25:29 <steveh> I was thinking of space complexity too
20:25:41 <Pseudonym> With hash tables, if you have lots of threads accessing it concurrently, you can just lock one hash chain.
20:26:02 <Pseudonym> Not that this applies to Haskell.
20:26:08 <steveh> hehe
20:26:10 <Pseudonym> Well, sort of.
20:26:51 <Pseudonym> The concurrent Haskell approach is to make a new Haskell thread to manage the hash table and do the accessing via IPC.
20:27:06 <Pseudonym> You could, in principle, crete one Haskell thread per hash chain.
20:27:24 <steveh> I'm not up on concurrent programming in Haskell at all
20:27:29 * Pseudonym nods
20:27:35 <steveh> I can do POSIX threads
20:27:37 <steveh> :)\
20:27:46 <Pseudonym> Well that's a start. :-)
20:28:41 <Pseudonym> http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/haskell-libs/libs/hashtable/
20:28:44 <Pseudonym> If you're curious.
20:29:04 <steveh> aah, tries are in chapter 10 of this book
20:29:09 <Pseudonym> Ah, there you go.
20:31:39 <steveh> I'm gonna need a roadmap to this code :-/  my haskell mojo is quite low
20:32:11 <steveh> actually I need to know what the heck Chan and MVar are
20:35:52 <steveh> ah ok, I found it
20:35:58 <steveh> had to go to the GHC page
20:39:47 <cale> Trie needs a better plural form, I guess it sort of lines up with the cruftiness of the rest of English, though. :)
20:40:52 <steveh> Trieae?
20:41:17 <cale> heheh
20:41:22 <saz> like
20:41:23 <saz> tray?
20:41:39 <steveh> I was pronouncing it "try-ee" in my head
20:42:19 * wli pronounces it "try"
20:42:31 <cale> Tria?
20:42:31 <steveh> aaah, the plural though
20:42:35 <steveh> is what's in question :)
20:42:57 <steveh> cale: pronounced "tree-a?" or "try-a?"
20:43:03 <saz> calling them tries could confused footy buffs
20:43:21 <steveh> eh, it doesn't matter
20:43:22 <cale> steveh: depends on how you pronounce trie, I suppose.
20:43:36 <steveh> anyone who will get confused over "tries" is gonna use a hashtable anyway
20:43:47 <cale> heh
20:43:51 <saz> hehe
20:44:00 <steveh> or should I say a java.util.Hashtable? :)
20:45:41 <cale> haha
21:16:33 <Pseudonym> Actually, "tries" is a normal English word.
21:26:55 <kip_> does anybody here use the emacs haskell mode?  it seems like the "indent" mode is doing funny things for me
21:33:32 <cale> I use vim, so I don't know much about it. What's going on though?
21:34:58 <kip_> oh, well i just discovered that "indent-according-to-mode" does something bogus.  maybe i'll just email the author
21:35:18 <kip_> thanks
