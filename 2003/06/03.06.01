01:05:36 <stepcut> just what I need!!! A prolog program that transforms lambda expressions into SKI combinators!!
01:06:02 <stepcut> http://cs.wwc.edu/~aabyan/LABS/FunctionalProgramming/CHAPTER.html
03:09:53 <Marvin--> what XML package should I use?
03:20:08 <mgoetze> Marvin--: XML sucks. use GTP2. :)
03:21:59 <Marvin--> mgoetze: I don't have much of a choice, I have data in XML that I want to process
03:23:12 <mgoetze> oh
03:26:35 <mgoetze> hmph, no ghc 6.0 package for os x
03:28:26 * mgoetze wonders whether he should try grabbing ghc 4.08 for hppa1.1-hp-hpux and bootstrapping 6.0 with them
03:28:54 <wli> are there ghc6 debs yet?
03:30:45 <mgoetze> wli: none that i can see on packages.debian.org or apt-get.org
03:31:12 <Lilith> wli: not that i can see. 
03:31:38 <wli> dang
03:31:43 <Lilith> does that cover "experiemental" as well?
03:32:26 <mgoetze> it seems like the only ghc release for sgi is 2.10... i bet getting that up to ghc6 would be scary :)
03:33:29 * mgoetze , in a fit of madness, downloads ghc 4.08 for hppa1.1-hp-hpux
03:37:35 <Marvin--> removeAllComment = applyBottomUp (none `when` isXCmt)
03:37:36 <Marvin--> ouch
03:43:26 <jlouis> Marvin--: huh?
03:44:02 <Marvin--> jlouis: I'm reading about HXmlToolBox
03:44:25 <Marvin--> and swearing about the actual code being completely different from the thesis
03:44:47 <jlouis> ah
03:45:07 <Lilith> heh
03:45:18 <Lilith> wasn't shapr fiddling with it before?
03:46:47 <duffy_> hi :)
03:47:33 <Marvin--> Lilith: yeah, I think so
03:47:42 <Marvin--> Lilith: I'm going to bitch at him when he appears :)
03:50:08 <duffy_> i have a problem: suppose you have a [Bool] representing a binary number. now a function is needed that returns the decimal string representation of af [Bool] WITHOUT using Int, Integer, etc. 
03:54:34 <duffy_> I spent the half night thinking about a nice solution but it seems to be tricky. I tought about converting from the binary representation to BCD...
03:55:48 <Marvin--> damn it, I can't even get it to parse a simple document
03:56:00 <Marvin--> unexpected illegal char: '='
03:56:00 <Marvin--> expecting version info (with quoted version number)
03:59:37 <mgoetze> ghc seems to be a lot slower on ppc than x86 (or is it just me?)
04:02:14 <mgoetze> ah, 6.0 adds a native code generator. now i just need a 6.0 package.
04:04:21 <Marvin--> what the fuck does it mean "unexpected illegal char: '='"?!
04:04:41 <Marvin--> what's wrong with   <?xml version="1.0"?> ?!
04:05:56 <mgoetze> Marvin--: the answer is tautological insofar as xml is a synonym for wrong :)
04:08:38 <mgoetze> where can i find a list of which architectures ghc version x has a native code generator for?
04:08:46 <Marvin--> mgoetze: grmbl
04:09:23 * mgoetze gives Marvin-- the Iron Will feat for free.
04:09:46 <Marvin--> mgoetze: thanks
04:09:57 <Marvin--> now I just need the Summon shapr spell too
04:10:50 <mgoetze> Marvin--: here, you can have it, but note that it costs 50000 XP to cast :)
04:10:59 <Marvin--> I can feel my SAN points slipping away
04:11:42 <mgoetze> is that what they're called in the new WotC CoC?
04:12:05 <Marvin--> nah, it's a cthulu thing
04:12:27 <Marvin--> sanity points
04:12:43 <mgoetze> whereby CoC == "Call of Cthulu"
04:12:52 <Marvin--> er
04:12:56 * Marvin-- needs sleep
04:12:57 <Marvin--> or coffee
04:12:59 <Marvin--> or both
04:21:17 <Marvin--> shaaaaaapr
04:21:51 <jlouis> ;P
04:34:17 * shapr poofs
04:34:27 <shapr> Marvin--: yes?
04:34:31 * andersca whabooms
04:34:46 <Marvin--> shapr: *bamf* hey, how the **** do I use hxmltoolbox?
04:35:15 <shapr> oh, just a moment
04:35:40 <Marvin--> I'm having problems "getting" it, since the code is different from the thesis, and the documentation is...lacking
04:36:01 <shapr> I had the same trouble
04:36:02 <Marvin--> I can't even get it to parse "<?xml version=\"1.0\"?>"
04:36:14 <shapr> I wrote unit tests to see exactly what worked and what didn't
04:37:31 <shapr> http://kungens.kemi.fi/~shae/src/haskell/Demo_Hxml.hs
04:37:34 <shapr> see if that helps
04:38:09 <andersca> wow, java 1.5 will have varargs support
04:38:23 <shapr> and run on the mach kernel
04:38:32 <andersca> :)
04:38:35 <Marvin--> andersca: yeah, urk
04:38:45 <Marvin--> shapr: hrrm, but where do you do the parsing?
04:39:00 <andersca> Marvin--: I kinda like how you can do printf in java then
04:39:12 <Marvin--> andersca: I don't
04:39:54 <Marvin--> sure, the way to use the varargs is a whole lot more sane than in C...
04:40:04 <Marvin--> especially with the automatic boxing
04:40:07 <andersca> yeah
04:40:27 <Marvin--> shapr: I mean, I can't even get the parsing going...
04:40:30 <shapr> Marvin--: http://kungens.kemi.fi/~shae/src/haskell/Parsey.hs http://kungens.kemi.fi/~shae/src/haskell/PFilters.hs
04:41:50 <shapr> does that help?
04:42:02 <o3> as far as printf goes, i think python has by far the best implementation
04:42:08 <Lilith> aloha shapr
04:42:12 <o3> (might as well say it when shapr's here to get brownie points)
04:42:18 <Marvin--> shapr: er, what does xattr do?
04:42:19 <Lilith> lol o3
04:42:32 <Lilith> assert!
04:42:45 <Marvin--> o3: yes, it's cute, but the *very* ad hoc overloading of operators in python is kinda creepy
04:43:00 <Marvin--> especially when you've peeked around in the implementation of said overloadign
04:43:01 <shapr> o3: heh
04:43:04 <Marvin--> and the Big Switch
04:43:09 <shapr> hiii Lilith!
04:43:17 <Lilith> if i learnt anything from kernel programming is that assert is better than kprintf!
04:43:22 * shapr bounces
04:43:55 <d-bug> Lilith: Yeah, crash as early as possible :)
04:44:03 <Lilith> andersca: where did you see that?
04:44:06 <d-bug> s/crash/panic/
04:44:17 <Lilith> d-bug: heh. :)
04:44:18 <andersca> Lilith: example code somewhere
04:44:20 <andersca> java.sun.com
04:44:24 <o3> Marvin--: well, you could do the same in haskell
04:44:31 <o3> except that you can't overload % specifically :)
04:44:33 <shapr> Marvin--: the whole secret to HXmlToolBox is to read the Tree/Node types about seven times
04:45:18 <shapr> then you'll realize that mkXTag creates a Tag and xtag creates [Tag] 
04:45:20 <Marvin--> o3: putting operators in type classes gets rid of the whole ad hoc problem
04:45:31 <shapr> hej d-bugd 
04:45:57 <Marvin--> o3: Python has + for adding numbers, and for concatenating sequences, * for multiplying numbers and for replicating sequences...
04:46:17 <d-bugd> hej shapr
04:46:26 <o3> Marvin--: yep, although i wish haskell was a bit more fine-grained in specifying what you can and can't do.  i don't think you can define a matrix class at the moment to use the same + - * / ops, for instance, which would be very useful
04:46:27 <shapr> hur är det med dig?
04:47:02 <d-bugd> shapr: ska strax cykla ner till centrum och k?ka n?t, f?r spader av att vara inne hela dagen
04:47:13 <Marvin--> o3: but they *aren't* the same thing... matrix multiplication isn't commutative for example
04:47:35 <o3> Marvin--: good point
04:48:09 <o3> Marvin--: still, i think using * instead of something more obscure (and ad-hoc in its own way) like <*> would be better
04:48:28 <d-bugd> shapr: och du, vad h?nder?
04:48:32 <Marvin--> shapr: hrrm, what if I don't want to parse a whole file, just a string?
04:48:59 <shapr> jag vil koder!!
04:49:02 <shapr> er vill?
04:49:11 <Marvin--> o3: perhaps, but if functions or operators could belong to more than one type class, you break type inference
04:49:13 <andersca> vill koda?
04:49:17 <Marvin--> shapr: vill koda
04:49:22 <shapr> geez, I can't use "er" for "um" since it's a real word in swedish.
04:49:40 <shapr> tack :-)
04:49:54 <shapr> Marvin--: what do you mean by parse?
04:49:59 <o3> shapr: "AHHRHHRHRHAHRHRAHR" is always a good substitute for "um"
04:50:14 <shapr> good point, that works in any language.
04:50:16 <o3> Marvin--: yeah
04:50:18 <Marvin--> shapr: "<?xml version=\"1.0\"?><a>foo</a>" -> a tree
04:51:10 <o3> shapr: what does 'er' mean in swedish?
04:51:12 <Marvin--> gahhhh, this is one bloated toolbox
04:51:29 <shapr> try getWellFormedDoc
04:51:37 <shapr> getWellformedDoc
04:51:39 <shapr> small f
04:52:28 <Marvin--> but that's a filter function,isn't it?
04:52:56 <shapr> http://kungens.kemi.fi/~shae/src/haskell/Parsey.hs
04:55:49 <Marvin--> eep, I tried to liftIO (print t)
04:55:51 <Marvin--> and...
04:55:59 <Marvin--> and I got ten-twenty lines of errors
04:56:35 <Marvin--> sheesh
04:57:11 <shapr> ?
04:57:14 <shapr> what sort of errors?
04:57:33 <Marvin--> never mind, they'd implemented their own IO lifting instead of using the existing liftIO mechanisms
04:58:02 <Marvin--> and wtf?!
04:58:05 <Marvin--> fatal error: file "/home/martin/programming/haskell/discover-reduce/" not found
04:58:25 <shapr> which version of HXmlToolBox are you using?
04:58:26 <Marvin--> that's my cwd, what does it want to do with that?!
04:58:31 <shapr> 2.02 or so?
04:58:31 <Marvin--> 2.02
04:58:47 <Marvin--> this is waaaay too complicated for me
04:58:56 <shapr> what are you trying to do?
04:59:09 <Marvin--> I thought the xattr function took a file name as second argument
04:59:45 <shapr> nah, xattr makes an xml tag attribute
05:00:03 <Marvin--> hmm, okay, so that's where I'm supposed to stuff my xml text?
05:01:07 <shapr> ohhh
05:01:23 <shapr> if you create a newRoot that has the attribute "source"
05:01:36 <Marvin--> oh for *******
05:01:45 <shapr> then that's a magically significant word that means "you should really read this off of the disk instead"
05:01:46 <Marvin--> how *obvious*
05:02:02 <shapr> instead of treating it like literal text
05:02:24 <Marvin--> I still get
05:02:26 <Marvin--> unexpected illegal char: '='
05:02:26 <Marvin--> expecting version info (with quoted version number)
05:02:27 <Marvin--> though
05:02:47 <Marvin--> this is soooo broken
05:02:50 <shapr> ?
05:03:09 <Marvin--> I'm trying to parse a file that starts with   <?xml version="1.0"?>   and it fails miserably
05:03:43 <shapr> hm, it works for me
05:05:01 <Marvin--> http://193.11.232.159:8080/DiscoverReduce.hs and list.xml
05:05:07 <shapr> do you have your file online?
05:05:16 <shapr> ok :-)
05:05:47 <Marvin--> way ahead of you ;)
05:08:06 * shapr tries to wake up
05:08:20 * Lilith passes coffee to shapr
05:08:39 <Marvin--> I can feel my SAN points slipping away
05:08:43 * shapr slurps 
05:08:48 <Marvin--> I was hoping that doing this in haskell would be more fun than doing it in python
05:08:50 <shapr> Marvin--: it's not that bad really, it's just a different viewpoint
05:09:02 <shapr> Marvin--: it really is pretty spiffy, have you looked at the thesis?
05:09:11 <shapr> the XNode XTree thing is really the central concept
05:09:23 <Marvin--> shapr: yes, but the function names are way off so it didn't help much
05:09:44 <shapr> they changed things to add namespace support
05:09:51 <shapr> that's the only major difference I'm aware of
05:09:56 <shapr> the QNames were a bit weird to start with
05:10:00 <Marvin--> does it have a dtd to datatypes tool?
05:10:10 <shapr> no, it doesn't need one
05:10:23 <shapr> the dtd is part of the document tree as much as the xml content
05:10:50 <Marvin--> shapr: the 'parseDoc' function doesn't seem to exist any more
05:10:53 <shapr> so validation happens when you call both getWellformedDoc with getValidatedDoc(?)
05:11:06 <shapr> right, I bitched and moaned about that, so Dr. Schmidt fixed it :-)
05:11:12 <shapr> and he fixed the examples too
05:11:18 <shapr> but the thesis hasn't been updated.
05:11:26 <Marvin--> but I don't *want* to work on a raw xml tree, I want a nice data type that I can manipulate and then turn back into an xml document
05:11:36 <shapr> you can do that
05:12:00 <shapr> with the XTree(?) type
05:12:04 * shapr looks in the thesis
05:12:32 <Marvin--> NTree?
05:12:40 <shapr> yah, Section 2.2
05:13:15 <shapr> That took me several days to really figure out, but I realized it's very flexible
05:13:27 <shapr> I wish I'd had that when I tried to write a refactoring browser
05:13:28 <Marvin--> I don't see how that helps
05:13:45 <shapr> an xml doc is just a tree
05:13:48 <Marvin--> yes
05:13:53 <shapr> of XNode
05:14:07 <shapr> in HaXml you have separate data types for each node type
05:14:19 <shapr> and it can only have DTD valid children/siblings/etc
05:14:33 <Marvin--> but if I have a DTD that explicitly says that "the doc consists of these nodes that each have those-and-these nodes and that's it", I don't *need* a general tree, since I know that a well-formed doc is only of max depth N
05:15:00 <Marvin--> shapr: anyway, can you spot the error? I sure as hell can't
05:15:12 <shapr> um, just a moment
05:19:21 <Marvin--> I mean it's a simple xml document for crying out loud
05:19:32 <Marvin--> python's xml.dom.minidom took it in-stride
05:19:54 <shapr> I've done it before
05:20:32 <shapr> trying it in ghci, I just can't show the XState state ()
05:21:40 <shapr> I think it's about which run run' or run0 to use
05:22:33 <Marvin--> run' calls run and run calls run0
05:23:05 <Marvin--> I don't see how it would make a difference which I use
05:24:23 * Marvin-- grumbles
05:24:44 <shapr> ok, I think I've gotten it to compile...
05:25:02 <Marvin--> compile? That's not the problem! :(
05:25:20 <Marvin--> the problem is getting it to do something
05:25:21 <o3> i'd say "use perl", but i think i might be regarded as a troll if i say that, so i won't
05:25:27 <shapr> Did you try throwing your dropStuff into Parsey.hs ?
05:25:44 <Marvin--> shapr: no, I haven't even used dropStuff yet since I haven't managed to use getWellformedDoc yet!
05:26:00 <shapr> ah
05:26:02 <Marvin--> o3: I'm very close to hopping over to python, but data types in haskell is so much nicer
05:26:40 <o3> Marvin--: fair enough
05:26:44 <Marvin--> shapr: 'cause I always get parse errors on my documents
05:26:54 <shapr> does it change if you remove the PI?
05:27:03 <Marvin--> PI?
05:27:17 <shapr> processing instruction
05:27:27 <shapr> the <?foo?> tag
05:27:57 <Marvin--> with a simple    <a foo="bar"> <b/> </b>   document I get
05:28:09 <Marvin--> error: "foo.xml" (line 1, column 1):
05:28:09 <Marvin--> unexpected illegal char: ' '
05:28:09 <Marvin--> expecting xml declaration, comment, processing instruction, "<!DOCTYPE" or element
05:28:20 <Marvin--> is it just me or does this seem to be thoroughly broken?
05:29:01 <shapr> it really does work for me, and I'm not awake enough yet to see why your code doesn't work :-/
05:29:02 <o3> do you have a DTD at the top of the document?
05:29:13 <shapr> oh, it does work
05:29:33 <Marvin--> o3: no... I don't, since I haven't even gotten past the <?xml marker
05:29:37 <shapr> Marvin--: I got your dropStuff to work on your list.xml
05:29:44 <o3> Marvin--: yeah, just noticed that
05:29:52 <o3> s/noticed/remembered/
05:30:04 <o3> anyway, time to do some work
05:30:08 <o3> later all, good luck marvin
05:30:24 <shapr> Marvin--: http://kungens.kemi.fi/~shae/src/haskell/Marvin.hs
05:30:54 <Marvin--> shapr: I just don't see what's different in that file compared to what I have
05:31:01 <shapr> calling the resulting binary with "Marvin list.xml" works
05:32:19 <Marvin--> doesn't work for me
05:32:23 <Marvin--> what version are you using?
05:32:52 <shapr> 2.02 or 2.03
05:33:07 <shapr> the latest and greatest from the website
05:33:46 <shapr> ah, he hasn't released 2.03 yet, must be 2.02
05:33:56 <shapr> the only changes he sent me in email were to the example code
05:33:57 <Marvin--> let me try compiling the damn things instead
05:34:31 <Marvin--> still the same error
05:34:45 <shapr> what's the error again?
05:34:59 <shapr> and, do you get it when compiling, running, or what?
05:35:06 * Marvin-- has a creeping suspicusion
05:35:12 <shapr> ?
05:35:32 <Marvin--> I was afraid he had a locally hacked parsec and I was using the parsec with ghc, but that wasn't it
05:35:42 <Marvin--> error: "list.xml" (line 1, column 6):
05:35:42 <Marvin--> unexpected illegal char: '='
05:35:42 <Marvin--> expecting version info (with quoted version number)
05:35:44 <Marvin--> that's the error
05:36:07 <shapr> are you using Marvin.hs ?
05:36:09 <Marvin--> yes
05:36:17 * shapr is confused
05:36:41 <shapr> hmake -O -fvia-C Marvin -i/home/shae/src/haskell/libraries/hxmltoolbox/hparser -i/home/shae/src/haskell/libraries/hxmltoolbox/hvalidator -i/home/shae/src/haskell/libraries/hxmltoolbox/parsec -i/home/shae/src/haskell/libraries/hxmltoolbox/hdom -i/home/shae/src/haskell/libraries/hxmltoolbox/http -i/home/shae/src/haskell/libraries/hxmltoolbox/hxpath  -package data -package net -fglasgow-exts -package lang -i/home/shae/src/haskell/
05:36:41 <shapr> libraries -package util
05:36:54 <shapr> that's my compile line, you see any hidden secrets there?
05:37:24 <Marvin--> not really
05:37:52 <shapr> you're using the 2.02 from 2003-05-08, right?
05:37:57 <Marvin--> I have   HXML=~/Source/HXmlToolbox-2.02 ghc -i$HXML/hparser:$HXML/hdom:$HXML/hvalidator:$HXML/http -package text -package util -package net --make -o FOO Marvin.hs
05:38:44 <shapr> oh
05:38:56 <Marvin--> not really any differences
05:39:01 <shapr> are you able to make the demo utilities?
05:39:16 <shapr> if so, and they work, then you can figure out the difference from there
05:39:49 <shapr> can you run make in the toplevel dir?
05:40:10 <Marvin--> doing thar right now, seems to work
05:40:18 <Marvin--> lots of asm warnings
05:40:30 <shapr> yah, that's gcc 3.3 (3.2?)
05:40:37 <Marvin--> 3.3
05:40:41 <shapr> if the example binaries work, then the toolkit can work on your box
05:41:52 <Marvin--> nope, ./ParseExample examples/example1.xml gives the same error
05:42:46 <shapr> ok, one more suggestion, rm **/*.hi **/*.o  in the top-level dir and make it again
05:42:57 <Marvin--> **?
05:43:01 <shapr> it sounds like you have .o files from an earlier version around
05:43:06 <shapr> do you use zsh?
05:43:09 <Marvin--> no, bash
05:43:14 <shapr> oh
05:43:18 <Marvin--> I just downloaded it today!
05:43:18 <shapr> I dunno if that works in bash
05:43:25 <shapr> oh
05:43:41 <shapr> that's really strange
05:44:00 <shapr> hmm
05:44:14 <shapr> lemme remake it with gcc3.3 and see if I get that error
05:44:31 <shapr> you're using the standard debian ghc5 packages?
05:44:36 <Marvin--> but the makefile doesn't have -fvia-C...
05:44:51 <Marvin--> yes
05:45:22 <shapr> well, if you're seeing asm errors, then the eval mangler (heh) is seeing something from 3.3, yes?
05:45:31 <Marvin--> I guess
05:45:34 <Marvin--> does ghc respect $CC?
05:45:38 * shapr dunno
05:45:44 <shapr> It works fine for me :-/
05:45:55 <shapr> I cleaned out all my *.hi *.o and my binaries
05:46:13 <shapr> What could be the difference between our systems?
05:46:31 <shapr> ok, one more thing, run "make test"
05:46:39 <shapr> HXmlToolBox comes with a test suite
05:46:51 <shapr> that should turn up the error if nothing else will
05:47:22 <shapr> if you can figure out what the problem is, we can send details to Dr. Uwe Schmidt, and maybe he can fix it.
05:48:02 <shapr> I had no errors with make test
05:48:18 <Marvin--> -pgmc gcc-2.95  might do the trick
05:48:53 <Marvin--> indeed, no asm warnings now
05:49:23 <Marvin--> I recompiled my kernel the other day, and had to hack the makefiles to get it to use gcc-2.95 :-/
05:49:41 <Marvin--> my god I'm getting a lot of warnings on this haskell code
05:51:24 <shapr> from gcc or ghc?
05:52:39 <Marvin--> ghc
05:53:00 <Marvin--> yes indeed, this was the problem... using gcc-2.95 it seems to work
05:53:03 <Marvin--> creepy
05:53:06 <shapr> very weird
05:53:12 <shapr> that signals a serious problem imo
05:53:21 <shapr> no idea what sort of problem though
05:53:26 <shapr> with gcc/ghc/?
05:53:50 <Marvin--> ?
05:53:51 <shapr> does make test and Marvin.hs work now?
05:54:35 <shapr> I don't get any ghc warnings with 5.04.2 and hxtb 2.02
05:55:20 <Marvin--> my own file works too
05:58:50 <Marvin--> that   processBottomUp (none `when` isXCmt +++ isXText)   is pretty scary :)
06:09:31 <Marvin--> now to figure out what it is I want to do
06:12:13 <shapr> I'm still not totally clear on the +++ combinator
06:12:26 <shapr> sometimes it seems to be Y, sometimes it's something else
06:12:38 <Marvin--> I thought it was a simple disjunction?
06:13:03 <shapr> @jargon disjunction
06:13:05 <lambdabot> No match for "disjunction".
06:13:10 <shapr> @web1913 disjunction
06:13:11 <lambdabot> No match for "disjunction".
06:13:16 <Marvin--> shapr: "or"
06:13:42 <Marvin--> shapr: or union if you like
06:13:59 <shapr> in arrows, and I think also in hxtb, it's more like Joy's dup
06:14:02 <Marvin--> processBottomUp (none `when` p1 +++ p2)  will replace nodes matched by p1 and nodes by p2 with none
06:16:05 <shapr> I still don't know if I prefer the htb or HaXml approach
06:16:43 <shapr> HaXml exploded when dealing with the OpenOffice DTD, so I used Hxtb instead.
06:18:35 <shapr> Marvin--: have you used HaXml for anything?
06:18:47 <Marvin--> shapr: nope
06:19:20 <Marvin--> I'm thinking SAX might be more interesting for what I'm doing
06:19:29 <Marvin--> since what I want to do is take an xml file and reduce it based on some rules
06:20:17 <shapr> what sort of rules?
06:20:44 <shapr> I wrote a bunch of transform rules for OpenOffices -> xlml, maybe I can help you out.
06:21:12 <Marvin--> very basic stuff... I'm dealing with discover2's hardware listings, and I want to reduce them for d-i, so for example, the net floppy hardware detection need only know about NICs, everything else can be scrapped
06:22:03 <shapr> do floppies have a separate bus="floppy" type?
06:22:35 <Marvin--> well, with "net floppy" I meant the target
06:22:50 <jlouis> Marvin--: what are you working on?
06:22:51 <shapr> oy
06:23:05 <Marvin--> jlouis: debian-installer
06:23:20 <shapr> so your first filter will be to limit to PCI/USB/EISA/ISA
06:23:23 <jlouis> oh
06:23:29 <shapr> I don't know of any scsi NICs
06:23:31 <jlouis> in haskell?
06:24:02 <shapr> oh, pcmcia also
06:24:29 <Marvin--> shapr: no, I don't want to do that, I want to take each file and strip out all bus classes but 'network', it's much saner to remove empty files afterwards
06:24:41 <Marvin--> jlouis: this is a build-time thing to create hardware lists
06:24:48 <shapr> that's easy enough
06:24:49 <Marvin--> jlouis: the installer itself is written in C and sh
06:24:53 <Marvin--> shapr: exactly
06:26:02 <Marvin--> shapr: so I have *-busclass.xml files that give me identifiers for different bus classes, so I'll traverse, e.g., usb-busclass.xml to find <busclass id="0206" name="network"/> and then traverse usb-device.xml looking for <device busclass="0206"...
06:26:25 <shapr> "bus" `hasValue` (== "network")
06:26:42 <Marvin--> well, I don't want all other nodes to magically go away...
06:28:05 <shapr> I don't understand the relation between usb-busclass and usb-device
06:28:38 <shapr> you want to end up with a single file that holds all this info?
06:28:42 <Marvin--> no no no
06:28:51 <Marvin--> I don't want to change usb-busclass
06:29:05 <Marvin--> I just want to traverse it looking for the busclass node that has name == "network"
06:29:12 <Marvin--> to get the id
06:29:18 <shapr> oh, and then get rid of everything else from usb-device?
06:29:40 <Marvin--> when I traverse usb-device, I want to remove all device trees that don't have that busclass
06:29:52 <shapr> I see
06:32:18 <shapr> hi buggs 
06:32:24 <shapr> what's up?
06:32:38 <Marvin--> if I have a filter that removes a node, and that node happens to have children, will they all be removed too?
06:33:10 <shapr> yes, but I wrote an "unwrap tag" that just removes a tag and leaves its children.
06:33:23 <buggs> hoi
06:33:27 <shapr> it's voodoo code though, I don't really understand what it does.
06:33:52 <Marvin--> shapr: you misunderstand me, I want them removed :)
06:33:56 <shapr> oh
06:34:09 <shapr> that's easier
06:35:01 <Marvin--> hmm, this could take some voodoo... I want to remove all  <data class="name">unknown</data>  trees... Could I simply make a filter that gets rid of 'unknown' XText nodes and a filter that gets rid of nodes that have no children?
06:35:37 <shapr> you could check for all three
06:36:31 <Marvin--> er, how?
06:36:51 <shapr> seqF [isTag "data", "class" `hasValue` "name"] that's the first two
06:37:22 <shapr> I can't remember how to check for XText values off the top of my head
06:37:23 * shapr checks
06:39:02 <Marvin--> is seqF a fold over `o` ?
06:40:05 <shapr> seqF is the same as .> and means "and"
06:40:08 <shapr> rather than "or"
06:40:10 <shapr> conjunction?
06:40:30 <Marvin--> aha
06:40:45 <Marvin--> but what does `o` do then?
06:41:04 <shapr> it applies to the results of the one before
06:41:10 <shapr> maybe they're all the same?
06:41:22 <shapr> I can't swear to that till I write up a unit test to check it
06:41:51 <Marvin--> ah, yes, .> and o are the same
06:41:57 <Marvin--> no wait, in different order
06:42:00 <shapr> ?
06:42:13 <Marvin--> f .> g          = g `o` f
06:42:19 <shapr> oh
06:42:57 <shapr> order hasn't been important in any of my filters so far
06:43:50 <Marvin--> but wouldn't it be something like   seqF [isTag "data", "class" `hasValue` "name", processChildren (isText "unknown")]
06:44:03 <shapr> that looks right to me
06:44:07 * shapr writes a unit test
06:44:50 <Marvin--> er, "class" `hasValue` (=="name")  obviously
06:45:14 <Marvin--> hrrm, when should I use bottom-up processing and when should I use top-down?
06:45:27 <shapr> when it makes sense :-)
06:46:06 <shapr> for the same reasons you sometimes use .> and sometimes `o`
06:47:22 <Marvin--> I so don't get this
06:47:27 <shapr> ?
06:47:43 <Marvin--> so say I have this seqF filter... what do I do with it?
06:47:57 <shapr> look at the unit tests I wrote
06:48:29 <shapr> "wrapnode2" ~: "<top><b><a>foo</a></b><c>baz</c></top>" ~=? showXTs (processBottomUp ((wrapNode "b") `when` (isTag "a")) $$ (xtag "top" [] ((xtag "a" [] (xtext "foo")) ++ (xtag "c" [] (xtext "baz")))))
06:48:48 <shapr> name ~: expected results ~=? testToRun
06:49:20 <Marvin--> wrapNode?
06:49:29 <Marvin--> oh, right
06:49:31 <shapr> that was just the handiest test
06:49:39 <shapr> I should have pasted something shorter ...
06:50:00 <shapr> "istag1" ~: "<a>foo</a>" ~=? (showXmlTrees ((isTag "a") $$ (xtag "a" [] (xtext "foo"))) "")
06:50:13 <shapr> showXmlTrees takes a tree and a string
06:50:27 <shapr> showXTs = flip showXmlTrees ""
06:51:06 <shapr> I mostly use the $$ operator to do the processing
06:51:22 <shapr> iirc, that applies it to each subnode too
06:51:23 <Marvin--> hmm, this doesn't seem to work
06:51:27 <shapr> which you don't always want
06:51:43 <shapr> ?
06:51:53 <Marvin--> I still have  <data class="name">unknown</data>  in the output
06:52:20 <shapr> are you using Marvin.hs eller hur?
06:52:34 <Marvin--> I'm using my own file now...DiscoverReduce.hs
06:52:49 <shapr> what does it look like now?
06:54:00 <shapr> yikes
06:54:04 <shapr> ghc-5.05: panic! (the `impossible' happened, GHC version 5.05):
06:54:06 <shapr> 	coreSyn/CoreUtils.lhs:1164: Non-exhaustive patterns in function isCrossDllArg
06:54:34 <Marvin--> http://193.11.232.159:8080/DiscoverReduce.hs
06:55:38 <Marvin--> oh never mind, fscking typo
06:56:29 <Marvin--> hmm, right, now I want to remove all  elements that only has whitespace children
06:58:07 <Marvin--> hrrm
06:58:22 <Marvin--> this ain't good
06:58:36 <Marvin--> it removed all <data class="name">ignore</data> too
06:59:47 <Marvin--> in fact, it removed all  <data class="name">...</data>
07:05:17 <Marvin--> shapr: so... uh... how do I fix this?
07:05:23 <jlouis> my combinatorparser bugs me too :)
07:06:24 <shapr> sorry, I was distracted for a bit.
07:06:38 * shapr looks
07:07:02 <Marvin--> the thesis doesn't provide much of documentation
07:07:12 <shapr> the haddocks have more recent stuff
07:07:33 <shapr> here's a case where I wish for nounVerb names
07:07:42 <shapr> childrenProcess attributeHas
07:08:06 <shapr> I think there's a children predicate to use rather than processChildren there
07:09:14 <Marvin--> I can only see replaceChildren, processChildren and modifyChildren
07:10:15 <shapr> something like "getChildren this == xtext "unknown"
07:10:41 <Marvin--> ?
07:10:53 <Marvin--> getChildren is just a selector function
07:11:45 <shapr> yes, but you could use it to check the children of the <data/> tag
07:12:07 <Marvin--> eh? how?
07:12:23 <Marvin--> this is point-free, remember, everything has to be done in terms of filters, don't they?
07:12:33 <shapr> no, not completely
07:13:15 <shapr> some of the demo code uses pattern matching with pointy(?) code to give you extra power
07:14:19 <Marvin--> well, I just find it strange that there is no such combinator already
07:14:35 <shapr> to check the children?
07:14:42 <Marvin--> yes
07:14:44 <shapr> there probably is...
07:14:58 <Marvin--> the way I understood seqF is that all filters in the list have to hold
07:15:01 <shapr> yup
07:15:29 <Marvin--> and a filter holding is defined as returning a non-empty list, right?
07:16:05 <shapr> that would make sense
07:16:32 <Marvin--> but looking at the definitions of processChildren and modifyChildren... they will always "hold" as they always return unit lists
07:17:46 <shapr> I don't think so
07:17:57 <shapr> processChildren ft (NTree n cs) = [NTree n (ft $$ cs)]
07:18:12 <shapr> that creates a new tree with the filter ft applied to the children cs
07:18:34 <shapr> err
07:19:03 <shapr> I see what you mean
07:19:39 <shapr> the thing here is that processChildren is for just that
07:20:37 <Marvin--> yes, so I tried to define  allChildren
07:20:44 <Marvin--> allChildren ft (NTree n cs) = case ft $$ cs of
07:20:44 <Marvin-->                                 [] -> []
07:20:44 <Marvin-->                                 xs -> [NTree n xs]
07:20:50 <Marvin--> but that didn't work at all :)
07:21:55 <shapr> maybe we're approaching this from the wrong direction
07:22:09 <Marvin--> maybe
07:22:28 <shapr> can you describe the problem again?
07:22:41 <Marvin--> the problem is "simple"
07:23:03 <Marvin--> I want to remove all ocurrences of  <data class="name">unknown</data>
07:25:25 * shapr writes unit tests to check his logic
07:25:33 <shapr> ok
07:26:33 <shapr> now I can remove the tags
07:26:51 <shapr> but it's also removing <data class="name">ignore</data> right?
07:27:22 <Marvin--> I've only succeeded with either removing all <data class="name">.*</data> or removing none :)
07:27:34 <shapr> yah, I'm having the same results
07:29:33 <shapr> is there some way to turn a boolean into a node filter? if so, --> getChildren this == xtext "unknown"
07:29:36 <shapr> right?
07:29:58 <Marvin--> uh, getChildren this isn't type correct
07:30:47 <shapr> ok, \x -> getChildren x == xtext "unknown"
07:30:48 <shapr> ?
07:30:50 <Marvin--> I think it's very very very very confusing that predicates and tranformations have the same type
07:32:22 <Marvin--> what I want is an all-like function, you know
07:33:47 <shapr> yah, that would be handy
07:34:23 <shapr> there's "satisfies" that turns a predicate into a boolean
07:34:29 <shapr> I wonder if it has an opposite
07:34:49 <Marvin--> isOf
07:34:51 <Marvin--> perhaps
07:35:15 <shapr> oh
07:37:05 <Marvin--> isOf (\x ->  all (satisfies (isText "unknown")) (getChildren x))  perhaps? yeech :P
07:37:16 <shapr> %-P
07:37:22 <shapr> there must be a better
07:37:22 <shapr> way
07:37:31 <shapr> I really wish hxtb came with a cookbook
07:38:02 <shapr> several times I found that I had rewritten simple combinators myself because I didn't know they existed.
07:38:14 <Marvin--> nope, still removes all nodes
07:38:41 <shapr> the simplest unit test here is "can you compare the xtext values of the children"
07:38:47 <shapr> once that works everything else will
07:41:09 <shapr> oh, maybe isTextNode ?
07:42:16 <Marvin--> dammit, this *should* work
07:42:23 <Marvin--> childrenAreUnknown x = isText "unknown" $$ getChildren x
07:42:30 <Marvin--> > childrenAreUnknown (tree "unknown")
07:42:31 <Marvin--> [NTree (XText "unknown") []]
07:42:36 <Marvin--> > childrenAreUnknown (tree "unknowndf")
07:42:36 <Marvin--> []
07:42:55 <shapr> I think isText only checks for a text node
07:42:57 <shapr> ?
07:42:58 <shapr> maybe?
07:43:09 <Marvin--> no, isText checks the string in the text node
07:43:13 <Marvin--> isXText checks for a text node
07:43:14 <shapr> oh
07:43:50 <Marvin--> so, to me it looks like this filter is bloody correct
07:44:28 <mgoetze> so, can someone point me to a simple "hello, what's your name?" "hi $name, nice to meet you" type i/o example?
07:45:43 <Marvin--> shapr: since seqF is a conjunction, I really don't understand why this doesn't work
07:46:41 <shapr> I'm writing bottom-up pieces at the moment... I want to make sure I can filter according to the text node contents
07:46:55 <shapr> mgoetze: have you looked at the YAHT tutorial?
07:47:11 <Marvin--> hdaume says it's good ;)
07:47:29 <shapr> heh
07:47:33 <shapr> I say that too
07:47:45 <mgoetze> nope
07:47:48 <shapr> ok, it looks like I can filter for/against text node contents
07:47:55 * mgoetze searches for it on h.o
07:48:08 <shapr> @fact learning
07:48:10 <lambdabot> http://www.haskell.org/learning.html
07:48:14 <shapr> I know it's linked from there
07:49:01 <mattam> is it possible to write customized show fns for type synonyms ?
07:49:27 <shapr> I think that may have been added recently, but it might be limited to 5.04.3 or so
07:49:54 <shapr> I know it's not possible around 5.04.1 or earlier
07:49:59 <mattam> shapr: you talking to me ?
07:50:05 <shapr> mattam: yes
07:50:11 <mattam> ok
07:50:28 <Marvin--> shapr: I really don't understand it... none `when` childrenAreUnknown $$ [tree "unknown"] returns [], and none `when` childrenAreUnknown $$ [tree "ignores"] returns [tree "ignores"] just as I want. but... why doesn't it work when I put it in the seqF? :(
07:50:52 <shapr> I don't know, try using .> instead
07:50:54 <shapr> or `o`
07:51:01 <shapr> see if that changes it
07:51:43 <Marvin--> no
07:51:50 <mgoetze> shapr: hm. the pdf looks kinda like a scanned in printout of a word document, but i'll take your word for it if you vouch for the contents :)
07:52:05 <shapr> mgoetze: I wrote some of the contents
07:52:09 <Marvin--> mgoetze: the .ps is good as far as I know
07:52:33 <mgoetze> .ps? but then i'd have to start an x server...
07:53:15 <shapr> Marvin--: what if you put only two of the conditions into the seqF? what happens then?
07:53:48 <shapr> er
07:53:51 <shapr> Marvin--: hey, it works
07:54:13 <Marvin--> shapr: what does?
07:54:15 <shapr> your code
07:54:32 <Marvin--> which one?
07:54:39 <shapr> childrenAreUnknown
07:55:03 <shapr> http://kungens.kemi.fi/~shae/src/haskell/Demo_Hxml.hs
07:55:10 <Marvin--> childrenAreUnknown works,  childrenAreUnknown `o` isTag "data"  doesn't work
07:57:03 * shapr is confused
07:57:38 <Marvin--> yes, it leaves 'ignore' nodes alone, but it also leaves 'unknown' nodes alone :)
07:58:50 <shapr> :-/
07:59:51 <mgoetze> argh, the quality of this .pdf is downright painful
08:01:02 <Marvin--> shapr: actually...   childrenAreUnknown .> isTag "data"  seems to work, but not when I add  "class" `hasValue` (=="name")  !
08:01:21 <shapr> I wonder if that's a bug
08:01:37 <mgoetze> shapr: at the time of writing, several options were available: emacs or xemacs. harharhar.
08:01:41 * mgoetze demands equal time
08:01:47 <shapr> :-P
08:02:11 <shapr> I think there's a section reservered for vim users, but iirc, none of the authors used vim
08:05:13 <Marvin--> holy...
08:05:22 <Marvin--> shapr: it seems to be sensitive to which order I do childrenAreUnknown and istag in
08:05:34 <mgoetze> ...hand grenade of antioch!
08:09:56 <Marvin--> shapr: ahh, wait a sec, of course it does
08:10:03 <shapr> ?
08:10:08 <Marvin--> shapr: hasValue is destructive
08:10:35 <Marvin--> shapr: it won't return the tag, it'll return the attribute
08:10:41 <Marvin--> the attribute value even
08:11:46 <Marvin--> hmm, wonder how to fix this
08:14:05 <Marvin--> aha!
08:14:12 <Marvin--> it kinda sucks having to create a myHasValue
08:14:14 <Marvin--> but it works
08:17:17 <Marvin--> hohum, I haven't eaten lunch yet
08:20:16 * andersca boings
08:21:27 * shapr splashes
08:21:51 <Marvin--> now to remove the nodes with whitespace-only-children
08:23:29 <Marvin--> shapr: so anyway, now I have this allChildren combinator that does what I want
08:23:36 <Marvin--> allChildren f x = f $$ getChildren x
08:26:37 <shapr> yay
08:26:44 * shapr gives in to the siren song of the unicycle
08:29:43 <Lilith> unicycle?
08:45:48 <o3> 3000 words, only about another 12000 to go
08:51:39 <mattam> @type assoc
08:52:05 <mattam> hmmm, what are the associative lists functions ?
08:53:20 <shapr> huh?
08:53:40 * shapr returns, much exercise obtained
08:54:22 <mattam> ?
08:54:41 <shapr> it's amazing how much heat you can build up by trying to keep 100 kilos exactly on top of pole that has a single wheel on the other end
08:54:50 <shapr> what sort of associative lists functions?
08:55:01 <shapr> you mean associating one thing with another? like Data.FiniteMap ?
08:55:02 <mattam> like mem(ber) or find 
08:55:08 <shapr> oh, elem ?
08:55:12 <shapr> @prelude elem
08:55:12 <mattam> [(a,b)]
08:55:16 <lambdabot> *** "elem" prelude "Haskell Standard Prelude Dictionary": text follows
08:55:16 <lambdabot> elem
08:55:16 <lambdabot>   infix  4 `elem`
08:55:16 <lambdabot>   elem ::  Eq a => a -> [a] -> Bool
08:55:17 <lambdabot>   elem              = any . (==)
08:55:41 <shapr> sorry, @type isn't working at the moment, I'll see if I can find the problem when I get to it.
08:56:00 <o3> shapr: what's the difference between a finitemap and a hash?
08:56:16 <shapr> I dunno
08:56:33 <mattam> so there aren't functions defined for [(a,b)] lists like mem :: [(a,b)] -> a -> Maybe b
08:57:01 <o3> shapr: ok, thanks anyway
08:57:17 <shapr> http://www.haskell.org/ghc/docs/6.0/html/base/Data.FiniteMap.html#lookupFM
08:57:35 <mattam> argh, yet another 6.0 feature i guess :)
08:57:47 <Marvin--> o3: finitemap is a tree, hashtables are usually...tables
08:57:51 <shapr> nah, FiniteMaps have been around forever
08:58:30 <o3> Marvin--: ah.  so it's just an internal data structure difference
08:58:37 <o3> was pondering since they both seem to do the same thing
08:58:39 <mattam> well, i don't need an ordered type
08:58:45 * shapr tries to figure out why xemacs is using 300mb of ram
08:59:11 * o3 resists making a comment about "it's emacs, what do you expect?"
08:59:18 <shapr> :-P
08:59:48 <mattam> o3: didn't resist enough, it's a characteristic of anti-emacs users, they lack patience
09:00:08 <o3> Marvin--: do you know what kind of tree implementation is in GHC's finitemap?
09:00:26 <o3> mattam: that's because we're used to things actually running quickly
09:00:27 <Marvin--> o3: no.. red-black perhaps
09:00:31 <shapr> oh my #haskell buffer is nearly 100k lines
09:00:33 <o3> (i'm an emacs user, btw) :)
09:00:33 <mattam> balanced trees it seems
09:01:57 <shapr> hm
09:02:12 <steveh> shapr do you use erc or zenirc?
09:02:19 <Marvin--> mattam: red-black trees are self-balancing, so are AVL trees, and 2-4 trees et.c.
09:03:30 <mattam> yes
09:04:14 <steveh> what's a good definition for a "purely functional data structure?"
09:04:31 <mattam> i said that because it is written at the beginning of the page :)
09:05:23 <kloo> aren't the operations functional, rather than the data structure?
09:05:30 <Marvin--> mattam: yes, well, non-self-balancing trees would be kinda worthless
09:06:01 <mattam> right
09:06:10 <steveh> Marvin--: unless you were sure the data would be acquired in random order.
09:06:35 <o3> Marvin--: nonsense, i'm sure they've kept many a crap programmer in employment by declaring they have a balancing tree -- they just don't mention that you have to rebalance it manually
09:06:57 <o3> -> profit!
09:07:09 <steveh> kloo
09:07:19 <mattam> so no standard [(a,b)] functions ? 
09:07:32 <steveh> kloo: well I am thinking of the book "Purely Functional Data Structures" which I have on order...
09:07:52 <o3> mattam: i don't think so
09:08:02 <o3> then again, i didn't know "intersperse" existed until a few days ago
09:08:02 <kloo> yes, i've wondered at that title. :)
09:08:15 <steveh> mattam: if you actually want a list implementation of that, it's trivial to write
09:09:38 <mattam> yes, so i write it now
09:10:03 <steveh> it works OK on relatively small data
09:10:33 <steveh> I wrote an (unbalanced!) tree-based dictionary to help me learn haskell
09:10:57 <steveh> after writing something with the same interface based on lists that puked when I fed it larger input 
09:11:46 <mattam> i'll have 1 to 10 elements in it
09:12:19 <steveh> hehe, then no reason to do anything fancy :)
09:12:25 <steveh> what are you writing
09:12:25 <steveh> ?
09:16:15 <mattam> it's a little grammar representation grammar is [(NonTerminal, rules)]
09:16:27 <mattam> s/rules/productions/
09:17:08 <steveh> ah...
09:17:23 * steveh remembers doing that in Perl for a class...
09:17:28 <steveh> Haskell would have been much nicer :)
09:18:09 <mattam> i'm concentrating on the grammar algorithms, so learning another data structure for my second Haskell prog doesn't please me too much :)
09:18:34 <mattam> i have an exam tomorrow, btw
09:18:58 <steveh> CKY algorithm?
09:19:49 <Smerdyakov> C is for composite. K is for kernel. Y is for yachting.
09:19:56 <mattam> CKY ?
09:19:56 <steveh> lol
09:20:05 <steveh> i like that one much better :)
09:21:05 <steveh> CKY is the algorithm I remember fighting with in class
09:21:38 <steveh> but since you don't recognize it, that's probably not the one you're doing :)
09:21:55 <steveh> it'd be hard to do in haskell anyway I think
09:22:08 <steveh> since I very distinctly recall a mutable table structure being key
09:23:43 <mattam> heh, i have a pseudo pascal example in my course but I hope i'll be clever enough to transpose it to functionnal code (I have no choice anyway :p)
09:24:01 <steveh> what does the exam cover?
09:26:31 <mattam> stack automata && a little parsing (only descent parsers i think)
09:26:55 <mattam> descendant may be a better word
09:29:32 <steveh> i've always heard it "recursive-descent" parsing
09:54:23 * Marvin-- grumbles
09:58:07 <Marvin--> shapr: I'm giving up for now
09:58:28 <Marvin--> shapr: I don't understand how to get it to remove onlly nodes without children (or rather, nodes with only whitespace children)
09:58:35 <shapr> I'd suggest you send questions/comments to Uwe Schmidt
09:59:05 <shapr> as for that, I think you should do it all at the same time
09:59:09 <Marvin--> the fact that predicates-are-filters makes it a pain in the *** to use them, since they have to return the right damn things for the pipes to work
10:00:28 <shapr> it was really useful in the code I was writing
10:00:34 <shapr> so it has some redeeming qualities
10:02:25 <Marvin--> well, I mean... you have to be really really really careful in which order you apply the "predicates"
10:02:31 <shapr> yah, that's true
10:02:34 <Marvin--> you can't write  destructivepredicate .> isXTag
10:02:47 <Marvin--> because that's wildly different from isXTag .> destructivepredicate
10:02:57 <shapr> yes, I agree
10:03:11 <Marvin--> and in the end, it feels like I'm ending up with a gazillion uses of isOf
10:03:31 <Marvin--> which makes me doubt the advantages of predicates-are-filters
10:04:33 <shapr> I only worked with hxtb for a few days, but I did notice that as I learned more combinators, it became more useful to me
10:04:43 <shapr> maybe if we knew all the combinators, it would be easy to use.
10:05:02 <shapr> otoh, a task-oriented cookbook would be *really* nice.
10:15:27 <Marvin--> shapr: should I CC you?
10:16:39 <Marvin--> shapr: (and if so, what address?)
10:27:52 <zipWith> How do you separate interfaces and implementations in Haskell? Are there *mli - like files in Haskell?
10:28:02 <Riastradh> I don't believe so.
10:31:16 <zipWith> Riastradh : if I put type declarations in one file (zipWith :: (a -> b -> c) -> [a] -> [b] -> [c] ) and implementations in another, can't I include the former from the latter? Or do modules get in the way?
10:33:50 <Marvin--> zipWith: interface == type class, implementation == data type + type class instantiation
10:36:16 <zipWith> Marvin-- : I don't see it this way. What type class does zipWith belong to? It still has an implementation. (We were talking about putting interfaces in a different file)
10:36:37 <zipWith> Marvin-- : s/implementation/interface
10:36:43 <Marvin--> zipWith: zipWith doesn't belong to a type class, it's not overloaded
10:37:30 <zipWith> Marvin-- : that's what I mean. It does not belong to a type class, but it has an interface (zipWith :: (a -> b -> c) -> [a] -> [b] -> [c])
10:37:43 <Marvin--> zipWith: no, that's a type
10:38:33 <Riastradh> What Marvin is talking about is something like:
10:38:40 <Riastradh> class Sequence s where
10:38:52 <Riastradh>     zipWith :: (a -> b -> c) -> s a -> s b -> s c
10:38:54 <Riastradh>     ...
10:38:56 <zipWith> Riastradh : I know what type classes are
10:39:11 <Riastradh> That's like an equivalent SML:
10:39:15 <Riastradh> signature Sequence =
10:39:15 <Riastradh> sig
10:39:32 <Riastradh>     type T
10:39:53 <zipWith> Riastradh : I was talking about putting interfaces and implementations in different files
10:39:54 <Riastradh>     val zipWith : ('a -> 'b -> 'c) -> 'a T -> 'b T -> 'c T
10:39:59 <Riastradh> end
10:40:25 <Riastradh> Yes -- put the Sequence class in the Sequence module, and then define an instance of Sequence on [] in a List module, in separate files.
10:40:25 <Marvin--> zipWith: it depends on what you mean with interfaces and implementations
10:41:28 <zipWith> Riastradh : I see
10:41:52 <Riastradh> module Sequence where
10:41:55 <Riastradh> class Sequence s where
10:41:57 <Riastradh>     ...
10:42:01 <Riastradh> module List where
10:42:05 <Riastradh> instance Sequence [] where
10:42:27 <Riastradh>     zipWith f (x : xs) (y : ys) = f x y : zipWith f xs ys
10:42:31 <Riastradh>     zipWith f _ _ = []
10:42:33 <Riastradh>     ...
10:43:47 <Riastradh> The 'module List where' bit is like this SML:
10:43:59 <Riastradh> structure List :> Sequence =
10:44:00 <Riastradh> struct
10:44:04 <Riastradh>     type 'a T = 'a list
10:44:09 <Riastradh>     fun zipWith ...etc...
10:44:11 <Riastradh> end
10:44:23 <Marvin--> Riastradh: stop defiling the channel :P
10:44:45 <Riastradh> What, would you rather I pasted all Haskell code in here and all SML code in #sml, defiling the conversation?
10:46:16 <Marvin--> I'm just kidding :)
10:46:30 * Riastradh , er, already knew that.
10:46:54 <zipWith> Riastradh : ... but List type has some properties not necessarily required in Sequence, right? 
10:47:06 <Riastradh> ?
10:48:04 <zipWith> For example, "take" works on Lists only
10:49:43 <Riastradh> This List module of which I spoke was merely an example of using type classes -- I wasn't referring to the standard List module.
10:50:14 <zipWith> I'm not sure if Sequence is part of Haskell, or something you thought of as an example, but if "Sequence" is a COMPLETE interface of List, then having to use a different name is a little odd. 
10:50:41 <zipWith> s/odd/tedious
10:51:32 <zipWith> ... that is one now has to think of two names for every module that would have only one name in SML
10:51:50 <Riastradh> ?
10:53:03 <zipWith> In Haskell it would be : List - implementation, Sequence - interface (list.hs & sequence.hs); In SML List - both implementation and interface (list.ml & list.mli)
10:54:00 <zipWith> Riastradh : ... so, interface and implementation need to have different names
10:54:44 <Riastradh> No, it's slightly different.
10:55:42 <Riastradh> As I said earlier, I don't think there's really anything in Haskell to do exactly what you asked about -- I was just elaborating on what Marvin had mentioned, actually.
10:55:59 <zipWith> Riastradh : OK
12:27:42 * shapr boings
12:28:00 * shapr zooms around the room
12:28:14 * andersca beams a smile at shapr
12:28:27 * shapr dodges the beam, surviving yet again!
12:28:29 <shapr> oh wait
12:28:33 <shapr> that wasn't a laser beam
12:29:16 <shapr> hi andersca! How's the code treating you?
12:29:30 <andersca> ok
12:29:37 <andersca> just found a small bug in nautilus that I'm pondering fixing
12:30:01 <shapr> till riklig == enough ?
12:30:14 * shapr fixes bugs in his Swedish module
12:34:18 <Marvin--> shapr: tillräcklig(t)
12:34:24 <esap> "swedish module"? is that some piece of Swedish with well-defined interfaces? :-)
14:40:09 <cale> Riastradh: you there?
15:16:11 <Riastradh> cale - I am now.
16:08:31 <cale> oh, yeah - I'm still having trouble with getting everything that should be equal down to some standard form. It seems that the rules only take B 2 3 to ((S(K 2)) 3) and not to 6 as expected.
16:10:47 <cale> where B is as usual, and 2 is ( (S((S(KS))K)) ((S((S(KS))K)) (K((SK)K)))) (succ (succ (K I)))
16:11:03 <cale> (that last paren was for reference)
16:15:59 <cale> the rules that I currently apply are:
16:17:24 <cale> ((K x) y) -> x,  (((S x) y) z) -> ((x z) (y z)), ((S (K x)) ((S K) K)) -> x, ((S (K x)) (K y)) -> (K (x y))
16:18:06 <cale> and when no rules match a paren, then I recurse on the left and right.
16:18:18 <cale> are there any that I'm missing?
16:20:44 <cale> It seems like (S(K ((SK)K) )) -> ((S K) K), to help B I -> I helps a little, but not entirely.
16:29:59 <Darius> S K _ x == K x (_ x) == x, therefore forall x.S K x == I
16:31:02 <Darius> (assuming non-strict reduction)
16:33:06 <cale> hmm... that does help some cases as well, but B 2 3 still isn't reducing identically to 6.
16:35:03 <cale> at present, with both that rule and (BI) -> I, (B 2 3) reduces to ((S(K((S((S(KS))K))((S((S(KS))K))(K((SK)K))))))((S((S(KS))K))((S((S(KS))K))((S((S(KS))K))(K((SK)K)))))), which is ((S(K 2)) 3)
16:35:23 <cale> whereas 6 reduces to ((S((S(KS))K))((S((S(KS))K))((S((S(KS))K))((S((S(KS))K))((S((S(KS))K))((S((S(KS))K))(K((SK)K))))))))
16:36:52 <cale> which is (SB (SB (SB (SB (SB (SB (KI)))))))
16:39:28 <cale> I'd just add delta reduction and do away with it (I probably will at some point anyway), but I'd really like extensionally equivalent things to reduce to equal things.
16:40:00 <Riastradh> Delta-reduction?
16:40:33 <cale> that is, add an integer type and appropriate definitions for + * as primitives.
16:41:30 <cale> delta-reduction is application of "real" mathematical functions from outside the SK calculus.
16:41:58 <Riastradh> Bah!  PURE SK-Calculus is for -REAL- men.  Mathematics is for wimps!
16:42:06 <cale> heh
16:42:32 <Riastradh> Nah, SK-Calculus isn't even for real men -- the X-Calculus is!
16:42:45 <Riastradh> @get-definition X
16:42:46 <lambdabot> X = \x.x K S K
16:42:50 <Riastradh> @eval X X X 5
16:42:51 <lambdabot> <<EM Dynamic -> EM Dynamic>>
16:42:56 <Riastradh> @eval X X X 5 5
16:42:56 <lambdabot> 5
16:43:01 <Riastradh> @eval X X X 5 6
16:43:01 <lambdabot> 5
16:43:13 <Riastradh> @eval X (X X) (X X X) (X X X) 5
16:43:13 <lambdabot> 5
16:43:41 <Riastradh> X (X X) = S
16:43:45 <Riastradh> X X X   = K
16:43:55 <Riastradh> X (X X) (X X X) (X X X) = I
16:44:05 <cale> nice :)
16:44:08 <Riastradh> (X (X X) (X X X) (X X X) is just S K K)
16:45:33 <Riastradh> Does anyone here know where one can acquire an image (suitable for printing) of the Hindley-Milner principle-type algorithm?
16:45:43 * Riastradh duct tapes Smerdyakov's mouth shut first, though.
16:45:50 <cale> heh
16:50:10 <cale> I seem to remember someone recommending it be put on a shirt between the words "What part of..." and "... don't you understand?"
16:50:22 <Riastradh> Yes, that's what I was going to do with it.
16:52:25 <cale> What would such an image consist of? I can find instances of the algorithm online in postscript form - I could easily make a large png from any one of them.
16:53:00 <Riastradh> That would be helpful.
16:56:46 <cale> hmm... archive.cs.uu.nl/pub/RUU/CS/techreps/ CS-2002/2002-031.pdf ?
16:57:12 * Riastradh is looking at that, but is unsure exactly what in it is the algorithm.
16:57:30 <Riastradh> Figure 1, just above section 3?
16:57:40 <cale> yeah - the four inference rules seem likely.
17:04:23 <cale> It's tricky to find a nice clean copy of it though.
17:10:55 <cale> It's so hard to get good information on things while away from university, and so hard to find time to read that information while at university.
17:25:02 <cale> It seems that HM is just recursive application of those rules.
17:26:05 <Smerdyakov> It's DEAD SIMPLE.
18:25:25 <stepcut> too bad you can't buy a nice hand-held lambda calculator
18:27:41 <steveh> yeah
18:27:49 <steveh> the possibilities of that are limitless :-P
18:27:55 <Riastradh> Literally!
18:28:12 <steveh> can't buy a handheld infinite-tape turing machine either
18:28:14 <Riastradh> ...because the Lambda-Calculus is Turing-complete!
18:28:15 <stepcut> I almost made one when I worked at a company that made a low-power stack-based microprocessor, but then I changed jobs
18:28:43 <Riastradh> I'm sure you could easily hack up a Palm or something to make it be a Lambda-Calculator.
18:28:50 <steveh> hehe
18:28:59 <lament> considering that there's scheme for palm
18:29:11 <Igloo> opencores+LCD display!
18:29:31 <stepcut> yeah, but what makes handheld calculators useful is all the buttons. pen based input is too slow
18:29:55 <Riastradh> I suppose so.
18:30:02 <steveh> just get an RPN calculator and be glad :)
18:30:11 <stepcut> steveh: who makes them still?
18:30:13 * Riastradh hmms...
18:30:26 * Riastradh laments the fact that HP shut down their calculator division.
18:30:53 <Arnia> Hugs for the psion :)
18:31:06 <stepcut> that was my plan... to build a nice lambda hand-held calculator to replace the hp-48 series
18:31:14 <steveh> well
18:31:19 <Riastradh> I had an HP 48G.
18:31:24 * Riastradh can't find it, though.
18:31:32 <steveh> you can probably get HP 48G...
18:31:34 <steveh> yes
18:31:34 <lament> stepcut: er.
18:31:34 <Riastradh> Of course, I haven't looked very hard.
18:31:36 <steveh> that one
18:31:37 <steveh> :)
18:31:38 <stepcut> the 48G is painfully slow (i have one)
18:31:41 <lament> stepcut: Palm has 6 buttons.
18:31:54 <lament> stepcut: which is more than enough for a lambda calculator :)
18:32:00 <stepcut> lament: :p
18:32:11 <Riastradh> You'd need...(, ), lambda, ., space, and then symbols with the pen.
18:32:12 <steveh> is the HP48 a z80?
18:32:18 <stepcut> steveh: i think so
18:32:36 <steveh> TIs were also
18:32:43 <steveh> though some have 68k now I think
18:32:58 <stepcut> i think the ti-91 was the first to have the 68k
18:33:01 <lament> Riastradh: bah
18:33:13 <Riastradh> lament - ?
18:33:23 <stepcut> 6 buttons ain't enough for a practical handheld calculator
18:33:30 <Riastradh> stepcut, why not?
18:33:38 <steveh> neither is lambda calculus!
18:33:40 <steveh> [duck]
18:33:41 <steveh> :)
18:33:42 <stepcut> you can't even enter all the numbers
18:33:49 <Riastradh> (, ), lambda, ., and space make 5.  You'd have one extra button.
18:33:52 <Riastradh> All the 'numbers?'
18:33:55 <Riastradh> What's a 'number?'
18:34:03 <stepcut> :p
18:34:06 <steveh> church numerals?
18:34:06 <lament> Riastradh: why do you need "," and space?
18:34:11 * steveh just learned about those...
18:34:12 <steveh> :)
18:34:17 <lament> Riastradh: the extra button will switch model
18:34:18 <lament> er
18:34:20 <lament> modes
18:34:30 <Riastradh> lament, not ','; space for making formatting nicer.
18:34:38 <Riastradh> Maybe the sixth button could be newline.
18:34:44 <lament> in the second mode, the other five buttons work as XYZAB
18:34:46 <lament> bah
18:34:48 <lament> formatting
18:34:50 <stepcut> numbers are what you need for a 'practical' calculator instead of a theoretical one
18:34:51 <lament> this is a _calculator_
18:35:03 <Riastradh> OK, fine, so you'd have two extra buttons.
18:35:06 <lament> you don't really need anything other than ( and )
18:35:21 <Riastradh> stepcut, but you only asked for a Lambda-Calculator.
18:35:29 <lament> er, and something else to delimit the arguments
18:35:34 <lament> a :
18:35:46 <Riastradh> Delimit the arguments...?
18:35:55 <lament> so that K is   (X Y : X)
18:35:58 <lament> :)
18:36:10 <Riastradh> That's what, er, . is for.
18:36:17 <Riastradh> \x.\y.x
18:36:18 <lament> oh, fine.
18:36:27 <lament> my point is that you don't really need the lambda
18:36:40 <Riastradh> But, uh, it's a Lambda-Calculator.
18:36:43 <Riastradh> Note the 'lambda' bit there.
18:36:48 <lament> you don't need the actual symbol
18:36:52 <stepcut> Riastradh: yeah, but I didn't say a PURE lambda calculator
18:36:53 <Riastradh> It'd be nice.
18:36:54 <lament> it's redundant
18:37:04 <Riastradh> stepcut, bah!
18:37:05 <lament> redundance is not nice in a 6-button calculator :)
18:37:09 <Riastradh> You implied it.
18:37:23 <lament> stepcut: what's the point of an impure lambda calculator?
18:37:26 <stepcut> Riastradh: i guess I implied church nurmerals too?
18:37:33 <lament> You didn't imply church numerals
18:38:01 <Riastradh> You didn't.
18:38:19 <Riastradh> You implied a pure Lambda-Calculator.
18:38:35 <stepcut> well i take it all back. What I real want is a handheld calculator that runs scheme 
18:38:49 <lament> that is something completely different :)
18:38:49 <Riastradh> OK, get a Palm and install LispMe on it.
18:38:55 <Riastradh> Or TinyScheme.
18:39:00 <lament> And get a keyboard for the palm.
18:39:07 <Riastradh> And be thou not in #haskell but in #scheme!
18:39:19 <stepcut> Riastradh: I have a Palm with LispMe, but its not the same
18:39:33 <lament> why not?
18:40:23 <stepcut> lament: The physical interface is lacking
18:41:51 <lament> Get a keyboard.
18:42:03 <stepcut> lament: better, but still not the same
18:42:05 <Riastradh> Use a laptop!
18:42:34 <stepcut> a laptop!!! that is insane!
18:42:55 * Riastradh uses laptops.
18:42:57 <Riastradh> They're great.
18:43:23 <stepcut> I use one too, but is not a good replacement for a top-notch calculator
18:44:03 <Riastradh> Get your hands on a copy of that Scheme chip from back in the '80s, then, and make a handheld out of it.
18:44:28 <stepcut> Riastradh: that was the plan
18:44:39 <Riastradh> Well, then?
18:45:03 <stepcut> Riastradh: no time :)
18:45:24 <lament> i don't understand this calculator fetish
18:45:29 <lament> calculators are big and cumbersome
18:45:55 <stepcut> I know the secret to marketing a graphing calculator... you must have a good game developers kit
18:46:30 <stepcut> lament: compared to what?
18:46:51 * Arnia has a TI-92
18:46:59 <lament> to a palm, for example.
18:47:04 <lament> I have a TI-86
18:47:06 <Arnia> Any calculator with a keyboard and a key for infinity has to be over the top
18:47:31 <lament> I bought it for school because I had to, and i'm not going to use it ever again
18:47:34 <stepcut> lament: entering calculations a the palm is slow, painful, and error prone
18:47:50 <Arnia> It can do symbolic integration and understands that e^(pi i) = -1
18:48:25 <stepcut> Arnia: can it do rpn?
18:48:34 <lament> stepcut: what do you mean by "calculations"?
18:49:08 <stepcut> lament: like adding a list of ten numbers together
18:49:45 <lament> that's simple enough that you may use the calculator program
18:49:57 <stepcut> lament: yeah, but it will take you 5 times as long
18:50:12 <lament> no, it won't
18:50:25 <stepcut> oh?
18:50:43 <lament> the palm calculator draws buttons on the screen, and you can just press them
18:51:12 <stepcut> lament: yeah, its not as fast
18:51:26 <lament> it's not?
18:51:29 <lament> what are you talking about?
18:51:29 <stepcut> no
18:51:54 <stepcut> it takes longer to press the little buttons on the screen than it does to hit them on a keypad
18:52:04 <stepcut> and you are more likely to make a mistake
18:52:10 <lament> i think you're mad
18:53:20 <stepcut> bad
18:53:24 <stepcut> bah even
18:55:57 <Arnia> We're all mad in this circle of candlelight we call reality...
18:56:11 * Arnia finds zen in exhaustion
