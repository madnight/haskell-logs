00:02:34 <andersca> boom
00:09:59 <Pseudonym> Bye all.
02:03:30 <h> hello
02:50:09 <tez> Hi
04:09:20 <Arnia> Yay! GHC CVS now has arrows sugar support :)
04:32:54 <h> re
04:37:41 <h> ok
04:37:47 <h> this run well
04:37:57 <h> we need to shape heuristic a bit
04:38:01 <h> to search faster
04:40:46 <Heffalump> did you mean to say that here? :-)
04:41:55 <h> yup
04:42:00 <h> im talking about icfp
04:43:22 <h> i know somes are doing icfp PC here
04:44:07 <Heffalump> ah, ok, thought you were talking to the rest of your team or something :-)
04:45:38 <h> nop
04:46:07 <h> we are on #icfp on irc.u-psud.fr
04:48:02 <Heffalump> well, I imagine your car is running a bit faster than ours :-)
04:48:15 <h> why ?
04:48:27 <Heffalump> because ours sucks :-)
04:48:39 <h> she likes the grass ?
04:49:02 <Heffalump> we've so far just about managed to get it round track 1.
04:49:49 <h> nice goal
04:49:58 <Heffalump> rather slowly.
04:50:09 <h> how long track ?
04:50:23 <Heffalump> ~30K
04:50:45 <h> in number of line ?
04:50:57 <Heffalump> number of timesteps
04:51:01 <h> ok
04:51:27 <h> thats rather long yes
04:51:57 <Heffalump> how about you?
04:52:02 <h> let me dig 
04:53:01 <h> 10567
04:53:14 <h> the shorter we hear about is around 9500
04:53:41 <Marvin--> it's going to be very interesting to hear about all the different approaches when this is over
04:53:46 <h> sure
04:54:00 <h> but our heuristic is very simplist
04:54:05 <h> so we need to shape it 
04:54:12 <h> to beat the 9500 limit
04:54:21 <h> so that we beat our teacher 
04:54:43 <h> which is our main goal
04:55:25 <Marvin--> heh
04:56:16 <tobgle> hi cale
05:00:18 <h> ttyl
05:13:28 <tobgle> hi
05:13:31 <tobgle> hi cale
06:41:12 <thornber> is there a more interactive/relaxed haskell interpreter that lets you do things like define functions interactively ?
06:41:35 <jlouis> hugs?
06:42:26 <jlouis> thornber: check out :edit
06:43:19 <thornber> hmm
06:46:28 <Heffalump> ghci
06:46:34 <Heffalump> let f x = x+x
06:47:09 <thornber> Heffalump: thx, much better
07:06:20 <jlouis> What is a good source on monad introduction?
07:31:09 <SyntaxPolice> how's the contest going?
07:32:09 <SyntaxPolice> jlouis: I liked the treatment in "THe Craft of Functional Programming".
07:34:25 <SyntaxPolice> jlouis: this is pretty good too: http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm
07:34:42 * Marvin-- mutters about the contest
07:35:30 * Heffalump too.
07:50:02 <earthy> isn't it almost over?
07:50:56 <Marvin--> nine hours or so left
07:51:14 <earthy> ah
08:01:47 <Igloo> Which team are you in, Marvin?
08:09:09 <SyntaxPolice> Marvin--: I sent in tasks & skills :)
08:09:26 <Marvin--> SyntaxPolice: great! :)
08:09:34 <Marvin--> Igloo: Team #haskell
08:10:52 * SyntaxPolice dances around in the hopes of becomming a Real Debian Boy soon
08:20:07 <SyntaxPolice> IConferenceFP registration is open
08:29:57 <bohdan> hello
08:30:59 <SyntaxPolice> hi bohdan
08:31:35 <bohdan> i has problems converting haskell-tutorial.tar.bz2 into .ps suitable for booklet printing on A4. actually the problem is margins which are not printed correctly on my CUPS driver.
08:31:38 <bohdan> could anyone help?
08:32:13 <SyntaxPolice> hm. don't know too much about CUPS except very basic stuff
08:35:22 <SyntaxPolice> what format do you get the tutorial in?  postscript?
08:44:08 <bohdan> i've got source
08:47:02 <Igloo> Cool
08:47:40 <bohdan> actually i could print a .pdf from windows, but i cannot create acroread-readable pdf :((
08:48:00 <bohdan> i use debian-3.0 
08:48:34 <bohdan> maybe it's #latex question? could you suggest other channel?
08:49:53 <SyntaxPolice> bohdan: i'm afraid I just don't know much about fiddling w/ margins either in CUPS or in Latex. There does seem to be a #latex channel.
08:50:16 <SyntaxPolice> but feel free to ask any Haskell questions! Lots of us use Debian too, btws.
08:50:45 <bohdan> SyntaxPolice: i cannot ask haskell question because i
08:50:53 <bohdan> didn't read haskell docs yet :)
08:51:53 <jlouis> Damn, monads are fun
08:51:57 <SyntaxPolice> jlouis: woohoo!
08:52:03 <jlouis> what about arrows then?
08:52:06 <SyntaxPolice> bohdan: which tutorial are you working with, btw?
08:52:07 <jlouis> ;P
08:52:47 <SyntaxPolice> jlouis: still working on understanding Functional Reactive Programming :)
08:53:27 <bohdan> SyntaxPolice: "A gentle ..."
09:32:01 <Shamino> hail to the king
09:36:08 <SyntaxPolice> hi Shamino
09:47:57 <Shamino> i need some help i want to add two predefined data types
09:48:04 <Shamino> data Sequ = End | A Sequ | B Sequ 
09:48:04 <Shamino>             deriving (Show, Eq )
09:48:11 <Shamino> append :: Sequ -> Sequ -> Sequ
09:48:17 <Shamino> append End End    = End
09:48:17 <Shamino> append (A s) End  = (A s) 
09:48:17 <Shamino> append (B s) End  = (B s)
09:48:17 <Shamino> append End (A s)  = (A s)
09:48:17 <Shamino> append End (B s)  = (B s)
09:48:24 <Shamino> append (A s1)(A s2) =
09:48:31 <Shamino> append (B s1)(B s2) =
09:48:37 <Shamino> append (A s1)(B s2) =
09:48:42 <Shamino> append (B s1)(A s2) =
09:48:54 <Shamino> so now i got no idea how to add two Sequ together
09:49:05 <Shamino> ++ is not working because they are no list
09:49:12 <Marvin--> Shamino: isn't it enough to pattern match on the first argument? Like ++ does
09:49:20 <Marvin--> @prelude (++)
09:49:22 <lambdabot> *** "(++)" prelude "Haskell Standard Prelude Dictionary": text follows
09:49:22 <lambdabot> (++)
09:49:22 <lambdabot>   infixr 5 ++
09:49:22 <lambdabot>   (++) ::  [a] -> [a] -> [a]
09:49:23 <lambdabot>   []     ++ ys      = ys
09:49:25 <lambdabot>   (x:xs) ++ ys      = x : (xs ++ ys)
09:50:06 <Shamino> so (++) ??
09:50:28 <Marvin--> I'd pattern match on   append End y,  append (A x) y  and append (B x) y
09:50:42 <Shamino> append (B s1)(A s2) = (B s1)(++)(A s2) <---------------- ????
09:50:57 <Marvin--> no no no, not use ++, *like* ++
09:51:14 <Shamino> ok show an example
09:51:22 <Marvin--> I just did
09:51:25 <Shamino> hehe
09:51:35 <Marvin--> append End y = ?? ; append (A x) y = ?? ; append (B x) y = ??
09:52:00 <Shamino> not sure what that means
09:52:10 <Shamino> german ?
09:52:27 <Shamino> what means pattern amtching ?
09:52:50 <Marvin--> uhm, if you don't know what pattern matching is, you should really go read a tutorial
09:53:14 <Shamino> someone translate that into german ?
09:53:36 <Marvin--> huh?
09:54:13 <Marvin--> http://www.haskell.org/tutorial/patterns.html
09:57:19 <Shamino> no
09:57:29 <Shamino> thats not my problem
09:57:38 <Shamino> i am not working with lists
09:57:51 <Shamino> i want to append predefined data types
09:58:03 <Shamino> data Sequ = End | A Sequ | B Sequ 
09:58:03 <Shamino> [6:46pm] <Shamino>             deriving (Show, Eq )
09:59:25 <Marvin--> I'm telling you to learn what pattern matching in general is
09:59:31 <Marvin--> it has nothing to do with lists
09:59:51 <Marvin--> constants are patterns, variables are patterns, constructors applied to patterns are also patterns, and so on
10:15:37 <Shamino> append (A s1)(A s2) = A s1 A s2
10:15:37 <Shamino> append (B s1)(B s2) = B s1 B s2
10:15:37 <Shamino> append (A s1)(B s2) = A s1 B s2
10:15:37 <Shamino> append (B s1)(A s2) = B s1 A s2
10:15:39 <Shamino> append (A s1)(A s2) = A s1 A s2
10:15:39 <Shamino> append (B s1)(B s2) = B s1 B s2
10:15:39 <Shamino> append (A s1)(B s2) = A s1 B s2
10:15:41 <Shamino> append (B s1)(A s2) = B s1 A s2
10:15:44 <Shamino> append (A s1)(A s2) = A s1 A s2
10:15:45 <Shamino> append (B s1)(B s2) = B s1 B s2
10:15:47 <Shamino> append (A s1)(B s2) = A s1 B s2
10:15:49 <Shamino> append (B s1)(A s2) = B s1 A s2
10:15:51 <Shamino> append (A s1)(A s2) = A s1 A s2
10:15:53 <Shamino> append (B s1)(B s2) = B s1 B s2
10:15:55 <Shamino> append (A s1)(B s2) = A s1 B s2
10:15:57 <Shamino> append (B s1)(A s2) = B s1 A s2
10:17:30 <Shamino> append (A s1)(A s2) = (A s1 A s2)
10:17:31 <Shamino> append (B s1)(B s2) = (B s1 B s2)
10:17:31 <Shamino> append (A s1)(B s2) = (A s1 B s2)
10:17:31 <Shamino> append (B s1)(A s2) = (B s1 A s2)
10:17:36 <Shamino> append (A s1)(A s2) = (A s1 A s2)
10:17:37 <Shamino> append (B s1)(B s2) = (B s1 B s2)
10:17:39 <Shamino> append (A s1)(B s2) = (A s1 B s2)
10:17:41 <Shamino> append (B s1)(A s2) = (B s1 A s2)
10:17:49 <Shamino> damn sorry for spamming
10:18:29 <Shamino> so the above is not working too and i am wondering why shouldnt it be possible t apend data types Like A B and End
10:18:37 <Shamino> data Sequ = End | A Sequ | B Sequ 
10:18:37 <Shamino>             deriving (Show, Eq )
10:19:41 <Marvin--> of course it is, and you don't have to do all these cases... do you know what recursion is?
10:20:18 <Shamino> data Sequ = End | A Sequ | B Sequ 
10:20:18 <Shamino>             deriving (Show, Eq )
10:20:36 <Shamino> ERROR G:\hugs\mixed5.hs:26 - Type error in application
10:20:36 <Shamino> *** Expression     : A s1 A s2
10:20:36 <Shamino> *** Term           : A
10:20:36 <Shamino> *** Type           : Sequ -> Sequ
10:20:36 <Shamino> *** Does not match : a -> b -> c -> d    
10:20:43 <Heffalump> append End s = s
10:20:55 <Heffalump> append (A s1) s2 = A (append s1 s2)
10:20:59 <Heffalump> append (B s1) s2 = B (append s1 s2)
10:21:10 <Heffalump> now try to understand how that works
10:21:17 <Shamino> yes thx
10:21:22 <Marvin--> Heffalump: yeah that's what I was getting at too, but I was trying to be slightly more subtle :P
10:21:26 <Heffalump> I know :-)
10:21:31 <Heffalump> I just couldn't take any more ;-)
10:21:35 <Marvin--> haha
10:21:42 <Marvin--> "oh, the suspension!"
10:26:52 * shapr yawns
10:27:10 <SyntaxPolice> hi shapr!
10:27:21 <shapr> hi SyntaxPolice 
10:41:53 * shapr snores
10:42:25 <shapr> cool: we have a continuous upswing in activity: http://tunes.org/~coreyr/date.php?chan=haskell
10:42:59 <shapr> looks like we really started getting traffic in late august early september of 2002
10:46:38 * SyntaxPolice joined around late september, I think
10:46:38 <shapr> aha, so it's *your* fault!
10:46:38 * SyntaxPolice is more powerful than he looks
10:46:41 <SyntaxPolice> perhaps I've been creating a lot of off-topic traffic ;)
10:46:46 * shapr uses SyntaxPolice to power his 2-CPU wattage hog
10:47:23 * SyntaxPolice runs in wheel for shapr
10:54:43 <shapr> SyntaxPolice: looks like http://tunes.org/~coreyr/read.php?chan=haskell&date=02.11.08 nearly halfway down
10:54:46 <Arnia> Yay... NN's server is back :)
10:56:22 * Marvin-- reads  http://tro.dyndns.org/icfp/viewtopic.php?t=17  and laughs
10:56:44 <Marvin--> "I've finally got a program that works great, unfortunately it takes a few hours per track..."
10:57:22 <SyntaxPolice> shapr: yep, thats me.
10:57:28 <SyntaxPolice> I guess I was wrong about when I joined.
10:57:40 <SyntaxPolice> I wonder why it took me over a month to find #haskell
10:57:51 <shapr> you were focussing on learning stuff?
10:58:31 <shapr> that what it looks like from the logs
10:59:54 * SyntaxPolice tries not to take a walk down memory lane from just a few months ago ;)
11:00:01 * shapr grins
11:00:31 <SyntaxPolice> yeah, I was definitely focused on learning stuff; and getting used to my new job, and I didn't have an internet connection for a while.  I actually started w/ Haskell sometime in september, though.
11:01:34 <shapr> in the true spirit of Haskell's evaluation model, get a Haskell job, then learn Haskell. 
11:02:06 <Shamino> hey marvin i am back for more
11:02:08 <Shamino> data Sequ = End | A Sequ | B Sequ 
11:02:08 <Shamino>             deriving (Show, Eq )
11:02:20 * Marvin-- hides behind Heffalump
11:02:22 <SyntaxPolice> hehe. actually I started learning about a month before starting the job
11:02:27 * SyntaxPolice hides behind Marvin--
11:02:28 <Shamino> i got a list like (A(B(A End)))
11:02:33 * shapr hides behind SyntaxPolice 
11:02:34 <Shamino> now i want to count the elements
11:02:43 <Shamino> "length" isn not working
11:02:52 <Shamino> any ideas ?
11:03:22 <shapr> Shamino: what's the length of an End element?
11:03:24 <Marvin--> that's because length is defined for lists
11:03:31 <Shamino> End is = []
11:03:39 <shapr> what's the length of any other element?
11:03:55 <Shamino> would guess 1 ?
11:04:03 * Marvin-- reads the log from when syntax the newbie joined ;)
11:04:04 <shapr> can you take an element apart?
11:04:23 <Shamino> what do you mean by that ?
11:04:44 <shapr> could you count this element as length 1 + length myChildren ?
11:04:49 <shapr> and length End = 0 ?
11:05:16 * SyntaxPolice kicks Marvin-- for his "well, it is" comment
11:05:24 <Shamino> guess not
11:05:53 <shapr> Shamino: read about pattern matching
11:06:06 <Shamino> i know already
11:06:11 <Shamino> its not that
11:06:12 <SyntaxPolice> Shamino: you have to recurse over the list and accumulate the length as you go along.
11:06:12 <shapr> SyntaxPolice: oh, good HaWiki integration would be @wiki <searchterm>
11:06:17 <Marvin--> SyntaxPolice: wha?
11:06:25 <Shamino> i just dont get it how to store data in haskell
11:06:28 <Riastradh> shapr, yowchef!
11:06:34 <Marvin--> oh, that
11:06:36 * Marvin-- grins
11:06:39 <SyntaxPolice> ;)
11:06:57 <SyntaxPolice> shapr: huh?
11:07:06 <Shamino> well say i got length End = 0
11:07:13 <Shamino> so length A End = 1 ?
11:07:25 <Shamino> But what about length A(A End )) ??!!!
11:07:30 * Heffalump suggests you study the recursion pattern of append
11:07:49 <Shamino> aaaaaaar matey
11:07:53 <Shamino> my ship is sinking
11:07:54 <shapr> Shamino: have you seen the definition of length for lists?
11:08:08 <Shamino> i tried to understand
11:08:13 * shapr checks the plank constant for Shamino's ship.
11:08:13 <Shamino> prelude
11:09:09 <Shamino> length           :: [a] -> Int
11:09:09 <Shamino> length            = foldl' (\n _ -> n + 1) 0
11:09:21 <Shamino> so foldl wont work caus its no list
11:09:28 <Shamino> the other things i cant even imagine
11:09:32 <shapr> length [] = 0
11:09:34 <Shamino>  looks like /§$)(%()§% to me
11:09:41 <shapr> length (x:xs) = 1 + xs
11:10:00 <shapr> Shamino: is this homework?
11:10:05 <Shamino> no
11:10:06 <Shamino> so
11:10:15 <shapr> then you can take your time and learn the pieces
11:10:18 <Shamino> length A s = 1 + s
11:10:33 <Shamino> makes no sense
11:10:43 <shapr> length (A s) = ...
11:10:48 <Shamino> s is sequenz
11:11:12 <Marvin--> shapr: length (x:xs) = 1 + length xs
11:11:24 <shapr> oh right
11:11:25 * shapr duhs
11:11:30 * shapr drinks more caffeine
11:11:38 <Shamino> but why
11:11:46 <Shamino> can i add an int to a list ?
11:11:51 <Shamino> i dont get it
11:11:52 <Marvin--> shapr: hey, you're the one who slept recently, I've been up for thirteen hours now, on five hours sleep
11:12:04 <shapr> I got about five hours sleep also
11:12:13 <Marvin--> shapr: fair enough :)
11:12:27 <shapr> I was in bed for a long time, but I couldn't switch off
11:13:26 <Marvin--> yeah, that's hard
11:13:40 <shapr> Shamino: length doesn't return a list, it returns a number
11:14:58 <Shamino> well thats what i want
11:15:12 <Shamino> length    :: Sequ -> Int
11:15:20 <Shamino> thats what i am aiming at
11:15:38 <Shamino> where Sequ is :
11:15:39 <Shamino> data Sequ = End | A Sequ | B Sequ 
11:15:39 <Shamino>             deriving (Show, Eq )
11:15:45 <shapr> I'd suggest you go throught the YAHT tutorial
11:15:47 <shapr> through
11:15:53 <Shamino> i got a book
11:16:00 <Shamino> the haskell school of expression
11:16:04 <shapr> that's a good book.
11:16:13 <shapr> how far have you read?
11:16:21 <Shamino> page 30
11:16:22 <Shamino> :)
11:17:08 <shapr> hi stepcut
11:17:20 * SyntaxPolice looks at SOE
11:17:27 <SyntaxPolice> Shamino: have you been doing some of the exercies?
11:18:54 <stepcut> hey
11:19:12 <SyntaxPolice> on page 15 there's a similar problem where you sum up the elements in a list; this shows how to use recursion to do something like this
11:19:37 <SyntaxPolice> (though it uses lists)
11:28:35 <Shamino> sur i did
11:28:49 <Shamino> but they are to easy i want to do spezial things
11:29:21 <SyntaxPolice> Shamino: with a clever combination of pattern matching and recursion, you could write the length function you want, but you should't call it length.
11:34:41 <Shamino> i call it len
11:35:10 <SyntaxPolice> so in recursion you need a base case and a recursive case. whats the base case?
11:35:32 <Shamino> if got someproblems to understand everything because my english suxx
11:35:47 <SyntaxPolice> thats OK, if you tell us what you don't understand, we'll try to help
11:35:48 <Shamino> so base case is len End = 0 me thinks
11:36:00 <SyntaxPolice> yeah, looks good.  so what is next?
11:36:17 <Shamino> recusrive case u say ?
11:36:28 <SyntaxPolice> yes. do you know what the recursive case will look like?
11:36:34 <Shamino> i call it by len A s
11:36:40 <Shamino> so i need len A s = ?
11:36:45 <Shamino> ? is
11:36:52 <SyntaxPolice> len (A s) = ...
11:36:55 <SyntaxPolice> len (B s) = ...
11:37:12 <Shamino> 1 + len s ?
11:37:18 <SyntaxPolice> yep!
11:37:21 <Shamino> but + is not allowed
11:37:25 <Shamino> i dont understand that
11:37:32 <Marvin--> yes it is, since both 1 and len s are numbers
11:37:38 <Shamino> why ?
11:37:44 <Shamino> s is a sequenz of a and bs
11:37:49 <Shamino> why is it a number ?
11:37:55 <arguile> But len s returns an Int
11:37:58 <SyntaxPolice> len s is an Int because len returns an int
11:38:03 <arguile> As you declared when you made the function
11:38:08 <Shamino> o dear
11:38:13 <Shamino> this is mad
11:38:23 <Shamino> a wait
11:38:27 <Shamino> so this means
11:38:38 <Shamino> everything on the right side of the = is the thing i declare ?
11:38:50 <Shamino> so when i say Sequ -> Bool
11:39:00 <Shamino> does it means that the above would be bool ?
11:39:08 <Shamino> s would be bool ?
11:39:19 <SyntaxPolice> Sequ -> Bool looks like a function that takes a sequence and returns a bool
11:39:33 <Shamino> yes
11:39:35 <SyntaxPolice> if I said "isEnd :: Sequ -> Bool" 
11:39:50 <Shamino> True or False
11:39:53 <Shamino> nothing else ?
11:40:04 <Shamino> a no
11:40:09 <SyntaxPolice> right.
11:40:10 <Shamino> i could call it by itself
11:40:14 <SyntaxPolice> write isEnd
11:40:15 <Shamino> reduce it
11:40:51 <Shamino> hsequ ( End) (A s2)      = True       
11:40:52 <Shamino> hsequ ( End) (B s2)      = True
11:41:00 <Shamino> and before that
11:41:01 <Shamino> hsequ (A s1)(A s2) = hsequ s1 s2             
11:41:01 <Shamino> hsequ (B s1)(B s2) = hsequ s1 s2
11:41:13 <Shamino> so its getting smaller
11:41:36 <SyntaxPolice> what is hsequ?
11:41:46 <Shamino> hsequ :: Sequ -> Sequ -> Bool
11:42:00 <Shamino> compare two lists
11:42:16 <Shamino> was just example
11:42:20 <SyntaxPolice> OK.
11:42:36 <Shamino> well ok thx ill try what u said
11:43:09 <SyntaxPolice> OK
11:48:37 <jlouis> suppose we through Monads want to do nondeterminstic computations. We define StateTransMany s a = (s -> [(s,a)])
11:48:56 <jlouis> now, assume we have such a Monad
11:49:50 <jlouis> then, if we want to make it an instance of MonadPlus, do we take mzero = STM(\s -> []), and `mplus` like list concatenation (++)?
11:50:03 <Riastradh> Why State _Trans_ Many?
11:50:15 <Riastradh> It's not a monad transformer...
11:50:18 <jlouis> so p `mplus` q returns what p ++ q has of possibilites
11:50:24 <jlouis> correct
11:50:32 <jlouis> Call it statemany then
11:52:22 <Riastradh> instance MonadPlus StateMany where { mzero = StateMany (\_ -> []); (StateMany s1) `mplus` (StateMany s2) = StateMany (\s -> s1 s ++ s2 s) }  -- like that?
11:52:58 <jlouis> something like that yes
11:53:21 <jlouis> modulo syntax differences in fact
11:53:49 <Riastradh> What would the Monad instance be, then?
11:54:15 <jlouis> return a = STM( \s -> [(s,a)])
11:54:30 <Riastradh> How do you return multiple things?
11:54:35 <Riastradh> Or rather...
11:54:46 <jlouis> ah, you say something
11:54:48 <Riastradh> How do you return things which are later nondeterministically chosen?
11:56:11 <jlouis> I have not found the trick yet
11:56:27 <jlouis> It is an exercise I do in order to try to learn about monads
11:56:39 <jlouis> but I am fairly sure it will work at some point
12:06:31 <jlouis> Main> length $ applySTM (queens 8 8) ([],[],[])
12:06:33 <jlouis> 92
12:06:36 <jlouis> HAH!
12:07:20 <jlouis> Riastradh: if p and q are nonderterministic, I use p `mplus` q
12:08:44 <Riastradh> Oh, duh.
12:10:41 <jlouis> How many are there in the 9 9 problem?
12:10:58 <jlouis> hmmm
12:11:26 <Shamino> damn teas empty
12:11:43 <jlouis> Monads are fun ;)
12:12:09 <Riastradh> Indeed.
12:12:17 <Riastradh> Arrows can probably get even more fun, too!
12:13:07 <jlouis> yes. I choose to lay arrows on the shelf until I got the hang of monads
12:13:29 <jlouis> They seems rather simple though
12:26:09 <Shamino> someone knows definition for reversing a list ?
12:27:03 <vegai> x:xs = xs ++ x
12:27:08 <vegai> that was a _wild_ guess
12:27:18 <Shamino> mhhhh
12:27:21 <Shamino> what about
12:27:29 <Shamino> xs + [x]
12:28:04 <Shamino> reverse (x:xs) = xs + [x]
12:28:08 <Shamino> is this correct ?
12:28:27 <vegai> looks better, but isn't it ++?
12:28:37 <vegai> concatenation, that is
12:31:46 <Riastradh> No, that's not reversing either.
12:32:09 <Riastradh> By that definition:   reverse [1,2,3,4] --> [2,3,4,1]
12:32:35 <Shamino> mhhhh
12:32:50 <vegai> reverse xs ++ [x]
12:33:01 <vegai> ...of course
12:33:27 <vegai> I need to install the interpreter
12:33:42 <Shamino> now i have to translate that arrrrrrr matey we are taking water
12:34:06 <Riastradh> reverse xs ++ [x] is a terrible reverse function, though, anyways.
12:34:20 <vegai> Riastradh: what would you use?
12:34:23 <Arnia> @prelude reverse
12:34:25 <lambdabot> *** "reverse" prelude "Haskell Standard Prelude Dictionary": text follows
12:34:25 <lambdabot> reverse
12:34:25 <lambdabot>   reverse ::  [a] -> [a]
12:34:25 <lambdabot>   reverse    = foldl (flip (:)) []
12:34:29 <Shamino> i am trying to reverse as and bs BABABABBAAAAABABA
12:34:31 <h> re
12:34:32 <Riastradh> That.
12:34:49 <vegai> ok, that makes no sense at all =)
12:34:54 <Riastradh> @prelude foldl
12:34:56 <lambdabot> *** "foldl" prelude "Haskell Standard Prelude Dictionary": text follows
12:34:56 <lambdabot> foldl
12:34:56 <lambdabot>   foldl ::  (a -> b -> a) -> a -> [b] -> a
12:34:56 <lambdabot>   foldl f z []      = z
12:34:57 <lambdabot>   foldl f z (x:xs)  = foldl f (f z x) xs
12:35:05 <vegai> @prelude flip
12:35:06 <lambdabot> *** "flip" prelude "Haskell Standard Prelude Dictionary": text follows
12:35:07 <lambdabot> flip
12:35:09 <lambdabot>   flip ::  (a -> b -> c) -> b -> a -> c
12:35:11 <lambdabot>   flip f x y      = f y x
12:35:18 <arguile> http://www.haskell.org/onlinereport/standard-prelude.html
12:35:30 <Shamino> he lambdabot stop spamming !!
12:35:38 <Shamino> :)
12:35:49 <vegai> but why foldl... hrm
12:36:10 <Shamino> foldl cant help me because it again for lists only
12:36:28 <Riastradh> Shamino, your datatype is rather...odd...it's just an endless stream of two possible values.
12:36:32 <Riastradh> Er, not endless.
12:36:39 <Shamino> madness :)
12:36:56 <Riastradh> It might be much simpler if you just did:   data MyValue = A | B  and then  type Sequ = [MyValue]
12:37:04 <Shamino> mh
12:37:21 <Shamino> yes
12:37:33 <Shamino> but its the same after all isnt it ?
12:37:45 <Riastradh> It's the same but your type is rather pointless.
12:37:49 <jlouis> damn, TyingTheKnot can be useful
12:38:02 <Shamino> yes i suck :)
12:38:24 <Riastradh> It's like rewriting all operations on monads (e.g., mapM, filterM, etc.) for every single monad.
12:38:25 <vegai> The Gentle Introduction should cover folds a bit more
12:39:03 <vegai> ie. even a birt
12:39:05 <vegai> s/birt/bit/
12:39:05 <Shamino> @prelude lex
12:39:07 <lambdabot> *** "lex" prelude "Haskell Standard Prelude Dictionary": text follows
12:39:07 <lambdabot> lex
12:39:07 <lambdabot>   lex ::  ReadS String
12:39:07 <lambdabot>   lex ""                  = [("","")]
12:39:08 <lambdabot>   lex (c:s) | isSpace c   = lex (dropWhile isSpace s)
12:39:10 <lambdabot>   lex ('\'':s)            = [('\'':ch++"'", t) | (ch,'\'':t)  <- lexLitChar s,
12:39:12 <lambdabot>   					       ch /= "'"                ]
12:39:14 <lambdabot>   lex ('"':s)             = [('"':str, t)      | (str,t) <- lexString s]
12:39:16 <lambdabot> [there's @more]
12:39:27 <Shamino> got it ? :)
12:40:41 <Shamino> well i didnt
12:41:01 <jlouis> why do you need lex?
12:41:08 <jlouis> what are you trying to do?
12:41:15 <Shamino> to confuse you :)
12:41:38 <arguile> You're doing an admirable job
12:41:41 <Shamino> i wanted to show you how i feel right now
12:42:14 <jlouis> list reversion?
12:42:37 <vegai> can somebody explain how the Prelude's defintion of reverse works?
12:42:59 <vegai> I think I understand foldl and flip separetely, but not in there
12:43:50 <jlouis> flip just wraps the 2 values around, so we agree that is easy right?
12:44:08 <vegai> yes
12:44:19 <vegai> flip is no problem
12:44:45 <jlouis> foldl :: (a -> b -> a) -> a -> [b] -> a
12:44:48 <vegai> ...well, neither foldl
12:45:28 <vegai> I'll have to figure this myself, apparently
12:45:38 <jlouis> @type (:)
12:45:39 <lambdabot> (:) :: a -> [a] -> [a]
12:45:42 <jlouis> ok?
12:45:46 <jlouis> @type flip
12:45:47 <lambdabot> flip :: (a -> b -> c) -> b -> a -> c
12:45:52 <Riastradh> foldl (flip (:)) [] [1,2,3,4]
12:45:53 <Riastradh> -->
12:46:03 <Riastradh> foldl (flip (:)) (1 : []) [2,3,4]
12:46:06 <arguile> vegai: If you don't get it, it might help to manually write out the steps for a small ist
12:46:09 <Riastradh> foldl (flip (:)) (2 : 1 : []) [3,4]
12:46:16 <Riastradh> foldl (flip (:)) (3 : 2 : 1 : []) [4]
12:46:19 <arguile> As Riastradh is now doing... :)
12:46:21 <Riastradh> foldl (flip (:)) (4 : 3 : 2 : 1 : []) []
12:46:28 <Riastradh> 4 : 3 : 2 : 1 : []
12:46:30 <Riastradh> [4,3,2,1]
12:46:42 <vegai> Ah. Thank you very much, Riastradh.
12:46:53 <jlouis> You can get an understanding by looking at types too
12:46:58 <jlouis> @type (flip (:))
12:46:59 <lambdabot> flip (:) :: [a] -> a -> [a]
12:48:12 <vegai> did ghc have an interpreter?
12:48:17 <jlouis> ghci
12:48:18 <Riastradh> Yes -- GHCi.
12:48:30 <vegai> ok...
12:50:03 <vegai> could you guys come up with that definition if you hadn't seen it earlier?
12:50:25 <vegai> or perhaps s/could/would/
12:50:44 <Riastradh> The definition of reverse?
12:50:47 <vegai> yes
12:50:59 <jlouis> I would have used a worker
12:51:14 <Riastradh> I would probably have written an auxiliary function and then smacked myself for realizing that I should be using foldl.
12:53:26 <Riastradh> I'd initially write:
12:53:33 <Riastradh> reverse l = reverse' l []
12:53:34 <Riastradh>   where
12:53:38 <Riastradh>     reverse' [] r = r
12:53:45 <Riastradh>     reverse' (x:xs) r = reverse' xs (x:r)
12:53:57 <Marvin--> Riastradh: that's probably what the inliner produces
12:53:58 <jlouis> Exactly
12:54:49 <Marvin--> look at the length implementation in ghc...
12:55:01 <jlouis> The question is what is most readable
12:55:19 <jlouis> foldl (flip (:) [] is something you need to write out to see what does
12:55:19 <Riastradh> foldl (\x _ -> x + 1) 0  -- is it similar to that, Marvin--?
12:55:36 <Marvin--> Riastradh: nope
12:55:45 <Marvin--> length l                =  len l 0#
12:55:45 <Marvin-->   where
12:55:45 <Marvin-->     len :: [a] -> Int# -> Int
12:55:45 <Marvin-->     len []     a# = I# a#
12:55:45 <Marvin-->     len (_:xs) a# = len xs (a# +# 1#)
12:56:10 <avida> 
12:56:14 <Riastradh> Yes it's similar to that!  It's just that foldl got inlined or something similar.
12:56:36 <Marvin--> and in this case, unboxed
12:56:46 <jlouis> 0# notes unboxed values?
12:56:50 <jlouis> rather n#
12:57:05 <Shamino> and now the question of the day how to reverse my data type ? :)
12:57:16 <Marvin--> jlouis: yes
12:57:30 <Marvin--> dunno how portable it is, though
12:57:31 <Shamino> mirror (A s) = (mirror s ) A ?
12:57:34 <jlouis> A GHC extension I presume?
12:57:45 <Marvin--> you presume right :)
12:58:23 <Shamino> and i presume wrong
12:58:38 <jlouis> It is good to have explicit control over (un)boxing though when you need to squeeze that little bit of extra power out of your strict, tail recursive heavily used innep ''loop'
12:59:07 <jlouis> Shamino: What is your datatype?
12:59:19 <Shamino> hehe you dont want to know :)
12:59:27 <Shamino> data Sequ = End | A Sequ | B Sequ 
12:59:27 <Shamino>             deriving (Show, Eq )
13:00:04 <Shamino> or A | B type ..... depending what you like
13:00:14 <hdaume> hey folks
13:00:16 <jlouis> Shamino: that is better
13:00:25 <jlouis> hey hdaume, thanks for your tutorial
13:00:39 <jlouis> Shamino: data Sequ = A | B
13:00:41 <hdaume> jlouis: you're welcome :)
13:00:46 <jlouis> type Sequlist = [Sequ]
13:00:53 <Riastradh> jlouis, that's what I told him a while ago.
13:01:00 <jlouis> or something like that (new to Haskell, to much SML-blood in me :)
13:01:17 <Riastradh> jlouis, you got it right.
13:01:38 <jlouis> Shamino: then there should be no problem at all
13:01:52 <jlouis> just apply reverse on the suc....
13:02:04 <Shamino> you cant use reverse
13:02:17 <Riastradh> Why not?
13:02:20 <Shamino> mirror :: Sequ -> Sequ
13:02:23 <Shamino> its no list
13:02:34 <jlouis> aha
13:02:38 <jlouis> data Elem = A | B
13:02:38 <Shamino> or is reverse for everything ?
13:02:45 <jlouis> type Sequ = [Elem]
13:02:54 <jlouis> mirror = reverse
13:03:03 <Riastradh> Shamino, if you were listening to what jlouis or I said, you would have seen that we suggested a different way to define 'Sequ,' which is much better.
13:03:16 <Shamino> hehe
13:03:17 <Shamino> yes
13:03:26 <Shamino> u got a  point
13:03:34 <Shamino> but i like mine so much
13:03:42 * vegai boggles heavily.
13:04:25 <Riastradh> Why do you prefer yours?  Ours is much simpler and all list operations work on it.
13:04:34 <Shamino> [9:35pm] <Shamino> madness :)
13:04:34 <Shamino> [9:35pm] <Riastradh> It might be much simpler if you just did: data MyValue = A | B and then type Sequ = [MyValue]
13:04:34 <Shamino> [9:35pm] <Shamino> mh
13:04:39 <Shamino> :)
13:05:02 <vegai> 9:35pm... perhaps time for bed, Shamino? =)
13:05:10 <Shamino> maybe i am just mortal
13:05:24 <Shamino> 8 hours of haskell
13:05:42 <Shamino> more then a mortal can bear
13:05:50 <Shamino> urrrfffff
13:05:59 <vegai> even more so, then
13:06:16 <Shamino> but i want to do this last function
13:06:47 <jlouis> Shamino: you have homework and you need to do it for tomorrow and you want to go out and party, admit it...
13:06:57 <Shamino> no
13:07:04 <Shamino> no party :(
13:07:10 <Shamino> no homework :(
13:07:15 <Shamino> nothing at all :(
13:07:23 <vegai> then sleep, for buddha's sake!
13:07:29 <Shamino> hrhr
13:07:39 <arguile> *whispers* or at least for ours
13:07:42 <vegai> you know you wanna... first time's for free
13:07:49 <arguile> =P
13:07:54 <jlouis> Shamino: If you want to do it your way, I would suggest looking at the simple definition of reverse given above by Riastradh and extending it with pattern matching for your datatype
13:08:06 <Shamino> next time 83947568346 $ ?
13:08:22 <Shamino> thats what i am doing
13:08:27 <Shamino> err trying to do
13:11:00 <jlouis> Good...
13:11:04 <Shamino> data abc = A | B  
13:11:04 <Shamino>             deriving (Show, Eq )
13:11:04 <Shamino> type Sequ = [abc] 
13:11:11 <Shamino> type is under data i guess
13:11:24 <jlouis> Now you do it our way
13:11:28 <Riastradh> It has to be 'data Abc' -- type names must be capitalized.
13:11:37 <Shamino> a yes
13:11:38 <Riastradh> (but what's the c for?  It's just A and B.)
13:11:50 <Shamino> u
13:11:58 <Shamino> i thought it doesnt matter what its named like
13:12:30 <Shamino> data Ab = A | B  | End
13:12:30 <Shamino>             deriving (Show, Eq )
13:12:30 <Shamino> type Sequ = [Ab] 
13:12:50 <Shamino> or
13:12:51 <Shamino> data A B = A | B  | End
13:12:51 <Shamino>             deriving (Show, Eq )
13:12:51 <Shamino> type Sequ = [A B] 
13:12:53 <Riastradh> Now you get all the list operations defined in the Prelude and in the List module.
13:12:57 <Riastradh> No, not 'A B'.
13:13:09 <Riastradh> And the End is unnecessary.
13:13:23 <Shamino>  Constructor "A" must have exactly 0 arguments in pa
13:13:23 <Shamino> ttern                               
13:13:26 <Shamino> jepeeeeeh
13:13:36 <Riastradh> 'A B' wont work.
13:13:42 <Shamino> i am using Ab
13:14:35 <jlouis> ok, now you are down to two lines, if you partout want your ''mirror'' function
13:14:45 <jlouis> with type Sequ -> Sequ
13:16:12 <Shamino> if i do it your way
13:16:19 <Shamino> ill have to change all my other programs
13:16:43 <Shamino> as     :: Int  -> Sequ
13:16:44 <Shamino> bs     :: Int  -> Sequ
13:16:44 <Shamino> len    :: Sequ -> Int
13:16:44 <Shamino> append :: Sequ -> Sequ -> Sequ
13:16:44 <Shamino> mirror :: Sequ -> Sequ
13:16:44 <Shamino> as 0     = End
13:16:46 <Shamino> as (n+1) = A (as n)
13:16:48 <Shamino> bs 0     =  End
13:16:50 <Shamino> bs (n+1) = B (as n)
13:16:52 <Shamino> len End   = 0
13:16:54 <Shamino> len (A s) = 1 + len s
13:16:56 <Shamino> len (B s) = 1 + len s
13:16:58 <Shamino> append End End    = End
13:17:00 <Shamino> append End s      = s
13:17:02 <Shamino> append (A s1) s2  = A (append s1 s2)
13:17:04 <Shamino> append (B s1) s2  = B (append s1 s2)
13:17:06 <Shamino> mirror End   = End
13:17:08 <Shamino> mirror (A s) = (mirror s ) A
13:17:10 <Shamino> mirror (B s) = (mirror s ) B  
13:18:09 <Shamino> so no offense but i think ill keep my old one
13:18:19 <Shamino> and next time i define ill use yours
13:19:16 <Shamino>  I'd initially write:
13:19:16 <Shamino> [9:52pm] <Riastradh> reverse l = reverse' l []
13:19:16 <Shamino> [9:52pm] <Riastradh> where
13:19:16 <Shamino> [9:52pm] <Riastradh> reverse' [] r = r
13:19:16 <Shamino> [9:52pm] <Riastradh> reverse' (x:xs) r = reverse' xs (x:r)
13:20:34 <jlouis> Shamino: Ok, I just did the reimplementation in mine and Riastradh's version. 9 lines
13:20:52 <Shamino> i am curious
13:21:10 <jlouis> lets take the simple ones first
13:21:14 <hdaume> jlouis: i think you could do it in 5...these are all prelude functions
13:21:24 <jlouis> hdaume: yes
13:21:44 <Shamino> i AM curious
13:21:45 <Shamino> :)
13:22:05 <jlouis> hdaume: I have a newline in it, and a deriving clause on its own line :)
13:22:14 <jlouis> Shamino: mirror = reverse
13:22:18 <jlouis> len = length
13:22:21 <hdaume> oh, i wasn't including the definition :)
13:22:23 <jlouis> append = (++)
13:22:35 <Shamino> yes i couldnt use them caus i didnt got lists
13:22:43 <jlouis> as n = take n $ repeat A
13:22:46 <jlouis> ..
13:22:53 <hdaume> jlouis: (or, as n = replicate n A)
13:23:17 <Shamino> ok one more thing
13:23:20 <jlouis> hdaume: prettier, considering I started on Haskell today I still need familarisation with the Prelude
13:23:35 <hdaume> jlouis: yeah, replicate was a function that it took me a while to discover :)
13:23:46 <Shamino> mirror (A s) = (mirror s ) A
13:23:50 <Shamino> why is this not working ?
13:23:56 <jlouis> SML misses it. We have List.tabulate, but that is the closest one
13:24:00 <hdaume> Shamino: because it doesn't make sense :)
13:24:04 <Shamino> lol
13:24:10 <Shamino> :)
13:24:19 <hdaume> you want 'mirror :: X -> X', right?
13:24:26 <Shamino> ok the left hand side is ok
13:24:27 <Shamino> yes
13:24:27 <hdaume> where X is whatever you called your AB list type
13:24:36 <Shamino> yes
13:24:48 <hdaume> but then on the RHS you call 'mirror s A', which treats it like a function of type 'X -> X -> X'
13:25:06 <Shamino> ok s its wrong i guess
13:25:08 <Shamino> hehe
13:25:11 <jlouis> Hindley-Milner has struck again...
13:25:19 <Shamino> ok so isay whats ok so far is
13:25:29 <hdaume> Shamino: actually, it's worse than that...
13:25:30 <Shamino> mirror A s = mirror s but something is misssing
13:25:41 <hdaume> yes.  in list notation you might say:
13:25:53 <hdaume> mirror (x:xs) = mirror xs ++ [x]
13:26:03 <hdaume> (note that this is hugely inefficient, but it works)
13:26:04 <Shamino> yes thats what we got above
13:26:13 <Shamino> up up in the sky
13:26:21 <hdaume> so in your case you want to replace (++) with your append (or whatever you called it) and [x] with (A End), right?
13:26:29 <Shamino> yes
13:26:56 <hdaume> so you should be able to write it given what i've just said :)
13:27:10 <jlouis> hdaume: I see that... nice way of doing it ;)
13:27:52 <Shamino> jesus
13:27:55 <Shamino> you are good
13:28:20 <Shamino> mirror A s = mirros s (append (A End)) ?
13:28:34 <hdaume> not quite :)
13:28:36 <Shamino> mirror A s = mirror s (append (A End)) ?
13:28:55 <Shamino> mirror A s = mirror s (append A End) ?
13:29:09 <hdaume> (you're going to need parens around "A s" on the LHS)....and you need to pull the append to the front
13:29:17 <hdaume> because basically what you want to do is this:
13:29:22 <hdaume> i have a list of the for (A something)
13:29:26 <Shamino> is this the #quiz :)
13:29:34 <hdaume> in order to reverse this, I want to append the element A to the end of the reverse of something
13:29:34 <Shamino> mirror (A s) = mirror s (append A End) ?
13:29:45 <hdaume> so i can get the reverse of something by calling (reverse something)
13:29:57 <hdaume> and i can make a single element list A by (A End)
13:30:13 <hdaume> now, i have two things, (reverse something) and (A End) and I want to append the latter onto the former
13:30:18 <hdaume> you take it from there :)
13:30:30 <Shamino> brain wok now
13:30:50 <hdaume> jlouis: how'd you decide to learn Haskell?
13:31:55 <Shamino> ack
13:31:59 <Shamino> arrrrrrrrrrrrrrrrrrrrrrrrr
13:32:30 <Shamino> me ugly human slave must append tiny human thingy to end of what ar me nub gruk this humie snarf
13:36:46 <Shamino> lol
13:37:10 <Shamino> rename this channel into #shaminos
13:39:12 <Shamino> : sigh
13:42:25 <Shamino> so in your case you want to replace (++) with your append (or whatever you called it) and [x] with (A End), right?
13:46:57 <Shamino> mirror (A s) = (append A End) mirror s
13:47:14 <hdaume> you need a few more parens, but that's pretty much it
13:47:58 <Shamino> mirror (A s) = (append (A End)) (mirror s)
13:48:00 <Shamino> !!!!!!!!!
13:48:06 <hdaume> yay
13:48:10 <Shamino> hurah !
13:48:17 <Shamino> BEEEEEEER
13:48:21 <Shamino> ;)
13:48:27 <hdaume> and actually, " = append (A End) (mirror s)" would be fine
13:48:48 <Shamino> wow
13:49:05 <Shamino> i am amazed how slowely my brain works
13:49:14 <hdaume> you'll get used to it after a while
13:49:25 <hdaume> (to haskell, n ot to your brain working slowly ^_^)
13:49:44 <Shamino> lol
13:49:45 <Shamino> :)
13:50:52 <Shamino> arck
13:51:04 <Shamino> i am sorry to say that but its no error
13:51:06 <Riastradh> Well, it'd be good to get used to your brain working slowly, too.
13:51:12 <Shamino> but its not mirroring
13:51:34 <Shamino> mirror End   = End
13:51:34 <Shamino> mirror (A s) = append (A End) (mirror s)
13:51:34 <Shamino> mirror (B s) = append (B End) (mirror s)
13:51:48 <Shamino> Main> mirror (A(A(B End)))
13:51:48 <Shamino> A (A (A End)) :: Sequ
13:51:48 <Shamino> Main> mirror (A(A(B End)))
13:51:48 <Shamino> Reading file "G:\hugs\mixed5.hs":
13:51:48 <Shamino> A (A (B End)) :: Sequ    
13:52:09 <hdaume> oh oops
13:52:11 <hdaume> you have a bug :)
13:52:40 <hdaume> the program you wrote is the same as "mirror (x:xs) = [x] ++ mirror xs", which is clearly the identity
13:52:57 <Shamino> you lured me into a trap
13:53:13 <Shamino> defend yourself
13:53:17 <hdaume> Shamino: no, i just wasn't thinking too hard when i said yours looked right :)
13:53:21 <hdaume> my brain works slowly too :)
13:53:23 <Shamino> *taking weapon*
13:53:27 <hdaume> it's *more or less* correct
13:53:41 <hdaume> you just have a small bug with the order of arguments
13:53:52 <Shamino> *Shamino swings and hits <hdaume> for 12 points of damage....
13:54:01 <hdaume> :)
13:54:04 <Shamino> *Shamino swings and misses
13:54:14 <Shamino> *Shamino swings and hits <hdaume> for 7 points of damage....
13:54:30 <Shamino> System Message <hdaume> is bleeding...
13:54:38 <Shamino> *Shamino swings and hits <hdaume> for 15 points of damage....
13:55:19 <Shamino> *Shamino goes Berserk
13:55:31 <Shamino> *Shamino sweeps chat room
13:58:12 * Arnia introduces shamino to kosh
13:58:24 <Shamino> *blushes*
13:58:46 --- mode: ChanServ set +o SyntaxPolice
13:58:50 <thornber> how do I declare a function that takes an 'a' and returns a function that takes an 'a' and returns ... etc ?
13:58:51 * SyntaxPolice picks up 20 sided die
13:58:54 <SyntaxPolice> ;)
13:59:31 <thornber> eg, for writing a state machine
13:59:52 <Shamino> mirror (A s) =(mirror s) (append (A End))
13:59:57 <Shamino> so whats wrong with that now
14:00:10 <Shamino>  the program you wrote is the same as "mirror (x:xs) = [x] ++ mirror xs", which is clearly the identity
14:00:22 <Shamino>  mirror (x:xs) = mirror xs ++ [x]
14:00:25 <Shamino> what i did
14:00:30 <Shamino> was turning that now
14:00:32 <Shamino> still wrong
14:02:48 <Shamino> must be some small thing
14:02:55 <Shamino> like ()
14:03:13 --- mode: SyntaxPolice set -o SyntaxPolice
14:03:36 <hdaume> Shamino: hint: look at the order of arguments to append
14:04:17 <Shamino> chaos
14:04:29 <Shamino> wtf
14:04:41 <hdaume> net split
14:05:05 <Shamino> order well the order
14:05:24 <Shamino> ok rest of list i want append something on the right hand side
14:05:40 <Shamino> i append A End to the right hand side
14:05:53 <Shamino> and reuse the rest by mirror s
14:06:26 <Shamino> i am blind cant see it
14:07:06 <hdaume> change the order :)
14:07:12 <Shamino> End A ??
14:07:15 <Shamino> makes no sense
14:07:36 <hdaume> no, the order of the arugments to append
14:07:43 <hdaume> youc all append x y; you want to call append y x
14:08:05 <Shamino> ooo well
14:08:09 <Shamino> mhh
14:09:19 <Shamino> HURF ?
14:09:21 <Shamino> lol
14:09:27 <Shamino> still makes no sense
14:09:31 <Shamino> that would mean End A
14:10:19 <hdaume> no.
14:10:26 <hdaume> you call append with two arguments
14:10:29 <hdaume> the first is (A End)
14:10:34 <hdaume> the second is (mirror s)
14:10:40 <hdaume> flip the order of these
14:11:11 <Shamino> but that id func
14:11:16 <Shamino> is
14:11:45 <Shamino> mirror (A s) =(mirror s) (append End A) 
14:12:14 <Shamino> you mean mirror (A s)=(append End A) (mirror s)
14:12:23 <Shamino> what we got before and returns A s
14:12:52 <hdaume> okay, let's take a step back
14:13:15 <hdaume> append is a function which takes two lists and produces a single list
14:13:21 <Shamino> yes
14:13:34 <hdaume> you write "append arg1 arg2" to say that you are applying the arguments arg1 and arg2 to append
14:13:47 <hdaume> in your erroneous case, you say "append (A End) (mirror s)"
14:13:56 <hdaume> in this case, arg1 is (A End) and arg2 is (mirror s)
14:14:02 <hdaume> these are in the wrong order
14:14:12 <hdaume> you really wan tto append (A End) to the *end* or (mirror s)
14:14:20 <Shamino> urmh
14:14:26 <Shamino> ok time for bed
14:14:34 <Shamino> :(
14:14:50 <hdaume> but in your code you put it on the beginning
14:15:03 <hdaume> you're calling "append x y" when you want to call "append y x"
14:15:09 <hdaume> where x = A End and y = mirror s
14:15:28 <Shamino> mirror (A s) = append(mirror s (A End ))
14:16:10 <Shamino> the amount of combinations is final sometime it must be correct !!!
14:20:41 <Shamino> yes my final sentence was correct
14:22:28 <Shamino> i am leaving you now for your own sake
14:22:32 <Shamino> but ill return !!!!!
14:22:38 <Shamino> MWUAHAHAHAA
14:25:30 <cale> @yow
14:25:33 <lambdabot> NOW do I get to blow out the CANLDES??
14:25:54 <cale> @yow
14:25:54 <lambdabot> That's a decision that can only be made between you & SY SPERLING!!
14:33:54 <cale> @yow
14:33:54 <lambdabot> My Aunt MAUREEN was a military advisor to IKE & TINA TURNER!!
14:34:15 <Arnia> @yow
14:34:16 <lambdabot> UH-OH!!  We're out of AUTOMOBILE PARTS and RUBBER GOODS!
14:37:34 <cale> @yow
14:37:34 <lambdabot> ..  So, if we convert SUPPLY-SIDE SOYBEAN FUTURES into
14:37:34 <lambdabot>  HIGH-YIELD T-BILL INDICATORS, the PRE-INFLATIONARY risks
14:37:34 <lambdabot>  will DWINDLE to a rate of 2 SHOPPING SPREES per EGGPLANT!!
14:44:17 <cale> @yow
14:44:17 <lambdabot> YOW!!  The land of the rising SONY!!
14:44:52 <cale> @yow
14:44:52 <lambdabot> ..  someone in DAYTON, Ohio is selling USED CARPETS to a SERBO-CROATIAN
14:53:21 <Igloo> Can someone please slow down the passage of time a mite?
14:55:09 <cale> oh, I can do that, with my new global time machine.
14:56:14 <Marvin--> Igloo: pleeeeease yes
14:57:09 <Arnia> ICFP problems? :(
14:59:57 <h> :)
15:00:42 <Marvin--> noooo
15:01:04 <Marvin--> seeing as we realized three or four hours ago that "this strategy won't work"...
15:02:30 <Arnia> Shit :(
15:04:12 <h> hehe
15:04:24 <Igloo> Are you able to drive round the circuits, Marvin?
15:04:53 <Marvin--> *cough* trade secrets
15:04:59 <Igloo> Heh
15:07:16 <Riastradh> The #scheme team collectively drives a car over every member of the #haskell team!
15:07:36 <Marvin--> well, if we hadn't wasted all that time on our first, very cool, strategy, we might actually have gotten somewhere with this one
15:11:31 <Marvin--> it sure is going to be interesting to read about all the submissions
15:15:37 <Igloo> Marvin  :-(
15:19:20 <mattam> #scheme'rs can drive cars ? what is this world I live in... :)
15:23:35 * Arnia blows a raspberry at the #scheme trampoline
15:50:08 <Marvin--> hmm, we've got 70 minutes, think we're going to make it...nahh
15:51:14 <mattam> we will
15:57:01 <Igloo> Good luck
15:57:55 <Marvin--> Igloo: how's it going for you guys?
15:59:48 <Igloo> Well, we have what we were aiming for basically working, although some manual tweaking of paths is necessary (not due to our code we believe). We don't have enough time to try out all the optimising tweaks that are obvious, though
16:00:00 <Igloo> And we don't have a particularly fast car from what we can tell
16:04:47 <cale> It would seem to me that certain ideas on how to do go ai might work out with the icfp problem. It'll be interesting to see if anyone takes the route that I'm thinking of.
16:05:49 <hdaume> cale: what route is that?  :)
16:05:53 <mattam> cale: which is ? some sort of A* ?
16:06:55 * hdaume has a feeling that the solutions run on "organic" hardware are going to win :)
16:07:01 <cale> I'm not too clear on the actual algorithms, but it was basically a way to compute influence that stones have using a cellular automaton.
16:07:06 <hdaume> perhaps post-optimized
16:07:24 <kosmikus> Igloo: did you use TH for your solution?
16:07:36 <Igloo> No  :-)
16:07:48 <Igloo> Good thing too given we've had to back out to GHC 5 at various points
16:07:54 <mattam> hdaume: not on all maps :)
16:09:36 * Igloo is annoyed with how hard it is to do a "proper" solution to this. Running things on your own machine both ads bias to those with more computational power at their disposal and makes that more inevitable
16:09:45 <Igloo> proper and good, that is
16:09:49 <mattam> cale: a cellular automaton, you mean 'cell divising' the map ?
16:11:03 <Marvin--> I guess it's no harm to reveal now that our first approach involved using A*
16:11:20 <Marvin--> well, no, our first approach involved skeletonization, maybe it was our second that involved A*
16:11:48 <Marvin--> but ew didn't get the heuristic good enough, and didn't get the pruning good enough so we didn't really *get* anywhere
16:11:54 <cale> mattam: possibly. Go is already chunked off into cells, so in that case it didn't need any extra subdivision.
16:11:59 <Marvin--> lots of cool code though :-P
16:12:54 <mattam> but the very problem here is speed/shortest path tradeoff
16:13:41 <mattam> and I don't see discretizing as a  solution to that...
16:13:55 <cale> though, in the case of go, the space of possible values was one dimensional (influence going from strongly white to strongly black), but in the case of the car problem, probably a 2-D vector "colouring" would be used.
16:16:23 * kosmikus decides not to submit any more solutions ...
16:16:57 <Igloo> You have it perfect already?  :-)
16:17:48 <kosmikus> not really ...
16:32:39 <h> hehe 27mins 
16:33:08 <shapr> http://kungens.kemi.fi/~shae/hairpinsconfused.png
16:33:22 <h> hello shapr 
16:33:24 <shapr> hi h
16:33:29 <h> how are you ?
16:33:34 <shapr> I'm okay.
16:33:42 <shapr> Riastradh: that url is for you.
16:33:47 <h> nice
16:33:51 <Marvin--> indeed it is :P
16:34:12 <h> haha 
16:34:17 <h> funny track
16:34:40 <Arnia> Shapr!
16:34:45 * Arnia boings
16:34:49 <shapr> hi Arnia
16:34:57 <h> is it drunken AI ?
16:34:58 <Riastradh> That's what your car tried to do?
16:35:02 <shapr> yup
16:35:06 <Riastradh> Haha.
16:35:13 <Riastradh> Ours at least works.
16:35:18 <shapr> yup
16:35:22 <Riastradh> However, the Dylan team looks like it's doing -REALLY- well.
16:35:35 <Marvin--> Riastradh: this is what we've hacked up during the last six hours, since our previous approach didn't work :-/
16:35:47 <Riastradh> They've got only about seventy thousand instructions so far -- they're just tweaking now, as everything works so far for them.
16:35:49 <shapr> yah, we could turn this into a lightning entry if we had a time machine
16:36:22 <Marvin--> shapr: not true, we spent some time on Fixed, and the simulator and so on
16:37:05 <shapr> oh, right
16:37:31 <Arnia> Could be used in a chaos simulator...
16:37:45 <Riastradh> Could any of you who have DrScheme be nice to the #scheme team and make a point file for a track?
16:37:51 <h> is there more picture like this around ?
16:38:02 <shapr> nah, not really.
16:38:41 <h> i dont have scheme
16:38:54 <Marvin--> Riastradh: I think we can do it with just a .trc...
16:39:31 <Riastradh> Marvin--, yeah, but your car can't even figure out where to go even with human direction -- ours just takes a little bit of human direction.
16:39:56 <Marvin--> Riastradh: I mean, give me a .trc and I'll give you the visualization...
16:40:06 <Riastradh> Oh.  Er.
16:40:11 <Riastradh> The point is that we need .pts files to make .trc files.
16:40:16 <Marvin--> er
16:40:18 <shapr> what's a .pts file?
16:40:25 <Riastradh> A points file.
16:40:30 <Riastradh> We use it to generate .trcs.
16:42:37 <Marvin--> hd-doh
16:49:46 <cale> shapr: that's some crazy tunnelling. :)
16:49:53 <shapr> truly
16:51:35 * Marvin-- officially gives up and goes to bed :)
16:59:04 <Heffalump> hohum.
16:59:11 <Heffalump> well that was a sorry fiasco :-)
17:01:07 <cale> "The car's top speed is guaranteed to be less than 1 square per time step." -- that seems pretty slow given the size of the tracks.
17:02:04 <cale> (though I guess it keeps things honest)
17:02:14 <Heffalump> it's hard to turn at that speed
17:04:40 <Arnia> That seems like a hard problem to solve in one weekend :(
17:11:31 <Heffalump> it was, yes
17:11:49 <Arnia> When will the solutions be published?
17:13:25 <Heffalump> ICFP I think
17:14:32 <kosmikus> at ICFP the winners will be announced
17:14:37 <Heffalump> Igloo and I think we could do much better if we had two more days :-)
17:14:48 <Igloo> Or another Heffalump and another Igloo
17:14:50 <mvw> hi folks,
17:15:08 <mvw> i was a one man team
17:15:22 <mvw> i just finished the simulator in the time
17:15:31 <kosmikus> Igloo, Heffalump: I'm sure you're not the only ones who think that ...
17:15:41 <mvw> now give me three more days to go for the real task :)
17:15:47 <Igloo> :-)
17:15:54 <Igloo> Yeah, we're definitely in demand
17:16:16 <kosmikus> so, any numbers to trade?
17:16:41 <mvw> how did you do it?
17:16:56 <kosmikus> I'm almost afraid to tell ;-)
17:17:01 <Strike> kosmikus: I'll give you a 7 for a 103
17:17:06 <Igloo> 126000 total ignoring the last 3 digits
17:17:09 <Igloo> So 130kish
17:17:16 <kosmikus> digits?
17:17:42 <Igloo> No, Heff's failing to add numbers up  :-)
17:17:44 <kosmikus> so you mean ~126000000?
17:17:48 <Igloo> 170kish
17:17:57 <kosmikus> okay
17:18:04 <Heffalump> hmm, no.
17:18:07 <kosmikus> ~85k
17:18:09 <Igloo> No, the total for all our maps is about 170000 steps
17:18:28 <kosmikus> rally in 35k
17:19:14 <Heffalump> 164036
17:19:15 <Heffalump> we suck.
17:19:16 <Igloo> What team were you in?
17:19:33 <kosmikus> me?
17:19:38 <Igloo> Yup
17:19:48 <kosmikus> with three other PhD students from UU
17:20:03 <kosmikus> "Dom"
17:20:22 <Heffalump> so how did you go about it?
17:20:29 <Heffalump> we made bezier patches and made something to follow them
17:20:39 <kosmikus> we wrote and editor and did all the courses manually ;-)
17:20:44 <kosmikus> s/and/an
17:21:19 <Igloo> Ah, well at least we were in the spirit, even if we did suck  :-)
17:21:21 <Heffalump> maybe we'll be one of the better automated teams...
17:21:29 <Heffalump> and maybe pigs fly
17:22:00 <kosmikus> we also wrote a post optimizer, but I think that gave us <500 in total
17:22:22 <cale> are there any other known Haskell using teams?
17:22:31 <kosmikus> what about shapr?
17:22:49 <Heffalump> how did it work?
17:22:56 <Heffalump> I was thinking about writing one, but could never decide quite how to do it
17:23:21 <mvw> i wonder what the real good approach would have been
17:23:55 <mvw> some strategy in pathfinding from robotics?
17:23:57 <kosmikus> very primitive -- just randomly modifying the instructions a bit
17:24:04 <kosmikus> (many times, of course)
17:24:28 <mvw> I had have loved to seen the physical information used
17:24:37 <mvw> that would lead to "optimal control"
17:24:43 <kosmikus> how did you write the "following" code?
17:24:48 <Heffalump> us?
17:24:52 <kosmikus> yes
17:24:55 <Heffalump> it's a little complicated
17:25:02 <mvw> but that is hard matrix optimization
17:25:04 <kosmikus> we thought about such a thing first
17:25:06 <Heffalump> essentially we kept a position on the Bezier patch we were following
17:25:17 <Heffalump> and tried to keep as close to the patch in both position and direction as we could
17:25:25 <Heffalump> but favouring acceleration over deceleration
17:25:26 <kosmikus> and speed?
17:25:38 <kosmikus> did you do lookahead?
17:25:40 <Heffalump> that we handled by calculating the maximum theoretical speed from the radius of curvature of the curve
17:25:42 <mvw> same like the robot that follows a painted track on the floor?
17:25:51 <Heffalump> and yes, we looked ahead to see how much we'd need to brake
17:26:21 <kosmikus> so why didn't it work well, then?
17:26:30 <Heffalump> I don't really know, to be honest
17:26:39 <kosmikus> how did you generate the Bezier patches?
17:26:40 <Heffalump> I never really checked the maths for the fastest speed
17:26:52 <Heffalump> from a list of line segments saying where we wanted to visit
17:27:00 <Igloo> It won't tend to brake in blocks before corners, for example
17:27:04 <Heffalump> we tried to generate those line segments automatically too, but that was a fiasco and cost us a lot of time
17:27:07 <Igloo> It all had to be a bit fuzzy and on the safe side
17:27:08 <kosmikus> that was manual input then?
17:27:20 <Heffalump> it wasn't meant to be, but it ended up being, yeah
17:27:37 <Igloo> Manually twekaed for all maps except 3 and 9 on which it failed for unknown reasons
17:27:44 <Heffalump> oh, yeah
17:27:48 <Igloo> (After having simplified 9 so it actually ran)
17:27:53 <kosmikus> have you heard numbers from other teams?
17:27:57 <mvw> kosikus: i had a nice trk <-> pnm converter and could draw bezier curves in the gimp with the bezier tool
17:28:08 <kosmikus> mvw: nice?
17:28:12 <kosmikus> s/?/!
17:28:32 <Heffalump> with more time, we'd be writing a bezier editor of our own
17:28:55 <Heffalump> so how exactly did you input your traces?
17:29:03 <Heffalump> or edit them or whatever
17:29:10 <kosmikus> is there any mathematical reasons (forgive me, I'm really bad at applied mathematics) to assume that Bezier curves are the right ones to use?
17:29:39 <mvw> a physical: only speed and accel matters (1st and 2nd order time derivative)
17:30:10 <mvw> i am not sure if a spline and a bezier curve are the same
17:30:11 <Heffalump> I don't think they were ideal, because (a) 3rd order bezier patches don't join up continuously in the 2nd derivative
17:30:22 <Heffalump> and (b) they don't cope with the fact that you can't turn while braking
17:30:30 <Heffalump> but they were the best idea we had
17:30:52 <Heffalump> I think we lost a lot of speed going in gentle curves when we could have been going in a straight line
17:31:18 <mvw> the exact solution to motion under friction like here is some exponential trajectory
17:32:01 <Heffalump> is it?
17:32:23 <Igloo> If you can turn while braking I think they might be good if you base them on the right sort of path
17:32:39 <mvw> if no breaking and acelel occurs for that time step
17:32:47 <mvw> so in reality is more complicated
17:33:09 <kosmikus> Heffalump, Igloo: did your approach work for the rally track as well?
17:33:31 <Igloo> No, it failed even when we set the speed to 50, but we decided not to care
17:33:48 <Heffalump> we could have fixed up the path by hand like we did with the others, but we preferred to use the time for other stuff
17:34:04 <kosmikus> the one who did that track spent 4(!) hours editing ...
17:35:08 <Heffalump> so you were literally editing the .trc files?
17:35:15 <kosmikus> no
17:35:44 <Heffalump> but something functionally equivalent, or something higher-level?
17:35:46 <kosmikus> basically, we decided that you can divide the trace into segments
17:36:09 <kosmikus> one segment is a tuple (Int,Pattern)
17:36:11 <mvw> so you defined subgoals manually
17:36:37 <kosmikus> a pattern can be something as simple as "go always left" or something more complicated
17:36:51 <Heffalump> ah, right
17:37:04 <kosmikus> we visualized these [(Int,Pattern)] things and edited those
17:37:23 <kosmikus> the model was implemented in the background to show different possibilities
17:37:31 <Heffalump> it annoys me that that approach could be more successful than actually writing a proper program :-)
17:37:32 <kosmikus> so you could pretty much locally optimize things
17:37:51 <kosmikus> :-)
17:37:56 <mvw> did you create segments = track building blocks like in a model train track?
17:37:56 <kosmikus> I can understand that
17:38:25 <kosmikus> mvw: I'm afraid I don't understand your question ...
17:38:43 <kosmikus> Heffalump: the first day we still believed in a "real" solution ...
17:39:04 <mvw> is a pattern a strategy or a sub trace (like a left arc, a stright short line, a right 45deg arc..)
17:39:07 <kosmikus> ... but after we just didn't make _any_ progress, we decided that we should make use of the "uniqueness" of this year's task description
17:39:40 <mvw> what was unique?
17:39:45 <kosmikus> a pattern is a function of type "Int -> [Command]", so it's not a strategy
17:40:17 <kosmikus> mvw: that your "program" just had to work for the given tracks
17:40:39 <kosmikus> in all the other years, you usually had to write a general optimizer and did not know for sure what is would be used on
17:40:45 <Heffalump> yeah.
17:40:48 <kosmikus> is -> it
17:40:53 <Heffalump> that would have been much better for us.
17:41:01 <mvw> so optimizing is a recurrent topic in icfp?
17:41:02 <Heffalump> We'd have spent more time fixing our automatic path generator
17:41:14 <kosmikus> mvw: unfortunately, yes ...
17:47:52 <mvw> guess i start preparing an optimizer lib for next year
17:49:50 <Igloo> :-)
17:50:23 * inkedmn is writing a python script to synchronize a site he's writing with the server it's being hosted on
17:53:09 <steveh> mmm python
18:18:58 <mvw> ok good nite
18:19:37 <clausen> gday Pseudonym
18:19:42 <Pseudonym> G'day.
18:20:24 <Pseudonym> Oh, I forgot to ask everyone.  How did the contest go?
18:24:24 * syntax-laptop needs a name for his distutils-like software in Haskell
18:24:54 <Pseudonym> distill
18:26:32 <syntax-laptop> not bad
18:26:46 <Pseudonym> Does it need an h in it?
18:27:07 <syntax-laptop> not really
18:27:14 * clausen finds /usr/dict/words useful ;)
18:27:24 <syntax-laptop> my GF suggested LIP Service (lip == Library Infrastructure Project), but then what would the module be called?
18:27:31 <Pseudonym> Oh, I know!
18:27:34 <Pseudonym> sadist
18:27:37 <syntax-laptop> hm
18:28:02 <syntax-laptop> can it have a sub-module called "Kinky"?
18:28:03 <Pseudonym> Probably not. :-)
18:28:21 <cale> Heh, it would be funny if a team that had hand driven the cars won. :) What would the judges say? "Hand-generated output is the programming tool of choice for discriminating hackers."?
18:28:32 <Pseudonym> You don't want to know what I thought of when you said "sub-module".
18:28:46 <syntax-laptop> Pseudonym: I don't know, do I? ;)
18:29:20 <syntax-laptop> LIP Service is good because it shows that its a part of LIP
18:29:34 * Pseudonym
18:29:36 <syntax-laptop> of course LipService.Sadist.Kinky would be a heck of a namespace
18:29:37 * Pseudonym nods, too
18:29:44 <Pseudonym> Yes, it would.
18:31:16 <Pseudonym> I'd actually make the namespace something meaningful.
18:31:26 <Pseudonym> Library.Distribution or something.
18:33:18 <syntax-laptop> thats a thought
18:33:41 <Pseudonym> What you call the product itself is a different question.
18:33:55 <Pseudonym> But if this is going to be "standard", IMO it should have a standard name.
18:35:24 <syntax-laptop> so Kinky is out altogether suddenly :(
18:35:34 <Pseudonym> You could still call it that. :-)
18:35:53 <syntax-laptop> hehe
18:36:30 <Pseudonym> Still, it's a good name for submissive... sorry, I mean "sub" modules.  Must think of a use for it some time.
18:36:52 * Pseudonym laughs
18:37:02 <Pseudonym> I found a failed assertion in some open source code I'm hacking up.
18:37:08 <syntax-laptop> hehe
18:37:19 <Pseudonym> The project maintainer said: Errrm nope, I didn't get this error, but I'm not running in debug mode, so I wouldn't see assertions.
18:37:27 <syntax-laptop> hehe
18:37:32 * Pseudonym isn't quite sure how to take that
18:37:32 <syntax-laptop> OK, I'll stop saying hehe now
18:37:50 <syntax-laptop> hm. I can think of a lot of rude replies
18:37:53 <Pseudonym> Yeah.
18:38:08 <Pseudonym> In the end, I said this: Cool!  If you turn of debug mode, the failed assertions go away!  Who'd have thought debugging was so easy?
18:38:20 <syntax-laptop> maybe he means that the error didn't otherwise manifest itself
18:38:25 * Pseudonym nods
18:38:26 <syntax-laptop> s/he/it
18:38:34 <Pseudonym> He, in this case.
18:38:37 <syntax-laptop> whe=w
18:38:53 * Pseudonym offered to track it down anyway
18:39:05 <Pseudonym> Since it's getting in the way of my feature.
18:41:09 <syntax-laptop> you should send him a patch to his command-line to turn on debugging :)
18:41:27 * Pseudonym LOL
18:42:10 <Pseudonym> s/--disable-debug/--enable-debug/
18:42:11 <Pseudonym> Simple patch.
18:45:52 <syntax-laptop> s/you/someone-who-knows-what-hes-doing
18:46:11 <syntax-laptop> (where you is him in this case, and maybe someone-who-knows-what-hes-doing is you)
18:46:16 <syntax-laptop> ;)
18:46:20 * Pseudonym laughs
18:46:21 <Pseudonym> No way.
18:46:41 <Pseudonym> Still, at least he actually put in assertions.
18:46:52 <Pseudonym> Credit where credit is due.
18:47:22 * syntax-laptop gets out of trash the random developer mode
18:47:24 <syntax-laptop> indeed
18:47:25 <syntax-laptop> :)
18:48:36 <Igloo> http://urchin.cipe/~ian/paths/ are the paths we took if anyone is interested. red == v = 0, white == v = 25k (or higher), linearly interpolated inbetween
18:50:28 * kosmikus takes a look at Igloo's paths
18:50:48 <kosmikus> is the URL correct?
18:50:52 <Igloo> Oh
18:50:56 <Igloo> Yes, but not useful to you  :-)
18:51:04 <Igloo> http://urchin.earth.li/~ian/paths/
18:51:38 <kosmikus> thanks
18:51:40 <Igloo> There are some obvious tweaks we could have done for probably significant improvement except for the man-hour constraint
18:53:10 <kosmikus> the paths don't look too bad -- the speed is probably too low
18:53:31 <Heffalump> we were trying to go at the maximum speed we thought we could
18:53:38 <Heffalump> and they tended to break when you tweaked it up much more
18:55:49 <kosmikus> ours are at http://www.cs.uu.nl/~eelco/icfppc2003/
18:56:18 <Igloo> They might not have broken if we'd only gone faster in some parts of the circuit though
18:56:24 <kosmikus> white dots are 100 steps, black dots 1000, colored dots 20
18:57:21 <Igloo> Mmm, your top left corner on 1 is much better than ours, which probably really helped you carry speed through the latter part of the circuit
19:00:06 <Igloo> Ah, you went around the top hump of the car? Interesting, I wondered about that, but again didn't have time to test
19:00:50 <kosmikus> yes, we figured that the turn at the end of the lower path would cost too much time
19:01:01 <Igloo> Oh, you didn't test it though?
19:01:06 <kosmikus> no
19:01:21 <Igloo> I knew we were taking a stupid route at the beginning of that map too  :-/
19:01:35 <kosmikus> Gothenburg is one of the only tracks where we tested several paths -- but actually not yours
19:02:11 <kosmikus> I think you lose a lot of time by turning in the beginning
19:02:19 <kosmikus> I am not sure though
19:02:26 <kosmikus> I will start up the editor again ;)
19:03:20 <Pseudonym> Was there a rule which said you had to go all the way around?
19:03:29 <Pseudonym> Or could you have done a u-turn?
19:03:39 <kosmikus> you must not hit the goal line from the right
19:03:44 <Pseudonym> Ah, OK.
19:03:50 <Pseudonym> Two u-turns, then.
19:03:59 <kosmikus> no, you must not hit it
19:04:03 <kosmikus> from the right
19:04:05 <Pseudonym> Ah, I see.
19:04:09 <kosmikus> it counts as a crash
19:04:12 <Pseudonym> Sorry . :-)
19:04:22 <kosmikus> no problem
19:04:26 <kosmikus> :)
19:06:20 <Igloo> kos: We thought about trying your path too, but time struck again. We thought it might not be too bad as you can turn sharply before you are going fast though.
19:15:19 <kosmikus> its not as easy as I thought to get the program running on my home notebook -- have to build some packages first ...
19:15:32 <Igloo> kos: Do you skid on the rally track?
19:15:42 <kosmikus> yes
19:16:49 <cale> http://vx.hn.org/autoshare/evil.trk
19:17:00 <Igloo> Have you got an image of it?
19:17:15 * kosmikus was about to ask the same question
19:17:20 <cale> http://vx.hn.org/autoshare/evil.png
19:18:35 <cale> it should be doable. (there is a path from the red dot to the blue goal line anyway)
19:18:41 <Igloo> If anyone has big images of the tracks in the gallery online then I'd be interested in seeing them
19:19:02 <kosmikus> I've thought about making the Feigenbaum fractal into a track (or a Nethack level, but that has been done by someone else)
19:20:05 <cale> This one maybe should have been included to test whether people were doing the things by hand.
19:20:48 <kosmikus> we would've succeeded anyway ;)
19:20:59 <Pseudonym> Do you have a plot of your solution?
19:21:19 <Heffalump> it'd have been cool if they'd produced tracks near the end of the time and given people x minutes to submit their solution to them
19:21:31 <Igloo> Does anyone know if the #haskell team managed to get a solution out in the end?
19:21:49 <Igloo> Except that biases it even more strongly in favour of people with fast machines
19:21:50 <cale> Pseudonym: were you referring to me? no, but if you use the gimp fill tool, you can convince yourself that one should exist.
19:22:17 <Pseudonym> Oh, I believe you.
19:22:25 * Pseudonym is just curious what it looks like
19:24:26 <cale> I suspect one could run a maze solving algorithm on it to find possible paths.
19:24:31 * kenikov dances for no particular reason
19:25:28 <Heffalump> igloo: true
19:26:01 <Pseudonym> In this case, some kind of A* search would probably be easiest.
19:27:47 <cale> The optimal solution would probably use quite a lot of tunnelling.
19:28:01 <Pseudonym> Oh, good idea.  Quantum cars.
19:28:10 <Igloo> Almost certainly
19:28:13 <Pseudonym> There is, after all, a finite probability that the car is already at the finish line.
19:29:24 <Heffalump> our technique really wouldn't cope well with the idea of tunnelling
19:29:27 <Igloo> If you had 9*7^10 computers handy it would be probably be quite an easy problem to solve
19:29:37 <Heffalump> anyway, you can only tunnel through corners, and that's not entirely tunnelling
20:16:56 <kunphuzil> is this correct for a slope intercept function? (y=mx+b)
20:16:57 <kunphuzil> slope x1 y1 x2 y2 = (y2 - y1) / (x2 - x1)
20:16:57 <kunphuzil> slopeint m x b = (m * x) + b
20:17:21 <kunphuzil> function slope isn't actually needed there, of course
20:27:51 <cale> yeah, that'll work, though I'd put the x parameter for slopeint last, as it is more variable then m and b.
20:28:11 <cale> s/then/than/
20:31:56 <kunphuzil> oh yeah, x is not really multiplied out right?
20:32:01 <kunphuzil> i am a little rusty as you can see
20:33:13 <cale> what you have is fine, it's just that if you put x last as in: slopeint m b x = (m * x) + b, then you can do something like myline = slopeint 3 2
20:34:34 <cale> (and myline becomes a function that returns the points on that line given their x coordinates)
20:35:09 <kunphuzil> hmm, i sort of get it.
20:35:50 <cale> you generally want to put the parameters that change the most at the end, so that you can use partial application as much as possible.
20:36:10 <kunphuzil> ok. well, what does myline do exactly?
20:36:34 <cale> myline 5 = (3 * 5) + 2
20:36:58 <kunphuzil> if i have myline = slopeint 3 2, and run it with the argument of 2, i get 8
20:37:03 <kunphuzil> not sure why tho
20:37:04 <kunphuzil> hmm
20:37:26 <kunphuzil> ah
20:38:05 <kunphuzil> so the argument to the myline function becomes the value of what x is?
20:38:47 <kunphuzil> useful indeed, i get it. 
20:38:52 <cale> yeah, you could have also written myline as: myline x = slopeint 3 2 x, but there's no need for the extra x's.
20:39:40 <kunphuzil> yeah, that is what confused me 
20:41:17 <cale> often you don't want to have to make a separate definition, as in, lets say you want to sample a line at a bunch of places...
20:41:57 <cale> you could write something like: map (slopeint 3 2) [0.0,0.1..1.0]
20:42:39 <kunphuzil> ah, cool
20:43:03 <kunphuzil> haskell is awesome ;)
20:44:02 <cale> yeah, it is :)
21:01:16 <kunphuzil> are functional languages good for ai? 
21:03:16 <cale> I'm not an AI person, but they should be. Lisp is/was apparently used extensively by AI researchers.
21:04:21 <kunphuzil> yeah
21:05:59 <Pseudonym> It depends what you mean by "AI".
21:06:17 <Pseudonym> I personally don't believe that AI is really a field.
21:06:28 <Pseudonym> It's more of a disjoint union.
21:07:35 <kunphuzil> heh
21:08:14 <Pseudonym> I do a good "complete history of AI".
21:08:17 <Pseudonym> It goes like this:
21:08:21 * Pseudonym ahems
21:08:27 <Pseudonym> Person A: "Doing task X requires intelligence."
21:08:46 <Pseudonym> Person B: *tap tap tap* Hey, I just wrote a program which does X!
21:08:49 <kenikov> Bah, I wouldn't say haskell is "awesome"
21:09:01 <Pseudonym> Person A: Hmm.  I guess it didn't require intelligence after all.  What about task Y?
21:09:09 <Pseudonym> Repeat, ad lib and fade.
21:10:15 <cale> kenikov: incredible? wonderful?
21:10:21 <Heffalump> Haskell is good at things like alpha-beta search :-)
21:10:31 <kenikov> cale: Satisfactory.
21:10:52 <kenikov> methinks Haskell is for rascalz
21:13:24 <Pseudonym> Haskell is a fine programming language for many tasks, according to the ICFP organisers.
21:13:29 <kunphuzil> You probably don't understand the concept of functional programming then
21:28:32 <kenikov> Yes Pseudonym, you don't understand the concept of functional programming.
21:29:01 <Pseudonym> Apparently.
21:31:57 <Pseudonym> What is the concept of functional programming, then?
21:32:16 <kenikov> Pseudonym: Google.com
21:32:30 <Heffalump> that's not a concept, it's a domain name
21:32:40 <Pseudonym> Hey, now I work in the text retrieval business, and I know for a fact that Google doesn't use Haskell.
21:32:43 <kenikov> Heffalump:  Google has become a verb.
21:32:53 <kenikov> I am hinting Pseudonym to do something.
21:33:01 <Pseudonym> What, get back to work?
21:33:09 <Pseudonym> Stop wasting time on IRC?
21:33:37 <Heffalump> you told him that he didn't understand something, surely it's incumbent on you to define what that thing is
21:33:48 <Pseudonym> Or at least give me a hint.
21:33:56 <Pseudonym> That isn't "go look it up yourself".
21:34:06 <kenikov> Heffalump: I don't have too.  A quick search on google would do so for you.
21:34:11 <Heffalump> especially when the topic is generally an amorphous and controversial one
21:34:19 * Pseudonym is also unsure exactly where he got it wrong
21:34:21 <kenikov> Heffalump: And I didn't, please don't get statements mixed up.  Kunphuzil did.
21:34:42 <Pseudonym> Hey, you're the one that directed it at me
21:34:47 <Heffalump> "[05:28] <kenikov> Yes Pseudonym, you don't understand the concept of functional programming"
21:34:53 <Pseudonym> Right.
21:34:55 <kenikov> I was simply agreeing with kunphuzil.
21:35:05 <Pseudonym> Well you must have some basis for this agreement.
21:35:12 <kenikov> Heffalump: Why are you directing this at me?  Who was my "yes" agreeing too?
21:35:15 <Heffalump> that presumably means that you formed an opinion as to what the concept is
21:35:33 <Heffalump> I don't think kunphuzil's statement was aimed at Pseudonym :-)
21:35:37 <kenikov> Heffalump: No, you are wrong.  I was simply agreeing to a statement.
21:35:50 <kenikov> Heffalump: You THINK!?  Or do you KNOW!?
21:36:13 <Pseudonym> I think Heffalump has a pretty good basis to assume that it wasn't directed at me.
21:36:14 <Heffalump> I *THINK* kunphuzil's statement was aimed at you. I *THINK* you are a troll.
21:36:30 <kenikov> You can THINK all you want, THINKING about a statement wont' convince me unless you KNOW
21:36:39 <seth_> Well, I just read the last 30 lines and I have no idea what ANYONE is talking about.  :)
21:36:44 <kenikov> Heffalump: No, you accusing me of being one is making you look trollish.
21:36:47 <Pseudonym> seth_: I'm with you.
21:37:03 <Pseudonym> OK, calm down everyone.
21:37:04 * Heffalump sorts things out by /ignoring kenikov
21:37:30 <kenikov> OOh, so first you target and mix-up my statements, then you insult me?>
21:37:31 <Pseudonym> kenikov: Why did you think that kunphuzil's statement was directed at me?
21:37:32 <seth_> But I do know that both Heffalump and Pseudonym know a lot about functional programming.
21:37:35 <kenikov> And you are not the troll Heffalump?
21:37:52 <kenikov> Pseudonym: It had no name directing it at me, and it came RIGHT AFTER your statement.
21:38:08 <kenikov> seth_: Would you bet your life on it ;) ?
21:38:32 <seth_> kenikov: actually, yes, as it happens.  If necessary.
21:38:35 <kenikov> Heffalump: Insulting, mixing up someone's statements with mine then ignoring me doesn't make you look "innocent"
21:38:46 <seth_> Why don't we get back to talking about haskell, or something remotely related to it?
21:39:01 <Pseudonym> kenikov: That could be explained adequately by lag.
21:39:02 <kenikov> Okay.
21:39:07 * Heffalump suggests the concept of functional programming :-)
21:39:25 <Pseudonym> I'm not saying who kunphuzil was talking about.  I don't know.  I wasn't really following.
21:39:30 <Pseudonym> But I don't think it was directed at me.
21:39:38 <Heffalump> though actually I should go to bed and try not to have nightmares about how crap our ICFP entry was :-)
21:39:39 <kenikov> Hmmm...he will probably deny it now.
21:40:11 <Pseudonym> Heffalump: That sounds like some bad projection you have there.
21:40:23 <Heffalump> Pseudonym: sorry?
21:40:33 <Pseudonym> Unhealthy emotional investment in your quick 'n dirty code.
21:40:36 <Heffalump> ah :-)
21:40:48 <Heffalump> you have to get fairly involved for the 72 hours it's running
21:40:53 <Heffalump> I was only joking about the nightmares, though
21:41:09 <Pseudonym> I was just joking about the emotional disorders, too. :-)
21:41:17 <kenikov> Pseudonym: You must be very confident on your definition of Functional Programming then
21:41:36 <Pseudonym> I don't think I've given a definition today.
21:41:49 <Pseudonym> But I am pretty confident about it, yes.
21:41:52 <Heffalump> what did you mean by "projection"?
21:41:54 <Heffalump> Oh, I think I see.
21:42:20 <Pseudonym> Yes, I say "projection" and everyone around here thinks "accessor function".
21:42:31 <Heffalump> anyway, I'll have you know that my code was very elegant
21:42:32 <kunphuzil> Gah, my statement was directed toward kenikov 
21:42:38 * Pseudonym hasn't seen it
21:42:44 <kenikov> See, I told you lines before that he would deny it.
21:42:47 <Heffalump> I'd be worried if you had.
21:42:48 <kunphuzil> kenikov is a troll. he always is looking for a debate
21:43:14 <kenikov> About...20 lines up I said he would deny his statements.
21:43:19 <Pseudonym> Because you'd wonder how I managed to hack into your CVS machine?
21:43:24 <Heffalump> well, I suppose Igloo might have shown it to you, but it seems unlikely, and the only other route would be via hacking our CV^U bah :-)
21:43:26 <kunphuzil> That is just stupid kenikov. 
21:43:33 * Pseudonym laughs!
21:43:37 <kenikov> No, that is just my smart prognostication.
21:43:42 <Heffalump> oh, or our other team members, but you don't know them
21:43:59 <kunphuzil> Oh yeah.. I forgot about the ICFP, do they know the winners yet?
21:44:07 <Pseudonym> I have access to all of last year's code, though!
21:44:08 <kenikov> and my knowledge of kunphuzil's psychology on IRC.
21:44:10 <Heffalump> we only finished 5 hours ago!
21:44:10 * Pseudonym laughs evilly
21:44:17 <kunphuzil> Heffalump: oh, heh
21:44:22 <Pseudonym> The results won't be out for weeks.
21:44:30 <Heffalump> I can tell you that we didn't win, though :-)
21:44:36 <kunphuzil> Oh.. I thought it only took a feew days, must have misread the doc
21:44:41 <Heffalump> well, unless we get the Judge's prize for an unholy mix of languages.
21:44:43 <Pseudonym> Well obviously.  Nobody's won yet.
21:44:49 <Pseudonym> Heffalump: What mix?
21:44:58 <Heffalump> 25th July is winner notification, but I think announcement is only at ICFP
21:45:03 * Pseudonym nods
21:45:21 <Heffalump> Haskell, SML, C for the main code, Java, Perl and vi scripts for the visualisation
21:45:39 <Pseudonym> That's not unholy.
21:45:55 <Pseudonym> Mix in some APL, Forth and malbolge.  Now that's unholy.
21:45:56 <Heffalump> the SML generated a C file that was linked in with some other C, that was then run to produce input for the Haskell
21:46:01 <kunphuzil> I didn't know you could use a mix of langs
21:46:09 <Heffalump> you can use whatever you like
21:46:10 <Pseudonym> You could this year.
21:46:16 <kunphuzil> interesting
21:46:22 <Heffalump> this year you didn't even have to send them a binary, so it was even easier to do what you wanted
21:46:40 <Heffalump> normally you have to keep things sane enough that they can actually run it without a complex tool chain
21:47:27 <Heffalump> it was a shame they did it that way, though, since it seems as if hand-crafted solutions have been beating "properly" generated ones hands down
21:47:46 <Heffalump> though I dunno what the Dylan lot did (mentioned some hours ago as having a very good entry)
21:47:59 <Pseudonym> Was there a time limit?
21:48:05 <Pseudonym> Run-time, that is.
21:48:15 <Heffalump> nope.
21:48:22 <Heffalump> all run at client-side and results submitted
21:48:33 <Heffalump> for pre-provided maps, so you could hack it all manually
21:48:37 <dennisb> but even handcrafted solutions needed computer support, but yes, it would be more fun if a program made the whole thing
21:50:07 <Pseudonym> So it was actually more of a problem-solving contest than a programming contest.
21:50:12 <Heffalump> dennisb: sure, but kosmikus said someone spent 4 hours hacking a solution for the rally map
21:50:21 <kunphuzil> You mean you could create an entry that had no "AI" i guess, only worked on a specific map?
21:50:28 <Heffalump> kunphuzil: precisely
21:50:49 <kunphuzil> Aww, that doesn't seem .. right.
21:50:51 <dennisb> I can imagine a program where you define a number of point you should visit to make the "search" faster, although you have to make sure you don't restrict the computer to much so you get a bad solution
21:50:52 <arguile> If you had enough power behind you, you could try every possibility
21:51:13 <dennisb> arguile: if you had enough power you could solve chess as well
21:51:32 <arguile> Heh, I was commenting on how open ended it was :)
21:51:38 <Pseudonym> It seems to me that an appropriate approach is to pick a route by hand and then get the computer to do some kind of constraint satisfaction problem to refine the route.
21:51:55 <arguile> Brute force wasn't exactly a pratical solution =P
21:52:02 <Heffalump> I'd hoped to try to refine the route, but we ran out of time
21:52:15 <Heffalump> getting it to follow the route took enough of our time
21:52:16 <Pseudonym> What approach did you use, then?
21:52:19 * Pseudonym nods
21:52:23 <Heffalump> (as did generating the route in the first place)
21:52:38 <Heffalump> compute the polygons of the obstacles
21:52:44 <Heffalump> make a visibility graph from those polygons
21:52:56 <Heffalump> apply Dijkstra's algorithm to find a straight line route
21:53:08 <Heffalump> apply a bezier-patch fitting algorithm to find a smooth route
21:53:39 <dennisb> and then you run it through your vi-script?
21:53:44 <Heffalump> calculate the maximum velocity for each segment (fractions of a bezier patch) based on the radius of curvature of that segment
21:53:50 <o3> arguile: s/chess/go/
21:53:53 <Heffalump> the vi script was for turning .trk files into .ppm :-)
21:54:13 <kunphuzil> What is the game go?
21:54:16 <Heffalump> back-propagate maximum velocities based on how fast the car could brake
21:54:56 <dennisb> you had a busy weekend
21:55:01 <Heffalump> drive round the track, keeping close to the curve found and keeping under the maximum velocity, whilst going as fast as possible and backtracking if you get too far away from the track
21:55:04 <o3> kunphuzil: google for 'go game', enjoy
21:55:24 <Heffalump> the visibility graph, Dijsktra's algorithm on that and the bezier-patch fitting came from a library we found on the net
21:55:48 <arguile> kunphuzil: The one where opponents put down black and white pieces on a rectangular grid board, putting your piece down flips all enemy pieces to your colour
21:55:58 <Heffalump> unfortunately we had some problems making it work well, so we ended up completely hand generating the straight lines for two maps, and tweaking most of the others to various extents
21:56:03 <arguile> s/all/all adjacent/
21:56:27 * Pseudonym nods
21:56:34 <kunphuzil> arguile: hmm. i think i might have played a game like it
21:56:34 <Heffalump> the biggest problem we had with the "driving" aspect was keeping enough control to avoid huge amounts of backtracking
21:58:15 <Heffalump> we also had a perl script that overlayed the bezier patches or the dump file from the simulator onto a track, for visualisation purposes
21:58:42 <Heffalump> and a Java program for when we needed to zoom and pan around the trace on the track to look carefully at details
21:58:55 <Heffalump> </brain dump> :-)
21:58:58 <kunphuzil> heh
21:59:01 <kunphuzil> sounds cool
21:59:08 <o3> Heffalump: is this for ICFP?
21:59:11 <kunphuzil> sounds like a lot of work too
21:59:11 <Heffalump> yeah
21:59:27 <Heffalump> it was fun, but quite frustrating especially when we were making no progress with generating the path
22:00:08 <Heffalump> oh, and my belief in "trace" as a debugging aid is now unshakeable
22:02:38 * Heffalump goes to bed
22:03:17 <kunphuzil> bye
22:08:04 <Pseudonym> Night.
22:09:33 <Pseudonym> Anyone here know how to read MIPS assembler?
22:12:05 <dennisb> Pseudonym: I knew 6-7 years ago
22:13:08 <dennisb> But I don't remember much, I just mapped my other assmebler knowlege onto mips back then
22:14:50 * Pseudonym nods
22:14:59 <Pseudonym> Just got a bit to reverse-engineer. :-/
22:15:47 <Pseudonym> It's only about 60 lines, so it should be straightforward.
22:16:17 <Pseudonym> It's really Sparc assembler without the delay slots and without the register stack, pretty much.
22:21:06 <dennisb> I just remeber it to be very easy, no really strange things if you compare with x86
22:22:02 <dennisb> maybe I can read it, I don't know
22:22:55 <Pseudonym> If I have trouble, I'll ask you. :-)
22:23:06 <Pseudonym> .s means short, right?
22:23:19 <Pseudonym> So, for example, sub.s$f8,$f4,$f6
22:23:27 <Pseudonym> that's single precision floats?
22:23:34 <Pseudonym> sub.s $f8,$f4,$f6
22:27:19 <dennisb> see, that was already a diffcult question :-)
22:27:27 <dennisb> But I think you are right
22:31:18 <Pseudonym> It also depends on the notation.
22:31:27 <Pseudonym> Some assemblers may be different, I guess.
22:42:31 <kunphuzil> How can i write a function that shows the usage if no variables are entered?
22:44:03 <Pseudonym> Hmmm?
22:44:10 * Pseudonym doesn't understand the question
22:44:25 <kunphuzil> Erm, example:
22:44:30 <kunphuzil> slopeint m b x = (m * x) + b
22:44:40 <kunphuzil> what if they just enter slopeint, no args,
22:44:55 <kunphuzil> how do i get it to not give an error and put the usage of the function?
22:45:14 <kunphuzil> something like if you run a program in a terminal with no options
22:45:22 <Pseudonym> It's not like that.
22:45:25 <dennisb> kunphuzil: you can't
22:45:29 <kunphuzil> oh ok
22:45:30 <Pseudonym> slopeint on its own is a perfectly valid value.
22:45:38 <Pseudonym> It means something.
22:45:57 <Pseudonym> And it has a type, too.
22:46:12 <arguile> Specifically it returns a function of type Int -> Int -> Int (guessing types)
22:46:15 <dennisb> I assume you use ghci or hugs, then you can do :t slopeint
22:46:36 <kunphuzil> slopeint :: Num a => a -> a -> a -> a
22:46:46 <kunphuzil> i see what you mean
22:46:53 <dennisb> so, there you have the usage info, it takes 3 nums and gives a num
22:47:28 <kunphuzil> how do you get that? (that is correct, but they are all a's ..)
22:47:50 <Pseudonym> slopeint, as you wrote it, works for any number.
22:48:27 <dennisb> the first part (Num a =>)says that a is any type as long as it's a number (actually, as long as it's in the class Num)
22:48:39 <kunphuzil> dennisb: ok
22:49:07 <dennisb> a is a type variable, that stands for a type like Int, Float
22:50:02 <dennisb> and the haskell system know it's a Num since you used + and * in your function
22:52:45 <kunphuzil> how do i differentiate between what it returns and what i put in? (in something like slopeint :: Num a => a -> a -> a -> a) ?
22:53:55 <Pseudonym> Ah, that's an interesting question.
22:54:01 <Pseudonym> -> associates to the right
22:54:09 <Pseudonym> So in fact this can be read as:
22:54:25 <Pseudonym> slopeint :: (Num a) => a -> (a -> (a -> a))
22:54:53 <Pseudonym> So if you supply one argument to slopeint, say, slopeint m
22:55:03 <Pseudonym> Then you get: a -> (a -> a)
22:55:08 <Pseudonym> If you supply another, you get a -> a
22:55:14 <Pseudonym> And if you supply three, you get a.
22:55:23 <dennisb> kunphuzil: you do know what -> is?
22:55:28 <kunphuzil> oh, i see
22:56:20 <kunphuzil> dennisb: well, not really. i just knew it kind of meant passing results onto the next thing ..
22:56:29 <Pseudonym> Right.
22:56:37 <Pseudonym> You see, a itself might be a function.
22:56:38 <dennisb> yes, it's a function
22:56:59 <dennisb> a -> b, is a function from a to b, it takes an a as input and returns a b
22:57:01 <Pseudonym> So you may actually need to supply more than three arguments before you get an answer.
22:57:19 <dennisb> yes, a and b can be anything, including functions
22:57:37 <kunphuzil> Oh, that is why this works:
22:57:44 <kunphuzil> myline = slopeint 3 2
22:57:49 <Pseudonym> Yes.
22:57:50 <kunphuzil> for example 
22:57:51 <dennisb> yes
22:59:23 <kunphuzil> How would one go about writing a function to rewrite an equation in a new form? I was trying to think of a way to make a standard form equation into slope intercept
22:59:50 <Pseudonym> The simplest approach is to come up with some representation for equations.
22:59:51 <dennisb> you need to represent equations first
23:00:33 <kunphuzil> ?
23:00:42 <dennisb> a datatype for Equations so you can work with it.
23:00:59 <dennisb> you can not manipulate haskell formulas like that
23:01:46 <dennisb> you should look at datatypes and how you define your own
23:02:03 <kunphuzil> hmm
23:02:14 <arguile> kunphuzil: Do you have access to "Haskell: The Craft of Functional Programming"?
23:02:17 <dennisb> so you can then write functions of the type: simplify :: Equation -> Equation
23:02:55 <kunphuzil> arguile: not sure
23:03:13 <kunphuzil> don't think there are haskell/functional programming books in my lib.
23:03:17 <kunphuzil> all imperative :/
23:05:42 <dennisb> well. if you want to write it in say C you would probably create a: struct Equation { ... how it is represented ... };
23:06:04 <dennisb> and then functions that takes Equations as input and so on, you do the same in haskell
23:06:05 <kunphuzil> no C for me :P 
23:06:19 <dennisb> what other language should we take?
23:06:27 <kunphuzil> huh?
23:06:39 <dennisb> or maybe we shouldn't confuse it by talking about related things in other languages
23:06:42 <Pseudonym> Here's an example:
23:06:44 <Pseudonym> http://haskell.org/hawiki/FactoryFunction
23:06:53 <Pseudonym> Just look at the data type up the top.
23:07:00 <Pseudonym> Damn, should remove the bird tracks.  Hang on.
23:07:49 <Pseudonym> OK, fixed.
23:09:35 <kunphuzil> yeah, what are those anyway?
23:09:41 <kunphuzil> seen them on other pages of the wiki
23:09:45 <Pseudonym> They're for literate scripts.
23:09:56 <Pseudonym> We used to use them to satisfy the old wiki.
23:10:01 <kunphuzil> oh
23:10:18 <Pseudonym> But they're actually valid Haskell, if you're using literate scripts.
23:10:18 <kunphuzil> well, i am going to sleep. i'll check this out when i am not so tired
23:10:27 <kunphuzil> what is literate scripts?
23:10:33 <Pseudonym> OK, cool.  Look through that page, and if you have any questions, you know where we are.
23:11:03 <Pseudonym> OK, in conventional programming, you normally write code and put special marks around comments.
23:11:07 <dennisb> there are two ways to write haskell programs, either you have a file with code and then when you write a comment you mark it with {- and -}, or you have you comments and you mark all lines with code with > in the beginning. 
23:11:10 <Pseudonym> Like /* */ in C
23:11:32 <Pseudonym> Right.  In Haskell, you can write documentation normally and specially mark code.
23:11:48 <dennisb> everything is a comment except if it starts with >
23:11:49 <Pseudonym> If you want to.
23:12:02 <kunphuzil> oh, cool
23:12:06 <kunphuzil> didn't know that
23:12:10 <Pseudonym> Some people have written academic papers this way.
23:12:25 <Pseudonym> The LaTeX source to print the paper and the program are one and the same.
23:12:28 <kunphuzil> Oh I see.. Then someone else can just run the paper as a program
23:12:33 <Pseudonym> Right.
23:12:38 <kunphuzil> That is interesting
23:13:15 <Pseudonym> It's not used so much because a) people don't like writing lots of comments, and b) it's not real literate programming. :-)
23:13:25 <kunphuzil> Heh
23:13:27 <Pseudonym> But that's another topic.
23:13:38 <kunphuzil> Well, thanks for you all your help! Haskell gets better each day ;)
