03:25:58 <ecraven> c
03:26:02 <ecraven> parden
03:26:08 <ecraven> s/e/o/1
04:48:10 <shapr> good morning!
04:48:19 <harsha123> hi shapr 
04:48:40 <shapr> hello harsha123 
04:49:21 <shapr> how's code?
04:59:16 <harsha123> shapr: do you have sicp-html.tar.gz?  do you have it on your disk?
05:04:31 <shapr> no, but I can download it.
05:04:46 <shapr> I *do* have several of the SICP lectures in RealMedia format
05:05:27 <shapr> 6474 megabytes of SICP lectures
05:05:29 <shapr> hello dak 
05:06:45 <dak> hello~
05:07:07 <shapr> do you want to learn Haskell?
05:07:13 <dak> yes 
05:07:28 <shapr> have you see http://www.haskell.org/learning.html ?
05:07:35 <dak> ^^
05:07:37 <dak> ok
05:07:59 <harsha123> shapr: i was doing a wget -r
05:08:08 <harsha123> on the link.
05:08:22 <shapr> harsha123: I think there's a zip file or something
05:08:56 <shapr> oh, it's not there
05:09:00 <shapr> hmm, there was a zip file
05:09:00 <harsha123> shapr: didnt find it though
05:10:20 <emu> how about paskell
05:10:40 <shapr> emu: you mean Paskelle?
05:10:48 <shapr> er, Paskalle?
05:11:03 <emu> Pasqualle
05:12:08 <shapr> I really want to release some anti-spam software named Paskalle
05:12:24 <shapr> since Paskalle is lovely finnish word
05:12:43 <Lor> Ahem.
05:13:05 * shapr grins slighly embarassedly
05:13:28 <shapr> Lor: how would you translate it?
05:14:25 <shapr> hello again dak
05:14:59 <dak> hello shapr~
05:15:39 <shapr> would you like to see a short demo file of Haskell source?
05:15:40 <Lor> Well, it depends on the context.
05:16:19 <shapr> it has multiple interpretations?
05:16:48 <Lor> All Finnish declinations have multiple interpretations. Just like all English prefixes do.
05:16:58 <dak> sharp :ok~ recommand me
05:17:01 <shapr> the way I understood it, paska is shit, and the lle ending means 'out of'
05:17:20 <Lor> No, that would be "paskasta".
05:17:39 <Lor> "-lle" is the allative suffix.
05:18:01 <Lor> Literally taken, it means "to on top of", but it also means "for" in many ways.
05:18:04 <shapr> http://kungens.kemi.fi/~shae/src/haskell/Demo.hs
05:18:20 <shapr> hm, that kills the humor of the word
05:18:30 <shapr> I thought it meant "to take the shit out of something"
05:18:46 <Lor> There's no single word for that.
05:18:50 <shapr> so it could be a cheesy way to say "to remove the spam from something"
05:18:58 <Lor> Then you would have the "-sta" suffix on the something.
05:19:10 <shapr> so, paskallesta ?
05:19:16 <Lor> No.
05:19:22 <shapr> paskastalle?
05:19:32 <Lor> No, those are different declinations, you can't combine them.
05:19:36 <shapr> oh
05:19:50 <Lor> "to take the shit out of something" would literally be "ottaa paska pois jostain"
05:19:52 <shapr> maybe I should try this again when I've started finnish classes.
05:20:30 <shapr> dak: see how this looks http://kungens.kemi.fi/~shae/src/haskell/Demo.hs
05:20:43 <Lor> But "paskalle" is kind of nice because after all, the spam filter is meant _for_ the shit, to deal with it.
05:21:20 <shapr> yah, and I like the askall and pascal references in the word also
05:22:27 <shapr> so Pasakalle could be interpreted as "for the shit" ?
05:22:43 <Lor> Approximately, yeah.
05:22:51 <Lor> It's not very natural as a standalone word, though.
05:23:18 <shapr> well, it's an attempt at a cheesy humorous name by a non-finnish speaker so...
05:24:59 <shapr> finnish is a cool language.
05:25:45 <shapr> anyways, has anyone used the doCon software that Peti is talking about on the mailing list?
05:27:23 <shapr> looks like a turku router just died.
05:31:09 <dak> shapr: ^^ thx good example, haskell is similar to sml ^^;
05:31:26 <shapr> yes, they are similar.
05:31:56 <shapr> I've heard that typeclasses and lazy evaluation are the two largest differences.
05:32:33 <shapr> I've been reading the ll1 mailing list
05:32:50 <shapr> it seems that people who have not actually used Haskell are wildly misinformed about it.
05:33:31 <shapr> I think I should apply this to myself, I shouldn't have any opinion about C++, COBOL, APL, or any language I haven't used much.
05:34:26 <dak> ll1 mailing list?
05:35:17 <shapr> http://ll1.ai.mit.edu/
05:35:57 <shapr> even though ll3 has happened, the ll1 mailing list is the one they all use.
05:38:22 <TripleDES> hi
05:46:57 <shapr> hello TripleDES 
05:46:58 <shapr> bonjour Lunar^ 
06:02:26 <gim> shapr: How can I use haskell in Windows environment more familiar?
06:03:17 <gim> It seems gee hugs in cygwin. giving me less comfort.
06:04:49 <gim> Even Haskell researchers are in MSR, there is no pretty solution not yet (I guess). :-(
06:05:20 <gim> (wow! what a humble my English syntax!)
06:06:47 <harsha123> shapr: is there any way to lock a emacs file that i am editing? something like the *escape mode* in vi ?
06:07:17 <harsha123> someway to stop further keystrokes until i want it..
06:07:29 <SyntaxNinja> harsha123: M-x toggle-read-only
06:10:57 <SyntaxNinja> brb
06:11:11 <harsha123> dfk
06:11:32 <shapr> gim: hugs and GHC run on win32, though I have not tried them on win32
06:11:44 <gim> wow, it is?
06:13:49 <shapr> this lists windows --> http://www.haskell.org/ghc/download_ghc_62.html
06:14:13 <shapr> this als has windows --> http://cvs.haskell.org/Hugs/pages/downloading.htm
06:20:03 <shapr> does anyone know if there's a later version of hbc than 0.9999.4 ?
06:33:09 <shapr> I think this is worth reading --> http://www.shirky.com/writings/riaa_encryption.html
07:08:56 <shapr> hej Marvin-- 
07:23:10 <phubuh> hej hej
07:23:28 <SyntaxNinja> hi phubuh
07:28:13 <phubuh> hello my totally awesome friend!  flipped out and kicked any ass lately?
07:30:24 <SyntaxNinja> phubuh: be very careful how you ask such questions!!
07:30:39 * phubuh hides
07:31:25 <SyntaxNinja> yesterday I heard a quiet sound in my office, flipped out, hid in the ceiling for 3 hours before finally killing my victim (which was a mouse, but it was worth it).
07:35:31 <phubuh> whoa
07:36:23 <phubuh> hmm, if I hook my phone line into my modem, could I do nifty stuff like talking and seeing who's calling, etc?
07:38:21 <SyntaxNinja> phubuh: yes. if you have the software.
07:38:26 <SyntaxNinja> and if your modem does caller ID
07:38:37 <SyntaxNinja> at least, that's what I seem to remember from 6 years ago when I last touched a modem ;)
07:38:50 <phubuh> oh, cool.  I hope there's good Linux software
07:46:07 <phubuh> wxDialer seems nice
07:46:25 <phubuh> now to get my internal modem working...
07:49:41 <phubuh> what the hell, dchub's configuration file is in some binary format
07:52:00 <phubuh> eh, the developer seems rather ... well, out of his mind:
07:52:01 <phubuh> dchub starts to have a lot of configuration files having a static structure. Each time new features must be added, either a new key is added to an existing file (if it can fit) or a new configuration file must be created. Replacing the current configuration files by a SQL database solve most of these problems.
07:53:17 <phubuh> I'm considering writing a Direct Connect hub in Erlang
08:00:04 <shapr> go forth and code!
08:00:06 <shapr> code is good
08:02:21 <Lor> forth is good, too.
08:05:08 <SyntaxNinja> so is Go :)
08:08:18 <Lor> Yes.
08:12:27 <Marvin--> hello guys
08:13:31 <shapr> hello Marvin-- 
08:13:35 <stepcut> hello
08:13:39 <shapr> hi stepcut 
08:13:55 <shapr> what's going on in the world of functional programming?
08:14:21 <stepcut> my port of haskellDB to ghc is finally making some good progress
08:14:43 <shapr> w00!
08:14:48 <shapr> do you have the sources online?
08:14:54 <shapr> how'd you beat the trex problem?
08:15:00 <shapr> nested tuples?
08:15:06 <stepcut> template haskell
08:15:11 <shapr> ohh
08:15:29 <stepcut> I have not fully solved the problem yet -- but things are looking favorable at the momemnt
08:16:20 <shapr> is the source online?
08:16:26 <stepcut> not yet
08:16:32 <shapr> can I get a copy?
08:16:34 * shapr begs
08:16:49 <stepcut> well, the exciting stuff has not happened yet
08:17:19 <stepcut> but I aim to "finish" it this year
08:17:35 <shapr> as in, before the new year?
08:17:39 <stepcut> yes
08:17:41 <shapr> yay
08:17:52 <shapr> I'd very much like to switch the database code in lambdabot to HaskellDB
08:17:58 <stepcut> I am on 'vacation' for the next two weeks
08:18:08 <stepcut> I would very much like to switch my code from hugs to ghc
08:18:15 <det> shapr: are you still doing mail stuff in haskell ?
08:18:40 <shapr> det: yup
08:18:51 <det> shapr: you should write an IMAP4 server ..
08:18:57 <shapr> why?
08:19:03 <det> shapr: dash mocks static typing
08:19:08 <stepcut> My database server only has 128 megs of ram, and simple cgi programs in hugs can easily consume 80megs -- the swapping is ferocious
08:19:18 <det> shapr: "show me a IMAP4 server written in a static language"
08:19:32 <shapr> det: er, what's so challenging about IMAP4?
08:19:37 <lambdabot> Yeah! Stick it to him shapr!
08:20:10 <det> shapr: I dunno, apparently it is hard to write, and therefor cant be done with static type systems!
08:20:17 <shapr> hm
08:20:28 <lambdabot> You show him shapr! STICK IT TO THE MAN
08:20:50 <shapr> I'll be happy when my pop3 server works
08:20:55 <det> :)
08:21:13 <shapr> seriously though, what's so hugely different between a pop3 and an imap4 server?
08:21:21 <det> I have no idea
08:21:27 <shapr> I think some parts of imap4 will be *easier* in Haskell than in some other language
08:21:54 <stepcut> besides, ghc has dynamics now :p
08:22:14 <det> stepcut: when will you fools learn! GHC != Haskell!
08:23:34 <shapr> at least, that's what they claimed at the most recent ICFP
08:23:40 <lambdabot> you tell him det!
08:23:46 <shapr> someone really did complain that Haskell should not equal GHC
08:23:54 <shapr> personally, I always use GHC
08:23:59 <shapr> why shouldn't I?
08:24:10 <stepcut> shapr: maybe you really like trex?
08:24:36 * lambdabot hugs shapr
08:24:44 <shapr> well, HaskellDB is almost a good enough reason to use Hugs
08:24:51 <shapr> lambdabot: dude, you're written in GHC, don't complain.
08:24:51 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
08:24:54 * lambdabot doesnt ghc shapr
08:25:12 <shapr> lambdabot: in fact, you're GHC-specific, and about to get more so
08:25:12 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
08:25:19 <shapr> hei musasabi 
08:26:01 <musasabi> hello
08:26:05 <stepcut> There is certainly merit to GHC != haskell, but if you run an IMAP4 server in hugs your crazy :p
08:26:18 <stepcut> of course, there are other options like nhc and whatnot
08:26:22 <stepcut> ohaskell
08:26:30 <det> isnt nhc like
08:26:34 <shapr> I thought O'Haskell requires Hugs?
08:26:35 <det> 3 years out of update
08:26:44 <shapr> nhc was designed to be easy to port
08:26:59 <shapr> there is a current project to get NHC98 running on PalmOS
08:27:05 <stepcut> sweet!
08:27:17 <shapr> supposedly it works, but not well enough for them to release it.
08:28:28 <stepcut> shapr: I have to catch my flight. I will send you something when I have something to send. Right now I just have a bunch of files name test.hs test2.hs with various bits of template haskell splattered in them
08:28:32 <SyntaxNinja> so um. lambdabot has a personality now?
08:28:50 <shapr> stepcut: sounds great, I'm looking forward to using it :-)
08:28:54 <lambdabot> SyntaxNinja: @yow
08:29:05 <SyntaxNinja> @yow
08:29:06 <lambdabot> HERE!!  Put THIS on!!  I'm in CHARGE!!
08:29:09 <stepcut> me too!
08:29:10 <SyntaxNinja> oh
08:29:26 <shapr> SyntaxNinja: of course, the debugging output shows me who's really pulling botstrings...
08:29:46 <SyntaxNinja> so what, you can message him and he says stuff?
08:29:57 <lambdabot> HER
08:30:12 <SyntaxNinja> @help
08:30:13 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
08:30:17 <SyntaxNinja> @listcommands
08:30:18 <lambdabot> I react to the following commands: ["all-dicts","arr","define","definitions","del-definition","devils","dict","dict-help","dummy","dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements","eval","foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","lojban","more","msg","part","prelude","quit","reconne
08:30:31 <shapr> SyntaxNinja: @eval "\CRPRIVMSG #haskell foo"
08:30:44 <lambdabot> :foo
08:30:48 <SyntaxNinja> @eval "\CRPRIVMSG #haskell foo"
08:30:49 <lambdabot> foo
08:31:06 <shapr> aka, I need to start escaping output from plugins
08:31:26 <lambdabot> then how will det have his fun?
08:31:54 <shapr> you'll have to write an IMAP4 server in your favorite functional language :-P
08:32:09 * stepcut goes on vacation
08:33:30 * lambdabot takes a byte out of crime
08:33:44 <lambdabot> Look! I made a rime!
08:34:11 <lambdabot> (rhyme), hehehe I am such a clever bot!
08:37:52 <lambdabot> I
08:42:18 <shapr> so, let's see how lambdabot likes GHC 6.2
08:59:37 <SyntaxNinja> @jargon foobar
08:59:39 <lambdabot> *** "foobar" jargon "Jargon File (4.3.0, 30 APR 2001)"
08:59:39 <lambdabot> foobar n. [very common] Another widely used {metasyntactic variable};
08:59:39 <lambdabot>    see {foo} for etymology. Probably originally propagated through
08:59:39 <lambdabot>    DECsystem manuals by Digital Equipment Corporation ({DEC}) in 1960s and
08:59:40 <lambdabot>    early 1970s; confirmed sightings there go back to 1972. Hackers do _not_
08:59:42 <lambdabot>    generally use this to mean {FUBAR} in either the slang or jargon sense.
08:59:44 <lambdabot>    See also {Fred Foobar}. In RFC1639, "FOOBAR" was made an abbreviation
08:59:46 <lambdabot>    for "FTP Operation Over Big Address Records", but this was an obvious
08:59:48 <lambdabot> [8 @more lines]
09:04:35 <Darius> Jon's first sentence in reply to "Where is unicode support lacking?" is exactly, word for word, what I thought when I read that question.
09:07:20 <shapr> which reply?
09:07:21 * shapr looks
09:08:00 <shapr> Darius: which mailing list?
09:08:59 <Darius> http://haskell.org/pipermail/haskell-cafe/2003-December/005636.html
09:10:10 <shapr> "All over the place."
09:10:14 <shapr> yah, no argument there.
09:10:28 <shapr> how to fix it?
10:07:28 <shapr> @arr
10:07:28 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
10:08:19 <shapr> Graham Klyne is great for the mailing list content
10:08:35 <shapr> hi opet 
10:08:36 <shapr> @arr
10:08:36 <lambdabot> Ahoy mateys
10:08:48 <shapr> @arr
10:08:49 <lambdabot> I'd like to drop me anchor in her lagoon
10:08:55 <opet> hey shapr :)
10:09:00 * shapr entertains himself
10:10:29 <yazirian> of late, on recommendation, i have been poring over doing a debian install
10:10:46 <shapr> I would also recommend debian
10:10:55 <yazirian> i have to say... as fine as this distribution is said to be, they certainly don't mind much for lowering the bar for entry do they?
10:11:05 <shapr> what do you mean?
10:11:10 <yazirian> Let me put it thus:
10:11:16 <shapr> oh, it's a pain to install?
10:11:22 <yazirian> I look at their install docs, and I think to myself, "Wow. Gentoo is easy."
10:11:25 <yazirian> ;)
10:11:37 <shapr> it is picky to install, I admit.
10:12:10 <shapr> but, unlike Mandrake, you don't need to reinstall if you want to upgrade from Debian 2.0 to Debian 3.0
10:12:21 <SyntaxNinja> yazirian: they're working on that :)
10:12:46 <yazirian> I'm messing with jigdo right now.
10:13:14 <yazirian> Which appears to want to build 12 iso images, and so far I've not found a spot where it tells me which ones I really do and don't need.
10:13:19 <shapr> Marvin-- is our local debian-installer guru
10:13:45 <shapr> I installed most recently from the netinstaller
10:13:47 <yazirian> aha, there it is
10:13:54 <yazirian> only took me 10 mins to find :)
10:15:08 <yazirian> just tired of redhat incompatibilities whenever I want to update some obscure dev package
10:15:13 <yazirian> (or, say, kernel 2.6.0...)
10:23:12 <shapr> I'm a great fan of 'speed of change'
10:23:58 <shapr> I like being able to install, try, and rip out if it's boring in the space of five minutes.
10:24:06 <yazirian> me too
10:25:11 * shapr opens his first jp2 file
10:26:10 <shapr> mmm, jpeg2000
10:39:08 <shapr> det: I think the botpuppet has been fixed, but feel free to search for other flaws :-)
10:55:39 <shapr> hey pesco 
10:55:53 <pesco> shapr!
10:56:07 <shapr> I heard rumors that people are working on turning your unregistered build into a registered build
10:56:49 <shapr> how's code treating you lately?
11:00:09 <pesco> Oh, nice rumors!
11:00:24 <pesco> Code ist treating me pretty nice for the most part.
11:01:37 <pesco> I don't get to much, but I'm currently having fun with drawing various things on my root window with GL.
11:01:59 <shapr> oh, are you using HOpenGL?
11:02:07 <pesco> No, I'm doing it in C++.
11:02:12 <shapr> ah
11:02:32 <pesco> I haven't done any Haskell for a while. :(
11:03:02 <shapr> well, if you're doing stuff you enjoy, that's good
11:03:07 <pesco> But the "Fun of Programming" exercises are on my TODO list.
11:05:34 <shapr> http://www.haskell.org/pipermail/glasgow-haskell-users/2003-December/006039.html
11:09:23 <shapr> hm, I can't find the email about someone working on the registered port...
11:24:07 <Igloo> Wolfgang committed some stuff recently
11:24:34 <Igloo> I think it might have made it into 6.2. I'll have a look once -1 has built
11:41:15 <TripleDES> hi
12:13:32 * esap is bored. What kind of new things should I write for my natural numbers module?
12:18:56 <shapr> esap: unnatural numbers?
12:19:39 <esap> heh, well I already got sequences, which are close :-)
12:21:06 <Igloo> Artistically-minded bored people should make crates (for people to pop up from behind), people or a backdrop for http://urchin.earth.li/~ian/kb/  :-)
12:24:28 * esap gets GLUT: Fatal Error in foo: OpenGL GLX extension not supported by display: :0.0  :-)
12:26:21 <Igloo> Ah, well, having OpenGL support would be a prerequisite too  :-)   Maybe I'll convert it to SDL when I have some time
12:29:25 * esap tries to enable GLX in XFree.
12:33:58 <esap> Hmm... now I got a black screen for it :-)
12:35:14 <Igloo> Did you give it a few seconds?
12:35:44 <esap> it seems to use much CPU time, but I see nothing.
12:35:54 <Igloo> Hmm. Does glxgears work?
12:36:05 <esap> yup.
12:36:37 <Cale> esap: what is already in your natural numbers module?
12:36:40 <esap> oh now it does something :-)
12:36:54 <Igloo> Oh, it could just be really badly performing on slow hardware. I'm no OpenGL expert, so it's probably not designed in the most sensible way
12:38:17 <Igloo> If you change time_step to 10, the 1000 commented "~1 per second" to 100 (or 1000 `div` time_step) and similarly divide the 5000 by 10 it might perform better
12:38:57 * Igloo puts the `div` time_steps in my development copy
12:40:27 <Igloo> You're meant to type the words that appear next to the "bad guys", BTW, to kill them
12:40:38 <esap> oh :-)
12:41:08 <esap> hmm.. once I do, the program exits.
12:41:43 <esap> Oh maybe I typoed :-)
12:42:00 <esap> Why are some of the texts overlapping?
12:42:13 <Cale> I really like it when the thing I have to type scrolls off the visible area :)
12:42:50 <Igloo> If it says "You died" you didn't do it fast enough. If it crashed it probably means it's an old version, but I thought it was the latest (for GHC 6.0.1), so it's probably an unknown bug
12:43:16 <esap> ok.
12:44:08 <Igloo> Because it is basically an evenings work. Ideally it would have nice levels and such with monsters in predefined positions. If I can find someone to do nice graphics I'll probably be motivated to have the word placement work better and script, at least partially, where the bad guys appear
12:45:29 <Cale> Yeah, it's pretty cool anyway - I've never attempted anything with GL
12:46:29 <esap> Hmm.. It exited but didn't say 'You died', and didn't crash (AFAIK), no core at least, and no segv.
12:46:49 <Cale> Did you type 1?
12:47:08 <esap> oh perhaps :-) that's how to exit?
12:47:16 <Cale> keyboardMouse _ (Char '1')   _ _ _ = exitWith ExitSuccess
12:47:32 <esap> The 'l', '1' and 'i' are very similar in the font used.
12:50:12 <Igloo> Oh, yeah. I didn't know how to check for alt-q ro something OTTOMH, and q and escape are already used, so I picked 1. I should fix that  :-)
12:53:18 * esap has been thinking about writing a 3D visualizer for visualizing program structure.
12:56:13 <esap> cale: I've got just basic simple things like fold over naturals, plus, times, power, the primitive sequence of naturals, sequences of squares, sequences of powers, etc. Things like that.
12:57:01 <Cale> how about the division algorithm? :)
12:57:03 <esap> cale: oh and instances for monad, Group etc, very simple and basic things.
12:57:47 <esap> cale: hmm.. no I don't have, but I guess it's simple to write...
13:16:37 <shapr> Igloo: do you want 3D models of bad guys? or just drawn images?
13:17:50 <Igloo> Errr, I want to be able to plug them into an HOpenGL (or HSDL) program easily  :-)
13:18:52 <shapr> ah, ok
13:19:00 <shapr> hey, do you have a copy of dark's partial SDL binding?
13:19:05 <Igloo> No
13:19:12 <shapr> do you want one?
13:20:56 <Igloo> Oh, Syn, I've uploaded a haddock 0.6 to Debian, but unfortunately things only seem to be getting put in the autobuild list once a day so it hasn't happened yet. I should hav uploaded it first, but I confused myself by having it installed but no uploaded because it wouldn't build ghc 6.0.1 without a minor extra patch.
13:21:10 <Igloo> shapr: Yes please
13:21:14 <shapr> ok
13:21:44 <shapr> http://shapr.homelinux.net/~shae/hasdl-0.1pre7.tar.gz
13:22:03 <shapr> it's based on the book "Programming Linux Games" which is freely available
13:22:15 <Igloo> Oh, interesting. Do you have a URL handy?
13:22:24 <shapr> yes, just a moment...
13:22:34 <shapr> http://www.overcode.net/~overcode/writing/plg/
13:24:22 <Igloo> Do i want plg-second-printing-update.pdf or plg-final-pdf-no-really-i-mean-it-this-time.pdf?
13:24:26 * esap just wrote the slowest possible natural number division algorithm :-)
13:24:34 <shapr> er, I don't know
13:25:07 <esap> divideNat a b = fst $ zero_elem (dropWhileSeq (\ (_,x) -> x `less_nat` a) (zipf integerSeq $ timesNseq b (nat_name b)))
13:27:01 <esap> dividing 1000 by 2 takes ages :-)
13:28:24 * Darius wonders how much code this is going to break.
13:28:37 <shapr> FOREVER!
13:28:42 <shapr> er, wait...
13:29:07 <Cale> hmm... it would be nice to be able to join io Handles.
13:32:16 <maihem> what do $ and $= mean?
13:33:03 <Cale> $ is just function application, but with precedence such that it's like what's to the right of it is enclosed in brackets.
13:33:33 <shapr> where's $= ?
13:33:34 <Igloo> $= is an HOpenGL function. It's essentially an assignment (using the IO monad)
13:33:41 <shapr> oh
13:35:51 <maihem> so esap's code above means: divideNat a b = fst (zero_elem (dropWhileSeq (\...) (zipf ...))?
13:36:23 <Cale> yeah
13:36:29 <maihem> greedily putting *everything* it can to the right into parentheses?
13:36:56 <Cale> well, it's really just very low precedence, so yes
13:37:41 <maihem> does it tend to cause a haskell compiler to be "eager"? or does it bear no relation to performance?
13:37:51 <Cale> no, it has nothing to do with that
13:37:51 <ibid> no relation
13:38:00 <maihem> thx
13:38:01 <Cale> f $  x    =  f x
13:38:17 <Cale> infixr 0  $
13:39:47 <maihem> I like $. It is a nice operator. I think my code will be clearer now :)
13:39:59 <Cale> yeah, it's good
14:13:43 * Darius sputters
14:13:59 <Darius> Instances: Data Float, where's the instance for Double?!
14:16:12 <Darius> or Rationals.
14:16:15 * Darius sighs.
14:16:32 <Darius> ah good, it does have Rationals.
14:30:39 <Darius> Hey Igloo, in 6.2 why does it complain "Can't splice a polymorphic local variable `top' in a 'do' expression" when using declaration reification brackets, and what do I do about it?
14:31:55 <Igloo> Can I see the code?
14:32:21 <Igloo> Oh, are you trying to use Template Haskell?
14:32:32 <Igloo> If not you need a space between "$" and "top"
14:34:11 <maihem> does lambdabot have a manpage like command so I can look up documentation for haskell functions with a simple /msg lambdabot mancmd fn?
14:34:24 <shapr> sort of
14:34:34 <shapr> the @prelude command used to work
14:34:39 <shapr> but tmoertel's dictd server is down
14:34:42 <Darius> I'm not trying to splice it all though.  The specific line is 'ptr <- top', I'll simplify it in a bit and paste it.
14:34:45 <shapr> @prelude mapM
14:34:45 <lambdabot> ERROR: connect: does not exist (Connection refused)
14:35:03 <shapr> maihem: there's a simpler command called @type
14:35:07 <shapr> @type (!!)
14:35:07 <lambdabot> (!!) :: [a] -> Int -> a
14:35:25 <maihem> ah, but that doesn't tell me what it does ;)
14:35:26 <shapr> maihem: since the type command uses a full Hugs interpreter, it can do relatively nifty tricks
14:35:35 <shapr> @type ([] !!)
14:35:36 <lambdabot> ([] !!) :: Int -> a
14:35:49 <shapr> @type (flip putStrLn)
14:35:55 <shapr> @type (putStrLn)
14:35:55 <lambdabot> putStrLn :: String -> IO ()
14:36:01 <shapr> @type (flip)
14:36:01 <lambdabot> flip :: (a -> b -> c) -> b -> a -> c
14:36:04 <Igloo> Do you have "$do" then?
14:36:15 <Igloo> It's almost certainly caused by a $ followed by something that's not a space, anyway
14:36:38 <shapr> Igloo: what counts as "easy to load" for HOpenGL?
14:39:25 <Darius> Here's (a simplificiation of) the code:
14:39:36 <Darius> top = undefined
14:39:41 <Darius> testEx = [d|
14:39:41 <Darius>  isEnter opcode = do
14:39:47 <Darius>         ptr <- top
14:39:52 <Darius>         return ptr
14:39:52 <Darius>     |]        
14:40:14 <Darius> I am loading it in GHCi if that matters.
14:40:35 <Darius> The code also was working with 6.0.1
14:41:41 <Igloo> Ermm, a module I can import would be ideal. Maybe with a function draw :: BadGuy -> IO () which draws a bad guy in the unit cube and step :: BadGuy -> BadGuy that gives you the next frame in the animation. I can't remember what is the easiest way to make that for OpenGL, let alone HOpenGL, but I suspect SDL will be the way forward anyway. I'll try to read that book soon.
14:42:10 <shapr> ek
14:42:14 <shapr> um, ok
14:42:25 * shapr reads the OpenGL guide
14:42:34 <Igloo> I think SDL is more likely to have built in stuff to load models in standard formats
14:43:00 <shapr> ok, I'll check that first.
14:50:26 <Igloo> Darius: I'm not sure. I don't recall this being deliberately disallowed, but I could have just missed it
14:55:11 * shapr chortles merrily at the bouncing penguins
14:55:23 <Igloo> ?
14:55:44 <shapr> SDL bouncing penguins is the hasdlpre2 demo
14:55:50 <shapr> they look cool
14:56:12 <shapr> data Penguin = Penguin Position Speed
14:56:13 <Igloo> Ah, right
14:56:14 * shapr chortles
14:58:24 <Igloo> That's just moving bitmaps around, right?
14:59:25 <shapr> yup
14:59:52 <Igloo> Would still be an improvment on rectangles, though  :-)
14:59:56 <shapr> yep :-)
15:00:20 <shapr> probably best to start out with penguins instead of zombies
15:00:28 <shapr> or maybe lambdas and penguins
15:00:42 <Igloo> For the next phase a still picture of crates is all that we want, i think. I'm tempted to try making a !person" out of ~7 geometric shapes
15:00:57 <Igloo> s/!/"/
15:00:57 <maihem> GHCi 6.2 seems to be a damn sight faster than GHCi 6.0 at starting up. Does this indicate better optimisation in general, or just the init of the runtime?
15:01:11 <shapr> maihem: everything in 6.2 seems a lot faster to me
15:01:21 <shapr> lambdabot seems significantly faster
15:01:28 <maihem> cool
15:01:55 <Igloo> 6.2 introduced push/eval rather than something/enter, or vice versa, didn't it?
15:02:02 <shapr> apply/thingy
15:02:11 <shapr> apply/enter ?
15:02:26 <Igloo> Could be
15:02:31 <shapr> didn't 6.2 also incorporate whatshisnames speculative evaluation code?
15:02:37 <shapr> Robert?
15:02:40 <Igloo> Don't think so
15:02:45 <Igloo> Robert Ennals or similar
15:02:54 <shapr> yah, that's him
15:03:11 <ibid> push/enter, eval/apply sounds right to me, but i could be wrong :)
15:03:21 * shapr googles
15:03:34 <maihem> I read a paper about push/eval vs apply/enter (I think it was microsoft research in cambridge)
15:03:41 <maihem> I didn't really understand it ;)
15:03:42 <ibid> spj
15:03:47 <shapr> http://www.research.microsoft.com/~simonpj/papers/eval-apply/
15:03:57 <ibid> it has a fun title :)
15:04:00 <ibid> how to make a fast curry
15:04:06 <shapr> How to make a fast curry: push/enter vs eval/apply
15:04:16 * ibid was right :)
15:04:35 <shapr> I thought it was the spec_eval stuff
15:04:47 <shapr> the profiling numbers from spec_eval looked really good
15:04:48 <ibid> huh?
15:04:54 <ibid> speculative evaluation?
15:05:02 <ibid> "it"?
15:05:05 <shapr> I thought that was the major speedup in 6.2
15:05:24 <ibid> i never heard ghc is using speculative evaluation :)
15:05:29 <maihem> what does speculatinve evaluation do?
15:05:31 <shapr> there's a cvs branch at least
15:05:34 <ibid> anybody from jyväskylä here? :)
15:05:58 <ibid> or interested in taking a trip to jyväskylä tomorrow, and understands finnish? :)
15:06:13 <shapr> http://research.microsoft.com/Users/simonpj/papers/optimistic/
15:06:16 <ibid> we are holding a discussion on programming as an art for,
15:06:19 <ibid> form
15:06:27 <shapr> wow, sounds great :-)
15:06:37 <Lor> Do you provide examples of aesthetic and less aesthetic code?
15:06:37 <shapr> muuta, minä en puhu suomea
15:06:46 <ibid> shapr: "mutta"
15:06:48 <Lor> it's "mutta"
15:06:48 <ibid> Lor: no
15:06:54 <shapr> heh, see? I told you so ;-)
15:06:59 <ibid> :)
15:07:12 <Lor> How then do you justify the claim that code is art?
15:07:14 <ibid> "muuta" is "change" (verb)
15:07:23 <shapr> oh
15:07:28 <Lor> 2nd person imperative.
15:07:30 <ibid> true
15:07:36 <ibid> Lor: come and hear :)
15:08:01 <Lor> I'm afraid I have other plans.
15:08:11 <shapr> Darius Bacon is interested in setting up a beautiful code contest
15:08:14 <ibid> i've written something about that topic earlier
15:08:15 <ibid> http://www.cc.jyu.fi/yhd/toys/puheenjohtaja.html
15:08:21 <Lor> As likely do many other people these days. Why did you choose such a time for it?
15:08:26 <ibid> anyway, the idea is nothing new
15:08:33 <shapr> he wants to do the opposite of the IOCCC
15:08:43 * Igloo suddenly remembers I never made debs with spec_eval - doh!
15:08:57 <shapr> Igloo: oh, that would be cool!
15:09:13 <shapr> if the profiling numbers they gave are realistic, I'll switch immediately
15:09:17 <ibid> anyway, to think that art must be beautiful is to ignore much of 20th century art
15:09:26 <Lor> Uh.
15:09:33 <shapr> there is beautiful code
15:09:37 <Lor> That completely depends on your definition of beauty.
15:09:38 <ibid> sure there is
15:09:48 <Lor> If beauty isn't what art strives for, then what is it?
15:09:59 <Lor> I mean, what is the intention that defines art?
15:09:59 <shapr> some people say art strives for expression
15:10:06 <shapr> personally, I just want to see beautiful art.
15:10:20 <shapr> or at least entertaining art
15:10:26 * Igloo isn't sure how good 'net access I'll have for the next week or two so might not be able to do so this side of the new year  :-/
15:10:27 <ibid> Lor: if your definition of beauty encompasses everything that is generally considered art, your definition is much wider than is generally accepted
15:10:40 <ibid> Lor: art defies definition :)
15:10:44 <ibid> anyway, on the date...
15:10:50 <Lor> I have no bloody idea what is "generally accepted" as beauty.
15:11:16 <ibid> we are holding a general meeting later tomorrow
15:11:31 <ibid> it felt like a good idea to combine them
15:11:37 <shapr> Igloo: no worries
15:11:50 <ibid> and as to why the meeting is tomorrow, it has to do with many scheduling issues :)
15:11:54 <shapr> Igloo: I'm going to france, I won't have time to use it even if you did.
15:11:59 <ibid> Lor: sure you do. it's just precise
15:12:06 <ibid> not precise, i mean
15:12:57 <ibid> i mean, ask a random educated person whether certain things are beautiful and whether they are art... :)
15:13:45 <ibid> Lor: we are not planning to let this be the last such discussion :)
15:14:15 <Lor> What exactly are you going to talk about?
15:14:36 <shapr> this is an interesting definition of beauty: http://www.accesscom.com/~darius/gallery/index.html
15:14:45 <ibid> art and engineering, specifically having to do with software :)
15:14:46 <shapr> http://www.accesscom.com/~darius/hacks/evoart/index.html
15:14:56 <ibid> and introducing toys, of course
15:16:16 <ibid> we have a preliminary writeup
15:17:41 <ibid> g'night :)
15:17:49 <Lor> Night.
15:18:28 <shapr> g'night!
15:18:39 <ibid> (GNU Night?)
15:18:42 <shapr> :-P
15:19:49 <ibid> beauty... in the dark
15:20:25 <ibid> anyway, i'm gone
15:20:29 <Igloo> "The avalanche has started. It is too late for the pebbles to vote." is one of my all-time favourite quotes
15:20:38 <ibid> ähh
15:20:45 <ibid> i shouldn't have brought b5 up :)
15:21:01 <ibid> my favourite quote is "my shoes are too tight and i have forgotten how to dance"
15:21:16 <Lor> Ha, you should have seen the kosh shell...
15:21:37 <ibid> i've heard about it :)
15:21:43 <Lor> Wow.
15:21:50 <ibid> but the shoe quote is not koshian :)
15:21:55 <Igloo> I think I might be googling later  :-)
15:22:13 <esap> My favorite quote is "Time is infinite. This is the wrong tool."
15:22:21 <esap> or something like that.
15:22:26 <shapr> where are you getting these quotes?
15:22:32 <esap> B5
15:22:34 <ibid> esap: that's wrong
15:22:35 <shapr> oh
15:22:51 <ibid> esap: it's "you are finite, zathras is finite, this is wrong tool"
15:23:51 <ibid> or longer, (from memory, could be wrong) "time? there's inifinite time. you are finite ..."
15:24:08 <Igloo> googling for koshisms will probably work, although I'm not sure how well they work without having seen the programs
15:24:19 <ibid> get the boxed sets :)
15:24:22 <shapr> I'd like to
15:24:28 <esap> The right quote is: "Cannot run out of time. There is infinite time. You are finite. Zathras is finite. This is wrong tool. No. No, not good. No. Never use that."
15:24:47 <ibid> :)
15:24:55 <ibid> i was right about the short version :)
15:25:06 <esap> http://www.churchofbrad.com/entilzha/quotes.html#Zathras
15:25:08 <ibid> hmm, never use what?
15:25:10 * Igloo can't afford to buy entire TV serieses, unfortunately
15:25:17 <shapr> VC++ I suspect
15:25:24 <ibid> i remember he had a fixation on one... no, not supposed to mention one. or *the* one
15:25:33 <ibid> :)
15:26:02 <ibid> the german b5 boxes are dirt cheap
15:26:19 <Igloo> A B5 quote page without a Kosh section?! Heresy!
15:26:23 <shapr> yes, but germans dub theirs, I might not get the english tracks
15:26:39 <ibid> shapr: the disks are identical, only the packaging differs
15:26:45 <ibid> DVD i mean
15:26:52 <shapr> oh
15:26:55 <shapr> okay, I'm there
15:27:04 <ibid> i have the german second season
15:27:12 <shapr> where'd you get it?
15:27:13 <Lor> Season 3 has had some packaging problems.
15:27:15 * Igloo wonders what ibid's definition of dirt cheap is
15:27:18 <ibid> the packaging is all german, but the disks run with english
15:27:29 <ibid> Lor: all of them have packaging problems
15:27:40 <shapr> what sort of problems?
15:27:42 <ibid> Igloo: lot cheaper than comparable items usually
15:27:44 <Lor> There have been lots of people complaining that some disks have come loose and gotten scratched in transit.
15:27:53 <ibid> shapr: loose disks that get scratched during transit
15:27:58 <ibid> i had that
15:28:01 <shapr> oh, that sucks
15:28:10 <ibid> but amazon replaced it without fee
15:28:29 <ibid> and said, don't bother sending us the broken one
15:28:29 <Lor> ibid, you chose the same wording independently?
15:28:32 <shapr> I want the andromeda boxed sets
15:28:38 <ibid> Lor: yes
15:28:42 <Lor> Scary. :)
15:28:57 <ibid> Lor: it was quite obvious what to say :)
15:29:05 <shapr> yah, english is so simple compared to finnish :-P
15:30:28 <ibid> shapr: oh yeah, i used amazon.de for the german second season
15:30:33 <ibid> shapr: amazon.co.uk for the rest
15:31:48 <ibid> Lor: note that we also chose many different words, like "in"/"during" and different forms "get"/"gotten" and disks have come loose / loose disks :)
15:31:53 <ibid> but i'm gone
15:32:48 <Lor> But still. There are _many_ alternate ways of expressing the same idea.
15:41:00 * shapr plays with the example haSDL example code
15:43:32 <maihem> @type head ([]::[Char])
15:43:33 <lambdabot> head [] :: Char
15:44:19 <maihem> how does head evaluate to an exception if it is a Char? Is there a Char that is "the exception"?
15:45:03 <maihem> ghci says "Prelude> head ([]::[Char])
15:45:03 <maihem> *** Exception: Prelude.head: empty list"
15:45:46 <shapr> head gets the first char from a list of char
15:46:21 <Lor> maihem, it's called "bottom".
15:46:39 <Lor> (Though with ghc's exception system, you can distinguish between different kinds of errors)
15:46:40 <Darius> maihem: In Haskell all variables include _|_ (bottom). As long as you can't catch the exception (in pure code), an exception looks like bottom.
15:46:58 <maihem> so all functions really sort of are a -> b | _|_
15:46:59 <maihem> ?
15:47:03 <Lor> Darius, note that mapException is a kind of a catch and it is pure.
15:47:13 <esap> maihem: no, all types include _|_.
15:47:19 <maihem> I see
15:47:26 <Darius> maihem: Yes in strict languages.
15:47:51 <Lor> But then it would be a | _|_ -> b | _|_ ....
15:48:06 <maihem> so f _|_ -> _|_ ?
15:48:19 <Darius> Lor: (a | _|_ -> b | _|_) | _|_
15:49:28 <Lor> Yeah.
15:49:54 <Darius> maihem: Not necessarily in Haskell, that's what adding _|_ to all (most) types does.
15:49:58 <Lor> Then again, you can't distinguish between bottom and const bottom.
15:50:04 <maihem> So a function can itself be bottom? rather than evaluating to a _|_::b ?
15:50:06 <Darius> Lor: Sure you can.
15:50:32 <Darius> maihem: Yes. _|_ and const _|_ are distinguishable in Haskell.
15:50:34 <Lor> Well yeah, if you add strictness.
15:51:19 <Lor> I somehow shifted my context to pure cbn lambda calculus...
15:51:27 <maihem> Why does haskell use this approach instead of head [a] -> Maybe a?
15:51:44 <Lor> maihem, because it's very convenient.
15:51:57 <Darius> And people typically use pattern matching to handle lists.
15:51:58 <maihem> ah, because bottom "automatically" propagates?
15:52:19 <Lor> Just like errors automaticall propagate in strict languages, too.
15:52:26 <Darius> Anyways, you could easily write, safeHeap :: [a] -> Maybe a
15:52:29 <Lor> If some part of a compound expression errs, the entire expression errs.
15:52:36 <Darius> s/Heap/Head/
15:52:58 <Darius> In fact, it's already written, listToMaybe
15:53:54 <maihem> At the risk of being annoying, why have Maybe when you have bottom?
15:54:17 <Darius> Because you can't go if isBottom x then doThis else doThat
15:55:12 <maihem> of course, because isBottom _|_ = _|_, then if _|_ = _|_ so the funtion that is if ... = _|_
15:55:17 <maihem> heh, silly me :)
15:55:42 <Darius> (There actually is an isBottom function in some module)
15:56:13 * esap considers "catch . evaluate" Almost like an if-then-else thing for that.
15:56:38 <maihem> how do you define that? isBottom _|_ = True; isBottom _ = False ?
15:57:01 <Lor> Um, not quite.
15:57:15 <Lor> You can't detect _bottom_, you can detect certain exceptions.
15:57:27 <Lor> But bottom also stands for nontermination, which is fundamentally trickier.
15:58:22 <maihem> That's unpleasant, a non-terminating function is still defined, it's value is merely never found.
15:59:35 <Lor> Yup. It's called the halting problem.
16:00:05 <maihem> a non-terminating function just takes an unreasonably long time to compute ;)
16:00:45 <maihem> so I suppose bottom could be thought of as "Could not compute"
16:01:04 <maihem> in haskell at least if not mathematically
16:01:16 <Lor> Pretty much, yeah.
16:03:27 <maihem> that's good. I was thinking about how one might use haskell for a public compute node. if a function used too many resources, I couldn't work out how to kill it neatly -- just at some point say, "this function cannot be computed"
16:04:29 <Lor> Well yeah.
16:04:41 <Lor> Read the asynchronous exceptions paper, it explains exactly how to do timeouts like this.
16:05:13 <maihem> I think I'm beginning to understand how I/O works in Haskell too. Can I get a confirmation ...
16:05:41 <maihem> getChar doesn't actually do any I/O itself, but returns details of "what" I/O needs to be done?
16:05:53 <Lor> Sort of.
16:05:55 <Riastradh> It returns a computation.
16:05:57 <maihem> so an IO Char is details of how to "make" a Char?
16:06:03 <Lor> Yep.
16:06:12 <maihem> then >>= in the IO monad does the IO to return the Char?
16:06:22 <Lor> You can think of it like that.
16:06:38 <Lor> Though the entire computation is again eventually packed in an IO.
16:07:06 <maihem> the great thing about a lazy functional language is it doesn't matter "how" it's done, just "how I can pretend it's done" :)
16:07:32 <Lor> Unfortunately, sooner or later you have to think about how it is done, to get reasonable performance.
16:07:41 <maihem> I suppose so.
16:08:16 <maihem> but it could be different from implementation to implementation
16:08:50 <Lor> True.
16:08:52 <Darius> Indeed, I think call-by-name is a conforming evaluation strategy for Haskell.
16:09:05 <Darius> (call-by-name v. call-by-need)
16:09:33 <maihem> what about ones _ = [1..]?
16:09:43 <Lor> What about it?
16:09:51 <Darius> What Lor said.
16:10:07 <maihem> would call by name cause eager evaluation?
16:10:14 <Lor> No.
16:10:14 <Darius> No.
16:10:50 <maihem> so what exactly is call-by-name, and call-by-need then?
16:11:23 <Darius> call-by-name reevaluates a value everytime you demand it, call-by-need saves the value after the first time it's demanded and returns the saved value.
16:11:36 <maihem> I was asssuming call-by-need evaluates what it needs, and call-by-name evaluates what names you give?
16:11:37 <maihem> sorry
16:12:27 <Lor> Both are pretty bad names, imho.
16:15:31 <Igloo> Ah, looks like SDL might just use OpenGL for 3D stuff. HOpenGL might be the way forward after all.
16:16:41 <Darius> Yes, SDL is basically a simple wrapper around OpenGL/DirectX
16:16:52 <Darius> With an emphasis on "simple"
16:17:28 <Igloo> Will it make it easier to draw a model of a crate, or to animate a simple person?
16:17:28 <maihem> If I did two write operations sufficiently far apart that they were in separate disk blocks, should a Haskell implementation ensure that the first is complete and the effects visible to all processes on a system before performing the second? Is it required, is it merely helpful of an implementation but not otherwise specified? 
16:17:39 <Darius> Igloo: By the way, adding the function, 'top' in the example, inside the reification brackets makes it work, but that would be annoying for the real thing.
16:18:41 <Igloo> The problem is (I think - I haven't actually looked at the code) that it's trying to put the value on the RHS of top in the splice, as it used to do for let-bound variables
16:19:00 <Lor> maihem, in general, if you want to ensure that something is visible to the outside world, you should flush.
16:20:32 <maihem> will flush cause the following I/O to not occur until the flush has been performed and visible to other processes?
16:21:13 <Lor> That's not a very precise way of stating it, but essentially yes.
16:21:17 <Darius> Igloo: SDL should be easier to use.  I don't know if it's simplicity scales though.  At any rate, it covers more things than OpenGL (e.g. input, audio) and there quite a few "add-on" libraries, and you should still be able to use OpenGL directly when you need it.
16:21:31 <maihem> ie do { mywritefn1; flush; mywritefn2 } where the second write should not be apparent in the file unless the first also is?
16:21:47 <Lor> Yes.
16:21:53 <maihem> thx
16:22:07 <Igloo> OpenGL does enough input for what kb needs
16:22:11 <Lor> Presumably you're doing some input, too, or the flush would be meaningless.
16:24:00 <Igloo> I think I'll have a look, but I suspect the difference for what kb wants is just a couple of functions to deal with models and maybe a few more lines of initialisation code I already have, which are probably outweighed by the existence and maintainedness of HOpenGL
16:24:42 <maihem> input can be done in other processes running concurrently
16:25:01 <maihem> s/can/may/
16:25:22 <Darius> Igloo: Yes, my responses were more in the context of using OpenGL/SDL from C/C++.  I haven't tried any Haskell bindings.
16:27:49 <Lor> maihem, you don't quite get the point. If your program doesn't do any input at all, then any flushes are quite meaningless.
16:28:23 <Lor> Because it would be quite possible for your entire program to run all the way to the end before any other program does anything at all. And then it wouldn't matter whether there was a flush in the middle or not.
16:29:00 <Lor> Concurrency is tricky. You must always remember that unless you have some timing guarantees, schedulers can do very very funny things.
16:30:31 <maihem> Of course, I'm still trying to understand functional programming. Getting there slowly :)
16:31:09 <Lor> All right, so forget about concurrency and interprocess communication for the time being.
16:31:14 <maihem> How might I limit the amount of computation done before permorming IO in Haskell?
16:31:19 <maihem> okay.
16:31:28 <Igloo> Darius: BTW, what's the "right" way to have an OpenGL program that animates things continually and listens for input? Should I be generating some event at the end of my displayCallback to cause another display event and using the difference in time since the last call to work out how much to step the animation by?
16:32:02 <Igloo> I'm currently just using addTimerCallback 1 and assuming the drawing functino takes 0 time, which obviously isn't ideal, especially on slower machines...
16:32:11 <Lor> maihem, read the asynchronous exceptions paper.
16:32:17 <maihem> k
16:32:19 <Lor> It explains how to do timeouts.
16:32:30 <Lor> Then again, it also requires concurrency.
16:37:13 <Igloo> This SDL book just seems to do it as fast as possible (for the bouncing penguins at least)
16:40:04 * Igloo realises I probably mean GLUT rather than OpenGL
16:42:55 <Darius> Yeah.  I don't think OpenGL itself handles that aspect.  I know nothing about GLUT and not much about (H)OpenGL, and what I have done is a long time ago.
16:43:21 <Darius> (OpenGL isn't very fun without a 3D accelerated graphics card)
16:43:27 <Igloo> Ah, OK. The book's just started talking about ti (on page 159!)
16:43:44 <Igloo> Hmm, no  :-(
16:43:53 <Igloo> Well, kb is probably OK  :-)
16:44:20 * Igloo should either see if my graphics card has decided to play nicely with the latest X or get software OpenGL working
16:59:20 * Darius does with Data.Generics in three lines what would take many otherwise.
17:00:59 <andersca> hey
17:29:11 * Darius remembers the perverse pleasure of hacking a graphics register.
17:40:03 <Igloo> IdleFunc! How did I manage to forget that?!
17:42:13 <Darius> No Substance! How did I manage to forget that?!
17:43:44 <shapr> Sleep! How did I manage to forget that?
17:43:55 * shapr remembers
17:50:33 <stepcut> :t table1
17:50:38 <stepcut> oops
17:50:41 <Cale> hehe
17:50:50 <Darius> [(String,Int)]
17:56:37 <Igloo> Anyone happen to know a way of getting a sub-second precision time before I dive into the POSIX HL docs?
17:57:16 * Darius used to know how to using x86 pemos
18:01:50 <Igloo> Eeek
18:01:54 * Igloo fails to find anything
18:02:13 <Igloo> Having to write a tiny bit of C and use the FFI would just be irritating
18:02:44 <Cale> Using getClockTime and then converting to CalendarTime fills in ctPicosec
18:03:05 <Cale> I'm not sure if it has any level of precision, but you could try it.
18:03:39 <Igloo> It's just handling wrapovers would be annoying
18:05:59 <stepcut> :t xida
18:06:03 <stepcut> gah!!!
18:06:19 <stepcut> apparently i am too tired to be coding and using irc at the same time
18:06:22 <ayrnieu> Igloo - no select()-like function exists?
18:07:25 <Igloo> Ah, GHC exports its ClockTime constructor which has just what I want
18:07:48 <Igloo> ayrnieu: That would only help me sleep, not measure time passed, no/
18:08:06 <ayrnieu> misunderstood your desire, sorry.
18:08:37 <Igloo> threadDelay in the Concurrent tree somewhere is what you'd want for that, incidentally
18:09:01 <ayrnieu> nifty.  Thanks.
18:11:06 <Cale> yeah, I'm just discovering all the Concurrent stuff. It's rather nice :)
18:11:42 <phubuh> HELLO!
18:11:54 <Igloo> Hiya
18:19:29 <Cale> sequence $ repeat $ do { c <- getClockTime; case c of TOD x y -> do { print y } }
18:20:16 <Igloo> Yeah - it breaks the standard but I think it's worth it
18:20:22 <Igloo> Oh, he went
18:54:25 <Darius> morons! *sigh*
18:56:01 <Igloo> ?
18:57:40 <Darius> The wiki was "hacked" yet again.
18:58:03 <Igloo> Oh, interesting
18:58:42 <Riastradh> Graaagh.  The _idiots_ who do this just don't deserve to have access to computers.
19:03:02 <Riastradh> Especially with this line on the _FRONT_PAGE_ (and there even before he 'cracked' it):  Which is to say - It is really lame to call yourself a hacker and go about  defacing a wikipage that is available for /Anyone/ to modify.
19:08:05 <Darius> You think he read the page before "cracking" it?
19:11:39 * Igloo wonders where it is if it's not fixed yet
19:12:32 <Igloo> and how often it happens
19:15:01 <Darius> I fixed it as I shortly after mentioning it.  You can look at the diff to see it if you'd like. Apparently the creator also added another page 'xd'.
19:15:16 <Darius> As to how often, I think this is the fourth or fifth time.
19:15:32 <Igloo> Where is it? And in how long?
19:17:02 <Darius> Go to RecentChanges and use the 3D glasses.  For how long, in the last month or so.  Though it apparently is a new fangled past-time, I'm not aware of it happening before then.
19:17:21 <Darius> On a side-note, Cliki apparently was "cracked" too recently.
19:17:30 <Igloo> But where is the wiki itself?  :-)
19:17:48 <Darius> www.haskell.org/hawiki
19:17:54 <Igloo> Ta
19:18:04 <Darius> Or click on the big "Haskell Wiki" link on www.haskell.org.
19:18:31 <Igloo> Ah, cunning
19:20:38 <Igloo> Oh, that really is quite unimaginative
19:21:19 <phubuh> 0wn3d by Status-x & Makan0!
19:21:19 <phubuh> .Ve & .Mx r00lz!
19:21:26 <phubuh> hahaha, I didn't think these people existed
19:21:46 * Igloo is interested as I know some people who run a (fairly low profile, local) wiki who assure me people behave sensibly (although they do seem to spend their life editing everyone else's contributions to fit the house style)
19:23:08 <Darius> Yes, but these aren't people.
19:24:09 <phubuh> oh, that explains it
