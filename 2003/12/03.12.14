03:00:18 <shapr> goood morning!
03:00:31 <ayrnieu> ... !  Oh, right.  Time for bed.  Good night.
03:01:17 <phubuh> morning, shapr!
03:01:34 * ayrnieu throws an emerge of GHC onto the pile.
03:02:37 <shapr> anything exciting happening today?
03:03:02 <opet> saddam hussein's getting arrested, apparently
03:03:06 <ayrnieu> apparently somebody caught Saddam recently.
03:04:37 <shapr> wow
04:52:21 <shapr> busy day?
05:58:01 <shapr> I still don't think recursively.
05:58:20 <esap> recursively? Why would you want to think recursively? :-)
06:01:15 <andersca_> recursively? why would you want to think recursively?
06:01:33 <shapr> Is there some way to fake string input from a handle? something like StringIO in Python?
06:04:36 <esap> shapr: that should not be necessary, I'd say. You should separate interface modules from control. [I don't know exactly what StringIO in Python does]
06:05:22 <shapr> I agree, but I can't think of an easy way to do it for an SMTP server.
06:05:37 <shapr> this is just a prototype anyway, I'll rewrite it when this vaguely works
06:06:16 <shapr> actually, this is a POP3 server, but SMTP is next
06:06:24 <esap> Maybe write to a temp file, then read from it?
06:06:47 <shapr> that's an idea
06:14:56 <ustenzel> shapr: What is missing?  Isn't there hGetSomething that would work?
06:16:21 <earthy> shapr: the problem is in dealing with interleaved commands and responses?
06:16:46 <earthy> why not model the command/response interaction as a possibly infinite stream that you then run a function over
06:16:47 <earthy> ?
06:18:29 <shapr> hm, I'll think about that.
06:19:17 <ustenzel> What's wrong about hGetLine?
06:20:05 <shapr> for what purpose?
06:20:41 <ustenzel> I don't get it.  What exactly do you want to fake and for what purpose?
06:21:33 <shapr> at the moment I'm passing a socket handle around, that seemed to be the quick hack solution
06:22:04 <ustenzel> sounds reasonable.
06:22:55 <ustenzel> ah, you want to simulate the "other end" of the socket for testing?
06:22:57 <shapr> if I wanted to unit-test something like that in Python, I'd use StringIO, where I can get a handle that just feeds a set string into whatever reads
06:22:58 <shapr> right
06:23:50 <shapr> I'd rather go with a structure like esap suggested, where interface and control functions are completely separate.
06:23:57 <shapr> I can't see an easy way to do that though.
06:26:36 <ustenzel> Hm.  Put all relevant functions not in the IO but in a custom monad with functions for sending and receiving messages.
06:27:00 <ustenzel> Make one socket-and-IO based instance and one based on strings.
06:27:23 <esap> For sending messages, I'd suggest using sequences to represent a stream of messages.
06:27:39 <shapr> of course, with decoupled code, I can unit test without needing to fake a socket
06:27:53 <shapr> esap: how so?
06:27:57 <ustenzel> a stream would work for reading, too.  but it seem fragile.
06:28:57 <esap> shapr: you mean the message part? Well that's just a nice way to represent it.
06:29:52 <esap> shapr: because then the interface module can take one msg at a time and send it to a socket. But if you don't have a stream of those, then you have to invoke the interface module separately every time.
06:31:39 <shapr> one at a time is necessary for POP3 at least, since each msg must be specifically requested
06:32:20 <esap> yes, but that's just the low-level thing. You can give it more abstraction by expressing the whole sequence.
06:33:52 <shapr> I'll think about that.
06:39:18 <shapr> is there some sort of rfctree that shows which RFCs obsolete which others?
06:40:48 <shapr> I want to make sure I'm reading the latest RFCs on POP3 and SMTP
06:41:41 * esap prefers google for finding RFCs.
06:41:52 <ustenzel> There should be an RFC that lists the current RFCs.  Probably 3500 or some other "even" number.
06:42:35 <shapr> ok, thanks
06:43:20 <ustenzel> Oh, a near miss: it's 3600.
06:46:55 <shapr> btw, does anyone know if I can define commands for certain keys in gnome? specifically, I want to set C-v and M-v to pgdn and pgup in Galeon
06:48:08 <shapr> RFC3600 is very useful, thanks
07:07:04 <shapr> it occurs to me that for SMTP and POP3 it might be simpler to define them as interpreters.
07:16:22 <steveh_> building GHC seems very slow...
07:17:11 <shapr> it does take some time.
08:31:58 <Darius> shapr: What you could do is define a module with the IO functions you are using implemented on strings and import it with the standard IO functions hidden or qualified.
08:32:13 <shapr> yah, that would work
08:32:41 <andersca_> hmm
08:32:53 <andersca_> how do I export an imported module from a module
08:33:08 <Darius> module A ( module B ) where import module B
08:33:25 <andersca_> thanks
08:34:16 <Darius> Another trick is, module A ( module X ) where import qualified B as X; import qualified C as X
08:58:46 <shapr> either can easily obfuscate code
09:01:27 <Darius> ?
09:02:45 <shapr> I was just contemplating something like either (parseError) (either (nosuchuserError) (usernameExistsP))
09:03:49 <Smerdyakov> That's lame! Only a smellykins would use that.
09:07:17 <Darius> shapr: I've used twice nested eithers, I don't think I've ever needed or used more than that.
09:14:57 <Smerdyakov> Darius, why didn't you define a custom datatype for it?
09:15:13 <Darius> Because it wasn't my datatype.
09:15:26 <Darius> Or rather, it wasn't all my datatype.
09:15:35 <Smerdyakov> ?
09:16:44 <Darius> If I use a library that return Either Something a, and I return Either A B, I can't change the library function to return Case1 Something | Case2 A | Case3 B
09:17:09 <Smerdyakov> But you can convert it.
09:17:56 <Darius> There wasn't any point.  I'd use the either something (either a b) to convert it, but I might as well just handle it there, typically the Something is some kind of error case.
09:18:28 <Smerdyakov> Grimble gromble
09:19:08 <shapr> I have a Parsec parser username :: Either (Left ParseError) (Right [Char]), then elemFM to see if that user exists, then parser password, then lookupFM to see if it's the correct password, how would you structure that?
09:21:13 <shapr> Smerdyakov: can you think of a non-lame way to structure that?
09:22:46 <Smerdyakov> No, but I'm not thinking too hard about it. :D
09:23:23 <Darius> shapr: Why not have the whole thing be a parser?
09:23:48 <shapr> huh, that would be simpler
09:44:44 * Darius stares at his code.
09:48:11 * Darius runs grep "TODO" *.hs | wc -l
09:58:47 <shapr> overflow error?
10:00:47 <Darius> 87
10:35:24 * shapr codes happily
10:35:54 <shapr> I'm still not sure about structuring everything, but I'm writing the pieces I can see need writing.
10:50:22 * Darius really needs to write a resolver... and a compiler while he's at it.
10:50:38 <shapr> resolver for what?
10:51:12 <Darius> LVM assembly
10:51:14 <shapr> oh
11:02:16 <andersca_> that's when I reach for my resolver
11:02:34 <shapr> hah
11:05:43 <shapr> what's the normal way to wait for a connection and fork off a process? do I Network.accept in the mainloop, and then pass the handle to the process just before I fork it?
11:11:48 <Darius> shapr: Pretty much.
11:12:11 <shapr> ok, thanks
11:12:14 * shapr bounces happily
11:12:40 <ayrnieu> shapr - you should probably use Concurrent Haskell instead, but OK.
11:12:50 <shapr> that is concurrent haskell
11:13:10 <shapr> isn't it?
11:13:34 <ayrnieu> Oh, OK.  'fork off a process' reads as OS-level processes to me.
11:14:17 <shapr> yah, I see your point
11:14:27 <ayrnieu> shapr - you should probably avoid any Network function that returns a Handle, though.  socketToHandle loses to real sockets in many practical ways
11:14:31 <shapr> next time I'll say forkIO/forkOS, whatever
11:14:58 <shapr> how so?
11:14:59 <ayrnieu> shapr - I basically looked at Network.hs and rewrote everything I needed without the final socketToHandle call.
11:15:13 <shapr> what's significant about socketToHandle?
11:15:31 <ayrnieu> shapr - hSetBuffering socketHandle X where X equals any possible setting loses to actually handling the socket.
11:16:13 <shapr> how so? what are the downsides?
11:16:40 <ayrnieu> shapr - NoBuffering gives you the functionality of BlockBuffering 1; LineBuffering works if you really want that, I suppose; BlockBuffering N for N waits for N bytes, even if it already has less than N bytes ready to read.
11:16:56 <shapr> oh
11:17:20 <shapr> I'll keep that in mind.
11:17:44 <ayrnieu> You can't write a simple 'echo' server worth anything with socketToHandle, for a trivial instance of the problem.
11:29:47 * Darius slowly decides that he's right about what some of those extraneous numbers mean.
11:37:00 <Darius> What gives an "Error in array index" exception.  It's presumably not an out-of-bounds exception as that has another, more informative, error message?
11:38:49 <shapr> it's not //
11:38:57 <shapr> that gives Index out of range
11:45:47 <Darius> let me see something...
11:48:01 <Darius> ah, well that's very annoying.
11:48:56 <shapr> ?
11:49:31 <Darius> Apparently, it is an out-of-bounds exception it just has a crappy error message when specialized to Word32.  I recently changed from IOUArray Int Int to IOUArray Word32 Word32.
11:50:03 <shapr> oh
11:50:06 <shapr> suckage
11:52:24 <Darius> Well, I guess I can change it back to Int, I have the necessary fromIntegrals now.  Though that will make the unsigned shift right into a signed one.
11:56:10 <Darius> Using Int the error disappears. Joy </sarcasm>
12:00:09 <Darius> Well... it's printed out 'h' and 'i' somewhere in the 233 lines of diagnostics.  So apparently the external calls work.
12:00:15 <shapr> yay
12:24:27 <shapr> g'morning SyntaxLaptop 
12:24:37 <SyntaxLaptop> hey shapr
12:40:33 <steveh_> good afternoon
12:41:10 <Heffalump> 'lo
12:49:12 <ben3> afternoon.  i wonder if the following three all do the same thing anyway:  f g x ... f (g x) ... f . g x
12:49:32 <Heffalump> no, none of them do
12:49:46 <Heffalump> is this your homework?
12:50:21 <ben3> heh, no... i'm trying to understand what's the point of .
12:50:35 <Heffalump> it's a notational convenience, really.
12:50:37 <ben3> is it a good question then, by the way?
12:50:52 <Heffalump> you could always write (\x -> f (g x)) instead of f.g
12:51:11 <Heffalump> but often it's useful, especially when you're not using it with an argument
12:51:15 <ayrnieu> . f g = \x -> f (g x)
12:51:18 <ben3> are you saying that f (g x) and f . g x do differently?
12:51:19 <Darius> "a notational convenience"?  It's a function.
12:51:25 <Heffalump> ben3: yep.
12:51:31 <ayrnieu> ben - yes.  The latter returns a function accepting one argument.
12:51:32 <Darius> @type \f g x -> f . g x
12:51:33 <lambdabot> \f g x -> f . g x :: (a -> b) -> (c -> d -> a) -> c -> d -> b
12:51:39 <Heffalump> darius: it's a functional that provides for notational convenience.
12:51:40 <Darius> @type \f g x -> f (g x)
12:51:41 <lambdabot> \f g x -> f (g x) :: (a -> b) -> (c -> a) -> c -> b
12:51:45 <andersca> la la la
12:51:54 <shapr> yeehaa
12:52:03 <Heffalump> s/functional/function/ #gah
12:52:15 <shapr> bah, I'll give in and watch The Last Crusade.
12:53:00 <Darius> Heffalump: Any function could be considered that.
12:53:41 <Heffalump> (.) more so than others, I'd claim.
12:56:22 <ayrnieu> ($) more than (.), I'd claim.
12:56:26 <Heffalump> true
12:56:41 <ben3> it appears to me that f (g (h x)) is the same as f . g . h x ... seeing as they are both "apply x to h, g, then f"?
12:56:53 <ayrnieu> ben - still wrong.
12:56:54 <Heffalump> ben3: you're missing some brackets
12:56:59 <Darius> No, (f . g . h) x
12:57:10 <ayrnieu> f (g (h x)) <=> f . g . h $ x
12:57:15 <Heffalump> remember that the ' ' of function application binds tighter than anything else, including .
12:57:29 <ayrnieu> f . g . h x <=> \y -> f (g (h x y))
12:57:46 <ben3> what is ' '?
12:58:00 <Heffalump> space
12:58:02 <ayrnieu> ben3 - function application binds tighter than any operator.
13:00:08 <ayrnieu> f . g . h x <=> (f) . (g) . (h x)  -- also
13:01:52 <ben3> with the above, it appears to me that h x is evaluated first (it's tighter than ., right?), then apply the result to g, then f?
13:02:30 <Darius> No, here's another way of writing it, let h' = h x in f . g . h'
13:02:57 <ben3> ah, i see
13:03:45 <ayrnieu> Best not to think in terms of 'evaluated' first with haskell.
13:04:46 <ayrnieu> ignore . (hardCalculation n) where ignore x = True
13:05:17 <Darius> ignore . (1 `div` 0) where ignore x = True
13:05:39 <ayrnieu> or possibly even  ignore . hardCalculation $ n where ignore x = True
13:06:25 <Darius> @eval ((\x -> True) . (\n -> n `div` 0)) 10
13:06:26 <lambdabot> True
13:08:10 <ayrnieu> also, belatedly, 'evaluated first'
13:11:02 <ben3> thanks all.  it's most appreciated.
13:12:34 <ayrnieu> divs x = div x x : divs (x - 1)
13:13:02 <ayrnieu> As in certain John Varley stories, looking at it will kill you.
13:13:43 <Darius> @define divs \x. div x x : divs (x - 1)
13:13:44 <lambdabot> divs defined
13:13:56 <Darius> @get-definition take
13:13:57 <lambdabot> take not defined
13:15:27 <Darius> @define take \n l.if null l || n <= 0 then [] else head l : take (n-1) (tail l)
13:15:28 <lambdabot> take defined
13:15:45 <Darius> @eval take 10 (divs (-1))
13:15:45 <lambdabot> (line 1, column 16):
13:15:45 <lambdabot> unexpected "-"
13:15:45 <lambdabot> expecting simple term
13:15:55 <Darius> @eval -1
13:15:56 <lambdabot> (line 1, column 1):
13:15:56 <lambdabot> unexpected "-"
13:15:56 <lambdabot> expecting white space or simple term
13:16:06 <ayrnieu> @eval take 10 (divs 20)
13:16:07 <lambdabot> unbound variable: div
13:16:21 <ayrnieu> interesting.
13:16:26 <ayrnieu> @eval 1 `div` 1
13:16:26 <Darius> @define div \x y.x/y
13:16:27 <lambdabot> unbound variable: div
13:16:27 <lambdabot> div defined
13:16:43 <ayrnieu> @eval take 10 (divs 20)
13:16:44 <lambdabot> [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
13:16:50 <ayrnieu> @eval take 20 (divs 20)
13:16:50 <lambdabot> [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
13:16:59 <ayrnieu> @eval take 21 (divs 20)
13:16:59 <lambdabot> divide by zero
13:17:03 <Darius> @eval take 10 (divs (0-1))
13:17:03 <lambdabot> [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
13:17:04 <ayrnieu> boom!
13:17:50 <ayrnieu> @define toZero \n if n < 0 then n + 1 else n - 1
13:17:51 <lambdabot> (line 1, column 5):
13:17:51 <lambdabot> unexpected reserved word "if"
13:17:51 <lambdabot> expecting letter or digit, "." or "->"
13:18:07 <Darius> digit?
13:18:15 <ayrnieu> @define toZero \n. if n < 0 then n + 1 else n - 1
13:18:16 <lambdabot> toZero defined
13:18:26 <ayrnieu> @eval [toZero -5, toZero 5]
13:18:26 <lambdabot> type error
13:18:37 <ayrnieu> @eval [toZero (0 - 5), toZero 5]
13:18:37 <lambdabot> [-4, 4]
13:18:53 <ayrnieu> Darius - I don't follow you.
13:19:17 <Darius> It said expecting letter or digit, which implies \2 -> True is legal.
13:19:21 <Darius> @eval \2 -> True
13:19:21 <lambdabot> (line 1, column 2):
13:19:21 <lambdabot> unexpected "2"
13:19:21 <lambdabot> expecting identifier
13:20:13 <ayrnieu> function 2 -> true;; =)
13:20:17 <Darius> I guess remained from parsing the identifier.  You'd think the whitespace would affect it.
13:20:24 <Darius> @type \2 -> True
13:20:24 <lambdabot> \2 -> True :: Num a => a -> Bool
13:20:35 <Darius> @eval \n2 -> True
13:20:36 <lambdabot> <<EM Dynamic -> EM Dynamic>>
13:31:08 <Darius> @define negate \x.0-x
13:31:09 <lambdabot> negate defined
13:42:43 <ben3> there's no such a toString :: Int -> String in the prelude?
13:42:54 <Riastradh> @type show
13:42:55 <lambdabot> show :: Show a => a -> String
13:42:55 <Lor> ben, there's show
13:43:08 <Riastradh> @prelude show
13:43:10 <lambdabot> ERROR: does not exist
13:43:10 <lambdabot> Action: connect
13:43:10 <lambdabot> Reason: Connection refused
13:43:13 <Riastradh> Nrrrghle.
13:43:14 <ben3> thanks :-)
13:43:16 <Riastradh> Someone needs to fix that!
14:10:33 <ben3> i think the mapState idea is quite popular, but how come it's not part of prelude?
14:11:11 <ayrnieu> possibly because Haskell98 defines the prelude
14:12:16 <Darius> mapState?  I can only think of one mapState function and it doesn't strike me as quite popular.
14:13:01 <ben3> for, er, stately interaction... is there a different popular approach?
14:13:51 <Darius> What mapState are you talking about?
14:15:28 <ben3> it's one approach of carrying information forward from an interaction for later use
14:16:21 <ben3> an calculator, for example
14:16:44 <ben3> judging by the reaction i've got here, i suppose it's not as popular as i thought it would be
14:16:45 <Darius> What module is mapState defined in?
14:17:01 <Lor> sounds like the state monad.
14:17:33 <Darius> Lor: That's the one I was thinking of before, but I'm not sure if that's what ben3 is talking about.
14:18:00 <ben3> http://www.haskell.org/ghc/docs/latest/html/base/Control.Monad.State.html
14:18:16 <Darius> Okay.  Why do think it's quite popular?
14:19:17 <ben3> well, i thought most of you would have written some interactive programs using haskell... and obviously knowing the state a program is in helps
14:19:39 <ben3> for calculator, editor, etc
14:20:23 <Lor> I think most of the time people try to avoid threading state through everything.
14:20:39 <Lor> And when you do really need state, ST or IO are often much handier.
14:21:20 <ben3> ST and IO?
14:21:34 <Darius> Also, the mapState function in particular doesn't seem too often used.  You usually don't need to change the type of the state you are working with.
14:21:43 <ayrnieu> My interactive programs tend to keep important state by passing them around explicity where I can see them.
14:23:19 <ben3> ok, thanks :-)
14:23:30 <Darius> (er nevermind, it's not even that)
14:24:33 <Darius> ben3: Have you read/Are you reading some kind of introduction/tutorial/book on Haskell?
14:25:02 <ben3> Darius: on the internet, yes
14:25:15 <Darius> Which?
14:25:38 <ben3> haskell.org, and the gentle introduction to haskell.  why?
14:28:21 <Darius> Just wondering.  Most of them cover IO and at least basic interactive Haskell programs, but they don't cover Control.Monad.State as it isn't Haskell 98 (in it's full glory), including that one.
14:31:34 <ben3> sorry if my questions have bothered you :-)
14:33:29 <Darius> I was just wondering where you got the idea that mapState was popular (not that it's unpopular, but most code I've seen that uses Control.Monad.State doesn't use mapState)
14:34:15 <ben3> i think it was intuition
14:34:30 <ben3> guess i was wrong then :-)
14:35:30 <ski> lo
14:42:45 * Darius thinks about making an EDSC or even two of them.
15:12:20 <ben3> sorry, have been unable to find a function for converting a number in char to int
15:13:12 <ben3> toInt :: Char -> Int .... for example, toInt '3' --> 3
15:13:49 <Darius> You could define it, but don't you really want toInt "30" --> 30
15:14:48 <ben3> that's what i'm trying to define, [Char] -> Int, but not Char -> Int ... i'll think of how to define it, thanks :-)
15:15:15 <ben3> s/not/wonder how to do/
15:15:37 <ayrnieu> digit c = read $ c:[]
15:16:09 <Darius> ayrnieu: If you are going to bother with a point you might as well use nice syntax, read [c]
15:16:13 <ayrnieu> or you could convert the character to its ASCII value and do a arithmetic.
15:16:42 <ayrnieu> darius - indeed.
15:16:42 <ben3> your latter idea was what i had in mind, but your first idea seems very elegant :-)
15:17:00 <Darius> ayrnieu: While I think that that is safe in -every- character set, I'm not sure and there is another way that would work even with an insane character set.
15:17:44 <ayrnieu> chr '1' - chr '0' -- if chr does what I think it does.
15:18:07 <ayrnieu> but insane character sets exist where '1' does immediate succeed '0', I suppose.
15:18:18 * ayrnieu waits for GHC to compile.
15:20:35 * Darius watches ayrnieu grow old.
15:21:00 <ayrnieu> No, doing CL programming right now.
15:22:35 <ben3> may i ask, CL?
15:22:43 <Darius> I never noticed CL stopping or reversing aging when I used it.
15:24:11 <ayrnieu> ben - Common Lisp.
15:25:27 <ayrnieu> Specifically, I look at Eclipse as an in-CL replacement for Sawfish, a wonderful lightweight WM with librep as an extension language -- but I don't like librep so much.  Hard to debug.  Somewhat barren, compared to Common Lisp.
15:26:18 <ayrnieu> Only in comparison, though -- I like sawfish a great deal; I just want to program it in Common Lisp instead of librep.
15:33:49 <ben3> any particular reason for using digit = read $ c:[] rather than digit = read (c:[]) ?
15:34:03 <ben3> other than having to type one less letter? :-)
15:35:17 <Darius> Because ayrnieu hates parens... as he sits there using CL :P
15:36:45 <phubuh> digit = ((.) read ((flip (:)) []))
15:37:42 <ayrnieu> ben - I like $
15:38:11 <ayrnieu> and I hate parens in non-lispy languages, sure.
15:45:00 <Riastradh> ben3, actually, 'read $ c:[]' is exactly the same number of characters as 'read (c:[])'.
15:45:26 <ben3> very true :-)
15:45:30 <Riastradh> read $ c:[]
15:45:33 <Riastradh> read (c:[])
15:45:39 <phubuh> but spaces are cheap
15:46:10 <Riastradh> Using $ is good for when your PHB walks by, because if he sees lots of $s, then he'll think that you're doing very profitable work.
15:46:33 <ben3> PHB?
15:46:37 <Riastradh> Pointy-Haired Boss.
15:46:43 <ben3> :-)
15:47:39 <phubuh> I'd like a ($$$) :: Num a => a -> IO Money
15:47:48 <ayrnieu> Riastradh - spaces don't really count to the number of spaces, though.
15:47:55 <ayrnieu> to the number of characters, even.
15:48:19 <ayrnieu> type Money = Money Int
15:48:39 <ayrnieu> ($$$) n = return $ Money n
15:49:48 <andersca> that should be newtype though, right?
15:49:48 <ayrnieu> eh, or rather:  ($$$) n = do playSound "cha-ching!"; return Money n
15:49:59 <andersca> and you might want to makes sure that n is positive
15:50:13 <ayrnieu> negative money exists.  Let me give you some of it.
15:50:45 <ayrnieu> type Money = US Int | Peso Int | Yuan Int
15:50:56 <Riastradh> data, not type.
15:51:01 <ayrnieu> oh, indeed.
15:51:12 <ben3> how do i start a list within another list?  duplicates x = x : duplicates ... that starts off with [x, x, x, ... but how do i start off with [[x, x, ... ?
15:51:12 <Riastradh> Lynch the OCaml-influenced!
15:51:17 <ayrnieu> so yeah, you should rewrite what I first said as newtype
15:51:56 * ayrnieu points desperately at the GHC build.
15:51:56 <Darius> Yeah, and $$$ must be binary.
15:52:58 <Darius> ($$$) :: HardWork -> Dedication -> IO Money
15:53:04 <ayrnieu> ($$$) Me (SomeElse x) = do transferCash x Me; playSound "cha-ching!"; return ()
15:53:11 <ayrnieu> oh, ptth.
15:53:20 <Darius> _ $$$ _ = ioError "Ideology overflow"
15:55:36 <Darius> ben3: duplicates (duplicates x)
16:07:55 <ben3> sorry, that was a bad example.  let's say that i have a function which ends a list and creates a new list (all within a list) whenever it encounters a '0' in a string being parsed
16:11:10 <det> give an example of string -> list ?
16:12:25 <ben3> f ' ' "darius ben3 det" --> ["darius", "ben3", "det"]
16:15:16 <ayrnieu> ben3 - perhaps if you figured out the type of this list, you'd find it easier to write the function that creates.
16:15:31 <ayrnieu> ben3 - carefully ignoring your bizarrely-aside example code.
16:17:11 <ben3> type would be: f :: Char -> [Char] -> [[Char]] ... i'm trying to see how it could help me
16:17:51 <ayrnieu> ben3 - OK.  Ignoring your question and looking only at your example code and the type you gave me, take a look at 'words' in the Prelude
16:18:01 <phubuh> why not f :: a -> [a] -> [[a]]? :-)
16:19:33 <ben3> ayrnieu: do you mean that i should see that i could use words in prelude? 
16:19:45 <ayrnieu> ben - no, I mean that you should look at 'words' in the Prelude.
16:20:02 <ben3> yes, i've got it here with me
16:20:33 <ayrnieu> Great!  Does that answer your question, then?
16:21:35 <ben3> words in prelude uses a different approach of doing it... i take it my idea of, within a list, starting and ending lists is not possible then?
16:22:21 <ayrnieu> ben - I have no idea you mean to ask.
16:22:39 <ben3> sorry
16:23:51 <ayrnieu> @eval foo n = n : foo n + 1
16:23:51 <lambdabot> (line 1, column 7):
16:23:51 <lambdabot> unexpected "="
16:23:51 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string, "(", operator, simple term or end of input
16:24:09 <ayrnieu> @define foo \n. n : foo n + 1
16:24:09 <lambdabot> foo defined
16:24:15 <ayrnieu> @eval take 10 foo
16:24:16 <lambdabot> type error
16:24:25 <ayrnieu> @eval take 10 (foo 5)
16:24:26 <lambdabot> type error
16:24:28 <Darius> I don't think you want foo n + 1
16:24:35 <ayrnieu> oh, right.
16:24:40 <ayrnieu> @define foo \n. n : foo $ n + 1
16:24:41 <lambdabot> foo defined
16:24:45 <ayrnieu> @eval take 10 (foo 5)
16:24:45 <lambdabot> type error
16:24:54 <ayrnieu> oh, right again.
16:25:03 <ayrnieu> @define foo \n. n : (foo $ n + 1)
16:25:03 <lambdabot> foo defined
16:25:07 <ayrnieu> @eval take 10 (foo 5)
16:25:08 <lambdabot> [5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
16:25:21 <ayrnieu> GIVEN THAT.
16:25:54 <ayrnieu> no, I won't use lambdabot's icky syntax for this.
16:25:55 <lambdabot> just use enumFrom, dummy
16:26:26 <ayrnieu> ..
16:26:38 <lambdabot> ...well, I guess I don't support it.
16:27:00 <ayrnieu> silly (0:xs) = take 10 (foo 5) : silly xs
16:27:09 <ayrnieu> silly (x:xs) = [x] : silly xs
16:27:11 <ayrnieu> silly [] = []
16:27:33 <ayrnieu> silly :: [Int] -> [[Int]]
16:27:56 <ayrnieu> ben - I still don't understand your question, but does that help you at all?
16:30:16 <det> seems like he just wants a split function
16:30:27 <ben3> i think what i typed above is the best i could do, i'll try and think of how to ask better...
16:30:44 <ben3> yes, a split function
16:31:47 <ben3> i suppose i'll make do with the words in prelude's approach
16:32:24 <ayrnieu> Well, it seemed that he wanted to ask a more general question (particular since he balked at looking at Prelude.words) -- but OK.
16:32:37 <ayrnieu> also, particularly.
16:33:31 <det> seems like Prelude words should be defined as: split ' '
16:33:53 <det> or split isSpace
16:34:08 <Darius> It would be trivial to abstract out the necessary parts from the definition of words.
16:36:16 <juhp> is happy not needed to build ghc (from a release tarball that is)?
16:40:03 <ben3> right... for example, i'd like to start with [[1] (not ending the outermost list, so to be able to add more integers to the innermost list later)... i later decide to add 4 to the innermost list so it's now [[1,4] ... then i decide to make a new list starting with 7 resulting in [[1,4], [7] ... now i think i'm done, so the final result is [[1,4], [7]] where the outermost list is ended
16:40:49 <ben3> replace all i's with f's (a function)
16:45:48 <ayrnieu> juhp - if you have Gentoo, I reccomend letting it build GHC for you.  I've never, not with many tries, ever managed to build GHC in any shape or form without OpenBSD's ports half-doing or Gentoo doing it all.
16:47:25 <juhp> ayrnieu: thanks, but I ask, since I list happy >= 1.13 as a build requirement in my ghc rpm spec file ;-)
16:47:30 <ayrnieu> ben3 - I can think of ways to do that, but no outstanding reason to do so.
16:48:17 <juhp> but someone told me that it is not needed... guess the quickest way to find out is to try to build without happy installed ;)
16:48:38 <juhp> the ghc building docs do list it however
16:48:39 <ayrnieu> ben3 - why you have a function build each sublist and just have it *return* when you decide to build another sublist?
16:48:45 <ayrnieu> also, why don't you.
16:49:13 <juhp> just wondering if it's only needed for cvs builds or something?
16:49:41 <ben3> ayrnieu: not sure what you meant by return?
16:50:07 <ayrnieu> ben - do you understand the concept of flow control?
16:51:28 <ben3> don't think so, looking for that
16:56:07 <juhp> hmm, the gentoo portage doesn't list happy as a ghc build dependency
16:57:09 <Igloo> If you start from the tarball you don't need it
17:13:03 <juhp> Igloo: ok, thanks
17:14:22 <juhp> that was my impression
17:18:34 <SyntaxLaptop> shapr: the smtpclient thing posted to libraries@h.o is probably a good candidate for haskell-libs
17:39:49 <ben3> ayrnieu: could you recommend of anywhere where i could learn more about flow control?
18:25:55 <ayrnieu> ben - a structured programming document, I suppose.  I don't know of any specific tutorials -- I don't even know where I picked it up.
18:26:23 <ayrnieu> ben - or you could learn befunge =)
18:28:41 <ben3> ok, thanks.. will look into befunge :-)
18:44:14 <shapr> SyntaxLaptop: I think Peter Thiemann's WASHMail does that and more, but I will grab it.
18:44:32 <andersca> la la la
18:44:48 <shapr> sleep time
18:44:54 <shapr> it's nearly 4am, and I have to work tomorrow
18:45:13 <ben3> what work? teaching? :-)
18:45:41 <shapr> no, writing web apps for European Union Projects
18:45:57 <shapr> do I look like an academic to you?
18:46:30 <shapr> ben3: here you have shapr and Igloo, now... which one is the academic? http://www.cse.unsw.edu.au/~sseefried/seafood/photos/people/people-Pages/Image8.html
18:46:34 <ben3> ah, well... you've been very friendly to everyone here, so that's why i sort of assumed that you were an academic
18:47:17 <shapr> I had CS101 in 1992 or so.
18:47:20 <ayrnieu> ben - a curious idea.
18:47:50 <shapr> coding is an addiction that I don't want to break
18:48:07 <ben3> Igloo's clearly a genius, a pure one
18:48:25 <shapr> just today I gained new and powerful insights into programming while figuring out this network server thingy.
18:48:30 <shapr> ben3: so, what am I? ;-)
18:48:42 <ben3> you're just average, of course
18:48:47 <shapr> I agree with your assessment of Igloo.
18:49:06 * ben3 is thinking of growing a really long beard
18:49:16 <shapr> I suspect that I am a) plumper than average b) more talkative than average and c) smarter than the average bear.
18:50:12 <ben3> was that at some haskell expo or something?
18:50:23 <shapr> yah, International Conference on Functional Programming
18:50:33 <shapr> in Uppsala, Sweden
18:50:36 <mgoetze> i suspect (b) is an understatement
18:50:42 <shapr> heh
18:50:56 <Riastradh> shapr, specify that to the average _male_.
18:50:59 <shapr> I'm really very shy in person... at least until I get to know you.
18:51:00 <Riastradh> (b)
18:51:01 <ben3> ah, you must know colin runciman then
18:51:13 <shapr> I saw Colin Runciman, but I didn't get to talk to him.
18:51:32 <Riastradh> I'm not shy.  I'm dark, antisocial, reclusive, and broody.
18:51:41 <shapr> I'm just shy.
18:52:09 <Smerdyakov> Riastradh says it like he has some great revelation to share with us.
18:52:15 <shapr> Riastradh: specify what to the average male?
18:52:18 <shapr> Smerdyakov: he does, of course.
18:52:24 <shapr> Smerdyakov: you just haven't realized it yet ;-)
18:52:25 <Riastradh> shapr, specify being more talkative than average.
18:52:53 <mgoetze> Riastradh: just use your telephone and dial shapr's number.... you'll find out :)
18:52:59 <shapr> that's true.
18:53:00 <SyntaxLaptop> shapr: cool :)
18:53:03 <shapr> Riastradh: what's your number?
18:54:24 <Riastradh> 202-456-2461
18:56:24 <shapr> that's a fax or modem number :-P
18:56:43 <ben3> lol
18:56:44 <det> his real number must be off-by-one!
18:57:37 <Riastradh> Yes, it was the first number I found when I Googled.
18:57:43 <shapr> :-P
18:58:02 <Riastradh> I didn't realize it was a fax number, actually, until I typed it here.
18:58:05 <Smerdyakov> Riastradh is very insecure. He wouldn't even reveal his _name_. We had to track it down.
18:58:18 <Riastradh> What do you mean I'd not reveal my name?
18:58:29 <Smerdyakov> You wouldn't tell us your real name.
18:58:56 <Riastradh> It's not rocket science to find my real name.
18:59:26 <Smerdyakov> And that someone changes the truth of my statement?
18:59:27 <Riastradh> If I didn't want to reveal my real name, I'd have used an alias to submit my two SRFIs.
18:59:28 <ayrnieu> Smerdy - indeed?  What name did you find?
18:59:30 <Smerdyakov> s/someone/somehow
18:59:39 <Smerdyakov> Taylor Campbell
18:59:55 <ayrnieu> Ah hah!  Does this name jive with his two submitted SRFIs?
19:00:02 <Riastradh> ...yes.
19:00:31 <Riastradh> And if you ever have an email conversation with me, you'll see my name...
19:00:37 <Smerdyakov> I don't really care. I'm just giving an example of how insecure Riastradh is.
19:00:48 <shapr> that doesn't mean he's insecure
19:00:51 <ayrnieu> smerdy - in that he so easily gives out his name?  I suppose.
19:00:56 <shapr> you don't have enough facts to base that hypothesis on
19:01:02 <Smerdyakov> shapr, but I have additional evidence.
19:01:06 <det> I even found his _pictures_!!
19:01:09 <det> http://www.boobvision.com/models/taylor-campbell.html
19:01:11 <Smerdyakov> shapr, he never reveals anything about himself.
19:01:12 <Riastradh> det, heh.
19:01:16 <ben3> everything sent through irc is in plaintext, we have a right to be careful
19:01:33 <Riastradh> det, are you sure you meant 'his' pictures?
19:01:37 <Smerdyakov> What an ugly face she has.
19:01:42 <ayrnieu> ben - except on IIP, but until freenode moves over there I'll abstain.
19:02:15 <ayrnieu> What does everyone work on, right now?
19:02:23 <shapr> for money? or for fun?
19:02:27 <det> Riastradh: you tell me
19:02:37 <shapr> I'm staring at this partially done POP3 server in Haskell
19:02:38 <ayrnieu> shapr - whichever interests you more =)
19:02:56 <shapr> I had fun playing mental jigsaw with the types today.
19:02:59 <lambdabot> for love!
19:03:14 <shapr> @eval a
19:03:15 <lambdabot> for love!
19:03:18 <shapr> hmm
19:03:20 <Riastradh> det, if they were pictures of _me_, it would be 'he'; but those are pictures of the porn star, which would be 'her.'
19:03:22 <shapr> @get-definition a
19:03:23 <lambdabot> a = "\CRPRIVMSG #haskell :for love!"
19:03:38 <ayrnieu> !!
19:03:43 <Riastradh> @eval "\CPRIVMSG #haskell :boo"
19:03:44 <lambdabot> (line 1, column 3):
19:03:44 <lambdabot> unexpected "C"
19:03:44 <lambdabot> expecting space, "&" or escape code
19:03:48 <Riastradh> ...
19:03:59 <ayrnieu> @get-definition b
19:04:00 <det> CR
19:04:00 <lambdabot> b not defined
19:04:02 <Riastradh> @define boo "\CPRIVMSG #haskell :boo"
19:04:03 <lambdabot> (line 1, column 4):
19:04:03 <lambdabot> unexpected "C"
19:04:03 <lambdabot> expecting space, "&" or escape code
19:04:12 <ayrnieu> @set-definition b "\CPRIVMSG #haskell :boo"
19:04:13 <lambdabot> Sorry, I don't know the command "set-definition", try "lambdabot: @listcommands"
19:04:17 <ayrnieu> @listcommands
19:04:18 <lambdabot> I react to the following commands: ["all-dicts","arr","define","definitions","del-definition","devils","dict","dict-help","dummy","dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements","eval","foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","lojban","more","msg","part","prelude","quit","reconne
19:04:19 <det> @eval "\CRNICK lambdaownt\CRNICK lambdabot"
19:04:25 <shapr> oy
19:04:26 <Smerdyakov> Someone is spamming our fine channel.
19:04:41 <Riastradh> Oh, \CR, not \C.
19:04:45 * ayrnieu hums at 'lojban'.
19:05:03 <Smerdyakov> @eval "\\CPRIVMSG #haskell :boo"
19:05:04 <lambdabot> \CPRIVMSG #haskell :boo
19:05:16 <shapr> ayrnieu: @lojban probably won't work since lojban.org shutdown their dictd server.
19:05:16 <Smerdyakov> There.
19:05:18 <Riastradh> @eval "\CRPRIVMSG #haskell :boo"
19:05:18 <lambdabot> boo
19:05:21 <det> Smerdyakov: didnt do it
19:05:27 <ayrnieu> shapr - aww.  OK.
19:05:31 <Smerdyakov> It did exactly what I wanted it to do.
19:05:34 <det> oh
19:05:37 <shapr> but, @cmafihe should work
19:05:39 <shapr> @cmafihe cilre
19:05:40 <lambdabot> Sorry, I don't know the command "cmafihe", try "lambdabot: @listcommands"
19:05:42 <shapr> oops
19:05:47 <shapr> where's the plugin?
19:05:51 <Riastradh> It should, should it?
19:06:05 <shapr> I'll fix that tomorrow, along with @eval escape codes
19:06:06 <ayrnieu> @eval "\CRPRIVMSG ayrnieu Can anyone do this, or just people on #Haskell?  How about privately to the bot?"
19:06:18 <det> you need a colon
19:06:25 <ayrnieu> Indeed.  It only messaged me a 'Can'.
19:06:27 <det> you probally just got "Can"
19:06:30 <Smerdyakov> @eval "\CQUIT"
19:06:31 <lambdabot> (line 1, column 3):
19:06:31 <lambdabot> unexpected "C"
19:06:31 <lambdabot> expecting space, "&" or escape code
19:06:41 <shapr> Smerdyakov: that wouldn't be nice
19:06:42 <Smerdyakov> @eval "\CRQUIT"
19:06:45 <Smerdyakov> Hahaha
19:07:09 --- mode: mgoetze set +o lambdabot
19:07:14 <shapr> uh oh
19:07:22 <det> @eval "\CRMODE #haskell +o det"
19:07:23 --- mode: lambdabot set +o det
19:07:25 --- mode: ChanServ set +o shapr
19:07:28 <det> :p
19:07:29 --- mode: shapr set -o lambdabot
19:07:34 <mgoetze> fun :)
19:07:36 <shapr> :-P
19:07:39 --- mode: det set -o det
19:07:40 <Smerdyakov> @eval "\CRMODE #haskell +l 128957"
19:07:42 --- mode: mgoetze set -ot shapr
19:07:42 --- mode: ChanServ set +o shapr
19:07:50 --- mode: mgoetze set -o det
19:07:52 <mgoetze> oops
19:07:58 <ayrnieu> typo, sadly: /msg lambdabot @eval "\CRKICK #haskell smerdyakov: leave me alone!
19:07:58 <shapr> what's -t shapr?
19:07:59 --- mode: mgoetze set +t
19:08:07 <mgoetze> i meant -oo shapr det
19:08:09 <Riastradh> shapr, no, it's -o shapr, -t.
19:08:10 <shapr> oh
19:08:38 <shapr> well, if people can keep from abusing the 'bot till tomorrow, I'll leave it up.
19:09:08 <mgoetze> hm.... i won't op it again... i think :)
19:09:13 * shapr gins
19:09:16 <det> @eval "\CRPRIVMSG #haskell :\SOHACTION abuses shapr\SOH"
19:09:16 * lambdabot abuses shapr
19:09:16 <shapr> um "grins"
19:09:20 * shapr snickers
19:09:21 * Riastradh tonics.
19:09:51 <Smerdyakov> @eval "\CRPRIVMSG #haskell :\SOHPING\SOH"
19:10:02 <mgoetze> hm :)
19:10:29 <lambdabot> OK, stop it.  Go program something!
19:11:02 <lambdabot> Hack, don't exploit lambdabot!
19:11:23 --- mode: mgoetze set -o shapr
19:11:36 <mgoetze> you won't be needing that ;)
19:11:45 <ayrnieu> (coup de robot?  Who holds the shotgun?)
19:11:53 <Smerdyakov> sploits sploits sploits!
19:12:23 * ayrnieu takes his own advice and goes to program something
19:12:31 <lambdabot> !stiolps stiolps stiolps
19:13:35 <ben3> is haskell really that addictive?
19:13:52 <ayrnieu> ben - I don't follow you, sorry.
19:14:16 <Riastradh> Join us or return!
19:14:20 <ben3> well, i don't want to get addicted to anything... just trying to be careful with my precious life
19:14:23 <Riastradh> Or eta.
19:14:37 <ayrnieu> ben - eh, OK.
19:14:39 <shapr> ben3: if you get addicted to haskell, you get paid lots of money to be a high-level programmer.
19:14:47 <shapr> so it has its advantages.
19:14:59 <Smerdyakov> High-level programmer? Pshaw.
19:15:06 <ben3> money? high-level programmer? in visual basic you mean?
19:15:08 <Smerdyakov> You can get paid lots of money to be a computer scientist.
19:15:26 <shapr> until I become as rich as Smerdyakov, I shall continue being a high-level programmer.
19:15:37 * juhp reaches for his fpl fix ;)
19:15:41 * shapr laughs
19:16:03 <shapr> ben3: actually, I get paid to write Python.
19:16:23 <shapr> but the concepts and strategies I've been applying recently I learned from Haskell.
19:16:59 <ben3> not a fan of perl then?
19:17:04 <ben3> or even ruby?
19:17:05 <ayrnieu> Haskell's expressivity makes it sometimes easier to write data-manipulating functions in Haskell and then translate these to the language in question.
19:17:32 <ayrnieu> ben - I like all of Perl and Ruby and Python and Haskell.  Please don't draw a dislike from a like.
19:17:34 <ben3> ayrnieu: how can you when most other languages aren't lazy?
19:17:36 <Smerdyakov> shapr, if I'm richer than you are, then you've fucked up your career horribly. :D
19:17:59 <shapr> Smerdyakov: I think that was the point of what I said, though I meant it a bit more tactfully.
19:18:02 <ayrnieu> ben - because Haskell's expressivity extends to more than just usefully lazy expressions.
19:18:26 <shapr> Smerdyakov: on the good side, a PhD in CS can get you a high-paying job.
19:18:37 <ayrnieu> For instance, I had to stop and write some ragged-matrix functions in Haskell whilst writing an Erlang program.
19:19:46 <ayrnieu> ben - take a look at the Evolution of a Haskell Programmer, if you haven't seen it yet.
19:21:58 <shapr> ben3: the Sapir-Whorf hypothesis can be paraphrased as "How you can speak affects how you can think"; Procedural, Functional and Logic/Constraint and the major programming flavors from my viewpoint. Each of those has strong and weak points in any given situation. It's best to know something about all of them.
19:22:37 <shapr> anyways, I'm off to sleep
19:22:43 <mgoetze> gnight shapr 
19:22:53 <ayrnieu> (A particularly bad restatement, on the face of it.  It suggests that people with lisps think differently)
19:22:57 <shapr> g'night mgoetze 
19:23:14 <ayrnieu> g'night shapr.
19:25:39 <ben3> google's returned many funny articles under that title
19:42:58 <ben3> um, why doesn't hugs have readline by default?
19:43:17 <Smerdyakov> Because everyone uses it in emacs.
19:43:40 <ben3> would be nice to have it in hugs too
19:45:20 <mgoetze> yeah, hugs is for emacs users, real mean use vim and ghc(i) :)
19:45:54 <Riastradh> Everyone uses GHCi in Emacs, too.
19:46:03 <Riastradh> Except for the rare vi dweeb.
19:46:34 <ben3> mgoetze: i use vim, so why should i use ghci?
19:47:04 <mgoetze> ben3: you may use ghc directly if you like ;)
19:47:06 <Smerdyakov> Let's start the countdown until I'm done with the semester. It stands at a little over 21 hours now.
19:50:00 <ben3> your finishes on a monday?
19:50:25 <Smerdyakov> Yes, dated at the deadline time of my last assignment.
19:52:15 * ayrnieu has four days until Christmas break.  mmm.
20:17:43 <stepcut> is there a way to add new syntax constructs to ghc, like what camlp4 does for ocaml?
20:19:14 <ayrnieu> stepcut - not like what camlp4 does for O'Caml, no.
20:19:28 <stepcut> too bad
20:20:04 <ayrnieu> Perhaps if you had a more specific task in mind, you wouldn't find it so saddening.
20:21:14 <stepcut> I do, I want to be able to write (x = 4, b = 5, e = 5) and then translate it in to something haskell actually understands at compile time
20:21:46 <ayrnieu> Write that in what context?  Have Haskell understand it as what?  Why?
20:21:59 <stepcut> like a list of tuples [("x",4),("b",5), ("e",5)]
20:22:11 <ayrnieu> Totally not what I expected, but OK.
20:22:19 <ayrnieu> You may want to look at Template Haskell.
20:22:33 <stepcut> i would like to be able to use the first expressions as a synonym for the second expression
20:23:12 <stepcut> I have been looking at Template Haskell, but it can only manipulate valid haskell syntax, not extend it
20:23:31 <ayrnieu> OK.
20:23:33 <stepcut> since haskell can't parse the first expression, I can't use th to transform it into the second
20:24:41 <stepcut> which is too bad -- if it could you could (for example) probably implement Trex in template haskell
20:25:11 <ayrnieu> Trex?
20:25:22 <stepcut> extensible records -- a hugs only extension
20:26:15 <stepcut> there has been talk about adding something similar to ghc for a while now, but difficultly on agreeing to what is the best
22:03:29 <harsha123> hello #haskell
22:04:58 <ayrnieu> hello harsha.
22:05:16 <Flarelocke> hello, harsha123
22:37:15 * isomer is away: zozo
