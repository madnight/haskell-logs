00:04:47 <sjj> @yow
00:04:49 <lambdabot> Then, it's off to RED CHINA!!
00:10:02 <lambdabot> sjj: @yow
00:10:24 <sjj> heh ;)
00:10:51 <lambdabot> sjj: try harder!
00:10:58 <lambdabot> sjj: @yow
00:13:36 * lambdabot whips sjj
00:13:41 <lambdabot> sjj: @yow
00:15:19 <sjj> I'm GLAD I remembered to XEROX all my UNDERSHIRTS!!
00:30:13 * det laughs :)
01:37:22 * Marvin-- sighs
01:38:11 <shrimpx> hi
01:40:04 <Marvin--> morning
01:40:14 <phubuh> http://www.google.se/search?hl=en&ie=UTF-8&oe=UTF-8&q=miserable+failure&btnG=Google+Search
01:40:16 <phubuh> heh heh.
01:40:54 <Marvin--> *sigh* :)
01:41:08 <andersca> old news
01:41:55 * Marvin-- wishes he knew how to get this to work
01:47:42 <Marvin--> fuck, I'm *never* going to finish this
01:47:52 <Marvin--> time to introduce a new arbitrary limitation
04:16:28 <shapr> yeehaa
04:16:51 <aleator> shapr: Is there anything more lame than wikihackers?
04:17:10 <shapr> not that I can think of
04:17:30 <shapr> HaWiki isn't the first: http://c2.com/cgi-bin/wiki?WikiVandals
04:19:12 <Lunar^> HaWiki has been vandalised ?
04:19:47 <aleator> mine got it's share also few days ago.. Mean I can raise some grumbling respect towards people that break in real computers. But people that think they are l33t hackers when they find an EditPage link..
04:19:56 <vegai> oh, people really do that? :(
04:20:00 <Lunar^> *sigh* how lame
04:23:31 <aleator> One can truly never underestimate how stupid people can be.
04:23:48 <shapr> yup
04:24:21 <aleator> shapr: But on a lighter note - there is an improved version of TauTau available - 3d robots. :)
04:24:29 <shapr> neat!
04:24:51 <shapr> what's the url again? (for advertising purposes :-)
04:26:07 * Marvin-- swears at his bank's broken homepage
04:26:18 <aleator> shapr: http://cocoon.it.jyu.fi/~aleator/moinwiki/index.cgi/TauTau
04:26:29 * aleator takes a quick backup of the wiki.. 
04:26:33 <shapr> oh, I like the new tank models
04:26:55 <aleator> Yup. We did a blender script that exports directly to haskell code :)
04:27:42 <shapr> is http://www.jyu.fi/~aleator/ttd.tar.gz the latest binary?
04:27:47 <aleator> I don't know if anyone will ever play it, but I/We are sure having fun making it.
04:28:16 <aleator> shapr: Should be.
04:28:20 <shapr> cool
04:29:11 <aleator> Soon we will add a radio to the game - so that the robots can talk to each other and form teams and so on..
04:32:16 <shapr> the new models are nice
04:32:37 <aleator> Thanks.
04:33:04 <aleator> The square trees might need a bit improvement though :)
04:33:12 <shapr> oh, those are trees?
04:33:34 <shapr> I thought it was ice-blocks on the border
04:33:50 <shapr> and some sort of tron-style crystal thingies in the middle of the board
04:33:56 <aleator> No, I meant the green spinning thingies :)
04:34:54 <shapr> are the board control documented somewhere?
04:41:04 <aleator> Humm.. Somewhere, yes, in finnish. They are ijkl, esdf, gh and t. It should be easy enough to experiment.
04:56:26 <Marvin--> god I hate my bank's homepage
04:56:59 <vegai> don't hate the player, hate the game ;P
05:03:04 <Marvin--> riight, so the page that should let me calculate my IBAN number is horribly broken and uses an insane combination of java and javascripts
05:04:08 <Marvin--> guess I'll have to *call* the bank instead (dear god)
06:26:48 * SyntaxNinja pokes Igloo for having an RC bug ;)
06:28:58 <Marvin--> meh, I need to fix my RC bug too
06:29:33 <Marvin--> stupid latex2html crud
06:34:27 <SyntaxNinja> heh
06:38:07 <Marvin--> argh, stupid metacity keeps crashing
06:54:17 <Igloo> Is that the one I fixed yesterday or a new one?
06:55:52 <SyntaxNinja> you posted on it today. the MD5 sum thing
06:56:00 <SyntaxNinja> I know you know about it :-)
06:56:27 <Igloo> It's fixed, just discussion on whether my fix is right  :-)
06:57:33 <SyntaxNinja> does that mean I can't make fun of you?
06:58:35 <Igloo> Not at all, feel free
06:58:54 <Igloo> After all, I make fun of your entire nation often enough  :-)
07:04:56 <SyntaxNinja> Igloo: don't get me started on my nation!
07:05:04 <Igloo> lol
07:05:39 <SyntaxNinja> we're going to need international observers for the next election ;)
07:06:27 <Marvin--> hell yeah
07:08:32 <Marvin--> dear god this is painful
07:18:26 <harsha123> SyntaxNinja: where are you from ? ;-)
07:23:33 <SyntaxNinja> harsha123: I'm in no danger telling you this: Ohio ;)
07:48:28 <Marvin--> yay, curling
08:08:08 <shapr> @fortune
08:08:09 <lambdabot> ... If I had heart failure right now, I couldn't be a more fortunate man!!
08:10:45 <keverets> @arr
08:10:46 <lambdabot> Smartly me lass
08:21:29 <SyntaxNinja> @yow
08:21:30 <lambdabot> Yow!!  It's LIBERACE and TUESDAY WELD!!  High on a HILL... driving a
08:21:30 <lambdabot>  LITTLE CAR...  I wanna be in that LITTLE CAR, too!!  I wanna drive off
08:21:30 <lambdabot>  with LIBBY and TUESDAY!
08:32:05 * Marvin-- almost feels sorry for the scots
08:36:32 <Smerdyakov> O(n^12.125)?
12:21:52 <yazirian> http://www.pbase.com/images/24017078.original.jpg
12:23:09 <opet> lol
12:23:21 <Igloo> Cute
13:33:22 <lambdabot> I'm GLAD I rememebered to XEROX all my UNDERSHIRTS!!
13:35:03 * Arnia pats lambdabot on the head
14:14:58 <Lor> How does one generate the fancy ligature >>= -symbols that one sees in pretty-printed haskell programs?
14:21:17 <Marvin--> insert \mkern stuff between the characters I guess
14:21:32 <Marvin--> from haskell.sty: \newcommand{\hsapp}{\mathbin{+\mkern-7mu+}}
14:23:34 <Lor> Yeah, just found out from lhs2tex.sty
14:23:56 <Lor> Complicated.
14:24:09 <Lor> I was hoping of figuring out how to do the same sort of thing vertically.
14:24:37 * Lor wishes all cs papers would come with the source...
14:25:10 <Lor> I'd like to do a \leadsto (squiggly arrow) with a short expression (n+1) above it.
14:26:06 <Marvin--> \stackrel or something like that?
14:26:23 <Lor> Hm. Cool.
14:26:25 <Lor> Thanks.
14:26:53 <Marvin--> I don't recall how it works, but I think it's something like that :)
14:29:27 <Lor> Hey, whee, it works!
14:29:39 <Darius> This has got to be the longest function I have ever written.
14:29:48 <Lor> So break it down.
14:30:08 <Lor> It's, what, a whopping ten lines? :)
14:30:26 <Darius> More like 801
14:30:47 <Lor> Golly. Is this fortran or what?
14:31:58 <Marvin--> heh, I often keep putting helper function after helper function in a humongous where clause until I realize "hell, I want to test these functions separately" and I have to put them at top level anyway
14:32:18 <Darius> It's a giant case-analysis with very imperative Haskell and a low level of abstraction.
14:32:55 <Darius> I could break it apart on the cases, but that wouldn't gain much in usuability (though it might cut down on the compile-times).
14:33:12 <wuuru> Darius: a you demoncrat?
14:33:14 <Lor> marvin, I think that's a real problem. On one hand, you want to have the common context, but you'd also want the function to be separately accessible.
14:33:17 <wuuru> Darius: are you demoncrat?
14:33:35 <Lor> First-class modules are the answer.
14:33:41 <Lor> Or something simpler but similar.
14:34:27 <Marvin--> Lor: yeah, I usually end up sticking the whole thing in a separate module with a short export list
14:34:40 <Darius> wuuru: No. /whois Darius
14:35:02 <wuuru> ah...
14:35:57 <Lor> There's some fundamental scoping functionality lacking from ML, _and_ Haskell, _and_ scheme and whatnot. I don't quite understand why it is so.
14:42:50 <Darius> Hmm, I can't make direct threaded code, but I could make indirect threaded code, which would require breaking each case into a separate function.
14:42:59 <Riastradh> Lor, ?
14:43:37 <Lor> It's a bit hard to explain.
14:44:03 <Lor> Essentially, I'd like, well, structures that shared a common scope.
14:44:21 <Lor> But they should be parameterizable by _run-time values_ and not just some compile time module parameters.
14:44:35 <Riastradh> 'Structures' in what sense?
14:44:46 <Riastradh> ML structures?  Record structures?
14:44:57 <Lor> Something that's a bit of both.
14:45:18 <Lor> I'd like to say (foo bar).baz 
14:46:08 <Lor> Of course something like this could be crudely simulated by haskell "records", but it's not pretty.
14:46:32 <Riastradh> Er, that's not lacking for ML, and I don't see why it couldn't just as easily be done with typeclasses.
14:46:38 <Lor> I'd like to be able to define the members as simple definitions with shared scope (ie. mutually recursive).
14:46:46 <Riastradh> s/ML/SML/1
14:47:00 <Lor> Yes, SML has records.
14:47:16 <Darius> Lor: What is an example of what you'd be able to write with this?
14:47:42 <Lor> Run-time parameterizable modules.
14:48:10 <Lor> I'd use it everywhere.
14:49:35 <Riastradh> Lor, http://www.bloodandcoffee.net/campbell/code/lexmod.scm
14:49:53 <Darius> Riastradh: That's what I was thinking of.
14:50:16 <Riastradh> Just because Scheme 'lacks' it doesn't mean it's impossible in Scheme.  (Macros complicate the situation; lexmod doesn't support them, and thus it is possible for it to be run-time.)
14:50:46 <Lor> I didn't say it's impossible.
14:51:02 <Riastradh> In SML, you've got its records.  In Haskell, well, sucks for you!
14:51:34 <Lor> But that particular way of solving it is a bit ugly, since you move name resolution from compile time into runtime.
14:51:39 <Riastradh> Lor, you said 'there's some fundamental scoping functionality lacking from Scheme.'  That 'fundamental' implies that it is fundamentally impossible to have this.
14:52:12 <Riastradh> How would it work for name resolution to happen at compile-time?
14:52:20 <Riastradh> The module itself is not known at compile-time.
14:52:22 <Lor> Good question. You need types. :)
14:53:20 <Riastradh> OK, specify further what you mean by 'name resolution.'
14:53:42 <Lor> But I'll admit that that's not a particularly essential point here..
14:54:27 <Riastradh> If you're worried about the run-time overhead of name lookup, then use the DEFINE-IMPORTS that will be among the dazzling amazingness of the next lexmod release.
14:54:35 <Riastradh> Or LET-IMPORTS, which is already there.
14:54:36 <Lor> Riastradh, well, if you do a symbol table lookup at runtime, it's clearly a form of name resolution. If you knew the type of the module you could resolve the name into an offset at compile time.
14:55:32 <Lor> The efficiency doesn't really bother me.
14:55:39 <Riastradh> Yes, I see what you're saying now, but I don't think it really matters enough to...well, matter.
14:56:20 <Lor> What bothers me is that names are a compile-time concept and you aren't really doing reflection or anything hairy enough to warrant reifying them to runtime.
14:56:33 <Lor> Can't say that I could offer a better solution in scheme, though.
14:57:57 <Lor> In general I'm bothered by the fact that scheme doesn't have compound names. All the prefixes that are based on symbol munging are a bit ugly.
14:58:26 <Riastradh> 'Compound names?'
14:59:23 <Lor> When you have modules, the namespace gets structured. The names should be structured as well.
14:59:31 <Riastradh> As in qualified names, or Foo.bar in Haskell?
14:59:33 <Lor> So module.name or something similar.
15:00:16 <Riastradh> Lexmod _has_ qualified names: (@module 'name).
15:01:16 <Lor> Yes. I was commenting on plain scheme.
15:01:29 <Lor> And you have to admit that your syntax is a bit of a hack.
15:01:35 <Riastradh> No, I don't have to admit that.
15:02:01 <Lor> Suit yourself. :)
15:02:05 <Riastradh> I sha'n't admit it.  My syntax is not a hack at all; it is _less_ of a hack than kluding extra lexical syntax onto symbol names to attempt to infest ordinary code with module metadata.
15:03:08 <det> clearly lexmod is the work of the devil.
15:03:11 <Riastradh> I'm no fan of qualified names at all, in fact, _unless_ they're _specifically_ for run-time module stuff, i.e. what you'd use lexmod for; module metadata should _not_ infest ordinary code.  Module _metadata_ is at an entirely different level than code _data_; they should not be combined.
15:03:28 <Riastradh> det, that would make me far too cool.
15:03:40 <Lor> Uh, what is this metadata you're talking about?
15:03:43 <Riastradh> Or hot, I guess.
15:04:15 <Riastradh> Lor, module metadata is the data that tells the module system how to interpret (in the literal sense, not in the sense of a code interpreter) some code.
15:04:59 <Riastradh> It tells the module system what other modules this module uses, what this module exports, maybe what compiler flags to use, what files the source code of this module is in, et cetera.
15:05:23 <Lor> Yes, right.
15:05:32 <Lor> So what does this have to do with having structured names?
15:05:41 <Riastradh> Qualified names are part of that metadata!
15:05:47 <Riastradh> They say 'this name is from that module.'
15:06:02 <Lor> Ah, right.
15:06:38 <Lor> You're advocating using imported rather than qualified names?
15:06:42 <Riastradh> Yes.
15:07:13 <Lor> Many would disagree with you, and claim that that makes the code less legible since it isn't immediately clear where is the definition of the variable you're using.
15:07:19 <Riastradh> _Unless_ you're specifically passing modules about at run-time, e.g. when using lexmod.  (Unless you're using lexmod as an ordinary module system, but I don't think that many people are.)
15:07:53 <Riastradh> If the variable is properly named and your modules are well laid out, then you won't have any problems.
15:08:05 <Lor> Personally, I find it rather tedious, having to explicitly write into an imports list all the variables I'm going to import from some module.
15:08:39 <Riastradh> You don't need to in good module systems.  (In lexmod, you do, but that's because there's no way to manipulate lexmods at macro-expand-time to generate all the names.)
15:09:09 <Lor> Uh, if you don't either list the imports or use qualified names, then what? Import everything from a module unqualified?
15:09:21 <Riastradh> Yes.
15:09:23 <Lor> Ick.
15:09:26 <Riastradh> Ick?
15:09:26 <Lor> That's bad style, if anything.
15:09:29 <Riastradh> Why?
15:09:47 <Lor> Because then you no longer have any idea about where some variable might be defined.
15:10:15 <Lor> Just looking at the source file you may find out that it is not defined there, but then you have to start guessing in which of the imported modules it might be defined.
15:10:29 <Riastradh> Keep your modules small so your list of imports will be small enough to easily find it: this is good practice anyways.  Keep your modules well organized so you can easily find the interface that defines the name: this is good practice anyways, too.
15:10:31 <Lor> And if there are transitive imports, then, well, eek.
15:11:06 <Riastradh> Transitive imports?
15:11:26 <Riastradh> Oh, modules that import FOO from another module and export FOO as well?
15:11:26 <Darius> If you aren't the author of a module you are importing, and the author later adds an identifier you're using then you're code will break.
15:11:28 <Lor> Maybe transitive exports would be better. I mean a module exporting something that it imports.
15:12:03 <Lor> Good point.
15:12:42 <Riastradh> Darius, not if DEFINE is well-defined.  DEFINE in Scheme (assuming the module system regards the names R5RS defines just like the names that modules import) will work even if the name it defines is already defined from another module; it will simply create a new binding and not overwrite the old binding or bork or anything.
15:13:18 <Lor> That will break even worse.
15:13:21 <Riastradh> ?
15:13:28 <Darius> I agree with Lor.
15:13:43 <Lor> I just had to hunt a bloody bug in ocaml code because of that.
15:13:52 <Riastradh> A module M1 defines FOO and BAR; BAR uses FOO.  A module M2 imports M1 and uses BAR, and also defines FOO for its own internal use.  Nothing will break; BAR will use the right FOO.  M2 will use its own FOO.
15:13:54 <Lor> It imported two modules and used a function that appeared in both.
15:14:00 <Riastradh> That's different.
15:14:05 <Lor> When the code was written, it only appeared in the first imported module.
15:14:18 <Lor> Then the second module also added the same name, and boom.
15:14:33 <Riastradh> And boom, the compiler noted 'hey, clashing imports, fix that?'
15:14:39 <Darius> Another situation is you are importing two modules made by two independent entities and they both define the same identifier.
15:14:40 <Lor> Not in ocaml.
15:14:50 <Lor> It just quietly shadowed the first one.
15:15:17 <Riastradh> Oh, right, OCaml's module system is dumb, too, and intermingles module code and source code.
15:15:26 <Lor> Eh?
15:16:21 <Riastradh> In a module's body, which allegedly contains its source code, you use 'open' to import names from other modules, as if 'open' were ordinary source code.
15:17:04 <Lor> Hm, in a way, yes.
15:17:08 <Riastradh> Presumably it's very dumb and goes through the 'open's sequentially and expanding them to 'let's, or something similar.
15:17:13 <Lor> But thinking like that, "define-public" etc would do the same.
15:17:18 <Riastradh> ?
15:17:31 <Riastradh> DEFINE-PUBLIC?
15:17:32 <Lor> define-public is like define that adds the defined name to the export list.
15:18:00 <Riastradh> That would be infiltrating ordinary source code with module metadata.
15:18:12 <Lor> Why is that bad?
15:18:19 <Riastradh> ...
15:18:34 <Lor> The intendend visibility of a function is an inherent part of its design.
15:18:40 <det> Riastradh: I think using open in Ocaml is generally considered a bad thing, as is using import * in python .. for this very reason
15:18:40 <Riastradh> No.
15:18:54 <Riastradh> It's an inherent part of the _module_'s design.
15:19:15 <Lor> I can understand why you'd want to make it _possible_ to separate these two concepts, but why enforce it?
15:19:26 <Riastradh> What if I want two modules that use the same source code and everything else, but export different things?  This would allow me to have a 'general' interface, and an 'internal' interface, without duplicating source code.
15:19:41 <Riastradh> DEFINE-PUBLIC wouldn't make sense; which module would it add the name to the export list of?
15:20:22 <Lor> So put all the source in one module that exports everything, and have the two modules import that one and let each export what's proper for it.
15:20:54 <Lor> Again, I can understand that you want to support cases like that, but why enforce the separation?
15:21:17 <Lor> If I add a new function to a module, in most cases it's just extra work having to go to the top of the file (or wherever) and add an entry to the export list.
15:21:32 <det> Riastradh: are you saying your example can't be done in some other language ?
15:21:44 <Lor> _Most_ modules, I dare wager, are quite simple and straightforward in this sense.
15:21:44 <Riastradh> Oh dear.  What a calamity.  You must write one more thing in a list of exports.
15:22:01 <Lor> It's not a big deal, but I don't see why that should be compulsory.
15:22:18 <Lor> Except that if someone is reading the source, it's nice to see all the exports in one place.
15:22:47 <Lor> But autogenerated documentation could fix that as well.
15:22:51 <Lor> (As is done in eg. java)
15:23:09 <Riastradh> det, ?
15:23:26 <det> "What if I want two ..."
15:24:03 <Riastradh> det, no, I'm not saying it's impossible in every language but Scheme.  I'm saying that that's a very useful thing to be able to do in a module system, whatever language it be for.
15:24:24 <Riastradh> Lor, and now, if you had three modules, you'd still have to add stuff to the export lists.
15:25:16 <det> oh, I was just going to point out how easily it is dome in *ml, but I have lost track of time
15:25:26 <det> I must go
15:25:29 <det> g'day
15:25:58 <Lor> Riastradh, not in the underlying module, which could just export everything.
15:26:21 <Riastradh> Lor, sure, not in the module that exports everything, but in one or both of the other two.
15:26:24 <Lor> But still, I think this is a fairly rare situation. The convenience of common cases ought to be important.
15:26:31 <Lor> Riastradh, yes. So?
15:26:46 <Riastradh> So your point about adding things to export lists is moot.
15:26:54 <Lor> Why?
15:27:07 <Riastradh> There's no difference between my ideal module system and your ideal module system regarding it.
15:27:08 <Lor> I didn't say that export lists could always be avoided. Just that often they can.
15:27:48 <Riastradh> There's still no difference.  My idea doesn't preclude a special EXPORT-ALL interface.
15:28:07 <Lor> But it does preclude a define-public.
15:29:15 <Riastradh> Why is DEFINE-PUBLIC _any_better_ than maintaining a separate export list?  It helps join module metadata and source data, it precludes having multiple modules with everything but interface the same, and I don't see any advantages to using it.
15:30:15 <Lor> How does it preclude that?
15:30:27 <Riastradh> What module does it add to the export list of?
15:30:54 <Riastradh> If you were to use your idea of three modules, why would it be necessary at all?
15:30:55 <Lor> The innermost one it is being defined in.
15:31:39 <Lor> Your entire argument seems to be based on this fairly unusual case of two modules sharing _code_ (instead of modules).
15:31:58 <Lor> I'm not precluding that at all, I just want a convenient way of defining straightforward simple modules.
15:32:05 <Riastradh> You seem to be bad at determining what my entire argument is.
15:32:16 <Lor> Well, yes.
15:32:44 <Lor> I'm just arguing for an additional feature. You seem to be dissing it because it doesn't solve all export problems.
15:32:50 <Riastradh> First, it is not a 'fairly unusual case'; I have seen it quite a lot, used it quite a lot, and found it very useful in testing and debugging.  Second, it is only a _part_ of my argument.
15:33:13 <Riastradh> You're arguing for an additional and _unnecessary_ feature; I don't see why you're arguing for it at all.
15:33:24 <Lor> Plain and simple: convenience.
15:33:39 <Riastradh> How is it more convenient to write -PUBLIC than to write another name in an export list?
15:33:51 <Lor> The export list is further from the definition.
15:34:03 <Riastradh> The difference might be by a few characters.  The difference might be that you use a key sequence to add it automatically rather than writing out -PUBLIC.
15:34:09 <Riastradh> Does that difference really _matter_?
15:34:23 <Lor> In addition, if you rename the entries, then you have to rename them in many places.
15:34:35 <Lor> The same for moving a definition into another module.
15:35:04 <blacksheep> hey! could someone pointed me out to the sdl bindings for haskell project?
15:35:16 <blacksheep> and others graphical bindings for haskell projects?
15:35:16 <Riastradh> For renaming, with DEFINE-PUBLIC, you'd have to rename it one fewer time than with my preference.
15:35:48 <Riastradh> For moving it into another module, you'd have to change some imports _anyways_, and you'd have to do one more step of changing the export lists.
15:36:51 <Lor> Might have to change imports, not necessarily.
15:37:00 <Lor> But anyway, this seems to me to me mostly a matter of taste.
15:37:02 <Riastradh> ?
15:37:16 <Lor> I don't see what's so disruptive about having a convenience for those who prefer it.
15:37:26 <Riastradh> How is it a convenience?
15:38:11 <Riastradh> It is not much more convenient at all than separately maintaining export lists and it is an annoyance when in the presence of multiple modules using the same source code but with different interfaces.
15:38:12 <Lor> I just explained. You may not think that these particular conveniences are very significant, and that's ok.
15:38:46 <Lor> How, btw, would you do multiple modules with the same source?
15:39:01 <Riastradh> (define-structures ((module1 module1-interface) (module2 module2-interface) ...)
15:39:13 <Riastradh>   (open scheme srfi-n whatever etc)
15:39:32 <Riastradh>   (optimize auto-integrate) ;just throw some more module metadata in
15:39:46 <Riastradh>   (files source-file1 source-file2))
15:39:51 <Lor> All right, so just forbid define-public when you're defining more than one module.
15:40:07 <Riastradh> But why have it at all?
15:40:48 <Riastradh> The difference in convenience lacks significance and you have said nothing to convince anyone otherwis.e
15:41:41 <Lor> That's all right.
15:41:49 <Lor> I'm not trying to force anyone to use it, after all.
15:42:10 <Riastradh> Yes, but you might as well give some rationale.
15:43:04 <Lor> I have given what I can give you. When defining simple modules and reading and writing its source, to me it's nice to keep its visibility specification next to its definition and documentation.
15:43:54 <Lor> Moving it elsewhere means I have to look in multiple places to see and change all the things related to that binding.
15:45:28 <Darius> blacksheep: http://www.haskell.org/hawiki/LibrariesAndTools http://www.haskell.org/libraries/#graphics There are actually several SDL bindings but they are typically for a particular project and not widely announced.
15:45:31 <Riastradh> That's really not an inconvenience at all: just have two buffers open, one for the source code and one for the module definitions files; it also _easily_allows_ for multiple modules with the same metadata other than interface, and you don't have to switch between the two locations of module export information when you just change the number of modules that use certian data.
15:45:44 <Riastradh> s/metadata/anydata/1, s/certian/certain/1
15:47:22 <Lor> Each with his own style.
15:47:51 <Lor> Both the harms and the benefits of either style are so insignificant, that I really don't see the point of arguing about it.
15:48:19 <Riastradh> That's not what I'm saying.  What bugs me is that you'd have to suddenly switch styles when you start using the multiple modules thing.
15:49:13 <Lor> Granted, it's a risk.
15:49:24 <Lor> Otoh, you could just make the new module a part of the old one.
15:49:31 <Lor> Or something similar.
15:49:44 <Riastradh> ?
15:50:19 <Lor> Define the new module inside the old one. Just say what you want to export from that, and all the variables are already in scope.
15:50:53 <Riastradh> By the way, out of 346 module definitions (excluding parametrizable modules) in the Scheme48 source, 256 define single modules and 90 define multiple modules.
15:51:06 <Lor> Fair enough.
15:51:06 <blacksheep> hey! i am pretty newbie in Haskell, but I have made some simple C bindings for OpenGL. If anyone is interested here is the website: http://rpmcruz.planetaclix.pt/haskell-gl/ . Enjoy! :)
15:51:07 * Riastradh doesn't get it.
15:51:15 <Lor> Once you adopt a style, you're likely to use it.
15:51:32 <Lor> If that wasn't possible in scheme48, it wouldn't be used.
15:51:43 <Riastradh> Yes, a good FORTRAN programmer can write FORTRAN in any language, but that doesn't mean it should be encouraged.
15:52:30 <Riastradh> Oh, and this is not only Scheme48 but also the Pre-Scheme compiler.
15:52:57 <Lor> But the multiple interfaces _could_ as well be implemented by having an internal module that both modules import.
15:53:19 <Lor> Perhaps scheme48 makes this situation a bit more convenient. Okay, nice.
15:53:23 <Riastradh> Yes, it could be, but then you'd _STILL_ have to maintain export lists and DEFINE-PUBLIC wouldn't be very useful at all.
15:53:54 <Lor> Of course there could be a more complicated export specification next to a definition.
15:54:32 <Riastradh> Yup, but it would need to be _really_ complicated for the three modules solution.
15:54:40 <Lor> Why so?
15:55:09 <Lor> (define-exported (exp-mod-1 exp-mod-2) (func arg1 arg2) body ...)
15:55:33 <Riastradh> What are EXP-MOD-1 and EXP-MOD-2?
15:55:42 <Lor> Those are some of the modules you're defining.
15:55:48 <Riastradh> Actually, scratch that.  Let me specify more clearly:
15:56:40 <Riastradh> There are three modules: MODULE-MUMBLE, MODULE, and MODULE-INTERNAL.  MODULE-MUMBLE exports everything; MODULE exports the main interface; MODULE-INTERNAL lets you get at the internals of the component.
15:57:11 <Lor> How do mumble and internal differ?
15:57:12 <Riastradh> There are three bindings in question here: AUX, INTERNAL, and FROB.
15:57:38 <Riastradh> MODULE-MUMBLE exports _everything_ that's defined; MODULE-INTERNAL exports everything relevant to the internals of the module, not auxiliaries.
15:57:50 <Lor> Okay.
15:58:19 <Riastradh> AUX isn't visible to any user: it's just an auxiliary.  INTERNAL is exposed to the user of MODULE-INTERNAL.  FROB is exposed to the user of MODULE and MODULE-INTERNAL.
15:58:28 <Riastradh> Give me definitions for all three of those bindings.
15:59:31 <Lor> (define (aux ...) body) (define-exported (module-internal) (internal ...) body) (define-exported (module module-internal) (frob ...) body)
15:59:49 <Lor> In this particular situation, I wouldn't necessarily advocate this style.
15:59:56 <Lor> But it's possible.
16:00:26 <Lor> Alternatively, just have (export (module-internal) internal) (define (internal ...) body)
16:00:27 <Riastradh> Now, if MODULE and MODULE-INTERNAL both import MODULE-MUMBLE, how would DEFINE-EXPORTED know about MODULE and MODULE-INTERNAL if it's in the source code of MODULE-MUMBLE and MODULE & MODULE-INTERNAL just happen to import MODULE-MUMBLE?
16:01:11 <Lor> They wouldn't. Then you'd have to list the exports explicitly.
16:01:39 <Riastradh> ...uh, then your idea of using (define-exported (module-internal) frob ...) wouldn't work.
16:01:49 <Lor> That's right.
16:02:03 <Lor> I never claimed it to be a universal Final Solution. Just a convenience for simple cases.
16:03:17 <Lor> Isn't it just horrible how you can write (define (foo bar) baz) and thus have the definitions _infiltrate_ pure expressions like lambda?
16:03:35 <Riastradh> So DEFINE-{EXPORTED,PUBLIC} don't make sense for multiple modules if you use your three modules idea and provide very little convenience for the two modules idea and would require you to shift styles when moving from single modules to double modules.
16:04:22 * Riastradh sighs.
16:05:01 <Lor> If you have this define-exported, then you can define multiple interfaces directly without an auxiliary all-exporting module.
16:06:34 <Lor> The whole question is just where to put the export information. As long as everything relevant is kept in one source file, you can always devise syntactic helpers to put it wherever you like it best.
16:07:27 <Lor> Once you start composing modules out of other modules (in other source files), _then_ you can no longer put the export info next to the definitions.
16:07:40 <Lor> Yes, it's a bit different style.
16:07:48 <Riastradh> And what if you have multiple modules with the _same_ interface?
16:07:56 <Lor> So is using (define (foo bar) baz) and (define foo (lambda (bar) baz))
16:08:26 <Lor> Then you again define the interface separately.
16:09:16 <Riastradh> But why pollute the concept environment by providing both DEFINE-EXPORTED _and_ explicit export lists?
16:09:41 <Riastradh> Indeed, conceptually, DEFINE-EXPORTED is very un-functional: it says: 'mutate the export list of some module by adding this name to it.'
16:09:45 <Lor> Why can define be used as syntactic sugar for lambda?
16:10:26 <Lor> Riastradh, it doesn't mutate anything, it just adds something. It can be implemented quite functionally.
16:10:39 <Riastradh> Yes, but _conceptually_ it is not functional.
16:11:21 <Lor> Well, um.
16:11:33 <blacksheep> O /me foi marcado como ausente.
16:11:34 <Lor> You could as well say that define is non-functional because it adds something to the environment.
16:11:47 <Lor> Even for internal defines.
16:12:02 <Lor> Far be it from me to dictate how you should conceptualize things. :)
16:13:08 <Riastradh> Regarding DEFINE as syntactic sugar for DEFINE and LAMBDA: a) It's incredibly common, more so than defining names that are exported.  b) (define (f x y) ...) shows more clearly the form of which F is used than (define f (lambda (x y) ...)).  c) Either way it's ordinary source code; you're not adding in several different layers that should be kept very separate.
16:14:08 <Lor> Oh but there definitely are two separate layers there.
16:14:17 <Lor> lambda is an expression, define is a command.
16:15:19 <Riastradh> It's still ordinary source code, not an ugly combination of module data and source code data.
16:16:38 <Lor> Far be it from me to dictate anyone's aesthetic tastes either. :)
16:19:52 * Lor is off. Should have been writing my thesis all this time.
16:42:33 * blacksheep já não está mais marcado como ausente. Foi desde 2003-12-13 00:14
23:25:21 <aleator> Sheesh. Someone fouled up the hawiki front page again..
