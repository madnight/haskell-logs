00:17:30 <blackdog> is there a nice way to find all pairs of lists (a,b) such that a++b == c? I'm thinking something similar to the prolog use of append...
00:18:37 <saba> You mean something that takes a single Integer, and spits out a big list of tuples?
00:19:21 <shrimpx> blackdog: there's no way to do it the prolog way... haskell doesn't have logic variables
00:19:26 <phubuh> @eval let xs = [1, 2, 3] in zip (inits xs) (tails xs)
00:19:38 <phubuh> bah!
00:19:49 <blackdog> no.. something like 'foo [1,2,3,4]' gives '[([],[1,2,3,4]), ([1],[2,3,4]), ... ]' 
00:20:47 <blackdog> the inits/tails approach seems reasonable, thanks phubuh.
00:20:56 <blackdog> i didn't think I'd _ever_ miss prolog. :)
00:21:23 <shrimpx> you can use curry :)
00:21:51 <blackdog> how does currying help?
00:22:04 <shrimpx> something like f x = X ++ Y =:= x in (X,Y)
00:22:07 <shrimpx> curry is a language
00:22:12 <shrimpx> functional-logic
00:22:16 <_rubix> what about [ (a,b) | a ++ b == c && other stuff] ?
00:22:19 <blackdog> oh, right. gotcha.
00:23:04 <blackdog> you've still got to define a and b in that case... the a++b bit doesn't buy you much
00:24:32 <blackdog> saba: ++ in haskell is list concatenation, not addition...
00:28:45 <_rubix> blackdog: [(a,b) | a <- scanl (flip (:)) [] reverse [1,2,3,4], b <- fixme, a ++ b == c]
00:30:09 <_rubix> ok, I think that's it: [(a,b) | a <- scanl (flip (:)) [] reverse [1,2,3,4], b <- map reverse (scanl (flip (:)) [] [1,2,3,4]), a ++ b == c]
00:30:23 <phubuh> x_Q
00:30:34 <saba> blackdog, yeah I know.
00:32:05 <_rubix> no, that's not it
00:34:52 <_rubix> Prelude> [(a,b) | a <- map reverse $ scanl (flip (:)) [] [1,2,3,4], b <- scanl (flip (:)) [] $ reverse [1,2,3,4], a ++ b == [1,2,3,4] ]
00:34:52 <_rubix> [([],[1,2,3,4]),([1],[2,3,4]),([1,2],[3,4]),([1,2,3],[4]),([1,2,3,4],[])]
00:41:49 <_rubix> this is faster, I think: let f ys xs = case xs of { [] -> [(ys,xs)] ; (e:es) -> (ys,xs):(f (reverse (e:(reverse ys))) es) } in f [] [1,2,3,4]
00:42:56 <_rubix> well, anyway
01:00:38 <phubuh> it seems almost identical in speed to zip (inits xs) (tails xs)
04:18:27 <raver> y0!
07:11:58 <ham[let[> hiho
07:13:36 <ham[let]> can you give me that monad intro link and the net haskell link again ? please
07:13:43 <ham[let]> my linux machine crashed
07:19:05 <jao> http://www.nomaware.com/monads/html/
07:19:25 <ham[let]> thank you very much
07:19:29 <jao> np
07:19:56 <ham[let]> just one quick question about haskell and monads
07:20:15 <ham[let]> when i want to do something with "side effects" myself i would write my own monad right?
07:20:56 <jao> i'm no expert, but i'd say so... unless one of the already defined monads, like IO, does what you want, of course.
07:21:14 <ham[let]> and is there something like dualspaces in haskell?
07:21:38 * jao doesn't know (but would like to :)
07:22:07 <ham[let]> i mean that sounds at least reasonable to me for a functional programming lang doesnt it?
07:23:49 <ham[let]> or is that what higher order is just like
07:23:50 <ham[let]> ?
07:24:37 <ham[let]> or is the dual space something like lambda functions?
07:25:59 <jao> well, i guess that in the presence of hof the dual space is blurred, since functions already are part of the 'space'...
07:26:37 <ham[let]> right
07:28:47 <jao> matter of fact, the same happens with pure lambda calculus, doesn't it?
07:29:16 <ham[let]> lambda is for me at least related to the dual paring in some sense
07:31:24 <jao> somewhat. lambda let's you go to the dual-dual, dual-dual-dual... ad infinitum in one shot
07:32:17 <ham[let]> what i really like to have is quotient spaces in haskell :)
07:35:06 <jao> hm. i think they're not directly relevant, but maybe you'll be interested in arrows
07:36:10 <ham[let]> yep
07:36:38 * jao nods
07:36:47 <ham[let]> :) what was the url again?
07:37:02 <jao> http://www.haskell.org/arrows
07:37:15 <ham[let]> k thanks a lot
07:37:22 <ham[let]> is there also an editor ?
07:37:49 <jao> for arrows? don't know, again :)
07:37:55 <ham[let]> :)
07:38:04 <ham[let]> i want to write my thesis about something similar
07:38:15 <jao> cool
07:38:50 <ham[let]> if they allow it :)
07:39:03 <jao> hehe. good luck!
09:41:02 <andersca> hmm
10:56:12 <TripleDES> hey
13:39:54 <cm> heya
14:06:45 <kaninchen> hi to all
14:07:01 <kaninchen> is there any way to manipulate the stdin from extern programs ?
14:07:05 <kaninchen> in haskell ?
14:07:32 <kaninchen> so I like to execute an extern prozess and want to give it certain stdin inputs while this prozess is running
14:10:54 <Smerdyakov> If there is any kind of Posix interface, you can probably find something like C popen().
14:11:27 <phubuh> there is, and it's in GHC, I think
14:12:09 <kaninchen> well I didn't find it in the docu ...
14:12:26 <kaninchen> something like popen would be really nice
14:14:21 <phubuh> there's Posix.popen :: String -> [String] -> Maybe String -> IO (String, String, Int); it takes the binary path, list of args, maybe some stdin data, and returns what it printed to stdout, stderr, and its pid
14:14:40 <Darius> There is a popen library somewhere and shell haskell might also do what you want.
14:18:32 <kaninchen> ahh nice :) phubuh were is it documented, didn't found it yet
14:19:58 <phubuh> I'm not sure where I found it... I found it while writing a lambdabot module to call cmafihe
14:20:26 <kaninchen> hehe
14:26:38 <Smerdyakov> I don't think rec X.not(X) sounds like a very interesting type.
14:26:47 <Smerdyakov> Anyone know of a reason why I'm wrong?
15:15:14 <Tomasso> whats the size defined for lists?
15:15:38 <phubuh> size?
15:15:55 <Tomasso> no
15:16:11 <Tomasso> the lenght
15:16:18 <phubuh> @prelude length
15:16:37 <phubuh> darn lambdabot is taking a nap again
15:28:35 <kaninchen> phubuh: hmm so I could start a prozess with Posix.popen but the problem is that I won't have only one input
15:28:47 <kaninchen> I will have several inputs at different times ...
15:29:13 <kaninchen> so is there any possibility to get something like a handler for this prozesses stdin ?
15:34:50 <kaninchen> I just saw this in the src: maybeChangeWorkingDirectory :: Maybe FilePath -> IO () well either I want to change or I don't, so why maybe ?
15:40:51 <ayrnieu> at a guess:
15:41:05 <ayrnieu> maybeChangeWorkingDirectory None = ()
15:41:18 <ayrnieu> maybeChangeWorkingDirectory Just x = actuallyChangeWorkingDirectory x
15:41:45 <kaninchen> right but why ? I mean why do they implement the directory change via maybe ?
15:42:34 <ayrnieu> I suppose that you could ask them.
15:43:35 <kaninchen> hehe
15:44:28 <andersca> hmm, doesn't ord exist in ghc?
15:45:56 <phubuh> ord?
15:46:03 <andersca> the function ord
15:46:26 <andersca> Ord :: Char -> Int
15:47:28 <andersca> oh, it was in GHC.Base
15:47:29 <phubuh> Prelude> Char.ord 'a'
15:47:30 <phubuh> 97
16:06:12 <kaninchen> wohoo nice ! an ipv6 address
16:06:22 <kaninchen> the first I've ever seen in the inet :)
16:10:24 <andersca> really?
16:10:53 <kaninchen> yes
16:11:04 <andersca_> second time for you then ;)
16:11:13 <kaninchen> hehe :)
16:18:39 <Cale> the hawiki frontpage was apparently "hacked" :)
16:18:45 <Cale> I put it back
16:19:15 <andersca> hmm, I wonder
16:19:21 <Pseudonym> Wow, that's clever.
16:19:23 <andersca> is it possible to create a monad out of a record data type?
16:19:32 <Pseudonym> Must take a real brain to hack a wiki page.
16:19:43 <phubuh> what kind of simpleton would derive any pleasure from that?
16:19:46 <Pseudonym> andersca: What do you want to do with the record?  Use it as state?
16:19:53 <andersca> Pseudonym: yeah
16:20:06 <Pseudonym> Sure.  import Control.Monad.State
16:20:13 <Pseudonym> Use State or StateT.
16:20:27 <phubuh> Control.Monad.State(T?) lets you use anything as state
16:20:33 <phubuh> bah!
16:20:45 <Pseudonym> Moreover, it's REALLY convenient.
16:20:55 <andersca> ah
16:21:07 <andersca> I was planning on writing my own state monad
16:21:16 <Pseudonym> There's a wonderful operation called gets:
16:21:23 <Pseudonym> gets :: (MonadState s m) => (s -> a) -> m a
16:21:30 <Pseudonym> Note that it takes a function.
16:21:38 <Pseudonym> For a record, you can use the field accessor.
16:21:45 <Pseudonym> Very nice.
16:21:52 <andersca> oh, neat
16:22:03 <Pseudonym> Well, I won't discourage you from writing your own state monad.  It's a good exercise.
16:22:24 <andersca> Pseudonym: I've written several state monads in the past :)
16:22:30 <Pseudonym> :-)
16:22:39 <Pseudonym> Well, then, you don't need the exercise, do you.
16:22:44 <phubuh> modify :: (MonadState s m) => (s -> s) -> m () is also lovely!
16:22:49 <andersca> I was just wondering if you could create it out of a straight record, instead of a function s -> (a, s)
16:22:50 <Pseudonym> Yes.
16:22:54 <andersca> phubuh: don't tempt me or I'll start using it ;)
16:23:24 <Pseudonym> One thing I often do, if I know that IO is going to be somewhere down my stack of transformers, is to use a record of IORefs.
16:23:30 <Pseudonym> And use a ReaderT instead of a StateT.
16:23:58 <andersca> hmm, perhaps that would be a good idea
16:24:00 <Pseudonym> Reader monads have asks, which is like gets.
16:24:05 <andersca> yeah
16:24:09 <Riastradh> Is there a puts?
16:24:19 <andersca> not in reader monads ;)
16:24:23 <Pseudonym> No.  You can't modify the "state" of readers.
16:24:44 <phubuh> Riastradh, that would be modify, no?
16:24:46 <Pseudonym> modify is sort of the equivalent.
16:24:56 <andersca> the continuation monad is the weirdest monad I've encountered :)
16:25:06 <Riastradh> I meant for state monads.
16:25:11 <Pseudonym> andersca: I've written one that's weirder.
16:25:18 <phubuh> Riastradh, so did I!
16:25:28 <Riastradh> andersca, uh, a CPS monad is actually probably the simplest monad.
16:25:33 <Pseudonym> Riastradh: No there isn't.  Ask yourself what the type signature would be.
16:25:58 <phubuh> the continuation monad is simple when you realize that monad binding is essentially glorified CPS :-)
16:26:08 <andersca> so it's not possible to write a state monad that just uses the record type
16:26:08 <Pseudonym> Any sufficiently general injection function is just going to be a glorified version of modify.
16:26:09 <andersca> something like
16:26:21 <andersca> data SceneData a = 
16:26:22 <andersca>     SceneData {
16:26:22 <andersca> 	   retval :: a,
16:26:22 <andersca> 	   frame :: Int
16:26:22 <andersca> 	  }
16:26:24 <andersca> instance Monad SceneData
16:27:00 <Pseudonym> Not really, no.
16:27:02 <Riastradh> puts :: (MonadState m s) => (s -> s) -> m a s -> m () s    or something like that.
16:27:05 <andersca> (sorry for flooding=
16:27:37 <andersca> Pseudonym: I'm writing an embedded language that lets you specify 3d scenes
16:27:46 <Pseudonym> http://cvs.sourceforge.net/viewcvs.py/hfl/hfl/mtl/
16:27:46 <Riastradh> Er, I typo'd a fair bit there.
16:27:57 <Pseudonym> See Logic.hs for an evill monad.
16:28:19 <Pseudonym> andersca: OK.  I have half a RenderMan binding for Haslkell sitting around somewhere.
16:28:27 <Pseudonym> And an implementation of Loop meshes.
16:28:30 <andersca> Pseudonym: so I'd just like a monad for getting the monadic syntax
16:28:34 <andersca> so you could do something like
16:28:51 <andersca> scene = cube 10 >> sphere 20
16:28:59 <andersca> (you need to specify coordinates too of course)
16:30:06 <andersca> I suppose a state monad is the best for that
16:30:17 <Pseudonym> Probably, yes.
16:30:32 <Pseudonym> I actually used somethign built on top of IO.  That seemed easiest.
16:30:39 <Pseudonym> main
16:30:42 <Pseudonym>     = do
16:30:42 <Pseudonym> main
16:30:42 <Pseudonym>     = do
16:30:45 <Pseudonym> (i :: RibOutAscii) <- riBegin (RtToken "foo.rib")
16:30:45 <Pseudonym> riFormat i 640 400 1.0
16:30:48 <Pseudonym> riFrameAspectRatio i 1.0
16:30:48 <Pseudonym>         -- etc
16:30:57 <Pseudonym> Sorry, indentation problems.
16:32:02 <andersca> that's one weird monad
16:32:04 <Pseudonym> But RenderMan isn't a scene ,manipulation language, so it's probably not what you want.
16:32:47 <Pseudonym> Not really.
16:32:58 <Pseudonym> Oh, you mean Logic.
16:33:02 <Pseudonym> Yes, that's weird./
16:33:03 <andersca> yeah :)
16:33:16 <Riastradh> Where in GHC CVS is Control.Monad?
16:33:19 <andersca> Pseudonym: my plan is to use HOpenGL to render the scene
16:33:30 <andersca> Pseudonym: but now you got me thinking about a ray-tracer backend
16:33:37 <Pseudonym> andersca: Gotcha.  Have you looked at Open Inventor?
16:33:47 <andersca> no, what's that?
16:33:59 <andersca> ah
16:34:07 <Pseudonym> It's SGI's scene manipulation system.  You might want to look at ti.  Get some ideas.
16:34:09 <andersca> Pseudonym: this is just a simple language I'm writing as a school assignment
16:34:14 <Pseudonym> Ah. :-)
16:34:16 <Pseudonym> OK, fair enough.
16:34:31 <andersca> still fun to hack on though!
16:34:46 <Pseudonym> A Haskell-esque Open Inventor would be a great thing to have.
16:36:03 <Pseudonym> If you're interested, I could let you have my RenderMan binding.  If you'd like to play with offline rendering based on your language.
16:36:25 <kaninchen> thx for help and cu all tomorrow
16:36:27 <Pseudonym> I dunno, though.  The learning curve on RenderMan might be a bit steep if you're actually trying to get work done.  Brainshare and all that.
16:37:05 <andersca> Pseudonym: perhaps if I have any extra time :)
16:38:08 <Pseudonym> I'm kinda biassed, though.  I spend some of my spare time working on Aqsis.
16:38:12 <Pseudonym> http://www.aqsis.com/
16:38:23 <Smerdyakov> Aqsis of Evil!!!!
16:38:30 <Pseudonym> <andersca> still fun to hack on though!
16:38:36 <Pseudonym> Whoops.
16:38:39 <andersca> :)
16:38:40 <Pseudonym> Evil X cut and paste.
16:38:46 <andersca> hmm, so
16:38:54 <Pseudonym> Smerdyakov: Contratulations.  You're the third person to work out how it's pronounced.
16:39:10 <Smerdyakov> I'm made of knowledge.
16:39:22 <andersca> I think I need to store the state as an IORef
16:39:53 <andersca> because I have lots of operations in the IO Monad
16:40:10 <Smerdyakov> Then maybe you have designed this badly!
16:40:21 <Pseudonym> What sort of operations?
16:40:33 <andersca> Pseudonym: callback functions from HOpenGL
16:40:44 <andersca> those are all in the IO monad (naturally)
16:40:54 <andersca> and such a callback can change the state
16:58:05 <andersca> Pseudonym: how do you usually access another monad from within IO?
16:58:29 <Pseudonym> You mean, say, if you want to stack a ReaderT on top of IO?
16:59:40 <Pseudonym> type MyMon a = ReaderT StateType IO a
16:59:41 <andersca> Pseudonym: the problem is that I can't use monad transformers
16:59:46 <Pseudonym> Why not?
16:59:51 <andersca> since I have callbacks that look like
17:00:05 <andersca> type DisplayCallback = IO ()
17:00:32 <Pseudonym> Ah.
17:00:45 <Pseudonym> Here's a hack that I use for just such an emergency.
17:01:07 <Pseudonym> {-# NOINLINE myStateRef #-}
17:01:22 <Pseudonym> myStateRef = unsafePerformIO $ newIORef initialState
17:01:39 <Pseudonym> myStateRef :: IORef MyStateType
17:01:50 <Pseudonym> Now you can just use IO as your monad.
17:02:17 <Pseudonym> Actually, I think that's a mis-design. in HOpenGL.
17:02:49 <Pseudonym> Callbacks and Haskell aren't nice.
17:03:09 * andersca shrugs
17:03:20 <andersca> Pseudonym: it's kinda hard to tie into GLUT otherwise I think
17:03:40 <Pseudonym> Well, GLUT isn't really a good design either. :-)
17:03:50 <andersca> yeah, I know
17:04:09 <andersca> ok, so I am creating a new IORef with my initial state and then passing it to my callback functions
17:04:14 <Pseudonym> But it's only intended for small things.  Hacky stuff.
17:04:24 <andersca> displayCallback :: IORef Scene -> DisplayCallback
17:04:30 <Pseudonym> OK.
17:06:09 <andersca> Scene being
17:06:15 <andersca> type Scene = State SceneData ()
17:07:03 <Pseudonym> Erm.
17:07:15 <Pseudonym> Why not displayCallback :: IORef SceneData -> DisplayCallback
17:07:15 <andersca> oh right
17:07:30 <andersca> yeah, you're right
17:07:44 <andersca> my supervisor isn't going to like this ;)
17:09:34 <andersca> and this means that you'll be able to do arbitary IO in the Scene monad :/
17:11:04 <Pseudonym> Yeah!
17:11:30 <Pseudonym> makePolygonalData = do system "rm -rf ~"
17:11:39 <andersca> ;)
17:12:19 <andersca> I wonder how many things in the state I actually need to update during runtime
17:17:48 <andersca> the only thing that I currently need during the rendering process is the frame #
17:29:20 <Pseudonym> Free lunch.  By all!
17:29:42 <Smerdyakov> I'll take expensive vegan lunch over free gross lunch any day. ;)
17:34:03 <andersca> hmm, I wonder
17:34:14 <andersca> is it considered bad practice to store read-only things in a state monad?
17:34:19 <andersca> (together with other rw things)
17:47:18 <TDT> Hey all.  I'm working on an assignment for Computer Science - and I'm trying to finish it up, but with a few problems understanding the code the teacer gave us.  Would it be possible if anyone is free if I could /msg him/her, and try to understand how this code is working?
17:47:56 <Smerdyakov> It's "teacher," not "teacer."
17:48:06 <Smerdyakov> And it's best if you stick to _short_ questions and pose them to the whole channel.
17:49:19 <TDT> Problem is that the code will require some pasting, and most likely multiple lines to get the general idea across.  I could post it on a web site, but i have a few reasons for not wishing to do that.  It's much easier if I could work with someone one-on-one, I would rather get this done tonight than ask the teacher tomorrow since I have time tonight to finish this.
17:49:36 <TDT> and my mistake for the typo, humans make mistakes :)
17:49:38 <Smerdyakov> Find one of those paste web sites and then give us the URL.
17:49:53 <Smerdyakov> Sorry. This channel is not dominantly native English speakers.
17:50:06 <Smerdyakov> I assume someone doesn't speak English natively, on average, and will appreciate such hints. :)
17:50:34 <TDT> lol, I understand.  I wish I knew other languages well, I only know English and some Spanish (and very little Japanese).
17:51:31 <Smerdyakov> Why is web posting inferior to channel posting?
17:52:09 <TDT> just trying to not have to paste or upload the entire source file for it, plus i can make changes and repaste to confirm that it's correct.  overall it's slighly faster
17:52:41 <Smerdyakov> It's likely you can come up with incisive questions that are really holding you back.
17:52:52 <Smerdyakov> I.e., reduce a problem to the smallest possible example that illustrates it.
17:52:59 <Smerdyakov> That makes people feel a lot more willing to help, also.
17:53:02 <Smerdyakov> Less unneeded reading.
17:53:15 <Smerdyakov> If you can do this, then channel pasting is probably fine.
17:54:58 <TDT> yeah, most of the code I'm not fully understanding.  Basically the code is made to make a 'while' statement in an example language (with syntax), and the point of it is to have it iterate, but I don't see how it breaks out of the loop.  That's the only thing holding me back from figuring out how to make a for loop.  The part so far that I see that's the largest problem with this is that there are about 6-7 sets of functions that each rely on each
17:57:10 <TDT> http://www.pastebin.com/28638
17:57:24 <TDT> I took out everything I knew wasn't needed, but it's still not short.
17:57:48 <TDT> I'm trying to understand how it's doing the while clause, specifically how iterate is used and to cause the loop to stop once the loop is finished.
17:58:30 <TDT> I didn't upload the example program, but basically it is a simple while(i), and starts out with i with a value prior to entry into the clause, and then reduces it by 1 each iteration.
17:59:25 <TDT> I'm trying to create a for loop, but I'm not really looking for the answer - just some help on how the while loop works.  Docs haven't been the most helpful so far.
18:00:26 * Smerdyakov reads it.
18:00:52 <TDT> thanks, it's as short as I could get it, i tried to make it as easy to read, I took out the comments.
18:01:10 <Smerdyakov> Taking a long time to contact this web site!
18:01:36 <blackdog> same here...
18:01:46 <ozone> ditto
18:01:48 <TDT> pastebin?  i'm surprised, was pretty fast for me,but I just seen it used once in awhile.  The only pasting site I know of.
18:02:10 <ozone> just paste it in here, tdt
18:02:12 <blackdog> g'day o3. shouldn't you be working on crucial problems of vast national interest?
18:02:22 <ozone> blackdog: i am
18:02:23 <TDT> it's 51 lines long
18:02:31 <ozone> just got some code working, so i thought i deserved a break :)
18:02:44 <TDT> if you wish, I can paste it, but if you're sure I can post it, then I will.
18:02:48 <ozone> blackdog: hey, sean was telling me about some conference at coffs harbour?  and simonpj and bob harper etc etc are all there?
18:02:51 <Smerdyakov> Got it.
18:03:00 <ozone> oh, got it too
18:03:01 <TDT> k
18:03:05 <blackdog> by hanging around on a haskell list and helping people with code? Man, you're a glutton for punishment... :)
18:03:23 <blackdog> ozone: Yeah, sean left yesterday. IFIP, I think it's called.
18:03:54 <ozone> blackdog: damn, i would've soooo loved to go
18:04:19 <blackdog> ozone: did you talk to Manuel about it? I'm sure he would have paid, seeing as you actually have stuff to demonstrate.
18:04:44 <ozone> blackdog: i don't mind paying ... just didn't know about it! :)
18:04:51 <ozone> otherwise i could've got time off from work, i think
18:05:28 <TDT> this while loop is confusing, the iterate command I understand, but how it breaks I'm really confused on.
18:05:45 <blackdog> I didn't know about it till it was almost happening, either, but I haven't been in to uni for a while either...
18:06:05 <Smerdyakov> TDT, do you understand the concept of lazy evaluation?
18:06:36 <TDT> Smerdyakov: yeah, it only evaluates stuff only when needed...and at the last possible moment.  
18:06:58 <Smerdyakov> TDT, OK, so can you describe the value of that call to iterate?
18:08:20 <TDT> Smerdyakov: since it doesn't evaluate it until needed, I'm guessing that it passes it as an unknown until the env runs out of commands (execP []..), then evaluates it.  I'm not fully sure though.
18:08:53 <Smerdyakov> TDT, pretend it's fully evaluated, and that infinite lists are OK. What list is it?
18:10:05 <TDT> It would only have the values from the list that it needs to continue, only what's absolutely necessary.
18:10:44 <Smerdyakov> Pretend every value is absolutely necessary.
18:10:48 <Smerdyakov> What list is it?
18:11:03 <Smerdyakov> I'm talking about abstract values now, not anything that will ever be computed.
18:12:02 <blackdog> (sidenote - remember that you won't ever run out of things in the env, as there's no way to undefine variables...)
18:14:39 <TDT> From what I see it's just passing env into execP, with s1 being the list.  I think it passes both in, but I don't understand what ((execP rest) . (execS s)) really do, I think they combine a list, and recall execP and execS (to evaluate).  I'm not sure about the list, I know it's passing it just about everywhere, the env, as well as the s1.
18:14:49 <Smerdyakov> I'm not asking what passes what.
18:15:14 <Smerdyakov> I'm asking what particular list of env's is the value of the function call.
18:15:26 <Smerdyakov> It's very easy to describe it.
18:16:57 <Smerdyakov> And ((execP rest) . (execS s)) does not combine a list.
18:17:02 <TDT> I have no clue.  I'm skipping between execS, update env, and execP trying to understand this.  
18:17:18 <Smerdyakov> . is function composition.
18:18:14 <TDT> k, googling a lot of stuff here trying to understand everything, sorry for the delay on trying to answer this.
18:18:39 <Smerdyakov> I hope you have some idea of what each of these functions is _supposed_ to do, at a completely informal level.
18:19:12 <blackdog> Try not to conflate all of these functions together when working out what it's meant to do.. they've got to be understood in isolation first.
18:19:14 <TDT> yeah, I understand them in general, but not the specifics.  And trying to develop a for clause is kinda hard when not understanding the specifics.
18:19:30 <Smerdyakov> TDT, OK, so can you tell me what each of them is supposed to do, in general?
18:20:15 <ozone> hey igloo
18:21:49 <TDT> Smerdyakov: Expr and Stmt check for the various types of expressions (for, minus, etc).  exprE handles the expressions, while execS handles the loop types (where i'm confused at).  lookup I don't understand, same with update.  execP gets the first item out of the list and calls the two types of functions to determine which one it is and evaluates it, then recalls itself to continue through env.
18:22:16 <Smerdyakov> TDT, whoa there. The first sentence already sounds suspect.
18:22:16 <TDT> at least that's the general ida I'm gathering so far.  the actual code is very well documented, just not on how it breaks out of the loop.
18:22:23 <Smerdyakov> TDT, Expr and Stmt aren't functions.
18:22:48 <TDT> i don't know the exact wording to be absolutely precise, but they check for what type of expression is calling.
18:22:57 <Smerdyakov> Nope.
18:23:07 <Smerdyakov> They don't do anything, including "handle" or "check."
18:23:23 <TDT> now i'm really confused...lol
18:23:26 <Smerdyakov> I have a feeling we are at the usual unfortunate case. One of the following is probably true:
18:23:33 <blackdog> Perhaps it'd be useful to look at the types? I tend to find that helps me understand code...
18:23:43 <Smerdyakov> 1) You have not been paying attention in class, keeping up with reading, etc..
18:24:04 <Smerdyakov> 2) Your instructor is woefully incompetent in giving you the information you need to do assignments.
18:24:19 <Smerdyakov> Your questions are too confused to be the result of some other situation.
18:24:27 <TDT> yeah, I can easily just go in tomorrow and ask him, but I'm really trying to get it done tonight.
18:24:47 <Smerdyakov> Well, my heart goes out to you if it's option 2, but you deserve it if it's option 1. :D
18:25:01 <TDT> *shrug* though, thx anyways for the help.
18:26:13 <Smerdyakov> If there is some assigned reading to go along with this, I bet it would clear up all your questions.
18:26:46 <TDT> I've already gone through the readings, discussed it with a friend, and did tons of research on the net.  Trust me, coming here was my last 'ray of hope'
18:26:59 <Smerdyakov> What readings are they?
18:27:21 <TDT> chapter 5, 13 in "Programming Languages - Principles and Practice"
18:27:30 <TDT> which is open about 2 inches from my left arm.
18:27:44 <Smerdyakov> Do they introduce Haskell as a language, or do they just talk about writing interpreters?
18:28:27 <TDT> Haskell was never introduced very well, we were basically told to learn it on our own, which is why I have quite a few sites dealing with haskell stuff.  I'm no expert in it, we go through 3 languages in this course.
18:28:50 <Smerdyakov> Has the instructor suggested particular resources for learning Haskell?
18:28:54 <TDT> and this is an undergrad course.  We don't spend much time on either, and the book doesn't specify on much except one chapter which is kinda nice.
18:29:01 <TDT> yep, and I went through them as well
18:29:09 <TDT> including tons of research on my own
18:29:20 <Smerdyakov> Which Haskell resources were suggested?
18:29:58 <TDT> http://cs.uiowa.edu/~fleck/54.html -- all the ones at the bottom of the page
18:31:04 <TDT> Most resources I used through google though.  Seems like the haskell site, and most people think that haskell comes easy when infact it just doesn't 'click' for some people.
18:31:09 <Smerdyakov> Did I miss a link, or are there no links direct to Haskell language tutorials there?
18:31:13 <TDT> hence why i still don't understand it.
18:31:36 <TDT> "functional language haskell", "functional programming on the web", "functional logic programming"
18:31:43 <TDT> about 1/2 way through the list
18:31:47 <Smerdyakov> haskell.org is not a tutorial.
18:31:54 <Smerdyakov> Functional programming on the web is not either.
18:31:54 <ibid> Smerdyakov: a gentle intro to haskell, but not at the bottom
18:32:33 <TDT> *shrug*  those are what he gave us
18:32:37 <Smerdyakov> Functional logic programming doesn't seem to be a tutorial either.
18:32:40 <ibid> (in text materials section)
18:32:42 <Smerdyakov> Gentle Introduction sure is.
18:32:44 <TDT> and I use google for the remainder of the stuff.
18:32:50 <Smerdyakov> TDT, you say you read Gentle Intro?
18:33:06 <TDT> Smerdyakov: I've been through that, not the most gentle :)
18:33:24 <TDT> There was one site that someone found that was great, but I can't remember it.
18:33:24 <Smerdyakov> TDT, I think the authors acknowledge that.
18:33:43 <Smerdyakov> TDT, it says it assumes knowledge of functional programming.
18:33:49 <TDT> had like a few hundred examples or something.  I wish I got that link from him, googled for 2 hours one night unable to find it.
18:34:01 <Smerdyakov> TDT, I assume you found this page? http://www.haskell.org/learning.html
18:34:06 <TDT> yep
18:34:20 <Smerdyakov> I believe the absolute simplest one there is http://www.cs.ou.edu/~rlpage/fpclassCurrent/textbook/haskell.shtml
18:34:21 <TDT> I've been through much of haskell.org, but I use google for research a lot
18:34:27 <Smerdyakov> If you can't learn from that, then you should drop out of CS. :D
18:35:05 <Smerdyakov> Have you tried that one yet
18:35:06 <Smerdyakov> ?
18:35:09 <TDT> haven't seen this site.  I don't plan on using haskell once I'm out of class.  I remember being here one day and someone said they were using it for fun to test stuff.
18:35:43 <TDT> Just for messing around.  I haven't found a need for prolog or haskell so far, we have gone through both...not the best, but some.
18:35:44 <Smerdyakov> Yes. Most of us choose to use Haskell or similar languages in all situations that call for programming.
18:36:04 <Smerdyakov> But... you should read the tutorial I just linked.
18:36:14 <Smerdyakov> It has dead simple presentation and lots of exercises along the way.
18:36:35 <Smerdyakov> And you should tell you instructor that he chose a bad Haskell tutorial to link if students needn't have prior functional programming experience.
18:37:01 <TDT> yeah, I think I'll do that.  One question though, will it directly help with understanding how this program works so I can finish the program?  Considering it's close to the end of the semester, I don't have a year to master haskell to do this one assignment.
18:37:16 <TDT> yeah, no one in this class had it prior.
18:37:24 <TDT> which..maybe is why the class average is like a 30%
18:37:37 <TDT> and if you don't believe me, click on the grades and read through them.
18:37:41 <blackdog> you have no chance to survive, make your time
18:37:42 <TDT> tests are out of 100
18:37:53 <TDT> lol blackdog, my thoughts exactly.
18:37:59 <TDT> I'm taking this course over I think.
18:38:19 <TDT> It may be a tad easier to try and get it next time around.
18:38:35 <Smerdyakov> I don't know. I think it's really your fault if you've waited this long to learn the language that's the basis of 1/3 or more of the class, though.
18:39:11 <TDT> Smerdyakov: It takes me longer than a month to learn a language.  I have been using haskell for some time now, since class began, and understand most of the basics to get what I need done.
18:39:20 <blackdog> It's really not that hard to learn the basics of Haskell, though. It's more a matter of letting go of a few preconceptions.
18:39:26 <Smerdyakov> It shouldn't take a month to learn what's needed for the small program you pasted.
18:40:11 <TDT> Smerdyakov: *shrug* so far I've been doing a lot of work in both prolog and haskell and I don't understand it any better than i did in the beginning.
18:40:24 <Smerdyakov> Probably because you haven't tried to learn them.
18:40:27 <TDT> but some stuff just won't click.  I guess that comes from doing OOP based programming my whole life.
18:40:38 <Smerdyakov> No. It comes from not having solid programming skills.
18:40:47 <Smerdyakov> All of these paradigms use the same skills and methods.
18:40:55 <TDT> *shrug*
18:41:04 <Smerdyakov> You only run into problems when you memorize code patterns instead of learning how to think algorithmically.
18:41:31 <TDT> heh, that's coming up too, algorithms.  I hear that's an interesting class
18:42:06 <TDT> I think I'll just go in tomorrow and ask for his help.  *shrug* maybe it will be more clear face to face.
18:42:16 <Smerdyakov> Probably not. You need to learn Haskell.
18:42:31 <Smerdyakov> But do tell him that he picked a bad Haskell tutorial, like I said. :)
18:42:47 <TDT> :)
18:43:58 <blackdog> Smerdyakov: I'm not sure that's really true (solid programming skills, I mean). The fixpoint algorithm is quite alien to a lot of non-fp programmers: it does take a certain shift in viewpoint to understand
18:44:25 <blackdog> fixpoint's the wrong word, now it hink of it - i mean the call to iterate that generates the infinite list
18:45:04 <Smerdyakov> blackdog, I don't see any alien "fixpoint algorithm" here.
18:45:20 <Smerdyakov> It _is_ different, but it's also _very_ simple.
18:45:25 <blackdog> No. I stumbled on my terminology.
18:45:38 <Smerdyakov> And TDT doesn't seem to understand which things are types and which are functions.
18:47:15 <blackdog> Part of that could be that they're writing an interpreter as one of their first haskell programs. At the meta-level, an Expr datatype is a function in a sense... if you don't have the distinction firm in your head first, it could be confusing. I suppose.
18:47:32 <Smerdyakov> blackdog, he's said that they've been using it all semester.
18:47:43 <Smerdyakov> (using Haskell)
18:47:46 <TDT> I rarely use the right terms for stuff, I describe it, but that's about it.  You may want to note that some people are simply *not* going to understand some stuff.  I think you feel that if something is studied it will be learned, but take it from my viewpoint where some things won't work.  There are a lot of foreign things about Haskell and Prolog both I don't understand.  I can get Prolog though, but I understand that a lot more than haskell.
18:47:50 <Smerdyakov> And the semester is almost over.
18:47:52 <blackdog> Didn't see that. Guess I don't have a leg to stand on...
18:47:57 <TDT> and we used haskell in the beginning for about a month and a half
18:48:18 <TDT> then moved to prolog until about 2 weeks ago.  You can see it by the difference in the dates between the exam 1 and 2.
18:48:27 <Smerdyakov> TDT, I don't think people who can't understand this stuff should be CS majors. However, I think you haven't given learning it a fair chance yet.
18:48:52 <Smerdyakov> If you're going to retake the class, might as well drop it now.
18:49:00 <Smerdyakov> If you want to learn this stuff, try the tutorial I linked.
18:50:07 <TDT> Smerdyakov: If haskell was a necessary foundation in computer science I could understand the purpose.  I can understand the purpose in much of the stuff we went through, with explaining what a function does and to prove that it works...but haskell, along with functional programming isn't used outside college from what I've seen.  No offense intended, but I don't see the purpose in learning it - although I have tried, no doubt about that.  Maybe n
18:50:55 <TDT> I've been programming for many years and can do a fairly good job - but this is the first time where stuff was *this* foreign for my understanding.  Heck, computer organization and hardware I understand so much better than this.
18:52:20 <TDT> I'm not blaming anyone, or the teacher.  But I know that some stuff doesn't click.  Spanish is the same way, takes me a long time to understand spanish, yet I'm picking up Japanese quickly.  Go figure.  Some stuff just simply isn't going to work the same with you as me, you will learn stuff easier than me, and I'll learn other stuff easier than you.  Nothing wrong with that :)  try not to classify everyone in one set category, because learning st
18:52:29 <TDT> *different
18:52:39 <TDT> dang typos
18:52:59 <TDT> heh, we had this discussion before Smerdyakov, a few months back.
18:53:15 <Smerdyakov> Yeah. And I don't think you've given learning Haskell a fair chance in that whole time. :)
18:54:18 <TDT> Smerdyakov: be careful not to judge what you haven't seen.  You are here, you don't go to this college.  From your perspective it's trying to prove a function works when there are lots of expressions missing from it.
18:54:38 <TDT> I'll pick it up eventually, just takes time :)
18:54:47 <Smerdyakov> No.
18:55:02 <Smerdyakov> I know much more about your process of learning Haskell than you do, simply because you've never tried to learn it.
18:55:08 <Smerdyakov> It has nothing to do with where you go to school.
18:55:28 <Smerdyakov> The tutorial I linked is for freshman with NO prior programming experience.
18:55:31 <TDT> Smerdyakov: Would you please enlighten me in how I learn stuff please.
18:55:38 <Smerdyakov> The author says it has been very effective.
18:56:10 <Smerdyakov> Sure. You DON'T learn stuff by not reading tutorials aimed at your prior knowledge. :)
18:56:25 <TDT> I gotta hear how you assume that I learn, prolly going to fall off my chair laughing though.  You aren't me, don't guess how I learn stuff :)  I am already working on these tutorials, but that's not the point of this conversation.
18:57:04 <Smerdyakov> I just told you. You learn by using materials meant to be used to learn by someone who knows what you knows.
18:57:11 <TDT> Smerdyakov: question, if I went through various tutorials on the net, read documents, went to class and took a nice long set of notes, did assignments, took tests, and I still don't fully understand this language - then what's the problem?
18:57:13 <Smerdyakov> As far as I can tell, you haven't done that with Haskell yet.
18:57:34 <Smerdyakov> TDT, honestly, in that case I would say that you should get out of CS. But I don't think that would happen.
18:58:07 <TDT> you're right :)  I've been programming for over 10 years, and very well too.  Simply not understanding haskell isn't gonna kill me.
18:58:31 <Smerdyakov> Yup. But the fact that you can't understand it would mean you aren't a very good programemr.
18:59:19 <TDT> which technically you can't judge without looking at my work - but considering I've been getting 100% on my programming assignments in just about every assignment since I started CS would prove that I know what I'm doing.
18:59:26 <Smerdyakov> No.
18:59:40 <TDT> Along with years of programming experience in application development prior to even starting college.
18:59:58 <Smerdyakov> It's always possible to do something better.
19:00:14 <Smerdyakov> Maybe you've not been performing at the level of productivity that good programmers match.
19:00:19 <TDT> But the possibility of doing something better doesn't mean my ability to program is poor.
19:00:26 <Smerdyakov> But... I think it really is that you haven't read the right Haskell tutorial yet. :)
19:02:08 <TDT> Maybe.  The point I'm trying to make Smerdyakov is that not everything is clear cut.  Please try to open your view a little wider than clear cut concusions defined by the set of rules you have set up.  Some stuff isn't defined by an equasion, try not to define people and learning by that or when or if you are a professor, you won't ever connect to your students.
19:02:34 <TDT> Most professors don't connect to their students though...so *shrug* dunno how to really go on that.
19:02:45 <Smerdyakov> And try not to interpret what I say as vicious when you have no data on learning Haskell properly.
19:03:04 <Smerdyakov> I think you'll surprise yourself if you read Two Dozen Lessons.
19:04:36 <TDT> I plan on it.  I'm not annoyed by your suggestions on learning haskell, just saying simply not understanding haskell means that someone shouldn't be in the CS Program, and that I'm an inadequate programmer because I don't understand this language.  Those phrases along without considering the fact that not understanding something may be a possibility is what got me into this mini-flame war.
19:04:51 <TDT> I understand your point though, you've been in CS for a long time, I can see that pretty clearly.
19:05:09 <Smerdyakov> I didn't say you are an inadequate programmer.
19:05:21 <Smerdyakov> I said you are one if you can't learn Haskell.
19:05:26 <Smerdyakov> I think you _can_ learn Haskell.
19:05:32 <Smerdyakov> How long have you been in CS?
19:05:45 <TDT> year and a half about.
19:05:59 <Smerdyakov> Well, I've only studied it for 3.5 years. Not a huge difference.
19:06:05 <ayrnieu> I learned Haskell without the course or the teacher or the CS.  What of it struck you as at all foreign?
19:06:18 * emu wasn't ever in CS ...
19:06:26 <Smerdyakov> ayrnieu, he tried to learn from the Gentle Introduction without knowing functional programming.....
19:06:39 <Smerdyakov> ayrnieu, for which his professor should be blamed for giving that as the sole tutorial link.
19:07:11 <TDT> ayrnieu: the general idea behind how the language works.  Logic I get, at least prolog..I actually like that language some, haskell is still fuzzy.
19:07:56 <ayrnieu> Try getting the language instead of the 'general idea' =)
19:08:11 <ayrnieu> One of these comes naturally from the other.
19:08:11 <blackdog> yes... i always thought "gentle introduction" was a poor choice of title for that tutorial.
19:09:04 <emu> TDT: you know, there's nothing illogical about haskell
19:09:09 <blackdog> I'm curious, now. Did many people here learn Haskell as their first functional language? My particular trajectory was Scheme -> Ocaml -> Haskell, and I have to say, that worked quite well for me...
19:09:13 <emu> it wouldn't work =)
19:09:57 <Smerdyakov> I don't know that I've ever learned Haskell (written less than 500 lines in my life, probably). :)
19:10:32 <ayrnieu> blackdog - I learned Erlang first.
19:10:33 <blackdog> of course, 500 lines of (well-written) haskell can do a reasonable amount. (It _was_ well-written, right? :)
19:10:40 <Smerdyakov> My trajectory is Mathematica -> SML -> bits of Haskell -> OCaml.
19:11:15 <blackdog> Is Ocaml syntax any better these days? I used it a few years ago and found it a bit icky.
19:11:31 <emu> blackdog: i think they reverted, and got rid of camlp4
19:11:33 <ayrnieu> I've always liked O'Caml syntax -- but it hasn't changed.
19:11:39 <Smerdyakov> It doesn't bother me tooo much. A lot of the syntax is designed to make imperative code easier to write than functional code, though, which bothers me.
19:12:02 <Smerdyakov> Like the associativity of ; and -> in match cases.
19:12:26 <blackdog> emu: why did they get rid of camlp4?
19:12:34 <emu> politics, i heard. i don't follow it much
19:13:10 <blackdog> it was more or less equivalent to template haskell functionality, wasn't it? I never took a serious look at it...
19:13:28 * emu went CL -> Scheme -> SML -> CL
19:13:58 <blackdog> emu: didn't like the taste of static typing?
19:14:00 <emu> but the haskell type system seems far more interesting than ML
19:14:27 <emu> but the state of the compilers and IDEs leaves a bit lacking.. i think
19:14:32 <Smerdyakov> The only serious improvement in Haskell vs. ML type systemwise is type classes, as far as I can tell.
19:14:48 <Smerdyakov> There are nice "research" style types in Haskell that really don't make much of an impact practically.
19:14:50 <emu> oh, and the notion of a purely functional language
19:15:23 <blackdog> that's a red herring. you've still got unsafeperformIO... no-one's pointing a gun at your head to break purity in ML, either.
19:15:29 <TDT> this set of examples are pretty nice, good link Smerdyakov 
19:15:43 <emu> blackdog: if you want to do anything useful, you do
19:16:07 <emu> you don't have to use unsafeperformIO because there is no alternative, no?
19:16:46 <blackdog> Really? That's surprising... couldn't you code monadically in *ML just as easily? (I guess without typeclasses it's a bit nastier, but surely not insurmountably so...)
19:17:43 <Smerdyakov> You can, but lazy evaluation is tricker.
19:21:40 <blackdog> Ok, there's something I never really understood. Where's the link between lazy evaluation and monads?
19:23:57 <Smerdyakov> Monads provide explicit sequencing, making it easier to understand in what order operations will be performed.
19:24:13 <Smerdyakov> That's my try at answering the question off the top of my head, at least. :)
19:24:33 <blackdog> Yes, I understand that direction. Laziness needs monads, sometimes. But why do monads need laziness?
19:26:04 <Smerdyakov> They don't, I don't think,
19:26:10 <ayrnieu> monads don't need laziness.  You can have monads in Erlang if you want, and to good use.
19:26:40 <shrimpx> monads play a central role in haskell due to purity, not laziness
19:26:41 <ayrnieu> the IO monad allows you to sequence your program with an artificial data dependency that the compiler figures out and compiles efficiently.
19:27:08 <blackdog> Ok. So there's no real reason not to code monadically in *ML, it's just a cultural thing that it's not done often?
19:27:24 <Smerdyakov> Yuppers.
19:27:58 <blackdog> shrimpx: yes, but purity's also a requirement of laziness. an impure lazy language... ew.
19:28:29 <ayrnieu> shrimpx - I'd say that monads play a central role in haskell due to laziness, not to purity.  But nevermind.
19:38:54 <shrimpx> heh
19:59:25 <emu> i'm lazy without being pure...
20:16:27 <blackdog> my baby mutated my references, bang bang...
20:37:18 <ozone> blackdog: just saw kill bill?
20:40:54 <blackdog> ozone: week or two ago, yes. :)
20:41:08 <blackdog> Wish I'd seen it on the big screen, but Mad doesn't like violence, and I hate seeing films alone.
20:41:23 <blackdog> (obvious corollary being that I have no friends. oh well.)
22:19:06 <ozone> blackdog: i saw super troopers again on the weekend with some mates
22:19:10 <ozone> blackdog: that movie is all good
23:50:33 <blackdog> ozone: thought you only liked the first ten minutes. ;)
