02:16:09 <malik> good morning
03:38:24 <det> Does anyone know of a good algorithm than can generate a shuffled copy of a list (shuffle: 'a list -> 'a list) ?
03:39:25 <Lor> Not a pure function. You need some source of randomness.
03:39:56 <Lor> But as for the algorithm, probably the best way is to turn the list into an array and then shuffle that.
03:40:12 <det> yes, I have a source of randomness
03:41:36 <Lor> You could of course just generate all the permutations and then choose the rand(n!):th one, but that's probably not very efficient. :)
03:41:36 <det> preferably without an intermediate list :)
03:42:16 <Lor> Um. With linked lists it's kind of hard to do efficiently without auxiliary data structures.
03:43:02 <det> I was thinking that I could pick a random element, cons that onto an empty list and then cons the index,
03:43:21 <det> then pick another random index in the range of 0 to length - 1
03:43:43 <det> cons that and find the "true" index given my list of indicies
03:43:52 <Lor> Yes, but it's dog slow.
03:44:18 <det> doesnt seem like it would be that slow
03:44:35 <det> escspecially if I use a binary tree to hold the previously chosen indicies
03:45:04 <Lor> That's O(n^2 log n), I think.
03:45:24 <Lor> Well, O(n^2) if you use your tree smartly.
03:46:47 <det> erm, isnt the latter slower than the latter ?
03:46:55 <det> latter slower than the former
03:47:49 <Lor> No, n^2 is definitely asymptotically less than n^2 log n
03:49:06 <Lor> You can shuffle an array imperatively in linear time. I wouldn't accept any functional solution that's worse than O(n log n).
03:49:22 <Lor> If there isn't one, then I'd rather use the imperative solution.
03:49:39 <det> agreed
03:50:49 <Lor> Hm, you could use that one trick in n log n time.
03:51:17 <Lor> It's not very pretty and not _really_ accurate, but it ought to work in practice.
03:51:39 <Lor> That is, generate a random number for each element in the list and zip them together, then sort the list of pairs by that random number element.
03:51:44 <Lor> Finally, get rid of the randoms.
03:53:19 <det> or just sort the list with a random comparison function
03:53:49 <Lor> Uh, no.
03:54:01 <det> how is that any different ?
03:54:22 <Lor> It can do anything at all and depends quite strongly on the exact sorting function.
03:54:33 <Lor> You aren't guaranteed an even distribution of permutations.
03:54:51 <det> oh, yes
03:54:53 <det> good point
03:56:40 <Lor> All right, there's an actually working solution in n log n.
03:56:46 <Lor> It's a bit complex, though.
03:57:24 <det> hrmm, can you generate a list of random numbers of length n consisting of unique values from 0 to n ?
03:57:29 <det> reasonably fast ?
03:57:43 <Lor> I think you can, in n log n. After that you only need to sort.
03:57:52 <Lor> The thing is, you need a special kind of a tree for that.
03:58:10 <Lor> But I do believe it can be balanced so that the lookup operations remain logarithmic.
04:01:45 <det> screw it, imperative it is :)
04:04:09 <Lor> http://okmij.org/ftp/Haskell/perfect-shuffle.txt
04:04:43 <Lor> Seems I was right. It can be done, but it is bloody complicated.
04:06:03 <det> :)
04:19:18 <shapr> @yow
04:19:22 <shapr> um
04:23:50 <lambdanazi> no @yow for you!
04:24:13 <shapr> det: be nice to the bot :-P
04:24:26 <shapr> or I'll cut off your bot privs
04:24:35 <det> haha, I have none :p
04:24:38 * shapr grins
04:29:44 <det> I wonder ..
04:30:10 * shapr foomps
04:30:16 <lambdabot> @yow
04:30:25 <det> ahh, he ignores himself :)
04:30:42 <det> ahh, he ignores himself :)
04:30:44 <det> oops
04:30:50 <lambdabot> lambdabot: @yow
04:32:41 <shapr> bah, Henrik Nilsson thinks we're being harsh about the Yampa license.
04:34:02 <det> what is the license ?
04:34:05 <det> and waht is Yampa ?
04:34:27 <shapr> http://www.haskell.org/yampa/
04:35:45 <shapr> the current license is "You may use, abuse, play with, hack the system to your hearts content, as long as it is for non-commercial purposes. However, the system may only be re-distributed in unaltered form and together with this copyright notice."
04:36:13 <det> oh, suck
04:36:26 <shapr> if we write something that uses Yampa, we can't put binaries or sources up for downloading
04:37:04 <det> unmodified sources, yes ?
04:37:14 <det> that just use Yampa as a library 
04:37:39 <shapr> that's true
04:37:56 <Darius> shapr: You can't modify the -system-.  You can post binaries or sources of programs -using- it, but you can't sell them.
04:38:11 <Darius> (Or rather, you can't redistribute the modified system)
04:38:30 <shapr> hm, maybe Henrik is right then, we may be too pissy.
04:38:38 <det> well
04:38:47 <shapr> anyways, they've said they'll release next under a BSD license, so I'm happy.
04:38:57 <det> you should be able to at least redistribute modified yampa sources :/
04:39:06 <shapr> I met Henrik Nilsson, he's a smart guy.
04:44:13 <shapr> amusing set of emails on the pragprog list
04:44:57 <shapr> stripper spam treated as needing eXtreme Programming :-)
04:52:32 <shapr> grr
04:52:58 <andersca> hmm, isn't fromInt in haskell?
04:53:03 <shapr> fromIntegral
04:53:17 <shapr> fromInt is oldskool
04:55:29 <andersca> oh
04:55:51 <malik> huh? i thought Int and Integer are different types?
04:55:58 <shapr> yah they are
04:56:03 <phubuh> Integral != Integer
04:56:20 <malik> well what is the new version of oldskool fromInt?
04:56:25 <shapr> Lunar^: you awake?
04:56:33 <shapr> malik: it's fromIntegral
04:56:35 <malik> ou...
04:56:38 <malik> i should read
04:56:41 <malik> sorry
04:56:46 <shapr> no worries :-)
04:56:55 <shapr> we're nice polite people here.
04:57:02 <shapr> except for me and Smerdyakov
04:57:11 <vegai> shapr is the worst
04:57:14 <shapr> yes, I am.
04:57:20 <malik> ok, i ll keep that in mind :)
04:57:25 * shapr gets a REALLY BIG STICK
04:59:22 <malik> perhaps i should tell this our professor :)
04:59:30 <shapr> er, who's your professor?
04:59:41 <malik> his name is goos...
05:00:20 <Lunar^> shapr: I am
05:00:22 <malik> somehow a veteran in functional programming...
05:02:34 <kosmikus> Karlsruhe?
05:02:51 <malik> yes...
05:03:16 <kosmikus> do you know D. Wagner?
05:04:05 <malik> no... i am here since this winter... dont know that much people
05:04:07 <andersca> shapr: I have a spinning cube!
05:04:22 <shapr> yay!
05:04:27 <shapr> I want to see a screenshot!
05:04:35 <kosmikus> malik: so you're learning Haskell in Karlsruhe in the first semester? cool
05:05:04 <malik> yes... and i like it :)
05:05:27 <kosmikus> even better, then :)
05:05:38 <shapr> Lunar^: could I see the Makefile for GHCiModule again?
05:06:39 <Lunar^> shapr: yep
05:07:19 <Lunar^> GHCiModule.o: GHCiModule.hs Shell.o
05:07:19 <Lunar^>         ghc $(GHCFLAGS) -c $< -ishell-haskell 
05:07:19 <Lunar^> Shell.o: shell_stub.o Shell.hs
05:07:19 <Lunar^>         ghc $(GHCFLAGS) -fffi -c Shell.hs shell_stub.o 
05:07:38 <shapr> oh
05:07:54 <shapr> I think that explains it.
05:09:15 <kosmikus> malik: "Hinweis: Benutzen Sie zum Lösen der Übungsaufgaben Ihren gesunden Menschenverstand!" That's funny ;)
05:09:39 <malik> kosmikus: yeah :)
05:10:11 <malik> kosmikus: the info students are pedants, and discussing every detail... this was the reaction :)
05:12:13 <kosmikus> I think it's quite a lot for one week, though ...
05:12:59 <malik> ehmm... you should see the math excersises :)
05:13:11 <shapr> @dynamic-load ghci
05:13:11 <lambdabot> symbol resolution failed
05:13:40 * shapr blinks
05:14:07 <malik> karlsruhe is known to be quite hard...
05:17:56 <harsha123> Hello shapr :)
05:18:40 <harsha123> shapr how do i get ":syntax on" (on vi) in emacs???
05:18:53 <shapr> are you using gnu emacs or xemacs ?
05:19:08 <harsha123> hmm.. gnu emacs
05:19:25 <kosmikus> malik: (math exercises) URL?
05:19:36 <shapr> interactively, M-x global-font-lock-mode
05:19:45 <shapr> and put (global-font-lock-mode 1) in your .emacs file
05:19:53 <harsha123> Ok :) 
05:19:55 <shapr> or maybe it's (global-font-lock-mode t) I forget.
05:20:14 <malik> kosmikus: ehm little moment... i am just compiling kernel and have no running x... 5 minutes or so...
05:20:55 <kosmikus> malik: :)
05:25:56 <harsha123> shapr :) yes it was mentioned on Slashdot! 
05:26:16 <harsha123> shapr people had bad comments though! :(
05:26:35 <shapr> people always have bad comments
05:27:21 <shapr> you gotta do what you think is right, and still listen to both the bad and good comments, some of them have useful information.
05:27:45 <harsha123> yeah.. i know
05:28:31 <shapr> just don't let the bad comments make you feel bad, and don't let the good comments make you think you're done :-)
05:30:24 <harsha123> :) yeah...
05:30:37 * earthy grinz at the `gesunden Menschenverstand'
05:31:10 <harsha123> brb
05:31:22 <shapr> harsha123: so you have any Haskell questions? :-)
05:31:45 <shapr> mgoetze: hey, can you kill the iohc-jury mailing list?
05:31:53 <harsha123> shapr brb, grab some tea..!
05:32:00 <shapr> ok
05:35:17 <cm> sigh, udp dos attacks
05:35:25 <shapr> ?
05:36:15 <malik> kosmikus: www.mathematik.uni-karlsruhe.de/~la/la0304/la1blatt<x>.pdf ... x ist the number...
05:36:19 <cm> box at work kept being udp dos'ed :(
05:36:29 <shapr> that sucks, did you irritate a script kiddie?
05:36:48 <cm> probably due to my short, not-really-unique nickname on irc networks
05:37:18 <malik> kosmikus: thats one part of maths... wie also have analysis and wahrscheinlichkeitstheorie...
05:37:52 <cm> seems that our pipe at work has been taken down a few times due to that, not good. grr.
05:39:09 <malik> kosmikus: and think the last one is representative... :) this was the easiest...
05:39:16 <malik> dont think...
05:39:35 <shapr> cm: you could change your nick
05:40:44 <cm> shapr: yeah, really considering it, at least for efnet. currently i'm only on irc directly or via a 3rd party shell hoster's bouncer, and those guys might know better how to deal with such stuff.
05:40:53 <cm> we'll see whether staying away from efnet helps ;)
05:41:31 <shapr> yah, good idea
05:44:04 <earthy> malik: this is 1st semester algebra?
05:44:44 <malik> earthy: yes...
05:44:50 <earthy> how many ECTS? :)
05:45:06 <malik> what?
05:45:29 <malik> ECTS?
05:45:39 <earthy> european credit transfer system. :)
05:45:52 <earthy> 28 hours of work for 1 ECTS
05:46:04 <earthy> nominally
05:46:39 <malik> whole together or just this math? :)
05:46:45 <earthy> just math
05:46:57 <earthy> whole together per semester should be roughly 30 ECTS
05:46:58 <malik> well thats one half of math...
05:47:38 <earthy> one half of math for that semester?
05:48:10 <malik> earthy: yes.. there is also analysis and statistics
05:48:20 <malik> but they arent that hard...
05:48:43 <malik> but algebra is a bunch of work... but you dont do it alone
05:48:43 <shapr> g'day Ninja Jones
05:48:50 <SyntaxNinja> hey shapr
05:49:02 <earthy> well, if math is half of the semester and this is half of math then it is at 7.5 ECTS and, while quite a bit, it's not overly much
05:49:22 <earthy> in my opinion. ;)
05:49:33 <kosmikus> malik: they look more or less as I would have expected
05:49:42 * earthy nods in agreement
05:49:57 <earthy> I like the question 'bout the monks though. `and why do they do it?' :)
05:50:10 <kosmikus> malik: actually, for LA, they are quite interesting -- I know professors who "invent" much more boring exercises
05:50:13 <malik> earthy: huh? i didnt say how long i need...
05:50:36 <malik> kosmikus: well for me they are quite hard...
05:50:44 <malik> kosmikus: info is nothing against that
05:51:13 <earthy> yes. that's what is called a challenge. >:P
05:51:31 <kosmikus> malik: that's normal, computer science *is* easy compared to math
05:51:39 <earthy> mostly easy
05:51:58 <cm> hmm
05:51:59 <kosmikus> earthy: for everything that's hard in computer science you find something in math that's harder ;)
05:52:05 <malik> kosmikus: well i dont like the term computer science.. :(
05:52:06 * earthy nods
05:52:29 <earthy> but for the fact that there's intricate man-made detail in informatics that you don't have to deal with in math
05:52:36 <kosmikus> malik: it's the standard translation of "Informatik" -- you can't really change it
05:52:47 <malik> kosmikus: info is 1/5 at the moment... cant say its easy :(
05:52:53 <earthy> and then there's the psychology stuff that just hasn't been really researched yet
05:53:42 * earthy marvels at the nice formulation `intricate man-made detail' to parafrase `steaming piles of shite'
05:53:55 <malik> i  wantet to type ":)" all the time :)
05:54:07 <malik> im laggin badly...
05:54:20 <shapr> smileys are kool
05:54:31 <earthy> olds kool, shapr? :)
05:54:45 <shapr> that too
05:57:07 <malik> well i dont remember this cool djikstra (sp?) quote exactly... somethin like... "computer science has as much to do with computers, as surgerz with knives." :)
05:57:16 <shapr> it's true
05:57:31 <shapr> I had a big argument about programming being more than Python on #plone yesterday.
05:57:38 <earthy> `Informatica heeft net zoveel met computers te maken als astronomie met telescopen'
05:58:08 <earthy> in english `Informatics has as much to do with computers as astronomy has to do with telescopes'
05:59:29 <malik> earthy: ah :)
05:59:52 <earthy> but I'm not doing it justice. He would've said it better in english
06:01:36 <earthy> see, my translation was overly literal. his is: `Computer Science is no more about computers than astronomy is about telescopes.'
06:02:24 <earthy> (but I like the Dutch version better, it provides more opportunity for interpretation and has more connotations)
06:04:14 <malik> well... now i know who to ask bout my la stuff :)
06:05:37 * harsha123 is back
06:05:42 <shapr> y0
06:05:58 * earthy grins
06:06:05 <earthy> not me. :)
06:06:37 <harsha123> yeah.. as i read the book "the craft of functional programming" i find haskell is very mathematical
06:06:48 <earthy> not really
06:06:58 <earthy> in a sense, yeah, sure.
06:07:02 <shapr> more math than C
06:07:15 <earthy> on the other hand, it is very much a practical programming language
06:07:16 <norpan> first you think it is, then you think it isn't and then you are enlightened
06:07:43 <norpan> i'm at stage 2 :)
06:09:01 <ozone> i'm at about 2.1
06:11:05 <harsha123> i guess recursion plays a very important role in a functional programming Language
06:11:16 <shapr> yup
06:11:24 <shapr> since recursion is a superset of loops
06:11:31 <harsha123> more than C and C++ !
06:11:34 <earthy> another candidate for `understatement of the year'
06:11:36 <shapr> length [] = 0
06:11:47 <shapr> length (x:xs) = 1 + length xs
06:13:18 <norpan> length xs = if null xs then 0 else 1 + length (tail xs)
06:13:33 <shapr> same thing
06:13:37 <norpan> i know
06:13:53 <shapr> afaik, both pattern matching and if/then/else become case statements
06:14:01 <harsha123> but ill have a lot to ask from day :) 
06:14:08 <cm> and the 2 liner is much more beautiful :>
06:14:18 <norpan> i always write pattern matching using case statements
06:14:19 <cm> (err, readable)
06:14:24 <norpan> makes it easier to rename functions
06:14:56 <norpan> length list = case list of
06:14:57 <norpan> ets
06:14:59 <norpan> etc
06:15:17 <cm> got string replace for that :>
06:15:59 <norpan> but maybe you haven't written thousands of lines of haskell code :)
06:16:12 <norpan> it pays off to be pragmatic
06:16:44 <cm> true, i'm at a couple of 100 with the current project, i think.
06:17:04 <cm> shapr: even better news, another box has been rooted. duh.
06:17:16 <shapr> one of your work boxen?
06:17:25 <norpan> when i convert all code to compile with ghc 6, maybe i'll switch to using template haskell for some things, and then i'll drop a couple of thousand lines
06:17:32 <cm> one small server at work
06:17:45 <shapr> aleator: can I advertise your corewars thingy?
06:17:49 <shapr> TauTau, it's called
06:18:03 <aleator> shapr: Sure.
06:18:06 <cm> norpan: what large project(s) are you using haskell for?
06:20:42 <Darius> norpan: What do you do about nested and multiple patterns?
06:22:34 <dennisb> pragmatic-norpan probably writes all functions as: myfunc = f where f 0 [] = 1 ....
06:23:15 <Darius> or f foo bar = case (foo,bar) of (Foo (Baz x),Bar (Baz x)) -> ...
06:24:27 <dennisb> and if all functions are called f inside everything is nice and dandy
06:33:34 <earthy> f f f f f f f f $ f f $! f
06:33:44 * earthy grins
06:34:09 * cm shrugs
06:36:05 <norpan> multiple patterns?
06:36:22 <norpan> i use tuples probably
06:36:37 <norpan> but i rarely need multiple patterns
06:37:18 <norpan> cm: a big part of our hardware verification products is written in haskell: www.safelogic.se
06:37:27 <mgoetze> shapr: yes, would you like me to?
06:38:15 <shapr> yes please, it's sending spam
06:38:20 * mgoetze notes that people still visit the iohcc webpages
06:38:22 <shapr> norpan: oh, you work for safelogic?
06:38:26 <cm> norpan: cool, so you actually can use haskell at work? :)
06:38:26 <norpan> yes
06:38:30 <norpan> to both
06:38:34 <cm> very cool
06:38:39 <norpan> indeed
06:38:44 <shapr> are you guys using Lava/Hawk or what?
06:38:58 <norpan> no
06:39:03 <shapr> bluecode?
06:39:06 <norpan> our verification tools are for verilog and vhdl
06:39:10 <shapr> ah, ok
06:39:17 <shapr> do you use quickcheck?
06:39:24 <norpan> not very much
06:39:38 <norpan> for small stuff only
06:39:59 <norpan> it's not very good at generating good complex input
06:40:24 <shapr> really?
06:40:37 <mgoetze> shapr: should i delete the archives too, or keep them around?
06:40:45 <shapr> mgoetze: please keep the archives
06:40:50 <mgoetze> ok
06:40:57 <shapr> mgoetze: thanks for hosting the html and mail :-)
06:41:17 <shapr> norpan: it's only as good as your input generator, right?
06:41:26 <norpan> yes
06:41:32 <shapr> and the coarbitrary stuff lets you adjust your generator
06:41:34 <norpan> and it's hard to generate good input
06:41:40 <shapr> oh, that's a good point
06:41:53 <mgoetze> shapr: np :) list is gone but for the archives
06:42:02 <shapr> thanks
06:42:21 <norpan> but i'd like a better quickcheck-like tool
06:42:37 <shapr> like what?
06:42:47 <shapr> have you guys looked at Programatica?
06:42:58 <shapr> its certificate stuff looks useful for real-world usage
06:44:18 <norpan> shapr: i don't know like what .)
06:44:38 <norpan> i wish i had more time looking at things to make my work more efficient
06:44:40 <norpan> :)
06:44:49 <shapr> I think a missing part of QuickCheck is the antiArbitrary, or whatever it should be called
06:46:05 <harsha123> shapr is scannedinavian.org down?
06:46:09 <shapr> yes it is
06:46:18 <shapr> the drive died, and I haven't gotten the other machine over there.
06:46:45 <harsha123> oh Ok
06:47:08 <shapr> harsha123: if you need something from that box, I probably have it available locally.
06:47:43 <harsha123> shapr i thought if you have the lambdabot source.....
06:47:57 <shapr> sure, lemme make a tgz
06:48:26 <earthy> owh damn.
06:48:49 * earthy is going to explain to someone tomorrow that his new startup may need to look at what safelogic is doing. :)
06:49:07 <earthy> (though I think their stuff is different)
06:50:51 <shapr> aha, it's bluespec I was thinking of
06:53:15 <norpan> bluespec is interesting, but they still have big theoretical problems i think
06:54:00 <norpan> if it's the one that was called trs before
06:54:02 <shapr> how so?
06:54:47 <norpan> it's not trivial to go from a non-deterministic term-rewriting system to a deterministic timed implementation
06:54:49 <shapr> I just know it's very Haskelly, and that Lennart Augustsson has a big part on it.
06:55:07 <norpan> it's basically specifying hardware through a term rewriting system
06:55:18 <shapr> what about a clockless implementation?
06:55:43 <norpan> well, sooner or later you have to put it on a real chip :)
06:55:56 <harsha123> shapr hmm...are U dcc'ing the file?
06:55:57 <shapr> there are clockless chips
06:56:05 <shapr> harsha123: no, sorry, I got distracted :-)
06:56:33 <earthy> shapr: yeah, and they're at about quadratic complexity when compared to timed logic
06:56:33 <norpan> there are still timing issues
06:56:44 <earthy> b'sides, you have to interface to a timed world
06:56:47 <harsha123> :) nevermind. you are a busy man! ;-)
06:56:54 <norpan> anyway, i don't know much more about bluespec
06:57:02 <earthy> (I for one wouldn't want to try interfacing to SDRAM in clockless logic)
06:57:04 <norpan> i've only heard lennart augustsson talk about it once
06:57:27 <shapr> on the good side, clockless logic costs less in wattage and heat if you use the reversible aspect of it.
06:57:33 <shapr> it is much more complex though
06:57:59 <earthy> plus there is a *lot* less macrocells for clockless logic. :)
06:58:01 <norpan> the company, sandburst, were using it to make some chip i think
06:58:06 <norpan> but they had big problems
06:58:08 <shapr> I know the F-22 uses clockless logic, I wonder how they interface to the clocked systems in the plane.
06:58:15 <shapr> what sort of problems?
06:58:21 <norpan> timing stuff
06:58:36 <norpan> and not knowing how the timing would change if you changed one rule in the system
06:58:41 <norpan> and optimizing
06:59:08 <shapr> sounds like the problems Yampa is trying to solve
06:59:20 <shapr> I wonder if Lennart has checked out Yampa
06:59:26 <norpan> i'm sure he has
06:59:52 <norpan> he's into that sort of stuff
06:59:57 <shapr> I've heard rumors that Lennart is "inte så daligt"
07:00:21 <norpan> he's very smart if that's what you mean
07:00:36 <shapr> yah, I've heard that from people I respect very highly
07:00:58 <norpan> he's the fastest programmer i've ever seen
07:01:02 <cm> yampa.. frp?
07:01:06 <shapr> cm: yup
07:01:11 <norpan> and smart too
07:01:26 <norpan> and he made cayenne
07:01:26 * cm hugs his hash table^Rbrain
07:01:38 <cm> is Lennart a guy on #haskell?
07:01:44 <shapr> nah, I wish :-)
07:02:05 <shapr> at least, if he's here, he's very quiet about it.
07:02:09 <norpan> hehe
07:03:55 <harsha123> whats Yampa? dunno if am asking the right question.. :))
07:04:11 <shapr> it's at http://www.haskell.org/yampa/
07:04:24 <shapr> it's one of the Functional Reactive Programming frameworks
07:04:32 <harsha123> hmm Ok :)
07:04:50 <shapr> in short, reactive programming is hard in a lazy language because you never know when to stop saving inputs for parsers that might fail
07:05:10 <cm> who is that Lennart guy? L. Augusstson (first google hit? :)
07:05:12 <shapr> so you get a 'space leak' where you save lots of stuff you probably won't need.
07:05:39 <shapr> earlier FRP frameworks used monads, and had space leaks
07:05:45 <harsha123> shapr trust me its bouncing off my head.. hehehe
07:06:16 <shapr> harsha123: look at the implementation of (++) in the Prelude
07:06:29 <harsha123> shapr :) Yep, I will..
07:06:46 * harsha123 feels, he has a *long* way to go
07:08:02 <shapr> sadly, I can't find the implementation of that function atm
07:09:26 <harsha123> shapr do you mind mailing me the lambdabot source? am sorry about asking it again and again !
07:10:04 <shapr> harsha123: http://shapr.homelinux.net/~shae/lambdabot.tar.bz2
07:11:35 <harsha123> shapr :) thanks a many!
07:11:40 <shapr> sure
07:29:48 <shapr> hi Darius
07:29:51 <shapr> er hi darius-
07:30:32 <shapr> darius-: would you like to learn Haskell? =)
07:31:09 <darius-> well, i already kind of know it :)
07:31:19 <shapr> yah, I still haven't checked out your huffman code.
07:31:50 <shapr> lambdabot plugins are always fair game.
07:32:15 <darius-> i'm just socializing, don't really have space for haskell hacking right now
07:32:29 <shapr> fair enough
07:33:01 <shapr> oh, aleator wrote a fun Haskell program recently
07:33:31 <darius-> fun is an ml keyword, not haskell
07:33:35 <shapr> :-P
07:33:48 <darius-> what's it do?
07:34:02 <shapr> http://cocoon.it.jyu.fi/~aleator/moinwiki/index.cgi/TauTau
07:34:12 <shapr> it's an OpenGL programmable robot tank game
07:35:18 <darius-> cool
07:35:54 <darius-> vorth looks vaguely joyful
07:36:24 <shapr> yah it does
07:36:38 <darius-> i still haven't done visual joy
07:36:49 <shapr> would be spiffy
07:37:55 <shapr> robotinohjelmointipeli <-- robot programming game
07:37:57 <shapr> finnish is so cool.
07:38:38 <shapr> Finnish is vaguely joyful too.
07:38:53 <darius-> yay for pronouns
07:39:53 * earthy grins at the MicrowavePopcorn wikipage
07:40:25 <aleator> Hi again. Seems that people stumbled upon my wikipage. :)
07:40:36 <earthy> especially given the knowledge of the travesty that is cheese-flavored microwave popcorn
07:40:56 <shapr> sounds terrifying
07:41:10 <earthy> I have not dared my mouth at it
07:41:24 <phubuh> mozarella-flavored non-microwave popcorn is actually graet
07:41:26 <phubuh> great*
07:41:35 <Smerdyakov> "Dared your mouth"?
07:41:46 <shapr> javas per minute is way funny
07:42:02 <earthy> smerdyakov: pardon the french
07:42:10 <phubuh> estrella sell them as "indianpopcorn" in sweden
07:44:12 <earthy> by the way, the 1.3 in ProgrammingMistakes is interesting
07:44:23 <earthy> especially given the *weird* scoping Python has (or had)
07:45:55 <aleator> I debugged that as a bug for a quite long time..
07:46:15 <earthy> >>> def f(val):
07:46:15 <earthy> ...     v = val
07:46:15 <earthy> ...     def g(v=v):
07:46:15 <earthy> ...        v = v + 1
07:46:22 <earthy> ...        return v
07:46:22 <earthy> ...     return g
07:46:22 <earthy> ... 
07:46:22 <earthy> >>> cl = f(1)
07:46:27 <earthy> >>> cl
07:46:28 <earthy> <function g at 0xe2480>
07:46:28 <earthy> >>> cl()
07:46:30 <earthy> 2
07:46:32 <earthy> there ya go
07:47:08 <earthy> (it is a *nasty* scoping problem. those are *exactly* why I dislike python)
07:47:24 <aleator> Ooh. That's cool! I've always boxed things in lists for that.
07:49:13 <shapr> I thought that's how scoping in Python is designed to work?
07:49:34 <shapr> how else could it behave?
07:49:50 <earthy> shapr: it *could* access surrounding scope
07:50:01 <earthy> and capture it locally...
07:50:18 <darius-> thought it did that now
07:50:27 <earthy> darius-: so did I
07:51:00 <earthy> but it doesn't seem to really do that in at least 2.2.1
07:51:09 <earthy> not for continuation-style stuff at least
07:51:14 <shapr> right, with 2.2 you have to do something like from __future__ import nested_scopes
07:51:23 <darius-> python is pretty annoying
07:51:45 <shapr> I like Python, though I do miss recursion and a bunch of other Haskelly things in Python.
07:52:05 <darius-> it has gotten better, yeah
07:52:07 <earthy> nope, import nested_scopes doesn't help. ;)
07:52:25 <darius-> upgrade to the latest?
07:52:45 <earthy> or just use the idiom I used above.
07:52:51 <shapr> I still don't understand what could be different about your example.
07:52:52 <Smerdyakov> Python doesn't have recursion?
07:52:56 * shapr thinks
07:53:34 <andersca> yes it does
07:55:10 <darius-> there's no y combinator in the standard library :)
07:55:53 <earthy> shapr: given nested scopes and automatic capture you wouldn't need the explicit default argument assignment  v=v
07:55:55 <shapr> earthy: function arg default values are bound when the function is created
07:56:20 <earthy> (it gets worse with lambda's...)
07:56:42 <basti_> hi all
07:56:46 <cm> hi
07:56:46 <shapr> oh, you want the default arg values to be bound at each runtime of the function?
07:56:50 <earthy> no
07:57:15 <earthy> I don't want to have to type the default arg values, I want g to look in the argumentdictionary of g *as*well*as* of f itself
07:57:34 <earthy> i.e.: g inherits all locals of f
07:57:41 <earthy> and all arguments
07:57:43 <darius-> earthy - have to upgrade, i guess
07:57:52 <earthy> darius-: yeah... newer pythons do that
07:57:56 <shapr> that's never been Pythonic though, for reasons of explicitness.
07:58:09 <darius-> too bad for pythonicity.
07:58:12 <shapr> it was always "LGB, local, global, built-in"
07:58:28 <earthy> shapr: true. but it has always ben hotly debated
07:58:28 <earthy> +e
07:58:48 <shapr> yes, we debated it lots on #python some years ago
07:59:26 <shapr> one of the points of python is explicit over implicit
07:59:29 <darius-> i suggested basing cap-python on first-class functions that way (capability secure python)
07:59:33 <shapr> I think the v=v fits that.
07:59:59 <shapr> anyways, I've come to the pure FP side nowadays.
08:00:36 <shapr> oh, here's part of my argument from last night on #plone: http://c2.com/cgi-bin/wiki?BlubParadox
08:01:26 <shapr> that lead me to a spiffy page, http://c2.com/cgi-bin/wiki?KeyLanguageFeatures
08:01:35 <earthy> ah, yeah, it's been changed between Python 2.2 and 2.3
08:03:32 <shapr> funny quote on that page "usage patterns of lambda expressions (they get passed around like a cigarette)"
08:03:58 <basti_> uhm
08:05:42 <sex|more> hello
08:05:47 <shapr> hi
08:05:49 <basti_> hi sex|more
08:05:53 <sex|more> someone familiar w/ Lambda calc?
08:05:58 <shapr> never heard of it
08:06:10 <shapr> oh wait, you mean those combinator thingies?
08:06:12 <basti_> surely its some obscure theory thing
08:06:16 <sex|more> yes
08:06:23 <shapr> like, um, S K and I ?
08:06:24 <sex|more> with the free and bound stuff?
08:06:36 <sex|more> yeah
08:06:37 <darius-> ooh, kinky
08:06:38 <shapr> sex|more: with a nice like that, you shouldn't say that sort of thing.
08:06:40 <phubuh> @get-definition pow
08:06:40 <lambdabot> pow not defined
08:06:49 <basti_> i think more like T:= a|(T T)|lambda a.T
08:06:49 <shapr> er "nick"
08:07:02 <shapr> I was reading about de bruijn matrices recently.
08:07:11 <shapr> they're not as high-falutin as I expected.
08:07:28 <basti_> brujin matrices.
08:07:36 <sex|more> can someone check my free and bound work?
08:07:42 <sex|more> it's only 4 lines
08:07:42 <shapr> I think it's bruijn
08:07:53 <Smerdyakov> sex|more, all the more reason not to check it!
08:07:58 <basti_> lol
08:08:04 <sex|more> Smerdyakov: ha ha
08:08:08 <basti_> shapr what are these?
08:08:24 <Smerdyakov> sex|more, let me guess: you'
08:08:40 <Smerdyakov> ve been assigned a homework problem where you say which variables are free and which bound in lambda expressions.
08:08:42 <shapr> they're the index of the offset from the first free variable
08:08:55 <sex|more> Smerdyakov: ??
08:09:04 <shapr> \x . x x becomes \0 . 0 0
08:09:08 <shapr> or something to that effect
08:09:12 <Smerdyakov> sex|more, why "??"?
08:09:18 <earthy> interesting how I/O is explicitly not included, as it is one of the major reasons for Algol 68 failing
08:09:18 <darius-> i thought those were called de bruijn indices
08:09:24 <sex|more> I didnt't get what oyu mean
08:09:24 <shapr> oh
08:09:30 <shapr> they probably are
08:09:34 <shapr> dunno why I said matrices
08:09:40 <darius-> oh well :)
08:09:52 <Smerdyakov> sex|more, combine my two lines above that are next to each other. I accidentally pressed enter.
08:10:04 <basti_> shapr ah
08:10:16 <cm> yeah, indices :> read about em in types and pl
08:10:26 <shapr> yah, that's a cool book
08:11:00 <Smerdyakov> sex|more, so I'm assuming that your answers to my question is yes.
08:11:11 <sex|more> which one?
08:11:29 <basti_> sex|more what he wants to say is that it looks like a homework problem ;)
08:11:37 <Smerdyakov> sex|more, let me guess: you've been assigned a homework problem where you say which variables are free and which bound in lambda expressions.
08:11:50 <phubuh> that's not a question
08:11:53 <sex|more> yes!
08:11:58 <Smerdyakov> I know. I just realized that.
08:12:09 <shapr> if someone isn't already aware of the 'homework' deal around here, it's probably best to explain it first.
08:12:29 <Smerdyakov> sex|more, OK. I think it's never ethical to check someone's work for problems that have only two possible answers, since that in effect does the problem for the person. And you should do your own homework.
08:12:50 <sex|more> ??
08:13:01 <Smerdyakov> What is it this time?
08:13:02 <sex|more> I did, just not sure if some lines are correct
08:13:19 <Smerdyakov> Right, and if we tell you which are correct and which not, we'll be giving you the correct answers.
08:13:48 <Smerdyakov> It doesn't matter if you have the right or wrong answers now: from any randomly generated answers, you can take our "right/wrong" values and generate the correct answers.
08:13:54 <sex|more> I never asked one to give the the right answers
08:14:01 <sex|more> just tell if it is right or not
08:14:21 <Smerdyakov> Yes, and there's an easy algorithm for taking an answer of if you have the right answer or not and producing the right answer.
08:15:06 <Smerdyakov> Even if we tell you if you are right or not for groups of variable occurrences at once, you probably are sure about all but one variable in many of the groups.
08:15:21 <Smerdyakov> Thus, for those groups, we would be giving you information that directly translates into the correct answer.
08:15:43 <sex|more> well man, it seems like you have serious problems
08:15:44 <Smerdyakov> Example: Consider the expression x.
08:15:49 <Smerdyakov> x is free here, clearly.
08:15:56 <Smerdyakov> Let's say you tell us "I think x is free. Am I right?"
08:16:07 <Smerdyakov> We say "yes," and you translate that into the fact that the answer is "free."
08:16:14 <Smerdyakov> Let's say you tell us "I think x is bound. Am I right?"
08:16:21 <Smerdyakov> We say "no," and you translate that into the fact that the answer is "bound."
08:16:22 <Smerdyakov> Get it?
08:16:39 <Smerdyakov> No matter how well you've solved the problem, our answer solves it for you entirely.
08:16:43 <Smerdyakov> It amounts to cheating on your part.
08:16:52 <shapr> I think he gets it Smerdyakov
08:17:06 <Smerdyakov> Probably not, if he said I "have serious problems"....
08:17:12 <earthy> so, suppose we have the expression \ x y z p q r s t u v w . (x y) z (p w) a b (t u)
08:17:41 <Smerdyakov> earthy, a professor would not assign a problem like that to someone who needs help making sure he has gotten the right answers. :)
08:17:56 <earthy> then, if you ask `I think x y z a b are bound' and we say `no' you have almost no information. :)
08:18:10 <Smerdyakov> Like I said, I bet every case has at most one variable occurrence that he is unsure of.
08:18:18 <earthy> smerdyakov: true.
08:18:44 <earthy> (but if I were a professor, I would throw that one in just for kicks)
08:23:06 <shapr> well
08:23:10 <shapr> that killed the conversation.
08:23:24 <aleator> Not really a bad thing I suppose :)
08:23:36 <earthy> ;)
08:23:47 <earthy> nice point to leave you all and go home. ;)
08:26:16 <shapr> so, um...
08:26:41 <shapr> Are there any good solutions for network transport of a running thread in GHC?
08:26:45 <darius-> can you make a dancing army of popes in haskell?
08:26:57 <shapr> I'm a pope.
08:27:01 <shapr> but not an army.
08:27:28 <darius-> well, i'm a pope too.  but i'm not written in haskell.
08:29:00 <Smerdyakov> \OMS
08:31:55 <andersca> so
08:31:58 <andersca> I have a function
08:32:08 <andersca> group :: [Object] -> Object
08:32:16 <andersca> which is supposed to group objects into a new one
08:32:31 <andersca> and Object is defined as
08:32:33 <andersca> type Object = ReaderT SceneState IO ()
08:35:06 <andersca> I thought I could use sequence
08:37:55 <Darius> okay
08:39:09 <vegai> "I think x is free. Am I right?" - Yes, you _do_ think x is free
08:39:26 <andersca> but then I got a type error :/
08:39:36 <Darius> @type sequence
08:39:37 <lambdabot> sequence :: Monad a => [a b] -> a [b]
08:39:47 <Darius> Use sequence_
08:39:51 <Darius> @type sequence_
08:39:52 <lambdabot> sequence_ :: Monad a => [a b] -> a ()
08:39:52 <vegai> and it _does_ seem that Smerdyakov has problems
08:40:39 <andersca> darius: thanks!
08:40:54 <Darius> "I think x is free.  Am I right?" No, Timmy. x is repressed by the Man. x will never be free until x rises up and brings down the Man.
08:40:55 <Smerdyakov> I'll tell you who has problems: Anyone who names a type Object. :D
08:41:20 <andersca> :)
08:41:23 <andersca> it is an object
08:41:26 <andersca> a scene object
08:41:32 <Smerdyakov> Then call it SceneObject!
08:42:09 <Smerdyakov> That's like naming a political party based around horse racing The Racists.
08:42:15 <Smerdyakov> Too much baggage on the word. :)
08:42:44 <darius-> sceneobject is too long for something used a lot
08:43:03 <Smerdyakov> ScObj
08:43:12 <Darius> Yes, it should be name Object_No_Not_Those_OO_Objects_A_Different_Object.
08:43:16 <aleator> All names are in a context. In some context Object is just a good name.
08:43:26 <darius-> i vote for thingummy
08:43:41 <Smerdyakov> No way. If anyone tries to use your library with any kind of cobbled together OO library, you'll have a name clash.
08:43:45 <Darius> I vote for RTFS
08:44:31 <shapr> I vote.
08:45:03 <darius-> actually morph is a nice short word
09:20:25 <basti_> anyone here ever built hol?
09:20:44 <keverets> hrm.. I'm trying to get the upper 16 bits of a 32-bit word.  Hugs dies when I try to do something like "shiftR 0xf40032f4 16 :: Int32" with "Program error: {primIntegerToInt 4093653748}"
09:21:47 <keverets> any ideas on how I can do this?
09:25:29 <Darius> Try Word32?
09:27:28 <keverets> Darius: that works.  Thanks.
09:57:17 <shapr> is there such a thing as a tutorial on writing network servers in Haskell?
09:57:59 <Darius> Probably not.  The closest you'd get is the paper on the webserver.
09:58:12 <shapr> yah, thanks
10:12:09 * harsha123 is back
10:22:49 <harsha123> @fortune
10:22:49 <lambdabot> There are some things worth dying for.
10:22:49 <lambdabot> 		-- Kirk, "Errand of Mercy", stardate 3201.7
10:23:12 <keverets> @arr
10:23:12 <lambdabot> Aye Aye Cap'n
10:23:31 <harsha123> shapr u around???
10:30:57 <shapr> harsha123: what's up?
10:31:39 <harsha123> hmm.. was wondering if you have some document on whats your "wish-list" / "to-do" for lambdabot!
10:31:54 <shapr> yes, there's a TODO file that's in the tgz
10:32:08 <harsha123> ok...
10:33:31 <Darius> It's also not hard to see things that could use some work.
10:33:39 <Darius> @type 'a' + 1
10:33:51 <Darius> @eval take 1000 (from 1)
10:33:51 <lambdabot> unbound variable: take
10:34:16 <Darius> @dict-help
10:34:16 <lambdabot> I perform dictionary lookups via the following 14 commands:
10:34:16 <lambdabot> @all-dicts .. Query all databases on dict.org
10:34:16 <lambdabot> @devils ..... The Devil's Dictionary
10:34:16 <lambdabot> @easton ..... Easton's 1897 Bible Dictionary
10:34:16 <lambdabot> @elements ... Elements database
10:34:17 <lambdabot> @foldoc ..... The Free On-line Dictionary of Computing
10:34:19 <lambdabot> @gazetteer .. U.S. Gazetteer (1990)
10:34:21 <lambdabot> @hitchcock .. Hitchcock's Bible Names Dictionary (late 1800's)
10:34:23 <lambdabot> @jargon ..... Jargon File
10:34:25 <lambdabot> [6 @more lines]
10:34:26 <Darius> @more
10:34:27 <lambdabot> wrong type (<<[] Char>>) in ModuleState
10:38:00 <shapr> oh, good point
10:46:31 <basti_> re
10:48:32 <harsha123> how do i start erc from emacs?
10:52:44 <esap> Hmm.. is the only difference between functions with types 'IO a -> IO b' and 'a -> IO b' the fact that you can force the evaluation of the input more than once in the first case?
10:53:08 <basti_> <?>
10:54:38 <ibid> you don't force the evaluation
10:55:29 <ibid> if you do f p = do { p ; p }, p is evaluated once (due to laziness) but the action it denotes is performed twice if the action f p is performed
10:55:57 <Lor> ibid, you're nitpicking.
10:56:31 <ibid> Lor: obviously, i don't think so
10:56:34 <Darius> Lor: No he isn't.
10:57:01 <Lor> Obviously evap meant "execution of the IO action" instead of evaluation of a term.
10:57:03 <Lor> esap
10:57:32 <shapr> hi tims 
10:57:33 <Darius> Lor: You don't execute the IO action of type a.
10:57:40 <ibid> then why did he not say that?
10:57:55 <ibid> i tend to assume people mean what they say
10:57:58 <esap> yes, for the purposes of this question, the first case executes an IO action whereas the other evaluates the value of the input.
10:59:08 <Darius> If the first executes an IO action, then they both evaluate the value of the input.
10:59:18 <Darius> The former is a substitution instance of the latter.
11:00:11 <Darius> The difference between them is exactly what the type says.
11:00:44 <esap> The only difference I can see is that in the first case, you can execute the IO action twice, whereas with the second, the evaluation strategy guarantees that each value is only evaluated once [given the monomorphism restriction, if I remember correctly]
11:01:34 <Darius> In both cases, the value is only evaluated once if at all.  It doesn't even make sense to talk about "executing" the input in the second, so you are comparing apples to oranges.
11:02:09 <esap> darius: in the second case, the corresponding term is 'demanding the input'.
11:03:25 <Darius> So?  You have to demand the input in the first case, I can call the first function (f1) as f1 undefined or f1 (longCalculatingProducingAnAction 10)
11:04:17 <esap> What I'm really interested in is _why_ there is very many functions with type of the form 'a -> IO b', but almost none with type of the form 'IO a -> IO b'. To me, it's counter-intuitive.
11:04:30 <Lor> Uh?
11:04:31 <Darius> The difference is in the first function, you know that you are getting an IO a so you can treat it as such, in the second you don't know what you are getting so you can't do anything with it.
11:05:18 <Darius> esap: There aren't too many functions with the type 'a -> IO b', undefined and \_ -> return undefined
11:05:26 <Lor> esap, why would you want to make a function deliberately less general than necessary?
11:05:46 <Darius> Oh and \_ -> undefined (damn seq)
11:06:23 <esap> darius: heh, I don't mean that. I mean things like putChar.
11:06:30 <Lor> Well, hm. You can either have f x = x >>= g, or g x = return x >>= f
11:06:34 <Lor> It's just a question of style.
11:06:58 <Lor> sorry, g x = f (return x)
11:08:14 <Darius> esap: monadic computations are morphisms in the Kleisli category, from the base category they look like a -> T b (for some a and b).
11:08:49 <Darius> So, return :: a -> T a is the identity a -> a in the Kleisli category.
11:09:16 <esap> darius: you can of course transform any 'a -> T b' into 'T a -> T b' using (=<<).
11:09:36 <Darius> At any rate, the reason is more or less the same as why you see more functions A -> B than (A -> B) -> C
11:10:01 <Darius> esap: Then that would be T a -> b in the Kleisli category.
11:11:20 <Darius> Another way of looking at it, is if the base language were imperative, then IO might be represented as type IO a = () -> a, most of the time you want values not delayed side-effecting computations.
11:12:26 <esap> oh ok, so it's about preference. That sounds reasonable.
11:14:54 <esap> I guess if you have primitives with types like 'IO Char -> IO ()', then you are by default delayed [and have to explicitly say when to evaluate], and if you use 'Char -> IO a', then the evaluation order of expressions will determine the evaluation order.
11:15:18 <Darius> esap: The difference is between call-by-value and call-by-name.
11:16:38 <basti_> was anyone here able to build hol?
11:17:35 <esap> darius: how about doing the reverse. If we have primitives with 'IO Char -> IO ()' form, how do you emulate call-by-need?
11:18:20 <Lor> With >>=
11:18:30 <Lor> Oops, sorri.
11:18:57 <esap> hmm.. maybe fmap?
11:19:04 <Lor> So what do you want?
11:19:14 <Lor> If you have a char already, you can just say f (return c)
11:20:15 <Darius> esap: It doesn't make sense for the primitive, putChar say, to be IO Char -> IO () unless you are expecting you're entire IO system to be call-by-name.
11:21:15 <Darius> (but then you wouldn't want it to be monadic at the user level)
11:21:20 <Lor> cbn in an imperative setting doesn't make any sense.
11:21:48 <Darius> Lor: Exactly.
11:21:51 <esap> Well I'd like something that can express both.
11:22:01 <Lor> What's wrong with Haskell, then? :)
11:22:31 <esap> lor: heh, you're right, not much. Maybe recursion is the most obvious thing :-)
11:22:59 * esap likes to be able to express termination.
11:23:26 <Lor> Uh?
11:23:29 <Lor> How do you mean?
11:24:01 <esap> It's again type system thing. I don't like every type to have _|_ as an element.
11:24:29 <Darius> esap: All you need to do then is add (checked) strictness annotations to Haskell.
11:24:38 <Darius> Unboxed types already do this to an extent.
11:24:46 <Lor> And strict datatypes...
11:24:51 <Lor> Hm, can you have strict newtypes?
11:25:17 <esap> darius: hmm.. I didn't realize unboxed types do this.
11:25:54 <Lor> An unboxed value is unboxed, it cannot be a closure of a diverging term.
11:26:58 <esap> Ok, but how do you write unboxed functions :-)
11:28:40 <esap> Maybe it's possible. Hmm.. I have to think about unboxed data types, I have completely ignored those previously.
11:29:03 <Darius> esap: Unboxed data types get rid of _|_ because they are strict, not because they are unboxed.
11:29:41 <esap> darius: Yes, I realize that.
11:29:59 <Darius> In a strict language, _|_ is occurs only in the following situation: a -> b_{_|_}.  To get rid of that, you need a guaranteed terminating subset, as you also know.
11:30:51 <esap> darius: yes, exactly.
11:31:10 <Lor> (System F! System F!)
11:32:10 <esap> What I'd like to see is that this kind of terminating subset was more commonly used, and the knowledge that the terminating subset was used is also taken into use in the type system.
11:32:16 <Darius> So you first start at a Turing-incomplete sublanguage.  Then you add a NonTermination commutative monad.  Lazy or call-by-name functions will then have type NT a -> NT b, and strict functions will be a -> NT b.
11:33:03 <Lor> esap, that's a textbook example of a trivial effect system.
11:33:21 <Lor> esap, actually, you did ask about that in news once, and I did point you to an example. :)
11:34:55 <esap> lor: yes, I'm still trying to build it :-)
11:35:44 <Lor> Uh? I pointed you to a paper. It didn't need any building. :)
11:37:07 <esap> darius: yes, that's the way you can add recursion. But I think there are less powerful constructs where the same situation occurs; either you get _power_ or you get _properties that you can prove_. I want both :-)
11:38:11 <Lor> Uh, you want the power of general recursion and also provable termination? Good luck...
11:38:31 <esap> lor: Of course, I separate those to separate sublanguages.
11:38:57 <Lor> It's not technically difficult.
11:39:07 <Lor> The problem is making the sublanguage easy enough to use for practical purposes.
11:39:37 <esap> Well that's why I don't provide just one sublanguage, I provide the whole hierarchy of sublanguages, each with different power.
11:40:10 <Lor> Even more difficult. :)
11:40:17 <Darius> esap: What's the issue? You can still have an Exception monad just as in Haskell, and that wouldn't require non-termination.  So you'd add exceptions but still keep provability (of course, that's kind of pointless).
11:40:24 <Lor> Hm. Refinement types, or capabilities, or effects...
11:40:37 <Lor> Or monads with _subtyping_, goddamit!
11:40:47 * Lor is tired of lifting between monad transformers.
11:41:43 <modesto> hello all, i'm working on implementing an interpreter for a simple language, and im having a bit of a problem with my typeof function when determining the type of an "If term", do you guys have a paste channel i could drop some code into?
11:41:57 <esap> darius: the issue is, I don't know where to draw the distinction between different sublanguages. Well the ordinary complexity-theory hierarchy is one good choice to use for the sublanguages, but of course, I don't have this for all the interesting constructs.
11:42:05 <Cale> you can paste to the wiki
11:42:14 <modesto> how do i do that?
11:42:28 <Cale> http://haskell.org/hawiki/HaskellIrcPastePage
11:42:35 <Cale> go to the bottom, and Edit Text
11:44:12 <Darius> esap: The sublanguages shouldn't be baked into the languages (except certain primitive ones).
11:44:45 <esap> darius: But you would want to be able to express the _properties_ that those sublanguages provide into the type system.
11:45:14 <Darius> esap: Then provide the means to do that.
11:46:03 <esap> darius: That's what I'm trying. But I don't know how I can design the type system for this kind of system, what are the basic primitives to build types from.
11:46:31 <modesto> aight, i pasted the start of my code, i didnt format correctly it looks like, but oh well. im having problems with the If match in the typeof fxn
11:46:40 <modesto> s/i/it
11:46:51 <Darius> esap: Have you looked at refinement types and property types?
11:47:39 * Darius whacks his mind-reading machine.
11:47:46 <Cale> I fixed the formatting - you missed the comment about putting {{{ }}} around code blocks at the top of that page :)
11:47:59 <esap> darius: not really.
11:48:01 <modesto> oops, sorry :)
11:48:03 <Darius> It seems to be broken.  I guess you'll have to state what problems you have, modesto.
11:48:26 <Darius> esap: There might be some helpful stuff there.
11:48:31 <shapr> why is it that mind-reading machines never come with printed manuals?
11:48:41 * shapr tries to think of a good telepathetic punchline
11:48:44 <modesto> well, it type checks fine if the first arg to If is of type TyBool, however it just freezes if you try, for ex, a TyFloat
11:48:51 <Darius> shapr: Mine always knew what I wanted.
11:49:08 <shapr> I could never figure out how to turn mine on.
11:52:11 <Cale> what does it seem to freeze on?
11:52:39 <modesto> type "typeof (eval (If (Flt 1.3) (Flt 1.0) (Flt 3.4)))"
11:53:51 <Darius> modesto: Don't you typically want to typecheck something before you evaluate it.
11:54:09 <Cale> okay, and what does it do for 'eval (If (Flt 1.3) (Flt 1.0) (Flt 3.4))'?
11:54:15 <Cale> :)
11:54:38 <Cale> You might want to be careful about how you evaluate that If
11:54:49 <modesto> lol
11:54:52 <modesto> crap
11:54:56 <modesto> yea
11:55:47 <Cale> Darius is right, you probably want to typecheck first.
11:56:38 <modesto> correct, i haven't yet written the interpret fxn that ties typeof and eval together yet
11:56:47 <Cale> note that it does throw an exception with typeof (If (Flt 0.2) (Var "a") (Var "b"))
11:57:12 <modesto> i was just testing the typeof function by itself, but what you say makes perfect since
11:57:46 <shapr> hi Xer0_ 
11:57:58 <Xer0_> hi shapr
11:58:07 <shapr> looking for Haskell info?
11:58:29 <Xer0_> looking for a haskell package for debian :)
11:58:44 <shapr> apt-get install ghc6
11:58:56 <Xer0_> do yo know where to find hshgl-ghc6.0 ?
11:59:16 <Xer0_> i need to work with graphics and i'm looking for it
11:59:25 <shapr> you want the SOEGraphics HGL?
11:59:52 <Xer0_> yes
12:00:04 <Xer0_> i've compiled 2.0.4 version of it
12:00:07 <modesto> Cale: however, typeof (If (Tru) (Flt 2.1) (Flt 2.4)) also throws an exception
12:00:12 <Xer0_> but i need it works with ghc
12:00:33 <Xer0_> and i've not been able to compile HGL version 3
12:01:36 <shapr> I think I saw some discussion about that on the haskell mailing lists, but I'm not sure.
12:02:01 <shapr> that == HGL3 with GHC
12:02:36 <Cale> modesto: "if ((typeof t1) == TyBool) && (typeof t1) == (typeof t2)" should be "if ((typeof t1) == TyBool) && (typeof t2) == (typeof t3)"
12:02:51 <shapr> Xer0_: I don't think there's a debian package of HGL
12:03:12 <Xer0_> i had it but i deleted
12:03:32 <Xer0_> now i need it again but it isn't on the debian pool
12:03:38 <Cale> and of course, returning typeof t2 would make more sense than TyFloat :)
12:03:47 <Xer0_> the package name was hshgl-ghc6.0
12:04:34 <modesto> Cale: damn, i need some coffee!
12:04:39 <modesto> Cale: thx
12:04:43 <Cale> np
12:05:49 <shapr> I don't know
12:06:03 <Xer0_> shapr: ok, thanks :)
12:06:56 <shapr> if Igloo is around, he may know more.
12:07:10 <esap> darius, lor: Do you know of any implementation of refinement types? I see all the papers seem to talk about ML, does some implementation have those?
12:07:33 <Smerdyakov> esap, I guess you looked at http://www-2.cs.cmu.edu/~triple/ ?
12:08:37 <esap> smerdyakov: well didn't, but thanks. That seems very interesting.
12:09:49 <Lor> There was something about refinement types in ICFP.
12:13:40 <esap> lor: http://citeseer.nj.nec.com/mandelbaum03effective.html I guess?
12:14:06 <Lor> Yeah.
12:15:36 <esap> My current approach to doing basically the same was using subtraction types. But I think the refinement type thing seems very good at it as well. I have to do a detailed comparison on those approaches.
12:22:43 <Lor> Hm. How do I define an environment so that its body is inside a \foo{...} command?
12:22:49 <Lor> In LaTeX, that is.
12:25:38 * esap never has used such commands, I don't know.
12:31:45 <basti_> Lor thats one of the harder things to do ;)
12:35:13 <Lor> Silly. Seems like it'd be often needed.
12:35:28 <Lor> Hm. And I cannot use a command either, since I want to be able to use environments inside the body.
12:38:00 <amb> Heya
13:17:26 <phubuh> does this link bring you to the wishlist of What Whatson? http://www.amazon.co.uk/exec/obidos/registry/wishlist/202-1237272-8255855
13:18:08 <phubuh> if not, does this? http://www.amazon.co.uk/exec/obidos/wishlist/7WG5HWEFNEMO/ref%3Dwl%5Fs%5F3/202-1237272-8255855
13:19:00 <phubuh> because I need you guys' help picking out two or three of those to wish for!
13:19:02 <Igloo> The first one takes me to a wishlist but I can't see who it belongs to
13:19:49 <phubuh> if it has a bunch of geeky books, I guess it works
13:19:50 <Igloo> 3, 6
13:20:04 <Igloo> Not particularly
13:20:21 <Igloo> Ah, the second one does
13:21:20 <phubuh> I'm still interested in the third and sixth :-)
13:21:53 * Igloo hasn't read any, but based on second or more hand info I'd say the 3rd and 5th
13:22:55 <phubuh> actually, feel free to recommend any books -- the wishlist is mostly to clarify my interests.  ah, yes, norvig's book looks very interesting
13:26:04 <phubuh> I'm also considering TAPL
13:26:36 <amb> I would suggest dawkins'
13:26:48 <Igloo> TAPL is good
13:30:09 <phubuh> bah, amazon are really good at marketing.  every time I visit my wishlist, I end up doubling its size :(
13:31:34 <Igloo> :-)
13:33:30 <amb> hey, books, that is a good idea *g*
13:33:41 * amb didn't know what he wanted for christmas *g*
14:03:02 <SyntaxNinja> shapr: any luck w/ gforge? did you ever do anythign w/ that email I sent you?
14:05:22 <Xer0_> any idea about how to override a mismatched interface file versions conflict?
14:05:31 <Xer0_>         Bad interface file: /usr/lib/ghc-6.0.1/imports/Graphics/HGL/Utils.hi
14:05:31 <Xer0_>             mismatched interface file versions: expected 6001, found 6000
14:05:49 <SyntaxNinja> Xer0_: recompile it
14:06:16 <Xer0_> any other solution?
14:06:44 <SyntaxNinja> Xer0_: in general, the compiled binaries between versions of ghc are not compatible.
14:06:46 <malik> arrr... why this operation on church booleans doesnt' work? it should be not((a v b)) :
14:07:11 <SyntaxNinja> Xer0_: so no, not that I know of :)
14:07:40 <SyntaxNinja> Xer0_: there is a project to help make recompiling things less painful, though http://www.haskell.org/libraryInfrastructure
14:08:38 <Xer0_> SyntaxNinja: ok, thanks. i will try that
14:09:05 <SyntaxNinja> Xer0_: I should clarify that that project _wants_ to make it less painful,b ut that project is hardly begun
14:09:12 <Darius> Xer0_: Well I didn't want to install a GHC 6.0 to use wxHaskell, so I just hacked the .hi files.
14:10:31 <Xer0_> Darius: i've edited the Utils.hi but i dont found the 6000 in ascii, I suppose it should be in binary
14:11:47 <Xer0_> Darius: any idea about where modify 6000 to 6001?
14:13:09 <Darius> Edit it with a hexeditor, it should be pretty easy to see where it is.  It's (obviously) near the beginning.
14:20:03 <malik> f = (\x->(x (\x->(\y->(y))) (\x->(\y->(x))))) (\x->(\y->(x (\z->(\a->(z))) y )))
14:20:21 <malik> oops sorry...
14:22:14 <malik> that should be (not(a v b) i dont get, why it doesn't work...
14:29:38 <Smerdyakov> Holy moly.
14:29:42 <Smerdyakov> Reversed text.
14:29:46 <Smerdyakov> Is this some kind of joke??
14:30:47 <malik> Smerdyakov: hm? talkin to me?
14:30:58 <Smerdyakov> Yeah.
14:31:06 <malik> Smerdyakov: why joke?
14:31:11 <malik> reversed text?
14:31:55 <Smerdyakov> Your "f = ..." has black background and white foreground text!
14:32:14 <Smerdyakov> And my IRC windows are set up for white background and black foreground.
14:32:26 <Smerdyakov> So your line either had explicit color codes or had a "reverse colors" code.
14:32:37 <malik> Smerdyakov: yeah... i said sorry for that.... dumb windows copy and paste...
14:33:01 <Smerdyakov> OK. Do you have a question about that code?
14:33:37 <malik> Smerdyakov: yes... it should be not(a v b)... church booleans... but it doesn't do what i expect :)
14:34:45 <malik> for example f (church true) (church false) returns true instead of false...
14:34:53 <Darius> @define id \x.x
14:34:54 <lambdabot> id defined
14:35:00 <Darius> @define const \x y.x
14:35:00 <lambdabot> const defined
14:35:17 <Smerdyakov> malik, why do you specify "a v b"? What do formal parameter names mean?
14:35:59 <Smerdyakov> I think they give no information, and just saying "Church not" gives the same.
14:36:06 <Darius> \/
14:36:36 <malik> Smerdyakov: with not(a v b) i mean  not( a OR b)
14:36:46 <malik> a, b are 'names' yes...
14:36:47 <Smerdyakov> Ah, I see.
14:37:06 <Smerdyakov> I don't see b in your code, though.
14:37:35 <Smerdyakov> And a only occurs bound.
14:37:39 <Smerdyakov> So I don't see what 'a' and 'b' mean.
14:39:16 <malik> this is only the formal term which should be represented as a lambda abstraction... so a lambda expression giving the same results as not(a OR B) so ((lambda expression) true false) would give false
14:39:38 <malik> a and b are just names... nothing to do with the lambda expression
14:41:02 <Smerdyakov> So you actually mean Forall a, b. (lambda expression) a b = not (a OR b)
14:41:16 <Smerdyakov> a and b have no meaning by themselves.
14:41:23 <malik> yes.
14:41:47 <Smerdyakov> Meaningless use of parameters like you used can be very annoying. :)
14:42:11 <Darius> \a b.not (a \/ b)
14:43:23 <malik> Darius: \/? whats that.? and im not allowed to use some predefined not or something
14:44:25 <Darius> It's a clearer way of writing what you originally wrote, making explicit that it's a function, and \/ is less likely to be confused for something else.
14:44:56 <Darius> Also, if you are using Haskell, then you're lambda term is way more syntactically complicated than necessary.
14:45:23 <malik> yeah i know...
14:45:46 <malik> its just an excerise... and i look for a mistake for a quite long time...
14:46:15 <Darius> It would be easier to understand if it were written more clearly.
14:46:37 <malik> hm...
14:47:22 <Darius> Anyways, you might want to start at the truth table for \a b -> not (a || b)
14:48:04 <malik> hm i try to make it clearer:
14:48:24 <Darius> I meant easier for you to understand.
14:49:19 <malik> f= \x -> (x true false) (\x->\y->(x true y))
14:49:26 <malik> Darius: you mean, you see the mistake?
14:50:14 <malik> :)
14:51:48 <Darius> malik: I haven't bothered.  I can easily get the solution.  I have suggested a way to build toward the correct answer.
14:53:16 <malik> Darius: yeah... thanks... but i think my problem arent the truth 'values'... i know this stuff... but i think i'm doing something wrong with the lambda expressions...
14:53:41 <malik> wrong order or something...
14:55:09 <Darius> Write a Haskell function that calculates not (a || b) for normal booleans without library functions and simply convert the result to a church representation.
14:56:07 <malik> hm... i think thats also no problem... but then i have no lambda expression?
14:57:34 <Darius> Once you converted to a church representation, you'd have the lambda expression.
15:01:41 <malik> hm? and what if there are if statements or anything like that in it? i dont really understand this...sorry for being so contrary...
15:01:44 <malik> *g*
15:02:25 <malik> well i think i'll have to relax a while and think about it again...
15:02:46 <Darius> Then you'll need to know how to convert if statements.
15:02:57 <malik> thanks anyhow
15:03:58 <malik> yeah we did that also... but  i think it gets even more complicated then
15:07:03 <Darius> How did you arrive at the lambda expression you started with.
15:07:04 <Darius> ?
15:08:09 <malik> i 'build' NOT and OR and squeezed them together to it :)
15:08:29 <malik> but i think i missed something with the order of arguments...
15:08:39 <Darius> How did you build not and or?
15:09:37 <malik> not a very scientific way... guessed well i would say :)
15:13:00 <Darius> Are you comfortable with Haskell's data declarations and pattern matching?
15:13:15 <malik> more or less... i just started with it...
15:13:37 <malik> but the basics i know... imho :)
15:15:20 <Darius> Given, data Pair a b = MkPair a b do you know what the type of MkPair is?
15:18:21 <malik> i would say Pair...
15:19:07 <Darius> Okay, load a file with 'data Pair a b = MkPair a b' in it and type ':t MkPair' and see what it says.
15:19:19 <malik> *g*
15:19:19 <phubuh> MkPair foo bar would be a Pair, but MkPair per se
15:21:31 <malik> ya ok... i see
15:23:18 <Darius> Okay, given a Haskell data type declaration it's pretty easy to make the church representation of it.
15:25:39 <Darius> The idea of the Church representation is you represent data by a function that takes a function that will do something with that data.
15:26:30 <Darius> So a pair is represented by a function that takes a function that takes two arguments and does something; it's type would be,
15:26:51 <Darius> (A -> B -> c) -> c
15:27:04 <Darius> for some A and B that's determined when the pair is made.
15:28:10 <Darius> So that's what a Pair looks like, to make a pair you need to provide the A and B, hence the type of MkPair being a -> b -> Pair a b.
15:28:47 <Darius> And expanding Pair a b we would get, a -> b -> (a -> b -> c) -> c
15:30:18 <malik> i try hard to understand it :)
15:32:47 <Darius> Well, there is only about one sensible lambda expression that will have that type.
15:35:04 <Darius> If you think about how the type reads and put the types together, then you should be able to figure out a definition of a mkPair function with type: a -> b -> (a -> b -> c) -> c
15:35:25 <Darius> The Haskell type system will yell at you if you get it wrong.
15:37:29 <Lor> What was the address to the H-M t-shirt?
15:38:02 <malik> Darius: well thank you... i understand it more or less... i'll try it tomorow with you hints...
15:40:22 <Darius> www.cafepress.com/skicalc (making it up off the top of my head)
15:40:47 <Lor> Yeah, just found it myself.
15:40:56 <Lor> No link in the wiki.
15:50:52 <Riastradh> cafeshops.com, not cafepress.com.
15:51:15 <Riastradh> Lor, uh, what about on QuotesPage?
15:53:07 <Lor> Hm, funny.
15:53:44 <Lor> Apparently I had a moment of localized blindness.
16:14:59 <shapr> SyntaxLaptop: I got gforge up and running on raven, then it crashed a few days later.
16:15:26 <shapr> since then, I've been working full-time on tomorrow's deadline.
16:15:47 <SyntaxLaptop> ok cool
16:17:22 <shapr> I started a rewrite of that email
16:18:40 <shapr> SyntaxLaptop: hey, Bea asked me whether you were changing domain names
16:18:53 <SyntaxLaptop> nope
16:19:03 <shapr> so, SyntaxNinja is just a Pseudonym?
16:19:29 <SyntaxLaptop> well, I never was very fond of feeling like I named the domain after myself, so I renamed myself rather than the domain.
16:19:36 <shapr> heh
16:22:05 <shapr> did you ever find a better sounding expression than "eat our own dogfood" ?
16:23:30 <SyntaxLaptop> hm. no, I didn't really think about it.
16:23:46 <SyntaxLaptop> maybe "Ride your own unicycles"?
16:24:12 * shapr cackles happily
16:24:20 <SyntaxLaptop> ;)
16:32:29 <shapr> ok, I've written a bit more, I'll pass it back your way.
16:32:42 <SyntaxLaptop> cool!
16:32:58 <andersca> la la la
16:35:26 <shapr> hej andersca 
16:36:09 <andersca> hej shapr
16:36:11 <andersca> snart Ã¤r min scen klar
16:37:03 <shapr> bra
16:37:04 <Smerdyakov> How does this idea tickle the fancies of the assembled persons? A contest-with-prizes for best open source software program by someone under age N, where N is chosen to be about when people begin higher education.
16:37:16 <shapr> är det på webben?
16:40:32 <andersca> how do I convert CInt to Int?
16:40:54 <shapr> that's outta my league
16:41:35 <Igloo> fromIntegral
16:42:26 <shapr> I have a question, do I need to do anything special to get multiple connections on the same socket? is that what ReuseAddr is for?
16:42:48 <Smerdyakov> Yes it is!
16:42:57 <Smerdyakov> And no one has any response to my idea!
16:43:25 <shapr> well, in my experience people write open source software to scratch their own itches mostly
16:43:42 <Lor> "Higher education" meaning what? After high school?
16:43:42 <shapr> and not so much for outside input
16:43:53 <Smerdyakov> shapr, yeah, but not Kids These Days. They have no idea what's up. They write web sites in PHP. They need some prodding.
16:43:55 <Smerdyakov> Lor, yes
16:44:28 <Lor> I'd say it's hard to get motivated to write software just to go after prizes.
16:44:50 <Lor> One should have a personal goal in mind.
16:44:53 <Smerdyakov> Yeah, for a real hacker. For kids who aren't close to being real hackers yet, it helps a lot, I think. :)
16:44:56 <shapr> yah, I agree.
16:45:01 <Smerdyakov> Again, you're talking about what rational software developers do.
16:45:12 <Smerdyakov> The purpose of this idea is to encourage young people to become rational software developers.
16:45:21 <shapr> I wrote code for fun many years before I ever thought it could make money for me.
16:45:25 <Lor> No, I mean, code written for a contest is bound to be crappy. Since there is no purpose behind it.
16:45:33 <Smerdyakov> shapr, and I bet you learned coding before the Internet was available to you.
16:45:42 <shapr> somewhat, yes
16:45:49 <Smerdyakov> shapr, the Internet and other assorted flashy technologies are killing the community of young programmers.
16:45:57 <shapr> I completely disagree
16:46:04 <Darius> I agree with shapr.
16:46:07 <Smerdyakov> shapr, distraction and an idea of what's worth coding that is based heavily on "simple" web based stuff.
16:46:11 <shapr> I would have become a better programmer much faster if debug.com hadn't been such a piece of shit
16:46:27 <Darius> It really is.
16:46:46 <Smerdyakov> I don't believe it. All the evidence I see is that growing up with Internet access is a net loss for the world in terms of young people who become competent hackers on their own time.
16:47:02 <Lor> If the contest is about implementing a specific kind of application, _and_ there is clearly a general need for such an application, _then_ the context might make sense.
16:47:06 <shapr> in my opinion, if you want to hook kids on code, give them highly interactive graphical environments
16:47:30 <Lor> logo, anyone? :)
16:47:34 <shapr> give them Self running on a Linux Virtual Machine
16:47:35 <Darius> Ones who want to can make great utilization of the Internet and it gives them access to -tons- of information they wouldn't otherwise be able to get.
16:47:38 <Smerdyakov> Lor, the exact parameters would be refined to encourage the sorts of software development that are good to develop. :)
16:47:54 <Lor> shapr, or smalltalk, maybe?
16:48:04 * Lor ought to try out squaek some day.
16:48:04 <Smerdyakov> Darius, irrelevant if they are never motivated to learn the basics of programming.
16:48:07 <shapr> Lor: Self has spiffier collab features, imho
16:48:07 <Darius> The Internet actually does still serve the purpose of desiminating CS info fairly well.
16:48:13 <Lor> It just seems a bit heavyweight.
16:48:16 <shapr> Lor: you gotta fast connect, and I'll show you :-)
16:48:35 <Darius> Smerdyakov: It's irrelevant whether they're motivated if they don't have the resources.
16:48:35 <Smerdyakov> Darius, most today who WOULD have been motivated to do that in the days of Amigas are instead motivated today to learn web design and maybe some PHP or similar stuff to show off flashy web sites to their friends.
16:48:41 <Lor> My upstream isn't blindingly fast, 10kbps or so.
16:48:47 <shapr> hmm
16:48:51 <Lor> kBps, that is.
16:49:08 <Smerdyakov> Darius, if you have the slighest bunch of data points showing that I'm wrong, I'm all ears.
16:49:22 <shapr> Smerdyakov: I propose phubuh as a data point :-)
16:49:26 <shapr> phubuh: hey, you awake?
16:49:35 <Smerdyakov> Darius, however, unless you've been involved in running Internet groups for young programmers since 1996 like I have, you may want to reconsider before poo-poo'ing me so quickly.
16:49:44 * Darius proposes himself.
16:49:55 <shapr> Darius: yes, but you don't advertise your age ;-)
16:49:57 <Smerdyakov> Darius, first learned to program in what year?
16:50:01 <shapr> how old are you Darius?
16:50:15 <Smerdyakov> Age doesn't matter as much as first exposure to programming and the environment that encouraged it.
16:50:22 <Smerdyakov> I posit that the Internet is bad to have in that environment.
16:50:32 <shapr> you proposed the contest on the basis of age
16:50:40 <Lor> Fancy modern machines are bad to have in general.
16:50:43 <Smerdyakov> Good to have once you know the basics and have developed a good rhythm for the development process.
16:50:44 <Darius> 1996 ish
16:51:04 <Smerdyakov> Darius, how long had you been on the Internet then?
16:51:10 <Lor> In olden days, the _default_ thing you could do with a machine was to program with it.
16:51:13 <Darius> about that long
16:51:23 <Smerdyakov> Darius, wha..? How long?
16:51:30 <Darius> Since 1996 
16:51:31 <Smerdyakov> Darius, you mean shortly before 1996? Shortly after?
16:51:42 <Smerdyakov> (for first time on Internet)
16:51:56 <shapr> anyways, enough of the inquisition :-P
16:52:16 <Smerdyakov> Oh, it's one of those "shapr tries to kill an interesting conversation with a statement" times.
16:52:19 <shapr> I think some people are fascinated with computation, and some aren't
16:52:37 * shapr sighs
16:52:40 <Darius> I'm not sure.  I'm pretty sure I took a swing at programming before using the Internet but I think I didn't really start until after.
16:52:52 <Lor> Some people miss the exposure to computation that might have made them fascinated.
16:52:54 <Smerdyakov> Darius, well, then you're not in the sample space I'm considering.
16:53:06 <Smerdyakov> Darius, I'm considering people who grew up with Internet access.
16:53:14 <shapr> I grew up with 'net access.
16:53:45 <Smerdyakov> shapr, you're also too old. Yes, age does matter, but only for placement in broad categories.
16:54:11 <shapr> I admit, I got a lot of distractions from the 'net, but I had *so much more* information to lean from.
16:54:44 <shapr> I think people will be themselves, and the 'net just makes it easier to find the stuff you want.
16:54:49 * Darius owns two books on programming... wait, one the other is networking... wait, zero one is a crappy Java 1.1 book.
16:55:00 <Smerdyakov> I think you're wrong, based on empirical observations over 5 years.
16:55:02 <shapr> whether that's pr0n for most teenagers, or computation for a few.
16:55:12 <Smerdyakov> Not based on armchair theorizing begun now. :)
16:55:24 <shapr> ok then, why did you want our opinions?
16:55:38 <Smerdyakov> Beats me.
16:55:49 <Smerdyakov> Some of you might see the same problem I see.
16:55:57 <shapr> you're wasting my time when I could be writing code?
16:56:09 <Smerdyakov> You don't have to respond.
16:57:38 <Smerdyakov> Maybe I'll go ask my question on EFNet in the general purpose programming channels that are probably 18 times less intellectual than this one. :)
16:58:46 <Darius> Probably a buncha kids who grew up with the Internet
16:59:01 <Smerdyakov> I wish.
16:59:22 <Smerdyakov> Seriously. Think about the evidence you've seen already. Maybe do a little research.
16:59:34 <Smerdyakov> Compare proportion of teenagers on the 'net interested in serious coding today vs. 1996.
16:59:54 <shapr> so
17:00:09 <shapr> any suggestions or recommendations on writing network servers in Haskell?
17:00:14 <Smerdyakov> ...and you'll find the proportion has gone down, even limited to "technically inclined" people.
17:00:21 <Darius> Compare the proportion of -people- on the 'net interested in coding -at all- today v. 1996
17:00:45 <Smerdyakov> That's where the above specialization comes into play. :)
17:01:57 * Riastradh coughs *cough*Erlang*cough* at shapr and ducks.
17:02:04 <shapr> Riastradh: good point
17:05:44 <Darius> shapr: serverLoop = do ssock <- accept fromWherever;forkIO (doSomethingWith ssock);serverLoop
17:05:58 <shapr> nice, thanks
17:06:37 <Darius> That's a basic outline of the loop, I'd have to look up the signatures to be more precise.
17:07:37 <shapr> I'll see if I can write a tiny one from that
17:08:24 <Darius> You should be able to knock out a very basic subset-of-HTTP/1.0 webserver in a page or less.
17:08:49 <shapr> ok
17:12:33 <andersca> yay
17:12:35 * andersca now supports cameras
17:14:34 <shapr> hi GreyLensmen 
17:14:53 <GreyLensmen> hey shapr
17:15:12 <shapr> how's code?
17:15:54 <GreyLensmen> always changing.  I'm a language butterfly.
17:19:02 <shapr> sounds like fun
17:20:18 <shapr> Darius: yay, it really *is* that easy
17:20:23 * shapr bounces
17:24:38 <shapr> man, the hierarchical libs need huge amounts of docs
17:24:43 <GreyLensmen> can anyone speak about Clean on Linux?  I hear its faster the Haskell without requiring lots of strickness notation intervention and I was hoping to get some decent 2d graphics and GUI.  But it looks like Clean on Linux is pretty crippled.  In fact, GHC may have better bindings then Clean for that stuff on Linux.  So all Clean would give me is a bit of speed boost.
17:24:56 <GreyLensmen> Fair summary???
17:25:06 <shapr> I've heard that myself
17:25:22 <shapr> that Clean isn't very good on Linux
17:25:30 <shapr> but I haven't tried it myself, so I'm not sure.
17:25:41 <Darius> I believe Clean developement happens mainly on Win32; it certainly seems that Clean support is better for Win32.
17:27:37 <shapr> what's the advantage of BlockBuffering being the standard setting?
17:27:52 <Riastradh> Do you really _care_ about speed?  Simple 2D graphics are not going to need blinding, hardware-accelerated speed; for a GUI you'll be using an FFI wrapper over some existing GUI toolkit in C, so the speed won't be any different from apps written in C that use that toolkit.
17:28:23 <shapr> I always vote for expressiveness over speed.
17:28:41 <shapr> I'm probably biased, I have an SMP machine.
17:29:32 <shapr> I bet there's some sensible higher order way to describe a network protocol
17:30:18 <Riastradh> shapr, an HTTP request is a monad; return sends the result to the user and >>= extracts the input form data.
17:30:31 <Darius> return should do nothing.
17:30:37 * Riastradh was being silly.
17:30:52 <Riastradh> Admittedly, it wasn't very funny at all.
17:31:23 <Darius> Riastradh: That isn't too far from how WASH works.
17:31:55 <shapr> Hey Joe
17:32:05 <Darius> (not that close, but not -that- far)
17:33:38 <shapr> I sent in some WASH bug reports recently
17:34:10 <GreyLensmen> Riastradh: I find those that have not had to substantive real world programs are always the first to dismiss "speed".  For many, by no means all, applications you just gotta have it.
17:34:26 * Darius would describe the monad in WASH as a serializable resumption (continuation) monad
17:34:56 <shapr> GreyLensmen: I've made nearly all of my income from Zope in the last year plus
17:35:05 <shapr> Zope is written in Python
17:35:07 <Riastradh> GreyLensmen, what such applications are these?
17:35:11 <GreyLensmen> not all classification.
17:35:35 <GreyLensmen> Currently?  
17:35:46 <Riastradh> ?
17:36:38 <shapr> I think development time is most important in commercial software development. You can almost always throw more hardware at a problem.
17:37:20 <GreyLensmen> nope.  rarely in fact.
17:37:37 <Riastradh> GreyLensmen, please answer my question.
17:37:55 <Riastradh> Or clarify what your response 'Currently?' means so I can inquire more specifically.
17:38:03 <GreyLensmen> Fine.
17:38:42 <SamB> io is generally the bottleneck in servers, isn't it?
17:38:47 <shapr> yup
17:39:02 <shapr> hi SamB, how's code?
17:39:40 <SamB> I haven't written a whole lot lately.
17:42:27 <Riastradh> GreyLensmen...
17:43:16 <GreyLensmen> Define a dimension as a Concept Ladder.  Implement this a partial ordered set, or a DAG.  A Domain is a set of Dimensions.  Now take a catalog of ~ 50,000 skus.  Now pre-build a "drilldown" graph where the user can "refine" his search by refining independently in any dimension.  Do this by crossing every sku with the Concept Ladder by calculating the LCA and then GCA for interstitual drilldown state.  Do this in real time, because all o
17:43:17 <GreyLensmen> ntract Customers have custom catalogs of several 1000s of skus.
17:44:30 <Smerdyakov> Riastradh doesn't even have experience with half-real-world applications. :D
17:44:47 <shapr> Smerdyakov: prove your superiority by being very quiet.
17:44:52 <Riastradh> GreyLensmen, OK, you've given me precisely one example, which doesn't exactly generalize to many other applications.
17:45:08 <SamB> GreyLensmen: okay, that clearly needs speed.
17:45:26 <Arnia> shapr: Hey... what's WASH? :)
17:45:59 <shapr> Arnia: Web Authoring System Haskell - by Peter Thiemann
17:46:02 <shapr> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
17:46:08 <shapr> WASH has a very spiffy logo.
17:47:07 <GreyLensmen> Riastradh: For the love of God.  Admit that there exists SOME applications that require lots of crunching of information in a relatively short period of time.  Then just accept the fact that sometimes your language of choice needs "speed".
17:48:14 <Riastradh> GreyLensmen, of course I concede that _SOME_ applications require it.  But 'some' is not 'most' or 'nearly all,' and indeed it is not a particularly large fraction of 'real-world applications.'
17:48:23 <shapr> GreyLensmen: in my experience with Python and Jython, I can write a program quickly, and then profile the slow parts and rewrite those in C or Java.
17:48:38 <shapr> those parts have always turned out to be very small parts, and easily optimized.
17:48:45 <Smerdyakov> Except if Java is too slow, as well! :D
17:49:51 <Arnia> shapr: Looked at Zope3 yet?
17:49:56 <shapr> nah, is it cool?
17:50:14 <shapr> I've seen enough of Plone lately to make me ill.
17:50:24 <Arnia> shapr: Yeah... component-architecture. You can swap components in and out
17:50:26 <Riastradh> And even _then_, it's not the _language_ choice.  It's the _compiler_ choice.
17:50:46 <Arnia> shapr: Plone 1.0 I presume... Plone 2 is very very much nicer *says the plone developer*
17:51:05 <shapr> I'll probably install plone 2.0.1 or so
17:53:39 * shapr grumbles at library shadowing
17:54:03 <Arnia> shapr: Its worth looking at Plone 2 now
17:54:28 <shapr> ok, I'll install it locally when I get a chance.
17:54:55 <Arnia> If only cos its WAI-AAA out of the box :)
17:56:22 <shapr> it's what?
17:56:35 <shapr> hey, Peter Thiemann's Email code that comes with WASH looks pretty cool
17:58:58 * shapr cackles happily
17:59:06 <shapr> X-Mailer: WASH/Mail 0.1
17:59:28 <Arnia> shapr: The highest accessibility standard. My partner did well :)
17:59:56 <shapr> runyaga seemed a bit irritable today.
18:02:14 <shapr> this is great, WASHMail does binary and multipart MIME as well.
18:05:41 <shapr> hrm
18:05:47 <Arnia> shapr: runyaga is very busy atm and his patience is a bit low
18:06:06 <shapr> yah, I can understand that.
18:06:28 <shapr> the price of fame and fortune, everyone wants more from you.
18:10:48 <shapr> sendmail $ simpleMail ["user@hostname.com"] "greets" $ textDOC "plain" ["hello","from me"]
18:10:50 <shapr> pretty simple
18:13:14 <andersca> neat!
18:14:18 <shapr> anyone seen any POP3 libs for Haskell?
18:15:01 <Riastradh> shapr, ooh, I've seen POP3 libraries (plural) for Scheme!
18:15:16 <shapr> I want one for Haskell
18:15:48 <Smerdyakov> I've seen them for C, which means I've seen them for both those languages, automatically.
18:16:34 <shapr> Lunar^: did you ever find any POP3 libs written in Haskell?
18:16:38 <Riastradh> Smerdyakov, yes, you may be able to easily write an FFI binding for it, but a) that's ugly: you shouldn't depend on C; b) it would take more work to make an _elegant_ interface to a C library than to just write an interface to it.
18:21:13 <shapr> I don't see anything on google
18:21:25 <Riastradh> shapr, write a POP3 library!
18:21:34 <Riastradh> POP3 isn't that complicated, is it?
18:22:17 <shapr> don't think so
18:38:56 <forkv> good afternoon, all
19:00:20 <shapr> whue!
19:00:44 <sjj> find one?
19:00:59 <shapr> no
19:01:03 <shapr> but I had fun looking
19:01:09 <sjj> heh :)
19:01:19 <shapr> it's now 4am
19:01:23 <shapr> and I gotta wake up at 9am
19:01:31 <sjj> ouch
19:02:02 <shapr> should be fun :-)
19:02:03 <SyntaxLaptop> shapr: I'm thinking of going to bed over on *this* side of the world :)
19:02:47 <shapr> @yow
19:02:47 <lambdabot> Somewhere in DOWNTOWN BURBANK a prostitute is OVERCOOKING a LAMB CHOP!!
19:02:49 <shapr> man
19:03:07 <shapr> well, time to sleep
19:04:09 <sjj> night
19:04:54 <SyntaxLaptop> peace shapr. thanks for the email.
19:09:24 * TripleDES time to sleep
20:28:00 <Smerdyakov> New debate: The pros and cons of good things.
20:30:07 <Smerdyakov> Begin now
20:31:17 <ski> Why do we have good things ?
20:31:55 <Smerdyakov> The people. The people demand it.
20:32:13 <ski> Is that a good thing ?  (in itself)
20:32:27 <Smerdyakov> It's not clear. What does your heart say?
20:33:08 <ski> Umm, I dunno. I'll guess I have to wake it up again, then ...  (waitaminute)
20:33:46 * ski reboots heart
20:34:52 <ski> *pling*  *dudunk* *du* *du* *dududunk* *dudunk* *dudunk* *dudunk* ...
20:34:59 <blackdog> there it goes
20:35:30 <Smerdyakov> Pling-a-ling-ling, says the dripper.
20:36:10 <ski> heart says : "The people sometimes also demand non-good things."
20:37:13 <ski> But perhaps, the non-good things are also good to some people ?
20:37:52 <ski> Is OO good ?  (to at least some people)
20:40:59 * ski exclaims "Oh, the horror of pour-soi !", while sipping a cup of clod tea.
20:41:08 <Smerdyakov> It's good to the people who write books about it.
20:41:17 <Smerdyakov> And they have a right to be happy like all men.
20:41:50 <ski> But, do they have a right to be unhappy ?
20:43:11 <ski> And think of all the good-looking covers !  Lots of bright colorful pictures on them !
20:43:35 <Smerdyakov> Bright colorful pictures have a role to play.
20:43:39 <Smerdyakov> Don't underemphasize that.
20:43:48 <ski> They must !
20:45:05 <ski> Hmmm, tea is good. Even if cold.
20:46:01 <ski> (Really dunno about clod, perhaps something for earthy types)
20:53:37 <juhp> that does it
20:53:59 <juhp> there are already ocaml packages in fedora extras
20:54:23 <juhp> i must kill^wsubmit a ghc package ;-)
20:54:27 <SamB> OO is okay if you don't get carried away
20:56:09 <ski> But do anyone of the OO types really understand OO ?    (or anyone at all ?)
20:56:24 <juhp> sure, it's just a shame ocaml got packages in before ghc ;-)
20:56:40 <ski> I guess one would have to really understand OO to tell that ...
20:57:50 <ski> juhp : "got packages in" ?  in where ?
20:58:17 <juhp> in the fedora project
20:58:46 <juhp> aka community-based Red Hat Linux
20:59:11 <ski> a distro ?
20:59:21 <juhp> yep
20:59:24 <ski> k
20:59:41 <juhp> well, they're in fedora.us currently
20:59:55 <juhp> which will become Fedora Extras
20:59:55 <SamB> I don't think anybody fully understands OO. Its not like its an exact science ;-)
21:00:44 <juhp> anyway i'm planning to contribute ghc packages soon :)
21:02:46 <ski> SamB : It sometimes seems like an amalgam of several separate things. Whereof some more interesting are e.g. coalgebras, subtyping, ...
21:04:16 <SamB> coalgebras?
21:05:33 <ski> you know Haskells (and SMLs,OCamls as well) data types ?
21:06:07 <SamB> a little
21:06:17 <ski> like "data Maybe a = Nothing | Just a"
21:06:27 <ski> or "data Bool = False | True"
21:06:43 <ski> ok
21:06:58 <SamB> I know about those, yeah.
21:07:14 * SamB notes that he is lagged
21:07:33 <ski> (haskells, etc  data types is also called algebraic datatypes)
21:08:03 <ski> this defines a new type and simultanously defines constructor functions for it
21:08:34 <SamB> yeah
21:08:35 <ski> (which we might match against in pattern matching)
21:09:07 <ski> well, coalebraic datatypes is the dual (in a sense) of algebraic datatypes
21:09:36 <SamB> hmm
21:10:34 <ski> when you define a coalgebraic datatype, you also simultanoulsy define selectors / deconstructors / field accessors / destructors / methods (lots of different names, yeah ;) for it
21:11:25 <ski> wanna see some small examples in pseudo-haskell ?
21:12:42 <SamB> sure
21:13:46 <ski> well, pairs, e.g. :   (this is also a parametric type, just like the Maybe type is)
21:14:02 <ski> data Pair a b = Fst :: a  &  Snd :: b
21:14:48 <ski> (btw, this type definition looks a bit like haskells current "records")
21:15:01 <ski> so Fst and Snd are selectors
21:15:22 <ski> the types of them are of course :
21:15:29 <ski> Fst :: Pair a b -> a
21:15:36 <ski> Snd :: Pair a b -> b
21:15:58 <ski> (so far this isn't very new)
21:16:58 <ski> (currectly we can do this in haskell : "data Pair a b = MkPair {fst :: a , snd :: b}", quite analogous, right ?)
21:17:19 <ski> (with the same types of the selectors)
21:17:23 <ski> ok ?
21:18:13 <ski> anyway, currently if we wanna bind foo to a pair we have to say something like :
21:18:19 <SamB> ok
21:18:38 <ski> foo = MkPair {snd = 43 , fst = "This is the first"}
21:20:03 <ski> with the coalgebraic type (as well as the pseudo-haskell syntax (don't punish me, SyntaxPolice !)) we can instead say :
21:20:06 <SamB> uh huh
21:20:15 <ski> Fst foo = "This is the first"
21:20:18 <ski> Snd foo = 43
21:20:23 <ski> nice ?
21:21:31 <ski> we can also do more interesting types
21:21:31 <SamB> ski: so you have to bind to both Fst and Snd on foo?
21:21:39 <ski> yes
21:22:04 <ski> quite a bit like the several definitions that we have, when pattern-matching
21:23:24 <ski> e.g. we could perhaps have a type something like (rough sketch) :
21:24:42 <ski> data Widget = Paint :: (Int,Int) -> IO () & moveTo :: (Int,Int) -> Widget & getBGColor :: Color & setBGColor :: Color -> Widget & ...
21:25:06 <ski> so you would probably write in the style of :
21:25:18 <ski> Paint foo (x,y) = ...
21:25:26 <ski> MoveTo foo (x,y) = ...
21:25:37 <ski> GetBGColor foo = ...
21:25:44 <ski> SetBGColor foo = ...
21:25:54 <ski> you see ?
21:26:37 <SamB> I think so
21:26:40 <ski> (this would define a value foo of type Widget)
21:27:14 <SamB> and these selectors are limited to this one class?
21:27:34 <ski> If we want a function bar returning a widget, it (bar) having, say, type  BlaBla -> BlaBlaBla -> Widget
21:27:45 <ski> then we would write like :
21:27:59 <ski> Paint (bar blabla blablabla) (x,y) = ...
21:28:02 <ski> and so on
21:28:17 <ski> um, not sure what you are asking
21:28:35 <SamB> ski: nevermind.
21:28:56 <ski> anyway, if we compare with OO langs ...
21:29:48 <ski> then the type Widget would (very probably i think) correspond to an interface (in Java / C#) or a fully abstract class (e.g. in C++)
21:30:53 <ski> and the definitions (foo,bar) for this type Widget, would correspond to two classes/OO-constructors implementing this interface
21:30:56 <SamB> ski: oh.
21:31:37 <SamB> in Python it would correspond with an idea, which might or might not have an associated abstract class...
21:32:17 <ski> SamB : If one really wanted, one could probably have syntax like "foo.Paint (x,y) = ..." and "(bar blabla blablabla).Paint (x,y) = ..." instead of the above (prefix) notation
21:33:05 <ski> SamB : but i think something like the above proposed notation is prettier (IMO) and possibly fits better with haskells style of syntax
21:33:19 <ski> mu
21:33:23 <ski> oh
21:33:25 <ski> um !
21:33:54 <ski> SamB : is "idea" a specific concept in Python ?
21:34:07 <SamB> ski: fits haskells style better, yes.
21:35:23 <SamB> ski: python is not the kind of language which is amenable to proofs
21:35:25 <ski> but note : there's still no subtyping in this here   (this could of course be added as well, but i think one could probably have an interesting mix just with subtyping and algebraic datatypes)
21:37:03 <ski> SamB : also, if one could ever figure out how to in a nice way add (at least some) multi-methods to this, then i think the postfix-selector/method style is definitely worse than the other style (prefix i.e.)
21:39:17 <SamB> probably when you use Haskell to solve the problem, trying to shoehorn OO in as well would not be the best idea in the world... presumably theres a reason why you use Haskell, like the problem is well understood already
21:39:23 <ski> anyway, this style of writing separate definition lines for the methods/... I currently call message-dispatching (compare to pattern-matching !)
21:40:02 <ski> (what do you think of the name ?)
21:40:06 <ski> yes
21:40:44 <SamB> the name is okay
21:40:56 <SamB> its not innaccurate
21:42:37 <ski> though, i think that if one used coalgebraic datatypes, one would then get one thing the OO crowd thinks OO is good for, namely that it is quite easy to add a new value/function of Widget type (corresponding to class/OO-constructor), but harder to add a method (all "OO-classes" must be updated)
21:43:54 <ski> (this is the dual of algebraic datatype, where it is easy to add new consuming functions (using pattern-matching), but harder to add a new variant/constructor, because then one has to update all previous functions which are pattern-matching on that type)
21:44:23 <ski> do you see to dual tradeoffs ?
21:45:42 <SamB> I see how in a language like Haskell with its very strict typing you have that
21:46:18 <ski> SamB : (re. the name : i think that _message_-dispatching is more accurate than, say _method_-dispatching, because the method (what to do) is determined by the receiving object, not by the message sent to it (which is the selector/method-name))
21:47:22 <ski> yes, this is all though of with a haskell-like-typesystem in mind
21:47:29 <SamB> you seem to have forsaken inheritance
21:48:17 <SamB> in Smalltalk and Python, interfaces are much less strict.
21:48:26 <SamB> You only implement what makes sense ;-)
21:48:57 <ski> though i'm not sure how much better the various dynamically typed languages fare on this point (CLOS, ... (perhaps Attribute Grammars are also relevant here))
21:49:25 <ski> SamB : No, I haven't forsaken inheritance !  I haven't even considered it yet ! ;)
21:49:50 <SamB> ski: oh, whatever. 
21:50:17 <ski> well, I guess one could probaly default implement methods with   error "something" 
21:51:18 <ski> SamB : I try to take it slowly ...  First coalgebraic types,  and then perhaps also subtyping (this could be added without coalg. also !)
21:51:59 <ozone> ski: sorry, missed the start of this -- are you doing reserach on this right now?
21:52:46 <ski> Then *perhaps* inheritance   (note that one can also have a sort of inheritance for algebraic types.  this is a dual to the 'normal' kind of inheritance though)
21:53:32 <ski> ozone : No, not at all :/  Just some random thoughts about how we could do this kind of stuff :))
21:53:38 <ozone> ah, right
21:54:40 <ozone> ski: good message about it at http://www.mail-archive.com/haskell-cafe@haskell.org/msg01797.html
21:54:45 <ozone> (using existentials)
21:55:50 <ski> If you want to see some *real* research on this you might look up Erik Poll. A Coalgebraic Semantics of Subtyping,2001 and Subtyping and Inheritance for Categorical Datatypes,1997 is the most interesting IMO
21:56:01 <ski> ozone : thanks
21:58:00 <SamB> it seems that most people are interested in things that make programming easier more then making it like theory
21:58:31 <ozone> SamB: well, making programming easier is always better than making it harder :)
21:58:47 <ski> heh
21:58:55 <ski> well, gotta go now. sorry
22:50:26 <rt> anyone have any "must have" book recommendations for someone who wants to start writing real programs in Haskell?
23:35:18 <sjj> rt: I don't know about "must have" but I certainly enjoyed "Haskell: The Craft of Functional Programming" by Simon Thompson
