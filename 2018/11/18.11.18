00:46:26 <uboa> hiiiii :)
00:46:59 <uboa> Here's what I have for the first problem so far going through H-99. Just wanted someone to check everything I'm talking about here to make sure I'm learning things correctly haha http://kawakokosowa.me/2018/11/17/haskell-99-problem-1.html
00:52:23 <Somniad> Wow, this is one of only 16 channels on Freenode with more than 1000 users. Do that many people use Haskell, or do that many Haskell users use IRC?
00:55:34 <pavonia> Perhaps Haskell is just more complicated than other languages and requires more asking for help :p
00:55:52 <f-a> eheh nice answer 
00:56:41 <Somniad> eh, I guess it's probably the most common language that isn't imperative and/or OO
00:56:50 <Somniad> so that makes sense
00:57:39 <f-a> Somniad: there are more people in #esperanto than in #francais too!
00:57:55 <Somniad> ha, that's pretty good
00:58:24 <Somniad> there's also more than 1000 people in #python AND more than 1000 people in #python-india
01:01:07 <f-a> most likely explanation: they had a close meeting with Python bivittatus
01:05:49 <gentauro> In Haskell you ask how to do stuff while in other dev communities you ask why your app breaks
01:05:54 <gentauro> which is a main diff
01:07:00 <Somniad> gentauro: would you mind elaborating? 
01:08:16 <gentauro> Somniad: When you ask a question here, it's more on how Haskell works. Example: So how do I write an instance of Monad/Functor and so
01:08:42 <gentauro> while, I noticed, in others questions seems to be: "I did this and I keep getting this error"
01:09:17 <gentauro> My point is, once you understand how Haskell works, you just code and rarely have runtime issues (depending on which packages you use ofc)
01:09:27 <Somniad> I suspect part of this is Haskell's error messages are easily the best I've ever seen
01:09:40 <ab9rf> heh, i've had some that belie that :)
01:09:43 <gentauro> Somniad: You haven't work with Elm right?
01:09:48 <Somniad> never heard of it
01:09:54 <gentauro> I guessed ;)
01:10:04 <Somniad> great error messages?
01:10:19 <Somniad> look I'm coming from C-style languages, here. it's a low bar
01:10:28 <gentauro> But you can get some "insane" Haskell error messages as well (specially if you use nested recursive Monads and -wall -werror flags)
01:10:32 <gentauro> but you get used to them
01:10:46 <gentauro> Somniad: I worked as "pro" 3 years with C++
01:10:57 <ab9rf> i've had error messages that were almost 100 lines long :)
01:11:05 <gentauro> the template errors messages are still stuff that wakes me up at night screaming !!!
01:11:37 <gentauro> I always had the idea of making a horror movie and just show C++ template error for 1:30
01:11:45 <Somniad> heh
01:11:48 <Somniad> I'd watch that
01:11:57 <gentauro> I think I would kill a few people with hearth attacks and probably win like a trillion Oscars
01:12:01 <Somniad> but I wouldn't bring my children
01:12:22 <gentauro> I wouldn't even bring my worst enemies 
01:13:29 <Somniad> Elm, a statically typed language functional with type inference
01:13:31 <Somniad> reminds me of something
01:13:55 <Somniad> *functional language
01:15:47 <gentauro> Somniad: Yes. It's almost Haskell syntax, but differs in that is not lazy, it hasn't monadic effects and that it's aimed for FE
01:16:10 <gentauro> but it's a very nifty language with some really really nice error messages ;)
01:16:41 <Somniad> according to this Wikipedia article which provided me infinite expertise, Elm's support for higher-order functions is also pretty not there
01:16:48 <Somniad> or wait
01:16:48 <Somniad> no
01:16:57 <Somniad> "higher-kinded types"
01:17:06 <Somniad> I think that's non-trivially different
01:17:09 <Somniad> what does that actually mean
01:17:37 <ab9rf> higher-order functions are fairly trivial. higher-kinded types are a whole different ball of wa
01:17:41 <ab9rf> x
01:18:09 <Somniad> "whole different ball of wax"
01:18:10 <ab9rf> as i recall, generalized support for higher-kinded types runs into undecidability issues
01:18:24 <Somniad> oh, uh, that's... what? then what does Haskell do
01:18:45 <ab9rf> the boundaries of when type inference in the presence of higher-kinded types are still being mapped out
01:19:01 <ab9rf> when type inference is provably decidable, that is
01:20:00 <Somniad> I mean
01:20:09 <Somniad> is determining undecidability undecidable?
01:20:41 <ab9rf> in the general case, yes, obviously
01:20:48 <Somniad> well that's bad
01:21:48 <Somniad> so Haskell just hedges its bets on its type inference algorithms working for all but the weirdest of cases? 
01:21:55 <Somniad> or what
01:21:59 <ab9rf> but you can come up with a decision algorithm that is decidable for every case, and never errs toward undecidability
01:22:53 <ab9rf> haskell originally did not allow higher-kinded polymorphism. recent extensions have allowed it in cases where the inference algorithm will provably terminate (and there is an option to risk having the compiler hang)
01:23:27 <Somniad> sounds like a solid approach
01:25:53 <Somniad> this section here on kinds in LYAH doesn't even have anything that's not either * or (* -> *) or something like that
01:26:25 <ab9rf> that's because higher-kinded types are fairly complicated, and involve issues that an introductory text does not want to deal with
01:27:09 <Somniad> will a person even run into higher-kinded types without going out of their way
01:28:04 <ab9rf> Somniad: probably. there are a number of very commonly used libraries that utilize them, most notably lens.
01:28:20 <Somniad> oh, neat
01:29:46 <Somniad> "Haskell supports higher-kinded types, which are types that take other types and construct a new type." well
01:29:49 <Somniad> that sounds annoying
01:29:53 <Somniad> but also useful
01:31:46 <Somniad> on a fairly unrelated note, how do functional languages with mutable state even get by?
01:32:06 <ab9rf> that would be scala :)
01:32:22 <Somniad> without immutable state you can't do beta reduction, right? that's like, my single favorite thing about Haskell so far
01:32:29 <Somniad> confused? just reduce and reduce and reduce
01:33:15 <ab9rf> of course, scala is full of pathologies, because half of its types are immutable, and the other half are not
01:33:41 <ab9rf> although the language tries to encourage you to use immutable types
01:33:59 <mniip> Somniad, you can beta reduce
01:34:09 <mniip> but the 'set' and 'get' operators on mutable references aren't lambdas
01:34:19 <mniip> and so don't partake in beta reduction
01:34:27 <Somniad> yeah that's what I figured
01:34:59 <mniip> to explain transformations related to them you actually have to couple your term with state
01:35:26 <Somniad> isn't that just saying "you can beta reduce with mutable state if you don't beta reduce the parts with mutable state"
01:35:43 <ab9rf> they're going to be some sort of other thing; what that other thing is will depend on your implementation
01:36:10 <ab9rf> Somniad: pretty much, yes
01:36:34 <Somniad> well, I'm sure beta reduction is still a tremendously useful tool in Scala
01:38:29 <Somniad> does Scala do anything to compensate for the inclusion of mutable types, or is it more like a feature that's considered a convenience for when immutable types are just harder to use?
01:39:26 <dminuoso> AndreasK: o/ :)
01:39:42 <ab9rf> Somniad: the main reason for mutable types in scala is because scala is imbedded in the JVM and most of the JVM ecosystem relies on mutable types
01:40:51 <Somniad> now I'm wondering why you'd want a functional language embedded in the JVM instead of anything else. I'm going to the scala website
01:41:03 <Somniad> "Scala combines object-oriented and functional programming in one concise, high-level language."
01:41:34 <Somniad> that makes sense
01:41:35 <Somniad> I think
01:42:07 <Somniad> I need to sleep and can't spend all night contemplating the reason Scala exists
01:42:14 <Somniad> thanks for the good conversation though.
01:44:20 <AndreasK> :)
03:59:06 --- mode: glguy set +v govno
04:00:42 <amx> I'm writing tests for a hash function and I use test-framework. Can I use quickcheck to generate a lot of instances and make sure they are all distinct or is this a job for HUnit
04:04:45 <Rembane> amx: Can you create a generator that creates distinct tests? 
04:04:53 <Rembane> amx: Why is it important that the test cases are distinct?
04:08:19 <amx> the only property I came up with for a hash function (without collisions) is that hashing different data gives different results
04:09:00 <amx> so I somehow need to make sure test cases are distinct and need to remember previous hashes
04:09:27 <rain1> that forces the codomain to be larger than the domain
04:10:02 <__monty__> amx: Then generate pairs of inputs?
04:15:05 <amx> __monty__: containing what?
04:15:28 <c_wraith> rain1: obviously that isn't how hash functions work.  The property is more precisely expressed as "it is computationally infeasible to find inputs x, y such that x /= y and f x == f y"
04:15:51 <amx> indeed
04:17:28 <__monty__> amx: Instead of generating an input and hashing it. Just generate a pair of distinct inputs, then you can hash both and compare.
04:18:06 <amx> ah.
04:19:31 <amx> yeah that would work, good idea.
04:23:11 <rain1> c_wraith: amx>	the only property I came up with for a hash function (without collisions) is that hashing different data gives different results
04:27:19 <__monty__> Ah, you meant larger as in >=, not >? I was confused.
05:44:24 --- mode: glguy set +v fen
05:45:36 <fen> ok, so Free is an example of a "nested" container. it has a "difference zipper" representation which is unlike that for linear stacks.
05:46:55 <fen> while a list-like fifo container can be sequentially deconstructed, and the retrieved values partially reapplied to the constructor that was pattern matched on to "uncos" the values.
05:47:21 <fen> a free, or generally, a "nested" representation is almost the opposite. 
05:47:57 <fen> instead of the head value being partially applied to the constructor, the tail value is
05:48:43 <fen> which is because the first value of the top layer of the nesting is not of the type of the value contained, but of the whole nested type
05:49:17 <fen> eg for Free, deconstruct :: Free f a -> (Free f a -> Free f a,Free f a)
05:50:35 <fen> the second value there is the "first" thing contained (another `Free f a') and the "difference" (first value in the returned pair) is the rest of the top layer, partially applied to the constructor that will take the second value of that pair
05:52:04 <fen> this explains why the "nested" abstraction gives a "difference", and as a result, a difference-zipper can be used to keep track of the depth that has been navigated to going successively into the first value and descending through the nestings 
05:52:23 <fen> this is a "vertical" zipper 
05:52:57 <fen> while, if there were, `Free (Zipper f) a' the zippers at each level would be horizontal
05:53:15 <fen> this gives rise to notions of up down left and right
05:53:58 <fen> note, as the depth of the nesting corresponds to the dimensionality of the container, there is no higher dimensional equivalent of this
05:54:42 <fen> regardless of how many dimensions a grid has, this up and down corresponding to focusing on one lower dimensional section of the space
05:55:22 <fen> and left and right correspond to moving around in the top dimension of that subsection
05:58:02 <fen> note also that the rear portion of the zipper over the nesting must be updated simultaneously with the same navigation, to ensure that all layers are navigated at the same time, e.g. for 2d, x axis being the outer layer of the nesting, and the y axis being the inner layer of a depth 2 Free-Zipper, all the y axis navigations must happen at each x coordinate
05:59:34 <fen> not just at the collumn currently focused on from having fist navigated horizontally (wrt the free-zipper, not the 2d grid) to some x coordinate, and then navigating vertially down over the free zipper, to focus in on the y-axis column at this x-coordinate
06:00:33 <fen> simultaneously, all columns must be updated, by going back up the free zipper, and navigating along to each column and fmaping over them to update the y-axis focus
06:01:16 <fen> it is precisely this process of updating the other columns of the outer row that means this approach is only applicable to Cartesian grids.
06:01:45 <fen> irregular or hetrogeneous graphs have no obvious corresponding opperation
06:02:16 <fen> anyway, what this is about is that *cyclic* graphs can be included in this
06:03:21 <fen> the fifo approach of using nested list-like fifo zippers makes the whole container fifo, and there is a corresponding traversable, and even comonad instance resulting from this
06:03:47 <fen> the aim is to give a systematic way to derive the traversable pointer comonad that can be extended to cyclic graphs
06:04:14 <fen> how are cyclic graphs represented? thats why "nesting" was introduced above rather than just using Free
06:05:00 <fen> the cyclic graph is a modification of the Free linear container (Linear f => Free f a), or even (Linear f => Free (Zipper f ) a)
06:05:20 <fen> instead its; ((Nested g,Linear f) => g f a)
06:06:45 <fen> and there is a nested instance for the following modified Free; data Cyclic f a = CPure a | CFree (f (Cyclic f a)) | Cycle (Cyclic f a)
06:07:18 <fen> which has a nested instance and hence supports a "vertical" zipper
06:08:11 <fen> this means the generalised fifo traversable comonad instance applies to (Linear f => Cyclic f a)
06:08:30 <fen> as it does in general to `(Nested g,Linear f) => g f a'
06:09:38 <fen> and because of the combination of zippers at each layer, as well as the vertical zipper over the whole nesting, positions can be moved to and stencils used to access the surroundings lazily
06:10:19 <fen> (Nested g,Linear f) => Zipper (g (Zipper f)) a 
06:11:08 <fen> though again, because of the need to update adjacent rows simultaneously, this seems to lead to a restriction just to Cartesian grids
06:12:49 <fen> if this is relaxed however, the above representation can be used to represent arbitrary cyclic graphs, but where some other way is needed to maintain adjacency of neighbours at branches 
06:13:05 <fen> including over cyclic references
06:22:58 <Solonarv> fen: could you maybe do a proper writeup of all this? It's really hard to follow a stream of statements posted on IRC over multiple days.
06:44:49 <mniip> Solonarv, maybe after we figure out whether Hask is a set or a category :P
06:47:10 <Solonarv> well, trying to put one's thoughts into a coherent writeup is one way to find out if your thoughts actually are coherent ;)
06:58:06 <mniip> Solonarv, people might have... different notions of coherence
06:58:28 <mniip> at least, from our past discussions it's clear that mine is very different from fen's
06:58:53 <Solonarv> Sure. It also gives me a way of (potentially) understanding what fen's going on about
07:03:05 <mniip> (X) Doubt
07:10:11 <tsaka__> in Ghci, what's the difference between :add and :module?
07:12:01 <geekosaur> looks like :add also does a reload
07:12:50 <tsaka__> also, I'm unable to import a file (I don't want to reset current variable bindings). I tried ":cd /home/fullpath/to/src" then ":m + Utils" where Utils.hs is present in the folder I cd'ed to
07:13:04 <hpc> i always use import
07:13:26 <tsaka__> (and Utils.hs starts with "module Utils where ..")
07:13:32 <tsaka__> tried import as well, no luck
07:13:55 <tsaka__> the directory of the file shows up in ":show paths" but I can't figure out how to load it
07:14:14 <geekosaur> :module always imports from packages
07:14:22 <geekosaur> :load is for files
07:14:25 <hpc> or i use ghci /path/to/file
07:14:51 <tsaka__> :load works!
07:15:59 <dmwit> (":module always imports from packages" is not precise. After you :load a module, you can use :module on it.)
07:18:06 <dmwit> (...and `:module *` *only* works on modules you got from :load)
07:18:20 <dminuoso> Is there an elegant way to do: (\x -> (x, find_provenances recs x)) <$> insts
07:18:29 <dminuoso> Or is that as elegant as it can get?
07:18:34 <dmwit> id &&& find_provenances recs
07:19:00 <dmwit> Well, it's idiomatic anyway. Whether it's elegant or not...
07:19:24 <dminuoso> dmwit: Mmm, you mean mine is idiomatic? Im not sure whether Control.Arrow is something I want to justify when I put my ghc patch on phabricator. :)
07:19:43 <dmwit> I mean mine is idiomatic but maybe not elegant.
07:20:23 <dminuoso> Oh well. (&&&) is used in a few places.
07:20:26 <dminuoso> Thanks dmwit. :)
07:24:16 <tsaka__> :load break current bindings, any way to avoid that ..
07:24:25 <tsaka__> breaks*
07:26:56 <c_wraith> I think someone had a branch of ghci that did that, but nothing in the main line does
07:33:32 --- mode: glguy set +v Butterbean
07:45:30 <fen> Solonarv: there are 2 problems currently that require some research before a writeup. 1. the two concepts of Cartesian and inhomogenous cyclic graphs require different ways of handling adjacent pointer chasing. 2. for the Cartesian version, the lazyness of accessing the hypercube of near neighbours is not path independent, where maybe a higher dimensional version of a double linked list can have let bound values which are equivalently 
07:45:42 <bollu> why does arrow notation not allow things like `x1 <- a1 -< a2 -< a3. -< ... -< input`?
07:45:54 <bollu> I'm finding the arrow notation way more clunky than it needs to be
07:46:37 <Solonarv> because that's just 'x1 <- a1 . a2 . a3 . ... -< input'
07:47:05 <Solonarv> (using the '(.)' from Category)
07:48:48 <fen> the set of haskell types includes all the morphisms that would form its category?
07:50:59 <mniip> I can't parse that questions
07:51:02 <mniip> I can't parse that question
07:51:20 <Solonarv> I think fen is asking if morphisms in Hask are also objects of Hask
07:53:42 <fen> well, not all types can be composed with (.), so category gives a way to distinguish this right?
07:54:41 <fen> its just confusing that those types resulting from composition of morphisms, as well as those morphisms themselves are objects of the category 
07:54:50 <Solonarv> The morphisms are not objects
07:55:14 <fen> or that there is an object corresponding to each morphism
07:55:33 <Solonarv> sure: that morphism's type
07:55:57 <fen> but the point is that the set is not a group closed under (.) and thats why category structure is needed
07:56:08 <fen> well semigroup
07:56:41 <fen> er, monoid
07:57:05 <Solonarv> Int is an object; Bool is another object; (Int -> Bool) is yet another object
07:57:31 <Solonarv> even :: Int -> Bool is a morphism, but is not an object - much like 1 :: Int is not an object
08:00:10 <fen> but (Int -> Bool) is an object
08:00:28 <Solonarv> yes indeed
08:00:40 <Solonarv> I said as much
08:01:03 <fen> its like its a set of types which are not functions (what are they called, saturated?) is extended to include the morphisms of the category over this set, and this extension is repeated infinitely 
08:01:50 <Solonarv> actually, Set (the category of sets) works the same way: its hom-sets are also objects
08:02:19 <fen> hom-sets are the sets of morphisms?
08:02:30 <Solonarv> yes
08:02:50 <Solonarv> the hom-set from A to B is written Hom(A, B)
08:03:01 <fen> the confusion is about when to refer to the morphisms rather that their corresponding types
08:03:41 <Solonarv> in Hask: a morphism is *one particular* function between two types
08:04:20 <Solonarv> 'even' is a morphism, '(>= 0)' is another morphism; they're both elements of Hom(Int, Bool)
08:04:39 <fen> well, yet, thats an example of how to refer to morphisms, but thats just defining what they are, and does not count
08:04:56 <fen> is there another example?
08:04:58 <bollu> Solonarv ah yes, indeed :)
08:05:31 <Solonarv> I'm confused; what kind of example are you looking for?
08:05:36 <Solonarv> bollu: :D
08:05:58 <bollu> Solonarv have you used arrows?
08:06:12 <fen> something like "the way to talk about functors requires objects and morphisms... *goes on to describe functors in this way*"
08:06:37 <Solonarv> bollu: nope, they're too clunky for me to willingly use them and nothing has forced me to reconsider yet ;)
08:07:14 <Solonarv> fen: have you read bartosz milewski's Category Theory For Programmers? That's where I learned most of the CT I know, I'd recommend it
08:07:22 <fen> maybe
08:07:37 <fen> could have been the youtube version
08:08:27 <Solonarv> there's a text version on his website
08:08:40 <fen> there seems to be 2 different ways to describe functors
08:09:05 <fen> and the usual class, and how classes themselfs are described wrt category theory ha not been clarified 
08:10:12 <Solonarv> the 'Functor' class is, specifically, a functor from Hask to Hask; but there are broader definitions
08:10:44 <Solonarv> again, CTFP covers the subject of functors
08:10:56 <fen> actaully, how are unsaturated parametrised types (kind /= *) talked about?
08:11:09 <fen> as the functor class is over these..
08:11:21 <ski> a functor `F' from a category `C' to a category `D' consists of (a) an object-mapping `Ob_F' (a function, if you will), transforming objects of `C' to objects of `D', in symbols `Ob_F : Ob_C >---> Ob_D'
08:11:23 <fen> it cant even be a subset of the set of objects of Hask
08:11:38 <ski> and (b) a morphism mapping `Mor_F (A,B)', transforming any morphism in `C' (between two objects `A',`B' in `C'), to a morphism in `D' (between the corresponding two objects `Ob_F A',`Ob_F B' in `D'), in symbols : `Mor_F (A,B) : Mor_C (A,B) >---> Mor_D (Ob_F A,Ob_F B)'
08:12:14 <ski> (and `Mor_C (A,B)' is just another notation for `Hom_C (A,B)', or `A >--->_C B', the collection of morphisms from `A' to `B', in the category `C')
08:12:18 <fen> oh yeah, and then there is a naturality square 
08:12:20 <Solonarv> in order for F to be an instance of Functor, it must have kind '* -> *', meaning it maps a type (object in Hask) to another type (object in Hask)
08:13:04 <ski> objects in `Hask' are only the types of kind `*'
08:13:28 <Solonarv> so: things of kind ≠ * are not objects of Hask; instead they're some variety of functor from/to Hask
08:13:39 <fen> right
08:13:51 <ski> (sometimes called "concrete types". it appears sometimes people have been using that term to refer to something else, though)
08:13:54 <dmwit> (There are many things of kind /= * that are not functors from/to Hask.)
08:14:33 <fen> so is there another category for parametrised types which are unsaturated 
08:14:35 <fen> ?
08:14:37 <Solonarv> true. Perhaps I should have said "related to Hask", instead?
08:14:43 <Solonarv> sure, there are many of them
08:15:13 <ski> `Hask^Hask' e.g.
08:15:21 <Solonarv> for example, there's the category of Hask-to-Hask functors
08:15:42 <ski> also `Hask^(Hask^op)'
08:15:48 <Solonarv> its objects are functors (i.e. instances of Functor), and its morphisms are natural transformations
08:17:20 <fen> what about (forall f a. Functor f => f a) is that a subset of the set of objects of Hask?
08:17:54 <ski> that's a type
08:18:08 <ski> (not a very useful one, though)
08:18:10 <fen> its not a set of types?
08:18:17 <ski> no ?
08:18:52 <ski> inhabited only by bottom, i think
08:18:57 <Solonarv> yep
08:19:01 <fen> hmm, (Functor f => f a) is a set of types or a type?
08:19:19 <Solonarv> neither, because 'a' isn't in scope ;)
08:19:19 <ski> it's a type, provided `f' and `a' are types (or appropriate kinds)
08:19:26 <fen> argh
08:19:36 <ski> just like `x + 1' is an integer, provided `x' is an integer
08:19:39 <fen> so there are no polymorphic types in Hask?
08:19:45 <ski> sure there are
08:20:13 <ski> if you declare `newtype Const c a = MkConst c', then `Const :: forall k. * -> k -> *', so `Const' is a polymorphic type
08:20:32 <ski> (if you allow that language extension, that is)
08:20:34 <fen> (a :: *) is the set of objects of Hask?
08:20:35 <Solonarv> "polymorphic" has too many meanings to give a good answer to your question
08:20:47 <ski> `a :: *' is not a set, it's a kind signature
08:21:03 <ski> (or maybe a kind ascription)
08:21:16 <Solonarv> no, the objects of Hask are written 'Ob(Hask)'
08:21:27 <fen> its just saying that the type `a' is a polymorphic kind * type
08:21:36 <ski> no
08:21:37 <Solonarv> (I don't think they form a set, so saying "the set of objects in Hask" is wrong)
08:21:49 <ski> `a' is (presumably) a type variable. nothing polymorphic about that
08:21:57 <fen> pretty sure Hask is a Category over a Set
08:22:17 <Solonarv> that doesn't mean anything
08:22:22 * ski isn't sure what fen means by "Category over a Set"
08:22:29 <Solonarv> and anyway, the objects of Set don't form a set either!
08:22:43 <Solonarv> if they did, you have a set that contains itself, which set theory doesn't allow
08:22:54 * ski prefers only admitting (essentially) one meaning of the term "polymorphic"
08:23:22 <Solonarv> ski: that's nice, but we don't know *which* meaning that is unless you tell us
08:24:18 <ski> well, `reverse' is polymorphic means that we can apply it to a list of `Bool'eans, and get a list of `Bool'eans back. or to a list of `String's, getting a list of `String's back, &c.
08:25:26 <fen> hmm
08:25:29 <ski> so `reverse' has "many shapes" (polymorphic), however all of them fitting the same general pattern : we are allowed to use `reverse' as having type `[a] -> [a]', for any type `a' (of kind `*') that we like
08:25:55 <fen> so you say f :: a is not polymorphic but g :: [a] is ?
08:25:56 <ski> so `reverse :: [Bool] -> [Bool]', and `reverse :: [String] -> [String]', &c.
08:26:40 <ski> there's an implicit operation of starting with the polymorphic `reverse', and *specializing* it to a specific type in place of `a', e.g. getting a specialized `reverse' of type `[Bool] -> [Bool]'
08:26:45 <fen> or does this apply to e.g. f :: a -> a
08:27:04 <dmwit> fen: I think ski would say that both f and g are polymorphic, but a and [a] are not.
08:27:10 <ski> this conversion isn't written explicitly in Haskell, however (well, with an extension, we can actually write it explicitly)
08:27:12 <fen> like, id is a polymorphic function
08:27:31 <MarcelineVQ> he's not done :>
08:27:41 <ski> anyway, the actual type of the polymorphic operation `reverse' here is written `forall a. [a] -> [a]'
08:27:50 <fen> ohh, so values can be polymorphic, but if a type is polymorphic it means it can have many kinds!?
08:27:57 <dmwit> fen: right
08:28:12 <fen> eg a :: k can be a :: * or a :: # ?
08:28:19 <dmwit> ...in ski's world. Beware that not everybody uses the term this way.
08:28:38 <fen> ski is normally pretty careful. i trust ski
08:28:41 <Solonarv> fen: exactly. or a :: (* -> *) -> *
08:28:49 <ski> so, `reverse :: forall a. [a] -> [a]' means : `reverse' is a polymorphic operation, for all types `a' (of kind `*'), we can use it as having type `[a] -> [a]'
08:30:04 <ski> yes, note dmwit's point. i'm explaining it in the way which makes the most sense to me. one could use differing terminology to describe it. i'm suggesting that the terminology i'm using makes the most sense (of the suggestions i've seen)
08:30:47 <fen> then it shall be set in stone!
08:30:52 <ski> heh :)
08:31:40 <ski> using the explicit specialization notation, we have `reverse :: forall a. [a] -> [a]', the general, polymorphic, operation, otoh, and otoh we have `reverse @Bool :: [Bool] -> [Bool]', the specialized version, which is no longer polymorphic (which is thus monomorphic, the opposite of polymorphic)
08:31:44 <fen> though shalt not confuse the levity of polymorphicity 
08:31:59 <ski> but usually, this `@Bool' stuff is implicit
08:32:42 <ski> (this is sometimes called "type application", or "application of a (value) expression / term to a type (expression)")
08:33:16 <ski> anyway, note that a value (or expression) being polymorphic corresponds exactly to its type *starting* with `forall'
08:33:59 <ski> (just as a value (or expression) being a function corresponds exactly to its type having `(->)' at its root, and similarly for lists and the type constructor `[]')
08:35:34 <ski> (so, with this terminology, strictly speaking, `reverse' (the polymorphic version) isn't a function, but "a polymorphic value/operation". but since we get a function when we specialize it, we can say it's a "polymorphic function", or even "function" for short, if we're only thinking of particular (monomorphic) specializations of it (remember specialization is (usually) implicit, so `reverse' could also refer to the specialized version))
08:37:06 <ski> anyway, at this point, i hope it's not that hard to appreciate the analogy at the type level, where `Const' being a polymorphic type meaning that it has kinds `* -> * -> *', `* -> (* -> *) -> *',`* -> (* -> Constraint) -> *',&c., all captured by the pattern/template/schema `* -> k -> *', where we may fill in `k' with any kind we like
08:37:29 <ski> hence the kind of the (polymorphic) type `Const' is `forall k. * -> k -> *'
08:38:31 <ski> the type `forall a. [a] -> [a]' is (with this terminology) not a polymorphic type (it has kind `*', which doesn't start with `forall'), nor is `[a] -> [a]' or `a' (both those have kind `*', assuming `a' has kind `*')
08:39:20 <ski> so, i suppose you could say i'm using the term "polymorphic" in a polymorphic way : applying at value level, at type level, and at all higher levels that we can talk about
08:40:06 <ski> (hence, it applies at level `l', for all levels `l', hence "polymorphic" is polymorphic, since it applies in the same uniform/parametric way, regardless of which level we apply it at)
08:40:23 <ski> are you sufficiently confused, yet ?
08:41:31 <fen> no its ok
08:41:49 <ski> Solonarv : does that help explain what meaning i (prefer to) ascribe to the term ?
08:42:00 <Solonarv> it certainly does!
08:42:08 <ski> (should i mention more non-examples ?)
08:42:41 <ski> `Maybe' is not a polymorphic type, nor is `Maybe a'
08:42:55 <fen> thats clear
08:43:07 <Solonarv> as far as I'm concerned "its type/kind starts with a forall" is enough information
08:43:43 <ski> (`Maybe' is monomorphic, having kind `* -> *'. one can call `Maybe' a parameterized (data) type, or a type function)
08:44:48 <ski> (`not' is monomorphic, having type `Bool -> Bool'. `not' is a (value) function. i suppose one could call it a "parameterized value", if one wanted to)
08:44:49 <Solonarv> otoh Nothing is polymorphic, because its type is 'forall a. Maybe a'
08:44:55 <ski> yep
08:44:56 <MarcelineVQ> "<Solonarv> as far as I'm concerned "its type/kind starts with a forall" is enough information" I find this less confusing than  "values can be polymorphic"
08:45:04 <fen> polymorphic at some levity means not concerete, or not yet specialised. and the common confusion is to refer to polymorphic values as having polymorphic type. or polymorphic types as having specialised kind. both are wrong
08:45:38 <ski> i often say "polymorphic operation", by which i mean the same as "polymorphic value", when i don't want to rule out polymorphic non-functions
08:46:37 <ski> fen : yes. i think it would be similar to claiming that `[False,False,True]' is a list whose type is a list containing `Bool'
08:47:00 <fen> still, this does not clear up how to refer to types of polymorphic values wrt Hask
08:47:05 <ski> or claiming `(False,"True")' is a tuple whose type is a (type) tuple, containing `Bool' and `String' as components
08:47:18 <ski> (unfortunately, the concrete syntax of Haskell here isn't helping)
08:47:47 <ski> (a type tuple, and a tuple type isn't the same thing, just like type function and function type are distinct)
08:48:25 <ski> fen : i tend to use the term "universal type" or "`forall'-type"
08:48:34 <fen> such as those types that are made of functors 
08:48:42 <fen> which is some subset of Hask
08:48:49 <fen> or Ob(Hask)
08:48:52 <ski> (cf. how tuple types can also be referred to as product types)
08:49:09 <Solonarv> actually, it's all of Hask (up to isomorphism), because Identity is a functor
08:49:20 <Solonarv> so the distinction isn't particularly useful
08:49:39 <fen> forget that isomorphism, its ruining everything
08:50:06 * ski . o O ( fen is on the nose )
08:51:10 <Solonarv> in that case: sure, you can talk about "types which are an application of a functor"; you can even encode this in Haskell as a type family:
08:51:30 <fen> a class?
08:51:55 <ski> fen : i don't really see how to interpret "how to refer to types of polymorphic values wrt Hask" and then "such as those types that are made of functors","which is some subset of Hask","or Ob(Hask)"
08:52:00 <fen> the question is about how to talk about classes as subsets of Ob(Hask)
08:52:22 <Solonarv> type family IsFunctorApp (x :: Type) :: Constraint where IsFunctorApp (f a) = Functor f; IsFunctorApp x = TypeError ('Text "Not a functor application") -- not very complicated
08:52:52 <Solonarv> (not very useful either, IMO, but there you have it)
08:53:26 <ski> fen : i think you'd want to say a class *has* such a subcollection, but not that it *is* one
08:53:43 <ski> (since that would be forgetting the methods of the class)
08:54:23 <fen> a class corresponds to a subcollection of Ob(Hask) ?
08:54:24 --- mode: glguy set +v govno
08:55:00 * ski just denied that
08:55:39 <fen> the instances of a class ?
08:57:38 <ski> .. i suppose this is somewhat strange. essentially, we're using a type name, like `Integer', not only to select an object of `Hask', say, but also an object of (more or less) a category of total orders (instances of `Ord') over `Hask'
08:57:47 <ski> and similarly for other type classes
08:58:37 <ski> strange, because, we *could* (in mathematical terms) impose any one of many total orders on `Integer', and these would give different objects of the latter category
08:59:30 <Solonarv> one intereseting thing is that constraints form a category
08:59:34 <ski> so, it's like `Integer' refers to an element of `TO Hask' (or however you want to write the category), and only by forgoetful/underlying functor can also be used to refer to an object of `Hask'
09:00:12 <Solonarv> ...except Integer is also an instance of a bunch of other things, so it's more complicated than that
09:00:31 <ski> but this is strange because (a) we first introduce `Integer' as an object of `Hask', only later do we introduce it as an object of `TO Hask'; and (b) because there's lots of other type classes which `Integer' is an instance of, as well
09:01:37 <Solonarv> perhaps we could view a typeclass as some kind of inverse of a forgetful functor Hask^C ?
09:02:20 <Solonarv> i.e. Ord defines a canonical inverse to the forgetful functor Hask^TO
09:02:25 <Solonarv> (no idea if that makes sense)
09:02:31 <ski> i'm wondering whether one should make a conceptual distinction here between "ideal instances of a type class", and ones one can actually have in Haskell, at the same time
09:03:10 <Solonarv> I think coherence might actually be helpful, by reducing the vagueness
09:04:02 <ski> (one can't have more than one instance of a type, for a class, in Haskell .. but this often seems a bit ad-hoc, in Haskell. e.g. when we talk about isomorphic types, it's often not that clear whether we're talking about isomorphism in `Hask' or `TO Hask', say)
09:06:25 <ski> (and hence we got trouble when one was allowed to coerce between `f A' and `f R', where `newtype A = AFromR R', but there being different instances of `A' and `R', for some particular type class, which an algorithm depended on always using the same instance for the same datums)
09:07:58 <ski> the "at most one instance" seems to be used to be able to uniquely identify the object of `TO Hask', given the type name
09:08:30 <ski> perhaps, if we had some other (reasonable) way to identify the object, we wouldn't need "at most one instance" ?
09:09:14 <fen> so because Constraint is not Type, it is a different Category, and it is the interaction between these categories that is of interest?
09:09:21 <Heffalump> according to https://www.haskell.org/cabal/users-guide/developing-packages.html, if a header file is specified in install-includes in some package, any package depending on it can use that .h file. Is there anything special said package needs to do? I'm trying to use windows_cconv.h from Win32 but using #include (with CPP enabled) in a .hs file isn't finding it and the right path for the Win32 package 
09:09:27 <Heffalump> in the cabal new-build store isn't being listed on the GHC command-line
09:09:45 <ski> well, type classes like `Ord' presumably would be functors from `Hask' to `Constraint' ?
09:10:12 <ski> hmm .. one could ask to what extent covariant vs. contravariant applies here
09:11:48 <geekosaur> Heffalump, it shoudl be handled automatically, provided something (/me glares at nix) isn't interfering with compiler options or (/me glares at arch) breaking haskell packages
09:11:48 --- mode: glguy set +v fib
09:12:04 <Heffalump> geekosaur: I'm using Windows
09:12:33 <geekosaur> figured that. which means I have no idea what might be able to interfere
09:12:41 <Heffalump> geekosaur: so you think the path to the lib/include folder for the Win32 package in the cabal new-build store should be getting included on the ghc command-line automatically?
09:12:59 <geekosaur> you can inspect the pakage registration fiel to see waht it says about finding the file
09:13:25 <geekosaur> I would expct it, yes, as derived from the package db entry for the pakage that provides it
09:13:59 <ski> MarcelineVQ : well. many people prefer thinking of dynamic semantics before static semantics. that's why i focused on the behaviour of polymorphic values, before describing their types
09:14:27 <fen> such confusal
09:14:33 <ski> (saying "its type starts with `forall'" doesn't help much, if you don't know what that's supposed to mean)
09:15:38 <Heffalump> second question then: how do I a ghc-pkg describe of the specific package in the store that the cabal new-build solver is choosing?
09:16:43 <geekosaur> cabal new-exec ghc-pkg describe ... (I think)
09:16:57 <Heffalump> I tried that but I don't think it did it. I could be wrong, I'll look more closely.
09:17:01 <fen> do we have derivingVia yet?
09:18:09 <geekosaur> should be in 8.6?
09:18:11 <dmj`> fen: yes
09:18:15 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#deriving-via
09:18:31 <Solonarv> ski: Constraint forms a category (with implication as the morphisms; it's a thin category), but I'm not sure how morphisms in Hask translate to morphisms in Constraint
09:18:50 <Heffalump> cabal new-exec ghc-pkg -v2 describe Win32 makes me think it's using the standard user db, not one from the store
09:19:00 <Solonarv> so I'm not sure if it's right to call typeclasses functors to Constraint
09:19:05 <fen> maybe that will helped with the tagged dynamic instances
09:19:16 <ski> i suspect the source category here is really `|Hask|', or some such
09:19:29 <geekosaur> Heffalump, at this point you might be better off asking in #hackage
09:19:36 <dmj`> Does anyone have pointers (pun intended) on working with union types in C from hsc2hs? The documentation seems lacking. 
09:20:02 <dmj`> A simple example wil ldo
09:20:07 <dmj`> s/wil/will
09:20:07 <Heffalump> geekosaur: agreed, thanks. I think I found the package.conf file in the store as well.
09:20:53 <Solonarv> typeclasses form functors from "Hask-with-subtyping" to Constraint, but we don't have "Hask-with-subtyping", so... idk
09:21:19 <fen> Solonarv: there is nothing which says that the result of a morphism on an object in Hask would also satisfy a constraint
09:21:36 <Solonarv> fen: in order for something to be a functor, it has to map morphisms to morphisms
09:21:40 <fen> not sure derivingVia is that good! there isnt a coersion there
09:21:59 <fen> is there?
09:22:14 <fen> well they dont have the same runtime representation, thats for sure
09:22:22 <Solonarv> i.e. for Ord, you'd need to map 'f :: A -> B' to 'fOrd :: Ord A :- Ord B'
09:22:51 <fen> anyway, if its something like a newtype being used to give a completely different instance, it would mean the original instance would not be needed at all
09:23:16 <Solonarv> ... hm. Actually, it works for Ord in particular: Ord is a functor from Hask^op to Constraint
09:23:19 <fen> so no, its not a functor
09:24:19 <fen> there is no requirement that the ordering on the argument is anything like the ordering on the result
09:24:47 <Solonarv> yes, coherence throws a bit of a wrench in things
09:24:47 <fen> you would need to have "constraint preserving functions"
09:25:34 <fen> (Constrained a,(Constraints a) b) => a -> b
09:26:19 <fen> could be the type of the defining function of a class ConstrainedCoerce 
09:26:33 <Solonarv> so we can define a category Ord(Hask), where: objects are those objects of Hask which have an Ord instances, and morphisms are monotonic functions
09:27:12 <fen> no you dont need to require that its the same ordering
09:27:22 <Solonarv> *then* Ord is a functor from Ord(Hask)^op to Constraint
09:27:23 <fen> it just needs to have *an* ord instance, not the same one
09:27:23 <ski> by `|Hask|' i mean the full discrete subcategory of `Hask' : it has the same objects as `Hask', but as morphisms it only has the identities
09:27:37 <Solonarv> ah. Hm, I suppose
09:27:44 <ski> er, strike "full", i rather meant "surjective on objects"
09:27:52 <Solonarv> but I'm not sure how interesting that is
09:27:59 <ski> ("full" is "surjective on `Hom'-classes")
09:28:21 <ski> perhaps one could instead take the subcategory where morphisms are all isomorphisms
09:28:32 <Solonarv> that's what I was proposing
09:28:54 <ski> the point is that in e.g. `class Num a where (+) :: a -> a -> a; ...', `a' occurs both covariantly and contravariantly in the method signatures
09:28:54 <Solonarv> (well, it's actually a different subcategory for every typeclass)
09:29:06 <ski> (yes, of course)
09:29:27 <Solonarv> Yep, so for that one you need full isomorphisms
09:29:39 <Solonarv> (er, not "full" in the technical sense)
09:29:56 <ski> hm, or .. i'm probably misunderstanding you (confusing myself, mostly)
09:30:07 <Solonarv> bah, I'm pretty confused too
09:30:10 <fen> cant a Constraint just act to label the objects of Hask?
09:30:20 <ski> explain how a different subcategory is needed, for different classes ?
09:30:38 <fen> its not
09:30:50 <fen> there is no need to map instances to instances
09:31:34 <fen> there exists a subcategory specified by constraint preserving coersions
09:31:37 <Solonarv> for Ord, the subcategory is "types with an Ord instance, where morphisms are (strictly?) increasing functions"
09:31:47 <ski> `|Hask|' is basically a category which only takes the objects of `Hask' themselves into account, not the (arbitrary) morphisms
09:32:03 <fen> that is, morphisms between objects with the same Constraint label
09:32:28 <fen> Solonarv: thats one such subcategory
09:32:42 <Solonarv> I think |Hask| would work for every type class, but I was trying to retain more structure than |Hask|
09:33:06 <fen> but is smaller than the total set of morphisms between objects satisfying the same Constraint 
09:33:11 <ski> hm, another approach would be to instead of using `|Hask| >---> Constraint', we could try to use `Hask^op * Hask >---> Constraint' (and then probably involve dinatural transformations, when we want to talk about constrained polymorphism)
09:33:15 <fen> (Ord in this case)
09:33:34 <Solonarv> what's '>--->' ?
09:33:36 <ski> Solonarv : *nod*
09:33:46 <ski> Solonarv : functor arrow ?
09:33:50 <Solonarv> oh, right
09:34:03 <Solonarv> fen: Ord is not a Constraint, its kind is * -> Constraint
09:34:08 <fen> sorry
09:34:30 <fen> but then we are in the class of kinds
09:34:49 <fen> s/class/category
09:34:49 <amx> :t ($$)
09:34:51 <lambdabot> Doc -> Doc -> Doc
09:35:20 <Solonarv> no we're not, we're trying to view typeclasses as functors from (a subcategory of) Hask to Constraint
09:35:58 <fen> :set -XNoMultiParameterTypeclasses
09:36:24 <Solonarv> yes, ignoring multi-param or higher-kinded typeclasses for now
09:36:40 <fen> so the * -> Constraint is just an arrow
09:36:41 <fen> ?
09:36:46 <fen> between Categories!?
09:36:59 <Solonarv> that's called a functor, not an arrow
09:37:09 <fen> oh
09:37:12 <fen> thats good
09:37:29 <Solonarv> (or a functor-ish thing, anyway - we're trying to figure out how it acts on morphisms)
09:37:45 <Solonarv> I think I'm going to go take a walk and mull this over some
09:38:06 <fen> well, yeah. a Functor between |Hask| and |Constrait(Hask)|
09:38:53 <fen> Solonarv: yikes! should really do this double linked quad-tree grid thing for lazyness
09:38:59 <fen> oh there was a question about that
09:40:12 <fen> about returning linked list links as returned values from a function that updates that link, or just calling a function on the updated link to get the values its linked to
09:40:17 <fen> is one faster than the other
09:40:18 <fen> ?
09:41:18 <fen> head . tail vs something that passes the updated tail to the previous head value
09:41:27 <fen> wait thats confusing, should make a paste
09:42:25 * ski . o O ( "provolution" )
09:50:54 <dminuoso> So I just tried to feed `gcc` with my Haskell program:
09:50:56 <dminuoso> ld: warning: ignoring file App.hs, file was built for unsupported file format ( 0x6D 0x6F 0x64 0x75 0x6C 0x65 0x20 0x41 0x70 0x70 0x20 0x77 0x68 0x65 0x72 0x65 ) which is not the architecture being linked (x86_64): App.hs
09:51:16 <dminuoso> It's so weird that gcc implicitly assumed my `App.hs` to be an object file.
09:53:19 <geekosaur> gcc does that with any file it doesn't understand, since it can be e.g. a linker script
09:58:05 <freeman42x]NixOS> is there any way to specify required GHC version inside the .cabal file? or where exactly is that specified per project?
09:59:22 <tsaka__> how do you name your program numeral constants, like board size, in particular if you want to make it known that they're constants 
09:59:39 <tsaka__> i've just used "wIDTH" and "hEIGHT" so far but it does look a bit weird
09:59:49 <tsaka__> is there any best practice
10:00:12 <Lears> freeman42x]NixOS: constrain the version of base, it's tied to GHC.
10:00:32 <__monty__> tsaka__: We have immutability, so every identifier is a constant.
10:01:15 <tsaka__> __monty__: sure, but there's a conceptual difference from variables that's passed around and which  you 'modify'
10:01:41 <__monty__> Not sure I get it.
10:01:54 <freeman42x]NixOS> Lears, I tried that but run into issues: https://github.com/haskell/haskell-ide-engine/issues/947
10:04:35 <monochrom> I don't make a conceptual difference either.
10:04:36 <geekosaur> tsaka__, oen relatively recent option is a bidirectional pattern synonym https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#syntax-and-scoping-of-pattern-synonyms
10:05:19 <geekosaur> that said, I tend to consider C-style (uppercase) a C wart
10:05:52 <monochrom> I even revisionisted the C naming convention to be "because it's a macro, not because it's a constant".
10:06:13 <geekosaur> that's whatit used to be
10:06:36 <geekosaur> people "adapted" it when "const" entered the language
10:06:39 <monochrom> Oh so I got it right and I got the authentic reason :)
10:08:05 <tsaka__> __monty__:  say you're following a chain of functions, each of which takes a variable named "height" and "width" but you're zooming in on the board, thus they decrease as you follow the chain. Thus the "height" 'variable' can have different values in different functions. But the maximum/total board size never changes, from function to function, thus it can be a global variable, and having a different naming scheme can highlight that
10:08:29 <monochrom> The long term trend in the past 400 years has been decreasing the use of upper case.
10:09:01 <tsaka__> so 400 years ago they programmed only in upper case?
10:09:02 <MarcelineVQ> or at least being more specific about what lower and upper should suggest to the reader
10:09:04 <oldandwise> it's meh again. Feels great that I was able to arrive at a readable,elegant bubble sort in haskell. But i need comments to further improve: http://termbin.com/c0tz
10:09:10 <illandan[m]> monochrom:  We knew upper and lower case 400 years ago?
10:09:13 <[Leary]> My client just bugged out and I missed the last few minutes or so. freeman42x]NixOS constraining base will make sure the package doesn't try to build on the wrong GHC, but I forgot cabal probably still just tries to use what's in PATH if you don't give it another one in command line (or setting with configure?).
10:09:17 <monochrom> For example if you read Gulliver's travel, it's full of "The Long Term Trend in the Past 400 Years has been decreasing the Use of the Upper Case".  No one writes like this anymore.
10:09:22 <illandan[m]> Or even, programmed 400 years ago?
10:09:39 <geekosaur> illandan[m], ancient Greek had case
10:10:25 <illandan[m]> geekosaur: didn't know. I never read any classical languages other than Sanskrit
10:10:34 <geekosaur> that sad, I think monochrom is commenting on English gradually detaching itself from its Germanic roots
10:10:47 <geekosaur> (notice that modern German capitalizes nouns)
10:11:01 <dminuoso> Not bad. I seem to have hung GHC on compiling GHC.
10:11:07 <tsaka__> (and so "wIDTH" will be constant _across_ functions, wherever you encounter the name, but "width" will not)
10:11:24 <monochrom> haha dminuoso achievement unlocked
10:11:38 <illandan[m]> That's kinda my point. "Modern" languages know about casing. Ancient/medieval/Classical languages had none of that highfalutin' stuff :P
10:12:25 <__monty__> tsaka__: How about names for functions? Why don't you mind that those are usually lowercase?
10:12:48 <[Leary]> tsaka__: if you do want to use WIDTH I think you can set up pattern synonyms for constants.
10:13:05 <geekosaur> I even pointed at the docs thereto
10:13:33 <monochrom> "global" vs "local" made sense in C.  False dichotomy in Algol, Pascal, Haskell... any language that allows unlimited levels of lexical scoping.  An outer variable is an inner constant.  It's all relative now --- relative to lexical scoping levels.
10:13:33 <tsaka__> __monty__: well it's usually clear from the name (verb-like) that it's a function 
10:14:28 <geekosaur> haskell doesn't distinguish that so much
10:14:54 <tsaka__> i know, but reading the code, there's a conceptual difference, as highlighted above ..
10:15:00 <monochrom> And like what __monty__ said, even "addone = \x -> x+1" is a constant too.  Are you going to call it aDDONE now?
10:15:24 <tsaka__> as said, i was talking about numerical constants; values
10:15:31 <monochrom> Conceptual differences are human-made.  You can choose to unmake it.  I did.
10:16:11 <monochrom> addone is a value too.
10:16:43 * geekosaur wonders how map fits this conceptual framework of
10:16:47 <dminuoso> Also another concept I learned.. you can use guards on *bindings* not just function bindings..
10:16:49 <tsaka__> doesn't change the fact that if you open up a random function in the program, and see two variables, one named "wIDTH" and one named "width", you will immediately know that the first will have the same value in every function, the latter may now
10:16:51 <tsaka__> not*
10:16:57 <monochrom> Plus "one :: Num a => a; one = 1" is at the same time a numerical constant, a value, and can be a function too if you have a Num instance for a certain kind of functions.
10:17:38 <monochrom> That is a very useful difference in C but not so much in Haskell.
10:17:59 <__monty__> tsaka__: But that's only true if you're disciplined. So if I read your code I don't know that, I'm a skeptic.
10:18:31 <MarcelineVQ> dminuoso: ye, you can use guards on case branches
10:18:39 <monochrom> If I have 4 levels of lexical scoping then at any point of time I only care "is this a free variable in this scope or not?
10:18:55 <monochrom> Plus there is always shadowing.
10:19:03 <dminuoso> MarcelineVQ: Oh really, right now I was using something like `show_these | cond = foo\n\t another_cond = bar`
10:19:10 <tsaka__> yes, that's true, which is why I wondered about best or common practices; if there was a non-enforced guideline for distinguishing those particular kind of constants
10:19:19 <dminuoso> MarcelineVQ: Ohh right, that's how you might implement multi way if by scrutinizing on () and then using guard
10:19:21 <monochrom> There is none.
10:20:04 <monochrom> "otherwise = True" is in the Prelude and it is not "oTHERWISE", it's "otherwise".
10:20:17 <Franciman> Hi, would you suggest using cabal+nix or stack?
10:20:36 <oldandwise> hi MarcelineVQ .. here's my second scratching in my climb to the ivory tower.Bubble sort in haskell can you review it http://termbin.com/8iwi
10:21:09 <[exa]> Franciman: depends on the task probably, but personally I'd go with cabal+nix
10:21:38 <Franciman> [exa], it's a desktop application
10:21:44 <Franciman> No server, backend CI stuff
10:21:58 <[exa]> q: do you really need nix?
10:22:06 <Franciman> unfortunately yes
10:22:12 <Franciman> ghc 8.6.2 broke everything :P
10:22:25 <Franciman> now I can't compile cairo anymore
10:22:47 <monochrom> And pi is "pi" not "pI".
10:22:53 <MarcelineVQ> dminuoso: you can also where case branches
10:23:33 --- mode: glguy set +v fen
10:23:34 <MarcelineVQ> valid haskell, https://gist.github.com/MarcelineVQ/8cd59c5e575ccd6595fda2dd379a2861  idk how to translate that into { } ; form
10:23:37 <fen> https://bpaste.net/show/60af1b3fa091
10:23:37 <dminuoso> MarcelineVQ: What do you mean?
10:23:43 <tsaka__> was there supposed to be release a GHCi version without memory leak somewhere around this time.. what version was that?
10:23:53 <dminuoso> tsaka__: The best way is to not talk about it with code conventions that are easily broken.
10:24:05 <dminuoso> tsaka__: The best way to talk about "this thing is immutable" is by leveraging the type system.
10:24:25 <MarcelineVQ> shouldn't have made those both 1 hehe, doesn't matter I guess
10:24:50 <dminuoso> MarcelineVQ: Oh that's interesting, I did not know that :)
10:25:16 <dminuoso> Also learned about empty case from matthew yesterday.
10:25:54 <geekosaur> case Just 2 of { Just x -> y where { y = 1 }; Nothing -> 1 }
10:26:37 <MarcelineVQ> geekosaur: thank you
10:31:35 <__monty__> dminuoso: Empty case?
10:31:48 <dminuoso> % :set -XEmptyCase
10:31:49 <yahb> dminuoso: 
10:31:51 <MarcelineVQ> oldandwise: I don't know what bubblesort is but good job. for myself I'd avoid using _ in front of identifiers because that's also syntax for typed holes, or a convention for things like Lens generation of the lens package, I don't know if that's actually a big deal in practise, the error it could give you isn't particularly hard to figure out.
10:31:57 <MarcelineVQ> > let _goo = 3 in _goo
10:31:58 <lambdabot>  3
10:32:00 <MarcelineVQ> > let _goo = 3 in _goao
10:32:01 <dminuoso> % f x = case x of {}
10:32:01 <yahb> dminuoso: 
10:32:02 <lambdabot>  error:
10:32:02 <lambdabot>      • Found hole: _goao :: t
10:32:02 <lambdabot>        Where: ‘t’ is a rigid type variable bound by
10:32:06 <dminuoso> __monty__: ^-
10:33:17 <__monty__> dminuoso: Hmm, can't imagine a use for this? Unless Void's involved or something?
10:33:45 <monochrom> Yes, Void is involved.
10:33:51 <oldandwise> thanks MarcelineVQ 
10:33:54 <dminuoso> __monty__: It's to scrutinize empty data types like Void.
10:34:15 <dminuoso> __monty__: so you might have: f x :: Void -> a; f x = case x of {}
10:35:02 <__monty__> Ah, ok. TIL
10:38:23 <MarcelineVQ> oldandwise: some people would suggest _bsort x = x below  _bsort (x:xs)  instead of _bsort []  = [] and _bsort [x]  = [x] but I don't think it matters so much. List is essentially set in stone so people know what the cases are.
10:38:28 <ab9rf> dminuoso: i'm unclear on how that's useful
10:38:38 <MarcelineVQ> If you were using your own datatype I'd avoid using  _bsort x = x  because it won't draw your attention to recheck the function if you change your datatype's defintion.  like if we had
10:38:44 <MarcelineVQ> data Some a = One a | None  and a function getSome x (One a) = a; getSome x None = x
10:39:11 <MarcelineVQ> er darnit,  a function getSome x (One a) = a; getSome x y = x
10:40:37 <MarcelineVQ> And we changed Some to  data Some a = One a | None | Many [a]   getSome wouldn't complain about missing cases with -Wall on and we'd never get our list of [a] from Many
10:41:54 <MarcelineVQ> since getSome x y = x covers the Many case already, but doesn't actually give you what Many holds, it just spits out x
10:45:34 <MarcelineVQ> if our function was instead getSome x (One a) = a; getSome x None = x  we'd get a warning about missing the Many case when we changed Some, provided we had -Wall or -Wincomplete-patterns enabled
10:48:31 <MarcelineVQ> ab9rf: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#empty-case-alternatives usefulness covered here
10:49:14 <ab9rf> MarcelineVQ: thanks, i'll look at that as soon as i get a browser that works :\
10:50:21 <MarcelineVQ> basically ghc is able to know more about what  case x of {}  is capable of inflicting on your program than error "unreachable case"  is
10:50:56 <MarcelineVQ> which helps for avoiding, what we see as, spurious warnings and in type-fu-resolving
11:03:20 <Vivit> I'm trying to define an instance of "Show" for the type  (Natural -> Die) , where  Die  is defined as  data Die = D Natural deriving (Show)
11:03:31 <Vivit> How complex is what I'm trying to do?
11:04:25 <Vivit> Basically, I want the data constructor  D  to be showable on its own
11:05:35 <Matt2843> Hey anyone in here by chance familiar with Dempster-Shafer theory and belief functions?
11:07:37 <fen> https://bpaste.net/show/e8d626b0a1da
11:08:40 <dminuoso> Vivit: Not possible as far as I can tell.
11:08:42 <fen> Matt2843: bays?
11:08:50 <fen> bayes*
11:09:13 <fen> there are some good algorithms with belief propegation 
11:09:19 <fen> whats the question?
11:09:51 <dminuoso> That being said.. I really want `justShowIt :: a -> String`
11:12:30 <ski> Vivit : each (total) value of that type (`Natural -> Die') is infinitely large
11:13:08 <fen> https://ieeexplore.ieee.org/document/47808
11:16:11 <ski> dminuoso : i assume you know about `:sprint' and `:print' in GHCi
11:16:34 <meck> Hi, anyone got a good way of managing LLVM installs on macos for use with -fllvm? I haven't had the best experience setting up nix on a mac. Right now i just installed the correct version with brew and muck about with the path accordingly?
11:17:53 <Matt2843> +fen A belief function is defined by these axioms: B1. Bel(Ø) = 0, B2. Bel(W) = 1 and B3. is the inclusion-exclusion rule where = is replaced by >=
11:18:13 <meck> As far as i can see there is no way to specifiy a location when invoking ghc
11:19:05 <fen> whats the question Matt2843?
11:19:37 <Matt2843> So let W = {w, w'} and define Bel({w}) = 1/5, Bel({w'}) = 0 and Bel(W)  = 1 and Bel(Ø) = 0, I need to show that Bel is a belief function
11:19:54 <fen> sorry thats off topic for this channel 
11:19:55 <ab9rf> MarcelineVQ: i was wondering if empty case would be more useful with dependent types or some other type feature that i wasn't imagining at the time
11:20:11 <Matt2843> fen: Yes i'm aware but theres no good place to ask this question
11:20:16 <dminuoso> ski: Im hacking on GHC and there's so many things I'd *really* love to trace.
11:20:20 <Matt2843> and I thought that logicians may reside in here ^^
11:20:26 <fen> that does not make this a good place
11:20:49 <ski> __monty__ : `case ... of {}' is also to scrutinize GADTs
11:21:22 <dminuoso> ski: I think Ill just reuse Ryans trick here: https://gist.github.com/RyanGlScott/9999b1ed78e265d9bd38c6d40c5e56fe
11:21:35 <dminuoso> Maybe coupled with some template haskell machinery
11:22:10 <ab9rf> (had to reboot, and make lunch, sorry for the long lead on that comment)
11:22:37 <ski> dminuoso : what's that for ?
11:23:03 <monochrom> Some uses of dependent types involve Void, so empty case could get involved too.
11:23:20 <ski> ab9rf : GADTs
11:23:26 <monochrom> But not majorly actually.
11:24:40 <dminuoso> ski: So you could use that to construct Eq/Show/Whatever instances that have some types inside that cant have Eq/Show like IO or functions
11:25:02 <ski> __monty__,ab9rf : e.g. `data IsBool :: * -> * where ItsBool :: IsBool Bool' with `dead :: IsBool Ordering -> a; dead x = case x of {}'
11:25:39 <dminuoso> ski: Say because you some large `data Foo = Foo { f_baz :: [Int], f_foo :: String, f_baz :: Integer, f_nope :: IO () }` which you cant have a Show instance for because of a single field.
11:25:43 <dminuoso> Which can be rather frustrating.
11:26:23 <dminuoso> I hear there's some plugin which gives you kind of "does not have an instance" constraint, with that you could probably use generics to automatically derive Show instances for such cases
11:27:25 <ski> with `data Nat = Z | S Nat' and `data Vec a :: Nat -> * where N :: Vec a Z; C :: a -> Vec a n -> Vec a (S n)' we get e.g. `head :: Vec a (S n) -> a; head (C x _) = xs' which is exhaustive, because `N' doesn't have type `Vec a (S n)'
11:27:49 <ski> one can imagine other cases where there are sometimes actually no alternatives left, so `case ... of {}' can be useful then
11:29:18 <ski> dminuoso : well, does the `f_nope' field visibly/observationally affect the behaviour of values of type `Foo' ?
11:29:48 <dminuoso> ski: No. I just want some low effort "show me as much as you can" tool
11:30:03 <ski> values with distinct behaviour ought to `show' to different `String's
11:30:47 <ski> if you just want to show info in the interactor/debugger, then something like `:sprint'/`:print' is what i'd look into
11:33:26 <dminuoso> ski: Mmm, maybe it's something to look into. Though it might be hard to use this from GHCi.
11:53:26 <mniip> dminuoso, that reminds me
11:53:48 <mniip> I came up with a way to get a debug toString function that doesn't break referential transparency
11:54:16 <mniip> just, instead of  a -> String, it should have type  a -> (forall c. String -> c) -> b
11:54:34 <dminuoso> mniip: You were the one who showed me that serialising into STG/Core broke ref transparency right?
11:54:42 <mniip> that can be used to implement  a -> IO String
11:54:52 <mniip> via throw/catch
11:55:30 <mniip> dminuoso, maybe
11:56:03 <mniip> there's plenty of ways in which two values could have different internal representations but that are otherwise extensionally equal
11:56:35 <mniip> anything that would break this extensional equality (by returning a pure Bool) would also break RT
12:11:01 <Vivit> What's the problem with the expression  length someList / 5 ?
12:11:37 <Vivit> "No instance for (Fractional Int) arising from a use of `/'"
12:11:40 <Welkin> it needs parentheses around the parameter
12:11:59 <Welkin> oh
12:12:07 <Welkin> length gives an Int
12:12:19 <Welkin> (/) only works on fractional values
12:12:25 <Welkin> you need to use fromIntegral
12:12:39 <Welkin> > fromIntegral (length [1,2,3]) / 5
12:12:41 <lambdabot>  0.6
12:12:55 <shiona_> or, if you want to use integer division use `div`
12:13:25 <Welkin> but no one wants integer division except masochists
12:13:40 <Solonarv> well, depends what you're doing
12:14:38 <Welkin> may as well use mod or rem then
12:14:55 <Welkin> :t divMod
12:14:56 <lambdabot> Integral a => a -> a -> (a, a)
12:15:00 --- mode: glguy set +v cornelius
12:16:43 <Solonarv> true, most of the time I want divMod
12:16:45 <mniip> what's a good reason to ever use rem
12:16:58 <Welkin> it's different in how it handles negatives
12:16:59 <mniip> whenever I have to use % in C I really want mod and have to reinvent the wheel
12:17:00 <Welkin> I don't know
12:17:02 <Welkin> never used it
12:17:24 <Welkin> > rem -4 1
12:17:26 <lambdabot>  error:
12:17:26 <lambdabot>      • Could not deduce (Num t0)
12:17:26 <lambdabot>        from the context: (Num (t -> a -> a -> a), Num (a -> a -> a),
12:17:33 <Welkin> > rem (-4) 1
12:17:36 <lambdabot>  0
12:17:40 <Welkin> > mod (-4) 1
12:17:43 <lambdabot>  0
12:17:49 <Welkin> > mod (5) -2
12:17:51 <lambdabot>  error:
12:17:51 <lambdabot>      • No instance for (Num (Integer -> Integer))
12:17:51 <lambdabot>          arising from a use of ‘e_152’
12:17:54 <mniip> > rem <$> [2, -2] <*> [5, -5]
12:17:56 <lambdabot>  [2,2,-2,-2]
12:17:57 <mniip> > mod <$> [2, -2] <*> [5, -5]
12:17:59 <lambdabot>  [2,-3,3,-2]
12:17:59 <Welkin> > mod 5 (-2)
12:18:01 <lambdabot>  -1
12:18:03 <Welkin> > rem 5 (-2)
12:18:06 <lambdabot>  1
12:18:10 <Welkin> there we go
12:18:27 <mniip> :thinking:
12:18:29 <Welkin> so rem is always positive
12:18:30 <Welkin> I think
12:18:33 <mniip> > (rem &&& mod) <$> [2, -2] <*> [5, -5]
12:18:36 <lambdabot>  error:
12:18:36 <lambdabot>      • Couldn't match type ‘(Integer -> Integer, Integer -> Integer)’
12:18:36 <lambdabot>                       with ‘Integer -> b’
12:18:43 <mniip> aww
12:18:48 <Welkin> with the code golf
12:19:03 <mniip> > (corry $ uncurry rem &&& uncurry mod) <$> [2, -2] <*> [5, -5]
12:19:06 <lambdabot>  error:
12:19:06 <lambdabot>      • Variable not in scope:
12:19:06 <lambdabot>          corry
12:19:09 <Welkin> corry
12:19:09 <mniip> > (curry $ uncurry rem &&& uncurry mod) <$> [2, -2] <*> [5, -5]
12:19:09 <Welkin> haha
12:19:12 <lambdabot>  [(2,2),(2,-3),(-2,3),(-2,-2)]
12:19:25 <mniip> there
12:19:34 <Welkin> now which one is which?
12:19:35 <mniip> anyway, I know what rem /does/
12:19:46 <mniip> I was asking when does one ever want that behavior
12:20:00 <Welkin> when you only want positive values I suppose
12:20:10 <Welkin> like I said, I never used it
12:20:16 <mniip> on positive values rem and mod agree
12:20:20 <Welkin> but I can see it being useful for indexing into a ring
12:20:33 <Welkin> if you get an input a negative number, it still works
12:20:35 <mniip> that's what mod would be useful for
12:20:37 <mniip> not rem
12:20:48 <Welkin> no, because mod would give a negative value
12:20:53 <mniip> no?
12:20:54 <Welkin> indexes can't be negative
12:20:56 <mniip> see the demo above
12:21:08 <Welkin> > mod 5 (-2)
12:21:10 <lambdabot>  -1
12:21:13 <Welkin> > rem 5 (-2)
12:21:15 <lambdabot>  1
12:21:24 <mniip> and -2 is?
12:21:27 <Welkin> the input
12:21:29 <mniip> the size of the buffer?
12:21:42 <mniip> yeah nah you got that backwards dude
12:21:45 <Welkin> oh, you are right
12:22:06 <Ariakenom> somewhat relevant: Division and modulus for computer scientists https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/divmodnote-letter.pdf
12:23:57 <MarcelineVQ> Is there a particular reason there's not an Alternative (Either a) ?
12:25:29 <mniip> MarcelineVQ, what's Right x <|> Right y
12:26:20 <Welkin> Right x
12:26:22 <MarcelineVQ> Right x?
12:26:34 <MarcelineVQ> At least, following Maybe's format
12:26:36 <Welkin> isn't it the same with Maybe?
12:26:40 <mniip> and Left x <|> Left y ?
12:26:54 <Welkin> Left y ?
12:26:59 <mniip> and then empty =?
12:27:08 <Solonarv> Left is the problem. I guess you could have 'Monoid e => Alternative (Either e)'
12:27:34 <mniip> you could have Left x <|> Left y = Left (x <> y)  empty = Left mempty
12:27:43 <Solonarv> yup, that's the one I was thinking of
12:28:01 <MarcelineVQ> I see, empty, thank you mniip 
12:28:29 <Solonarv> although I'm not sure if that's lawful? it might not interact correctly with the Applicative instance
12:28:38 <mniip> eh
12:28:50 <mniip> Alternative is in the wild west
12:28:51 <mniip> no rules
12:29:23 <Solonarv> I thought it had laws? like "((<|>), empty) form a monoid"
12:29:26 <mniip> list of maybe sensible rules includes,
12:29:36 <mniip> empty and <|> are a family of monoids
12:29:42 <mniip>  <|> distributes over <*>
12:30:11 <mniip> rather, the converse
12:30:15 <mniip> <*> distributes over <|>
12:30:32 <mniip> empty is absorptive wrt <*>
12:30:46 <ski> hm, iirc there's a newtype over `Either e a' whose `Alternative' instance uses `Monoid e' ?
12:30:52 * ski can't recall the name atm
12:30:59 <Solonarv> you're thinking of Validation
12:31:01 <dminuoso> ski: Validation
12:31:04 <ski> hm, yes
12:31:04 <Solonarv> it's not a newtype though
12:31:28 <ski> ok, right
12:31:35 <ski> @hackage validation
12:31:35 <lambdabot> http://hackage.haskell.org/package/validation
12:31:42 <Solonarv> but its /Applicative/ instance is the one that needs Monoid e
12:32:13 <ski> hm, yes, just noticed
12:32:45 <Solonarv> ah, just Semigroup actually
12:33:00 <__monty__> Working on an exercise implementing lenses. Why didn't the typechecker catch the occurs check error with the first definition? It's what I expected but didn't get until writing the second definition, where I no longer expected it. http://ix.io/1spp
12:35:19 <lyxia> Is there an occurs check error in the first?
12:36:46 <__monty__> lyxia: No, there's a type error as expected but the inferred actual type seems wrong to me.
12:38:25 <lyxia> __monty__: t has type   (a -> K (Endo [a]) a) -> s -> K (Endo [a]) s     so an application of t has type   s -> K (Endo [a]) s
12:38:32 <__monty__> lyxia: Both errors are in the paste btw.
12:39:27 <__monty__> lyxia: It should, but why doesn't it infer the argument's type first?
12:42:30 <__monty__> lyxia: Like, id (5 :: Int) would surely be inferred to have type Int, not type a?
12:44:41 <mniip> __monty__, it will have type a with context (a ~ Int)
12:44:45 <mniip> which can be tidied to Int
12:46:09 <geekosaur> I don't think you get a guarantee as to what order it solves these in, and if it discovers an error before it has fully resolved it it would report with what it knows at that point?
12:47:49 <__monty__> Hmm, so this is just an unlucky occurrence, i.e. in a similar situation it might've complained about the occurs check?
12:48:01 <Vivit> Is there any way to keep a very small  number from showing in scientific notation?
12:48:12 <libertyprime> hey guys. im trying to get a haskell environment that works. im hitting brick walls trying to get it going. any tips on how to proceed? https://github.com/mullikine/mullikine.github.io/blob/master/debugging-haskell-environment.org
12:49:31 <dminuoso> The Glorious Glasgow Haskell Compilation System | version 7.10.3
12:49:52 <dminuoso> libertyprime: Are you required to work with some industry legacy project?
12:49:58 <geekosaur> Vivit, not with Show. you can use routines in the Numeric module, or Text.Printf.printf
12:50:19 <libertyprime> too old? nah i dont care about legacy. i care about cutting edge only :P
12:50:34 <geekosaur> ...7.10.3
12:51:05 <Vivit> geekosaur: Does the Numeric module have the option to show fractions in percentage form?
12:51:12 <libertyprime> haha. ok i will update ghc. i get the hint
12:51:15 <Vivit> That's what I'm trying to implement.
12:51:24 <tauoverpi[m]> At least it's supported by Eta and GHCJS...
12:51:49 <geekosaur> nothng predefinedfor it, but that's just multply by 100 and format with showFFloat or etc.
12:53:41 <geekosaur> > (\p -> Numeric.showFFloat Nothing (p * 100) "%") 0.45
12:53:44 <lambdabot>  "45.0%"
12:55:27 <Vivit> Is there arbitrary-precision truncation?
12:55:52 <Vivit> I mean, it wouldn't be hard to implement, but if it's already there I'd like to use what's already there.
12:57:53 <geekosaur> > (\p -> Numeric.showFFloat Nothing (p * 100) "%") 0.4520134
12:57:55 <lambdabot>  "45.20134%"
12:58:20 <geekosaur> afaik it forces the ".0" just to demonstrate tat it's a floating value in that case
13:04:24 <__monty__> Have to say I'm thoroughly enjoying these exercises. It's the first time I've been able to let myself be completely guided by the types since Agda.
13:05:00 <libertyprime> is a global installation of ghc ever really required? or can i get away with just installing on a per-project basis using stack?
13:05:55 <MarcelineVQ> libertyprime: it is not
13:06:12 <libertyprime> cool
13:07:52 <sm> I have stack downloading ghc right now, and it's really slow. Anybody else ?
13:08:18 <jlamothe> I don't know if this is the right place to ask, but is there a way to get stack to use a specific git repo/branch instead of Hackage for one package? I've pit in a pull request, but the maintainer hasn't touched the code in almost a decade.
13:08:44 <jlamothe> put*
13:08:50 <Solonarv> sm: the initial download can take a while
13:08:59 <sm> jlamothe: yes there is, see the docs for the exact spelling
13:09:12 <MarcelineVQ> jlamothe: yes, it's fairly straightforward  https://docs.haskellstack.org/en/stable/yaml_configuration/#git-and-mercurial-repos
13:09:31 <sm> Solonarv: it's really bad though.. stalling in fact
13:09:48 <jlamothe> Thanks! Not sure how I missed that.
13:10:03 <sm> the docs are not well organised..
13:10:14 <Solonarv> sm: you might be able to download GHC yourself and somehow point stack at it? not sure how to do the latter, though
13:11:22 <sm> I can wait, I'm just wondering if it's a global issue or just me
13:11:41 <jlamothe> I have no expectations of a swift merge to my PR. The bug was reported 3 years ago.
13:21:58 <sm> also, is anybody else seeing haskell-src-exts rebuild every time, with latest stack and GHC ?
13:25:33 <sm> "Ignoring package haskell-src-exts, from (InstalledTo Local,"/Users/simon/src/PLAINTEXTACCOUNTING/hledger/.stack-work/install/x86_64-osx/nightly-2018-11-14/8.6.2/pkgdb/"), due to wrong location: (Just (InstalledTo Local),Snap)"
13:26:26 <MarcelineVQ> not uncommon with nightlies, by latest do you mean released or git?
13:26:55 <sm> released
13:28:52 <sm> ah, this seems to be https://github.com/commercialhaskell/stack/issues/3922.. if only I could understand that
13:31:10 <geekosaur> makes sense to me, it's failing because happy is a buidl tool, and because buidl tools aren't considered part of the snapshot it looks like an external dependency
13:37:00 <sm> ok, though I don't have any direct dependency on happy that I can see
13:37:15 <sm> out of time for now. Thanks o/
13:37:27 <geekosaur> the point is hasell-src-exts does
13:37:52 <geekosaur> whichis why it looks "always out of date", because it can't find the happy dependency in the snapshot
13:38:08 <geekosaur> (because it's a build tool, so not considered)
13:57:54 <Vivit> showFFloat is giving me lots of 99999999999999s
13:58:04 <Vivit> how do I How do I avoid that?
14:00:59 <geekosaur> rounding. floating point does that/
14:01:21 <[exa]> Vivit: it's an inherent property of 'exact' floats
14:01:27 <geekosaur> fi you ask for indefinite precision, you get to see that floating point is an approximation
14:06:38 <Ariakenom_> > 0.1 + 0.2
14:06:40 <lambdabot>  0.30000000000000004
14:08:18 <geekosaur> basically, if you want ideal precision, use Rational or one of the exact floating types (e.g. CReal), and avoid irrational and transcendental numbers
14:13:42 <Vivit> geekosaur: I get that. I want rounding. And the reason I want rounding is so that I only have a few digits after the decimal point. Lots of nines isn't a few digits.
14:14:00 <Vivit> I don't really want exact precision.
14:14:14 <geekosaur> then relace Nothing with (Just #digits)
14:14:32 <geekosaur> > (\p -> Numeric.showFFloat (Just 2) (p * 100) "%") 0.4520134
14:14:34 <lambdabot>  "45.20%"
14:15:16 --- mode: glguy set +v macalinao
14:17:30 --- mode: glguy set -v macalinao
14:24:05 <Ariakenom_> geekosaur: is CReal a "floating" type?
14:25:46 <geekosaur> no. http://hackage.haskell.org/package/numbers-3000.2.0.2/docs/Data-Number-CReal.html
14:26:18 <geekosaur> the package also has fixed-precision real number types
14:27:45 <Welkin> cereal
14:28:44 <[exa]> I can't believe that "floating CReals" associated to cereals floating in milk and I'm hungry now
14:29:20 <geekosaur> surreal?
14:31:43 <[exa]> :]
14:43:10 <Ariakenom_> nitpick satisfied
14:45:37 <geekosaur> ye, I should have said real number type. but then, one of the non-floating types (secretly rationals) calls itsefl BigFloat
14:47:09 --- mode: glguy set +v masaeedu[m]
14:48:32 <masaeedu[m]> i noticed that it also typechecks with `arr f = rmap f Control.Category.id`. not sure if there is some way to demonstrate that `arr f = lmap f Control.Category.id = rmap f Control.Category.id` is valid
14:51:02 <dmwit> I'm missing some context (perhaps you said something before you got +v'd?) but it would be very unusual for lmap f id = rmap f id to hold.
14:51:27 <masaeedu[m]> no, sorry. i just didn't provide enough context
14:51:38 <masaeedu[m]> i was reading a bit about how arrows are equivalent to strong profunctors
14:51:48 <masaeedu[m]> well, strong profunctor categories
14:52:07 <masaeedu[m]> and was trying to figure out how I can correctly implement `Arrow` in terms of those constraints
14:54:37 <dmwit> Hm. Maybe I take it back.
14:54:45 <edwardk> dmwit: parametricity is a hell of a drug
14:55:11 <dmwit> I was thinking of Bifunctor.
14:55:22 <dmwit> I can never keep straight which of these name pairs is for which thing.
14:55:26 * Solonarv thinks does that even type check?
14:55:59 <edwardk> Solonarv: they are different type arguments for 'id'
14:56:12 <Solonarv> oooh I see, that makes sense
14:56:31 <masaeedu[m]> yeah, they're secretly two different ids
14:56:44 <masaeedu[m]> `id_a :: p a a`, `id_b :: p b b`
14:57:00 <masaeedu[m]> both of which `id :: forall x. p x x` can be instantiated to
14:57:17 <edwardk> Massaessdu: the category of strong profunctors is not the same as just Strong + Category in haskell
14:57:33 <edwardk> zednenem wrote an article on that, catching that mistake
14:58:10 <edwardk> you may well have known that but i figured it was safer to mention than leave it unsaid =)
14:59:17 <masaeedu[m]> Well no, i actually don't know what that means. The extent of my knowledge right now is some of Bartosz Milewski articles and videos that I'm still watching
14:59:49 <edwardk> fair nuff. then consider the above thing a landmine to look out for on the path ahead ;)
15:35:04 <Vivit> Is there a "lowest element of this list" function or do I need to implement that
15:35:46 <Solonarv> :t minimum
15:35:48 <lambdabot> (Ord a, Foldable t) => t a -> a
15:36:03 <Solonarv> > minimum [3,5,6,6,3,2,8]
15:36:04 <lambdabot>  2
15:36:10 <Solonarv> Vivit: ^ that?
15:36:27 <kadoban> > minimum []  -- be careful of this though
15:36:29 <lambdabot>  *Exception: Prelude.minimum: empty list
15:36:43 <Solonarv> Aye.
15:37:00 * Solonarv wants Foldable1 in base
15:37:06 <koz_> You and me both.
15:37:37 <dmwit> http://hackage.haskell.org/package/monoid-extras-0.5/docs/Data-Monoid-Inf.html#v:minimum
15:38:11 <koz_> dmwit: Oooh, that's pretty neat.
15:38:25 <koz_> Solonarv: Is there an implementation of Foldable1 floating around someplace?
15:38:41 <Solonarv> yes, but I don't remember /where/ exactly
15:39:08 <kadoban> That is cute. For maximum you can use Just, IIRC, but then you have to remember which is which ... and that's more convenient anyway
15:41:17 <Vivit> Solonarv: thanks!
15:43:18 <geekosaur> http://hackage.haskell.org/package/semigroupoids/docs/Data-Semigroup-Foldable-Class.html#t:Foldable1
15:44:45 <koz_> Thanks.
15:48:01 <shafox> I have a Type module where I have defined all my record syntax data and types. If I am importing it to some other module, i cannot use the property function e.g. `data MyData = MyData { first : [SomeOtherType], second : Maybe AnotherType}`, I cannot access `second MyData` . 
15:48:38 <koz_> shafox: How did you do the import?
15:48:55 <shafox> while in ghci, I can see the type of `:t second` correspond to `MyData -> Maybe AnotherType` 
15:49:08 <shafox> @koz `import Type`
15:49:08 <lambdabot> Maybe you meant: yow do
15:49:29 <shafox> @koz_ ^^
15:49:29 <lambdabot> Unknown command, try @list
15:50:47 <koz_> 'second MyData' <-- I guess you mean 'second x' where 'x :: MyData'?
15:50:52 <koz_> Since MyData is a type, not a value.
15:51:01 <geekosaur> maybe the correct question is how you exported it?
15:51:08 <shafox> koz_: yes. 
15:51:14 <koz_> geekosaur: I was getting to that lol.
15:51:42 <koz_> shafox: What geekosaur asked.
15:51:43 <shafox> ah geekosaur koz_ that was it. 
15:52:11 <shafox> The way I exported was wrong. Now I added the correct module and the error vanished. 
15:52:14 <shafox> thank you :) 
16:08:19 <monochrom> This is why your data constructor name should be different from your type name.
16:08:21 * koz_ wishes I had {-# LANGUAGE LetMeTypelevelProgramAlready #-}...
16:11:15 <Welkin> monochrom: why? I always reuse names
16:11:38 <koz_> Could someone answer me this kind signature question? https://gist.github.com/kozross/fba8c962d5cc8a37063dc871992aaa44
16:12:48 <geekosaur> you might see what happens with PolyKinds enabled
16:13:10 <koz_> geekosaur: Thanks, forgot about that.
16:13:35 <monochrom> The foregoing troubleshooting demonstrated that you could have an error message that says "wth is MyData?" and if MyData is both your type name and your data constructor name then you easily get confused and make the wrong assumption about which one the error message is talking about.
16:14:00 <koz_> geekosaur: Unless I'm doing something wrong, GHCi still reports it as [*].
16:14:10 <koz_> Index (2 :<< 3 :<< 'Empty) :: [*]
16:14:45 <monochrom> Also, if someone recommends "don't look at the sun", it is not a consolation to reply "why? I do that all the time".
16:15:49 <monochrom> Or "don't smoke" -> "why? I smoke all the time".  And so on.
16:19:31 <MarcelineVQ> koz_: what kind would you like to see?
16:19:45 <koz_> MarcelineVQ: I'm just wodnering if there's something more specific possible here.
16:19:53 <MarcelineVQ> but what do you have in mind when you say more specific
16:20:04 <koz_> Since I know every element of that type-level list is a Finite n, just that the ns vary.
16:21:07 <MarcelineVQ> Finite 3 :: *
16:21:16 <koz_> Ah, I see.
16:21:25 <koz_> Thanks, that jogged my understanding.
16:30:18 <koz_> If I have a (closed, for the sake of argument) type family, is there a way I can view in GHCi what type an instance of that family actually corresponds to?
16:31:39 <hpc> maybe :info
16:33:02 <koz_> Never mind, you gotta do :t undefined :: Family Param1 Param2 Etc
16:36:06 <ski> koz_ : `:kind!' ?
16:37:48 <koz_> ski: Is that different to :k?
16:38:49 <Axman6> yes
16:38:59 <koz_> Well, that explains a bit.
16:39:06 <Axman6> also... axeman- what's going on here
16:39:24 <koz_> I've been using :k thinking it was the same, derp.
16:39:33 <koz_> We have multiple axe-people.
16:39:38 <Axman6>  :kind! will evaluate the kind, which usually means evaluating things like type families
16:39:39 <koz_> Call the SCP plz.
16:40:00 <Axman6> I wish ghi has :k! as a shorthand for :k
16:40:04 <Axman6> ghci*
16:40:21 <koz_> You mean as a shorthand for :kind!
16:41:05 <Axman6> uh yeah
16:41:32 <Welkin> secure copy?
16:41:33 <monochrom> Is there also :info! by the way?
16:41:41 --- mode: glguy set +v axeman-
16:42:01 <Welkin> Axman6: hey, it's your smaller cousin, axeman- 
16:42:11 <koz_> Welkin: Small and apparently British.
16:42:47 <Axman6> one of the prototypes must have escaped from the lab
16:43:18 <koz_> Is there a way I can define PosNat, the kind of type-level natural numbers _except_ 0?
16:43:57 <monochrom> Predicate subkind?!
16:43:58 <ski> `data PosNat = One | Succ PosNat' ?
16:44:11 <ski> no refinement kinds :/
16:44:18 <koz_> ski: I figured.
16:44:39 <koz_> Oh well.
16:47:34 <koz_> Also, do I understand correctly that Finite 0 is isomorphic to Void?
16:51:37 <axeman-> koz_: I escaped the lab without sharpening my IRC foo, why did you think I was British?
16:51:48 <koz_> Spelling of the word 'axe'.
16:52:07 <koz_> Unless the intended reading is something like 'ax e-man'.
16:52:44 <monochrom> Emanuel Ax?!
16:54:30 <ski> koz_ : yes
16:54:32 <axeman-> Ah, Good old colonisation :)
16:55:49 <koz_> ski: So it's structural or nothing, at least until Richard adds {-# LANGUAGE RefinementKinds #-}.
16:57:38 <ski> refinment types will probably be added before that
16:57:51 <koz_> ski: Don't we have a way to kinda-sorta fake those?
16:58:33 <ski> not sure what you are thinking of
16:58:53 <koz_> ski: http://nikita-volkov.github.io/refined/
17:01:24 <koz_> 97
17:01:27 <koz_> Whoops.
17:02:01 <Welkin> monochrom: I saw Emmanuel Ax play Beethoven's Emperor Concerto live
17:02:07 <Welkin> Emanuel*
17:09:57 <ski> koz_ : ok, the 3b is interesting
17:10:22 <ski> reminds me of idiomatically RT
17:10:53 <ski> (also "run-time compilation")
17:12:19 <Vivit> What functions does Haskell have for tabulation?
17:12:57 <koz_> Vivit: What do you mean by 'tabulation'?
17:13:23 <koz_> ski: 3b?
17:14:03 <ski> "So, what are the possible approaches here? I know three popular ones:"
17:15:05 <koz_> Ah, the slice :: Int -> Maybe ([a] -> [[a]])?
17:16:06 <Vivit> koz_: putting values into a legible table
17:16:23 <Vivit> Instead of Just a messy list with no spaces in it
17:17:11 <ski> yes
17:18:01 <ski> > Just (words "a messy list with no spaces in it")
17:18:03 <lambdabot>  Just ["a","messy","list","with","no","spaces","in","it"]
17:18:29 <koz_> Vivit: The Show instance for list isn't designed to be pretty-printed. I know there are several pretty printers which could do what you want, but I don't think they do it by default.
17:18:47 <ski> hmm, perhaps there's something ncurses-based ?
17:19:05 <koz_> ski: Does this need the full firepower of ncurses though?
17:19:10 <ski> or at least ANSI escapes (custom tab stops ?)
17:19:32 <ski> koz_ : probably not
17:20:32 <Vivit> I definitely don't need ncurses for this
17:28:22 <koz_> Vivit: This may be of use: https://stackoverflow.com/questions/5929377/format-list-output-in-haskell
17:28:33 <koz_> Or this, perhaps? http://hackage.haskell.org/package/pptable
18:06:09 <jonatan> under the assumption that I get to post beginner questions here: In an expression with $ splitting up "actions" where . is equivalent, is there any reason for preferring one or the other?
18:07:18 <jonatan> Got an example here, in translate. I realize it could be made pointfree, but ignoring that. https://gist.github.com/425ba24db4974bd1297a324fd5b630e2
18:20:42 <lyxia> it's purely a matter of style, they compile to the same thing
18:22:44 <monochrom> I always unprefer $
18:23:57 <monochrom> My reason is that beginners turn $ into a cargo-cult.
18:26:16 <koz_> monochrom: What do you mean by that?
18:26:26 <koz_> (also, unprefer ~ disdain)
18:26:53 <monochrom> They use the oversimplified model "$ is for getting rid of parentheses".
18:29:31 <koz_> Ah, OK. Yeah, agreed.
18:29:45 <monochrom> So one day someone thinks that "2 * (1 + 3)" can be rewritten as "2 * $ 1 + 3".
18:29:52 <monochrom> s/thinks/thought/
18:29:59 <koz_> monochrom: Have you actually seen that?
18:30:12 <monochrom> Yes.  Maybe not literally 2, 1, 3 though.
18:30:19 <koz_> Lol, fair enough.
18:30:48 <monochrom> Actually happened 1-3 months ago. Forgot the exact time.
18:32:27 <koz_> Man, I really wish massiv-sized was a thing, but I'm too inept to write it. :P
18:36:32 <dmj`> jle`: ping
18:38:34 <koz_> dmj`: LOL
18:38:47 <jonatan> Entirely the same thing. Okay :3 thank you
18:38:57 <dmj`> koz_: hm?
18:39:31 <koz_> dmj`: Your pinging of jle` right after my statement of 'I wish [dependently-typed version of X] existed but am too inept to write it' is a hilarious bit of synchronicity.
18:39:58 <koz_> Since jle` is a maintainer/contributor to vector-sized and wrote a whole bunch of stuff related to dependently-typed work in Haskell.
18:40:37 <dmj`> koz_: heh, yea I was going to ask him a question about arrays, I saw you mention massiv too
18:40:48 <koz_> dmj`: I might be able to field it if it's something easy?
18:41:01 <koz_> I'm probably about a quarter of a jle` though.
18:41:13 <dmj`> sure why not
18:42:15 * koz_ is apparently a contributor to vector-sized too, lol.
18:43:46 <jonatan> lyxia: how do you figure it compiles to the same thing, is that something along the lines of in-lining them and doing beta reductions and ending up with the same thing before anything clever happens?
18:44:27 <dmj`> koz_: It's more of a design / safety question, suppose you're FFI'ing into a C library that exposes some operations like sqrt :: Array -> IO Array,  factorial :: Array -> IO Array, would you unsafePerformIO here, or opt for a kleisli monad-esque interface (sqrt <=< factorial). I'd prefer the former, but am ok with the latter.
18:44:59 <lyxia> jonatan: yes that's right
18:45:11 <koz_> dmj`: I'm guessing they're in IO because they mutate their arguments or something?
18:46:14 <jonatan> okay!
18:46:22 <jackdk> if you're convinced that the functions in the C lib are pure, you can import them without IO in the return type
18:46:43 <dmj`> koz_: yea, anything that goes across the language boundary will need to be in IO, but since its a C library, it might be re-entrant. I should ask.
18:47:02 <koz_> dmj`: If you're _very_ sure that they're actually pure, jackdk's advice is good.
18:47:05 <dmj`> jackdk: I'm not convinced :) at all hah
18:47:23 <koz_> If not, I'd stuff it into ST personally.
18:47:48 <dmj`> koz_: is that possible?
18:48:03 <dmj`> koz_: or you mean just do it in Haskell, in ST
18:48:22 <koz_> dmj`: Yeah, with unsafePerformIO under the covers.
18:49:19 <dmj`> koz_: sounds dangerous 
18:49:25 <koz_> dmj`: It comes back to 
18:49:33 <koz_> 'how far do you trust that the C stuff behaves'?
18:49:47 <koz_> If the answer is 'I don't', better be honest about the IO.
18:49:59 <dmj`> koz_: oh it behaves, but it can fail, for sure
18:50:05 <koz_> In what way?
18:51:24 <dmj`> koz_: many ways, out of memory, driver error, runtime, invalid array, lib loading failure, symbol not found, even "unknown"
18:51:56 <koz_> Ah, it's one of those, lol.
18:52:05 <koz_> Are any of those actually recoverable from in a meaningful way?
18:52:11 <dmj`> koz_: this API exposes functions that could fill out both Num and Bits instances
18:52:33 <dmj`> koz_: but they all return IO (Either Error Array)
18:53:37 <monochrom> Wait, why is there  a driver error for computing factorials?
18:53:55 <dmj`> monochrom: you could do it on the gpu apparently
18:53:56 <koz_> The thing is, once you're in Haskell-land and you encounter an error condition in the midst of executing one of the Bits methods, what can you do besides 'vomit'?
18:55:13 <monochrom> Perhaps you can unsafePerformIO over a function that catches all those errors.
18:55:58 <koz_> monochrom: Would you be able to meaningfully define Bits or Num instances if you take this approach though?
18:56:05 <monochrom> No.
18:56:20 <monochrom> Or yes, just reinvent NaN.
18:56:25 <koz_> LOL
18:57:17 <monochrom> I am pretty sure NaN was invented for IEEE754 precisely because the Fortran and C people have never heard of exceptions therefore every function has to be total including square roots.
18:57:19 <dmj`> monochrom: that's not a bad idea. So then instead of an IO (Either Error Array) (that could be an ExceptT), we could have just an Either Error Array, but yea, no Num on that.
18:57:40 <koz_> dmj`: Bits neither.
18:59:07 <dmj`> I'd almost rather unsafePerformIO everything and act like no errors exist, try to make the safest interface to obviate your basic user errors, and then if an IO error occurs, then something has really gone wrong and your program probably should crash anyways.
18:59:15 <dmj`> Gaining Num and Bits
18:59:34 <koz_> dmj`: This is why I asked whether there's any meaningful action you can take in Haskell-land from a C-land error.
18:59:46 <monochrom> In that case you can take the stance that since "head xs" can crap out so why not your function too.
18:59:47 <koz_> Your solution is basically 'nope, you're fscked at that point'.
19:02:21 <monochrom> I think I also heard that recently base library also allows "length xs" to crap out if xs came from lazy I/O e.g. "xs <- hGetContents h" and at some point of reading you run into an I/O error.
19:03:31 <dmj`> koz_, monochrom: Basically. Would make it so that the only reason a program would crap out is due to an IO failure of some kind, not because they specific negative indices or something that can be fixed statically.
19:03:45 <monochrom> Yeah.
19:03:58 <koz_> dmj`: That's an acceptable choice if documented.
19:04:10 <dmj`> monochrom: well, main = print $ sum xs / fromIntegral (length xs) where xs = 1e9 will blow the heap on a 64GB machine
19:04:30 <dmj`> xs = [ 0 .. 1e9 ]
19:05:06 <dmj`> sum happily allocates 8GB (not including pointer indirections and intermediate cons cells), since length keeps the GC from collecting anything
19:05:29 <dmj`> koz_: agreed, it's solved
19:05:37 <dmj`> koz_: but I am still worried about CAFs and things like that
19:05:43 <dmj`> until another day I guess
19:05:56 <koz_> dmj`: That's where I nope right out, because I'm only like, a quarter of a jle`. :P
19:06:31 <dmj`> koz_: heh you should give yourself more credit
19:07:13 <koz_> Maybe so, but I am _very_ aware that my knowledge of Haskell is limited.
19:07:28 <koz_> I only recently feel confident enough to even answer questions here, lol. :P
19:08:33 --- mode: glguy set +v fen
19:09:00 <fen> kenco coffee concentrate contains coconut! its true! 
19:17:31 <koz_> Is there an easy way to create a [Finite n] containing only the even members of Finite n?
19:21:33 <MarcelineVQ> Even of n or even of value?
19:21:51 <koz_> MarcelineVQ: Corresponding to even naturals.
19:22:23 <koz_> So if we imagine that Finite 6 has inhabitants F0, F1, ..., F5, I'd wanna get [F0, F2, F4] when I call this with n ~ 6.
19:24:29 <Arahael> koz_: I'd just define data Finate = Finate Int, where Finate only deals with multiples of 2.
19:24:55 <koz_> Arahael: I was referring to the Finite coming from finite-typelits.
19:25:03 <koz_> But it's OK - I figured a few ways.
19:26:28 <MarcelineVQ> filter (even . getFinite) $ finites @6
19:26:29 <Arahael> koz_: Ah, that's beyond me, at this stage. :)
19:26:42 <koz_> MarcelineVQ: Yeah, that's one option.
19:27:25 <koz_> Arahael: It's OK - this is something I'm only recently starting to figure out.
19:27:47 <MarcelineVQ> I'm not sure you'll get better with current haskell, not that I'd know though, you're well ahead :>
19:28:09 <koz_> MarcelineVQ: I constantly feel I barely understand this stuff.
19:28:42 <koz_> A lot of my work with dependently-typed stuff in Haskell is 'read jle`'s stuff, read isovector's book, copy and modify, read compiler errors, ask if in doubt, repeat'.
19:28:43 <MarcelineVQ> There'd be other ways, if this was caught by the compiler:   4 :: Finite 3
19:30:54 <koz_> MarcelineVQ: Finite has an Enum instance.
19:30:57 <koz_> Could this potentially help?
19:32:18 <MarcelineVQ> if you like
19:32:26 <MarcelineVQ> [0 :: Finite 6, 2..]
19:32:34 <koz_> Wait that works?
19:32:58 <MarcelineVQ> sure, but if you guess wrong it's an exception
19:33:06 <koz_> Yeah, fair point.
19:33:06 <MarcelineVQ> [0 :: Finite 6, 10..]
20:04:41 <koz_> % :info :+:
20:04:41 <yahb> koz_: ; <interactive>:1:1: error: Not in scope: `:+:'
20:04:45 <koz_> % :info (:+:)
20:04:45 <yahb> koz_: ; <interactive>:1:1: error: Not in scope: `:+:'
20:12:40 <MarcelineVQ> koz_: What are you wanting to + ? :>
20:13:28 <koz_> MarcelineVQ: Still trying to write massiv-sized, lol.
20:13:38 <koz_> It's a nightmare of demotion. :P
20:38:45 <koz_> % :info Compose
20:38:46 <yahb> koz_: ; <interactive>:1:1: error: Not in scope: `Compose'
20:39:10 --- mode: glguy set +v bcherny
20:40:09 <bcherny> Can anyone think of a more elegant way to find the next node in a BST than what I came up with? https://github.com/bcherny/bst-next/blob/master/src/v2-noparent.hs
20:40:39 <koz_> bcherny: By 'next' I assume you mean 'in-order successor'?
20:45:09 <bcherny> @koz_ right, next inorder, or Nil
20:45:09 <lambdabot> Unknown command, try @list
20:47:53 <koz_> bcherny: None that I can see.
20:50:00 <bcherny> @koz_ Thanks for taking a look. A bit of a bummer :)
20:50:00 <lambdabot> Unknown command, try @list
20:57:28 <koz_> jle`: Now I'm pingin' you for dependent types help.
21:00:12 --- mode: glguy set +v nathan86
21:47:42 <koz_> Could someone help me understand this bit of dependent typing confusion? https://gist.github.com/kozross/a2c06e873eef6c9c12012a39b7819f86
22:57:02 <dminuoso> Mmm, in this example at https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/separate_compilation.html#orphan-modules-and-instance-declarations - why is module B considered an orphan instance if there is a functional dependency on E?
23:04:12 <dminuoso> Sorry, *why is module B considered an orphan module
23:41:27 --- mode: glguy set +v govno
23:53:45 --- mode: glguy set +v smash_
