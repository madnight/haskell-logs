00:02:02 <cocreature> huxpro: have you run "stack build"?
00:14:04 <MarcelineVQ> huxpro; regarding your dependencies error: assuming by "I changed the resolver to 7.10.2" you mean  resolver: ghc-7.10.2  this does not include many libs, just ghc related ones. if you want to use ghc 7.10.2 you probably want a broader resolver based on ghc 7.10.2, which would be something like  resolver: lts-3.22
00:16:26 <MarcelineVQ> though the write-you-a-haskell repo uses lts-4.2 in it's stack.yaml, which is 7.10.3
00:17:30 <MarcelineVQ> Ah, huh, weird setup, the untyped dir does use  resolver: ghc-7.8.4   
00:18:16 * hackage aos-signature 0.1.1 - An implementation of the AOS signatures  http://hackage.haskell.org/package/aos-signature-0.1.1 (sdiehl)
00:21:42 <huxpro> Thx folks! I found the problem...it's because untyped doesn't include a lisence file...which result in the whole copy step failed!
00:22:20 <MarcelineVQ> good find huxpro
00:22:27 * hackage haskoin-store 0.6.2 - Storage and index for Bitcoin and Bitcoin Cash  http://hackage.haskell.org/package/haskoin-store-0.6.2 (xenog)
00:23:17 <MarcelineVQ> Wonder if the Cabal versions at the time of ghc7 were more lenient about that
00:24:00 <MarcelineVQ> note the other-modules warnining it gives as well, best to change that too while you're at it
00:44:24 --- mode: glguy set +v eric8
00:44:32 <eric8> anyone on this late?
00:45:57 <eric8> So, is there a colloquial name for the (<>) operator in semigroups?
00:46:19 <Jacoby6000> pretty sure it's append
00:46:24 <Jacoby6000> on monoid you have `mappend`
00:46:26 <Jacoby6000> which is <>
00:46:53 <eric8> tyvm
00:47:01 <Jacoby6000> np
00:49:27 <mniip> sappend!
00:50:08 <MarcelineVQ> eric8: Is this so you can talk about it with a fellow organic?
00:50:22 <MarcelineVQ> Because if it's just for you then you can pronounce it <>  :D
00:52:37 <eric8> (typesafe use of "pronounce" detected)
00:52:46 <eric8> *unsafe
00:53:40 <eric8> It's late >.> but for real it's easier to wrap my memory around these operators when there're sounds associated with them
00:53:42 <MarcelineVQ> alright alright, call it ⊕  :>
00:53:54 <mniip> hrmph
00:54:03 <eric8> ... the ... direct sum?
00:54:05 <mniip> it be great if you could tell GHC to "coinline" a function
00:54:47 <MarcelineVQ> eric8: the symbol of the operation that in this particular case and context denotes (<>) of the Semigroup class but not in other contexts
00:55:00 <mniip> if you have   let x = ... in g x, you could "coinline" g into x by replacing all instances where x yields a value with g
00:55:47 <eric8> :) got it.
00:55:47 <mniip> especially if x is large but g is small
00:56:04 <mniip> and such an inlining allows you to remove a layer of boxing
00:59:35 <eric8> Anyone know anything about lensing?
01:00:08 <eric8> I've got a bunch of template haskell spliced lenses for some "nested" data types
01:00:51 <eric8> e.g. a = (b,c), each of b and c are themselves b = (d,e), c = (f,g) and so on
01:01:10 <eric8> Sort of a reflection of a deep JSON-ish struct
01:01:59 <eric8> Here's the question: is there a way to "auto-lens" into that nested data type to find e.g. the first instance of type d?
01:02:32 <eric8> Or, am I stuck daisy-chaining lenses?
01:02:37 <MarcelineVQ> in this case the leftmost bit of data?
01:03:03 <eric8> I'm just using tuples for illustrative purposes
01:03:22 <eric8> I mean *2-tuples
01:03:44 <eric8> Let's assume that each nested type is isomorphic to an n-tuple
01:04:11 <eric8> I think that's completely general... but at least enough for discussion :D
01:04:55 <eric8> as in, it could be `b :: (c,d,e)`
01:05:24 <eric8> we're presented with `a :: (b,g)`, and so on
01:05:46 <eric8> Task is to come up with the first instance of an `x :: d` somewhere in that hierarchy
01:06:39 <eric8> It's just that doing `a ^. b ^. d` becomes clumsy with any depth of that type nesting structure
01:06:41 <nshepperd> if you can express your type as something parameterized by d `data Foo d = Foo ((a, b), c, ...)` you can get a Traversal to that d for free, with DeriveTraversable
01:07:41 <eric8> Ok so that works for `d` in particular which is a step forward for me
01:08:00 <eric8> But what if I want that traversal for all basic types in `Foo`?
01:08:12 <nshepperd> you're certainly not supposed to do something like `a ^. b ^. d`
01:08:49 <nshepperd> lenses are meant for composing, so you should write `a ^. b . d`
01:08:50 <eric8> oh?
01:08:57 <eric8> ah ok got it
01:09:01 <eric8> ty
01:09:06 <nshepperd> and then you can extract b . d into a function and reuse it next time
01:09:16 <eric8> So that's how to do it.
01:09:30 <eric8> I have to daisy chain lenses but then I can reuse that daisy chain
01:09:37 <nshepperd> yeah
01:09:59 <eric8> well, it seems like there's an opportunity to make that whole process easier..
01:10:34 <eric8> I'm guessing types are first class values just like functions and atoms
01:11:04 <nshepperd> oh my
01:32:05 <sshine> I'm building a Tic-Tac-Toe game, and I thought that instead of a 9-tuple, I might use a vector of 9. but the 'vector' library doesn't seem to let me type-annotate the 9. does it do that, or is there another popular vector library that lets me do it, or am I in the woods here?
01:34:08 <MarcelineVQ> type-annotate?
01:34:20 <sshine> like, board :: Vector 9
01:34:56 <MarcelineVQ> Oh, vector-sized could do this
01:34:57 <sshine> sorry, board :: Vector 9 (Maybe Mark), where data Mark = X | O
01:37:33 <MarcelineVQ> Is having Maybe Mark more useful than an Empty constructor for Mark?
01:40:31 --- mode: glguy set +v schlurp
01:42:14 <sshine> MarcelineVQ, I don't know yet.
01:47:57 <MarcelineVQ> fwiw I'm not sure a sized vector is especially more useful for this task than otherwise, in that I can't think of an advantage it gives you if all boards are 9 tiles. Another option is a Fin type for indexing, which would prevent you from being able to index out of bounds, but I don't know how useful that type is in haskell.
01:48:07 <MarcelineVQ> e.g. https://hackage.haskell.org/package/fin-0.0.1/docs/Data-Fin.html
01:57:17 <mniip> something something finite-typelits and vector-sized
01:57:24 <mniip> except typelits are terrible to work with
01:57:57 --- mode: glguy set +v kamyar
01:59:14 <sshine> sounds like I might as well use a Data.Vector.
02:05:14 <kuribas> Why doesn't the time libry use text for formatting?
02:06:10 <kamyar> Can anyone check my code?
02:06:44 <cocreature> kuribas: my guess would be as so often “historical reasons”
02:07:07 <cocreature> kamyar: your first message probably got lost (to prevent spam, unregistered users can only talk after they are voiced)
02:07:26 <kamyar> Please help me fix this code: https://pastebin.com/QFYhpXvD
02:08:03 <cocreature> kamyar: show us the error message or explain the problem that you’re encountering
02:08:15 <sshine> I'm thinking about proposing that the first text-handling exercise on Exercism.io uses Data.Text. right now the test suite makes it optional.
02:08:18 <kuribas> My coworker remarked that in haskell it takes a lot of effort to do things that are supported out of the box in other languages.
02:08:43 <kuribas> µFor example the poor mysql support in haskell db libraries
02:08:47 <kamyar>  Ambiguous type variable ‘a0’ arising from a use of ‘Redis.sendRequest’
02:08:47 <kamyar>       prevents the constraint ‘(hedis-0.10.4:Database.Redis.Types.RedisResult
02:08:47 <kamyar>                                   a0)’ from being solved.
02:08:52 <kamyar> There is a problem of type interference with redis and the outer func
02:09:26 <kuribas> kamyar: that usually means you need to  provide a type
02:09:47 <cocreature> kamyar: show us the full error message including line numbers and everything (on some pastebin site)
02:09:48 <kamyar> I guess using something like liftIO this would be fixed
02:10:36 <kamyar> cocreature: Hrer is the error: https://pastebin.com/rc7qLTpn
02:11:58 <kuribas> kamyar: do you write a big blob of code, then typechrck it?
02:12:33 <kuribas> because thats a lot of type errors
02:13:52 <cocreature> "bikers" also doesn’t look like a redis command
02:14:06 <cocreature> oh they left
02:14:26 <MarcelineVQ> dc'd
02:15:22 <kuribas> I read some guy compaining that it took him 2 hours to typecheck his code. 
02:15:38 <kuribas> Then you are writing haskell like C.
02:19:06 <kuribas> I'd like to know about someone who genuinly did an effort to learn haskell, and then decided on another language.
02:19:35 <mniip> probably me at some stage
02:19:54 <mniip> been flipping back and forth
02:25:10 <MarcelineVQ> One language? If haskell teaches you anything it should be that there's no one language :>
02:25:35 <MarcelineVQ> Also all the other stuff it teaches you.
02:26:27 <Arahael> MarcelineVQ: I hoped that language was Haskell. ;)
02:27:08 <Lycurgus> "the guy" apparently didn know about quickcheck an stuff
02:29:03 <mniip> if I have   foo = go where go = .... {-# INLINE foo #-}
02:29:13 <mniip> do I understand correctly that that inlines just the foo and not the go
02:41:07 <jhrcek> I'd like to derive Show instance for newtype wrapper around Text that won't display the constructor. Is that possible?
02:41:59 <jhrcek> newtype A = A Text deriving Show
02:42:26 <jhrcek> I want `show (A "hi") == "hi"`
02:44:13 <geekosaur> (a) you cant' modify the deriving mechanism that way, but you can write a manual Show insance
02:44:32 <jhrcek> I found this article which anwers my question :) https://ryanglscott.github.io/2017/04/12/improvements-to-deriving-in-ghc-82/
02:44:34 <geekosaur> 9b) there si an assumption that Sow and Read commute and produce valid Haskell.
02:44:53 <MarcelineVQ> it's possible to write the instance yourself, but that's not what Show is intended for it's intended to show something as you'd see in real haskell code, as Read is intended to read code into data
02:45:18 <geekosaur> (Show is intended for debugging. if you want prettyprinting or etc, use your own class or you will be very unhappy at some point)
02:57:16 * hackage gi-gtk-declarative 0.2.0 - Declarative GTK+ programming in Haskell  http://hackage.haskell.org/package/gi-gtk-declarative-0.2.0 (owickstrom)
02:58:46 * hackage gi-gtk-declarative-app-simple 0.2.0 - Declarative GTK+ programming in Haskell in the style of Pux.  http://hackage.haskell.org/package/gi-gtk-declarative-app-simple-0.2.0 (owickstrom)
03:02:08 <MarcelineVQ> mniip: Hard to nail that one down :O  using the new  -ddump-ds-preopt  flag it looks like that particular where disappears very early, into let/letrec (and thus RHS) but I'm not sure if that's before or after INLINE affects things
03:06:32 <MarcelineVQ> oh neat   -dverbose-core2core is fairly informative, and seems to include   -ddump-ds-preopt
03:12:23 <megatr0nz> hello, I would like some advices on how to find the number of all (nonEmpty) palindromic subsequences of a given string (efficiently). My current solution is the straightforward approach and does not scale.
03:15:17 <kamyar> cocreature: Sorry I was disconnected! Can you help me?
03:24:45 <kuribas> MarcelineVQ: I mean not using haskell at all.  Using another language for pragmatic reasons is totally reasonable
03:25:01 <kuribas> mniip: between which languages?
03:27:48 <kuribas> MarcelineVQ: my coworker says I only read successtories of haskell because I am in a bubble
03:28:06 <kuribas> (of people who like haskell)
03:29:24 --- mode: glguy set +v lantti
03:29:31 <lantti> it's a good bubble though...
03:29:38 <kuribas> yeah for sure
03:30:38 --- mode: glguy set +v capisce
03:34:01 <capisce> everyone's in some kind of bubble
03:34:06 <lantti> considering how success stories are not as media sexy as looming catastrophies, you need to position yourself so that at least some come your way
03:34:18 --- mode: glguy set -v capisce
03:35:31 <cocreature> @tell kamyar The error message tells you that you need to specify the result type in line 12 with a type annotation. However, that line looks like it has some fairly fundamental error. Afaik "bikers" is not a redis command so you probably need to rethink what you are trying to achieve here
03:35:31 <lambdabot> Consider it noted.
03:36:12 <Uma[m]> I'm trying to use Control.Exception.try to capture the exceptions thrown by readFile and writeFile, but the program is still being halted whenever the file being read doesn't exist. Any ideas?
03:36:58 <MarcelineVQ> Uma[m]: Best to include what you're trying in a paste so people don't have to guess/ask as much to get started :>
03:38:30 <Uma[m]> MarcelineVQ: Ok! The relevant parts are here http://dpaste.com/162WK6X
03:40:34 <MarcelineVQ> hmm, that doesn't read a file  was there supposed to be more where … is?
03:42:07 <Uma[m]> Oops, pasted the part where it writes a file. Still, if I try to write to a filename that's a dir, the exception is thrown (openFile: inappropriate type (Is a directory)) and the program halted
03:42:46 * hackage som 10.1.6 - Self-Organising Maps  http://hackage.haskell.org/package/som-10.1.6 (AmyDeBuitleir)
03:43:13 <MarcelineVQ> You probably need type annotation to say what kind of exceptions you care about, based on try's documentation https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception.html#v:try
03:44:35 <Uma[m]> Oh, right, tryJust might be more appropriate
03:45:05 <Uma[m]> I should read more carefully!
03:45:39 <MarcelineVQ> possibly tryJust, or maybe TypeApplications  like   try @IOException  I've little epxerience with these myself
03:46:22 <MarcelineVQ> these being exceptions
03:47:00 <tombusby> Hey, I have a couple of "Show" object tree dumps. Does anyone know a good way to get this info pretty-printed so I can more easily see the tree strucutre?
03:47:08 <MarcelineVQ> % :t try @IOException
03:47:08 <yahb> MarcelineVQ: IO a -> IO (Either IOException a)
03:48:37 <cocreature> tombusby: take a look at the pretty-show package
03:48:45 <tombusby> cocreature: thx
03:49:23 <cocreature> Uma[m]: to be precise, your code only catches exceptions of type TaflError
03:50:10 <tombusby> cocreature: this appears to only work if you have access to the objects themselves, I just have access to the text string that basic "show" produced.
03:50:37 <Uma[m]> I could use tryJust to make every IOException into a Maybe TaflError, right?
03:51:27 <MarcelineVQ> cocreature: thank you for saying that, wasn't thinking about ExceptT's presence fixing the types
03:51:59 <cocreature> Uma[m]: either that or use fmap over the Either IOException a you get back from "try @IOException" and convert the errors appropriately
03:53:32 <Uma[m]> Ok! Thanks both for the help!
03:53:38 <cocreature> tombusby: nope, it also works when you have the String. you can parse it to a value using "parseValue" and then pretty print that
03:53:50 <cocreature> tombusby: take a look at the implementation of ppShow, that’s exactly what it does
03:54:36 <tombusby> hmm, ok, thanks again, I'll dig a little deeper into it
03:56:24 <cocreature> tombusby: fmap (show . valToDoc) . parseValue should do the trick
03:56:39 <cocreature> as for parse failures, you’ll have to decide yourself how you want to handle them
03:56:47 <tombusby> ok thanks
03:57:17 <cocreature> given that you’re probably using this for debugging. throwing in a fromJust might be acceptable
03:58:33 <Uma[m]> It works! The result is pretty terrible though, I'll try to clean up: withExceptT (const CannotLoadGame) $ ExceptT $ try @IOException $ readFile path
03:59:29 <cocreature> doesn’t look too bad, I would use some parenthesis and (.) instead of $ but that’s a matter of taste
04:34:31 <dminuoso> Is there a newtype that I can derive via to obtain a Show instance without field accesors? Or do I have to write my own?
04:40:53 <geekosaur> ? just don't use a field accessor?
04:41:09 <geekosaur> otherwise you have to write the instance manually
05:01:49 --- mode: glguy set +v mxf
05:02:25 <mxf> Hey *, what are the thoughts on here on fixplate vs. recursion-schemes vs. other libraries in the same design space? I want to transform a lisp-like AST and narrowed it down to those two packages.
05:07:24 <Shockk> hello, I have a quick question; is there a way to simplify the following code?
05:07:25 <Shockk> L.withModuleFromAST ctx lAST $ \m -> do
05:07:26 <Shockk>     BS.unpack <$> L.moduleLLVMAssembly m
05:07:38 <Shockk> I would ideally want to write something like L.withModuleFromAST ctx lAST (BS.unpack <$> L.moduleLLVMAssembly)
05:07:43 <Shockk> but of course that isn't valid
05:08:45 <cocreature> Shockk: L.withModuleFromAST ctx lAST (fmap BS.unpack . L.moduleLLVMAssembly)
05:11:07 <Shockk> cocreature: ah I think that makes sense
05:11:08 <Shockk> thanks
05:12:19 <heaven> hello Shockk, how are you doing today my friend
05:12:58 <Shockk> doing well, thanks?
05:13:21 <cocreature> Shockk: if you don’t mind me asking, what are you using llvm-hs for?
05:13:46 <Shockk> I'm picking up the language I was working on a year ago and abandoned
05:14:05 <cocreature> sounds fun :)
05:16:08 <Shockk> ideally making a language suitable to rewrite my game engine in, as well as being suitable to write game code in, to be run by the engine
05:16:44 <cocreature> ambitious :)
05:16:50 <Shockk> ikr
05:20:20 <deltasquared> a question that has been in the back of my head for a while, if you have a given number of values of a given type a, and a binary operator f :: a -> a -> a, and you were to use f in a fold (it can be assumed to be non-empty), what properties would f require such that the ordering of the list of a's passed to the fold could be completely indetermistic and still produce the same result?
05:20:38 <deltasquared> my intuition is saying f would have to be commutative and associative but I'm not sure
05:20:55 <cocreature> deltasquared: sounds right
05:21:35 <deltasquared> cocreature: I was just unsure whether commutative + associative was either stronger than needed or too weak
05:21:44 <deltasquared> certainly I wouldn't know how to go about proving it
05:24:10 <cocreature> deltasquared: in particular you want this property to hold for a list of length two so it definitely has to be commutative
05:24:46 <deltasquared> cocreature: hmm, good point
05:24:54 <deltasquared> I had not thought of that xD
05:25:27 <cocreature> you also want it to hold for a list of length 3 where [a, b, c] and [b, c, a] should return the results
05:25:45 <cocreature> i.e. (a `f` b) `f` c = (b `f` c) `f` a (assuming a left fold)
05:26:01 <Ferdirand> but if you have commutativity, you can "bubble sort" the arguments
05:26:04 <cocreature> due to commutativity that’s equivalent to a `f` (b `f` c) which is exactly associativity
05:26:42 <`slikts> how much sense does it make to say that monads are for modeling dependencies?
05:26:58 <`slikts> between computations
05:27:33 <deltasquared> hmm, I always thought of monads as being producers rather than indicating a need for something
05:27:37 <cocreature> so commutativity and associativity are definitely required. you also have to prove that their sufficient (they are) which you can probably do by induction over the list length
05:28:07 <Shockk> I think I'm missing something obvious here, but what should I do in order to get a ShortByteString from a String?
05:28:17 <deltasquared> cocreature: right, so extending the examples to (((a b) c) d) or something like that?
05:28:31 <deltasquared> and showing their equivalence
05:29:10 <cocreature> Shockk: depends on the encoding that is used for the ShortByteString
05:29:37 <Shockk> hmm, that's a tough one, go with utf-8 I guess for now?
05:30:36 <cocreature> deltasquared: in the end you have to prove that given an "f" that is commutative and assocative, and a list of inputs you get the same result regardless of how you permute the input
05:31:01 <cocreature> Shockk: why do you even need to convert to a String? that sounds somewhat suspicious (assuming we’re still talking about llvm-hs)
05:31:02 <deltasquared> cocreature: "permutations of the input", that was the phrase I was looking for previously, cheers
05:31:12 <Shockk> cocreature: not to a String, from a String
05:31:53 <Shockk> the String I have is the file name, which comes from getArgs
05:31:57 <cocreature> Shockk: ah I see! in that case, llvm-hs doesn’t care what encoding you use, so utf-8 is a fine choice
05:32:58 <Shockk> and then I want to use that file name as the LLVM module source file name and the LLVM module name, which are both ShortByteString
05:33:46 <cocreature> Shockk: the LLVM c++ libraries just treat names as opaque bytearrays which is why they’re mapped to ShortByteString in llvm-hs
05:34:05 <Shockk> ahh right
05:34:28 <Shockk> how exactly do I do the conversion from String to ShortByteString though?
05:35:35 <geekosaur> there's a potential trap hiding in here; consider https://downloads.haskell.org/~ghc/latest/docs/html/libraries/unix-2.7.2.2/System-Posix-Env-ByteString.html#v:getArgs
05:35:50 <Shockk> oh hmm, would I just do encodeUtf8 and then toShort?
05:36:36 <cocreature> Shockk: right
05:36:46 <Shockk> great, thanks
05:37:04 <cocreature> but yeah for filenames, cli args and whatnot you might want to avoid converting them to a String in the first place
05:37:19 <cocreature> at least on unix systems filenames are just bytestrings with no specified encoding iirc
05:37:38 <deltasquared> interesting, ShortByteString isn't stored on the heap? so is that like C++`s std::string short string optimisation
05:37:49 <Shockk> hmm but getArgs gives me a [String] though
05:37:58 <cocreature> Shockk: look at what geekosaur linked you
05:38:05 <Shockk> oh I missed that sorry
05:38:18 <cocreature> deltasquared: no ShortByteString totally is stored on the heap. the difference is that ShortByteString isn’t pinned
05:39:14 <deltasquared> I'm not familiar with ghc's heap internals, what would pinning mean
05:39:23 <Shockk> geekosaur: ah great thanks
05:39:23 <deltasquared> also *reading ShortByteString source* lawl accursedUnutterablePerformIO
05:39:41 <geekosaur> pinned = can't be relocated by gc
05:39:56 <deltasquared> ah, so it doesn't break raw pointers?
05:40:03 <geekosaur> right
05:40:17 <geekosaur> ebcause ByteString is often used with C / FFI
05:40:37 <deltasquared> heh, object lifetimes, the one thing of C++ I don't miss having to reason about myself
05:48:46 * hackage bulletproofs 0.2.1 -   http://hackage.haskell.org/package/bulletproofs-0.2.1 (sdiehl)
05:52:08 --- mode: glguy set -v chessai
05:55:37 <`slikts> "Monads force a denotation of sequencing." what's this mean
05:55:51 <`slikts> I know what denotational semantics are and what squencing is
05:56:05 <`slikts> but what'd be a more accessible way to translate that sentence
05:57:13 <MarcelineVQ> depends on the rest of the sentence, the one that came before it, the one after, whether we're talking about categories or haskell, etc
05:58:00 <MarcelineVQ> I think it's fair to say >>= can be seen as a sequencing
05:58:05 <Solonarv> consider the 'bind' operator: '(>>=) :: m a -> (a -> m b) -> m b'
05:58:05 <Solonarv> before you can "execute" the 'm b', you have to execute the 'm a', so that you have an 'a' to pass to the function
05:58:23 <`slikts> Solonarv: right, so there's a data dependency
05:58:39 <Solonarv> *nod*
05:59:03 <Solonarv> which means, for monads that represent some kind of effect, that these effects must occur in a certain order
05:59:23 <Solonarv> e.g. IO, State, Writer
06:00:00 <`slikts> does this also apply to commutative monads?
06:00:11 <Solonarv> I don't recall what those are
06:00:52 <`slikts> I've understood them as ones that don't order operations
06:01:37 <Solonarv> well those don't have a notion of "execution order" in the first place, so clearly >>= can't force any particular order
06:01:42 <Solonarv> a good exampe is Reader
06:02:30 <Solonarv> (or '(->) e' if you prefer0
06:02:46 <`slikts> thanks, I guess this helps
06:02:56 <mniip> well, except,
06:03:01 <mniip> State actuallt executes in reverse
06:03:13 <`slikts> that's still sequencing
06:03:33 <Solonarv> yes, and there's a reverse State somewhere too
06:04:08 <`slikts> I think the phrase "threaded state" isn't used often enough
06:04:18 <`slikts> in the context of monads or otherwise
06:05:07 <Solonarv> "you need to execute the 'm a' first so that you have an 'a' to pass to the function" is just handwavy talk to get an intuition of how >>= fixes effect order; what "fixing effect order" means depends on the particular monad
06:55:00 --- mode: glguy set +v TaufRaz
06:58:10 <max3> is anyone using the haskell layer for spacemacs? i can't figure out how to get intero tooltips to stay up
06:58:16 <max3> they disappear after like 1s
07:49:08 --- mode: glguy set +v Guest39
07:52:13 <nikivi> I was reading about the declarative approach to programming
07:52:23 <nikivi> and I got curious, can you make a fully declarative language?
07:52:42 <nikivi> in that declarative means you specify what has to be done, not the implementation 
07:53:31 <nikivi> but if everything is declarative, someone has to write the instructions to carry out the declarative code which I assume has to be done imperatively
07:54:10 <lyxia> Don't you think Haskell is declarative?
07:58:38 <__monty__> nikivi: At what point do you say something is no longer "what has to be done" but "how to do it"?
07:58:54 <nikivi> __monty__ yes
07:59:19 <nikivi> I guess the imperativeness is hidden behind implementation details
07:59:25 <nikivi> so all you are given is a declarative model
08:03:49 <__monty__> nikivi: Why does it matter there's imperative stuff underneath though?
08:04:12 <nikivi> __monty__ it doesn't. I was just curious if you can write something completely declaratively all the way to implementation details
08:06:21 <__monty__> nikivi: I'd say you can. You can satisfactorily define what a computer is in logic afaik. Logic is declarative.
08:06:38 <__monty__> You can't implement anything without implementing it though.
08:07:05 <lyxia> that's deep
08:07:43 <nikivi> so implementation by definition is imperative (just following instructions)
08:07:52 <nikivi> but how you define it can be declarative
08:07:55 <nikivi> makes sense
08:09:21 <__monty__> Definition is not necessarily imperative afaik.
08:18:16 <hugbubby> So I have code but don't know why it works.
08:19:00 <hugbubby> FOllowing the Write Yoruself a scheme tutorial and ended up making this solution to the number parser, by following linter recommendations: parseNumber = Number . read <$> many1 digit
08:19:28 <hugbubby> I'm on this part of the tutorial: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing. The heck is <$>?
08:19:42 <lyxia> fmap
08:19:44 <hugbubby> And why does it solve the type issue for exercise 1?
08:20:05 <lyxia> many1 digit   is a parser that returns a list of digits, ok?
08:20:23 <lyxia> then you need to apply read to that list
08:20:23 <hugbubby> Ok.
08:20:26 <hugbubby> Right.
08:20:46 <lyxia> more precisely you need to apply read to the result of the parser many1 digit
08:21:01 <lyxia> that's exactly what (<$>) does, also called fmap
08:21:16 <hugbubby> Could I just call read (many1 digit)?
08:21:27 <lyxia> no that's applying read to the parser itself
08:21:43 <lyxia> which makes no sense because a parser is not a string
08:23:16 * hackage nonemptymap 0.0.6.0 - A NonEmptyMap Implementation  http://hackage.haskell.org/package/nonemptymap-0.0.6.0 (ChristopherDavenport)
08:23:33 <Ariakenom> hugbubby: if do-notation helps: do {digits <- many1 digit; return (Number (read digits))}
08:24:16 <hugbubby> What is the different between x = (many1 digit) and digits <- many1 digit
08:24:19 <hugbubby> difference*
08:25:41 <cocreature> hugbubby: it doesn’t make sense to consider digits <- many1 digit on its own. you need to consider the whole expression. the one using <- is equivalent to many1 digit >>= \digits -> return (Number (read digits))
09:02:21 <pavonia> Can anyone spot something obviously wrong with this function (starting a curl process) <https://pastebin.com/raw/90kgej2h>? That call blocks on waitForProcess when debug == True, but only on some servers, and I'm not sure why. When I run the same command directly from the terminal, it seems to work fine
09:04:29 <geekosaur> stderr is larger than a buffer's worth, so curl blocks when the pipe fills
09:05:14 <geekosaur> in general you want to read process output in separate threads when possible
09:05:34 <cocreature> that looks like you are reimplementing readProcess
09:06:58 <pavonia> readProcess semms to only give me stdout while I need stderr too
09:07:23 <cocreature> readCreateProcessWithExitCode also gives you stderr
09:07:46 <cocreature> or readProcessWithExitCode
09:08:01 <pavonia> Ah, I'll try that one
09:08:04 <geekosaur> people never seem to understand the idea that if you are waiting for a process, you are not reading its (in this case) error output, and it will eventually block waiting for something to read
09:10:38 <pavonia> geekosaur: When you say I want to read the output in different threads, could I just forkIO two hGetContents calls before waitForProcess?
09:11:10 <geekosaur> presuming you have some way to get the output back where you need it, yes
09:12:36 <cocreature> pavonia: note that your code is also not exception safe. I really recommend that you use readProcess instead of trying to implement this yourself
09:13:18 <pavonia> Yeah, I will try this first
09:22:16 --- mode: glguy set +v fen
09:29:24 <Shockk> is there an easy way to do `traverse f someList` and use the last element in the resulting list, in some action, but only if the list is non-empty?
09:29:39 <Shockk> for example:
09:29:50 <Shockk> resultList <- traverse astBuilder asts
09:30:22 <Shockk> IR.ret =<< theLastResult resultList
09:30:25 <Shockk> or something
09:33:08 <fen> Shockk: there is no standard approach as yet. there being an avoidable overhead when using Maybe as a way to sort of convert non-empty into [] by using Nothing as a surrogate empty list. 
09:33:29 <hugbubby> How do you conditionally read in parsec
09:34:52 <rotaerk> hugbubby, hmm, one way might be to use...
09:34:54 <rotaerk> :t when
09:34:54 <hugbubby> like, how can I say " x <- many noneOf(somthing)" and then check and keep reading depending on something
09:34:55 <lambdabot> Applicative f => Bool -> f () -> f ()
09:35:49 <fen> Shockk: whats the type of theLastResult?
09:36:19 <rotaerk> hugbubby, what about manyTill?
09:36:28 <Shockk> Lack {of = "my understanding"}
09:36:40 <fen> ?
09:36:42 <Shockk> just a placeholder for my lack of knowledge
09:36:44 <Shockk> sorry
09:37:01 <fen> whats the type of resultList?
09:37:19 <Shockk> that would be [Operand]
09:37:33 <fen> well if its a list you can just use:
09:37:35 <hugbubby> I think I see what I'm looking for
09:37:38 <fen> :t last
09:37:40 <lambdabot> [a] -> a
09:37:50 <fen> but that would fail it it was an empty list
09:37:58 <Shockk> right, what I'm thinking is something like: 
09:38:05 <Shockk> when (not (null results)) 
09:38:11 <Shockk> and then I'd use `last` 
09:38:21 <fen> the error thrown would not match null
09:38:22 <pavonia> cocreature: readProcessWithExitCode seems to work
09:38:49 <fen> oh sorry, thats to check if its empty to avoid an error
09:38:50 <Shockk>  oh?
09:38:51 * hackage type-map 0.1.3.0 - Type-indexed maps  http://hackage.haskell.org/package/type-map-0.1.3.0 (lyxia)
09:38:58 <Shockk> yep that's what my thinking is
09:39:31 <fen> so you need an "if not null then .. else .."
09:39:38 <Shockk> I wonder if this is where, umm, I think it's called safe-prelude? may come in handy
09:39:38 <fen> kind of pattern
09:39:47 <Shockk> not sure if there's a safe `last` in there
09:39:55 <fen> well its easy to define one
09:40:00 <Shockk> that's true
09:40:17 <fen> but then how would =<< deal with the Maybe wrapper?
09:40:19 <lyxia> Shockk: https://hackage.haskell.org/package/safe-0.3.17/docs/Safe.html#v:lastMay
09:40:47 --- mode: glguy set +v noob
09:41:15 <fen> what about;
09:41:18 <fen> :t maybe
09:41:19 <lambdabot> b -> (a -> b) -> Maybe a -> b
09:42:38 <Shockk> hmm, like, `maybe (pure ()) IR.ret mLastResult` then?
09:43:09 <cocreature> :t fmap Data.List.NonEmpty.last . Data.List.NonEmpty.nonEmpty
09:43:11 <lambdabot> [b] -> Maybe b
09:44:09 <fen> yes
09:44:53 <monochrom> "pure ???" sounds right, but I bet ??? is not ().
09:45:47 <fen> right, it should match the type of IR.ret
09:49:24 <rotaerk> hmm I need to create a byte array and pass a pointer to it, along with its byte size, into something that will fill it with raw data
09:50:13 <rotaerk> should I use allocaArray, or the memory package's ByteArray, or the primitive package's ByteArray
09:50:25 <fen> on the issue of trying to work around the overhead introduce by Maybe, this latest paste shows the Comonad for Pointers (nested zippers) https://bpaste.net/show/a7132418dbf5 . it shows 2 different approaches where the S suffix indicates "safe" and there are many costly Just and fromJust opperations, such as when folding a difference list over NonEmpty (generally "Linear" instances) 
09:50:34 <rotaerk> or something else
09:51:25 <fen> if the get,getS,geti and getiS (and set,setS,seti and setiS) corresponding to linear,stack,structured and StructuredS - with difference and differenceS
09:51:34 <fen> were to be made into a library
09:51:47 <fen> it would be good to give the "fast" option aswell
09:52:08 <fen> where undefined was used instead of Nothing, and these costly Maybe functions were avoided
09:52:42 <fen> but it seems difficult to automate the refactoring of this code or any other, which is defined using the "safe" functions
09:52:54 <fen> to the "fast" approach
09:53:44 <fen> this is not the kind of API that is normally written, and its difficult to understand what it would be like
09:54:03 <rotaerk> so many byte array things, hard to tell the differences
09:55:18 <fen> but as it stands, existing code which uses less abstraction and avoids this approach is faster, and it would be a shame if the standardised library issued as a hackage repo would incur a performance penalty if used
09:55:52 <cocreature> rotaerk: if you’re interacting with the ffi, you probably want to use allocArray
09:56:28 <cocreature> fen: if you’re hoping for any kind of feedback you need to do better than post a > 600 line paste
09:56:49 <fen> but its comprehensive
09:56:55 <rotaerk> in this case, I'm reading a KTX texture file; it's got blocks of image data that I want to read straight into a buffer, given a pointer to it
09:57:25 <rotaerk> I wasn't sure if allocaArray specialized to Word as the element would be as "good" as something like primitive's ByteArray or ByteString
09:57:26 <fen> it shows each of the abstractions described working together to provide a Comonad default
09:57:44 <monochrom> Word? Word8?
09:57:56 <rotaerk> Word without a number is Word8
09:58:06 <monochrom> > maxBound :: Word
09:58:08 <lambdabot>  18446744073709551615
09:58:15 <rotaerk> err wait, maybe that's a mistake
09:58:25 <rotaerk> yeah... I mean Word8, then
10:00:13 <fen> cocreature: take like 194 for example
10:00:16 <rotaerk> k I'll just use the Foreign.Marshall.Array stuff for this
10:00:49 <monochrom> I don't know the "memory" library.  I would try allocaArray first, but keep primitive mind.  I would watch out for their APIs rather than "what are they, really?"
10:02:01 <rotaerk> the "memory" one is an abstraction; ByteArray is a class that unifies ByteString along with some other things
10:02:32 <cocreature> fen: that’s not how this works. if you want other people to look at your stuff, it’s up to you to isolate the problem to a reasonably small example. I highly doubt you need 600 lines to make your point
10:02:46 <cocreature> and if you do, fair enough but then good luck finding someone willing to disect that
10:05:01 <monochrom> Generally my strategy is first a combination of "which one is more efficient?" and "which one's API fits my use case?".  If there is a tie then "which one depends on fewer extra-GHC libraries?".  If it is still a tie then "which one I learned first?".
10:05:22 <rotaerk> heh, sounds reasonable
10:05:38 <cocreature> "memory" is mostly useful if you want to interact with cryptonite ime
10:06:12 <rotaerk> I'm dealing with endianness, but I don't find memory's endianness features useful
10:06:28 <rotaerk> because I don't care if it's big or little endian, only if it's different from or the same as the native endianness
10:06:52 <rotaerk> so I evaluate SameEndian or FlipEndian
10:09:09 <fen> cocreature: there were some much shorter pastes a while ago that described the problem exactly. the current problem is refactoring this larger piece of code to use the previous approach
10:10:10 <fen> the code in this paste shows the complete working lib code (and some peripherals, which if removed might get it below 500 lines, but they are pretty easy to read over anyway)
10:10:58 <fen> it would be possible to either trim the unnesacary parts and find these previous examples
10:11:07 <fen> d
10:12:50 <fen> cocreature: https://bpaste.net/show/f8a0407ae39c
10:16:09 <fen> this shows its faster to use type Differences f a = [f a -> f a] even for NonEmpty
10:16:19 <zachk> fen, whats with your mild obsession with non empty lists? :)
10:16:51 <fen> zachk: the library depends on them, and they are slow to work with without this magic hacl
10:17:10 <fen> basically, Free NonEmpty = RoseTree
10:17:24 <fen> while Free [] is a nightmarish mess of empty leafs
10:17:53 <zachk> does your rosetree have empty or tagged leafs? 
10:18:06 <zachk> Free>
10:18:07 <zachk> ?
10:18:15 <fen> rosetree does not allow empty leafs
10:18:40 <fen> the "Graph" which is providing getiSDefault requires that the dismantled brach can be encoded as a Monoid navigation
10:18:47 <fen> ie. (Int,Int)
10:19:03 <fen> thats because the braches are snapped off from the far left
10:19:18 <fen> and are just strait lines up to the branch point
10:19:50 <fen> but if there are empty leafs all over the place, then the dismantled segment needs to be this whole shape, and a path to navigate over it
10:20:19 <fen> while this is possible, its eaiser to work with free NonEmpty
10:20:42 <zachk> whats Free? Free Monad?
10:20:43 <fen> especially for ease of communication, because the Graph instance for Free [] is more complicated
10:20:58 <fen> Free f a = Pure a | Free (f (Free f a))
10:21:45 <fen> if f can be empty then there might not even be a pure value at the end of a branch
10:23:04 <fen> but the problem then becomes making a difference list for NonEmpty, as the "Pointer" over RoseTree is actually `Linear f => Zipper (Free (ZipperS f))'
10:23:09 <fen> not just Free f
10:23:43 <zachk> whats Linear there?
10:23:53 <fen> and the ZipperS (safe Zipper, for Linear (non-empty) containers) has a slow (Maybe (f a) -> f a) difference list
10:24:48 <fen> linear means it provides getS and setS
10:24:49 <fen> class (DifferenceS f,SetS f,GetS f) => Linear f
10:24:56 <fen> DifferenceS is a trivial superclass
10:25:27 <fen> https://bpaste.net/show/a7132418dbf5
10:25:30 <fen> see line 256
10:25:56 <fen>  setS :: (a,Maybe (f a)) -> f a
10:26:28 <fen> that means; setS (a,Nothing) :: Linear f -> f a
10:26:47 <fen> as a way to use NonEmpty, as an instance of Linear
10:28:48 <fen> line 182 has ZipperS
10:29:08 <fen> data ZipperS f a = ZipperS [Maybe (f a) -> f a] (Maybe (f a))
10:29:15 <fen> which is slow to rewind
10:29:29 <fen> but can have Nothing as the last value
10:29:56 <fen> backwardsS (ZipperS (f:fs) xs) = Just (ZipperS fs (Just (f xs)))
10:30:06 <fen> the Just (f xs) is SOLW!
10:33:17 <fen> a library exporting Stack,Linear,Structured and StructuredS should somehow also allow the user to write this kind of slow code, and then kind of provide a way to use the faster version shown in this benchmark;
10:33:35 <fen> https://bpaste.net/show/f8a0407ae39c
10:34:01 <fen> where the difference list is [f a -> f a], not [Maybe (f a) -> f a]
10:34:08 <fen> which is the whole cause of all this slowness
10:34:48 <fen> trying to design an API which can convert a slow representation into a fast one is the problem now
10:34:56 <zachk> do you know how the Maybe slows it down so much? I would think it would just be simple pattern matching 
10:36:11 <Solonarv> might be something to do with the extra layer of boxing/indirection/laziness
10:36:14 <Solonarv> if I had to guess
10:39:52 <cocreature> we didn’t get unboxed sums for no reason :)
10:40:03 <cocreature> https://hackage.haskell.org/package/unpacked-maybe-0.1.0.0/docs/Data-Maybe-Unpacked.html
10:40:24 <fen> hmm, this isnt even the correct benchmark, its when its folded up too. and it does not have the slow differences for comparison
10:41:04 <fen> cocreature: whats that?
10:41:41 <cocreature> a version of Maybe based on unboxed sums which can allow you to shave off an indirection
10:42:59 <jcowan> I need some help with terminology.  Given a monad M (or any typeclass T, really), there are four flavors of functions, with types A => B, M A => M B, M A => B, A = M B.
10:43:07 <fen> it will still be slower than the hack using undefined instead of nothing though?
10:43:16 <jcowan> The names pure function and monadic function seem sensible for the first two, but what of the second two?
10:43:58 <fen> ->?
10:44:03 <jcowan> I have thought of "monadic-domain fn" and "monadic-codomain fn", but they seem ugly, and "monad-{preserving, introducing, removing} seem verbose.
10:44:07 <fen> not =>
10:44:08 <hexagoxel> that makes me wonder: can you use that approach to arbitrary datatypes? replace any sum type by an unboxed sum, plus pattern synonyms?
10:44:15 <jcowan> Yes, sorry, a minor side effect of being a polyglot
10:44:54 <rotaerk> hmm is there some way to get ghcid to see my test suite?  I don't understand what it expects me to pass into the --test flag
10:45:09 <lyxia> jcowan: I don't know of any standard terminology for these four, but I think "A -> M B" is a better fit for "monadic function"
10:45:14 <rotaerk> I tried --test="main", and it didn't find the main of my test suite
10:45:26 <fen> hexagoxel: whats being attempted is a way to make patterns for all FIFO constructors
10:46:15 <zachk> I think M A => B might be like extract from Comonad
10:46:24 <fen> and the Maybes are messing things up
10:47:00 <zachk> and A => M B might be some form of (monadic) return/pure  composed with an A => B 
10:47:31 <fen> thats kilesli type
10:47:39 <fen> the other is cokliesli type
10:47:57 <rotaerk> hmm, oh, guess I need to do:  ghcid test-suite-name --test=main
10:48:13 <rotaerk> so I need two ghcids; one for my library, one for my test suite
10:48:37 <rotaerk> though, not sure how to make the test suite run if my *library's* code changes
10:48:51 <fen> :t (>=>)
10:48:52 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
10:49:02 <rotaerk> monadic composition
10:49:18 <fen> kliesli arrow
10:49:47 <fen> :t (=>=)
10:49:49 <lambdabot> error:
10:49:49 <lambdabot>     • Variable not in scope: =>=
10:49:49 <lambdabot>     • Perhaps you meant one of these:
10:49:54 <fen> % :t (=>=)
10:49:55 <yahb> fen: Comonad w => (w a -> b) -> (w b -> c) -> w a -> c
10:50:02 <fen> cokliesli arrow
10:50:12 <hexagoxel> rotaerk: you can use the approach i described at https://github.com/ndmitchell/ghcid/issues/204#issuecomment-425733891
10:50:40 <fen> they make categories
10:50:43 <fen> like (.)
10:50:51 <fen> :t (.)
10:50:53 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:51:17 <fen> (category needs composition and identiy)
10:51:23 <hexagoxel> hexagoxel: although, perhaps it is sufficient to specify an appropriate --restart for your usecase
10:51:30 <hexagoxel> (or --reload)
10:52:54 <fen> cocreature: could benchmark this unpacked-maybe approach...
10:53:14 <fen> is that the best advice for this API problem?
10:53:22 <hexagoxel> did i really address myself? i must be tired. i meant rotaerk ^
10:53:31 <monochrom> A -> M B is a Kleisli arrow if M is a monad.
10:53:54 <monochrom> M A -> B is probably more relevant for comonads.
10:54:29 <lavalike> cocreature: is unpacked sum different than a standard data type with unpacked fields? I can't find the relevant GHC docs
10:54:49 <monochrom> Unpacked fields means unpacked product.
10:55:11 <monochrom> Unpacked sum is very new.  Try very new GHC user's guide.
10:55:24 <lavalike> right, I meant a data type with >1 constructors whose fields are unpacked
10:56:30 <lavalike> UnboxedSums, there they are
10:56:45 <rotaerk> hexagoxel, thanks
10:58:32 <cocreature> lavalike: you can’t unpack a field that has a sumtype. but you can unpack a field that has an unboxed sumtype
10:59:08 <cocreature> lavalike: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unboxed-sums
11:01:33 <lavalike> «Any single-constructor data is eligible for unpacking», so you're saying *only* single constructor data
11:01:51 <cocreature> yep
11:02:09 <lavalike> I'm glad one can do both things one, I'll keep that in mind
11:02:22 <lavalike> one? now
11:05:34 <hexagoxel> for the container types table at the bottom of https://wiki.haskell.org/GHC/Memory_Footprint, what would be sizeof(T) for `Maybe a` ?
11:05:55 <hexagoxel> (the regular, non-unboxed-sum-Maybe)
11:06:31 <leshow> The example app for websockets uses an mvar for the server state, which is essentially just a list of WS.Connection. In a production application, if you still wanted to keep the list of connected users in memory, what might you use instead of mvar?
11:06:52 <lavalike> hexagoxel: 1 word + sizeof(a)
11:06:53 <leshow> As I understand it mvar is blocking, and each broadcast in the example app does a readMVar
11:07:53 <hexagoxel> lavalike: can that be right? if that was true, i don't see what improvement the unboxed-sum-Maybe could possibly have.
11:09:11 <cocreature> that seems to be missing the pointer
11:09:12 <lavalike> hexagoxel: I don't see how else it would be implemented
11:09:26 <cocreature> you hae 1 word for the tag, 1 word for the pointer in Just + sizeof(a)
11:09:27 <hexagoxel> for the unboxed-sum-Maybe, I'd have said the answer was 2 word + sizeof (a)
11:09:36 <monochrom> Nothing is one word.  Just x is two words.
11:09:48 <lavalike> I thought they put tags inside pointers
11:10:20 * hackage aws-easy 0.1.0.2 - Helper function and types for working with amazonka  http://hackage.haskell.org/package/aws-easy-0.1.0.2 (rcook)
11:10:44 <lavalike> one can figure it out via unsafeCoerce
11:10:44 <monochrom> Maybe is lifted and boxed and all that.  "Just x" needs one pointer to x always.  "Nothing" alone and "Just" alone is one pointer to an info table.
11:11:12 <monochrom> Pointer tagging does not replace space used up by constructors.
11:12:26 <monochrom> In the 1.2 table most of the "sizeof(...)" are wrong.
11:12:46 <monochrom> Err, nevermind.
11:13:05 <monochrom> They are "right" but I wouldn't include them.
11:14:41 <monochrom> Suppose I have "let x=[(),()] in (x,x)".  If you truly believed in "3+sizeof(va)+sizeof(vb)", it would be 3+7+7.  This is clearly stupid.
11:15:49 <rotaerk> hmm if I have ghcid run the test script, it over-scrolls, and the message at the top disappears
11:15:52 <lavalike> +2 for the () I guess (:
11:15:59 <rotaerk> test suite *
11:16:02 <monochrom> Therefore for a really logical and sane formula, you should only commit yourself to the skeleton of the container data structure, and declare "actual data not included".
11:16:28 <cocreature> hexagoxel: afaik, the unpacked Maybe type itself doesn’t have a direct benefit as it is also lifted but GHC’s optimizer can use the underlying unboxed sumtype (if strictness analysis kicks in). so let’s say you return Maybe Int. for the unpacked version that can be optimized to return (# Tag#, Any #) which doesn’t need to allocate
11:17:22 <monochrom> As it happens, in Ontario, Canada, shops give you price tags that don't include sales tax.  One factor is because tourists can actually be exempted from sales tax.
11:18:19 <aplainzetakind> My function :: Rand StdGen [DieValue] brings me numbers in chunks, and in order (like seven 6's, four 5's, eight 4's...). Is this supposed to be normal?
11:18:35 <monochrom> (Implementation detail: At the cashier tourists still pay sales tax first.  Then take your receipts to a place to get refund.)
11:18:48 <cocreature> hexagoxel: or if you have some other type data Foo = Foo !(Maybe Int), the unboxed version can be unpacked into the constructor while the standard Maybe can’t
11:19:02 <rotaerk> hexagoxel, can't get the same instance of ghcid to report errors in both my test suite and my library, *and* to run the test suite if everything passes
11:19:15 <monochrom> At any rate, if some people have to pay tax and some people don't, then including tax in a price tag would be wrong.  This is why 1.2's tables are wrong.
11:19:19 <lavalike> monochrom: is the info table you mentioned the same as the possibile implementation of type classes where functions such as succ :: Enum a => a -> a can be considered a function of two arguments succ :: Enum a -> a -> a where the first item is a lookup table, that given 'a' gives you the function for that particular 'a'?
11:19:27 <monochrom> No.
11:19:53 <monochrom> Every data constructor gets an info table.
11:20:06 <cocreature> also that’s not how typeclasses are implemented
11:20:18 <cocreature> you pass around a record containing the implementation of the instance, not a lookup table
11:20:25 <hexagoxel> cocreature: but that only works because Int can be unpacked, right?
11:20:34 <jcowan> cocreature: What's the difference?
11:20:54 <lavalike> jcowan: the other things in the table are the other class methods, not the other types'
11:21:05 <jcowan> Oh yes, I see.
11:21:17 <monochrom> https://github.com/takenobu-hs/haskell-ghc-illustrated is more comprehensive and trustworthy.
11:21:27 <rotaerk> hexagoxel, so I think I need to make a sh script to run ghcid for my test suite, and then launch two instances of it
11:21:45 <lavalike> monochrom: wonderful!
11:21:46 <cocreature> hexagoxel: no that doesn’t matter. whether you unpack Int into the Just constructor or not is an orthogonal question. if you define a polymorphic Maybe, you can’- unpack it into the constructor
11:22:31 <lavalike> it's using comic sans, so you know you can trust it
11:22:40 <hexagoxel> rotaerk: yeah, you might need two ghcid instances after all, if you want error reporting for both.
11:23:27 <leshow> lavalike: lol
11:23:29 <cocreature> rotaerk: you can usally write a .ghci file fairly easily that loads both your test suite and your library
11:23:35 <cocreature> in fact that’s what stack does
11:23:51 <monochrom> "Just (1,2) :: Maybe (Int,Int)" is basically very boxed and lifted.
11:24:21 <rotaerk> hmm I haven't tried anything with .ghci files; will look into that
11:24:27 <lavalike> I've always wondered how the internals looked from the ground up
11:24:32 <rotaerk> I'm using cabal new-repl, btw
11:24:51 <cocreature> rotaerk: often it’s as simple as ":set -isrc\n:set -itest\n:l test/Spec.hs"
11:24:58 <monochrom> Two ghcid instances!!!
11:25:12 <rotaerk> monochrom, what do you mean by that
11:25:33 <cocreature> yeah cabal new-repl insists on being pedantic and not allow you to load both the lib and the repl into the same instance since they could potentially have conflicting flags
11:25:34 <monochrom> It sounds like a lot, that's all.
11:25:45 <monochrom> Oh! OK.
11:26:10 <cocreature> in practice that rarely happens and it’s immensiely useful to load both into the same instance, so writing the stupid .ghci file yourself is well worth it imho
11:26:22 <lavalike> those slides make more sense read backwards
11:26:34 <monochrom> Can ghcid be hierarchical?  So that a parent ghcid drives two children ghcids?
11:26:54 <hexagoxel> i fear i don't understand yet what can be unpacked and what cannot. are there any good resources on this subject, other than the ghc user's guide and the trac wiki on heapobjects and footprint?
11:27:01 <monochrom> I mean this is now 3 instances but at least you just give one manual command not two.
11:27:35 <monochrom> https://github.com/takenobu-hs/haskell-ghc-illustrated
11:28:26 <hexagoxel> ah right, thanks
11:28:27 <cocreature> hexagoxel: afaik it’s as simple as any single constructor type + unboxed sums (which are compiled to unboxed tuples anyway)
11:28:48 <lavalike> monochrom: how did you find this?
11:28:49 <geekosaur> perhaps msot simply as "anything that doesn't require a constructor tag"
11:29:08 <monochrom> But do read the GHC user's guide on why there are "boxed vs unboxed" and then "lifted vs unlifted".  There is a simple technicality forcing them to be almost orthogonal.
11:29:17 <monochrom> haskell-cafe post a long time ago.
11:29:40 <lavalike> I'm seeing the matrix
11:29:46 <monochrom> One day takenobu posted on haskell-cafe "hey guys I made this, check it out"
11:29:57 <cocreature> hexagoxel: https://github.com/ghc/ghc/blob/master/compiler/simplStg/UnariseStg.hs#L74 might also be worth a read
11:30:58 <rotaerk> cocreature, is the idea that cabal new-repl would use .ghci, or I would just use ghci, which works basically as good as cabal new-repl as long as the .ghci is in place?
11:31:09 <cocreature> rotaerk: the latter
11:31:14 <rotaerk> k
11:31:56 <cocreature> rotaerk: that’s one of the very few cases where the .ghc.environment.* files that cabal spits out can actually be somewhat convenient
11:32:11 <cocreature> as it means that just running ghci will still pick up deps
11:32:18 <rotaerk> I see
11:32:36 <rotaerk> those don't exist in the path in which I run ghci anyway
11:32:50 <cocreature> they should exist once you run "cabal new-build"
11:33:10 <cocreature> and unless your deps are available globally (which will be the case with nix) you want them to exist here
11:33:20 <rotaerk> my folder structure is like this (though the code is out of date on github):  https://github.com/rotaerk/ktx-rw
11:33:29 <rotaerk> project level folder, then package level folder within
11:33:45 <rotaerk> I have been putting the .ghcid in the packag level folder, and that's where I have been running cabal new-repl
11:33:45 <cocreature> ah it should be sufficient if it’s in a parent folder
11:33:50 <rotaerk> k
11:34:16 <hexagoxel> cocreature: thanks
11:37:04 <rotaerk> cocreature, thanks; this works much better... having that .ghci file in place, and putting *just* --test="Test.main" into my .ghcid
11:37:15 <rotaerk> don't need to override the command or screw with --restarts/--reloads
11:37:27 <lavalike> what a herculean effort must have been putting this document together
11:41:02 <hexagoxel> on p30 of takenobu-hs/haskell-ghc-illustrated, why is there an empty second field in the payload?
11:41:22 --- mode: glguy set +v fen
11:41:52 <hexagoxel> copy-paste oversight?
11:42:08 <fen> is unboxing really the best way to handle Maybe?
11:43:35 <fen> rather than benchmarking another example, which admittedly, if it made it as fast as not using maybe, shouldnt the conversion to code that does not use maybe be focused on? 
11:44:22 <fen> :t foldl' (.) id
11:44:24 <lambdabot> Foldable t => t (c -> c) -> c -> c
11:45:15 <johnw> :t appEndo . foldMap Endo
11:45:16 <lambdabot> Foldable t => t (a -> a) -> a -> a
11:45:28 --- mode: glguy set +v lelo
11:45:46 <fen> :t foldl' (\ f g -> (f . Just . g)) Just
11:45:48 <lambdabot> Foldable t => t (Maybe a -> a) -> Maybe a -> Maybe (Maybe a)
11:45:59 <cocreature> johnw: I don’t think that’s the same. foldMap is a foldr for lists
11:46:17 <johnw> associativity doesn't matter for composition though
11:46:18 * hackage microspec 0.2.1.0 - Tiny QuickCheck test library with minimal dependencies  http://hackage.haskell.org/package/microspec-0.2.1.0 (TomMurphy)
11:46:46 <johnw> and it's for any Foldable
11:47:05 <fen> :t Endo
11:47:07 <lambdabot> (a -> a) -> Endo a
11:47:16 <johnw> :t foldl' (.) id . map (fmap Just)
11:47:17 <lambdabot> [Maybe a -> a] -> Maybe a -> Maybe a
11:47:28 <geekosaur> yeh, looks liek copy-pasto from the list example following
11:48:29 <fen> oh Reader
11:48:54 <fen> still slow
11:49:48 <fen>  differenceS  :: SafeState (f a) (Maybe (f a) -> f a)
11:49:57 <fresheyeball> hey out there
11:50:03 <fresheyeball> http://hackage.haskell.org/package/aeson
11:50:07 <fen> type StateSafe  s a = s -> Maybe (a, s)
11:50:12 <fresheyeball> this page says cffi is disabled for security
11:50:18 <fresheyeball> anyone know what the risk is?
11:50:59 <johnw> fen: if only the machines library had partial mealy machines...
11:51:04 <fen> oops
11:51:05 <fen> type SafeState  s a = s ->       (a,Maybe s)
11:51:17 <fen> what is this mealy machines?
11:51:28 <hexagoxel> geekosaur: but the -ddump-opt-cmm -ddump-asm output does indeed contain three .quads for the (Just 42 :: Maybe Int) closure
11:51:38 <fen> https://en.wikipedia.org/wiki/Mealy_machine
11:51:49 <johnw> newtype PartialMealy s a b = PartialMealy (s -> a -> Maybe (b, PartialMealy s a b)
11:51:59 <johnw> )
11:52:37 --- mode: glguy set +v newb
11:52:37 <johnw> State is a restricted mealy machine, in that the behavior of the "machine" never changes
11:53:05 <johnw> anyway, probably off-topic
11:53:34 <fen> ah
11:53:35 <fen> nice
11:54:09 <newb> Hey, I am very new to Haskell and I implemented 2 power functions and i want to test them if they give the same results. 
11:54:27 <fen> :t (==)
11:54:28 <lambdabot> Eq a => a -> a -> Bool
11:54:44 <johnw> newb: QuickCheck is a good way to write such tests
11:54:50 <newb> I am using quick check and created this function 
11:54:51 <hexagoxel> https://gist.github.com/lspitzner/e9d40ab1a109ea85045744742e81dfbb
11:54:53 <johnw> prop_pow x = pow1 x == pow2 x
11:54:55 <newb> prop_powers :: Integer -> Integer -> Bool   prop_powers a b = power == power1 
11:55:02 <hexagoxel> that ".quad 3" is strange
11:55:03 <newb> basically to compare the results of the two power functions
11:55:06 <johnw> there you go
11:55:29 <newb> I get this error tho
11:55:33 <newb>     * No instance for (Eq (Integer -> Integer -> Integer))         arising from a use of `=='         (maybe you haven't applied a function to enough arguments?)
11:55:44 <johnw> you need to pass a and b
11:55:48 <johnw> power a b == power1 a b
11:55:59 --- mode: glguy set +v eric8
11:56:04 <eric8> rather than to their resulting values
11:56:36 <geekosaur> odd
11:56:40 <eric8> Maybe try: `(power a b) == (power1 a b)`
11:56:45 <eric8> :i ==
11:56:48 <newb> thanks that just hit me and i tried it, but then can i just load the file and use prop_powers or /
11:57:09 <johnw> in ghci, run: quickCheck prop_powers
11:57:17 <eric8> Oof, load your file to the gist site: https://gist.github.com/
11:57:24 <fen> thinking that the hackage repo will just have to give the slow implementation for now
11:57:48 <newb> thanks a lot, it works now! 
11:57:49 <eric8> I'd follow @johnw's solution
11:57:50 <fen> and when any kind of headway is made on being able to make it faster it will have to be a revision
11:57:57 <eric8> ++johnw
11:58:43 <johnw> note that for throwaway tests, you could say: quickCheck $ \a b -> power a b == power1 a b
11:58:46 * hackage microspec 0.2.1.1 - Tiny QuickCheck test library with minimal dependencies  http://hackage.haskell.org/package/microspec-0.2.1.1 (TomMurphy)
11:58:46 <newb> is there a way to restrict the test on positive values only?
11:58:53 <johnw> yes, add an if
11:59:05 <newb> awesome thanks! 
11:59:09 <hexagoxel> monochrom: regarding your "tax" comparison: does specifying an upper bound not still make sense? even if sharing etc. can reduce things? (well, presuming that it was properly labelled as an upper bound, which it is not)
11:59:10 <fen> still such a shame that using this newer code will make some old simulations slower, just for the sake of using the library
11:59:12 <johnw> quickCheck $ \a b -> a <0 || b < 0 || power a b == power1 a b
11:59:42 <Tuplanolla> It would be a better idea to use types to guide the generators, johnw.
11:59:42 <fen> but a standardised approach to overloading FIFO constructors is the aim
11:59:50 <Tuplanolla> There's `Positive` for this.
11:59:51 <johnw> Tuplanolla: true
11:59:55 <hexagoxel> (or is upper bound also not correct?)
12:00:02 <fresheyeball> I just want to enable cffi for aeson in hpack
12:00:09 <fresheyeball> totally not finding any docs
12:00:14 <fen> and the library achieves that only by "safely" handling nonempty with slow Maybes
12:00:18 <fresheyeball> if anyone wants to help
12:00:59 <fen>  get :: f a -> Maybe (a,f a)
12:01:05 <fen>  getS :: f a -> (a,Maybe (f a))
12:03:20 <cocreature> fresheyeball: you can’t specify flags for deps in cabal files (and thereby also not in package.yaml files)
12:03:29 <cocreature> fresheyeball: you need to specify the flags directly via cabal/stack
12:03:43 <fresheyeball> cocreature: what do you mean?
12:03:53 <fresheyeball> how can I do this with cabal?
12:04:16 * hackage microspec 0.2.1.2 - Tiny QuickCheck test library with minimal dependencies  http://hackage.haskell.org/package/microspec-0.2.1.2 (TomMurphy)
12:04:42 <cocreature> fresheyeball: https://cabal.readthedocs.io/en/latest/nix-local-build.html#cfg-field-flags is one option
12:05:15 <fresheyeball> cocreature: doesn't that show how to do it with a cabal file?
12:05:48 <cocreature> no it shows how you can configure flags in cabal.project not in your .cabal file
12:05:59 <fresheyeball> oic
12:06:04 <fresheyeball> I am not using a cabal.project file
12:06:59 <fresheyeball> cocreature: if I set `cffi = true`
12:07:06 <fresheyeball> will it doe that for the entire project?
12:07:11 <fresheyeball> Can I set that for only aeson?
12:10:40 <fresheyeball> cocreature: I see, I need to set this in nix
12:10:59 --- mode: glguy set +v starfish18
12:11:06 <starfish18> need help
12:11:10 <fresheyeball> do you know if this is a configureFlag or a buildFlag
12:11:16 * hackage microspec 0.2.1.3 - Tiny QuickCheck test library with minimal dependencies  http://hackage.haskell.org/package/microspec-0.2.1.3 (TomMurphy)
12:11:17 <fresheyeball> starfish18: this is the right place
12:15:40 <cocreature> fresheyeball: configureFlag
12:15:49 <cocreature> and yeah if you get your deps via nix, then you have to set it there
12:17:16 <cocreature> fresheyeball: there is an enableCabalFlag helper in haskell.lib
12:21:48 * hackage midair 0.2.0.1 - Hot-swappable FRP  http://hackage.haskell.org/package/midair-0.2.0.1 (TomMurphy)
12:24:35 <fresheyeball> cocreature: I will try that
12:25:14 <zachk> and the docs seem broken for midair, on the hackage website at least :( 
12:27:04 <cocreature> zachk: the hackage builder takes some time if it succeeds at all
12:27:06 <fresheyeball> cocreature: do you know any example usages?
12:27:11 <fresheyeball> it's very unclear to me
12:27:58 <cocreature> fresheyeball: something like haskellPackages.override { overrides = self: super: { aeson = haskell.lib.enableCabalFlag "cffi" super.aeson; }; }
12:28:12 <fresheyeball> oic
12:28:53 <cocreature> zachk: if you click on an older version (e.g. 0.2.0.0 which is probably quite close) you’ll get docs
12:29:06 * cocreature resists the urge to rant about the hackage builder
12:29:38 <fresheyeball> cocreature: "cffi" must be a set
12:30:08 <zachk> cocreature, oh thank you :) 
12:30:58 <cocreature> fresheyeball: oh I swapped the arguments
12:31:04 <cocreature> enableCabalFlag super.aeson "cffi"
12:42:16 * hackage vivid-osc 0.5.0.0 - Open Sound Control encode/decode  http://hackage.haskell.org/package/vivid-osc-0.5.0.0 (TomMurphy)
12:45:53 <Amras> I've got a subprocess which periodically spits out a line of code. I want haskell to read this line of code and print it back out
12:46:29 <Amras> withCreateProcess(proc "./mysubprocess" []) {std_out = CreatePipe} $ \_ (Just so) _ _ -> hGetLine so >>= \l -> putStrLn l
12:47:17 <Amras> there seems to be a buffer of some sort on the pipe, since putStrLn only starts printing after I've fed over 500 lines into it
12:47:27 <lavalike> check out hSetBuffering
12:47:45 <hpc> sounds like block buffering, yeah
12:47:56 <lavalike> (the buffering could be on the print side too, not on so)
12:49:05 <Amras> the other side is just python's print(), so probably not
12:49:32 <geekosaur> still possibleunles sou told python to unbuffer
12:50:10 <geekosaur> stdbuf migth be of interest (dont' know offhand if python dos its own buffering or uses stdio though)
12:50:31 <Amras> hSetBuffering solved it
12:50:54 <Amras> no, scratch that, it didn't
12:50:57 <Amras> yeah, I'll look at python
12:54:08 <Amras> yup, python's stdout wasn't being flushed
12:54:13 <Amras> thanks
12:54:14 <lavalike> rude!
12:57:16 * hackage vivid-supercollider 0.4.1.0 - Implementation of SuperCollider server specifications  http://hackage.haskell.org/package/vivid-supercollider-0.4.1.0 (TomMurphy)
13:04:31 <fresheyeball> cocreature: that worked! thanks!
13:04:36 <fresheyeball> cocreature++
13:06:33 <nitrix> Hello. I'm using EBNF to document a file format. It seems pretty limited because it doesn't cover the width of integers. I can add my special definitions, but then terminal terms like 'a' or "a" cannot be properly mapped to a width either.
13:06:39 <nitrix> Are there solutions?
13:07:12 <nitrix> I currently have   'a' = uint8_t ; uint8_t = ? 8-bit number ? ;
13:07:18 <nitrix> Which I'm sure isn't valid :P
13:07:33 <lavalike> bit bit bit bit bit bit bit bit :P
13:13:22 <fr33domlover> Hello! Is there some existing type for something that can be either one item or a list/vector of such items? e.g. data T a = One a | Many [a] or something like this (where it's important there's a distinction between [a] and a)
13:13:54 <fr33domlover> I have a need for such a type, I thought I'd write a module for it, but maybe something like this already exists? Idk how to look for such a thing
13:16:06 <lavalike> Either a [a]
13:18:05 <fr33domlover> lavalike, yeah that works but typeclass instances for Either operate on Right and treat Left as sort of an error type, which isn't the behavior I want: e.g. I'd like fmap to apply to both left and right
13:18:36 <fr33domlover> So making such a type with foldable, functor, traversable instances etc. is useful to me
13:18:49 <fr33domlover> Unless there's a trick to make that work with Either?
13:19:16 <lavalike> ah I see, one degree of freedom too much
13:19:17 <nitrix> fr33domlover: You want Bifunctor.
13:19:25 <geekosaur> tbh this sounds misfactored to me; is a single item really different from a list of length 1?
13:19:50 * hackage vivid 0.4.2.0 - Sound synthesis with SuperCollider  http://hackage.haskell.org/package/vivid-0.4.2.0 (TomMurphy)
13:20:32 <nitrix> > bimap (+42) (*69) (Left 1)
13:20:36 <lambdabot>  Left 43
13:20:37 <nitrix> > bimap (+42) (*69) (Right 1)
13:20:39 <lambdabot>  Right 69
13:20:41 <nitrix> fr33domlover: ^
13:21:00 <fr33domlover> geekosaur, my use case is JSON, where 1 and [1] can mean different things in some cases, not sure if it's significant in my code but I want to model it properly so that it's always distinct whenever it matters
13:21:16 <nitrix> I guess I could've used better integers for that example, but you get the idea.
13:21:17 <fr33domlover> (Specifically, when working with JSON-LD)
13:22:12 <lavalike> :t join bimap
13:22:14 <lambdabot> Bifunctor p => (c -> d) -> p c c -> p d d
13:23:03 <fr33domlover> join bimap (+1) (Left 1)
13:23:08 <fr33domlover> > join bimap (+1) (Left 1)
13:23:10 <lambdabot>  Left 2
13:23:19 <fr33domlover> > join bimap (+1) (Right [1,2,3])
13:23:21 <cocreature> I would just define a new type
13:23:21 <lambdabot>  error:
13:23:22 <lambdabot>      • No instance for (Num [Integer]) arising from a use of ‘e_11123’
13:23:22 <lambdabot>      • In the expression: e_11123
13:23:44 <nitrix> fr33domlover: [] introduces an additional Functor.
13:23:45 <fr33domlover> Hmmm this doesn't work, need to tweak
13:23:46 * hackage vivid-supercollider 0.4.1.1 - Implementation of SuperCollider server specifications  http://hackage.haskell.org/package/vivid-supercollider-0.4.1.1 (TomMurphy)
13:24:36 <fr33domlover> bimap (+1) (+1) (Left 1)
13:24:41 <fr33domlover> > bimap (+1) (+1) (Left 1)
13:24:44 <lambdabot>  Left 2
13:24:52 <fr33domlover> > bimap (+1) (+1) (Right [1,2,3])
13:24:55 <lambdabot>  error:
13:24:55 <lambdabot>      • No instance for (Num [Integer]) arising from a use of ‘e_111123’
13:24:55 <lambdabot>      • In the expression: e_111123
13:25:02 <nitrix> > bimap (+1) (+1) (Right 1)
13:25:04 <lambdabot>  Right 2
13:25:08 <fr33domlover> It still needs a wrapper
13:25:22 <nitrix> fr33domlover: Bimap applies the transformation of the left if it's Left, and the one on the right if it's Right, that's all.
13:25:47 <geekosaur> it's not going to automaically apply map for you
13:26:04 <fr33domlover> nitrix, yeah I mean I still need to define f g = bimap g (fmap g)
13:26:13 <fr33domlover> nitrix, and same for traverse and fold etc.
13:26:18 <Tuplanolla> @let instance Bifunctor f => Functor (Join f) where fmap f = Join . join bimap f . getJoin
13:26:19 <nitrix> > bimap (+1) (fmap (+1)) (Right [1,2,3])
13:26:20 <lambdabot>  Defined.
13:26:21 <lambdabot>  Right [2,3,4]
13:26:24 <fr33domlover> have to define such functions for them
13:26:52 <fr33domlover> I'm asking whether it already exists or I'll write my own module so that I can just fmap and traverse freely :)
13:27:22 <nitrix> fr33domlover: You just said the magic word. Traversable does this :)
13:28:11 <fr33domlover> nitrix, only if I define an instance, or make a wrapper for the function that gets applied :P either way need to write some code
13:28:31 <Tuplanolla> > getJoin (fmap (+ 1) (Join (Left 42)))
13:28:33 <lambdabot>  Left 43
13:28:55 <nitrix> Yes, using Haskell requires writing code :)
13:29:43 <hpc> as nice as it would be if all we had to write was data types...
13:30:34 <Tuplanolla> You can refine that further with lenses.
13:31:40 <lavalike> I think that for data Foo a = Foo1 [a] | FooMany [a] ghc can derive all the things you need, and you could make sure to enforce the limit on Foo1 by construction
13:35:12 <lavalike> now that I think about it why wouldn't that work for Foo1 a | FooMany [a]
13:35:26 --- mode: glguy set +v huxpro
13:35:42 <Solonarv> GHC can auto-derive Functor/Foldable/Traversable, so really there's no reason not to just make your own type
13:35:50 <lavalike> I'm optimist the deriving mechanics can handle that one too
13:35:51 * hackage vivid 0.4.2.1 - Sound synthesis with SuperCollider  http://hackage.haskell.org/package/vivid-0.4.2.1 (TomMurphy)
13:36:18 <Solonarv> indeed they can:
13:36:45 <Solonarv> % data Foo a = Foo1 a | FooN [a] deriving (Show, Functor, Foldable, Traversable)
13:36:45 <yahb> Solonarv: 
13:36:52 <lavalike> bingo!
13:37:03 <fr33domlover> Yeah I want to make my own type, I was just asking whether such a type already exists so that I'd reuse it, that's all :)
13:37:23 <cocreature> at least not in any reasonably popular package
13:38:51 <fr33domlover> Hoogle search didn't find anything relevant, I guess I'll make my own. The JSON-LD spec is horrible, it's very hard to see whether there's any case where I'll need the distinction, I prefer to have it for now, and can always remove later if it ends up not being useful/needed
13:39:01 <Solonarv> well, techincally you could use `Identity :+: []', which are all in base ;)
13:39:39 * fr33domlover doesn't know what :+: is
13:40:04 * fr33domlover guesses it's a type constructor
13:40:39 <fr33domlover> https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Generics.html#t::-43-:
13:40:47 <fr33domlover> This? ^_^
13:40:52 <Solonarv> yup, that's the one
13:41:48 <fr33domlover> @kind Identity :+: []
13:41:50 <lambdabot> error:
13:41:50 <lambdabot>     • Expecting one more argument to ‘Identity’
13:41:50 <lambdabot>       Expected a type, but ‘Identity’ has kind ‘* -> *’
13:42:13 <fr33domlover> @kind (Identity :+: [])
13:42:15 <lambdabot> error:
13:42:15 <lambdabot>     • Expecting one more argument to ‘Identity’
13:42:15 <lambdabot>       Expected a type, but ‘Identity’ has kind ‘* -> *’
13:42:32 <Solonarv> % :k (:+:)
13:42:32 <yahb> Solonarv: ; <interactive>:1:1: error:; Not in scope: type constructor or class `:+:'; Perhaps you meant `:~:' (imported from Data.Data)
13:42:41 <Solonarv> @kind (:+:)
13:42:42 <lambdabot> * -> * -> *
13:42:50 <Solonarv> huh
13:43:08 <Solonarv> not sure where that's imported from
13:50:46 <nitrix> Is this modified EBNF readable? https://ideone.com/6tcBmO
13:52:10 <Tuplanolla> My advice would be to just use ANTLR, nitrix.
13:52:22 <Tuplanolla> It's not only unambiguous, but also machine-checked.
13:53:13 <aplainzetakind> I've started doing the NICTA course. How can I run, with stack, only the tests on some specific package? I'm not sure what kind of target to give `stack test`.
13:56:05 <aplainzetakind> ^s/package/module
13:58:15 <lyxia> stack test name-of-the-package?  stack test path/to/the/package?
13:58:53 <nitrix> Tuplanolla: Okay I'll check, thanks for the feedback.
14:01:18 <aplainzetakind> lyxia: Something like that probably, but I can't get it to work.
14:02:52 --- mode: glguy set +v dunder
14:04:47 * hackage vivid 0.4.2.2 - Sound synthesis with SuperCollider  http://hackage.haskell.org/package/vivid-0.4.2.2 (TomMurphy)
14:06:29 --- mode: glguy set -v dunder
14:13:00 <lavalike> Solonarv: it isn't, it was imported by someone with @let before
14:17:27 --- mode: glguy set +v fen
14:18:10 <fen> here is a shortened version of the paste, it removes the consideration of shaped containers and graphs as a default way to derive get
14:18:11 <fen> https://bpaste.net/show/4f4ee728b10e
14:18:16 <fen> it has a benchmark
14:19:14 <fen> it shows how slow these Maybes are
14:19:19 <fen> to be compared with;
14:19:20 <fen> https://bpaste.net/show/d6d6d3adf516
14:19:41 <fen> which shows how fast difference lists are when not using Maybe
14:21:22 <fen> the comparison with list is not perfect as it has inlining but at least shows how fast it could be
14:21:31 <fen> (in the first paste)
14:23:16 * hackage vivid 0.4.2.3 - Sound synthesis with SuperCollider  http://hackage.haskell.org/package/vivid-0.4.2.3 (TomMurphy)
14:28:35 <fen> sorry, that first version had some unnecessary functions
14:28:40 <fen> here is a reduced version
14:28:41 <fen> https://bpaste.net/show/f35054360c5c
14:31:17 <fresheyeball> http://hackage.haskell.org/package/http-client-0.5.13.1/docs/Network-HTTP-Client.html#t:RequestBody
14:31:33 <fresheyeball> anyone know the rational behind this unshowable type?
14:32:33 <fresheyeball> http://hackage.haskell.org/package/http-client-0.5.13.1/docs/Network-HTTP-Client.html#t:Popper
14:39:52 <lyxia> streaming?
14:43:24 <mpickering> Does anyone know a package which uses an hs-boot file which isn't ghc?
14:52:39 <fen> here is the version with the "fast" traverse https://bpaste.net/show/fe732c1e95f4
14:53:26 <fen> by eliminating the get/set its almost twice as fast
14:53:32 <fen> thats because of the Maybe
14:53:53 <fen> either;
14:54:15 <fen> get :: f a -> Maybe (a,f a), set :: Maybe (a,f a) -> f a
14:54:17 <fen> or;
14:54:46 <fen> getS :: f a -> (a,Maybe (f a)), setS :: (a,Maybe (f a)) -> f a
14:55:56 <fen> actually, it still uses one Maybe on the unfolding of the difference list
14:56:28 <fen> so only eliminating one of the two gives a speed up from 200ms to 130ms
14:57:45 <hexagoxel> mpickering: brittany uses hs-boot
14:58:20 * hackage postgres-websockets 0.5.0.1 - Middleware to map LISTEN/NOTIFY messages to Websockets  http://hackage.haskell.org/package/postgres-websockets-0.5.0.1 (diogob)
15:04:06 <fen> is this something Unboxed Maybe could help with?
15:05:51 <strigo_dn> hey, all. i'm taking a numerical analysis class this winter. any tips for using haskell in this context?
15:06:17 <hpc> strigo_dn: you'll probably spend more time fighting with math than the computer
15:06:29 <hpc> the class may also force you to use R or matlab
15:06:54 <strigo_dn> asked the prof. said we can use whatever lang we want
15:07:05 <hpc> ah nice, wish mine was like that
15:07:11 <strigo_dn> it's a blessing!
15:07:12 <hpc> had to learn x forwarding just so i could use octave from home
15:07:41 <strigo_dn> during my linear algebra class I had to access matlab over ssh. lots of fun.
15:10:59 <strigo_dn> has anyone here used the matrix package? any thoughts?
15:13:59 <fen> use matlab, haskell is useless for linear algebra
15:20:36 --- mode: glguy set +v Bish_
15:20:59 <Bish_> what is this problem called: giving a set of numbers, getting combinations that sum up to a certain value?
15:22:35 <hpc> https://en.wikipedia.org/wiki/Subset_sum_problem
15:23:05 <Bish_> uhm, is that with taking a number doubled?
15:25:44 <hpc> with taking a number doubled?
15:26:42 <Bish_> well subsetSum 3 = [...,[1,1,1,],...]
15:28:12 <fen> does more than one copy of a number in the set?
15:28:59 <Bish_> no, my set is integers
15:29:10 <Bish_> [1..]
15:29:28 <fen> where do all those replicated values appear from then?
15:29:58 <fen> anyway, its just some subset of the powerset no?
15:32:10 <fen> anyway, how is traversing a [] 100 times faster than when its written for a custom definition of list!?
15:37:20 <lavalike> Bish_: http://www.algorithmist.com/index.php/Coin_Change
15:38:16 * hackage supervisors 0.1.0.0 - Monitor groups of threads with non-hierarchical lifetimes.  http://hackage.haskell.org/package/supervisors-0.1.0.0 (isd)
15:42:38 <fen> oh it might have been to do with fmapDefault... hmm wait
15:43:23 <fen> ok its just twice as fast
15:43:24 <fen> https://bpaste.net/show/287c7e8b8a8a
15:44:25 <fen> oops, wrong benchmarks
15:44:29 <fen> try this one
15:44:29 <fen> https://bpaste.net/show/d105cd2d1ec4
15:44:43 <fen> how can it get as fast as preludes list?
15:46:27 <fen> omg! sorry... this one; https://bpaste.net/show/1ee3272d0b3b
15:48:53 <Solonarv> is there a reason you're doing 'method = methodDefault' instead of letting GHC derive the instances for you?
15:49:26 <Solonarv> try using Derive{Functor,Foldable,Traversable} instead and see if that's better
15:49:37 <fen> the issue is with why this default is slow
15:49:42 <fen> thats the question
15:50:09 <fen> its a restricted example of a larger case (unshaped containers, GHC wouldnt be able to derive the shaped version)
15:50:15 <Solonarv> is there still a difference if you compile with -O0 ?
15:51:49 <Solonarv> if no: might be rewrite rules fusing stuff together
15:52:52 <koz_> I had a similar situation - no matter how I wrote tree folds for lists, the default foldMap still beat me, even on asymptotically hard cases.
15:53:24 <Solonarv> *jazz hands* fuuuuuusion
15:53:49 <fen> koz_ its using mapAccumR so that traverse is used explicitly
15:54:12 <fen> Solonarv: compiling with optimisation flags now
15:56:42 <koz_> Solonarv: I figured as much. Guess if I worked at it and figured out how to use fusion I might be able to get a treefold up to the same speed, but that's _way_ out of my depth.
15:57:07 <fen> its just a flag
15:57:32 <Solonarv> making operations on *your* data structure fuse is not just a flag
15:57:50 <fen> Solonarv: for "shaped" containers, a class Traversi of a previous paste is used to give a comonad default
15:58:05 <Solonarv> you also need to create correct rewrite rules and figure out primitives that lend themselves well to fusion
15:58:13 <fen> huh?
15:58:27 <lavalike> yes, library implementations of functions come with such rewrite rules
15:58:33 <Solonarv> fen: the data structure stuff you're doing is way over my head tbh, it just sounds like Generalized Abstract Nonsense to me
15:58:47 <fen> damn, with optimisations list is 4X faster... 
15:59:21 <fen> https://bpaste.net/show/47951d3cb86a
15:59:44 <fen> Solonarv: this example is a very stripped back version
16:00:11 <fen> was just trying to answer why GHC deriving the instances isnt an option
16:00:29 <Solonarv> fair enough
16:01:05 <Solonarv> anyway, there's not much more I can do without running tests myself, and my laptop sucks enough that I'm not willing to do that
16:01:15 <Solonarv> all I can do is recite generalities
16:01:39 <fen> at some point these mysterious fusions should be delved 
16:02:19 <fen> oooh! foldr instead of foldl' and they are almost as fast
16:03:10 <Solonarv> the most basic is just stuff like '{-# RULE "map/map" forall f g. map f . map g = map (f . g) #-}', and INLINE pragmas to make sure those rules can actually fire
16:03:50 <fen> hmm, the test example was designed to avoid such things
16:04:03 <fen> there are probably no shortcuts it can take with mapAccumR
16:04:30 <Solonarv> you're probably right; I was just explaining that fusion isn't *that* mysterious
16:05:28 <fen> hmm, upon lowering the varience its still almost twice as slow; https://bpaste.net/show/1eb9f195bb65
16:05:47 <fen> so whats causing this slowness if its not fusion?
16:06:57 <Solonarv> tbh, I have no idea
16:08:18 <fen> the only thing that seems slow is that its checking each time to see if its at the end
16:08:40 <fen> line 59-50
16:08:47 <fen> 49*
16:10:35 <fen> seems like this "difference default" for traverse is doomed
16:10:57 <fen> which is really quite frustrating, seeing as how the whole library is built around it 
16:11:15 <Solonarv> the sheer size of it does make it suspicious from a performance PoV, yes
16:11:29 <fen> it needs at least one Maybe to unfold the differences
16:12:12 <fen> right. whats all this unboxed maybe about
16:12:42 <fen> read the docs, looks confusing
16:13:38 <Solonarv> TL;DR Maybe but with (sometimes?) better performance characteristics
16:13:51 <c_wraith> secret null pointers
16:14:51 <c_wraith> that's what rust does, anyway - its option type is often implemented as null pointers
16:19:25 <fen> ok, just refactoring it, then maybe can try with this unboxed approach
16:20:50 <fen> https://bpaste.net/show/ce64dcf6ccf7
16:23:21 <fen> https://hackage.haskell.org/package/unpacked-maybe-0.1.0.0/docs/Data-Maybe-Unpacked.html
16:23:32 <fen> does that need import Prelude hiding Maybe?
16:25:54 <fen> it sure does!
16:26:36 <fen> argh its slower!
16:27:18 <fen> https://bpaste.net/show/d3759b71e384
16:30:36 <fen> this sucks
16:32:50 <fen> research conclusion; unified all traversals, found default comonad for shaped containers. was slow. 
16:35:37 <Zemyla> lambdabot doesn't let you do @more more than once; it fails with Prelude.init: empty list afterwards, even if it says there are [x @more lines].
16:58:09 --- mode: glguy set +v Tchof
17:00:16 * hackage gloss-export 0.1.0.1 - Export Gloss pictures to png, bmp, tga, tiff, gif and juicy-pixels-image  http://hackage.haskell.org/package/gloss-export-0.1.0.1 (timoa)
17:06:17 --- mode: glguy set +v fen
17:06:32 <fen> ok, so, some of the slowness was from unfolding (using Maybe) and then refolding
17:06:41 <fen> removing this makes it as fast as list!
17:11:17 <fen> almost..
17:12:20 <fen> oh, its the varience, yes, its basically as fast!
17:13:16 <fen> https://bpaste.net/show/3343790bcfae
17:15:08 <fen> so basically, pattern matching on the differences as they are produced is the way to go, rather than unfolding them which needs a Maybe to finish unfolding at the end of the list
17:15:28 <fen> not that that is an option for Zippers...
17:15:38 <fen> but at least the traverse is fast now
17:15:40 <fen> yay!
17:16:01 <fen> this should probably work to matching on last for "Linear" containers
17:16:45 <fen> not sure how it will be with the "shaped" containers, might have to benchmark against Trees traverse instance...
17:17:18 <fen> but really, for the Pointers (zippers over nested zippers), there is nothing comparable to benchmark agains
18:10:06 --- mode: glguy set +v boxscapeR
18:11:21 --- mode: glguy set -v boxscapeR
18:24:29 <Zemyla> How is the default for a type family associated with a typeclass done again?
18:30:25 <lyxia> type Fam a :: * ; type Fam a = DefFam a
19:50:34 --- mode: glguy set +v t[m]
19:56:48 <leifmetcalf> What's the `realm` in `data BasicAuth (realm :: Symbol) (userData :: *)`?
19:57:00 <leifmetcalf> In Servant.API.BasicAuth
20:03:34 <c_wraith> leifmetcalf, 99% chance it's the "realm" field that's specified as part of http basic auth
20:04:47 <leifmetcalf> Oh, it's a server-side thing. I guess I can leave it empty then. I feel a bit silly now. Thank you!
20:07:35 <t[m]> Anyone use emacs on gentoo for haskell? I have problem jumping to definition on dante mode. E.g. myLayout = tiled ||| Mirror tiled ||| FullI am able to goto defintion of myLayout, but I can not jump to the definition of Mirror and Full. Guess I have to install the xmonad source code? Which is the prefered way to do that? The xmonad binary on my systeme was installed by emerge x11-wm/xmonad.
21:37:28 <oldandwise> need some tip code review (styling) in my short solution here --> http://termbin.com/63bs
21:41:27 <MarcelineVQ> @let isExists e ((a,_):xs) | e == a = True | null xs = e == a | otherwise = isExists e xs
21:41:29 <lambdabot>  Defined.
21:41:35 <MarcelineVQ> > isExists 1 []
21:41:37 <lambdabot>  *Exception: /tmp/mueval15057-0.hs:(159,1)-(162,29): Non-exhaustive patterns ...
21:42:08 <oldandwise> yea, k.. hmm.. i protected that condition from the caller part..
21:42:54 <MarcelineVQ> That's fair but it's good practice to be safe in the first place, so you don't have to remember to protect it if you us it again.
21:43:41 <oldandwise> thanks MarcelineVQ 
21:45:27 * oldandwise fees like i'm no longer at the sewerage of the ivory tower. But in the basement now
21:54:11 <MarcelineVQ> If you're willing to use things like foldl you could try writing isExists with foldr, and incElem with map.
21:56:09 <Lears> > let inFirst a = any $ (== a) . fst; l = [(0, 1), (2, 3)] in (inFirst 2 l, inFirst 3 l)
21:56:11 <lambdabot>  (True,False)
22:11:42 <oldandwise> Lears: thanks
22:13:18 <Zemyla> Is there a way to have a witness that two types are provably not equal?
22:17:07 <koz_> Zemyla: I'd check https://hackage.haskell.org/package/decidable
22:25:53 <nshepperd> you can write it with (a :~: b) -> Void
22:27:13 <nshepperd> i don't know any good way to make ghc prove that types are unequal though
22:32:01 <nshepperd> oh, i guess a type family with patterns Foo a a and Foo a b
22:45:51 <tnks> I uploaded a package candidate, but the docs didn't generate (which I believe is a known issue).  But I'm not sure how to upload the docs manually for candidates.  Any tips?
22:50:13 <cocreature> tnks: cabal upload -d should do the job
22:59:08 --- mode: glguy set +v luisholanda
23:03:58 <Zemyla> nshepperd: No, if you have constructors for Foo a a and Foo a b, then the latter constructor just means that you can't prove a and b are equal with the information given.
23:04:21 <nshepperd> not constructors. a type family
23:05:16 <nshepperd> type family Equal a b :: Bool where { Equal a a = True; Equal a b = False }
23:05:23 <Zemyla> Retty sure it still means "Equality isn't provable". A constructive proof of inequality is, like you said first, (a :~: b) -> Void.
23:06:50 <nshepperd> aiui, if you use 'Equal a b' in any code with particular a and b, the type family is considered stuck until the type checker knows the concrete outer type constructors of a and b
23:08:31 <Zemyla> Though sadly, in Hask, you can't get refinement of inequalities: a /= c -> forall b. Either (a /= b) (a /= c).
23:10:13 <nshepperd> eg. "example :: (Equal a b ~ False) => a -> b -> a; example x y = x"
23:10:44 <nshepperd> 'example [2] Nothing' yields [2]
23:11:13 <nshepperd> 'example [1] [2]' yields "Could not deduce: Equal [a] [a0] ~ 'False"
23:14:58 <nshepperd> so I guess writing 'unrefl :: (Equal a b ~ False) => (a :~: b) -> Void; unrefl Refl = error "unreachable"' should work just fine
23:20:32 <nshepperd> going the other way, '((a :~: b) -> Void) -> Dict (Equal a b ~ False)' seems like it'll require unsafeCoercing a Dict, which I'll leave as an exercise to the reader to figure out if it's safe
