00:13:29 <teto> I did "touch ./settings" but now I get ./platformConstants: openFile: does not exist (No such file or directory) wtf
00:23:02 --- mode: glguy set +v akfp
00:23:12 <akfp> what is a good parser framework for parsing sequences that are not strings?
00:39:25 <c_wraith> akfp: depending on your other goals, the answer might be anything but attoparsec
00:40:20 <c_wraith> like, what quality of error reporting do you need?
00:40:34 <c_wraith> How important is performance?
00:43:13 <c_wraith> I've been playing around with Earley recently, because I hate factoring out left-recursion.  It is quite capable of handling non-characters as the primitive type.  But it's not the fastest by any means, nor does it have the best error reporting.
00:44:33 <c_wraith> If parsing speed matters or reporting parse errors to non-technical people is important, it's probably not the right choice.
00:50:36 <koz_> akfp: Also, what do you mean by 'sequences that are not strings'?
00:52:06 <dminuoso> Im looking for a fast pretty printer I can use to neatly format log output. Should I just pick `pretty`?
00:54:08 <merijn> dminuoso: If you log a lot, I'd say you should go for non-pretty output structured for machines. And if you don't log a lot, why does it have be especially fast?
00:54:32 <merijn> aka "just use prettyprinter" ;)
00:55:27 <dminuoso> Can people quit making good and sensible arguments? :(
00:56:06 <dminuoso> merijn: I guess the argument regarding speed is a really good one.
00:56:42 <koz_> merijn: When I install GHC binary builds, is there a way I can tell it to _not_ use LLVM7 when I pass -fllvm to the resulting ghc binary?
00:56:55 <koz_> It seems to default to LLVM7, even though I have an LLVM6 available.
00:57:35 <merijn> koz_: There's a config file, set by the configure script when you use the bindist. I forget exactly where it is, though try asking in #ghc
00:57:44 <merijn> (that also controls which linker, etc.)
00:58:16 <koz_> merijn: But it is possible. OK, good; I was starting to think I'd have to build from source.
01:00:21 <merijn> koz_: I'm guessing that it is possible, because there doesn't seem an obvious reason why it can't be runtime configuration and all other things (C compilers, linkers, etc.) are controlled that way
01:01:15 <koz_> It's not the end of the world if I have to build from source to do this, but for obvious reasons, I would prefer not to.
01:12:20 <trcc> anyone using haskell-mode in emacs here? I am having issues with errors displaying in the source that are not happening when building. I do not know where these come from
01:17:23 <[exa]> Hm guys, is there some kind of Gloss for 3D?
01:17:59 <[exa]> trcc: do you have a specific sample of the error? I guess it would be compiler flags related
01:18:49 <trcc> [exa]: "could not find module "Data.Aeson" Perhaps you meant Data.Version (from base ...) try -v to see list of files included"
01:18:58 <trcc> it just cannot figure out where to configure it
01:20:53 <[exa]> trcc: perhaps it's using another package database? I've no experience with haskell-mode but there should be a config that e.g. allows you to specify the sandbox to play with, or something
01:23:11 <Taneb> [exa]: have you seen not-gloss?
01:23:25 <trcc> [exa]: hmm no idea.. 
01:25:39 <[exa]> Taneb: not yet
01:26:07 <[exa]> Taneb: ok that's probably it, thanks a lot
01:26:15 <[exa]> (they couldn't have invented a better name tho)
01:26:42 <[exa]> trcc: do you have a sandbox for the software?
01:26:48 <[exa]> (or maybe it's stack-based?)
01:27:00 <trcc> No sandbox, but I am using the cabal new-*
01:27:48 <merijn> trcc: That sounds like aeson is missing from your build-depends?
01:28:01 <trcc> merijn: it works when I do cabal new-build in terminal
01:28:25 <trcc> and from emacs with haskell compile. The error messages showing in the hs file is just originating from somewhere else
01:28:28 <trcc> and I cannot figure out where
01:29:28 <[exa]> trcc: can you make it fail the same way from the commandline? like, not using new-* ?
01:29:36 <trcc> hehe currently not
01:29:40 <trcc> am trying
01:30:04 <[exa]> but I'm just guessing, I'm really not into IDEs :]
01:32:17 <hpd[m]1> trcc: have you set haskell-process-type to cabal-new-repl?
01:32:23 <trcc> hpd[m]1: ye
01:33:11 <akfp> koz_: for example megaparsec abstracts a sequence into a Stream in the types, but then cheats and requires all streams to be convertible into String.  It's a type-show!
01:33:29 <trcc> hpd[m]1: https://github.com/CThuleHansen/doom.d/blob/master/config.el
01:33:37 <akfp> koz_: I want to parse a [a]
01:34:12 <akfp> c_wraith: early might be perfect if it works.  I don't need fast nor good error messages.
01:34:41 <koz_> akfp: What's the input you're taking look like?
01:35:27 <koz_> Or are you saying your input _is_ a list of some type a?
01:35:45 <akfp> it's the output of a tokenizer
01:36:00 <akfp> it is a [Token]
01:36:02 <hpd[m]1> trcc: that looks ok to me. Do the errors come from haskell-mode when you do `C-c C-l` or similar, or from flycheck?
01:36:21 <trcc> hpd[m]1: flycheck I think. It works when I do C-c C-l
01:37:10 <hpd[m]1> trcc: also, if your cabal-file has multiple targets, you might have to do `haskell-session-change-target`  if the file is not part of the default target
01:37:44 <trcc> it does not
01:37:46 <hpd[m]1> trcc: flycheck is configured seperately
01:38:02 <trcc> Ok. Thanks! I will try to see if I can find it then
01:38:50 <trcc> hpd[m]1: though I think it might come from interactive-haskell
01:38:57 <__monty__> akfp: Where do you see this String requirement for megaparsec?
01:41:35 <hpd[m]1> trcc: try disabling flycheck. I don't use flycheck currently. I'd like to, but couldn't get it to work reliably
01:47:45 <trcc> hpd[m]1: ah think it is because flycheck detects that I have stack installed and try to use it. Now I just need to find some way of disabling that..
01:52:31 <bahamas> hello. is there any tool that I can use to generate Haskell code programmatically? I actually want to generate PureScript, but there doesn't seem to exist anything for it. so I hope to at least find inspiration in Haskell land
01:53:26 <merijn> Generate from what?
01:56:31 <bahamas> merijn: from an AST or anything else I can build programmatically
01:56:52 <merijn> I mean, the most obvious answer would be Template Haskell
01:57:12 <merijn> More generally, sounds like you're describing a compiler that compiles to Haskell to me ;)
01:58:24 <bahamas> merijn: indeed. fortunately, I only need a small subset. I'm converting some Python to PureScript and this code consists of functions that are quite similar in structure
01:58:55 <bahamas> merijn: that's why I'm hoping to translate the Python AST to an equivalent PureScript representation and then to generate the code.
02:00:16 <akfp> __monty__ in the Stream class and the associated helper functions required to implement the instance.
02:00:51 <__monty__> akfp: Why is it cheating though? It's probably just for display in error messages or something.
02:01:10 <akfp> no, see http://hackage.haskell.org/package/megaparsec-7.0.1/docs/Text-Megaparsec-Stream.html#t:Stream reachOffset for example
02:02:24 <akfp> I could use megaparsec 6.x with some hand-waving, but 7.x seems to be more tightly tied to String
02:02:51 <jle`> bahamas: isn't purescript written in haskell?  i think the purescript library has an AST type that you can directly manipulate and pretty-print, within haskell
02:06:07 <bahamas> jle`: it is written in Haskell and it does have an AST. I don't know what to print it with. maybe this? https://github.com/purescript/purescript/blob/master/src/Language/PureScript/Pretty/Common.hs
02:18:54 <koz_> Hi jle`!
02:19:00 <koz_> How was your trip?
02:22:51 --- mode: glguy set +v PatrickRobotham
02:39:50 <__monty__> akfp: Still looks like a representation used for the sake of error reporting.
03:04:48 <dminuoso> Cabal new-build is telling me something that cannot be true: app/Main.hs:58:55: error: Module ‘Network.RADIUS.Types’ does not export ‘VSA(..)’
03:04:55 <dminuoso> How would I go about debugging the cause here?
03:07:06 <phadej> cabal new-repl
03:07:43 <phadej> :browse Network.RADIUS.Types
03:08:52 <dminuoso> phadej: Oh perfect! Found my mistake, thanks. :)
03:09:10 <phadej> good
03:19:48 <lastmanstanding> I'm new to haskell. I recollect reading somewhere that haskell can parallelize code by switching to a different compiler/compiler flag?
03:20:55 <lastmanstanding> so if I was to write a program that is embarassingly parallel (say to see if a number is even), then could it be paralleized without changing the program?
03:22:03 <opqdonut> no
03:22:20 <opqdonut> you need to add "hints" for parallelization
03:22:36 <opqdonut> this can eiter be done with the `par` and `pseq` primitives, or by using higher-level constructs like parMap
03:23:11 <opqdonut> see also, https://stackoverflow.com/questions/15005670/why-is-there-no-implicit-parallelism-in-haskell
03:26:25 <lastmanstanding> opqdonut: thank you. as far as I can tell this just requires me to mark parts of my code as 'can be parallelized'. I don't have to fiddle with the actual computation I'm trying to do right?
03:26:37 <dminuoso> lastmanstanding: Right.
03:26:56 <lastmanstanding> awesome. off I am to get me a haskell then :D
03:26:59 <dminuoso> lastmanstanding: There's an excellent book by Simon Marlow "Parallel and Concurrent Programming in Haskell" you should read.
03:27:11 <dminuoso> lastmanstanding: I think there's a free pdf if you dig in archive.org
03:29:18 <lastmanstanding> will wallow when work wanes
03:29:20 <Axman6> lastmanstanding: definitely read that book
03:31:06 <Axman6> It's available online for free at https://web.archive.org/web/20171031113757/http://chimera.labs.oreilly.com:80/books/1230000000929/index.html (it's no longer available at that oreilly address, but it wasn;t intentially taken down afaiui)
03:32:27 <Axman6> lastmanstanding: In theory all Haskell functions can be evaluated in parallel safely, but there is usally a lot of overhead from taking such a naive approach
03:34:31 <PacoV> Hi!
03:35:35 * hackage ekg-prometheus-adapter 0.1.0.4 - Easily expose your EKG metrics to Prometheus  http://hackage.haskell.org/package/ekg-prometheus-adapter-0.1.0.4 (AlfredoDiNapoli)
03:35:53 <dminuoso> Axman6: The way we can do parallelism in GHC with Control.Concurrent was a further great revelation why non-strict semantics are great.
03:36:34 <PacoV> I'm trying to install https://hackage.haskell.org/package/abnf-0.4.1.0 using stack install abnf and it seems that I've the wrong resolver or something like this.
03:37:04 <PacoV> stack solver does not solve anything and I don't get what to put in the stack.yaml file.
03:37:30 <PacoV> Do you have any hint on what to do here?
03:39:29 <trcc> hpd[m]1: https://gist.github.com/CThuleHansen/81f8f5910ac48f3f0a99746d717b31d9
03:39:32 <trcc> got it working..
03:39:58 <trcc> A bit embarrassed of all the time I spent.. All beginnings are tough :)
03:40:24 <lyxia> PacoV: what's the output of stack install abnf
03:40:50 <lyxia> wait im silly I have stack right here
03:41:03 * hackage rncryptor 0.3.0.1 - Haskell implementation of the RNCryptor file format  http://hackage.haskell.org/package/rncryptor-0.3.0.1 (AlfredoDiNapoli)
03:41:46 <PacoV> lyxia: http://ix.io/1uOo
03:43:10 <PacoV> PS: I need to parse string agains a given grammar but there might be better/simpler packages than anbf. I'd love to know about them if anyone tried them.
03:44:14 <lyxia> PacoV: This error says that base-4.9 is the latest version of base abnf is compatible with
03:44:46 <lyxia> but your stack configuration is pointing to a newer base version
03:45:03 * hackage type-level-sets 0.8.9.0 - Type-level sets and finite maps (with value-level counterparts)  http://hackage.haskell.org/package/type-level-sets-0.8.9.0 (DominicOrchard)
03:45:45 <lyxia> base-4.9 is tied to GHC 8.0, so you need a resolver with that version of GHC. Looking at the list of latest LTS https://www.stackage.org/ lts-9.21 is the latest for GHC 8.0
03:46:15 <lyxia> PacoV: so go to your stack.yaml, and change it to say "resolver: lts-9.21"
03:46:44 <PacoV> Ho, ok.
03:47:08 <PacoV> But, should'nt stack solver be able to fix that?
03:47:21 <lyxia> I have never gotten stack solver to do anything useful
03:47:28 <PacoV> Ahaha
03:51:31 <PacoV> I don't understand how you went from base-4.9 to lts-9.21 using stackage.org.
04:01:49 <PacoV> lyxia: I don't understand how you went from base-4.9 to lts-9.21 using stackage.org.
04:03:22 <cocreature> PacoV: you can use https://ghc.haskell.org/trac/ghc/wiki/Commentary/Libraries/VersionHistory to figure out which version of ghc base 4.9 corresponds to and then you can look at "Latest LTS per GHC version" on stackage.org
04:05:48 <PacoV> cocreature: Thanks, now I get it!
04:05:58 <PacoV> But still...
04:06:08 <PacoV> Should'nt stack solver be able to fix that?
04:07:02 <merijn> Fix how?
04:07:08 <cocreature> my experience with "stack solver" matches lyxia’s experience. I never managed to get it to do anything useful
04:09:19 <PacoV> merijn: should'nt it be able to look at taht https://ghc.haskell.org/trac/ghc/wiki/Commentary/Libraries/VersionHistory array and return the correct resolver?
04:09:38 <merijn> Define "correct resolver"?
04:09:48 <merijn> What is that lookup based on?
04:09:58 <PacoV> One of the resolver that satisfies every dependency need.
04:10:10 <PacoV> Yeah, I forgot the dependencies part.
04:10:14 <merijn> At that point your basically inventing a dependency solver
04:10:16 <hpd[m]1> trcc: nice! But that won't read your cabal file, so it might not work in the presence of default-extensions and the like.
04:10:33 <merijn> Stack's entire design goal is pretty explicitly not to do dynamic dependency solving
04:10:45 <merijn> You're supposed to pick a solver (aka curated package set) and code against that
04:10:54 <PacoV> I thought "solver" in stack solver was basically it.
04:11:34 <merijn> If you want it to dynamically try and figure out which dependencies fit together given constraint, you're pretty much describing cabal-install
04:11:55 <PacoV> Which is use by stack solver under the hood.
04:12:03 <merijn> No, Cabal is used by stack
04:12:09 <merijn> cabal-install is separate
04:12:30 <cocreature> pretty sure, that "stack solver" shells out to cabal install
04:12:33 <PacoV> stack "asked"me to install cabal-install in order to use stack solver.
04:12:43 <merijn> oh, I don't know about stack solver, tbh
04:13:00 <cocreature> it uses cabal-install for dependency solving and then tries to reconstruct a stack.yaml file with the same deps
04:13:19 <cocreature> in practice, it mostly fails to do that :)
04:13:20 <merijn> Anyway, at that point aren't you getting the "worst of both worlds"?
04:13:48 <PacoV> Might be, I've no experience in those worlds.
04:14:18 <cocreature> merijn: it’s not that different from "cabal new-freeze"
04:14:43 <cocreature> (assuming it worked)
04:16:48 <PacoV> Anyway, it seems to be working now.
04:17:02 <PacoV> Thanks all, now it's time to learn how to parse.
04:19:18 <trcc> hpd[m]1: might be. Works for now
04:22:09 <hvr> the irony of Stack being so much more beginner-friendly isn't lost on me ;-)
04:30:19 <lyxia> But it is much more friendly in that he didn't have to learn how to manage multiple versions of GHC.
04:30:48 <merijn> lyxia: What's there to manage?
04:31:48 <warbo> anyone know how make a lens/prism from "[\"a\",\"b\"]" to [Text] using lens-aeson?
04:32:31 <warbo> I can get [Value], but don't know how to convert the elements without 'to' (which seems to be a Getter rather than a Lens, i.e. is one-way)
04:33:42 <warbo> I tried '"[\"a\",\"b\"]" ^. _Array . traverse . _String' but that concatenates the strings into "ab"
04:34:35 <lyxia> merijn: well, once the right resolver is selected stack just installs GHC for you, what's the equivalent of that with cabal
04:35:05 <merijn> You install GHC and call it a day
04:39:17 <lyxia> he surely wouldn't have figured to do that whether using cabal or stack
04:40:46 <lyxia> There are situations where cabal works better for beginners than stack, this is not one of them, I'm only objecting to hvr's unjustified bashing in this case.
04:41:01 <__monty__> Installing ghc isn't any harder than installing stack ime.
04:41:58 <__monty__> Once you need to work on several projects with incompatible GHC version requirements then stack managing GHC may be relevant. I don't know many beginners who have that need though.
04:44:11 --- mode: glguy set +v rann_
04:44:35 <confusedwanderer> upgrading haskell platform is not as easy as with stack
04:44:39 <lyxia> the present discussion was prompted by a beginner wanting to use a package that depends on GHC 8.0 when they had some other version installed.
04:47:09 <__monty__> lyxia: It was only a problem because stack managed GHC for them. Otherwise they could've just installed the right GHC?
04:48:03 <dmwit> I work on many projects for work with incompatible GHC requirements. It is easy-breezy with cabal. Just configure or new-configure with -w and never think about it again.
04:48:18 <dmwit> I don't see that this is significantly more difficult than choosing a resolver.
04:48:20 <merijn> dmwit: Or just switch the first dir in your path...
04:48:25 <lyxia> it's not
04:48:51 <dmwit> merijn: Yes, but then you must do this every time you switch projects. With -w you do it once per project, not once per context switch. It's a big difference in usability in my experience.
04:49:21 <merijn> I don't switch that often :p
04:49:23 <lyxia> but if you're a beginner and you get told only that you there is some problem that you don't understand with the version of base, no existing tool tells you that the problem is GHC in the first place
04:49:41 <dmwit> lyxia: Yes, that is the real problem, I agree.
04:50:53 <lyxia> I'm not saying stack works particularly better than other solutions, but it's definitely not worse.
04:51:46 <lyxia> well, not worse for those who already know their tools
04:52:28 <lyxia> I did say "it is much more friendly", in the context of this particular problem with this particular beginner
05:28:52 <ventonegro> Ah, this again
05:29:12 <ventonegro> In 95% of cases a newcomer to Haskell will be happier with Stack
05:30:01 <ventonegro> +/- 2%
05:30:44 <merijn> I too, can make up statistics with no justification 99.786% of the time
05:31:08 <ventonegro> Ok, make it +/- 2.3%
05:31:36 <dminuoso> ventonegro: Is this just based on some gut feelings?
05:31:52 <dminuoso> I found stack to be too much magic and frustrating when I learned Haskell.
05:31:59 <merijn> I appreciate that some people like stack, and everyone should just use whatever the hell they want.
05:32:14 <ventonegro> dminuoso: Yes :)
05:32:16 <merijn> But I don't appreciate people confidently spreading some sort of community consensus that does not exist
05:33:18 <ventonegro> merijn: I didn't mention any community consensus... Where did you see that?
05:34:01 <merijn> Realistically, I think stack vs cabal-install is approximately 50-50 with a skew towards cabal for long term Haskellers and a skew to stack for beginners. But I feel most of this can be attributed to the stack half aggressively pushing the story that "stack is easier for beginners" everywhere
05:34:26 <merijn> ventonegro: "stack is easier for 95% of beginners" implies there's some sort of consensus that this is the case
05:34:39 <ventonegro> merijn: No, it doesn't
05:34:43 <merijn> ventonegro: While in reality it is "*you* think stack is easier for 95%"
05:34:45 <dminuoso> Or that someone took the liberty to gather enough cases to come up with that number.
05:34:56 <ventonegro> Jeez, learn how to build a proper strawman
05:35:14 <merijn> ventonegro: If you had said "I think stack is better for 95% of beginners" than I'd be fine agreeing to disagree
05:35:56 <merijn> But throwing these statistics around with no qualification implies some sort of consensus or community endorsement that that's actually true
05:36:01 <ventonegro> The fact that I gave it a 95% is a dead giveaway that it was not serious
05:36:18 <ventonegro> So I don't honestly understand what is the problem here
05:36:27 <merijn> ventonegro: I don't think that's as obvious to beginners as you think it is
05:37:03 <Solonarv> IMO the main "issue" with cabal for newcomers is being unaware that you should be using cabal v2-* commands, and thereby running into cabal hell
05:38:20 <merijn> Solonarv: actual "cabal hell" hasn't existed for almost a decade now, and I am kinda annoyed the term entere mainstream usage as meaning "I configured/want incompatible dependencies and it doesn't work"
05:39:16 <Solonarv> My understanding is that it will still happen if you blithely 'cabal install' stuff
05:39:31 <merijn> Sure, better dependency resolution and conflict reporting are needed
05:39:49 <Solonarv> Yes, it doesn't happen if you use sandboxes or the newstyle builds, but you have to know that you should be using those
05:40:29 <merijn> Solonarv: No, that's not what cabal hell meant (I will concede everyone has now started using it for something else entirely, but I think that unfairly blames cabal)
05:41:07 <Solonarv> Ah, fair enough. I thought it simply meant "messing up your package DB".
05:41:09 <merijn> Solonarv: If you willy-nilly cabal install things you will get into situations where it can't find a build/dependency plan, yes. But that's not wrong behaviour, just inconvenient
05:41:39 <merijn> Solonarv: Well, it means messing up your package DB, but it doesn't actually do that anymore. It's just that old-style builds default to trying to use what's in your DB and then get stuck
05:42:19 <merijn> Old-style cabal hell used to be "cabal silently upgraded a transitive dependency and now 70% of my installed libraries are silently corrupted and unusable and there's no possible way to fix things"
05:42:28 <Solonarv> oooh that's bad
05:43:00 <Solonarv> True. Doesn't affect my main point, though: newcomers might not know that it's a bad idea to just 'cabal install' things, and then mess up their package DB and be unable to build/install things.
05:43:19 <merijn> Solonarv: Nowadays it simply refuses to do that upgrade, meaning it can get "stuck" without a dependency solution. new-style builds allows more success due to every dependency being kept completely independent
05:43:38 <Solonarv> Note that if I were in the business of writing haskell education resources, I would still recommend cabal, and simply instruct readers to use the new-style builds
05:43:48 <merijn> Solonarv: Oh, sure, I hope we switch to new-build as default soon, but I think there's still some polishing to do
05:44:14 <Solonarv> It's my understanding that the switch is planned for 3.0, no idea what the timeline on that is though
05:45:16 <cocreature> iirc it does at least warn starting from 2.4 if you use the old commands
05:45:25 <confusedwanderer> is there some way to specify "new-" commands as the default?
05:45:44 <Solonarv> You could use a wrapper script, I suppose
05:46:13 <Solonarv> or use the 'v2-' prefix instead of 'new-' if you want to be forwards compatible
05:46:31 <confusedwanderer> i see
05:52:23 <the_2nd> assume I have type GetSet = Get | Set a, and I'd like to write a DSL for it, so GetSet becomes a proper Monad interpreted with an IO function. How do I e.g. define get a get function that will later hold the correct value? Any links to such constructs?
05:52:36 <mpickering> Is there a data type, data A f a = A (f a) defined anywhere in base?
05:54:07 <the_2nd> such that within the Monad I can call x <- get and set y
05:55:23 <Solonarv> @hackage free -- the_2nd
05:55:23 <lambdabot> http://hackage.haskell.org/package/free -- the_2nd
05:55:30 <lavalike> the_2nd: you need data GetSet a = Get | Set a for starters, so that GetSet :: * -> * has the proper kind for Functor, Monad, and so forth, then you write an instance for it
05:55:39 <lyxia> mpickering: sounds like IdentityT (but it's not in base)
05:56:03 <lyxia> there's WrappedMonad
05:56:07 <Solonarv> mpickering: a variety of wrappers (Alt, Ap, WrappedMonad) have that kind
05:57:01 <Solonarv> the_2nd: you might want your data type to look more like 'data GetSet a = Get (Blah -> a) | Set a'
05:57:01 <Solonarv> where 'Blah' is whatever type 'get' is supposed to return
05:57:22 <lyxia> type Identity = IdentityT Identity
05:57:44 * Solonarv o . O ( recursive type synonyms )
05:58:25 <the_2nd> lavalike, how would   get :: GetSet a   then look like?
05:59:06 <lavalike> the_2nd: I just realized you need Get to be a tad different yeah :)
05:59:10 <Solonarv> Using my example, 'get' would have a type more like 'Free GetSet Blah'
05:59:35 <Solonarv> Your original type 'data GetSet a = Get | Set a' is actually just Maybe with different names
06:01:48 <the_2nd> Solonarv, and my "a" is basically nothing/anything, just there to make the impls work?
06:02:02 <PacoV> Hey, back from lunch and I saw some of what you guys told about stack/cabal.
06:02:17 <Solonarv> No, 'a' is the return type of the entire monadic operation
06:02:25 <PacoV> As a beginner, I don't even know what cabal is.
06:02:57 <PacoV> I understanc the concept of snapshot here.
06:03:05 <Solonarv> actually, if you want something to plug into 'Free' you'd write:
06:03:05 <Solonarv> 'data GetSet s a = Get (s -> a) | Set s a'
06:03:05 <the_2nd> okay and in case I want to interpret it writing and reading a single value from a specific file, a would be () ? Since I only want the side effects
06:03:23 <PacoV> But I don't understand why can't a tool handles it for me.
06:03:30 <merijn> PacoV: Cabal is a spec for describing dependencies and build configurations for libraries/executables
06:03:36 <Solonarv> 's' is the thing you're getting/setting, 'a' is the return type of the entire operation
06:03:58 <merijn> PacoV: cabal-install (aka the commandline executable cabal) is a tool for actually chasing down dependencies, building/installing them and building your own package/code
06:04:21 <the_2nd> e.g. I want to interpet it as an int written to foo.txt . Then 'a' is '()' and 's' is Int?
06:04:37 <warbo> PacoV: (roughly) stack is a layer above cabal, cabal is a layer over ghc-pkg, ghc-pkg is a layer over 'ghc --make'
06:04:39 <Solonarv> if 's' is always the same thing, you could also do 'data Files a = ReadFile (FileContents -> a) | WriteFile FileContents a'
06:04:43 <merijn> PacoV: There's also stack, which has the same goal as cabal-install, but a different approach
06:05:20 <warbo> personally I use cabal, and I use Nix to get the right version of GHC
06:05:34 <merijn> PacoV: With stack you pick a resolver (a curated, fixed set of packages+versions) and build agains that. cabal-install on the other hand gets a list of dependencies from Hackage and tries to find a compatible build-plan for your dependencies then build that
06:05:44 <warbo> (I've sunk many many hours into trying to get Stack to compile, with no success)
06:05:52 <PacoV> So, using cabal I can get my code up and running and thanks to cabal-install, I'll have the correct Haskell version given a set of libraries?
06:05:59 <merijn> warbo: If you're not using Nix for anything else you can probably also get by with using the bindists of GHC
06:06:20 <warbo> merijn: I use Nix for basically everything ;)
06:06:30 <merijn> warbo: Right, then carry on :p
06:06:52 <Solonarv> Cabal is the fomat you use to describe which dependencies you're using; cabal-install is a tool which makes sure those dependencies are available
06:06:59 <PacoV> So, stack brings some "stability" and cabal some flexibility here?
06:07:08 <dminuoso> merijn: heh you were the one frequently talking about how much the Monoid instance Monoid b => Monoid (a -> b) is underused right?
06:07:08 <Solonarv> That's about right
06:07:11 <PacoV> (cabal-install, sorry(
06:07:35 <dminuoso> merijn: For the past 30 minutes I've been chasing an abstraction I couldn't grasp until I realized - it was the simplest of them all. Monoid on functions. :)
06:07:47 <merijn> PacoV: Roughly. Although you cabal-install also has (new-)freeze, which computes a list of *ALL* your dependencies and their exact version (on your machine) and stores that
06:07:48 <Solonarv> note that cabal-install /also/ has the ability to freeze dependency versions, so they can both give you reproducible builds
06:08:03 <merijn> dminuoso: Best Monoid ever :)
06:08:15 <dminuoso> merijn: Yeah. :)
06:08:21 <Solonarv> merijn: Ap would like a word with you ;)
06:08:28 <PacoV> Ok, I'll dig into cabal in the coming days, first, parse those abnf lines.
06:08:46 <PacoV> If you guys have any website/example, I'd be thankfull.
06:08:57 <PacoV> I only see the package's tests.
06:09:10 <Solonarv> I'd suggest looking at the cabal docs :V
06:09:37 <Solonarv> https://cabal.readthedocs.io/en/latest/ -- link
06:09:54 <PacoV> Solonarv: thanks!
06:13:17 <the_2nd> thanks everyone
06:19:40 <Solonarv> there's also other libraries similar to 'free', for example 'freer'. If you were using that, you might have a GetSet type more like:
06:19:40 <Solonarv> data GetSet a where
06:19:41 <Solonarv>     Get :: GetSet Int
06:19:41 <Solonarv>     Set :: Int -> GetSet ()
06:34:03 * hackage pretty-show-ansi-wl 1.9.2 - Like pretty-show, but only for ansi-wl-pprint  http://hackage.haskell.org/package/pretty-show-ansi-wl-1.9.2 (LiamOConnorDavis)
06:39:33 * hackage shake 0.17.2 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.17.2 (NeilMitchell)
07:22:50 <bahamas> I'm trying to build language-python and I get these errors: https://bpaste.net/show/8d6a98960305 I assume the only solution is to try to build with an older version of ghc, right?
07:23:58 <merijn> bahamas: Or patch the package
07:23:59 <geekosaur> explicitly: import Prelude hiding ((<>))
07:24:12 <merijn> bahamas: Looks like breakage due to Semigroup change, which should be fairly simple to fix
07:24:19 <bahamas> merijn: how do I patch it?
07:24:26 <merijn> bahamas: Submit a PR/patch and be the change you want to be in the world! \o/
07:24:37 <geekosaur> no, this looks like when <> went into the Prelude as alias for mappend
07:25:10 <Solonarv> didn't that happen around the same time as the Semigroup change?
07:25:16 <geekosaur> no
07:25:33 <merijn> bahamas: The hackage page has a link to the repo, then it's a matter of updating the usages of <> in the package
07:27:33 <bahamas> merijn: looks like it's already been fixed https://github.com/bjpop/language-python/blob/98958701b6825e90bb4dbea9372dcee1eab92f2a/src/Language/Python/Common/SrcLocation.hs#L38. I guess there hasn't been a release then
07:27:38 <geekosaur> Semgroup does obscure when ti happened, but all Semigroup stuff was ghc8 whereas originally <> was like ghc7.8
07:29:35 <Solonarv> bahamas: in that case, you should be able to point your build tool at the github repo and have the fixed version
07:30:16 <Solonarv> are you using cabal, stack, or something else?
07:30:35 <bahamas> Solonarv: stack
07:31:16 <Solonarv> in that case, add the repo to stack.yaml
07:31:32 <Solonarv> I don't remember the exact syntax, just look at the stack docs
07:32:36 <bahamas> Solonarv: yeah. I cloned it for now, but I guess it's better to have stack install it directly from github
07:32:52 <Solonarv> yeah, that seems less messy.
07:36:39 <bahamas> thanks for the help! I feel excited about using haskell for this project
07:37:08 <shapr> yay!
07:37:34 <Solonarv> \o/
07:41:24 <bahamas> I opened an issue on the repo anyway, because the latest release was in 2016
07:47:33 * hackage yesod-markdown 0.12.6.0 - Tools for using markdown in a yesod application  http://hackage.haskell.org/package/yesod-markdown-0.12.6.0 (PatrickBrisbin)
08:02:50 <celphi> Why would Bool be part of the typeclass Enum? This tutorial I'm reading says typeclass Enum are: members are sequentially ordered types & have defined successors and predecesors, which you can get with the succ and pred functions. But how is that possible with True/False? succ False is an error.
08:03:08 <bahamas> is there any technical reason not to have pre-compiled libraries? to avoid all the initial waiting time of compiling a project you just created
08:03:19 <merijn> > succ False
08:03:21 <lambdabot>  True
08:03:35 <merijn> celphi: Why wouldn't it be an instance?
08:03:46 <celphi> Try it with True
08:03:55 <celphi> succ True
08:04:01 <c_wraith> bahamas: only the increase in distribution artifact size.
08:04:03 * hackage symbols 0.1.0.0 - Symbol manipulation  http://hackage.haskell.org/package/symbols-0.1.0.0 (kcsongor)
08:04:04 <merijn> celphi: The Enum typeclass's design is...not great, yes
08:04:09 <merijn> > succ maxBound :: Int
08:04:12 <lambdabot>  *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
08:04:32 <c_wraith> bahamas: nix has a binary artifact cache of haskell libraries when compiled in common configurations, for instance
08:04:40 <merijn> celphi: That same problem applies to any Enum instance that's finite
08:04:48 <celphi> *Main> succ True
08:04:48 <celphi> *** Exception: Prelude.Enum.Bool.succ: bad argument
08:05:16 <merijn> > maxBound :: Int
08:05:18 <lambdabot>  9223372036854775807
08:05:23 <merijn> > succ 9223372036854775807 :: Int
08:05:26 <lambdabot>  *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
08:05:35 <bahamas> c_wraith: what do you mean by distribution artifact size?
08:05:46 <celphi> Oh so even though the #s keep going
08:05:56 <celphi> It has a bound
08:06:06 <c_wraith> Int has a highest possible value.
08:06:09 <c_wraith> Integer does not
08:06:29 <c_wraith> (well, technically it does, depending on how much system memory you have...)
08:06:43 <shapr> heh
08:07:04 <celphi> These all make sense to have succ and pred: (), Bool, Char, Ordering, Int, Integer, Float and Double. but the bool one didnt make sense to me.
08:07:07 <shapr> I'm now vaguely tempted to see if libgmp handles swapping well
08:08:22 <geekosaur> how can () make sense but Bool not?
08:08:27 <c_wraith> bahamas: the source for most libraries is a few kilobytes.  The compiled versions are a bit bigger - for every single combination of compiler version, package flags, and inlined dependencies on other packages
08:08:35 <celphi> I actually dont know what () is
08:08:46 <celphi> i just pasted it from tutorial.
08:08:47 <geekosaur> :t ()
08:08:48 <lambdabot> ()
08:08:56 <c_wraith> bahamas: the inlined dependencies are the big deal.  There would be thousands of versions of common packages.
08:08:59 <Solonarv> 'data Unit = MkUnit' -- same thing as ()
08:09:15 <celphi> is that like an empty tuple?
08:09:20 <geekosaur> it's an enumeration with one value, typically representing something with no result
08:09:21 <geekosaur> :t putStrLn
08:09:22 <lambdabot> String -> IO ()
08:09:41 <c_wraith> bahamas: nix deal with this by having a giant binary cache infrastructure and typically locking down build plans to a very small possible variety.
08:09:50 <geekosaur> yo use putStrLn for the side effect, not the value; but it needs to have *some* value. so it uses ()
08:09:57 <Solonarv> you can also think of it as a zero-element tuple, yes
08:10:18 <c_wraith> bahamas: cabal, on the other hand, gives you the flexibility to use all of those without the massive infrastructure for binary artifacts
08:10:25 <celphi> ok cool
08:10:30 <bahamas> c_wraith: giant binary cache infrastructure is what I was thinking as well
08:11:11 <celphi> maxBound :: Bool
08:11:13 <c_wraith> bahamas: that's especially important when you remember ghc will inline across packages, so what something builds to depends on exact dependency versions
08:11:19 <bahamas> c_wraith: yes, I understand the flexibility. I understand it's also about cost. I think it would be great if Hackage or something else provided binaries. a lot of time would be saved
08:11:34 <bahamas> c_wraith: but I guess I can use nix if I want that for now
08:13:03 <celphi> how come maxBound :: Float doesnt work
08:13:19 <merijn> Becaus Float isn't an instance of Bounded
08:13:21 <c_wraith> A lot of instances for Float/Double are really questionable.
08:13:37 <c_wraith> I think they'd be better off without Enum instances than they are with their current ones
08:13:39 <merijn> Also, Enum for Float and Double are vile evil
08:14:08 <c_wraith> > [1, 1.3 .. 2]
08:14:10 <lambdabot>  [1.0,1.3,1.6,1.9000000000000001]
08:14:14 <celphi> maxBound :: Bounded a => a (is there a way to identify which variable types they are)?
08:14:17 <c_wraith> Oh, right.  rounding
08:14:22 <shapr> bahamas: but I won't get binaries for my this quarter Xeon!
08:14:26 <c_wraith> > [1, 1.3 .. 2.1]
08:14:28 <lambdabot>  [1.0,1.3,1.6,1.9000000000000001,2.2]
08:14:36 <c_wraith> that's the bizarre case
08:14:39 <celphi> yeah the tutorial pointed that out
08:14:55 <c_wraith> there's no excuse for that! :)
08:15:03 <shapr> bahamas: now I'm curious whether compiling binaries for different levels of x86_64 results in speed / size differences
08:15:21 <c_wraith> "the spec requires it" is an explanation, but it just transfers the blame to the spec.
08:16:05 <celphi> The example they gave in tutorial is [0.1, 0.3 .. 1] 
08:16:35 <c_wraith> more or less, pretend Float and Double don't have an Enum instance and you'll be happier
08:16:41 <bahamas> shapr: I think you wouldn't care as much when you're just starting out with your project. having binaries would be something more beginner friendly
08:16:48 <celphi> k
08:16:57 <celphi> thnx.
08:17:26 <celphi> is there a way to determine which variable types are allowed with this? maxBound :: Bounded a => a
08:17:56 <celphi> since it doesn't say int -> int
08:19:04 * hackage pairing 0.1.2 - Optimal ate pairing over Barreto-Naehrig curves  http://hackage.haskell.org/package/pairing-0.1.2 (sdiehl)
08:21:58 <Solonarv> sure: you can replace 'a' with any type you want, as long as it has a 'Bounded' instance
08:24:19 <geekosaur> in ghci (not lambdabot) ":i Bounded" will tell you what Bounded instances are in scope, among other things
08:30:11 --- mode: glguy set +v barnl
08:30:28 <Solonarv> %% :i Bounded
08:30:29 <yahb> Solonarv: http://qp.mniip.com/y/46
08:30:52 <lavalike> neat
08:31:03 <Solonarv> yahb is cool :D
08:32:29 <barnl> hi
08:33:38 <Solonarv> hello!
08:34:09 <barnl> can you guys help me with a thing?
08:34:24 <barnl> i'm basically trying to figure out what a "registered package" is
08:34:53 <barnl> i've read this article on how to put a pretty-printer into ghci: https://teh.id.au/posts/2017/02/13/interactive-print/index.html
08:35:05 <infinisil> Probably just a package registered on hackage?
08:35:17 <geekosaur> it means it shows up in "ghc-pkg list" (note that with something like stack or cabal sandboxes you need to runt hat in the sandbox)
08:35:19 <barnl> and the article says "However, it does not survive :reload. colorPrint is a local definition, so it is cleared on reload along with the rest of our session bindings. If you want your custom pretty-printer to survive long-term, it needs to be a symbol defined in a registered package, such as pretty-show. For this reason, vanilla pPrint is a safer bet."
08:35:35 <infinisil> Ah
08:35:44 <geekosaur> tis also means that installing something for general ghci use will be painfl under e.g. stack, which will usually exclude it because it's not a dependency
08:36:20 --- mode: glguy set +v noah__
08:37:02 <barnl> so what i've been trying is to put "colorPrint = IO.putStrLn . hscolour TTY defaultColourPrefs False False "" False . ppShow" into a module and use that module as a dependency in my projects
08:37:10 <barnl> together with the necessary imports etc
08:37:35 --- mode: glguy set +v noah_
08:38:03 <noah_> How can I convert a function a -> m (Maybe a) to m (Maybe a) -> m (Maybe a)?
08:38:33 <barnl> and it works, until i do :r in ghci and then it defaults back to the normal printer
08:42:03 * hackage pandoc-csv2table 1.0.6 - Convert CSV to Pandoc Table Markdown  http://hackage.haskell.org/package/pandoc-csv2table-1.0.6 (vmandela)
08:42:45 <barnl> so running "stack exec ghc-pkg list" dos list a bunch of packages, but not the one i created (which is normal i guess)
08:44:04 * hackage pairing 0.1.3 - Optimal ate pairing over Barreto-Naehrig curves  http://hackage.haskell.org/package/pairing-0.1.3 (sdiehl)
08:45:29 <Solonarv> % :t \f -> runMaybeT . (>>= (MaybeT . f)) . MaybeT
08:45:29 <yahb> Solonarv: Monad m => (a1 -> m (Maybe a2)) -> m (Maybe a1) -> m (Maybe a2)
08:45:34 <Solonarv> noah_: ^
08:46:23 <celphi> Oh that :i command is cool
08:46:27 <Solonarv> yup!
08:46:56 <Solonarv> (it's actually :info, :i is just a convenient shorthand)
08:47:06 <celphi> yeah i like it a lot.
08:47:23 <celphi> thnx for showing me that
08:47:40 <Solonarv> :D
08:51:24 <hololeap> hopefully this isn't too OT, but what license is a good default when starting a cabal project? i've never understood the differences between all those choices... should it match the license of Haskell in general?
08:52:33 * hackage jammittools 0.5.5.1 - Export sheet music and audio from Windows/Mac app Jammit  http://hackage.haskell.org/package/jammittools-0.5.5.1 (mtolly)
08:53:40 <Solonarv> Whatever license works for the project; the fact that it's a haskell project isn't particularly relevant
08:54:22 <Solonarv> I think the MIT license is a pretty good default if you want to be open-source, but there are endless debates about this kind of stuff
08:55:44 <hololeap> ok... i found a pretty good rundown of the whole license ecosystem at gnu.org, but it's still pretty confusing what the main differences are
08:56:39 <boj> if you don't particularly care what people do with your code and don't want to be liable MIT or BSD3 are perfectly fine
08:59:04 <Solonarv> Yup. If you look at my github repos they're all MIT-licensed.
08:59:25 <Solonarv> (ignoring those which are forks of someone else's repo, and the throwaway ones that might not even have a LICENSE)
09:05:37 <hololeap> well, my last question on this topic is: what's wrong with gpl3?
09:08:03 <phadej> depending on whom you ask, either "nothing" or "everything" :)
09:10:11 <phadej> https://www.gnu.org/licenses/gpl-faq.en.html#WhyUseGPL <- first sentence summarises it alreaady
09:12:09 <hololeap> i see... so that's the item of contention
09:16:00 <EvanR> i'm surprised we haven't seen a crusade-like religious war fought over this yet
09:16:14 <EvanR> like boots on the ground
09:18:15 <c_wraith> the vim vs emacs war has settled, too. no side won, but it's rare for two seeking a fight on opposite sides to find each other
09:21:40 <hololeap> qwerty vs dvorak?
09:23:12 <infinisil> dvorak! qwerty is just a historical mistake
09:24:02 <hololeap> yeah, i've been "getting around to" switching for a few years now
09:25:28 <__monty__> boj: Might as well use BSD 2-clause instead of BSD3.
09:38:46 <Solonarv> eeeee I actually ran into a module dependency cycle! It finally happened!
09:39:45 <dminuoso> Solonarv: On Munihac Ben actually asked around "Who here has used boot modules before" and looked around him.. nobody spoke up and there was an awkward silence..
09:40:08 <Solonarv> this'll be a first for me :D
09:40:45 <phadej> often if you split your modules, you can break the cycle
09:40:54 <phadej> or generalise
09:41:14 <Solonarv> actually in this case I get a cycle /because/ I'm splitting, I had everything in a huge monolith before
09:41:27 * ski . o O ( splitting module into signature and implementation, in ML module system )
09:42:09 <dminuoso> Circular dependencies can be pretty tough to avoid without special tricks in some situations sadly.
09:42:16 <Solonarv> yeah, this is one of them
09:43:15 <Solonarv> It's a rather benign case though, I'll link it once I'm done
09:44:09 <phadej> I'd try very hard to break the cycle. Because if you have cycle you don't actually split anything
09:44:38 <phadej> the concept is still monolithic, just spread in many files (which arguably is even worse than a big module?)
09:45:00 <Solonarv> The cycle is actually only there because of an HKD-like type family
09:46:41 <Solonarv> I could remove it, but then there'd be additional wrapping/unwrapping noise downstream
09:53:39 <phadej> coerce works
09:54:31 <phadej> though, can't you define that family in the same module with a type it unwraps?
09:57:06 <Solonarv> no, because it removes multiple different wrappers
09:57:26 <Solonarv> and coerce /is/ noise compared to "nothing at all" :D
09:57:43 <phadej> have multiple type families, and compose them?
09:59:10 <Solonarv> since when can you compose type families? o_O
09:59:11 <Ariakenom> I'm going to interpret those quotes to mean the 3 variables "nothing at all"
10:00:23 <Solonarv> when I quote code I use single quotes :P
10:11:58 <c_wraith> that sounds like it could be a line from some sort of coding gang rap. 
10:20:51 <Solonarv> heh
10:21:06 <Solonarv> ...am I missing something? where am I supposed to import showSPrec from?
10:21:18 <cemerick> is hedgehog the best game in town for property-based testing with ~automatic shrinking that can maintain runtime invariants?
10:21:21 <Solonarv> nevermind, I mistyped it
10:23:12 <Akii> Hard to put my issue in words but I tried: https://gist.github.com/Akii/3f792f149b23a23dca0ecab9230e0569 Essentially I want to have several continuous scans and use their results within other scans.. 
10:23:22 <Akii> if anyone has an idea I'd appreciate it
10:24:15 <Akii> I do have real code to show for this but it's probably weird and abstract. This is the... hehe.. gist of it
10:24:31 <koz_> Akii: Pipes or conduit sound a lot like what you want.
10:24:38 <Akii> already using pipes
10:25:02 <Akii> I think I need to store less in IORefs and compose more pipes
10:25:13 <Akii> but Pipes is tedious with merging and splitting
10:26:12 <Akii> I also have a related issue with lazy evaluation.. I run all those pipes and in the end nothing really is evaluated
10:26:28 <Akii> which is why I deepseq the UI models every 15 seconds
10:26:36 <Akii> it's getting weird :D
10:30:40 <Solonarv> You could just deepseq wherever the values are produced
10:31:07 <Solonarv> also, if you're folding over an event stream perhaps FRP would be a good idea?
10:33:12 <Akii> Solonarv I actually tried that but then I'd need to differentiate between the initial startup phase and the continuous phase
10:33:28 <Akii> because deepseq'ing every step takes so much time apparently..
10:33:51 <Akii> every time I look into FRP it's not the thing I want
10:34:23 <Akii> Like this is a prime streaming problem. All I need is splitting/merging and concurrently running pipes
10:34:37 <Akii> I probably overthink this
10:43:30 <Akii> All I probably need to do is Applicative magic and unification of my 3 types of events
10:43:32 <Akii> or smth like that
10:44:02 <Akii> I hate this feeling of almost having the solution but somehow lacking one piece of knowledge
10:47:44 <jlamothe> Can anyone suggest a better way I could've written this? https://github.com/m4dc4p/hcl/pull/5
10:48:12 <[exa]> Akii: anyway, what is the whole thing supposed to do? like, in a higher perspective
10:48:36 <Akii> it's event sourcing; more specifically the projection part of it
10:48:55 <jlamothe> I don't like using const like that.
10:50:19 <Solonarv> jlamothe: you can put a type signature in the pattern
10:50:29 <[exa]> jlamothe: if you just want to force a type of 'e', put it in pattern or in a let-binding
10:50:30 <Solonarv> \(e :: IOException) -> ...
10:51:08 <[exa]> can you do even \(_ :: IOException) -> ... ?
10:51:18 <Solonarv> in this case I'd write:
10:51:18 <Solonarv> (Just <$> io) `catch` \(e :: IOException) -> pure Nothing
10:51:26 <Solonarv> or a _, yes
10:52:19 <jlamothe> I'd tried \(_ :: IOEzception) -> ... the compiler didn't like it.
10:52:32 <jlamothe> Maybe with a named value...
10:52:59 <jlamothe> Which I'm still not keen on, but we'll see what happens.
10:53:00 <Solonarv> % :t \(_ :: Int) -> undefined
10:53:00 <yahb> Solonarv: Int -> a
10:53:05 <cocreature> jlamothe: that should work once you enable ScopedTypeVariables
10:53:14 <cocreature> jlamothe: and replace IOEzception by IOException :)
10:53:18 <Solonarv> oooh that'd be it
10:53:33 <Solonarv> % :set -XNoScopedTypeVariables
10:53:33 <yahb> Solonarv: 
10:53:42 <Solonarv> % :t \(_ :: Int) -> undefined
10:53:43 <yahb> Solonarv: ; <interactive>:1:3: error: Illegal type signature: `Int' Type signatures are only allowed in patterns with ScopedTypeVariables
10:53:49 <Solonarv> yup! there we go
10:53:59 <Solonarv> % :set -XScopedTypeVariables
10:54:00 <yahb> Solonarv: 
10:59:06 <jlamothe> cocreature: It worked! Thanks!
11:03:00 <cemerick> If I add a new test dependency, e.g. `stack ghci :my-tests` will fail without attempting to obtain it. However, if I add the dep to the top-level dependencies, it is downloaded and built as expected. What might cause this?
11:03:07 <Akii> is this a thing people use? http://hackage.haskell.org/package/monad-par-0.3.4.8/docs/Control-Monad-Par.html
11:04:41 <cocreature> cemerick: what happens if you run stack ghci --test :my-tests?
11:07:21 <johnjay> hey what are the benefits of learning haskell? is it as much as lisp?
11:07:46 <johnw> the benefits are that it will stimulate your mind, and make writing certain kinds of programs more fun, if you're of that mindset
11:08:18 <johnjay> i see
11:08:48 <johnw> but if you're a Python type of guy who just wants to "make his computer do stuff" and then head home, maybe not
11:09:03 <neobrain> it also tends to make writing programs in languages *other* than Haskell much *less* fun
11:09:32 <neobrain> sorry, you asked for benefits... as you can tell I'm really bad at those :p
11:09:35 <johnw> (no dig on Python intended, it just seems designed to get _thinking about programming_ as much out of the way as possible)
11:10:19 <koala_man> which is not always a bad thing
11:10:56 <koz_> koala_man: If you're being paid to glue together Web App #8650, sure.
11:11:09 <johnw> no, it's not always a bad thing
11:11:32 <johnw> not everyone in the world aspires to, or needs to care about, a deeper understanding of the fundamentals of computing
11:12:56 <johnw> when I was a C++/Lisp/Python programmer, I loved programming. After learning Haskell, now I love CS and math, and programming is a way to instantiate these ideas.
11:13:28 <johnjay> haha well i am "python make computer go, python make computer do" most of the time
11:13:39 <koz_> johnw: That's a really good way of phrasing it.
11:13:42 <johnjay> but sometimes I do look at the stars and wonder if aliens exist or something. so maybe i could try haskell out
11:14:02 <Solonarv> johnw++
11:14:14 <Akii> ++
11:14:27 <koz_> Someone needs to @rememeber that.
11:14:37 <koz_> s/rememember/remember/
11:15:44 <boj> my team uses haskell to erase future technical debt with the type system
11:16:08 <boj> the compiler catches so much you'd have to typically test for in another language
11:17:30 <Akii> that's what types do (=
11:17:50 <pzp> What kinds of type-level functions can you implement using TypeFamilies but not using FunctionalDependencies?
11:17:50 <johnjay> technical debt sounds like a bogus sigma 6 marketing term
11:18:14 <Solonarv> not all type systems, Akii - have you /seen/ java?
11:18:25 <Akii> oh yes I have, true
11:18:32 <johnjay> technical debt implies you know how your system will be extended in the future and you can't plan for it no
11:18:35 <johnjay> *now
11:18:51 <Solonarv> technical debt is sort of the exact opposite
11:19:15 <Solonarv> technical debt is "we didn't plan for the future, now we can't make changes we need to"
11:19:16 <johnw> I think he means: types more strictly limit the behavior of a function, so there are fewer "things it can do" which in the future turn into surprises
11:19:25 <c_wraith> johnjay, do you work in industry? that is how every single day of my life goes. I know my requirements are incomplete and I'm making the best compromises I can right now.
11:20:08 <johnw> I always thought of technical debt as building in work that you'll need to do in the future to make things right.
11:20:12 <johnjay> no i don't. do you mean like in java type languages and you're just being assigned to do something from above?
11:20:27 <c_wraith> and I even do pretty well. 75% of my compromises turn out to be good. but the remaining 25% create technical debt.
11:20:33 <boj> haskell helps with technical debt due to its strong refactoring story. it is so easy to implement unknown future features and have faith that you didn't forget anything
11:21:14 <johnjay> boj: is there a way to apply those haskell concepts to other languages like C++ or java?
11:21:26 <Akii> I'm applying them to JavaScript
11:21:28 <johnw> my favorite example of technical debt was a comment I saw in the Borland C++ compiler, where an engineer had put in a hack to fix a big during the release cycle. His comment actually said "If this line of code is still here after <DATE>, fire me." The comment was 8 years overdue by the time I saw it, and they were still there.  That's technical debt, which fortunately never had to be paid.
11:21:32 <Akii> it changes your way of thinking
11:21:34 <Solonarv> generally speaking, yes!
11:21:54 <boj> johnjay: write a lot of non-standard boilerplate you usually don't write in those languages to get close to the power of what haskell offers :)
11:22:12 <Solonarv> for example, look at the recently released bit of minecraft source code (DataFixerUpper, to be precise) and you'll see profunctors and (IIRC) lenses
11:25:41 <cemerick> cocreature: sorry for the delay; ah, that appears to be installing everything as expected
11:28:48 <johnjay> johnw: if i were him i would use a grep command or something to fail an assert if the comment was still there after x time
11:29:05 <johnw> yeah, CI exists now, doesn't it
11:30:04 <cemerick> cocreature: it looks like this is a known issue? https://github.com/commercialhaskell/stack/issues/4031
11:31:44 <johnjay> johnw: heh i suppose so. but that's not really a nything to do with haskell
11:31:59 <johnw> nor did my tech debt example :)
11:32:23 <geekosaur> except then someone forgets it was there after he's left and thinsg go weird several eyars later
11:32:28 <koala_man> johnjay: reminds me of a tech lead who wanted a benchmark to fail a unit test if it took more than N ms, hoping to prevent people from regressing performance. Instead it was just a flaky test whose flakiness depended on how recently you had gotten a new laptop
11:32:32 <johnjay> my understanding is tech debt is when you make a decision that benefits you now, but later on will cost effort to fix
11:32:39 <__monty__> Well the thesis is you'll incur less tech debt with haskell. Who knows though?
11:32:53 <johnw> johnjay: I like that definition
11:33:13 <cocreature> cemerick: yeah looks like it is
11:33:15 <johnjay> i guess my definition doesn't imply that you know it's going to be costly though
11:33:24 <johnjay> you could unwittingly incur it by making a dumb decision
11:33:27 <__monty__> You don't always.
11:33:37 <johnw> I think types curtail some tech debt; they make refactoring much easier in the future, for example
11:34:06 <Solonarv> johnjay: that's a feature, not a bug! your definition is great
11:34:32 <johnw> yeah, good definition
11:34:39 <cemerick> cocreature: thanks for the hint
11:34:46 <johnjay> heh well i was reading a book about how debt and usury are wrong, so i had it on my mind
11:35:24 <johnjay> do you have any tutorials or books/blogs that are great for learning haskell?
11:35:39 <koz_> johnjay: The Haskell Wikibook isn't a bad starting point.
11:35:41 <koz_> Helped me heaps.
11:36:07 <johnw> i enjoyed Learn You a Haskell for Great Good, as an intro to functional programming in general
11:36:16 <johnjay> hah. now that title is funny
11:36:34 <johnw> it's a cute book
11:36:45 <johnw> getting a bit out of date, but I still recall it fondly
11:42:03 * hackage type-of-html 1.5.0.0 - High performance type driven html generation.  http://hackage.haskell.org/package/type-of-html-1.5.0.0 (knupfer)
11:42:45 <_deepfire> what would be a good modern "intermediate"-level Haskell book?  (for some value of intermediate, anyway..)
11:44:39 <c_wraith> someone just finished a book targeting that.
11:44:57 <c_wraith> I don't remember who or the title, and I haven't reviewed it. (probably related)
11:45:41 <systemfault> Any thought about the whole freer vs mtl thing? Should I focus on one more than the other? :/
11:45:58 <johnw> it really depends on how much you care about performance
11:46:12 <hololeap> would intermediate entail something like the typeclassopedia and wikibook, or would it go into libraries and language extensions?
11:46:14 <johnw> and who else will be using your code
11:46:29 <Levy[m]> shouldn't partial evaluation remove most of the overhead?
11:46:41 <johnw> I really like freer, and have used it successfully, but for code on Hackage I stick with mtl
11:46:50 <monochrom> Maybe Thinking in Types is an intermediate level book.
11:47:12 <geekosaur> suppose it depends on focus. parconc might count as intermediate
11:47:13 <johnw> Levy[m]: there's a reason things like fused-effects got made
11:47:14 <_deepfire> monochrom: sounds intriguing!
11:47:28 <johnw> I haven't tried that one yet
11:47:42 <systemfault> johnw: Fused effect is the new cool "freer"?
11:47:51 <johnw> from what I can see, yes
11:47:57 <johnw> freer-simple was the new freer
11:48:00 <_deepfire> I hear good things about freer-simple.
11:48:02 <monochrom> Typeclassopedia is definitely intermediate.  The wikibook contains both beginner and intermediate.
11:48:03 <johnw> fused-effects is the new freer-simple
11:48:20 <johnw> but note, there's only ever been one mtl :)
11:48:24 <systemfault> ** head explodes **
11:48:39 <geekosaur> tell that to mtl-tf
11:48:46 <johnw> oops, I retract
11:49:01 <geekosaur> nto to mention that current mtl is a redesign of original mtl
11:49:01 <monochrom> mtl-tf didn't catch fire
11:49:18 <hololeap> how does extensible-effects tie in to all of that?
11:49:21 <geekosaur> (go look at mtl-1.x)
11:50:06 <johnw> i think freer was the new extensible-effects
11:50:10 <johnw> ?
11:50:18 <hololeap> oh, that would make sense...
11:50:21 <lyxia> hololeap: freer-simple and extensible-effects are both forks of Oleg's original code
11:51:03 <systemfault> So... if I wanted to write something reusable then mtl is probably still the best, right?
11:51:16 <lyxia> (Oleg Kiselyov the author of the Freer paper)
11:51:17 <systemfault> I wouldn't want to lock myself... or eventually lib users to a specific effect lib
11:51:32 <johnw> mtl will certainly be the most familiar to other Haskellers, at this point in time
11:53:09 <monochrom> mtl comes with GHC.
11:54:04 <systemfault> I haven't played with PureScript much... but are those effect libs based on the native PS effect system?
11:54:14 <systemfault> Or.. it's more like the opposite.
11:55:22 <geekosaur> huh. thought they were fairly strenuously avoiding doing that, but I see it's in as of 8.4.1
11:55:49 <hololeap> so, is type theory pretty much a subset of cateogry theory, or is it not that simple?
11:55:53 <geekosaur> including duplicating parts of mtl inside of ghc for its private use
11:56:20 <geekosaur> not nearly that simple. or even related, considering HoTT
11:57:41 <geekosaur> unless you count the viewpoint that category theory abstractly subsumes everything else
11:59:47 <hololeap> i'm just glancing at the sample of of "Thinking With Types" and it looks a lot like what's in Milewski's CT for Programmers book
11:59:57 --- mode: glguy set +v safinaskar
12:00:12 <safinaskar> i found <&> on online docs here: https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor.html#v:-60--38--62-
12:00:43 <safinaskar> then i used in my project  "import Data.Functor ((<&>))", but i get "Module ‘Data.Functor’ does not export ‘(<&>)’"
12:00:44 <safinaskar> why/
12:00:46 <safinaskar> why?
12:01:19 <MarcelineVQ> "Since: 4.11.0.0" version difference most commonly, you may not have base 4.11+
12:01:20 <hololeap> safinaskar: you're probably not on base-4.12
12:01:51 <MarcelineVQ> which is ghc 8.4.1+
12:01:59 <hololeap> ^
12:03:34 <safinaskar> i just checked
12:03:40 <safinaskar> i have base 4.9
12:03:50 <safinaskar> where is <&> in my base 4.9?
12:04:15 <monochrom> This is what's wrong with relying on online docs and Google. You always get a version mismatch.  The right thing to do is build local docs on your own disk.
12:04:47 <monochrom> It probably doesn't exist at all.
12:05:30 <monochrom> You can maybe go out of your way to get base-compat and maybe it bridges the gap.  But I haven't really checked.
12:05:51 <monochrom> But I would just download a newer GHC.
12:05:55 <geekosaur> lens, iirc
12:06:03 <geekosaur> or just define it yourself
12:06:22 <monochrom> Oh lens is another go-out-of-your-way errand.
12:06:27 <johnjay> lens is a c ompiler?
12:06:34 <monochrom> There is a cartoon for that.
12:07:07 <johnw> lens makes a syntactically simple language seem much larger
12:07:09 <safinaskar> okey, how to build local docs? it is possible to get something like local hoogle?
12:07:10 <hyperisco> that's like chopping down a tree to whittle a toothpick
12:07:10 <monochrom> https://ro-che.info/ccc/23
12:07:15 <hyperisco> and there is a cartoon for that also
12:07:39 <safinaskar> johnjay: "lens is a c ompiler?" - no, lens is Haskell package
12:07:53 <safinaskar> johnjay: http://hackage.haskell.org/package/lens
12:08:03 * hackage symbols 0.2.0.0 - Symbol manipulation  http://hackage.haskell.org/package/symbols-0.2.0.0 (kcsongor)
12:08:04 <johnjay> ok. i'd google it but i'm having difficulties with getting browsing to work atm
12:09:00 <MarcelineVQ> safinaskar: you can click on the source link to the right of https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor.html#v:-60--38--62- to see how it works
12:09:44 <_ceb> Is the university of Glasgow any good?
12:09:46 <monochrom> GHC already comes with local doc so that's one fewer thing to worry.  (Unless you installed GHC in non-standard ways. Note: "I got it from my linux distro" usually counts as non-standard, most linux distros butcher it.)
12:09:51 <_ceb> I know Haskell was invented there
12:10:22 <monochrom> For libraries you installed after, http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#config
12:10:47 <__monty__> safinaskar: Local hoogle's easy with nix.
12:11:04 <safinaskar> monochrom: https://ro-che.info/ccc/23 doesn't work here, in Russia
12:11:25 <monochrom> That's too bad.
12:11:49 <safinaskar> monochrom: but i still is able to see the comic using a proxy
12:11:50 <hyperisco> monochrom, I am glad you brought that comic to me… has me cracking up https://ro-che.info/ccc/28
12:11:56 <monochrom> Wait, did you test it comprehensively over all/most of Russia, or is it just your town and you extrapolated?
12:12:02 <Lears> Btw, for people who want to use local docs, I recommend open-haddock. It uses ghc-pkg to look up modules/packages and load their documentation. Like per-project hoogle indices (which I highly recommend), it's another thing that works well with nix.
12:12:13 <monochrom> Like, Russia is huge, you know.
12:12:15 <safinaskar> monochrom: my city. but i checked two different ISPs
12:12:30 <safinaskar> monochrom: i. e. i checked both home ISP and mobile
12:13:08 <johnw> Lears: is there a write up on that anywhere?
12:13:27 <monochrom> I was most impressed by a Jeopardy! epsiode.  The final question^W answer of that episode was: This country is the largest [area] country in the world after the USSR was dissolved.
12:13:39 <johnw> i use ghcWithHoogle to make local haddocks available
12:13:44 <johnw> (in Nix)
12:13:46 <safinaskar> monochrom: we have internet censorship here. mostly it applies to porn, to political site. it is very rare when some innocent site is banned. but ro-che.info is banned
12:13:52 <Lears> Not that I'm aware of johnw, but the source is tiny.
12:13:57 <safinaskar> monochrom: *to political sites
12:14:08 <monochrom> And the correct answer^W question turned out to be "What is Russia?".  OMG, that's how huge Russia is.
12:14:21 <__monty__> Lears: Why not just use your local hoogle?
12:14:58 <koz_> Maybe it's the Roskomnadzor nuclear bomb from a while ago striking again?
12:15:13 <koz_> I remember they basically had ridiculous dragnet blocking because Telegram.
12:15:27 <koz_> (I think lpaste is _still_ blocked in Russia)
12:15:40 <Lears> I do use the hoogle to look up a single function, but haddocks for modules/packages is a whole other thing. Unless there's a way to convince hoogle to open that too?
12:16:14 <hyperisco> So does that mean Russia is anti FP or just Haskell specifically?
12:16:39 <__monty__> Lears, simply hoogle for the package name?
12:16:55 <koz_> hyperisco: It's an accidental dragnet side-effect I think.
12:16:57 <__monty__> Or module name if you want to be more specific.
12:17:02 <koz_> What they're _actually_ against is Telegram.
12:17:24 <hyperisco> monochrom, well we live in the second ranking country. Not shabby.
12:17:24 <monochrom> Anyway I'm the wrong person to talk to about suspected censorship or suspected ISP flaws.  Like I could change them.
12:17:37 <safinaskar> koz_: i just checked. lpaste.net doesn't work. but https://downforeveryoneorjustme.com reports it doesn't see lpaste.net , too. so, it seems the site is down
12:17:45 <koz_> safinaskar: Interesting.
12:18:50 <Lears> __monty__: I suppose you're using some kind of local webserver interface to hoogle? I gather that can be done, but I've never looked into how. hoogling a package from the command line doesn't give me much.
12:18:53 <hyperisco> and both countries share the attribute of being mostly wasteland, or what the hippies call "nature"
12:19:05 <monochrom> koz_: Fortunately lpaste seems to be dead for good.
12:19:24 <koz_> monochrom: So I guess everyone's gonna be using Gist permanently now?
12:19:25 <hyperisco> why is that fortunate?
12:19:46 <monochrom> One fewer censored site. >:)
12:20:41 <__monty__> Lears: Oh, yep. This is the command I run: `hoogle server --local -p 8008 > $HOOGLELOG 2>&1 &`
12:20:52 <hyperisco> game over, censorship wins
12:21:11 <hololeap> dpaste.com is superior
12:21:43 <monochrom> Oh w00t "delete in one week" option. I like that.
12:21:49 <koz_> hololeap: http://dpaste.com/api/v2/ <-- wooo
12:21:58 <hyperisco> I tried reaching out the maintainer but have not got a response
12:22:55 <hyperisco> and did again a year prior I think, and by the sounds of it they were hoping to offload it onto someone else
12:23:09 <hyperisco> so I guess it just died out of willful neglect
12:23:43 <hololeap> or someone pasted a mind-blowing red-pill and the site got *disappeared*
12:24:10 <koz_> hololeap: Where's that Heath Ledger as the Joker clip when you need it?
12:24:43 <monochrom> Wait, Joker took the red pill and disappeared?!
12:25:38 <hyperisco> some people just want to watch the world be subverted by a larger reality
12:36:16 <safinaskar> hyperisco: "So does that mean Russia is anti FP or just Haskell specifically?" - of course, no.      sometimes someone post something illegal to some innocent site, and then whole site becomes banned. for example, one day someone posted to github instructions how to perform suicide. then whole github was banned in Russia (there was not techically possible to ban just that page, because github is https). so github had to ban that su
12:36:58 <safinaskar> hyperisco: ...and then Russian opened github again
12:37:05 <hyperisco> Interesting. Well it seems Apple is a bit like Russia then.
12:37:26 <safinaskar> hyperisco: so, as you can see it is possible innocent technical site becomes banned for random reason 
12:38:11 <__monty__> Wait, so we can DOS part of the russian economy just by posting something like suicide instructions to a bunch of tech sites?
12:38:21 <safinaskar> hyperisco: moreover, if i remember correctly, that "suicide instruction" was just a joke. i. e. it was simply "step 1. buy a gun. step 2. shot yourself". i. e. nothing really useful
12:38:55 <safinaskar> __monty__: yes!!!!
12:39:07 <monochrom> Apple, Russia, China, stack.  Walled gardens.
12:39:17 <monochrom> Although, I do use an iPhone.
12:39:21 <hyperisco> I haven't considered the legality of publishing suicide instructions before… seems nebulous.
12:39:42 <hyperisco> like, just publishing the means in which a Darwin award was earned could be construed as suggestive
12:40:15 <hyperisco> guess we just have to ask the Russian firewall what is permissible
12:42:22 --- mode: glguy set +v petya
12:43:00 <hyperisco> and… what if on a chemical label you say "DO NOT INGEST. Side effects include death."
12:44:30 <monochrom> I think we all understand and agree on the irrationality of censorship.
12:44:45 <johnw> I would delete that comment if I could, monochrom
12:44:50 <hyperisco> so then suppose I patch the GitHub page to say "step 1. DO NOT buy a gun, step 2. If you failed step 1, DO NOT shoot yourself with the gun." and then follow it with a winky face?
12:44:51 <monochrom> haha
12:45:02 <koala_man> it seems pretty rational depending on what your goals are
12:49:26 <koz_> Is hindent still being worked on? 
12:49:51 <johnw> koz_: have you tried brittany?
12:50:05 <koz_> johnw: https://github.com/lspitzner/brittany/issues/200
12:50:14 <koz_> So yes, and as usual, I found bugs. With my face.
12:50:14 <johnw> :(
12:50:37 <hyperisco> I think winky faces would dramatically improve the mood of all warning labels.
12:50:39 <johnw> install with ancient-install?
12:50:56 <hexagoxel> koz_: have you tried installing using the instructions from the readme?
12:51:12 <hexagoxel> koz_: sorry for not having replied on the ticket yet
12:51:19 <johnw> we use brittany at work, along with a test that breaks CI if your PR contains code different from what brittany produces
12:51:32 <koz_> hexagoxel: No worries - stuff happens. Thanks for informing me that, again, I fail at reading. :P
12:51:33 * hackage symbols 0.2.0.1 - Symbol manipulation  http://hackage.haskell.org/package/symbols-0.2.0.1 (kcsongor)
12:51:43 <johnw> i.e., we ended all code style arguments :)
12:52:02 <koz_> johnw: I'm a big fan of ending code style arguments. I'm also incredibly lazy.
12:52:09 <koz_> So code formatters are pretty cool.
12:52:16 <johnw> you're a call by need kind of guy?
12:52:32 <koz_> I'm more of a 'call someone else to do it' kind of guy if anything.
12:52:44 <hyperisco> run the standard formatter for checkin, run your personal formatter for checkout
12:52:51 <johnw> evaluation by delegation
12:53:16 <koz_> hexagoxel: Any chance that there might be a fix that allows us to just use cabal new-install?
12:53:27 <hyperisco> I think they called that distributed computing
12:53:34 <johnw> hyperisco: nice idea
12:53:44 <koz_> hyperisco: Or 'cloud' computing if you're one of the new kids.
12:54:41 <hexagoxel> koz_: i have no idea; have not tested. is new-install sufficiently stable anyways? i take it you use cabal-2.4?
12:54:56 <hyperisco> What does a series of tubes form? A cloud.
12:54:57 <koz_> hexagoxel: Yes, and britanny is _literally_ the first thing I've had issues with on it.
12:55:24 <koz_> Hlint, hindent, pandoc, tldr and shellcheck all build without issue.
12:55:30 <koz_> (well, build and install)(
12:55:40 <safinaskar> hololeap: "dpaste.com is superior" - there are lots of more feature-rich pastebin sites. say, https://privatebin.net   encrypts paste in your browser. thus the server gets text already encrypted. and encryption key is included in URL itself, the server doesn't know it (well, this may help the pastebin to avoid banning in Russia if someone postes suicide instructions). also there is paste.gg , which supports posting multiple files
12:56:04 <safinaskar> monochrom: check out this pastebin sites, too
12:56:08 <koz_> safinaskar: dpaste has a CLI API.
12:56:15 <safinaskar> monochrom: ^
12:56:53 <shachaf> Encrypting the text in your browser makes no sense because the server sends you the code that does the encryption.
12:57:01 <hyperisco> an encrypted pastebin… that's like… an antipattern
12:58:10 <koala_man> shachaf: it does give some forward secrecy
12:58:29 <hyperisco> next up is encrypted imgur
12:58:42 <hyperisco> post your photos from last night's party in secrecy
12:59:19 <monochrom> I prefer the coding style that says "make all your data strict"
12:59:27 <nshepperd1> It makes sense if the server wants to legally protect itself from having access to the paste contents
12:59:53 <hyperisco> fine, let them do that
13:00:13 <hyperisco> then I'll swoop in with keybin.net which lets you publicly post the decryption key
13:01:01 <hexagoxel> koz_: i'll look into it, right after i resolve my current fight with cabal :/ (enabling profiling for a non-trivial project currently does not work)
13:01:29 <trcc> In e.g. aeson the user can supply a record and aeson will convert some json to that given record. How does aeson map the json data to fields in the record?
13:01:46 <trcc> if it was something else I would think reflection, but how does this work in haskell?
13:01:47 --- mode: glguy set +v Baller
13:02:10 <Baller> Yo ho ho
13:02:11 <koz_> hexagoxel: Thanks - I'd be really grateful, along with other new-install users.
13:02:19 <koz_> Baller: Are you a pirate?
13:02:28 <hyperisco> we'll have to host it on some island in Oceania where modern laws don't apply
13:02:39 <Baller> Do I have voice?
13:02:40 <koz_> hyperisco: I live on an island in Oceania. :P
13:02:51 <hyperisco> great we'll use your basement
13:03:01 <koz_> Lol, I don't have a basement. I have an attic?
13:03:11 <hyperisco> right, waterlines and stuff
13:03:31 <nshepperd1> hyperisco: you can already publicly post the link, which includes the decryption key. So what?
13:03:33 <Baller> must I nickserve identify to get voice?
13:04:00 <johnw> Baller: I hear you
13:04:21 <hyperisco> sure you can, most sites ignore what they don't recognise in a query string :P
13:04:55 <monochrom> trcc: If you added "deriving Generic" to your type, that's how aeson knows your fields (both names and types).  Generic has the methods for those.
13:05:04 <hyperisco> maybe we should call this phenomenon "encryption theatre"
13:05:21 --- mode: glguy set +v safinaskar
13:05:48 <safinaskar> i just typed "cabal install hoogle" as non-root user on my debian
13:05:52 <safinaskar> how to run it?
13:06:06 <safinaskar> i. e. where hoogle binary got installed to?
13:06:20 <monochrom> It's probably $HOME/.cabal/bin
13:06:30 <trcc> monochrom: thank you
13:06:39 <monochrom> Furthermore, the output of "cabal install hoogle" probably said that too.
13:07:26 <safinaskar> monochrom: thanks, i already found
13:10:56 --- mode: glguy set -v Ballerr
13:11:17 <Ballerr> Hello
13:11:20 <trcc> I am developing a framework in Haskell. Once a user has realised some functions, the final application will be called from a third party C application (TPC). The TPC will invoke a framework function which will invoke a function defined by the user. Currently I am using unsafePerformIO $ newIORef userFunc (mutating global state). Any other ideas?
13:11:29 <Ballerr> Am I visible?
13:11:34 <safinaskar> Ballerr: yes
13:11:46 <Ballerr> groovey
13:12:19 <johnw> trcc: you could have an init function in Haskell that returns a void * to C, and then requires this to be passed with any API calls. Otherwise, your approach is workable.
13:12:27 <hyperisco> what is TPC?
13:12:33 <safinaskar> i installed ghc and cabal from my debian repos. how to install docs for all packages i installed using "cabal install", say, parsec
13:12:34 <safinaskar> ?
13:12:53 <trcc> johnw I do. Currently the framework is handling this function
13:12:58 <c_wraith> hyperisco, I'm pretty sure it's the 3 words right before the first appearance of the initialism
13:13:03 * hackage purescript-iso 0.0.6 - Isomorphic trivial data type definitions over JSON  http://hackage.haskell.org/package/purescript-iso-0.0.6 (athanclark)
13:13:25 <trcc> johnw: otherwise I would have the require the user to provide some FFI functino, which I am not really interested in
13:13:37 <hyperisco> I was thinking it was some IPC method
13:13:43 <johnw> then the global state trick is not terrible
13:14:30 <hyperisco> can you just start the Haskell program as a separate process?
13:15:04 <monochrom> So this is why in my course policy I have "Maturity requirement: ... reading comprehension ..."
13:15:15 <trcc> hyperisco: not sure I understand
13:15:52 <hyperisco> what I think I got a B in that
13:15:57 <hyperisco> not sure because I sorta skimmed the report
13:19:19 <hyperisco> trcc, if the C program and Haskell program are separate, and run as separate processes, you can use IPC. Say a socket. It is an option.
13:19:33 * hackage chan 0.0.4 - Some extra kit for Chans  http://hackage.haskell.org/package/chan-0.0.4 (athanclark)
13:19:53 <trcc> hyperisco: ah yes.. That might be next version :) Just want to get something started for now
13:21:05 <Zemyla> You know, I am kind of thinking about the distributed-static library. :V
13:21:13 <trcc> So I think, that when TPC loads the library, then loaded will be invoked. After hs_init, I will call a custom function: foreign export ccall initDoStepFunction :: IO ()  which can do the global ref stuff
13:24:43 <hyperisco> monochrom, so what else is on your list of maturity requirements? I'm intrigued.
13:25:44 <monochrom> http://www.cs.utoronto.ca/~trebla/CSCC24-2018-Summer/course-info.html  then look for "Maturity requirement"
13:27:05 <monochrom> You won't believe how much I need to spell out those.  I.e., you won't believe how immature people are.
13:27:30 <koz_> monochrom: I'm in your position sorta. I 100% believe it.
13:27:33 * hackage haskoin-store 0.7.0 - Storage and index for Bitcoin and Bitcoin Cash  http://hackage.haskell.org/package/haskoin-store-0.7.0 (xenog)
13:28:20 <monochrom> There was a time I posted a 12-page doc on AVL trees because CLRS doesn't do AVL so I thought this would be good for students who wanted more than my slides.  Someone dared to say "Do we have to read this? This is like 12 pages."
13:29:12 <boj> wow
13:29:22 <shapr> monochrom: and you said "No, but you don't have to pass the test either." ?
13:29:27 <monochrom> And there was a time, in the last 15 minutes of an exam of a course called "data structure blah blah", a student asked "this question says design a data structure for...', what is data structure?"
13:29:43 <johnw> haha
13:29:46 <johnw> what is IRC?
13:30:06 * hackage haskoin-store 0.8.0 - Storage and index for Bitcoin and Bitcoin Cash  http://hackage.haskell.org/package/haskoin-store-0.8.0 (xenog)
13:30:20 <koala_man> there's no such thing as a stupid question, but there sure are a lot of stupid students
13:30:32 <hyperisco> I wrote a logic exam and got full marks on a question about equivalence classes when I had no idea what an equivalence class was. There's an art to stupidity.
13:30:46 <johnw> example of a stupid question: "Am I asking a question right now?"
13:31:03 * hackage datadog 0.2.3.0 - Datadog client for Haskell. Supports both the HTTP API and StatsD.  http://hackage.haskell.org/package/datadog-0.2.3.0 (dfithian)
13:31:04 <Levy[m]> Right questions but at the wrong time
13:31:29 <Solonarv> Answer all questions with "Yes" unless the asker is trying to trick you into something
13:31:50 <monochrom> Yes Levy[m].  "What is data structure?" would be an excellent question at the beginning of the course.  But I answered that in class already.
13:32:16 <hyperisco> monochrom, what you're calling immaturity I'd probably call disinterest.
13:32:42 <monochrom> Oh they care about marks so I call them very keenly interested.
13:33:09 <johnw> monochrom: where do you teach?
13:33:14 <monochrom> So it is immaturity when you want marks but deny that there is a cost.
13:33:27 <monochrom> U of Toronto, Scarborough campus.
13:33:49 <hyperisco> monochrom, yeah, you're right.
13:33:56 <hyperisco> dammit why is he always right
13:34:37 * Lycurgus don't want no damn marks
13:36:35 <Levy[m]> This is the same I've run into quite a bit with final year students that haven't picked up a programming language
13:36:43 <koala_man> monochrom: how much do you use automation when grading exercises?
13:37:14 <c_wraith> monochrom, I *just* figured out where "trebla" comes from, and I've been looking at your various pages for years. I must confess to a lack of curiosity wrt usernames. :)
13:37:31 <hyperisco> monochrom, some student's I've seen I wonder if they've just misunderstood the point. Obsessed with schooling and grades like it is the universe.
13:38:27 <hyperisco> asking "is this on the exam?" because they've overfit their behaviour to suit just the game of school
13:39:07 <geekosaur> whcih in pat derivs from HR being just as lazy and using grades as a checklist item
13:39:18 <hyperisco> though next level is to do that without losing sight of the long term, i.e. after school
13:40:57 <hyperisco> still, you raise kids like that and it isn't so surprising they become hyperattentive to grades while their sense of merit atrophies
13:41:04 --- mode: glguy set +v Newbie
13:41:15 <Newbie> can someone help me ? 
13:41:23 <koz_> Newbie: It depends. What are the symptoms?
13:41:31 <koz_> If you need medical or financial help, this is probably not the place.
13:41:37 <Newbie> xD
13:41:38 <Newbie> lol
13:41:42 <Newbie> im new to haskell
13:42:00 <Newbie> and im having problems with module installations
13:42:08 <hyperisco> I'm afraid the treatment for that condition is long an arduous.
13:42:11 <_deepfire> hyperisco: what if the students had an option to switch topic during exam -- to whatever they actually found fascinated and focused on?
13:42:13 <Newbie> my problem is with glib and gtk xD 
13:42:21 <_deepfire> *fascinating
13:42:24 <safinaskar> Newbie: just ask your question
13:42:36 <_deepfire> hyperisco, but such an option is offered rarely, if ever..
13:42:42 <Newbie> im programming under Windows and need to know how to install gtk
13:42:58 <Newbie> i tried with gtk+ but im having dependencies problems
13:43:15 <Solonarv> oooh boy that's a thorny issue
13:43:20 <Solonarv> are you using stack?
13:43:23 <monochrom> koala_man: I use autotesting for programming exercises.  For theoretical exercises I still have TAs to mark them.
13:43:38 <Newbie> nope, cabal
13:43:41 <koz_> monochrom: Must be nice having TAs.
13:43:56 <koala_man> monochrom: how much does the autotesting decide? do you manually grade those that fail, or is it fully automatic?
13:44:09 <hyperisco> _deepfire, if I flitted to whatever interested me in the moment I'd be a wreck of a person. Incessantly chasing pleasure as it recedes from me. No, there needs to be some discipline as well.
13:44:17 <koala_man> e.g. do you give marks for being close but not passing the unit test?
13:44:22 <Newbie> Solonarv: i know pretty nothing about stack
13:44:48 <Newbie> maybe im messed and i dont know what stack is
13:44:49 <Solonarv> Hmm...
13:45:00 <_deepfire> hyperisco: the thing is, the status quo model demands uniform distribution of effort across the course topics
13:45:04 <hyperisco> _deepfire, a great psychological achievement of the human is to postpone pleasure for a greater reward. Don't you know?
13:45:15 <Newbie> im installing stack right now
13:45:36 <Newbie> like i said, i didnt know what stack is xD 
13:45:41 <Newbie> i messed, sorry
13:45:46 <_deepfire> hyperisco: that's a complicated topic, since humans operate very differently psychological "bodies", so to speak
13:46:00 <Newbie> btw, i have stack installed now Solonarv 
13:46:12 <_deepfire> our variety of the options of psychologies is what makes for a vibrant society
13:46:32 <Solonarv> My process for when I need some dynamically-linked C dependency is roughly:
13:46:32 <Solonarv>  $ stack exec -- pacman -Syu mingw-w64-whatever
13:46:32 <Solonarv>  $ stack build # should work now
13:46:32 <Solonarv>  $ # download the DLL(s) and plop them next to the executable
13:46:48 <Newbie> ok
13:46:58 <Solonarv> Since this is your first stack install you'll need to do some additional steps first
13:46:58 <Newbie> ty
13:46:59 <_deepfire> hyperisco: therefore I'd refrain from making categorical statements, such as yours
13:47:54 <monochrom> koala_man: Oh! Yeah, I also ask TAs to take a quick look and give part marks for style and "it looks like the algo we require".  I emphasize "quick" and it's OK to be generous in this part.  This part doesn't worth a lot of marks anyway.
13:48:07 <hyperisco> And you're free to do so. Such a vibrant society isn't it.
13:48:08 <Solonarv> Newbie: Make sure to look at the stack docs, they're helpful
13:48:15 <Newbie> okok
13:48:19 <Newbie> on my way
13:48:35 <_deepfire> hyperisco: there are hyper-narrowly-focused people, who chase complex, specific things -- and there's a virtue to that as well
13:48:52 <hyperisco> you sound burned by the educational system
13:48:55 <johnw> i guess we should move non-Haskell chat to -offtopic at this point
13:49:02 <koz_> Agreed.
13:49:04 <johnw> (or whatever that channel is called)
13:49:33 <Solonarv> #haskell-offtopic yes
13:50:50 <Lycurgus> it's bifurcated, -blah/-offtopic, tls and non
13:51:16 <hyperisco> monochrom, a professor I had explained that he doesn't actually read assignments. He just glances them over and if they appear well done then they're probably correct and just slaps a grade on them. Heh.
13:51:48 <Newbie> Solonarv: is Stack a tool to install packages ? 
13:51:52 <Newbie> like cabal ? 
13:52:22 <Solonarv> Newbie: sort of, yes.
13:52:22 <Newbie> i mean, if i type "stack install glib"
13:52:35 <Newbie> or 
13:52:35 <Newbie> "stack install whatever " 
13:52:43 <monochrom> It is unwise to prematurely categorize people or stack.
13:53:20 <Solonarv> 'stack install blah' just means "build 'blah' (a haskell package) and copy its executable to ~/.local/bin"
13:53:33 <Newbie> oh, ok
13:53:44 <Newbie> im really new to this world xD 
13:54:02 <Newbie> and my english is not that good 
13:54:06 <Solonarv> and you picked quite the project to start on, it seems!
13:54:13 <Newbie> so im like a monkey trying to talk and to program xD 
13:54:33 <Solonarv> honestly, I hadn't noticed anything about your english. It's fine.
13:54:57 <Newbie> well im having problems to say what im trying to say, so there it goes 
13:55:02 <Newbie> my problem is 
13:55:20 <Newbie> im in 4th grade of programming engineer
13:55:32 <Newbie> and have an exam next week 
13:55:38 <Newbie> haskell programming
13:56:03 <Newbie> i have had 2 weeks of learning and its not enough for the project i have to make xD 
13:56:29 <Newbie> i will try to install/build glib with stack
13:56:45 <_deepfire> Newbie, how would you describe the program you want to build?
13:57:04 <Newbie> the one i am coding ? _deepfire 
13:57:13 <_deepfire> Newbie: yes
13:57:24 <Newbie> its a game 
13:57:43 <Newbie> but im trying to understand gtk before coding
13:57:49 <Newbie> i tried with openGL
13:57:50 <_deepfire> what kind of a game is it?
13:58:19 <Newbie> but didnt understand much 
13:59:22 <Newbie> its a puzzle game
13:59:24 <Newbie> too simple
13:59:30 <Newbie> i finished it for console
13:59:39 <Newbie> but it's too ugly xD
13:59:50 <Newbie> i want to have it with GUI 
14:00:07 <Solonarv> GUI in haskell is a bit difficult, tbh
14:00:18 <Newbie> i have noticed xD 
14:00:20 <dmwit> gtk is an especially exciting choice of thing to build. There are instructions on the wiki, and they are a bit involved. I don't know how much adaptation is needed for them to work with stack.
14:00:20 <dmj`> Solonarv: what kind of gui
14:00:24 <dmwit> But you should check them out anyway.
14:00:38 <Solonarv> I tried using various GUI libs for my game, but eventually threw it away and stuck to SDL2
14:00:52 <Newbie> dmwit my problem is installing gtk
14:01:08 <dmwit> https://wiki.haskell.org/Gtk2Hs/Installation
14:01:13 <Newbie> im coding under windows
14:01:35 <dmwit> There is a section about Windows, but it was written back when XP was the dominant version.
14:02:02 <Newbie> oh i see
14:02:07 <Newbie> i tried with gtk+
14:02:08 <dmwit> It may still work, I don't know. You should read it carefully. Windows makes some things quite difficult.
14:02:25 <Newbie> but dont know what to do with the bin folder in gtk+
14:02:38 <Newbie> i have tried installing glib and gtk with cabal
14:02:55 <dmwit> You must install the C libraries first, before touching cabal.
14:02:55 <Newbie> and glib gives an error of other packages
14:03:07 <Newbie> what is that of C libraries
14:03:55 <_deepfire> Newbie: are you sure you need to use GTK?
14:04:10 <Newbie> _deepfire i think so
14:04:16 <_deepfire> Newbie: there are interactive graphics libraries that are better integrated with Haskell
14:04:18 <Newbie> idk what other tool 
14:04:23 <Newbie> oh
14:04:24 <_deepfire> like http://www.gibiansky.com/blog/haskell/haskell-gloss/ for example
14:04:54 <_deepfire> problem with GTK is that it carries too much of the C baggage in its concepts
14:04:55 <Newbie> the thing about gtk is i have a project of a brickbreaker i want to try
14:09:59 <_deepfire> gtk2hs is a complex software stack, which is featureful, but somewhat fragile.. it often gives people problems..
14:10:36 <Newbie> i have been 4 hours trying to install gtk xD 
14:11:19 <Newbie> everywhere says using gtk+ is enough
14:11:19 <_deepfire> this pain is known.. : -)
14:11:41 <Newbie> but i cant solve the problem xD 
14:11:51 --- mode: glguy set +v ibloom
14:11:59 <Newbie> Graphics.UI.gtk is the module
14:12:05 <Newbie> i have tried everything
14:12:06 <Newbie> xD
14:12:12 <_deepfire> well, it's going to be enough -- once you master its build and usage.. problem is two weeks are not infinite..
14:12:15 <Newbie> i think im switching to another  GUI tool
14:12:20 <dmwit> If you want help, you're going to have to give more details. What did you do? What did you expect to happen? What happened instead?
14:13:08 <Newbie> i should upload what i have to the git repo
14:13:26 <dmwit> Be precise. It might make sense to spend a half an hour with ESR's "How to Ask Questions the Smart Way" -- you'll get better answers at the end of that half hour than you might after half an hour of bad questions. =P
14:13:44 <Newbie> xD i know 
14:13:50 <Newbie> my questions are not the best
14:13:58 <Newbie> cause i dont even know what to ask
14:14:22 <Newbie> i think that installing gtk will be enough but maybe it wont 
14:14:55 <Solonarv> Oh, it will be. Installing gtk is what's hard
14:14:57 <dmwit> http://catb.org/~esr/faqs/smart-questions.html
14:15:55 <Newbie> haha ty dmwit 
14:16:14 <Newbie> Solonarv: oh, so my problem is that , then 
14:16:38 <Newbie> i have to figure it out how to install gtk 
14:16:58 <Newbie> if i cant do it on windows, i will install linux in the other pc
14:17:13 <Newbie> cause this problems its getting me mad xD
14:18:50 <sm> obligatory http://hackage.haskell.org/package/fltkhs suggestion
14:21:25 <lavalike> sm: I'm starting to think you're involved with that library (:
14:22:25 <Newbie> btw failed to install that library xD 
14:22:28 <sm> I haven't even used it. :) It's just one of those things that I think looks good and that noone but me ever seems to know about :)
14:22:58 <Newbie> well people, im leaving xD 
14:23:03 <Newbie> i will try again tomorrow
14:23:20 <sm> Newbie: you tried that package's install guide ?
14:23:25 <Newbie> i have been 12 hours in coding and im having abad headache
14:23:49 <Newbie> i did sm
14:24:07 <berndl> So, I'm reading https://hackage.haskell.org/package/kan-extensions-5.0.1/docs/Data-Functor-Yoneda.html
14:24:16 <sm> well a break is a good idea, it will go much better when fresh
14:24:28 <Newbie> ty sm
14:24:33 <berndl> And I'm noticing that the proof of liftYoneda . lowerYoneda ≡ id is missing.
14:24:35 <Newbie> im coming back tomorrow
14:24:35 <sm> good luck
14:24:54 <berndl> I tried working it out, but I'm stuck.
14:25:36 <berndl> https://hastebin.com/ekapanatad.m
14:32:03 * hackage u2f 0.1.0.2 - Haskell Universal Two Factor helper toolbox library thing  http://hackage.haskell.org/package/u2f-0.1.0.2 (ebutleriv)
15:03:42 <koz_> @pl \x -> (x,x)
15:03:42 <lambdabot> join (,)
15:08:44 <berndl> OK, I just realized I forgot to use naturality.
15:15:47 <mniip> hmm
15:15:57 <mniip> can I not build an executable where the main module isn't named "Main"
15:16:12 <shachaf> ghc -main-is
15:16:12 <geekosaur> -main-is
15:16:35 <geekosaur> you can also specify the entry point that way
15:18:17 <mniip> does cabal support that?
15:18:27 <MarcelineVQ> ye  main-is: 
15:18:31 <geekosaur> it has its own 'main-is', with different rules
15:19:01 <mniip> cabal: The 'main-is' field must specify a '.hs' or '.lhs' file
15:19:07 <geekosaur> I think you end up combining them in this case, because cabal's ... does that
15:19:19 <geekosaur> so ou need ghc-options: -main-is ...
15:19:26 <geekosaur> thsi should be discussed in the cabal manual
15:20:00 <jgt> is there a nicer way to write this healthVulnDef function? http://ix.io/1uRV
15:20:14 <sclv> I think cabal’s uses ghc’s
15:21:01 <infinisil> koz_: Whoa, join (,) is amazing
15:21:09 <koz_> infinisil: Yup.
15:21:13 <infinisil> I've spent a couple minutes just trying to figure out why it works
15:21:19 <infinisil> (Got it in the end)
15:22:01 <koz_> jgt: Are _all_ combinations of those possible?
15:22:07 <koz_> Or do some preclude others?
15:22:43 <infinisil> I probably prefer `id &&& id` in favor of `join (,)` though. It's a bit less magical
15:23:02 <koz_> infinisil: Yeah, especially if you later want to stuff things into each half.
15:23:05 <MarcelineVQ> not as less magical as (\x -> (x,x))
15:23:07 <koz_> (different things that is)
15:23:21 <koz_> I might actually rewrite the thing I needed it for with &&&
15:23:23 <jgt> koz_: I'm not sure what you mean. I think some preclude others, but in this case I'm just wondering if I can write a "default" function for a record with many fields, and set them all to False
15:23:34 <jgt> without writing `False` 25 times
15:24:23 <geekosaur> ah, crud. the readthedocs version of the manual lost the discussion of how to use ghc's main-is
15:24:24 <koz_> (how do you even pronounce &&&?)
15:24:24 <koz_> (apart from 'and-and-and' or 'ampersand-ampersand-ampersand')
15:24:37 <infinisil> I'll invent a language that has no local variables, so you always need to use pointless style muahahahaha
15:25:00 <geekosaur> I think J already exists >.>
15:25:09 <jgt> koz_: apparently it's pronounced "fanout"?
15:25:12 <koz_> jgt: Not in general, no. You can rewrite that as a Vector and do it quicker that way, but then you lose accessor functions unless you wanna spell each one.
15:25:28 <koz_> I asked because it might be possible to restructure your record into several smaller records and combine them together.
15:25:40 <koz_> (in fact, I'd strongly suggest this in any case)
15:26:02 <jgt> koz_: ah, ok. Well, that's a good question to ask. In my case, this record is actually a smaller part of an even larger record :)
15:26:08 <koz_> infinisil: Yeah, J and its various friends exist. They're big on pointfree (they say 'tacit') style.
15:26:14 <koz_> jgt: Eeeek.
15:26:33 <koz_> I'd try and break it into pieces and deal with each one individually, but if this is part of something even larger...
15:26:43 <koz_> Is this part of some kind of data set you're trying to grind?
15:27:21 <jgt> koz_: Yeah. Basically I have to take a whole bunch of form inputs, and combine it into a big XML, which is then fed to electricity companies
15:27:31 <MarcelineVQ> Also an option a sum type where each of these Bools are instead Constructors, and have a Map of them instead of a record. Not in the Map? false. default, empty map
15:27:41 <jgt> this health data is one section of that XML
15:28:16 <koz_> Alternatively, pack them into a multi-dimensional array of Bools and then have a bidirectional map of indices to column names.
15:28:26 <jgt> (although I don't know why electricity companies care if a potential customer has learning difficulties…?)
15:28:43 <koz_> I would also argue that perhaps leaning on a database might help.
15:28:46 <Solonarv> you can encode 'let v = x in e' from the lambda calculus via '(λv.e)x', and that in turn can be encoded in a combinator calculus
15:29:02 <jgt> MarcelineVQ: that's quite a cool idea!
15:29:29 <koz_> (I'm actually doing something similar to the packing I suggested in my own work)
15:29:46 <MarcelineVQ> Well, Set I guess instead of Map, since prescence is the value.
15:30:13 <jgt> there are a few nice ideas, but it seems like what I have — although verbose — will be the simplest/easiest thing
15:30:43 <MarcelineVQ> whatever works, you can always change it later
15:30:48 <jgt> absolutely
15:33:42 <hexagoxel> koz_: can you confirm that the brittany fix i just pushed works? would involve clone and then new-install.
15:34:04 <koz_> hexagoxel: Let me try.
15:35:20 <koz_> hexagoxel: That's very odd - I get a 'Resolving dependencies...' then 'Up to date'.
15:35:40 <koz_> Do I have to pass some kind of flag to force a rebuild?
15:35:56 <hexagoxel> you had this checked out before, and did git pull?
15:36:06 <koz_> hexagoxel: No, I just did 'cabal new-install brittany'.
15:36:13 <koz_> I didn't have a prior checkout.
15:36:50 <hexagoxel> try "cabal new-install exe:brittany". "brittany" might default to the package from the index, instead of the current dir.
15:37:53 <koz_> hexagoxel: http://paste.debian.net/1053795/
15:38:08 * hackage network-bsd 2.8.0.0 - Network.BSD  http://hackage.haskell.org/package/network-bsd-2.8.0.0 (HerbertValerioRiedel)
15:39:08 <adius> Is there a GHC pragma which lets me write function signatures in a polymorphic way? E.g.:
15:39:08 <adius> ```
15:39:08 <adius> newtype Test = Test Int
15:39:08 <adius> joinParts :: [a] -> a
15:39:08 <adius> joinParts _ = Test 1
15:39:08 <adius> ```
15:40:03 * hackage algebraic-graphs 0.3 - A library for algebraic graph construction and transformation  http://hackage.haskell.org/package/algebraic-graphs-0.3 (snowleopard)
15:43:52 <hexagoxel> koz_: i can reproduce, in a separate checkout. let me see how pandoc etc. manage to avoid that particular nonsense.
15:44:00 <koz_> hexagoxel: Thank you for your tireless efforts.
15:44:52 <hexagoxel> ah, they put ChangeLog.md into "extra-source-files:" instead of "extra-doc-files:"
15:45:10 * hexagoxel tests this
15:46:32 <hexagoxel> no, that wasn't it.
15:46:46 * hexagoxel scratches head
15:49:16 <hexagoxel> just use.. stack :D
15:49:30 <koz_> hexagoxel: Lol.
15:49:57 <fr33domlover> I got this error from stack build: https://share.riseup.net/#o4nFyAeTkJImzzwLOS5GMg
15:50:33 <fr33domlover> I could delete ~/.stack but it means hours of rebuilding stuff, is there more specific stuff I can delete and stack build again to fix this?
15:50:45 <mniip> 11/30/2018 [02:24:02] <koz_> (how do you even pronounce &&&?)
15:50:47 <mniip> mediate?
15:50:54 <hexagoxel> (thanks for immediately providing a counterargument to stack :D)
15:51:03 <koz_> mniip: Interesting.
15:51:28 <mniip> it is /the/ unique morphism that makes the diagram commute
15:52:05 <fr33domlover> (The GHC download went fine, and then it just gives that error every time I stack build)
15:52:05 <sm> fr33domlover: stack upgrade ?
15:52:18 <fr33domlover> sm, I'll try :)
15:53:04 * hackage network-bsd 2.7.0.0 - Network.BSD  http://hackage.haskell.org/package/network-bsd-2.7.0.0 (HerbertValerioRiedel)
15:53:07 <hexagoxel> adius: `(\_ -> Test 1)` has type `a -> Test`, so i don't know what you want with that signature.
15:54:49 * fr33domlover runs stack build again and prays ^_^
15:56:00 <MarcelineVQ> https://github.com/commercialhaskell/lts-haskell/issues/154
15:57:12 <sm> haskell tools should offer to search the web for their error messages
15:57:27 <sm> it would save a lot of time
15:58:49 <MarcelineVQ> like a @lmgtfy to get https://www.google.com/search?q=NoParse%20"license"  ?
15:59:53 <sm> yes
16:00:23 <sm> some apps show short error codes too, I don't know if that would help
16:03:07 <lavalike> @googleit NoParse "license"
16:03:07 <lambdabot> http://letmegooglethatforyou.com/?q=NoParse+"license"
16:03:16 <lavalike> @google NoParse "license"
16:03:17 <lambdabot> https://github.com/commercialhaskell/lts-haskell/issues/154
16:05:53 <koz_> I have a slightly weird question - I have something which generates arrays of Word64, and I need to ensure that the results (which I can't predict) are filtered for uniqueness, and also that I don't introduce an array and its complement (all bits flipped) as well. I'm thinking that I need to ram it through a Set or a HashSet, but I'm unsure which would be a better first option. The arrays would have total
16:06:45 <sm> lavalike: nice
16:06:52 <lavalike> (:
16:07:57 <koz_> size of 6-7K, plus whatever overheads Massiv forces on me.
16:07:58 <koz_> What would you nice folks suggest as a good starting point - ram through Set, or ram through HashSet?
16:07:58 <koz_> Solutions amenable to parallel processing on the CPU preferred.
16:08:31 <hexagoxel> the flipping part can be done just by normalizing to a form where the first bit is 0, right?
16:09:41 <koz_> hexagonel: I'm not sure I understand how. To demonstrate with 4-bit words, I need it not to collect both [0b1100, 0b1010] and [0b0011, 0b0101].
16:09:55 <koz_> (essentially, for the purposes of uniqueness, I treat those two as 'the same')
16:11:34 <zachk> koz_, checking your array manually would be O(n^2) I believe, so is O(n*insert on set) be faster? then check for length of set 
16:12:09 <koz_> zachk: I don't disagree with the choice of a set as an auxilliary structure here.
16:12:23 <koz_> My question is 'should I start with Set, HashSet, or does it not matter much?'.
16:12:38 <zachk> is HashSet faster? 
16:13:00 <koz_> zachk: Asymptotically I think the answer is 'no'. Practically, for my specific data? Unsure, hence my question.
16:15:37 <hexagoxel> koz_: the easiest way of treating the same is by normalizing the representation of the equivalence classes.
16:15:57 <koz_> hexagoxel: How would you suggest doing this? I'm definitely interested in doing a normalization like that, but I'm not sure how.
16:16:48 <hexagoxel> as i said, the first bit. or the last bit.
16:17:04 <koz_> hexagoxel: I'm sorry, but I still don't follow.
16:17:09 <hexagoxel> normalize x = if first_bit_zero x then x else flip x
16:17:32 <koz_> X refers to the whole array?
16:17:35 <koz_> Or each element?
16:17:36 <hexagoxel> yes
16:17:41 <hexagoxel> the whole array
16:18:22 <koz_> Sorry if I'm being dense, but I have no idea how this normalizes the representations any.
16:20:03 <hexagoxel> well both normalize [0b0011, 0b0101] == normalize [0b1100, 0b1010] == [0b0011, 0b0101]
16:20:15 <hexagoxel> s/both//
16:20:37 <koz_> Oh, I see what you meant now.
16:20:41 <hexagoxel> (am i misunderstanding the task perhaps?)
16:20:51 <koz_> The 'flip' means 'flip all bits'.
16:21:01 <hexagoxel> eh, yes :)
16:21:15 <koz_> I thought you meant 'just flip the 'sensor' bit' and was terribly lost.
16:21:22 <koz_> That's a pretty neat scheme, thanks!
16:21:54 <koz_> Will wait and see if anyone can chime in on the Set vs. HashSet auxilliary question.
16:22:16 <koz_> Since I'm actually not entirely clear on when which is preferable, aside from 'if you care about order then Set'.
16:22:19 <koz_> (in this case I don't)
16:26:30 <hexagoxel> koz_: have you considered tries?
16:26:53 <hexagoxel> it smells like a trie application, because Ord and Hash might be expensive
16:29:52 <zachk> has anyone here ever gotten ghc working on openindiana?
16:33:46 <hexagoxel> well, but then tries are more about compact representation when there are overlaps. depends on the data that you have.
16:43:08 <johnjay> brittany what now?
16:43:23 <johnjay> does the haskell community have its own names for everything. T_T
16:43:25 <MarcelineVQ> a code formatting tool iirc
16:43:39 <MarcelineVQ> Things usually have their own names.
16:45:12 <johnjay> unfortunately to find out the name of something you have to already know the name of it
16:45:23 <MarcelineVQ> That's the most direct way for sure
16:45:25 <johnjay> i have that all the time with apt-get trying to figure out what the pdf viewer is called or whatever
16:45:49 <johnjay> usually with a clever combination of apt-file, apt-cache, apt-get, and guesswork I can figure it out
16:46:25 <zachk> whats apt-file do? 
16:46:46 <hpc> apropos pdf, perhaps
16:47:06 <davean> koz_: why is it flip and not binary not?
16:47:11 <johnjay> zachk: reverse lookup. searches packages and returns ones that have a specific file
16:47:32 <zachk> never knew, sounds cool/nice 
16:47:43 <johnjay> well it's cool. but what i'm saying is, without it i'd be deep sixed
16:47:54 <davean> hexagoxel: I would not call Tries compact at all personally.
16:48:02 <johnjay> so in haskell i feel it would be the same thing again with a giant ecosystem
16:48:08 <geekosaur> soemthing something naming something something hardest problem
16:48:25 <hololeap|2> koz_: from the unordered-containers docs: "A HashSet is often faster than other tree-based set types, especially when value comparison is expensive, as in the case of strings."
16:48:41 <davean> johnjay: Interesting. I've only used apt-file mabye 20 times since I learned about it decades ago
16:49:07 <celphi> how do i do multiline so i can add function declaration
16:49:09 <MarcelineVQ> geekosaur: I call that the grimblor persporiety.
16:49:11 <hololeap|2> i'm not sure how calculating a hash for two strings would be faster than comparing them though
16:49:13 <geekosaur> nto to say geeks needing to be "clever"
16:49:48 <celphi> Im trying to add this:
16:49:52 <celphi> lucky :: (Integral a) => a -> String  
16:49:52 <celphi> lucky 7 = "LUCKY NUMBER SEVEN!"  
16:49:52 <celphi> lucky x = "Sorry, you're out of luck, pal!"
16:50:01 <celphi> But i get error from ghci.
16:50:03 <zachk> celphi, in ghci? 
16:50:07 <celphi> Yes.
16:50:17 <zachk> separate all the lines by ; 
16:50:21 <davean> hololeap: well, just consider the assembly
16:50:45 <zachk> or there is some option I forget that allows multiline, but I mostly just use ; as a line separator in ghci, even for the type signature
16:51:02 <celphi> <interactive>:101:37: parse error on input `;'
16:51:16 <hololeap> because there isn't a comparison for each character, just for the hashes at the end?
16:51:23 <zachk> ? did you put them all on one line celphi? 
16:51:28 <celphi> yes
16:51:31 <davean> in GHCi multiline starts :{
16:51:44 <celphi> *Main> lucky :: (Integral a) => a -> String; lucky 7 = "LUCKY NUMBER SEVEN!"; lucky x = "Sorry, you're out of luck!"
16:51:49 <johnjay> for example i'm basically guessing that apt-get install haskell-stack is what i need to do for haskell
16:52:03 <johnjay> but for all i know i need libdeb_ghc_compiler_package_addon_something_something
16:52:16 <davean> hololeap: you don't NEED to compare each char to do a string compare, you can xor and and if you just want equality checks. But yes.
16:52:17 <johnjay> geekosaur: indeed
16:52:33 * hackage cassava-conduit 0.5.1 - Conduit interface for cassava package  http://hackage.haskell.org/package/cassava-conduit-0.5.1 (domdere)
16:52:50 <celphi> Still get error. :*(
16:52:54 <davean> johnjay: oh, you don't use aptitude
16:52:54 <MarcelineVQ> celphi: that line as written works for me, does that line as written give you an error?
16:53:04 <celphi> Yeah
16:53:07 <davean> johnjay: that explains it
16:53:13 <geekosaur> celphi, lasttime you brouht that up I asked about your ghci version
16:53:21 <MarcelineVQ> celphi: what if you put let lucky :: (Integral a) => a -> String; lucky 7 = "LUCKY NUMBER SEVEN!"; lucky x = "Sorry, you're out of luck!"
16:53:28 <geekosaur> some linux distriutions still include ghc 7; you need to start that with "let" in that case
16:53:58 <celphi> My verison is 7.6.3
16:54:08 <zachk> celphi, i cute and pasted your earlier code and separated with ; and it worked fine
16:54:14 <zachk> that is kind of old 
16:54:21 <zachk> 8.4 - 8.6 is more current 
16:54:26 <zachk> by years
16:54:32 <davean> celphi: thats MASSIVELY ancient
16:54:38 <MarcelineVQ> it would be a good idea to upgrade to a 8.* or newer ghc, but if you don't feel up to doing that for you you'll need to say  let   to define things, like geekosaur is suggesting
16:54:42 <celphi> Sorry. I'm noobie.
16:54:48 <celphi> I just did yum install
16:54:52 <davean> celphi: where did you find sometihng so old?
16:54:59 <geekosaur> "yum"
16:55:00 <davean> celphi: thats from 2012
16:55:01 <zachk> i'm installing 7.6.3 atm myself 
16:55:13 <zachk> on a strange operating system though 
16:55:26 <geekosaur> if thats' rhel… it amkes debian look leading edge
16:55:30 <celphi> https://medium.com/@jtpaasch/install-haskell-on-centos-5be42b76c7a4
16:55:34 <celphi> is how i installed it
16:55:38 <celphi> i have centos 7
16:55:39 <geekosaur> centos. same story
16:55:55 <zachk> doesn't the haskell platform offer a rpm? 
16:56:23 <davean> ... I've got a copy of linux 2.2 if anyone wants to update to it ...
16:56:33 <celphi> lol.
16:58:04 <celphi> https://www.haskell.org/downloads/linux (only has unoffical repos)
16:58:15 <celphi> for centos
16:58:39 <davean> Yah, I don't think anyone loves centos, its not very common.
16:59:06 <celphi> sadface.. will i still be able to learn effectively on version 7?
16:59:20 <MarcelineVQ> yes
16:59:24 <davean> It'll be akward. Its massively out of date so many things won't work as you read about
16:59:29 <davean> but its still Haskell
16:59:32 <celphi> k
16:59:55 <davean> the base library type classes are different now, but modern code should mostly work if its not too fancy
16:59:59 <davean> ... mostly.
17:00:10 <hpc> it has stack though, and a version of stack that predates them trying to usurp package definitions from cabal
17:00:16 <celphi> it's not backwards compatiable?
17:00:18 <davean> ... mostly./?
17:00:43 <davean> celphi: I mean some stuff is compatable, but there are changes. That was 6 years ago.
17:00:55 <celphi> oh. that was awhile ago
17:01:05 <davean> celphi: I'm not even sure what the state of Haskell2010 was i nthat version and we've had AMP since then
17:01:38 <hpc> my memory of ghc 7 was that before .10 none of it really mattered
17:01:42 <davean> Applicativeis a superclass of Monad now, we've got Foldable and Traversable (theres compatability options to make it work back that far, but they're stnadard now)
17:02:03 * hackage pretty-show-ansi-wl 1.9.2.1 - Like pretty-show, but only for ansi-wl-pprint  http://hackage.haskell.org/package/pretty-show-ansi-wl-1.9.2.1 (LiamOConnorDavis)
17:02:04 <hololeap> wait, couldn
17:02:10 <davean> celphi: you cna make code compatable back that far mostly, but its takes actually doing it.
17:02:22 <hololeap> couldn't celphi use stack to install a newer version of ghc? (i'm not a stack user)
17:02:29 <hpc> hololeap: yes
17:02:35 <davean> celphi: As you're learning that makes it harder.
17:02:54 <hpc> stack comes with the baggage of doing build environments properly
17:02:59 <davean> hololeap: I already suggested he just install a modern GHC not via yum, hell, you can just downloda the tarball from the GHC site.
17:03:08 <hpc> learning that and haskell at the same time is way too much
17:03:27 <celphi> So what's your recommendation?
17:03:30 <davean> hpc: I mena, for someone's definition of "properly"
17:03:39 <davean> celphi: just grab GHC from haskell.org/ghc?
17:03:48 <celphi> ok ill do that
17:03:52 <celphi> brb
17:04:09 <hpc> davean: i mean more that it forces you to put effort into it, not that stack is necessarily the right way ;)
17:04:38 <hpc> also yeah, agreed with installing from the ghc site
17:04:56 <hpc> you can cabal install a consistent set of packages you need from that, and for the most part things are fire and forget
17:04:59 <davean> celphi: I assume you know enough *nix to do a user local install or something
17:05:34 <davean> I've never used ghcup, maybe this is its use case
17:05:38 <hpc> things get annoying when it comes time to change a package version, but that shouldn't come up when you're just learning
17:05:57 <davean> eh, by the time he's doing that he should be comfortable enough to just do vs-
17:05:59 <davean> *v2-
17:06:19 <celphi> ok so maybe i should just download the platform for windows
17:06:31 <celphi> i prefer linux but it's same thing right?
17:06:38 <davean> Eh, I'd recomend linux
17:06:43 <hpc> ^
17:06:46 <celphi> k
17:06:56 <MarcelineVQ> davean: what is v2?
17:07:03 <hpc> you can sort of get by on windows, but you're going to have a really bad time with any libraries that do something interesting
17:07:17 <davean> MarcelineVQ: the new command set for cabal as of like ... 3 years ago?
17:07:27 <zachk> celphi, I just checked on 7.6.3, you just need a let at the beginning like MarcelineVQ said earlier 
17:07:41 <celphi> ya the "let" worked
17:07:50 <MarcelineVQ> davean: is v2- differeren than new-?
17:07:51 <celphi> but now im going to try and get the verison 8
17:07:54 <hpc> ghci in a windows-style shell window is also uncomfortable
17:07:56 <celphi> thanks zachk
17:08:03 <zachk> np celphi 
17:08:10 <davean> MarcelineVQ: Its what new- was renamed to a while back.
17:08:33 <MarcelineVQ> awhile back? :X
17:08:35 <celphi> So if i do the manual install on this page: ill be good? https://www.haskell.org/downloads/linux
17:09:05 <davean> MarcelineVQ: Maybe 6 months ago? As part of getting them ready for release.
17:10:01 <MarcelineVQ> oh, that's a little different than the 3 years we incepted earlier hehe. I'm okay with being 6 months wrong on my end
17:10:03 <hpc> celphi: yep
17:10:17 <davean> MarcelineVQ: 3 years was for the set of commands
17:10:18 <hpc> ooh, new-* is close to release?
17:10:52 <davean> hpc: its getting there. Its actively in the stage of being cleaned up for release.
17:11:00 <hpc> :D
17:11:10 <hpc> i am waiting until it's released to get off of stack
17:11:23 <MarcelineVQ> sure but this is the first I'm hearing of calling anything v2 so I'm glad it's a change only within 6 months
17:11:46 <davean> hpc: Being cleaned up though means a lot of work for all the rough edges and such. Its definately months away still I tihnk.
17:12:16 <celphi> this make this too complicated to install :P
17:12:26 <celphi> *they
17:12:36 <davean> celphi: how so?
17:12:42 <davean> the tarballs are standard *nix tarballs
17:12:52 <davean> standard ./configure; make install
17:13:06 <celphi> Mines not listed-- do i just follow the Fedora 27?
17:13:20 <koz_> hexagoxel: Do you know of any trie packages for Haskell?
17:13:41 <davean> celphi: Yes, that should match your libc version.
17:14:05 <celphi> Says it requires GMP 6.1
17:14:12 <zachk> celphi: https://www.haskell.org/platform/#linux-redhat ? does that help? 
17:14:21 <koz_> hololeap: Yeah, that makes sense. You can sometimes get hilariously fast hashing using SIMD instruction magic which could race comparisons, although in the worst case you fall back equality anyway.
17:14:46 <zachk> celphi, ive had to manually compile gmp (gnu multiprecision library) to get haskell working before
17:15:10 <davean> zachk: you can just always use a version that doesn't use gmp
17:15:14 <celphi> @zachk ya that yum command installed 7
17:15:14 <lambdabot> Unknown command, try @list
17:15:31 <zachk> you did haskell-platform? 
17:15:53 <celphi> yeah, i used the command on this page : https://medium.com/@jtpaasch/install-haskell-on-centos-5be42b76c7a4
17:15:58 <celphi> same command as one you linked me
17:16:15 <zachk> i am getting assembler messages: tmp/ghc1358_0/ghc1358_0.s:35:0:  Error: bad register name `%rbp)' , then a ton of registers, what does it mean? when using ghc to compile Setup.hs for parsec-3.1.x 
17:16:23 <zachk> oh 
17:16:34 <davean> zachk: Holy what?!
17:16:51 <zachk> its ghc 7.6.3 via pkgin on openindiana 
17:16:59 <zachk> ghci works fine it seems 
17:17:04 --- mode: glguy set +v dncr
17:17:06 <davean> it doesn't like the assembler I assume.
17:17:11 <celphi> yeah they saying that one is outdated.
17:17:15 <davean> ghci doesn't compile it.
17:17:26 <davean> ghci does bytecode interpritation mostly
17:17:30 <zachk> thats the latest available out of a package manager for openindiana that I can find 
17:18:04 <davean> zachk: theres two families of assembly, maybe you assmelber wants the other style?
17:18:18 <davean> zachk: I'd see what its calling
17:18:20 <mniip> what /is/ your assembler
17:18:35 <zachk> how do I check my assembler? 
17:18:39 <davean> AT&T vs. Intel style
17:18:45 <davean> zachk: -v3 probably displays the command
17:18:58 <davean> zachk: you're in a weird error area
17:19:28 <jle`> koz_: my trip was good, thanks for asking!
17:20:13 <zachk> it looks like its using gcc to do the assembler 
17:20:14 <mniip> zachk, run with -v3, look for '*** Assembler:'
17:20:41 <davean> zachk: what what architecture are you running on?
17:21:03 <davean> lets make sure those SHOULD be the registers for your system first
17:21:38 <zachk> x86_64
17:21:40 <zachk> 'gcc' '-pipe' '-O2' '-pipe' '-O2' '-I/opt/local/include' '-I/usr/include' '-I/opt/local/include/ncurses' '-fno-stack-protector' '-L/opt/local/gcc49/lib/gcc/x86_64-sun-solaris2.11/4.9.4' '-Wl,-R/opt/local/gcc49/lib/gcc/x86_64-sun-solaris2.11/4.9.4' '-L/opt/local/lib' '-L/usr/lib/amd64' '-Wl,-R/usr/lib/amd64' '-Wl,-R/opt/local/lib' '-I.' '-c' '/tmp/ghc1370_0/ghc1370_0.s' '-o' 'Setup.o'
17:22:00 <zachk> maybe something thinks its 32-bit in the toolchain or somewhere 
17:22:19 <davean> maybe.
17:22:34 <zachk> is gcc 4.9.4 old? 
17:22:38 <gehn> very
17:22:45 <mniip> you could try tunning gcc with -v
17:22:46 <gehn> we're on GCC 9.x now
17:22:52 <zachk> wow
17:22:57 <mniip> it should tell you which assembler you're using
17:22:59 <zachk> I had heard of 7 and 8 but not 9 
17:23:09 <mniip> gehn, I mean, I was using 4.7.3 just a couple years ago
17:23:18 <gehn> that doesn't make it not old
17:23:27 <zachk> does haskell use gcc for compiling still? is it for the runtime system? 
17:23:28 <mniip> I think that was debian stable at the time?
17:23:35 <davean> Actually 4.9.4 is a 2016 compiler, but 4.9 is from 2014.
17:23:37 <mniip> zachk, as you can see, only for the assembly
17:23:39 <gehn> debian stable is like, the definition of "everything is old"
17:23:40 <davean> its not as old as the GHC
17:25:02 <davean> gehn: I don't see GCC 9 as released yet
17:25:08 <gehn> it's not
17:25:22 <davean> right, so we're not on it yet?
17:25:29 <gehn> we are
17:25:41 <davean> Then you're on something that doesn't even exist yet.
17:25:45 <gehn> it exists
17:25:59 <davean> It doesn't even have a beta listed.
17:26:08 <davean> No one has cut a GCC 9 yet as far as I can tell
17:26:13 <davean> you could be working off git ...
17:26:16 <davean> but thats not a version
17:27:14 <gehn> a sha hash is basically a version
17:27:20 <gehn> just not a release version
17:28:06 <davean> And sorry I mean svn
17:28:07 <davean> because gcc
17:28:33 <mniip> modulo pedantry, "we're on GCC 9.x now" implies everyone's using it by now
17:28:35 <gehn> there's a git mirror
17:28:45 <gehn> mniip, it doesn't at all
17:28:51 <celphi> the command ./bootstrap.sh not working :/
17:28:55 <davean> mniip: it means the GCC project has named something 9
17:28:57 <gehn> any more than "we're on 8.x" implies everyone's using 8.x which they're definitely not
17:28:58 <mniip> perhaps pick better words next time
17:29:09 <davean> celphi: you shouldn't be using bootstrap - thats not in the directions
17:29:20 <celphi> it is.
17:29:27 <gehn> perhaps use better reasoning next time
17:29:36 <davean> no, its in the build instructions not the install instructions
17:29:45 <celphi> Download the tar.gz file, extract and inside the resulting directory, run:
17:29:46 <celphi> $ sh ./bootstrap.sh
17:30:05 --- mode: glguy set +v covagrant
17:30:20 <davean> thats NOT in the install instructions
17:30:21 <zachk> celphi, that might just build ghc from source for you
17:30:24 <celphi> i asked if i goto: https://www.haskell.org/downloads/linux and do the manual install
17:30:41 <zachk> you probably want to install binaries of ghc, not build it from source 
17:30:50 <davean> celphi: oh, for cabal?
17:30:57 <celphi> yes for cabal
17:31:02 <davean> oh I thought you were on GHC
17:31:05 <mniip> are you on GHC HEAD?
17:31:05 <gehn> that may depend on how old the haskell is in his package repos
17:31:06 <davean> sorry
17:31:10 <celphi> no i finished ghc
17:31:22 <davean> ok, whats the failure of bootstrap?
17:31:28 <celphi> im on step 2
17:31:29 <mniip> celphi, you're bootstrapping cabal for which version of GHC/base/...
17:31:35 <zachk> cabal is a pia installing from src iirc 
17:31:40 <davean> celphi: you might be missing GHC in your path
17:31:50 <davean> zachk: its slow but not hard
17:31:57 <davean> zachk: I do prefer the packages of it
17:31:59 <mniip> if it's HEAD you definitely want to make adjustments to the .sh script
17:32:01 <celphi> should cabal be inside my ghc directory?
17:32:10 <davean> celphi: no
17:32:16 <celphi> ok its not.
17:32:26 <davean> but whats the error?
17:32:36 <davean> and what is "whereis ghc"?
17:32:49 <celphi> ..usr/local/lib/ghc-8.6.2/bin/ghc: error while loading shared libraries: libtinfo.so.6: cannot open shared object file: No such file or directory
17:33:07 <celphi> whereis ghc
17:33:07 <celphi> ghc: /usr/bin/ghc /usr/local/bin/ghc /usr/share/man/man1/ghc.1.gz
17:33:16 <davean> you're missing terminfo
17:33:35 <davean> from the ncurses project
17:33:37 <celphi> no idea what that means
17:33:48 <celphi> ncurses is a C library no?
17:33:54 <davean> its the thing that lets things know the capabilities of terminals.
17:33:55 <mniip> sure is
17:34:12 <celphi> not in directions /tsk tsk
17:34:19 <celphi> so i can just yum install that?
17:34:24 <mniip> probably
17:34:35 <davean> celphi: Its a standard library :/
17:35:03 <mniip> I'm not sure what for it's used though
17:35:06 <davean> I'd more worry centos has an older version of it than expected
17:35:10 <mniip> colors and readline in ghci?
17:35:12 <davean> mniip: ghci
17:35:33 * hackage nonempty-containers 0.1.0.0 - Non-empty variants of containers data types, with full API  http://hackage.haskell.org/package/nonempty-containers-0.1.0.0 (jle)
17:36:27 --- mode: glguy set +v shawn_
17:36:31 <celphi> Package ncurses-devel-5.9-14.20130511.el7_4.x86_64 already installed and latest version
17:36:31 <celphi> Nothing to do
17:36:41 <davean> celphi: what version of tinfo do you have?
17:36:56 <davean> this is why I said I thought it might be a too old version
17:37:16 <davean> no sane linux system doesn't come with tinfo, the instructions don't mention libc either.
17:37:38 <davean> if you're off the beaten track enough those are missing you don't need instructions if you're qualified to be doing what you're doing.
17:37:51 <koz_> celphi: Are you installing a bindist of GHC?
17:39:03 <davean> koz_: thats what he was doing yes, the fedora one on CentOS
17:39:12 <koz_> davean: Ah.
17:39:16 <celphi> gehn is helping me in pm.  thnx all i dont want to spam channel with my probs. :)
17:39:23 <celphi> thx for all your help too btw
17:42:49 <Hijiri> I have a career question
17:43:03 <Hijiri> how hard is it to convert higher salary potential into less working hours
17:43:29 <Hijiri> like if instead of 33% more salary I just wanted to work 30 hours or something like that
17:44:42 <Hijiri> other than being a self-employed consultant or something like that
18:09:28 <koz_> Is there some kind of pre-cooked data type like 'Inclusive a b = Either a | Or b | Both a b'?
18:10:08 <koz_> I remember it being linked in this channel but I forgot the name.
18:11:52 <covagrant> it uses These This and That, but I forget the actual name try googling those with haskell 
18:12:11 <koz_> covagrant: What exactly is a co-vagrant?
18:12:44 <MarcelineVQ> https://hackage.haskell.org/package/these-0.7.5/docs/Data-These.html
18:12:51 <covagrant> it's the categorical dual of one who is just passing through with no job 
18:12:55 <koz_> MarcelineVQ: Thank you, that was the one.
18:14:58 <Solonarv> That package has great names
18:16:20 <koz_> mergeTheseWith is a good one.
18:18:15 <dmwit> malign is my personal favorite, but crosswalk is good and every method in MonadChronicle is golden.
18:18:26 <koz_> malign is inadvertently funny.
18:18:51 <koz_> But yeah, the MonadChronicle methods are brilliant.
18:19:29 <koz_> It's a pity 'runChronicle' wasn't 'narrate'.
18:36:04 <jle`> witherable has great names too
18:36:09 <jle`> @hackage witherable
18:36:09 <lambdabot> http://hackage.haskell.org/package/witherable
18:37:03 <jle`> always wanted to use a Peat
18:37:42 <jle`> aw, just noticed that they removed blight
18:40:53 <celphi> is it possible to explicit type declaration a function after it's defined?
18:41:50 <monochrom> There is no real notion of "before" or "after" for this. You can really put your type sig almost anywhere any distance away.
18:42:20 <monochrom> If you have line 1 "f x = x" and line 10000 "f :: a -> a" it's totally fine.
18:42:34 <monochrom> and in-between you can code up other stuff.
18:43:17 <geekosaur> in a sourc efile. ghci's not as accommodating, mostly because it can't divine the future
18:43:49 <monochrom> But who in their right minds enter substantial code into ghci?
18:44:38 <monochrom> or any REPL
18:44:45 <teto> yesterday I presented this error https://www.reddit.com/r/haskell/comments/a1fs0r/settings_openfile_does_not_exist_no_such_file_or/ . I looked at ghc's code and it seems it is trying to open the files listed in copyRules: https://github.com/teto/ghc/blob/b1af0aed08c78f42c7dd2505ed9b96d0cbf1d076/hadrian/src/Rules/Generate.hs#L158-L169  is that expected ?
18:47:40 <geekosaur> the settings fiel it should be trying to open is the one in the ghc lib directory. since you say nix, I conclude they've broken theghc build in nix, possibly related to relocatable support changing
18:48:00 <celphi> @monochrom i tried doing it afterwards but it doesnt work.
18:48:00 <lambdabot> Unknown command, try @list
18:48:34 <celphi> I did this first: lucky 7 = "LUCKY NUMBER SEVEN!" then ran lucky :: (Integral a) => a -> String 
18:48:36 <geekosaur> celphi, "doesn't work" tells people pretty much nothing
18:49:11 <zachk> celphi maybe use a text editor and ghc to compile your code
18:49:28 <monochrom> No need to compile. Just use the :load command.
18:49:44 <monochrom> But definitely use a text editor and save code in a file
18:49:46 <celphi> so in ghci it the order matters?
18:49:52 <monochrom> <monochrom> But who in their right minds enter substantial code into ghci?
18:49:57 <monochrom> I really don't get it.
18:50:03 <celphi> im a noob.
18:50:25 <monochrom> For crying out loud you wouldn't even enter code like this in Python.
18:50:32 <celphi> i dont know python
18:50:42 <geekosaur> you were told twice bfore: n ghci, they must be on the sae line
18:51:34 <zachk> celphi if you are just beginning you dont need type signatures for most basic functions you code when you are starting, but writing them is good practice, haskell has very good type inference
18:51:46 <celphi> yeah but this time im asking if the order matters.
18:52:22 <zachk> someone just said it doesnt, if you use ghc, not ghci 
18:52:43 <Solonarv> the order doesn't matter, no. /if/ you enter the function and it signature at the same time.
18:53:33 <geekosaur> even in ghci they can be in any order on te same line (or mltline mode with :{ :}
18:53:35 <geekosaur> even in ghci they can be in any order on te same line (or mltline mode with :{ :})
18:53:44 <geekosaur> but they asked this a couple hours ago
18:53:48 <geekosaur> and were told then
18:54:01 <Solonarv> yes, that's what I meant by "at the same time"
18:54:05 <celphi> and this gives an error lucky 7 = "Lucky you!";lucky :: (Integral a) => a -> String; lucky x = "Sorry, you're out of luck, pal!"
18:54:09 <geekosaur> and asked it yesterday, and were tpld then.
18:54:11 <zachk> geekosaur, do you have to set something in ghci to enable multiline?
18:54:20 <geekosaur> not the :{ form
18:54:23 <monochrom> Ignorance is bliss. In lieu of that, there is always denial.
18:54:35 <celphi> i ask because it's not matching up to what you're saying
18:54:37 <zachk> put a let in front your line celphi 
18:54:44 <Solonarv> You said earlier that you were using an old GHC version. Because of that, you need a 'let' at the beginning of that.
18:54:48 <geekosaur> there's a different kind of multiline mode enabled with :set +m
18:54:52 <celphi> im using version 8 now
18:54:52 <zachk> you dont need the let if you :load or use ghc though 
18:55:22 <celphi> <interactive>:11:62: error:
18:55:22 <celphi>     Multiple declarations of `lucky'
18:55:22 <celphi>     Declared at: <interactive>:11:1
18:55:22 <celphi>                  <interactive>:11:62
18:55:33 <celphi> So it appears the order does matter.
18:56:51 <Solonarv> IIRC the equations need to be together
18:57:28 <Solonarv> so you can do 'signature; eq1; eq2' or 'eq1; eq2; signature', but you can put the signature in between
18:57:32 <c_wraith> order matters if the patterns aren't mutually exclusive too
18:57:44 <celphi> Thank you c_wraith
18:58:04 --- mode: glguy set +v PatrickRobotham
19:00:46 <monochrom> Well, I'm glad problem solved.
19:03:33 <teto> geekosaur: interesting thanks !
19:14:18 <celphi> :t 7
19:14:19 <lambdabot> Num p => p
19:14:46 <celphi> Why does this fail? 
19:14:46 <celphi> lucky :: (Num a) => a -> String
19:14:46 <celphi> lucky 7 = "LUCKY NUMBER SEVEN!"
19:15:43 <glguy> celphi: There should be an error message
19:15:43 <Solonarv> it would help if you could also say what error message you're getting
19:15:46 <c_wraith> what does "fail" mean?
19:15:56 <celphi> Oh ok sorry.
19:16:07 <celphi> It's kinda long and i didnt want to spam channel.
19:16:29 <c_wraith> Then throw it into a paste someplace and link to it
19:16:29 <celphi> Could not deduce (Eq a) arising from the literal `7'
19:16:29 <celphi>       from the context: Num a
19:16:30 <celphi>         bound by the type signature for:
19:16:41 <jackdk> too slow, c_wraith ^_^
19:16:45 <geekosaur> oh. that'sa ghc-ism
19:17:03 <geekosaur> it used to be that Num implied Eq, basically because of this particular use case
19:17:28 <geekosaur> these days you have to specify the Eq instance explicitly: (Num a, Eq a) => a -> String
19:18:22 <celphi> k. so 7 isnt a Num?
19:18:40 <koz_> celphi: 7 is a Num a for several different a.
19:18:41 <geekosaur> Num is not a type, it's a typeclass
19:18:44 <geekosaur> what is nto known i8s which *instance* of Num
19:18:59 <geekosaur> so it cant'match directly, so it tries to use ==
19:19:16 <geekosaur> and then discovers it doesn't knwo which == to use either, andasks for an Eq instance as well as the Num instance
19:20:02 <celphi> im reading Integral is a typeclass too but it works., so i guess Eq is built into it?
19:20:02 <geekosaur> as I just said, it used to be the case that if it knew the Num instance, it also knew the Eq instance. standad Haskell still requires this, but ghc as of around 7. requires you to specify the Eq instance explicitly
19:20:06 <geekosaur> 7.8
19:20:24 <celphi> im using verison 8+ now
19:21:05 <geekosaur> Integral requires Real, which requires both Num and Ord; Ord requires Eq
19:21:12 <dmwit> Eq => Ord => Real => Integral
19:21:16 <dmwit> Oh, too slow. =P
19:21:31 <celphi> Oh- thnx geek
19:21:50 <geekosaur> Num is very general
19:22:20 <celphi> i know im asking a ton of questions-- so hopefully you dont get annoyd
19:22:34 <celphi> working through tutorial
19:26:06 <geekosaur> you may have to watch out for a few more things like that. ghc tends to ride the bleeding edge, and violates standard Haskell as specified in the language report in a number of ways that enable various advanced things
19:26:16 <geekosaur> and it's hard to make things like this backward compatible
19:27:06 <celphi> k,. why would i even need Num? Why doesnt just Eq work?
19:27:34 <c_wraith> you need Num for the literal 7 to mean something.
19:27:49 <celphi> Oh-., so the 7 to mean something and Eq for equality
19:28:07 <celphi> err Num for the 7 to mean something
19:30:54 <geekosaur> to be a little more clear, because "7" here isn't actually a concrete value but a function which has a different value depending on the specific Num instance used (7 :: Int and 7.0 :: Double are two different values), it's using ==. For most uses of pattern matching, it knows an exact value and doesn't need to use ==.
19:31:19 <geekosaur> But people expect "7" to be a value, somethingt hat can be pattern matched. This whole thing is kind of a wart
19:32:38 <celphi> Interesting. Thnx for explaining that.
19:35:27 <koz_> I have a whole bunch of lazy ByteStrings (chopped up CSV input), which I need to turn into a whole bunch of Doubles. What is the appropriate tool for this?
19:45:32 <Solonarv> cassava is usually the go-to CSV library, it should be capable of doing that
19:46:30 <koz_> Solonarv: The parsing isn't the issue - I already have it in the form of a whole pile of ByteStrings stuffed into a 2D massiv array.
19:46:41 <Solonarv> oh, I see.
19:46:53 <koz_> Some of those (by column, not all) will need to be converted into columns of Doubles by parsing each lazy ByteString.
19:55:50 <koz_> (also Solonarv, do you like, sleep?)
19:58:47 <Solonarv> Only when you do :V
19:59:07 <koz_> Solonarv: ...
19:59:26 <Solonarv> I couldn't resist
19:59:29 <MarcelineVQ> :U
19:59:33 * hackage apecs 0.7.0 - Fast ECS framework for game programming  http://hackage.haskell.org/package/apecs-0.7.0 (jonascarpay)
20:00:06 <Solonarv> oooh that's an exciting package update
20:00:21 <koz_> Solonarv: I'm a fan of ecstasy.
20:00:26 <koz_> (not least of all because isovector wrote it)
20:00:33 * hackage apecs-physics 0.3.0 - 2D physics for apecs  http://hackage.haskell.org/package/apecs-physics-0.3.0 (jonascarpay)
20:01:37 <Solonarv> I haven't used ecstasy, actually
20:01:44 * hackage apecs-gloss 0.1.0 - Simple gloss renderer for apecs  http://hackage.haskell.org/package/apecs-gloss-0.1.0 (jonascarpay)
20:01:58 <koz_> Solonarv: The substance or the ECS?
20:02:38 <Solonarv> Yes.
20:04:01 <koz_> Good use of DeMorgan's laws, and logic.
20:04:31 <Solonarv> :V
20:04:42 <MarcelineVQ> Should have used Hartley's Law
20:04:46 <koz_> MarcelineVQ: ??
20:05:50 <MarcelineVQ> That's where Solonarv actually sleeps more than you, but exists in time which flows differently than yous, so he appears to always be active.
20:06:07 <Solonarv> I'm quite sure that isn't the case
20:06:20 <Solonarv> joking aside, my sleep has been really erratic this week
20:19:31 --- mode: glguy set +v fen
20:20:08 <fen> is there any way to make Traversable lazy for infinite streams?
20:22:48 <Solonarv> IIUC traverse can only be as lazy as the applicative's <*> and fmap
20:23:52 <fen> like for Stream a = Infinite (a , (Stream a))
20:24:08 <fen> data*
20:24:31 <fen> oh, the applicative? 
20:25:06 <fen> just cant seem to write traverse as there is no last value
20:25:48 <lyxia> traverse f (Infinite (a, s)) = Infinite <$> ((,) <$> f a <*> traverse f s)
20:25:54 <fen> well sure it typechecks but its scary because it looks like it will never end!
20:26:20 <fen> just worried it will keep consuming values even if something like take is done on the traversed stream
20:27:35 * hackage entwine 0.0.3 - entwine - Concurrency tools  http://hackage.haskell.org/package/entwine-0.0.3 (lambda_foo)
20:28:10 <lyxia> as Solonarv said, it depends on the Applicative
20:28:15 <fen> hmm...
20:29:47 <fen> so far the Traversable default implementation relies on get :: f a -> (a,Maybe (f a)) and set :: (a,f a) -> f a. where here "get" is of the type for nonempty things, and set is the type for streams
20:30:47 <fen> worried that the DefaultSignatures, which prevents branching, that is each class can have its methods implemented by at most 1 other class
20:31:12 <fen> and with streams, lists, and nonempty, will not have a unique implementation for traverse
20:32:34 <fen> it should work as long as get for nonempty is implemented by get for lists and thats implemented by get for streams
20:32:41 <fen> and the other way round for set
20:33:17 <fen> nonempty-set implements list-let which implements stream-set 
20:34:44 <fen> and then pairing the get/set methods of each form, there is this total lack of super/subclass since over each half, the class functions being inverses, the super/subclass hierarchy flows in the opposite direction
20:35:31 <fen> it would be better if e.g. implementing it for nonempty derived it for list and stream
20:36:26 <fen> which would be possible if the class was split into 2, one for get, one for set
20:37:20 <fen> not sure if thats worse style than having them paired together in the same class and having these wierd 2 way superclass.subclass things
20:39:05 <lyxia> what you're describing reminds me of McBride's ornaments
20:40:09 <fen> like, implementing the most refined subclass and having it derive all its superclasses seems normal, but in this setting one half of the most specialised (nonempty) and one half of the leas specialised (stream) is implemented and the defaults flow in opposite directions, fully giving the middle class (list)...
20:40:30 <fen> so wierd! 
20:40:49 <fen> totally messes up the notion of super/sub class
21:07:38 * hackage servant-kotlin 0.1.1.5 - Automatically derive Kotlin class to query servant webservices  http://hackage.haskell.org/package/servant-kotlin-0.1.1.5 (matsubara0507)
21:46:29 <jle`> is everyone ready for advent of code? :D :D
21:46:58 <jle`> fen: the problem with traversable being lazy with infinite streams is that you have to sequence an infinite number of effects
21:47:23 <jle`> it depends on the semantics of the Applicative in question
21:49:53 <jle`> it makes sense for some applicatives, but not for others
21:50:34 <jle`> if you're looking for infinite effectful streaming, there are things like (the real) ListT, etc.; this is actually a big deal that people have put a lot of work into
21:50:57 <fen> thanks
21:51:34 <jle`> (the real) ListT is similar to what you described, and also pipes, iteratees, conduit, etc.
21:52:47 <jle`> but yeah, it doesn't make sense with Traversable, because consider something like `traverse (writeIORef myRef) [1..] *> readIORef myRef`
21:52:53 <jle`> what would the resulting action's effects be?
21:53:24 <jle`> or something like even `do _ <- take 10 <$> traverse (writeIORef myRef) [1..]; readIORef myRef`
21:53:29 <jle`> that do you think that should do?
21:53:46 <jle`> if you think about it, there isn't anything that makes sense with traverse or IO's Applicative semantics
21:54:05 <jle`> (except for what actually happens: it never terminates)
21:55:00 <jle`> or even for State: `do _ <- take 10 <$> traverse put [1..]; get`
21:55:50 <fen> seems like foldMapDefault might break
21:56:12 <fen> even just for fmap (+1)
21:56:22 <fen> or toList
21:57:05 <jle`> hm, what do you mean?
21:57:18 <fen> like, egStream = Stream 0 `Stream` egStream 
21:57:37 <fen> fmap (+1) $ toList $ egStream
21:57:59 <jle`> ah, for data Stream a = a :< Stream a ?
21:58:08 <fen> if toList of Foldable was obtained using foldMapDefault
21:58:11 <jle`> for that type, foldMapDefault is just as lazy as foldMap would be, I think.
21:58:19 <jle`> since foldMapDefault uses a lazy Applicative
21:58:24 <fen> awesome
21:58:25 <fen> thanks
21:58:36 <jle`> remember, it's the Applicative that counts.  and foldMapDefault uses Const w
21:58:45 <jle`> Const w is as lazy as w's Monoid instance
21:59:07 <fen> ah yes, was confuse by the use of StateL/R in mapAccumL/R
21:59:30 <jle`> @let data Stream a = a :< Stream a deriving (Show, Functor, Foldable, Traversable)
21:59:32 <lambdabot>  Defined.
22:00:22 <jle`> @let countFrom i = i :< countFrom (i + 1)
22:00:23 <lambdabot>  .L.hs:166:17: error:
22:00:23 <lambdabot>      Ambiguous occurrence ‘:<’
22:00:23 <lambdabot>      It could refer to either ‘Lens.:<’,
22:00:31 <jle`> aw.
22:00:59 <MarcelineVQ> jle`: use yahb with  % foo  to avoid some of the cruft
22:01:00 <jle`> @let data Stream a = a :~ Stream a deriving (Show, Functor, Foldable, Traversable)
22:01:01 <lambdabot>  Defined.
22:01:11 <jle`> @let countFrom i = i :~ countFrom (i + 1)
22:01:13 <dminuoso> How can I have an unfoldr that can fail?
22:01:14 <lambdabot>  Defined.
22:01:45 <jle`> > foldMapDefault (Any . (> 10)) (countFrom 0)
22:01:48 <lambdabot>  Any {getAny = True}
22:02:15 <dminuoso> Oh well, I guess I could make some unfoldrM myself.
22:02:16 <jle`> > foldMapAny (\i -> if i > 10 then First (Just i) else First Nothing) (countFrom 0)
22:02:18 <lambdabot>  error:
22:02:18 <lambdabot>      • Variable not in scope:
22:02:18 <lambdabot>          foldMapAny :: (Integer -> First Integer) -> Stream Integer -> t
22:02:21 <jle`> dminuoso: what do you mean can fail?
22:02:29 <jle`> > foldMapDefault (\i -> if i > 10 then First (Just i) else First Nothing) (countFrom 0)
22:02:31 <lambdabot>  First {getFirst = Just 11}
22:03:37 <cocreature> dminuoso: make sure that this is actually what you want. you might end up executing all effects before you return the first element of the list
22:05:22 <dminuoso> cocreature, jle`: I was thinking of this: https://gist.github.com/dminuoso/fd3386f17a17d0d1274b4062c32f09fa
22:05:45 <dminuoso> cocreature: yeah I think this is really what I want. :)
22:07:40 <cocreature> that implentation has exactly the problem I mentioned, i.e., you can’t consume the results in an incremental fashion
22:08:40 <dminuoso> Yeah I can probably live with that.
22:16:02 <fen> ok. here is the example of this strange hierarchy... https://bpaste.net/show/17f672f4a516
22:20:50 --- mode: glguy set +v FistfulOfFunctor
22:22:34 <FistfulOfFunctor> Is there any support in Haskell for something like UnsafeMutableState a?
22:23:11 <jle`> FistfulOfFunctor: what is UnsafeMutableState a ?
22:24:33 <[exa]> FistfulOfFunctor: like, unsafePerformIO for writing to IORef?
22:24:46 <jle`> FistfulOfFunctor: and what's wrong with safe mutable state?
22:25:04 <jle`> we like living on the edge, huh?
22:25:16 <[exa]> FistfulOfFunctor: as seen above, chances are that you're trying to do something quite wrong
22:26:03 <FistfulOfFunctor> Some context: I'm looking to implement a DLL in Haskell. For sake of simplicity, let's assume that it must implement a function with signature Int -> Int. However
22:26:47 <jle`> a dynamic-linked library?
22:27:02 <FistfulOfFunctor> that function must be *stateful*. Since I need to invoke it from some non-functional language (e.g. C++), I can't use the State monad.
22:27:03 <[exa]> I thought FFI exports of Int->Int are the same as those of Int->IO Int?
22:27:19 <jle`> FistfulOfFunctor: what does it mean for the function to be stateful?
22:27:22 <[exa]> and with IO, you can use safe IORefs
22:27:26 <FistfulOfFunctor> Hence it would need to mutate state internally.
22:27:39 <jle`> FistfulOfFunctor: well, is it still a true Int -> Int function?
22:27:46 <jle`> will it return the same thing every time it is given the same Int ?
22:27:57 <jle`> semantically, I mean
22:28:04 <jle`> will `myFunc 0 == myFunc 0` ?
22:28:11 <FistfulOfFunctor> stateful = 'the result of subsequent invocations depend on previous ones'
22:28:35 <FistfulOfFunctor> jle`: No, it is not referentially transparent.
22:29:01 <FistfulOfFunctor> jle`: Yes, a DLL.
22:29:04 <jle`> it's not quite possible to do in a sensible way as an Int -> Int, since 'invocation' in haskell isn't sequential
22:29:15 <jle`> evaluation order in haskell is non-deterministic
22:30:06 <jle`> so while there are low-level primities to define an `Int -> Int` that might do IO (like FFI), it must be observationally a 'function' that returns the same thing every time 
22:30:57 <FistfulOfFunctor> jle`: Since the function Int -> Int will be invoked externally, it's therefore the 'top' of the system (as far as the Haskell implementation is concerned), which surely imposes some execution ordering?
22:30:57 <dminuoso> jle`: What do you mean by "it being non-determistic"?
22:31:03 <jle`> for example, even (+) for Int in Haskell is implemented using IO, it's "actually" Int -> Int -> IO Int.  but because, given the same inputs, it returns the same thing every time, we can treat it like an Int -> Int -> Int and from the external perspective, you can't tell the difference
22:31:08 <dminuoso> jle`: Are you sure you didn't mean to say "non-strict" rather than "non-deterministic"?
22:31:16 <jle`> i mean non-deterministic
22:31:26 <geekosaur> it kinda doesn't mater; its being invoked from not-\Haskell, it is *necessarily* in IO
22:31:53 <jle`> there are some situations where it is deterministic, but in general it isn't
22:32:09 <jle`> you can specifically trigger some evaluation when some other evaluation happens, but that's it
22:32:22 <dminuoso> jle`: Do you have an example that illustrates this?
22:33:18 <FistfulOfFunctor> So, the consensus so far seems to be: "No means of caching state within some function Int -> Int that is invoked via FFI", right?
22:33:33 <jle`> FistfulOfFunctor: there is a means of caching state, but not in an observationally sane way
22:33:57 <jle`> it's a low-level primitive for defining FFI. but unless you maintain referential transparency, things will behave very unpredictably
22:35:09 <jle`> FistfulOfFunctor: also consider that the compiler might inline invocations of the function, or do common subsequence eliminations
22:36:24 <jle`> FistfulOfFunctor: consider that myFunc 0 - myFunc 0 might give you a different answer depending on which `myFunc` the runtime system decides to evaluate first
22:36:30 <jle`> (that's -, subtraction)
22:36:33 <FistfulOfFunctor> jle`: I don't see how it can be inlined (w.r.t. the invoking external program), since it's in a dll.
22:36:48 <jle`> myVal = myFunc 0 - myFunc0
22:36:53 <jle`> er, myFunc 0 - myFunc 0
22:37:11 <jle`> the value of myVal will be different depending on which myFunc 0 the runtime system decides to evaluate first
22:37:32 <jle`> since the runtime system is free to re-order evaluations in the most optimal way
22:37:49 <jle`> it could even do CSE and compile that as myVal = let x = myFunc 0 in x - x, giving a third, different result
22:38:25 <dminuoso> FistfulOfFunctor: I do not fully understand why you can't have `Int -> IO Int` - why do you insist the function signature claims ref transparency when you also admit that it wont be ref transparent.
22:39:12 <jle`> ^ dminuoso the example above is what i meant
22:39:47 <FistfulOfFunctor> dminuoso: I'd be entirely happy to have `Int -> IO Int` if a) this could be readily invoked via FFI and b) this allowed me to cache state on the Haskell side.
22:40:09 <jle`> haskell's runtime is built around exploiting the fact that evaluation order doesn't matter, so if you have a situation where evaluation order matters, you can run into unpredictable results
22:40:14 <jle`> FistfulOfFunctor: you can cache state in IO
22:40:19 <jle`> that's one of the 'features' of IO, so to speak
22:42:16 <jle`> can you maybe give a more concrete example of what you are trying to do?
22:42:26 <FistfulOfFunctor> So (Haskell, though not FP, newbie here) what would a simple function 'Int -> IO Int' function with semantics, "state counts #invocations, return arg + #invocations" function look like?
22:43:55 <jle`> if you had a mutable variable (like IORef), you could write `myFunc x = do inv <- readIORef myVar; modifyIORef myVar (+1); pure (x + inv)`
22:44:18 <jle`> trhere might be a function to combine the read-and-modify pattern
22:44:33 <jle`> this would be referentually transparent/pure
22:44:43 <jle`> since it returns the same IO action every time
22:45:06 <jle`> one awkward thing is getting myVar into scope, but people often do that using some low level tricks.
22:45:52 <jle`> low-level-but-referentially-transparent tricks
22:46:22 <jle`> but you're doing FFI, so i'm assuming you're open to mucking around at the low level :)
22:47:30 <jle`> it does take a while to become familiar enough with the denotational semantics of haskell to know what is a sort of safe low-level hack vs. an unsafe one that can break the semantics/denotation
22:48:15 <AfC> 'evening
22:48:25 <jle`> if you're coming from an imperative intuition, you'll have to switch your mind from operational semantics to denotational semantics
22:48:27 <FistfulOfFunctor> jle`: Thanks! And is it relatively simple for the calling (C++) program to interface with the IO Int return type?
22:51:36 <jle`> FistfulOfFunctor: i don't work with it too often, but from what I've seen I think it's something that the FFI supports
22:52:22 <FistfulOfFunctor> jle`: Thanks a lot for all your help!
22:52:57 <jle`> but i do think I see what you meant originally: if your function is *only* called from C using the FFI, and never within Haskell code, it might be okay to just unsafePerformIO the entire thing.  because while it is referentially transparent, it is never observably so becuase it is never used (heh)
22:53:08 <trcc> If I have io [maybe a] how do I get io maybe [a]?
22:53:25 <jle`> but i'd always recommend doing it the 'right' way, when possible :) and 'right' meaning 'you don't have to prove it correct, the compiler can do it for oyu'
22:53:29 <jle`> trcc: there are a couple ways
22:53:30 <AfC> If I have a MultiParamTypeClass, say Dictionary a k v (whatever, it's kind * -> * -> *) and I would like to make an instance for lists, ie [(k,v)], is that possible? I get that it's complaining that that is only kind * but is is possible to make (in this example an association) list behave like Pair k v ?
22:53:37 <jle`> trcc: how do you want the result to depend on the input?
22:54:02 <AfC> Maybe I should put this on StackOverflow :/
22:54:07 <trcc> (sequence $ Prelude.map fileToJson args) currently I do this, and it gives me: io [maybe a]
22:54:28 <trcc> I would like to have IO (Maybe [a])
22:54:34 <jle`> well, you can use catMaybes to get all the Just's
22:54:42 <jle`> > catMaybes [Just 1, Just 10, Nothing, Just 3]
22:54:45 <lambdabot>  [1,10,3]
22:54:55 <jle`> you can use sequence to fail if there are any Nothing's present
22:55:01 <jle`> > sequence [Just 1, Just 10, Nothing, Just 3]
22:55:03 <lambdabot>  Nothing
22:55:05 <jle`> > sequence [Just 1, Just 10, Just 3]
22:55:07 <lambdabot>  Just [1,10,3]
22:55:09 <trcc> I cannot get the sequnce to work, because I have io [maybe]
22:55:18 <trcc> I tried sequence . sequence with no luck
22:55:22 <jle`> right, you can use an (a -> b) function with IO a, using fmap
22:55:22 <AfC> trcc: `sequenceA`, I think
22:55:30 <jle`> fmap :: (a -> b) -> (IO a -> IO b)
22:55:32 <trcc> ahh
22:55:36 <trcc> so I need to lift the sequence
22:55:37 <jle`> fmap will lift a "pure" function to be usable with IO
22:55:42 <trcc> thank you!
22:55:47 <jle`> no problem!
22:56:12 <jle`> trcc: you can also `fmap catMaybes` to get the "collect all Just's" behavior as well
22:56:20 <trcc> that is not the desired behaviour
22:56:28 <trcc> but thank you for the extra knowledge :)
22:56:47 <jle`> no problem :) yeah, that's what i mean when i say that it depends on which [Maybe a] -> Maybe [a] you want
22:56:54 <trcc> ahh yes of course
22:57:59 <fen> is there some way to use DerivingVia to neaten up the instances of Traversable,Foldable and Functor of this paste?https://bpaste.net/show/17f672f4a516
23:00:21 <jle`> fen: yeah, you can make a newtype that gives Functor, Applicative, Foldable, Traversable instance in terms of a Difference instance
23:00:42 <jle`> newtype WrappedDiff f a = WrappedDiff (f a)
23:00:54 <fen> not sure Applicative is defaulted
23:01:20 <fen> is that the only thing its useful for is a newtype?
23:01:29 <jle`> instance Difference f => Functor (WrappedDiff f); instance Difference f => Foldable (WrappedDiff f); instance Difference f => Traversable (WrappedDiff f)
23:01:47 <jle`> and then you can derive (Functor, Foldable, Traversable) via Difference
23:01:47 <fen> hmm
23:01:59 <jle`> er, derive (Functor, FOldable, Traversable) via WrappedDiff
23:02:00 <fen> oh ok! that sounds good
23:02:07 <jle`> or whatever the syntax is
23:02:15 <fen> awesome
23:02:18 <fen> thanks
23:02:20 <jle`> also note though that Functor, Foldable, and Traversable are already all derivable typeclasses in GHC
23:02:34 <jle`> so you can directly write deriving (Functor, Foldable, Traversable) without any newtyping
23:02:41 <fen> hmm
23:02:47 <fen> Comonad?
23:02:59 <jle`> Comonad, no not yet, so this can help for that :)
23:03:15 <fen> right
23:03:38 <fen> but the Difference newtype wrapper could also give a comonad for the corresponding difference Zipper
23:04:06 <jle`> yeah, if you write instance Difference f => Comonad (WrappedDiff f), then you could derive Comonad via WrappedDiff
23:04:40 <fen> oh yeah, just using "tail", like, dropping the difference list from the zipper
23:05:11 <fen> does the deriving (Functor, Foldable, Traversable) need generics?
23:05:23 <jle`> it doesn't, it's built into ghc
23:05:47 <jle`> but, it is possible with generics, without needing to be built into ghc
23:05:47 <fen> or more to the point, can the Infinite Linear and Stack be derived in the same way as  (Functor, Foldable, Traversable) ?
23:06:26 <jle`> no, not quite
23:06:47 <jle`> Foldable and Traversable deriving in GHC is built into the compiler, it uses the actual compiler-level representation of the data type
23:07:14 <jle`> so you can't do it exactly the same way while you're "in" haskell, using tools that ghc exposes
23:07:24 <fen> not sure what that is if its not generics
23:07:28 <jle`> but you can do it using GHC Generics, which is the tool that ghc exposes that is usable at the haskell/language level
23:08:04 <jle`> GHC Generics is the within-the-language tool that ghc gives to you to let you derive those typeclasses using normal haskell functions
23:08:10 <hololeap> anyone here familiar enough with conduit to tell me what this means? "Infinite operations means that source doesn't know when stream is ended so one need to use other methods of finishing stream like sending an exception or finish conduit in downstream."
23:08:12 <jle`> it's closer in nature to template haskell
23:08:16 <hololeap> from here: https://hackage.haskell.org/package/stm-conduit-4.0.1/docs/Data-Conduit-TQueue.html
23:08:56 <jle`> hololeap: conduits can act on upstream streams being "done".  usually this works by upstream streams broadcasting that they are done
23:09:17 <jle`> this is saying that TQueue will never broadcast downstream that it is done, so if any downstream conduits are waiting for the 'done' signal, it'll never happen
23:09:24 <fen> well, it might not be worth it. these really are classes that can be "extended" by encoding the get/set funcitons into an index that gives the extra information required to capture the inverse nature of these (de)constrution patterns. basically, this indexing cant be easily expressed using Generics
23:10:49 <hololeap> jle`: ok, but what about the TQueue makes it impossible to broadcast downstream?
23:11:20 <jle`> it's not impossible to broadcast downstream, it's just not ever going to broadcast that it's done
23:11:33 <hololeap> oh... wait i think i understand... the TMQueue can be closed but TQueue is always waiting for more input
23:11:36 <jle`> because its nature is that it's never done 'for sure'
23:11:50 <jle`> it can always potentailly receive more inputs down the line
23:11:55 <jle`> or, more inputs later in time
23:12:08 <hololeap> ok, that makes sense :)
23:12:46 <jle`> contrast to a queue that will not accept any more input after the first 100
23:14:01 <hololeap> yeah that acutally is completely intuitive, it just sounded as though it wasn't
23:19:43 <trcc> Is there a prettier way of:   doesFileExist fp >>= \fExists -> if fExists then Just <$> BSL.readFile fp else pure Nothing 
23:20:11 <koz_> trcc: Do notation.
23:20:48 <trcc> It seems that do notation is mainly preferred over >>=?
23:21:11 <koz_> trcc: Depends.
23:21:28 <koz_> Sometimes it's actually more verbose, especially when you can use applicative combinators instead.
23:21:32 <fen> jle`, its not a problem if the Difference instance is not derived it it? like, DerivingVia would throw an error if this instance was not given, but it does not have to be provided only using deriving clauses does it?
23:24:15 <jle`> fen: the type would have to define an instance of Difference somewhere
23:24:25 <jle`> it can be defined manually, yes
23:24:30 <fen> yay!
23:25:25 <jle`> trcc: note that that's not really a good way to 'read a file if it exists'
23:25:29 <jle`> due to the nature of IO
23:25:42 <trcc> ok
23:25:42 <jle`> the file could be deleted between the time when you check and the time when you start reading
23:26:01 <jle`> it's good for a toy project, but not something you would use in real world code :)
23:26:45 <jle`> you could simplify the lambda a bit with \fExists -> mapM (const BSL.readFile) (guard fExists), i suppose, but not sure if it's more readable :)
23:27:24 <fen> as an instance of any one of Infinite Linear or Stack gives rise to the others (with errors and patterns...) this could be done using DerivingVia also...
23:27:58 <fen> will paste a version like this imminently 
23:29:17 <jle`> "will paste post-haste"
23:33:08 <fen> the good thing is that even with all the error clauses, the Difference instance should work ok for any of them. so, while there are different versions for Infinite List and Stream, only one of these needs to be used as it works for each case. and this disambiguation means that defaults can be written using it
23:33:32 <fen> the default in question is for Traversable however, so there is no way to get at it as it is in Prelude
23:34:24 <fen> but the version for shaped containers has Traversablei instead, and so this can have its instance given by default over Difference
23:34:51 <fen> (though for these shapeless containers, having () made available at traversal is pretty redundant)
23:35:16 <fen> interestingly, this is via an UndecidableInstance
23:35:37 <fen> and follows the same style as DefaultSignatures
23:35:48 <fen> namely, only one is allowed
23:36:02 <fen> otherwise it would throw a ambiguous instance error
23:36:10 <fen> which isnt really the best error to throw
23:36:25 <trcc> I have a haskell library that is invoked from C. Therefore I also have a c file, that does hs_init and all that. 
23:36:28 <fen> but it means the DefaultSignatures can be basically written for "sprecialised" instances
23:36:33 <trcc> woaw, was supposed to be a new line
23:37:02 <trcc> is it possible to expose a method from Haskell only to the accompanying C, and not the the third party C application using the library?
23:37:43 <fen> wouldnt that depend on the modular exports for C?
23:37:50 <trcc> sort of foreign export ccall without the export
23:38:29 <trcc> fen: as it is know, it seems that all my foreign export ccall are exported once packaged into a library
23:38:41 <trcc> know/now
23:39:39 <fen> right
23:39:44 <fen> thats expected though?
23:40:04 <fen> how could haskell control which functions exported to C were then reexported by that C code#/
23:40:06 <fen> ?
23:48:19 <trcc> fen: i agree, that is expected
23:48:28 <trcc> I am just trying to see whether there is a middle ground
23:48:45 <trcc> such that the accompanying c file is aware of a haskell function, which is not exported once compiled together
23:58:14 <bahamas> hello. I'm trying to use language-python in my project. because of an issue, I can't use the version available on hackage, so I added the project to my stack.yaml `packages` key using the syntax with `location` described here: https://docs.haskellstack.org/en/v1.0.2/faq/#i-need-to-use-a-different-version-of-a-package-than-what-is-provided-by-the-lts-haskell-snapshot-im-using-what-should-i-do. however, 
23:58:20 <bahamas> when I try to build I see this message: "language-python needed, but the stack configuration has no specified version". what am I missing?
