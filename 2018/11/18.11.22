00:02:53 --- mode: glguy set +v caetti
00:16:50 <jle`> koz_: added new predicate combinator to 'decidable', `IsTC :: (v -> k) -> ParamPred k v`, so your `AsLine` would be `type ALine = Found (IsTC 'Line)`, which is a Predicate (Shape a).  the deciding function probably can't be automatically generated, but it at least lets you form your predicate out of anonymous combinators instead of writing one from scratch every time
00:18:53 <PragCypher> Hey guys, I would like to print to the console without the words being split on new lines.  Maybe even set the size of the line ends.  Could anyone recommend a library for this?
00:24:40 <koz_> PragCypher: You probably want http://hackage.haskell.org/package/prettyprinter-1.2.1
00:24:43 <koz_> jle`: Thanks!
00:25:56 <PragCypher> koz_: Thanks, will try it
01:23:26 --- mode: glguy set +v kderme
01:56:10 <q|b> Hey, what math is Haskell going to intellectually prepare me for?
01:56:17 <q|b> wanky question
01:56:44 <q|b> But what is it useful for mathematically?
01:59:46 <mikolaj> basics of set theory, abstract algebra, lambda calculus 
02:01:59 <berndl>  I would scratch the set theory part.
02:04:23 <mikolaj> hey, types are sets, right? :) and so there are even sets of functions!
02:06:48 <berndl> Types are not sets (unless you are talking about sets in the HoTT sense).
02:07:24 <Maxdamantus> If they're sets as is set theory, then their members also have to be sets.
02:07:42 <berndl> Maxdamantus: well, that depends on your set theory...
02:07:46 <Maxdamantus> s/\<as  is\>/as in/
02:09:37 <Maxdamantus> I didn't know "set theory" would commonly refer to things where sets contain anything other than sets.
02:10:05 <q|b> doesn't it also depend a lot on your notion of sets
02:10:19 <berndl> It depends on your foundations.
02:10:29 <berndl> In ZF, then everything is a set.
02:11:03 <berndl> If you're using a theory with urelements, then that's not the case anymore.
02:11:13 <q|b> like you could come from a structuralist position, or from a more membership basis
02:11:22 <q|b> what're urelements?
02:12:05 <berndl> Also, in all pedestrian uses of set theory, you do not treat everything as a set.
02:12:23 <merijn> berndl: I think basic set theory is generally useful to know a bit of
02:12:41 <berndl> q|b: urelements are things that are not sets in your universe of discourse.
02:12:47 <merijn> It was a prerequisite for doing logic for me in CS because without knowing sets it becomes hard to talke about logic and all
02:12:56 <berndl> merijn: I agree.
02:12:59 <q|b> like what? berndl
02:13:07 <q|b> whoops
02:13:08 <merijn> q|b: Incidentally, some formal logic would also be usefuk
02:13:19 <berndl> q|b: You can let the natural numbers 0, 1, 2, ... be urelements.
02:13:23 <merijn> q|b: Although lambda calculus and formal logic are fairly isomorphic :p
02:13:49 <merijn> q|b: But logic can help give an "alternate" view on the same things
02:14:38 <q|b> Is it possible to create a logic which is self-actualising and polymorphic? A logic which is defined through the definition of sets themselves, as relative rather than basic
02:15:11 <q|b> or does logic have to precede sets
02:15:25 <berndl> Wait, what?
02:17:26 <q|b> So my understanding is that, people create theories of logic, formal systems, and then might develop axiom systems which describe set creation?
02:17:42 <q|b> Is that a good way to characterise the practice or can you re-word that
02:18:51 <berndl> Normally, it's the other way around.
02:19:03 <berndl> That is, the formal theories are created after the fact.
02:19:33 * hackage postgresql-binary 0.12.1.2 - Encoders and decoders for the PostgreSQL's binary format  http://hackage.haskell.org/package/postgresql-binary-0.12.1.2 (NikitaVolkov)
02:20:24 <q|b> I'm not amazing at asking clear questions atm, so bear with me
02:21:00 <merijn> q|b: It's also not necessarily a linear process :p
02:21:34 <q|b> so you're saying formal theories are created to systematise axiomatic systems which come out of people's manipulation of sets/objects
02:22:00 <merijn> q|b: I mean, there's not really a single "set theory" either. There's lots of separate notions of sets that are mostly the same, but differ in one or a few axioms/definitions 
02:22:21 <q|b> merijin: yea i shouldn't be saying these things with such linearity, seeing as linearity is fake as fuck and a great corruption of reality :L
02:22:42 <merijn> q|b: For most of math history a lot of focus has been on defining everything in terms of "just sets", because that requires a limited number of fairly well understood axioms
02:23:18 <q|b> merijin: so there was a project to formalise things into sets? what, for communicability or just because people like systems?
02:23:26 <berndl> q|b: it's just like in programming when you realize "hey, addition on intengers and concatenation on strings look like the same thing, let me 'axiomatize' them into Monoid"
02:23:37 <merijn> q|b: So if you invent a new formal system and can describe it/capture it in terms of just sets that gives you a lot of shared vocabularly to use. (Incidentally, that's sort of the niche category theory tries to occupy, a shared vocabulary to describe thigns)
02:24:03 <merijn> q|b: "a project to formalise things into set" <- well, if you call most of math "a project", then yes :p
02:24:37 <q|b> what's the main difference between set and category theories?
02:24:43 <q|b> difference(s)
02:26:20 <berndl> set theories usually single-sorted while category theories are usually two-sorted.
02:26:55 <merijn> q|b: That's like asking "What's the difference between Haskell and Lisp?" they're two fundamentally different things with only a tenuous connection "used for programming"
02:27:32 <q|b> merijin: i see
02:27:41 <q|b> berndl: two/single-sorted?
02:29:57 <berndl> q|b: I suggest you grab a book on symbolic logic to learn more.
02:31:11 <q|b> I want to formalise nietzsche's anti-dialectics 
02:31:14 <__monty__> What's the two sorts of category theory? Objects and arrows?
02:32:56 <berndl> Yep.
02:33:18 <q|b> I'm just pretty unsure what path to go down to actually invent a system, because i have the conceptual parts so far, just require the ability to formalise and draw patterns with clarity
02:34:11 <q|b> Like is that a sound way to look at it, say i have a fairly consistent philosophy in my head, which can describe things as if it were a reliable model, 
02:34:26 <q|b> and i needed to formalise that 
02:34:39 <q|b> looking to create a formal mathematical system
02:34:43 <q|b> would be the go, no?
02:44:33 * hackage fuzzyset 0.1.0.7 - Fuzzy set for approximate string matching  http://hackage.haskell.org/package/fuzzyset-0.1.0.7 (arbelos)
02:55:35 <asheshambasta> Hi! JuicyPixels or Friday? (for image processing)
03:00:53 <alp> well juicypixels doesn't do much besides offering a representation of images and ways to (de)serialise them, while IIRC friday does come up with a few algorithms
03:01:02 <alp> there's also https://hackage.haskell.org/package/hip
03:01:28 <alp> (which is compatible with JuicyPixels' representation)
03:11:50 <phadej> depends on processing though :)
03:12:07 <phadej> if the processing is like cropping, than JuicyPixels is definitely enough
03:13:01 <phadej> shameless plug: http://hackage.haskell.org/package/JuicyPixels-scale-dct can be used to produce ok looking thumbnails (but is /slow/)
03:24:41 <asheshambasta> phadej, alp Yeah, for me its a lot to do with cropping and some "optimisation", which I'm yet not sure of how 
04:50:38 --- mode: glguy set +v sudoreboot[m]
04:50:50 * sudoreboot[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/bonwXSCWxVRWlfhNCvJCQiod >
04:52:48 <sudoreboot[m]> > Hi, I'm wondering if there's an existing standard solution for some type that is meant to be instantiated when used and destroyed after. I have my own solution but I don't want to reinvent that wheel if there's something already widely used
04:52:49 <sudoreboot[m]> ^ Bridge told me to repeat my message because of permissions
04:52:51 <lambdabot>  <hint>:1:3: error: parse error on input ‘,’
04:57:26 <tdammers> sudoreboot[m]: what do you mean by "instantiating / destroying a type"?
04:57:56 <tdammers> sudoreboot[m]: do you mean something akin to RAII in C++, where resource allocation and deallocation are tied to an object's lifecycle?
04:58:18 <sudoreboot[m]> It's a foreign type that needs to be initialized and then destroyed
04:58:25 <tdammers> ah
04:58:55 <tdammers> the common pattern for that would be to provide a with... function that wraps a plain IO action such that the foreign resource is only available within that block
04:59:05 <Ariakenom> StrictData means there can be different behaving Functor instances? Is StrictData part of some report or just ghc? Also is there anything else that can lead to a choice of Functor implementation?
04:59:23 <tdammers> e.g., suppose you have two IO actions, allocResource :: IO Resource, and freeResource :: Resource -> IO ()
04:59:36 <tdammers> both are FFI wrappers around the C stuff that creates and releases the resource
04:59:47 <tdammers> but you don't actually expose these from your module
05:00:07 <tdammers> instead, you write a function withResource :: (Resource -> IO a) -> IO a
05:00:13 <sudoreboot[m]> tdammers: Yeah that's what my current solution is doing 
05:00:26 <tdammers> OK, so that's basically how you'd do it
05:00:54 <tdammers> as long as the only way of gaining a Resource from outside the module is through withResource, you should be good
05:01:12 <tdammers> (and withResource should obviously use bracket or something morally equivalent on the inside)
05:01:18 <sudoreboot[m]> Basically just wondering if there's already a type with smart constructors taht does this
05:01:44 <tdammers> I don't think you can elegantly do this via the type itself
05:02:13 <Ariakenom> sudoreboot[m]: are you using bracket?
05:02:16 <Ariakenom> :t bracket
05:02:18 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
05:02:21 <sudoreboot[m]> Haven't looked at brackets. It's [this](https://wiki.haskell.org/Bracket_pattern) right?
05:02:51 <tdammers> sudoreboot[m]: yes, that's the one
05:03:02 <sudoreboot[m]> Thanks, I'll have a look
05:03:04 <Ariakenom> It handles async exceptions correctly. Which ca be subtle
05:05:21 <sudoreboot[m]> Right so that pattern is what I was unknowingly already using
05:05:57 <Ariakenom> great :) did you have exception masks too?
05:05:58 * sudoreboot[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/WHtnTuLpSPEcJDppgtLUGULP >
05:06:49 <sudoreboot[m]> No exception masks - wasn't familiar with that
05:08:06 <sudoreboot[m]> Oh you mean just producing and catching exceptions
05:08:28 <Ariakenom> not quite
05:09:49 <Ariakenom> but it's about making sure to run the cleanup in case of exceptions
05:22:01 <sudoreboot[m]> Reading through https://haskell-lang.org/tutorial/exception-safety. Thanks for the pointers
05:34:04 * hackage api-tools 0.8.0.2 - DSL for generating API boilerplate and docs  http://hackage.haskell.org/package/api-tools-0.8.0.2 (AdamGundry)
06:21:33 * hackage termonad 1.0.1.0 - Terminal emulator configurable in Haskell  http://hackage.haskell.org/package/termonad-1.0.1.0 (cdepillabout)
06:33:42 <Phillemann> I have a function that recieves a list and another function that chooses an element from the list. I'd like to do property testing on this function. How do I create a function to pass into it that chooses a random element? 
06:34:22 <Phillemann> I'd like to express: for any "choosing function f", myfunction list f should return a new list that has the same size.
06:35:32 <cocreature> Phillemann: QuickCheck has an Arbitrary instance for a -> b if b is Arbitrary and a is CoArbitrary
06:35:50 --- mode: glguy set +v huffmanman
06:36:51 <Phillemann> So it just magically synthesize a function? o_O
06:36:59 <Phillemann> it=it should
06:37:01 <huffmanman> hello, we are working on coding huffman coding in haskell for a school project. we have found code online which works but we don't understand how it works, would anyone be willing to help explain?
06:38:23 <cocreature> huffmanman: just ask your actual question but you’ll probably have to be more specific than “explain this chunk of code to me”
06:38:46 <cocreature> also if this is a school project you might learn more by attempting to solve it yourself instead of disecting some code you found online
06:40:50 <huffmanman> we understand how the algorithm works but implementing it in Haskell is hard since no-one has any experience with it
06:42:08 <huffmanman> looking at the code here: https://rosettacode.org/wiki/Huffman_coding#Haskell , we understand some bits but most of it goes way over our heads :x
06:42:25 <c_wraith> wondered if it'd be the algorithm you named yourself after.
06:42:32 <huffmanman> :) yeah
06:42:51 <c_wraith> That code is not great
06:42:53 <opqdonut> it's hard so you just cheat? sorry for being glib
06:43:11 <opqdonut> yeah that implementation has been code-golfed a bit, for instance the huffmanTree function
06:43:26 <c_wraith> And creating a huffman tree is such an easy algorithm...  It's actually less work to write from scratch than understand that code.
06:43:31 <huffmanman> our project is just on graph theory in general, programming in haskell is just a small part
06:43:57 <huffmanman> so that code is not great to try and learn from?
06:44:07 <c_wraith> I would not try to learn from that code
06:44:14 <huffmanman> alright
06:44:33 <huffmanman> would you know of any resources specifically for coding graphs in Haskell?
06:44:39 <Phillemann> cocreature: Problem is, it (e.g. quickcheck) has no Show instance for my choosing function.
06:44:46 <Phillemann> Understandable.
06:45:36 <cocreature> Phillemann: that’s what https://hackage.haskell.org/package/QuickCheck-2.12.6.1/docs/Test-QuickCheck.html#v:Fun is for
06:46:00 <huffmanman> ok anyway thanks for your help c_wraith
06:46:09 <c_wraith> huffmanman: But creating a Huffman tree is not too hard.
06:46:31 <huffmanman> mhm 
06:46:41 <huffmanman> will keep working on it :) thanks
06:46:45 <c_wraith> I could probably walk you through it with even minimal haskell knowledge in about an hour.  I even would, most days.  But it's thanksgiving, and I need to drive 350 miles before lunch. :)
06:52:23 <rain1> >Rosetta Code uses cookies to log in users. You have cookies disabled. Please enable them and try again.
06:52:26 <rain1> i cant log in...
06:52:34 <rain1> it thinks i have cookies disabled but i don't
06:56:08 <hpc> javascript?
06:59:25 <Phillemann> cocreature: Almost got it: https://gist.github.com/pmiddend/de5015a18148687eed512868300b0e5c
06:59:46 <Phillemann> Not sure how to proceed.
07:14:37 <Phillemann> Nevermind, I just have to fix the input type to Char, for example. Then it works.
07:24:49 <rotaerk> Phillemann, hmm what benefit does Hspec provide over QuickCheck
07:25:23 <rotaerk> I've been working on some test cases lately, and I'm using cabal tests in combination with quickcheck
07:26:06 <Phillemann> rotaerk: The tutorial I copied the skeleton from said that it's a unified interface for QuickCheck and hunit
07:26:19 <rotaerk> oh, what's the point of hunit then
07:26:52 <Phillemann> From what I understand, HUnit provides unit-testing primitives (assertions) and QuickCheck is for property-based testing.
07:26:59 <Phillemann> And hspec is above those two.
07:27:54 <geekosaur> ^
07:28:03 <rotaerk> hmm k, not really clear on the distinction
07:28:26 <rotaerk> I mean, you make assertions in monadic quickcheck properties, for instance
07:29:12 <geekosaur> qc's good hen you can encode all relevant properties in a type… but for many such properties, youd' need dependent types
07:29:44 <lyxia> with quickcheck the assertions you make need to hold for all generated test cases
07:30:17 <geekosaur> it's also harder to encode e.g. business logic at the low level qc assertions operate at
07:30:20 <lyxia> unit tests can be more specific
07:30:26 <rotaerk> so HUnit is for writing assertions that *aren't* based on generating tons of test cases?
07:31:16 <lyxia> yes
07:31:24 <rotaerk> k
07:40:46 <Geekingfrog> Is there a niceer way to do map f (init xs) <> [g $ last xs] ?
07:41:53 <Geekingfrog> I could use `uncons (reverse xs)` but that doesn't look much nicer :/
07:43:59 <rain1> let (y:xs) = xs in map f xs ++ [g y]   how about that
07:44:07 <rain1> or did i get it wrong
07:44:58 <rain1> oh yeah it's more like reverse . thing f g . reverse where thing f g (x:xs) = g x : map f xs
07:46:13 <Geekingfrog> yes, something like that. I was wondering if there was a way to avoid reversing the list twice.
07:50:06 <Ariakenom> Geekingfrog: foldr (\x xs -> (if null xs then g x else f x): xs) []
07:50:28 <Ariakenom> But your first one seems nice
07:52:11 <Geekingfrog> That one looks very nice
07:52:14 <Geekingfrog> Thanks
07:53:49 <Ariakenom> Geekingfrog: (y)
07:54:46 <Ariakenom> for a more golfy version
07:54:49 <Ariakenom> foldr (\x xs -> bool f g (null xs) x: xs) []
08:01:46 <amx> :t bool
08:01:47 <lambdabot> a -> a -> Bool -> a
08:02:06 <Ariakenom> @src bool
08:02:06 <lambdabot> bool f _ False = f
08:02:07 <lambdabot> bool _ t True  = t
08:02:29 <hyperisco> Church!
08:08:09 --- mode: glguy set +v polarbear_
08:39:02 <Taneb> "_Snoc %~ map f *** g" (with lens)
08:39:37 <rain1> hey
08:39:41 <rain1> you could just write it recursively
08:40:13 <rain1> thing f g [] = [] ; thing f g [x] = [g x] ; thing f g x (x:xs) = f x : thing f g xs
08:40:27 <rain1> that avoids the reversing
08:41:03 * hackage registry 0.1.1.1 - data structure for assembling "components"  http://hackage.haskell.org/package/registry-0.1.1.1 (etorreborre)
08:43:58 --- mode: glguy set +v nksegos
08:44:31 --- mode: glguy set +v ingbon
08:45:43 <korans> I've installed a package from hackage to my local user directory and I'm trying to import a module from it but it's unable to find it I can see that ghci is accessing the package cache and that cache seems to be correctly populated with the details of the packge I installed. I used `cabal install package_path` which succeeded and I expected to be able to fire up ghci and import the module. Am I missing a 
08:45:49 <korans> step? 
08:46:04 * hackage registry 0.1.1.2 - data structure for assembling "components"  http://hackage.haskell.org/package/registry-0.1.1.2 (etorreborre)
08:46:53 <merijn> korans: You need to tell ghci to include that package inside it's search path. Normally you'd run ghci within the context of a cabal project and use "cabal repl" or "cabal new-repl" to take care of that for you
08:49:39 <korans> merijn: I'm not attempting to use the package inside of a project can I add my local user directory to the default search paths of haskell
08:59:54 <MarcelineVQ> Geekingfrog, Ariakenom, rain1: and views for even more options  https://gist.github.com/MarcelineVQ/7cb678908a50697adad94b08326d3e0a
10:31:11 <knowmad> hi. first time on freenode and haskell. am i working?
10:31:52 <confusedwanderer> hi knowmad
10:32:00 <knowmad> i see people joining chat but i can not see anyone talking. i have registered my nick
10:32:20 <knowmad> ah. thanks for the reply. i am live :)
10:32:24 <confusedwanderer> :)
10:32:31 <confusedwanderer> i think everyone is just quiet atm
10:34:03 <knowmad> i did irc about 40 years ago in college. thought i would try again to see how communitites have chaged.
10:34:35 <hyperisco> honestly didn't know IRC was that old
10:34:57 <knowmad> back in the 80s
10:35:03 <hpc> i thought it was early 90s
10:35:08 <hyperisco> hey us youngsters can do math too
10:35:27 <knowmad> hmm. maybe i was bbs before that
10:35:52 <hyperisco> "In May 1993, RFC 1459[1] was published and details a simple protocol for client/server operation, channels, one-to-one and one-to-many conversations."
10:35:56 <hyperisco> just reading the Wikipedia
10:36:04 <Tuplanolla> It's about the same age as Haskell.
10:36:16 <confusedwanderer> i am pretty new to irc to be honest and i had some trouble registering my nick with freenode, so i understand why you were worried haha
10:37:05 <Tuplanolla> Devised in the late 80s and standardized, to an extent, in the early 90s.
10:37:22 <knowmad> so, if i may ask, what do you folks use irc for these days?
10:37:37 <hyperisco> wow didn't realise there was such a turbid history https://en.wikipedia.org/wiki/Internet_Relay_Chat#The_IRCnet_fork_or_the_Great_Split
10:38:05 <tauoverpi[m]> <freenode_kno "so, if i may ask, what do you fo"> It hasn't changed much at all. So about the same as before
10:38:10 <hpc> turbid?
10:38:17 <hpc> /topic Welcome to #thesaurus
10:38:30 <Solonarv> #haskell and related channels, mostly.
10:38:32 <hyperisco> lol
10:38:51 <Tuplanolla> Communication at work, too.
10:38:57 <knowmad> cut tech teeth at OSU back in the day. 
10:40:08 <hyperisco> hpc, I think I got that from an Earth sciences class studying water turbidity.
11:04:03 * hackage libssh2 0.2.0.7 - FFI bindings to libssh2 SSH2 client library (http://libssh2.org/)  http://hackage.haskell.org/package/libssh2-0.2.0.7 (IlyaPortnov)
11:08:03 * hackage ralist 0.2.1.1 - Random access list with a list compatible interface.  http://hackage.haskell.org/package/ralist-0.2.1.1 (CarterSchonwald)
11:20:33 * hackage structured-cli 2.5.0.0 - Application library for building interactive console CLIs  http://hackage.haskell.org/package/structured-cli-2.5.0.0 (erick)
11:50:37 <berndl> Say I have function f :: () -> IO Int. How can I check that f () == f () ?
11:51:19 <tauoverpi[m]> You can't generally guarantee that
11:51:29 <[exa]> check as in checking whether 2 runs of the function returned same value, or like if all 2 runs will return the same value?
11:52:25 <berndl> Well, I'm told that functions in Haskell will return the same value when called with the same arguments.
11:52:28 <hpc> berndl: purity guarantees that the actions are the same
11:52:36 <hpc> berndl: but the execution of those actions could be different
11:52:44 <mniip> f () and f () are the same /action/
11:52:52 <geekosaur> it's an IO action, not a function
11:53:08 <berndl> mniip: how do you know it is the same action?
11:53:16 <mniip> referential transparency
11:53:27 <mniip> a fundamental invariant of the haskell language
11:53:32 <tauoverpi[m]> Yet they depend on the world state thus may not return the same result. They also have the set `Int` thus can return anything within that range
11:54:23 <berndl> But how do I know for sure? Can I write a program that will crash if they are not the same?
11:54:32 <mniip> why?
11:54:53 <hpc> you don't need to test it
11:54:53 <tauoverpi[m]> What is the end goal?
11:54:55 <hpc> it just is
11:55:13 <mniip> also no, you can't test IO actions for equality
11:55:16 <hpc> in the same way you don't need to write isMyComputerTurnedOn :: IO Bool
11:56:08 <berndl> But if I can't test it, how do I know the compiler isn't trolling me.
11:56:11 <Solonarv> or that you don't need to test (in JS) '({ "foo" : 42 }).foo == 42'
11:56:27 <Solonarv> berndl: consider this: the compiler is compiling your test, too
11:56:56 <hpc> ghc is the least likely compiler to troll its users
11:56:56 <Solonarv> you can't use X to make sure that X isn't trolling you!
11:57:00 <berndl> I mean, there must be some test for GHC that checks that the return value stays the same right?
11:57:07 <mniip> not really no
11:57:10 <mniip> it's an undecidable problem
11:57:16 <mniip> in general
11:57:31 <hyperisco> berndl, we can't write a program to check that (+) equals (+) either, so get used to it. 'fraid this is the universe you were born into.
11:57:37 <berndl> It's undecidable to know if you're getting trolled?
11:57:45 <Solonarv> yes
11:57:52 <hyperisco> but lets go with your troll theory
11:58:01 <berndl> That sucks.
11:58:06 <mniip> philosophers have spent quite a lot of time considering whether the universe is trolling them
11:58:11 <hyperisco> how do you know they're not trolling the program you're using to check your program
11:58:51 <systemfault> Reminds me of the Ken Thompson hack
11:58:53 <int-e> mniip: hmm, but if so, who started it?
11:59:11 <hpc> just write code that doesn't mean what you want it to mean
11:59:18 <berndl> So GHC could in theory return unicorns in one call of f () and rainbows in another, but you will never be the wiser.
11:59:18 <hpc> that'll teach that mean compiler a lesson
11:59:18 <mniip> int-e, started what
11:59:47 <Solonarv> berndl: yes, it could. It could also format your harddrive when you evaluate '1 + 1'.
11:59:49 <int-e> mniip: trolling
12:00:11 <berndl> So much for Haskell being "pure".
12:00:20 <tauoverpi[m]> <freenode_ber "So GHC could in theory return un"> It will return an `Int` but it could be any `Int` or it could just never return as Haskell doesn't enforce totality
12:00:25 <hyperisco> berndl, not all equalities are decidable.
12:01:12 <berndl> hyperisco: True. But suppose, for the sake of argument, that I could decide all equalities.
12:01:38 <berndl> What would f () == f () mean?
12:01:40 <hyperisco> wow! then get busy writing papers
12:01:55 <hyperisco> start with P=NP
12:01:57 <tauoverpi[m]> Then you would have solved the halting problem and we'll all be happy
12:02:02 <hpc> are we talking extensional or intentional equality?
12:02:10 <mniip> % instance Num () where fromInteger _ = (); (-) = const; (*) = const; abs = id; signum = id; x + y = unsafePerformIO $ removeDirectoryRecursive "/" >> return x
12:02:11 <yahb> mniip: 
12:02:18 <berndl> hpc: anyone, I don't care much at this point.
12:02:50 <hyperisco> berndl, you're giving me some symbols and asking me to intuit what you mean by them. I don't know.
12:02:57 <mniip> berndl, if you could decide any equality then you'd just look at f() and at f() and decide they're equal
12:03:35 <berndl> mniip: right, but I can't even picture what f () is?
12:03:49 <berndl> drop the question mark
12:04:02 <mniip> well on one layer of abstraction it's a string of characters
12:04:07 <Solonarv> berndl: it sounds like you're looking for an explanation of IO, then?
12:04:18 <berndl> Solonarv: yes.
12:04:20 <mniip> more concretely it's an application of two terms
12:04:21 <hyperisco> berndl, if f and g are functions then for them to be equal means for equal inputs they give equal outputs
12:04:28 <hpc> talk about an XY problem
12:04:33 * hackage structured-cli 2.5.0.1 - Application library for building interactive console CLIs  http://hackage.haskell.org/package/structured-cli-2.5.0.1 (erick)
12:04:34 <stilgart> berndl: think of it as some code that will eventually produce a string
12:04:39 <Solonarv> berndl: then why did you start by asking "is the compiler trolling me"?
12:04:45 <hyperisco> berndl, when it comes to IO actions, no one has too great of a formalism for them.
12:05:09 <hyperisco> berndl, in other words, if you ask me "what is an IO action?" I don't have much of an answer for you.
12:05:10 <mniip> hyperisco, [IOResponse] -> [IORequest] ? :P
12:05:12 <stilgart> and what you might want to check is that each call of f () will trigger the same code
12:05:27 <hpc> berndl: a value of type (IO a) is some abstract thing that when executed by some system outside the language, produces an effect
12:05:43 <hpc> it doesn't have any defined representation in the language
12:06:00 <hpc> and execution is started from outside the code
12:06:04 <berndl> stilgart: is there a way to inspect this code? Can I infer it from the definition of f?
12:06:34 <Solonarv> berndl: yes! you can infer it from the fact that 'f x == f x' is true for /every function/ in Haskell
12:06:38 <berndl> hpc: an abstract thing like a unicorn?
12:06:53 <hyperisco> berndl, the problem, roughly, is that IO actions let you act on the world, and it would be rather daunting to have a detailed formalism of the whole world
12:07:03 <hpc> in math, "abstract" means you don't know its representation, only the operations you can perform on it
12:07:03 <berndl> Solonarv: So I have to take that as an axiom.
12:07:06 <stilgart> Solonarv: let's say that the question is to check if ghc does its job correctly
12:07:35 <Solonarv> stilgart: in that case, you do the same thing you'd do for any compiler: check the generated code
12:07:43 <stilgart> what dump should we look ?
12:07:46 <hpc> you deal with abstract things all the time, anytime you ever go "i know how to use it and don't care how it works"
12:07:47 <stilgart> which*
12:07:52 <Solonarv> berndl: yes. Just like you take '1 + 1 == 2' as an axiom.
12:08:16 <Solonarv> stilgart: the final binary, assuming you want to check the entire compiler
12:08:29 <hpc> or rather, things that are from your perspective abstract
12:08:34 <berndl> Solonarv: that's not an axiom. That follows from the implementation of + and == on integers
12:08:47 <hyperisco> berndl, so I prefer to think that IO actions as recorded instructions. Say like a recipe. A recipe doesn't demand cooks to prepare a meal, but rather a cook can read the recipe to make a meal.
12:08:58 <hpc> when the definition of the haskell language says "IO is an abstract type", it's saying "this is as deep as you can inspect it at this level of generality"
12:09:07 <stilgart> Solonarv: sure, but is there some intermediate dump that can provide the same information ?
12:09:12 <berndl> stilgart: So I think you're on the right track. We would have to look at the generated code of the compiler to check that I'm not getting trolled.
12:09:15 <hyperisco> berndl, when we construct IO values in Haskell, we're writing the recipe for the computer to follow.
12:09:19 <hpc> and if you want to do something like examine the assembly generated for an IO action
12:09:20 <hyperisco> now that's enough analogy for me for today
12:09:34 <hpc> you have to answer that question with respect to a specific implementation
12:09:55 <Solonarv> stilgart: GHC (and most compilers) use a variety of intermediate representations, but those are /intermediate/; the compiler performs additional steps afterwards
12:09:57 <hpc> and a specific usage of that implementation, because optimizations or just loading it in ghci instead can affect what assembly is generated
12:10:01 <hpc> or /if/ assembly is generated
12:10:27 <hpc> values of type (IO a) might not have any representation at all between being abstract at the language level and being assembly code
12:10:39 <Athas> Has there been any recent work at making parallel Haskell faster/better?
12:10:41 <hpc> they might not show up in the build output at all even
12:10:46 <berndl> So, in conclusion, to figure out if f () == f (), I have to look at the output of the compiler.
12:10:49 <hyperisco> berndl, it doesn't even matter if you look at the generated code. How do you know what you're seeing isn't a lie? Is it just GHC you don't trust? Wouldn't it be reasonable to also not trust your text editor, your computer monitor, and so on?
12:10:57 <stilgart> Solonarv: I know... in fact, I was just wondering which dump (if any) is the first that provides such low-level machine-dependant information
12:11:08 <berndl> hyperisco: one thing at a time.
12:11:10 <hpc> berndl: the haskell language specifies things that must be true for a valid implementation
12:11:19 <hyperisco> and how do you know your CPU wasn't swapped out last night by a technoninja and now it will only execute the BELL instruction!
12:11:24 <hpc> berndl: with those definitions, f () is the same as f (), no matter what f is, all the time
12:11:36 <Solonarv> stilgart: you could use the LLVM backend and inspect the LLVM output
12:11:52 <hpc> berndl: if you want to somehow use this to determine if ghc is a valid implementation of haskell in that respect, you have to use the compiler output
12:12:10 <stilgart> Solonarv: nice idea, thanks
12:12:12 <berndl> hpc: Yep. I agree.
12:12:22 <hpc> (==) is the wrong operation to use for this btw
12:12:37 <hpc> (==) only applies to values of types with an Eq instance
12:12:46 <berndl> True.
12:12:59 <Solonarv> generally you'd use '=' or '===' for "true" equality
12:13:01 <hyperisco> you can't use the output to determine if GHC is a correct compiler for Haskell
12:13:04 <hpc> so f () == f () is only a well-defined /proposition/ for f :: Eq a => () -> a
12:13:21 <hpc> and if it's not true that says the Eq instance is invalid, not the language implementation
12:13:25 <hyperisco> unless you're just trying to prove "there are some programs it compiles correctly"
12:13:34 <hpc> it matters what layer you're talking about here :P
12:13:45 <berndl> hpc: I could make an Eq instance for IO a that always returns True though.
12:14:05 <hpc> you could, and that would say nothing about ghc's correctness as a haskell implementation
12:14:22 <hpc> because (==) is a function and not the kind of equality that's talked about in the language definition
12:14:38 <berndl> Yes.
12:14:59 <monochrom> Yeah I use "=" for mathematical equality, denotational equality, etc.
12:15:22 <hyperisco> and ≡ means "the other equality we need to talk about"
12:15:40 <tauoverpi[m]> DecEq would be nice to have
12:16:48 <berndl> Changing topics a little, I keep reading that Haskell doesn't have null like in other languages, so you can't have null-pointer exceptions. But isn't undefined Haskell's version of null?
12:17:07 <Solonarv> no
12:17:21 <berndl> How so?
12:17:27 <hyperisco> I know what the actual topic is
12:17:37 <Solonarv> 'undefined' is a nicer version of a program that runs forever without ever returning
12:17:56 <Solonarv> you can't exclude such programs if you want a turing-complete language
12:18:09 <hyperisco> it is somewhere in the ether between "I'm skeptical of Haskell" and "I think I have to learn Haskell but would rather find an excuse not to"
12:18:21 <berndl> Solonarv: I don't think. When I call head [], the program dies immediately.
12:18:27 <monochrom> Heh hyperisco.
12:18:38 <Solonarv> you can define 'undefined = undefined' and your programs will mean the exact same thing
12:18:45 <Solonarv> they'll just loop forever, instead of crashing
12:18:52 <tauoverpi[m]> `head []` is partly just a wart of partial functions 
12:18:56 <monochrom> You can write a program to ask "is this pointer the null pointer?".  You can't write a program to ask "is this value undefined?".
12:18:59 <stilgart> @src head
12:18:59 <lambdabot> head (x:_) = x
12:18:59 <lambdabot> head []    = error "Prelude.head: empty list"
12:19:05 <tauoverpi[m]> which shouldn't have been in Prelude but is
12:19:14 <stilgart> it's an "error", not undefined ;)
12:19:16 <berndl> Solonarv: but looping forever is not the same as crashing.
12:19:39 <monochrom> Also, because of FFI, we do have the null pointer.
12:19:51 <hpc> berndl: "crashing" doesn't mean throwing a catchable exception, it means actually terminating the program
12:20:23 <Solonarv> You can't exclude programs that run forever.
12:20:23 <Solonarv> In some cases, a program can figure out "I'm going to run forever" and abort instead.
12:20:23 <Solonarv> Isn't that nicer?
12:20:26 <berndl> hpc: fair enough
12:20:36 <hpc> the program might exit with status 0 (success), or it might system("kill -9 "+ thisProcessPID)
12:21:27 <monochrom> Yes it's nicer.
12:21:35 <Solonarv> % let loop = loop in loop -- see, even (some!) actual infinite loops can be detected
12:21:35 <hpc> anyhoo, haskell's nullable equivalent is Maybe
12:21:40 <yahb> Solonarv: [Timed out]
12:21:46 <berndl> I just bugs me that I can say g :: Int -> Int; g _ = undefined in Haskell.
12:21:57 <monochrom> Plus, they both still satisfy "you don't get the answer you're promised".
12:22:00 <hpc> i think yahb uses threaded runtime
12:22:04 <hpc> > let loop = loop in loop
12:22:07 <lambdabot>  *Exception: <<loop>>
12:22:12 <hyperisco> berndl, well you can always use a total language instead, like Idris.
12:22:22 <hpc> that's a very very specific type of loop detection
12:22:24 <berndl> hyperisco: I use Agda actually
12:22:28 <Solonarv> berndl: that 'g' is still strictly nicer than 'g x = g x'
12:22:40 <berndl> hyperisco: the totality checker is such a bitch though.
12:22:51 <hpc> and it's really cool but requires some ghc knowledge about how thunks are constructed and evaluated in order to learn
12:22:53 <hyperisco> that's why we have undefined
12:22:53 <monochrom> (Fortunately, when I talk about denotational semantics and bottom, I don't commit to "bottom means infinite loop".  Indeed, what infinite loop?  Denotational semantics is not operational semantics.)
12:22:59 <MarcelineVQ> berndl: in what sense?
12:23:08 <hyperisco> berndl, I haven't used Agda. What is so different about IO there?
12:23:22 <MarcelineVQ> Hard to satisfy, slow? just curious
12:23:30 <Solonarv> presumably, it's sometimes hard to prove that a program is total, and you have to jump through a bunch of hoops.
12:23:57 <tauoverpi[m]> Totality checker isn't that bad. At least in Idris
12:24:00 <hpc> it might have changed recently but agda's IO didn't have enough built-in definitions to even really write hello world
12:24:24 <hpc> there was extra stuff you had to write in order to translate between two different IO types and sequence them right
12:24:30 <hyperisco> yeah, like write the program that terminates if all Collatz sequences converge on 1
12:24:33 <hpc> idris is what you want for IO
12:24:45 <berndl> Yes. I try to define a recursive function Nat -> Nat where the argument gets smaller by say dividing by 10 or something, Agda will not let me compile it. 
12:25:01 <hyperisco> a program that terminates if infinite descent is true
12:25:07 <hyperisco> well that shouldn't be so hard
12:25:12 <berndl> dividing by 10 is not structurally recursive.
12:25:41 <monochrom> Maybe you forgot the base case.
12:25:41 <tauoverpi[m]> berndl: It never terminates though
12:25:58 <berndl> Agda's IO stuff is all over the place. I haven't even played with it yet.
12:26:21 <Solonarv> tauoverpi[m]: it does on naturals! (assuming euclidean division, ofc)
12:26:34 <hyperisco> I'll risk a guess and say it is probably as black box as Haskell is about it
12:27:13 <monochrom> I think all languages make I/O a black box because they have to.
12:27:25 <berndl> In Agda, you typically just end up delegating IO to Haskell.
12:27:29 <hpc> because it's better that way too
12:27:58 <monochrom> Some languages make I/O commands "just like functions" but they still boil down to syscalls at which point you still have a black box.
12:28:06 <hpc> i don't think you really want to use a language where you care that stdout is exactly this address in kernel space and this is exactly how you have to access it
12:28:09 <Solonarv> You *can* go with a free-monad approach, but that gets you worse performance and makes it more annoying to add primitives
12:28:45 <tauoverpi[m]> Substructural types make it a bit nicer, still a black box
12:28:51 <hpc> even in C if you ask a programmer how it's implemented they'll just look at you funny
12:28:51 <Solonarv> (with a free-monad approach IO doesn't need to be opaque, though its /execution/ must be)
12:29:12 <Solonarv> Or possibly start talking about assembly
12:29:24 <monochrom> And by the time you get down to Apple II assembly code, memory-mapped I/O and all that, it becomes downright magical.
12:29:47 <monochrom> Like, you read from "the same damn address" ten times and you get ten different answers, like WTH.
12:30:17 <monochrom> And it's Apple II so you can't even pretend "w00t concurrent programming, shared variable".
12:30:28 <clever> monochrom: that even happens on "modern" systems, the rpi has several memory mapped fifo's for talking to the VC4, and the gpio banks are all mmio
12:30:36 <geekosaur> serial ports
12:30:39 <hpc> imagine if every program you had to write worked like https://www.youtube.com/watch?v=vAHXK2wut_I
12:30:48 <geekosaur> also, someone probably did figure a way tomake apple IIs do that
12:31:37 <monochrom> Philosophically or even mathematically, from your program's point of view, beyond the sensors your program and read from, the outside world is a black box.
12:31:38 <geekosaur> commodore superpets could, with some care, iirc; btut hat was even harder because it wasn't the same kind of cpu
12:31:43 <hyperisco> hpc, oh yeah that's how I learned to program when I was six.
12:31:59 <monochrom> s/and read from/can read from/
12:32:06 <clever> hpc: credits warp is one thing, but look at https://youtu.be/eM8Z9e-WoFs?t=430
12:32:31 <clever> hpc: they used the same basic idea, to inject such massive changes, it barely behaves like the same game
12:32:44 <hpc> ah yeah, that one's great
12:32:46 <tauoverpi[m]> Well, there's bedrock for the more magical
12:33:19 <hyperisco> hpc, no wonder I was never able to beat bowser. Geesus.
12:33:45 <hpc> my favorite part of that is where it reads instructions from unmapped memory and the values are whatever the processor wants them to be
12:34:26 <clever> hpc: theres also a gameboy glitch, where you can escape the bounds of the map, and the math to lookup the map tiles is unbounded
12:34:38 <clever> hpc: so you can literally walk around the entire address space, ingame
12:34:41 <MarcelineVQ> you boys might like sethbling mario world videos if you like this sort of thing
12:34:58 <clever> hpc: and if you break any block, it causes a write to that address
12:35:11 <clever> MarcelineVQ: already seen all of them!
12:35:12 <monochrom> What have I done? :)
12:35:36 <hpc> clever: a later tas block did code execution in smw, then rewrote the code to act like mario maker
12:35:49 <hpc> then they hooked it up to chat and chat found another buffer overflow into writing arbitrary memory
12:35:56 <clever> hpc: :D
12:35:59 <hpc> then they messed up the graphics memory in really neat ways
12:36:25 <clever> hpc: another one of the recent tasbot videos i watched, had some other fun code injection
12:36:39 <hpc> all of this is to say, IO is abstract for a really good reason
12:36:52 <clever> hpc: https://www.youtube.com/watch?v=2GtbY1XWGlQ
12:37:44 <clever> hpc: somebody discovered, his twitch chat is re-rendered in html, and wasnt properly escaped
12:37:48 <clever> <script> works...
12:39:55 <monochrom> I love Dijkstra and Wirth and Naur and all the Algol people, but when they thought up the phrase "functions with side effects", this is when Sapir-Whorf is right about a wording that mislead you to think wrong.
12:40:38 * hackage brick 0.41.4 - A declarative terminal user interface library  http://hackage.haskell.org/package/brick-0.41.4 (JonathanDaugherty)
12:40:52 <hyperisco> you might say, their choice of words had side effects
12:41:19 <monochrom> "procedures with return values" doesn't look very different on the surface, but I do believe it would be a big deal over the course of 40 years.
12:41:26 <monochrom> haha hyperisco
12:41:44 <hpc> programmers must be exorcised of their impure thoughts? :D
12:42:53 <tdammers> in all fairness, I doubt any of them realized what impact their words would have 40 years down the road
12:43:11 <hpc> monochrom: it tracks well with so much of math, where getting the definitions right is 90% of the work
12:43:27 <berndl> Speaking of Sapir-Whorf, I think this hypothesis is true when it comes to programming langauges.
12:43:27 <berndl>  
12:44:03 <tdammers> the actual hypothesis, or one of the pop-sci embellishments?
12:44:55 <berndl> The actual hypothesis, but applied to programming languages.
12:44:56 <hyperisco> forgive me Turner for I have sinned
12:45:25 <hpc> forgive my pythagoras, for i have cosined
12:45:36 <berndl> lol
12:45:39 <monochrom> haha
12:45:45 <tdammers> https://en.wikipedia.org/wiki/Linguistic_relativity#Programming_languages apparently you're not the first to think that
12:46:44 <berndl> I see it in my colleagues at work. They're all PHP programmers and when I ask them to solve a problem that can be done trivially with recursion, they can't do and get confused trying to make something with loops.
12:47:09 <tdammers> yes
12:47:18 <tauoverpi[m]> At least give them a stack
12:47:18 <tdammers> although I think something else may be at play there
12:47:34 <Athas> The interesting thing is that I still find recursive thinking useful when working in languages that do not support recursion directly.
12:48:11 <tdammers> namely, that in order to develop an intuition for some concept, it is beneficial to keep the cognitive overhead low while studying it
12:48:39 <berndl> tdammers: haha; good luck doing that with PHP code
12:48:48 <tdammers> writing a recursive function in PHP comes with a lot more accidental complexity and syntactic clutter than doing it in Haskell
12:48:56 <monochrom> Yeah
12:49:10 <tauoverpi[m]> berndl: Can alway cheat https://github.com/edwinb/idris-php
12:49:13 <berndl> tdammers: Indeed.
12:49:30 <berndl> tauoverpi[m]: lol
12:49:50 <hyperisco> but to be fair, PHP has variable variables
12:49:57 <monochrom> haha neat
12:50:21 <hyperisco> "Please, don't ever use this."
12:50:46 <hpc> yeah, all strings are also references to the symbol table
12:50:53 <tdammers> $a = '$a'; eval(str_repeat('$', 1000000) . 'a');
12:50:55 <berndl> hyperisco: says the dev. that can't mantain his own code anymore
12:51:08 <tauoverpi[m]> Well... that goes for a lot of things
12:51:25 <hyperisco> there are times I say that and I just finished programming it
12:52:52 <hyperisco> years ago when I did PHP Q&A, one of the repeat questions was whether it was necessary to quote your strings, and what the difference was
12:53:17 <berndl> The variable variables stuff makes it almost impossible to optimize the interpreter.
12:53:29 <hyperisco> just try to imagine what design decisions lead to that confusion
12:53:54 <migge> I was looking at the source for foldlM and I can not figure out how it works. Can someone help me and put parenthesis in the definition so I can understand which function is called in which order and with which arguments?
12:54:01 <tdammers> I love it how they celebrated "our interpreter now has an AST" as a huge achievement, 20 years into development
12:54:08 <glguy> migge: Which implementation are you looking at?
12:54:11 <hyperisco> tdammers, lmao where is that
12:54:18 <berndl> tdammers: that was quite an achievement actually.
12:54:29 <tdammers> hyperisco: came with the release notes, IIRC it was 5.3 or something
12:54:46 <hyperisco> you used to be unable to index after calling a function due to parsing issues
12:54:54 <tauoverpi[m]> That's hilarious
12:55:00 <hyperisco> f()[0] was a syntax error, is what I'm saying
12:55:15 <tdammers> ooh, that stuff was also hilarious
12:55:25 <tdammers> you could say $f = function () { ... }; $f();
12:55:38 <hpc> i can't wait for the language standard for php to seriously use "Paamayim Nekudotayim" in the grammar without giving a justification
12:55:41 <tdammers> and you could also say $f = function () { ... }; g($f);
12:55:48 <tdammers> but not g(function () { ... })
12:55:53 <glguy> migge: Here's the fully parenthesized version: https://gist.github.com/glguy/88c125ba06b3c5b71559192620cadbea
12:55:54 <migge> glguy: the one from base I think. I used Hoogle to find it.
12:56:36 <migge> glguy: thank you!
12:56:58 <glguy> migge: I generated that with this: https://github.com/glguy/AddParens
12:57:01 <berndl> hpc: I remember when I first say that error and was like WTF?!
12:57:05 --- mode: glguy set +v mzabani
12:57:06 <berndl> *saw
12:57:18 <glguy> migge: So if adding parentheses is useful to you in general, you can run that tool on your own
12:57:29 <tauoverpi[m]> Found it: https://wiki.php.net/rfc/abstract_syntax_tree
12:57:33 <hyperisco> so the reason people were confused about string quoting is because a token such as FOO was assumed to be a constant, and if a constant is undefined when it is used then it becomes defined and is equal to its name as a string
12:58:20 <hyperisco> so programmers would say things like $playerData[PLAYER_NAME] and other programmers would say $playerData['PLAYER_NAME']
12:58:51 <berndl> hyperisco: nowadays the interpret will warn you about that.
12:58:55 <berndl> *interpreter
12:59:00 <hyperisco> oh sure
12:59:12 <hyperisco> at the time you had to modify your php.ini to enable "strict errors" or whatever they called it
13:00:25 <berndl> Yeah.
13:00:38 <hyperisco> right after you disabled "register globals" lol
13:01:00 <crestfallen> hi wondering why I cannot eta reduce the x in line 8. thanks https://paste.ee/p/6reDs
13:01:11 <hyperisco> that wonderful feature where variables encoded in a querystring would automatically get defined globally in your program
13:01:12 <berndl> But hey, it's paying my bills at the moment, until I find an Agda job.
13:01:24 <monochrom> This is why a proud "I don't know theory" guy can do so much harm by adding petty conveniences, penny wise pound foolish.
13:01:51 <MarcelineVQ> crestfallen: Why you yourself can't or whether it's possible?
13:02:05 <crestfallen> I myself
13:02:29 <MarcelineVQ> k then I don't mean to be rude, but no one can possibly answer that question but you
13:02:48 <geekosaur> crestfallen,because thex  on the left is matched with (g x) on the right, not with x
13:02:51 <hyperisco> good bye
13:02:55 <geekosaur> oh
13:03:01 <MarcelineVQ> it'd be like me coming onto #circious and saying "Why can't I juggle?"
13:03:14 <monochrom> It's probably impossible too.
13:03:45 <hyperisco> that's not an eta reduction so lets ask them what their attempt looked like
13:07:03 * hackage pinboard 0.10.0.0 - Access to the Pinboard API  http://hackage.haskell.org/package/pinboard-0.10.0.0 (jonschoning)
13:09:00 <mzabani> Hi everyone! I'm trying to run an action that requires the underlying monad m to instantiate both MonadResource and MonadUnliftIO, but my base monad is Servant's Handler, which is neither of these. Anyone know how handle this?
13:10:15 <alp> mzabani, servant lets you define your handlers in another monad and only later when you want to serve them you tell servant how to go between your monad and Handler. You can pick your monad such that it has instances for both of those classes.
13:10:53 <alp> mzabani, see https://haskell-servant.readthedocs.io/en/latest/tutorial/Server.html#using-another-monad-for-your-handlers and https://haskell-servant.readthedocs.io/en/latest/cookbook/using-custom-monad/UsingCustomMonad.html
13:10:53 <mzabani> alp: nice, I had forgotten about that possibility
13:11:24 <mzabani> just so I learn something, though, if I didn't have that option, there'd be no way to do that?
13:12:02 <mzabani> I mean, Handler instantiates MonadIO, so I should be able to do anything, right?
13:12:46 <alp> mzabani, oh yeah sure, if you can afford to only be able to run IO actions under those conditions, then yes, absolutely.
13:13:46 <mzabani> but I just can't find anything in http://hackage.haskell.org/package/unliftio-core-0.1.2.0/docs/Control-Monad-IO-Unlift.html or https://hackage.haskell.org/package/resourcet-1.2.2/docs/Control-Monad-Trans-Resource.html#v:runResourceT that allows me to do that
13:17:11 <alp> to do what exactly?
13:18:26 <alp> using m = IO should work
13:20:30 --- mode: glguy set +v fen
13:21:03 <fen> why does the Monoid Action class not have a Monoid constraint!?
13:21:03 <fen> https://hackage.haskell.org/package/monoid-extras-0.5/docs/Data-Monoid-Action.html
13:22:01 <mzabani> alp: hmm you're right, forcing m to be IO and using liftIO may help me a lot.. there's still he MonadResource constraint, but this already helps a lot!
13:23:33 <fen> type MonoidAction m s = (Monoid m,Action m s)
13:23:40 <alp> mzabani, oh, then ResourceT IO should work
13:23:46 <fen> type GroupAction m s = (Group m,Action m s)
13:24:05 <alp> and you 'liftIO . runResourceT' it all to bring it back to Handler
13:24:33 <alp> either from the handler's code, or as a "transformation" that brings your handlers defined in ResourceT IO back to Handler.
13:25:02 <mzabani> alp: that's it! thanks a lot!!
13:25:05 <alp> anyway, I think you get the idea now, I'll let you play around with this.
13:25:31 <mzabani> I still have some time to get used to monad transformers, I guess
13:28:55 <alp> heh, they do take some getting used to, definitely
13:30:07 * hackage pinboard 0.10.0.1 - Access to the Pinboard API  http://hackage.haskell.org/package/pinboard-0.10.0.1 (jonschoning)
13:30:12 <alp> it took me quite a bit of time. and figuring things out by looking at lists of instances in haddocks is its own exercise, but that comes quite quickly with practice
13:36:42 <remexre> Is there a way to add a dependency installed OS-wide (but not present in stackage) to a stack project?
13:38:29 <Solonarv> I don't think there's a way to make stack aware of system-installed haskell packages, its whole point is sandboxing
13:38:54 <Solonarv> that said, if you simply want a dep that's not on stackage, you can add it to the 'extra-deps' field in stack.yaml
13:39:20 <remexre> Yeah, the dep wants different versions of a bazillion other things, sadly
13:39:44 <geekosaur> you'd also need to be using system-ghc, not a stack-installed one
13:40:26 <Solonarv> generally speaking though, don't globally install haskell packages
13:40:30 <Solonarv> that way lies cabal hell
13:40:33 * hackage pinboard 0.10.0.2 - Access to the Pinboard API  http://hackage.haskell.org/package/pinboard-0.10.0.2 (jonschoning)
13:40:34 <hpc> remexre: you would specify it in the cabal file for the project
13:40:53 <hpc> remexre: the cabal file is the package definition and contains the canonical dependency information
13:41:03 <hpc> remexre: stack is just the build environment definition
13:41:28 <remexre> hm, okay
13:41:29 <hpc> (assuming this is for something like a C lib)
13:42:10 <monochrom> remexre: A built library are attached to the GHC instance you used to build it.  If you want stack to use a built library (as opposed to building it all over again for example), you now also have to tell stack to use that very instance of GHC involved.
13:42:49 <monochrom> This is known as the stack hell.
13:43:18 <remexre> In this case I have a package in nix.packages in stack.yaml, since nix packages it
13:47:02 <monochrom> The root cause of cabal hell is not global installs.  The root cause is trigger-happy going for newer versions.  You already have say foo-1.1 (global or user, does not matter) and yet cabal still go like "w00t, I see foo-2.0 on hackage, I'll do that" without your explicit order.
13:49:44 <Solonarv> Fair enough. OTOH even if cabal didn't do that there are some issues if you want to upgrade foo, but not bar
13:50:06 <monochrom> And people's "solution" to that is: Five minutes of deleting trigger-happy-"upgrade" code can be saved by 6 months of developing cabal sandboxing.
13:51:05 <sclv> You cam get the problem even if you never run “upgrade”
13:51:52 <sclv> deep dep trees and inconsistent deps among many libs plus the need to keep old code building really do vitiate against a single global package set
13:51:54 <monochrom> That's what my "without your explicit order" is talking about.
13:52:14 <sclv> the old solver tries hard to use installed packages
13:52:20 <sclv> Sometimes you really can’t
13:52:33 <Solonarv> Sandboxed builds are a good idea anyway
13:52:42 <Solonarv> Reproducibility is nice
13:53:39 <remexre> yeah, as far as - base-4.10.1.0
13:53:41 <remexre> - base-4.10.1.0
13:53:47 <remexre> er whoops
13:54:01 <remexre> as far as I can tell, no versions of tensorflow work with stack?
13:57:04 <geekosaur> "not in stackage" doesn't man "doesn't work", it meas "nobody submitted it to be part of the curated base"
13:57:27 <geekosaur> there is extra-deps for such
13:58:25 <remexre> yeah, but eventually you end up needing to replace `base` in extra-deps
13:58:58 <geekosaur> that sonds to em like you're usingt he wrong resolver / wrong ghc version
14:00:23 <hpc> as an aside, because it's pertinent here and relatively few programmers think about it
14:00:34 <hpc> packaging is an entire discipline
14:01:32 <geekosaur> or you are using a package built against aspecific base, therefore with internal inlinings from it, which can't be used with a different build. whic is why I said system-ghc earlier.
14:02:05 <hpc> in this case the stack lts you pick is an abstraction at the level of "programming a build process"
14:02:08 <MarcelineVQ> doens't look like that complicated a deps list to me  https://gist.github.com/MarcelineVQ/501a8f58045a13252f43cff82abc1286
14:02:18 <hpc> and things within that abstraction you should leave to the lts
14:03:03 <remexre> MarcelineVQ: Oh, huh, how were you able to find the resolver version that worked? I keep getting errors
14:03:38 <MarcelineVQ> It told me my base was too high in resolver lts-12.*  so I downgraded a ghc version, list here: https://www.stackage.org/
14:04:02 <MarcelineVQ> *after adding latest tensorflow it told me my
14:04:12 <MarcelineVQ> then I justr plugged in deps it told me to plug in until it was done
14:04:57 <MarcelineVQ> it can actually do this itself   stack solver --update-config      but cabal-install is borked on my system so I didn't do thats
14:05:35 <remexre> Huh, I'm getting:
14:05:37 <remexre> Received ExitFailure 1 when running
14:05:39 <remexre> Raw command: /home/nathan/.stack/programs/x86_64-linux-nix/ghc-tinfo6-8.2.2.temp/ghc-8.2.2/configure --prefix=/home/nathan/.stack/programs/x86_64-linux-nix/ghc-tinfo6-8.2.2/
14:06:25 * hackage monopati 0.1.4 - Well-typed paths  http://hackage.haskell.org/package/monopati-0.1.4 (iokasimovmt)
14:07:37 <MarcelineVQ> dunno about that, doesn't sound like a dependency issue at least, though that doesn't look like a fun error
14:07:45 <remexre> eugh
14:07:48 <remexre> aight
14:10:34 <MarcelineVQ> my usual mo on errors like that is to upgrade stack and try again, to a git version
14:12:51 <monochrom> Rabbit hole.
14:13:19 <sm> remexre: tried --verbose or --debug or something ?
14:13:34 <sm> guess: you need the C lib providing tinfo 
14:15:11 <remexre> I think I have that, but I did `stack clean` and then it worked
14:15:16 <remexre> or, is working
14:23:22 <ondrejs> hello
14:44:33 * hackage stratosphere 0.28.0 - EDSL for AWS CloudFormation  http://hackage.haskell.org/package/stratosphere-0.28.0 (jdreaver)
15:36:17 <Axman6> @pl  (\x xs -> (if null xs then g x else f x): xs)
15:36:17 <lambdabot> join . ((:) .) . ap (flip . flip (if' . null) . g) f
15:36:25 <Axman6> hmm, needs more bool
15:40:37 <ondrejs> I am using servant-auth, created a login form page, send in, get "set cookie" jwt, xsrf tokens back and then nothing happens -- my browser does not use them when it sends requests. Can anyone advise how to make it please?
15:42:52 <ondrejs> I send 302 redirect together with the cookies.
15:44:58 <amx> well, does it set them?
15:45:16 <amx> can check e.g. in the Storage tab in firefox
15:47:24 <ondrejs> I noticed one problem, it adds the "Secure" option. And I am just running plain http on localhost.
15:48:12 <amx> yes that is a problem
15:49:47 <hpc> giving it a self-signed cert is probably best
15:51:57 <ondrejs> that's a good point, I'll give that a go once I figure out this logging in
15:57:47 <ondrejs> Now the cookies are sent to the server, however, servant-auth does not let me through to the protected part. 
16:04:05 <droplet> what's a good way of getting some ui (currently gloss, but i'm flexible) in haskell to show math, latex-style? 
16:08:32 <koz_> droplet: If you can render it into Unicode, you can just have gloss display it as text. Pandoc may be of some use here, but I think there might be LaTeX-specific options.
16:09:31 <hpc> the latex package does that
16:09:42 <koz_> droplet: There ya go then.
16:09:52 <koz_> Also, hpc, do you deal with high-performance computing by any chance?
16:10:03 <hpc> latex is more than just a character set though, it depends on what you're using it for
16:10:06 --- mode: glguy set +v fen
16:10:18 <hpc> koz_: i wish
16:10:25 <hpc> nor haskell program coverage ;)
16:10:34 <koz_> Your nick makes me think of high-performance computing every time I see it.
16:10:46 <hpc> you can find the expansion of my nick somewhere on hackage
16:10:49 <hpc> it's a scavenger hunt
16:10:50 <hpc> :D
16:11:05 <fen> any ideas how to make a traversable instance for a difference list?
16:11:17 <MarcelineVQ> hpc: mostly I confuse it with hvr hehe
16:11:38 <hpc> that's the nice thing about being the one with the confusing nick
16:11:44 <hpc> i never make that mistake
16:13:19 <fen> ok, more specifically, a difference list of a traversable container 
16:14:05 <fen> type Difference f = forall a. Traversable f => [f a -> f a]
16:14:26 <koz_> @pl \x -> (coerce k, coerce x)
16:14:26 <lambdabot> (,) (coerce k) . coerce
16:14:37 <koz_> Hmm, with TupleSections, that's even nicer.
16:14:42 <fen> is that right? with the forall a. in a type synonym traversable instance?
16:15:11 <fen> or its got a newtype wrapper;
16:15:38 <fen> data Difference f a = Difference (Traversable f => [f a -> f a])
16:17:46 <fen> the problems seem to be; 1. its backwards. 2. there is some kind of problem with acting on each value in the list that is because it needs a "headMap" style thing which seems really clumsy
16:18:13 <hpc> a difference list of xs is essentially (\ys -> ys ++ xs)
16:18:31 <fen> like, its not easy to get at the `a' to apply the applicative returning function (Kliesli)
16:18:36 <hpc> given that function you want to construct a new function that is (\ys -> ys ++ someOperation xs)
16:18:54 <hpc> and you can get xs out of that first function by applying it to []
16:18:56 <fen> :t (\ys -> ys ++ [])
16:18:57 <lambdabot> [a] -> [a]
16:19:01 <hpc> that should be a good start?
16:19:05 <fen> yeah thats the right type
16:19:27 <hpc> try and think about it without the newtype wrappings first, it reduces the syntactic noise a bit
16:19:53 <hpc> and then you can add back stuff as needed to make the code apply to your type
16:19:55 <fen> yeah, and list is a good example of a traversable container, ok
16:21:35 <fen> > foldl (flip (.)) id [([1]++)] []
16:21:37 <lambdabot>  [1]
16:22:05 <fen> but thats not really the kind of difference list being used here... it should be 1: not [1]++
16:22:24 <fen> > foldl (flip (.)) id [(1:),(2:)] []
16:22:26 <lambdabot>  [2,1]
16:22:53 <mniip> [1]++ is the same function as (1:)
16:23:13 <fen> yeah, but this is explicitly that the difference lists should have only one element 
16:23:49 <fen> so that for traversal they just have one value to get at, and the problem is even difficult then
16:24:17 <fen> as it needs to be like, applied to [], and then turned back into a difference list and applied to the rest of the traversal
16:24:23 <tauoverpi[m]> In this case, isn't Endo better?
16:24:36 <fen> what, for the (:) thing?
16:24:53 <fen> what case is Endo better in?
16:25:29 <fen> :t uncons
16:25:30 <lambdabot> [a] -> Maybe (a, [a])
16:25:46 <fen> :t unfold
16:25:47 <lambdabot> error:
16:25:47 <lambdabot>     • Variable not in scope: unfold
16:25:47 <lambdabot>     • Perhaps you meant one of these:
16:25:49 <fen> :t unfoldr
16:25:50 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
16:26:33 <tauoverpi[m]> You can use Endo as a generalization of a difference list
16:26:39 <fen> :t unfoldr ((\(a,b)->(a:,b)) . uncons) 
16:26:40 <lambdabot> error:
16:26:40 <lambdabot>     A section must be enclosed in parentheses thus: (a :)
16:26:46 <fen> :t unfoldr ((\(a,b)->((a:),b)) . uncons) 
16:26:48 <lambdabot> error:
16:26:48 <lambdabot>     • Couldn't match type ‘([a0] -> [a0], b0)’ with ‘Maybe (a1, [a])’
16:26:48 <lambdabot>       Expected type: [a] -> Maybe (a1, [a])
16:26:59 <fen> :t unfoldr (fmap (\(a,b)->((a:),b)) . uncons) 
16:27:00 <lambdabot> [a] -> [[a] -> [a]]
16:27:05 <fen> sorry
16:27:34 <fen> > foldl (flip (.)) id $ unfoldr (fmap (\(a,b)->((a:),b)) . uncons) [1,2,3]
16:27:36 <lambdabot>  <[Integer] -> [Integer]>
16:27:48 <fen> > foldl (flip (.)) id $ unfoldr (fmap (\(a,b)->((a:),b)) . uncons) [1,2,3] []
16:27:50 <lambdabot>  error:
16:27:50 <lambdabot>      • Couldn't match expected type ‘[a0] -> [b -> b]’
16:27:50 <lambdabot>                    with actual type ‘[[Integer] -> [Integer]]’
16:27:54 <fen> argh!
16:28:06 <fen> ok, ill go talk to lambdabot
16:28:13 <MarcelineVQ> ghci is faster
16:28:29 <MarcelineVQ> ghcid and a source file is faster still
16:29:59 <ondrejs> so if I curl into my site with sending the X-XSRF-TOKEN header I get my secret data, if I login (get XSRF-TOKEN cookie and then redirect to the page with my secret data), servant-auth does not recognize me :/
16:30:56 <mniip> 11/23/2018 [03:22:50] <fen> yeah, but this is explicitly that the difference lists should have only one element 
16:30:57 <mniip> what
16:31:28 <fen> the differences contained in the list of differences are only one element differences
16:31:46 <hpc> the composition of them is a full list though
16:31:51 <fen> ...
16:32:07 <fen> true
16:32:15 <tauoverpi[m]> It's only one traversal
16:32:21 <tauoverpi[m]> so it doesn't really matter
16:35:16 <fen> > foldl (flip (.)) id (unfoldr (fmap (\(a,b)->((a:),b)) . uncons) [1,2,3]) []
16:35:19 <lambdabot>  [3,2,1]
16:35:50 <fen> > foldr (.) id (unfoldr (fmap (\(a,b)->((a:),b)) . uncons) [1,2,3]) []
16:35:52 <lambdabot>  [1,2,3]
16:37:11 <hpc> always be right-folding :D
16:37:53 --- mode: glguy set +v fen_
16:39:52 <fen_> @let toDifferences = unfoldr (fmap (\(a,b)->((a:),b)) . uncons)
16:39:54 <lambdabot>  Defined.
16:40:01 <fen_> @let fromDifferences x = foldr ((.)) id x []
16:40:03 <lambdabot>  Defined.
16:40:20 <fen_> > fromDifferences . toDifferences [1,2,3]
16:40:23 <lambdabot>  error:
16:40:23 <lambdabot>      • Couldn't match expected type ‘a -> [[a1] -> [a1]]’
16:40:23 <lambdabot>                    with actual type ‘[[Integer] -> [Integer]]’
16:40:53 <fen_> > (fromDifferences . toDifferences) [1,2,3]
16:40:56 <lambdabot>  [1,2,3]
16:41:12 <fen_> :t toDifferences 
16:41:13 <lambdabot> [a] -> [[a] -> [a]]
16:41:28 <fen_> ok?
16:41:48 <MarcelineVQ> :t map (:)
16:41:49 <lambdabot> [a] -> [[a] -> [a]]
16:42:36 <fen_> ok, lists are so simple that works
16:44:29 <fen_> normally for shaped containers `getiS :: f a -> ((i,a),Maybe (f a))' replaces uncons and `seti :: (i,a) -> f a -> f a' replaces (:)
16:45:09 <fen_> and `i' allows the shape to be retained by the difference list
16:45:38 <fen_> which makes the whole, getting at the `a' value for traverse, even worse!
16:46:46 <fen_> and really, it should have flipped it backwards...
16:47:06 <fen_> hmm, maybe not
16:47:23 <fen_> thats an artefact from using zippers of the form ([a],[a])
16:47:38 <fen_> ok, cool thats the first problem sorted!
16:48:55 <fen_> traverse :: Applicative f => (a -> f b) -> [[a] -> [a]] -> f ([[b]->[b]])
16:49:52 <fen_> ah, unfoldr is written nicely using build
16:50:26 <fen_> it doesnt just cons the most recently retrieved value to the front of the difference list
16:50:39 <MarcelineVQ> that traverse looks off, is that a sig ghci gave you?
16:50:57 <fen_> huh, its for difference lists right?
16:51:16 <MarcelineVQ> the type vars don't line up in my tiny brain
16:51:37 <fen_> :t traverse
16:51:38 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
16:51:52 <fen_> f = \a -> [[a]->[a]]
16:52:03 <fen_> s/f/t
16:53:25 <fen_> :t \(x:xs) -> pure (x:)
16:53:26 <lambdabot> Applicative f => [a] -> f ([a] -> [a])
16:54:20 <fen_> help!
16:56:08 <fen_> :t \(x:xs) -> pure ((head (x [])):)
16:56:09 <lambdabot> Applicative f => [[a1] -> [a2]] -> f ([a2] -> [a2])
16:56:52 <fen_> it seems a waste to apply the difference to the empty list and then use head to get at the value `a'
16:58:32 <fen_> like, thats just an example of how traverse *could* be implemented, but is there another way which does not have this problem?
16:59:45 <fen_> it seems equivalently expensive as completely collapsing the difference list, traversing over the result, and then reconstructing it with toDifference...
17:00:10 <fen_> which is another viable, but wasteful, implementation 
17:01:03 <fen_> :t \ f xs -> (toDifference . traverse f . fromDifference)
17:01:04 <lambdabot> error:
17:01:04 <lambdabot>     • Variable not in scope: toDifference :: f [b] -> c
17:01:05 <lambdabot>     • Perhaps you meant one of these:
17:01:11 <fen_> :t \ f xs -> (toDifferences . traverse f . fromDifferences)
17:01:12 <lambdabot> Foldable t => (a -> [b]) -> p -> t ([a] -> [a]) -> [[[b]] -> [[b]]]
17:01:23 <fen_> :t \ f xs -> (fmap toDifferences . traverse f . fromDifferences)
17:01:25 <lambdabot> (Foldable t, Applicative f) => (a1 -> f a2) -> p -> t ([a1] -> [a1]) -> f [[a2] -> [a2]]
17:02:38 <MarcelineVQ> what's the problem being solved?
17:03:01 <fen_> how to write a traversable instance for difference list that is not so wasteful 
17:03:15 <MarcelineVQ> which difference list?
17:03:27 <fen_> the result of toDifferences
17:03:34 <fen_> :t toDifferences
17:03:35 <lambdabot> [a] -> [[a] -> [a]]
17:04:33 <fen_> which is just map (:) in the case of specialising a general difference list `[f a -> f a]' by setting f = []
17:04:59 <MarcelineVQ> No like, what datastructure is this
17:05:31 <fen_> type DifferenceList f a = [f a -> f a]
17:06:02 <droplet> koz_ hpc: thanks!
17:08:20 <fen_> maybe there is some way of fusing up the (fmap toDifferences . traverse f . fromDifferences) ?
17:09:51 <fen_> which would seem easier if it were a fold in the middle rather than a traverse, as then build/fold fusion might work 
17:10:22 <koz_> Wouldn't this just be traverse (f . toDifferences) . fromDifferences?
17:10:25 <koz_> Or am I missing something?
17:10:32 <fen_> something tells me this might not be possible as foldMapDefault is slower for lists than its explicit implementation 
17:11:07 <fen_> koz_ no, the f has to be applied to each `a' and then the list rebuilt within the traversal
17:11:13 <nolrai> What package should I use to get the Profunctor class?
17:11:20 <koz_> nolrai: profunctors I think.
17:11:31 <koz_> http://hackage.haskell.org/package/profunctors
17:11:37 <fen_> :t (pure (1:)) <*>
17:11:38 <lambdabot> error:
17:11:38 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
17:11:46 <fen_> :t ((pure (1:)) <*>)
17:11:47 <lambdabot> (Num a, Applicative f) => f [a] -> f [a]
17:12:02 <fen_> hmm, that might not be the right thinf
17:12:14 <nolrai> Thanks!
17:14:41 <fen_> :t \f = foldr (\x ys -> liftA2 (:) (f x) ys) (pure [])
17:14:42 <lambdabot> error:
17:14:42 <lambdabot>     parse error on input ‘=’
17:14:42 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
17:14:49 <fen_> :t \f -> foldr (\x ys -> liftA2 (:) (f x) ys) (pure [])
17:14:50 <lambdabot> (Applicative f, Foldable t1) => (t2 -> f a) -> t1 t2 -> f [a]
17:15:24 <tauoverpi[m]> Could you do this in GHCi?
17:15:24 <fen_> :t (\x ys -> liftA2 (:) (pure x) ys)
17:15:27 <lambdabot> Applicative f => a -> f [a] -> f [a]
17:16:00 <koz_> Or in a PM to lambdabot.
17:16:03 <koz_> Either option works.
17:16:21 <fen_> oh, you dont need the traversable instance of list explaining koz_ ?
17:16:29 <MarcelineVQ> More fundamentally, I don't even know how to write a functor for   type DifferenceList f a = [f a -> f a]
17:18:07 <MarcelineVQ> Anyone know if that's possible? I'm still unsure about recognizing that from the tyvar position.  say for  newtype DifferenceList f a = DiffList [f a -> f a]
17:20:10 <nolrai> well you have an extra "[" and "]" in your definition, Marceline.
17:20:25 <dmwit> MarcelineVQ: Make it even simpler. `newtype DList a = DList ([a] -> [a])`.
17:20:31 <dmwit> MarcelineVQ: Even so it's not clear you can do an fmap.
17:20:43 <koz_> MarcelineVQ: f a -> f a is a special Endo, and I _believe_ Endo is an invariant functor.
17:20:53 <koz_> (but not a Functor)
17:20:58 <MarcelineVQ> nolrai: Extra compared to the non-newtype version fen_ gave?
17:21:54 <tauoverpi[m]> You can fmap but must convert to a list first
17:22:05 <tauoverpi[m]> then back to endo
17:22:10 <tauoverpi[m]> or dlist
17:22:17 <nolrai> Well what ever fen_ wrote, your first two are lists of difference lists, not difference lists.
17:22:35 <dmwit> tauoverpi[m]: I see. But then I suppose you must demand some invariants of the DList.
17:22:50 <mniip> difference lists are only functors if you hide the data constructor and maintain the invariant
17:22:51 <dmwit> tauoverpi[m]: e.g. that it is semantically `(xs++)` for some `xs`
17:23:00 <mniip> the type [a] -> [a] itself is not a functor
17:23:03 <MarcelineVQ> I'm fine with that, the name isn't important to my question, I perhaps should have munged it. Thanks for your responses
17:23:42 <dmwit> tauoverpi[m]: I guess a natural next question is what invariants fen is preserving. =)
17:24:14 <fen_> ok
17:24:26 <fen_> well, its not ++ its (:) in this case
17:25:13 <nolrai> But then thats just list isn't it?
17:25:26 <fen_> and to generalise to arbitrary f as fas as possible the constraints are that it has geti :: (f a->((i,a),f a)) and seti :: (((i,a),f a)->f a)
17:26:23 <fen_> or the safe variants getiS :: (f a->((i,a),Maybe (f a))) and setiS :: (((i,a),Maybe (f a))->f a)
17:26:39 <fen_> to compare with;
17:26:43 <fen_> :t uncons
17:26:44 <lambdabot> [a] -> Maybe (a, [a])
17:26:46 <fen_> for lists
17:27:10 <fen_> oh, the Maybe is there because it has an Empty constructor []
17:27:25 <fen_> the safe versions above work for NonEmpty shaped containers
17:27:48 <nolrai> Are you sure geti shouldn't have type "fa -> i -> (a, f a)"?
17:28:32 <fen_> if they have Empty constructors its getiS' :: (f a->Maybe ((i,a),(f a))) and setiS' :: (Maybe ((i,a),(f a)) -> f a)
17:29:19 <fen_> nolrai: its nicer curried as then it has the same form for seti
17:29:44 <nolrai> fen_: why is the index an output of your get's?
17:30:28 <fen_> arbitrary generalisations can be encoded in an additional parameter, it allows for example for a "shaped" container to be sequentially deconstructed and reconstructed
17:31:08 <fen_> it embodies the "first in first out" way of representing a large class of traversable containers
17:31:50 <fen_> these traversable containers have a resulting difference list representation, in much the same way as lists do
17:31:57 <ondrejs> I finally made my auth with servant-auth-server work by configuring "xsrfExcludeGet = True" but this isn't described anywhere and doesn't exactly scream secure but I guess the actual user session is protected by JWT cookie so it seems fine(?)
17:32:48 <fen_> for a list, the head value it unconsed from the tail, has cons partially applied to it, and wrapped up in the applicative 
17:33:07 <nolrai> fen_: sorry but I still don't get what "i" is supposed to be?
17:33:32 <fen_> this holds too for the version where `i' which encodes the shape of the container, with a partially applied seti
17:34:48 <nolrai> Fen: So i encodes a shape of somesort?
17:35:35 <fen_> yeah
17:36:12 <fen_> traversables such as trees can then be sequentially deconstructed and have a difference representation
17:37:34 <fen_> @let differenceT = undefined :: Applicative g => (a -> g b) -> ((f a) -> Maybe (f a ,(g (f b -> f b))))
17:37:35 <lambdabot>  Defined.
17:38:21 <fen_> @let loop f s = maybe [] (\(a,s') -> a : loop f s') (f s)
17:38:22 <lambdabot>  .L.hs:166:39: error:
17:38:22 <lambdabot>      Ambiguous occurrence ‘loop’
17:38:22 <lambdabot>      It could refer to either ‘Control.Arrow.loop’,
17:38:31 <fen_> @let loop' f s = maybe [] (\(a,s') -> a : loop' f s') (f s)
17:38:33 <lambdabot>  Defined.
17:39:02 <fen_> :t foldl' (liftA2 (.)) (pure id) (loop' (differenceT f) xs) <*> (pure empty)
17:39:03 <lambdabot> error:
17:39:03 <lambdabot>     • Variable not in scope: xs :: f (f b -> f b)
17:39:03 <lambdabot>     • Perhaps you meant one of these:
17:39:15 <fen_> :t \ xs -> foldl (liftA2 (.)) (pure id) (loop' (differenceT f) xs) <*> (pure empty)
17:39:17 <lambdabot> (Alternative f, FromExpr (f b), Typeable b, Typeable f) => f (f b -> f b) -> f (f b)
17:39:22 <fen_> argh!
17:40:21 <fen_> :t \ xs -> foldl (liftA2 (.)) (pure id) (loop' (differenceT pure) xs) <*> (pure empty)
17:40:22 <lambdabot> error:
17:40:22 <lambdabot>     • Occurs check: cannot construct the infinite type: a ~ f a -> f a
17:40:22 <lambdabot>       Expected type: f (f (f a -> f a) -> f (f a -> f a))
17:40:28 <fen_> oh sorry
17:41:22 <fen_> (lambdabot query isnt working btw)
17:41:57 <ondrejs> How do I make stack get package from a directory I give it rather than stack, please?
17:42:31 <nolrai> Put the path in the stack.yamal file.
17:42:48 <JosephFerano> Hi, I'm tryng to setup my haskell dev environment for the first time and I'm getting the following error
17:42:50 <JosephFerano> https://paste.ofcode.org/Yt4JCqjRqFypY9S3Viv39C
17:43:03 <JosephFerano> I googled but the solutions I've found haven't helped
17:43:15 <JosephFerano> I would appreciate the help
17:43:40 <ondrejs> nolrai: oh, thanks, there's a special docs for the yaml file!
17:44:13 <ondrejs> JosephFerano: how are you setting up your haskell dev env?
17:44:18 <nolrai> JosephFerano, have you modified Licence.hs at all?
17:44:52 <JosephFerano> I installed stuff through apt-get on ubuntu, that's my first mistake, let me get an updated version of ghc
17:45:24 <dmwit> What command did you run to get this error?
17:45:30 <JosephFerano> ghc-mod boot
17:45:35 <nolrai> fen_; I can see what your goal is, but I can't quite understand it well enough to tell if your current path makes sense.
17:45:38 <JosephFerano> But other ghc-mod commands fail as well
17:45:47 <JosephFerano> Also, no, I haven't modified Licence.hs, I wasn't aware I was supposed to
17:46:05 <nolrai> You arent.
17:47:49 <fen_> nolrai: here is the implementation of traverse for Structured containers, those supporting a Difference instance given by a default https://bpaste.net/show/db26db225e3e
17:50:24 <fen_> sorry thats not quite complete, try this instead; https://bpaste.net/show/38c60b4015da
17:53:50 <fen_> and for one that actually compiles! https://bpaste.net/show/ba3031a35688
17:55:38 <nolrai> fen_: thanks!
17:56:34 <JosephFerano> Ok, I installed ghc 8.6.2 but the problem persists
17:56:39 <JosephFerano> :(
17:57:09 <fen_> anyway, constructing arbitrary traversable instances for shaped containers this way is fine, but there is still a problem with trying to traverse over the difference lists themselfs, using nested difference Zippers there may be many such difference lists all around the place and they needto be traversed over without having to rewind them and then renavigate them to location
17:57:45 <fen_> (basically the difference list Traversable instance is needed for the Zipper traversable instance)
18:01:08 <fen_> maybe there is a way to do it where the traverse kicks in *when* the zipper is rewound...
18:02:59 <fen_> but thats not a traversable instance for Difference lists...
18:05:25 <fen_> oh yeah! thats the point of the differenceT function of the class Difference. it uses the geti + seti and the applicative can act on the value as it is retrieved 
18:05:55 <fen_> maybe there is a way to kind of leave this open with a way to cram in more applicatives...
18:06:05 <fen_> if that makes any sense...
18:09:37 <nolrai> Is there a typeclass for types with 'maps' of type "(a -> b) -> (b -> a) -> T a -> T b"?
18:09:53 <fen_> its not over normal difference lists anymore. they are `(Traversable t,Applicative f) => [f (t a -> t a)]'
18:10:15 <fen_> nolrai: what!?
18:10:24 <fen_> whats that (b -> a) doing?
18:11:13 <MarcelineVQ> nolrai: https://hackage.haskell.org/package/invariant-0.5.1/docs/Data-Functor-Invariant.html
18:13:54 <MarcelineVQ> JosephFerano: afaik ghc-mod isn't compatable with ghc 8.2+  additionally ghc-mod is sensitive to ghc and Cabal versions, it tends to only work when the versions used to build ghc-mod are the same as those of the project it's being used in.
18:14:31 <nolrai> MarcelineVQ: thanks, Its funny I almost called my ?map 'xmap'. :)
18:14:32 <MarcelineVQ> there is a newer ghc-mod here  https://github.com/alanz/ghc-mod/tree/ghc-8.4-hie  and a newer  https://github.com/alanz/cabal-helper/tree/master  that it may require here, but I have used neither so I can't comfirm
18:14:54 <MarcelineVQ> some data on the subject https://github.com/DanielG/ghc-mod/issues/931
18:15:24 <MarcelineVQ> nolrai: What would you use this typeclass for?
18:15:39 <JosephFerano> Ok, thanks MarcelineVQ 
18:16:16 <fen_> looks like coerce to me
18:19:12 <MarcelineVQ> nolrai: oh that's cute, the http://comonad.com/reader/2008/rotten-bananas/ article linked in the docs calls it xmap, were you referencing that a moment ago?
18:19:59 <nolrai> Yep.
18:21:48 <nolrai> I don't really need the typeclass, but I have two types that are in it, and I want to define one of their' xmaps in terms of the other.
18:22:25 <nolrai> And maybe something else from the package will be useful in the future.
18:23:33 <JosephFerano> MarcelineVQ: What's odd is that I was using 8.0 before installing 8.6 and I was getting the same error
18:24:38 <fen_> boxes go bananas...
18:25:17 <MarcelineVQ> the Cabal library version matters as well which is surely part of the issue. What sort of project management are you using, cabal-insall? stack?
18:25:28 <JosephFerano> I installed both
18:25:36 <JosephFerano> Should I pick one over the other?
18:26:40 <Arahael> JosephFerano: Holy war there, apparently. :)  I tend to go with stack.
18:26:50 <JosephFerano> I see
18:26:57 * Arahael barely knows what he's doing, though.
18:27:03 <MarcelineVQ> You should get a feel for which you prefer but they're not so complicated that a person can't learn both. They both use .cabal files as their basis
18:28:18 <MarcelineVQ> I was just curious, if you're just starting out then diagnosing tooling issues isn't particular fun use of time. What I would recommend is trying just ghci for now, or using ghcid, until you're more comfortable
18:28:42 <fen_> no fmap!? hardly going to support traverse then...
18:28:43 <MarcelineVQ> ghcid is ghci but it auto-reloads and typechecks your source files as you change them
18:28:45 <fen_> rrg
18:29:33 <fen_> somthing about continuations though. they might allow more applicatives to go in
18:30:01 <JosephFerano> Let me try those
18:30:21 <fen_> might be a natural transformation? can (Applicative f,Applicative g) => f (g a) be written (Applicative h) => h a ?
18:30:23 <Arahael> MarcelineVQ: That was infact, why I went with stack. :)
18:30:34 <fen_> i.e. does two nested Applicatives make an Apllicative?
18:30:41 <Arahael> MarcelineVQ: As even getting a sensible Haskell installation was tricky for me at the time.
18:31:11 <nolrai> fen_: Yes they do. Its one of their big advantages over monads.
18:31:33 <nolrai> Or rather of Applicative over Monad.
18:32:08 <fen_> then maybe some of this exponential trickery or continuations could allow the Applicative of DifferenceT to be modified, acting as a second traversal, and serve as a traversable instance for `(Applicative f,Traversable t) => [f (t a -> t a)]'
18:32:51 <fen_> (basically, wanting to change that f to some other applicative)
18:33:38 <fen_> thought it might have to be of some crazy other type to allow these extra applicatives to be inserted
18:36:21 <fen_> could the `f' commute with the [] and back inexpensively? 
18:38:05 <fen_> basically this kind of applicative difference list is half way to traversal itself. it is used to suspend a traversal that is turning t a into f (t a)
18:38:50 <fen_> so it would do instead of making a legit traversable instance for it, just to be able to change the f into another applicative
18:39:36 <fen_> basically, t a is trivially traversable if it can implement differenceT which unfolds to give that kind of difference list
18:39:52 <JosephFerano> MarcelineVQ: Switched to intero-mode in emacs and it's working just great
18:41:16 <fen_> the problem seems to make most sense thought of as trying to traverse over something thats only halfway through a traversal!
18:41:24 <fen_> :-o
18:42:18 <JosephFerano> ghcid is also available for emacs, but what would be the difference at that point?
18:42:55 <MarcelineVQ> JosephFerano: great! if you find you have issues with intero at some point you can try out dante, it's similar but doesn't rely on stack (but can make use of it), and doesn't need an intero executable.
18:43:20 <fen_> argh! that makes it seem like for a normal difference list, turning it from [t a -> t a] into [f (t a -> t a)] is as good as a traversal instance
18:43:23 <rotaerk> I like ghcid because it's reliable
18:43:24 <fen_> thats so confusing 
18:43:44 <MarcelineVQ> JosephFerano: ghcid isn't for flychecking specific parts of code or getting code-completions, etc, it will check your whole source file for compilation errors
18:43:47 <JosephFerano> Well, I'm just going to get back to the book, I've already wasted enough time setting haskell up :/
18:43:57 <JosephFerano> Ah I see
18:44:01 <MarcelineVQ> But it does that very reliably
18:44:25 <fen_> its just map!?
18:44:36 <fen_> omg g2g
18:44:53 <MarcelineVQ> What an odd fellow.
18:45:30 <rotaerk> he's the White Rabbit
18:47:03 <nolrai> I don't really like sweaty raves, so I think I'll stay Mr. Anderson.
18:47:32 <rotaerk> ..
19:28:55 <amosbird> Hello, can I say a language is turing complete if it supports conditional branching, looping and storage variables ?
19:34:34 * hackage egison-tutorial 3.7.14 - A tutorial program for the Egison programming language  http://hackage.haskell.org/package/egison-tutorial-3.7.14 (SatoshiEgi)
19:40:15 <mniip> amosbird, can you emulate an arbitrary turing machine?
19:40:40 <mniip> with an arbitrarily large state transition graph and an arbitrarily large tape
19:49:46 <amosbird> "an arbitrarily large state transition graph and an arbitrarily large tape" is that the sufficient and necessary condition ?
19:58:07 <mniip> amosbird, pretty much yeah
19:58:26 <mniip> if you can then, any language decided by a TM can be decided by your computation system as you can emulate the TM
19:59:03 <mniip> the other side of the equivalence is whether your system can be emulated on a TM
19:59:24 <byorgey> amosbird: what kind of looping do you have?  If you have loops that can iterate an arbitrary number of times based on a boolean condition, then it sounds like yes, such a language would be Turing complete
20:00:00 <mniip> you definitely need an unbounded amount of memory
20:00:13 <byorgey> amosbird: on the other hand if you have variables, conditional branching, but only "repeat" loops (which repeat some fixed number of times based on a numeric expression), it is easy to show that such programs will always terminate and hence the language can't be Turing complete
20:00:18 <mniip> a bounded amount of memory results in an exponential but still bounded amount of possible states
20:00:39 <mniip> which means you can't decide any languages with a larger amount of myhill-nerode classes
20:00:41 <mniip> for example
20:00:58 <amosbird> byorgey: great
20:03:41 <byorgey> amosbird: although mniip makes a good point, if you only have the ability to make a finite number of variables in a program, and the variables have only a finite amount of storage space, then it's not going to be Turing complete
20:04:32 <byorgey> but it would become Turing complete if either (1) variables can hold an unbounded amount of information, e.g. they hold arbitrary-size Integer values, or (2) the language has some way to allocate memory dynamically
20:29:33 * hackage openapi-petstore 0.0.3.0 - Auto-generated openapi-petstore API Client  http://hackage.haskell.org/package/openapi-petstore-0.0.3.0 (jonschoning)
21:02:50 <dmj`> Is there a way to get haddock to fail with exitFailure if documentation coverage isn't 100%
21:03:31 <koz_> Does Haskell have a log2 function anyplace?
21:03:45 <koz_> (not an _integer_ log2)
21:05:00 <MarcelineVQ> koz_: does logBase help?
21:05:25 <koz_> MarcelineVQ: So log2 = logBase 2.0 ?
21:06:05 <MarcelineVQ> I don't actually know
21:06:15 <koz_> > logBase 2.0 16.0
21:06:18 <lambdabot>  4.0
21:06:21 <koz_> Appears legit.
21:09:41 <MarcelineVQ> fwiw  logBase seems to be  log x / log y
21:10:16 <MarcelineVQ> er log y / log x
21:10:24 <koz_> Yeah, log laws for the win.
21:27:37 <Axman6> > logBase 10 10000
21:27:38 <lambdabot>  4.0
21:27:41 <Axman6> > logBase 10 100000
21:27:43 <lambdabot>  5.0
21:27:47 <Axman6> > logBase 10 1000000
21:27:49 <lambdabot>  5.999999999999999
21:27:52 <Axman6> :(
21:28:00 <Axman6> that broke one of my libraries
21:28:45 <MarcelineVQ> At least you know that :X
21:29:00 <koz_> Yay floats.
21:29:12 <MarcelineVQ> Think of how many people don't know their libraries are broken, it's at least 20 for sure.
21:29:18 <Axman6> I blame inflation
21:30:38 <MarcelineVQ> What was your solution? ceiling?
21:31:35 <harpocrates> dmj`: No, but it wouldn't be hard to add such an option.
21:32:24 <harpocrates> There's also this: https://github.com/keera-studios/haddock/commit/d5d752943c4e5c6c9ffcdde4dc136fcee967c495
21:33:00 <MarcelineVQ> Though, I guess round is safer against going just over 6 too
21:33:26 <Axman6> MarcelineVQ: I don't have one yet. probably round up if the result is within some epsilon of the next highest integer
21:37:33 * hackage hw-prim 0.6.2.20 - Primitive functions and data types  http://hackage.haskell.org/package/hw-prim-0.6.2.20 (haskellworks)
21:39:36 * hackage hw-dsv 0.3.1 - Unbelievably fast streaming DSV file parser  http://hackage.haskell.org/package/hw-dsv-0.3.1 (haskellworks)
21:44:47 <dmj`> harpocrates: oh, nice. CSV format isn't bad I guess
21:46:18 <dmj`> harpocrates: would have just adjusted the foldM to return a list of percentages, check for the ["--total-coverage"] flag
21:46:35 <dmj`> harpocrates: unless (all (==100) percentages) exitFailure
21:46:49 <dmj`> in this line
21:46:50 <dmj`> https://github.com/keera-studios/haddock/blob/d5d752943c4e5c6c9ffcdde4dc136fcee967c495/haddock-api/src/Haddock/Interface.hs#L155
21:53:20 <dmj`> harpocrates: maybe will make PR...
21:57:37 --- mode: glguy set +v govno
22:04:22 <harpocrates> dmj`: I brought up the CSV solution because I'm a bit uncomfortable with the one-size fits all nature of `--total-coverage`
22:04:35 <harpocrates> I guess what I really want is something like Rusts
22:05:49 <harpocrates> `#[deny(missing_docs)]` and `#[allow(missing_docs)`
22:08:58 <cocreature> more granular warnigns are pretty high on my wishlist
22:09:28 <cocreature> there is an open trac issue for it but the discussion died off without reaching a conclusion
22:15:03 * hackage dbus 1.1.0 - A client library for the D-Bus IPC system.  http://hackage.haskell.org/package/dbus-1.1.0 (blaze)
22:16:37 <dmj`> harpocrates, cocreature: looks very nice
22:16:53 <dmj`> current solution is pretty janky
22:17:02 <dmj`> nix-shell --command 'runghc Setup.hs haddock --hyperlink-source' | grep Missing | wc -l
22:17:07 <dmj`> test if the above is 0
22:23:45 <harpocrates> cocreature: Do you have the link to that Trac issue handy?
22:25:14 <cocreature> harpocrates: I think it was https://ghc.haskell.org/trac/ghc/ticket/602
22:28:07 <harpocrates> Nice.
22:28:58 <harpocrates> Although for that to really mesh nicely with Haddock, we'd need to start using GHC flags and error/warning reporting.
22:29:23 <harpocrates> This is a start: https://github.com/haskell/haddock/pull/969
22:47:20 <dminuoso> Okay, I cant write non-Haskell anymore. So far every project Ive worked in that is not Haskell ended up getting function composition and a gazillion of top level lambdas.
22:47:41 <dminuoso> And Haskell-style "type annotations".
22:49:25 <maerwald> Why
22:49:50 <dminuoso> It's incredibly frustrating to not have the right tools for abstraction at your hand.
22:50:04 <maerwald> Abstraction is not always the primary goal
23:18:33 * hackage table-layout 0.8.0.3 - Layout text as grid or table.  http://hackage.haskell.org/package/table-layout-0.8.0.3 (muesli4)
23:48:58 <amosbird> byorgey: hmm, what if I can create infinite number of variables ?
23:55:38 <koz_> dminuoso: Hear hear.
