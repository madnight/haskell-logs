00:53:26 --- mode: glguy set +v Niranjan
01:20:04 * hackage filecache 0.4.1 - A cache system associating values to files.  http://hackage.haskell.org/package/filecache-0.4.1 (SimonMarechal)
01:51:07 * hackage kind-generics 0.2.0 - Generic programming in GHC style for arbitrary kinds and GADTs.  http://hackage.haskell.org/package/kind-generics-0.2.0 (AlejandroSerrano)
02:26:45 --- mode: glguy set +v asd_
03:13:15 <asheshambasta> Hi! Some help with "friday" when trying to blur an RGB image. I see `    • No instance for (Integral I.RGBPixel)` https://github.com/RaphaelJ/friday-examples/blob/master/src/GaussianBlur.hs (I've had the same result with `gaussianBlur`). 
03:16:13 <dminuoso> asheshambasta: can you gist your code together with the full error message?
03:18:06 <asheshambasta> dminuoso: sure, here: https://gist.github.com/asheshambasta/0b3e70fae8b5b37f84c1c8aa8a7d1182
03:19:18 <dminuoso> asheshambasta: And the error message? :)
03:20:13 <asheshambasta> dminuoso: Sorry, added a comment to the gist :-) 
03:20:57 <asheshambasta> (its very rough, sorry about the messy code)
03:29:45 <asheshambasta> dminuoso: no errors if I replace I.RGB with I.Grey, so its quite telling why the example uses Grey instead. 
03:32:03 * hackage githash 0.1.3.0 - Compile git revision info into Haskell projects  http://hackage.haskell.org/package/githash-0.1.3.0 (MichaelSnoyman)
03:32:21 <__monty__> Maybe you need to blur each channel seperately?
03:33:20 <asheshambasta> I guess, but thats a serious limitation of this library
03:33:33 * hackage http-conduit 2.3.3 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.3.3 (MichaelSnoyman)
03:34:01 <asheshambasta> (if thats the case, but it looks like blurring only on single-channel images is supported.)
03:34:49 <asheshambasta> actually, I found it: https://github.com/RaphaelJ/friday/issues/24
03:37:06 <__monty__> 2 years of no activity on that issue and a PR open for about a year tell me you'll probably have to fork to get it fixed any time soon.
03:37:47 <asheshambasta> yeah, I'd probably choose to move away at this point :-) 
03:38:41 * hackage hsyslog-udp 0.2.4 - Log to syslog over a network via UDP  http://hackage.haskell.org/package/hsyslog-udp-0.2.4 (k_bx)
04:11:44 --- mode: glguy set +v HoboKing
04:18:04 <HoboKing> Seems like DerivingVia has issues when used together with StandaloneDeriving and PolyKinds
04:18:05 <HoboKing> https://gist.github.com/KingoftheHomeless/e8463a42963c1c5e27c3482529c66447
04:18:11 <HoboKing> Or am I missing something?
04:27:42 <f-a> I need to generate haskell modules for a projet of mine
04:28:00 <f-a> the idea is very simple: read data -> generate haskell syntax -> write it to a module
04:28:20 <f-a> should I use template haskell or is that only for compile time generation? 
04:28:42 <f-a> or more generally: which tool should I use?
05:00:51 <amx> f-a: what exactly are you doing to the data
05:04:01 <f-a> amx: I want to read some csv files and output an .hs module with the data (say, [[String]]) plus some convenience function (i.e. colD t = t ! 4, etc.) 
05:05:49 <Rembane> f-a: Why do you need to put the data in the hs-file?
05:07:04 * hackage greskell 0.2.2.0 - Haskell binding for Gremlin graph query language  http://hackage.haskell.org/package/greskell-0.2.2.0 (debugito)
05:07:46 <f-a> Rembane: because I might want to modify those convenience functions and the function are related to that specific data
05:08:45 <Rembane> f-a: Okay. So why is it a more convenient solution to put the csv data in the hs-file than to read the data from the csv-file and then operate on it? 
05:09:17 <Ariakenom_> f-a: you can write a "CSV -> ConvenienceFunction" function
05:10:46 <f-a> because if I import SomeModule I will get the data and the related functions. Otherwise I need to parse the data at runtime, and that might fail
05:11:18 <Rembane> Why is failing not an option?
05:13:06 <Ariakenom_> I see, but if it fails isn't the csv you want to operate on broken?
05:14:05 <f-a> Ariakenom_: unfortunately CSV type is very loose (i.e. hasn't much compile time guarantees), so by having autogenerated functions in the same module as the data, I can enforce some kind of safety
05:14:51 <f-a> Rembane: I feel failing while loading a module is better than runtime failures
05:15:38 <Rembane> f-a: Fair enough. I think you are approaching this in a roundabout way, but you can of course do it anyway. :)
05:15:55 <f-a> Rembane: I am open to suggestions!
05:17:19 <Ariakenom_> f-a: running a single test run should provide you the same guarantees, I'd think
05:17:21 --- mode: glguy set +v PatrickRobotham
05:17:40 <Rembane> f-a: Read the csv file using for instance Cassava: https://hackage.haskell.org/package/cassava and handle failure at runtime. 
05:19:44 <f-a> Rembane: how would I then generate convenience funtion? say the thirs column is labeled "bar", how to get a "bar :: CSV -> Column" autowritten? TH?
05:20:33 <f-a> Ariakenom_: thanks, I will think about it
05:22:35 <Rembane> f-a: Sure, sounds reasonable.
05:23:02 <Solonarv> or you could use OverloadedLabels, I suppose
05:24:07 <Rembane> Or GHC.Generics, there's quite some nice functionality for this in Cassava. 
05:26:31 <f-a> Rembane: generics won't land you an extensible (column wise) table
05:26:55 <f-a> vinyl and friends will, but that's at a price of quite long type signatures
05:28:34 <Rembane> f-a: That's true. I might have a too narrow understanding of the problem you want to solve.
05:30:20 <Solonarv> Data.Csv.NamedRecord + OverloadedLabels for accessors sounds like a decent middle ground to me
05:30:56 <f-a> thanks Solonarv , I know nothing of those two. I will look into it
05:31:16 <Solonarv> NamedRecord is just a plain old type from cassava
05:37:56 <rinfiyks> hey all, I'm trying to follow a basic hello world guide to happstack (having not used haskell much before) and I get a "cabal: Could not resolve dependencies" error despite having only just installed cabal, after `cabal update; cabal install happstack`
05:38:19 <rinfiyks> cabal 2.4.0.0, ghc 8.6.2
05:38:36 <f-a> rinfiyks: can you paste the full error somewhere
05:40:11 <rinfiyks> http://ix.io/1ueK
05:42:00 <f-a> can you try --allow-newer?
05:43:40 <rinfiyks> different error now: http://ix.io/1ueL
05:43:43 <amx> happstack:  Deprecated. in favor of happstack-server 
05:43:47 <amx> try that one
05:44:29 <rinfiyks> http://ix.io/1ueM
05:45:02 <f-a> There are files missing in the ‘base-4.12.0.0’ package,
05:45:03 <f-a>     try running 'ghc-pkg check'.
05:45:34 <f-a> seems something is wrong with your installation
05:46:19 <rinfiyks> a bunch of warnings all similar to   Warning: haddock-interfaces: /usr/share/doc/haskell-zlib/html/zlib.haddock doesn't exist or isn't a file
05:46:45 <rinfiyks> /usr/share/doc/haskell-zlib exists but is empty
05:47:01 <lyxia> are you on arch by any chance
05:47:08 <rinfiyks> yeah
05:47:15 <f-a> ok
05:47:28 <rinfiyks> I installed ghc and cabal-install
05:47:46 <lyxia> arch distributes GHC with dynamic linking
05:47:52 <f-a> arch decided on dynamic linking
05:48:52 <lyxia> the arch wiki describes various solutions
05:49:11 <lyxia> either to work with that or to avoid it
05:49:32 <rinfiyks> hmm, okay, I'll have a read of the wiki page, thanks!
05:53:42 --- mode: glguy set +v hhhhhhhg
05:58:33 * hackage hedis 0.10.8 - Client library for the Redis datastore: supports full command set,pipelining.  http://hackage.haskell.org/package/hedis-0.10.8 (k_bx)
06:01:09 <kakadu> Folks, I have a two-parameteric type-indexed (data Zero + data Succ n) list based on GADTs. Can I make him to be an instance of Applicative by stored element parameter? The problem is that I can't write `pure` because length parameter is fixed in instance and I want to return a value of type `List (Succ Zero) a` there
06:02:33 * hackage expiring-containers 0.2.1 - Expiring containers  http://hackage.haskell.org/package/expiring-containers-0.2.1 (OShev)
06:10:36 <Solonarv> you'll run into a similar problem for <*>
06:11:13 <Solonarv> you should instead go for the "zippy" instance
06:11:42 <Solonarv> where 'pure x :: List n a' is n copies of 'x'
06:12:56 <lyxia> you still can't do that parametrically though
06:13:06 <Solonarv> Sure you can
06:13:12 <lyxia> a -> List n a  with no constraints?
06:13:51 <kakadu> Are "zippy" instances googlable?
06:13:53 <lyxia> you need to carry some static information about n
06:14:08 <Solonarv> instance Applicative (List Zero) where pure _ = Nil
06:14:08 <Solonarv> instance Applicative (List n) => Applicative (List (Succ n)) where pure x = Cons x (pure x)
06:14:14 <lyxia> that's not parametric
06:14:30 <Solonarv> I'm pretty sure they just meant "has two parameters"
06:14:53 <lyxia> maybe
06:15:14 <Solonarv> kakadu: look at ZipList
06:15:27 <rinfiyks> f-a amx lyxia everything is working correctly for me now, thank you for your help! :)
06:23:23 --- mode: glguy set +v zhangwenjum
06:24:19 <kakadu> Solonarv: It seems the thing I wanted. Thanks!
06:24:29 <rain1> is regex derivatives the same as abstract interpretation?
06:29:40 <byorgey> amosbird: how can you create an infinite number of variables in a finite program?
06:30:14 <amosbird> byorgey: does function local one counts? recursion
06:33:50 <zhangwenjum> do you know wether cis 194 has video to follow?
06:34:49 <byorgey> amosbird: well sure, if you have arbitrary recursion then it's Turing complete =)
06:35:02 <byorgey> I thought we were just talking about having conditionals and loops
06:35:11 <byorgey> zhangwenjum: no, it doesn't
06:36:29 <ggole> How about a cyclic program?
06:37:31 <byorgey> what is a cyclic program?
06:37:52 <ggole> A program where the term structure contains itself
06:38:42 <berndl> ggole: a quine?
06:39:25 <byorgey> That seems equivalent to allowing unbounded loops or general recursion
06:40:22 <ggole> No, more like #1=(let ((program #1#)) #1#)
06:40:28 <ggole> In Lisp
06:47:06 <phadej> isn't this general recursion?
06:47:52 <berndl> Is it true that Foldable has no laws?
06:48:31 <ggole> Not at the language level, no
06:48:47 <hpc> If the type is also a Functor instance, it should satisfy
06:48:48 <hpc> foldMap f = fold . fmap f
06:48:52 <hpc> from the docs
06:48:55 <hpc> it's a bit buried
06:49:32 <Taneb> It has a handful of laws
06:49:46 <Taneb> Like "fold = goldMap id" and "sum = getSum . foldMap Sum"
06:49:46 <hpc> other than that it has internal "laws" about definitions of some class methods in terms of other class methods
06:50:11 <berndl> I see...
06:50:22 <hpc> but those only exist because things were "unnecessarily" brought into the class so you can write optimized forms
06:50:31 <hpc> it'd be like if ap was a class method of Monad
06:51:01 <hpc> it would have a "law" that ap = definition in terms of the other methods
07:19:17 <safinaskar> Prelude has zips up to zip3
07:19:25 <safinaskar> Data.List has zips up to zip7
07:19:30 <safinaskar> who more? :)
07:21:47 <ragusa> ZipList is an Applicative, so it has basically has zip∞
07:24:48 --- mode: glguy set +v fen
07:30:00 <lyxia> zipn for all n does not imply you can make zip∞
07:30:59 <lyxia> how would zip∞ know whether the result is an empty list or not
07:36:27 <fen> is there a way to delay application of a function? https://bpaste.net/show/d28bd0a47657
07:37:08 <fen> to allow other functions to act on the argument before it?
07:38:32 <fen> the paste shows fmap of (:) into a value wrapped in an applicative.
07:39:12 <fen> this (:) must be applied after anything else that needs to be done to the value
07:39:28 <geekosaur> sounds like you want a free Functor of some kind? that said, you have one, you can pattern match through the (:)
07:39:32 <fen> because it returns a type which is difficult to act on
07:40:13 <fen> geekousar: how can you pattern match on something of type `forall a. [a] -> [a]'
07:40:21 <fen> that does not seem like the correct approach 
07:41:45 <fen> applying it to [] and mapping over the resulting list and retrieving the resulting value seems wasteful 
07:42:46 <fen> a better idea is to delay the application of (:) until after everything that needs to be done to the value.
07:43:45 <fen> not sure how best to do this and what the resulting type would be that could support a Functor instance
07:45:17 <kuribas> is it possible with servant to create a documentation with (given) examples, that also should work against the api?
07:45:24 <kuribas> and can be used as a test-suite?
07:47:37 <antonh> I want to define a tree like this: data MyTree = MyLeaf (Int,Char) | MyBranch (Int) (MyTree l) (MyTree r). But I am not sure how I am supposed to do. Can you help me?
07:47:58 <geekosaur> if you are applying a constructor (:), you can pattern match away *that* constructor
07:48:08 <lyxia> antonh: MyBranch Int MyTree MyTree
07:49:43 <alp> kuribas, what do you mean? could you give an example?
07:51:51 <fen> geekosuar, but its only a partial application 
07:52:14 <antonh> lyxia: Wow. That works! Thank you.
07:52:29 <fen> maybe this problem would be for all partial applications, as the resulting type is not something that can be fmaped over
07:58:19 <fen> geekoasur: not sure I understand your idea?
08:00:04 <fen> maybe it be encoded as a differnt arrow?
08:00:17 <vaibhavsagar> how do I specify the order in which libcrypto and libssl are linked in cabal?
08:07:24 --- mode: glguy set +v noah
08:07:50 <fen> ok, so if applying a function of type (forall a. a -> f a) to a value of some type,  `f' might not be a functor. but because this function can be applied to any value, the thing that might want to get at the `a; of the resulting `f a' could just be applied to the `a' before the `forall a. a -> f a'
08:08:01 <phadej> vaibhavsagar: cabal doesn't reorder anything, or at least shouldn't
08:08:07 <noah> I installed MonadHaskell via cabal but when I import Control.Monad.Random i get "Could not find module 'Control.Monad.Random'"
08:09:12 <lavalike> noah: what is MonadHaskell?
08:09:55 <noah> MonadHaskell is the library implementing Control.Monad.Random
08:10:16 <vaibhavsagar> phadej: can I specify an order?
08:10:27 <Solonarv> I doubt that, that module is in 'random'
08:10:53 <Solonarv> it /is/ possible for multiple packages to use the same module name, but that's frowned upon and not done very much
08:11:05 <vaibhavsagar> I'm running into https://github.com/robertdavidgraham/heartleech/issues/19 when trying to build a binary statically
08:11:21 <Solonarv> 'MonadHaskell' isn't even on hackage!
08:12:05 <noah> Oh sry I was thinking about a different thing while typing :) I meant MonadRandom
08:12:09 <phadej> vaibhavsagar: well, if you specify them in order, the order should be preserved
08:12:22 <hpc> MonadRandom is a type class
08:12:34 <lavalike> ok that one's a package as well
08:12:40 <noah> But how to I get "import Control.Monad.Random to work"
08:13:23 <vaibhavsagar> phadej: thanks, I will try that
08:13:48 <lavalike> noah: does ghc-pkg show it as installed? if so which version?
08:14:32 <geekosaur> and how did you install it?
08:15:43 <noah> cabal install MonadRandom
08:16:14 <noah> random-1.1 is installed
08:16:23 <phadej> vaibhavsagar: try -v2 etc. output, than you'll see how GHC / linker are envoked
08:16:25 <phadej> invoked
08:16:30 <phadej> if it still doesn't work
08:16:34 <lavalike> noah: that's a different thing
08:17:28 <lavalike> it defines System.Random
08:17:46 <lavalike> (ghc-pkg describe <package>)
08:17:53 <noah> after running cabal install MonadRandom it says MonadRandom-0.5.1.1 is installed but it is not listed by ghc-pkg list
08:18:06 <lavalike> hm
08:18:27 <fen> hmm, it gives this error; https://bpaste.net/show/477159f64d55
08:18:41 <vaibhavsagar> phadej: thanks for the tip :), unfortunately I'm doing this with Nix so I'm not sure how to pass -v2 to cabal
08:19:07 <lavalike> noah: out of curiosity does   ghci -package MonadRandom   work in the sense of letting you then   import Control.Monad.Random   ?
08:20:19 <noah> No
08:20:46 <noah> but if I can import Monad.Random in cabal repl
08:21:24 <geekosaur> then you are probably in a sandbox and need to run ghci inside that sandbox, which is what cabal repl is
08:21:54 <biglambda> Hello, is there anyone familiar with using GHC as a library?
08:22:33 <berndl> As a library?
08:22:39 <noah> Oh thank you. I ran plain ghc instead of running it in the sandbox
08:22:50 <lavalike> how do you run it in a sandbox?
08:22:57 <biglambda> Yes I’m experimenting with manipulating core expressions.
08:23:46 <biglambda> I’ve gotten to the point where I can compile a program to core syntax but I’m just curious if anyone can guide me through the codebase a little so that I don’t reinvent the wheel.
08:23:54 <geekosaur> lavalike, cabal exec. Or cabal repl, which runs int he sandbox and preloads modles listed in the cabal file
08:24:10 <fen> where is this type level lambda anyway?
08:24:47 <biglambda> I’d like to for example, just reduce a single lambda and I’m wondering what existing machinery can already do that in the codebase.
08:25:28 <lavalike> gotcha
08:26:32 <fen> is it too much to be able to expect ghc to be able to infer `f x = \x -> [x] -> [x]' ?
08:26:47 <biglambda> I’ve been looking at the substitution functions. But I’m wondering if there is something higher level. Like for example if I have a WHNF in the scrutinee of a case expression, how can I reduce that.
08:27:01 <fen> sorry, just `f' on the lhs
08:27:39 <fen> like, is that the problem which is why we dont have type level lambdas?
08:27:59 <fen> would that confuse the typechecker?
08:28:39 <fen> like, obviously it would have to have some way to try and match expressions by generating lambda type level functions?
08:29:29 <fen> hmm, seems like the defunctionalisation stuff all over again
08:29:45 <fen> datatypes to wrap partially applied types
08:30:22 <fen> why does everything always end up so complicated!?
08:31:33 <berndl> Because life
08:31:55 <fen> because haskell more like
08:36:53 --- mode: glguy set +v tronic_
08:40:14 <tronic_> hello, i'm using stack for my project, and I'm interested in doing some JSON encoding and decoding.  So I thought I'd install aeson with "stack install aeson".
08:40:36 <tronic_> but when I try that, I get the following: 
08:40:38 <tronic_> In the dependencies for unix-2.7.2.2:     time-1.9.1 from stack configuration does not match >=1.2 && <1.9  (latest matching version is 1.8.0.4) needed due to aeson-1.3.1.1 -> unix-2.7.2.2
08:41:57 <tronic_> There is a function from the time module that I'm using called nominalDiffTimeToSeconds that is only present in the time package since time-1.9.1, so I'm not sure what to do.
08:42:38 <Solonarv> 'stack install' means "build this package's executables and copy them to ~/.local/bin"
08:43:43 <Solonarv> if you want a package to be available to your project, you need to add that package to the 'dependencies' section in package.yaml, or to the 'build-depends' section in yourpackage.cabal
08:44:27 <tronic_> oh, thanks, that's not what I want then.  OK, I had forgotten the difference between stack.yaml and package.yaml and did a search to find out how to use a library and must have misunderstood.
08:45:18 <Solonarv> very roughly: package.yaml specifies info about /your package/, which includes its dependencies. stack.yaml specifies where to get them.
08:46:34 <tronic_> ok thanks for the info
08:48:46 <tronic_> hmm.  when I add it to my package.yaml, I get troubles with dependencies.
08:49:39 <Franciman> How can I "concat" two conduits ? In the sense that I want to first stream all the first conduit and then all the second one
08:49:49 <Franciman> something like c1 ++ c2 for lists
08:52:15 <tronic_> I am using a function added in time-1.9.1 (nominalDiffTimeToSeconds), but it looks like I'm using unix-2.7.2.2, which for some reason requires time < 1.9
08:52:50 <Solonarv> tronic_: try switching your resolver to 'nightly'
08:57:07 <tronic_> hmm i don't think that will help -- it seems the nightly is still using time-1.8.0.2
09:01:06 <Solonarv> ah, damn
09:01:24 <Solonarv> then your two options are basically "turn on allow-newer" or "use cabal instead"
09:01:55 <lyxia> Franciman: (>>) ?
09:07:12 <tronic_> hmm, thanks Solonarv.  I am only using one function from 1.9.1, and that is a function that converts a NominalDiffTime to seconds -- I wonder if there is a way to do that manually with 1.8.0.2
09:07:48 <Solonarv> I've ran into the exact same issue myself (even the same function I needed)
09:08:29 <tronic_> haha
09:08:56 <Solonarv> I ended up doing without, because at the time I didn't have cabal working
09:09:13 <tronic_> i am scared of cabal
09:09:46 <Solonarv> what specifically are you scared of?
09:10:50 --- mode: glguy set +v kiwipre-51
09:11:34 <tronic_> well I guess I'm scared that I will won't be able to get all of the modules to work together in a reproducible fashion.  that's why I am using stack, because it seems that it maintains a consistent set of packages which seems nice
09:12:37 <geekosaur> cabal 2 and later are better at it, and then you can "cabal freeze" the result as a reproducible build
09:12:43 <Solonarv> ^ that
09:14:16 <tronic_> ok, well I think I'm going to avoid trying to use cabal and see if I can figure out a way to do a conversion of a NominalDiffTime to seconds myself...
09:15:39 <Taneb> "unsafeCoerce :: NominalDiffTime -> Pico" should do it
09:16:55 <tronic_> wow OK thank you taneb...
09:17:55 <tronic_> also, here is a question -- why did stack let me get away with adding - time >= 1.9.1 to my dependencies when it is not one of the stable ones that stack includes?
09:18:18 <geekosaur> if it was an extra-deps then it would override
09:18:22 <tronic_> i guess the whole point of me using stack was to ensure that I would have a consistent set of packages 
09:18:53 <geekosaur> because sometimes you do need later versions of things than have been fully tested as part of a snapshot/LTS
09:19:00 <Solonarv> the thing about stackage is that a snapshot is a compatible set of *all* packages, even ones you don't use
09:19:05 <tronic_> i did add it to my "dependencies" section and also to "extra-deps" in the stack.yaml file...
09:19:09 <MarcelineVQ> it's one of the essent things extra-deps is for
09:19:13 <MarcelineVQ> *essential
09:19:29 <MarcelineVQ> Adding things not found in a chosen snapshot to your project environment
09:19:57 <tronic_> oh i didn't realize that one.  so I should avoid adding things to the extra-deps if possible...
09:20:14 <Solonarv> no, the opposite
09:20:28 <Solonarv> you add things to extra-deps if you need them, but they're not in the snapshot you're using
09:20:40 <MarcelineVQ> Not avoid, but one should use extra-deps when it's needed
09:20:49 <tronic_> hmm I've also got "Stack-0.3.2" in my extra-deps I wonder what that means...
09:20:52 <Solonarv> since you specify an exact version in extra-deps, it's just as pinned as any otherpackage
09:20:59 <MarcelineVQ> And it's needed when the package you wan't isn't in a chosen resolver
09:21:10 <tronic_> oh i see
09:22:29 <tronic_> but any time I add something to extra-deps I run the risk of future troubles if I add another package...
09:22:37 <tronic_> like I did today
09:23:11 <Solonarv> yes, but once you fix those troubles they *stay* fixed
09:23:48 <tronic_> haha but I don't think I can fix my current problem.  This might be first time I ever using a function with the word "unsafe" in it...
09:26:06 <Solonarv> I'd recommend you write a wrapper around unsafeCoerce instead of using it directly
09:26:29 <MarcelineVQ> Solonarv: to fix the type?
09:26:34 <Solonarv> MarcelineVQ: yes
09:26:50 <Solonarv> and to more clearly explain what the unsafeCoerce is for
09:29:32 <tronic_> ok I will work on that...  also if I have "Stack-0.3.2" in my extra-deps does that mean that I'm locked to a particular version of the package list?
09:29:47 <tronic_> I'm not sure I know why I put it there...
09:30:27 <Solonarv> I don't know either! and no, that's not what locks you to a particular snapshot
09:30:40 <Solonarv> the snapshot is selected by the 'resolver' field
09:31:42 <tronic_> haha OK thank you
09:32:07 <tronic_> I am going to try taking it out and see what kind of disaster that creates
09:51:33 * hackage yesod-markdown 0.12.5 - Tools for using markdown in a yesod application  http://hackage.haskell.org/package/yesod-markdown-0.12.5 (PatrickBrisbin)
09:54:21 <tronic_> hmm, solonarv, when you say create a wrapper around the unsafeCoerce function, what do you mean?  I am having some trouble using it because it says unsafeCoerce is a variable that is out of scope
09:55:17 <tronic_> i wrote a function that has a signature of NominalDiffTime -> Pico and am using the function unsafeCoerce inside that function, but I suspect that's not what you suggested when you said write a wrapper function for it
09:55:33 <Solonarv> that is in fact what I meant ;)
09:55:57 <Solonarv> unsafeCoerce is in Unsafe.Coerce iirc
09:56:01 <Solonarv> % :i unsafeCoerce
09:56:02 <yahb> Solonarv: unsafeCoerce :: forall a b. a -> b -- Defined in `Unsafe.Coerce'
09:56:03 <MarcelineVQ> you need to import it from Data.Coerce or Unsafe.Coerce
09:56:11 <tronic_> Oh k
09:56:26 <MarcelineVQ> Oh Data.Coerce doesn't export it, huh, thought it did
09:56:46 <Solonarv> Data.Coerce is for /safe/ coercing
09:57:08 <MarcelineVQ> coerce is yes, for some reason I thought it re-exported unsafeCoerce though
09:58:18 <tronic_> ah that helped -- thanks.  I'm able to use it after importing Unsafe.Coerce
10:04:45 <geekosaur> MarcelineVQ, possibly it did before Safe Haskell made it advisable to segregate the unsafe stuff into its own modules?
10:05:34 <MarcelineVQ> Just my own misremembering most likely, I don't think I was around before Safe
10:08:05 <dmj`> Is cabal segfaulting pretty bad for anyone else? cabal build (version 2.4.0.0, library 2.4.0.1)
10:09:17 <dmj`> building with verbosity shows cabal's invocation of ghc dumps (returned ExitFailure (-11))
10:09:55 <leshow> I'm switching some code that's using mvar's to tvar's. modifyMVar returns some value after modification
10:10:04 <leshow> there is no equivalent function in STM
10:11:04 <Solonarv> you can just write it yourself, I guess
10:12:42 <geekosaur> not sure you can, actually, at least without some extra thought about how that interacts with retries
10:13:05 <leshow> am I left with just modifying then reading immediately after
10:13:33 <dmj`> segfaults on 8.6.1 as well
10:14:43 --- mode: glguy set +v HoboKing
10:15:39 <HoboKing> There seems to be a bug with DerivingVia which doesn't allow you to write standalone DerivingVia instances for polykinded types: https://gist.github.com/KingoftheHomeless/e8463a42963c1c5e27c3482529c66447
10:15:46 <HoboKing> Is this known?
10:16:01 <HoboKing> Or am I missing something?
10:26:25 <bollu> Has anyone read https://www.cs.cmu.edu/~rwh/papers/farray/popl17.pdf? If so, thoughts?
10:34:08 <Solonarv> no, but I am now!
10:42:04 <c_wraith> that paper reminds me of DiffArrays
10:42:12 <c_wraith> which don't exist anymore for a reason.
10:43:19 <c_wraith> Oh.  They're actually mentioned eventually.
10:48:40 --- mode: glguy set +v fen
10:48:46 <fen> ok! have got a solution! 
10:50:07 <fen> traversable isnt really the end goal. the traversable instance for shaped containers leads to a Traversablei class, where the shape directing index is made available along with the values stored during traversal
10:51:00 <fen> this is important because it leads to a mapAccum function that can use these shape directing indexes to update a carried value
10:51:45 <fen> this is used in the comonad duplicate instance, where this shape index is used to navigate a carried copy of the shaped container
10:51:49 <JosephFerano> I caved and went back to Jetbrains MarcelineVQ 
10:51:58 <MarcelineVQ> Whatever works
10:52:02 <JosephFerano> Using IdeaVim which isn't that bad, but man...
10:52:05 <JosephFerano> Jetbrains just werks
10:52:14 <JosephFerano> It's been so hard to ween myself off of it
10:52:16 <fen> the problem was that the traversable instance couldnt be used for difference zippers
10:52:24 <MarcelineVQ> I use a glorified notepad so it's not like editor is make or break
10:52:44 <JosephFerano> I'm just big on programming UX, and this is just on a league of its own
10:52:44 <fen> but actually, all that is needed is the indexed version of mapAccum 
10:53:13 <fen> and this can be implemented for a version of difference zippers
10:53:18 --- mode: glguy set +v govno
10:53:44 <fen> this motivates a Acuumlator superclass of Traversable, and the corresponding indexed versions of these classes
10:54:16 <fen> its not apparent just considering Traversable, why the mapAccum function gives a default for an Accumulator superclass
10:55:01 <fen> but when the shape directing index is included, the ability of some types to support an Acuumulatori instance but not a Traversablei instance motivates this distinct superclass
10:56:39 <fen> previously it was noted that anything supporting a difference representation is traversable by default, and that get/set and geti/seti variants implement the differenceT function and thus give riseto a traversable instance 
10:56:58 <fen> https://bpaste.net/show/ba3031a35688
10:57:08 <fen>  differenceT :: Applicative g => (a -> g b) -> StateSafe (f a) (g (f b -> f b))
10:57:43 <fen> but now, rather than recombining the constructor and deconstructor within an applicative to give the `StateSafe (f a) (g (f b -> f b))'
10:58:44 <fen> the construction and deconstruction superclasses are required explicitly, as they leave the value visible for an accumulator to run over it, and for the indexed versions, have access to these indexes at each value also
11:01:29 <fen> while implementing differenceT gives rise to traversable, relaxing that the constructor and deconstructor are applied simultaneously to each value as it is retrived, the Accumulator class can be instantiated, and Comonad duplicate given by default, even when Traversable instances are not available, such as for difference zippers
11:02:39 <fen> the differenceT approach was good because it unified the get/set and geti/seti approaches, as both give rise to a differenceT instance and traversable and comonad duplicate follow by default
11:04:43 <fen> this however prevented difference Zippers themselfs from being traversed and so there could not be a correspoding comonad duplicateDefault
11:05:37 <fen> the point is that this duplicateDefault does not need traversable, but only the mapAccum function, which should thus become the defining function for a superclass to Traversable
11:06:12 <fen> maybe its only relavent for the indexed versions... so that Acumulatori is a superclass to Traversablei
11:07:31 <fen> and then there is a Comonad instance difference zippers of this new form, where values are left visible, rather than applying the reconstructor at the point where the deconstructor retrives them from the list
11:09:00 <fen> giving; data Zipper f a = Structured i f => Zipper [(i,a)] (f a)
11:10:02 <fen> mapAccumRi :: Auumulatori i t => (a -> (i,b) -> (a, c)) -> a -> t b -> (a, t c)
11:11:40 <fen> being the defining function of this new superclass to Traversablei i t; class Accumulatori i t 
11:12:37 <fen> class (Traversable t,Accumulatori i t) => Traversablei i t where traversei :: Applicative f => ((i,a) -> f b) -> t a -> f (t b)
11:12:59 <fen> mapAccumRi f s t = runStateL (traversei (StateL . flip f) t) s
11:13:18 <fen> mapAccumLi *
11:14:44 <fen> toDuplicate :: Accumulatori i f => (i -> f a -> f a) -> f a -> f (f a)
11:15:09 <fen> toDuplicate f xs = snd $ mapAccumRi (\ carry (i,_) -> let carry' = f i carry in (carry',carry)) xs xs
11:15:57 <fen> which is the function which requires the index `i' to update the carry, and gives rise to the duplicate instance for the form of Zipper above
11:16:53 <fen> this is good because it means the zipper does not need to be rewound before it can be duplicated
11:18:42 <fen> and actually yes, the version without an index, a zipper over linear containers, does serve as an example of something where Acummulator can be instantiated but traversable cannot
11:19:28 <fen> Linear f => Zipper [a] (f a)
11:20:10 <fen> the reason is that the values in the [a] when recombined with the `f a' using set, cant have the applicative commuted to the outside
11:20:27 <fen> wait, can they?
11:20:59 <hyperisco> fen, hey I learned recently how to set up a static blog with S3. Need some tips?
11:21:39 <fen> hyperrisco: can you tell if that representation supports a Traversable instance? would be good to solve that asap
11:23:12 <Solonarv> I don't think static blogs on S3 support a Traversable instance, no
11:23:13 <Solonarv> :V
11:24:46 <fen> like, it can go to (Appliative f,Traversable t) => Zipper [f a] (f (t a)), but not to `f (Zipper t a)' , right?
11:25:15 <fen> so that *does* mean Accumulator is a valid superclass of Traversable?
11:25:58 <fen> probably a good idea to get some feedback on something that is such a fundamental change to the Prelude
11:27:07 <fen> hyperisco: cool news for your blog btw, would be great to see some of your posts, publishing is very important! 
11:28:24 <fen> do you link that at job interviews?
11:29:15 <fen> nobody actually reads this channel anyway!
11:30:06 <hyperisco> I don't have a blog. I just know how to set one up on AWS now.
11:30:31 <hyperisco> Well I still can't get the domain working but that's just details.
11:31:07 <fen> nice! yeah, the only bad thing about blogs is that sometimes if there is a comment section it messes up the presentation, but probably that could be avoided somehow
11:31:57 <Tuplanolla> Having no comment section works pretty well.
11:31:58 <hyperisco> actually looks like the DNS record is still propagating
11:32:31 <hyperisco> you don't want a comment section… here's what I'd do
11:33:02 <fen> well, feedback on some issues is very very important
11:33:09 <hyperisco> post an email address somewhere on a different page, say a "contact" page, and let the comments flow into that
11:33:22 <fen> maybe there is a blog that only #haskell users can post too!
11:33:44 <hyperisco> let the email spam filter do its work and you might be able to find actual comments
11:34:04 <hyperisco> then any good ones you can copy and paste to your static page
11:34:11 <fen> yeah, if you have time to write a spam filter!
11:34:19 <hyperisco> no, you're just going to use gmail or w/e
11:35:04 <fen> is #haskell blocked in china?
11:36:17 <hyperisco> granted running Wordpress is painting a target on your chest, but I remember how horrendous having a Wordpress comment section was
11:36:37 <hyperisco> the first couple days I had left it for open comment… came back to some, erm, surprises
11:37:01 <fen> no one has to deal with that!
11:37:10 <fen> that suck, sorry 
11:37:27 <hyperisco> so I set it so I'd have to approve first, but I'd get dozens of spam messages a day
11:37:39 <fen> anyway, if you get another blog id be really happy to see it! 
11:37:57 <hyperisco> eventually I stopped checking and the unapproved comment count, all spam, grew into the thousands
11:38:14 <hyperisco> until one day I realised running a blog sucked and I shut it all off
11:38:18 <fen> but maybe if there are any feedback on the Accumulator superclass to Traversal thats not what i should thinking about now 
11:39:43 <Solonarv> my blog is just hakyll deploying to github pages via CI
11:40:44 <fen> you have a blog?? now thats something i want to know about
11:41:12 <hyperisco> did you time travel into the future? I thought that would be exciting maybe 15 years ago
11:41:50 <fen> no its just Solonarv has high quality haskell skills and thats really quite relevant 
11:42:14 <Solonarv> There's all of two posts on it. The first one chronicles my original attempt at setting up the blog, the second one chronicles the (successful) second attempt
11:42:55 <hyperisco> the "sorry I haven't written much lately" post is when you know death is nigh
11:43:11 <fen> blogging about blogging is so 2017
11:43:19 <Solonarv> Oh I'm not planning to write a ton anyway
11:44:06 <Solonarv> but if you want a link, sure: http://solonarv.github.io/
11:44:16 <hyperisco> I'd have to pick between working on a blog and video gaming, basically, and that's not a contest
11:44:33 <Solonarv> I just noticed some of the static pages are still lorem ipsum, lol
11:45:29 <hyperisco> where's your "under construction" animated gif?
11:46:21 <Solonarv> well, if hakyll's default template came with one of those I'd probably have it there
11:46:23 <fen> a lambda sign shielding itself with a man hole cover from a pneumatic drill
11:47:25 <hyperisco> that is oddly creative
11:47:30 <Solonarv> bah, that requires art skills - I have none of that
11:47:33 <Solonarv> cool idea though!
11:48:01 <fen> you want to know a cool idea? there seems to be a superclass to traversal!
11:48:19 <fen> ... a *new* one
11:48:23 <hyperisco> you mean Traversable?
11:48:31 <fen> yeah the class
11:48:36 <hyperisco> or is that a recursion schemes thing… "Traversal"
11:48:48 <hyperisco> could be lens
11:48:52 <fen> hmm, maybe I should like the blog post 
11:48:53 <Solonarv> % :i Traversal
11:48:54 <yahb> Solonarv: type role ReifiedTraversal representational nominal representational nominal; newtype ReifiedTraversal s t a b = Traversal {...}; -- Defined in `Control.Lens.Reified'; type Traversal s t a b = forall (f :: * -> *). Applicative f => (a -> f b) -> s -> f t -- Defined in `Control.Lens.Type'
11:49:01 <fen> no not that!
11:49:06 <Solonarv> heh
11:49:07 <fen> thats rediculousness 
11:49:33 <Solonarv> good luck liking my post, the site is completely static and doesn't have any social-media iframes
11:49:57 <hyperisco> well if you did mean Traversable, that is great you found its super class, but most of us just skip to the back of the book (where the documentation is)
11:50:39 <hyperisco> and you could say that you only have half the story!
11:51:25 <fen> after whining so much about difference lists and their associated Zippers not being Traversable and this ruining their comonad duplicate default, thought it might be nice to show how those considerations lead nicely to the Acuumulator superclass of Traversable, and the corresponding versions for shaped containers
11:52:16 <fen> hyperisco: maybe if your books were more interactive it would already be there! 
11:52:34 <hyperisco> ah ha I see, well shame me then
11:53:53 <hyperisco> I didn't catch the definition of Accumulator in your dissertation there
11:54:05 <fen> thought thats what OpenStax was for...
11:54:17 <fen> :t mapAccumR
11:54:18 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
11:54:23 <fen> its just a class with that in
11:54:43 <hyperisco> and what are the laws?
11:55:03 <fen> that mapAccumR of a valid traversable gives its default
11:55:33 <fen> its supposed to be shape preserving...
11:55:44 <hyperisco> well that's begging the question, and I'm actually using that terminology correctly
11:56:18 <fen> mapAccumRi :: Accumulatori i t => (a -> (i,b) -> (a, c)) -> a -> t b -> (a, t c)
11:56:34 <fen> class (Traversable t,Accumulatori i t) => Traversablei i t where traversei :: Applicative f => ((i,a) -> f b) -> t a -> f (t b)
11:57:11 <fen> hyperisco: huh? that makes it inherit the Traversable laws though right?
11:57:16 <fen> of Functor and Foldable
11:57:27 <dmj`> hlint ANN declarations apparently cause segfaults in nix and cabal builds
11:57:29 <fen> it being a "trivial" superclass
11:57:42 <Solonarv> dmj`: huh.
11:58:56 <hyperisco> how can I inherit traversable laws if it is not traversable
11:59:00 <fen> then because difference Zippers are instances of Accumulatori and are pointers they are comonads!!
11:59:22 <fen> hmmm, thats a good point
11:59:31 <fen> idk, probably it has some laws
11:59:59 <fen> if i wrote a blog about it someone might be helpful enough to write a comment about it!
12:00:11 <hyperisco> :t traverse
12:00:12 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
12:03:02 <hyperisco> so something is an Accumulator that isn't a Traversable?
12:06:57 <fen> well that was the question that was asked just prior to your blog interjection 
12:07:13 <fen> [19:19] <+fen> Linear f => Zipper [a] (f a)
12:07:19 <fen> [19:19] <+fen> the reason is that the values in the [a] when recombined with the `f a' using set, cant have the applicative commuted to the outside
12:07:25 <fen> [19:20] <+fen> wait, can they?
12:08:00 <fen> [19:24] <+fen> like, it can go to (Appliative f,Traversable t) => Zipper [f a] (f (t a)), but not to `f (Zipper t a)' , right?
12:09:12 <hyperisco> what is Zipper?
12:09:35 <hyperisco> from comonads?
12:09:39 <fen> there are several varients
12:09:54 <fen> here its easiest to consider; data Zipper f a = Linear f => Zipper [a] (f a)
12:10:23 <nshepperd1> That's traversable as long as f is
12:10:25 <sclv> where is Accumulator defined?
12:10:42 <fen> which replaces the corresponding difference list variant `data Zipper f a = Linear f => Zipper [f a -> f a] (f a)'
12:11:06 <sclv> for that matter where is Linear defined?
12:11:15 <fen> nsepperd1: yes, it does have a traversable instance, but it requires the zipper to be rewound
12:11:26 <fen> which is slow if all thats needed is the Accumulator over it
12:11:29 <nshepperd1> What
12:11:36 <fen> such as for its comonad duplicate default
12:12:17 <fen> fromZipper :: Zipper f a -> (Int,f a)
12:12:55 <fen> then traverse the resulting `f a' and move forwards by the returned Int after doing toZipper = Zipper []
12:13:39 <hyperisco> we seem to be stuck waist deep in a swamp
12:14:02 <hyperisco> what is Linear
12:14:04 <sclv> i think mathematically mapAccumL as structured in the accumulator class is really equivalent in power to traverse
12:14:07 <fen> the problem was trying to commute the `f' out of `Zipper [f a] (f (t a))' cheaply 
12:14:14 <nshepperd1> You can just traverse the [a] then the f a then combine the results
12:14:19 <sclv> it just might be "cheaper"
12:14:24 <sclv> in which case it isn't a super or a subclass
12:14:45 <fen> nshepperd1: and that doesnt lose the place the zipper was navigated to?
12:15:30 <fen> sclv: still would be good to be able to override a default class function with another implementation
12:15:31 <hyperisco> I couldn't figure out a traverse defined in terms of mapAccumR
12:16:12 <nshepperd1> fen: why would it
12:16:15 <fen> yeah, mapAccumR uses StateR as the Applicative, probably cant invert that to make a more general Applicative
12:16:19 <hyperisco> but fmap is definitely definable with mapAccumR, as is foldMap
12:16:51 <hyperisco> (if we make some loose assumptions on what mapAccumR means)
12:17:52 <fen> nshepperd1: because getting the `f' on the lhs of the Zipper would mean combining the f [a] and the f (t a), and doing this would lose its place
12:18:12 <hyperisco> though just because we can't write traverse in terms of mapAccumR doesn't mean there's actually any Accumulators which are not also Traversable
12:19:08 <nshepperd1> fen: No it wouldn't, that's just <*>?
12:19:55 <fen> oh right, the Zipper is reapplied using liftA2
12:19:58 <fen> fair enough
12:20:19 <fen> yay a cheap traversable instance!
12:21:32 <fen> anyway what this really messes up is the Difference superclass to Traversable, which captured get/set and geti/seti containers, named Linear and Structured respectively  
12:21:58 <fen> they had the Zipper as; data Zipper f a = Linear f => Zipper [f a -> f a] (f a)
12:22:10 <fen> which is very badly not traversable
12:22:58 <fen> but that any `f' which could implement  differenceT :: Applicative g => (a -> g b) -> StateSafe (f a) (g (f b -> f b)) was Traversable
12:23:02 <fen> https://bpaste.net/show/ba3031a35688
12:26:22 <fen> Zipper f a = (Has (f a) (b,f a),Has (b,f a) (f a)) => Zipper [b] (f a)
12:26:52 <fen> type Has a b = Default (a -> b)
12:27:42 <fen> and then its getting hard to traverse again
12:32:26 <crestfallen> hi I've been trying to get this to work on a list of Maybe elements such that ...
12:32:51 <crestfallen> @let t = (<$>) length
12:32:53 <lambdabot>  Defined.
12:33:16 <crestfallen> one moment sorry
12:33:52 <crestfallen> @let t = (<$>) (++ " !)
12:33:52 <lambdabot>  Parse failed: Improperly terminated string
12:33:59 <crestfallen> @let t = (<$>) (++ " !")
12:34:00 <lambdabot>  .L.hs:165:1: error:
12:34:00 <lambdabot>      Multiple declarations of ‘t’
12:34:00 <lambdabot>      Declared at: .L.hs:164:1
12:34:08 <crestfallen> @let tt = (<$>) (++ " !")
12:34:10 <lambdabot>  Defined.
12:35:12 <crestfallen> I cannot write the type declaration to make tt work over a list [(Just "Tater"), (Just "Tot")]
12:35:34 <Solonarv> :t tt
12:35:36 <lambdabot> Functor f => f [Char] -> f [Char]
12:35:53 <Solonarv> :t [(Just "Tater"), (Just "Tot")]
12:35:54 <lambdabot> [Maybe [Char]]
12:36:33 <Solonarv> the list-of-maybes has two "layers": the outer layer is '[]', the inner layer is 'Maybe'
12:36:53 <Solonarv> 'tt' only works through one layer
12:37:04 <crestfallen> ok I've been one the right track, however Solonarv 
12:37:07 <crestfallen> ...
12:37:38 <crestfallen> how do I write that in the constraint?
12:37:54 <Solonarv> you don't, instead you write:
12:38:03 * hackage adblock2privoxy 2.0.0 - Convert adblock config files to privoxy format  http://hackage.haskell.org/package/adblock2privoxy-2.0.0 (essandess)
12:38:09 <Solonarv> @let t2 = fmap (fmap (++ " !"))
12:38:11 <lambdabot>  Defined.
12:38:13 <Solonarv> :t t2
12:38:14 <lambdabot> (Functor f1, Functor f2) => f1 (f2 [Char]) -> f1 (f2 [Char])
12:38:22 <Solonarv> this one does two layers
12:38:33 <crestfallen> excellent thanks kindly Solonarv 
13:15:24 <amateur_hour> Is there a way of writing something like `zero :: Num a => a` with `zero = 0`?
13:15:45 <Solonarv> I think you just did
13:15:51 <geekosaur> have you tried it?
13:15:55 <Solonarv> but you could also just write '0'
13:15:57 <Solonarv> :t 0
13:15:58 <geekosaur> note that in ghci, you need to put them on ne line
13:15:58 <lambdabot> Num p => p
13:16:05 <geekosaur> or use multiline mode
13:16:45 <hyperisco> I want some profound theorem to be published that way
13:17:50 <amateur_hour> huh, that really works
13:19:40 <amateur_hour> ahh, I had forgotten a data constructor in what I was looking at and wasn't understanding why it wasn't typechecking
13:19:53 <amateur_hour> and had a brainfart when reading the reason
13:19:57 <amateur_hour> thanks! :)
13:25:12 <tronic_> hello, I'm getting an error saying "Could not find module 'Data.Stack'", but I have "- stack" in my package.yaml file.
13:25:52 <confusedwanderer> maybe you need to rebuild?
13:26:07 <tronic_> how would I do that?
13:26:51 <confusedwanderer> do you use cabal or stack (the build tool)?
13:26:58 <tronic_> i'm using stack
13:27:06 <confusedwanderer> try "stack build"
13:27:32 <tronic_> ok, that's what I'm doing when I see the error that there is no module "Data.Stack"
13:27:51 <confusedwanderer> i see
13:28:04 <confusedwanderer> i think dependency names are case-sensitive
13:28:15 <confusedwanderer> do you have "Stack" in your package.yaml?
13:28:19 <confusedwanderer> or "stack"?
13:28:29 <tronic_> lowercase stack...
13:28:45 <hyperisco> confusedwanderer, do you have a magical chest that follows you around?
13:29:29 <confusedwanderer> tronic_: does it work if you try uppercase and rebuild?
13:29:46 <tronic_> oh I see.  I think yo'ure right.  When I look at hackage the package name is "Stack-0.3.2"
13:29:49 <tronic_> I will try it now
13:29:53 <confusedwanderer> hyperisco: maybe...
13:30:20 <leo2007> if you had to throw away all haskell books but one, which one would you keep?
13:30:37 <sclv> the haskell report
13:30:42 <hpc> ^
13:30:51 <hpc> or maybe the ghc manual if i trusted my memory enough
13:30:56 <hpc> but the report first
13:32:03 * hackage ats-pkg 3.2.4.2 - A build tool for ATS  http://hackage.haskell.org/package/ats-pkg-3.2.4.2 (vmchale)
13:35:12 <amateur_hour> how much would your haskell programs change without laziness?
13:35:54 <glguy> A lot
13:36:04 <hpc> i wouldn't be able to think about data structures as if they were control flow
13:36:10 <hpc> for instance a list is a reified loop
13:37:07 <hpc> a tree is a series of decisions (if you traverse it to one element), or many other things depending on the operation you choose to traverse it with
13:37:10 <hpc> etc
13:38:40 <leo2007> sclv and hpc, what about printed books?
13:38:42 <hpc> pretty much every time i compose things, i have to think much more deeply about the components
13:38:53 --- mode: glguy set +v aksjdbw
13:39:21 <hpc> like you have a definition for a list
13:39:42 <hpc> you want to use it somewhere, in a lazy language you wonder if it's defined
13:39:54 <glguy> leo2007: If you're just looking for a book to learn Haskell from there's Hutton's Programming in Haskell
13:40:04 <hpc> as in, if you keep evaluating it, will it ever reach a point where it errors or doesn't produce the next element
13:40:46 <hpc> [1..] is defined
13:40:54 <hpc> but in a strict language you now have to wonder if it terminates
13:41:07 <leo2007> glguy: I am not looking for learning material more for a classic book for my bookshelf, which I'd like to keep it small.
13:41:15 <hpc> meaning you can't just think inductively about it, you have to actually reason through ALL of it and determine that it is a finite list
13:41:35 <glguy> leo2007: Just something for people to be impressed with when they see it then?
13:41:47 <leo2007> for myself of course.
13:41:51 <hpc> so the list (collatz someHugePositiveNumber) is not as easy to reason about as [1..] or [1..5]
13:41:57 <Tuplanolla> I imagine that I'd prefer a strict language, but I've never actually tried one.
13:41:57 <Ariakenom> in (lhs <*> rhs) you have to consider how much it costs to evaluate rhs and maybe should manually make it lazy
13:42:06 <crestfallen> @let bb = (<$>) (fmap (++ " !")) -- Solo*narv, I wonder if you're still on. There's something I don't understand about ghci vs ghc fundamentally -- bb does not compile but works fine in ghci 
13:42:08 <lambdabot>  Defined.
13:42:10 <glguy> Oh... well if you're just trying to impress yourself, pick something that impresses you :)
13:42:57 <hpc> i think that's really the key bit, comparing [1..5] to [1..] to (collatz bigNumber)
13:43:05 <hpc> in a strict language you're treating each one wildly differently
13:43:26 <hpc> in a lazy language they're all lists and the next iteration of each list is a very simple computation so they are productive when matched on
13:43:35 <leo2007> somethings it is difficult to convey intention.
13:43:53 <hpc> amateur_hour: hope that made sense
13:44:33 <crestfallen> bb [(Just "Tater"), (Just "Tot")]
13:44:51 <leo2007> I just want to pick the most important book of haskell to buy.
13:45:04 <amateur_hour> it does, and it's very interesting, though I'm not sure I see why as a list it's better than considering a present number plus storage, I'll have to reflect on it a bit more
13:45:28 <crestfallen> > bb [(Just "Tater"), (Just "Tot")]
13:45:31 <lambdabot>  [Just "Tater !",Just "Tot !"]
13:45:51 <amateur_hour> @Tuplanolla we briefly considered purescript at work, that seems interesting for a strict language if you ever wanted to dabble
13:45:51 <lambdabot> Unknown command, try @list
13:46:06 <amateur_hour> oops, no idea why I added an at
13:46:08 <Tuplanolla> I think I'd rather try OCaml, amateur_hour.
13:46:20 <Tuplanolla> Mainly because it integrates better with Coq.
13:46:34 <stilgart> crestfallen: I cannot help you much to understand what happens here
13:46:55 <stilgart> but the code does compile if you provide a type signature for bb
13:47:07 <amateur_hour> yeah we really only considered it because we have some front end dev to do :P
13:47:11 <hpc> leo2007: maybe okasaki's data structure book, if you're dead set on that
13:47:36 <hpc> programming doesn't really have status books like you'd find with like, homer's odyssey on a laywer's bookshelf
13:48:17 <amateur_hour> category theory for programmers recently started being printed on demand, free to read online
13:48:28 <crestfallen> stilgart but why doesn't inference work in ghc ?
13:48:39 <stilgart> this I don't know
13:48:49 <Tuplanolla> @where mmr -- crestfallen
13:48:49 <lambdabot> https://wiki.haskell.org/Monomorphism_restriction
13:49:29 <crestfallen> thanks all I find that maddening 
13:49:36 <__monty__> hpc: How about TAOCP, maybe SICP?
13:49:45 <stilgart> does ghci use some -Xfeature by default?
13:50:49 <stilgart> wow, thanks Tuplanolla 
13:51:10 <glguy> stilgart: type: :showi language
13:51:15 <hpc> haven't read TAOCP, i wasn't a huge fan of SICP
13:51:29 <hpc> though i read it post-haskell so it wasn't really anything new to me
13:52:45 <stilgart> and here it is:   -XNoMonomorphismRestriction
13:52:47 <tronic_> hpc: I started reading haskell and didn't know what "map" was.  I stopped reading for a while and then discovered SICP, and it was a revelation because it actually explained what map was.
13:53:24 <tronic_> this was back in '03 I think...
13:53:43 <hpc> ah
13:54:20 <glguy> It should be pretty common for a book to teach new things
13:54:32 <crestfallen> I've heard wildly successful programmers say that SICP was impossible. I certainly couldn't get through chapt 1.
13:55:12 <tronic_> haha well the haskell book i was reading was Hudak's Haskell School of Expression
13:55:18 <tronic_> which was probably too advanced for me at the time
13:55:50 <amateur_hour> SICP is quite a nice read really, no wonder a lot of universities use it early on in a CS programme
13:56:05 <tronic_> It is typeset very well also haha
13:56:32 <hpc> i was pretty bummed when MIT dropped lisp as their freshman language for python
13:56:59 <hpc> really missed the point of MIT there
13:57:21 <glguy> hpc: Why were you bummed?
13:58:15 <hpc> because theoretically, MIT is one of the best CS schools in the world
13:58:31 <crestfallen> @let vv :: Functor f => f [[Char]] -> f [[Char]] ; vv = (<$>) (fmap (++ " !"))
13:58:33 <lambdabot>  Defined.
13:58:45 <crestfallen> well at least I got this to work
13:58:47 <hpc> and downgrading languages like that is making them yet another python school
13:58:50 <hpc> at least for undergrads
13:59:01 <glguy> So you went somewhere else instead?
13:59:54 <hpc> i never went, but i still liked knowing someplace that taught CS seriously as a science was out there
14:00:13 <hpc> rather than as engineering, or office job number 765
14:01:03 <crestfallen> please explain how to get vv to work over a list of Maybe [Char] .. I've tried to write that into the signature  
14:01:37 <crestfallen> ...numerous times
14:01:55 <crestfallen> sorry for being a knucklehead
14:02:13 <hpc> crestfallen: if you substitute Maybe for f, that might help you see the mistake in the type signature
14:02:51 <hpc> that might improve the error enough that you can solve it the rest of the way yourself
14:03:14 <crestfallen> so it goes into the constraint ...
14:03:22 <crestfallen> thanks
14:03:59 <hpc> i assume you ultimately want vv :: Maybe [Char] -> Maybe [Char]?
14:05:09 <hyperisco> hpc, pressure to be more industry relevant
14:05:30 <hyperisco> I don't know but if my experience in uni is telling then that's a likely explanation
14:05:35 <crestfallen> thanks hpc .. working
14:06:49 <hyperisco> hpc, I heard similar murmuring about dropping Miranda because it seemed irrelevant
14:06:52 <geekosaur> that includes little things like funding / sponsorships
14:06:57 <geekosaur> sadly
14:07:08 <hpc> that sounds likely
14:07:17 <hyperisco> follow the money
14:07:29 <hyperisco> because of the other adage: go where the money is
14:07:55 <Tuplanolla> You also need to get rid of all the hard courses, because students don't like those.
14:08:12 <hpc> the sad thing is, "the money" is now in "devops"
14:08:32 <hyperisco> the stupid part, the subversive part, is the *students* were making these complaints
14:08:45 <hyperisco> and they get elected onto student councils, and then they have the ear of the administrators
14:08:50 <hpc> and when i got that sort of job, functional programming was by far the most relevant prior skill i had going into it
14:08:55 <hpc> BY FAR
14:09:12 <hyperisco> why students should have a say in what they are taught is beyond me
14:09:44 <hyperisco> you pick your course, and beyond that you're there to learn from the people who know
14:10:09 <amx> which country/continent are you talking about
14:10:41 <hyperisco> UoW Ontario
14:10:52 <geekosaur> students want what will get them a job quickly, not what will teach them skils useful beyond that first job
14:11:53 <gonz_> Given how useless and debilitating a lot of university studies seem to be in the US it's a different situation than most in f.e. Europe
14:12:35 <gonz_> To take on massive debt or have your parents pay a shit ton for something that largely isn't actually doing much for you should send anyone into a panic.
14:12:42 <hpc> heh, that reminds me once i was explaining a bug fix to a coworker and the simplest explanation was via calculus
14:12:51 <hpc> their immediate reaction was "oh god, this again"
14:13:17 <Rembane> :D
14:14:00 <hpc> if i could go back in time and be one of those complain-y students, i would probably direct my efforts at data structures
14:14:02 <koz_> hpc: Hear hear.
14:14:11 <koz_> (for everything above)
14:14:30 <hpc> nobody ever learned anything interesting from heaps and hashing algorithms
14:14:34 <hpc> B-trees are where it's at
14:14:41 <hpc> best data structure ever
14:14:58 <bollu> hpc why do you like B trees? they're weird
14:15:01 <hyperisco> I've forgotten just about all of it
14:15:13 <hpc> bollu: it's the data structure that stores something like 90% of the world's data
14:15:21 <hpc> every RDBMS uses it
14:15:22 <bollu> hpc sure
14:15:27 <hyperisco> at one point I could calculate some things about filling hash tables up and comparing linear and quadratic somethings
14:15:31 <koz_> Basically, if you interact with _anything_ that claims to be a database it probably uses it.
14:15:32 <bollu> hpc that's cause disks used to have seek times
14:15:34 <hpc> because it's got fast access through multiple indices, plus fast traversals
14:15:46 <koz_> bollu: In-memory DBs still use B+-trees.
14:15:51 <bollu> koz_ why?
14:16:01 <koz_> (at least according to Andy Pavlo, and when Andy Pavlo says something, I'm inclined to listen)
14:16:12 <koz_> bollu: I can link you to his explanation, but it's in video form.
14:16:12 <hpc> i don't even care about the locality aspect, indexing is just so good
14:17:31 <hpc> even if every row access is its own hard drive seek, O(logn + n) is a really good asymptote for "select x from y where complicated predicates and sub-queries"
14:17:53 <hpc> which... is O(n)
14:18:26 <geekosaur> bollu, because they're a good general purpose data structure for both random / by-key and indexed sequential access
14:18:27 <hpc> and multiple indexes
14:18:41 <hpc> which you're never going to get out of even my second-favorite data structure, balanced binary trees
14:18:44 <Solonarv> > reading wikipedia article on B-trees
14:18:44 <Solonarv> "What, if anything, the B stands for has never been established. "
14:18:46 <lambdabot>  error:
14:18:46 <lambdabot>      • Variable not in scope:
14:18:46 <lambdabot>          reading
14:19:02 <hyperisco> we also learned AVL and Red Black trees… forget all those too
14:19:18 <hyperisco> but being able to balance a tree is useful
14:19:46 <bollu> hyperisco splay trees <3 
14:19:48 <hpc> i think i was talking about B+ trees this whole time, but close enough :D
14:20:02 <buttons840> will the haskell police take me away if I make a Storable instance that doesn't implement peek?
14:20:26 <hyperisco> buttons840, where do you live?
14:21:16 <amx> take your hands away from the keyboard and put them were i can see them
14:21:40 <hyperisco> "I never compiled it officer I swear!"
14:21:41 <Solonarv> Just so we can send you chocolates for being so original, of course. We wouldn't use that address to come arrest you. Nuh-uh.
14:22:01 <geekosaur> it's not clear how much use such a thing is, but as long as it's not a bomb lurkingwithin a published library (I could see it in a program making use of specific C APIs where it's only useful in one direction) it's probably ok
14:22:07 <koz_> bollu: https://www.youtube.com/watch?v=QKNISiRJF-4&list=PLSE8ODhjZXjbisIGOepfnlbfxeH7TW-8O&index=2
14:22:23 <koz_> Check out the rest of this video series and the associated course materials too - they are a fascinating insight into how DBs are actually implemented.
14:22:35 <hyperisco> 10 years from now we're reading the headlines "Peek-A-Boo Exploit Exposes Millions"
14:23:00 <hpc> hyperisco: i read something about that about the quic protocol that http/3 is built on
14:23:02 <koz_> bollu: Course page: 15721.courses.cs.cmu.edu/spring2016/
14:23:07 <crestfallen> hpc pulling my hair out
14:23:09 <amateur_hour> I'll be very disappointed if the next spectre vulnerability isn't called 'Spoopy Ghost'
14:23:11 <geekosaur> and, uh, clearly documented so you don't shoot ourself in the foot 6 months from now
14:23:14 <hpc> it sends cryptographic information in the first packet
14:23:24 <geekosaur> *yourself
14:23:26 <hpc> someone said "this is the next 10 years of vulnerabilities"
14:23:45 <buttons840> i'm working with a graphic library, and it has a LoadTexture/Unload
14:24:01 <hpc> crestfallen: where are you at now?
14:24:05 <koz_> bollu: Sorry, _actual_ link: https://15721.courses.cs.cmu.edu/spring2016/
14:24:31 <bollu> koz_ thanks!
14:24:42 <koz_> As a complete aside, I find Andy Pavlo hilarious.
14:25:01 <crestfallen>    vv :: Functor Maybe => Maybe [Char] -> Maybe [Char] 
14:25:05 <buttons840> i'm working with a graphic library, and it has a LoadTexture/UnloadTexture method, so I use a ForeignPtr to ensure UnloadTexture get's called, like you'd expect, but the actual Texture is little more than an integer id to the texture being stored on the GPU, so, I could easily make it peekable, but then you end up having these bad texture ids laying around if you're not careful
14:26:12 <Solonarv> "you can have stale data if you're not careful" is always a problem if you're working with pointers
14:26:21 <hyperisco> saying  Functor Maybe  is a frivolous exercise
14:26:24 <hpc> cool so, you don't need the Functor Maybe constraint
14:26:50 <koz_> Yah, Maybe is already a Functor. As well as many other things.
14:27:23 <hyperisco> if it is a Functor, you don't need the constraint, and if it isn't a Functor your code won't compile anyways
14:27:27 <crestfallen> oh you mentioned that above but I thought you wanted me to hash it out from there hpc :) .. I didn't try it
14:27:29 <buttons840> so, I'm either going to leave Storable's peek method undefined, or just use arbitrary functions without making it Storable -- which is perferrable?
14:27:37 <Solonarv> the latter, IMO
14:27:43 <koz_> _Definitely_ the latter.
14:28:01 <koz_> If you can't keep typeclass promises, you should really not be an instance unless you have a _very_ good reason.
14:28:20 <hyperisco> buttons840, preferable is something like  error "peek not implemented for MyType"
14:28:24 <hpc> crestfallen: hmm, here's something that might help - imagine that you don't know it's going to be (++ "!") that you're applying to the inner strings
14:28:28 <koz_> Especially if you expect people who aren't you to use it.
14:28:41 <hyperisco> buttons840, assuming avoiding this instance altogether is off the table
14:28:42 <Solonarv> the main point of Storable is for libraries to provide datastructures, functions etc. that can work fr any Storable; those libraries will definitely call 'peek' and crash, because that's literally half the point of Storable
14:28:45 <hpc> crestfallen: that would give you some kind of vv' :: (String -> String) -> Maybe String -> Maybe String
14:28:54 <hpc> crestfallen: and vv = vv' (++ "!")
14:29:02 <hpc> vv' might be easier to define
14:29:03 * hackage fast-arithmetic 0.6.4.2 - Fast functions on integers.  http://hackage.haskell.org/package/fast-arithmetic-0.6.4.2 (vmchale)
14:29:25 <hpc> see if you recognize that type signature in some other functions you've used before ;)
14:29:54 <buttons840> k, i'll just make my own Storable-like functions, but not actually make a Storable instance
14:29:56 <hyperisco> any time you write an error message, consider whether an idiot could figure out what is actually wrong by reading it
14:30:14 <hyperisco> even assuming they have access to your source code and the grep tool
14:30:17 <hpc> consider being that idiot with a library you didn't write too
14:30:37 <hyperisco> well, I was going to say because that idiot could be you come a year from now
14:30:38 <Tuplanolla> How do you feel about error messages long enough to be books?
14:30:45 <koz_> s/a year/a week/
14:31:08 <Solonarv> s/could/will/, too
14:31:09 <hyperisco> I think my code memory is maybe a month long
14:31:13 <hpc> Tuplanolla: like long stack traces? as long as the information i need is at the top or bottom i can get used to them
14:31:39 <koz_> Tuplanolla: I am sympathetic to people not liking the kind of incoherent error spew Java NPEs produce.
14:31:49 <hpc> or if they're like ghc error messages and full of location and descriptive information in equal measure
14:31:50 <hyperisco> Tuplanolla, I've been baptised in the slurry of C++ error messages.
14:32:01 <koz_> Involving thousands of BuilderFlyweightSingletonOptionalManagers
14:32:32 <Tuplanolla> More like several paragraphs of written exposition of what actually went wrong.
14:33:20 <Solonarv> ack, I've seen my fair share of NPEs while writing minecraft mods
14:33:29 <Solonarv> caught and re-thrown a couple of times, too
14:33:30 <hpc> when i am debugging an error, i like location info and not being lied to
14:33:44 <hyperisco> "It all started 18 years ago when I first stumbled across a brightly yellow 'PHP For Dummies' book on my father's bookshelf…"
14:34:04 <Solonarv> Tuplanolla: might want to have a short summary at the top/bottom, tbh
14:34:08 <koz_> Solonarv: I can do better. I've had my university's CMS vomit two-page NPE stacktraces at me.
14:34:13 <koz_> (and not even once)
14:34:15 <hpc> if your code's ability to debug itself ends at stacktrace("dunno lol"), that's better than leading me astray with a short message
14:34:27 <Solonarv> *only* two pages? hah!
14:34:37 <hpc> ideally you would stacktrace("dunno lol but here's my variables\n" ++ everything_in_scope)
14:34:40 <koz_> Solonarv: Two pages on a 1920x1080 resolution screen in my browser.
14:34:46 <koz_> That's a lotta lines.
14:34:48 <Solonarv> oh, that's a big oof
14:35:08 <hyperisco> "… and so you see, that is why the magic method could not find the member you were looking for. A simple matter of naming convention."
14:35:31 <koz_> And people wonder why I don't trust the ICT team anywhere near as far as I can throw them. Which, being that I'm an out-of-shape person, is not far at all.
14:36:02 <hyperisco> Tuplanolla, like that? I might enjoy writing an Easter egg like that sometime.
14:36:22 <Tuplanolla> That's the spirit, hyperisco.
14:39:10 <crestfallen> hpc sorry I don't understand your vv' suggestion
14:39:34 <koz_> crestfallen: The idea is that instead of 'baking in' a particular thing to do, you pass a function which does that thing as an extra parameter.
14:39:37 <hpc> crestfallen: basically it's making the problem a little bit more generic
14:39:44 <hyperisco> koz_, and seeing as the ICT team is also mostly composed of out-of-shape people, there's not much hope for anyone throwing them far.
14:39:58 <hpc> so there's fewer possible definitions that satisfy the type
14:40:27 <koz_> So instead of having 'mapIncrement :: [Int] -> [Int]', we have 'map :: (a -> b) -> [a] -> [b]', and define 'mapIncrement = map (+ 1)'
14:40:41 <hpc> the type of vv' is very similar to the type of a function you've used before
14:40:47 <koz_> (also that too)
14:40:53 <hpc> in fact, it might be the same type just specialized wink wink
14:41:13 <hpc> so you find that function, define vv' as that, and see if it does what you want
14:42:57 <hyperisco> I recommend trying VVVVVV
14:44:01 <koz_> hyperisco: Why not UUUUUUU?
14:44:13 <hyperisco> is that a sequel?
14:44:20 <koz_> s/se/pre/
14:44:22 <stilgart> well, I'm still not master of the universe :(
14:44:36 <koz_> stilgart: Have you tried asking it nicely?
14:44:41 <stilgart> wow, is there a prequel ? really
14:44:42 <hpc> (the solution is going to look stupidly easy in retrospect, but you'll have begun learning type-level thinking in the process)
14:45:04 <stilgart> koz_: you got this title when you finish VVVVVV with no death
14:45:23 <crestfallen> my nomenclature is perfectly fine
14:45:27 <hyperisco> koz_, really? because I can't find it
14:46:25 <hyperisco> guess my problem is I suck too much
14:47:37 <hpc> crestfallen: less about terminology, more about thought process - one of my biggest hangups learning haskell early on was changing the way i think
14:47:54 <hpc> it's hard without the right problems and something pointing you in the right direction :D
14:48:52 <hyperisco> you think programming hardware is hard? try the wetware
14:49:15 <crestfallen> hpc thanks really appreciate it.. I looked at the link re: inference but I cannot understand it. I don't see why an environment for testing/learning allows you to do things that the compiler will not.
14:49:22 <hpc> https://mygaming.co.za/news/wp-content/uploads/2012/09/PC-oil-cooling.jpg - wetware
14:49:37 <Solonarv> my wetware has a bug where it just kind of fails to do things, and it's really hard to debug
14:50:39 <hpc> crestfallen: which link?
14:50:52 <hyperisco> I have troubles waking my wetware from sleep mode
14:51:08 <sm> Solonarv: dropouts between the scheduler and worker nodes ?
14:51:39 <Solonarv> sounds about right
14:51:59 <crestfallen> sorry hpc that was Tupla*nolla  https://wiki.haskell.org/Monomorphism_restriction
14:52:10 <hpc> ah
14:52:18 <hpc> i think that was part of a different conversation
14:52:44 <crestfallen> yeah I was asking about ghci vs ghc
14:52:45 <hpc> or maybe i misread, reading scrollback is hard in this channel
14:52:52 <crestfallen> word
14:52:54 <hyperisco> also the power supply is really finnicky about what it gets
14:53:53 <hpc> hyperisco: i can't find the switch for EU voltage
14:54:06 <crestfallen> hpc but at that point I'm pretty burnt from guessing how to write it
14:55:02 <hyperisco> yeah that's no good, else it'll get the wrong kind of chips
14:55:05 <hpc> try vv = fmap (++ "!")
14:55:41 <hyperisco>    ^^ unused variable
14:56:04 <hyperisco> huh though I lined that up. *shrug*
14:56:06 <hpc> fun fact, in the UK they call it an "intel crispset"
14:56:11 <hpc> hyperisco: lol
14:56:21 <hpc> can't line it up with my eentsy nick
14:57:24 <Lears> MMR is basically interpreting your declarations less charitably for the sake of performance. ghci doesn't offer performance, so it wants to make the opposite tradeoff. Also, it can be enabled or disabled however you prefer in both ghci and source files.
14:59:11 <crestfallen> hpc you mean in a file?
14:59:40 <Eduard_Munteanu> I was recently writing some Go code and wondered if we had anything like select in Haskell. We can probably write one as a function, although we have orElse in STM as a nice alternative.
15:00:03 <hyperisco> what select is that?
15:00:23 <Eduard_Munteanu> hyperisco, C-like select, except you can use it on a bunch of channels
15:00:33 <hpc> crestfallen: as your definition for vv
15:00:45 <Solonarv> `select` isn't a C thing, it's a unix thing (IIUC))
15:00:50 <hyperisco> I don't recall a select in C either
15:00:54 <Eduard_Munteanu> Er, yeah.
15:01:07 <Eduard_Munteanu> POSIX then.
15:01:08 <hpc> i mean, http://hackage.haskell.org/package/select
15:01:10 <rain1> select is a standard C function
15:01:21 <crestfallen> that won't compile
15:01:55 <hpc> crestfallen: vv :: Maybe String -> Maybe String?
15:02:07 <Eduard_Munteanu> Anyway, they made it fairly convenient.
15:02:37 <Solonarv> you should be able to implement that as a function in haskell, too
15:02:44 <crestfallen> yeah with the signature it does
15:02:49 <Solonarv> for most "channel" implementations
15:03:08 <crestfallen> ok thanks one moment please
15:07:02 <Eduard_Munteanu> I figure something along the lines of   data Select = forall a. Read (MVar a) (a -> IO ()) | forall a. Write (MVar a) a
15:07:20 <Eduard_Munteanu> And have   select :: [Select] -> IO ()
15:08:37 <koz_> Eduard_Munteanu: Any reason not to have select' :: Select -> IO () and then define select = traverse_ select' ?
15:09:38 <Eduard_Munteanu> koz_, I guess you kinda need to call a real select on the underlying MVars, although what you said might work with STM's orElse.
15:09:50 <Eduard_Munteanu> *on all the underlying MVars
15:12:54 <koz_> Also, select' should probably be doSelect or runSelect or something.
15:20:56 <koz_> Eduard_Munteanu: Maybe I don't understand exactly what you're after, but wouldn't this work? https://gist.github.com/kozross/28cac7bc29a34cefef00ae237bb19b72
15:26:54 --- mode: glguy set +v JZ
15:31:32 <Eduard_Munteanu> koz_, it won't work with multiple MVars if the first one blocks
15:32:36 <Eduard_Munteanu> Unless you have some way of chaining blocking actions in a special way, like...
15:32:39 <Eduard_Munteanu> :t orElse
15:32:40 <lambdabot> error: Variable not in scope: orElse
15:32:45 <Eduard_Munteanu> @hoogle orElse
15:32:46 <lambdabot> GHC.Conc orElse :: STM a -> STM a -> STM a
15:32:46 <lambdabot> GHC.Conc.Sync orElse :: STM a -> STM a -> STM a
15:32:46 <lambdabot> Control.Monad.STM orElse :: STM a -> STM a -> STM a
15:32:55 <reallymemorable> I have been programming a bit with Python and Postgres and am now starting Haskell.  I have simultaneously had an interest to build a procedurally generated sound project.  Are there good libraries for this in Haskell?
15:33:15 <reallymemorable> Or are there examples of people building interesting things along these lines?
15:36:56 <hpc> reallymemorable: i was just messing with that a few months ago
15:36:57 <hpc> uh
15:37:21 <hpc> i used synthesizer-core and synthesizer-alsa
15:37:41 <hpc> and followed the included example code
15:37:58 <reallymemorable> I am reading about http://www.euterpea.com/ and Tidal
15:38:37 <reallymemorable> I will check those out also thank you
15:39:12 <hpc> if you don't mind using an external tool, i forget the name of the library but it interfaces with soundcollider
15:39:23 <hpc> er, supercollider
15:39:44 <reallymemorable> hmmm ok will investigate thanks
15:41:58 <crestfallen> friend in pm :  https://paste.ee/p/kUaOj
15:47:04 <crestfallen> the error is included ^
15:49:03 * hackage fix-imports 2.1.0 - Program to manage the imports of a haskell module  http://hackage.haskell.org/package/fix-imports-2.1.0 (EvanLaforge)
15:56:10 <crestfallen> I'm getting this Ambiguous type variable error when I comment out the type signature for 'bb'  : https://paste.ee/p/kUaOj
15:57:55 <lyxia> Congratulations, you hit the monomorphism restriction!
15:58:49 <lyxia> since it's just a variable to the left of '=', the inferred type tries to be monomorphic
15:59:17 <lyxia> but there is no way to infer what functors you want to use fmap and (<$>) with
16:02:53 <crestfallen> lyxia, thanks what do you mean by "its just a variable to the left of the '='  ?
16:04:59 <geekosaur> it has no parameters
16:05:27 <stilgart> crestfallen: if you start with "bb l =", then you will be fine
16:05:50 <crestfallen> thanks one moment
16:05:53 <geekosaur> haskell assumes you intended a memoized value binding, and memoizatio only makes sense with a concreet type, so it monomorphizes
16:05:55 <geekosaur> you were pointed at thsi earlier. read it
16:05:59 <geekosaur> ?where mmr
16:05:59 <lambdabot> https://wiki.haskell.org/Monomorphism_restriction
16:07:15 <stilgart> crestfallen: you should go read this wiki page (if you did not already read it a couple of hours ago)
16:07:42 --- mode: glguy set -v ScriptRunner
16:09:45 --- mode: glguy set +v gerwwtnf
16:10:28 <crestfallen> thanks ALL I was being helped in the chat so had time to merely glance at it. really appreciate it, adding a parameter shouldn't be too hard to grasp
16:28:23 <zachk> the haskell type system is like a shining, guiding light in a dark cave
16:52:44 <MarcelineVQ> it's alright :>
16:54:40 <MarcelineVQ> inference is pretty great
17:11:50 <zachk> :)
17:13:49 --- mode: glguy set +v jkieberk
17:48:16 --- mode: glguy set +v basil
18:41:55 <reallymemorable> I just installed Euterpea and ran the `play $ c 4 qn` in the introduction and got this error: CallStack (from HasCallStack): error, called at ./Euterpea/IO/MIDI/Play.lhs:133:54 in Euterpea-2.0.6-sUxZzvXR5hKuIjgYiTYLc:Euterpea.IO.MIDI.Play
18:42:01 <reallymemorable>  and i can't seem to google it
18:44:48 <c_wraith> that error message seems to lack the actual error message
18:46:35 <geekosaur> if null allOutDevs then error "No MIDI outputs!"
18:49:16 <geekosaur> http://euterpea.com/euterpea/setting-up-midi/
19:15:36 <reallymemorable> geekosaur: http://www.donyaquick.com/working-with-midi-on-mac-os-x/
19:15:42 <reallymemorable> im on step 4 here
19:15:47 <reallymemorable> but I dont see the IAC driver
19:15:49 <reallymemorable> where is that
19:17:30 <geekosaur> no idea, I haven't used a Mac in several years
19:18:55 <midi[m]> <freenode_gee "if null allOutDevs then error "N"> did someone say midi
19:19:43 <geekosaur> reallymemorable, https://www.logicprohelp.com/forum/viewtopic.php?t=121976 has some suggestions
19:32:11 * hackage xmonad-spotify 0.1.1.0 - Bind media keys to work with Spotify  http://hackage.haskell.org/package/xmonad-spotify-0.1.1.0 (vmchale)
21:52:33 * hackage total-map 0.1.0 - Finitely represented /total/ maps  http://hackage.haskell.org/package/total-map-0.1.0 (ConalElliott)
22:02:45 <platz> due to backtracking, is an attoparsec parser that just skips chars until it finds a certain steing less efficient than megaparsec (which does not backtracking by default, but supposedly has worse perf thans attoparsec), or even a regex?
22:22:28 <supersaiyan> hello everyone, how would I print one character of word per line?
22:24:26 <dmj`> mapM (\c -> putChar c >> putChar '\n') word
22:26:29 <supersaiyan> dmj` : thank you so much
22:26:43 <dmj`> supersaiyan: np
22:48:05 --- mode: glguy set +v blakee
22:48:13 <blakee> hi
22:49:24 <f-a> Hello, I am having a problem with template haskell http://paste.debian.net/plain/1053046
22:50:12 <f-a> (in the second splicing, I try to obtain a `f a = 8` kind of function)
22:51:12 <f-a> I can of course use [d| $(myName "foo") = \a -> 8 |], but I wondered why the error
23:06:16 <fridge> recommendations for a haskell development environment in linux?
23:06:22 <supersaiyan> hello everyone, how would I print one word of sentence per line?
23:06:45 <f-a> fridge: I use ghcid + vim (or any editor, really) and like it a lot
23:07:07 <f-a> > words "la rana in spagna"
23:07:09 <lambdabot>  ["la","rana","in","spagna"]
23:07:27 <f-a> :t mapM_
23:07:28 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
23:07:34 <f-a> meh
23:07:56 <f-a> :t +d mapM_
23:07:58 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
23:08:01 <f-a> supersaiyan: ^
23:08:09 <supersaiyan> f-a: so use mapM and words?....
23:08:54 <f-a> supersaiyan: yeah, is that enough?
23:08:59 <MarcelineVQ> consider what you already used to print a char per line, what does each part do, how can they help you here
23:09:15 <fridge> f-a: I'll look at ghcid, thanks
23:09:59 <supersaiyan> MarcelineVQ: sounds good.... ill dwell more
23:22:51 <klntsky> by the way, https://wiki.haskell.org/IDEs does not mention neither intero nor ghcid (there are no mentions even on per-editor pages). Is the wiki abandoned?
23:23:40 <MarcelineVQ> the garden is a little weedy
23:27:59 <f-a> now it does include ghcid :P
23:28:14 <f-a> never used intero, so I don't know what to write
