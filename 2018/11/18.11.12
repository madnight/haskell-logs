00:00:57 <mniip> ztf, I'd go for  x == y | EQ <- compare x y = True | otherwise = False
00:02:36 <shachaf> Why?
00:10:18 <mniip> good point
00:10:23 <ztf> What does <- do? can that just be read as if compare x y is EQ, etc..? 
00:10:28 <mniip> they're equivalent with sufficient -O
00:15:58 <mniip> ztf, it's a pattern guard
00:16:14 <mniip> fun x y | pat <- expr = ...
00:17:32 <ztf> ty, found it 
00:34:40 <ion> I like ztf's version, although I'd make both ==s infix.
00:56:32 <shachaf> I'm pretty sure I didn't make up that notation.
01:05:02 <tombusby> Hi, I'm looking for a good way to sort Aeson "Value" types, and we're a bit stumped. I'm wondering if anyone has any suggestions.
01:20:46 <MasseR> tombusby: what kinds of problems?
01:21:16 <tombusby> General ones, there's no default istance of Ord, and defining one is proving challenging
01:22:49 <tombusby> We have a subtree of Aeson types, we'd like to take the Array contructor and sort what's in it, what ordering doesn't matter, only that it's consistent.
01:23:24 <tombusby> because we need to be able to take two trees and check they're the same thing, so as long as the sort produces the same order for both, we don't care what that order is
01:23:34 <MasseR> Luckily aeson provides you the ADT constructors for you
01:24:01 <MasseR> I would create a newtype for Value (to prevent orphan instances), and write a similar Ord instance as the automatic deriving would
01:25:28 <MasseR> A bit boilerplatey, but that's a one time thing
01:25:42 <tombusby> hmm ok, thanks for the suggestion, I'll have a look into it
01:29:05 <tdammers> I'd just hand-write a comparer function and use something like sortBy
01:29:55 <tdammers> another thing possibly worth investigating is converting those Arrays into Sets
01:30:14 <tdammers> though due to the recursive nature of Value, this may not be straightforward
01:30:38 <tdammers> but anyway, the sortBy approach shouldn't be overly difficult
01:31:26 <tombusby> > though due to the recursive nature of Value, this may not be straightforward
01:31:29 <lambdabot>  <hint>:1:36: error: parse error on input ‘of’
01:31:35 <tombusby> this is the issue we're experiencing tbh
01:32:36 <tdammers> that error says you wrote invalid syntax, it has nothing to do with the conceptual difficulties here
01:33:27 <Ariakenom> tdammers: they tried to quote you :p
01:33:42 <Ariakenom> Wasn't supposed to be code
01:34:29 <tdammers> oh
01:34:32 <tdammers> right
01:34:52 <tdammers> oh haha, that was lambdabot, didn't get that part
01:35:02 * tdammers sits in a corner and weeps
01:35:24 <tdammers> anyway, so try to write compareValues :: Value -> Value -> Ordering
01:36:21 <tdammers> it's cumbersome but trivial for the scalars
01:36:30 <tdammers> (Null, Number, String, Boolean)
01:37:03 <tdammers> while for Array and Object, you need to recurse via orderBy
01:48:36 <tombusby> tdammers: ok thanks, I think this is a big hint in the right direction. thanks for the assistance.
02:12:16 * hackage structured-cli 2.3.0.0 - Application library for building interactive console CLIs  http://hackage.haskell.org/package/structured-cli-2.3.0.0 (erick)
02:16:59 --- mode: glguy set +v sisoteuz
02:18:16 <sisoteuz> For example having data Obj = Obj { x :: Int, y :: Float }. If my json is {“x”:1,”y”:2.4} it works but if x and y are reversed it doesn’t. 
02:19:11 <sisoteuz> Because of my implementation of :*: which deserialise “in order”. Any ideas on how to achieve this ?
02:20:06 <mniip> usually the way to go with json is to first deserialize it into a proper AST/Tree and then do lookups on it
02:21:14 <sisoteuz> Here you go :) I was thinking of some sort of intermediary structure which makes more sense now 
02:21:23 <sisoteuz> Thanks mnip will try that 
02:23:35 <sisoteuz> So my generic deserialisation function would take that AST/tree as argument and return the representation of my type ?
02:23:49 --- mode: glguy set +v __Lorn__
02:24:05 <__Lorn__> anyone? :D
02:30:18 --- mode: glguy set +v __Lorn__
02:38:51 --- mode: glguy set +v akfp
02:39:32 <akfp> I need a parser that matches against a huge list of strings.  Does anyone know a megaparsec functoin for this that would work like a trie?  Does megaparsec fix this internally?
02:40:46 <akfp> I mean so that (string "abcd" <|> string "abbccd") is optimized to something like ("a" *> (string "bcd" <|> string "bbccd"))
02:40:52 <phadej> it isn't
02:41:31 <tdammers> megaparsec can't optimize like that because it's not semantically equivalent
02:41:49 <phadej> usually you match on a something like `some (satisfy isAlphaNum)` and then check if the result is "valid"
02:42:03 <phadej> that's not the same either; though
02:42:20 <Ariakenom> Someone just mentioned advent of code. Does anyone have tips or resource on that type of code puzzles in haskell?
02:42:34 <tdammers> the former, when presented with the input "abbcd", will fail, because it will first start parsing the left alternative, consuming "ab", and then fail to parse "c"; after that, it will try the second alternative, but the first alternative has already consumed "ab", so it tries to match "bccd" with "abbccd", which fails too
02:42:38 <Ariakenom> I can contribute interact for stdin -> stdout
02:42:49 <Ariakenom> % :t interact
02:42:49 <yahb> Ariakenom: (String -> String) -> IO ()
02:43:11 <akfp> tdammers: no string does automatic fallback.
02:43:36 <akfp> but try string "abcd" <|> string "abbccd" then.
02:43:39 <tdammers> akfp: looks like you're right.
02:43:49 <tdammers> still, that would be kind of hard to detect, wouldn't it
02:44:10 --- mode: glguy set +v fen
02:44:20 <akfp> I need a solution for the common case of matching against a large set of strings.  Like fgrep.  fgrep is even a separate utility in unix, so this is hardly an uncommon case.
02:44:23 <tdammers> especially because megaparsec doesn't construct an AST for the parser which could then be scrutinized
02:44:48 <tdammers> maybe it could be solved with RULES, but I don't think megaparsec has any for this specific case
02:45:07 <tdammers> personally, I'd write some sort of `trie` combinator myself
02:45:12 <akfp> I don't really need megaparsec to fix this for me, I need a solution for my problem.
02:45:19 <Ariakenom> yes, an explicit optimization is better anyway.
02:45:31 <tdammers> well, write trie :: [String] -> Parser String yourself then
02:45:35 <akfp> yes, so that's my second problem.  How can I write a trie that uses <|> as the node in the tree?
02:45:47 <tdammers> you don't
02:45:56 <tdammers> you explicitly list the strings you want to accept
02:46:22 <mniip> akfp, my best guess would be to 
02:46:23 <tdammers> I don't think you can trivially generalize this to arbitrary parsers
02:46:36 <mniip> pick up a Trie implementation that allows you to detect the tree structure
02:46:46 <mniip> pump your strings into the trie, and then fold the trie into a parser
02:47:23 <tdammers> yeah, once you have your strings in a trie, writing a parser that follows that structure shouldn't be too difficult
02:47:24 <akfp> yes something like that sounds right.
02:47:30 <fen> the time evolution of systems is specified by partial differential equations, which are the dependency of the time evolution of vectors variable on thier derivative. these are "local" in nature, where systems of interacting components shares the property of physical systems that changes originate at some location or variable and propagate through the system along edges representing dependence between variables, which rarely include all
02:48:03 <fen> in order to ensure the stability of such systems, bounds are placed on the rate of information flow wrt timestep
02:49:13 <fen> this is again to do with the locality of a change in the value of some variable, and the rate which it propagates through the system, where the temporal resolution must be sufficient to ensure its stability. 
02:49:36 <fen> this is related to the notion of "characteristic" flows
02:50:03 <fen> this is the motivation for the generality of the solution sought by local stencil convolutions on graphs
02:50:58 <fen> the stable simulation of any system described in terms of partial differential equations is intrinsically to do with local interactions on graphs
02:53:04 --- mode: glguy set +v taeyun
02:54:22 <fen> the fact that graphical models, neural networks and the languages they are written in also form graphs is a happy coincidence, and where they also depend on local interactions, a local convolution framework is also beneficial 
02:55:27 <fen> it is this ability to provide an interface for local interactions on graphs which is provided by the Pointer Comonad
03:09:27 --- mode: glguy set +v fen
03:11:10 <fen> Pointers not only form a Comonad, but a Monad aswell, and are special in this respect, and possibly a correspond Pointer representation exists for all datatypes which satisfy this property
03:11:52 <fen> notably, NonEmpty, and Free NonEmpty. while lists do not have a valid Comonad. 
03:12:42 <fen> this distinction motivates functions which handle recursion schemes for these datatypes. 
03:14:37 <fen> so far, extending the Traversable class to support partial traversal, (Zippers, which form the basis of the one hole context (derivative) fundamental to Pointers, giving rise to their Monad and Comonad instances) has used "safe" loops, which are slower than direct recursion using pattern matching
03:16:26 <fen> it is essential to derive a way to convert between these representations so that the Compiler can convert between safe, and faster representation automatically, to provide a more useful API for the definition of the Graph superclass to Pointer.
03:54:24 <rain1> hi
03:54:34 <rain1> this isn't strictly haskell but I was hoping i could ask here about type systems?
03:57:29 <cocreature> rain1: probably fine to ask here
04:10:46 --- mode: glguy set +v __Lorn__
04:14:43 <__Lorn__> anyone knows how can I extend `zip` to accept three parameters?
04:15:20 <cocreature> :t zip3
04:15:22 <lambdabot> [a] -> [b] -> [c] -> [(a, b, c)]
04:15:26 <cocreature> ^ __Lorn__ 
04:15:53 <__Lorn__> nice, I see. thank you
04:16:39 <cocreature> ofc you can also just use two calls to "zip" but then you end up with a nested tuple
04:16:44 <cocreature> :t \a b c -> zip a (zip b c)
04:16:46 <lambdabot> [a1] -> [a2] -> [b] -> [(a1, (a2, b))]
04:17:11 <lavalike> :t unzip3
04:17:13 <lambdabot> [(a, b, c)] -> ([a], [b], [c])
04:17:19 <lavalike> they thought of everything
04:18:15 <geekosaur> well, there is one wart. one would think one might be able to constructively extend tuples, but no; they're not list-like
04:18:48 <geekosaur> so given (x,y) the only way to get (x,y,z) is disassembly and reassembly
04:19:03 <__Lorn__> I see, yep
04:20:54 <cocreature> the fact that we can’t define tuples inductively while getting a contigous memory layout always makes me sad
04:21:39 <__Lorn__> haha, yes, it's a bit of additional pain 
04:24:55 <Ariakenom> well you could, right. you can copy a bunch
04:25:36 <infinisil> :t (,,,,,,)
04:25:38 <lambdabot> a -> b -> c -> d -> e -> f -> g -> (a, b, c, d, e, f, g)
04:31:52 <geekosaur> plus "so what differentiates this from a list?"
04:34:51 <Athas> Sixten supports this, kinda!
04:37:26 --- mode: glguy set +v rckd
04:37:38 --- mode: glguy set -v rckd
04:38:24 <fr33domlover> Does HashMap do fusion? If I M.map or M.traverse several times on the same map, are they fused into 1 traversal of the hashmap being done?
04:38:44 <fr33domlover> *traverse
04:39:26 <fr33domlover> e.g. M.map (+1) $ M.map (* 2) m
04:40:03 <hpc> try it, see if they compile to the same thing
04:42:51 <lyxia> fr33domlover: you usually need RULES for this, so you can see whether there are any in the source
04:43:41 <opqdonut> if those use fromList/toList, you might get list fusion
04:43:59 <fr33domlover> Thanks hpc, lyxia, opqdonut :)
04:45:24 <opqdonut> nah it's a straightforward structural recursion: http://hackage.haskell.org/package/unordered-containers-0.2.9.0/docs/src/Data-HashMap-Strict.html#mapWithKey
04:45:25 <fr33domlover> lyxia, hmm no use of RULE at all in the package
04:45:30 <fr33domlover> I guess no fusion then
04:45:37 <opqdonut> yeah
04:45:48 <fr33domlover> But they have a TODO in the code to improve the rules
04:45:53 <fr33domlover> So maybe in the future ^_^
04:46:24 <opqdonut> c.f. http://hackage.haskell.org/package/containers-0.6.0.1/docs/src/Data.Map.Strict.Internal.html#map
04:46:28 <opqdonut> "map/map" forall f g xs . map f (map g xs) = map (\x -> f $! g x) xs
05:00:46 * hackage massiv 0.2.3.0 - Massiv (Массив) is an Array Library.  http://hackage.haskell.org/package/massiv-0.2.3.0 (lehins)
05:20:07 <NinjaTrappeur> Hey, is there any way to see how many packages are part of Hackage? (ie. a total count)
05:22:55 <amx> NinjaTrappeur: click on browse
05:22:58 <amx> Showing 1 to 50 of 13,241 entries
05:23:21 <NinjaTrappeur> oh, I missed this. Thanks amx!
05:23:27 <amx> yw
05:36:00 <jebes> Does anyone here use erc to connect to a znc server multiple times?
05:43:52 <jebes> oops thought i was in #emacs
05:43:53 <jebes> sorry
05:50:16 * hackage tomland 0.5.0 - Bidirectional TOML parser  http://hackage.haskell.org/package/tomland-0.5.0 (shersh)
05:53:10 --- mode: glguy set +v gabriel_vasile
06:02:37 --- mode: glguy set +v gabriel-vasile
06:13:12 <gabriel-vasile> hello
06:16:31 <maerwald> welcome
06:33:09 <asheshambasta> Hi, does anyone know where to find error logs etc. from xmonad?  I'm writing a simple function but I cannot really see where any output from xmonad goes. 
06:34:56 <geekosaur> wherever the session log goes. traditionally this is the text console if you use startx, or ~/.xsession-errors with a display manager. systems that use journald often change this, systems that use systemd may limit output even if they don't redirect to journald
06:39:01 <asheshambasta> geekosaur: ah, thanks! That helps.
06:50:22 <asheshambasta> I seem to have run into https://github.com/haskell/process/issues/46 which is a bummer. 
06:51:11 <asheshambasta> I'm trying to make xmonad detect what to do with xrandr depending on the wifi ssid's in range and whether or not my computer has an active ethernet connection (I move with my laptop between my home office and my office-office)
06:51:38 <asheshambasta> the possibilities are interesting nonetheless.
06:52:28 * geekosaur sighs. people still don't understand the posix process model
06:52:36 --- mode: glguy set +v Orbstheorem[m]
06:52:59 <asheshambasta> geekosaur: is there something I'm doing wrong? 
06:53:08 <Orbstheorem[m]> I'd go for udev instead
06:53:09 <geekosaur> I mean that bug you linked
06:53:38 <Orbstheorem[m]> And if you're using networkmanager, query network manager for the current SSID or network
06:53:40 <asheshambasta> geekosaur: ah yeah, but I'm still a bit stumped by why I'm seeing this error though. 
06:53:57 <asheshambasta> Orbstheorem[m]: yeah thats pretty much what I'm doing. 
06:54:11 <geekosaur> actuallm, if it's xmonad, I'm guessing you're using the normal process calls
06:54:20 <asheshambasta> 1. `nmcli -c no device` -- parse for "ethernet connected"
06:54:28 <geekosaur> they won't work and will fail the way you see, bcause xmonad sets up subprocess autoreaping
06:54:32 <asheshambasta> 2. `nmcli -c no device wifi` -- parse for ssid's 
06:55:01 <asheshambasta> if 1 is true and 2 contains office-wifi ssid, assume 2 displays connected, run xrandr with office options, and similarly for home. 
06:55:02 <Orbstheorem> asheshambasta: Over here ^^/
06:55:32 <cocreature> changing the xrandr config based on the wifi ssid seems really weird :)
06:55:56 <geekosaur> http://hackage.haskell.org/package/xmonad-contrib-0.15/docs/XMonad-Util-Run.html has replacements for some of it that work
06:55:57 <asheshambasta> cocreature: I could probably also just do this with the xrandr output. 
06:56:10 <Orbstheorem> asheshambasta: Else you could try matching your screen's EDID UUID
06:56:37 <Orbstheorem> That's a cleaner solution
06:57:04 <asheshambasta> Orbstheorem: yeah, true
06:57:09 <asheshambasta> geekosaur: thanks for the pointer. 
07:19:33 --- mode: glguy set +v __Lorn__
07:24:51 <asheshambasta> geekosaur: yeah, that works. I'm now parsing the xrandr output instead. 
08:12:53 --- mode: glguy set +v Sagiliste_
08:23:16 * hackage type-of-html 1.4.0.2 - High performance type driven html generation.  http://hackage.haskell.org/package/type-of-html-1.4.0.2 (knupfer)
08:24:46 * hackage yesod-markdown 0.12.4 - Tools for using markdown in a yesod application  http://hackage.haskell.org/package/yesod-markdown-0.12.4 (PatrickBrisbin)
09:01:27 <kuribas> does anyone use sql like compehensions?
09:02:02 <kuribas> are they worth it over normal comprehensions plus list functions?
09:04:10 <hpc> not really
09:05:47 <kuribas> it feels like the lisp loop macro, to much syntax for to little gain
09:06:12 --- mode: glguy set +v akfp
09:06:25 <akfp> give me your best reasons for why Data.Tree is lacking Semigroup and Monoid instances
09:07:55 <maerwald> akfp: what do you set rootLabel to? for mempty?
09:08:20 <maerwald> Monoid a constraint?
09:08:32 <akfp> I guess so.
09:08:35 <maerwald> Now you are restricted...
09:08:38 <kuribas> akfp: it dorsn't obey monoid laws?
09:09:16 * hackage type-of-html 1.4.1.0 - High performance type driven html generation.  http://hackage.haskell.org/package/type-of-html-1.4.1.0 (knupfer)
09:09:39 <kuribas> particularly (a <> b) <> c == a <> (b <> c)
09:12:05 <akfp> kuribas would:  Eq a => Semigroup (Tree a) or (Ord a, Eq a) => Semigroup (Tree a) work?
09:12:39 <akfp> ah, you mean the rootLabel is the problem..
09:13:06 <kuribas> akfp: there is no garatnee it's balanced, even with those constraints
09:14:38 <Solonarv> IIRC Tree is applicative, so you *could* give it a monoid instance that way
09:15:37 <kuribas> liftA2 (<>) ? 
09:16:07 <kuribas> what's mempty then?
09:16:20 <maerwald> Probably only Semigroup
09:16:46 <kuribas> right
09:17:22 <cocreature> pure mempty
09:18:00 <maerwald> then you have to add a constraint for a
09:18:20 <cocreature> sure but you have to do that for (<>) = liftA2 (<>) as well
09:18:45 <cocreature> > mempty :: Ap Tree (Sum Int)
09:18:47 <lambdabot>  error:
09:18:47 <lambdabot>      Not in scope: type constructor or class ‘Ap’
09:18:47 <lambdabot>      Perhaps you meant one of these:
09:18:56 <cocreature> @let import Data.Monoid
09:18:58 <lambdabot>  Defined.
09:19:00 <cocreature> > mempty :: Ap Tree (Sum Int)
09:19:03 <lambdabot>  error:
09:19:03 <lambdabot>      Not in scope: type constructor or class ‘Ap’
09:19:03 <lambdabot>      Perhaps you meant one of these:
09:19:09 <MarcelineVQ> too new
09:19:12 <cocreature> % mempty :: Ap Tree (Sum Int)
09:19:13 <yahb> cocreature: Ap {getAp = Node {rootLabel = Sum {getSum = 0}, subForest = []}}
09:20:15 <maerwald> So I guess the reason is that if you want monoid/semigroup, you are restricting 'a' and making the data less general
09:20:39 <maerwald> And the feature is not really that interesting
09:23:01 <kuribas> what does the applicative instance do?  tree search?
09:24:05 <lyxia> it puts one tree in place of every leave of the other
09:27:54 <maerwald> That doesn't sound like a very common thing to do :P
09:28:03 <Welkin> I thought warp is supposed to use http2 by default if the connecting client supports it, but it's not
09:28:06 <Welkin> what with that?
09:28:16 <Welkin> Or is there something I have to do to enable it?
09:29:08 <barrucadu> Is this a valid instance of Semigroup for tree? `instance Semigroup a => Semigroup (Tree a) where (Node a1 xs) <> (Node a2 ys) = let go (x:xs) (y:ys) = x <> y : go xs ys; go xs [] = xs; go [] ys = ys in Node (a1 <> a2) (go xs ys)` ?
09:29:16 <barrucadu> I'm not sure what it'd be useful for though
09:29:39 <mniip> maerwald, think about it
09:29:46 <mniip> a tree is like [Bool] -> a
09:30:44 <mniip> except it's somehow the converse
09:31:25 <mniip> [([Bool], a)]
09:31:40 <royal_screwup21> sigh I'm dying, my language engineering course in haskell is killing me :(
09:32:45 <royal_screwup21> I have the next  week to recover, hopefully I can turn things around...
09:32:49 <berndl> language engineering?
09:33:10 <berndl> Is that a fancy way of saying compiler course?
09:33:27 <royal_screwup21> berndl: yeah, things like shallow embedding/deep embedding, writing parsers, combinators and all that
09:33:34 <hpc> it sounds like it's more on the side of designing the language too
09:33:43 <hpc> a typical compiler course has the language pre-defined
09:34:23 <Welkin> implement the C language in java
09:34:27 <berndl> royal_screwup21: what books are you using?
09:34:39 <royal_screwup21> i really don't like it, for a number of reasons. (1) the course is so niche, googling for stuff leads me nowhere. All I have is my prof's notes.
09:34:44 <Welkin> I think that is what students had to do in some compiler course at my uni
09:34:48 <Welkin> I never took it though
09:34:51 <Welkin> sounded dumb
09:35:28 <royal_screwup21> i brought up this issue with my prof, he was like "oh, so you're saying we don't provide you with enough support blah blah". I'm like, no, and I gave a concrete example of why it might be a better example to teach something well established, as opposed to the cutting edge thing he's written papers about.
09:36:06 <royal_screwup21> for example, if you're studying baye's theorem, and all you're given is the formula, it might not seem intuitive why the formula is the way it is
09:36:30 <geekosaur> not sure I agree. actually designing languages, including restricted ones like configuration file languages, is something far too people understand
09:36:52 <hpc> far too few?
09:36:59 <royal_screwup21> but BECAUSE it is well established, you have multiple avenues of information. And if you google aggressively, you'll find that you can baye's theorem with probabilistics trees which is much more intuitive.
09:37:18 <hpc> geekosaur: i would even s/including/especially/ in that sentence
09:37:20 <royal_screwup21> the same can't be said of this course. I only have my prof's notes, and if I don't understand it, I'm basically screwed
09:37:35 <tolt> I'd kill to have taken a novel cs class while I was going to school
09:37:36 <geekosaur> yeh
09:37:49 <hpc> the most novel course i took was relational algebra
09:38:00 <maerwald> royal_screwup21: Teachers applying unnatural pressure, because they can't figure out what curiosity and motivation is :)
09:38:17 <hpc> it mentioned "functional dependencies" in passing
09:38:25 <tolt> royal_screwup21: definitely understand your frustrations though
09:38:32 <MarcelineVQ> I wonder if complaining to a prof has ever lead a human to happyness.  It's untrue that there's no support though, the things you mentioned are daily topics here and in other channels on this network
09:39:12 <royal_screwup21> maerwald: when I made my example, he was like "oh, so you want to me teach you stuff that was taugh 15 years ago!?". I was like sure, it's well established, and there's a slim I'll ever feel stranded
09:39:16 <royal_screwup21> my case*
09:39:26 <tolt> MarcelineVQ: I'm not sure those are the most acceptable sources for a group of students taking a class
09:39:50 <MarcelineVQ> sources?
09:40:26 <tolt> "it's untrue that there's no support" I don't think irc is used by most students....
09:40:38 <hpc> the kind of things we like to discuss here don't translate well to coursework things
09:40:41 <MarcelineVQ> ah, I'm not saying that to most student
09:40:41 <royal_screwup21> i've found irc super useful :)
09:40:53 <royal_screwup21> well
09:41:24 <Welkin> I took classes to learn interesting things and work on rewarding and challenging projects, not to get a grade
09:41:36 <tolt> Sure, but I'm agreeing with royal_screwup21. There very well might not be enough resources for students outside of the class and I don't think "well people talk about it on irc" is a great resource for them
09:41:52 <maerwald> royal_screwup21: most teachers use pressure for two reasons: 1. it's a poor substitute for motivation and they don't know how to motivate people (not entirely their fault), 2. they think they have to prepare you for your work life, whatever that means (also not entirely their fault)
09:41:52 <maerwald> I've told them before that it's total nonsense and some... surprisingly... agreed :>
09:42:08 <Welkin> if the class was boring I dropped it or just never went to class
09:42:23 <royal_screwup21> Welkin: how'd you pass then? :(
09:42:38 <Welkin> I use about 5% of what I learned in classes in my work
09:42:39 <geekosaur> my point there si that tsi doesnt' mean the class is abd, it means the class and its supporting information should be way more common
09:42:45 <MarcelineVQ> Aha, okay I should have used more words. What I meant by those being daily topics, is that if you ask about them people will jump to discuss them with you, not just that they're often spoken of.
09:42:46 <Welkin> the other 95% I learned elsewhere or on my own
09:42:53 <geekosaur> if you use "but nobody else does it" as excuse, then nobody else will ever do it
09:42:59 <Welkin> royal_screwup21: I failed a lot of classes
09:43:17 <Welkin> I eventually left uni after 4 years anyway since it was not a good use of my time any more
09:43:30 <hpc> i have used...
09:43:38 <hpc> computational classes (regexes / cfgs / turing machines)
09:43:41 <royal_screwup21> oh true, the class isn't bad...it's challenging, and so are a lot of other courses. It's just that this one's unique because I'm very very dependent on my prof's notes, and nothing else
09:43:47 <hpc> a bit of prolog stuff translated back to haskell
09:44:07 <hpc> LL/LR parsing?
09:44:13 <hpc> and a little bit of yacc knowledge
09:44:19 <hpc> i think that's it
09:44:46 <hpc> i have used stuff i learned in that relational algebra class, so i guess half credit for that because i learned it out of class first
09:44:47 <Welkin> the best classes were microcontrollers and philosophy, anthropology, physics
09:44:53 <Welkin> most of the engineering classes were dreadful
09:45:20 <royal_screwup21> Welkin: out of curiosity, did you attend uni in the US?
09:45:53 <Welkin> yes
09:47:39 <Welkin> so does anyone know about how to get http2 working with warp, or am I misunderstanding how its supposed to work by default?
10:01:26 <Welkin> if I use `forkIO` will the thread's memory be released if it dies?
10:02:04 <geekosaur> yes
10:03:22 <geekosaur> although if you're holding a ThreadId, you probably need to (presumably test and) drop it at some point
10:03:57 --- mode: glguy set +v fen
10:04:00 <Welkin> if I write several messages to a Chan, but there are no consumes for a while, then the first consumer comes along and reads a duplicate channel (using dupchan), what happens to all of the previous messages?
10:04:06 <Welkin> will they be garbage collected?
10:04:12 <Welkin> or will they sit in memory forever?
10:04:27 <Welkin> no consumers*
10:06:51 <Shockk> is there a syntax similar to the applicative style, but for monadic data flow instead of applicative data flow? let me give an example:
10:07:50 <Shockk> in the applicative style I might write:   Branch <$> compoundParser <* charParser '?' <*> exprParser .. etc etc
10:08:19 <Shockk> but I'd like to replace code like:
10:08:46 <Shockk> do { x <- whatever; monadicAction x }
10:08:59 <geekosaur> @undo do { x <- whatever; monadicAction x }
10:08:59 <lambdabot> whatever >>= \ x -> monadicAction x
10:09:24 <Shockk> okay I mean, bad example, hang on:
10:09:41 <Shockk> do { x <- whatever; y <- whatever; z <- whatever; monadicAction x y z }
10:09:49 <Shockk> this is closer to my use case
10:10:29 <geekosaur> "do" notation desugars to (>>=) and (>>); Applicative was origially done via Monad with liftM (more or less fmap for Monad, before Functor was a prerequisite) and `ap`
10:10:34 <Shockk> instead I'd ideally like to replace that with something like monadicAction <$> whatever <*> whatever <*> whatever, except that doesn't work for the monadic action 
10:11:24 <geekosaur> :t ap
10:11:25 <lambdabot> Monad m => m (a -> b) -> m a -> m b
10:11:35 <Shockk> hmm 
10:11:36 <geekosaur> :t (<*>)
10:11:38 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:11:59 <Shockk> that looks like it still won't work for my case though
10:12:58 <cocreature> :t \f x y -> join (f <$> x <*> y)
10:13:00 <lambdabot> Monad m => (a1 -> a2 -> m a3) -> m a1 -> m a2 -> m a3
10:13:13 <geekosaur> I think you'll have to provide more detail including what "won't work" means here
10:13:24 <Shockk> oh I think I'm looking for just =<< but with left associativity maybe
10:14:32 <Shockk> is something like that defined in the standard lib?
10:15:38 <cocreature> :t \f x y -> (f =<< x) =<< y
10:15:39 <lambdabot> Monad m => (a1 -> a2 -> m b) -> (a2 -> a1) -> m a2 -> m b
10:15:45 <cocreature> that’s not what you want is it?
10:16:14 <Shockk> yep that is; but without needing to bracket from left to rigth
10:16:16 <Shockk> right*
10:16:39 <cocreature> you sure? you made it sound like you want Monad m => (a -> b -> m c) -> m a -> m b -> m c instead
10:16:52 <geekosaur> @.@pl @undo  do { x <- whatever; y <- whatever; z <- whatever; monadicAction x y z }
10:16:53 <lambdabot> Maybe you meant: unpl pl
10:16:54 <Welkin> what is the way to catch any exception?
10:17:06 <geekosaur> @. @pl @undo  do { x <- whatever; y <- whatever; z <- whatever; monadicAction x y z }
10:17:06 <lambdabot> Plugin `compose' failed with: user error (Unknown command: "@pl")
10:17:06 <Shockk> hmm hang on
10:17:14 <geekosaur> @. pl undo  do { x <- whatever; y <- whatever; z <- whatever; monadicAction x y z }
10:17:14 <lambdabot> (whatever >>=) . ((whatever >>=) .) . monadicAction =<< whatever
10:17:19 <geekosaur> yug
10:17:23 <Shockk> :t \f x y z -> ((f =<< x) =<< y) =<< z
10:17:24 <lambdabot> Monad m => (a1 -> a2 -> a3 -> m b) -> (a2 -> a1) -> (a3 -> a2) -> m a3 -> m b
10:17:32 <Shockk> this? maybe? 
10:17:58 <cocreature> well you’ll have to tell us what you want but it’s not equivalent to the code using "do" that you showed
10:18:04 <geekosaur> Welkin: catch (\(SomeException e) -> ...) ? (or handle, etc.)
10:18:14 <Shockk> it's not? 
10:18:42 <cocreature> Shockk: just look at the type, do you really expect x to be of type (a2 -> a1)? it seems like you want it to be of type "m a1"
10:18:47 <geekosaur> but ou should you shoudl think about whether that's what you really mean, snce sync and async exceptions are very different things in practice
10:19:18 <cocreature> :t \f x y z -> join (f <$> x <*> y <*> z)
10:19:20 <lambdabot> Monad m => (a1 -> a2 -> a3 -> m a4) -> m a1 -> m a2 -> m a3 -> m a4
10:19:39 <Shockk> err hmm, I'm getting muddled up
10:19:40 <cocreature> afaict, this is what you are looking for
10:21:14 <Shockk> cocreature: huh, adding the join worked
10:21:43 <Shockk> not sure I understand it but I'll look up join
10:21:49 <Shockk> :t join
10:21:50 <lambdabot> Monad m => m (m a) -> m a
10:22:15 <ski> @let (<*>>) :: Monad m => m (a -> m b) -> m a -> m b; mamb <*>> ma = join (mamb <*> ma)
10:22:16 <lambdabot>  Defined.
10:23:12 <ski> @type \f x y z -> f <$> x <*> y <*>> z
10:23:13 <lambdabot> Monad m => (a1 -> a2 -> a3 -> m b) -> m a1 -> m a2 -> m a3 -> m b
10:23:29 <ski> (added `infixl 4 <*>>')
10:29:16 --- mode: glguy set +v govno
10:29:33 <govno> whereis a can find Prim.hs ?
10:29:33 <shafox> I am getting Non-exhaustive patterns in function parseRevision in this code: https://gist.github.com/shadow-fox/f330ce7985bcbb0474f777af3447006f . 
10:30:09 <Welkin> geekosaur: what do you mean about sync vs async exceptions?
10:30:34 <Welkin> I'm trying to see what exception gets thrown when a streaming response from warp is broken. I get this "Network.Socket.sendBuf: resource vanished (Broken pipe)"
10:32:11 <cocreature> govno: can you be a bit more specific? where did you get that filename from?
10:32:12 <geekosaur> shafox, what happesn if parseRevision _ [] ?
10:32:26 <[exa]> govno: I always thought that these functions are primitive because they are magically defined by the compiler
10:32:29 <cocreature> Welkin: usually you don’t want to catch all async exceptions. otherwise you end breaking things like C-c
10:33:04 <Welkin> I only want to catch timeouts and this broken pipe esception
10:33:06 <Welkin> exception*
10:33:10 <govno> [exa]: ok, I must understand RTS
10:33:18 <[exa]> govno: but you probably meant this https://hackage.haskell.org/package/ghc-prim-0.5.3/docs/GHC-Prim.html
10:33:33 <lavalike> govno: looks like it's generated https://github.com/ghc/ghc/blob/2c959a1894311e59cd2fd469c1967491c1e488f3/utils/genprimopcode/Main.hs#L221
10:33:43 <lavalike> not sure where a generated version ends up in the docs, if at all
10:34:44 <geekosaur> it's a dummy anyway; everything in it is a built-in, the file exists for documentation and to create info tables for primitive types
10:35:36 <shafox> geekosaur: the otherwise case ? 
10:36:20 <geekosaur> shafox, that still requires (x:xs) to match
10:50:58 <Nolrai> > :t foldl'
10:51:01 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
10:51:12 <Nolrai> :t foldl'
10:51:13 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
10:52:51 <crestfallen> hi, if I may, I've been reading that the "S" in the SKI calculus is a certain implementation of <*>  .  could someone tell me which one it is / where I can read about it more? BTW I find the SKI calculus easier to understand than lambda calculus (I believe I do :) )  thanks
10:53:22 <crestfallen> not implementation, but that it is equivalent ...
10:53:42 <lyxia> <*> for functions
10:54:16 <lyxia> crestfallen: https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#line-822
10:54:40 * ski algebra, not calculus
10:55:04 <Solonarv> % let s x y z = x z (y z)
10:55:04 <yahb> Solonarv: 
10:55:10 <Solonarv> % :t s
10:55:10 <yahb> Solonarv: (t1 -> t2 -> t3) -> (t1 -> t2) -> t1 -> t3
10:55:28 <govno> crestfallen: what I can read about s k i algebra?
10:55:28 <Solonarv> % :t ((<*>) @((->) _))
10:55:28 <yahb> Solonarv: (w -> a -> b) -> (w -> a) -> w -> b
10:56:14 <geekosaur> shafox, if what's bothering you is not wanting to repeat the case there, the correct answer is to omit the otherwise guard and have a catch-all pattern afterward. If all the guard expressions fail, but there are further patterns, it will go on to those; so use a catch-all pattern at the end
10:56:21 <crestfallen> thanks lyxia , Solonarv .. one moment
10:56:25 <zachk> govno, maybe google sk combinators
10:57:04 <crestfallen> I watched some videos but couldn't figure out the connection to <*> in haskell
10:57:40 <shafox> geekosaur: I added parseRevision doc [] = doc. 
10:57:41 <govno> Solonarv: How you combine it?
10:57:45 <geekosaur> except in this case that doesnt work either because there'd be no xs either. which si why the otherwise guard can't fire on []
10:57:51 <geekosaur> yeh
11:01:15 <govno> :t @
11:01:17 <lambdabot> error: parse error on input ‘@’
11:02:11 <geekosaur> it doesn't have a type. you're looking for TypeApplications
11:02:57 <crestfallen> what about iota do people think about it much ? what is the dis/advantage to think in terms of SKI iota et al ?
11:03:09 <Solonarv> oh, the '@((->) _)' business was just to ask about '<*>' for functions specifically
11:03:22 <Solonarv> % :t (<*>)
11:03:22 <yahb> Solonarv: Applicative f => f (a -> b) -> f a -> f b
11:03:49 <Solonarv> '<*>' actually has that type, which is more general
11:04:33 <geekosaur> crestfallen, it's kinda a reductionist approach. I'm not sure it actually accomplishes anything practical, it's mostly a way to see how compact a "language" you can come up with that has the same expressiveness as lambda calculus
11:05:00 <geekosaur> (I is often omitted because you can derive it given S and K, but that was only realized later)
11:05:54 <Solonarv> specifically: SKxy reduces to y, so SKx === I
11:06:57 <crestfallen> excellent thanks geekosaur the notation for SKI seems to gel better for me. Right I == SKK right? 
11:07:25 <Solonarv> SKK, or SKS, or SK(SSSSSS)
11:07:31 <geekosaur> as Solonarv just showed, it doesn't have to be SKK
11:07:36 <shafox> This code run indefinitely : https://gist.github.com/shadow-fox/466e5618497ed7085ee265811a105a3f  it should stop when it reaches at the  end. however it prints the default values. 
11:07:48 <Solonarv> precisely: SKx, for any choice of x, is equivalent to I
11:08:13 <crestfallen> interesting thanks ALL
11:08:38 <Solonarv> SKxy => Ky(xy) => y -- as you can see, it doesn't matter what x is
11:10:15 <crestfallen> so I assume that if we use S, that is applicative order as opposed to normal order? not too clear on this.
11:11:48 <ski> hm, i think "applicative order" and "normal order" allows reducing under lambda, while "by-value" and "by-name" doesn't
11:12:26 <ski> (hm, but if you have already converted to SKI algebra, then i suppose some of your reductions would then correspond to original reductions under lambda)
11:12:58 <crestfallen> ski thanks gotta work on this
11:13:09 * dstolfa wants someone to implement a CAM for Haskell. that would be fun
11:13:20 <crestfallen> sorry if I inadvertently pinged you!
11:13:30 <ski> dstolfa : Categorical Abstract Machine ?
11:13:33 <dstolfa> ski: yep
11:13:42 <dstolfa> ski: it's a horrid IR, but it would be fun to see haskell run on it :-)
11:13:47 <fresheyeball> hey out there
11:13:54 <fresheyeball> I am looking at this http://hackage.haskell.org/package/time-1.9.2/docs/Data-Time-Format.html
11:14:05 <fresheyeball> and not seeing a way to parse a string as a given time zone
11:14:34 <fresheyeball> do I seriously need to decompose my `TimeZone` type into it's name, and then add %Z to my format?
11:15:03 <dstolfa> also the claim that OCaml implements it -- i am sceptical of that since Caml removed it soon after it was first done
11:15:50 <dstolfa> The name Caml has remained throughout the evolution of the language, even though the present implementation has no relation with the CAM.
11:15:52 <dstolfa> i would be right
11:15:59 <dstolfa> (source: OCaml docs)
11:16:50 <jkaye> fresheyeball TimeZone has a Read instance
11:16:53 <jkaye> Or do you mean something else?
11:18:18 <geekosaur> fresheyeball, you do realize thats' a losing case no matter what?
11:18:31 <geekosaur> "IST" has something like 4 possible meanings, for example
11:21:13 <govno> % :t (<$>)
11:21:13 <yahb> govno: Functor f => (a -> b) -> f a -> f b
11:21:28 <govno> % :t (<*>)
11:21:28 <yahb> govno: Applicative f => f (a -> b) -> f a -> f b
11:22:02 <govno> % :t ((<*>) @((->) _))
11:22:02 <yahb> govno: (w -> a -> b) -> (w -> a) -> w -> b
11:23:07 <govno> f (a -> b) it is parametrized
11:24:01 <fresheyeball> geekosaur: are you saying a function like parseFormatAs :: TimeZone -> String -> Maybe UTCTime
11:24:04 <fresheyeball> is not possible?
11:24:54 <geekosaur> oh, no. at least if I understadn the intentof that corect5ly, where you have a well defined timezone and want it to apply to a timezone-less timestamp
11:26:29 <crestfallen> "The choice of reduction strategy determines which terms diverge: normal order vs. applicative order." This is something I never grasped. It came up while looking at SKI. any concrete example appreciated.
11:27:11 <fresheyeball> yeah that is my intent, I want to parse a string without a timezone with a `TimeZone`
11:27:55 <fresheyeball> geekosaur: ^^
11:28:39 <fresheyeball> what I am doing now is parsing it to a ZonedTime (it parses as UTC when there is no zone in the fmt)
11:28:52 <fresheyeball> and then changing out the `TimeZone` in that data structure
11:29:40 <MarcelineVQ> "<Welkin> or will they sit in memory forever?" They will if you don't read them. dupChan will only have messages that came after it was created.  "<Welkin> what is the way to catch any exception?" catch SomeException    may I interest you in merijn's useful library https://hackage.haskell.org/package/broadcast-chan-0.2.0.1
11:30:46 <geekosaur> that or the LocalTime equivalent may be the best you can do
11:31:09 <geekosaur> the C equivalent is even worse: you get to use _tzset to force the local time zone and then parse a "local" time
11:31:53 <fresheyeball> geekosaur: gotcha good enough for me
11:32:25 <MarcelineVQ> Welkin: if it's useful, stm also has broadcast chans
11:35:29 <crestfallen> ok normal order is just what haskell calls lazy evaluation.
11:51:22 <crestfallen> one more question re: SKI . why is it called theoretic or "synthetic" ?
11:51:43 <crestfallen> vs. analytic / model
11:52:26 <Welkin> MarcelineVQ: what do you mean by broadcast chans?
11:53:40 <geekosaur> analytic means you've fitted it to existing data of some kind, theoretic means you've derived / proved it from fundamentals
11:53:41 <Welkin> the way I am considering handling this is to have a single channel that I write to using a key-value pair, where the key is either an ID or a global tag
11:54:08 <Welkin> then each consumer filters the messages for only global ones and the id is it assigned
11:56:26 <crestfallen> hmm,  ok thanks geekosaur 
11:58:10 <geekosaur> and "synthetic" here doesn't man "artificial", it is referring to the word's meaning in logic (for example the thesis / anti-thesis / synthesis construction in logic, derived from ancient Greek explorations of logic)
12:01:01 <crestfallen> right its not like sweet-n-low. :) thanks a lot geekosaur 
12:17:12 <kuribas> yuck, selda generates pretty convoluted SQL output
12:17:50 <kuribas> for a really simple query, it has three levels deep nested select statements.
12:18:33 <kuribas> is there a DB library that doesn't suck?
12:18:39 <Clint> i doubt it
12:19:39 <lavalike> this one looked interesting http://hackage.haskell.org/package/postgresql-typed
12:20:53 <kuribas> we use mysql
12:23:16 <tdammers> I still like writing SQL queries in SQL
12:23:38 <tdammers> and then attach types manually at the SQL / Haskell boundary
12:24:43 <kuribas> tdammers: I was hoping for something like SQL but not using strings
12:24:53 <kuribas> a light layer over sql
12:26:22 --- mode: glguy set +v fragamus_
12:26:36 <fragamus_> hi can someone look at this with me
12:26:37 <fragamus_> https://gist.github.com/fragamus/889030f241f0956bdb630c8305ad8c76
12:27:51 <lyxia> looks like SVG is a typeclass
12:27:56 <tdammers> kuribas: I did make yeshql, which compiles string queries into your executable via QQ (postgresql-simple can also do that), and parses a subset of Haskell's types out of magic comments in the query string (postgresql-simple does not do that)
12:28:21 <kuribas> tdammers: do you support mysql?
12:29:16 <kuribas> oh, you do...
12:29:17 <lyxia> fragamus_: ah no, R2 is the typeclass, maybe?
12:29:56 <fragamus_> lyxia: I really don't know... I need instruction as to how to read this error
12:30:43 <fragamus_> some typeclass is a parameter and it has kind (* ->*)   right
12:30:48 <tdammers> kuribas: well, HDBC does
12:32:01 <kuribas> tdammers: still, what if I want to dynamically modify a query?
12:32:15 <kuribas> for example adding pagination
12:32:34 <tdammers> you'd have to do that dynamically,
12:32:57 <tdammers> although if it's just pagination, most SQL engines (including MySQL) accept query params for LIMIT clauses too
12:32:58 <lyxia> fragamus_: The error says "Diagrams SVG" is expected to be of kind (blabla -> *), one reason for that may be that it is being applied to a thing of type blabla
12:33:14 <int-e> fragamus_: Diagram only takes one argument now... compare https://hackage.haskell.org/package/diagrams-core-1.4/docs/Diagrams-Core-Types.html#t:Diagram (current; V and N are type families) to https://hackage.haskell.org/package/diagrams-core-1.0/docs/Diagrams-Core-Types.html#t:Diagram (around the time of ekmett's blog post)
12:33:29 <lyxia> fragamus_: which is the case here. (Another reason would be that something of type ((blabla -> *) -> bar) is being applied to it)
12:33:34 <fragamus_> ok
12:34:12 <fragamus_> so now all I need to do is look at the two versions of Diagram and update Kmett's code as if I were him
12:34:40 <koz_> fragamus_: Channel your inner Edward.
12:35:00 <lyxia> fragamus_: so R2 has kind ((* -> *) -> Constraint) which is the kind of a typeclass, whereas the code looks like it's treating R2 as a type, and then looking through the different versions of diagrams you can confirm that indeed the definition of R2 changed.
12:35:03 <fragamus_> yes I feel I know shit now
12:38:39 <int-e> fragamus_: at a guess it should be just Diagram SVG, no R2, and what used to be R2 is now V2; the mapping SVG -> V2 is done by a type instance: V SVG = V2.
12:39:05 <fragamus_> nice I'll chase it down
12:39:18 <fragamus_> thanks lyxia and int-e
13:53:46 * hackage limp 0.3.2.3 - representation of Integer Linear Programs  http://hackage.haskell.org/package/limp-0.3.2.3 (amosrobinson)
13:55:48 <Welkin> I'm implementing a presence system and have a few options for doing it. The first approach is: mark the user as online when they connect to an event-stream endpoint, and mark them as offline when the connection is broken. Can you forefee any possible downside to this approach?
13:56:25 <zachk> are you using websockets?
13:56:39 <Welkin> alternatively, I would keep their status up to date every time I successfully ping the client, with a timeout to reset the mback to "offline" if it is unsuccessful
13:56:44 <Welkin> no, server-sent events
13:57:19 <zachk> if it's http endpoints, how do you know they are no longer connected? you would have to have a timeout on the server side if your client is routinely polling
13:57:27 <Welkin> but the second approach would use a lot more resources for no real benefit that I can see
13:57:37 <Welkin> the client is not polling
13:57:52 <Welkin> the server sends a ping to the client to keep the event-stream connection open
13:58:07 <zachk> whats an event-stream connection?
13:58:12 <Welkin> I only know when the connection is broken when I try to send an event and catch an exception (broken pipe)
13:58:22 <Welkin> it is a persistent connection
13:58:26 <Welkin> https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events
13:58:27 * hackage structured-cli 2.4.0.0 - Application library for building interactive console CLIs  http://hackage.haskell.org/package/structured-cli-2.4.0.0 (erick)
13:58:30 <zachk> over http?
13:58:32 <Welkin> yes
14:00:38 <dmwit> Welkin: Some systems I've used make it a trit instead of a bit. "online"/"not seen in a while"/"offline" instead of "online"/"offline". The user has to explicitly set the "offline" status by disconnecting cleanly.
14:01:16 <Welkin> in this case, I only need online/offline
14:01:25 --- mode: glguy set +v weebull[m]
14:01:40 <Welkin> but yes, in the case of an "away" status it would require keeping a timestamp or something as well and checking every time you ping
14:02:08 <hpc> browsers can emit a "this window is closing" event that you can use to offline cleanly
14:02:12 <Welkin> actually, that would require the client to send data back too
14:02:22 <hpc> last i checked it wasn't guaranteed, but that was a really long time ago
14:02:45 <hpc> and in the unclean case you tune the timeout and ping/pong frequency
14:02:52 <weebull[m]> I'm trying to update an old package of mine to the latest stack LTS, and I'm getting some linker errors about ignoring files because the arch is wrong when I stack build. Eventually it fails due to missing symbols. I'm on OSX w/ homebrew installed stack. Anybody have any ideas?
14:03:08 <hpc> maybe starting at 60s or so?
14:03:42 <Welkin> besides that, the other question is where to store the data
14:04:20 <Welkin> if I persist it to disk (postgres) then when the server goes offline or restarts, the data wil be wrong (users set to online when they are offline because I missed their disconnect event)
14:04:20 <tdammers> if you want to make absolutely sure, mandate a working webcam, and use CV to verify that the user is still looking at the app
14:04:39 <Welkin> in-memory (redis) it would have an expiration (timeout) and be deleted automatically anyway
14:05:04 <hpc> Welkin: that status is attached to the connection, so you persist it at the same level the connection itself persists
14:05:16 <Welkin> so, in-memory
14:05:23 <hpc> yeah
14:05:27 <Welkin> and yes I don't need to store it in redis necessarily
14:05:34 <Welkin> redis is quite a pain because everything is a string
14:06:00 <hpc> it's also a whole other external thing to interact with
14:06:05 <Welkin> IntMap perhaps
14:06:42 <Welkin> but that still raises the question of timeouts and how to handle them
14:06:50 <Welkin> redis gives you timeouts for free with expiring data
14:07:46 * hackage hmm-hmatrix 0.1.0.1 - Hidden Markov Models using HMatrix primitives  http://hackage.haskell.org/package/hmm-hmatrix-0.1.0.1 (HenningThielemann)
14:07:48 <hpc> i think i would store when the last ping/pong happened
14:08:26 <hpc> and then for triggering things when it goes offline, either have it synchronously in someplace that's frequently reached
14:08:45 <hpc> or asynchronously once a second or something
14:10:05 <freeman42x]NixOS> is there any online Haskell REPL where I could access Data.Text package?
14:10:50 <Solonarv> for small stuff, you can use yahb - it works in PMs too
14:10:58 <hpc> > Data.Text.pack "lambdabot?"
14:11:00 <lambdabot>  error:
14:11:00 <lambdabot>      Not in scope: ‘Data.Text.pack’
14:11:00 <lambdabot>      No module named ‘Data.Text’ is imported.
14:11:09 <zachk> why do you need that in an online repl? just curious....
14:11:12 <Welkin> > T.pack "hello"
14:11:15 <lambdabot>  error:
14:11:15 <lambdabot>      Not in scope: ‘T.pack’
14:11:15 <lambdabot>      Perhaps you meant ‘BS.pack’ (imported from Data.ByteString)
14:11:36 <Welkin> lambdabot is pretty useless for most things
14:11:48 <Welkin> and an online repl would be the same
14:12:02 --- mode: glguy set +v govno
14:14:26 <Solonarv> @let import qualified Data.Text as T
14:14:28 <lambdabot>  Defined.
14:14:36 <Solonarv> > T.pack "hello"
14:14:38 <lambdabot>  "hello"
14:16:15 <govno> > "hello"
14:16:18 <lambdabot>  "hello"
14:17:27 <govno> I reduce a code
14:20:34 <govno> :t text
14:20:36 <lambdabot> String -> Doc
14:20:53 <govno> :t Doc
14:20:55 <lambdabot> error: Data constructor not in scope: Doc
14:21:22 <c_wraith> it's from some pretty printing library
14:24:59 --- mode: glguy set +v eric8
14:26:32 <eric8> Hi all, is there a better way to use (f :: String -> a) on (x :: Text) than (f . T.unpack $ x) ?
14:27:15 <EvanR> f (T.unpack x)
14:31:50 <EvanR> if you need the f . T.unpack a lot, put it in an auxilliary definition, likewise for T.unpack x
14:32:19 * hackage limp-cbc 0.3.2.3 - bindings for integer linear programming solver Coin/CBC  http://hackage.haskell.org/package/limp-cbc-0.3.2.3 (amosrobinson)
14:37:34 <eric8> Ok but there's not a better backend way to handle the (:: String) to-and-from (:: Text) conversion?
14:38:02 <eric8> (also thank you @ EvanR)
14:38:47 <hpc> what would that better way be? it's hard to get much simpler than pack/unpack
14:40:20 <EvanR> having the conversion there has helped me a lot when understanding code, and bugs of code
14:40:40 <EvanR> badly done automatic conversions are painful to figure out
14:41:32 <wraithm> Is there a Maybe version of (!!) in Prelude? ie. [a] -> Int -> Maybe a
14:41:37 <EvanR> it also helps identify where your performance is going
14:42:16 * hackage gloss-export 0.1.0.2 - Export Gloss pictures to png, bmp, tga, tiff, gif and juicy-pixels-image  http://hackage.haskell.org/package/gloss-export-0.1.0.2 (timoa)
14:43:14 <govno> What can I read about System F ?
14:43:35 <Welkin> you can write your own list indexing function. It's really easy
14:43:47 <wraithm> Sure, of course
14:43:47 <Welkin> just recursively process the list
14:44:04 <wraithm> But I'd rather use whatever is the standard way to do it.
14:44:18 <Welkin> that is the standard way to do it
14:44:27 <Solonarv> I'm not sure if it's in Prelude or Data.List, but there's 'lookup'
14:44:28 <wraithm> Cool
14:44:32 <Welkin> in haskell, everything is recursion, and you will be writing a lot of your own functions
14:44:34 <Solonarv> % :t Data.List.lookup
14:44:34 <yahb> Solonarv: Eq a => a -> [(a, b)] -> Maybe b
14:44:44 <Solonarv> % :t Prelude.lookup
14:44:45 <yahb> Solonarv: Eq a => a -> [(a, b)] -> Maybe b
14:44:47 <EvanR> there are packages with a safe index function
14:44:47 <Welkin> lookup is for association lists
14:44:53 * hackage structured-cli 2.4.0.1 - Application library for building interactive console CLIs  http://hackage.haskell.org/package/structured-cli-2.4.0.1 (erick)
14:44:54 <Solonarv> oh, derp
14:45:20 --- mode: glguy set +v fen
14:45:32 <EvanR> in package `safe' theres atMay :: [a] -> Int -> Maybe a
14:45:53 <dexterfoo> how can i do case-insensitive replace of Data.Text ?
14:46:21 <fen> dexterfoo: what!?
14:46:39 <govno> what I must know about Haskell type system?
14:46:43 <fen> the whole module, or just something of that type?
14:47:40 <wraithm> EvanR: Thanks. That's exactly what I was looking for.
14:47:48 <dexterfoo> fen: something like the Data.Text.replace function, but case-insensitive needle
14:48:05 <govno> How to realize c++ parametric polymorphism in haskell?
14:48:24 <Welkin> dexterfoo: https://hackage.haskell.org/package/case-insensitive
14:48:27 <Welkin> for comparisions
14:48:38 <Solonarv> Depends on what aspect of c++ templates you want to replicate
14:48:53 <Solonarv> for some aspects the answer is "you don't, because that's unsound"
14:49:03 <Welkin> the aspect where they take 5 hours to compile?
14:49:14 <hpc> for just getting started with haskell's type system, i suggest ghci's :t command
14:49:22 <pacak1> Most likely 500 lines of error messages...
14:49:28 <govno> I want compile-time templates in haskell sucj as in C++
14:49:41 <Solonarv> oh that's easy, just lean heavily on generics/inlining/rewrite rules
14:49:53 <dexterfoo> Welkin: hm... not sure that is what i need. i want to do something like search-and-replace functionality in a text editor. replace all occurances of "cat" with "dog". But also replace "Cat", "CAT", etc...
14:50:04 <pacak1> govno: A bit more details?
14:50:07 <hpc> C++ templates are a code generation tool, you generally don't want that in haskell
14:50:13 <govno> with dependent names, SFINAE, specializtions
14:50:29 <Welkin> dexterfoo: you can use this to do case-insensitive search, then you have all of the instance which you can replace
14:50:29 <govno> overloading templates
14:51:17 <Solonarv> the thing about C++ templates is that they're an ad-hoc mess; haskell's approach to polymorphism is a bit more well-founded
14:51:27 <Solonarv> from a math/logic perspective, that is
14:51:58 <Welkin> haskell's adhoc polymorphism is through type classes
14:52:02 <pacak1> I'd start reading about typeclasses. The way haskell does it is slightly different and you might not need c++ like templates.
14:52:15 <hpc> govno: i suggest you learn haskell's type system as totally independent of c++ rather than trying to translate between them
14:52:29 <Welkin> be warned that you should use typeclasses as little as possible
14:52:38 <hpc> they have a completely different logical base
14:52:45 <Welkin> people go nuts with them coming from oop backgrounds
14:52:59 <govno> ok, I must use FFI 
14:52:59 <fen> govno: what would you want to use those for?
14:53:19 <EvanR> Welkin: tell that to ekmett
14:53:53 <Solonarv> he encodes mathematical structures with them, which is just about exactly what they're meant for
14:53:59 <hpc> govno: why do you need haskell to behave exactly like c++?
14:54:31 <fen> Welkin: why?
14:55:25 <davr0s> govno haev you used Rust
14:55:50 <hpc> rust's impl feature is also quite different from c++ templates
14:55:50 <govno> davr0s: no
14:56:32 <davr0s> govno i found using rust made haskell easier to get.. rust has some ideas inspired by haskell but with c++ execution model, and syntax closer to c++ 
14:56:35 <fen> govno: can you give an example of something you could do with the approach that your used to which we can translate as an example?
14:56:40 <geekosaur> quite a few thngs you have to use templates for in C++ can be done with polymorphism and no typeclasses, for that matter
14:56:40 <davr0s> gateway drug
14:57:12 <davr0s> typeclass<->trait  etc
14:57:20 <davr0s> enum<->data
14:57:24 <fen> geekosaur: +1. only ever encountered templates when trying to implement a haskell like interface
14:57:38 <davr0s> match <-> case of
14:57:46 <hpc> govno: out of curiosity, is haskell your second language?
14:58:22 <fen> we just have a polymorphic type appearing in a type signature, where C needs templates to overload variables to be an unspecified type iirc
14:59:22 <davr0s> i would recomend any c++ programer who wants to use haskell to use rust first as a gateway drug
14:59:29 <govno> hpc: ok, I must read a GHC, How it work, RTS etc
14:59:37 <fen> so is that why typeclasses are used too frequently by ex C programmers? 
14:59:41 <fen> hmmm
15:00:02 <hpc> govno: learn the language before the compiler
15:00:08 <fen> the idea of how they could be used "too frequently" still seems mysterious 
15:00:52 <hpc> fen: "too frequently" here means it's a very common mistake to use them when they shouldn't be used
15:00:59 <fen> but i could understand if being used to templates and finding thie interface as typeclasses in Haskell would make them seem more familiar. but how thats a bad thing?
15:01:02 <hpc> rather than that there's some exact right quantity of type classes to aim for
15:01:13 <fen> right, but whats that?
15:01:48 <fen> there is no obvious convention of when to avoid a typeclass
15:02:09 <fen> and what constitutes unnecessary 
15:02:11 <hpc> type classes define a set of operations with defined relationships, which may apply to multiple types
15:02:28 <fen> obviously!
15:02:30 <pacak1> fen: Do you need examples? Take your most recent program you wrote, something 10-20 methods long. And make everything into a single typeclass.
15:02:34 <hpc> and that's when they are appropriately used (such as for defining abstract math concepts like Solonarv mentions)
15:02:48 <hpc> the common misconception is that type classes also give you polymorphism
15:03:06 <hpc> which is common in OOP because with subtyping an interface actually does give you polymorphism
15:03:06 <Welkin> fen: inventing your own typeclasses is the wrong thing to do 99.9% of the time
15:03:13 <pacak1> I saw this recently for example. And in this case only one instance ever had sense.
15:03:14 <fen> pacak1: are you asking to see the Graph class example? its still not very concise 
15:03:19 <Welkin> it only makes sense sometimes for library authors to do so
15:03:27 <hpc> so oop people will write type classes to gain polymorphism, then struggle around the fact that they don't actually have it
15:03:43 <dexterfoo> one thing you can do with C++ templates that i don't think you can do as well in haskell, is something like:  template<int n> struct Vector { float data[n]; };
15:03:46 <dexterfoo> and then you can do stuff like:  Vector<3> newPos = oldPos + velocity;
15:03:52 <dexterfoo> and you get good static type safety (can't mix vectors of different sizes), and also excellent performance because the compiler will optimize each separate vector size at compile time
15:04:05 <pacak1> fen: I'm givin examples how typeclasses can be used excessively
15:04:13 <fen> pacak1: or are you speaking about the also uncertain "what should go in the typeclass other than minimal defining functions" ?
15:04:27 <fen> which seems to be a slightly different issue
15:04:48 <Solonarv> dexterfoo: yeah, length-indexed vectors are not quite there yet
15:05:07 <Solonarv> (in haskell, I mean)
15:05:10 <fen> obviously there is established convention of not putting all functions using a constraint into that typeclass! 
15:05:23 <Welkin> typeclasses are completely unnecessary
15:05:30 <Welkin> you can program fine without them
15:05:33 <fen> but brilliantly useful
15:05:39 <Welkin> I mean not even using the existing ones
15:05:45 <fen> not at all!
15:05:48 <fen> they comunicate
15:05:57 <fen> thats why we write "good" code
15:06:09 <fen> for the reason of communication
15:06:09 <Welkin> what...?
15:06:18 <Welkin> typeclasses make bad code
15:06:22 <Solonarv> they do have one feature that you can't get by just passing dictionaries, though
15:06:24 <Welkin> they make it impossible to understand
15:06:27 <fen> you think the existance of Functor as a class is useless?
15:06:31 <Solonarv> (coherence)
15:06:32 <Welkin> look at any of snoyberg's libraries
15:06:40 <fen> what about them?
15:06:47 <c_wraith> fen, there's a huge gap between useless and necessary
15:06:47 <Welkin> fen: Elm has no typeclasses, but we get along just fine, great in fact
15:06:54 <EvanR> type classes dont make bad code, people make bad code
15:06:58 <Welkin> List.map, Maybe.map
15:07:00 <Welkin> not a problem
15:07:08 <fen> giving things a name is a good idea
15:07:15 <c_wraith> Welkin, but how do you do lenses? :P
15:07:28 <Welkin> c_wraith: extensible records
15:07:30 <Welkin> there are ways
15:07:39 <Welkin> extensible records can do some amazing things
15:07:51 <c_wraith> um. extensible records are so very far from traversal.
15:07:56 <c_wraith> *traversals
15:08:01 <Solonarv> I'd rather have a 'Functor' class than a bunch of blog posts about the 'Visitor pattern', tbh
15:08:27 <Welkin> Solonarv: of course
15:08:47 <Welkin> I think the oop design patterns were a big joke that some professors played on students
15:08:53 <Welkin> and people took it seriously
15:08:57 <fen> right. classes in haskell (well, those in the prelude) correspond to concepts which have a strong foundation, and corresponding name
15:08:59 <Welkin> and then it became a religion
15:09:34 <fen> which it wouldnt have if it were unreasonable 
15:09:49 <Welkin> what?
15:09:50 <nshepperd1> x = (3 Int.+ 4 Int.* 6) `Int.div` 2
15:09:52 <tauoverpi[m]> If not typeclasses, would you have ML modules?
15:09:52 <Welkin> it is ocmpletely unreasonable
15:09:54 <Welkin> it is insanity
15:10:04 <Welkin> but people are insane, so
15:10:04 <hpc> Welkin: i watched a video on smalltalk the other day and it was like ruby with an IDE
15:10:56 <hpc> as weird as it is to say, java was the first OOP language with type-level principles
15:11:28 <c_wraith> eh. lots of Prelude classes are designed solely for ease of use in common cases. like the entire numeric hierarchy
15:11:57 <fen> they are a way to embed considered design principles 
15:12:15 <c_wraith> "ring with literals, abs, and signum" is not a principled concept. but it is practical
15:12:17 <fen> a class, a subset of types of some particular property
15:13:17 <fen> they even form a Category! 
15:14:09 <fen> in terms of composable reusable higher order common patterns, they are indispensable 
15:14:37 <fen> OOP design principles pish
15:17:06 <fen> UndecidableInstances and UndecidableSuperclasses are awesome!
15:17:39 <hpc> use IncoherentInstances for an authentic experience
15:18:37 <fen> can anyone help understand about inlining and build rules? the basic principles are clear, but constructing the desired implementation... 
15:19:22 <c_wraith> hpc, I'm curious what you were getting at wrt Java's type system
15:20:00 <hpc> c_wraith: just that it has things you can know at compile time
15:20:31 <hpc> smalltalk is a very dynamic language from what i saw, very little that's in code is necessarily true at runtime
15:20:37 <c_wraith> to a different degree than C++ before it?
15:21:13 <fen> java is so much better than matlab for writing class hierarchies (polymorphic inheritance) 
15:21:30 <hpc> C++ is as OOP as python is functional
15:21:44 <hpc> they're designed from a completely different base
15:22:16 <fen> but what about R?
15:22:21 <c_wraith> smalltalk is even more dynamic than that. smalltalk doesn't work with source, it works with runtime images. the source is one tiny fragment of it. you could easily have an image contain behavior with no code describing it anywhere.
15:22:30 <hpc> i would consider C++ an OO language from the perspective of writing it, but not from the perspective of things that were written into the language on purpose
15:23:01 <fen> C++ will be functional soon... 
15:23:21 <fen> then they will delete all the bad design artefacts and it will be haskell
15:23:55 <fen> and then so will scala!
15:24:38 <geekosaur> doubt either fo them can erase all their bad design artifacts
15:24:51 <hpc> it's easy
15:24:53 <hpc> first you become rust
15:24:58 <hpc> then you wait for ghc to get affine types
15:25:07 <hpc> and then you're 90% of the way there
15:25:14 <geekosaur> especially scala havng the sunk costs of jvm and full bidirectional java interop
15:25:58 <fen> lazy by default?
15:27:30 <fen> how do rules work wrt constraints?
15:29:24 <fen> and how does an INLINE pragma work as well as e.g. build/fold rules for unfoldr?
15:31:01 <fen> it would be reassuring to work with types matching Maybe knowing they could be translated to equivalent implementations matching patterns 
15:31:07 <fen> :t unfoldr
15:31:08 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
15:31:32 <c_wraith> rules are type-checked. if the replacement doesn't have the same type in a particular case, it just isn't applied.
15:31:33 <fen> > unfoldr uncons [1,2,3]
15:31:36 <lambdabot>  [1,2,3]
15:32:43 <fen> > let refold xs = case xs of [] -> []; (x:xs) -> (x:refold xs)
15:32:44 <c_wraith> and I'm pretty sure that happens in core, meaning classes have already been resolved when possible and replaced with dictionaries otherwise.
15:32:45 <lambdabot>  <no location info>: error:
15:32:45 <lambdabot>      not an expression: ‘let refold xs = case xs of [] -> []; (x:xs) -> (x:re...
15:32:54 <fen> > let refold xs = case xs of [] -> []; (x:xs) -> (x:refold xs) in refold [1,2,3]
15:32:56 <lambdabot>  [1,2,3]
15:33:21 <fen> (thats what inlining translates to?)
15:34:49 <fen> it would be good to be able to extend this rewriting to all state generators
15:35:26 <Solonarv> inlining is simply replacing uses of a function with that function's body
15:35:37 <fen> the question about Constraints is from when patterns like matching on (:) [] are abstracted 
15:36:49 <fen> e.g. class ListLike f where empty :: f a; cons :: (a,f a) -> f a
15:39:30 <fen> then the rules would be for something like; refold :: Listlike f => f a -> f a: refold Empty = Empty; refold (Cons (x,xs)) = cons (x,refold xs)
15:39:55 <fen> is that clear, does this need a full paste?
16:13:32 <fen> ok! heres the paste https://bpaste.net/show/c4c800c0fb49
16:14:16 <fen> thats how the rewite should work
16:14:34 <fen> rewrite*
16:18:21 <leifmetcalf> Can you use pattern guards inside a do block? I tried https://gist.github.com/leifmetcalf/370267ff6e4ff424ecf36effaca06f91 which doesn't work.
16:19:25 <fen> well the <- should be an = ?
16:19:37 <fen> and probably just use case?
16:19:56 <fen> (in which case it would be ->)
16:22:01 <fen> not sure how to use rules to get the compiler to make that conversion
16:22:04 <leifmetcalf> How would case work? I thought it could just check equality with a variable. I updated the gist to show why I used `<-`, the results are Monads
16:22:43 <geekosaur> foobar is not a definition, so it can'tuse guards directly. if you are testing a value, you want to use case and guards
16:23:23 <hpc> @undo do {x <- m; f x}
16:23:23 <lambdabot> m >>= \ x -> f x
16:23:23 <fen> foobar <- pure $ case ...
16:23:38 <hpc> leifmetcalf: the "x" in the do block becomes a function parameter when translated
16:24:04 <fen> > compare 1 2
16:24:07 <lambdabot>  LT
16:24:14 <fen> > compare 1 1
16:24:14 <geekosaur> the "pretiest" way si the MultiWayIf extesion, but you an emulate it with a case
16:24:16 <lambdabot>  EQ
16:24:18 <fen> > compare 2 1
16:24:20 <lambdabot>  GT
16:24:53 <fen> you can match those with case (compare x y) of EQ -> ... ; LT -> ... ; GT -> ...
16:25:00 <leifmetcalf> The comparisons were only for the gist, in the actual code there are a bunch of equalities that don't have a nice function like `compare`
16:25:30 <shafox> This code run indefinitely : https://gist.github.com/shadow-fox/466e5618497ed7085ee265811a105a3f  it should stop when it reaches at the  end. however it prints the default values.  Why ?
16:25:31 <geekosaur> foobar <- pure $ case () of () | comparison1 -> whatever | comparison2 -> whatever2 ...
16:25:32 <fen> might make sense to make a helper fucntion?
16:25:37 <fen> something like;
16:25:41 <fen> :t maybe
16:25:42 <lambdabot> b -> (a -> b) -> Maybe a -> b
16:25:50 <fen> which handles the "cases"
16:26:20 <fen> shafox: that paste is too long
16:26:30 <fen> for such a simple error
16:26:34 <hpc> shafox: what's the entry point for that code? can you make a minimal reproduction?
16:26:52 <shafox> hpc: entry point is readFileForXML
16:26:54 <fen> geekosuar: nice
16:27:03 <hexagoxel> geekosaur: you are not a fan of the corresponding extension, i take it?
16:27:18 <geekosaur> I'm fine with it, others may nto be
16:27:26 <shafox> fen: that is the whole code that generates the  error. I dont know  how to shorten  it to give a reproducible bug. 
16:27:34 <fen> oh LambdaCase?
16:27:46 <hpc> oh!
16:27:54 <geekosaur> lambdacase isn't so useful here, I was thining MultiWayIf
16:27:56 <hexagoxel> (there is -XMultiWayIf that replaces "case () of () | .."
16:28:05 <hpc> leifmetcalf: what happens if you just put "let" in front of foobar?
16:28:08 <leifmetcalf> ack, kiwiirc disconnected.
16:28:14 <leifmetcalf> geeksosaur: Thanks,I didn't realise I could use guards in a case expression. MultiWayIf seems like a prettier way to go.
16:28:21 <hpc> (and use "=")
16:28:26 <hpc> let foobar | ... = ...
16:28:33 <hpc>           | ...
16:28:39 <geekosaur> leifmetcalf, secretly the guards you know are case guards
16:30:05 <leifmetcalf> hpc: That would mean putting a `>>=` in the return line, right?
16:30:33 <geekosaur> no, "x <- pure ..." is the same as "let x = ..."
16:30:42 <hpc> > do {let x | 1 < 2 = "example"; pure x} :: [String]
16:30:45 <lambdabot>  <hint>:1:38: error: parse error on input ‘}’
16:30:54 <hpc> needs more {}
16:30:55 <geekosaur> extra braces for the let...
16:31:34 <hpc> but you'd do that and now x is a definition and not a pattern
16:31:38 <hpc> and you can write those things
16:33:29 <leifmetcalf> I think I made a bad gist, the `pure "x = y"` is just a stand-in for the real actions in the code the gist was made from.
16:33:47 <fen> > do {let x | 1 < 2 = "example"; | otherwise = pure x} :: [String]
16:33:49 <lambdabot>  <hint>:1:32: error: parse error on input ‘|’
16:33:56 <hpc> leifmetcalf: this is for the whole foobar thing, not each single line
16:34:46 <hpc> let foobar | ... = ...
16:34:48 <hpc>            | ...
16:34:55 <hpc> in the do block
16:35:45 <hpc> personally, if foobar is that complicated i would make it top-level anyway
16:35:56 <hpc> foobar x y | ...
16:35:57 <freeman42x]NixOS> hi, I am getting an error for the following code: https://paste2.org/wy48vA2B error details in the link. Could anyone help with figuring out what is wrong? I am stuck
16:37:17 <geekosaur> freeman42x]NixOS, you need to say(-1) with the parens
16:37:42 <geekosaur> otherwise 'rotate -1 ...' is (rotate - 1) ... so you're subtracting 1 from a function
16:37:49 <fen> ok, so in this paste https://bpaste.net/show/c4c800c0fb49, differenceT1 consumes the result of a loop which halts when Maybe returns Nothing, while differenceT2 does both the steps (producing and consuming an intermediate list of differences) together, which means that the Maybe can be omitted, as when consuming the list, pattern matching can be used to halt the recursion
16:38:34 <geekosaur> which is where it came up with the weird Num constraint
16:38:51 <freeman42x]NixOS> geekosaur, thank you very much, reading your explanation
16:40:30 --- mode: glguy set +v fen_
16:41:43 <geekosaur> it's basically a wart in the language, unary minus is ambiguous. the default is to treat it as the standard subtraction operator unless that's impossible, like right after an open paren
16:42:10 <geekosaur> there are various extensions in recent ghc that change the rules… each introducing a different wart in place of this one
16:42:42 <fen_> still here...
16:44:07 <fen_> any clues about this rewrite?
16:44:12 <fen_> via "rules"
16:45:07 <fen_> the reason the generalisation sought works for traverse is because it unfolds and refold something 
16:45:23 <fen_> well, it *can* be written this way (thats the differenceT1 version)
16:46:23 <fen_> and it would be good if the differenceT2 version which Inlines this process to make use of the patterns in place of Maybe, could be obtained
16:47:43 <shafox> any pointer for the error ?
16:49:15 <leifmetcalf> hpc: here's almost exactly the code I'm using: https://gist.github.com/leifmetcalf/dbc0f9d6b89ff72d9cff922f22764aa0. It's an awful API that gives the colour of an object by the presence of a {"isColour": "true"} key-value.
16:49:34 <leifmetcalf> MultiWayIf seems to be perfect for this.
16:51:39 <fen_> there is no reason nit to use let?
16:51:44 <fen_> not*
16:54:15 <leifmetcalf> Eh? Without changing `pure colour`?
16:56:16 <geekosaur> leifmetcalf, as I said earlier, (x <- pure ...) is identical to (let x = ...)
16:56:19 <geekosaur> no difference
16:56:59 <leifmetcalf> geekosaur, but not every pattern in the form `... -> pure ...`
16:58:01 <c_wraith> yes, behavior can be different if you have a pattern that may fail to match in place of x
17:00:41 <c_wraith> > do { Left x <- pure (Right 1) ; pure 3} :: [Int]
17:00:45 <lambdabot>  []
17:00:50 --- mode: glguy set +v purplepanda
17:01:45 --- mode: glguy set +v mildlyorangechop
17:01:52 <c_wraith> > do { let {Left x = Right 1} ; pure 3} :: [Int]
17:01:56 <lambdabot>  [3]
17:02:13 <c_wraith> just a bit different
17:07:00 <mildlyorangechop> Hey, I'm having some issues. I'm trying to get evalQuilt to work on this program that I'm writing. I have created a pastebin with the relevant code and the errors that I am getting. https://pastebin.com/tBcTuXsa
17:08:16 <shachaf> Your type for interpQuilt has a couple of Doubles you're not giving it.
17:08:26 <shachaf> Which part of that error is confusing?
17:12:21 <mildlyorangechop> I am trying to partially apply interpQuilt on line 22 of the paste, but I need to pattern match it to check if it gives us an error. However, it gives me a (Double -> Double -> Either InterpError Color) instead of just a Either InterpError Color, so I'm not sure how to do the case of it
17:13:17 <ion> There is no Either InterpError Color until you have applied it fully.
17:13:53 <ion> If you want an Either at that point, the type might look something like Env -> QExp -> Either InterpError (Double -> Double -> Color) instead.
17:17:14 <leifmetcalf> I updated the gist with the function replaced with let, as suggested by hpc, geekosaur, fen_: https://gist.github.com/leifmetcalf/dbc0f9d6b89ff72d9cff922f22764aa0
17:17:51 <leifmetcalf> What happens if the pattern doesn't match?
17:19:16 <Sheilong> How can I declare a multdimensional array in a function header?
17:20:07 <dmwit> Sheilong: `Array i (Array i' e)` I guess
17:20:48 <dmwit> leifmetcalf: A `True` guard always succeeds. It is idiomatic to use `otherwise` instead of `True`, even though
17:20:51 <dmwit> ?src otherwise
17:20:51 <lambdabot> otherwise = True
17:20:58 <lyxia> Array (i, i') e might also work
17:21:36 <dmwit> Ah, yep, `Array (i, i') e` is probably better.
17:22:53 <ion> leifmetcalf: If Parser is an instance of Alternative, (Blue <$ guard (val .:? "is_blue"  .!= False)) <|> (Green <$ (val .:? "is_green" .!= False)) <|> (Red <$ (val .:? "is_red"   .!= False)) might work. The library may additionally have a function that lets you add an error message to that expression for the failure case.
17:23:14 <ion> Only commenting on the latest paste, I may be missing something from earlier discussion.
17:23:50 <Sheilong> didn't worked, I was ashamed to show my code but https://www.irccloud.com/pastebin/PRgHjBxH/
17:25:09 <ion> leifmetcalf: ... <|> fail "error message" probably.
17:25:28 <dmwit> Sheilong: Odd, that page comes up completely blank for me.
17:26:28 <ion> Sheilong: You didn't paste the error message so I have to guess what it is, but "array" with a lower case initial a is a type variable and it's different from Array.
17:26:37 <dmwit> leifmetcalf: Anyway I think your `case`-based code is fine. Just fix up the syntax and off you go.
17:27:12 <Sheilong> ion: odd
17:27:38 <Sheilong> sarrus.hs:(9,22)-(12,36): error: • Couldn't match expected type ‘Int’ with actual type ‘e’ ‘e’ is a rigid type variable bound by the type signature for: sarrus :: forall (array :: * -> * -> *) i e. array (i, …
17:27:47 <Sheilong> This is the error I go.
17:28:43 <ion> Sheilong: Try changing the "e" to "Int".
17:28:48 <leifmetcalf> ion: That's fits exactly what I wanted, thank you. I didn't know about the Alternative typeclass
17:29:08 <Sheilong> ion: I've already tried this =/
17:29:25 <ion> I assume the error message is different if you try that.
17:29:34 <Sheilong> ion: I got it to work now. 
17:29:37 <Sheilong> Thanks guys.
17:29:46 <Sheilong> And sorry for such stupid code. 
17:29:46 <leifmetcalf> dmwit: I thought it was good too. A few people earlier told me there was no reason to not use `let`
17:30:01 <dmwit> Perhaps they didn't read it carefully.
17:30:29 <Sheilong> Even though having some experience with Lisp, haskell has been something very crazy that is being hard to me to get along.
17:30:39 <ion> You don't have to apologize or feel ashamed about code. Everybody starts from the same position and learns.
17:31:18 <ion> And writing actual code and figuring out what's wrong with it is an excellent way to learn.
17:32:52 <Sheilong> The signature still is issue, it is not correct yet. I will try to figure this out.
17:35:34 <ion> Once you figure out the type issue, you might want to do something like "foo matrix | low /= high = ... | low == 1 = ... | low == 2 = ... | ... where { (_, (low, high)) = bounds matrix }" But that is equivalent to your current code, so don't worry about that part yet. What is the code and the type error currently?
17:36:56 <Sheilong> ion:  I read the error message, and It was complaining about Integer type with Int type, so I changed everything in the signature to Integer and it fixed the issue with the type.
17:38:53 <ion> Sheilong: https://bpaste.net/show/a8828b9b8b66
17:39:35 <Sheilong> ion: Thanks it is an elegant solution, I will apply your idea : )
17:40:49 <ion> It's the same code, there's just often a nicer alternative to both nested if expressions and the use of fst/snd.
17:40:59 <ion> syntactically
17:45:14 <Sheilong> ion: https://bpaste.net/show/9ee66b94d838
17:46:17 <Sheilong> It is a syntactic sugar for nested if expression
17:47:16 * hackage waargonaut 0.2.1.0 - JSON wrangling  http://hackage.haskell.org/package/waargonaut-0.2.1.0 (schalmers)
17:47:29 <avp> how do i do pattern matching in a list comprehension if i want to pattern match on the result of a function call? I'm getting irrefutable pattern match fails: https://repl.it/repls/WheatCompleteComputers
17:48:34 <ion> Sheilong: In this case yes, but the syntax also allows pattern matching:
17:49:03 <Sheilong> ion: Nice! 
17:49:04 <ion> > let foo str | 'h':t <- str = t | otherwise = "?" in foo "hello"
17:49:07 <lambdabot>  "ello"
17:49:43 <ion> avp: Just x <- get v
17:49:47 <ion> no let
17:49:55 <ion> Oh, wait
17:50:16 <avp> yeah that doesn't work because the <- would expect [Maybe Int]
17:50:17 <ion> Just x <- [get v] would work
17:50:23 <avp> ooh interesting
17:50:55 <avp> bingo, that actually makes complete sense
17:51:07 <avp> thx ion 
17:54:54 <ion> One option would be to use Alternative instead of a hardcoded Maybe: "get :: Alternative f => Int -> f Int; get 0 = empty; get n = pure n". "get n" would act as a Maybe Int and a [Int] depending on type inference and you could use "x <- get v" in the list comprehension. A general "Alternative f => f Int" is more like [Int] than a Maybe Int though, it may have multiple values. Another option is "x <-
17:54:56 <ion> maybeToList (get v)".
17:56:05 <ion> I would probably keep get as a function that returns a Maybe since it explicitly has either zero results or one.
18:38:29 --- mode: glguy set +v Gigabitten
18:38:43 --- mode: glguy set -v Gigabitten
18:38:59 <Gigabitten> what would happen if you tried to implement a non-transitive Eq?
18:39:09 <Gigabitten> would Haskell just explode?
18:39:49 <Gigabitten> (I mean, how would Data.List.group behave with that? probably kinda weird)
18:40:20 <Solonarv> it wouldn't outright explode, but some stuff that uses Eq would behave weirdly
18:40:41 <Solonarv> the exact weirdness depends on how exactly you're breaking the Eq laws
18:41:05 <Solonarv> (note: IEEE floats have law-breaking Eq instances)
18:41:06 <Gigabitten> ah
18:41:14 <Gigabitten> rly?
18:41:15 <Gigabitten> like what
18:41:33 <Solonarv> NaN == NaN is false, for example
18:41:48 <shachaf> The general expectation is that Haskell would just explode, and so no one has ever tried it.
18:41:57 <geekosaur> msot notably, it follows IEEE semantics instead of those Haskell expects
18:42:18 <Solonarv> yes, and IEEE float equality semantics are just a bit insane
18:42:20 <Gigabitten> Solonary, that's odd but does that create any odd derivative behavior or is it isolated to just that?
18:42:23 <nitrix> I wrote a non-symmetric Ord instance once. It wasn't pretty.
18:42:38 <shachaf> I guess the "correct" semantics for (==) is for it to nonterminate in some cases.
18:42:49 <shachaf> Assuming you see floats as approximate reals.
18:43:03 <shachaf> Unfortunately that's not a good idea.
18:43:16 <Solonarv> shachaf: they're *approximate* reals, so (==) should definitely always terminate on them
18:43:31 <Gigabitten> ha, yeah, I mean, all of working with floats is about knowing how they differ from approximate reals, right?
18:43:38 <nitrix> Since floats have approximative precision, I'd expect (==) to take epsilon into account for equality.
18:43:54 <shachaf> But if you're comparing two approximate reals, the best answer you can get is "I don't know whether they're equal".
18:43:57 <nitrix> But I know literally nothing about that stuff :P
18:44:24 <Solonarv> Gigabitten: well, in theory the law-breaking propagates to user-defined types that have a float in it
18:45:10 <Gigabitten> ooh good point. ... but. oh christ. how convoluted would it have to be for that to ever be invoked lol
18:45:29 <Solonarv> not particularly convoluted
18:45:33 <Gigabitten> ?
18:45:56 <Solonarv> you can run into the broken instance if you're e.g. shoving floats into a Set
18:46:16 <Solonarv> or using them as keys in a Map
18:46:24 <Gigabitten> oh geez ok yeah 
18:46:45 <Gigabitten> that second one really illustrates how annoying that could be
18:47:18 <Solonarv> of course as long as you're only working with "nice" floats (i.e. no NaNs or infinities) this isn't a huge problem... until you run into a rounding error!
18:47:29 <Gigabitten> does that mean you can transform a list of Eq into another list of Eq and have them go from equal to not equal
18:47:33 <shachaf> There are no "nice" floats
18:47:40 <Gigabitten> that sounds REALLY annoying for maps especially if that ever comes up
18:47:58 <Solonarv> yes, which is why you shouldn't use floats as map keys
18:48:05 <Gigabitten> ha yeah alright I'll remember that
18:48:17 <Gigabitten> fun fact, floats are actually evil
18:48:42 <Solonarv> if you need a float-indexed map kind of thing you'd need something that can handle their "fuzziness"
18:50:16 <shachaf> Kittens also don't make good map keys, for the same reason.
18:50:59 <Gigabitten> :/ I could definitely imagine situations where you'd want a float as a key. how would you implement that?
18:51:25 <shachaf> You can do a lookup for values in an interval rather than exact values.
18:51:32 <Solonarv> no idea, that sounds hard
18:51:36 <Solonarv> but yes something like that
18:51:44 <geekosaur> tjere
18:51:50 <shachaf> But also you can do something else instead of using the float as a map key.
18:52:09 <geekosaur> there's some hackage packages for interval lists and interval trees iirc
18:53:00 <shachaf> please abstain from consing
18:53:25 <geekosaur> but floating point being inherently approximate, the notion of using a floating point value as a key is iffy to begin with
18:58:26 --- mode: glguy set -qo $~a glguy
19:16:58 <Gigabitten> how slow is Sort unsorted sorted = Sort (tail unsorted) (insert (head unsorted) sorted) compared to using an actually good algorithm
19:18:03 <Gigabitten> er, with an end case when unsorted is empty
19:18:10 <Gigabitten> obviously
19:18:37 <avp> i've got some foldl' code that's slow: https://repl.it/repls/TiredTomatoRoute 
19:19:01 <avp> but if i put a "seq first' (first', idx', length + 1)" as the result of stepFast, it's much faster
19:19:18 <lyxia> foldl' doesn't solve the problem it's solving if your accumulator is a tuple
19:19:18 <avp> isn't foldl' supposed to be forcing the evaluation so i don't have to do seq manually?
19:19:23 <avp> ohh
19:19:29 <avp> why?
19:19:44 <lyxia> because it will only force the tuple up to (_|_, _|_, _|_)
19:20:05 <avp> is there a builtin way to solve it or is forcing seq the only way?
19:20:41 <lyxia> I think seq is the best way
19:20:57 <avp> it feels like an abstraction leak to make stepFast aware of when to force things
19:21:32 <avp> lyxia: thanks for the help!
19:22:41 <lyxia> another way is to not use fold with accumulators that may contain thunks
19:23:37 <avp> and just do the recursion manually with a counter?
19:25:24 <lyxia> or use other functions like map
19:26:04 <avp> i would use map, but sadly in this computation (as well as others) the result is dependent on the previous value, etc.
19:27:02 <lyxia> the sequence of idx and length does not depend on the list though
19:28:05 <avp> i guess that's true, and given a list of (idx, length) pairs i could fold over Int and that'd be fast
19:28:09 <avp> makes sense
19:31:15 <lyxia> In any case it's true that the cost model of Haskell isn't so intuitive
19:36:59 <fragamus> https://gist.github.com/fragamus/ae85e57ec1c3ccdfec26c626011e91da
19:37:27 <fragamus> need a little help bringing up some Diagrams code
20:00:07 <koz_> I'm having some trouble understanding how the combination of ViewPatterns and PatternSynonyms works. Specifically this example: https://gist.github.com/kozross/9e82dd19a33d2ada03eb20b688dfa5c2
20:00:26 <koz_> I'm _specifically_ unclear on the whole 'pattern Empty <- ... where Empty = ...'.
20:01:31 <jle`> koz_: the general syntax is something like `pattern PatSym x <- OriginalPattern x`
20:01:46 <jle`> so `pattern FakeJust x <- Just x`
20:01:54 <koz_> jle`: What form exactly is 'OriginalPattern' allowed to take?
20:02:10 <jle`> will match on `Just x`, and bind x to what the original x in the Just is
20:02:13 <jle`> koz_: any pattern
20:02:25 <jle`> @let pattern FakeJust x <- Just x
20:02:26 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
20:02:28 <koz_> jle`: In the 'pattern match' sense of pattern, I guess?
20:02:50 <jle`> pattern as in, the syntactical thing
20:02:54 <jle`> pattern vs. expression vs. delcaration etc.
20:03:25 <koz_> Sorry if this sounds daft, but I actually don't know what constitutes a 'pattern' in this case.
20:03:40 <jle`> yeah, it's the same syntax that is used in case statements for pattern matching
20:03:47 <jle`> but the exact syntax is in the haskell report
20:04:08 <jle`> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17
20:04:12 <koz_> OK, so it _can't_ be some kind of computation - only something you can match on.
20:04:19 <koz_> That's the part that was throwing me I think.
20:04:23 <jle`> yeah, it's a pattern
20:04:33 <jle`> so without ViewPatterns, you can only directly match on patterns
20:04:44 <jle`> but ViewPatterns is sort of a hack, that lets you insert general computations into patterns
20:04:56 <jle`> so (myFunction->Just x) is a view pattern
20:05:03 <lyxia> (add (exp -> pat) to those rules
20:05:07 <koz_> And what does myFunction have to output?
20:05:17 <jle`> are you familiar with ViewPatterns?
20:05:30 <jle`> it basically lets you pre-apply a function to the input, and match on the result of that function
20:05:46 <jle`> @let myHead (uncons->Just (x, _)) = x
20:05:50 <lambdabot>  Defined.
20:05:53 <jle`> > myHead [1,2,3]
20:05:56 <lambdabot>  1
20:06:33 <jle`> ViewPatterns is an extension to pattern syntax that allows you to pre-apply a function to an input, and name/match on the result instead of the input directly
20:06:34 <koz_> Ah, OK, that makes sense.
20:06:46 <jle`> so myHead will apply uncons to the first argument, and match on Just (x, _)
20:07:00 <koz_> OK, that makes much more sense.
20:07:15 <koz_> But then what about the 'where Empty = Seq empty' part?
20:07:29 <jle`> that's the second part of pattern synonym syntax
20:07:40 <jle`> that lets you specify the reverse direction, the 'review'
20:08:03 <jle`> so the first line specifies the 'preview' (match), the second line specifies the 'review' (construct)
20:08:09 <koz_> So that says 'if I use Empty to 'make' something, 'fake' it with 'Seq.empty'?
20:08:32 <jle`> yeah, the 'Empty' pattern synonym, if used as a constructor, is Seq.empty
20:08:41 <jle`> remember that constructors all have two roles
20:08:51 <jle`> they are used for pattern matching, and also used for constructing
20:09:05 <jle`> the first line specifies how the first role works, the second line specifies how the second role works
20:09:28 <jle`> % pattern FakeJust x <- Just x where FakeJust x = Just x
20:09:28 <yahb> jle`: ; <interactive>:312:20: error:; parse error on input `<-'; Perhaps this statement should be within a 'do' block?
20:09:40 <koz_> OK, I _think_ I understand.
20:09:49 <jle`> but yeah, that's how you'd declare a fake Just constructor that works just like Just
20:09:50 <koz_> Let me try what I was trying to do before, and I'll chime in if further confused.
20:10:21 <jle`> using ViewPatterns is just a hacky way to insert a general computation for the matching part
20:11:24 <jle`> there's a proposal to make things a little less hacky -- https://github.com/ghc-proposals/ghc-proposals/pull/138
20:13:36 <koz_> jle`: So is this way we have to have previews emit Maybe?
20:13:41 <koz_> (even if they can't fail)
20:13:55 <koz_> s/way/why/
20:14:33 <jle`> if they can't fail then you can make it simpler, just do pattern MyPat x <- (myView->x)
20:14:48 <MarcelineVQ> fragamus: completely stumped here as to where the mechanism that goes between Result b v n and MarkupT () resides, as renderSvg appears to have always taken a MarkupT ()
20:14:50 <jle`> but the Maybe is because in the general case, patterns can possibly fail to match
20:15:14 <koz_> jle`: Ah, OK.
20:15:20 <jle`> but there's a special case if we have an isomorphism, you can do pattern MyPat x <- (myIsoTo->x) where MyPat x = myIsoFrom x
20:15:25 <MarcelineVQ> *MarkupM ()
20:15:40 <koz_> jle`: This is _crying out_ for a post.
20:15:45 <koz_> (just sayin')
20:16:00 <koz_> Because your explanation is way clearer than the stuff in the GHC manual or anything else I've been able to find.
20:16:28 <jle`> i'd hope someone has written about how pattern synonym syntax works :o because it's something that is pretty wide-spread
20:16:39 <fragamus> MarcelineVQ: Im trying to bring up some code from Ed Kmett's blog post from several years ago
20:16:54 <MarcelineVQ> fragamus: I know, and looking at it I can't figure out how it worked when it did work
20:17:03 <koz_> jle`: Nothing I've been able to find was much help honestly.
20:17:11 <fragamus> https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/cellular-automata
20:17:19 <koz_> I'd love to see a jle` writeup with all the parallels to Iso/Prims.
20:17:26 <koz_> s/Prims/Prism/
20:18:16 <fragamus> "It isn't the stone age any more."
20:18:35 <jle`> i suppose it's about time for an update to https://ocharles.org.uk/posts/2014-12-03-pattern-synonyms.html and https://mpickering.github.io/posts/2014-11-27-pain-free.html
20:18:42 <fragamus> edwardk mayday mayday mayday
20:18:47 <koz_> It's been four years, lol.
20:19:00 <koz_> fragamus: Are you activating the Kmett Signal? :P
20:19:12 <MarcelineVQ> ghc manual is pretty clear in general but tends to lacks motivating examples which I think is what make blog posts effective. on top of the problem where you need to know you need a thing to know to look for that thing, to figure out how to apply that thing, to have that thing save you time
20:19:13 <fragamus> yes because stone age
20:19:14 * Axman6 thinks jle`writes the best blog posts so should totally write another, whatever the topic is
20:20:24 * koz_ agrees with Axman6.
20:24:34 <Roybent> (silicone, saline, string) implants
20:25:02 <MarcelineVQ> (silicone, saline, string) patches
20:25:26 <koz_> (silicone, saline, string) solution
20:25:38 <fragamus> I have the perfect plan
20:25:48 <koz_> fragamus: Not a _cunning_ plan?
20:25:54 <fragamus> to solve this problem
20:26:10 <fragamus> I'll let you be the judge
20:26:35 <fragamus> I am going to play civilization until edwardk wakes up
20:26:46 <fragamus> then I'm going to ask him
20:26:54 <koz_> fragamus: Why is that a perfect plan?
20:27:12 <MarcelineVQ> agree with koz_, at least play brood war
20:27:26 <Roybent> (silicone, saline, string) implants
20:27:31 <fragamus> Because it is bound to succeed and requires *no effort whatsoever*
20:27:52 <fragamus> ok score my plan
20:28:14 <MarcelineVQ> 3
20:28:24 <koz_> 3 as well
20:28:58 <koz_> (I'm the guest chef on Hell's Kitchen as run by MarcelineVQ)
20:29:22 <Roybent> (silicone, saline, string) implants
20:34:46 <MarcelineVQ> "error: Illegal binding of built-in syntax: (,,)" :<
20:37:12 <edwardk> what are you going to ask me?
20:37:49 <MarcelineVQ> fragamus
20:39:15 <fragamus> oh hi I'm trying to bring up this code
20:39:16 <koz_> Hi edwardk!
20:39:47 <fragamus> https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/cellular-automata
20:40:43 <fragamus> and and I'm having this problem
20:40:45 <fragamus> https://gist.github.com/fragamus/ae85e57ec1c3ccdfec26c626011e91da
20:42:19 <fragamus> oh I see Lysxia  commented
20:48:41 <Roybent> (silicone, saline, string) implants
20:53:04 <Roybent> (silicone, saline, string) implants
20:55:10 <rotaerk> I was a little confused there
20:55:18 <rotaerk> "How is he applying a 3-tuple to implants?"
21:38:18 * hackage sh2md 0.1.0.0 - Record your shell session and print in the markdown format  http://hackage.haskell.org/package/sh2md-0.1.0.0 (kkweon)
22:41:55 <MarcelineVQ> @tell fragamus after some scouring of libs, here's a modern edition https://gist.github.com/MarcelineVQ/d2840dd21a0c54335fb426b440c31e98
22:41:55 <lambdabot> Consider it noted.
22:48:40 <dminuoso> So I might want to wrap *any* exception caught inside some async with `newtype WorkerException = WorkerException SomeException` for some other reasons. Are there any obvious reasons why this might be a bad idea?
22:49:05 <dminuoso> In particular Im thinking about the exception hierarchy and async exceptions which I dont understand well.
22:49:40 <Zemyla> Huh, there is a prism called _Void, which is something I thought of pretty much independently.
22:49:46 <Zemyla> :t prism absurd Left
22:49:48 <lambdabot> (Applicative f, Choice p) => p a (f Void) -> p t (f t)
22:50:00 <cocreature> dminuoso: if you catch all asynchronous exceptions you also end up breaking things like C-c
22:50:05 <Zemyla> It shows that for anything, you can't extract a Void from it. :P
22:51:02 <ktonga> is it common that when you use PatternView extension GHC complains about pattern not matched but actually all are?
22:52:09 <cocreature> ktonga: do you have an example?
22:52:47 <ktonga> it is happening to me with some custom data types, but i was able to reduce it to an example using just Maybe
22:53:17 <ktonga> intFn :: Int -> Maybe ()
22:53:17 <ktonga> intFn = undefined
22:53:17 <ktonga> patternView :: Int -> ()
22:53:17 <ktonga> patternView (intFn -> Nothing) = ()
22:53:17 <ktonga> patternView (intFn -> Just _ ) = ()
22:53:56 <ktonga> warning:
22:53:58 <ktonga> Pattern match(es) are non-exhaustive
22:53:59 <ktonga> In an equation for ‘patternView’: Patterns not matched: _
22:56:48 <ktonga> cocreature: ^^^
22:59:23 <ktonga> sorry I meant ViewPatterns
23:00:07 <cocreature> ktonga: I think that’s sadly expected, see https://ghc.haskell.org/trac/ghc/ticket/15884
23:02:22 <ktonga> oh noes, that's so sad, cool extension but that problem makes it almost useless
23:08:50 <Zemyla> I really wish ther were a withLens like there's a withPrism.
23:11:08 <jle`> Zemyla: hm, i wonder why there isn't
23:11:31 <jle`> you could pretty much copy and paste the source of withPrism and it'd work as withLens, minus some name changes
23:11:57 <Zemyla> Also, there should be Lens and Prism pattern synonyms for them, like doSomething (Prism bt seta) (Lens sa sbt) = ...
23:13:16 <jle`> let me make sure that my suspicious about withLens are correct
23:18:04 <jle`> hm, it might not be possible to write withLens without losing sharing
23:18:09 <jle`> that might be why it's not there?
23:19:09 <shachaf> withLens :: ALens s t a b -> ((s -> (a, b -> t)) -> r) -> r ?
23:19:27 <shachaf> The type of "lens" is bad and it should feel bad.
23:19:36 <jle`> ah, that version makes much more sense
23:19:39 <shachaf> You always want the version with sharing.
23:21:16 <mniip> hmm, that's just instantiating the lens with  f ~ (a, b ->)  innit
23:22:21 <mniip> hrmph, "image of the identity" makes me feel natural transformations and yoneda is nearby
23:23:14 <shachaf> Yes, that's how APrism works
23:23:28 <shachaf> Uh, ALens
23:23:30 <shachaf> Both of them
23:24:20 <shachaf> By instantiating the thing with a type that gives you all the information in it.
23:24:24 <dminuoso> cocreature: Mmm, just catching IOException feels like I don't get all interesting exceptions.
23:24:29 <koz_> AShapedPieceOfGlass, shachaf?
23:24:30 <shachaf> This is much more straightforward with pure profunctor lenses.
23:25:05 <dminuoso> My issue is that I have an `Async Void` and if that, for any reason, throws on some waitXXX I need to propagate that error since it means the connection is lost.
23:35:26 <cocreature> dminuoso: async should already take care of propagating exceptions no?
23:36:14 <nshepperd> (is there a lens function called 'telescope'?)
23:37:43 <nshepperd> (if not, should there be, and what would it do? :p)
23:37:53 <MarcelineVQ> alias for zoom
23:38:57 <dminuoso> cocreature: I need to write my own thin wrapper around it
23:40:20 <koz_> :t zoom
23:40:21 <lambdabot> Zoom m n s t => LensLike' (Zoomed m c) t s -> m c -> n c
23:40:37 <koz_> What does zoom do in non-lens terms?
23:42:13 <cocreature> koz_: runs something on a subpart of the state
23:42:21 <koz_> cocreature: Ah.
23:42:26 <cocreature> e.g. if your state is a tuple, you can use zoom to run something only on the first element
23:42:48 <nshepperd> :t zoom :: Lens' s a -> State a y -> State s y
23:42:49 <lambdabot> Lens' s a -> State a y -> State s y
23:43:36 <koz_> That sounds really handy for complex state.
