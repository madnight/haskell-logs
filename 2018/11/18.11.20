00:00:40 <Lears> foldl (\k x -> k . f x) id [a, b, c] = f a . f b . f c
00:00:49 <Lears> Don't need no z.
00:02:54 <foldrm> That helped not a whit. Haha
00:07:18 <foldrm> OH!
00:07:22 <foldrm> I get it. :)
00:08:40 <foldrm> So like Lears said, it's actually building up a stack of computations
00:09:09 <foldrm> More correctly: A composition of all the steps in the reduction, the last of which needs the initial value
00:09:50 <foldrm> Once you supply the initial value, the entire reduction runs and produces the final result.
00:09:52 <foldrm> Is that correct?
00:12:01 <foldrm> Lears: I take it back, that did help. Although I had to just sit and stare at the definition for 15 minutes to see it, and *then* your comment helped. :D
00:13:48 <Lears> Np. Sounds like you've more-or-less got it.
00:14:21 <foldrm> More or less? Am I still missing something?
00:15:09 <foldrm> It's ok if I am. I want to really grok this. :)
00:16:04 <Lears> Nah, I'm just phrasing it weakly because it's hard to assess understanding from a few lines in irc.
00:18:01 <foldrm> Ah ok. Fair enough. Thanks so much all! Really appreciate your patience as I muddle through and screw this up. :)
00:18:18 <foldrm> I still don't know why that broke my brain so hard.
00:21:13 --- mode: glguy set +v Maswor
01:39:04 --- mode: glguy set +v reactormonk
01:39:11 --- mode: glguy set -v reactormonk
02:04:54 <WilliamHamilton[> hi, I have an error with cabal new-build when trying to build https://github.com/ichistmeinname/explicit-sharing
02:05:08 <WilliamHamilton[> here is the error I'm getting https://paste.laravel.io/5a94eadc-a90e-4549-8cfb-dd9bc359a18d
02:05:45 <WilliamHamilton[> it is about a dependency, `next goal: explicit-sharing:setup.Cabal`
02:06:12 <WilliamHamilton[> but I never saw a dependency on `setup.Cabal`
02:15:25 <WilliamHamilton[> (it all works with `cabal build`, can it be because I'm on nixos?)
02:35:33 <fr33domlover> Is there a performance/memory use difference between foldlM and foldrM the way there is between foldl and foldr?
02:35:56 <opqdonut> in general, yes, but it depends on your monad too
02:35:57 <fr33domlover> (In other words does is matter which one I use, if I otherwise have free choice)
02:38:10 <fr33domlover> opqdonut, thanks :) So foldrM generally avoids the thunks that foldlM would be building? And my monad stack has IO, StateT and ExceptT, what can I learn from that? ^_^
02:38:37 <opqdonut> the other way around, I think
02:38:44 <opqdonut> IO is strict-ish so foldlM sounds appropriate
02:39:36 <opqdonut> hmm weird I'm missing something now
02:39:45 <opqdonut> fodlrM is defined using foldl
02:39:49 <opqdonut> and foldlM using foldr
02:40:43 <Lears> WilliamHamilton[: Looks like https://github.com/haskell/cabal/issues/5278
02:41:36 <WilliamHamilton[> Lears: yes, thanks, it's probably that
02:42:29 <opqdonut> ah right fold[lr]M build up a monadic operation, and then feed the input value to it
02:43:31 <opqdonut> I wonder why it's defined that way and not the more straightforward way of folding with a monadic state
02:43:49 <opqdonut> less >>=s this way maybe
02:44:19 <opqdonut> fr33domlover: now that I'm reading the code, I don't know which one you should use a priori. so use whichever and measure :)
02:46:00 <WilliamHamilton[> Lears: solved, it was indeed because the new cabal wants the dependencies for Setup.hs explicitly declared. Adding a `custom-setup` stanza, like in the first post of the thread you linked, solved things. Thanks again!
02:46:25 <Lears> yw
02:48:00 <fr33domlover> opqdonut, haha yeah that's what I've been doing ^_^ The algorithm suggests foldlM but the order doesn't matter so it will work with foldrM too, I guess I'll just pick whichever is more convenient
02:53:22 <bor0> what's the best way to write this guard?     | target `elem` (map result foundProofs) = f. I want f to be the matching element in foundProofs such that result f == target
02:54:06 <opqdonut> bor0: use find and pattern match on the result?
02:54:34 <bor0> `find`, hoogling.. I thought I needed something like Scheme's `findf` :)
02:54:39 <opqdonut> :t find
02:54:40 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
02:54:53 <opqdonut> > find even [1,2,3]
02:54:55 <lambdabot>  Just 2
02:55:03 <bor0> awesome. thank you!
02:58:26 <dminuoso> :t foldM
02:58:27 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
02:59:54 <bor0> is hpaste down? and if yes, what is used nowadays as an alternative?
03:01:15 <Axman6> lpaste
03:01:16 <bor0> is there a better way to write this? https://gist.github.com/bor0/e9c9014b0c90113a86dabb3d363f92e1
03:01:18 <Axman6> @where lpaste
03:01:18 <lambdabot> http://lpaste.net/
03:03:10 <Axman6> bor0: you iterate over the list twice, why not just use case find (\x -> target == result x) foundProofs of Just x -> Just x; Nothing -> <your otherwise case>
03:03:41 <bor0> right! that makes sense, thanks
03:04:13 <bor0> do I remove the guards and use pattern match? or can I combine case with guards?
03:04:13 <opqdonut> yeah that's what I meant
03:04:28 <Axman6> also you can have multiple definitions inside a single let clause: let x = y; z = f x y (where ; can be read as literally ; or a new line which aligns z with the definition of x)
03:05:18 <Axman6> Usually I'd write: findProofIter _ _ 0 _ = Nothing; findProofIter prover target depth foundProofs = case ...
03:05:28 <Axman6> (again where ; is a new line)
03:06:04 <Axman6> is fromList Data.Set's fromList?
03:06:25 <bor0> yes
03:06:39 <bor0> I added a comment to the code, you can reload if you don't see it
03:06:49 <bor0> it uses the fact `The case where no new theorems were produced, that is, A union B = A`
03:06:52 <Axman6> if so, it seems a bit silly to be constantly turning a list into a set on each recursive case - you could use findProofIter as a wrapper around a function which passes around sets
03:07:19 <bor0> hmm, but `foundProofs` changes with each iteration
03:07:32 <bor0> (or each recursion)
03:10:17 <Axman6> prover and target don't change so don't actually need to be passed around
03:10:25 <Axman6> what does mergeProofs do?
03:11:19 <bor0> mergeProofs p1 p2 = nubBy (\t1 t2 -> result t1 == result t2) p1 ++ p2
03:12:00 <bor0> -- Merge two list of proofs but skip duplicate proofs, giving the first argument priority. This is used to avoid circular results in the search tree. E.g. application of rules resulting in an earlier theorem/axiom
03:12:11 <Axman6> you can do something like this: findProofIter prover target depth foundProofs = go depth foundProofs where go 0 _ = Nothing; go n found = case find ... of go (n-1) found' where found' = <the stuff you have in the lets>
03:12:22 <bor0> I can upload the whole file if you are interested. it's just 60 lines, a simple proof search
03:12:37 <bor0> I'd already implemented it in Scheme a few months ago. but the "typed" version is much better :)
03:17:59 <Axman6> the change I'm suggesting is called worker/wrapper, it's a common way to reduce the complexity of a function and the number of arguments passed aruond, which often improves performance
03:24:06 <bor0> ok, Gist updated: https://gist.github.com/bor0/e9c9014b0c90113a86dabb3d363f92e1. I'll try to implement your latest suggestion with the worker/wrapper pattern
03:26:20 <Axman6> you can delete all the "let" and "in" except for the first and last ones respectively btw
03:27:40 <Axman6> (I left a comment showing how)
03:27:50 <bor0> hm, ghci whines when I do that. maybe because of newlines or something? I tried `let x = 1; y = 2 in x` and it worked tho
03:28:27 <bor0> ahh, they have to be spaced
03:28:33 <bor0> tricky
04:36:17 <asheshambasta> Hi one and all. What Haskell libraries should I be looking at if I want to scale/crop and "optimise" image files? The optimise part is very important (reduce quality, etc.). 
04:36:59 <asheshambasta> I've come across hip, JuicyPixels, Friday, but none of them (at least from what I've read so far) offer the "optimise" part I'm looking for. 
04:37:15 <fendor> When i want to traverse a list in both direction, i should use a zipper, right? If i want to traverse two lists in a similar fashion at once, i can still use a zipper and a suitable interface, can I do the same for a finite list of lists? I do not know how many lists I want to traverse at once
04:37:59 <geekosaur> fendor, sometimes. there's also Data.Sequence
04:43:57 <fendor> geekosaur, well, i have n traversables, and i want to traverse them simultanousely, and insert at the same location, or remove something. A simple zip does not work, because i dont want to traverse them element wise but in a more complex way
04:48:01 <quicksilver> you can't insert into a traversable at all
04:48:09 <quicksilver> (or remove indeed)
04:49:48 <fendor> quicksilver, it is ok to specalize it to some concrete type like list , I just didnt want to say list, since i dont care about the actual datastructure
04:55:15 <quicksilver> well if you want to insert and delete then you definitely want a zipper
04:55:42 <quicksilver> if you have a zipper it's not hard to move along multiple structures at once
04:55:51 <fendor> quicksilver, i think so too, can I create a zipper of arbitrary size? I mean, theoretically, it should not be a problem
04:55:57 <fendor> i dont have a zipper *yet*
04:56:00 <quicksilver> the only time I used a non-trivial zipper I designed it myself for the structure at hand
04:56:09 <quicksilver> I have no idea if there are pleasant-to-use generic ones yet
04:56:20 <dibblego> https://hackage.haskell.org/package/zippers
04:56:23 <dibblego> https://hackage.haskell.org/package/list-zipper
04:56:34 <fendor> quicksilver, i think, designing it myself should be feasible
04:56:39 <maerwald> or just use something you can mutate?
04:58:31 <fendor> maerwald, yeah, I could use mutable vectors with mutable elements or something like that. But I'd like to avoid IO
04:58:49 <maerwald> ST?
05:01:41 <fendor> maerwald, I actually dont know how I could implement it via ST... 
05:03:22 <fendor> list-zipper library has 1000 lines of code and not a single line of documentation. Plus a dozen infix operators
05:07:36 <maerwald> sounds like a haskell library xD
05:07:52 <int-e> at least the documentation is up-to-date
05:09:31 <tauoverpi[m]> It's in the types!
05:14:34 <fendor> on the other hand, very explicit import list
05:14:34 <maerwald> types are as much documentation as class diagrams are architecture
05:30:00 <geekosaur> type-ical?
05:32:04 <dibblego> https://hackage.haskell.org/package/zippers
05:32:06 <dibblego> oops
05:32:08 <dibblego> https://github.com/qfpl/list-zipper/blob/master/test/Tests.hs
07:03:46 <cemerick> hi, I'm shopping for a pretty printer I can plug into ghci that offers a width/columns configuration. Any suggestions?
07:09:59 <safinaskar> i work in "Either String" monad. I also have some datatype, say, "data Tree = Nil | Node Tree Tree". I have "x :: Tree". I often do this: "case x of { Nil -> Left "Error!"; _ -> return (); }". But I don't like this repetetive "_ -> return ()". How to avoid them? I know I can use "when" to avoid repetetive "if someBool then Left "error" else return ()". Is there something like "when", but for avoiding 
07:10:05 <safinaskar> repetetive "_ -> return ()" instead of "else return ()"?
07:10:51 <merijn> safinaskar: Depending on the datatype you can often use mapM_ or traverse_
07:11:09 <merijn> (or the forM_ and for_ equivalents)
07:11:33 <merijn> % for_ Nothing $ \x -> print x
07:11:33 <yahb> merijn: 
07:11:41 <merijn> % for_ (Just True) $ \x -> print x
07:11:41 <yahb> merijn: True
07:12:08 <merijn> safinaskar: So if your tree type is Foldable/Traversable that'd work
07:13:52 <safinaskar> merijn: let's assume this is not tree, but some simple structure instead. Say, data X = A Int | B Char | C String
07:14:06 <merijn> safinaskar: There might be other approaches, but that'd append exactly on the exact datatype you're working with and what you wanna do with it
07:14:24 <safinaskar> merijn: i simply want to test whether "x" matches "A _". and I don't want to write "return ()" explicitly
07:15:29 <merijn> safinaskar: I don't think there's a straightforward way of doing that without surrounding context
07:16:20 <merijn> You might be able to restructure your surrounding code to simplify things, but that's hard to say given this info
07:17:04 <Solonarv> actually, if you're working in Either String you can just use 'A _ <- someValue' (i.e. a partial pattern match)
07:17:30 <Solonarv> if the pattern doesn't match, you get a call to 'fail', which for Either String gives you a Left
07:17:50 <merijn> No, don't do that
07:17:59 <merijn> That will be deprecated soon
07:18:15 <merijn> Either doesn't have a MonadFail instance (yet?)
07:19:28 <merijn> See https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail and -XMonadFailDesugaring in GHC 8.4 and up
07:20:36 <lavalike> @src whenn
07:20:36 <lambdabot> Source not found. You type like i drive.
07:22:07 <lavalike> @src when
07:22:07 <lambdabot> when p s = if p then s else return ()
07:23:59 <merijn> safinaskar: oh, also, if you're consistently matching against the same type X, you can of course simply write a custom "when" that does "myWhen x = case x of { Nil -> Left "Error!"; _ -> return () }"
07:24:20 <merijn> safinaskar: You can even replace the "Left "Error!"" with a function for the one case you want to handle
07:24:31 <merijn> But of course that only works if you consistently use the same match
07:27:40 <safinaskar> well, this is bad
07:27:59 <safinaskar> so if i want general solution, i need to use template haskell
07:28:18 <safinaskar> what i need is "case" with "_ -> return ()" added in the end
07:28:38 <safinaskar> and it seems that the only way to create one is actually create one using template haskell
07:28:41 <safinaskar> right?
07:29:35 <merijn> safinaskar: Yes, but I wouldn't go that route
07:29:57 <merijn> safinaskar: I'm pretty sure your problem can be solved more elegantly, but you haven't actually told us what the actual problem is, so it's hard to say
07:33:08 <safinaskar> merijn: i already said. i will repeat: i want language construct MYCONSTRUCT such that for any type TYPE with CTOR as one of its constructor and for any variable "variable" with type TYPE and for any expression EXPR i get "MYCONSTRUCT variable CTOR EXPR" replaced with "case variable of { CTOR _ _ _ _ _ _ -> EXPR; _ -> return (); }"
07:33:22 <safinaskar> merijn: and it seems the only way to do this is use template haskell
07:33:43 <safinaskar> merijn: if TYPE is bool and CTOR is True, then, yes, we can just use "when"
07:33:56 <safinaskar> merijn: but as i understand there is no general solution for all datatypes
07:36:03 <merijn> That's not a definition of "what you're doing", I mean *very specifically* what exact code are you wrting and what does it do. Not some abstract "I want to write code pattern X"
07:36:10 <merijn> Because this sounds like an XY problem to me
07:37:16 <Solonarv> note: you *can* define such a construct using prisms
07:40:08 <lavalike> safinaskar: I was thinking along this way:
07:40:12 <lavalike> :t when . isJust
07:40:13 <lambdabot> Applicative f => Maybe a -> f () -> f ()
07:40:22 <lavalike> where you define isA in your example
07:40:54 <lavalike> with template haskell you can definitely create whenA whenB whenC programmatically too
07:41:53 <Solonarv> TH leaves a bad taste in my mouth for this kind of thing
07:41:59 <merijn> The thing is, if he (for example) wants to process a list/collection of X's with a single pattern you can capture that nicely with list expressions
07:42:12 <merijn> TH is massive overkill for this and likely not necessary
07:42:16 <lavalike> (:
07:42:32 <lavalike> it's probably enlightening to do it both ways and compare
07:47:14 <safinaskar> it seems i found a solution
07:47:29 <safinaskar> first i will say this: Maybe is instance of MonadFail
07:47:51 <safinaskar> so, even if MonadFail proposal get into mainstream, Maybe still will be instance of MonadFail
07:47:55 <safinaskar> now see my code:
07:47:57 <safinaskar> when (isJust $ do { A _ <- Just x; }) $ Left "error"
07:52:32 <Solonarv> https://gist.github.com/Solonarv/0f88493882c608f1cfe523111e295938 -- wheee, lenses!
07:53:25 <Solonarv> er, prisms, I guess
07:53:31 <safinaskar> merijn: Solonarv: lavalike: but this is still too repetetive (i am about my solution with Just)
07:53:56 <safinaskar> merijn: "I mean *very specifically* what exact code are you wrting" - i see this pattern in my code every time
07:54:30 <Solonarv> how is this "repetitive"? at the use site it's just: whenP' _Leaf $ Left "blah blah"
07:54:56 <safinaskar> merijn: i very often see in my code this:     {- line 1 -} case x of {- line 2 -} A _ -> throwError "err" {- line 3 -} _ -> return ()
07:55:21 <safinaskar> Solonarv: i am about my solution, not yours
07:55:33 <Solonarv> oh, I see
07:56:02 <safinaskar> merijn: and in C language this would be 2 lines instead of haskell's 3 lines
07:56:47 <safinaskar> merijn: in C you can always omit "default" case in switch and this will cause "do nothing". in haskell you cannot, you have to always write "do nothing" explicitly: "return ()"
07:58:08 <Solonarv> OTOH in haskell we can define control flow structures that are just plain old functions
07:58:43 <Solonarv> in haskell you can't have the default be "do nothing" because a haskell program isn't a series of instructions to execute one after the other
07:59:07 <Sornaensis> just add a syntax extension for it in ghc
07:59:14 <Sornaensis> :D
07:59:19 <Solonarv> or, y'know, write a combinator for it
07:59:24 <merijn> safinaskar: My point is that you can probably replace 90% of those case with things like traverse_, etc. which already capture that pattern. But how specifically you can use things like traverse_ is hard to say without examples
08:01:21 <safinaskar> Solonarv: your solution is cool. thanks
08:01:51 <safinaskar> Solonarv: but i will probably just use full-brown "case"
08:02:45 <exio4> safinaskar: i'm confused about your code, what's the purpose of doing that check? afterwards you won't be able to do (without unsafe code) much with it other than pattern matching again 
08:04:33 <merijn> In general if that pattern occurs a lot in your code, your either propagating errors too far or not far enough, I think
08:07:27 <Solonarv> *nod*
08:09:38 <merijn> Because you wanna either throw right away when getting the "wrong" input, or just aggregate everything at the end and report all errors in one go
08:10:10 <Welkin> is there a way to branch in json parser (aeson) when decoding to a sum of products?
08:10:13 <Welkin> or is that not possible?
08:10:34 <merijn> Welkin: Eh, <|> should work, no?
08:10:39 <Welkin> or, is there a way to branch based on the value of a previous field that was decoded?
08:11:07 <Welkin> oh, it's that easy?
08:11:30 <Welkin> A (...fields) <|> B (...fields)
08:11:41 <merijn> Welkin: aeson's parser is an instance of Alternative, so it should be, yes
08:11:42 <Welkin> I haven't used real parsers in a long time
08:11:44 <Welkin> I'll try that
08:12:15 <Solonarv> Welkin: aeson's Parser is a monad, so yes, you can branch on field values
08:12:16 <merijn> Welkin: <|> for parsers is generally just left-biased backtracking parse
08:12:24 <Welkin> I wrote a lot of parsers in elm last night, and it uses a monodic interface
08:12:30 <merijn> Solonarv: Monad is not sufficient for branching parses
08:12:35 <Welkin> monadic*
08:12:44 <Solonarv> yes, but Alternative isn't either
08:12:50 <Solonarv> you need Monad + Alternative
08:12:54 <merijn> Solonarv: Alternative is sufficient for branching
08:13:05 <merijn> Solonarv: You need Monad for parsing that depends on previous results
08:13:05 <Solonarv> yes, but not for branching on a field value
08:13:23 <merijn> Solonarv: You can, it'll just be very inefficient
08:13:50 <Solonarv> Only if you have a "match" primitive, no?
08:13:57 <Solonarv> which AFAIK aeson's parser doesn't have
08:14:01 <Welkin> how do I ignore (discard) fields after parsing them?
08:14:14 <Solonarv> wdym? fields in the JSON you haven't used?
08:14:15 <merijn> Welkin: eh, don't use them in the result? :p
08:15:09 <Welkin> more generaly, my approach so far to encoding ADTs as json has been to include a "type" and "ctor" field to use in decoding it properly. Does anyone have a better approach or is this it?
08:15:11 <Solonarv> you don't need to do anything in particular, aeson won't error if a field is uused
08:15:56 <Welkin> Solonarv: I mean throwing away a field like "type" or "ctor" that are only used for the branching logic
08:16:24 <merijn> Welkin: Well, it depends on whether variants can overlap or not
08:16:31 <Solonarv> I mean... the same way you "throw away" any value? you just don't use it, that's all
08:16:45 <Solonarv> Haskell has no "must use values" rule
08:16:50 <merijn> Welkin: <|> is left-biased, so it will just use the left-most parser that succeeds
08:17:34 <merijn> Welkin: You only need an "extra" tag if the parse is ambiguous without it (i.e. multiple parsers could succeed and always picking "left-most" isn't acceptable)
08:18:07 <Welkin> Solonarv: this is how I have been writing the parsers: `NewChatMessage <$> v .: "ctor" <*> v .: "body"`
08:18:17 <Welkin> that consumes all values
08:18:26 <Solonarv> ooooh that's what you were asking
08:18:29 <Welkin> I could wrap NewChatMessage in a lambda
08:19:07 <Solonarv> ... why does NewChatMessage even have a field corresponding to 'ctor'??
08:19:23 <Solonarv> wait, I'll whip up a gist
08:20:18 <Welkin> because it's really a sum of products
08:20:27 <Welkin> well, ChatMessage is
08:20:53 <Welkin> this to to create it in the database, for which I don't have all the data when it comes in through the initial request, hence NewChatMessage
08:21:16 <Welkin> this is between Elm <-> Haskell
08:23:28 <Solonarv> https://gist.github.com/Solonarv/88d184f946286a4f4362c3aa7768c2ed -- here's what I was thinking
08:24:08 <merijn> That constructor string seems redundant there
08:24:47 <Welkin> merijn: it represents a sum type with two constructors
08:25:12 <Solonarv> still, your /constructors/ shouldn't have a "constructor" field
08:25:16 <Welkin> the other thing I didn't mention is that I also have a representation for this in the database (postgres) using a custom postgres enum
08:25:22 <Solonarv> did you see my gist?, btw?
08:25:31 <Welkin> Solonarv: it has to, otherwise I don't what know type of message it is
08:25:46 <Solonarv> nooo, you can do that with an ordinary function
08:26:03 <merijn> Welkin, Solonarv: This would work just as well: https://hastebin.com/ipowidehir.coffeescript
08:26:06 <Welkin> I don't think I'm explaining it right
08:26:32 <Solonarv> 'constructorTag :: Event -> String; constructorTag = \case NewChatMessage{} -> "NewChatMessage" ...'
08:26:54 <Welkin> NewMessage only comes from outside, and only has a FromJSON instance. It is used solely to create the object in the database. ChatMessage is the real representation of the data that is stored in the database and goes out (ToJSON)
08:27:12 <Solonarv> merijn: that only works if all the constructors have different fields
08:27:30 <merijn> Solonarv: Well yes, that's what I said
08:27:40 <merijn> Solonarv: But that's a common enough case
08:29:36 <Solonarv> the problem I have with that is: what if your fields are non-overlapping, but then you add a constructor which has the same fields as an existing one? And perhaps you don't notice, so you just add it to the end of the list
08:29:40 <Solonarv> Now your parser is broken!
08:30:59 <Welkin> thanks for the help, I think I can do what I need to do with it now
08:31:11 <Welkin> this brings up another question though
08:31:30 <Welkin> What about storing/retreiving a sum of products from a database?
08:31:55 <Welkin> I can store products just fine (of course) and even simple sums (converting to a postgres enum type I defined)
08:32:05 <Solonarv> the trite answer is "depends on the DB"
08:32:13 <Welkin> I would have to take the same approach as in json for this
08:32:25 <Welkin> where I pull out the constructor value to branch on
08:32:39 <merijn> Postgres has a JSON backend, so...
08:32:47 <Welkin> yeah, but I don't store it as json
08:33:16 <Solonarv> I wouldn't be massively surprised to learn that postgres just supports ADTs out of the box, tbh
08:37:36 <hyperisco> Solonarv, not a chance last time I used it (3 years ago I think)
08:37:50 <Solonarv> mmm, I just had a google and it looks like it doesn't
08:38:48 <Solonarv> you could use nullable columns I for the fields + an enum to identify the constructor, I guess
08:39:06 <hyperisco> maybe this is reason to modernise relational databasing
08:39:48 <hyperisco> also I'd like to see bidirectional views
08:40:10 <Welkin> One of the fields stored in the database will be an escaped string of json data. Will including this directly in the output of an encoded data type work, or will it be double escaped and encoded wrong?
08:40:37 <hyperisco> why would you store it escaped?
08:40:38 <Welkin> using toEncoding
08:40:49 <berndl> Storing ADTs in a relational database is asking for trouble.
08:41:26 <Welkin> I'm storing it escaped because my server application doesn't need to know about it othe than it is data that the client sent for storage and later retrieval
08:41:37 <hyperisco> Postgres has JSON querying support, but you need to store it as JSON
08:41:44 <Welkin> I don't want to query it
08:41:46 <Solonarv> if you know it's JSON, why not store it as JSON?
08:41:49 <Welkin> it is a blob of opaque data
08:42:05 <Solonarv> or at least a /binary/ blob
08:42:44 <hyperisco> Mkay then it comes out the same way you put it into the database. I don't know about the rest.
08:43:29 <Welkin> it gets decoded on the client
08:44:06 <Welkin> I am storing it in the same field as normal Text
08:44:21 <Welkin> this is the part where I'm trying to store an ADT in a table entry
08:47:18 <Welkin> I wonder if I keep the data as Value instead of Text and store it directly in postgres through postgresql-simple
08:48:18 <Welkin> then instead of sharing a field, there are two fields, let's say "body" and "json" that are both Maybe/nullable, and I'd have to branch on the constructor field when decoding from the database
08:51:59 <Welkin> thanks Solonarv and merijn. I ended up changing to using `data NewChatMessage = NewChatMessage Text | NewDiceRollMessage Value` and branching on the constructor in parseJSON
08:52:11 <Welkin> I'll see how that goes
08:57:32 <Welkin> haha
08:57:40 <Welkin> postgresql-simple just re-encodes it again
09:01:12 <Welkin> but when I am working with it inside parseJSON it's already fully decoded into a Value, so it makes the most sense to leave it that way and let pg handle the re-encoding
09:04:20 <dminuoso> It makes a lot of sense to re-encode it. You probably dont want to couple your database to an external JSON format.
09:06:38 <leshow> im fiddling with the websocket example, that uses an mvar for the application state. what are the options if I wanted state modifications to use something nonblocking, but keep the state in memory
09:07:21 <merijn> leshow: Define "non-blocking"
09:07:24 <leshow> I was thinking of moving the state to it's own thread and communicating with it through channels, is there anything like an actor library for haskell
09:07:38 <merijn> leshow: MVar only blocks if you have multiple threads modifying concurrently
09:07:47 <merijn> leshow: In which case you *want* to block
09:08:05 <leshow> I think that may happen if multiple users joined simultaneously
09:08:31 <merijn> leshow: Right, which means you want it to block, because else you get race conditions
09:09:14 <merijn> leshow: You might also wanna consider STM?
09:10:06 <merijn> leshow: I think there's a couple actor-style libraries, but not really one that's really blown me away
09:10:48 <merijn> leshow: But STM is often a nice alternative to actors, since it gives you the simplicity of shared mutable state with the nicety of atomic transactions :)
09:12:17 <leshow> merijn: thanks I think I'll go the STM route
09:13:43 <leshow> I was playing with actix in rust and wanted to do a comparison between using ws w/ haskell&websockets and actix-web, but it's a little apples to oranges
09:14:34 <Welkin> those are completely different
09:14:43 <Welkin> actix is an actor-model library
09:14:56 <Welkin> the closest comparison would be distributed haskell, which is erlang-in-haskell
09:15:12 <Welkin> also websockets is a protocol
09:16:20 <leshow> I was referring to the library 'websockets'
09:18:08 <Welkin> http2 with server-sent events makes websockets obsolete for all but the most specialised use-cases
09:18:32 <Welkin> also, you don't need to re-invent http on top of websockets
09:18:56 <Welkin> unless you're making a video game that is, and aren't actually using http for anything other than to establish the initial connection
09:19:10 <juri_> z,cb 31
09:21:20 <lavalike> > (2^64-1 :: Word64)+1
09:21:24 <lambdabot>  0
09:21:34 <lavalike> I'm curious, since 2^64 does not fit in Word64, where does that calculation happen?
09:23:01 <berndl> Isn't it because of overflow?
09:23:44 <dmwit> lavalike: I'm not sure I understand the question yet.
09:24:24 <dmwit> lavalike: For example, how would you answer for a calculation you *do* understand? Where does the calculation `1 + 1 :: Word64` happen?
09:24:52 <ragusa> >  2^64 - 1 :: Word64
09:24:55 <lambdabot>  18446744073709551615
09:25:11 <dmwit> > 0-1 :: Word64
09:25:13 <lambdabot>  18446744073709551615
09:27:40 <Ariakenom> > (18446744073709551614, 18446744073709551614+1,18446744073709551614+2,18446744073709551614+3) :: (Word64,Word64,Word64,Word64)
09:27:44 <lambdabot>  (18446744073709551614,18446744073709551615,0,1)
09:27:55 <dmwit> Another one that may be fun to ponder:
09:28:35 <dmwit> > [2^(2^63 :: Word64), 2^(2^64 :: Word64)] :: Word64
09:28:43 <Solonarv> TL;DR arithmetic on Word64 is module 2^64
09:28:44 <lambdabot>  error:
09:28:44 <lambdabot>      • Couldn't match expected type ‘Word64’
09:28:44 <lambdabot>                    with actual type ‘[Integer]’
09:28:57 <dmwit> > [2^(2^63 :: Word64), 2^(2^64 :: Word64)] :: [Word64]
09:28:59 <lambdabot>  [0,1]
09:29:35 <dmwit> > [2^(2^63 :: Word64), 2^(2^64 :: Word64), 2^(2^64 :: Integer)] :: [Word64]
09:29:37 <lambdabot>  [0,1,0]
09:31:57 <lavalike> dmwit: I'm guessing probably in Integer
09:33:40 <dmwit> lavalike: Oh, nope. (1 + 1 :: Word64) definitely doesn't cast the two 1's from Word64 to Integer, add them, then cast back.
09:33:47 <dmwit> lavalike: The addition is done directly in Word64.
09:34:27 <dmwit> lavalike: And the same thing is true of 2^64 :: Word64. The power operation is all done in Word64 directly. No Integer involved at all.
09:34:39 <dmwit> lavalike: ...which means that it gets the wrong answer, of course!
09:34:41 <geekosaur> sufficiently recent ghc(i) should actually reveal what's going on, at least with -Wall
09:34:57 <dmwit> lavalike: The fact that 2^64-1 :: Word64 appears to get the right answer is mostly a coincidence.
09:35:10 <lavalike> hah
09:35:10 <dmwit> lavalike: Check out these wicked facts:
09:35:38 <lavalike> > 2^1263781263817236172396 :: Word64
09:35:41 <dmwit> > ((2^64 :: Word64) == 0, (2^64-1 :: Word64) == 0-1, (2^65 - 1 :: Word64) == 2^64-1)
09:35:41 <lambdabot>  0
09:35:43 <lambdabot>  (True,True,True)
09:35:59 <lavalike> yeah
09:36:26 <Taneb> > 2^65 :: Word64
09:36:28 <lambdabot>  0
09:36:29 <lavalike> 0
09:39:56 <dmwit> lavalike: Do you feel like your question has been answered now?
09:40:18 --- mode: glguy set +v ScriptRunner
09:40:32 <ScriptRunner> I've looked into GLUT and GLOSS
09:40:35 <lavalike> there is definitely still some magic happening since ^ is a function, not a literal number syntax, like say, 'NNNeMM'
09:40:57 <lavalike> but at least the computation happening in the given type does make sense, it being coincidentally right works out
09:41:41 <lavalike> actually no magic, just defaulting of the exponent type, and that's it
09:41:56 <phadej> :t (^)
09:41:57 <lambdabot> (Num a, Integral b) => a -> b -> a
09:42:12 <phadej> :t (^^)
09:42:13 <lambdabot> (Integral b, Fractional a) => a -> b -> a
09:42:27 <phadej> :t (*)
09:42:28 <lambdabot> Num a => a -> a -> a
09:42:29 <phadej> :t (**)
09:42:30 <lambdabot> Floating a => a -> a -> a
09:42:49 <phadej> enough variation
09:42:58 <Ariakenom> > 2^(64 :: Word64)-1+1 :: Word64
09:42:59 <lambdabot>  0
09:43:00 <ScriptRunner> What a good bot
09:43:30 <lavalike> @botsnack
09:43:30 <lambdabot> :)
09:43:52 <malice> Is there any good program that you'd recommend to write to learn Haskell? I want to learn it, but I don't really want to write something like web server or similar, I'd love to learn all the tasty haskell bits in the process.
09:43:53 <Ariakenom> lavalike: the defaulting doesn't matter
09:44:10 <Lears> Not really a coincidence that 2^64 - 1 :: Word64 gets the right answer -- that our operations are well behaved in modular arithmetic is a pivotal algebraic fact. 2^64 ~ 0 --> (2^64 - 1) ~ (0 - 1)
09:44:10 <ScriptRunner> Hi everyone, whats the best way of running a function every 5 seconds? I've been stuck with this for ages :-(
09:44:16 <lavalike> Ariakenom: not for the answer I agree, just trying to figure out what are all the degrees of freedom
09:44:17 <dmwit> malice: There's a somewhat famous Haskell tutorial that has you implement a Scheme, I think.
09:44:35 <malice> dmwit: yeah, it's also pretty old
09:44:47 <ScriptRunner> malice: I recommend the craft of functional programming if you like books, thats what I'm using
09:44:48 <malice> I went through it, it's fine but a bit old.
09:45:08 <malice> (not relating to the book, but rather the scheme tut)
09:45:10 <dmwit> malice: Then I recommend writing a program you want to use.
09:45:35 <malice> dmwit: but I already got my Emacs :(
09:45:36 <dmwit> ScriptRunner: cron, I guess. But if you want a pure Haskell solution, fork a thread and use threadDelay.
09:46:34 <malice> ScriptRunner: I'll try out the book then, thjanks for the suggestion
09:46:57 <dmwit> Lears: Yes. But your ~ is not ==. In particular 2^65 ~ 0, and 2^65 - 1 ~ 0 - 1, but 2^65 - 1 :: Word64 doesn't get the actually correct answer, because Word64 can't represent the actually correct answer.
09:46:58 <lavalike> > (fromIntegral (2^65 :: Word64) / fromIntegral (2^3 :: Word64)) == fromIntegral (2^(65-3) :: Word64) -- Lears in this sense, if you will
09:47:00 <lambdabot>  False
09:50:38 <Lears> I mean, Word64 is Z/(2^64)Z as far as I'm concerned, so a ~ b on Integer is actual == on Word64.
09:50:40 <MarcelineVQ> ScriptRunner: it depends mainly on whether you want the result of the function, in which case there's a lot of options and approaches people could recommend. if you don't need the result dmwit's suggestion is by far the easiest. forkIO with forever and a threadDelay
09:51:11 <Ariakenom> dmwit: what's the right answer then?
09:56:34 <Welkin> if you want the result, write it to a Chan
09:56:59 <dmwit> Ariakenom: What's the question?
09:57:26 <Ariakenom> "2^65 - 1 :: Word64 doesn't get the actually correct answer"
09:57:39 <dmwit> > 2^65 - 1 :: Integer -- the actually correct answer
09:57:41 <lambdabot>  36893488147419103231
09:57:48 <Welkin> you can still use the simple forkIO $ forever (threadDelay us >> function)
09:58:16 <Welkin> > 2^34536456 -1 :: Integer
09:58:19 <lambdabot>  1584635121609061840726465392580930321927889476706650715680003880672827054602...
09:58:21 <Welkin> haha
09:58:33 <dmwit> Turns out, computers are really, *really* fast at arithmetic. =)
09:58:55 <Ariakenom> dmwit: not modulo 64
09:59:04 <dmwit> Ariakenom: My point in a nutshell, yes.
09:59:24 <dmwit> Ariakenom: (And you meant modulo 2^64. ;-)
10:00:09 <Ariakenom> dmwit: I think we define == differently 
10:02:20 <Ariakenom> why can't == be modular congruence
10:03:44 <dmwit> Ugh. Look, the whole conversation started from a point of confusion about modular congruence. I took the (what I think is pedagogically quite sound) stance of therefore eliminating it from my vocabulary briefly, so that I could talk with the confused person in language they could understand.
10:06:50 <Ariakenom> ok
10:09:02 <crysikrend> Hey everyone, I want to make a mobile game and I want to make the logic server side (you know, to make purchases secure and what not). How suitable would Haskell be as a server-side language dealing with games? It won't render frames or anything like that, it will simply send and receive data. I'm not sure how fast things need to be to be honest, I'm more worried about reliability and security and I feel
10:09:04 <crysikrend> like with Haskell making clean code is much easier. There will most likely be a database for player accounts which will need accessing as well. I'm just doing research on my options or whether to just go C++. Thank you!
10:09:23 <Welkin> Clean is a language
10:09:57 <Welkin> https://clean.cs.ru.nl/Clean
10:10:26 <crysikrend> do you think that's more suitable than Haskell? 
10:10:31 <Welkin> no
10:10:33 <Welkin> it was a joke
10:10:39 <crysikrend> I thought so haha
10:10:48 <Welkin> Clean is a cool language, but Haskell is much more practical for building applications
10:10:49 <crysikrend> I thought it was a little odd
10:10:59 <Welkin> yes, haskell is a very good choice to a web server
10:11:12 <Welkin> performance is great, it has built-in concurrency and parallelism
10:11:39 <crysikrend> This is a tough one. I've tried making games in Haskell and doing logic is such a breeze. I can use some engine to simply interpret the HTTP requests, but the game itself will be a simple data based puzzler (2D array for tiles = done). I figured that Haskell will just be so much nicer to work with
10:11:54 <crysikrend> My worry is the whole database thing and connecting to the internet, never touched that stuff
10:11:56 <Welkin> games in haskell is tough because of opengl and the garbage collector
10:12:09 <Welkin> but haskell is one of the best choices for web servers
10:12:21 <Welkin> database support is really good
10:12:23 <crysikrend> but I haven't touched that in C++ either. So I have to choose which to learn for the server side logic
10:12:28 <crysikrend> ah that sounds like everything I wanted
10:12:41 <Solonarv> For a game server I don't see any particular reason *not* to use haskell; it tends to be pretty good for backends
10:12:51 <crysikrend> because I can still build the gmae in haskell, just not draw it. It's kind of perfect to be honest
10:13:01 <leshow> Welkin: what library do you use for interaction with db
10:13:04 <hyperisco> crysikrend, Haskell struggles with realtime for a variety of reasons. For doing CC transactions it won't be a problem.
10:13:05 <Welkin> use this web server https://hackage.haskell.org/package/scotty
10:13:07 <Solonarv> the main reason not to use haskell on the backend would be sharing code with the frontend
10:13:22 <Welkin> I am using it now to build a real-time collaborative document service
10:13:23 <crysikrend> if I wanted logic every frame I wouldn't do haskell, but to be honest I think for async it should do fine? hyperisco It will basically be a slow puzzle game, not real time :) 
10:13:39 <Welkin> I use postgresql-simple for the database layer (well, for postgres)
10:13:42 <Welkin> I also use redis
10:13:50 <leshow> There's a youtube video about the new GC that's coming in possibly ghc 8.10, the concurrent generational GC
10:13:57 <leshow> it's supposed to significantly reduce pause times
10:14:02 <crysikrend> hyperisco: for simplicity - lets say candy crush. The sweets are stored on the server and the state is sent to the client and the client responds with a move, the game is played on the server
10:14:22 <crysikrend> Welkin: No idea about that stuff thanks for the topics to look up
10:14:28 <leshow> https://www.youtube.com/watch?v=7_ig6r2C-d4
10:15:04 <hyperisco> crysikrend, you won't have a problem with that.
10:15:18 <oak> What about hasql for postgres?
10:15:42 <crysikrend> oak: I don't know what postgres is nor hasql, but I like the name hasql already
10:15:52 <oak> Btw this discussion reminds me about the fact that the game called Hedgewars has server written in Haskell: https://github.com/hedgewars/hw/tree/master/gameServer
10:15:56 <Welkin> my recommendation to start is use scotty for web server library (linked above), postgresql-simple for the database (or similar)
10:16:28 <Welkin> if you know sql you can use posgtresql-simple easily: you just write normal sql
10:16:30 <MarcelineVQ> leshow: got that link? we already have parallel generational gc so I'm interested to see what that's about
10:16:39 <MarcelineVQ> oop you linked it
10:16:47 <Welkin> I heard about that concurrent generational gc before
10:16:48 <leshow> concurrent sorry
10:16:53 <Welkin> there was a paper I downloaded nut never read
10:16:58 <Welkin> but*
10:17:45 <phadej> ben's talk about moving/non-moving gc: https://www.youtube.com/watch?v=7_ig6r2C-d4
10:17:51 <leshow> The speakers mentions tradeoffs between what ghc is implementing and what's done in Go. Essentially they are using a non-generational concurrent gc, which further reduces pause times at the cost of throughput and pretty much everything else
10:18:06 <phadej> go uses non-moving gc
10:18:10 <phadej> ghc uses moving atm
10:18:20 <phadej> that's the main difference
10:18:26 <crysikrend> I have done only a bit of SQL, the basics of CRUDding.
10:18:32 <leshow> I'm talking about the difference between the proposed GC and Go
10:18:35 <leshow> not the current GC
10:21:30 <rcat> i also watch the video about the new GC coming, looks pretty promising 
10:21:55 <phadej> ben mentions though (or that way I understood) that upcoming GC can be tuned so there are no (moving) nursery; so you can sacrifice "everything else" too
10:21:56 <rcat> i have to say, that as much as i don't enjoy coding in Go, having a low-latency GC makes your life easier to server side software in some industries
10:22:24 <c_wraith> Go's GC seems to have made some weird tradeoffs.
10:22:41 <c_wraith> Guaranteeing latency means that you can go out of memory even with a small working set.
10:23:43 <rcat> i remmeber reading somewhere, that Go has a pretty sophisticated model to slow down the mutator to accomodate when too much garbage is being generated
10:23:57 <rcat> exactly the same answer Ben in the video gave
10:24:15 <c_wraith> I guess that makes sense.  You're already sacrificing throughput for latency, so you might as well make it worth it.
10:24:51 <Zemyla> Is there a plan for at least multithreaded GC? I mean, most people have two processors, or two cores on one processor.
10:24:59 <amx> yes
10:25:27 <rcat> the existing GC is already parallel, the new one, as far as i understood, will also be
10:25:49 <phadej> nice example of "parallel and concurrent" meaning completely different things!
10:25:51 <rcat> he mentions, don't expect infinite scalability, a 32 core machines has more overhead coordinating the GC work than a 4 core machines
10:26:06 <rcat> ah true true
10:26:14 <c_wraith> the parallel GC has had correctness issues before.  It's been a long time since I had to worry about them, though. 
10:26:20 <c_wraith> Did they get fixed?
10:26:37 <rain1> phadej: you could have a program that uses 128 green threads on a 4 core processor, then there is 4 parallel threads running ~32 concurrent green threads each
10:26:41 <c_wraith> (I just remember "turn off parallel GC" as a way to make programs stop crashing under load)
10:27:07 <rcat> oh, nasty i never saw that before
10:27:40 <phadej> I won't be surprised if simonmar & facebook team fixed most bad "under load" bugs :)
10:28:47 <AndreasK> If I remember correctly there are currently no plans to go completely non-moving in the new GC as this would require more changes than what he presented at MuniHac does. But it might be an option in the future.
10:30:33 <phadej> (Note that we currently don't allow -xn with -G1 because of some implementation-related issues. We may be able to fix this before the release, but maybe we want to leave this because if you make generation 0 non-moving you lose aging as generation 0 is used to implement aging)
10:30:38 <phadej> in https://www.reddit.com/r/haskell/comments/9ygoy1/munihac_2018_keynote_a_lowlatency_garbage/
10:34:32 <crysikrend> Okay, decided to go for Haskell I think for server side language. Need to get to planning how things are going to look
10:34:57 <c_wraith> Aging is a cute trick to remove several young generations from the memory space.
10:35:25 <c_wraith> (alternatively, to pretend the nursery is a lot bigger than it actually is)
10:35:30 <Welkin> you mean remove the old generations
10:35:44 <Welkin> haha
10:36:00 <Welkin> if someone were to walk in on people talking about this, they would be confused
10:36:09 <Welkin> the terminology is funny
10:36:22 <c_wraith> Aging is the name for the thing where an object isn't promoted out of the nursery if it's alive on the first nursery collection when it's alive.
10:36:43 <Welkin> like aging a fine cheese, or wine
10:36:43 <c_wraith> Which I suppose prevents a lot of spurious promotion of short-lived things that are just alive at the wrong time.
10:38:50 <phadej> makes sense
10:39:49 <c_wraith> yeah, it probably is a significant performance improvement in the GC for a lot of common use patterns and not much complexity.
10:44:55 <dmj`> crysikrend: congrats 
10:46:27 --- mode: glguy set +v pjrt
10:46:30 <pjrt> Eden, Young, etc, etc
10:47:08 <pjrt> Disclaimer: I am not that familiar with GCs
10:52:14 <monochrom> Eden eh? So no one dies, no need for GC? >:)
10:54:32 <dmj`> Does anyone have an example of a Storable written on a recursively defined struct?
10:54:47 <pjrt> monochrom: lol, I am like 90% sure I've heard that term 
10:56:04 <pjrt> https://goo.gl/images/mJ5W76
10:56:18 <pjrt> I guess Permanent is "eden"?
10:57:03 <monochrom> But it writes "eden" on the left end.
10:57:37 <monochrom> Perhaps this is Eden in the sense of "you were created here" and also "soon you will have to leave".
10:57:44 <pjrt> Opps, I can't read
10:58:03 <pjrt> Yeah, Garden of Eden as "start", not as "eternal life"
11:06:00 <c_wraith> dmj`: Storable doesn't map very well to recursive types.  I'm not sure I've ever seen it used for that successfully.
11:06:31 <dmj`> c_wraith: I assume you'd have to test for a null ptr and then wrap it in a maybe
11:06:54 <c_wraith> dmj`: Storable doesn't even work very well for types with multiple constructors.
11:07:19 <dmj`> c_wraith: you mean unions ?
11:07:42 <geekosaur> tagged unions, effectively
11:07:46 <c_wraith> dmj`: Storable is for Haskell types more than native types.
11:08:19 <c_wraith> You can do all sorts of things with C types that work very poorly in Haskell
11:09:53 <c_wraith> Like..  Good luck mapping a C function pointer to a Haskell type.
11:11:25 <Solonarv> that's mostly because C structs unpack their fields, no? whereas in haskell ctor fields are pointers, roughly speaking
11:11:59 <c_wraith> Well, that's the thing Storable is actually for mapping between.
11:13:51 <phadej> Storable is fixed size
11:14:00 <phadej> sizeOf :: a -> Int -- Computes the storage requirements (in bytes) of the argument. The value of the argument is not used.
11:14:19 <phadej> so recursive types are out
11:14:32 <phadej> but you can encode C-unions
11:14:45 --- mode: glguy set +v Boarders
11:14:48 <c_wraith> assuming they're discriminated
11:14:54 --- mode: glguy set -v Boarders
11:14:55 <phadej> yes
11:14:56 <Solonarv> (blergh, not using proxy)
11:15:18 <phadej> Storable is "@since base-2.1"
11:15:31 <Boarders> I am trying to write a data type as binary to a file and then read it but when I run it I get:
11:15:34 <Boarders> "hGetContents: invalid argument (invalid byte sequence)"
11:15:41 <Boarders> is anyone familiar with the problem?
11:15:48 <geekosaur> Boarders, don't use hGetContents
11:15:56 <Boarders> I am not
11:15:58 <geekosaur> it reads characters, by default UTF8
11:16:01 <c_wraith> if you're using System.IO.hGetContents, it's trying to read it according to your system encoding
11:16:13 <c_wraith> Use Data.ByteString for reading binary data
11:16:42 <c_wraith> readFile uses hGetContents internally.
11:17:18 <geekosaur> in fact anything that goes through Char is wrong for binary data
11:17:41 <geekosaur> Char is a Unicode codepoint, not binary data
11:17:58 <Boarders> I appear to be using readFile from Data.ByteString.Lazy
11:18:19 <c_wraith> That seems improbable, given the exception you're getting.
11:18:38 <monochrom> How to reproduce it?
11:19:27 <c_wraith> I'd check your imports and your use of readFile to make sure the readFile you're calling is the readFile you think you're calling.
11:19:29 <Boarders> readFile in Data.ByteString.Lazy does use hGetContents
11:19:46 <c_wraith> Yes, but it doesn't have invalid byte sequence
11:19:48 <c_wraith> s
11:19:56 <geekosaur> -- Note: the 'Handle' should be placed in binary mode with
11:19:56 <geekosaur> -- 'System.IO.hSetBinaryMode' for 'hGetContents' to
11:19:56 <geekosaur> -- work correctly.
11:20:07 <geekosaur> you cannot do tis with readFile
11:20:21 <c_wraith> the readFile in ByteString should do that.
11:20:36 <glguy> it does
11:20:40 <geekosaur> mm, it does do openBinaryFile, ys
11:20:48 <c_wraith> So yeah.  Check your impots/uses
11:20:49 <Boarders> ah I see
11:20:51 <Boarders> I'll give that a try
11:20:54 <Boarders> thank you!
11:20:55 <geekosaur> soemthing is still doing encoding
11:20:57 <c_wraith> You're not calling the readFile you think you are.
11:21:12 <Boarders> I am literally calling BS.readFile
11:21:13 <monochrom> Usually types would tell you that.
11:21:15 <Boarders> idk man
11:21:41 <amx> A paste is worth a thousand words :)
11:21:52 <monochrom> Yeah. <monochrom> How to reproduce it?
11:21:57 <geekosaur> yeh, everyone here is guessing
11:22:20 <monochrom> Why do people prefer to act like call-in tech support?
11:22:46 <monochrom> "Have you power-cycled your computer?"
11:22:54 <monochrom> "How about your router?"
11:22:56 <mniip> @unpl (.) ($ op) ((.) (.) ((.) (.) op))
11:22:56 <lambdabot> (\ x x0 x1 -> op x (op x0 x1))
11:23:11 <zachk> "is your computer plugged in?" 
11:23:34 <AndreasK> "Is your recursion total?"
11:24:09 <zachk> AndreasK, I don't know, because I am trying to compute collatz sequences
11:24:10 <Boarders> https://gist.github.com/Boarders/a57d862bce8894d5771e885c94cec0bd
11:24:12 <monochrom> These IRC help channels are really sick economically.
11:24:14 <Boarders> here is what I am trying to do
11:25:14 <monochrom> The buyers pay up as little as possible. The sellers supply as much as possible.
11:25:43 <monochrom> (Here the buyers pay least information and the sellers supply maximum information.)
11:25:57 <mniip> @unpl (.) ((.) op) op
11:25:57 <lambdabot> (\ x x0 -> op (op x x0))
11:26:23 <c_wraith> Boarders: Looks to me like the invalid byte sequence is coming from the decode.
11:26:34 <monochrom> Makes me realize what Stephen Chang means when he writes "If people were not selfish, it would be hell, not paradise".
11:26:58 <hodapp> that sounds like something Ayn Rand would say
11:29:19 <Boarders> c_wraith: do you mean that the decode is using the wrong type or something else?
11:29:58 <c_wraith> Boarders: just that the input bytes are not compatible with what the Get instance for the type in question requires.
11:30:34 <monochrom> A error raised by decode would not brought up "hGetContents" either.  You would want to provide an input file that demos this.
11:31:51 <c_wraith> and mention what os you're running on.  And if it's a unixy os, what your locale settings are
11:32:17 <c_wraith> or if it's windows, what your language settings are
11:33:13 <Boarders> it is ubuntu 18.04
11:34:04 <c_wraith> add the output of "locale" to your gist.  along with the input file that's failing.
11:45:24 <dmj`> phadej: If we had a struct that contained a pointer to itself, I think we could encode it. data Thing = Thing { foo :: Ptr (Maybe Thing) }
11:48:23 <dmwit> But that's not a recursive type.
11:48:54 <dmwit> Hm. Now that I've said it aloud I wonder if I believe it.
11:50:35 <mniip> how long has the liftA2 lemma been there
11:51:04 <dmwit> What is the liftA2 lemma and where is "there"?
11:51:34 <dmwit> (Okay. I've decided I don't believe it: Thing is a recursive type.)
11:52:20 <mniip> it seems that in 4.10.0.0 the documentation for Applicative was extended with a new lemma: https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Applicative.html#t:Applicative
11:53:32 <Solonarv> dmwit: a generalization of "liftA2 op is associative when op is associative"
11:59:52 <Gigabitten> is Haskell a really good or really bad language for code golf? On the one hand it supports some pretty complicated stuff, but on the other hand it feels like Haskell's ability to do janky stuff is gated off by having to be very explicit when you do so
12:00:16 <hyperisco> Gigabitten, it is stellar
12:00:39 <Gigabitten> why's that?
12:01:29 <c_wraith> as long as you don't count imports
12:01:42 <c_wraith> Most of the good golfing tools are behind imports
12:01:50 <amx> Gigabitten: here's a package for you https://hackage.haskell.org/package/plumbers-0.0.3/docs/Control-Plumbers.html
12:01:51 <hyperisco> because often times there's a definition that does just what you need, or two that you can put together
12:02:06 <monochrom> What is janky stuff?
12:02:55 <Gigabitten> janky stuff is just, stuff that really shouldn't be allowed
12:02:58 <Gigabitten> but is
12:02:59 <hyperisco> functional programming likes to name patterns and the combinators to put them together
12:10:55 <Zemyla> Question: Is there a way to enforce that a data family is representational or phantom in one of the arguments that's not one the data family closes over?
12:11:28 <Zemyla> Like, say, data family Test (f :: * -> *) :: * -> *; type role Test nominal representational
12:18:01 <shapr> Tritlo: oh look! https://www.youtube.com/watch?v=ahYGUulhixc
12:18:55 <mniip> Solonarv, grab your theorem prover
12:19:12 <mniip> every applicative expression admits a normal form
12:19:12 <Solonarv> I don't have one though T_T
12:19:22 <mniip> pure _ <*> _ <*> _ ...
12:21:16 <Solonarv> that does *sound* right, yes
12:24:42 <dmwit> Gigabitten: On the code golf stackexchange, the shortest programs are regularly in languages designed for code golf (CJam, e.g.), not languages designed to be used for large-scale projects (Haskell, Python, C-family stuff). Surprise surprise.
12:26:00 <dmwit> > [(+), (*)] <*> [1,2] <*> [10, 20] -- mniip ?
12:26:03 <lambdabot>  [11,21,12,22,10,20,20,40]
12:26:30 <dmwit> > pure id <*> [(+), (*)] <*> [1,2] <*> [10,20] -- hm, maybe you're thinking of something like this
12:26:31 <mniip> slap a 'pure id <*>'
12:26:32 <lambdabot>  [11,21,12,22,10,20,20,40]
12:27:08 <mniip> dmwit, I mean like
12:27:31 <mniip> proving   liftA2 op xs (liftA2 op ys zs) = liftA2 op (liftA2 op xs ys) zs    from Applicative axioms is very tedious
12:27:35 <Gigabitten> dmwit: ah, makes sense!
12:27:49 <mniip> you need something like 20 axiom applications
12:36:44 <koz_> mniip: Any chance you could help me with my prior issues with using the If-based Ix'? I'm still having a bit of writing trouble: https://gist.github.com/kozross/50996aff731be6b8f400a9a6a75d7d2b
12:38:16 <mniip> koz_, that's already wrong
12:38:31 <koz_> mniip: In what way?
12:38:57 <mniip> sIf from singletons is your only savior here
12:39:21 * koz_ checks sIf.
12:39:47 <mniip> the whole point about using the If family is sIf
12:40:30 <mniip> it's sIf that gives you ability to make use of a type family equation in the "False" branch
12:41:15 <mniip> actually...
12:41:17 <mniip> hmm
12:41:31 <koz_> Ah, I see how that'd work.
12:41:37 <koz_> (or at least in theory)
12:42:02 <mniip> that only works for Sings doesn't it
12:42:30 <koz_> Yeah, AFAICT.
12:43:13 <Welkin> talking about Sings makes me think you mean an Indian family
12:44:38 <koz_> mniip: So I basically need to grab Sings for 'Len ns == 0', 'Len ns == 1', etc, and then construct an Ix' based on that?
12:44:46 <mniip> data K = K0 | K1 | K2 | Kn Nat
12:44:55 <mniip> type family ToK :: Nat -> K
12:45:07 <mniip> -- use If
12:45:20 <mniip> type family Ix' :: K -> *  -- this one can be an open tyfam
12:45:34 <mniip> then make K an instance of Sing
12:45:53 <mniip> then you have  Ix n :~: Ix' (ToK n)
12:45:54 <koz_> Using DerivingSingletons or something?
12:46:41 <mniip> you can write it by hand if you wish
12:47:57 <mniip> data instance Sing (a :: K) where SK0 :: Sing K0; SK1 :: Sing K1; SK2 :: Sing K2; SKn :: Sing n -> Sing (Kn n)
12:48:57 <mniip> instance SingI K0 where sing = SK0
12:49:00 <mniip> you get the idea
12:49:04 <koz_> Yep.
12:49:33 <warbo> hello, I'm pretty new to lenses, and having trouble using lens-aeson to get/set a JSON array of strings (inside an object)
12:50:07 <warbo> I can get an individual string (as Text), but not the array (as [Text] or [String])
12:50:37 <warbo> not sure if I should be putting 'each' or 'traverse' in my lens, or whether I should be using '^..' when applying it to my string of JSON, or what :(
12:51:28 <mniip> DeriveSingletons doesn't sound like a real extension
12:51:38 <koz_> mniip: genSingletons was what I meant.
12:51:40 <mniip> the library probably exports TH magic instead
12:51:41 <koz_> Sorry, it's early.
12:51:42 <mniip> yeah
12:52:20 <warbo> gah, sorry everyone; I've apparently got to make a move right now (will probably be back later), so no need to answer me!
12:53:15 <koz_> OK, I'm getting weird errors.
12:53:33 <koz_> Let me paste.
12:54:30 <koz_> mniip: https://gist.github.com/kozross/50996aff731be6b8f400a9a6a75d7d2b
12:55:14 <mniip> koz_, -ddump-th-splices
12:55:42 <mniip> I think singletons expects you to write Natural instead of Nat
12:55:45 <mniip> but that kinda breaks stuff
12:56:25 <mniip> also slightly irrelevant but find a better name for K. I chose K because your nick begins withb that :P
12:56:49 <koz_> mniip: Lol, I will, in time.
12:57:16 <koz_> mniip: https://gist.github.com/kozross/50996aff731be6b8f400a9a6a75d7d2b#gistcomment-2763842
13:10:28 <matheus23> Hi! I'm trying out deriving-via. I wrote the following: data MyPair = MyPair Int Int deriving Arbitrary via (Positive Int, Positive Int)
13:10:46 <Franciman> Hi
13:10:52 <matheus23> ghc complains, however, since (Positive Int, Positive Int) doesn't match the representation of MyPair. How do I fix that?
13:11:36 <heptahedron> matheus23: using a newtype declaration instead should work
13:11:58 <Franciman> are os and arch values documented somewhere? ( os and arch of this module: http://hackage.haskell.org/package/base-4.12.0.0/docs/System-Info.html )
13:12:00 <matheus23> heptahedron: ah so only newtype MyPair = MyPair (Int, Int) works?
13:12:02 <gentauro> I wonder where I have seen this table before "This is the rule of functional architecture. You can also explain it with a table:" http://blog.ploeh.dk/2018/11/19/functional-architecture-a-definition/
13:12:14 <gentauro> maybe from here? http://uniprocess.org/effects.html :D
13:12:26 <gentauro> (remember to cite websites if you borrow stuff from them) ;)
13:12:32 <koz_> mniip: So will I have to hand-roll all the singleton-related stuff for K?
13:12:34 <heptahedron> matheus23: I am inclined to believe that is the case since we can't expect GHC to infer isomorphisms between arbitrary types, even though it may appear trivial to us
13:12:57 <matheus23> alright! Thanks!
13:13:14 <koz_> A case in point is the isomorphism between ((a,b), c), (a, (b, c)) and (a,b,c)
13:19:46 <geekosaur> Franciman, I thik the canonical stuff comes from aclocal.m4 in the ghc source
13:19:55 <Franciman> thanks geekosaur 
13:24:19 <mniip> koz_, maybe uhh
13:24:29 <mniip> data K a = K0 | K1 | K2 | Kn a
13:24:43 <mniip> and just stick to K Nat everywhere
13:24:48 <koz_> Works.
13:28:04 <Welkin> has anyone worked with field parsers in postgresql-simple?
13:28:15 <Welkin> normally the implementation for FromRow looks really stupid
13:28:38 <amx> I did a bit
13:28:40 <Welkin> `instance FromRow ChatMessage where fromRow = ChatMessage <$> field <*> field <*> field <*> field <*> field`
13:28:49 <Welkin> really, wtf
13:29:44 <Welkin> I'd like to be able to branch and inspect the values. I guess Alternative is what I'll use
13:29:58 <Welkin> but unlike my json example from earlier, there are no names that I can use to decode the data
13:30:01 <Welkin> it's only positional
13:30:41 <Welkin> so I can't do `parseJSON (Object o) = ctor <- o .: "ctor"; case ctor of ...""`
13:31:20 <Welkin> so I guess, use the `field` parser once, then use bind to pass it along?
13:32:01 <koz_> mniip: For the Ix n :~: Ix' (ToK n), I assume I have to 'spell out' that proof, rather than use unsafeCoerce as before?
13:32:15 <mniip> you still can't
13:32:51 <koz_> So still unsafeCoerce Refl?
13:33:03 <mniip> yes
13:33:06 <koz_> OK.
13:33:13 <koz_> Sorry I keep asking you these daft questions - I'm new to this.
13:33:23 <mniip> this isn't a particularly easy aera
13:33:25 <mniip> area
13:33:37 <koz_> mniip: Yeah, and massiv isn't making it easier.
13:33:43 --- mode: glguy set +v Budda
13:34:18 <Budda> By the way I'm new to irc.
13:34:28 <mniip> koz_, getting an intuition for GHC's constraint solver might give you an intuition for what's possible and what's not
13:35:19 <Budda> Quick question, so what are the practical uses of haskell?
13:35:34 <Welkin> programming
13:35:37 <mniip> koz_, the trickiness of closed type families in particular
13:35:57 <Budda> Fair, I did as a very broad question.
13:35:57 <Welkin> you could also read it for leisure I suppose
13:36:06 <koz_> Welkin: Writing for leisure is also cool.
13:36:13 <Budda> Interesting
13:36:21 <Welkin> I meant printing it out and binding it into a book
13:36:23 <Welkin> to read before bed
13:36:25 <Welkin> random source code
13:36:37 <mniip> @hackage random
13:36:37 <lambdabot> http://hackage.haskell.org/package/random
13:36:46 <Budda> I'm new to programming so all this seems quite intimidating.
13:36:46 <koz_> mniip: When you said that 'Ix'' can be an open type fam, would that mean I have to write instances for it for every Ix' I want separately?
13:36:59 <mniip> koz_, you need like 4 equations
13:37:04 <Welkin> Budda: it is, and that feeling won't go away for probably a few years
13:37:10 <koz_> mniip: For 0, 1, 2, and else?
13:37:14 <mniip> yes
13:37:19 <mniip> but the way they're spelled it doesn't actually matter if it's open or closed
13:37:20 <Welkin> no matter what language you use
13:37:31 <koz_> mniip: I'd rather spell it as closed.
13:37:32 <mniip> because all of the equations are compatible
13:37:35 <Budda> Thank you, Welkin. Any tips on where to start from the most basic fundamentals?
13:37:54 <mniip> koz_, well there's no harm in an open tyfam if you write instances for all constructors yourself
13:38:04 <Welkin> Budda: https://www.seas.upenn.edu/~cis194/spring13/
13:38:08 <mniip> I mean it isn't possible to write another instance
13:38:19 <Welkin> there are some books you can pick up too, llke Programming in Haskell 2nd Ed
13:38:28 <Budda> Thank very much! I check out this link. Farewell guys.
13:38:36 <koz_> mniip: Fair point.
13:40:07 <koz_> mniip: Mind checking if I've missed something of your description? https://gist.github.com/kozross/50996aff731be6b8f400a9a6a75d7d2b
13:40:37 <mniip> no that looks good
13:40:58 <koz_> mniip: OK, thanks. I'll try hammer this out more - will you be around for the next few hours in case I get stuck again?
13:41:10 <koz_> If you're busy or I'm overly annoying, that's OK, I'll chase jle` instead. :P
13:42:57 <mniip> I was thinking of going to sleep
13:43:40 <koz_> mniip: Ah, OK. I'll ask jle` if I have further issues then. Thank you for all your help - I appreciate it very much.
14:10:02 --- mode: glguy set +v fen
14:11:29 <fen> to what extent do associated types enable MultiParamTypeClasses to be avoided?
14:13:55 <Welkin> parsing this postgres row is a problem
14:14:10 <Welkin> I only have access to positional inputs
14:14:27 <Welkin> what's an easy way to ignore inputs in an applicative parsing interface?
14:14:46 <geekosaur> fen, they are one way to enable MultiParamTypeClasses to be useful, the other being fundeps
14:15:40 <Welkin> https://hastebin.com/ijilelufah.haskell
14:15:55 <Welkin> there is my FromRow parser
14:16:10 <Welkin> I put a comment next to the line where I want to ignore the field
14:16:26 <int-e> Welkin: <* and *>? (not looking at the paste)
14:16:48 <Welkin> ah, I totally forgot about that
14:17:22 <Welkin> thanks, I'll try it
14:18:06 <Solonarv> fen: they're completely equivalent in power if you allow equality constraints, IIRC
14:19:28 <fen> well thats confusing
14:19:42 <Solonarv> how so?
14:20:00 <fen> <geekosaur> fen, they are one way to enable MultiParamTypeClasses to be useful, the other being fundeps
14:20:06 <fen> <Solonarv> fen: they're completely equivalent in power if you allow equality constraints, IIRC
14:20:43 <Solonarv> you have two options which are equal in expressive power, but not equal in convenience of notation
14:20:59 <Solonarv> (sometimes one is more convenient, sometimes the other)
14:21:58 <Solonarv> which part of the equivalence confuses you:
14:21:58 <Solonarv>  - expressing fundeps using families?
14:21:58 <Solonarv>  - expressing families using fundeps?
14:21:58 <Solonarv>  - both?
14:22:06 <fen> (SomeConstraint i j) => ... i ... j ... compared too SomeConstraint i => ... i ... (J i) ...
14:22:12 <geekosaur> they compared tfs to mptcs
14:23:09 <fen> so, that is when | i -> j
14:23:36 <fen> ok
14:23:40 <Welkin> I get a type error using *>
14:24:09 <Welkin> No instance for (FromField (a0 -> ChatMessage)) arising from a use of ‘field’
14:24:39 <fen> Solonarv: why throw in equality constraints?
14:25:06 <Welkin> ah, I think I used the wrong one. It needs to be <*
14:26:01 <fen> guess, the question should have been. to what extent do associated types enable parameters fundeps to be avoided? 
14:26:06 <Solonarv> fen: because with those you can go 'class (j ~ J i j) => Foo i j where ...'
14:26:12 <Solonarv> that depends on the specific fundeps
14:26:38 <fen> no, it was J i to replace j
14:26:43 <fen> not J i j
14:26:55 <Solonarv> in general, every parameter that appears *only* on the RHS of a fundep can be replaced with an associated type
14:27:20 <fen> what, no
14:27:34 <fen> the associated type can be used on the LHS of the constraint too
14:27:35 <Solonarv> so if you have 'class Foo i j | i -> j, j -> i' you can't naively replace those fundeps with families
14:27:52 <Welkin> https://hastebin.com/obeberaduf.hs
14:27:53 <Solonarv> er, right; something along those lines, then
14:27:55 <fen> oh, right, the RHS of the ->
14:28:00 <Welkin> I'm getting an ambiguous type error
14:28:12 <Welkin> only where I am using <*
14:29:11 <Welkin> any have an idea why?
14:29:14 <Welkin> anyone*
14:29:57 <fen> so, associated types can replace all type class parameters that can be determined from the other parameters, but not those used to determine other parmeters using a fundep. 
14:30:11 <fen> thanks
14:30:36 <Welkin> here's a full paste https://hastebin.com/inacisayuk.hs
14:31:47 <Solonarv> with equality constraints I *think* you can replace all fundeps
14:31:59 <Solonarv> without them, only non-cyclic fundeps
14:32:21 <fen> % :t (<*)
14:32:21 <yahb> fen: Applicative f => f a -> f b -> f a
14:32:28 <fen> % :t (<*>)
14:32:28 <yahb> fen: Applicative f => f (a -> b) -> f a -> f b
14:33:43 <fen> so the (f (a -> b)) specifies both a and b
14:33:59 <fen> while b cant be determined from f a of <*
14:34:01 <fen> right?
14:34:30 <Solonarv> yup
14:34:56 <Welkin> I tried adding type annotations to no avail
14:36:19 <Welkin> I got it working
14:36:29 <Welkin> I think I had the types flipped around
14:36:30 <Welkin> thanks
14:39:23 <Welkin> damn, now I am running into issues with null fields
14:42:15 <Welkin> nulls need to be wrapped in Maybe, but my type does not use Maybe
14:42:32 <Welkin> I'd have to either unwrap them while parsing, or remove the nulls and use some value
14:46:32 <zachk> @type maybe
14:46:34 <lambdabot> b -> (a -> b) -> Maybe a -> b
14:46:49 <zachk> use that
14:48:40 <Welkin> I know about that
14:48:47 <Welkin> I can use it
14:48:59 <Welkin> but I don't know how to fail the parser in postgresql-simple
14:50:14 <Welkin> besides if it's not what I expect, it should fail with a message
14:50:20 <Welkin> pg-simple uses exceptions for this
14:51:17 <Welkin> I suppose `throw`
14:51:19 <Welkin> :t throw
14:51:20 <lambdabot> Exception e => e -> a
14:55:50 <zachk> fail?
14:55:58 <zachk> @type fail
14:55:59 <lambdabot> Monad m => String -> m a
14:58:15 <koz_> jle`: When you rematerialize, I need assistance making use of the suggestions I got above: https://gist.github.com/kozross/50996aff731be6b8f400a9a6a75d7d2b
14:58:26 <Welkin> yes! I finally got it to work
14:58:44 <Welkin> all the work I've done over the last 2.5 days is finally working
14:59:16 <Welkin> the amount of parsers and json encoders/decoders I had to write is crazy, but it's done
14:59:34 <Welkin> well over 1,000 lines of parsers/en/decoders
15:01:48 <__monty__> Sounds like a lot of parsers.
15:02:02 <koz_> Welkin: You have my sympathies.
15:04:27 <lockestep> Welkin what are you working on?
15:04:34 <lockestep> I'm working on a Markdown parser right now
15:05:20 <Solonarv> @tell fen sketch of fundep -> tyfam conversion: <https://gist.github.com/Solonarv/3cd90ca7897f2af189893be537d3ecd6>
15:05:20 <lambdabot> Consider it noted.
15:05:21 <Axman6> lockestep: that's a pretty big task, any reason to not just use pandoc? Markdown is incredibly complicated
15:05:43 <koz_> Or any of the various bindings to various existing parsers?
15:07:26 <Axman6> Complicated: https://spec.commonmark.org/0.28/
15:08:32 <lockestep> koz_ two reasons. 1) I don't want HTML output, I want a compact json representation of my document and 2) there are some additional features I want in my markdown that are not available elsewhere
15:11:37 <Solonarv> pandoc can do #1 no problem
15:15:00 <Welkin> lockestep: it's for a tabletop rpg web application I'm building. All of these parsers and en/decoders were for the chat/dice rolling system
15:15:48 <Welkin> it so also involved a lot of designing my own data types, and how they should be represented as json and in a relational database
15:15:51 <Welkin> it was fun though
15:26:46 <koz_> lockestep: Pandoc can also probably do 2 with reasonable ease.
15:28:23 --- mode: glguy set +v eric8
15:29:01 <eric8> Why does it recompile when an import changes a function that the importing module doesn't use?
15:29:31 <eric8> e.g. if A imports B but does not use B.foo, B changes foo, then why does A need to recompile upon running `stack build`?
15:29:47 <lockestep> koz_: I'm also having a lot of fun learning megaparsec
15:29:57 <Solonarv> complicated reasons which boil down to "the compiler doesn't know that A wasn't using foo"
15:30:36 <lockestep> so not much lost
15:30:37 <eric8> In theory couldn't the compiler know A doesn't use B.foo?
15:30:49 <geekosaur> because (a) files don't nicely allow for fractional recompilation, or fractional dependency checking (b) tings you "don't use" can be exposed for cross-module inlining, meaning that in some cases you might be using it via an inlined function
15:31:11 <eric8> i.e. is this just a feature that isn't there yet or is it architecturally bad?
15:31:27 <Solonarv> suppose there is B.bar, which uses B.foo
15:31:27 <Solonarv> and A uses B.bar but not (directly) B.foo
15:31:29 <eric8> geekosaur: recursing through inlines should handle (b)
15:31:45 <Solonarv> but B.foo might get inlined into B.bar!
15:31:46 <geekosaur> in theory you could slice ad dice and know exactly which bytes are in use. and your dependency information and chcking, and cached per-declaration information, will be slower and use more disk space than just compiling it
15:32:02 <eric8> geekosaur: that's the answer I want
15:32:03 <Solonarv> eric8: inlining happens late enough that you're basically doing a full compile anyway
15:32:13 <eric8> Ok thanks y'all :)
15:32:22 <geekosaur> rust is already running into this with incremental compiltion support
15:32:22 <eric8> Solonarv++ geekosaur++
15:32:59 <eric8> So ok... why not do this checking the other way? something like pullbacks
15:33:21 <eric8> i.e. B.foo knows who uses it and can follow those edges out?
15:34:18 <Solonarv> because then you run into a weird bit of circularity: B is compiler /before/ anything that uses it
15:34:28 <Solonarv> so users would have to go back and add themselves to the list
15:34:35 <Solonarv> that sounds very error-prone to me!
15:35:22 <eric8> well... so did implementing the Hidney/Milner type system :P
15:36:06 <eric8> recompilation triggered for only those modules who use those fractional dependencies
15:37:18 <spion> wow, validation is complex to model, even with typeclasses. Do you want all the errors or the first one? What if subsequent validation depends on previous validation succeeding (i.e. not "None", and then validate within Some), then you can't get multiple errors.
15:37:32 <spion> can anyone point me to material on this topic? :)
15:38:54 <eric8> spion: monad transformations might help
15:39:58 <eric8> spion: Real World Haskell's chapter 18 is very good
15:40:21 <spion> eric8, thanks I'll check it out! i thought monadic validation always stops at the first error?
15:40:46 <Solonarv> something like 'WriterT [NonFatalError] (ExceptT [FatalError] m) result', I'd guess
15:40:55 <spion> i'm hoping for some strange mix of applicative and monadic validation
15:40:59 <spion> ahhh
15:41:01 <eric8> spion: `MaybeThrowIO'` and `catch` exist... but there should be a better way
15:41:07 <Solonarv> er, FatalError isn't wrapped in []
15:41:15 <eric8> Solonarv++
15:41:38 <spion> that looks interesting
15:41:41 <Solonarv> the result type ends up as ([NonFatalError], Either FatalError result)
15:41:46 <spion> and I guess I could also "recover" from a fatal error
15:41:47 <Solonarv> which seems about right to me
15:42:15 <spion> then e.g. proceed with other fields
15:42:26 <lavalike> peculiar definition of fatal
15:44:10 <spion> thanks!
16:19:58 --- mode: glguy set +v Darwin226
16:20:41 <Darwin226> Here's something weird
16:20:43 <Darwin226> https://gist.github.com/LukaHorvat/b15463fcf5b86b1f8997d67b87b8637d 
16:20:46 <Darwin226> this compiles
16:20:56 <Darwin226> but you can't get the type of it in GHCi
16:23:14 <mniip> that's an unsatisfiable constraint...
16:23:40 <Darwin226> Indeed
16:23:44 <Darwin226> But it compiles
16:23:54 <Rembane> Do you get any warnings if you enable them?
16:24:11 <Solonarv> Constraints are checked at use sites, not at definition sites
16:24:43 <Darwin226> I'd expect that :t would only get the provided type, not try to do anything else with it
16:25:04 <mniip> nuh-uh
16:25:10 <mniip>  :t takes an expression and not an identifier
16:25:25 <Darwin226> Fair enough
16:25:52 <mniip> it wouldn't help you with an ambiguous type for example
16:25:55 <Solonarv> % let { fake :: (Int ~ Char) => String; fake = "uh oh" }
16:25:56 <yahb> Solonarv: 
16:26:02 <Solonarv> % :t fake
16:26:02 <yahb> Solonarv: ; <interactive>:1:1: error: Couldn't match type `Int' with `Char' arising from a use of `fake'
16:26:21 <mniip> % foo :: (Show a) => (); foo = ()
16:26:21 <yahb> mniip: ; <interactive>:6:8: error:; * Could not deduce (Show a0); from the context: Show a; bound by the type signature for:; foo :: forall a. Show a => (); at <interactive>:6:8-21; The type variable `a0' is ambiguous; * In the ambiguity check for `foo'; To defer the ambiguity check to use sites, enable AllowAmbiguousTypes; In the type signature: f
16:26:27 <mniip> % :set -XAllowAmbiguousTypes
16:26:27 <yahb> mniip: 
16:26:29 <mniip> % foo :: (Show a) => (); foo = ()
16:26:29 <yahb> mniip: 
16:26:31 <mniip> % :t foo
16:26:31 <yahb> mniip: ()
16:26:35 <mniip> wait uhh
16:26:38 <Solonarv> defaulting
16:26:44 <mniip> % foo :: (Monad m) => (); foo = ()
16:26:44 <yahb> mniip: 
16:26:46 <mniip> % :t foo
16:26:47 <yahb> mniip: ; <interactive>:1:1: error:; Ambiguous type variable `m0' arising from a use of `foo'; prevents the constraint `(Monad m0)' from being solved.; Probable fix: use a type annotation to specify what `m0' should be.; These potential instances exist:; instance Monad m => Monad (WrappedMonad m) -- Defined in `Control.Applicative'; instance ArrowApply a => Monad (ArrowMonad a) -- Def
16:28:08 <mniip> it is still weird indeed
16:28:12 <Darwin226> Ok, so now the _really_ weird part
16:28:44 <Darwin226> I have this library, simple-effects, it also has a State effect, and it also has a fundep, but  done in a slightly more convoluted way
16:28:50 <Darwin226> https://gist.github.com/LukaHorvat/6808513cec020fc02d781c4e9db8fb32
16:29:38 <Darwin226> wtf2 again has an unsatisfyable constraint, yet I can handle both of those constraints and get "aaaaa" as output
16:29:56 <Solonarv> so clearly it's not unsatisfiable, eh? ;)
16:30:16 <mniip> MonadEffect doesn't have a fundep
16:30:34 <Darwin226> No, but it has a superclass constraint that's a type family 
16:30:38 <Solonarv> you have two "layers" of StateT there, so you can have two states
16:30:52 <Darwin226> and that constraint for the State effect is defined as a class that does have a fundep
16:32:44 <Darwin226> for example, this compiles https://gist.github.com/LukaHorvat/f09f34d00f1c50e2e38c0b39ac3b8b70
16:33:01 <Darwin226> even though I don't specify the type of "int"
16:33:06 <Darwin226> it wouldn't work without a fundep
16:34:36 <Solonarv> please explain what you think a fundep is, because I don't think you're using the same definition as the compiler.
16:35:33 <mniip> that looks inconsistent to me
16:36:12 <Darwin226> Ok, so in the above case the type of "int" isn't ambiguous because the compiler knows that m determines the type of state, and the constraint claims that the type of state is Int, so (int :: Int)
16:39:51 <Darwin226> The errors seem to have changed a bit from 8.2 to 8.6, but in 8.2 if you omit the signature of wtf you get an error about a fundep (can't match Char and Int), and you get the same error if you omit the signature of wtf2
16:40:13 <Darwin226> It explicitly states that it's because of the fundep, so it's there
16:40:45 <Darwin226> In 8.6 for some reason it complains about missing instances for the inferred type m...
16:42:49 <Darwin226> In other words, the type of the function can't be inferred because the constraint would be unsolvable, but I can provide a signature to delay the check. This should still mean things break when I try to use wtf2
16:43:08 <Darwin226> but they don't, in fact I can run both states and discard both of those constraints
16:46:17 <lockestep_> does anyone know some common pitfalls when parsing markdown? I tried google but didn't get anything usefu 
16:46:18 <lockestep_> l
16:46:34 <lockestep_> I keep hearing about how it's gruesome to parse and it hasn't been *that* hard so far
16:48:20 <Rembane> I think the edge cases are especially interesting.
16:50:05 <lockestep_> such as?
16:50:52 <lockestep_> "__ ** __ test __ ** __" has an interesting result in pandoc
16:51:21 <lockestep_> whoops
16:51:45 <lockestep_> "__t **t __t t__ t** t__"
17:04:48 <Darwin226> Ok, I have a minimal example that compiles and works but I don't think it should
17:04:50 <Darwin226> https://gist.github.com/LukaHorvat/57362314482f4f0434a170ffaab03bc4
17:05:04 <Darwin226> "minimal"
17:05:40 <Darwin226> It seems like I'm getting all the benefits of having a fundep but without the drawback of being fixed to a single state per computation
17:07:27 <Darwin226> Ok, now it's even more minimal
17:09:42 <Darwin226> What I think is happening is that even though the compiler is searching for "State Int (StateT Char m)" and it is finding the "MyState s (StateT s m)" instance, it's deciding not to complain that Int doesn't match Char, but instead pick the other overlappable instance
17:10:56 <Darwin226> If this is intended behavior that it's a great trick. Fundeps kick in only in case of ambiguity and get out of the way otherwise
17:11:33 <hpc> it's great until it picks the wrong instance and then you need to become a ghc wizard to fix it
17:12:27 <Darwin226> it's not obvious that that can happen
17:17:43 <dmwit> Darwin226: That... seems like a bug.
17:18:32 <Darwin226> Yeah... But maybe no? I mean, the fact that overlappable instances even work with fundeps is pretty weird
17:18:58 <Darwin226> and the behavior is the same in both 8.2 and 8.6
17:20:35 <Darwin226> I'll make a ticket about it tomorrow
17:30:20 <Arahael> If I'm using Stack on a linux distro, what's the easiest way for me to compile it so that it will run on another linux system (including the one C library it uses)
17:33:11 <koz_> Arahael: I think Stack has a way of compiling with static linking so everything gets bundled in.
17:34:57 <Solonarv> and if you need any .so/.dll's that *aren't* system libraries, I'd recommend just bundling them alongside your binary
17:35:23 <Arahael> koz_: I thought glibc was incompatible with static linking?
17:35:44 <Solonarv> e.g. don't bundle libc, do bundle libsdl2
17:36:10 <Arahael> Gotcha - I'll bundle libzip, I think that's the lib I need.
17:36:19 <Arahael> Looks like there is indeed a --static argument for stack.
17:36:26 <Arahael> (No, it's still open)
17:36:28 <koz_> Arahael: There's a pure Haskell version of zip.
17:36:45 <Arahael> koz_: It's gzip I need, I forget the name of the actua lib.
17:36:58 <Arahael> It's a dependency of http-client.
17:39:31 <Arahael> Looks like that even if stack doesn't directly deal with this, cabal does, sounds like I may have a bit of research to do if I want to persevere with this.
18:22:58 <dmj`> jle`: ping
18:58:47 --- mode: glguy set +v nickoralias
20:38:11 <Welkin> what is with POSIX time in the tie library?
20:38:31 <Welkin> when I convert UTCTime to POSIX I get a really messed up result
20:38:36 <Welkin> like 1.542755080974998e9
20:39:32 <Welkin> well, also after applying utcTimeToPOSIXSeconds
20:40:11 <Welkin> I thought it was supposed to be an Int
20:40:16 <Welkin> but it's a floating point value
20:48:39 <ragusa> Welkin: It's a NominalDiffTime "Conversion functions will treat it as seconds. It has a precision of 10^-12 s."
20:50:07 <Welkin> I converted it to milliseconds afterward and it's all good now
20:50:23 <Welkin> so it has microsecond precision, but other implementations of POSIX time use milliseconds
20:50:34 <Welkin> and why utcTimeToPOSIXSeconds? why not milliseconds?
20:50:46 <Welkin> it's just a pain to work with so many different interpretations
20:51:17 <lmy9900> The following package identifiers were not found in your indices: ghc-boot-8.4.4 |||| Possible candidates: ghc-boot-8.4.3, ghc-boot-8.4.1, ghc-boot-8.4.2.    who can help me?
20:51:18 <Welkin> threadDelay uses microseconds too (that one got me for a while)
20:52:17 <ragusa> If you use fractional numbers it makes sense to use seconds as the base unit
21:31:59 <Arahael> Welkin: Probably because it's using milliseconds since the POSIX epoch.
21:33:36 <Welkin> POSIX is defined as *seconds* since the epoch though
21:33:49 <Welkin> I suppose you could have more precision if you wanted
21:34:10 <Welkin> so the haskell time library's implementation is correct
21:34:23 <Welkin> but in elm they use milliseconds
21:34:38 <Welkin> and it converts from an Int -> Posix
21:36:21 <Arahael> I just assume that if anything touches time, it's going to be confusing. :(
22:26:28 <ab9rf> Arahael: a safe bet
22:47:58 <BaneAliens> is writing a function using case expression the same as writing a function using pattern matching? Are they synonmous?
22:53:34 <BaneAliens> nevermind looks like they are entirely different
22:57:05 <opqdonut> BaneAliens: they are the same. se section 4.4.3.1 of the Haskell2010 standard
22:58:24 <opqdonut> BaneAliens: ... which defines `f pat1 pat2 = e1; f pat3 pat4 = e2` to be the same as `f = \x1 x2 -> case (x1,x2) of (pat1,pat2) -> e1; (pat3,pat4) -> e2`
23:32:09 <dminuoso> How do you folks generally order your function arguments? I myself try to position them in such a way that I can use them curried in most usecases. Are there other considerations?
23:32:26 <opqdonut> that's my number one criterion too
23:32:46 <opqdonut> other considerations: consistency within the lib and with the standard library
23:33:01 <opqdonut> infixability
23:33:18 <opqdonut> so something like withAuthentication :: Handler -> Authentication -> Handler
23:33:41 <opqdonut> even though Authentication -> Handler -> Handler might be otherwise nicer
