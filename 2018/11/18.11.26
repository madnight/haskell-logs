00:22:57 <MarcelineVQ> can you use traverse to say  sequence $ liftA2 f x y ?
00:23:39 <dminuoso> :t \f x y -> sequence $ liftA2 f x y
00:23:40 <lambdabot> (Applicative t, Monad m, Traversable t) => (a1 -> b -> m a2) -> t a1 -> t b -> m (t a2)
00:47:51 <ski> @type \f x y -> traverse (uncurry f) (liftA2 (,) x y)  -- MarcelineVQ ?
00:47:53 <lambdabot> (Applicative t, Applicative f, Traversable t) => (a -> b1 -> f b2) -> t a -> t b1 -> f (t b2)
00:51:18 <Solonarv> @type \f x y = sequenceA (f <$> x <*> y)
00:51:20 <lambdabot> error:
00:51:20 <lambdabot>     parse error on input ‘=’
00:51:20 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
00:51:36 <Solonarv> @type \f x y -> sequenceA (f <$> x <*> y)
00:51:37 <lambdabot> (Applicative t, Applicative f, Traversable t) => (a1 -> a2 -> f a3) -> t a1 -> t a2 -> f (t a3)
00:52:16 <ski> (aye, but they said `sequence')
00:52:36 <Solonarv> I didn't catch what you were responding to, I only just logged on :P
00:52:44 <ski> ah
00:52:51 <MarcelineVQ> ski: neato
00:53:04 <ski> well, i dunno whether it's neat
00:53:22 <ski> the version with `sequence'/`sequenceA' seems simpler, to me
00:53:51 <Solonarv> yeah, I don't like the uncurry/(,) noise
00:54:41 <Solonarv> @pl \f x y -> sequenceA (liftA2 f x y)
00:54:41 <lambdabot> ((sequenceA .) .) . liftA2
00:54:46 <MarcelineVQ> this is just curiosity.  traverse f being sequenceA . fmap f  made me wonder how it could be made to interact with liftA2 since it's also fmapping
00:54:56 <mniip> ski, so uh
00:55:01 <mniip> there's an interesting problem
00:55:14 <ski> MarcelineVQ, *nod*
00:55:15 <dminuoso> So Im wondering - is there some kind of ring structure buried in Monad when you consider the alternative definition of Applicative using `class Functor f => Monoidal f where unit :: f (); (<+>) :: f a -> f b -> f (a, b)`?
00:55:17 <mniip> (->) is functorial in the subcategory of left- and right-total relations
00:55:43 <ski> total surjective relations
00:55:43 <mniip> and that subcategory is also closed under product, coproduct, and exponential
00:56:00 <ski> (i've seen the term "entire" instead of "surjective", for relations)
00:56:20 <mniip> now the problem is
00:56:39 <mniip> the forall-functor talks about "for any relation"
00:56:53 <mniip> but I have a feeling that's exactly as strong a statement as "for any left- and right-total relation"
00:57:22 <ski> remind me of what the `forall'-functor was, again ?
00:58:58 <mniip> ski, consider a functor F : Rel -> Rel
00:59:28 <mniip> we map that functor to the object 'forall x. F x'
00:59:50 <ski> which is an end, maybe ?
00:59:58 <mniip> but also, given a natural transformation alpha : F --> F', we have a relation  forall R. alpha R
01:00:43 <mniip> ski, the definition is a bit recursive:
01:00:53 <mniip> we can consider a subset of 'pi x. F x'
01:01:02 <mniip> and define 'pi R. alpha R'
01:01:24 <mniip> and then the identity natural transformation maps to a relation on  'pi x. F x'
01:01:33 <mniip> there are no elements outside the diagonal
01:01:53 <mniip> and on the diagonal, the relateds are exactly the parametric terms
01:02:05 <mniip> as per wadler's/reynold's theorem
01:02:17 <mniip> and so we shrink our "set of interest" to that set
01:03:14 <ski> which set ?
01:03:24 <ski> `pi R. alpha R' ?
01:03:44 <mniip> no, that's a relation
01:03:50 <mniip> hm
01:04:14 <ski> hrm, sorry. i meant `pi x. F x'
01:04:20 <mniip> okay, consider F, F' : Rel -> Rel,  alpha : F --> F'
01:04:32 <mniip> pi x. F x   and pi x. F' x  are sets
01:04:55 <mniip> and thus objects in Rel
01:05:09 <mniip> we now define the meaning of the symbol 'pi R. alpha R'
01:05:31 <mniip> which is like a functor acting on morphisms
01:05:35 <mniip> except it's not actually a functor
01:05:38 <ski> some subsets of `forall x. F x' and `forall x. F′ x' ?
01:05:50 <mniip> the opposite actually
01:05:57 <mniip> it's just the usual product of family of sets
01:06:20 <mniip> where x ranges over the entire category of sets
01:06:24 <mniip> ...that's not a set
01:06:29 <mniip> doesn't matter!
01:07:24 <mniip> anyway, pi R. alpha R  is a relation from  pi x. F x  to  pi x. F' x
01:08:07 <mniip> namely, {(f, f') | forall A, A', forall R : Rel(A, A'), (pi_A f, pi_A' f') in alpha R}
01:09:00 <mniip> if it's not clear, alpha R is the diagonal composite F'R . alpha_A = alpha_A' . FR
01:09:41 <mniip> anyway, it can be shown that if  (x, y) in (pi R. alpha R)  then x=y
01:10:23 <mniip> errrrrrrrrr
01:10:29 <mniip> anyway, it can be shown that if  (x, y) in (pi R. id_F R)  then x=y
01:10:45 <mniip> but that doesn't yield   id_(pi x. F x)
01:10:52 <mniip> because there are some (x, x) that aren't in the relation
01:10:55 <mniip> the nonparametric terms
01:11:13 <mniip> now consider the set of all x such that (x, x) in (pi R. id_F R)
01:11:34 <mniip> define   forall x. F x  to be that set
01:11:44 <mniip> now "forall" is a functor (Rel -> Rel) -> Rel
01:14:00 <ski> (hm, i think i'd write `alpha_R', or something)
01:14:15 <mniip> the only problem right now is that (->) is not a functor in its left argument
01:14:22 <mniip> not over the entirety of Rel
01:17:31 --- mode: glguy set +v koankeeper_
01:17:32 --- mode: glguy set +v jdhorwitz_
01:17:37 <mniip> (I came up with some neat machinery for computing a counterexample)
01:17:43 --- mode: glguy set +v simony__
01:17:44 --- mode: glguy set +v thi__
01:18:01 --- mode: glguy set +v Peter_Storm__
01:18:17 --- mode: glguy set +v higherorder_
01:18:18 --- mode: glguy set +v kristjansson_
01:18:22 --- mode: glguy set +v coot__
01:18:32 --- mode: glguy set +v rizary__
01:18:40 --- mode: glguy set +v rann_
01:35:15 --- mode: glguy set +v govno
02:13:41 --- mode: glguy set +v mreh
02:17:29 <Unhammer> I compile with `stack build --executable-profiling --library-profiling --ghc-options="-fprof-auto -rtsopts"`  and run with `+RTS -p` but getCallStack only shows the actual function where I put (?loc :: CallStack) – how do I see which function called that one?
02:22:14 <merijn> Unhammer: Where did you get the "-p" RTS flag from?
02:22:22 <Unhammer> oh, I need to add HasCallStack to every single function of the program to find out which one calls show, fun
02:22:38 <merijn> Unhammer: "It Depends"
02:22:42 <Unhammer> why copy-pasting from stackoverflow of course
02:22:58 <merijn> Unhammer: The profiling callstack and HasCallStack mechanisms are completely unrelated, afaik?
02:23:05 <Unhammer> ooh
02:23:15 <merijn> Unhammer: To the best of my knowledge there's no such thing as a "-p" RTS flag
02:23:46 <merijn> (Mind you, I'm at best about 70% confident it doesn't exist)
02:23:54 <Unhammer> heh
02:27:08 <Unhammer> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#time-and-allocation-profiling does say -p is an rtsopt
02:29:09 <merijn> ah, hmm, maybe the problem is checking on a non-profiling exe :)
02:29:49 <merijn> I end up just using -sstderr 90% of the time
02:32:03 <Unhammer> what's -s?
02:32:16 <Unhammer> really hard to search for single-char options in docs …
02:34:05 <Unhammer> oh, I think I've actually used that and then forgotten about it again
02:34:29 <Unhammer> I really like https://github.com/jaspervdj/profiteur/ 
02:34:49 <merijn> Unhammer: Just dumps cost centers/profiling to a specfic stream (in this case stderr)
02:35:51 <merijn> Confusingly some of these flags are under RTS flags and others under profiling...
02:35:54 <Unhammer> profile while looking at a 30's modernist painting
02:37:37 <merijn> I just wish GHC had a variant of -xc that ignored *caught* exceptions
02:54:33 * hackage pairing 0.1.0 - Optimal ate pairing over Barreto-Naehrig curves  http://hackage.haskell.org/package/pairing-0.1.0 (sdiehl)
03:00:49 * hackage ngx-export 1.6.1 - Helper module for Nginx haskell module  http://hackage.haskell.org/package/ngx-export-1.6.1 (lyokha)
03:00:50 --- mode: glguy set +v isamert
03:08:00 <isamert> Hi! I'm using uniplate to do some simple transformations on an AST. The problem is `descend f ast` starts applying `f` to immediate children but not to `ast` itself. Using `transform f ast` applies `f` to `ast` eventually but I need to apply `f` in top to bottom manner. Is there a function that does what I want?
03:09:39 <Taneb> isamert: why not `descend f (f ast)`?
03:11:11 <Taneb> I don't think there's a single function to do this but it isn't too hard to write
03:13:37 <Taneb> Oh, nevermind, I misunderstood the docs. My suggestion will not touch the grandchildren
03:14:34 <Taneb> You can do something like "let f' = descend f' . f in f ast" but I've got no idea whether that would be able to terminate
03:40:57 <isamert> Taneb: I believe you meant "... in f' ast" (asterisk in f' is missing in your example) but yeah, it does not terminate. I actually want `f` to do not touch grandchildren when it's applied to a parent (which I believe is the behavior of `descend`) but the problem of the first solution is that when I do `f ast` before passing it the to `descend`, `ast` becomes the first child. (let's say f function wraps ast into another ast) So call
03:42:31 <isamert> ... the first child and applies f again which is something that I don't want. The problem appears so simple but I just can't wrap my head around it, maybe it has something to do with my design.
03:48:03 * hackage ngx-export-tools 0.3.1.0 - Extra tools for Nginx haskell module  http://hackage.haskell.org/package/ngx-export-tools-0.3.1.0 (lyokha)
04:16:37 * hackage JuicyPixels-blp 0.1.1.0 - BLP format decoder/encoder over JuicyPixels library  http://hackage.haskell.org/package/JuicyPixels-blp-0.1.1.0 (NCrashed)
04:53:26 --- mode: glguy set +v TaufRaz
05:04:49 <maerwald> is there a design pattern where you add a "label" to a data structure, but still be polymorphic over all functions that don't care about the label? Adding a newtype means you unwrap all the time and need functions for both types. A class seems overkill too
05:06:14 <mreh> maerwald, you can derive typeclasses using the GeneralizedNewtypeDeriving extension
05:06:47 <__monty__> maerwald: Sounds like you want extensible records.
05:07:53 <ski> @where DecoratingStructures
05:07:53 <lambdabot> <http://web.archive.org/web/20051126143527/http://haskell.org/hawiki/DecoratingStructures>
05:08:38 <ski> @where PLFA
05:08:38 <lambdabot> I know nothing about plfa.
05:08:56 <ski> @where+ PLFA "Programming Language Foundations in Agda" (formal methods book) by Wen Kokke,Philip Wadler in 2018-(01-06) at <https://homepages.inf.ed.ac.uk/wadler/topics/agda.html>
05:08:56 <lambdabot> I will never forget.
05:17:21 <maerwald> ski: so basically just a type parameter?
05:21:32 <ski> maerwald : interspersing each level by scaling with the label
05:21:45 <ski> (also see `IndirectComposite')
05:22:10 <maerwald> I am referring to IndirectComposite, which is basically just a type parameter
05:22:58 <ski> well, it's also detaching your fixpoint
05:26:08 <maerwald> extensible records libraries all look awful
05:32:17 <cemerick> it looks like code/definitions made in .ghci are ignored; is this correct?
05:35:17 --- mode: glguy set +v Levy[m]
05:36:32 <Unhammer> I don't suppose there's a trick to make ghci always run something after :l ?
05:36:42 <Unhammer> like a main_ghci  =P
05:43:24 <confusedwanderer> Unhammer: you could try ghcid: https://github.com/ndmitchell/ghcid
05:45:19 <confusedwanderer> it has a "--run" option to specify what to run after successful loading and it also reloads automatically when the sources change
05:46:00 <Unhammer> oh, nice
05:46:17 <Unhammer> it's noninteractive though, right?
05:46:23 <Unhammer> maybe just as well
05:46:46 <confusedwanderer> yeah, noninteractive
05:47:26 <confusedwanderer> some people use ghci + ghcid + editor, each in a separate window
05:50:44 <henrylaxen> I just watched https://www.reddit.com/r/haskell/comments/9zmi63/type_driven_program_synthesis_with_haskell/ where Prof. Nadia defined a data type for sorted lists in her synquid language.  Does anyone know how to define such a beast in Haskell?  In other words, how do I define a data type that statically enforces that a list is sorted?  Thanks for any pointers.
05:53:48 <merijn> henrylaxen: It's hard (if not impossible) to guarantee such properties in types directly
05:54:04 <merijn> henrylaxen: However, you could define a (new)type and only export functions that preserve order
05:55:06 <henrylaxen> Thanks merijn, I was hoping for a different answer.
05:55:28 <confusedwanderer> henrylaxen: you could look for dependent types aproximations in haskell
05:55:40 <merijn> henrylaxen: I mean, you can probably get quite close, but it'll be insanely painful
05:56:01 <merijn> henrylaxen: faking dependent types in haskell makes your life very complicated and painful, generally
05:56:40 <henrylaxen> I guess that explains why google couldn't find any examples for me.
05:58:30 <merijn> henrylaxen: There's several papers about this sorta thing by (amongst others) Stephanie Weirich and Richard Eisenberg
05:58:44 <merijn> henrylaxen: See also the singletons library and the papers it mentions
05:59:05 <merijn> henrylaxen: But we warned that there's a reason the first paper on "faking dependent types in Haskell" was called "Hasochism" :)
05:59:59 <cemerick> can someone tell me why, when this is installed as .ghci, pretty-printing isn't configured? i.e. I need to invoke `:pp` manually once the ghci prompt is ready: https://gist.github.com/cemerick/e2a1edfde67280d16a19755f89db7ff7
06:00:05 <henrylaxen> Thanks, I've read the one by Stephanie about red-black trees, but couldn't figure out how to extend that to sorted lists.
06:08:33 * hackage fgl 5.7.0.0 - Martin Erwig's Functional Graph Library  http://hackage.haskell.org/package/fgl-5.7.0.0 (IvanMiljenovic)
06:09:16 <geekosaur> cemerick, that may be a (undocumented, grumble) security "feature", iirc you can define things but not run/evaluate them in .ghci files
06:12:33 * hackage fgl 5.7.0.1 - Martin Erwig's Functional Graph Library  http://hackage.haskell.org/package/fgl-5.7.0.1 (IvanMiljenovic)
06:13:26 <cemerick> geekosaur: well that's pretty unfortunate; any suggestions then for getting pretty-printing on by default when you're cobbling together the printing fn?
06:14:11 <geekosaur> no idea, sorry
06:18:03 * hackage funcons-intgen 0.2.0.1 - Generate Funcons interpreters from CBS description files  http://hackage.haskell.org/package/funcons-intgen-0.2.0.1 (ltvanbinsbergen)
06:24:29 <maerwald> I think a LabelledData with a functor instance is simpler than extensible records
06:24:48 <maerwald> then all functions would only be defined for the inner type
06:25:05 <maerwald> and then fmap/monad all of it, easy
06:32:03 --- mode: glguy set -v mreh
06:32:14 <mreh> not my voice
06:51:33 <c_wraith> is there any guidance from above re: mdo vs do rec? I know how they behave differently - but why do both exist? is one deprecated? do we just have both forever for the sake of backwards compatibility?
06:55:02 <c_wraith> (my position is that we should prefer do rec for the fact that it gives more precise scoping over mutually recursive bindings.) 
07:05:31 --- mode: glguy set +v mreh
07:05:42 --- mode: glguy set -v mreh
07:09:04 --- mode: glguy set +v Anti-Antidote
07:09:50 <Anti-Antidote> I've been looking for some decent tutorials on getting started, does anyone have a good one?
07:12:29 --- mode: glguy set +v NelsonHB
07:13:55 <NelsonHB> Hiranyagarbha (the cosmic egg).He is more prominently mentioned in the post-Vedic Hindu epics and the mythologies in the Puranas. In the epics, he is conflated with Purusha.
07:15:57 <Mrbuck> NelsonHB:  what is your last message topic i missed the logs
07:16:03 <delYsid> I'd like to write a webaudio game with a functional language like Haskell or PureScript.  Anyone with experience on how to get rolling with Webaudio in a functional setting?
07:17:05 <NelsonHB> Hiranyagarbha (the cosmic egg).He is more prominently mentioned in the post-Vedic Hindu epics and the mythologies in the Puranas. In the epics, he is conflated with Purusha.
07:17:18 <NelsonHB> malaysia
07:17:27 <Mrbuck> NelsonHB:  what the fuck we have to do with Haskell ?
07:19:12 <NelsonHB> where are you from?
07:19:38 <Mrbuck> NelsonHB:  why ?
07:19:47 --- mode: ChanServ set -v+q NelsonHB *!*@49.125.12.2
07:25:51 --- mode: glguy set +v NelsonHB
07:26:33 --- mode: glguy set +v Anti-Antidote
07:26:33 --- mode: glguy set -v Anti-Antidote
07:31:29 <pjrt> Is that a new copy-pasta? lol
07:32:36 <ski> c_wraith : i think `mdo' was earlier
07:32:44 <ski> pjrt ?
07:33:14 <pjrt> the random hindu thing above
07:34:00 <ski> oh, that's some kind of spam, i think
07:34:08 <ski> (i've seen it before)
07:34:56 <NelsonHB> we should login to our country channel
07:35:17 <pjrt> Unn, I wonder what the difference between spam and copy-pasta is. 
07:35:24 <Clint> stop making me hungry
07:35:30 <pjrt> NelsonHB: huh? why?
07:35:34 --- mode: ChanServ set -v NelsonHB
07:35:52 --- mode: glguy set +v NelsonHB
07:36:32 --- mode: ChanServ set -v NelsonHB
07:39:22 --- mode: glguy set +v NelsonHB
07:39:36 --- mode: ChanServ set -v NelsonHB
07:40:06 <pjrt> what is going on? ChanServ and glguy seem to be fighting each other over that Nelson guy
07:40:26 <Ariakenom> war of the bots
07:41:04 <ski> i think glguy has a script which auto-voices (unidentified ?) people, when they try to speak (and it doesn't get caught in some spam check ?)
07:41:26 <Ariakenom> ya something like that
07:52:11 <kadoban> Seems like it should be rate limited, heh.
08:01:08 --- mode: glguy set +v NelsonHB
08:06:58 <NelsonHB> #sabah
08:08:38 <__monty__> I'm trying my hand at a ReadP parser. I'd like to parse a #-style comment. I came up with `char '#' <*> endBy (satisfy (/= '\n')) (char '\n')`, do I need to handle \r and \r\n or are those handled by readFile?
08:09:44 <lyxia> that's right, readFile handles \r
08:10:08 <NelsonHB> #asean
08:10:56 <__monty__> lyxia: ty
08:12:42 --- mode: ChanServ set -v NelsonHB
08:47:11 * hackage patience 0.2.0.0 - Patience diff and longest increasing subsequence  http://hackage.haskell.org/package/patience-0.2.0.0 (chessai)
08:53:46 --- mode: ChanServ set -q *!*@49.125.12.2
09:00:32 <jollygood2> hi
09:00:40 <jollygood2> how would you call a function that takes a list of Show instances, say, [1,2,3], and procues "1, 2 and 3" string?  showList is already taken
09:00:46 <jollygood2> produces*
09:04:17 <ski> nitpick, that's not a "list of Show instances". that's a list of values, whose (common) type is an instance of `Show'
09:04:31 <geekosaur> isn't naming one of the hardest problems in CS? :p
09:04:54 <geekosaur> (fwiw, I'd probably use  presentList — but it would depend on context)
09:04:58 <ski> perhaps you could call it `describeElements' ?
09:06:42 <jollygood2> good suggestions
09:07:55 <pjrt> That's oddly specific, I would use whatever the business calls it :\
09:08:15 <__monty__> Another ReadP question, the documentation mentions that `munch 
09:08:43 <__monty__> p /= many (satisfy p)` but I don't understand why?
09:09:05 <jollygood2> is there a show equivalent that works exactly like show, but returns id for string? to avoid quotes
09:11:13 <jollygood2> if I call show in a function described above, and pass ["one","two","three"] to it, I get "\"one\", \"two\" and \"three\"" instead of "one, two and three"
09:12:05 <__monty__> jollygood2: Append before showing?
09:13:06 <jollygood2> __monty__ I can't, function accepts a list of Show things
09:14:24 <__monty__> jollygood2: You probably don't want to use show if you don't actually want a valid haskell representation.
09:17:43 <jollygood2> __mony__ what should I use instead?
09:18:36 <geekosaur> there's severa pretyprinting libraries on hackage. btu often, what yiou actually want will ahve application-specific elements, and you're better off providing youir own typeclass and when appropriate delegating to a Show instance in typeclass instances
09:20:19 <geekosaur> (also see the DefaultSignatures extension, which lets you automate this to some extent: you still ahve to make instances manually, but the default implementation of the method can require a Show instance without forcing it on all instances)
09:26:39 <ryantrinkle> is there a better way to get the size of Int than with WORD_SIZE_IN_BITS? i'm running into that being set to zero for some reason
09:35:09 --- mode: glguy set +v verement_
09:35:22 <verement_> ryantrinkle: Data.Bits.finiteBitSize?
09:37:05 <ryantrinkle> verement_: i'm hoping to make the decision at compile time (and, specifically, to fail to compile if the size isn't exactly 32 or 64 bits)
09:45:05 <jollygood2> re my earlier question, what do you think that instead of creating my own Present class or whatever, I just have presentList accept a (a -> String) function?
09:46:01 <ski> could work
09:46:06 <jollygood2> presentList :: (a -> String) -> [a] -> String    . presentList id ["one","two","three"] => "one, two and three".   presentList show [1,2,3] => "1, 2 and 3"
09:47:04 <ski> if you wanted to, you could factor out the `"and"' part
09:47:07 <geekosaur> sure, the typeclass is more or less that done implicitly
09:47:26 <ski> (so that one could use `"or"' instead, when appropriate. perhaps that's not something you'd have need of, though)
09:47:27 <jollygood2> also gives me additional flexibility, for exmaple I may want to show Double in different ways.
09:47:29 <geekosaur> at least if it only has one method in it
09:48:06 <jollygood2> ski yeah I did that already, mostly to support non-english languages. but "or" is another good use
09:52:05 <python476> hi
09:52:25 <python476> is it that wrong to thing of Functor / fmap as a Visitor (*coughs blood*)
09:55:10 <Ariakenom> Visitor doesn't really have any laws/guarantees/promises.
09:55:57 <python476> fair point
09:56:22 <Ariakenom> > traverse print [1,2,3]
09:56:24 <lambdabot>  <IO [()]>
09:56:29 <Ariakenom> % traverse print [1,2,3]
09:56:30 <yahb> Ariakenom: 1; 2; 3; [(),(),()]
09:56:44 <Ariakenom> well that output isn't intuitive
09:56:48 <Ariakenom> % traverse_ print [1,2,3]
09:56:48 <yahb> Ariakenom: 1; 2; 3
09:57:16 <Ariakenom> traverse is closer. even has the same naming theme
09:58:05 <marvin2> :t traverse
09:58:07 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
09:58:08 <marvin2> :t mapM
09:58:09 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
09:58:23 <marvin2> same situation as liftA2 vs liftM²?
09:58:59 <Ariakenom> probably
09:59:14 <ski> yes
10:00:11 <ski> @type for
10:00:12 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
10:00:13 <ski> @type forM
10:00:15 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
10:00:54 <ski> (there's also `mapM_',`for_',`forM_')
10:04:32 <marble_visions> :t [1,2,3]
10:04:34 <lambdabot> Num a => [a]
10:04:37 <marble_visions> nice.
10:06:10 <ski> overloaded numeric literals
10:09:12 <Ariakenom> list literals
10:10:33 * hackage cachix 0.1.3 - Command line client for Nix binary cache hosting https://cachix.org  http://hackage.haskell.org/package/cachix-0.1.3 (domenkozar)
10:11:10 <geekosaur> list literals would have an IsList instance in there too
10:12:10 <Ariakenom> overloaded list literals would
10:13:39 <c_wraith> I still think that extension should have gone in terms of overloading the implicit (:) constructor, rather than using fromList
10:14:17 <Ariakenom> c_wraith: oh why?
10:15:17 <c_wraith> Ariakenom, to allow mixing types in literals if the constructed type supports it.
10:16:33 <Ariakenom> ah interesting. do you have a ncie example?
10:18:02 <Ariakenom> I'm collecting short cool haskell things for a 5 min talk. just added ":t [1]" it was a nice addition to a slide I had
10:18:52 <Ariakenom> Anyone has something else?
10:20:46 <Levy[m]> What about `sequenceA`?
10:21:55 <Levy[m]> Ability to declare and enforce transitions via the type system?
10:22:36 <Ariakenom> hm, what do you mean?
10:22:46 <Levy[m]> Things which are rather easy to understand the surface of would be good.
10:23:03 <Ariakenom> indeed
10:24:08 <ski> > sequence ["01","abc","?."]
10:24:11 <lambdabot>  ["0a?","0a.","0b?","0b.","0c?","0c.","1a?","1a.","1b?","1b.","1c?","1c."]
10:25:02 <Levy[m]> Phantom types would be one interesting thing to bring up
10:25:24 <ski> > replicateM 3 "ab"
10:25:26 <lambdabot>  ["aaa","aab","aba","abb","baa","bab","bba","bbb"]
10:25:28 <ski> > filterM (const [True,False]) "abc"
10:25:31 <lambdabot>  ["abc","ab","ac","a","bc","b","c",""]
10:25:46 <Ariakenom> nice ski 
10:26:06 <ski> not sure if that's included in the kind of things that may be interesting
10:26:54 <Ariakenom> without showing other instances it's just weird names I guess
10:27:11 <ski> perhaps some simple example of using parsing combinators to parse something
10:27:45 <Levy[m]> Or arrows to build reactive animations
10:28:07 <ski> > sortBy (comparing length <> compare) (words "The quick brown fox jumps over the lazy dog")
10:28:09 <lambdabot>  ["The","dog","fox","the","lazy","over","brown","jumps","quick"]
10:28:22 <Ariakenom> my current finish is :t id and that it can only do one thing. purity ad
10:28:42 <ski> is perhaps a nice example of sorting (or more generally comparing) primarily by one aspect, secondarily by another aspect, &c.
10:28:55 <lavalike> Ordering monoid is so good
10:29:50 <Ariakenom> does it need understanding of monoid, or maybe more instances, to be interesting?
10:29:59 <Levy[m]> combinators such as `on` could be as they're usually easy to read
10:30:04 <Ariakenom> (aka how do people work?)
10:30:10 <ski> depends on whether you want to describe in details how it works
10:30:10 <Levy[m]> and to explain
10:30:38 <Ariakenom> only 5 min, so that would probably be about all of it :p
10:30:51 <Levy[m]> hmmm
10:31:00 <ski> perhaps you could show off how one can build one's own "looping constructs"
10:31:13 <Ariakenom> I can add it to my substantially larger collection of extra slides
10:31:29 <ski> well, in five minutes, you can mostly just scratch the surface, and suggest things, i think
10:31:41 <Ariakenom> yes
10:31:53 <ski> and perhaps give some overview of important concepts that makes programming in Haskell different
10:32:09 <ski> (such as immutability, non-strictness)
10:32:15 <Levy[m]> Could have a running instance of this https://hackage.haskell.org/package/djinn and use it to explore combinators.
10:32:15 <Ariakenom> that's what I'm going for with "id" adn purity
10:32:27 <Levy[m]> For the final part
10:32:39 <ski>   primes = sieve [2 ..] where sieve (p:ns) = n : sieve [n | n <- ns,n `mod` p /= 0]
10:32:48 <ski> could be a nice example of non-strictness
10:33:00 <Levy[m]> Showing that we can automatically derive programs from types
10:33:10 <Ariakenom> ski: yes. it's quite a lot of syntax though
10:33:34 <ski>   fibs = 0 : 1 : zipWith (+) fibs (tail fibs)  -- is simpler
10:34:12 <Ariakenom> Levy[m]: yes, pretty much what the id implementation from type is too
10:34:44 <Ariakenom> yes I've considered adding that exact code ski :)
10:34:58 <ski> some example of using a higher-order function could be nice
10:34:59 <Ariakenom> lots of nice suggestions all around
10:35:15 <Levy[m]> Yep, but showing it being done by a program would really catch their eye
10:35:25 <ski> > map (map (^2)) [[0,1,2,3],[4,5,6],[7,8],[9],[]]
10:35:27 <lambdabot>  [[0,1,4,9],[16,25,36],[49,64],[81],[]]
10:35:46 <Ariakenom> yes, I think I will touch on currying, function application and how that makes higher order and partial application nice
10:36:34 <Ariakenom> sounds a lot but I think I can make it fairly clear and nice with code
10:37:14 <Levy[m]> Ariakenom: This would be nice to give after https://www.hedonisticlearning.com/djinn/
10:37:18 <Levy[m]> for them to play with
10:37:33 <Ariakenom> Levy[m]: I have some repl-paste sections on the slide
10:37:59 * ski suspects it's a bit too much to expect them to come up with non-trivial types that djinn can do something useful with, after five minutes
10:38:33 * hackage vinyl 0.10.0.1 - Extensible Records  http://hackage.haskell.org/package/vinyl-0.10.0.1 (AnthonyCowley)
10:40:03 * hackage GLUtil 0.10.3 - Miscellaneous OpenGL utilities.  http://hackage.haskell.org/package/GLUtil-0.10.3 (AnthonyCowley)
10:40:28 <Ariakenom> djinn might be great to drive home the id thing.
10:40:59 <Levy[m]> Could also give other types for them to try
10:41:55 <Ariakenom> bit lighter than a link to Theorems for free
10:43:24 <Levy[m]> Could also link that as further research for the audience
10:43:52 <Ariakenom> I'll keep it in mind if someone asks
10:47:33 --- mode: glguy set -v orzo
10:50:25 <t7> anyone use a haskell code formatter ?
10:52:40 <shapr> stylish?
10:52:56 <shapr> t7: https://github.com/jaspervdj/stylish-haskell
10:54:04 * hackage expiring-containers 0.2.2 - Expiring containers  http://hackage.haskell.org/package/expiring-containers-0.2.2 (OShev)
10:54:42 <orzo> i implemented an unusual import-formatting style for stylish
10:54:50 <orzo> pull 216
10:55:15 <orzo> it's probably an acquired taste but i've been using it everywhere
10:57:00 <orzo> it combines the qualified and restricted import pattern into one stanza with one of the imports indented
10:58:41 <orzo> is there something like Functor but parameterized over a Rank-2 type?
10:59:09 <orzo> fmap2 :: (forall a. m a -> f a) -> m b -> f b
10:59:31 <orzo> er
10:59:42 <orzo> fmap2 :: (forall a. m a -> f a) -> t m b -> t f b
10:59:55 <orzo> or actually, nevermind the b
11:00:05 <hexagoxel> https://hackage.haskell.org/package/rank2classes-1.2/docs/Rank2.html#t:Functor
11:00:07 <orzo> fmap2 :: (forall a. m a -> f a) -> t m -> t f
11:00:31 <orzo> yeah thats it
11:00:32 <orzo> exactly
11:00:40 <orzo> thanks
11:19:12 <ski> @type Control.Monad.Morph.hoist
11:19:14 <lambdabot> forall k (t :: (* -> *) -> k -> *) (m :: * -> *) (n :: * -> *) (b :: k). (Monad m, Control.Monad.Morph.MFunctor t) => (forall a. m a -> n a) -> t m b -> t n b
11:19:42 <hexagoxel> huh, if an identifier starting with _ is imported only qualified, the error does not indicate that you might need the qualification when it is missing.
11:20:23 <hexagoxel> "[..] Or perhaps ‘_whatever’ is mis-spelled, or not in scope"
11:21:04 <orzo> it's a bad idea to begin identifiers with _ if they aren't typed holes
11:21:30 <hexagoxel> for record fields, it is quite common
11:22:06 <zachk> autogenerated prisms from lenses as well
11:23:40 <t7> is there a better way todo this: if condition then Left "error" else Right ()
11:23:41 <hexagoxel> funnily, you can just remove the underscore, and get a proper "perhaps you meant Qualified._whatever"
11:23:43 <t7> inside a do 
11:25:05 <geekosaur> :t when
11:25:07 <lambdabot> Applicative f => Bool -> f () -> f ()
11:25:27 <hexagoxel> :t \x -> when x (Left "error")
11:25:28 <lambdabot> Bool -> Either [Char] ()
11:25:38 <t7> wtf
11:25:52 <t7> ah Left: Either a ()
11:26:57 <dmwit> :t \x -> when x (throwError "error")
11:26:59 <lambdabot> MonadError [Char] f => Bool -> f ()
11:28:30 <geekosaur> actually,w hat I had been thinking of was
11:28:42 <geekosaur> % :t guard @(Either String)
11:28:42 <yahb> geekosaur: Bool -> Either String ()
11:29:40 <hexagoxel> > guard False :: Either String ()
11:29:42 <lambdabot>  Left ""
11:30:57 <dmwit> geekosaur: no slot for an error message though
11:31:30 <geekosaur> true, btu if you're going that far, the only shorter you're going toget is wrapping it in a fnction of your own devising
11:38:33 * hackage cabal2nix 2.12 - Convert Cabal files into Nix build instructions.  http://hackage.haskell.org/package/cabal2nix-2.12 (PeterSimons)
11:59:37 * hackage HCL 1.5.1 - High-level library for building command line interfaces.  http://hackage.haskell.org/package/HCL-1.5.1 (jlamothe)
12:26:10 <rain1> @src sequence
12:26:10 <lambdabot> sequence []     = return []
12:26:10 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:26:10 <lambdabot> --OR
12:26:10 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
12:39:55 <shapr> @src traverse
12:39:55 <lambdabot> Source not found. I am sorry.
12:40:02 <shapr> @src Data.Traversable.traverse
12:40:02 <lambdabot> Source not found. :(
12:40:06 <shapr> hrmm
12:41:05 <geekosaur> it's a manually managed database in the lambdabot repo, not a general source lookup
12:41:33 <shapr> too bad
12:47:09 <Akii> I made dis, Haskell backend https://elescore.de/
12:53:03 <t7> how do i do lots of lets in a non do
12:53:09 <t7> like 
12:53:20 <t7> \x -> i need lots of named variables 
12:53:37 <t7> i would use `where`  if it was a top level binding
12:55:52 <t7> i wish haskell was not whitespace sensitive sometimes 
12:56:00 <marvin2> in a single line: `\x -> let y = 10; z = 20 in ..'. in multiple lines you can substitute ; with newline
12:56:31 <MarcelineVQ> t7: all the same ways you'd do them in a do, but you end it with  in    https://gist.github.com/MarcelineVQ/5aabf53b2334894f8cf91692cdb11e6a
12:57:59 <t7> MarcelineVQ: do you do 80 char lines?
12:58:09 <MarcelineVQ> mostly
12:59:11 <t7> this is the only time in my codebase where i have to indent so much WS :(
13:02:00 <MarcelineVQ> a busy lambda should typically be given a name and moved out
13:02:54 <MarcelineVQ> it's like a kid, if they start saying "you just don't get it", it's time tof them to move out
13:02:54 <pjrt> Oh, I didn't know u could use `;`. I've always just used the `let ... in let ....` pattern
13:04:08 <MarcelineVQ> pjrt: I'm not very good with it, but whitespace can be, entirely I think, replaced with { } and ;
13:04:39 <MarcelineVQ> I mean, obviously not for function application, but as far as source structure goes
13:04:47 <c_wraith> MarcelineVQ, indentation can be. spaces between tokens can't. :)
13:05:06 <c_wraith> (when adjacent tokens use letters)
13:05:07 <MarcelineVQ> doh ho ho
13:29:31 <tdammers> 80 chars is life, 80 chars is love
13:30:23 <shapr> I like 236
13:38:57 <glguy> Maybe love and life are just overrated
13:43:01 <tdammers> well, technically, both of these are only 4 chars each
13:57:35 <pjrt> I've been doing 80 for ages, but I've recently started to see the advantage of 120
14:00:08 <__monty__> Annoying everyone else?
14:00:11 <__monty__> : >
14:00:32 <emilypi> glguy forget love and life, get moneys and honeys
14:01:33 <pjrt> I've just been noticing more and more signatures that are "just long enough to be over 80 but not long enough where I find them too long"
14:02:43 <emilypi> pjrt vertical alignment not your thing? 
14:03:02 <earthy> 120 is weird. 132 sounds better.
14:03:22 <pjrt> When too long, but I prefer nice, flat signatures, ofc
14:03:36 <__monty__> Type synonyms : >
14:03:42 <pjrt> I also do Scala for a living, vertical aligments for scala aren't are pretty :)
14:03:53 <pjrt> Also, hi emilypi ! Long time to speak
14:04:16 <emilypi> yes! hey buddy. You coming out wednesday for the old crew meet?
14:04:28 <__monty__> earthy: What 120 has going for it is you're not the only one to like it : p
14:04:40 <pjrt> Ah right, fommil is in town
14:04:44 <emilypi> yeah
14:06:02 <earthy> __monty__: well, I'm old school. We had 40, 80 or 132 characters per line
14:07:59 <__monty__> earthy: Really? Never heard of 132. I stick to 80 for everything though.
14:08:21 <earthy> __monty__: 132 was on the original vt100 as well as on line printers
14:08:23 <geekosaur> old line printers
14:08:52 <earthy> mighty beasts, those line printers.
14:09:03 * geekosaur often uses 96 these days. which also has some history
14:12:38 <__monty__> I've always liked narrow text. And 76 or thereabouts is supposedly optimal for prose, so why deviate for code?
14:13:13 <geekosaur> most prose is rather closer to bricktext
14:13:28 <ski> (`DECCOLM' can be used to switch between `80' and `132')
14:13:34 <geekosaur> if your code is, you need to rethink things
14:14:20 <MarcelineVQ> I just like being able to have an editor and documentation/tooling up on the screen at the same time, ~80 works for this
14:16:23 <ski> > 132 `div` 2
14:16:25 <lambdabot>  66
14:16:30 <ski> hm, interesting
14:18:32 * ski . o O ( "Separate each file into pages of no more than sixty-six lines and no fewer than forty lines with form feeds (ASCII #x0C, or ^L, written in Emacs with `C-q C-l'), on either side of which is a single line break (but not a blank line).","It also allows readers of the code to print it onto paper without fiddling with printer settings to permit pages of more than sixty-six lines (which is the default number for many printers), .." )
14:21:03 <__monty__> geekosaur: My point is prose doesn't require more so why would I use more for code, since I like narrow text anyway.
14:21:49 <ski> (perhaps the idea is that code doesn't break as easily ?)
14:24:10 <__monty__> Then code should be more "bricktext"-y than prose : >
14:46:35 --- mode: glguy set +v Brandon_
14:48:19 <Brandon_> I have a general type theory question. If I have a function e.g. f(x) = 2x, then the type signature might be f: R -> R, where R is a real number. But if I have a constant function, such as f(x) = 5, then what is the type signature? The return type is not the type of all real numbers, it's a constant value.
14:49:13 <boj> Brandon_: it would be f :: R
14:49:52 <mniip> Brandon_, even in mathematics, the range of the function is not its codomain
14:50:06 <mniip> an equation f(x)=2x is not enough to conclude what is its domain or codomain
14:50:21 <mniip> I could say f(x)=2x as a function from [0,1] to (-3, 10)
14:50:34 <__monty__> Brandon_: Numeric constants in haskell have type Num a => a afaik.
14:50:47 <mniip> likewise, f(x)=5 could be a function into {5}, [4, 6], or R
14:51:14 <pjrt> Wouldn't the type signature be the same?
14:51:21 <pjrt> `5` is still a Real Number
14:51:25 <mniip> in type theory however types usually don't intersect
14:51:35 <mniip> so there's no type like {5} or [4, 6]
14:51:40 <c_wraith> 5 is a number in many definitions of "number"
14:51:55 <c_wraith> R, Z, Q, and many others!
14:51:56 <mniip> so yeah, R is the most "fine" specification you can give
14:52:14 <c_wraith> what's wrong with C?
14:53:52 <Brandon_> But I want to distinguish between a value and a variable I guess
14:54:28 <Brandon_> the function f(x) = 2x accepts a variable and uses that variable in the funciton body, whereas f(x) = 5. there's somethign different about these two that I want to capture type theoretically
14:54:37 <pjrt> Then `f :: R -> 5` :|
14:54:50 <pjrt> I guess
14:55:06 <boj> Brandon_: what is the point of the x if it is not used?
14:55:13 <pjrt> I believe that's valid syntax in Idris :)
14:55:13 <mniip> Brandon_, you could say in the latter x can be universally quantified
14:55:18 <mniip> f :: forall a. a -> R
14:55:31 <mniip> that implies the only thing f can be is a constant function
14:55:57 <pjrt> That's technically a "point", no?
14:56:09 <pjrt> f :: () -> 5
14:56:38 <mniip> pjrt, forall a. a -> R is equivalent to () -> R
14:56:49 <mniip> (but do you know why)
14:57:26 <pjrt> Is it? Because you have no knowledge of `a`, but `()` has a single instance
14:57:39 <pjrt> and it is the initial object in Hask
14:57:50 <pjrt> (assuming Hask is a category, blah blah)
14:58:08 <mniip> and then  forall a. R -> a  is equivalent to  R -> Void
14:58:20 <mniip> but  forall a. a -> a  is not equivalent to  () -> Void
14:58:37 <mniip> strange huh?
14:58:38 <shachaf> forall a b. a -> b is, though
14:58:42 <mniip> sure
14:59:31 <pjrt> I stil don't follow how `∀a. a -> R` is the same as `() -> R`
14:59:41 <pjrt> unless you are counting `undefined` as initial
14:59:59 <pjrt> or something else I am now seeing
15:00:06 <pjrt> not*
15:00:18 <mniip> @free a -> R
15:00:18 <lambdabot> Extra stuff at end of line
15:00:22 <mniip> @free forall a. a -> R
15:00:22 <lambdabot> Try `free <ident>` or `free <ident> :: <type>`
15:00:27 <mniip> @free f :: forall a. a -> R
15:00:27 <lambdabot> f = f . g
15:00:30 <Brandon_> so it  should be f:: R -> () -> 5?
15:00:41 <mniip> Brandon_, what no
15:00:54 <mniip> pjrt, f = f . g, for any g
15:01:15 <pjrt> Well that went over my head
15:01:18 --- mode: glguy set +v dgirsh
15:01:24 <infinisil> pjrt: You have equally little knowledge about both () and any a
15:01:28 <mniip> in particular consider g that maps everything to ()
15:01:34 <infinisil> pjrt: You only know that it exists, nothing else
15:01:42 <pjrt> ohhhhh
15:01:49 <pjrt> yeah, I see what you mean now
15:02:02 <boj> Brandon_: f :: a -> R; f _ = 5
15:02:06 <pjrt> That's an interesting way of seeing that
15:03:09 <pjrt> Never thought about it. If a thing has a single instance, with no properties except that it exsits, then it is the same as `∀a. a`
15:03:21 <mniip> that's not correct
15:03:59 <shachaf> i,i if a thing has no properties except that it exit()s, then it has the type ∀a. a
15:04:37 * hackage slick 0.2.0.0 -   http://hackage.haskell.org/package/slick-0.2.0.0 (ChrisPenner)
15:04:41 <mniip> there's the abstraction theorem, that says in this particular instance that for any types T, T', and any relation R : T<=>T' , forall (x, y) in R, f(x) = f(y)
15:04:41 <zachk> does forall a . a exist? 
15:05:01 <boj> f :: Void
15:05:22 <mniip> which in particular implies that for any type T and for any x :: T, f(x) is the same value
15:05:53 <mniip> the thingy given by lambdabot is by assuming that R is a function
15:06:09 <mniip> iow forall x. f(x)= f(R(x))
15:06:25 <zachk> @free forall a . a 
15:06:25 <lambdabot> Try `free <ident>` or `free <ident> :: <type>`
15:06:27 <c_wraith> zachk, in what theory? there are terms with that type in Haskell, but Haskell is hardly the only type theory.
15:06:54 <zachk> say in haskell, would it just be _|_ ? 
15:07:02 <c_wraith> :t undefined
15:07:03 <lambdabot> a
15:07:16 <c_wraith> if you have explicit foralls, there you go.
15:07:27 <zachk> undefined is bottom right? 
15:07:35 <c_wraith> but yeah, all bottom values can have the type forall a. a
15:07:44 <Brandon_> So the type of f(x) = 5, where x: R   is f:: R -> c    where c is the constant type?
15:08:22 <zachk> i think it would more be f :: a -> R 
15:08:41 <zachk> oh x has to be r would be R -> R then 
15:10:22 <pjrt> mniip: Unn, can't say I 100% follow (probably need to know this abstraction theorem you mentioned), but intuitibly I think I follow what u are saying.
15:10:29 <pjrt> Anywho, have to sign off for today
15:10:34 <pjrt> Cya!
15:11:31 <Brandon_> I want the maximally restrictive type signature, yes f(x) = 5 could be defined as f:: R -> R but it is more specificalyl always mapping to a single element of a type.
15:12:35 <boj> what are you trying to restrict?
15:12:36 <dstolfa> Brandon_: what you want is dependent types
15:12:56 <dstolfa> with judgemental equality defined that lets you compute in the types
15:13:04 <dstolfa> but plain haskell doesn't have that
15:13:09 <dstolfa> so R -> R is what you want here
15:13:28 <Brandon_> Does Idris have what I want?
15:13:47 <dstolfa> Brandon_: probably, but i've not used idris so i can't answer that, sorry :-(
15:14:05 <Brandon_> ok, thanks though!
15:14:26 <hpc> what properties does f have?
15:14:30 <rain1> wouldn't even function just have its source code as the type?
15:14:38 <devoid_> whatever you want my dude
15:15:09 <boj> what is Brandon_ trying to accomplish (for us non-math types)? map any value in a domain to a codomain with a single value?
15:16:54 <ski> something like `f : forall a. a -> {x : R | x = 5}', iiuc ?
15:17:15 <ski> (perhaps look into Liquid Haskell ?)
15:17:17 <hpc> ah, that's better than what i was thinking of
15:17:26 <hpc> i was trying to write it as some dependent pair kind of thing
15:17:43 --- mode: glguy set +v hhefesto
15:17:43 <hpc> this is a pretty contrived example anyway
15:17:51 <hpc> my first tool for this sort of problem would be data Five = Five
15:18:12 <hpc> if that number is really that special
15:18:25 <ski> apparently in ATS, you can have `f : forall a. a -> int(5)' (i don't recall syntax exactly)
15:20:26 <hpc> maybe a better question would be about a type that expresses a sort function is correct
15:22:30 <hhefesto> Hello, mighty haskell community!
15:22:41 <koz_> hhefesto: We are indeed mighty.
15:22:55 <hhefesto> lol
15:23:00 <hhefesto> I agree
15:23:05 <hhefesto> Would someone happen to know why GHC is saying that ``` customers <- runDB $ ... ``` isn't an expression? https://gist.github.com/hhefesto/13c48bfe5ae9ed96d2346726ce5fa7f8
15:23:16 <ski> it isn't
15:23:24 <ski> did you forget `do' ?
15:24:02 <boj> hhefesto: note that the last thing in a function must be an expression. perhaps you want to just call runDb directly, or `return customers`
15:25:32 <[Leary]> Looks like you indented line 22 too deep.
15:26:16 <[Leary]> And the previous one not deep enough? Not sure why there's a do before it.
15:26:48 <ski> should that `return $ (followUp, ...)' be deindented two spaces ?
15:28:33 * hackage antiope-athena 6.1.4 -   http://hackage.haskell.org/package/antiope-athena-6.1.4 (newhoggy)
15:28:54 <hhefesto> making the return less indented made other things break
15:29:25 <hhefesto> Will be back when things do better sense on my head
15:29:33 * hackage antiope-sqs 6.1.4, antiope-sns 6.1.4, antiope-s3 6.1.4, antiope-messages 6.1.4, antiope-dynamodb 6.1.4, antiope-core 6.1.4, antiope-contract 6.1.4 (newhoggy)
15:32:14 <ski> perhaps there should also be a `return c' (or something) after that `E.where_ ...' command
15:44:28 <zachk> is ghc 8.0.2 very old? 
15:44:52 <phadej> zachk: depends on whom you ask
15:45:00 <glguy> zachk: https://www.haskell.org/ghc/
15:46:44 <zachk> its almost two years old, not that old I guess
15:47:17 <glguy> It's common for people to support the last 3 major versions of the compiler, so 8.6, 8.4, 8.2
15:49:27 <zachk> I think I started on like ghc 6.8.2 , which isn't even on that web page anymore
15:50:45 <phadej> glguy, zachk; yet the time between 8.6 and 8.2 releases (note skipped 8.4) is roughly the same as between 8.2 and 8.0
15:51:17 <phadej> I personally try to not stick to  "3 major versions" as it's very vague
15:51:41 <glguy> I can understand not sticking to that, but it doesn't seem particularly vague
15:52:06 <phadej> (I rather stick to "support whateveer is in Ubuntu LTS" :)
15:52:10 <koz_> If I want to specialize (^ 2.0) to Double using TypeApplications, how do I spell that?
15:52:22 <koz_> I tried (^ @Double 2.0), but GHC wasn't very happy with that.
15:53:05 <glguy> koz_: You wanted the 2.0 to be a double?
15:53:22 <koz_> glguy: I want the result to be a Double, but I guess that would work too.
15:53:22 <glguy> You can only use type applications on named things, so something like: (^) @Double 2.0 :: Integral b => b -> Double
15:53:30 <glguy> though that's not what you wrote, just an example
15:53:41 <glguy> (since (^) isn't flipped there)
15:54:27 <koz_> glguy: OK, I think I'll just use a specialized helper with a type sig.
15:54:31 --- mode: glguy set +v atondwal
15:54:41 <zachk> I think ubuntu bionic beavers haskell-platform is ghc 8.0.2 
15:54:43 --- mode: glguy set -v atondwal
15:55:20 <glguy> koz_: (^ 2.0) doesn't work on its own, 2.0 isn't an Integral thing
15:55:29 <koz_> glguy: Yeah, just realized.
15:55:41 <glguy> zachk: The GHC that comes built into Ubuntu isn't for development, it's for building Ubuntu packages
15:55:43 <atondwal> Is there a way to tell ghci not to print out free variables when I stop at a breakpoint? It takes several minutes for my usecase...
15:55:56 <koz_> glguy: OK, I've got it. Was misreading GHC's earlier complaints.
15:59:04 <zachk> glguy, ubuntu comes with a builin ghc now? I was referring to the ghc from their haskell-platform 
16:00:13 <glguy> No, it's not "built-in", but it's provided as a package via apt
16:15:30 <atondwal> is it just me, or is ghci useless in debugging large applications? do the GHC devs just use `Debug.Trace` to printf everything?
16:16:35 <geekosaur> the script to load ghc itself into ghci argues otherwise to some extent
16:17:19 <geekosaur> but ghci isn't exactly the greatest debugging environmnt ever. that said, "printf debugging" is common in many languages for a reason
16:17:20 <hpc> ghci is great
16:17:30 <hpc> you just don't use it like gdb
16:17:58 <hpc> you use it to decompose a large application and create smaller reproductions
16:17:59 <hpc> of bugs
16:25:20 <infinisil> hpc: I still have no idea how to reliably debug haskell :/
16:27:17 <atondwal> geekosaur: how does that script deal with size? ghci really chokes if I'm trying to run `:trace` on something with a lot of steps
16:27:25 <hpc> in general, you write as much of your code out of IO as possible
16:27:28 <atondwal> I guess the answer is to not use `:trace`?
16:28:06 <geekosaur> the scrpt only manages loading, not what you do once loaded. I couldn't say how it's used
16:28:10 <hpc> and then you never need to really do much environment-specific stuff to reproduce a bug
16:28:27 <atondwal> geekosaur: loading is the easy part :)
16:28:36 <hpc> start with some relevant function and give it inputs that are similar to what the original issue would pass
16:28:46 <geekosaur> nto for ghc it isn't
16:28:55 <geekosaur> or, I suspect, any program with many sub-packages
16:30:39 <hpc> if that doesn't work and it's an IO issue, coming up with a reproduction is going to involve writing more code anyway
16:30:48 <atondwal> geekosaur: compared to actually debugging the beast? :)
16:31:03 <hpc> but you've already separated out the IO from the rest of the logic so you just do the IO parts and print what it produces
16:31:06 <geekosaur> I'll take Kernighan's answer there :p
16:31:17 <hpc> and don't really need to set a breakpoint anywhere to examine values
16:33:34 --- mode: glguy set +v fen
16:33:45 <atondwal> anyhow I'm trying to run a function in a repl, but its first argument is some massive data structure that has a processed source file in it, and I want to try applying it with a bunch of different choices for the second parameter
16:34:16 <fen> having trouble with impredictive polymorphism; https://bpaste.net/show/412b5b32fb9b
16:34:27 <atondwal> so I set a breakpoint in it... and for some reason the first argument isn't in scope?
16:34:43 <atondwal> I guess I should really try to put together a small example
16:34:46 <hpc> don't think of it as debugging the program
16:34:58 <hpc> open ghci, import your modules
16:35:07 <hpc> then you want to produce the value of that first argument
16:35:28 <hpc> presumably you have some simple definitions to read the file and parse it into that massive value
16:35:31 <hpc> so you write
16:35:40 <hpc> firstArg <- thatFunction "/that/file"
16:35:50 <hpc> now you have another function you want to test, f
16:35:54 <hpc> so you write
16:35:56 <hpc> f firstArg 0
16:36:00 <hpc> f firstArg 1
16:36:00 <hpc> etc
16:36:40 <hpc> if you want to then examine firstArg, you have it right there and you have all of haskell with which to examine it
16:36:50 <fen> the paste shows an attempt to "add constraints" to a type which differs only by what constraints it has over it
16:37:46 <hpc> atondwal: hopefully that makes it easier to see ghci's model of debugging?
16:43:25 <fen> the problem with bundling a constraint into a datatype is that this constraint needs to be written into the type signature of functions over this type, while it would be good if the constraint, which has to be satisfied in order to create values to pass to the function, would go into the type signature automatically, but type families can be used instead
16:44:50 <fen> the problem is doing the inverse, of recreating the constrained type as a return value, where the constraint now instead of being retrived from the datatype to be used in the type signature, now needs to be taken from the type signature to be recombined with the type it is to be bundled with in the constrained datatype
16:45:19 <fen> can type families do this?
16:47:43 <koz_> What would you nice folks suggest I use to pick min {k, len arr} random unique indices of an array arr?
16:48:16 <fen> shuffle
16:48:19 <ski> fen : GADTs ?
16:48:56 <lyxia> fen: the code you pasted seems to just be a confusion where you put (,) instead of Constrained somewhere
16:49:04 <fen> ski: in the paste? isnt Constrained ok?
16:49:15 <fen> lyxia, yeah thats it
16:49:18 * ski hasn't seen any paste
16:49:21 <fen> https://bpaste.net/show/412b5b32fb9b
16:49:49 <geekosaur> it's in scriollback but you have to go back a ways
16:49:58 <koz_> I guess I could shuffle then take the array [0,1...,length arr - 1], guess I'll do that.
16:50:08 <lyxia> so what goes wrong if you write \f (a, b) -> Constrained (f a, b)  instead?
16:50:15 <fen> koz_ thats not so lazy though
16:50:35 <koz_> fen: If you have a concrete, non-single-word, suggestion, I am all ears.
16:50:54 <koz_> I'm not sure what laziness gets me in this case anyway, since I have an array anyhow.
16:51:19 <lyxia> your sort then take is a nice solution
16:51:34 <koz_> lyxia: You mean _shuffle_ right?
16:51:50 <lyxia> oh yeah
16:51:59 <lyxia> "co-sort"
16:52:12 <koz_> LOL
16:52:17 <koz_> Best name for a shuffle yet.
16:52:19 <fen> co-pivot 
16:52:24 <ski> fen : hm, how do you want to use `Constrained' ?
16:52:41 <koz_> My mind is currently co-sorted, clearly.
16:52:55 * ski . o O ( cohorted )
16:53:02 <fen> thats what the Zipper example shows ski. it is an extra constraint added to a Loop
16:54:03 <ski> fen : is `forwards' supposed to be an example of the "inverse" you were talking about above ?
16:54:04 <fen> lyxia: that lambda pattern will bundle up the existing constraint from the type signature right?
16:54:16 <fen> ski: no?
16:54:30 <fen> oh
16:54:32 <fen> yes
16:54:40 <fen> its type signature
16:54:50 <ski> fen : just to make it clear, your `Constrained' isn't bundling up any constraint
16:55:05 <fen> possibly it could use patterns to match the pair like (Loop a b)
16:55:13 <fen> pattern synonyms
16:55:28 <fen> data Constrained p a = Constrained (p => a)
16:55:32 <fen> sure looks like it does
16:56:28 <fen> thats just to get round impredictive polymorphism
16:56:34 <fen> it would be better as a type
16:56:35 <ski> consider `Constrained [0,1,2]'. this can be given the type `forall a. Constrained (Num a) [a]'
16:56:48 <ski> because `[0,1,2]' is polymorphic in which number type to use
16:57:05 <fen> ok
16:57:49 <ski> but perhaps you were looking to express `data Provides c a = c => Bundle a' ?
16:58:28 <fen> oh, what difference does that commutiation do?
16:58:36 <ski> a value of type `Provides (Ord a) [a]', say, contains a list of type `[a]', and evidence that `Ord a' holds
16:59:19 <ski> this means that instead of going `foo :: Ord a => [a] -> Maybe a', say, you can go `foo :: Provides (Ord a) [a] -> Maybe a', *hiding* the constraint in the input argument
16:59:29 <fen> ok sure, thats the better type
16:59:46 <ski> `Provides' and your `Constrained' are very different
16:59:52 <ski> basically opposites of each other
16:59:56 <fen> oh?
17:00:16 <fen> one gives proof, the other expresses that proof is required?
17:00:49 <ski> if you say `bar :: ... -> Provides (Ord a) [a]', then that means that `bar' will itself give you back evidence for `Ord a', when calling it (after unpacking the result, of course)
17:01:39 <ski> while `baz :: ... -> Constrained (Ord a) [a]' is just basically the same as `baz :: Ord a => ... -> [a]', in other words here `baz' *requires* the caller to provide `Ord a', rather than itself providing `Ord a' to its caller
17:01:48 <ski> fen : yes
17:02:13 <ski> you can also declare `Provides' using GADT syntax, as
17:02:26 <ski>   data Provides c a
17:02:28 <ski>     where
17:02:40 <ski>     Bundle :: c => a -> Provides c a
17:02:51 <koz_> ski: Couldn't this be done with Edwards constraints package?
17:02:51 <ski> while
17:03:00 <ski>   data Constrained c a
17:03:02 <ski>     where
17:03:11 <ski>     Constrain :: (c => a) -> Constrained c a
17:03:14 <ski> is very different
17:03:21 <fen> @let type Provides c a = c => a
17:03:23 <lambdabot>  Defined.
17:03:34 <koz_> s/Edwards/Edward's/
17:03:59 <ski> koz_ : probably
17:04:23 <ski> fen : no, that's `Constrained'
17:04:31 <fen> ohhh
17:04:32 <ski> `Constrained c a' is `c => a'
17:04:41 <ski> while `Provides c a' is `c *> a'
17:04:56 <ski> (and `Dict c' at <https://hackage.haskell.org/package/constraints-0.10.1/docs/Data-Constraint.html> is `c *> ()')
17:05:13 <fen> can that be made into a type instead of a datatype? maybe then it wont complain about impredictive polymorphism at its use site
17:05:16 <ski>   Bundle :: c => (a -> Provides c a)
17:05:21 <ski> is logically the same as
17:05:29 <ski>   Bundle :: (c *> a) -> Provides c a
17:05:35 <ski> by "uncurrying"
17:05:48 <ski> hence `Provides c a' expresses `c *> a'
17:06:04 <fen> but can you express (*>) as a type instead of a datatype?
17:06:11 <ski> (that `Constrained c a' expresses `c => a' can be read of directly from the signature of `Constrain')
17:07:13 <ski> fen : you need at least `ExistentialQuantification' (or else `GADTs') to be able to define `Provides'
17:07:16 <ski> so, no
17:07:45 <fen> is there any nice sugar for Provides as a GADT?
17:08:10 <fen> maybe Bundle could be an infix symbol that resembles =>
17:08:18 <ski> (well, if `*>' was added to the language, directly, instead of merely being able to encode it (similarly to how one may encode existential quantification via `data' types), then one (obviously) wouldn't need a `data')
17:08:51 <fen> is that something that can be done with TypeReps?
17:09:00 <ski> (my point is that i don't see it as inherent in the idea of `*>' that you must express it as a `data' type. just as a consequence of the current way to do it)
17:09:31 <ski> not sure what you had in mind, but i suspect not
17:09:56 <fen> thought maybe QuantifiedConstraints might help
17:10:19 <ski> hm, maybe you can CPS it with that
17:10:29 <fen> hmm, there was something somewhere about how implicitparams are implemented, was just trying to find that
17:10:49 <fen> it had type applications and some string type reflection stuff going on
17:11:25 <fen> seemed like a pretty powerful approach for defining language extensions
17:11:28 <fen> writing*
17:12:08 <fen> the ?x:: implicit param is sugar for something, wait might be able to find it
17:13:06 <mniip> GHC.Classes.IP
17:13:16 <ski> it's a different kind of constraint, than class constraints
17:14:02 <ski> (well .. in the technical sense of the word "kind", both have kind `Constraint', of course)
17:14:07 <fen> ah, TypeLists
17:14:24 <ski> @kind ?x :: Int
17:14:25 <lambdabot> Constraint
17:14:30 <ski> @kind Num Int
17:14:31 <lambdabot> Constraint
17:14:56 <fen> maybe a continuation would be an ok encoding of *> but it would be good to be able to give it as a type synonym...
17:16:02 <phaazon> hey peeps
17:16:10 <ski> `c *> a' can be expressed as `forall o. (c => a -> o) -> o', yes
17:16:13 <phaazon> is there a way to export a typeclass without exporting its content? 
17:17:03 <fen> ski: sure, but that then gets the user stuck in writing continuation style
17:17:18 <ski> (and i suppose `c => a' can be expressed as `exists s. (s,(c *> s) -> a)')
17:17:25 * ski nods
17:17:55 <fen> whats that last thing?
17:18:09 <fen> pseudohaskell?
17:18:12 <ski> phaazon : hm, try just writing the class `C' in the export list. or `C ()'
17:18:21 <ski> fen : of course
17:18:27 <phaazon> it exports everything, ski
17:18:36 <phaazon> I just tried with ghci
17:18:40 <ski> it exports the methods ?
17:19:03 <fen> not sure the data and continuating encodings of exists are whats sought after here
17:20:09 <ski> fen : just as `a' can be expressed via CPS as `forall o. (a -> o) -> o', it can also be expressed (in "OO" / state-passing-style) as `exists s. (s,s -> a)'
17:20:10 <fen> ski: mentioning implicitparams just because there seemed to be a way to write new syntax without resorting to TH
17:20:37 <fen> :t store
17:20:39 <lambdabot> error: Variable not in scope: store
17:20:43 <fen> hmm, nvm
17:20:52 <ski> (more generally, `f a' can be expressed as `forall o. (a -> o) -> f o' and as `exists s. (f s,s -> a)', if `f' is a functor. these are the yoneda and coyoneda encodings)
17:21:17 <fen> nice
17:22:13 <lyxia> phaazon: ghci puts the whole module toplevel in scope but that's because it ignores the import list
17:22:23 <ski> (anyway, my point above was that, just as `*>' could be expressed in terms of `forall' and `=>' (and `(->)'), `=>' could be expressed in terms of `exists' and `*>' (and `(,)' and `(->)'))
17:22:26 <fen> so is there any chance of getting (*>) to work with nicely without having newtypes to contend with
17:22:38 <ski> `newtype's ?
17:23:05 <fen> like, to have an AddConstraint :: q -> (p *> a) -> ((p,q),a)
17:23:15 <fen> datatype wrappers*
17:23:35 <zachk> @type *> 
17:23:35 <mniip> that's a kind error
17:23:37 <ski> i'm not sure what the point of `AddConstraint' in your paste was
17:23:37 <lambdabot> error: parse error on input ‘*>’
17:23:45 <zachk> @type (*>) 
17:23:46 <lambdabot> Applicative f => f a -> f b -> f b
17:24:11 <fen> data Constrained p a = Constrained (p => a)  type family AddConstraint (q :: Constraint) c where  AddConstraint q (Constrained p a) = Constrained (q,p) a
17:24:11 <ski> zachk : not that one
17:24:19 <zachk> fen, if *> is one of your operators you might want to rename it because it conflicts with Control.Applicative
17:24:26 <zachk> oh there is another one? -_- 
17:25:14 <phaazon> lyxia: right, I had forgotten that
17:25:15 <ski> zachk : i'm talking about a pseudo-Haskell notation i use informally, to discuss "bundling up a constraint with data, providing it to the user/caller/consumer"
17:25:16 <phaazon> thanks
17:25:23 <fen> data Provides c a where (*>) :: c => a -> Provides c a
17:25:34 <ski> (also some other people have also used it)
17:26:03 * ski would prefer to avoid using the constructor name fen just gave
17:26:16 <fen> hmm?
17:26:33 <ski> (i'm not really a fan of "punning" in the sense of naming/spelling related things on the type and value level the same)
17:27:07 <ski> (hence why i renamed your data constructor `Constrained' to `Constrain', to distinguish it from the type constructor `Constrained')
17:27:15 <fen> oh
17:28:26 <ski> (also, that data constructor `(*>)' (which would have to start with a `:', but ignore that for now) only takes a single (explicit) argument .. so not the best thing to use an infix operator for)
17:28:30 <fen> data Provides c a where Bundle :: c => a -> Provides c a
17:28:31 <fen>  Bundle :: (c *> a) -> Provides c a
17:29:19 <ski> `C => (T -> U)' is equivalent to `(C *> T) -> U'
17:29:38 <ski> `forall a. (T a -> U)' is equivalent to `(exists a. T a) -> U'
17:29:41 <fen> right, but if it was; type c (*>) a = c => a ... but that doesnt work because its Constrain not Provides 
17:29:54 <ski> both of these corresponds to "currying/uncurrying", in some sense
17:30:45 <fen> dont we have type Curry? cant it just be type Constrain c a = c => a, type (*>) = Uncorry Constraint
17:31:08 <fen> Curry Constrain*
17:31:14 <fen> or Uncurry, not sure
17:31:14 <ski> i suppose you could `data c *> a = c => Bundle a'
17:31:36 <fen> huh, Bundle takes values?
17:31:39 <ski> fen : that doesn't make sense
17:32:03 <fen> oh, its a redefining 
17:32:07 <fen> nvm
17:32:11 <ski> (in that `data' declaration, `(*>)' has replaced `Provides')
17:32:30 <fen> yeah, its not whats sought here
17:32:42 <fen> Provides was ok, but its a datatype, not a type nynonym
17:32:47 <fen> synonym*
17:33:13 <fen> Constrain can be written as a type synonym, but it cant be used because of impredictive polymorphism
17:33:30 <fen> would (*>) be the same?
17:33:35 <ski> right, because there is no actual `*>' (in the sense i was talking about), in Haskell (with extensions)
17:33:45 <ski> it's just pseudo-Haskell
17:33:53 <zachk> isn't there a language pragma to AllowImpredicativeTypes ? 
17:33:57 <fen> ohh, your version is a type family?
17:34:14 <ski> `Constrained c a' can be written as a type synonym for `c => a', because `=>' already is in the language
17:34:17 <ski> `*>' isn't
17:34:22 <fen> hmm
17:34:26 <ski> (no, no type family)
17:34:48 <fen> something must prevent it from working as a type family?
17:34:54 <ski> zachk : `ImpredicativeTypes'
17:34:59 <fen> being written as a type family*
17:35:16 <zachk> ski, would setting that get around his problem?
17:35:20 * ski has no idea how fen intends to write it as a type family
17:35:30 <ski> zachk : whose problem ?
17:35:42 <fen> confused, is your (*>) different from something like provides but as a type
17:35:59 <zachk> fen's
17:36:05 <ski> <ski> hence `Provides c a' expresses `c *> a'
17:36:07 <ski> <ski> (that `Constrained c a' expresses `c => a' can be read of directly from the signature of `Constrain')
17:36:21 <zachk> assuming fen is male
17:36:25 <ski> zachk : i don't think so ?
17:36:30 <fen> hmm
17:36:38 <lyxia> ImpredicativeTypes is unlikely to be a solution to anyone's problems, it's a badly incomplete extension.
17:36:55 <nshepperd> iirc ImpredicativeTypes completely breaks type inference, so it's pretty useless
17:37:26 <fen> its not needed anyway as constrain is not what was really sought, it was a Provides but written as a type synonym 
17:37:47 <fen> which apprantly needs (*>) to be "part of the language" like how => is
17:37:52 <ski> fen : yes .. which was my original suspicion, upon seeing that paste, and what you were talking about
17:38:18 <fen> yeah, so the problem is with a lack of (*>)
17:38:24 <fen> and how to fix that
17:38:48 <nshepperd> type Provides c a = forall r. (c => a -> r) -> r
17:39:01 <fen> isnt that worse to work with?
17:39:02 <ski> the `Provides' i gave above merely encodes `(*>)' as a `data' type (not a `newtype'. that wouldn't work with a dictionary-passing implementation, we need an "extra implicit field" for the constraint evidence / instance dictionary)
17:39:08 <fen> like, for pattern matching
17:39:31 <fen> thats why the datatype version was to be avoided, as it would then need pattern synonyms too many
17:39:58 <fen> ski: no not a newtype or a datatype, a type
17:40:08 <fen> and not a continuation
17:40:09 <ski> fen : "and how to fix that" -- (a) design an extension to the type system for `*>' (and `exists' ?); (b) implement it; (c) profit ?
17:40:30 <fen> i am dubious about these steps
17:40:51 <nshepperd> "type"s don't exist
17:40:58 <nshepperd> type synonyms are just macros
17:41:11 <fen> no idea 
17:41:24 <ski> s/not a continuation/not a CPS-encoding/
17:41:35 <fen> type synonyms retain the original record accessors and patterns
17:41:38 <fen> thats all that desired
17:41:54 <fen> ski, yes, sry
17:42:08 <atondwal> hpc: sorry for disappearing, lost power and now I'm commuting home
17:43:16 <fen> argh, well if its just a case of writing pattern synonyms, at least it will compile...
17:43:31 <atondwal> The problem is thst the value I'm looking for is built up via a cluster of mutually recursive functions, most of which were written by other people who aren't around for me to ask anymore
17:43:32 <ski> fen : anyway, i hope you better understand the difference between providing and requiring a constraint, now. and how you can actually express both (albeit one a bit awkwardly), when you need them
17:43:41 <fen> sure
17:43:42 <fen> thanks
17:43:50 <ski> (which was the main point i wanted to get across)
17:44:25 <fen> is this idea of Provides (the datatype encoding of (*>)) and the "AddConstraint" type family appear at all useful?
17:44:31 <ski> (i'm assuming you already know about the two commonly used encodings of `exists')
17:44:32 <atondwal> So I really do want to treat ghci as a debugger; tell me what this damn value is in code I don't understand
17:44:45 <fen> bit wary of using that style in a library if its going to be unwieldy 
17:44:50 * ski isn't sure what fen intended to use `AddConstraint' for
17:45:15 <fen> covered that earlier
17:45:25 <vasiliy_san> Hi everyone. I've just tried to use `+RTS -xc` option to dump stack traces for all exceptions thrown in my program. Works great but it prints *only* stack traces without error messages. Any hints, how to print error messages together with a stack traces?
17:45:29 <fen> to "extend" Loops to Zippers, by adding constraints
17:45:43 <ski> atondwal : have you tried `trace', perhaps ?
17:45:44 <fen> this "Provides" is just supposed to be a type with added constraints
17:46:18 <fen> and "AddConstraint" is the way to keep doing this to give wrappers over types with distinct functionality 
17:46:30 <atondwal> ski: it's big enough that I don't actually want the value, I want the thunk
17:46:49 <fen> its kind of like a class hierarchy, with progressively more functionality at each subclass
17:46:57 <ski> what would you want to do with the thunk, except forcing it ?
17:47:01 <nshepperd> the only reason you can using the 'original' record accessors and patterns with c => a is because ghc gets the type class dictionary c and applies the c => a to it secretly behind your back
17:47:08 <atondwal> Heh, I'm not sure I have enough ram to print it out
17:47:23 <atondwal> Ski: force some part of it :)
17:47:29 <ski> then do so ?
17:47:45 <atondwal> In particular I want to call a function that uses it
17:47:55 <atondwal> But I don't want to have to recompile every time
17:48:24 <nshepperd> an additional pattern match or something CPSd would be necessary for c *> a to bring the constraint in scope
17:48:45 <atondwal> I just want to try it on a bunch of values instead of waiting several minutes for each build before I can decide what the next thing I'm printing is
17:49:50 <atondwal> Ghci's breakpoints *should* work here
17:49:58 <ski> not quite sure i follow. maybe you can define this thing you want to survive reloading of a module, in another module
17:50:15 <atondwal> But there's something about the do block that makes this thing go out of context
17:50:49 <atondwal> Yeah, I'm going to try and put together a minimal example on my laptop once I get power again (on my phone atm)
17:51:13 <atondwal> I guess I could link you to the actual code I'm using on github, but it's spaghetti
17:53:05 <zachk> atondwal, is the thing bound via nameOfThing <- functioToGenerateThing a1 a2 ... ? 
17:53:35 <fen> nshepperd: its not so bad to have to write pattern synonyms for the original datatype with added constraints, since thats how datatypes are normally used anyway, especially with something like (,). the important thing is being able to build a hierarchy of progressively more constraints bundled with the type, and to give each of these new record patterns
17:55:07 <atondwal> zachk: nah, it's an argument to the function (built recursively) that for some reason doesn't seem to be in scope when I set a breakpoint in the body
17:55:39 <atondwal> The body is a big do block which is why I think something strange is going on
18:02:38 <atondwal> zachk, ski: have at ye: https://github.com/ucsd-progsys/liquidhaskell/blob/3f21e54310f1e385a2111fc04922e88fa5ff2371/src/Language/Haskell/Liquid/Constraint/Generate.hs#L861
18:03:09 <atondwal> I want to be able to call this consE with gamma and whatever I wish in ghci
18:05:54 <zachk> atondwal, consE :: CGEnv -> CoreExpr -> CG SpecType , can you generate a CGEnv and a CoreExpr?
18:14:46 <fen> hmm, this way does not seem to put the constraint from the "Provides" datatype into the type signature of a function which uses it
18:15:57 --- mode: glguy set +v atondwal
18:16:11 <atondwal> man IRC does not like it when you change IPs
18:16:27 <atondwal> zachk: the problem is that constructing CGEnv is hard
18:18:09 <atondwal> it's built out of mutual recurison on the AST :)
18:21:19 --- mode: glguy set +v atondwal
18:23:28 --- mode: glguy set +v asfd
18:33:56 <koz_> How do monads form monoids again?
18:35:06 <lyxia> join :: m . m ~> m    pure :: I ~> m
18:36:01 <koz_> lyxia: Ah, I see.
18:37:10 <ski> monoid objects in the monoidal category of endofunctors (with identity and composition as the monoidal structure)
18:37:51 <koz_> I assume there isn't an instance of Monoid in existence corresponding to that?
18:38:07 <koz_> (well, either of that)
18:38:33 <ski> `Monoid' has the wrong kind
18:38:42 <koz_> Yeah, I thought as much.
18:39:12 <koz_> Since Monoid is kind Type, and that'd need to be... Type -> Type?
18:41:20 <dmwit> Yes. You'd also need a higher-kinded arrow for lyxia's ~>
18:42:00 <lyxia> well, if you're looking for a type class with join and pure, that would be Monad (modulo the fact that it actually uses (>>=) and return)
18:42:27 <koz_> (well, and the fact that join isn't in the typeclass because shenanigans, but yeah)
18:43:05 <ski> @kind Monoid
18:43:06 <lambdabot> * -> Constraint
18:43:17 <koz_> ski: Yeah, whoops.
18:43:19 <ski> @kind Monad
18:43:20 <lambdabot> (* -> *) -> Constraint
18:43:29 <koz_> What I _meant_ to say is that it must be given a type of kind Type.
18:43:48 <koz_> And here we have something of kind Type -> Type.
18:43:51 <koz_> Gotta watch my wording.
18:44:57 <ski> @let type f ~> g = forall a. f a -> g a
18:44:58 <lambdabot>  Defined.
18:44:59 <ski> @kind (~>)
18:45:00 <lambdabot> (k -> *) -> (k -> *) -> *
18:45:20 <ski> `(~>)' is a higher-order type (function)
18:45:24 <lyxia> there's also a different way to make a monoid out of a Monad (or any Applicative), via  liftA2 mappend :: m a -> m a -> m a    pure mempty :: m a
18:45:52 <lyxia> though that's not what people usually mean when they talk about monads and monoids
18:46:06 <koz_> :t liftA2 (<>)
18:46:07 <lambdabot> (Monoid c, Applicative f) => f c -> f c -> f c
18:46:12 <koz_> Huh, that's pretty neat.
18:46:19 <koz_> Oddly, this is probably _closer_ to what I thought it was.
18:46:28 <ski> @type (<|>)
18:46:29 <lambdabot> Alternative f => f a -> f a -> f a
18:46:31 <ski> @type empty
18:46:33 <lambdabot> Alternative f => f a
18:46:40 <koz_> Yeah, that's Alt.
18:46:41 <ski> @type mplus
18:46:42 <lambdabot> MonadPlus m => m a -> m a -> m a
18:46:43 <ski> @type mzero
18:46:44 <lambdabot> MonadPlus m => m a
18:47:36 <ski> @type liftA2 (,)
18:47:38 <lambdabot> Applicative f => f a -> f b -> f (a, b)
18:47:42 <ski> @type pure ()
18:47:43 <lambdabot> Applicative f => f ()
18:49:16 <fen> woop!! it compiles! https://bpaste.net/show/44b517dd1c56
18:49:54 <fen> still not happy about the ConstraintOf though...
18:50:06 <fen> plenty of patterns too..
18:51:17 <fen> but this is maybe how to do "hierarchies of types with progressively more constrained parameters"
18:55:38 <koz_> Now that I think about it, if you newtype over a -> m a and m is a Monad, you can also make a Monoid out of that using return and fish.
18:56:56 <fen> fish!?
18:56:56 <ski> fen : why not `PassS s a t => t -> Maybe s -> Loop s a t' ?
18:57:03 <koz_> fen: (<=<)
18:57:11 <koz_> Kinda looks like a fish.
18:57:13 <ski> @type (<=<)
18:57:14 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
18:57:20 <ski> kleisli composition
18:57:26 <koz_> There's also >=>
18:57:31 <fen> yeah sure
18:57:34 <fen> ok
18:57:47 <koz_> It's probably one of my favourite operator names.
18:58:11 <ski> (in fact, this is a category (the kleisli category). category is a generalization of monoid)
18:58:40 <koz_> ski: ... damn, a _jarful_ of pennies just dropped for me.
18:59:04 <fen> ski: what and have Loop as a datatype rather than a type ?
18:59:28 <ski> @type \f g -> runKleisli (Kleisli f Control.Category.. Kleisli g)
18:59:30 <lambdabot> Monad m => (b1 -> m b2) -> (a -> m b1) -> a -> m b2
18:59:39 <fen> eaier to write ConstranintOf then... 
18:59:49 <ski> fen : why ?
19:00:16 <ski> i'm just wondering what the point of using `ConstraintOf' there is
19:00:59 <fen> because then it can match the (*>) and use that type family instance for ConstraintOf
19:01:23 <ski> yea, but why would that be desirable ?
19:01:35 <fen> its just a convenience type function to retrieve the constraint
19:01:48 <fen> as thats needed by functions using (*>) things
19:01:52 <ski> why not just write the appropriate constraint explicitly ?
19:02:15 <ski> why hide it behind `ConstraintOf' and `Loop' ?
19:02:18 <fen> well, as they are composed with (*>>) they could get unmanageable 
19:02:56 <fen> after many constraints are added to a type 
19:03:11 <fen> to write them all over again
19:03:44 <fen> its because (*>) doesnt put the constraint into the type signature because its a datatype not a type synonym
19:03:57 <fen> its an artefact of that problem
19:06:01 <fen> as the (*>) constructor needs to be unwrapped to fetch the constraint, the ConstraintOf type family acts as a helper function to do that
19:10:13 <ski> i suppose you could do `type LoopCn = PassS; type ZipperCn f a = (Pass [a] a (f a),LoopCn (f a) a [a])', and then `Loop :: LoopCn s a t => t -> Maybe s -> Loop s a t' and `Zipper :: ZipperCn f a => [a] -> Maybe (f a) -> Zipper f a'
19:12:55 <fen> using (,) to compose the constraints
19:13:53 <fen> probably this is a good idea, writing the t -> Maybe .. each time, but for larger record types it might make more sense to use the fact they are just added constraints 
19:16:26 <fen> it might be good to have a WithConstraint type family but its kind is something like Constraint => ...
19:16:36 <fen> so it doesnt seem possible
19:17:59 <fen> this would be good for if several Constraied types appeared in a type signature, so they would appear as eg WithConstraint (Zipper f a) which would be the same as (ConstraintOf (Zipper f a) => Zipper f a)
19:18:31 <fen> and then they would all gather at the far left instead of having to write ConstrainedOf for each of them in the constraint
19:19:35 <fen> type family WithConstraint c  
19:19:35 <fen> type instance WithConstraint (p *> a) = p => p *> a
19:19:43 <fen> Illegal qualified type: p => p *> a
19:21:35 <fen> is that because there is no kind level => ?
19:23:01 <fen> for e.g. type family WithConstraint c :: Constraint => *
19:51:06 <koz_> Could someone help me understand how this function would actually be used? http://hackage.haskell.org/package/massiv-0.2.4.0/docs/Data-Massiv-Array.html#v:traverse I'm particularly lost vis a vis the second argument.
20:01:36 <ragusa> koz_: That function defines how to compute the result values
20:02:26 <koz_> Yeah, I gathered that, but I have no idea how the (ix1 -> e1) would be useful for anything.
20:04:06 <ragusa> It lets you lookup values in the source array
20:05:16 <koz_> I think I'm just going a bit mental here, but for some reason, I'm just not getting this thing.
20:06:25 <koz_> Like, for example, suppose I had a 1D array full of Ints, could I use this to construct a 1D array that's twice the size with Nothing on odd indices and Just x in even ones, where each x at 2i comes from index i in the 'original' array?
20:08:54 <ragusa> I think so, with \f i -> if odd i then Nothing else Just (f $ i `div` 2)
20:09:03 <koz_> Ah, OK, that makes more sense now.
21:19:03 * hackage antiope-athena 6.1.5 -   http://hackage.haskell.org/package/antiope-athena-6.1.5 (newhoggy)
21:20:33 * hackage antiope-sqs 6.1.5, antiope-sns 6.1.5, antiope-s3 6.1.5, antiope-messages 6.1.5, antiope-dynamodb 6.1.5, antiope-core 6.1.5 (newhoggy)
21:31:38 <EvanCarroll> Is there a generic functional programming chan on Freenode?
21:32:21 <EvanCarroll> If there isn't are non-haskell quesitons about FP on-topic here? Looking for the name of a generic with the signature (b->b->c) -> (a->b) => (a->a->c)
21:33:44 <jackdk> @hoogle on
21:33:44 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
21:33:44 <lambdabot> System.Glib.Signals on :: object -> Signal object callback -> callback -> IO (ConnectId object)
21:33:44 <lambdabot> Text.Regex.TDFA.Common on :: (t1 -> t1 -> t2) -> (t -> t1) -> t -> t -> t2
21:34:02 <jackdk> the first one is in base
21:34:46 <MarcelineVQ> EvanCarroll: "are non-haskell quesitons about FP on-topic here?" yes, though you may be directed to relevant channels if there are any
21:37:29 <koz_> On is a very useful function.
21:41:13 <celphi> What is the proper way to install haskall on a mac? Is it via homebrew?
21:44:03 * hackage antiope-contract 6.1.5 -   http://hackage.haskell.org/package/antiope-contract-6.1.5 (newhoggy)
21:46:54 <Arahael> celphi: Any method except homebrew, in general.
21:47:37 <Arahael> I think it's better now, but a few years back, I had to learn the hard way that homebrew's haskell was broken. :(
21:47:59 <Arahael> Stack is convenient, though.
21:56:06 <dminuoso> celphi: Haskell Platform works fine if you want a simple way, but you can simply download the package directly: https://www.haskell.org/ghc/download_ghc_8_6_1.html
21:56:33 <dminuoso> Personally I just install it manually because it's not a hassle and less pain in the long run.
21:59:25 <dminuoso> Nix is probably an option too, but that's out of my experience. :)
21:59:25 <EvanCarroll> koz_: jackdk: thanks a ton, that's exactly what I'm looking for! now I just gotta find it for Ramda.js
21:59:56 <dminuoso> EvanCarroll: Just write it yourself.
22:00:31 <EvanCarroll> dminuoso: I could easily do that, I just wanted to know if Ramda.js had a more Ramda.js-ish way to do it.
22:11:45 --- mode: glguy set +v govno
22:14:45 <celphi> how do i exit ghci lol
22:14:57 <celphi> exit and quit dont work
22:15:17 <osa1> :quit
22:15:27 <celphi> Thanks.
22:18:39 <ion> or Ctrl+D
22:27:47 <EvanCarroll> Ctrl+D is what you should use.
22:27:57 <EvanCarroll> then you'll never have to ask yourself this question again.
22:28:10 <EvanCarroll> It'll work in (most) every interactive program on Linux.
22:29:51 <jackdk> Ctrl-D is read as "end of file" , and is Ctrl-Z RET on windows IIRC
22:46:20 --- mode: glguy set +v fen
22:46:53 <fen> these benchmarks show that it does not matter if any of 3 varieties of State are used to unfold a list; https://bpaste.net/show/9944b0e4579d
22:47:35 <fen> thats; (s -> (a,s)), (s -> Maybe (a,s)) or (s -> (a,Maybe s)) 
22:49:44 <trcc> Anyone familiar with Waargonaut? I am reading in two json objects from different files and I want to combine them into one. There are no overlapping names. I cannot figure out how to define the parseFn, but I expect to use this: unDecoder json parseFn (mkCursor somebytestring)
22:51:14 <fen> this means that (s -> (a,Maybe s)) can be used for both Lists and NonEmpty Lists, and will be as fast with NonEmpty lists as for Lists. because the "SafeState" approach can be used for both without performance penalty, both types, which are "Linear" can be unfolded (and traversed) using the same approach, as shown in the paste
23:02:39 <fen> the approach taken is to return undefined, and match on the last value instead of the empty list, reconstructing using const to dispense of this undefined value. the benchmarks in the paste show this to be equivalent to matching on Empty instead. 
23:04:41 <fen> because the SafeState / Linear approach using undefined and const can be used for both List and NonEmpty, it means that the Linear class and the safeState loop can be used to unify the approach to traversal over linear recursive datatypes regardless of if they have an Empty constructor
23:19:17 <maerwald> lool, cannot cancel latest cabal anymore
23:19:20 <maerwald> it just keeps running
23:29:12 <maerwald> and it now reports putting stuff into directories that don't exist
23:29:26 <maerwald>  /home/maerwald/.cabal/store/ghc-8.4.4/incoming/new-20073/home/maerwald/.cabal/store/ghc-8.4.4/haddock-library-1.7.0-bea6fb627852722a31ad28ba150ff04c38f15a66966b81469a4417c6976b9146/lib
23:29:31 <maerwald> new-20073 doesn't even exist
23:31:48 <maerwald> it also rebuilds everything now, although new-update has not been used
23:32:11 <MarcelineVQ> I​ have a similar issue, where it then it tries to use the non-existent things and dies
23:32:32 <maerwald> it seems those are temporary directories of some sort
23:33:07 <maerwald> I don't even want to know what's going on there
23:44:04 * hackage expiring-containers 0.2.2.1 - Expiring containers  http://hackage.haskell.org/package/expiring-containers-0.2.2.1 (NikitaVolkov)
23:51:10 <bahamas> hi. this is not haskell specific, but more about software development in general. if I wanted to automatically translate some source code from one language to another, how would I go about it? at the AST level?
23:55:10 <bahamas> I have the feeling it's a question that, if I have to ask it, I don't know enough to do it :)
23:55:50 <sshine> it seems that Data.Text doesn't have an `elem` function. is there anything other than `T.any . (==)`?
23:57:23 <koz_> bahamas: That's what a compiler does.
23:57:32 <koz_> So the answer is 'write a compiler'. :P
23:57:54 <koz_> sshine: Are you looking to do string matching or something?
