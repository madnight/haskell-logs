00:14:42 <muesli4> hi, is there some way I can enable profiling just for the current executable/library? Is this also possible from cabal?
00:14:54 <muesli4> i.e. via repl
00:39:52 <syniseth> How can I do something like sum List / length List, it won't let me: "No instance for (Fractional Int) arising from a use of ‘/’".
00:41:07 <opqdonut> > let xs :: [Int]; xs = [1,3,3] in fromIntegral (sum xs) / fromIntegral (length xs)
00:41:09 <lambdabot>  2.3333333333333335
00:41:19 <opqdonut> :t fromIntegral
00:41:21 <lambdabot> (Num b, Integral a) => a -> b
00:42:09 <koz_> syniseth: For this particular use, I would also recommend the foldl package, as it means you can do that computation in one pass over the list instead of two: http://hackage.haskell.org/package/foldl-1.4.5/docs/Control-Foldl.html
00:51:55 --- mode: glguy set +v onions
00:52:15 <onions> Learn you a Haskell!
00:52:38 <koz_> onions: For Great <s>Justice</s>Good?
00:52:43 <devoid_> is prolog worth learning?
00:53:25 <aldum> the greater good
00:53:27 <onions> koz_: For more good!
00:53:54 <onions> I had my eyes set towards Scheme devoid_
00:54:05 <onions> fwiw 
00:54:11 <opqdonut> prolog is worth learning definitely
00:54:32 <opqdonut> not necessarily worth using, as such, but you might find logic programming libraries for other languages more useful after studying some prolog
00:54:34 <devoid_> wow hi aldum, how are you doing today?
00:55:17 <onions> slap onions
00:55:27 <onions> Be back later!
00:55:35 <onions> Have to slap more onions
00:56:34 <yaxu> Hi all, I'm looking for feedback on my representation of pattern here https://slab.org/tidal-1-0-0-refactor/
00:56:46 <yaxu> all feedback + criticisms much appreciated
01:02:03 * hackage fuzzyset 0.1.0.8 - Fuzzy set for approximate string matching  http://hackage.haskell.org/package/fuzzyset-0.1.0.8 (arbelos)
01:14:33 * hackage docusign-base-minimal 0.0.1 - Low-level bindings to the DocuSign API (only what is necessary for docusign-client)  http://hackage.haskell.org/package/docusign-base-minimal-0.0.1 (maerwald)
01:30:28 <maerwald> does genericToJSON has a higher memory footprint than TH?
01:37:04 * hackage docusign-client 0.0.2 - Client bindings for the DocuSign API  http://hackage.haskell.org/package/docusign-client-0.0.2 (maerwald)
01:41:56 <tsahyt> is there some variant of sortBy that I can use with a partial ordering?
01:42:42 <merijn> tsahyt: What should happen for uncomparable elements?
01:43:23 <Solonarv> maerwald: if inlining works correctly, they should generate the same code AFAIK
01:44:14 <maerwald> Solonarv: I was asking about memory footprint of compilation
01:44:52 <Solonarv> oooh, compile-time memory footprint? No idea then
01:45:10 <tsahyt> merijn: I might need to rethink this
01:47:10 <tsahyt> merijn: what I have is a list of list of nodes in a directed graph, which represent components that go together. now when there's an edge with a special label from any node in one component to any node in another, I know that the first must precede the second. in the end I'm looking for some way to walk through these components such that this ordering is observed.
01:47:20 <tsahyt> so I thought I could just sort them somehow
01:47:26 <tsahyt> but the order is of course partial
01:47:36 <koz_> tsahyt: Ever heard of a graph linearization?
01:47:43 <koz_> It sounds like this is what you want.
01:47:58 <tsahyt> I don't think I have
01:48:08 <Solonarv> "topological sort" might also be a useful search term
01:48:35 <koz_> tsahyt: https://en.wikipedia.org/wiki/Topological_sorting
01:48:38 <koz_> It gives three algorithms.
01:48:53 <tsahyt> ahh
01:49:01 <tsahyt> yes a topological sort seems to be what I want
01:49:14 <tsahyt> fgl supports it too, so that's nice. I'll just build a graph out of my graph then :)
01:49:15 <koz_> The parallel one is the cutest.
01:49:57 <tsahyt> thanks for the help!
01:50:21 <Solonarv> I have created a horror.
01:50:21 <Solonarv> https://github.com/Solonarv/hoo-fancy/blob/master/src/Hoo/Cls.hs
01:52:38 <koz_> Solonarv: 'hoo' is an interesting name.
01:53:06 <Solonarv> :D
01:53:31 <Solonarv> This is what happens when I listen to fen talking about Haskell being OO.
01:53:47 <koz_> Solonarv: Although I assume it's meant to be pronounced 'eitch-oh-oh'?
01:54:01 <Solonarv> nope, "hoo" is correct
01:54:11 <Solonarv> as in "hoo boy"
01:54:18 <Solonarv> which was my initial reaction
01:54:18 <koz_> Lol.
01:54:51 <koz_> This means, by law, the next attempt at this will be named 'wat'.
01:55:01 <merijn> tsahyt: Oh, you just want a pre-order or post-order traversal for a DAG?
01:55:18 <merijn> But yeah, topological sort is what you want
01:55:34 <Solonarv> I honestly don't know how much I'll do with this
01:55:46 <Solonarv> the amount of type-level hackery is scaring me a bit
01:56:03 <Ke> if it's a dependency network, you want to optimize path of blame
01:56:30 <Ke> or slowest path
01:56:59 <koz_> Solonarv: It doesn't seem too bad, but maybe I'm just desensitised.
01:57:09 <koz_> After trying to write typelevel sizing wrappers for massiv.
01:57:17 <Solonarv> Hah, fair enough
01:57:47 <Solonarv> the other question is: who would even use this? I don't think I will!
01:59:31 <merijn> hmm, you only need S to build all of SKI, right? Or am I misremembering?
01:59:50 <Solonarv> you need K as well, IIRC
02:00:00 <koz_> Yep, because I = S K K
02:00:05 <Solonarv> I can be replaces with SKx (for whatever x)
02:00:29 <merijn> Solonarv: I recall there being a string to get away with only 1 combinator
02:00:42 <Solonarv> there /is/ a single-combinator calculus: the ι-calculus
02:01:28 <mniip> merijn, U = \f -> f S K
02:01:44 <mniip> it doesn't work out in simply typed LC though
02:04:29 <asheshambasta> Hi! I'm using Scotty to make a sort of a proxy between the client and S3.  Basically, the client makes a request to get something and I want to be able to respond back chunked parts of the object in S3, which can potentially be very large.  I've looked at wai-conduit that creates raw Wai Requests from Conduits but I cannot see how to wire that with Scotty. Scotty, AFAIK, provides no way to set a raw Wai Response, correct?
02:05:24 <asheshambasta> Scotty has  `stream` but that seems to expect a Wai StreamingBody, which has me stumped. 
02:09:33 <Solonarv> In the course of this experiment I've found that vinyl is an amazing library
02:13:30 --- mode: glguy set +v fen
02:13:37 <fen> can an array be indexed by a Tree?
02:14:55 <Solonarv> depends on the exact array and the exact tree
02:14:59 <Solonarv> in principle, yes
02:15:12 <fen> a rose tree
02:15:31 <fen> Free NonEmpty
02:16:00 <Solonarv> I think you meant: Cofree []
02:16:17 <Solonarv> (it's possible that's the same thing, but Cofree [] is clearer IMO)
02:16:45 <fen> hmm, it should only have values at the leaves 
02:17:00 <fen> the Cofree version has values at the branches 
02:17:03 <Solonarv> Oh, I see. Hmm.
02:17:40 <Solonarv> I can't immediately think of how the indexing would work, but I don't see a compelling reason for it to be impossible
02:17:55 <fen> the problem seems to be with the bounds
02:18:00 <fen> :t range 
02:18:02 <lambdabot> Ix a => (a, a) -> [a]
02:18:11 <Solonarv> Yep, that was my thought
02:19:22 <fen> it would mean the shapes of the trees would have to have an order... and thats totally the wrong idea
02:19:51 <fen> the point is that a Pointer over Tree () serves as an Index for Tree ()
02:20:21 <fen> :t inits
02:20:22 <lambdabot> [a] -> [[a]]
02:20:30 <fen> > inits [1,2,3]
02:20:32 <lambdabot>  [[],[1],[1,2],[1,2,3]]
02:20:49 <fen> > inits [(),(),()]
02:20:51 <lambdabot>  [[],[()],[(),()],[(),(),()]]
02:21:03 * hackage Win32 2.8.2.0 - A binding to Windows Win32 API.  http://hackage.haskell.org/package/Win32-2.8.2.0 (TamarChristina)
02:21:53 <fen> so partially traversing the Tree like a zipper, the stored list of passed values corresponds to positions in the tree
02:22:01 <fen> maybe thats the ordering?
02:22:37 <fen> (the wrong ordering is trying to order all possible shapes, this just orders the various truncations of the overall tree)
02:22:56 <Solonarv> that sounds vaguely reasonable
02:23:35 <fen> if it were a binary tree it would be [Bool]
02:23:46 <fen> for a rose tree its [Int]
02:24:28 <Solonarv> yes, you can certainly index /into/ a tree
02:24:28 <fen> for the example over [] above its Int
02:25:08 <fen> well, its just converting Tree () into a [Int] that correponds to the shape of the "subtree" 
02:25:53 <fen> the problem with the inits approach for sequentially less truncated trees is that they would follow the order of traversal
02:26:25 <fen> so that there would be lots of indexing over branches that dont correspond to the path take to the indexed value
02:26:29 <fen> would that slow it down?
02:27:13 <fen> sorry, its not [Int] for rose tree
02:27:29 <fen> its something far more complicated
02:28:16 <fen> best just to think about Tree () for now. possibly Tree Int corresponds to a one dimension less hypertree... but thats just crazyness
02:29:13 <fen> (c.f. higher dimensional trees algebraically) 
02:29:45 <fen> still unsure about the Ix instance...
02:29:53 <fr33domlover> Is there a (TH) Lift instance for Data.List.NonEmpty? I can't find one. Perhaps it should be added to the template-haskell package?
02:32:52 <fen> maybe if its being traversed to get the subtrees it would be equivalent to just index these using Int corresponding to the order they appear in the traversal
02:34:25 <fen> but the idea of being able to cast the Pointer over `Tree a' to a Pointer to the same location of `Tree ()' and use this as an index for an Array of the Pointers to each location seemed quite nice
02:35:54 <fen> that would be, rewinding the zipper over the tree navigated to that position having discarded the remainder 
02:38:03 <fen> maybe the dimension lower Tree Int index would save navigating the wrong branches unnecessarily. this could be viewed as something like being able to skip a bunch of Int indexes for the version using order of traversal
02:38:35 <fen> not sure if this corresponds to a less expensive Array access...
03:02:36 <Solonarv> oh, fen: last night spawned this: https://github.com/Solonarv/hoo-fancy/blob/master/src/Hoo/Cls.hs
03:12:02 <fen> what is this?
03:13:07 * fr33domlover just created his first GHC trac ticket ^_^
03:13:51 <Solonarv> what's it look like? an OO-like class/object system in Haskell! :V
03:16:35 <fen> does it use any good coding principles?
03:18:01 <fen> oh damn, it uses TypeLits
03:19:02 <Solonarv> It's rather type-safe, so that's one thing
03:19:38 <fen> are there some function names as types?
03:21:00 <fen> method name as part of a kind!?
03:21:09 <fen> argh
03:21:45 <Solonarv> heh
03:22:09 <Solonarv> method and field names are present at the type level, yes
03:22:13 <fen> why use Symbols?
03:22:27 <Solonarv> because they're type-level strings
03:22:41 <fen> thats what they are, not why use them
03:22:49 <Solonarv> how else am I going to represent "a method named 'foo' " at the type level?
03:23:03 <Solonarv> I need to represent method/field names somehow, you know! :P
03:23:03 <fen> again, the question isnt how, its why
03:23:39 <Solonarv> Why represent method/field names at all?
03:23:49 <fen> to use them as values
03:24:06 <fen> to write programs with them
03:24:10 <Solonarv> I don't want to have the names exist only at the value level
03:24:19 <fen> why?
03:24:27 <Solonarv> If they exist only at the value level, they can't be checked at compile time
03:24:38 <fen> thats what types are for
03:24:50 <Solonarv> Yes, exactly. Which is why I'm putting the names in the types.
03:24:55 <fen> nono
03:25:03 <fen> the types of the values, not the values
03:25:28 <fen> a value and its type are different things, not confusing that the value is now also at type level
03:25:55 <fen> why is type checking now value checking?
03:26:01 <Solonarv> It isn't.
03:26:22 <fen> why check the values at type level during compilation?
03:26:34 <Taneb> What values are being checked?
03:26:38 <Solonarv> I use Symbol to represent field/method names, because that way I can get "that field does not exist" errors at compile time
03:26:56 <fen> Taneb: it has the *names* of the functions being typechecked 
03:27:19 <fen> thats not typechecking!
03:27:20 <Solonarv> Taneb: I'm writing an OO-ish library and fen is confused about my use of Symbol. Link here: https://github.com/Solonarv/hoo-fancy/blob/master/src/Hoo/Cls.hs
03:27:21 <Taneb> fen: in the model Solonarv is trying to make, the names of the function are part of the specification of a "Class"
03:27:30 <Taneb> Solonarv: I saw briefly earlier
03:27:51 <Taneb> (Class in roughly the Java sense, I presume)
03:28:02 <Solonarv> Yes, that's right.
03:28:16 <Solonarv> Except there won't be inheritance - that's the tool of the devil!
03:28:24 <fen> yeah, but when you piece together functions of the correct type (thats what you want the typechecker to check) it shouldnt care about the name of the function
03:28:56 <Solonarv> fen: the names are overloaded
03:28:59 <fen> why?
03:29:01 <Taneb> So Solonarv can now maybe generalize over 'objects with a method called "foo" with this type'
03:29:13 <Solonarv> yes, or simply notational convenience
03:29:13 <fen> why?
03:29:18 <Taneb> Fun
03:29:22 <Solonarv> ^
03:29:22 <fen> !?!?
03:29:25 <fen> its madness
03:29:35 <Solonarv> exactly! :D
03:29:43 <fen> sigh
03:29:59 <fen> your breaking everything
03:30:05 <Solonarv> I'm not breaking anything
03:30:29 <Solonarv> Look at basically any extensible records library and you'll see the same Symbol stuff
03:30:36 <Taneb> fen: this is not anything you will ever have to use
03:30:45 <fen> if there was some communicated motivation for doing so...
03:31:00 <fen> Taneb: its not something anyone would ever want to use?
03:31:08 <fen> maybe it has good reason for doing this
03:31:16 <fen> maybe we will never know
03:31:29 <Solonarv> This library is not something *I* am intending to use, and I'm writing it!
03:31:31 <Taneb> fen: "seeing if it works" is sometimes a good idea for seeing if something works
03:31:47 <fen> of course it works!
03:31:50 <Taneb> The only thing it costs is Solonarv's time
03:31:59 <fen> thats what all this KnownSymbol stuff is for
03:32:02 <fen> just not sure why
03:32:23 <Solonarv> As for the type-level string stuff... This is going to sound condescending, but just because you haven't seen it used this way before doesn't mean it's nonsense
03:32:33 <fen> only possibly to be at some low level in the compiler, far far away
03:33:11 <fen> Solonarv: its used more and more commonly, in many different ways
03:33:20 <fen> and sure there will be motivations in each setting
03:33:58 <fen> basically just presuming this creation has some reason for being devised 
03:34:18 <nkaretnikov> hi! i'm looking for a simple pure-Haskell regex library. i really like regex-applicative, but i'm not sure how to parse something like an ip address with it as the applicative interface doesn't allow sequencing. is it impossible or am i overlooking something? alternatively, i'm willing to consider a parser combinator library with a monadic interface if it's lightweight and maintained. bonus points if it has a string
03:34:18 <nkaretnikov> interface, not text.
03:34:39 <fen> "oh look, this new tool can do this and that, how marvellous" - not just, this is crazyness but it works!
03:35:42 <fen> the question is about where it is useful to have a functions name at type level
03:36:00 <fen> about how this can be understood as a good idea
03:37:37 <Solonarv> If it helps: it's not a function name, it's a field label
03:37:43 <Solonarv> Seriously, look at vinyl
03:37:50 <Solonarv> it's doing most of the heavy lifting here
03:38:04 <fen> its not just that it seems to be a bad idea
03:38:18 <fen> its not just that it seems to be a bad idea
03:38:20 <fen> extensible records are one thing
03:39:13 <Solonarv> A class is simply a record of methods, and a record of field initializers. An object is a pointer back to its class, and a record of fields. It's actually quite simple.
03:39:58 <Solonarv> Making these records extensible means I can provide general operations to make the syntax less of a pain.
03:40:02 <fen> finally
03:40:21 <Solonarv> ...and I get really powerful casts out of it, too
03:40:44 <fen> whats that?
03:40:50 <nkaretnikov> https://github.com/feuerbach/regex-applicative/wiki/Examples nevermind
03:41:13 <Solonarv> refresh the page, look for 'as'
03:41:25 <tsahyt> nkaretnikov: alternatively, this is in base https://hackage.haskell.org/package/base-4.12.0.0/docs/Text-ParserCombinators-ReadP.html
03:41:35 <tsahyt> for some reason people just overlook it
03:42:33 <tsahyt> it's lightweight in the sense that it doesn't have any dependencies you don't already depend on anyhow
03:42:53 <tsahyt> dunno how well it performs, but I imagine for parsing an IP address from a string it should suffice
03:43:41 <fen> so you can retrieve the actual class as a value from some "object"
03:44:26 <tdammers> there has been a general tendency of making Haskell more expressive at the type level
03:44:40 <fen> or is that, changing the class of an object?
03:44:43 <fen> confused
03:45:06 <fen> tdammers: apparently we now have object oriented languages at type level
03:45:29 <Solonarv> The cast changes the class of an object, yes.
03:46:04 <fen> Solnarv: so wheres the type level (=>) ?
03:46:07 <Solonarv> fen: That's wrong, the OO language is value-level. It just uses type-level programming to increase safety and notational convenience
03:46:19 <tdammers> fen: haven't played with vinyl yet, but my understanding is that if anything, it uses type-level programming techniques to get us typesafe object-oriented programming at the term level
03:46:20 <Solonarv> ...what's a type level (=>) ?
03:46:40 <Solonarv> I wouldn't call vinyl OO, but the rest is about right.
03:46:56 <tdammers> depends which definition of "OO" you use
03:47:00 <tdammers> I don't think it matches mine
03:47:33 <Solonarv> Oh did you mean my library? In that case, yes, that's exactly what I'm doing.
03:48:46 <fen> thought they were just broken records 
03:49:10 <tdammers> "broken"?
03:49:47 <tdammers> my conclusion so far was that the mental overhead of the whole machinery is probably not going to pull its weight for most applications, but I haven't found anything that I would consider broken
03:50:01 <fen> Solnarv: for type level Dicts and an imlpementation of ski's *> that puts the constraint to the lhs where it belongs for constrained type synonyms 
03:50:49 <Solonarv> Oh, that's what you meant. Why would I need that?
03:51:33 <fen> to obtain inheritance for hierarchical types
03:51:47 <fen> extensible type constraints
03:51:57 <fen> constrained types*
03:52:24 <Solonarv> I don't want inheritance anyway
03:52:36 <fen> impredictive polymorphism is it called?
03:52:41 <Solonarv> Maximally liberal casts are good enough for me
03:53:06 <merijn> Forget about impredicative polymorphism, it won't help you ever
03:53:22 <fen> what about algorithmic class reformulation?
03:53:37 <Solonarv> the casting rules are: you can cast an 'Object fs1 ms1' as a 'Class fs0 ms0' whenever fs0 is a subset of fs1
03:53:45 <fen> merijn: it would be very useful 
03:54:01 <tdammers> inheritance in itself isn't difficult to implement
03:54:17 <fen> e.g. extending the get/set class to geti/seti
03:54:28 <tdammers> it gets slightly more involved when you want "open recursion" (methods calling back into their owning object, resolving by the correct runtime vtable)
03:54:57 <tdammers> and it gets completely messy when you want the combo of open recursion, multiple interfaces, and mutable fields
03:55:00 <fen> as one parameter extensions are maximal generalisations - encoding functions by index values
03:55:01 <Solonarv> Yeah I'm not doing that :P
03:55:34 <Solonarv> I have mutable fields and multiple interfaces (sort of)
03:55:41 <WilliamHamilton[> hi, I have a problem with the package `hmatrix-special`, which I need to compute some bessel functions: `can't load .so/.DLL for: ... undefined symbol: gsl_sf_legendre_array_size`. It seems related to this issue https://github.com/paulrzcz/hquantlib/issues/24
03:55:43 <fen> runtime class generation?
03:55:57 <tdammers> once you want all three, you tend to end up with something that inherits (pun intended) all the troubles that plague existing OOP languages
03:56:19 <fen> tdammers: can that be understood somehow?
03:56:41 <tdammers> fen: what do you mean?
03:57:04 <fen> this conflict and these problems intrinsic to OOP languages
03:57:09 <fen> for those unfamiliar 
03:57:41 <fen> multiple interfaces is what exactly?
03:58:16 <tdammers> oh, just being able to manipulate the same object through multiple interfaces, and having the manipulations be "seen" through all other interfaces
03:58:53 <tdammers> say you have an object that implements get/setArea and get/setDimensions through two separate interfaces
03:59:06 <tdammers> now you cast it to the Area interface, change the area through setArea
03:59:27 <tdammers> and you also cast the object to the Dimensions interface, and read back the updated dimensions after you have changed the area
03:59:48 <tdammers> this requirement essentially rules out any approach that models updates as Object -> Object
04:00:21 <fen> urgh
04:00:44 <tdammers> but oh dear, now that you are storing your object state in MVars or TVars or whatever, you need to go through the corresponding Monad (IO or STM) for *all* state access
04:01:08 <tdammers> so all purity guarantees essentially go out the window, and you're stuck in imperative land
04:01:43 <fen> and they call this a paradigm?
04:02:03 <tdammers> sure
04:02:12 <tdammers> part of the paradigm is not restricting side effects
04:02:49 <fen> das ist verbotern 
04:04:15 <fen> this is exactly why Scala is bad
04:04:38 <fen> giving the option to break purity is very very bad
04:06:47 <fen> imperative and OO and impure seem synonymous 
04:07:12 <fen> generally mutable values are also bad
04:08:07 <fen> but some things demand it, such as strict thread control for parallel and concurrent programing
04:08:11 <fen> so its not all bad
04:08:37 <fen> just so long as it happens under the hood
04:08:59 <quchen> My microcontroller does not enjoy running GHC’s runtime.
04:09:06 <fen> a lazy pure immutable interface is a really serious powerful thing
04:09:29 <tsahyt> quchen: wasn't idris designed with embedded applications in mind?
04:09:45 <quchen> tsahyt: It’s one of the long-term goals of Edwin, yes.
04:09:56 <tsahyt> quchen: does it work already?
04:10:18 <quchen> But saying »mutability is bad« is a bit of a close-minded statement.
04:10:32 <quchen> tsahyt: Not sure, you’d have to ask in #idris.
04:10:51 <tsahyt> okay
04:11:56 <quchen> But then Idris is a research language that has this as one of its goals – a practical dependently typed strict language for general purpose programming, with the hope it’ll be useful for low-level stuff
04:12:09 <quchen> Where low-level probably means soft real time low level
04:12:45 <quchen> Not sure how hard real time would fare with anything highlevel. But then again I’m out of my depth here.
04:13:10 <fen> quchen: sure, but the point is that it upsets a pure environment, but that such might rest on top of a backend based on mutable machinery basically makes it a necessity. the point is more about the interaction between these two worlds 
04:14:14 <tsahyt> quchen: I've only used idris when working through Edwin's book. My main takeaway was that dependently typed programming is very cool but can be frustrating at times, when it requires you to prove obvious things to the compiler
04:14:42 <quchen> believe_me is your friend in this case!
04:14:55 <quchen> It’s unsafeCoerce, but it’s much more useful in dependently typed languages.
04:15:00 <fen> maybe there is a similar comment with when use of Symbol and other TypeLits stuff encroaches on an otherwise orderly codebase 
04:15:10 <tsahyt> I've tried to use Haskell as well while I was reading this book, and it was also painful, though for different reasons
04:15:21 <quchen> And Idris isn’t very strict on enforcing proofs anyway, luckily. Agda is a total hardass.
04:15:38 <tsahyt> maybe I should give it another shot
04:18:00 <quchen> Haskell? Or Idris
04:18:05 <trcc> I am trying to lift ++ into Either. And I thought I could just do: pjson1 (liftA2 ++) pjson2  where both pjson1 and pson2 are Either . However, I cannot. What am I missing?
04:18:23 <quchen> trcc: You’re missing parentheses, (liftA2 (++))
04:18:35 <quchen> (liftA2 ++) == \x -> liftA2 ++ x
04:18:42 <quchen> That’s a section of the (++) operator
04:18:51 <tsahyt> quchen: idris
04:19:12 <tsahyt> quchen: my dependent type faking skills in haskell have also improved in the meanwhile, so perhaps I should try the exercises again in both
04:19:26 <trcc> (liftA2 (++)) pjson1 pjson2  gives me: variable not in scope, liftA2. I have imported Data.Either
04:19:38 <tsahyt> speaking of which, there's now a book on type level programming iirc. I should work through that
04:19:56 <quchen> trcc: And you can’t use expressions as infix (like you can in Scala, I think). One way to write your function would be »liftA2 (++) pjson1 pjson2«.
04:20:19 <v0d1ch> tsahyt: http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:liftA2
04:20:31 <trcc> still gives me variable not in scope: liftA2. I have imported Data.Either
04:20:34 <trcc> quchen: 
04:20:42 <quchen> trcc: liftA2 is in Control.Applicative
04:20:44 <trcc> §ahh
04:20:46 <trcc> thank you!
04:21:02 <quchen> It’s not specific to Either; rather, (Either a) is one Applicative, but there are many others
04:21:40 <tdammers> fen: "imperative and OO and impure see synonymous": absolutely not
04:22:03 * hackage hopenssl 2.2.3 - FFI Bindings to OpenSSL's EVP Digest Interface  http://hackage.haskell.org/package/hopenssl-2.2.3 (PeterSimons)
04:22:29 <quchen> Imperative and OO are just as synonymous as immutable and FP
04:22:54 <tdammers> imperative implies a certain degree of impurity
04:22:55 <quchen> You can have immutable OO, mutable FP, imperative FP, and all other combinations
04:23:11 <tdammers> but "impure" doesn't imply "imperative"
04:23:37 <tdammers> and if you squint enough, you can even come up with imperative code that is still free of side effects
04:23:39 --- mode: glguy set +v ejt
04:23:54 <tdammers> OO doesn't imply any of that either
04:24:23 <fen> concurrent updates and blocking coms is confused here with top down basic style code execution. sry
04:24:55 <fen> delirious from trying to read Solonarvs code
04:25:25 <tdammers> anyway, mutability is kind of inevitable in the real world, the interesting question is how we manage mutations to avoid common problems in the wild
04:25:51 <quchen> You can have objects in Haskell – just write a tuple that has components that expect itself as an argument and returns new versions of itself.
04:26:06 --- mode: glguy set -v ejt
04:26:25 <Solonarv> fen: don't worry, I'm delirious too.
04:26:36 <tdammers> quchen: yes, that's one of the popular approaches, but it's also one of those that doesn't give you the holy trinity of open recursion, updates, and multiple interfaces
04:26:37 <Solonarv> Currently trying to figure out why this damn type family is stuck
04:26:44 <ejt> hi, I'm coming back to Haskell after an ~8 year break.  Is hoogle still the best place to look up library functions?
04:27:02 <quchen> ejt: Hoogle and Hayoo, yes
04:27:28 <ejt> quchen: thx
04:27:45 <ejt> anything obviously changed in the Haskell world? (I think the Lens library is new)
04:28:02 <fen> @let type EgObject = (EgObject -> EgObject,Int)
04:28:04 <lambdabot>  .L.hs:162:1: error:
04:28:04 <lambdabot>      Cycle in type synonym declarations:
04:28:04 <lambdabot>        .L.hs:162:1-43: type EgObject = (EgObject -> EgObject, Int)
04:28:22 <quchen> Cabal has come a long way, there’s Stack as an alternative (built ontop of Cabal), and umm yes lots of things changed since 2011 :-D
04:28:45 <quchen> Applicative is now a superclass of Monad ♥
04:28:53 <quchen> Foldable is in Prelude
04:29:23 <ejt> (Applicative) makes sense
04:29:32 <fen> still waiting for type level GHC and a lazy type familes
04:29:38 <tdammers> also Semigroup-Monoid
04:30:30 <quchen> 2011 was GHC 7.2? 6.12?
04:30:30 <fen> and some replacement of the defunctionalisation debauchery 
04:31:26 <ejt> 7.2
04:31:39 <fen> ejt: UndecidableSuperclasses!
04:32:12 <tdammers> DerivingVia!
04:32:35 <tdammers> also a truckload of baby steps towards dependently-typed Haskell
04:32:54 <fendor> good morning, given I have a datastructure that does not implement NFData, how can I evaluate fully evaluate it, before storing it into a `IORef (Maybe a)`, where a is my datastructre?
04:33:01 <quchen> And colored error messages. Don’t forget about that one.
04:33:14 <tdammers> that's probably the biggest change of all :P
04:33:17 <quchen> fendor: Write an instance of NFData? :-x
04:33:18 <merijn> fendor: Eh, add an NFData instance? :)
04:33:37 <ejt> hmm, looks like ghc has moved on a lot
04:33:53 <merijn> You can even derive generic, then use the Generic instance of NFData if you're lazy
04:34:22 <tdammers> ejt: it has, but there are surprisingly few breaking changes - Functor / Applicative / Monad and Semigroup / Monoid are probably the most important ones
04:34:47 <quchen> > instance NFData Foo where rnf = rnf . show -- :-D
04:34:49 <lambdabot>  <hint>:1:1: error: parse error on input ‘instance’
04:35:38 <ejt> tdammers: I used to use Applicative for everything, so if that's changed my old code will need updating
04:35:57 <quchen> ejt: Does it? It should just work
04:36:04 <ejt> if ...
04:36:12 <merijn> ejt: Applicative hasn't changed, it's just been made a superclass of Monad
04:36:18 <ejt> fine
04:36:20 <merijn> ejt: So you can generalise simplify a lot of code now
04:36:39 <quchen> You can replace a lot of liftM with fmap now
04:36:50 <merijn> ejt: i.e. before you had to do "foo :: (Applicative m, Monad m) => ..." if you used both <*> and >>=
04:36:59 <ejt> y
04:37:07 <merijn> ejt: Now you can just do "foo :: Monad m => ..." since Monad requires Applicative
04:37:37 <fendor> quchen, merijn, I tried that but it threw some errors for newtypes: https://hastebin.com/uyonefifah.coffeescript
04:38:18 <merijn> fendor: No, don't use DeriveAnyClass there...
04:38:29 <merijn> fendor: That's just going to derive an empty NFData for you
04:38:48 <merijn> fendor: You derive generic, then write "instance NFData Frequency"
04:39:10 <fendor> forgot to add the error message: https://hastebin.com/bacuwosita.bash
04:39:12 <merijn> fendor: NFData has a default implementation using Generic, so if your datatype implements generic you don't actually have to write an implementation
04:39:24 <fendor> merijn, ok, ill try
04:40:03 <merijn> oh, wait that's using "deriving newtype" I have no clue how that affects things...
04:43:10 <fendor> merijn, oh, forgot about that
04:43:34 <Bish> how would the haskellers tackle the following: 69 days sind how much month, weeks,days (considerung length(month) = 30)?
04:44:03 <Bish> s/sind/are
04:44:07 <Bish> stupid brain
04:44:20 <fendor> so this compiles, merijn, but you said, that I should not autoderive it? https://hastebin.com/golupukuvu.coffeescript
04:44:25 <tdammers> Bish: for your simplified 30-day-month calendar, quotRem; for actual calendar, Data.Time
04:44:42 <merijn> That derives?
04:44:42 <tdammers> the "time" library, that is
04:44:48 <merijn> Even without DeriveAnyClass?
04:44:51 <merijn> That doesn't seem right
04:45:02 <Bish> tdammers: well i was interested in a iomplementation
04:45:11 <tdammers> right
04:45:34 <tdammers> so you take the input and apply quotRem 30 to get the number of months and the remaining days
04:45:40 <Bish> because i wrote this in ruby right now, and tried it without having mutability and i find it overly complicated while being a simple problem
04:45:47 <tdammers> then you quotRem the remaining days to get weeks and days
04:45:49 <fendor> merijn, yeah, it compiles
04:46:09 <Bish> ohh, quotRem was a function
04:46:16 <merijn> fendor: I suspect you somehow/somewhere have other extensions enabled
04:46:55 <fendor> merijn, right, DerivingStrategies, GeneralizedNewtypeDeriving
04:46:55 <tdammers> > let (months, remainingDays) = 69 `quotRem` 30 in let (weeks, days) = remainingDays `quotRem` 7 in (months, weeks, days)
04:46:57 <lambdabot>  (2,1,2)
04:47:06 <Bish> thanks, exactly what i wanted
04:47:35 <tdammers> using mutable variables for this would be idiotic
04:48:19 <merijn> fendor: Asking people to debug a paste like that without relevant information like that is...less than helpful. Anyway, with GND enabled it's just copying the NFData for Double (which is probably fine), but that makes the entire Generic deriving pointless
04:48:20 <Bish> tdammers: well, ruby lacks quotRem
04:48:53 <tdammers> Bish: ruby also lacks explicit mutability management
04:49:34 <Solonarv> ah-ha! I un-stuck my type family
04:49:39 <Solonarv> onwards, to method invocation!
04:51:25 <fendor> merijn, true, it was a mistake, it was not on purpose, I am sorry to make it harder for you to help! why does it make the Generic deriving pointless?
04:52:29 <merijn> fendor: The reason to derive Generic to get NFData is to use the "default" Generic implementation in your instance, but if you GND derive NFData directly anyway, that becomes moot
05:01:57 <nkaretnikov> tsahyt: I’ll try trifecta as it’s written by ed. Turns out I like good error messages and Nothing is not enough.
05:04:30 <fendor> merijn, but dont I still need the Generic instance?
05:05:00 <merijn> Depends if you need it for anything else...
05:06:33 <hpc> will the next good parsing library be written by sed?
05:08:03 --- mode: glguy set +v rich18
05:11:07 <ragusa> I already have the perfect name for that: "parsed"
05:11:53 <tsahyt> nkaretnikov: there's also megaparsec of course, which allegedly performs very well now
05:12:33 * hackage mixpanel-client 0.1.1 - Mixpanel client  http://hackage.haskell.org/package/mixpanel-client-0.1.1 (domenkozar)
05:46:39 * hackage json-alt 1.0.0 - Union 'alternative' or Either that has untagged JSON encoding.  http://hackage.haskell.org/package/json-alt-1.0.0 (MichalGajda)
05:48:03 * hackage json-autotype 3.0.0 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-3.0.0 (MichalGajda)
05:59:38 <nkaretnikov> tsahyt: I don’t like the api. I think it returns a maybe where I want either.
06:14:03 * hackage vt-utils 1.0.0.0 - Vector and Text utilities  http://hackage.haskell.org/package/vt-utils-1.0.0.0 (Wilton)
07:20:23 <pzp> Trying to read this paper http://kataskeue.com/gdp.pdf but I am having a hard time understanding this line `type a ~~ name = Named name a`. Is this essentially a custom infix operator at the type level?
07:20:41 <Cale> yes
07:20:57 <pzp> Great, thanks!
07:21:07 <pzp> Didn't know you could do that, wow!
07:23:47 <slaterr> hi
07:24:18 <slaterr> my ghci crashed after I did length "some string", what is up with that?
07:24:23 <slaterr> I can't reproduce it
07:24:43 <slaterr> but every now and then, ghci segfaults
07:24:56 <Cale> slaterr: That... generally shouldn't happen
07:25:13 <slaterr> "The Haskell process `test' has died. Restart? (y, n, l: show process log) y". unfortunately, I did not press l so I don't think I can get logs
07:25:30 <Cale> What's that message from?
07:25:42 <Cale> Doesn't look like a ghci message
07:25:44 <slaterr> emacs repl buffer
07:25:47 <Cale> ah
07:25:48 <slaterr> running ghci
07:31:28 <dmwit> If you don't use the FFI, ghci should never segfault. If you find a way to reliably make that happen, it is absolutely a bug.
07:31:29 <slaterr> actually I can reproduce it this time, but only in emacs. length "\346" (where \346 is replaced with that unicode character) crashes ghci
07:32:16 <dmwit> Would you enter that same input into xxd instead of ghci?
07:32:21 <slaterr> it works fine if I run ghci in terminal. but, like you said, no matter what emacs sends to ghci process, it shouldn't cause a segfault
07:32:26 <dmwit> It would be good to know exactly which bytes emacs is sending to ghci.
07:34:00 <tdammers> dmwit: I'm pretty convinced that the problems leading to https://ghc.haskell.org/trac/ghc/ticket/14375 could be exploited to make GHC(i) segfault
07:34:12 <tdammers> without using FFI, that is
07:34:39 <slaterr> dmwit I have no idea how to check what emacs is sending to ghci
07:35:17 <dmwit> slaterr: I told you how: run xxd instead of ghci, and enter the exact same thing.
07:35:37 <dmwit> It will print a hex representation of the bytes it receives.
07:36:08 --- mode: glguy set +v dmrd_
07:36:22 <dmwit> tdammers: And you would not consider this fact a bug?
07:36:49 <tdammers> dmwit: I would, that's why we're working on a fix
07:36:56 <dmwit> Then I think we're in agreement.
07:37:03 <dmwit> "ghci should never segfault" is normative, not descriptive.
07:37:16 <tdammers> OK then, I rest my case
07:38:14 <slaterr> dmwit I missed that line, moment
07:39:43 <dmwit> tdammers: "If the compiler gets a fatal signal, for any input whatever, that is a compiler bug. Reliable compilers never crash." I love this sentence for all the same reasons MJD does. https://blog.plover.com/prog/compiler-error-2.html
07:43:24 <tdammers> I whole-heartedly agree
07:43:34 <tdammers> and this should go for *any* program, really
07:44:00 <tdammers> no inputs should be able to cause a program to crash hard (segfault / coredump / uncaught exception)
07:49:30 <c_wraith> uncaught exception is a *lot* less hard than those other two.
07:49:48 <c_wraith> It implies and orderly unwind & shutdown sequence by the runtime, which the others don't
07:51:42 <c_wraith> unless you meant one of the *other* definitions of exception than the language level construct provided in languages like Haskell
07:57:09 <geekosaur> there's also tings that are ore or less hacks, like the "broken pipe" signal on unix
07:58:55 <c_wraith> off-topic question: what process(es) get SIGINT if you ctrl-c a shell pipeline?  I guess it's up to the shell?
07:59:25 <geekosaur> every process in the pipeline
07:59:43 <c_wraith> I guess that's the only safe approach.
08:00:12 <geekosaur> it's nto up to the shell, except insofar as the shell may group "jobs" by terminal process group; btu it's the terminal driver that signals proicesses in the current tpgrp
08:01:07 <c_wraith> Does that imply the shell itself also gets a SIGINT?
08:01:20 <geekosaur> (whcih is also the set of processes that can read and write to the terminal without blocking or receiving SIGTTIN / SIGTTOU)
08:01:52 <geekosaur> it does but will be ignoring it (or recording and resuming waitpid())
08:01:52 <c_wraith> Huh.  I didn't know anything about any of this.  Thank you.
08:03:08 <merijn> "in the pipeline" <- that's not a thing
08:03:16 <merijn> Every process in the process-group gets the signal
08:03:34 <merijn> Although most shells will (helpfully) group shell pipelines into a single process-group
08:05:23 <geekosaur> which is what I said about grouping "jobs"
08:05:36 <slaterr> question unrelated to my prior one. I already have ghc installed on linux, and now I want to install stack. should I remove global ghc before installing stack?
08:05:47 <geekosaur> a shell without job control will generally put all its children in its own pgrp, so all fo tem would be signaled
08:06:02 <c_wraith> slaterr: nah, stack works just fine with or without a system ghc install
08:12:52 <geekosaur> works btu can be confusing when e.g. ghci and stack ghci do different things
08:23:57 <shapr> good morning!
08:25:35 <sm> good morning shapr!
08:25:45 <shapr> sm: how you doin this fine morning?
08:25:53 <sm> quite well thank you!
08:26:15 <sm> rain forecast tonight in LA
08:26:45 <shapr> Lower Alabama?
08:27:25 <sm> southern california, I should say
08:27:34 <shapr> oh ok
08:28:01 <shapr> I visited San Francisco for the first time recently. It's an unusual area.
08:31:46 <shapr> I've never visited Los Angeles though
08:42:44 <sm> let me know if you do!
08:42:53 <sm> so what's on the menu for today ? any haskelling ? (shapr)
08:49:34 <ski> @get-shapr
08:49:34 <lambdabot> shapr!!
08:49:54 * ski idly wonders why shapr was requested
09:03:25 <shapr> ski: you called?
09:03:43 <ski> well, sm did
09:03:43 <shapr> sm: yup, I'm going through advent of code 2015 to practice for advent of code 2018 starting on dec 1st
09:03:58 <lavalike> shapr: me too! 11 is giving me a hard time ):
09:04:11 <ski> (11 ?)
09:04:25 <shapr> ski: https://adventofcode.com/2015/day/11 ?
09:04:48 <lavalike> maybe I should have not said it, people here will golf a one liner for it
09:05:03 <shapr> I'm hoping glguy will one day share his contest setup
09:05:09 <ski> shapr, ok, ic
09:05:16 <shapr> since he ranked 13th last year out of ~ten thousand players
09:05:23 <lavalike> shapr: will it include his brain, it's a very important piece
09:05:30 <shapr> true that!
09:05:36 <shapr> but probably won't include his brain
09:06:37 <ski> ("as these letters can be mistaken for other characters and are therefore confusing" seems to be accomodating to someone who's trying to decipher the password you wrote down on a post-it note :)
09:07:34 * ski . o O ( "braaains !!" )
09:07:51 <sm> oh, good thinking
09:09:04 <sm> glguy has a special setup ? agreed, that would be interesting
09:09:14 <glguy> I hope he tells me about it!
09:09:28 <ski> well, if you ask him kindly, then perhaps ..
09:09:42 <sm> tell him to make top ten this year
09:09:57 <shapr> sm: the way I heard it, he only heard about the contest after it started
09:10:29 <lavalike> the internet can really connect you to the wildest outliers
09:10:49 <ski> no, you !
09:11:01 <shapr> lavalike: I think we're all outliers in our own way
09:11:10 <lavalike> shapr: may very well be
09:13:08 <sm> my 2016 advent of code setup was... each solution was a stack script, NN.hs, with the problem url and text pasted as the module docstring; emacs & ghcid.
09:13:36 <glguy> I usually started with an open editor, some stuff from containers imported, and ghci loaded
09:14:03 <lavalike> next steps:  * ????  * PROFIT!
09:14:05 <sm> oh, ghci too
09:14:21 <glguy> If you're thinking of participating for the first time this year you can join the group I'll probably be advertising in here all month: 43100-84040706  https://adventofcode.com/2018/leaderboard/private
09:14:39 <sm> nice
09:15:56 <shapr> glguy: I mentioned AoC on lobste.rs, was asked if I expected to place on the global leaderboard... but I'm really competing with my coworkers.
09:16:03 <shapr> And most everyone is using a fun language to solve the problems.
09:16:21 <sm> it's a very well done contest
09:16:32 <shapr> it is!
09:16:37 <shapr> and the puzzles have improved over the years
09:16:43 <lavalike> that is quite true
09:16:44 <glguy> shapr: I think the best use of it is to try and find clean solutions to the problems rather than racing
09:16:57 <lavalike> glguy: +1 !
09:17:07 <glguy> and to have everyone working on the same problem set to have shared discussions
09:17:13 <lavalike> glguy: I deeply enjoyed the TH solution to the assembler-language problem you wrote
09:17:22 <shapr> I also enjoy comparing solutions in various languages
09:17:35 <shapr> For day 2 of 2015, I wrote a 'full parser' since that was all of two lines.
09:17:45 <shapr> one line for the datatype, one line for the parser.
09:18:11 <lavalike> shapr: heh! I'm always happy to be able to have an excuse to write some Parsec code for those inputs
09:18:31 <shapr> I've been using attoparsec
09:18:48 <shapr> I'd like to switch to megaparsec, but it's changed in the past two years and I haven't kept track
09:18:54 <glguy> I need to refresh myself on megaparsec
09:18:54 <lavalike> gotta have that speed
09:19:05 <sm> does AOC also rank the private leaderboards ? it should
09:19:32 <sm> collectively competing with other languages would be fun
09:20:08 <shapr> lavalike: last I heard, megaparsec is 97% as fast as attoparsec, with better error messages
09:20:31 <shapr> but I don't know! I need to sit down and figure out how to do all the same things in megaparsec that I can do in attoparsec
09:20:34 <lavalike> I always just use Parsec, didn't really ever had the need to change
09:20:50 <sm> shapr: do it.. there are good tutorials
09:20:55 <lavalike> the parser is usually not the bottleneck anyway
09:21:19 <shapr> lavalike: I like to think better error messages improves speed of development
09:22:43 <lavalike> I think that if I could type the solution a thousand times faster I would still take the same time to solve the problems
09:43:03 * hackage toodles 1.0.1 - Manage the TODO entries in your code  http://hackage.haskell.org/package/toodles-1.0.1 (aviaviavi)
09:57:32 <dmwit> sm: Are you asking whether private leaderboards are ranked against other private leaderboards, or whether the people invited to a private leaderboard are ranked against each other?
09:57:39 <dmwit> The former I think no, the latter yes.
10:24:03 <fresheyeball> so I was reading about Curry Howard
10:24:08 <reygoch> Is it possible to extract current generator from MonadRandom? I'd like to save the generator / seed which was used to generate particular item.
10:24:15 <fresheyeball> and see that function arrows are exponents in types
10:24:31 <fresheyeball> so if we have a function `a -> b` we have |b| ^ |a|
10:24:43 <fresheyeball> that makes sense to me
10:24:57 <fresheyeball> but I don't understand how this works considering `id`
10:25:00 <fresheyeball> id :: a -> a
10:25:09 <mniip> id :: forall a. a -> a
10:25:11 <mniip> it''s a forall-type
10:25:16 <fresheyeball> and |a -> a| = 1
10:25:22 <mniip> nuh uh
10:25:25 <mniip> |forall a. a -> a| = 1
10:25:38 <fresheyeball> mniip: I see
10:25:43 <fresheyeball> but I don't understand
10:25:53 <mniip> there's no simple formula for counting the inhabitants of a forall-type
10:26:12 <fresheyeball> I thought | forall a. a | = Infinity
10:26:28 <mniip> quite the opposite
10:26:29 <mniip> it's 0
10:26:49 <fresheyeball> how so?
10:26:58 <mniip> parametricity
10:27:05 <mniip> @free x :: forall a. a
10:27:05 <lambdabot> f x = x
10:27:05 <fresheyeball> I don't understand
10:27:20 <mniip> if x were to have type forall a. a
10:27:27 <mniip> then for any function f,  f x = x
10:27:35 <mniip> clearly no such x exists
10:27:39 <geekosaur> reygoch, I thik oly for specific instances. Consider one where the source is /dev/random
10:28:15 <reygoch> geekosaur: what do you mean /dev/random? I'm using StdGen.
10:28:43 <geekosaur> MonadRandom is a typeclass. StdGen-based random generators are not the only instances
10:28:49 <fresheyeball> mniip: but doesn't `forall a. a` unify with any type? If I have a bottom, can't I break things?
10:29:27 <reygoch> geekosaur: ah, yes... I actually want to extract StdGen from RandT StdGen Identity a
10:30:26 <reygoch> geekosaur: or rather, I'm trying to write `get :: RandT StdGen Identity StdGen`
10:31:40 <reygoch> geekosaur: this seems like rather useful thing, and I'm not sure if it can't be achieved or I'm just being dumb
10:32:32 <geekosaur> yeh, I'm looking. I think the problem is you need it from the RandT level, but RandT can't promise that every possible "g" has an accessor
10:33:45 <geekosaur> so it has no way to expose (in this case) the StdGen. (this gts ugly in the general case; go look at mwc-random for one that is difficult to do this for)
10:34:50 <mniip> fresheyeball, bottoms are out of the scope of the type/set algebra you're describing
10:34:51 <geekosaur> so I think you can't do this with the MonadRandom interface
10:35:28 <reygoch> hm... I do't quite get what you mean by it not being able to promise that every possible "g" has an ancestor.
10:35:39 <reygoch> I'm interested in the g that yet has to be used.
10:36:20 <mniip> fresheyeball, or perhaps it makes sense to say that || only counts inhabitants reduced to normal form
10:36:27 <reygoch> Only thing I'm missing really is RandT constructor so that I can wrap it around `get` from state transformer.
10:37:15 <reygoch> But I'm not sure if something else is there to allow me to read the state which contains g which is next in line
10:39:16 <rfold> Hi, I have a bunch of code that does traverse, and I want to use Kleisli composition instead of repeated traverse, and do one traverse at the end. For fmap you can use Coyoneda. But Coyoneda uses (a -> b) instead of (a -> m b) so I came up with this: https://glot.io/snippets/f73lg8d294 I was wondering if this is a sensible thing to do or if it already exists in a library.
10:42:33 * hackage HCL 1.6 - High-level library for building command line interfaces.  http://hackage.haskell.org/package/HCL-1.6 (jlamothe)
10:42:49 <geekosaur> reygoch, accessor, not ancestor. Way to retrieve the "seed" within it (which may not belong to it, as with /dev/random or the hack mwc-random uses) given a StdGen value.
10:43:37 <geekosaur> erm, given a "g". if "g"is StdGen, StdGen provides such a way
10:44:07 <geekosaur> btut he RandT interface has to work also for the ones that aren't StdGen
10:45:34 <reygoch> geekosaur: Well, RandT is newtype around StateT g m a, I want to get g from that StateT. It is not limited to StdGen but what ever, and I want to get that "whatever". Don't really see why this wouldn't be possible.
10:45:41 <johnw> rfold: so, in the way that Coyoneda captures the arguments to fmap and yields a Functor, you want to capture the arguments to (>>=) and yield a Monad?
10:46:24 <rfold> johnw: rather, the arguments to traverse
10:46:58 <rfold> johnw: although a problem is that traverse only gives you an applicative, for <=< you need a monad, so it can't be an instance of Traversable
10:47:45 <johnw> i'm not aware of anything in particular. You sort of want the "free traversable"?
10:48:02 <reygoch> geekosaur: I've actually noticed that I can retrieve g with liftRandT.
10:48:12 <reygoch> geekosaur: damn, took me long enough
10:48:18 <rfold> johnw: similar to how Coyoneda is the free functor, yes
10:48:43 <rfold> johnw: so it has to do the traverse, and not my data structure (which is a HashMap, where repeated traverses are quite expensive)
10:48:53 <johnw> and you're doing it to shift composition into the argument, rather than between the operations?
10:49:04 <rfold> yes
10:49:08 <johnw> sounds legit to me
10:50:23 <rfold> In particular I'd be looking for something with a law that foo f <=< foo g = foo (f <=< g), where foo is similar to traverse. Traversable doesn't have this law though.
10:51:03 <johnw> doesn't this just mean that foo is a monad homomorphism?
10:54:11 <rfold> Yes I think so.
10:59:03 <johnw> rfold: I can't find anything other than a talk by Ed, but his talk appears to be mainly about species of monad homomorphisms, not anything you might gain from abstracting their laws
10:59:15 <johnw> sounds like an interesting vein of research, though
11:01:31 <lavalike> what are some good choices for packages for testing haskell code?
11:01:59 <johnw> tasty, hedgehog, criterion
11:02:10 <koz_> Criterion is for benching.
11:02:15 <johnw> hunit of course (these all integrate with tasty)
11:02:27 <johnw> sure, but I don't know exactly what people mean when they say "testing"
11:02:31 <johnw> testing for speed :)
11:02:44 <koz_> johnw: I would normally think 'testing' is to do with correctness.
11:02:45 <lavalike> ^_^ I remember something about being able to put your tests into comments too
11:02:47 <koz_> But that's just me maybe.
11:02:57 <lavalike> but forget what that is called
11:03:04 <boj> lavalike: doctest i believe
11:03:06 <johnw> doctest
11:03:16 <rfold> There's doctest but I had some trouble getting it to work with GHCJS some time ago.
11:03:19 <koz_> Also, johnw: What I recall from Ed's talk on the topic of monad homomorphisms is 'Cont ruins things, again'.
11:03:25 <lavalike> was hoping it would be one of the ones mentioned
11:03:31 <lavalike> appreciate it
11:03:35 <johnw> koz_: Cont is the outlier for so many things
11:03:49 <rfold> I'll look up the talk by Ed, always enjoy watching them
11:03:58 <Solonarv> how about Codensity? That tends to be a bit better-behaved
11:04:02 <koz_> I think in this case it's because ContT is not an MFunctor.
11:04:04 <johnw> https://www.youtube.com/watch?v=YTaNkWjd-ac
11:04:07 <johnw> rfold: ^
11:13:23 <noumenon> http://hume.ucdavis.edu/mattey/phi175/monad.html
11:13:43 <noumenon> "The only qualities of monads are intrinsic, and any change that comes about in them is due to an internal principle."
11:14:05 <noumenon> are the monads of category theory based on Leibniz' monads?
11:14:13 <mniip> no
11:14:18 <mniip> unfortunate naming coincidence
11:14:44 <noumenon> sounds like they are describing the same thing; what's the etymology of monad in category theory?
11:16:14 <mniip> noumenon, monos -> monad
11:16:20 <mniip> it's supposed to be a sibling to monoid
11:17:04 <noumenon> well, I'm aware of the root monos, but what exactly do the -oid and -ad suffixes signify?
11:17:31 <mniip> 'id' - "-like"
11:17:59 <mniip> 'ad' - "derived from -"
11:18:31 <noumenon> right, so they essentially mean the same thing, "derived from one"
11:18:40 <koz_> Obligatory 'monads are just monoids in the category of endofunctors'.
11:19:16 <bsima> noumenon: to confuse you even further, Leibniz (as interpreted by Deleuze) also has a concept of a "fold" https://en.wikipedia.org/wiki/The_Fold%3A_Leibniz_and_the_Baroque
11:19:16 <noumenon> right; and all functors in Haskell are endofunctors over Haskell types or something
11:19:37 <mniip> all Functors (capital F) in haskell are endofunctors on Hask yes
11:19:48 <noumenon> bsima: interesting; can you fold monads in category theory/Haskell?
11:19:51 <Solonarv> Not actually true, it's just the usual Functor class that's endofunctors
11:20:23 <mniip> there's also Bifunctors and Profunctors
11:20:38 <mniip> and you can use something like ekmett's Hask machinery to define abitrary higher order functors
11:20:58 <noumenon> Haskell remains quite arcane to me
11:21:01 <Solonarv> 'Dict' is a functor too, for example (one from the category of constraints to Hask)
11:22:20 <koz_> Solonarv: This immediately makes me think of a Codict.
11:22:26 <koz_> (not that I suspect it'd be very useful)
11:22:29 <mniip> koz_, no such
11:22:50 <Solonarv> What would that be? a functor from Constraint^op to Hask, or...?
11:23:00 <koz_> Hask -> Constraint I was thinking.
11:23:07 <koz_> What is Constraint^op even?
11:23:20 <Solonarv> C^op is the dual category to ^op
11:23:24 <Solonarv> errr, to C
11:23:25 <hololeap> noumenon: unless i'm mistaken, (>=>) is analoguous to `mappend` and `return` is analogous to `mempty`. you can see the monoidal structure through that
11:23:35 <Solonarv> keep the same objects, flip all the arrows
11:23:42 <koz_> Ah yeah, that's right.
11:23:49 <Solonarv> hololeap: yes, that's right
11:24:50 <koz_> Of relevance: http://hackage.haskell.org/package/monadoid-0.0.3/docs/Data-Monadoid.html#t:Monadoid
11:25:00 <koz_> (specifically its Monoid instance)
11:25:20 <koz_> (although 'Monadoid' is _super_ awkward as a name)
11:25:43 <Solonarv> something something three hard problems something something naming things off by one
11:26:47 <koz_> Solonarv: Yeah, that one is evergreen.
11:27:46 <Solonarv> ...isn't that just Ap ? it's in base as of 4.11 IIRC
11:27:52 <Solonarv> % :i Ap
11:27:52 <yahb> Solonarv: type role Ap representational nominal; newtype Ap (f :: k -> *) (a :: k) = Ap {getAp :: f a}; -- Defined in `Data.Monoid'; instance Alternative f => Alternative (Ap f) -- Defined in `Data.Monoid'; instance Applicative f => Applicative (Ap f) -- Defined in `Data.Monoid'; instance forall k (f :: k -> *) (a :: k). Eq (f a) => Eq (Ap f a) -- Defined in `Data.Monoid'; instance Functor f => Functor (Ap f) 
11:28:29 <koz_> Solonarv: Huh, interesting. I wonder why that package is still updated then.
11:28:47 <Solonarv> It only got added to base fairly recently
11:30:12 <mniip> hololeap, Solonarv what no
11:30:23 <mniip> join is analogous to mappend and return is analogous to mempty
11:30:40 <koz_> The one hololeap describes is the Kleisli category I think.
11:30:51 <mniip> (>=>) and return is the kleisli category description
11:30:53 <Solonarv> ah yes
11:31:00 <hololeap> makes sense
11:31:35 <koz_> I remember this kinda conversation happening recently here. I think I even asked.
11:31:57 <koz_> And people gave me, like, three possible ways in which you could treat (something like) Monads as Monoids.
11:32:21 <koz_> (which were basically pure/join, Kleisli and Ap)
11:32:23 <mniip> an interesting example of a kleisli category is that Rel, the category of relations, is a kleisli category of the covariant powerset functor on top of Set
11:32:40 <koz_> mniip: Oh that's _really_ cool.
11:34:08 <hololeap> what in the world is the covariant powerset functor
11:34:38 <Solonarv> it's the functor Pow : Set -> Set which takes a set to its powerset
11:35:20 <hololeap> wait, wouldn't it be the other way around since it's covariant?
11:35:42 <Solonarv> co/contravariant only changes how it treats the arrows
11:35:58 <hololeap> oh right... i was thinking _contra_variant
11:36:56 <Solonarv> the covariant powerset functor takes a function f : A -> B to Pow(f) : Pow(A) -> Pow(B), with Pow(f) = \X -> { f(x) | x in X }
11:37:14 <Solonarv> AKA "the obvious thing", or "commonly accepted abuse of notation"
11:37:40 <hololeap> what would `join` do on Pow(Pow(x))
11:38:05 <Solonarv> dunno, ask mniip :V
11:38:41 <lyxia> union
11:39:17 <Solonarv> ah, makes sense
11:42:16 <hololeap> ugh
11:42:24 <hololeap> too much for me
11:43:40 * hackage concurrency 1.6.2.0 - Typeclasses, functions, and data types for concurrency and STM.  http://hackage.haskell.org/package/concurrency-1.6.2.0 (barrucadu)
11:50:24 <dmwit> There is a contravariant powerset functor, too.
11:50:46 <dmwit> For fmap, instead of taking the image, take the preimage.
11:51:24 <mniip> and for the monad
11:51:26 <mniip> it's complicated
11:51:31 <mniip> basically Cont Bool
11:53:45 <PrimHelios> is there a way to combine lines 11 and 12 of this code into one line? liftM2 works but it's lazy so the print statement in libhello never prints
11:54:34 <PrimHelios> whoops forgot the code: https://hastebin.com/uladamizuy
11:56:37 <johnw> mniip: is Cont Bool an ultrafilter?
11:57:46 <Solonarv> "liftM2 is lazy" has nothing to do with this; unless you're using unsafeInterleaveIO, laziness won't affect whether IO actions happen or not
11:58:09 <Solonarv> that being said:
11:59:20 <mniip> johnw, I have no idea what that is :P
11:59:28 <johnw> https://github.com/vidlew/Ultrafilter/blob/master/Ultrafilter.hs
11:59:42 <Solonarv> @. pl undo do { sayhello <- getFunc; mkString >>= mkFun sayhello }
11:59:42 <lambdabot> (mkString >>=) . mkFun =<< getFunc
11:59:44 <johnw> and also, nlab
11:59:48 <Solonarv> PrimHelios: ^
12:00:02 <Solonarv> Not particularly readable, IMO. Keep it how it is.
12:00:08 <dmwit> PrimHelios: join (liftM2 mkFun (dlsym ...) (newCString ...))
12:00:23 <Solonarv> also please don't use liftM2, use liftA2
12:00:26 <dmwit> PrimHelios: This is not the first time I have wished for a liftM* variant that does a join at the end.
12:00:34 <dmwit> Solonarv: Doesn't matter. Gotta join anyway.
12:00:54 <PrimHelios> Solonarv: is there a reason for that?
12:00:54 <dmwit> Solonarv: ...so liftA2 doesn't actually buy you any extra polymorphism.
12:01:27 <dmwit> Also I agree that "liftM2 is lazy" is a mischaracterization of what has gone wrong.
12:01:28 <Solonarv> oh, I know all that. I just get really irritated seeing pre-AMP (and FTP, and to some extent SMP) stuff
12:02:38 <PrimHelios> so if "liftM2 is lazy" isn't the issue, what is? is it that the IO action is wrapped in another IO action?
12:02:57 <Solonarv> PrimHelios: historical stuff. Applicative is a generalization of Monad, and turns out to be sufficient to implement liftX2. However, Monad was added first, so we have some crufty old functions laying around that require Monad when really Applicative is enough
12:03:00 <Solonarv> and: yes, exactly
12:03:17 <Solonarv> IO (IO blah) ≠ IO blah
12:03:22 <PrimHelios> ah, that all makes sense. thanks!
12:03:37 <PrimHelios> liftX2
12:03:42 <PrimHelios> whoops, wrong window
12:03:49 <Solonarv> liftX2 doesn't actually exist
12:03:59 <Solonarv> I just couldn't decide between typing liftA2 and liftM2
12:04:06 <PrimHelios> ah, so google wouldn't have helped anyway lol
12:04:09 <PrimHelios> gotcha
12:04:10 <Solonarv> nope :p
12:04:45 <dmwit> "If 'liftM2 is lazy' isn't the issue, what is?" The issue is that liftM2 gives you an IO action that prepares the arguments to mkFun, but returns an action for executing mkFun without actually executing mkFun itself. In some ways it is similar to the factory pattern in Java.
12:05:12 <PrimHelios> ahhh, alright, gotcha
12:05:13 <dmwit> That is, you do some IO that creates an action you can execute several times, and each time you do it runs mkFun afresh.
12:05:42 <dmwit> If you want it to run exactly once, you have to say so; join is the way to say that.
12:06:02 <monochrom> To a large extent "is it lazy or not" is a wrong question.
12:06:47 <Solonarv> Yup. As I said, unless you're using unsafeInterleaveIO laziness and IO won't get in each other's way
12:08:28 <mniip> johnw, I don't think so
12:08:40 <monochrom> The right approach is to understand the definition of liftA2 and liftM2, which are based on <*> and >>=. And understand what <*> and >>= actually do for the monad in question --- it really depends on the monad.
12:09:50 <monochrom> In the simple [I know right?] case of IO, <*> and >>= are sequential in the I/O operations.  (I'm just saying the I/O operations, the effects.  I am not talking about evaluation of for example x+1.)
12:11:25 <Solonarv> (that can still happen in any order)
12:12:01 <monochrom> For example if you write so much as "getLine >>= \_ -> putStrLn "foo"", the waiting for your input will happen, and it will happen here and now, before outputting foo, even though obviously the code will throw your input away.
12:12:25 <monochrom> And the outputting of foo will happen right there, even though you are not looking at the computer.
12:13:05 <monochrom> So if you accept that, then it's clear what happens to liftM2 blahbah getLine getLine, even when blahblah is highly lazy.
12:40:28 <hololeap> so, i'm just playing around with DataKinds, trying to limit IO to read, write, read/write, or errors only. there's no practical reason for this; it's just an exercise. still, i would appreciate it if someone knowledgable could peek at my code and suggest improvements or other ways of accomplishing this: http://dpaste.com/0XHH43Q
12:44:47 <koz_> hololeap: Have you looked at part 1 of jle`'s Introduction to Singletons?
12:45:00 <koz_> I would suggest doing so, because otherwise I'll just end up repeating it while advising you. :P
12:45:42 <hololeap> koz_: no, i haven't
12:46:17 <koz_> https://blog.jle.im/entry/introduction-to-singletons-1.html
12:46:29 <koz_> Definitely read it - you will see improvements you can make to your code _immediately_.
12:46:56 <hololeap> koz_: ok, thanks :)
12:47:18 <koz_> Don't thank me - thank jle` for writing it.
12:47:37 <koz_> At this stage, you probably don't need parts 2 and 3, but they're also useful to read if you wanna use dependent typing in Haskell.
12:47:54 <MarcelineVQ> don't do that, he'll feel good inside and it will distract him from his important mission
12:48:11 <koz_> MarcelineVQ: What is his important mission?
12:48:34 <MarcelineVQ> Well it's... wait, you're one of them aren't you
12:49:03 * koz_ is one of them, apparently.
12:49:09 <MarcelineVQ> them
12:49:27 <koz_> Yes, <arbitrary_punctuation>them</arbitrary_punctuation>.
12:49:41 <hololeap> MarcelineVQ: how are you doing that font styling?
12:49:44 <koz_> s/punctuation/font_shenanigans/
12:50:43 <MarcelineVQ> It's a power of the ancients, I recommend against it, unicode requires slightly less human sacrifice
12:51:06 <MarcelineVQ> Though in consumed man-hours it's probably the deeper evil.
12:53:48 <monochrom> hololeap: https://modern.ircdocs.horse/formatting.html#characters helps :)
12:54:11 * hololeap understands!
12:55:35 <monochrom> Some IRC clients have keyboard shortcuts for generating those codes, e.g., Hexchat takes your ctrl-i to generate 0x1D so you just have to remember "italic -> i -> ctrl-i"
12:58:52 <berndl> I'm little confused about ⊥ in Haskell. I'm reading this tutorial and it says that ⊥ "lives in the word of denotational sematics".
13:00:41 <berndl> But then the article starts writing things like "head ⊥" and "False && ⊥".
13:01:47 <monochrom> That means "head ⊥" is also living in the world of denotational semantics now.
13:01:50 <berndl> I'm guessing it should be [|head|] ⊥, where [|_|] are the usual denotation brackets.
13:02:14 <monochrom> Yes you can do that and it's probably more proper.
13:02:37 <berndl> OK. I just wanted some closure about that because it was throwing me off.
13:05:04 --- mode: glguy set +v Boarders
13:05:34 --- mode: glguy set -v Boarders
13:06:19 <berndl> So when people say that "every type in Haskell is inhabited by bottom", they are actually refering to that the denotation of the type has a bottom member.
13:06:43 <berndl> bleh, my sentences are coming out all screwy today.
13:06:50 <monochrom> Yes.
13:11:54 <berndl> Something else that is unclear to me is: what kind of model are we using for the denotational semantics?
13:12:45 <berndl> Do people typically assume, in the context of Haskell, that the model is a omega-DCPO?
13:13:32 <monochrom> Yes I think so.
13:14:51 <leshow> Has anyone read Thinking With Types by Sandy
13:15:40 <berndl> Not me.
13:16:33 <MarcelineVQ> a little
13:16:37 <MarcelineVQ> koz_ has
13:16:46 <leshow> There's this part where he talks about representing data from it's cardinality, a tictactoe game. could be represented with like board { one :: Maybe Bool, two:: Maybe Bool, etc .. }
13:16:49 <koz_> Yep, confirmed.
13:17:11 <leshow> then if you work back from the cardinality he arrives at (Three, Three) -> a or Three -> Three -> a
13:17:58 <leshow> where Three is One | Two | Three
13:18:28 <leshow> representing the position on the board. But I'm trying to imagine what a function might look like that makes a move
13:18:47 <koz_> leshow: Let me refresh my memory. What page?
13:18:56 <leshow> 14, its right at the start
13:19:04 <leshow> 13-14
13:20:03 <koz_> leshow: What do you mean by 'making a move' in this case - are you saying 'scribble something into an empty square'?
13:20:12 <leshow> yeah sure
13:20:20 <koz_> OK.
13:20:44 <koz_> Let's say your board is a TicTacToe (Maybe Bool) for simplicity.
13:20:51 <koz_> Where Nothing means 'empty cell'.
13:21:14 <koz_> What do you think should happen if someone tries to scribble into a non-empty cell?
13:21:48 <leshow> I imagine you'd return an error or something, or ask to move again
13:22:01 <koz_> Let's go with the error option.
13:22:10 <koz_> So the type sig would be something like
13:22:37 <koz_> makeMove :: TicTacToe (Maybe Bool) -> (Three, Three) -> Bool -> Maybe (TicTacToe (Maybe Bool))
13:22:48 <koz_> We can eliminate the Maybe Bool noise by defining our own type like
13:23:10 <koz_> data Cell = Empty | IsX | IsO
13:23:14 <koz_> But that doesn't matter really.
13:23:40 <koz_> With me so far?
13:24:12 <leshow> TicTacToe here is still represented as Three -> Three -> Maybe Bool?
13:24:51 <koz_> More precisely, it's represented as wrapper around that.
13:24:53 <hyperisco> lol I approve
13:24:54 <koz_> But yes.
13:25:02 <leshow> okay sure
13:25:02 <hyperisco> I don't see people choosing that representation often
13:25:35 <koz_> Right, so let's think about it a bit. First, we have to check if we're getting Nothing because our caller decided to scribble onto a non-empty cell.
13:25:40 <koz_> How would we do that given our arguments?
13:25:54 <hyperisco> want to transpose the board? flip!
13:26:02 <koz_> hyperisco: Yeah, that's a pretty cool one.
13:26:21 <leshow> This is where I'm confused about the representation, our first argument is a function with 2 arguments
13:26:48 <koz_> leshow: If it helps, imagine it's board :: (Three, Three) -> Maybe Bool
13:26:58 <koz_> It doesn't actually matter, but it might make it easier for you to see what's happening.
13:27:46 <koz_> board is just a function, like any other: you feed it a (Three,Three), it gives back a Maybe Bool.
13:27:53 <koz_> We have a (Three,Three) argument from makeMove.
13:27:58 <koz_> So how would we check if that cell is available?
13:29:14 <leshow> um
13:29:31 <leshow> pass in the tuple and evaluate board ?
13:30:07 <koz_> Correct. We can get either Nothing, or Just b, where b = True or b = False.
13:30:17 <koz_> What should we do if that evaluation gives Nothing?
13:31:18 <leshow> return Nothing in this case
13:31:47 <koz_> leshow: Are you sure about that?
13:32:01 <koz_> If we get back Nothing from calling the board function on the input tuple, it means the cell is _available_.
13:32:03 <leshow> oh wait
13:32:07 <leshow> yeah if it's nothing it's empty
13:32:20 <leshow> place an True/False
13:32:21 <leshow> a*
13:32:31 <koz_> Yep, based on what the caller requested.
13:32:41 <koz_> Now, for _all the other_ cells, we can just re-use the old board function, right?
13:32:50 <koz_> The only change is at the tuple passed as an argument.
13:33:13 <leshow> yeah I suppose you could
13:33:37 <koz_> So what you need to do is cook a new function which takes a tuple, checks if it matches the argument; if it does, return whatever the user requested we put there, otherwise delegate back to the original board function.
13:33:42 <koz_> Can you write that?
13:34:04 <koz_> (note that, as Three has an Eq instance, so does (Three, Three))
13:34:06 <koz_> (this is not an accident)
13:34:44 <leshow> One thing I didn't get in your original type signature is why your second 'argument' is (Three, Three) is that not already encoded in the first argument, TicTacToe
13:35:02 <koz_> leshow: TicTacToe (Maybe Bool) is your original board.
13:35:13 <koz_> The (Three, Three) argument to makeMove is 'where you wanna move'.
13:35:24 <koz_> Or more exactly, 'what cell do you want to scribble on'.
13:35:43 <leshow> Alright I'll give it a go
13:35:50 <koz_> Give it a try and post your results.
13:36:06 <koz_> It's a little tricky at first, but you'll see it quickly.
13:36:28 <leshow> I still feel like it's not mentally clicking but only one way to find out lol
13:37:19 <koz_> leshow: Just give it a try.
13:37:27 <koz_> If you get stuck, at least it'll be on something more concrete.
13:44:47 <rain1> @src liftM2
13:44:48 <lambdabot> liftM2 f m1 m2 = do
13:44:48 <lambdabot>     x1 <- m1
13:44:48 <lambdabot>     x2 <- m2
13:44:48 <lambdabot>     return (f x1 x2)
13:57:16 <leshow> koz_, perhaps I'm misunderstanding but you mentioned board taking (Three, Three) and giving back a Maybe Bool? In this case it takes a TicTacToe, does it not? I suppose I'm being tripped up on the equality part
13:58:01 <leshow> I have a move, which is a (Three, Three), I can pass my first argument (the current board) into board to get it's value
13:58:37 <monochrom> You are mixing up "board" and "move".
13:59:34 <leshow> "board is just a function, like any other: you feed it a (Three,Three), it gives back a Maybe Bool"
13:59:48 <leshow> does it not take a TicTacToe, not a (Three, Three)
13:59:59 <monochrom> And to some extent, also probably mixing up "move" and "how does a move affect the board".
14:01:30 <monochrom> "board" doesn't take a TicTacToe. "board" means TicTacToe.
14:02:46 <leshow> functions in records confuse the hell out of me
14:02:49 --- mode: glguy set +v mitchellsalad__
14:03:15 --- mode: glguy set -v mitchellsalad__
14:03:17 <c_wraith> huh. I've got some really old tictactoe code around. I just scanned it and found a bunch of things that I got patched in libraries after writing it and discovering various shortcomings.
14:03:57 <mitchellsalad__> Is it possible to pass C structs by value via the FFI?
14:04:09 <mitchellsalad__> I couldn't really figure out how with c2hs
14:04:17 <c_wraith> historical artifact! and all I wanted to do was using Cofree's coiter function to build a complete game tree.
14:05:01 <monochrom> I don't think you should think of it as "a function in a record".  The record has only one field, and that field is that function.  So it's more like the special case of "a wrapper so I have a new-and-shorter name for this type".
14:05:28 <c_wraith> mitchellsalad__, the FFI doesn't support that. you'll need to have C shims that use pointers in their interface
14:05:37 <mitchellsalad__> Poop.
14:05:47 <monochrom> And also maybe "eventually I'll make it an abstract type and change implementation details this is why I add this layer of wrapping".
14:07:50 <mitchellsalad__> That's really annoying for wrapping C libraries that use single element structs as a poor man's newtype, relying on gcc's -O to make it a zero cost abstraction
14:08:31 <monochrom> You will have to manually write code to marshall your C struct to your Haskell-side type.  And yes it's manual because there are a few design choices you have to make.
14:08:38 <rfold> leshow: I sometimes find it confusing because given newtype A = A { runA :: Int -> Bool }, the type of runA isn't Int -> Bool, it's A -> Int -> Bool.
14:08:43 <Younder> Being a mathematician is something beautiful. Like the writer of classic songs that everyone hums to. I hope someday they will recognize what we are and what we do for society. As for now we are the invisible culture.
14:09:00 <leshow> rfold: yes I just had to remind myself of that
14:09:13 <leshow> sometimes the GADT definitions for things is more clear
14:09:32 <geekosaur> plus only the c compiler has any clue how to do structs by value as parameters, and even more so as returns
14:09:33 <monochrom> Well, it is not like "newtype B = B { runB :: Int }" implies runB :: Int.
14:09:52 <rfold> leshow: GADT syntax doesn't help here, unfortunately. It would be: newtype A where A :: { runA :: Int -> Bool } -> A
14:09:55 <monochrom> Like, if you are confused, you should be confused by all of record syntax.  All of it.
14:10:10 <Younder> I had had success in music as well. THERE I am remebr
14:10:24 <Younder> remebered..
14:10:38 <leshow> monochrom: no, just this
14:10:38 <monochrom> Younder, this channel is not your personal blog.  Go create your own channel.
14:11:39 <Younder> monochrom, rlol, true.. I just feel we should take pride in our work.
14:14:01 <rfold> Does MonomorphismRestriction still make sense if you have MonoLocalBinds enabled and add signatures to all globals?
14:15:12 <monochrom> Probably just throw it in for paranoia.
14:16:04 <dmwit> The monomorphism restriction is moot, on or off, if you add signatures to all top-level definitions.
14:16:20 <Younder> This all makes more sense if you regard types as spaces. As one does in homotopy type theory.
14:16:23 <dmwit> I don't think MonoLocalBinds being either on or off affects this claim.
14:16:55 <koz_> Aww, leshow's gone.
14:16:58 <koz_> Oh well.
14:18:08 <rfold> dmwit: the monomorphism restriction also applies to let bindins, though. Compare: https://glot.io/snippets/f73s4uhyh9 vs https://glot.io/snippets/f73s4ka8vp
14:19:27 <rfold> But with MonoLocalBinds, the binding would be monomorphic even with NoMonomorphismRestriction.
14:19:29 <dmwit> Okay, I am wrong.
14:19:43 <Younder> I mean the use of lattices in NVIDEA's latest RTX release is brilliant (AMS). But I think we all know beyond 8 bit integer approximations to rays there is a whole world.
14:20:03 <berndl> I still don't understand the monomorphism restriction.
14:20:14 <dmwit> Apparently neither do I. =P
14:20:21 <dmwit> And I've answered many questions about it.
14:20:34 <rfold> But since I have GADTs in my default extensions, and it implies MonoLocalBinds, I think I can just not worry about the monomorphism restriction at all.
14:20:54 <rfold> berndl: what would you like to know about it?
14:21:01 <berndl> Sometimes I write a function on lists in point-free style and GHC won't compile it until I add an actual argument.
14:21:16 <berndl> I presume this is because of the monomorphism restriction.
14:22:44 <MarcelineVQ> koz_: I'm still working on it, fwiw
14:22:47 <Younder> Learn algebraic topology and monomorphism and a few other terms will become clear. The problem Haskellers have is that they expect non mathematicians to know what they are talking about.
14:22:49 <dmwit> Most likely, yes. If you prefer, adding a type signature should work as an alternative to adding an argument.
14:23:09 <koz_> MarcelineVQ: Working on what>?
14:23:28 <MarcelineVQ> Younder: the monomorphism restriction is not related to topology, it's a rule in ghc
14:23:46 <MarcelineVQ> koz_: making tictactoe in function form
14:24:05 <koz_> MarcelineVQ: Ah.
14:24:32 <berndl> monomorphims restriction should be called nonpolymorphism restriction.
14:24:46 <MarcelineVQ> While the book is specific in that it's not for beginners there is a bit of a dissonance here for me between "making this change, we are rewarded with the entire toolbox of combinators for working with functions; we gain better compositionality and have to pay less of a cognitive burden. ... Your colleagues and collaborators will thank you later!"  and  "how do I use this?"  :(
14:25:15 <zachk> I think it is from monomorphisms, epimorphisms, and isomorphisms in category theory 
14:25:23 <Younder> MarcelineVQ, yes, and no. The terminology is borrowed from topology. And to really understand it you need to know Homotopy.
14:25:25 <koz_> MarcelineVQ: I'm gonna send a few corrections to Sandy when this migraine dies down.
14:25:36 <koz_> Right now I'm basically useless for anything except writing stupid parallel array code.
14:25:51 <MarcelineVQ> To understand it you need to read the wiki page on it, https://wiki.haskell.org/Monomorphism_restriction
14:26:06 <shapr> I'm a shaprmorphism
14:26:37 <aplainzetakind> Younder: monomorphism in mathematics usually means a bijection.
14:26:38 <aplainzetakind> 'usually' here means pretty much always, allowing room for possibly existing uncommon conventions.
14:26:39 <monochrom> This is the disease of math enthusiasists who have newly get acquainted and over-excited with an advanced area.
14:27:10 <Younder> or one to one and onto
14:27:13 <lavalike> can't spell 'a morphism' without 'shapr'
14:27:39 <monochrom> I know because I was one of them. Right after you have learned a thing or two about complex numbers, you will shout "everyone should learn complex numbers before learning whole numbers, everything makes so much more sense now".
14:27:51 <monochrom> No, everything makes no sense in that order.
14:28:01 <berndl> aplainzetakind: not really. If you're working in the category Set, monomorphisms are injections.
14:28:08 <Younder> mappings between spaces spell hotopy, which work and which don't. Thus the base for types.
14:28:38 <Younder> homotopy
14:29:21 <dmwit> aplainzetakind: Perhaps you're thinking of "isomorphism" instead of "monomorphism".
14:29:56 <Younder> I am thinking of the univalence theorem
14:31:01 <berndl> As I understand it, univalence is an axiom, not a theorem.
14:31:48 <monochrom> Now let's also argue whether a square is a rectangle.
14:32:15 <Younder> I refer to Bullitin of AMS  october.Daniel R. Grayson.
14:32:33 <dmwit> Neat. "The inclusion Z -> Q is both a monomorphism and epimorphism in the category Ring, ... but not an isomorphism." https://math.stackexchange.com/q/266886/139921
14:33:03 <dmwit> But I am straying far from the official topic of #haskell.
14:33:38 <aplainzetakind> What did I miss?
14:34:00 <monochrom> off-topic ramblings that should go to personal tweeter accounts instead.
14:34:03 <dmwit> There are logs in the topic. =)
14:34:16 <dmwit> Mmm... there is a link to logs in the topic, anyway.
14:34:34 <aplainzetakind> dmwit: Thanks, didn't realize that.
14:34:50 <Younder> Seriously, Haskell is confuses things by not seeing types as spaces. This SIMPLIFIES things. It was areal revelation to me.
14:35:53 <monochrom> No, wrong assumptions confuse things.
14:36:31 <monochrom> Haskell is a programming language.  Mistaking it for a foundation of mathematics is your source of confusion.
14:36:52 <shachaf> Did you know: "f is mono" means "(f .) is injective"; "f is epi" means "(. f) is injective"
14:36:54 <monochrom> Conversely, mistaking HoTT for a programming language will bite you one day, too.
14:37:08 <shachaf> "f is split mono" means "(. f) is surjective"; "f is split epi" means "(f .) is surjective"
14:37:20 <Younder> Sigh, just look up http:/homotoytype theory.org/book
14:37:30 <aplainzetakind> berndl: So they are always one to one maps, perhaps preserving more structure when relevant to the category.
14:37:31 <Younder> no stace
14:37:34 <shachaf> mono + split epi, or epi + split mono, gives you iso
14:37:37 <lavalike> shachaf: what's (f .) is bijective and (. f) is bijective
14:37:50 <berndl> monochrom: so mistaking lambda calculus for a programming language will also bite you?
14:38:21 <aplainzetakind> Those category theoretical terms don't have anything to do with the monomorphism restriction, which is mono- as opposed to polymorphism as a programming language concept.
14:38:30 <aplainzetakind> So learning algebraic topology would be quite irrelevant.
14:38:56 <shachaf> lavalike: Those are both iso, by combining the things I said.
14:39:07 <berndl> aplainzetakind: that's why I suggested it should be called the nonpolymorphism restriction.
14:39:52 <monochrom> berndl: That will have to be refined to "practical programming language" vs "theoretical programming language".
14:40:03 <aplainzetakind> berndl: I'd second that.
14:40:36 <shachaf> In Set, every mono is automatically split, so mono + epi = iso
14:40:39 <monochrom> And also refined to, for example, which corner of the lambda cube do you want?
14:40:49 <shachaf> The axiom of choice says that every epi is also split.
14:41:00 <Younder> It always bothered me. That ZF set theory.Because you can do do the same with classes. If the class is different from the object then the Russel paradox doesn't occur.
14:42:30 <Younder> Simple classes are different from objects
14:42:59 <berndl> Younder: what?
14:43:25 <Younder> The the class set is different from the instance class
14:43:49 <Younder> The the class 'Set' is different from the instance of 'Set'
14:43:58 <berndl> monochrom: unfortunately, the lambda cube doesn't even include have anything supporting inductive types...
14:44:32 <monochrom> Yes. That's just an example.
14:44:34 <berndl> Younder: first of all, ZF has no notion of classes.
14:44:45 <monochrom> perhaps s/Yes/Right/
14:45:45 <monochrom> I hate English.
14:46:39 <Younder> berndl, No, So I will refer you to  'Topoi The catagorical analysis of logic' by Robert Goldblat
14:48:43 <dmwit> shachaf: Yes, that one (axiom of choice <-> every epi splits) was quite an eye-opener the first time I unpacked it.
14:48:50 <berndl> Younder: classes are an informal notion. It is not a notion in ZF. See e.g. page 5 from Set Theory by Jech.
14:49:09 <koz_> You need NBG or something for a formal treatment of classes as their own thing IIRC.
14:49:24 <berndl> koz_: correct.
14:49:27 <Younder> Classesare not and informal notion. They are as rigorous as stes
14:49:31 <Younder> sets
14:50:21 <shachaf> dmwit: I remember!
14:50:52 <monochrom> This is just cause for me to like the axiom of choice. (I have always liked it.) It completes a symmetry. Both monos and epis are split now. The world is more fair this way.
14:51:45 <shachaf> dmwit: In some sense it expresses the axiom of choice better than a lot of formulations, I think.
14:51:56 <shachaf> I mean, when you remove all the category nonsense from it and just talk about sets.
14:52:05 <shachaf> I don't really know how it generalized to other categories.
14:52:07 <dmwit> I agree. It's got that je ne se quois of category theory that makes it compact and general.
14:52:44 <monochrom> Now I have to learn French too.  In addition to category theory.  Damn.
14:52:44 <dmwit> monochrom: "fair"?! How very unlike you. =)
14:53:06 <dmwit> It's got that I-don't-know-what of category theory...
14:53:15 <berndl> I like the version of the axiom of choice that says that every product of a nonempty family of sets has a member.
14:53:42 <dmwit> That can't be right.
14:53:50 <shachaf> dmwit: I don't think "every surjection has a right inverse" loses much.
14:53:57 <monochrom> Ah dmwit, I think it's the pointfreeness.
14:53:59 <dmwit> The product of the nonempty family that has just the empty set doesn't have a member.
14:54:07 <shachaf> Except "right inverse" is a really bad confusing name.
14:54:22 <shachaf> "every surjection is a retraction"?
14:54:28 <aplainzetakind> "family of nonempty sets"
14:54:34 <berndl> dmwit: oops, I meant ^
14:54:43 <monochrom> But I can never remember what retraction is. :)
14:55:37 <shachaf> monochrom: You can look at this picture to remember: https://upload.wikimedia.org/wikipedia/commons/9/90/Bundle_section.svg
14:55:39 <monochrom> Also which side is "right" for right inverse.
14:56:38 <shachaf> If you embed the smaller thing into the larger thing injectively, it specifies some cross section of it.
14:56:43 <shachaf> (Of the larger thing.)
14:56:46 <berndl> a retraction is almost like the dual of an injection.
14:57:19 <shachaf> Then a retraction takes the larger thing back into the smaller thing such that points in the cross section go back to where they were.
14:57:27 <monochrom> Sorry shachaf I have been TAing a computer graphics course this term so when I see that picture all I can think of is "w00t parametrization of a 2D surface and hey how do I compute surface normals and texture mapping there?" also it won't help that next term I want to sit in in a differential geometry and general relativity course.
14:59:09 <monochrom> Ah OK I see.
15:00:40 <Younder> In 2D all yo need to worry about is arc parametirization, angle and curvature. So it is relativitysimple.
15:02:54 <Younder> Manfredo P. do Cramo ' Differential geometry of curves and surfaces' chapter 1Curves and 2 regular surfaces
15:03:56 <infinisil> Hey, I need my Haskell application to listen to a port and reply with an html document whenever somebody asks via http
15:04:14 <Younder> Diff. geom. in 2D can basically be covered in a 100 pages
15:04:15 <zachk> infinisil, look at scotty to do that simply 
15:04:16 <infinisil> What's the easiest way to achieve this?
15:04:26 <infinisil> zachk: Thanks will check it out
15:05:16 <monochrom> If it's always the same html "document" I would just write a simple loop based on Network.Socket and also hardcode the document.
15:05:44 <infinisil> monochrom: It changes over time
15:05:50 <monochrom> In fact if someone has already set up apache with CGI support I would just write a shell script for that.
15:06:21 <infinisil> It's a html document generated by some state in the program
15:06:40 <boj> infinisil: scotty is a fine choice. i'd try that until you feel you need more power
15:06:54 <infinisil> Yeah scotty looks perfect, thanks :)
15:07:19 <infinisil> And I'll use https://hackage.haskell.org/package/blaze-html for generating the html
15:07:36 <monochrom> OK my approach also requires hardcoding http headers which might be too inflexible.
15:07:51 <boj> infinisil: good plan. maybe compare it to lucid, slightly different api
15:08:10 --- mode: glguy set +v PatrickRobotham
15:08:10 <infinisil> Ah I think I've heard of lucid before
15:09:50 <zachk> is there a way to start ghci with a flag so it doesnt need gmp?
15:10:19 <infinisil> boj: If you know both, what do you prefer?
15:10:35 <infinisil> blaze-html looks a bit better on first sight
15:10:40 <infinisil> imo
15:11:16 <monochrom> zachk: I think no. You have to build GHC and tell the builder you don't want gmp.
15:11:24 <boj> infinisil: i don't actually use either, so no opinion :)
15:11:43 <infinisil> Ahhh: https://chrisdone.com/posts/lucid
15:11:45 <monochrom> IIRC the thing you can use to replace gmp is something called "integer-simple" along that line.
15:11:48 <infinisil> I read that blog post before
15:11:55 <infinisil> It mentions some problems with blaze
15:12:11 <infinisil> I guess I'll go with lucid then, seems to be also maintained
15:12:13 <monochrom> IMO unless you're paid $1000 to do it you shouldn't bother.
15:13:20 <Younder> Never be afraid to do the math.
15:15:32 <marvin2>  
15:17:08 --- mode: glguy set +v neobrain
15:17:16 <infinisil> marvin2: I'll have to agree with you there
15:17:19 <neobrain> infinisil: as for the actual server part, see http://snapframework.com/docs/tutorials/snap-api#hello-snap
15:18:16 <neobrain> I'm using snap with lucid for some stuff, it's great. That said, snap also has a serveFile function that just sends a local html file to clients
15:19:43 <neobrain> (I still usually prefer the rapid change-and-see-the-change cycles of plain html files, even though they aren't compile-time checked like documents generated by Lucid would be)
15:19:45 <MarcelineVQ> you can use wai-middleware-static to add that sort of functionality to many haskell server libs
15:20:18 <Younder> Is Simmon P Jones still on this group?
15:21:02 --- mode: glguy set +v taktoa_
15:21:28 <Younder> Very well
15:21:54 <taktoa_> anyone know if there's a programmatic way to ask the GHC runtime system how many threads (not capabilities, but forkIOed threads) are currently running?
15:22:07 <monochrom> I think no.
15:23:04 <Younder> If you are in linux from the caoomand line run htop (in debian)
15:23:16 <Younder> comand
15:23:30 <taktoa_> htop lists the number of OS threads, not the number of forkIOed green threads
15:23:50 <taktoa_> (capabilities are OS threads)
15:23:51 <Younder> depends on the setup
15:23:51 <infinisil> There's a reddit thread of people discussing different web frameworks: https://www.reddit.com/r/haskell/comments/78k3af/servant_scotty_or_snap/
15:24:00 <infinisil> There's so many..
15:24:15 <infinisil> I guess I'll still go with scotty though, seems rather minimal
15:24:17 <Younder> They have to be oS treads though
15:24:39 <taktoa_> no they don't, Haskell has a userspace scheduler
15:25:14 <Younder> taktoa_, for htop, not Haskell
15:26:42 <taktoa_> Younder, I asked about number of Haskell threads, not number of OS threads. Since there can be arbitrarily many Haskell threads on one OS thread, htop is not relevant.
15:26:51 <infinisil> neobrain: I'll keep snap in mind if I need something more advanced though
15:27:11 <taktoa_> I don't recommend snap personally; I much prefer servant
15:27:27 <aplainzetakind> Calling :info does not tell me the fixity of (*>) and (<*).
15:28:00 <monochrom> In that case maybe the default fixity is used. infixl 9 is it?
15:29:02 <monochrom> Yeah, default is infixl 9.
15:29:13 <Younder> These micro-threads are of a granularity which is inefficient for a i7 processor to use. Desist and use threads.
15:29:54 <bsima> taktoa_: you could use https://hackage.haskell.org/package/ekg
15:29:59 <MarcelineVQ> monochrom: they're both infixl 4 though, his ghci is not saying that for some reason
15:31:35 <monochrom> Strange.
15:32:58 <aplainzetakind> OK I'm in stack ghci in the nicta course folder, and the standard library ones are overridden. My eyes glazed over the `defined at` line at first.
15:33:14 <monochrom> Heh
15:52:19 <MarcelineVQ> Could someone link me to a good free monad tutorial/resource? Preferably for haskell, but whatever you have that's best.
15:57:38 <boj> MarcelineVQ: this was interesting, if not basic http://shmish111.github.io/2018/09/23/freer-than-free/
15:57:53 <boj> uses lexi-lambda's freer-simple library
15:58:32 <boj> free vs freer, of course. if you mean free-with-functors then this is not it
15:58:56 <MarcelineVQ> thank you, I don't know the difference currently
15:59:22 <MarcelineVQ> But will in the near future
15:59:23 <boj> i could barely explain it myself :)
16:00:56 <boj> i think the bottom line is that free monads are based on functors, and are slow. freer utilizes GADTs, and is faster, but still not as fast as mtl-style code when it comes to compiler optimizations
16:01:43 <boj> and something something algebras something
16:02:46 <_deepfire> is there a tool that would minimise a module, while maintaining a particular compiler error message?
16:03:06 <boj> MarcelineVQ: possibly this from the master himself http://okmij.org/ftp/Haskell/extensible/index.html
16:03:11 <MarcelineVQ> _deepfire: that sounds really useful
16:03:13 <_deepfire> I find myself wanting such a thing every other week..
16:04:24 <MarcelineVQ> boj: oh is it extensible effects? Someone is working on an idris package manager that uses the freer concept so I'd like to understand these things. extensible effects makes sense there since you can track things clearly in types.
16:04:37 <lavalike> MarcelineVQ: this is pretty good https://ocharles.org.uk/posts/2016-01-26-transformers-free-monads-mtl-laws.html
16:04:41 <boj> yep, that is the keyword you probably want
16:05:15 <MarcelineVQ> These are enough to get going. There's code I can just look at but I like to try implementing things I see first.
16:05:32 <MarcelineVQ> idk if it actually helps :> but it's fun
16:05:41 <boj> i was tinkering with it last month https://github.com/alasconnect/freer-experiment
16:05:58 <boj> yeah, interesting stuff
16:06:08 <_deepfire> In fact, I wonder if such an erring-module-minimiser thing would make sense to build into GHC.
16:07:17 <MarcelineVQ> _deepfire: it would make more sense as a plugin provided by a seperate package, but yeah you'd probably want to utilise ghc for the job
16:07:27 * _deepfire fancies GHC running this minimiser when it detects itself panicking..
16:07:51 <MarcelineVQ> Actually plugin might be too deep come to think of it, plugins are for core, hmm
16:08:57 <dmwit> I think modern GHCs have a way for a plugin to sit after the parser but before any other phase. So that's probably exactly the right place.
16:09:03 <_deepfire> MarcelineVQ: I'm also imagining how GHC/Haskell could be made more approachable to beginners -- where they could be automatically presented with minimal explanation of their mistake..
16:09:51 <dmwit> Anyway the whole thing sounds significantly bigger than a weekend hack. So unless you can find a source that wants to fund it it probably won't happen. =(
16:10:48 <MarcelineVQ> boj: is your middle name osmium?
16:11:07 * _deepfire thinks of Bank Of Japan
16:14:50 * _deepfire wonders about the potential strategies for trimming the module AST..  could be brute-force random pruning, also could be something that involves finding provably irrelevant stuff..
16:16:05 <boj> MarcelineVQ: nope :)
16:16:28 <_deepfire> provable irrelevance can be hard for the totality of language constructs, but as far as it goes, it could probably prune most irrelevant stuff quickly..
16:16:57 <_deepfire> ..at which point a handover to random pruning could happen
16:17:33 <_deepfire> but also provable irrelevance would require "understanding" the error messages
16:17:49 <_deepfire> which seems prohibitive..
16:18:32 <_deepfire> ..or maybe we could instrument the compiler error emission sites with information to prime the guided pruning
16:19:43 <_deepfire> that still seems heavy, of course..
16:19:44 <monochrom> I would write short modules in the first place.
16:20:03 <_deepfire> well, sometimes we don't have the luxury -- but also
16:20:29 <_deepfire> wouldn't we like to merge the modules, to get a whole-program picture of the error?
16:20:48 <_deepfire> short modules kind of defeat this
16:21:36 * _deepfire is leaning towards the random pruning approach for the PoC
16:21:57 <monochrom> I already did that. Not to programs, but to social problems.  Human problems are caused by humans.  Holistic view.
16:22:43 <monochrom> It implies the solution of just nuking whole humanity and be done with it.  Applied to programs, just nuke the whole code repo. >:)
16:23:17 <_deepfire> I have a close friend who shares this kind of mindset : -)
16:32:10 <aplainzetakind> @pl \f g -> \x -> f x >>= pure . g
16:32:10 <lambdabot> (. (pure .)) . flip . ((>>=) .)
16:33:32 <_deepfire> another problem is maintaining validity of bindings, i.e. not shooting ourselves in the foot
16:35:07 <_deepfire> that limits the simplicity of random pruning approach a lot
16:36:13 <_deepfire> one thing that can be used pretty effectively, I guess, is riding on the -Wunused, with an empty export list
16:36:53 <_deepfire> given it's _already_ transitive, that should be a blast for dropping most irrelevant stuff quickly
16:38:09 <_deepfire> but that's just an efficiency hack, since after that we're back to random pruning that needs to maintain bindings
16:44:00 <_deepfire> dmwit: do you think there is an up-to-date overview of GHC plugin API/infrastructure?
16:46:24 <_deepfire> https://ghc.haskell.org/trac/ghc/wiki/NewPlugins mentions 7.2.1, which gives me a scare..
16:47:43 <_deepfire> there's also https://downloads.haskell.org/~ghc/master/users-guide/extending_ghc.html#compiler-plugins, which is probably a good start..
16:48:18 <dmwit> _deepfire: Everything I know I learned from the GHC manual. But that's not saying much because I know very little.
16:50:39 <_deepfire> That's still a good recommendation, thank you!
16:51:22 <MarcelineVQ> _deepfire: aside from the manual possibly the most up to date reference for plugins will be reading other people's
16:52:00 <MarcelineVQ> I think hvr had a couple, ezyang too maybe, hmm... There's some hackage packages that also provide plugins but I don't know them offhand.
16:52:26 <MarcelineVQ> type solvers are more common than others
16:52:33 <_deepfire> MarcelineVQ: that is definitely a useful resource, I agree.. but in exploratory scenarios one often wants to know about ALL available options, not SOME
16:52:58 * _deepfire almost used a reference to forall/exists
16:53:03 <MarcelineVQ> An often overlooked resrouce are ghc trac's, about the feature in question
16:54:41 <_deepfire> I'll have a look at that, thank you! : -)
16:55:43 <monochrom> I know that feeling. During Steam sales I buy all games on sale.
16:56:01 <monochrom> But right after the reality sets in that I don't actually have time to play them.
16:56:16 <_deepfire> ..I have the exact same syndrome..
16:57:43 <MarcelineVQ> _deepfire: this kind of trac search is what I was thnking of https://tinyurl.com/yaccn7ut  though idk how useful it is for this exact subject
16:59:00 <_deepfire> MarcelineVQ: aha!  It looks helpful, indeed.. thank you! : -)
17:01:54 <_deepfire> all feature requests for plugins -- that nicely correlates with the boundary of what's possible
17:02:40 <MarcelineVQ> Also, phab links in tracs link to the actual code that's been changed. These will often include code comments worth reading
17:03:17 <MarcelineVQ> Which are available in the ghc source code as well, but might not be so easy to track down, dunno
17:03:39 <MarcelineVQ> Once you've located the modules responsible it shouldn't be too hard to find commentary in them
17:04:11 <MarcelineVQ> Many comments in ghc include their trac ticket number, so a person can search the ghc codebase with that
17:04:33 * hackage waargonaut 0.4.2.0 - JSON wrangling  http://hackage.haskell.org/package/waargonaut-0.4.2.0 (schalmers)
17:04:35 <MarcelineVQ> like  https://ghc.haskell.org/trac/ghc/ticket/11194  might show as  #11194  in a code comment
17:07:58 <teto> I am trying to run $cabal v1-update on nix to solve a "Can't unpack optparse-applicative-0.14.3.0" problem but it gives "Warning: No remote package servers have been specified". Any idea ?
17:08:53 <teto> more details at https://github.com/grwlf/haskdogs/issues/4#issuecomment-442359789
17:11:51 <monochrom> Haha "JSON wrangling".  Haskell programming has just become too violent.  I need a drink.
17:12:04 <monochrom> Or is it web programming that's violent?
17:13:38 <geekosaur> have you ever looked at web javascript?
17:13:45 <_deepfire> MarcelineVQ: thank you once more!
17:14:00 <hpc> have you ever looked at server javascript?
17:14:54 <_deepfire> why, with us having GHCJS.. it's like looking at assembly..
17:15:33 <hpc> oh snap
17:31:09 <c_wraith> https://kcsongor.github.io/symbol-parsing-haskell/ is horrifying and beautiful and we *so very much* need better tools for working with Symbol
17:32:10 <c_wraith> but hey, it lets you write type-safe printf (format string at the type level) with today's ghc...
17:40:03 * hackage ftp-client 0.5.1.1 - Transfer files with FTP and FTPS  http://hackage.haskell.org/package/ftp-client-0.5.1.1 (miscyb)
17:41:03 * hackage ftp-client-conduit 0.5.0.4 - Transfer file with FTP and FTPS with Conduit  http://hackage.haskell.org/package/ftp-client-conduit-0.5.0.4 (miscyb)
18:09:15 <_deepfire> c_wraith: horrifying and lovely, indeed..
18:09:36 <_deepfire> ..and yes, compiler support..
18:46:52 <jlamothe> Is there a way to override stdin/stdout on an IO a for unit testing purposes?
18:51:50 <jlamothe> Normally, I try to keep my IO functions minimal, but that approach doesn't make sense in this case.
19:10:13 <lyxia> you can generalize your functions so they don't use IO directly
19:10:44 <lyxia> as in, instead of writing   f = putStrLn "Hello"   you write   f psl = psl "Hello"
19:11:06 <lyxia> then your application can use f puStrLn, and your unit test can use  f mockPutStrLn
19:14:40 <teto> wow that's cool https://haskell-code-explorer.mfix.io
19:15:46 <celphi> can someone explain this to me? im noob
19:15:48 <celphi> https://wandbox.org/permlink/OPMtl5I2gemKq72g
19:16:28 <MarcelineVQ> teto: pretty cool
19:17:12 <celphi> The site im learning from says the format is:
19:17:28 <teto> MarcelineVQ: now if I could only get similar functionalities in neovim
19:17:29 <celphi> output | input, predicate
19:17:46 <geekosaur> celphi: produce adjective ++ " " ++ noun, for every "adjective" from the list "adjectives" and every "noun" from the list "nouns"
19:18:27 <celphi> but how does that fall into "output | input, predicate"
19:18:50 <jackdk> adjective ++ " " ++ noun is the output
19:18:52 <geekosaur> "predicate" is missing here
19:18:59 <jackdk> predicate is empty so the , can be elided
19:19:13 <jackdk> the rest is input
19:19:19 <geekosaur> it's optional, without it all values are produced. you can use it to specify wich valeus to accept
19:19:29 <celphi> how come the the 2nd , isn't the predicate?
19:19:58 <celphi> ", noun <- nouns" this part
19:20:27 <jackdk> because it's another generator, which I believe is determined because it has the <-
19:21:09 <celphi> oh so the "<-" symbol means it's part of the input?
19:22:53 <celphi> thanks- that makes sense to me.
19:23:28 <MarcelineVQ> celphi: that link gives me various errors, do you have an error with that code?
19:24:38 <celphi> it's not valid run code. it's just a editor i pasted my code in.
19:24:49 <MarcelineVQ> alrighty
19:24:56 <geekosaur> you can read '<-' as 'from'
19:25:03 <geekosaur> or 'taken from'
19:25:07 <celphi> im still noob running code in ghci
19:25:19 <celphi> thanks geek
19:26:01 <celphi> im learning from http://learnyouahaskell.com
19:26:07 <celphi> so ill likely ask lots of Qs
19:26:45 <jackdk> if you've seen formal language docs before, the haskell report describes the precise syntax of list comprehensions here: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11
19:27:08 <jackdk> and it is correct to say <- is what makes it a generator, or what LYAH seems to call "part of the input"
19:27:35 <MarcelineVQ> celphi: check out https://en.wikibooks.org/wiki/Haskell if learnyouahaskell gets confusing
19:28:05 <celphi> right on- thnx!
19:28:42 --- mode: glguy set +v pittma[m]_
19:29:04 * hackage lrucache 1.2.0.1 - a simple, pure LRU cache  http://hackage.haskell.org/package/lrucache-1.2.0.1 (CarlHowells)
19:30:09 --- mode: glguy set +v pittma_[m]
19:30:21 <pierrot> *4
19:59:48 --- mode: glguy set +v fen
19:59:52 <piyush-kurur> I vaguely remember someone had a writeup on creating a docker instance suitable for artifact evaluation (haskell related). Can any one point it out to me ?
20:00:21 <c_wraith> that sounds like something fpcomplete would have made
20:00:24 <fen> is there a way (DerivingVia) to implement superclasses at the subclass instance implementation?
20:00:36 <c_wraith> maybe https://www.fpcomplete.com/blog/2017/12/building-haskell-apps-with-docker ?
20:01:30 <piyush-kurur> c_wraith: thanks but I was looking for a cabal new-build based one. So may be I will just follow along and make appropriate changes 
20:01:51 <c_wraith> oh.  well then it certainly wasn't fpcomplete.  they pretend cabal doesn't exist. :)
20:02:28 <piyush-kurur> ;-)
20:02:37 <fen> vaguely remember something about using UndecidableInstances to do this was a bad idea, cant recall why though.
20:02:48 <piyush-kurur> c_wraith: I think I got the one I was looking it is by mpickering 
20:02:57 <c_wraith> cool.  glad you found it
20:02:57 <piyush-kurur> he uses nix not cabal new-build
20:03:07 <piyush-kurur> http://mpickering.github.io/posts/2018-09-19-nix-artefacts.html
20:03:43 <piyush-kurur> okey nix is one of the things i know I should be doing but cannot get my act together :-(
20:04:20 <fen> seems like when a superclass can be instantiated by a subclass it should be. possibly it was something to do with needing the user to "ok" this, in the sense that they confirm that it is the desired implementation. and maybe something like how foldr can be faster than foldMapDefault as an implementation of the trivial superclass "Foldable" of Traversable
20:04:24 <c_wraith> I really like the idea of nix, but every time I try it I discover I have misunderstood some important detail and nothing I've done will work.  Then I go back to cabal.
20:04:45 <celphi> ok can i get some explanation here?
20:04:45 <celphi> https://wandbox.org/permlink/yNFQGWqlX0z8sTcm
20:04:45 <celphi>  [ [ x | x <- xs, even x ] | xs <- xxs] 
20:04:45 <celphi> is there two outputs here?
20:05:08 <fen> outputs?
20:05:30 <celphi> yeah site says left of pipe is output
20:05:47 <fen> well there are two <- symbols if thats what you mean
20:05:48 <celphi> output | input, predicate
20:05:58 <fen> oh, well two | then
20:06:09 <celphi> yeah- so that means two outputs?
20:06:17 <fen> its your definition
20:06:41 <celphi> gotcha- guess it's not universal
20:07:10 <fen> well set builder notation is the underlying foundation 
20:07:13 <c_wraith> celphi: it's nested.
20:07:25 <fen> not sure that term is drawn from that tradition
20:07:29 <c_wraith> celphi: [ expr | xs <- xxs ]
20:07:52 <c_wraith> celphi: expr can be *any* expression.  In this case, it's another list comprehension
20:08:22 <fen> :t [x | x <- [ y | [x,y]]]
20:08:24 <lambdabot> error:
20:08:24 <lambdabot>     • Couldn't match expected type ‘Bool’ with actual type ‘[Expr]’
20:08:24 <lambdabot>     • In the expression: [x, y]
20:08:25 <celphi> how come the result are lists and not one list?
20:08:36 <fen> :t [x | x <- [ y | y <- [x,y]]]
20:08:38 <lambdabot> [Expr]
20:09:07 <c_wraith> celphi: because a list comprehension creates a list.  So the outer list comprehension creates a list of whatever expr creates.  and expr creates a list of values
20:09:19 <celphi> oh
20:09:22 <fen> because the value in the list is a list
20:09:43 <celphi> cool! thanks peeps!
20:09:57 <celphi> srry for being a noob.
20:10:06 <c_wraith> celphi: I kind of dislike list comprehensions.  I think they're overused in beginner materials.  I'd write that as map (filter even) xxs
20:10:08 <koz_> celphi: Don't apologize for not knowing. We all started somewhere.
20:10:26 <celphi> :)
20:10:31 <fen> Solonarv: is there a chance of getting classes at type level to make an API for trivial superclasses?
20:10:49 --- mode: glguy set +v Levy[m]
20:10:56 <c_wraith> Yeah, learning is awesome.  Not knowing is a great place to start learning. :)
20:11:45 <fen> its good for students that have recently received an introduction to set theory, or are used to that notation from maths
20:11:56 <jackdk> I agree with c_wraith and downplay list comprehensions when I teach haskell
20:12:14 <koz_> It can also sometimes be more concise than the equivalent chain of functions. But I will echo both c_wraith and jackdk.
20:12:36 <fen> wonder if it works for shaped containers...
20:13:07 <fen> it embodies traversal
20:13:14 <fen> maybe there is a varient for zipper...
20:13:24 <fen> somewhere in yet to be written syntax land
20:13:55 <fen> anyway nvm. 
20:14:19 <fen> its super confusing to mix trivial and regular superclasses up in complex class hierarchies 
20:15:09 <fen> if it means having to avoid the haskell class system and do it all with something like extensible records it would be overkill
20:15:16 <fen> there must be a happy medium?
20:15:52 <fen> is there a ghc trac for this?
20:17:22 <fen> there is much talk about it online over the years, but there seems to be no real evidence it is being incorperated into GHC any time soon... unless there is, but its just eluding searches
20:19:52 <fen> eg a type synonym, such as for Get+Set gives a whole bunch of trivial superclasses that result from defaults for the classdefining functions that have a (Get f,Set f) constraint. this means the class synonym of (Get f,Set f) then also has all those other classes, and its not clear to the user which they have to implement and which are resulting
20:20:46 <fen> type Linear f = (Get f,Set f,Traversable,MonadPlus)
20:20:53 <fen> (foldable monoids are monads?)
20:21:04 <fen> type Linear f = (Get f,Set f,Traversable f,MonadPlus f)
20:21:42 <fen> here the user should implement all these classes, but Get and Set are "sufficeint" while Traversable and MonadPlus are "trivial" 
20:22:13 <fen> which is totally unclear from the type synonym
20:22:40 <fen> Get + Set `entails` Traversable + MonadPlus
20:22:55 <fen> maybe there is something in Constraints that can do this?
20:23:02 <fen> or something that could be made which does
20:23:59 <fen> clearly this isnt what DerivingVia is for...
20:26:08 <fen> there are even proposals for overriding superclass functions at the subclass, but the closest we have is default which appears at the superclass
20:28:01 <fen> this is no good for adding constraints togeter to satisfy others. which would the default go in? e.g. Get could have a default implementation for traverse at its class declaration, which relied on Set being implemented, but then this would work the other way round, with the same defualt appearing in the Set class with a Get constraint
20:28:40 <fen> wait is that how it works?
20:29:22 <fen> anyway it would make more sense if it could be that a class synonym could override some of its superclass implementations
20:30:00 <fen> why isnt this part of GHC?
20:30:13 <fen> is there some theory behind why this cant or shouldnt be done?
20:30:25 <fen> its been proposed so many times...
20:32:44 <geekosaur> in part this is why "superclass" is the wrong word
20:35:16 <fen> what so Foldable isnt a "superclass" of Traversable?
20:35:27 <geekosaur> "prerequisite" is a better word
20:35:40 <fen> what about "trivial superclass"?
20:35:44 <geekosaur> "suprclass" leads to what your;'e doing: tryingt ot reat ti as OOP inheritance.
20:35:55 <geekosaur> that turns outto make the type system unsafe
20:36:11 <fen> meaning it has a default implementation in terms of the "sufficient" subclass
20:36:26 <geekosaur> for whatever reason, ghc docs insist on calling it using OOP terms
20:37:01 <fen> they dont own the terms class or the meanings of supper/sub
20:37:19 <fen> not sure about why its not type safe
20:37:39 <fen> its like an entailment proof, which is why derivingvia was mentioned
20:38:03 <geekosaur> this stops whoe xactly? every language has its abuse of terms that mean something else in some other language. not to say pretty much every branch of mathematics "abusing" terms that mean something lse in another bran ch
20:38:07 <fen> like instance Ord a => Ord f a can be derived
20:38:43 <geekosaur> hell, Haskell, C++, Prolog, and SML have incompatible definitions of "functor"
20:39:11 <fen> the closest way is UndecidableInstances, where the trivial superclass can be given an overlapping definition in terms of the sufficient subclass
20:39:28 <fen> clearly thats not great style
20:40:00 <fen> so syntax for overriding superclass functions at the subclass declaration would be preferable 
20:40:56 <fen> also, this could give a way, like rather than trying to match on Specificity, to give another overlapping definition for the user to override the default 
20:41:25 <fen> like, if the foldMapDefualt needs to be overridden.
20:41:45 <fen> since its generally slower than writing foldMap directly
20:42:05 <fen> % :t foldMapDefault
20:42:05 <yahb> fen: (Traversable t, Monoid m) => (a -> m) -> t a -> m
20:42:53 <fen> writing instance Traversable f => Foldable f where foldMap = foldMapDefault is terrible!
20:44:07 <fen> in part, DerivingVia can be used to avoid long stacks of hierarchical class implementations with defaults ?
20:45:26 <fen> but what would be better is if the lowest of these could be written, and all those above it inferred automatically, and if these superclasses needed to be implemented differently, giving an explicit definition would replace the default provided by the subclass
20:46:55 <fen> and even better, would be some kind of modification to the constraints mechanism to make it obvious which constraints on the lhs of the => at a class deceleration were automatically derived, and which should be implemented 
20:47:35 <fen> like an extension of the minimal sufficient implementation of mutually defined class functions but that extends to superclasses
20:48:58 <fen> currently, placing all the entailed classes as constraints can be used to force the user to implement these, but it gives no indication that there are some of these that have default implementations 
20:49:27 <fen> e.g. Foldable is entailed by Traversable
20:50:12 <fen> leading to a definition of trivial and sufficent super/sub classes as; trivial superclasses are entailed by sufficient subclasses
20:52:38 <celphi> is it possible to type in explicit type declarations into ghci?
20:53:36 --- mode: glguy set +v ibloom
20:53:58 <ibloom> I have a specific problem I’ve detailed here: https://www.reddit.com/r/haskellquestions/comments/a1c1c4/question_for_a_ghc_expert_about_reducing_core/
20:56:05 <geekosaur> celphi, yes, but you have to use multiline mode or put them on the same line with a semicolon in between
20:56:24 <geekosaur> each logical line is a separate binding group
20:57:00 <celphi> @geekosaur I tried it but i'm getting an error.
20:57:00 <lambdabot> Unknown command, try @list
20:57:33 <celphi> test3 :: [Bool] -> [Bool] (gives me an error)
20:58:50 <geekosaur> that does not look like "put them on the same line with a semicolon in between"
20:59:00 <geekosaur> nor do I see :{ :}
20:59:31 <celphi> put what on same line?
20:59:50 <fen> the function definition and its type signature
21:00:03 <celphi> does it matter which one goes first?
21:00:16 <geekosaur> no, just that hey're in the same binding group
21:01:33 <celphi> test4 :: [Bool] -> [Bool]; test4 x = True
21:01:52 <celphi> breaks
21:02:46 <fen> whats the error?
21:02:53 <fen> https://stackoverflow.com/questions/31600470/how-to-define-default-implementation-in-subclass-definition-in-haskell
21:02:55 <geekosaur> how? also,w hat ghc version? (before ghc8, it needs to be prefixed with "let")
21:03:24 <celphi> <interactive>:151:38: error:
21:03:24 <celphi>     • Couldn't match expected type ‘[Bool]’ with actual type ‘Bool’
21:03:24 <celphi>     • In the expression: True
21:03:24 <celphi>       In an equation for ‘test4’: test4 x = True
21:03:24 <geekosaur> several debian derivatives still default to 7.10.x which will need that
21:03:42 <geekosaur> yes. so what makes you tink that;'s ap roblem with syntax?
21:03:56 <geekosaur> :t True
21:03:58 <lambdabot> Bool
21:04:24 <celphi> if i do test4 False (i get true)
21:04:36 <celphi> so shouldnt that declaration work?
21:04:37 <geekosaur> unless the "problem with syntax" is you're not clear on what [Bool] means
21:04:46 <celphi> True / False
21:04:49 <fen> with the proposed DefaultSignatures there is still the problem of combining classes to entail a trivial subclass, and also, there might not be the possibility of changing the class declarations of Prelude classes, which is why it should be placed at the subclass, not the superclass
21:04:59 <geekosaur> the braces are not commentary
21:05:06 <celphi> lol oh
21:05:29 <celphi> Sorry,.. im coming from a differ programming language this is so foreign to me
21:05:37 <fen> :t [True]
21:05:38 <lambdabot> [Bool]
21:06:06 <celphi> :t [Bool]
21:06:08 <lambdabot> error:
21:06:08 <lambdabot>     • Data constructor not in scope: Bool
21:06:08 <lambdabot>     • Perhaps you meant variable ‘bool’ (imported from Data.Bool)
21:06:14 <celphi> haha cool
21:06:38 <fen> :k '[Bool]
21:06:39 <lambdabot> [*]
21:06:58 <celphi> Thank you Geek for explaining that
21:07:04 <geekosaur> :t [True,True]
21:07:05 <lambdabot> [Bool]
21:08:07 <celphi> i saw removeNonUppercase :: [Char] -> [Char]  and thought i could use Bool.,.. but the next line in tutorial explains why the Char is in square brackets
21:08:51 <fen> :t "hello" :: [Char]
21:08:52 <lambdabot> [Char]
21:08:59 <fen> :t "hello" :: String
21:09:01 <lambdabot> String
21:09:13 <fen> hmm, would have expected them both to be String...
21:09:24 <fen> % :t "hello" :: [Char]
21:09:25 <yahb> fen: [Char]
21:09:28 <fen> oh well
21:10:08 <celphi> what does :: do fen
21:10:18 <fen> that means "type"
21:10:31 <fen> a :: b means "a is of type b"
21:10:47 <celphi> so :t asks what it is but then you define it?
21:10:57 <fen> :t 0
21:10:58 <lambdabot> Num p => p
21:11:02 <fen> :t 0 :: Int
21:11:03 <lambdabot> Int
21:11:17 <fen> its a type specialisation then
21:11:17 <c_wraith> You can provide those annotations more narrowly.
21:11:21 <celphi> so like type coersion?
21:11:32 <c_wraith> think of it more like refinement than coercion.
21:11:32 <geekosaur> ghc's typechecker makes some attempt to remember which type aliases were used. this breaks down when type nference comes into lay, leading to lots of complaints about how someone expected or wanted one form but got the other, and it's literally impossible to make everyone happy
21:11:33 <fen> whats that?
21:11:39 <c_wraith> It can't *change* the type of anything.
21:11:45 <c_wraith> But it can make them more specific
21:12:01 <celphi> so like int to float?
21:12:07 <c_wraith> that's a change.
21:12:11 <fen> :t realToFrac
21:12:12 <lambdabot> (Fractional b, Real a) => a -> b
21:12:28 <fen> :t realToFrac :: Double -> Float 
21:12:29 <lambdabot> Double -> Float
21:12:44 <fen> :t realToFrac :: Int -> Double
21:12:45 <lambdabot> Int -> Double
21:13:02 <geekosaur> celphi, if you hv a numeric literal, its type is (Num a => a) or (Fractional a => a) depending on whether it had a decimal point or not. You can give that a more specific type
21:13:22 <geekosaur> If it's already Int or etc, you can't get more specfic and you can;'t tell it to turn into something else
21:13:36 <fen> :t (realToFrac (0 :: Int)) :: Double
21:13:37 <lambdabot> Double
21:13:49 <celphi> great clarity
21:13:52 <celphi> ty
21:14:31 <fen> :t (realToFrac (0 :: Int)) 
21:14:33 <lambdabot> Fractional b => b
21:14:50 <geekosaur> there are conversion fnctions, most of which are or use numeric typeclass methods and therefore can be specified. like realToFrac there
21:14:51 <geekosaur> or fromIntegral
21:14:54 <geekosaur> :t fromIntegral
21:14:55 <lambdabot> (Num b, Integral a) => a -> b
21:15:23 <geekosaur> you can "fix" the a or b as long as the type you choose has an appropriate instance.
21:15:27 <fen> :t toRational
21:15:28 <lambdabot> Real a => a -> Rational
21:15:48 <geekosaur> or partially fix it, e.g. constainingthe "b" there to an instance of Integral or Fractional
21:16:01 <geekosaur> because both require a Num instance
21:20:15 <fen> how can the Traversable class be changed to include some defaults?
21:20:33 <fen> not the version on Hackage, just a local version
21:20:43 <fen> would that require building GHC from source?
21:28:46 <fen> possibly this leads to a convention of only defining "default" functions at top level for prelude classes, and all other classes can be written using DefaultSignatures
21:32:03 <celphi> ok new one
21:32:07 <celphi> why does this fail?
21:32:09 <celphi> factoral3 :: Num -> Num; factoral x = sum [1..x]
21:32:32 <c_wraith> celphi: Num is a class, not a type
21:32:42 <glguy> Factorial uses product, not sum, and Num isn't a type that you can use like that, it's a typeclass
21:32:53 <c_wraith> celphi: in haskell, a class is something different than it is in an OO language
21:33:06 <celphi> oh ok
21:33:34 <c_wraith> celphi: a class is more or less an interface that a type can provide.  Num is an interface provided by types like Int, Double, etc.
21:33:38 <celphi> so why does this fail then?
21:33:39 <celphi> factoral3 :: Int -> Int; factoral x = sum [1..x]
21:33:41 <glguy> Also keep in mind that the proper version: Num a => a -> a  conveys more information than yours would if it made sense
21:33:48 <glguy> We know that the argument and result types match
21:33:59 <glguy> celphi: the names don't match
21:34:11 <celphi> rofl gawd im a noob
21:34:23 <c_wraith> happens to non-noobs too.  Don't worry about it. :)
21:34:33 <celphi> Thnx for being patient.
21:35:05 <celphi> just fyi i do try lots of things before asking in room.
21:35:19 <c_wraith> that's a good habit.  keep it up! :)
21:48:38 * hackage ip2proxy 1.0.0 - IP2Proxy Haskell package for proxy detection.  http://hackage.haskell.org/package/ip2proxy-1.0.0 (ip2location)
22:47:22 <Mrbuck> https://ai.google/research/teams/brain   very talented than people at haskell ?
22:50:34 <koz_> Mrbuck: Are you deliberately trolling?
22:50:53 <Mrbuck> koz_:  no 
22:51:08 <koz_> There are no people 'at haskell', whatever that means.
22:51:25 <koz_> There are folks who work on GHC, and there are folks who use Haskell codebases at work (in the sense they get paid for them).
22:51:26 <Mrbuck> koz_:  I feel many talented people here who are not famous
22:51:38 <koz_> Yeah, but fame's overrated.
22:51:39 <Mrbuck> I m jealous
22:52:05 <Mrbuck> https://ai.google/research/teams/brain  I see every one top colleger and university people
22:53:33 <Mrbuck> and even Hinton is below jeff dean
22:56:04 * geekosaur wonders if that exchange would make more sense in a language other than English. or a culture different from western
22:56:42 <koz_> geekosaur: Possibly.
22:58:43 <Mrbuck> geekosaur:  what ?
22:58:55 <Mrbuck> which exchange ?
23:19:03 * hackage fay-websockets 0.0.1.0 - Websockets FFI library for Fay  http://hackage.haskell.org/package/fay-websockets-0.0.1.0 (swamp_agr)
23:24:14 <trcc> anyone know how to install ghc < 8.2 using homebrew?! Cannot seem to find a way
23:30:11 <johnw> has anyone already done the work of matching WebAssembly floating point semantics in a Haskell library?
23:32:44 <trcc> anyone has a good setup for emacs on haskell + cabal project? (not using stack). I would prefer them to not depend on ghc-mod, since ghc-mod does not support ghc >= 8.2. Any other tooling suggestions very welcome!
23:35:59 <johnw> the only thing I've ever had reliably working is haskell-mode + flycheck-haskell
23:40:03 <trcc> johnw: I will try
23:43:29 <trcc> johnw: it seems like haskell-mode depends on ghc-mod as well
23:43:40 <johnw> really?
23:43:42 <johnw> i don't use ghc-mod
23:43:46 <trcc> through company-ghc
23:44:06 <trcc> maybe works without
23:44:19 <johnw> ah, I turn off company-mode in haskell files
23:44:28 <trcc> okay. Makes sense
23:46:05 <johnw> heading out now, good luck
23:47:00 <teto> as soon as I run ghc, I get into "./settings: openFile: does not exist (No such file or directory)" . I can't even do ghc --help :s
23:47:09 <trcc> johnw: thanks
23:47:55 <koz_> teto: How did you set up GHC?
23:49:19 <teto> koz_: I use nix "shellFor" command
23:49:42 --- mode: glguy set +v hpd[m]1
23:49:57 <teto> ghc 8.4.4. I found many reports of this behavior but no real solution. For instance I don't have stack in the environment
