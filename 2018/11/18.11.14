00:01:02 <bahamas> hello. I have an issue with PureScript, but I'm hoping it's close enough to Haskell that someone can tell what the problem is. this is the code and the error https://bpaste.net/show/438312972816. how can I assert that `Maybe t0` is `Maybe String` or coerce to String?
00:02:35 <MasseR> If I'm reading the error msg correctly, you don't have 'Maybe t0' that you want to be 'Maybe String', you have 'String' that you want to be 'Maybe String'
00:03:36 <bor0> what's `hush`, `obj`, `.?`?
00:04:18 <MasseR> Or maybe you have a 'Maybe (Maybe String)' ?
00:04:28 <MasseR> Maybe try adding a join there?
00:04:49 <bahamas> bor0: `hush :: Either String a -> Maybe a`; obj :: Object Json; `(.?) :: Object Json -> String -> Either String a`
00:10:16 * hackage config-ini 0.2.4.0 - A library for simple INI-based configuration files.  http://hackage.haskell.org/package/config-ini-0.2.4.0 (gdritter)
00:13:36 <asheshambasta> Hello fine people of Haskell, what is a good place to advertise a Haskell job? I know /r/haskell is one place but I wanted to ask before posting since I wouldn't want to be doing shameless plugs everywhere. :-) 
00:15:38 <MasseR> asheshambasta: we did /r/haskell, haskell-cafe and haskell channel on slack
00:15:47 <MasseR> oh and the jobs channel as well
00:15:56 <cocreature> twitter is also an option
00:16:43 <bahamas> the problem was that my editor import `fromMaybe` from `Data.Unfoldable` instead of from `Data.Maybe`
00:17:37 <MasseR> interesting. What's it's type?
00:19:40 <asheshambasta> I see, thanks MasseR, cocreature! In other news, we're investing full time in Haskell from now on. We've got some services written in Scala that still need to be maintained though. I hope that isn't a deal-breaker.
00:21:06 <MasseR> asheshambasta: Who is 'we'?
00:21:26 <bahamas> MasseR: https://pursuit.purescript.org/packages/purescript-unfoldable/4.0.0/docs/Data.Unfoldable#v:fromMaybe
00:21:28 <asheshambasta> MasseR: my little startup: centralapp.com 
00:22:05 <MasseR> bahamas: ah I see
00:23:13 <MasseR> bahamas: if you allow remote workers, you should quite a few applicants :)
00:23:19 <bahamas> asheshambasta: do you accept remote?
00:23:22 <MasseR> s/bahamas/ asheshambasta /
00:23:23 <bahamas> :)
00:24:06 <asheshambasta> bahamas: not 100% remote yet (unless the application is compelling), but yeah, I work remotely a couple of times a week. 
00:45:16 * hackage pure-shuffle 0.1.0.0 -   http://hackage.haskell.org/package/pure-shuffle-0.1.0.0 (igrep)
01:14:28 <Shockk> I have a quick llvm-hs-pure question once again
01:16:53 <Shockk> I want to simplify my code that generates the module IR from my AST, and I'm wondering, if I create unnamed functions (i.e. given ascending numeric names), and then I create a constant of value GlobalReference, 
01:17:38 <Shockk> if I then set that GlobalReference to the unnamed function's name, will it be equivalent to the function being callable with the name of the GlobalReference?
01:18:31 <Shockk> not sure if I'm explaining my question very well; what I mean is, if I have like:   define i32 @1(i32 %x) { ret i32 %x; }
01:20:08 <Shockk> if I then create a GlobalReference i32 "1" and assign that to the name "identity" or something, then when LLVM lowers this to machine code and writes it to an object file, will "identity" be a function symbol that I can call?
01:28:25 * hackage church 0.1.0.0 - Automatically convert Generic instances to and from church representations  http://hackage.haskell.org/package/church-0.1.0.0 (dailectic)
02:11:19 <bahamas> is there any Haskell tutorial or guide that would set me up in a good position to understand how to use this PureScript module https://pursuit.purescript.org/packages/purescript-coroutines/5.0.0/docs/Control.Coroutine?
02:18:16 <cocreature> bahamas: looks like the pipes tutorial might be helpful
02:20:45 <kuribas> Is adding a Overlapping pragma to an instance safe?
02:20:58 <kuribas> (not a orphan instance)
02:21:02 <Shockk> is there a way to put a constraint on a type alias?
02:21:05 <Shockk> for example:
02:21:17 <Shockk> type Builder m = StateT [Scope] (IR.IRBuilderT m)
02:21:31 <Shockk> I'd like m to be constrained by IR.MonadModuleBuilder m
02:22:47 <bahamas> cocreature: ok. thanks!
02:24:18 <cocreature> kuribas: safe in what way?
02:25:14 <kuribas> cocreature: that it breaks type-inference, causes unexpected side-effects...
02:25:36 <Shockk> hmmm.. apparently this works with ExistentialQuantification and RankNTypes:
02:25:53 <Shockk> type Builder a = forall m. IR.MonadModuleBuilder m => StateT [Scope] (IR.IRBuilderT m) a
02:25:56 <Shockk> am I overthinking this?
02:26:02 <Shockk> or is this like, the only way to do what I want to do?
02:26:33 <puffnfresh> Shockk: existential type-class constraints are usually considered an anti-pattern
02:26:55 <puffnfresh> https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
02:26:58 <Shockk> right, but I really don't want to have to put the constraint on all of my functions though
02:27:04 <kuribas> cocreature: I understand why using it on a orphan instance is bad, but I don't see any problem with instance defined in the same module.
02:29:37 <puffnfresh> Shockk: oh you just want to alias a constraint?
02:29:59 <Shockk> pretty much; I had this: type Builder m = StateT [Scope] (IR.IRBuilderT m)
02:30:29 <Shockk> the problem with using this is that I require m to have that constraint, everywhere I use Builder m
02:30:55 <Shockk> er, forget the m on Builder
02:31:01 <Shockk> I mistyped that
02:31:16 <Shockk> so I have:  type Builder = StateT [Scope] (IR.IRBuilderT m)
02:32:25 <kuribas> Shockk: "type MyType m = Monad m => m () " works with RankNTypes
02:32:40 <Shockk> hmm let me try that
02:34:00 <Shockk> kuribas: with that I just get "Not in scope: type variable 'm'", on both the constraint and the type
02:34:18 <Shockk> that's why I had the explicit forall there
02:34:44 <geekosaur> that won't work
02:34:51 <Shockk> but then with explicit forall, it tells me it expects one more argument to StateT [Scope] (IR.IRBuilderT m)
02:34:54 <geekosaur> basically, you can't' do what you want
02:35:06 <kuribas> geekosaur: with forall that should work?
02:35:23 <kuribas> as long as he doesn't want to fill in the m...
02:35:32 <Shockk> hmm this one did compile: type Builder a = forall m. IR.MonadModuleBuilder m => StateT [Scope] (IR.IRBuilderT m) a
02:35:34 <geekosaur> no. the forall prevents unification with the m coming from outside
02:35:54 <puffnfresh> yeah you don't want to exclude the m
02:35:54 <geekosaur> it may work for soem things, it will give you errors you cannot fix for others
02:36:06 <puffnfresh> you want that m exposed
02:36:22 <puffnfresh> otherwise writing a function with MonadState m would not be possible
02:36:33 <Shockk> hmm
02:36:36 <Shockk> I'm not sure I understand
02:36:48 <cocreature> kuribas: it definitely has some problems, e.g., https://www.reddit.com/r/haskell/comments/7nre75/fixing_overlapping_instances/
02:37:33 <puffnfresh> Shockk: myFunction :: MonadReader MyConfig m => Builder m ()
02:37:51 <puffnfresh> just imagining this like this could possibly be useful
02:37:58 <puffnfresh> therefore, you want the "m" to be exposed
02:37:59 <kuribas> cocreature: "By accepting the above function definition GHC is violating the open world assumption, and assuming that just because it doesn't yet see an overlapping instance, that it will never see one"
02:38:20 <kuribas> cocreature: that will not happen if you avoid them for orphan instances.
02:39:12 <cocreature> kuribas: there is no orphan instance in the code example used here
02:39:13 <geekosaur> Shockk, consider 'let m = ... in let m = ... in ...'. you can't ge at the outer 'm' because the inner one is in the way
02:39:28 <geekosaur> the same is happening here, but with types
02:39:51 <Shockk> puffnfresh: well I mean, that's true if I was trying to build a generic type but for my purposes Builder is very specific and intended to just be an alias so that I don't have to type out my constraint and all the StateT stuff, within my module
02:41:08 <cocreature> kuribas: in general in the case of overlapping instances, adding new instances can change the behavior of code that previously compiled which is at best surprising and at worst breaks existing code
02:41:37 <kuribas> geekosaur, Shockk: this works just fine: https://gist.github.com/kuribas/684fc5b6d610f96cc19a9e6232e6cf97
02:42:10 <Shockk> kuribas: right that's what I've got, just still unsure if it's desirable based on what geekosaur and puffnfresh are saying
02:42:15 <kuribas> geekosaur, Shockk notice the IO unifies with m, even though it's in the forall.
02:42:43 <kuribas> I think it works because type generates just a synonym, not a datatype.
02:42:51 <Shockk> right
02:44:04 <puffnfresh> kuribas: no, that's fine, but try expanding that to MonadState
02:44:09 <puffnfresh> sorry try MonadReader
02:44:22 <puffnfresh> MonadReader m => MyState Int
02:44:31 <puffnfresh> there's nowhere for the "m" to go
02:44:32 <Shockk> I see your point, though I don't think I need to be able to get at the inner m there
02:44:36 <puffnfresh> but if that's what you wnt Shockk, go for it
02:45:20 <Shockk> I understand the point now though I think; I messed with some existentially quantified types like a couple of years ago but forgot most of what I did now
02:47:22 <kuribas> puffnfresh: works just fine: https://gist.github.com/kuribas/684fc5b6d610f96cc19a9e6232e6cf97
02:47:34 <kuribas> Shockk: this isn't an existentially quantified type
02:47:43 <Shockk> is it not?
02:47:46 <kuribas> nope
02:47:57 <opqdonut> Shockk: I didn't follow your problem that closely, but I'd just try to select a _fixed_ monad and give it a type alias. that should make working with the llvm library easier
02:48:05 <Shockk> the m is only on the rhs though and I had to enable ExistentialQuantification in my extensions
02:48:16 <Shockk> or maybe I didn't
02:48:21 <Shockk> maybe I just need explicit forall
02:48:35 <Shockk> opqdonut: hmm what do you mean by fixed monad?
02:48:43 <kuribas> Shockk: you only need RankNTypes
02:49:04 <Shockk> kuribas: oh, huh, you're right
02:49:23 <opqdonut> Shockk: so something like "type MyIRAndModuleBuilder = ModuleBuilderT (IRBuilderT Identity)"
02:49:41 <Shockk> opqdonut: ah but I need my own state in here though
02:49:52 <opqdonut> right, well then just change Identity to whatever you need
02:49:56 <Shockk> or, oh, I see what you mean now
02:50:03 <opqdonut> the library needs to be polymorphic to support various use cases
02:50:19 <opqdonut> but in your single use case you're probably better off with a monomorphic type
02:50:25 <Shockk> ah right
02:50:27 <opqdonut> (or maybe two different monomorphic types)
02:50:58 <opqdonut> this is one of the "design patterns" for monad transformers: pick a single concrete transformer stack, and give it an alias
02:51:03 <Shockk> kuribas: what's the difference between Rank2Types and RankNTypes btw, and which of them should I use here? (they both appear to work)
02:51:17 <Shockk> opqdonut: hmm okay that makes sense
02:51:30 <opqdonut> Rank2Types is more restricted than RakNTypes
02:51:51 <opqdonut> the "rank" refers to how many ->s occur to the left of a forall, roughly speaking
02:51:51 <Shockk> ah I see
02:51:59 <Taneb> In recent GHC compilers they're synonyms and you should use RankNTypes
02:52:01 <Shockk> I also see now it's deprecated 
02:52:07 <Shockk> okay, thanks
02:52:11 <opqdonut> good to know
03:00:12 <puffnfresh> kuribas: I mean having MyType AND MonadReader, is not possible
03:00:40 <kuribas> puffnfresh: right, but that's what he wanted...
03:00:46 <puffnfresh> yeah, I know
03:04:27 <Shockk> well I made progress :D 
03:04:28 <Shockk> https://gist.github.com/shockkolate/1b0a4a64d727054e90c3fec876cebb7c
03:04:39 <Shockk> finally scoped definitions now that I have state
03:13:43 <Jetien> "if condition then Just x else Nothing" - is there a more elegant/generic way to write this?
03:14:39 <cocreature> Jetien: guard condition *> pure x works
03:15:10 <cocreature> or x <$ guard condition
03:16:36 <Jetien> cocreature: thanks! need some time to understand that
03:16:59 <cocreature> with -XMonadComprehensions [x | condition] should also work
03:19:10 <cocreature> Jetien: guard p = if p then pure () else empty
03:19:28 <cocreature> Jetien: for Maybe you have pure = Just and empty = Nothing
03:19:34 <tdammers> there's no need to really "understand" this here - that's the beauty of equational reasoning :O
03:19:36 <cocreature> so guard p = if p then Just () else Nothing
03:19:56 <cocreature> *> will shortcircuit on Nothing
03:20:21 <cocreature> and for <$ the Functor instance will handle things appropriately
03:20:39 <Jetien> everythin in haskell is just equational reasoning ;) i jused "guard" only in list monad before (without really understanding it)
03:23:12 <cocreature> usually the Alternative and the MonadPlus instance coincide and for MonadPlus mzero/empty shortcircuits
03:23:32 <cocreature> as in mzero >>= f = mzero
03:24:06 <cocreature> so guard can be used to shortcircuit based on a predicate
03:41:10 <Ariakenom> cocreature: which Alternative and MonadPlus don't coincide?
03:41:42 <cocreature> Ariakenom: not sure there are any instances in base but there is nothing in principle stopping someone from making two different instances
04:06:49 --- mode: glguy set +v govno
04:07:52 <govno> How to realize Functor class for type with kind *->*->*->*->*?
04:08:07 <quicksilver> well there is nothing to stop people writing instantces which don't obey laws
04:08:25 <quicksilver> but assuming people are writing lawful instances I think it's a "law" that Alternative and MonadPlus coincide.
04:08:32 <quicksilver> a folklore law, at least
04:08:34 <quicksilver> folklaw?
04:10:01 <govno>  How to realize Functor class for type with kind *->*->*->*->*?
04:11:55 <cocreature> quicksilver: well it’s not mentioned in the docs
04:12:45 <govno> therefore C++ is more better than Haskell
04:12:54 <cocreature> govno: you can’t, Functor instances have kind kind *->*
04:13:11 <cocreature> but you might be able to make an instance for a partially applied version of that that has kind *->*
04:15:15 <quicksilver> cocreature: yeah. It's odd isn't it. I personaly take it as strongly hinted by the superclass and the default methods but I agree it should actually say it.
04:16:51 <tauoverpi[m]> <freenode_qui "well there is nothing to stop pe"> with dependent types and a VerifiedFunctor/Applicative/Monad/etc... there would at least be a way to automatically check as long as laws are agreed upon.
04:17:34 <cocreature> quicksilver: yeah it’s kind of weird
04:18:08 <cocreature> quicksilver: the fact that it has additional laws surrounding the interaction of mzero with >> and >>= also makes it not entirely redundant
04:18:48 <cocreature> maybe I should try to add empty *> x = empty to the docs of Alternative
04:31:25 * hackage hspec-need-env 0.1.0.2 - Read environment variables for hspec tests  http://hackage.haskell.org/package/hspec-need-env-0.1.0.2 (debugito)
04:36:15 <hpc> cocreature: i can't imagine an instance where that isn't the case already, seems like a good law to add
04:39:16 * hackage singletons 2.5.1 - A framework for generating singleton types  http://hackage.haskell.org/package/singletons-2.5.1 (ryanglscott)
05:01:23 <barrucadu> govno: A functor in C++ is not the same thing as a functor in Haskell
05:09:24 <phadej> is functor in C++ a class with operator() ?
05:10:25 <hpc> yes
05:10:40 <hpc> that question didn't really strike me as genuine to begin with though
05:10:50 <Solonarv> (what a terrible choice of name on c++'s side)
05:11:17 <phadej> better than  SML functors? :)
05:13:01 <Solonarv> I don't know SML well enough to comment :P
05:13:12 <geekosaur> parameterized modules
05:13:14 <phadej> in SML functor is a parametrisable module
05:13:17 <hpc> Solonarv: it's like ML, but with S
05:14:04 <hpc> heh, i always heard parameterized modules just called "modules"
05:15:15 --- mode: glguy set +v sparky
05:15:21 <[exa]> phadej: afaik standard c++ does not use the name (instead uses std::function, or "callable" in some docs). But "functor" is wildly misused there, yes
05:15:50 <ggole> Prolog was there first!
05:16:19 <hpc> ggole: holy crap
05:17:06 <hpc> in prolog, functions are also called functors, TIL
05:18:09 <ggole> Mmm, not really. A functor is prolog is the 'name' part of a compound term.
05:18:16 <phadej> is there functions in prolog? :)
05:18:27 <ggole> Eg, you have a term foo(X, Y), the 'foo' there is the functor.
05:18:54 <geekosaur> ' it looks function-ish'. so the same thing C++ is doing, more or less >.>
05:18:59 <hpc> phadej: haskell is more better than prolog :P
05:19:15 <hpc> it looks like the use of "functor" in CT juuuuuuust barely predates prolog
05:19:18 <hpc> 1971 vs 1972
05:19:31 <hpc> (going by wikipedia citations)
05:19:32 <phadej> what it was called  before?
05:20:20 <tdammers> I always imagine Functor as some sort of superhero, the kind that appears in comic books targeted at 12-year-olds
05:20:28 <phadej> I see, MacLane's book is from 71
05:20:37 <hpc> the original use of functor is in linguistics
05:20:45 <phadej> tdammers: no, it's the lambda man
05:20:53 <phadej> the superhero, I mean
05:20:55 <tdammers> phadej: maybe Functor is the nemesis then
05:21:08 <phadej> :D
05:21:09 <hpc> nah, functor is the superweapon
05:21:24 <hpc> and then in the inevitable sequels, endofunctor, profunctor, bifunctor, etc
05:21:34 <tdammers> alternate universes
05:21:39 <hpc> haha
05:21:40 <ggole> Somebody should really fix these name allocation race conditions
05:21:59 <geekosaur> "allocation". aren't we optimistic
05:22:14 <tdammers> "allocation" is a euphemism for "squatting", no?
05:22:38 <geekosaur> "I'll do what I damned well please", so roughly yes
05:22:44 <ggole> Well, squatting implies inhabitation of a preexisting structure
05:23:03 <ggole> I'm not sure how accurate that is in this case
05:23:17 <tdammers> not really; it just implies ignoring any possible pre-existing usage rights
05:23:49 <tdammers> or you could say that the name itself is axiomatically a pre-existing structure
05:25:09 * ggole ponders the parallels to the 'isomorphic javascript' thing
05:26:56 <phadej> "isomorphic javascript" is a good example of using a word without slight understanding of its meaning
05:27:43 <phadej> e.g. Java is ... just "Java"
05:29:29 <tdammers> 'isomorphic' is fascinating
05:30:07 <ggole> It's not entirely awful if you just look at the Greek roots and forget what you know about the mathematical term
05:30:42 <tdammers> if you look up a literal translation of 'isomorphic', you get something like 'same shape'; the nuance of what kind of shape is being talked about is lost in translation, and once you forget the full meaning of the greek roots, the usage is "technically correct"
05:31:35 <ggole> Hmm... what would a better term be?
05:32:10 <ggole> isokodikas?
05:32:33 <ggole> (I think I probably butchered that.)
05:33:52 <phadej> i'm not sure there need to be a special prefix at all
05:35:46 * hackage hasbolt 0.1.3.1 - Haskell driver for Neo4j 3+ (BOLT protocol)  http://hackage.haskell.org/package/hasbolt-0.1.3.1 (zmactep)
05:36:49 <tdammers> monoglot?
05:38:13 <geekosaur> codex javascriptis?
05:39:26 * hackage gasp 1.1.0.0 - A framework of algebraic classes  http://hackage.haskell.org/package/gasp-1.1.0.0 (JeanPhilippeBernardy)
05:44:16 * hackage TotalMap 0.1.0.0 - A total map datatype  http://hackage.haskell.org/package/TotalMap-0.1.0.0 (edwardwas)
05:47:28 <max3> can someone tell me what getDogRM desugars to here https://paste.rs/d6k.hs
05:49:16 <max3> sorry not just desugars but all the way to the definition of >>=
05:49:25 <geekosaur> @undo do { name <- dogName; return $ Dog name }
05:49:25 <lambdabot> dogName >>= \ name -> return $ Dog name
05:51:21 <max3> yes i understood that far
05:51:26 <max3> but the definition of >>=
05:52:02 <ventonegro> max3: it depends on the Monad instance
05:52:14 <max3> yes i know
05:52:15 <max3> i'm saying here
05:52:19 <geekosaur> actally Is ee no monad instance so I susepct a type error
05:52:32 <Solonarv> geekosaur: wrong, Monad ((->) e)
05:52:33 <max3> ((-> r) is the monad
05:53:24 <Solonarv> I'd suggest looking up that instance's source code, so you can look at the definition of >>=
05:54:09 <max3> this is what i don't understand
05:54:16 <max3> f >>= k = \ r -> k (f r) r
05:54:37 <max3> \ name -> return $ Dog name should be a two argument function
05:54:44 <max3> sorry
05:54:57 <rotaerk> huh, never considered using ((->) e) like that for accessing records
05:55:01 <Solonarv> a two-arg function is actually just a one-arg function that returns another one-arg function
05:55:06 <max3> sure
05:55:17 <max3> is it the return that returns the one arg function?
05:55:30 <Solonarv> i.e. '\x y -> ...' is the same thing as '\x -> \y -> ...'
05:55:41 <Solonarv> no - return isn't special syntax, it's also defined in that Monad instance
05:55:54 <max3> well yes i'm saying for this instance
05:56:34 <max3> note it's not written in ghc base
05:56:38 <max3> unless it's pure
05:56:45 <max3> which is const
05:57:07 <ventonegro> The return for reader just ignores the argument
05:57:09 <Solonarv> 'return' is the same thing as 'pure', always
05:57:22 <Solonarv> the fact that they're separate is a historical accident
05:57:28 <max3> well of course my confusion is that i've seen pure = return
05:57:49 <max3> and it's not obvious to me that when a monad instance is also an applicative instance it uses pure and return can be omitted 
05:57:59 <Mrbuck> hi I want to convert the code here https://lectures.quantecon.org
05:58:04 <Mrbuck> to haskell
05:58:09 <Mrbuck> is it a big effort?
05:58:09 <max3> Mrbuck, lol no way
05:58:14 <Mrbuck> max3:  why ?
05:58:30 <Solonarv> the default definition for 'return' is 'return = pure'; if you've defined 'pure' you don't need to define 'return'
05:58:30 <Solonarv> if you define 'return' manually, then you have to define 'pure = return'
05:58:30 <max3> there is so much numerical code there that's ergonomic because of numpy/julia
05:59:15 <max3> Solonarv, okay
05:59:46 <max3> but so that's it: in this instance (pun) return returns a 1 arg function
05:59:47 <max3> const
06:00:21 <Mrbuck> max3:  you say impossible or what ?? In Haskell cant we have our numpy like library ?
06:00:47 <Mrbuck> Julia uses what ? it has default numpy like stuff?
06:01:22 <max3> this is all very much beyond scope. suffice it to say it will be very hard to reproduce quantecon in haskell
06:01:29 <Solonarv> max3: let's step through this bit by bit:
06:01:29 <Solonarv> dogName >>= \name -> return $ Dog name
06:01:29 <Solonarv> -- replace '>>=' with its definition
06:01:29 <Solonarv> \r -> (\name -> return $ Dog name) (dogName r) r
06:01:29 <Solonarv> -- apply the inner lambda
06:01:29 <Solonarv> \r -> (return $ Dog (dogName r)) r
06:01:29 <Solonarv> -- replace 'return' with its definition
06:01:30 <Solonarv> \r -> const (Dog (dogName r)) r
06:01:30 <Solonarv> -- definition of 'const'
06:01:31 <Solonarv> \r -> Dog (dogName r)
06:01:36 <max3> Mrbuck, https://old.reddit.com/r/haskell/comments/3vwn69/equivalent_of_numpy_for_haskell/
06:01:54 <Solonarv> Mrbuck: it's not that haskell *can't* have a numpy-equivalent, it just doesn't have one and writing that is a lot of effort
06:03:36 <max3> Solonarv, thanks
06:05:36 <Mrbuck> Solonarv: max3  yeah but if one starts writnf now others may contribute and become usable ny next 5-6 years right ?
06:07:04 <Solonarv> I'm pretty sure people are already working on numeric libraries
06:09:39 <Mrbuck> Solonarv:  nice I dont know both python and haskell anyway and I found https://lectures.quantecon.org
06:09:45 <Mrbuck> very intresting
06:10:15 <Mrbuck> so I was like should I just use python as it lready exist or write in haskell myself
06:12:39 <Solonarv> the answer is definitely "use python" in this case
06:16:27 <Mrbuck> Solonarv:  thank you for genuine reply
06:16:42 <Mrbuck> Solonarv:  you also say so because of libarries right ?
06:16:51 <Mrbuck> I find haskell only place I get genuine replied
06:16:52 <Solonarv> that's half the reason
06:17:02 <Mrbuck> other channel they support their anguage always
06:17:09 <Mrbuck> Solonarv:  which is half other ?
06:17:19 <Solonarv> the other half is that the course uses python, and trying to translate a course from one language to another is generally not a great idea
06:17:52 <Solonarv> *especially* if, like here, the libraries used don't have a one-to-one equivalent in the other language
06:18:19 <Mrbuck> Ok and may be once I am done then I can try to translate 
06:18:22 <Mrbuck> right ?
06:18:50 <Solonarv> yes, then you could try to replicate the same thing in another language
06:20:23 <Mrbuck> Cool Solonarv Thank you
06:22:27 <Guillaum> Which 2D interactive drawing library are you using when gloss is too slow? I want to draw a few (~3000) point at an interactive framerate. I can do this with opengl, but I'll rather prefer an API as simple as gloss.
06:25:16 <cppxor2arr> Guillaum: i think you should use opengl if you want the performance
06:25:29 <cppxor2arr> there is also sfml for haskell
06:25:35 <dmwit> (Are you sure gloss is too slow?)
06:25:54 <cppxor2arr> sfml is fast enough for 3000 points in my experience
06:31:41 <the_2nd> just noticed my stack folder sitting at 16gb. Is there some GC command or similar? Or do I just wipe the folder?
06:34:18 <cocreature> the_2nd: you have to wipe it manually
06:37:01 <Guillaum> dmwit: 30ms / frame to draw 2000 points, this is too slow ;)
06:37:13 <Guillaum> cppxor2arr: I'll have a look at sfml
06:38:20 <the_2nd> cocreature, just wipe the entire folder or be careful?
06:38:33 <the_2nd> worst case next usage will take a long time?
06:41:08 <cocreature> the_2nd: are you talking about ~/.stack or .stack-work?
06:41:20 <the_2nd> ~
06:41:35 <the_2nd> I guess keep config.yaml, but the other stuff?
06:41:37 <cocreature> in that case you probably only want to nuke ~/.stack/snapshots and maybe ~/.stack/programs
06:41:53 <cocreature> you want to keep your config.yaml and your global-project
06:42:19 <the_2nd> snapshots and programs take like 80-90% of space, so that should do
06:42:34 <cocreature> deleting whole snapshot directories or ghc installations is fine. trying to be more granular, e.g., delete individual packages within a snapshot might cause problems
06:43:23 <the_2nd> alright, thanks
07:01:46 * hackage hschema 0.0.1.1 - Describe schemas for your Haskell data types.  http://hackage.haskell.org/package/hschema-0.0.1.1 (alonsodomin)
07:03:17 * hackage hschema-aeson 0.0.1.1, hschema-prettyprinter 0.0.1.1, hschema-quickcheck 0.0.1.1 (alonsodomin)
07:05:47 * hackage classyplate 0.3.2.0 - Fuseable type-class based generics  http://hackage.haskell.org/package/classyplate-0.3.2.0 (lazac)
07:12:06 --- mode: glguy set +v boi
07:14:16 * hackage multilinear 0.3.0.0 - Comprehensive and efficient (multi)linear algebra implementation.  http://hackage.haskell.org/package/multilinear-0.3.0.0 (ArturB)
07:15:09 <boi> my google fu failed me. How is "literal" (1, 2.0, "abc") type deduced?
07:16:19 <phadej> :t (1, 2.0, "abc")
07:16:20 <lambdabot> (Num a, Fractional b) => (a, b, [Char])
07:16:48 <phadej> and type-inference proceeds from that
07:18:17 <pavonia> "abc" could also be IsString s => s if the OverloadedStrings extension is enabled
07:18:45 <boi> do i understand correctly, that when i write 1 :: Int, 1 is converted (specialized?) to Int from Num a => a?
07:19:06 <Ariakenom> % :set -XOverloadedStrings
07:19:06 <yahb> Ariakenom: 
07:19:11 <Ariakenom> % :t (1,2.0,"abc")
07:19:11 <yahb> Ariakenom: (Fractional b, IsString c, Num a) => (a, b, c)
07:19:20 <Ariakenom> boi: yes
07:19:25 <Ariakenom> well
07:20:01 <Ariakenom> it's only the type gets "specialised". No values are touched
07:20:53 <boi> thanks, sorry for stupid question, it's simpler than i thought
07:22:02 <Taneb> Asking stupid questions is the best way to learn :)
07:52:17 * hackage multilinear-io 0.3.0.0 - Input/output capability for multilinear package.  http://hackage.haskell.org/package/multilinear-io-0.3.0.0 (ArturB)
08:05:47 * hackage hackage-whatsnew 0.1.3 - Check for differences between working directory and hackage  http://hackage.haskell.org/package/hackage-whatsnew-0.1.3 (JeremyShaw)
08:07:04 --- mode: glguy set +v joelb
08:13:55 --- mode: glguy set -v joelb
08:26:52 --- mode: glguy set +v ch3pjw
08:27:25 <ch3pjw> Is there a way to write a function of the type a :~: b -> (a == b) :~: 'True
08:29:16 <dminuoso> ch3pjw: What is `==` supposed to be?
08:30:07 <dminuoso> Oh wait, there is a type family like that?
08:30:10 <dminuoso> Cool stuff :)
08:30:22 <EvanR> what is ==
08:31:18 <ch3pjw> dminuoso: EvanR: Yeah, the type family for equality of types
08:31:42 --- mode: glguy set +v smitop_
08:31:51 <ch3pjw> I'm actually trying to construct a bigger function that confirms whether one type-level list is the prefix of another
08:32:24 <ch3pjw> But I'm stuck with the part that compares elements of the lists
08:33:16 * hackage cgi 3001.3.0.3 - A library for writing CGI programs  http://hackage.haskell.org/package/cgi-3001.3.0.3 (PeterSimons)
08:37:54 <EvanR> ch3pjw: if you are doing tests to see if something is type-equal, then it seems like you need testEquality
08:38:23 <EvanR> if "confirms whether" means you dont already know the answer and the answer might be "no"
08:38:53 <EvanR> either way i am skeptical about the presence of 'True is the process
08:38:57 <EvanR> in the process
08:39:03 <ch3pjw> EvanR: I already have the Refl value of type a :~: b (i.e. the equality test has passed)
08:39:07 <ch3pjw> EvanR: me too!
08:39:44 --- mode: glguy set +v Boarders
08:40:47 <Boarders> hi I was using compact regions to try to serialise data that is then read by a test suite and it gives a funky GC error
08:40:54 <EvanR> i was referring to the "actual task", the list thing
08:41:06 <Boarders> I assume this is because it only is guaranteed to work on a single binary but wanted to just check with someone that knows if this is the case
08:41:34 <Boarders> (I know I can use cereal or other libraries for this purpose)
08:41:52 --- mode: glguy set +v learninghaskell5
08:42:16 <EvanR> the compact regions, iirc, can only be deserialized by the same program compiled with the same ghc version
08:43:25 <EvanR> another way to do what you want is to use Show and Read, which has deriving support?
08:48:34 <copumpkin> EvanR: tanking
08:50:08 <EvanR> thats a city in china. this is a channel about the haskell programming language
08:50:16 <copumpkin> oh sorry
09:08:40 <Boarders> EvanR: Thanks!
09:16:34 <drewbert> Has the haskell ARM scene gotten any better since I last looked a couple years ago?
09:34:57 --- mode: glguy set +v nksegos
09:48:16 * hackage dwergaz 0.2.0.3 - A minimal testing library  http://hackage.haskell.org/package/dwergaz-0.2.0.3 (henrytill)
09:49:23 <machined1od> Hi everyone... I have a question about Numeric.Natural... so, if value drops below zero, it, uh, throws an exception. I found some other, more nicely behaved packages dealing with naturals as values.... I was wondering, what is the rationale behind this choice of implementation?
09:50:32 <Athas> machined1od: probably to make the interface simpler.
09:51:14 <Athas> The alternative is to either have things like subtraction return a Maybe value (a little cumbersome), or to use type-level programming to rule out the possibility of negative numbers (extremely cumbersome).
09:51:58 <machined1od> Athas: One package on hackage deals with this by redefining subtraction to truncate to zero whenever a < b
09:52:18 <glguy> machined1od: Natural shouldn't have a Num instance since it doesn't implement subtraction reliably, but people wanted to be able to add them, so its instance is a compromise
09:52:19 <machined1od> The other one I found is practically Maybe Natural...
09:52:31 <glguy> Integer is a much better choice in general
09:53:12 <machined1od> glguy: Even when I know I'll never deal with negative values (eg. indices on vectors)?
09:53:18 <glguy> Yeah, even then
09:53:30 <glguy> It's not about what values the ranges will be in, it's what operations the type supports in general
09:54:24 <glguy> For example Data.ByteString.Lazy.length :: ByteString -> GHC.Int.Int64
09:54:28 <machined1od> See, I made a mistake of using Word previously, until 'wrapping' bit me in the ass.... so i thought using a proper Natural type would be a better solution.
09:54:48 <Athas> So why isn't it?
09:55:14 <Athas> I can't see why using Natural is worse than Integer in this case.
09:55:23 <Athas> (Except that Integer is probably a little more convenient.)
09:55:36 <glguy> Using Word or Natural, etc, just introduces new failure modes and conversions
09:55:40 <machined1od> Well... maybe I intuitively assumed that it would just wrap to 0 for subtraction, but I'm open to the idea of just having misguided intuition
09:56:16 <Athas> glguy: Natural's failure modes compared to Integer are just a louder instance of the same bug.
09:56:36 <Athas> machined1od: that sounds like a really bad solution that might mask bugs.
09:56:56 <machined1od> That's a very interesting viewpoint! I never thought about looking at it from this perspective.
09:57:41 <Athas> The best thing is total functions.  The second best thing is partial functions that model partiality with Maybe or Either.  Then comes functions that explode loudly when something goes wrong.  Last comes functions that just guess what I mean.
09:59:03 <machined1od> Right. I agree. I thought that using Natural would make the function total, because it doesn't have to accept values that it can't deal with.
09:59:30 <machined1od> But, unless I catch exceptions somewhere far, far away in IO, all I'll get is a crash with a very simplistic message :-( That isn't very helpful
09:59:38 <glguy> machined1od: For indexing a finite lengthed vector you are just as partial with negative as too-large values
10:00:18 <machined1od> Btw sorry for going offtopic here, but its interesting for me to read all this...
10:01:13 <Athas> It's really tricky to balance convenience and safety.
10:03:20 <machined1od> In my limited experience, I noticed that if functions domain is too wide, I end up in the second tier that you wrote about, using Maybe or Either, so I try my hardest to narrow it as strictly as I can... this in turn makes for quite convenient functions, I find...
10:15:31 --- mode: glguy set +v aghaskell
10:15:33 <EvanR> using subtraction with Natural seems like it requires care
10:16:05 <EvanR> in a - b you have to have proof that b is less than or equal to a
10:16:14 <EvanR> thats the missing piece
10:18:02 <EvanR> if you get or want to get a saturated 0 result, thats a different operation... "monus"
10:18:14 <machined1od> That's a good point too. In most of the code I don't even do substraction (just addition and multiplication), so I assume that additional proofing code isn't an attached complexity for *all* uses of Natural.
10:18:59 <machined1od> So, overloading (-) from Num to do this would be a no-no?
10:19:19 <EvanR> proof might not be code, its like an invisible part of the code that nonetheless you can break by changing code
10:20:56 <EvanR> > 5 - 4 :: Natural
10:20:58 <lambdabot>  1
10:21:04 <EvanR> > 4 - 5 :: Natural
10:21:07 <lambdabot>  *Exception: Natural: (-)
10:21:13 <EvanR> > 4 `monus` 5 :: Natural
10:21:15 <lambdabot>  error:
10:21:15 <lambdabot>      Variable not in scope: monus :: Integer -> Integer -> Natural
10:22:03 <EvanR> 0
10:22:57 <EvanR> um regardless, "exceptions in IO" should not be on the table here
10:28:08 <koz_> isovector's finished his book!
10:28:14 <koz_> https://leanpub.com/thinking-with-types/
10:29:56 <EvanR> the picture on the cover looks interesting
10:35:17 * hackage haskoin-node 0.9.5 - Haskoin Node P2P library for Bitcoin and Bitcoin Cash  http://hackage.haskell.org/package/haskoin-node-0.9.5 (xenog)
10:36:23 <Zemyla> I now have enough space on my Amazon VM to install Haskell again. :D
10:37:15 <Zemyla> Also, I kind of wish there were a total operation integerToENatural :: Integer -> Either Natural Natural
10:37:27 <Zemyla> With it being Left (-n) if n is negative, or Right n if n is 0 or positive.
10:38:42 <koz_> Isn't that something like 'if x < 0 then Left . fromIntegral . abs $ x else Right . fromIntegral $ x'?
10:41:47 <Solonarv> that's exactly what it is
10:42:12 <koz_> Solonarv: I dunno, maybe there's some way of writing it in like, three symbols.
10:42:18 <koz_> (people in this channel always surprise me)
10:42:37 <Solonarv> there might be, who knows? (I don't)
10:43:03 <MarcelineVQ> there is, name that foo :>  consider that behind all the golfing is still some small mess of caseing somewhere
10:44:09 <koz_> MarcelineVQ: I don't think something like that can be written without case analysis or at least an if.
10:44:21 <koz_> (I would be happy to be proved wrong though)
10:47:07 <EvanR> can you please use this function in the implementation of that
10:47:48 <EvanR> huh :: (Natural -> a) -> a -> (Natural -> a) -> Integer -> a
10:48:08 <EvanR> huh Left Right Right
10:48:12 <EvanR> :)
10:48:28 <EvanR> 4 symbols
10:48:31 <hyperisco> trying to think… why a type indexed TypeRep other than the Dynamic constructor  Dynamic :: a -> TypeRep a -> Dynamic ?
10:48:48 <hyperisco> seems a small reason to add the index
10:48:59 <EvanR> ... huh Left (Right 0) Right
10:51:16 * hackage haskoin-store 0.6.3 - Storage and index for Bitcoin and Bitcoin Cash  http://hackage.haskell.org/package/haskoin-store-0.6.3 (xenog)
10:55:31 <hpd[m]1> koz_: not 3 symbols, but completely pointless style? `liftA3 bool (Left . fromIntegral) (Right . fromIntegral . abs) (<0)`
10:55:59 --- mode: glguy set +v mson__
10:58:43 <Zemyla> Okay, I'm having a stack problem.
10:58:51 <MarcelineVQ> I have a contention with the original specification,  integerToENatural :: Integer -> Either Natural Natural  should not have a negative left because Natural is supposed to be non-negative. propose min 0 left or Integer left
10:59:20 <Zemyla> MarcelineVQ: I mean that if it's passed a negative number n, then the result is Left (fromInteger (-n)).
10:59:40 <MarcelineVQ> Oh ehe I see you're negating the negative?
10:59:44 <Zemyla> Yep.
11:00:00 <MarcelineVQ> I am no longer contentionativated.
11:00:12 <Zemyla> But yeah, when I try to start stack ghci, it goes "populating index cache...", sits for a while, and then is killed.
11:00:32 <MarcelineVQ> except that just flipping the sign is a little weird, but just being 0 is also a little weird
11:01:34 <Solonarv> I'd rather just get back a Nothing tbh
11:01:44 <MarcelineVQ> sounds like some hackage touching, try  stack update
11:02:50 <govno> Solonarv: How to write a polymorphic function in haskell such as in C++ with template parameters ?
11:02:53 <MarcelineVQ> yeah that's what it is, are you out of space where your .stack/ dir is located? hackage indexes are quite large
11:03:42 --- mode: glguy set +v npisarski
11:05:49 <Solonarv> govno: I'm not sure why you're mentioning me, but as I said last time you were asking about this: it depends on the function
11:05:49 <MarcelineVQ> quite large meaning 1.2gigs
11:06:09 <Zemyla> No, I'm not out of space. I've got 91 gigs remaining. I just increased my disk space.
11:07:12 <Zemyla> Solonarv: There already is a function that returns Nothing on negative. I want one that returns Either because it proves that every Natural is negative or nonnegative.
11:07:22 <Solonarv> oh, I see
11:07:40 <MarcelineVQ> well try  stack update  and keep en eye on it with top/htop to see what it's up to cpu/memory-wise. Do you have any custom .ghci that might be doing something when ghci starts as well?
11:08:03 <Zemyla> The fromInteger function is partial, and there's no guarantee based on the types that integerToNaturalMaybe n and integerToNaturalMaybe (-n) won't both return Nothing.
11:20:40 <govno> in c++ i can parametrize arguments by type variables...
11:22:17 <Solonarv> my C++ is incredibly rusty, I can't generate an example alongside its translation to haskell
11:23:23 <Solonarv> if you provide a c++ template function I can tell you what the haskell analog is and explain how to get there
11:23:42 <geekosaur> what exacly do you get from template parameters aside from more limited syntax?
11:24:51 <Solonarv> I think what's going on is that govno knows how to use C++ templates, heard that haskell has some similar features, and wants to learn the latter
11:27:28 <govno> haskell has FFI
11:27:28 <capisce> govno: reverse :: [a] -> [a] is similar to template <typename T> vector<T> reverse(vector<T> values); in C++
11:28:06 <capisce> it works for all types instead of being tied to any given type
11:28:23 <Tuplanolla> It's rather `list` than `vector` though.
11:28:48 <Solonarv> AIUI you can't use C++ functions via haskell's FFI directly, you need to go through C and the C FFI
11:29:17 <govno> capisce: and for what in haskell use `forall` 
11:29:39 <hyperisco> I've seen it happen before, so I'm worried that thinking in terms of C++ templates is going to miss the drastic difference
11:29:48 <capisce> govno: forall is usually implicit
11:30:02 <Solonarv> 'forall a' is analogous to 'template<typename T>'
11:30:12 <capisce> govno: that's the same as reverse :: forall a . [a] -> [a]
11:30:51 <capisce> govno: whenever you use lower case type variables like that there's an implicit forall
11:31:12 <hyperisco> What's this one Solonarv template<typename T> int f(T x) { return x.y; }
11:31:14 <capisce> govno: it'd be like in C++ you wouldn't have to write template <typename T>
11:32:08 <Solonarv> hyperisco: there's no direct equivalent, because haskell doesn't use substitution the way C++ does, so SFINAE doesn't even make sense
11:32:17 <hyperisco> exactly
11:32:33 <Tuplanolla> What's even going on there, hyperisco?
11:32:40 <stilgart> hyperisco: typeclass + instance might do the trick, no ?
11:32:55 <capisce> hyperisco: f :: Has t y => t -> y
11:33:17 <hyperisco> so I just caution that entertaining this analogy is going to lead to disappointment
11:33:22 --- mode: glguy set +v koi
11:33:38 <stilgart> > 1+1
11:33:40 <lambdabot>  2
11:33:48 <stilgart> (ok, no voice needed)
11:34:15 <koi> Hello.
11:34:27 <hyperisco> Tuplanolla, I am projecting the y field from x, whatever that ends up being.
11:34:32 <Solonarv> hyperisco: that's why I repeatedly said they're not exactly the same thing
11:35:10 <Tuplanolla> Is it safe, because the existence of the field is checked when the type variable is instantiated, hyperisco?
11:35:21 <Solonarv> that's my understanding, yes
11:35:47 <Tuplanolla> (I don't know C++.)
11:37:07 <hyperisco> here's the difference in a nutshell… in Haskell, when something has a type, it means it works for all instantiations of that type. In C++, when something has a template that tells you nothing other than how many parameters there are.
11:37:37 <hyperisco> though they're adding "concepts" sometime… no idea where that is nowadays
11:37:59 <Solonarv> any use of a template function/struct/whatever causes a monomorphized variant of that thing to be generated; you can think of this as a sort of textual substitution
11:38:22 <Tuplanolla> Now that we're on this topic, how do traits relate to this stuff?
11:38:36 <hyperisco> that depends on which language's traits you're talking about
11:38:54 <hyperisco> in PHP that just means a class mixin, iirc
11:39:10 <hyperisco> in Rust that means much like a type class, iirc
11:39:16 <Solonarv> in Rust they're a cross between Java-style interfaces and Haskell-style type classes
11:40:13 <Zemyla> This may be a kernel bug. D:
11:40:21 <EvanR> Zemyla: my huh function otoh is not partial
11:40:59 <Zemyla> And I missed what everyone said after govno said "capisce: and for what in haskell use 'forall'"
11:41:49 <Zemyla> I'd check the logs, but they seem to have stopped working D:
11:42:21 <EvanR> what is SFINAE
11:42:35 <hyperisco> you don't want to know
11:43:07 <Solonarv> "Substitution Failure Is Not An Error"
11:43:44 <hyperisco> it is how C++ does type level case analysis
11:44:32 <EvanR> that sounds orwellian
11:44:37 <hyperisco> which, as far as I understand the story, was a behaviour discovered of the compiler and now that's just "a thing"
11:45:06 <EvanR> C++ has a "the compiler" ?
11:45:23 <hyperisco> there is a standard to follow, surprisingly :P
11:45:38 <Solonarv> basically: the compiler crudely substitutes in the concrete type, and if that results in an error, said error is swallowed and the errored code is simply not generated
11:45:50 <EvanR> o_O
11:45:56 <Tuplanolla> My understanding is that every compiler mutually abi incompatible, so there might as well be, EvanR.
11:47:00 <Solonarv> Zemyla: I copy-pasted what you missed: https://paste.rs/l5w
11:47:41 <mnoonan> (concepts is supposed to be in c++20 now)
11:48:57 <Solonarv> C++ is a chimera of a language, it just keeps having More Stuff grafted on
11:50:01 <EvanR> what is "concepts" again?
11:50:34 <EvanR> every time concepts appears in any language i get mad at the choice of terminology, no matter what it ends up being
11:50:39 <hyperisco> C++ is a dusty old arcane tome unearthed and studied by its acolytes.
11:51:07 <EvanR> what word could be worse, "things" "ideas" "objects"
11:51:26 <hyperisco> EvanR, you copy what I said earlier about the difference between templates and types? Well the concept of concepts is to make templates more like types.
11:51:33 <npisarski> EvanR: "Concept" is the fundamental building block of "idea". It's an atomic unit of human thought. In psychology they can be instantiated. So "redness" may be ansantiated as an apple.
11:51:58 <hyperisco> npisarski, what did you study?
11:51:59 <__monty__> EvanR: "Type" isn't exactly that much better, you've just known it for longer.
11:52:23 <EvanR> objection sustained
11:52:46 <Solonarv> heh, *object*ion
11:52:52 <hyperisco> What kind of type are you talking about?
11:52:55 <npisarski> hyperisco: I had to take psychology for a CS degree
11:52:56 * hyperisco snickers
11:52:59 <MarcelineVQ> I can solve that, just call it Set
11:53:04 <MarcelineVQ> or Star
11:53:29 <EvanR> yes everything is a set
11:53:31 <MarcelineVQ> Or Kaminejima
11:53:43 <hyperisco> npisarski, your course sounds a lot better than the one I took
11:54:26 <Solonarv> npisarski: *had* to?
11:54:51 <Solonarv> I can see "you have to take one subject from this list", with psych appearing on that list
11:55:18 <hyperisco> those are called "electives", and though they typically stink they sometimes don't
11:55:22 <Tuplanolla> I have tried to explain to the mathematically uninitiated that "type theory is about identity and equality", but that only made it worse.
11:55:24 <MarcelineVQ> funny how part of that whole process always seems to be overloading students
11:56:30 <Tuplanolla> They may even follow up by asking "what is my type".
11:56:33 <EvanR> hyperisco: concepts of concepts?
11:56:39 <EvanR> higher order concepts
11:57:10 <hyperisco> I think it ticks some boxes for some well-meaning politicians for "well-rounded" education, but maybe I'm just cynical
11:57:45 <Solonarv> *shrug* I was looking forward to my electives, until I dropped out
11:57:53 <hyperisco> what a testimony
11:58:25 <Solonarv> I dropped out because of mental health issues, not because studies were terrible ;)
11:59:06 <hyperisco> was it going to be your first year of post-secondary?
11:59:47 <npisarski> And yeah, it was an elective. I've studied the concept of concepts a lot though because I have synesthesia, so it helps mee understand the disease.
12:00:13 <hyperisco> npisarski, how did you discover that, if you don't mind my asking?
12:00:22 <npisarski> So if "French" is a different color when used with "french fries" or "french people", I know it's because it's the same word but different concepts.
12:00:26 <__monty__> Wait, it's a disease? People always make it sound like a superpower.
12:00:50 <npisarski> hyperisco: Basically I had to go to therapy as a kid and they let me know then that thinking only in colors is 100% not normal lol. I assumed it's how everyone did until then.
12:02:06 <hyperisco> is it a problem?
12:02:09 <MarcelineVQ> Normal is one of the words of terror.
12:02:28 <govno> and for what aims use explicit `forall` keyword?
12:02:34 <npisarski> It's only a problem when two colors overlap. I get confused. Or when something is associated with a negative color.
12:02:53 <Solonarv> I stopped attending uni halfway through my first year and got kicked out automatically at the end of what would've been my second year
12:03:03 <Solonarv> depression: not even once
12:03:34 <hyperisco> npisarski, I don't think I have ever conceived of a negative colour. Well that's really interesting.
12:03:37 <npisarski> Solonarv: Dude that sucks. They didn't provide student counseling or such?
12:03:58 <EvanR> you know, white - theColor
12:04:34 <Solonarv> there's counseling, but that doesn't really help when my entire problem is "I don't do stuff"
12:05:27 <Tuplanolla> Particle physicists have a concept of color charge that comes with negation, hyperisco.
12:06:15 <hyperisco> doesn't know C++ but can casually offer analogies to physics theories
12:06:19 <hyperisco> I like your choice of knowledge
12:06:38 <Shockk> I have a quick question; I have some code under a monad transformer:  IRBuilderT (ModuleBuilderT (State [Scope]))
12:07:01 <Shockk> from this, I'd like to run, like, a sub-state of this, without modifying the current state
12:07:32 <Shockk> i.e. I'd like to get the current state, then evaluate an action of that same type, but with a temporary modified state
12:08:42 <Shockk> specifically I just want to add a new element to the start of the [Scope] list, but only within that evaluation and not within the *current* state I have
12:08:43 <hyperisco> npisarski, I wonder then if you were able to experience a colour you haven't seen before if that would become a new concept to instantiate
12:09:54 <ion> govno: There are multiple reasons to use it. For example, ScopedTypeVariables when you want to refer to the same type variable in an inner type. Or types such as (forall s. ST s a) -> a.
12:10:31 <EvanR> Shockk: you can certainly read the state, run your subcomputation normally, save the result, and restore the original state
12:10:51 <Shockk> hmm
12:11:03 <Shockk> is that the best way to do such a thing?
12:11:03 <EvanR> though i cant tell you the rest of your transformer context wont be affected
12:11:18 <Solonarv> Shockk: if your types are set up correctly, you can 'do st <- get; result <- evalStateT innerAction st; ... -- use result'
12:11:41 <npisarski> hyperisco: I've thought of that before. Probably? Supposedly studies showed that blind-from-birth people have experience color on certain medications.
12:12:37 <Shockk> Solonarv: hmm will evalStateT work when State is the innermost monad?
12:12:40 <EvanR> that might not work if IRBuilderT and ModuleBuilderT dont have simple run functions
12:12:47 <Solonarv> 'innerAction' would have type 'StateT [Scope] (IRBuilderT (ModuleBuilderT (State [Scope])))
12:12:59 <Shockk> oh I see
12:13:04 <Solonarv> Shockk: you're adding another StateT layer on the outside
12:13:11 <hyperisco> npisarski, what about spatial relationships? Do those also appear as colours? For example, the concept of "side by side" or "on top" and such
12:13:19 <Shockk> that seems like it complicates it toio much
12:13:19 <Shockk> too*
12:13:56 <Solonarv> it's not complicated at all if your code was already written in tagless-final style
12:14:18 <__monty__> Does synesthesia occur in blind people?
12:14:38 <Solonarv> it isn't limited to sight, so I don't see why not
12:16:07 <npisarski> hyperisco: Spatial relations are (I think) the only thing WITHOUT a color, actually. 
12:16:12 <MarcelineVQ> it's not like you need sight, in the form of sensors of visible light, to imagine form or images anyway. Just that such imaginings are more likely to resemble what such sensors would have given you
12:16:25 <npisarski> Ordinal things have a clear spatial map, but I think that's common and not a synesthesia thing.
12:16:47 <npisarski> The people with spatial synesthesia have really messed up maps. Like number lines in the shape of a star, etc. Just crazy stuff.
12:18:01 <MarcelineVQ> *Just that with sight such imaginings
12:22:55 <hyperisco> npisarski, do things change colour as you learn?
12:24:12 <Tuplanolla> Does the four-color theorem have a color?
12:24:23 <kadoban> four of them, I'd hope
12:24:54 <npisarski> Only if they switch concepts. So functions in programming changed once i started using Haskell over Java, because the concept was different. Before functions were "owned" by objects always, so that caused the concept to shift.
12:25:04 <npisarski> They went from yellow in Java to turquoise
12:25:22 <hyperisco> I'll remember that npisarski :)
12:25:49 <npisarski> Thanks hyperisco. It's surprising how many programmers have it / how many people don't know it's not a normal thing.
12:26:39 <monochrom> The 4-colour theorem would benefit from 5 colours so that the edges can be drawn with the 5th colour for better clarity :)
12:27:08 <EvanR> what about the background color
12:27:15 <monochrom> Oops forgor that.
12:27:25 <__monty__> npisarski: Do you adjust syntax coloring to align with your synesthesia?
12:27:25 <MarcelineVQ> "I think I have synethesia, I see js and c in different colors" "James, that is called syntax highlighting" "...Oh"
12:27:31 <EvanR> if transparant you need two more colors for the obligatory checkerboard
12:28:02 <Shockk> EvanR, Solonarv: this is what I've got now, I don't think it builds right now but obviously this is a real mess, just wondering if there's a nicer, ideal way to do it
12:28:33 <Shockk> https://gist.github.com/shockkolate/f9e38c31448004c04753c9120ddf5e65
12:29:14 <npisarski> MarcelineVQ: lol, and __monty__ not really. It's not strong with things like keywords.
12:29:28 <kadoban> MarcelineVQ: xD
12:29:59 <MarcelineVQ> aw shit, missed oppertunity  "James, that is called syntax highlighting" "...Oh. I think I have Syntax Highlighting"
12:30:44 <Shockk> syntaxthesia?
12:31:43 <kadoban> hah
12:31:44 <hyperisco> npisarski, I find that fascinating because I would have guessed learning would be an incremental change.
12:32:31 <monochrom> Not entirely.  Learning is always a lot of incremental but once in a while disruptive.
12:32:46 * hackage shake 0.17.1 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.17.1 (NeilMitchell)
12:33:08 <__monty__> npisarski: I was thinking along the lines of having indentifiers be turquoise.
12:33:46 * hackage cipher-aes128 0.7.0.4 - AES and common modes using AES-NI when available.  http://hackage.haskell.org/package/cipher-aes128-0.7.0.4 (ThomasDuBuisson)
12:34:37 <monochrom> To be sure, the disruptive ones depend on whether you stay in your echo chamber comfort zone or you get out of it once in a while (be it your choice or forced on you).
12:34:39 <hyperisco> no I have to be thinking about it wrong
12:34:47 * hackage entropy 0.4.1.4 - A platform independent entropy source  http://hackage.haskell.org/package/entropy-0.4.1.4 (ThomasDuBuisson)
12:35:40 <monochrom> For example you grew up in a creationist church but then one day someone tells you about evolution.
12:36:08 <monochrom> To be sure, when confronted with disruption, you could choose denial instead of learning.
12:36:31 <monochrom> Ignorance is bliss.  In lieu of that, you can always choose denial.
12:37:25 <hyperisco> no it is like… say we identify a concept with "221B Baker Street"
12:37:50 <hyperisco> as I learn more about "221B Baker Street" I don't have to change how the concept is identified, I just change what I associate with it
12:38:00 <hyperisco> like, it is in England, and Sherlock Holmes lives there, and so on
12:38:28 <monochrom> OK but there is always a chance that one day you learn that Sherlock Holmes is entirely fictional.
12:39:03 <monochrom> Either that, or like what the Holmes movie tells, Sherlock Holmes is real but the address is not 221B Baker Street.
12:39:09 <hyperisco> sure, but does that mean I have to change "221B Baker Street"?
12:39:16 <monochrom> Yes.
12:40:39 <hyperisco> I don't see why
12:41:40 <monochrom> There is "221B Baker Street" and then there is "221B Baker Street".
12:41:51 <hyperisco> say we do, then nothing has changed but the identifier, which doesn't seem to be needed… doable but unnecessary
12:42:29 <hyperisco> or what we do is we create a new concept, say one associated with a real location and the other associated with a fictional location
12:42:32 <monochrom> Or more clearly, there is "221B Baker Street" of this world, and then there is "221B Baker Street" of a fictional world.
12:43:14 <monochrom> Similarly, there is a real New York (in which there is no Stark Tower), and there is an MCU New York (in which there is a Stark Tower).
12:43:32 <hyperisco> so in that sense, learning something could spawn a new concept copied from an existing concept
12:43:34 <Zemyla> Anyone ever feel sorry for whoever lived at 221A Baker Street?
12:44:01 <Zemyla> Their neighbor smoked cocaine and had weirdos showing up at all hours.
12:44:58 <hyperisco> monochrom, I am just making the distinction then that we don't have to forget one 221B Baker Street to know another
12:45:03 <monochrom> Not just copying.  You have to make drastic surgery too.
12:45:14 <hyperisco> why surgery?
12:45:22 <monochrom> Why not?
12:45:34 <hyperisco> what for fun? lol
12:45:59 <MarcelineVQ> grafting is surgery
12:45:59 <monochrom> Also, after knowing that Sherlock Holmes is fictional, the real 221B Baker Street is no longer of interest to me.  I would delete it.
12:46:07 <freeman42x]NixOS> is this a correct way to handle a case which is known to never happen? https://paste2.org/2fgZVNsk basicall only adding that case to get rid of the warning
12:46:34 <hyperisco> okay, but for those not operating on a positronic matrix, we have to live with our memory :P
12:46:55 <MarcelineVQ> freeman42x]NixOS: no, at least have an error explaining what the case is, so when you do hit it, and you likely will some day, you know why
12:47:06 <monochrom> There is still a difference between "I don't have to forget" and "I would like to forget but can't."
12:47:16 * hackage hmatrix-backprop 0.1.2.5 - hmatrix operations lifted for backprop  http://hackage.haskell.org/package/hmatrix-backprop-0.1.2.5 (jle)
12:47:27 <Solonarv> Shockk: this is how I'd do it: https://gist.github.com/Solonarv/0114d8364e2d1a4eeb2e96e874bd501d
12:47:34 <freeman42x]NixOS> MarcelineVQ, ah yeah, I tried using error but it did not compile. That is because I needed to use error of some string I assume
12:48:08 <Shockk> Solonarv: hmm I see, that seems reasonable
12:48:09 <Solonarv> yes, you need to provide a descriptive string
12:48:11 <MarcelineVQ> freeman42x]NixOS: if you want to show more of what you're working on people may be able to suggest better ways to go about it as well
12:48:22 <Shockk> there's nothing like this already defined?
12:48:30 <Solonarv> not that I know of
12:48:46 <Shockk> hmm okay, thanks very much
12:48:47 <hyperisco> monochrom, if a contradiction inspires a new concept, I think it interesting question of how we know contradictions in the first place
12:48:52 <Solonarv> you could have a look through hackage, I suppose
12:49:12 <monochrom> More ObHaskelly, suppose you learned Pascal first.  Then when you move on to C, it's an incremental change.  Then when you move on to Haskell, it's a disruptive change.
12:50:05 <monochrom> Some people say, "I still start with cloning C and then do any surgery necessary to adjust for Haskell".  Sure they have the right to do that.
12:50:32 <monochrom> Unfortunately, it looks like starting from scratch in this case is more efficient than clone-then-surgery.
12:50:41 <freeman42x]NixOS> MarcelineVQ, I am working on https://www.codewars.com/kata/parse-html-slash-css-colors/train/haskell what I Currently have is: https://paste2.org/VDP5Aj6d I am aware that I could get even better type safety by creating a RGB type that has to be valid
12:51:03 <Shockk> Solonarv: hmm `locally` is failing to build for me
12:51:15 <Shockk> couldnt' match type a with () 
12:51:19 <monochrom> And by the way, I don't draw a hard line between increment and disruptive, or short and long.  I shade a whole bloody region.
12:51:22 <Solonarv> oh, duh
12:51:45 <Shockk> it should just be -> m () right?
12:51:50 <monochrom> For example, from C to SML is half incremental half disruptive, and similarly from SML to Haskell.
12:52:01 <Solonarv> 'locally act = get >>= \old -> do r <- act; put old; pure r' should work
12:52:06 <Shockk> oh right
12:52:40 <hyperisco> monochrom, I am just saying, at one point a person would perceive distinguishable things as the same thing, and at the next point they discover an irreconcilable difference, such as 221B Baker Street cannot be both nonfictional and fictional, so there must be two different things
12:53:15 <Solonarv> or the shorter variant:
12:53:15 <Solonarv> 'locally act = get >>= \old -> act <* put old'
12:54:20 <Shockk> oh nice, that makes sense
12:54:23 <lavalike> monochrom: a related instance of this phenomenon is reading documentation or books about programming, you might read hundreds and hundreds of lines and never have it never have a big impact on your coding, then you stumble onto a line once in a blue moon whose impact is incommensurable to the rest, hence I think it's a good idea to prioritize not being bored with reading than anything else, to maximize 
12:54:29 <lavalike> the opportunities
12:54:32 --- mode: glguy set +v Padawan
12:55:02 <Guest44057> hello
12:55:06 <hyperisco> monochrom, whether our starting point is "fictional 221B is the exact same as nonfictional 221B except in how they exist" or it is "I don't know what this other 221B is but it certainly fiction" isn't the interesting part
12:55:10 <lavalike> greetings Guest44057 
12:55:16 * hackage stripe-core 2.4.1 - Stripe API for Haskell - Pure Core  http://hackage.haskell.org/package/stripe-core-2.4.1 (DavidJohnson)
12:56:46 <hyperisco> monochrom, sorry, conflated my terminology… whether the concept made at the second point starts with all the same associations except the one difference or with no associations except the difference
12:56:47 * hackage stripe-tests 2.4.1, stripe-http-streams 2.4.1, stripe-http-client 2.4.1, stripe-haskell 2.4.1 (DavidJohnson)
12:57:20 <hyperisco> that's a difference in strategy which, as you point out, can vary in effectiveness
12:58:43 <hyperisco> I was always thinking in the other direction of how to find the similarity in dissimilar things
12:59:30 <hyperisco> maybe it is two sides of the same coin but I'm not sure
13:01:36 <Shockk> hmm quick question, is there a function that just maps over the first element of a list?
13:01:47 <Shockk> for example: modify $ \(scope:xs) -> HM.insert name e scope : xs
13:02:12 <Shockk> instead: modify theMagicFunction
13:02:18 <Shockk> er
13:02:28 <Shockk> instead: modify (theMagicFunction (HM.insert name e)
13:03:37 <lavalike> :t \f -> uncurry (:) . first f . fromJust . uncons
13:03:39 <lambdabot> (a -> a) -> [a] -> [a]
13:04:21 <Solonarv> fromjust? pah!
13:04:24 <lavalike> :t \f -> (uncurry (:) . first f <$>) . uncons -- Safer!
13:04:25 <lambdabot> (a -> a) -> [a] -> Maybe [a]
13:05:09 <Tuplanolla> > over (ix 0) (over (iso ord chr) (22 +)) "cup"
13:05:11 <lambdabot>  "yup"
13:05:11 <Solonarv> is there a 'cons :: Maybe (a, [a]) -> [a]' somewhere? (inverse of uncons)
13:05:20 <lavalike> hehe
13:05:29 <lavalike> Tuplanolla: o_O
13:05:29 <Solonarv> yes, 'over (ix 0)' works
13:05:49 <monochrom> @type uncons
13:05:50 <lambdabot> [a] -> Maybe (a, [a])
13:05:53 <lavalike> :t over (ix 0)
13:05:54 <lambdabot> (Num (Index t), Ixed t) => (IxValue t -> IxValue t) -> t -> t
13:05:55 <freeman42x]NixOS> I knew this but forgot. Why does show 'a' print "'a'" and how can I get it to return just "a" ?
13:06:11 <lavalike> :t putChar
13:06:12 <lambdabot> Char -> IO ()
13:06:24 <freeman42x]NixOS> lavalike, thank you!
13:06:26 <monochrom> 'a':[] = "a"
13:06:31 <lavalike> freeman42x]NixOS: \o/
13:06:40 <freeman42x]NixOS> lavalike, :) cheers
13:08:27 <lavalike> :t \f xs -> fromJust $ (uncurry (:) . first f <$> uncons xs) <|> pure xs -- no reason to get Nothing back if the list is empty
13:08:28 <lambdabot> (a -> a) -> [a] -> [a]
13:09:01 <freeman42x]NixOS> lavalike, oh wait. I do not want to print it. I just need a function Char -> String that does not do that weird "'a'" thing
13:09:11 <lavalike> oh then what monochrom said
13:09:31 <lavalike> (:[]) or pure or return
13:10:42 <freeman42x]NixOS> lavalike, ah! so make the char become a string by using list constructor?
13:10:50 <lavalike> yeah
13:11:27 <freeman42x]NixOS> lavalike, monochrom thank you
13:12:19 <freeman42x]NixOS> can I complain about something regarding Haskell? nvm, I will anyway :D it is so awkward to type from right to left instead of right to left (yes, I know you can use an operator to flip the order but that is not the default)
13:12:32 <freeman42x]NixOS> *instead of left to right
13:13:15 <Solonarv> what do you mean by that?
13:13:36 <MarcelineVQ> the default is left to right though, are you talking about . composition, or is there another way to say what you're saying? :>
13:14:48 <cocreature> I find it kind of funny how people complain about the order of f . g but are fine with the order of \x -> f (g x)
13:15:05 <lavalike> :t (&) -- :D
13:15:06 <lambdabot> a -> (a -> b) -> b
13:15:59 <freeman42x]NixOS> Solonarv, I mean that when you apply the functions they are applied from right to left. If you apply 1 extra function it usually goes to the left of existing ones
13:16:06 <freeman42x]NixOS> that makes it harder to type stuff
13:16:22 <Solonarv> ah, I see what you mean
13:17:00 <freeman42x]NixOS> say I have to type: fst $ head $ readHex $ 'a' : []. Let's say I start with: readHex $ 'a'. Then I got to move cursor to the left of it and type $ and whatever I apply and so on
13:17:01 <Welkin> has anyone used stm-containers before?
13:17:11 <Solonarv> for small stuff I usually have the entire expression in my head before I type it, and for larger functions I use a 'where' clause with each step on a line after the next
13:17:25 <Welkin> it looks like the STM Map is a newtype around Hamt, which is a newtype around a TVar already
13:17:28 <Welkin> qualified 
13:17:30 <Welkin> https://hackage.haskell.org/package/stm-containers-1.1.0.2/docs/StmContainers-Map.html
13:17:31 <freeman42x]NixOS> Solonarv, <<for small stuff I usually have the entire expression in my head before I type it>> I am really bad at that :)
13:17:43 <monochrom> Hrm what is Hamt?
13:17:46 <Welkin> does that mean I can use the STM Map without wrapping it in a TVar?
13:17:52 <Welkin> Hash-Array Mapped Trie
13:18:02 <Welkin> https://hackage.haskell.org/package/stm-hamt
13:18:39 <monochrom> Yeah you don't need an extra TVar.
13:19:27 <monochrom> Similarly you can just use TChan directly without adding your own TVar because TChan already does its own TVar.
13:19:27 <Welkin> this stm-containers package is only about 3.5 months old, but has been downloaded a lot
13:19:32 <Welkin> has anyone else used it?
13:20:06 <Welkin> monochrom: right, I forgot about that. I just think of all the concurrency types as special already
13:20:45 <monochrom> I haven't.  My use case happened a couple of years ago and I have already made my own IORef-over-immutable-dict.  (I use atomicModifyIORef and it suffices.)
13:21:31 <Welkin> the examples in the blog post confuse me though
13:21:35 <Welkin> the types looks wrong somwhow
13:21:40 <Welkin> https://nikita-volkov.github.io/stm-containers/
13:21:49 <Welkin> `TVar (HashMap (TVar a))`
13:21:54 <Welkin> where is the key to the hashmap?
13:22:18 <monochrom> Oh interesting heh.
13:22:30 <Welkin> this is the "wrong" version compared to the hash array mapped trie
13:22:44 <monochrom> I think it's a typo.
13:22:45 <cocreature> Welkin: the latest version is 3 months old, the first version is from 2014
13:23:13 <monochrom> I think he meant "TVar (HashMap k (TVar a))"
13:25:18 <fryguybob> No, the key is paired at the leaves and functions have a key extraction constraint.
13:25:42 <fryguybob> newtype Map k v = Map (HAMT (Association k v))
13:25:57 <cocreature> fryguybob: do you have a highlight on stm or are you just really good at noticing when people talk about stm? :)
13:26:05 <fryguybob> lookup :: Key k => k -> Map k v -> STM (Maybe v)
13:26:19 <fryguybob> cocreature: Both good timing and a highlight :D
13:27:26 <monochrom> Yeah, highlight is ineffective if you're afk altogether :)
13:27:28 <fryguybob> The lastest version has been reworked some but still uses the same representation.
13:27:58 <monochrom> I need to learn HAMT some day.  (And then inflict it on my students bwhahaha)
13:28:15 <fryguybob> monochrom: It is great.
13:31:52 * hackage mixed-types-num 0.3.1.5 - Alternative Prelude with numeric and logic expressions typed bottom-up  http://hackage.haskell.org/package/mixed-types-num-0.3.1.5 (MichalKonecny)
13:32:11 <zachk> whats HAMT?
13:32:23 <Welkin> how is the HAMT different from a HashMAp (or Map) wrapped in a TVar with TVar values?
13:32:25 <fryguybob> zachk: Hashed Array Mapped Trie
13:32:44 --- mode: glguy set +v urzo
13:33:01 <fryguybob> Welkin: The internal structure is built with TVars so any manipulation of the tree can be a transactional operation.
13:33:19 <Solonarv> Welkin: it's probably the same semantically, but faster / nicer
13:33:57 <Solonarv> for example if the internal structure has TVars then two threads could modify independent parts of the map at the same time
13:34:07 <Welkin> wouldn't both allow multiple threads to read data simultaneously?
13:34:22 <Solonarv> read yes, but not write (AIUI)
13:34:30 <Welkin> yeah, that is why I am going to use it
13:34:34 <Welkin> I need read and write
13:35:35 <Tordek> https://blog.plover.com/2018/11/09/#what-goes-wrong-3 so in this article he defines > double f x = f $ fmap f x, and it doesn't work; if I understood correctly is because since `double :: (f a -> g a) -> f (f a) -> g (g a)`, the inner application of `f` is  `f (g a) -> g (g a)` and a /= (g a); is there some way to type that function so that it does typecheck?
13:35:53 <Tuplanolla> Yes.
13:35:55 <Welkin> I wonder how this compares to redis as a simple key-value store
13:36:01 <Tordek> hi Tuplanolla 
13:36:07 <Welkin> I know redis is single-threaded, but still fast
13:36:15 <Tuplanolla> Give the explicit type `(forall a. f a -> g a) -> f (f a) -> g (g a)`.
13:36:16 * hackage slack-web 0.2.0.9 - Bindings for the Slack web API  http://hackage.haskell.org/package/slack-web-0.2.0.9 (EmmanuelTouzery)
13:37:02 <Tordek> great, thanks!
13:37:17 <Tuplanolla> Also see this package.
13:37:20 <Tuplanolla> @hackage mmorph
13:37:20 <lambdabot> http://hackage.haskell.org/package/mmorph
13:37:33 <fryguybob> Welkin: While the HAMT in stm-containers is somewhat fast and the nodes are reasonably compact, the TVars add significant indirection slowing it down quite a bit.
13:39:18 <fryguybob> Welkin: I would hope any well optimized single threaded structure would be signficantly faster when exercised enough.
13:39:35 <Solonarv> I'd prefer '(forall x. f x -> g x) -> f (f a) -> g (g a)', personally - makes it clearer that they're different type variables
13:43:06 --- mode: glguy set +v JanUlrich
13:43:08 <fryguybob> monochrom: I didn't inflict HAMT directly on my students yet, but I did make them add POPCOUNT instruction in an architecture class and used HAMT as the workload to see if there was a benef.t
13:43:15 <JanUlrich> hello everybody
13:43:33 <JanUlrich> i got a problem
13:43:49 <JanUlrich> if i try to install strict package with cabal it tells me: "
13:44:02 <JanUlrich> strict-0.3.2: installed package info from too old version of Cabal (key field does not match id field) Failed to install strict-0.3.2
13:44:21 <JanUlrich> im using cabal v 1.22.9.0
13:45:14 <Welkin> that is a crazy old version of cabal
13:45:25 <Welkin> we are on 2.2.x
13:45:37 <JanUlrich> oh okay thanks :D
13:45:39 <Welkin> you should probably upgrade your whole setup
13:45:42 <Welkin> what version of ghc?
13:45:49 <Welkin> should be 8.4 or 8.6
13:46:42 <JanUlrich> ghc version 8.0.2
13:46:49 <Welkin> how did you install it?
13:47:46 <JanUlrich> can't remember actually :D
13:47:47 <Welkin> go here to get a recent installer https://www.haskell.org/platform/
13:48:04 <JanUlrich> fedora package manager dnf
13:48:25 <buttons840> what's the best way to go from `m [a]` to `m [b]` using `a -> m b` ?
13:48:31 <JanUlrich> thanks alot guys
13:49:26 <Welkin> JanUlrich: installing the bindist is also very easy if you want to go that route
13:49:42 <Welkin> https://downloads.haskell.org/
13:51:49 <buttons840> :t join
13:51:51 <lambdabot> Monad m => m (m a) -> m a
13:52:05 <lavalike> :t traverse
13:52:06 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
13:52:29 <lavalike> hm nope
13:52:33 <MarcelineVQ> lavalike: yes
13:52:45 <MarcelineVQ> keep going
13:52:51 <lavalike> :)
13:53:23 <c_wraith> :t \x f -> x >>= traverse f  -- buttons840
13:53:25 <lambdabot> (Traversable t, Monad m) => m (t a) -> (a -> m b) -> m (t b)
13:53:34 <MarcelineVQ> c_wraith: spoiler :O
13:54:00 <lavalike> :t \f xs -> join $ traverse f xs
13:54:01 <lambdabot> (Traversable m, Monad m) => (a1 -> m a2) -> m a1 -> m a2
13:55:34 <Solonarv> that doesn't look right
13:57:32 <Welkin> StmContainers.Map doesn't have an `insertWith`
13:57:53 <buttons840> :t \x f -> join (map f)
13:57:54 <lambdabot> error:
13:57:54 <lambdabot>     • Couldn't match type ‘(->) [a]’ with ‘[]’
13:57:54 <lambdabot>       Expected type: [[a1]]
13:57:58 <c_wraith> lavalike, I stepped through there on my way. you're missing lifting the traverse inside of m
13:58:03 <Welkin> I suppose I need to use `focus` to perform multiple operations on it (lookup, then insert with modifications)
13:58:06 <lavalike> c_wraith: I see yeah
13:58:16 <buttons840> :t \x f -> join . map f
13:58:18 <lambdabot> p -> (a1 -> [a2]) -> [a1] -> [a2]
13:58:27 <lavalike> :t \f xs -> xs >>= traverse f
13:58:29 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> m (t a) -> m (t b)
13:58:33 <lavalike> yours is the right one
13:58:48 <MarcelineVQ> buttons840: did you mean to leave the x off?
13:59:03 <buttons840> :t \f -> join . map f
13:59:04 <lambdabot> (a1 -> [a2]) -> [a1] -> [a2]
13:59:45 <buttons840> there it is for list
13:59:45 <Solonarv> :t \f -> join . fmap f
13:59:47 <lambdabot> Monad m => (a1 -> m a2) -> m a1 -> m a2
13:59:56 <Solonarv> that's not what you want
14:00:16 <buttons840> right, not quite
14:00:55 <lavalike> :t \f xs -> sequence . map f =<< xs
14:00:56 <lambdabot> Monad m => (a1 -> m a2) -> m [a1] -> m [a2]
14:02:29 <c_wraith> sequence . map === traverse
14:02:45 <Welkin> my intuition says to use a Map of Sets to represent the data that I want to store, but I could also represent it as a Set with composite keys. Map GameId (Set PlayerId) vs Set (GameId, PlayerId), but I also want to be able to get all of the data for a given GameId `lookup (gameID, _) set`
14:03:05 <Tuplanolla> :t join .: fmap . traverse
14:03:06 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> m (t a) -> m (t b)
14:03:19 <Tordek> https://dpaste.de/k7L4 Tuplanolla it doesn't seem to like that definition :/
14:03:38 <Tordek> oh nevermind i'm dumb
14:04:36 <Tordek> https://dpaste.de/xNus but still
14:05:13 <lavalike> :t (join .: fmap)
14:05:15 <lambdabot> Monad m => (a1 -> m a2) -> m a1 -> m a2
14:05:32 <dmwit> Welkin: `Map GameID (Set PlayerID)` seems sensible to me, though I lack all context (I've seen only your latest message). If you think you might want to look up game IDs given a player that's in the game, you might look at the Relation type available on Hackage.
14:05:51 <dmwit> http://hackage.haskell.org/package/relation-0.2.1/docs/Data-Relation.html
14:05:51 <lavalike> makes sense
14:05:54 <Tordek> ah, typo
14:06:00 <dminuoso> lavalike: That's just >>= ... 
14:06:12 <lavalike> :D
14:06:14 <Welkin> I will only ever need to insert players into the set and lookup by gameid, never by playerid
14:06:16 <dmwit> dminuoso: Well, =<< ...
14:06:27 <Welkin> I have the real information stored in postgres, but this is for presence data (who is online right now)
14:06:45 <Tuplanolla> @let double :: (Functor f, Functor g) => (forall a. f a -> g a) -> f (f a) -> g (g a); double f = f . fmap f
14:06:46 <lambdabot>  Defined.
14:06:49 <Welkin> I'm just looking for a way to avoid having empty sets/keys sitting around
14:06:54 <dminuoso> dmwit: Heh. :)
14:06:55 <Tuplanolla> There it is, Tordek.
14:07:04 <Tordek> yep, I forgot the f, I got it working now :) thank you
14:07:10 <dmwit> Tuplanolla: Is this for that MJD blog post?
14:07:11 <Welkin> I thought about deleting them when the size of the set is 0, but that adds a lot more complexity
14:07:21 <Tuplanolla> Probably, dmwit.
14:07:33 * dmwit nods
14:07:41 <c_wraith> Welkin, not if you use lenses
14:07:48 <Tordek> yeah, it got me curious, dmwit :)
14:08:10 <c_wraith> Welkin, that's precisely what non is for.
14:08:23 <dmwit> Right. The solution is obvious-ish to anyone who's played with RankNTypes before, but v. puzzling for those that haven't.
14:08:24 <zachk> :t (>>=) 
14:08:24 <Welkin> and of course I also need some kind of upsert function, which unfortunately the stm-containers library does not provide
14:08:26 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:12:14 <c_wraith> Welkin, wow, at first I thought it must have all those operations hidden behind some super generic interface like alterF. but.. that interface is basically empty.
14:13:03 <Welkin> at least it has `focus`
14:13:10 <Welkin> which looks like what I will have to use for everything
14:14:14 <c_wraith> Welkin, ah, yes. focus does all the alterF stuff. I guess I understand why, given that everything returns STM values
14:14:22 <Welkin> here we go https://hackage.haskell.org/package/focus-1.0.1.2/docs/Focus.html#v:insertOrMerge
14:33:04 --- mode: glguy set +v Guest12
14:51:39 --- mode: glguy set +v Guest12
14:58:47 * hackage stack 1.9.1.1 - The Haskell Tool Stack  http://hackage.haskell.org/package/stack-1.9.1.1 (borsboom)
15:40:41 <buttons840> I'm creating some C bindings using c2hs. c2hs creates some Haskell equivalents of some C enum types, the data constructors are pretty self explanitory (for example, you can guess what the F constructor of type KeyboardKey does), but I can't get haddock document these constructors. Anyone know if I can force haddock to export all the constructors?
16:05:06 <zachk> is there a cabal clean function to clean exe's built under dist?
16:15:35 <royal_screwup21> are <$> and <*> combinators?
16:15:47 <Solonarv> sure
16:15:53 <royal_screwup21> wow
16:16:10 <Solonarv> "combinator" doesn't have a very precise definition, tbh
16:16:45 <buttons840> what is the extension that lets you define types without constructors?
16:16:48 <EvanR> things you can combine
16:16:53 <EvanR> heh
16:17:11 <dsal> COMBINATE!
16:17:22 <Solonarv> buttons840: EmptyDataDeclarations I think
16:17:23 <buttons840> "combinatable"
16:17:44 <Solonarv> you can just try writing an empty data definition and GHC will tell you what the extension is
16:18:00 <EvanR> graphical linear algebra even goes as far as using an analogy to lego
16:18:04 <buttons840> as in, "you can't use that with combinators because it is not combinatable"
16:18:28 <EvanR> i refudiate that terminology
16:18:39 <Solonarv> you'll get an error message like "error: empty data declaration, did you mean to use WhateverTheExtensionIsCalled?"
16:18:44 <MarcelineVQ> EmptyDataDecls it seems like it's usually on though, since I've never needed to specify that extension
16:18:45 <geekosaur> terminatology?
16:18:54 <geekosaur> I think it's defautl as of H2010?
16:19:00 <Solonarv> it might be implied by Haskell2010 yeah
16:19:24 <buttons840> Solonarv: oh, good tip, ty
16:19:54 <Solonarv> that works for a lot of things, actually
16:19:57 <MarcelineVQ> royal_screwup21: https://wiki.haskell.org/Combinator
16:20:07 <Solonarv> er, s/things/extensions/
16:20:18 <Welkin> damn!
16:20:20 <Axman6> there's probably an argument to say that <$> is not a combinator but <*> is, as the latter combines things of the same structure
16:20:23 <EvanR> words like EmptyDataDecls always makes me call into question the arbitrary way stuff is abbreviated, or not abbreviated
16:20:25 <Welkin> my idea for presence isn't quite working
16:20:55 <Welkin> I write to the channel after duplicating it, but the subscriber seems to never get that first message
16:21:11 <Welkin> or maybe the message never gets written
16:21:13 <Welkin> I haven o idea
16:21:14 <Solonarv> yeah, haskell (or should I say GHC?) extensions are that way
16:21:19 <EvanR> "presence", isnt everyones idea for that not working?
16:21:20 <Welkin> none of the subscribers seem to get the message
16:22:14 <zachk> can you get them any messages? says in a simpler setup?
16:22:29 <hpc> iirc a combinator is a definition that uses only bound variables, and no free ones
16:22:32 <Welkin> I am not sure if they get messages or not
16:22:36 <Welkin> mauybe I can print out the messages
16:23:11 <Solonarv> hpc: that's one of the definitions given on that page
16:23:32 <hpc> ah, neat
16:23:34 <Welkin> no Show instance
16:23:44 <hpc> i just had to double-check that that wasn't supercombinator
16:23:45 <Welkin> how do you debug channels?
16:23:59 <hpc> in any event it's hard to really make a distinction based on that alone
16:24:15 <hpc> because you can substitute the body of a free variable in
16:25:27 <hpc> i usually go with "simple definitions i use to compose things" and then just never call it combinator in the interest of precise definitions
16:25:54 <hpc> so (<$>) is a combinator
16:26:06 <hpc> or maybe not because it's a class method, depending on what mood i am in and what i consider composition
16:26:23 <hpc> (.) is never not a combinator :D
16:26:45 <Solonarv> but (<$>) is sometimes (.) !
16:27:17 <EvanR> haskell is interesting because you can put so many different (comp sci -wise) things in the same expresssion 
16:27:42 <EvanR> it could even be expanded to allow more, i think
16:27:58 <Solonarv> it *is* being expanded to allow more
16:28:00 <Solonarv> all the time
16:28:31 <EvanR> papers often have very strict languages
16:28:33 <hpc> Solonarv: no, they are being discovered
16:28:46 <Solonarv> hpc: I mean haskell specifically is being expanded
16:28:50 <hpc> a nameless explorer dug up ghc from the depths of r'leh in the mid 1800s
16:29:04 <hpc> and we watch in horror as it changes before us
16:29:05 <hpc> :D
16:29:08 <koz_> hpc: Frankly I suspect that's where JavaScript was found.
16:29:16 <koz_> Depths of R'lyeh.
16:30:15 <Solonarv> said { explorer
16:30:15 <Solonarv>      ; immediately went mad
16:30:15 <Solonarv>      ; at the sight of shifting
16:30:15 <Solonarv>      ; lines
16:30:15 <Solonarv>      }
16:30:44 <hpc> Solonarv: i wish i could @remember that without ruining the joke
16:31:31 <Welkin> well, my approach half-works if the client manually disconnects by closing the connection with a function call
16:31:33 <MarcelineVQ> And in the tomes his terrible end can be read, "error: Variable not in scope: said"
16:31:34 <Solonarv> I feel honored ;)
16:32:12 <Welkin> but if the client navigates to a different url, or closes the tab, nothing happens 
16:32:32 <Welkin> I was sure this would work, but I was wrong. Unless I am not doing it right
16:32:59 <hpc> Welkin: https://stackoverflow.com/questions/1631959/how-to-capture-the-browser-window-close-event might help
16:33:11 <Welkin> that's just one of many issues
16:33:19 <Welkin> I need to know when they close the connection
16:33:33 <Welkin> I thought handling it through an exception would work, but apparently only in some cases
16:33:58 <hpc> at least for leaving the page, you can call that function that closes the connection
16:34:11 <Welkin> this is an event-stream, so the server an send stream data to the client, and I am keeping the connection from timing out by sending a ping every 15 seconds
16:35:15 <Welkin> apparently the way to do it *is* to check for a broken connection, but it only works when the client explicitly closes it using .close() on the event stream
16:35:26 <Welkin> at least in my limited experience with it
16:36:13 <zachk> why not use websockets?
16:36:13 <Welkin> unless the thread just dies immediately without allowing me to handle the exceptions
16:36:38 <Welkin> zachk: it is vastly more complicated to set up, and does not work through an http proxy (you need a tcp proxy)
16:36:43 <Welkin> and it has disadvantages to sse
16:39:18 <Welkin> either I am not catching the exception at the right place in the code, or it is not getting propogated up
16:39:38 <Welkin> propagated*
16:49:23 <royal_screwup21> so I'm trying to figure out what the highlighted stuff is doing https://prnt.sc/lihzfh specifically, how did we get those results?  For the 1st example, I understand parse number "123"  = [("123", "")]. What happens after that? I understand <$> behaves like an fmap, but I can't see the connection :(
16:50:18 <koz_> You can read ((+1) <$> number) as fmap (+1) number.
16:50:21 <koz_> Does that make more sense?
16:51:16 * hackage viewprof 0.0.0.24 - Text-based interactive GHC .prof viewer  http://hackage.haskell.org/package/viewprof-0.0.0.24 (MitsutoshiAoe)
16:51:57 <royal_screwup21> hm I guess...not sure I see how parse (+1) [("123", "")] makes sense though. Also, the definitions are like so: newtype Parser a = Parser (String → [(a, String)])
16:51:57 <royal_screwup21> parse :: Parser a → String → [(a, String)]
16:52:21 <koz_> parse (+1) [("123", "")] indeed makes no sense.
16:52:26 <koz_> But that's _not_ what you've got there.
16:52:44 <Welkin> there may be a way to get presence data from couchdb
16:53:09 <Welkin> I know that roll20 uses firebase for their game data, and it has a built-in presence feature (if the user is connected to the database, they are online, basically)
16:53:22 <Shockk> can someone familiar with llvm-hs tell me if it's valid for me to add multiple functions with the same name using the module builder? I understand that the IR builder enumerates duplicate names like "arg" becomes "arg2" and "arg3" and so on
16:53:33 <Shockk> will this happen with names of functions as well?
16:54:02 <Welkin> I have had little to no luck finding information on any of these topics though, so it has been mostly experimentation and reading about high-level concepts like heartbeats
16:54:16 * hackage envy 1.5.1.0 - An environmentally friendly way to deal with environment variables  http://hackage.haskell.org/package/envy-1.5.1.0 (DavidJohnson)
16:56:12 <Welkin> holy shit
16:56:14 <royal_screwup21> koz_: I don't see the order in which the functions are run. So, I think `parse number` is first function run on the input string, and we get back a result. I don't understand the next function run on this result...
16:56:23 <Welkin> roll20 sends almost 200 requests to load a game
16:56:32 <Welkin> and transfers over 6 mb of data
16:56:43 <koz_> royal_screwup21: What is the type of parse?
16:57:00 <Welkin> it's mostly just crap
16:57:17 <Solonarv> 'parse :: Parse a -> String -> [(String, a)]' koz_
16:57:17 <koz_> Welkin: Or, as the cool kids like to say, 'modern design'.
16:57:27 <koz_> (replace 'modern' with any of a bunch of other adjectives)
16:57:49 <Solonarv> well, theoretically HTTP/2 is supposed to make that a bit less sucky... still not great though
16:58:33 <koz_> Solonarv: That was meant to be for royal_screwup21 to answer.
16:58:40 <koz_> (I'm quite aware)
16:58:49 <Solonarv> they already answered it
16:59:07 <koz_> Solonarv: I wanted to highlight it for pedagogical reasons.
16:59:18 <Solonarv> I just repeated their answer because I thought you'd missed it, sorry
16:59:25 <Welkin> firebase uses SSE, no websockets
16:59:36 <koz_> royal_screwup21: Since Solonarv beat you to the punch, what's 'Parse a'?
16:59:49 <royal_screwup21> so parse taken in a Parser, a string and returns a list with one tuple
16:59:52 <koz_> (you also told me this before, but I want you to look at it more carefully)
17:00:01 <royal_screwup21> takes*
17:00:05 <koz_> Sorry, Parser a.
17:00:36 <Solonarv> a list with one tuple? are you sure?
17:01:40 <royal_screwup21> Parser a is a datatype paramterized on a...it takes in a function that converts a string to  [(a, String)]
17:02:22 <koz_> royal_screwup21: newtype Parser a = Parser (String → [(a, String)]) <-- remember this?
17:03:10 <koz_> What would the Functor instance for Parser look like?
17:05:24 <Shockk> ooh okay yes, llvm-hs does append ascending numbers to the function names
17:05:31 <Shockk> i.e. _block, _block.1, _block.2, _block.3, etc
17:07:52 <Shockk> as a result, I'm now able to code-gen this correctly 
17:07:53 <Shockk> https://gist.github.com/shockkolate/7d20ea57df624f29c4e831465a2b054f
17:08:43 <royal_screwup21> koz_: not sure tbh. I'm thinking what fmap Parser p would look like...
17:09:14 <royal_screwup21> fmap f Parser p
17:09:19 <koz_> royal_screwup21: Start with the type.
17:16:56 <royal_screwup21> koz_: I don't see it :( So Parser p returns something of type [(a,String)]. We to fmap over this with a function f...the type of the result from doing that should be [(a,String)] as well
17:17:28 <koz_> Parser a = Parser (String -> [(a, String)]) right?
17:17:43 <koz_> So thus, the fmap definition for Parser is
17:17:51 <koz_> fmap :: (a -> b) -> Parser a -> Parser b
17:18:31 <koz_> Because intuitively, a 'Parser a' is a function which, given a string, tries to extract a's from that string repeatedly.
17:18:53 <koz_> So the idea with this fmap is that if we know how to parse a's, and we have a way of turning a's into b's, we now have a way to parse b's.
17:18:58 <koz_> Make sense so far?
17:20:11 <koz_> s/definition/type signature/
17:21:08 --- mode: glguy set +v simps
17:25:30 <royal_screwup21> koz_: so the def. would be fmap f (Parser a) = Parser (f a)
17:26:11 <koz_> royal_screwup21: No.
17:26:17 <koz_> But that's not really the key idea here.
17:26:30 <koz_> The key idea is that, if we can parse a's, as long as we can turn a's into b's, we can parse b's too.
17:26:43 <koz_> And fmap is what enables us to do this 'parser conversion'.
17:27:01 <koz_> So let's look at the first thing that's confusing you.
17:27:06 <dmwit> royal_screwup21: If `fmap :: (a -> b) -> Parser a -> Parser b`, think: what is the type of `a` in `fmap f (Parser a)`? (Hint: not `a`.)
17:27:23 <koz_> 'parse (fmap (+1) number) "123"'
17:27:29 <koz_> What's the type of 'number'?
17:28:09 <royal_screwup21> ah right, so that's a function...mapping from String -> [(Int, String)]
17:32:00 <royal_screwup21> dmwit: a::String-> [(the_type_Parser_is_parameterized_on, String)]?
17:32:42 <royal_screwup21> oh dear, this is confusing
17:32:54 <dmwit> royal_screwup21: right =)
17:33:11 <dmwit> So `f a` isn't going to work quite right, is it?
17:33:31 <dmwit> You got to make it down under the function arrow, into the list, and off to the left of the tuple.
17:33:35 <dmwit> It's a windy road...
17:36:26 <Welkin> I don't know anymore
17:36:47 <Welkin> it's possible I may need to end up using websockets, but it should be possible to get this working without it
17:36:59 <royal_screwup21> dmwit: so it's fmap f (Parser my_parser) input_string = f (my_parser input_string)?
17:37:28 <royal_screwup21> fmap f ((Parser my_parser) input_string) = f (my_parser input_string)
17:38:03 <dmwit> royal_screwup21: Okay, same question as before. If `fmap :: (a -> b) -> Parser a -> Parser b`, what is the type of `my_parser input_string` in `fmap f (Parser my_parser) input_string`?
17:39:41 <royal_screwup21> dmwit: the type of that would be [(the_type_Parser_is_parameterized_on, String)]? cuz my_parser is a function. It's applied on  a string. And the result of that is a list with one tuple...
17:41:13 <dmwit> That type looks right.
17:41:26 <dmwit> Your conclusion that the result is a list with one tuple sounds unjustified to me.
17:41:55 * hackage primitive 0.6.1.1 - Primitive memory-related operations  http://hackage.haskell.org/package/primitive-0.6.1.1 (CarterSchonwald)
17:42:02 <ktonga> hi, can somebody please help me with this error, I dunno why it's happening
17:42:04 <royal_screwup21> I guess it could be an empty list as well...
17:42:05 <ktonga> maybeShow :: (Show a) => Maybe a -> Text
17:42:05 <ktonga> maybeShow = maybe "" show
17:42:05 <ktonga> blah :: Text
17:42:05 <ktonga> blah = maybeShow (Just True)
17:42:05 <ktonga> meh :: Text
17:42:06 <dmwit> And specifically, since we've named the type the parser is parameterized on, we can shorten it to just [(a, String)]. (And we're trying to get a `String -> [(b, String)]`.)
17:42:07 <ktonga> meh = maybeShow Nothing
17:42:19 --- mode: ChanServ set +o dmwit
17:42:32 <dmwit> royal_screwup21: Sure. Or it could have two elements, or three, or...
17:42:38 <ktonga> in the case of meh it fails with "Ambiguous type variable ..."
17:42:57 <royal_screwup21> dmwit: ah okay...I got confused because there's two meanings for 'a' - it could be the paramterized type, or it could be a function...
17:43:02 --- mode: dmwit set -o dmwit
17:43:09 <koz_> ktonga: That 'Nothing' could be 'Maybe a' for _any a whatsoever_.
17:43:43 <dmwit> ktonga: Yeah, that's a bit annoying. For `Maybe` in particular it doesn't really matter: all contained types still show as the String `"Nothing"`.
17:43:46 <ktonga> if i annotate the Nothing :: Maybe Bool it works
17:43:49 <dmwit> ktonga: But it doesn't have to be that way.
17:43:57 <royal_screwup21> oh yes that makes sense...so it could be a list with any number of tuples
17:43:59 <ktonga> it happens with [] too
17:44:14 <koz_> ktonga: That's precisely it - if you annotate it, then you've said for which particular Maybe X you want a Nothing.
17:44:17 <dmwit> ktonga: Think about `show []`: if `[] :: String`, you get `"\"\""`, but if `[] :: [Int]` you get `"[]"`.
17:44:26 <koz_> The empty list is similar: [] is a [a] _for any a whatsoever_.
17:44:27 <dmwit> > show ([] :: [Char])
17:44:30 <lambdabot>  "\"\""
17:44:32 <dmwit> > show ([] :: [Int])
17:44:34 <lambdabot>  "[]"
17:44:49 <dmwit> ktonga: So to know what String to return, it has to know what type you want it to try to `show` at.
17:45:25 <ktonga> yeah what confuses me is that in the case of [] i dont use the show at all
17:45:54 <dmwit> You only think that you don't use it. But you do (well, the compiler does).
17:46:48 * dmwit channels his inner obtuse zen master
17:47:22 <ion> Ignoring what the compiler is doing, what do *you* say is the concrete type of the "a" the type of "Maybe a" in "maybeShow Nothing"?
17:47:44 <dmwit> ?let data MyMaybe a = MyNothing | MyJust a
17:47:45 <lambdabot>  Defined.
17:48:01 <dmwit> ?let instance Show (MyMaybe Int) where show _ = "in the Int instance!"
17:48:02 <lambdabot>  Defined.
17:48:12 <dmwit> ?let instance Show (MyMaybe Bool) where show _ = "in the Bool instance!"
17:48:13 <lambdabot>  Defined.
17:48:23 <dmwit> > (MyNothing :: MyMaybe Int, MyNothing :: MyMaybe Bool)
17:48:25 <lambdabot>  (in the Int instance!,in the Bool instance!)
17:48:43 <dmwit> ktonga: Do you agree that for `MyMaybe`, it makes sense for the compiler to demand that you choose which type is contained?
17:48:48 <dmwit> That is, does this error make sense to you?
17:48:50 <dmwit> > MyNothing
17:48:52 <lambdabot>  error:
17:48:52 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M532080599837...
17:48:52 <lambdabot>        prevents the constraint ‘(Show (MyMaybe a0))’ from being solved.
17:49:45 * dmwit disappears in puff of smoke
17:49:59 <ktonga> sorry guys i was afk, reading now
17:52:02 <ktonga> ok, yeah i guess it makes sense now
17:52:52 <ktonga> thank you all for the detailed explanation
17:53:36 <koz_> ktonga: You're welcome!
17:53:48 * koz_ summons back dmwit by sacrificing a lemon.
18:02:37 <royal_screwup21> do I need to know to understand https://prnt.sc/lihzfh I can work with fmap on <$> on trivial examples with lists, but clearly I'm missing something fundamental, or I justdon't have the IQ to grok this the highlighted stuff :(
18:02:40 <royal_screwup21> what do*
18:02:46 <royal_screwup21> fmap and *
18:05:40 <ion> Taking away the Parser newtype wrapper, fmap_Parser :: (a -> b) -> (String -> [(a, String)]) -> (String -> [(b, String)]). It may be a good exercise to implement that function yourself.
18:08:18 <royal_screwup21> ion: I guess my question is, how do I fmap over a function?
18:08:47 <royal_screwup21> I need to fmap over a function of type  (String -> [(a, String)])
18:10:15 <ion> Note that the final parentheses are redundant, this is the same type: fmap_Parser :: (a -> b) -> (String -> [(a, String)]) -> String -> [(b, String)]
18:10:35 <ion> So in addition to a couple of functions, you have something concrete to start with, a String.
18:11:23 <ion> Conveniently, you also have a function that takes a string as input. You can start from there.
18:12:09 <koz_> Out of curiosity - would DeriveFunctor be able to derive a Functor instance for this definition of Parser?
18:13:41 <ion> yesyes
18:13:43 <ion> whoops
18:13:49 <ion> Just yes. :-P
18:13:55 <koz_> ion: Lol.
18:13:58 <koz_> Just Yes.
18:14:25 <koz_> That's pretty cool.
18:16:34 <royal_screwup21> fmap f (parser input_string) = change_first_element (parser input_string) where change_first_element (first, second) = (f first, second)
18:16:48 <royal_screwup21> ugh idk ignore that
18:45:15 <isovector1> `CoT` seems to give me a monad transformer over a comonad but i can't figure out how to actually run the thing
18:55:58 <lyxia> I guess it depends on the comonad
18:56:19 <isovector1> Store
18:56:21 <lyxia> it sure looks like a fun type
18:58:07 <lyxia> CoT w (Store s) a ~~~ forall r. s -> (s -> a -> m r) -> m r   that's CPS-ed StateT.
18:58:27 <isovector1> i think you got that backwards
18:58:34 <isovector1> `CoT (Store s) IO`
18:59:01 <isovector1> or maybe you are on another level than i am :D
18:59:13 <lyxia> uh I meant CoT (Store s)) m
19:00:40 <lyxia> but other than unfolding things like that I have no intuition for what cot does
19:01:02 <isovector1> hmm yeah i see the unravelling now
19:01:11 <isovector1> okay, i'll play with it. thanks!
19:01:43 <lyxia> :)
19:20:20 <leifmetcalf> How do you add haddock-generated documentation to your package on hackage?
19:22:31 <isovector1> leifmetcalf: you use stack to upload it and deal with it for you
19:22:41 <isovector1> i've never had luck using cabal
19:23:05 <leifmetcalf> oh
19:23:10 <leifmetcalf> Yeah that works
19:23:21 <leifmetcalf> thank you
19:23:46 * hackage artifact 0.0.0.0 - Basic types and instances for Valve's Artifact Card-set API  http://hackage.haskell.org/package/artifact-0.0.0.0 (leif)
19:24:56 <MarcelineVQ> http://hackage.haskell.org/upload
19:28:10 <dmwit> cabal's upload should work fine, too.
19:28:29 <dmwit> It takes a few minutes to build on the server, is all.
19:31:24 <isovector1> lyxia: mind doublechecking this logic for me? `co :: Functor w => (forall r. w (a -> r) -> r) -> Co w a` is the introduction for `CoT w Identity`
19:31:48 <isovector1> its implementation is `co f = CoT (Identity . f . fmap (fmap runIdentity))`
19:32:03 <isovector1> which suggests it can't be done for `IO` since there is no `runIO`
19:35:35 <koz_> isovector1: Hihi!
19:35:38 <koz_> I bought your book.
19:36:47 <lyxia> isovector1: what can't be done for IO
19:38:04 <lyxia> if you mean changing Co w a to CoT w IO a, that sounds about right.
19:38:26 <isovector1> i mean like, implementing trying to implement `coT` analogously to the implementation of `co`
19:38:39 <isovector1> koz_: hi! thanks :) what do you think so far?
19:38:57 <koz_> isovector1: It's pretty damn good. I was interested from the day I got linked to the preview, and seeing the finished work is good.
19:38:59 <isovector1> lyxia: i'm trying now having moved `r` into a type parameter of `CoT` rather than as the existential
19:39:06 <isovector1> koz_: glad to hear that :D
19:39:08 <koz_> It makes a great companion to jle`'s Introduction to Singletons.
19:40:16 <koz_> isovector1: As a complete aside, would you be interested in writing up a bit about how the internals of ecstasy work?
19:40:23 <koz_> I'd be _very_ interested to read that.
19:40:29 <lyxia> coT = CoT ?
19:41:46 <isovector1> no, like some helper that constructs CoT
19:42:06 <isovector1> koz_: have you seen my blog posts about it?
19:42:57 <lyxia> "a helper that constructs" sounds like "constructor" *shrugs*
19:43:17 * hackage co-log-core 0.1.1 - Composable Contravariant Comonadic Logging Library  http://hackage.haskell.org/package/co-log-core-0.1.1 (shersh)
19:43:43 <koz_> isovector1: I've seen this one: http://reasonablypolymorphic.com/blog/why-take-ecstasy/
19:44:51 <isovector1> ¯\_(ツ)_/¯ maybe i should just use unsafePerformIO
19:45:19 <lyxia> yes good idea
19:53:21 * hackage co-log 0.2.0 - Composable Contravariant Comonadic Logging Library  http://hackage.haskell.org/package/co-log-0.2.0 (shersh)
21:07:51 <koz_> Is there an analogue to (==#) for Word64#?
21:13:18 <selfsymmetric-mu> ,hoogle Word# -> Word# -> Word#
21:13:44 <selfsymmetric-mu> @hoogle Word64# -> Word64# -> Word64#
21:13:45 <lambdabot> Prelude const :: a -> b -> a
21:13:45 <lambdabot> Data.Function const :: a -> b -> a
21:13:45 <lambdabot> Data.Array.Accelerate const :: a -> b -> a
21:13:56 <koz_> selfsymmetric-mu: It's fine, found a solution.
21:59:57 --- mode: glguy set +v koankeeper
22:01:10 --- mode: glguy set +v feepo
22:03:11 <nilOps> does haskell have a way to capture arithmetic over/underflow?
22:51:42 <koz_> DerivingVia appears to be broken on all tools everywhere.
22:51:51 <koz_> HLint = broken, hindent = broken, argh.
23:00:44 <puffnfresh> koz_: both are based on haskell-src-exts
23:00:53 <puffnfresh> think that needs to be fixed :)
23:01:33 <koz_> puffnfresh: Thanks for giving me another thing to prod. Does it have an issue tracker?
23:01:57 <puffnfresh> https://github.com/haskell-suite/haskell-src-exts/issues
23:02:11 <koz_> Thanks!
23:04:11 <koz_> Alrighty, add one more to my pile of reported issues, lol.
23:20:22 * hackage lens-toml-parser 0.1.0.3 - Lenses for toml-parser  http://hackage.haskell.org/package/lens-toml-parser-0.1.0.3 (henrytill)
23:57:00 <MarcelineVQ> is Dmitrii Kovanikov in here?
