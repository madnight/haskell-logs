00:11:07 * hackage dhall 1.19.1 - A configuration language guaranteed to terminate  http://hackage.haskell.org/package/dhall-1.19.1 (GabrielGonzalez)
00:59:29 <sshine> koz_, https://github.com/exercism/haskell/pull/785/files#diff-95b4a21f5f979651e225d8bbf44821f5
01:02:36 <koz_> sshine: To do pangram checking, you wanna do a pass through it with one of these: http://hackage.haskell.org/package/text-1.2.3.0/docs/Data-Text.html#g:11 , tracking what you've seen so far, then counting at the end whether all 26 letters appear.
01:04:09 <sshine> koz_, my preferred solution is: 'Set.null . T.scanl deleteLower alphabet where deleteLower cs c = Set.delete (C.toLower c) cs'
01:04:56 <sshine> koz_, the example isn't supposed to be the "best" in any way, just validate that the test works. so I translated the one that existed for `String`. but there's no reason why it shouldn't be a better version now that there isn't one.
01:05:58 <fr33domlover> In the scientific package, is it safe to use floatingOrInteger where the integral type is Integer? I mean due to laziness that Integer isn't computed until needed? (hmm but then could still fill memory when used? I'll try in GHCI :P)
01:06:04 <koz_> Then that works.
01:06:51 <sshine> koz_, right. :) thanks. I think it takes a little getting used to Data.Text, but for the most part, the library is even more convenient. except that it doesn't have `elem`, it seems.
01:08:08 <Ariakenom> fr33domlover: What do you mean would be the problem? Int is just as lazy
01:08:40 <koz_> sshine: I suspect because string matching is usually more involved than that. You can hack together something like elem with one of the folds I linked if you really need it though.
01:08:55 <koz_> (or your approach I guess)
01:09:05 <sshine> koz_, would that be better than `T.any . (==)`?
01:09:38 <koz_> sshine: It depends how how T.any is implemented.
01:09:44 <sshine> koz_, I figured that T.any is lazy and that the folds aren't.
01:09:45 <koz_> I suspect it's in terms of one of the folds though.
01:10:02 <sshine> koz_, but now that I think of it, I don't see why they shouldn't be.
01:10:25 <koz_> sshine: For the record, T.any is based on http://hackage.haskell.org/package/text-1.2.3.0/docs/src/Data.Text.Internal.Fusion.Common.html#any
01:10:36 <sshine> koz_, I generally try to avoid folds if there's a more appropriate combinator, since folds are as close to the manual recursion scheme as I get.
01:10:53 <fr33domlover> Ariakenom, I mean Int is bounded. But hmmm I tried in GHCi and it seems even with Int it builds the whole huge integer first... I guess that's why toBoundedInteger exists in Data.Scientific :)
01:11:00 <koz_> While foldl' (which is what I'd probably write this in terms of) is http://hackage.haskell.org/package/text-1.2.3.0/docs/src/Data.Text.Internal.Fusion.Common.html#foldl%27
01:11:15 <koz_> The two are _very_ similar, so I suspect it'd probably run about the same either way.
01:12:00 <koz_> Additionally, they both fuse.
01:12:01 <sshine> koz_, but wouldn't `foldl'` recurse towards the end while `any` stops at the first element for which its predicate is `True`?
01:12:13 <koz_> sshine: Read the implementations if you want to confirm that.
01:12:33 <koz_> I haven't looked at them in enough detail, but from a casual glance, I wouldn't say any can do some kind of short-circuiting.
01:13:32 <koz_> Specifically, look at 'case next s' versus 'case next0 s' - they're spelled damn near identically.
01:13:41 <sshine> yes, any specifically short-circuits.
01:13:49 <sshine>                       Yield x s' | p x       -> True
01:13:49 <sshine>                                  | otherwise -> loop_any s'
01:14:06 <sshine> and I'm not sure how foldl' could.
01:14:17 <koz_> Yeah, good point.
01:14:35 <koz_> In that case, T.any is a better choice.
01:14:47 <koz_> Usually whenever you have questions like this, a good starting point is to read the source.
01:15:03 <sshine> I wasn't thinking that for the reason of the low-level implementation detail of short-circuiting, but because `any` is more specific than `foldl'`.
01:15:48 <sshine> yeah :) when I started doing Exercism exercises, I did a whole lot of benchmarking trying to optimize my code, only to find out that if I just wrote it abstract enough, it'd usually be as efficient as the most optimzed thing I could easily think of (e.g. wrt. strictness).
01:16:09 <sshine> so now my strategy is: write it abstract, optimize later.
01:16:21 <merijn> A sound strategy
01:16:53 <sshine> I think not a lot of languages have the feature of "more high-level => faster".
01:19:50 <koz_> sshine: Haskell (and GHC) have some really clever capabilities in this regard.
01:21:06 <merijn> sshine: Note that inlining can lead generic/polymorphic functions to get monomorphised during optimisation
01:21:32 <koz_> Inlining can also cause fusion rules to fire that otherwise wouldn't.
01:21:36 <merijn> sshine: Similarly, typeclasses can very often be inlined and optimised away too
01:23:05 <merijn> sshine: *Ostensibly* polymorphic functions like + have to decide at runtime which implementation to run (like subclassing or dynamic dispatch in imperative languages), in practice if GHC knows both sides are, e.g. always Int it can just look it up during compile time and use the right version straight away, resulting in 0 overhead from the abstraction/indirection
01:23:35 <sshine> merijn, right!
01:26:12 <merijn> sshine: Incidentally, you can even tell GHC to do generate optimised code for specific types of polymorphic functions to help that along
01:26:50 <merijn> sshine: So you have "sum :: Integral a => [a] -> a" you can tell it to optimise a case for Int and use that when it infers appropriate via the SPECIALIZE pragma
01:27:27 <koz_> Isn't there also a pragma to say 'if these are the types, call this function instead'?
01:28:03 <merijn> koz_: There's rewrite rules, but those are far more powerful (and dangerous!)
01:28:15 <merijn> koz_: SPECIALIZE is, comparatively, very safe and easy
01:30:39 <koz_> I meant this thing: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#specialisation
01:30:47 <koz_> But yeah, it used to be its own thing, but now it's a rule.
01:31:26 <koz_> (or rather, is written using RULE)
01:31:36 <koz_> s/RULE/RULES/ arg
01:35:40 <merijn> Wait, what
01:35:46 <merijn> SPECIALIZE was remove?
01:35:53 <merijn> When the hell did that happen?
01:37:18 <merijn> Ah, no, SPECIALIZE still exists
01:37:35 <merijn> The feature allowing it to do (unsafe!) rewrites like rewrite rules can was just removed
01:37:44 <merijn> koz_: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#specialize-pragma
01:38:53 <sshine> OK, Data.Text.scanl frustrates me. it seems that I can exactly produce a Text of the same length, but with each Char being the result of an accumulation. what Data.List.scanl gives me is lazy access to intermediate results. so it seems that since Text isn't Foldable, I lose access to a lazy stream. it seems that Data.Text.Internal.Fusion has stream :: Text -> Stream Char, but I feel like I'm doing somethin
01:38:54 <merijn> koz_: Your link is about replacing a function with a different implementation entirely. What I was referring to is about telling GHC to use the same *code* but optimise and generate code for a specific type instantiation of that code
01:38:59 <sshine> g wrong when I open something called Internal.
01:39:12 <merijn> sshine: What are you trying to do?
01:39:42 <sshine> merijn, find out if a Text is a pangram (contains a..z) without necessarily consuming the entire input. maybe what I'm really looking for is a lazy Text?
01:39:52 <merijn> sshine: Also, Text isn't foldable, but it has various folds implemented
01:40:18 <merijn> sshine: How big is your expected input?
01:40:28 <merijn> sshine: https://hackage.haskell.org/package/text-1.2.3.1/docs/Data-Text.html#g:11
01:40:34 <sshine> merijn, it's a hypothetical problem.
01:41:45 <merijn> sshine: lazy Text is (conceptually) just a lazy list of chunks of strict Text. It could help with "stopping early" when processing input, but honestly if you have a "real" problem where you want to stream input and abandon early you probably want one of the stream processing libraries like conduit/pipes anyway
01:42:39 <sshine> merijn, OK, so that's what I read on https://haskell-lang.org/tutorial/string-types and I'll stick to that now and go for the eager solution.
01:44:06 <merijn> sshine: The problem is usually that lazy Text input solutions rely on unsafeInterleaveIO which closes the file after all input has been processed, which leads to unreliability in when the file is closed
01:44:11 <sshine> also, that's a really nice article. I didn't know haskell-lang.org existed.
01:44:22 <merijn> sshine: conduit/pipes/etc. give more control over when files are closed
01:44:23 <sshine> merijn, OK.
01:44:29 <sshine> merijn, good to know.
01:44:54 <Ariakenom> is there a comprehensive list of streaming libraries somewhere? :p
01:45:17 <merijn> Ariakenom: Naah, because it's ever increasing :p
01:45:35 <Ariakenom> is there a comprehensive stream of streaming libraries somewhere? :p
01:45:45 <merijn> conduit, pipes, machines, iteratees, streaming, I think there's some more
01:46:33 <merijn> I think conduit has the widest ecosystem around it. Pipes seems conceptually elegant, but every time I *try* to use it, it ends up just being a pain in the ass
01:46:50 <merijn> I've heard good things about machines, but haven't used it yet
01:47:23 <Ariakenom> it's kmett. that's an adjective right?
01:47:43 <merijn> I think iteratees is basically dead, on account of having a complicated API and not great performance. It's an honourable mention on account of inventing the way to do streaming, though
01:47:59 <merijn> Ariakenom: It's edwardk's, yes. I have no clue about the adjective part :p
01:48:22 <merijn> When edwardk starts babbling category speak I just smile and nod :p
01:49:29 <merijn> sshine: Might wanna play with one of the streaming libraries anyway for your hypothetical problem. I think they're game changers. I've not seen anything solve a problem this tricky/complex as nicely in other languages
01:49:46 <koz_> There's also streaming and streamly I think, which are apparently good perf-wise.
01:51:00 <merijn> koz_: Yeah, but they don't have as much of an ecosystem around it :)
01:52:07 <sshine> merijn, I have yet to try them. would you suggest I look at conduits or pipes first?
01:53:02 <merijn> sshine: Probably conduits first these days, because of larger ecosystem
01:53:59 <merijn> sshine: Especially in combination with parser like attoparsec/binary. Which let you easily write code that parses any number of records/data type from a stream and then processes those
01:55:48 <bollu> if I have a function (c a => b) , how do I reify it to (Dict (c a) -> b)?
02:00:48 <fr33domlover> :t fold
02:00:50 <lambdabot> (Monoid m, Foldable t) => t m -> m
02:01:04 <Ariakenom> :t foldr
02:01:05 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
02:01:15 <Ariakenom> :t foldMap
02:01:16 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
02:01:17 <fr33domlover> bollu, something like these ^
02:01:58 <bollu> I am not sure that helps, I don't think anything in Dict has a monoid / foldable instance?
02:02:46 <fr33domlover> bollu, where does Dict come from, and in which way would you like to combine the values in it to produce a single value of type 'b'?
02:04:20 <asheshambasta> So, I seem to have run into this lonely corner: https://groups.google.com/forum/#!topic/haskell-wai/G8fNDVfEY0w; has anyone dealt with this? What I'd like to do is retrieve the streaming contents of something from an AWS S3 bucket (which is nothing but (ConduitM () ByteString (ResourceT IO) ())) and use that to form a "StreamingBody" scotty response. 
02:04:39 <asheshambasta> I don't really know how to "plumb" it all together, like the original question also mentions. 
02:08:11 <marble_visions> does lambdabot parse all text from the channel?
02:08:22 <asheshambasta> (plus I'm dealing with potentially large files here so keeping these files in memory to stream them is not an option)
02:09:11 <Taneb> marble_visions: I imagine lines that don't begin with one of a handful of characters (@, >, and maybe ?) are filtered out early in the process
02:09:19 <fr33domlover> asheshambasta, I never used Scotty or streaming responses, but I've used Yesod, I'd check how Yesod passes streaming bodies to WAI etc.
02:09:27 <fr33domlover> Maybe that code can help
02:12:15 <marble_visions> Taneb: thanks
02:13:41 <asheshambasta> fr33domlover: okay, I'll check that. Seems like I've found myself at the deep end here.
02:14:09 <bollu> fr33domlover https://hackage.haskell.org/package/constraints-0.10.1/docs/Data-Constraint.html#t::-61--62-
02:14:15 <bollu> fr33domlover it allows one to reify constraints into values
02:14:19 <devoid_> hellp fr33domlover, r u 31337?
02:14:34 <devoid_> very nice name btw, i like freedom too
02:19:55 <fr33domlover> devoid_, glad you like the nickname ^_^
02:20:24 <fr33domlover> bollu, oh I see, hmm I never used this stuff tbh, maybe withDict is relevant? Otherwise idk tbh
02:35:47 <[Leary]> % let flipWithDict :: (a => b) -> Dict a -> b; flipWithDict b d = case d of Dict -> b
02:35:47 <yahb> [Leary]: 
02:35:56 <[Leary]> % :t flipWithDict
02:35:56 <yahb> [Leary]: forall {a :: Constraint} {b}. (a => b) -> Dict a -> b
02:36:27 <[Leary]> bollu: ^ that looks about right.
02:36:48 <bollu> [Leary] thanks :) ]
02:37:02 <bollu> [Leary] now, next question! how do I implement reify2? https://gist.github.com/bollu/c1c0355d463bd15594ef405ce98350d1#file-rank2-constraints-hs-L5
02:41:43 <bollu> I'm trying to implement something that satisfies this type signature: reify2 :: (forall r1. c' r1 :- c r1) -> (forall r2. c r2 => a) -> (forall r3. c' r3 => a)
02:41:43 <bollu>  
03:08:22 <Lears> bollu: I'm not really sure, it looks like either it should just work with the same implementation as reify, or it maybe with QuantifiedConstraints. You could also looks at Data.Constraint.Forall.
03:09:44 <Lears> I can't play with it properly myself atm, as I don't have the constraints package built for GHC 8.6 (and trying to rectify that just about took down my weak laptop).
03:35:33 * hackage cachix-api 0.1.0.3 - Servant HTTP API specification for https://cachix.org  http://hackage.haskell.org/package/cachix-api-0.1.0.3 (domenkozar)
03:49:22 <mxf> Hi *, I'm currently trying to figure out how to run a FFI call only from the bound main thread, reading through the GHC user guide and Control.Concurrent/GHC.Conc leads me to believe this is not possible?
03:49:25 <lavalike> does a ghc install not come with a copy of the haskell report?
03:51:16 <mxf> As to why I want to do it: Window event polling on Windows must be done in the main thread (from what I have heard?) and other OSes event polling FFI isn't thread safe either (well, at least on Linux)
03:54:08 <Ariakenom> mxf: https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Concurrent.html#g:8
03:54:17 <Ariakenom> "Note in particular that the main program thread (the thread running Main.main) is always a bound thread"
03:54:56 <mxf> yeah, I read that. But does the Runtime make any promises about where FFI calls are actually made?
03:55:21 <Ariakenom> mxf: yes. it depends on the thread that made the call
03:55:46 <Ariakenom> a FFI call in the main haskell thread will run on the main os thread
03:56:19 <mxf> ah, and the FFI call *must* be marked afe, right? Otherwise it might run in an unbound thread, is that it?
03:56:34 <mxf> s/afe/safe/
03:58:19 <Ariakenom> mxf: no. is there a documentation section that makes you suspicious?
04:01:37 <mxf> Ariakenom, Since the documentation is a bit spread out, I'm not sure, let me try to find the bits, but I guess it was some kind of blog post. Thanks for clearing my confusion about bound threads up for me. :)
04:02:08 <Ariakenom> alright, good luck
04:03:01 <mxf> Ariakenom, I guess it wouldn't hurt if https://downloads.haskell.org/~ghc/8.4.4/docs/html/users_guide/ffi-chap.html#multi-threading-and-the-ffi had more information on how unsafe ffi is handled
04:03:02 <lavalike> is there a way to peruse all of the installed packages' docs on one system in the browser?
04:04:33 <merijn> mxf: What do you meany by "how unsafe FFI is handled"?
04:06:15 <mxf> merijn, I was under the impression that the runtime is free to call unsafe FFI in any "greenthread" in any os thread, bound or not.
04:08:11 <merijn> mxf: Yes, so what is the question?
04:09:45 <mxf> I guess some confusion I have is mostly due to how ghci (in the past?) handled FFI. I had crashes playing with sdl2 and ghci due to FFI being called in the wrong OS thread.
04:10:32 <kuribas> is it possible in reflex to dynamically add widgets?
04:10:46 <mxf> merijn, I guess my q is: What do I need to to to ensure certain FFI functions being only called in specific threads? And how does that differ from compiled code vs. ghci (with -fobject-code)
04:10:52 <Ariakenom> mxf: oh. ghci does not play nicely with main thread stuff I think
04:11:14 <merijn> mxf: You should use safe FFI imports
04:11:18 <kuribas> Or are all widgets statically fixed for each page?
04:11:36 <merijn> mxf: You should only use unsafe FFI when you know what you're doing and are very, VERY sure it's fine
04:12:31 <mxf> Ariakenom, yeah. It doesn't. In the past I need to make sure I was using -fobject-code. Storing the eventloop/window ref in foreign-store helped a bit, but after some time I was running into trouble anyway.
04:12:31 <merijn> mxf: Note: unsafe imports for FFI *don't* mean "import this unsafe (i.e. impure) FFI code", it means "import this in an unsafe way"
04:12:55 <merijn> There's a reason safe FFI is the default
04:14:03 <mxf> merijn, it's basically skipping the rts sync and blocking all thread due to not returning from rts, correct? That's at least how I understand it.
04:14:40 <merijn> mxf: unsafe FFI is just directly embedded an ASM CALL instruction for the corresponding C function
04:14:49 <merijn> mxf: So, yes.
04:14:54 <mxf> ah, I see.
04:15:04 <merijn> Although it only blocks all threads on the same capability
04:15:14 <merijn> So if you have the threaded runtime you can still have other threads running
04:15:30 <merijn> (Since then you can have multiple capabilities)
04:15:33 <mxf> yeah, but unsafe calls aren't my main problem here. It's really about making sure safe FFI is called in the correct bound thread.
04:15:49 <mxf> And it would be nice to also convince ghci to do the same.
04:16:12 <merijn> mxf: I think safe FFI from a bound thread should "Just Work (TM)"
04:16:36 <merijn> mxf: Convincing ghci to do the same is...trickier
04:17:26 <mxf> hm. Maybe I should have a look at ghc-hotswap right from the start then.
04:19:10 <mxf> Ariakenom, merijn: Thanks a lot to you two :)
04:27:28 <confusedwanderer> mxf: i'm not sure if this could help you, but ghci has a "-fno-ghci-sandbox" option which "which stops GHCi running computations in a separate thread. In particular, this is useful for GLUT on OS X, which only works if being run on the main thread."
04:28:13 <mxf> confusedwanderer, ah! Thanks for reminding me, I forgot about that flag!
04:29:06 <confusedwanderer> mxf: you're welcome, hope it's useful :)
04:29:34 <Ariakenom> confusedwanderer: Oh! I'll have to remember that one.
04:30:35 <confusedwanderer> Ariakenom: i remember it from a stackoverflow question, but had some trouble finding documentation for it to be honest. but it's pretty useful
04:30:49 <mxf> IIRC the downside was not being able to use the debugger? (I guess that's also not possible when using -fobject-code anyway)
04:31:16 <confusedwanderer> oh i don't know about that
04:32:11 <merijn> confusedwanderer: If that flag isn't in the GHC User's Guide, file a bug on Trac for missing flag documentation
04:34:50 <confusedwanderer> merijn: i tried using the search box on https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/index.html and didn't find anything
04:35:24 <confusedwanderer> am i missing something or is it really not documented?
04:36:04 <merijn> confusedwanderer: Wouldn't be the first missing flag, so :)
04:36:44 <confusedwanderer> merijn: ok, i'll file the bug :)
04:36:45 <Ariakenom> yeah I can't find it
04:39:40 <mxf> lavalike, regarding an index of the Documentation: There should be an index.html in your root folder.
04:40:18 <mxf> lavalike, if you are using stack you can open it like so: `stack haddock --open bytestring`
04:41:33 <mxf> well, a specific package. Cut the path down to '.../8.4.4/doc/index.html'
04:47:08 <confusedwanderer> merijn: create https://ghc.haskell.org/trac/ghc/ticket/15958, thanks for the sugestion
04:47:12 <confusedwanderer> created*
04:47:30 <confusedwanderer> suggestion*
04:47:32 <confusedwanderer> :|
04:58:03 <lavalike> mxf: thanks, that is the one I was able to find too, it seems to me that is just the packages coming with ghc, not the ones installed with cabal (unfortunately not using stack)
04:58:53 <merijn> lavalike: Edit "~/.cabal/config" search for the line "documentation" uncomment that and set to true
04:59:04 <merijn> lavalike: That'll tell cabal to generate documentation for each package you build
04:59:32 <lavalike> merijn: oh so they *should* be there, but they aren't because it wasn't set and/or the doc build not requested upon install?
04:59:43 <merijn> lavalike: Right
04:59:46 <lavalike> I see, appreciate it!
05:00:08 <merijn> lavalike: If you build with --enable-documentation (or whatever it is) and/or set it in the cabal config it will build docs for you
05:00:47 <merijn> lavalike: new-build support for this is a bit flaky, but normal operation will install them inside ~/.cabal/share/doc or inside your sandbox directory
05:01:08 <merijn> lavalike: (new-build will correctly build docs, but *finding* them is convenient yet)
05:02:12 <lavalike> merijn: I'm quite happy for the "global" ghc packages to come up in that page, that's exactly what I wanted, since I'm gonna be offline for a while and I already know what packages I needed (and installed them)
05:02:47 <lavalike> you mention cabal build / new-build for packages that you don't get straight from hackage w/ cabal install right?
05:03:12 <mxf> tbf, generating docs should be the default, glad to see new-cabal changed that.
05:03:21 <merijn> lavalike: cabal doesn't care if they're from hackage or just local when it comes to generating docs
05:03:59 <lavalike> merijn: I just mean I don't end up using cabal to build or new-build "dependencies" if that makes sense
05:04:25 <merijn> lavalike: If you change ~/.cabal/config that flag will apply to dependencies too
05:12:33 * hackage safecopy 0.9.4.2 - Binary serialization with version control.  http://hackage.haskell.org/package/safecopy-0.9.4.2 (JeremyShaw)
05:12:57 <lavalike> funny, I already have documentation: True
05:13:07 <lavalike> maybe I changed it after installing some of the packages in the past
05:14:11 <mxf> This might be slightly off-topic, but what's the deal with hackage.org not always generating the documentation? This has been the case for several years now.
05:14:49 <phadej> mxf: there are build reports, they tell why
05:15:01 <phadej> mxf: do you have an example package without docs?
05:15:08 <mxf> phadej, oh, where can I find them?
05:15:37 <merijn> mxf: The builder can take a while to catch up and sometimes the build might fail due to missing dependencies on the buildserver/wrong GHC version
05:15:51 <phadej> mxf: look for "Status"
05:16:24 <phadej> in my packages there is "Docs avaiable [build log]" and "Last success reported on 2018-... [all 1 reports]"
05:17:39 <merijn> mxf: For your own packages I always recommend people build docs locally and upload those, that way you don't have to rely on the docbuilder
05:17:53 <mxf> phadej, ah, good to know. Unfortunately(?) I don't have any tabs open with broken docs and can't remember of top of my head.
05:18:23 <alanz> My experience is that in the past 6 months at least the doc building has been pretty reliable
05:18:34 <alanz> possibly longer
05:19:20 <mxf> ah, here we go: http://hackage.haskell.org/package/api-tools-0.8.0.2
05:19:52 <phadej> there are plenty of issues in doc builder though, yes (it works in ~most cases): https://github.com/haskell/hackage-server/labels/component%3A%20doc%20builder
05:20:16 <phadej> so if someone feel strongly about docs, I'm sure gbaz will find time to onboard
05:20:21 <mxf> merijn, since this is a recurring problem, why not make this the default? (having to upload documentation with your package?)
05:20:36 <phadej> All reported builds failed as of 2018-11-22
05:21:09 <phadej> and if you click the reports, it says PlanningFailed
05:21:53 <phadej> that's because builder uses ghc-8.6.1 but api-tools doesn't yet support ghc-8.6
05:22:06 <phadej> as you can see from Matrix CI (link next to the build log links): https://matrix.hackage.haskell.org/#/package/api-tools
05:22:07 <mxf> phadej, ah, thanks for the hint, I hope I'll find some time and motivation to look into this.
05:22:25 <phadej> and there's indeed an issue in hackage-server for that: https://github.com/haskell/hackage-server/issues/790
05:22:35 <mxf> phadej, is there an architecture overview somewhere?
05:22:44 <merijn> mxf: Honestly, when new-haddock is slightly more published I hope including docs when generating a tarball/uploading will become the default, yes
05:23:14 <mxf> "more published"?
05:23:19 <phadej> polished*
05:23:36 <mxf> ah, right, that makes sense.
05:24:30 <phadej> mxf: there're explanations how docbuilder works spread across the issues. TL;DR every 10 minutes it checks hackage whether there are packages without docs, and tries to build them, up to 3 times
05:25:34 <phadej> and i remember seeing gbaz writing down how that should/could be changed
05:26:01 <mxf> So, I guess as soon as new-haddock landed, one possible solution to all those tickets is to rip out the docbuilder to close those tickets for good? ;)
05:26:14 <phadej> personally, no
05:26:35 <mxf> heh, i was half-joking.
05:27:05 <phadej> it just won't work, e.g. you have to convince stack users to upload docs
05:27:07 <mxf> (Half because the only good commit is a commit removing code)
05:27:10 <phadej> (i.e. change that tool too)
05:27:23 <phadej> + whatever other tools & scripts people use
05:27:30 <mxf> yeah, true.
05:31:10 <lavalike> if I understand correctly the package uploader can also upload the docs?
05:31:46 <mxf> Seems like that's the corresponding stack ticket: https://github.com/commercialhaskell/stack/issues/737
05:32:15 <mxf> Not fixed since 2016, if I understand it correctly.
05:32:44 <merijn> lavalike: Yes
05:33:20 <mxf> hm, at least there seems to exist a tool for uploading docs with stack: http://hackage.haskell.org/package/hup
05:33:22 <merijn> lavalike: If you use new-build "cabal new-haddock all --haddock-for-hackage" will generate a tarbal of documentation, you can then use "cabal upload" to upload those to hackage
05:34:21 <lavalike> maybe surfacing that better to the pages that an upload would look at would help removing the pressure from the docs generation backend
05:34:48 <mxf> lavalike, +1
05:37:02 <merijn> lavalike: The problem is that that currently is a bit brittle still. And once it's more polished/robust it should just be integrated into cabal upload
05:42:04 <lavalike> that makes sense
05:42:34 <mxf> merijn, that would be really nice.
05:44:00 <merijn> mxf: So, besides diving into the docbuilder it might also be worth trying to help new-haddock get to that point if you're motivated :)
05:44:41 <merijn> mxf: I know Alex Biehl is working on/polishing new-haddock, he's not on IRC very often, but he responds fairly quickly to questions on his github tickets
05:48:45 <mxf> heh, I try not to dig too many rabbit holes for me, but TBH this seems like a worthwhile time investment. I really wish documentation as a whole would be better in the ecosystem, having *existing* documentation is one of the first steps, I guess.
05:49:10 <mxf> s/having/being able to read/
06:42:07 * hackage impl 0.2.0.0 - Framework for defaulting superclasses  http://hackage.haskell.org/package/impl-0.2.0.0 (dailectic)
06:51:26 <merijn> Math and/or English nerds: Should it be "Cartesian product" or "cartesian product"?
06:51:47 <lavalike> the latter
06:52:01 <lavalike> except at the beginning of a phrase >:)
06:53:17 <berndl> I prefer the former.
06:56:34 <Taneb> Strictly, Cartesian, but English is flexible enough that it can change and mathematics doesn't care
07:00:08 <merijn> wikipedia seems to agree with capitalisation
07:00:56 <merijn> Taneb: If I'm gonna bother updating my spelling dictionary to get rid of the error, I might as well update it *right*
07:01:07 <aldum> isn't it an adjective this way?
07:01:25 <aldum> you don't capitalise those muc
07:01:25 <aldum> h
07:01:48 <merijn> aldum: I think "Cartesian product" is considered a single noun, not a noun + adjective
07:01:51 <Taneb> aldum: you do when it's relating to a proper noun
07:02:17 <aldum> interesting
07:02:21 <pjrt> So like "I would like some Canadian bacon"?
07:02:22 <berndl> My rule is: if it involves a proper name, capitalize it.
07:02:27 <Taneb> pjrt: I think so
07:02:49 <Taneb> There's a handful of exceptions due to common usage, like "abelian"
07:03:08 <berndl> Exceptions suck.
07:03:10 <pjrt> My rule is: English is like Chinese; just memorize the symbols and say them
07:03:34 <aldum> you know chinese?
07:03:34 <quicksilver> English is really not consistent. I buy Italian coffee but I speak italian.
07:03:55 <pjrt> Nope
07:04:12 <merijn> quicksilver: Ugh, really?
07:04:16 <Taneb> quicksilver: I think that's incorrect
07:04:22 <merijn> quicksilver: That looks wrong
07:04:23 <quicksilver> ah no apparently the standard is Italian for the language too.
07:04:26 * quicksilver shrugs
07:04:29 <quicksilver> it all makes no sense to me :)
07:04:42 <berndl> natural languages...
07:04:42 <pjrt> But, as I understand it, Chinese is a symbol language. Funnily enough, differnt people with different languages can write and read chinese
07:04:45 <Taneb> I'm a native speaker and I get it wrong way too much
07:04:53 <pjrt> Even if they dont understand each other's speech
07:05:00 <Taneb> I always want to capitalize "north"
07:05:50 <Taneb> Anyway, this is wildly off-topic
07:05:57 <Taneb> How's your Haskell going?
07:06:07 <pjrt> Still looks like Scala :(
07:08:55 <aldum> what's wrong with Scala? :)
07:09:44 <pjrt> At this point, I don't even know anymore
07:19:44 <hodapp> it smells bad and it's ugly
07:19:46 <hodapp> just saying
07:20:33 * ski . o O ( bad code smell ? )
07:20:42 <dminuoso> What is good code smell?
07:21:31 <ventonegro> jasmin
07:24:10 <maerwald> Durian
07:25:45 <c_wraith> I'm not sure why -Wall wants types on pattern synonyms.
07:26:13 <c_wraith> I'm also not sure why the type of a pattern synonym is its type when used as a constructor.
07:40:28 <c_wraith> I just found myself thinking "mfix will make this cleaner".  I'm headed down a dark path...
07:41:23 <c_wraith> (I was also right)
07:47:04 * hackage pairing 0.1.1 - Optimal ate pairing over Barreto-Naehrig curves  http://hackage.haskell.org/package/pairing-0.1.1 (sdiehl)
07:50:52 --- mode: glguy set +v noipmusp
07:50:53 <noipmusp> How to use custom QuickCheck generators (Gen a) with Hspec "prop" function?
07:51:29 <lyxia> noipmusp: forAll
07:51:42 <ski> @quote a.problem.in
07:51:42 <lambdabot> shachaf says: Some people, when asking about a problem in #haskell, get a link to okmij.org. Now they have two problems.
07:51:47 <ski> @quote have.a.lifetime
07:51:47 <lambdabot> ddarius says: When a programmer has a problem and says "I'll use regular expressions," they have two problems.  When the programmer says "I'll use Haskell," they have a lifetime of problems.
07:52:07 <lyxia> noipmusp: prop (forAll myGen $ \x -> my_prop x)
07:52:35 <lyxia>                       ^ insert String here
07:52:57 <lyxia> hmmm, wrong place :(
07:53:12 <ski> (string ?)
07:53:50 <ski> @hoogle Test.Hspec.prop
07:53:50 <lambdabot> Test.Hspec.QuickCheck prop :: (HasCallStack, Testable prop) => String -> prop -> Spec
07:53:51 <lambdabot> Test.Hspec.Wai.QuickCheck property :: Testable a => a -> Application -> Property
07:53:51 <lambdabot> Test.Hspec.SmallCheck property :: Testable IO a => a -> Property IO
07:53:58 --- mode: glguy set +v Boarders
07:54:05 <ski>   prop {- insert `String' here -} (forAll myGen $ \x -> my_prop x)
07:54:11 <lyxia> ski++
07:54:17 --- mode: glguy set -v Boarders
07:55:07 <Boarders> I am trying to write something to render to text files and I wonder what people recommend? Someone on here suggested using text-builder but there is also text-show
07:55:23 <merijn> Boarders: Define "render to text"
07:55:38 <merijn> Boarders: What data are you trying to output in what format? Also, how much data?
07:56:37 <Boarders> it is a haskell type that has a bunch of information and it can be quite large (not sure on the numbers but currently it eats up memory), the format is not very important
07:56:57 <Boarders> at the moment it using using just show and writeFile as a stand in for something proper
07:57:10 <merijn> Boarders: "large" are we talking, kilobytes, megabytes, gigabytes...
07:57:51 <Boarders> merijn: I think it could be like 500mb or something like that
07:58:02 <Boarders> perhaps more on some data sets
08:00:02 <noipmusp> lyxia: Thank you.
08:15:21 <dmwit> Boarders: Depending on the consumer, you might like cassava (CSV) or aeson (JSON). 500MB is not going to be human-readable, so don't bother restricting yourself to Text-based formats.
08:25:09 <dmwit> Boarders: Or, like... SQL also seems like an option, honestly.
08:25:23 <Boarders> dmwit: thanks I'll give it a think
08:26:01 <Boarders> 500mb was sort of the largest example but I expect there will be lots of more reasonable sized examples too
08:47:45 <c_wraith> hmm. Why does Earley's Prod type have Semigroup and Monoid instances that just duplicate the Alternative instance? do most parser libraries do that?
08:49:34 <c_wraith> hmm, no. megaparsec lifts operators over its Applicative interface. that's the behavior I'd expect.
08:50:21 <ski> @type liftA2 (<>)  -- ?
08:50:23 <lambdabot> (Monoid c, Applicative f) => f c -> f c -> f c
08:50:39 <ski> @type (<|>)
08:50:40 <lambdabot> Alternative f => f a -> f a -> f a
08:52:53 <c_wraith> I don't see what having <> be a synonym for <|> buys you. especially in comparison to having it do something useful (and nice to provide as a single operator) 
08:54:57 <c_wraith> too bad changing the behavior of an instance is such a brutal thing in a published library. not everyone checks why there was a major version bump, and might use code that still compiles but no longer works.
08:55:10 <ski> i suppose generally one could expect `Monoid (F T)' to both depend on `F' and `T'
08:55:41 <ski> (as opposed to `Alternative F', where whatever `T' is in `F T's you combine, doesn't matter)
08:56:09 <c_wraith> yeah, that's why I was surprised by that choice.
08:57:00 <ski> (should there be a `Monoid [a]' instance, when we "already have" `Alternative []' ?)
08:58:23 <ski> .. i suppose chaning `String' into some other text type, with a `Monoid' instance, would be more bothersome, if one couldn't use `(<>)' for the former
08:58:37 <c_wraith> that one bugs me less, for some reason. maybe just being used to it. it would be kind if nice to have Cartesian products on <>
08:58:39 <tabaqui> Hey, all
08:58:49 <tabaqui> I'm trying to implement interactive console UI
08:59:12 <tabaqui> But cannot read from stdin char by char
08:59:36 <tabaqui> I use getContents function but it doesn't return if there is no EOL
08:59:57 <tabaqui> How can I read arrow keys for example in real time?
09:00:26 <c_wraith> you're better off using a real TUI library that handles all of the platform specific stuff there.
09:00:42 <geekosaur> hSetBuffering, or more generally you want to use a terminfo or higher level interface because, for examle, arrow keys aren't single "events"
09:00:57 <ski> `hSetBuffering stdin NoBuffering' ?
09:01:18 <c_wraith> rather than trying to build it yourself from console IO streams. 
09:01:19 <geekosaur> (also the hSetBuffering thing is a ghc-specific hack, its got nothing to do with buffering, it's termios)
09:01:37 <tabaqui> Is this solution cross-platform?
09:01:41 <tabaqui> *solutions
09:07:52 <tabaqui> terminfo, ncurses, vty don't work on Windows
09:08:33 <geekosaur> this should be telling you something
09:08:51 <tabaqui> anyway, I'll rewrite IO code for Win32 and GTK, so I can train with console ui now
09:09:16 <geekosaur> "console" is a very different beast on windows vs. unix, and it's very hard to get anything to behave nicely cross-platform
09:10:54 <tabaqui> I have no choice :)
09:12:36 * hackage hpack-dhall 0.5.1 - hpack's dhalling  http://hackage.haskell.org/package/hpack-dhall-0.5.1 (philderbeast)
09:14:33 * hackage composition-prelude 2.0.2.1 - Higher-order function combinators  http://hackage.haskell.org/package/composition-prelude-2.0.2.1 (vmchale)
09:14:36 <tabaqui> ski, geekosaur: set buffering does help, thanks
09:18:33 * hackage follow-file 0.0.3 - Be notified when a file gets appended, solely with what was added. Warning - only works on linux and for files that are strictly appended, like log files.  http://hackage.haskell.org/package/follow-file-0.0.3 (athanclark)
09:18:54 <sm> tabaqui, fltkhs might be a cross platform alternative to win32/GTK
09:19:17 <sm> http://hackage.haskell.org/package/fltkhs
09:20:38 <tabaqui> sm, does it link with opengl on windows?
09:22:55 <sm> tabaqui: the install guide shows an optional flag for opengl support, I don't know if it works on windows
09:26:29 <tabaqui> I'll check then, thanks
09:30:03 <sm> tabaqui: and here is the last known status of windows support for vty and brick: https://github.com/jtdaugherty/vty/pull/1#issuecomment-297143444
09:32:16 <hexagoxel> what was the name of the library with the unboxed(sum) maybe?
09:34:05 <lavalike> @package unpacked-maybe
09:34:05 <lambdabot> http://hackage.haskell.org/package/unpacked-maybe
09:35:02 <hexagoxel> thanks
09:35:39 * hackage pandoc 2.5 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-2.5 (JohnMacFarlane)
09:50:09 <Ariakenom> What are some thing Haskell does really well? concurrency, streaming, refactoring, parsing?
09:50:39 <glguy> Yeah, those are some good examples
09:51:06 --- mode: glguy set +v eskimor
09:53:28 <eskimor> correctness
09:55:27 <c_wraith> some people think I'm clueless, but: documentation. Haskell does it way better than anything else I frequently use. single line type signatures have more info in them that pages of rails "guides".
09:55:39 <c_wraith> *than
09:56:34 <sm> that's a pretty narrow definition of documentation though
09:57:24 <hexagoxel> there is unboxed-maybe, unboxed-either and unboxed-these, but no unboxed-bool?
09:57:40 <c_wraith> I think it's the broadest definition - it answers the questions "what can this do and how do I make it do those things". I don't care how it's conveyed, just that it's correct and complete.
10:01:17 <lavalike> hexagoxel: -XMagicHash
10:03:07 <sm> *good* haddocks *can* answer those questions
10:03:19 <Ariakenom> @quote newtype.planT
10:03:19 <lambdabot> edwardk says: newtype PlanT k i o m a = PlanT  { runPlanT :: forall r. (a -> m r) ->  (o -> m r -> m r) -> (forall z. (z -> m r) -> k i z -> m r -> m r) -> m r -> m r } -- is a monad i actually use ;
10:03:19 <lambdabot> )
10:04:12 <[exa]> what does it even do?
10:06:30 <Ariakenom> "You can construct a Plan (or PlanT), turning it into a Machine (or MachineT)."
10:06:44 <hexagoxel> lavalike: i don't follow
10:06:51 <hexagoxel> is there Bool# ?
10:07:19 <c_wraith> looks like a sort of codensified version of the basic Machine stuff
10:08:04 <lavalike> hexagoxel: unboxed types achieved by that extension correspond to the "raw machine" ones you'd use in C, bool is fairly straightforward, would be most surprised if there isn't
10:08:30 <Ariakenom> good input, thanks.
10:09:53 <orion> What are some of the use cases in which conduit is uniquely suited, as compared to machines?
10:11:24 <lavalike> hexagoxel: funnily enough the docs for unboxed tuples do show a definition of a "bool-like" type 
10:12:25 <c_wraith> a lot of low-level primitives use Int# for Bool values.
10:12:46 <c_wraith> something about enabling branch-free algorithms in some cases.
10:13:02 <hexagoxel> which docs? and yes, i sure can use Int or Int#, but i was looking for a proper newtype and the two trivial pattern synonyms.
10:13:21 <lavalike> the section on unboxed sums in ghc
10:15:22 <hexagoxel> ah, the last paragraph, gotcha
10:16:49 <hexagoxel> i wonder what the performance differences are of encoding Bool as  (# (# #) | (# #) #)  vs  Int#
10:17:07 <lavalike> time to benchmark!
10:22:03 * hackage generic-lens 1.1.0.0 - Generically derive traversals, lenses and prisms.  http://hackage.haskell.org/package/generic-lens-1.1.0.0 (kcsongor)
10:40:03 * hackage antlr-haskell 0.1.0.0 - A Haskell implementation of the ANTLR top-down parser generator  http://hackage.haskell.org/package/antlr-haskell-0.1.0.0 (KarlCronburg)
10:41:33 * hackage brick 0.41.5 - A declarative terminal user interface library  http://hackage.haskell.org/package/brick-0.41.5 (JonathanDaugherty)
10:46:03 --- mode: glguy set +v boi
10:55:24 <zzz> is there a time-complexity reference for Prelude?
11:14:53 <Ariakenom> zzz: many definitions are simple and can be found via hoogle. Here's dropWhile you were talking about https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.List.html#dropWhile
11:38:53 <megatr0nz> hello, anyone that used Massiv.Array.Mutable before?
11:44:13 <bsima> is the literate haskell syntax defined somewhere? 
11:45:17 <lavalike> bsima: yes it's in the report
11:45:48 <lavalike> bsima: https://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17900010.4
11:46:31 <boi> Hello
11:47:19 <bsima> lavalike: ooh thanks, i've never actually read *the report* - I guess now is as good a time as any!
11:47:48 <lavalike> bsima: ^___^
11:47:52 <boi> Question: how is is possible to compose 2 fmaps? Shouldn't (.) take only functions with one parameter?
11:48:28 <__monty__> boi: Every function in haskell is a function that takes only one argument.
11:48:28 <lavalike> boi: trying to make sense of fmap . fmap?
11:50:35 <pikajude> is there a package that exposes an intermediate datatype like what aeson would use to generate instances?
11:50:47 <pikajude> i want to hijack aeson's codegen to generate flow type signatures for some ADTs i have
11:51:19 <boi> lavalike: yes. __monty__ : i know, but fmap doesn't "fit" into (.) type
11:51:39 <lavalike> well ghc seems to think otherwise (:
11:51:43 <geekosaur> it does, you just have to thinkmore flexibly
11:52:02 <lavalike> :t (.)
11:52:03 <lambdabot> (b -> c) -> (a -> b) -> a -> c
11:52:06 <boi> i'm dumb, i got it
11:52:07 <Ariakenom> boi: a -> b -> c = a -> (b -> c) = a -> d  where d = b -> c
11:52:09 <lavalike> :t fmap
11:52:10 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:53:12 <lavalike> if you read fmap's as (a->b) -> (f a->f b) it's of the shape thing -> thing that . expects
11:55:27 <boi> thanks, got that
12:07:13 --- mode: glguy set +v safina
12:07:34 <safina> is there forM and forM_, but for maps?
12:07:39 <safina> i. e. Data.Map.Map
12:09:53 <lavalike> safina: that's forM and forM_
12:10:02 <lavalike> :t forM
12:10:03 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
12:10:15 <lavalike> Data.Map.Map provides a Traversable instance
12:13:22 <safina> lavalike: thanks!
12:13:32 <safina> bye
12:28:19 <eacameron> How is atomicWriteIORef atomic? It's atomic with reference to what?
12:30:00 <boj> other threads accessing it?
12:31:03 * hackage xeno 0.3.5 - A fast event-based XML parser in pure Haskell  http://hackage.haskell.org/package/xeno-0.3.5 (ocramz)
12:31:48 <dmwit> eacameron: The docs talk about this some, don't they?
12:32:18 <dmwit> In short, it's just writeIORef with a memory barrier added.
12:32:39 <eacameron> How is writeIORef *not* atomic? I'd imagine it's just a pointer swap.
12:32:59 <dmwit> Yes, it is. But those swaps can appear out of order on other CPUs.
12:33:17 <dmwit> because caching
12:33:19 <dmwit> or something
12:33:45 <eacameron> ah I see. So atomicWriteIORef is probably the only writeIORef you ever want to use unless you are patently single threaded.
12:34:00 <eacameron> Or maybe even then...
12:35:12 <geekosaur> You're safe when single-threaded. multithreaded you probably want something higher level than IORef
12:35:45 <eacameron> geekosaur: Even if you have a pure transformation over some IORef and could use `atomicModify`?
12:36:27 <eacameron> or is that also only atomic in single-threaded?
12:36:57 <eacameron> according to docs atomicModify is safe for multithreaded.
12:37:11 <eacameron> I presume that includes multi-OS threaded not just green threads.
12:38:00 <dmwit> Probably just about anything you do is fine if you are not using -threaded, i.e. just green threads and not OS threads.
12:38:17 <dmwit> I mean data races will still be data races, but the memory model for a single CPU is much simpler than the memory model for multiple CPUs.
12:38:49 <eacameron> dmwit: I think if you get pre-empted between a read and write you could end up with races
12:39:01 <eacameron> even on a single core
12:39:05 <dmwit> Yes. Data races are data races.
12:39:37 <eacameron> I see.
12:39:43 <dmwit> But at the very least everything will probably appear to happen in a sensible order.
12:40:25 <monochrom> Use atomicModifyIORef for thread safety.  atomicWriteIORef is a "write barrier" thing for use cases that quite frankly I say the use cases are buggy and full of wrong assumptions to begin with.
12:40:46 <eacameron> ok...that I can believe.
12:40:53 <geekosaur> that, basically
12:41:36 <eacameron> I am having a really hard time imagining when atomicWriteIORef would be safe enough to justify using it over just writeIORef. If you want shove a value in there I don't know how a memory barrier really helps...
12:42:29 <eacameron> either never use it or always use it...but I can't think of a meaningful use case that distinguishes them
12:42:43 <monochrom> I think the doc gives an example.
12:42:44 <dmwit> I mean, if your other thread gets confused when it sees non-increasing timestamps in that IORef...
12:43:06 <dmwit> (Or any data that can appear to "go backwards", not just timestamps.)
12:43:11 <monochrom> But yes I look at that examples and others and my opinion is why would you write code like this in the first place.
12:43:20 <dmwit> (Say, current revision in a revision control system or something.)
12:43:53 <eacameron> dmwit: monochrom The example is for atomicModify which makes perfect sense.
12:44:26 <monochrom> Yes, atomicModify is fine, I use it all the time.
12:44:40 <eacameron> It's atomicWrite I don't understand. If you have multiple threads writing to an IORef then memory model is the least of your worries, from what I can tell.
12:44:55 <dmwit> eacameron: The use is when you have one thread writing, and one reading.
12:45:03 <monochrom> Yeah write barrier is morally wrong.
12:45:12 <eacameron> dmwit: Hm...
12:45:33 * hackage monadoid 0.0.3 - A monoid for monads  http://hackage.haskell.org/package/monadoid-0.0.3 (athanclark)
12:45:47 <dmwit> With writeIORef: thread 1 writes A, then writes B; thread 2 can read B then read A. With atomicWriteIORef, once thread 2 reads B, it will never read A again.
12:46:42 <eacameron> dmwit: ohhh that is crazy. But ok that makes sense. And...makes me wonder again why you would ever use `writeIORef` ever.
12:47:50 <eacameron> It's still a highly questionable design...but still I can see that
12:47:54 <dmwit> It is fine if all accesses to the IORef happen from a single thread.
12:48:06 <dmwit> And if they don't, you probably wanted MVar or TVar instead anyway, not IORef.
12:48:19 <geekosaur> people who want max speed and are willing to take risks
12:48:43 <monochrom> Naw. Unwilling to take risks.
12:48:48 <eacameron> Ok fair fair. Thanks for helping me understand. I'll stay far away from `writeIORef` in my code then. :P
12:49:00 <monochrom> So unwilling, they blame it on someone else.
12:49:58 <geekosaur> I'm fine with writeIORef in green threads, generally go straight to TVar etc. for threaded. if I want to muck with stuff at that low a level, I'll write it in C >.>
12:50:05 <monochrom> Write barrier is the same as an investor wanting high return no risk bitcoin trading.
12:50:25 <eacameron> Well yeah if I'm truly single threaded then I'll just use ST...
12:50:39 <geekosaur> enh. it's fine and in fact necessary as the lowest level of this
12:51:00 <geekosaur> but if I'm writing in Haskell, I've already given up on :"lowest level"
12:56:14 <dmwit> IORef and STRef are the same under the hood. And IORef is better in some cases (e.g. if you want to hold onto a reference across a network access).
12:56:28 <geekosaur> and the thing to remember about atomic*IORef is that's what we had to use before STM and such. basically, it's the lowest level of multithreaded primitives in this area. kinda like using forkIO instead of async, you probably don't want to go there unless you really need to do all the lowlevel stuff yourself for some reaso
12:58:07 <boeingx> Hi! Is it possible to have a detailed csv or plain text output with the criterion library? With the --csv option, I only get a summary of benchmark
12:59:02 <dmwit> What details are you wishing for but missing?
13:00:54 <boeingx> dmwit: such as the run time for individual test. In the csv file, we only have mean, standard variation etc
13:01:44 <dmwit> I don't know of a way. You may have to modify the library yourself.
13:06:26 <boeingx> dmwit: I see... it is kind of strange because in the HTML file we see clearly there is this information in the plot. However, the plot is generated with jquery so it is not very readable :(
13:11:59 --- mode: glguy set +v safinaskar
13:12:03 <safinaskar> hi
13:12:14 <safinaskar> i just asked about "forM_" for maps
13:12:51 <safinaskar> unfortunately Map is not foldable
13:12:58 <safinaskar> oops, sorry, it's foldable
13:12:58 <safinaskar> :)
13:13:01 <dmwit> You'll have to repeat your question.
13:28:15 <shapr> safinaskar: what was your question?
13:29:44 <dmwit> I guess it was probably some minor variation on "How can I emulate forM_ even though Map isn't Foldable?".
13:29:58 <dmwit> But then they discovered Map is Foldable. =)
13:30:12 <safinaskar> shapr: dmwit: i already found solution, thank you
13:43:21 <adius> Hi, I'm thinking of releasing a package for various digit alphabets in the hope that it will become a base for lots of other packages. Here is my first draft:
13:44:00 <adius> https://www.irccloud.com/pastebin/BJ7VXa8j/Digit%20Alphabets
13:44:05 <adius> What do you think?
13:44:58 <dmwit> Err... is that the whole package?
13:45:38 <adius> I'll add helper functions to simplify calculations and such things.
13:45:56 <adius> But for the beginning it's important to get the names right!
13:46:10 <dmwit> Well. There's nothing stopping you. But I think this would be a tough sell for most of the projects I work on.
13:46:42 <dmwit> You might look at https://hackage.haskell.org/package/arithmoi-0.8.0.0/docs/Math-NumberTheory-Moduli-Class.html#t:Mod
13:51:57 <adius> I had several cases where I needed to constraint the number of inputs, but didn't want to define a new data type, either because it was to much effort (like base64) or there were no clear names for the options (storage locations)
13:52:45 <adius> With this package I could simply create `newtype StorageLocation = StorageLocation DuoDit`
13:53:18 <dmwit> With arithmoi you could simply create `newtype StorageLocation = StorageLocation (Mod 12)`.
13:54:19 <dmwit> Plus you wouldn't need to remember whether you named it DuoDit or Dozenal or Binadecimal or what.
13:54:41 <koz_> dmwit: 'Dozenal' is an actual term for base 12?
13:55:03 <dmwit> If you haven't encountered the Dozenal Society of America yet, you are in for a treat.
13:55:11 <koz_> dmwit: I see.
13:55:15 <MarcelineVQ> the lalilulelo?
13:55:38 <adius> http://www.dozenal.org/ - You should join them
13:55:52 <adius> Damn, @dmwit was faster 😂
13:56:17 <dmwit> They object to "duodecimal" on the grounds that it assumes decimal is a good starting point. ^_^
13:56:39 <dmwit> They have designed two new digits for what most folks call 10 and 11 which look like an upside down 2 and an upside down 3.
13:57:23 <geekosaur> I did that when I was, like, 13
13:57:24 <adius> I wanted to use them for https://adriansieber.com/ukulele-fingering-chart-cli-tool-in-haskell/, but GHC does not allow them 😞
13:57:44 <MarcelineVQ> this is why I think the kzinti had it right
13:58:07 <dmwit> ↊ ↋
14:01:38 <dmwit> TIL the kzinti made an appearance in Star Trek.
14:01:54 <geekosaur> only the animateds, and onlybecause niven got lazy
14:01:59 <MarcelineVQ> in the animated series?
14:02:18 <dmwit> MarcelineVQ: yep
14:02:28 <MarcelineVQ> M'Ress is bae
14:02:29 <geekosaur> it was basically a Trek-flavored retelling of one fo his Kown Space shorts
14:03:28 <MarcelineVQ> Anyway I mention them because their numbers are base8
14:03:53 <dmwit> I have a cunning plan. For every number, first we will write down all the possible digits in order, then the number itself.
14:04:07 <dmwit> It will be clear where the number starts because it is the first duplicate digit.
14:05:05 --- mode: glguy set +v atondwal
14:05:06 <dmwit> Longer texts can use a more complicated protocol to establish the base at the beginning.
14:05:23 <dmwit> Hm, and I guess the natural progression is to allow cultures to use a still more complicated protocol to establish a shared base.
14:05:23 <atondwal> (err, there should be a do in front of that block)
14:05:31 <atondwal> anyone have any idea what's up with that?
14:05:32 <dmwit> Oh, dang, that's where we are at the moment.
14:05:56 <geekosaur> atondwal, whatever you;'re referring to got eaten. send it again?
14:05:59 <MarcelineVQ> atondwal: note your private messages
14:05:59 <dmwit> atondwal: Whatever you said before "(err, there should be a do in front of that block)" got eaten by our anti-spam system. You'll have to replace it.
14:06:06 <dmwit> s/replace/repeat/ yikes
14:06:52 --- mode: glguy set +v safinaskar
14:07:14 <safinaskar> is there function (\(x, _, _) -> x) on hackage?
14:07:36 --- mode: glguy set -v atondwal
14:07:42 <geekosaur> ...I would't import a package just for that
14:07:44 <MarcelineVQ> there is but it's a pretty easy one to make yourself :>
14:07:56 <atondwal> so I realize my problem with ghci ealier. Say I have `f i = { x <- Just i ; return x }`, then, if I set a breakpoint at `return x`, I find that `x` is in scope, but not `i`
14:07:59 <safinaskar> geekosaur: i would
14:08:05 <MarcelineVQ> https://hoogle.haskell.org/?hoogle=(a%2C%20b%2C%20c)%20->%20a
14:08:07 <safinaskar> geekosaur: i want my code to be ideomatic
14:08:13 <dmwit> Yes, you can use _1 if you're into lens or look at the tuple package.
14:08:18 <MarcelineVQ> oh hmm, that doens't link properly
14:08:19 <safinaskar> geekosaur: i want to use standard name for any operation
14:08:24 <geekosaur> idiom there is lambda, or lens
14:08:30 <geekosaur> depending on your religion >.>
14:08:39 <dmwit> http://hackage.haskell.org/package/tuple-0.3.0.2/docs/Data-Tuple-Select.html
14:09:33 <safinaskar> aaaaaaah!
14:09:34 <safinaskar> http://hackage.haskell.org/package/tuple-0.3.0.2/docs/src/Data.Tuple.Select.html
14:09:37 <mnoonan> \(x,_,_) -> x is pretty idiomatic, too
14:09:43 <safinaskar> http://hackage.haskell.org/package/tuple-0.3.0.2/docs/src/Data.Tuple.Select.html <- this source is awful
14:09:45 <dmwit> Some of the fundeps in that package are a bit laxer than they should be.
14:09:56 <dmwit> safinaskar: It is generated code.
14:10:04 <dmwit> It doesn't need to be not awful. =)
14:15:07 <koz_> What do I need to set for a Cabal new-build to compile my code with -fllvm?
14:18:58 <dmwit> I guess ghc-options: -fllvm for the appropriate packages should do.
14:19:07 <safinaskar> MarcelineVQ: hmmm, well, i tried to search at https://www.haskell.org/hoogle and found nothing useful
14:19:18 <dmwit> I think there's a * meta-package if you want it for the whole dependency tree.
14:19:27 <adius> I made the abbreviations type aliases, maybe I should remove them completely? https://www.irccloud.com/pastebin/ygQpRrZW/BaseXDigit
14:19:29 <dmwit> But I have not tested either piece of this advice.
14:19:30 <koz_> dmwit: I do want it for the whole tree.
14:19:34 <koz_> I'll give that a try.
14:19:35 <safinaskar> MarcelineVQ: but https://hoogle.haskell.org successfully finds "fst3"
14:19:58 <safinaskar> MarcelineVQ: so, there is two hoogles, and one finds fst3, and one doesn't find. right? why?
14:20:38 <geekosaur> because one is an older one with older daabase but working tpe search, theother is newer and can index everything but doesn't have type search
14:20:48 <koz_> dmwit: Your * suggestion appears to be working.
14:21:06 <dmwit> \o/
14:21:28 <geekosaur> (the older version has size limits and so can't e.g. index all of hackage)
14:25:27 <safinaskar> ghc uses llwn?!
14:25:39 <koz_> safinaskar: It's possible to use LLVM's code generator.
14:25:45 <koz_> The default is GHC's own.
14:25:51 <safinaskar> koz_: thanks
14:26:34 <davean> safinaskar: the LLVM backend is somewhat less robust too.
14:26:39 <davean> YMMV
14:27:06 <koz_> Yeah, there's some issues. It also only generates faster code in _some_ cases, usually involving heavy numerical stuff. Or massiv, it seems.
14:27:14 <koz_> So it's definitely not something to do by default.
14:27:31 <davean> Yah, its faster for most numerical heavy code, but it has bugs sometimes like when floats and doubles are mixed in a function call.
14:27:41 <davean> Mostly the native backend is faster and more robust.
14:28:05 <davean> validate the LLVM backend for your specific application
14:28:17 <safinaskar> geekosaur: but both hoogles seem to understand query "(a, b, c) -> a". so they have type search
14:28:40 <geekosaur> hoogle's big thing is fuzzy type search. an exact one will mostly work in both
14:28:59 <geekosaur> btu hoogle5's fuzzy type search isn't really there
14:29:20 <geekosaur> there's also hayoo, somewhere in between and indexes everything but sometimes gets confused by updates
14:29:24 <geekosaur> @where hayoo
14:29:24 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
14:29:43 <koz_> Hayoo's been _awfully_ unreliable lately.
14:30:21 <geekosaur> yeh :(
14:33:39 <koz_> It seems my GHC is grabbing the LLVM7 on my path instead of LLVM6.
14:33:53 <koz_> I guess there's no way to change that?
14:35:08 <davean> koz_: building or running?
14:36:19 <koz_> davean: Building. When I give it the -fllvm flag, specifically.
14:37:53 <bollu> how do I talk to the GC in haskell? Can I ask it to "forget" some objects, and then "finalize" / "mark ready for deletion" once I'm done?
14:39:37 <safinaskar> geekosaur: hoogle.haskell.org successfully finds functions with requested type
14:39:58 <safinaskar> geekosaur: and moreover, it can find functions with more general type than i requested
14:40:17 <safinaskar> geekosaur: for example, i need function with type     [a] -> (a -> m ()) -> m ()
14:40:37 <safinaskar> geekosaur: and hoogle.haskell.org successfully finds all functions with more general types
14:40:38 <geekosaur> up to a point. I*d' suggest you should actually read about hoogle, butyou ae striking me as just wanting to argue
14:40:48 <safinaskar> geekosaur: i. e. all functions which can solve my problem
14:40:53 <geekosaur> and I'm uninterested, so go ahead and aruie\
14:40:57 <geekosaur> argue
14:41:31 <safinaskar> this includes forM
14:41:53 <safinaskar> so, well, hoogle.haskell.org type search works exactly how it should be
14:42:01 <dmwit> bollu: What benefit are you imagining you will get from asking the GC to forget an object?
14:42:06 <safinaskar> so why we need haskell.org/hoogle?
14:42:12 <geekosaur> sigh
14:42:15 <bollu> dmwit I want to hack stuff using structs
14:42:30 <bollu> dmwit so I can maintain a "strict universe" inside the lazy runtime
14:42:39 <bollu> dmwit so I don't want to stress the GC out
14:43:38 <dmwit> You might like to google compact regions. Or maybe you just want malloc (which already exists), not sure.
14:52:25 <dmwit> (re: malloc; I mean I'm pretty sure the GC doesn't traverse Ptrs... does it?)
14:53:06 <dmwit> (It really seems from the types of some of the operations that it couldn't possibly traverse Ptrs. e.g. castPtr doesn't require a Storable instance for its output.)
14:53:18 <geekosaur> I would hope not, since you're often using them for data received from C and therefore not part of the gc pol
14:53:20 <geekosaur> pool
14:53:45 <phadej> you cann alloc  from GHC heap (pinned objects) which GC won't move
14:54:33 <phadej> exactly because their contents may be pointers to other pinned objects etc.
14:55:18 <phadej> oh, I wrote and fixed the bug during the same day!
14:55:53 <monochrom> virtual pair of bug and fix annihiliating each other
14:55:54 <dmwit> I'm not sure whether "GC won't move it" is the property bollu is asking for. Not to say it isn't. Just that they haven't been super clear.
14:55:55 <phadej> as a result test-suite has a little bit more diagnostic output
14:56:26 <dmwit> I was imagining "GC won't inspect it". These two properties may go hand-in-hand, but it's not a priori obvious that they must.
14:56:34 <bollu> dmwit well, move = move to older generation, right? that's not all that I want, I want "won't inspect it"
15:01:32 <geekosaur> you can't simply tell ti to ignore something already allocated, no, you ave to allocate it pinned / unmanaged or use compact regions, which sound like what you want
15:02:25 <geekosaur> cg expcts that something in heap will have references to other things in the heap, and will be referenced by other things in the heap --- including shared references to subcomponents, because immutability allows that sharing
15:03:41 <geekosaur> https://github.com/ezyang/compact
15:07:08 <bollu> geekosaur ty. And if I want something that is unmanaged, do I "just malloc()" ?
15:07:24 <dmwit> what are those parens about
15:08:47 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.12.0.0/Foreign-Marshal-Alloc.html#v:malloc (or mallocBytes), probably
15:09:17 <dmwit> No fair. You're being helpful instead of mysterious. Is this even the Internet?
15:18:35 <zachk> the internet ended 2 years ago, this is merely a quantum shared neural simulation of what the internet was....
15:18:47 <hpc> beep boop, can confirm
15:50:44 <_deepfire> How do people debug "solveWanteds: too many iterations" ?
15:53:03 <_deepfire> I'm sure I did something stupid, but I fail to interpret the giant "Unsolved" dump, mainly due to the lack of context of what it means..
15:54:22 <Solonarv> That sounds like an error from GHC's constraint solver. Are you using any compiler plugins?
15:55:12 <_deepfire> No, I don't..
15:56:59 <_deepfire> I have a pretty sick type class head, though.. beginning to get suspicions..
15:57:45 <_deepfire> had to turn on UndecidableSuperClasses to have it even admitted
15:58:26 <_deepfire> and since it's self-referent, via a type family defined in a different type-class, I think I have an idea why it might complain..
16:07:33 --- mode: glguy set +v fen
16:10:32 <fen> data Loop s a t where Loop :: (?act :: (a,t) -> t,?stateS :: s -> (a,Maybe s)) => (t,Maybe s) -> s a t
16:10:42 <fen> data Loop s a t where Loop :: (?act :: (a,t) -> t,?stateS :: s -> (a,Maybe s)) => (t,Maybe s) -> Loop s a t
16:12:34 <fen> :t \f s -> build ((undefined :: (s -> (a, Maybe s)) -> s -> (a -> b -> b) -> b -> b) f s)
16:12:35 <lambdabot> error:
16:12:35 <lambdabot>     • Variable not in scope:
16:12:35 <lambdabot>         build :: ((a -> b0 -> b0) -> b0 -> b0) -> t
16:12:44 <fen> % :t \f s -> build ((undefined :: (s -> (a, Maybe s)) -> s -> (a -> b -> b) -> b -> b) f s)
16:12:45 <yahb> fen: (p -> (a, Maybe p)) -> p -> [a]
16:14:06 <fen> Loop allows values to be retrieved via stateS from the rhs of (t,Maybe s), which then act on the lhs
16:14:19 * Solonarv o . O ( implicit parameters? in a GADT? whyyyy )
16:14:39 * hackage pandoc-citeproc 0.15.0.1 - Supports using pandoc with citeproc  http://hackage.haskell.org/package/pandoc-citeproc-0.15.0.1 (JohnMacFarlane)
16:15:04 <fen> this is one value at a time, while the build loop above does this exhaustively 
16:15:37 <fen> as a result of this "complete" looping behaviour, the version using build can have build fold fusion, and is fast
16:16:04 <fen> how can this kind of thing be done on the version using Loop?
16:16:16 <fen> can the build be commuted into the datatype?
16:17:26 <fen> forwards :: (?act :: (a,t) -> t,?stateS :: s -> (a,Maybe s)) => (Loop s a t) -> Maybe (Loop s a t)
16:19:42 <fen> loop :: (a -> Maybe a) -> a -> a; loop f x = maybe x (loop f) (f x)
16:20:52 <fen> this loop is used with forwards to progress the Loop as far as possible. however, the recursion here rather than in the first argument to build above messes up the inlining 
16:21:42 <fen> if this problem of being able to use build cant be solved, then the Loop datatype is not useful 
16:22:58 <fen> (which is actually almost convenient as it gives an excuse to avoid trying to write the Zipper datatype as "a loop in both directions", and then all the complexities of adding extra constraints to the GADT)
16:23:54 <fen> Zippers are naturally "partially suspended traversals" so it makes more sense not to be able to use the build fusion over them, as they are not supposed to just loop over all the values they contain without stopping like build/fold does
16:26:12 <fr33domlover> Is there a difference between f = undefined and f x = undefined? Does it make a difference to the point at which using the function causes an error? Or is it the same
16:26:36 <shachaf> There is a difference between undefined and (\x -> undefined), because you can distinguish them with seq
16:27:24 <fen> Solnarv: here is the version with the classes written without ImplicitParams, it shows this technique of "adding constraints to a type" https://bpaste.net/show/44b517dd1c56 
16:27:33 <Solonarv> % let { f1, f2 :: Int -> Int; f1 = undefined; f2 x = undefined }
16:27:33 <yahb> Solonarv: 
16:27:50 <fen> here are benchmarks showing how fast the build fold fusion is for the 3 various types of State... https://bpaste.net/show/9944b0e4579d
16:27:52 <Solonarv> % f1 `seq` 42
16:27:53 <yahb> Solonarv: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:2:34 in interactive:Ghci4
16:28:03 <Solonarv> % f2 `seq` 69
16:28:03 <yahb> Solonarv: 69
16:28:13 <Axman6> giggity
16:29:15 <fr33domlover> shachaf, Solonarv, thanks :)
16:30:28 <fen> Solonarv: the point above was that this mechanism for making Zippers a type differing only from Loop by adding constraints is to be avoided, by noting that they differ more fundamentally, in that Loop should run over all the values and get to use fusion as a result, while Zippers are a more appropriate use of the pattern of passing one value at a time 
16:31:47 <Solonarv> fen: I don't mean to be rude, but could you please stop pinging me with your Zipper stuff until you have a coherent writeup or library?
16:32:23 <Solonarv> if I comment on your use of implicit params that does not mean I want a rambling dissertation about zippers!
16:32:51 <koz_> If I need to parse CSV, specifically _without_ trying to guess what types the entries are (that is, treat everything as just blobs of text), should I use cassava, or is there something else more worth using?
16:33:58 <Axman6> cassava can do that just fine, you can get it to give you a Vector (Vector ByteString). You might also want to look at the new sv package, which has a lot of cool features
16:34:12 <koz_> Axman6: I'll check out sv, definitely.
16:34:32 <koz_> Ideally I'd love something that can spew me an Array D Ix2 Text from massiv, but I'll take what I can get. :P
16:34:58 <Axman6> there's a backend which makes ue of succinct data structures to make parsing insanely efficient. There's also... tsv? I'll find it
16:35:41 <koz_> Axman6: I guess you mean the hw-dsv backend?
16:35:47 <Axman6> yeah
16:36:07 <koz_> OOOOH it has AVX powers.
16:36:14 * koz_ is instantly sold.
16:36:15 <Axman6> #fast
16:36:45 <Axman6> make sure you compile with the appropriate flags
16:37:01 <koz_> #fast is what I want, since I'm leaning on massiv with about a gazillion parallel optimizations by means of monoidal folds and ramming through my eight cores.
16:37:48 <Axman6> newhoggy_ and gwilson are who you should be talking to, they wrote hw-* and sv respectively
16:38:03 <koz_> I'll chat to them if I run into trouble. Thank you for introducing me to this very cool thing.
16:38:15 <koz_> I'm a serious SIMD/parallelism fiend/evangelist.
16:38:25 <fen> Solonarv: request for writeup - no problem! this is one of the final considerations in the design of the library.
16:38:30 <Axman6> both of them hang out in #haskell.au if you want to join us
16:38:45 <koz_> Wait, you're in Australia?
16:38:54 <koz_> I'm in NZ, so I'm not (very) far awa.
16:38:57 <koz_> s/awa/away/
16:40:23 <Axman6> yep, and so are both those two
16:40:58 <koz_> Axman6: Thanks - you're officially an Awesome Person.
16:42:03 <MarcelineVQ> It's official.
16:47:56 * Axman6 adds that to his resume
16:48:32 --- mode: glguy set +v chessai
16:48:48 --- mode: glguy set -v chessai
16:48:59 <chessai> is it expected behaviour for an IORef not to be emptied upon a 'cabal new-repl' reload (":r")
16:49:52 <chessai> was experiencing a weird bug related to this, then decided to exit the repl and run `cabal new-run`, and the program ran ideally
16:51:16 <c_wraith> chessai, if you're holding O  to a reference to an IORef across a reload.. its contents won't change.
16:51:21 <c_wraith> *on to
16:51:52 <c_wraith> but holding on to it would imply that it's a top-level IORef in a module?
16:52:06 <c_wraith> that's a dangerous pattern. for that reason, among others.
16:52:41 <c_wraith> top-level mutable cells do not play well with code reloading.
16:56:45 <hpc> it's faster to list the things top-level mutable cells do play well with
16:57:37 <chessai> c_wraith: it is not a top level ioref
16:58:04 <chessai> c_wraith: it is only bound in main
16:58:37 <chessai> i guess i didn't realise that a reload wouldn't free everything
16:58:39 <c_wraith> then how is it still around? does main start a thread that uses it?
16:58:45 <chessai> no
16:59:11 <chessai> i perform some numerical computations using the ioref
16:59:17 <chessai> then i print the result
16:59:19 <chessai> then exit
16:59:48 <c_wraith> because :reload absolutely does trash all local bindings.
17:08:20 <chessai> c_wraith: my main function basically looks like:
17:08:20 <chessai> main = do
17:08:20 <chessai>   !mem <- newPrimArray 30000
17:08:20 <chessai>   !index <- newIORef 0
17:08:20 <chessai>   execute mem index
17:09:20 <zachk> is that ! for strictness? 
17:09:32 <davean> zachk: that is what ! does
17:09:32 <chessai> yes
17:20:38 <Solonarv> you need the BangPatterns extension for that, btw
17:31:07 <zachk> do I need the MagicalHash as well? ;) 
17:33:25 <Solonarv> only if you want to use '#' in identifiers!
17:33:56 <Solonarv> errors from forgetting BangPatterns can get really confusing though
17:34:31 <Solonarv> because without it, 'foo !x = whatever' is interpreted as a binding for (!), not for 'foo'
18:09:46 <iAmDecim> test
18:10:10 <Solonarv> test successful?
18:10:48 <iAmDecim> yes =P
18:10:57 <koz_> Lol.
18:27:03 <koz_> Can a cabal new-build pull in a branch for a source-repository-package?
18:27:23 <maerwald> koz_: why not?
18:27:35 <koz_> maerwald: I tried to feed it this and it blew up: https://github.com/haskell-works/hw-dsv/tree/consistently-use-int-based-simd-registers
18:28:08 <koz_> Exact entry is: http://paste.debian.net/1053502/
18:28:24 <maerwald> no, the location is wrong
18:28:30 <koz_> So what should it be?
18:28:33 <maerwald> https://github.com/haskell-works/hw-dsv.git
18:28:40 <koz_> Yeah, that's the main branch.
18:28:45 <maerwald> no
18:28:49 <Solonarv> I know cabal v2 can pull in deps from git, presumably you can point it at a specific commit
18:28:49 <maerwald> you specify a tag
18:28:55 <maerwald> a branch is just a reference
18:28:59 <koz_> Oh, so it just magically knows? Neat.
18:29:01 <maerwald> git doesn't have actual branches
18:29:15 <maerwald> if it doesn't work, then it's a bug in cabal new-*
18:29:58 <koz_> OK, that works, but that branch has no cabal file, so I am sad.
18:30:06 <maerwald> that is an upstream bug
18:30:17 <maerwald> tell them relying on hpack is wrong.
18:30:37 <koz_> I will.
18:32:17 <Solonarv> I've actually stopped using hpack for exactly that reason
18:32:58 <koz_> What is hpack even?
18:33:46 <maerwald> autogenerator for your .cabal file
18:33:55 <maerwald> Which doesn't even validate if it would be accepted by hackage
18:34:01 <koz_> :(
18:34:29 <maerwald> Also note that stack has an internal copy of hpack
18:34:43 <maerwald> And just starts generating
18:35:30 <koz_> Well, let's see what this nice person responds with.
18:35:35 <Solonarv> and its default template gives you a package.yaml, too
18:35:37 <maerwald> Just provide a PR
18:36:04 <koz_> maerwald: I might later. I'm busy refactoring on one branch and testing their fixes (or trying to) on another.
18:36:15 <koz_> (my own code, not that)
18:39:06 --- mode: glguy set +v safinaskar
18:39:22 <safinaskar> when i want to read ghc docs, i usually go to http://web.archive.org/web/20150706065120/https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/
18:39:30 <safinaskar> is there non-web.archive.org link?
18:40:17 <Solonarv> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/index.html
18:40:37 <Solonarv> AKA "the live version of that"
18:42:31 <koz_> You can also download a PDF.
18:42:35 <koz_> (although it has formatting issues)
18:44:21 <koz_> Is there a way I can specify in cabal.project that a particular package needs to find its cabal file in a special place?
18:45:26 <safinaskar> Solonarv: thanks
18:49:05 <koz_> Never mind, just moved it by hand.
18:49:13 <maerwald> koz_: yes
18:49:19 <maerwald> subdir: 
18:49:54 <maerwald> that expects the whole project to be in that subdir with a valid .cabal file
18:50:03 <maerwald> just moving cabal files around shouldn't really work anyway
18:50:29 <koz_> maerwald: Well, I just needed to test a compile anyway.
18:50:40 <koz_> It works, although I find it odd that this _compiler error_ didn't get picked up before.
18:51:13 <koz_> s/this/these/
18:51:17 <koz_> Oh well.
18:55:14 <maerwald> with 8.6.2 I get an error that I didn't get with 8.4.4: Illegal nested constraint <something>, (Use UndecidableInstances to permit this)
18:55:25 <maerwald> What changed that this only shows up in 8.6.2?
18:56:28 <koz_> maerwald: Could you give the full error?
18:56:31 <maerwald> No
18:56:36 <maerwald> Not opensource
18:56:39 <koz_> Ah.
18:59:53 <dmwit> maerwald: QuantifiedConstraints, perhaps
19:03:48 <maerwald> https://ghc.haskell.org/trac/ghc/wiki/Migration/8.6#UndecidableInstancesispickier
19:03:51 <maerwald> ...
19:05:37 * hackage hw-dsv 0.3.2 - Unbelievably fast streaming DSV file parser  http://hackage.haskell.org/package/hw-dsv-0.3.2 (haskellworks)
19:05:45 <koz_> Oh yay, fix got pushed.
19:05:56 <yushyin> nice to have migration guides
19:06:35 <maerwald> "just add more UndecidableInstances to your code" is not very comforting though ;)
19:07:20 <koz_> UndecidableInstances is a scary-sounding name.
19:09:00 <maerwald> It basically means you are smarter than GHC
19:09:29 <Solonarv> ...and in this particular case, GHC isn't all that smart.
19:09:45 <maerwald> I still prefer not to outsmart GHC
19:10:03 <koz_> Yeah, the instance resolution algorithm it uses is _very_ restrictive.
19:10:25 <koz_> I think Edward had a proposal for a DecidableInstances extension which uses something more permissive, but still guaranteed to terminate, but it's gone dormant.
19:10:38 <Solonarv> Yeah. It'd be nice if it were better at figuring out when instances are actually decidable
19:11:21 <dmwit> s/instance resolution algorithm/termination checker/ ?
19:11:31 <Solonarv> I mean it can't even figure out that 'instance Blah xs => Blah (x ': xs)' is fine
19:11:36 <koz_> dmwit: Yeah, what I meant.
19:22:33 <fen> thats actually a great fix to allow nested typefamilies
19:22:45 <fen> not sure why it is part of UndecidableInstances
19:22:56 <fen> must have some similarities under the hood
19:23:31 <fen> by nested, meaning, that the type returned by a type family can reference another type family
19:23:47 <fen> some explanation of how thats Undecidable might be good
19:24:11 <maerwald> I don't like OOP code
19:24:33 <Solonarv> Welcome to the club :P
19:24:46 <maerwald> Well, type families, undecidable instances etc feel very OOP
19:24:51 <koz_> On that issue, you are quite decidedly among the choir.
19:24:56 <Solonarv> inheritance is the devil!
19:25:13 <maerwald> You can't really reason about anything anymore
19:25:13 <fen> maerwald, how?
19:25:16 * Lycurgus loves the OOP
19:26:48 <Lycurgus> arguably it's a far better paradigm for computing as a thing existing in culture than fp although the latter is better for insiders
19:27:04 <Lycurgus> insiders fighting for insiders, go with the flow
19:27:27 <fen> can you quantify that with reason? 
19:28:32 <fen> or some explanation of what its supposed to mean?
19:28:51 <teto> for those using stack on nix: how can I make $ stack build's "I don't know how to install GHC on your system configuration, please install manually" error go away ? I am in a nix-shell with ghc available :s
19:28:59 <Lycurgus> ofc I could, it's been the dominant paradigm since roughly the turn of the century after a 20 year build up before that; FP just caught fire for the masses in the last decade
19:29:35 <fen> because there is seemingly nothing offered by object oriented languages not having a similar feature in functional programming languages...
19:29:39 <maerwald> Lycurgus: I think they overread your "culture" reference and are waiting for technical explanations ;)
19:29:43 <maerwald> As I thought...
19:29:45 <Lycurgus> stack and nix together seems like overkill or maybe x purposes
19:30:19 <Solonarv> teto: option one is "use stack's nix support" (look at stack's docs)
19:30:20 <fen> it could be suspected that these features elude identification because there are actually no such differences to be compared
19:30:21 * Lycurgus should say he learned OOP with Smalltalk in the mid '80s
19:30:30 <Solonarv> option two is "enable system-ghc"
19:31:18 <maerwald> fen: OOP offers you the biggest culture of programmers, libraries, frameworks, knowledge databases, tutorials, ...
19:31:24 <teto> Solonarv: I have nix: enable: true in .stack/config.yaml
19:31:36 <maerwald> so while you're still busy comparing language details, you missed the actual point :P
19:31:53 <Lycurgus> stack + nix is like "make the non-declarative rubble dance"
19:32:01 <maerwald> Just because it's big, doesn't mean you have to like it though
19:32:06 <Solonarv> teto: ~/.stack/config.yaml is the config for the /global/ project
19:32:07 <maerwald> But it's easily quantifiable
19:32:16 <Solonarv> You need that in your project's stack.yaml
19:33:03 <fen> if it is indeed a bogus distinction between these paradigms, it would simply mean something similar to; object oriented languages lack refferntially transparent type systems.
19:33:35 <teto> Solonarv: isn't ~/.stack/config.yaml appended/merged to every other project ? 
19:33:59 <Solonarv> teto: not as far as I'm aware, but I could be wrong. Look at the docs.
19:34:15 <fen> maerwald: but there is a difference between calling languages of a particular historical vogue a "programming paradigm" and them actually having any sort of real defining features
19:34:39 <maerwald> wat?
19:34:46 <Lycurgus> 69, now its time, for new, believable, people
19:35:00 <Solonarv> There's also a difference between a distinction being vague and it being nonexistent/ill-defined
19:35:00 <fen> is the term just used to reffer to the use of polymorphic inheritance in languages like java?
19:35:08 <fen> because we have that in haskell
19:35:12 <maerwald> We were not talking about language details
19:35:44 <fen> thats the point, your talking about language using a term that should refer to actual language features, to be a "paradigm" 
19:35:53 <Solonarv> Haskell doesn't have inheritance, it just has polymorphism
19:35:56 <maerwald> terminology nitpicking
19:36:35 <fen> Solonarv: how does superclasses appearing via constraints at the class declaration not constitute inheritance?
19:37:25 <fen> isnt it that fp = oop + refferentially transparent types
19:38:03 <Solonarv> Not every partial ordering is "inheritance"
19:38:11 <fen> (so as long as the fp language has inheritance, and accepting that oop is essentially characterised by such inheritance)
19:38:35 <Solonarv> and in any case, it's only "inheritance" of interfaces, not of data types
19:38:37 <fen> Solonarv: it would be really interesting to understand what these terms are supposed to mean
19:39:00 <fen> classes = interfaces?
19:39:01 <geekosaur> "what <x> says they mean". there isn't even one OOP
19:39:22 <Solonarv> well I'll turn that around on you: what are "referentially transparent types" supposed to mean?
19:39:46 <fen> those that facilitate equational reasoning 
19:40:07 <Solonarv> the only meaning I can assign to it says that C has referentially transparent types; after all, you can replace any use of a 'typedef' with its RHS!
19:40:25 <fen> hence the "functional" in functional programming. like how functions are written using a equals sign
19:40:26 <Solonarv> Types have nothing to do with equational reasoning
19:40:48 <Solonarv> The lambda calculus is untyped and equational reasoning is valid
19:40:58 <fen> its possible to do equational reasoning without a type system?
19:41:12 <Solonarv> yes: as I said, the lambda calculus
19:41:24 <teto> Solonarv: I believe it is appended. nix belongs to the "non-project" specific options https://docs.haskellstack.org/en/v1.0.2/yaml_configuration/#project-config
19:41:45 <fen> hmm, what about inheritance?
19:41:53 <Solonarv> teto: well, try enabling nix integration in your project's config anyway. If that doesn't work, I got nothing
19:41:53 <fen> that needs a type system right?
19:42:43 <Solonarv> fen: Eh, prototype-based inheritance (e.g. JS) doesn't need one. But it's debatable whether that's really inheritance.
19:42:56 <fen> meaning that untyped lambda calculus isnt a functional programming language because its not oop 
19:43:07 <geekosaur> it doesn't need one. it could be said to provide one of sorts
19:43:24 <Solonarv> where did you get the idea that OO is a necessary precondition of FP?
19:43:25 <fen> whats prototype?
19:43:34 <gehn> !prototype
19:43:48 <gehn> hmm, wrong chan, nm
19:44:06 <fen> Solonarv, is there a fp language that does not provide inheritance, and is inheritance not the defining feature of object oriented programming?
19:45:01 <Solonarv> 'foo.method()' will first check for foo["method"], then foo.__proto__["method"], then foo.__proto__.__proto__["method"], and so on
19:45:34 <Solonarv> fen: sure. Unlambda.
19:46:34 <Solonarv> Or Haskell (I consider it misleading to apply the term "inheritance" to superclass constraints)
19:46:42 <fen> so then referential transparency, the ability to perform equational reasoning on terms is the defining feature of functional programming?
19:47:09 <fen> Solonarv: how does that not do what inheritance is?
19:47:58 <fen> finally accepts the distinguishing features of these paradigms...
19:48:07 <Solonarv> No. Languages like python or (even!) JS can reasonably claim to support FP, but they sure aren't referentially transparent
19:48:14 <fen> do not for a poset..
19:48:33 <Solonarv> Also, please explain what you mean by "inheritance".
19:48:41 <fen> Solonarv: passing functions as arguments is possible in C, but thats hardly a fp language?
19:49:11 <Solonarv> It doesn't have lambdas, IIRC; so that's enough to boot it out of the club IMO
19:49:25 <maerwald> It's not about features, it's about the spec
19:49:40 <fen> Solonarv: the progressive restriction of objects or types by increasing specification of their properties, where these properties are "inherited" from the superclass
19:49:43 <maerwald> Even if it had lambdas, that doesn't mean the language is based on lambda calculus
19:50:00 <maerwald> I don't understand why people are so feature-centric
19:50:19 <fen> so that means fp is just programming based on lambda calculus?
19:50:23 <maerwald> Yes
19:50:36 <fen> but unlambda has no lambda!
19:50:38 <maerwald> That's how it's defined academically in Amr Sabrys paper
19:50:54 <maerwald> https://pdfs.semanticscholar.org/32ff/28cb5b5c990fe7bdca510040ea22f5c13316.pdf
19:51:04 <maerwald> Of course you can choose to disagree
19:51:17 <maerwald> But I find that definition very simple and accurate and easy to classify
19:51:26 <fen> ah, well unlambda is called a "nearly pure" functional programming language
19:51:30 <Solonarv> It turns out you can recover lambda abstraction from combinators (e.g. the SK calculus), so it isn't strictly needed
19:51:49 <fen> fair
19:52:13 <fen> so is it more about combinator logic?
19:52:34 <fen> or is it the higer order programming paradigm?
19:52:57 <fen> both in terms of higher order functions, and that it compiles to a lower level language
19:53:09 <Solonarv> Combinator calculi are annoying to reason about
19:53:12 <fen> (its a *more* high level language)
19:53:29 <maerwald> fen: you mean transpiles?
19:53:40 <fen> but then thats historical for haskell, it goes strait to machine code now?
19:53:47 <Solonarv> It doesn't matter what a language does or doesn't compile to; clearly Haskell would still exist if you deleted every copy of every haskell compiler
19:54:18 <fen> personally, the best thing about haskell is higher order functions
19:54:22 <Solonarv> GHC can output LLVM too, and other Haskell implementations still exists; e.g. Hugs compiles to some bytecode and interprets that
19:54:27 <fen> and these are nicely captured in classes
19:54:44 <fen> and are really difficult to write in C
19:54:45 <Solonarv> Eta and Frege compile Haskell to the JVM, GHCJS compiles to JS, etc
19:55:18 <fen> could it just be the sugar for passing functions as arguments?
19:56:01 <Solonarv> If you're looking for a single unambiguous defining feature of FP, you won't find it here
19:56:10 <fen> maybe
19:56:27 <fen> or it could be a cultural thing
19:56:30 <Solonarv> Functions being first-class values is definitely an important one
19:56:31 <maerwald> Solonarv: but you can define one for purely functional languages :) (well, not feature, but property)
19:57:05 <Solonarv> True.
19:57:06 <fen> yeah, this started as the lack of such for what is meant by object oriented
19:57:13 <fen> and if haskell could be considered as such
19:57:59 <Solonarv> generally, when talking about whether a language is <X paradigm> you're really talking about whether it's natural to use <X paradigm> in that language
19:58:10 <Solonarv> in that sense, no Haskell is not OO.
19:58:16 <fen> but the particular paradigm eludes definition!
19:58:23 <maerwald> Not every conversation is technical. Programming is both technical and artistic/mechanical. On an artistic level, we can agree on a much more en passe language and we are more talking about how things *feel*
19:58:39 <maerwald> And some parts of GHC features feel quite OOP
19:58:40 <fen> what makes a language "feel" OO
19:59:13 <Solonarv> you could of course build a library that embeds an OO language in Haskell.
19:59:25 <Solonarv> With OverloadedLabels the syntax wouldn't even be too awful
19:59:27 <fen> thats not the point, you can do that with haskell in C
19:59:43 <Solonarv> ...hmmm I want to do that now
20:00:06 <fen> the argument against that used to be that haskell can generate C anyway...
20:00:30 <Solonarv> no, I don't mean some template haskell/quasiquote stuff
20:01:24 <fen> so even if not all functional programming languages have the same features, haskell sets the pace for the other languages that either lag or have overtaken it 
20:01:55 <fen> the fact is that this OO feel is fine for haskell and similar languages, but the converse is not true
20:02:13 <fen> C sucks to try and emulate haskell style for example
20:02:29 <fen> but thats just sugar at the end of the day...
20:03:01 <fen> and if traditionally OOP langauges are getting more functional, with lambdas and stuff
20:03:18 <Solonarv> Languages are allowed to have multiple paradigms
20:03:21 <fen> maybe these apparent distinguishing padadigms are a red herring
20:03:23 <Solonarv> I mean just look at C++
20:03:29 <fen> rather not
20:03:42 <Solonarv> hah, fair enough
20:04:45 <fen> yeah, so as the languages get features borrowed from other languages where some style is more natural, isnt it like that object orientation isnt so much a set of languages, as an era of programming advances
20:04:57 <maerwald> I think it's fair to say that things like C++ or Scala are more meta-languages. Depending on what feauteres you use, you get a *completely* different experience.
20:05:10 <maerwald> And in fact, GHC is heading the same way
20:05:35 <fen> and that is true also for functional programming, its the era of functional programming now, since the features added to languages across the spectrum are developed as parts of functional languages
20:05:59 <teto> so I've presented my stack + nix problem (stack can't find ghc even when ghc is in PATH) at https://github.com/commercialhaskell/stack/issues/4420 .
20:06:09 <fen> maerwald: certainly ambiguity of styles exists within languages.
20:06:17 <maerwald> fen: not in all
20:06:22 <fen> fair
20:06:23 <maerwald> And with very different degree
20:06:50 <maerwald> Go and clojure pretty much look the same everywhere
20:06:56 <maerwald> Which is good
20:07:06 <maerwald> (for reading)
20:07:40 <fen> sometimes it can be annoying to have to think about why one style might be advantageous over another, an sometimes better expressive capabilities are countered by less readability, as the normal approach sets the standard
20:08:40 <fen> (adding constraints to datatypes for example, or type families used to generate new constraints instead of classes)
20:08:51 <maerwald> Yeah, priorities. For me it's almost never about expressivity or abstraction... both of those are at the end of my priority list
20:09:21 <fen> the least sufficient complexity for a given use case is ok
20:09:51 <fen> but then its also nice if more complex features are made sugary by the syntax of the language
20:10:03 <fen> kind of seems like thats actually what makes haskell so great
20:10:27 <maerwald> sugar causes cancer, use it seldomly ;P
20:10:42 <fen> then it makes something considerably complex and resultingly unreadable to most, into the standard, most readable way
20:11:25 <fen> maerwald: no, like how templates in C++ are sugared away by haskell syntax
20:11:56 <maerwald> I don't know how that related to sugar really
20:12:16 <fen> right, people say sugar is like ($) 
20:12:38 <fen> or some other neat infix sprinkles 
20:12:48 <maerwald> that's not sugar
20:12:54 <fen> ok so whats it?
20:13:13 <maerwald> I don't know. Technically it's not and artistically I have no idea what you could possibly mean either
20:13:36 <fen> "a pretty api"
20:14:20 <fen> the argument agains which is that seeing loads of wierd symbols you have not yet learned the meaning of can be quite stressful 
20:14:51 <maerwald> Not sure that is the argument against
20:15:22 <Solonarv> A good example of good sugar is 'do' notation
20:16:01 <maerwald> Solonarv: and then you hit MonadFail desuagring :P
20:16:18 <fen> like, hiding the api behind a unintrusive api can lead to it being less visible (more readable, but also with less obvious effects on the code - like "why does that type check, argh what are all those funny symbols, oh, its applicative sugar, why cant they just write fmap like normal people!"
20:16:43 <Solonarv> I mean that's fixed by an extension which will become standard SoonTM
20:17:17 <maerwald> Solonarv: it is already in 8.6.2 afais
20:17:28 <maerwald> But that's still an instance of "not so obvious"
20:17:42 <maerwald> sugar can make you do things you don't understand
20:17:47 <Solonarv> oh, nice! I'm not on 8.6 yet because stack
20:17:58 <maerwald> Solonarv: embrace cabal :)
20:18:14 <glguy> stack can use 8.6.2 as well
20:18:20 <Solonarv> I am. My workflow is "stack exec cabal".
20:18:25 <maerwald> glguy: does it resolve with latest lts?
20:18:38 <glguy> Not that I know of, but lts is something else
20:18:50 <Solonarv> I'm on windows and using it cabal/ghc directly is more annoying than having stack install them
20:19:04 <maerwald> windows is your own fault!
20:19:14 <yushyin> stackage nightly has 8.6.2
20:19:30 <Solonarv> That's true, but it doesn't magically install linux either
20:19:33 <glguy> Solonarv: e.g.:  stack ghci --resolver=ghc-8.6.2
20:20:21 <Solonarv> Yeah, my editor integration is intero currently, which doesn't play well with that.
20:20:26 <Solonarv> I should probably swap to HIE
20:21:02 <glguy> You can set the resolver in your stack.yaml, doesn't have to be a command-line flag
20:21:27 <glguy> not wanting to get my workflow bogged down only supporting stack is why I stick to dante on emacs
20:21:29 <maerwald> Solonarv: you have a 50% chance that HIE compiles xD
20:21:59 <Solonarv> Uh oh. Definitely not something I want to mess with tonight then XD
20:22:04 <Solonarv> I'll try this weekend
20:22:31 <maerwald> if it compiles, you have a 50% chance that it works
20:22:46 <maerwald> if it works, you have a 50% chance that it doesn't blow up your memory
20:23:55 <maerwald> The problem is that it's still based on ghc-mod codebase. It's not really a from-scratch thing
20:23:59 <maerwald> it carries lots of legacy code
20:31:02 <Solonarv> Definitely a mixed blessing
20:34:28 <maerwald> The main problem with haskell tooling in fact is not features, but performance
20:34:42 <maerwald> But there is no project prioritizing performance
20:35:09 <maerwald> Even if something works, you can likely not use it on GHC codebase ;)
20:37:25 <Solonarv> good thing I'm not working on the GHC codebase then ;)
20:37:42 <Solonarv> I'd say it isn't just features, but also currentness
20:38:02 <Solonarv> ghc-mod and intero lag behind by one or two GHC versions usually
21:03:36 <superlinux> hello.  when I do `stack install hpack-convert` I get the same error as in this link: https://github.com/yamadapc/hpack-convert/issues/18 . there is a link for a patch in the same page. can someone help me install hpack-convert? thanks.
21:04:37 <superlinux> hello.  when I do `stack install hpack-convert` I get the same error as in this link: https://github.com/yamadapc/hpack-convert/issues/18 . there is a link for a patch in the same page. can someone help me install hpack-convert? thanks.
21:23:51 <glguy> superlinux: How about just building it with the lts version that it supports?
21:24:14 <superlinux> glguy, how can I do that?
21:29:53 <Axman6> stack --resolver lts-N.MM install hpack-convert
21:30:31 <superlinux> Axman6, ok cool
21:31:00 <superlinux> Axman6, which lts do you think I should select ?
21:32:41 <superlinux> ok I selected lts-10.0 . cross my fingers
21:40:24 <koz_> When using massiv, under what (general) conditions is profitable to set the computation strategy to Par instead of Seq? I _assume_ that 'small array = Seq is better'; am I missing anything?
21:43:03 * hackage avro 0.4.1.0 - Avro serialization support for Haskell  http://hackage.haskell.org/package/avro-0.4.1.0 (alexeyraga)
21:48:52 --- mode: glguy set +v PatrickRobotham
22:08:18 <maerwald> is there a way for defining alternative dependencies in cabal?
22:08:29 <maerwald> probably only via flags I guess?
22:23:49 <superlinux> I had to go down to lts-9.0 to get hpack-convert compiled . wow !! too much
23:20:05 <m-renaud> superlinux: Whoa, I just looked at that package and it doesn't have hardly any dependency bounds defined :/
23:40:03 * hackage sparrow 0.0.3.1 - Unified streaming data-dependency framework for web apps  http://hackage.haskell.org/package/sparrow-0.0.3.1 (athanclark)
