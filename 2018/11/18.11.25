00:54:02 <f-a> in my test-suite section (.cabal) I got
00:54:05 <f-a> main-is:             Main.hs
00:54:27 <f-a> so why, when I run `cabal new-repl test`, `main` is not loaded?
00:54:43 <f-a> I need to :load test/Main.hs
00:54:52 <f-a> but don't understand why
01:59:17 <f-a> say that I have a function :: a -> b -> c. What newtype should I wrap it in to that fmap f function modifies `c`?
02:19:19 <koz_> f-a: I _think_ you're after this: https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Compose.html
02:19:40 <koz_> (assuming I correctly understood what you're after)
02:20:11 <f-a> most likely yes koz_ , many thanks
02:20:40 * hackage tree-diff 0.0.2 - Diffing of (expression) trees.  http://hackage.haskell.org/package/tree-diff-0.0.2 (phadej)
02:33:44 <Mrbuck> Hi any maths professor here ?
03:14:33 <phadej> I think the cumulative knowledge of people here is worth many professors
03:15:17 <f-a> given that we are to handpick those professors, I agree phadej ;)
03:17:40 --- mode: glguy set +v fdda2ab512365
03:28:52 <fr33domlover> I did `stack build` (recently moved the hard disk from one laptop to another one, idk if that's relevant) and  suddenly stack decides to download GHC nopie
03:28:58 <fr33domlover> What does it mean? 
03:29:06 <fr33domlover> Why does it need to download a new GHC
03:29:19 <Rembane> Which version of GHC did you use before? 
03:29:35 <Rembane> And what are the OSs on the different laptops?
03:30:25 <fr33domlover> Rembane, same, I was using stack 2 days ago on the same project and same OS, the only changes I can think of are changed laptop and maybe apt-get upgrade
03:30:45 <fr33domlover> Rembane, same OS, I just moved the hard disk so it's exactly the same OS and everything
03:31:58 <Rembane> fr33domlover: PIE is a hardening strategy that's being rolled out on Linux for some time now. I wonder if it just kicked in on your computer. https://wiki.ubuntu.com/SecurityTeam/PIE
03:32:33 <Rembane> fr33domlover: I pasted the wrong link, sorry. https://en.wikipedia.org/wiki/Position-independent_code#Position-independent_executables
03:37:26 <fr33domlover> Rembane, thanks :) I'm aware of PIE, just wondering why it needed a new GHC ^_^ I build stuff on one machine and scp to another so I was worried it won't work anymore etc.
03:38:43 <Rembane> fr33domlover: Cool, well, that might still be the case. :)
03:42:28 <fr33domlover> Rembane, do you mean it will work or it won't? :P
03:46:34 * hackage hw-prim 0.6.2.22 - Primitive functions and data types  http://hackage.haskell.org/package/hw-prim-0.6.2.22 (haskellworks)
03:48:51 <Rembane> fr33domlover: It probably won't. Try it! :D
03:50:28 <fr33domlover> Rembane, yeah, I will ASAP. Why would it not work though?
03:51:54 <Rembane> fr33domlover: I just have a feeling that if an executable puts all things in random places in memory when the OS expects it not to it could lead to things not working properly.
03:53:08 <fr33domlover> Rembane, does it put them in random places though? GHC *nopie* ? :)
03:53:14 <merijn> Rembane: Why would the OS expect anything to be anywhere?
03:55:05 <Rembane> merijn: That's a very good point. 
04:21:32 <f-a> when I construct an HashMap (say, a = fromList [(3,"foo"), (1,"goo"), (18,"paa")]) and then I call `keys` on it, I see the keys are ordered in a different way than when I first inserted them.
04:22:01 <f-a> Indeed from the documentation "A HashMap makes no guarantees as to the order of its elements". Is there a similar structure but that preserves ordering?
04:25:09 <lavalike> :t M.fromList
04:25:10 <lambdabot> Ord k => [(k, a)] -> M.Map k a
04:25:29 <lavalike> nevermind
04:27:01 <lavalike> f-a: I guess the question is what operations you need on such structure, and with what complexity
04:28:36 <Ariakenom> f-a: a Ord based map will give you the keys in Ord order
04:29:46 <Ariakenom> f-a: or do you want insertion order?
04:30:00 <f-a> ah, silly me, yeah, insertion order
04:31:06 <f-a> lavalike: I use lookup(99% of the time) and insert / delete
04:31:17 <geekosaur> re nopie, it's not the OS, its things like gc making assumptions about memory layout, or heap allocatins which may not like randomly placed shared object mappings, etc.
04:31:28 <Ariakenom> im not aware of anything that gives you that out of the box. But you can replace key with (index, key) and then use an Ord map
04:32:03 <lavalike> I was thinking keeping the list of insertion ordered keys on the side, but putting it in the key is a better idea (:
04:32:10 <f-a> Ariakenom: indeed good idea
04:32:17 <Ariakenom> issue being
04:32:27 <lavalike> not (key, index) ?
04:32:38 <Ariakenom> that if something should replace the key you need to know the index used
04:32:55 <f-a> lavalike: very good idea
04:33:04 <Ariakenom> > (0,1) < (1,0)
04:33:06 <lambdabot>  True
04:33:30 <lavalike> Ariakenom: yeah I'm saying you keep the standard usage of the map this way, and you can sort the output of toList, when you need it
04:33:39 <lavalike> (instead of losing the info)
04:33:59 <geekosaur> but iirc the biggiehere is that you generate different code for position independent, because it's liek everything including the normally static stuff in the C runtime framework, is now dynamic. and the code geenrator doesn't expect that and generates static relocations, which show up as linker errors
04:34:19 <Ariakenom> hm, losing what info?
04:34:24 <lavalike> the insertion order info
04:35:06 <lavalike> :t sortBy (comparing (snd . fst))
04:35:08 <lambdabot> Ord a1 => [((a2, a1), b)] -> [((a2, a1), b)]
04:35:26 <ski> > (map (second snd) . sortBy (comparing (fst . snd)) . HS.toList . HS.fromList . zipWith (fmap . (,)) [0..]) [(3,"foo"),(1,"goo"),(18,"paa")]
04:35:29 <lambdabot>  [(3,"foo"),(1,"goo"),(18,"paa")]
04:35:32 <lavalike> (:
04:36:07 <Ariakenom> to keep normal usage you need to put the index onto the value and then sortBy, dont you
04:36:10 <ski> > (HS.fromList . zipWith (fmap . (,)) [0..]) [(3,"foo"),(1,"goo"),(18,"paa")]
04:36:13 <lambdabot>  fromList [(1,(1,"goo")),(18,(2,"paa")),(3,(0,"foo"))]
04:36:53 <lavalike> maybe that's better
04:38:15 <ski> hm, i suppose i didn't get why one'd like to keep the original index/counter in the key ?
04:38:42 * ski was just thinking about being able to recover the original order/index
04:38:45 <f-a> ski: imagine importing a .csv file
04:39:33 <f-a> Hashmap ColName (SomeVector), but you would still like to have the columns sorted as original
04:39:57 <lavalike> ski: it might be a bad idea actually, it screws up update
04:40:01 <ski> yea, but do you need that information in the *key*, as opposed to in the value ?
04:40:24 <geekosaur> I thik ski is sugesting e.g. a 2-level maping. one from original key to internal key, second uses the internal key. iterate the second to get the insertion order, use the first to access by original key?
04:40:26 <ski> (or maybe stored separately)
04:40:27 <lavalike> I think the (key,(index,value)) idea is just better
04:41:04 <lavalike> my ((key,index),value) idea just screws up many of Map's functions
04:41:41 <f-a> geekosaur: so Map k (i, v) ?
04:41:43 <tauoverpi[m]> Hmm, are there any other tools than just regular screen readers for blind programming with haskell? (e.g semantic information from the compiler in a form for tools such as espeak)
04:41:54 <geekosaur> f-a, two maps
04:42:03 <f-a> thanks
04:42:04 <geekosaur> Map k i, map i v
04:42:11 <geekosaur> Map i v
04:42:31 <f-a> geekosaur: wouldn't it be Map k v, Map k i?
04:42:42 <Rembane> Why not, Map k i, Vector v?
04:42:55 <geekosaur> no? you want the one with i as key to retreive the original insertion order
04:43:17 <geekosaur> you do two lookups for keyed access, ordered scan on the internal to get the origial insertion order
04:43:26 <f-a> I see
04:43:28 <f-a> thanks
04:43:35 <geekosaur> althoguht here are other ways to do thsi as well, depending on what kind ofperformance you need
04:43:38 <ski> i suppose there's several variants, here
04:44:32 <Ariakenom> shove into SQLite and build index for key
04:44:38 <Ariakenom> we need more choices
04:44:40 <geekosaur> and of course if there's only a handful of rows, sometimes just an alist is easier
04:51:47 <lavalike> geekosaur: two maps is nice too!
04:53:13 <lavalike> toList is just O(n) instead of adding the O(n log n) of sorting, on the flip side you have to insert and delete in two different maps
04:53:33 <geekosaur> yep. you need to thik out how you're using it to decide which approach works best
04:53:44 <lavalike> quite
05:16:33 * hackage multilinear 0.5.0.0 - Comprehensive and efficient (multi)linear algebra implementation.  http://hackage.haskell.org/package/multilinear-0.5.0.0 (ArturB)
05:28:33 * hackage hlibsass 0.1.8.0 - Low-level bindings to Libsass  http://hackage.haskell.org/package/hlibsass-0.1.8.0 (jakubfijalkowski)
05:35:19 --- mode: glguy set +v cgenie[m]
05:59:37 <safinaskar> why parsers often implemented as "String -> [(s, String)]"?
05:59:48 <safinaskar> say, Prelude's ReadS is exactly this
05:59:54 <safinaskar> why we need list here?
06:00:04 <safinaskar> why not "String -> Maybe (s, String)"?
06:00:24 <lavalike> safinaskar: in case there are multiple matches
06:00:25 <f-a> safinaskar: historical artifact
06:00:54 <lavalike> f-a: so that never happens?
06:02:30 <safinaskar> look here: https://zerobin.net/?afa3b945c315c711#KGVjdGW1bAel9Pb2DkuL2FF6M3kFIHTLIK2AZ6f6dyA=
06:02:33 <c_wraith> not with Read, anyway
06:02:36 <f-a> lavalike: I am pretty sure there are documented cases of using [a] instead of Maybe a
06:02:44 <safinaskar> i wrote "String -> Maybe (s, String)" implementation
06:02:47 <f-a> i.e. read sohuld crash on ambigious parser
06:03:02 <c_wraith> safinaskar: yes, it works.  It just doesn't handle ambiguous grammars.
06:03:32 <safinaskar> c_wraith: please give me practical example of such grammar
06:05:30 <f-a> safinaskar: check your `alt`, what if both x and y succeded?
06:06:43 <ski> i think using lists can be more modular, in the sense of more refactoring laws. even if one's not interested in getting ambiguous answers in the end
06:07:13 <safinaskar> f-a: my code will pick first result
06:07:18 <ski> if one's never using non-disjoint alternatives, it shouldn't matter
06:07:26 <mniip> safinaskar,  <stmt> = <expr> | if <expr> then <stmt> | if <expr> then <stmt> else <stmt>
06:07:49 <c_wraith> safinaskar: in pseudo-BNF  expr ::= literal | (expr) | expr + expr | expr * expr
06:08:20 <f-a> safinaskar: well maybe that is not what the user wants
06:10:05 <ski> the law i'm thinking of would be the left-distributive law `monadicSeq (alt p0 p1) k = alt (monadicSeq p0 k) (monadicSeq p1 k)', which fails with `Maybe' instead of `[]'
06:11:18 <mniip> yeah, with Maybe,  alt x y is not the union of languages x and y
06:11:49 <c_wraith> Not that I think handling ambiguous grammars is especially useful.  It's easy to make parse time go exponential with ambiguous grammars.  Avoiding that is nearly as much work as just factoring out the ambiguity in the first place.
06:12:21 <ski> specifically, pick  p0 = char 'a'; p1 = monadicSeq (char 'a') (\_ -> char 'b'); k _ = char 'c'  and consider the input `"abc"'
06:13:43 <ski> (this is basically the same as mniip's and c_wraith's examples, of course)
06:14:31 <mniip> alt x y = x union {w | w in y, no prefix of w in x}
06:14:35 <ski> mniip : `x,y :: Parser ()' ?
06:16:31 * ski thinks safinaskar's use of brackets and semicolons is .. interesting
06:17:34 <ski> (fwiw, in `char', you could use a guard instead of an `if'-`then'-`else')
06:19:31 <safinaskar> ski: "if one's never using non-disjoint alternatives, it shouldn't matter" - i can use my Maybe-parser even if i have non-disjoint alternatives. i just need to list preferred alternative first. for example, my parser CAN handle dangling-else grammar. i need just to put "if _ then _ else _" variant first, and then "if _ then _"
06:19:58 <safinaskar> mniip: as i just said, my parser works well with dangling else
06:20:14 <ski> safinaskar : *nod*, never said you couldn't
06:20:29 * ski . o O ( maximal munch )
06:20:45 <c_wraith> the change to make my grammar work is a lot more intensive.  It can be done, of course.
06:20:50 <c_wraith> ski: LR parsing. :)
06:20:51 <safinaskar> c_wraith: "expr ::= literal | (expr) | expr + expr | expr * expr" - this grammar cannot be handled by parser combinators at all, because it is left recursive
06:21:03 * hackage hsass 0.8.0 - Integrating Sass into Haskell applications.  http://hackage.haskell.org/package/hsass-0.8.0 (jakubfijalkowski)
06:21:04 <ski> right
06:21:14 <c_wraith> safinaskar: not true.  many parser combinator libraries can handle it fine.  Ones that are LL-based cannot.
06:21:26 <dminuoso> safinaskar: https://pure.royalholloway.ac.uk/portal/files/31169565/paper.pdf
06:21:42 <c_wraith> safinaskar: but something like the earley library would have no trouble.
06:21:46 <dminuoso> safinaskar: Heck not even that, the one quoted in its abstract shows this too. :)
06:22:19 <safinaskar> f-a: "well maybe that is not what the user wants" - you mean picking the first alternative is not what the user wants? well, let's assume i actually release this code with docs. then i will write to docs, that my code picks first alternative. if you think my solution is not ideal, well, please, give example where it doesn't work
06:22:34 --- mode: glguy set +v smitop_
06:23:50 <ski> hmm
06:29:03 * hackage multilinear-io 0.5.0.0 - Conduit-based input/output capability for multilinear package.  http://hackage.haskell.org/package/multilinear-io-0.5.0.0 (ArturB)
06:33:10 <ski> i suppose i'd like concatenation of parsers to include the concatenation of the corresponding languages
06:33:23 <f-a> safinaskar: in a context free grammar, ambiguous strings are one which can be constructed in more than one leftmost derivation
06:33:57 <f-a> which goes in hand with "more than one parse"
06:34:47 <f-a> of course, your library would solve that by picking the first parse tree
06:36:39 <safinaskar> ski: "the law i'm thinking of would be the left-distributive law" - wow, you are right. i wrote example which demonstrates this: https://repl.it/@safinaskar/PrettyUnawareRecursion
06:37:09 <safinaskar> ski: but i still think that user of parsing library should be careful
06:38:16 <safinaskar> ski: i. e. if a user want to parse regex (aa|a)ab, then he should refactor it into (aaab|aab) and then actually parse it using parsing library
06:39:03 <safinaskar> ski: well, in this particular regex case i know you will likely disagree with me. but in general, when parsing real programming languages, i think user of parsing library should think how to write his parser code
06:40:07 <ski> "if a user want to parse regex ..., then he should refactor it into ..." -- yes, i suppose i'm mostly saying that this is something that a user needs to be aware of
06:40:45 <ski> otherwise they could easily (i think) use this distributive law, when writing or refactoring code, without realizing that it's problematic in this setting
06:41:47 <lavalike> there's also another way to look at this: when you have such ambiguous parses, you can use your data to provide error messages that help the user, if you're not throwing it away
06:41:59 <safinaskar> ski: "thinks safinaskar's use of brackets and semicolons is .. interesting" - well, i use them in c++ style. if you have any guide which will help me to switch to bracker-free style, then, well, please, give me it
06:42:06 <ski> (and i'd prefer it, if a user wouldn't need to be wary of such things, for correctness. but still be able to get reasonable performance, without torturing the code)
06:42:54 <ski> (one could argue that, at least sometimes, having to "refactor" one's code in this way, in order to get it correct, would amount to torturing the code)
06:43:17 <merijn> safinaskar: The layout rules are fairly straightforward, the wikibook has an in-depth explanation of how they work: https://en.wikibooks.org/wiki/Haskell/Indentation
06:43:40 <ski> safinaskar : i'm not saying your use of brackets and semicolons is wrong or anything. just unusual
06:44:09 <merijn> safinaskar: tbh, in your specific case simply deleting the brackets/semicolons it should "Just Work"
06:44:35 <ski> safinaskar : what i'd suggest is getting familiar with the indentation rules, so that you know how to use them (including possible caveats and gotchas), and then decide which alternative suits you better
06:44:39 <merijn> ski: Well, it's not "wrong", but it's clearly deviating from the community default of "layout everywhere" :)
06:44:51 <ski> sure
06:45:15 <ski> there's also some people who insist on using tabs for indentation
06:45:17 <merijn> Anyway, I think the wikibook is pretty comprehensive on how it works and any caveats
06:45:23 <ski> which can work, if you're principled about it
06:47:10 <ski> (it's not something i'd recommend to beginners, unless they're adamant about it, but ..)
06:48:26 <__monty__> ski: Enabling is the wrong approach with substance abusers : p
06:48:35 <ski> hehe
06:49:30 <ski> i suppose i tend to lean towards telling people why you should not "hang yourself", but then also, at least if prompted, point them to the rope
06:50:09 <__monty__> Yes but tabs is like pointing trump at the nuclear football ; )
06:52:19 <ski> (sometimes, because reasons, you want/need to do something which isn't generally advicable (or at least you think you do). after telling why it's usually/commonly a bad idea, i lean towards enabling them making an informed decision on their own)
06:54:48 <safinaskar> bye
06:58:59 <__monty__> ski: Yeah, keep doing the good work, was jk.
06:59:54 <tauoverpi[m]> Technically tabs are much clearer in conjunction with braces and screen readers.
07:00:16 <c_wraith> oh, darn.  Took me too long to learn the Earley library.  safinaskar left.  (I implemented my sample grammar in it)
07:03:37 <__monty__> tauoverpi[m]: Screen readers read indentation explicitly? o.O
07:18:49 <c_wraith> well, you know.  In case someone wants a really dumb example of using Earley:  https://gist.github.com/chowells79/44b30ad6400c664a9cfa15b835fb0729
07:19:31 <tauoverpi[m]> usually yes. Some languages don't really require it but for those that do it really helps
07:19:46 <tauoverpi[m]> e.g python is next to impossible without it reading indentation
07:22:51 <ski> c_wraith : nice
07:23:08 <c_wraith> ambiguous parsing!
07:23:55 <tauoverpi[m]> But symbols like `<$>` are more of a problem than indentation tbh
07:24:21 <f-a> how so
07:24:23 <hpc> or symbols like (<*) which don't match '<>'
07:24:24 <f-a> precedence?
07:24:27 <f-a> oh
07:25:32 <tauoverpi[m]> what do you call it? `fmap` works but then it becomes awkward as you have `fmap f x` and `f fmap x`
07:26:02 <f-a> I see
07:26:33 <c_wraith> Yeah, Haskell does sound particularly screen-reader unfriendly.
07:27:17 <tauoverpi[m]> It could be perfect if GHC had an IDE mode similar to Idris' one
07:27:18 * ski recalls talking to someone in here, some years ago, who were blind, and learning/programming Haskell
07:27:21 <f-a> I suppose scheme an list are nicer
07:27:40 <f-a> very few operators, regular syntax
07:28:05 <ski> tauoverpi[m] : what does that IDE mode do, wrt this ?
07:28:22 <ski> `paredit'-like structural navigation and editing ?
07:28:34 <tauoverpi[m]> provides hints for speech
07:28:34 <tauoverpi[m]> and structural navigation
07:28:46 <ski> interesting
07:28:48 <dminuoso> ski: That's definitely an interesting topic: A programming language tailored for blind people.
07:29:21 <dminuoso> When we write code, a lot of thought goes into structuring code to be visually pleasant.
07:29:40 <tauoverpi[m]> Once the compiler (or doc tool) is capable of looking up documentation for functions it becomes much simpler
07:30:11 <tauoverpi[m]> iff there are hints for operator names
07:30:49 <ski> i've been talking to someone, who's visually impaired, and (i think) getting worse, so that they can't really see much of any detail any longer
07:30:50 <tauoverpi[m]> dminuoso: Yeah, it could be much better for those without sight.
07:31:01 <tdammers> I'd imagine that a proglang for blind people would be optimized such that text-to-speech and speech recognition would be lossless
07:31:07 <tdammers> or at least as close as possible
07:31:32 <ski> anyway, they told me that they have this sort of mental "visual" (?) model in their mind about their surroundings, where things are. and if they'd suddenly discover say a towel on a table they didn't remember being there, it'd suddenly "pop into existence" in their mental model
07:31:41 <tauoverpi[m]> It doesn't really need to affect syntax much if you have enough information from the compiler and an IDE which handles indent/blocks
07:32:16 <tdammers> tauoverpi[m]: well, things like Haskell operators that don't even have commonly agreed-upon pronunciations are clearly not a great thing for this
07:32:19 <ski> so, i'm thinking that perhaps, not all of the "structuring code to be visually pleasant" actually needs to rely of seeing
07:32:36 <tdammers> another direction I'd think in would be structural editing
07:32:59 <tdammers> i.e., make the visible representation independent from the AST, and allow manipulating AST through multiple alternative representations
07:33:00 <ski> (yes, having a mental model of a structure is close to what i was mentioning, i think)
07:33:47 <tdammers> the problem with that, I think, is that we don't yet have a sufficiently simple-yet-expressive tree data format that could be a substrate for arbitrary programming languages in the same way textual format currently can
07:34:08 <tdammers> XML could have been that format if it hadn't been for its obvious problems
07:34:24 <tdammers> (XML the DOM semantics, not XML the textual syntax, I mean)
07:34:27 <tauoverpi[m]> tdammers: yep, but haskell does usually form rather nice sentences compared to some of the other languages.
07:34:28 * ski recalls a computer game which had submenues for different party members, which looked roughly the same. it was annoying to have to traverse up to a common ancestor, and then down "the same path" on another party member, when one just wanted to switch the party member, but keep the other context the same
07:34:46 <ski> so, sometimes we'd like commuting paths, iow graphs rather than trees
07:35:41 <tdammers> another thing worth looking at for inspiration would be radio phraseology, like what they use in aviation
07:35:53 <ski> e.g. with multiple defining equations of a function, it'd be nice to be able to move directly from a pattern for an argument, to the corresponding pattern for the same argument, in (say) the next defining equation, without having to traverse up and down
07:36:56 <ski> (recall how many people like to align "parallel" patterns and expressions)
07:37:47 <__monty__> I'd expect a more useful solution would be to be able to change the screen reader behavior, say cyclops instead of <*> for example. Not having agreed names doesn't matter much if you can choose your own. It'd also help with everything, rather than just this hypothetical language optimized for screen readers.
07:37:51 <ski> tdammers : elaborate ?
07:41:11 <tauoverpi[m]> monty: yep, I have <*> bound as "ap" regardless of haskellish which language I'm using. It would be nice if we could leave hints for screen readers within the documentation for the symbols along with the extra meta-data such as type, constraints, bound variables, etc.
07:41:53 <tauoverpi[m]> Plus different tones depending on if it's a constructor (Red), type (Blue), etc
07:42:24 <c_wraith> ghc actually has support for custom annotations which are preserved in .hi files
07:42:30 <mniip> tauoverpi[m], tones? red? blue?
07:42:55 <c_wraith> it seems like you could use that mechanism.  It would need a lot more work, but maybe the foundation is in place
07:42:59 <ski> mniip : presumably they're thinking of automatic conversion of syntax highlighting colors to tone
07:43:31 * ski plays a blue note
07:44:35 <Zemyla> You all know confusing in lens?
07:44:41 <mniip> sure is
07:44:45 <c_wraith> I like to laugh at its name, at least
07:45:12 <mniip> haha
07:45:18 <mniip> I read "You all know how confusing is lens"
07:45:34 <tauoverpi[m]> mniip: Conor McBride set down a set which has been in use for papers on dependent types and Idris-mode's semantic highlighting
07:46:48 * ski somehow associates constructors more with green, and deconstructors/selectors with red
07:47:12 <tauoverpi[m]> Here is a list: http://docs.idris-lang.org/en/latest/reference/semantic-highlighting.html
07:47:15 <Zemyla> Well, I've actually figured out how it works, and it's less confusing than it sounds, but its current implementation is a bit more complicated than it needs to be.
07:50:22 <tauoverpi[m]> Another issue would be errors... they aren't pretty at all
07:51:52 <Zemyla> Like, I know you're all familiar with Yoneda.
07:53:55 <Zemyla> And newtype RightAssoc f a = RightAssoc { runRightAssoc :: forall r. f (a -> r) -> f r } is a free Applicative for any Functor that associates <*> calls to the right.
07:55:43 --- mode: glguy set +v lemastero
07:56:06 <Zemyla> So what confusing does is uses something similar to that RightAssoc type with Yoneda f to eliminate the Applicative dictionary of the type being used altogether, which simplifies the code for a bunch of nested traversals.
07:57:21 <Zemyla> However, I recently figured out that you only need Yoneda f (a -> r) -> f r, because only the left side is fmapped, so this saves passing a function around.
07:57:29 <haasn> It's a (well-)known limitation of the Monad class that we cannot make an instance for Set. Is there a satisfying generalization of Monad that permits this instance while still type-checking with -XRebindableSyntax's do notation?
07:58:10 <carter> haasn: thereâ€™s some papers about that.
07:58:30 <carter> I think some of them use constraint kinds
07:59:01 <Zemyla> haasn: Use a Codensity wrapper around Set, or a Coyoneda wrapper.
07:59:07 <haasn> Now obviously I can throw a hammer at it and define class CMonad m where type CMonadC m :: * -> Constraint; return :: CMonadC m a => a -> m a; (>>=) :: CMonadC m b => m a -> (a -> m b) -> m b, but that's not satisfying
07:59:24 <haasn> Zemyla: oh, codensity is a good approach. I like it
07:59:32 <ski> haasn : perhaps `rmonad'
07:59:58 <haasn> I was also wondering if I could somehow parametrize the -> to a more specific arrow/cat/profunctor `p` but that doesn't seem like it would make do notation type check
08:00:17 <haasn> in particular something like p a (m b) -> p (m a) (m b)
08:00:32 <ski> kleisli extension
08:01:01 <haasn> yeah RMonad is the exact thing I was thinking about, but I think I prefer codensity - it doesn't even require RebindableSyntax!
08:01:46 <Zemyla> The Coyoneda wrapper uses Set.cartesianProduct for liftA2 and Set.disjointSum for (<|>) and mappend, and then use the fact that Coyoneda Set is Foldable to say (>>=) = flip foldMap.
08:03:01 <Zemyla> Though it's probably more efficient at that point to use a Seq and occasionally sort it and strip its unique values.
08:03:56 <Zemyla> @let newtype Confused f a = Confused { runConfused :: forall r. (forall x. ((a -> r) -> x) -> f x) -> f r }
08:03:58 <lambdabot>  Defined.
08:04:19 <mniip> haasn, for Set to be a monad you'd need to define the category of monotonous functions
08:04:45 <Zemyla> @let instance Functor (Confused f) where fmap f (Confused m) = Confused $ \y -> m $ \x -> y $ \c -> x $ c . f
08:04:47 <lambdabot>  Defined.
08:04:53 <mniip> also is Set even an endofunctor there
08:05:15 <mniip> I suppose for some Ord (Set a) it is
08:05:39 <ski> Smyth, Hoare, Egli-Milner partial orders
08:06:25 <Zemyla> @let instance Applicative (Confused f) where { pure a = Confused $ \y -> y ($ a); liftA2 f (Confused ma) (Confused mb) = Confused $ \y -> mb $ \xb -> ma $ \xa -> y $ \c -> xa $ \a -> xb $ c . f a }
08:06:26 <lambdabot>  Defined.
08:06:47 <mniip> ooh liftA2 is a class method now?
08:06:54 <mniip> what year is this
08:07:15 <Zemyla> @let liftConfused :: Applicative f => f a -> Confused f a; liftConfused u = Confused $ \y -> y id <*> u
08:07:17 <lambdabot>  Defined.
08:07:27 <dminuoso> mniip: Yes, and to top it off: {-# MINIMAL pure, ((<*>) | liftA2) #-}
08:07:40 <mniip> next we should get unit and (**)
08:07:45 <dminuoso> Agreed. :)
08:08:24 <Zemyla> @let lowerConfused :: Applicative f => Confused f a -> f a; lowerConfused (Confused m) = m $ \x -> pure (x id)
08:08:26 <lambdabot>  Defined.
08:09:02 <ski> hm, interesting that you need `Applicative' in both directions (though different parts of it)
08:09:53 <Zemyla> @let newConfusing :: Applicative f => LensLike (Confused f) s t a b -> LensLike f s t a b; newConfusing tr = \f -> lowerConfused . tr (liftConfused . f)
08:09:55 <lambdabot>  Defined.
08:10:05 * ski suddenly sees how `Confused' is related to `RightAssoc' ..
08:10:10 <mniip> > lowerConfused (liftA2 (,) (liftConfused [1, 2, 3]) (liftConfused [4, 5, 6]))
08:10:12 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
08:14:07 <mniip> > lowerConfused (liftA2 (,) (liftConfused []) (liftConfused [1..]))
08:14:10 <lambdabot>  []
08:14:11 <mniip> > lowerConfused (liftA2 (,) (liftConfused [1..]) (liftConfused []))
08:14:17 <lambdabot>  mueval-core: Time limit exceeded
08:31:18 <haasn> Zemyla: not sure if Codensity helps, it seems like the `forall b.` part of `forall b. (a -> m b) -> m b` ruins it
08:32:05 <haasn> to put it more concretely: I can't write `liftSet :: Ord a => Set a -> Codensity Set a`
08:33:44 <haasn> although I could do it if `Set a` contained a dictionary for Ord a
08:39:46 <Zemyla> @let newtype SetM a = SetM { runSetM :: forall r. Ord r => (a -> Set r) -> Set r }
08:39:48 <lambdabot>  .L.hs:220:49: error:
08:39:48 <lambdabot>      Not in scope: type constructor or class â€˜Setâ€™
08:39:48 <lambdabot>      Perhaps you meant one of these:
08:40:11 <Zemyla> @let newtype SetM a = SetM { runSetM :: forall r. Ord r => (a -> S.Set r) -> S.Set r }
08:40:12 <lambdabot>  Defined.
08:42:03 <Zemyla> It has the obvious instances.
08:42:46 <haasn> Oh, I see what you're getting at now
08:43:56 <Zemyla> @let newtype SetMT m a = SetMT { runSetMT :: forall r. Ord r => (a -> m (S.Set r)) -> m (S.Set r) }
08:43:57 <lambdabot>  Defined.
08:44:15 <mniip> ski, so hmm
08:44:25 <mniip> forall is like a functor from [Rel, Rel] to Rel
08:44:26 <mniip> but not quite
08:44:35 <Zemyla> @let instance MonadTrans SetMT where lift m = SetMT ((>>=) m)
08:44:37 <lambdabot>  Defined.
08:45:21 <mniip> I mean on a first approximation we could define 'forall A. T A'  (with T : Set -> Set) to be  Pi_A T A
08:46:12 <Zemyla> @let liftSetMT :: Applicative m => S.Set a -> SetMT m a; liftSetMT s = SetM $ \c -> fmap S.unions $ foldr (liftA2 (:) . c) (pure []) s
08:46:13 <lambdabot>  .L.hs:234:5: error:
08:46:13 <lambdabot>      â€¢ Couldn't match expected type â€˜SetMT m aâ€™
08:46:14 <lambdabot>                    with actual type â€˜SetM aâ€™
08:46:51 <mniip> then consider the case where T upgrades to Rel -> Rel
08:46:53 <Zemyla> @let liftSetMT :: Applicative m => S.Set a -> SetMT m a; liftSetMT s = SetMT $ \c -> fmap S.unions $ foldr (liftA2 (:) . c) (pure []) s
08:46:55 <lambdabot>  Defined.
08:47:11 <mniip> and then with two such T and a natural transformation between them:  alpha : T ---> T'
08:47:37 <akr> Hi there, is there a way to get a list of all value of an Enum polymorphically?
08:47:42 <akr> @hayoo Enum a => [a]
08:47:42 <lambdabot> Unknown command, try @list
08:47:49 <mniip> we could define a relation 'forall A. alpha A' in Rel(Pi_A T A, Pi_A T' A)
08:48:17 <mniip> problem is,  'forall A. id_T A' is not  id in Rel(Pi_A T A, Pi_A T A)
08:48:21 <mniip> Pi_A T A  is too large
08:48:55 <mniip> I suspect if we used an appropriate subset of  Pi_A TA  instead, "forall" would be a functor
08:49:02 <mniip> [Rel, Rel] -> Rel
08:49:45 <erisco> akr, no, only if it is also Bounded
08:50:05 <mniip> Rel is actually interesting in that Rel^op = Rel
08:50:34 <akr> erisco: ah, I see. Thanks!
08:50:37 <mniip> so a functor Rel -> Rel has the power analogous to that of a profunctor Set^op x Set -> Set
08:51:02 <erisco> if pred/succ were total functions, we could
08:55:13 --- mode: glguy set +v safinaskar
08:55:16 --- mode: glguy set -v safinaskar
08:55:44 <safinaskar> hi
08:55:55 <safinaskar> does compiler actually counts count of spaces? i. e. does validity of program depend on how many spaces i used in indentation?'
08:56:04 <erisco> the order of these events is surprising
08:56:20 <Rembane> safinaskar: Yes! 
08:56:24 <f-a> safinaskar: identation level matters
08:56:25 <geekosaur> the language is indentation-sensitive, yes
08:56:53 <erisco> you make it sound dumb when you say it like that
08:57:01 <Zemyla> I wish Enum had total variants of pred and succ.
08:57:17 <geekosaur> and it has a fixed notionof what tabs are, so if your editor disagrees with it you can get unexpected syntax errors; safest si to tell your editor to expand tabs
08:57:57 <safinaskar> Rembane: f-a: geekosaur: ok, thanks
08:58:08 <mniip> until recently I've never used alignment and only indentation
08:58:14 <f-a> safinaskar: are you following a particular guide?
08:58:19 <mniip> for which hard tabs work fine
08:58:42 <safinaskar> f-a: no
08:58:53 <safinaskar> f-a: i already read a log time ago "learn you a haskell"
08:59:03 <safinaskar> f-a: and i understand everything in this book
08:59:06 <f-a> I see
08:59:14 <safinaskar> f-a: including very dark matters, say, type kinds
09:00:08 <erisco> for great good
09:00:09 <safinaskar> f-a: moreover, i think i understand haskell type system more that anybody of you. say, i understand that haskell type system is pure type system and "*" and "Constraint" are "sorts" in pure type system terminology
09:00:23 <cppxor2arr> o_O
09:00:29 <safinaskar> but until today i didn't know how indentation works
09:00:36 <safinaskar> i simply used braces everywhere
09:01:20 <f-a> I thought * was a universe, silly me
09:01:36 <erisco> *shrug* you can take that title if you want it
09:01:48 <Zemyla> I mean, succM e = unsafePerformIO $ do { () <- evaluate (rnf e); catch (let s = succ e in evaluate (rnf s) >>= (\() -> return (Just s))) (\x -> const Nothing (x :: SomeException) }
09:01:58 <Zemyla> That sort of works.
09:03:33 * hackage easyrender 0.1.1.4 - User-friendly creation of EPS, PostScript, and PDF files  http://hackage.haskell.org/package/easyrender-0.1.1.4 (PeterSelinger)
09:05:16 <mniip> safinaskar, what about nonparametric kinds?
09:06:26 <safinaskar> mniip: well, i don't know them :)
09:06:34 <safinaskar> mniip: but let me google a little :)
09:07:21 <geekosaur> .oO { brain the size of a planetâ€¦ }
09:07:46 <safinaskar> mniip: well, maybe you mean kinds of types such as Int# ? (well, i didn't use google)
09:08:22 <mniip> no
09:08:39 <mniip> the difference between  'f :: a -> a'
09:08:47 <mniip> and  'type family F :: k -> k'
09:09:58 <safinaskar> mniip: well, okey, i don't know this :)
09:11:11 <erisco> I guess mniip is the new reigning champion
09:11:27 --- mode: glguy set +v govno
09:12:54 <safinaskar> mniip: look here https://paste.gg/p/anonymous/1bcbebc4edba4eb9931ff8cc296eaf6d
09:14:01 <mniip> are you showing off?
09:14:20 <safinaskar> mniip: yes, i don't know what is nonparametric kinds.    but i wrote pure type system implementation in haskell.   also, i know that type system of haskell itself is somewhat pure type system.  thus i can write little interpreter of haskell in haskell with all its type system power, and you cannot. ahaha. look at my code
09:15:40 <erisco> and in comes the haymaker!
09:16:17 <safinaskar> bye
09:16:50 <mniip> I can actually run my programs and you cannot, ahahaha
09:16:55 <mniip> look at my code https://gist.github.com/mniip/7e5fda039b81553c8796bb2c15faf8ed
09:17:43 <haasn> Zemyla: cool, I got it working - and it cut down the size of my decision tree considerably. (I was attempting to migrate from using [] as a "nondeterminism" monad to Set)
09:18:53 <haasn> (actually Map a Probability rather than Set a, but the same principle)
09:19:43 <erisco> honestly never in my life have I witnessed a code measuring contest...
09:21:11 <erisco> I thought everyone who wrote code felt it was a bit shit
09:21:24 <f-a> 9> OPTIONS_GHC -fno-warn-tabs
09:21:47 <__monty__> erisco: I guess golfing is a code measuring contest : >
09:21:58 <erisco> haha
09:23:56 <mniip> erisco, shrug, he started it
09:24:13 <monochrom> I don't understand why a simple tab question turns into a type system contest.
09:24:18 <cppxor2arr> i've recently seen the "Seed" language answer for a "Hello World!" code golf challenge on SE
09:24:21 <cppxor2arr> insane
09:26:24 <monochrom> OK found the right word.  s/type system contest/bragging contest/
09:26:53 <erisco> cppxor2arr, wow
09:27:08 <erisco> that's bringing code golf to another level
09:28:54 <erisco> so now we're procedurally generating code golf solutions, lol
09:31:09 <erisco> also this language is amazing https://esolangs.org/wiki/Mornington_Crescent
09:31:20 <cppxor2arr> yeah :P i was amused
09:31:44 <cppxor2arr> apparently there's metagolfing
09:37:07 --- mode: glguy set +v fen
09:43:03 <__monty__> Is this C-- the same C-- as GHC uses? https://www.cs.tufts.edu/~nr/c--/index.html
09:43:12 <__monty__> I assume it's not.
09:44:59 <geekosaur> take alook at the first paper on https://www.cs.tufts.edu/~nr/c--/papers.html
09:45:22 <__monty__> : o
09:46:56 <fen> seems to be the brainchild of spj, so probably kinda haskelly
09:47:37 <geekosaur> that said, ghc evovled cmm in its own direction and eventually standalone c-- was discontinued; and it sounds like Tufts has taken the original further
09:48:42 <monochrom> One of them ought to rename themselves to Cflatflat >:)
09:48:42 <fen> wonder how much of that made it into our systemf
09:49:32 <fen> let bound concurrent garbage collection with machine level types
09:49:45 <fen> case*
09:50:08 <fen> so, how can this be written as a class? https://bpaste.net/show/9269a664c0e2
09:51:27 <fen> like, instead of those dictionaries, how to get zipper as a type synonym to a loop constraint in both directions?
10:22:17 <ski> mniip : i'm not following that `Pi_A T A' means
10:24:34 * hackage open-adt 1.0 - Open algebraic data types.  http://hackage.haskell.org/package/open-adt-1.0 (Woehr)
10:29:03 * hackage open-adt-tutorial 1.0 - Open algebraic data type examples.  http://hackage.haskell.org/package/open-adt-tutorial-1.0 (Woehr)
10:29:44 --- mode: glguy set +v mreh16
10:32:02 <mreh> is it possible to derive SafeCopy for a newtype? I'm getting strange errors
10:33:54 <mroman> alright. I have something that should be lazy... but for some reason is not lazy.
10:34:17 <mroman> It produces a infinite list and I do essentially take 10 xs but it doesn't stop.
10:34:25 <mroman> so something makes this strict.
10:34:51 <mroman> how do I debug this?
10:36:56 <geekosaur> mreh, GeneralizedNewtypeDeriving should always work, provided the type roles permit â€” but beware of having both it and DeriveAnyClass enabled (also see the DerivingStrategies extension)
10:38:43 <mreh> geekosaur, It's just a newtype wrapper round Integer
10:40:26 <lyxia> mreh: compile with -prof -fprof-auto, run with +RTS -xc, kill the program and see what it was in the middle of doing
10:41:05 <mreh> lyxia wrong person? :)
10:42:16 <mroman> well it's in the middle of computing an infinite list :D
10:42:22 <geekosaur> oh, I see, it has its own deriving mechanism. and if I read this right, yues, you may have issues
10:42:24 <lyxia> mroman: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-flag--xc
10:42:28 <lyxia> (sorry mreh!)
10:42:37 <geekosaur> because Int is a primitive
10:43:00 <MarcelineVQ> mnoonan: alternatively, if it's readably small, put it in a paste and people will tell you what looks wrong :>
10:43:22 <lyxia> too many similar-looking prefixes in this chan.
10:43:33 <geekosaur> so it's not so much newtypes that are a problem, as the Int which isn't versioned so the deriving stuff falls over
10:43:43 <MarcelineVQ> lyxia: you have to watch out for the m's, there's something weird about them.
10:43:53 <Solonarv> Int is an ordinary lifted type, Int# is the primitive </pedant>
10:44:13 <geekosaur> Solonarv, this is with respect to SafeCopy, not ghc prims
10:44:16 <mroman> hm. how do I install profiling packages for dependencies?
10:44:27 <geekosaur> "primitive" here means "not a versioned data item"
10:44:31 <mroman> > Perhaps you haven't installed the profiling libraries for package `digits-0.3.1'?
10:44:32 <Solonarv> oh, I see
10:44:33 <lambdabot>  <hint>:1:74: error: parse error on input â€˜-â€™
10:44:41 <geekosaur> http://hackage.haskell.org/package/safecopy-0.9.4.1/docs/Data-SafeCopy.html#t:SafeCopy
10:45:28 <mreh> geekosaur, ah interesting, it doesn't need to be versioned then probably
10:45:54 <mroman> https://pastebin.com/rNqsE1V0 <- this would be the relevant code, but not sure this is helpful.
10:46:20 <MarcelineVQ> lyxia: oh god, I did it too, and I was trying not to. sorry mnoonan :>
10:47:21 <infinisil> mroman: ghc option --enable-library-profiling
10:48:20 <mroman> that's apparentely an unrecognized flag.
10:48:40 <mroman> 8.0.1 I'm on
10:49:20 <lyxia> mroman: lines 11 and 12 don't look very lazy
10:49:54 <mroman> hm. speaking of it. laziness is dead for other functions as well.
10:50:34 <geekosaur> mroman, that flag is for cabal, not ghc. if you're using ghc directly, you get to manage e.g. profiled builds directly too
10:50:52 <mroman> yeah. head . map (succ) $ [1..] doesn't terminate anymore in my interpreter as well.
10:52:01 <mroman> lyxia: but it's a lazy state monad?
10:53:42 <mroman> but yes, in that snippet the function `f` itself doesn't terminate.
10:53:58 <mroman> (even if I use (take 10 ys) above it won't terminate)
10:56:08 <mroman> I don't think it has anything to do with get/put
10:56:52 <mroman> https://pastebin.com/c4jiaVWU <- this seems to not terminate as well.
10:57:07 --- mode: glguy set +v curca
10:57:48 <mroman> but it should.
10:58:00 <mroman> for as long as you don't access snd and trd of the state
10:59:01 <mroman> if you access the second or third element of the state then yes, this breaks laziness.
10:59:27 <mroman> or hm.
10:59:36 <mroman> so I guess something later on is accessing snd and trd of the state
11:00:10 <mroman> ok it's the put (st, ng, nv) stuff.
11:00:21 <mroman> ok so there's no way I can make this lazy then :(
11:00:37 <fen> class Constrainted (f :: k -> *) where type AddConstraint (q :: k -> Constraint) f :: k -> *
11:00:40 <fen> does that work?
11:00:47 <fen> (my ghci is down)
11:01:00 <curca> hey guys, how do you avoid passing to many arguments to complex functions? 
11:01:12 <curca> too many*
11:01:13 <mroman> but still... why would a put (st, ng, nv) break laziness if nobody access the ng/nv later on?
11:01:28 <koz_> curca: Make a record for the arguments and pass that?
11:01:54 <mroman> for as long as you don't access any variables within my language (which are stored in ng/nv) then the stack itself should be lazy
11:02:27 <curca> #koz but doesn't it require unpacking the structure like "Constructor {prop1=val1, prop2=val2...}">
11:06:16 <koz_> curca: If all you're doing is grabbing arguments, you can just use the accessor functions.
11:06:43 <koz_> I admit it's not a perfect solution by any means, but absent more context, I can't really give more advice than that.
11:07:05 <curca> koz_: I need to change the values, it is a problem that I can map easier in imperative way
11:07:56 <koz_> curca: It would help if you explained to us what you're trying to do. This is extremely vague and as a result, we can't give you any sensible advice.
11:08:14 <koz_> You've gone from 'multiple function arguments' to 'mutable state' in the course of less than five minutes.
11:09:36 <curca> koz_: The professor said to solve the "hanoi tower" problem using a random algorithm with a couple of optimisations like freezing the biggest disc that is placed right and tracking if the state didn't repeat before
11:10:13 <curca> I tried to use haskell, but it requires to pass the randomizer token and other state around and the code gets too messy
11:10:24 <curca> so I ended up doing it in JS
11:10:58 <koz_> curca: Have you perhaps considered that an algorithm conceptualized, and described, imperatively might need re-thinking for a functional writeup?
11:11:33 <mroman> hm. nope.
11:11:36 <mroman> I call this a ghc bug :D
11:11:48 <Solonarv> Haskell's a pretty decent imperative language, tbh
11:11:58 <koz_> Additionally, the moment I hear 'passing state around', I immediately think 'State monad maybe'
11:12:01 <koz_> ?
11:12:36 <koz_> Solonarv: Yeah, it is, but I wouldn't reach for mutable references and ST immediately either.
11:12:40 <Solonarv> or, if it's specifically a random generator, MonadRandom (or whatever it's called)
11:12:50 <koz_> Yup, MonadRandom it is.
11:12:53 <Solonarv> koz_: a plain old State monad can look pretty imperative too
11:12:54 <curca> koz_: can I do a loop inside state monad and change some "global state" there?
11:13:12 <Solonarv> it isn't "global", but yes you can
11:13:20 <koz_> The whole point of the State monad is to have state that changes.
11:13:47 <koz_> Instead of having it global, you handle passing it around without having to constantly pass extra args.
11:13:48 <curca> ok, I will look into state monad then. Thanks ;)
11:13:50 <mroman> https://pastebin.com/cwa8ghR8 <- there's no reason why map' can't be lazy.
11:15:57 <mroman> unless this has something to do with IO?
11:16:08 <mroman> runStack'' is IO a afterall
11:19:45 <geekosaur> IO's (>>=) is strict, yes
11:19:54 <mroman> well...
11:19:59 <mroman> Why didn't you tell me this :D
11:20:10 <mroman> now I broke laziness in my language by introducing I/O.
11:20:22 <geekosaur> becaue I do not have your codebase memorized and did not know IO was involved untl you said that
11:20:28 <mroman> (I'm kidding)
11:20:39 <mroman> (not about the breaking laziness part though)
11:20:57 <geekosaur> there is unsafeInterleaveIO to simulate laziness, but I'm ot sure it helps you here
11:21:09 <geekosaur> and well, it's unsafe* for a reason\
11:22:11 <Zemyla> How lazy is lazy ST? Like, on a scale from strict ST to unsafeInterleaveST.
11:22:51 <mroman> it used to be lazy enough.
11:23:19 <mroman> I could do take 10 . map (succ) $ [1..] for as long as you didn't also access variables in my language.
11:24:23 <mroman> Unfortunate. But not a complete dealbreaker I guess...
11:24:32 <mroman> sooner or later you have to have a take n somewhere anyway...
11:24:50 <mroman> but it's not good for code reuse :(
11:25:23 <mroman> but I'll try unsafeInterleaveIO
11:28:36 <mroman> nah. still doesn't work with unsafeInterleaveIO
11:29:37 <mroman> hm. do I need to put unsafeInterleaveIO before every recursive call as well?
11:29:41 <mroman> or just the call to runStack''?
11:30:48 <mroman> neither works anyway.
11:33:30 <mroman> wait...
11:34:13 <mroman> https://pastebin.com/V9QQ6qZq <- this works.
11:37:24 <mroman> https://pastebin.com/dYB2RhaR <- but this doesn't.
11:37:54 <mroman> even though it's used as (mst, _, _) <- map'
11:37:59 <mroman> so the ng', nv' are never even used
11:38:06 <mroman> then why is it not lazy?
11:43:36 <mroman> at least it works read-only.
11:43:38 <Zemyla> mroman: You need to go ~(mst, _, _) <- map.
11:43:45 <Zemyla> The tilde means lazy.
11:44:32 <mroman> oh. and ~ at the other matches as well
11:45:17 <mroman> awesome!
11:45:19 <mroman> Thanks a lot.
11:45:33 <mroman> Now old code relying on laziness can keep on working.
11:47:03 <mroman> is there a way to "abort" evaluation when it's not needed?
11:47:38 <mroman> take 10 . map (\i -> i + 1) $ [1..] now works again
11:48:09 <fen> when will 8.6.1 be the version of GHC released with the haskell platform?
11:48:28 <mroman> but { take 10 . map (\i -> i + 1) $ [1..]; print v; } doesn't because the "print v" accesses the third element of that 3-tuple.
11:48:54 <mroman> even though v is never set in the map function
11:52:37 <fen> the haskell platform gives a .msi installer which unpacks everything into the right directories, there are ghc binaries, but its not clear how to use these with a previous builds installed libraries etc.
11:53:48 <fen> having uninstalled everything (maybe not nesacary, and time consuming rebuilding of libraries will follow) is there a way to use e.g. cabal to install everything? like download cabal first and then use it to install ghc
11:57:31 <mroman> if you install a new ghc version you _usually_ have to re-download every cabal package anyway.
11:58:54 <mroman> packages on windows are installed into C:\Program Files\Haskell Platform\<version>\lib
12:29:36 <mroman> it's weird that this has exponential slow down though.
12:32:11 <nsxt> I have a vocabulary problem that prevents me from searching for solutions... At heart, I'm looking to transpile Haskell. So if I've an expression like `mul 0.5 $ fmap (mlp (on 50 2500 $ tri 0.2) 0.3) $ pink`, how do I go about the translation process? Do I generate an AST and go from there?
12:33:05 <mroman> transpile from Haskell to something?
12:33:19 <mroman> but in either case... AST is pretty much always the way to go
12:33:26 <Rembane> Template Haskell?
12:33:30 <nsxt> Yes, in thise case, to Csound, where functions like "tri" and "pink" have specific meaning and should be preserved.
12:34:17 <mroman> and if you're using fmap... you might need some kind of type inference to select the right versions of functions as well...
12:34:59 <philippD> I'm currently trying some things in cloud-haskell but I can't get it to work: Whenever I call `spawnLink` with the id `nid <- processNodeId <$> getSelfPid` I recieve an exception: `ProcessLinkException pid://127.0.0.1:10501:0:9 DiedUnknownId` am I using the API wrong? https://gist.github.com/chisui/bfe1cf05707f1c8f16f43493d314fe63
12:37:23 <nsxt> @mroman Are there any libraries that would be particularly suited to this?
12:37:23 <lambdabot> Unknown command, try @list
12:37:32 <nsxt> mroman: Are there any libraries that would be particularly suited to this?
12:37:57 <mroman> no idea.
12:38:13 <mroman> Why are you transpiling from Haskell anyway?
12:39:47 <nsxt> Because writing straight Csound code would be an exercise in masochism. :(
12:40:03 <nsxt> And I wanted to give myself a project to learn Haskell.
12:41:31 <Solonarv> That doesn't mean /transpiling/ is the best way to go about it. You're probably better off building a DSL and generating the Csound code.
12:42:06 <mniip> ski, the set-theoretical product of a family of sets
12:43:57 <koala_man> is there a machine readable list of stackage lts releases? I want to automatically test my project against each of them
12:45:10 <Solonarv> that sounds like it would exist
12:45:56 <koz_> koala_man: Have you tried checking the Stackage Github repo?
12:48:49 <Solonarv> https://github.com/commercialhaskell/lts-haskell -- this repo has all the snapshots
12:48:54 <Solonarv> koala_man: ^
12:49:26 <koala_man> nice
12:50:17 <mroman> nsxt: then either a DSL in Haskell is better or a DSL based on something that is easier to transpile
12:50:23 <mroman> for example S-Expressions.
12:50:30 <koala_man> hmm, large files and no easy to tell which one uses which version
12:51:18 <Solonarv> huh? 'packages.<pkgname>.version' gives you the version of that package
12:51:19 --- mode: glguy set +v RA_
12:53:43 <koala_man> Solonarv: I'm not sure what you mean. I'm mostly trying to test against various ghc versions, and I don't know how to tell that the latest lts for GHC 8.4.3 is 12.14
12:54:33 <Solonarv> IMO there are few enough GHC versions that you can just input that manually
12:54:55 <Solonarv> note also the "Latest LTS per GHC version" section on https://www.stackage.org/
12:55:21 <koala_man> I don't disagree, but I'd rather not have to google the latest one every time I run the tests
12:55:31 <RA_> I just started RWH. Anyone else who found chapter 8 on efficient file processing extremely dry?
12:55:32 <koala_man> yes, that's the list I'd like in a machine readable format
12:57:03 <koala_man> meh, I'm already testing against a bunch of distros' ghc versions, that should be good enough. I just need one with latest, and I can use nightly for that
12:57:27 <Solonarv> well yeah, the very newest GHC usually isn't in any LTS snapshots
13:00:09 <Solonarv> I suppose you could write a small script that trawls commercialhaskell/lts-haskell and checks the 'system-info.ghc-version' key (or trawl the nightly repo instead)
13:01:06 <koala_man> yep. I guess automatic updates are exactly what stack is intended to avoid
13:01:42 <mroman> nsxt: http://codepad.org/lpNxXN5s <- this is one of the quick ways.
13:01:54 <mreh> I guess ixset-typed is favoured over ixset now if the latter isn't in snapshots
13:01:55 <mroman> surely with some better knowledge about type system features you can lift a lot to the type system.
13:02:13 <Solonarv> I'm sure you can find guidance somewhere on testing your package with a variety of GHC versions
13:03:10 <mreh> I'm so not up to speed on the DataKinds extension.
13:03:48 <hpc> i forget a lot of the Text functions - what's a convenient way to do some simple string escaping?
13:03:56 <mroman> (and by implementing Num and fromIntegral etc. you can get rid of the `int`)
13:04:02 <hpc> i want " to \" and \ to \\
13:04:30 <mreh> convert it to JSON?
13:04:40 <Solonarv> 'Text.pack . show' :P
13:05:08 <hpc> nvm, found it
13:05:15 <hpc> it's the obviously named "replace"
13:05:32 <hpc> those are the only escapes i want to do, it's for another file format
13:06:58 <nsxt> mroman: Thanks. This looks like what I'd want to do. When you mentioned "DSL", I was thinking of a new "language", which isn't really what I want. I'd still like to be able to use Haskell syntax to generate the expressions, much like in the very first example (and in yours as well). Any resources you could point to where I can learn more about this?
13:07:14 <mroman> hpc: you could also use concatMap.
13:07:41 <Solonarv> EDSLs ("embedded domain-specific language") are a fairly common pattern in Haskell
13:08:43 <mroman> yep. google "haskell edsl" should get you some pointers.
13:08:57 <nsxt> Thank you mroman, Solonarv. Really appreciate the help here.
13:09:08 <Solonarv> hpc: Text.concatMap (\case '\\' -> "\\\\"; '"' -> "\""; c -> Text.singleton c)
13:09:23 <Solonarv> (using LambdaCase and OverloadedStrings)
13:09:37 <Solonarv> That'll do it in one pass
13:09:39 <mreh> multiple passes would be a doozy
13:09:47 <mreh> you'd have to not reescape stuff
13:09:57 <__monty__> Solonarv: "\\\""
13:10:07 <Solonarv> oh, oops
13:10:20 <hpc> oh that's much better
13:10:21 <Solonarv> well, you get the idea
13:20:59 <koz_> Does anyone here know of any papers that talk about the benefits of delayed array representations, similar to the ones available for Repa and massiv?
14:23:05 <safinaskar> hi again :)
14:23:41 <safinaskar> how to create some datatype such way, that i cannot directly call its type constructors in the rest of program?
14:23:52 <safinaskar> yes, i know i can put this type into separate file
14:23:57 <safinaskar> but i don't want this
14:24:09 <safinaskar> this is more handy when everything is in one file
14:24:56 <safinaskar> i don't want to create separate 3-lines file, which contents is just this: https://zerobin.net/?e87ef78703b8a6ca#C/V+PDvP6FhK6yVPUgd0LCnPoaBzWSvO21tHMl01S9A=
14:25:03 <safinaskar> (this was my actual file)
14:25:07 <safinaskar> so, what to do?
14:25:20 <safinaskar> maybe there is a way to write module inside of another module?
14:25:42 <safinaskar> i. e. there is a way put "module { .... }" block inside of another module block?
14:26:44 <geekosaur> no
14:27:57 <safinaskar> geekosaur: this is sad
14:28:10 <safinaskar> so, i need to create this 5-lines file every time?
14:28:16 <safinaskar> *files
14:28:19 <geekosaur> yes
14:29:04 <geekosaur> in theory that could be changed, but nwo you get to figure out how the compiler maps a module name to a source file name
14:29:14 <safinaskar> i think that *ALL* languages should allow nested modules. exactly for such situation. absolutely all. c++, js, python, haskell etc etc
14:29:14 <geekosaur> there's already some oddities there
14:29:31 <safinaskar> and it seems c++ has this feature, but i need to check more
14:30:04 <safinaskar> geekosaur: i just tested, module names need to be equal to file names
14:30:12 <Solonarv> C++ doesn't have modules at all, except for very recently
14:30:18 <safinaskar> geekosaur: at least when all files are in same directory and compiled using "ghc *.hs"
14:30:22 <geekosaur> C doesn't, iirc standard C doesn;t even allow nested functions
14:30:27 <tdammers> c++ doesn't really have modules, but it does support nested namespaces
14:30:28 <geekosaur> (gcc does as an extension, then there's Apple's blocks and such)
14:30:43 <safinaskar> Solonarv: in c++ i can write          namespace { ..... namespace { ..... } .... } or something like that
14:30:57 <safinaskar> Solonarv: but i don't know exact syntax
14:31:03 <geekosaur> safinaskar, the oddity is that sometimes it'll accept Foo.Bar.hs for Foo/Bar.hs. and sometimes not. and bild tools arent; guaranted to agree with it
14:31:08 <Solonarv> True, namespaces aren't modules though
14:31:42 <safinaskar> Solonarv: i mean that i want nested namespace (i am talking about c++) to export *SOME* of its functions to outer namespace and hide others. i don't remember how to do this, but i think there is a way
14:32:01 <Solonarv> side note: you'll usually use 'ghc --make Main.hs', not 'ghc *.hs'
14:32:19 <tdammers> or just ghc Main.hs
14:32:33 * hackage Cabal 2.4.1.0 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-2.4.1.0 (MikhailGlushenkov)
14:32:54 <tdammers> safinaskar: C++ doesn't really "export"; best you can do is put things in the .hxx or not
14:33:29 <geekosaur> Solonarv, --make has been default since ghc7.0.1
14:33:33 * hackage cabal-install 2.4.1.0 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-2.4.1.0 (MikhailGlushenkov)
14:33:52 <Solonarv> oh, cool
14:34:16 <Solonarv> I rarely invoke GHC directly, so I didn't know
14:42:31 <c_wraith> safinaskar: if you were curious on the parser thing:  Here's an example of using an ambiguous, left-recursive grammar with the Earley library - https://gist.github.com/chowells79/44b30ad6400c664a9cfa15b835fb0729
14:52:39 <safinaskar> c_wraith: wow, cool. it seems this parser somehow perfectly handles left-recursive grammars
14:54:33 <c_wraith> safinaskar: the algorithm it uses actually prefers left-recursive grammars.  iirc, the Earley algorithm works in O(n) time if the input is in the LALR parsing class, which prefers left-recursion
14:59:16 <safinaskar> c_wraith: do you know some parser library which can do both parsing and pretty printing?
14:59:52 <safinaskar> c_wraith: i want some lib which can parse and pretty print without need to separately describe parser and printer
14:59:54 <c_wraith> there are several.  The only one I can remember the name of offhand is https://hackage.haskell.org/package/boomerang 
15:00:01 <c_wraith> But I know there are others
15:00:13 <c_wraith> That one just wins the clever name category
15:02:00 <hpc> ooh
15:02:20 <hpc> i've been wanting something like that for a couple of years now, but never enough to go seriously looking for it
15:02:39 <geekosaur> "invertible parser" is IIRC the usual name for such
15:03:13 <Solonarv> @hackage waargonaut - tangentially relevant, an invertible JSON library
15:03:13 <lambdabot> http://hackage.haskell.org/package/waargonaut - tangentially relevant, an invertible JSON library
15:10:33 <safinaskar> c_wraith: thanks
15:11:09 <safinaskar> bye
15:25:11 <safinaskar> haha
15:25:23 <safinaskar> in fact you CAN define multiple modules in one file
15:25:28 <safinaskar> look here: http://blog.ezyang.com/2016/10/try-backpack-ghc-backpack/
15:25:48 <safinaskar> geekosaur: ping
15:26:28 <crestfallen> hi a hopefully not too long question . I was unable to understand the webpage on monomorphisms suggested here. but I got bb on line 11 to work using show in the one parameter. so is show the only argument that makes sense in parameter x ? https://paste.ee/p/5Dgnt 
15:27:48 <crestfallen> I got it to work based on reading the error messages which is rare.
15:27:58 <infinisil> Isn't an invertible parser just a serialization library with a custom serialization format?
15:28:12 <Tuplanolla> Monomorphisms and monomorphic types are completely different things, crestfallen.
15:29:16 <crestfallen> Tuplanolla: lines 5-7 were posts from a member here. I don't quite get that but included them.
15:31:00 <Solonarv> infinisil: ideally, a invertible parser can also preserve comments, whitespace, key ordering and the like
15:31:18 <crestfallen> also the signature on line 9 perplexes, I assume t can be other than show. as for what monomophism vs monomorphic really no clue Tuplanolla
15:31:35 <Solonarv> the idea is that 'encode . decode = id' as well, not just 'decode . encode'
15:31:38 <crestfallen> 't'
15:32:12 <Tuplanolla> A monomorphism is a generalization of an injective function to categories, while a monomorphic type is a type that is not polymorphic, crestfallen.
15:32:47 <Tuplanolla> You can forget the former in this context.
15:32:59 <crestfallen> ok thanks one moment
15:35:20 <crestfallen> alright t is always going to be show in that case Tuplanolla
15:37:45 <MarcelineVQ> Tuplanolla: monomorphism is being mentioned here because part of the original issue was running into the DMR I believe
15:42:33 <crestfallen> so is it safe to say that 't' must be show in the function lines 9-11 ?
15:42:37 <MarcelineVQ> crestfallen: it's incorrect to say t is show, t is a type variable, type variables stand in for types, so t is a type. show is a function, it has a type but it is not a type.
15:43:01 <MarcelineVQ> further x isn't used on line 11, it can be anything at all due to that, so its type which is t can be any type.
15:45:06 <crestfallen> It was happenstance that I used show. I thought that the argument [(Just "Yo"), Nothing, (Just "Hey")] was to be the argument, so I was getting print errors MarcelineVQ
15:47:10 <crestfallen> ..getting print errors when using above argument. still confused since if monomorphic means one type in this case, and anything can be put there...not sure what is going on.
15:47:58 <MarcelineVQ> bb as you've written it takes two arguments and ignores the first
15:48:23 <crestfallen> one moment I don't think that was my experience
15:49:00 <MarcelineVQ> you may have intended to write   bb :: (Functor f1, Functor f) => f (f1 [Char]) -> f (f1 [Char]); bb x = (<$>) (fmap (++ " !")) x
15:49:36 <crestfallen> note lines 16-17
15:49:52 <crestfallen> though with differing signature
15:50:28 <MarcelineVQ> yes?
15:50:42 * ski idly wonders whether crestfallen is attempting to understand DMR
15:51:25 <crestfallen> frankly I can't remember how I ran into this problem. I was pretty flustered
15:56:33 * hackage serverless-haskell 0.8.4 - Deploying Haskell code onto AWS Lambda using Serverless  http://hackage.haskell.org/package/serverless-haskell-0.8.4 (AlexeyKotlyarov)
15:59:36 <crestfallen> MarcelineVQ: so are 9-11 incorrect as written? I thought this version at the very least illustrated DMR
16:03:24 <crestfallen> reposted :  MarcelineVQ: so are 9-11 incorrect as written? I thought this version at the very least illustrated DMR
16:04:24 <ski> crestfallen : those lines are confusing (and perhaps confused ?), at least
16:04:27 <MarcelineVQ> It depends on what you intended, bb is not a more general version of cc if that's what you wanted. These do not seem to demonstrate the DMR, it only occurs when you don't have a type signature.
16:05:22 --- mode: glguy set +v davidsixx
16:05:33 <davidsixx> hey everyone
16:05:47 <koz_> davidsixx: HihI!
16:05:59 <ski> DMR can be side-stepped by (a) having an explicit type signature; (b) having at least one parameter to the left of `=' (requires that you're defining a function); (c) disabling DMR, by `{-# NoMonomorphismRestriction #-} e.g.
16:06:19 * hackage haskell-igraph 0.7.1 - Haskell interface of the igraph library.  http://hackage.haskell.org/package/haskell-igraph-0.7.1 (kaizhang)
16:06:27 <ski> then there's the (separate) issue of why DMR was introduced in the first place
16:07:11 <Rembane> Why was it introduced in the first place?
16:07:13 <MarcelineVQ> if your question is, "why does bb x = (<$>) (fmap (++ " !"))  not trigger the DMR when bb = (<$>) (fmap (++ " !")) does" I don't know. But ski's (b) above seems to cover that case.
16:07:19 <koz_> ski: DMR? Dreaded Monomorphism Restriction?
16:07:20 <crestfallen> thanks MarcelineVQ ski    ... working
16:08:05 <ski> and also in which situations DMR applies : it applies when (a) there's no type signature; and (b) there's no explicit parameters to the left of `='; and of course (c) DMR hasn't been disabled
16:08:11 <ski> koz_ : yep :)
16:08:31 <koz_> ski: It took me a while.
16:08:50 <Solonarv> yeah, same. The 'D' threw me for a loop.
16:09:05 <ski> to add to that, it only applies (d) where the inferred type would have (usually type class) constraints
16:09:26 <ski> e.g. consider
16:10:16 <ski>   primes = sieve [2 ..]
16:10:19 <ski>     where
16:10:20 <ski>     sieve (p:ns) = p : sieve [n | n <- ns,n `mod` p /= 0]
16:11:01 <ski> > let primes = sieve [2 ..] where sieve (p:ns) = p : sieve [n | n <- ns,n `mod` p /= 0] in take 25 primes  -- `primes' is a list of all (infinitely many) prime numbers
16:11:03 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
16:12:02 <crestfallen> MarcelineVQ: ski   thanks a lot . you know I'm just going to forget for now.. particularly since its something that can be disable.
16:12:03 <crestfallen> d
16:12:25 <MarcelineVQ> The lesson here is to give things type signatures
16:12:32 <ski> anyway, in the (call-)by-need, aka lazy evaluation, implementation strategy for the non-strict semantics of Haskell, you basically get sharing of the result of a (sub)computation, by giving it a name (also, function arguments are shared, even if we match on them, rather than naming them directly)
16:12:54 <MarcelineVQ> While one can disabled things to get around it, type signatures are good practise anyway and aid in development and error message clarity
16:13:41 <koz_> Yeah, type sigs can help a lot of weirdness, especially when you starting bringing in more interesting extensions.
16:13:45 <ski> so, one could then *expect* that `primes' here would be shared : that after i've computed the first twentyfive primes via the `take' above (assuming `primes' was a stand-alone, top-level definition in the module), then those wouldn't be recomputed again, next time we extract some primes from this list
16:14:17 <ski> however, this doesn't actually happen (in the usual implementation style of laziness, and of constraints)
16:14:25 <crestfallen> tbh I'm pretty shaky on this point. sorry ski I don't see why this is lazy eval.      I didn't write line 9 , I just type checked bb
16:15:16 <crestfallen> if show gets this implementation to work, but 't' is monomorphic, I don't really know what that means
16:17:09 <crestfallen> why is that function call by need / lazy  ?
16:18:44 <geekosaur> because every function is, in Haskell
16:19:18 <koz_> Should we import Data.Monoid or Data.Semigroup these days?
16:19:27 <ski> because since if `primes' would get the inferred type `Integral a => [a]' (which is what you'd get, if DMR was disabled), then the usual dictionary-passing implementation of class constraints would actually transform this into something like
16:19:32 <ski>   primes :: IntegralDict a -> [a]
16:19:40 <ski>   primes iDict = sieve (enumFrom (enumSuperIntegral iDict) (fromInteger iDict (2 :: Integer)))
16:19:44 <ski>     where
16:19:53 <ski>     sieve (p:ns) = p : sieve [n | n <- ns,(/=) (eqSuperOrd (ordSuperReal (realSuperIntegral iDict))) (mod iDict n p) 0]
16:20:34 <ski> the important point being that class constraints would be translated to explicit passing of class dictionaries, containing implementations of the class methods, for the particular type in question
16:21:34 <ski> and here we can see that with the usual sharing of results in lazy evaluation, `primes' would *not* share the already computed primes, because `primes' is (after this dictionary-passing translation) a *function* : each time it's called, it'd recompute the primes in question
16:22:40 <crestfallen> so earlier a member called this memoization
16:23:03 <ski> and it's hard to see how this could be avoided, since if we ask about `take 10 (primes :: [Integer])' one time, and `take 25 (primes :: [Int])' another time, then we're asking it to compute a list of primes of a different *type*, and this computation will depend on *different* operations (in the respective instances of `Integral', for `Integer' vs. `Int')
16:23:25 <ski> now, we know that, in some sense, we can expect the *same* integers in both cases. but the implementation doesn't know that
16:23:56 <ski> end result is : it's not reasonable to expect sharing of `primes' in such a situation
16:24:15 <ski> however, on the *surface* of the original code, it *looks* like we could expect sharing
16:25:36 <ski> so, it was deemed confusing (to newbies, at least) to have this behaviour, and therefore DMR was introduced, which automatically gets rid of the class constraints (by monomorphizing the definition *enough*, by applying some default selections of types, which hopefully will get rid of the jarring class constraints)
16:26:10 <ski> however, if (a) you're writing an explicit type signature, then presumably you already know anyway that you can't expect sharing, and so DMR doesn't apply in that case
16:26:47 <ski> and if (instead) (b) you have explicit arguments to the left of `=', then you presumably know that you have a function, so you can't expect sharing of results anyway, and so DMR doesn't apply in this case either
16:26:58 <ski> (and if (c) is disabled, obviously it doesn't apply)
16:27:36 <ski> so, DMR was introduced to attempt to remedy what was perceived as a potentially confusing situation (especially to newbies)
16:28:01 <ski> but .. DMR itself is unfortunately also confusing (e.g. to newbies)
16:28:03 <ski> so ..
16:29:05 <crestfallen> the prime example is actually more clear ski . ok writing .... 
16:29:11 <ski> <MarcelineVQ> The lesson here is to give things type signatures
16:29:14 <ski> <MarcelineVQ> While one can disabled things to get around it, type signatures are good practise anyway and aid in development and error message clarity
16:29:27 <ski> is probably good advice, yes
16:31:32 <crestfallen> so essentially its a technicality involving type inference when the type of the function is ambiguous and the function's meaning is guessed at by ghc/
16:31:33 * hackage superdoc 0.1.2.8 - Additional documentation markup and Unicode support  http://hackage.haskell.org/package/superdoc-0.1.2.8 (PeterSelinger)
16:31:48 <crestfallen> ghc/i
16:31:57 <ski> (some people seems to prefer writing as few signatures as possible. (e.g. John Hughes, iirc). i wonder if perhaps people who started in dynamic typing (say Scheme or something), and who got good at this, keeping types in their head, are among these people. i support *allowing* to omit signatures, to the extent possible. but from a development (locating errors) and documentation perspective, having signatures is really nice, for most people)
16:32:49 <crestfallen> thanks ski and MarcelineVQ . I gotta mosey thanks for all the great comments
16:33:19 <ski> crestfallen : yes. normally the ambiguity wouldn't matter (since we can infer overloading in Haskell). except that here it interferes with an expectation that what looks like it'd be shared will also be shared
16:34:42 <crestfallen> thanks pax
16:57:46 <cemerick> I'm looking at the example shown for MutliParamTypeClasses @ https://en.wikibooks.org/wiki/Haskell/Advanced_type_classes
16:58:38 <cemerick> it's true that the second example compiles, but no usage of it does. Where can I find simple useful examples of MultiParamTypeClasses?
16:58:56 <koz_> cemerick: vector (the library) has a good few.
16:59:06 <koz_> The way it defines the Vector and MVector classes for example.
16:59:20 <koz_> Another one is mtl, although those might be a bit trickier in some cases.
16:59:33 <koz_> (mtl also uses fundeps)
17:00:05 <mniip> hmm
17:00:24 <mniip> in wadler's relational treatment of parametricity
17:00:39 <mniip> is it actually possible to end up with a nondiagonal relation for a closed term
17:01:03 <cemerick> hum
17:01:14 <cemerick> that's a lot more in the deep end given what I'm attempting to express
17:01:30 <mniip> for a closed type*
17:01:34 <cemerick> will try FunctionalDependencies instead 
17:01:39 <koz_> cemerick: What _are_ you trying to express?
17:03:02 <cemerick> koz_: really nothing more than what I think the Collection example on the linked page is; a family of data structures that contain values of type A, with classes that define the relevant operations over instances that accept and return A, [A], and so on
17:03:30 <mniip> it seems that his (- x -), (- -> -) and (-*) operations take identity relations to identity relations
17:05:07 <mniip> which means that if (t, t') in T where T is the relation corresponding to 'forall a. F a'
17:05:48 <koz_> cemerick: That page gives an example of fundeps - fundeps are meant to deal with the ambiguities that arise from multi-param typeclasses.
17:05:55 <koz_> https://en.wikibooks.org/wiki/Haskell/Advanced_type_classes#Functional_dependencies
17:06:07 <mniip> then forall A, forall R : A <=> A,  (t_A, t'_A) in F R
17:06:23 <mniip> picking R the identity we get t_A = t'_A
17:07:06 <cemerick> koz_: yup, I was just trying the first thing listed, and then got confused when even the example didn't work 
17:08:07 <koz_> cemerick: Did you try the first example in the first section, or the second?
17:09:00 <cemerick> Second example. Amy usage of the class methods is ambiguous
17:09:09 <cemerick> koz_: ^
17:09:44 <koz_> cemerick: That's exactly the point - multi-parameter typeclasses can do this, because it's not necessarily clear which instance you want from the context.
17:10:04 <koz_> Since the compiler doesn't inherently know that you can determine the collection item type from the collection type.
17:10:16 <koz_> This is what functional dependencies are designed to address, as it can let us spell out this particular fact.
17:12:02 <koz_> s/it/they/
17:18:47 <cemerick> koz_: That's fine, I'll add in fundeps and see. Still surprised that even `insert [5] 6` is ambiguous, but oh well
17:19:13 <koz_> cemerick: Multi-param typeclasses have this issue unfortunately. This is why fundeps exist.
17:19:34 <geekosaur> in many cases you need TypeApplications to specify, because neither parameters nor result tpe exposes enough
17:19:45 <geekosaur> or fundeps or associated types
17:19:56 <koz_> Yeah, TypeApplications is another option.
17:37:44 --- mode: glguy set +v Mutter
17:38:33 <Mutter> On irc 
17:39:33 * hackage HCL 1.5 - High-level library for building command line interfaces.  http://hackage.haskell.org/package/HCL-1.5 (jlamothe)
17:39:49 <Mutter> 18:37 Mutter: Hello all.... i am try to find an international news channel any suggestions
17:44:44 <cemerick> koz_: yup, fundeps worked out just fine. Thanks :-)
17:56:36 <koz_> Does someone understand massiv slicing? I don't really understand its logic, and would appreciate some help.
17:57:47 <koz_> Specifically am unclear about the second argument to <!>: http://hackage.haskell.org/package/massiv-0.2.4.0/docs/Data-Massiv-Array.html#v:-60--33--62-
18:02:03 * hackage superdoc 0.1.2.9 - Additional documentation markup and Unicode support  http://hackage.haskell.org/package/superdoc-0.1.2.9 (PeterSelinger)
18:08:59 <ragusa> koz_: Looks like it's the dimension and number of elements you want to slice
18:09:36 <koz_> ragusa: It seems that it can only slice 'down' one dimension at a time.
18:09:47 <koz_> I was looking for a way to slice, say, a 3D array into a 1D piece.
18:09:53 <koz_> But I don't think <!> does that.
18:10:49 <ragusa> No, but it says you can chain them
18:11:07 <koz_> Oh yeah, I could do something like arr !> i !> j or something.
18:11:19 <koz_> I was just wondering if that was the 'correct' way of doing that.
18:12:44 <ragusa> All function return an Elt result, so it seems you can only go down one dimension
18:14:07 <koz_> ragusa: Yeah, seems so. Thanks for confirming that.
18:17:03 * hackage hakyll-dhall 0.2.2.2 - Dhall compiler for Hakyll  http://hackage.haskell.org/package/hakyll-dhall-0.2.2.2 (jle)
18:36:29 <platz> it's that time of year again: advent of code
18:38:16 <platz> I think i made it until the 15th last year before calling it quites
18:53:54 <mniip> oh huh
18:54:03 <mniip> I did make it to the previous year's leaderboard after all
18:56:48 <platz> it looks like they disabled the prior years private leaderboards
18:57:09 <platz> ah no just have to log in :)
18:58:04 <platz> you got 8th :)
19:02:48 <Axman6> @hoogle for
19:02:48 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
19:02:48 <lambdabot> Distribution.Compat.Prelude.Internal for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f t b
19:02:48 <lambdabot> Text.Blaze.Html4.FrameSet.Attributes for :: AttributeValue -> Attribute
19:02:53 <Axman6> @hoogle for_
19:02:53 <lambdabot> Data.Foldable for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
19:02:53 <lambdabot> Distribution.Compat.Prelude.Internal for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
19:02:53 <lambdabot> Lucid.Html5 for_ :: Text -> Attribute
19:11:18 <mniip> platz, no I mean the global leaderboard
19:11:20 <mniip> ;)
19:36:42 <Axman6> @hoogle (&)
19:36:42 <lambdabot> Data.Function (&) :: a -> (a -> b) -> b
19:36:42 <lambdabot> Control.Lens.Lens (&) :: () => a -> (a -> b) -> b
19:36:42 <lambdabot> Control.Lens.Operators (&) :: () => a -> (a -> b) -> b
19:46:03 <disconsis> I have a slightly embarrassing problem
19:46:39 <disconsis> Somehow I can't seem to be able to use (<>) instead of mappend
19:47:13 <disconsis> imported Data.Monoid, but ghc shows that '<>' is not a (visible) method of class 'Monoid'
19:47:22 <disconsis> works in ghci though...
19:47:38 <ski> how did you import it ?
19:48:06 <geekosaur> check that ghc and ghci are the same version? (in particular, if using stack and also have a system package for ghc installed) 
19:48:55 <disconsis> they are, and (<>) seems to only throw an error inside the definition - which suddenly makes a lot of sense
19:49:11 <disconsis> *instance of Monoid
19:49:32 <disconsis> ok nevermind brainfart
19:49:35 --- mode: glguy set +v mjw
19:49:40 <disconsis> :')
19:49:43 <ski> what was the issue ?
19:49:58 <ski> i guess we'll never learn, now
19:50:46 <geekosaur> Semigroup?
19:51:12 <ski> i was thinking that could be it, as well, yes
21:16:03 * hackage generic-data-surgery 0.1.0.0 - Surgery for generic data types  http://hackage.haskell.org/package/generic-data-surgery-0.1.0.0 (lyxia)
21:30:36 * hackage hw-aeson 0.1.0.0 - Convenience functions for Aeson  http://hackage.haskell.org/package/hw-aeson-0.1.0.0 (haskellworks)
21:49:10 <mniip> ski, I've managed to construct a counterexample
21:49:17 <mniip> to ->'s functoriality in Rel
21:50:37 <mniip> f = {(*, False), (*, True)} in Rel(1, 2)
21:50:44 <mniip> g = empty in Rel(1, 1)
21:52:15 <mniip> (f -> id_Bool) . (g -> id_Bool)
21:52:38 <mniip> in Rel(1 -> 2, 2 -> 2)
21:52:50 <dminuoso> Okay why exactly is GHC complaining here.. https://gist.github.com/dminuoso/ec6ab3a006c585922524d59689196ecc
21:53:04 <mniip> relates any function from (1 -> 2) to constant functions from (2 -> 2)
21:53:32 <mniip> (f . g) -> id_Bool
21:53:36 <mniip> relates everything to everything
21:53:45 <mniip> and thus is a different morphism from (f -> id_Bool) . (g -> id_Bool)
21:53:45 <dminuoso> That is, I dont even understand what GHC is complaining about.
21:54:30 <geekosaur> dminuoso, that is often a symptom of using Arch's ghc packages
21:55:29 <geekosaur> althoughâ€¦ are you working *on* ghc? If so, there's a special harness needed to get it to load into ghci
21:57:06 <geekosaur> should be utils/ghc-in-ghci/run.sh
21:57:28 <dminuoso> geekosaur: Mmm, well it happens on macOS. Surprisingly it didn't happen on GHC a few commits ago, but I cant figure out what the relationship to this issue is.
21:57:30 <dminuoso> geekosaur: Do you know the technical details?
21:58:22 <dminuoso> geekosaur: The really frustrating thing is, stage1 builds just fine.
21:58:25 <geekosaur> as the error tells you, it suggests there's a problem with missing files in the ghc-prim package as registered in the package db; the ghc-pkg check command should give more detail
21:59:05 <geekosaur> but you shoudl probably ask in #ghc or on the ghc-devs mailing list
21:59:09 <dminuoso> Fair enough
22:00:30 <justsomeguy> Out of curiosity, does anyone here use ghci as their primary unix shell? What tweaks or libraries did you use to make it easier to do things like file descriptor redirection, pipelining, etc?
22:00:55 <Axman6> why would you do that?
22:01:27 <justsomeguy> Personal preference, and becuase bash has some really weird edge cases. A whole lot of them.
22:02:14 <geekosaur> specifically it sounds like GHC/Types.hi is missing, possibly with a way prefix(which might eb your problem, if it's looking for Types.dyn_hi but you only have the vanilla way built as is normal for stage1)
22:05:04 <dminuoso> geekosaur: Mmm, Ill take a deeper look. For whatever reason invoking another `make` seems to rebuild a lot of things.
22:20:37 <dminuoso> Oh well, on the upside I realized I no longer need to break a cyclic dependency - so I can probably fix this issue by avoiding it. =)
22:47:24 <koz_> justsomeguy: I think there's some kind of library/package/thingo for that exact use case.
22:47:30 <koz_> I just can't remember its name for the life of me.
22:47:40 <MarcelineVQ> turtle
22:47:45 <koz_> YES THAT ONE
22:47:54 <MarcelineVQ> and others
23:00:55 <justsomeguy> I'll have to become acquainted with turtle, then. :^)
23:01:26 <maerwald> justsomeguy: use posix shell then
23:01:33 <MarcelineVQ> https://hackage.haskell.org/packages/search?terms=shell
23:04:48 <maerwald> I doubt turtle is more well-defined than bash, especially after reading "Portability: Works on Windows, OS X, and Linux"
23:07:02 <justsomeguy> Well, mostly I just want to have fun exploring Haskell, and I happen to mostly use programming languages for shell-like tasks.
23:07:17 <koz_> Love Haskell as I do, I don't think I'd want it for shell work.
23:07:42 <maerwald> posix shell is quite well defined, if you stick to the spec, that's as good as it gets for you in terms of "correctness" (which means, less edge cases)
23:07:51 <MarcelineVQ> koz_: why not :>
23:08:07 <maerwald> MarcelineVQ: because of "portability"
23:08:18 <koz_> MarcelineVQ: It's easier for me to write a one-liner in shell than to do the equivalent in Haskell.
23:08:19 <maerwald> you have no idea what your stuff does on windows, basically
23:08:23 <maerwald> it's semi-defined
23:08:36 <maerwald> depending on library implementations
23:08:39 <maerwald> which is unspecced
23:09:26 <maerwald> ad-hoc portability ;)
23:09:28 <MarcelineVQ> koz_: what about in haskell designed to work the same way? could be fun
23:09:53 <koz_> MarcelineVQ: Dunno, it's too vague.
23:09:59 <koz_> (namely what you're describing)
23:12:20 <MarcelineVQ> Well like shelly
23:12:27 <MarcelineVQ> er turtle :>
23:12:58 <koz_> MarcelineVQ: I've never looked into either in much detail so I still dunno. :P
23:13:19 <koz_> For something like a one-liner would be in shell, I can't imagine Haskell gives me much.
