00:26:19 --- mode: glguy set +v govno
00:46:09 --- mode: glguy set +v james881
01:55:03 * hackage WAVE 0.1.4 - WAVE audio file IO library  http://hackage.haskell.org/package/WAVE-0.1.4 (BartonMassey)
03:23:06 * hackage hpqtypes 1.6.1.0 - Haskell bindings to libpqtypes  http://hackage.haskell.org/package/hpqtypes-1.6.1.0 (MikhailGlushenkov)
03:38:19 <marvin2> what does +d do in :t?
03:38:32 <marvin2> :t mapM_
03:38:33 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
03:38:36 <marvin2> :t +d mapM_
03:38:37 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
03:38:49 <f-a> marvin2: type defaults 
03:39:07 --- mode: glguy set +v kderme
03:41:25 <kderme> any suggestions for a mutable Array in IO? Aim is efficiency.
03:43:15 <govno> I think that Haskell has not support mutability
03:43:54 <govno> unboxed types may be
03:44:10 <__monty__> kderme: https://wiki.haskell.org/Arrays
03:53:59 <stilgart> kderme: you may also consider IOVector  
04:06:23 <jollygood2> do all arrays described in https://wiki.haskell.org/Arrays have O(1) element access time by index?
04:08:15 <ski> apart from old versions of `DiffArray', i believe so
04:09:21 <Ariakenom> not that unboxed can be important for efficiency
04:09:44 <ski> s/not/note/, presumably
04:10:06 <Ariakenom> ha yes, thanks
04:15:01 <jollygood2> > listArray (0, 2) ["one", "two", "three"]
04:15:04 <lambdabot>  array (0,2) [(0,"one"),(1,"two"),(2,"three")]
04:15:22 <jollygood2> ghci gives me for the same line * Non type-variable argument in the constraint: IArray a [Char]       (Use FlexibleContexts to permit this)
04:15:52 <ski> add a type ascription `:: Array Int String' ?
04:16:34 <jollygood2> that worked, but I'm not sure why was it needed
04:21:42 <ski> @type listArray
04:21:44 <lambdabot> Ix i => (i, i) -> [e] -> Array i e
04:21:44 <ski> @type Data.Array.IArray.listArray
04:21:45 <lambdabot> (Ix i, Data.Array.Base.IArray a e) => (i, i) -> [e] -> a i e
04:22:11 <ski> jollygood2 : the latter (which you're presumably using ?) is overloaded on which type of array to construct
04:22:28 <jollygood2> I see
04:23:24 <ski> jollygood2 : in actual code sitting in a context, as opposed to a simple example, like typed into the interactor, usually it would either figure out which type to use from the context, or else generate an operation that's polymorphic in which type to use (usually under some class constraint)
04:24:17 <ski> only relatively rarely would you need to use a type ascription (or similar measure, such as `asTypeOf', type signature, ..) then
04:31:03 * hackage deferred-folds 0.9.9.1 - Abstractions over deferred folds  http://hackage.haskell.org/package/deferred-folds-0.9.9.1 (NikitaVolkov)
04:31:15 <jollygood2> listToArray xs = listArray (0, length xs - 1) xs
04:31:20 <jollygood2> is this doable without length?
04:31:29 <jollygood2> not necessarily using listArray
04:31:57 <lavalike> :t zip [0..]
04:31:58 <lambdabot> (Enum a, Num a) => [b] -> [(a, b)]
04:32:25 <lavalike> maybe not
04:32:52 <jollygood2> I think that will attempt to create array with int max elements
04:34:29 <jollygood2> no function that just takes [(index,element)] without also (min bound, max bound)
04:34:44 <ski> you need to know how many elements to allocate, before you allocate the array
04:35:22 <ski> you could define `nListToArray n xs = listArray (0,n-1) xs', i suppose
04:36:24 <ski> @let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ix f = listArray ix [f i | i <- range ix]
04:36:26 <lambdabot>  Defined.
04:36:45 <ski> > tabulate (0,9) (\i -> i^2)
04:36:47 <lambdabot>  array (0,9) [(0,0),(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81)]
04:36:59 <ski> i find something like that often handy
04:38:22 <jollygood2> pretty handy
04:38:35 <ski> (you can generalize it to `IArray', of course)
04:38:43 <ski> i got the idea from the MLs
04:38:52 <jollygood2> I don't see myself using non-Int index often (or ever)
04:39:00 <jollygood2> likewise, non-0 starting index
04:39:24 <ski> well, if you're going multi-dimensional, you'll probably use `(Int,Int)' or so as index type ?
04:39:55 <jollygood2> true
04:39:56 <ski> (`Array Int (Array Int e)' is a "ragged" array. each component array can have a different shape (in this case length))
04:40:11 <jollygood2> I wonder at how many elements Array starts to make a notable difference vs just using [a] and !!
04:41:01 <__monty__> I'd expect it to not be that many.
04:41:29 <govno> ski: with unboxed types I can modify a variables such as in imperatives languages?
04:41:41 <[exa]> jollygood2: in fact, not very much
04:41:41 <ski> variables are immutable
04:42:14 <govno> ski: ok, Haskell support FFI
04:42:27 <jollygood2> just guessing, hundred, thousands? I'll test it out of curiosity
04:42:27 <ski> but there's mutable cells, as in (a) a reference to a mutable cell; and (b) a (reference to a) mutable array
04:42:35 <ski> govno ^
04:44:02 <ski> govno : it's commonly not hard to transcribe algorithms relying on mutable state directly to say `IORef's and `IOArray's (or `STRef's and `STArray's, if you prefer)
04:45:17 <ski> however, one thing that you cannot do is go `fstLValue :: IORef (a,b) -> IORef a', you can't "take the address (for purposes of mutation) of components of a value stored in a mutable location"
04:46:09 <__monty__> govno: Are you sure you need mutation?
04:46:29 <ski> (a value of type `(a,b)' is immutable. a value of type `IORef (a,b)' references a mutable cell containing a *single* immutable value (at any time) of type `(a,b)'. there is no reduction to two independently mutable values, of type `a' and `b')
04:49:31 <govno> ski: thanks
04:49:43 <ski> (btw, a value of type `IORef a' doesn't "contain" a value of type `a'. you can conceptually think of a value of type `IORef a' as an (array) index, or a finite map key, that *together* with the actual state including the values currently stored in mutable locations, will allow you to access that value, or update the location to hold a new value. the "index" itself, on its own only *references* the value
04:50:02 <ski>  this also explains how there can be an `Eq' instance on `IORef a', not depending on `Eq' on `a'. it's basically just an index comparision)
04:51:19 <jollygood2> I benched access of every element by index. 50 elements. array is slightly slower. 100 elements, array is slightly faster. 500 elements, array is 3 times faster. 5000: 16 time faster. 50000, array is 200 times faster
04:52:34 <ski> (you can think of the part of the heap that stores current values of mutable cells as being one gigantic (dynamic) array or record or something, which is indexed via "memory addresses", which we represent as `IORef a', `IOArray i a', or similar. this mutable heap is hidden inside `IO', never explicitly referred to. we only see the "indices")
04:53:00 <jollygood2> this included building a new list out of those elements, if I timed just the access difference would be a lot greater
04:56:00 <jollygood2> I also benchmarked in ghci.. so.. not that relevant. :). but interesting that list was faster with small number of elements
04:56:07 * hackage json-feed 1.0.5 - JSON Feed  http://hackage.haskell.org/package/json-feed-1.0.5 (fozworth)
04:57:27 <stilgart> is there a reason why you speak about "index" instead of "pointer" ?
05:03:11 * hackage ratel 1.0.7 - Notify Honeybadger about exceptions.  http://hackage.haskell.org/package/ratel-1.0.7 (fozworth)
05:03:51 <__monty__> jollygood2: Probably the assigning of the arrays?
05:06:29 <jollygood2> __monty__ you're right
05:08:31 <ski> stilgart : you're asking me ?
05:12:33 * hackage lackey 1.0.7 - Generate Ruby clients from Servant APIs.  http://hackage.haskell.org/package/lackey-1.0.7 (fozworth)
05:13:11 <stilgart> ski: yes
05:14:23 <ski> stilgart : the idea is to emphasize that, conceptually, a value of type `IORef a', or `IOArray a', doesn't "contain" any values of type `a'
05:14:51 <ski> (compare with how an I/O-action, a value of type `IO a', doesn't need to contain any value of type `a', either)
05:16:26 <ski> conceptually, `readArray :: Ix i => IOArray i a -> i -> IO a' will get the value of type `a' from a state that's passed around ("threaded") hidden inside the `IO' part
05:16:47 <ski> the `IOArray i a' just acts like an index that tells use *which* part of this state we should access
05:17:59 <ski> (and if you think about it, you can think of a flat address space as a large array, indexed by memory addresses. in this particular case, we're only considering a subsection of that (with correspondingly a subset of all valid memory addresses), that's used to implement the mutable part of the heap)
05:20:11 <ski> so, this gives a conceptual view for (a) why `IOArray i a -> i -> a' would be unreasonable to ask for, since "the `IOArray i a' doesn't contain any `a'"; and (b) explains that the `Eq (IOArray i a)' instance really just abouts to index (or pointer/address, if you prefer) comparision. it *can't* touch any `a' values (because there's no `IO' in the result type) (and hence it doesn't require `Eq a')
05:20:14 <stilgart> I actually consider that a pointer is nothing more than a memory address (the presence of a value at this address highly depends on how you get your pointer)
05:20:27 <ski> yes
05:21:08 <ski> it's just that some people would like to think that "oh, if i have a pointer, then that's an indirect data structure that contains the value that's pointed at"
05:21:23 <geekosaur> that's one of the key differecnes. pointers can point, well, wherever. and admit pointer arithmetic
05:21:41 <ski> which is what i would like to get away from, from a conceptual standpoint
05:22:32 <stilgart> sounds reasonnable
05:22:43 <stilgart> thanks for the expaination
05:22:51 <ski> np
05:25:43 <ski> geekosaur : differences between pointers, and what ? references ?
05:26:33 <jollygood2> array vs list, fetching all the elements by index. compiled with -O2.  https://pastebin.com/NV7iHcTt
05:28:10 <geekosaur> in some sense, an array index is just a relative pointer. an IORef, you always know it's valid because you have to provide a value initially. in some ways it's a "managed array reference" the way there are "managed pointers" in e.g. c++
05:29:07 <ski> (fwiw, when i talk about pointers (from a conceptual standpoint, at least), i suppose i'm most commonly ignoring the pointer arithmetic aspects of them, only thinking of the indirection, via which one can access and set values. if we want multiple values after one another, of the same type, then one can conceptually think of that as arrays, pointers not needed. doing stuff like xoring pointers, or `offsetof' is another matter)
05:29:39 <ski> geekosaur : array of size one, you mean ?
05:31:02 <philippD> Is there a library that allows you to constrain the types on which a Functor or Monad can act? Something like `class CFunctor f where type C f; cFmap :: (C f a, C f b) => (a -> b) -> f a -> f b`
05:31:58 <ski> (hm, now i'm pondering pointers-to-members in C++, and what relation they have to lenses)
05:33:54 <philippD> the supermonad package seems to be kind of overkill if you just want to add simple constraints
05:34:44 <ski> @hackage constrained-monads
05:34:44 <lambdabot> http://hackage.haskell.org/package/constrained-monads
05:34:46 <ski> maybe
05:34:57 <ski> (not sure if that's the one i've seen before or not)
05:34:58 <ggole> "Array of bytes" really isn't a good model of address spaces
05:35:38 <ggole> They can be noncontiguous, multiply mapped, etc.
05:36:36 <philippD> ski: do you know how that package interacts with the standard classes?
05:37:02 <ski> i don't
05:41:05 --- mode: glguy set +v PatrickRobotham
05:46:31 --- mode: glguy set +v jackboy[m]
05:49:44 <philippD> thanks ski++
05:50:25 <mpickering> where is the cabal new-build cache?
05:51:47 <jollygood2> is Text using Data.Array.IArray under the hood?
05:52:08 <hpc> http://hackage.haskell.org/package/text-1.2.3.1/docs/src/Data.Text.Internal.html#Text
05:52:18 <hpc> http://hackage.haskell.org/package/text-1.2.3.1/docs/src/Data.Text.Array.html#Array
05:52:29 <hpc> it's using ByteArray#
05:53:14 <hpc> i think that's some ghc built-in?
05:56:03 * hackage multilinear 0.4.0.0 - Comprehensive and efficient (multi)linear algebra implementation.  http://hackage.haskell.org/package/multilinear-0.4.0.0 (ArturB)
06:05:56 <mpickering> It seems whatever I do I can't get cabal to rebuild dependencies
06:06:01 <mpickering> I have no idea where it is finding them
06:09:18 <infinisil> mpickering: ~/.cabal? ./dist? ./new-dist?
06:35:03 * hackage multilinear-io 0.4.0.0 - Conduit-vased input/output capability for multilinear package.  http://hackage.haskell.org/package/multilinear-io-0.4.0.0 (ArturB)
06:38:03 * hackage lackey 1.0.7, ratel 1.0.7, json-feed 1.0.5 (fozworth)
06:38:05 * hackage dbus 1.1.0 - A client library for the D-Bus IPC system.  http://hackage.haskell.org/package/dbus-1.1.0 (blaze)
06:38:07 * hackage yesod-markdown 0.12.5 - Tools for using markdown in a yesod application  http://hackage.haskell.org/package/yesod-markdown-0.12.5 (PatrickBrisbin)
06:38:10 * hackage brick 0.41.4 - A declarative terminal user interface library  http://hackage.haskell.org/package/brick-0.41.4 (JonathanDaugherty)
06:38:12 * hackage deferred-folds 0.9.9.1 - Abstractions over deferred folds  http://hackage.haskell.org/package/deferred-folds-0.9.9.1 (NikitaVolkov)
06:38:13 * hackage registry 0.1.1.2, registry 0.1.1.1 (etorreborre): https://qbin.io/qui-hunter-ijyw
06:38:15 * hackage hedis 0.10.8, hsyslog-udp 0.2.4 (k_bx): https://qbin.io/kodak-cheers-62w6
06:38:17 * hackage egison-tutorial 3.7.14 - A tutorial program for the Egison programming language  http://hackage.haskell.org/package/egison-tutorial-3.7.14 (SatoshiEgi)
06:38:19 * hackage http-conduit 2.3.3, githash 0.1.3.0 (MichaelSnoyman): https://qbin.io/pad-themes-9x8s
06:38:20 * hackage hw-dsv 0.3.1, hw-prim 0.6.2.20 (haskellworks): https://qbin.io/et-trap-zzoj
06:38:22 * hackage WAVE 0.1.4 - WAVE audio file IO library  http://hackage.haskell.org/package/WAVE-0.1.4 (BartonMassey)
06:38:25 * hackage ralist 0.2.1.1 - Random access list with a list compatible interface.  http://hackage.haskell.org/package/ralist-0.2.1.1 (CarterSchonwald)
06:38:27 * hackage libssh2 0.2.0.7 - FFI bindings to libssh2 SSH2 client library (http://libssh2.org/)  http://hackage.haskell.org/package/libssh2-0.2.0.7 (IlyaPortnov)
06:38:29 * hackage monopati 0.1.4 - Well-typed paths  http://hackage.haskell.org/package/monopati-0.1.4 (iokasimovmt)
06:38:31 * hackage expiring-containers 0.2.1 - Expiring containers  http://hackage.haskell.org/package/expiring-containers-0.2.1 (OShev)
06:38:32 * hackage openapi-petstore 0.0.3.0, pinboard 0.10.0.2, pinboard 0.10.0.1, pinboard 0.10.0.0 (jonschoning)
06:38:34 * hackage xmonad-spotify 0.1.1.0, fast-arithmetic 0.6.4.2, ats-pkg 3.2.4.2 (vmchale)
06:38:36 * hackage table-layout 0.8.0.3 - Layout text as grid or table.  http://hackage.haskell.org/package/table-layout-0.8.0.3 (muesli4)
06:38:38 * hackage hpqtypes 1.6.1.0 - Haskell bindings to libpqtypes  http://hackage.haskell.org/package/hpqtypes-1.6.1.0 (MikhailGlushenkov)
06:38:40 * hackage total-map 0.1.0 - Finitely represented /total/ maps  http://hackage.haskell.org/package/total-map-0.1.0 (ConalElliott)
06:38:42 * hackage stratosphere 0.28.0 - EDSL for AWS CloudFormation  http://hackage.haskell.org/package/stratosphere-0.28.0 (jdreaver)
06:38:44 * hackage fix-imports 2.1.0 - Program to manage the imports of a haskell module  http://hackage.haskell.org/package/fix-imports-2.1.0 (EvanLaforge)
06:38:47 * hackage filecache 0.4.1 - A cache system associating values to files.  http://hackage.haskell.org/package/filecache-0.4.1 (SimonMarechal)
06:38:48 * hackage structured-cli 2.5.0.1, structured-cli 2.5.0.0 (erick): https://qbin.io/og-city-vqf7
06:38:50 * hackage greskell 0.2.2.0 - Haskell binding for Gremlin graph query language  http://hackage.haskell.org/package/greskell-0.2.2.0 (debugito)
06:38:52 * hackage multilinear-io 0.4.0.0, multilinear 0.4.0.0 (ArturB): https://qbin.io/helps-sector-rg0v
06:38:54 * hackage adblock2privoxy 2.0.0 - Convert adblock config files to privoxy format  http://hackage.haskell.org/package/adblock2privoxy-2.0.0 (essandess)
06:38:57 * hackage kind-generics 0.2.0 - Generic programming in GHC style for arbitrary kinds and GADTs.  http://hackage.haskell.org/package/kind-generics-0.2.0 (AlejandroSerrano)
06:39:14 <Athas> Did Hackage have a hiccup?
06:39:30 <hpc> in the future these should be batched at display time and not at fetch time
06:54:49 <klntsky> Are there any tools similar to dejafu for imperative programming languages? https://hackage.haskell.org/package/dejafu
07:03:57 <philippD> Klntsky: I don't think so but you should be able to write something like that for Promise based asynchronicity. For languages like Java and Javascript it shouldn't be that hard to do.
07:08:06 <barrucadu> klntsky: There's Maple and Chess for C.  I think there's one for Java, but I can't quite remember
07:12:07 <maerwald> data files are not installed into .cabal/share when I do cabal new-install in a local project?
07:13:17 <merijn> maerwald: Pretty sure they're installed inside the global store
07:13:28 <merijn> maerwald: new-install just makes symlinks for exes, afaik
07:13:59 <merijn> No reason for it to make data files globally symlinked, since the Paths module can already look them up in the global store
07:14:52 <maerwald> for me, only cabal new-run works
07:15:01 <maerwald> cabal new-exec doesn't when data files are involved
07:15:11 <merijn> maerwald: Which version of cabal-install?
07:15:43 <merijn> maerwald: Also, maybe ask in #hackage and/or file a bug report, because that doesn't sound right
07:16:03 * hackage aeson 1.4.2.0 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-1.4.2.0 (AdamBergmark)
07:16:07 <geekosaur> iirc stack has the same problem, and it's rooted in data files being a hard problem in general: this can be fixed, at the price of their only working *when* installed
07:16:37 <geekosaur> (that is, you have to install to test, etc.)
07:16:52 <maerwald> merijn: trying on this project https://git.io/v5Lu4
07:17:01 <merijn> geekosaur: Why? It works fine with new-run, so why wouldn't new-exec work?
07:19:01 <klntsky> philippD: promises/futures have very little to do with concurrent state updates, aren't they? It's just a design pattern of composing async computations. To create a similar tool it is required to inspect the functions of which the promise computation is composed (i.e. argument of Promise constructor and promise object's .then/catch methods' arguments, speaking in terms of JS), to get the actual state which
07:19:04 <klntsky> is being modified, at least.
07:19:51 <geekosaur> so, as I recall it, theres a hack so data file access can detect whether it's in an installed configuration or not (that is, whether to look in the install location or relative to the current directory)
07:20:09 <geekosaur> the hack doesn't like sandboxing much
07:20:32 <merijn> geekosaur: new-run and new-exec know what directory to look into, since either cwd, or an explicitly passed project file
07:20:33 <geekosaur> new-run evokes the hack on the assumption that you are running a non-installed program. exec assumes installed
07:22:47 * geekosaur is looking for the past discussion
07:24:27 <geekosaur> https://github.com/commercialhaskell/stack/issues/848 isn't it but links to it and related things while describing a new hack to get around it 
07:25:26 <jollygood2> is there a haskell array type that you can pass directly to a C function, without any back and forth copying going on in the backgorund?
07:25:50 <merijn> jollygood2: Storable Vector
07:25:55 <merijn> @hackage vector
07:25:55 <lambdabot> http://hackage.haskell.org/package/vector
07:26:14 <merijn> jollygood2: Mind you, if the C side modifies things you'd still have to copy to be safe
07:26:40 <jollygood2> thanks
07:27:09 <merijn> jollygood2: Although if you want to do truly horrific things, you can be inspired by this atrocity: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/Utils.hs
07:29:01 <merijn> If you miss C too much in Haskell, you just need to add more -XMagicHash and (Foreign)Ptr nonsense :)
07:30:15 <philippD> klntsky: you're right. Promises have little to do with what dejafu does. You would also have to inspect the closures of the functions passed to then/catch to get any information.
07:30:41 <hexagoxel> if the c side mutates, should you not just Storable.Mutable? and freezing that is exactly the "safe copy". perhaps you meant exactly that, merijn?
07:31:06 <merijn> hexagoxel: He asked for a way to pass without copying
07:31:20 <merijn> hexagoxel: So doing a "safe copy" is still making a copy
07:31:58 <hexagoxel> but if you pass the raw ptr from a Vector.Storable.Mutable, you don't need _any_ "safe copy".
07:32:19 <merijn> Well, you do if someone on the Haskell side is going to look at it in the meantime...
07:32:51 <hexagoxel> no, that is safe. it is subject to race-conditions, if you access the same index concurrently, of course.
07:33:14 <hexagoxel> but that is a feature of any mutable data
07:38:47 <hexagoxel> (the important bit might be that the .Mutable functions are all IO (/PrimState))
07:40:26 * hexagoxel likes the "undefined `asTypeOf` head x" idiom. although it seems to be unnecessary with ScopedTypeVariables.
07:41:03 <hexagoxel> but it is nice to keep the plain haskell solutions in mind
07:41:46 <merijn> hexagoxel: honestly, proxy would've been better, but that was invented after the Storable API
07:42:15 --- mode: glguy set +v crvdgc
07:43:55 <ski> hexagoxel : another variant is `... foo x where foo :: [a] -> a; foo = undefined', to select the part of the type one's interested in
07:47:30 <jollygood2> is there a generic variant of filter, that works with Data.Array.IArray?
07:50:34 <jollygood2> and if not, can I expect haskell to optimize list away to a simple loop? ie (backToArray . f . toList)
07:51:06 <merijn> jollygood2: vector should have stuff like filter, etc. If you're dealing with 1D arrays you probably want vector over Array anyway
07:55:22 <younder> Recently been looking into Homotopy Type theory. A new program started at Princeton Institute of Advanced study by Voevodsky.
07:55:33 * hackage wai-route 1.0.0 - WAI middleware for path-based request routing with captures.  http://hackage.haskell.org/package/wai-route-1.0.0 (romanb)
07:57:23 <younder> It regards types as topological spaces as types and uses the univalent theorem to find a new way to hierarchically work types.
08:04:00 --- mode: glguy set +v koopa184
08:04:50 <geekosaur> ?where hott
08:04:50 <lambdabot> http://homotopytypetheory.org/book/
08:11:15 <ski> also ##hott
08:13:13 <koopa184> So I'm a bit of a Haskell newb, but have had some exposure to FP (just not as much "pure" FP, mostly Scala).
08:14:26 <koopa184> In Scala, you can have some value you treat as a function, i.e. you can re-evaluate it every time it's referred to. Type definitions usually something like "=> A" where A's some type parameter
08:14:43 <koopa184> In Haskell, does the same thing have to be expressed by something like the IO monad?
08:15:18 <merijn> koopa184: What does "re-evaluate" even mean? If a function is pure "re-evaluating" will just have the exact same result value
08:16:35 <koopa184> That's what I mean, Scala's not a "pure" language, so if that function has some side effect (like a network call), then the expression passed is evaluated again
08:24:24 <haveo> merijn: what if you don't want to keep the result in memory?
08:33:54 <monochrom> I don't think merijn ever committed to "keep it in memory".
08:35:44 <monochrom> Also note that Haskell "function" is not other languages' "function".
08:36:20 <haveo> I'm just saying the value of the result (and possible side-effects even though I wouldn't put side effects in by-name parameters) might not be the only concern
08:36:23 <droplet> :t (<~)
08:36:24 <lambdabot> MonadState s m => ASetter s s a b -> m b -> m ()
08:36:32 <droplet> :t (%=)
08:36:33 <lambdabot> MonadState s m => ASetter s s a b -> (a -> b) -> m ()
08:36:52 <droplet> is there something which combines these two, ie ending with '(a -> m b) -> m ()' ?
08:37:29 <monochrom> Then you should have said that in the first place.
08:39:05 <Solonarv> :t (<%=)
08:39:06 <lambdabot> MonadState s m => LensLike ((,) b) s s a b -> (a -> b) -> m b
08:39:15 <Solonarv> nope, that's not it
08:39:22 * hexagoxel . o O ( "exact same result value" _could_ mean "same address in memory", but that was not meant )
08:40:10 <lavalike> :t (!~)
08:40:11 <lambdabot> error:
08:40:11 <lambdabot>     • Variable not in scope: !~
08:40:11 <lambdabot>     • Perhaps you meant one of these:
08:40:33 <lavalike> these things are silly
08:41:06 <Ariakenom> ^~!+
08:42:31 --- mode: glguy set +v nicholasEdwardNa
08:42:59 <monochrom> And also Haskell "evaluation" is not other languages' "evaluation".  In short, other languages' "evaluation" gets split into "evaluation" (effectless) and "execution" (effectful).
08:43:21 * ski . o O ( elaboration )
08:43:38 <monochrom> If you want to repeat an effect, you re-execute it, not re-evaluate it.  Or at least this is how #haskell people speak.
08:43:49 <lavalike> :t mapMOf
08:43:50 <lambdabot> LensLike (WrappedMonad m) s t a b -> (a -> m b) -> s -> m t
08:43:52 <__Joker> Hello, first timers here, apologies beforehand if anything I say is out of order. Also, please do correct me. 
08:44:19 <lavalike> __Joker: welcome!
08:44:47 <__Joker> What brings me here is this question https://stackoverflow.com/questions/53359774/how-can-i-define-a-and-b-depending-from-each-other-typed-class-using-refind-libr
08:45:11 <haveo> monochrom: yes, the point is in scala both get conflated so even though the original question seems to be more about effectful computation, I was contemplating it on the sharing / evaluation order side of things
08:45:16 <__Joker> lavalike : Thank you for extending welcome 
08:46:15 <ski> __Joker : perhaps you want to ask the Scala folks over in #scala ?
08:46:20 <__Joker> As such, I assume the refined is kind of a port of the refined haskell library. 
08:47:47 <__Joker> ski: I believe haskell is kind of grand daddy of type theory. And believe it would not be out of place to get a  opinion here. 
08:50:03 <ski> hm, are you sure `refined' can express such disequality constraints ?
08:50:10 <__Joker> ski: Also more interested in whether something like this could be done, in any language. I personally believe not. 
08:50:41 <monochrom> I think "not equal to 5" can be done but "not equal to x" is not worth the effort.
08:51:44 <ski> (btw, i think it's more like Haskell being inspired, perhaps, by type theory)
08:52:08 <ski> __Joker : can for sure be done in dependently typed languages
08:52:12 <__Joker> monochrom: Yes, that was my feeling. Again may be I can define a extra field, c = a-b and can have a c not equal zero. But I don't think, thats serves any purpose.
08:52:16 <monochrom> Ah but Haskell is inspiring people to learn type theory.
08:52:37 <ski> true story
08:52:45 <monochrom> a-b is even harder than not-equal-to-a.
08:53:24 <ski> __Joker : such as Agda,Idris,..
08:53:48 <ski> (ATS ?)
08:54:23 <tauoverpi[m]> ATS, yes... but the syntax
08:54:36 <__Joker> ski: I have a very basic idea of Haskell, and I like to find excuse to just learn more. :) 
08:54:51 <tauoverpi[m]> Oh yeah, second language which compiles to php
08:55:17 <monochrom> If you want to convince people that a proof language would better not look like a programming language, you show them ATS.
09:00:26 <ski> tauoverpi[m] ?
09:03:59 <tauoverpi[m]> ATS targets C, php, js, and python iirc
09:09:14 <ski> ok
09:09:43 <ski> __Joker : lurking in this channel might be a good thing, then
09:16:28 <nicholasEdwardNa> Hi all. Looking for some general advice/input. New here. New to programming and Haskell. Finished two or three books, still feel amateur AF. Don't want to do another cover to cover. Want a challenge. Want to work on algorithmic trading platform to learn more (too ambitious, I know). Have got to grips with cabal, hspec, quickcheck, want to start fleshing out a project. Wanted to base project on this: https://bit.ly/2zjL6NF W
09:19:29 <hpc> your question got cut off at the link
09:20:52 <nicholasEdwardNa> What do you guys think about using the outline (https://bit.ly/2zjL6NF) for such a project?
09:21:52 <infinisil> nicholasEdwardNa: Why a link shortener??
09:22:37 <__monty__> And why a toxic one like bitly?
09:22:37 <nicholasEdwardNa> it's a long link :/ http://www.turingfinance.com/wp-content/uploads/2013/11/U10026942_SoftwareArchitectureDocument_ATs.pdf
09:24:10 <infinisil> Most would rather have a longer link than a bit.ly link tbh
09:25:14 <nicholasEdwardNa> noted. no more bitly.
09:25:21 <MarcelineVQ> I couldn't possibly care less, if we're commenting on link shorteners at the current subject.
09:25:51 <MarcelineVQ> nicholasEdwardNa, go for it, ask in here when you have more specific questions about what you end up with :>
09:28:25 <leshow> how do I know when to use transformers or mtl as a dependency? They both export some of the same functionality
09:28:49 <infinisil> leshow: Pretty sure nowadays mtl is preferred
09:29:10 <leshow> infinisil: oh okay, well that makes it easy
09:29:41 --- mode: glguy set +v kiwipre-52
09:31:10 <__Joker> ski: doing it. 
09:33:03 <geekosaur> leshow, to be more correct, mtl is one abstraction that can be built on top of transformers. there are others, but mtl is still probably the most common
09:33:23 <ski> __Joker : it may be nicer, in the long run, to use a proper IRC client, instead of a web client
09:34:31 <ski> __Joker : also, sometimes the channel is quiet, and you mey have to wait for someone, who can contribute to your question, to notice it. can sometimes be more than half an hour, just saying
09:34:45 * ski isn't sure how familiar __Joker is with IRC customs
09:35:53 <leshow> what was __Joker's question
09:36:02 <MarcelineVQ> irc conversation is asynchronous :>
09:36:04 <__Joker> ski: Any suggestion for a client. ski, grateful for the attention I am getting here.
09:36:23 <leshow> I'm using weechat, but I'm not sure if you're into terminal clients
09:36:57 <ski> __Joker : hm, not sure what the popular clients on Mac OS is ..
09:37:16 <geekosaur> textual is common
09:37:18 <ski> (perhaps HexChat is available there as well ?)
09:37:36 <geekosaur> and yes, theres hexchat usually via brew / macports
09:38:16 <ski> __Joker : if you're not afraid of the terminal emulator, then Irssi is what i use. there's also what leshow mentioned, and ircII, and others i'm sure
09:38:21 <__Joker> ski: I prefer terminal, the only use mac to browse and ssh to my development machine. 
09:39:00 <ski> (i even believe there's a couple of clients in Emacs, if that's your cuppa tea)
09:39:03 <leshow> ski: is irssi still being maintained?
09:39:19 <lavalike> __Joker: brew install irssi
09:39:33 <ski> hm, says "Stable release 2018-02-15" so i assume so
09:39:42 <lavalike> leshow: very much
09:41:04 <leshow> right on
09:42:55 <ski> __Joker : it's not an uncommon setup to run a terminal client, under a terminal multiplexer (like GNU Screen, TMux) on some machine that's usually up, and then you can SSH in to it. there's also bouncers, but i don't know much about such ..
09:44:53 <glguy> __Joker: If you're interested in Haskell and terminal IRC clients, there's http://hackage.haskell.org/package/glirc https://www.youtube.com/watch?v=taz0-hZwWP4
09:45:16 <Solonarv> I just use thunderbird because I'm lazy
09:45:42 <Solonarv> It's not a very good IRC client, so I wouldn't necessarily recommend it.
09:45:44 <monochrom> pidgin anyone? <duck>
09:46:35 <lavalike> that's a blast from the past
09:46:55 <monochrom> All blasts come from the past.
09:47:32 <MarcelineVQ> that's just a limitation of the word from
09:47:38 <lavalike> I do remember using pidgin for irc for a brief moment but it didn't last
09:47:43 <MarcelineVQ> We can overcome this with effort
09:48:25 <monochrom> No, it's a limitation of sub-lightspeed shockwaves. A blast that comes from the future has to travel faster than light.
09:50:10 <leshow> in recent GHC versions, some stuff is imported from Monoid by default right? It seems like (<>) is available now
09:50:19 <Solonarv> It's perfectly sound to view antimatter as ordinary matter that's travelling backwards in time.
09:50:24 <leshow> and when I define a Monoid, it's asking to define Semigroup too
09:50:36 <Solonarv> Hence, if you emit an antimatter blast you got hit by a blast from the future! ;)
09:50:44 <Solonarv> leshow: yep, as it should be
09:50:44 <lavalike> leshow: actually from Semigroup yeah
09:51:09 <leshow> So, if I define Semigroup, and then go to define Monoid, I just need to define mempty, not mempty and mappend?
09:51:13 <Solonarv> correct.
09:51:16 <leshow> thanks
09:51:44 <lavalike> the dual of rrect
09:51:53 <monochrom> Solonarv: Oops, forgot that one.
09:52:00 <monochrom> But anyway...
09:52:06 <monochrom> @quote monochrom faster.than.c
09:52:06 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
09:52:17 * lavalike slaps forehead
09:52:28 <Solonarv> a FTL blast would come from neither your past nor your future.
10:00:17 <leshow> how do I use a typeapplication to tell ghc that: all (< 5) [0..10]  should use say, Ints
10:00:42 <Solonarv> % :t all
10:00:42 <yahb> Solonarv: forall {t :: * -> *} {a}. Foldable t => (a -> Bool) -> t a -> Bool
10:01:10 <Solonarv> % all @_ @Int (< 5) [0..10]
10:01:10 <yahb> Solonarv: False
10:01:23 <Solonarv> leshow: like that
10:03:04 <leshow> did that work for you Solonarv ? I fiddled with it and all @Int (< 5) [1..10] worked for me
10:03:15 <leshow> I don't get the location you put the application in
10:03:50 <leshow> how do you know where to put it? When you do a :: Type, it always made sense to me, because it was at the end of the expression
10:04:39 <geekosaur> look at thebraces in the output of ":t all" above
10:04:45 <Solonarv> you have several choices for where to put it
10:04:57 <Solonarv> % :t all @_ @Int
10:04:57 <yahb> Solonarv: forall {w :: * -> *}. Foldable w => (Int -> Bool) -> w Int -> Bool
10:05:15 <Solonarv> % :t all @Int
10:05:16 <yahb> Solonarv: ; <interactive>:1:6: error:; * Expected kind `* -> *', but `Int' has kind `*'; * In the type `Int'; In the expression: all @Int
10:05:54 <Solonarv> I prefer it when sub-expressions still typecheck by themselves, so that's why I applied the types to 'all'
10:06:07 <leshow> Solonarv: my bad, I have a slightly different function I was using w/ no Foldable f =>, that's why mine worked
10:06:14 <Solonarv> ah, makes sense
10:07:06 <MarcelineVQ> I'm a fan of  all (< 5) [0..10 :: Int]
10:09:15 <leshow> Most cases I'd do that too, I just wanted to learn the other way
10:10:04 <MarcelineVQ> well, in that case : >    https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#visible-type-application
10:10:24 <leshow> Solonarv: what do you pass to ghci to get it to print the forall { t :: * -> * } bit
10:10:53 <MarcelineVQ> :set -fprint-explicit-foralls
10:11:00 <leshow> ah here it is
10:11:02 <Solonarv> ah, that's the one
10:16:43 --- mode: glguy set +v fen
10:17:02 <fen> help! https://bpaste.net/show/b441caac28e7
10:17:39 <fen> monad transformers!?
10:18:55 <Clint> more than meets the eye
10:19:11 <Solonarv> burritos in disguise!
10:24:08 <fen> its supposed to be something like a bifunctor
10:24:38 <fen> but instead of fmap on both sides, one side is a state of some return type and the other side can be acted on by this return type
10:25:09 <adius> Hi, what's currently the best (free) getting started resource for Haskell?
10:25:24 <adius> I liked http://learnyouahaskell.com, but the setup instructions are a bit lacking
10:27:14 <MarcelineVQ> I can't say what's best but https://en.wikibooks.org/wiki/Haskell covers a lot of ground
10:30:18 <govno> adius: learn Haskell is a pain, it is more difficult than other languages.
10:32:03 <leshow> I don't know that it's much more difficult. There's certainly more of it though. And coming from like an OO language it's radically different.
10:32:28 <leshow> If your first language was OCaml you probably wouldn't think it was that tough
10:32:46 <fen> most people are born with an innate understanding of haskell 
10:32:49 <Ariakenom> and it's certainly not a pain, ime
10:33:32 <leshow> Ariakenom: yeah, true, people love learning it so much they do it in their free time, even when they know they probably won't get a job writing it lol
10:35:20 <fen> like learning english in a foreign country! 
10:47:37 <fen> any help with? https://bpaste.net/show/b441caac28e7
10:47:53 <Solonarv> you haven't said what you want help *with*
10:48:03 * hackage crypto-enigma 0.1.1.1 - An Enigma machine simulator with display.  http://hackage.haskell.org/package/crypto-enigma-0.1.1.1 (Orome)
10:50:14 <monochrom> A good, free, getting started resource.
10:51:14 <monochrom> And an example to elaborate: That LYAH is inadequate in setup instructions.
10:52:06 <MarcelineVQ> monochrom: drink your coffee :>
10:52:30 <monochrom> eh?
10:53:00 <monochrom> Oh, I have fen on ignore. Is that why?
10:53:08 <MarcelineVQ> I was about to ask that
10:53:25 <MarcelineVQ> ones less mystery in the universe
10:54:01 <fen> eh?
10:54:09 <Clint> fen: eat your pudding
10:54:13 <fendor> How lazy is a monad stack? Imagine a code snippet like this: https://hastebin.com/xihemavero.coffeescript . If the Monad constraint is actually `MonadRandom` or `MonadState` for some randomness, e.g. the neighbourhood is randomly generated or permuted, how lazy is the implementation? 
10:55:14 <monochrom> Do you want a CoffeeScript answer or do you want a Haskell answer?
10:55:38 <fendor> monochrom, i dont know how to tell hastebin which language i am pasting :)
10:55:59 <fendor> monochrom, i'd porbably prefer the haskell answer, since i dont know coffeescript
10:56:00 <lavalike> just transpile your coffeescript answer into an haskell answer
10:57:57 <Solonarv> this may sound a bit unsatisfying, but: depends on the concrete transformer stack you end up picking
10:58:04 <geekosaur> laziness will eb determined by how lazy (>>=) is for all the monads n question
10:58:15 <fen> Solnarv: trying to write an abstraction like Bifunctor, but for where the requirement is not that its has fmap over both parameters stored in something like a pair, but instead that one side is a state returning a value that can act on the other side
10:58:15 <Solonarv> e.g. mtl has Control.Monad.State.Strict and Control.Monad.State.Lazy
10:58:54 <fendor> geekosaur, makes sense, thank you! 
10:59:51 <fen> maybe the paste is more complex than it could be because its also trying to express how such a thing is also itself a state of the intermediate value and can be acted on by it.
11:00:08 <Solonarv> It is, yes.
11:00:27 <fen> maybe help with a monad instance and how it would make a transformer?
11:00:42 <fen> probably would need StateT...
11:00:50 <fen> but then whats ActT?
11:01:00 <fen> thats a good place to start probably
11:01:58 <fendor> Solonarv, I thought that this *only* influences the evaluation model for the state it encapsulates?
11:02:00 <fen> one side returns a value and is modified during the process, so it needs both Reader and Writer, its a State
11:02:16 <fen> but this dual thing Act is different...
11:02:25 <fen> contravarient dual?
11:02:25 <Solonarv> fendor: possibly, I don't recall the exact difference.
11:03:03 <adius> MarcelineVQ: Ah yes, the wiki is indeed not bad. Thanks!
11:03:06 <Solonarv> fen: ReaderT over WriterT is not the same thing as StateT
11:03:15 <fen> ohno!
11:04:24 <blackandblue> hi haskellers
11:04:24 <fen> so is this like ActT over StateT? the fact it has 2 sides and isnt symmetric is confusing this 
11:04:30 <blackandblue> what OS do you use ?
11:04:38 <monochrom> No, Control.Monad.State.Strict and Control.Monad.State.Lazy do not differ in your state.  Your state will still be lazy.  They differ in control flow.  I have an example in the URL I'll give next.
11:04:51 <Solonarv> this doesn't seem like it's a monad (or monad transformer) at all, IMO
11:04:59 <fendor> Solonarv, I dont think that is right, since both have the `modify'` for strict modification. 
11:05:03 <Solonarv> blackandblue: windows for me
11:05:58 <monochrom> ooohhh the URL doesn't work now.  But a simple one is "gen = do { xs <- gen; return (0:xs) }"
11:07:08 <monochrom> If you say "that looks like unsafeInterleaveIO" you're right I think.
11:07:11 <fen> :t gen = do { xs <- gen; return (0:xs) }
11:07:13 <lambdabot> error:
11:07:13 <lambdabot>     parse error on input ‘=’
11:07:13 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
11:07:21 <fen> @let gen = do { xs <- gen; return (0:xs) }
11:07:23 <lambdabot>  Defined.
11:07:26 <fen> :t gen
11:07:27 <lambdabot> (Monad m, Num a) => m [a]
11:08:21 <monochrom> I use Ubuntu.
11:09:07 <monochrom> Is lpaste really dead now? I put some many good examples there.
11:09:21 <Solonarv> It seems so.
11:09:24 <monochrom> I guess time to set up my own pastebin.
11:09:30 <adius> I anyone joining me for the HaskellChallange? 😅
11:09:30 <adius> https://twitter.com/AdrianSieber/status/1066407164577746944
11:10:19 <fen> ok, sure, the Loop instance (e.g. ([a],[a]), which is Loop (,) [a] [a] a) is not a Monad, but because it requires State and Act constraints on ([a],[a]) @a cant it be writen like a Monad Transformer stack of StateT and ActT ?
11:10:21 <pikajude> is there a reference for all the Show instances of the IOErrors the RTS can throw?
11:10:32 <pikajude> i'd like to catch "resource vanished" but i have no idea what that is
11:11:33 * hackage yesod-auth-oauth2 0.5.3.0 - OAuth 2.0 authentication plugins  http://hackage.haskell.org/package/yesod-auth-oauth2-0.5.3.0 (PatrickBrisbin)
11:11:43 <Solonarv> pikajude: you probably shouldn't use Show for that
11:11:51 <pikajude> well i'm not
11:12:00 <pikajude> it just gets printed to stderr before my program exits
11:12:05 <Solonarv> oooh I see
11:12:26 <Solonarv> if you look at the haddocks for IOError, there's a list of instances
11:12:41 <Solonarv> next to each instance is a "source" link which takes you to that instance's definition
11:12:52 <monochrom> I think it's going to be an uphill battle.  IOError is kept abstract.  System.IO.Error has a ton of predicates for you to test against, but nothing says it's comprehensive and there is always the userError case that really comes down to string comparison.
11:13:17 <pikajude> sigh
11:14:56 <geekosaur> IOErrorType, ResourceVanished
11:15:26 <geekosaur> (ioe_type in IOException)
11:16:03 <monochrom> I don't think they are exported at all.
11:16:08 * hackage yesod-auth-oauth2 0.6.0.0 - OAuth 2.0 authentication plugins  http://hackage.haskell.org/package/yesod-auth-oauth2-0.6.0.0 (PatrickBrisbin)
11:16:55 <geekosaur> they are, but in GHC.IO.Exception. 
11:16:59 <geekosaur> er, from...
11:17:06 <monochrom> But is that a hidden module?
11:17:27 <pikajude> well i know i probably shouldn't import anything starting with GHC.* just to deal with an error like this
11:17:37 <buttons840> adius: you are just starting to learn Haskell? welcome
11:17:52 <merijn> They're also in System.IO.Error I think?
11:18:06 <monochrom> No, System.IO.Error keeps things very abstract.
11:18:19 <monochrom> Hell it's full of boolean blindness too.
11:18:47 <merijn> What's wrong with using those to catch the errors?
11:18:55 <monochrom> It's like a Scheme programmer designed it.
11:19:02 <merijn> I agree the design is maybe not ideal, but it works
11:19:20 <monochrom> None of them helps you with ResourceVanished.
11:19:58 <pikajude> maybe i can just catch all io errors
11:20:07 <pikajude> and unconditionally restart
11:20:34 * hackage swagger2 2.3.1 - Swagger 2.0 data model  http://hackage.haskell.org/package/swagger2-2.3.1 (phadej)
11:21:53 <adius> buttons840: Why would you assume that after reading my tweet?
11:22:23 <buttons840> adius: i didn't realize it was you who wrote the tweet, i thought you were someone taking the challenge
11:23:57 <adius> With joining me I meant posting the same / a smiliar tweet as I can only offer free lunch for the Berlin area ;-)
11:25:36 <koz_> adius: I'd be happy to extend this to Auckland, NZ.
11:26:04 <adius> Cool! tweet away 😁
11:26:35 <koz_> adius: Just did.
11:27:39 <blackandblue> Solonarv: linux is not helpful in haskell dev right?
11:27:44 <blackandblue> Solonarv: you use WSL?
11:28:23 <koz_> blackandblue: Uhh, I'd argue it's easier on Linux, but that's my daily driver everywhere, so I'm biased. :P
11:30:36 <tauoverpi[m]> Almost everything concerning dev will be easier on linux
11:31:39 <fen> like crosscompiling! 
11:32:16 <ski> imho, the `Show' instances of the error/exception types are messed up ..
11:37:18 <rotaerk> hmm I'm trying to add type-level state to a monad; I'm looking at effect-monad, but it seems like they aren't transformers...
11:37:54 <rotaerk> like, they're neat for tracking effects but ... effects of what? they don't seem to support running IO actions during those state changes
11:38:54 <tauoverpi[m]> fen: amusinly it's even easier with nix/guix
11:40:05 <fen> no travis?
11:40:20 <fen> or gradle...
11:40:42 <fen> hmm, so whats the way to abstract pair to the class level?
11:41:59 <Solonarv> blackandblue: I'm on windows 7/8, so I don't have WSL. Haskell dev probably /is/ easier on linux, but I don't feel like putting in the effort to install a linux
11:42:01 <fen> the part thats important is deriving instances for the generalised pair from instances on the values stored on either side...
11:42:39 <fen> like instance State s a => State (b,s) a
11:42:48 <Solonarv> fen: cross-compiling haskell is complicated no matter what, in large part because of TH
11:42:52 <fen> and obviously the version on the other side
11:43:24 <fen> Solnarv: why is TH complicates things?
11:44:10 <Solonarv> because TH requires that you're able to run the compiler's output, which doesn't really work when cross-compiling
11:45:18 <fen> oh
11:45:20 <fen> makes sense
11:45:21 <koz_> Solonarv: Never looked into setting up Cygwin?
11:45:46 <fen> Cygwin is a must for building most stuff on windows
11:46:38 <Solonarv> I have looked into it, yes; I don't use it though
11:46:47 <Solonarv> at least not knowingly
11:46:48 <hpc> vagrant makes it easy to do builds in a VM
11:46:58 <hpc> if you are fine with just skipping windows entirely
11:47:02 <fen> surely this idea of a Pair class is really fundamental?
11:47:14 <fen> like, bifunctor clearly only goes part of the way
11:47:22 <koz_> fen: What laws does such a class follow?
11:47:51 <Solonarv> the reason I don't have a linux installed is that I don't have the storage space to perform the requisite data-juggling
11:48:11 <fen> thats the complicated thing, not sure about if this inheriting instances of classes from the values at each side is kind of the defining property?
11:48:29 <fen> seems to fit for bifunctor...
11:49:34 <fen> like instance (Pair f,p a,q b) => (p,q) (f a b)
11:49:42 <fen> (sorry for the notation)
11:50:25 <fen> but where there are different names for the version on either side... like leftFmap or something
11:50:56 <fen> have a feeling lens is going to storm in at this point
11:52:10 <ski> fen : are you looking for the concept of categorical product ?
11:53:25 <ski> Solonarv : hm, shouldn't the TH stuff get compiled with the "local" compiler, not the cross-compiler, then ?
11:55:44 <geekosaur> TH is hard ebcause it runs locally but needs to use stuff from the target
11:55:59 <lavalike> what is the "stuff" it needs to use?
11:56:03 <geekosaur> or, these das, use ghcid to compile and run on the target or emulation thereof
11:56:06 <merijn> TH isn't hard because of technical reasons
11:56:19 <merijn> TH is hard because no one sat down and thought hard about what it *should* do
11:56:24 <Solonarv> ski: yes, that's the complicated part IIUC
11:56:40 <geekosaur> lavalike, there's various details of word sizes, alignments, etc. buried in various things; consider unpacked strict values
11:56:40 <fen> ski: sure, generics has it, but its not just "product" like (,) or a datatype of 2 parameters...
11:57:00 <fen> like, how would bifunctor result from a product category?
11:57:09 <lavalike> geekosaur: I'm surprised, I thought TH just generated haskell code syntactically, I guess I'm wrong!
11:57:09 <merijn> Some parts of TH are just for running locally, so they need to be able to run on the build machine. Some other code just generates code for the target machine and thus needs things like "the size of types on the target"
11:57:18 <fen> because it "preserves morphisms" ?
11:57:19 <merijn> Figuring out the interplay between those two is hard
11:57:31 <geekosaur> ^]
11:57:38 <merijn> lavalike: It is, but the code generated can depend on things like "the size of a Int in bytes"
11:57:54 <merijn> lavalike: Presumably you don't want that to generate based on the size of Int of the host machine
11:58:07 <merijn> lavalike: But maybe you do...and what the hell it's even supposed to mean is unclear
11:59:11 * ski doesn't understand fen's question
11:59:40 <ski> merijn : *nod* grovelling
12:01:15 <fen> not wanting to use generics...
12:02:09 <fen> but yeah, if the main thing about pairs as a class is that they give new names for the left and right versions of instances inhereted from the underlying values, is that what a catagory product does?
12:02:26 <ski> categorically, a bifunctor is just a functor whose domain category is a product category
12:02:35 <fen> like, is that what natural transformations or morphism preserving lifting is?
12:03:02 <fen> ski: so what about something that is a state because one half of it is a state?
12:03:15 <ski> what is "natural transformations or morphism preserving lifting" ?
12:03:21 <fen> idk!
12:03:23 <ski> what does "is a state" mean ?
12:03:38 <ski> i'm not getting the context of what you're talking about
12:03:48 <fen> it implements class State s a where state :: s -> (a,s)
12:03:52 <fen> https://bpaste.net/show/b441caac28e7
12:03:57 <fen> that was the basic attempt
12:04:21 <ski> what would be the point of such a class ?
12:04:55 <fen> see line 55
12:05:05 <fen> what, the pair class?
12:05:38 <fen> at the moment there is just Loop. which is like, an asymentric pair
12:05:47 <fen> the idea is that a Zipper is a Loop in both directions
12:06:04 <fen> but it would be good to get the abstraction its not really expressing down first
12:07:34 <ski> the `State' class (or `StateS', if you prefer)
12:07:41 <ski> it smells of being nearly as illfounded as `class (Functor f,Functor g) => NatTransf f g where eta :: f a -> g a'
12:09:07 <ski> why would you want to associate a default action of type `s -> (a,s)' or `s -> Maybe (a,s)' or `s -> (a,Maybe s)', with any particular two types `a' and `s'
12:09:26 <fen> like list and uncons
12:09:35 <ski> in general, for given types `a', `s', i can imagine many different functions, of those respective types
12:10:03 <Solonarv> in that case, give the class a better name!
12:10:06 <ski> why should one of those many be singled out, and given special, privileged status ?
12:10:13 <fen> :t (!! 0)
12:10:15 <lambdabot> [a] -> a
12:10:19 <Solonarv> if it's meant to represent unconsing call it 'Uncons' or something like that
12:10:41 <fen> :t extract 
12:10:42 <lambdabot> error: Variable not in scope: extract
12:10:47 * ski agrees with Solonarv
12:10:48 <fen> anyway..
12:11:45 <fen> so it should just take a function as an argument instead of this being available from a Constraint
12:12:26 <fen> ok, anyway it still holds for Uncons as a class
12:12:32 <fen> just as it would for State as a class
12:13:19 <fen> disabiguating those classes with a newclass isnt the problem, its using the fast that any constraint is satisfied by either sides value to make the pair satisfy that constraint
12:13:33 <fen> what class it is shouldnt matter
12:14:22 --- mode: glguy set +v minopret
12:16:10 <fen> if its a valid Pair, the value the Constraint is implemented should be available to be acted on, and the difficutly is the getting a new value for the pair and any other resulting things commuted outside of the pair. and this pattern is pretty much captured by state
12:16:40 <fen> except Act...
12:17:18 <fen> which is kind of the opposite problem, of commuting additional arguments (to the class function of the Constraint) into the pair
12:17:57 <fen> so that, if these are satisfied (State and Act) over both halfs, then anything should be possible
12:18:22 <fen> as all constraints can be curried or uncurried into that form
12:18:32 <fen> maybe something that combines Act and State is required...
12:19:23 <fen> class ActState args x results where argState :: (args,x) -> (results,x)
12:19:59 <fen> which seems to mean that to implement Pair, the user would have to give some way to make all class functions of any Constraint into this form...
12:20:05 <fen> that seems insane...
12:21:40 <ski> @type let stateDefault :: (s -> (a,Maybe s)) -> (s -> Maybe (a,s)); stateDefault stateS s = let (a,ms) = stateS s in fmap (a,) ms in stateDefault
12:21:42 <lambdabot> (s -> (a, Maybe s)) -> s -> Maybe (a, s)
12:21:43 <ski> @type let stateDefault :: (s -> (a,Maybe s)) -> (s -> Maybe (a,s)); stateDefault stateS = sequence . stateS in stateDefault
12:21:45 <lambdabot> (s -> (a, Maybe s)) -> s -> Maybe (a, s)
12:22:02 <fen> or, they could just work with ActState, acknowledging that any function *could* be put in that form and then use thin ActState Pair machinery 
12:22:28 <fen> :t sequence
12:22:29 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
12:22:36 <fen> oh sure, sry
12:23:37 <minopret> pl ((-) 0) . ((-) 7)
12:23:53 <minopret> pl \x -> ((-) 0) . ((-) 7) $ x
12:24:03 <ski> (0 -) . (7 -)
12:24:47 <ski> > map ((0 -) . (7 -)) [0 .. 7]
12:24:49 <lambdabot>  [-7,-6,-5,-4,-3,-2,-1,0]
12:25:11 <Solonarv> @pl ((-) 0) . ((-) 7)
12:25:11 <lambdabot> (-) 7
12:25:40 <minopret> pl \x y -> x y
12:26:20 <ski> @check \x -> (((-) 0) . ((-) 7)) x == (-) 7 x
12:26:22 <lambdabot>  *** Failed! Falsifiable (after 1 test):
12:26:22 <lambdabot>  0
12:27:24 <minopret> @pl \x y -> x y
12:27:24 <lambdabot> id
12:27:29 <minopret> thanks
12:27:43 <minopret> @pl ((-) 0) . ((-) 7)
12:27:44 <lambdabot> (-) 7
12:29:14 <ski> @pl (7 -) . (0 -)
12:29:14 <lambdabot> (-) 7
12:29:16 <ski> @pl (7 +) . (0 -)
12:29:16 <lambdabot> (-) 7
12:29:20 <ski> that's very strange
12:30:27 <fen> wait,sorry the above is wrong, it needs plenty of Maybe sprinkled around the place
12:48:03 * hackage pandoc-crossref 0.3.4.0 - Pandoc filter for cross-references  http://hackage.haskell.org/package/pandoc-crossref-0.3.4.0 (lierdakil)
12:51:37 <mroman> is Data.Map.fromList constant folded somehow?
12:51:40 <mroman> or "cached"?
12:52:56 <Solonarv> top-level bindings are usually memoized, which I think is what you meant by "cached"
12:53:52 <mroman> trying to define a constant Data.Map
12:53:56 <mroman> that is computed though.
12:54:17 <mroman> so it'd better be memoized otherwise performance is going down the drain.
12:54:47 <Solonarv> it should be memoized, yes
12:54:59 <Solonarv> If you want to post the code you're using we can tell you more.
12:55:06 <mniip> hmm
12:55:14 <mniip> what would be a good morphism type for the category of relations
12:55:33 <mniip> I'm thinking (a -> [b], b -> [a])
12:56:53 <ski> mniip : you want converse ?
12:57:01 <mniip> I think I do
12:57:14 <mniip> I absolutely want composition and identity
12:57:18 <ski> the two remaining modes ?
12:57:19 <mniip> so a -> b -> Bool is no good
12:59:57 <mroman> xs = [("a","b","c")]; myMap = M.fromList $ map (\(f,_,t) -> (f,t)) xs;
13:00:02 <mroman> ^- that's about the gist of it.
13:00:20 <ski>   (s . r) x z = forSome (\y -> r x y && s y z)  -- `forSome' problematic
13:01:06 <ski>   s . r = [(x,z) | (x,y0) <- r,(y1,z) <- s,y0 == y1]  -- `(==)' problematic
13:01:38 <mniip> data Rel a b = Rel { row :: a -> [b], column :: b -> [a] }
13:01:40 <mniip>   id = Rel return return
13:01:40 <mniip>   Rel x y . Rel z w = Rel (z >=> x) (y >=> w)
13:02:52 <mniip> and well
13:02:57 <mniip> dagger (Rel x y) = Rel y x
13:08:15 <fen> class (forall a b. Has ((a->b),f a) (f b)) => Functor f
13:08:20 <fen> its not works
13:08:32 <fen> Illegal polymorphic type: forall a b. Has (a -> b, f a) (f b)       A constraint must be a monotype
13:08:46 <mniip> fen, QuantifiedConstraints
13:08:56 <fen> awesome 
13:09:25 <fen>  Unsupported extension: QuantifiedConstraints
13:11:31 <fen> wierd, sure 8.6.1 was installed...
13:12:12 <fen> mniip: any idea how Pairs can be represented using Categories?
13:12:25 <mniip> what kind of pairs
13:12:58 <fen> class Pair f where
13:13:03 <fen>  stateActL :: (Maybe args,f a b) -> (Maybe results,f a b)
13:13:07 <fen>  stateActR :: (Maybe args,f a b) -> (Maybe results,f a b)
13:13:27 <mniip> how is this a "pair"
13:13:53 <fen> that was supposed to capture all possible functions that could be in a class that could then be distributed over a pair
13:13:55 * ski . o O ( <https://en.wikipedia.org/wiki/Dagger_compact_category> )
13:14:04 <fen> (hence the attempt to curry functors above)
13:14:40 <mniip> "functions" that could be in a "class"?
13:14:47 <mniip> "functions" "distributed over a pair"?
13:14:52 <fen> class defining functions
13:15:02 <fen> classes as products of one function classes
13:15:05 * ski spots singleton variables `args' and `results'
13:15:24 <mniip> ski, I'm not even questioning that at this point
13:15:26 <fen> whats that ski?
13:15:29 <fen> oh, ok
13:16:03 <fen> erm, not including functions that dont return a new value for wither side of the pair in their return type
13:16:19 <fen> otherwise there would be Maybe (f a b) in the return type
13:16:24 <ski> mniip : i don't really know how those work, just something i randomly associated your mention of `dagger' with
13:17:22 <fen> distributed over a pair meaning it can work on the values on either side, and commute the other input and output values into and out of the pair
13:17:26 <ski> should there be a warning for singleton variables, in e.g. type signatures ?
13:17:28 <fen> thats what those defining functions do
13:17:54 <mniip> "it" can "work" on values "on either side"?
13:18:04 * ski has no idea what fen is trying to do/express
13:18:07 <mniip> I'm not understanding a word
13:18:30 * Solonarv is glad they're not the only one
13:18:55 <fen> hrmpf
13:19:18 <fen> well why are pairs not a class?
13:19:31 <mniip> ski, hmm, this stuff reminds me of lens
13:19:34 <ski> if you're talking about some new type class, it might be sensible to suggest some example instances you have in mind. preferably more than one
13:19:44 <ski> mniip : `Rel' ?
13:20:01 <ski> fen : i don't know what "pairs being a class" would even mean
13:20:06 <Solonarv> seriously, I'd recommend taking whatever you're trying to express as a single chunk of (readable!) text
13:20:07 <fen> okok, lets get these QunatifiedConstraints working
13:20:09 <mniip> fmap (Rel t f) = Rel (\(x, y) -> (,) x <$> t y) (\(x, y) -> (,) x <$> f y)
13:20:18 <mniip> see the similarity to the _2 lens?
13:20:23 <ski> @type uncurry
13:20:27 <lambdabot> (a -> b -> c) -> (a, b) -> c
13:21:03 <ski> fen : how would you restate the signature of `uncurry', (or `fst', or `zip',`unzip'), using your "pairs being a class" notion ?
13:21:04 <fen> ski: eg a datatype such as Zipper f a = Zipper [a] (f a) is like a "pair" of [a] and (f a)
13:21:11 <mniip> in fact
13:21:24 <mniip> fmap (Rel t f) = Rel (_2 t) (_2 f)
13:21:27 <mroman> what does happen with a StateT IO when you fork?
13:21:33 <ski> `Zipper f a' there is iso to `([a],f a)', sure .. so ?
13:21:45 <fen> ok, so it means ios to (,)
13:21:52 <fen> isomorphic*
13:22:08 <mniip> mroman, the state is copied into both threads, but not synchronized afterwards
13:22:40 <ski> mniip : what are the types of `x' and `y' ? (assuming `t :: a -> [b]' and `f :: [b] -> a' ?)
13:22:58 <mniip> instance Functor Rel Rel ((,) e)
13:23:14 <ski> hm, ok
13:23:34 * hackage toodles 1.0.0 - Manage the TODO entries in your code  http://hackage.haskell.org/package/toodles-1.0.0 (aviaviavi)
13:24:36 <fen> like, bifunctor would be an immediate result of a Pair instance, and a way to rephrase fmap into curried form
13:25:32 <ski> mniip : hm, ok
13:25:41 <mniip> ski, ok? hm
13:25:53 * ski smirks
13:26:52 <fen> where to get 8.6.1 ?
13:27:06 <koz_> fen: You mean 8.6.2 right?
13:27:09 <ski> fen : i still have no idea what a "Pair instance" is meant to express (i did not at all understand that `stateActL',`stateActR' had to do with something "being a pair type (?)")
13:27:18 <fen> its not on haskell platform...
13:27:22 <koz_> ski: As a complete aside, are you named after the combinators S, K and I?
13:27:30 <ski> koz_, aye
13:28:08 <fen> ski: thats just the machinery required to apply the curried class defining functions and retrive the updated pair and the rest of the results
13:28:16 <ski> mniip : .. not sure where you're going with that lens similarity, though
13:28:42 <ski> what is "the curried class", and what does it have to do with pairs ?
13:29:01 <ski> "retrive the updated pair" ??
13:29:32 <mniip> traversable
13:29:50 <mniip> ...functors on Set are functors on Rel?
13:29:53 <ski> fen : can you please try to state clearly and explicitly what property (or structure) of a type `f', the constraint `Pair f' is intended to express ?
13:30:27 <fen> functions over values on either side can act on the whole pair
13:30:45 <ski> what is "the whole pair" ?
13:30:57 <fen> as a result, constraints satisfied by either side are satisfied by the whole pair
13:31:39 <fen> ski: if f a b is "the whole pair" and a and b are values on either side
13:31:45 <ski> i *suspect* that you want the type `f a b', for any types `a' and `b', to (somehow) represent ("represent" ?) a pair type (of `a' and `b') -- but i'm by no means sure that's what you're after
13:32:28 <ski> if `f' is the same `f' as in `Pair f', then `f a b' can not be any "the whole pair". it's a type, not a value. pairs are values (and `a' and `b' would also be types, not values)
13:33:13 <fen> modulo terminology 
13:33:36 <fen> its isomorphic to what i mean
13:34:07 <fen> "values of that type"
13:34:12 <mniip> modulo terminology, an idea is isomorphic to gibberish
13:34:36 <fen> sure that refering to a value of a type means exactly that
13:34:36 <Solonarv> well, module terminology any flarbl is necessarily a gloorph, but cannot be a jhustagar
13:34:39 <koz_> mniip: We need to @remember that.
13:34:54 <mroman> ah man. StateT mess again :(
13:35:03 <fen> your not a dumb compiler!
13:35:44 <fen> some questions are counterproductive
13:35:46 <ski> (sometimes i think i may behave somewhat boneheaded (or "boneheaded", depending on how one interprets it) in wanting to distinguish between a type, and values of that type (or some other kind of distinction of similar import). in certain circumstances, it's clear what people meant anyway, in which case i usually don't bother nitpicking on this
13:35:46 <Solonarv> mroman: if you're using StateT IO, I'd recommend switching it out in favor of ReaderT Env IO, where Env contains one (or more) IORef/MVar/TVar
13:35:51 <mroman> Expected: StateT f IO (a), Actual: StateT f IO (IO a)
13:35:51 <ski>  but sometimes at least i get confused as to what is meant (if anything that isn't essentally founded on a confusion). perhaps that's me being more thickheaded than others, i'm not sure)
13:36:10 <fen> its a pair!
13:36:39 <ski> @remember mniip modulo terminology, an idea is isomorphic to gibberish
13:36:39 <lambdabot> I will never forget.
13:36:47 <ski> koz_ : satisfied ?
13:36:55 <mroman> ah. need to lift the execStateT.
13:36:58 <koz_> ski: Very.
13:37:46 * ski sometimes feels more like a dumb compiler, tbh ..
13:41:06 <mroman> Is there a way to go from Num a to Integer _and_ Double?
13:41:26 <rotaerk> think I might drop effect-monad ... don't think it buys me anything
13:42:15 <rotaerk> it builds an abstraction and a bunch of instances of it that are useless to me, and doesn't really supply anything that generalizes across the abstraction, so even if I implement the abstraction, I'm not buying myself anything
13:43:00 <koz_> mroman: Are you asking for a function of type Num a => a -> (Integer, Double)?
13:43:30 <ski> @type let foo :: Integral a => a -> (Integer,Double); foo x = (n,fromInteger n) where n = toInteger x in foo  -- mroman ?
13:43:31 <lambdabot> Integral a => a -> (Integer, Double)
13:43:47 <geekosaur> you can polymorphically bind, and the bound value will be specialized at use sites. otherwise… yeh, explain more what you're trying to do
13:44:26 <mroman> let me post a snippet.
13:44:36 <reallymemorable> I'm super new to Haskell. I installed and have been playing with Euterpea and my command line says Prelude Euterpea.  How do I exit this and go back to regular `Prelude`?
13:45:24 <geekosaur> why do you need to? it's just telling you which modules are in scope
13:45:39 <reallymemorable> oh
13:45:42 <geekosaur> if you really want to remove Euterpa from yoru session: :m - Euterpea
13:45:47 <mroman> https://pastebin.com/TGVWq1sS <- @koz_
13:45:53 <platz> in Persistent/sqlite can you add columns via migration to a table that is referenced by foriegn keys?  I just want to add a column on the end, but it's trying to create a new table and drop the old one
13:45:55 <geekosaur> (or whatever the ful module name is)
13:45:59 <reallymemorable> I just tried to install a module and it didn't work and i assumed I was in some kind of special environment
13:46:02 <reallymemorable> thanks
13:46:24 <mroman> I don't want to write each arithmetic operation by hand but thought I could create a wrapper function that takes the binop as an argument.
13:48:06 <Solonarv> you could move the forall and have this signature: '(forall a. Num a => a -> a -> a) -> GsqState'
13:48:07 <ski> mroman : perhaps you want `vhArith :: (forall a. Num a => a -> a -> a) -> GsqState' ?
13:48:13 * ski smiles
13:48:18 <geekosaur> mroman, so the problem here is you're letting the caller choose any a that fits the constraint
13:48:24 <koz_> Solonarv and ski now owe each other sodas.
13:48:36 <ski> koz_ : this is an old tradition in #haskell
13:48:42 <Solonarv> :D
13:49:08 <mroman> well I could probably also use (Int -> Int -> Int) -> (Double -> Double -> Double) -> GsqState and pass in the Int version and Double version of +
13:49:17 <koz_> (as an aside, mroman's situation is a great non-trivial demonstration of how RankNTypes is really useful)
13:49:18 <MarcelineVQ> in fact you can time a mechanism by it. there's a long pause and them suddenly multiple people do the same thing.
13:49:54 <ski> @quote quote.stereo
13:49:54 <lambdabot> shachaf says: I remember when I joined #haskell and everyone would @quote stereo.
13:49:56 <MarcelineVQ> Only some of which would be explained by multiple people playing in ghci and getting answers near each other
13:49:58 <ski> @quote triumphant.stereo
13:49:58 <lambdabot> xplat says: Welcome to #haskell-blah, where your bot commands are executed in triumphant stereo!
13:50:03 <ski> @quote majestic.stereo
13:50:03 <lambdabot> monochrom says: Welcome to #haskell, where @remember's are in majestic stereo!
13:50:14 --- mode: glguy set +v fen
13:50:28 <geekosaur> people keep removing the original and variants thereof
13:50:34 <ski> (there used to be more quotes on this theme, but at some point they got removed, i think)
13:50:41 <MarcelineVQ> :>
13:51:01 <mroman> https://pastebin.com/rAjeJDpy <- this works
13:51:06 <mroman> but it feels so unhaskell.
13:51:09 <geekosaur> @quote antiphony
13:51:09 <lambdabot> No quotes match. I've seen penguins that can type better than that.
13:51:20 <ski> @quote fugue
13:51:20 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
13:51:28 <ski> ok, that's another one
13:51:43 <fen> @quote fen
13:51:46 <lambdabot> fen says: how slow are you trying to be!?
13:51:55 <fen> @quote zell
13:51:56 <lambdabot> zell says: <zell> So, are there better language than prolog to compile to and from?
13:52:15 <Solonarv> mroman: try the RankNTypes version?
13:53:38 <MarcelineVQ> Welcome to haskell! where conversation is represented by a biprofunctor stream in the category of whatever some expert claims it is, in whatever particular direction you prefer your extensions
13:54:09 * ski waits for it
13:54:23 <fen> @quote typefamilies
13:54:23 <lambdabot> No quotes match. My brain just exploded
13:55:14 <ski> (if you want to look for more quotes, perhaps you should do it in private, until and unless you find some that you'd like to share)
13:56:26 * ski idly remembers keal,palomer,protontorpedo
13:57:45 <fen> class Pair f where
13:57:49 <fen>  stateActL :: ((Maybe args,a)->(Maybe results,Maybe c)) -> ((Maybe args,f a b) -> (Maybe results,Maybe (f c b)))
13:57:53 <fen>  stateActR :: ((Maybe args,b)->(Maybe results,Maybe c)) -> ((Maybe args,f a b) -> (Maybe results,Maybe (f a c)))
13:58:07 <fen> was *obviously* what it was supposed to be...
13:58:07 <ski> mroman : fwiw, all those brackets around your patterns are redundant
13:58:40 * ski stares in utter bewilderment
13:58:57 <fen> that should capture any function applied to a pair
13:59:05 <fen> and so define pair
13:59:08 <ski> what does `Maybe' have to do with pairs ?
13:59:14 <mroman> a lot of my parentheses are redundant :)
13:59:47 <fen> well it might not need any args or give any result types. or if it gives results that dont update the pair 
13:59:54 <ski> yea, `ord' and `GsqLst' as well
14:00:04 <fen> bifunctior is clearly a subset of this class
14:00:32 <ski> how is a bifunctor a set ?
14:00:39 <fen> Bifunctor*
14:00:44 <fen> a set?
14:00:54 <ski> well, you said it was a subset ..
14:01:02 <fen> right, because class
14:01:09 <fen> probably meant subclass
14:01:26 <ski> do you mean all instances of `Bifunctor' could be made instances of `Pair' ?
14:01:58 <fen> no, bifunctor is this pair 
14:02:11 <fen> that is, all instances of `Pair' are instances of Bifunctor
14:02:25 <ski> mhm, the other way around
14:02:26 <fen> but its more
14:02:32 <fen> as this is for all classes
14:02:35 <fen> not just Functor
14:02:39 <fen> extended to pairs
14:03:11 <ski> if we identify `Pair' with the set ("class") of its instances, and likewise for `Bifunctor', then "all instances of `Pair' are instances of Bifunctor" means `Pair' is a subset of `Bifunctor', not the other way around
14:03:18 <fen> ok, not all classes, just those over a parameter of kind * -> *
14:03:48 <fen> all pairs are bifunctors, all bifunctors are pairs
14:03:53 <fen> it works both ways round
14:04:03 <ski> oh, so you're saying they're equivalent ?
14:04:06 <fen> no
14:04:29 <fen> pair also does this with all other classes over a kind * -> * parameter
14:04:46 * ski has no idea what "this" refers to
14:05:12 <fen> Pair + Functor = Bifunctor
14:05:28 <fen> otherclass + Pair= BiOtherclass
14:05:49 <fen> it gets more complicated if it only applies to one side
14:05:59 <ski> could you state the former more formally ?
14:06:15 <fen> such as the paste earlier where it was Loop which had State over one half and Act over the other
14:06:25 <ski> (i don't understand what the `+' means. also i'm not sure i understand what the `=' means)
14:06:40 <fen> but really, as a pair is used, this subclas of functionality isnt needed
14:07:07 <fen> yeah, i would but in trying to get Qualified constraints working now have no GHC...
14:07:19 <ski> fen : also, i still have no idea of particular examples of `f' satisfying `Pair f'
14:07:29 <fen> (,)
14:07:42 <fen> ...
14:07:42 <ski> more ?
14:07:52 <fen> anything isomorphic to (,)
14:08:07 <ski> that's pretty meagre, then
14:08:19 <fen> !?
14:08:23 <ski> basically only one instance (up to isomorphism)
14:08:31 <fen> thats what pairs are!!!
14:08:50 <ski> we prefer having at least two instances (not essentially the same)
14:09:03 <fen> but the fact it gives Bifunctor as a class algorithmicly is sure a good thing tho right? 
14:09:17 <ski> (there may be exceptions, but i'm not convinced this is such a case .. it seems quite ad hoc)
14:09:35 <Solonarv> if your class is just "things isomorphic to (,)" then you should probably replace its methods with 'fromPair :: (a,b) -> f a b; toPair :: f a b -> (a,b)'
14:09:41 <ski> why no
14:09:41 <fen> so Bifunctor is equivalently useless then
14:10:01 <Solonarv> Bifunctor has a whole bunch of other instances
14:10:07 <Solonarv> Either, for example
14:10:21 <fen> Solonarv: not sure defining isomorphisms is the best way...
14:10:22 <ski>   stateActL :: ((Maybe args,a)->(Maybe results,Maybe c)) -> ((Maybe args,(a,b)) -> (Maybe results,Maybe (c,b)))
14:10:25 <ski>   stateActR :: ((Maybe args,b)->(Maybe results,Maybe c)) -> ((Maybe args,(a,b)) -> (Maybe results,Maybe (a,c)))
14:10:36 <ski> together with a class with the methods Solonarv suggested
14:10:53 <fen> yeah sure that works for Either
14:10:55 <Solonarv> fen: if your class represents an isomorphism, then yes, it's a very good idea to define the class in terms of that iso
14:10:56 <fen> ohhh
14:11:03 <fen> thats why you dont like the name pair
14:11:07 <fen> ok fair enough
14:11:25 <Zemyla> You know, I think this type should exist somewhere.
14:11:32 <Solonarv> which type?
14:11:34 <fen> thats the point!
14:11:58 <Zemyla> @let newtype Requires c a = Requires { achieved :: c => a }
14:11:59 <lambdabot>  Defined.
14:12:07 <fen> Zemyla: the problem is comuting the arguments results with the pair,and representing all classes curried... basically, thats probably why it doesnt exist
14:12:20 <fen> oh right
14:12:21 <fen> nvm
14:12:24 <Zemyla> No, the type I just mentioned.
14:12:29 <fen> yah
14:12:53 <ski> Zemyla : i'd look in some kmett packages, i think
14:12:55 <MarcelineVQ> Zemyla: is Dict that?
14:13:05 <ski> MarcelineVQ : no
14:13:11 <Zemyla> MarcelineVQ: No, Dict would be the opposite.
14:13:16 <ski> `Dict c' is `c *> ()'
14:13:19 <MarcelineVQ> Man that stuff confusing
14:13:25 <Solonarv> 'data Dict c where Dict :: c => Dict c'
14:13:28 <Zemyla> @let data Has c a where { Has :: c => a -> Has c a }
14:13:29 <lambdabot>  Defined.
14:13:33 <ski> `Requires c a' is `c => a' (obviously)
14:14:24 <Zemyla> Requires and Has are adjoint to each other.
14:14:45 <fen> arent they the same?
14:14:51 <ski> not at all
14:14:56 <Zemyla> No, they're opposites.
14:14:58 <Solonarv> nope
14:15:03 <ski> they're as different as `forall' and `exists'
14:15:14 <ski> as `(->)' and `(,)'
14:15:19 <ski> as `(=>)' and `(*>)'
14:15:31 <Solonarv> 'Has c a' is (Dict c, a); 'Requires c a' is 'Dict c -> a' (right?)
14:15:37 <ski> as "necessary" and "possible"
14:15:40 <Zemyla> A value of type Requires (Applicative f) (f a) means you need proof that f is an Applicative before you can get at the f a inside.
14:16:04 <ski> Solonarv : yep
14:16:11 <Zemyla> A value of type Has (Applicative f) (f a) gives you not only a value of type f a, but a proof that f is an Applicative.
14:16:36 * ski . o O ( as chalk and chees )
14:16:52 <Zemyla> I have no idea what direction the T shape goes, but it's either Has |- Requires or vice versa.
14:17:16 <ski> Zemyla : `Has ---| Requires'
14:17:16 <Eduard_Munteanu> Has T Requires? :P
14:17:28 <Solonarv> A practically useful variant of 'Has' is 'data With c a where With :: c a => a -> With c a'
14:17:29 <ski> (note that this is unrelated to the logical symbol `|-')
14:18:01 <Zemyla> Solonarv: But Has is a Functor, while With isn't.
14:18:29 <Solonarv> True.
14:19:00 <Solonarv> On the other hand, you can use 'With' in the HKD pattern
14:19:08 <Zemyla> HKD?
14:19:15 <Solonarv> "higher-kinded data"
14:19:47 <Solonarv> data Blah f = Blah { intField :: f Int, stringField :: f String }
14:20:23 <Solonarv> Also used by vinyl
14:20:33 <Solonarv> % :i Data.Vinyl.Rec
14:20:34 <yahb> Solonarv: ; <interactive>:1:1: error: Not in scope: `Data.Vinyl.Rec'
14:20:55 <crysikrend> Hey everyone, I came here a while ago and I wanted to ask for the same answer (i've forgotten due to a mountain of uni work). I'm making a game and I want to make the backend server in Haskell. It's a simple puzzler, asynchronus, and I want to be able to access a database of players and their stuff. People threw a lot of answers for how to start building the server but I have no clue which one was a good
14:20:56 <crysikrend> idea? I only remember hasql for the database?
14:21:48 <Zemyla> But yeah, Requires is a Monad and a Representable, while Requires is a Comonad and Traversable.
14:22:49 <Solonarv> you said Requires twice
14:23:23 <ski> `Has c a' is a comonad
14:23:49 <ski> (er, `Has c', rather)
14:24:06 <Eduard_Munteanu> crysikrend, have you decided on a network protocol?
14:24:18 <crysikrend> I believe http is all I'll need?
14:24:23 <crysikrend> although I want to make it secure
14:24:28 <crysikrend> so is https a thing?
14:24:45 <Eduard_Munteanu> crysikrend, you should probably look at Servant then
14:24:55 <crysikrend> (i'm not very good at all this if you can tell)
14:25:21 <fen> nonono
14:25:23 <Eduard_Munteanu> Yeah, you can do HTTPS, although it's more common to stick a reverse proxy in front of the Haskell stuff.
14:25:24 <fen> this is all wrong
14:25:35 <fen> you can represent it as a continuation though
14:25:50 <fen> a -> ((p => a) -> a)
14:26:01 <fen> -> a
14:26:06 <fen> hmm, nvm
14:27:15 <ski> rather `forall o. (c => o) -> o'
14:27:36 <ski> (or `forall o. (c => a -> o) -> o')
14:28:02 <crysikrend> Eduard_Munteanu: Thank you :)
14:28:30 <rotaerk> I am defining a type like this: newtype KtxRead (m :: * -> *) (s :: (*, PositionName)) (s' :: (*, PositionName)) a = KtxRead { runKtxRead :: h -> m (a, h') }
14:28:31 <Zemyla> While Has and Requires aren't Monads and Comonads respectively unless c, they are Bind and Extend.
14:28:40 <rotaerk> is there some way to get the h and h' to be the first component of the s and s'?
14:30:00 <rotaerk> I tried:  newtype KtxRead (m :: * -> *) ((h,p) :: (*, PositionName)) ((h',p') :: (*, PositionName)) a = ...
14:30:02 <rotaerk> but that's not valid
14:30:23 <Solonarv> rotaerk: add a 's ~ (h, p0)' constraint
14:30:39 <rotaerk> it works fine if I make h, p, h', and p' separate type arguments altogether, but I need this pattern to make it compatible with IxMonad
14:30:45 <rotaerk> hmm k, thanks, lemme try that
14:30:53 <Solonarv> or write a 'Fst' type family and replace h with 'Fst s'
14:30:55 <ski> (does `Ktx' stand for "OK, thanks" ?)
14:31:17 <rotaerk> lol nah
14:31:29 <rotaerk> khronos texture
14:31:29 * ski laments tuple types being written in a way which looks like type tuples
14:31:50 <Solonarv> type family Fst (xy :: (k1,k2)) :: k1 where Fst '(x,y) = x
14:32:21 <Zemyla> I wonder if there's a way to prevent people from declaring instances of any sort for a type you create.
14:33:27 <Eduard_Munteanu> That seems excessive.
14:33:38 <Solonarv> then you have: newtype KtxRead m (s :: (*, PositionName)) (s' :: (*, PositionName)) a = KtxRead { runKtxRead :: Fst s -> m (a, Fst s') } -- rotaerk
14:33:50 <Solonarv> Zemyla: /any/ instance? that seems excessive
14:33:57 <rotaerk> thanks; I'm not sure how to get the *other* approach to work
14:34:14 <Solonarv> Surely you wouldn't want to prevent 'class Vacuous (a :: k); instance Vacuous a'
14:34:15 <rotaerk> KtxRead { runKtxRead :: ((h,p) ~ s, (h',p') ~ s') => h -> m (a, h') }
14:34:23 <ski> the other day, we talked about how it might be nice to be able to have disjointness statements for type classes, where one can say that under no circumstances should there both be such and such instances in the same program
14:35:02 <ski> i assume GHC could check this, when importing modules, since it already (iirc) checks for overlapping instances then
14:35:18 <rotaerk> type families approach seems clean though, so I'll use that
14:35:31 <erisco> as much as you can find it to be nice I could find that to be awful
14:35:54 <erisco> there are too many reasons for separate packages to conflict but this would be another
14:35:54 <ski> ok ?
14:36:05 <erisco> there are not*
14:36:24 <Solonarv> but if you want to disallow a *specific* class, you can write 'instance (TypeError ('Text "Forbidden SomeClass instance for MyType")) => SomeClass MyType where {}'
14:38:10 <geekosaur> hm.not sure it can 100% check then
14:38:29 --- mode: glguy set +v Ozy0900
14:38:44 <geekosaur> modle A uses one instance, module B a second, both use a function in C whch has neither one's instances imported
14:38:51 <geekosaur> and the instance comes in at runtime
14:39:23 <Zemyla> Actually, I would. I'm trying to write a generalization of the rank1dynamic package, which can handle more variable kinds than just *, while still having Typeable on them, and I eventually found something like data family ANY :: Nat -> k; type family Any :: Nat -> k where Any = ANY; and then I just don't export ANY.
14:40:15 <ski> "instance comes in at runtime" ?
14:40:50 <Zemyla> But I'm not sure if LiberalTypeSynonyms would allow someone to write instance Show (Any 0) where { ... } if ANY isn't exported.
14:42:18 <geekosaur> it's a dictionary parameter
14:43:27 <mroman> hm. forkIO doesn't force deep-eval right?
14:43:52 <geekosaur> doesn't force any evaluation
14:44:30 <Solonarv> % :i evaluate
14:44:30 <yahb> Solonarv: evaluate :: forall a. a -> IO a -- Defined in `GHC.IO'
14:44:36 <mroman> yeah apparentely if you just do forkIO $ something that something might never actually be evaluated
14:44:41 <mroman> so it's essentially a nop
14:44:41 <Zemyla> And I want to forbid that, because I want to be able to do "insert "showsPrec" (Dynamic1 $ Requires showsPrec :: Requires (Show (Any 0)) (Int -> Any 0 -> ShowS)) functionMap" later on without a potential Any 0 instance for Show inserting itself and causing problms.
14:44:52 <geekosaur> yep, anda somewhat common mistake
14:45:17 <geekosaur> "I saidto do these computations in threads" "bu you didn;'t force them in threads so the final print did them all"
14:45:21 <Solonarv> Zemyla: if it's a specific instance you want to forbid, you can use the 'instance TypeError (...) => Forbidden Whatever' method
14:45:21 <mroman> I seemed to have used forkIO $ do { result <- something; case result of { [] -> return () _ -> return )( } } to ensure it actually does something.
14:45:40 <mroman> I'm not sure this is actually enough.
14:45:44 <Solonarv> mroman: yeah, use 'evaluate'
14:45:58 <Solonarv> @hackage deepseq - and possibly look at this package
14:45:58 <lambdabot> http://hackage.haskell.org/package/deepseq - and possibly look at this package
14:54:08 <mroman> but it seems that writes and reads to chan have an effect.
14:54:15 <mroman> so at least it's enough for the usual use cases.
14:54:26 <mroman> and I can see the prints done.
14:55:24 <Zemyla> It'd be very useful if forkIO's signature were forkIO :: IO a -> IO (Thread a).
14:56:19 <mroman> I was thinking about modelling sockets as chans.
14:56:27 <geekosaur> http://hackage.haskell.org/package/async-2.2.1/docs/Control-Concurrent-Async.html
14:56:33 <mroman> Is there some nasty pitfall there or is this a decent idea/solution?
14:56:52 <mroman> (well... two chans. A read chan and a write chan)
14:57:02 <geekosaur> forkIO is very low level; async gives you nicer stuff
14:57:24 <mroman> I'd spawn two forks that read/write from the socket and relay this over the chan.
14:58:18 <mroman> this would mean I could expose a single data type to handle sockets/files and other async stuff.
14:59:24 <mroman> probably (Chan,MVar)
14:59:29 <mroman> chans can't be closed.
14:59:34 <zachk> mroman, I use cloud-haskell/distributed process for handling sockets in a networked "game" and it works rather nicely, with multiple processes for each socket to read and write 
15:00:10 <mroman> or (MVar (Chan a)) even
15:00:13 <mroman> that's probably better?
15:00:30 <mroman> a closed chan would then be an empty mvar.
15:00:52 <Solonarv> @hackage broadcast-chan -- might be useful
15:00:52 <lambdabot> http://hackage.haskell.org/package/broadcast-chan -- might be useful
15:01:26 <Solonarv> that one's closable
15:04:59 <mroman> hm. alright. I'll look into that.
15:05:10 <mroman> last thing is to figure out how I can catch errors.
15:05:46 <mroman> such as when the file does not exist you're trying to open with readFile
15:06:30 <mroman> I wanna catch errors, but not the "missing pattern" errors if possible.
15:06:38 <mroman> because I want to catch errors and not bugs :D
15:06:59 <mroman> ("non-exhaustive patterns")
15:08:45 <Solonarv> 'thingThatMightFail `catch` \(e :: IOException) -> whatever'
15:09:04 <mroman> would that also catch divByZero stuff?
15:09:44 <Solonarv> no, division by zero is an ArithmeticException IIRC
15:10:45 <Solonarv> % evaluate (1 / 0) `catch` \(e :: ArithException) -> print e
15:10:45 <yahb> Solonarv: ; <interactive>:32:11: error:; * No instance for (Num ()) arising from the literal `1'; * In the first argument of `(/)', namely `1'; In the first argument of `evaluate', namely `(1 / 0)'; In the first argument of `catch', namely `evaluate (1 / 0)'; <interactive>:32:11: error:; * No instance for (Fractional ()) arising from a use of `/'; * In the first argument of `evaluate', 
15:10:45 <mroman> also: does this catch exceptions of forks as well?
15:11:05 <Solonarv> no
15:11:07 <mroman> (ideally it shouldn't catch past forkIO)
15:11:21 <Solonarv> I'd recommend having a look through https://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Exception.html
15:14:05 <mroman> Hm. yep. Thanks, you've helped me greatly. 
15:15:09 <geekosaur> @where parconc
15:15:09 <lambdabot> https://www.safaribooksonline.com/library/view/parallel-and-concurrent/9781449335939/
15:15:24 <geekosaur> hm, is that even valid now?
15:17:40 <MarcelineVQ> yes that's the good link
15:17:45 <mroman> but I'm feeling this can get quite tricky due to my nested use of eval so best option is probably to expose a catch function to the language I'm interpreting.
15:17:47 <MarcelineVQ> just that one has to scroll down
15:23:23 <ski> @where PCPH
15:23:23 <lambdabot> "Parallel and Concurrent Programming in Haskell" by Simon Marlow in 2013 at <http://community.haskell.org/~simonmar/pcph/>,<http://chimera.labs.oreilly.com/books/1230000000929/>,<https://web.archive.
15:23:23 <lambdabot> org/web/20180117194842/http://chimera.labs.oreilly.com/books/1230000000929>
15:24:07 <ski> @where+ PCPH "Parallel and Concurrent Programming in Haskell" by Simon Marlow in 2013 at <http://community.haskell.org/~simonmar/pcph/>,<http://chimera.labs.oreilly.com/books/1230000000929/>,<https://web.archive.org/web/20180117194842/http://chimera.labs.oreilly.com/books/1230000000929>,<https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/>
15:24:08 <lambdabot> Done.
15:40:56 <Solonarv> question: has anyone seen this type before? I've found myself using it, but I don't recall ever seeing it anywhere.
15:40:56 <Solonarv> https://gist.github.com/Solonarv/2b8cf9c75daae53548077b5a67476b00
15:45:05 <ski> (looks like `Maybe (With c a)' (in terms of your earlier `With') ?)
15:46:59 <Solonarv> Hm, yes
15:48:39 <Solonarv> I was wondering if this could be expressed using With and Maybe but somehow kept thinking of With c (Maybe a), which isn't right
15:52:56 <Solonarv> I was using it in conjunction with vinyl: Rec (CtMaybe Interpreter) is
16:03:25 <mniip> ski, hmm, I wonder if the relation on functions is possible in this encoding
16:03:57 <mniip> I think I'd need Traversable ((->) a)
16:04:15 <ski> hm, need `Finite a' ?
16:04:50 <mniip> given  a -> [a'],  a' -> [a],  b -> [b'],  b' -> [b]
16:05:03 <mniip> construct   (a -> b) -> [a' -> b'] 
16:06:39 <mniip> you can precompose the  a' -> [a], and postcompose b -> [b]
16:06:45 <mniip> but that gets you [a -> [b]]
16:06:46 <mniip> er
16:06:49 <mniip> but that gets you [a' -> [b']]
16:07:28 <mniip> ski, no wonder the proof of its functoriality calls for the axioms of choice
16:07:33 * hackage hsPID 0.1.1 - PID control loop  http://hackage.haskell.org/package/hsPID-0.1.1 (jlamothe)
16:09:59 <ski> i suppose i'm not seeing how AoC enters here
16:10:20 --- mode: glguy set +v fen
16:10:23 <ski> (but then i'm tired, i don't recall whether this corresponds to what we talked about earlier, involving AoC, or not)
16:11:14 <fen> so, if its not possible to abstract over pairs... then just one datatype should be used for loop... as opposed to trying to make anything that is a "pair" with values having particular properties, into a loop
16:11:43 <fen> so is that a general concept? like, everywhere that there is a datatype that has certain properties, these could be abstracted into a class?
16:12:14 <fen> but they are not, because this abstraction is obviously more difficult than just making one datatype to act that way..
16:12:35 <fen> and then the question is, when to make a class, and when to make a datatype...
16:12:50 <fen> is the abstraction nesacary if one type can always be used for that thing?
16:13:22 <mniip> ski, category of relations
16:13:38 <mniip> set product, set coproduct, set exponential all turn out to be functors on relations
16:14:54 <fen> like, there is a datatype State, and a StateT class...
16:15:15 <fen> but not a Functor type...
16:15:43 <mniip> fen, a class is an interface
16:15:49 <mniip> not very useful if it's only got one instance
16:16:05 <mniip> nor if all instances are isomorphic
16:16:30 <fen> well, both (,) and Either are Pairs, or Bifunctors..
16:17:39 <mniip> I wouldn't call Either a "pair"
16:17:49 <fen> the reason this class is not to be used is because its clumsy to try and reexpress haskell classes as products of one function classes of curried  functions
16:18:00 <fen> mniip: yeah, sure, it needs a different name
16:18:08 <mniip> Either is a bifunctor
16:18:28 <fen> well, bifunctor was supposed to be a subclass of pair..
16:18:29 <mniip> if you want to express higher order functors via "currying" look into ekmett's Hask
16:18:43 <mniip> (Either a) is a functor from Hask to Hask
16:18:49 <fen> that wouldnt solve the issue at all.
16:18:51 <mniip> Either is a functor from Hask to (NT Hask Hask)
16:19:04 <mniip> and so with a single class you can map over its left and right components
16:19:09 <fen> its about trying to allegorically derive instances
16:19:15 <fen> algoritmically
16:19:29 <fen> which requires writing them differently to begin with
16:19:33 <fen> which is just too much work
16:19:42 <ski> (`NT' ?)
16:19:43 <fen> its actually a wierd reason for not using that class
16:19:59 <fen> ski: natural transformation
16:20:16 <fen> like f a -> g a
16:21:08 <fen> mniip: yeah but thats just bifunctor, this was StateAct
16:21:19 <fen> Bifuncotr is just a subclass of that
16:21:37 <fen> it has no "state like" return types
16:21:38 <mniip> ski, is it called Nat?
16:21:53 <fen> and its "act like" input is just the function to map over the args
16:22:54 <fen> so how does the Category functor thing work for State and Act
16:23:12 <mniip> you'll have to explain what any of those is first
16:23:13 <fen> that (s -> (a,s)) and ((a,s) -> s)
16:23:16 <mniip> using normal language
16:23:20 <fen> ^^
16:23:34 <mniip> what is that supposed to mean
16:24:01 <fen> thats the point about having to completely curry everything to put it in the form needed by StateAct, which comines those
16:24:11 <mniip> stop
16:24:13 <mniip> you didn't explain
16:24:18 <fen> like, (args,s) -> (outputs,s)
16:24:49 <fen> ok, so if Act, State and StateAct are understood, then whats the question?
16:25:18 <mniip> you didn't explain /anything/
16:26:25 <fen> the claim is that expressing Either using Functor built on Category, that both sides can be fmapped over in the same way, and that this is a way to represent Bifunctor
16:26:51 <fen> and the question is how to extend this to types other than just acts like curried fmap
16:27:00 <fen> namely, state-like things
16:27:24 <fen> which have return types other than the value the act-like things act on
16:27:35 <fen> :t curry fmap
16:27:36 <lambdabot> error:
16:27:36 <lambdabot>     • Couldn't match type ‘(a, b)’ with ‘a1 -> b1’
16:27:36 <lambdabot>       Expected type: (a, b) -> f a1 -> f b1
16:27:45 <fen> :t uncurry fmap
16:27:47 <lambdabot> Functor f => (a -> b, f a) -> f b
16:27:58 <fen> oops, should have been saying uncurried above...
16:28:38 <fen> so here, the target of the act-like `uncurry fmap' is `f a'
16:29:37 <fen> so bifunctor only serves as an example of using Functor on Category for "act-like" things, not "state-like" things
16:29:41 <fen> it makes sense?
16:29:44 <mniip> no
16:30:02 <fen> its makes sense enought to ask a question that could clarify!?
16:30:09 <mniip> frankly no
16:30:21 <mniip> what's an "act-like thing"
16:30:46 <ski> mniip : isn't is just the functor category from `Hask' to `Hask' ?
16:30:48 <fen> act :: (a,s) -> s.
16:30:56 <mniip> ski, exactly?
16:31:06 <mniip> in haskell we denote categories by their hom profunctors
16:31:09 <mniip> so Hask is (->)
16:31:17 <mniip> and [Hask, Hask] is  NT (->) (->)
16:31:25 <ski> well, you wrote `Hask', not `(->)'
16:31:32 <mniip> type Hask = (->)
16:32:14 <mniip> fen, where a, s?
16:32:48 <fen> " a acts on s "
16:32:55 <mniip> okay sure
16:32:57 <mniip> what's
16:33:00 <mniip> :t uncurry fmap
16:33:02 <lambdabot> Functor f => (a -> b, f a) -> f b
16:33:03 <mniip> got to do with this
16:33:12 <fen> s = f a there
16:33:20 <mniip> and a = b?
16:33:33 <fen> omg
16:34:13 <fen> its not even "act-like"
16:34:21 <fen> now even the question is confused 
16:35:07 <safinaskar> i recently found a hack which allows to catch "error" exceptions in pure code
16:35:26 <safinaskar> i found a function with type "NFData a => a -> Maybe a"
16:35:28 <Solonarv> safinaskar: do explain?
16:35:44 <fen> ok, well have to make state-like and act-like wrt; (a,b) -> c and a -> (b,c)
16:35:58 <mniip> fen, that's just as general as it gets
16:36:13 <safinaskar> this function "fully executes" its argument (in deepseq-style) and returns "Just" resulting value
16:36:14 <mniip> you've lost all useful information
16:36:28 <mniip> safinaskar, does it only catch ErrorCall or all exceptions?
16:36:33 <safinaskar> but if this this argument fails using "error" or "undefined", then
16:36:37 <fen> at least it can then be used to capture the difference between the bifunctor example and a "state-like" example
16:36:40 <safinaskar> then it returns "Nothing"
16:36:54 <safinaskar> unfortunately i forget name of that function and name of that module
16:37:00 <safinaskar> please, say me it :)
16:37:19 <geekosaur> http://hackage.haskell.org/package/spoon-0.3.1/docs/Control-Spoon.html
16:38:11 <safinaskar> geekosaur: thanks, it is :)
16:38:14 <mniip> yeah that's a library that doesn't seem particularly concerned with referential transparency
16:39:13 <mniip> I mean spoonWithHandles is essentially unsafePerformIO
16:45:26 <fen> hmm, all the old lpastes are dead
16:45:30 <safinaskar> i tried to search "NFData a => a -> Maybe a" in hoogle, but found nothing
16:45:42 <safinaskar> i think this is hoogle bug
16:45:48 <fen> here is the closest thing to it mniip; https://bpaste.net/show/dd8b7622fb7c
16:46:04 <zachk> do you have the library installed safinaskar and indexed with iirc hoogle data?
16:46:18 <zachk> if using a local hoogle that is
16:46:37 <safinaskar> zachk: i use usual online hoogle
16:46:45 <zachk> oh
16:46:53 <fen> cant find the one with Either & NT
16:47:02 <safinaskar> mniip: what about functions "spoon" and "teaspoon"? are they referential transparent?
16:47:18 <mniip> safinaskar, probably not
16:47:40 <fen> safinaskar: its not easy to see what the underlying types are thats the point
16:47:40 <mniip> feh https://github.com/ekmett/hask/blob/cd4d30e7911dd7cc2da78383fd833272b1ff9303/wip/Univariant.hs
16:48:04 <fen> yes!
16:49:39 <Solonarv> actually, I think `spoon` and `teaspoon` are transparent ignoring async exceptions
16:49:57 <Solonarv> they only catch 'error', 'undefined' and incomplete pattern matches (according to the docs)
16:50:33 <zachk> would the functions in System.Exit exit all my threads / "processes" if I am using cloud haskell/distributed process?
16:50:40 <Solonarv> I can't think of a way for a pure value to maybe-or-maybe-not contain a bottom
16:51:30 <zachk> well then: Note: in GHC, exitWith should be called from the main program thread in order to exit the process. When called from another thread, exitWith will throw an ExitException as normal, but the exception will not cause the process itself to exit.
16:51:34 <geekosaur> safinaskar, there's two; one with older indexes, one with newer ones but broken type search
16:51:38 <ski> if `foo (fix id)' is bottom, then `foo (error "boo !")' should also be bottom
16:51:49 <ski> (consider `foo :: NFData a => a -> Maybe a')
16:52:14 <Solonarv> alright, bad wording on my part
16:52:23 <Solonarv> I meant "throw one of these exceptions"
16:53:15 <zachk> can I use throwTo mainThreadId to kill the main thread, and that will exit the program? 
16:55:23 <fen> mniip: so its confusing because its not like fmap takes a pair of inputs in this representation 
16:55:37 <fen> a function and a functor
16:56:58 <fen> thats wierd, it kind of acts on all the possible arguments at the same time!?
16:58:38 <safinaskar> do you remember, i asked for construct, which attempts pattern match and does "return ()" in case of error?
16:59:20 <safinaskar> i wanted way to write this shorter:         case something1 of { pattern -> something2; _ -> return (); }
16:59:43 <safinaskar> and now i have brilliant solution!!!
16:59:48 <safinaskar> look here:
16:59:51 <Solonarv> safinaskar: do you remember that we answered your question, and I gave you a function which does exactly that?
17:00:04 <safinaskar> Solonarv: using prisms?
17:00:15 <Solonarv> yes, that's the one
17:00:25 <safinaskar> Solonarv: prisms are too difficult for me
17:00:34 <safinaskar> Solonarv: i don't want to use prisms in my projects
17:00:59 <safinaskar> so, here is my solution:           myWhen x = case teaspoon x of { Just res -> res; Nothing -> return (); }
17:01:22 <Solonarv> how is that shorter!?
17:02:01 <safinaskar> you should use this so:                       main = myWhen $ let ![[_], [_]] = [[2], [3]] in putStrLn "Matched"
17:02:10 <safinaskar> Solonarv: this is not shorter
17:02:41 <safinaskar> Solonarv: i. e. my solution is not shorter than yours. but i don't want to use prisms
17:03:17 <safinaskar> Solonarv: also my method works with complex patterns, such as this [[_], [_]] = [[2], [3]]
17:03:29 <Solonarv> So does the 'case' one without any fanciness
17:03:39 <safinaskar> Solonarv: and you can use matched variables in monadic action
17:04:16 <safinaskar> Solonarv: you mean just writing (case [[2], [3]] in [[_], [_]] <- putStrLn "Matched", _ <- return ())?
17:04:24 <Solonarv> % case [[2],[3]] of [[2],[3]] -> putStrLn "Matched"; _ -> pure ()
17:04:25 <yahb> Solonarv: ; <interactive>:33:52: warning: [-Woverlapping-patterns]; Pattern match is redundant; In a case alternative: _ -> ...; Matched
17:04:29 <safinaskar> Solonarv: well, but then i should write (return ()) and i don't want this
17:05:09 <Solonarv> why, exactly? 
17:05:17 <Solonarv> % :set -Wno-overlapping-patterns
17:05:17 <yahb> Solonarv: 
17:05:23 <Solonarv> % case [[2],[3]] of [[2],[3]] -> putStrLn "Matched"; _ -> pure ()
17:05:23 <yahb> Solonarv: Matched
17:05:44 <safinaskar> Solonarv: you mean why i should write (return ())?
17:05:54 <ski> @let done :: Monad m => m (); done = return ()
17:05:56 <lambdabot>  Defined.
17:05:59 <Solonarv> no, I mean why do you want to avoid writing that
17:06:19 <safinaskar> Solonarv: because this is boterplate
17:06:39 <Solonarv> 'myWhen $ ' is boilerplate, too
17:07:05 <Solonarv> except that if you use 'myWhen', I have to go look at the definition of 'myWhen' to understand what your code does
17:07:13 <safinaskar> Solonarv: also i prefer always write case alternatives at their own lines. thus i should write such "case" using 3 lines. but "myWhen" solution uses 1 line :)
17:07:49 <Solonarv> if you just have a '_ -> pure ()' branch anyone reading your code immediately knows what's happening
17:08:31 <fen> mniip: what are bifunctors now!? if Either and (,) are just functors on both arguments!!!
17:09:15 <zachk> > fmap (+1) (Right 5) 
17:09:17 <lambdabot>  Right 6
17:09:19 <mniip> tht's pretty much all there is to it
17:09:23 <zachk> > fmap (+1) (Left 5) 
17:09:27 <lambdabot>  Left 5
17:09:35 <zachk> > fmap (+1) (4,5)  
17:09:37 <lambdabot>  (4,6)
17:09:47 <zachk> fen, how is that over both arguments? 
17:09:47 <fen> zachk: https://github.com/ekmett/hask/blob/cd4d30e7911dd7cc2da78383fd833272b1ff9303/wip/Univariant.hs
17:10:02 <fen> line 96
17:10:12 <mniip> fen, a bifunctor is just a functor from a product category
17:10:17 <mniip> or a functor into a functor category
17:10:34 <mniip> which is the same because the currying adjunction works in Ca
17:10:35 <mniip> Cat
17:10:38 <fen> not sure about that duality but ok
17:10:49 <ski> fen : a bifunctor isn't just something that's functorial in each argument
17:11:02 <fen> not anymore!
17:11:12 <ski> never has been
17:11:37 <fen> well the Bifunctor class of old was misleading then
17:11:40 <zachk> are there bimonads?
17:11:52 <mniip> zachk, no
17:12:07 <mniip> ski, it's that plus  lmap commutes with rmap, right?
17:12:19 <fen> ok no idea how state and act fit in with this
17:13:14 <ski> a bifunctor should also satisfy `first f . second g = second g . first f' (where `second = fmap' here)
17:13:29 <mniip> yeah, first and second
17:13:33 <mniip> lmap/rmap are from profunctor
17:13:55 <ski> yep
17:14:08 <fen> :: (s -> (a,s)) -> ((a,t) -> t) -> (s,t) -> (s,t)
17:14:20 <fen> thats what the abstraction was supposed to capture
17:14:22 <mniip> zachk, actually
17:14:34 <safinaskar> Solonarv: i like my "myWhen", because it is the most natural way to write imperative C/C++-style "if"
17:14:45 <Solonarv> !!
17:14:51 <safinaskar> Solonarv: i. e. if(some_codition)call_some_imerative_function ()
17:14:52 <mniip> zachk, a pair of bifunctors could be a bimonad
17:14:59 <mniip> i.e a monad in Hask x Hask
17:15:13 <zachk> so I would actually have 4 things? 
17:15:14 <Solonarv> haskell is not C/C++, and if you want to write it like that then you'll run into trouble eventually
17:15:20 <zachk> bi X bi = quad ?
17:15:26 <mniip> huh?
17:15:42 <fen> via `(s -> (a,s)) -> (s,t) -> (a,(s,t))' and `((a,t) -> t) -> (a,(s,t)) -> (s,t)'
17:15:53 * ski thought zachk might have been thinking about monoid objects in the category of monads
17:15:59 <zachk> a bi functor has two things, so if it requires a pair of bifunctors, then it would have 4 things 
17:16:13 <mniip> "a bi functor has two things" ?
17:16:23 <safinaskar> Solonarv: moreover, in C++ we destructive assignment, i. e. we have "auto [a, b] = std::make_tuple (2, 3)", which is equivalent to Haskell's "let (a, b) = (2, 3)"
17:16:34 <zachk> :info Bifunctor 
17:16:50 <safinaskar> Solonarv: so in C++ we can write something like      if([a, b] = some_func ())printf("Aha!")
17:17:00 <zachk> @type when 
17:17:01 <lambdabot> Applicative f => Bool -> f () -> f ()
17:17:10 <safinaskar> Solonarv: and my myWhen allows me to write similar code in Haskell
17:17:11 <zachk> safinaskar, use when in your do block 
17:17:25 * ski . o O ( "quad erat demosthenum" )
17:17:34 <safinaskar> Solonarv: (well, i am not sure analogie is correct here)
17:17:44 <fen> in words thats, "if one half of a pair is a state of `a' and the other half can be acted on by `a' ... etc
17:17:48 <mniip> anyway
17:17:50 <mniip> class Bimonad f g where lreturn :: a -> b -> f a b; rreturn :: a -> b -> g a b; ljoin :: f (f a b) (g a b) -> g (f a b) (g a b) -> f a b; rjoin :: f (f a b) (g a b) -> g (f a b) (g a b) -> g a b
17:17:56 <Solonarv> the haskell equivalent of that is 'case some_func of (a, b) -> putStrLn "Aha!" '
17:18:16 <Solonarv> which is perfectly fine because that pattern can't fail
17:18:23 <Solonarv> C++ does not have sum types
17:18:34 <mniip> Solonarv, std::variant
17:18:40 <Solonarv> sum types are where you need multiple case branches
17:18:46 <ski> mniip : probably need some superclass
17:18:49 <Solonarv> mniip: right
17:19:00 <mniip> ski, right, Bifunctor f, Bifunctor g
17:19:19 <fen> Applicativ/e
17:19:21 <fen> ?
17:19:30 <ski> not necessary
17:19:50 <ski> (but could be nice, perhaps)
17:20:08 <fen> yeah, whats an applicative in the land of Categories?
17:20:55 <mniip> lax monoidal endofunctor
17:21:02 <fen> ofc!
17:21:50 <Solonarv> 'endofunctor' means 'functor from a category to itself', i.e. Hask -> Hask
17:22:13 <fen> so Dom = Cod = (->) ?
17:22:22 <ski> @quote strong.lax
17:22:22 <lambdabot> geheimdienst says: haskell makes hard things easy and easy things a strong lax monoidal endofunctor ...
17:22:30 <Solonarv> 'endofunctor' actually just means Dom = Cod
17:22:32 <ski> @quote lax.functor
17:22:33 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
17:22:42 <Solonarv> Applicative is specifically an endofunctor in Hask
17:23:33 <safinaskar> Solonarv: okey, now i got correct example. look here: this is C++ code: "typedef std::variant<int, double> X; ... X x; if(auto y = get_if<0>(x))cout << "we got " << *y;"     Now this is its Haskell equivalent: "data X = L Int | R Double; ... x :: X; ... case x of L y -> putStr $ "we got " ++ y; _ -> return ()"
17:23:43 <fen> my eyes!!!
17:24:06 <safinaskar> again, c++:
17:24:08 <safinaskar> typedef std::variant<int, double> X; ... X x; if(auto y = get_if<0>(x))cout << "we got " << *y;
17:24:28 <fen> parse error on input c code
17:24:38 <safinaskar> and haskell:
17:24:41 <safinaskar> typedef std::variant<int, double> X; ... X x; if(auto y = get_if<0>(x))cout << "we got " << *y
17:25:21 <Solonarv> I mean, if you want to write C++ you're in the wrong channel, tbh
17:25:39 <Solonarv> Haskell has a 'case' construct for a reason
17:26:27 * ski . o O ( anaphora )
17:26:54 <safinaskar> oops, i meant get_if<0>(&x) instead of get_if<0>(x)
17:27:24 <safinaskar> fen: here is complete c++ example if anybody interested: https://zerobin.net/?ae4e7238961104e3#nm+pxG/TpZxQvrhauWZwp40PpvX39weJdlsOWaqVVos=
17:27:32 <safinaskar> so, c++ has sum types
17:27:34 <fen> so lax means not invertable?
17:27:56 <safinaskar> and this c++ code really performs some kind of pattern matching which can potentially fail
17:28:15 <safinaskar> so this c++ code actually coresponds to haskell code i gave earlier
17:28:40 <safinaskar> but in haskell code we should put "return ()" and in c++ code we should not. "return ()" is implied
17:28:42 <fen> your saying its impossible to use c ?
17:28:50 <safinaskar> this is why i added myWhen
17:28:57 <safinaskar> because i want that c++-style coding
17:29:03 <safinaskar> i hope now you understand me
17:29:17 <fen> seems like what your really after is haskell stype coding
17:29:26 <safinaskar> haskell code:
17:29:35 <safinaskar> data X = L Int | R Double; ... x :: X; ... case x of L y -> putStr $ "we got " ++ y; _ -> return ()
17:29:37 <Solonarv> fen: you clearly weren't paying attention, safinaskar is trying to replicate C++ behavior in haskell
17:29:55 <fen> it is true :-(
17:30:01 <Solonarv> which I don't think is a good idea
17:30:45 <fen> ++ show y
17:30:52 <safinaskar> data X = L Int | R Double; ... x :: X; ... myWhen $ let L y = x in putStr $ "we got " ++ y       -- and this is myWhen variant
17:31:05 <safinaskar> as you can see, no need for "return ()" anymore
17:31:05 <Solonarv> safinaskar: tell me this: do you understand 'teaspoon' ?
17:31:21 <safinaskar> data X = L Int | R Double; ... x :: X; ... myWhen $ let L y = x in (putStr $ "we got " ++ y)
17:31:24 <safinaskar> Solonarv: yes
17:31:36 <safinaskar> Solonarv: yes, i understand that here i abuse teaspoon
17:31:36 <Solonarv> explain it.
17:31:39 <safinaskar> Solonarv: but this works
17:31:44 <fen> no $ and parens!!
17:32:04 <safinaskar> Solonarv: in my example i actually can use it to detect pattern mismatch
17:32:14 <Solonarv> that's not what I'm asking.
17:32:15 * ski . o O ( let's ban `$' from the language )
17:32:20 <Solonarv> How does 'teaspoon' work?
17:32:34 <fen> @pl $
17:32:34 <lambdabot> (line 1, column 1):
17:32:34 <lambdabot> unexpected "$"
17:32:34 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
17:32:46 <safinaskar> Solonarv: teaspoon evaluates its argument to whnf. if this produces error thrown using "error", then teaspoon returns Nothing
17:32:50 <Solonarv> ski: give it a few years, BlockArguments only just came out
17:33:12 <Solonarv> safinaskar: yes good job, you can copypaste the documentation. How does it work?
17:33:18 <ski> aye, i should have some patience, and faith in the good sense of people
17:33:52 <safinaskar> Solonarv: it runs unsafePerformIO under hood
17:34:39 <fen> and deepSeq!
17:34:40 <Solonarv> 'unsafe'!? oh my, that doesn't sound like something I'd want to rely on!
17:35:12 <fen> thats how most people feel about the IO monad!
17:35:40 <safinaskar> fen: teaspoon doesn't run deepSeq (unlike spoon)
17:36:02 <Solonarv> and how does unsafePerformIO work, anyway?
17:36:02 <safinaskar> Solonarv: well, "teaspoon" works :)
17:36:24 <fen> Solonarv: no fair
17:36:41 <Solonarv> fen: yes fair, just wait
17:36:51 <safinaskar> Solonarv: "IO a" is pair of RealWorld (which is just opaque "black box") and value. unsafePerformIO just throws away RealWorld
17:37:00 <safinaskar> Solonarv: i really know how haskell works
17:37:01 <Solonarv> safinaskar: that's wrong.
17:37:43 <Solonarv> Anyway, my point is that whether you're using prisms or teaspoon, you're using something you don't understand.
17:37:55 <safinaskar> Solonarv: here is my scheme interpreter written in scheme: https://repl.it/repls/AlarmingCyberProperty
17:37:58 <Solonarv> Why not use the thing that /doesn't/ muck about with internals needlessly
17:38:17 <Solonarv> Ah yes, a scheme program. This clearly demonstrates your Haskell knowledge.
17:38:32 * ski . o O ( `instance Comonad OI where { #include "Kieburz" }' )
17:38:34 <safinaskar> Solonarv: here is my scheme interpreter written in c++: https://github.com/safinaskar/scheme-in-cpp-interpreter (but with commonlisp special forms)
17:38:47 <safinaskar> Solonarv: and i can write haskell interpreter, too :)
17:38:58 <Solonarv> Ah yes, a C++ program! I am in awe at your Haskell prowess!
17:38:59 <fen> in scheme?
17:39:19 <safinaskar> fen: yes, in scheme
17:39:23 <safinaskar> fen: and in haskell, too
17:39:28 <safinaskar> fen: and in c++
17:39:32 <MarcelineVQ> y'all full of beans today
17:39:36 <safinaskar> Solonarv: https://github.com/safinaskar/pa-0.1 - here is my proof checker
17:39:49 <fen> MarcelineVQ: it has descended into chaos!
17:39:57 <safinaskar> Solonarv: here is example of input it can accept: https://github.com/safinaskar/pa-0.1/blob/master/test.sh
17:40:06 <fen> people are talking about c! its fraught 
17:40:21 <Solonarv> Prisms are the idiomatic way to do what your 'myWhen' is supposed to do. If you don't understand prisms, go learn them!
17:40:41 <fen> meh, Prisms are just Lenses for rich people
17:40:43 <MarcelineVQ> what does myWhen do?
17:40:50 <ski> @palomer
17:40:50 <lambdabot> I think vim is good for the rubbish bin
17:41:27 <safinaskar> Solonarv: "The RealWorld# token is "deeply magical" and doesn't actually expand into any code when compiled, but simply threaded around through every bind of the IO or ST monad and has several properties of being unique and not being able to be duplicated to ensure sequential IO actions are actually sequential. unsafePerformIO can thought of as the unique operation which discards the world token and 
17:41:33 <safinaskar> plucks the a out, and is as the name implies not normally safe"
17:41:34 <safinaskar> Solonarv: - http://dev.stephendiehl.com/hask/
17:41:48 <Solonarv> safinaskar: yes, amazing, you copypasted the documentation
17:41:50 * ski is sure Solonarv knows this
17:41:53 <Solonarv> I do.
17:43:17 <fen> man, wanting this loop pattern expressed using abstracted pairs sure isnt happening 
17:44:01 <Solonarv> also: oh yes, a proof checker written in Shell! now I am truly convinced that you know haskell!
17:44:24 <fen> Solonarv: your being mean
17:44:33 <Solonarv> I know.
17:44:46 <fen> its just a bit of c, relax
17:45:08 <safinaskar> geekosaur: "there's two; one with older indexes, one with newer ones but broken type search" - :( this is sad
17:47:39 <Solonarv> safinaskar: why are you writing haskell, anyway? you don't seem to be particularly attracted to the language.
17:49:20 * ski isn't sure one would need to be that attached to the language, to use it ..
17:52:55 <Solonarv> I mean, haskell isn't exactly the kind of mainstream language that you use even though you hate it simply because that's where the money is
17:53:42 <Solonarv> I'm just trying to figure out why someone would insist on writing haskell like C++ to such an extent
17:57:09 <ski> well, could be they're used to C++
17:57:27 <safinaskar> Solonarv: fen: here is my proof checkers written in haskell: http://safinaskar.com/f/pa.tar
17:57:30 <ski> could be they like this feature in C++, and wonder whether it can be done sensibly in Haskell
17:57:37 <ski> &c.
17:59:17 <safinaskar> Solonarv: "a proof checker written in Shell" - well, you didn't understand anything. that was shell program that generates input for my proof checker (written in c++) and tests that checker
17:59:33 <safinaskar> Solonarv: so, that was just test script. they are often written in shell
17:59:46 <safinaskar> Solonarv: also, i say this again: check that pa.tar
18:00:13 <mniip> safinaskar, IO a = State# RealWorld -> (# State# RealWorld, a #)
18:00:13 <Solonarv> yes, yes.
18:00:25 <mniip> first of all, IO isn't a pair, it's a "state transformer"
18:00:40 <mniip> second, RealWorld isn't even the type of the token. It's State# RealWorld
18:00:54 <safinaskar> Solonarv: "you don't seem to be particularly attracted to the language" - i like haskell. it is simply more strict and beautiful than most of langs (c, c++, js, python, shell, scheme etc etc)
18:00:55 <mniip> State# is an unboxed type whose representation is of size 0
18:01:14 <safinaskar> Solonarv: but sometimes i don't like lack of imperative programming in haskell
18:01:14 <mniip> so at the STG/Cmm layer it gets erased
18:01:28 <mniip> but in Core it serves to preserve the strictness properties of IO functions
18:01:31 <safinaskar> Solonarv: and so i need a lang which combines imperative programming with haskell's beauty
18:01:41 <Solonarv> safinaskar: have you looked at Rust?
18:02:02 <safinaskar> Solonarv: it seems ML is such language. so i hope i will learn it one day, but now i am concetraded on other things
18:02:13 <safinaskar> Solonarv: but often i LIKE haskell's purity
18:02:44 <Solonarv> I haven't used much rust, but I read through the rust book. It very much seems to combine imperative programming with haskell's beauty.
18:02:49 <mniip> what exactly is it that you want from imperative programming that's not available in haskell?
18:02:56 <ski> @quote world's.best
18:02:56 <lambdabot> SPJ says: Haskell is the world's best imperative language.
18:03:27 <Solonarv> ^ that's mostly because we can define control structures as ordinary functions
18:03:30 <ski> safinaskar : the MLs are worth learning for the module system, if nothing else
18:03:39 <safinaskar> Solonarv: also, i don't understand why you mentioned money. currently i am coding just for fun. this applies to all languages i use (haskell, c++, scheme etc)
18:03:42 <Solonarv> e.g. prisms + the whenP that I showed you a few days ago
18:03:57 <Solonarv> safinaskar: I was simply curious to know what drew you to haskell, is all
18:04:11 <mniip> oo yee, haskell's where the money's at
18:04:34 <Solonarv> well my thinking was more along the lines of "it's obviously not money, so what was it?"
18:05:19 <Solonarv> I'm also a bit tired and feeling vaguely ill, which may have contributed to me not being as charitable as I should've been. Apologies.
18:05:53 <safinaskar> yes, i need some c++ features in haskell and share my opinion here, in irc. but you know what? some days ago i did opposite. i went to ##c and complained that c lacks good package manager as opposed to haskell
18:06:21 <safinaskar> so, i speak about c/c++ at #haskell, and about haskell at #c
18:06:35 <Jexi> Good job there sir
18:06:56 <ski> @where C/C++
18:06:56 <lambdabot> "C/C++ : A new language for the new Millennium" by Richard Heathfield in 2005-02 at <http://web.archive.org/web/20090421080714/http://www.cpax.org.uk/prg/portable/c/c++/rfe00000.html>
18:07:01 <ski> safinaskar : nice
18:12:56 <Solonarv> safinaskar: anyway, I'd recommend checking out lens - it's one of the coolest libraries in the Haskell ecosystem, IMO
18:16:08 <safinaskar> Solonarv: "I'm just trying to figure out why someone would insist on writing haskell like C++ to such an extent" - okey, well, let me try to explain you honestly what i am doing. i know this langs: basic, pascal, c, c++, wolfram language, js, haskell, scheme, bash.    when i want to do something low-level i pick c/c++.   in all other cases the only sane choice is usually haskell.  because this is the 
18:16:14 <safinaskar> only language i know which is actually beautiful and concise. all other languages i know are very bad. this is why i use haskell.   i like haskell because it have algebraic data types, which i miss in c++.  say, c++ variant of "data Tree x = Node (Tree x) (Tree x) | Leaf x" is very long boterplate code. haskell is good in parsers, in implementing lambda calculi, in proof checkers. haskell allows me to 
18:16:20 <safinaskar> write lcf-style proof checkers (i. e. it allows me to declare type "verified theorem" and export it, but now export its constructors). etc, etc. i like haskell for all this. but often i just want to express in haskell code some patterns i used to do in c++. and that is why i showed you this myWhen
18:16:33 * hackage pseudo-boolean 0.1.8.0 - Reading/Writing OPB/WBO files used in pseudo boolean competition  http://hackage.haskell.org/package/pseudo-boolean-0.1.8.0 (MasahiroSakai)
18:18:23 <Jexi> I am okay at programming, done alot of scripts and know most of how to program. But the issue i have is with object oriented programming and wrapping my head around it. I just find it bothersome, it might be that iwe not done it much, but id like to hear what functional programming is, and what is used for really. 
18:18:42 <safinaskar> mniip: well, if you think that part of http://dev.stephendiehl.com/hask/ is wrong, then please go report the author
18:20:33 <safinaskar> Solonarv: "have you looked at Rust?" - i looked. and for system-level things it is probably very good. but when task is not system-level, well, haskell is good choice. ML is good, too, but, as i said, i currently don't know this language
18:21:07 <Solonarv> Rust looks pretty good for other heavily imperative programs, too.
18:21:15 <Solonarv> Admittedly, I haven't actually used it.
18:21:43 <safinaskar> Solonarv: in Rust you cannot write    data List = Cons Int List | Nil .    you should put Box<...> something, because rust's enums store objects by values.   in system programming this is good thing, but in my tasks usually not
18:22:14 <Solonarv> Fair enough, recursive types are a bit verbose in Rust.
18:23:06 <safinaskar> mniip: "what exactly is it that you want from imperative programming that's not available in haskell?" - say, i want structure where you can go not only to children of particular node, but also to parent
18:23:18 <safinaskar> mniip: you can do this with DOM in js
18:23:46 * ski . o O ( zipper )
18:24:28 <safinaskar> mniip: also, in c++ you can simply write    a.x.y.z = 0.   in haskell you should either write very big expression, either use lenses
18:24:49 <mniip> exactly
18:24:52 <mniip> zippers and lense
18:24:52 <mniip> s
18:24:55 <ski> safinaskar : fwiw, ML is nowadays a family of languages : SML,OCaml,F#,Alice ML are the main members, i think
18:25:15 <Solonarv> That is actually exactly why lenses were invented, IIRC
18:25:16 <mniip> if you don't like lenses maybe whip out a quasiquoter
18:25:30 <dmj`> safinaskar: you can use pointers in Haskell, and make structures that can do that
18:25:39 <Solonarv> or learn lenses! basic lenses really aren't that complicated
18:27:45 <Solonarv> you can think of them as 'data Lens' s a = Lens { view :: s -> a, set :: s -> a -> s }'
18:28:23 <ski> Jexi : people sometimes claim that in object-oriented programming, "everything is an object". so one might perhaps assume that in functional programming "everything is a function". but that's not true. each thing is its own thing. but it is true that FP focuses more on expressions, and computing values/results, over focusing on commands (sometimes called "statements"), and "side-effects" (like generating some output (not a value), or changing the state)
18:29:58 <safinaskar> Jexi: go read "learn you a haskell". you will know what is functional programming
18:30:00 <ski> Jexi : i think that some ideas in OO are worthwhile to know about. but unfortunately, OO languages are commonly mixed in with all sorts of stuff (like implementation inheritance), that generally doesn't help that much, and even often can hinder good programming
18:30:09 <Solonarv> a prism is 'data Prism' s a = Prism { match :: s -> Either s a, construct :: a -> s }'
18:30:57 <ski> (and the common "everything is an object" view, even if not taken fully, is also a problem, as mentioned)
18:31:37 <Jexi> safinaskar: Ill look into that one, thanks 
18:32:13 <ski> Jexi : one thing : learning a different programming paradigm will probably be a little bit like learning to program from scratch again. of course, some things carry over, but perhaps less than you initially think (or at least it can seem so, after some while of learning and *unlearning*)
18:33:30 <Jexi> Gotcha
18:33:47 <ski> Jexi : unlearning things you take for granted will probably be one of the harder parts of this. but it's worth it (imho), if you carry through, for the different insights, and different POVs it brings on how one can approach and attack problems. more (useful) tools in your thinking toolbox is a good thing, even if you then don't end up using a language that was intended to support FP well
18:36:13 <Jexi> I want to know the different sides to programming. And not becoming a ignorant "javascript" dev.
18:36:17 <ski> Jexi : after you've gotten the basics of FP well under your belt, *then* you can start comparing with how you'd approach stuff in OO. but please don't do such comparisions too much, prematurely .. usually you'll then end up misunderstanding things, making bad analogies
18:36:40 <Jexi> Yeah, good point
18:36:58 <ski> also, there isn't a single clear definition of FP (just like there isn't for OO)
18:37:38 <ski> Haskell,SML,OCaml,F# all have (good) static typing systems, with type *inference* (which you may not be used to)
18:37:51 <ski> but there's also dynamically typed FP, like Scheme,Erlang
18:38:04 <Jexi> Personally, i dont like the fullness some programming enviourments where you have 100s of different functions that do similar things, like PHP is one that i didnt enjoy much.
18:38:26 <Jexi> but thats webdev so
18:39:38 <supersaiyan> hello everyone, do I have the right idea? I am trying to write a code that returns each word of a sentence into a new line? mapM_ (\putStrLn -> words >> words '\n') 
18:39:42 <ski> some people have had bad experience with static typing in say C,C++,Java,C#,Pascal,Ada, and for that reason have taken refuge in dynamically typed languages
18:40:16 <ski> but the type systems in statically typed FP tend to be different, more powerful and more flexible
18:40:32 <safinaskar> bye
18:40:45 <ski> (still, some people seem to inherently prefer program in dynamically typed languages)
18:41:20 <ski> supersaiyan : not sure what you want to do ..
18:42:10 <Solonarv> you seem to have found some relevant functions, but this is definitely not a sensible way to put them together
18:42:23 <ski> Jexi : then, Haskell is "pure" (has no side-effects). FP tends to (varying degrees) emphasize immutability, and absense of assignment. Haskell (and Clean) could be said to take this to extremes
18:42:43 <supersaiyan> ski: I want to write an I/O, where the user types "Hello ski", and it returns Hello on one line, and then ski on the next.
18:43:53 <ski> Jexi : in SML,OCaml,F#,Scheme,Erlang, you can still have your side-effects, if you want to. that may make it easier to transition into. but it might also be that it makes you not relly learn alternative FP approaches, because you can keep using only imperative approaches you already know
18:44:20 <ski> Jexi : you'll have to decide whether you prefer to be "thrown into the deep end", or "take it easy, a little at a time"
18:45:04 <systemfault> > traverse_ putStrLn (words "Hello World")
18:45:07 <lambdabot>  <IO ()>
18:45:33 <Solonarv> systemfault: yahb will actually execute IO actions
18:45:49 <ski> Jexi : also, Haskell uses non-strict semantics ("lazy evaluation". that term isn't quite the same, but it's related). basically means that function arguments (and data structure elements, &c.) are (generally) not evaluated before the function is called (or the data structure built), but only when their value is actually *demanded*
18:45:52 <systemfault> Solonarv: How do you us yahb though?
18:46:00 <systemfault> yahb: traverse_ putStrLn (words "Hello World")
18:46:15 <Solonarv> % -- anything you would type into GHCi
18:46:15 <yahb> Solonarv: 
18:46:29 <Solonarv> % traverse_ putStrLn (words "Hello World")
18:46:29 <yahb> Solonarv: Hello; World
18:46:37 <systemfault> Oh, fun :)
18:46:40 <systemfault> Thanks
18:46:56 <ski> Jexi : apart from Clean, Haskell is more or less unique among more used languages, in this. SML,OCaml,F#,Erlang,Scheme all uses strict semantics, where function arguments are determined before function call
18:47:13 <ski> Jexi : does this help ?
18:47:28 <Solonarv> supersaiyan: clearly there are multiple steps to your task:
18:47:28 <Solonarv>  - get an input from the command line
18:47:28 <Solonarv>  - split a string into a list of words
18:47:28 <Solonarv>  - print each element of a list in a separate line
18:48:26 <ski> supersaiyan : `getLine' can be used to get a line of input from the user
18:48:49 <supersaiyan> Solonarv: thank you. i'm slowly getting it...
18:49:01 <supersaiyan> ski: oh yeah, i have do x<-getLine
18:49:15 <ski> supersaiyan : `mapM_' (and `mapM') is used to loop over a list (or other "structure" containing elements), doing something for each element. you need to get your list (or structure) first, though
18:49:31 <Jexi> Its a bit jibber talk for me, but i get the rough idea, ill try to search around some more. And possibly try to just learn more Object oriented coding and come back to this once i at least know OO to the point i can describe how it works and can make usable code with it.
18:50:06 <ski> supersaiyan : you shouldn't write `putStrLn' directly after the lambda (the `\' symbol), you should write a name you use for "the current element"
18:50:26 <ski> Jexi : *nod*
18:50:27 <supersaiyan> ski: ahhhhhh makes sense
18:50:52 <ski> Jexi : re OO, you might perhaps want to look into Smalltalk, at some point
18:51:49 <Solonarv> I wonder if you could embed Smalltalk in Haskell...
18:52:52 <ski> Jexi : here's one talk by Alan Kay, which might be interesting "The computer revolution hasnt happened yet" in 1997 at <https://www.youtube.com/watch?v=oKg1hTOQXoY>
18:53:43 <Jexi> Ill watch it. thanks
18:53:52 <ski> (also perhaps "We Really Don't Know How to Compute!" by Gerald Sussman in 2011 at <https://www.youtube.com/watch?v=O3tVctB_VSU>)
18:55:12 <ski> ("Kay is one of the fathers of the idea of object-oriented programming, which he named, along with some colleagues at PARC.")
18:56:06 <ski> (and Sussman was one of the authors of the book SICP, that teaches computing science, via Scheme)
18:56:09 <ski> @where SICP
18:56:10 <lambdabot> "Structure and Interpretation of Computer Programs" <http://mitpress.mit.edu/sicp/>,<http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/>,<https://github.com/sarabander/sicp-pdf> | "
18:56:10 <lambdabot> Storage and Identification of Cabalized Packages" <http://www.vex.net/~trebla/haskell/sicp.xhtml>
18:57:05 <supersaiyan> ski: am I on track? x <-getLine
18:57:05 <supersaiyan>  , mapM_ (\x -> words >> words '\n')
18:57:33 <ski> better
18:58:15 <ski> but you need to pass a list as second argument to `mapM_'
18:58:18 <ski> which list ?
18:58:37 <ski> well, that depends on what you want `x' to, successively be
18:59:20 <ski> `x <- getLine' will give you *that* `x' (perhaps rename it, to not confuse it with the *other* `x', in this snippet) as a `String'
18:59:39 <ski> and in Haskell (for better or worse), a `String' is just a list of `Char'acters
19:05:02 <supersaiyan> ski: thanks ski, i think i got it.
19:06:31 <ski> Jexi : re FP, iirc John Carmack had some Quakecon keynote (<https://www.youtube.com/watch?v=1PhArSujR_A> ? some bit into it, iirc) where he talked some about why he thought FP could be interesting, for a game programmer. also his "Functional programming in C++" in 2012-04-26 at <http://gamasutra.com/view/news/169296/Indepth_Functional_programming_in_C.php>
19:06:50 <ski> Jexi : and the slides "The Next Mainstream Programming Languages: A Game Developers's Perspective" by Tim Sweeney at <http://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf> are from a similar perspective
19:07:09 <ski> Jexi : .. just thinking you might be interested in checking these out, at some point
19:07:32 <Jexi> So many links, but i dont want to do game programming :/
19:07:49 <ski> ok, i just thought i'd mention them
19:07:55 <Jexi> yeah, thanks
19:08:25 <ski> supersaiyan : if you don't mind, would you like to show your code ?
19:09:13 <supersaiyan> ski: it's not 100%, but i'll slowly get it... string <-getLine
19:09:13 <supersaiyan>    mapM_ (\x -> putChar x >> putChar '\n') string
19:09:23 <ski> ok
19:09:32 <supersaiyan> ski: is that closer ?
19:09:47 <ski> that'll display each character from the string on its own line
19:10:07 <ski> `string' is a list of characters. `x' will, in succession, be each of those characters
19:10:35 <supersaiyan> ski: can i use putChar [x] ?
19:10:59 <ski> no, but you can use `putStr [x]' (which will do the same as `putChar x')
19:11:35 <ski> you can also use `putStrLn [x]', which will do the same as :  putChar x >> putChar '\n'
19:11:52 <ski> supersaiyan : what's the type of the `words' function that you pondered before ?
19:12:29 <supersaiyan> ski: [char] ?
19:12:35 <ski> sorry, no
19:12:45 <supersaiyan> ski: string ?
19:13:29 <ski> if you can't find the type of the function, in some text/tutorial/doc you're reading, you could ask the interactor, by giving the `:type words' command (which can be abbreviated as `:t words')
19:13:48 <ski> that asks the interactor to figure out the type of the expression (in this case just the name `words')
19:14:19 <supersaiyan> ski: ahhh i see. [string]
19:14:24 <ski> sorry, still no
19:14:37 <ski> what's the *full* thing that it responded with ?
19:14:47 <supersaiyan> ski: String -> [String] 
19:14:50 <ski> right
19:15:04 <ski> the `->' part is crucial, that's what says that this is the type of a function
19:15:41 <supersaiyan> ski: ahhhh i seeee
19:15:51 <ski> the type of the function `words' *itself* is `String -> [String]', which means that it's a function that, if given a `String' as input, will produce an output of type `[String]' (iow will produce an output that is a list of `String's)
19:16:03 * hackage hw-prim 0.6.2.21 - Primitive functions and data types  http://hackage.haskell.org/package/hw-prim-0.6.2.21 (haskellworks)
19:16:32 <ski> *however*, *if* `str' is any `String', then you can pass it as input to `words', as in the function application/call `words str', and *that* expression/call will have type `[String]'
19:16:49 <ski> (which i think was what you were thinking of, before i objected)
19:17:20 <supersaiyan> ski: ahhhh makes sense... 
19:17:23 <ski> so : you can pass any `String' to `words', and you'll get back a list of `String's, ok ?
19:17:56 <supersaiyan> ski: yeah... makes sense.
19:18:04 <ski> (in fact, the list of `String's you get back will be the individual "words" from the input `String', arrived at, by splitting the input `String' at white space)
19:18:24 <ski> so .. what could you do with such a list of `String's ?
19:18:37 <ski> also .. what input `String' could you pass to `words', to begin with ?
19:19:05 <ski> > words "This is a dream"
19:19:07 <lambdabot>  ["This","is","a","dream"]
19:19:10 <ski> is an example of `words' in action
19:19:54 <ski> supersaiyan : so, i want you to ponder those two questions
19:20:06 <supersaiyan> ski: ok, i'm doing that now.
19:20:43 <ski> (and also, perhaps, to think about something that was mentioned earlier, in case it's not already/still/again on your mind)
19:21:03 * hackage composition-prelude 2.0.2.0 - Higher-order function combinators  http://hackage.haskell.org/package/composition-prelude-2.0.2.0 (vmchale)
19:22:03 * hackage dbus 1.1.1 - A client library for the D-Bus IPC system.  http://hackage.haskell.org/package/dbus-1.1.1 (blaze)
19:30:06 * hackage madlang 4.0.2.14 - Randomized templating language DSL  http://hackage.haskell.org/package/madlang-4.0.2.14 (vmchale)
19:31:10 <supersaiyan> ski: am I getting closer?  string <- getLine
19:31:10 <supersaiyan>   (mapM_ . words) (\x -> putStr [x] -> putStrLn [x])
19:32:22 <Solonarv> you're certainly getting closer
19:32:30 <ragusa> "\x -> putStr [x] -> putStrLn [x]" is a syntax error
19:32:47 <supersaiyan> solonarv: thanks
19:33:01 <Solonarv> but indeed, there is a syntax error
19:33:09 <supersaiyan> ragusa: i see... hmmm *thinking hat*
19:36:30 <ski> supersaiyan : i'm not sure you want to complicate stuff here, by using function composition `.'
19:36:59 <ski> remember
19:37:01 <ski> <ski> but you need to pass a list as second argument to `mapM_'
19:37:20 <ski> (you did that before, so i know you can do it)
20:04:03 * hackage hsPID 0.1.2 - PID control loop  http://hackage.haskell.org/package/hsPID-0.1.2 (jlamothe)
20:33:56 <supersaiyan> ski: does this look any better?   string <- getLine
20:33:56 <supersaiyan>   mapM_ words (\x -> putStr [x] >> putStrLn [x]) string
20:34:38 <supersaiyan> ski: im not sure i fully get what you mean by pass list as second argument. wouldn't putStr [x] be the list that gets passed on?
20:34:58 <Solonarv> 'putStr [x]' isn't a list
20:35:28 <supersaiyan> solonarv: ooh.. wow... been attacking this wrong for 30 mins... hmm **thinking cap**
20:37:09 <supersaiyan> Solonarv : would (words . x) be a list ?
20:37:22 <Solonarv> nope
20:37:31 <Solonarv> let's get back to the basics
20:37:50 <Solonarv> you have a function 'f' and a value 'x'. How do you apply 'f' to 'x' ?
20:38:06 <supersaiyan> Solonarv: f x
20:38:30 <Solonarv> very good!
20:38:51 <supersaiyan> Solonarv : words x ?
20:39:05 <Solonarv> close!
20:39:19 <supersaiyan> Solonarv: (words x) ?
20:39:51 <Solonarv> no, no - that *is* how you apply 'words' to 'x', but that's not what we're trying to do
20:40:43 <Solonarv> 'words' takes a string and gives back a list of strings (which are the words in the input)
20:41:01 <Solonarv> what's the thing we want to split into words here?
20:41:14 <supersaiyan> Solonarv: string ?
20:41:20 <Solonarv> precisely!
20:41:40 <supersaiyan> Solonarv: wow ok let me try this...
20:49:12 <supersaiyan> Solonarv: would string be in the anonymous function or no?
20:49:30 <Solonarv> nope
20:49:41 <Solonarv> consider: mapM_ takes two arguments
20:49:48 <supersaiyan> Solonarv: I have this... mapM_words string (\x -> x >> putStrLn x)
20:50:10 <Solonarv> you're applying mapM_ to three arguments
20:50:27 <Solonarv> 'mapM_ someFunction aListOfStuff'
20:52:01 <supersaiyan> Solonarv: mapM_ someFunction(words) aListOfStuff' (string) ?
20:52:21 <Solonarv> not quite
20:52:37 <Solonarv> remember, the thing we want to do is 'for each word, print that word'
20:53:11 <Solonarv> so perhaps it should be 'mapM_ printTheWord theWordsWeWantToPrint' ?
20:55:16 <supersaiyan> Solonarv: would I utilize the print function?
20:56:12 <Solonarv> ignore that for now
20:56:39 <Solonarv> what does 'theWordsWeWantToPrint' look like?
20:57:11 <supersaiyan> (words string) ?
20:57:16 <Solonarv> exactly!
20:57:30 <supersaiyan> ***thinking***
20:57:39 <Solonarv> so we have 'mapM_ something (words string)' -- makes sense?
20:58:28 <supersaiyan> Solonarv: ahhh i see.... would that something be print or an anonymous function ?
20:58:59 <Solonarv> putStrLn, not print
20:59:28 <Solonarv> % print "word"
20:59:29 <yahb> Solonarv: "word"
20:59:38 <Solonarv> % putStrLn "word" -- see the difference?
20:59:38 <yahb> Solonarv: word
21:00:32 <supersaiyan> ahhh i see..
21:05:59 <supersaiyan> Solonarv: thank you for your guidance!!
21:06:08 <supersaiyan> Solonarv: I reallly appreciate it :))
21:11:50 * ski idly wonders whether supersaiyan ended up using a function abstraction/literal/expression or not
21:13:54 <supersaiyan> ski: haha, i figured it out with a lot of help in less than 3 hours :
21:14:03 <supersaiyan> :')
21:14:39 <Solonarv> out of curiosity, what was your final solution?
21:15:03 <supersaiyan> Solonarv:  string <- getLine
21:15:03 <supersaiyan>    mapM_ (\x -> putStrLn x) (words string)
21:15:37 <Solonarv> ski: there's your answer :D
21:16:36 <supersaiyan> i think a lot of had to due with syntax though
21:16:40 <ski> Solonarv : fwiw, it's possible to abbreviate `(\x -> putStrLn x)' as just `putStrLn', there
21:17:06 <supersaiyan> i had  mapM_words (\x -> putStrLn x) string ... almost 30 mins ago...
21:17:15 <ski> a function that, when called with an input, call it `x', will call `putStrLn x', *behaves* exactly the same as the function `putStrLn' itself
21:17:29 <ski> (this holds for any function, this isn't anything particular to `putStrLn')
21:17:40 <supersaiyan> ski: let me see..
21:17:44 <ski> this simplification is called "eta contraction/reduction"
21:18:11 <ski> (the opposite is "eta expansion". both refactoring directions, taken together are called "eta conversion")
21:18:36 <supersaiyan> ski: you're right, i did not know that
21:19:27 <ski> in general, if two functions compute the same outputs, for all possible inputs, then they're considered to be equal functions : this is called "function extensionality". it's onlt the "input-to-output behaviour" of functions that matter, when identifying them
21:19:43 <supersaiyan> ski: ahhhh...
21:19:43 <ski> "function extensionality" is closely related to "eta conversion"
21:20:34 <Solonarv> but it's more general: for example, '\x -> 2 * x' and '\x -> x + x' are equal, too (assuming they're restricted to Int)
21:21:23 <ski> (of course, one formulation of a function may still be more efficient than the other. but saying that they're equal means that we're relying on the *behaviour* of the program to stay the same (not including how much time and memory it uses, how much it heats the CPU up), if we exchange one version/algorithm with another. that's the point, we want to be able to swap about algorithms, but keeping functionality)
21:21:59 <ski> yes, because if the first function is called with any input `x' (say of type `Int', as Solonarv suggested), it will compute `2 * x'
21:22:10 <ski> and the second function, if called with input `x', will compute `x + x'
21:22:35 <ski> but it's an arithmetic fact (theorem, if you want) that `x + x' is equal to `2 * x', for any integers `x'
21:22:46 <supersaiyan> ahhhhh
21:24:18 <ski> therefore Solonarv's two functions are also equal
21:25:08 <ski> supersaiyan : however, if you had had something more complicated inside the function abstraction, then you possibly couldn't have "abbreviated" the function (callback) argument to `mapM_', like this
21:26:02 <ski> supersaiyan : but, `mapM_ f xs' is the same as `forM_ xs f' (and `mapM f xs' is the same as `forM xs f'. these latter versions also collect a list of results, that's the difference with `mapM_' and `forM_')
21:26:09 <ski> supersaiyan : so, instead of
21:26:16 <ski>   mapM_ (\x -> putStrLn x) (words string)
21:26:19 <ski> one can say
21:26:29 <ski>   forM_ (words string) (\x -> putStrLn x)
21:26:45 <ski> and if we imagine instead that we had, say
21:26:58 <ski>   forM_ (words string) (\x -> putStrLn x >> putStrLn "---")
21:27:21 <ski> which is the same as (using `do'-notation, not sure whether you've seen this yet)
21:27:34 <ski>   forM_ (words string) (\x -> do putStrLn x; putStrLn "---")
21:27:42 <ski> and we can write this as
21:27:49 <ski>   forM_ (words string) $ \x -> do
21:27:54 <ski>     putStrLn x
21:27:57 <ski>     putStrLn "---"
21:28:16 <ski> (with a recent extension, `BlockArguments', we can finally get rid of the `$' here ..)
21:28:27 <supersaiyan> ski: ahhh wow that's really advanced.... im no where near knowing any of this...
21:28:27 <Solonarv> or:
21:28:27 <Solonarv> words string `forM_` \x -> do ...
21:28:48 <ski> supersaiyan : the point is that we can write this, so that it looks more like a "traditional `for' or `while' loop, in imperative programming"
21:29:03 * ski nods to Solonarv
21:29:32 <supersaiyan> ahhh i see...
21:29:41 <ski> supersaiyan : `forM_' (and `forM') is typically used when the function expression is larger than the list expression, so that it's easier to first read the list expression
21:29:44 * Solonarv really likes `for` / `for_`
21:30:07 <ski> the function expression could span many lines, possibly itself having "subloops", calls for `forM_'
21:30:11 <ski> s/for/to/
21:30:50 <ski> supersaiyan : an alternative would be to give a *name* to the "loop body" (the function/callback argument)
21:31:13 <ski>   blah x y ... = mapM_ doIt (words string)
21:31:15 <ski>     where
21:31:18 <Solonarv> e.g.
21:31:18 <Solonarv> [1..10] `for_` \i -> do {- some huge procedure... -}
21:31:27 <ski>     doIt x = do putStrLn x
21:31:35 <ski>                 putStrLn "---"
21:32:17 <Solonarv> In Haskell there are often many ways to write the same thing.
21:32:43 <supersaiyan> ooooo
21:32:43 * Solonarv o . O one of the many ways in which it differs from python
21:33:16 <supersaiyan> why are we comparing haskell with python? haha
21:33:48 <ski> (yea, the difference between `for_',`for', and `forM_',`forM' is that the former two only assumes an idiom (aka applicative functor). the latter two requires a monad. they are separate basically only for historical reasons (idioms being invented later than monads). if you wonder about what corresponds to `mapM_',`mapM', then those are called `traverse_',`traverse')
21:34:20 <Solonarv> in this case, because one of python's "rules" is that there should be only one way to do something
21:35:02 <ski> (it's fine if you use `for_',`for',`traverse_',`traverse', in place of `forM_',`forM',`mapM_',`mapM')
21:35:12 <Solonarv> in fact, I'd even recommend it
22:07:11 <koz_> I instinctively prefer traverse_, but that might be because I do a lot of mutable array loops.
22:07:19 <koz_> For which traverse_ just seems perfectly suited.
22:34:03 * hackage http-conduit 2.3.4 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.3.4 (MichaelSnoyman)
22:43:04 <platz> so i found the secret to getting persistent migrations to work in sqlite is to disable foreign keys on the connection.
22:43:53 <platz> by setting fkEnabled=False the migrations can swap data to backup tables without failing
