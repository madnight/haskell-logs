00:00:45 <teto> haskdogs prints an error "Could not find module ‘System.Linux.Netlink.C’ it is a hidden module in the package ‘netlink-1.1.1.0’", what's a hidden module ? is there any way around ?
00:01:58 <devoid_> add netlink to the cabal file
00:02:00 <devoid_> maybe
00:02:32 <trcc> Any way to improve this? https://gist.github.com/CThuleHansen/62f96168738e75b52615b780714acaeb I am sort of thinking lifting union into IO Maybe, but I cannot figure out how to do the double lifting
00:05:39 <MarcelineVQ> Might that be  (liftA2 . liftA2) union (fileToJson f1) (fileToJson f2)
00:07:11 <MarcelineVQ> or  liftA2 (liftA2 union) (fileToJson f1) (fileToJson f2)
00:08:56 <trcc> thanks MarcelineVQ
00:09:00 <trcc> the first one worked fine
00:09:17 <dminuoso> semantic editor combinators at work?
00:19:21 <teto> devoid_: thanks but it is already in the file. doesn't seem very important anyway
00:28:20 <dminuoso> Okay, so Ive been using exceptions for control flow for a while now - and it's pretty cool to shortcircuit computation in IO. Right now I use newtype wrappers to control where exceptions are caught and returned into results.. and it's kind of neat.
00:29:03 <dminuoso> The interesting bit is - like a mantra I learned that exceptions for control flow are bad in traditional languages, but never with real good reasons.
00:35:51 <MarcelineVQ> "<dminuoso> semantic editor combinators at work?"  :(  ((liftA2 . liftA2 . liftA2 . liftA2) union (. fst) (. snd) fileToJson .) . (,)
00:37:36 <MarcelineVQ> :t (liftA2 . liftA2 . liftA2 . liftA2)  --  :(
00:37:37 <lambdabot> (Applicative f4, Applicative f3, Applicative f2, Applicative f1) => (a -> b -> c) -> f1 (f2 (f3 (f4 a))) -> f1 (f2 (f3 (f4 b))) -> f1 (f2 (f3 (f4 c)))
00:39:07 <spoonm> pointfree much?
00:39:17 <MarcelineVQ> Sometimes you just gotta let your hair down
00:39:26 <koz_> :t traverse . traverse . traverse
00:39:27 <lambdabot> (Traversable t3, Traversable t2, Traversable t1, Applicative f) => (a -> f b) -> t1 (t2 (t3 a)) -> f (t1 (t2 (t3 b)))
00:39:30 <koz_> :D
00:43:21 <trcc> https://www.reddit.com/r/haskell/comments/a1qpzo/haskell_and_ffi_shard_object_call_haskell_from/ in case someone has good ideas on partly exposing a haskell ffi function :)
00:44:06 <merijn> trcc: Why "without exporting"?
00:44:50 <trcc> hmm shoudl maybe have been exposing..
00:44:59 <trcc> merijn: because it is not part of the standard
00:45:27 <trcc> And I am not interested in the function being invoked more than once, and therefore I would like to control it
00:45:43 <merijn> trcc: "not part of the standard"? says who?
00:45:51 <merijn> The FFI is part of the Haskell Report
00:46:03 <trcc> the standard c-interface that my application must adhere to
00:46:13 <merijn> Anyway "calling a haskell function without exporting it" is impossible
00:46:32 <spoonm> merijn: it doesn't mean one can't try
00:46:34 <merijn> Without a foreign export GHC doesn't generate a linker symbol with a C compatible ABI
00:47:19 <merijn> spoonm: Well, if you're willing to reverse engineer GHC unstable ABI across different platforms and write your own custom assembly to invoke it and someone patching the linker to support all this, then yes, you can try
00:47:40 <trcc> merijn: there is not special way of only exposing it to the accompanying c-file?
00:48:12 <merijn> trcc: No, because neither C nor Haskell support anything like that
00:48:44 <merijn> Honestly, I can't imagine many things that will be more painful than attempting this
00:48:54 <trcc> okay. Thank you!
00:49:06 <merijn> (and I can imagine some pretty painful programming tasks!)
00:49:39 <trcc> to cite fight club: Even more painful than someone cutting of your penis and throwing it out the window of a moving car? :)
00:50:03 <trcc> anyways, I will probably use a global variable to ensure, that the setup only occurs once
00:50:20 <merijn> trcc: What are you trying to do?
00:50:53 <trcc> I am trying to develop a framework, and part of this framework is invoking a function provided by the one using the framework
00:51:10 <trcc> currently this function is stored in a global mutable variable as part of this setup routine
01:00:56 <Ariakenom> dminuoso: Yeah I can recognize that fear of exceptions from some. It's probably worse in not-haskell because interrupting a mutation could corrupt the data.
01:01:35 <merijn> My long term life goal is to fix Haskell's exception mess
01:01:59 <Ariakenom> how's it going?
01:02:03 <merijn> Unfortunately, that's both a fairly considerable engineering task and backwards incompatible change in Haskell...also, no one is willing to pay for it
01:02:11 <Ke> merijn: perhaps some day make haskell standard that ghc supports by default
01:02:27 <spoonm> merijn: if you do it, I'll buy you a beer
01:02:31 <merijn> Ariakenom: It's not :p I have some half arsed prototypes that need a lot more work to prove the general ideas
01:02:36 <Ke> it's actually perhaps the main thing about haskell that bothers me
01:02:44 <spoonm> I'll throw in a "thanks, bro" if you comment the code well
01:03:04 <Ke> there is no standard haskell you can work with
01:03:12 <merijn> spoonm: Considering it'd probably take like 1 years worth of work to finish something like that, that's about $40k below what I'd need ;)
01:03:31 <spoonm> merijn: how much is a beer?
01:03:49 <Ariakenom> merijn: what are the main things you wanna change?
01:03:59 <merijn> Ariakenom: I want checked, but inferred exceptions
01:05:01 <merijn> Ariakenom: So I *don't* want to: 1) use something like either (we already have that), and 2) I don't want to manually annotate the code between throw and catch with the fact that it might throw (you know, the annoyance of checked Java exceptions)
01:05:33 <merijn> Ariakenom: But I *do* want exceptions to be checkable so you can ask the compiler "this can't throw anything, right?" and statically know what you need to catch/handle
01:07:36 * hackage kind-apply 0.2.0.0 - Utilities to work with lists of types  http://hackage.haskell.org/package/kind-apply-0.2.0.0 (AlejandroSerrano)
01:08:22 <merijn> And I feel I have a pretty good idea about *how*, but actually prototyping is type consuming so I'm currently putting in 0 effort, given that I have both a job, a thesis to finish, and a quota of IRC slacking to meet ;)
01:08:39 <MarcelineVQ> all equally important
01:09:03 * hackage kind-generics 0.2.1.0 - Generic programming in GHC style for arbitrary kinds and GADTs.  http://hackage.haskell.org/package/kind-generics-0.2.1.0 (AlejandroSerrano)
01:15:01 <bahamas> why would stack build just freeze? it's stuck at this step: Finished writing /Users/lucian/dev/purifier/.stack-work/install/x86_64-osx/lts-12.20/8.4.4/flag-cache/purescript-0.12.1-Cm4CcjmSwuqDotAIru01rh
01:16:07 <Lycurgus> for how long?
01:16:14 <bahamas> Lycurgus: a few minutes
01:16:43 <Lycurgus> on a  fast machine?
01:17:24 <gehn> how do I see $PWD inside of ghci?
01:17:31 <gehn> I know I can set it with :cd but how do I see what it is right now?
01:19:02 <bahamas> Lycurgus: macbook air 2014 i7 cpu
01:19:23 <Lycurgus> my guess would be some system corruption
01:20:06 <Lycurgus> just don't see many hangs these days for any other reason, less so in this culture
01:20:12 <bahamas> Lycurgus: how can I fix it?
01:20:44 <Lycurgus> interrupt and examine the environment but probably more practical
01:20:51 <Lycurgus> to start over
01:21:14 <bahamas> Lycurgus: delete .stack-work?
01:22:21 <Lycurgus> well in the limit remove haskell entirely and reinstall with whatever you were using on macos, ports or whatever
01:23:02 <Lycurgus> most advanced computing these days is oriented for linux
01:23:36 <Lycurgus> windows and mac don't get the love
01:25:27 <Lycurgus> i'd be especially leary of stack on mac
01:26:55 <MarcelineVQ> This doesn't sound like especially useful information, if at all accurate.
01:27:04 <MarcelineVQ> bahamas: sure, try removing .stack-work and trying again, if it hangs again it would be a good idea to make a git issue about it. https://github.com/commercialhaskell/stack/issues
01:27:29 <Lycurgus> *leery
01:27:32 <MarcelineVQ> gehn: :! pwd  is one way
01:28:46 <Lycurgus> MarcelineVQ, no? I thought it was, in a Gordian knot kinds way, which as you know is mine.
01:29:04 <Lycurgus> and I did say to find out why interrupt and examine
01:29:10 <MarcelineVQ> your name is Gordie?
01:29:35 <Lycurgus> Howe could you think that?
01:30:10 <MarcelineVQ> gehn: another way is to  import System.Directory  and use  getCurrentDirectory
01:30:37 <adius> If I have a function, I can inject dependencies like:
01:30:37 <adius> ```
01:30:37 <adius> sayHi unwords name =
01:30:37 <adius>   unwords ["Hi", name]
01:30:37 <adius> ```
01:30:37 <adius> But in the signature the `String` is somewhat static.
01:30:37 <adius> ```
01:30:38 <adius> sayHi :: String -> String
01:30:38 <adius> ```
01:30:39 <adius> Is there a way to inject types into type signatures?
01:31:10 <merijn> That type signature is...not right...
01:31:19 <merijn> Also, please don't paste more than 1-2 lines
01:31:20 <Lycurgus> *kinda
01:31:35 <Lycurgus> *my way
01:31:52 <spoonm> adius: sayHi :: ([String] -> String) -> String -> String is what you have now
01:33:10 <bahamas> MarcelineVQ: question about slack. if I list a dependency in extra-deps without specifying a version, will it look for it on the file system? I ask, because I had language-python locally and after I removed it, I see this error: "purifier/language-python/: getDirectoryContents:openDirStream: does not exist (No such file or directory)"
01:33:22 <adius> Yeah, I know, sorry. The signature was for `sayHi name =  ["Hi", name]`. Doesn't change the question ...
01:33:25 <spoonm> you can have some sayHi :: Foldable t => (t a -> a) -> a -> a, but if you're gonna use unwords and "Hi", you'll use anything that can be String
01:34:01 <spoonm> adius: what exactly do you want to insert there? ["Hi", _] will be [String]
01:34:11 <adius> But in `sayHi :: Foldable t => (t a -> a) -> a -> a` the `Foldable` is still static
01:34:18 <merijn> Best you can do with that implementation is: "sayHi :: (IsString s, Foldable t) => (t s -> a) -> s -> a"
01:34:51 <MarcelineVQ> bahamas: it's possible, since you can specify local folders as extra-deps
01:34:58 <merijn> adius: Honestly, I'm not entirely sure what the question is?
01:35:16 <spoonm> merijn: possibly inserting IsString as a constraint instead of using String
01:35:24 <adius> I want to make the functions completely independent from all external dependencies, but I still need `import Prelude (String)` for it to work
01:35:43 <merijn> What does "independent of all external dependencies" mean?
01:35:54 <adius> If there was a way to inject the implemention of `String` I want to use I could avoid this problem
01:37:22 <merijn> adius: How do you expect to use string literals without using String?
01:37:38 <olligobber> adius, `sayHi :: a -> (a -> a -> a) -> a -> a; sayHi hi unwords name = unwords hi name`
01:37:51 <bahamas> MarcelineVQ: ok. here's my problem. I need to use language-python from github, because the version on hackage doesn't build with ghc 8.4. I added it to my stack.yaml under packages with location: git: url, commit: hash, but when I run stack build, I see this error: language-python needed, but the stack configuration has no specified version
01:37:57 <adius> olligobber: I tried this, but it's not compiling
01:38:14 <MarcelineVQ> bahamas: you add it under extra-deps, packages is for things that are part of your project, not for dependencies
01:39:08 <adius> merijn: With OverloadedStrings?
01:39:21 <merijn> adius: Then you'd depend on the IsString class
01:39:35 <merijn> adius: Also, you'd depend on the implementation of lists in your initial example
01:39:40 <MarcelineVQ> bahamas: I'm surprised it wasn't a parse error though, maybe you're using an older stack version, what version do you have?
01:39:49 <merijn> I just don't see the point of "writing code with no external dependencies"
01:39:59 <merijn> It's possible, but it's just a whole lot of work for little to no gain
01:40:08 <mniip> is it possible with GHC though
01:40:19 <mniip> also, guard syntax depends on Bool
01:40:23 <olligobber> adius, what I suggested should work, example use being `sayHi "Hi " (++) "adius"`
01:40:36 <merijn> mniip: I think it's not senssible anyway
01:40:48 <bahamas> MarcelineVQ: I have stack 1.7.1
01:41:06 <merijn> mniip: I mean, does any real language support it?
01:41:08 <Ariakenom> merijn: (about exceptions) I see, interesting.
01:41:15 <MarcelineVQ> k good, try moving that stuff to extra-deps, if you still have a problem then link your stack.yaml in a paste
01:41:18 <merijn> mniip: Even assembly has a bunch of built-in assumptions
01:41:21 <olligobber> my suggestion depends on (->) though, is that an acceptable dependency?
01:41:58 <mniip> merijn, freestanding C?
01:42:32 <merijn> mniip: Even that has a whole bunch of builtin-assumptions about datatypes
01:43:00 <merijn> I mean, untyped lambda calculus doesn't have any builtins
01:43:07 <merijn> But no sane language works like that
01:43:15 <bahamas> MarcelineVQ: how do I add an extra dep from github?
01:44:41 <MarcelineVQ> bahamas: https://gist.github.com/MarcelineVQ/7ae7380f656bcc263e3f45251e32e5dd  this is how you would add acme-missiles from hackage and stack from git as dependencies for your project
01:44:41 <adius> Yeah I guess, there has to be a lower limit of things you have to assume. I'm Just trying to figure out where it is. 
01:44:41 <adius> It bothers me that Haskell functions aren't really pure. `showHi name = unwords ["Hi", name] depends on a global implementation of `unwords`. So the output is not only dependent on it's arguments.
01:45:14 <merijn> adius: That implementation is static and unchanging, though
01:45:18 <merijn> adius: So it *is* pure
01:45:33 <merijn> adius: If all global definitions are static and unchanging then things still only depend on their input arguments
01:46:10 <merijn> Because unwords behaviour can't change and the behaviour of unwords is also pure
01:46:46 <adius> `unwords _ = "I WILL NOT GREET YOU"` 😉
01:47:06 <merijn> So?
01:47:11 <adius> I wonder if it wouldn't be cleaner to track all dependencies in a state monad
01:48:11 <adius> If I move the function into a new file, or new project, the implementation unwords behaviour can change
01:49:40 <bahamas> MarcelineVQ: then this answer is wrong: https://docs.haskellstack.org/en/stable/faq/#i-need-to-use-a-package-or-version-of-a-package-that-is-not-available-on-hackage-what-should-i-do
01:51:28 <MarcelineVQ> bahamas: correct, that is not how it's done anymore. It might still work that way, but it's not the reccomended way, the reccomended way is: https://docs.haskellstack.org/en/stable/yaml_configuration/#packages-and-extra-deps
01:53:03 <bahamas> MarcelineVQ: it wasn't working for me. I think that was the reason for the hanging
01:53:14 <MarcelineVQ> Are things working now?
01:54:15 <bahamas> MarcelineVQ: it's building. btw, it would be great if there was clearer feedback on whether things are happening or the process is stuck. it's showing me: language-python-0.5.5: build (lib)
01:54:19 <bahamas> Progress 0/2
01:54:56 <MarcelineVQ> yeah it's pretty quiet about what it's doing with dependencies, often that's because there's a few being built at a time
01:55:23 <MarcelineVQ> I think it just says the steps of config, build, copy
02:02:24 <MarcelineVQ> bahamas: https://github.com/bjpop/language-python/issues/41 this thread is a little scary
02:03:50 <MarcelineVQ> you might need to use a more recent ghc to build this in a timely fashion,  if it seems to hang again try setting   resolver: ​nightly-2018-11-30  in your stack.yaml to use a more recent ghc
02:04:58 <MarcelineVQ> seems like osx might be slow on this for some reason or another
02:16:41 <bahamas> MarcelineVQ: oh, geez. thanks for spotting that. trying with nightly now
02:20:33 * hackage xeno 0.3.5.1 - A fast event-based XML parser in pure Haskell  http://hackage.haskell.org/package/xeno-0.3.5.1 (ocramz)
02:21:58 <bahamas> MarcelineVQ: ok, now my problem is that purescript requires an older version of base
02:23:15 <bahamas> MarcelineVQ: nix might be my saviour. it already compiled most of the package
02:32:48 --- mode: glguy set +v bwuietp
02:35:19 <jle`> finally cracked down to learn how to use TH for my automated advent of code runner
02:39:37 <bahamas> anyone know what kind of file this is? https://github.com/bjpop/language-python/blob/master/src/Language/Python/Version2/Parser/Parser.y the compiler is spending a lot of time on it
02:39:54 <merijn> Alex generated parser
02:40:09 <merijn> Or maybe happy, one of the two
02:42:27 <bahamas> is it normal to take so long to compile this kind of file?
02:43:38 <merijn> "It Depends"
02:43:53 <merijn> Depends on the generated source
02:44:32 <Ariakenom> response question = "It depends."
02:46:05 <dminuoso> bahamas: How long is "long"
02:46:17 <Ariakenom> > length "long"
02:46:19 <lambdabot>  4
02:46:41 <dminuoso> Oh. Clearly.
02:47:24 <merijn> bahamas: In general it's a well known issue that GHC doesn't deal well with deriving typeclasses for datatypes with a lot of constructors. So if the generated .y does that, then it's...well, not normal, but at least expected
02:48:11 <bahamas> dminuoso: it's been 5 minutes. or maybe 10?
02:51:04 <Lycurgus> .y is the standard extension for yacc, if there were one
02:51:18 <bahamas> merijn: this user says that he built language-python in under 1 minute, so I wonder what's different https://github.com/bjpop/language-python/issues/41#issuecomment-440141751
02:51:25 <Lycurgus> and yacc follow ons
02:51:30 <dminuoso> bahamas: Perhaps a gcc regression.
02:53:03 <MarcelineVQ> he's also not on osx, many important low-level things are quite different on osx than linux
02:55:24 <bahamas> hm. so I guess the next step is to build everything inside docker or a VM hoping to make this faster
03:14:57 <merijn> hmm, it feels like I should be able to simplify "a || (!a && b)" somehow, but it keeps escaping me...
03:15:07 <jle`> truth table?
03:15:54 <jle`> a || (!a && b) = (a || !a) && (a || b) = True && b = True
03:15:55 <geekosaur> || effectively short-circuits, so that should be a || b? 
03:16:26 <jle`> er, that last one should be True && (a || b) = True
03:16:38 <merijn> geekosaur: Yeah, looks like that is right
03:16:42 <merijn> Incidentally
03:16:50 <merijn> This is awesome: http://web.stanford.edu/class/cs103/tools/truth-table-tool/
03:16:59 <jle`> or a+(!a*b) = (a+!a)*(a+b) = 1 * (a+b) = 1
03:17:36 <jle`> where did i go wrong :'(
03:17:56 <jle`> oh, True && x = x
03:18:26 <jle`> so a + (!a*b) = (a+!a) * (a+b) = 1 * (a+b) = a+b
03:19:21 <jle`> a || (!a && b) = (a || !a) && (a || b) = True && (a || b) = a || b
03:23:49 <matheus23> Hello, I'm having issues with 'stack ghci' and package imports.
03:24:44 <matheus23> I have a module as a 'package' dependency (in my stack.yaml there is a reference to the folder the package is defined in): packages: ../elm-compiler
03:25:43 <geekosaur> is it in the cabal file (or package.yaml)? if not, the stack.yaml entry won't be used
03:25:45 <matheus23> it defines a module "Reporting.Region", I also have a dependency "elm-format", which is referenced the 'normal' way in my .cabal file
03:26:05 <matheus23> geekosaur: its both, in the .cabal file and the packages (in my stack.yaml)
03:26:43 <matheus23> To import the right module, I use PackageImports: import "elm" Reporting.Region
03:27:00 <matheus23> this works when running stack build, but fails when running stack repl with the error
03:27:11 <matheus23> Could not find module ‘Reporting.Region
03:27:45 <matheus23> when I remove the package import it works in stack ghci, but not in stack build
03:28:42 <matheus23> its kind of hard to explain this issue for me... Basically the imports seem to work differently depending on whether I'm running stack ghci or stack build. And because of that I have to either add a package import annotation or remove it :/
03:29:38 <geekosaur> that actually amkes some sense. the difference is that ghc doesn't have to have both in scope at the same time, but ghci does
03:30:26 <matheus23> what do you mean by both in scope? By what I assume you mean, import Reporting.Region shouldn't work in the repl at all
03:30:33 <geekosaur> because you can have modules using each of them active at the same time
03:31:30 <matheus23> but why does "import Reporting.Region" work in ghci then? If that is ambiguous, why does it just work? :D
03:31:43 <geekosaur> when you are building, it can load one of tem whiel compilinga modle using it, then unload it again wen it's done, so no conflict
03:32:10 <geekosaur> ghci has to keep both around, ebcause it gives you a prompt afterward which can inspect modules using both packages
03:32:47 <geekosaur> but they can't both be loaded at the same time, only one can "own" the name at any given tme
03:34:34 <matheus23> I think understand what you mean. However, stack ghci doesn't actually fail, when I remove the package imports. It seems like only the elm package ever owns the "Reporting.Region" namespace 
03:34:34 * hackage pairing 0.1.4 - Optimal ate pairing over Barreto-Naehrig curves  http://hackage.haskell.org/package/pairing-0.1.4 (sdiehl)
03:35:21 <geekosaur> most likely it doesn't even check for that, so the last one loaded wins
03:36:06 <matheus23> shouldn't ghci 'just' also respect PackageImports? Its useful for exactly these disambiguation problems
03:36:24 <matheus23> oh but yeah. I see what you mean about the namespace
03:36:55 <matheus23> however, stack ghci loads a module fine with "import Reporting.Region" and "import qualified "elm-format" Reporting.Region as ElmFormat"
03:37:10 --- mode: glguy set +v Fraus
03:38:12 <geekosaur> yes, because you renamed te namespace it's using
03:38:42 <geekosaur> a m,roe precise specificaton would be that both are "loaded", and internally it uses distnct identifiers for them. but only oen of those can "own" the name Reporting.Region
03:39:10 <Fraus> Hey! I recently started doing Project Euler in Haskell, and I don't understand how one of the solutions provided "fibonacci = 1 : 2 : (zipWith (+) fibonacci (tail fibonacci))", this provides us with an infinite list of fibonacci numbers, but I don't understand the last part, how does this work?
03:39:14 <geekosaur> so if you rename it during import (import qualified ... as), you avoid that collision
03:39:15 <matheus23> okay, but "import qualified "elm" Reporting.Region as Elm; import qualified "elm-format" Reporting.Region as ElmFormat" fails ghci
03:40:45 <matheus23> and "import qualified Reporting.Region as Elm; import qualified "elm-format" Reporting.Region as ElmFormat" doesn't
03:40:55 <matheus23> (note the missing package import in the first import)
03:42:11 <geekosaur> that I can't help with. might be worth asking on haskell-cafe. but there might well be some untested edge conditions in PackageImports; its use is generally not recommended, because it's confusing
03:46:01 <matheus23> geekosaur: is there an alternative to PackageImports with stack? I've seen cabal mixins, but they don't seem to be supported by stack...
03:47:23 <geekosaur> not that I know of, but I don't use stack
03:54:43 --- mode: glguy set +v mariatsj_
03:54:55 <mariatsj_> Fraus: The function calls itself with the pair-wise addition of two infinite lists. By shifting the second one "one place to the right" (using tail), it results in the definition of fibonacci, which is the sum of two previous things in the list
03:59:37 <matheus23> Hi all, can I reference a local folder in "extra-deps", similar to how one can reference a git url?
03:59:45 <matheus23> (in a stack.yaml file)
04:00:55 <lyxia> nowadays you add that folder under "packages:" as   "- location: foo/bar/\n  extra-dep: true"
04:02:02 <matheus23> oh you can specify "extra-dep: true"? Does that make it behave similar to extra-deps? lyxia 
04:02:14 <lyxia> yes
04:03:28 <matheus23> OH MY GOD THANK YOU
04:03:34 <lyxia> in older versions you could add the location to "extra-deps:", I think you still can for backwards compat, I'm not sure why they changed it.
04:04:01 <matheus23> this fixes all my package-import-different-behaviour-between-build-and-repl-issues
04:04:27 <matheus23> now I can package-import modules from something thats an extra-dependency in ghci just as I would when I build the project
04:04:29 <matheus23> thanks! :)
04:04:53 <lyxia> or actually it might be the other way around...
04:06:25 <lyxia> matheus23: sorry I may have gotten mixed up, the manual says to put your path in extra-deps:  https://docs.haskellstack.org/en/stable/yaml_configuration/#local-file-path
04:06:59 <lyxia> so what I said might be the old way
04:07:26 <matheus23> lyxia: Nice, It works :) Using the new way now
04:33:37 * hackage leancheck-instances 0.0.1 - Common LeanCheck instances  http://hackage.haskell.org/package/leancheck-instances-0.0.1 (rudymatela)
04:42:07 <syniseth> Why does this not work " tupleToList :: (a, b) -> [a, b]  "?
04:42:25 <syniseth> If I let type inference it just does (a,a) -> [a]
04:42:48 <merijn> syniseth: Lists can hold only one type of element
04:42:57 <echoreply> I’m working through data61 course. In Parser.hs Applicative instance, a tip was given to use bind operator to implement it. This feels strange to me, because I understood that monad is more powerful than applicative and that you don’t need a monad instance to implement applicative one
04:43:11 <syniseth> omg thank you
04:43:14 <merijn> echoreply: Correct
04:43:26 <syniseth> so obvious... 
04:43:30 <syniseth> I
04:43:32 <syniseth> I
04:44:07 <merijn> echoreply: Applicative is a superclass of Monad, so less things are Monads than Applicatives and the Monad interface can do more than the Applicative one. However, that doesn't say anything about which operation is easier to write code for :)
04:44:14 <syniseth> My bad didn't mean to type that twice, I'm a haskell scrub rn, I heard Haskell also has arrays which would be suitable for this?
04:44:36 <cocreature> echoreply: you don’t need it but if you have it available then why not use it
04:44:55 <merijn> syniseth: There's a bunch of different array datatypes, Array from Data.Array is the simplest, but doesn't perform well when not used "read-only"
04:45:14 <merijn> syniseth: There's also various vector types in the "vector" package which has better performance
04:45:20 <cocreature> arrays aren’t different from lists when it comes to storing elements of different types
04:46:42 <merijn> echoreply: Basically, what they're saying is that implementing (as in writing code) >>= is easier than <*>, and once you have >>= you can use that to implement <*>
04:47:15 <echoreply> Clear
04:48:26 <merijn> echoreply: Similarly, the monad class and laws would've been nicer if defined in terms of "return" and ">=>", but it's generally easier to write code for >>= than >=>, so the class is defined that way
04:50:23 <merijn> echoreply: Related note: Unlike OO inheritance, the fact that a class is a "superclass" doesn't require any sort of ordering in implementation. The compiler just cares that "must have Applicative if instancing Monad", the fact that the Applicative implementation calls the Monad code is unimportant
04:56:41 <confusedwanderer> that's the other way around, right? the monad implementation calls the applicative code
04:56:58 <merijn> confusedwanderer: Doesn't have to
04:57:14 <confusedwanderer> right, but if it does it's the other way around
04:57:18 <merijn> confusedwanderer: That's my point. Superclass relations don't mean anything in terms of *what code calls what*
04:57:54 <merijn> All GHC cares about is "both definitions exist" (and shouldn't call each other, because then you get an infinite loop for obvious reasons)
04:58:42 <confusedwanderer> oh i see
05:06:15 * geekosaur still thinks using OOP terminology there was a mistake
05:07:29 <geekosaur> we're already fixing "return", why'd we have to add a worse one?
05:12:00 --- mode: glguy set +v bruteforcecat
05:33:59 <Unhammer>     No instance for (Eq ZonedTime) arising from a use of ‘==’
05:34:00 <Unhammer> um
05:34:16 <Unhammer> I know time is Difficult, but … can someone explain why?
05:34:41 <__monty__> Unhammer: Because you didn't write one probably.
05:34:57 <Unhammer> https://hackage.haskell.org/package/time-1.8.0.2/docs/Data-Time-LocalTime.html#t:ZonedTime
05:35:04 <Ariakenom> Unhammer: they may have different time zones
05:35:20 <Unhammer> Ariakenom ZonedTime include the TimeZone
05:35:31 <Ariakenom> so maybe ambiguous between same local time or same time normalized
05:35:33 <Unhammer> wait, LocalTime and TimeZone have Eq, so that makes no sense
05:35:46 <Unhammer> what's normalized
05:36:24 <Ariakenom> do you want to compare their utc time or local time. extract that part
05:36:25 --- mode: glguy set +v noipmusp
05:36:27 <noipmusp> Given "loadString :: IO (Maybe String)", how to print that string within IO context without using case check for Just/Nothing?
05:36:31 <Ariakenom> but it's unclear which is right
05:36:43 <__monty__> Unhammer: Just because the parts have Eq instances doesn't mean the whole does. It obviously doesn't from the documentation. It *could* be derived but they didn't, maybe with good reason?
05:36:51 <merijn> noipmusp: Well, what do you expect to do if you don't have a String?
05:36:55 <Unhammer> yeah, I just wonder what that reason is
05:36:58 <noipmusp> To do nothing.
05:37:40 <Ariakenom> :t maybe
05:37:41 <lambdabot> b -> (a -> b) -> Maybe a -> b
05:38:11 <Ariakenom> > traverse print Nothing
05:38:12 <lambdabot>  <IO (Maybe ())>
05:38:19 <Ariakenom> % traverse print Nothing
05:38:19 <yahb> Ariakenom: Nothing
05:38:30 <Ariakenom> % traverse_ print Nothing
05:38:30 <yahb> Ariakenom: 
05:38:39 <Ariakenom> % traverse_ print (Just 1)
05:38:39 <yahb> Ariakenom: 1
05:39:02 <noipmusp> Wow.
05:39:31 <__monty__> Unhammer: Well, when talking about the "same time" you might mean 1:00 UTC == 2:00 CET or 12:00 UTC == 12:00 CET.
05:39:32 <Ariakenom> :t traverse_
05:39:33 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
05:40:12 <dmwit> Or you might mean 12:00 UTC /= 12:00 CET, and 1:00 UTC /= 2:00 CET, but 1:00 UTC == 1:00 UTC.
05:40:32 <Unhammer> __monty__,  I would think if your type is ZonedTime, 12 UTC /= 12 CET
05:40:39 <dmwit> But "there are many possible good instances" doesn't seem like a super great reason.
05:40:51 <Unhammer> ooh, like that
05:40:53 <dmwit> The obvious instance is the one I said.
05:41:19 <dmwit> Where they're equal only if all parts are equal (and it's your responsibility to convert away the timezones if you want timezone-agnostic equality).
05:41:22 <Unhammer> ok, so someone might want to say they're the same even in different time zones, now I get it 
05:41:37 <Unhammer> mm
05:41:54 <dmwit> So I have the same question as Unhammer. =)
05:43:00 <Ariakenom> dmwit: that obvious instance doesn't seem very useful.
05:43:03 <Unhammer> to me it would make sense to include the "strict" equality as Eq (z == z' if their parts are ==), and leave the complicated timezone-agnostic bits to other functions
05:43:08 <dmwit> Ariakenom: Why not?
05:43:13 <Unhammer> It's useful to me right now :)
05:43:21 <Ariakenom> huh ok
05:43:27 <dmwit> Ariakenom: A priori it seems as useful as any other Eq instance I've ever heard of.
05:44:01 <__monty__> I'd be surprised.
05:44:05 <Ariakenom> I would have thought you either want to convert them to utc time or local time
05:44:11 <dmwit> __monty__: What would surprise you?
05:44:14 <Ariakenom> and then use that as equality
05:44:20 <__monty__> So let's just say the author didn't want to break their head over LoD.
05:44:32 <dmwit> Ariakenom: Nah, Eq instances usually don't do any interesting computation. If I want interesting computation, I'll use (==) `on`.
05:44:33 <__monty__> dmwit: 1:00 UTC /= 2:00 CET
05:45:01 <merijn> Unhammer: To be fair, you could define a newtype and write that instance yourself :)
05:45:03 * hackage summoner 1.2.0 - Tool for scaffolding completely configured production Haskell projects.  http://hackage.haskell.org/package/summoner-1.2.0 (shersh)
05:45:07 <dmwit> Ariakenom: Eq instances generally do interesting computation only when there's an abstraction boundary to preserve.
05:45:08 <Ariakenom> dmwit: yes I'm saying it makes sense to not have an instance. not that it sohuld have one of those
05:45:10 <dmwit> Ariakenom: There's none here.
05:45:33 <dmwit> Ariakenom: Why does it make sense not to have an instance?
05:45:52 <Unhammer> sure, it's not like it's a big issue, I was more just interested in the reasons
05:46:03 <Ariakenom> I would have thought you either want to compare them as utc time or local time
05:46:13 <dmwit> Ariakenom: So what? Even if it has an instance, you can still do that.
05:46:31 <bahamas> has anyone used this image with stack build? https://hub.docker.com/r/tweag/stack-docker-nix/ how do I make shell.nix available to it?
05:46:50 --- mode: glguy set -v neobrain
05:46:52 <merijn> Unhammer: Most of base follows the logic "if there's multiple sensible instances and there's no clearly obvious default, don't provide an instance"
05:46:57 <Unhammer> imo this would be solved with a note in the docs explaining why there's no eq instance =P
05:47:10 <merijn> Unhammer: See, lack of Monoid instance for Int and Bool, for example
05:47:16 <Ariakenom> reformulation. I would have thought that Eq instance wasn't useful
05:47:19 <Unhammer> mm, makes sense
05:47:24 <merijn> Unhammer: Be the change you want to see in the world! ;)
05:48:09 <Unhammer> oh, it's on github even …
05:48:53 <Unhammer> lol three issues https://github.com/haskell/time/issues?utf8=%E2%9C%93&q=zonedtime+eq+
05:49:19 <dmwit> Ariakenom: It seems you should consider yourself surprised.
05:49:42 <Ariakenom> I do.
05:52:34 <dmwit> Unhammer: Anyway, after reading those three issues, it does seem like adding a comment saying that there's no Eq instance because people can't agree on whether it should be structural equality or UTC equality would be accepted.
05:53:40 <Ariakenom> yes, make a 4th issue :D
05:53:57 <merijn> No, make a PR!
05:54:05 <merijn> Be the change you want to see in the world!
05:54:58 <dmwit> Agreed, PR not issue.
05:57:03 * hackage each 1.1.1.0 - Template Haskell library for writing monadic expressions more easily  http://hackage.haskell.org/package/each-1.1.1.0 (ice1000)
05:58:28 --- mode: glguy set +v Frederick
05:58:35 <Frederick> Hello
05:59:03 <berndl> Hi
05:59:37 <Frederick> It's my first time to use IRC
05:59:53 <Axman6> Welcome!
06:00:03 <Frederick> Does this like a group chat?
06:00:08 <Axman6> yes
06:00:12 <Unhammer> https://github.com/haskell/time/issues/16#issuecomment-443210862
06:00:17 <Axman6> Do you have a question about Haskell?
06:03:55 <Frederick> I am new in Haskell
06:05:45 <Frederick> Is it Real Haskell a good book for learning Haskell without any other languages background?
06:07:15 <__monty__> Frederick: Real World Haskell isn't usually recommended as a first programming book, it's a bit outdated, which makes it harder to follow along.
06:07:22 <Unhammer> > hoursToTimeZone 31415
06:07:24 <lambdabot>  error:
06:07:25 <lambdabot>      Variable not in scope: hoursToTimeZone :: Integer -> t
06:07:53 <Unhammer> anyway,
06:07:54 <Unhammer> +3141500
06:07:56 <Unhammer> seems like an odd timezone
06:07:58 <Unhammer> but maybe that's ok
06:10:52 <dmwit> Well, if you use 31416 instead then it will be an even timezone. ;-)
06:11:09 <dmwit> Also closer to a multiple of pi, so that's nice!
06:12:00 <dmwit> Anyway, the time author did mention he regretted the name timezone, since it's actually a fixed offset from UTC and not what people usually call a time zone.
06:12:34 <crackin> but aren't timezones technically offsets from GMT 
06:12:50 <__monty__> dmwit: You mean because of summer/winter time?
06:13:14 <dmwit> Yes, summer/winter time, and also apparently the offset sometimes changes for political reasons.
06:13:43 <dmwit> And, like, zones are added or removed over time.
06:13:58 <dmwit> There may be many zones that are currently using the same offset.
06:14:02 <dmwit> There are many differences.
06:14:56 <dmwit> crackin: Any confusion about GMT vs UTC is mine and not the time package's author, I'm sure.
06:15:00 <__monty__> Hmm, CET/CEST seems more useful to me than "Whatever time zone applies in Paris rn."
06:15:42 <dmwit> __monty__: To me, both of those concepts seem useful in different situations.
06:15:46 <__monty__> Pretty sure time zones are defined as offsets from UTC. GMT just happens to be defined as 0 offset.
06:16:07 <c_wraith> the international standard for specifying a timezone is by a city
06:16:34 <c_wraith> Which just makes things more fun
06:16:35 <Unhammer> even timezone hah
06:17:00 <merijn> __monty__: Timezones *have* a UTC offset, they're not defined by one
06:17:11 <merijn> As timezones may change the UTC offset that applies to them
06:17:19 <__monty__> dmwit: Yeah, but if I ask an american "What time zone are you in." EST is much more useful than "The time zone NY is in."
06:17:46 <dmwit> Is it?
06:17:57 <dmwit> That claim seems like it needs some further evidence to me.
06:18:00 <Unhammer> Let's make a time zone border through a city
06:18:11 <merijn> Unhammer: That already exist
06:18:15 <merijn> Unhammer: Actually, it's worse
06:18:26 <merijn> Unhammer: There's time zones borders that are person based :)
06:18:29 <c_wraith> the continental US has more time zones than the Pacific, Mountain, Central, and Eastern.
06:18:35 <__monty__> dmwit: Yes, it is. Googling 12pm EST to CET is easier than, googling what TZ applies in NY rn, then googling the former.
06:19:01 <merijn> Unhammer: Palestine and Israel use different time zones, so the time zone that applies to you depend on your nationality/society :)
06:19:14 <c_wraith> It used to be a *lot* more, back before Indiana decided the whole state should observe DST the same way
06:19:18 <dmwit> __monty__: When I google "12 pm nyc to cet" the first hit is titled "CET to New York Time Converter".
06:19:18 <Unhammer> but the standard is still cities, great
06:19:22 <merijn> Timezones are almost as bad as names
06:19:23 <dmwit> __monty__: So... no, it's not easier.
06:19:37 <Unhammer> oh, but it works if you spell the city in arabic vs hebrew alphabets?
06:19:59 <dmwit> __monty__: (Same result for "12 pm ny to cet", so don't complain that you have to know to write nyc instead of ny.)
06:20:45 <__monty__> dmwit: Does it work for backwater cities though?
06:21:08 <dmwit> Maybe. But does it matter? Backwater cities aren't time zones.
06:21:33 * hackage haskoin-store 0.8.1 - Storage and index for Bitcoin and Bitcoin Cash  http://hackage.haskell.org/package/haskoin-store-0.8.1 (xenog)
06:21:40 <dmwit> The claim is not "all towns are time zones". Just that there is a collection of cities which constitutes the standard way of naming a time zone.
06:21:49 <dmwit> Not every city you might name is in that collection, and that's okay.
06:22:12 <Unhammer> ooh
06:22:12 <__monty__> dmwit: So you're saying people should name a large city in the same TZ, rather than just the TZ they're in?
06:22:30 <dmwit> No, they should name the timezone they're in, and the name of the timezone will be a large nearby city. =)
06:22:37 <dmwit> hehehe
06:22:38 <merijn> __monty__: That's how most timezone selectors work
06:23:12 <dmwit> I'm not saying "EST" is a bad way to indicate an offset. Just that it's not obviously better than "NYC".
06:23:24 <dmwit> Different. And has a different meaning.
06:23:34 <dmwit> So your time library should have concepts for both.
06:23:59 <__monty__> dmwit: But there's no unique standard. So when someone tells me thery live on CET I immediately know what that is. With Madrid, or Barcelona I have to guess.
06:24:27 <dmwit> That's just because you don't live in Spain.
06:24:46 <__monty__> dmwit: I'd be totally okay with having both. Just saying that when someone says TimeZone, I expect CET/PST/...
06:24:56 <dmwit> I'd have to look up equally much if they gave me an abbreviation for an offset name from Spain.
06:25:32 <__monty__> dmwit: But more people share a TZ indication than a country.
06:26:17 <dmwit> You keep saying time zone, but I don't think we agree on its meaning. Can we eliminate that word from our vocabulary and try to speak in more basic terms so that we can communicate with each other more clearly?
06:27:19 <dmwit> I think what you're saying is: there are more cities used for indicating an offset than there are offsets. I have no objection to this claim.
06:27:48 <dmwit> I think you are also claiming that just saying a number that is the offset from UTC would be pretty good. I agree with that, too.
06:28:22 <__monty__> No, I'm still on your original point that TZ /= GMT/CET/etc.
06:28:28 <__monty__> For me it does.
06:28:43 <__monty__> Or should not rather than /=
06:29:15 <dmwit> That is why I am trying to stop saying the word "timezone". Once we've got all the concepts right, then we can pick labels for them. And we can check whether other people use these labels consistently with the way we picked them (spoilers: nope).
06:30:33 <dmwit> So GMT/CET/etc. generally pick out fixed offsets from UTC. This is nice in some ways.
06:31:53 <dmwit> On the other hand, America/New_York_City picks out offsets from UTC that vary over the course of the year (and maybe will vary in unpredictable ways in the future). This is also nice in some ways -- for example, if you want to know whether a New York City business is open at a given time, you should use America/New_York_City and not EST.
06:32:50 <Athas> When I try to write a UTF-8 character to stderr on Windows with Data.Text.hPutStrLn, the process explodes with "hPutChar: invalid argument (invalid character)".  What am I doing wrong?  It works fine on civilised systems.
06:33:05 <merijn> Athas: Probably don't have locale configured?
06:33:22 <Athas> merijn: Windows is ASCII-only by default?
06:33:26 <merijn> Athas: What does running "locale" in the shell print?
06:33:34 <dmwit> Athas: chcp 65001
06:33:39 <merijn> Oh...Windows...you're on your own :p
06:33:41 <Athas> I'm seeing this on a pretty standard AppVeyor container.
06:38:50 <Ariakenom> Unhammer: what was your use case for comparing zonedtime?
06:39:57 <Stealthmate> hey guys I have a question about coding style
06:41:04 <merijn> Whatever the question, the answer is to follow my coding style!
06:41:48 <Stealthmate> Should I be putting a 'where' keyword after an empty typeclass definition?
06:41:59 <merijn> Stealthmate: No
06:42:29 <Stealthmate> well that was quick
06:42:34 <c_wraith> In fact, you should elide all "where"s that contain 0 declarations
06:42:36 <c_wraith> :)
06:42:53 <Stealthmate> fair enough
06:42:55 <Unhammer> Ariakenom,  parsing log files; skipping the lines that were produced from this system up until three days ago
06:43:01 <tsahyt> is it possible to use hint with some kind of mock IO for security reasons?
06:43:24 <Unhammer> in my case I guess it wouldn't have mattered if I'd had the comparison-via-UTCTime, it would just be unnecessary
06:43:42 <c_wraith> tsahyt: no, but you can tightly control imports - assuming you don't allow the code you're running to add its own imports.
06:43:45 <Stealthmate> it was messing up my syntax highlighting, so I wrote it, but then i got told to remove it during code review and it made me wonder
06:43:59 <tsahyt> c_wraith: ahh, so I could then just provide my own safe version of IO?
06:44:16 <tsahyt> how does lambdabot do that anyhow?
06:44:16 <c_wraith> You could, at that.
06:44:26 <merijn> Also, I feel compelled to point out that storing times as UTC is only safe for times in the past
06:44:38 <merijn> (related to the whole timezone discussion)
06:44:49 <c_wraith> lambdabot does like 3 different things together to handle different cases
06:44:55 <Ariakenom> Unhammer: Aha! I feel vindicated.
06:45:06 <tsahyt> ah okay, I should probably just read the code then
06:45:24 <Ariakenom> Unhammer: if there were different time zones in the log then utc would've been correct, no?
06:46:27 <c_wraith> tsahyt: most of the interesting stuff is actually in the mueval package
06:47:02 <tsahyt> oh that's nice
06:47:11 <tsahyt> that might be just what I want actually
06:48:32 <Unhammer> maybe, yeah
07:29:39 <SrPx> Hello
07:29:59 <SrPx> Is there any Haskell library for polynomials over finite fields, including methods such as lagrange interpolation?
07:45:51 <noipmusp> How to turn "Map k (Maybe a)" into "Map k a" by dropping Nothing values?
07:46:33 <merijn> Hmm, that'll be a bit messy. Easier to never insert the Nothing's in the first place...
07:46:38 <merijn> how are you building the map?
07:48:00 <noipmusp> It's quite messy code and I wanted to rewrite later, but it seems I have to probably do it now.
07:48:49 <noipmusp> Or use traverseWithKey…
07:53:33 <tsahyt> :t Data.Map.mapMaybe id
07:53:34 <lambdabot> M.Map k (Maybe b) -> M.Map k b
07:53:37 <tsahyt> wouldn't that do it?
07:53:58 <tsahyt> noipmusp: ^
07:54:42 <tsahyt> > Data.Map.mapMaybe id (Data.Map.fromList [(1,Nothing), (2, Just 'a')])
07:54:43 <noipmusp> That's it. Thank you.
07:54:44 <lambdabot>  fromList [(2,'a')]
08:05:24 <c50a326> hey is it true that whenever you use a Functor there is some "effect(s)"?
08:05:41 <c50a326> e.g. `map (+1) [1]` what is the effect, if the above is true?
08:05:44 <merijn> Yes, no, maybe
08:06:02 <merijn> It depends on your definition of "use", "effect", "some" and "is"
08:06:15 <merijn> Oh, and your definition of "true", I suppose
08:06:20 <c_wraith> I'm going to go with "no" for most possible definitions, though.
08:06:29 <merijn> Agreed :p
08:06:31 <c50a326> I mean "effects" as in like how I'm seeing "effects", hang on let me cite the book I'm reading
08:06:47 <dmwit> You can think of lists as having a "nondeterministic effect".
08:07:03 <dmwit> This is true independent of whether all Functors have effects.
08:07:10 <c50a326> "The Prelude also defines a collection of type classes which enable a functional style of programming with side-effects in PureScript: Functor, Applicative and Monad."
08:07:14 <c50a326> https://leanpub.com/purescript/read#leanpub-auto-common-type-classes
08:07:46 <dmwit> That sentence doesn't claim that all F, A, or M instances are effectful.
08:07:56 <c50a326> so when is something effectful and when is it not?
08:08:06 <c50a326> excluding the obvious case of IO
08:08:10 <merijn> c50a326: There's no hard definition of "effectful"
08:08:11 <Solonarv> Those classes enable a convenient way of working with side effects, yes.
08:08:11 <Solonarv> It does not follow that every instance of these classes is an "effect".
08:08:19 <merijn> c50a326: So we just handwave and pretend it has some concrete meaning
08:08:26 <c50a326> damn, that's tough
08:08:26 <merijn> Solonarv: s/side effects/effects
08:08:31 <dmwit> c50a326: Controversial claim: the answer to that question *does not matter*.
08:08:59 <merijn> c50a326: Basically, we say "effects", because "that thing represented by the functor instance of this type, whatever it is" is a bit unwieldy
08:09:20 <Solonarv> 'data Identity a = Identity a' is a Functor, Applicative, Monad (and a bunch of other things too). Is that an effect?
08:09:33 <Solonarv> (as dmwit said, I don't think the answer matters)
08:09:51 <merijn> c50a326: If we're talking about "Functor f => f a" and doing something on it, what do we call the "functionality provided by the 'f'?"
08:10:15 <merijn> c50a326: If we think of [], we might wanna talk about containers, if we think about IO, we might be tempted to say effects
08:10:37 <merijn> c50a326: In reality there's no adequate way to describe it other than "that thing that specific functor does when fmap'ing"
08:11:55 <merijn> c50a326: Similarly, you can think of Maybe's functor both as being "short-circuiting" (an effect) or a container. In the end, it doesn't really matter which it is, because the answer doesn't really matter (which is a very longwinded way of agreeing with dmwit :p)
08:12:43 <c50a326> but doesn't everything matter :P
08:13:00 <c50a326> but no, anyway, thanks, that's shed a little glimmer of light where there was less before
08:14:50 <c50a326> I've decided I'm going to write my own functor/applicative/monad article... and it's probably going to be the worst one ever so far... but I think the reason that there are so many monad blog posts is because maybe one way of forcing the issue of understanding any of it is by having to lay it all out in your own words
08:16:30 <c_wraith> have you read byorgey's article on why there are so many monad tutorials?
08:16:36 <c_wraith> I think he nailed it.
08:17:20 <c_wraith> also, the article is the source of the burrito meme.
08:22:02 <bahamas> I'm curious about something. what's the reason for this using this happy-generated code if it makes compiles times so bad? https://github.com/bjpop/language-python/blob/master/src/Language/Python/Version2/Parser/Parser.y. I'm also looking at PureScript's source code and it doesn't seem to use happy https://github.com/purescript/purescript/tree/master/src/Language/PureScript/Parser
08:22:05 <Solonarv> c_wraith: link?
08:22:43 <c_wraith> Solonarv, https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
08:22:51 <Solonarv> thanks!
08:22:52 <ski> @where burrito
08:22:52 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
08:23:09 <ski> (handy shorthand to get it)
08:25:23 <ski> Solonarv : "Is that an effect?" -- yes, the trivial effect :)
08:26:07 <Solonarv> hah, fair enough - that'd be my answer
08:26:44 * ski has no qualms talking about e.g. list-effects, subset/powerset-effects, expression-effects .. possibly even polynomial-effects
08:28:30 <ski> (it's perhaps less clear whether it's useful to say that any instance of `Functor' represents an effect. but at least for `Monad' (definitely), and `Applicative' (probably), i think it makes sense to stipulate the meaning of the term "effect" in terms of those .. at least in this context. there may perhaps be reasonable notions of effects which are not captured by those, though)
08:30:39 <ski> perhaps when we say "effects", we have in mind something which can be combined (in sequence, say)
08:30:53 <ski> with `Functor' (only) we don't get that
08:31:14 <Solonarv> True. Functor by itself is very general.
08:31:43 <ski> (`Applicative' effects allow only "static sequencing". `Monad'ic effects afford also "dynamic sequencing")
08:33:39 <c_wraith> SSA... single static applicative!
08:34:32 <ski> (there are more fine-grained effect systems, e.g. tracking when an operation may allocate a new state cell, when it may read a particular state cell, when it may write it. i'm not sure whether that could accurately be captured in some kind of generalized monadic/idiomatic framework)
08:35:36 <c_wraith> for what it's worth, I'm not even sure I would calling using fmap over an IO value to be performing an effect. I see it more as adding post-processing to create a new effect that might later be run.
08:36:05 <ski> performing = executing
08:36:38 <ski> so performing `fmap reverse getLine' would be performing the effect of `getLine' (then doing some non-effect processing)
08:37:02 <Solonarv> ski: probably, you can use a generalization of the Monad class and add RankNTypes trickery (like ST) to lift scoping to the type level
08:37:21 <ski> but i suppose since it doesn't combine effects, you perhaps don't want to think of it in those terms ("performing") ?
08:37:23 <c_wraith> ah, some subtlety of reading the original question that I missed. I can accept that.
08:38:17 <c_wraith> but yeah, I'm not sure I really think of fmap over Data.Map as an effect.
08:38:51 <c_wraith> or rather, I don't think of Data.Map as representing an effect.
08:39:26 <ski> (if `fmap f ts', where `ts :: F T', where only know `Functor F' about `F' say, is not performing an effect, then i suppose you'd argue that doing the same operation when `F = IO' ought to be called the same (not performing an effect). perhaps one could say this is a (more) trivial case than actually combining effects (and possibly even depending dynamically on intermediate results))
08:40:01 <Solonarv> I feel like this is somehow related to (co)yoneda
08:40:27 <c_wraith> you can think fo Coyoneda as a reified fmap.
08:40:29 <ski> (i also suppose that each higher-order effect operation, by which i mean an operation which takes an action as input (and where that operation isn't RT) adds a possibly new way of "combining/doing" effects ?)
08:40:56 <ski> (e.g. `forkIO :: IO () -> IO ThreadId')
08:41:38 <ski> well. you can think of `Nat' as a monoid, if you want to
08:41:59 <ski> so, if there's some `Monad' structure there, you can take it into account, or not, as you please
08:59:39 <Solonarv> an endofunctor in Nat would be 'class HFunctor h where ffmap :: Nat f g -> Nat (h f) (h g)'; examples include but are not limited to: co/yoneda, co/monad transformers
09:01:31 <Solonarv> a monad in Nat would be 'class HMonad h where hreturn :: forall f. Nat f (h f); hjoin :: forall f. Nat (h (h f)) (h f)'
09:02:45 <ski> (hm, i suppose it may not have been obvious that i was thinking of natural numbers)
09:03:44 <ski> @type lift  -- not quite `hreturn'
09:03:46 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
09:06:18 <Solonarv> That's hreturn for monads in the category of monads
09:06:52 <Solonarv> @hackage mmorph -- some classes for the category of monads
09:06:52 <lambdabot> http://hackage.haskell.org/package/mmorph -- some classes for the category of monads
09:07:38 <Solonarv> The category of (Hask-)monads is a subcategory of the category of (Hask-endo)functors
09:10:22 <ski> hm, now i'm trying to remember whether, given a functor `F', there can be more than one monad instance for it
09:11:32 <ski> because if so, then i'd say it's not really a subcategory, since it's not just a property which may or may not hold (it holding if you can produce evidence for it), but structure, which can be given in different ways
09:12:30 <ski> (e.g. a group can't be abelian in more than one way, so `Ab' is a subcategory of `Group'. but you can add an inner product to a vector space in more than one way)
09:13:23 <Solonarv> Hmmm, good point
09:13:28 <Taneb> ski: yes, consider ([a], x)
09:13:36 <Taneb> Has Writer [a] and Writer (Dual [a]) instances
09:15:15 <Solonarv> Ah, damn
09:15:24 <Solonarv> Okay, subcategory isn't quite right notion then
09:15:41 <ski> a subset type ⌜{x : A | P x}⌝ can be thought of as a dependent product type. but commonly we don't want to distinguish two elements of the subset type, if only the proofs of the property are distinct, but not the elements from ⌜A⌝. so one'd actually form a quotient over the dependent product type, identifying two pairs of element&proof, if the corresponding elements are equal (which amounts to identifying all the proofs of the property with each oth
09:15:50 <Solonarv> I don't know enough CT to put the relationship in proper terms
09:15:57 <ski> (er, cut off near : ".., if the corresponding elements are equal (which amounts to identifying all the proofs of the property with each other)")
09:16:39 <ski> but if the property ⌜P x⌝ is already a proposition (meaning that there's at most one proof of it), then this last quotient step isn't necessary
09:17:14 <ski> Solonarv : you could say the category of monads is concrete over the category of endofunctors, i think
09:17:50 <ski> that means that you have a functor from the former, to the latter, that you consider to be an "underlying"/"forgetful" functor
09:18:11 <ski> (usually such functors would be faithful)
09:18:14 <Solonarv> yes, that sounds right
09:18:59 <ski> (meaning "injective, on each ⌜Hom⌝-class ⌜Hom(A,B)⌝ between objects ⌜A⌝,⌜B⌝ in the domain category, for any two such objects)
09:19:30 <ski> if one says "the category is concrete", then one usually means "the category is concrete over ⌜Set⌝"
09:20:30 * Solonarv nods
09:23:45 <ski> (then there's e.g. ⌜HTop⌝ (category of topological spaces, morphisms being continuous maps, *upto* homotopy equivalence ("continuous deformation")) which is not concrete (over ⌜Set⌝))
09:26:15 <Solonarv> yup I'm looking at the "Concrete Category" wikipedia page
09:30:44 <ski> Solonarv : i think one exception to the "faithful" part could be if you have multiple carriers, and you consider a functor which forgets a carrier (as opposed to just forgetting a law, or an operation)
09:31:51 <ski> hm, if we have a category of graphs, having vertices and edges as carriers, we could imagine another category where objects has vertices, edges, and faces
09:32:08 <Solonarv> The wiki page defines a concrete category using a faithful functor; if the functor isn't faithful then it doesn't define a concrete category
09:32:14 <Solonarv> (what's a carrier?)
09:32:24 <ski> then we could have a functor from the latter to the former, which forgets the faces (and the operations which tell which edges faces span between)
09:33:01 <ski> well, to specify a group, you specify a carrier set, and then three operations (with specific signaturs, in terms of the carrier)
09:33:36 <ski> to specify a vector space, you talk about both a particular set of vectors, and a set of scalars
09:33:51 <Solonarv> oh, I see - it's just the "underlying set" ?
09:34:16 <ski> however, usually we pick the same set of scalars (really should be a field, or at least a ring), in a single context. so one talks about `Vect_K', the category of vector spaces over the field `K'
09:34:45 <ski> i suppose one could perhaps also consider a category where objects are pairs of a field `K', and a vector space over that field `K'
09:35:06 <ski> anyway, multi-sorted algebras are not as common as single-sorted ones
09:35:29 <ski> the graph example is probably the most familiar one, with multiple carriers
09:35:43 <ski> (directed multi-graphs)
09:36:02 <ski> Solonarv : so, yes
09:37:11 <ski> "defines a concrete category using a faithful functor" -- yes, so i was commenting that, perhaps, this only makes sense for the single carrier case
09:37:36 <ski> (i'm not sure what to replace it with, in multiple-carrier / multi-sorted cases)
09:37:59 <ski> anyway
09:38:07 <ski> "This functor makes it possible to think of the objects of the category as sets with additional structure, and of its morphisms as structure-preserving functions."
09:38:34 <ski> it's the "additional structure" here which is something more than a "mere property" (which would indeed yield a subcategory)
09:38:46 <Solonarv> Yup, makes sense
09:39:50 <ski> (and "additional structure" here means "additional operations" (or, maybe, even "additional carriers"), but not just "additional laws", unless one goes type-theoretical on the latter, distinguishing different proofs of the laws from each other, so not considering them as "(mere) propositions")
09:41:34 * Solonarv nods
09:42:06 <Solonarv> Does it mean anything in particular if the forgetful functor is also full?
09:42:07 <ski> (then there's the question of which laws of which form actually could have multiple, distinct, proofs. universal algebra only allows as laws universally quantified equalities between terms built from operations, and those universally quantified variables. perhaps also adding ambient constants and operations of "constant sorts" like `K' in the vector space case)
09:43:21 <ski> well, then every morphism in each morphism class is "hit" by the forgetful
09:44:37 <ski> so i suppose either every morphism actually already satisfies the forgotten law. or you didn't forget any law (but only operations, say). hm, or perhaps that would be that you only forget laws that you have to remove because you're also forgetting operations which are mentioned in the law ?
09:46:59 <Solonarv> That seems like it'd apply to the forgetful functor from (Hask-)monads to (Hask-endo)functors, right?
09:47:58 <ski> hm, if we have two groups, which can be considered to be monoids (forgetting inverse operation and therefore also needing to forget inverse laws), is it the case that every monoid homomorphism between those two groups comes from a group homomorphism between those two groups, forgetting that it preserves inverse ?
09:48:47 <ski> or, simpler : is every monoid homomophism between two groups already a group homomorphism ?
09:49:03 * hackage apecs-physics 0.3.1 - 2D physics for apecs  http://hackage.haskell.org/package/apecs-physics-0.3.1 (jonascarpay)
09:49:03 <ski> or, even : does every monoid homomophism between two groups preserve the inverse operation ?
09:49:16 <ski>   f : G >---> H
09:49:16 <Solonarv> hmm
09:49:24 <ski> we know
09:49:33 <ski>   f 1_G = 1_H
09:50:03 * hackage apecs-gloss 0.1.1 - Simple gloss renderer for apecs  http://hackage.haskell.org/package/apecs-gloss-0.1.1 (jonascarpay)
09:50:08 <ski>   f (g_0 *_G g_1) = f g_0 *_H f g_1  -| g_0,g_1 : G
09:51:25 <ski>      f (inv_G g) *_H f g
09:51:28 <ski>   =
09:51:35 <ski>      f (inv_G g *_G g)
09:51:39 <ski>   =
09:51:45 <ski>      f 1_G
09:51:45 <ski>   =
09:51:49 <ski>      1_H
09:52:41 <ski> therefore `f (inv_G g)' satisfies the characterizing property that `inv_H (f g)' satisfies, which means that these two are equal (because there's only one thing that satisfies this property, if there's anything)
09:52:51 <ski> therefore yes, `f' preserves inverses
09:53:55 <Solonarv> \o/
09:54:09 <ski> Solonarv : "That seems like .." -- "That" being specifically what ?
09:54:37 <Solonarv> the forgetful functor being full
09:55:09 <ski> yea, but did you respond in particular to me three-alternative statement ?
09:56:36 <Solonarv> Not really, though it did help me think
09:57:12 <ski> i'm not seeing why "the forgetful functor from (Hask-)monads to (Hask-endo)functors" would be full
09:57:42 <ski> hm, perhaps i should unpack it, to see what it would even mean, first ..
09:58:10 <ski> so, we're talking about morphisms in these categories, which are monad morphisms, resp. natural transformations in general
09:58:59 <ski> so the question is then : given any natural transformation between two monads (forgetting the monad structure there), does it come from a monad morphism between those two monads (via forgetting the monadic operation preservation)
09:59:16 <ski> or : is every natural transformation between monads a monad morphism ?
09:59:32 <ski> (i assume you remember what being a monad morphism means ?)
09:59:42 <Solonarv> Yes.
10:02:25 <Solonarv> the documentation of 'mmorph' indicates that the answer is no
10:02:56 <Solonarv> "The first argument to hoist must be a monad morphism, even though the type system does not enforce this"
10:03:23 <ski> hm, spelling it out anyways, for easy reference, given a natural transformation `phi : M >---> N', `id >-{eta_M}-> M >-{phi}-> N' should be equal to `id >-{eta_N}-> N' (iow `phi . eta_M = eta_N'), and `M . M >-{mu_M}-> M >-{phi}-> N' should be equal to `M . M >-{phi o phi}-> N . N >-{mu_N}-> N' (iow `phi . mu_M = mu_N . (phi o phi)')
10:03:47 <Solonarv> (that first argument has type "forall x. m x -> n x", which means it's a nat. trans.)
10:04:23 <Solonarv> You say easy reference, but that's actually really hard to read with the (lack of) formatting
10:04:44 <ski> well, it's the "iow" formulations i was after, here
10:04:54 <ski> the diagram-chasing is just how i remember those
10:05:29 <Solonarv> Hm, can we find a counterexample? (a NT which is not a monad morphism)
10:06:54 <ski> so, taking `M = N = Maybe', and `phi : Maybe >---> Maybe' defined by `phi_A (_) = Nothing', then `(phi . eta_M)_1 () = phi_1 (Just ()) = Nothing', but `(eta_N)_1 () = Just ()'
10:08:32 <ski> so `phi' doesn't preserve `eta_Maybe'/`return'
10:09:28 <ski> (hm, i should say "doesn't preserve `eta'/`return'. i just happened to have the same domain and codomain `Maybe' here ..)
10:10:02 <ski> so .. i suppose this forgetful is not full
10:10:11 <Solonarv> I found another one: 'ɸ = concatMap (\x -> [x,x])', taking M = N = []
10:10:11 <Solonarv> then 'ɸ (ŋM a) = [a, a] ≠ [a] = ŋN a', hence ɸ . ŋM ≠ ŋN
10:10:26 <Solonarv> (took a while to type because I decided to do proper greek letters)
10:10:35 * ski nods
10:11:35 <Solonarv> I find (counter)examples help a lot in understanding stuff.
10:11:40 <ski> yes
10:11:56 <ski> finding which inclusions are proper, which implications can't be reversed, &c.
10:12:45 <ski> a large extent of mathematics seems to consist of attempting to reverse implications, perhaps after some creative reformulation of the property
10:14:02 <ski> e.g. you have `forall x,y,z. x =< y /\ y =< z -> x =< z' in a partial order (or even preorder) `(=<)'. obviously you can't in general reverse this ("take/consider the converse")
10:14:32 <ski> because that would mean that as soon as `x =< z', then *every* `y' in the set would need to fit inbetween, in that interval
10:14:57 <ski> so, either the set is empty, or it has only one in habitant, i think
10:15:59 <ski> however, if we reformulate it as `forall x,z. (exists y. x =< y /\ y =< z) -> x =< z' and *now* form the converse, we're expressing the property of a *dense* order
10:16:20 <ski> (actually, we should use `(<)', not `(=<)', for that. but both are transitive anyway)
10:17:25 <ski> otoh, we can also reformulate the same transitivity property as `forall y,z. y =< z -> (forall x. x =< y -> x =< z)', and take the converse, reversing the outer implication
10:18:04 <ski> so we're stating that if every lower bound of `y' is a lower bound of `z', then `y' is at most `z' -- which is true, in a preorder
10:18:38 <ski> (alternatively stated : if the lower set of all elements that are at most `y' is included in the lower set of `z', then `y' is at most `z')
10:18:52 <ski> (btw, could one say "forgetfull" if one has a full forgetful functor ? :)
10:20:04 <Solonarv> It would fit into a long tradition of intentional misspellings being assigned a separate meaning from the "correct" spelling :P
10:20:08 <Solonarv> (see also: iff)
10:20:36 <ski> hm, i think possibly some examples that are mentioned in relation to some definition should actually be termed "theorems" or at least "lemmata" or "propositions" or somesuch
10:21:30 <ski> to indicate that they're to be considered non-expendible parts, when learning about the definition. as opposed to some random example that shows the definition in use, but which one doesn't need that particular one, to know how to handle the definition
10:22:59 <ski> (i suppose theorems would usually either be implications, or universally quantified formulae, or maybe sometimes a conjunction of such. as opposed to having a theorem whose main connective is an existential (or even a disjunction))
10:24:51 * ski is also reminded of how people in physics say something like "a law should be general" .. which somehow seems to be besides the point, or however one should state it, hmm
10:26:06 <ski> (also, at least when using classical logic, every property could be said to be a "negative property", because any `A' is equivalent to `not B', taking `B' as `not A')
10:30:39 <dmwit> Perhaps you could identify some cheap-to-compute normal form. Then it may be sensible to identify "negative property" with "its normal form looks like this".
10:31:27 <dmwit> (In your particular case then at most one of A and not (not A) are in normal form.)
10:33:08 --- mode: glguy set +v francoweb
10:35:01 <ski> point
10:35:16 <ski> (but then that's not stable under substitution of propositional variables)
10:35:57 <ski> (perhaps one shouldn't worry about / expect that anyway, in "such" situations ..)
10:39:31 * ski isn't sure what "such" means, specifically ..
10:40:57 <ski> (oh, it's actually s/expendible/expendable/)
10:51:49 * hackage fused-effects 0.1.2.0 - A fast, flexible, fused effect system.  http://hackage.haskell.org/package/fused-effects-0.1.2.0 (robrix)
10:53:32 <johnjay> ski: i love pseudo-philosophizing about logic in the context of programming
10:53:36 <johnjay> probably why i like scheme too
10:54:57 <Solonarv> relatedly: the Curry-Howard isomorphism is awesome :D
11:00:33 * hackage haskoin-store 0.9.0 - Storage and index for Bitcoin and Bitcoin Cash  http://hackage.haskell.org/package/haskoin-store-0.9.0 (xenog)
11:10:10 <SrPx> if I have a big polynomial `P(x)` with N coefficients, is there any simple/obvious way to compute the coeffs of `F(x) = P(x+k)` ?
11:10:37 <dmwit> ski: Properties with unbound variables should probably be banned in the first place. =)
11:10:46 <dmwit> (Or just not called "properties".)
11:10:56 <opqdonut> SrPx: you just need to write it out, the answer involves binomial coefficients unsurprisingly
11:11:49 <opqdonut> SrPx: the straightforward way is to compute the polynomials a_j(x+k)^j for each j and then sum them
11:12:10 <dmwit> SrPx: If you store your polynomial as a list of its roots instead of a list of its coefficients then that computation is much easier. =)
11:12:21 <opqdonut> that's an excellent point
11:12:22 <SrPx> dmwit: oh indeed!
11:12:27 <SrPx> thanks for that
11:12:55 <SrPx> I asked this on #haskell by mistake, but I'm not disappointed 
11:12:59 <SrPx> thanks guys
11:13:54 <dmwit> (But other computations are much harder, so... TANSTAAFL)
11:16:00 <ski> dmwit : "Properties with unbound variables" ?
11:19:53 <ski> oh, i suppose you mean "the property ⌜P x⌝" ? sorry, i meant that as a "property in ⌜x⌝", which means that i had ⌜x ↦ P x⌝ in mind
11:20:16 <ski> (but i'm still curious about what your meant with your sentiment, which i'm not sure i agree with)
11:32:33 * hackage Earley 0.13.0.0 - Parsing all context-free grammars using Earley's algorithm.  http://hackage.haskell.org/package/Earley-0.13.0.0 (OlleFredriksson)
11:32:46 <celphi> Afternoon all. I'm stuck. https://wandbox.org/permlink/rE2ZDWRlCzslFjNZ
11:37:53 <c_wraith> hah. ski, if you recall my asking about the monoid/Semigroup instances for a type in Earley, that release just changed it. still not sure if just changing it was a good idea, but I do think the new instances are better.
11:38:44 <ski> changed from what to what ?
11:38:57 <ski> hm, oh
11:39:08 <ski> the `liftA2 (<>)' vs `(<|>)' thing
11:39:13 <c_wraith> yeah
11:39:33 <c_wraith> at least it was a major version bump
11:39:40 <ski> yea, was just wondering about that :)
11:40:03 <dmwit> ski: You object that normal forms are probably not stable with respect to substitution of propositional variables.
11:40:26 <xolotolox> could someone demonstrate an (nth root of x) calculation in ghci?
11:40:27 <dmwit> ski: I object to your objection that you shouldn't have unbound variables in the first place, and so substitution of propositional variables should change nothing, including whether it's normal or not.
11:40:56 <ab9rf> i object to objections to objections
11:41:04 <ski> hm, i don't recall objecting to having unbound variables
11:41:18 <dmwit> ab9rf: I object to being subject to your objections.
11:41:59 <dmwit> ski: No, *I* am objecting to having unbound variables.
11:41:59 * ski subjects to being object of your subjections
11:42:25 <Solonarv> % let x `root` n = x ^ (n^^-1) in 27 `root` 3
11:42:26 <yahb> Solonarv: ; <interactive>:129:24: error:; * Variable not in scope: (^^-) :: t -> Integer -> Integer; * Perhaps you meant one of these: `^^' (imported from Prelude), `^^=' (imported from Control.Lens), `^^~' (imported from Control.Lens)
11:42:35 <ski> dmwit : so you don't like propositional formulae like `(p /\ q -> r) /\ p -> (q -> r)', then ?
11:42:50 <ab9rf> you need a space :)
11:42:55 <Solonarv> % let x `root` n = x ^ (n^^(-1)) in 27 `root` 3
11:42:55 <yahb> Solonarv: ; <interactive>:130:35: error:; * Could not deduce (Fractional b0) arising from a use of `root'; from the context: Num a bound by the inferred type of it :: Num a => a at <interactive>:130:1-45; The type variable `b0' is ambiguous; These potential instances exist:; instance RealFloat a => Fractional (Complex a) -- Defined in `Data.Complex'; instance HasResolution a =
11:43:03 <Solonarv> bah!
11:43:05 <Solonarv> brb
11:43:07 <ab9rf> heheh
11:43:13 <dmwit> ski: Not as a thing which we can call a "negative property" or not. =)
11:43:24 <ski> ah, i see
11:43:40 <ski> ty
11:44:56 <Solonarv> % let x `root` n = x ** recip n
11:44:57 <yahb> Solonarv: 
11:45:04 <Solonarv> % 27 `root` 3
11:45:05 <yahb> Solonarv: 3.0
11:45:11 <ab9rf> hehe
11:45:15 <Solonarv> xolotolox: ^
11:45:20 <ab9rf> Solonarv: was wondering whe you'd discover that function
11:45:41 <dmwit> > ap (==) reverse "xolotolox"
11:45:41 <Solonarv> I remembered "wait, I'm being dumb. 'recip' is a thing."
11:45:43 <lambdabot>  True
11:45:49 <ab9rf> @pl \f x n -> x ** recip n
11:45:50 <lambdabot> const ((. recip) . (**))
11:46:19 <Solonarv> what's the 'f' argument for?
11:46:22 <dmwit> % let x `root'` n = x ** (1/n) -- in case you've forgotten that recip is a thing
11:46:22 <yahb> dmwit: 
11:46:32 <ab9rf> @pl \n x -> x ** recip n -- d;oh
11:46:32 <lambdabot> flip (**) . recip
11:46:39 <ab9rf> Solonarv: i have no idea
11:46:54 <xolotolox> Thanks Solonarv! always nice to start from a working example  : )
11:47:00 <ab9rf> Solonarv: some sort of damned interloping identifer]
11:47:20 <Solonarv> celphi: [ blah | blah blah ] is a list comprehension, its type is a list
11:47:23 <ab9rf> just use "root = flip (**) . recip"
11:47:33 <ab9rf> well, no, that's backwards actually
11:47:41 <ab9rf> @pl \ x n -> x ** recip n -- d;oh
11:47:41 <lambdabot> (. recip) . (**)
11:47:58 <ab9rf> there, that's if you want it to be x `root` 3
11:48:02 <ab9rf> instead of 3 `root` x
11:48:45 <Solonarv> celphi: Additionally, if you write 'x <- foo' in a list comprehension, 'foo' must also be a list
11:48:49 <ab9rf> i kinda prefer the "root" argumnet being first because it curries better
11:48:59 <ab9rf> then sqrt = root 2
11:49:33 <dmwit> square = 2; sqrt = (square `root`)
11:49:44 <Solonarv> nO
11:50:07 <dmwit> ^_^
11:50:12 <ab9rf> :)
11:51:04 <Solonarv> % ^_^
11:51:05 <yahb> Solonarv: ; <interactive>:137:1: error: parse error on input `^'
11:51:26 <ab9rf> can't start an expression with an operator ;)
11:51:27 <jle`> who's ready for advent of code ^^
11:52:14 <aplainzetakind> @pl \x n -> exp (log x / n)
11:52:14 <lambdabot> (exp .) . (/) . log
11:52:20 <c_wraith> jle`, I think I'm going to give this one a shot. I've ignored them in the past, but it always looked fun.
11:52:46 <Solonarv> I'm going to give it a shot but that doesn't mean I'm ready! :V
11:53:01 <c_wraith> (OK, ignored isn't quite right. more like "felt like I had other things to do instead") 
11:53:47 <ab9rf> advent of code?
11:53:55 <ab9rf> oh, it is that time of year, isn't it/
11:55:58 <Solonarv> Aye.
11:55:58 <aplainzetakind> Do I need to grok Arrow to be able to use hxt? The exposition at the Haskell wiki was rather terse and not exactly noob-friendly.
11:59:21 <c_wraith> aplainzetakind, yeah, and worst of all, hxt barely uses what actually makes arrow interesting. so you get the complexity with little payoff.
11:59:34 <celphi> Afternoon all. I'm stuck. https://wandbox.org/permlink/rE2ZDWRlCzslFjNZ
12:01:44 <aplainzetakind> c_wraith: I just want to read an xml into a data type I defined, while ignoring certain tags. What's the most practical tool for the job?
12:02:08 <Younder> XPATH
12:02:11 <geekosaur> tagsoup?
12:02:33 <c_wraith> aplainzetakind, last time I worked with that I used simple-xml. it would still work, though there might be better choices now.
12:02:46 <zachk> celphi, a and b aren't lists so thats not gonna work in a list comprehension 
12:04:07 <celphi> so does that mean: "x | x <- " doesnt have to go inside [ ]
12:04:11 <c_wraith> aplainzetakind, if you're looking for something that automatically derives code from your types, I'm not sure what your best bet is. I haven't dealt with that.
12:04:44 <zachk> > let f as bs = [a+b | a <- as, b <- bs] in f [1,2,3] [4,5,6]  --celphi 
12:04:46 <lambdabot>  [5,6,7,6,7,8,7,8,9]
12:05:19 <Younder> Really these web formats are so awkward with the Haskell type system. As a heterogeneous programmer I would just use a different language like python.
12:05:55 <celphi> so the point of <- is for lists
12:06:06 <aplainzetakind> c_wraith: No I'm not asking for that much, I just want something that I can get started with quickly.
12:06:13 <Younder> XML and JSON and sort of a slug fest. They fight you every step of the way.
12:06:17 <celphi> if i wanted to do a + b, i just dont add the x |
12:06:42 <Solonarv> celphi: no, the point of *list comprehensions* is lists
12:06:46 <zachk> celphi in a list comprehension <- is for lists, but there is something called do notation that also uses <- for arbitrary monads, where list is a monad as well 
12:07:00 <Ariakenom> Younder: have you tried lensy Aeson?
12:07:07 <Solonarv> and pattern guards are written using <- as well
12:07:15 <Younder> Ariakenom, no, I haven't
12:07:39 <aplainzetakind> But I will eventually parse a wiktionary dump which is 200 million lines, that may be relevant.
12:07:43 <Solonarv> If you just want to add 'a' and 'b' you write 'a + b' and that's all
12:08:22 <Solonarv> '[a + b]' is a list containing one element, which is 'a + b'
12:08:59 <celphi> oh cool.. that clears up a lot
12:26:58 <Solonarv> I think I've figured out what I dislike about OverloadedLabels
12:27:19 <c_wraith> is it that inference doesn't work?
12:27:45 <Solonarv> No, it's that too many of their uses would require an 'IsLabel s (x -> y)' instance
12:28:07 <celphi> This language is so incredibly different from any language i've learned
12:28:22 * Solonarv nods
12:28:59 <hodapp> yes.
12:30:10 <Solonarv> You can't use overloaded labels for e.g. generic-lens and vinyl at the same time, because both those uses happen via an 'IsLabel s (_ -> _)' instance
12:30:19 <Solonarv> So they overlap, and now you're fucked
12:30:39 <Solonarv> Which means you end up not using them.
12:32:03 <zachk> celphi, haskell has made it simpler for me to understand most other languages 
12:32:37 * hodapp doesn't want to know what emoticon (_ -> _) is
12:33:33 <zachk> hodapp, its a face upside down with a nose of course!
12:34:22 <cocreature> your nose has to be broken pretty badly for this
12:34:38 <MarcelineVQ> it's a sleeping owen wilson
12:36:40 <Solonarv> fun fact: (_ -> _) is valid syntax for a haskell type (although it isn't allowed in all types)
12:36:53 <ab9rf> i truly dislike json
12:37:00 <Solonarv> % :t reverse @(_ -> _)
12:37:00 <yahb> Solonarv: [w1 -> w2] -> [w1 -> w2]
12:37:32 <shapr> ab9rf: I just wish it allowed comments
12:37:42 <celphi> @zachk yeah im just used to imperitive languages. FP is so different.
12:37:42 <lambdabot> Unknown command, try @list
12:38:13 <Solonarv> I don't mind json too much as long as the schema makes sense. Unfortunately if I'm working with someone else's API it often doesn't.
12:38:33 <Solonarv> "this field may be a string, a number, an array, or completely absent. have fun!"
12:38:41 <celphi> Is web applications practical using Haskell?
12:38:48 <ab9rf> i've yet to see a json implementation that handles Very Large objects reasonablyu
12:39:08 <Solonarv> celphi: It's one of haskell's primary use cases (specifically the server side)
12:39:24 <geekosaur> celphi, list comprehensions aren't so much FP as syntax. I mean, Python has them too.
12:39:27 <celphi> How does it compare to like php 7.2 performance wise
12:39:34 <shapr> I could stand to update my Haskell example web apps
12:39:37 <Eduard_Munteanu> Well, I wish there was a serialization format that handled very large objects reasonably. I'm not sure there is one.
12:39:38 <shapr> celphi: oh it's MUCH faster
12:40:12 <celphi> I'm coming from a JS/PHP background so this langauge is so foreign.
12:40:16 <shapr> I compared Python and Haskell speed wise. Python takes about ten times longer to do anything.
12:40:29 <Solonarv> Haskell is pretty fast. More importantly, it's harder to accidentally write an incorrect program in Haskell than in some other languages.
12:40:45 <hodapp> ab9rf: what do you prefer to JSON?
12:40:51 <Solonarv> Many things which would otherwise be runtime errors can be caught by the type checker at compile time instead
12:40:57 <celphi> How many lines to do like a Hello World app in haskell?
12:41:04 <celphi> web app
12:41:39 <shapr> probably ten?
12:41:50 <celphi> Jeez
12:41:56 <ab9rf> hodapp: depends on the purpose
12:42:05 <Solonarv> most of that would be imports & the like
12:42:05 <ab9rf> hodapp: it most cases, i'll write a DSL
12:42:09 <celphi> <?php echo "Hello World";
12:42:36 <hodapp> that's sort of cheating since that doesn't actually cover the webserver that runs it
12:42:43 <Eduard_Munteanu> You can do  main = putStrLn "Hello world"   in Haskell as CGI, but it's kinda stupid.
12:42:45 <shapr> celphi: here's an exercise tracking website I made, uses sqlite and has all the html inside the app itself: https://github.com/shapr/sporkle/blob/master/app/Main.hs
12:43:00 <Solonarv> and could in fact just be
12:43:00 <Solonarv> Hello World
12:43:05 <Solonarv> (completely skipping php)
12:43:13 <Eduard_Munteanu> :)
12:43:19 <celphi> Does haskell use it's own webserver or can you run on apache?
12:43:22 <hodapp> ab9rf: if the main need is just to pass structured data, seems rather overkill
12:43:30 <celphi> ill check it out shapr
12:43:33 <shapr> celphi: that source imports the webserver, builds the routes, accesses the database, does the markup and adds new entries to the database
12:43:44 <shapr> celphi: it's 140 lines
12:43:56 <Eduard_Munteanu> celphi, it's common to use an application server like Warp and put Apache in front of it.
12:44:03 <shapr> I am *not* a front end designer, so it's not the least bit attractive.
12:44:04 <ab9rf> hodapp: have you look at how complicated JSON, YAML, and XML parsers are?
12:44:28 <celphi> shapr what's the url?
12:44:33 <celphi> to see site
12:44:35 <ab9rf> hodapp: the overkill is in using one of these behemoths instead of a slimline DSL
12:44:41 <Eduard_Munteanu> Text serialization formats are kinda stupid, for most usecases.
12:44:45 <shapr> celphi: I wrote it for a talk I gave, so it's not up anywhere
12:45:00 <ab9rf> Eduard_Munteanu: precisely
12:45:37 <shapr> celphi: but you can clone that repo and (assuming you have stack installed) "stack run" will run the site on localhost:3000 I think
12:45:38 * shapr checks
12:45:40 <Eduard_Munteanu> The fact that it's human readable doesn't make it easy to implement, quite the contrary.
12:45:53 <ab9rf> if your purpose is simply to make it robustly transferrable, you just need to normalize representation and wrap untransmittable bit or byte sequenceis
12:46:03 <ab9rf> if your purpose is to make it human readable, then fucking make it human readable
12:46:27 <ab9rf> JSON barely qualifies as human readable, and the syntax is so brittle that it's really not human-editable
12:47:07 <celphi> i like json-- but im biased
12:47:32 <celphi> thnx shapr
12:47:36 <Eduard_Munteanu> It's much easier to pretty-print than decode these formats, by the way. No reason to stick with the odd representation.
12:47:42 <hodapp> he fact that it's widely-supported is worth something anytime what you're coding has to 
12:47:55 <hodapp> ...interface with other things, particularly, things you don't control
12:47:58 <ab9rf> json is "widely supported" bceause json is simply java script source code
12:48:30 <shapr> C is widely supported, that's why we use it to build websites. </joke>
12:48:31 <MarcelineVQ> it might be easier if it was, instead it is its own spec, which them rfers back to js stuff, making it under-specified
12:48:38 <shapr> I dunno, I see both sides.
12:48:45 <hodapp> I don't particularly care about why it's widely-supported; I care about making the system work rather than making some sort of abstract point about design.
12:48:49 <ab9rf> MarcelineVQ: even worse :)
12:49:00 <Eduard_Munteanu> I really wish there was a nice way to represent streaming blobs in RPC/serialization formats.
12:49:05 <ab9rf> shapr: only two sides?
12:49:33 <ab9rf> one of my large complaints with json is that you have to deserialize the entire object before youy know if it's valid
12:50:10 <ab9rf> you could, i suppose, presume that it's valid and speculatively deseiralize but you have to be prepared for the possibility that it's not
12:50:35 <Solonarv> something something CBOR ?
12:50:38 <MarcelineVQ> Tell your ends to send multiple smaller objects, nothing could go wrong or be wasteful :>
12:50:42 <ab9rf> this comes up when someone (stupidly) serializes something Very Large into JSON
12:50:48 <Solonarv> I think there's a haskell library for it too
12:51:00 <ab9rf> someone was in here a while back asking for help with dealing with a 20 gigabyte file that was a single JSON object
12:51:08 <Solonarv> yeowch
12:52:01 <Eduard_Munteanu> I bet it wasn't much useful data in there, maybe 2 GiB? :)
12:52:16 <ab9rf> Eduard_Munteanu: he wanted to slice it, extracting a specific subset of attributes
12:53:42 <Eduard_Munteanu> And we have drop-in replacements like MsgPack, you don't really have to do much to avoid JSON.
12:53:54 <ab9rf> if it had been xml, a relatively simple XSL transform (which can be done streamwise) would have sufficed
12:54:21 <Eduard_Munteanu> It would have been 100GiB then. :P
12:54:27 <ab9rf> Eduard_Munteanu: point :)
12:54:34 <Solonarv> celphi: 9 lines for hello world: https://gist.github.com/Solonarv/326219068428c54598120eea949f571b
12:54:59 <Solonarv> give it chmod +x and run it, and it'll Just Work (tm)
12:55:01 <ab9rf> in theory, it should be possible to transform JSON in a streamwise manner as well, but there are not many libs out there for actually doing so
12:55:32 <ab9rf> Eduard_Munteanu: i like the looks of msgpack
12:57:07 <ab9rf> Eduard_Munteanu: i especially like the fact that varsized data is counted instead of delimited
12:59:54 <Eduard_Munteanu> At work we had to implement file uploads. It turns out you still need to implement your own chunking and reassembly even with more advanced protocols like gRPC and Avro. Who would've thought this wasn't a solved problem by 2019?
13:00:31 <Solonarv> something something hurr durr web 3.0 what even are files? who even does file uploads anymore?
13:00:38 <Solonarv> ~ the designers or gRPC, presumably
13:02:09 <Eduard_Munteanu> And after a bit more thought, I realized you can't just stream one big message, because that'd stall your entire connection until it's done.
13:02:20 <EvanR> Eduard_Munteanu: should have used an off the shelf solution.. like FTP :)
13:02:35 <ab9rf> heh
13:03:09 <EvanR> the real answer has been there all along... rewrite everything in house from scratch because what exists sucks
13:03:12 <Eduard_Munteanu> Yeah, well, I suggested HTTP.
13:03:13 <c_wraith> FTP is more like an off the shelf incompatibility with how networks are configured now.
13:03:42 <ab9rf> c_wraith: ftp is a pain the fucking ass from a network security standpoint
13:04:26 <c_wraith> FTP is indistinguishable from a data exfiltration attack
13:04:33 <MarcelineVQ> I ​miss ftp, taking 2 hours to uploade 10,000 50byte files was a nice lunch break
13:05:30 <Solonarv> isn't there a more modern alternative to FTP? I can't remember what it's called
13:05:43 <ab9rf> Solonarv: dropbox?
13:05:50 * ab9rf runs
13:05:52 <Eduard_Munteanu> I recently had to rename a binary from "something" to "something.exe" because some FTP client/server thought it was a good idea to convert newlines.
13:05:54 <Solonarv> kek
13:06:52 <ab9rf> Eduard_Munteanu: probably Microsoft FTP; MS IIS has a scadload of places where it decides for itself whether it's dealing with a text file or binary file, using God Knows What to make the decision
13:07:16 <Eduard_Munteanu> There was a Windows machine involved, so that's possible.
13:07:27 <hodapp> yeah, IIS is sort of an atrocity
13:07:40 <hodapp> I once had to try to write a plugin for it
13:08:10 <hodapp> this is the only time I have ever had the edit the bloody registry just to get at the actual log files
13:08:17 <Solonarv> Windows using file extensions to decide what type a file is has irked me for as long as I've known there's another way
13:08:38 * hodapp sends Solonarv not_a_virus.jpg.exe
13:08:42 <hyperisco> hodapp, I was reticent to install WAMP again so I tried IIS. Am proud to say that I now have a dev webserver on localhost. It can be done!
13:09:06 * Solonarv has "hide file extensions" disabled because they're not a pleb
13:09:09 <ab9rf> Solonarv: it's more than just "file extensions"
13:09:41 <Solonarv> If changing a file's extension changes how the OS handles it that's enough to count IMO
13:09:52 <ab9rf> Solonarv: there are even situations where it examines the content of the file to try to decide if it's text or not. this has resulted in some exploits, due to bugs in MSFT's content type decision engine
13:10:05 <hyperisco> Solonarv, I think "there's another way" is more truthfully phrased as "there's too many other ways"
13:10:19 <Solonarv> yes, the text/binary distinction is annoying too
13:10:26 <__monty__> Solonarv: What's the other way?
13:10:30 <hodapp> there was the exploit too in which a specially-crafted JPEG could get code running in kernel space because they decided to both roll their own JPEG decoding and to not do it in userspace
13:10:59 <hyperisco> well you don't want the overhead of context switching in your jpeg decoder do you?! thought not
13:11:01 <Solonarv> "whatever *nix does", which IIRC involves looking at the beginning of the file and going from there
13:11:05 <hodapp> instead of using libjpeg, which runs on World War II era toasters and has been tested to death
13:11:23 <Solonarv> (I'm a filthy windows user that doesn't even have a linux install)
13:11:39 <shapr> if it works for you
13:12:10 <hyperisco> Solonarv, well for execution all it does is 1) are you asking to execute it and 2) does it have execute permissions. Meet 1 and 2 and that's an executable.
13:12:59 <hyperisco> chmod +x not_a_virus.jpeg && ./not_a_virus.jpeg
13:13:52 <hyperisco> Windows on the other hand sees .jpeg and is like "wtf mate"
13:14:45 <Solonarv> there's some part that needs to figure out how to execute the thing in the first place, no?
13:14:49 <hyperisco> so the Windows idiom is to rename to .exe first, then execute :)
13:15:23 <Solonarv> I guess I just don't like file metadata leaking into file names
13:15:42 <ab9rf> Solonarv: linux reads the first two bytes, and uses that to decide how to execute it
13:15:50 <ab9rf> Solonarv: windows is ... more complicated
13:15:54 <hyperisco> well that happened because no one can agree on file metadata
13:15:56 <Solonarv> Ah yeah, that's about what I vaguely remembered
13:16:22 <Solonarv> which leads to the amazingly useful thing that is #!
13:16:41 <hyperisco> but every file system at least has file names, modulo allowable characters and length and directory separators and drive paths
13:16:48 <ab9rf> Solonarv: lueah, #! is just the magic number ofr "this is a script, and the interpreter you should use appears immediately after #!"
13:17:07 * hackage gingersnap 0.3.0.0 - Consistent and safe JSON APIs with snap-core and (by default) postgresql-simple  http://hackage.haskell.org/package/gingersnap-0.3.0.0 (TomMurphy)
13:17:15 <hyperisco> so what happens if you encode your script in UTF-8 with BOM
13:17:27 <ab9rf> my recollection is that windows (DOS) uses a combination of extension and magic numbers
13:17:47 <shapr> hyperisco: it'll FEFF it up
13:17:52 * shapr makes terrible unicode jokes
13:17:59 <ab9rf> hyperisco: my recollectin is that a BOM at the start of a hashbang script will prevent it from executing, since FEFF is not 2321
13:18:33 <shapr> from wikipedia: "The byte order mark (BOM) is a Unicode character, U+FEFF"
13:19:03 * hackage gingersnap 0.3.0.1 - Consistent and safe JSON APIs with snap-core and (by default) postgresql-simple  http://hackage.haskell.org/package/gingersnap-0.3.0.1 (TomMurphy)
13:19:17 <hyperisco> good way to troll someone I think
13:19:33 <hyperisco> set some env var to change the default encoding on their text editor
13:20:21 <hodapp> is that like the old 'alias vi=rm' trick?
13:21:22 * Solonarv types `vim` instead
13:21:56 <hodapp> I said 'old' for a reason :P
13:23:25 <Solonarv> something something `alias vim='rm -rf --no-preserve-root /'`
13:24:04 * hackage gingersnap 0.3.1.0 - Consistent and safe JSON APIs with snap-core and (by default) postgresql-simple  http://hackage.haskell.org/package/gingersnap-0.3.1.0 (TomMurphy)
13:25:19 --- mode: glguy set +v smitop_
13:26:19 <__monty__> hyperisco: Or random replace some of their ;'s with ;'s.
13:27:46 <hyperisco> Mine doesn't cause permanent damage. Well, not to their files anyways.
13:28:41 <__monty__> If you're gonna troll...
13:43:37 <berndl> Anybody know what the contravariant version of Reader is called?
13:44:27 <Solonarv> Traced, I think?
13:45:07 <lavalike> what does it look like?
13:45:25 <Solonarv> @hackage comonad
13:45:25 <lambdabot> http://hackage.haskell.org/package/comonad
13:45:39 <Solonarv> Just look around in there, I don't know it by heart or anything
13:46:55 <Solonarv> ah, I misremembered - it's Env
13:46:59 <Solonarv> berndl: ^
13:47:22 <Solonarv> https://hackage.haskell.org/package/comonad-4.0.1/docs/Control-Comonad-Env.html
13:47:22 <berndl> Env? OK. I will check.
13:51:10 <berndl> Hmm... since Reader a b = a -> b, shouldn't Env a b = b -> a?
13:51:52 <Solonarv> oh wait derp, a contravariant reader wouldn't be a comonad
13:53:11 <c_wraith> yeah, extract is even less likely to work if the type is contravariant
13:53:26 <Solonarv> berndl: https://hackage.haskell.org/package/contravariant-1.5/docs/Data-Functor-Contravariant.html#t:Op
13:53:55 <berndl> Solonarv: That's it.
13:53:58 <berndl> Thanks man.
13:54:05 <bsima> how do i use a custom 
13:54:05 <bsima>  
13:54:06 <bsima>  
13:54:08 <bsima> [Fri Nov 30 2018]
13:54:10 <bsima> *** Topic for #haskell: https://www.haskell.org |
13:54:12 <bsima>     https://wiki.haskell.org/IRC_channel | Paste code/errors:
13:54:16 <bsima>     https://gist.github.com/ | Logs:
13:54:16 <bsima>     http://tunes.org/~nef/logs/haskell/?C=M;O=D |
13:54:19 <bsima>     https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic:
13:54:22 <bsima>     #haskell-offtopic | https://downloads.haskell.org | Identification or
13:54:25 <bsima>     Voice(+v) require to chat during spam                               [10:08]
13:54:28 <bsima> *** #haskell: topic set by glguy, 2018-08-02 09:06:52
13:54:31 <bsima> *** Users on #haskell: AMDPhenomX4Q APic Adeon Adluc Akii Amadiro AndreasK
13:54:34 <bsima>     Annihitek Anthaas Arahael ArchieT[m] Arguggi_ Ariakenom ArneB Athas Axman6
13:54:38 <bsima>     Azel Barnabas[m] Bergle_1 Big_G Bigcheese Bish Blkt Boobie Boomerang
13:54:41 <bsima>     ByronJohnson Cale Cathy @ChanServ Charn Chousuke CindyLinz Ckat
13:54:44 <bsima>     ClaudiusMaximus Clint CoderPuppy Cthalupa DTZUZO DTZUZU Dabo DavidEichmann
13:54:45 <MarcelineVQ> woops I guess
13:54:53 --- mode: ChanServ set +o dmwit
13:55:18 <Akii> ^^
13:55:35 <dmwit> (I've un-klined him.)
13:55:40 <bsima>     SamuelHenrique[m SegFaultAX Sgeo_ Shockk @Sigyn SlashLife Snircle_
13:55:45 <dmwit> bsima: Oh dear.
13:55:49 <Akii> :D
13:55:59 <dmwit> Perhaps it's for the best to stay that way...
13:56:04 <Akii> highlight all the persons
13:56:16 <Amadiro> Shouldn't have chosen a nick starting on A, I always get highlighted in these
13:56:18 <MarcelineVQ> this is what happens when you irc from emacs
13:56:24 <yuuki_> I'm trying to build & run a toy app I've built with Stack. The executable in .stack-work/dist/ works, the executable in .stack-work/install immediately exits with terminated by signal SIGKILL (Forced quit) (I'm using Fish shell). In bash I get Killed: 9. I have no idea whatsoever where to look or how to approach this. I'm on MacOS Mojave 10.14.1
13:56:46 <Shockk> Amadiro: hah, I mean, in fairness I got pinged too
13:56:50 <Shockk> and I'm all the way at S
13:58:40 <dmwit> He ways probably "sending" the remainder of the mispaste the entire time he was klined.
13:58:46 <dmwit> D-S got skipped. ^_^
14:00:20 <SlashLife> Amadiro: Didn't help *me* much now, did it? :P
14:01:19 <Shockk> 1000 users and they just happened to catch me on the single line after they came back :(
14:01:44 <dmwit> Had to be somebody...
14:02:48 <monochrom> Haha I have a few nested record types and I'm totally abusing NamedFieldPuns and RecordWIldCards and I'm writing like  case recordList of A{b=B{c=C{..}, ..}, ..}
14:03:05 <dmwit> Let's try that one more time...
14:03:12 <Solonarv> NamedFieldPuns are pretty awesome IMO
14:03:57 --- mode: dmwit set -o dmwit
14:04:15 --- mode: ChanServ set +o dmwit
14:04:28 <dmwit> bsima: Make sure not to paste a big thing this time... =)
14:04:46 <dmwit> If you do I'll try to kick you before Sigyn gets to you. ;-)
14:12:46 <monochrom> Ah my code doesn't really use NamedFieldPuns.
14:13:19 <monochrom> The moment I have "b=B{..}" that "b" is no longer a pun.
14:14:03 <Solonarv> something something use lenses
14:15:34 <monochrom> My use case is read-only.
14:16:05 <dmwit> It's winter though.
14:19:20 <Solonarv> hey, lenses can do reading! :P
14:21:04 <monochrom> Yeah I just want short code not category-theoretically sound code.
14:22:04 <monochrom> If there is a field name "y" belonging to record x, I want to just write "y", not "y x" or "x ^ _y" or ...
14:22:21 <monochrom> In other words I'm done with mentioning x over and over again.
14:22:33 <Younder> sorry
14:22:47 <berndl> monochrom: can that be done in Haskell?
14:23:12 <monochrom> Yes. See the last 20 minutes.
14:23:12 <Younder> well there is template haskell
14:23:55 <monochrom> "20 minutes" may sound a lot, but really there has been only 10 lines.
14:24:49 <Younder> ah lences
14:28:49 <__monty__> monochrom: Agda's "open" combined with "records define implicit modules" would be great for your use case.
14:29:38 <berndl> Indeed. Agda's records are awesome.
14:37:42 <monochrom> Also Javascript's "with"  >:)
14:38:18 <ski> does that extend a record/object with fields ?
14:41:02 <Solonarv> no; 'with(o) { ... }' seems to be analogous to 'case o of _{..} -> ...'
14:52:03 * hackage SecureHash-SHA3 0.1.0.0 - simple static linked SHA3 using private symbols and the ref impl  http://hackage.haskell.org/package/SecureHash-SHA3-0.1.0.0 (CarterSchonwald)
14:52:30 <ski> oic
15:02:18 <geekosaur> errrrr
15:03:08 --- mode: ChanServ set +o geekosaur
15:04:07 --- mode: geekosaur set -o geekosaur
15:04:16 <geekosaur> guess someone already got to it
15:09:31 <xacktm> noo lambdabot come back
15:09:47 <geekosaur> @bot
15:09:52 <lambdabot> :)
15:09:55 <xacktm> oh he's back nvm
15:10:43 <xacktm> looks like someone on the -beginners channel was being zealous 
15:11:11 <hodapp> ehh?
15:11:50 <xacktm> I was wondering why sigyn killed lambdabot, and that's why
15:12:14 <Solonarv> someone on #haskell-beginners issued a bunch of command to lambdabot, which caused both the asker and lambdabot to trip freenode's anti-spam
15:13:01 <geekosaur> ah, I was wondering what happened
15:14:13 <celphi> oh i didnt know there was a beginners channel
15:14:22 <celphi> thnx ppl
15:14:59 <glguy> celphi: It's just another channel, beginner questions are fine here, too.
15:15:04 <xacktm> ^
15:15:15 <celphi> k
15:36:31 <noan> is there a common pattern of like, an isomorphism through an effect? like a -> IO b and b -> IO a?
15:37:13 <celphi> So I'm learning about guards and I tried to make one but it fails. Any reason why?  https://wandbox.org/permlink/OcOKdMOyTqh6a944
15:37:20 <benzrf> noan: isomorphism in a kleisli category, surely
15:37:23 <noan> right now I just have my own typeclass for it but I was wondering if there was an existing pattern this better fits into
15:37:45 <koz_> celphi: [Char] isn't a constraint.
15:37:48 <zachk> linking Main, undefined symbol, on ghc 7.6.3 on openindiana, what do I do, when compiling
15:37:59 <koz_> You probably wanted a type of areYouCool :: String -> String.
15:38:06 <noan> benzrf, what would that look like codewise though?
15:38:11 <koz_> s/[Char]/[Char] a/
15:38:15 <celphi> I thought [Char] and String were same?
15:38:16 <benzrf> the conditions for that would be f >=> g = return and g >=> f = return
15:38:49 <benzrf> oh, perhaps that's not what youre looking for
15:38:51 <koz_> celphi: Yes, but if you write ([Char] a) => ..., you're saying that a must be an instance of the typeclass [Char].
15:38:57 <Solonarv> yes, and if you had written '(String a) => a -> String' you would've gotten basically the same error
15:38:59 <koz_> Which, you must admit, doesn't make the first ounce of sense.
15:39:04 <noan> benzrf, nah, just to leverage existing typeclass stuff here
15:39:10 <celphi> Oh.
15:39:24 <benzrf> noan: what makes this an isomorphism, exactly?
15:39:25 <noan> like if I could use some aspect of the Lens library or something
15:40:28 <noan> benzrf, it probably technically isn't. But, basically... (f >=> g) a == (g >=> f) b
15:40:29 <lyxia> noan: "Reflections on monadic lenses" (Abou-Saleh et al.) and other papers by these authors explore that kind of idea
15:40:30 <celphi> Which typeclass should I use then?
15:40:35 <celphi> Char?
15:40:47 <noan> if I wrote my shit right there.. nearly 1am and semidistracted
15:40:51 <zachk> Char is a type not a typeclass 
15:40:55 <Solonarv> celphi: that isn't a type class either
15:41:06 <benzrf> noan: what is b there
15:41:10 <benzrf> and a
15:41:15 <benzrf> no, wait, those are different types
15:41:18 <benzrf> that makes no sense :p
15:41:18 <noan> f :: a -> IO b
15:41:20 <Solonarv> just write 'areYouCool :: String -> String'
15:41:23 <noan> g -> b -> IO a
15:41:24 <celphi> k
15:41:39 <noan> the round trip is isomorphic with the exception of a failure of the Effect
15:41:41 <celphi> Trying to understand the point behind typeclasses.
15:41:58 <celphi> But i guess ill figure it out later in tutorial
15:42:03 * Solonarv nods
15:42:06 <noan> my specific case is actually.. ciphertext <-> plaintext
15:42:15 <zachk> typeclasses let you overload functions for different types 
15:42:18 <noan> since the act of decryption carries implicit failure
15:42:35 <Solonarv> celphi: are you still using tutorialspoint, or did you switch to something else?
15:42:47 <noan> I guess it's more of a prism through an effect
15:42:50 * noan shrugs
15:43:01 <celphi> im learnging from http://learnyouahaskell.com
15:43:26 <celphi> there's some parts it makes some big jumps
15:43:54 <Solonarv> oh damn I'm tired, I confused you with someone in #haskell-beginners
15:44:14 <celphi> np
15:44:18 <Solonarv> :D
15:45:01 <celphi> is it possible to make my function work with 0 / 1 too?
15:45:15 <koz_> celphi: In what sense?
15:45:35 <celphi> Well my current guards check for "Yes" and "No"
15:46:05 <celphi> can i add 0 and 1 but non string
15:46:09 <Solonarv> it's /possible/, but I don't think it's a good idea.
15:46:17 <koz_> celphi: What would the type of the function need to be to make that possible?
15:46:34 <celphi> int + string
15:46:44 <koz_> celphi: Actually spell the type in actual Haskell please.
15:47:15 <celphi> areYouCool :: Int, String -> String ??
15:47:22 <koz_> Int, String is not a type.
15:47:28 <koz_> (Int, String) is, but that's not what you want.
15:47:36 <koz_> (since that's a pair of some Int with some String)
15:47:49 <celphi> ( ) are tuples if i remember right
15:47:53 <koz_> You do.
15:48:08 <koz_> The closest thing to what you want would be something like 'areYouCool :: Either Int String -> String.
15:48:35 <koz_> Since 'Either Int String' means that you have either 'Left x' where x is an Int, or 'Right y' where y is a String, so you can case match on those.
15:48:42 <noan> celphi, (show int) ++ str
15:48:45 <koz_> But, to echo Solonarv, I'm not sure this is the plan.
15:48:52 <noan> implicit type conversion isn't a think
15:48:56 <koz_> s/the/a good/
15:49:10 <noan> but the idea of anything -> string is represented by membership in the class of types called Show
15:49:57 <celphi> ^ yeah i need a more indepth tutorial explaining members and types/ typeclasses of haskell
15:50:14 <koz_> celphi: I think LYAH talks about typeclasses at some point.
15:50:21 <koz_> It's been this end of ages since I looked though.
15:50:38 <celphi> It does., but it's very brief.
15:50:42 <ski> (koz_ : rather, it's a pair type, having component types `Int',`String'. so values of that type will be "pair of some Int with some String". unfortunately, the same syntax is used for the type of tuples, which is a bit confusing, imho)
15:51:07 <koz_> ski: Yeah, that's true. Thanks for being more precise.
15:51:57 <MarcelineVQ> speaking of precise, what is an example input and output for the function you want to make celphi?
15:52:07 <celphi> ok ill just stick to tutorial and keep chugging.. normally i learn something and try to make my own example., but they all failing lol.
15:52:19 <celphi> uhm
15:52:36 <celphi> So I learned guards., and function signatures
15:52:38 <koz_> celphi: If you come from a background in dynamically-typed languages, you'll run into this kind of thing a bit at first.
15:52:51 <celphi> Yeah i am.
15:53:32 <celphi> I was trying to use a typeclass in my function wtih a guard. So i kind of made up a stupid function.
15:53:44 <ski> noan : hm .. given `f :: T -> M U' and 'g :: U -> M T' (`M' a monad), if we want `f >=> g = return' and `return = g >=> f', then it seems likely to me this only works if `f = return . f0' and `g = return . g0', where `f0 :: T -> U' and `g0 :: U -> T', unless there's some kind of "anti-effects" in `M'
15:53:54 * ski would like to see an example of such a monad ..
15:53:56 <zachk> you could use typeclasses to have youAreCool :: (Cool a) => a -> String and make instances of Cool for Int and String 
15:54:28 <celphi> Oh i didnt know you could make you own.
15:54:35 <koz_> celphi: Yep, you definitely can.
15:55:11 <celphi> the keyword show is confusing-- it seems like it just turns an input into a string
15:55:24 <ski> it does
15:55:34 <Solonarv> It isn't a keyword, it's a function
15:55:43 <ski> (and it's not a keyword, it's just an ordinary variable name, bound to a function)
15:55:48 <zachk> celphi, you can make almost anything of your own in haskell other then say IO by yourself
15:56:03 <zachk> check out the Prelude celphi 
15:56:20 <celphi> Prelude?
15:56:31 <celphi> show is a variable?
15:56:40 <celphi> oh i see what you're saying
15:57:09 <geekosaur> remember that haskell makes no distinction between "functions" and "values"
15:57:11 <celphi> so like let show = a -> String
15:57:23 <celphi> oh didnt know that
15:57:36 <ski> a function is a kind of value
15:57:44 <ski> just like a number, or a list, or a tuple, is
15:58:09 <zachk> > let andOne = (+1) in map andOne [1,2,3] 
15:58:11 <lambdabot>  [2,3,4]
15:58:38 * ski would probably rather call that `orOne'
15:58:48 <zachk> -_-
15:58:57 <celphi> i havent learned the in function yet
15:59:14 <Solonarv> 'in' is not a function
15:59:17 <zachk> let something = expression in expression is syntax, not a function
15:59:21 <Solonarv> that *is* a keyword
15:59:25 <ski> `in' belongs to `let'
15:59:35 <zachk> you use let without in in do blocks, and you need the in in regular expressions 
15:59:50 <celphi> lol.. omg lol
15:59:54 <zachk> but I don't mean regexes 
16:00:32 <ski> (zachk : sorry, didn't mean to criticize your snippet .. just couldn't resist touching on "and" as multiplication, "or" as addition)
16:00:50 <ski> > [() | let]
16:00:53 <celphi> (+1) ?? is that a single tuple?
16:00:53 <lambdabot>  [()]
16:00:58 <zachk> ski: oic 
16:01:04 <zachk> no 
16:01:13 <zachk> its a partially applied function 
16:01:23 <ski> celphi : nope. no unituples in Haskell. that's an "((infix) operator) section"
16:01:37 <zachk> (,) , (,,) , (,,,,) .... etc are tuples 
16:01:46 * ski can't recall whether it's called a "left section" or a "right section"
16:02:06 <ski> (`()' is also a tuple, a nullary tuple, with zero components)
16:02:14 <zachk> I just call that one unit 
16:02:25 <ski> that's what i call the type :)
16:02:43 <ski> the value, i suppose i often say "the empty tuple"
16:02:47 <celphi> let andOne = (+1) in map andOne [1,2,3]   (using zachk's example)..., what is "in map"
16:03:03 <zachk> let goes with in 
16:03:06 <zachk> you havent seen map yet?
16:03:09 <zachk> map is fantastic
16:03:10 <ski> (in terms of vector spaces, it's a zero vector, of the zero-dimensional vector space `|R^0')
16:03:10 <celphi> nope
16:03:20 <zachk> map function list 
16:03:28 <celphi> it's like my 3rd day on Haskall
16:03:37 <ski> > toLower 'A'
16:03:37 <zachk> takes a list and a unary function and maps the function over the list producing a new list 
16:03:39 <lambdabot>  'a'
16:03:42 <ski> > toLower 'a'
16:03:44 <lambdabot>  'a'
16:04:00 <zachk> > map toLower "AM I YELLING?"
16:04:01 <celphi> so sorta like JS map function
16:04:02 <lambdabot>  "am i yelling?"
16:04:27 <Solonarv> Pretty much exactly like 'map' in JS, yes
16:04:36 <ski> "maps the function" meaning "applies the function, in turn, to each and every element"
16:04:45 <ski> (producing a new list with the resulting values)
16:05:20 <zachk> @src map 
16:05:20 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
16:05:29 <celphi> lol
16:05:43 <ski> @src map
16:05:44 <lambdabot> map _ []     = []
16:05:44 <lambdabot> map f (x:xs) = f x : map f xs
16:05:47 <ski> strange ..
16:05:52 <ski> > filter isUpper "Are We having fUn, yeT?"
16:05:55 <lambdabot>  "AWUT"
16:06:37 <zachk> ski: why didnt @src map work for me? 
16:07:13 <celphi> when i tried :i map i got map :: (a -> b) -> [a] -> [b] 	-- Defined in ‘GHC.Base’
16:07:45 <Solonarv> celphi: yes, that's right
16:08:27 <celphi> so that means i need: map (tuple) -> [list] and i get a [list] ?
16:09:11 <celphi> oh nvm., tuple uses comma not arrow
16:10:52 <zachk> map :: function -> InputList -> OutputList 
16:12:21 <dmwit> > "map"
16:12:23 <lambdabot>  "map"
16:12:25 --- mode: dmwit set -o dmwit
16:12:49 <zachk> hey celphi if you are still running ghc 7.6.3, could you do a gcc --version and tell me what version of gcc you are using? 
16:12:53 <dmwit> zachk: Odd. \bot just doesn't like you I guess.
16:13:06 <zachk> @src map 
16:13:06 <lambdabot> Source not found. Maybe you made a typo?
16:13:24 <zachk> @src liftM2
16:13:24 <lambdabot> liftM2 f m1 m2 = do
16:13:24 <lambdabot>     x1 <- m1
16:13:24 <lambdabot>     x2 <- m2
16:13:24 <lambdabot>     return (f x1 x2)
16:13:32 <zachk> weird
16:15:41 <AndreasK> In code like "f Con a1 a2 a3 ... = .... (Con a1 a2 a3) .... will GHC always reuse the argument or is there a decent chance it will rebuild the constructor in the body?
16:16:01 <Solonarv> it'll be rebuilt, IIRC
16:16:29 <Solonarv> if you want to reuse it, do: 'f x@(Con a1 a2 a3) ... = ... x ...' instead
16:17:20 <benzrf> zachk: @src is a fixed db
16:17:25 <benzrf> it doesnt do a real lookup
16:17:30 <benzrf> (iirc)
16:17:35 <zachk> yea but @src map worked for ski , try it and see 
16:17:47 <benzrf> o
16:17:55 <Solonarv> that isn't the real source code for a lot of these functions, so I can believe it
16:18:00 <AndreasK> So far in the core output it always seemed to rebuild it, was just wondering if that's just common or in practice always the case.
16:18:19 <AndreasK> *so far it always seemed to NOT rebuild it
16:18:36 <zachk> do certain versions of ghc require certrain versions of gcc and its toolchain to compile haskell correctly? 
16:18:37 <Solonarv> if you look at e.g. the source code of containers you'll see it uses @-patterns too
16:18:51 <Solonarv> zachk: probably, but I'd expect those version bounds to be pretty loose.
16:18:59 <hpc> i think @-patterns are growing on me
16:19:03 * hackage HCL 1.7 - High-level library for building command line interfaces.  http://hackage.haskell.org/package/HCL-1.7 (jlamothe)
16:19:29 <hpc> even absent what it's useful for when you want your code to do something
16:19:38 <hpc> it's got the name of a value and its structure right next to each other
16:19:42 <Solonarv> containers actually does some pretty neat stuff with @-patterns and ptrEq to get maximum sharing
16:21:15 <AndreasK> Solonarv: Yeah no doubt to force it to share @ is the way to go. Just never saw it fail to share so far when I checked which made me wonder.
16:25:19 <geekosaur> zachk, to bvuild ghc yes, to build ahskell code generally no (unless possibly some foreign export cases, but thatseems unlikely)\
16:25:26 <geekosaur> ghc does not compile to C
16:25:46 <Solonarv> There used to be a C backend, but it's deprecated/gone
16:25:53 <zachk> i've heard ghc uses gcc to do some stuff at compile time of regular haskell code, or at least 7.6.3 seems to 
16:25:54 <geekosaur> if you are using the LLVM backend, the versions of opt and lld must match what ghc expects
16:26:04 <geekosaur> zachk, no
16:26:06 <zachk> did 7.6.3 use the c backend? 
16:27:09 <geekosaur> 7.6.3 accepted -fvia-C but used -fasm instead
16:27:47 <zachk> is it using gcc as the assembler then? 
16:28:20 <geekosaur> that ti does, but gcc is not actually doing anything except possibly running aprivate version of the assemblr
16:28:31 <AndreasK> zachk: It uses as as the assembler, but there are some C stub files which are generated and compiled via gcc afaik.
16:28:41 <geekosaur> liekwise linking ses gcc as drivr, primarily to get the C runtime libraries
16:28:58 --- mode: glguy set +v bruteforcecat
16:29:12 <geekosaur> only in the case of foreign exports, or foreign import with "capi"
16:30:31 --- mode: glguy set -v bruteforcecat
16:31:13 <AndreasK> geekosaur: Also for static ptr stubs, and I think the actual "main" entry point as well.
16:39:19 <aplainzetakind> I want to run a parser that parses "====This====\n" into "This" over a huge file (skipping failed lines), and insert each match into a Set, to get a picture of the possible values occuring. I suppose I'll have to somehow make the set insertions happen while the parser is running, and vaguely I think I'll have to finally learn to use monad transformers.
16:39:27 <aplainzetakind> What should I read?
16:39:36 <aplainzetakind> I'm using megaparsec by the way.
16:41:47 <lyxia> you don't need a monad transformer for this
16:42:40 <lyxia> read a megaparsec tutorial
16:44:24 <hpc> for manipulating the set, parsers have a context state that's perfect for this
16:45:21 <aplainzetakind> "ParsecT e s m a is a parser with custom data component of error e, stream type s, underlying monad m and return type a."
16:45:46 <aplainzetakind> Or something else?
16:46:03 <hpc> data ParsecT s u m a
16:46:15 <hpc> they are all the same but e isn't there, and u is a user state
16:46:47 <hpc> using the user state corresponds to writing a context-sensitive grammar
16:47:31 <hpc> oh, i was looking at parsec
16:48:29 <hpc> anyway, not hugely important here i guess
16:49:15 <hpc> you'll probably end up writing a parser that gives you the list
16:49:23 <hpc> then fold over that list inserting into the empty set
16:49:27 <geekosaur> yeh, user state went away. it dats from wen nobody had worked out how to properly stack a parser with a MonadState yet. thats solved and the megaparsec docs should say how to do it in place of the user state hack
16:50:22 <hpc> you could use mutation (and have m = IO), but that shouldn't be your first choice here imo
16:50:57 <celphi> i cant even make a max function :(
16:50:59 <celphi> https://wandbox.org/permlink/ll9uAGGUX1ijiYSl
16:51:08 <Solonarv> you could use mutation with ST instead :V
16:51:21 <geekosaur> @where cis194
16:51:21 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
16:51:35 <geekosaur> celphi ^ this might work beter than LYAH
16:52:18 <Solonarv> Probably, yes
16:52:20 <geekosaur> also, that'sa fairly confused notion of what a list comprehension does
16:52:25 <dmwit> celphi: `maximum [a, b]` ?
16:52:29 <Solonarv> I used LYAH but I had a lot of catching up to do
16:52:35 <ski> zachk : maybe you managed to get some weird invisible characters in there ? did you try typing it anew ?
16:52:38 <aplainzetakind> Well, the file is 5.5G, a list would probably not work so well with all the multiplicities.
16:53:02 <celphi> :geekosaur do i have to wait for the semester to start to enroll?
16:53:05 <dmwit> celphi: If you really want to use a list comprehension, then `[x | x <- [a, b]]` would do. But `[x | x <- FOO]` is always exactly the same as `FOO`.
16:53:32 <geekosaur> celphi, it's nto thatkind of course. it's annotated course notes from the Spring '13 class; you work at your own pace
16:53:43 <geekosaur> and class materials
16:53:45 <aplainzetakind> In any case using m = IO/ST means I'll have to learn to use monad transformers, no?
16:53:46 <Solonarv> aplainzetakind: you probably want to use 'ParsecT e s (State (Set Whatever)) a'
16:53:54 <zachk> ski i don't think so I will try once more
16:53:57 <Solonarv> or IO/ST, yes
16:54:00 <zachk> @src map
16:54:00 <lambdabot> map _ []     = []
16:54:00 <lambdabot> map f (x:xs) = f x : map f xs
16:54:04 <zachk> now it works!
16:54:06 <Solonarv> aplainzetakind: yes, ParsecT is a monad transformer
16:54:18 <dmwit> > "hk> @src map "
16:54:20 <celphi> wheres the join button at
16:54:21 <lambdabot>  "hk> @src map "
16:54:25 <dmwit> ?src map 
16:54:25 <lambdabot> Source not found. I am sorry.
16:54:27 <dmwit> ?src map
16:54:28 <lambdabot> map _ []     = []
16:54:28 <lambdabot> map f (x:xs) = f x : map f xs
16:54:38 <dmwit> zachk: Okay, solved. You had an extra space at the end of yours, lol.
16:54:40 <Solonarv> using State will probably interact better with backtracking
16:54:48 <zachk> ahhh
16:54:50 <dmwit> zachk: What a dumb failure mode.
16:54:51 <Solonarv> celphi: "join button?"
16:55:10 <aplainzetakind> I actually did go through the nicta course StateT exercises, but I did them while barely understanding what's going on.
16:55:22 <geekosaur> oh crap, that link goes to th class regsitration ./ info page now
16:55:46 <dibblego> which link?
16:55:49 <aplainzetakind> How do I get enough practice to develop the intuition to use transformers fluently?
16:55:53 <dmwit> geekosaur: Not for me...
16:56:02 <hpc> works for me
16:56:19 <dmwit> celphi: There's no join button. You just... do the course. There's a link to the lectures and assignments at the top. You grab those and then you're on your own.
16:56:50 <dmwit> I mean not completely on your own. We'll help you as we can in here, e.g., and StackOverflow can be a good resource if you use it well.
16:56:56 <geekosaur> I'm  seeinga  page that starts with Mondays 1:30-3    Towne 309
16:56:59 <dmwit> But there's not like course staff that are assigned to help you.
16:57:05 <geekosaur> tis is not exacly obvious
16:57:11 <hpc> geekosaur: navigation at the top
16:57:32 <dmwit> geekosaur: Perhaps https://www.seas.upenn.edu/~cis194/spring13/lectures.html is a better link to have in \bot?
16:57:43 <Solonarv> aplainzetakind: use them! they're (mostly) pretty straightforward; for example a 'StateT Blah IO' lets you do IO and have a state at the same time
16:57:45 <geekosaur> probably
16:57:50 <dmwit> Okay. I'll change it.
16:57:59 <hpc> the instructor is in here occasionally
16:58:03 <hpc> but then, so are the rest of us :P
16:58:06 <dmwit> ?where cis194
16:58:06 <geekosaur> althugh it stll says due mondays at start of class
16:58:06 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
16:58:28 <geekosaur> nwo I know why we;ve had several confused people that I've seen...
16:59:39 <koz_> http://hackage.haskell.org/package/free-5.1/docs/Control-Comonad-Cofree.html gives examples for Cofree Maybe, Cofree Identity and so on. What would a Cofree (a,) be?
16:59:52 <koz_> (well, Cofree ((,) a) more exactly)
17:00:33 <hpc> koz_: its data constructor is (:<) - a :< (f (Cofree f a))
17:00:37 <hpc> substitute (a,) for f
17:00:43 <hpc> or to disambiguate, perhaps (b,)
17:01:02 <hpc> a :< (b, Cofree (b,) a)
17:01:10 <hpc> and repeat
17:01:16 <hpc> until you see the pattern
17:01:56 * ski suppose a space counts as an "invisible character", in some sense, though probably not a "weird" one
17:02:36 <koz_> hpc: It looks like a stream of alternating a and b.
17:02:48 <hpc> yep
17:03:38 <Solonarv> or alternatively, a stream of (a, b)
17:04:02 <koz_> OK, so that's _not_ quite what I was after. According to the same page, Cofree is useful for annotating syntax trees.
17:04:11 <celphi> thanks geekosaur ill try this site
17:04:19 <koz_> Could someone suggest to me what a Cofree meant to represent an annotated syntax tree looks like?
17:04:28 <Solonarv> a proper alternating stream would be 'data Alternating a b = a :> Alternating b a'
17:05:34 <dmwit> aplainzetakind: I really liked All About Monads for grokking transformers.
17:05:36 <dmwit> ?where aam
17:05:36 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
17:05:48 <Solonarv> koz_: define your AST like so: 'data ExprF x = Add x x | Lit Int', now the annotated AST is 'Cofree ExprF Annotation'
17:05:56 <shachaf> i,i I really liked About All Monads for grokking continuations.
17:06:00 <koz_> Oh, it's liek a recursion scheme.
17:06:04 <hpc> exactly
17:06:04 <Solonarv> Yup.
17:06:25 <hpc> the important part is unwrapping the recursion by giving it a parameter to "fix"
17:06:39 <Solonarv> The un-annotated AST is 'Fix ExprF', which is equivalent to 'Cofree ExprF ()'
17:06:40 <koz_> I think that was throwing me - I thought the 'a' (well, the thing of kind Type) that Cofree needed was the 'value', not the 'annotation'.
17:07:06 * Solonarv nods
17:07:18 <koz_> Wow, this... actually makes sense to me now.
17:07:51 <koz_> I remember a while back, when I was having to do some truly ghastly work involving randomly-generating syntax trees, then performing randomized targeted cuts and resplices, someone was like 'oh, use Cofree like hence'.,
17:08:05 <koz_> It made _zero_ sense to me back then, and the errors GHC would vom at me scared me.
17:08:14 <koz_> Now... I think I actually get why they suggested it. :P
17:08:33 <hpc> this is one of my favorite bits of programming that i never get to use
17:08:57 <hpc> taking some piece of recursive logic, untying the knot, then retying it with a different recursion scheme
17:09:01 <Solonarv> note: 'Cofree f a' is 'Fix (((,) a) .: f)'
17:09:17 <Solonarv> (where 'type (.:) = Compose' )
17:09:30 <aplainzetakind> dmwit: Thanks I'll check it out.
17:09:30 <koz_> So in the context of annotated syntax trees, ComonadCofree lets me... pull a parent apart from its children?
17:09:40 <koz_> (well, the unwrap function)
17:09:49 <Solonarv> and 'Free f a' is 'Fix (Either a .: f)'
17:12:59 <Solonarv> koz_: 'unwrap' in this context is 'throw away the annotation'
17:13:05 <koz_> Ah, I see.
17:13:26 <Solonarv> unwrap (ann :< blah) = blah
17:13:30 * ski had forgottten AAM existed
17:13:52 <koz_> OK, so as far as I understand, Cofrees can always be unfolded, but not always folded, as the Cofree construction might never 'stop'.
17:14:07 <koz_> (like in the Cofree (a,) example above)
17:15:12 <koz_> That's what coiter does - it's like unfoldr, but for Cofrees?
17:15:18 <koz_> (also that name still makes me giggle)
17:15:45 <c_wraith> koz_, https://gist.github.com/chowells79/dbc7c6df2af8f1e00aa6a037c1cfc3d8
17:15:45 <Solonarv> well, you can still fold infinite structures if the combining function is sufficiently non-strict
17:15:52 <Solonarv> but yes, that's right
17:16:04 <c_wraith> koz_, I had some fun with coiter and lenses
17:16:10 <koz_> c_wraith: I can see that, lol.
17:17:08 <MacSlow> Greetings everybody!
17:17:13 <koz_> And, from what I can see, Frees can always be 'folded', but not unfolded.
17:17:17 <koz_> (but I can't quite tell why)
17:17:26 <koz_> (also, why do iterA and iterM both exist?)
17:18:05 <koz_> Wait, never mond, there's an unfold function for Frees as well.
17:18:31 <koz_> s/mond/mind.
17:18:34 <Solonarv> both Free and Cofree are special cases of Fix
17:18:53 <Solonarv> which can in principle be folded/unfolded.
17:19:07 <koz_> Yeah, as you said - Free is a Fix of a sum, Cofree is a Fix of a product?
17:19:14 <Solonarv> Yup.
17:19:39 <shachaf> I'd say that Free is data an Cofree is codata or something like that
17:19:43 <shachaf> Not that you can really say that in Haskell
17:19:54 <koz_> shachaf: I remember reading something liek that a while back.
17:20:05 <koz_> And so Fix would be some magical thing which is the union of data and codata?
17:20:56 <ski> @quote cofree
17:20:57 <lambdabot> djahandarie says: Category theorists are morphisms for turning cofree theorems into free theorems.
17:21:23 <koz_> What on earth is a 'cofree theorem'?
17:21:29 <Solonarv> a pun?
17:21:38 <koz_> Aside from that.
17:21:46 <geekosaur> pun on the joke about mathematicians turning coffee into theorems?
17:21:52 <koz_> Yeah, I gathered as much.
17:22:04 <koz_> I was just trying to figure how you'd get a categorical dual of a free theorem.
17:22:05 <geekosaur> beyond that, proabbly not worth thinking about
17:22:37 <koz_> :t Fix
17:22:38 <lambdabot> error:
17:22:38 <lambdabot>     • Data constructor not in scope: Fix
17:22:38 <lambdabot>     • Perhaps you meant one of these:
17:22:39 <geekosaur> ...or if you have been, you've probably been drinking something stronger than coffee. and anyone wlse will need something stronger yet to understand it >.>
17:22:57 <koz_> geekosaur: I don't think I'm _quite_ ready to follow in Erdos's footsteps. :P
17:23:18 <koz_> % :t Fix
17:23:18 <yahb> koz_: f (Fix f) -> Fix f
17:23:31 <Solonarv> @hackage recursion-schemes -- koz_: this is where Fix is from
17:23:31 <lambdabot> http://hackage.haskell.org/package/recursion-schemes -- koz_: this is where Fix is from
17:24:05 <koz_> Solonarv: So wait, is Fix f a basically the union of f a, f (f a) , f (f (f a)), and so on, ad infinitum?
17:24:27 <Solonarv> "limit", not "union"
17:24:37 <Solonarv> also, there's no 'a'
17:25:14 <koz_> f is of kind Type -> Type, right?
17:25:17 <Solonarv> Fix f ≅ f ( f ( f ( ... )))
17:25:18 <koz_> (or rather, has to be)
17:25:22 <Solonarv> yes
17:25:27 <Solonarv> % :k Fix
17:25:28 <yahb> Solonarv: Fix :: (* -> *) -> *
17:26:12 <koz_> Am I right to be reminded of the construction of the first infinite ordinal here?
17:27:19 <Solonarv> maybe? you can't actually construct 'Fix Identity', though you can construct 'Fix Thunk'
17:27:26 <ski> @quote not.smart.enough
17:27:27 <lambdabot> Kernighan&Plauger says: "Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to
17:27:27 <lambdabot> debug it." -- Brian W. Kernighan,P. J. Plauger in "The Elements of Programming Style"
17:27:39 <koz_> ski: This is just a thought process more than anything.
17:27:55 <koz_> It's kinda like coming back to something you thought was really weird and mysterious and realizing it's really not.
17:28:11 <c_wraith> ski, on the other hand, edwardk has said he frequently writes code he isn't smart enough to in Haskell.
17:28:11 <koz_> Solonarv: Where Thunk is?
17:28:19 <ski> koz_ : "This" being ?
17:28:22 <Solonarv> 'data Thunk a = Thunk a'
17:28:32 <koz_> ski: All the stuff I've been asking about so far.
17:28:52 <koz_> Solonarv: How's that different to Identity?
17:29:06 <koz_> (naming aside)
17:29:16 <ski> c_wraith : yea, there's a certain sense in which you can be lead by the types through a "minefield", where you wouldn't be able to pass in a dynamically typed language, or even a less expressive statically typed one (where you can't do typeful programming as well)
17:29:22 <Solonarv> Thunk undefined ≠ undefined, but Identity undefined ≡ undefined
17:29:53 <Solonarv> (because Identity is a newtype)
17:29:58 <koz_> Ah, OK.
17:30:16 <Solonarv> so 'Fix Identity' is just a funny way of saying 'Void'
17:30:23 <ski> koz_ : hm, sorry. i suppose i haven't looked that closely at it. (do not think what i said was meant as some kind of subtly (?) criticism of what you said)
17:30:34 <koz_> ski: No worries.
17:30:48 <Solonarv> ...aww, recursion-schemes doesn't have 'type instance Base Void = Identity'
17:30:52 <Solonarv> that'd be cool
17:30:54 <aplainzetakind> @pl \x -> f x >>= g
17:30:55 <lambdabot> (g =<<) . f
17:30:57 <koz_> Solonarv: Send them a PR.
17:31:27 <ski> aplainzetakind : `f >=> g', aka `g <=< f'
17:31:38 <koz_> aplainzetakind: Also called 'fish'.
17:31:46 <aplainzetakind> Cool.
17:31:52 <aplainzetakind> That had to exist.
17:32:18 <ski> monad laws can be expressed as `(>=>)' being associative, and having `return' as left and right neutral elements
17:32:46 <zachk> ski, I find that description of the monad laws much clearer, it made them click for more with (>=>) 
17:32:48 <koz_> Kleisli category hell yeah.
17:32:59 <koz_> (who was this Kleisli person anyway?)
17:33:06 <ski> zachk : having them expressed in terms of `do'-notation also helps, i think
17:33:16 <aplainzetakind> Yes, <=< is much more natural.
17:33:28 <aplainzetakind> than =<<
17:33:58 <koz_> aplainzetakind: For the prupose of stating the monad laws, sure. In practice, I've written =<< _way_ more than <=<.
17:34:04 <ski> zachk : if expressed that way, i think most people would agree that they just encode "refactoring common sense"
17:34:26 <aplainzetakind> Is do notation considered harmful?
17:34:31 <Solonarv> 'join' can also be a useful way of looking at them
17:34:33 <Solonarv> aplainzetakind: no
17:34:34 <ski> aplainzetakind : no ?
17:34:57 <aplainzetakind> No reason, just curious.
17:35:01 <ski> aplainzetakind : sometimes the intermediate naming can be a bit annoying, and so you can use a modicum of other operators (instead, or as well)
17:35:23 <ski>   x <- foo . bar =<< blah  -- is not that uncommon to see
17:35:29 <zachk> do notation is great 
17:35:34 <ski>   x <- blah >>= foo . bar  -- is worse
17:35:40 <koz_> Yeah, especially if you, like me, work with mutable arrays.
17:35:50 <Solonarv> Yup. I also do 'x <- foo . bar <$> blah' fairly often.
17:35:51 <aplainzetakind> I mean, when trying not to use do gets too complicated, I feel like I'm missing a cleaner way to express what I'm trying to do.
17:35:55 <koz_> I'd _hate_ to write some of that code without it.
17:36:14 <Solonarv> I should use =<< more, I keep forgetting it's a thing I'm allowed to do.
17:36:30 <ski> Solonarv : yea, `return' and `join' formulation is nice .. especially if you use my custom notation :)
17:36:44 <Solonarv> ski: what's your notation?
17:36:50 <dmwit> koz_: It's not that bad. `x <- foo\ny <- bar\nstuff` is not so different from `foo >>= \x ->\nbar >>= \y ->\nstuff`.
17:37:01 <ski> (at least you should add the indices, to make it clearer what is happening. and perhaps draw it has an arrow chasing diagram)
17:37:27 <koz_> dmwit: I dunno, in my experience, it's a lot easier for me to make sense of what I'm writing (and what I've written) with mutable arrays using do notation, unless it's very simple.
17:37:55 <Solonarv> for completeness' sake: in terms of join, the monad laws are 'fmap join = join', and 'join . return = id' (IIRC)
17:38:13 <ski> Solonarv : `join (| return (||),m |) = m',`m = join (| m,return (||) |)',`join (| join (| m0,m1 |),m2 |) = join (| m0,join (| m1,m2 |) |)'
17:38:38 <ski> Solonarv : the type of `m' in the first two is `M', which is also the type of `m0',`m1',`m2' in the last one
17:38:58 * Solonarv scratches their head
17:39:04 <ski> the type of `return' is `id >---> M', and the type of `join' is `M . M >---> M'
17:39:06 <Solonarv> do you have a link where you describe this notation?
17:39:49 <ski> think of `M . M' as (squinting a bit) a kind of "product type", whose inhabitants have two components (the "outer" and the "inner" `M' level, in this case)
17:40:27 <Solonarv> oh no I got that part, I mean the (| |) stuff
17:40:53 <ski> in this case, i've elided talking about the actual values of type `A' in `M (M (M A))' at all. `m0' is the outermost `M'-level structure, `m1' is the middle one, and `m2' is the innermost one
17:41:54 <ski> `(| x,y |)' means that we have an expression `x' for a new outer level structure (having type `F' say, that being a functor), and `y' for a new inner level structure (having type `G'), which we "place beside each other", so that the whole expression has type `F . G'
17:42:15 <ski> (note that i'm talking about expressions having a type which doesn't have kind `*' here .. yes, this is weird, and fun :)
17:42:25 * Solonarv scratches their head some more
17:42:46 <ski> another example
17:43:11 <ski> consider `sing :: a -> [a]; sing = (:[])'
17:43:42 * Solonarv nods
17:44:06 <koz_> What is Eq1?
17:44:50 <Solonarv> 'Eq1 f' means 'forall a. Eq a => Eq (f a)', roughly
17:44:59 <koz_> Where is that described?
17:45:05 <ski> Solonarv : there are monoid law/theorems `forall m. mconcat (sing m) = m' `forall mss. mconcat (concat mss) = mconcat (map mconcat mss)'
17:45:13 <Solonarv> with new GHC versions we can write the latter directly, so Eq1 wll become deprecated eventually
17:45:30 <Solonarv> koz_: the docs for Eq1
17:45:43 <Solonarv> ski: makes sense so far
17:47:36 <ski> Solonarv : with my notation, i express those as something like `mconcat (| sing (||) ; m |) = (| ; m |)' and `mconcat (| concat (| l0,l1 |) ; m |) = mconcat (| l0 ; mconcat (| l1 ; m |) |)'
17:49:26 <ski> Solonarv : if `f :: F' and `g :: G', then `(| f,g |) :: F . G'. now i'm saying that if also `a :: A', then `(| f,g ; a |) :: (F . G) A' -- so here i'm also talking about the "elements/components" inside the levels of structure, i'm not *only* talking about those wrapping levels
17:49:46 <Solonarv> aaah, I see
17:51:03 <ski> Solonarv : example, consider `[[0,1,2,3],[4,5,6],[7,8],[9],[]] :: [[Integer]]'. the type is equal to `([] . []) Integer'. if i were to use `(| l0,l1 ; n |)' to refer to this, then `l0' refers to the outer list `[..,..,..,..,..]' including the outer list level, but *not* including (referring to) the element( list)s in that list
17:51:35 <ski> Solonarv : then `l1' will, "in succession", refer to `[..,..,..,..]',`[..,..,..]',`[..,..]',`[..]',`[]'
17:51:49 <Solonarv> Yep, it makes sense now
17:52:12 <ski> and finally `n' will refer to : `0',`1',`2',`3' ; `4',`5',`6' ; `7',`8' ; `9' ; -
17:52:23 <ski> (with a grouping/nesting of the sequence)
17:53:17 <ski> Solonarv : anyway, with the `return' and `join' example, the monad laws in this notation literally look like how you'd usually (pointful) state the monoid laws
17:54:05 <ski> Solonarv : and with the `sing',`concat',`mconcat' example, the laws look like monoid action laws (`sing' and `concat' being `return' and `join' for the list monad)
17:55:23 <ski> one can imagine some more extensions to this notation, as well
17:56:59 <ski> if we have a natural isomorphism in `F . G >~> G . F', then one could allow mentioning adjacent pattern variables of types `F',`G' out of order in the expression (definiens)
17:57:28 <fragamus> Hi everyone I'm trying to resurrect some code that edwardk posted some years back
17:57:30 <ski> (otherwise we have a strict "use structure-variables in the same order they were bound" rule)
17:57:49 <ski> a typical example of such commutation would be matrix transpose
17:57:57 <Solonarv> fragamus: what's the code?
17:58:15 <Solonarv> also, he appears to be online, so he may chime in himself
18:01:20 <aplainzetakind> what's the difference between sequence and sequenceA, except the former having a more restricted type signature? Is there a difference in the way "effects happen"?
18:02:10 <dyl> :t sequence 
18:02:12 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
18:02:17 <dyl> :t sequenceA
18:02:19 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
18:02:24 <nisstyre> aplainzetakind: wouldn't it depend on the instance
18:02:40 <geekosaur> Ithink te Applicative and Monad interfaces are required to be the same here?
18:02:42 <nisstyre> if the Applicative instance is different from the Monad instance
18:02:50 <geekosaur> so the main reason is that sequence predates Applicative
18:02:50 <nisstyre> that seems unlikely though
18:02:55 <dyl> The difference is that applicatives represent “pipeline like” effects or idioms, whereas monads represent more complete program structures. 
18:03:17 <dyl> Applicatives are “fixed pipelines”, whereas Monads admit dynamic branching behavior.
18:03:29 <Solonarv> Generally speaking they're meant to be the same as long as the Applicative and Monad instances are the same
18:03:53 <ski> `Applicative' instance ought to agree with `return' and `ap' from `Monad' instance
18:03:56 <nisstyre> dyl: if you have `Applicative a`, and `Monad a` then they could technically be different yes?
18:04:01 <dyl> sequence generalizes sequenceA
18:04:02 <geekosaur> so sequenceA admits a wider class of Applictives than just those that have (compatible?) Monad interfaces
18:04:05 <Solonarv> some instances are only "morally" the same, where e.g. <*> might perform actions in parallel (which 'ap' can't_
18:04:19 <nisstyre> the only reason for them to be the same is that you "should" make them the same
18:04:25 <dyl> nisstyre applicative behavior is a subset of monad behavior. 
18:04:32 <dyl> So when both instances exist they should behave the same. 
18:04:33 <geekosaur> nisstyre, technically yes but practically no because it's generally assumed that you can sue the Applictive in place of the Monad
18:04:36 <ski> dyl : `sequenceA' generalizes `sequence'
18:04:42 <nisstyre> agreed geekosaur 
18:04:53 <dyl> But in general applicatives are more general (less restrictive) than monads. 
18:05:01 <nisstyre> well they have different methods
18:05:12 <dyl> ski: yes my bad :p
18:05:23 <geekosaur> so you will confuse a lot fo people if you make tem different. I think this got "formalized" as a statement that if a type has both Applicative and Monad, operations common to both shoudl have the same behavior
18:05:38 <dyl> Yes. 
18:06:01 <Solonarv> Yup. the "interaction" laws are: pure = return, (<*>) = ap
18:06:11 <dyl> But the difference between an applicative and a monads is essentially whether *which operation succeeds the current one* varies dynamically based on data.
18:06:24 <geekosaur> also making them different would probably shatter ApplicativeDo… but that's far from its only fragility, so.
18:06:25 <ski> (every type that is an instance of `Monad' is an instance of both, nowadays. so just make that "any instance of `Monad' ought to satisfy : ...")
18:07:00 * ski isn't fond of statements to the effect that "all types that are instances of both these two classes ought to satisfy : ..."
18:07:08 <ski> (that's orphan laws)
18:07:21 <Solonarv> actually, making them different is the whole /point/ of ApplicativeDo
18:08:06 <Solonarv> it was brought into existence to allow exploiting the fact that <*> can be more efficient than >>=
18:08:36 <Solonarv> ApplicativeDo lets you use the convenient do-notation and still get the benefit of using your faster <*>
18:09:15 <geekosaur> not exactly. they still need *some* level of compatibility
18:09:48 <geekosaur> faster <*>, yes. if pure and return are different, you have a Problem(tm)
18:09:58 <Solonarv> Indeed.
18:10:19 <dyl> I personally always use “pure” just because the name is clearer.
18:10:22 <dyl> Even when working with monads.
18:10:25 <Solonarv> Then again 'return = pure' is in Monad, and there is a warning for Monad instances that define 'return'
18:10:27 <Solonarv> dyl: same
18:10:45 <dyl> Thank god the FAM thing is fixed now.
18:11:11 <geekosaur> ow, yes, ut asserting that level of compatiobility between them was necessary to enable that
18:11:30 <geekosaur> if we'd gone the direction fo "it'd be nice", we couldn't do that
18:11:53 * Solonarv nods
18:12:32 <Solonarv> and while some instances break <*> = ap in the strict sense, they do respect it "in spirit"
18:12:51 <Solonarv> i.e. depending on whether you used <*> or ap you might see network fetches happening in a different order
18:12:59 <dyl> Wait what. <*> = ap should be absolute... 
18:13:12 <dyl> I just think of <*> as sugar...
18:13:26 <Solonarv> ... but you should still get the same /result/, is what I was going to say.
18:13:33 <dyl> Still... 
18:13:49 <dyl> What is a good reason for their behavior to vary at all? 
18:14:01 <Solonarv> 'foo <*> bar' can compute 'foo' and 'bar' in parallel, 'foo `ap` bar' can't
18:14:29 <Solonarv> so if 'foo' and 'bar' are for example slow network fetches you can get quite the speedup
18:14:57 <dyl> Oh right ap is on monad.
18:14:58 * ski recalls listening to to talk by Marlow, on exactly this
18:15:04 <Solonarv> @hackage haxl is the motivating example
18:15:05 <lambdabot> http://hackage.haskell.org/package/haxl is the motivating example
18:15:07 <ski> s/to to/to a/
18:15:08 <dyl> I keep thinking ap is on Applicative. 
18:15:19 <ski> `ap' existed before `Applicative'
18:15:45 <dyl> But per the docs a well formed applicative/monad should have ap = <*>
18:15:57 <Solonarv> Indeed.
18:16:02 <ski> i remember reading a paper on adaptive/incremental computation, which wished `ap' had been a method of `Monad', so that they could special-case its implementation to be more efficient
18:16:02 <dyl> Not x `ap` y = x <*> y 
18:16:06 <dyl> But ap = <*>
18:16:12 <ski> (that was before `Applicative' was invented)
18:16:27 <dyl> haxl should use another function name other than ap then :) 
18:16:54 <Solonarv> haxl doesn't use ap
18:17:02 <dyl> According to the docs ap is on monad. 
18:17:13 <dyl> :t ap
18:17:14 <lambdabot> Monad m => m (a -> b) -> m a -> m b
18:17:22 <dyl> :t (<*>)
18:17:24 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
18:17:26 <Solonarv> Yes, but it isn't a class method.
18:17:34 <dyl> True.
18:18:33 <Solonarv> which means 'ap mf ma = do f <- mf; a <- ma; pure (f a)', always
18:20:46 <ski> @where adaptive
18:20:47 <lambdabot> "Adaptive Functional Programming" by Umut Acar,Blelloch,Harper in 2002 (POPL) at <http://www.umut-acar.org/publications/popl2002.pdf> and in 2006 (TOPLAS) at <http://www.umut-acar.org/publications/
18:20:47 <lambdabot> toplas2006.pdf>
18:20:50 <ski> @where incremental
18:20:51 <lambdabot> "Monads for Incremental Computing" (Functional Pearl) by Magnus Carlsson in 2002 (ICFP) at <http://www.carlssonia.org/ogi/papers/icfp-2002.pdf>,<http://www.carlssonia.org/ogi/Adaptive/>,in Hackage
18:20:51 <lambdabot> at <http://hackage.haskell.org/package/Adaptive>
18:21:42 <Solonarv> Which in turn means that strictly speaking, <*> isn't allowed to work in parallel if your type happens to also be a monad.
18:24:19 <ski> hmm
18:24:41 <spion> :o
18:24:42 <ski> isn't sequential behaviour a special case of concurrent behaviour ?
18:24:56 <Solonarv> So it is.
18:25:23 <Solonarv> But sometimes you want stuff to /actually/ happen at the same time, not /maybe/-but-actually-not happen at the same time
18:26:13 <ski> so if the concurrent implementation would allow performing `iab' completely before `ia' in `iab <*> ia', is there a semantics problem (as opposed to a pragmatics problem) ?
18:26:40 <Solonarv> Not as far as I know.
18:26:52 <Solonarv> But pragmatics are pretty important for some applications.
18:27:10 <ski> perhaps it'd not be the same if there was communication between these two parts
18:27:33 <ski> granted
18:28:02 <c_wraith> people are willing to accept more relaxed definitions of equivalent in monad/applicative laws.
18:28:36 <c_wraith> like, few people complain about how QuickCheck's Gen isn't a monad under strict equality checks.
18:28:52 <Solonarv> Yup. That's what I meant when I said stuff like "you still get the same result" and "the order doesn't matter"
18:29:12 <c_wraith> Gen only follows the Monad laws up to "all random numbers are equivalent"
18:29:24 * Solonarv nods
18:30:07 <Solonarv> "up to equivalence" is a pretty useful concept :D
18:31:57 <MarcelineVQ> glguy: there an advent group yet?
18:39:44 <ski> c_wraith : hm, i suppose i hadn't heard/thought of that
18:40:27 <c_wraith> ski, iirc it's actually mentioned somewhere in the docs.
18:40:31 <ski> you're saying grouping in `Gen' can affect which result you get, starting from the same PRNG state ?
18:40:41 <c_wraith> yes
18:40:44 <ski> interesting
18:41:10 <ski> hm .. i suppose it's using `split' on environment
18:41:27 <ski> (as opposed to threading)
18:41:36 <c_wraith> i think so.
18:41:46 <c_wraith> which behaves nicer with laziness
18:41:50 <ski> right
18:42:48 * ski is somehow reminded of oracles in Fudgets
18:43:20 * ski . o O ( comonoids )
18:50:51 <jle`> c_wraith: join the leaderboard if you want :)
18:51:53 <c_wraith> I should. is there a link on reddit?
18:53:10 <jle`> c_wraith: we're all in glguy's leaderboard, code 43100-84040706
18:53:28 <c_wraith> let's see if I can find this again when I get home. :)
18:55:11 --- mode: ChanServ set +o geekosaur
18:55:54 --- topic: set to 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Identification or Voice(+v) require to chat during spam | glguy's AoC leaderboard code 43100-84040706' by geekosaur
18:56:01 --- mode: geekosaur set -o geekosaur
18:56:50 <c_wraith> geekosaur, oh, that helps. :)
18:57:35 <geekosaur> we generally add it to the topic (last 2 years at least)
19:13:21 <koz_> Can GHC autoderive Eq1?
19:16:21 <Solonarv> I don't think so. Additions to the stock deriving mechanism are generally behind a language extension, and there isn't one for Eq1.
19:16:47 <koz_> Solonarv: Aww.
19:16:57 <koz_> It seems awfully mechanical, hence my question.
19:17:21 <Solonarv> Yes, it is. Fortunately QuantifiedConstraints will make it moot anyway.
19:17:25 <geekosaur> I think DerivingVia is supposed to enable such
19:17:35 <Solonarv> oh, good point
19:17:37 <koz_> geekosaur: What do you derive it via?
19:17:38 <geekosaur> ..btu someone still has to implement it
19:17:57 <koz_> s/do/would/
19:17:58 <Solonarv> I suppose it could be done without QuantifiedConstraints, by going through generic
19:18:14 <koz_> I was thinking that too, similar to GEq.
19:18:17 <MarcelineVQ> geekosaur: implement which?
19:18:54 <geekosaur> deriving Eq1, or other thngs that could eb done reasonably mechanically but aren't built into ghc
19:19:37 <Solonarv> so you'd simply write 'data Blah a = Blah deriving stock Generic; deriving via (DeriveEq1 (Blah a)) Eq1'
19:19:59 <geekosaur> once someone's written that. but now tey can write that instead of having to get it into ghc
19:20:23 <koz_> Ah, interesting.
19:20:27 <Solonarv> Yup. In practice it would probably be a single 'DeriveLiftedClasses' or something instead
19:20:56 <lyxia> you can also use generics
19:21:24 <Solonarv> Yes, the idea here is that DeriveEq1 uses Blah's Generic instance in its implementation of Eq
19:21:26 <Solonarv> * Eq1
19:22:03 <lyxia> But you can directly use Eq1 or Eq on Rep (Blah a)
19:22:59 <lyxia> BTW DeriveEq1 is called Generically by me https://hackage.haskell.org/package/generic-data-0.3.0.0/docs/Generic-Data.html#t:Generically1
19:24:05 <Solonarv> ooooh this already exists! that's awesome!
19:24:44 <koz_> lyxia: That's really useful - it may make it into my current WIP blogpost.
19:24:52 <Solonarv> geekosaur: apparently, someone has written that already :D
19:26:36 <lyxia> koz_: I'm interested!
19:26:50 <koz_> lyxia: Just playing around - I have half a forgotten idea. :P
19:31:55 <koz_> lyxia: So basically, I make my whatever an instance of Generic, when write 'instance Eq1 Foo where liftEq = gliftEq' and go about my day?
19:32:53 <lyxia> yeh
19:33:45 <lyxia> Generic1 actually, and you have to hope that it can be derived for your type (it's more restrictive than Generic), but if it can, that's it
19:34:27 <Solonarv> koz_: even better, you write 'deriving via (Generically1 Foo) (Eq1, Ord1)' (right, lyxia?)
19:34:28 <koz_> lyxia: I get this: https://gist.github.com/kozross/a6e08ab1d0d19c3e2d87995591fdd988
19:36:44 <lyxia> koz_: ah, there are missing Eq1 instances on GHC <= 8.4 (see the top of the doc, that says to import Generic.Data.Orphans)
19:37:24 <koz_> lyxia: OK, that works now. I was wondering wtf GHC just spewed at me, while giggling at 'DecidedlyLazy'.
19:37:28 * koz_ is DecidedlyLazy.
19:37:32 <lyxia> heh
19:39:06 <lyxia> In spite of the scary name I plan to patch that module, removing the instances as get into GHC, to avoid overlap and so you can use it for backwards compatibility.
19:39:12 * Solonarv is too lazy to decide whether they're lazy
19:39:20 * Solonarv is therefore UndecidedlyLazy
19:39:37 <koz_> Solonarv: As opposed to UndecidablyLazy?
19:39:39 <geekosaur> UndecidablyLazy
19:39:41 <geekosaur> heh
19:40:08 <Solonarv> Indeed. It's certainly /possible/ to decide whether I'm lazy, I just haven't done so.
19:40:37 <koz_> I think laziness is semi-decidable. If you're not lazy, you'll be motivated enough to figure that out, but otherwise, you'll never find out.
19:40:40 * ski . o O ( undecidable^2 : a statement which is undecidable whether it's undecidable )
19:40:41 <koz_> (too lazy)
19:40:56 <koz_> ski: Are you referring to 0''?
19:41:04 <ski> what's that ?
19:41:33 <koz_> 0 is the class of all computable functions.
19:41:41 <Solonarv> ...it only just clicked that this was an ASCII-art thought bubble, ski
19:41:47 <koz_> 0' is the class that contains HALT.
19:42:02 <koz_> ... actually, I'm not explaining this well.
19:42:05 <koz_> Let me link.
19:42:18 <koz_> https://en.wikipedia.org/wiki/Turing_jump
19:47:12 <koz_> Also, I finally think I got an intuition for Free f a.
19:47:19 <koz_> It's... kinda obvious beyond words now.
19:48:45 <lyxia> heh
19:49:27 <Solonarv> I'm watching Travis CI compile recursion-schemes and it's kind of funny how much faster the build is on newer GHC
19:50:07 <Solonarv> HEAD is 4:07, 7.8.4 took 9:27
19:50:48 <koz_> Solonarv: Have they been grinding at performance or something?
19:50:49 * ski . o O ( "refuting Rice's theorem implies WLPO" )
19:50:55 <koz_> WLPO?
19:51:09 <ski> Weak Limited Principle of Omniscience
19:51:24 <koz_> But... Rice's Theorem is correct?
19:51:39 <Solonarv> It's also plausible that older GHCs need to pull in more stuff (and therefore must do more work) that's already provided by newer ones.
19:51:40 <koz_> It's, like, the standard first 'this is why we can't have nice things' in computability theory.
19:52:11 <ski> yes, this is a statement of Rice's theorem, in a Martin-Löf type theory
19:52:40 <koz_> ski: Ah, OK. This is where I plead ignorance.
19:52:43 <koz_> (or stupidity maybe)
19:53:53 <ski> (forall-)LEM,LPO,LLPO,WLPO acts as weaker versions of falsity, in constructivism, wrt counter-examples, iow knowing when to give up attempting to constructively prove something
19:53:55 <koz_> Also, I just saw hoistFree, which in my context is amazing.
19:54:36 <koz_> Now I need to see if I can write this thing I want.
19:54:47 <Solonarv> what's that? '(forall x. f x -> g x) -> Free f a -> Free g a' ?
19:54:55 <c_wraith> glguy is 14th on his own leaderboard?  that's some fascinating tiebreaking
19:55:06 <koz_> Or, in my context 'remunge one tree into another'.
19:55:16 <koz_> c_wraith: Which leaderboard?
19:55:28 <c_wraith> see the topic. :)
19:55:47 <koz_> Oh, _that_ leaderboard.
19:56:04 <Solonarv> oh, it's in the channel topic! neat ;d
19:56:33 <c_wraith> I expect to hang out near the back of the leaderboard, just based on time of day.  *shrug*.  Should be fun anyway.
20:02:20 <koz_> OK, so thanks to lyxia, I now only ever need to derive two things ever.
20:02:25 <ski> koz_ : "The intrinsic topology of a Martin-Löf universe" (section 4) Martín H. Escardó in 2012-02,2012-05-15 at <http://www.cs.bham.ac.uk/~mhe/papers/universe-indiscrete-and-rice.pdf>
20:02:26 <koz_> Thank you, this is amazing.
20:02:37 <koz_> ski: This is _way_ out of my depth.
20:09:49 * Solonarv has forked recursion-schemes and is now trying to get vaguely acquainted with it
20:10:36 <koz_> Solonarv: Did it start from Base Void = Identity?
20:10:47 <Solonarv> yes, that's why I forked it
20:10:49 <koz_> Also, I get the feeling hoistFree can't do what I want, sads.
20:11:07 <koz_> I suspect this is because I don't understand what a natural transformation is beyond the type sig.
20:11:26 <Solonarv> I don't want to just change stuff in the github web interface and send off a half-baked PR
20:11:48 <Solonarv> (this is actually my first PR attempt ever, so...)
20:11:57 <koz_> Solonarv: Wow, good start.
20:12:17 <Solonarv> I mean it's like 5-10 mostly trivial lines, so
20:12:39 <koz_> ... yeah, it doesn't seem I can do a natural transformation between these functors.
20:12:41 <Solonarv> I'm not expecting it to be difficult or anything
20:12:47 <Solonarv> koz_: which functors are they?
20:12:52 <koz_> Solonarv: Let me paste.
20:15:35 * ski . o O ( "« So, you are doing logic... you must be warped... » The popular opinion about logic (here, my hairdresser, March 2000) seems to be shared by a good half of logicians : if something is simple, natural, it's fishy. you need 10-tuples at least for the most basic definition, and never write an equality if you can replace it with an isomorphism ; .." )
20:15:43 * ski . o O ( ".. to make the long story short, something is logical when you don't understand it. This cult of artificiality culminates in bleak competitions of the form : « My logic is terrible... Sorry, mine is definitely worse ! »." )
20:16:12 <koz_> Solonarv: https://gist.github.com/kozross/e5c2ec045a64de430ac99557f6e800e5
20:16:32 <ski> what is `Base' ?
20:16:38 * Solonarv is waiting for recursion-schemes to build locally
20:16:52 <Solonarv> ski: in this case, a type family from recursion-schemes
20:17:34 <Solonarv> 'type instance Base T = F' means 'T' is isomorphic to 'Fix F'
20:17:37 <ski> is the idea `Base [a] r = 1 + a * r' ?
20:17:48 <ski> ok
20:17:51 <Solonarv> Got it in one.
20:17:56 <ski> that's not unique, of course
20:18:11 <ski> perhaps there's a least solution, in some sense, hmm
20:18:44 <Solonarv> @hackage recursion-schemes
20:18:44 <lambdabot> http://hackage.haskell.org/package/recursion-schemes
20:18:52 <ski> (and is `Base' intended for inductive types, rather than coinductive ? or both ?)
20:19:07 * hackage ats-pkg 3.2.4.4 - A build tool for ATS  http://hackage.haskell.org/package/ats-pkg-3.2.4.4 (vmchale)
20:19:15 <Solonarv> Both. There are 'Recursive t' and 'Corecursive t' classes in that package, too.
20:19:38 <Solonarv> koz_: minor point, but GHC can derive Functor instances for you.
20:19:55 <glguy> Oh, it just occurred to me that aoc starts tonight and not tomrorow
20:20:03 <koz_> Solonarv: Yeah, I know.
20:20:07 <Solonarv> other point: yes, it looks like you'll need something other than hoistFree
20:21:00 <Solonarv> a NT from PLF to SMF can't inspect the 't' values, so your 'compiling' can't be described as one.
20:21:54 <benzrf> ski: imagine thinking that equalities are more natural than isomorphisms ;)
20:21:57 <benzrf> i kid, i kid
20:22:06 <ski> hm, `Base Natural = Maybe', but `Base (Maybe Natural) = Const (Maybe Natural)', while `Natural ~= Maybe Natural'
20:22:09 <koz_> Yeah, that makes sense to me even just by construction, given what I want to represent.
20:22:48 <ski> benzrf : well, i suppose HoTT is some kind of reconciliation with that
20:23:52 <Solonarv> in fact thanks to parametricity there isn't anything to an NT than its type; in other words, '(forall x. f x -> g x)' is always an NT
20:24:02 <Solonarv> (ignoring GADTs)
20:24:24 <benzrf> now where would we be without GADTs??
20:24:39 <benzrf> still in caves, surely
20:24:44 <ski> s/ignoring GADTs/assuming `f' and `g' are functors/ ?
20:25:24 <ski> (what if only one of them are ?)
20:25:38 <Solonarv> well yes, but they don't have to be Functor
20:25:41 <aarvar> Solonarv: isn't that true regardless of gadts?
20:26:15 <Solonarv> aarvar: no, because GADTs let the function recover the type of 'x'
20:26:21 <aarvar> so?
20:26:31 * ski supposes "is an NT" doesn't even make sense if they aren't functors
20:26:38 <aarvar> it's a natural transformation in the functor category (:~:) -> (:~:)
20:26:39 <aarvar> or something
20:26:58 <ski> what's `(:~:)' ?
20:27:04 <benzrf> a crying face
20:27:08 <aarvar> equality
20:27:18 <aarvar> :t Refl
20:27:19 <lambdabot> forall k (a :: k). a :~: a
20:28:06 <ski> looks like that's a type of an NT, not a functor category ?
20:28:42 <ski> (that NT would be a morphism in some functor category)
20:29:05 <Solonarv> aarvar: I'm apparently too tired to think coherently about this, sorry.
20:29:51 <Solonarv> All I remember is that "'(forall x. f x -> g x)' is always an NT" relies on parametricity, and GADTs break parametricity
20:29:59 <aarvar> ski: by that I meant the category of endofunctors on the category of equalities
20:30:31 <aarvar> er, equalities between types
20:30:57 <ski> say again ?
20:31:19 <aarvar> Solonarv: I don't think gadts break parametricity
20:33:50 <ski> well, if `data IsBool :: * -> * where ItsBool :: IsBool Bool', then consider `foo :: forall a. IsBool a -> Identity a; foo ItsBool = Identity False'
20:34:37 <aarvar> ski: what about it?
20:35:04 <ski> then `foo' being an NT would mean `forall (a :: *) (b :: *). forall (f :: a -> b). fmap @Identity f . foo @a = foo @b . fmap @IsBool f'
20:35:14 <ski> but `fmap @IsBool' isn't a thing
20:35:18 <aarvar> ski: that's for natural transformations in Hask -> Hask
20:35:36 <aarvar> and that would require that IsBool be a `Functor`, which it isn't
20:35:51 <aarvar> (where by `Functor` I mean functor from Hask to Hask)
20:37:09 <ski> so it's "Not even wrong !"
20:37:31 <blankhart> i am puzzled about how to profile a very vanilla, hello world program with cabal 2.4 and ghc 8.6.2.  so far i have encountered a compiler bug in which the 'impossible' happened, a number of errors, and a working program that produces no profiling output
20:38:53 <blankhart> i've installed the hvr ghc-8.6.2-prof package and pass -fprof-auto and -rtsopts in my ghc-options
20:43:01 <blankhart> nvm figured it out
20:52:41 <glguy> MarcelineVQ: Yeah, the AoC group code is in the /topic
20:53:44 <MarcelineVQ> It wasn't :>
20:54:03 <MarcelineVQ> should be fun
20:57:28 <blankhart> is there a way to have cabal put a built executable on my PATH?
20:57:52 <blankhart> cabal install doesn't work with the new- style commands on my project
20:58:17 <geekosaur> new-install should be a thing if your cabal is recent enough
20:59:58 <blankhart> oh nm i think new-install just doesn't work if the project name has a hyphen in it
21:00:14 <blankhart> it must interpret the hyphen as an option invocation
21:00:30 <c_wraith> you can use -- before that to disable option parsing
21:00:49 <systemfault> Oh it's on
21:00:56 <systemfault> AoC 2018
21:01:05 <c_wraith> So, right about time to start installing haskell on this computer, eh?
21:03:24 <suzu> its the aoc!
21:10:56 <Solonarv> gah! I thought I'd be asleep by the time it opened
21:13:19 <koz_> Solonarv: You never sleep though.
21:13:33 <koz_> Seriously, I've seen you on here at _every_ hour.
21:13:34 <Solonarv> I do though.
21:13:42 <koz_> What, do you micronap?
21:14:00 <Solonarv> No, my sleep schedule is just rather erratic
21:14:25 <geekosaur> some of us do that
21:15:09 <Solonarv> Naps mystify me. When I fall asleep it's invariably for several hours at least.
21:15:16 <koz_> Likewise.
21:15:26 <koz_> Napping is just something I've never really managed.
21:19:32 <c_wraith> Ok, That second one took me *way* too long.
21:19:58 <c_wraith> would have helped if I'd read the directions.  (hint to all those who haven't done it!)
21:23:52 <glguy> Reading the problem statement is a timeless hint
21:27:25 <suzu> for problem 1. part 1
21:27:38 <suzu> is there a drop-in replacement for 'read'?
21:27:41 <suzu> that i can use in this situation
21:27:54 <c_wraith> nothing I'm aware of
21:27:54 <suzu> it fails if the first character is a +
21:28:01 <suzu> and i'm trying to 'one-line' a solution
21:28:05 <suzu> in ghci
21:28:11 <glguy> read . dropWhile ('+'==)
21:28:17 <suzu> oh perfect
21:28:27 <c_wraith> I went with filter ('+'/=)
21:28:30 <c_wraith> all the same
21:28:37 <suzu> i wrote a damn whole function instead
21:28:50 <suzu> foo ('+':xs) = read xs, foo x = read x
21:28:52 <suzu> <_<
21:29:45 <glguy> That seems fine to me
21:29:56 <c_wraith> it's just not a cute one-liner
21:30:03 <suzu> yeah. i want the cute one-liner
21:30:10 <suzu> i've got that now though, thanks glguy 
21:33:48 <mniip> curious
21:34:58 <Solonarv> in case anyone was wondering, I made the PR: https://github.com/ekmett/recursion-schemes/pull/60
21:37:56 <mniip> wo-ah
21:38:08 <mniip> a C++ equivalent of my solution was 100 times faster
21:38:56 <mniip> that's uncool
21:39:17 <Gigabitten> isn't it fairly common for unoptimized haskell to be really slow
21:39:24 <mniip> it was -O3
21:39:35 <c_wraith> that's not really what "optimized" means
21:39:54 <Solonarv> -O3 just means -O2, by the way ;)
21:40:31 <c_wraith> mniip: was your solution slow enough to have visible processing time?
21:40:39 <mniip> yes
21:40:46 <c_wraith> Oh.  well that's expected
21:40:50 <c_wraith> err. unexpected
21:40:52 <mniip> tens of seconds
21:40:57 <mniip> the C++ one takes 0.1
21:41:18 --- mode: glguy set +v jackboy[m]
21:41:40 <glguy> mniip: Fix your Haskell solution so it runs closer to 0.1 then
21:42:08 <mniip> real    2m19.821s
21:42:19 <glguy> real	0m0.088s
21:42:34 <c_wraith> I didn't even compile mine
21:43:04 <glguy> I run it in GHCi for submission, but I figured I'd compile it to compare for this situation
21:44:20 <c_wraith> Just beware of O(n^2) solutions.  Doing better than that should be your first goal.
21:44:42 <mniip> n log n
21:44:44 <mniip> for some value of n
21:44:48 <mniip> (not the input size_
21:45:00 <jle`> i used stripPrefix
21:45:17 <jle`> parse x = (readMaybe =< ("+" `stripPrefix` x)) <|> readMaybe x
21:45:26 <jle`> oh sorry
21:45:33 <mniip> well for one, switching from Integer to Int,
21:45:34 <jle`> please do not read if you are avoiding spoilers!
21:45:36 <mniip> gets me down to 1m11.344s
21:46:11 <jle`> hm, my day 5 is 85ms
21:46:15 <jle`> er, my part 2 was 85 ms
21:46:19 <mniip> other than that I'm not sure what's there to fix
21:46:24 <mniip> it's all monomorphic
21:46:31 <mniip> a composition of good producers and consumers
21:46:34 <jle`> suzu (parse above was addressed to you)
21:46:38 <jackboy[m]> Is this channel a freenode or Matrix channel?
21:46:45 <jackboy[m]> Or is it a bridge channel?
21:46:45 <glguy> Freenode
21:47:11 <vaibhavsagar> freenode_jackboy[m] you can use Matrix to connect to it if you want
21:47:19 <mniip> my duplicates function doesn't admit any stray laziness
21:47:21 <mniip> I think
21:47:37 <vaibhavsagar> My solution didn't work until I changed `foldl` to `foldl'`
21:47:44 <Lycurgus> it is not however a matrix channel
21:47:52 <jle`> i remember writing a duplicate function last year but i forgot exactly how i did it, so i rewrote it again using explicit recursion
21:47:53 <vaibhavsagar> laziness is bad actually
21:48:08 <mniip> oh wow
21:48:14 <mniip> scanl -> scanl'
21:48:15 <jle`> i'm not too happy with an explicit recursion version though
21:48:17 <mniip> fixes it
21:48:18 <Lycurgus> the number of [m]s in the currently online list is prolly about accurate
21:48:35 <vaibhavsagar> mniip: dammit
21:48:55 <mniip> literally a 600x speedup
21:49:21 <jle`> my sol is 85ms even with scanl, hm
21:49:32 <jle`> https://github.com/mstksg/advent-of-code-2018/blob/master/src/AOC2018/Challenge/Day01.hs
21:49:33 <mniip> I wonder why though, is there no sharing in scanl
21:49:39 <c_wraith> what sharing?
21:49:54 <c_wraith> scanl is optimal as long as you don't ignore values while traversing the spine
21:50:08 <mniip> I mean even if I have a series of thunks [0, x, x + y, (x + y) + z, ((x + y) + z) + w, ...]
21:50:13 <mniip> and then I evaluate them in order
21:50:25 <Lycurgus> so what took 10 minutes now takes 1s?
21:50:36 <mniip> Lycurgus, 1m11s -> 0.12s
21:50:57 <c_wraith> that's...  really weird.
21:51:22 <c_wraith> What ghc version?
21:51:30 <Lycurgus> yeah that's essentially same
21:52:21 <mniip> err
21:52:22 <mniip>  8.7.20181104
21:52:37 <Lycurgus> that's a dev build i take it
21:52:37 <Arahael> Do we have a home-builder's channel here?
21:52:42 <mniip> yes
21:52:50 <mniip> I'll check with 8.4
21:53:10 <c_wraith> usually you don't build optimized compilers when building it yourself, since it's so slow
21:53:14 <c_wraith> That might be an issue
21:53:20 <mniip> no, it was a full build
21:53:34 <mniip> also "optimized compilers" means whether the ghc binary itself is optimized
21:54:02 <Lycurgus> well i wouldn't be surprised if 8.4 is different
21:54:12 <mniip> I think 8.4 is worse
21:54:17 <mniip> it's being slow even with scanl'
21:54:36 <Lycurgus> worse is different
21:55:14 <mniip> hmm, didn't there use to be an AoC spoilers channel
21:57:06 <jle`> we're hanging out in ##adventofcode
21:57:47 <mniip> I think I've identified the problem
21:58:35 <mniip> curious
21:59:46 <mniip> oooh
21:59:48 <mniip> right
21:59:53 <mniip> I was using Data.Foldable.elem in my duplicates function
21:59:57 <mniip> instead of member
22:00:18 <mniip> and elem has to traverse the entire set cause it doesn't have an Ord dictionary to work with
22:00:35 <c_wraith> So..  O(n^2) again. :P
22:00:57 <mniip> what's curious is that with scanl' it somehow became faster
22:01:50 <c_wraith> Recent versions of ghc must have some really clever optimization going on there that was exposed by additional strictness
22:02:11 <c_wraith> Maybe there's a rewrite rule on elem at the right types, actually.  That would do.
22:03:11 <mniip> wait what
22:03:49 <mniip> right, I think it didn't actually work with scanl'
22:03:57 <mniip> I might've measured the wrong executable
22:04:03 <c_wraith> oh, hah
22:04:07 <c_wraith> That would explain a lot
22:04:11 <mniip> so yeah
22:04:16 <mniip> don't use elem on sets
22:06:26 <c_wraith> Yeah, no rules that come close to applying in containers
22:06:33 <jle`> ah, elems vs members
22:07:12 <Solonarv> ...is there seriously not a safe version of (!!) in base?
22:07:58 <c_wraith> just use lens.  :P
22:08:04 <mniip> Solonarv, take 1 . drop n
22:08:14 <Solonarv> Yeah, that's what I'm doing
22:08:25 <mniip> hmm
22:08:29 <jle`> listToMaybe . drop n
22:08:31 <mniip> can RULES have contexts?
22:08:47 <jle`> Solonarv: i take the lack of a safe !! as a sign that you aren't really supposed to be indexing lists
22:09:00 <jle`> s/sign/message
22:09:12 <c_wraith> mniip: no, but they just don't apply if they don't still type-check after substitution
22:09:23 <Solonarv> Bah. I just want to have a static list of `Solution` and a function which grabs the nth one from in there.
22:09:45 <mniip> well this works: {-# RULES "Set.elem" forall (e :: Int) s. elem e s = S.member e s #-}
22:09:54 <mniip> but I don't think it's possible to write it for all Ord types
22:10:23 <c_wraith> if you just leave out the annotation on e, does it work?
22:10:57 <mniip> Could not deduce (Ord a) arising from a use of ‘S.member’  Possible fix: add (Ord a) to the context of the RULE "Set.elem"
22:11:08 <c_wraith> Hmm.  guess it doesn't!
22:11:55 <mniip> heh
22:12:06 <mniip> I initially wrote my duplicates function with lists
22:12:13 <mniip> then I quickly changed it to sets
22:12:23 <mniip> I was thinking "ah, elem, they're both foldable anyway"
22:13:10 <jle`> Solonarv: yeah, it's not meant to prevent you from safely indexing, just to discourage ;)
22:13:16 <c_wraith> and therefore you managed to precisely maintain computational complexity, too!
22:13:30 --- mode: glguy set +v fen
22:14:26 <fen> here is another attempt at the stream/linear/stack hierarchy using defaults; https://bpaste.net/show/764eae2987ce
22:14:36 * Solonarv is still setting up a scaffold
22:20:09 * ski . o O ( `scaffold :: Comonad w => w a -> w (w a)' )
22:21:33 * hackage xmobar 0.29 - A Minimalistic Text Based Status Bar  http://hackage.haskell.org/package/xmobar-0.29 (JoseAntonioOrtegaRuiz)
22:37:58 * Solonarv gets excited because they have a great reason to use cabal common stanzas
22:40:19 * Solonarv is really puzzled at `Warning: aoc2018.cabal: Unknown field "import"'
22:40:31 <Solonarv> ooh, they need to be at the start of the section...
22:43:11 <cocreature> it took me way too long to figure that out when I used common sections for the first time
22:46:04 <Solonarv> It'd be nice if the warning was "import must be at the start of the section" instead
22:56:17 <Wizek> Hey, is this supposed to work? https://gist.github.com/d008b00e33441728ef14b82c0bc0eec0
22:57:11 <Wizek> GHCid doesn't seem to be picking up on the file being changed
22:57:18 <Wizek> and reloading
22:58:46 <maerwald> how can I tell GHC to stop using gold linker?
22:59:28 <geekosaur> I think it'san entry in ghc's settings file
23:00:12 <koz_> :info Codensityh
23:00:20 <koz_> % :info Codensity
23:00:20 <yahb> koz_: ; <interactive>:1:1: error: Not in scope: `Codensity'
23:00:24 <Wizek> just tried, GHCi doesn't seem to be picking it up either
23:00:42 <geekosaur> pyanfar Z$ grep 'ld[.=]' /opt/ghc/8.2.2/lib/ghc-8.2.2/settings
23:00:42 <geekosaur>  ("C compiler link flags", " -fuse-ld=gold"),
23:00:42 <geekosaur>  ("ld command", "ld.gold"),
23:01:11 <Wizek> Introducing a syntax error in File.cpp.hs then `:reload`ing says "Ok, 36 modules loaded."
23:06:59 <MarcelineVQ> Wizek: is the file in your cabal extra-source-files ?
23:07:11 <MarcelineVQ> I dunno about that sort of thing, but just in case
23:07:53 <maerwald> why does: cabal new-install --ghc-options='-optl-fuse-ld=bfd' --ld-options='-fuse-ld=bfd' <pkg>
23:07:54 <maerwald> not work?
23:08:31 <fen> oh no, an undecidable instance will not resolve a type application :-(
23:11:24 <fen> on line 26 ... https://bpaste.net/show/a320c1844370
23:11:28 <Wizek> MarcelineVQ: I use hpack which auto-generates that field, and looking at the generated cabal file it doesn't seem to be in there. 
23:11:53 <MarcelineVQ> That's all I can think of to check, never #included+TH things myself.
23:12:31 <geekosaur> MarcelineVQ, thsi is about when ghci is running. ghci knows nothing about cabal files
23:13:08 <fen> it cant use a default signature because its a type specialisation
23:13:12 <MarcelineVQ> I thought maybe  cabal repl  might, no idea about it
23:13:43 <geekosaur> it still runs ghci in the end, and can't modify what ghci does on :reload
23:18:36 <Wizek> MarcelineVQ: I've added it to that field manually, ghci still ignores it 
23:19:32 <geekosaur> Wizek, if I'm understanding https://ghc.haskell.org/trac/ghc/ticket/4900 correctly (still working my way through it), addDependentFile doesn't work with ghci's recomp check and there are difficulties with making it do so
23:19:49 <Wizek> oh
23:19:52 <Wizek> that would be a shame
23:20:49 <geekosaur> and as of https://ghc.haskell.org/trac/ghc/ticket/4900#comment:81 it's still not implemented, there is a patch attached that doesn't work yet
23:21:27 <geekosaur> https://ghc.haskell.org/trac/ghc/ticket/4900#comment:67 what's wrong with the current patch
23:24:27 <koz_> I think my understanding jumped today. I've read something of Edward's _and it actually all made sense_.
23:24:49 <Solonarv> \o/
23:25:01 <Solonarv> out of curiosity, what was it you read?
23:25:24 <koz_> Solonarv: http://comonad.com/reader/2011/free-monads-for-less/
23:25:27 <koz_> And part 2.
23:26:04 <koz_> I remember Edward talking about how all free monad implementations have issues with performance, and he listed four: naive, Codensity, Church and the one that all the effects people love nowadays.
23:26:18 <koz_> And I never fully understood Codensity and Church. UNTIL TODAY.
23:27:54 <Wizek> geekosaur: okay, I've added myself to the cc list, maybe in 8 more years it gets addressed. In the meantime I'm writing up some more context about how this affects me and to see if anyone has any workaround ideas of this missing feature.
23:29:16 <geekosaur> if I unddrstand corectly,t e patch does work for many use cases, and there's a proposal to accept it as is and solve the missing cases (e.g. hs-boot files) soem other time because they're going to be Difficult and are usually avoided anyway
23:29:26 <geekosaur> so you might put your voice in on that
23:30:16 <geekosaur> (I suspect fixing hs-boot files properly will ultimately mean making them go away in favor of proper recursive import support)
23:37:20 <Wizek> geekosaur: yeah, both of those things would be nice indeed
23:38:00 <Wizek> are there serious talks on supporting proper recursive imports? Or is that just a "could be"?
23:38:32 <mniip> probably not
23:38:45 <mniip> a lot of effort for little yield
23:39:03 <geekosaur> ^
23:39:56 <geekosaur> and complicate and slow down a bunch of things for a very rare use case
23:41:03 <geekosaur> and I should have said cyclic imports
23:55:39 <systemfault> Do we have a special channel for help about AoC? I wanted a code review :/
23:56:51 <MarcelineVQ> sure, here or there's ##adventofcode
23:58:40 <systemfault> So, spoilers day 1 AoC https://gist.github.com/r-cyr/75eb6920e397eceb0c07dbb7db618534
23:59:23 <systemfault> I would like to know how I could remove repetition in main... and how to make the readInput function more readable
23:59:45 <systemfault> I'm a beginner, trying to use AoC as a way to level up
