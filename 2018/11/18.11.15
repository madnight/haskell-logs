00:06:49 <mniip> MarcelineVQ, he's in mleπ's discord
00:09:00 <MarcelineVQ> all these fancy new programming places :O  At this rate I'll have to get telegraph an go around saying "hello fellow kids"
00:12:16 <quicksilver> MarcelineVQ: personally I've given up keeping up and I just shout at them when they walk near my lawn
00:12:28 <MarcelineVQ> You have to be vigilant.
00:53:42 --- mode: glguy set +v rckd
01:02:46 * hackage bustle 0.7.3 - Draw sequence diagrams of D-Bus traffic  http://hackage.haskell.org/package/bustle-0.7.3 (WillThompson)
01:42:28 --- mode: glguy set +v govno
02:06:47 * hackage pure-shuffle 0.1.0.1 -   http://hackage.haskell.org/package/pure-shuffle-0.1.0.1 (igrep)
02:18:16 * hackage list-zipper 0.0.1 - A list zipper  http://hackage.haskell.org/package/list-zipper-0.0.1 (qfpl)
02:27:50 <salva> from inside a ghci session, is there any easy way to show the source code for a function?
02:54:59 <dminuoso> So let's say I have a situation where I obtain some `STM (STM a)` and I need to enforce that they are never placed into the same transaction. How would I do that?
02:55:39 <dminuoso> That is, you shouldn't be able to do something like `atomically . join $ thatThing`
03:06:45 <Maxdamantus> dminuoso: never used STM, but maybe `fmap atomically thatThing`?
03:06:57 <v0d1ch> salva: afaik you can load a module and then do ‘:e’ but that brings up entire source code
03:07:43 <Maxdamantus> dminuoso: that way you instead get an `IO a`, which will have its own transaction when it's run.
03:08:15 <phadej> dminuoso: phantom types, yet probably depends on "what goes wrong if they are joined"
03:25:19 <dminuoso> phadej: So here is some: do var <- newEmptyTVar; spawnThreadAndWriteToVar var; return (readTMVar var)`
03:25:44 <dminuoso> (There's some more subtle details in the middle going on)
03:27:18 <phadej> spawnThreadAndWriteToVar doesn't look like STM computation
03:27:41 <dminuoso> phadej: Okay it's illphrased. Essentially there happens a lot of TQueue shuffling with threads in the background
03:28:20 * phadej is not convinced
03:28:27 <dminuoso> phadej: think of that action as putting a reference to that TMVar into a TQueue - with a background thread working with network things to eventually satisfy the request. when the request is satisfied, the thread puts the TMVar
03:29:31 <dminuoso> Right now there's a TQueue for incoming network data, a TQueue for outgoing network data, a TQueue for requests. There then exists an infinite thread that takes a request (which has the original TMVar that comes from that code above), does network things, and then eventually puts into that
03:29:37 <phadej> too complicated
03:29:43 <dminuoso> Mmm.
03:30:29 <phadej> is the gist: if you join STM computations they will always `retry`?
03:31:18 <phadej> I guess, I'd use phantom type to separate them
03:31:21 <phadej> then
03:32:24 * hackage stackage-query 0.1.3 - Stackage package query  http://hackage.haskell.org/package/stackage-query-0.1.3 (JensPetersen)
03:33:13 <dminuoso> phadej: well due to the way they intefere, they can do nothing but hang if you join these.
03:41:08 <dminuoso> phadej: Alright that makes sense with phantom types. So it'd just be some `newtype STM' s a = STM' (STM a)` right?
03:43:37 <MarcelineVQ> how come in/out tchans instead of streaming procesing?
03:45:17 <MarcelineVQ> streamly has a few forms of stream behaviors that sound like they'd fit the simplified description above at "<dminuoso> Right now there's a  ..."
03:45:40 <MarcelineVQ> *instead of stream processing?
03:46:39 --- mode: glguy set +v soitgoes
03:47:16 --- mode: glguy set +v fen
03:48:55 <fen> the question about why classes are a useful feature of Haskell leads naturally to a justification for an interface to make local class instances
03:50:36 <fen> classes are a way to demand that values of some types are associated to a types which instantiate a class
03:51:03 <MarcelineVQ> fen: https://www.youtube.com/watch?v=kvgsZ01AJhI
03:51:20 <fen> the question about why use classes to do this arises because they serve a similar purpose in this respect to functions
03:51:30 <Peaker> hi, I installed the newest available cabal-install. cabal install tells me to use "new-install" or deprecated install. My VERY FIRST use of new-install just fails on the fact I don't have a package store in ~/.cabal/store. Seems a bit weird that the most basic use case just does not work?
03:52:00 <fen> functions also demand that values of some type are available. the difference is that a class gives types a default associated value
03:52:35 <phadej> Peaker: run `echo "" | cabal new-repl -b fail`
03:52:57 <Peaker> phadej, thanks. Any idea why an emergency fix isn't issued? This is a show-stopper bug
03:52:58 <phadej> Peaker: there's unfortunate bug which is already fixed, but there's no 2.4.0.x release to fix it
03:53:18 <fen> the values of the types the class consists of are provided with instances, where the user is able to choose which of several possible values of the correct type to associate to the type which is an instance of a class
03:53:18 <phadej> Peaker: dunno
03:54:16 <fen> but if there are several possible ways to implement the class, and provide values of the corresponding types of the class, why are these not just provided to functions directly?
03:55:50 <Peaker> Why does "new-install" not default to symlink bins to ~/.cabal/bin ? And does not build "." by default?  This is terrible UX. These guys really need some outside input
03:56:05 <fen> aside from the argument that class hierarchy can succinctly represent collections of arguments to a function which is independent of ordering, there is also the fact that only one fixed choice of implementation of constraints is appropriate for any type 
03:56:24 <Peaker> why not behave like old cabal in these simple decisions? No reason to rearrange the deck chairs here, it's hard enough to switch to a different system as it is
03:57:03 <fen> but since many possible implementations may be available, it might not necessarily make sense to fix the choice at the class instance 
03:59:01 <fen> instead, local instances can provide a way to utilise this mechanism of providing arguments to functions which are specific to some type, while retaining the ability to change between their various possible implementations.
04:00:34 <fen> classes are useful when associating implementations to a type is reasonable, but local instances make this choice dynamic. 
04:00:43 <Athas> Peaker: what does 'new-install' do?
04:00:55 <Athas> I vaguely recall that it copied to ~/.cabal/bin (which I would argue is bad behaviour).
04:01:26 <phadej> Peaker: please report your troubles to https://github.com/haskell/cabal
04:02:24 <phadej> Peaker: `Cabal` master does symlink to ~/.cabal/bin
04:02:39 <phadej> I'm not sure what you mean by "And does not build "." by default
04:02:58 <phadej> anyway, ranting on #hackage probably help, but if you really want a change, you should make an issue
04:17:11 <Peaker> phadej, thanks, I'll move to #hackage
04:29:22 * hackage thrist 0.4 - Type-threaded list  http://hackage.haskell.org/package/thrist-0.4 (GaborGreif)
04:32:16 * hackage list-zipper 0.0.2 - A list zipper  http://hackage.haskell.org/package/list-zipper-0.0.2 (qfpl)
04:32:40 --- mode: glguy set +v mkk
04:34:09 --- mode: glguy set -v soitgoes
04:35:28 --- mode: glguy set +v soitgoes
04:46:14 --- mode: glguy set +v soitgoes
04:49:44 --- mode: glguy set -v soitgoes
04:53:09 --- mode: glguy set +v Roybent
04:55:08 <Roybent> Hiranyagarbha (the cosmic egg).He is more prominently mentioned in the post-Vedic Hindu epics and the mythologies in the Puranas. In the epics, he is conflated with Purusha.
04:59:10 <MarcelineVQ> not to be confused with post-dinner mythologies, in those epics he is inflated with purusha
05:00:03 <ski> how about in monics ?
05:00:37 <Roybent> Hiranyagarbha (the cosmic egg).He is more prominently mentioned in the post-Vedic Hindu epics and the mythologies in the Puranas. In the epics, he is conflated with Purusha.
05:01:28 --- mode: ChanServ set -v+q Roybent *!*@49.125.12.185
05:02:01 --- mode: ChanServ set -q *!*@49.125.12.185
05:17:23 <fendor> what happens if during a call of `appendFile`, an async exception is raised, for example by `timeout`? Will the line be properly written to the file or is it possible that the line is written only halfway through?
05:19:24 <lavalike> fendor: this might be relevant https://www.stackage.org/haddock/lts-12.18/base-4.11.1.0/Control-Exception.html#v:mask
05:20:30 <lavalike> fendor: I always come back to this article when I have questions about asynchronous exceptions and code designed around them http://www.well-typed.com/blog/97/
05:22:02 <fendor> lavalike, this depends on the implementation of appendFile, but it is not documented...
05:22:53 <lavalike> fendor: it does use withFile so I thought it would fall under that umbrella
05:24:01 <Solonarv> withFile doesn't guarantee atomicity, it just guarantees that the file is closed properly
05:24:06 <Solonarv> (IIRC)
05:24:25 <lavalike> and withFile uses bracked, and bracket masks, so once one understands what that means one can answer your original question
05:24:29 <lavalike> *bracket
05:24:52 <fendor> lavalike, bracket does unmask when performing the operation, right?
05:25:13 <Ariakenom> fendor: yes
05:25:51 <Ariakenom> doesn't look like appendFile masks exceptions during the entire write, might have missed something though. https://hackage.haskell.org/package/base-4.12.0.0/docs/src/System.IO.html#appendFile
05:26:05 <fendor> however, imo, that should be documented. Then how can I make sure that the file is properly written in case of an async exception?
05:26:37 <fendor> Ariakenom, it probably doest make sense, if the string is really big to mask exceptions, since the program might become unresponsive
05:26:48 <Ariakenom> well file systems are annoying. I would think there are file system errors that can leave it half written too.
05:27:03 <Solonarv> sure
05:27:21 <Solonarv> one such file system error might even be "the hard drive was unplugged"
05:27:47 <fendor> Ariakenom, thats ok, i just want it to timeout the thread that writes to a file, i dont care about any external influences
05:28:49 <Solonarv> why are you tossing async exceptions at a thread and then trying to mask them in that same thread?
05:28:53 <Solonarv> that seems smelly to me
05:29:05 <Ariakenom> rename is often atomic so a common move is to copy-change-rename
05:30:08 <fendor> Solonarv, I have a long running process, e.g. that should be timeouted after some time. The long running process logs information to a file. I want to timeout the thread without damaging the file where the logs are lcoated
05:30:59 <fendor> other way might be, to let the thread check the time itself and kill itself if enough time has passed
05:31:12 <Solonarv> is there a reason you're not using a proper logging library?
05:31:32 <fendor> Solonarv, it felt like overkill? But no, no proper reason
05:32:05 <Solonarv> it's probably overkill for a straightforward use case, but you seem to have gone past that
05:32:07 <fendor> it didnt actually occur to me, i am writing statistical data, such as the iteration of the "loop" 
05:32:07 <MarcelineVQ> co-log is a pretty neat logging lib
05:32:21 <leshaste> hi.. how I install Control.Parallel.Strategies in OS X? I brew installed ghc
05:34:02 <fendor> MarcelineVQ, how is it better than lets say MonadLogger?
05:34:26 <leshaste> is it just cabal install parallel?
05:35:50 <MarcelineVQ> fendor: composability as a design goal  https://kowainik.github.io/posts/2018-09-25-co-log
05:35:52 <fendor> leshaste, depends on how you installed ghc and what you want to do, I fear. Do you have a project?
05:36:09 <Ariakenom> withFileAtomic would be nice actually.
05:36:18 <leshaste> fendor: Thanks.. I literally did "brew install ghc" 2 minutes ago
05:36:30 <Solonarv> that would work, but if you keep using 'cabal install blah' you might eventually make a mess of your package database and end up in "cabal hell"
05:36:42 <leshaste> interesting
05:36:55 <leshaste> I don't think I want to be in cabal hell 
05:37:12 <Solonarv> I wouldn't recommend it, I've been there
05:37:21 <leshaste> welcome back in that case!
05:37:41 <MarcelineVQ> Ariakenom, fendor: could examine and/or crib  https://hackage.haskell.org/package/atomic-write-0.2.0.6/docs/System-AtomicWrite-Writer-String.html#v:atomicWriteFile
05:38:40 <Ariakenom> MarcelineVQ: heh perfect
05:38:46 * hackage jaeger-flamegraph 1.0.0 - Generate flamegraphs from Jaeger .json dumps.  http://hackage.haskell.org/package/jaeger-flamegraph-1.0.0 (fommil)
05:39:02 <MarcelineVQ> Though uh, looking at it, I'm not exactly sure what part is truly atomic.
05:40:32 <Ariakenom> "(. flip hPutStr) . atomicWithFile" -.- no points in sight
05:40:35 <MarcelineVQ> that is to say there isn't any particular exception checking, uhm, anywhere, so maybe not a good example
05:40:51 <MarcelineVQ> even in the internals
05:41:45 <fendor> MarcelineVQ, it seems like the library uses rename and copy for atomicity 
05:42:34 <Solonarv> leshaste: anyway, to avoid cabal hell you generally don't install libraries globally
05:43:04 <leshaste> Solonarv:  got you
05:43:38 <Ariakenom> MarcelineVQ: it may not need any exception code with renaming
05:44:56 <fendor> Ariakenom, i think it does need excpetion code, because during the execution of any code, it might be interrupted
05:45:01 <MarcelineVQ> maybe, if you're okay with leaving temp files around the house
05:45:18 <Ariakenom> MarcelineVQ: does it remove them on success even?
05:45:27 <fendor> but you can probably add it yourself if needed
05:45:36 <Ariakenom> fendor: not during the rename syscall maybe
05:45:50 <fendor> Ariakenom, right, but during writing to the new file it might get interupted
05:46:02 <fendor> so the initial file is not hurt, which is probably enough for me
05:46:12 <Solonarv> leshaste: you probably want to set up a project, like so:
05:46:12 <Solonarv> $ mkdir trying-haskell && cd trying-haskell
05:46:12 <Solonarv> $ cabal init
05:46:23 <leshaste> thanks!
05:46:25 <MarcelineVQ> renameFile claims to be atomic https://hackage.haskell.org/package/directory-1.3.3.1/docs/System-Directory.html#v:renameFile
05:48:44 <Solonarv> leshaste: then you can add whatever packages you want (e.g. parallel) to the 'build-depends' section in the 'foo.cabal' file to specify you want to use that package, and open a GHCi session using 'cabal new-repl'
05:48:59 <ggole> rename(2) is atomic in Posix, and this is almost certainly a thin wrapper over it.
05:49:22 <Ariakenom> indeed
05:50:36 <Ariakenom> I don't get the tmp file handling but I don't know anything about how it should be done
05:51:17 <MarcelineVQ> well the temp should be removed on successful rename, unless I don't understand rename at all. but it looks to me like it sticks around on failure since there's no removal bracketing
05:51:57 <ggole> Typically temporaries are removed en-masse periodically rather than immediately
05:52:25 <ggole> Since that is more robust against badly written software (or things like power failures, etc)
05:52:53 <ggole> I mean, you *can't* be sure that your temporary file will be removed after you create it, so you have to handle that case anyway.
05:53:10 <MarcelineVQ> fair enough
05:54:13 <ggole> You might say that bracketing is good for managing file handles, but not files.
05:55:29 <Ariakenom> I'm somewhat concerned about name conflicts for the temp file
05:56:24 <Solonarv> those shouldn't happen if you ask the OS for a temp file
05:56:30 <fendor> temporary file names are chosen by the OS, right?
05:56:37 <fendor> it probably is some hashed filename
05:58:13 <MarcelineVQ> it uses https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#v:openTempFile   https://hackage.haskell.org/package/atomic-write-0.2.0.6/src/src/System/AtomicWrite/Internal.hs
05:58:26 <Ariakenom> yes, just noticed.
05:58:55 <ggole> There's mkstemp(3) for that, at least on Linux
05:59:15 <Ariakenom> Then my only remaining concern is race conditions for "doesFileExist targetFilePath >>="
05:59:55 <ggole> Ariakenom: if you first choose a non-existing name by inspecting the file system and open that, then there is a race condition
06:00:01 <ggole> That's why tmpnam is a bad idea.
06:00:23 <ggole> mkstemp avoids the race condition by merging those operations
06:00:34 <Ariakenom> ggole: it doesn't do that. I just thought it chose a name first. but it does use appropriate lib action
06:00:50 <Ariakenom> the check is on the original file
06:01:04 <ggole> Oh
06:01:06 <Ariakenom> for permissions and file mode
06:01:39 <MarcelineVQ> concerningly openTempFile does seem to do what ggole is saying isn't good though
06:02:30 <MarcelineVQ> in findTempName
06:04:53 <MarcelineVQ> probably for portability, and/or no one's had compelling reason to update that code in awhile
06:06:46 <MarcelineVQ> ah maybe O_EXCL prevents it being an issue
06:18:38 <adius> Hi, am I missing something or Is there no way to set the final name of an image created with stack
06:18:38 <adius> ```yaml
06:18:38 <adius> image:
06:18:38 <adius>   containers:
06:18:38 <adius>     - base: haskell:8.4.3
06:18:38 <adius>       entrypoints:
06:18:38 <adius>         - theapp
06:18:39 <adius> ```
06:18:39 <adius> leads to the image name `theapp-theapp`. How can I get only `theapp`? ^^
06:23:10 <MarcelineVQ> https://docs.haskellstack.org/en/stable/docker_integration/#configuration  suggests you can write    image: "imagename"   but I've never used docker so dunno, and the syntax might need some massaging since I never can tell what yaml will work until trying
06:25:22 <MarcelineVQ> mmm, looking like that syntax is out of date
06:28:08 <apeyroux> hello
06:34:55 <Ariakenom> apeyroux: hi
06:35:43 <adius> The `image` field does not seem to work, I already tried. I guess than something is broken ;
06:35:45 <adius> The `image` field does not seem to work, I already tried. I guess than something is broken …
06:36:14 <MarcelineVQ> it was accepted for me in the yaml but I don't have docker so I couldn't try it out
06:36:40 <MarcelineVQ> in this form https://gist.github.com/MarcelineVQ/964c9c9b98d899d2eb46f22239f47a1f
06:38:12 <MarcelineVQ> there's also a container-name: "example-name" field, I've no idea what that affects
06:38:19 <adius> No, the image field under `docker` means something else
06:38:27 <adius> it's the source image for the builder image
06:38:49 <adius> The image `image` is for the final target image
06:39:05 <adius> * The field `image`
06:40:18 <adius> `container-name` is also for the builder image and not the target image
06:44:03 <MarcelineVQ> oh, huh, the syntax for this stuff is in the yaml settings section instead of the docker section  https://docs.haskellstack.org/en/stable/yaml_configuration/#image
06:44:27 <MarcelineVQ> "You can specify the name of the image using name (otherwise it defaults to the same as your project)." worth a shot
06:44:59 <MarcelineVQ> probably still is gonna put a suffix on it though
06:45:06 <adius> Yeah, this sets the fist part in `theapp-theapp`, but I can't get rid of the second part 😭
06:45:33 <adius> the second part is the executable name
06:45:54 <adius> Maybe i must change the package.yaml to contain to executables list 🤔
06:46:10 <adius> Is there a convention for a default executable?
06:46:41 <adius>  to contain *no* executables list
06:49:05 <adius> I guess I'll have to fall back to renaming it 😒
06:55:02 --- mode: glguy set +v janulrich
06:55:22 <janulrich> i got another problem when installing binding-wx with cabal
06:55:46 <adius> MarcelineVQ: But thanks for your help!
06:56:05 <pja> > head [1,2]
06:56:08 <lambdabot>  1
06:56:11 <pja> Hah.
06:56:29 <pja> > (+) 1 2
06:56:31 <lambdabot>  3
06:57:21 <pja> Sadly 0-width spaces don’t work, or much fun could be had with really obtuse haskell.
07:05:27 <o1lo01ol1o> I have a large-scale series of trivial refactoring to do in a large code base.  It amounts to moving lots of functions renaming modules like `Foo.Foos.foosies` -> `Foo.Bar.foosies` and `Bar.Bars.barsies` -> `Foo.Bar.oldBarsies`;  this using ghc(js) 8.0 using several cabal subpackages.  Is there a good workflow for this sort of thing?  Even if only working in single sub projects at a time.
07:11:56 <Solonarv> haskell-ide-engine should be able to do that, IIRC
07:12:22 <tdammers> I'd use sed for that
07:12:32 <dmwit> sed comes to mind. If the usage conventions aren't super strong, you could consider using haskell-src-exts for better parsing.
07:19:37 --- mode: glguy set +v boi
07:24:18 <o1lo01ol1o> usage conventions are non-existent, ergo, the refactor
07:25:18 <o1lo01ol1o> Each module has a couple dozen imports from shared modules, I'd like to have those handled automatically if possible.  
07:25:50 <elgoosy> hi, im trying to follow the tutorial: https://tathougies.github.io/beam/tutorials/tutorial1/ However getting to the point of 
07:25:51 <o1lo01ol1o> Solonarv: hie has HaRe support planned but not supported yet, what functionality are you remembering?
07:26:50 <elgoosy> "defining our database" the code in the example does not compile. I get *Illegal instance declaration for ‘Database be ShoppingCartDb’..*
07:27:43 <o1lo01ol1o> elgoosy: does ghc suggest any pragmas for that?
07:27:44 <boi> Hello, i asked before and got helpful answers, but i realized i still dont get this concept: if we declare x type as x :: Int, it means x can only be Int, if we write x :: Num a => a, x can be anything that implements Num. Imo, it is logical that x :: a should mean that x can be anything, but that's not the case. What is the flaw in my logic?
07:28:24 <o1lo01ol1o> boi: x can be any `a`, not anything
07:28:56 <pjrt> x :: a, means `x` is an `a`
07:29:17 <pjrt> but `a` is `a`, not `anything`. I guess the word "anything" is a bit ambiguous. 
07:29:36 <elgoosy> o1lo01ol1o: no
07:29:59 <boi> if a isn't constrained, can't it be any type?
07:30:13 <mnoonan> `x :: a` has a hidden quantifier, it's really `x :: forall a. a`, meaning "for any type a, x has type a"
07:30:23 <Solonarv> o1lo01ol1o: apparently I'm remembering functionality it doesn't have!
07:30:24 <mnoonan> not "there is some type a that x has"
07:30:29 <Solonarv> I might have been thinking of intero
07:30:51 <mnoonan> or alternately: "if you give me any type a, I can produce an x with that type."
07:31:38 <o1lo01ol1o> elgoosy:  you'll probably need FlexibleContexts, FlexibleInstances, and MultiParamTypeClasses to make that instance legal
07:32:05 <o1lo01ol1o> as to why ghc didn't suggest those, i'm not sure
07:33:35 <pjrt> @boi It might be clearer if u think about `x :: a` as different than `f :: a -> a`
07:33:35 <lambdabot> Maybe you meant: yow join do bug bid bf
07:34:00 <pjrt> the `a` in those two cases is different
07:34:12 <elgoosy> o1lo01ol1o: thank you!
07:34:28 <mnoonan> pjrt: wat
07:34:41 <MarcelineVQ> @let x :: a; x = 'z'   -- something like this is incorrect because the type of 'z' isn't any type at all, like the variable a promises, it's specifically and only Char
07:34:41 <pjrt> Unn, just realized that's also wrong
07:34:42 <lambdabot>  .L.hs:233:5: error:
07:34:42 <lambdabot>      • Couldn't match expected type ‘a’ with actual type ‘Char’
07:34:42 <lambdabot>        ‘a’ is a rigid type variable bound by
07:35:38 <MarcelineVQ> Though I should have used mnoonan's terminology <_<
07:35:48 <boi> So, Num a => a and a don't, idk how to put it, work in same way? :: Num a => a is any Num and `:: a` is a 'container' for type, that doesn't mean anything on its own?
07:35:57 <pjrt> Yes, what Marceline said! That's where I'm getting tripped up. Not sure how to put it to word. 
07:36:45 <pjrt> Well kind of, I think it is a scoping issue. 
07:36:46 <mnoonan> boi: no, they do work the same way except "x :: a" means "if you give me any type a, I'll give you a value of that type", and "x :: Num a => a" means:
07:37:04 <mnoonan> "if you give me any value of type a *that satisfies Num a*, then I'll give you a value of that type"
07:37:51 <Solonarv> no, that's "Num a => a -> a"
07:37:54 <pjrt> `a` is a specific type, but u can specify the type "based on some scope". Like Marceline's example. Yes, `a` isn't a Char, BUT if you say `(x :: a) @Char`
07:39:56 <mnoonan> @let foo :: forall m. Monad m => m Int; foo = return 42 -- give me a monad M, and I'll give you a value of type M Int
07:39:58 <lambdabot>  Defined.
07:40:07 <mnoonan> > foo @[]
07:40:07 <dminuoso> boi: Consider a function `\x -> x + 1`, would you agree that the consumer of that function has the choice to pick x?
07:40:09 <lambdabot>  error:
07:40:09 <lambdabot>      Pattern syntax in expression context: foo@[]
07:40:10 <lambdabot>      Did you mean to enable TypeApplications?
07:40:23 <mnoonan> > foo :: Maybe Int
07:40:26 <lambdabot>  Just 42
07:40:28 <dminuoso> boi: Furthermore, would you agree that from the perspective of that function, you have to be ready to work with *all* choices of some value x?
07:40:31 <mnoonan> > foo :: [Int]
07:40:33 <lambdabot>  [42]
07:41:12 <mnoonan> > foo :: Either Char Int
07:41:15 <lambdabot>  Right 42
07:42:32 <boi> dminous, i get that, but if function is f :: a -> b; f x = 1 i can't make sense of it again
07:43:23 <pjrt> Well it can be, if u say add `Num b`
07:43:30 <Solonarv> boi: well that's not legal haskell; it's good that it doesn't make sense!
07:43:46 * hackage haskoin-store 0.6.4 - Storage and index for Bitcoin and Bitcoin Cash  http://hackage.haskell.org/package/haskoin-store-0.6.4 (xenog)
07:43:59 <mnoonan> Solonarv: oops, yes, I meant "x :: Num a => a means `if you give me any type a *that satisfies Num a*, then I'll give you a value of that type'"
07:44:07 <mnoonan> I over-valued :)
07:44:54 <pjrt> Ah, I think I see the confusion. "Anything" can mean "all the power" or "no power". In haskell (and math, I guess?) it is the latter. 
07:45:17 <boi> Solonoarv: i should've worded that differently: i don't get why f :: a -> b; f x = 1 is not legal. To me, that's absolutely ok
07:45:17 <Ariakenom> boi: what about (f ::  Num b => a -> b)?
07:45:33 <Ariakenom> with explicit foralls (f :: forall a b. Num b => a -> b)
07:45:35 <pjrt> Don't think of `b` as `Object` in, say, Java, where it can be `anything`. `b`, because it has no restriction, means it can't be anything but itself. lol
07:45:58 <Solonarv> boi: 'f :: a -> b' means "whoever's calling this function can pick whatever they want for 'a' and 'b'"
07:46:20 <boi> pjrt: but when it's `f :: a -> b` a is `all the power`
07:46:30 <pjrt> does it?
07:46:31 <Solonarv> if the caller picks 'b = String' and you give them '1', that's a problem!
07:46:51 <pjrt> There is a cool example around this
07:47:02 <pjrt> complete the following function: `f :: a -> a`
07:47:15 <pjrt> What definiton could `f` have?
07:50:14 <pjrt> @let f = (_ :: a -> a)
07:50:15 <lambdabot>  .L.hs:234:6: error:
07:50:15 <lambdabot>      • Found hole: _ :: a1 -> a1
07:50:16 <lambdabot>        Where: ‘a1’ is a rigid type variable bound by
07:50:26 <boi> pjrt: i know that it's identity function, but my intuition tells me it can be anything
07:50:51 <pjrt> Yes! it can only be identity, but you understand why? 
07:51:09 <boi> because input and output types are the same
07:51:30 <pjrt> Not quite, consider this one
07:51:40 <pjrt> g :: Num a => a -> a
07:51:52 <pjrt> What definition could `g` have?
07:52:39 <boi> g x = x i think
07:52:58 <boi> i think im getting where my confusion comes from
07:53:00 <Solonarv> that is certainly a valid definition!
07:53:03 <Solonarv> are there any others?
07:53:07 <pjrt> @let g = (_ :: Num a => a -> a)
07:53:08 <lambdabot>  .L.hs:234:6: error:
07:53:08 <lambdabot>      • Found hole: _ :: a1 -> a1
07:53:08 <lambdabot>        Where: ‘a1’ is a rigid type variable bound by
07:53:18 <pjrt> Lame, didn't show the whole thing
07:53:41 <pjrt> But yes, that's one definition, but are there others?
07:55:00 <boi> if it does count, we can match anything that implements num i guess
07:55:31 <dminuoso> boi: Have you considered my original question?
07:55:49 <dminuoso> boi: Type variables can be thought of as "parameters" on a type level.
07:56:11 <dminuoso> So something like `a -> b` means the *user* of that function gets to *freely* pick whatever a and b are supposed to be
07:56:18 <pjrt> yes, we could do `g x = x + 2`
07:56:23 <pjrt> or `g x = negate x`
07:56:36 <pjrt> or anything else that could possibly act on a number
07:58:03 <dminuoso> boi: It's like `\x -> x + 1`, the user gets to freely decide what `x` is going to be - you have no control over it.
07:58:10 <pjrt> Why? Becuase we have restricted `a` to be a number. This is what I meant by "anything" means "nothing". If u know nothing about a varibale, `a` (with no restriction like Num or otherwise), then that variable can `only` be itself. 
07:59:41 <pjrt> Since universal identity is a thing
08:04:05 <boi> dminuso, pjrt, Solonarv: i think i got it! I thought that thinking of `a` in a way suggested by dminuoso was wrong, because in case of `f :: Num b => a -> b; f x = 1` we could expect only Int instance, but turn out type of `1` is actually `Num a => a`,  and, as expected, `f x = 1 :: Int` doesn't typecheck.
08:04:25 <dminuoso> boi: A constraint can be thought as *an additional* argument ontop.
08:04:43 <dminuoso> boi: so `x :: forall a. a` takes a type variable
08:05:04 <dminuoso> boi: `x :: forall a. Num a => a` takes a type variable and a dictionary 
08:05:47 <dminuoso> boi: Or rather think of it as reducing the number of choices of `a` to those that have an instance Num.
08:05:58 <dminuoso> So the caller can still pick any a... as long as it has an instance Num.
08:09:36 <boi> thanks to all, i think it all makes sense to me now
08:21:44 <elgoosy> `allUsers = all_ (_shoppingCartUsers shoppingCartDb)` from tutorial also does not compile with this message https://pastebin.com/sMnKZa5N
08:29:16 * hackage freer-simple 1.2.1.0 - Implementation of a friendly effect system for Haskell.  http://hackage.haskell.org/package/freer-simple-1.2.1.0 (lexi_lambda)
08:54:21 --- mode: glguy set +v edgar_
09:20:19 --- mode: glguy set +v govno
09:30:16 --- mode: glguy set +v t4nk191
10:24:07 --- mode: glguy set +v biggun
10:28:31 --- mode: glguy set +v daad
10:30:00 --- mode: glguy set +v uyetw
10:39:46 * hackage haskoin-store 0.6.5 - Storage and index for Bitcoin and Bitcoin Cash  http://hackage.haskell.org/package/haskoin-store-0.6.5 (xenog)
10:51:18 --- mode: glguy set +v biggun
11:13:16 * hackage servant-kotlin 0.1.1.4 - Automatically derive Kotlin class to query servant webservices  http://hackage.haskell.org/package/servant-kotlin-0.1.1.4 (matsubara0507)
11:35:48 --- mode: glguy set +v tokamak
11:38:39 --- mode: glguy set -v tokamak
12:18:19 <dsal> Is there any magic being done on making compilation faster?
12:18:46 <dsal> I'm a little surprised at how long it takes me to "get" packages.  I can spend a full day compiling a couple small projects.
12:20:04 <pjrt> wow, that sounds wrong. Are u downloading the dependencies every time or something?
12:20:08 <koz_> dsal: I've never found it to be _that_ bad.
12:20:08 <MarcelineVQ> is it dependencies that are taking awhile?
12:20:40 <dsal> Yes, dependencies can take a while.  Some are worse than others.
12:21:21 <dsal> My own compilation isn't too bad (it's orders of magnitude slower than other stuff I do, but still not terrible).  But some dependencies can use an insane amount of resources just to acquire.
12:21:23 <dsal> e.g., aeson.
12:21:58 <c_wraith> but why are you rebuilding it all the time?
12:22:12 <pjrt> yeah this should only happen during the first compilation
12:22:12 <c_wraith> that seems like something that needs to be addressed
12:22:15 <dsal> Well, not all the time, but the initial build can be pretty bad.
12:22:24 <dsal> And I do initial builds on occasion.
12:23:03 <pjrt> Unn, not sure why you would need to do that often, unless there is something wrong
12:23:39 <dsal> OK, but whether I should do it often or not is a bit orthogonal with whether it takes an unreasonably long amount of time when I do it.
12:23:54 <pjrt> But to answer the first Q, idk of any magic. I believe -O's somewhat affect it
12:24:29 <dsal> I've worked around the issues to some degree by trying to do all my builds for all the things for all the versions on one machine and copy bins around.  I used to try building code on machines where I wanted to run it, but I can spend a full day on a machine trying to do the first build.
12:24:54 <MarcelineVQ> It's not an unreasonable subject, some packages do use what seems like a silly amount of memory to build. often compounded by multiple dependencies being built at the same time
12:25:10 <pjrt> Well Haskell is a language with a pretty feature-heavy type system, which is all compiled from source, so that's gonna be quite slow during initial runs
12:25:12 --- mode: glguy set +v kangan
12:25:18 <dsal> Yeah.  I've tried to work around that on memory constrained machines.  it was quite a struggle to get there.
12:25:28 <MarcelineVQ> But time, they shouldn't take forever to build, are you running out of memory and thrashing?
12:25:40 <dsal> I've had that, for sure.
12:26:25 <dsal> I've got a few projects and a shell script that builds them all with stack three ways (default, lts, and nightly).  And also builds them for ARM in addition to the native build.  If I do a clean build, it'll take a day or two.
12:27:43 <pjrt> Ah, I see. Yeah, not sure how to get around that. 
12:28:24 <dsal> I occasionally get a new computer as well...
12:28:40 <dsal> But it does seem like there's room for improvement that would have a fairly broad effect.
12:28:42 <pjrt> But you aren't the first person I've heard complain about long build times in CI for GHC
12:29:09 <pjrt> And CI is one of those use cases where u probably want a clean build every time
12:29:35 <dsal> I do have one issue in the ARM build where it memoizes "can't get GHC" and never works until I clean it.
12:29:38 <monochrom> Oh yeah, watch out for the trade off between -j??? and memory.
12:30:26 <monochrom> Although, if you say "I have 8 cores, 128GB RAM" then not a concern.
12:31:03 <dsal> It's a bit less of a pain on my bigger machines.  I've got an older Atom that may have been slow, and my ARM machines I've mostly given up on even trying to build on.  heh
12:31:09 <monochrom> Oh haha, memoizes "can't get GHC".
12:31:59 <koz_> Yeah, if you double the -j arg, expect memory load to roughly double too.
12:32:03 <dsal> Yeah, I don't exactly understand how that GHC thing happens...  It doesn't come out for all platforms at the same time and I've had the tools forget.
12:32:20 <dsal> I think I did hit 100% CPU on a build yesterday on a largeish machine, so that's probably fine.
12:32:59 <monochrom> I estimate that with >=75% probability GHC uses <=2GB RAM.  So if you have (# of cores)*2GB <= (your RAM size) you can safely maximize -j.
12:33:11 <monochrom> Perhaps s/estimate/guesstimate/ too
12:33:44 <dsal> Is there any way to get some build metrics out?  That might be useful.  I remember seeing aeson taking a lot of resources to build, but I don't know what all bits are slow.
12:34:52 <chessai> aeson probably takes a while to build because almost everything is marked inline
12:34:57 <chessai> and theres generics/th stuff in there
12:35:06 <monochrom> text also takes both a long time and a lot of space.  This one is explained by crazy rewrite rules to get fusion to happen.
12:35:15 <Welkin> I wrapped a streaming response with `try` and `finally`, but I don't get the result I thought I would when the connection is broken
12:35:26 <chessai> Welkin: gist?
12:35:46 <Welkin> it must be a misunderstanding of how warp handles connections perhaps?
12:35:49 <monochrom> crazy rewrite rules ==> you're asking GHC to do algebra on steroid.
12:36:12 <dsal> Oh yeah, I remember trying to balance text and aeson in a build.
12:36:40 <monochrom> When I build most of Haskell Platfom, basically text stands out as the main hog and only hog :)
12:37:11 <chessai> Welkin: could you gist an example of wht you are trying to do
12:38:04 <dsal> I guess I don't know much about text.  I'll accept it's worth it, though.  :)
12:38:14 <monochrom> Yes.
12:39:25 <monochrom> If you have a non-lazy sequence of Chars, [Char] is just going to take too much memory (and the ripple effect of putting stress on GC and cache therefore slowness too).
12:39:34 <Welkin> chessai: trying to now, but the paste sites are all broken
12:39:59 <Welkin> https://bpaste.net/show/1ceb3bff2a14
12:40:01 <dsal> I have a lay idea of text, I just don't know much about what it does.
12:40:01 <chessai> Welkin do you have a github?
12:40:19 --- mode: glguy set +v Boarders
12:40:35 --- mode: glguy set -v Boarders
12:40:51 <monochrom> Ah OK. Non-lazy Text is an array of 16-bit words, storing your string in UTF-16 format.
12:41:28 <Welkin> the `putStrLn "It works!"` only fires when I explicitly close the connection from the client, causing a ResourceVanished exception
12:41:43 <Welkin> but `finally` should work regardless of any exceptions
12:41:43 <dsal> Oh interesting.  It's fascinating how many tradeoffs one has to make to get human language into a program.
12:41:44 <Boarders> What is an efficient way to write to a file when what you are writing is potentially very large?
12:41:52 <monochrom> It is approximately 2 bytes per character.  But non-lazy [Char] is much worse, 24 bytes per.
12:42:02 <dsal> 24?
12:42:18 <koz_> 8 for constructor, 8 for pointer, 8 for char I think.
12:42:20 <chessai> Welkin: in the documentation for 'finally', it says 'computation to run _afterward_'
12:42:21 <cocreature> Boarders: how are you storing the data in memory?
12:42:36 <Welkin> chessai: yes, I understand that
12:42:39 <monochrom> Because "data L a = Nil | Cons a (L a)"  8 bytes for Cons, 8 bytes for pointer to a, 8 bytes for pointer to L a.
12:42:52 <chessai> Welkin: so it shouldn't execute until the first computation terminates
12:42:56 <Welkin> but it seems that the thread just dies without giving it a chance to run
12:43:13 <dsal> And then L a itself?
12:43:21 <Boarders> cocreature: as Haskell data structures, the current approach is they have Show instances and to use writeFile, but it seems the performance is terrible
12:43:38 <dsal> er, a itself.
12:43:43 <monochrom> Fortunately GHC RTS does keep around a flyweight table of commonly occuring Chars so I do not need to add the space actually used for the Chars themselves.
12:43:52 <dsal> Oh, i see.
12:44:26 <cocreature> Boarders: you probably want to go via Text or ByteString
12:44:33 <cocreature> Show is for debugging, not for performant IO
12:44:48 <monochrom> OK you want to look at the cons cell e.g. "Cons 'X' xs".  8 bytes for something that corresponds to the Cons tag, 8 bytes for pointer to an instance of 'X', 8 bytes for pointer to xs.
12:44:48 <Boarders> cocreature: Yeah, do you know if there are approaches with incremental rendering
12:44:58 <Boarders> or should that be covered by using lazy text / lazy bytestring?
12:45:01 <Welkin> use bytestring to write to file
12:45:04 --- mode: glguy set +v shiona_
12:45:13 <Welkin> stream it with pipes/conduit
12:45:49 <cocreature> Boarders: bytestring and text have builder interfaces
12:45:50 <shiona_> Is there a reason https://pastebin.com/mtqPv7Rn prints 1 and 2 right after each other?
12:45:54 <monochrom> Fortunately GHC RTS keeps a flyweight table for common Chars.  If you have "replicate 1000 'X'" it's 1000 cons cells all pointing to the same address that stores one 'X'.
12:46:17 <monochrom> But it's still 1000*24 bytes just for the list spine. >:)
12:46:22 <Boarders> cocreature: sorry could you elaborate what you mean by that?
12:46:28 <Welkin> I have written a 12 mb file using String before and it worked fine though
12:46:44 <monochrom> You can cut it down to 1000*12 bytes by simply installing 32-bit GHC >:)
12:46:58 <cocreature> Boarders: https://hackage.haskell.org/package/text-1.2.3.1/docs/Data-Text-Lazy-Builder.html
12:47:17 <Boarders> ah I see, thank you!
12:47:47 <shapr> 16-bit GHC is even better!
12:48:37 <monochrom> https://github.com/takenobu-hs/haskell-ghc-illustrated is a godsend.  (It also has a huge list of references in case you want to dig even deeper or more authentic.)
12:48:43 <lavalike> I want 3.12-bit GHC
12:48:49 <Welkin> chessai: chessai so why isn't `finally` working as desribed?
12:49:07 <chessai> Welkin: it is, because the first computation hasn't terminated
12:49:49 <chessai> Welkin: that's to my understanding - if you believe that the first computation has terminated, then tell me
12:50:06 <Welkin> it should have terminated because the client is no longer connected
12:50:09 <Welkin> the connection should have broken
12:50:29 <dsal> I've done the "If I compile this for 32 bit it'll use much less memory" hack a few times.  heh
12:51:48 <cocreature> shapr: because queueToList doesn’t stream. it only returns the resulting list once it gets Nothing
12:52:51 <Welkin> chessai: here is the streaming response code https://bpaste.net/show/bb89c8e4bb60
12:53:14 <Welkin> it's a streaming wai response with an infinite loop using `fix`
12:54:48 <cocreature> shiona_: see above (I accidentally mentioned shapr instead of you)
12:55:57 <shiona_> cocreature: I suspected something like that. but why does it not and is it just something wrong in how I've written it or does the IO somehow cause it to never stream or what?
12:56:55 <cocreature> shiona_: if you want to stream results in IO, you need some streaming lib like pipes or conduit
12:57:07 <shiona_> ok
12:57:16 <cocreature> (or lazy IO but it’s usually better to pretend that doesn’t exist :))
12:59:10 <shiona_> another solution would probably be that I never go to a list and just create new queues for each function composition, but there's probably at least a dozen libraries that do that in a sane manner
12:59:30 <monochrom> Yeah, things like mapM and replicateM used in IO are totally non-streaming.
13:00:15 <Solonarv> you want one of pipes/conduit/streaming, probably
13:00:33 <Solonarv> I'm not sure what the exact differences between them are
13:00:43 <Welkin> pipes has a cleaner interface and a great tutorial
13:00:48 <Welkin> I prefer pipes over conduit
13:01:13 <Welkin> they both have a lot of bindings to use them with all kinds of other libraries
13:03:11 <jle`> yeah, i usually just use whatever one works with the library i am currently using
13:03:34 <monochrom> What if there is a tie? >:)
13:04:10 <cocreature> then you invent yet another streaming lib
13:04:18 <monochrom> Haha
13:04:52 <chessai> Welkin:
13:05:07 <MarcelineVQ> streamly has a nice tutorial
13:05:23 <chessai> Are you sure the thread died? An exception could have been raised, but the thread may not have died yet. 
13:05:49 <chessai> Welkin: with the default linux settings, it takes a really long time before the OS tells your application that a socket is dead
13:05:58 <Welkin> chessai: it sends a 500 http response back to the client
13:08:31 <Welkin> oh wait
13:08:36 <Welkin> it actually is working
13:08:41 <shiona_> it seems I can get some understanding of pipes with its tutorial so I guess I'll give it a try
13:09:13 <Welkin> I must be letting the connection live in my javascript when I navigate elsewhere in my application
13:09:19 <Welkin> I think that is the problem
13:10:05 <Welkin> it takes maybe 15-20 seconds to respond though
13:11:27 <Welkin> but tell me what you think of this
13:11:48 <BartAdv> Hi! I'm in need of some type-level machinery, but I'm not sure what exactly. Basically, I need to be able to specify something like: Given a Proxy, and a value of the proxied type, how can I convince typechecker that they're the same? https://www.irccloud.com/pastebin/1ue1RvCv/
13:12:16 <Welkin> I am using exceptions to perform a normal operation in my application: marking users as "offline" when the resource vanishes
13:12:19 <Welkin> that seems wrong
13:12:29 <Welkin> I an use `finally` instead, but that also seems kind of bad
13:13:26 <Solonarv> BartAdv: this has nothing to do with proxies - it seems like the runtime type equality check is the issue
13:14:09 <noidedsuper> BartAdv: I think you want to pattern-match on `:~:` in a case statement.
13:14:15 <noidedsuper> See: http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Typeable.html
13:14:19 <BartAdv> yes, Proxy was one of my attempts at this. But it basically boils to the fact that GADT Await knows that if you Await a certain "type", then the result be of that type
13:14:30 <monochrom> Don't even bother with "typeOf x == typeOf y".  Just go directly to "cast" and get a Nothing or a Just.
13:15:21 <chessai> Welkin: yeah, 15-20 seconds sounds right
13:15:21 <BartAdv> cast require to have two typeables, I have a Proxy and Typeable
13:15:43 <monochrom> This is the same mindset as: you don't even bother with "if xs == null then foo else ... head xs ... tail xs ...".  Just do pattern matching.
13:16:07 <BartAdv> maybe I shouldn've used Proxy, just don't know how can I say: Await a value of some type, if the type matches, return that value
13:17:20 <chessai> BartAdv: a runtime check on the type? usually if you're receiving some value, e.g. from a network, you parse it to make sure it's well-formed
13:17:42 <Solonarv> I think you may have an incorrect impression of what Proxy does; could you explain what (you think) Proxy is?
13:18:13 <BartAdv> for me it was a way to have a value that defines a type
13:18:21 <pjrt> Isn't Proxy just a poor-man's version of TypeApplications?
13:18:28 <chessai> Welkin: i'm not sure there's a better way to do that other than something liek System.Timeout, which is potentially bad if the thing just takes a while to respond but is reachable. Or you can fiddle with system settings, but that affects everything else running on the host
13:18:30 <Solonarv> what does "a value that defines a type" mean?
13:18:33 <monochrom> Yes pjrt
13:18:49 <jle`> BartAdv: remember that Proxy doesn't actually contain any type information
13:19:47 <Welkin> chessai: this is for a presence system, and it seems like the most reliable way to handle this is to have the client send a close message before it disconnects normally, and have a ping/pong with a timeout on the server for network outages
13:20:35 <zachk> what if your client has a hard power failure?
13:20:41 <jle`> BartAdv: the proxy in your Activity isn't playing any active role, type system wise.  it only makes it a little more convenient to pattern match out the type variable using ScopedTypeVariables
13:20:42 <Welkin> one other thing that is bothering me is that I am sending a message to the TChan as soon as a user connects saying that userId is online, but that message never seems to get processed by any subscribers
13:21:02 <chessai> BartAdv: recall that the definition of Proxy is `data Proxy a = Proxy`. There's no value inside of the Proxy, the type `a` is just used to guide the type system
13:21:02 <jle`> BartAdv: if you want to check for type equality, add a Typeable constraint.  (Event e, Typeable e) => Proxy e -> Activity e
13:21:17 <Welkin> zachk: the timeout will handle that. If the server doesn't hear a ping from the client in the timeout interval, they are treated as disconnected
13:21:34 <zachk> Welkin, how does your client ping the server?
13:21:43 <Welkin> right now it doesn't
13:21:47 <Welkin> but a normal http request
13:22:05 <Welkin> currently only the server pings the client (with no pong)
13:22:10 <zachk> so every X seconds it does an http request to the server? 
13:22:22 <BartAdv> Solonarv: to me it meant something akin to a value of type Type one could have in dependently typed language, but I just recalled I might be doing something that would be invalid there too...
13:22:26 <zachk> oh the server is going to ping the client and the client is going to pong?
13:22:34 <Welkin> zachk: no, no pong
13:22:44 <Welkin> that's just to keep the persistent connection open though
13:23:00 <Solonarv> BartAdv: that is most certainly not what Proxy is! it doesn't contain any type information
13:23:02 <jle`> BartAdv: a value of type Type is actually not Proxy, but TypeRep
13:23:13 <BartAdv> jle`: but for checking type equality I would use `eqT`, right?
13:24:01 <jle`> BartAdv: yeah, if you use Data.Typeable
13:24:17 <BartAdv> but then, eqT works with constraints, it doesn't get any arguments
13:24:24 <jle`> exactly
13:24:35 <monochrom> BartAdv: It looks like "case cast payload of {Nothing -> Left ...; Just (a :: a) -> Right a" plus ScopedTypeVariables.
13:25:26 <monochrom> In fact "Just a -> Right a" suffices because you have a top-level type sig that forces a::a.
13:25:49 <jle`> BartAdv: note that if you were really looking for a value-level Type, you can use TypeRep instead of Proxy.  then you can directly use eqTypeable myTypeRep (typeOf e)
13:26:13 <monochrom> OK, this also means you need "Typeable a".  Guess what, without it, there is no other way.
13:26:16 <BartAdv> hm, what monochrom said just typechecked
13:26:31 <jle`> what a `Typeable a =>` constraint provides is essentially the same as `TypeRep a ->`
13:26:48 <BartAdv> I haven't even used Typeable constraint on a
13:26:59 <jle`> so you were probably trying to use Proxy to do something that is really filled by TypeRep
13:27:05 <Solonarv> 'Typeable a' reads as "please retain run-time type information about 'a'"
13:27:31 <jle`> so you can either (1) add Typeable e to your GADT constructor, or (2) use TypeRep a instead of Proxy a in your GADT constructor
13:28:17 <BartAdv> yeah, I added Typeable e to my GADT. Ok, sorry for slow replies, I just need to try if it works
13:31:08 <jle`> BartAdv: alternatively, you can do what Control.Exception does, and have Typeable e be a superclass of Typeable
13:31:19 <jle`> er, Typeable be a superclass of Event
13:33:07 <BartAdv> Ended up with this: https://www.irccloud.com/pastebin/njuNxEUx/
13:33:56 <jle`> BartAdv: here is both ways i mentioned https://paste.ofcode.org/4XqtcYueEYAK93jKrQ5CJb
13:34:19 <jle`> ah yeah, cast is probably better
13:34:26 <jle`> you actually odn't even need the (a :: a), you can just use a ->
13:34:28 <monochrom> It is possible that you can keep the "Proxy e" for the benefit of some other parts of your code.
13:34:55 <BartAdv> right, I can remove a :: a
13:35:09 <BartAdv> ok, thank you all guys, you've been super helpful :)
13:35:16 * hackage garfield 0.0.0.0 - TBA  http://hackage.haskell.org/package/garfield-0.0.0.0 (chessai)
13:35:35 <BartAdv> this channel is like, some crazy thing. You come asking question, and you don't just get help, you get tons of help :)
13:35:45 <jle`> right, GHC.TypeLits uses Proxy in its SomeNat/SomeSym type for convenience
13:37:37 <jle`> BartAdv: for a clean version of your function, you could also just do:
13:38:10 <jle`> interpret a@(Await _) = maybe (Left a) Right . cast
13:38:52 <monochrom> haha
13:38:55 <BartAdv> :)
13:39:12 <jle`> which sort of makes you think that interpret isn't too necessary
13:39:17 <jle`> and you could just use cast everywhere instead
13:40:03 <jle`> oh, but in practice you'r actually interpreting each constructor
13:40:52 <BartAdv> yes, in full code there gonna be some more
13:43:22 <ski> BartAdv : i suggest not making such a `Show' instance
13:43:49 <BartAdv> ah right, it was just for quick aid in REPL
13:45:10 <ski>   showsPrec p (Await awaited) = showParen (p > 10) $ showString "Await " . showsPrec 11 awaited
13:45:13 <ski> would be ok
13:45:25 <ski> BartAdv ^
13:46:36 <BartAdv> I'm one of the persons who never used showsPrec :)
13:46:54 <lavalike> it's a good function!
13:49:05 --- mode: glguy set +v madgen
13:52:18 <madgen> hi! is recursion-schemes being more efficient than implicit recursion no longer true?
13:52:41 <monochrom> What is implicit recursion?
13:53:03 <madgen> just vanilla recursion we always do
13:53:15 <monochrom> I thought we'd call that explicit.
13:53:45 <monochrom> Like if I swore at you you'd call that an expletive or would it be an impletive?
13:54:26 <koz_> monochrom: LOL
13:54:42 <madgen> monochrom: yes, you're right I confused myself never mind.
13:55:07 <cocreature> if anything, I would expect explicit recursion to be faster not the other way around
13:55:33 <koz_> cocreature: I think Edward said something to the effect of 'there's no real difference in Haskell between explicit recursion and schemes'.
13:55:41 <koz_> (but it was a while ago so I might be mis-remembering)
13:55:46 * hackage rollbar 1.1.2 - error tracking through rollbar.com  http://hackage.haskell.org/package/rollbar-1.1.2 (jetaggart)
13:55:53 <monochrom> False dichotomy.  Having fusion rewrite rules is faster than not having fusion rewrite rules.
13:55:57 <pjrt> I would think GHC makes it all a loop in the end
13:56:12 <pjrt> But I'm not that familiar with the internals
13:56:39 <cocreature> does recursion-schemes have rewrite rules?
13:56:47 <Solonarv> that's true assuming sufficient optimization passes and no rewrite rules
13:56:48 <madgen> I heard it a couple times and it is at the end of Milewski's blog post on F-Algebras quoting Gabriel Gonzales 
13:56:55 <madgen> though obviously the post is 5 years old
13:56:58 <cocreature> I don’t see any
13:58:44 <madgen> Also this Stack Overflow quesiton regarding recursion-scheme performance https://stackoverflow.com/questions/23664197/are-ana-catamorphisms-just-slower
13:59:58 <madgen> eventually resolves the problem and claims faster runtime by more than 4x in one instance
14:00:12 <madgen> though again that's 4 years old
14:03:29 <monochrom> I don't actually understand the bar chart.  For example does "25" means "25 operations per second" or is it "1 operation per 25 seconds"?
14:03:42 <Solonarv> Yes.
14:04:37 <Solonarv> jokes aside, it seems to be "1 operation per 25 units-of-time"
14:06:04 <madgen> I think it is just ms. At least in the new version of the library that generates that graph
14:06:18 <madgen> Criterion that is
14:07:50 <madgen> I benchmarked using Criterion as well and in my case every function I write is 2-3x is slower with recursion-schemes
14:09:59 <madgen> Here's the link to my code: https://github.com/madgen/pretty-print-precedence/blob/master/Main.hs
14:10:56 <madgen> Maybe you can tell me if I'm doing stupid. There is also the benchmarking results in "pretty-print-performance.html" in the repo
14:16:10 <o1lo01ol1o> madgen:  for all the foo = cata alg where alg = blah functions, try wrapping the application in the where clause and returning a single bound variable
14:16:17 <o1lo01ol1o> madgen: as in https://github.com/ekmett/recursion-schemes/blob/master/Data/Functor/Foldable.hs#L184
14:16:47 <o1lo01ol1o> It's just a guess but I read somewhere that ghc produces more efficient code thatway
14:18:50 <madgen> o1lo01ol1o: I think it was mentioned in https://blog.sumtypeofway.com/recursion-schemes-part-41-2-better-living-through-base-functors/
14:20:20 <o1lo01ol1o> yep, that's it
14:21:28 <madgen> o1lo01ol1o: though would that matter because the outer functions are only called once?
14:22:28 <o1lo01ol1o> Yeah, you're right, I miss read them when i glanced over the code
14:22:44 <madgen> o1lo01ol1o: also the point there is the recursive call is a single bound variable whereas the algebra does not have that recursive component
14:22:55 <madgen> o1lo01ol1o: thanks anyway!
14:24:38 <o1lo01ol1o> What flags you compiling with?
14:25:38 <madgen> o1lo01ol1o: -O3. In the unoptimised version explicit recursion is 2x faster in the optimised version 2-3x faster
14:25:46 * hackage katip 0.7.0.0 - A structured logging framework.  http://hackage.haskell.org/package/katip-0.7.0.0 (MichaelXavier)
14:25:58 <o1lo01ol1o> and with -fllvm?
14:26:09 <madgen> o1lo01ol1o: nope, would that help?
14:26:18 <o1lo01ol1o> I dunno
14:26:35 <o1lo01ol1o> in my experience it does with numerical and array code
14:26:56 * hackage katip-elasticsearch 0.5.1.1 - ElasticSearch scribe for the Katip logging framework.  http://hackage.haskell.org/package/katip-elasticsearch-0.5.1.1 (MichaelXavier)
14:27:07 <o1lo01ol1o> (also, -O2 is as high as it goes, -O3 is the same setting)
14:27:51 <madgen> o1lo01ol1o: I forgot my LLVM installation is currently out of order, so can't try, but it shouldn't help with optimising recursion I imagine
14:27:57 <madgen> o1lo01ol1o: thanks for the tip
14:30:31 <o1lo01ol1o> madgen:  i'm interested in why there's a slowdown, you could post on /r/haskell and someone will likely be able to give you some feedback
14:31:08 <madgen> o1lo01ol1o: good idea. I'll do that
14:43:30 * hackage fptest 0.2.3.0 - IEEE754r floating point conformance tests  http://hackage.haskell.org/package/fptest-0.2.3.0 (jrp)
14:43:49 <madgen> o1lo01ol1o: here's the link if you want to follow: https://www.reddit.com/r/haskell/comments/9xg585/are_recursionschemes_no_longer_faster_than/
14:43:58 <o1lo01ol1o> thx!
14:47:04 <o1lo01ol1o> madgen:  the body text of that says [removed]
14:49:00 <madgen> o1lo01ol1o: yes, and it makes me very confused. do posts to r/haskell require approval or something?
14:49:14 <o1lo01ol1o> yes
14:49:52 <madgen> o1lo01ol1o: alright, then I guess we're waiting for that
15:25:48 * hackage tasty-hspec 1.1.5.1 - Hspec support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-hspec-1.1.5.1 (mitchellwrosen)
16:53:34 <smutnysyn> difference between pure and non-pure lambda expression?
16:53:56 <mniip> we don't have the latter ones in haskell
16:58:03 <ion> An impure lambda expression would have side effects upon evaluation.
17:06:38 <koz_> What does CAF stand for?
17:08:01 <dexterfoo> how does GHC know that patterns are exhaustive in guards when I end it with "otherwise", but if I try with "myOtherwise" (which i defined as myOtherwise = True) then I get a non-exhaustive pattern warning? I looked at the source at "otherwise" is defined to be equal True, just like I have done with "myOtherwise"
17:09:53 <ski> Constant Applicative Form, iirc
17:17:33 <glguy> dexterfoo: Because `otherwise` is hardcoded into the checker
17:18:51 <ski> hm, is there an inline pragma on it ?
17:18:58 <glguy> https://github.com/ghc/ghc/blob/21f0f56164f50844c2150c62f950983b2376f8b6/compiler/deSugar/DsUtils.hs#L979-L981
17:24:41 <dexterfoo> glguy: interesting... what do people do when they use an alternate prelude?
17:25:08 <glguy> Ideally they don't; or they re-export otherwise from Prelude
17:25:37 <Welkin> there is nothing wrong with the prelude
17:26:40 <ion> Num is just perfect, for example.
17:27:33 <koz_> Ditto String. :P
17:27:40 <ion> head
17:29:13 <edwardk>  ion: exactly
17:29:16 * edwardk deadpans.
17:29:24 <koz_> Hi edwardk!
17:29:29 <ion> hedwardk
17:29:38 <edwardk> heya koz_ et al
17:31:03 <edwardk> does anybody know if the nominal renaming sets stuff was ever completed to the point of handling "nominal renaming unification" or if the gabbay paper on it is all there is?
17:40:49 <koz_> edwardk: What's this paper you're referring to?
17:41:26 <edwardk> http://gabbay.org.uk/papers/nomrs.pdf
17:41:40 * koz_ has a look.
17:41:45 <edwardk> and the earlier tech report: https://pdfs.semanticscholar.org/22a9/4ad31c682df706bb18da5e5da5d4e21b8038.pdf
17:41:56 <edwardk> it fits into the stuff i've been doing in github.com/ekmett/name
17:42:06 <edwardk> where i'm using 'nominal sets' rather than 'nominal renaming sets'
17:42:23 <edwardk> but once i got to where i start considering substitution, 'nominal renaming sets' is a more natural fit
17:42:28 <edwardk> and most of the machinery would switch over
17:42:41 <edwardk> otoh, nominal sets have 'nominal unification' and 'equivariant unification'
17:42:49 <edwardk> i'd like to know the equivalent for nominal renaming sets
17:43:46 <edwardk> aside from one quirk in the permutation of functions, everything basically transfers from the nominal sets code to the nominal renaming sets stuff
19:05:56 * hackage wizards 1.0.3 - High level, generic library for interrogative user interfaces  http://hackage.haskell.org/package/wizards-1.0.3 (LiamOConnorDavis)
19:59:47 * hackage wide-word 0.1.0.7 - Data types for large but fixed width signed and unsigned integers  http://hackage.haskell.org/package/wide-word-0.1.0.7 (ErikDeCastroLopo)
22:54:36 <shiona_> which files do I want to commit to git in a stack project? In other words which files are generated by the tools at compilation and should not be committed?
22:57:51 <koz_> shiona_: https://github.com/github/gitignore/blob/master/Haskell.gitignore
22:58:00 <koz_> This should be a pretty good guide to that.
22:58:05 <shiona_> koz_: thanks
22:59:04 <koz_> I really wish pizza was a functional data structure.
22:59:09 <shiona_> I guess I'm an idiot. it seems stack has created a gitignore file
22:59:11 <koz_> Eat a slice, still have old pizza.
22:59:33 <shiona_> eat-only datastructure
22:59:59 <shiona_> I could live with one
23:00:06 <shiona_> or preferably multiple
23:00:29 <koz_> uncons :: Pizza -> Maybe (Slice, Pizza)
23:01:17 <shiona_> I think that would need some more type magic to specify the Pizza was unchanged
23:02:15 <koz_> Well, that one assumes that Pizzas are like lists.
23:02:35 <koz_> Since uncons x may give you Nothing.
23:02:42 <koz_> But then again, can a Pizza be empty?
23:02:52 <koz_> So perhaps my signature is wrong.
23:04:01 <shiona_> uncons :: Pizza -> (Slice, Either Slice Pizza) ?
23:04:54 <koz_> Why not uncons :: Pizza -> (Slice, Maybe Pizza)?
23:04:54 <mniip> it stops being a pizza and starts being a slice once it's under 120 degrees
23:05:09 <koz_> mniip: You have some big slices.
23:05:16 * hackage pure-shuffle 0.1.1.1 -   http://hackage.haskell.org/package/pure-shuffle-0.1.1.1 (igrep)
23:06:19 <shiona_> but do we then need a class Sliceable so we can split slices that are too big. Or do we handle a complete pizza as a 360 degree slice
23:11:06 <mniip> I think you mean cosemigroup
23:13:22 <koz_> What kind of laws would Sliceable obey?
23:13:40 <koz_> Also, I get the feeling that a pizza sliced into slices is a Zipper.
23:18:45 <koz_> mniip: Is a cosemigroup an actual thing?
23:20:08 <mniip> I mean, in a monoidal category - why not
23:20:59 <koz_> So what, we have something like un<> :: s -> (s, s) ?
23:38:16 * hackage dynloader 0.1.0 - Dynamically runtime loading packages  http://hackage.haskell.org/package/dynloader-0.1.0 (taqenoqo)
23:50:53 <mniip> koz_, split :: s -> (s, s)
23:51:09 <mniip> such that  first split . split = alpha . second split . split
23:53:04 <koz_> mniip: What's 'alpha' here?
23:53:25 <mniip> ((a, b), c) ~~ (a, (b, c))
23:53:53 <mniip> well, the inverse of it, in this case
23:58:09 <koz_> Ah.
