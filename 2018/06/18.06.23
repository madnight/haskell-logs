00:01:14 <yasshek> what is haskell stack and haskell platform ?
00:01:38 <cocreature> yasshek: we have two main build tools in Haskell, cabal-install (the executable is called "cabal") and stack
00:01:50 <cocreature> some people prefer one, some the other :)
00:01:55 <cocreature> the haskell platform ships with both
00:02:12 <yasshek> cocreature:  I am beginner which one should I use
00:02:23 <yasshek> and which one is famous or helpful
00:02:33 <cocreature> depends on who you ask but currently, I tend to recommend stack to beginners
00:03:07 <cocreature> (whether you should use cabal or stack tends to result in somewhat heated discussions which is why I’m cautious to take a strong stance here)
00:03:53 <systemfault> As a beginner, cabal has given me so much trouble, it's not even funny.
00:04:05 <systemfault> Stack has been a painless experience.
00:04:27 <yasshek> I see
00:05:11 <yasshek> can we compare thse build tools to other language ?
00:05:15 <yasshek> like :
00:05:18 <sclv> As someone experienced, i have found the opposite
00:05:21 <taumuon> also as a beginner, you probably won't need a cli tool to get going.  you can use haskell's REPL called ghci.
00:05:39 <yasshek> I work only with cli
00:05:56 <taumuon> you'll be spending a lot of time in ghci tinkering about
00:06:09 <cocreature> even beginners tend to want to use libraries fairly soon ime and at that point you want to use stack or cabal
00:06:09 <sclv> yasshek: someone just wrote a good article on different build tools that maybe can be a starting point
00:06:10 <sclv> https://kowainik.github.io/posts/2018-06-21-haskell-build-tools.html
00:08:52 <cocreature> just pick one and stick to it for a while. I don’t think it’s useful to spend too much time trying to figure out which build tool works best for you as a beginner since that’s really something that only experience can tell you
00:09:19 <cocreature> once you’ve used it for a while you can try the other one and then see what you prefer
00:09:42 <cocreature> (or switch between both as I do)
00:09:53 <yasshek> Yup I will follow some tuturial cis194 and see what he says
00:10:04 <yasshek> https://github.com/bitemyapp/learnhaskell
00:14:44 <frakkin_toaster> hello?
00:15:12 <cocreature> hey frakkin_toaster
00:15:17 <frakkin_toaster> hi
00:15:32 <frakkin_toaster> what is this place?
00:16:21 <cocreature> it’s a channel about the Haskell programming language
00:16:36 <frakkin_toaster> ah,
00:16:52 <frakkin_toaster> can I be here if I don't know haskell?
00:17:11 <yasshek> frakkin_toaster:  no i guess
00:17:52 <frakkin_toaster> :(
00:18:05 <yasshek> I am learning haskell to stay here just started :D
00:19:21 <frakkin_toaster> putStrLn "Hello World"
00:19:28 <frakkin_toaster> does that count?
00:19:31 <cocreature> frakkin_toaster: ofc you can be here if you don’t know Haskell as long as you are interested in Haskell :)
00:19:40 <frakkin_toaster> cool.
00:19:51 <leifm> > putStrLn "Hello World"
00:19:53 <cocreature> this channel is mostly about helping people when they have Haskell questions, so it’s perfect for learning Haskell
00:19:54 <lambdabot>  <IO ()>
00:20:00 <zfnmxt> What's the name of the offtopic Haskell channel again?
00:20:21 <fishythefish> #haskell-offtopic?
00:20:24 <fishythefish> it's in channel topic
00:21:00 <fishythefish> there's also #haskell-blah
00:21:11 <zfnmxt> fishythefish: I figured it might be but then I couldn't figure out how to get weechat to actually print the full topic >.<
00:21:15 <zfnmxt> Thanks.
00:21:28 <cocreature> zfnmxt: you can scroll with f9 and f8
00:22:24 <taumuon> f9 f10*
00:22:37 <taumuon> sorry for the pedantry
00:22:41 <cocreature> oh right
00:22:45 <cocreature> off-by-one :)
00:24:22 <wz1000> cocreature: one Simon to rule them all? :P
00:24:48 <zfnmxt> Have you guys ever seen a language where if-then expressions never produce values, but if-then-else expressions do? (i.e. the if-then is only evaluated for its side-effects)
00:24:48 <cocreature> wz1000: yeah :)
00:25:11 <zfnmxt> The language I'm writing my compiler for has that specification. Seems so strange to me.
00:25:41 <leifm> what language is that?
00:26:04 <zfnmxt> leifm: http://www.cs.columbia.edu/~sedwards/classes/2002/w4115/tiger.pdf
00:26:10 <zfnmxt> Just a toy language
00:26:20 <jesyspa> zfnmxt: Well, it makes some sense: what value would you get in the else case?
00:26:35 <jesyspa> I mean, in the false case, if you have no else.
00:26:41 <zfnmxt> leifm: But I think that pdf actually doesn't specify what I just said, but the original textbook does.
00:26:50 <leifm> jesyspa: A maybe?
00:26:52 <fishythefish> zfnmxt: ocaml does this
00:26:53 <yasshek> I think people here know 10-20languages amazing
00:27:05 <fishythefish> well, if you fudge the distinction between () and no value
00:27:07 <yasshek> tiger language what a nowledge
00:27:12 <zfnmxt> jesyspa: Ah, of course.
00:27:14 <yasshek> no one even know that languge
00:27:47 <zfnmxt> fishythefish: I actually have been using () as my "no value"
00:27:52 <zfnmxt> I'm not sure if it's going to bite me later...
00:28:03 <jesyspa> leifm: It could, but many languages lack sum types and it does mean you're either making Maybe a builtin construction or adding a dependency from a language feature to a library type.
00:29:03 <yasshek> rust language easier than haskell language, I just see haskell very old compared to rust and rust developed by firefox
00:29:34 <fishythefish> jesyspa: to be fair, if/then/else already depends on Bool
00:30:14 <fishythefish> yasshek: older doesn't necessarily mean worse, and haskell was designed by plenty of smart people too ;)
00:30:23 <jesyspa> fishythefish: That is fair, but Bool is a builtin much more often than Maybe.
00:30:30 <fishythefish> "easier" is subjective, but you don't fight the borrow checker in haskell
00:30:43 <fishythefish> jesyspa: yes, absolutely
00:31:23 <fishythefish> although even languages without proper sum types may have optional types as language feature
00:32:01 <leifm> How do languages deal with functions that may fail without a maybe type?
00:32:16 <fishythefish> exceptions, straight-up crashing
00:32:50 <fishythefish> programmers may implement their own sentinel values
00:33:15 <jle`> zfnmxt: it seems like if/then and if/then/else are completely different things then
00:33:46 <jle`> they have different "types"
00:36:26 <fishythefish> i wouldn't say completely different, you can look at if/then as a restricted variant of if/then/else
00:36:30 <fishythefish> if cond then body == if cond then body else ()
00:39:47 <fishythefish> i suppose you could even make it syntactic sugar with ^ as the rewrite rule
00:40:51 <kuribas> It's kind of sad how haskell sucks for scientific computation.
00:41:10 <kuribas> It would be a great language for it, but the libraries are fragmented and incomplete.
00:52:09 <asheshambasta> whats the recommended way to upgrade stack LTS?
00:52:28 <asheshambasta> I changed to lts-11.14 and I seem to have entered Stack hell :-)
00:56:04 <Rembane> asheshambasta: What happened?
00:56:13 <Rembane> asheshambasta: What do you want it to do, and what does it do?
00:56:18 <c50a326> is there a haskell book that's nice and gentle like LYAH but also has exercises? LYAH doesn't have exercises :(
00:57:21 <asheshambasta> I'm seeing this: https://pastebin.com/nEcfMytd
00:57:39 <asheshambasta> doing what the error tells me to do doesn't solve the problem, and what does that error even mean?
00:58:11 <Rembane> c50a326: If you have some money to spare http://haskellbook.com/ is quite good.
00:58:29 <c50a326> c50a326: I'm allergic to money
00:58:58 <Rembane> asheshambasta: Interesting. Have you specified the version of esqueleto?
00:59:04 <Rembane> asheshambasta: ...in your cabal file?
01:00:40 <asheshambasta> Rembane: no -- I'm editing the package.yaml file in the project, not the cabal file. My package.yaml: https://pastebin.com/aZgcYEKV
01:01:59 <Rembane> asheshambasta: Good, specify a version range for esqueleto and see if you get a better error message.
01:04:33 <Rembane> c50a326: http://bitemyapp.com/posts/2014-12-31-functional-education.html
01:04:47 <hrk> Could someone please help me understand this weird behavior of Applicative instance of MaybeT []?
01:04:49 <hrk> https://gist.github.com/jhrcek/76212171f8625a3636ebc28a3b77a998
01:06:13 <asheshambasta> Rembane: `    esqueleto must match >=2.5.3, but the stack configuration has no specified version (latest matching version is 2.5.3)`
01:06:47 <asheshambasta> IMHO, that error message doesn't help. If the latest matching version is within my constraints, what is the problem exactly? :-)
01:16:28 <mreh> angerman, Hmm, seems like this script depends on your NDK being in "$HOME/Library/Android/sdk"  https://github.com/zw3rk/ghc-build-scripts/blob/master/build-libiconv, could I put in a flag for NDK location?
01:17:54 <angerman> mreh: sure! It's mostly my build scripts that I used on macOS.
01:18:34 <mreh> angerman, it could be the start of a nice open source framework for bootstrapping android apps in Haskell
01:18:45 <mreh> if that interests you
01:18:52 <mreh> it's not really easy right now
01:19:15 <angerman> mreh: I'm all for contributions!
01:20:17 <angerman> mreh: there is also https://github.com/mobilehaskell/user-guide, which is available from http://mobile-haskell-user-guide.readthedocs.io/en/latest/
01:22:49 <mreh> angerman, ah yes, thanks
01:31:55 <Rembane> asheshambasta: I have no idea. It's superweird. I hope that people with more stack-skillz show up. :)
01:33:45 <apoc> hi! when i do stack build it needs the exe directory/sources, is it possible to just download/build the dependencies of the .cabal file of the executable? I want to separate this so that i don't have to rebuild the deps when the executable changes
01:33:58 <Rembane> asheshambasta: I think I found out. I'm not sure yet, but I have a theory. esqueleto isn't on stack. Try to add it to your extra-deps.
01:34:25 <asheshambasta> Rembane: I've tried that
01:34:56 <asheshambasta> it just leads to more such proposed fixes until it asks me to add a specific version in extra-deps of a particular package, and then another version
01:35:09 <asheshambasta> after which I get an error about 2 differing versions of the same pacakge.
01:35:14 <asheshambasta> package*
01:35:49 <asheshambasta> `stack solver` warns me about a 'newer' version of cabal-install than the version it has been tested with -- but the version isn't newer per se, its just different
01:36:09 <asheshambasta> as per https://docs.haskellstack.org/en/stable/ChangeLog/#v171 I'm supposed to be using 2.2
01:36:17 <asheshambasta> but I'm using 2.0.0.1
01:37:05 <asheshambasta> … so, then I tried to upgrade cabal using the instructions at https://www.haskell.org/cabal/download.html but the `cabal install` command as suggested on this page doesn't work for me
01:37:51 <asheshambasta> basically, `cabal install cabal cabal-install` leads to a cryptic error message that is `trying: cabal-0.0.0.0 (user goal)
01:37:51 <asheshambasta> unknown package: youProbablyWantCapitalCabal (dependency of cabal-0.0.0.0)`
01:40:30 * hackage relational-query 0.11.4.0 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.11.4.0 (KeiHibino)
01:45:24 <asheshambasta> Rembane: funnily, `cabal install Cabal` does the trick
02:00:37 <Rembane> asheshambasta: That was interesting.
02:01:00 <Rembane> asheshambasta: The error messages gave absolutely no clue to that.
02:01:21 <asheshambasta> Rembane: yeah, and pretty painful
02:02:33 <asheshambasta> Rembane: I think its crazy the amount of time I've spent fighting Haskell's tooling.
02:03:14 <kuribas> mreh: do you know about eta language?  It allows you to create jvm android apps.
02:03:26 <mreh> kuribas, yeah, I did look into it
02:03:51 <mreh> kuribas, it's yet another ecosystem to learn :\
02:03:56 <Rembane> asheshambasta: Indeed. My experience so far is that it either works 100% smoothly or not at all.
02:03:58 <mreh> nix etc
02:04:26 <asheshambasta> Rembane: also, this warning from Stack is totally useless, I reckon adding more data there should be pretty simple; `Warning: Installed version of cabal-install (2.0.0.1) is newer than stack has been tested with.  If you run into difficulties, consider downgrading.`
02:04:49 <Rembane> asheshambasta: Indeed. If you want to make the world a better place, create an issue.
02:04:55 <asheshambasta> also /s/newer/different & /s/downgrading/correcting-the-version
02:05:02 <kuribas> Rembane: my solution to build problems was mostly to nuke .ghc and .cabal, and usually that solves it.  I also have less problems since I use the hvr ppa.
02:05:20 <Rembane> kuribas: Nice! What's hvr ppa?
02:05:39 <kuribas> Rembane: it's a ppa with all the ghc versions.  And cabal, happy, etc...
02:05:39 <Rembane> kuribas: I run Arch Linux, so everything wrt Haskell is painful. :)
02:05:46 <Rembane> kuribas: Nice!
02:05:58 <kuribas> Rembane: for debian like systems only I am afraid.
02:06:12 <kuribas> Rembane: yeah, it's a blessing :)
02:06:34 <kuribas> messing with local builds is painful.
02:06:51 <Rembane> kuribas: Yeah. Debian like systems are a bit less crazy than Arch, but in all other regards Arch works amazing for me, so I do all my Haskell work using stack and nix.
02:08:51 <pally> Okay, I want to know if someone can propose a clean way (if there's a function that will help, that's even better) to do the following:
02:11:47 <pally> [ ["student", "alan", "peter"], ["student", "ronald", "sally"], ["instructor", "bob", "michell"], ["instructor", "Jane", "May"]]
02:14:07 <pagnol> I created a new project by running `stack new`, added a package to extra-deps, and ran `stack solver` ... but the latter wants to delete the package I just added?
02:14:53 <pavonia> pally: Do what?
02:15:00 <pally> return the list containing lists, group by the first element of the list in each each of  input lists.
02:16:34 <pally> [ [ ["student", "alan", "peter"], ["studnet", "ronald", "sally"]], [["instructor", "bob", "michelle"], ["instructor", "Jane", "May"]]]
02:17:23 <pavonia> So the latter two strings of each list have to be kept together?
02:17:40 <kuribas> pally: sort?
02:17:41 <mreh> angerman, am I supposed to run this build of iconv through the toolchain wrapper? it seems like it's using my locally installed version of cpp
02:17:56 <kuribas> :t groupBy
02:17:57 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
02:18:14 <pally> kuribas, very nice.
02:18:21 <kuribas> :t groupBy (compare `on` head) . sort
02:18:22 <lambdabot> error:
02:18:22 <lambdabot>     • Couldn't match type ‘Ordering’ with ‘Bool’
02:18:23 <lambdabot>       Expected type: [a] -> [a] -> Bool
02:18:39 <pagnol> ah... I'm supposed to add it to the cabal file
02:18:39 <mreh> I'm so out of my depth haha
02:18:48 <pally> kuribas, not sure why I'd need sort tho
02:19:02 <kuribas> pally: is it already sorted?
02:19:28 <kuribas> :t groupBy ((==) `on` head)
02:19:30 <lambdabot> Eq a => [[a]] -> [[[a]]]
02:19:51 <kuribas> > groupBy ((==) `on` head) [ ["student", "alan", "peter"], ["student", "ronald", "sally"], ["instructor", "bob", "michell"], ["instructor", "Jane", "May"]]
02:19:53 <lambdabot>  [[["student","alan","peter"],["student","ronald","sally"]],[["instructor","b...
02:20:08 <pally> kuribas, does it have to be?  O_o
02:20:30 <kuribas> pally: groupBy only works on adjacent elements
02:24:53 <potong> @free fmap :: (a -> b) -> (F a -> F b)
02:24:53 <lambdabot> g . h = k . f => $map_F g . fmap h = fmap k . $map_F f
02:26:34 <kuribas> > map read . filter (all isDigit) . groupBy ((==) `on` isDigit) $ "123abc524def3145" :: [Int]
02:26:37 <lambdabot>  [123,524,3145]
02:27:14 <pally> kuribas, can we talk about your solution a lil bit more?
02:27:21 <pally> I know it works
02:27:27 <kuribas> pally: nope, it's finished.
02:27:31 <kuribas> Done.  Basta
02:27:37 <kuribas> pally: of course :)
02:27:56 <kuribas> pally: what do you want to know?
02:28:10 <asheshambasta> Rembane: I'll report this as an issue
02:28:10 <c50a326> can why is pattern matching called pattern matching
02:28:23 <c50a326> [a+b | (a,b) <- xs]
02:28:32 <pally> ` ((==) `on` head)`  is the first argument you passed to   `groupBy`
02:28:33 <c50a326> apparently this involves "pattern matching" ... does it though? :\
02:28:34 <asheshambasta> but I'll just live on an older LTS that worked -- I'm tired of this and I've spent far too much time getting things to work in Haskell
02:28:42 <asheshambasta> as compared to actually writing useful code
02:28:51 <pally> but if we look at the type signature:
02:28:55 <pally> :t groupBy
02:28:56 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
02:29:19 <asheshambasta> Rembane: basically, every instruction out there that I follow leads to more errors and then some more, and I end up staring down this rabbit hole from one issue to another.
02:29:43 <pally> the first paramter is a function that expects two arguments
02:29:48 <c50a326> asheshambasta: I heard the recommended way to install haskell is to use a nixos docker container
02:29:54 <kuribas> :t ((==) `on` head)
02:29:55 <lambdabot> Eq a => [a] -> [a] -> Bool
02:30:02 <potong>  > map (+1) [1..10]
02:30:42 <kuribas> pally: note that those a's are not the same
02:31:08 <pally> (==) is one, `on` is two, and head is three, no?
02:31:18 <potong> @type contramap
02:31:19 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
02:31:27 <kuribas> pally: think of that as Eq b => [b] -> [b] -> Bool, where [b] ~ a
02:32:07 <asheshambasta> c50a326: on a mac that would mean running a VM
02:32:26 <kuribas> pally: ((==) `on` head) is the same as (on (==) head).  It's the result of applying (==) and head to on.
02:33:55 <kuribas> pally: it's a function that transforms into another function.
02:34:28 <pally> this is one of the reasons why Haskell is so difficult.
02:34:43 <kuribas> :t \f -> f `on` head
02:34:44 <lambdabot> (b -> b -> c) -> [b] -> [b] -> c
02:34:50 <kuribas> pally: do you see what on does?
02:35:11 <kuribas> pally: in particular what (`on` head) does?
02:35:16 <potong>  @run map (+1) [1..10]
02:35:59 <kuribas> pally: it's easier formatted like this: (b -> b -> c) -> ([b] -> [b] -> c)
02:36:46 <c50a326> why is "pattern matching" called "pattern matching"
02:36:58 <c50a326> no "patterns" are being "matched" are they...
02:37:08 <Rembane> asheshambasta: Sweet! Then it really needs fixing.
02:37:11 <pally> it's a function that accepts two parameters and spits out a functions that accepts two wrapped arguments of type b
02:37:42 <kuribas> pally: [b] is a list of b
02:38:03 <kuribas> pally: so it will apply "head" to both arguments first, then use the original function (comparison).
02:39:03 <pally> kuribas, `on` is harder to locate since a search on Data.List documentation will highlight a lot of results
02:39:14 <kuribas> pally: it's in Data.Function
02:39:28 <kuribas> @hoogle on
02:39:29 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
02:39:29 <lambdabot> System.Glib.Signals on :: object -> Signal object callback -> callback -> IO (ConnectId object)
02:39:29 <lambdabot> Text.Regex.TDFA.Common on :: (t1 -> t1 -> t2) -> (t -> t1) -> t -> t -> t2
02:41:10 <kuribas> > (==) [1, 2] [1, 4] -- pally
02:41:12 <pally> (b -> b -> c) -> (a -> b) -> a -> a -> c is too much
02:41:12 <lambdabot>  False
02:41:20 <kuribas> > ((==) `on` head) [1, 2] [1, 4] -- pally
02:41:21 <lambdabot>  True
02:41:28 <kuribas> pally: see the difference?
02:42:18 <pally> from `(b -> b -> c) -> (a -> b) -> a -> a -> c` how do you read how many arguments `on` accepts?
02:42:39 <kuribas> pally: you don't
02:42:48 <pally> Oh Haskell.
02:43:19 <kuribas> pally: do you have an intuition what on does?
02:44:09 <pally> I am trying to find handle, but haskell got spikes on it at every spot,.
02:44:17 <pally> that's how I am feeling right now.
02:45:24 <kuribas> pally: forget the signature, just look at the example
02:45:33 <kuribas> pally: do you see what it did?
02:45:53 <kuribas> on is a quite complicated combinator
02:47:50 <malorie> I'm trying to write a simple regex, using regex-applicative, but my solution seems a bit tedious: https://lpaste.net/3178453116764815360 is there anything I could do better, or is this how regex-applicative is supposed to be used?
02:47:57 <kuribas> pally: (==) `on` head does compare the two values, it compares them after applying head to both arguments.
02:48:07 <pally> kuribas, I will, bear with me for 1 sec.  I want to pull up a useful documentation, record our discussion, re-read the log and tackle again.
02:48:15 <pagnol> so when I create a new project with stack I get three config files... what a putrid mess
02:50:13 <kuribas> pally: sorry I mean't doesn't compare the two values
02:50:39 <kuribas> pally: it compares the "head" of the two values
02:50:53 <kuribas> pally: in other words, it compares "on the head".
02:50:57 <Rembane> pagnol: https://xkcd.com/927/
02:51:12 <kuribas> pally: you can read it like english :)
02:52:03 <pally> kuribas, you know what's even tougher, I've looked for documentations on several authoritative sites, there's literaelly no english description for it.http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Function.html
02:52:10 <pally> zero
02:52:46 <kuribas> pally: file a bug :)
02:53:31 <kuribas> pally: anyway, I gave you a lengthly explanation
02:53:55 <c50a326> hey if I try to do a type definition for a function in ghci it moans. I'm trying: sum' :: (Num a) => [a] -> a
02:54:05 <c50a326> and it says Variable not in scope: sum' :: [a1] -> a1
02:54:30 <kuribas> pally: just forget about the type signature of on
02:55:33 <pally> kuribas, okay.  I will now re-read the log.  I am sorry for the delay and have wasted your time.  I thought it'd make sense have something doc opened for easy reference.
02:55:36 <malorie> c50a326: let sum' :: Num a => [a] -> a ; sum' = sum
02:55:53 <kuribas> pally: you still haven't answered my question about the examples
02:56:01 <c50a326> The type signature for ‘sum'’ lacks an accompanying binding
02:56:24 <c50a326> oh if I do ; and then the function definition on the same line it works
02:56:35 <kuribas> pally:  <kuribas> pally: see the difference?
02:56:46 * pally looking
02:57:06 <c50a326> :sum' :: (Num a) => [a] -> a; sum' [] = 0; sum' (x:xs) = x + sum' xs; sum' [5, 4, 3]
02:57:26 <c50a326> This works but if I leave out the type definition bit at the beginning it says:  Non-exhaustive patterns in function sum'
02:57:59 <pally> kuribas, yes I do.
02:58:20 <kuribas> pally: so you see what it does?
03:00:41 <pally> ues
03:00:42 <pally> yes
03:01:15 <pally> just like you said. "it compares on-the-head"
03:01:47 <kuribas> pally: there isn't more to it.
03:02:13 <kuribas> now have a beer :)
03:03:45 <c50a326> if I declare the function type of sum' as     sum' :: (Num a) => [a] -> a     then that's the function type, but if I don't explicitly declare the function type then the type is     sum' :: Num a => [a] -> a
03:04:01 <c50a326> and apparently this difference causes an error: Non-exhaustive patterns in function sum'
03:04:14 <c50a326> the only difference is Num a being in the ()s
03:04:21 <c50a326> So what difference does that make?
03:05:13 <pally> kuribas, let's review what you said earlier:
03:05:23 <pally> <kuribas> pally: ((==) `on` head) is the same as (on (==) head).  It's the result of applying (==) and head to on.
03:05:43 <kuribas> yes
03:05:51 <kuribas> `f` is infix syntax
03:06:00 <c50a326> it sounds like you guys are beating a dead horse
03:06:13 <pally> let's look at the standard prefix notation
03:06:22 <pally> (on (==) head)
03:06:33 <pally> since evaluation is from left to right
03:07:01 <kuribas> c50a326: that's exactly the same.  The error will be elsewhere.
03:07:03 <pally> should it instead be "the result of apllying `on` to `(==)`
03:07:58 <asheshambasta> if I have a package in my extra-deps (stack) I'm supposed to find it during imports right?
03:08:03 <c50a326> wtf
03:08:14 <c50a326> I just tried it again and now it works without the type signature declaration thing
03:08:23 <c50a326> I must have mistyped something
03:09:15 <c50a326> oh wait no I put sum instead of sum', I didn't mistype something until now so the problem is still real. Hang on I'll paste something.
03:10:01 <kuribas> pally: so if we unify the variables we get:  "head :: [a] -> a", "(==) :: Eq a => a -> a -> Bool", and on :: (a -> a -> Bool) -> ([a] -> a) -> ([a] -> [a] -> Bool)"
03:10:16 <asheshambasta> having ```extra-deps:
03:10:16 <asheshambasta> - monad-log-0.1.1.0
03:10:16 <asheshambasta> - aeson-0.11.3.0
03:10:16 <asheshambasta> - esqueleto-2.5.3``` but Database.Esqueleto in imports not found
03:10:23 <kuribas> pally: see how everything fits?
03:10:23 <asheshambasta> this is giving me a headache
03:10:32 <pally> asheshambasta, you are not alone.
03:11:45 <c50a326> here https://lpaste.net/6313430216622473216
03:12:21 <kuribas> c50a326: that's because you are redifining sum', not making new clauses.
03:12:29 <c50a326> ohhhh...
03:12:53 <kuribas> asheshambasta: sorry, I don't use stack...
03:13:27 <kuribas> asheshambasta: if we can meet in Brussel, I can have a look at it...
03:13:36 <c50a326> with stack runghc it works with linebreaks
03:13:52 <c50a326> maybe I should stop using ghci
03:14:31 <kuribas> c50a326: in new ghci's you can do multiple lines
03:14:42 <c50a326> kuribas: with \ or something?
03:14:51 <kuribas> c50a326: or separate with ;
03:15:07 <c50a326> yeah I already used ; in the paste so I know that lol
03:15:37 <kuribas> c50a326: :{ multiline code :}
03:15:52 <c50a326> oh, juicy
03:16:50 <taumuon> there's also the :set +m command
03:17:47 <asheshambasta> kuribas: I'll let you know about next week, thanks!
03:17:59 <asheshambasta> we should catch up indeed.
03:19:13 <c50a326> asheshambasta: apparently you can use nix on mac
03:19:41 <c50a326> without a VM... I was just being facetious about a nix docker container tho :p
03:25:58 <asheshambasta> c50a326: gives me shivers to even think of using yet another tool for Haskell after I've finally gotten HIE to play nicely with emacs
03:26:54 <asheshambasta> Rembane: after further analysis of this, it looks like the versions of persistent are just too new for Esqueleto (a library I've also been using in the project)
03:27:10 <Rembane> asheshambasta: Oh. So a bit of dependency hell too?
03:28:20 <asheshambasta> Rembane: yeah, thats what it looks like. Apparently, Spock uses Conduit (guessing) but a newer version as per the Spock version on LTS-11.14
03:28:39 <asheshambasta> and so does Persistent, so downgrading persistent will also need downgrading Conduit
03:29:04 <asheshambasta> and that won't play nice -- so this is a dependency stalemate as I'd term it
03:29:17 <Rembane> asheshambasta: Dang. It just can't end well.
03:29:19 <pally> > ((==) `on` head) [1, 2] [1, 4]
03:29:21 <lambdabot>  True
03:29:53 <pally> > ((==) `on` head) [1, 2] [1, 4] [1,5]
03:29:56 <lambdabot>  error:
03:29:56 <lambdabot>      • Couldn't match expected type ‘[Integer] -> t’
03:29:56 <lambdabot>                    with actual type ‘Bool’
03:29:58 <asheshambasta> Rembane: the only way out of this (from what it seems) is to move away from Esqueleto and use something else for nicer db queries with joins and stuff.
03:30:34 <pagnol> is anyone here using json-ld from haskell?
03:32:14 <kuribas> > let l = [[1, 2], [1, 4], [1,5]] in all (((==) `on` head) (head l)) l
03:32:16 <lambdabot>  True
03:32:23 <kuribas> pally ^^
03:38:47 <pally> > groupBy ((==) `on` head) [ ["student", "1"], ["student", "2"], ["instructor", "3], ["student", "4"], ["instructor", "5"]]
03:38:50 <lambdabot>  <hint>:1:122: error:
03:38:50 <lambdabot>      lexical error in string/character literal at end of input
03:39:11 <pally> > groupBy ((==) `on` head) [ ["student", "1"], ["student", "2"], ["instructor", "3"], ["student", "4"], ["instructor", "5"]]
03:39:13 <lambdabot>  [[["student","1"],["student","2"]],[["instructor","3"]],[["student","4"]],[[...
03:39:40 <pally> kuribas, I see what you mean when you said they need to be sorted now
04:00:57 <fendor> is it possible that i can not obtain profiling information when the program has been terminated with `exitWith ExitSuccess`?
04:15:50 <encodes> another error; https://lpaste.net/4873430800143482880
04:27:54 <c50a326> is a list comprehension an expression?
04:28:02 <c50a326> it is isn't it?
04:28:38 <pavonia> Yes
04:28:46 <iron_houzi> What's a good way to build unicode strings in haskell? My natural way of doing this would be to assign numeric values for each character in an alphabet and join to strings: k = 0x040; n = 0x053; [k, n] :: String ---> error: No instance for (Num Char) arising from a use of ‘k’
04:29:04 <c50a326> what about the `x <- xs` bit that is inside a list comprehension? is that an expression? it's not is it?
04:29:08 <c50a326> is it just "sugar" ?
04:29:22 <iron_houzi> oh wait, maybe I have to map the numbers with chr
04:29:27 <pavonia> It's syntax
04:29:27 <c50a326> is it bad to use list comprehensions as a beginner because they're just "sugar" ?
04:29:46 <pavonia> No
04:29:49 <c50a326> pavonia: but it's not a command using a monad is it?
04:29:56 <c50a326> even though it has the <-
04:30:57 <pavonia> They are for lists only, not arbitrary monads (if this is what you're asking)
04:31:00 <iron_houzi> .. no not ASCII, so to/fromEnum
04:31:29 <pavonia> iron_houzi: ord/chr work for all Unicode characters
04:31:57 <c50a326> pavonia: so it's a list monad?
04:32:21 <pavonia> [a] has a Monad instance, yes
04:33:22 <pavonia> iron_houzi: What is your aim? Perhaps String isn't the proper data type for your need
04:34:59 <jbetz> From an old reddit thread about why haskell doesn't have row polymorphism: "There is no consensus that row polymorphism is the best way to implement records and variants." What exactly are the alternative implementations?
04:37:45 <encodes> c50a326: more importantly it implements; class DifferenceT f where differenceT :: Applicative g => (a -> g b) -> (f a -> (g (f b -> f b),f a)).
04:37:53 <iron_houzi> pavonia: Thanks, I figured it out now. I want to convert Tibetan text written in latin script to native Tibetan unicode script. Tibetan script is written both horizontal and vertical, so at some point I need to determine axis and shift accordingly, which is why I want to represent each letter as an int, so I can +50 for vertical shift before converting to unicode character
04:53:06 <encodes> Either the error is something to do with line 20, or the approach is fundamentally flawed.. something to do with Lift2 having too many arguments perhaps? https://lpaste.net/4873430800143482880
04:55:59 <nowhereman_> how come the result of forever can be unified with any monadic type?
04:57:01 <nowhereman_> like (forever $ getLine :: IO Int)
04:57:37 <phadej> :t forever
04:57:38 <lambdabot> Applicative f => f a -> f b
05:02:09 <asheshambasta> So; I upgraded my Stack LTS to 11.14 in a project that uses Persistent and Esqueleto. Esqueleto, for some reason, isn't available on this resolver (probably due to compat. issues with the Persistent version on this resolver) so I added it to my extra-deps in stack.yaml. Now, the Persistent version on this resolver is 2.8.2 but persistent, as required by Esqueleto, must match < 2.8. So this is a bit of a soup. What
05:02:10 <asheshambasta> to go about this? Downgrading the resolver?
05:02:26 <maerwald> use cabal xD
05:03:19 <asheshambasta> maerwald: how likely is that to solve this problem? :-)
05:03:26 <kuribas> iron_houzi: string is already unicode
05:03:31 <maerwald> you don't have to deal with stack then
05:03:50 <asheshambasta> maerwald: I've heard scary things about Cabal too
05:03:55 <maerwald> I haven't
05:04:49 <iron_houzi> kuribas: Thank you, I know.
05:05:43 <kuribas> iron_houzi: are you looking for chr or ord?
05:06:08 <kuribas> :t chr
05:06:09 <lambdabot> Int -> Char
05:06:31 <kuribas> :t ord
05:06:33 <lambdabot> Char -> Int
05:06:37 <iron_houzi> kuribas: I was looking for chr, it didn't seem to be working i ghci, but I just had to import it with correct namespacing
05:06:53 <int-e> > toEnum 48 :: Char
05:06:55 <lambdabot>  '0'
05:07:16 <iron_houzi> > chr 0x040
05:07:18 <lambdabot>  '@'
05:07:31 <kuribas> oh, pavonia already mentioned it...
05:07:39 <iron_houzi> > chr 0x0f40
05:07:41 <lambdabot>  '\3904'
05:07:56 <iron_houzi> > putStrlLn chr 0x0f40
05:07:58 <lambdabot>  error:
05:07:58 <lambdabot>      • Variable not in scope: putStrlLn :: (Int -> Char) -> Integer -> t
05:07:58 <lambdabot>      • Perhaps you meant one of these:
05:09:01 <gonz_> maerwald: If you've never heard scary things about cabal you either have never paid attention or you are new.
05:09:03 <iron_houzi> > putStrLn $ map chr [0x0f40]
05:09:05 <lambdabot>  <IO ()>
05:09:15 <maerwald> gonz_: I'm neither
05:09:40 <iron_houzi> the bot doesn't to IO??
05:09:45 <iron_houzi> *do
05:10:23 <mbwgh> Is there a portable and performant way to traverse directories only? Currently, I Conduit's `sourceDirectory`, and `filterMC (liftIO . doesDirectoryExist)`, but this is dog slow. There are things like the unix package of course. But is it possible to get something more efficient than "get everything and then filter by file type"?
05:10:37 <maerwald> I feel it's mostly people who don't know much about cabal who keep saying it's scary
05:10:54 <maerwald> which is a result of advertisement imo
05:11:51 <int-e> :t text
05:11:53 <lambdabot> String -> Doc
05:12:16 <int-e> > text [chr 0x0f40]
05:12:18 <lambdabot>  ཀ
05:13:30 * hackage cdeps 0.1.1.3 - Extract dependencies from C code.  http://hackage.haskell.org/package/cdeps-0.1.1.3 (vmchale)
05:15:36 <int-e> iron_houzi: Anyway, using the type system as a mechanism for preventing IO is one of the main ideas behind lambdabot. The bot might not exist without this idea.
05:16:36 <iron_houzi> int-e: Wow! What does the type Doc represent? Is it only used by the lambdabot, or is this a common type in haskell?
05:16:50 <maerwald> gonz_: you can also check out https://www.haskell.org/cabal/users-guide/nix-local-build-overview.html and https://www.stackage.org/lts-11.14/cabal.config
05:16:59 <int-e> % print 123 -- yahb has a different philosophy
05:17:00 <yahb> int-e: 123
05:17:35 <int-e> iron_houzi: http://hackage.haskell.org/package/pretty-1.1.3.6/docs/Text-PrettyPrint.html
05:21:56 <iron_houzi> int-e: This is very interesting. Not sure I can use it entirely, as I am using a language where these rules would not fully apply, but it's hard to be 100% sure due to the sparse information on the page you linked to
05:22:52 <iron_houzi> Very inspirational to say the least
05:23:54 <iron_houzi> > text $ map chr [0x0f40, 0x0f53]
05:23:56 <lambdabot>  ཀན
05:24:02 <iron_houzi> Nice
05:27:12 <int-e> > (show (show "äöü"), show (text "äöü")) -- what lambdabot uses for output is the result of "show" applied to the given value
05:27:14 <lambdabot>  ("\"\\\"\\\\228\\\\246\\\\252\\\"\"","\228\246\252")
05:27:22 <int-e> uhm
05:27:36 <int-e> > (show "äöü", show (text "äöü")) -- that was one 'show' too many
05:27:38 <lambdabot>  ("\"\\228\\246\\252\"","\228\246\252")
05:27:59 <int-e> > fix show
05:28:01 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
05:35:12 <encodes> there was a mistake before, this gives an error which it might be easier to help with; https://lpaste.net/972356191810224128
05:43:48 <infinisil> fix show is magical..
05:45:43 <infinisil> > elemIndices '"' $ fix show
05:45:49 <lambdabot>  mueval-core: Time limit exceeded
05:46:18 <infinisil> > take 15 . elemIndices '"' $ fix show
05:46:20 <lambdabot>  [0,2,6,14,30,62,126,254,510,1022,2046,4094,8190,16382,32766]
05:51:27 <Ariakenom> > (\xs -> zipWith (-) (tail xs) xs) $ take 15 . elemIndices '"' $ fix show
05:51:29 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384]
05:52:08 <int-e> > [2^i - 2 | i <- [1..]]
05:52:10 <lambdabot>  [0,2,6,14,30,62,126,254,510,1022,2046,4094,8190,16382,32766,65534,131070,262...
05:55:28 <rzmt> i have a list of urls and i want to make exactly 30 HTTP requests for those in a minute, how would i throttle the requests using conduit?
06:07:02 <mbwgh> rzmt: https://hackage.haskell.org/package/conduit-throttle ?
06:13:41 <rzmt> thanks, ill check this soon
06:22:01 <encodes> is it because reflect expects 's' as the last argument to Lift2 but Functor expects 'a'?
06:22:38 <ij> is it possible to run hspec in ghci?
06:23:29 <reanimator> hey, I am having trouble with do notation..I have this piece of code
06:23:31 <reanimator> https://gist.github.com/rastko1996/f4a136f20ee0b7ade8f43d85acf556fb
06:23:52 <reanimator> tried writing it in two different ways, nothing works, parse error either on return or let
06:25:37 <encodes> so that a Functor over type 'a' (x :: (Functor (f s) => (f s) a)) is not a proxy over type 's' as required to call 'reflect x'. how then can a proxy for 's' be obtained from 'x'?
06:27:26 <encodes> with reference to; https://lpaste.net/972356191810224128
06:39:25 <c50a326> hey this is my first attempt at a sorting algorithm and it's giving me a headache, I don't think this approach is even viable. In any case, I'd like to understand the error: https://lpaste.net/31288866816131072
06:39:48 <c50a326> cannot construct the infinite type: a ~ [a]
06:40:01 <c50a326> what's the tilda in the error dialogue for?
06:45:24 <encodes> > [1,2]:[3]
06:45:26 <lambdabot>  error:
06:45:26 <lambdabot>      • No instance for (Num [Integer]) arising from a use of ‘e_1123’
06:45:26 <lambdabot>      • In the expression: e_1123
06:45:56 <encodes> > [1,2]++[3]
06:45:58 <lambdabot>  [1,2,3]
06:46:30 <encodes> > :t ((:),(++))
06:46:32 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
06:46:40 <encodes> :t ((:),(++))
06:46:41 <lambdabot> (a1 -> [a1] -> [a1], [a2] -> [a2] -> [a2])
06:47:43 <encodes> the ~ is trying to say that the types are equal
06:48:07 <encodes> https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/equality-constraints.html
06:48:09 <c50a326> oh yeah ++ sorry
06:49:15 <fendor> when should i prefer TQueue over TChan?
06:59:00 * hackage tasty 1.1.0.2 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-1.1.0.2 (RomanCheplyaka)
06:59:16 <c50a326> okay what about this one? https://lpaste.net/6707562172622307328
06:59:55 <c50a326> it wants me to do a type declaration, why?
07:00:40 <c50a326> I guess it could be anything that could go in a list, what type is that? Fold or Ord or something?
07:01:43 <c50a326> take' :: Int -> Fold -> Fold    isn't right lol
07:02:13 <c50a326> I guess I can look at :t take
07:02:15 <blackandblue> can you do AI with haskell or python better?
07:02:47 <c50a326> oh that works
07:05:19 <maerwald> python might have more libraries
07:06:33 <c50a326> ah I did it!
07:08:35 <encodes> ok, this works. https://lpaste.net/2492316960059031552
07:08:52 <encodes> is it in a library somewhere already?
07:09:23 <c50a326> this works too https://lpaste.net/3733163579155677184 I managed to write some haskell to do something that I wanted it to do, woot
07:09:54 <nkaretnikov> how do i implement short-circuiting for something like this? `for [1..10] \x -> for [1..10] \y -> if (x,y) == (5,5) then (act :: IO a) else return ()` where `for` is something like `forM`. the problem here is that the expression returns different types depending on the result of `if`. i was thinking about using `foldl` similar to `let xs = foldl1 (\x y -> traceShow y $ if y == 5 then 42 else x) [1..10]` which goes from 10
07:09:54 <nkaretnikov> to 5 and then prints 42. but i can't figure out how to apply this to my problem. any ideas?
07:10:53 <lyxia> nkaretnikov: do you mean to replace return by something that shortcircuits
07:11:29 <nkaretnikov> to stop evaluating lists as soon as the condition holds
07:11:47 <nkaretnikov> i guess i could rely on laziness here too
07:12:05 <nkaretnikov> and just add another pass later looking for a marker in the list or something
07:13:04 <nkaretnikov> so just do something like foldl1 ... $ for ... $ for
07:13:24 <lyxia> there are ways to add a short-circuiting feature to a monad with ExceptT or ContT
07:14:59 <nkaretnikov> any examples?
07:15:14 <nkaretnikov> i used both a long time ago
07:15:37 <the_2nd> Is it possible to read two multi-line string from stdin? I tried calling getContents twice, but that seems to create some sort of endless loop / error state
07:16:53 <mniip> the_2nd, how would you find where the first string ends
07:17:39 <apoc> i have a Data.Text (i think) but putStrLn can't print it, Couldn't match type ‘Text’ with ‘[Char]’, how can i print it?
07:17:55 <the_2nd> unsure :D Maybe two "getline" where "\n" has to be used for multi line might work
07:18:24 <Boreeas> `/log
07:27:46 <p0lyph3m>   nkaretnikov : https://lpaste.net/8514759117993148416
07:28:35 <p0lyph3m> use list monad + guard to filter the cases when to act , then map over them
07:31:44 <apoc> Text.unpack was what I was looking for ;)
07:31:57 <apoc> is there no etcdv3 client library for haskell yet?
07:33:36 <p0lyph3m> > mapM_ print [(x,y) | x <- [1..10],y <- [1..10] , x == y ]
07:33:39 <lambdabot>  <IO ()>
07:37:28 <p0lyph3m> nkaretnikov: to short circuit just take 1 element
07:38:30 <p0lyph3m> mapM_ print $ take 1 [(x,y) | x <- [1..10] , y <- [1..10] , x == y ]
07:39:59 <gonz_> johnw: Do you have a write-up or something about your machinery to cache (parts of) hackage on a home server and use that to pull to your dev machine?
07:40:29 <gonz_> I'm curious about the server bit. I'm running `nix-serve` right now, but I'm not sure exactly how automated the bit that pulls certain packages can be.
07:42:58 <gonz_> A cron job that basically just updates the channel and installs a list of packages should work, but people also have a tendency to make nicer stuff for things like this.
07:51:59 * hackage script-monad 0.0.1 - Transformer stack of error, reader, writer, state, and prompt monads  http://hackage.haskell.org/package/script-monad-0.0.1 (nbloomf)
07:52:29 * hackage ats-pkg 2.11.0.1 - A build tool for ATS  http://hackage.haskell.org/package/ats-pkg-2.11.0.1 (vmchale)
08:46:37 <manek> Hi guys! Let's consider I've got a data type `data T = A | B` and `class Foo (t :: T) where foo :: Int -> Int` and `type family X (a :: Type) :: T`. When I use it as follow `myVar = foo @(X a) 5` I got constraint `Foo (X a)`, which is clear, however is it possible to somehow hide this constraint and tell GHC
08:46:53 <manek> that I've implemented all possible instances, namely `Foo 'A` and `Foo 'B` ?
08:47:58 <manek> because these are the only instances that could be matched, I've provided them, so could we somehow tell GHC that as soon as it knows what `X a` is, the constraint `Foo` will be met and we dont need to provide it in the context?
08:48:57 <mniip> no
08:49:06 <mniip> the haskell typesystem is constructive
08:50:10 <mniip> much like having two terms of types P A and P B wouldn't let you write a term of type forall a. P a
09:03:54 <glguy> manek: Keep in mind that the types get erased at compile time, and it's not enough to know that there must be an instance, you have to know *which* instance is needed at runtime
09:04:18 --- mode: glguy set -o glguy
09:19:05 <encodes> are "with" or "using" part of any library?
09:19:42 <cocreature> :t Foreign.Marshal.Utils.with
09:19:44 <lambdabot> Foreign.Storable.Storable a => a -> (GHC.Ptr.Ptr a -> IO b) -> IO b
09:20:04 <cocreature> "using" exists in various libs but not in base afaik
09:22:10 <encodes> is that the same as the version here; https://lpaste.net/6834688991220989952 ?
09:22:22 <cocreature> no? it has a completely different type?
09:22:30 <rotaerk> cocreature, what I was trying to do with Scope is achievable with resourcet (i.e. avoiding explicit releases), so I'm dropping it
09:22:43 <rotaerk> can just do nested runResourceT >_>
09:23:00 <cocreature> rotaerk: oh yeah I guess that works
09:23:42 <encodes> so is *that* version part of some library?
09:23:56 <encodes> possibly under a different name...
09:29:54 <domenkozar> could someone help me explain this: https://gist.github.com/domenkozar/30e4a02028bc00cfae95f78953bed8b1
09:30:10 <domenkozar> I'd expect GHC not to emit a warning
09:30:26 <malorie> I'm trying to write a simple regex, using regex-applicative, but my solution seems a bit tedious: https://lpaste.net/3178453116764815360 is there anything I could do better, or is this how regex-applicative is supposed to be used?
09:34:35 <monochrom> domenkozar: The compiler does not yet know that "a" and "not a" cover all cases.
09:35:23 <domenkozar> it says it's missing False
09:35:28 <domenkozar> so it doesn't know about "not a"
09:37:05 <monochrom> I bet you it doesn't know about "a" either.  There is a way to make it say "missing Foo True"
09:41:03 <monochrom> Hrm, I can't make it say "missing Foo True".
09:43:08 <glguy> domenkozar: Your choices are either to guard on: a, otherwise; or to case a of True -> ...; False -> ...; or if a then ... else ...
09:43:46 <glguy> I think GHC has special knowledge that otherwise from base is defined as True which allows it to know the pattern is complete if that's the last guard
09:44:14 <monochrom> I guess it knows about "a" but not "not a".
09:45:07 <domenkozar> glguy: that's pretty limited :)
09:46:15 <glguy> :)
09:49:23 <c50a326> how is this not a merge sort https://lpaste.net/8053164770645245952
09:50:05 <mniip> it's a quicksort
09:50:10 <monochrom> So much for "meaningful" function names, eh?
09:50:19 <c50a326> what's the difference
09:50:25 <c50a326> it divides and conquers and sorts
09:50:44 <monochrom> But merge sort does not simply need ++ for the merge stage.
09:51:01 <monochrom> Both quicksort and mergesort are divide and conquer.
09:51:04 <mniip> so you don't know the difference between a quicksort and a mergesort?
09:51:28 <monochrom> Please don't speak like "what's the difference between the empty string and the empty set? both are empty"
09:52:01 <c50a326> no I don't
09:53:03 <mniip> well the quicksort first splits an array into two subarrays that definitely come one before another in the sorted array, and then recursively sorts each
09:53:24 <mniip> (then you can concatenate the sorted results)
09:53:33 <monochrom> There are multitudes of mergesort presentations on the web so you can take a look.
09:53:47 <mniip> mergesort on the other hand splits arbitrarily, then recursively invokes sorting and then does a merge of two sorted arrays
09:54:14 <monochrom> But if you just work at the coarse level of "oh so it's just divide and conquer" and not look at the particulars, you will never improve.
09:54:40 <monochrom> At which point insertion sort is divide and conquer, too.
09:54:44 <supitto> Another think to keep in mind is that quick sort is not açwa
09:54:56 <supitto> *always n log
09:55:05 <mniip> supitto, it can be made to be
09:56:20 <supitto> you may use the pivot in a intelligent way so it get pretty difficult to fall on a n^2 case
09:56:41 <supitto> but I never saw a failproof approach
09:56:54 <monochrom> There is a linear-time algorithm for finding the median.
09:57:19 <supitto> That makes sense
09:57:42 <monochrom> If you use that to choose your pivot, you get n lg n worst case.
09:58:05 <mniip> supitto, median of medians
09:58:07 <monochrom> People don't always do that because the constant multiplier is bigger.
09:58:33 <mniip> it does invoke quickselect recursively, but the complexities work out
10:00:57 <monochrom> So, no one wants to say "teach the controversy! if you are not using a mutable array, it is not quicksort" ?  >:)
10:01:37 <supitto> That made me laugh hard
10:05:27 <nshepperd_> Apparently a paper came out last year that improves the constant factors of median of medians http://erdani.com/research/sea2017.pdf
10:05:36 <monochrom> Nice.
10:11:29 <hololeap> @let newtype Thing d a = Thing { runThing :: (a -> a -> d) -> a }
10:11:30 <lambdabot>  Defined.
10:11:58 <hololeap> how would fmap be written for this?
10:12:44 <geekosaur> that looks wrong. it never gets an a
10:13:36 <hololeap> i figured it out for newtype Thing d a = Thing { runThing :: (a -> d) -> a }
10:14:56 <firc5e1e4308> fmap f (Thing g) = \ a b -> f (g a b)
10:15:26 <phadej> the latter Thing is Cont
10:15:57 <firc5e1e4308> fmap f (Thing g) = \ a b -> Thing $ f (g a b)
10:16:25 <phadej> wait, it's not
10:16:50 <phadej> Select: http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Select.html
10:17:58 <nshepperd_> @djinn (a -> b) -> ((a -> a -> d) -> a) -> ((b -> b -> d) -> b)
10:17:58 <lambdabot> f a b c = a (b (\ d _ -> c (a d) (a d)))
10:20:32 <potong> @help
10:20:32 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:20:32 <hololeap> nshepperd_: thanks
10:20:51 <hololeap> useful tool.
10:20:58 <potong> @help list
10:20:58 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
10:21:19 <nshepperd_> Note that djinn gave up before realizing that it could use both of the arguments to the inner function
10:21:52 <geekosaur> :exf "(a -> b) -> ((a -> a -> d) -> a) -> ((b -> b -> d) -> b)"
10:21:52 <potong> @help free
10:21:52 <lambdabot> free <ident>. Generate theorems for free
10:21:53 <exferenceBot> \ f1 f2 f3 -> f1 (f2 (\ g -> f3 (f1 g) . f1))
10:21:53 <exferenceBot> \ f1 f2 f3 -> f1 (f2 (\ g -> \ h -> f3 (f1 h) (f1 g)))
10:22:28 <nshepperd_> It should be (\d e -> c (a d) (a e))
10:23:45 <potong> @list
10:23:46 <lambdabot> What module?  Try @listmodules for some ideas.
10:25:42 <potong> > sum [1..10]
10:25:45 <lambdabot>  55
10:28:32 <potong> @listmodules
10:28:32 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
10:28:33 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
10:47:30 * hackage iso8601-duration 0.1.1.0 - Types and parser for ISO8601 durations  http://hackage.haskell.org/package/iso8601-duration-0.1.1.0 (albertov)
10:52:49 <encodes> This version achieves the same as the last but without needing to define a new version of reify for kind *->* types. if the comments around using2 are removed, there are many errors; https://lpaste.net/7690765987238379520
10:54:20 <encodes> this can be compared against the kind * case; https://lpaste.net/6834688991220989952
10:54:59 * hackage tintin 1.9.1 - A softer alternative to Haddock  http://hackage.haskell.org/package/tintin-1.9.1 (NickSeagull)
10:58:23 <encodes> how can using be written properly for the kind *->* case?
11:00:44 <encodes> also, reifiedIns2 on line 22 might not be correct...
11:19:08 <haasn> Is it possible to implement Data.Data for an existential data type?
11:21:22 <glguy> haasn: I would think so assuming you had the right Data constraints on the quantified type variables, at least in some cases
11:21:40 <haasn> i.e. data SomeData = forall a. Data a => SomeData a
11:22:16 <haasn> the standard derived case gunfold k z _ = k (z SomeData) fails type checking
11:22:58 <glguy> Oh yeah, maybe not. I'd have to actually play with it :-/
11:23:28 <haasn> even though you'd think it should since `k` also requires a Data constraint on the same parameter
11:24:22 <haasn> Actually it's more subtle than that, even `z SomeData` fails because it's ambiguous which type you're using
11:24:26 <haasn> Maybe I need scoped type variables or something
11:26:53 <dmj`> Anyone used BFNC ?
11:26:57 <dmj`> BNFC*
11:28:44 <encodes> this version gives a more meaningful error; https://lpaste.net/8889766800099639296
11:30:54 <encodes> meaningful/difficult
11:35:25 <dmj`> nvm
11:38:52 <encodes> oh, it was a stray forall a.
11:41:06 <simon> https://gist.github.com/sshine/e02c202c2045fc711f0bd9e619f7e882 -- is there any way I can make this piece of code work without listing all the remaining constructors? (in this case it's only one, but for my AST it's like 20 where only 3 have the parameter.)
11:42:37 <monochrom> There is an extension DeriveFunctor for this.
11:44:09 <simon> monochrom, excellent, thanks.
11:46:41 <the_2nd> If I want to make my program fail in IO with output to stderr and error code, what should I do? error "foo" ?
11:47:36 <cocreature> the_2nd: if you really want a fatal error and you are writing an application rather than a library, then you can use hPutStrLn stderr and exitFailure
11:49:14 <roconnor> Yep.  System.Exit.exitFailure or if you have a specific code in mind, System.Exit.exitWith exitcode
11:49:27 <the_2nd> yeah I want it to be used e.g. when piping on linux
11:50:14 <roconnor> (must be called from the main thread if you are multithreaded)
12:09:59 * hackage dwergaz 0.2.0.2 - A minimal testing library  http://hackage.haskell.org/package/dwergaz-0.2.0.2 (henrytill)
12:14:48 <dmwit> the_2nd: `die "foo"` puts `foo` to stderr and exits with code 1.
12:14:59 * hackage webdriver-w3c 0.0.1 - Bindings to the WebDriver API  http://hackage.haskell.org/package/webdriver-w3c-0.0.1 (nbloomf)
12:15:01 <dmwit> the_2nd: Pretty convenient shortcut for the steps other folks are describing here.
12:15:13 <dmwit> (`die` is available from `System.Exit`.)
12:22:01 <geekosaur> with a sufficiently recent ghc, at least
12:25:03 <roconnor> dmwit: nice.
12:37:55 <dmwit> Sufficiently recent, yes -- but "sufficient" in this case is pretty lax. It's been three years.
12:40:42 <Unode> I'm trying to build a static binary with ghc. This has worked in the past but recently a package that depends on cairo was included and is now failing during linking due to missing references to the pixman lib. All relevant libs are in the system but I'm having a hard time figuring out how to pass -lpixman-1 to ghc to ensure references are picked up correctly. The static build (failing) log can be seen here:
12:40:44 <Unode> https://gitlab.com/ngless/ngless/-/jobs/76940825 and a non-static build (succeeding) is: https://gitlab.com/ngless/ngless/-/jobs/76939863
12:41:12 <Unode> Does anyone know how to do this correctly?
12:42:23 <Unode> or can provide any guidance...
12:44:14 <c50a326> hey if functions are pure is there an easy way to make the inverse without having to write it?
12:44:35 <encodes> here it is working; https://lpaste.net/8843645233662001152
12:44:41 <c50a326> oh actually no that doesn't work does it... like if you've got 4 it's impossible to say if it was 2+2 or 3+1
12:46:21 <the_2nd> when having mulitple executables in a .cabal
12:46:33 <the_2nd> is there a way to define some sort of parent dependency?
12:46:48 <the_2nd> e.g. currently both might depend on the same 100 files / packages
12:46:53 <the_2nd> and only differ in 2
12:47:12 <cocreature> the_2nd: make a library that contains the 100 files
12:47:46 <cocreature> since cabal 2.0 you can also have multiple internal libraries which can be convenient if you want to do this just to organize and share things within your package
12:49:21 <sps4> I have a function createReport :: Info -> Maybe Report. Given a [Info], I want to generate two lists, [Report] and a [Info] that produced a Nothing.
12:51:51 <roconnor> compose createReport with a function that map Maybe Report to Either () Report.
12:52:03 <roconnor> er rather
12:52:09 <roconnor> compose createReport with a function that map Maybe Report to Either Info Report.
12:52:30 <roconnor> anyhow then map that function over [Report] and use partitionEithers.
12:52:49 <cocreature> :t \f xs -> partitionEithers (map (\x -> maybe (Left x) Right (f x)) xs)
12:52:50 <lambdabot> (a -> Maybe b) -> [a] -> ([a], [b])
12:54:17 <sps4> roconnor: I see. thanks.
12:56:15 <roconnor> cocreature has spelled out an implementation.
12:58:15 <cocreature> although I would probably just use "case" rather than "maybe" here
13:28:10 <nec> how can i get the most general unifier for a type equation ?
13:30:08 <statusfailed> can I write class instances like this?: instance (forall a . FromJSON (f a)) => FromJSON (MyType f) where ...
13:30:15 <c_wraith> nec: I'm not sure what you're asking.  Can you give an example of the process you want?
13:30:25 <statusfailed> (I mean, I'm getting an error "illegal polymorphic type", but I wonder if I can achieve something similar?)
13:30:28 <c_wraith> statusfailed: not yet, but it's coming soon.  QuantifiedContexts, or something like that
13:30:35 <statusfailed> aw durnit
13:31:05 <statusfailed> maybe in case I'm X/Ying, MyType is a record, where I want to have some fields optional, and sometimes they should be mandatory
13:31:08 <c_wraith> statusfailed: the current state of doing things would be to create a FromJSON1 class that you can put the constraint on.
13:31:10 <statusfailed> so I thought to parametrise by a functor f
13:31:19 <statusfailed> not sure if there's a better way
13:31:23 <c_wraith> (maybe that class already exists?)
13:31:52 <statusfailed> "this has been merged" - seems possible :D
13:32:42 <nec> c_wraith: i have this type equation: {Int → α = β → Bool → β, γ → Int = α} , now i need to get the most general unifier
13:34:45 <encodes> !?
13:35:07 <c_wraith> that looks like two equations to me...
13:35:37 <nec> c_wraith: exactly, i need the mgu for these two equations
13:37:20 <c_wraith> I suppose that's pretty close to on-topic for this channel, though it's a rather unusual vocabulary for the context of haskell.
13:37:34 <encodes> how to return type 's' of reify rather than providing it?
13:37:47 <Tuplanolla> You can follow algorithm W to discover that the system of equations has no free variables, nec.
13:37:55 <Tuplanolla> Is that what you're asking?
13:38:13 <c_wraith> pretty sure "algorithm W" is the answer.
13:38:59 * hackage pomaps 0.0.1.0 - Maps and sets of partial orders  http://hackage.haskell.org/package/pomaps-0.0.1.0 (sgraf812)
13:39:04 <dysfun> it's a shitty question if the answer isn't either algorithm W or algorithm M
13:39:29 <nec> Tuplanolla: i think its about the algorithm of robinson ?
13:42:31 <encodes> i.e. expressing '(i,a) -> b' as Refies i (Def Is (a->b)), what would 'a->(i,b)' be?
13:43:11 <statusfailed> hm, I'm a bit confused how I can use FromJSON1 to write my instance
13:43:23 <statusfailed> I assumed instance FromJSON1 f => FromJSON (MyType f)
13:43:42 <statusfailed> but I get lots of errors like "Could not deduce (ToJSON (f SomeFieldType))"
13:47:41 <nec> Tuplanolla: c_wraith: Example: A1 = ( X, Y, f(b) ).  A2  = ( a, b, Z ).  now with unification i make them the same with sigma(A1) = (a, b, f(b) ) , sigma(A2) = (a, b, f(b) ). where  sigma = (X -> a, Y -> b, Z -> f(b) )
13:48:04 <c_wraith> statusfailed: hmm, that looks basically right.  The error suggests the problem is in the other direction somewhere, like you called ToJSON on it
13:49:32 <statusfailed> c_wraith: hm, I think you're right - I need to pare down my example a bit
13:52:20 <nec> Tuplanolla: c_wraith: and because there are many unifications possible, i need find the most general unifier for the two equations posted before
13:57:50 <nec> Tuplanolla: the answer is it has no free variables ?
14:16:05 <lukelau> Are there any libraries for mechanically/programtically editing a .cabal file?
14:16:09 <lukelau> Same with package.yaml
14:17:37 <dmj`> lukelau: Cabal
14:21:07 <statusfailed> c_wraith: couldn't figure it out with pared down example, so I posted to SO: https://stackoverflow.com/questions/51005138/
14:21:25 <rotaerk> hmm is there some emacs plugin that would let you hit a keybinding, and it will generate a type declaration above the symbol at the cursor
14:21:55 <rotaerk> as in if you have foo = 5, it will generate foo :: Num a => a
14:23:01 <c_wraith> statusfailed: oh, that looks like the default instance is written in terms of ToJSON, rather than ToJSON1
14:23:50 <c_wraith> statusfailed: try defining toJSON as toJSON1 in the instance.
14:24:10 <dmj`> lukelau: https://gist.github.com/53e1e130e20c6c49691b97379a519b9e
14:24:13 <c_wraith> statusfailed: oh, that's not quite right either.  But it's something like that. :)
14:25:14 <lukelau> dmj`: Awesome
14:30:08 <Solonarv> rotaerk: I don't know if there is a ready-to-use emacs plugin for it, but at least one of the haskell editor backends has a way to insert a type decl
14:30:11 <statusfailed> c_wraith: haha :D
14:30:20 <statusfailed> I'm sure it's going to be something simple
14:30:27 <statusfailed> either that or it's impossible :-P
14:31:41 <rotaerk> Solonarv, ah
14:32:09 <rotaerk> Solonarv, btw, I got what I wanted working with nested runResourceTs, so I dropped Scope
14:32:09 <Solonarv> well this is pretty much exactly what the new QuantifiedConstraints language extension is for
14:32:18 <Solonarv> rotaerk: great!
14:32:25 <butterthebuddha> Can I get GHC to print every function call?
14:32:55 <butterthebuddha> One of my functions is running really slowly and I suspect that it's because it's getting caught in too many recursive calls
14:33:09 <rotaerk> use a profiler
14:33:10 <Solonarv> *every* call on every function? no
14:33:17 <Solonarv> not in any practical way that I know of
14:33:22 <Solonarv> but yes, use a profiler
14:33:27 <Solonarv> that's what they're for
14:34:29 <dmj`> butterthebuddha: there’s Debug.Trace.traceStack
14:35:17 <Solonarv> butterthebuddha: with GHC HEAD you can write instance (forall x. ToJSON x => ToJSON (f x)) => ToJSON (MyType f)
14:35:36 <Solonarv> ah sorry wrong ping, I meant statusfailed
14:35:59 <Solonarv> this will also be in GHC 8.6.1 afaik, which will be released soon-ish
14:37:38 <Solonarv> with current GHC I think you could do something like instance (ToJSON (f Int), ToJSON (f String)) => ToJSON (MyType f)
14:55:20 <hastuur> is haskell better than lisp prolog and smalltalk?
14:56:47 <tdammers> yes
14:56:56 <tdammers> (biased answer though, see channel name)
14:57:56 <Solonarv> Not in scope: ‘better’
14:59:23 <firc5e1e4308> hastuur: than lisp , less () more types ; than prolog , no clauses and noresolution calculus ; than smalltalk , no subtyping but parametic polymorphism
14:59:54 <firc5e1e4308> if that sounds good .... go for it
15:00:37 <pdxleif> @pl foo (\x y -> bar x y arg3 arg4)
15:00:37 <lambdabot> foo (flip flip arg4 . flip flip arg3 . bar)
15:00:47 <pdxleif> I'm sure no one will mind if I use that suggestion...
15:02:30 <pdxleif> Of course, I could redefine the arg order of bar so it takes x and y last, and write that as foo $ bar arg3 arg4
15:12:46 <maerwald> tdammers: well, no one has written a world class editor in haskell yet, so that point goes to lisp :>
15:16:46 <hastuur> is haskell better than lisp prolog and smalltalk?
15:17:42 <Rembane> hastuur: Yes!
15:17:58 <maerwald> is he just copy pasting that across different channels?
15:18:11 <pdxleif> There's "yi".
15:18:16 <maerwald> not a world class editor
15:20:53 <apoc> at least they don't have 5 different string types, so no
15:21:30 <butterthebuddha> "lpaste.net unexpectedly closed the connection.
15:21:30 <butterthebuddha> ERR_INCOMPLETE_CHUNKED_ENCODING"
15:21:42 <butterthebuddha> ^ getting that error when I try to make a lpase
15:21:45 <butterthebuddha> lpaste*
15:21:51 <pdxleif> What are the 5? String, Lazy and String ByteString and Text?
15:21:56 <pdxleif> *Strict
15:22:14 <pdxleif> @info IsString
15:22:14 <lambdabot> IsString
15:23:04 <apoc> I was just refering to https://mmhaskell.com/blog/2017/5/15/untangling-haskells-strings
15:28:06 <maerwald> and OverloadedStrings is the worst imo :>
15:30:36 <Solonarv> OverloadedStrings is a bit of a wart, but it's better than using Prelude.String
15:30:53 <maerwald> it can introduce quite subtle bugs and in general makes it hard to reason about string types
15:31:19 <maerwald> it's one of those instances where short code really is not better
15:31:31 <Solonarv> so what do you recommend? explicitly wrapping your literals in pack / whatever the bytestring one is?
15:31:37 <maerwald> yes.
15:31:53 <Solonarv> fair enough
15:32:10 <maerwald> in addition, strings are also for some parts ghc version dependant
15:33:07 <maerwald> https://hackage.haskell.org/package/word8-0.1.3/docs/Data-Word8.html
15:34:17 <Solonarv> what part of that module doc am I meant to be looking at?
15:34:34 <nshepperd> what kind of bugs can OverloadedStrings cause?
15:34:38 <maerwald> "Base library 4.7 (GHC 7.8) or earlier is based on Unicode 6.  Base library 4.8 (GHC 7.10) or later is based on Unicode 7.  isLower, isSymbol and isPunctuation behave differently."
15:35:14 <maerwald> nshepperd: result depends on type inference, which may not actually be what you want, then your program does double decoding or other weird stuff
15:37:04 <nshepperd> hm, double decoding?
15:37:11 <maerwald> yes
15:37:22 <nshepperd> oh, because the bytestrings also have IsString instances?
15:37:40 <Rembane> Yes! :D
15:37:51 <maerwald> right, something like that happened to me when I was dealing with GlibString (from glib bindings)
15:38:06 <maerwald> it was quite non-trivial and a rather dangerous bug
15:38:11 <crestfallen> hi revisiting basics: why does the order change in the lambdas here, with foldrr and foldl ? https://ptpb.pw/ZdKi
15:39:03 <crestfallen> the seed is in the second place in foldr (I wrote it as foldrr)
15:40:22 <nshepperd> 'class (IsString s, Monoid s, Show s) => GlibString s where' ew
15:40:30 <maerwald> :>
15:40:42 <nshepperd> 'withUTFString :: s -> (CString -> IO a) -> IO a' double ew
15:40:54 <Solonarv> ew wtf
15:40:54 <nshepperd> this library seems confused
15:41:02 <maerwald> at some point, you don't really know what the semantics are and OverloadedString doesn't force you to think about it
15:41:22 <maerwald> so stuff kinda type checks, but...
15:42:38 <nshepperd> yeah, normally I choose a specific string type and only use OverloadedStrings so that I don't have to write Text.unpack in front of every string constant
15:42:39 <Solonarv> OverloadedStrings is a good idea in principle; it's not much different from Num-with-only-fromInteger
15:42:53 <Solonarv> but there seems to be a lot more dubious use of OverloadedStrings than Num
15:43:33 <maerwald> it's not that much trouble to use explicit packs I found
15:43:53 <maerwald> maybe use some shorthand function alias
15:45:07 <Solonarv> I'm curious, what's your stance on OverloadedLists?
15:45:17 <maerwald> haven't use them yet
15:46:14 <crestfallen> > scanl (\_ -> \acc -> acc + 1) 0 [5,6,7]
15:46:16 <lambdabot>  [0,6,7,8]
15:46:28 <crestfallen> > scanl (\acc -> \_ -> acc + 1) 0 [5,6,7]
15:46:28 <maerwald> I prefer correctness over convenience in general, so when I can avoid bugs with explicitness, I tend to be explicit
15:46:30 <lambdabot>  [0,1,2,3]
15:47:01 <Solonarv> I find it quite handy because I tend to use several of Vector / HashMap / Map / Set etc in the same module, and having qualified fromList calls everywhere is not something I'm a big fan of
15:47:07 <Solonarv> too much clutter
15:47:18 <maerwald> well, if you haven't hit weird bugs yet, then why not
15:47:40 <maerwald> the reason I stopped using OverloadedString was not a philosophical one, but because it broke my program
15:47:49 <Solonarv> I haven't hit bugs with overloaded strings either ;)
15:47:53 <Solonarv> at least not that I can recall
15:47:53 <maerwald> and I realized I am too lazy to use it properly
15:48:22 <nshepperd> hm, GlibString only has instances for Text and String, so that seems ok
15:48:28 <nshepperd> so i wonder how it went wrong?
15:48:44 <maerwald> I don't remember, I might have to check my git log for it
15:49:00 <Solonarv> I do enable it on a per-module basis (instead of package.yaml) so that helps not having it show up in unexpected places
15:49:51 <crestfallen> since the seed set at 0 must be the first argument in the lambda for this to work like length I guess ?  (length = 3) please comment
15:50:08 <maerwald> nshepperd: I have an orphan instance instance GlibString BS.ByteString btw
15:50:16 <nshepperd> oh
15:50:29 <Solonarv> but if I'm writing say a FromJSON instance I really don't want to use `o .: (T.pack "key")` instead of `o .: "key"`
15:50:30 <nshepperd> there's your mistake :)
15:50:43 <maerwald> not a mistake in it's own
15:51:01 <maerwald> except you have to know what that ByteString means
15:51:04 <nshepperd> I think bytestrings absolutely should not have an IsString instance
15:51:12 <nshepperd> they're not strings
15:51:16 <maerwald> yeah
15:51:17 <Solonarv> it's not clear whether this is an example of "orphans are risky" or "overloaded strings are risky"
15:51:29 <Solonarv> of course it could be both ;)
15:51:53 <maerwald> Solonarv: well, I would not have hit that bug without overloaded strings, because the stuff would not have type checked
15:51:54 <maerwald> afair
15:51:59 <nshepperd> I think ideally I would use a language extension that makes string constants monomorphically strict Text
15:52:19 <maerwald> and as soon as I removed it, things became clear why they didn't work
15:52:34 <Solonarv> yeah just not having to interact with `String` at all would be ideal
15:52:36 <nshepperd> actually I suppose with RebindableSyntax that can be accomplished just by importing a different fromString
15:54:26 <Solonarv> true
15:54:30 * hackage doctest 0.15.1 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.15.1 (SimonHengel)
15:55:24 <maerwald> the only true string handling is in C :>
15:55:56 <maerwald> no convenience, no mistakes
15:55:57 <nshepperd> {-# Language OverloadedStrings, RebindableSyntax #-} import Data.String hiding (fromString); fromString = Data.Text.pack
15:55:59 <nshepperd> perfect
15:57:53 <Solonarv> is the data.string import actually needed?
16:00:40 <Cale> maerwald: Don't you mean "no convenience, devastating mistakes which cause security vulnerabilities all the time"?
16:00:44 <nshepperd> i think fromString is implicitly imported when you enable the extensions
16:00:50 <maerwald> Cale: that too ^^
16:01:14 <nshepperd> so you need to unimport it to replace it with the monomorphic version
16:01:15 <maerwald> but sometimes, convenience has negative impact on correctness
16:01:32 <maerwald> (like missing types :P)
16:02:04 <maerwald> and isn't that somehow what it does? You're not specifying the type of your string literal and it just guesses it from the context
16:02:14 <maerwald> it feels like duck typing, even if it isn't technically
16:03:40 <geekosaur> so how do you feel about Num?
16:03:42 <geekosaur> }:>
16:04:25 <maerwald> :(
16:05:04 * maerwald is going to write a blog post "type inference is duck typing" :P
16:05:06 <nshepperd> I still think the root cause here is having instances of this stuff for bytestrings
16:05:29 <maerwald> yeah, you don't know how a bytestring is encoded
16:05:34 <nshepperd> the class of semirings is a meaningful thing
16:05:56 <nshepperd> and has a canonical decoding from natural numbers
16:06:18 <nshepperd> whereas bytestrings are just a totally different thing from text
16:08:36 <nshepperd> and yes, turning text into bytestring has no canonical encoding, so...
16:10:41 <nshepperd> you don't have problems with guessing the semantics of integer constants in haskell, and you don't have problems with guessing the semantics of text constants either, as long as the instances of IsString are all actually text types
16:11:34 <nshepperd> ("actually text" ~ is a sequence of unicode characters)
16:17:55 <pdxleif> We have overloaded numeric literals... but overloaded string literals are bad?
16:18:00 * hackage doctest 0.16.0 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.16.0 (SimonHengel)
16:19:14 <pdxleif> I guess Num implies a fair amount more than IsString
16:20:19 <Solonarv> Num is exactly a ring
16:20:20 <pdxleif> If we had Overloaded strings in Idris I could use Strings to write type signatures; :/ a la https://gist.github.com/LeifW/8f99aaca6d63b28f195e
16:20:26 <butterthebuddha> Is there any of expressing "subtype" with ADTs?
16:20:31 <butterthebuddha> any way*
16:20:33 <dmj`> Anyone here ever used BNFC?
16:20:52 <Solonarv> with ADTs, not really; you can have the "superclass" be a field of the "subclass"
16:21:13 <butterthebuddha> I have a type Atom, which contains two constructors for "Sym" and "Key"; both store Strings
16:21:37 <butterthebuddha> I have a nonstandard Show instance for Atom
16:21:52 <butterthebuddha> And I'd like to use the "constructors" Sym and Key as keys in a Map
16:22:05 <butterthebuddha> (because of the Show instance which I don't want to duplicate)
16:22:18 <Solonarv> your explanation is rather unclear
16:22:50 <Solonarv> could you post some code using https://lpaste.net , https://gist.github.com , or an equivalent?
16:22:52 <butterthebuddha> I have a type "data Atom = Key String | Sym String | ... "
16:23:26 <butterthebuddha> I have a non-standard Show instance for Atom so the strings in Key and Sym are printed differently
16:24:13 <butterthebuddha> I'd like to have a Map with a String key, but I want to express the fact that the String is in fact "a Sym"
16:35:11 <Zipheir> butterthebuddha: Stick ("Sym" ++) somewhere in your Map-building code?
16:37:03 <Solonarv> that doesn't sound like a great idea
16:37:24 <Solonarv> make a newtype SymKey = SymKey String
16:37:29 <Solonarv> and use that as your map key
16:37:56 <Tuplanolla> Here's a better idea: don't mix `Show` and `Read` with pretty printing and parsing.
16:38:59 <Solonarv> `read` *is* a parsing function by definition
16:41:13 <jle`> Solonarv: presumably Tuplanolla means parsing of the pretty-printed version
16:41:28 <Solonarv> ah yeah
16:41:50 <Solonarv> if you're going to have both Show and Read instances it's probably best to just use the auto-derived ones
16:43:01 <jle`> butterthebuddha: your original question sounds like you want to express an ADT without one of the possible constructors?
16:43:14 <jle`> there's no built in way in haskell that can do that
16:43:50 <jle`> the simplest way would just be to declare an alternative data type with only the constructors you want (and their contents)
16:49:25 <Solonarv> there are other ways but it gets complicated and boilerplate-heavy rather quickly
16:52:52 <kevinmeredith> Could someone please explain this type signature to me?
16:52:52 <kevinmeredith> class EncodeJson m n a | m a -> n where
16:52:52 <kevinmeredith>   encodeJson :: m a -> n Json
16:52:53 <kevinmeredith> https://github.com/argonaut-io/argonaut-hs/blob/master/src/Data/Argonaut/Encode.hs#L22-L23?
16:52:55 <kevinmeredith> I don't follow the `m a -> n` part
16:52:58 <kevinmeredith> Thanks
16:53:57 <Solonarv> that means "`m` and `a` together determine `n`"
16:54:16 <Solonarv> which means you can't have two instances with the same `m` and same `a` but different `n`
16:54:49 <jle`> kevinmeredith: the practical main usage of it is to help with typechecking
16:55:14 <kevinmeredith> Thanks, Solonarv and jle. What can we tell about m, n and a from that typeclass? Do you know their kinds?
16:55:24 <jle`> if you have a certain 'm a', then ghc can infer what 'n' would be for the instance
16:55:31 <jle`> kevinmeredith: yeah, you can tell it from the type of encodeJson
16:55:35 <Solonarv> we can infer their kinds, yes
16:55:36 <jle`> encodeJson :: m a -> n
16:55:40 <jle`> (->) :: * -> * -> *
16:55:51 <jle`> so you know that m a :: *
16:56:01 <jle`> hm, i suppose you can't fully infer all of their kinds
16:56:10 <jle`> the kind of 'a' is not inferrable
16:56:21 <kevinmeredith> How do you know that `m` is `*` and not `* -> *` or something else?
16:56:29 <jle`> kevinmeredith: 'm a' is *
16:56:33 <jle`> not m
16:56:44 <jle`> 'm a' is *, so 'm' has to be `k -> *`
16:57:09 <Solonarv> the typing judgment here is: (m a :: *) therefore (m :: k -> *, a :: k)
16:57:30 <Solonarv> I'm assuming (Json :: *) and we know that (n Json :: *), so (n :: * -> *)
16:57:31 <kevinmeredith> I've seen the asterisk notation with kinds (from LYAH), but I'm not familiar with the k. Could you please explain that?
16:57:39 <jle`> it's a kind variable
16:57:45 <jle`> like map :: (a -> b) -> [a] -> [b]
16:57:51 <Solonarv> `k` is a kind variable - it can be replaced with any kind
16:57:54 <kevinmeredith> Ah
16:57:58 <jle`> it's just common practice to use 'k' as the type variable for kinds
16:58:05 <jle`> the mnemonic is 'k for kind'
16:58:13 <jle`> but we could have used any other variable name
16:58:20 <Solonarv> in practice it will default to `k = *` unless you explicitly tell the compiler otherwise
16:58:28 <jle`> m :: q -> *, a :: q
16:58:54 <lukelau> If a have a bunch of Maybes, whats the best way to take the first non-Nothing?
16:59:07 <jle`> lukelau: you can put them in a Foldable, and use asum
16:59:09 <kevinmeredith> Looking at `encodeJson :: m a -> n Json`, could you please explain (sorry if asking the same question again), how do you know that m a has kind *?
16:59:23 <jle`> kevinmeredith: we can re-write it as (->) (m a) (n Json)
16:59:36 <kevinmeredith> Oh
16:59:36 <jle`> and know that (->) :: * -> * -> *
16:59:41 <lukelau> jle`: Cool, thanks
16:59:52 <jle`> lukelau: no problem :)
16:59:57 <kevinmeredith> Hmm
16:59:57 <kevinmeredith> λ: >:t (->)
16:59:57 <kevinmeredith> <interactive>:1:2: error: parse error on input ‘->’
17:00:02 <jle`> :k (->)
17:00:03 <lambdabot> TYPE q -> TYPE r -> *
17:00:10 <jle`> you might have been asking for the type
17:00:13 <jle`> but we're looking for the kind
17:00:15 <kevinmeredith> Ah!
17:00:27 <kevinmeredith> Thanks - that helps!
17:00:31 <jle`> no problem :)
17:00:43 <jle`> remember that values have types, so that's what :t expects
17:00:47 <jle`> (values)
17:00:59 <kevinmeredith> Looking at:
17:00:59 <kevinmeredith> instance EncodeJson Identity Identity JString where
17:00:59 <kevinmeredith>   encodeJson = Identity . fromJString . runIdentity
17:01:01 <kevinmeredith> What's the purpose/value of this instance? I don't follow the value of Identity in this case.
17:01:20 <jle`> are you familiar with the data type?
17:01:29 <Solonarv> bad lambdabot, stop confusing people with levity polymorphism!
17:01:40 <jle`> data Identity a = Identity { runIdentity :: a }
17:01:53 <jle`> if we make it more pointful, that's encodeJson (Identity x) = Identity (fromJString x)
17:02:29 <jle`> kevinmeredith: one of the big purposes of Identity in general is its use as a 'base case' of sorts, for recursive/inductive typeclass instances
17:02:48 <jle`> i'm not sure about this specific example, though
17:03:34 <kevinmeredith> Comparing it to the Scala argonaut:
17:03:35 <jle`> kevinmeredith: but, you can look at the type of encodeJson to see how it can be used
17:03:47 <jle`> encodeJson :: Identity JString -> Identity Json
17:03:59 <kevinmeredith> trait EncodeJson[A]  --> an instance of an EncodeJson indicates that the A can be represented as JSON
17:04:02 <jle`> and we know that `Identity a` is no different than `a`
17:04:10 <jle`> so effectively we have encodeJson :: JString -> Json
17:04:26 <jle`> basically it's just encodeJson = fromJString
17:05:11 <jle`> alone, it's not very useful, since you can always just use 'fromJString'
17:05:20 <jle`> it's mostly useful if you think of it in terms of polymorphic code
17:05:42 <jle`> so you can use JString's with code written polymorphically to work for all EncodeJson's
17:06:09 <jle`> or, someone could use it to write an EncodeJson instance in terms of other EncodeJson instances, and Identity can serve as a base case of sorts
17:06:38 <jle`> from looking at just the module you linked, i can't find any examples of this second usage, but the first one still applies
17:07:42 <kevinmeredith> > so you can use JString's with code written polymorphically to work for all EncodeJson's
17:07:45 <lambdabot>  error:
17:07:45 <lambdabot>      • Variable not in scope:
17:07:45 <lambdabot>          so
17:07:48 <kevinmeredith> could you say a bit more, please? I Don't follow
17:08:14 <kevinmeredith> "so you can use JString's with code written polymorphically to work for all EncodeJson's" (repeating since I don't know if what I typed above was output to the chtaa)
17:08:49 <jle`> kevinmeredith: yes, let's say someone wrote some function like myFunction :: EncodeJson m n a => m a -> IO ()
17:09:04 <jle`> you can use that function with any JString
17:09:13 <jle`> by passing it an `Identity JString`
17:10:09 <kevinmeredith> I'm still grappling with the purpose of m and n. I'm not doubting them, but rather looking to understand!
17:10:34 <jle`> in the instances you gave, they are a little silly
17:10:51 <jle`> but they are presumably more useful with other instances
17:11:00 * hackage network 2.7.0.1 - Low-level networking interface  http://hackage.haskell.org/package/network-2.7.0.1 (dukerutledge)
17:11:10 <jle`> we can write one where m is [] and n [], say
17:11:19 <jle`> instance EncodeJson [] [] JString where
17:11:25 <jle`>     encodeJson = map fromJString
17:11:31 <jle`> here, encodeJson :: [JString] -> [Json]
17:11:56 <kevinmeredith> when would m and n not be the same, e.g. Identity or []?
17:12:05 <jle`> whenever you want
17:12:15 <jle`> data Proxy a = Proxy
17:12:24 <jle`> instance EncodeJson Maybe Proxy Int where
17:12:27 <jle`>     encodeJson _ = Proxy
17:12:38 <jle`> here, encodeJson :: Maybe Int -> Proxy Json
17:12:56 <jle`> you could even write:
17:13:00 <jle`> instance EncodeJson Maybe [] Int where
17:13:06 <jle`>     encodeJson _ = []
17:13:15 <jle`> here, encodeJson :: Maybe Int -> [Json]
17:13:22 <jle`> i'm not saying it would be useful, though :)
17:13:27 <jle`> (those instances would be pretty useless)
17:13:33 <kevinmeredith> ^^ :eye:
17:14:00 <Solonarv> if I found that instance in a library I'd feel inclined to slap the library author with a big ol' herring made of fundeps
17:14:09 <Solonarv> ^^
17:14:14 <jle`> there isn't anything from the module you gave that leverages the different m's and n's so i can't really see the purpose behind using different ones
17:14:43 <jle`> but it probably becomes useful in other modules/usage sites
17:15:03 <jle`> for what it's worth, i don't recognize this as a common design pattern
17:15:27 <jle`> in fact, it smells a lot like a common anti-patern
17:15:52 <jle`> can't tell for sure without seeing how it is used, heh
17:16:38 <kevinmeredith> Looking at data Json = JsonObject !JObject from https://github.com/argonaut-io/argonaut-hs/blob/master/src/Data/Argonaut/Core.hs#L80, what's the meaning of the exclamation point?
17:17:03 <jle`> it's a strict field
17:17:31 <jle`> semantically it means that whenever you resolve a JsonObject, you also evaluate the JOpject inside
17:17:59 <jle`> for normal data types, pattern matching on the constructor does not cause the contents to be evaluated
17:18:05 <jle`> @data MyData = MyData Int
17:18:06 <lambdabot> Unknown command, try @list
17:18:12 <jle`> @let data MyData = MyData Int
17:18:13 <lambdabot>  Defined.
17:18:27 <jle`> > case (MyData undefined) of MyData _ -> 10
17:18:29 <lambdabot>  10
17:18:39 <jle`> we can pattern match on the MyData constuctor without poking at the 'undefined'
17:18:48 <jle`> @let data MyData2 = MyData2 !Int
17:18:49 <lambdabot>  Defined.
17:18:55 <jle`> > case MyData2 undefined of MyData2 _ -> 10
17:18:57 <lambdabot>  *Exception: Prelude.undefined
17:19:05 <kevinmeredith> If you referenced undefined, i.e. of MyData a -> 10, it'd blow up?
17:19:12 <kevinmeredith> (heh - let me just run it)
17:19:17 <jle`> yes, only if you reference it, like MyData x -> x * 10
17:19:35 <jle`> the main purpose of a strict data field is to prevent unevaluated thunks from piling up and causing space leaks
17:19:39 <kevinmeredith> λ: >case (MyData undefined) of MyData a -> 10
17:19:39 <kevinmeredith> 10
17:19:48 <jle`> you still never refernce the contents, in that case
17:19:51 <kevinmeredith> Ah
17:19:54 <jle`> > case MyData undefined of MyData x -> x * 10
17:19:56 <lambdabot>  *Exception: Prelude.undefined
17:21:04 <jle`> lazy data fields helps with space usage in some situations, and hurts in others
17:21:11 <jle`> lazy fields is the 'default' behavior
17:21:17 <kevinmeredith> interesting - so the same for a newtype?
17:21:20 <kevinmeredith> λ: >newtype Password = Password String
17:21:21 <kevinmeredith> λ: >case (Password undefined) of (Password a) -> 4
17:21:21 <kevinmeredith> 4
17:21:51 <jle`> so if the library declares a strict field, it means that the usage of that field is a situation where a strict field would be more useful
17:22:31 <Solonarv> newtypes are a bit different
17:22:35 <kevinmeredith> Why does argonaut-hs use strict fields in its https://github.com/argonaut-io/argonaut-hs/blob/master/src/Data/Argonaut/Core.hs#L80-L86, would you expect?
17:23:18 <jle`> probably because it is not using any of the benefits of laziness where it uses Json
17:23:26 <jle`> or, well, they are not planning on using any of the benefits of laziness
17:23:43 <Solonarv> using strict fields is generally a prtty good idea on finite data structures
17:23:53 <jle`> so it would just be a waste of space to let thunks build up
17:25:07 <jle`> laziness adds another layer of indirection, so if you don't ever plan on taking advantage of it, it's common practice in data types to turn it off
17:25:41 <jle`> (if you don't plan on taking advantage of it)
17:26:26 <jle`> you can always use a strict field lazily, too, and use a lazy field strictly, at the actual location where you use it
17:26:43 <jle`> so it's more of a declaration of intent/default behavior of that data type
17:26:53 <jle`> > case MyData undefined of MyData !x -> 10
17:26:56 <lambdabot>  *Exception: Prelude.undefined
17:26:59 <jle`> ^ using a lazy field strictly
17:27:10 <jle`> > case MyData2 undefined of ~(MyData2 x) -> 10
17:27:12 <lambdabot>  10
17:27:13 <jle`> ^ using a strict field lazily
17:27:55 <jle`> so it's possible to "override" strict/lazy.  picking if your field should be strict or lazy is more about saying what the normal behavior you want or are expecting is
17:28:53 <jle`> hm, maybe my second example was not very accurate
17:29:09 <jle`> > case MyData2 undefined of MyData2 ~x -> 10
17:29:12 <lambdabot>  *Exception: Prelude.undefined
17:29:16 <jle`> maybe it is not possible to use a strict field lazily
17:29:28 <jle`> i'm wrong here then :)
17:31:41 <Solonarv> strict fields are something like "whenever the constructor is in WHNF, its strict fields are all in WHNF"
17:33:37 <Solonarv> with `case <thing> of MyData2 _ -> ...` you evaluate <thing> to WHNF, which causes all its strict fields to also be evaluated
17:33:48 <Solonarv> if one of those strict fields is `undefined`, well, boom
17:35:50 <aryeh> Hi! I'm curious if someone can point me to some simple code/tutorial/explain uses of a type like `data X a b c = X`
17:36:39 <nitrix> aryeh: https://wiki.haskell.org/Phantom_type
17:36:53 <aryeh> nitrix: Oh wow, awesome, didn't know it had a name
17:37:07 <Solonarv> there's a `data Proxy a = Proxy` type in base which is the "standard" type of that form
17:37:18 <Solonarv> you might be able to find things by googling that
17:38:24 <nitrix> aryeh: You can probably find better material online now that you know what it's called :)
17:38:55 <kevinmeredith> Since you mentioned, Phantom Types, this answer helped me out quite a bit - https://stackoverflow.com/questions/28247543/motivation-behind-phantom-types
17:39:42 <aryeh> Totally unrelated -- I've noticed that Haskellers tend to be generally pretty friendly. For those of you that work professionally in Haskell, have you felt, as engineers, that things are a little more rational and less "on fire" than in other roles?
17:40:10 <aryeh> Pretty friendly, and also just knowledgeable, careful about how they think.
17:40:21 <aryeh> Not sure if this is just magical thinking/fantasizing on my part.
17:41:25 <Solonarv> the /r/haskell subreddit definitely seems nicer than other programming-related subreddits to me
17:42:08 <Solonarv> for context: those other subreddits are mostly /r/programming and /r/gamedev, occasionally I peek into /r/python
17:42:45 <nitrix> aryeh: I'm going to answer just for myself, I think it's a combination of multiple things. One is probably curiosity. Two might be a desire to better themselves and improving things around them.
17:44:45 <Solonarv> one thing I really appreciate about the haskell community is how devs of major packages / infrastructure aren't aloof and unreachable
17:45:01 <nitrix> That's what engineering should be about. Computer Science is a science after all.
17:46:07 <maerwald> Solonarv: I haven't encountered that problem in any language
17:46:34 <Solonarv> I didn't really phrase that very well
17:47:08 <Solonarv> I meant things like ed kmett being active on r/haskell, to pick out one example
17:47:34 <Solonarv> of course it's possible I simply don't recognize notable figures in other languages' communities
17:47:35 <maerwald> that's one guy and he is a magician indeed, but I wouldn't generalize that over the whole community
17:48:15 <maerwald> I've had quite different experiences where PRs were out for 6+ months until someone responded and then I just forked
17:48:29 <maerwald> for smaller projects, tbf
17:50:14 <maerwald> not sure if there are any numbers about how much dead-code projects we have on hackage vs <some other lang>
17:51:17 <maerwald> I'd say since ppl tend to experiment more in haskell, chances are also higher you stumble upon an abandoned lib
17:51:20 <nitrix> We get called out fairly often too for sitting on our ivory tower.
17:52:06 <nitrix> In the end, whatever inspires you can probably be used as leverage until something else inspires you.
17:59:04 <rotaerk> anyone actually use the debugging haskell debugging feature of haskell-mode in spacemacs, or emacs?
17:59:16 <rotaerk> s/the debugging/the/
18:00:08 <rotaerk> would be nice if there were a usable IDE that just worked out of the box rather than requiring a lot of fumbling with finnicky plugins
18:03:17 <leifm> q
18:04:17 <mrm> Yea, but tbf, that's probably just jealousy because they can't figure out how to use ivory as a building material.
18:24:48 <ich> Hey guys
20:46:16 <XorSwap>  
21:14:40 <ekoor> Hi I am not able to solve exercise problems from cis 194
21:14:57 <ekoor> Though I understand the text and language very well
21:15:08 <ekoor> What could be the problem ? What can I do ?
21:17:47 <glguy> You would have to ask a question about the things you don't understand
21:26:44 <ekoor> glguy: here is my real problem I see from last 6 years I never read anything and suddenly I couldnt read whole thing and even if I read its just sweeping and so couldnt do the problems
21:39:00 <anon136> Hi guys. I'm working on the exercises at the end of one of the chapters in my haskell book here and the solution that it gives dpesm
21:39:19 <anon136> doesn't compile.
21:39:40 <Cale> anon136: Can you put it on lpaste or something?
21:39:47 <anon136> all' :: (a -> Bool) -> [Bool] -> Bool; all' p = and . map p
21:39:54 <Cale> ah, one liner :)
21:40:06 <Cale> ah, the type signature is incorrect
21:40:12 <Cale> Change [Bool] to [a]
21:40:26 <anon136> So strange that the text book would give me false information though....
21:40:41 <Cale> These things happen -- which textbook is it?
21:41:27 <anon136> "Programming in Haskell" by Graham Hutton
21:44:46 <anon136> well thanks for clearing up the confusion, I'm going to just go with he miss-typed
21:48:32 <mjrosenb> or it could be a brain fart; the result of map p does in fact have type [Bool] ... although it isn't as if there is a subexpr that has that type.
21:50:08 <glguy> anon136: What chapter was that in?
21:50:50 <glguy> Oh, 7.9 Exercise 2?
21:51:06 <ekoor> all' :: (a -> Bool) -> [Bool] -> Bool;  I didn't understand  its type declaration ?
21:52:34 <ekoor> all' denotes something I forgot :(
21:52:55 <ekoor> time to retire :(
21:53:54 <anon136> glguy: chapter 7 exercise 2 part a
21:54:13 <anon136> glguy: oh yea you got it
21:55:14 <anon136> what do you make of it glguy, just a mistake on mr huttons part?
21:55:23 <dmwit> anon136: That one is listed in the online errata.
21:55:30 <mjrosenb> huh, this is kind of strange.  I currently have a datatype which I'm planning on replacing with a tuple; this operation almost always go in the opposite direction.
21:55:55 <dmwit> anon136: http://www.cs.nott.ac.uk/~pszgmh/pih-errata.html
21:56:07 <geekosaur> printing errors happen
21:56:17 <geekosaur> as do thinkos and typos
21:56:22 <anon136> dmwit: ok cool thanks
22:01:12 <mjrosenb> in other news, I just learned how (Either a a) is ever so slightly not the same as (Bool, a)
22:01:56 <dmwit> Yeah, bottoms ruin everything. =)
22:03:45 <mjrosenb> in this case, it isn't bottom that I'm concerned about, but the nearly adjacent concern of the extra overhead of calculating the Either to head.
22:04:42 <dmwit> I don't think you meant to type "to head". But I can't figure out what you meant to type instead.
22:05:13 <mjrosenb> I'm generating a list of solutions, taking at most N guesses, and the function currently returns Either [Sol] [Sol], Left if it ran out of guesses, Right if it didn't.
22:05:14 <dmwit> Ah, perhaps you did mean that, as short for "head normal form" or so.
22:05:43 <mjrosenb> and I want to extract "are there any solutions", without worrying about if it ran out of guesses.
22:05:57 <geekosaur> or head of the list, given the latest. although if it had been me, wouldn;t be the first time I had garbage from an earlier attempt at phrasing it dangling off the end…
22:07:59 <mjrosenb> no, head normal form; with (Bool, [Sol]), it shouldn't need to run until it runs out of guesses in order to distinguish between 0 solutions, and 1+ solutions.
22:41:43 <Guest65332> dir
22:48:54 <sebastia2> The inline-c documentation says that ghci should still work if used with the -fobject-code flag, but I haven't had any luck
22:49:23 <sebastia2> This is breaking the Haskero Visual Studio Code plugin for me, now that my project involves C interop through inline-c
22:50:08 <sebastia2> has anyone else experienced this problem?
22:59:12 <cocreature> sebastia2: how are you trying to start ghci?
23:02:09 <sebastia2> cocreature: the Haskero Visual Studio Code plugin starts ghci like so: stack ghci --with-ghc intero "--ghci-options=-ignore-dot-ghci -Wall -fobject-code -O0" --no-build --no-load
23:02:47 <sebastia2> the -fobject-code -O0 is my addition to the default process, which I put in through the plugin config
23:03:55 <cocreature> sebastia2: I would recommend that you first try to get "stack ghci" working in a terminal and then see how you can transfer that to haskero
23:04:15 <cocreature> what is the error message if you just try "stack ghci --ghci-options -fobject-code"?
23:05:26 <grooverg> Hi 22 weekend should be fine for writing a website and other software in Haskell
23:08:06 <sebastia2> cocreature: totally, I also tried outside of VSC and had the same problem. Here's the result when running in the terminal: https://lpaste.net/4001795306571169792
23:08:40 <sebastia2> (I neglected to mention before, my current build process requires a few extra-include/extra-lib flags)
23:09:05 <parsnip> grooverg: that probably depends on the person.
23:09:54 <cocreature> sebastia2: where is cpCollisionHandlerDoNothing defined? is that part of the external library or defined in a file that’s listed in c-sources?
23:10:35 <sebastia2> it's defined in a file listen in c-sources
23:10:39 <sebastia2> *listed
23:10:50 <grooverg> any crm software developed in haskell
23:11:00 <sebastia2> although, also part of the external library
23:11:25 <cocreature> huh, so the same symbol is defined twice? that sounds weird
23:13:00 <sebastia2> cocreature: I found that if I didn't specify where to find the shared object file and the headers, then the inline-c include couldn't find the file
23:13:25 <sebastia2> but then without also adding it to c-sources, it wouldn't find the involved symbol
23:13:40 <cocreature> sebastia2: is your project available publically somewhere?
23:14:47 <sebastia2> unfortunately not currently, I can try to pop the requisite parts out into pastes and link you to them
23:15:37 <cocreature> what exactly have you specified in c-sources? afaict cpCollisionHandlerDoNothing is a symbol defined by the chipmunk library so I don’t see how c-sources come into play here
23:18:41 <sebastia2> cocreature: here is the package.yaml: https://lpaste.net/29137543467368448 and here is the only file in the project that uses inline-c: https://lpaste.net/6603817667084156928
23:19:30 * hackage extensible-effects-concurrent 0.2.0.2 - Message passing concurrency as extensible-effect  http://hackage.haskell.org/package/extensible-effects-concurrent-0.2.0.2 (SvenHeyll)
23:19:59 * hackage greskell 0.2.0.1 - Haskell binding for Gremlin graph query language  http://hackage.haskell.org/package/greskell-0.2.0.1 (debugito)
23:20:54 <cocreature> sebastia2: try removing the c-sources part and instead specify "extra-libraries: chipmunk" (or whatever is the precise name of that lib)
23:22:02 <sebastia2> cocreature: interesting, is that within the library, not the top level of the package.yaml? And also, should the name of the library be the same as the name of the shared object file? (libchipmunk.so)
23:22:33 <cocreature> sebastia2: should be within the component that uses inline-c so in this case your library
23:22:48 <cocreature> if the name is libchipmunk.so you need to specify extra-libraries: chipmunk
23:23:28 <cocreature> you seem to be trying to mix a global installation of the chipmunk lib (located in /usr/local judging from your options) with one that you compile locally using c-sources, that’s probably asking for trouble :)
23:27:38 <sebastia2> cocreature: oh MAN that fixed it! Thank you so much
23:28:07 <sebastia2> I have been mystified by a lot of the rules around linking to a C library, seems like the documentation is all over the place
23:29:30 <centril> Does GHC guarantee global uniqueness of instances in the absence of orphan instances, OverlappingInstances, and IncoherentInstances ?
23:29:46 <cocreature> sebastia2: when you want to link to a C library, you need extra-libraries. c-sources is for when you want to compile C files and link against those rather than link against an already compiled library
23:30:24 <centril> cc edwardk since that is your forte :)
23:31:13 <jle`> centril: do you mean without OverlappingInstances and IncoherentInstances ?
23:31:30 <centril> jle`: yes, without those, and without orphan instances
23:31:37 <jle`> note that i don't think OverlappingInstances is a thing people do anymore
23:32:12 <jle`> nowadays i think {-# OVERLAPS #-} is preferred
23:32:13 <centril> jle`: I'm asking for type theoretical purposes :)
23:32:13 <cocreature> well we don’t enable it as an extension anymore but the specific pragmas are definitely still used
23:32:35 <centril> I'm working on an RFC for Rust, so I'm compiling prior art...
23:32:36 <jle`> cocreature: are you going to consider UndecidableInstances ?
23:32:49 <jle`> er, centril
23:33:33 <centril> jle`: Does UndecidableInstances affect the global uniqueness of instances?
23:34:03 <jle`> hm, i'm not sure
23:34:37 <jle`> i fee like it was related to an issue regarding uniqueness that i ran into a few years ago
23:34:40 <centril> But they should be taken into account since AFAIK Rust's trait system is turing complete
23:36:12 <centril> jle`: this blog post: http://blog.ezyang.com/2014/07/type-classes-confluence-coherence-global-uniqueness/  , suggests that Haskell does not guarantee global uniqueness, but it is somewhat unclear if forbidding orphans guarantees it or not
23:37:53 <jle`> you can write instances that aren't unique without any extensions, i think
23:38:26 <jle`> @let class MyClass a where mc :: p a -> String
23:38:27 <lambdabot>  Defined.
23:38:42 <jle`> @let instance Show a => MyClass [a] where mc _ = "showable"
23:38:43 <lambdabot>  Defined.
23:38:50 <jle`> @let instance MyClass [Int] where mc _ = "int"
23:38:51 <lambdabot>  Defined.
23:38:56 <cocreature> with FlexibleInstances you can make an instance for Int and for an arbitrary "a"
23:39:03 <jle`> now [Int] has two possible instances and ghc doesn't complain
23:39:11 <jle`> the only issue comes with using the instances
23:39:16 <cocreature> you’ll get an error when you try to use them without overlapping pragmas but defining them is fine
23:39:55 <jle`> > mc [1::Int]
23:39:58 <lambdabot>  error:
23:39:58 <lambdabot>      • No instance for (MyClass Int) arising from a use of ‘mc’
23:39:58 <lambdabot>      • In the expression: mc [1 :: Int]
23:40:06 <jle`> > mc [[1::Int]]
23:40:08 <lambdabot>  error:
23:40:08 <lambdabot>      • Overlapping instances for MyClass [Int]
23:40:08 <lambdabot>          arising from a use of ‘mc’
23:40:55 <centril> jle`, cocreature: so does that entail that there is global uniqueness once you use instances, but not when defining them?
23:46:34 <cocreature> centril: I guess so although “global uniqueness” seems like a weird term in that case. it just boils down to GHC won’t choose automatically choose an instance if there is more than one in scope
23:46:44 <centril> i.e: absent of orphans, we are ensured that for any constraint 'k T' where 'T' is some type, it always resolves to the same dictionary, no matter how the value of 'T' is chosen?
23:46:47 <cocreature> and avoiding OrphanInstances ensures that you can’- hide instances
23:46:51 <cocreature> *can’t
23:47:11 <centril> or maybe that is coherence...?
23:47:18 <centril> cocreature: ^
23:48:07 <cocreature> yeah I think that’s coherence but I’m not too familiar with the terminology tbh :)
23:48:21 <centril> cocreature: same here :)
23:50:25 <cocreature> centril: I’m curious, what rust proposal are you planning to make?
23:50:50 <centril> cocreature: working on a proposal to allow visibility modifiers on trait implementations
23:51:17 <cocreature> that sounds dangerously close to orphans :)
23:53:37 <cocreature> hm maybe not
23:53:57 <centril> cocreature: these are not modular instances a la Scala / Idris; In my proposal, the coherence check will consider all implementations, irrespective of visibility. But you can hide away an implementation of a trait for a type. If a hidden implementation exists, no other module may define an implementation for it
23:54:33 <centril> the visibility control is mainly for cases where you are not ready to expose facts about your type, but want to use them internally
23:54:49 <centril> it's not for allowing multiple instances
23:55:06 <centril> that is decidedly unsound for Rust since 'unsafe { .. }' is allowed to assume coherence
