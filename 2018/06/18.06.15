00:00:32 <dminuoso> charukiewicz: Dont rely on the generic fromJSON/toJSON implementations.
00:00:47 <dminuoso> Or work with an intermediate type. =)
00:00:59 <tdammers> charukiewicz: my approach with these things is to have 3 sets of types. one set to represent what's in the database, one set to represent API data structures, and one set to represent the actual domain entities
00:01:41 <tdammers> if you try and use the same type for all of them, you tend to get implicit coupling between the DB and the API, and that's going to come back and bite you as your application evolves
00:02:25 <tdammers> you can sometimes get away with just the domain objects though, if your DB and API instances are malleable enough
00:02:39 <charukiewicz> tdammers: the 'domain entities' being the actual 'business logic' that my haskell code works with?
00:03:55 <tdammers> charukiewicz: yes.
00:04:22 <tdammers> business logic == domain logic, same thing. I just prefer the term "domain logic" because not all software is business software ;)
00:08:09 <charukiewicz> so in such an approach, suppose we start at querying the db, you would write toDomainEntity and toApiEntity functions that transform the data to take values of the appropriate types? then I assume you could use the generic (or very close to) toJSON implementation at the end for the API endpoint response.
00:10:16 <tdammers> something like that, yes
00:10:35 <tdammers> but the big advantage is that you no longer need a 1:1 correspondence between result sets, domain objects, and API responses
00:11:22 <tdammers> e.g., you could run multiple queries to get information about one user, combine that into one domain object, and then calculate some more data in other domain objects, and finally assemble an API response that contains only a subset of the user data but also fields from other domain objects
00:12:28 <charukiewicz> makes sense. thank you. and I agree with your point about the 'domain' vs. 'business' logic!
00:18:05 <BalterNotz> q
00:24:30 * hackage prettyprinter 1.2.1 - A modern, easy to use, well-documented, extensible pretty-printer.  http://hackage.haskell.org/package/prettyprinter-1.2.1 (quchen)
00:33:00 * hackage snap-language 0.1.0.4 - Language handling for Snap  http://hackage.haskell.org/package/snap-language-0.1.0.4 (petterb)
00:44:23 <dminuoso> Mmm. What's the proper way to extract the executable from a new-style build for deployment purposes?
00:45:08 <cocreature> dminuoso: "cabal-plan list-bins" is probably your best option atm
00:45:14 <cocreature> (cabal-plan is a separate tool)
00:45:21 <atodorov> hi folks, I have a cabal package (tarball) which is a dependency of another program that I'm building. How can I instruct cabal to use the local tarball if found and fetch the rest via the Internet?   This is part of a test pipeline where I want to make sure changes to the library don't break something in the application. Thanks.
00:53:26 <cocreature> atodorov: sounds like you might be looking for cabal’s optional-packages feature https://cabal.readthedocs.io/en/latest/nix-local-build.html#cfg-field-optional-packages
00:53:35 <cocreature> although that won’t take a tarball, so you’ll have to do the unpacking yourself
00:54:19 <cocreature> but if it’s part of the test pipeline, just fixing the version via some constraint sounds like it might be the better option
00:54:47 <cocreature> you can use "cabal new-freeze" to generate a freeze file that locks all package versions
00:55:17 <Boomerang> Alternatively if you use stack or nix, you should be able to point straight at the local tarball
00:55:50 <Boomerang> For stack: https://docs.haskellstack.org/en/stable/yaml_configuration/#archives-https-or-local-filepath
01:02:30 * hackage data-diverse 4.5.0.0 - Extensible records and polymorphic variants.  http://hackage.haskell.org/package/data-diverse-4.5.0.0 (louispan)
01:09:22 <dminuoso> cocreature: cabal-plan looks great thank you =)
01:19:00 * hackage distributed-fork 0.0.1.3, distributed-fork-aws-lambda 0.0.2.0 (utdemir): https://qbin.io/jews-plugin-6u3i
01:20:09 <dminuoso> cocreature: What is the reason there's no infrastructure to pull the images out anyway? Is that because of the nix mentality?
01:20:31 <dminuoso> Or is it a result of it being beta and missing features?
01:20:32 <cocreature> dminuoso: afaik it’s more a case of “nobody has implemented it” :)
01:20:38 <dminuoso> Ah I see. :)
01:21:39 <cocreature> I suppose eventually "new-install" might be what you should be using for deployment
01:23:18 <dminuoso> It seems like the cabal folks are actively designing new-install at the moment https://github.com/haskell/cabal/issues/4558
01:23:48 <cocreature> yeah, I think it’s a gsoc project
01:28:30 * hackage postmark-streams 0.1.0.2 - Send email via Postmark using io-streams.  http://hackage.haskell.org/package/postmark-streams-0.1.0.2 (petterb)
01:42:30 * hackage bustle 0.7.1 - Draw sequence diagrams of D-Bus traffic  http://hackage.haskell.org/package/bustle-0.7.1 (WillThompson)
01:42:40 <atodorov> cocreature: this looks like what I need so I gave it a try. As far as I can tell from the default settings I just need to unpack the library into the current directory of the program and run cabal install && cabal build. However the log tells me Downloading library, Configuring, etc. So it looks like cabal downloaded the library from Hackage.
01:43:01 <cocreature> atodorov: that feature only works with cabal new-build
01:43:18 <atodorov> I will experiment more with that b/c I'm not sure I'm doing everything correctly. Any hints are appreciated
01:43:56 <cocreature> make sure the path is correct, don’t use "cabal install" and replace "cabal build" by "cabal new-build"
01:54:15 <drets> Is there a function in standard library which gives me the Just first element from the list if it exists, otherwise Nothing?
01:54:45 <cocreature> :t listToMaybe
01:54:46 <lambdabot> [a] -> Maybe a
01:54:49 <cocreature> ^ drets
01:55:35 <drets> Oh, I saw it in hoogle, but the name... couldn't guess that it's the thing, thank you.
01:56:11 <Taneb> drets: it's not the best name
01:56:11 <cocreature> hoogle also shows you the first line of the docs which should be sufficient in this case :)
01:56:31 <drets> I would name it maybeHead. =)
01:56:43 <cocreature> there is headMay in the "safe" package
01:56:55 <dminuoso> drets: there's also pattern matching which depending on the usage might be nicer to read than listToMaybe
02:22:33 <jle`> some people call it safeHead
02:23:47 <dminuoso> listToMaybe has a nice NT ring to it =)
02:25:06 <fendor> > headMay []
02:25:08 <lambdabot>  error:
02:25:08 <lambdabot>      Variable not in scope: headMay :: [a0] -> t
02:25:30 <drets> Cool, next nooby question: I have line 1: maybeScenarioId <- listToMaybe <$> (runPersist pool $ ... line 2: let foo = maybe Nothing (Just . E.unValue) maybeScenarioId. It feels I can refactor `maybe` somehow :thinking_face:
02:26:18 <quicksilver> foo = E.unvalue $> maybeScenarioId
02:26:29 <quicksilver> erm
02:26:36 <quicksilver> foo = E.unvalue <$> maybeScenarioId
02:26:49 <fendor> @let headMay as = if null as then Nothing else Just (head as)
02:26:51 <lambdabot>  .L.hs:166:1: warning: [-Woverlapping-patterns]
02:26:51 <lambdabot>      Pattern match is redundant
02:26:51 <lambdabot>      In an equation for ‘headMay’: headMay as = ...
02:27:05 <fendor> > headMay []
02:27:07 <lambdabot>  Nothing
02:28:16 <drets> quicksilver, cool, that works, can I remove the line 2 completely? and do something with first one?
02:28:53 <jle`> drets: yes, `maybe Nothing (Just . f)` is `fmap f`
02:29:16 <quicksilver> and <$> is just a way of writing fmap as an infix operator
02:29:27 <jle`> you can combine the two lines doing `fmap f . listToMaybe <$> ....`
02:29:28 <quicksilver> (to illuminate the connection between jle`'s answer and mine)
02:29:59 <quicksilver> interestingly it doesn't matter which order you do `fmap f` and `listToMaybe`
02:30:00 <jle`> maybeScenarioId <- fmap E.unValue . listToMaybe <$> runPersist ....
02:30:16 <quicksilver> so `listToMaybe . fmap E.unvalue` would work too
02:30:42 <jle`> yup, because listToMaybe is a natural transformation :)
02:30:53 <quicksilver> :category_theory_high_five:
02:30:56 <drets> jle` thank you works, I tried ((E.unValue . listToMaybe) <$>...) and E.unValue <$> listToMaybe <$> ... and it didn't =)
02:31:15 <jle`> that's a part of the reason why i like the listToMaybe name, because it emphasizes the fact that it's a natural transformation
02:31:35 <jle`> yeah it'd be (E.unValue <$>) . listToMaybe <$> ... if you had to use <$>
02:31:47 <jle`> definitely a lot less readable in this situation heh
02:31:53 <drets> So close, no matter how far =)
02:32:45 <quicksilver> yeah the fmap at two different levels is mildly unaesthetic
02:56:25 <Philonous> Is there an easy way to get the IOErrorType of an IOException ?
02:59:06 <rkrishnan> is "cabal new-run" functional? I have this cabal.project file that has two packages in it (with .cabal file), when I run "cabal new-run foo", all I get is "Up to date". It does not actually run the program.
02:59:23 <cocreature> rkrishnan: which version of cabal are you using?
02:59:42 <rkrishnan> 2.0.0.1 (cabal library is 2.0.1.0)
02:59:50 <cocreature> you need 2.2 for a working new-run
03:00:03 <arahael> What's wrong with this expression?
03:00:05 <rkrishnan> ah, ok, thanks a lot, cocreature. WIll compile it now.
03:00:05 <arahael> \(a, b) -> a / b $ zip [1.1] [2.2]
03:00:34 <arahael> (I expect to see [0.5] as the answer)
03:00:37 <cocreature> rkrishnan: in general if you’re using the new-* stuff you want to make sure you are using the latest version or even run from HEAD
03:00:53 <cocreature> Philonous: how about ioeGetErrorType?
03:01:02 <rkrishnan> cocreature: thanks.
03:01:33 <Philonous> cocreature, Yes, I just saw it. -_- Sorry
03:02:04 <cocreature> arahael: you forgot a "map"
03:02:20 <arahael> cocreature: D'oh. Indeed.
03:02:29 <quicksilver> > \(a, b) -> a / b <$> zip [1.1] [2.2]
03:02:32 <lambdabot>  error:
03:02:32 <lambdabot>      • No instance for (Typeable b0)
03:02:32 <lambdabot>          arising from a use of ‘show_M59217637781609940133003’
03:02:34 <cocreature> arahael: you might also want to use zipWith instead of zip + map
03:03:10 <arahael> cocreature: Ideally, I wanted to have: zip [1.1] [2.2] `something` (\(a, b) -> a / b)
03:03:16 <arahael> cocreature: But I don't knwo what to use for 'something'.
03:03:35 <quicksilver> > (\(a, b) -> a / b) <$> zip [1.1] [2.2]
03:03:37 <lambdabot>  [0.5]
03:04:04 <arahael> quicksilver: Right, but I want a `flip <$>`, if that makes sense.
03:04:09 <quicksilver> it does
03:04:28 <quicksilver> the lens library is full of combinators which work that way around
03:04:41 <arahael> Ah, that must be why they don't show in hoogle (by default)
03:05:09 <cocreature> we even have it in base by now!
03:05:12 <cocreature> :t (<&>)
03:05:13 <lambdabot> Functor f => f a -> (a -> b) -> f b
03:06:00 <cocreature> > zip [1.1] [2.2] <&> (\(a,b) -> a / b)
03:06:02 <lambdabot>  [0.5]
03:06:02 <arahael> Nice, not in my haskell, sadly.
03:06:12 <cocreature> but I’d say that’s still worse than zipWith
03:06:18 <cocreature> > zipWith (/) [1.1] [2.2]
03:06:20 <lambdabot>  [0.5]
03:06:28 <arahael> cocreature: That works with tuples like that!?
03:06:37 <cocreature> :t zipWith
03:06:38 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
03:06:43 <cocreature> it’s basically zipWith + map
03:06:44 <arahael> Ah, very nice.
03:28:35 <maerwald> I think haskell needs a crowdfunded project to fix the tooling mess, especially wrt editor support
03:31:04 <dminuoso> maerwald: Haskell needs developers contributing to tooling instead of complaining about the lack.
03:31:20 <maerwald> what? how would that work without money and time
03:32:09 <maerwald> obviously, it doesn't, otherwise it would have happened already
03:32:54 * quicksilver has observed a lot of time (and probably money as well?) put into tooling and editor support over the last 10 years
03:33:06 <quicksilver> but, well, it's hard to get it right, and it's hard to get things finished
03:33:19 <electrocat> there are many things that are close to the tooling we need
03:33:31 <cocreature> even if you have something that seems finished at some point, the next GHC release will probably break it
03:33:32 <electrocat> we just never get there
03:33:44 <cocreature> or the release of yet another build tool will require updates, …
03:33:55 <maerwald> cocreature: yes, that has to be discussed to, external API shouldn't randomly break anymore
03:34:29 <cocreature> that requires defining what the external API even is
03:34:46 <cocreature> and once you expose the AST which some tooling wants to look at you pretty much have to live with breaking changes
03:35:13 <maerwald> weird, that doesn't seem to be the case in other languages
03:35:21 <maerwald> as in: they don't constantly break the AST
03:35:39 <electrocat> they don't change the language that often as we do :p
03:35:42 <dminuoso> All I want is type information for arbitrary expressions and gathering errors (and correlating them to source code with flycheck).
03:35:50 <Taneb> Haskell is foremost an exercise in language design research
03:35:55 <cocreature> dminuoso: that’s just ghci :)
03:35:58 <maerwald> Taneb: not anymore, no
03:36:13 <cocreature> and ghci has a pretty stable interface
03:36:16 <Taneb> It just happens to be an exercise in language design research that gets used
03:36:33 <dminuoso> cocreature: So I suppose ghcid is finally the answer Ive been avoiding.
03:37:18 <cocreature> dminuoso: or dante if you want something more integrated in emacs
03:37:27 <cocreature> or intero which isn’t much more than ghci for the most part either
03:37:38 <Taneb> maerwald: it's going to be until there are other mainstream general purpose non-strict languages
03:37:41 <maerwald> and doesn't have code completion
03:37:47 <dminuoso> Im not happy with intero, it's way too brittle and requires me to kill it so often..
03:38:12 <cocreature> ghci does have code completion
03:38:14 <dminuoso> And I suspect that intero is somewhat crash happy (since Ive been getting a lot of segfaults after using intero)
03:39:03 <cocreature> % :complete repl 5 "import Data."
03:39:04 <yahb> cocreature: 5 313 "import "; "Data.Array"; "Data.Array.Base"; "Data.Array.IArray"; "Data.Array.IO"; "Data.Array.IO.Internals"
03:39:06 <dminuoso> Mmm dante looks good as a drop-in replacement :)
03:39:13 <dminuoso> intero-light almost
03:39:35 <maerwald> Taneb: it's not really that. It just happens that most people in the haskell community value stable API very little. It's not just GHC, it's also Cabal (supporting multiple versions is an ifdef hell) and others
03:39:49 <maerwald> and so tooling also becomes a mess
03:40:06 <maerwald> you can experiment anything you want in your internal API and do API-backwards compatible additions
03:40:17 <dminuoso> And furthermore, in all fairness what do you compare Haskells tooling to?
03:40:19 <maerwald> it's not that simple "oh, we are research"
03:40:44 <dminuoso> If you compare it to Java it's a bad case because Java has billions of dollars invested to by all kinds of companies all over the planet.
03:40:45 <maerwald> Java, in some areas, is much more research than haskell, because the type system is so extensible
03:40:56 <maerwald> that's a design problem
03:40:58 <maerwald> nothing else
03:42:36 <dminuoso> What non-Java languages have excelling tooling?
03:42:50 <maerwald> Go
03:42:57 <maerwald> for editors (not build system)
03:43:04 <LiaoTao> C++ :^)
03:43:35 <dminuoso> LiaoTao: Are you referring to MSVC?
03:43:57 <maerwald> even clojures tooling seems better
03:43:59 <LiaoTao> I'm being glib again
03:44:05 <LiaoTao> C++ is a flaming mess
03:44:09 <dminuoso> heh
03:44:11 <LiaoTao> MSVC can be nice, though
03:44:21 <dminuoso> It's my experience that tooling for most languages is not really stellar.
03:44:37 <maerwald> I don't think so
03:45:26 <dminuoso> maerwald: What specific "tooling" features do you miss in Haskell that you think is prevalent in other languages
03:45:55 <cocreature> it’s not so much about missing features as it is about Haskell tooling being really brittle
03:46:00 <maerwald> it's not about what I miss, it's that they are constantly broken
03:46:24 <maerwald> they can neither keep up with GHC, nor Cabal
03:46:42 <maerwald> which also shows a cultural problem
03:46:56 <maerwald> library authors don't *care* what they break
03:47:18 <maerwald> "use the old version", pvp 4tw
03:48:46 <maerwald> which is why you are stuck with ghc 7.10 if you want to install ghc-mod (without checking out WIP branches, applying patches etc)
03:50:17 <maerwald> so either this needs a cultural shift, or a very active crowdfunded project
03:52:53 <rkrishnan> cocreature: thanks, new-run works great with cabal 2.2.0.0
04:03:53 <tdammers> the weird thing about Haskell's IDE story is that while in theory, the language offers excellent tooling opportunities, in practice none of them work
04:04:28 <liste> and it's sad :(
04:04:34 <liste> though there's been some progress lately
04:05:00 <liste> with Language Server Protocol
04:05:13 <tdammers> I think part of the reason is our insistence on doing things right
04:05:48 <tdammers> most haskellers aren't keen on solutions that get you 80% there but make the remaining 20% impossible because the abstractions are technically wrong
04:06:48 <tdammers> so for example, you can't really make correct autocompletion for Python, because there is no way of knowing what you'll *really* have in that object you're looking at without actually running the code on the production server
04:07:13 <tdammers> but you can make some educated guesses, and they're usually still much better than nothing, even if they're possibly outright wrong
04:07:24 <dminuoso> tdammers: That summarizes intellisense.
04:07:27 <dminuoso> In all its glory.
04:07:31 <tdammers> yes, pretty much
04:07:48 <quicksilver> on the other hand, C# has this interesting property that it is (very often) possible to read it left-to-right top-to-bottom and have correct type information
04:07:53 <dminuoso> tdammers: Though if thats all you care about, then ctags has you covered already.
04:07:55 <quicksilver> it's like C# is the perfect intellisense language
04:08:20 <tdammers> dminuoso: well, exactly, that's the other reason - we can't get 100%, so instead of settling for 80%, we settle for a more predictable 50%
04:08:36 <tdammers> quicksilver: in all fairness, C# was designed with intellisense in mind
04:11:35 <quicksilver> tdammers: and vice versa
04:12:22 <quicksilver> tdammers: giving developers powerful tools was absolutely a key objective of that whole process. And that particular company has a lot of tool expertise.
04:13:08 <quicksilver> powerful <*> (combinators `applied` infix) need a different model.
04:14:19 <dminuoso> quicksilver: That's an interesting consideration. In a way it's easier to create tooling for a language that has an artificial limit on the abstractions available. That is if `classes` are all the whizz of your language and the type system is rigid and not extensible, then the tooling gets easy.
04:14:41 <dminuoso> Because you force the users to do abstractions within those restrictions, giving rise to "patterns" in the sense of GoF.
04:15:36 <cocreature> dunno, I don’t think the problems with Haskell’s tooling are caused by the restrictions or lack thereof in the language
04:16:00 <dminuoso> Im just suggesting it might at the very least be one factor
04:16:10 <quicksilver> cocreature: I don't think it's the whole story but I do think it's a factor.
04:16:25 <cocreature> I think it’s a factor that comes into play at a much later point
04:16:53 <dminuoso> Also there's the part that in case of C# the language implementation and IDE are not separate product - they are one product coming from the same vendor.
04:16:55 <cocreature> our tooling breaks because of our build tools and the GHC api are changing
04:17:13 <cocreature> not because you can do profunctor lenses
04:17:18 <dminuoso> In the "open world" things are much uglier when A) gives you the compiler, B) gives you a build chain, C) gives you an editor and D) tries to glue everything together
04:17:47 <dminuoso> cocreature: But why is the GHC API changing so much?
04:18:17 <cocreature> sure language changes are a problem but you can change a language that’s simple as well
04:18:57 <cocreature> and I’d say that problem would be solvable if we would agree on what the public interface of the GHC API is even supposed to be. for now GHC exposes pretty much everything so people use everything and complain when it breaks
04:19:35 <quicksilver> for the syntax and type-checking problem, it would nice if there were public APIs for those two things
04:19:43 <cocreature> a significant part of the complexity in ghc-mod and the reason why it doesn’t work with new-build is just getting information out of your build tool
04:19:45 <quicksilver> concrete syntax tree and types
04:20:09 <quicksilver> and then new GHC features would 'have to' include corresponding updates to those two APIs (ASTs)
04:20:14 <cocreature> for types, you have ghci and for the syntax tree there is a gsoc project this year
04:20:32 <quicksilver> does ghci have a machine-readable type ?
04:21:27 <cocreature> dunno, but most of the tooling just seems to present it to users so I’m not sure the fact that it’s machine readable matters for the tooling that we have to day (ofc you can definitely build tooling that does inspect the type but that’s the next step)
04:23:30 <cocreature> my point is the problems with our tooling are at a much lower level than the one where the complexity of the language comes into play
04:25:01 <arkaros> cocreature: Just out of interest. What is the main paint-points that you think that the haskell tooling has?
04:25:52 <cocreature> ime the interaction with the build tools is the most annoying part
04:26:36 <arkaros> So how we compile the project and such?
04:27:24 <cocreature> every tooling that uses the GHC api must figure out the arguments that it passes to ghc, that involves parsing the cabal file, figuring out package databases, …
04:28:07 <cocreature> if you actually want your tooling to work for all build tools that a significant portion of Haskellers use you need to get this right for at least cabal, cabal new-build, stack and nix
04:30:16 <dminuoso> Lets see if I can run `cabal new-build --only-depenencies` with everything but the .cabal file missing, and then copy the project into the directory and build it =)
04:30:23 <dminuoso> This is going to be interesting
04:31:08 <arkaros> Hmm it feels like a lot of languages have issues with the build tools and that a lot of languages have their own custom implementation of how to do builds.
04:31:37 <tdammers> quicksilver: the vice-versa case is kind of obvious - of course you write a smart autocompleter to match the target language; but designing the language so that it is an easy target for a smart autocompleter is kind of an intriguing idea
04:32:55 <Jinxit> yeah that's what i was worried about
04:32:57 <Jinxit> w/c
04:33:01 <dminuoso> arkaros: that's how MS does things: they give you the compiler, the IDE and build tools - all in one package
04:33:22 <quicksilver> tdammers: yes, and you can see how it informs their new features to.
04:33:39 <quicksilver> tdammers: "how will this new feature integrate into our refactoring tools and our code sense tools?"
04:33:56 <maerwald> liste: unfortunately, the most fundamental feature of LSP haskell doesn't work: type of arbitrary expressions
04:34:00 <quicksilver> tdammers: whereas in a heterogenous environment the answer to that double question is always "It will break them. All of them."
04:34:02 <maerwald> at least not in vim (supposedly in VS code)
04:35:00 <maerwald> you can only get type of identifiers
04:35:02 <maerwald> which is pretty boring
04:36:00 * hackage wai-route 0.4.0 - Minimalistic, efficient routing for WAI.  http://hackage.haskell.org/package/wai-route-0.4.0 (romanb)
04:36:22 <arkaros> dminuoso: Yeah sure but it feels like rather than using one of the existing build tools all languages sort of implement their own instead of building on existing and quite functional solutions. My knowledge in this area is way too lacking to actually argue for this point but it feels sort of like languages reinvent the wheel in order to hava  build system written in the language currently used.
04:37:23 <arkaros> Like is there a reason why haskell couldn't just be built using gradle, for example?
04:37:31 <tdammers> quicksilver: indeed. it's a tradeoff.
04:38:29 <maerwald> gradle? Please :>
04:38:49 <arkaros> Just throwing it out there.
04:39:18 <gonz_> maerwald:  The reason type of arbitrary expression doesn't work in neovim with HIE, for example, is because it fails on getting docs for the selection
04:39:32 <dminuoso> arkaros: One of the driving thoughts of Haskell is "everything out there sucks and is doing it wrong" (well maybe not as sharp..)
04:39:33 <maerwald> the only universal tool out there are Makefiles and theoretically you can use that for your haskell project, but it might be hard to really have useful abstraction (do you use cabal sandbox, new-repl or stack?)
04:39:47 <gonz_> and it doesn't try to salvage the error it gets for docs with showing the type
04:39:59 <gonz_> The language server analyzes the type and sends it back just fine
04:40:50 <gonz_> You select `writeToFile filename` and do show type on it, it gets the type but also tries to fetch docs for "writeToFile filename"
04:41:08 <gonz_> It's not a language server issue, but a client side issue
04:41:30 <maerwald> so I'm back to using plain ghc-mod
04:41:45 <maerwald> whatever you try, for some reason it doesn't work...
04:42:09 <maerwald> at this point, haskell fits very well in the unix ecosystem
04:42:10 <maerwald> :P
04:42:23 <Ariakenom> Feel like I need to link SPJ's https://www.microsoft.com/en-us/research/uploads/prod/2018/03/build-systems.pdf
04:42:35 <arkaros> maerwald: Sounds like a quite a dark realization. "whatever you try it doesn't work"
04:42:36 <quicksilver> arkaros: all build tools are horrible and broken. They all fail to solve the hard problems of dependency management (some of them also fail to solve some other easy problems)
04:42:44 <gonz_> The correct way for neovim-LanguageClient to do it would be to only get docs for the thing at point, but do expression on the entire selection, which is what VSCode does
04:42:46 <maerwald> Ariakenom: waaat, the first sentence is already wrong :>
04:42:53 <maerwald> make is neither big, nor complicated
04:43:01 <quicksilver> arkaros: whenever a new language ecosystem springs up, people in that community believe that they can do better :)
04:43:02 <maerwald> autotools is
04:44:04 <Ariakenom> maerwald: make gets complicated
04:44:14 <Ariakenom> generating makefiles | recursive makefiles
04:44:17 <Ariakenom> ghah
04:44:21 <maerwald> generating?
04:44:48 <Ariakenom> yes, terrifying
04:44:56 <maerwald> how is that related to make
04:45:07 <maerwald> that's like saying "it's hard to generate haskell code"
04:45:08 <quicksilver> it's relative. Make is big and complicated relative to the core problem you want it to solve.
04:45:15 <quicksilver> but it's a complex discussion.
04:45:29 <maerwald> make is annoyingly simple
04:45:41 <Ariakenom> make is too bad at solving the issue so you need to generate makefiles, which has problems
04:45:41 <maerwald> which is why we came up with cancer like autotools
04:45:59 <maerwald> yes, it is simple, not complicated
04:46:05 <Ariakenom> eh
04:46:22 <Ariakenom> it's simple like brainfuck is simple. if you try to use it to solve a problem its complicated.
04:46:45 <maerwald> simple tools are usually like that
04:47:35 <Ariakenom> whether to call it itself simple is just a matter of phrasing.
04:47:53 <maerwald> it's a property
04:48:33 <maerwald> although, this is probably funny http://okmij.org/ftp/Computation/#Makefile-functional
04:49:16 <maerwald> maybe we can implement haskell in make
04:51:15 <juri_> i still think in makefiles. my haskell software comes with a Makefile.
05:00:33 <zincy> how do I drop a the elements within a list given a list of indices to drop at
05:01:12 <juri_> you create a new list, without the element.
05:02:02 <cocreature> zincy: zip the list with the indices and then filter based on whether the index is in the list
05:02:16 <cocreature> zincy: but tbh that sounds like something for which you might want to use Data.Map rather than a list
05:03:26 <zincy> thanks
05:05:32 <zincy> https://lpaste.net/189407065616154624
05:05:53 <zincy> So I am stuck on how to get this algorithm to work.
05:07:04 <zincy> Given a list of players and a list of cards if a playerState is In then the player should be given two cards from the deck of cards. The end result is a tuple where the first element are the players and the second element is the cards remaining in the deck after the dealing process
05:08:23 <zincy> In that snippet the correct players are given the correct cards but what should be the remaining deck of cards is in fact just the original deck of cards. However as you know the intersection of the player cards and remaining cards should be empty
05:13:30 * hackage bgmax 0.2.0.3 - Parse BgMax-files  http://hackage.haskell.org/package/bgmax-0.2.0.3 (petterb)
05:21:30 <quicksilver> zincy: yes, you concat the entire chunkedDeck at the end
05:21:38 <quicksilver> so you do indeed get back the whole deck
05:22:14 <quicksilver> also note that if one your players isn't In (perhaps he's Out?) then his two cards still get skipped
05:22:22 <quicksilver> don't think you want to use zipWith here
05:24:00 * hackage pidfile 0.1.0.3 - Run an IO action protected by a pidfile  http://hackage.haskell.org/package/pidfile-0.1.0.3 (petterb)
05:24:47 <zincy> quicksilver:  correct we dont give players that are Out any cards
05:25:07 <zincy> im not sure what to use instead of zipwith
05:31:50 <hexagoxel> :t mapAccumL
05:31:52 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
05:31:57 <hexagoxel> zincy: ^
05:32:37 <quicksilver> zincy: I would personally rewrite that code in a more 'imperative' style
05:32:56 <quicksilver> using a state monad to handle the changes to the player states
05:33:00 <quicksilver> and returning the leftover deck
05:33:03 <zincy> hexagoxel: cool!
05:33:32 <zincy> quicksilver: I was thinking about that ... the functional style is prettier though isnt it if possible
05:33:57 <zincy> the imperative version in the state monad would probably be more performant
05:34:05 <quicksilver> nope
05:34:12 <quicksilver> the state monad *is* the functional style
05:34:17 <quicksilver> it's just a different way of writing it
05:34:34 <quicksilver> the state monad is just a way to use monadic notation to construct functions (s -> (a,s))
05:34:35 <zincy> its a functional style *emulating* an imperative style right
05:34:51 <maerwald> it doesn't really feel functional, except for haskellers maybe
05:35:02 <maerwald> I would rather describe it "monadic style"
05:35:16 <maerwald> not many other functional languages use that style, so "functional" is kinda far-fetched
05:35:48 <zincy> maerwald: that is what I thought too I guess functional is a bit of a fuzzy term though
05:36:24 <maerwald> it's not necessarily fuzzy, except when people stuff things like "purity" into it
05:36:52 <zincy> is that people people conflate evaluation and executon of haskell programs
05:37:04 <Ariakenom> or first class functions
05:37:05 <maerwald> they conflate functional with purely functional
05:37:09 <hexagoxel> for learning purposes, or before one thinks of mapAccum, there always is plain recursion.
05:37:26 <pspace> hi everybody can you hear me?
05:37:49 <zincy> whats the difference between functional and purely functional
05:38:14 <zincy> cant hear you :P
05:38:21 <pspace> :D
05:38:42 <maerwald> zincy: functional is just "based on lambda calculus", which is very broad, not saying much about evaluation properties
05:39:14 <zincy> People call javascript functional
05:39:23 <maerwald> is it based on lambda calculus?
05:39:26 <zincy> because functions are first class
05:39:47 <zincy> maerwald: Its pure lambda calculus all the way down
05:39:56 <maerwald> then it's certainly functional
05:40:02 <zincy> haha
05:40:41 <pspace> purly functional is without any global state and effectless/side effects in monads
05:40:50 <maerwald> nah
05:40:50 <zincy> I always thought the "if it has first class functions it is a functional lang" was always a loose criteria since nearly every lang has that
05:40:51 <dminuoso> pspace: Nope
05:41:04 <dminuoso> pspace: Haskell had side effects long before monads were even known to programmers.
05:41:15 <pspace> ok than i am sorry
05:41:19 <zincy> haskell does have side effects right?
05:41:24 <dminuoso> pspace: Purely functional only means that your functions are referentially transparent.
05:41:27 <maerwald> zincy: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.27.7800&rep=rep1&type=pdf
05:41:28 <zincy> They are just controlled
05:41:53 <dminuoso> zincy: a language without side effects is not going to be a very useful one
05:42:01 <maerwald> purely functional means that call-by-name, call-by-need and call-by-value are weakly equivalent
05:42:30 <zincy> I think john carmack needs to read this he said you can do functional programming in C++
05:42:41 <maerwald> functional programming != functional language
05:42:47 <maerwald> and indeed, he is right
05:42:49 <dminuoso> maerwald: what does the evaluation model have to do with being purely functional?
05:42:52 <zincy> ahhh
05:42:54 <maerwald> dminuoso: see the link
05:43:55 <zincy> What is this notation
05:43:55 <zincy> M; N; L 2 Term ::= x j x:M j MN j n j M + N
05:44:10 <dminuoso> maerwald: Thats a necessary but not sufficient definition according to the paper.
05:44:43 <maerwald> dminuoso: what do you mean?
05:45:50 <zincy> Would I be correct if I said the lambda calculus was a system of compution based on unary functions
05:46:03 <thongpv3> Hello everybody, I'm new to Haskell
05:46:09 <maerwald> dminuoso: think of it this way, when the evaluation strategy "doesn't matter", then it cannot have "side effects", right? (that's a very fuzzy interpretation, but...)
05:47:21 <maerwald> also note "weakly equivalent", because of laziness
05:47:26 <thongpv3> What is good book for learning haskell
05:47:26 * hexagoxel might consider "side effects" versus "effects"
05:47:42 <dminuoso> thongpv3: what background do you have in programming and functional programming?
05:47:56 <maerwald> hexagoxel: the problem is that "return a value" is also considered an "effect" for most people
05:48:18 <zincy> thongpv3: https://www.amazon.co.uk/Programming-Haskell-Graham-Hutton/dp/1316626229/ref=sr_1_1?ie=UTF8&qid=1529066864&sr=8-1&keywords=hutton+haskell
05:49:53 <thongpv3> I'm good at C++, I know what is algebraic data type, pattern matching, concept, first class function
05:50:14 <dminuoso> thongpv3: Are you experienced with any ML type of languages?
05:50:26 <thongpv3> No
05:50:44 <dminuoso> thongpv3: Curious, where does your ADT and pattern matching experience come from?
05:51:15 <thongpv3> from C++ variant, optional.
05:52:03 <nitrix> thongpv3: My typical recommendation is http://haskellbook.com/. The author went through a lot of efforts to consolidate all the material scattered online in an approachable way, regardless of your background.
05:52:22 <thongpv3> I know litte of template meta programming in C++ (partial template specialization is look like pattern matching, concepts is looklike typeclass)
05:52:22 <zincy> does anyone else find haskelbook way way too slow
05:52:30 <dminuoso> thongpv3: CIS194 might be suited to you, it's a bit dense and has good excercises.
05:52:51 <dminuoso> zincy: It's targeted towards beginners to programmers.
05:53:09 <matsurago> I found "Get Programming with Haskell" quite useful with good examples.
05:53:17 <zincy> hmm I wouldnt call myself advanced
05:54:04 <nitrix> zincy: I prefer that it holds your hand, with examples and assignments that you must complete on your own, rather than skimming material too fast and creating an opportunity for the reader to think they grasp the concepts when they don't really.
05:54:21 <maerwald> zincy: the proprietary book?
05:54:23 <dmwit> zincy: That notation is BNF. It says that in the future, they plan to use "M", "N", and "L" as metavariables for the syntactic category they're defining there, and that the syntactic category includes five syntactic forms.
05:54:46 <maerwald> I even find lyah too slow
05:54:51 <zincy> maerwald: whats that?
05:54:54 <dmwit> zincy: I find your description of the lambda calculus as "based on unary functions" kind of misses the point but isn't technically incorrect.
05:54:57 <maerwald> something you shouldn't read
05:55:02 <dminuoso> thongpv3: Did you have any contact with the C++ ISO standard?
05:55:08 <zincy> nitrix: The exercises are great
05:55:31 <maerwald> I want: 1. core concept, 2. motivation, 3. one use case, 4. exercises
05:55:34 <maerwald> no BS, no blah
05:55:39 <matsurago> Well, I would definitely not recommend LyaH
05:55:45 <dmwit> maerwald: That is why I loved the Gentle Introduction.
05:55:54 <zincy> maerwald: Yes
05:55:55 <dminuoso> +1
05:55:56 <dmwit> maerwald: Straight to the point, no BS. I also couldn't stand LYAH for exactly the same reasons.
05:55:58 <matsurago> LyaH was a reason I didn't learn Haskell for long long time.
05:56:14 <zincy> I feel like whoever wrote haskelbook has very little actual writing experience
05:56:19 <thongpv3> @dminuoso no, but I keep track at C++
05:56:19 <lambdabot> Unknown command, try @list
05:56:19 <maerwald> haha
05:56:20 <zincy> *haskellbook
05:56:26 <dmwit> ?where gentle
05:56:26 <lambdabot> http://www.haskell.org/tutorial/
05:57:20 <dminuoso> thongpv3: You might find CIS194 to your liking. You should, regardless of what learning resource you pick, keep a copy/link to the Haskell 2010 report at hand. It's for the most part easily readable and can often help illuminate things.
05:57:33 <dmwit> thongpv3: (And if you don't mind separating the process of learning the language from learning the libraries, I still recommend the Gentle Intro for learning the language. It is out of date when commenting on the libraries, though.)
05:57:51 <dminuoso> The gentle introduction just doesn't teach you any functional programming at all.
05:58:17 * dmwit shrugs
05:58:19 <dmwit> Worked for me.
05:58:27 <nitrix> Haskell is indeed very terse with quite overwhelming abstractions when you're new to all this. I think it's good that it's slow. Otherwise you have the illusion that you understand, but you still fumble for weeks, trying to put the pieces together.
05:58:39 <dminuoso> dmwit: worked for me too, but I had a year of previous programming with immutable data and pure functions. :)
05:58:44 <thongpv3> I'm begining read Real World haskell, and completed 3 chapter, should I continue
05:58:47 * dmwit didn't
05:58:52 <dminuoso> thongpv3: RWH is very old and outdated.
05:59:08 <zincy> nitrix: The longwinded explanations didn't help test my understanding
05:59:11 <dmwit> My path was C -> C++ -> Python -> Gentle Intro. I had no prior experience with FP or immutability.
05:59:15 <dminuoso> dmwit: In the end learning is a highly individual thing.
05:59:21 <thongpv3> So I should pick Programming in Haskell.
05:59:25 <dminuoso> You should pick resources according to your needs and experience. :)
05:59:34 <dmwit> Can't argue with that.
05:59:45 <nitrix> You also have the option of learning by osmosis, doing a pet project and asking questions here :)
05:59:52 <pspace> i am doing C++ as main language and scala and now haskell as fun languages for side projects
05:59:54 <nitrix> We're a slow medium though.
06:00:07 <zincy> nitrix: My favourite way of learning
06:00:14 <dmwit> (Then again, the start of my path was "how do I create fractals? here's a book on how to do it in C", so recursion was natural and iteration the learned thing for me. =P)
06:00:28 <matsurago> thongpv3: have a look at that: https://www.amazon.com/Get-Programming-Haskell-Will-Kurt/dp/1617293768
06:00:45 <hc> hi all, how to set the content-length header in servant?
06:01:08 <thongpv3> Thankyou :)
06:01:50 <alfa> !list
06:01:51 <alp> hc, isn't it set automatically?
06:04:05 <hc> not when returning a wrapped lazy bytestring
06:04:19 <hc> anyway, i'll try a hack to fix an urgent bug
06:05:07 <pspace> i am currently having a project where i am using Data.Fixed. does anyone know how to construct a Fixed from a string?
06:06:04 <nitrix> There's a Read instance, if that helps.
06:08:17 <nitrix> > read "42" :: Fixed E9
06:08:19 <lambdabot>  error:
06:08:19 <lambdabot>      Ambiguous occurrence ‘Fixed’
06:08:19 <lambdabot>      It could refer to either ‘Data.Fixed.Fixed’,
06:08:25 <nitrix> > read "42" :: Data.Fixed E9
06:08:28 <lambdabot>  error:
06:08:28 <lambdabot>      Not in scope: type constructor or class ‘Data.Fixed’
06:08:28 <lambdabot>      Perhaps you meant one of these:
06:08:42 <dmwit> > read "42" :: Data.Fixed.Fixed E9
06:08:44 <lambdabot>  42.000000000
06:08:44 <pspace> nitrix: thanks a lot
06:11:25 <dminuoso> For the sake of docker caching Im thinking about keeping a "fake" cabal file that lists mosts of the dependencies. Is this sane?
06:11:41 <dmwit> Hm. Not sure I like this Read instance.
06:12:23 <nitrix> dmwit: "42.09" :: Fixed E1 truncates to "42.0"
06:12:24 <dmwit> ?let data B2
06:12:25 <lambdabot>  Defined.
06:12:33 <dmwit> ?let instance HasResolution B2 where resolution _ = 4
06:12:34 <lambdabot>  Defined.
06:12:36 <Geekingfrog> dminuoso: I believe that what stack does on the latest versions. There is a (big) images with lots of already compiled dependencies
06:12:50 <dmwit> > (0.25 :: Data.Fixed.Fixed B2, read "0.25" :: Data.Fixed.Fixed B2)
06:12:53 <lambdabot>  (0.3,0.0)
06:13:25 <dmwit> nitrix: Explain this. It is not truncation, because 0.25 is exact.
06:13:53 <nitrix> . . .
06:14:11 <dmwit> I mean, I know why it behaves this way, because I can just look at the code and see. But I don't like it.
06:14:26 <nitrix> It just caught me.
06:14:42 <dminuoso> Geekingfrog: Mmm it looks a bit different from what Im doing
06:15:50 <dminuoso> Geekingfrog: Though I cant see what registry.gitlab.fpcomplete.com/fpco/default-build-image:1954 actually is.
06:15:59 <dminuoso> https://gist.github.com/dminuoso/6386dad71d04ec194552e047cdf89d49 this is what Im doing right now
06:17:14 <nitrix> dmwit: Shouldn't the resolution be powers of 10?
06:18:01 <dmwit> Why?
06:18:02 <cocreature> dminuoso: I feel like a new-freeze file would be perfect for this but I’m not sure if cabal has a command for “install all packages in this freeze file”
06:19:20 <dmwit> nitrix: (N.B. The Read instance even includes a comment saying they want to deal with e.g. `resolution _ = 128`, so I know the answer to that is no. I'm just playing Socrates here.)
06:20:21 <dmwit> nitrix: And I will note that if they just used all the digits of precision instead of first truncating the String, then truncated the result, they would not have this problem.
06:20:32 <dmwit> > (2 / 10 :: Fixed B2, 25 / 100 :: Fixed B2)
06:20:34 <lambdabot>  error:
06:20:34 <lambdabot>      Ambiguous occurrence ‘Fixed’
06:20:34 <lambdabot>      It could refer to either ‘Data.Fixed.Fixed’,
06:20:39 <dminuoso> cocreature: The problem is that when you add a single dependencies, that will suddenly bump up build time from 5 minutes to an hour.
06:20:48 <dmwit> > (2 / 10 :: Data.Fixed.Fixed B2, 25 / 100 :: Data.Fixed.Fixed B2)
06:20:50 <lambdabot>  (0.0,0.3)
06:21:06 <dminuoso> So I want to kind of "prebuild" a list of expected dependencies in a previous layer, relying on new-build sharing compilations
06:21:08 <nitrix> dmwit: It's in base though. I feel like this should be fixed (no pun intended, okay maybe intended).
06:21:21 <dmwit> I agree, it seems simply broken.
06:21:27 <dmwit> And should be fixed.
06:24:04 <cocreature> dminuoso: if you want non-shitty caching I wouldn’t rely on docker’s caching at all. just cache some external directory and mount that in your docker build
06:24:17 <cocreature> or use nix for caching
06:24:56 <dminuoso> cocreature: Not too keen to start learning nix because I've been investing a *lot* of hours on Haskell and other things - it's time we start getting productive so..
06:24:56 <dminuoso> For the moment anyway.
06:25:23 <dminuoso> cocreature: What would you cache for new-build exactly?
06:26:22 <cocreature> dminuoso: just cache ~/.cabal/store and mount that in your docker image
06:26:33 <cocreature> that’s pretty much how stack build --docker works as well
06:26:49 <dminuoso> Oh haha. It cant be that easy :)
06:27:02 <pspace>  how to split my project into different files? should I do a file with all fatatypes and one with all instances? or one file for each datatype and its instances?
06:27:24 <pspace> what is best practice for splitting?
06:27:33 <cocreature> dminuoso: anything specific you’re worried about?
06:32:51 <maerwald> pspace: to avoid import cycles I often do a module with data types, but generally I would structure your files according to your architecture
06:33:06 <maerwald> if you don't know how to structure them, chances are good you haven't thought about architecture yet :P
06:33:29 <pspace> yeah i havent, it is just a small project
06:33:39 <pspace> it's my first haskell project
06:34:05 <maerwald> then just play around, don't care about "best practices". You'll probably run into one or another problem anyway
06:36:33 <ggVGc> the best practice is to get code that runs so you can see how shit it is and fix it!
06:36:46 <ggVGc> <-- professional software dev
06:37:06 <maerwald> yeah, prototyping 4tw
06:37:21 <ggVGc> google gets it, everything is a prototype
06:37:22 <maerwald> people talk about TDD and all that crap, but only prototyping works
06:37:22 <ggVGc> forever :(
06:37:31 * ggVGc is still prototype
06:37:49 <maerwald> yeah, occasionally we ship the prototype xD
06:37:54 <cocreature> ggVGc: take care that nobody accidentally throws you away and starts a new prototype!
06:38:04 <ggVGc> can I share the sad story of a few months ago when I prototyped a trading bot in haskell, fucked it up, and now it's in Elixir and running much better
06:38:17 <ggVGc> cocreature: I've got too much technical debt for that
06:38:24 <dminuoso> cocreature: Thanks. You just single handedly "unconvoluted" my CI setup. ;-)
06:38:26 <maerwald> I always prototype in python, then argue "this will be much cleaner in haskell" xD
06:38:50 <cocreature> dminuoso: heh, glad I was able to help :)
06:39:46 <ggVGc> my story wasn't completely accurate, the part that I thought haskell would be good for were actually really good in the haskell version. But the other IO-heavy stuff got completely messed up, partly because of me not completely understanding what I wanted, but also because haskell wasn't supporting the use case well. The current elixir version is really good at those parts, but actually a lot worse at the
06:39:52 <ggVGc> parts that were good in the haskell version..
06:40:00 <ggVGc> so I'm actually about to integrate half of my old haskell version into this thing
06:40:04 <ggVGc> to get best of both worlds
06:40:18 <cocreature> IO-heavy stuff is the best part of Haskell!
06:40:22 <maerwald> maybe rewrite it in clojure, to get a 3rd opinion :>
06:40:32 <maerwald> cocreature: how so
06:40:45 <ggVGc> cocreature: I really needed fault tolerance and a lot of async processes, and good interactive usage
06:40:46 <maerwald> exceptions are awful :/
06:40:55 <ggVGc> I got a lot of that for free in elixir
06:41:09 <zincy> hexagoxel: Thanks for mapAccumL it worked like a dream!
06:41:16 <ggVGc> but the defining of strategies and testing them were great in haskell
06:41:19 <ggVGc> and it's crap in the elixir version
06:41:20 <ggVGc> so...
06:41:21 <ggVGc> :(
06:41:27 <cocreature> fair enough, although at least the “lots of async processes” part is usually great in Haskell as well
06:41:28 <ggVGc> but it turns out that the fault tolerance part was more important
06:41:36 <ggVGc> but had to learn that though the first prototype
06:41:58 <maerwald> yeah, correctness is not always what you want, when it crashes your program :>
06:42:29 <ggVGc> the point of the story is, the only way for me to realise elixir was a better fit and why it was, was to build a useable thing in haskell first to see how it sucked
06:42:38 <ggVGc> so, fastest way to something you can use is always the best practice
06:42:39 <ggVGc> imo
06:43:13 <maerwald> for what? delivering features or writing good software
06:43:35 <ggVGc> for creating any kind of software
06:43:56 <maerwald> well, I don't believe in gradual prototyping. I actually delete my prototypes and start from scratch
06:44:12 <ggVGc> if you need to deliver a feature, it needs to built in the fastest way possible so you can see in which ways you misthought about the feature
06:44:14 <zincy> maerwald: haha
06:44:22 <maerwald> and for the non-prototype I don't care how fast I finish it
06:44:35 <ggVGc> maerwald: ah yeah, same. usually the 3rd version is where I start getting something that actually fulfills what I originally imagined
06:44:54 <ggVGc> I'm in my 3rd or 4th version of my sequencer software now, and it started being actually useful to me only about a year ago
06:44:59 <ggVGc> after doing it off and on for several years
06:45:02 <zincy> Does anyone else get stuck in the loop of finding the perfect solution and then three hours go by and you havent written a line of code and are no closer to a working feature
06:45:16 <zincy> its a bad habit i have
06:45:19 <maerwald> zincy: you fit percectly into haskell culture then
06:45:21 <maerwald> xD
06:45:30 <zincy> :x haha
06:45:32 <maerwald> maybe you should rather write Go to get rid of that habit
06:45:33 <ggVGc> zincy: sometimes, but not as much anymore,  because I'm acutely aware of it and have some tactics to break free
06:45:38 <zincy> hahaha
06:45:39 <ggVGc> but it requires direct action
06:45:41 <maerwald> because in Go you cannot have a perfect solution anyway
06:45:48 <zincy> I actually have a friend which insists I do just that/1
06:45:52 <maerwald> it's crap either way, but it run nicely
06:46:11 <ggVGc> maerwald: it's nice, you never have to actually run your shit and deal with your problems. Just watch those nice compiler successes
06:46:18 <ggVGc> and your beautiful ADTs and type specs
06:46:21 <dminuoso> zincy: I find that whenever I fall into the pattern that I need to reapproach it. Sometimes I flip the "top-down/bottom-up" switch and that does the trick.
06:47:02 <zincy> dminuoso: what do you mean?
06:47:08 <ggVGc> zincy: one trick for me is to walk away a but, then come back as a user and just sit down and use my software, and instantly see "well, this just isn't possible to use" and then do the smallest thing to fix that specific annoyance
06:47:12 <ggVGc> and then I'm on a roll again
06:47:22 <dminuoso> zincy: So in software sometimes you have a top-down approach where you try to start writing from general code towards specific code.
06:48:24 <zincy> ggVGc: Yes that too I need more breaks
06:48:39 <ggVGc> zincy: well, that's part of it. But also, switching perspective to being the user
06:48:42 <ggVGc> works well for me
06:50:28 <zincy> ggVGc: you mean thinking about what end result the difference will make to the user?
06:51:05 <ggVGc> zincy: no, literally being the user
06:51:13 <ggVGc> not thinking about what it would be like
06:51:22 <zincy> ggVGc: Oh so just use the app
06:51:29 <ggVGc> yeah, or whatever it is you're building
06:52:24 <ggVGc> you will either see 1. I can not actually use the app (I need to do the smallest thing, to get anything I can start up and use) or 2. Doing this thing is really awkward, why doesn't it work this way (make it work that way). or 3. This feature is just actually broken(bug) (fix the bug)
06:52:33 <ggVGc> zincy: this usually instantly gets me on track
06:52:50 <ggVGc> but, I also only make software (personally) that I am the primary user of
06:52:55 <ggVGc> I find anything else really difficult
06:53:07 <ggVGc> at work it's not a problem since there's always well defined needs
06:53:23 <ggVGc> e.g atm I'm writing backend for a tool, and the tool has certain needs, and either I fulfill them or I don't
06:53:54 <ggVGc> but I think when you get stuck in that design loop, it's because you've lost the focus of what you're trying to build, and what you want to be able to do wit hit
06:53:59 <ggVGc> so you end up focusing on the wrong things
06:54:07 <ggVGc> well, this is my personal experience anyway
06:54:21 <zincy> ggVGc: That is simply the best way of allocating tasks for personal projects to yourself
06:55:25 <zincy> Thats the dream in the business world - the developer is the user
06:55:58 <zincy> I read in a book that John Carmack just built games he would enjoy playing
06:55:59 <ggVGc> yeah but that's never the actual case. I think that's fine though. You just need to find a way to stay focused on what you need to deliver, rather than how it should be implemented
06:56:07 <ggVGc> so your drive is to get it done as soon and as simple as possible
06:56:14 <ggVGc> rather then being stuck in building a golden house
06:56:26 <ggVGc> (that will turn out to be a rotten house anyway)
06:56:41 <zincy> Yeah its an ideal case
06:57:00 <zincy> Trading bot would have been fun though
06:57:17 <zincy> I would have thought elixir and haskell would be equally great for it
06:57:51 <zincy> Maybe you just made your first prototype in haskell and then the second gen prototype happened to be in Elixir when you had a clearer idea of what you wanted
06:57:54 <ggVGc> they litereally each fill half of the story perfectly, I've found
06:57:58 <ggVGc> and now I've built both versions
06:58:06 <ggVGc> and will pick the good part from both and marry them
06:58:08 <ggVGc> is the plan anyway
06:58:52 <zincy> right tool for the job
06:59:01 <ggVGc> zincy: no the fault tolerance of erlang is really actively helping me not write a load of code I would have needed to write in the haskell version. And which is why the haskell version wasn't useful, since I didn't write that code
06:59:26 <ggVGc> but it's a lot harder and less safe making strategies for the elixir version, so I want to use what I wrote in haskell for that
06:59:27 <zincy> how does fault tolerance work in a trading bot
06:59:56 <ggVGc> well, for example, I have a websocket feed that dies 2-3 times per day. And it's a non-issue in the elixri version since it just crashes the process and restarts and reconnects
06:59:57 <zincy> As in what would be considered a fault?
07:00:00 <ggVGc> and I didn't have to do anything at all
07:00:07 <ggVGc> it's a bigger problem to handle in the haskell version
07:00:37 <zincy> What did you have to do in the haskell version?
07:00:43 <ggVGc> also, I sometimes get timeouts from the REST APIs, or hit rate limits, and that also ends up being a non-issue
07:00:49 <ggVGc> rather than something I have to deal with
07:01:20 <ggVGc> zincy: to achieve the same thing I'd have to make sure I handle any exception that might or might not happen. Or build a bad version of OTP with isolated threads sending messages to eachother
07:01:26 <ggVGc> at which point I'm just making bad erlang
07:01:58 <ggVGc> also, database access is a lot easier and light weight from elixir than haskell
07:01:59 <zincy> So is every trading bot for a given api running in a separate process
07:02:20 <zincy> and then when an exception is thrown in the elixir runtime the process just restarts?
07:02:37 <ggVGc> there are many processes doing different things. One is fetching order books, one is validating orders being placed on exchanges, one is monitoring feeds, one is running strategies
07:02:41 <ggVGc> etc.
07:02:54 <ggVGc> and any one of them can crash and restart at any time
07:02:55 <ggVGc> and it's fine
07:03:11 <zincy> That is one complex program
07:03:14 <zincy> Did you finish it
07:03:52 <ggVGc> it's running live since about a month
07:03:58 <ggVGc> took me 2 days to write the basics of it
07:04:15 <ggVGc> OTP makes it easy, hence why the haskell version was bad
07:04:20 <zincy> Also where did you keep the state for how each strategy was performing , pnl etc?
07:05:32 <ggVGc> it's pretty simple. each strategy just has its state in a blob in a database, and gets pulled out and executed by a runner. If something fails the new state is not written to the DB (as long as no external actions have been executed)
07:05:46 <ggVGc> and each strategy is connected to a local account, which I can track what happens to
07:06:09 <ggVGc> it also prevents a strategy from running off and buying/selling too much
07:06:11 <zincy> How long have you been coding for? Im surprised you wrote that in two days
07:06:55 <ggVGc> I didn't write the whole thing in two days. Just the basic thing with fetching order book and runnign the strategies. There were some bugs and not great control, but the basics worked. Since then I've been working on it fairly actively the past month
07:07:15 <ggVGc> ah, also the account management part
07:07:20 <ggVGc> since those were the issues with the haskell version
07:07:50 <ggVGc> my point was, the hard problems in the haskell version took a few days to solve in elixir. But the strength of the haskell version (rigid definition of strategies) are missing in the elixir version now
07:08:42 <mbwgh> Is a first-order language one without higher-order functions and vice versa? Or is it more complicated than that??
07:08:57 <ggVGc> not sure I've heard the term first-order language before :(
07:09:23 <mbwgh> It show up all the time in the tagless-final lecture notes, for instance.
07:09:55 <mbwgh> Also in the context of "defunctionalization", where as I understand it, you turn CPS-style back into first-order style.
07:10:58 <mbwgh> As described in the last chapter of Hutton's book, where they implement a compiler
07:11:55 <zincy> :t %=
07:11:56 <lambdabot> error: parse error on input ‘%=’
07:12:04 <zincy> :t (%=)
07:12:06 <lambdabot> MonadState s m => ASetter s s a b -> (a -> b) -> m ()
07:12:32 <mbwgh> I'm pretty sure lens is a higher-order language
07:12:34 <zincy> :t ASetter
07:12:35 <lambdabot> error:
07:12:35 <lambdabot>     • Data constructor not in scope: ASetter
07:12:35 <lambdabot>     • Perhaps you meant one of these:
07:12:58 <mbwgh> :i ASetter
07:13:05 <mbwgh> :(
07:13:06 <cocreature> mbwgh: I’m not sure first-order language is really a well-established term but my interpretation would be the same as yours
07:13:39 <zincy> What is the  ASetter s s a b
07:14:08 <ggVGc> it does sound like a language that can not represent it's own pieces in a first-order way. e.g for example not having functions as first class citizens
07:14:15 <ggVGc> but this is quite a fair bit of speculation form me
07:14:21 <mbwgh> cocreature: Would you regard C a higher-order language then? You can take function pointers as arguments and return them. But you can't create functions on the fly or easily capture an environment without things quickly becoming hairy
07:14:43 <ggVGc> with that definition I owuld definitely consider C first order
07:14:48 <ggVGc> a function pointer is not a function
07:15:03 <AWizzArd> I have a function   eval :: (Show a) => Environment a -> Term -> Either String Term     and later want to call it:  prog1' = eval emptyEnv prog1     but GHC complains that an »Ambiguous type variable ‘a0’ arising from a use of ‘eval’ prevents the constraint ‘(Show a0)’ from being solved.«
07:15:07 <ggVGc> you can't, for exampole, in a reasonable way partially apply it
07:15:23 <cocreature> zincy: it’s the type of things that can act as setters, Lens, Prism, … can all be specialized to that type
07:15:32 <AWizzArd> What other type than    prog1' :: Either String Term    should I use to make clear that Showing is possible?
07:15:39 <ggVGc> I think Lens types could be a uni course in itself
07:15:40 <ggVGc> or maybe a year
07:15:43 <cocreature> mbwgh: probably not but without agreeing on some formal definition I don’t think it makes sense to debate whether it applies to C
07:16:09 <zincy> ggVGc: haha
07:16:59 <mbwgh> Ok I guess I'll go with first-order => no HOFs until it blows up in my face
07:17:05 <zincy> I need to get some motivation to learn Lens
07:17:24 <ggVGc> well, I'd argue the type specs isn't one
07:17:25 <mbwgh> zincy: Try to update a deeply nested record without them
07:18:14 <cocreature> zincy: are you familiar with the Traversable typeclass?
07:18:31 <ggVGc> zincy: I think Lens allows you to think about your data in new intersting ways, and gives you kind of structural typing, so you can write functions for "values that have x and y" for example
07:18:40 <ggVGc> that was my main original motivation to get into it
07:19:18 <ggVGc> also, Lens allows you to implement fairly nice DSL with very little effort
07:19:26 <ggVGc> if that's a good or bad thing is up to you :)
07:20:30 <quicksilver> zincy: you'll find motivation soon enough.
07:21:07 <kuribas> zincy: how do you increment each part of a tuple?
07:21:11 <quicksilver> foo { bar = bar foo { baz = baz bar foo + 1 } } is enough motivation for many
07:21:20 <quicksilver> but thre are penty of other convincing places
07:21:26 <kuribas> > over both (+1) (3, 2) -- zincy
07:21:28 <lambdabot>  (4,3)
07:21:31 <ggVGc> quicksilver: what about "feeling clever"?
07:21:39 <ggVGc> that's a pretty big one around haskell I think :)
07:21:48 <mbwgh> zincy: I would strongly recommend having a look at the microlens haddocks, and probably also the Wikibooks article. Other than that, it is perfectly fine to use lens as "getters and setters" when starting out. You don't need to know about Prisms, Isos, or the classy stuff in order to get stuff done with them.
07:22:39 <zincy> cocreature: Yeah traversable just has the traverse function as a required function right
07:22:47 <zincy> :t traverse
07:22:48 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
07:23:32 <zincy> feeling clever is a good reason to do anything
07:23:58 <mbwgh> zincy: Also, there is a library that clamis to provide comprehensible error messages: https://github.com/mrkgnao/silica It isn't overly discoverable, since it isn't on hackage.
07:24:05 <zincy> mbwgh: thanks sounds good
07:25:04 <zincy> should I look at microlens instead of simple-lens
07:26:50 <mbwgh> zincy: I think this is one of the shortest lens guides: https://guide.aelve.com/haskell/lenses-sth6l9jl
07:27:47 <mbwgh> zincy: I personally have only really used `lens` itself, and used the microlens haddocks as some sort of tutorial. But the haddocks of lens have improved significantly as well.
07:28:19 <zincy> Can you imagine onboarding someone new to haskell to lensified codebase :)
07:29:08 <zincy> :t (.).(.)
07:29:09 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
07:29:10 <glguy> zincy: Yeah, I've done that
07:29:15 <zincy> how did it go?
07:29:17 <cocreature> zincy: exactly, lens’ Traversal type is just a generalization of the "traverse" function
07:29:18 <glguy> fine
07:29:24 <cocreature> :i Traversal
07:29:30 <cocreature> % :i Traversal
07:29:34 <yahb> cocreature: type role ReifiedTraversal representational nominal representational nominal; newtype ReifiedTraversal s t a b = Traversal {...}; -- Defined in `Control.Lens.Reified'; type Traversal s t a b = forall (f :: * -> *). Applicative f => (a -> f b) -> s -> f t -- Defined in `Control.Lens.Type'
07:29:40 <cocreature> well that looks horrible
07:30:03 <zincy> glguy: how long did it take for them to be productive?
07:30:05 <cocreature> but if you look at the end you see the interesting part "type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s f t"
07:30:19 <zfnmxt> I need to generate register labels that are unique, i.e. each new label is different from all previous labels. Should I just do this by incrementing a counter or is there a nice library that provides that sort of fucntionality?
07:30:41 <cocreature> Lens is then just a Traversal that always targets exactly one element. this also lets you "view" that element in addition to modifying all elements targetted by the Traversal
07:31:40 <maerwald> does anyone have a working deoplete configuration?
07:32:01 <maerwald> the documentation is really bad
07:32:14 <glguy> zincy: They were able to be productive right away and then of course they got more comfortable
07:32:50 <zincy> glguy: So from no haskell experience they hit the ground running in a haskell codebase?
07:33:40 <zincy> I need some context did they have 5 years of exp in another ML lang
07:35:41 <glguy> I think that Haskell was his first language in that family, but he was an experienced programmer
07:36:30 <zincy> Ah ok
07:36:49 <glguy> but at work we've brought a number of people onto Haskell projects who needed to learn it
07:37:06 <zincy> glguy: Where do you work
07:37:33 * hackage layered-state 1.1.4 - Control structure similar to Control.Monad.State, allowing multiple nested states, distinguishable by provided phantom types.  http://hackage.haskell.org/package/layered-state-1.1.4 (danilo2)
07:50:09 <zincy> How do I use %= to set something on a list of lensified values?
07:50:23 <maerwald> deoplete is really impossible to get working, I'm confused about the positive reviews
07:50:41 <zincy> (username %= "") <$> players :: [Player]
07:50:48 <cocreature> zincy: are you in State? (%=) is only the stateful version of (%~)
07:51:01 <zincy> not in State
07:51:17 <cocreature> then the first step is to use (%~) instead of (%=) :)
07:52:06 <zincy> :)
07:52:07 <zincy> (pockets %~ []) <$> players :: [Player]
07:52:20 <cocreature> > [(1,2), (2,3)] & traverse . _1 %~ (+1)
07:52:22 <lambdabot>  [(2,2),(3,3)]
07:52:28 <cocreature> is that what you’re looking for?
07:53:00 <zincy> does traverse come from Lens
07:53:07 <zincy> or traversable
07:53:11 <cocreature> no it’s the traverse from Traversable
07:53:30 <cocreature> as I mentioned before, lens’ Traversal type is just a generalization of the "traverse" function
07:53:32 <zincy> what does & do
07:53:42 <cocreature> (&) is flipped function application, it’s in base
07:53:45 <cocreature> :t (&)
07:53:46 <lambdabot> a -> (a -> b) -> b
07:56:24 <zincy> thanks!
07:56:37 <zincy> Traverse is just mapping with effects right?
07:58:32 <nitrix> zincy: That's a good intuition. There are laws associated to it though.
07:59:24 <zincy> :)
07:59:29 <zincy> Oh
07:59:35 <zincy> :t %~
07:59:37 <lambdabot> error: parse error on input ‘%~’
07:59:47 <cocreature> you need parenthesis around the operator
08:00:53 <zincy> :t (%~)
08:00:54 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
08:01:12 <zincy> hmm          let players' =                     (players :: [Player]) &                     traverse . (pockets %~ ([] :: [Card]))
08:01:20 <cocreature> zincy: I would recommend looking at the simplified type signatures in the lens’ docs rather than the ones that :t spits out
08:01:44 <nitrix> (%~) :: Setter a a' b b' -> (b -> b') -> a -> a'
08:02:03 <zincy> ok will do
08:02:18 <zincy>          let players' =  (players :: [Player]) &  traverse . (pockets %~ ([] :: [Card]))
08:02:43 <cocreature> your parenthesis are wrong
08:02:44 <zincy>  • Couldn't match type ‘Player’ with ‘a -> f b’       Expected type: Player -> a -> f b         Actual type: Player -> Player     • Possible cause: ‘(%~)’ is applied to too many arguments       In the second argument of ‘(.)’, namely         ‘(pockets %~ ([] :: [Card]))’       In the second argument of ‘(&)’, namely         ‘traverse . (pockets %~ ([] :: [Card]))’       In the expression:         (playe
08:02:47 <cocreature> and [] is not a function
08:03:04 <zincy> what about const
08:03:07 <zincy> :t const
08:03:08 <lambdabot> a -> b -> a
08:03:08 <cocreature> also please use a pastebin for multiline error messages
08:03:23 <cocreature> that would work or you can use .~ instead of %~
08:03:50 <zincy> https://lpaste.net/5971647710028103680
08:04:37 <cocreature> start by fixing the errors I told you about and then show us the new errors (if any) :)
08:05:11 <zincy> I did what you said and ... it works!
08:05:12 <zincy>  let players' =                   (players :: [Player]) & traverse . pockets .~ ([] :: [Card])
08:05:18 <cocreature> even better :)
08:05:23 <zincy> :D
08:05:27 <zincy> Thank you
08:05:29 <nitrix> zincy: (%~) has the lens on the left (that'll focus onto some parts of your Traversable) and a transformation function on the right (to be applied).
08:05:32 <nitrix> .~ works :)
08:05:37 <cocreature> just to be clear, the parenthesis are around (traverse . pockets)
08:06:05 <zincy> so %~ takes a function and .~ just sets a value
08:06:28 <cocreature> .~ is pretty much %~ combined with const
08:06:49 <zincy> Makes sense
08:06:51 <zincy> :)
08:06:56 <zincy> traverse . lensThing .~ someValue
08:07:09 <zincy> is lensThing a lens
08:07:48 <cocreature> that’s a bit hard to say without seeing its definition
08:08:34 <Taneb> zincy: a lens would certainly fit there
08:10:14 <zincy> Are lens operators such as (%=) and (.~) just functions which take lens?
08:10:21 <zincy> And return the complete structure without zooming in
08:10:39 <zincy> Whereas ^. would get you the zoomed in structure?
08:12:16 <fr33domlover> Btw, Wikibooks has an amazing lens tutorial
08:13:10 <zincy> thanks will look
08:13:26 <zincy> this one? https://en.wikibooks.org/wiki/Haskell/Lenses_and_functional_references
08:14:07 <fr33domlover> zincy, yeah
08:16:40 <drets> Is there a way to return value of my custom data type from http://hackage.haskell.org/package/esqueleto-2.5.3/docs/Database-Esqueleto.html#v:select ? Should I implement instance of SqlSelect? But it's internal class :|
08:17:21 <geekosaur> generally you have to marshal and unmarshal from what the database supports
08:18:30 * hackage semilattices 0.0.0.0 - Semilattices  http://hackage.haskell.org/package/semilattices-0.0.0.0 (robrix)
08:18:31 <drets> yeah, and my question is how... will try to create example.
08:23:14 <fr33domlover> drets, look at the function signatures, there should be a typeclass for everything you can return. Maybe it also uses classes from persistent. Btw check out the Selda library :)
08:23:23 <fr33domlover> gtg bbl o/
08:25:32 <glguy> zincy: galois.com
08:26:59 <AWizzArd> Some users may expect that when my type implements Show that they can call read on the result of calling show.   Is there an alternative to the Show TC that I can use for any String representation that I want?
08:27:40 <geekosaur> not a standard one, nbecause everyoen has different expectations in that area
08:28:02 <glguy> AWizzArd: No. If you need some application specific formats you should make a new typeclass for that (assuming a typeclass is needed at all)
08:28:07 <geekosaur> there are prettyprinter libraries that can help you build your own
08:28:11 <saurabhnanda> Been scratching my head over Perstitent's types for quite some time now. Which function concretizes the `BaseBackend backend` constraint finally? https://gist.github.com/saurabhnanda/6d10581503ae877e61de5edef3574538
08:29:46 <AWizzArd> glguy: is there a way to marry ghci’s repl with my own mirrored Show TC?
08:30:52 <zincy> glguy: Fun company to work for?
08:31:10 <glguy> yup :)
08:31:23 <zincy> Ok lens lead to nice concise code
08:31:42 <glguy> AWizzArd: Not that I'm aware of
08:31:43 <geekosaur> AWizzArd, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html#ghci-interactive-print
08:32:30 <geekosaur> beh, thta's broken, they lost the docs, it points to itself :(
08:32:51 <suppi> https://teh.id.au/posts/2017/02/13/interactive-print/index.html
08:32:58 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#using-a-custom-interactive-printing-function
08:33:27 <AWizzArd> Oho! :-)
08:33:56 <glguy> Ah, now I'm aware of one :)
08:34:29 * hackage hexpat-lens 0.1.7 - Lenses for Hexpat.  http://hackage.haskell.org/package/hexpat-lens-0.1.7 (OliverCharles)
08:35:30 * hackage semilattices 0.0.0.1 - Semilattices  http://hackage.haskell.org/package/semilattices-0.0.0.1 (robrix)
08:36:02 <dminuoso> zincy: For me at least, simply changing the direction in which I code tends sometimes stop sme worrying about "getting it right". For me personally it works :0
08:36:47 <drets> fr33domlover, I think it's PersistField, thanks.
08:37:05 * hackage lawful 0.1.0.0 - Assert the lawfulness of your typeclass instances.  http://hackage.haskell.org/package/lawful-0.1.0.0 (mnoonan)
08:38:44 <zincy> dminuoso: Not sure I follow
08:41:55 <dminuoso> zincy: That was regarding your earlier question how to defeat certain cyclic behavior patterns. :P
08:43:20 <zincy> dminuoso: Yeah I know. I didn't follow what you meant by "direction"
08:43:24 <zincy> :)
08:43:39 <dminuoso> zincy: Like I said. Top-down vs bottom-up
08:43:46 <zincy> ah yes I remember now
09:40:51 <sm> https://www.codingame.com/contests/code-of-kutulu might be fun for haskellers
09:40:56 <sm> starting today
09:44:21 <reygoch> So, I have this : forall m a e x. (Functor m, a ~ (x -> ExceptT e m x), ...) => ...
09:44:58 <reygoch> but I'm getting the message that m occurs more often in the constraint than in the instance head
09:45:36 <reygoch> is it not possible to put a constraint on the m in this case?
09:47:05 <cocreature> reygoch: can you show us the full error message?
09:47:11 <reygoch> sure, just a sec
09:47:53 <reygoch> https://lpaste.net/2201506163260915712
09:47:56 <reygoch> there :)
09:49:39 <reygoch> cocreature: I'm trying to make a function which can take infinite number of arguments, but since my arguments are parametrized it get's complicated
09:50:10 <zfnmxt> I'm sort of finding myself in a situation where I have like 5 different modules all involving types with StateT monads. I want to combine everything into one "big" StateT monad. Is there a nice way to do that?
09:50:13 <cocreature> reygoch: GHC already tells you how to fix this: enable UndecidableInstances
09:50:36 <reygoch> Yes, but I'd like to avoid that.
09:50:39 <cocreature> why?
09:51:07 <cocreature> if you are doing anything fancy with typeclasses, you will pretty much always find yourself having to enable UndecidableInstances
09:51:11 <reygoch> code will get a bit more complicated onward and I think undecideable will bite me in the ass
09:51:22 <reygoch> here is example of what I'm trying to do: https://lpaste.net/4822520422480216064
09:51:35 <reygoch> I want to have function which takes infinite number of arguments
09:51:47 <reygoch> but my arguments are heavily parametrized
09:51:48 <cocreature> GHC’s termination checker for instances is pretty dumb, so you have UndecidableInstances to turn it off
09:52:14 <cocreature> at worst that will give you an infinite loop at compile time (although in practise, GHC has some (configurable) limit after which it gives up iirc)
09:52:34 <reygoch> but I'm getting the feeling that I'm dumb and there is a better way to go about this :D
09:52:49 <reygoch> ok, I'll go with undecideable for the time being
09:52:52 <cocreature> are all your arguments of type x -> ExceptT e m x?
09:52:52 <reygoch> thanks
09:52:55 <reygoch> no
09:53:02 <reygoch> some are of type Validator i m e
09:53:15 <cocreature> that seems to be the return value not the argument?
09:53:25 <reygoch> It can be argument as well
09:53:47 <reygoch> I'm trying to do the same thing printf does
09:54:17 <reygoch> taking in infinite number of varying arguments
09:55:03 <cocreature> your instances doesn’t really seem to allow for that no? you have a single instance for (a -> o) that forces a to be (x -> ExceptT e m x) and o to be Validator i m e
09:55:38 <reygoch> this is just one branch of the recursion
09:55:59 <cocreature> hm hard to say then if things will fit together correctly :)
09:56:05 <reygoch> yes :D
09:56:21 <reygoch> well, I'll make them fit! XD
09:56:29 <cocreature> but you can’t make two instances for Checker s (a -> o)
09:56:40 <reygoch> oooo...
09:56:43 <reygoch> damn,
09:56:58 <reygoch> this was my second approach actually
09:57:01 <cocreature> so I think you probably want one for Checker s (a -> Validator i m e) and then another one for Checker s (a -> o) and Overlapping instances
09:57:28 <reygoch> damn, I think I'll have to look for another approach
09:57:35 <cocreature> or even one for Checker s (Validator i m e) and for Checker s (a -> o) and no overlapping instances
09:58:04 <cocreature> either way, this might all not apply to your situation but it’s really impossible to tell without having more context :)
09:58:27 <reygoch> well... I'll get back to work and hopefully report back with a nice and simple validation library :)
09:58:30 <reygoch> thanks for advice
09:58:35 <cocreature> have fun :)
09:58:39 <reygoch> sure will
10:07:01 <AWizzArd> I have a function   foo :: a -> (forall b. b -> b -> Bool) -> Bar   and want to know how I can add an Eq constraint to the `b` in the Rank2 fn.
10:07:17 <AWizzArd> Where does this syntactically go?
10:07:27 <int-e> (forall b. Eq b => b -> b -> Bool)
10:07:50 <glguy> AWizzArd: You can just write that: foo :: Eq b => a -> b -> b -> Bool, and it will be the same
10:07:57 <glguy> ohhh, sorry, linewrapping
10:08:02 <glguy> I missed the -> Bar :)
10:08:35 <AWizzArd> Oki. I tried 2-3 locations for the constraint but didn’t think of that one. Now it works, thx!
10:14:23 <zfnmxt> I made a small module to that's basically a counter: https://github.com/zfnmxt/TigerHaskell/blob/master/compiler/src/Temp.hs and I need to integrate it into my CheckerState monad (line 28) https://github.com/zfnmxt/TigerHaskell/blob/master/compiler/src/Semant.hs . I'm not really sure how to do that. Do I just make larger monad transformer stack? Seems kind of ugly.
10:20:28 <[exa]> zfnmxt: what about just type Env = (VEnv,TEnv,Temp) ?
10:20:48 <zfnmxt> Well, I thought of that too. Where Temp :: Int, right?
10:21:02 <[exa]> zfnmxt: btw extending is easier (and code cleaner) if you use records with named fields instead of long tuples
10:21:19 <[exa]> (where 2 is already long)
10:21:36 <zfnmxt> I generally use records, but I guess I should be more consistent.
10:21:39 <[exa]> zfnmxt: I thought that you have defined Temp (not int)
10:22:22 <zfnmxt> Oh, right.
10:22:59 <zfnmxt> But, somehow I dislike that because I like the modular nature of having things like mkTemp, etc. I don't know if that make sense.
10:23:08 * hackage pinch 0.3.3.0 - An alternative implementation of Thrift for Haskell.  http://hackage.haskell.org/package/pinch-0.3.3.0 (abhinav)
10:23:21 <zfnmxt> It seems like by changing Env I'm sort of "forcing" the Temp into the Env in a somewhat non-modular way. But maybe that's just my lack of understanding.
10:23:25 <[exa]> zfnmxt: why would mkTemp stop working?
10:23:48 <zfnmxt> I wouldn't use it, would I?
10:24:11 <zfnmxt> If I have Temp in the Env I'd have to manually update Temp instead of using mkTemp, right?
10:24:13 <[exa]> yeah in this case it will stop working because it requires the state to be exactly Temp, but you can easily make it work on the extended state
10:24:48 <zfnmxt> Right, but then I'm rewriting mkTemp
10:25:18 <zfnmxt> Isn't there a nice way to combine the CheckerState monad in Semant.hs with the GenTemp monad?
10:25:25 <[exa]> hmm... what about a bit of overloading?
10:25:53 <zfnmxt> What do you mean?
10:26:10 <zfnmxt> Sorry about my confusion. I still find monad transformers difficult to understand/reason about :)
10:26:11 <[exa]> did you try working with MTL?
10:26:48 <[exa]> the idea is that you make a class that is called e.g. "HasTemp" for monads that provide Temp setting/getting
10:27:19 <[exa]> and using a bit of instances you can easily derive the HasTemp for whole monad stacks
10:28:04 <[exa]> which prevents most of manual lifting in the code and makes the thing quite readable
10:28:17 <zfnmxt> Hm, I see.
10:28:39 <zfnmxt> Do you know of any examples of using typeclasses in that way?
10:28:51 <zfnmxt> Just so I have a concrete reference
10:29:18 <[exa]> I guess this can be a good starting point https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Lazy.html#g:4
10:30:49 <[exa]> 'MonadState s m' means that there's a (StateT s) hidden somewhere in the stack, and get/put will work as if it was not stacked
10:31:40 <glguy> and it doesn't have to be an actual StateT, just any type that implements the interface
10:31:52 <[exa]> oh the examples there aren't very explanatory regarding the actual typeclass usage
10:32:05 <glguy> so if you're doing this style for your project you might have a single type tha implements all the interfaces needed by various components
10:32:06 <zfnmxt> Heh, right. I was confused about the examples. :)
10:32:43 <reygoch> I'm having trouble with writing this class: https://lpaste.net/1904271663051046912
10:32:50 <reygoch> Is it possible to do something like this?
10:32:57 <zfnmxt> glguy: And that type would be a MonadState <something>?
10:33:19 <[exa]> there should be a nice reading about MTL somewhere...
10:33:42 <glguy> zfnmxt: Yeah, as long as there's an instance that has the expected behavior it's fine
10:34:04 <zfnmxt> Is it easy to add new components like that?
10:34:25 <zfnmxt> The issue I'm having here is that I didn't realize I needed a counter until after I wrote my typechecker :)
10:34:31 <[exa]> zfnmxt: this is good I guess: https://blog.jle.im/entry/mtl-is-not-a-monad-transformer-library.html
10:35:07 <glguy> zfnmxt: It's easier if you make sure that your main type is fairly abstract and that nothing is depending on its implementation, just the operations you've defined on that type
10:35:09 <[exa]> zfnmxt: you will want to implement something like MonadTemp and MonadEnv
10:35:32 <glguy> then you'll be free to change it around to support the new functionality like having a counter without breaking everything else
10:35:41 <zfnmxt> I see.
10:35:44 <reygoch> So, is it impossible to bind scoped variables in class instance?
10:35:46 <zfnmxt> Thanks [exa] , I'll read that :)
10:35:59 <zfnmxt> I guess this also comes with experience (which I don't have) :)
10:36:10 <glguy> reygoch: the instance variables are already scoped
10:36:34 <reygoch> but I I have method with variables that aren't mentioned in the class definition?
10:36:45 <reygoch> like this : https://lpaste.net/1904271663051046912
10:37:05 <glguy> that's fine, don't forall the variables that are already in scope
10:37:26 <cocreature> i.e. don’t forall anything here :)
10:37:42 <reygoch> but it doesn't work either way
10:38:15 <cocreature> what’s the error once you remove the forall?
10:38:24 <reygoch> same
10:38:29 <reygoch> but now that I think of it
10:38:40 <reygoch> maybe I should add type signature to my definition
10:38:51 <reygoch> for `validator` function
10:40:11 <glguy> reygoch: The correct type signature is:   mkarg :: (i -> x) -> (x -> ExceptT e m x) -> Validator i' m' e'
10:41:07 <glguy> You were trying to relate the univerally quantified type variables i m e in mkarg with the variables in the instance head
10:41:40 <glguy> Which means your class is wrong, not your instance, most likely
10:41:40 <reygoch> So how do I make i' ~ i, m' ~ m, and e' ~ e ?
10:41:51 <zfnmxt> So for my specific problem, it seems like I could actually essentially solve it just by swithing Env to a record type. The argument for MonadState is to make things not break if I change my current usage of StateT, right?
10:42:26 <[exa]> zfnmxt: this is even better reading I guess https://wiki.haskell.org/Monad_Transformers_Tutorial
10:43:16 <[exa]> zfnmxt: yes, if you want it working, go with a record type. If you somehow depend on the Temp State monad to be completely independent on the rest of the thing, you should probably go with the typeclasses
10:43:21 <glguy> reygoch: You probably just don't need a class
10:44:02 <zfnmxt> [exa]: Where "go with typeclasses" <--> "use MonadState", right?
10:44:24 <glguy> zfnmxt: You shouln't rely on literal MonadState, that's just an example of the approach
10:44:35 <glguy> You should make a class specific to the operations your counter functionality needs
10:45:08 <zfnmxt> And then make CheckerState an instance of that class?
10:45:12 <glguy> yeah
10:45:31 <zfnmxt> Okay. I'll do that, if only to learn about that approach :)
10:46:00 <[exa]> :]
10:46:07 <zfnmxt> Thanks for the help!
11:03:26 <c_my_nick> why is cabal new-build ignoring my freeze file?  it has Cabal ==1.18.1.5 in it, but it wants to install Cabal-2.2.0.1 (and runs out of memory when it tries)
11:03:45 <c_my_nick> the dependencies on this project havent changed since the last time i ran cabal new-freeze
11:07:01 <sclv> c_my_nick: have you tried using an index-state timestamp? https://cabal.readthedocs.io/en/latest/nix-local-build.html?highlight=freeze#cfg-field-index-state
11:07:23 <sclv> As i mentioned on the other channel, I think that the freeze constraint isn't applying to a build-tool dependency perhaps
11:07:50 <sclv> i hope/suspect that the index-state would work more uniformly
11:08:59 <c_my_nick> i dont even know what value i would use for that
11:10:57 <zfnmxt> At the end of the first section in this post: https://ocharles.org.uk/blog/posts/2014-12-04-record-wildcards.html he talks about "applicative syntax"--what's that?
11:13:14 <c_my_nick> zfnmxt, i assume he is referring to the use of the <$> and <*> functions, instead of do notation:  undefined <$> o .: "name" <*> o .: "position" ... etc.
11:13:26 <sclv> c_my_nick: pick a timestamp from when you had a successful build
11:13:54 <sclv> like e.g. the timestamp from when your  new-freeze was?
11:14:25 <zfnmxt> c_my_nick: Ah, right. Thanks.
11:20:50 <c_my_nick> zfnmxt, i guess that works (added a couple days to the last modified date of the freeze file), but it wants to update a bunch of other packages too.
11:21:07 <zfnmxt> c_my_nick: wrong person :)
11:21:21 <c_my_nick> whoops ><
11:37:14 <zfnmxt> [exa]:
11:37:16 <zfnmxt> Oops.
11:37:23 <zfnmxt> [exa]: So I got this far: https://github.com/zfnmxt/TigerHaskell/blob/master/compiler/src/Semant.hs
11:37:43 <zfnmxt> I think that's okay, but it just augments the Env. I don't really see how to do it without doing that (i.e. using the GenTemp monad)
11:37:55 <zfnmxt> (See line 37)
11:40:42 <[exa]> oh okay, that's an approach that mixes both :]
11:41:39 <zfnmxt> Yeah, I guess so :D
11:41:51 <zfnmxt> But I'd like to do it with just the GenTemp monad, to make sure I understand
11:43:14 <[exa]> the total pure MTL way would be this: 1] TempT that is built upon StateT, with accompanying class HasTemp   2] CheckerStateT with HasCheckerState   3] (the fun part) inductive instances that say "any monad transformer that contains a CheckerState is also in HasCheckerState
11:45:41 <zfnmxt> [exa]: Okay, let me play around and see if I can get something like that. Thanks!
11:45:42 <[exa]> wild unchecked guess about the code that might be completely wrong because I don't have ghci handy: instance (MonadTrans mo, HasTemp mi) => HasTemp (mo mi) where {mkTemp = lift mkTemp}
11:49:25 <[exa]> which way you can have a monad stack that looks roughly like: TempT (CheckerStateT (Either Error))
12:03:36 <zfnmxt> [exa]: My brain hurts. I tihnk I need to read more about MTL first :)
12:03:44 <zfnmxt> [exa]: Thanks a lot for all your help, at any rate
12:08:55 <[exa]> zfnmxt: the thing with the instance is basically telling the compiler that if it sees  e.g. a monad  'Temp a' (which is in HasTemp) and it's wrapped in a transformer, the Transformer (Temp a) will also be in HasTemp (only with a slight lift)
12:09:48 <[exa]> which will eventually lift its way all the way down in your monad stack, collecting all the properties of the transformers you've used in a single place without any manual 'lift'
12:09:48 <infinisil> zfnmxt: Brains are 10% off at Walmart this week, if you want a new one, this is the time!
12:11:18 <zfnmxt> [exa]: It makes sense intuitively...but I think I need to do some more reading :)
12:13:53 <[exa]> zfnmxt: still I guess you've got better to implement it with a single State now. If you name your accessors reasonably, you'll be able to convert the code to transformers later without any serious rewriting
12:15:14 <zfnmxt> [exa]: Can this be done just by using a basic transformer stack? I.e., how could I easily tack on the GenTemp to the stack without the (at the moment) more confusing MTL stuff?
12:15:35 <zfnmxt> Maybe once I understand that the MTL stuff will be easier
12:16:38 <[exa]> yeah, you'll only need to remember the correct amount of lifts you need to do for each transformer
12:16:53 <zfnmxt> I would have to change GenTemp from State to StateT, right?
12:17:06 <[exa]> yes
12:17:21 <zfnmxt> So change it to StateT, and put CheckerState inside of it, and viola
12:18:54 <[exa]> yes. I guess your GenTempT will even get the MonadTrans instance for free from StateT s, so you'll be able to use 'lift' right away
12:19:18 <dmwit> Put CheckerState inside of it, and BAM! Suddenly musical! 🎶
12:19:34 <zfnmxt> Okay, cool. I'll do that as a stepping stone and then see if I can get the MTL approach down :)
12:19:38 <zfnmxt> Thanks a lot, [exa] !!
12:19:46 <[exa]> :]
12:20:16 <zfnmxt> dmwit: I hope so :)
12:35:11 <butterthebuddha> What's the best solution for maintaining (mutable) global state in a program?
12:36:48 <lyxia> pass around an IORef?
12:37:05 <monochrom> Most often you don't need it.  In the minority of cases when you need it, "x = unsafePerformIO (newIORef blah)" with {-# NOINLINE x #-} is the standard solution.
12:37:29 <liste> or just making one in main and passing it around
12:38:11 <liste> ImplicitParams could be an option
12:39:08 <butterthebuddha> Is there any way to avoid having to pass around an extra parameter?
12:39:26 <liste> @define foo :: (?x :: Int) -> Int -> Int; foo y = ?x + y
12:39:26 <lambdabot>  Parse failed: Parse error in type: ?x :: Int
12:39:38 <philippD> When collecting constraints into a single type what are the benefits of creating a new class like `A` with a single `instance (constraints...) => A a` over using ConstraintKinds a defining a `type A a = (constraints...)` ?
12:40:01 <liste> > let { foo :: (?x :: Int) -> Int -> Int; foo y = ?x + y } in (let ?x = 5 in foo 10)
12:40:04 <lambdabot>  error:
12:40:04 <lambdabot>      • Expected a type, but ‘?x::Int’ has kind ‘Constraint’
12:40:04 <lambdabot>      • In the type signature: foo :: (?x :: Int) -> Int -> Int
12:41:03 <geekosaur> it's a constraint, not a type
12:41:06 <liste> > let { foo :: (?x :: Int) => Int -> Int; foo y = ?x + y } in (let ?x = 5 in foo 10)
12:41:08 <lambdabot>  15
12:41:18 <liste> look ma, no passing ?x to foo!
12:41:25 <monochrom> You can also let some library does it for you.  global-config and global-variables do it.
12:42:00 <lyxia> philippD: partial application, which is useful with higher-order constraint combinators.
12:42:16 <conn> how can the cartesian product of two monoids be a monoid ?
12:43:21 <philippD> lyxia: Ahhh, that makes a lot of sense. Thanks.
12:43:43 <butterthebuddha> conn: apply the operation element-wise
12:43:45 <liste> mempty = (mempty, mempty); mappend (a, b) (a', b') = (mappend a a', mappend b b')
12:44:02 <butterthebuddha> ^
12:47:25 <conn> butterthebuddha can u give an example ? ;)
12:47:40 <ZeuPiark> hello
12:48:07 <butterthebuddha> conn: Let's think about the addition monoid over Integer
12:48:24 <butterthebuddha> I believe this is called "Sum" in Haskell
12:48:56 <butterthebuddha> Let's try to define a monoid instance for Sum * Sum
12:49:20 <butterthebuddha> What does an element of Sum * Sum look like? It looks like (a, b) where both a and b are elements of this "Sum" type; i.e. they are Integers with addition defined on them
12:50:41 <butterthebuddha> If we have two elements of Sum * Sum, (a, b) and (a', b'), the most natural way of implementing (a, b) <> (a', b') is to simply do (a <> a', b <> b'). So for example, if the first element we pick from Sum * Sum is (1, 1) and the second element we pick is (2, 4), then (1, 1) <> (2, 4) would be (1 <> 2, 1 <> 4) = (3, 5)
12:50:43 <philippD> Hello ZeuPiark
12:50:55 <butterthebuddha> Does that make sense?
12:51:51 <conn> <> equals mappend ?
12:51:58 <butterthebuddha> This is of course just one way to think about the product of two monoids as a monoid, but it's the most natural construction and satisfies the (category theoretic) universal property of Product
12:52:03 <butterthebuddha> conn: UYes
12:52:05 <butterthebuddha> Yes*
12:52:56 <butterthebuddha> For a more complicated example, consider Sum * Product; (2, 4) <> (3, 1) = (2 <> 3, 4 <> 1) = (5, 4)
12:53:39 <butterthebuddha> (because (<>) = (+) in Sum and (*) in Product)
12:54:42 <conn> butterthebuddha i tried it like this: x = mappend [1,2] [] y = mappend [3,4] []  myMonoid a b = [ (m,n) | m <- a, n <- b]  , which outputs: [(1,3),(1,4),(2,3),(2,4)]
12:55:27 <conn> where x and y should be monoids and myMonoid should be the new monoid made from x and y
12:55:48 <butterthebuddha> x and y are not monoids - they are elements of the List monoid
12:56:41 <butterthebuddha> In the code above, x = [1,2] and y = [3,4], so the corresponding element in the monoid that is the product of List with itself is ([1,2], [3,4])
12:56:57 <conn> how can i make x and y monoids ? from what i understood is that -- Identity laws x <> mempty = x
12:57:09 <butterthebuddha> x and y _cannot_ be monoids
12:57:19 <butterthebuddha> Only types of kind * -> * can be monoids
12:57:24 <glguy> *
12:57:38 <butterthebuddha> Whoops, kind *
12:57:52 <butterthebuddha> (Do you know what kinds are)
12:58:42 <philippD> x and y are values, not types and only types can be monoids
12:59:03 <butterthebuddha> It seems from our conversation that you are confused about what a Monoid is; I suggest you read the Typeclassopedia article here: https://wiki.haskell.org/Typeclassopedia#Monoid
12:59:10 <monochrom> > [1,2] <> mempty
12:59:12 <lambdabot>  [1,2]
12:59:15 <monochrom> works
12:59:38 <butterthebuddha> (btw is there a list of lambdabot's abilities somewhere)
12:59:54 <monochrom> I have long lost that list.
13:00:16 <philippD> also your `myMonoid` has a signature that isn't compatible with mappend.
13:00:54 <Taneb> @djinn a -> (((a -> r) -> r) -> r) -> r
13:00:54 <lambdabot> f a b = b (\ c -> c a)
13:01:04 <Taneb> @@ pl djinn a -> (((a -> r) -> r) -> r) -> r
13:01:04 <lambdabot>  pl djinn a -> (((a -> r) -> r) -> r) -> r
13:01:08 <Taneb> @@ @pl @djinn a -> (((a -> r) -> r) -> r) -> r
13:01:08 <lambdabot>  f = flip id . flip id
13:01:35 <monochrom> You can also think of it as flip ($) . flip ($)
13:02:03 <conn> butterthebuddha i read https://wiki.haskell.org/Monoid
13:02:32 <Taneb> monochrom: those are just two of my favourite things in lambdabot
13:02:42 <Taneb> (djinn and composition, I can take or leave pl)
13:03:30 <butterthebuddha> conn: The first thing to understand is that in Haskell, Monoid is a _typeclass_. Thus, instances of Monoid must be types.
13:04:07 <butterthebuddha> A good example of Monoid is the type [a]; another example is the type Maybe [a]
13:04:34 <butterthebuddha> (this can actually be generalized to Maybe a for any type a that implements Monoid)
13:04:39 <butterthebuddha> with me so far?
13:05:59 <conn> if [a] is my monoid can u give an example how to use it?
13:06:04 <zincy> Why can't * -> * be a monoid?
13:06:12 <monochrom> [1,2] <> mempty
13:06:23 <butterthebuddha> > [1,2] <> [3,4]
13:06:25 <lambdabot>  [1,2,3,4]
13:06:43 <Taneb> zincy: that's a kind error. "Maybe -> Maybe -> Maybe" isn't a type that makes sense
13:06:56 <butterthebuddha> zincy: Types of kind * -> * are not "concrete"
13:06:57 <zincy> Think of <> as an operator that works on an type that has a monoid instance.
13:07:23 <zincy> This means that if we change our code to use different monoids we don't need to alter our operators
13:07:26 <butterthebuddha> To be able to define mappend and mempty, you need access to elements of a type
13:07:44 <butterthebuddha> Types of kind * -> * don't have any elements
13:08:03 <zincy> :k StateT
13:08:05 <lambdabot> * -> (* -> *) -> * -> *
13:08:12 <zincy> :k State
13:08:14 <lambdabot> * -> * -> *
13:08:16 <Taneb> (I think it's not quite right to even call things with kind * -> * "types")
13:08:35 <zincy> Ah
13:08:43 <butterthebuddha> Yeah I suppose they aren't types in the conventional sense
13:08:47 <conn> Of course, every Monoid instance should actually be a monoid in the mathematical sense, which implies these laws:  mempty `mappend` x = x x `mappend` mempty = x (x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)
13:08:50 <zincy> So you cant combine sets of things that dont contain values
13:09:10 <zincy> :k State Int Int
13:09:12 <lambdabot> *
13:09:15 <butterthebuddha> zincy: Well
13:09:17 <dmwit> Different audiences/contexts will be more or less friendly to calling terms of kind * -> * "types".
13:09:28 <butterthebuddha> the way I would put it is that a type of kind * -> * is a "function"
13:09:38 <glguy> dmwit: Fortunately we're in #haskell
13:09:39 <zincy> So is it necessary but sufficient for monoid..  *
13:09:47 <butterthebuddha> So it's not that it's an empty type
13:09:58 <butterthebuddha> but that it doesn't make sense for a type of kind * -> * to have elements
13:10:01 <dmwit> I think even different subsets of #haskell will have differing opinions on this. So best to establish your convention explicitly.
13:10:10 <zincy> How not?
13:10:16 <glguy> We can just stick with the Haskell Report's use for now
13:10:31 <dmwit> Then things of kind * -> * are perfectly good types.
13:10:46 <monochrom> In that case there is not even such as thing as "typeclass".  It's "type class" in the Haskell Report. >:)
13:10:49 <plugin> So I have this 4gb csv I'm reading via Pipes.Parse and I don't know what encoding it uses.  If I use the default utf-8, I end up processing about 1/10th the total rows.  if I use latin, I process 99% of the rows, but values which are non-nullable are sometimes null and some columns have values they aren't allowed to.
13:10:56 <butterthebuddha> zincy: Let's think about Maybe
13:10:57 <butterthebuddha> Does it make sense for "Maybe" to have elements?
13:11:06 <zincy> Maybe a surely has an infinite set of possible values
13:11:23 <butterthebuddha> Yes, but "Maybe a" for any type "a" has kind *
13:11:26 <zincy> No Maybe has no values
13:11:26 <monochrom> zincy, I want Text to be an instance of Monoid, and Text's kind is *
13:12:05 <zincy> Ok you win :)
13:12:06 <butterthebuddha> zincy: I don't really have a concrete answer for you, maybe someone else can provide a better argument than "it just doesn't make sense"
13:12:59 <zincy> But I still feel slightly uncomfortable with whether Maybe has values. I am happy to say it doesnt have concrete values though
13:13:00 <dmwit> What is it that we're arguing?
13:13:01 <plugin> for kicks, I ran it through python's codec and rewrote it in utf-8.  now I'm parsing more of the lines but it looks like I have exponential computational blowup as the parsing goes on.  what gives?
13:13:11 <dmwit> zincy: There are no terms whose type is `Maybe`.
13:13:18 <zincy> Can Maybe be said in any sense to have values
13:13:19 <dmwit> zincy: (Not even `undefined`!)
13:13:21 <butterthebuddha> dmwit: I argue that it doesn't make sense for a type of kind "* -> *" to have values
13:13:32 <dmwit> Whether it makes sense is a completely different question.
13:13:40 <nitrix> zincy: You cannot have something of type `Maybe`, so there are no values (inhabitants).
13:13:50 <dmwit> But whether there are terms of such a type is an objective question, so I will focus on that one.
13:13:54 <nitrix> zincy: `Maybe` is a type constructor, it takes a type for argument.
13:14:02 <zincy> ok thanks
13:14:03 <butterthebuddha> I guess whether "it makes sense" comes down to your own personal beliefs
13:14:07 <glguy> Maybe is a type constructor , that tells us its capitalized
13:14:15 <glguy> its kind is * -> *, that tells us it takes an argument
13:14:19 <conn> butterthebuddha : if [a] type is a monoid then x = mappend [1,2] []    is a monoid ? since applying an empty list to a list does nothing
13:14:33 <dmwit> nitrix: (glguy's comments just there were aimed at you, I think. =)
13:14:52 <monochrom> conn, you are still conflating terms and types.
13:14:56 <butterthebuddha> conn: No, in that cacse x is _not_ a monoid; it's an element of the [a] Monoid
13:14:57 <butterthebuddha> Well, the [Integer] Monoid
13:15:10 <monochrom> Monoid is an adjective type types, not for terms.
13:15:27 <monochrom> It is as non-sensical as saying "15 is abelian".
13:15:35 <butterthebuddha> conn: You are also not actually giving a definition for mappend or mempty
13:15:43 <glguy> nitrix: Don't forget that Int is a type constructor and (Either Int) is not. Int has kind *, so it takes no arguments and the type Either Int has kind * -> *, so we know it does
13:15:46 <conn> haskell wiki says: 1.2 Examples The prototypical and perhaps most important example is lists, which form a monoid under concatenation:  instance Monoid [a] where   mempty = []   mappend x y = x ++ y   mconcat = concat
13:15:56 <butterthebuddha> conn: Maybe you need to read up some more/write some code that relates to typeclasses?
13:16:17 <zincy> :k Either Int
13:16:18 <lambdabot> * -> *
13:16:28 <zincy> How is that not a type constructor? :/
13:16:38 <butterthebuddha> zincy: it is
13:16:40 <glguy> because type constructor has nothing to do with kinds
13:16:51 <zincy> :o
13:16:52 <glguy> There are type constructors: Int Either Maybe, etc
13:16:52 <conn> butterthebuddha can you explain what haskell wiki menas by: lists which form a monoid under concatenation
13:16:56 <butterthebuddha> Well; I suppose
13:16:57 <glguy> and there are type variables: a b c proxy
13:17:13 <glguy> constructor vs variable is a lexical category
13:17:22 <dmwit> butterthebuddha: It isn't.
13:17:44 <butterthebuddha> conn: What that means is that the type [a] is Monoid, where "a" is a polymorphic type (i.e. it can be any type under the sun)
13:17:56 <glguy> where a is a type variable
13:17:58 <nitrix> Sarcasm doesn't play well when someone is actively asking for help. My coma should have been a period to not imply that one was related to the other, I'll accept my mistake there, but let's not confuse zincy.
13:18:14 <monochrom> conn: The sentence is referring to collection of all lists (not an individual list).
13:18:56 <butterthebuddha> dmwit: glguy: I suppose I have always considered things that have a kind that's not * to be type constructors too, but that's technically wrong
13:19:06 <glguy> yeah, that's just wrong
13:19:11 <monochrom> Just like the lone integer 15 is not abelian.  It is the collection of all integers, under addition, that's abelian.
13:19:13 <zincy> Who is being sarcastic?
13:19:13 <dmwit> butterthebuddha: Yep, it's a very common error.
13:19:31 <butterthebuddha> conn: again I suspect that you are confused because you don't understand typeclasses and you should attempt to understand those before you tackle Monoids
13:19:38 <zincy> So how do we identify type constructors?
13:19:46 <zincy> Unapplied type functions?
13:19:59 <glguy> Type constructors are capitalized and exist in the type namespace
13:20:08 <zincy> Oh nice and simple
13:20:29 <glguy> Value constructors are capitalized and exist in the value namespace: True, Just, etc
13:20:37 <zincy> Thanks
13:20:47 <glguy> we have special case for operators to behave like that, we prefix those with :
13:21:00 * hackage typenums 0.1.1 - Type level numbers using existing Nat functionality  http://hackage.haskell.org/package/typenums-0.1.1 (AdituV)
13:21:36 <zincy> So why is (Either Int) not a type constructor?
13:21:52 <butterthebuddha> So is using the State monad a good way to introduce global state to a program? I've never used it before
13:21:53 <glguy> it's a type expression formed from the application of one type identified by its type constructor to another
13:21:59 <butterthebuddha> zincy: "Either" is a type constructor
13:22:21 <butterthebuddha> ("Either" int) is a type constructor that takes two type arguments and has one of them applied
13:22:22 <monochrom> "type constructor" is a very syntactic notion, not a semantic notion.
13:22:25 <glguy> Either and Int are type constructors, (Either Int) is the application of Either to Int, it's a whole expression, not a name
13:22:31 <zincy> State monad doesn't give you global state does it?
13:22:34 <butterthebuddha> *not a type constructor
13:22:37 <monochrom> In other words only a parser would care.
13:22:54 <zincy> hahaha
13:22:59 <conn> butterthebuddha : typeclasses If a type is a part of a typeclass, that means that it supports and implements the behavior the typeclass describes.
13:24:04 <butterthebuddha> conn: Now, a Monoid is a *typeclass*; what this means is that if a thing X is a Monoid, then that thing X has to be a *type* and *cannot be a value*
13:24:35 <conn> you mean like 3 is and Integer type, X is an Monoid type ?
13:24:44 <nitrix> glguy: Curiously, if Either is a type constructor, accepting two concrete types, could (Either Bool) been seen as partial application of the constructor, giving us yet another type constructor, accepting only one concrete type this time?
13:25:02 <butterthebuddha> conn: 3 is an element of the Integer type, and the Integer type is a Monoid, yes
13:25:18 <nitrix> glguy: There should be a close relation to how Big Lambda works there.
13:25:30 <butterthebuddha> nitrix: I think it's like a matter of terminology?
13:25:36 <conn> so how can i make use of the Monoid type ?
13:25:41 <zincy> conn: Types can have instances of typeclasses
13:25:59 <zincy> conn: you define an instance of monoid for your type
13:26:46 <zincy> Look at the monoid instance for lists to get started
13:26:56 <butterthebuddha> conn: Monoid is one of the more abstract typeclasses; I don't know of any easy use cases that aren't stupid and forced for the sake of examples
13:27:09 <butterthebuddha> conn: But essentially, if a type implements a Monoid
13:27:14 <butterthebuddha> then you can "combine" elements of that type
13:27:26 <butterthebuddha> This gives you certain guarantees when working with types
13:27:45 <butterthebuddha> Typeclasses in general are all about "providing guarantees" about what you can do with a type
13:28:48 <jle`> wait what, easy monoid use cases come up all the time
13:29:03 <jle`> > mconcat ["hello", "world"]
13:29:05 <lambdabot>  "helloworld"
13:29:27 <monochrom> All type classes are abstract.
13:29:32 <zincy> <> is supposed to be associative but ...
13:29:36 <glguy> nitrix: No, it wouldn't make sense to think of Either Int being a new type constructor any more than  map succ is a new variable
13:29:46 <butterthebuddha> Yes, but what I meant was to illustrate the true power of Monoids
13:29:49 <zincy> [1] <> [2] == [2] <> [1]
13:30:02 <jle`> zincy: you might be thinking of commutativity
13:30:04 <butterthebuddha> zincy: that's commutativty and monoids don't satisfy that in general
13:30:11 <jle`> > ("hello" ++ "world") ++ "goodbye"
13:30:13 <lambdabot>  "helloworldgoodbye"
13:30:16 <butterthebuddha> I mean [1] <> [2] is kind of a stupid example
13:30:20 <butterthebuddha> When talking about Monoids
13:30:47 <nitrix> glguy: Not quite. map is a function, you partially apply an argument, you still obtain a function. Either a type constructor, you partially apply it, you should still obtain a type constructor. I mean, its kind allows currying, doesn't it?
13:30:51 <jle`> mconcat shows the power of monoids in a great way, i think
13:30:51 <monochrom> In that case I like to keep it stupid and simple so yeah it's stupid which is a good thing. :)
13:30:56 <butterthebuddha> A better use case would be a polymorphic function that needs to be able combine elements of a type
13:31:02 <jle`> yeah, like mconcat :)
13:31:02 <zincy> Why is it a stupid example?
13:31:06 <butterthebuddha> but doesn't care how the actual combining is done
13:31:49 <monochrom> In that case Monoid is a fairly simplistic class in the first place because <> is rather bland.
13:32:07 <jle`> i don't think it's a particularly stupid example
13:32:16 <monochrom> I mean, it is not even gropu theory.
13:32:20 <butterthebuddha> monochrom: What I meant was that Monoid is more abstract than Num and Ord which are inspired by everyday and elementary mathematical considerations
13:32:36 <conn> like this : data Mytype = Custom Int       then i make an instance for Mytype in Monoid class like :    instance Monoid Mytype where mempty = 0  mappend (Custom x) (Custom y) =  x + y.
13:32:38 <butterthebuddha> Regardless, the concept of a monoid is difficult for someone to grasp if one hasn't seen any rigorous math
13:32:51 <nitrix> glguy: Where is my understanding failing? What makes it not be a type constructor? Other than "no", what's the reason?
13:32:53 <jle`> is monoid really that difficult for people to grasp?
13:33:05 <zincy> butterthebuddha: I can understand monoids easily and I have never seen rigorous math
13:33:12 <jle`> conn: try (Custom 0) instead of 0
13:33:17 <electrocat> conn: no, the result should be of Mytype
13:33:19 <zincy> Its like the simplest typeclass out there
13:33:44 <monochrom> Monoid is inspired by strings and sequences which are everyday elementary programming considerations.  Hell did you know that Tcl is based on only one monoid --- strings?
13:33:46 <butterthebuddha> Well monoids and groups were certainly very unfamiliar for me
13:33:52 <butterthebuddha> and I had trouble seeing motivation
13:33:52 <jle`> i feel like most programmers especially have several examples of monoids that they run into every day
13:33:55 <butterthebuddha> until much later
13:34:08 <butterthebuddha> I suppose that's not the case for everybody
13:34:14 <jle`> mconcat is a good example, i think
13:34:22 <monochrom> Err I guess s/Tcl/shell scripts/ .  Tcl is based on lists in general.
13:34:27 <jle`> mconcat [] = mempty
13:34:32 <jle`> mconcat (x:xs) = x <> mconcat xs
13:34:45 <jle`> now any type that implements mempty and <> can use mconcat
13:35:16 <jle`> > mconcat ["hello","world","bye"]
13:35:19 <lambdabot>  "helloworldbye"
13:35:23 <jle`> > mconcat [Sum 3, Sum 10, Sum (-6)]
13:35:26 <lambdabot>  Sum {getSum = 7}
13:35:34 <jle`> > mconcat [Any True, Any False, Any False]
13:35:36 <lambdabot>  Any {getAny = True}
13:35:43 <monochrom> unfamiliar ≠ abstract
13:36:05 <monochrom> unfamilar = you didn't know someone gave it a name
13:36:23 <glguy> nitrix: instead of trying to redefine type constructor to match what you thought it will be better just to learn about what it is
13:36:54 <jle`> mconcat is an extremely powerful operation that can basically be used to unite many different things that we originalyl thought wer eall separate.
13:37:09 <jle`> nitrix: type constructors exist at the token level, not at the level of any actual semantic concepts
13:37:20 <zincy> glguy: So Type Constructor is just a semantic name for capitalised words in the type namespace?
13:37:41 <monochrom> "type constructor" is analogous to "data constructor" they are just for syntactic sake you don't go around saying "(:) True is a data constructor"
13:37:45 <zincy> So it only comprises one token
13:37:59 <zincy> monochrom: I do :)
13:38:05 <nitrix> Even at the token level, it's still valid for the instance declaration form, instance (a1, ..., an) => class t1 ... tm where ...
13:38:07 <jle`> yes, it's at the syntax level, not at the 'meaning' level
13:38:09 <monochrom> Yeah sure hehe
13:38:15 <nitrix> Since those are types, not type constructors.
13:38:45 <nitrix> I don't know what glgul knows that I don't know about type constructors, but I'd really like him explaining instead of playing a cat-and-mouse game.
13:38:59 <monochrom> I go by the Haskell Report but I understand that postmodernism is the norm.
13:39:18 <jle`> you might be confusing 'Just', the data constructor, with 'Just', the function
13:39:30 <zincy> nitrix: I think his explanation was sufficient for me
13:39:43 <jle`> Just is syntactically a data constructor, syntactically.  like a literal, almost
13:39:47 <nitrix> zincy: Cool! Still, I have questions of my own :)
13:39:51 <jle`> and as a value, you can use it like a function
13:39:53 <monochrom> What cat-and-mouse game? I didn't see any.
13:40:08 <jle`> 'Either' is syntactically a type constructor, but you can use it as a * -> * -> * to get a * -> *
13:40:15 <zincy> nitrix: Perhaps I dont understand it though hehe
13:40:21 <conn> jle`: i tried this: data Mytype = Custom Int deriving Show  instance Monoid Mytype where  mempty = (Custom 0)  mappend (Custom x) (Custom y) = Custom x  myMonoid = mappend (Custom 5) (Custom 6)  main = do  print $ myMonoid
13:40:38 <jle`> the concept of a "type consturctor" and a "* -> * -> *" thing are separate, we just use the letters E-i-t-h-e-r to get a "literal" for a * -> * -> *
13:40:50 <nitrix> I'm aware. Int is a valid type constructor.
13:40:57 <nitrix> Despite the `*` kind.
13:40:57 <zincy> conn: Have a look at http://lpaste.net/
13:41:08 <jle`> conn: nice :)
13:41:22 <jle`> that should work syntactically
13:41:32 <jle`> unfortunately the operation you defined is not monoidal/doesn't satisfy the laws
13:41:33 <electrocat> conn: not 'mappend (Custom x) (Custom y) = Custom (x + y)' ?
13:42:12 <nitrix> jle`: I'm aware. See above. But claiming (Either Bool) is not a type constructor is something else. Why would it not be? Exemples? Proofs? Anything substential?
13:42:22 <zincy> This is more of a general programming question but here goes the project is Haskell I promise
13:42:33 <zincy> How do you structure your messaging around game updates for a game server to its clients. Would you always send the entire game state to clients or would you ever send additional messages of in game occurrences despite the fact they are derivable from the entire game state?
13:42:36 <monochrom> Definition of "type constructor" in the Haskell Report.
13:42:38 <nitrix> Other than "No", which I find almost insulting. It's a polite request, I don't know why I'm being nagged.
13:42:55 <electrocat> it's not a type constructor, technically it's a type application
13:42:57 <conn> electrocat: thanks thats what i was looking to do
13:43:29 <jle`> nitrix: yes, that syntactical structure is an application between two type constructors
13:44:12 <jle`> "type constructor" is the name of a type of leaf of the abstract syntax tree
13:44:18 <jle`> that's not a leaf, that's a node
13:44:36 <raoult> could anyone please help me with HIE in VS Code? my issue is that I need to pass -fobject-code (which I specified in the cabal file) but at some point this flag seems to get lost
13:44:53 <raoult> so I'm getting an error saying that I need to enable -fobject code
13:45:03 <jle`> data TypeExpression = TypeApplication TypeExpression TypeExpression | TypeConstructor String
13:45:26 <raoult> I don't know what I can do besides specifying this flag in the cabal file, is there any other location I should be adding this flag or something?
13:45:27 <electrocat> don't forget TypeVariable :)
13:46:42 <monochrom> It really annoys me, nitrix.  glguy already typed in multiple sentences to explain why, long before you asked.  But you ignore most of them and just pick out the "no" part and claim he's not explaining.  You are the one insulting all his genuine effort.
13:46:54 <conn> jle` :  electrocat: now the code looks like this https://pastebin.com/118fZuN6 , is myMonoid a monoid now ?
13:46:58 <nitrix> Is (Either Bool Int) a type constructor then?
13:47:00 * hackage yaml-pretty-extras 0.0.2.1 - Extra functionality for pretty printing Yaml documents.  http://hackage.haskell.org/package/yaml-pretty-extras-0.0.2.1 (locallycompact)
13:47:12 <nitrix> The report surely says it is, a nullary type constructor.
13:47:24 <electrocat> conn: yep :)
13:47:32 <jle`> nitrix: no, it is Appl (Appl (TyCon "Either") (TyCon "Bool")) (TyCon "Int")
13:47:33 <electrocat> Mytype you mean
13:47:37 <electrocat> ah
13:47:40 <electrocat> myMonoid as well
13:47:48 <jle`> the structure of a type expression is in 4.1.2 of the 2010 report
13:47:49 <nitrix> 4.1.1p1 `The symbol * represents the kind of all nullary type constructors.`
13:48:16 <jle`> nitrix: that is true, those two facts are not mutually exclusive
13:48:18 <conn> electrocat: ok since Mytype is a monoid now, how could i use 2 monoids and make a new one with using the cartesian product ?
13:48:39 <jle`> that's saying "All nullary type constructors have kind *"
13:48:47 <jle`> it's not saying "All kind-* things are nullary type consturctors"
13:49:07 <nitrix> What?!
13:49:23 <monochrom> Haha that's new to me, but I am OK with it. :)
13:49:29 <parenthetical> I want to compile AST-like like data to some kind of hidden implementation like so https://lpaste.net/5494303520037273600 -- is this possible?
13:49:35 <jle`> in the next section 4.1.2 it defines exactly what a type constructor is
13:49:47 <nitrix> Type expressions have different kinds, which take one of two possible form. The symbol * represents the kind of all nullary type constructors.
13:49:56 <nitrix> That's literally from the report.
13:50:09 <nitrix> It's not the inverse... how that can be up for interpretation.
13:51:35 <conn> jle` any idea on how to use the cartesian product on two monoids to make a new monoid ?
13:52:14 <jle`> nitrix: hm, okay, yeah, i think there might be a contradiction here then betweeen 4.1.1 and 4.1.2
13:52:57 <jle`> unless "nullary type constructor" includes things that aren't type constructors
13:53:04 <monochrom> To be fair, when I say "X is the set of all even integers" I don't mean "ah sometimes irrational numbers are also included".
13:53:51 <jle`> that's different than saying "X includes all even integers" though; that's more of a superclass kind of statement
13:54:13 <jle`> 4.1.2 clearly defines what the haskell report calls a type constructor, and i guess it does contradict that bullet point in 4.1.1
13:55:02 <nitrix> jle`: I'm looking at every paragraphs and none of them seems to hint that (Either Bool) wouldn't be a type constructor.
13:55:16 <jle`> it doesn't fall under the tycon category
13:55:21 <jle`> in the table at the start of 4.1.2
13:55:29 <nitrix> `gtycon` ?
13:55:35 <jle`> a type consturctor is one of five categories
13:55:52 <jle`> a string of letters and numbers and apostrophes with the first letter capitalized
13:55:55 <jle`> ()
13:56:00 <monochrom> Yeah, gtycon and qtycon are the type constructors in the grammar.
13:56:04 <fishythefish> I'm not seeing the contradiction between 4.1.1 and 4.1.2
13:56:15 <jle`> [], (->), and (,) (,,) (,,,) family
13:56:15 <electrocat> conn: cartesian product of what? two lists?
13:56:38 <jle`> conn: try writing it, data P a b = P a b
13:56:43 <jle`> conn: instance Monoid (P a b) where ....
13:56:48 <fishythefish> conn: didn't butterthebuddha explain that earlier? do all the monoid operations componentwise
13:56:56 <conn> electrocat: i should use the cartesian product on two monoids and it should give me a monoid
13:57:09 <nitrix> monochrom: Except that what you're describing are tokens that matches a gtycon rule. Where is the connection between that syntax and the semantic meaning of type constructor in that report?
13:57:22 <nitrix> monochrom: Also, I'm trying to find `tycon` and I only find `gtycon`.
13:57:32 <jle`> nitrix: tycon is defined earlier
13:57:39 <jle`> nitrix: that's the point, though.  that there is *no* semantic meaning of a type constructor
13:57:48 <jle`> it doesn't exist at the semantic level, only at the syntactic level
13:57:54 <jle`> it is purely a syntactic construct, nothing more
13:58:03 <monochrom> Yeah
13:58:13 <conn> electrocat: how could i do this with my actual code
13:58:22 <electrocat> conn: product on the type level? that would be a tuple?
13:59:00 <jle`> nitrix: tycon is defined in 2.4, it has only one possible form/constructor
13:59:06 <jle`> "conid"
13:59:18 <jle`> tycon -> conid
13:59:27 <jle`> conid -> large {small|large|digit|'}
13:59:37 <conn> electrocat : make a tuple with list comprehension ? like [ (x,y) | x <- xs , y <- ys ]
14:00:01 <fishythefish> conn: you're working with Monoids, not lists
14:00:25 <jle`> the point that we're trying to make is that there is no such thing as a type constructor at the semantic level, it only exists at the syntactic/parsing/tokenization stage
14:00:30 <electrocat> conn: i just don't know what kind of semantics you're looking for
14:00:51 <zincy> A type constructor is literally a name for a token to represent a type right?
14:00:55 <jle`> there is no connection between the syntactic type consturctor and the semantic type constructor because the semantic type constructor doesn't exist
14:01:49 <jle`> zincy: yes
14:02:06 <monochrom> Well, the other token is type variable
14:02:26 <conn> electrocat: fishythefish: how could i apply the cartesian product on monoids in my actual code here, where Mytype is a monoid : https://pastebin.com/118fZuN6
14:03:13 <electrocat> conn: like [mappend x y | x <- xs, y <- ys] ?
14:03:29 <fishythefish> conn: none of what you have there is relevant; you need to write `instance (Monoid a, Monoid b) => Monoid (a, b) where ...`
14:05:03 <parenthetical> \
14:05:21 <jle`> conn: if X and Y are monoids, their cartesian product is (X,Y)
14:05:28 <nitrix> jle Except that 4.1.2p4 says "A parenthesized type, having form (t), is identical to the type t".
14:05:29 <jle`> conn: and (X,Y) also is a monoid
14:05:37 <nitrix> jle` ^
14:05:52 <conn> fishythefish: explain further please, like this: instance (Monoid a, Monoid b) => Monoid (a, b) where  mempty = (mempty, mempty)  mappend (Monoid a, Monoid b) = ?
14:06:03 <jle`> conn: mappend (x,y) = ....
14:06:04 <fishythefish> conn: yes
14:06:14 <fishythefish> except you need to write mappend (x, y) =
14:06:17 <jle`> nitrix: what is that in response to?
14:06:23 <fishythefish> you don't pattern match on `(Monoid a, Monoid b)`
14:07:05 <electrocat> not sure if he wants a product type of a value :p
14:07:19 <nitrix> jle` It appears (Either Bool) isn't a type constructor because it doesn't match the criteria that the syntax wants it to begin with an uppercase letter, but then there's this axiom that says `(t)` is the same as `t`.
14:07:22 <fishythefish> electrocat: his original question was how can the cartesian product of two monoids be a monoid
14:07:25 <monochrom> Yeah what is "cartesian product"?
14:07:44 <fishythefish> nitrix: yes, so (Either Bool) is the same as Either Bool as a type expression; that doesn't make it a type constructor
14:07:50 <jle`> yeah the full rules are:
14:07:53 <jle`> conid -> large {small|large|digit|'}
14:07:58 <jle`> so spaces are disallowed
14:08:34 <jle`> just 'small' letters, 'large' letters, digits, and '
14:08:42 <nitrix> I ran out of options to refute it.
14:08:48 <conn> fishythefish: now i get this error : Duplicate instance declarations:       instance (Monoid a, Monoid b) => Monoid (a, b)
14:09:00 <fishythefish> trying to refute definitions tends to do that :P
14:09:07 <electrocat> conn: it's already defined
14:09:09 <fishythefish> conn: that's because it's already defined in the standard libas
14:09:11 <fishythefish> libs*
14:09:16 <jle`> conn: yeah, the instance already exists, so if you want to practice it, you'll have to define your own cartesiaon product type
14:09:31 <jle`> data (a :X b) = a :X b
14:09:52 <jle`> or just data CartProd a b = CP ab
14:09:54 <fishythefish> you can write `data Pair a b = Pair a b` and `instance (Monoid a, Monoid b) => Monoid (Pair a b) where ...`
14:10:46 <monochrom> Friday is bad for programming.
14:11:00 <nitrix> jle` monochrom Seems like the Haskell Report supports the claim, I can't find anything else that justify me hanging onto that old idea. I appreciate your time, both of you.
14:11:13 <monochrom> You're welcome.
14:11:16 <dysfun> days ending in a y are bad for programming
14:11:17 <jle`> no problem :)
14:12:16 <fishythefish> jle`: btw, I don't think that bullet point in 4.1.1 leads to a contradiction
14:12:36 <fishythefish> * is the kind of all nullary type constructors, but not everything with kind * must be a nullary type constructor
14:12:52 <jle`> that's what i initially said
14:12:59 <monochrom> Yeah, but like I said, what do you make of "the set of all even integers"?
14:12:59 <jle`> but the paragraph above that says that there are only two categories of kinds
14:13:18 <jle`> so things that are kind * and not nullary type constructors...where are they covered?
14:13:26 <jle`> the paragraph above claims that the two bullet points are an exhaustive list
14:13:41 <fishythefish> ah, but the bullet points aren't classifying those things
14:13:45 <fishythefish> it's classifying the kinds they can have
14:14:06 <fishythefish> bullet point 1 is the base case, and bullet point 2 tells you how to apply an arrow kind
14:14:33 <jle`> hm, i see
14:14:38 <jle`> it might be more clearly written then
14:14:52 <Guest52948> I'm trying to get scotty to beam me up, but GHC seems to ignore the OverloadedStrings pragma...
14:14:54 <jle`> - The symbol *, which represents the kind of things including nullary type constructors
14:15:06 <electrocat> i'm not sure what this tycon disagreement is about :p
14:15:10 <jle`> - Their arrowing, * -> *, which represents the kinds of things...
14:15:23 <jle`> electrocat: welcome to #haskell ;)
14:15:43 <jle`> it reminds me of traffic wave theory
14:15:55 <fishythefish> jle`: perhaps, but I'm reading it more as a set of axioms
14:16:03 <fishythefish> we can axiomatically take nullary type constructors to have kind *
14:16:16 <fishythefish> bullet point 2 says that we can get other things of kind * via type application
14:16:24 <jle`> ah i see
14:16:37 <jle`> that sounds like the right way to read that
14:16:53 <jle`> or at least, the reading that the authors had intended
14:16:56 <conn> fishythefish: something like this ? data Pair a b = Pair a b  instance (Monoid a, Monoid b) => Monoid (Pair a b) where  mempty = (Pair mempty, mempty)  mappend (x, y) = (Pair x, y)
14:17:16 <jle`> conn: note that you aren't doing anything involving tuples anymore
14:17:20 <fishythefish> conn: almost, but you need `mappend (Pair x y)` since we're not matching tuples anymore
14:17:30 <Taneb> Guest52948: how are you passing the pragma?
14:17:33 <jle`> conn: are you familiar with ADT's ?
14:17:34 <fishythefish> similarly, mempty = Pair _ _, fill in the blanks
14:17:41 <jle`> @let data Pair a b = Pair a b deriving Show
14:17:43 <lambdabot>  Defined.
14:17:44 <jle`> > Pair 3 '5'
14:17:46 <electrocat> jle`: is it purely about how the report should be interpeted? :p
14:17:46 <lambdabot>  Pair 3 '5'
14:17:57 <Guest52948> Taneb: {-# LANGUAGE OverloadedStrings #-} at top of the file
14:17:57 <jle`> ^ that's how you make a Pair, not (Pair 3, '5')
14:18:13 <Taneb> Guest52948: hmm, odd
14:18:15 <conn> jle` not familiar with ADT
14:18:24 <jle`> conn: do you know types like Maybe?
14:18:28 <jle`> Either, lists?
14:18:36 <Taneb> Guest52948: what type are you expecting the overloaded strings to be?
14:18:50 <conn> fishythefish: got this error : Couldn't match expected type ‘Pair a b’                 with actual type ‘(b0 -> Pair a0 b0, t0)’
14:19:07 <Guest52948> Taneb: The functions expect Text, but the actual types keep remaining String
14:19:09 <jle`> conn: do you know the 'Maybe' type, data Maybe a = Nothing | Just a
14:19:17 <fishythefish> conn: did you fix *all* the appearances of tuples?
14:19:27 <fr33domlover> data T a b = A a | B b is type application too though, right? "Type application" refers to the left side of the = not the right side
14:19:29 <Taneb> Guest52948: what happens if you also enable the NoMonomorphismRestriction extension?
14:19:29 <jle`> Guest52948: OverloadedStrings doesn't implicitly convert all strings to Text
14:19:29 <fishythefish> conn: you should only have `Pair`s, no tuples anywhere
14:19:50 <Guest52948> Taneb: hmm let me try
14:20:03 <conn> fishythefish: thats the code now https://pastebin.com/tAkFE0JC
14:20:06 <jle`> Guest52948: so if you have a value that has type String, it won't be converted to Text automatically
14:20:22 <jle`> Guest52948: OverloadedStrings is actually really OverloadedStringLiterals
14:20:25 <fishythefish> conn: the problem is that the RHS of mappend and mempty is still written incorrectly
14:20:49 <Guest52948> Taneb: still the same
14:20:54 <jle`> Guest52948: it doesn't automatically convert any strings to texts, it just interprets the letters `"hello"` as a Text *literal*
14:21:04 <fishythefish> conn: mappend also needs to take 2 arguments, not 1
14:21:08 <jle`> Guest52948: it only applies to literals you type into your source code
14:21:36 <fr33domlover> :t pack
14:21:38 <lambdabot> error:
14:21:38 <lambdabot>     • Variable not in scope: pack
14:21:38 <lambdabot>     • Perhaps you meant one of these:
14:21:44 <Taneb> Guest52948: then remove the extension and listen to jle`
14:21:46 <jle`> Guest52948: can you paste your code maybe?  it's hard to see exactly what's going on without seeing code :)
14:21:50 <Guest52948> :jle` I thought it'd "polymorphise" string literals...
14:21:58 <electrocat> Guest52948: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overloaded-string-literals
14:21:59 <Taneb> (I mean, remove NoMonomorphismRestriction)
14:22:01 <jle`> Guest52948: yes, that's what it does
14:22:05 <jle`> Guest52948: it polymorphises the literals
14:22:10 <jle`> Guest52948: it doesn't polymorphise String in general
14:22:22 <jle`> so if you have a value (x :: String), you can't pass x to a function expecting Text
14:22:31 <monochrom> It doesn't polymorphize variables or compound expressions.
14:22:44 <justSomeGuy_> Hey all, anybody willing to help out a new haskeller persistent and spock?
14:22:54 <jle`> Guest52948: it's hard to really see what's going on without seeing the code :)
14:23:02 <Guest52948> jle`: I'm simply passing a "..." literal to a function that expects Text
14:23:02 <jle`> justSomeGuy_: don't ask to ask, just ask :)
14:23:16 <monochrom> OK show code.
14:23:25 <jle`> Guest52948: ah, okay. then there's no other way we can help without seeing code
14:23:27 <Guest52948> it's the main example from scotty... hold on
14:23:32 <conn> mappend (Pair m n) (Pair x y) = ?
14:23:38 <Guest52948> http://hackage.haskell.org/package/scotty
14:23:40 <fishythefish> conn: good, now write the RHS
14:23:55 <jle`> Guest52948: what's the error?
14:24:14 <Guest52948> couldn't match expected type Text with actual type [Char]
14:24:35 <jle`> on what line?
14:24:43 <jle`> (what's the full error message?)
14:24:48 <jle`> @where lpaste
14:24:48 <lambdabot> http://lpaste.net/
14:25:25 <Guest52948> scotty.hs:13:7: error:     • Couldn't match expected type ‘RoutePattern’                   with actual type ‘[Char]’     • In the first argument of ‘get’, namely ‘"/:word"’       In the expression: get "/:word"       In a stmt of a 'do' block:         get "/:word"           $ do beam <- param "word"                lift (putStrLn "hello")                html $ mconcat ["<h1>Scotty, ", beam, ....]    | 13 |   get 
14:25:28 <Guest52948> oops
14:26:05 <Guest52948> it's complaining about all lines with a string literal in them...
14:26:06 <jle`> can you paste the file you are running too?
14:26:11 <jle`> it looks like it's different than the example code
14:26:35 <Guest52948>  {-# LANGUGAGE OverloadedStrings #-}  {-# LANGUAGE NoMonomorphismRestriction #-}    module Scotty where      import Web.Scotty    import Data.Monoid (mconcat)  import Data.Text.Internal.Lazy    main = scotty 3000 $ do    get "/:word" $ do      beam <- param "word"      lift (putStrLn "hello")      html $        mconcat ["<h1>Scotty, ", beam, " me up!<h1>"]
14:26:40 <fishythefish> @where lpaste
14:26:40 <lambdabot> http://lpaste.net/
14:26:50 <jle`> LANGUGAGE
14:27:04 <Guest52948> oh my
14:27:05 <electrocat> LANGUGAGE :p
14:27:32 <Guest52948> no compile error in pragmas then...
14:27:40 <jle`> pragmas are just normal comments
14:27:40 <monochrom> See how much time could have been saved if you showed actual code
14:27:50 <jle`> {-# blah blah blah #-} is syntax for haskell comments :)
14:27:55 <Guest52948> monochrom: yeah...
14:28:03 <conn> fishythefish: not sure how could i make it ? mappend (Pair m n) (Pair x y) = Pair m n
14:28:03 <jle`> and yeah, that's why it's good practice to start the question with code and full error :)
14:28:09 <[exa]> I always thought that the # inside turns on somehow mandatory pragma parsing
14:28:18 <Guest52948> jle`: I didn't know that...
14:28:26 <jle`> [exa]: it's a warning i believe
14:28:26 <Guest52948> jle`: thanks
14:28:30 <monochrom> And yes unregconized pragmas are silently ignored.
14:28:31 <jle`> Guest52948: no problem :)
14:28:34 <fishythefish> conn: m and x are elements of the same monoid, n and y are elements of the same monoid
14:28:36 <[exa]> interesting
14:28:46 <fishythefish> conn: how would you interpret (1, 2) + (3, 4), for exampel?
14:28:46 <dukedave> What's a terse way to write a `chars` function which would turn `"foo"` in to `["f","o","o"]` ?
14:28:48 <fishythefish> example*
14:29:00 <jle`> > map (:[]) "foo"
14:29:02 <lambdabot>  ["f","o","o"]
14:29:08 <jle`> the trusty ol' robot monkey operator
14:29:19 <dukedave> Arg, I was so close, thanks @jle` !
14:29:34 <jle`> np :)
14:29:47 <electrocat> monkey operator :p
14:30:04 <dukedave> Ha, I see it now :)
14:30:44 <conn> fishythefish: interpret ? (1,2,3,4) ?
14:31:16 <fishythefish> conn: well, for it to be a monoid, the output type must be the same as the input type
14:31:44 <jle`> conn: what do you think the mappending operation for (Sum 3, "hello") <> (Sum 4, "world") should be?
14:31:46 <reygoch> Is it possible to print out full record type? I'd like to do something like :t undefined::MyRecord and get all fields form MyRecord with their types listed.
14:31:49 <fishythefish> (think of how you add vectors)
14:31:56 <jle`> what should the result be?  it has to also be (Sum Int, String)
14:32:24 <conn> fishythefish: mappend (Pair m n) (Pair x y) = Pair m y
14:32:30 <jle`> reygoch: it is possible with GHC Generics, but it's not a function people have written i think
14:32:47 <jle`> there's no built-in that directly does that, even though it's possible to write it yourself
14:32:54 <jle`> (that works for all records)
14:33:02 <monochrom> Is "info MyRecord" enough?
14:33:02 <fishythefish> conn: that doesn't satisfy the monoid laws but does typecheck
14:33:06 <reygoch> yes, I assumed it is possible with generics, but I was hoping for a ready solution
14:33:10 <monochrom> err, ":info MyRecord"
14:33:14 <justSomeGuy_> I'm trying to setup a basic endpoint which takes an id and goes through a join table to return all joined records  get ("songs" <//> var) $ \id -> do   song <- getRecord404 $ SongKey id   tags <- runSQL $ select $     from $ \(tag `InnerJoin` songTag) -> do       on (songTag ^. SongTagTagId ==. tag ^. TagId)       where_ (songTag ^. SongTagSongId ==. val (SongKey id))       return (tag)   json $ object ["song" .= song, "tags" 
14:33:20 <justSomeGuy_> oh god
14:33:24 <fishythefish> where @lpaste
14:33:26 <fishythefish> @where lpaste
14:33:26 <lambdabot> http://lpaste.net/
14:33:33 <jle`> ah yeah, i forgot ghci was magical :)
14:33:36 <reygoch> monochrom: no, I'm using type classes and type parameters so I want to see the resulting type
14:34:17 <justSomeGuy_> okay here's a writeup of my question: https://lpaste.net/9032809779654819840
14:34:25 <conn> jle`: [(Sum 3, Sum 4, "wold") , ("hello", Sum 4, "world") ]
14:34:36 <jle`> conn: remember the type has to also be (Sum Int, String)
14:34:40 <jle`> not [(...)]
14:35:07 <monochrom> I do think that [(Sum 3, Sum 4, "wold") , ("hello", Sum 4, "world") ] is a type error
14:35:16 <jle`> i think you might be misinterpreting 'cartesian product' in this context
14:36:17 <conn> fishythefish: how would i make it satisfy the monoid laws ?
14:36:19 <fishythefish> conn: you don't need to compute the cartesian product of the inputs - tuples/pairs are already cartesian products of their components
14:36:31 <fishythefish> you're trying to define a notion of combining them (componentwise)
14:37:00 <fishythefish> conn: for one thing, make sure that mempty acts as a left and right identity for mappend
14:37:31 <jle`> conn: try trying out things that typecheck, and try different things until they satisfy the laws
14:37:34 <monochrom> I did use "cartesian product" to refer to liftA2 f xs ys in my course. :)
14:37:40 <jle`> for examplke, here is one typechecking definition:
14:37:54 <jle`> mappend (Pair x1 y1) (Pair x2 y2) = Pair x1 y1
14:38:01 <jle`> do you see why that typechecks?
14:38:08 <jle`> s/why/that
14:38:21 <jle`> and then, can you check if it obeys the laws?
14:39:05 <conn> fishythefish : instance (Monoid a, Monoid b) => Monoid (Pair a b) where  mempty = Pair mempty mempty  mappend (Pair m n) (Pair x y) = Pair m y
14:39:19 <jle`> right, that typechecks :)
14:39:25 <jle`> now, can you check if it follows the laws?
14:39:36 <conn> this compiles but mappend still needs to be written correctly
14:39:40 <fishythefish> yes
14:39:42 <jle`> here's an example to try:
14:39:54 <jle`> (Pair (Sum 3) "hello") <> mempty
14:40:02 <jle`> the answer *should* be (Pair (Sum 3) "hello")
14:40:05 <jle`> since x <> mempty = x
14:40:09 <fishythefish> `Pair 1 2 <> Pair 0 0` yields `Pair 1 0`, so that violates the laws
14:40:09 <jle`> but, what does your instance give you?
14:42:01 <jle`> (try it out on ghci :) )
14:46:57 <conn> jle`: i tried this: let test = (Pair "hello" "abc") `mappend` mempty print $ test   and output is: Pair "hello" ""
14:50:12 <conn> fishythefish : now mappend works only if Pair contains strings but not with numbers like Pair 1 2
14:50:16 <athan> Hey yall, how's everyone doing
14:50:43 <fishythefish> conn: are you talking about typechecking or correctness?
14:51:45 <conn> fishythefish: let test = (Pair "hello" "abc") `mappend` mempty print $ test let test2 = (Pair 1 2) `mappend` mempty print $ test2     , test works , test2 doesnt
14:52:24 <fishythefish> conn: and what do you mean by "works" and "doesn't"? what's the output?
14:52:43 <fishythefish> :t print
14:52:44 <lambdabot> Show a => a -> IO ()
14:53:27 <athan> shoot, did I get kicked? Sorry for the spam
14:53:30 <conn> fishythefish: output on test is: Pair "hello" "",   test2 gives error: No instance for (Num a0) arising from the literal ‘1’     The type variable ‘a0’ is ambiguous
14:53:41 <athan> if you were a one-stop-shop method to normalizing arbitrary images to a specific type (say, PNG), how would you do it? I was considering juicypixels or an imagemagick binding or something
14:54:34 <fishythefish> okay, so test typechecks but still has incorrect behavior, and test2 is failing to typecheck
14:54:49 <[exa]> athan: juicypixels is good if you want to run the image data through haskell's rts; I'd go with imagemagick if you don't need them
14:55:21 <athan> [exa]: Yeah I just want to turn `forall a. SomeKindaImageFormat a => a -> PNG` or something
14:55:22 <[exa]> athan: your connection seems to be dying a bit (reset by peer last tiem)
14:55:32 <athan> ahh, darn starbucks thwarting my efforts
14:55:59 <[exa]> why not hip?
14:56:04 <athan> hip? Hm
14:56:05 <conn> fishythefish: see the code now https://pastebin.com/AtPhe25n
14:56:58 <dukedave> @pl     parseTile l =  L.find ((==) l . show ) [Straight ..]
14:56:58 <lambdabot> parseTile = flip L.find [Straight..] . (. show) . (==)
14:57:09 <dukedave> ... is melting my brain :\
14:57:26 <[exa]> athan: it has many formats, doesn't unnecessarily unpack the data (iirc) and 'downsample' is here https://hackage.haskell.org/package/hip-1.5.3.0/docs/Graphics-Image-Processing.html
14:58:52 <athan> [exa]: hmm, I think I had better go with an imagemagick binding - this is for a production server
14:58:58 <athan> thank you for the suggestion though
14:59:01 <[exa]> dukedave: you can simplify that a bit by moving the show right to the list, like: ... = L.find ((==) l) (map show [Straight..])
14:59:19 <fishythefish> conn: right, so the type error is because literals like 1 and 2 are polymorphic and ghci doesn't know which instance of Num to use in order to show the result
14:59:23 <fishythefish> conn: try `Pair (1::Sum Int) (2 :: Sum Int) <> mempty`
14:59:41 <butterthebuddha> The process run by "createProcess" is printing after the haskell program has finished printing; is there a way to force the program to finish execution resuming with the haskell program?
15:00:25 <orion> https://gist.github.com/centromere/e229850efbbb276514a75c97cfe37691 <-- How do I specify that I want to use the default implementation for runFoo here?
15:00:37 <dukedave> [exa]: unfortunately that won't work because I want to find `Straight`, and not `show Straight`
15:00:57 <[exa]> athan: avoiding dependencies? if you're going for stability I'd generally avoid the glue layers to differently-managed packages
15:00:59 <fishythefish> butterthebuddha: waitForProcess?
15:01:43 <[exa]> dukedave: oh it returns the plain thing, yes. Sorry :]
15:02:22 <conn> fishythefish: output is: Pair (Sum {getSum = 1}) (Sum {getSum = 0})
15:02:34 <fishythefish> conn: yes, so it typechecks but gives you an incorrect answer
15:02:38 <[exa]> anyway that @pl is cool
15:03:16 <conn> fishythefish: incorrect answer is because my instance of mempty = Pair mempty mempty  mappend (Pair m n) (Pair x y) = Pair m y ?
15:03:25 <fishythefish> conn: mappend is incorrect
15:03:42 <conn> fishythefish: how could i correct it?
15:04:35 <fishythefish> conn: imagine `Pair` represents a vector: e.g. Pair 1 2 represents going 1 unit in the x direction (right) and 2 units in the y direction (up). How would you add two vectors? Pair 1 2 + Pair 3 4
15:04:36 <geekosaur> butterthebuddha, without context… if you are feeding data to a process, you also want to close the Handle you're using before waiting for the process to exit, so it knows you've finished
15:05:34 <athan> [exa]: moreso memory overhead - I never know how haskell's stack could blow, unless I'm using something like conduit
15:05:37 <conn> Pair 1+3 2+4
15:05:49 <athan> I also just feel like if the binding is somewhat sane, it shouldn't be too bad
15:05:51 <fishythefish> conn: exactly. Now do something similar with your implementation
15:06:01 <fishythefish> only instead of +, it's mappend
15:06:03 <athan> idk if I could store directly with imagemagick - we'll see
15:07:16 <conn> fishythefish: mappend (Pair m n) (Pair x y) = Pair (mappend m x) (mappend n y)
15:07:24 <fishythefish> conn: excellent
15:07:56 <conn> fishythefish: it compiles and output is: Pair (Sum {getSum = 1}) (Sum {getSum = 2})
15:08:08 <fishythefish> conn: and does that make sense?
15:08:44 <conn> fishythefish: mathematically i think yes, because the identity memoty doesnt change the inout ?
15:08:51 <fishythefish> right
15:09:26 <conn> fishythefish: now this code impelemnts the behavior of the cartesian product on two monoids ?
15:09:52 <fishythefish> conn: this code says that the cartesian product of two monoids can itself be considered a monoid
15:10:03 <fishythefish> the `Pair a b` construction is the cartesian product itself
15:10:22 <fishythefish> and the `(Monoid a, Monoid b)` constraints tell us that the components of our product are themselves monoids
15:12:28 <athan> shoot I'll just use `magick convert`
15:12:34 <conn> fishythefish: thats what i needed ! now the task says: Prove that the cartesian product of two monoids again is a monoid!   So is the code i wrote the solution?
15:13:07 <fishythefish> conn: well, not really
15:13:19 <fishythefish> you've shown that you can write an instance that typechecks
15:13:35 <fishythefish> but verifying that the implementation satisfies the Monoid laws is something you have to do independently
15:13:47 <conn> fishythefish: i need to write a mathematical proof based on the code ?
15:13:48 <fishythefish> that's more a mathematical exercise than a programmatic one
15:14:04 <fishythefish> conn: no, you can write a mathematical proof without any code at all
15:14:31 <fishythefish> really, the code should be based on the math
15:14:57 <conn> fishythefish: so i need to write a proof without any haskell code? or extend my code so it satisfies the monoid laws ?
15:15:24 <fishythefish> conn: your code already satisfies the monoid laws, but the typechecker does not verify that proof for you
15:15:44 <fishythefish> you need to argue separately that it satisfies the monoid laws, because we've already seen you can write an implementation which violates them but still typechecks
15:16:23 <conn> fishythefish: how would i argue any example ?
15:17:08 <fishythefish> conn: you need to show that mempty is a left identity, that mempty is a right identity, and that mappend is associative
15:19:53 <fishythefish> conn: i.e. show that `Pair a b <> mempty == Pair a b`, `mempty <> Pair a b == Pair a b`, and `Pair a b <> (Pair c d <> Pair e f) == (Pair a b <> Pair c d) <> Pair e f`
15:20:07 <fishythefish> you just need to perform simplification and apply the underlying Monoid instances you already have
15:21:33 <conn> fishythefish: this is like the mathematical laws of monoids : -- Identity laws x <> mempty = x mempty <> x = x   -- Associativity (x <> y) <> z = x <> (y <> z)
15:21:45 <fishythefish> conn: precisely
15:23:55 <conn> fishythefish: now i so ehow write a proof by induction for this laws applied on my code ?
15:24:16 <fishythefish> conn: you shouldn't need induction
15:26:30 <maerwald> any good unicode plugin for vim haskell
15:28:41 <conn> fishythefish: could i do it like this for every law write: Pair x y and the output of it ?
15:29:20 <fishythefish> conn: not sure what you mean. `Pair x y` doesn't really have output
15:29:42 <Tordek> conn: you prove it by manually applying your code and explaining how it behaves. e.g., id law 1 => x <> mempty = x => (Pair a b) <> (Pair 0 0) = Pair (a+0) (b+0) = Pair a b
15:30:15 <fishythefish> conn: in your mathematical formulation, you can replace `x` with `Pair a b`, `y` with `Pair c d`, and `z` with `Pair e f` and verify that you do get equalities
15:32:18 <Tordek> (Or, more genereally,  ... <> (Pair mempty mempty) => Pair (x <> mempty) (y <> mempty), and by id property that's Pair x y
15:32:37 <Tordek> repeat (applying relevant rules in each step) for all properties
15:37:50 <conn> fishythefish: you mean like this ? https://pastebin.com/fCXE5bSd
15:41:18 <Tordek>  conn: that's not proving anything, you're just stating the laws
15:42:07 <conn> Tordek: how would i prove the first law ? add an example ?
15:42:21 <Tordek> read what I said above
15:43:43 <conn> Tordek: ok thanks for the hint, ill try to rewrite it now
16:11:09 <conn> Tordek: how about this ? https://pastebin.com/khmz4GVj
16:12:00 * hackage forkable-monad 0.2.0.0 - An implementation of forkIO for monad stacks.  http://hackage.haskell.org/package/forkable-monad-0.2.0.0 (mpahrens)
16:12:30 * hackage forkable-monad 0.2.0.1 - An implementation of forkIO for monad stacks.  http://hackage.haskell.org/package/forkable-monad-0.2.0.1 (mpahrens)
16:13:37 <Tordek> conn: I made an amendmwnt after my first example: you shouldn't use 0/+ but mempty/<> since your type is meant to work on monoids, not just numbers
16:14:30 * hackage forkable-monad 0.2.0.2 - An implementation of forkIO for monad stacks.  http://hackage.haskell.org/package/forkable-monad-0.2.0.2 (mpahrens)
16:15:56 <Tordek> in the case of proof of assoc, the best way is to evaluate each side separately and prove the result is the same
16:16:28 <conn> Tordek: niw change the 0 to mempty and =
16:16:38 <conn> and + to <>
16:19:03 <Tordek> conn: the point is that you're starting from your own definitions: mempty = Pair mempty mempty; mappend (Pair m n) (Pair x y) = Pair (mappend m x) (mappend n y)
16:19:11 <Tordek> and applying them:
16:20:06 <Tordek> x <> mempty => (Pair m n) <> (Pair mempty mempty) <- I've replaced x for an arbitrary instance of Pair, and just "evaluated" mempty; replaced it by its contents
16:21:13 <Tordek> next step is to evaluate <>, just from your definitions, and you've defined it such that (Pair m n) <> (Pair mempty mempty) = Pair (mappend m mempty) (mappend n mempty)
16:22:22 <Tordek> now you exploit the id property of whatever the inner monoid is (you know it's a monoid because you've declared your type to work on monoids), and since mappend m empty = m, those expressions evaluate as Pair m n
16:23:10 <Tordek> and since (Pair m n) <> mempty = [..steps..] = Pair m n, using only your definitions or the proofs of the other entities, you've proved it
16:23:53 <Tordek> be careful with your parentheses, however; Pair m n <> Pair x y is NOT the same as (Pair m n) <> (Pair x y)
16:25:50 <Tordek> since you're proving properties, remember in each step to be clear and deliberate, not just to write everything in a single line: explain "this transformation is valid because of this definition"
16:37:10 <Tordek> https://lpaste.net/242062093354795008 conn here's a more complete example of the first proof
16:54:41 <conn> Tordek: for the first law like this ? https://pastebin.com/vY2MYYUr
16:59:03 <Tordek> conn: better; now do associativity :)
16:59:08 <Tuplanolla> I see a familiar name.
16:59:14 <Tordek> hey tup
17:00:12 <Tuplanolla> Good to see you join our cult.
17:00:13 <conn> Tordek: thanks! ok ill rewrite it now
17:00:48 <rotaerk> hmm think I realized why regions isn't all that nice to use, compared to resourcet
17:00:57 <Tordek> conn: the clearest way is probably gonna be... "a <> (b <> c) = [... steps ..] = result; (a <> b) <> c) = [..steps..] = result, result=result, therefore a<>(b<>c) =...
17:01:41 <rotaerk> with regions, your resources are wrapped inside something to prevent them from escaping, so there need to wrappers for all the functions that use those resources too
17:01:53 <c_wraith> rotaerk, the type tricks it uses are less pleasant to use than the lack of type tricks in resourcet
17:03:31 <rotaerk> the type tricks I can imagine getting used to, but the fact that every type of resource you might want to use regions with has to have regions-infected libraries is pretty much a deal breaker
17:04:16 <c_wraith> well, that's basically required by the type tricks.
17:04:28 <c_wraith> which was my point.
17:04:37 <rotaerk> k
17:14:00 * hackage butter 0.1.0.2 - Monad Transformer for Asyncronous Message Passing  http://hackage.haskell.org/package/butter-0.1.0.2 (mpahrens)
17:19:29 <conn> Tordek: see now associativity https://pastebin.com/4DHwarqy
17:21:06 <Tordek> Pair ace bdf -- by Associativity property this is lazy and incomplete (even though technically correct)
17:21:46 <conn> Tordek: i just used the output of my compile ;) what would be better there ?
17:22:26 <Tordek> conn: the explicit step of Pair((a<>c)<>e) [...] = Pair(a<>(c<>e))...
17:22:39 <patlv> hi all, is there an easy way to convert between Data.ByteString.Lazy.Internal.ByteString  and Data.ByteString.Internal?
17:22:40 <Tordek> and _then_ they're equal because of associativity
17:23:29 <patlv> any pointer welcome, those different bytestring formats are killing me
17:27:20 <conn> Tordek: mean like this ? ( (Pair (mappend (mappend a c) e) (mappend (mappend b d) f) ) ) =
17:28:36 <Tordek> sure; but mappend is the same as <>, the latter is just shorter and infix
17:33:45 <conn> Tordek: ok see now improved associativity https://pastebin.com/7axi0sMr
17:36:08 <truthadjustr> need help. Could not import 'Data.Vector'. I tried `cabal install -p --reinstall --force-reinstalls vector` but to no avail
17:36:36 <geekosaur> what exactly are you doing? importing into ghci?
17:36:37 <truthadjustr> i'm using the Docker 'haskell' image
17:36:55 <zachk> patlv import them qualified and use like BS.pack . BSL.unpack $ lazybytestring
17:37:09 <zachk> to convert between the two
17:37:23 <truthadjustr> geekosaur: trying to compile 'https://github.com/OlivierNicole/haskell-chess.git'
17:39:27 <patlv> zachk gonna try, thx!
17:44:54 <conn> Tordek: https://pastebin.com/bEsiubUs
17:45:17 <Tordek> lol the url
17:45:59 <Tordek> also, in a minute, I'm eatibg :)
17:46:59 <conn> Tordek: ok ;)
17:56:46 <Tordek> conn: I'm not a fan of this line "Pair ace bdf -- by Associativity property" even though it's not, strictly speaking, wrong; however I'd just go with... ( (Pair (mappend (mappend a c) e) (mappend (mappend b d) f) ) ) = ( Pair (mappend a (mappend c e) ) (mappend b (mappend d f) ) -- by Associativity property
18:00:13 <Tordek> conn: but that's personal opinion, more than anything; other than that it looks great
18:01:03 <Tordek> conal: er, except for this: <> Pair (e f)
18:04:10 <conn> Tordek: https://codeshare.io/2WA9YW
18:14:52 <Tordek> conn: sorry, you dc'd just as I was responding, lol
18:15:12 <Tordek> there's an error in Assoc where you say ... <> Pair (e f)
18:16:27 <conn> Tordek: can you repeat?
18:17:15 <Tordek> seems like all you missed was "but that is mostly personal opinion, it can work, I just don't like it"
18:19:47 <conn> Tordek: ah ok! see the code again i think i fixed the missing mappend https://codeshare.io/2WA9YW
18:19:52 <Tordek> also there seems like there's a couple superfluous parentheses; you're writing ( (Pair [...] [...]))
18:20:42 <Tordek> ( (Pair (mappend a c) (mappend b d) ) mappend Pair (e f) = -- by definition of `mappend` <- the error is Pair (e f) should be (Pair e f)
18:24:49 <Tordek> I hope you get the gist of proving properties: you start by taking the definition of the property (in this case, say, a = a <> mempty), replace the variables by an arbitrary instance of your type ("Pair a b, where a and b are some value that doesn't matter"), and then either apply your definition or the properties of your objects until you reach whateve conclusion is asserted by the property
18:25:44 <Tordek> and either you prove it (if you can reach the claimed result) or disprove it (if a step fails)
18:28:53 <conn> Tordek: https://codeshare.io/2WA9YW
18:29:59 <Tordek> looks good
18:30:21 <conn> Tordek: i can leave it like this now and go sleep ;) ?
18:32:30 * hackage sbv 7.9 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-7.9 (LeventErkok)
18:36:57 <jle`> conn: your last proof at the end is not complete yet, the final step is to show that the two are equal
18:37:16 <jle`> you just expanded both sides, but did not claim that both sides are equal :'(
18:37:50 <jle`> in fact your proof seems to be trying to imply that they are not equal, heh
18:38:14 <conn> jle`: you mean like this : Pair ace bdf = Pair ace bdf ?
18:39:26 <jle`> in the end you have to show that two things are equal, yeah
18:40:07 <jle`> conn: one way is by going from one to the other
18:40:11 <jle`> through a series of manipulations
18:40:26 <jle`> like you did for your first two examples
18:41:26 <conn> jle`: https://codeshare.io/5w0W6x
18:41:37 <jle`> conn: i edited https://codeshare.io/2WA9YW to demonstrate what i mean
18:41:58 <jle`> you can't quite just say pare ace bdf = pair ace bdf, because you never introduced what ace and bdf are
18:42:12 <jle`> but yeah, i ended the original paste you sent to show what i mean
18:42:33 <jle`> we go from one side to the other side by doing substitutions
18:42:45 <jle`> so we go from (x <> y) <> z to z <> (x <> y)
18:43:08 <jle`> just like how we did it for the first two examples
18:44:26 <conn>  ok ill check this tomorrow
18:44:47 <conn> jle` thanks for the hint
18:45:37 <jle`> no problem :)
18:45:43 <jle`> have a good night!
19:02:45 <ru0mad>  /j gentoo
19:18:31 * hackage numhask 0.2.3.0, numhask-prelude 0.1.0.0 (tonyday567): https://qbin.io/items-texas-fy7h
19:35:00 * hackage numhask-prelude 0.1.0.1 - A numeric prelude  http://hackage.haskell.org/package/numhask-prelude-0.1.0.1 (tonyday567)
21:50:37 <zfnmxt> I noticed that the typeclasses in MTL uses the class like types, i.e. they'll write things like MonadState s m => MonadState s (MaybeT m), where MonadState is a type class, not a type.
21:50:52 <zfnmxt> What exactly does that mean?
21:51:41 <Cale> zfnmxt: If m satisfies MonadState s m, it means that it's a monad which supports get and put operations for acting on a state of type s
21:52:16 <geekosaur> it's not usimg it as a type, it's requiring one MonadState instance to define a second instance
21:52:22 <zfnmxt> Oh, right. I'm an idiot.
22:38:33 <JuanDaugherty> MonadState s m is just CTish for get and put, what a reveal. hs in a nutshell
22:39:44 <JuanDaugherty> an insight that can eschew every obfuscation
22:42:19 <gonz_> No, `MonadState` doesn't have more to do with category theory than just being a monad does, as far as I know.
22:42:46 <gonz_> It's not some special terminology, it's a type class in `mtl`
22:45:01 <JuanDaugherty> an insight isn't assertion of fact, and my statement wasnt about this particular type class it was about hs in general
22:45:34 <JuanDaugherty> *isn't an
23:23:00 * hackage hasql 1.3.0.2 - An efficient PostgreSQL driver and a flexible mapping API  http://hackage.haskell.org/package/hasql-1.3.0.2 (NikitaVolkov)
23:31:00 * hackage neat-interpolation 0.3.2.2 - A quasiquoter for neat and simple multiline text interpolation  http://hackage.haskell.org/package/neat-interpolation-0.3.2.2 (NikitaVolkov)
23:51:43 <tabemann> I'm having trouble where I am trying to communicate between threads using TQueues and the receiving end is not always registering writes which it is waiting on when they are written to the TQueue
23:52:19 <tabemann> this occurs only when the TQueue is emptied, and the reading side is waiting for more data to read
23:55:58 <cocreature> tabemann: what exactly do you mean by “is not registering writes”? you are calling readTQueue but it never returns even though items are being written to the queue?
23:56:12 <tabemann> yes
23:56:25 <cocreature> that sounds bad, can you show us (parts of) the code?
23:56:49 <tabemann> I put a putStrLn right after I write, and a putStrLn right after I read, and the first message appears but not the second
23:58:12 <cocreature> maybe put a putStrLn before the read to make sure you actually get to that point. and maybe an exception handler around the read to make that the thread doesn’t die before it finishes reading
23:58:22 <cocreature> also are you sure that you are not reading anywhere else?
23:58:56 <tabemann> https://lpaste.net/2832396340321845248
23:59:12 <tabemann> I had previously put an exception handler around the read, and nothing showed up there
23:59:39 <tabemann> what is interesting is when I put a putStrLn after the write, it stopped raising waiting forever in STM exceptions
23:59:57 <tabemann> in a completely different part of the code
