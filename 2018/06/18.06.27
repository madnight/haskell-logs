00:03:15 <pdxleif> Monads are like viewing the world (RealWorldState) through a glass darkly, obscured by reflections and shadows.
00:03:51 <pdxleif> kidding
00:07:11 <hc> I thought monads were like burritos ;-)
00:12:29 * hackage persistable-types-HDBC-pg 0.0.3.5 - HDBC and Relational-Record instances of PostgreSQL extended types  http://hackage.haskell.org/package/persistable-types-HDBC-pg-0.0.3.5 (KeiHibino)
00:13:46 <jle`> `Guest00000: to me, dependent types aren't just using ADT's in a clever way, but rather being able to work with such things as first-class values
00:14:26 <jle`> for example, `data Either e a = Left e | Right a` is similar in a lot of ways to a dependent sum, to the extent that it is a sum
00:16:37 <jle`> but it isn't a dependent sum because it isn't a first-class value that determines 'e' or 'a'
00:16:47 <jle`> similarly we can have "fixed-length" vectors using basic ADT's
00:16:51 <jle`> data V2 a = V2 a a
00:17:05 <jle`> data V3 a = V3 a a a, data V4 a = V4 a a a a, etc.
00:17:17 <jle`> but dependent types allow us to treat 2, 3, 4, etc. as first-class values
00:17:24 <jle`> we can add them, subtract them, manipualte them programmatically
00:18:35 <tdammers> hum, does stackage no longer publish cabal.config package lists?
00:20:08 <mpickering> https://www.stackage.org/lts-11.15/cabal.config
00:23:31 * hackage hspec-core 2.5.2, hspec 2.5.2, hspec-discover 2.5.2 (SimonHengel)
00:28:50 <tdammers> oh, so it's just hidden
00:32:37 <fd> how to append one integer list to antoher ?
00:33:20 <cocreature> :t (++) -- fd
00:33:21 <lambdabot> [a] -> [a] -> [a]
00:36:09 <`Guest00000> jle`: twoPlusFour :: [()]; twoPlusFour = [(), ()] ++ [(), (), (), ()]  -- 6
00:37:26 <`Guest00000> for "at least 2" will need to make a new datatype  data V2Plus a = V2Plus a a [a]
00:42:15 <Franciman> Hi
00:42:49 <Franciman> what's the gist of FRP? Is the separation between declaring data dependencies and the underlying update engine?
00:44:03 <tdammers> expressing a program as a function of state over time, maybe?
00:45:09 <Franciman> ah ok
00:45:54 <Franciman> still gotta wrap my head around it a bit
00:46:22 <Franciman> thank you
00:48:44 <tdammers> so you have plain old reactive programming, where your program is kind of a "stepper" function that takes an old state and an event, and returns a new state; and then you just keep applying that function to a series of states based on a stream of incoming events, and for each output state, you emit some sort of view or view manipulation
00:49:00 <tdammers> step :: Event -> State -> State -- in a nutshell
00:49:26 <tdammers> time, in this model, is discrete, and timer updates are just another event type
00:49:53 <Franciman> ok
00:50:05 <tdammers> FRP takes this to the next level, and instead uses continuous time (or, well, as close as you can get with time values computers can represent)
00:50:18 <mreh> @help
00:50:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:50:25 <mreh> @help list
00:50:25 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
00:50:27 <Franciman> in this way you can compose functions (I had read), not sure why
00:50:43 <mreh> anyone know how to get her to list her commands?
00:51:05 <tdammers> oh, yes - because a stepper is just a function, you can compose them out of other functions
00:51:25 <cocreature> and to make things confusing people call reactive programming without continuous time frp and make conal angry :)
00:51:39 <Franciman> :P
00:51:41 <dminuoso> Franciman: I found https://www.youtube.com/watch?v=j3Q32brCUAI this to be a smooth introduction into continuous frp. :P
00:51:50 <tdammers> cocreature: god yes... apparently the Elm folks have stopped doing that, but it's still very common
00:51:53 <Franciman> what's the benefit of continous, then?
00:51:56 <Franciman> thanks dminuoso !
00:52:06 <dminuoso> Franciman: It's a talk from Conal Elliott. :)
00:52:29 <cocreature> mreh: you can use @listmodules to get all modules and then "@list module" to get the commands in a module
00:52:40 <mreh> cocreature, thx
00:52:41 <cocreature> mreh: note that you can talk to lambdabot in private messages so no need to spam the channel
00:52:59 <mreh> cocreature, yeah I was just doing that, got stuck :)
00:53:12 <mreh> @slap mreh
00:53:12 * lambdabot hits mreh with a hammer, so they breaks into a thousand pieces
00:54:08 <dminuoso> Mmm, according to which style is inflecting the verb with `s` correct when using singular they?
00:54:26 <dminuoso> Or is this possibly a typo?
00:54:59 <mreh> dminuoso, it's not gramattical is it
00:55:10 <mreh> grammatical*
00:55:35 <jle`> `Guest00000: i mean, we can't manipulate the lengths in "length-4 vector" and "length-5 vector", as types,w ithout dependent types
00:56:02 <jle`> `Guest00000: we can write a length-4 vector type, data V4 a = V4 a a a a
00:56:11 <jle`> and a length-5 vector type, data V5 a = V5 a a a a a
00:56:24 <jle`> but the "4" and "5" are hard-coded; the can't be manipulated as first-class values
00:57:26 <jle`> a `V4 Int` has exactly four ints, and a `V5 Int` has exactly 5 ints
00:57:43 <jle`> we can make a V9 as well, and write a V4 a -> V5 a -> V9 a
00:57:53 <jle`> but we can't work with the 4, 5, and 9 as first-class values programmatically
00:59:09 <jle`> they are out of the scope of our language, unless we have dependent types
01:11:08 <angerman> mreh: sorry, I'll have a look.
01:11:39 <angerman> mreh: http://hackage.mobilehaskell.org/ and the downloads seem to work, what were you referring to?
01:11:40 <mreh> angerman, cool
01:12:07 <mreh> angerman, I think there was some caching going on somewhere, seems to be working!
01:12:29 <mreh> I'm just getting Haskell cross compiling with cabal
01:12:33 <mreh> nearly there
01:13:03 <angerman> yey!
01:14:23 <mreh> angerman, I had to point the linker to the right sysroot, I'm getting copy file errors at the moment though
01:14:32 <mreh> it's hard work cross compilation!
01:15:21 <angerman> mreh: yea, the whole SDK interaction is rather nasty.
01:15:33 <angerman> for iOS, the xcrun tool neatly hides all the nitty gritty details.
01:15:47 <angerman> for RPi, the docker image helps a lot.
01:15:59 <angerman> I guess for linux -> android one could build a docker image a sell.
01:16:18 <mreh> angerman, android studio is supposed to fix everything, but I ditched it
01:16:33 <ZeuPiark> hello
01:17:06 <angerman> mreh: I doubt it. Android Studio is the NDK under the hood as well..
01:17:08 <mreh> angerman, but a prebuilt build environment would be great
01:17:49 <mreh> angerman, the gradle android plugin knows alot about the whole build process, but that doesn't help with the Haskell though I suppose
01:21:53 <mreh> angerman, could my errors be due to the Setup.hs being cross compiled too?
01:26:16 <cocreature> do we have a "mconcat1 :: Semigroup m => NonEmpty m -> m" in base?
01:29:04 <dminuoso> cocreature: Semigroup has sconcat?
01:29:08 <dminuoso> :t sconcat
01:29:09 <lambdabot> error:
01:29:09 <lambdabot>     • Variable not in scope: sconcat
01:29:09 <lambdabot>     • Perhaps you meant one of these:
01:29:16 <dminuoso> @let import Data.Semigroup
01:29:16 <cocreature> dminuoso: ah perfect, thanks!
01:29:17 <lambdabot>  Defined.
01:29:18 <dminuoso> :t sconcat
01:29:19 <lambdabot> Semigroup a => Data.List.NonEmpty.NonEmpty a -> a
01:33:27 <jle`> sconcat is nicer to pronounce
01:34:24 <jle`> SKONK-at
01:34:49 <cocreature> it’s easier to pronounce, I’m not sure skonk-at counts as “nicer” :)
01:34:56 <jle`> well
01:35:00 <jle`> it's nothing to skonk at
01:35:02 <ChaiTRex> How do I box and unbox values with GHC.Prim?
01:35:53 <cocreature> ChaiTRex: you mean, how do you convert between Int and Int# (and similar types)?
01:36:02 <ChaiTRex> cocreature: Yes, that's it.
01:36:21 <cocreature> use the constructor, e.g., https://hackage.haskell.org/package/ghc-prim-0.5.2.0/docs/GHC-Types.html#t:Int
01:39:09 * [exa] imagines skunk-cat animal, the keeper of semigroups
01:41:16 <ChaiTRex> cocreature: Thanks. I hadn't known to import GHC.Types.
01:42:35 <dminuoso> Why are top level bindings for unlifted types not alloweD?
01:43:47 <merijn> dminuoso: How would those work?
01:45:37 <dminuoso> merijn: If I could answer your question I probably wouldn't have asked.. :P
01:46:07 <cocreature> well if you did know how to make them work it would make sense to ask :)
01:46:19 <cocreature> otherwise “nobody knows how to make them work” is an acceptable answer :)
01:46:52 <dminuoso> Well what is it about being _unlifted_ that prevents it?
01:47:02 <merijn> dminuoso: I mean, most unlifted types tend to be stuff you just keep in registers, so having them at the top level means first reading them in from memory to whereever you plan to use them, in which case you might as well be using a lifted type?
01:47:38 <dminuoso> merijn: Are you sure you are not conflating lifted and boxed here?
01:48:56 <merijn> dminuoso: No, but I'm only talking about a subset of all unlifted types yes
01:49:17 <ChaiTRex> Is there some way to do something like `fromIntegral . W# . f $ n` where `W#` works like other constructors? As it is, I have to write it as `fromIntegral $ W# (f n)`.
01:49:18 <merijn> But if you can't make it work for a subset of unlifted types, then you can't make it work for unlifted types in general, so it's still an answer :p
01:49:28 <dminuoso> merijn: Oh it is indeed.
01:49:36 <[exa]> unlifted module exports *nay*
01:49:40 <dminuoso> I guess you could only make it work for ByteArray#
01:50:31 <dminuoso> ChaiTRex: The thing that prevents you there is lack of levity polymorphism in (.)
01:50:53 <dminuoso> % :i ($)
01:50:53 <yahb> dminuoso: ($) :: (a -> b) -> a -> b -- Defined in `GHC.Base'; infixr 0 $
01:51:09 <__monty__> Are there unboxed lifted types?
01:51:24 <ChaiTRex> dminuoso: Ahh, thanks.
01:51:35 <__monty__> Oh, it's in the docs.
01:51:53 <[exa]> __monty__: afaik not, you need a box to support the bottom value
01:51:56 <dminuoso> Uhh.. why is yahn now showing this differently
01:52:14 <dminuoso> ChaiTRex: ($) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b -- Defined in `GHC.Base'; infixr 0 $
01:52:38 <dminuoso> (.) :: (b -> c) -> (a -> b) -> a -> c  -- Defined in ‘GHC.Base’; infixr 9 .
01:53:15 <__monty__> [exa]: Yes, lifted implies boxed according to what I'm reading.
01:53:54 <dminuoso> __monty__: the distinction is useful because there's some things like ByteArray# that are heap allocated (and thus boxed), but bottom-free.
01:54:37 <[exa]> __monty__: they could really add an example of something that's boxed but unlifted
01:55:10 <merijn> __monty__: Rather, unboxed *requires* unlifted according to GHC docs :)
01:55:54 <dminuoso> [exa]: https://github.com/ghc/ghc/blob/master/compiler/types/Type.hs#L284-L292
01:56:36 <[exa]> oh, primitive types. Thanks
01:57:01 <[exa]> ByteArray# ofc. :D
01:57:23 <dminuoso> @let (..) :: forall (r :: RuntimeRep) (a :: Type) (b :: Type) (c :: TYPE r). (b -> c) -> (a -> b) -> (a -> c); (f .. g) x = f (g x)
01:57:23 <lambdabot>  Parse failed: Parse error: ..
01:57:28 <__monty__> merijn: (lifted -> boxed) <=> (~boxed -> ~lifted) : p
01:57:46 <dminuoso> @let (.') :: forall (r :: RuntimeRep) (a :: Type) (b :: Type) (c :: TYPE r). (b -> c) -> (a -> b) -> (a -> c); (f .' g) x = f (g x)
01:57:46 <lambdabot>  Parse failed: Parse error: )
01:59:19 <__monty__> Is it possible to write a polymorphic function over unlifted types? f :: (a :: #) -> (a :: #)
02:04:59 <merijn> __monty__: Only if it's polymorphic in the return type, like $
02:05:54 <merijn> __monty__: Parametric polymorphism uses boxing for uniform representation during codegen, so you can't really be polymorphic for non-return values
02:07:29 <dminuoso> % (.#) :: forall (r :: RuntimeRep) (a :: Type) (b :: TYPE r) (c :: Type). (b -> c) -> (a -> b) -> (a -> c); (f .# g) x = f (g x)
02:07:29 <yahb> dminuoso: ; <interactive>:30:122: error:; A levity-polymorphic type is not allowed here:; Type: b; Kind: TYPE r; In the type of expression: (g x)
02:07:40 <merijn> __monty__: Consider this: How can code handle both a 16bit value, 32bit value, and 64bit value? With boxing this is easy because *every* value is just a constant size pointer to the "actual" value
02:07:59 <merijn> __monty__: Once you unbox that uniformity disappears
02:08:29 <dminuoso> merijn: by "actual value" you mean the code that produces the value right?
02:08:42 <merijn> I suppose you can take a C++/ML approach and generate separate code for each possible use of such a function, but that'd quickly bloat your code size, which we is why we do boxing in the first place
02:09:18 <merijn> dminuoso: Now you're making my mistake from earlier :p
02:09:44 <merijn> dminuoso: The fact that it's boxed doesn't require that it be able to represent thunks/bottoms
02:10:02 <merijn> Plenty of non-lazy languages do boxing too
02:10:11 <merijn> (e.g. Java)
02:11:13 <dminuoso> Ah so representing the value as a closure is just for lazyness?
02:11:54 <dminuoso> Ive read the stg paper a bit, but I barely understand the GHC internals
02:12:12 <merijn> dminuoso: Well, yes
02:12:30 <merijn> dminuoso: If you have strict language you never need to have computation inside your box
02:12:53 <merijn> dminuoso: You already know what it is/it's size. But you still use boxing to do parametric polymorphism
02:13:04 <dminuoso> merijn: So if my computation uses an unboxed value, it would not `jmp` into the closure but read from it directly?
02:13:07 <merijn> s/it's/its
02:13:21 <dminuoso> Oh wait.. this brings us back to the original topic..
02:13:28 <dminuoso> It'd already be in a register.
02:14:05 <merijn> dminuoso: Right, in most normal conditions unboxed values are already wherever you plan to use them and since GHC knows about them it knows it can stuff them in a register/whatever
02:14:22 <dminuoso> merijn: Let me correct that..
02:14:35 <dminuoso> so if my computation uses an unlifted/boxed value, it would not `jmp` into the closure but read from it directly?
02:15:19 <merijn> dminuoso: Or just inline it directly into the surrounding code, yeah
02:16:00 <merijn> eh, wait, I think I misread
02:16:27 <merijn> You mean unlifted/unboxed?
02:16:36 <dminuoso> unlifted/boxed.
02:16:42 <dminuoso> e.g. ByteArray#
02:17:05 <merijn> I dunno how GHC implements those, tbh
02:20:21 <dminuoso> Ah: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects
02:36:54 <mgttlinger> What is the recommended way to deal with references in data that would need to be retrieved separately from some kind of API be it REST or DB. E.g. a Message containung a "user_id" which references the author of the message.
02:38:35 <mgttlinger> Parametrise the message data type over that type and querie the users when needed?
02:39:52 <mgttlinger> Are there libraries to aid in doing this kind of thing given that this is probably a problem many people need to deal with?
02:52:52 <tomsen> Did someone manage to get autocompletion working in neovim? Can you tell me which plugin does the job for you so i can try to figure it out?
03:01:43 <power-fungus> I wonder what is the difference between Alternative and MonadPlus and what of those 2 is recommended today?
03:01:54 <maerwald> tomsen: yes, I use deoplete with HIE language server
03:02:44 <electrocat> power-fungus: practically the same, except alternative has applicative as a subclass
03:03:02 <electrocat> i use alternative because it's less restricting
03:03:18 <cocreature> MonadPlus exists mostly for historical reasons afaik
03:03:24 <cocreature> it even has an Alternative superclass these days
03:03:25 <power-fungus> is there any class for which <|> and mplus are different?
03:04:01 <electrocat> i dont think so, as cocreature said, it's just there for historical reasons, they should be the same
03:04:08 <Taneb> power-fungus: no, it's a law that the instances have to match
03:04:40 <cocreature> Taneb: it isn’t a law or at least it is not documented as such
03:04:50 <Taneb> cocreature: ah, I'd misremembered
03:05:09 <tomsen> maerwald: Thanks!, i'll try that combination
03:06:28 <power-fungus> this answer states that monadPlus has an extra lawhttps://stackoverflow.com/questions/10167879/distinction-between-typeclasses-monadplus-alternative-and-monoid#10168111
03:06:42 <power-fungus> empty >>= f = emtpy
03:08:04 <maerwald> tomsen: you can see my config here https://gitgud.io/hasufell/vim-config/tree/neovim
03:08:54 <dminuoso> power-fungus: And interestingly that law is not guaranteed by Alternative. In the presence of Backwards you can break left-zero ;)
03:09:24 <mniip> anyone here familiar with the quantified constraints paper?
03:09:28 <mniip> https://i.cs.hku.hk/~bruno//papers/hs2017.pdf
03:09:51 <dminuoso> % import Control.Applicative.Backwards
03:09:51 <yahb> dminuoso:
03:10:02 <dminuoso> % forwards $ empty <*> Backwards (putStrLn "hello")
03:10:02 <yahb> dminuoso: hello; *** Exception: user error (mzero)
03:17:39 <ahri> can anyone explain what I'm doing wrong here? https://gist.github.com/ahri/06829b3b9ba1a2522c89786358ecee1b it seems to me like I'm adhering to the rules, but that's clearly not the case
03:18:03 <ahri> sorry, I'm trying to write a Monoid instance
03:18:20 <dminuoso> ahri: The error is self explaining.
03:18:30 <dminuoso> ahri: Have you tried enabling the language pragma the compiler suggested?
03:20:12 <dminuoso> ahri: Essentially it's complaining that an instance declaration must look like `Monoid a1 a2 a3 ...` where a1, a2, a3.. are type variables. You put `(Event t Msg)` in there which is not a type variable. FlexibleInstances is a safe and common extension that removes that restriction.
03:21:14 <ahri> dminuoso: yes I have, and I end up with "Overlapping instances for Monoid"
03:21:25 <ahri> I see, in that case I'm not sure what to do about the overlapping
03:22:49 <cocreature> I would instead make a Monoid instance for "Event t a" and if you have something like m (Event t a) you can use liftA2 (<>)
03:23:30 <ahri> I've added a comment with the exact error to that gist
03:26:58 <ahri> cocreature: ok, thanks, I'll try your approach
03:27:51 <dminuoso> ahri: I made a small mistake: It should look like `Monoid T a1 a2 ..`, you gave something that looked like `Monoid a1 (T a2)`
03:31:16 <ahri> ah, yes, I guess that's why cocreature made the suggestion to focus on the `Event` instance
03:43:29 <dysfun> what's the term for a read-only lens?
03:43:41 <mniip> Getter
03:43:45 <dysfun> ta
03:46:51 <mniip> hmm
03:47:10 <mniip> one would think that given  class ctx sigma => Cls sigma where {}
03:47:25 <mniip> instance ctx sigma => Cls sigma  would work
04:01:17 <jle`> ahri: for what it's worth, this is not a good typeclass instance to have in production
04:01:48 <ahri> jle`: oh, why not?
04:01:51 <jle`> ahri: what you are doing is essentially defining a Monoid instance to work on *all* m (Event t a)'s
04:02:13 <ahri> well I'm happy to make `a` specific
04:02:23 <jle`> but to only be usable to work on instance of MonadWidget t m
04:02:27 <jle`> ahri: the issue isn't a, but 'm'
04:02:40 <jle`> it's basically a super-orphan
04:03:13 <jle`> now anyone who ever makes a type that has kind * -> *, your instance will cover that type
04:03:46 <jle`> it's basically the same issue with writing (Applicative f, Monoid a) => Monoid (f a)
04:04:16 <jle`> that instance now is the canonical instance for all 'f a', globallyh
04:04:38 <jle`> that instance also would clash with the Monoid instace for [a]
04:04:53 <zerobaud> This might be offtopic, please redirect me to a appropriate channel. I want to check for functional equivalence of loop free (basic blocks) code but its too costly to go over all inputs and outputs for a target and reference. SMT solvers should be able to help here... Does anybody know how?
04:05:26 <jle`> ahri: if you can see what is wrong with writing an instance (Applicative f, Monoid a) => Monoid (f a), then it's pretty much the same issue here
04:05:47 <cocreature> zerobaud: I’ve done some work in that area (although we’ve focused on programs that contain loops) but let’s move this to #haskell-offtopic
04:05:53 <jle`> ahri: the "typical" way people handle situations like this is by writing a newtype wrapper, and then writing an instance for that newtype wrapper
04:06:06 <zerobaud> Thank you cocreature
04:06:14 <jle`> that way if people wnat to use an m (Event t a) as a Monoid, they can wrap it in your wrapper, and it'll now have a Monoid instance
04:06:32 <jle`> and in ghc 8.6, they can use that newtype to automatically derive Monoid for a specific 'M' they create
04:06:56 <jle`> what you don't want is a monster instance m (Event t a) that eats up all m's ever
04:06:57 <ahri> jle`:  ok, I completely accept that I may be stumbling around making bad decisions :) I started out wanting to do a `foldMap` on a collection of widgets, turning them into a merged one - perhaps the newtype approach works
04:07:34 <jle`> ah yeah, if you want to take advantage of foldMap for widgets, a newtype might help
04:07:44 <jle`> ahri: consider also if your specific 'm' you will eventually use has a Monoid instance for this
04:07:56 <jle`> if that's the case, you can just constrain on Monoid (m (Event t a)) => ...
04:08:04 <jle`> knowing that it will be satisfied when you actually use it
04:08:21 <ahri> ah, I'm pretty sure it does
04:09:45 <jle`> alternatively instead of foldMap f, you can do foldr (mappend . f) mempty
04:10:01 <jle`> which works for all foldables, and also you can manually provide the "mempty" and "mappend" functions you want
04:10:20 <jle`> > foldr ((++) . show) "" [1..10]
04:10:22 <lambdabot>  "12345678910"
04:10:30 <jle`> > foldMap show [1..10]
04:10:33 <lambdabot>  "12345678910"
04:12:02 <jle`> yeah, orphan instances cause enough headaches :)  and in this case it's like an orphan for every * -> * type, heh
04:12:15 * jle` . o (maybe typeclasses were a mistake)
04:12:49 <cocreature> jle`: heretic!
04:12:57 <merijn> Burn the witch!
04:12:59 <jle`> the main issue is that it's magically global and hogs the instances of all * -> * types ever
04:13:06 * jle` flees
04:13:57 <jle`> i do find it funny that the very reason typeclasses were invented for is now the thing we consider bad practice to use typeclasses for
04:14:11 <jle`> and the reason we use typeclasses today is nothing like how they were originally intended to be used
04:14:14 <mniip> anyone here familiar with the quantified constraints paper?
04:15:44 <[exa]> sounds like bagof/3 in typeclasses
04:15:48 <`Guest00000> functions can be constructed at run-time. Q: does GHC runtime optimize the constructed functions?  like, for compositions of a same function it could just store a number of how many time it's composed to itself
04:16:42 <[exa]> `Guest00000: optimizer is not present at run-time so if you construct the functions on _run_ time from tiny pieces, they won't be optimized
04:17:07 <`Guest00000> ok
04:17:27 <jle`> it could potentially do it if you knew the number of times at compiletime and constructed the function at compiletime (but it doesn't)
04:17:36 <mniip> `Guest00000, it's easy to get the wrong intuition for how functions work
04:17:37 <[exa]> note that stuff that seems runtime-ish like `if something then a . b else b . a` is optimized.
04:17:48 <mniip> when you say g = f . f
04:17:59 <mniip> you don't create a function g that applies f twice
04:18:19 <mniip> g is bound to a closure that is a partial application of (.)
04:18:36 <`Guest00000> mniip:   modify (join (.))
04:19:01 <mniip> is this lazy StateT?
04:20:12 <`Guest00000> lazy/eager here is like "(\... -> ...) `seq` ..."
04:20:26 <`Guest00000> sure can
04:20:33 <`Guest00000> > const `seq` ":)"
04:20:36 <lambdabot>  ":)"
04:20:38 <mniip> no, there's a lazy StateT and a strict StateT
04:20:40 <merijn> That seq is rather pointless, tbh
04:20:46 <mniip> also evaluating a function closure achieves very little
04:21:17 <merijn> mniip: That's not necessarily true
04:21:33 <merijn> mniip: It gets rid of some indirection
04:21:37 <mniip> in this case it is
04:21:42 <merijn> Sure
04:21:45 <mniip> ditto for when your StateT is parameterized by a function
04:21:57 <merijn> mniip: But you stated that as if it was generally true
04:22:23 <mniip> if you do multiple 'modify (join (.))' you still end up with a closure that looks like a binary tree
04:22:30 <mniip> well, collapsed into a linear graph, but still
04:22:48 <mniip> during evaluation all those layers will have to be traversed
04:23:37 <w1n5t0n> hey, I've installed a package I'm developing with "cabal install" and, even though it installs successfully, when I try to use it in ghci I get the error "ghc.exe: unable to load package `array-0.5.2.0'". I tried adding "array" to the cabal file and reinstall but still the same, any suggestions?
04:24:32 <[exa]> w1n5t0n: (blind guess:) try new-repl
04:25:23 <w1n5t0n> [exa]: is that a ghc command?
04:25:27 <[exa]> otherwise seeing why it can't load the package would be most useful
04:25:42 <kuribas> it's not possible to compose type constructors right?
04:25:51 <[exa]> cabal command. it has new-build, new-repl, new-run, ... that manage dependencies a lot better
04:26:00 <kuribas> without newtype
04:26:38 <w1n5t0n> [exa]: I don't know if this means anything, but the first time I try to run anything I get this error " *** Exception: loadArchive "C:\\Program Files\\Haskell Platform\\8.4.3\\msys\\mingw64\\lib\\libsndfile.dll.a": failed", but from then onwards I only get the array error
04:26:45 <merijn> kuribas: Define "compose"
04:26:47 <cocreature> kuribas: not sure what exactly you mean by that but maybe Compose is helpful?
04:26:53 <cocreature> from Data.Functor.Compose
04:27:08 <kuribas> like apply a list of lists to a type
04:28:06 <kuribas> like : data MyType s = MyType (s Int), then MyType ([] [])
04:28:10 <[exa]> w1n5t0n: that should not affect array loading (imho)
04:28:46 <[exa]> w1n5t0n: can you check out what version of array is actually installed?
04:29:24 <cocreature> w1n5t0n: how are you launching ghci and where have you run "cabal install"?
04:29:56 <`Guest00000> kuribas: Compose is a newtype, but generic, you just use (Compose [] [])
04:30:39 <kuribas> `Guest00000: yeah, with compose it works.
04:31:02 <w1n5t0n> cocreature: I launch ghci as a process in emacs, because I'm using an emacs buffer to send strings to it, and I ran "cabal install" in the directory of my package, without a sandbox (as I believe emacs' ghci wouldn't be able to see it then)
04:31:11 <`Guest00000> hmmmm
04:31:18 <`Guest00000> now for (Compose Compose Compose)
04:31:55 <cocreature> w1n5t0n: I would first try to get ghci to work outside of emacs to eliminate one of the moving parts
04:32:02 <cocreature> w1n5t0n: what’s the output of ghc-pkg list?
04:33:29 <w1n5t0n> cocreature: https://lpaste.net/4552118842121256960, array is not included
04:33:53 <cocreature> w1n5t0n: maybe try "cabal install array"?
04:34:07 <cocreature> w1n5t0n: is the package you tried to install included?
04:34:41 <zincy> Is there an alternative to System.Timeout that doesn't throw exceptions
04:35:01 <w1n5t0n> yes it is, it's the first one. I added array to the .cabal file, run cabal install again, and got the message "array-0.5.2.0 added" before it successfully installed again
04:35:26 <cocreature> zincy: how else do you expect it to kill your IO action?
04:36:09 <w1n5t0n> cocreature: I also tried "cabal install array" but I get "all the requested packages are already installed"
04:36:10 <zincy> Spawn an extra thread ?
04:36:36 <merijn> zincy: Which would get killed how?
04:36:56 <zincy> Mvar?
04:37:04 <merijn> zincy: How would that kill it?
04:37:24 <zincy> Read from the Mvar in the extra thread and check for a kill signal
04:37:25 <merijn> zincy: If you want to limit compute time, you need to somehow interrupt it when it's taking too long
04:37:39 <merijn> zincy: How can you read from the MVar if you're busy computing?
04:37:41 <zincy> Is a thread a process?
04:37:47 <merijn> No
04:37:56 <[exa]> not even a real thread, usually
04:38:18 <zincy> Is it an abstraction for a series of computations that are independent?
04:38:41 <[exa]> ...with those from other threads unless stated explicitly; yes
04:38:57 <merijn> zincy: Either your code is busy computing and it needs to be interrupted, or your continuously polling whether you should stop. Those are the only two options
04:39:07 <merijn> And the 2nd option requires you to completely modify the original code
04:39:08 <cocreature> zincy: maybe let’s step back: what’s the problem with timeout throwing an exception?
04:39:28 <zincy> It kills the thread that my websocket listener is running in
04:39:35 <zincy> and thus disconnects the client
04:40:09 <zincy> So I guess when I run timeout it forks a thread that waits for x amount of time and then throws an exception
04:40:10 <[exa]> zincy: maybe you should catch the exception?
04:40:19 <zincy> that exception is propagated up and kills the thread
04:40:58 <zincy> good idea
04:41:04 <zincy> How do I do that
04:41:22 <zincy> well I can google that easily
04:42:16 <zincy> What are exceptions exactly and how do they differ from errors?
04:43:14 <[exa]> error is what programmer messed up, exception is something that got messed up but programmer expected it
04:43:31 <[exa]> (there's a haskell wiki page on that somewhere)
04:44:27 <zincy> Ah right so you throw exceptions on say a 404
04:45:02 <[exa]> the point of exceptions is that they handle exceptional situations without cluttering the 'normal 99.999% cases' code
04:45:08 <cocreature> zincy: the exception shouldn’t propagate up, that’s why "timeout" returns a Maybe. I wonder if you aren’t misinterpreting the behavior you are seeing
04:45:23 <cocreature> "timeout n a" will only kill "a"
04:46:40 <zincy> cocreature: Yes true
04:47:39 <newhoggy> The way I'm going about learning this is possibly not the most efficient way to do it :D
04:48:26 <cocreature> newhoggy: “this”?
04:49:16 <merijn> cocreature: Seems to be directed at GHC hacking in #ghc :p
04:49:18 <newhoggy> Sorry, I was typing #ghc and it jumped channel just before I pressed <enter>
04:49:37 <zincy> I am right in assuming that an exception in a client's thread will lead to "ConnectionClosed"
04:51:56 <kuribas> anyone needs a remote haskell job?
04:52:02 <kuribas> I found this https://stackbuilders.workable.com/j/E01709D897
04:52:58 <__monty__> Node on the frontend?
04:53:21 <__monty__> Projects using Ruby, Rails and Haskell sounds suspicious imo.
04:53:48 <kuribas> __monty__: with some purescript :)
04:53:50 <mniip> o wow
04:54:01 <mniip> I think the QuantifiedConstraints problem goes all the way back to the paper
04:54:44 <mniip> their "tractable constraint entailment" inference rules allow an infinite corecursive proof of 'C => C'
04:54:46 <gonz_> __monty__: Why? It could just be a very long migration towards something better.
04:55:13 <mniip> which GHC might try to produce, doing a structure-driven proof
04:55:29 <mniip> I arrived at this http://mathb.in/26293
04:56:54 <kuribas> __monty__: there blog articles are almost completely about FP and haskell.
04:56:56 <__monty__> gonz_: Sure but it's consulting. Hard to migrate on the customer's dime.
04:57:50 <gonz_> __monty__: A company's toolset can migrate towards something over time. You might be right, though, I don't know.
04:58:14 <kuribas> __monty__: maybe they target rails users who want to migrate :)
04:58:50 <gonz_> I just know that for projects that I work on I've managed to introduce OCaml as a part of it and if one were to hire for the company I work for it may very well include OCaml in there.
04:59:27 <kuribas> __monty__: "Stack Builders started as a Ruby consultancy, and we continue to build and maintain some of the largest and most complex Ruby applications in the industry. "
04:59:48 <kuribas> __monty__: that explains it pretty well.
05:00:59 <hpc> "some of the largest and most complex Ruby applications in the industry."
05:01:02 <hpc> so they wrote rails
05:03:45 <ChaiTRex> Is there a good way to do the equivalent of foldl' over four list elements at a time such that fusion can still occur?
05:04:08 <zincy> Whats fusion
05:05:03 <ChaiTRex> It combines things so that they use less memory for the most part. For example: map (+1) . map (*2) will create two intermediate lists unless it's fused into map ((+1) . (*2))
05:05:09 <mniip> ChaiTRex, you might need to write your own fusion rules
05:05:22 <ChaiTRex> mniip: Ahh. Hmm, OK.
05:05:39 <mniip> alternatively you could use foldl, but with a tricky function
05:05:58 <mniip> one that pushes elements into a "stack" and when there's 4 does whatever needs to be done
05:24:25 <kuribas> hpc: it's not hard to create a large and complex ruby application :)
05:24:55 <kuribas> hpc: better brag about creating the smallest and leanest haskell applications in industry.
05:25:36 <kuribas> hpc: "we created a CMS in haskell in only 10 lines".
05:31:13 <barrucadu> Funny, I've been doing a lot of Ruby at work, and last night played around with servant for the first time, and was impressed with how concise and clear the Haskell was compared to what the Ruby would have been
05:36:31 <zincy> Does anyone know why the timeout is killing the thread that is listening for messages? https://lpaste.net/1927765005311148032
05:40:04 <dreamer_> Is it okay to unsafePerformIO mapConcurrently
05:40:22 <dreamer_> or is t a horrible crime
05:40:46 <merijn> dreamer_: Horrible crime
05:40:56 <merijn> dreamer_: Why would you want that?
05:41:19 <dreamer_> because even though I am going to be using the pure function in a IO Monad
05:41:22 <merijn> Because it sounds more like you'd want the parallel strategies approach if you're wanting to do a pure map in parallel
05:41:53 <dreamer_> I just want to parallelize it and I don't like having to rewrite the whole functional chain in Monadic style
05:42:11 <dreamer_> Oho~
05:42:15 <merijn> dreamer_: https://hackage.haskell.org/package/parallel-3.2.1.1
05:42:17 <dreamer_> parallel strategies is it
05:43:40 <merijn> dreamer_: Obviously someone has already thought about and figured out the issue of "I wanna do pure/deterministic parallelism in Haskell" ;)
05:44:14 <dmwit> zincy: Why should we believe the timeout won't kill its argument?
05:44:51 <zincy> I thought that timeout would spawn a new thread which is the timer and the timer thread would be killed?
05:45:26 <dmwit> Sure. The new thread for the computation you pass it is also killed when the timer expires.
05:45:32 <dmwit> Or else what would be the point?
05:45:50 <zincy> Ok thanks so much
05:45:53 <zincy> that makes sense
05:46:10 <zincy> I am not sure if what I wrote is a solution to my actual problem then
05:46:34 <zincy> I mean the timer should not run for every action
05:46:40 <zincy> sorry
05:46:47 <zincy> the timer should not run continously
05:47:10 <zincy> What abstraction would I use to conditionally wrap an IO computation in a timeout?
05:47:45 <dreamer_> thanks merijin
05:47:58 <zincy> I guess on each state transition you could check to see if a timeout is applicable or not
05:48:04 <zincy> concurrency is complicated
05:48:17 <dmwit> `timeout` seems like a fine way to wrap an IO computation in a timeout.
05:48:41 <dmwit> I'm a bit confused about 1. what you expected to happen 2. what you want to happen 3. what you observed happening instead.
05:50:08 <zincy> me too
05:52:07 <amar_> Hey - does anybody know - how many active devs working on GHC?
05:52:19 <dmwit> zincy: https://xkcd.com/568/
05:53:00 <robstr> Hey, I'm using the `req` package, is it possible to _just print_ the entire request with all headers & payload for debugging purpose ?
05:54:48 <lyxia> amar_: https://ghc.haskell.org/trac/ghc/wiki/TeamGHC maybe this can give you some estimate?
05:55:01 <dminuoso> Im trying to identify the correct algebraic structure of ADTs. It seems that they are semirings. Or are they more?
05:55:20 <dmwit> robstr: Looks tricky but possible. You can use `getRequestBody` and `getRequestContentType`, then pattern match on the `RequestBody`.
05:55:49 <dminuoso> + is a full monoid, * is a full monoid, and + commutes.
05:56:05 <dminuoso> (up to iso)
05:56:37 <dmwit> * also commutes up to iso, and distributes over +
05:57:13 <dminuoso> dmwit: As far as I can tell any further progression requires + to be abelian though
05:57:17 <amar_> lyxia: Thanks that helps
05:57:31 <dminuoso> *an abelian group!
05:57:45 <dminuoso> Or is there some quirky way to have a negative type?
05:57:58 <dmwit> Well. There is, yes.
05:58:05 <dmwit> But you're not going to like it. =P
05:58:42 <dmwit> I think you could probably say "a ring where + doesn't have inverses" and be just fine.
05:59:00 <dminuoso> Well that is called a semiring :P
05:59:13 <dmwit> *Probably* what you want to say is that you have a Cartesian closed category.
05:59:44 <dmwit> Oh, so it is.
06:00:17 <dmwit> I bet there's not a lot of algebraic structures with Mu. =)
06:00:42 <robstr> dmwit: thank you
06:00:58 <dmwit> Hm, and I guess cartesian-closed doesn't imply sums.
06:01:08 <ij> Is there a defined %%~ that sets rather than modifies? i.e. \lens setter -> lens %%~ (const setter)
06:01:30 <dmwit> :t (%=)
06:01:32 <lambdabot> MonadState s m => ASetter s s a b -> (a -> b) -> m ()
06:01:44 <dmwit> :t (%~)
06:01:45 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
06:02:25 <dmwit> :t (~.) -- perhaps this, ij
06:02:27 <lambdabot> error:
06:02:27 <lambdabot>     • Variable not in scope: ~.
06:02:27 <lambdabot>     • Perhaps you meant one of these:
06:02:31 <dmwit> ugh
06:02:34 <dmwit> I am terrible with lens.
06:02:36 <dmwit> :t (.~)
06:02:38 <lambdabot> ASetter s t a b -> b -> s -> t
06:02:49 <ij> %%~ is id, so I can return a result inside an applicative
06:02:51 <dmwit> :t (.=)
06:02:53 <lambdabot> MonadState s m => ASetter s s a b -> b -> m ()
06:03:00 <ij> sorry for not stating that initially
06:03:11 <nshepperd> :t (%%~)
06:03:12 <lambdabot> LensLike f s t a b -> (a -> f b) -> s -> f t
06:04:17 <dmwit> ij: Does (.=) not do that?
06:04:47 <ij> The applicative might not have a MonadState.
06:05:02 <dmwit> aha
06:05:39 <nshepperd> @hoogle LensLike f s t a b -> f b -> s -> f t
06:05:39 <lambdabot> Control.Lens.Lens (%%~) :: LensLike f s t a b -> (a -> f b) -> s -> f t
06:05:39 <lambdabot> Control.Lens.Operators (%%~) :: LensLike f s t a b -> (a -> f b) -> s -> f t
06:05:40 <lambdabot> Control.Lens.Traversal traverseOf :: LensLike f s t a b -> (a -> f b) -> s -> f t
06:07:02 <nshepperd> doesn't seem to exist
06:09:36 <ij> Yeah, couldn't find it near %%~ definition in lesn source either.
06:09:39 <ij> oh well :)
06:10:43 <dmwit> I like your nick, though, so you got that going for you, which is nice.
06:10:52 <ij> haha, thanks :)
06:12:58 <dminuoso> dmwit: I guess you could call it a semidomain (if such a thing existed)
06:13:10 <dminuoso> Or even an integral semidomain
06:17:07 <dminuoso> 14:57           dmwit | But you're not going to like it. =P
06:17:13 <dminuoso> What were you on about by the way?
06:18:14 <dmwit> https://github.com/dmwit/pi-eta-epsilon/blob/master/docs/rational.pdf
06:18:24 <dmwit> The paper exists elsewhere but I'm too lazy to find it.
06:18:49 <dmwit> Negative types are time travel. Fractional types are unification variables.
06:37:46 <c50a326> what do these pattern matchings mean in this adt def:   data Tree a = Empty | Node a (Tree a) (Tree a)
06:38:16 <c50a326> why are the trees in parenths
06:39:15 <hexagoxel> because the "Node" constructor has three arguments. "Node a Tree a Tree a" would be parsed as a constructor with five arguments.
06:39:45 <c50a326> ah okay thanks
06:43:48 <Guest98805> Hi guys anyone here active?
06:44:13 <Guest98805> Have some questions and looking for some marketing / growth hacking advices
06:44:25 <cocreature> you’re in the wrong channel for that
06:44:31 <cocreature> this channel is about the Haskell programming language
06:44:54 <Guest98805> oh right I see
06:45:03 <Guest98805> cheers cocreature
06:45:08 <Guest98805> tought its a marketing channel
06:59:05 <dmwit> I wonder why they thought that.
07:00:03 <m2[m]> Well I just looked up Haskell marketing and there is some kind of management consulting company called Haskell
07:00:46 <philippD> http://www.haskell.com/
07:00:59 <dreamer_> Is there a marketing monad
07:02:21 <ventonegro> Just give the marketers the right lens to see Haskell from a different prism
07:02:31 <cocreature> dreamer_: lens has a Profunctor called Market
07:03:16 <dreamer_> amazing.
07:04:25 <[exa]> ◔.◔  Market
07:05:08 <Rembane> I think there is a marketing monad. In the lenses library.
07:05:39 <Taneb> Market isn't a Monad, but it is a Profunctor
07:05:46 <Rembane> Oh.
07:05:54 <Rembane> I got them messed up.
07:05:58 <Taneb> data Market a b s t = Market (b -> t) (s -> Either t a)
07:06:26 <Rembane> It is pro though. No amateurish functor.
07:06:57 <dminuoso> newtype Bazaar p a b t = Bazaar { runBazaar :: forall f. Applicative f => p a (f b) -> f t }
07:07:05 <dminuoso> Mmm. Similar names :o
07:10:59 * hackage relational-query-HDBC 0.6.8.1 - HDBC instance of relational-query and typed query interface for HDBC  http://hackage.haskell.org/package/relational-query-HDBC-0.6.8.1 (KeiHibino)
07:18:00 * hackage tasty-html 0.4.1.2 - Render tasty output to HTML  http://hackage.haskell.org/package/tasty-html-0.4.1.2 (RomanCheplyaka)
07:19:02 <dminuoso> Taneb: Oh wait. Isnt that just a Prism?
07:20:05 <dminuoso> It kind of looks like the pre-profunctor optics representation of it
07:23:00 * hackage miso 0.20.1.0 - A tasty Haskell front-end framework  http://hackage.haskell.org/package/miso-0.20.1.0 (DavidJohnson)
07:28:43 <dmj`> cocreature: slack offline?
07:29:14 <Taneb> dmj`: it's facing outages all over
07:29:37 <dmj`> Taneb: :(
07:34:44 <c50a326> muahahaha
07:34:50 <c50a326> bloody slack... take that...
07:40:00 * hackage QuickCheckVariant 1.0.0.1 - Generator of "valid" and "invalid" data in a type class  http://hackage.haskell.org/package/QuickCheckVariant-1.0.0.1 (sanjorgek)
07:44:00 * hackage extensible-effects-concurrent 0.3.0.1 - Message passing concurrency as extensible-effect  http://hackage.haskell.org/package/extensible-effects-concurrent-0.3.0.1 (SvenHeyll)
07:46:23 <srk> c50a326: this!
08:01:26 <ffwacom> https://usercontent.irccloud-cdn.com/file/WwdpiYAL/image.png
08:01:59 <ffwacom> https://usercontent.irccloud-cdn.com/file/O5cJSTmb/image.png
08:02:20 <ffwacom> throwbacks
08:04:39 <NameReplicator> Is there an existing way of compiling GHC Core into untyped lambda calculus/some combinatory logic?
08:06:59 * hackage relational-query-HDBC 0.7.0.0 - HDBC instance of relational-query and typed query interface for HDBC  http://hackage.haskell.org/package/relational-query-HDBC-0.7.0.0 (KeiHibino)
08:07:26 <jakov> q
08:11:34 <c50a326> what's the quickest way to search hoogle? just on their site, or do you guys use other techniques?
08:12:04 <glittershark> c50a326: `stack hoogle` is fun
08:14:37 <sm> I use a firefox bookmark/browser shortcut
08:15:24 <ddellacosta> c50a326: you can set up a `:hoogle` helper command in ghci too which is handy
08:15:49 <ddellacosta> https://wiki.haskell.org/Hoogle#GHCi_Integration
08:16:08 <ddellacosta> can set it up with stack too, if I recall correctly
08:33:00 <reactormonk> Is there something like "this type should not be a Maybe" as a constraint? Mostly for debugging purposes.
08:34:17 <Solonarv> you can do with with a type family
08:35:04 <reactormonk> Ah, nice idea!
08:35:32 <reactormonk> Is there something like a TypeWarning? Where I can print if a constraint has been requested
08:35:43 <Solonarv> type family IsNotMaybe (f :: Type -> Type) :: Constraint where IsNotMaybe Maybe = TypeError (ShowType Maybe :<>: Text " cannot be Maybe"); IsNotMaybe f = ()
08:35:58 <Solonarv> % :k TypeError
08:35:58 <yahb> Solonarv: TypeError :: *
08:36:03 <glittershark> reactormonk: TypeError is in GHC.TypeLits
08:36:44 <reactormonk> glittershark, yeah, but I don't want it to crash
08:36:56 <glittershark> ah
08:37:12 <glittershark> there's a WARNING pragma but I think that's only for functions
08:38:55 <reactormonk> Solonarv, sorry, I'd be more looking for `a !~ Maybe b`, not testing `a ~ Maybe`
08:39:41 <Solonarv> you can't negate constraints-in-general, because of the open-world assumption
08:41:15 <Solonarv> you can get inequality constraints with this type family: https://lpaste.net/6756892771119792128
08:42:41 <moony> i think i'm finally getting how haskell works. may as well preemptively join the IRC channel
08:42:46 <ziman> hello, is there a way to see where a certain instance is defined? a piece of code compiles even though I think it shouldn't because of a missing instance (unfortunately I can't reduce and lpaste it, it's a multi-library thing, with many orphans here and there)
08:43:41 <Solonarv> there is a way to find where an instance is defined, but idk how (sorry, I know this isn't very helpful)
08:43:53 <electrocat> ziman: load the module in ghci and use ':info <TypeClass>'
08:43:53 <ziman> in the corresponding .dump-hi file, I can see a reference to something that should be defined in the same module but I can't see it in surface syntax anywhere
08:43:54 <glittershark> ziman: :i on the typeclass in GHCi?
08:44:19 <Solonarv> % :i Monoid
08:44:19 <yahb> Solonarv: class Semigroup a => Monoid a where; mempty :: a; mappend :: a -> a -> a; mconcat :: [a] -> a; {-# MINIMAL mempty #-}; -- Defined in `GHC.Base'; instance [safe] Applicative f => Monoid (Traversed a f) -- Defined in `Control.Lens.Internal.Fold'; instance [safe] Monad m => Monoid (Sequenced a m) -- Defined in `Control.Lens.Internal.Fold'; instance [safe] Monoid (Rightmost a) -- Defined in `Contro
08:45:21 <ziman> oh, that would be neat, let me see
08:46:40 <ziman> there are many instances but mine does not seem to be listed there
08:47:27 <ziman> sorry for the vagueness, I don't know how I could make this more explicit since I can't reasonably share the code
08:47:41 <ziman> i'll dig in the core and see if i can find anything
08:47:53 <Solonarv> if you know what type the instance is for you can also try :i on that
08:48:21 <Solonarv> and obviously make sure you've loaded the module that's compiling but shouldn't (using :m + Module)
08:49:01 <ziman> thank you, ill try that
08:51:35 <Solonarv> this might be relevant: https://downloads.haskell.org/~ghc/7.6.2/docs/html/users_guide/interactive-evaluation.html#ghci-scope
08:52:07 <c50a326> hey does the ghci have something to show data types (:t doesn't work on names defined with the data keyword)
08:52:09 <Solonarv> so you'd want to do `:m + *Offending.Module` to make your scope match the scope of Offending.Module's top-level
08:52:30 <Solonarv> use :i
08:52:34 <Solonarv> % :i Maybe
08:52:35 <yahb> Solonarv: data Maybe a = Nothing | Just a -- Defined in `GHC.Maybe'; instance Alternative Maybe -- Defined in `GHC.Base'; instance Applicative Maybe -- Defined in `GHC.Base'; instance Eq a => Eq (Maybe a) -- Defined in `GHC.Maybe'; instance Functor Maybe -- Defined in `GHC.Base'; instance Monad Maybe -- Defined in `GHC.Base'; instance MonadPlus Maybe -- Defined in `GHC.Base'; instance Semigroup a => Monoid (Maybe
08:53:47 <ziman> oh, * is neat
08:54:59 <ziman> it seems that I cannot :load the library module that contains the type I'm interested in, that's strange
08:55:09 <ziman> it says the module cannot be found locally
08:55:37 <ziman> (I'm using stack ghci so I'd expect everything to just work™)
08:58:49 <cocreature> do we have a package for hashing Haskell values using something like sha256?
08:58:52 <ziman> okay, i'll take a break from it for now, thank you very much
08:58:58 <cocreature> I found large-hashable but that actually only includes md5
08:59:30 <cocreature> and I’m hoping for somethinga bit more convenient than first having to convert my value to a ByteString
08:59:58 <infinisil> But sha256 works over bytestrings?
09:00:21 <cocreature> infinisil: right but I’m hoping for some kind of typeclass that allows be to easily compose things
09:00:38 <c50a326> what's the syntax to... if I have a LogMessage from here http://www.cis.upenn.edu/~cis194/spring13/extras/02-ADTs/Log.hs how do I pattern match to just get the TimeStamp Int ?
09:01:13 <infinisil> cocreature: Hmm, it would be a bit weird for the package to decide how values should be encoded though
09:02:00 <cocreature> infinisil: would it? the hashable package does the same. my only problem with that is that it only produces an Int as the hash
09:02:16 <infinisil> Hmm, going through aeson would work
09:02:17 <Solonarv> I can't think of anything better than hash . Data.Binary.encode
09:02:36 <cocreature> alright, I’ll just go with that then
09:02:42 <Solonarv> you can generic-derive a Binary instance so it shouldn't be much work
09:03:04 <infinisil> Oh, I didn't know about Data.Binary.encode
09:03:04 <cocreature> ah good point, I forgot about that!
09:08:33 <glittershark> fwiw I've benchmarked most of the generic binary encoding libraries and http://hackage.haskell.org/package/store is fastest by a fair bit
09:08:41 <glittershark> but also produces the most bytes of data
09:09:27 <glittershark> here's the benchmarks cocreature https://gist.github.com/glittershark/2a068ed70c51b18bba673c0fbd553d80
09:09:38 <Solonarv> it's also architecture dependent though, which might be a problem
09:09:51 <cocreature> glittershark: thanks! I don’t really care about performance here so I’m probably going to stick to binary but I’ll definitely keep it in mind
09:10:03 <glittershark> :+1:
09:10:09 <glittershark> yeah sometimes perf just doesn't matter
09:11:08 <Solonarv> with crypto it could sometimes be argued that being slow is a benefit anyway :P
09:11:43 <glittershark> well depends on the situation
09:12:19 <c50a326> data Tree a = Empty | Node a (Tree a) (Tree a) deriving Show
09:12:26 <c50a326> let t = Node 1 Empty Empty
09:13:01 <c50a326> let (Node n) = t  -- this doesn't work but maybe you can see what I want to do?
09:13:10 <c50a326> well I want to get the 1
09:13:15 <c50a326> what syntax do I have to use?
09:13:22 <glittershark> let (Node n _ _) = t ?
09:13:28 <c50a326> ah ty
09:16:41 <infinisil> cocreature: I mean, since you pipe it into sha256, it might as well be fast, because you don't have to really care about the size
09:17:00 <infinisil> I guess it doesn't matter for small values anyways though :)
09:30:00 <c50a326> is there a nice way of printing stuff like trees in ghci
09:30:08 <c50a326> Node (Node Leaf (LogMessage Info 25 "la la la") (Node (Node Leaf (LogMessage Info 29 "la la la") Leaf) (LogMessage Info 30 "la la la") Leaf)) (LogMessage Info 35 "la la la") Leaf
09:30:21 <cocreature> c50a326: you might be interested in the pretty-show package
09:31:39 <Biontry> https://tinyurl.com/ya79dnx5
09:31:40 <Solonarv> it's a bit hackish but it very much Just Works™
09:31:59 <c50a326> cocreature: where is the documentation like if I go to Node (Node Leaf (LogMessage Info 25 "la la la") (Node (Node Leaf (LogMessage Info 29 "la la la") Leaf) (LogMessage Info 30 "la la la") Leaf)) (LogMessage Info 35 "la la la") Leaf
09:32:02 <c50a326> oops
09:32:07 <c50a326> http://hackage.haskell.org/package/pretty-show
09:32:21 <c50a326> every time im on this site it says "Docs available"
09:32:22 <cocreature> basically just use ppShow instead of show
09:32:33 <cocreature> huh? just click on the module name
09:32:35 <Solonarv> or pPrint instead of print
09:32:48 <c50a326> ah like this? http://hackage.haskell.org/package/pretty-show-1.7/docs/Text-Show-Pretty.html
09:32:52 <cocreature> exactly
09:32:58 <c50a326> what about installation?
09:33:25 <c50a326> I suppose if it's on hackage I can just use stack
09:34:53 <Solonarv> yeah that'll do
10:31:52 <`Guest00000> c50a326: Data.Tree, which is in containers, contains  drawTree :: Tree String -> String
10:36:30 <liste> > drawTree (Node "wow" [Node "it's" [], Node "cool!" []])
10:36:32 <lambdabot>  "wow\n|\n+- it's\n|\n`- cool!\n"
10:36:41 <liste> > text $ drawTree (Node "wow" [Node "it's" [], Node "cool!" []])
10:36:43 <lambdabot>  wow
10:36:43 <lambdabot>  |
10:36:43 <lambdabot>  +- it's
10:37:15 <Solonarv> %% putStrLn $ drawTree (Node "wow" [Node "it's" [], Node "cool!" []])
10:37:15 <yahb> Solonarv: http://qp.mniip.com/y/66
10:40:10 <int-e> liste: fwiw, lambdabot will produce the whole output for that in private chat
11:29:06 <pikajude> hello, is there a good way to extract build information out of cabal programmatically?
11:29:38 <pikajude> i.e. what packages will be built, their versions, their sources, etc
11:36:28 <c50a326> data LogMessage = Unknown String | LogMessage Something Blah Lala
11:37:04 <c50a326> how do I check if a LogMessage is Unknown String or a proper LogMessage?
11:37:43 <pikajude> --dry-run shows me names and versions but i'd also like to retain information that's from, like, file or git sources
11:38:26 <sclv> pikajude: there's a plan.json that's generated by new build
11:38:37 <__monty__> c50a326: Pattern match?
11:38:56 <sclv> pikajude: cf http://hackage.haskell.org/package/cabal-plan
11:39:22 <pikajude> oh, really?
11:39:25 <pikajude> ok
11:39:41 <pikajude> thanks sclv that's useful
11:40:19 <c50a326> __monty__: I tried that and got Irrefutable pattern failed for pattern LogMessage _ x _
11:41:00 <c50a326> what happens if there's an Int in LogMessage, but the thing is actually Unknown, so just a String, but x is supposed to be the Int in LogMessage
11:41:08 <c50a326> what is x at that point? is there a way I can check for that?
11:42:29 <__monty__> c50a326: I was talking about bread and butter pattern matching: isUnknown (Unknown _) = True; isUnknown _ = False
11:44:54 <c50a326> ah I can do this where Unknown takes a string:  (Unknown s) = not $ null s
11:45:03 <c50a326> I'm within a where statement btw
11:45:52 <c50a326> oh wait ignore that
11:46:37 <napping> Is unification-fd the only package with a class for comparing terms in a functor, with a method like f a -> f b -> Maybe (f (a,b))?
11:51:36 <__monty__> c50a326: Did that help you at all? I'm not quite sure I understood your question.
11:52:53 <c50a326> __monty__: I thought it did but then it didn't :D here's my code at the moment https://lpaste.net/1138678486815211520
11:53:26 <c50a326> I'm now getting irrefutable pattern thingy on line 13 when I try to insert a LogMessage (not an Unknown) so it doesn't like that D:
11:53:35 <fishythefish> c50a326: where clauses are not the same as case
11:54:40 <c50a326> oh maybe I need to do case of
11:54:44 <__monty__> insert (Unknown unknown) tree | not $ null unknown = tree <- The pattern match needs to happen on the lhs, or in a case expression.
11:54:57 <fishythefish> you can change insert to do an explicit `case msg of ...` or just define `insert (Unknown unknown) tree = ...`, `insert (LogMessage _ msgTime _) tree = ...`, etc.
11:55:12 <fishythefish> there are also pattern guards
11:56:51 <c50a326> I'm using pattern guards already aren't I?
11:56:57 <c50a326> or some kinds of guards anyway
11:57:05 <__monty__> Those are regular guards.
11:57:17 <c50a326> ah yeah they're like conditional guards
11:57:21 <__monty__> https://wiki.haskell.org/Pattern_guard
11:57:31 <__monty__> It allows pattern matching in guards.
12:04:39 <mreh> angerman, should I need to specify the package databases when using toolchain-wrapper?
12:06:42 <lolmonad> Hello.
12:06:55 <byorgey> hi lolmonad
12:07:09 <lolmonad> What are some reasons to use Stack now that Cabal's new-build etc. are here?
12:08:16 <electrocat> lolmonad: stack conveniently provides a ghc installation as wel
12:09:30 <phadej> stack is Stackage oriented, cabal is dependency solving oriented
12:10:07 <phadej> neither is universally better apaproach
12:10:51 <__monty__> phadej: Cabal + stackage is pretty much equivalent to the former too though?
12:10:54 <napping> lolmonad: I'm not sure there's much advantage for actual compilation, but stack fetching a prescribed GHC version is nice
12:11:18 <lolmonad> ok great
12:11:24 <lolmonad> that's most def an advantage
12:11:28 <lolmonad> thanks mates
12:12:59 <mreh> how does it manage the package databases? flags to cabal?
12:13:33 <phadej> installing ghc thrue chocolatey (win) / hvr-ppa (ubuntu) or brew (macOS) is not hard either
12:14:05 <phadej> especially if you use those to get cabal-install too
12:14:10 <napping> I think it mostly uses the ghc-level package database stuff, I know it used to do some hacky stuff to get package reuse before GHC natively supported multiple package builds
12:14:15 <__monty__> Through nix it's a little harder but a lot awesomer ; )
12:14:20 <napping> Not sure if they still do
12:15:45 <phadej> mreh: which one, stack?
12:16:12 <mreh> phadej, yeah
12:17:18 <phadej> stack has package-db per each snapshot
12:18:17 <napping> mreh: stack does compute the package flags to pass, but ghc takes all those flags directly so stack doesn't ordinarily need to run cabal (it only runs it for the dependency solver)
12:18:39 <mreh> napping, it uses the Cabal API directly doesn't it
12:18:47 <mreh> rather than cabal-install
12:18:50 <phadej> for package-db, there is ghc-pkg executable
12:19:22 <napping> mreh: It does that too, but to control package selection you can just run things like `ghc --package-db=whatever --package --package ...`
12:19:22 <mreh> I was thinking about trying to get stack to work for cross compilation
12:20:06 <napping> I don't know the details, but in verbose mode it will show exactly what is running
12:21:02 <pikajude> hmm, I'm misusing new-build somehow
12:21:14 <pikajude> I'm getting the TODO: add support for multiple packages in a directory error
12:21:34 <pikajude> oh wait, never mind
12:21:40 <pikajude> I have to move cabal.project.local to cabal.project
12:21:42 <pikajude> lol, why
12:23:23 <mreh> packages != 1
12:29:50 <pikajude> but they're not in the same directory
12:30:51 <pikajude> damn, plan.json doesn't have the information I expected
12:34:07 <sclv> pikajude: some of the information you may want may not exist
12:34:13 <sclv> at the moment cabal doesn't fetch from repos or whatever
12:34:17 <pikajude> certainly
12:34:28 <c50a326> not $ (==3) . length $ words "I 321 jdjoiDOIAS"   -- what's the nicest way to also check for (==4) in here?
12:34:28 <pikajude> you did indeed guess what information i was looking for
12:34:30 <sclv> so it presumes all packages are in the upstream package repositories
12:34:33 <pikajude> it all has to be in hackage
12:34:38 <sclv> not necc hackage
12:34:39 <pikajude> unfortunate
12:34:42 <sclv> you can change your repositories
12:34:50 <sclv> and have other local ones, etc
12:34:58 <pikajude> yeah, but i still need to set that up
12:35:08 <sclv> so what exactly is the end-goal here
12:35:36 <pikajude> i would like to be able to run nix-shell except sometimes the package versions that exist in nixpkgs aren't the ones i need
12:35:39 <pikajude> either too new or too old
12:36:00 <pikajude> so ideally i would run the cabal solver, take those package versions and generate a default.nix or shell.nix with the cabal2nix outputs
12:36:18 <pikajude> which would be useful
12:36:22 <pavonia> c50a326: (`elem` [3,4]) is an option
12:36:36 <sclv> pikajude: ok but the plan.json sounds like enough then?
12:36:37 <pikajude> also some packages aren't on hackage at all, like most of reflex-platform is on git
12:36:40 <mreh> can I get stack to print a resolved list of packages against a snapshot?
12:36:43 <sclv> oh except for that :-)
12:36:48 <pikajude> github, sorry
12:36:56 <sclv> yeah, also unforunately plan.json is just for new-build
12:37:04 <pikajude> well that's not a problem, i'm fine with using that
12:37:06 <sclv> which doesn't play nicely with nix anyway yet
12:37:09 <mreh> stack ls dependencies?
12:37:21 <pikajude> but cabal itself does not yet support repository dependencies
12:37:25 <pikajude> so i'm barking up the wrong tree here
12:37:31 <sclv> right
12:37:33 <pikajude> will just have to go with the manual method until it has that
12:38:05 <sclv> hrm wait actaully
12:38:05 <__monty__> sclv: In what way does it not? I use cabal new-build and new-repl in nix environments.
12:38:16 <sclv> __monty__: i just meant the full integration isn't there
12:38:25 <__monty__> Ah, got it.
12:38:27 <sclv> pikajude: ok here's a dumb hack. if you have a fixed limited set of github deps
12:38:45 <sclv> you can just fetch them into the local directory directly as vendored things
12:38:50 <sclv> then new-build can see them when it solves
12:39:08 <pikajude> i could do that
12:39:14 <sclv> then of course the solver wn't solve for them, but it will, treating them as fixed vendored bits, solve for everything else
12:39:20 <pikajude> but plan.json doesn't actually have the filepath of the source directory of vendored deps
12:39:23 <sclv> so you can pin the non-hackage stuff and let the solver handle the rest
12:39:25 <pikajude> so i would have to go find them
12:39:27 <pikajude> somehow
12:39:44 <sclv> right, to even have a plan.json you need to have the vendored deps in your directory to begin with
12:39:54 <pikajude> well just the sources
12:39:56 <pikajude> and then i can run the solver
12:39:57 <sclv> otherwise the solver can't run if it can't see the stuff
12:39:57 <sclv> right
12:40:06 <pikajude> but if i want to produce a nix expression from it, i need to know where the vendored deps are in order to cabal2nix them
12:40:11 <pikajude> and plan.json doesn't tell me
12:40:11 <sclv> right
12:40:19 <pikajude> so i would have to...guess
12:40:37 <sclv> so you don't have a magic tool, but a tool that takes _as input_ a fixed collection of deps-to-be-vendored locations
12:40:50 <pikajude> sure
12:41:07 <pikajude> well, there's no magic, i would still have to list the vendored deps in my cabal.project anyway
12:41:29 * hackage tasty-hspec 1.1.5 - Hspec support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-hspec-1.1.5 (mitchellwrosen)
12:50:17 <justaguest> I'm working through Haskell From First Principles CH25, and they have:
12:50:20 <justaguest> newtype Compose f g a = Compose { getCompose :: f (g a) }
12:51:01 <justaguest> applicative is supposed to be defined as: (Compose f) <*> (Compose a) = Compose $ liftA2 (<*>) f a
12:51:19 <justaguest> how do I understand why this works?
12:51:49 <justaguest> I don't understand the liftA2 (<*>) f a part
12:52:22 <liste> justaguest: do you know how <*> works for just functions?
12:52:52 <liste> > ((+3) <*> (*2)) 5
12:52:54 <lambdabot>  error:
12:52:54 <lambdabot>      • Couldn't match type ‘Integer’ with ‘Integer -> t’
12:52:54 <lambdabot>        Expected type: (Integer -> t) -> Integer
12:53:18 <justaguest> somewhat, it applies a single argument to multiple functions at the same time
12:54:34 <justaguest> I think
12:54:40 <liste> yes
12:56:04 <liste> (<*>) f g x = f x (g x)
12:56:16 <liste> from https://hackage.haskell.org/package/base-4.11.1.0/docs/src/GHC.Base.html#line-798
12:56:34 * hackage bugsnag-haskell 0.0.1.2 - Bugsnag error reporter for Haskell  http://hackage.haskell.org/package/bugsnag-haskell-0.0.1.2 (PatrickBrisbin)
12:56:48 <liste> > ((+) <*> (+1)) 5
12:56:50 <lambdabot>  11
12:58:47 <liste> though that's only a single case of "f" though
12:59:40 <justaguest> I see
12:59:45 <mjoldfield> liste : Is this the same as the Applicative instance for ((->) r)
13:00:16 <justaguest> they also give the type as: (<*>) :: Compose f g (a -> b) -> Compose f g a -> Compose f g b
13:02:04 <justaguest> ((+) <*> (+1)) 5 is similar to (f <*> g) x
13:05:30 <hexagoxel> is the function/Reader Applicative really relevant? i don't see it getting used in that instance
13:06:15 <hexagoxel> justaguest: do you realize the types of `f` and `a` in that instance? Also, are you familiar with the source of `liftA2` ?
13:08:06 <jle`> justaguest: if you're familiar with liftA2, note that (<*>) is `liftA2 ($)`
13:08:16 <jle`> it lifts function application over a layer of applicatives
13:08:19 <jle`> :t liftA2
13:08:20 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
13:08:24 <jle`> :t liftA2 ($)
13:08:25 <lambdabot> Applicative f => f (a -> c) -> f a -> f c
13:08:36 <jle`> so what's going on here is they are "lifting" ($) twice
13:08:43 <jle`> :t liftA2 . liftA2
13:08:45 <lambdabot> (Applicative f2, Applicative f1) => (a -> b -> c) -> f1 (f2 a) -> f1 (f2 b) -> f1 (f2 c)
13:08:47 <jle`> ^ lift over two layers
13:08:48 <justaguest> For a concrete example, i'm using "Compose [Just 1, Nothing]". f is [], g is Maybe a, a is Int?
13:08:53 <jle`> :t liftA2 (liftA2 ($))
13:08:55 <lambdabot> (Applicative f2, Applicative f1) => f1 (f2 (a -> c)) -> f1 (f2 a) -> f1 (f2 c)
13:09:01 <jle`> we are "lifting" ($) over two layers of Applicatives
13:09:14 <jle`> :t Compose [Just True, Nothing]
13:09:15 <lambdabot> error:
13:09:15 <lambdabot>     • Data constructor not in scope: Compose :: [Maybe Bool] -> t
13:09:15 <lambdabot>     • Perhaps you meant variable ‘icompose’ (imported from Control.Lens)
13:09:21 <jle`> @let import Data.Functor.Compose
13:09:23 <lambdabot>  Defined.
13:09:24 <jle`> :t Compose [Just True, Nothing]
13:09:25 <lambdabot> Compose [] Maybe Bool
13:09:49 <jle`> > liftA2 (liftA2 negate) [Just 1, Nothing]
13:09:51 <lambdabot>  error:
13:09:51 <lambdabot>      • No instance for (Typeable b0)
13:09:51 <lambdabot>          arising from a use of ‘show_M69877245186714311168294’
13:09:52 <jle`> er
13:10:01 <jle`> > liftA2 (liftA2 (+)) [Just 1, Nothing] [Nothing, Just 3]
13:10:03 <lambdabot>  [Nothing,Just 4,Nothing,Nothing]
13:10:13 <jle`> ^ lifting (+) over two layers of Applicatives
13:10:29 <jle`> > liftA2 (liftA2 ($)) [Just negate, Nothing] [Nothing, Just 3]
13:10:31 <lambdabot>  [Nothing,Just (-3),Nothing,Nothing]
13:10:36 <jle`> ^ lifting ($) (function application) over two layers of Applicatives
13:14:39 <hexagoxel> justaguest: i meant the value-level `f` and `a`. and yes, it is kind of confusing to have variables reused over value/type level there :/
13:16:19 <hexagoxel> i.e. if you have "(<*>) :: Compose f g (a -> b) -> Compose f g a -> Compose f g b"
13:17:01 <hexagoxel> and "Compose x <*> Compose y = _ x y", what would be the type of _ ?
13:18:32 <justaguest> hmm
13:20:09 <justaguest> I have no idea. x is f g (a->b) and y is f g a
13:20:34 <hexagoxel> right, apart from the parentheses you need:
13:20:43 <Profpatsch> Is there something like an abstract implementation of a binary search algorithm?
13:20:56 <hexagoxel> x :: f (g (a -> b)), y :: f (g a)
13:21:06 <Profpatsch> e.g. I give it something like a seekable sequence and it returns the item?
13:21:31 <Profpatsch> *the first item that returns true for a predicate
13:22:15 <Profpatsch> Because I’ve been wanting that in some cases, like implementing a custom git bisect
13:22:29 <Profpatsch> Or maybe it doesn’t make sense to abstract that out.
13:23:41 <hexagoxel> justaguest: so if we inline the `liftA2`, our implementation looks like this:
13:23:41 <hexagoxel> .. = (<*>) <$> (x :: f (g (a -> b))) <*> (y :: f (g a))
13:25:24 <justaguest> which is equivalent to "liftA2  (x :: f (g (a -> b))) (y :: f (g a))"
13:25:38 <Profpatsch> Okay, I could have searched for binary search on hackage and clicked the first link https://hackage.haskell.org/package/binary-search-1.0.0.3/docs/Numeric-Search.html
13:25:52 <hexagoxel> justaguest: you missed the (<*>)
13:26:13 <justaguest> liftA2 (<*>) (x :: f (g (a -> b))) (y :: f (g a))
13:26:24 <hexagoxel> right, those are the same
13:26:50 <hexagoxel> as the next step, i'd also think about the (<*>) in that line.
13:29:11 <hexagoxel> :t (<$>)
13:29:12 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:29:57 <hexagoxel> we pass (<*>) as the "a -> b" of that, and (x :: f (g (a -> b))) as the "f a"
13:31:43 <hexagoxel> with a few steps of inference, we can deduce that (<*>) :: g (a -> b) -> g a -> g b
13:32:11 <justaguest> if (<*>) is a->b, then b has to be a function? since (<*>) takes 2 arguments
13:32:26 <hexagoxel> right
13:33:16 <hexagoxel> together: ((<*>) :: g (a -> b) -> g a -> g b)) <$> (x :: f (g (a -> b))) <*> (y :: f (g a))
13:33:52 <noipmups> Hi, anyone have experience with calling C++ library from Haskell?
13:34:41 <hexagoxel> for the liftA2 version, rather similar:
13:34:45 <hexagoxel> liftA2 ((<*>) :: g (a -> b) -> g a -> g b) (x :: f (g (a -> b))) (y :: f (g a))
13:36:20 <hexagoxel> justaguest: does this make sense so far?
13:37:30 <justaguest> I almost get it. Not sure what the types for "(<*>) <$> (x :: f (g (a -> b)))" would look like
13:37:55 <justaguest> I know that (<$>) would apply the (<*>) to the g (a->b) part
13:38:03 <justaguest> inside the f
13:38:21 <hexagoxel> justaguest: good, that is exactly the right direction :)
13:38:41 <justaguest> is the recommendation to write everything step-by-step?
13:38:47 <justaguest> or is there some intuitive way to understand?
13:39:17 <hexagoxel> we already know that the left (<*>) uses the Applicative instance of `g`. But we have not looked at which Applicative is in use for the other <$> and <*>
13:41:23 <hexagoxel> but if we focus on the relevant information, what we have is (<*>) <$> (_ :: f ..) <*> (_ :: f ..)
13:41:58 <hexagoxel> so indeed, <$> and <*> lift into `f`.
13:43:17 <justaguest> ahh, I see the thought process. To understand, i'll have to spend 1-2 hours in front of some paper
13:43:28 <justaguest> thanks for the help, I have a good starting point now
13:44:07 <justaguest> and you too jle` for the liftA2 primer
13:44:30 <jle`> no problem :)
13:44:32 <hexagoxel> justaguest: the full type of the (<$>) is (g (a -> b) -> (g a -> g b)) -> f (g (a -> b)) -> f (g b)
13:44:45 <hexagoxel> i'll leave (<*>) as an exercise :)
13:44:52 <hexagoxel> (the second (<*>))
13:46:30 <justaguest> thanks hexagoxel!
13:46:32 <hexagoxel> justaguest: i think the important bit is realizing how the other Applicative instances get used when implementing the one for Compose. So there are three different (<*>) in that one line, for Compose f g, f, and g.
13:46:53 <justaguest> hopefully all this theory is useful in practice
13:47:10 <justaguest> ahh, I see
13:47:42 <hexagoxel> and yes, tracking things down involves playing human type inferencer :)
13:48:47 <jle`> justaguest: heh, at this point i don't even see this as theory anymore, because i use things like this every day in actual code
13:48:58 <jle`> lifting over multiple levels of abstraction is very common
13:49:08 <jle`> we don't do it in other languages because it's often very hard
13:49:16 <jle`> in haskell it's as easy as lifta1, a2, a3 :)
13:50:23 <jle`> a lot of this is actually what i've learned to see as the practical (not theory) side of haskell
13:50:47 <liste> ö
13:50:58 <liste> sorry
13:51:06 <justaguest> i'm assuming you use intuition, as opposed to the human type inferencing
13:51:38 <justaguest> going through the full procedure on a daily basis would be mindblowing
13:51:58 <jle`> justaguest: ah, i wa sreferring to things like using liftA2 (<*>)
13:52:06 <jle`> but honestly these days i let GHC do my type inference for me
13:52:09 <mjoldfield> I think you can educate your intuition by asking ghci to give you the type of things when you supply specific applicatives
13:52:13 <jle`> :t liftA2 _
13:52:14 <lambdabot> error:
13:52:14 <lambdabot>     • Found hole: _ :: a -> b -> c
13:52:14 <lambdabot>       Where: ‘a’ is a rigid type variable bound by
13:52:26 <jle`> :t liftA2 (_ `asTypeOf` (<*>))
13:52:27 <lambdabot> error:
13:52:27 <lambdabot>     • Found hole: _ :: f1 (a -> b) -> f1 a -> f1 b
13:52:27 <lambdabot>       Where: ‘a’ is a rigid type variable bound by
13:52:43 <jle`> ^ ghc will just tell you what types are where
13:52:58 <jle`> although to be fair it's good to be at least able to do some of the basic ones in your head
13:53:44 <jle`> for example, in the earlier case, you can put in a typed hole _ and ghc will tell you what type needs to go where
13:53:58 <jle`> you can even use _ in type signatures and annotations, and ghc will tell you what type goes there too
13:54:04 <hexagoxel> justaguest: sure, it is intuition, or just inference reduced to what is necessary to figure out which instances are used where. I certainly don't think of the full (<$>) type when i look at this, but I can see quickly that it involves the "f" instance.
13:54:11 <mjoldfield> e.g. > :t liftA2 (+) (Just 12)
13:54:22 <jle`> > [Just True, Nothing] :: [Maybe _]
13:54:24 <lambdabot>  error:
13:54:25 <lambdabot>      • Found type wildcard ‘_’ standing for ‘Bool’
13:54:25 <lambdabot>        To use the inferred type, enable PartialTypeSignatures
13:55:22 <hexagoxel> and that is both quick, with some training, and sufficient to understand things. plus what jle said about holes.
13:55:24 <jle`> and if you even just do Compose f <*> Compose x = _, ghc will tell you the types of f, and x
13:55:31 <jle`> so you know exactly what's going on
13:55:46 <jle`> @let data Comp f g a = Comp { runComp :: f (g a) }
13:55:47 <lambdabot>  Defined.
13:56:09 <jle`> @let instance (Applicative f, Applicative g) => Applicative (Comp f g) where Comp f <*> Comp x = _
13:56:10 <lambdabot>  .L.hs:163:10: error:
13:56:10 <lambdabot>      • Could not deduce (Functor (Comp f g))
13:56:10 <lambdabot>          arising from the superclasses of an instance declaration
13:56:24 <jle`> @let deriving instance (Functor f, Functor g) => Functor (Comp f g)
13:56:25 <lambdabot>  Defined.
13:56:26 <jle`> @let instance (Applicative f, Applicative g) => Applicative (Comp f g) where Comp f <*> Comp x = _
13:56:27 <lambdabot>  .L.hs:167:29: error:
13:56:28 <lambdabot>      • Found hole: _ :: Comp f g b
13:56:28 <lambdabot>        Where: ‘f’ is a rigid type variable bound by
13:56:44 <jle`> aw.  well normally it would tell you what the type of f and x are
13:57:03 <jle`> a lot of the "point" of haskell is letting the compiler do your work for you
13:58:37 <jle`> in the end it is neat that liftA2 can be taken to as many levels as you like
13:58:50 <mjoldfield> jle`: I think it's helpful to do some of the work yourself when you're learning though.
13:59:01 <mckeankylej> Is there a nix haskell packages for a complier with QuantifiedConstraints support?
13:59:13 <jle`> > (liftA2 . liftA2 . liftA2) (+) [Just (Left "hi"), Nothing, Just (Right 20)], [Nothing, Just (Right 3), Just (Right 2)]
13:59:15 <lambdabot>  <hint>:1:76: error: parse error on input ‘,’
13:59:18 <Solonarv> %% data Comp f g a = Comp { runComp :: f (g a) } deriving Functor; instance (Applicative f, Applicative g) => Applicative (Comp f g) where Comp f <*> Comp x = _
13:59:19 <yahb> Solonarv: http://qp.mniip.com/y/67
13:59:20 <mckeankylej> ghcHEAD seems to be 8.5
13:59:22 <jle`> > (liftA2 . liftA2 . liftA2) (+) [Just (Left "hi"), Nothing, Just (Right 20)] [Nothing, Just (Right 3), Just (Right 2)]
13:59:25 <lambdabot>  [Nothing,Just (Left "hi"),Just (Left "hi"),Nothing,Nothing,Nothing,Nothing,J...
13:59:30 <glittershark> noipmups: your question got glossed over it seems, but I do
13:59:31 <Solonarv> aw it didn't work
14:00:05 <jle`> > (liftA2 . liftA2 . liftA2) (+) [Just (Left "hi"), Nothing, Just (Right 20)] [Just (Left "bye"), Just (Right 2)]
14:00:07 <lambdabot>  [Just (Left "hi"),Just (Left "hi"),Nothing,Nothing,Just (Left "bye"),Just (R...
14:00:13 <jle`> ah so close
14:01:00 <jle`> mjoldfield: yeah, i agree
14:04:46 <noipmups> glittershark: Could you recommend me some easy tool/library or something like that?
14:13:31 <glittershark> noipmups: so basically Haskell only knows how to call C, so you have to make `extern "C"` bindings to whatever C++ you're calling
14:14:05 <glittershark> once you do that, https://wiki.haskell.org/Foreign_Function_Interface is a pretty good guide
14:14:30 <glittershark> and cabal recently added support for a `cxx-sources` section in the .cabal file so you don't even need to do anything separate in your build step
14:17:30 <Solonarv> you can also figure out what the mangled names from the C++ library are and import those directly
14:17:56 <glittershark> that can be pretty hairy, especially with templates
14:17:57 <noipmups> This looks promising, thank you.
14:17:59 <glittershark> but yes, that's totally doable
14:18:29 <glittershark> noipmups: np! feel free to mention me here if you run into problems
14:18:53 <glittershark> my journey calling into C++ was long and fraught with peril, I'd love to share some of that wisdom
14:23:41 <geekosaur> http://hackage.haskell.org/package/hoppy-generator
14:24:07 <glittershark> :0
14:24:15 <geekosaur> and there have been a few other attempts. C++ is hairy enough that it's not recommended
14:24:30 <geekosaur> and, uh, nonportable
14:24:35 <glittershark> oh lovely
14:25:47 <phadej> note that different C++ compilers mangle names differently
14:26:19 <Solonarv> writing a thin wrapper over the C++ library that exports sensible un-mangled names seems like a good idea to me
14:26:40 <phadej> https://en.wikipedia.org/wiki/Name_mangling#How_different_compilers_mangle_the_same_functions
14:27:37 <glittershark> `extern "C"` is by far the least-hacky way to do it
14:29:46 <Solonarv> at least modern gcc and clang seem to have the same, reasonable scheme
14:29:58 <Solonarv> but I want some of whatever MSVC smoked...
14:34:32 <dysfun> Solonarv: it's more like clang copied gcc
14:34:59 <Solonarv> nothing wrong with copying what's successful
14:36:06 <dysfun> that's not why they copied it, they copied it for interop purposes
14:36:20 <geekosaur> there's actually some attempt to keep non-Windows x86 and x86_64 ABIs on the same page.
14:36:29 <geekosaur> microsoft of course completely ignored that and does its own thing
14:36:31 <dysfun> but the reason it's different is historical, from a time when there was no need for them to be harmonised
14:37:41 <dysfun> and actually several MSVCisms have entered other compilers over the years, like #pragma once
14:38:37 <dysfun> gosh, i never expected knowing any of that to ever be useful
14:39:38 <Solonarv> seeing this, I'm not sure if I should be glad or not that we basically only have one haskell compiler
14:41:22 <dysfun> i don't worry about lack of other implementations, but then i've spent a lot of time writing languages with only one implementation and all the doom-mongering has never seemed to come to anythin
14:48:55 <mckeankylej> any time there is a type variable of kind constraint does Haskell constraint solving apply or is it only when the constraint is on the left hand side of a =>. I am wondering if a constraint on the right hand side of Data.Constraint.(:-) will solve.
14:49:23 <glguy> It's only on the left side of =>
14:49:26 <glittershark> mckeankylej: well `:-` is implemented with a `=>`
14:49:33 <glittershark> inside the GADT constructor
14:50:02 <glittershark> data Dict a where Dict :: a => Dict a
14:50:29 <glittershark> newtype a :- b = Sub (a => Dict b)
14:50:54 <glguy> That'll only matter when you try to use Sub to make a value of this type
14:51:09 <glittershark> ah, sure, it's at compile time
14:51:14 <glguy> but GHC won't try to "solve" the constraint just because you used c :- d as a type
14:53:52 <c_wraith> it couldn't even if it wanted to, as haskell is a non-total language.
14:54:19 <glittershark> well the constraint language tries to be total
14:54:38 <mckeankylej> glittershark: https://github.com/mckeankylej/kpf/blob/master/Hask/Functor/Polynomial.hs#L200
14:54:50 <mckeankylej> how does that line type check without constraint solving on the right hand side
14:55:01 <mckeankylej> like i really have no idea how that type checks its kinda insane
14:55:26 <glittershark> yeah when you construct a term of type `:-` constraint solving does kick in
14:55:32 <glittershark> because it's trying to construct the `Dict`
14:55:45 <mckeankylej> glittershark: but its calling out to another function
14:56:09 <mckeankylej> like how does it know youre constructing Dict ob is just some random function
14:56:28 <tcsiwula> compiler knows all
14:56:30 * hackage graph 0.0.0.0 - Class of graphs  http://hackage.haskell.org/package/graph-0.0.0.0 (MatthewFarkasDyck)
14:56:32 <c_wraith> glittershark, sure, but having an argument of type (:-) doesn't do anything until you pattern match on it, which is at runtime.
14:56:35 <glguy> It would know if the type of ob had constraints in it to solve
14:56:53 <glittershark> well ob :: _ :- _ I'm assuming
14:56:57 <glguy> If ob doesn't have constraints in its type, then no constraints are solved when you use ob
14:57:00 <mckeankylej> glittershark: also its not even obvious how that constraint is satisfied even under that assumption
14:57:18 <mreh> I'm getting some strange errors when cross compiling https://pastebin.com/raw/QHx76LV5
14:57:27 <glittershark> I agree that it is pretty wild that that typechecks
14:58:10 <mreh> saying "dependency doesn't exist", they're definitely there in my package database and in the libs folder
14:58:50 <c_wraith> mreh, I think the real problem is that there isn't a primitive package available to cross-compile with
14:59:13 <tcsiwula> i got weird error like that too on my mac
14:59:16 <c_wraith> mreh, and the rest is buggy error messages.
15:00:06 <tcsiwula> this is what fixed it: ```rm -rf .stack-work/```
15:01:17 <mreh> c_wraith, primitive seemed to cross compile okay previously, I can see that in my package-db
15:01:40 <c_wraith> mreh, does it have the same package id in the db?
15:02:02 <mreh> c_wraith, it does
15:02:29 <c_wraith> huh. OK, I was chasing a red herring. (fish are fast, and red ones are faster)
15:08:03 <mreh> oh, maybe the --package-db cabal flag doesn't work how I expect
15:16:02 <mreh> I thought --user was always the default with cabal-install
15:23:30 * hackage extensible-effects-concurrent 0.3.0.2 - Message passing concurrency as extensible-effect  http://hackage.haskell.org/package/extensible-effects-concurrent-0.3.0.2 (SvenHeyll)
15:30:50 <geekosaur> mreh, how --package-db works is complex and runs into backward compatibility issues with ghc (and possibly early versions of cabal-install)
15:31:21 <geekosaur> iirc there are at least some circumstances where using it will change what db --user considers to be the user db
15:31:54 <geekosaur> (I should say, changes what cabal and ghc consider to be)
15:32:37 <moony> Is System.Random not installed by default?
15:32:59 <mreh> moony, no, try the random package
15:35:46 <moony> mk
15:39:18 <mreh> hmm, stack has given me an unpossible list of deps
15:40:41 <napping> I guess you are using extra-deps?
15:42:13 <mreh> napping, I'm cross compiling, I don't know how to make stack work that way, so I'm sort of generating my cabal file from stack
15:42:45 <mreh> when I add a dep I have to delete the cabal file, ask stack for some deps then regenerate and hard code the deps in
15:43:06 <mreh> it's pretty tedious but seems to result in a working set of packages
15:44:33 <geekosaur> rube goldberg-skell
15:46:13 <sclv> stack sdist gen-bounds should give a cabal file?
15:47:08 <geekosaur> will that work without building it?
15:47:28 <geekosaur> (I suspect building non-cross is not intended, and maybe not possible)
15:49:26 <dataN> is there an advantage to using 'Reifies s a =>' instead of 'Given (s -> a)' ?
15:49:35 <mreh> sclv, geekosaur, stack build --dry-run won't build
15:49:41 <mreh> and generates a cabal file
15:49:48 --- mode: ChanServ set +o glguy
15:49:48 --- mode: glguy set -bbbb *!*@117.194.192.0/20 *!*@217.64.113.52 *!*@62.170.224.64 *!*@dsl-olubng12-54fa06-160.dhcp.inet.fi
15:49:48 --- mode: glguy set -o glguy
15:49:59 <geekosaur> right, I was asking oif trying to do it with sdist would force a build
15:50:23 <sclv> ah that’s wild
15:51:31 <dataN> the latter of which provides; 'give :: forall a r. a -> (Given (a -> s) => r) -> r' instead of 'reify :: forall a r. a -> (forall (s :: *). Reifies s a => Proxy s -> r) -> r'
17:51:48 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | cabal update stuck? http://mail.haskell.org/pipermail/haskell/2018-January/025325.html'
17:51:48 --- topic: set by geekosaur on [Thu May 17 06:28:54 2018]
17:52:07 <dmwit> No idea what you're on about. But I'm very sure this isn't the channel for it.
17:52:44 <jollygood2> dmwit, hypocrisy of using exclusive "he" in the negative context, but then whining when someone uses inclusive "he" in the positive context
17:53:21 <dmwit> Still no idea what you're on about. And now more sure than ever that this isn't the channel for it.
17:54:26 <jollygood2> dmwit I commented on the link posted in this channel, and I don't see any topical conversation I am interrupting
17:55:16 <jollygood2> this is what I am talking about, from the link above: "Note that I use "he" here in the general sense even though Help Vampires are almost exclusively male. It appears that male Help Vampire, drawn as it is to shiny technology, occupies an evolutionary niche that females of the species simply do not find desirable. "
17:55:27 <dmwit> Whatever link you're talking about, it wasn't posted to this channel in the last hour and a half.
17:55:49 <dmwit> And "there's no other on-topic discussion" does not imply "this discussion is on-topic".
17:56:06 <dmwit> And if you'd like further meta-discussion of what's on-topic here, you may continue that discussion with me in #haskell-ops. Not. Here.
17:56:39 <jollygood2> dmwit, oh! you're entirely right, that was conversation from ##programming . I  got disconnected and lost track of my channels
18:08:26 <tam1138> hi there.  whenever i run "cabal install <executable>", it goes through all the downloading and compiling, and then complains that it can't create a symlink because the file already exists.  except i never created it.  google hasn't been terribly enlightening here.  any ideas?
18:09:21 <dmwit> What's the exact error message? You can (should) use an online pastebin and post a link if it's longer than a line or two.
18:10:01 <tam1138> https://lpaste.net/2130879403217911808
18:10:32 <tam1138> i've gotten the same message for every executable i've installed with cabal
18:10:42 <dmwit> That's puzzling.
18:11:08 <tam1138> that's what i said!
18:13:06 <dmwit> Could you share your ~/.cabal/config?
18:13:28 <dmwit> From my read of the source there is an option in there for controlling where symlinks should be made, and if it is not set no symlinks are made.
18:13:54 <dmwit> So it seems you may have inadvertently set that flag to be ~/.cabal/bin, which... isn't okay, for the reason the error complains about.
18:14:02 <tam1138> interesting
18:14:06 <tam1138> i do not recall every changing that file
18:14:41 <tam1138> symlink-bindir is indeed set to ~/.cabal/bin
18:14:48 <tam1138> hmm
18:14:54 <dmwit> Maybe comment that out and try again?
18:15:26 <geekosaur> odd. I know the OS X Platform used to set that because of how it tries to integrate with Apple's preferred directory structure
18:16:38 <tam1138> yep, that fixed it
18:16:41 <tam1138> thanks!
18:17:48 <tam1138> i just deleted ~/.cabal/config and let cabal remake it.  the default setting for symlink-bindir is ~/.cabal/bin, which causes the breakage.
18:18:05 <dmwit> Whoops. That's probably worth a bug report.
18:18:09 <dmwit> What version of cabal?
18:18:37 <tam1138> cabal-install version 2.2.0.0, compiled using version 2.2.0.1 of the Cabal library
18:19:29 <dmwit> Yeah, I'd file a bug.
18:20:10 <dmwit> I can see why cabal developers might not notice that regression. Most of them already have a config file. =)
18:20:25 <tam1138> will do
18:20:28 <tam1138> thanks for your help
18:23:38 <tam1138> interestingly, the cabal-install documentation specifically mentions the default value of symlink-bindir being ~/.cabal/bin
18:24:13 * dmwit squints
18:24:38 <tam1138> https://github.com/haskell/cabal/tree/master/cabal-install
18:24:45 <tam1138> at the end of "quick start on unix systems"
18:25:04 <dmwit> Something weird has happened somewhere. Either the intended meaning of the field has been updated, but the behavior doesn't match the intention, or the intended behavior hasn't changed and somebody made a bad choice about changing a default.
18:25:08 <dmwit> Either way it's a bug.
18:25:22 <dmwit> The default configuration should not result in warnings.
18:26:14 <tam1138> it's actually failures.  if, eg, happy is a dependency, the installation won't proceed past it.
18:26:57 <tam1138> my compiler situation is a bit... odd.  i wonder whether that's an issue.
18:28:49 <dmwit> It shouldn't be, but say a bit about what you think makes it odd?
18:30:27 <tam1138> i'm running arch linux.  i installed enough official packages to let me compile ghc from scratch, which i packaged up.  i also built cabal-install and packaged THAT up.  then i removed all pre-existing haskell-related Arch packages and installed the two i just built.
18:30:43 <tam1138> then i ran "cabal install cabal" and then removed the cabal-install package i had previously
18:31:04 <tam1138> and here i am
18:31:11 <dmwit> None of that sounds problematic to me. cabal doesn't care about what your package manager thinks about the situation at all.
18:32:30 <tam1138> and presence of the cabal library installed as part of ghc isn't likely to present a problem?
18:32:51 <dmwit> If it were going to be a problem, it would have done so while building cabal-install.
18:33:18 <dmwit> Oh, sorry. I may have misunderstood what you meant, because I now see a second possible meaning.
18:33:38 <dmwit> But anyway the symptoms of either reading of that question wouldn't be this oddity about symlinks.
18:33:42 <geekosaur> the cabal library wouldn't care about this
18:34:03 <geekosaur> it manages ghc's package databse and knows very little about executables other than how to find them by $PATH search
18:35:04 <dmwit> (It does know a little bit about GHC-specific executables. But nothing that matters here. Basically just how to go from `ghc-X.Y` to `ghc-pkg-X.Y`.)
18:35:36 <tam1138> i think i follow
18:35:42 <tam1138> i will file a bug
18:35:45 <tam1138> thanks everybody
18:56:24 <butterthebuddha> Is there a better way to write "and (map pred xs)" to get short-circuiting?
18:56:33 <butterthebuddha> (or does it short-circuit by default?)
18:58:36 <geekosaur> if and gets a False it'll stop "turning the crank" on the map, if that's what you mean
18:59:05 <monochrom> It already short-circuits. but you can simplify it further to "all pred xs".
18:59:11 <jollygood2> > and [False, undefined]
18:59:13 <lambdabot>  False
18:59:37 <butterthebuddha> Awesome, this is because of laziness I presume?
18:59:38 <monochrom> > and (map id (False : undefined))
18:59:40 <lambdabot>  False
18:59:44 <monochrom> Yes.
18:59:46 <dramforever> :t all
18:59:47 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
18:59:56 <dramforever> butterthebuddha: If you want to use a pre-defined function
19:00:05 <dramforever> :t all even [4, 6, 3, undefined]
19:00:06 <lambdabot> Bool
19:00:13 <dramforever> > all even [4, 6, 3, undefined]
19:00:15 <lambdabot>  False
19:00:20 <jollygood2> hmm, is : undefined necessary vs [..undefined] to prove it shortcircuits?
19:00:37 <monochrom> WTH is [..undefined]?
19:00:43 <dramforever> It depends
19:00:50 <jollygood2> > and [False, undefined]  -- this
19:00:52 <lambdabot>  False
19:00:54 <dramforever> monochrom: that '..' is 'real' ellipsis
19:01:57 <monochrom> [False, undefined] is still an finite list.  False : undefined is you don't even know that it is a finite list.
19:02:08 <dramforever> So it really depends
19:02:19 <dramforever> because just saying 'because laziess' doesn't say too much
19:02:39 <dramforever> other than that 'it works in a handful of more cases than strict'
19:03:08 <dramforever> Using :print is also a good way of checking: https://pastebin.com/gLzS7gDu
19:03:11 <monochrom> False:undefined rules out more hypotheses than [False,undefined]
19:04:00 <monochrom> To make this more obvious: False:(undefined :: [Bool]) rules out more hypotheses than False:(undefined::Bool):[]
19:04:18 <dramforever> Yes you're right
19:04:26 <dramforever> :print is a bit more... direct
19:04:46 <monochrom> The scientific method teaches us to look for experiments that rule out more models.
19:06:33 <dramforever> Yes
19:06:34 <dramforever> You win
19:07:47 <monochrom> No.  I am still on the losing side.  Until one day all programmers practice the scientific method as a given so that I don't have to keep bringing it up, I am still losing, and all humanity is still losing too.
19:09:05 <XorSwap> computer *science*
19:09:16 <dramforever> It's also kind of sad that we have to practice the scientific method on *known* things
19:09:21 <dramforever> those essentially mathematics
19:09:44 <XorSwap> I usually picture the science part as being for things that are too big to prove
19:09:53 <XorSwap> like can you prove your os is uncrashable
19:10:38 <tam1138> http://ts.data61.csiro.au/publications/papers/Klein_EHACDEEKNSTW_09.pdf
19:10:41 <monochrom> Well, the scientific method is the fastest way to learn things. There are a lot of things known to other people but not yet known to you.  You can use the scientific method, or at least most of its ideas and recommendations, to learn those.  I am a successful example.
19:11:16 <dramforever> Not trying to argue with that
19:11:31 <dramforever> But then there's i++ + ++i and...
19:11:55 <tam1138> that's a result of underspecification in the language, though
19:12:07 <dramforever> It's actually well specified
19:12:11 <dramforever> 'Don't do that'
19:12:43 <XorSwap> "doctor, it hurts when I invoke undefined behaviour"
19:12:54 <dramforever> That would be great
19:12:58 <dramforever> but it doesn't
19:13:09 <dramforever> I mean, doesn't always
19:14:15 <dramforever> And :print is neat as well, at least for small objects
19:15:05 <dramforever> And this ghc-vis thing if I can get it to install: http://felsin9.de/nnis/ghc-vis/
19:34:17 <enterprisey> %pf \x y -> [x,y]
19:34:45 <enterprisey> @pl \x y -> [x,y]
19:34:46 <lambdabot> (. return) . (:)
19:50:11 <benzrf> yikes
20:02:21 <war> IRC SERVER ====> /server -m irc.heckmann.top
20:28:01 --- mode: ChanServ set +o glguy
20:28:01 --- mode: glguy set +q-b *!*@191.189.13.148 glguy!*@*
20:28:44 --- mode: glguy set -o glguy
20:34:00 * hackage tomland 0.3 - TOML parser  http://hackage.haskell.org/package/tomland-0.3 (shersh)
20:35:36 <dreamer_> heyo
20:35:47 * dmwit waves
20:39:33 <dreamer_> I have a problem
20:39:34 <dreamer_> https://lpaste.net/4376009222886785024
20:40:13 <glguy> That's right, you can't do that
20:40:14 <dmwit> Yes, lenses. Or don't try to take the field name as an argument.
20:40:41 <glguy> It would be more like: f rec change newval = change rec newval
20:40:48 <dmwit> People have experimented with a variety of other ways, but they are generally not as good for various reasons.
20:40:51 <glguy> Record field names aren't "first class"
20:41:35 <dreamer_> Okay; thanks !
20:45:41 <Solonarv> conceptually, lenses are almost exactly first-class field names that can also be composed
20:58:30 * hackage bench 1.0.10 - Command-line benchmark tool  http://hackage.haskell.org/package/bench-1.0.10 (GabrielGonzalez)
20:59:59 * hackage foldl 1.4.1 - Composable, streaming, and efficient left folds  http://hackage.haskell.org/package/foldl-1.4.1 (GabrielGonzalez)
21:30:23 <thelounge90> xzczxc
21:37:23 <ddellacosta> there's a way to see the instances generated in the loaded module in ghci, isn't there?
21:44:15 <cocreature> ddellacosta: :i TypeClass will show you all instances of TypeClass that are in scope
21:44:28 <cocreature> not sure if there is something that only shows you the instances of a specific module
21:44:32 <cocreature> maybe :browse works?
21:45:04 <ddellacosta> cocreature: doesn't seem to show me derived instances though, huh?
21:45:21 <ddellacosta> :browse also isn't giving it to me...although I could swear I have seen it before
21:45:50 <ddellacosta> I mean, I feel like I've done this before which is what's annoying me, but maybe I'm imagining that
21:46:21 <cocreature> :i should include derived instances
21:47:48 <geekosaur> there's no difference between manual and derived instances by that point
21:48:18 <geekosaur> the only "special" instances by then are Coercible, but that's because they don't actually exist; it's a typechecker hack that pretends to be instances
21:52:14 <ddellacosta> geekosaur: from what you're describing it sounds like I've got a misunderstanding of how this should work--so if I create a custom data type like `data FooTree a = Empty | Node a (FooTree a) (FooTree a)` and derive Functor, I won't see e.g. `instance Functor FooTree` when I use the `:browse` command, then?
21:52:30 <geekosaur> you should see it.
21:52:53 <ddellacosta> okay then I'm confused
21:52:58 <ddellacosta> er, more confused
21:53:05 <cocreature> I’m not sure about :browse but :i Functor should definitely show it
21:53:16 <geekosaur> I'm not sure :browse shows instances, because it shows symbols and an instance isn't a symbol
21:53:52 <geekosaur> (there's a hidden internal symbol representing the typeclass dictionary, but that's never visible at Haskell level without hacks like Ifcxt)
21:54:15 <ddellacosta> okay yeah I see it via `:i`
21:54:26 <ddellacosta> cocreature and geekosaur, thanks
22:07:04 <halogenandtoast> I'm trying to use postgresql-simple and I'm having a hard time understanding the FromField instance (ref: https://hackage.haskell.org/package/postgresql-simple-0.5.4.0/docs/Database-PostgreSQL-Simple-FromField.html#t:FromField)
22:07:27 <halogenandtoast> I'm trying to do: query_ conn "SELECT * FROM lists"
22:07:49 <halogenandtoast> And I have a List type, but I don't know how to define fromField for it
22:08:10 <halogenandtoast> I assumed fromField would affect a single column
22:09:32 <cocreature> it does affect a single column
22:10:26 <cocreature> if you want to parse a whole row you need to make an instance of FromRow
22:11:18 <halogenandtoast> Okay that aligns with my thought
22:11:28 <halogenandtoast> then it seems weird that it only complains about the FromField instance
22:11:34 <halogenandtoast> and once defined compiles
22:11:52 <cocreature> I think we are going to need more context to tell what’s going on there
22:12:07 <halogenandtoast> https://gist.github.com/halogenandtoast/4fefa2c61e03ab8e10aaa8717e6c505b
22:12:36 <halogenandtoast> editing to add full source in just a second
22:12:49 <cocreature> what’s the inferred return type of that statement?
22:12:56 <halogenandtoast> updated
22:13:06 <cocreature> it’s probably hitting one of the existing instances
22:13:19 <halogenandtoast> oh you know what
22:13:23 <halogenandtoast> it's probably the fromOnly
22:13:41 <cocreature> exactly
22:13:48 <halogenandtoast> womp womp
22:13:53 <halogenandtoast> thanks cocreature
22:13:58 <cocreature> FromField a => FromRow (Only a)
22:14:32 <halogenandtoast> No instance for (FromRow List) arising from a use of ‘query_’
22:14:34 <halogenandtoast> perfect ^^
22:19:23 <halogenandtoast> of course that instance is suprisingly easy to write
22:19:34 <halogenandtoast>   fromRow = List <$> field <*> field <*> field <*> pure []
22:19:57 <halogenandtoast> Oh haskell, sometimes you are uniquely beautiful
22:46:24 <newhoggy> Is there a way to write `demote :: (SuperUser m, Monad m) => m () -> m ()` such that the `m` in the return value has the SuperUser constraint, but the `m` in the argument doesn't?
22:53:22 <halogenandtoast> use a letter other than m?
22:53:42 <newhoggy> I want to keep all other constraints though.
22:54:08 <liste> newhoggy: "m" must be only one type, with one set of constraints
22:54:44 <liste> newhoggy: so having different constraints for the argument and return value makes no sense, because they are the same type
22:54:52 <halogenandtoast> demote :: (SuperUser n, Monad m) => m () -> n ()
22:55:19 <liste> newhoggy: did you mean "demote :: (Monad m, Monad n, SuperUser n) => m () -> n()" ?
22:55:37 <liste> I don't see how you can do anything with that though
22:55:53 <newhoggy> But what if n has other constraints that I don't know about, but I want m to also have them.  But I want m not specifically not have Superuser.
22:55:58 <liste> just Monad doesn't really provide much actual operation
22:56:16 <liste> newhoggy: there's no "not" constraints
22:56:27 <liste> the type system doesn't do negation
22:56:44 <newhoggy> That's a shame.  :D
22:57:08 <halogenandtoast> liste: to translate he wan't some type m to be converted to a type n that has all the same constraints but also is a SuperUser
22:57:12 <dminuoso> Anyone versed in SSH by any chance? Im trying to use libssh2 to interact with a network device, but to no avail. runShellCommands is not producing any visible output.
22:57:35 <liste> halogenandtoast: that just sounds weird to me :) but yeah I get that
22:58:03 <halogenandtoast> agreed
22:58:03 <newhoggy> I sometimes like to think of constraints as capabilities, but one way they are different from capabilities is that I can't take them away.
22:58:40 <liste> constraints are just implicit parameters
22:58:42 <halogenandtoast> newhoggy: basically a function doesn't know the "extra" constraints of m that aren't specified
22:58:57 <liste> that's why => looks like ->
22:59:15 <halogenandtoast> to be honest if you get back some value from demote that can't be used correctly you'll just get a compiler error
22:59:20 <halogenandtoast> so it's semi moot
22:59:51 <dminuoso> liste: Ive heard that edward thinks scalas implicits are vastly different though.
23:00:51 <liste> dminuoso: I think so too, I think they're kinda convoluted
23:03:31 <nshepperd> i think of constraints as facts
23:03:37 <nshepperd> Num Int is a fact.
23:03:50 <Maxdamantus> Int is a fact too.
23:04:20 <nshepperd> there's no type signature you can write that will make Num Int stop being true
23:04:46 <newhoggy> Depending on the language, I think with implicit parameters, it's possible to bring two of the same type into scope so that you can deny functions access to any of them because then it would be ambiguous?
23:05:12 <liste> newhoggy: that can happen with type class instances
23:05:21 <liste> with orphan instances*
23:05:59 <newhoggy> That's true, although it doesn't manifest as a type error.
23:06:00 <liste> nshepperd: but you can pass those facts as regular parameters too, right?
23:06:19 <Maxdamantus> You wouldn't pass the facts. You would pass the evidence of the facts.
23:06:41 <liste> yeah, that's an good point
23:06:52 <liste> constraint is the fact, instance is the evidence
23:07:22 <Maxdamantus> This just sounds like implicit arguments.
23:07:26 <nshepperd> instance dictionary is the evidence
23:08:03 <Maxdamantus> I imagine the main distinctions between classes and implicit parameters would be do with resolution.
23:08:57 <Maxdamantus> Haskell classes/instances involve constraints that are not clearly expressed through the syntax, but probably could be.
23:09:12 * Maxdamantus doesn't know how Scala works.
23:09:17 <liste> hmm, what if I used ?-variables instead of constraints
23:09:30 <liste> type class constraints*
23:09:49 <nshepperd> the main difference is instance coherence
23:10:19 <newhoggy> What if we mixed constraints with linear types so we get linear constraints, which would allow us to consume constraints :D
23:10:55 <nshepperd> 'Num Int' is more fact-like than other types in that it's true in exactly one way
23:11:03 <nshepperd> so it describes a relatively interesting fact
23:11:30 <Maxdamantus> Well, `Num Int` should probably be seen first as a proposition, not a fact.
23:12:17 <Maxdamantus> since the distinction between `Num Int` and `Num String` is that one is already proved by Prelude.
23:13:14 <Maxdamantus> or maybe s/String/Bool/ to avoid unnecessary alias issues.
23:18:19 <nshepperd> 'f :: Num a => _t' says "for your type a, prove to me that Num a, and I will bestow great treasure of type _t"
23:19:03 <nshepperd> 'f :: (?x :: a -> a -> a) => _t' says "for your type a, give me any old function of type a -> a -> a, and I will bestow great treasure of type _t"
23:25:27 <halogenandtoast> For servant, if I have a request 405ing is there a good way to see why?
23:25:50 <halogenandtoast> nvm I see it
23:27:31 <halogenandtoast> well now I get a 400 and don't know why :\
23:28:01 <halogenandtoast> looks like the error is in the body
23:32:43 <halogenandtoast> Is there a better (more safe and syntactically better) way of doing this: [Only lid] <- query conn "INSERT INTO lists (title, color) VALUES (?, ?) returning id" (createListTitle c, createListColor c)
23:33:19 <cocreature> halogenandtoast: pattern match and handle the case where the list is not a singleton list?
23:33:20 <halogenandtoast> suppose I could case match the return value, but I'm wondering if there is a more standard way of doing this
23:35:41 <halogenandtoast> for the record, I want to insert a row, and get back an object of the right type (List), here I'm getting back an id and using it to construct a new List
23:35:54 <dminuoso> halogenandtoast: You *are* already pattern matching the return value.
23:36:15 <halogenandtoast> dminuoso: sure, just partially
23:36:46 <cocreature> I’d say it depends on your application. in most cases there is probably not really a good way to handle errors here so you want to either crash or let the exception propagate to some exception handler that logs the exception thrown by that request
23:37:27 <halogenandtoast> my unknowns are, can I get this id or the row in a better manner, does servant have a preferred way to be crashed (the request not the app)
23:37:39 <halogenandtoast> and I guess it's not servant here, but wai
23:37:42 <dminuoso> halogenandtoast: If you get an errenous response (be it an error or exception) and you can _handle_ it, then catch it. Otherwise propagate.
23:38:21 <cocreature> iirc warp catches exceptions thrown by requests
23:38:23 <dminuoso> I think servant produces a 500 for uncaught exceptions?
23:38:32 <dminuoso> Or warp does yeah
23:39:59 <halogenandtoast> Okay that's nice of it
23:40:04 <halogenandtoast>               _ -> error "Could not insert list"
23:40:07 <halogenandtoast> ^^ it is then
23:40:24 <cocreature> hm maybe servant doesn’t handle this properly https://github.com/haskell-servant/servant/pull/954
23:40:29 <dminuoso> Mmm, is `error` ever a good choice?
23:40:42 <dminuoso> Wouldn't an explicit throwIO a better pick here?
23:41:12 <cocreature> yeah throwIO is usually preferable
23:41:15 <halogenandtoast> dminuoso: I'm not sure of the difference
23:41:20 <halogenandtoast> too green I guess
23:41:52 <dminuoso> halogenandtoast: The issue with `error` is that it fits into pure functions, making them hard to predict.
23:41:59 <dminuoso> :t throwIO
23:42:00 <lambdabot> Exception e => e -> IO a
23:42:27 <dminuoso> halogenandtoast: Also this produces a catcheable exception. With `error` you will have a hard time catching specific exceptions.
23:43:09 <cocreature> if you use "error", throwing the exception is tied to the point where evaluation happens. if you use throwIO, it is tied to execution
23:43:33 <halogenandtoast> Ah nice, that makes sense
23:45:26 <halogenandtoast> updated to:               _ -> throwIO CreateListException
23:47:00 <halogenandtoast> It still feels weird to have to pattern match an id for insert with [Only id]. For some reason I figured there would be a way to extract a single value
23:47:37 <halogenandtoast> Are there any good open source Servant examples?
23:55:55 <drets> How can I refactor this piece of beautiful code: https://lpaste.net/1075620610198994944 or it's already just perfect?
