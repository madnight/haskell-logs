00:00:42 <cocreature> are you sure that’s actually the same queue? the way you get the reference to it seems different in the two parts
00:01:34 <tabemann> okay, I'm stupid
00:01:54 <tabemann> I put a putStrLn before the readTQueue, and that message isn't appearing either
00:02:00 * hackage lines-of-action 0.0.1 - Lines of Action, 2-player strategy board game  http://hackage.haskell.org/package/lines-of-action-0.0.1 (jxv)
00:02:14 <tabemann> so it's not hanging inside readTQueue
00:02:55 <tabemann> something must be hanging inside my event-handling code
00:03:31 <tabemann> (and they say that things work the first time once you get them to compile in Haskell - hah!)
00:04:45 <tabemann> (this code of course is a big pile of concurrency code that essentially is as bad as much traditional concurrency code using locks even though it uses STM)
00:05:15 <cocreature> usually I find concurrency in Haskell to be significantly better than tradiotional concurrency code :)
00:06:04 <tabemann> yeah, but I'm using TMVars to coordinate error handling and shutting down of socket readers, writers, and listeners
00:07:25 <tabemann> there's probably a bug somewhere in the code handling those TMVars
00:08:24 <tabemann> even still, this project would have been much harder without STM
00:44:30 * hackage hadolint 1.7.3 - Dockerfile Linter JavaScript API  http://hackage.haskell.org/package/hadolint-1.7.3 (lorenzo)
02:04:41 <conn> jle` here ?
02:16:27 <conn> Tordek: fishythefish:
02:36:35 <conn> can anyone review my proof of cartesian product ?
02:39:03 <pavonia> Where is it?
02:39:27 <conn> pavonia: https://codeshare.io/50PoNe
02:43:48 <Tordek> that's a bit on the empty side, conn?
02:44:00 <Tordek> nm, render error
02:44:14 <conn> Tordek: ok
02:47:07 <Tordek> looks great now; I'd say the last chunk is unneeded since you're literally applying it backwards to show it works both ways, but that's implicit in the =
02:47:35 <Tordek> but being more explicit is never a bad thing
02:48:34 <conn> Tordek: thanks! also do i need to include the data type Pair which i defined in my haskell code ?
02:49:50 <Tordek> I don't know what you're being asked for exactly; if you're given the type and asked for the proof, you don't need to; if you're asked to define it, then yes
02:50:17 <Tordek> in any case, what I just said still applies: nothing bad in being more explicit, so leave it in
02:52:08 <conn> Tordek:  prove that the cartesian product of two monoids is a monoid, (was the task)
02:53:07 <Tordek> you could use (a,b) instead of Pair a b
02:54:08 <conn> Tordek: ok. and this is the code my proof is based on: https://codeshare.io/5QdXMx
02:54:42 <Tordek> but, yes, you need to show what the definition is for mempty/mappend for your datatype, otherwise your proof leaves a doubt as for where you're taking the definition from
02:55:23 <conn> Tordek: so i need to include this to my definition: data Pair a b = Pair a b deriving Show
02:55:51 <Tordek> yes
02:57:30 * hackage soundgen 0.1.1.0 - sound generator  http://hackage.haskell.org/package/soundgen-0.1.1.0 (CIX_68)
02:58:05 <conn> Tordek: see now https://codeshare.io/5w0W17
02:59:14 <Tordek> looks good
03:00:40 <conn> Tordek: thanks also how can it be that in my data type, the name of the type and name of the value are the same ?
03:01:57 <conn> Pair (name of data type constructor) a b = Pair (name of value constructor) a b. ? they can be the same ?
03:01:58 <Tordek> because one is the type and one is the value :P
03:02:32 <conn> Tordek: is it bad coding ? i dont need to change it ?
03:02:42 <Tordek> they're relevant in different contexts; no, it's perfectly fine
03:02:54 <conn> Tordek: ok ;)
03:06:14 <Tordek> conn: (), Id, [], and the whole family of cartesian products (,), (,,), (,,,) and so on have the same name for type and value
03:08:03 <conn> Tordek: ok
03:28:56 <haskell_noob2> I am looking into cloudhaskell and i need to interface with rdma verbs? Is cloudhaskell's cci implementation something that i can use? It seems to be current.
03:53:30 * hackage facts 0.0.1.0 - Refined types  http://hackage.haskell.org/package/facts-0.0.1.0 (mrkkrp)
04:18:38 <conn> can anyone help with print a binary tree as asciiart ?
04:22:27 <cocreature> conn: anything specific that you are having trouble with?
04:33:21 <truthadjustr> need help.. i cannot import Data.Vector when trying to compile https://github.com/OlivierNicole/haskell-chess.git
04:33:48 <truthadjustr> tried `cabal install -p --reinstall --force-reinstalls vector` but to no avail
04:34:10 <truthadjustr> i'm using the haskell Docker image
04:35:35 <zincy> What is the equivalent of assign when in the State Monad if you are not using the lens library? (.=)
04:36:19 <cocreature> zincy: modify + const
04:36:27 <cocreature> eh no "put"
04:36:29 <cocreature> :t put
04:36:30 <lambdabot> MonadState s m => s -> m ()
04:36:37 <cocreature> my brain is apparently broken today
04:37:42 <zincy> Thanks
04:37:53 <zincy> :t const
04:37:54 <lambdabot> a -> b -> a
04:38:01 <zincy> const 5
04:38:10 <zincy> (const 5) 2
04:38:35 <zincy> const 5 2
04:38:38 <cocreature> modify + const works, it’s just silly
04:38:53 <zincy> what is silly
04:38:58 <zincy> (.=) ?
04:39:07 <cocreature> using modify + const when there is put :)
04:39:53 <zincy> so put can only be called within the context of the state monad?
04:40:31 <cocreature> yes (the same restriction applies to (.=) as well)
04:40:40 <cocreature> not sure what "put" would even do outside of a state monad
04:42:20 <zincy> So the state monad is simply a function that returns a tuple of return and state
04:42:28 <zincy> wrapped in the type Constructor
04:44:36 <truthadjustr> need help to compile haskell-chess. The error I have is: https://asciinema.org/a/SsQZJ0RezkohGIcEBgfSHIB1b
04:45:18 <cocreature> truthadjustr: try "cabal install vector"
04:45:40 <zincy> if that fails I always stack clean --full
04:45:48 <zincy> just as a habit
04:46:03 <zincy> but that is more for linker errors
04:46:10 <cocreature> that’s not a stack project
04:46:22 <cocreature> it’s not even a cabal package, it builds using a makefile …
04:46:34 <zincy> doesnt everyone use stack :p
04:46:55 <zincy> how does that work
04:47:08 <zincy> i thought makefile was just for c
04:47:51 <truthadjustr> cocreature: thanks.. works now
04:48:54 <cocreature> makefiles don’t care about the language that you use them for
04:49:47 <zincy> what does make do? I get it is a build tool but thats it
04:50:41 <truthadjustr> zincy: make uses the files's timestamp to determine if needs to do something in its action section
04:51:07 <truthadjustr> zincy: the action section can be anything like 'wget' or curl.. etc..
04:51:34 <zincy> why would make need to know the time a file was created?
04:51:37 <zincy> Im confused
04:52:04 <truthadjustr> zincy: to determine if it has changed, so then it has to recompile or redo the build steps
04:52:37 <truthadjustr> this timestamp in the filesystem is heart of make
04:52:49 <zincy> So would that be for developing
04:52:54 <zincy> It would have a watch mode
04:53:30 <truthadjustr> i think, only timestamp is being compared.. mode is not
04:54:21 <truthadjustr> zincy: for example, it app.cpp timestamp is newer than app.exe, then make will redo the action to recompile app.cpp to produce app.exe
04:54:54 <zincy> ah ok
04:54:57 <zincy> thanks for the explanation
04:55:58 <zincy> What are type families?
04:57:39 <truthadjustr> by the way, i'm using the chess game example here to learn haskell
04:58:22 <truthadjustr> what is meant by 'lazy evaluation' ?
05:01:28 <zincy> lazy evaluation is when the evaluation of expressions are deferred till when they are needed
05:02:36 <zincy> https://hackhands.com/lazy-evaluation-works-haskell/
05:05:55 <halogenandtoast> I have a weird request because I seem to fall in this trap pretty frequently and I was wondering if someone could point me in the direction of how best to resolve this. I have a Yesod app using stack and I'd like to add esqueleto which should be fairly simple. I am using lts-11.13. So I go to package.yaml and add esqueleto to the end of my dependencies.
05:06:40 <halogenandtoast> I get "but the stack configuration has no specified version"
05:06:55 <halogenandtoast> so I assume I need to add this to my stack.yaml under extra-deps
05:07:48 <halogenandtoast> once I add that it complains about my version of persistent
05:08:24 <halogenandtoast> so I have to change that, and then conduit, and then resourceT, and then both conduit and resourceT are the wrong version.
05:08:44 <halogenandtoast> If I enable allow-newer: true, it soft of works, except the Conduit won't compile
05:09:51 <halogenandtoast> (recompiling to get the exact error)
05:10:18 <halogenandtoast> `Not in scope: type constructor or class ‘ConduitT’`
05:10:43 <zincy> Try a different LTS perhaps?
05:10:48 <zincy> I had that same issue
05:11:18 <zincy> In fact I had this exact same issue and gave up on trying to use esqueleto so would be keen to hear the solution
05:11:27 <halogenandtoast> lol :\
05:11:43 <zincy> Don't worry though I gave up easily
05:11:59 <halogenandtoast> I think the answer is that esqueleto just needs to have it's constraints loosened a bit
05:12:06 <halogenandtoast> maybe I'll just install it locally
05:12:30 <zincy> What is the exact error you get?
05:12:38 <zincy> post a snippet
05:13:28 <halogenandtoast> https://lpaste.net/7761722355956580352
05:14:04 <[exa]> that kindof looks like attoparsec gets a wrong version of Conduit
05:14:25 <[exa]> s/attoparsec/conduit-extra/
05:15:31 <[exa]> can you check whether the installed conduit is at least 1.3.0 ?
05:16:37 <halogenandtoast> It is not, it's 1.1.11
05:16:46 <halogenandtoast> because it forces me to use that version
05:17:08 <[exa]> you should be able to have both afaik
05:17:29 <[exa]> weird that conduit-extra 1.3.0 doesn't complain about conduit this old
05:17:55 <[exa]> what is the thing that pulls the older conduit?
05:19:01 <halogenandtoast> persistent-2.7.3.1:
05:19:12 <halogenandtoast> >=1.0 && <1.3
05:19:25 <[exa]> can you try with cabal new-build?
05:20:03 <halogenandtoast> Not familiar with it, I haven't touched cabal in quite some time
05:20:18 <halogenandtoast> Do you mean to make a new app or can I run that in my current project dir?
05:20:48 <halogenandtoast> okay figured that part out
05:21:07 <[exa]> well new-build should handle multiple package versions in one project so that could do
05:21:19 <[exa]> if you don't require stack for anything else than building, it could work for you
05:21:50 <[exa]> I guess this might also be relevant if you try to make it work with stack: https://docs.haskellstack.org/en/stable/architecture/#shadowing
05:23:16 <halogenandtoast> I'm not married to stack at the moment
05:23:31 <halogenandtoast> I'm happy with whatever works the easiest
05:24:21 <halogenandtoast> I suppose this is Cabal's chance to win me over again.
05:26:00 * hackage optparse-applicative-simple 1.0.3 - Simple command line interface arguments parser  http://hackage.haskell.org/package/optparse-applicative-simple-1.0.3 (NikitaVolkov)
05:27:51 <[exa]> stack might be an overkill in your case
05:28:55 <halogenandtoast> stack templates make setting up a yesod app quite easy (except that it has a bunch of extra crap I don't need)
05:29:19 <[exa]> I wish someone would cabalize the templates
05:29:35 <halogenandtoast> I haven't used Cabal in years now, back when I used to use it, you would have to reinstall everything if you renamed the directory your project was in.
05:29:46 <cocreature> you can totally use stack templates with cabal-install
05:29:58 <cocreature> just ignore or remove the stack.yaml file
05:30:11 <cocreature> and if you use one with hpack, run the "hpack" executable to generate the cabal file
05:30:11 <[exa]> oh that was fast
05:30:14 <[exa]> :D
05:31:37 <[exa]> halogenandtoast: nuking is still sometimes needed but it got much better (esp. the new-build just works^TM)
05:32:30 <conn> need help on show a binary tree
05:33:10 <cocreature> conn: my question from when you asked this an hour ago or so still hands: anything specific you are having trouble with?
05:33:43 <conn> cocreature thanks i was disconected. ill post a paste in a minute
05:33:49 <halogenandtoast> Yeah, well, I think esqueleto just doesn't work with the latest version of persistent and it's turtles all the way down.
05:37:46 <conn> cocreature: see here http://pasted.co/4f6ef814
05:39:36 <cocreature> conn: you probably want to write a separate function for this instead of trying to do it via Show
05:39:47 <[exa]> conn: Show instances shouldn't do eye candy
05:39:52 <cocreature> in particular, you want that function to take an Int argument that corresponds to the nesting level
05:42:04 <[exa]> not sure if nesting by Ints will work, he'll probably need more complicated prefixes (there can be any combination of | and spaces
05:43:30 * hackage nettle 0.2.1 - safe nettle binding  http://hackage.haskell.org/package/nettle-0.2.1 (stbuehler)
05:45:56 <conn> cocreatur: ok , i have the function printTree :: (Show a) => Tree a -> String and the instance:  instance Show a => Show (Tree a) where   show = printTree
05:46:15 <conn> how would i start the output with printTree ?
05:46:48 <cocreature> conn: as I said you probably want that function to take an Int argument that indicates the nesting level
05:46:48 <conn> concreature
05:47:10 <cocreature> also you keep screwing up my nick
05:47:57 <conn> cocreature: ok , the input should be like : tmy = Node 6 (Node 3 (leaf 2) (Node 4 (leaf 5) Empty )) (Node 7 Empty (Node 9 (leaf 8) Empty))
06:11:11 <madgen> Hello, so Haskell pleasantly surprised me by inferring `GArrayLike e -> Int` for `gLength` in this program https://gist.github.com/madgen/a402a2c0e86b0387c71d96f1098d4ec9
06:12:03 <madgen> I thought without explicit type signature, HM would have inferred `GArrayLike Word8 -> Int`, can smo explain to me how this happens?
06:18:42 <conn> whynew line with "\n" does not work for my function: printTree :: (Show a) => Tree a -> String printTree (Empty) = " " printTree (Node x Empty Empty) =  "\n |" ++ " \\-"++ show x ++ "" printTree (Node x l r) =  "\n|-"    ++ show x ++ "" ++ show r ++ show l
06:20:37 <conn> cocreature: here ?
06:22:55 <conn> nvm i fixed it with putStr instead print
06:26:10 <cocreature> conn: you’re printTree function still doesn’t take an Int argument to indicate the nesting level.
06:26:42 <cocreature> bbl
06:31:58 <conn> cocreature: why would i need that ? dont i need just the fix the output of the string ? see here: https://codeshare.io/2103En
06:32:35 <hexagoxel> there is no IORef-based non-blocking single-consumer channel datatype package out there, is there?
06:33:49 <hexagoxel> i want some non-blocking obtain-all-current-messages, which the non-STM Chan at least does not provide.
06:41:37 <hexagoxel> conc: if your function is supposed to print "|    \-8" in a single step, consider what information it needs for that.
06:42:47 <conc> hexagoxel : it needs a leaf 8 ?
06:43:46 <hexagoxel> conc: and what input would match the output "| \-8"?
06:44:29 <conc> same but i need to fix my output string ?
06:45:21 <hexagoxel> if the same output is supposed to produce two different results, you clearly have forgotten to pass some of the context information that makes the two invocations different.
06:45:30 <hexagoxel> *if the same input
06:46:01 <conc> the only output for now is the second one, the first one is not an output of my actual code
06:46:17 <hexagoxel> I know
06:47:06 <conc> also there should not be two results for one input, it has to be like the bottom output i posted
06:47:40 <hexagoxel> Also, it seems you can create trees that for example would include a line such as "  | | \-13".
06:48:59 <hexagoxel> conc: by input i meant what the function uses to determine one single line of the output
06:49:05 <conc> hexagoxel: how would i fix my code to produce: | |-9 |    \-8.  instead of : |-9   | \-8
06:50:00 <[exa]> conc: by a rewrite
06:50:06 <hexagoxel> ^
06:50:37 <conc> exa: any suggestions on this? https://codeshare.io/2103En
06:51:41 <[exa]> conc: maybe you might want to start the other way around. Printed tree is a list of lines. If you have a list of lines, you can easily merge them to a string (just join them by "\n"), and you can simply push them a bit right (by prefixing them by "| " or "  " or whatever else)
06:52:16 <[exa]> in that case, printing a tree consists of printing the root, then right subtree prefixed by "| ", and left subtree prefixed by "  "
06:52:37 <conc> exa: thats waht i tried, and it almost looks like what it should
06:52:43 <[exa]> plusminus some minor easily solved nuisances with the \ and -
06:53:13 <[exa]> codeshare's telling me it's over capacity :(
06:53:34 <[exa]> can you put it to lpaste?
06:55:01 * hexagoxel wonders what the supposed output for "Node 9 Empty (leaf 8)" would be..
06:55:21 <conc> [exa] : https://pastebin.com/y6eXcR3p
06:55:23 <[exa]> hexagoxel: I decoded that leaf x =probably= Node x Nil Nil
06:56:25 <[exa]> conc: ok where is the part that moves the lines to the right?
06:56:42 <[exa]> conc: (i.e. prefixes all lines by "  " or "| " or something else)
06:56:42 <hexagoxel> [exa]: yeah, i just mean that the "easily solved nuisances with the \ and -" aren't completely specified yet. \ vs |
06:56:50 <conc> [exa] how would i do that?
06:57:06 <[exa]> hexagoxel: \- looks like a left child, |- is right child
06:57:23 <[exa]> conc: good question! :D
06:57:28 <conc> - (minus) before number indicates a leaf
06:57:36 <hexagoxel> [exa]: no, \- looks like the last child, |- like a non-last child :p
06:57:48 <[exa]> conc: 9 in your example certainly isn't a leaf
06:58:00 <[exa]> hexagoxel: also look at 9 in the example
06:58:01 <conc> \-2
06:58:29 <conc> i mean leaf is like this:   \-2
06:58:42 <[exa]> ok what about \-3
06:58:42 <hexagoxel> [exa]: ah, good point. missed that.
06:59:31 <conc> exa not sure about \-3
06:59:37 <[exa]> not a leaf. :]
06:59:44 <[exa]> nevermind
07:00:45 <[exa]> conc: if you have a list of strings (e.g. list of lines of the tree), do you know how to prefix each line with some indentation, e.g. with "  " ?
07:01:07 <conc> exa: same output in list view with 3 beeing  empty : (6,(3,<2>,(4,<5>,ε)),(7,ε,(9,<8>,ε)))
07:01:31 <conc> < > indicates leaf
07:01:43 <conc> ( indicates new Node
07:01:52 <[exa]> yeah ofc
07:04:11 <[exa]> conc: anyway would this output match the expectations? https://lpaste.net/3749643110972391424
07:04:57 <conc> looks ok ?
07:05:50 <conc> now for start how would i fix my code that the root does not look like a leaf prefixed with -
07:05:59 <[exa]> I'll give you the tt function so you can generate trees to play with
07:06:00 * hackage hadolint 1.7.4 - Dockerfile Linter JavaScript API  http://hackage.haskell.org/package/hadolint-1.7.4 (lorenzo)
07:07:28 <[exa]> conc: https://lpaste.net/8966001722279329792
07:07:49 <[exa]> conc: you can continue by replacing the 'undefined's down below
07:08:51 <[exa]> conc: btw unlines is the function that takes a bunch of strings and joins them as lines, by "\n"
07:08:54 <iaowejf> Which of these two are correct according to haskell users? http://ix.io/1dyD I'm pondering whether pure functional languages need closures or simply just need lambdas (or have I misunderstood?)
07:09:33 <[exa]> conc: and the 'st' function should output lists of lines. First you can guess what the output of 'st Empty' will be
07:09:58 <conc> exa that looks quite diffent from my code, i think i just need to adjust the matching on my printTree a bit ?
07:11:15 <[exa]> your printTree won't work unless you either 1] have an extra argument for accumulating the indentation 2] use this approach with lists to be able to indent the trees after they are "printed" 3] do something really ugly that reminds str_replace on newlines in PHP
07:12:38 <[exa]> conc: you can easily see that the 'show' of the left/right child trees will never be able to output the correct indentation without knowing what the indentation should be
07:13:01 <conc> exa the list tree runction works just like this why would my ascii function need an extra argument ?
07:14:35 <[exa]> conc: the list tree function has the output as list that can be reindented, not mangled together in one string
07:17:35 <conc> exa ok then id try to add another argument ?
07:24:04 <maerwald> do we have a nice linter that doesn't propose changing semantics of your program?
07:28:39 <Athas> hlint is the best linter we have, I think.
07:28:43 <orion> maerwald: hlint
07:28:51 <maerwald> that proposes changing semantics
07:28:54 <maerwald> it's the worst imo
07:28:57 <orion> Example?
07:28:57 <Athas> Can't you just ask it to ignore the rules that change semantics?
07:29:05 <Athas> orion: some of the hints affect strictness.
07:29:09 <maerwald> yes
07:29:16 <orion> Athas: Example?
07:29:30 <maerwald> orion: https://github.com/quchen/articles/blob/master/fbut.md#f-x---is-not-f--x---
07:30:29 <Athas> maerwald: what is the program you are working on?
07:32:00 <maerwald> nothing specific right now
07:32:27 <maerwald> coding random crap
07:32:48 <orion> maerwald: Thank you.
07:33:20 <maerwald> orion: also note https://github.com/quchen/articles/issues/49
07:33:36 <maerwald> so... hlint might make your program crash ;)
07:34:51 <Athas> It's not a problem in practice.
07:36:18 <igqg> i'm learning about monad classes and trying to combine a MonadWriter and list, but i'm getting these compiler errors https://lpaste.net/1149179144983019520
07:36:54 <igqg> do i need to lift? if so, then how?
07:37:06 <maerwald> Athas: the eta reduce is already so annoying and most other suggestions I find useless as well
07:37:23 <Athas> maerwald: you can customise it to your own preferences.
07:37:33 <maerwald> that would mean just disabling it
07:37:41 <maerwald> I don't think it's possible to add new rules
07:37:46 <maerwald> it's not a generic linter
07:39:29 <Athas> maerwald: you can ignore specific rules.
07:39:44 <maerwald> that's not "customising" :>
07:39:49 <Athas> I use the following: hlint -i "Use import/export shortcut" -i "Use const"
07:40:13 <maerwald> we already have enough opinionated tools
07:40:13 <Athas> I don't remember why I found the 'Use const' rule bad, but the import/export shortcut interacts catastrophically with Haddock.
07:41:31 <maerwald> https://github.com/haskell/haskell-ide-engine/blob/master/docs/Tools.md#linters--refactoring
07:41:49 <maerwald> not much interesting there
07:47:52 <igqg> changing the type of foo to :: Int -> WriterT [Int] [] () works fine so i think lifting makes sense
07:49:05 <philippD> I'm trying to work through edward kmetts explanation of a free monad on stackoverflow https://stackoverflow.com/questions/13352205/what-are-free-monads/13352580#13352580 In there he says that you could define a List as `newtype List a = List (forall b. Monoid b => (a -> b) -> b)` But I don't quite get how you would represent list elements that way.
07:50:06 <barrucadu> You can add new rules to hilnt: https://github.com/ndmitchell/hlint#adding-hints
07:51:18 <philippD> Never mind, I got it :D
07:52:17 <maerwald> philippD: I don't know half of the words he uses.
07:53:28 <maerwald> barrucadu: cool
07:53:38 <philippD> maerwald: I try to work through it every few month to see if I have learned enough. Until now I only got to adjunctions
07:55:59 <maerwald> philippD: the accepted answer is pretty good
07:56:31 <philippD> maerwald: I know, but I also want to understand the category theoretic part
08:03:00 <conn> exa here ?
08:03:17 <conn> [exa]
08:08:06 <orion> maerwald: Do you have an example of hlint making an application crash?
08:08:14 <orion> Specifically because of inlining.
08:16:13 <darkJedi> hi! I was a code snippet of cons using lambda function.   cons = \x xs ->
08:16:29 <darkJedi> cons = \x xs -> \c -> c x xs
08:16:37 <darkJedi> What would be c over here ?
08:17:17 <darkJedi> Will it be a function which appends xs to x ?
08:17:46 <wz1000> darkJedi: you should read about https://en.wikipedia.org/wiki/Mogensen%E2%80%93Scott_encoding
08:18:21 <darkJedi> :wz1000 Thanks :)
08:19:06 <wz1000> also https://en.wikipedia.org/wiki/Church_encoding
08:22:06 <liste> darkJedi: it's a paremeter, it can be anything
08:22:18 <liste> @let cons = \x xs -> \c -> c x xs
08:22:20 <lambdabot>  Defined.
08:23:19 <liste> :t cons (:[]) (:)
08:23:20 <lambdabot> error:
08:23:20 <lambdabot>     Ambiguous occurrence ‘cons’
08:23:20 <lambdabot>     It could refer to either ‘Lens.cons’,
08:23:28 <liste> @let myCons = \x xs -> \c -> c x xs
08:23:29 <lambdabot>  Defined.
08:23:35 <liste> :t myCons (:[]) (:)
08:23:37 <lambdabot> ((a1 -> [a1]) -> (a2 -> [a2] -> [a2]) -> t3) -> t3
08:24:16 <liste> hmm, not quite :/
08:35:28 <philippD> > myCons 1 [2] (:)
08:35:30 <lambdabot>  [1,2]
08:35:30 <mreh> Is there an easy way to format Haskell datastructures for debugging? Show's output is pretty unreadable for nested datastructures, although I understand it's not really meant for that purpose.
08:36:14 <cocreature> mreh: there is the pretty-show package
08:36:25 <cocreature> mreh: or often I just paste it into a file and run hindent on it
08:37:01 <mreh> cocreature: that sounds like a quick and dirty solution
08:37:17 <cocreature> well you did say you want to use it for debugging, so quick & dirty seems fine for that :)
08:39:40 <mreh> cocreature: do you know if it does well with Data.Map ?
08:40:08 <cocreature> pretty-show?
08:40:13 <mreh> does it break apart the list in `fromList [...]`
08:40:16 <mreh> hindent
08:40:51 <cocreature> it will insert linebreaks if the list gets too long if that’s what you’re asking
09:07:00 * hackage flat 0.3.2 - Principled and efficient bit-oriented binary serialization.  http://hackage.haskell.org/package/flat-0.3.2 (PasqualinoAssini)
09:22:41 <conc> [exa]
10:10:27 <hololeap> i'm trying to use ghc-vis as a system-wide library, and i can't seem to get it to activate from ghci.
10:10:52 <hololeap> Prelude> :vis
10:10:52 <hololeap> unknown command ':vis'
10:12:28 <cocreature> hololeap: have you loaded the script? installing a library doesn’t magically give you new ghci commands
10:12:46 <hololeap> oh, i wasn't sure how that worked
10:13:04 <cocreature> https://github.com/def-/ghc-vis#installation take a look at the very bottom
10:13:50 <cocreature> I think you should also have seen the instructions when you installed the library
10:13:56 <cocreature> https://github.com/def-/ghc-vis/blob/master/Setup.hs#L19
10:15:32 <hololeap> I did it through the gentoo package manager so the output would be buried in a log file somewhere
10:20:09 <hololeap> cocreature: ok, i got it figured out. thanks for the hint :)
10:20:17 <cocreature> np
10:22:22 <hololeap> oh, i guess graphviz should be pulled in as a dependency...
10:36:25 <darkJedi> Hi! I have been trying out different ways of writing built-in functions. I tried cons. And I could not understand type signatures for cons.
10:36:30 * hackage cl3 1.0.0.1 - Clifford Algebra of three dimensional space.  http://hackage.haskell.org/package/cl3-1.0.0.1 (nwaivio)
10:36:45 <darkJedi> cons = \x xs -> \c -> c x xs
10:37:23 <darkJedi> I had defined it as consl in prelude. So on doing :t in ghci I got consl :: t2 -> t1 -> (t2 -> t1 -> t) -> t
10:37:40 <darkJedi> I could not understand where it was taking a function ?
10:37:57 <geekosaur> "c x xs" is application of function "c" to parameters "x" and "xs"
10:38:40 <geekosaur> this is a representation that uses functions to encode structure, instead of using structured data. I believe you were pointed at information about that (Scott and Church encodings) earlier?
10:38:50 <darkJedi> Yeah
10:38:56 <darkJedi> I looked them up as well.
10:39:41 <darkJedi> :geekosaur thanks :)
10:40:51 <darkJedi> But again I wasn't able to correlate them up. So I tried looking up the type signatures.
10:41:41 <philippD> @let myCons = \x xs -> \c -> c x xs
10:41:42 <lambdabot>  .L.hs:175:1: error:
10:41:42 <lambdabot>      Multiple declarations of ‘myCons’
10:41:42 <lambdabot>      Declared at: .L.hs:170:1
10:41:48 <philippD> :t myCons
10:41:49 <lambdabot> t1 -> t2 -> (t1 -> t2 -> t3) -> t3
10:42:39 <geekosaur> yes, but type sig won;t tell you anything here. you're modeling untyped lambda calculus, more or less
10:42:49 <darkJedi> So what I understood from Mogensen-Scott encoding was Lambda calculus allows data to be stored as parameters to a function that does not yet have all the parameters required for application.
10:43:24 <conc> how to convert a tree to a DataTree so i can use drawTree ?
10:44:43 <liste> conc: in what format is it now?
10:45:41 <conc> liste: data Tree a = Empty             | Node { label :: a, left,right :: Tree a }  leaf :: a -> Tree a leaf a = Node a Empty Empty      ,
10:46:00 <conc> liste: mytree = Node 1 (Node 2 (Node 3 (leaf 3) Empty) Empty) Empty
10:46:39 <johnw> darkJedi: maybe another way to say that would be: a term is equivalent to everything that may be done to that term
10:49:38 <cocreature> conc: there is not going to be a builtin way to do the conversion. you need to write a recursive function that does the conversion
10:49:42 <darkJedi> :johnw I could not understand what you meant ? Can you state an example as well.
10:50:14 <conc> cocreature: yes how would the function need to look like ?
10:50:51 <conc> cocreature: i found this example but it doesnt work for my tree : toDataTree (Leaf a) = Node a [] toDataTree (Branch b cs ds) = Node b [toDataTree cs, toDataTree ds]
10:51:02 <cocreature> conc: start by pattern matching on your input. then you have two cases. one the tree is Empty, so you need to think about how you can express that using Data.Tree. in the other case you have a Node so you need to think about how you translate that
10:51:20 <johnw> darkJedi: I'm not sure I can say it better, so ignore me until a later time
10:51:49 <darkJedi> :johnw Okay
10:52:18 <arfy> hey everyone. thought I'd come by and say hi, new to haskell but enjoying it so far. wanted something new to dabble with
10:52:46 <johnw> arfy: welcome
10:53:47 <mreh> channel has grown by about 1400 nicks since I started coming here
10:54:13 <arfy> wow. that's a lot of people!
10:54:29 <johnw> whoa, we're up to 1725, that's crazy
10:54:29 <mreh> well, that was 10 years ago
10:55:14 <Cale> I think it was closer to 25 when I joined :D
10:55:56 <conc> cocreature: liste: any hint ?  toDataTree (Node x Empty Empty) = Node x Empty Empty toDataTree (Node x y z) = Node x y z
10:56:48 <mreh> we better wear lambdas in public so we can start recognising each other
10:57:09 <cocreature> conc: the Tree type in containers doesn’t have a way of representing an empty tree. so you are either going to have to return a Maybe (Tree a) and store empty trees that way or a list of "Tree a", i.e., Forest a
10:57:30 * arfy is getting to grips with pure fp, but is relishing the challenge
10:57:49 <mreh> I need a replacement for the now defunct HGL
10:58:22 <mreh> https://hackage.haskell.org/package/HGL
10:58:41 <geekosaur> darkJedi, how familiar are you with the untyped lambda calculus?
10:59:04 <mreh> gloss any good?
11:00:08 <Tuplanolla> Gloss is good, but primarily pedagogical, mreh.
11:00:26 <mreh> Tuplanolla, no good for games then?
11:00:28 <geekosaur> darkJedi, the trick in that cons function is that c is not specified, so you are doing partial application where you know the data to be applied but not the function. the result is a function, which is the only way to represent structured data in untyped LC
11:00:35 <conc> cocreature: toDataTree (Node x Empty Empty) = maybe (Tree a) error: Not in scope: data constructor ‘Tree’
11:00:43 <geekosaur> which is why it's written as \c -> c x xs
11:01:35 <cocreature> gonz_: take a look at the docs, the constructor is called "Node" not "Tree" (you are going to have to do a qualified import to avoid the name collision with your own Node constructor)
11:01:41 <Tuplanolla> Depends on the game, mreh.
11:01:50 <cocreature> gonz_: also the constructors of Maybe are called Nothing and Just not "maybe"
11:02:10 <EvanR> :t maybe
11:02:11 <lambdabot> b -> (a -> b) -> Maybe a -> b
11:02:21 <EvanR> maybe is the destructor
11:02:36 <darkJedi> :geekosaur I just started a few hours back on reading on untyped lambda calculus. Though I will ask my mentor who had done haskell some years back to explain it in depth.
11:02:52 <geekosaur> ok, yes, you'll want to learn more.
11:03:10 <reactormonk> I've got overlapping instances, one for a and one for (Maybe a) - can I help the compiler a bit?
11:03:11 <geekosaur> you need to do tricky things with functions, like this, to represent things like lists
11:03:30 <geekosaur> reactormonk, no you can't. the one for a matches every type.
11:03:33 <conc> cocreature : import Data.Tree hiding (Tree, Node) ?
11:03:44 <geekosaur> you can tell the compiler to accept that and try anyway, but you get no promises
11:04:03 <geekosaur> conc, you probably need those imported qualified
11:04:26 <cocreature> conc: you need a qualified import. if you just hide the constructor you won’t be able to use it
11:04:30 <geekosaur> if you hide Data.Tree's constructors, you're going to have trouble creating a Data.Tree
11:04:32 <geekosaur> heh
11:05:00 <conc> cocreature: geekosaur: how to do a qualified import ?
11:05:26 <RobertL_> Hey everyone! Quick Haskell question :) I want to do something like this : translate = foldr (+x0, +y0) [] [(x,y):rest]
11:05:37 <philippD> conc: import qualified Module as Alias
11:05:39 <darkJedi> :geekosaur I thought parsing with Parsec was toughest in Week 4 Functional Programming in Haskell but by far defining functions using lambda functions was way more tougher to comprehend. But it's really fun learning more and more.
11:06:04 <c_wraith> RobertL_: well, that won't type-check. :)
11:06:08 <RobertL_> yeah
11:06:17 <c_wraith> RobertL_: your base case needs to have the right type
11:06:18 <RobertL_> but do you get the general idea of what i'm trying to do? O.o
11:06:35 <c_wraith> RobertL_: also, you need a real function as the first argument
11:06:39 <geekosaur> looks to me like you want to do two partial applications. that's not how you do it, and to be honest I wouldn;t bother with partial application
11:06:50 <geekosaur> it can usually be done but in cases liek that it gets ugly fast
11:07:17 <RobertL_> I know foldr works easily with a fucking like (+). But how can I get it to work with a tuple? :S
11:07:23 <conc> phillipD: import qualified Data.Tree (Tree) as XTree
11:07:39 <conc> philippD
11:07:40 <c_wraith> RobertL_: so, sort of like foldr (\(x0, y0) (x1, y1) -> (x0 + x1, y0 + y1)) (0, 0)
11:07:42 <geekosaur> o.O ok, that's a new failure mode for autoincorrect >.>
11:07:54 <RobertL_> i basically want to create a function that takes (x,y) and then a list of [(x1,y1)] and be able to do : (x+x1, y+y1)
11:08:06 <EvanR> define a haskell fucking
11:08:11 <philippD> conc: import Data.Tree as XTree ... XTree.Tree
11:08:15 <c_wraith> RobertL_: first off, that's using a lambda for the function.  It's not worth trying to make that function pointless
11:08:35 <c_wraith> RobertL_: second, your base case needs to be something of the right type.  Probably (0,0)
11:09:22 <reactormonk> Can I somehow get the intero error messages into a buffer somehow so I can copy/paste the required context out?
11:09:38 <c_wraith> RobertL_: though, that's a better use case for foldl' than foldr
11:10:06 <RobertL_> I'm doing a mock exam (my finals are Friday). The question is asking us to use foldr :)
11:10:34 <c_wraith> > foldl' (\(x0, y0) (x1, y1) -> (x0 + x1, y0 + y1)) (0, 0) (zip [1..10] [11..20])
11:10:36 <lambdabot>  (55,155)
11:10:43 <conc> philippD: be precise what is ... XTree.Tree ? : import qualified Data.Tree as XTree
11:10:44 <c_wraith> RobertL_: well, the question is wrong. :)
11:11:13 <c_wraith> RobertL_: the function is associative and commutative, so you get the same result either way.
11:11:18 <RobertL_> Hmm. We have a function defined as :
11:11:20 <c_wraith> RobertL_: err, the lambda is
11:11:24 <RobertL_> translate + [] = []
11:11:41 <philippD> conc: The import line should read "import qualified Data.Tree as XTree" then when you want to use something from Data.Tree you have to preface it with "XTree."
11:11:45 <geekosaur> conc, that import declaration tells Haskell to import all the names with prefix "XTree." instead of with no prefix.
11:11:49 <c_wraith> RobertL_: that is a definition of the plus operator
11:11:49 <RobertL_> translate(x0,y0)((x,y):vs) = (x+x0,y+x0):translate(x0,y0) vs
11:11:56 <RobertL_> and i have to convert it to a foldr function
11:12:00 * hackage stack-prism 0.1.7 - Stack prisms  http://hackage.haskell.org/package/stack-prism-0.1.7 (MartijnVanSteenbergen)
11:12:09 <RobertL_> translate _ [] my bad
11:12:14 <EvanR> so its really a map, not a fold
11:12:16 <conc> philippD: ok
11:12:16 <c_wraith> RobertL_: oh, right.  oops.
11:12:19 <EvanR> though you can use a fold to define it
11:12:22 <RobertL_> translate _ []
11:12:25 <RobertL_> translate(x0,y0)((x,y):vs) = (x+x0,y+x0):translate(x0,y0) vs
11:12:32 <c_wraith> EvanR: it's a scanl, actually
11:12:44 <c_wraith> > scanl (\(x0, y0) (x1, y1) -> (x0 + x1, y0 + y1)) (0, 0) (zip [1..10] [11..20])
11:12:46 <lambdabot>  [(0,0),(1,11),(3,23),(6,36),(10,50),(15,65),(21,81),(28,98),(36,116),(45,135...
11:13:05 <RobertL_> The question says foldr though :S (We haven't learned scanl in class!)
11:13:11 <c_wraith> foldr is more general
11:13:16 <conc> philippD: now my convert function: toDataTree (Node x Empty Empty) = maybe (XTree.Tree a) toDataTree (Node x y z) = Node x y z ?
11:13:32 <c_wraith> RobertL_: You can write it that way.  But it will be a bit more complex.  On the plus side, it means your base case of [] was correct! :)
11:13:33 <EvanR> why is it scanl, its adding constants x0 and y0 to all elements
11:13:46 <c_wraith> Oh, right.  that is a map.
11:13:59 <geekosaur> conc, you need to qualify the last Node too, otherwise it uses yours instead of Data.Tree's
11:13:59 <c_wraith> I misread it was passing different arguments to the recursive call
11:14:32 <RobertL_> Yeah, its basically a question that ask us to get rid of recursion, and use a foldr to fix the functions
11:14:36 <philippD> conc: try it ;)
11:14:42 <c_wraith> RobertL_: ok, your initial code was really close.  Just try using a named helper function as the first argument to the foldr, and pay close attention to types
11:14:56 <philippD> @let translate'
11:14:56 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
11:15:06 <philippD> @let translate'' = (getSum *** getSum) . fold . fmap (Sum *** Sum)
11:15:08 <lambdabot>  Defined.
11:15:15 <hololeap> i remember hearing about ghc-vis first on this channel, but something as simple as `let a = 1; :view a` in GHCi is giving me errors like "ghc: Unknown opcode 66". if you have ghc-vis working, what version of GHC, ghc-vis, and ghc-heap-view are you using?
11:15:31 <reactormonk> Is there a way to trace typeclass resolution? Aka why it needs a specific constraint.
11:15:38 <c_wraith> hololeap: yeah, that library is *very* tied to internal ghc details
11:15:50 <philippD> > translate'' [(0,0),(1,11),(3,23),(6,36),(10,50)]
11:15:52 <lambdabot>  (20,120)
11:16:08 <c_wraith> philippD: but it turns out the original was a map, not a fold
11:16:23 <conc> philippD: geekosaur: toDataTree (Node x Empty Empty) = maybe (XTree.Tree x) toDataTree (Node x y z) = XTree.Node x y z      doesnt work error: Not in scope: data constructor ‘XTree.Tree’
11:16:51 <geekosaur> please show your full code. to a pastebin, not directly into the channel
11:16:52 <geekosaur> @paste
11:16:53 <lambdabot> Haskell pastebin: http://lpaste.net/
11:17:42 <nitrix> reactormonk: What do you mean by trace? The author of the typeclass chose the constraints and the laws that are associated with the class.
11:19:04 <geekosaur> reactormonk, you can trace the typechecker but not at the level of a single typeclass.
11:19:12 <RobertL_> translate = foldr f [] [(x,y):vs] and then I define f?
11:19:19 <c_wraith> RobertL_: If you use the most general type for translate, there are very few implementations that type-check and are wrong.  (there are some, but testing will reveal they're wrong quickly.)  The most general type is (Num a, Num b) => (a, b) -> [(a, b)] -> [(a, b)]
11:19:21 <geekosaur> also if you are trying to use constraints to limit type class resolution, that will not work
11:19:45 <c_wraith> RobertL_: types are really important in Haskell.  They remove so much guessing.  Use them.  Trust them.  :)
11:19:52 <conc> geekosaur: philippD: code here https://pastebin.com/czYWHPps
11:21:14 <philippD> conc: line 24: XTree.Node instead of XTree.Tree
11:21:15 <geekosaur> Data.Tree is not the same kind of tree, it doesn;t have Node.
11:22:17 <hololeap> can someone give me a brief explanation of what this thing could mean? newtype DiaProd p = DiaProd (forall a. p a a)
11:22:24 <conc> philippD: ok it compiles
11:22:42 <reactormonk> tried stack build --ghc-options -ddump-tc-trace # no output :-(
11:23:04 <conc> philippD: but the second line still doesnt work ? toDataTree (Node x y z) = XTree.Node x y z
11:23:09 <geekosaur> reactormonk, stack redirects all dump output to files
11:23:21 <cocreature> conc: take a look at the arguments the Node constructor takes
11:23:23 <philippD> conc: you also have to map the subtrees ;)
11:23:24 <geekosaur> somewhere under ~/.stack-work will be a file whose extension is .tc-trace
11:23:41 <cocreature> also "maybe (XTree.Node x)" is almost certainly not going to do what you want
11:23:41 <hololeap> it's from the ends/coends chapter of milewski's CTFP, but it seems so abstract i'm a little baffled as to what it would mean in the context of haskell
11:25:32 <conc> philippD: how to map the subtrees ?
11:26:30 <nitrix> reactormonk: Possibly your question was more about type inference (or the type checking), to know why a specific expression ends up having the type that it has... which is different than asking why any given typeclass has such or such constraint, because that's up to the author.
11:26:37 <philippD> @let newtype DiaProd p = DiaProd (forall a. p a a)
11:26:39 <lambdabot>  .L.hs:179:1: error:
11:26:39 <lambdabot>      Multiple declarations of ‘DiaProd’
11:26:39 <lambdabot>      Declared at: .L.hs:177:1
11:26:51 <philippD> :t DiaProd id
11:26:52 <lambdabot> DiaProd (->)
11:28:14 <reactormonk> nitrix, I'm writing the typeclasses, so yeah :-)
11:28:22 <conc> cocreature: what do i need to change i. maybe (XTree.Node x) to make it convert my Tree to DataTree ?
11:28:35 <c_wraith> :t DiaProd (Kleisli return)
11:28:36 <lambdabot> Monad m => DiaProd (Kleisli m)
11:29:11 <nitrix> reactormonk: Oh. If you're re-writing existing typeclasses, you'll probably make discoveries of why those constraints were chosen along the way, yeah :)
11:29:27 <reactormonk> nitrix, nah, doing some typelevel programming
11:29:34 <hololeap> philippD, c_wraith: thanks for the examples. that's helping solidify it in my mind
11:30:12 <maerwald> what is typelevel programming?
11:30:18 <c_wraith> hololeap: it's hard finding defined examples in Haskell.  I keep wanting to do dumb things like DiaProd (undefined, undefined)  :)
11:30:46 <hololeap> it seems like for a given profunctor, there could only be one instance of DiaProd, due to parametric polymorphism (educated guess)...
11:30:54 <philippD> :t DiaProd (,)
11:30:55 <lambdabot> error:
11:30:55 <lambdabot>     • Couldn't match type ‘a’ with ‘b0 -> (a, b0)’
11:30:55 <lambdabot>       ‘a’ is a rigid type variable bound by
11:30:56 <c_wraith> hololeap: I believe so
11:30:57 <maerwald> that's the only "typelevel programming" I can think of: https://github.com/seliopou/typo
11:31:14 <cocreature> conc: I would recommend that you take a step back and first try how your representation of a tree differs from the one in Data.Tree and then think about how you want to handle the differences. currently you seem to be randomly trying things out in the hopes that you’ll arrive at a working solution and ime that’s not a very good way to tackle things
11:31:31 <cocreature> *try to understand
11:32:18 <conc> cocreature: i have this example : toDataTree (Leaf a) = Node a [] toDataTree (Branch b cs ds) = Node b [toDataTree cs, toDataTree ds]  d = Branch "1" (Branch "11" (Leaf "111") (Leaf "112"))                 (Branch "12" (Leaf "121") (Leaf "122"))
11:33:11 <c_wraith> hololeap: I believe the "Diagonal" in the name refers to the idea of making a matrix of types.  The only places that value is defined is when the two indices are the same.
11:33:19 <conc> should be possible to transfer to my tree ?
11:34:30 <c_wraith> hololeap: and it's a product (at the type level) because the type constructor takes two arguments.
11:34:33 <geekosaur> conc, uit's possible, yes. it's not going to be automatic, and you have to understand the kind of tree you are trying to generate, not assume it works just like yours
11:35:32 <RobertL_> damn, i thought I had it :( ::::: translate(x0,y0)((x,y):vs) = foldr (x+x0,y+y0) [] ((x,y):vs)
11:36:07 <geekosaur> you're still giving it the wrong start value
11:36:20 <geekosaur> you have a list of tiuples. [] is not the right start value
11:36:30 <c_wraith> geekosaur: no, [] is correct.  it's a map
11:36:32 <conc> geekosaur: cocreature: where can i read how a Tree in  Data.Tree looks like ?
11:36:48 <cocreature> conc: take a look at the documentation https://hackage.haskell.org/package/containers-0.5.11.0/docs/Data-Tree.html
11:36:50 <c_wraith> RobertL_: the problem is that the first argument needs to be a *function*
11:37:46 <EvanR> maerwald: what is programming
11:38:43 <conc> cocreature: ok and which tooic on this site? cant figure out whats relevant for my toDataTree runction
11:38:43 <arfy> can someone point me in the right direction for this? is there a way to either do a glob-style match on a directory and get a list of matching filenames, or a way to filter a list from System.Directory.listDirectory and get a similar result?
11:38:46 <philippD> maerwald: As far as I understand it it's computing stuff with types. The stuff you can do with DataKinds and TypeFamilies
11:38:49 <RobertL_> but isn't (x+x0...) a function?
11:38:54 <conc> cocreature: which topic
11:39:04 <c_wraith> RobertL_: no.  it's a pair
11:39:10 <nitrix> How do you invoke the bot that has TypeApplication?
11:39:15 <cocreature> conc: huh? I linked you to the docs that contain the definition of the Tree type. just look at that
11:39:23 <c_wraith> :t (1 + 2, 3 + 4) -- RobertL_
11:39:24 <lambdabot> (Num b, Num a) => (a, b)
11:39:26 <geekosaur> nitrix: "% " prefix
11:39:35 <nitrix> % :t foldr @[] @(Int, Int) @(Int, Int)
11:39:35 <yahb> nitrix: ((Int, Int) -> (Int, Int) -> (Int, Int)) -> (Int, Int) -> [(Int, Int)] -> (Int, Int)
11:39:53 <c_wraith> :t \(x, y) -> (x + 1, y + 2) -- RobertL_
11:39:54 <lambdabot> (Num b, Num a) => (a, b) -> (a, b)
11:40:40 <c_wraith> RobertL_: -> is the type of functions.  If the type isn't -> it's not a function
11:41:53 <maerwald> EvanR: programming is where your artistic motivation and your scientific knowledge meet
11:41:58 <RobertL_> ok i see :t (1 + 2, 3 + 4) like you said is a tuple
11:42:05 <philippD> @let iCantBelieveItsNotTranslate (x,y) = fmap ((+x) *** (+y))
11:42:06 <lambdabot>  Defined.
11:42:10 <RobertL_> :t \(x, y) -> (x + 1, y + 2)
11:42:11 <lambdabot> (Num b, Num a) => (a, b) -> (a, b)
11:42:30 <philippD> > iCantBelieveItsNotTranslate (5,5) [(1,2),(3,4)]
11:42:32 <lambdabot>  [(6,7),(8,9)]
11:42:59 <conc> cocreature: yes but there like 20 topics to read, where can i see how i could transform my tree into this ?
11:44:01 <nitrix> RobertL_: foldr funcThatTakesTwoTuplesAndYieldsOneTuple startingTuple listOfTuplesToProcess
11:44:09 <cocreature> sry, I’m not interested in spoon-feeding you the solution
11:46:32 <conc> cocreature: dont need to give a solution but a hint would be helpful
11:47:10 <RobertL_> translate .... : foldr (\(x, y) (x0,y0) -> (x + x0, y + y0)) [] ((x,y):vs) :::::::: is the right side better?
11:47:23 <cocreature> I gave you a lot of hints but you either seem to ignore them or not willing to put in the work to understand them
11:47:27 <conc> cocreature: Building trees unfoldTree :: (b -> (a, [b])) -> b -> Tree a Source#  Build a tree from a seed value ?
11:47:57 <nitrix> RobertL_: Almost. foldr <transformation> <initial accumulator> <things to process (to fold)>
11:48:38 <gonz_> cocreature:  Do you use dvorak? You highlighted me instead of conc  and the only way that makes sense is with a dvorak layout.
11:49:30 <johnw> in the Haskell world I've met far more dvorak typist than in other communities; how strange
11:49:39 <nitrix> RobertL_: foldr will fold a Foldable data structure into a single value, but you need to provide an initial value as well as how you're going to merge the values during the folding. Of course, the type of those values must be consistent throughout.
11:49:48 <cocreature> gonz_: oh sry, no I don’t use dvorak (although I use some other weird keyboard layout). I just mixed up your nix since they both have "on" in the middle so I looked at the wrong one
11:49:50 <philippD> Is there a type that treats the first half of a Bifunctor as a Functor?
11:49:52 <nitrix> > foldr (\(x1, y1) (x2, y2) -> (x1+x2, y1+y2)) (0, 0) [(1, 1)...]
11:49:54 <lambdabot>  error:
11:49:54 <lambdabot>      A section must be enclosed in parentheses thus: ((1, 1) ...)
11:50:09 <nitrix> > foldr (\(x1, y1) (x2, y2) -> (x1+x2, y1+y2)) (0, 0) [(1, 10), (2, 20), (3, 30)]
11:50:11 <lambdabot>  (6,60)
11:50:12 <cocreature> philippD: https://hackage.haskell.org/package/bifunctors-5.5.2/docs/Data-Bifunctor-Flip.html#t:Flip
11:50:29 <nitrix> RobertL_: See this example if it helps. You're pretty close already ^
11:51:17 <philippD> cocreature: but Flip doesn't implement Functor
11:51:29 <cocreature> philippD: huh, it does?
11:51:35 <cocreature> Bifunctor p => Functor (Flip p a)
11:51:45 <philippD> cocreature: it does
11:51:53 <philippD> cocreature: I just can't read
11:52:07 <cocreature> :)
11:52:41 <nitrix> There aren't many types that don't implement Functor :P
11:54:05 <cocreature> nitrix: all the ones that don’t have type parameters! :)
11:54:15 <maerwald> johnw: more americans maybe
11:54:19 <conc> anyone can help convert my tree to Data.Tree type which i can use drawTree on, in here ? https://pastebin.com/wRYyjYYs
11:55:06 <johnw> maerwald: hmm
11:58:52 <[exa]> conc: judging from the code I highly suggest you go through some haskell tutorial before attempting that, for example LYAH here http://learnyouahaskell.com/chapters
11:59:32 <[exa]> conc: anyway converting is super-easy, you just need to answer "what does Empty look like in Data.Tree format" and "What does (Node a l r) look like"
11:59:58 <conc> [exa] thats where im stuck atm ;)
12:00:23 <[exa]> you can probably look it up in docs here https://hackage.haskell.org/package/containers-0.5.11.0/docs/Data-Tree.html
12:00:53 <RobertL_> @nitrix yeah it helps. I need to find a way to make it that the result go into a list (list of tuple)
12:00:53 <lambdabot> Unknown command, try @list
12:01:19 <conc> [exa] empty is like this: Node a [] ?
12:01:56 <[exa]> conc: where would you get the 'a' ?
12:02:58 <conc> [exa] like this: toDataTree (Node x Empty Empty) = maybe (XTree.Node x [])
12:03:17 <[exa]> why maybe? (are you not sure?)
12:03:36 <conc> [exa]it compiles but its correct ? no idea maybe was suggested by someone before
12:03:37 <hololeap> @paste
12:03:37 <lambdabot> Haskell pastebin: http://lpaste.net/
12:03:58 <hololeap> conc: https://lpaste.net/8920536572873408512
12:04:06 <[exa]> conc: you can try to load it in ghci and see if the type matches your expectations
12:04:47 <[exa]> hololeap: oh noes! the nullables look like Java
12:05:04 <cocreature> take care, the floor is java!
12:05:48 <[exa]> conc: hint: it will not match your expectation :]
12:05:58 <[exa]> conc: anyway, why are you converting that to Data.Tree?
12:07:22 <rotaerk> f x y = let gxy = g x y in \z -> h z gxy   vs.  f x y z = h z (g x y)
12:07:28 <conc> hololeap: thanks the toDataTree works, but drawTree will not draw it ? see https://pastebin.com/3S3FQ1q7
12:07:49 <RobertL_> translate (x1,y1) ((x,y):vs) = foldr (\(x1, y1) [(x, y)] -> [(x1+x, y1+y)]) [] ((x,y):vs). It compiles without error, but when i try to replace the variables, i get non-exhaustive error :(
12:07:52 <rotaerk> if I'm generally going to use f by partially applying to x and y, and then reapplying it to many z, does the former implementation offer an advantage over the latter?
12:07:58 <rotaerk> or is the difference generally optimized away
12:08:12 <cocreature> rotaerk: replace how?
12:08:25 <rotaerk> you mean RobertL_
12:08:32 <cocreature> ahrg yeah
12:08:42 <cocreature> I’m really too stupid for autocomplete this evening
12:09:03 <conc> [exa] i need to convert it so i can use drawTree function
12:09:14 <maerwald> cocreature: I would blame people choosing similar nicks :P
12:09:17 <nitrix> RobertL_: Can you rename some of those variables? Your lambda and your function body have the same x1, y1... it makes it harder to reason about and explain.
12:09:19 <philippD> RobertL_ the warning says exactly what case is missed: [] if you call `translate (1,2) []` it explodes
12:10:04 <[exa]> conc: btw if the purpose of the exercise is just to write a tree drawing function, you can easily reap it from the official drawTree implementation here https://hackage.haskell.org/package/containers-0.5.11.0/docs/src/Data.Tree.html#drawTree
12:10:05 <philippD> RobertL_ the same goes for your lambda
12:10:21 <[exa]> conc: (notice the similarity with the separate-lines approach I was telling you about)
12:10:31 <RobertL_> translate (tX,tY) ((x,y):vs) = foldr ((tX, tY) \[(x, y)] -> [(tX+x, tY+y)]) [] ((x,y):vs) ::::::::::::::; I renamed the variables
12:10:41 <conc> [exa] i tried already writing my own draw runction and it works, but drawTree looks better
12:11:04 <philippD> @let robertsTranslate (tX,tY) ((x,y):vs) = foldr ((tX, tY) \[(x, y)] -> [(tX+x, tY+y)]) [] ((x,y):vs)
12:11:04 <lambdabot>  Parse failed: Parse error: \
12:11:42 <philippD> @let robertsTranslate (tX,tY) ((x,y):vs) = foldr (\(tX, tY) [(x, y)] -> [(tX+x, tY+y)]) [] ((x,y):vs)
12:11:44 <lambdabot>  Defined.
12:11:54 <philippD> robertsTranslate (0,0) []
12:11:56 <philippD> > robertsTranslate (0,0) []
12:11:58 <lambdabot>  *Exception: /tmp/mueval14134-0.hs:(185,1)-(187,19): Non-exhaustive patterns ...
12:12:04 <conc> hololeap: here ?
12:12:18 <hololeap> conc: you just need to convert `XTree.Tree (Maybe a)` to `XTree.Tree String`. the easiest way to do that is to fmap show over your tree: https://lpaste.net/
12:12:19 <RobertL_> oh we have a lambda bot in here!
12:12:28 <hololeap> *ahem* https://lpaste.net/6606573545734537216
12:12:32 <nitrix> philippD: I think he mentioned the other relevant pattern, I don't think it's an oversight.
12:13:01 <nitrix> Well, at least earlier he had it. Maybe now he doesn't.
12:13:09 <RobertL_> robertsTranslate(0,0)[(1,2)]
12:13:17 <RobertL_> robertsTranslate (0,0) [(1,2)]
12:13:19 <philippD> > robertsTranslate(0,0)[(1,2)]
12:13:21 <fishythe_> you need a > before it
12:13:22 <lambdabot>  *Exception: /tmp/mueval14155-0.hs:186:12-52: Non-exhaustive patterns in lambda
12:13:24 <nitrix> RobertL_: Add > in front.
12:13:28 <hololeap> conc: i just modified line 31... `show <$> e` is the same as `fmap show e`
12:13:37 <RobertL_> >robertsTranslate (0,0) [(1,2)]
12:13:44 <RobertL_> > robertsTranslate (0,0) [(1,2)]
12:13:46 <lambdabot>  *Exception: /tmp/mueval14176-0.hs:186:12-52: Non-exhaustive patterns in lambda
12:14:30 <conc> hololeap: can you paste what you changed ?
12:14:33 <philippD> RobertL_ even if you have a second pattern that handles the empty case the lambda you pass to foldr is still problematic
12:14:56 <hololeap> conc: that second-to-last line... i changed the `e` to `show <$> e`
12:15:40 <philippD> RobertL_ the list will always be empty in the first step. and you are only matching a list that has exactly one element.
12:15:53 <conc> hololeap: doesnt compile, make a paste of the whole code if possible
12:15:53 <hololeap> conc: https://lpaste.net/6606573545734537216
12:16:25 <fishythefish> RobertL_: most likely your accumulator should just be a pair, not a list of pairs, and your starting value should be (0, 0), not []
12:17:16 <hololeap> i actually don't like lpaste. here, conc: http://dpaste.com/24P3QYK
12:17:29 <RobertL_> hmm, but the original code I need to convert into a foldr is :      translate(x0,y0) ((x,y):vs) = (x+x0,y+y0): translate(x0,y0)vs
12:17:37 <philippD> RobertL_ what are you trying to achieve exactly? are you trying to sum up a list of pairs or do you want to add a pair to every pair in the list?
12:17:40 <RobertL_> if i read it right, the : suggests that we are building a list?
12:17:48 <nitrix> RobertL_: Again, foldr is about collapsing a Foldable structure into a single result. You make it sound like you want to apply a translation to every tuples in a list and obtain a new list, which foldr isn't suited for. I know you said it's a requirement, but I'm at lost at what you're trying to achieve.
12:17:59 <fishythefish> nitrix: foldr is suited just fine for creating new lists
12:18:31 <RobertL_> Is my understanding of the original function right?
12:18:32 <nitrix> fishythefish: Assuming your accumulator is a list, sure.
12:18:32 <RobertL_> translate(x0,y0) ((x,y):vs) = (x+x0,y+y0): translate(x0,y0)vs
12:18:56 <conc> hololeap: ok but how do i hide the Just and Nothing in the output ?
12:19:05 <fishythefish> nitrix: right, and that's easily doable and in fact what RobertL_ seems to be trying, so I'm not sure why you're telling him otherwise
12:19:14 <philippD> RobertL_ depends on what you want to do
12:19:27 <nitrix> fishythefish: Because he's shown me otherwise.
12:19:44 <conc> hololeap: it should look like this: https://lpaste.net/3749643110972391424
12:19:57 <conc> hololeap: no Just and Nothing visible
12:20:02 * hackage nettle 0.3.0 - safe nettle binding  http://hackage.haskell.org/package/nettle-0.3.0 (stbuehler)
12:20:04 <fishythefish> nitrix: there's a difference between "I don't think you understand how to use this tool" and "you're holding the wrong tool"
12:20:17 <hololeap> conc: it was the only way to fit your tree structure into the XTree.Tree structure. An empty node in XTree.Tree still requires a label, while yours does not. hence, i had to use Maybe to fit them together
12:20:44 <conc> hololeap: any way to fix this ?
12:20:51 <fishythefish> RobertL_: was that the only line of the code you're turning into foldr, or did you also have a case to handle an empty input list?
12:21:24 <RobertL_> translate(x0,y0) ((x,y):vs) = (x+x0,y+y0): translate(x0,y0)vs
12:21:24 <RobertL_> and
12:21:37 <[exa]> hololeap: not true (see Forest)
12:21:44 <philippD> RobertL_ What should your translate function do?
12:21:45 <RobertL_> translate _ [] = []
12:21:50 <RobertL_> translate _ [] = []
12:21:51 <RobertL_> translate(x0,y0) ((x,y):vs) = (x+x0,y+y0): translate(x0,y0)vs
12:21:56 <RobertL_> and i need to use foldr
12:22:13 <cocreature> you don’t even need a forest here, you can just return a Maybe (Tree a)
12:22:24 <cocreature> if you need a forest you can always use toList
12:22:27 <starlord123> > parseExpr = do {option '+' sign; d <- liftM (\c -> read c :: Int) $ option "1" $ many digit; x <- many letter; return $ Term d (sort x)}
12:22:29 <lambdabot>  <hint>:1:11: error:
12:22:29 <lambdabot>      parse error on input ‘=’
12:22:29 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
12:22:39 <philippD> RobertL_: so you want to add a pair to every pair in the list correct?
12:22:56 <starlord123> > let parseExpr = do {option '+' sign; d <- liftM (\c -> read c :: Int) $ option "1" $ many digit; x <- many letter; return $ Term d (sort x)}
12:22:58 <fishythefish> RobertL_: okay, good. Now you just need to understand foldr :) Based on that, the general pattern would be `translate (x0, y0) vs = foldr (...) [] vs` and we need to fill in the ... with the appropriate lambda
12:22:58 <lambdabot>  <no location info>: error:
12:22:58 <lambdabot>      not an expression: ‘let parseExpr = do {option '+' sign; d <- liftM (\c ...
12:23:38 <starlord123> Hi, why do my read function fails in this parseExpr = do {option '+' sign; d <- liftM (\c -> read c :: Int) $ option "1" $ many digit; x <- many letter; return $ Term d (sort x)}
12:23:39 <RobertL_> @philippD yeah
12:23:39 <lambdabot> Unknown command, try @list
12:23:40 <hololeap> [exa]: you can have an empty forest, but a Tree (from Data.Tree) with an empty forest still needs a labe
12:24:00 <RobertL_> translate(1,1) [(1,1), (2,2)] = [(2,2), (3,3)]
12:24:00 <hololeap> *label
12:24:05 <conc> [exa] : hololeap: code works now, only need to remove Just and Nothing from output ? https://pastebin.com/SvHiyFHT
12:24:07 <RobertL_> assuming i understand the question correctly
12:24:24 <philippD> RobertL_ and you absolutly HAVE to use `foldr`? Using `map` this would be pretty easy
12:24:32 <cocreature> hololeap: [exa]’s point is that you don’t need to convert to a Tree, you can convert to a Forest instead (or a Maybe (Tree a) as I suggested)
12:24:34 <[exa]> hololeap: empty forest doesn't need a label
12:24:38 <RobertL_> yes. The question requires us to use foldr
12:24:42 <RobertL_> and to avoid recursion
12:26:06 <RobertL_> philippD : the question after translate is
12:26:11 <RobertL_> length [] = 0
12:26:23 <RobertL_> length (_:xs) = length xs + 1
12:26:34 <RobertL_> again, use foldr and rewrite the function
12:26:49 <conc> can you filter words from output in putStr ?
12:27:15 <hololeap> well, whatever. the whole point of this exercise was to convert conc 's tree to a Tree from Data.Tree so they could use drawTree. i did that and i'm gonna call it a day :)
12:27:53 <conc> hololeap: ok thanks ! i think it looks good already
12:29:03 <hololeap> conc: if you want to customize the output, i think you'll have to use your own version of drawTree instead of the built-in one
12:29:12 <philippD> RobertL_: ok. then you should exepriment with foldr in ghci for a bit until you get an intuition for what it does.
12:29:59 <conc> hololoeap: heres the code from the example where its done without Just and Nothing https://pastebin.com/XqgvAQzE
12:30:24 <RobertL_> even this doesn't work :S (a function that would put tuple into the []) translate ((x,y):vs) = foldr (:) [] ((x,xs):vs)
12:30:45 <RobertL_> but yeah, playing with ghci :)
12:31:14 <RobertL_> translate (x:vs) = foldr (:) [] (x:vs) works
12:31:41 <RobertL_> oops, ignore my first msg.
12:31:58 <RobertL_> translate ((x,y):vs) = foldr (:) [] ((x,y):vs) works. I mistyped
12:32:18 <philippD> RobertL_: you shouldn't start by pattern matching the arguments. Patternmatching always always leads to recursion
12:32:50 <philippD> treat them as black boxes you just stick into other functions
12:33:12 <philippD> let those functions deal with the structure of the value
12:34:04 <hololeap> conc: the difference is that they have Branch or Leaf, both of which hold a label. in your version you have Node, which holds a label, or Empty, which doesn't hold anything
12:34:48 <conc> hololeap: so no way to do it like in the example ?
12:35:56 <hololeap> conc: you could change it so that you are using a Branch and Leaf like they do, or just stick with converting to `Tree (Maybe a)` since this allows for the option of not having a label.
12:39:19 <RobertL_> I suck at haskell :(
12:39:32 <RobertL_> I decided to skip translate. For length : length1 (x:xs) = foldr (\_ x -> 1 + x) 0 (x:xs)
12:39:34 <RobertL_> i think it works
12:39:52 <Cale> RobertL_: why pattern match the list?
12:40:52 <RobertL_> you mean it would be better to replace (x:xs) by list?
12:40:54 <Cale> That definition would work for an empty list too (that's what the 0 is for)
12:41:07 <Cale> So no need to specify that the list must be nonempty
12:41:08 <fishythefish> RobertL_: you can just replace that pattern with a single variable
12:41:24 <RobertL_> let length1 a = foldr (\_ x -> 1 + x) 0 a
12:41:31 <RobertL_> @ let length1 a = foldr (\_ x -> 1 + x) 0 a
12:42:10 <RobertL_> > let length1 a = foldr (\_ x -> 1 + x) 0 a
12:42:12 <lambdabot>  <no location info>: error:
12:42:12 <lambdabot>      not an expression: ‘let length1 a = foldr (\_ x -> 1 + x) 0 a’
12:42:25 <fishythefish> @let length1 a = foldr (\_ x -> 1 + x) 0 a
12:42:26 <lambdabot>  Defined.
12:42:34 <fishythefish> > length1 []
12:42:34 <hololeap> conc: here, this should do what you want: http://dpaste.com/22KXSBT
12:42:36 <lambdabot>  0
12:42:38 <fishythefish> > length1 [1, 2, 3]
12:42:40 <lambdabot>  3
12:43:16 <RobertL_> thnx
12:43:30 * hackage hlint 2.1.6 - Source code suggestions  http://hackage.haskell.org/package/hlint-2.1.6 (NeilMitchell)
12:43:54 <[exa]> RobertL_: btw you can now omit both 'a's from the definition
12:44:12 <conc> hololeak: yes thats it !
12:45:25 <[exa]> RobertL_: and just for something interesting, the lambda (\_ x->x+1) is equal to a bit more readable  (const (+1))
12:45:53 <hololeap> (i realized you could just filter the (XTree.Node Nothing _) values out of the Forest, and then strip away the Just wrapper)
12:45:56 <conc> hololeap: now any idea how i could use printTree , like putStr $ printTree t9   and it should use t9 convert it with toDataTree and print it
12:46:16 <zincy> How do I use lens to set across lists?
12:46:30 <RobertL_> exa : @let length1 = foldr (\_ x -> 1 + x) 0 ?
12:46:35 <zincy> Tried this clearBets game = (game . players . traversed . bet) .~ 0
12:46:35 <RobertL_> @let length1 = foldr (\_ x -> 1 + x) 0 ?
12:46:35 <lambdabot>  Parse failed: Parse error in expression: foldr (\ _ x -> 1 + x) 0 ?
12:46:36 <[exa]> zincy: use traverse?
12:47:03 <[exa]> RobertL_: yes (except lambdabot doesn't like question marks)
12:47:14 <RobertL_> @let length1 = foldr (\_ x -> 1 + x) 0
12:47:15 <lambdabot>  .L.hs:186:1: error:
12:47:15 <lambdabot>      Multiple declarations of ‘length1’
12:47:15 <lambdabot>      Declared at: .L.hs:179:1
12:47:23 <RobertL_> @let length2 = foldr (\_ x -> 1 + x) 0
12:47:24 <lambdabot>  Defined.
12:47:31 <RobertL_> length2 [1,2,3,4,5]
12:47:40 <RobertL_> > length2 [1,2,3,4,5]
12:47:42 <lambdabot>  5
12:47:42 <hololeap> conc: i'm not sure what you mean. printTree takes one of your Tree data structures that you wrote, while toDataTree turns it into an XTree.Tree
12:48:10 <Zemyla> So I have a question about Linear Haskell.
12:48:54 <conc> hololeap: i mean just leave the type signature of printTree, rewrite it and make it call toDataTree and do the print
12:50:07 <[exa]> RobertL_: anyway anyway, if you're learning haskell, you will like to examine following definition: length5 = sum . map (const 1)
12:52:55 <hololeap> conc: like this? http://dpaste.com/0XHKJ26
12:54:26 <conc> hololeap: so i can do the print withhololeap: yes thanks ;)
12:55:15 <hololeap> conc: you could also do this since you have the Show instance defined (show = printTree): http://dpaste.com/12XVM36
12:56:15 <hololeap> also, note that fromJust is also in the Data.Maybe module
12:56:59 <conc> hololeap: ok ;)
12:57:58 <[exa]> I'm always amazed by how much people like null exceptions
12:58:04 <MarcelineVQ> and fromMaybe, fromJust's non-evil big brother
12:58:12 <MarcelineVQ> and maybe, fromMaybe's dad
12:58:44 <hololeap> yeah, fromJust will throw an exception if you give it a Nothing, but we filtered all the Nothings from the list already...
12:58:57 <mreh> hololeap, exception?
12:59:12 <[exa]> hololeap: what about the tree root btw?
12:59:19 <mreh> I thought it called `error'
12:59:30 <geekosaur> error throws an exception
12:59:37 <MarcelineVQ> filters and froms? sounds like catMaybes or mapMaybe :D
12:59:51 <hololeap> [exa]: eh, good point :)
12:59:52 <geekosaur> the exception type is ErrorCall and carries a String payload
13:00:11 <mreh> can you catch an exception raised by error?
13:00:14 <maerwald> there goes purity :P
13:00:29 <cocreature> mreh: yes but only in IO
13:00:36 <cocreature> and you really shouldn’t :)
13:00:51 <hololeap> mreh: you really don't want to call exceptions from pure code if you can help it
13:00:57 <mreh> exceptions are Satan
13:01:11 <maerwald> exceptions are great, if they are done properly
13:01:16 <mreh> why would I want to jump into another execution stack, one is enough
13:01:36 <geekosaur> not sure I'd say they're satan, but they;re certainly a devil to deal with properly >.>
13:01:48 <MarcelineVQ> you don't, you stay in IO and handle it all there.    http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml
13:02:20 <mreh> phew
13:02:37 <conc> is it possible to use import below a runction and not in the first line ?
13:02:45 <geekosaur> conc, no
13:04:38 <conc> is it possible to copy paste the code from Data.Tree which i use, so i dont need to import ?
13:05:23 <[exa]> conc: if you also copypaste its dependencies
13:05:29 <hololeap> [exa], conc: there. it won't die on an empty root node now: http://dpaste.com/0H1KP2S
13:06:21 <conc> [exa] what do you mean ? so it wouldnt work ?
13:06:41 <[exa]> conc: it will work
13:06:59 <conc> [exa] how to locate the code i use and copy paste it ?
13:07:01 <cocreature> hololeap: fwiw imho this is a lot cleaner if you put the Maybe around the tree rather than in the node values, i.e., https://gist.github.com/cocreature/0e03d57f978a2519c01bec96c5aba5c3
13:07:02 <[exa]> hololeap: you're finally converging to the simple solution :D
13:08:53 <hololeap> cocreature: that is a LOT cleaner :) and i will have to remember mapMaybe for the future. seems like a useful function.
13:09:06 * [exa] added a comment
13:09:32 <cocreature> hololeap: catMaybes is also often useful
13:09:38 <[exa]> (you can use drawForest with that directly)
13:09:39 <mreh> I wish there was a mapLeft
13:09:55 <[exa]> mreh: isn't there one in bifunctors?
13:09:58 <cocreature> [exa]: the forest solution has a less precise type :)
13:10:05 <mreh> [exa], maybe
13:10:15 <cocreature> :t first :: (a -> b) -> Either a c -> Either b c
13:10:16 <lambdabot> error:
13:10:16 <lambdabot>     • Couldn't match type ‘(a1, d0)’ with ‘Either a1 c1’
13:10:16 <lambdabot>       Expected type: (a1 -> b1) -> Either a1 c1 -> Either b1 c1
13:10:20 <cocreature> :t first
13:10:21 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
13:10:24 <cocreature> stupid arrow
13:10:29 <cocreature> :t Data.Bifunctor.first :: (a -> b) -> Either a c -> Either b c
13:10:30 <lambdabot> (a -> b) -> Either a c -> Either b c
13:10:33 <cocreature> there you go :)
13:11:52 <hololeap> [exa]: nice, hadn't thought of that
13:12:11 <mreh> cocreature, neat
13:13:11 <conc> how can i extract the cose i use from Data.Tree so i dont need to import it ?
13:13:18 <conc> *code
13:14:26 <cocreature> Ctrl+C and Ctrl+V
13:15:06 <hpc> maybe you could build it with the import, then decompile it after :P
13:15:07 <mreh> conc, download it from hackage
13:15:29 <hpc> conc: what do you need this for? i can't think of what purpose that would serve
13:15:34 <conc> mreh hackage is legal to use?
13:15:46 <hpc> why would it not be?
13:15:48 <mreh> conc, yes, but don't tell anyone
13:17:33 <cocreature> hpc: there is the “my university assignment doesn’t allow me to use anything but "base"” usecase :)
13:18:09 <hpc> oh, so not "legal" but "cheating" ;)
13:18:20 <mreh> assignments aren't allowed in Haskell, didn't anyone tell you?
13:18:22 <maerwald> cheating is the best thing you can do
13:18:25 <mreh> badum tish
13:18:31 <conc> so how do i find Data.Tree Node code inhackage ?
13:18:36 <maerwald> everyone should cheat
13:18:49 <maerwald> that's what free software is about :)
13:19:06 <cocreature> conc: the docs have source links on the right, e.g., take a look at https://hackage.haskell.org/package/containers-0.5.11.0/docs/Data-Tree.html#v:drawTree
13:19:11 <cocreature> that will show you the definitions
13:20:35 <[exa]> conc: did you try just, like, copypasting it?
13:21:31 <conc> [exa] i will try now
13:22:16 <cocreature> write lots of code really fast with this one weird trick: copypaste
13:24:37 <hololeap> also the best way to increase your WPM
13:25:49 <[exa]> oh verily do I remember the time when opensource was dark and code was scarce
13:26:22 <[exa]> and the only stuff available for copypaste was visual basic
13:27:54 <Vapeur> We moved from VisualBasic+HTML to All Javascipt+html.  I miss VB.
13:28:33 <EvanR> if current threds continue, in 20 years we will all be using asseembly language + HTML
13:28:59 <EvanR> trends*
13:30:29 <[exa]> asm.js *cough*
13:30:55 <t7> asm.js is obsolete
13:31:22 * [exa] can't resist imagining bf.js
13:31:47 <EvanR> i only think in whitespace .js
13:32:19 <fr33domlover> That's the universal measure of the quality of JS code
13:32:27 <fr33domlover> A JS file that is just whitespace
13:32:33 <fr33domlover> That's perfection in JS
13:32:48 <t7> not a valid module according to typescript
13:32:52 <t7> needs an export
13:33:43 <fr33domlover> t7, well, JS is invalid ^_^
13:34:38 <mreh> WebAssembly backend for GHC when?
13:35:03 <Cale> elvishjerricco: ^^
13:37:26 <conc> damn i cannot locate which code i need to copy paste from Data.Tree since im not allowed to import anything in the task
13:38:03 <MarcelineVQ> if you're not allowed to import anything what sense does copying something else even make
13:38:51 <conc> well it says editing is allowed in a section of code , but not at the top where an import goes
13:40:10 * geekosaur has a feeling the real intent is "write it yourself"
13:40:19 <conc> so i have to find a way arround or use my old function which is not as good as drawTree from Data.Tree
13:42:00 * hackage deriving-compat 0.4.3 - Backports of GHC deriving extensions  http://hackage.haskell.org/package/deriving-compat-0.4.3 (ryanglscott)
13:42:10 <mreh> I think copying and pasting is considered plagarism, which is generally frowned upon in academia
13:43:23 <conc> mreh: yeah i think i stick to my own "bad" function
13:47:00 * hackage language-puppet 1.3.18 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-1.3.18 (SimonMarechal)
13:52:00 <geekosaur> don't worry about how good it is. you'll get there, if you keep working at it
13:54:00 <[exa]> he didn't have ctrl+f  :(
14:03:53 <starlord123> second try parseExpr = do {option '+' sign; d <- liftM read $ option "1" $ many digit; x <- many letter; return $ Term d (sort x)}
14:04:07 <starlord123> why does my read fail in this case
14:04:36 <starlord123> it fails only when the option fails and returns "1"
14:04:49 <starlord123> for rest if the cases it works fine
14:06:47 <starlord123> > :t option
14:06:49 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
14:08:01 <starlord123> > parseExpr = do {option '+' sign; d <- liftM read $ option "1" $ many digit; x <- many letter; return $ Term d (sort x)}
14:08:03 <lambdabot>  <hint>:1:11: error:
14:08:04 <lambdabot>      parse error on input ‘=’
14:08:04 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
14:09:31 <geekosaur> I don't think (mega)parsec is loaded anyway
14:09:42 <geekosaur> but you can't define names in "> " like that
14:09:48 <geekosaur> it takes expressions
14:10:51 <starlord123> ok
14:13:00 <conc> [exa] was this your code ? https://lpaste.net/8966001722279329792
14:15:50 <starlord123> my code https://lpaste.net/9025818350286012416
14:20:30 * hackage weeder 1.0.6 - Detect dead code  http://hackage.haskell.org/package/weeder-1.0.6 (NeilMitchell)
14:32:00 * hackage composition-prelude 1.5.0.1 - Higher-order function combinators  http://hackage.haskell.org/package/composition-prelude-1.5.0.1 (vmchale)
14:47:30 * hackage composition-prelude 1.5.0.2 - Higher-order function combinators  http://hackage.haskell.org/package/composition-prelude-1.5.0.2 (vmchale)
14:49:01 <zincy> How do I install test dependencies using stack if I added a dependency to my tests executable in the package.yaml?
14:52:00 * hackage composition-prelude 1.5.0.3 - Higher-order function combinators  http://hackage.haskell.org/package/composition-prelude-1.5.0.3 (vmchale)
14:59:11 <zincy> How do you use lens to set a given element in a list which satisfies a predicate?
14:59:46 <zincy> Im thinking traversed and %~
15:11:46 <aijony> Anybody ever use docon?
15:14:40 <Eduard_Munteanu> Are there some great Haskell libs for machine learning, particularly classification problems, that I should take a look at?
15:15:03 <Eduard_Munteanu> (not necessarily Haskell-native, could be bindings)
15:35:15 <orion> Is it possible/easy to incrementally parse a list of objects in JSON with ConduitT?
15:37:11 <jle`> zincy: a 'given element' as in an element at a given index?
15:37:31 <jle`> or all elements in a list that satisfy a predicate?
15:48:12 <Xal> I'm parsing a language with megaparsec; what's the best way to tag my AST with the source position of each leaf?
16:34:10 <Xal> I've settled on using the cofree comonad, it seems to work pretty well.
17:34:35 <maerwald> haha, I got cyclomatic complexity in my editor :>
17:50:03 <glguy> Xal: It's common to annotate your AST with the type of annotations and to use position information as the annotation you get on the AST you get from the parser
18:21:43 <arfy> hi, haskellites, is there a reason that a simple hello, world type program is around 7.6mb when compiled with ghc? static linking? and is there a way to reduce this? running under win x64
18:23:02 <Cale> Yeah, pretty much static linking. You could link the thing dynamically, but most people won't have the appropriate libraries, so mostly, don't worry about it.
18:23:18 <pdxleif> @hoogle Maybe a -> e -> Either e a
18:23:19 <lambdabot> Control.Error.Safe justErr :: e -> Maybe a -> Either e a
18:23:19 <lambdabot> Control.Error.Util note :: a -> Maybe b -> Either a b
18:23:19 <lambdabot> Data.Either.Extra maybeToEither :: a -> Maybe b -> Either a b
18:24:10 <arfy> Cale: alright! :) Was just curious more than anything
18:29:44 <pavonia> On older compilers that was less than a MB. What did happen to the RTS that it grew by a factor of >7?
18:30:08 <pdxleif> So one library (extra) is described as "Extra functions I use"; the other (Control.Error) apparently has two of the same function, just in different modules.
18:48:28 <hololeap> arfy: it's a combination of static linking and that the haskell runtime is pretty beefy
18:49:28 <hololeap> definitely not suitable for embedded programming, unfortunately
18:52:16 <alx741_> has anyone used ivory to write embedded code in an actual application? specially to run in a small microcontroller. The DSL seems great but a bit cumbersome for a whole application
18:58:12 <glguy> alx741_: The team that developed Ivory used it to develop an embedded autopilot: https://smaccmpilot.org/
19:00:44 <alx741_> glguy: Oh! that's amazing. Was leaning towards Rust for uC embedded, but if they managed to pull that off, maybe is worth a serious try
19:08:27 <shachaf> whoa, Conor McBride is giving a talk in SF on Monday?
19:08:40 <shachaf> How come no one tells me these things?
19:18:21 <jchia_> How can I trace the chain of modules that reexport (directly or indirectly) a function all the way to where it's originally exported? Can I do this in ghci?
19:18:41 <jchia_> '
19:19:06 <jchia_> ':i' seems to only tells me where it's originally defined and where it's finally reexported
19:41:02 <stites> Hi all! I'm wondering if there is an academic paper on the advantages of purely-functional programming languages for concurrent and parallel requirements
19:41:28 <stites> Would anyone happen to know of one?
19:43:51 <ammar2> stites: not a full paper on the topic, but the famous paper on concurrency, "Communicating Sequential Processes" has a tiny section and a further reference to pure functional languages
19:45:09 <ammar2> the paper referenced in that section is "The semantics of a simple language for parallel programming", and the language presented there is pure functional
19:46:33 <ammar2> that last bit might be wrong but hopefully that should give you some good leads
19:46:46 <stites> Awesome! I'm taking a look now.
19:50:01 <stites> Hmm... looks like CSP is saying that, as of 2004, "functional multiprocessing" (which I'm reading as "fp applied to multiprocessing" based on the intro) is a hopeful, but practically infeasible.
19:54:35 <stites> Oh! These are all about PLT applied to multiprocessing
19:57:14 <stites> Okay, thanks @ammar2 -- this is making me realize that I just need to find citations for various modules in base
20:02:06 <stites> ...and it looks like all I have to do is look at SPJ's publication page, then scroll down: https://www.microsoft.com/en-us/research/people/simonpj/#!publications
22:04:33 <dmwit> jchia_: I don't believe there's an existing tool for that. Also be aware that it may not be a chain but a full-blown graph.
22:27:00 * hackage potoki-core 2.1 - Low-level components of "potoki"  http://hackage.haskell.org/package/potoki-core-2.1 (IrinaArtemeva)
22:33:42 <darkJedi> hi! I was going through Monad laws to understand them. But I'm unable to understand Right identity. Can anyone explain it to me with an example?
22:33:59 <darkJedi> I'm referring https://wiki.haskell.org/Monad_laws
22:34:38 <cocreature> darkJedi: what exactly is confusing you?
22:35:10 <cocreature> > [1,2,3] >>= return
22:35:12 <lambdabot>  [1,2,3]
22:36:25 <darkJedi> So, on getting the type of (>>=). I get (>>=) :: Monad m => m a -> (a -> m b) -> m b
22:37:14 <darkJedi> Is return a function over here ? That takes the value from inside the Monad and does some operation and wraps it back in a monad ?
22:37:21 <cocreature> :t return
22:37:23 <lambdabot> Monad m => a -> m a
22:37:33 <monochrom> Set a=b.
22:37:53 <cocreature> a better way to think of return is that it embeds a value in a monadic context
22:38:03 <cocreature> > return 1 :: [Int]
22:38:05 <lambdabot>  [1]
22:38:08 <cocreature> > return 1 :: Maybe Int
22:38:10 <lambdabot>  Just 1
22:39:07 <darkJedi> oh! okay.
22:41:23 <olligobber> > return 1 :: ZipList Int
22:41:26 <lambdabot>  error:
22:41:26 <lambdabot>      • No instance for (Monad ZipList) arising from a use of ‘return’
22:41:26 <lambdabot>      • In the expression: return 1 :: ZipList Int
22:41:47 <olligobber> that's not what I expected
22:41:57 <cocreature> > pure 1 :: ZipList Int
22:42:00 <lambdabot>  ZipList {getZipList = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
22:42:07 <olligobber> that's what I expected
22:42:11 <olligobber> why isn't that a monad?
22:42:19 <cocreature> try writing an instance :)
22:43:14 <darkJedi> And left identity ```return a >>= f```. In here ```return a``` will give me ```a wrapped in monad```. And f is a function that takes a monad, unwraps the value applies the operation, wraps it in a monadic context right!
22:43:45 <cocreature> not quite, f is of type (a -> m b) so it doesn’t “take a monad”
22:44:26 <darkJedi> oh! okay.
22:44:31 <cocreature> it might be helpful to think about >>= in terms of fmap and join. x >>= f is equivalent to join (fmap f x)
22:44:54 <cocreature> so you first apply f to all values in the structure and then you merge the resulting nested structure
23:26:33 <pdxleif> What happened to EitherT? It was in version 4.5 of "either", but it's gone in version 5.0
23:26:39 <pdxleif> Should I use ExceptT instead?
23:27:41 <pdxleif> Ah, I see: https://github.com/ekmett/either/commit/543f78bce4bcd8131318b912574d409f59ce6144
23:41:00 * hackage buffer-builder 0.2.4.6 - Library for efficiently building up buffers, one piece at a time  http://hackage.haskell.org/package/buffer-builder-0.2.4.6 (chadaustin)
23:50:07 <dramforever> Has anyone made, for demonstration purposes, a GHC Haskell program that uses as many syntactic features as possible?
23:50:43 <dramforever> I kinda want to try out the -ddump-parsed-ast and -ddump-tc-ast options but I don't want to read GHC source :(
23:51:11 <cocreature> why do you need to read the GHC source to try out a cli arg?
23:51:18 <cocreature> just, like, try it out?
23:52:41 <dramforever> cocreature: that's a good question
23:55:48 <dramforever> cocreature: Because the dump output looks like this: https://paste.ubuntu.com/p/Q9G6tYZYpR/
23:56:22 <cocreature> dramforever: do you have some underlying goal here? i.e. what information are you trying to get out of -ddump-parsed-ast?
23:56:48 <dramforever> My general direction is to write some tooling
23:57:14 <dramforever> like, we might be able to get local variable completion with this thing
23:57:25 <cocreature> it sounds like you might be interested in wz1000’s gsoc project
23:57:45 <cocreature> I don’t think -ddump-parsed-ast is really the way to go. you might as well use the GHC API at that point
23:58:45 <dramforever> And I don't want to write too much Haskell code (like, more than a ghci invocation)
23:58:46 <dramforever> Uh
23:59:03 <dramforever> Like dante: https://github.com/jyp/dante
23:59:33 <cocreature> -ddump-parsed-ast just dumps GHC’s internal representation so if that’s what you want, the GHC API is a better choice
