00:00:13 <cocreature> dumping GHC’s internal representation as a string only to then try and parse it to extract information from it doesn’t sound like a good idea
00:01:44 <dramforever> The dump *does* look quite easy to parse, if only I knew what the { ... } things could be
00:02:27 <cocreature> it’s probably easy to parse but the resulting AST is just the thing that you get from the GHC API
00:02:45 <cocreature> so you are only making your life harder by first serializing the AST to a string and then trying to parse it
00:03:35 <dramforever> I think I'm trying to avoid Haskell in editor extension code, but now that I think about it, I can't really say I know why
00:03:57 <dramforever> Couldn't hurt to try a bit, I suppose
00:05:06 <gonz_> dramforever:  Which editor is this for?
00:05:21 <gonz_> Most editors are going the way of using language protocol clients
00:05:23 <cocreature> I can certainly see an argument for getting a simplified version of the AST instead of having to work with the GHC API (and that’s what the aforementioned gsoc project is trying to do) but -ddump-ast is literally GHC’s internal representation
00:05:48 <dramforever> 'using language protocol clients' duh
00:05:57 <dramforever> looks like I *am* going against everyone else on this
00:06:08 <dramforever> And guess what, it's for vscode
00:06:15 <dramforever> that's like, triple duh
00:07:17 <gonz_> VS Code has the principal implementation of the language protocol client
00:07:34 <gonz_> I think that's a pretty good reason to just concentrate on language servers
00:07:39 <gonz_> But to each his own, I suppose
00:07:54 <gonz_> There is an excellent language server for Haskell called `haskell-ide-engine`.
00:08:07 <dramforever> There must be a reason for ghci to have things like :complete and :all-types
00:08:22 <dramforever> And -ddump-json isn't there for nothing
00:08:29 <dramforever> I hope
00:11:31 <cocreature> ghci is great because contrary to the GHC API it tends to have a fairly stable and robust interface. but once you step out of that interface (i.e. the few commands supported by ghci) I don’t think messing with -ddump flags and trying to parse the output is the way to go
00:11:53 <gonz_> For what it's worth, the main reason Emacs is falling behind nowadays in terms of tooling is because it hasn't embraced language servers early enough and it only has WIP status clients. It's not especially forward-thinking to make a non-language-server-based solution at the present time
00:12:07 <dramforever> :(
00:12:23 <dramforever> I suppose you're right, cocreature and gonz_
00:12:41 <cocreature> dramforever: do you have some specific reason for why you are trying to avoid going down an lsp route?
00:13:10 <dramforever> I guess I was fed up with trying to have ghc-mod build at the time?
00:13:58 <dramforever> And I *do* think that if all I want is some, say, squiggles, then the ghci approach is going to work
00:14:00 <cocreature> I think you are conflating two things here: the way the backend for the server is written and the protocol it uses to communicate with the client
00:14:19 <dramforever> Oh
00:14:24 <gonz_> Interestingly enough  `haskell-ide-engine` features the only known (to me) version of `ghc-mod` that runs on GHC 8.x, so you get `ghc-mod` for free
00:14:36 <cocreature> you could construct your language server as a wrapper around ghci
00:14:40 <dramforever> cocreature: sorry I misunderstood
00:14:58 <dramforever> I thought you were talking about my avoiding Haskell code
00:15:53 <dramforever> You know, you were talking about GHC API earlier...
00:16:24 <ammar2> well that was an alternative to dumping the AST as text :P
00:16:36 <dramforever> :P
00:16:48 <dramforever> And we switched from that to lsp a while back
00:17:19 <dramforever> I mean, switched topics, not backends
00:17:20 <cocreature> so I think there are several points to this: 1. unless you have a good reason to avoid it, lsp is probably a good protocol to communicate with the client. 2. relying on ghci for the backend is perfectly reasonable. 3. dumping the AST as text to avoid having to work with the GHC API is probably not reasonable
00:17:48 <dramforever> 1. 2. yes, 3 okay got that
00:18:47 <dramforever> Yeah that was totally because I misunderstood 'using language servers'. I thought you were talking about haskell-ide-engine in particular
00:20:13 <dramforever> That's cleared
00:20:27 <dramforever> I guess I still have time to go back and switch to a language server implementation, that's noted
00:20:34 <dramforever> Thank you again, gonz_ and cocreature
01:04:48 <zincy> say you players is a field comprising a list inside a record type called Game I want to get the first element of said list using lens. This is my failed attempt       let playerWhoBet = newGame (^. players) . (^? ix 1)
01:05:43 <cocreature> zincy: you usually use lens by first composing the various optics and then using a single operator such as (^.) or (^?)
01:05:58 <cocreature> so try something like newGame ^? players . ix 1
01:07:19 <zincy> So I should think how can I compose optics in a way that fits my needs rather than using ^. multiple times
01:07:28 <cocreature> yep
01:07:32 <zincy> thanks
01:07:50 <cocreature> the fact that optics are composable is probably the main advantage of using lens
01:08:50 <zincy> So that worked
01:08:52 <zincy> :)
01:08:59 <zincy>  ^? players . ix 1
01:09:07 <zincy> Is that just a composed lens ^
01:09:27 <zincy> Operators are just functions that take lenses as arguments
01:09:29 <cocreature> no ix gives you a Traversal not a lens
01:09:42 <zincy> Whats the difference
01:09:49 <cocreature> a lens always targets exactly one argument
01:10:00 <cocreature> a Traversal can target many or 0 elements
01:10:13 <cocreature> which is important for things like "ix" since there might not be a value at the index
01:10:17 <zincy> So is a Traversal an "optic"
01:11:08 <zincy> What alternative to ix would allow you to get the element(s) that satisfy a predicate?
01:11:15 <cocreature> yeah optic is the general term for the various things you’ll find in lens, e.g. Lens, Traversal, Prism, …
01:11:20 <cocreature> :t filtered
01:11:22 <lambdabot> (Applicative f, Choice p) => (a -> Bool) -> Optic' p f a a
01:12:39 <zincy> :)
01:13:20 <zincy> I am beginning to see the expressiveness of lens code
01:13:55 <zincy> Using lens seems to reduce your LOC by a significant amount
01:14:31 <zincy> The only disadvantage is remembering all the squiggly operators :D
01:14:35 <dminuoso> zincy: Just be aware that the downside is, that it requires the reader to be familiar with lens.
01:14:49 <zincy> Yes very very true
01:15:17 <zincy> Although glguy said something which puzzled me yesterday
01:15:20 <dminuoso> Unlike many other libraries you can derive very little intuition from staring at types of optics if you are not familiar with lens already.
01:15:31 <zincy> He said that someone new to haskell hit the ground running in a lensified code base
01:15:34 <cocreature> a lot of the operators also have non-operator versions
01:15:47 <cocreature> e.g. view for (^.), over for (%~), …
01:15:50 <zincy> I cant get my head around how someone could do that
01:16:54 <dminuoso> zincy: Obligatory https://xkcd.com/1827/
01:17:19 <zincy> haha
01:17:39 <zincy> I guess he was an outlier :P
01:17:48 <zincy> or she
01:18:39 <cocreature> using lens is not that hard. the tricky part is finding stuff and dealing with errors and if you have someone that can help you there, it’s not too bad
01:18:49 <[exa]> "there are also non-operator versions" lol :D
01:19:46 <zincy> I guess it just has scary looking operators
01:20:44 <zincy> So what are your favourite libraries?
01:22:45 <dminuoso> acme-everything
01:24:47 <zincy> Does it have many dependencies?
01:25:03 <dminuoso> zincy: You tell me: http://hackage.haskell.org/package/acme-everything
01:25:07 <zincy> :P
01:25:18 <zincy> haha
01:28:04 <zincy> Why did elm's design choices choose to treat everyone like children?
01:28:38 <zincy> Its like the blue pill for functional programming
01:30:54 <dminuoso> zincy: In a lot of ways it's similar to Go, in that the author(s) have very firm beliefs in what the language should be, so they restrict it enough to force to into the habits they believe are good.
01:31:42 <zincy> What do you think of go
01:31:49 <dminuoso> Also both try to be as attractive as possible to mainstream (C or JavaScript respectively) developers, so they both try to avoid overwhelming people with abstractions.
01:31:57 <dminuoso> "Simplicity" they call it
01:32:44 <zincy> Imperative coding overwhelms the faculties of my brain related to working memory
01:34:20 <zincy> Im not sure if I am alone there though
01:34:53 <cocreature> you are in a channel full of Haskell programmers, you will certainly find people here that agree that imperative code is often not the right way to approach a problem :)
01:35:15 <zincy> I love echo chambers
01:35:17 <dminuoso> I firmly believe that imperative programming is the definite approach to *some* solutions. :)
01:35:24 <dminuoso> *some* problems even :P
01:35:40 <zincy> What kind?
01:38:21 <dminuoso> zincy: Any area that requires tight control over generated code or memory is (at this stage) frequently better written in things like C, C++ or Rust. Say kernel development or certain kinds of embedded development.
01:41:30 <dminuoso> zincy: Cryptographic schemes might be problematic as well to implement right because it's very hard to control the generated code leaving you open to a huge well of potential side channels.
01:41:50 <dminuoso> Or things that require maximum performance
01:43:32 <cocreature> interestingly, we seem to be seeing more and more cryptographic code that’s being written in high-level languages that allow for verification and then compiles to low-level code
01:43:54 <cocreature> e.g. chrome has crypto written in Coq iirc, firefox has crypto written in f#, …
01:43:56 <cocreature> eh f*
01:44:24 <ammar2> verification of crypto code or the actual implementation?
01:45:04 <cocreature> depends on what you mean the actual implementation, afaik they automatically generate the code from the verified implementation
01:45:12 <cocreature> that compilation pipeline is probably not fully verified
01:45:21 <dminuoso> cocreature: The verification of the algorithm is one thing, but the papers Ive read that elaborate on side channel attacks because of cache timing attacks, peephole optimizations, code generation, out-of-order execution...
01:46:01 <dminuoso> Against implememtations that were, on the paper, correct.
01:46:20 <cocreature> dminuoso: right, iirc for the stuff in chrome, they claim that they are immune to things like timing attacks because they compile only to primitives that are resistant against those
01:46:37 <dminuoso> That sounds very interesting then.
01:47:39 <dminuoso> cocreature: Do you have a link/article/paper about this at hand or should I google myself?
01:47:51 <cocreature> you’ll have to search for it yourself, sry :/
01:48:07 <dminuoso> No worries :)
01:48:11 <cocreature> adam chlipala was involved in the chrome stuff iirc, so that might be a helpful search term :)
01:48:43 <dminuoso> http://adam.chlipala.net/theses/rsloan.pdf
01:49:40 <dminuoso> That was helpful :)
01:56:08 * hackage store-core 0.4.4 - Fast and lightweight binary serialization  http://hackage.haskell.org/package/store-core-0.4.4 (MichaelSloan)
02:20:14 <jchia_> There's MonadIO, MonadBase IO (from lifted-base), and MonadUnliftIO (from unliftio-core), and different libraries use them. I just want to use the libraries to do IO and get things done. Do I really have to go and learn lifted-base and unliftio-core and understand how to use them? It's not just one but two things in addition to MonadIO. Is it really necesary?
02:22:16 <jchia_> I don't understand the roles of lifted-base and unliftio-core and how they are different
02:22:52 <cocreature> jchia_: MonadIO only works for things in a positive positions, i.e., things that return IO. MonadUnliftIO and MonadBaseControl allow you to also lift functions that take IO things as arguments
02:23:08 <cocreature> MonadUnliftIO and MonadBaseControl solve the same problem, you only need to use one of them
02:23:49 <cocreature> MonadUnliftIO is simpler and easier to reason about at the cost of restricting what you can write instances for (it only works for ReaderT like things)
02:24:14 <cocreature> MonadBaseControl is more general but it’s fairly complex to understand and a lot of the instances for non ReaderT like things are at least somewhat questionable
02:24:29 <cocreature> e.g. you can end up silently throwing away the result of a State action
02:24:54 <cocreature> so I would recommend that you stick to MonadIO when it works for your usecase and go for MonadUnliftIO when you have IO as an argument
02:25:26 <cocreature> monad-control is somewhat interesting but given the complexity and its problems I would try to avoid it
02:26:18 <jchia_> cocreature: Thanks. I suppose if the libraries I use sometimes use MonadUnliftIO and sometimes use MonadBaseControl, I'll have to learn them both and switch between them both in my code that uses different libraries. Or, maybe I'll avoid libraries that use MonadBaseControl.
02:27:06 <cocreature> unliftio is still fairly new but I kind of hope that it will replace the use of MonadBaseControl in a lot of libraries
02:43:23 <jchia_> cocreature: What about MonadBase? Is it more similar to MonadIO or the other two?
02:43:39 <jchia_> lifted-base uses MonadBase IO
02:44:01 <cocreature> MonadBase IO should be equivalent to MonadIO
02:44:16 <cocreature> the difference is that you could have a different base monad
02:44:36 <jchia_> thanks
02:45:29 <cocreature> if you take a look at lifted-base you can also see how it uses MonadBase IO for the things that return IO and MonadBaseControl IO for things that take IO actions as their arguments
03:05:51 <[exa]> hm, how complicated it would be to make a DSL that compiles to shell (bash)?
03:06:22 <[exa]> I'm kindof annoyed by all packaging systems except autotools, which uses m4 as the DSL
03:07:58 <dminuoso> [exa]: You mean you want nix?
03:09:25 <[exa]> nix is a distribution that includes many (repackaged) autotools-style packages, I want a way to create such packages
03:09:42 <[exa]> a configure-script compiler if you want
03:17:09 <dminuoso> [exa]: You mean autoconf?
03:20:16 <[exa]> dminuoso: yes, with automake... Makefile-compiler-compiler to be cleaner :D
03:20:46 <zincy> what is autoconf I remember  it gets sad when I list extra packages that dont exist in my cabal file
03:21:26 <[exa]> it's completely unrelated to haskell/cabal, I was just thinking about rewriting that from a shellish DSL to haskell DSL
04:10:14 <zincy> How do I update a field using other fields of the record type?
04:10:15 <zincy> placeBet value = (chips -~ value) . (bet +~ value) . (committed +~ value) . (playerState %~ (^. ) )
04:11:04 <zincy> The last lens should update playerState value depending on whether value is equal to the chips record field
04:13:32 * hackage dejafu 1.10.0.0 - A library for unit-testing concurrent programs.  http://hackage.haskell.org/package/dejafu-1.10.0.0 (barrucadu)
04:16:06 * hackage hunit-dejafu 1.2.0.5, tasty-dejafu 1.2.0.6 (barrucadu): https://qbin.io/con-lovely-1044
04:17:38 <Gurkenglas> zincy, you could do (filtered (views chips (==0)) . playerState .~ "bankrupt")
04:19:06 <zincy> nice ... would it not add an extra N in worst case runtime complexity though?
04:19:07 <Gurkenglas> zincy, you could do (lensProduct chips playerState %~ \(c,p) -> (c,if c == 0 then "bankrupt" else p))
04:19:53 <Gurkenglas> zincy, why do you think it would?
04:20:29 <zincy> Because if you add a filtering operation you are adding an additional iteration through the list to the computation
04:20:41 <zincy> Is that right
04:21:01 <Gurkenglas> > map (+1) $ filter odd $ map (+1) $ [1,2,3,4,5,6,undefined]
04:21:03 <lambdabot>  [4,6,8*Exception: Prelude.undefined
04:21:33 <zincy> Also this takes a single player as an argument not a list placeBet value = (chips -~ value) . (bet +~ value) . (committed +~ value) . (playerState %~ (^. ) )
04:21:51 <zincy> but your answer is very helpful as it would allow me to do what I was trying
04:22:00 <Gurkenglas> In this case, filtered takes a single-element list and turns it into a zero-or-one-element list
04:23:07 <zincy> So would I then have to get the value out of the list
04:23:12 <zincy> there must be a simpler way :P
04:23:44 <zincy> From my understanding this solution would entail putting an element into a list and then taking it back out
04:23:51 <zincy> Maybe I misunderstood?
04:24:24 <litb> hello folks
04:24:30 <zincy> hi
04:24:37 <litb> i'm looking at some golfing answer and it has  (sum.).take
04:25:01 <zincy> :t (sum.).take
04:25:02 <lambdabot> Num c => Int -> [c] -> c
04:25:11 <litb> apparently it means f x y   means  take 'x' elements from 'y' and sum it up
04:25:19 <litb> yeah, matches the type
04:25:31 <cocreature> litb: it’s equivalent to \x y -> sum (take x y)
04:25:52 <zincy> cocreature: Why are there two dots?
04:25:56 <cocreature> and apart from golfing, I definitely wouldn’t recommend that style :)
04:26:02 <zincy> :t (sum . take)
04:26:03 <lambdabot> (Num [a], Foldable ((->) [a])) => Int -> [a]
04:26:06 <dminuoso> :t ((.) . (.)) sum take
04:26:07 <lambdabot> Num c => Int -> [c] -> c
04:26:09 <cocreature> zincy: because otherwise you would end up with \x y -> sum (take x) y
04:26:26 <litb> the complete answer as   zipWith((sum.).take)<*>scanr(:)[].tail.cycle
04:26:32 <cocreature> :t fmap fmap fmap sum take
04:26:33 <dminuoso> zincy: ^- this may make it a bit more obvious
04:26:34 <lambdabot> Num a => Int -> [a] -> a
04:27:13 <cocreature> if you are having trouble understanding how the double dots work, just inline the definition of (.)
04:27:31 <zincy> :t (.)
04:27:32 <lambdabot> (b -> c) -> (a -> b) -> a -> c
04:27:42 <zincy> :t (.).(.)
04:27:43 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
04:27:48 <zincy> :t (.).(.).(.)
04:27:49 <lambdabot> (b -> c) -> (a1 -> a2 -> a3 -> b) -> a1 -> a2 -> a3 -> c
04:27:51 <litb> ah now i understand.. "(sum.)" means that it expects a function. and the function will be the partially applied "take" that still expects the list
04:27:56 <litb> and the result is summed
04:28:38 <dminuoso> :t sum . zipWith take
04:28:40 <lambdabot> (Num [[a]], Foldable ((->) [[a]])) => [Int] -> [[a]]
04:28:47 <zincy> Oh so composing composition just adds an extra argument to the first function call
04:29:07 <cocreature> f . g = \x -> f (g x)
04:29:07 <dminuoso> zincy: It may be really helpful to think of it as `fmap fmap fmap`
04:29:21 <zincy> what has fmap got to do with (.)
04:29:37 <cocreature> dminuoso: I hope you’re kidding :)
04:29:39 <dminuoso> zincy: there is an `instance Functor ((->) a)
04:29:43 <dminuoso> cocreature: Actually not. :)
04:29:58 <cocreature> then your mind seems to work rather differently than mine :)
04:30:36 <zincy> Variety of teaching styles is advantageous
04:30:57 <zincy> :t fmap fmap fmap
04:30:58 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
04:31:09 <zincy> :t fmap fmap fmap fmap fmap
04:31:10 <lambdabot> Functor f => (a1 -> b) -> (a2 -> a1) -> f a2 -> f b
04:31:26 <litb> is "(sum . take)" even applicable to anything?
04:31:37 <litb> "sum" will try to interpret a function as a list
04:31:46 <dminuoso> :t sum
04:31:47 <lambdabot> (Num a, Foldable t) => t a -> a
04:31:53 <dminuoso> litb: Strictly speaking it will require a Foldable instance
04:31:53 <zincy> Yeah sum the first N elements of a list
04:32:33 <zincy> Gurkenglas: Still there?
04:32:41 <zincy> Concurrent discussions ftw
04:33:21 <zincy> How do I grok (.).(.)
04:33:37 <cocreature> zincy: substitute the definition of (.)
04:33:45 <zincy> :t (.)
04:33:47 <lambdabot> (b -> c) -> (a -> b) -> a -> c
04:34:34 <litb> i thought functor is something that can be mapped over, like a list
04:34:48 <dminuoso> zincy: (fmap . fmap) is the route that I followed to gain a better understanding. It's in the same department as `(zipWith . zipWith)` for example
04:35:15 <dminuoso> litb: You can map over functions too.
04:35:38 <zincy> :t fmap id
04:35:40 <lambdabot> Functor f => f b -> f b
04:38:00 <dminuoso> zincy: so for example: How do you map over the numbers in [[Int]]
04:38:01 <zincy> I am confused about the substitution ... (.) is a function of three arguments but the first arg to (.) takes only two  -  (b -> c) -> (a -> b) -> a -> c
04:38:16 <zincy> fmap fmap
04:38:43 <zincy> fmap fmap id [[1]]
04:38:47 <dminuoso> that wont type check
04:38:54 <zincy> :t fmap
04:38:56 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:40:27 <dminuoso> zincy: You'd just write `fmap (fmap id) [[1]]` for example
04:40:43 <dminuoso> you can write that first part as `(fmap . fmap) id [[1]]`
04:41:08 <dminuoso> so if you wanted to map over the integers in [[[1]]] you could, using the same line of thought, use `(fmap . fmap . fmap) id [[[1]]]`
04:42:02 <cocreature> zincy: f . g = \x -> f (g x), so ((.) . (.)) f g = (\x -> (.) ((.) x)) f g, now let’s beta reduce so we get to (.) ((.) f) g, put (.) in infix form so we have ((.) f) . g, expand the definition again to get to \x -> (.) f (g x), put (.) in infix form so we get \x -> f . g x, expand the definition so we get \x -> \y -> f (g x y)
04:45:27 <dminuoso> zincy: So my intuition is that a function can be thought of as a container of sorts. `f :: Int -> String` is a huge list of strings, indexed by `Int`. using fmap (or respectively (.)) you can map over those strings.
04:45:52 <dminuoso> zincy: and then something like Int -> (Int -> String) is just "nested containers", just like [[Int]]
04:47:06 <zincy> whats going on here (.) ((.) x)) f g
04:47:21 <cocreature> what do you mean by “what’s going on here”
04:47:41 <dminuoso> zincy: That's the inverse of what I just said regarding `fmap (fmap id) = (fmap . fmap) id`
04:47:47 <zincy> Can you talk me through it
04:48:03 <cocreature> note that this term never appears in my expansion
04:48:13 <cocreature> the closest is (\x -> (.) ((.) x)) f g
04:48:23 <zincy> ah ok
04:48:48 <cocreature> and the “talking you through”-part is what I was trying to do with the explanation given above :)
04:49:14 <dminuoso> cocreature: I think ertes taught me this "functions as containers" perspective when I learned about the Costate comonad - it was then when the (.) . (.) completely clicked.
04:49:39 <zincy> So its not just me that struggles with the dot trinity
04:50:28 <cocreature> I tend to just avoid the word “containers” for the most part. too much time has been wasted on debating whether certain things can be called “container” or not
04:50:54 <litb> docker?
04:51:01 <zincy> so the functions as containers perspective is akin to seeing the function as a list of possible elements of the codomain of a function
04:51:19 <dminuoso> zincy: Well *image* of a function
04:51:30 <zincy> what is the image of a function
04:54:40 <zincy> Oh googled it just what I said
04:55:39 <zincy> dminuoso: so is the nesting of (.) just adding containers of structure and increasing the image of the resulting function?
04:56:16 <zincy> or not adding containers of structure .. rather just structure
04:56:25 <zincy> so to get around the fact that
04:56:31 <dminuoso> zincy: Let's pretend for the sake of argument we have some `type Array = ((->) Int)`
04:56:32 <zincy> :t (.)
04:56:33 <lambdabot> (b -> c) -> (a -> b) -> a -> c
04:56:39 <zincy> Takes a function of one argument
04:57:02 <dminuoso> zincy: Array (Array String) is kind of like [[String]] right? (Let's require Int to positive only)
04:57:07 <zincy> we then compose (b -> c) inside the argument to the first (.)
04:57:20 <zincy> Yep
04:58:03 <zincy> :t (->)
04:58:05 <lambdabot> error: parse error on input ‘->’
05:01:46 <dminuoso> zincy: If a function can be thought of as a container (in which the contained type is observable in the codomain), then a function returning a function is just a nested contained.
05:02:13 <dminuoso> Array (Array String) ~ Int -> Int -> String
05:03:25 <zincy> dminuoso: wow
05:03:56 <zincy> That is such an elegant way of describing composition
05:04:04 <litb> :t fmap id id
05:04:06 <lambdabot> b -> b
05:04:09 <litb> nice!
05:04:50 <zincy> dminuoso: How did that intuition help you with costate comonad?
05:05:27 <dminuoso> zincy: So if `fmap x` lets you map over a container, and `(fmap . fmap)` lets you map over a nested container.. then we just need to observe the fact that `instance Functor ((->) a) where fmap = (.)` to see that ((.) . (.)) lets you adapt the result of the result of a function.
05:05:51 <zincy> cocreature: so x is a function in the term? -  f g = (\x -> (.) ((.) x))
05:07:42 <zincy> dminuoso: so each time we compose a function we just nest the resulting functions image
05:07:58 <dminuoso> zincy: That's what currying means.
05:08:09 <dminuoso> A -> B -> C really just means A -> (B -> C)
05:08:39 <cocreature> zincy: yep
05:08:43 <zincy> so currying nests the resulting functions image
05:08:46 <dminuoso> zincy: Or wait I misunderstood that. What exactly do you mean by that?
05:09:07 <zincy> The jump to currying confused me
05:09:28 <zincy> See this is the kind of stuff I find really interesting
05:09:50 <zincy> How do I get more of it :)
05:09:55 <dminuoso> zincy: No I misread what you said.
05:09:57 <dminuoso> 14:07           zincy | dminuoso: so each time we compose a function we just nest the resulting functions image
05:10:12 <dminuoso> function composition in the end is just function composition
05:10:56 <dminuoso> zincy: based on the fact that for `((->) a)` we have a Functor instance I just offered an alternative intuition. But fundamentally it boils down to what cocreature is saying
05:13:29 <litb> the functor thing looks a lot like monad >>=.
05:13:59 <litb> at least the fmap one
05:14:18 <zincy> All monads instances require a functor instance
05:14:33 <zincy> Not sure why though :/
05:15:21 <litb> ah but for >>= the function is required to return a monad instance, but for functor it's not
05:15:44 <zincy> :t (>>=)
05:15:45 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:15:50 <zincy> :t fmap
05:15:51 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:16:06 <cocreature> :t (=<<) -- that one is even closer to fmap
05:16:07 <zincy> :t (<<=)
05:16:08 <lambdabot> Monad m => (a -> m b) -> m a -> m b
05:16:08 <lambdabot> error:
05:16:08 <lambdabot>     • Variable not in scope: <<=
05:16:08 <lambdabot>     • Perhaps you meant one of these:
05:16:14 <zincy> thats it
05:16:27 <litb> and for whatever reason, functor's fmap order of arguments is different from monad's >>=
05:16:40 <litb> ah i see
05:17:21 <zincy> bind is a function whose implementation needs to lift the first argument
05:43:49 <maerwald> 'instance (MyClass (Maybe a)) => MyClass (Either a b)' reduces to 'instance MyClass (Either a b)', right?
05:44:08 <dysfun> i don't suppose anybody knows the purescriptism for converting a Maybe to an Either by providing a Left value?
05:45:57 <hpc> maybe foo id?
05:46:36 * hackage emailparse 0.2.0.10 - An email parser that will parse everything  http://hackage.haskell.org/package/emailparse-0.2.0.10 (mkawalec)
05:46:50 <dysfun> no, sadly it doesn't seem to have a maybe function
05:47:00 <dysfun> that's what i looked for first :/
05:48:13 <dysfun> i think the trick might be this (since prj does the inverse), but i can't figure out how to use it https://pursuit.purescript.org/packages/purescript-either/4.0.0/docs/Data.Either.Inject
05:48:21 <dysfun> and the PS channel is dead at the best of times
05:48:56 <dminuoso> maerwald: what do you mean by "reduces to"
05:49:08 <Taneb> dysfun, that doesn't look right, inj there corresponds to Left I think
05:49:40 <Taneb> dysfun, what about https://pursuit.purescript.org/packages/purescript-either/4.0.0/docs/Data.Either#v:note ?
05:49:59 <dysfun> oh wow, how'd i miss that?
05:50:05 <dysfun> thanks :)
05:50:22 <Taneb> Happy to help :)
05:50:43 <maerwald> dminuoso: the constraint cannot be applied anywhere
05:52:51 <litb> zincy, i think of (.) as "delay". instead of applying the first to the second argument immediately, it just waits or one further argument
05:53:28 <litb> then when saying ((a.).)b it will wait for two arguments.   and for  (((a.).).)b  it will wait for three ones, and so on
05:53:40 <dminuoso> litb: You'll have a much easier time of you think of (.) as a kind of composition. That is in a way it acts like a generalized version of <>
05:55:33 <dminuoso> maerwald: what does that even mean?
05:55:41 <maerwald> nvm
05:56:51 <maerwald> I'll have the answer by the time I have explained it :P
06:01:31 <backes> hey, I don't understand why the second function is valid. Why can we use $ xs ? https://lpaste.net/1785124253738205184
06:02:33 <maerwald> dminuoso: the class has no functions, so the additional context constraint cannot be applied anywhere
06:03:04 <maerwald> I cannot come up with something where the compiler gives a different answer for either of those instance signatures
06:03:22 <maerwald> which is why they are reduced to the same thing
06:03:59 <dminuoso> backes: It's for the same reason that ($) works in the first place
06:04:20 <int-e> backes: a $ b c = a . b $ c  is true by the definition of (.), and (.) is associative
06:04:21 <dminuoso> infixr 9  .
06:04:23 <dminuoso> infixr 0  $, $!
06:05:20 <litb> and is that not the same as   a . b c   ?
06:05:27 <dminuoso> backes: Then add the fact that function application (done with filter) has higher precedence than any operator
06:05:45 <dminuoso> litb: Nope
06:05:53 <litb> ah i see. b c   is done first
06:06:09 <dminuoso> litb: Like I said: function application has higher precedence than any operator.
06:06:15 <litb> race condition
06:06:26 <backes> ah okay, thank you that makes sense :)
06:08:55 <int-e> in full glory: a . b $ c d e = (a . b) $ ((c d) e) = ((a . b) . (c d)) $ e = (a . (b . (c d))) $ e = a . b . c d $ e
06:21:07 <zincy> I am gonna try again :)
06:21:17 <zincy> placeBet :: Int -> Player -> Player :: placeBet value = (chips -~ value) . (bet +~ value) . (committed +~ value) . (playerState %~ (^. ) )
06:21:58 <zincy> How do I set a value for playerState based on the logical condition of the value being equal to the chhips field
06:27:36 <patlv> hi all, is it possible to have a literal in a data type, just like a #define in a struct in C?
06:28:07 <litb> "#define in a struct" ? what does that mean
06:28:54 <dminuoso> patlv: myMagicalNumber = 7;
06:28:55 <litb> do you mean  struct Foo { int data[SIZE]; }  ?
06:30:10 <patlv> something like:
06:30:53 <patlv> struct data { u_char  whatever; #define CONST 0x0001};
06:31:31 <[exa]> do you know that there's no difference if you moved the #define out of the struct?
06:33:04 <[exa]> I guess you wanted to do something like this instead: struct data { static const TheConst = 123; };
06:34:14 <[exa]> anyway, for the original question, if you turn on the C preprocessor using the language pragma, then the answer is yes, you can literally use #define anywhere inside the data statement in haskell.
06:35:01 <patlv> yes it was a bad example, I guess what I need is a literal in a data type
06:35:28 <[exa]> hmh
06:35:37 <[exa]> like data Int = 0 | 1 | 2 | ... ?
06:35:59 <[exa]> I can't see any other place for literals there, maybe except data kinds
06:37:29 * ski idly wonders what patlv is trying to achieve
06:37:36 <patlv> I have a data type like: data IPHeader = IPHeader { ver :: Word8, tos :: Word8, RF=0X001 }, the RF here is always 0x001
06:38:17 <cocreature> why is there an RF field if it’s constant?
06:38:44 <ski> perhaps you want to always set an `RF' to `0x001', when serializing a value of this data type ?
06:38:52 <ski> (an `RF' field)
06:38:53 <LiaoTao> Because it is likely automatically serialized somewhere
06:40:18 <patlv> yes, I use the Get monad to parse an array of ByteString into this data type, but I guess, I can just set the value myself
06:40:30 <ski> perhaps you can specify serialization of `IPHeader's, by converting them to a more general format, setting the `RF' field to `0x001', and serializing that
06:41:01 <patlv> ski: right
06:41:45 <ski> (or otherwise, perhaps manually specifying the serialization of `IPHeader's ..)
06:44:15 <patlv> yes, that's what i'm gonna do, thanks!
06:45:03 * hackage dejafu 1.10.1.0 - A library for unit-testing concurrent programs.  http://hackage.haskell.org/package/dejafu-1.10.1.0 (barrucadu)
07:14:54 <rkaippully> Hi, I am exploring type level programming in Haskell. Is it possible to use arbitrary functions in type family instances?
07:15:15 <rkaippully> Here is some pseudo-haskell that gives an idea of what I am aiming for: https://lpaste.net/7339569290288300032
07:15:55 <rkaippully> Can something like this be achieved with the current state of dependent type support?
07:19:26 <halogenandtoast> If I change my LTS for stack, does anyone know how to use the "relevant" stack template, basically want to use an older yesod-postgres template
07:23:01 <rkaippully> halogenandtoast: You can use a URL or a local file path as a template name
07:23:31 <rkaippully> So a github URL to the old version should work
07:23:40 <halogenandtoast> okay I'll try that
07:27:47 <dminuoso> rkaippully: are you more interested about type programming like that in general, or do you want to have access to all haskell functions?
07:29:25 <rkaippully> I am specifically looking for String functions. So that I can derive types parameterized on them.
07:30:36 <halogenandtoast> rkaippully: thanks for the pointer
07:33:42 <dminuoso> rkaippully: The closest thing I can think of is going through '[Nat] instead of Symbol, and then writing your own families/typeclasses for that
07:35:37 <dminuoso> rkaippully: Its possible TH might be an easier fit at this time *shrugs*
07:39:42 <rkaippully> dminuoso: Thanks. Unfortunately the stuff I am working on are URIs. So Nat is not a good fit.
07:39:53 <rkaippully> You are right TH might be a better choice.
07:40:24 <rkaippully> I have some other ideas as well, let me explore.
07:40:53 <dminuoso> rkaippully: What exactly is the use case here?
07:42:57 <rkaippully> I have a URI like this "/users/:userid". I am trying to represent that as a type - say `data URI (path :: Symbol)`
07:43:19 <rkaippully> Now, I am trying to derive the path parameters from it via a type family.
07:43:56 <dminuoso> rkaippully: You should check out servant.
07:44:09 <dminuoso> rkaippully: They do exactly that kind of thing but they glue things together with type operators.
07:44:20 <rkaippully> Yes, I know. Servant solves it via the :> combinator
07:44:38 <rkaippully> I am trying to see if there is a less verbose choice.
07:44:43 <dminuoso> Ah I see
07:46:00 * hackage gdp 0.0.0.1 - Reason about invariants and preconditions with ghosts of departed proofs.  http://hackage.haskell.org/package/gdp-0.0.0.1 (mnoonan)
07:47:29 <rkaippully> If I could use arbitrary string functions (or equivalent of that), I can split "/users/:userid" into its components and derive a `Param "userid"` type from it.
07:48:20 <dminuoso> rkaippully: In a more general setting servant types describe far more though, because they also describe the body, content types, verbs.
07:48:31 <dminuoso> rkaippully: But it would be interesting nevertheless. :)
07:51:21 <rkaippully> Yes that's true. I guess I
07:51:46 <rkaippully> Yes that's true. I guess I'll stick to servant like combinators for now
07:51:59 <rkaippully> dminuoso: Thanks for your help.
08:11:04 <Joestar79> hello everyone
08:11:37 <Joestar79> how do I print each intermediate step of a fold in Haskell?
08:12:00 <Joestar79> tried with Debug.trace, but can't figure out how to
08:15:14 <Ariakenom> Joestar79: Did you put trace with your "combining" function?
08:15:17 <cocreature> Joestar79: can you show us the code that you used?
08:15:37 <hpc> :t scanl
08:15:38 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
08:15:49 <cocreature> there is also ghci’s debugger which might be relevant https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#tracing-and-history
08:15:51 <hpc> > scanr (+) 0 [1, 2, 3, 4, 5]
08:15:53 <lambdabot>  [15,14,12,9,5,0]
08:15:59 <hpc> er
08:16:05 <hpc> > scanl (+) 0 [1, 2, 3, 4, 5]
08:16:07 <lambdabot>  [0,1,3,6,10,15]
08:16:23 <hpc> Joestar79: probably need to flip the list a bit?
08:17:49 <Joestar79> here's the function: dec2int = foldl ((+) . (*10)) 0
08:18:41 <Joestar79> forgot the signature, sorry guys: dec2int :: [Int] -> Int
08:18:55 <hpc> > scanl ((+) . (*10)) 0 [1, 2, 3, 4, 5]
08:18:58 <lambdabot>  [0,1,12,123,1234,12345]
08:19:41 <Joestar79> can't it be done using just trace and foldl?
08:19:54 <hpc> probably, however
08:20:10 <hpc> trace output is triggered by evaluation
08:20:29 <hpc> so you have to hang the output off of the correct thunk
08:20:50 <hpc> scanl has the advantage as well of putting every intermediate step into a haskell value
08:21:52 <hpc> you may also need to use foldl' to make sure it's even printed in the right order
08:24:17 <Joestar79> I really wanted to print the whole process, and show the steps of multiplication and addition
08:25:24 <cocreature> Joestar79: where have you tried inserting "trace"?
08:30:51 <Joestar79> concreature: inside the function argument
08:31:20 <cocreature> Joestar79: you’ll have to be a bit more precise if you want us to spot the mistake (also you misspelled my nick :))
08:31:33 <cocreature> Joestar79: foldl' (\acc x -> traceShow acc (x + acc * 10)) 0 [1,2,3] works for me
08:33:31 <Joestar79> cocreature: sorry about mispelling your nick.. had too much trust in my fingertips, but should've used copy&paste :D
08:33:47 <cocreature> get yourself an irc client that can tab-complete nicks :)
08:34:16 <rotaerk> the creature that cons
08:34:17 <Joestar79> cocreature: thanks for writing that out I kept trying without using the right syntax. Now I can see my mistake
08:36:04 <Joestar79> can I trace/traceShow more than one variable at a time?
08:36:31 <cocreature> just traceShow a tuple
08:42:50 <Joestar79> cocreature: thx man
08:45:24 <cocreature> Joestar79: yw :)
08:48:17 <dmwit> Also you can `traceShow x . traceShow y $ z`.
09:05:09 <xcmw> I have a data types that is a Profunctor and is Arrowish. Does it exist in any library? It does not fit the arrow typeclass. Is there a type class like arrow that it does fit? https://lpaste.net/5986876066331885568
09:05:52 <xcmw> It is a mealy machine that does not always output a value
09:06:36 <xcmw> It would fit arrow if Pair was replaced with These
09:07:10 <maerwald> anyone good with mtl? https://lpaste.net/2402993816534515712
09:07:39 <maerwald> the same thing with MonadError works
09:14:58 * geekosaur wonders if this is because "s" is declared as being completely unknown
09:15:06 <maerwald> I tried with String too
09:15:09 <[exa]> maerwald: perhaps you somehow didn't import the instance for ReaderT?
09:15:56 <[exa]> although that would be pretty hard to do
09:16:45 <maerwald> uff
09:16:58 <maerwald> I have a local ReaderT defined xD
09:17:04 <maerwald> how stupid
09:18:27 <[exa]> :]
09:18:30 * hackage HNumeric 0.5.0.0 - Haskell Numeric Library with pure functionality, R & MATLAB Syntax.  http://hackage.haskell.org/package/HNumeric-0.5.0.0 (edeftg)
09:38:00 <xcmw> I have a data types that is a Profunctor and is Arrowish. Does it exist in any library? It does not fit the arrow typeclass. Is there a typeclass like arrow that it does fit? https://lpaste.net/5986876066331885568
09:40:02 <cocreature> xcmw: why does it not fit Arrow? I think I’m missing something here
09:43:05 <xcmw> cocreature: Because combining `MealyMaybe a1 b1` with `MealyMaybe a2 b2` gives `MealyMaybe (These a1 a2) (These b1 b2)` instead of `MealyMaybe (Pair a1 a2) (Pair b1 b2)`
09:44:16 <cocreature> ah I see
09:45:57 <cocreature> xcmw: you can probably still make a lawful Arrow instance that outputs nothing if either of the input arrows outputs nothing, right?
09:46:22 <cocreature> so the problem is not so much that you can’t implement Arrow but that you have an additional operation that’s not expressible by Arrow
09:47:04 <xcmw> cocreature: Yes but I do not see why that implementation would be useful
09:47:56 <cocreature> fair enough, anyway I haven’t seen a typeclass that captures your composition operator
09:53:30 * hackage relational-record 0.2.2.0 - Meta package of Relational Record  http://hackage.haskell.org/package/relational-record-0.2.2.0 (KeiHibino)
10:07:00 * hackage IPv6Addr 1.0.4 - Library to deal with IPv6 address text representations.  http://hackage.haskell.org/package/IPv6Addr-1.0.4 (MichelBoucey)
10:18:56 <River> Hi everyone! I need a little help with a small function. I have a function defined like this: """obtainWordList fp = return . lines =<< readFile fp""", which has as signature """FilePath -> IO [String]""", and I would like to simplify it a little bit by removing the "fp" at the end of the definition (and of course from the arguments), but when I remove it I get """Expected type: FilePath -> IO [String], actual type: FilePath -> [Strin
10:22:37 <xcmw> River: obtainWordList = (lines `fmap`) . readFile
10:22:48 <cocreature> River: the problem is that (return . lines =<< readFile) fp is not the same as return . lines =<< readFile fp
10:22:53 <xcmw> I generated that with pointfree.io
10:23:11 <xcmw> So I think it will work but I have not tested it
10:23:27 <cocreature> just "fmap lines . readFile" is more readable imho
10:23:59 <xcmw> Yes
10:31:47 <kuribas> pointfree isn't always better
10:32:15 <kuribas> often an argument makes things more readable
10:34:08 <iron_houzi> Can someone please help me with me trying to use parser monads? I'm trying to follow: http://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf, and on page 9 it says that one should change the Parser def from a type alias to a data type, but I have no clue as to how to do this. So far I have the following: https://github.com/ironhouzi/hstib/blob/tib_monad/src/Main.hs#L279-L288
10:34:51 <cocreature> iron_houzi: that looks like Parser is already a data type
10:35:19 <cocreature> ah are you asking about how you can fix the rest of the code now that you’ve changed it to a datatype?
10:35:22 <iron_houzi> cocreature: Above it you see the commented out type alias that used to work without the Monad
10:35:28 <River> great! concreature and xcmw, thanks a lot for the help
10:35:30 <iron_houzi> cocreature: Yeah
10:35:34 <River> have a nice day
10:36:08 <cocreature> iron_houzi: so if you substitute m = Parser in the type signature you see that result has to be of type "a -> Parser a"
10:36:35 <cocreature> \inp -> [(v, inp)] is of type [Letter] -> [(a, [Letter])] so this will produce an error
10:37:00 <cocreature> however, you have a function of type ([Letter] -> [(a, [Letter])] -> Parser a in your code. do you know which function that is?
10:38:01 <iron_houzi> From what I understand, the function ([Letter] -> [(a, [Letter])]) is the parser
10:38:19 <iron_houzi> You can see in the document I'm trying to follow
10:39:05 <cocreature> what I am asking for is a function "f :: ([Letter] -> [(a, [Letter])] -> Parser a". once you have found what "f" is you can fix your code by changing the definition of result to "result v = f (\inp -> [(v, inp)])"
10:39:40 <iron_houzi> It tries to teach parser monads in a way where the Parser is first defined without using Monads, then switch to Monads to teach the reader how the Monad works .. but the switch isn't 100% described in terms of implementation unfortunately
10:40:21 <iron_houzi> s/It/The document/
10:41:21 <iron_houzi> cocreature: I'll try to let your comment marinate a bit ..
10:41:30 <iron_houzi> cocreature: Thanks for you help
10:42:12 <iron_houzi> cocreature: To me it's just weird that the type alias didn't need this function you're talking about..
10:42:32 <iron_houzi> Why is that suddenly needed?
10:42:58 <cocreature> iron_houzi: a type alias doesn’t create a new type. it just creates an “alias” i.e. a new name for an existing type
10:43:29 <cocreature> a "data" declaration creates a newtype so you’ll have to do some plumbing to create and consume values of this new type
10:43:30 * hackage relational-query 0.11.2.0 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.11.2.0 (KeiHibino)
10:45:32 <iron_houzi> OK, I get that String is a type alias for [Char] ... and how `Parser a` is a type alias for `[Letter] -> [(a, [Letter])` .. but this doesn't translate to defining a data type..
10:46:49 <cocreature> a data type is a completely separate type. you can _only_ construct values of that type by using the constructors defined in the data declaration and you consume values of that new type by pattern matching on the constructors
10:47:21 <cocreature> if you define "type X = Int" then you can use any value "x :: Int" as a value "x :: X"
10:47:40 <cocreature> if you define "data X = MakeX Int" then you need to use the MakeX constructor
10:57:32 <iron_houzi> cocreature: You asked me if I knew what function I had with the type ([Letter] -> [(a, [Letter])] -> Parser a), isn't this the function `result`? which used to be a function, but now I'm trying to convert to an instance ..
10:59:55 <iron_houzi> cocreature: Here's the initial version without the Monad and data type: https://github.com/ironhouzi/hstib/blob/typing/src/Main.hs
11:02:39 <cocreature> iron_houzi: no, I mean a function that works for your new Parser type, not for the type synonym
11:03:46 <cocreature> iron_houzi: hint: the name of the function starts with a capital letter :)
11:04:30 <iron_houzi> cocreature: I don't understand. I am utterly confused and you seem to have an answer you don't want to share with me..
11:05:26 <cocreature> iron_houzi: I don’t want to ruin the fun and the joy of figuring out the answer yourself :) if you want me to just tell you the answer I can do so but ime that’s significantly less helpful than figuring things out yourself (with some hints)
11:06:59 <iron_houzi> cocreature: Dude! I've been trying for days before asking this question here .. I would *love* to just get the answer and figure out the understanding from there.. the eureka moments will come anyways
11:07:32 <cocreature> iron_houzi: alright, "result v = Parser (\inp -> [(v, inp)])" should work
11:09:47 <iron_houzi> cocreature: Thank you *so* much! To me it seems like I left out the data type constructor in the result definition
11:10:34 <cocreature> iron_houzi: if you run ":t Parser" in ghci you’ll see that it has exactly the type "([Letter] -> [(a, [Letter])] -> Parser a" that I’ve told you to look for
11:11:16 <cocreature> iron_houzi: to avoid confusion it might also make sense to rename the constructor so that the type and the constructor don’t have the same name
11:11:24 <cocreature> e.g. "data Parser a = MkParser …"
11:13:13 <iron_houzi> cocreature: Thanks! I'll have a new chance to work this understanding into implementing the instance for `bind`
11:18:35 <ZeuPiark> hello
11:34:24 <iron_houzi> Why does `:t concat` return Foldable t => t [a] -> [a], when it should be [[a]] -> [a] ?
11:35:15 <geekosaur> because it's been generalized
11:35:21 <geekosaur> % :t concat @[]
11:35:22 <yahb> geekosaur: [[a]] -> [a]
11:35:34 <hpc> iron_houzi: it's a recent change
11:35:44 <hpc> (relatively speaking)
11:35:56 <iron_houzi> Wow, correctness can be so confusing to a beginner :)
11:36:18 <iron_houzi> geekosaur: Thank you
11:36:24 <geekosaur> basically, instead of being specific to lists, it can now be used on anything which is "list-like" in some fashion, expressed by the "Foldable" constraint
11:36:58 <geekosaur> (Foldable is actually more general than just things that look like lists, though.)
11:38:46 <srk> cooking a network-status library https://lpaste.net/5408154408884109312
12:17:30 * hackage safe-buffer-monad 0.1.0 - A monadic buffer resilient to exceptions  http://hackage.haskell.org/package/safe-buffer-monad-0.1.0 (dcastro)
12:20:51 <Estracult> Hey
12:24:39 <Estracult> Is anyone online?
12:26:19 <glguy> There are always people around, there are over 1700 users idling right now
12:26:20 <cocreature> Estracult: just ask your question :)
12:36:49 <mrm> Well, I'm not online.
12:43:02 <Jello_Raptor__> Im thinking of making a higher order lattice/partial-order typeclass in the style of Ord1 or Traversable1 but I vaguely remember that there's alternate design patterns that let you express that `Foo1 f = forall a. (Foo a) implies (Foo (f a))` construct.
12:43:36 <Jello_Raptor__> Some of my interfaces require a `Foo1 f` constraint because my backend instantiates f with a whole bunch of different parameters that should be hidden from the user.
12:45:51 <dmwit> You may be thinking of this library:
12:45:53 <dmwit> ?hackage constraints
12:45:53 <lambdabot> http://hackage.haskell.org/package/constraints
12:47:06 <dmwit> Personally I prefer the *1 pattern, when that's sufficient. Fewer fancy extensions.
13:00:25 <rihards> hey, i'm a bit confused by typeclasses, like Functor, which can appear as :: Functor f => f a -> ... in type signatures. what's the thing in the typeclass definition that sets apart Functor, Applicative, Monad and others from, say, Num and Eq?
13:00:46 <infinisil> rihards: Check :k in ghci of each of those
13:00:51 <infinisil> That's the kind
13:00:52 <rihards> that is, why is it that i can write :: Functor f => f a -> ... and not Num n => n a -> ...
13:02:22 <rihards> oh, i'll have some reading to do. thanks
13:02:29 <cocreature> % :k Num
13:02:30 <yahb> cocreature: Num :: * -> Constraint
13:02:33 <cocreature> % :k Functor
13:02:34 <yahb> cocreature: Functor :: (* -> *) -> Constraint
13:03:10 <infinisil> rihards: Oh and https://stackoverflow.com/questions/27095011/what-exactly-is-the-kind-in-haskell
13:05:30 <maerwald> any good hlint linter rule sets?
13:06:04 * dmwit sticks his tongue into his cheek
13:06:09 <dmwit> I use the empty set every time I program.
13:10:15 <rihards> it's weird that kinds have never come up (at least for me) when going through writings explaining functors and applicatives and such. i guess this has been hampering my ability to understand type signatures involving them for a while now
13:11:21 <c_wraith> rihards: in some sense, they're an entirely emergent property, and not part of the Haskell spec.
13:12:07 <c_wraith> rihards: I think that's why a lot of resources neglect them
13:13:53 <glguy> The Haskell Report defines kinds, which part were you thinking was outside the spec?
13:14:21 <maerwald> that would be a pretty significant GHCism
13:14:22 <c_wraith> Is that something added for 2010?
13:14:33 <glguy> No, kinds were described in 98, too
13:14:48 <glguy> There just isn't a syntax for writing them in your code, but they are covered in the report
13:16:08 <__monty__> Also, before datakinds, kinds didn't really matter to 99% of cases, so why bother treating them?
13:16:09 <c_wraith> maerwald: well, even if I was correct (which it seems I wasn't), it's still an emergent property of the type system.
13:16:26 <glguy> __monty__: No, kinds stil matter lots without data kinds
13:17:04 <__monty__> glguy: But there was only 2 and even now I don't see # cropping up anywhere. It's all about *.
13:17:15 <glguy> It's about * and kinds formed with ->
13:17:18 <c_wraith> __monty__: no, there's also (->)
13:17:29 <__monty__> Ah, right.
13:17:36 <__monty__> My bad.
13:17:45 <c_wraith> Java only has *.  :)
13:19:04 <int-e> ah the good old times where kinds were easy: *, #, (#), ? and ??
13:19:34 <c_wraith> technically, that whole mess still exists in ghc, it's just hidden behind an extension now
13:19:54 <c_wraith> And it's also a lot more principled now.
13:22:22 <Xal> I'm having a bit of  hard time writing a polymorphic Stream instance for megaparsec: https://lpaste.net/7678566871368466432
13:22:59 <mniip> int-e, yeah but now there's * :: *
13:23:01 <Xal> I want to be able to wrap around a regular Stream and tag some information on it, but I can't quite figure out how to get it to typecheck
13:23:51 <mniip> or more specifically TYPE :: TypeRep -> TYPE LiftedRep
13:25:29 <int-e> mniip: yes, horrible :P
13:25:48 <mniip> the funny thing about * :: * is that when you look at it you only see * :: *
13:25:53 <mniip> but there's also the fact that * :: *
13:26:55 <c_wraith> Xal: do you have ScopedTypeVariables enabled?
13:27:10 <mniip> that means that '*' is itself a type!
13:27:21 <mniip> % :k Maybe *
13:27:21 <yahb> mniip: Maybe * :: *
13:27:57 <c_wraith> Xal: without ScopedTypeVariables, the s on line 7 is a *different* s than on line 4
13:28:00 <mniip> which, hmm, to think of it
13:28:03 <c_wraith> Xal: and that's what the compiler is complaining about
13:28:31 <glguy> mniip: Just Int :: Maybe *
13:28:39 <glguy> Just Just :: Maybe (a -> Maybe a)
13:29:30 <c_wraith> Xal: or maybe you just want to pass prx instead of creating a new proxy?  (I can't tell, I'm not looking at the megaparsec docs)
13:29:53 <Xal> c_wraith: that's the error with it enabled
13:30:04 <Xal> I need to pass it a new proxy for the stream it wraps around
13:31:19 <c_wraith> Xal: oh, should you be using one of the type families there?  (Proxy :: Proxy (Token s)), maybe?
13:31:40 <mniip> glguy, Just Int is not a term though
13:31:42 <__monty__> int-e: Are those haskell report kinds or are they ghc specific? I can't find the kind definitions in the haskell report.
13:31:44 <c_wraith> Xal: that one appears it would make the compiler happy, but I'm not sure it would work correctly
13:34:20 <int-e> __monty__: that's all ghc. # is for unboxed values, (#) is for unboxed tuples, and ? and ?? are ad-hoc combinations of these just for (->) :: ? -> ?? -> *  (so ? is * or #; ?? is * or # or (#)). It's of little significance.
13:34:55 <glguy> mniip: Data.Maybe.isNothing (Nothing :: Maybe *) --- True
13:35:45 <int-e> __monty__: the ? and ?? used to creep into the occasional type error, so it was useful to know about them once upon a time.
13:35:55 <__monty__> int-e: Ah, thanks. So the only haskell report kinds are * and combinations with ->?
13:36:03 <int-e> __monty__: yes
13:37:23 <geekosaur> hm. does h2010 even have types, aside from a background concept?
13:37:27 <geekosaur> er, kinds
13:37:31 <glguy> Yes
13:39:14 <Xal> c_wraith: while it pains me to do this, I think I'm just going to monomorphize it for now to get it working
13:39:27 <Xal> I'll come back later to figure out how to do it right
13:42:54 <Xal> c_wraith: it's an even stranger error when I try to implement it without the proxy: https://lpaste.net/3543512151375216640
13:43:08 <Xal> it's expecting a Token (SStream s) but getting a Token s
13:43:21 <Xal> which should be the same thing due to the line `type Token (SStream s) = Token s`
13:44:13 <glguy> Xal: SStream s  doesn't appear to equal  s
13:44:59 <glguy> (and since it doesn't, the types don't match
13:47:20 <Xal> while s /= SStream s, Token s should equal Token (SStream s), no?
13:47:37 <glguy> You stopped reading too soon
13:47:47 <glguy> it's the second component of the pair that doesn't match
13:49:24 <mreh> could I implement backtracking with STT []?
13:49:46 <mreh> (and restoring my state)
13:49:47 <Xal> glguy: this is what happens when you stare at ghc error message for too long, thank you!
13:53:38 <jbetz> Is there any overlap between problems solved by dependent types and row polymorphism? I've been reading about purescript and all its row type magic and while yes, it seems useful, I wonder if there are better solutions to the record problem, and if records *themselves* are the problem. E.g., if there are better data structures that would enable Haskell programming to not rely on records so heavily.
13:54:00 <maerwald> haven't they given up on row types recently?
13:55:29 <suppi> nope. just on granulated Eff
13:55:38 <maerwald> ah right
13:55:53 <suppi> which is still available as a library i think?
13:56:30 <jbetz> maerwald: they dropped the row type in the Eff monax, but otherwise no. row type programming is all the rage in purescript.
13:59:32 <jbetz> suppi: yeah, the ecosystem is still migrating to the new rowless Effect monad
14:00:55 <maerwald> is that better?
14:08:43 <suppi> it's basically IO I think?
14:08:55 <jbetz> Pretty much
14:09:21 <suppi> i think they just didn't feel they get much value out of granulated Eff and it was too much of a hassle
14:09:27 <jbetz> And yes it's better, but not really a good instance to judge row types by
14:14:39 <jbetz> If that's what you meant
14:15:52 <jbetz> I'm really just curious what the possiblity space is, and where row types fit into it, and what the big picture problem actually IS
14:17:56 <merijn> jbetz: I would say rowtypes are the answer to "I want ducktyping, but, you know, statically"
14:18:43 <merijn> jbetz: So they capture a design space that is commonly tackled with either dynamic types or inheritance, while avoiding the downsides/flaws in those
14:18:44 <dminuoso> merijn: Isn't that subtyping?
14:19:09 <merijn> dminuoso: Yes, no, maybe.
14:19:10 <dminuoso> (Especially structural subtyping)
14:19:22 <merijn> Depends on your definition of subtyping ;)
14:19:45 <merijn> But yeah, rowtypes were invented to be "structural subtyping, except not sucky"
14:21:01 <Eduard_Munteanu> Doesn't Typescript have something like that as well?
14:22:21 <Eduard_Munteanu> It maps reasonably well to JS.
14:26:09 <xcmw> Is there some generalization of Strong and Choice that allows you to pass an arbitrary bifunctor (* -> * -> *)?
14:26:53 <dminuoso> xcmw: What do you mean by "pass"
14:27:25 <xcmw> I have a data type that is strong with respect to These.
14:28:30 * hackage numhask-test 0.1.0.0 - Laws and tests for numhask  http://hackage.haskell.org/package/numhask-test-0.1.0.0 (tonyday567)
14:29:01 <xcmw> dminuoso: I mean take a bifunctor and a profunctor as an argument and make sure that the profunctor is strong with respect to the bifunctor
14:29:33 <xcmw> I don't fully understand what I am doing
14:41:09 <jbetz> merijn: static duck typing, nice :)
14:42:18 <joncfoo> I'm using RIO along with Yesod and noticed that RIO's logging functions end up blocking the whole program.  Anyone run into something similar before?
14:42:30 <jbetz> That clarifies a lot, and explains why it doesn't feel like Haskell yet doesn't feel wrong either.   Just slightly off.
14:52:27 <jbetz> dminuoso: https://brianmckenna.org/blog/row_polymorphism_isnt_subtyping <-- this makes a good case for row polymorphism /= subtyping
15:18:40 <Mrd1> Y
15:19:39 <Mrd1> hey where else?hey where else
15:23:10 <phadej> xcmw: can't you express These-strenght as a composition of Strong/Choice classes?
15:24:03 <xcmw> phadej: Maybe
15:24:12 <phadej> These a b ~ Either a (Just a, b)
15:24:25 <phadej> s/Just/Maybe/
15:24:50 <xcmw> I will try it
15:24:59 <dminuoso> Is there some good resource to understand MonadBaseControl and how to use it *correctly*?
15:25:19 <phadej> use as define instance, or use instances?
15:25:30 <phadej> use /existing/ instances
15:25:30 <Mrd1> Yeah..
15:25:53 <dminuoso> phadej: define instances
15:26:29 <phadej> I just copy&paste the existing instances
15:26:45 <Mrd1> Hahah
15:26:55 <phadej> (I mean, if i have something looking like reader, i just copy Reader instance and change the names)
15:26:56 <glguy> Mrd1: Did you have any questions about Haskell?
15:27:25 <Mrd1> Emmm
15:27:33 <Mrd1> Nothing
15:28:26 <glguy> Mrd1: OK, this channel is for discussing Haskell. You're welcome to come and chat if you end up having Haskell questions.
15:29:35 <Mrd1> Glguy: I just browsed
15:31:16 <Mrd1> Glguy: chanel may be useful here
15:33:32 <Mrd1> what is haskell?
15:34:05 <kvda> Mr. Haskell
15:34:11 <kvda> This is a fan club
15:34:22 <Mrd1> Ohhh
15:34:24 <glguy> Mrd1: You can start with a page like https://wiki.haskell.org/Introduction and then bring back your questions about what you read
15:35:09 <kvda> Mrd1 https://en.wikipedia.org/wiki/Haskell_Curry
15:35:26 <Mrd1> Ok thank
15:35:45 <maerwald> he can just look at the topic
15:35:53 <xcmw> Haskell is a programming language
15:36:22 <Mrd1> Is it true
15:36:30 <xcmw> Is what true?
15:36:50 <Mrd1> Haskell is aprogramming
15:37:12 <xcmw> Yes Haskell is a programming language
15:37:17 <maerwald> please read the channel topic
15:38:00 <Mrd1> what it looks like
15:38:35 <xcmw> Go to https://www.haskell.org and do the try it thing
15:39:07 <Mrd1> I like programming language and I want to be programmer.....
15:39:19 <maerwald> I want to be a rockstar
15:39:40 <lambdabot> I want to be a firetruck.
15:40:04 <rotaerk> you go be that, then, lambdabot
15:40:34 <maerwald> rotaerk: he cannot walk, has no IO! :>
15:40:43 <rotaerk> heh
15:42:07 <Mrd1> Codyrutscher: wellcome
15:42:21 <codyrutscher> can i ask a question
15:42:30 <Mrd1> Sure
15:42:53 <codyrutscher> i wasn't recently rootkitted
15:42:55 <codyrutscher> very shitty
15:43:05 <rotaerk> I wasn't either
15:43:06 <glguy> codyrutscher: This channel is for talking about Haskell specifically
15:43:16 <codyrutscher> got it
15:44:05 <maerwald> does haskell have rootkits? :>
15:44:45 <glguy> You could probably publish if you made one and overcame getting the RTS inside
15:45:54 <glguy> Just speculating, though. I don't know that much about the implementation challenges involved :)
15:46:12 <maerwald> next question would be: how do I become a rootkit programmer xD
15:47:51 <maerwald> you probably need monads for that, I guess
16:29:00 * hackage numhask-histogram 0.1.3.0, numhask-range 0.2.3.1 (tonyday567): https://qbin.io/sink-park-mxbz
16:47:30 * hackage aeson-filthy 0.1.2 - Several newtypes and combinators for dealing with less-than-cleanly JSON input.  http://hackage.haskell.org/package/aeson-filthy-0.1.2 (AlecHeller)
16:53:11 <infinisil> Hey, is there something nice and tight for `\x -> do { f x; g; }`?
16:53:36 <jackdk> `\x -> f x *> g`?
16:53:55 <jackdk> `(*>)` from Control.Applicative
16:53:58 <infinisil> Without the lambda I'm hoping
16:54:51 <xcmw> (*> g) . f
16:54:54 <glguy> infinisil:  It would seem pretty silly to give that a special name
16:55:28 <infinisil> xcmw: Oh nice!
16:55:43 <xcmw> pointfree.io generated that
16:55:53 <infinisil> Ah right
16:56:02 <infinisil> @pl \x -> f x *> g
16:56:02 <lambdabot> (*> g) . f
16:56:16 <glguy> Stuff you have to use ?pl to get generally isn't suitable for putting into actual source files
16:56:35 <infinisil> Eh, I think this isn't too bad
16:57:14 <hpc> :t \x -> do { f x; g; }
16:57:15 <lambdabot> (FromExpr (m a), FromExpr (m b), Show t, Monad m) => t -> m b
17:22:08 <Mrd1> Hello
17:23:29 <Mrd1> Wellcome
17:54:18 <tabemann> I don't know what's wrong with my code here: https://lpaste.net/5268645053542170624 (why can't I make instances like that?)
17:55:58 <Cale> tabemann: The second instance makes sense.
17:55:59 <geekosaur> because it can't resolve contexts like that at runtime, and what you compile now may be linked into another program a year later
17:56:13 <Cale> The first would apply to any type application where you're applying a type to ()
17:56:16 <geekosaur> all it can use is the type, and a overlaps with IO
17:56:50 <Squarism> Is there some lib that let me list all timezones?
17:57:19 <Cale> http://hackage.haskell.org/package/timezone-olson might be useful
17:57:39 <tabemann> Cale: what I want is one case for all types of kind * -> * that have MonadIO instances, and then one for IO
17:58:07 <geekosaur> tabemann, that is what you cannot have because it can only check MonadIO after picking the type/instance to use
17:58:11 <Cale> tabemann: The thing is, the algorithm which selects which instance to use isn't allowed to look at the type class constraints on the instances
17:58:26 <geekosaur> other code *cannot know* what instances exist.
17:58:37 <Cale> (for a good reason -- it might not know about all the instances which will be specified in future modules)
17:59:06 <tabemann> the thing is I swear I've seen instance definitions that include stuff like MonadIO a =>
17:59:07 <Cale> So, if it picked the a () instance under the assumption that there was no more specific instance available, that might immediately become untrue in the next module
17:59:07 <Squarism> Cale, that require me to point out these "olson" files? I thought this was a standard OS function so that I wasnt required to do such tricks.
17:59:18 <geekosaur> tabemann, you have. they are checked afterward.
17:59:30 * hackage th-abstraction 0.2.7.0 - Nicer interface for reified information about data types  http://hackage.haskell.org/package/th-abstraction-0.2.7.0 (ryanglscott)
17:59:30 <Cale> Squarism: Yeah, I don't know, that's what we do where I work.
17:59:33 <geekosaur> Squarism, on unixlike systems this is tzinfo
17:59:58 <Squarism> Cale, ok good to know. thanks
18:00:09 <tabemann> so, how would I fix my instances, if there is any good way to do this?
18:00:30 <Cale> tabemann: Make instances of LogContext for each monad you want it for
18:01:07 <tabemann> yeah, because there is a specific monad I have in mind, but it didn't feel right making an instance just for it when there is an obvious more general case
18:01:34 <Cale> You can, using DefaultSignatures, put the implementation you have there into the class declaration
18:01:34 <tabemann> e.g. it really doesn't matter that it's that monad, but rather that that monad has a MonadIO instance that matters
18:01:46 <Cale> and then you can just write
18:01:51 <Cale> instance LogContext MyMonad
18:02:03 <Cale> whenever you have  MonadIO MyMonad
18:02:35 <dmwit> tabemann: Why do you even have a class for this?
18:02:50 <Cale> Also, yeah, why is logMessage's type not more specified?
18:03:05 <dmwit> `logMessage string = when logActive (liftIO (putStr string))` works for any `MonadIO`, including `IO` itself.
18:03:06 <Cale> It seems like it should always be String -> m () at least
18:03:07 <tabemann> dmwit: because I didn't feel like having two different functions used in different parts of my program
18:03:21 <dmwit> tabemann: It's not even two different functions, lol. `liftIO = id` for `IO`.
18:03:30 <Cale> tabemann: You know that IO is an instance of MonadIO too, right?
18:03:30 <dmwit> It's the same function.
18:03:33 <tabemann> okay, now I feel stupid
18:04:05 <Cale> I assumed there would be some other monads where you wanted to implement logMessage differently
18:04:08 * tabemann honestly didn't know that IO had a MonadIO instance
18:04:47 <tabemann> Cale: there is another monad I might use with it, but it also has a MonadIO instance
18:05:03 <geekosaur> it'd be kinda silly if it didn't, especially when it's such a trivial instance
18:05:38 <dmwit> It would be silly and also difficult to make work. IO is the base case of a recursion. Without it, every instance would have to double up on whether it was "one layer" over IO or many.
18:06:30 <tabemann> now I feel extra stupid, and rightly so, and will remove my needless use of a type class for this
18:06:37 <dmwit> e.g. you would need both `instance MonadIO (ReaderT r IO)` and `instance (MonadIO m, IsNotIO m) => MonadIO (ReaderT r m)`... which runs into exactly the same kinds of problems you're running into with this.
18:07:37 <dmwit> (...you would need them both because they would have different implementations of `liftIO`, the former being `lift` and the latter being `lift . liftIO`.)
18:11:11 <tabemann> I don't know why I didn't just assume that IO had a MonadIO instance, and why I didn't check to confirm whether IO has a MonadIO instance
18:11:29 <tabemann> because in second thought, as you state, it's obvious that IO should have a MonadIO instance
18:14:42 <tabemann> I don't know why i spent the last week or so hacking on an actor library in Haskell when there's already Cloud Haskell
18:15:31 <Mrd2> Hello
18:15:36 <tabemann> hey
18:15:53 <Mrd2> ......
18:16:02 <Mrd2> Hey
18:17:21 <tabemann> (well, it's probably way lighter-weight than Cloud Haskell, but at the same time probably doesn't handle nearly many edge cases or scale nearly as well)
18:17:42 <tabemann> (it currently doesn't really handle nodes dropping out well right now)
18:18:36 <tabemann> (well, it's okay if a node just dies - but it doesn't handle it as well if some links between nodes are lost but not others)
18:27:13 <tabemann> (it doesn't scale well either, because it relies on point-to-point links between nodes, so the number of connections scales with n^2
18:28:30 <Cale> tabemann: Yeah, I highly recommend watching the talks by Duncan Coutts about Cloud Haskell, they're great
18:29:10 <Cale> https://skillsmatter.com/skillscasts/3523-cloud-haskell -- annoying that you have to log in to watch this one, but at least it's free
18:29:16 <Cale> https://www.youtube.com/watch?v=1jJ2paFuErM
18:30:13 <Mrd2> Hey...
18:31:39 <tabemann> what's up, Mrd2?
18:36:04 <tabemann> why is the Youtube video so quiet
18:36:31 <monochrom> No, I heard a loud cough right at the beginning :)
18:36:40 <tabemann> it's not the audio on my machine, since it's fine when I try to use Spotify
18:37:10 <tabemann> and I set the volume to be the same for Firefox and for Spotify
18:38:36 <monochrom> It is not quiet for me. I can hear the speech.
18:38:41 <tabemann> hmm
18:40:14 <tabemann> I restarted the video, and heard the cough, and little else
18:40:47 <monochrom> Hmm, after a million restarts you will hear the whole thing :)
18:41:11 <Chenlong> Woow
18:41:39 <tabemann> I think my implementation is in some ways more complex API-wise than the core of CH, because I have the concept of "groups", where you can send a single message to any number of listening processes, or you can listen for the death of any number of processes
18:43:04 <tabemann> at the same time my actor library specifies a very basic wire format for messages; basically one bytestring for a header and one bytestring for a body, with the idea that the header will be decoded and used to determine what type to decode the body with
18:43:37 <tabemann> that said, it doesn't have typed channels
18:44:39 <tabemann> it is basically up to the user to do the encoding and decoding of data
18:50:35 <Chenlong> Why silent
18:57:30 * hackage butter 0.1.0.3 - Monad Transformer for Asyncronous Message Passing  http://hackage.haskell.org/package/butter-0.1.0.3 (mpahrens)
18:59:00 * hackage HNumeric 0.5.0.1 - Haskell Numeric Library with pure functionality, R & MATLAB Syntax.  http://hackage.haskell.org/package/HNumeric-0.5.0.1 (edeftg)
19:04:00 * hackage gdp 0.0.0.2 - Reason about invariants and preconditions with ghosts of departed proofs.  http://hackage.haskell.org/package/gdp-0.0.0.2 (mnoonan)
19:11:30 * hackage diagrams-core 1.4.1.1 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-1.4.1.1 (BrentYorgey)
19:42:13 <Mrd1> Hey....
19:48:12 --- mode: ChanServ set +o glguy
19:48:12 --- mode: glguy set +q Mrd1!*@*
19:55:11 <systemfault> The dude is basically the IRC version of the Navi fairy from Zelda "Hey...", "listen"
20:27:30 * hackage containers 0.6.0.1 - Assorted concrete container types  http://hackage.haskell.org/package/containers-0.6.0.1 (dfeuer)
20:30:19 <glguy> Oh, updating every package's upper bounds for containers will be fun :)
20:31:13 <Axman6> Changelog: "Released with GHC 8.6"
20:31:36 <Axman6> so hopefully it is actually just version bounds
20:32:21 <glguy> I imagine most packages aren't depending on the deprecated functions that were removed in this release
20:33:05 <Axman6> oh, urgh, I managed to miss all the other stuff, my eye just saw a new heading and assumes it was the next version >_<
20:33:47 <Axman6> assumed*
20:34:16 <tabemann> upper bounds considered harmful
20:34:28 <glguy> nope
20:34:31 <Axman6> nah
20:35:29 <glguy> Perhaps changing existing APIs could be "considered harmful" but upper bounds are just the messanger
20:36:11 <monochrom> Messenger virtual particles considered harmful.  Dark matter FTW.
20:36:34 <tabemann> the reason I say that is that lower bounds alone only result in a minimum allowable version but lower bounds combined with upper bounds allow a situation where no possible version can be allowed for a given set of packages
20:37:16 <glguy> that's fine, if packages are incompatible we'll want to know
20:37:43 <glguy> and it helps to not have libraries become unusable over time just because new versions of things were released
20:37:53 <monochrom> Absence of upper bounds allows a situation where newbies get weird build errors.
20:38:42 <tabemann> what might help is to require certain major versions but only have lower bounds on minor versions
20:38:52 <tabemann> but I don't know if cabal allows that
20:39:16 <tabemann> because a major version change can be reasonable assumed to be breaking
20:39:38 <sclv> we have ^>= syntax
20:39:42 <monochrom> Have you read the PVP?
20:40:00 <tabemann> PVP?
20:40:29 <monochrom> Because the PVP already defines version numbers that indicate non-breaking fixes and version numbers that indicate breaking changes.
20:40:39 <nisstyre> How does one debug a Haskell program that is using an FFI to C, and producing segfaults? Obviously the typical use of valgrind, etc isn't going to work. Is there a better way?
20:40:52 <nisstyre> (for context, I did not write the program, I'm just trying to fix a bug in it)
20:41:04 <sclv> tabemann: http://cabal.readthedocs.io/en/latest/developing-packages.html#pkg-field-build-depends
20:41:14 <sclv> pvp: https://pvp.haskell.org/
20:41:55 <nisstyre> Or maybe I can debug it with valgrind, but I'd have to recompile with debug symbols right?
20:42:35 <sclv> nisstyre: why won't valgrind work?
20:42:44 <sclv> i've heard reports it works with haskell code decently
20:42:49 <nisstyre> sclv: no debug symbols, but I guess I'd do "-optc -g" right ?
20:43:24 <nisstyre> I'm just wondering if I'll get a whole bunch of false positives to wade through though
20:43:43 <sclv> nisstyre: compile with -debug and you get symbols
20:43:47 <nisstyre> ah ok
20:44:11 <sclv> these tips are for working with gdb but valgrind works too: https://ghc.haskell.org/trac/ghc/wiki/Debugging/CompiledCode
20:44:29 <sclv> cf also https://ghc.haskell.org/trac/ghc/ticket/3215 which reports valgrind working
20:44:30 <nisstyre> sclv: great, that link looks helpful
20:46:10 <tabemann> okay, I'm stupid in wondering whether cabal supports specifying just major version, because it obviously supports ranges of versions
20:46:26 <tabemann> the PVP was informative though
21:39:32 <cocreature> nisstyre: sclv: fwiw the flag to compile with debug info is called -g not -debug
21:40:06 <cocreature> and you need a GHC built with DWARF debugging symbols as well for this to work properly
21:41:04 <nisstyre> cocreature: thanks, I'm using stack so it shouldn't be an issue to do that
21:42:34 <cocreature> nisstyre: I don’t think the GHC builds that stack uses by default have DWARF debugging information
21:42:56 <cocreature> you might also need to disable symbol stripping to make sure the symbols end up in the final binary
21:45:26 <nisstyre> cocreature: can't I tell stack to use a specific GHC that I've built?
21:46:04 <cocreature> sure, you can set "system-ghc: true" and then put some GHC in your PATH
21:46:22 <cocreature> but if you’re just chasing a segfault, compiling your C code with debugging info is probably sufficient tbh
21:46:40 <nisstyre> ok, cool, I appreciate the info anyway
21:48:50 <mniip> DWARF in GHC is terrible anyway
21:50:15 <cocreature> it’s definitely not great but it’s still better than nothing :)
21:56:11 <mniip> I wouldn't say it's Just either :p
22:05:02 <dminuoso> Im trying to dodge a bullet (MBC) here, but Im not certain whether what Im doing is correct: https://gist.github.com/dminuoso/35b0deb3d3ec88fb2746d3816b219051 is my way of turning some `(R -> IO a) -> IO a` into `(R -> MandyT a) -> MandyT a`
22:05:19 <rotaerk> mniip, would you say it's just Either?
22:05:50 <mniip> Maybe.
22:05:54 <rotaerk> lol
22:06:31 <mniip> dminuoso, what is MandyT?
22:06:56 <dminuoso> mniip: type MandyT = ReaderT Config (ExceptT ServantErr IO)
22:07:56 <mniip> ah well, there's no nice way to do this
22:08:05 <mniip> you're lucky it works at all for your transformer
22:08:36 <dminuoso> mniip: I figured you'd say that. Im guessing if I start adding more things like a StateT into the mix things will brick?
22:08:38 <mniip> dminuoso, you could do it in two steps
22:09:10 <cocreature> even ExceptT can be tricky if you don’t pay attention (although your code looks fine)
22:09:32 <mniip> Monad m => (forall b. (a -> m b) -> m b) -> (a -> ReaderT r m b) -> ReaderT r m b
22:09:38 <mniip> and then ditto with ExceptT
22:09:47 <mniip> notice the higher rank of the type
22:10:38 <mniip> the higher rank isn't necessarily needed for ReaderT, but it is for ExceptT
22:12:11 <dminuoso> mniip: Im not entirely sure how that relates to my code. Could you give me one further hint?
22:12:30 * hackage glabrous 0.3.6 - A template DSL library  http://hackage.haskell.org/package/glabrous-0.3.6 (MichelBoucey)
22:12:55 <mniip> (I'm going to need a new word for elevation)
22:13:23 <mniip> dminuoso, "turning some `(R -> IO a) -> IO a` into `(R -> MandyT a) -> MandyT a`"
22:13:35 <mniip> that can be done in multiple steps: one for each transformer in the stack
22:19:00 * hackage postgresql-common 0.1.0.0, postgresql-common-persistent 0.1.0.0 (IanDuncan): https://qbin.io/live-skins-isch
22:21:19 <mniip> consider this
22:21:28 <mniip> @let class Heighten t where heighten :: Monad m => (forall b. (a -> m b) -> m b) -> (a -> t m b) -> t m b
22:21:29 <lambdabot>  Defined.
22:21:46 <mniip> with an example function:
22:21:50 <mniip> :t catch undefined
22:21:51 <lambdabot> Exception e => (e -> IO a) -> IO a
22:21:58 <mniip> :t heighten $ catch undefined
22:21:59 <lambdabot> forall k (t :: (* -> *) -> k -> *) a (b :: k). (Exception a, Heighten t) => (a -> t IO b) -> t IO b
22:22:04 <mniip> :t heighten $ heighten $ catch undefined
22:22:05 <lambdabot> forall k (t1 :: (* -> *) -> k -> *) (t2 :: (* -> *) -> * -> *) a (b :: k). (Exception a, Heighten t2, Monad (t2 IO), Heighten t1) => (a -> t1 (t2 IO) b) -> t1 (t2 IO) b
22:22:24 <mniip> you can implement instances:
22:22:25 <mniip> @let instance Heighten (ReaderT r) where heighten f g = ReaderT (\r -> f (\a -> runReaderT (g a) r))
22:22:26 <lambdabot>  Defined.
22:22:30 * hackage multipool 0.1.0.0, multipool-persistent-postgresql 0.1.0.0, multipool-persistent 0.1.0.0 (IanDuncan): https://qbin.io/helmet-briefs-hjrf
22:22:36 <mniip> @let instance Heighten (ExceptT e) where heighten f g = ExceptT (f (\a -> runExceptT (g a)))
22:22:37 <lambdabot>  Defined.
22:23:49 <mniip> not saying you should write out this exact class, but splitting your function into two such heighten's is a good idea
22:30:42 <dminuoso> mniip: Okay I can live with this - but ultimately I cant avoid testing whether `heigtening` that callback into a transformer stack breaks some laws/assumptions about the transformer stack, can I?
22:31:46 <geekosaur> right. there's a reason this isn't a standard function somewhere
22:31:46 <cocreature> there is a reason why unliftio deliberately restricts itself to ReaderT like things :)
22:35:09 <mniip> this is not really unliftio
22:35:16 <mniip> again, see the higher ranked type
22:35:37 <mniip> dminuoso, it's simple really
22:36:18 <mniip> if the function you're calling is of the form \f -> (a >>= f) <* b
22:36:34 <mniip> hmm maybe not that
22:37:04 <mniip> \f -> do x <- a; r <- f x; b x; return r
22:37:10 <dminuoso> mniip: In reality it will be something like: a f *> b f
22:37:12 <mniip> then it breaks no monad laws
22:37:24 <dminuoso> Mmm
22:38:05 <guessWHo> where does this forall keyword comes from and what's it's use ??
22:38:26 <mniip> otherwise, if f is "invoked" after the function "terminates", then it's going to be off, but predictably so
22:39:10 <glguy> guessWHo: It's a type variable quantifier; what it's up to depends on the situation. What are you looking at?
22:39:11 <cocreature> guessWHo: there are several different uses of forall so you will have to give a bit more context
22:39:26 <mniip> also hmmm
22:39:33 <mniip> :t ContT (catch undefined)
22:39:34 <lambdabot> Exception a => ContT r IO a
22:39:38 <mniip> !
22:40:07 <dminuoso> mniip: I dont have anything fancy really. At most I might throw an additional MaybeT into the mix.
22:40:23 <dminuoso> *perhaps* a WriterT/StateT but Im not certain about that part yet
22:40:27 <mniip> actually
22:40:39 <mniip> geekosaur, you turned out to be wrong
22:40:56 <mniip> heighten = liftCallCC, up to newtype coercions
22:41:17 <guessWHo> what does it mean in this contex "waitOne :: forall m t . (MonadIO m) => STM.TVar (OQ.PacketStatus t) -> m t"
22:41:26 <mniip> which I mean, Control.Monad.Trans.Except.liftCallCC and Control.Monad.Trans.Reader.liftCallCC
22:41:45 <glguy> guessWHo: In that context it's just saying that m and t are introduced at that point in the type signature
22:42:02 <glguy> In standard Haskell the "forall m t." part is implied
22:42:12 <glguy> in that type signature in particular
22:42:24 <mniip> sounds like ScopedTyVars
22:42:26 <guessWHo> @glguy : it's part of haskell right ? no extension required ?
22:42:26 <lambdabot> Unknown command, try @list
22:42:49 <glguy> guessWHo: You need an extension to actually write that forall there
22:43:03 <guessWHo> @glguy : what's that ?
22:43:03 <lambdabot> Unknown command, try @list
22:43:06 <mniip> guessWHo, no it does require an extension. Either ScopedTypeVariables or RankNTypes
22:43:17 <cocreature> or ExplicitForalls
22:43:29 <glguy> An extension is required because the "forall" syntax isn't in the Haskell Report
22:43:33 <guessWHo> mniip : any one of them depending on the context ?
22:44:27 <cocreature> apart from stylistic reasons, the only reason to have the explicit forall in your example would be that ScopedTypeVariables is enabled.
22:54:07 <dminuoso> :t liftCallCC
22:54:09 <lambdabot> error: Variable not in scope: liftCallCC
23:00:48 <dminuoso> mniip: Okay pretty slick stuff, I suppose this will do nicely indeed. It doesn't actually change my problem, but make withLdap look nicer. :)
23:01:16 <dminuoso> Took me a moment to understand why the rank 2 type was necessary, but it's obvious because things like ExceptT or MaybeT need to change the inner type of the IO
23:01:34 <dminuoso> (So the continuation must be polymorphic in there)
23:06:46 <gama> which is better in memory  forever functiion call or recursive call of function
23:07:27 <dminuoso> gama: How do you think forever is implemented?
23:08:14 <gama> dminuoso : I don't know
23:08:26 <dminuoso> gama: https://hackage.haskell.org/package/base-4.11.1.0/docs/src/Control.Monad.html#local-6989586621679327091
23:11:59 <dminuoso> :t heighten . heighten $ catch undefined
23:12:00 <lambdabot> error:
23:12:00 <lambdabot>     • Couldn't match type ‘(a1 -> t0 m0 b0) -> t0 m0 b0’
23:12:01 <lambdabot>                      with ‘forall b1. (a -> m b1) -> m b1’
23:12:02 <dminuoso> :t heighten $ heighten $ catch undefined
23:12:03 <lambdabot> forall k (t1 :: (* -> *) -> k -> *) (t2 :: (* -> *) -> * -> *) a (b :: k). (Exception a, Heighten t2, Monad (t2 IO), Heighten t1) => (a -> t1 (t2 IO) b) -> t1 (t2 IO) b
23:26:13 <[exa]> what kind of lifting is heightening O_O
23:30:46 <dminuoso> That class should be call Enheightenment
23:33:47 <dminuoso> But Im curious... why does `heighten $ heighten $ catch undefined` type check while `heighten . heighten $ catch undefined` does not
23:34:11 <dminuoso> :t (.)
23:34:12 <lambdabot> (b -> c) -> (a -> b) -> a -> c
23:34:29 <dminuoso> :t heigten (catch undefined)
23:34:30 <lambdabot> error:
23:34:30 <lambdabot>     • Variable not in scope: heigten :: ((e0 -> IO a0) -> IO a0) -> t
23:34:30 <lambdabot>     • Perhaps you meant ‘heighten’ (line 159)
23:34:32 <dminuoso> :t heighten (catch undefined)
23:34:33 <lambdabot> forall k (t :: (* -> *) -> k -> *) a (b :: k). (Exception a, Heighten t) => (a -> t IO b) -> t IO b
23:34:59 <Ariakenom> :t ($)
23:35:00 <lambdabot> (a -> b) -> a -> b
23:35:23 <Ariakenom> $ is more kind general right?
23:36:13 <dminuoso> @let data R = R
23:36:14 <lambdabot>  Defined.
23:36:33 <dminuoso> @let with :: (R -> IO a) -> IO a; with f = f R
23:36:34 <lambdabot>  Defined.
23:36:42 <dminuoso> :t heighten with
23:36:43 <lambdabot> forall k (t :: (* -> *) -> k -> *) (b :: k). Heighten t => (R -> t IO b) -> t IO b
23:36:59 <Ariakenom> and you had a kind variable
23:54:09 <zds> @kind Monad
23:54:10 <lambdabot> (* -> *) -> Constraint
23:54:36 <zds> @unmtl ReaderT
23:54:36 <lambdabot> Plugin `unmtl' failed with: `ReaderT' is not applied to enough arguments, giving `/\A B C. A -> B C'
23:54:39 <dminuoso> Where does that kind polymorphism come from in there?
23:56:01 <zds> \quit
