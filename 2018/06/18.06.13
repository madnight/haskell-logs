00:00:33 <jle`> what would it do?
00:00:47 <jle`> is it just maybe . throwIO ?
00:01:23 <jle`> also SomeException is not a typeclass
00:01:39 <jle`> (maybe you mean Exception?)
00:01:44 <dminuoso> Oh heh. I was changing it forth and back and flipped a coin. Yes I meant Exception :P
00:02:04 <dminuoso> :t fromMaybe . throwIO
00:02:05 <lambdabot> Exception e => e -> Maybe (IO a) -> IO a
00:02:11 <dminuoso> :t maybe . throwIO
00:02:13 <lambdabot> Exception e => e -> (a1 -> IO a2) -> Maybe a1 -> IO a2
00:02:25 <jle`> :t flip maybe pure . throwIO
00:02:26 <lambdabot> Exception e => e -> Maybe a -> IO a
00:02:28 <cocreature> seems pretty reasonable
00:02:46 <jle`> :t \e -> maybe (throwIO e) pure
00:02:48 <lambdabot> Exception e => e -> Maybe a -> IO a
00:03:22 <jle`> if it's a pattern that pops up a lot then go for it :)
00:03:36 <jle`> i'd probably use it more as a local binding
00:03:47 <jle`> also:
00:03:55 <jle`> :t \e -> maybe (throwError e) pure
00:03:56 <lambdabot> MonadError e m => e -> Maybe a -> m a
00:04:09 <jle`> i use that a lot to convert Maybe's to Either's
00:04:29 <jle`> usually it's so short/simple that i don't bother with giving it a name
00:04:49 <cocreature> it’s called "note" in various packages
00:05:14 <dminuoso> Oh *that* is cool.
00:05:28 <jle`> too bad fundeps prevent using any exception nakedly with IO
00:05:33 <jle`> you'd have to wrap in SOmeException
00:06:14 <dminuoso> How does MonadError compare to MonadThrow/MonadCatch?
00:06:31 <pdxleif> jle`: Hmm, I guess it works if I turn on UndecidableInstances in my standalone example: https://gist.github.com/LeifW/f6c2e6da3647ad43c151cc9e27e46ac6
00:06:43 <pdxleif> I can look more into why it was saying ambiguous instance in my full code.
00:07:02 <pdxleif> People probably wouldn't be wild about having UndecidableInstances to use the API.
00:07:13 <jle`> UndecidableInstances is a pretty common thing
00:07:31 <jle`> the name is scarier than what it actually is :)
00:07:45 <jle`> i'm usually more surprised when i'm writing code and UndecidableInstances is off
00:07:48 <dminuoso> pdxleif: All UndecidableInstances does is turn of some conservative checks that ensure the type checker will terminate. Worst case your type checker will error out in an infinite loop.
00:07:56 <dminuoso> Rare worst case it will be stuck in the type checker I think.
00:08:09 <dysfun> isn't that what darcs1 had?
00:08:23 <pdxleif> Ok. I thought what I was asking it seemed like a sensible thing, and I'm pretty certain it will terminate.
00:08:52 <jle`> to me it's on the same level as TupleSections
00:09:21 <jle`> where i do (x,) and ghc gives me and error and i get grumpy that such a benign thing is not in haskell by default
00:09:33 <pdxleif> dminuoso: With MonadError you specify the type of the error, like Either.
00:09:41 <tdammers> TupleSections is just syntax sugar though
00:09:50 <dysfun> yeah TupleSections is totally reasonable for default enabling
00:09:51 <pdxleif> With MonadThrow the left is just SomeException instances.
00:10:10 <tdammers> UndecidableInstances goes a bit deeper
00:10:23 <jle`> dminuoso: if it helps give any context, MonadError is basically MonadState, MonadReader, MonadWriter, except for Either
00:12:15 <dminuoso> Ah cool - so I dont have to actually use this in a transformer stack because I can use the instance  MonadError e (Either e)
00:13:29 <jle`> yeah, it's meant to generalize over Either-like patterns
00:13:52 <jle`> MonadCatch/MonadThrow are meant to generalize the runtime Exception system that GHC offers
00:14:43 <jle`> so if you understand the difference between using 'Either e' and using IO exceptions, it's somewhat of a similar analogy
00:15:14 <jle`> * (Either e, ExceptT e, etc.)
00:15:36 <dminuoso> pdxleif: The degenerate case it tries to protect you against, is if you had some `instance HasFoo t => Has Foo t` I think. The type checker would end up in an infinite recursion to check the constraints of each other.
00:15:46 <cocreature> the part that’s slightly weird is the MonadError instance for IO
00:16:11 <jle`> in fact i suppose you could even have both (MonadError e m, MonadCatch m) => m .., and MonadError would handle your "pure" exceptions (ExceptT e, Either e) and MonadCatch would handle your IO exceptions
00:16:23 <dminuoso> pdxleif: And strictly speaking you can't know whether that will always be the case. The open world assumption allows a third party user to later add it, and then loop the type checker.
00:17:29 <jle`> if you had ExceptT e IO a, MonadError methods would work with your 'pure' e errors, and MonadCatch methods would work with the IO exceptions at the base
00:17:45 <jle`> but i don't think i'd recommend ever actually mixing both, heh
00:17:57 <jle`> that's just maybe a good illustration of the differences
00:18:18 <dminuoso> jle`: If Im not responding its because Im slowly reading and digesting this heap of knowledge =)
00:18:21 <cosmia> is there any article about ekmett/machines? the pdf on dropbox is no longer available
00:19:11 <pally> [ f x | x <- xs ]
00:19:24 <pally> I have a non-technical question:  How would you read that in speech?
00:19:32 <opqdonut> f x for x in xs
00:19:52 <dminuoso> That sounds pythonish.
00:20:06 <opqdonut> that's how you read set notation in math
00:20:18 <cocreature> dminuoso: well python stole list comprehensions from Haskell iirc :)
00:20:18 <opqdonut> and list comprehensions are obviously inspired by that
00:20:25 <pally> and in math that's called the intentional description of a set
00:21:00 <pally> now, let's use Haskell parlance
00:21:36 <pally> opqdonut, how you'd you read it in Haskell parlance?
00:22:02 <pally> that was for dminuoso, actually.
00:22:35 <opqdonut> TBH when talking about haskell I just usually grab a whiteboard or post-it note
00:22:42 <opqdonut> types are hard to read out loud too
00:22:51 <opqdonut> consider something like the type for >>=
00:23:19 <opqdonut> or something like "f i . g (h j) $ k x
00:23:36 <pally> I am a newbie, I am not there yet :p , but I think it's the binding operator (Monad related)
00:23:41 <jle`> i usually don't translate the symbols directly, but rather the function or thing that the symbols are describing
00:23:54 <opqdonut> :t (>>=)
00:23:55 <lambdabot> Monad m => m a -> (a -> m b) -> m b
00:23:56 <opqdonut> ^ this type
00:24:10 <dminuoso> pally: I know it as set builder notation.
00:24:16 <jle`> like `f i . g (h j) $ k x`, it's describing applying f i composed with g of (h j) to k x
00:25:02 <jle`> for something like `putStrLn "hi" >> putStrLn "by"` i'd read >> as "and then" or "sequenced with"
00:25:17 <jle`> i'm not sure if i'm disproving or proving my point
00:25:20 <dysfun> i normally read do notation as 'and then' tbh
00:27:07 <dminuoso> I dont read do notation allowed because I know it's just an abstract interface.
00:27:11 <dminuoso> *aloud.
00:28:38 <pally> jle` when you give your talks, do you ever get into hickups reading them out? heh
00:28:49 <pally> *aloud\
00:29:23 <jle`> sometimes, but i do usually try to explain the idea of it instead of the notation
00:29:29 <jle`> unless it's a talk specifically about notation.  then it gets weird
00:30:32 <zenspider> can I get a (gentle) code review? I implemented a concordance fn while poking a new book: https://gist.github.com/7cebc4b7f4f0c328da58f698b0b5be2d
00:30:43 <zenspider> I'm sure there are things I can improve. I'm just getting started
00:32:23 <jle`> zenspider: instead of group + map, you can use a Map
00:32:52 <jle`> Map Int String and M.fromList instead of [(Int, String)] and map (\xs -> (...,  head xs)) . group
00:33:04 <dminuoso> zenspider: also generally you'd rather use composition than a chain of $ in here:  let top25 = take 25 $ sort $ concordance stops file
00:34:27 <zenspider> I'm not thrilled that I am passing down the stopwords set. My original version used one of the unsafe fns so I could make notStops a top level function that was prepopulated. Not sure if I've got the whole IO monad design thing down yet
00:35:02 <cocreature> what’s bothering you about having to pass it down? that seems perfectly fine
00:35:16 <jle`> there is nothing wrong with parameterizing concordance on a stopwords set, heh
00:35:26 <cocreature> and definitely better than some unsafePerformIO newIORef if that’s what you mean by unsafe fns
00:35:53 <jle`> i wouldn't even call that unsafe, just absurd, heh
00:36:19 <jle`> zenspider: small things, putStrLn (printf "..." ...) is just printf "...\n" ...
00:36:23 <zenspider> well... it *worked*... :P yeah. I was using unsafePerformIO to make the set populate at the top
00:36:32 <cocreature> jle`: you’d be surprised by how often I’ve seen that to get global variables in Haskell :)
00:36:35 <jle`> printf can directly be IO
00:36:38 <dminuoso> zenspider: Also you probably might want to check out traverse_ over sequence_ for that last bit. :)
00:36:41 <jle`> cocreature: oh yeah, i mean, in this situation
00:36:43 <zenspider> I'm not sure I grok the Map suggestion above. I don't think I'm quite there yet
00:36:55 <jle`> zenspider: you're basically emulating a Map
00:36:56 <dminuoso> (or forM_ if you prefer)
00:37:00 <jle`> zenspider: are you familiar with Data.Map ?
00:37:17 <zenspider> jle`: nope, not yet
00:37:28 <jle`> do you know any other languages besides haskell?
00:37:48 <zenspider> sequence_ is in my book. traverse_ isn't (yet?). But I'll poke at it.
00:37:49 <jle`> Map is a key-value store, like hashes from ruby, objects from javascript, dicts from python
00:38:17 <zenspider> jle`: yeah. I'm esp good w/ ruby and racket
00:38:24 <jle`> you're basically using [(Int, String)] as a "poor man's" version of a ruby hash
00:38:30 * hackage HNumeric 0.4.0.0 - Haskell Numeric Library with pure functionality, R & MATLAB Syntax.  http://hackage.haskell.org/package/HNumeric-0.4.0.0 (edeftg)
00:38:42 <jle`> but it's easier if you use the right data structure, Map from Data.Map
00:38:51 <jle`> you'd have `Map Int String` instead, a map of strings indexed by Int's
00:39:05 <dminuoso> :t traverse
00:39:06 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
00:39:11 <simon> how hard is it to compile a MacOS binary on Linux using GHC?
00:39:26 <jle`> zenspider: oh hm, actually it might be slightly different
00:39:43 <jle`> i might have misread, Map might not be a direct translation of what you're using
00:39:48 <zenspider> I have it [(Int,String)] right now so that it is sortable
00:40:17 <zenspider> it's really a Map String Int but I want the sort via the value
00:40:22 <zenspider> (well, both)
00:40:37 <jle`> ah i see.  yeah it's not quite a direct translation then, since Map sorts internally by the key
00:40:57 <jle`> i suppose in that case this might be simpler, although i always feel weird seeing 'head'
00:41:01 <zenspider> if there is something like sortBy then it should be ok?
00:41:27 <zenspider> head is because of group. I didn't know how better to count occurances
00:41:58 <jle`> oh, i see, you're just using that as a frequency map
00:42:08 <zenspider> exactly. there's probably something better for that tho
00:42:09 <jle`> yeah, the typical frequency map is made using Map
00:42:24 <dminuoso> zenspider: traverse f = sequenceA . fmap f
00:42:25 <jle`> :t M.fromListWith (+) . map (,1)
00:42:26 <lambdabot> (Num a, Ord k) => [k] -> M.Map k a
00:42:43 <jle`> that will build a frequency map of k's to their number of occurrences
00:42:44 <dminuoso> zenspider: So basically `sequence` is for collecting a list of effects in a foldable, while traverse allows you to map each element to an effect first.
00:42:54 <jle`> then you can just do M.toList to get the [(String, Int)] back and then sort how you like
00:42:56 <zenspider> ugh. I still don't get hoogle. I look up Map and I wind up with a page of 100% deprecetade stuff
00:43:04 <jle`> what hoogle are you using?
00:43:07 <dminuoso> zenspider: What you are doing with the list comprehension is exactly that: You take each element, replace it by an effect, and then sequence these effects. That is exactly traverse =)
00:43:15 <jle`> the 'official' hoogle is actually like five years out of date
00:43:28 <jle`> :t M.toList . M.fromListWith (+) . map (,1)
00:43:29 <lambdabot> (Num a, Ord k) => [k] -> [(k, a)]
00:43:31 <zenspider> https://hoogle.haskell.org/?hoogle=Map
00:43:43 <jle`> yup it's the first result :)
00:44:00 <jle`> > M.toList . M.fromListWith (+) . map (,1) $ "hello world"
00:44:02 <lambdabot>  [(' ',1),('d',1),('e',1),('h',1),('l',3),('o',2),('r',1),('w',1)]
00:44:09 <zenspider> first result is 100% deprecated
00:44:21 <dminuoso> zenspider: forM_ top25 $ \(n, s) -> printf "%s -- %d\n" s (-n)
00:44:24 <zenspider> either I don't get hoogle, or I don't get the doco
00:44:50 <cocreature> zenspider: the docs are kind of confusing. the functions that are directly defined in Data.Map are deprecated but Data.Map reexports all of Data.Map.Lazy which is not deprecated
00:44:50 <jle`> https://hackage.haskell.org/package/containers-0.5.11.0/docs/Data-Map-Lazy.html
00:45:02 <dminuoso> Or I suppose `for_` is sufficient *shrugs*
00:45:28 <zenspider> huh. that's a new error. Illegal tuple section?
00:45:29 <jle`> > sort . map swap . M.toList . M.fromListWith (+) . map (,1) $ "hello world"
00:45:31 <lambdabot>  [(1,' '),(1,'d'),(1,'e'),(1,'h'),(1,'r'),(1,'w'),(2,'o'),(3,'l')]
00:45:46 <jle`> zenspider: yeah tuples can't be sectioned in vanilla haskell
00:45:47 <zenspider> guessing it's that (,1)
00:45:53 <jle`> the error message should give you a fix :)
00:46:17 <zenspider> use TupleSections... I'd rather stick to vanilla for now
00:46:23 <zenspider> I can figure it out tho
00:46:43 <cocreature> it’s just syntactic sugar for (\x -> (x,1))
00:46:58 <zenspider> yup
00:47:01 <jle`> zenspider: add {-# LANGUAGE TupleSections #-} to the top of your file
00:49:24 <zenspider> oh. sortBy isn't a schwartzian transformer... hrm
00:50:07 <jle`> sortOn is, i believe
00:51:07 <zenspider> how terrible is this?
00:51:08 <jle`> > sortOn (negate . fst) . map swap . M.toList . M.fromListWith (+) . map (,1) $ "hello world"
00:51:08 <zenspider> sortBy (\a b -> snd b `compare` snd a) $ Map.toList . Map.fromListWith (+) . map (\x -> (x,1)) $ "hello world"
00:51:11 <lambdabot>  [(3,'l'),(2,'o'),(1,' '),(1,'d'),(1,'e'),(1,'h'),(1,'r'),(1,'w')]
00:51:28 <jle`> zenspider: sortOn swap ?
00:51:58 <cocreature> jle`: I don’t think that’s the same thing
00:52:12 <zenspider> > sortBy (\a b -> snd b `compare` snd a) $ Map.toList . Map.fromListWith (+) . map (\x -> (x,1)) $ "hello world"
00:52:15 <lambdabot>  error:
00:52:15 <lambdabot>      Not in scope: ‘Map.toList’
00:52:15 <lambdabot>      Perhaps you meant one of these:
00:52:15 <cocreature> there’s a flip compare in there
00:52:18 <zenspider> BOOM
00:52:21 <jle`> oh i see
00:52:32 <jle`> sortOn snd
00:52:36 <jle`> but flipped
00:52:37 <cocreature> sortBy (flip compare `on` snd)
00:53:03 <jle`> `sortBy (negate . snd)` :)
00:53:10 <jle`> er, sortOn (negate . snd)
00:53:51 <jle`> > sortOn (negate . snd) . M.toList . M.fromListWith (+) . map (,1) $ "hello world"
00:53:53 <lambdabot>  [('l',3),('o',2),(' ',1),('d',1),('e',1),('h',1),('r',1),('w',1)]
01:04:10 <zenspider> OK! THIS is the reason why I don't like pushing the stopwords stuff down ...
01:04:34 <zenspider> how do I poke at these new functions now that I basically need all of main to be redefined in my repl to even start poking?
01:05:11 <zenspider> eg. the sortOn isn't working but now I need to pull in and parse the stopwords instead of having that unsafe function that just works
01:05:29 <zenspider> what's the usual workflow for y'all?
01:05:48 <jle`> can't you just bind your stop words set?
01:05:56 <jle`> if you're in ghci?
01:06:21 <jle`> stops <- makeTheStopWords
01:06:34 <zenspider> my basic rule: whenever a nerd uses the word "just", they're understating something.
01:07:13 <zenspider> Yeah. I'm in ghci in emacs. flipping back and reloading and then running main
01:07:29 <zenspider> but I can't run my sub-fns because I need those binding that main has, over and over
01:07:48 <zenspider> that's why I said I'm not sure I have this IO monadic design thing down yet
01:07:49 <jle`> `makeTheStopWords :: IO S.Set String`
01:07:57 <jle`> makeTheStopWords would be an IO action
01:08:02 <jle`> * IO (S.Set String)
01:08:12 <jle`> and when you reload, you can do stops <- makeTheStopWords
01:08:15 <jle`> and stops is your stop words :)
01:09:01 <Axman6> Once you have that, ^R is your friend for reusing previous commands which use those bindings :)
01:09:53 <zenspider> huh. new error. Expecting one fewer arguments to IO Set.Set
01:10:11 <cocreature> you need parentheses around S.Set String
01:10:16 <zenspider> but parens there means tuple, doesn't it?
01:10:17 <Axman6> IO (Set.Set String)
01:10:19 <cocreature> no
01:10:20 <zenspider> oh. just ()
01:19:09 <zenspider> is Foundation.Timing the right thing to be poking with?
01:20:26 <cocreature> whether foundation is the right thing for anything is at least up for debate :)
01:20:49 <zenspider> ok. how do I get simple timing info from my code?
01:21:01 <cocreature> I use the clock package
01:21:34 <Laura> hello
01:22:05 <jle`> zenspider: if you're in ghci you can also just do :set +t
01:22:11 <jle`> % :set +t
01:22:11 <yahb> jle`:
01:22:14 <jle`> % sum [1..1000]
01:22:15 <yahb> jle`: 500500; it :: (Num a, Enum a) => a
01:22:19 <cocreature> hey Guest5159 :)
01:22:20 <jle`> aw
01:22:57 <jle`> ah, :set +s
01:23:01 <jle`> % :set +s
01:23:02 <yahb> jle`:
01:23:07 <jle`> > sum [1..10000]
01:23:09 <lambdabot>  50005000
01:23:14 <jle`> % sum [1..100000]
01:23:14 <yahb> jle`: 5000050000; it :: (Num a, Enum a) => a; (0.17 secs, 16,267,160 bytes)
01:23:25 <cocreature> % :set -t
01:23:25 <yahb> cocreature: Some flags have not been recognized: -t
01:23:37 <Laulz> hi cocreature
01:23:39 <jle`> good thing Gauss as a 1st grader didn't have ghci
01:23:43 <cocreature> huh, is there no way to turn that off?
01:23:45 <zenspider> holy shit... am I really using that much memory?!?!
01:24:26 <dysfun> sounds like you've got a leak
01:24:36 <jle`> "how much memory does this haskeller use?  the answer will shock you!"
01:24:53 <zenspider> my original map version is consistently faster... but they're both using absurd amounts of ram
01:24:53 <dysfun> https://wiki.haskell.org/Memory_leak
01:24:54 <cocreature> if you actually care about memory usage, you probably want to compile with -O and not use ghci for testing
01:25:35 <zenspider> .39s & 286mb vs 0.50s & 318mb
01:26:47 <zenspider> the compiled version only uses ~23mb
01:27:08 <cocreature> also make sure you are not confusing resident memory and total memory allocated
01:29:17 <zenspider> If I limit RTS to 11m it bombs out. Passes w/ 12m
01:29:33 <jle`> did i ruin yahb
01:29:33 <cocreature> can you show us the code?
01:30:13 <zenspider> https://gist.github.com/f9f956d31d83881f017254ab69fd8c82
01:30:35 <cocreature> how large are the files that you are reading?
01:31:20 <zenspider> it's literally pride and prejudice from gutenberg
01:31:27 <zenspider> ~700kb
01:31:48 <zenspider> ~125 k words
01:32:08 <cocreature> 12mb don’t seem that unreasonable for representing a text file using String
01:32:09 <jle`> hm, does the memory go up or down if you use a larger or smaller file?
01:32:19 <cocreature> String is a linked list of characters so it’s not at all space efficient
01:32:20 <jle`> if not then it might just be the normal RTS doing its job
01:32:31 <ggVGc> jle`: the answer does shock me, every time
01:32:43 <jle`> oh yeah, String is indeed pretty awful in terms of memory usage, if you're using it as text
01:32:58 <jle`> it's basically the "i don't care about memory" type
01:33:11 <cocreature> you might also be able to safe some memory by using Data.Map.Strict
01:33:12 <zenspider> I usually don't either... it was the +s output that blew me away
01:33:20 <zenspider> that's taking it to another level
01:34:26 <dminuoso> What's the space requirement per character in String?
01:34:33 <dminuoso> (That is how large are boxes?)
01:35:34 <zenspider> is it really making a cons (or equiv) per char?
01:35:39 <dminuoso> zenspider: Yes.
01:35:58 <zenspider> huh. impressive
01:36:08 <dminuoso> zenspider: "foobar" is really 'f':('o':('o':('b':('a':('r':[])))))
01:36:11 <pdxleif> dminuoso: a byte per char, I think - same as in C?
01:36:18 <dminuoso> pdxleif: absolutely no.
01:36:20 <zenspider> I figured it just emulated it that way
01:36:45 <pdxleif> Just for the chars - that's not counting the list, or the references to those chars.
01:36:47 <dminuoso> zenspider: Text is the efficient packed version of it that you know about.
01:37:45 <pdxleif> Int32, Char, Word32 are equivalent afaik
01:38:10 <cocreature> dminuoso: iirc tags and Char are 32bits. a cons cell will have a tag + 2 pointers
01:38:30 * hackage wss-client 0.1.0.0 - A-little-higher-level WebSockets client.  http://hackage.haskell.org/package/wss-client-0.1.0.0 (igrep)
01:38:31 <dminuoso> cocreature: Ah I found an interesting article https://wiki.haskell.org/GHC/Memory_Footprint
01:39:38 <quicksilver> on 64bit architectures, all those 32 bit objects are 64 bits
01:40:35 <dminuoso> 5N words according to Johan Tibell
01:40:40 <dminuoso> So 10 characters cost 50 bytes.
01:40:43 <pdxleif> > Unsafe.Coerce.unsafeCoerce [1..10] :: String
01:40:46 <lambdabot>  error:
01:40:46 <lambdabot>      Not in scope: ‘Unsafe.Coerce.unsafeCoerce’
01:40:46 <lambdabot>      No module named ‘Unsafe.Coerce’ is imported.
01:40:51 <zenspider> what's the current runtime flag equivalent to -xc ? should be printing out a stack trace when it blows?
01:40:59 <quicksilver> 10 characters cost 10 * 5 * 8
01:41:02 <quicksilver> 400 bytes
01:41:08 <quicksilver> (because a word is 8 bytes, on a modern arch)
01:41:14 <dminuoso> ohh right.
01:41:28 <dminuoso> quicksilver: Its really confusing to see them use the word "word" right.
01:41:34 <dminuoso> 2 years of assembly programming have ruined me.
01:41:44 <quicksilver> I thought it was 4N but Tibell is probably right.
01:42:39 <merijn> In conclusion: Text rules, String drools! ;)
01:43:04 <dminuoso> Though the *real* price of String is not even the large memory footprint.
01:43:20 <dminuoso> But the poor cache characterstics.
01:43:27 <cocreature> hm, we get 3 from the cons cell, does the Char itself really take up 2 words?
01:43:44 <quicksilver> yes, one word for the thunk pointer and one for the Char itself
01:43:48 <merijn> cocreature: Char is boxed, so I'd say "probably"
01:44:22 <zenspider> do I need compile flags or something to get a stack trace when this thing blows up?
01:44:26 <quicksilver> Strings which are streamed and consumed in a stream fashion have excellent cache characteristisc, of course.
01:44:43 <dminuoso> quicksilver: do they?
01:44:59 <merijn> quicksilver: Not nearly as great as chunks of Text would
01:45:01 <dminuoso> quicksilver: They evict horrible amounts of cache lines.
01:45:08 <cocreature> quicksilver: I don’t think there is a thunk pointer? you have "data Char = C# Char#" and afaik primitive types are stored unpacked
01:45:21 <dminuoso> So while a streamed string might all be cached already, not much else will be left in your lower caches.
01:45:48 <cocreature> you have the pointer going to the Char but that’s one of the 3 in the cons cell
01:46:02 <quicksilver> and that pointer points to the code
01:46:10 <quicksilver> which is executed to produce the actual char value
01:46:22 <dminuoso> So I wouldn't say "excellent cache characteristics" at all
01:46:42 <quicksilver> dminuoso: maybe excellent is overstating it
01:46:47 <dminuoso> Does the GHC RTS have any cache color awareness?
01:46:50 <quicksilver> just 'not as bad as you'd expect from a strict intuition'
01:47:12 <quicksilver> lazily produced and consumed strings have good locality of access and the GC is also performed locally.
01:47:30 <dminuoso> quicksilver: Right, but if you evict all the other cache lines in the process your program still suffers in all the other bits.
01:47:43 <zenspider> I *have* to be doing something terrible. My ruby code runs 33% faster than the complied haskell
01:47:53 <merijn> zenspider: Are you using "String"?
01:47:55 <dminuoso> zenspider: stop using String. =)
01:48:01 <merijn> dminuoso: High-five!
01:48:57 <merijn> zenspider: In general if you think "huh, this code is very slow" and you're doing anything involving a non-trivial amount of text, the answer is "whoops, you're probably using String and really shouldn't" (see past couple 100 lines for reasons why ;))
01:48:59 <zenspider> I thought I wandered into #emacs for a sec
01:49:44 <merijn> zenspider: If that's *not* the case, then the next step would be "profile your code" probably there's a non-strict foldl or some similar memory leak slowing things down. Those are 2 most obvious problems in beginner code
01:49:52 <dminuoso> zenspider: In addition the RTS has profiling available (you need to recompile your code though)
01:50:01 <dminuoso> merijn: Here we go again!
01:50:26 <merijn> Also, did you compile with -O or -O2?
01:51:40 <zenspider> Apparently I can't profile. I'm using Data.List.Extra which apparently doesn't have profiling info and blows out the compile
01:51:54 <cocreature> how are you trying to compile?
01:52:04 <merijn> zenspider: How are you building things? cabal-install or stack?
01:52:05 <cocreature> both stack and cabal new-build should take care of building your deps with profiling info
01:52:41 <zenspider> ghc -rtsopts -prof -fprof-auto golf.hs && ./golf  +RTS -M11m -xc
01:52:57 <cocreature> I would recommend to turn that into a cabal package
01:52:57 <jle`> oh you are just using ghc directly
01:53:14 <merijn> I second that recommendation :)
01:55:00 <merijn> Unrelatedly, a pox upon people who push to master with broken tests >.<
01:55:37 <dminuoso> Ive seen worse. People *force* pushing code onto master with broken tests.
01:56:18 <merijn> dminuoso: Yeah, but now I don't know if my PR is breaking things (probably not) or tests are just broken >.<
01:56:30 <cocreature> or both!
01:56:40 <merijn> cocreature: Relatedly, if you're feeling adventurous, I have an even more bleeding edge new-build for you ;)
01:57:28 <cocreature> not atm, sry :)
02:02:30 * hackage wss-client 0.1.0.1 - A-little-higher-level WebSocket client.  http://hackage.haskell.org/package/wss-client-0.1.0.1 (igrep)
02:18:23 <dminuoso> If I want raw sockets in Haskell, do I have any other options than pcap?
02:18:28 <dminuoso> (Linux only)
02:19:00 <dminuoso> Im currently pondering about rolling some PPPoE client to provide cleaner automated testing of our PPPoE infrastructure
02:19:34 <merijn> dminuoso: You could just do some thin FFI to the C socket API? I mean network is already only a tiny thin shell over that anyway
02:20:29 <dminuoso> merijn: Mmm I guess that could work indeed.
02:22:08 <dminuoso> I mean I dont even want to send data ontop of PPP, just the raw handshake is enough. So I guess a thin wrapper is probably the easiest solution
02:24:33 <butterthebuddha> "class Monad m => MonadReader r m | m -> r where"
02:24:38 <butterthebuddha> What does the pipe in the definition mean?
02:25:31 <drets> Hye, https://lpaste.net/4617692650449928192 why to use record update with recordwildcards is bad, so it's disallowed?
02:26:06 <drets> Hey*
02:26:42 <pavonia> butterthebuddha: It introduces functional dependencies on the type parameters  https://wiki.haskell.org/Functional_dependencies
02:27:55 <dminuoso> It
02:30:13 <pavonia> drets: I think you can only use it in patterns and with data constructors
02:31:24 <cocreature> drets: that seems like asking for trouble. if you had a typo in the field name it would just silently not update the field
02:31:33 <butterthebuddha> So the definition above is asserting that r is uniquely determined by m?
02:31:57 <ZeuPiark> hello
02:32:06 <dminuoso> butterthebuddha: Correct.
02:33:24 <dminuoso> butterthebuddha: iow "if you know m, then we can figure out r based on that knowledge alone"
02:41:36 <reactormonk> I used to specify a ghc options to print me the number of coercions and a few more things on compliation - anyone got that information around?
02:43:15 <shafox> How would I implement rose tree while parsing a text file ? Here are the relevant code and structure of the text that I am parsing. https://gist.github.com/shadow-fox/acd2ce8977e0c28c5f6fa31fe9445133
02:43:24 <shafox> Can someone help me in implementing the same ?
02:43:54 <dminuoso> reactormonk: https://downloads.haskell.org/~ghc/master/users-guide/using.html#verbosity-options there's -fprint-explicit-coercions listed there. Is that what you are looking for?
02:44:37 <dminuoso> butterthebuddha: It gives the type checker some freedom because it needs not infer/figure out `r` - it suffices to figure out `m` (since there can be only choice for `r` to go with some choice of `m`)
02:50:23 <Ariakenom> :t sin^2 + cos^2
02:50:25 <lambdabot> (Num (a -> a), Floating a) => a -> a
02:50:45 <reactormonk> dminuoso, more on a general number, to see the order of magnitude of coercions created
02:52:32 <cocreature> reactormonk: there are various -ddump-*-stats flags
03:15:14 <jle`> shafox: what parser combinator library are you using?
03:15:51 <shafox> jle`: I am using megaparsec.
03:44:12 <sigma_> what does this symbol means in haskell ?? ((->) e)
03:45:58 <Ariakenom> sigma_: The syntax is like this (a + b) = ((+) a b) so a partially applied function arrow (e -> x)
03:46:36 <Ariakenom> You can also think of partially applied either: (Either a)
03:47:11 <Ariakenom> ((->) e x) = (e -> x)
03:48:02 <Ariakenom> sigma_: Did this help?
03:48:45 <sigma_> Ariakenom : not really can you elaborate a bit ? i got the partially applied part but what exactly is this and where is it used
03:49:31 <cocreature> it’s used in things like the Functor instance declaration for ((->) e)
03:49:34 <Ariakenom> Do you understand partially applied Either? So instead of Either a b we have Either a
03:49:50 <sigma_> yep
03:51:05 <sigma_> cocreature : okay i was reading it in exact same context but how exactly do we define ((->) e)
03:51:26 <cocreature> sigma_: you can’t define it. functions are a primitive built into the compiler
03:51:27 <Ariakenom> When we write the Functor instance for Either we write (instance Functor (Either a)) right?
03:51:53 <sigma_> yes
03:52:32 <Ariakenom> So we do the same for ((->)a b) = (a -> b)
03:52:41 <Ariakenom> functions
03:53:21 <Ariakenom> The type parameter it accepts is what fmap maps.
03:54:15 <Ariakenom> Where it is for example (Either a) or ((->) a)
03:55:06 <sigma_> does it have some name in haskell ?
03:55:18 <Ariakenom> What would you call (Either a)?
03:55:43 <sigma_> Type ?
03:55:48 <cocreature> (->) is called function arrow, the partially applied version is sometimes called Reader (but that might also refer to the newtyped version)
04:00:30 * hackage fay 0.24.0.1 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.24.0.1 (AdamBergmark)
04:03:27 <Psybur> do the IRC browse logs stop at April 11th for anyone else?
04:03:50 <cocreature> Psybur: yes, irc browse has been dead for some time
04:04:37 <tdammers> Ariakenom: you might call it a partially applied type constructor
04:04:48 <tdammers> although arguably that doesn't make sense in the "everything is unary" paradigm
04:05:10 <tdammers> we also have this concept called "Kind", which is the "type of a type"
04:05:55 <Ariakenom> I would probably go with "The function type applied to e"
04:05:55 <tdammers> so you could say Either a is a type of kind * -> *
04:06:10 <Ariakenom> Or Type -> Type if you have morals
04:06:19 <Psybur> How can I search through this channels logs without ircbrowse?
04:07:00 <Ariakenom> sigma_: You mean like a type? Then ((->) e) is also a type.
04:07:45 <lavalike> Reader e   is also   ((->) e)
04:08:07 <Psybur> nvm the tunes log is easy enough to search
04:16:02 <haskell_noob1> Hi. If i run  valgrind on a FFI bindings, does valgrind report the leaks correctly?
04:16:39 <haskell_noob1> https://lpaste.net/8262624102263554048
04:17:04 <cocreature> haskell_noob1: ime it does
04:17:06 <haskell_noob1> which tool should i be using to accurately determine that there are no leaks in the application?
04:17:43 <haskell_noob1> so if the output as in the paste, cocreature, says "definitely lost"..is that a good thing?
04:17:50 <cocreature> no :)
04:17:58 <cocreature> that’s a bad thing
04:17:59 <haskell_noob1> hmmm.
04:18:24 <cocreature> valgrind has a --leak-check=full option iirc (it should tell you about that at the end of the output)
04:18:40 <cocreature> if you compiled your C source with debug info you should get pretty decent info out of that
04:18:42 <haskell_noob1> here is the record: https://lpaste.net/208509667104522240
04:19:01 <mreh> is it possible to say, keep track of the branching factor when evaluating a search tree with the list monad?
04:19:28 <haskell_noob1> cocreature, so looks like there is an issue with the bindings.
04:19:49 <cocreature> or with the way you are using the bindings
04:20:33 <haskell_noob1> it has to be the former, because i am writing this myself.
04:20:35 <haskell_noob1> :)
04:20:40 <cocreature> afaik some applications also do very weird stuff that confuses valgrind so it might be worth doing a quick check if you can find any reports of false positives for hdf5
04:20:43 <cocreature> heh
04:22:15 <haskell_noob1> thanks for the tip. Makes sense. cocreature. I did a simple alloc/realloc in a loop and things seemed to work..but thats like a stretch.
04:24:40 <mreh> from Control.Monad.List: "this does not yield a monad unless the argument monad is commutative"
04:24:49 <mreh> anyone able to shed some light on that statement?
04:25:00 <cocreature> haskell_noob1: compiling with dwarf debug info can also be useful for getting more info out of tools like valgrind
04:25:09 <sras> I am using the Gloss library (http://hackage.haskell.org/package/gloss) to draw some graphs in my application. But when I run it from ghci, as long as I close the Gloss window, the ghci instance exits. Why is this?
04:25:29 <mreh> I just googled it: https://stackoverflow.com/questions/6089997/how-do-i-find-out-whether-a-monad-is-commutative
04:34:44 <LikosX>  /leave
04:54:49 <sras> I am using the Gloss library (http://hackage.haskell.org/package/gloss) to draw some graphs in my application. But when I run it from ghci, as soon as I close the Gloss window, the ghci instance exits. Why is this?
04:56:07 <tdammers> my guess would be that gloss binds to some C function somewhere that simply calls exit() or something equivalent
04:56:56 <tdammers> ghci doesn't run interactive expressions in a separate process, so if the guest code causes the process to end, it takes ghci down with it
04:59:30 * hackage base-compat-migrate 0.1.0.1 - Helps migrating projects to base-compat(-batteries).  http://hackage.haskell.org/package/base-compat-migrate-0.1.0.1 (AdamBergmark)
05:35:57 <wagle> is coq suitable for proving things about haskell programs, or should I learn isabelle/HOL?
05:36:25 <wagle> is coq suitable for proving things about haskell programs, or should I learn isabelle/HOLCF?
05:38:07 <Ferdirand> wagle: maybe you want Idris ?
05:38:32 <wagle> hmm..  i was wondering about agda/idris
05:41:43 <wagle> Ferdirand: why Idris?  (not disagreeing, just needed a heuristic for triaging my rampp up time
05:41:46 <wagle> )
05:43:25 <cocreature> it depends on what your goals are. if you want to prove things about existing Haskell code then liquid-haskell and hs-to-coq are probably your best options.
05:43:52 <cocreature> if you are writing something from scratch but want the end result to be Haskell code then Coq and Isabelle and their code extraction mechanisms might be worth a look
05:44:23 <cocreature> if you are just interested in proving things about programs in general, then you might also want to look at Agda or Idris
05:44:26 <wagle> i'm implementing from scratch
05:46:20 <Ariakenom> cocreature: What was different about that last use case?
05:46:41 <Ariakenom> Oh proven code that doesn't have to be Haskell
05:47:06 <cocreature> right
05:47:29 * wagle goes off chasing those leads
05:47:38 <cocreature> I guess Agda also compiles to Haskell so it probably also falls into category two
05:48:00 <cocreature> which of those tools is best also depends on the kind of code that you write
05:48:34 <cocreature> liquid-haskell is really good at linear arithmetic, e.g., proving that indices are in bound and whatnot
05:49:11 <Krisostoomus> https://imgur.com/a/CLT64
05:53:30 <Krisostoomus> https://imgur.com/a/CLT64
05:53:44 <cocreature> @where ops
05:53:44 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
05:54:44 --- mode: ChanServ set +o dibblego
05:55:04 --- mode: dibblego set +b *!*Krisostoo@*.dyn.estpak.ee
05:55:04 --- kick: Krisostoomus was kicked by dibblego (Krisostoomus)
05:55:28 <cocreature> thanks
05:55:38 --- mode: ChanServ set -o dibblego
05:59:32 <wagle> tanks for pointers!
05:59:39 <wagle> thanks, even
06:10:00 * hackage cassava-conduit 0.5.0 - Conduit interface for cassava package  http://hackage.haskell.org/package/cassava-conduit-0.5.0 (domdere)
06:13:30 * hackage lucid-colonnade 1.0.1 - Helper functions for using lucid with colonnade  http://hackage.haskell.org/package/lucid-colonnade-1.0.1 (andrewthad)
06:24:28 <sigma_> how to work with type synonyms with function
06:25:03 <sigma_> something like this type ConfigReader a = AppConfig -> a
06:27:24 <infinisil> sigma_: I don't understand your question
06:27:41 <sigma_> what does this mean 'type ConfigReader a = AppConfig -> a'
06:29:53 <infinisil> sigma_: Wherever you put "ConfigReader a" will get translated into "AppConfig -> a"
06:29:53 <Boomerang> It means that wherever you see `ConfigReader a` you can replace it by `(AppConfig -> a)`, you could create a value of this type with a lambda that takes an AppConfig for example.
06:30:19 <infinisil> And the a can be anything e.g. `ConfigReader Int` = `AppConfig -> Int`
06:31:16 <sigma_> an why is it useful
06:33:07 <infinisil> sigma_: Let's say you need to use the type `ReaderT (WriterT [String] (Env (Config [(Int, a, Bool)]))) IO` a lot
06:33:39 <infinisil> Instead of typing it out everytime, you can define `Foo a = ReaderT (WriterT [String] (Env (Config [(Int, a, Bool)]))) IO`
06:33:48 <infinisil> And then use `Foo a` instead of that monstrosity
06:35:10 <infinisil> Also can be used to have type synonyms to give them more meaning
06:35:20 <infinisil> E.g. type Username = String
06:36:34 <sigma_> infinisil : yeah that's the basic use i was aware of
06:37:06 <infinisil> sigma_: https://en.wikibooks.org/wiki/Yet_Another_Haskell_Tutorial/Type_advanced#Type_Synonyms
06:38:37 <osa1> do I have to recompile everything to install something that I've already build via cabal new-install?
06:45:40 <cocreature> osa1: by “install” you mean using regular “cabal install”?
06:45:54 <osa1> cocreature: yes
06:46:09 <osa1> I ended up copying the bin but I don't know why I can't just cabal install, it's already built
06:47:33 <__monty__> The classic cabal commands don't understand the new-* commands afaik.
06:47:44 <cocreature> osa1: there is no sharing between old build and new-build
06:48:09 <osa1> well there isn't a new-install so I don't know how to install otherwise
06:48:20 <cocreature> there is a new-install in 2.2
06:48:51 <cocreature> but only for packages on hackage
06:49:36 <lortabac_> hello, is there a way to abstract over Alternative Maybe and Semigroup (Either a b)?
06:49:58 <lortabac_> to get the behavior of "take the result of the first successful computation"
06:50:27 <cocreature> lortabac_: sounds like you might be looking for https://hackage.haskell.org/package/semigroupoids-5.2.2/docs/Data-Functor-Alt.html
06:50:53 <cocreature> or the First newtype for Maybe
06:51:30 <lortabac_> cocreature: Data.Functor.Alt seems exactly what I was looking for
06:52:36 <lortabac_> cocreature: I think the First newtype would be a little harder to use in my particular case
06:53:13 <cocreature> I don’t know your usecase so it’s hard to comment on that :)
06:54:47 <lortabac_> cocreature: I am writing a function that deals with JSON, and I want it to be able to decode with decode or decodeEither according to the desired result type
07:10:30 * hackage barbies 0.1.0.1 - Classes for working with types that can change clothes.  http://hackage.haskell.org/package/barbies-0.1.0.1 (DanielGorin)
07:19:38 <lyxia> this package... ^
07:21:35 <Ariakenom> lyxia: I've always wanted a Barbie with a monoid structure
07:22:03 <ventonegro> Profunctor Barbie
07:23:29 <dminuoso> Ariakenom: You get a traversable Barbie at least.
07:26:07 <Ariakenom> dminuoso: Well you get a Barbie with a monoid structure at Last
07:26:41 <dminuoso> "We get a container of a's for any Barbie-type when we make it wear a (Const a) . The Container wrapper gives us the expected instances for a container type."
07:30:55 <dmj`> lortabac_: this is the interface I had in mind https://gist.github.com/dmjio/a0710b26029c54785c72eccc38330310
07:34:50 <sheyll> hi, is there an ordered pair data structure with an ord instance that swaps the pair members before comparing the pairs?
07:34:57 <sheyll> in the standard lib
07:35:29 <infinisil> Um, just swap them yourself?
07:35:48 <orion> What's the current state-of-the-art for logging in large applications? I've heard good things about MonadLogger.
07:36:49 <sheyll> I am going to try logging-effect in production soon
07:41:27 <shapr> orion: works for me in scotty and spock
07:43:50 <orion> "Unlike other logging libraries available on Hackage, MonadLog does not assume that you will be logging text information." <-- that sounds neat.
07:44:29 <exarkun> text logs, so bad.
07:45:09 <shapr> all my logs are thunks that are only evaluated when the user looks at them </joke>
07:45:16 <Ariakenom> yes. you should use String logs
07:46:03 <shapr> I am happy I switched all my web dev stuff to Text
07:46:30 <orion> shapr: What was a major pain point you encountered when not using Text?
07:47:01 <nshepperd> normally Tree logs are the strongest
07:47:37 <shapr> orion: I started out switching my parsing from String to Text, then I switched all my web dev stuff.
07:47:57 <orion> Why did you switch your parsing?
07:48:13 <shapr> String is slow
07:48:35 <orion> Fair enough.
07:48:46 <shapr> orion: I mostly switched because I'm teaching my coworkers Haskell once a week, and they're all speed obsessed.
07:49:18 <shapr> So even if I could clearly demonstrate that writing Haskell required less time to accomplish a task, they didn't care unless the resulting code was faster than Python/Ruby/etc
07:49:50 <Ariakenom> shapr: Speed obsessed pythonistas?
07:49:53 <shapr> know your audience when giving a talk or teaching, right?
07:49:56 * shapr shrugs
07:50:25 <Ariakenom> Doesn't sound hard to impress at least. Did you benchmark?
07:50:31 <adjofun> Hello everyone! I'm searching for a paper, in which author explained away most arguments against functional programming by introducing parametrised types, and showed how they solve mentioned problems. I forgot the name of the paper, sadly =(
07:50:35 <shapr> Ariakenom: I did a comparison of Python Flask vs Haskell Spock, most people were only idly interested until I showed that Haskell Spock takes about a tenth of the time to do stuff.
07:50:36 <metalrain__> python/ruby seems quite low bar, but maybe runtimes are just so good
07:51:17 <shapr> Personally, I don't care much at all about the speed of the binary, I care about how quickly I can safely change the code to try new abstractions and data structures.
07:51:41 <shapr> I believe that changing the data structure or abstraction is always the best way to speed up a solution.
07:52:09 <ysangkok> what prompts your need for superlatives?
07:52:29 <Ariakenom> Sounds good. Are you gonna start with speed graphs next time? :p
07:53:01 <shapr> ysangkok: probably purely reactionary from what I perceive as the common programmer culture of speed of execution being the only important factor.
07:53:49 <shapr> yeah, I'd say it's frustration with speed obsessed coders who'd rather spend much more time writing a solution in C because they believe it will be faster to execute.
07:53:58 <adjofun> sharp: try C! Code is not always correct, but always fast =:)
07:54:15 <shapr> ysangkok: what do you think about that?
07:54:53 <metalrain__> yeah, speed of execution is hardly a factor unless you serve billions of users/requests.
07:55:18 <shapr> ysangkok: tror du att det är bra, eller?
07:55:20 <byorgey> "common programmer culture of speed of execution being the only important factor"  ---  https://www.cs.utexas.edu/users/EWD/ewd00xx/EWD32.PDF is a fun read =)
07:55:29 <zxzdfp> Just wondering why I can't use a constraint in a type synonym.
07:55:37 <zxzdfp> {-# LANGUAGE RankNTypes #-}
07:55:43 <zxzdfp> type Lens s a = Monad m => (a -> m a) -> s -> (a, m s)
07:55:48 <zxzdfp> This should work but
07:56:06 <zxzdfp> not in scope: type variable 'm'
07:56:44 <dmwit> Add an explicit forall. `type Lens s a = forall m. Monad m => ...`
07:56:46 <byorgey> zxzdfp: needs more 'forall'
07:56:50 <orion> shapr: Oh wow, I find myself in a similar position. I too am serving as a mentor fo co-workers.
07:56:54 <orion> for*
07:57:19 <zxzdfp> Oh, great.
07:57:28 <zxzdfp> Many thanks,
07:57:31 <shapr> Half this company has switched to Go because it's faster than Python, and has a type system.
07:57:59 <orion> shapr: Faster? As in the speed of the resulting executable or the development time?
07:58:43 <metalrain__> I think some need for speed is really human factor, need to improve/succeed/make change even if it would total system (or company) more inefficient.
07:58:44 <shapr> orion: faster execution for Go, and the type system means fewer errors found in the code.
07:58:54 <shapr> metalrain__: what do you mean?
07:59:01 <shapr> oh, I see
07:59:07 <shapr> put your fingerprints on it.
07:59:08 <shapr> ?
08:00:48 <orion> shapr: What do you think about this quote from Rob Pike, the creator of Go?: http://nomad.uk.net/articles/why-gos-design-is-a-disservice-to-intelligent-programmers.html
08:02:45 <shapr> orion: PHP is popular because it's easy to learn and does html templating decently, I think that's the goal of Go as well.
08:03:17 <shapr> I get that, and coworkers here say that fresh college graduates can pick up Go quickly and be productive on just about any project, whether it's new dev or maintenance.
08:03:22 <orion> shapr: Makes sense. How did you convince your co-workers that Haskell is worth learning?
08:03:26 <orion> Over Go.
08:03:50 <shapr> Mostly I haven't, I give free lunchtime classes once a week, and it started out with twenty people, now it's two regulars and sometimes up to five others.
08:04:17 <shapr> paul graham talked about the blub paradox, where you can't understand a more powerful programming language than you write, and I see that often.
08:04:43 <shapr> Two or three of the most enthusiastic Go coders here were unable to understand why I would want Functor or Monoid in a programming language.
08:06:18 <shapr> The enthusiastic go coders here sometimes say "Go is a *productive* language" and it seems like they're implying it's just about getting stuff done, and not screwing around with programming language toys.
08:06:30 * hackage servant-dhall 0.1 - Servant Dhall content-type  http://hackage.haskell.org/package/servant-dhall-0.1 (phadej)
08:08:49 <infinisil> shapr: Whats the answer to the Functor/Monoid question? So that you can make your functions more generic, without requiring a specific instance?
08:08:50 <zxzdfp> When do I get " -Wdeferred-out-of-scope-variables " error?
08:10:10 <shapr> infinisil: Someone wrote a big pile of code to convert a deeply nested structure to protobuf, I tried to use that as a way to demonstrate the advantage of using fmap, but I don't think they understood.
08:10:25 <drets_> I am using esqueleto, is it possible to return custom data type from `from`? Now I am returning the tuple: https://lpaste.net/526766138147733504 When I tried to use custom data type I faced the issue that the record has ,say, the type Text but ^. operation returns `expr (Value typ)` (I dunno how to “unwrap” expr).
08:10:50 <shapr> We have many singe-purpose big piles of code for traversing specific deeply nested values, and to me that's a problem.
08:10:52 <nshepperd> it's hard to explain the benefit of a whole ecosystem of generic functions by pointing to a single example
08:11:05 <shapr> nshepperd: any other ideas?
08:11:24 <infinisil> shapr: Ah yes
08:11:25 <nshepperd> not really
08:11:28 <Ariakenom> shapr: I was gathering some simple "bullet point" features of Haskell. I'll try to find them if you'd like
08:11:30 <nshepperd> it's hard for me too :)
08:11:31 <Ariakenom> I'd love additions
08:12:51 <nshepperd> i suppose i would compare fmap to arithmetic operators
08:13:14 <Ariakenom> shapr: https://lpaste.net/365286 Think some aren't clear from what I wrote down but still
08:13:14 <nshepperd> it would be annoying if you had to import a different operator for every numeric type
08:13:23 <shapr> I'm finally starting to understand why Haskell looks like incomprehensible magic to most coders, they've never even considered thinking in these patterns. It's all about the Blub Paradox.
08:13:48 <Ariakenom> I mean it's also the syntax
08:13:56 <Ariakenom> Which is great. But different.
08:14:34 <nshepperd> that's the 'single example' point of view: having a single (+) lets you avoid importing operators for different numbers, which gets a 'huh, that's convenient I guess'
08:15:17 <shapr> purity means I have less to fill up my working memory when writing a function
08:15:26 <nshepperd> but the real benefit of (+) being (+) is that once you're familiar with it, reading any code that does arithmetic is natural
08:15:31 <nshepperd> regardless of the number type
08:15:35 <shapr> I think Go is trying to also reduce the amount of working memory required, but by cutting the language down.
08:16:08 <shapr> It's hard to describe how all the cool features are more than just the sum of their parts.
08:16:10 <Ariakenom> I made my list because I wanted blub resistant, easily explained points
08:16:23 <adjofun> Go assumes that language innovations stopped in 1970s, I feel
08:16:54 <shapr> adjofun: it has some strange and interesting points like goroutines and 'methods' but mostly, I agree
08:17:08 <dstolfa> shapr: it's similar to the experience people have when thinking about denontational semantics in general. if you show them operational semantics of something, they instantly grok it if they're computer scientists, but denotational semantics can be counter-intuitive to people
08:17:13 <orion> Ariakenom: I like the separation of side effects.
08:17:42 <shapr> So I'm thinking of taking a Go position for six months so I have a deep understanding.
08:17:54 <orion> Ariakenom: Also, the very concept of a "Kind" is a nice feature.
08:18:05 <dstolfa> i.e. telling someone that natural numbers can be defined in terms of zero being a natural number and some function S which takes a natural number and returns a natural number is counter-intuitive to people because they suddenly think: but what is a natural number, it's defined recursively and S has no meaning in terms of what it does with a natural number!
08:18:12 <shapr> I'm also thinking of writing some Haskell code that detects variable shadowing in Go, since there aren't any tools to do that.
08:18:54 <Ariakenom> orion: I'm looking for things that would take seconds to sway a Java/go programmer. I don't think kinds fit.
08:19:16 <shapr> Ariakenom: what about mapReduce in Control.Concurrent?
08:19:40 <shapr> https://hackage.haskell.org/package/async-2.2.1/docs/Control-Concurrent-Async.html
08:20:08 <shapr> I say things like "pure code lets me distribute computations on all my cores, where race conditions and deadlock are impossible"
08:20:23 <orion> Ariakenom: My understanding is that in Java, you can express certain specific Monads such as [], but the abstract concept of a Monad is literally unexpressable/
08:20:42 <Ariakenom> orion: Correct. But a Monad is also not explainable :p
08:20:50 <adjofun> Ariakenom: Easy concurrency is your go-to feature, I think. Show STM, and walk away with a smile =:)
08:20:51 <Ariakenom> (correct afaik)
08:20:58 <orion> Further, Monads are not expressable without Kinds.
08:21:19 <Ariakenom> adjofun: I've included it https://lpaste.net/365286
08:21:41 <shapr> I agree that I've swayed people by saying "I have code that uses threads with provable lack of deadlock/livelock/race conditions"
08:21:57 <Ariakenom> Yes. It is my favourite example
08:22:28 <adjofun> I just said to my colleagues that CompletableFuture<T> is a monad, and that in Java 8 are 3 monads now, including Optional<T> and Stream<T>
08:22:36 <Ariakenom> Although caveat -fno-omit-yields
08:22:47 <adjofun> They told me that "monad" is a curse word =\
08:23:06 <Ariakenom> on the livelock thing
08:23:49 <Ariakenom> Another example on my list that I found baffling when I started Haskell is maxBound
08:25:02 <Ariakenom> The maxBound of some type that has one. Type is inferred. Just great
08:25:26 <int-e> adjofun: "monad" is far less scary than "java" :)
08:25:31 <orion> ha
08:26:00 <Ariakenom> I guess my polymorphic max function doesn't apply much. Even Java can do that now that it has generics I guess
08:26:21 <adjofun> orion: There is a library for Java, callem cyclops-react, and they have something called AnyM, which allows to white monadic code without dependency on any particular monad. What do you mean by "unexpressible" then?
08:26:21 <jackhill> Speaking of benefits/disadvanteges of Haskell over other languages: I read http://blog.khinsen.net/posts/2017/11/16/a-plea-for-stability-in-the-scipy-ecosystem/ and also Rich Hickey's talk, "Spec-ulation" https://www.youtube.com/watch?v=oyLBGkS5ICk and became concerned that Haskell (or at least all of us who write Haskell) isn't conducive to that sort of stability.
08:27:15 <Ariakenom> I'd also like to be able to say this but it's to abstract. "Haskell is also a language without side effects. Haskell has effects they're just not _side_ effects."
08:28:46 <Ariakenom> For a sufficiently interested audience I guess it works.
08:28:47 <orion> Ariakenom: It's not part of the core language.
08:29:10 <orion> adjofun: ^
08:29:11 <Ariakenom> orion: No I mean they're not functions with side effects. It's IO with effects.
08:29:23 <Ariakenom> Oh
08:29:26 <jackhill> A smaller language sounds like it would be more conducive (althought I guess there is then the temptation to make your own DSLs anyways). Are there ways to think about Haskell that would make it more palatable for code that I don't won't be under constant maintenance?
08:30:33 <adjofun> orion: Are you implying that if something isn't part of the core language, then it is inexpressible in the "not core" language, whatever that means?
08:31:02 <adjofun> orion: Typeclasses are not part of the Haskell Core language afaik
08:31:12 <adjofun> But we have Monads nonetheless
08:31:23 <orion> adjofun: Yes. Typeclasses are syntactic sugar.
08:32:23 <orion> I consider kinds in Haskell to be more fundamental to the language than typeclasses.
08:32:28 <shaylew> what's the canonical way to derive Eq1/Show1 etc?
08:34:35 <cocreature> shaylew: the deriving-compat package
08:36:42 <nshepperd> does AnyM really express Monads, or does it express a horrible kludge that kinda-sorta lets you write monad-generic code if you squint
08:38:18 <cocreature> nshepperd: can you link me to AnyM? I can only find anyM in monad-loops which is probably not what you’re referring to
08:38:37 <nshepperd> cocreature: some java thing https://github.com/aol/cyclops-react/tree/master/cyclops-anym
08:38:50 <cocreature> ah
08:38:57 <adjofun> https://medium.com/@johnmcclean/a-type-safe-java-monad-api-part-i-with-vavrs-future-and-try-7beaea28d351
08:40:35 <adjofun> I use that library everythere in my Java code, my colleagues have an allergy to haskell, unfortunately
08:42:29 <orion> 75% of my co-workers are excited enough about Haskell to read haskellbook.com *and* do the end-of-chapter problems.
08:46:13 <ventonegro> There was a bug opened about a stateful async handler and I said that would never happen in a pure language; they just ignored me
08:47:46 <adjofun> ventonegro: Yeah, I would also ignore that, that remark is not contributing to a problem solution, but trying to provoke a holywar =)
08:49:03 <ventonegro> adjofun: Fair enough
08:50:43 <orion> sheyll: Have you ever had to create a Monad transformer which uses multiple LoggingTs?
08:51:14 <sheyll> @orion no.. not that I am aware of
08:51:14 <lambdabot> Unknown command, try @list
08:51:29 <orion> sheyll: I am currently faced with that.
08:52:16 <orion> I am writing a library to interact with Microsoft Graph API. That library is its own Cabal package, and it needs logging. I am writing an application which uses this library, and it needs its own logging.
08:52:43 <AWizzArd> Let’s say I have  data Term e = Lit Lit | Var String (e -> Term e)  (ignoring what a Lit is). So I have Literals and Vars. And a Var should have a name (String) and a lookup function from some environment to a Term.
08:52:47 <AWizzArd> The idea is that Vars can be looked up at runtime to see what they stand for. Now what if I wanted to use a Data.Map.Strict as a backend store for vars that goes from Strings to Terms? Is it possible to specify a type signature for this case?
08:52:52 <AWizzArd> I am having difficulties to see how this can be done. I can not introduce a varmap of type:  varmap :: M.Map String Term    because here `Term` does not include the `e` environment. But this very map is the environment. So it looks like an infinite recursion. Does that make sense?
08:53:49 <infinisil> This `Term` type looks very weird, why e -> Term e?
08:54:25 <infinisil> Oh, I see, that's the environment, hmm
08:54:27 <sheyll> orion what do you compose, like this: LoggingT (BlahT (BlubT IO)) ?
08:54:51 <AWizzArd> infinisil: should an existential type be used here?
08:54:51 <orion> My Microsoft Graph API library defines a Monad transformer: LoggingT GraphLog (ReaderT GraphEnv m) a.
08:54:59 <infinisil> AWizzArd: I'd separate the term from the environment
08:55:28 <infinisil> AWizzArd: Have a type that represents a term, have one that represent the env (a Map), then have a function `eval` that takes a term and an env and evaluates it
08:55:47 <orion> So the question is: Will this compose nicely when an application wishes to define something like: AppT = LoggingT AppLog (GraphT m) a?
08:56:08 <orion> I *think* it'll work OK.
08:56:08 <AWizzArd> infinisil: yes I want that. So what would your Term declaration look like?
08:56:21 <adjofun> AWizzArd: If I were to define `x = Var "foo" (M.lookup env)`, would I need to define every Var with a same (M.lookup env)?
08:56:21 <infinisil> Well what does your language look like?
08:56:27 <sheyll> isnt there a mapLoggingT or something?
08:57:04 <infinisil> AWizzArd: If my language is just + and numbers, I'd have `data Term = Lit Int | Sum Term Term`
08:57:23 <sheyll> in logging-effect there is a mapLogMessage :: MonadLog message' m => (message -> message') -> LoggingT message m a -> m a
08:57:24 <orion> sheyll: There is. I haven't actually finished the library yet. My question is an act of planning ahead.
08:57:39 <orion> I don't want to code myself in to a box.
08:57:48 <sheyll> so you are using LoggingT from logging-effect, right?
08:57:58 <orion> Yes. As of 20 minutes ago.
08:58:03 <AWizzArd> adjofun: yes, probably one hashmap for all vars that were introduced.
08:58:06 <sheyll> lol
08:58:23 <orion> Literally based (in part) on your recommendation my company is going to use this library.
08:58:30 <AWizzArd> infinisil: I would not want to limit the lang by making Sum explicit. Instead it has a Fn (or Lambda) and an App for application.
08:59:29 <adjofun> AWizzArd: what does "Vars can be looked up at runtime to see what they stand for" mean?
09:00:04 <AWizzArd> adjofun: I may want to compare  x with 10.  I.e.  x == 10.   I don’t know what x is before I run this.
09:00:53 <adjofun> so, Var "x" (M.lookup env) == Lit 10?
09:01:32 <AWizzArd> adjofun: yes, something like that right.
09:01:50 <adjofun> are you sure you don't just want `Var String Term`?
09:01:57 <infinisil> AWizzArd: `data Term = Var String | App Term Term | Lambda String Term`?
09:02:06 <AWizzArd> adjofun: I am not sure. Possibly this can work.
09:02:15 <infinisil> Var is a variable reading, App is function application, lambda is lambda
09:03:12 <shaylew> AWizzArd: if you want to go down the mutual recursion path you can make it work with a newtype VarMap = VarMap (M.Map String (Term VarMap)) -- it's only type synonyms that can't be self-referential. but I don't know enough about what you're trying to do to tell whether this is a good idea
09:03:27 <AWizzArd> infinisil:    Fn String (Term -> Term) | App Term Term
09:04:01 <infinisil> Ah
09:04:05 <AWizzArd> shaylew: thx for the hint, I can consider this too and look into it.
09:04:27 <chindy> Is it possible/good practice to transform Maybe String to IO String ? if so how?
09:04:40 <adjofun> AWizzard: I think you are trying to substitute type recursion with a map lookup
09:04:52 <infinisil> AWizzArd: Wait no, Fn String Term should work
09:05:02 <infinisil> Or I just don't get it
09:05:02 <AWizzArd> infinisil:  an example:     equal = Fn "==" (\(Lit (I arg1)) -> Fn "==" (\(Lit (I arg2)) -> (Lit (B $ (arg1 == arg2)))))    and    prog = (App (App equal (Lit (I 33))) (Lit (I 33)))
09:05:05 <adjofun> chindy: of cource, everything is possible, but what semantics do you need?
09:05:11 <kritzefitz> chindy: What would the result be when the Maybe String is Nothing?
09:05:29 <chindy> Then I do not want to write into a file kritzefitz
09:05:47 <kritzefitz> The you probably want mapM
09:06:05 <kritzefitz> Like mapM whateverYouWantToDo yourMaybeString
09:08:41 <AWizzArd> It’s just if I don’t want to compare two Int literals but a var with an Int literal. I am not sure how to best model this.
09:09:30 * hackage asn 0.1.0.0 - asn type and encoding/decoding  http://hackage.haskell.org/package/asn-0.1.0.0 (chessai)
09:09:31 <adjofun> chindy: when (isJust x) (write (fromJust x))
09:10:23 <chindy> adjofun: whats this when construct?
09:10:29 <adjofun> :t when
09:10:30 <lambdabot> Applicative f => Bool -> f () -> f ()
09:10:50 <chindy> Anyways, thanks i think I got what I wanted
09:10:57 <chindy> when happens if Bool is false?
09:11:03 <adjofun> nothing
09:11:34 <kritzefitz> chindy: when False _ = return ()
09:11:47 <chindy> ah thanks
09:11:57 <orion> Does anyone have a good example of how to define an instance for MonadTrans? GHC is unable to automatically derive one.
09:12:09 <orion> (even with cunning GeneralizedNewtypeDeriving)
09:12:09 <kritzefitz> chindy: Did you see my answer above? It basically does the same, but with less typing.
09:12:17 <cocreature> orion: have you linked at the existing instances?
09:12:35 <adjofun> :t mapM
09:12:37 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
09:12:38 <adjofun> :t fmap
09:12:39 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:13:00 <adjofun> hm
09:13:08 <Np-Harda`> hello everybody
09:13:12 <chindy> kritzefitz: yea, thanks
09:14:50 <orion> cocreature: You're correct, that is where I should have looked before formulating my question.
09:14:51 <Np-Harda`> can you hear me? dI dont know if my emacs-client is conetcted the right way
09:15:29 <cocreature> Np-Harda`: yes
09:15:59 <Np-Harda`> fine thats nice
09:16:30 * hackage multihashmap 0.1.0.0 - hashmap from keys to hashsets  http://hackage.haskell.org/package/multihashmap-0.1.0.0 (chessai)
09:17:42 <Np-Harda`> I just started learning haskell and started a project. What resources do you recommend learning some best practice in haskell?
09:20:04 <sm> https://haskell-lang.org/get-started
09:20:31 <sm> https://leanpub.com/haskell-cookbook/read
09:21:42 <cocreature> jasper’s talk is pretty good https://www.youtube.com/watch?v=-X1vrxQUETM but it’s probably something to watch once you’ve played around with Haskell for a bit not in your first week
09:21:44 <metalrain__> Np-Harda`: there are quite good books http://haskellbook. com and http://learnyouahaskell.com
09:21:52 <cocreature> I wouldn’t worry too much about best practises at the beginning tbh
09:22:13 <sm> https://wiki.haskell.org/Haskell
09:22:42 <Np-Harda`> ahh thanks a lot
09:23:29 <Np-Harda`> I did some functional programming before, so I am familiar with it and i basicaly understand monads
09:24:22 <cocreature> I would recommend to just find some small toy project to work on and then ask for feedback on that
09:24:37 <cocreature> or improve it yourself by taking a look at how other people have solved similar problems
09:24:39 <Np-Harda`> thats what I am currently doing
09:25:06 <Np-Harda`> I am working on a small server communicating with bitcoind
09:25:57 <Np-Harda`> is it normal that most of my function signatures are polluted with the IO monad? is this considered normal?
09:26:46 <sm> Np-Harda`: if they're doing IO, then yes
09:26:50 <cocreature> heavily depends on your program. if your program mostly communicates with some other server then having a lot of that be in IO is not that unreasonable
09:27:37 <sm> often you can convert them to non-IO by restructuring
09:29:36 <Np-Harda`> sm: do you mean restructuring the project?
09:29:36 <Np-Harda`>  
09:29:47 <sm> just the code
09:30:15 <sm> sometimes you have IO functions that can be made pure
09:30:47 <Np-Harda`> yeah I am try that
09:31:02 <cocreature> what happens more often ime is that your IO stuff stays in IO but you can extract some pure functions from those IO functions
09:31:58 <cocreature> you might have something like "do input <- fetchData; let output = processInput input; sendOutput output"
09:32:07 <cocreature> fetching and sending data will require IO but process the input might not
09:32:14 <cocreature> so you can separate that out into a separate definition
09:32:15 <Np-Harda`> another question, I have a function which returns eigther Data or IO Data. Can I construct the case in which it returns just the Data into something such that the whle function just returns IO Data?
09:32:37 <Np-Harda`> cocreature: I am already trying to do that
09:32:41 <cocreature> you can use "pure" for that
09:32:45 <cocreature> :t pure
09:32:47 <lambdabot> Applicative f => a -> f a
09:32:53 <cocreature> :t pure @IO
09:32:54 <lambdabot> error:
09:32:54 <lambdabot>     Pattern syntax in expression context: pure@IO
09:32:54 <lambdabot>     Did you mean to enable TypeApplications?
09:34:04 <Np-Harda`> ahhh ok thank you I will try that
09:35:59 <Np-Harda`> cocreature: works well thank you
09:36:27 <pie_> not really a haskell specific question just thought someone here might be well equipped to answer; ive been meaning to get into UI development since it seems like an area that could use a lot of improvement, but i havent really been able to figure out how to get started
09:36:46 <pie_> * for native apps, not web stuff
09:39:27 <Np-Harda`> whats the difference between pure and return?
09:39:40 <dminuoso> Np-Harda`: historical reaasons.
09:39:53 <dminuoso> Np-Harda`: return incurs a Monad constraint, pure incurs only Applicative
09:40:02 <glguy> pure works in more contexts, but the two should behave the same
09:40:05 <dminuoso> Np-Harda`: For any instance Monad it is required that `pure = return` behaviorwise
09:40:16 <Np-Harda`> ok which one should I use then?
09:40:22 <gonz_> Np-Harda`:  `pure`
09:40:23 <dminuoso> Np-Harda`: If you are unsure use `pure`
09:40:34 <Np-Harda`> ok perfect thank you
09:40:36 --- mode: glguy set -bb *!*@117.194.198.142 *!*@117.194.195.189
09:41:04 <Np-Harda`> I never thought this, but haskell is quite fun to programm in
09:41:18 <Np-Harda`> much more than what I am used to do :D
09:43:22 <gonz_> Np-Harda`:  I felt the same way when I started getting into it. I think the lore surrounding Haskell (largely retold by people who never bothered to learn it) scares a lot of people
09:43:33 --- mode: glguy set +q Krisostoomus!*@*
09:45:17 <Np-Harda`> I am currently doing my M.Sc in computer sience and have compiler construction as a main field, which is why I got into type theory a little bit. Thats why i thought haskell would be fun to learn and it fuckin is
09:45:31 <orion> Is it possible that return will be deprecated?
09:46:10 --- mode: glguy set -bbbb *!*@gateway/web/freenode/ip.87.82.211.21 *!*@212.110.89.62 *!*@*.5.150.112.164 *!*@gateway/web/freenode/ip.5.150.112.164
09:46:21 <cocreature> orion: probably not. what is planned (or was planned at some point, I haven’t kept track) is to move return out of Monad so you can no longer overwrite it and will be guaranteed that return = pure
09:46:28 <dminuoso> orion: https://ghc.haskell.org/trac/ghc/wiki/Proposal/MonadOfNoReturn
09:47:09 <dminuoso> Np-Harda`: Sadly there are very few languages that admit the advancements of the past 20 years and incorporate them into their design.
09:48:15 <gonz_> dminuoso: But new language features get in the way of being practical, you know ;)
09:49:33 <dminuoso> gonz_: One common argument of some mainstream languages is that many such features are "complicated" and require training to utilize. While I admit that it is a reasonable argument to make, it tends to introduce other issues.
09:49:42 <Np-Harda`> The "new" languages we see like rust, go, scala are pretty decent I think
09:50:32 <Np-Harda`> and at least most of them having nice functional features
09:50:48 <Np-Harda`> scala even has the for expressions for monads
09:50:59 <orion> dminuoso: Thanks.
09:51:33 <gonz_> dminuoso:  I agree completely. I was honestly shocked by how ergonomic Haskell is when I got into it. To me it seems like Haskell is one of the most practically inclined languages out there, because of the ease and possibility of abstraction.
09:52:17 <gonz_> But I honestly think that OCaml, for example, has more of a reputation of being "practical" even though the ergonomics clearly are not there, mostly because it doesn't stress lack of effects
09:52:33 <gonz_> At least that's my perception of the development community
09:52:44 <gonz_> And it doesn't match what I think from using both languages
09:55:12 <kuribas> dminuoso: when I program in another language, I am amazed how hard it is.
09:56:17 <pie_> "i find programming in every languge hard but haskell is the least hard"
09:57:01 <Np-Harda`> I am not at this point tbh I hope to get there as well
09:58:24 <dminuoso> kuribas: What I mean by that, is that it takes time to study and learn abstractions. Go is designed to take someone out of high school and have them write driver code within a week.
09:58:47 <kuribas> dminuoso: yes, same thing with python
09:58:59 <kuribas> dminuoso: easy to learn, very hard to program in.
10:00:31 <Np-Harda`> I do all my machine learning and AI stuff in python
10:00:33 <kuribas> dminuoso: the mental effort for writing in haskell is much lower than in other languages IMO
10:01:01 <Np-Harda`> I hate the dynamic type system
10:01:19 <kuribas> Np-Harda`: sure, for small(ish) scripts it's fine.
10:01:38 <kuribas> but anything more complex, it becomes a big mess easily.
10:02:11 <dminuoso> Np-Harda`: There is no such thing as a dynamic type system.
10:02:53 <Np-Harda`> dminuoso: I hate that python is dynamicaly typed :D
10:02:56 <Np-Harda`> better? :D
10:03:13 <monochrom> Aw please don't argue wording.
10:03:23 <cocreature> monochrom++
10:03:54 <ddellacosta> cocreature++
10:04:20 <sm> python is runtime-typed rather than compile-time-typed ?
10:04:20 <monochrom> Also if you're going down that philosophical route, you may as well remind all of us "temperature does not exist, only velocities of gas particles exist"
10:04:41 * sm can't help inquiring
10:04:42 <geekosaur> molecular vibration, actually :p
10:04:58 <kuribas> ddellacosta++
10:05:15 <ddellacosta> kuribas: now the question is when all of these get evaluated
10:05:43 <monochrom> IOW the Bob Harper "no dynamic typing, it's static unitype" is a reductionist stance that ignores an emergent phenomenon.
10:06:49 <dminuoso> monochrom: It's not about ignoring the emergent phenomenon - it's comparing two orthogonal things.
10:07:03 <kuribas> a static unitype with mostly non-total functions
10:08:12 <dminuoso> monochrom: When a type system becomes a method to have automated proofs of the abscence of certain program behaviors according to some operational model, then in what possible sense does comparing it with python runtime tag checking make sense?
10:08:19 <dminuoso> It would imply there's some fundamental similarity between the two.
10:09:06 <monochrom> That starts with the premise that "type" is machine-checked data invariant.
10:09:51 <dminuoso> If I take the definition from TaPL, then types are just some tags I decorate terms with. It's a syntactic method
10:10:29 <monochrom> And it becomes revisionist history. Because "type" began as set/class/whatever-collection of values mutually compatible in terms of operations.
10:11:12 <geekosaur> .oO { porqué no los dos? }
10:13:38 <dminuoso> monochrom: But isn't it reductionistic to only consider the "collection of values mutually compatible in terms of operations" because that's all that Python can do?
10:13:41 <monochrom> It's OK to say that the very original origin is outdated and we should move on to a more modern notion.  I agree, I do that too.
10:14:12 <dminuoso> I mean one of the guarantees that Haskells type system gives you, is the absence of segfaults (ignoring certain choices of backdoors). Python gives you that same guarantee.
10:14:20 <dminuoso> But that's about the extend of it.
10:14:40 <monochrom> And instead of TaPL, I take my definition from a formal methods paper that makes "type" data invariant (not necessarily machine-checked).
10:15:38 <__monty__> Then python still doesn't have types. Since the type is a field of the objects.
10:15:48 <monochrom> No, reductionist means what my example says, "there is no temperature, you only have vibrating molecules"
10:16:36 <monochrom> Bob Harper's is reductionish because dynamic typing (a high-level idea) is implemented by static unitype with runtime tag checks.
10:16:48 <orion> Temperature is defined as average kinetic energy.
10:17:00 <geekosaur> there's multiple definitons of temperature
10:17:02 <Np-Harda`> ok guys :D i build my project with `cabal install -j` on my x64 machine and then copied the binary over to my x64 server. when I run the binary I get [1]    4767 illegal hardware instruction  ./FirstHaskellProject
10:17:08 <geekosaur> they interact in odd and not always understood ways
10:17:18 <monochrom> Reductionism means you say that the high-level thing doesn't exist, only the low-level implementation detail exists.
10:17:32 <dmwit> Np-Harda`: Nice! Any fun FFI stuff in it?
10:17:35 <dminuoso> monochrom: Ah I see what you are on about.
10:17:42 <dmwit> Np-Harda`: How small of a program can you make and still reproduce that problem?
10:17:55 <geekosaur> or libs using some sse / avx / hatever that the server's cpu doesn't support
10:17:59 <geekosaur> *whatever
10:18:04 <dminuoso> monochrom: So first let me agree that conceptually there's nothing wrong with talking about the "high-level idea" of "dynamic typing" as you put it. It's not what I have an issue with.
10:19:05 <Np-Harda`> actualy I dont know if any of my libs is using SSE, but could be the case, because I use some SHA256 hashing
10:19:14 <dminuoso> monochrom: But the wording suggests that, on some level, it's comparable with what a type system does. The mere comparison of "type system" vs "runtime tagging checking" is fruitless because it's essentially comparing two orthogonal things.
10:19:26 <geekosaur> even worse, yes, you may be dependent on something having detected hardware SHA
10:19:32 <orion> monochrom: Would you provide a link to the paper?
10:19:37 <Np-Harda`> any chance building the binary without SSE command?
10:19:44 <orion> "a formal methods paper"
10:19:57 <monochrom> orion: I read it on physical paper.
10:20:02 <Np-Harda`> or other hardware specific instructions?
10:20:05 <orion> monochrom: Oh, I see.
10:20:23 <monochrom> But I bet searching for "type data invariant" may find it.
10:20:30 <geekosaur> you'll likely hve to check what libs you are using. ghc itself doesn't do things like this for the most part, math or crypto libs may contain FFI hackery that does
10:20:37 <dmwit> monochrom: That does not a priori prevent you from providing a link to the paper.
10:20:45 <geekosaur> in which case look for build flags for those libs
10:20:56 <monochrom> Err, no, that won't find it.
10:20:56 <cocreature> dminuoso: the thing is you are not going to win a fight trying to eliminate the word “dynamic typing” so instead of telling people they’re wrong to call it that you can just accept that the word “type” does not mean the same thing to everyone and make it clear which definition you are using if that’s not clear from the context
10:21:11 <dmwit> monochrom: (Or at least the title and maybe some author info...)
10:22:15 <Np-Harda`> geekosaur: i am building some http connection in the programm so there is definitly some crypto stuff involved
10:22:22 <Np-Harda`> daaammmn that sucks ...
10:22:30 <dmwit> Np-Harda`: Step 1 is produce a minimal test case.
10:23:06 <phaazon> quickie: in PVP, 1.2.3 has which semantics?
10:23:10 <phaazon> major.minor.patch?
10:23:15 <phaazon> or super-major.major.minor?
10:23:21 <sm> ma.jor.minor
10:23:28 <glguy> https://pvp.haskell.org
10:23:36 <phaazon> that’s what I thought, thanks :)
10:23:44 <Np-Harda`> dmwit: I will try to do so
10:23:52 <Np-Harda`> but its already pretty minimal
10:24:12 --- mode: glguy set -o glguy
10:24:47 <monochrom> Perhaps dminuoso just objects to "dynamic type system" because it has no system to speak of.
10:27:07 <monochrom> But people still say "the latest programming technology" even when it has no technology to speak of.
10:27:32 <monochrom> Oh and "software engineering"
10:28:04 <orion> monochrom: What do you mean by "software engineering" (in quotes)?
10:28:06 <EvanR> "interpretive folk logic"
10:28:21 <geekosaur> orion, I think that's the point
10:28:45 <geekosaur> nobody means the same thing by it. like nobody necessarily means the same thing by "type"
10:28:50 <geekosaur> or "type system"
10:29:07 <dmwit> Therefore we should all stop trying to talk to each other in the first place.
10:29:38 <geekosaur> there've been times when it's seemed futile… but that's why someone mentioned setting out definitoons up front instead of assuming everyoen uses yours
10:29:55 <cocreature> dmwit: talking considered harmful!
10:30:19 * geekosaur thinking of something  coupel months ago in here that was brain-breaking until it came out they were talking about vhdl
10:30:36 <shafox> Repost:: How do I create a rose tree while parsing a text file using megaparsec/attoparsec etc ? Related code and text file example is here in this gist https://gist.github.com/shadow-fox/acd2ce8977e0c28c5f6fa31fe9445133
10:30:38 <monochrom> haha
10:31:06 <orion> geekosaur: What are the two most common uses of "software engineering"?
10:31:22 <orion> I guess I should direct that question to monochrom.
10:31:36 <geekosaur> 1. copying someone else. 2. reaching for something that sounds better than "programmer"
10:31:50 <monochrom> I believe that when people write "dynamic type system", with the "system" word there, they're just doing it out of habit, they don't really mean it.
10:32:01 <geekosaur> (note absence of what you might expect to find in there...)
10:32:17 <monochrom> What geekosaur says
10:33:05 <dmwit> shafox: There are several parser combinator tutorials out there. I recommend you work your way through one. Nothing about the data you've showed or the structure you intend to parse it into looks particularly difficult once you know the basics.
10:33:21 <EvanR> is talking about talking futile, harmful
10:33:44 <EvanR> also talking about the previous statement is forbidden
10:34:06 <geekosaur> russell's paradox in natural language?
10:34:06 <shafox> dmwit: I am just not sure how do I insert at the correct level.
10:34:57 <dmwit> You don't insert at all. You just write a recursive parser.
10:35:07 <nitrix> Does GHC/C-- ultimately monomorphize every type during compilation by generating a unique data structure per polymorphic variant, or the runtime has additional logic to handle those?
10:35:34 <dmwit> Neither. Everything has a uniform representation (pointer) so neither of those things is needed.
10:35:51 <nitrix> Interesting.
10:35:54 <shafox> dmwit: alright. lemme try.
10:36:18 <dmwit> I can prove that it does not monomorphize by producing a program with an infinite set of possible types at runtime (determined by user input which ones get used).
10:36:23 <orion> geekosaur: If you are paid to architect and write code for large scale systems, what job descriptor would you use instead of "software engineer"?
10:36:27 <geekosaur> nitrix, in polymorphic situations either it is ignoring the polymorphism (e.g. length :: [a] -> Int, it doesnt need to care about the a at all) or using a passed record containing the appropriate mehcnaisms for the actual type (typeclasses)
10:36:44 <dmwit> I cannot prove that it doesn't do the latter by experiment. You'll have to just believe me, or check the source yourself.
10:37:54 <geekosaur> orion, I feel like you're misfocused. it is not that "software engineering" is in and of itself a bad term; it is that it gets overused
10:38:01 <geekosaur> for things that arguably are not
10:38:16 <exarkun> Most people involved with don't engineer software, they only write it.
10:38:17 <nitrix> dmwit: I like that approach. How does one create infinite set of types at runtime? Don't you need dependent types for that?
10:38:20 <geekosaur> the problem is that the term is also used for writing a 5-line program
10:38:25 <orion> geekosaur: Ah. Is it a term worth saving?
10:38:35 <geekosaur> only if you can figure out how to save it.
10:38:47 <geekosaur> (good luck with that. people will do what people will do.)
10:39:22 <orion> I wonder what a good replacement term would be, given that saving it is probably futile.
10:39:32 <dmwit> nitrix: No, polymorphic recursion is enough. I have some SO writing on the topic that I will give you a link to, one moment please.
10:39:43 <exarkun> orion: Computer Programmer
10:39:50 <orion> ha
10:40:18 <exarkun> or even more accurate, Computer Toucher
10:40:28 <geekosaur> there's little point. semantic drift will happen
10:40:35 <ddellacosta> my problem with "software engineer" is that in other fields, "engineer" has much more rigorous requirements before anyone can call themselves an engineer
10:40:35 * geekosaur forgets the exact formal term atm
10:40:51 <dmwit> nitrix: https://stackoverflow.com/a/11422333/791604
10:40:54 <geekosaur> people use language as they will
10:40:59 <exarkun> geekosaur: mostly
10:41:01 <dminuoso> ddellacosta: and equivalently "programmer" has usually no requirements before you can call yourself a programmer. =)
10:41:20 <exarkun> geekosaur: although if you call yourself a civil engineer, there are certain penalties if you mean something different by that than the State means.
10:41:30 <dminuoso> "Never wrote a line of code in your line? Feel free to call yourself a programmer"
10:41:34 <nitrix> dmwit: checking
10:41:35 <exarkun> So, you could save "software engineer" by legislating a meaning.
10:41:44 <exarkun> And fining/jailing people who misuse it.
10:41:51 <geekosaur> exarkun, sure. and as always, pressures to change that.
10:41:52 <orion> I should create an elitist programming society.
10:41:55 <ddellacosta> dminuoso: ...which suits me fine. I think it's simply disingenuous for people--such as myself--who have no qualifications past experience in the field to call themselves by a term that in every other usage is pretty regulated
10:42:52 <__monty__> Computer science isn't a science so software engineering can't be engineering ; )
10:42:56 <ddellacosta> and let's acknowledge that the entire reason anyone wants to call themselves a software _engineer_ is exactly to create an association with the gravitas that term holds
10:43:12 <phadej> what's "civil" is in civil engineering?
10:43:32 <ddellacosta> sorry I fear I've helped get us pretty far offtopic
10:43:34 <monochrom> bridges, roads, apartments, etc
10:44:03 <phadej> monochrom: courteous and polite.
10:44:04 <phadej> "they were comparatively civil to their daughter"
10:44:12 <geekosaur> upon a time, it meant stuff used by normal folks instead of specialists
10:44:24 <geekosaur> "civilians"
10:44:42 <monochrom> I hate non-dead languages.
10:44:44 <geekosaur> these days, given the amount of electronic, RF, etc. engineering that goes into a modern cellphone, that definition's kinda lost
10:44:54 <__monty__> Pretty sure it was to distinguish from military engineering.
10:44:55 <phadej> I guess, it's original meaning is "non-military"
10:44:59 <phadej> __monty__: me too
10:45:06 <phadej> but that's the point, meaning of terms change.
10:45:11 <johnw> civil means "Pertaining to a city or state, or to a citizen in his relations to his fellow citizens or to the state; within the city or state."
10:45:14 <opqdonut> definitely not "non-military"
10:45:20 <opqdonut> yeah, what johnw said
10:45:35 <phadej> opqdonut: but in "civil aviation"
10:45:35 <johnw> being civil comes from "acting like a citizen"
10:45:46 <phadej> johnw: talking about "civil engineering"
10:45:51 <johnw> "Having the manners of one dwelling in a city, as opposed to those of savages or rustics; polite; courteous; complaisant; affable."
10:45:55 <geekosaur> yes
10:46:00 <opqdonut> I think "civil engineering" is "city engineering", right?
10:46:04 <geekosaur> and civil engineering can be seen as city ... that
10:46:06 <glguy> Which Haskell package are we talking about?
10:46:09 <johnw> yeah, building things needed by the city
10:46:16 <johnw> glguy: philology gets me every time
10:46:19 <johnw> ok, back to Haskell!
10:46:40 <ddellacosta> geekosaur: civil-recursion-schemes, I think
10:46:49 <geekosaur> did you mean glguy ?
10:46:53 <ddellacosta> er, glguy, yes sorry
10:46:54 <opqdonut> hmm, military-recursion-schemes
10:47:28 <phadej> anyway, I don't really seen anyone distinguish "software engineer, software developer, software programmer". Software architect somehow stands out.
10:47:40 <geekosaur> for now
10:47:58 <__monty__> Here everything from computer science and electronics over mechanical and chemical engineering is known as "civil engineering" as opposed to military engineering.
10:48:12 <geekosaur> ah, right, semantic treadmill, euphemism treadmill
10:48:14 <johnw> civilCata?
10:48:31 <phadej> OTOH, loaning a lot of analogies (via terms) from civil engineering isn't always good :(
10:48:43 <geekosaur> "software architect" is still young, it'll spread out the same way over time
10:48:50 <ddellacosta> ugh I hope not
10:48:59 * ddellacosta shivers
10:49:10 <geekosaur> deal. it *always* happens
10:49:23 <geekosaur> unless enfoced by e.g. law, at its own price
10:49:36 <geekosaur> (potentially including said law being so widely ignored as to have no real meaning)
10:49:46 <ddellacosta> geekosaur: you say that as though we, the people working in the industry, have absolutely no will to exert in relation to the matter
10:49:56 <phadej> yet, I heard people having job titles (vs. degree titles) as "integrator",
10:49:57 <ddellacosta> but, sorry, way offtopic now--let's take it to #haskell-offtopic
10:50:12 <phadej> maybe in near future it won't be as general as software developer, but rather "AI programmer"
10:50:16 <geekosaur> we have some will. butt (a) you say :we" as if it's a monolith with a single intent (b) you ignore what people outside it say of insiders
10:50:41 <chessai> sanity check: is the following safe?
10:50:41 <chessai> aToAny2 :: forall f a. (f a -> f a) -> (f Any -> f Any)
10:50:41 <chessai> aToAny2 = unsafeCoerce
10:51:06 <johnw> not if a is Void
10:51:09 <geekosaur> and one way that slide happens is someone in e.g. HR reaching for something that sounds good so it'll attract "the right people", with no real undrrstanding of intent
10:51:30 <chessai> johnw: ah! good point
10:52:00 <phadej> and if f is GADT
10:52:17 <nitrix> dmwit: I see. So big lambda, \T -> (T, T). Applied recursively to itself, the codomain blows up. You can monomorphize the (T, T) but you end up needing a uniform representation, where the T becomes pointers to another monomorphic type, or possibly, itself (creating the recursion).
10:52:45 <chessai> phadej: how so
10:52:56 <nitrix> dmwit: Looks like recursive types in general is the implementation challenge, not really polymorphism.
10:53:15 <edmundnoble> chessai: Because if it's a GADT and you match on `f Any` to get an `f Int`, you have a proof that `Any ~ Int`.
10:53:26 <edmundnoble> Which is very not good.
10:56:25 <chessai> edmundnoble: that makes sense
10:56:27 <nitrix> dmwit: Thanks.
11:03:33 <Unhammer> is there already a package which gives "(RealFrac a, Integral b) => a -> Maybe b" (to avoid NaN → 2.203912183e18) for round/ceiling/truncate/floor? I don't find them in https://hackage.haskell.org/package/safe
11:15:58 <johnw> i think TypeApplications is my favorite new feature
11:17:15 <nitrix> johnw: Have they added it to lambdabot yet?
11:17:23 <osa1> it gets better with https://arxiv.org/abs/1806.03476
11:17:25 <geekosaur> no. think there's some updates to libs needed
11:17:30 * hackage expressions 0.1.7 - Expressions and Formulae a la carte  http://hackage.haskell.org/package/expressions-0.1.7 (jakubdaniel)
11:17:53 <nitrix> :t map @Int @Bool
11:17:55 <lambdabot> error: parse error on input ‘@’
11:17:57 <johnw> the only problem is that I'm lazier about writing things so that inference happens nicely
11:17:57 <geekosaur> currently it parses it in many circumstances because it reads @ as a normal operator, but that can go wrong since what follows is a type instead of a term)
11:18:18 <geekosaur> yahb does speak it
11:18:25 <geekosaur> % :t map @Int @Bool
11:18:26 <yahb> geekosaur: (Int -> Bool) -> [Int] -> [Bool]
11:19:13 <nitrix> https://github.com/lambdabot/lambdabot/pull/147
11:19:26 <nitrix> Haha, on my I created that PR long time ago :)
11:20:02 <nitrix> I think I'll revisit it. There must be a way to check if @ is used as an operator in the context :/
11:20:30 <geekosaur> you need to use an updated version of haskell-src-exts, and verisons of hint and mueval that support it
11:20:32 <nitrix> I guess that'd need to be a change to the GHC extension rather than lambdabot.
11:20:34 <geekosaur> at minimum
11:22:21 <geekosaur> which still leaves the collision with @ in patterns, and potentially @ as an actual operator, but those indeed require changing the extension and at this point I suspect that won;t fly
11:22:53 <geekosaur> and ASCII doesn't have enough characters not already used as Haskell syntax
11:32:14 <dmwit> osa1: Thanks, before this paper I was never super clear on why pattern signatures required ScopedTypeVariables. Now it's obvious, even though they didn't explicitly about it: the signature could mention a variable, and there's no reason to connect that variable to any particular variable in the whole function's signature.
11:33:37 <orbisvicis> can I run haddock via cabal without building or configuring ?
11:33:46 <orbisvicis> ie with missing dependencies
11:34:22 <sclv> No
11:34:40 <sclv> It needs to compile to compute type info
11:35:02 <orbisvicis> oh, and that makes sense
11:35:49 <orion> I'm designing a monad transformer with ResourceT. Should it be closer to the base monad, further, or does it not matter?
11:36:28 <glguy> if it matters depends on the monad transformer, there's no generic answer. same pertains to the level you should put it at
11:36:32 <cocreature> orion: iirc ResourceT is basically ReaderT which tends to commute which pretty much everything
11:36:43 <ski> dmwit : it used to be a pattern signature could bind a tyvar, for later use in a defining equation (or `case' branch or ...)
11:36:51 <orion> cocreature: Great, thanks.
11:36:53 <geekosaur> but resource lifetimes don't necessarily so commute
11:36:55 * ski misses result signatures
11:37:23 <dmwit> ski: I think it still can. Do you think otherwise/
11:37:24 <dmwit> ?
11:38:08 <dmwit> > let f :: [a] -> [a]; f ((x :: b) : xs) = [y] where y :: b; y = undefined in f []
11:38:09 <orion> geekosaur: What do you mean?
11:38:11 <lambdabot>  *Exception: <interactive>:3:22-72: Non-exhaustive patterns in function f
11:38:25 <dmwit> Oops, I didn't actually check what I wanted to check.
11:38:40 <dmwit> > let f :: [Int] -> [Int]; f ((x :: b) : xs) = [y] where y :: b; y = 3 in f []
11:38:42 <lambdabot>  error:
11:38:42 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘b’
11:38:42 <lambdabot>      • When checking that the pattern signature: b
11:38:48 <dmwit> Oh, interesting.
11:39:39 <geekosaur> orion, you could for example "lose" the resource if you put the ResourceT in the wrong place. or handle exceptions at the wrong level (the MonadBaseControl problem)
11:40:13 <Welkin> lose the reference to it?
11:40:15 <geekosaur> which is why neither ResourceT nor MonadBaseControl can be automated, you must carefully think through resource lifetimes to figure out how to put an instance together
11:40:19 <Welkin> does that cause a memory leak?
11:40:50 <geekosaur> it can if it goes completely out of scope, because a resource is a handle on something external to Haskell (e.g. a datbae handle received from FFI)
11:40:53 <geekosaur> *database
11:40:53 <dmwit> ski: Weird. GHC's behavior does not seem to match the behavior described in this paper, which does claim that pattern signatures can bind type variables just by mentioning a variable that's not currently in scope.
11:41:10 <orion> geekosaur: Do you know of any good reading material which can help me gain intuition for how to do that?
11:41:23 <geekosaur> dmwit, wonder if it's worth testing that in ghc 6.4 or some other version that had standalone PatternSignatures
11:41:27 <orion> (that = think carefully about the instance)
11:42:32 <orion> I'm trying to compose LoggingT, ReaderT, and ResourceT. The order is what I'm currently working through.
11:42:44 <geekosaur> there's some School of Haskell stuff
11:42:52 <dmwit> geekosaur: Oh, it turns out that (even in this paper) they mention there is a restriction: pattern signatures may only bind variables *to other variables*.
11:42:58 <geekosaur> not sure if any of it talks about how to build your own as opposed to using existing ones, though
11:43:03 <dmwit> So binding `b` to `Int` as in my test above is ruled out. =(
11:43:25 <geekosaur> I have seen discussion, but it's ….complex
11:44:23 <geekosaur> http://blog.ezyang.com/2012/01/monadbasecontrol-is-unsound/ (note that the actual title is now "…is tricky") hits some of the issues
11:44:33 <geekosaur> and "tricky" is indeed the problem
11:44:44 <geekosaur> but the problem it wants to solve isequally tricky
11:45:00 <geekosaur> not to say downright nasty at times
11:47:12 <phadej> for LoggingT ReaderT and ResourceT order doesnät matter
11:47:16 <phadej> they are all readers
11:48:15 <orion> phadej: geekosaur says that the placement of ResourceT does matter.
11:48:31 <geekosaur> it can matter. I was speaking generally
11:48:33 <phadej> it does in general, but not with these trnasformers
11:48:41 <phadej> geekosaur: +1
11:48:42 <geekosaur> if all three are ultimately readerT then they may well commute safely
11:49:24 <geekosaur> you hadn't mentioned which ones and I can;t claim familiarity with some of them, so not safe for me to make assertions there
11:49:48 <glguy> even if they commute it some might have instances that others don't
11:49:49 <geekosaur> (yes, you did mention later)
11:53:15 <Guest56485> Hey everyone, I was wondering if there's a group actively working on developing stats with Haskell
11:53:30 <Guest56485> I couldn't seem to find anything super current
11:53:37 <srk> stats?
11:54:02 <Guest56485> yea, like how R has a ton of tools for working in statistics
11:54:12 <enterprisey> any ideas on debugging infinite loops in megaparsec
11:54:16 <srk> right. not sure
11:54:30 <enterprisey> specifically, I have a simple parser with (some constructors) <$> alphaNumChar and I get a <<loop>>
11:55:08 <orion> geekosaur: You mentioned MonadBaseControl being tricky. Does the same apply to MonadUnliftIO?
11:55:24 <Welkin> Guest56485: http://www.datahaskell.org/
11:55:25 <geekosaur> I haven't looked into MonadUnliftIO so can't say
11:55:29 <dmwit> enterprisey: A good first step, as with any other debugging endeavor, is to produce a minimal test case (here minimal means both "small thing to pass to the parser" and "small amount of code to define the parser").
11:56:00 <geekosaur> enterprisey, one thing I look for in that case is any rule that immediately reduces to application of itself
11:56:01 <Guest56485> Welkin: thank you!
11:56:12 <Welkin> Cale mentioned that MonadUnliftIO has the same problems
11:56:24 <orbisvicis> if I want to link (haddock) to an external function of a different module in the same package, I either have import the module (ghc error with -Werror) or refer to it fully qualified. Is there any alternative ?
11:56:24 <geekosaur> foo = foo mumble <|> ... -- will <<loop>>
11:56:47 <geekosaur> left recursion is bad in recursive descent parsers
11:57:22 <phadej> orion: monadunliftio is conceptually much simpler, if you can get away with it, than it's good
11:57:47 <phadej> (you can write instances only for readers, thus it's easy, but also limiting)
12:02:19 <enterprisey> yeah I have no recursion of any sort
12:02:50 <enterprisey> in fact, it's so short I can paste it here
12:03:10 <enterprisey> I have a ByteString, and I'm trying to parse it to a String
12:04:17 <enterprisey> so imagine f converts [Word8] to a String; then my parser is f <$> some alphaNumChar
12:06:33 <dminuoso> geekosaur: what is the solution to the MonadBaseControl problem though? Ditching such `(T -> IO a) -> IO a` implementations for manual resource management with bracket?
12:07:00 <geekosaur> dminuoso, the "problem" is there is no way to build "generic" instances; you have to carefully design them
12:07:32 <geekosaur> MBC works, but you have to think about it, not have the compiler roll it for you
12:07:50 <Amras> Are there any non-platform-dependent solutions for non-blocking reads from pipes/sockets/files? Some generalized solution that will compile properly on POSIX/non-POSIX systems?
12:08:07 <Peaker> hey, in https://github.com/simonmar/alex/blob/master/examples/haskell.x there's   $graphic # ...    what does the # mean? It seems like it might mean exclusion? But I can't find that anywhere. Where does # come from?
12:08:28 <Amras> short of forkIO + MVars + wait,checkMVar
12:10:21 <cocreature> Amras: the standard IO operations are all implemented in terms of non-blocking reads. just spawn a thread using forkIO
12:11:15 <phadej> Peaker: it's difference operator, yes.
12:11:26 <geekosaur> Peaker, https://www.haskell.org/alex/doc/html/charsets.html
12:11:36 <Peaker> thanks
12:11:37 <geekosaur> set0 # set1
12:12:35 <Peaker> Is alex the fastest way to tokenize? It seems like such an archaic way to work
12:14:04 <geekosaur> the same can be said of lex / flex in C; I punted to hand-written lexers years ago there
12:14:25 <geekosaur> but it's not about fastest way to tokenize; it's largely about maintainability and modifiability.
12:14:35 <geekosaur> programmer time and "brain space"
12:14:51 <Amras> cocreature, would you mind writing up a quick example of what you mean? something that'll return Just String from a getLine if data is immediately available or Nothing if it isn't
12:15:05 <Amras> I'm not following how forkIO would help here
12:15:33 <geekosaur> Amras, the usual design here is ot have a dedicated read thread that can send a message to another one when there is input
12:15:36 <geekosaur> via a Chan or etc.
12:15:45 <geekosaur> rather than trying to micromanage it
12:17:00 * hackage cookies 0.1.0.0 - web cookies  http://hackage.haskell.org/package/cookies-0.1.0.0 (chessai)
12:18:37 <cocreature> yeah geekosaur phrased it pretty well
12:19:43 <geekosaur> which? :p
12:20:21 <shapr> I found blaze-to-html, is there anything like that for lucid?
12:20:35 <geekosaur> (notably,micromanagement plays really badly if someone uses your code in a multithreaded program later)
12:20:55 <cocreature> geekosaur: all of it :)
12:21:23 <cocreature> shapr: what do you mean by blaze-to-html? I don’t see it on hackage
12:22:17 <shapr> I think it's part of the blaze package, it 'decompiles' html into blaze source
12:22:28 <shapr> (though it does not handle ARIA or other offbeat things)
12:22:29 <Welkin> so you mean html-to-blaze
12:22:42 <Welkin> there are tools like that for elm as well
12:22:42 <cocreature> shapr: do you mean blaze-from-html?
12:22:47 <Welkin> I've never used them before though
12:23:36 <Amras> geekosaur, not clear on how multithreading could break a non-blocking read. Also, assuming a straight-up MVar would be preferable to a Chan in this case since readChan blocks too.
12:23:43 <geekosaur> (and re lex in C, the main thing there was I had lex on AT&T UNIX but nothing yet for e.g. linux, so little choice there other than pregenerating elsewhere. Yes, I am that old.)
12:24:04 <geekosaur> Amras, race conditions if multiple threads end up running the same code with the same non-blocking read
12:24:18 <Amras> ah, right
12:24:49 <geekosaur> and TVars are probably preferable here because you get retry stuff
12:25:44 <cocreature> shapr: https://github.com/alogic0/lucid-from-html
12:27:54 <dmwit> Does the GHC API expose Z encoding/decoding somewhere?
12:32:00 * hackage haskell-tools-ast 1.1.0.0, haskell-tools-backend-ghc 1.1.0.0, haskell-tools-builtin-refactorings 1.1.0.0, haskell-tools-cli 1.1.0.0, haskell-tools-daemon 1.1.0.0, haskell-tools-debug 1.1.0.0, haskell-tools-experimental-refactorings 1.1.0.0, haskell-tools-prettyprint 1.1.0.0, haskell-tools-refactor 1.1.0.0, haskell-tools-rewrite 1.1.0.0, haskell-tools-demo 1.1.0.0 (lazac)
12:35:19 <shapr> cocreature: oh wow! thanks!
12:35:37 <shapr> cocreature: right, sorry for the typo, I meant html-to-blaze
12:36:09 <cocreature> shapr: no you meant blaze-from-html, at least that’s the name of the package on hackage :)
12:36:19 <shapr> oh, ok
12:36:51 <shapr> In any case, I have some html pages that need to be templates
12:46:35 <hololeap> anyone know of a library/mechanism to dole out jobs from a central server to any number of clients? some way to serialize a closure and a function maybe?
12:47:16 <geekosaur> sounds vaguely like cloud haskell?
12:47:39 <geekosaur> which doesn't actually serialize functions etc., just references to them (which must already exist in the client)
12:47:54 <geekosaur> actually serializing functions is … difficulr
12:48:00 <geekosaur> -r+t
12:48:16 <Welkin> hololeap: erlang
12:48:19 <dmwit> actually setializing functions is ... difficulr
12:48:32 <Welkin> I bet distributed haskell has a way to do it, since it is erlang implemented in haskell
12:48:45 <dmwit> Sorry, sorry. I couldn't help it.
12:49:52 <geekosaur> !-2:s/lr/lt/ # bah humbug
12:50:45 <jakub_> Hi, suppose I have a type that corresponds to numbers but I could care for it to have abs, signum and the like as otherwise required of instance of, but I would still really like to use the number literals instead of more complicated constructors for values of my type, is there something like OverloadedNumbers (in spirit of OverloadedStrings) or is there some easy TemplateHaskell way to achieve this? (I
12:50:51 <jakub_> would still wish to use normal numbers occasionally, I am fine with having to provide type signatures at some level to help compiler infer what the real intention is when a literal is used)
12:51:05 <hololeap> is distributed haskell is the same project as cloud haskell; just a different name? that's what it seems like.
12:51:05 <jakub_> *couldn't
12:51:32 <jakub_> *instances of Num
12:53:32 <geekosaur> jakub_, no way to separate fromInteger from Num, no. if you really want this you could have a dummy Num instance with everything but fromInterger = undefined
12:53:38 <Welkin> hololeap: yes
12:53:47 <geekosaur> or maybe quasiquotes, althoughthat still requires extra syntax (oxford brackets)
12:53:49 <Welkin> the name changed to distributed haskell
12:56:38 <lyxia> jakub_: RebindableSyntax makes numerals desugar to whatever "fromInteger" is in scope, instead of Prelude.fromInteger.
12:57:00 * hackage taffybar 2.1.2 - A desktop bar similar to xmobar, but with more GUI  http://hackage.haskell.org/package/taffybar-2.1.2 (eyevanmalicesun)
13:00:54 <jakub_> geekosaur, lyxia: thanks a lot, that helped
13:06:00 <hololeap> how come Network.Socket is not "safe" under Safe Haskell?
13:07:55 <shapr> I *think* Safe Haskell started with Don Stewart's Haskell interpreter inside lambdabot, so the point was "things that can't eat your system or affect the outside world"
13:08:11 <shapr> but now I have to go look up Safe Haskell and see if that's still what it means.
13:09:14 <shapr> Finding ways to get the /etc/shadow off the machine running dons' haskell interpreter was a multi-year fun hobby.
13:09:35 <cocreature> shapr: did you ever succeed? :)
13:09:50 <shapr> Many of us succeeded in a many different ways.
13:10:00 <cocreature> nice :)
13:10:10 <shapr> ddarius found a cute trick where Template Haskell could still do IO even though IO was not allowed at all
13:10:26 <shapr> I think it's all in the logs, it was a blast
13:11:05 <hololeap> System.IO is considered "trustworthy"
13:12:22 * shapr reads https://downloads.haskell.org/~ghc/8.4.3/docs/html/users_guide/safe_haskell.html
13:12:40 <geekosaur> I'd be looking in the docs for the network package
13:13:00 * hackage servant-nix 0.1 - Servant Nix content-type  http://hackage.haskell.org/package/servant-nix-0.1 (AlpMestanogullari)
13:13:00 <geekosaur> but I think part of the reason is that it can't be inferred trustworthy and nobody has audited it
13:13:29 <geekosaur> since it uses a lot of FFI and a certain amount of jiggery-pokery related to marshaling and unmarshaling socket FFI data
13:13:41 <hololeap> is that the de-facto way to do low-level network stuff (connect to a TCP port, for instance) in haskell?
13:13:47 <geekosaur> yes
13:13:59 <hololeap> ok
13:14:01 <geekosaur> if you re working at low level, at least
13:14:18 <geekosaur> these days for a bit higher level stuff conduit or pipes is preferred
13:14:24 <geekosaur> the Network module is deprecated
13:14:52 <hololeap> hmmm... well Data.Conduit is "safe"
13:26:21 <orion> "Note that, in order to meet the laws given below, the intuition is that a monad must have no monadic state, but may have monadic context." https://www.stackage.org/haddock/lts-11.13/unliftio-core-0.1.1.0/Control-Monad-IO-Unlift.html
13:26:34 <orion> What is the difference between "state" and "context"?
13:27:34 <blender> hello, does anyone have a working vim setup that shows types with ghc 8.2.2 ?
13:27:38 <cocreature> orion: context doesn’t change
13:27:47 <cocreature> orion: so Reader has context but no state
13:27:48 <maerwald> blender: stick to 8.0.2
13:28:30 <blender> maerwald: I switched to lts 11.13 and I think it requires 8.2.2 ?
13:28:30 * hackage uom-plugin 0.3.0.0 - Units of measure as a GHC typechecker plugin  http://hackage.haskell.org/package/uom-plugin-0.3.0.0 (AdamGundry)
13:28:40 <orion> cocreature: I see, thanks
13:28:51 <maerwald> I don't know what lts 11.13 is
13:29:04 <blender> stack LTS 11.13
13:29:10 <maerwald> I don't use stack, no idea
13:30:09 <blender> but in general there is nothing working with 8.2.2 :( ? I believe haskell-ide-engine does not show type information?
13:30:58 <maerwald> only for functions/identifiers, not for arbitrary expressions
13:31:58 <blender> ok, thanks :(
13:32:30 <geekosaur> and some things won;t work with 8.2+ because they just don't work. typed holes in ghci have been broken since 8.2 which means anything using that to get type info will fail
13:32:47 <geekosaur> no fix yet, has to be fixed in ghc
13:32:59 <suzu> typed holes have been working for me
13:33:24 <Rembane> geekosaur: Are typed holes working in 8.4, or not at all?
13:33:31 <suzu> though i've only been using it with simple cases
13:33:55 <suzu> usually i just toss in `()` and read the error as that's more illuminating
13:33:59 <suzu> :/
13:34:05 <cocreature> I think they are only broken in combination with -fdefer-type-errors?
13:34:06 <geekosaur> "[12 21:44:21] <mpickering> bgamari: Did Andres tell you about the bug with holes? There were some situations where the compilation would fail but no error message would appear when using a hole." is what I know
13:34:08 <Rembane> suzu: Have you tried using _ ?
13:34:15 <geekosaur> although that sounds like it might be something else than the one I'm thinking of
13:34:20 <suzu> yes. _ works but () gives me better results
13:34:25 <geekosaur> where ghci would panic if it hit a hole in some circumstances
13:34:26 <Rembane> geekosaur: Cool. The thrill is gone. :)
13:34:39 <suzu> ok no never seen a panic
13:34:44 <Rembane> suzu: That's fun, I need to use that trick. Thank you!
13:34:52 <suzu> yeah it is better. np!
13:36:22 <blender> holes are working for me. That is how I have been getting along but it sets me back a lot compared to haskell-vim-now :(
13:36:57 <geekosaur> cocreature, yeh, forgot to metnion that, but that's used a lot by editor shims so they can try to type things that aren't working
13:37:13 <geekosaur> also sometimes -fdefer-all-errors which is the main reason it exists
13:39:20 <glguy> emacs+dante gives types of expressions
13:47:27 <suzu> emacs+intero too
13:48:58 <maerwald> yes, and Go works on vim, maybe switch to Go
13:49:17 <blender> ahahaah :) well I could use spacemacs but I like vim.
13:49:23 <blender> with evil mode
13:49:25 <suzu> i switched from vim to spacemacs actually
13:49:30 <suzu> haskell was a factor in this decision
13:49:58 <blender> yeah but vim :( I might consider evil mode as I said.
13:49:59 <suzu> hs integration just works and i can move on with my life
13:50:16 <suzu> i do use evil mode
13:50:56 <blender> what do I need? spacemacs and then? how do I install what I need for intero?
13:51:04 <suzu> spacemacs and nothing else
13:51:11 <suzu> it will set everything up for you out of the box
13:51:17 <glguy> intero locks you into stack, so be aware of that. That's one of the advantages of dante
13:51:56 <suzu> spacemacs lets you use intero or dante
13:52:03 <suzu> i left it as intero but it can be changed
13:52:16 <glguy> did that make it into master yet?
13:52:26 <glguy> last time I played around with that it was only in develop
13:52:27 <blender> ok so I install spacemacs and then just do `stack install intero` ?
13:52:30 <suzu> i..think so
13:52:32 <suzu> blender: no
13:52:49 <suzu> you install spacemacs, install the haskell intero layer, and then it will take over the rest when you load a stack project
13:52:59 <blender> ok
13:53:02 * hackage distributed-process-extras 0.3.5 - Cloud Haskell Extras  http://hackage.haskell.org/package/distributed-process-extras-0.3.5 (AlexanderVershilov)
13:53:07 <blender> I'll try.
13:53:10 <suzu> including installing the correct intero into your project
13:53:28 <suzu> the biggest motivation i had for using spacemacs was the idea that the only reason i use vim is simply because it was the first tool i learned
13:53:34 <suzu> and that is a bad reason
13:53:35 <maerwald> intero works with neovim too
13:53:47 <maerwald> I would rather switch to that instead of emacs
13:53:54 <maerwald> that sounds unreasonable for a vim user
13:54:03 <dyl> I should play with spacemacs.
13:54:04 <dyl> Looks handy.
13:54:10 <maerwald> blender: https://github.com/parsonsmatt/intero-neovim
13:54:12 <dyl> I just don't have time to configure emacs in general.
13:54:22 <suzu> dyl: no need
13:54:36 <suzu> spacemacs comes batteries-included with defaults that i still use
13:54:48 <dyl> "intero locks you into stack" ← boo
13:55:00 <maerwald> you can use a custom backend
13:55:04 <suzu> whats with all the recent stack hate
13:55:09 <suzu> is cabal new-build that good?
13:55:26 <sclv> its pretty good
13:55:27 <dyl> stack is just one more thing to learn and I had minor issues using it initially.
13:55:31 <blender> maerwald: thanks I'll look at that too. Evil mode in spacemacs lets you use vi bindings to it's not that bad if you overlook the fact that your using emacs as a vi fan :D
13:55:38 <dyl> cabal had its own issues, but the new stuff fixes all of them I remember.
13:55:38 <sclv> idk if that should induce hate of anything else
13:55:43 <dyl> Nah, I don't hate stack.
13:55:45 <sclv> but it should induce some satisfaction :-)
13:55:49 <dyl> I just prefer using the new-* subcommands.
13:55:50 <maerwald> blender: I don't like unstable editors
13:55:56 <sclv> the main issues are just that its a bit incompete
13:56:00 <suzu> stack solved my hair-ripping cabal meltdowns
13:56:02 <sclv> but we have lots of ongoing gsoc work driving it forward
13:56:08 <suzu> so it will always have that one special place in my heart
13:56:14 <suzu> for letting me actually get things done
13:56:36 <dyl> I forget what the issue I had was, but it was just generally confusing.
13:56:45 <dyl> stack seems good for application people, cabal new-* for library people.
13:57:08 <dyl> I also didn't like that I couldn't figure how to have a library+executable in stack easily.
13:57:21 <dyl> stack ghci didn't work right.
13:57:49 <dyl> sclv in the end a better cabal means a better stack too :).
13:57:53 <Peaker> is it customary for "alex" to generate "Whitespace" tokens? If not, what technique is used to make sure whitespace is significant in token separation?
13:58:20 <Peaker> a regexp word boundary around token keywords?
13:58:31 <gonz_> Stack has never not worked for me
13:58:33 <glguy> Peaker: What are you trying to enforce whitespace around?
13:58:45 <edmundnoble> And stack has also never worked for others
13:58:56 <glguy> Peaker: Generally you forget about whitespace after the alex phase
13:59:06 <Peaker> glguy, e.g: include <filepath>   where "include" is a keyword
13:59:11 <koala_man> Peaker: isn't the fact that it tokenizes as two separate tokens enough?
13:59:15 <dyl> stack seems to fit a certain sort of user.
13:59:19 <Peaker> I don't want it to accidentally allow includefilepath
13:59:22 <geekosaur> ^ whitespace tokens are for indentation sensitive parsing.
13:59:32 <glguy> Peaker: alex uses a longest match
13:59:39 <sm> you are all fools, everything but pier is trash
14:00:04 <glguy> so if you have another rule for identifiers that would have matched includefilepath that would be prefered to lexing that as two tokens
14:00:04 <suzu> lmao
14:00:05 <geekosaur> do we have #haskell-square-ring yet?
14:00:11 <gonz_> dyl:  You would still configure library + executable in your cabal file, though, no? Why would this be more of an issue with stack?
14:00:21 <dyl> no, you are the fool: not using gulp from the node.js ecosystem and only pulling packages as strings in single file npm packages?
14:00:21 <Peaker> glguy, I see
14:00:22 <dyl> hah!
14:00:24 <dyl> You peons.
14:00:34 <dyl> gonz_ stack ghci didn't work.
14:00:44 <glguy> Peaker: Alex also has the ability to specify a following pattern
14:00:50 <dyl> Which is a dealbreaker for me.
14:01:07 <glguy> so if you didn't have some longer match that would have helped with this you can say that include shouldn't be followed by an alpha
14:01:10 <dyl> And I want cabal new-repl for various reasons.
14:01:15 <dyl> (which doesn't mix with stack)
14:01:37 <Peaker> glguy, I am trying to describe lexing of (extended) makefiles.. someone made a prototype in alex but it's not really correct.. and very ugly. I'm very new to alex
14:02:04 <glguy> Peaker: It's trickier to actually look for whitespace because often you'd tolerate whitespace or a { or [, etc
14:02:10 <Peaker> makefiles are hairy -- they have the <tab>-<random string> part that shouldn't be tokenized normally
14:02:11 <glguy> include<stuff> might have been OK
14:02:29 <sbrg> does anyone know what could cause stack to think dependencies are missing when they *definitely* are not missing and are declared correctly in the cabal file and so on? Everything build just fine, but trying to load my project in ghci(stack ghci via emacs) complains about missing dependencies
14:03:15 <sm> sbrg: how do you know emacs is running stack ghci inside your project directory
14:03:56 <sbrg> sm: the name of the session is correct, but i have my suspicions something along those lines is happening. it's just so strange because it actually worked a couple of days ago.
14:04:27 <sbrg> also worth noting is that the flycheck checker haskell-stack-ghc also seems to be borked
14:04:32 <sbrg> which also worked previously
14:05:04 <sbrg> this is a "monorepo" consisting of a library, two other libraries that depend on it, and an executable that depends on all three, so maybe it's picking up some other package.yaml or something.. but it shouldn't
14:05:07 <sm> none of this seems strange to me, sadly
14:05:21 <sm> ye'll have to debug yer tools
14:05:34 <sbrg> :!pwd prints the correct directory
14:06:36 <Peaker> the alex documentation uses the alex descriptions of its own syntax, apparently, making it very hard to understand which parts are examples and which are definitions of alex in alex
14:06:37 <sbrg> and even `:set -package <missing packages>` fixes the problem.. so clearly it knows about these packages? O.o
14:06:58 <sbrg> god i hate having to debug my tools instead of my code -_-
14:07:14 <Peaker> reading https://www.haskell.org/alex/doc/html/alex-files.html#rules in 3.2.2.1 I am very lost about how I am supposed to read left_ctx := ...  what am I reading?  An example of left ctx use? The definition of it in alex?
14:07:35 <dminuoso> sbrg: when you run `stack ghci` from a terminal while inside the project directory, do you get the same issue still?
14:08:04 <Peaker> I guess it's the alex-in-alex definition, but then an example of use of ^ and "set ^" would be really useful
14:08:54 <dsal> Does anyone happen to know why the .&. operator exists in QuickCheck?   It's a sort of half-conjunction operator where you want to test input against two properties that both should pass, but it only tries one of them somewhat arbitrarily.
14:09:08 <glguy> Peaker: set is defined in 4.2
14:09:17 <glguy> "Syntax of character sets"
14:10:44 <Peaker> glguy, so foo^ bar would make sure "foo" precedes (but some other token consumed it [potentially as a suffix])?
14:11:08 <glguy> foo isn't a character set
14:11:20 <Peaker> $foo ^ bar  then
14:11:55 <sbrg> dminuoso: no, but it seems to think it's the wrong project, so i guess that's a clue
14:12:05 <sbrg> that is, it doesn't give me access to the modules in that project
14:12:18 <glguy> Yeah, the left-context matches the end of the previous match
14:12:22 <sbrg> but trying to load the module in question gives me the same errors
14:12:49 <Peaker> glguy, great, thanks :-)  I think "char" would have been much less confusing to me than "set" :)
14:13:07 <Peaker> (it's not a set there, but a char *from* the set)
14:13:24 <glguy> well, that part of the documentation is describing the syntax
14:13:29 <Peaker> or I guess, it depends on what level of abstraction you're working in
14:13:31 <glguy> so it wouldn't make sense to show char there
14:13:33 <geekosaur> it's thinking in regex. [a-z]
14:14:03 <Peaker> yeah, so I guess "chardesc" would be less confusing for me, though "set" is more concise for something this frequent
14:14:45 <geekosaur> (icon? cset)
14:19:16 <jle`> are there any "inductive" types to represent grids (2d lists)?
14:19:26 <jle`> so i can inductively prove theorems about entire rows and columns
14:20:32 <jle`> searching for "inductive grid" gives me electrical engineering topics
14:20:43 <__monty__> dsal: Does it pick the same one every pass?
14:22:05 <dsal> __monty__: It's supposed to arbitrarily pick one.  Like, perhaps it's meant for performance?
14:22:13 * dsal can't figure out how to get lambdabot to quickCheck anymore
14:22:59 <jle`> @check \x y z -> (x + y) + z == x + (y + z)
14:23:02 <lambdabot>  +++ OK, passed 100 tests.
14:23:08 <dsal> ah
14:23:19 <dsal> @check \x -> x > 0 .&. x > 0
14:23:19 <lambdabot>  :-1:-1:Ambiguous infix expression
14:23:32 <__monty__> dsal: Quickcheck tests non-deterministically so this seems to fit with the modus operandi. It doesn't need to test both every time because it'll likely test either with enough cases?
14:23:53 <dsal> I guess?  Just seems not sufficiently different from .&&.
14:24:17 <lyxia> It might be useful with recursive properties to avoid the combinatorial explosion
14:25:37 <Ariakenom> What's the terminology around these things. Does deterministic but randomised make sense?
14:28:22 <dsal> It's a seeded random sequence so it's reproducible, but arbitrary.
14:30:00 <__monty__> Ariakenom: I think it does actually, monte carlo sampling comes to mind.
14:30:23 <lyxia> pseudorandom
14:30:33 <pounce> Is there a way to flatten a [[Int]] to an [Int] ?
14:30:42 <typedrat> jle`: not like "known", but `data InductiveGrid a = IGCons { igNextCol :: InductiveGrid a, igNextRow :: InductiveGrid a, igValue :: a } | IGNil` should at least be a starting place
14:30:52 <EvanR> jle`: Vect m (Vect n a) right
14:31:04 <geekosaur> :t conat
14:31:06 <lambdabot> error:
14:31:06 <lambdabot>     • Variable not in scope: conat
14:31:06 <lambdabot>     • Perhaps you meant one of these:
14:31:06 <geekosaur> er
14:31:09 <geekosaur> :t concat
14:31:10 <lambdabot> Foldable t => t [a] -> [a]
14:31:18 <geekosaur> % :t concat @[]
14:31:18 <yahb> geekosaur: [[a]] -> [a]
14:31:27 <pounce> ty
14:31:42 <EvanR> typedrat: that has the issue of a particular grid not having a unique representation
14:31:43 <__monty__> Calling pseudorandomness deterministic is cheating imo. And the question was about the determinism and randomness, not pseudorandomness specifically.
14:31:56 <EvanR> like inductive graphs
14:32:46 <dyl> chaotic = random but deterministic, stochastic = random but not deterministic.
14:32:51 <lyxia> __monty__: I thought determinism was the main point of pseudorandomness?
14:32:57 <dyl> __monty__ it's not cheating at all.
14:33:03 <EvanR> dunno dyl sounds specious
14:33:09 <typedrat> EvanR: nextRow would point to the thing in the correct column to line up, etc. It's a horrible pain to construct
14:33:28 <dyl> EvanR "not deterministic" does generate some philosophical questions :p.
14:33:34 <typedrat> but sometimes the trivial solution is what you want
14:33:38 <dyl> Think logistic map vs brownian motion.
14:33:40 <__monty__> lyxia: Main point of pseudorandomness is getting as close as possible to randomness imo.
14:34:07 <dyl> Also: generators like /dev/urandom are NOT pseudorandom. They use pseudorandom algorithms as well, but also work from a pool of "true randomness".
14:34:16 <dyl> From things like fluctuations in temperature readings, or key presses.
14:34:38 <EvanR> /dev/urandom might be deterministic on some systems
14:34:44 <dyl> Yes.
14:34:49 <dyl> *might be*.
14:35:03 <EvanR> yeah so factor in the random choice of unix :)
14:35:10 <dyl> Usually, /dev/random blocks when there's not enough entropy left, /dev/urandom just uses pseudorandom, BUT
14:35:20 <dyl> in a lot of cases they are exactly the same and it's a bit more complex.
14:35:22 <EvanR> ah youre talking about linux
14:35:44 <merijn> dyl: What makes you say that chaotic is deterministic?
14:35:53 <dyl> Chaotic = deterministic in the short term.
14:36:01 <dyl> Meaning you can predict the next outcome based on the current one.
14:36:04 <merijn> EvanR: No it's not, that's nonsense
14:36:10 <dyl> (which, inductively, means it's deterministic)
14:36:11 <geekosaur> mathematical chaos theory
14:36:20 <mreh> @hoogle :: [Either a b] -> (a -> c) -> [c]
14:36:20 <lambdabot> Control.Error.Safe foldr1Err :: e -> (a -> a -> a) -> [a] -> Either e a
14:36:20 <lambdabot> Control.Error.Safe foldl1Err :: e -> (a -> a -> a) -> [a] -> Either e a
14:36:20 <lambdabot> Control.Error.Safe foldl1Err' :: e -> (a -> a -> a) -> [a] -> Either e a
14:36:22 <merijn> EvanR: The meaning of urandom isn't defined anywhere and there's not a single OS that does that
14:36:22 <EvanR> what
14:36:22 <dyl> But you can't predict an outcome N ahead based on the current one with some closed form.
14:36:32 <dyl> https://www.2uo.de/myths-about-urandom/
14:36:33 <mreh> shame that doesn't exist
14:36:34 <dyl> ^ relevant
14:36:42 * hackage hs-bibutils 6.5.0.0 - Haskell bindings to bibutils, the bibliographyconversion utilities.  http://hackage.haskell.org/package/hs-bibutils-6.5.0.0 (wilx)
14:36:50 <EvanR> i can't be sure were talking about the same thing
14:37:31 <dyl> Chaotic means that sufficiently far in the future outcomes are not *predictable* from the current/past outcomes.
14:37:43 <dyl> But it's still based on a deterministic process, so you can predict the next one, and so forth.
14:37:55 <dyl> Stochastic behavior is closer to what crypto would call "true random".
14:38:10 <jle`> EvanR: you can only prove row theorems that way though, right?
14:38:25 <pie_> edwardk, just found some random logs, you ever do anything imgui related in haskell?
14:38:31 <Ariakenom> dyl: I think you're missing precision in your chaos.
14:38:37 <EvanR> jle`: i dont think so
14:38:56 <EvanR> you can talk about columns
14:38:58 <dyl> I'm coming from mathematical definitions. Both "chaotic" and "stochastic" are overloaded to hell and back in most areas
14:38:58 <Ariakenom> That chaos means you can predict close things well, not perfect. And far away things bad.
14:39:06 <jle`> er, just one or the other, right
14:39:11 <dyl> Ariakenom for a statistician yes
14:39:50 <dyl> Chaotic systems are deterministic, but not predictable.
14:40:32 <Ariakenom> simulation is fine prediction in this context?
14:41:07 <dyl> Simulation is simply obtaining the next outcome. Since it's not a statistical process, the meaning of "prediction" breaks down.
14:41:13 <Ariakenom> Anyway I threw this off topic
14:41:22 <dyl> 👍
14:42:48 <EvanR> what do you call the weather forecast for tomorrow
14:42:54 <ClaudiusMaximus> found 2 bugs (1x performance, 1x correctness)
14:42:56 <EvanR> how about "meaningless"
14:42:56 <ClaudiusMaximus> Prelude> (1e100000000 :: Double, 1e1000000000 :: Double)
14:42:56 <ClaudiusMaximus> (Infinity,0.0)
14:42:56 <ClaudiusMaximus> (75.32 secs, 68,432 bytes)
14:44:00 <ClaudiusMaximus> ghci-8.4.3 on amd64 linux (self-compiled on debian buster)
14:49:40 <EvanR> ClaudiusMaximus: thats wacky, same here
14:54:12 <EvanR> i guess that answers the question of ghc precompiling constant numbers of known type
14:55:24 <geekosaur> not like that's not already true of other types
14:55:30 <geekosaur> > 100000000000000000000000 :: Int
14:55:32 <lambdabot>  200376420520689664
14:55:47 <geekosaur> and always has been
14:55:57 <EvanR> that one makes sense and isnt slow
14:58:31 * hackage slack-web 0.2.0.5 - Bindings for the Slack web API  http://hackage.haskell.org/package/slack-web-0.2.0.5 (EmmanuelTouzery)
15:00:00 <ClaudiusMaximus> without a type signature it takes longer and allocates loads
15:04:14 <glguy> 1e100000000 gets converted to a call to fromRational, right?
15:04:24 <glguy> so that Integer it getting created in GHCi
15:04:32 <glguy> is getting*
15:04:55 <geekosaur> yes
15:10:12 <EvanR> gross
15:12:52 <hcarr> I have a type: Bloom (n :: Nat) (h :: Nat) = ...  --- but it is easy to accidently swap the nats when creating.   Is there anything like `newtype` at the type level?
15:34:01 <lyxia> have you tried newtype
15:34:26 <edmundnoble> Explicitly: `newtype N (n :: Nat) = N Nat`, `Bloom (n :: 'N)`
15:40:25 <ClaudiusMaximus> how worried should i be about warnings for unticked promoted types with -XDataKinds ?  is support for that going away and code will break in the future?
15:40:53 <ClaudiusMaximus> s/promoted types/promoted constructors/
15:43:20 <lyxia> It looks like the kind of thing we're stuck with on the very long term
15:54:04 <centril> phaazon: get to work ;)
15:54:28 <phaazon> I am I am!
15:54:38 <phaazon> centril: were you at ZuriHac btw?
15:54:43 <phaazon> I didn’t find you there! :)
15:54:47 <centril> phaazon: no :)
15:54:51 <phaazon> (:
15:55:04 <centril> phaazon: I never leave the Church of Haskell.
15:55:30 <phaazon> :D
15:55:51 <centril> phaazon: == Chalmers University of Technology
16:03:56 <blender> since now runResourceT requires m to be instance of MonadUnliftIO, if there a point to a constraint (MonadUnliftIO m, MonadIO m) rather than just IO ?
16:05:32 <hpc> IdentityT IO :D
16:06:27 <glguy> blender: m could be ReaderT
16:06:37 <glguy> blender: m could be (ReaderT e m)
16:06:54 <glguy> with the m not shadowed .. and.. whatever
16:07:32 <dminuoso> Im trying to build a stack project inside a docker container using fpco/stack-build on a macOS host. It's sometimes crashing while building the RTS with "no space left on device" errors which I dont understand how could occur.
16:07:38 <dminuoso> Does anyone have any guidance for me?
16:08:34 <int-index> increase the size of your /tmp?
16:08:41 <int-index> could be one reason
16:09:17 <dminuoso> int-index: https://gist.github.com/dminuoso/af727c458ed4f1c0efc91beaa22d2622
16:09:57 <dminuoso> And the docker vm is configured to have 80GiB of disk space...
16:10:09 <dminuoso> (With 20GiB in usage)
16:11:35 <dminuoso> Okay something is up.. now I cant even stream anything to the docker daemon anymore
16:17:56 <blender> I have a ExceptT stack that before the MonadUnliftIO requirement from runResourceT used to work just fine. What am I supposed to use now? Just turn this into (MonadError e m) ?
16:26:29 <lyxia> put ExceptT outside ResourceT
16:30:05 <Peaker> in happy, the syntax Foo $$ for %token works for a single field in a constructor. Any way to capture 2 fields inside the cons?
16:30:25 <sm> cabal get -s is nice, thanks cabal!
16:30:49 <blender> lyxia: well the signature is already ExceptT e m r, you're suggesting ResourceT where m is ExceptT ?
16:34:31 <argent0> hi, if I do `forkIO $ forever $ return ()` i get only one thread. Right? as in this is not a fork bomb.
16:35:12 <lyxia> blender: I don't think so, but I'd like to see the problematic code to be more specific.
16:35:22 <hpc> argent0: correct
16:35:30 <hpc> argent0: the computation you are forkIO-ing is (forever $ return ())
16:35:44 <Peaker> $$ in happy seems to lose the token itself (e.g: the position)! :-(
16:35:53 <argent0> hpc, thanks!
16:36:02 <hpc> argent0: forever $ forkIO $ return () is a forkbomb, but not a very good one
16:36:08 <hpc> because every thread exits immediately
16:36:12 <blender> lyxia: https://github.com/blender/Rome/blob/ea65f24c208f1ec13692e9823e4cb9bfb5f90493/src/Caches/Local/Downloading.hs#L288
16:36:31 <hpc> in practice, i think you just end up with an infinite loop that makes your cpu slightly warmerer
16:36:38 <blender> `saveBinaryToFile` uses runResourceT
16:37:28 <blender> lyxia: from the correct branch: https://github.com/blender/Rome/blob/9ea72bab372fcdf3320d05e50e28109322a194cb/src/Caches/Local/Downloading.hs#L288
16:37:44 <lyxia> blender: ah, that looks like a trickier case than I thought
16:38:51 <lyxia> I think generalizing to MonadError will only delay the problem to the point where you call runExceptT
16:39:10 <NotLokathor> just installed a fresh copy of 64 bit stack on windows 10
16:39:25 <NotLokathor> and stack is trying to use ANSI escape codes to color my terminal
16:39:26 <NotLokathor> :(
16:39:37 <blender> lyxia: also I have no idea how to write this: https://github.com/blender/Rome/blob/feature/lts-11.13/src/Caches/Local/Downloading.hs#L281
16:40:32 <hpc> NotLokathor: i bet it's the bash stuff they added recently
16:40:48 <NotLokathor> into cmd.exe?
16:40:50 <NotLokathor> or into stack?
16:41:13 <hpc> cmd
16:41:13 <blender> lyxia: but I also I can't use the ExceptT stack anymore and I have to run it everywhere now which kidn of defeats the purpsoe
16:41:31 <blender> I'm pretty lost :(
16:41:46 <NotLokathor> hpc: wild stuff
16:42:10 <NotLokathor> it's shockingly hard to just get a few lines of haskell to execute
16:42:28 <NotLokathor> the browser based repl was broke so i had to get stack, then stack is partly broke too
16:43:18 <NotLokathor> also i told it to install to the D drive and it seems to be using the C drive anyway ;_;
16:43:36 <hpc> NotLokathor: if you're lucky, the sharks won't notice you until you're close to shore
16:44:18 <lyxia> blender: what's the error message?
16:44:40 <NotLokathor> i just want it to print some slightly formatted text stuff out of two lists
16:45:00 <NotLokathor> hpc, here's a wild time, _some of the colors do work_
16:45:06 <lyxia> blender: is there an error message?
16:45:29 <blender> The error message is that it wants me to unwrap the except computation an run it
16:45:40 <NotLokathor> hpc, https://imgur.com/a/Vu225RR
16:45:47 <blender> which I don't want to do beucase the whole point was to propagate the failure upwards
16:46:01 <blender> using the properites of the stack
16:46:31 <hpc> ugh, what the hell do i have to do so noscript lets me look at imgur crap
16:46:45 <hpc> interesting
16:46:58 <hpc> maybe it does color but not bold?
16:46:59 <blender> so basically because I'm using using a conduit somewhere down I have to give up my entire error propagation?
16:47:25 <hpc> NotLokathor: another silly idea, get putty and ssh into localhost
16:47:27 <hpc> and run it from there
16:47:45 <NotLokathor> well i've got my output
16:47:49 <NotLokathor> time to uninstall stack
16:47:53 <hpc> haha
16:48:32 <blender> just seems like ExceptT and runResourceT can't go together anymore to me and this affects my entire program
16:48:34 <hpc> guess what, it was cookies
16:48:57 <blender> which is based on ExceptT for the most past
16:49:01 <blender> part*
16:49:12 <NotLokathor> imgur was messed up because of cookies?
16:49:16 <hpc> yep
16:49:22 <hpc> web2.0
16:49:34 <NotLokathor> call me back for web 2.2
16:51:14 <hpc> web 3.11 for workgroups
16:53:55 <NotLokathor> how'vya been hpc
16:54:03 <NotLokathor> how has the web treated you
16:54:30 <hpc> heh
16:57:00 * hackage bits-extra 0.0.1.3 - Useful bitwise operations  http://hackage.haskell.org/package/bits-extra-0.0.1.3 (GeorgeWilson)
16:59:31 <jackdk> where does haddock document the instances of associated types to a typeclass? I'm trying to find out what the instances are for Reflex's `Event t`/`Behavior t`/`Dynamic t`, but this is relevant elsewhere too
17:00:25 <hpc> jackdk: below the class definition, and below the type definition
17:04:32 <jackdk> I see them for normal type declarations but not for associated types, though (in the `-XTypeFamilies` sense)
17:05:33 <hpc> type families are in the same world as type aliases
17:06:03 <hpc> they disappear instead of being something you can think of as their own type
17:12:30 * hackage yarn2nix 0.7.0 - Convert yarn.lock files to nix expressions  http://hackage.haskell.org/package/yarn2nix-0.7.0 (Profpatsch)
17:13:38 <Np-Harda`>  Whenever I am drunk I am so much better in programming
17:14:07 <Np-Harda`> not like a little bit better, but 500% at least
17:15:08 <Np-Harda`> anyone else feeling that way?
17:20:22 <geekosaur> ob https://xkcd.com/323/
17:20:49 <geekosaur> of course, yours is how you get the failure mode mentioned :p
17:26:29 <maerwald> seems intero-neovim is utterly broken without stack
17:28:49 <sm> intero requires stack, no ?
17:29:26 <geekosaur> which is why dante exists https://github.com/jyp/dante
17:29:48 <maerwald> sm: it's supposed to work with a custom backend too
17:29:54 <maerwald> https://github.com/parsonsmatt/intero-neovim#using-a-custom-backend
18:22:49 <dmwit> jackdk: Perhaps those documents were created with an older haddock, which didn't yet support type families. (It's a relatively new haddock feature.)
19:36:30 * hackage espial 0.0.2 - Espial is an open-source, web-based bookmarking server.  http://hackage.haskell.org/package/espial-0.0.2 (jonschoning)
21:02:00 * hackage exitcode 0.1.0.1 - Monad transformer for exit codes  http://hackage.haskell.org/package/exitcode-0.1.0.1 (qfpl)
21:03:30 * hackage odpic-raw 0.2.1 - Oracle Database Bindings  http://hackage.haskell.org/package/odpic-raw-0.2.1 (leptonyu)
21:47:30 * hackage reroute 0.5.0.0, Spock 0.13.0.0, Spock-core 0.13.0.0, Spock-api-server 0.12.0.1, Spock-api 0.12.0.1, Spock-api-ghcjs 0.12.0.1 (AlexanderThiemann): https://qbin.io/miami-rj-dooj
22:20:32 <pounce> can I use the type annotation :: for things that aren't functions?
22:21:04 <geekosaur> > 5 :: Int
22:21:06 <lambdabot>  5
22:21:19 <geekosaur> although that question is a bit unclear: use where?
22:22:23 <pounce> something like `primes :: [Int]; primes = ...`
22:22:39 <geekosaur> sure
22:23:21 <pounce> Oh, i'm getting a weird error rn. let me throw it up in a gist
22:23:22 <geekosaur> (what you can;t do without an extension is something like `foo (x :: Int) = ...`
22:23:30 * hackage hoist-error 0.2.0.1 - Some convenience facilities for hoisting errors into a monad  http://hackage.haskell.org/package/hoist-error-0.2.0.1 (schalmers)
22:25:15 <pounce> I don't really get this error I'm getting: https://gist.github.com/4e554c4c/eaa4f2ed056d6acea149fe22c8083c8f
22:25:32 <pounce> I haven't got the function to compile yet, so feel free to ask about the terrible parts of it
22:25:51 <pounce> oh, and the `:: [[[Int]]]` that was for debugging
22:26:33 <pounce> oh, that looks to be maybe my error
22:26:38 <cocreature> pounce: you are trying to make … ++ (1:l) typecheck as [[[Int]]] which means (1:l) must have type [[[Int]]] and thereby 1 must have type [[Int]]
22:26:48 <cocreature> :t 1
22:26:49 <lambdabot> Num p => p
22:27:11 <cocreature> numeric literals are overloaded so you get the error about the missing num instance rather than a type mismatch
22:27:31 <pounce> yeah, the list was getting pretty nasty before I threw those concats in
22:28:24 <pounce> (concat . replicate) seems like it should be another function
22:29:30 <dminuoso> gitlab ci, what's the usual mechanism to build docker containers and pushing them onto a registry from within gitlab ci?
22:29:36 <dminuoso> (With a stack project)
22:31:57 <pounce> ok, well I updated it, and I'm getting a different error. I think it's because my list constructor returns a list for its elements, so I'm getting a [[Int]], but if I do `concat [xs | ... ]` it fails to check in a different way https://gist.github.com/4e554c4c/eaa4f2ed056d6acea149fe22c8083c8f
22:38:41 <dminuoso> :t replicate
22:38:42 <lambdabot> Int -> a -> [a]
22:39:05 <geekosaur> do you want to make a list of different xs-s?
22:39:12 <dminuoso> pounce: Tell me what you think `concat $ replicate 1 1`  would do
22:41:58 <pounce> dminuoso: I would think it would fail to typecheck because replicate 1 1 would give [1] whichisn't a Foldable [a] ?
22:42:15 <pounce> but I'm really new so I'm not sure :[
22:42:38 <pounce> geekosaur: no, just a flat list
22:42:50 <geekosaur> then you're thinking about list comprehensions wrong
22:43:10 <geekosaur> you are telling it to generate a bunch of list elements, provided by xs, then combine them into one list
22:43:19 <geekosaur> that is, each generated value of xs is one list element
22:43:44 <geekosaur> > [ x | x <- [3,4,5] ]
22:43:46 <lambdabot>  [3,4,5]
22:44:13 <geekosaur> (trivial comprehension generating the original list I gave it)
22:44:35 <geekosaur> > [ x + 2 | x <- [3,4,5] ]
22:44:37 <lambdabot>  [5,6,7]
22:44:42 <geekosaur> perhaps clearer as to what's up
22:46:04 <pounce> hmm
22:49:40 <dminuoso> pounce: what should this then do? (concat . replicate 1) <$> [1,2,3]
22:54:22 <pounce> dminuoso: ok, well I'd assume the same, because from what I know of `<$>` it maps the func on the left to each of the elements in right
22:54:29 <pounce> so I think that helps me out :)
22:56:39 <pounce> thanks for the help, I'm quite new at all of this
22:57:11 <dminuoso> pounce: You might want to use list do-notation rather than a list comprehension when it's packed with that much code.
22:58:14 <pounce> so, is do a more imperative syntax? It looks a bit weird to me (but so does most of haskell)
22:59:14 <dminuoso> pounce: No, do is a kind of syntax sugar that actually uses >> and >>=
22:59:23 <dminuoso> pounce: Which incidentally list comprehensions are too.
23:00:04 <dminuoso> But yeah, it gives the impression of an imperative touch while being all functional. =)
23:03:10 <pounce> ok, I'll take a shot at turning this into do syntax when I'm done with it. Might need some help though
23:03:21 <pounce> I was looking at a "real project" yesterday and saw a lot of `do`
23:06:57 <geekosaur> it's convenient when doing I/O, or other things where order matters
23:18:24 <gentauro> Question about newtype, is this syntax valid? newtype FM a = FM { unFM :: forall m. Monoid m => (a -> m) -> m }
23:18:36 <gentauro> Source: comonad.com/reader/2015/free-monoids-in-haskell/
23:18:56 <geekosaur> valid with RankNTypes
23:19:08 <geekosaur> not in standard Haskell
23:19:24 <gentauro> geekosaur: is that a Pragma?
23:19:43 <gentauro> {-# RankNTypes #-} ?
23:19:47 <Axman6> it's a language extension
23:19:52 <geekosaur> it's a LANGUAGE pragma, or can be specified in other ways (-X option to compiler, or in cabal file etc.)
23:20:01 <Axman6> {-# LANGUAGE RankNTypes #-}
23:21:14 <gentauro> Axman6: thx
23:21:34 <gentauro> I got it to work in the Emacs REPL (:set -XRankNTypes)
23:21:39 <gentauro> as well
23:28:49 <nsnc> We
23:33:24 <ahri> I have a function `f :: a -> b -> c` that I wish to map over `a :: Either String (Maybe a)` and `b :: Maybe b`, so if that Either layer wasn't there I'd do `f <$> a <*> b` - so what approach should I take? I can use `b' = pure b` to get them both to be the same 'depth' but I'm still unable to use `f <$> a <*> b'` at that point due to there being 2 layers, so I'm not sure what the idiomatic way to do this is (or indeed how to
23:33:25 <ahri> search for it!) - I'm almost looking for `(Functor f, Functor g) => (a -> b -> c) -> f g a -> f b -> f g c` but not really as I enjoy using `<$>` and `<*>` and like how flexible and readable they feel
23:33:44 <ahri> and to be clear, that `f b` could be `g b` - I just want to be able to deal with this impedance mismatch in a nice way
23:36:40 <shiona_> So you wish to discard the possible information the Left could bring?
23:38:31 <ahri> Perhaps a simpler question is how to cleanly do `(Functor f, Functor g) => (a -> b -> c) -> f g a -> f g b -> f g c` with `<$>` and `<*>`, and I can sort out the depth of layers myself via `pure`
23:39:49 <cocreature> :t \f x y -> runMaybeT (f <$> MaybeT x <*> MaybeT y)
23:39:51 <lambdabot> error:
23:39:51 <lambdabot>     Variable not in scope: runMaybeT :: f0 b -> t2
23:39:51 <lambdabot> error:
23:40:00 <cocreature> @let import Control.Monad.Trans.Maybe
23:40:01 <lambdabot>  Defined.
23:40:04 <cocreature> :t \f x y -> runMaybeT (f <$> MaybeT x <*> MaybeT y)
23:40:05 <lambdabot> Monad m => (a1 -> a2 -> a3) -> m (Maybe a1) -> m (Maybe a2) -> m (Maybe a3)
23:40:08 <cocreature> ^ ahri
23:40:17 <ClaudiusMaximus> :t liftA2 ?f <$> ?a <*> pure ?b
23:40:18 <lambdabot> (?f::a -> b -> c, ?b::f2 b, ?a::f1 (f2 a), Applicative f2, Applicative f1) => f1 (f2 c)
23:41:16 <cocreature> :t \f x y -> getCompose (f <$> Compose x <*> Compose y) -- that one might be even nicer
23:41:17 <lambdabot> error:
23:41:17 <lambdabot>     Variable not in scope: getCompose :: f0 b -> t2
23:41:17 <lambdabot> error:
23:41:23 <cocreature> if it worked …
23:41:32 <cocreature> @let import Data.Functor.Compose
23:41:34 <lambdabot>  Defined.
23:41:35 <cocreature> :t \f x y -> getCompose (f <$> Compose x <*> Compose y) -- that one might be even nicer
23:41:36 <lambdabot> forall k1 (f :: k1 -> *) (g :: * -> k1) a1 a2 a3. Applicative (Compose f g) => (a1 -> a2 -> a3) -> f (g a1) -> f (g a2) -> f (g a3)
23:46:30 * hackage wss-client 0.2.0.0 - A-little-higher-level WebSocket client.  http://hackage.haskell.org/package/wss-client-0.2.0.0 (igrep)
23:54:35 <jle`> ahri: you can double-lifta2
23:54:41 <jle`> :t liftA2
23:54:42 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
23:54:47 <jle`> :t (liftA2 . liftA2)
23:54:48 <lambdabot> (Applicative f2, Applicative f1) => (a -> b -> c) -> f1 (f2 a) -> f1 (f2 b) -> f1 (f2 c)
23:54:55 <jle`> :t (liftA2 . liftA2 . liftA2)
23:54:56 <lambdabot> (Applicative f3, Applicative f2, Applicative f1) => (a -> b -> c) -> f1 (f2 (f3 a)) -> f1 (f2 (f3 b)) -> f1 (f2 (f3 c))
23:55:00 <jle`> repeat to go as deep as you need
23:55:25 <imjacobclark> Can anybody help me with a Regex question and FindAllMatches? I want to find out _how many_ matches my regex found, I have the following code: https://pastebin.com/mnbFff6A
23:55:28 <jle`> note that the behavior of MaybeT's Applicative instance is different than liftA2/Compose
23:55:38 <imjacobclark> But this is resulting in a No instance for (Foldable (AllTextMatches [])) arising from length error
23:55:41 <jle`> MaybeT's Applicative instance will short-circuit on effects if possible
23:55:42 <imjacobclark> and I just can't figure out why
23:55:54 <jle`> but liftA2.liftA2/Compose will always execute both effects
23:56:24 <jle`> in the case of Either though I don't think it matters
23:58:32 <jle`> imjacobclark: what regex library are you using?
23:58:44 <jle`> where is AllTextMatches from?
23:59:06 <imjacobclark> jle`: import Text.Regex.PCRE
23:59:34 <imjacobclark> in my package.yaml I have regex-pcre declared
23:59:44 <jle`> the package is regex-pcre, then?
