00:08:05 <cocreature> centril: hm I feel slightly uneasy about that but I can’t quite say why
00:08:45 <centril> cocreature: heh :)
00:38:00 * hackage html-conduit 1.3.1 - Parse HTML documents using xml-conduit datatypes.  http://hackage.haskell.org/package/html-conduit-1.3.1 (MichaelSnoyman)
00:39:17 <cocreature> huh, I have something like: traceShow "should error" (error "foobar")
00:39:29 <cocreature> I see the "should error" but the error call never seems to be executed
00:39:50 <cocreature> I’m a bit confused about what is happening here
00:41:00 * hackage mime-types 0.1.0.8 - Basic mime-type handling types and functions  http://hackage.haskell.org/package/mime-types-0.1.0.8 (MichaelSnoyman)
00:44:23 <cocreature> infact rather than crashing my code seems to hang forever
00:55:33 <cocreature> ahrg, typed-process silently swallows errors that are produced by the input string
00:56:51 <asheshambasta> hi everyone, which SQL library would you recommend for writing slightly complex queries via Haskell (queries with joins etc.)
00:57:11 <asheshambasta> I used Esqueleto, but it doesn't seem like it works with the latest persistent version (2.8.2(
00:59:00 * hackage alarmclock 0.5.0.2 - Wake up and perform an action at a certain time.  http://hackage.haskell.org/package/alarmclock-0.5.0.2 (dcturner)
01:37:37 <c50a326> zipWith is a function that takes "a function and two lists as parameters and then joins the two lists by applying the function between corresponding elements."
01:37:46 <c50a326> the type signature is zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
01:37:53 <c50a326> this is from LYAH... I'm confused with the type signature
01:38:26 <sternmull> what confuses you?
01:39:20 <[exa]> c50a326: it takes a function that can combine a and b to c (that's the (a->b->c) parameter)
01:39:20 <c50a326> well if I'm reading that it's a function that takes a function and two lists... then... well how many parameters does that function that you pass to it, how many parameters is that function supposed to take?
01:39:29 <c50a326> don't we need to know that ahead of time? this isn't explained in the text
01:39:33 <[exa]> c50a326: then a list of [a]'s, a list of [b]'s, and returns the list of [c]'s
01:40:26 <c50a326> why isn't it just (a -> b) -> [a] -> [b] -> [c]
01:40:34 <c50a326> oh
01:40:36 <c50a326> yeah I get it
01:40:38 <c50a326> nvm
01:40:50 <c50a326> ty
01:41:01 <[exa]> that type would be of 'map', without the ->[c] :]
01:41:03 <sternmull> the first argument (the thing in brackets) is a function that takes two arguments (with the element types of the two lists that are the next two arguments) and produces a value of the element type of the list that is finally returned.
01:43:00 * hackage hpack-dhall 0.2.0 - Dhall support for Hpack  http://hackage.haskell.org/package/hpack-dhall-0.2.0 (SimonHengel)
01:44:32 <zclod> i have a question, i'm trying to build some fold with the foldl library and i want to use the applicative instance. Let's say i have     data Foo = Foo a b      f1 :: Fold x a       f2 :: Fold x b      so (Foo <$> f1 <*> f2) :: Fold x Foo
01:45:49 <zclod> if instead f1 :: Fold x (a,a) and f2 :: Fold x (b,b)    how can i build a fold :: Fold x (Foo, Foo) ?
01:50:27 <zclod> here is the situation https://lpaste.net/4108861986492645376
01:51:04 <edmundnoble> Might anyone have a resource for merging radix tries?
01:51:20 <edmundnoble> zclod: `fmap (\a -> (a, a)) f3`
01:52:07 <c50a326> hey what's better, this:   zipWith' f as bs = [f a b| a <- as, b <- bs]
01:52:17 <c50a326> or this:   zipWith' f (a:as) (b:bs) = f a b : zipWith' f as bs
01:52:25 <Taneb> They do differen things
01:52:45 <c50a326> oh crap
01:52:53 <c50a326> I wrote zipWith in ghci instead of zipWith' to test
01:52:59 <c50a326> god damned ' things
01:53:13 <jle`> c50a326: yeah, the first one is known as liftA2 :)
01:53:22 <jle`> there is actually a parallel list comp extension, though
01:53:31 <jle`> zipWith' f as bs = [ f a b | a <- as | b <- bs ]
01:53:34 <jle`> but i don't think many people use it
01:53:49 <jle`> > [ (a, b) | a <- [1,2,3] | b <- "abc" ]
01:53:51 <lambdabot>  [(1,'a'),(2,'b'),(3,'c')]
01:54:24 <Taneb> Oh, I didn't realise we had that enabled in lambdabot
01:54:26 <jle`> even if that were in style, zipWith can be convenient because it can be used point-free
01:54:34 <jle`> as in, in partially-applied form
01:54:45 <jle`> @let addList = zipWith (+)
01:54:47 <lambdabot>  Defined.
01:54:49 <c50a326> oh unexpected parallel statement in a list comprehension
01:54:51 <jle`> > addList [1,2,3] [100,200,300]
01:54:54 <lambdabot>  [101,202,303]
01:54:56 <jle`> c50a326: yeah, you need to enable the extension
01:56:09 <jle`> if you're on ghci you can probably do :set -XParallelListComprehensions
01:56:18 <jle`> er
01:56:23 <jle`>  :set -XParallelListComp
01:56:29 * hackage logging-effect 1.3.1 - A mtl-style monad transformer for general purpose & compositional logging  http://hackage.haskell.org/package/logging-effect-1.3.1 (OliverCharles)
01:57:04 <c50a326> so what is it doing when using a comma instead of a pipe
01:57:12 <c50a326> I mean what is the original list comprehension that I wrote doing
01:57:35 <edmundnoble> Nested loops
01:57:38 <c50a326> > zipWith' f as bs = [f a b | a <- as, b <- bs]; zipWith' (+) [1,2,3] [4,5,6]
01:57:40 <lambdabot>  <hint>:1:18: error:
01:57:40 <lambdabot>      parse error on input ‘=’
01:57:40 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
01:58:27 <c50a326> well no idea why that doesn't work, it works on my system, but produces a bad result
01:59:01 <jle`> lambdabot evalutes expressions when you do >
01:59:02 <Taneb> > let zipWith' f as bs = [f a b | a <- as, b <- bs] in zipWith' (+) [1,2,3] [4,5,6]
01:59:04 <lambdabot>  [5,6,7,6,7,8,7,8,9]
01:59:11 <jle`> and ; doesn't join to expressions together
01:59:24 <c50a326> oh right
01:59:57 <c50a326> so why does this list comprehension produce this result
02:00:30 <thebnq> > [(a,b) | a <- [1..3], b <- ['a'..'c']]
02:00:33 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
02:06:11 <pong> hey guys, I'm finding the size of intersection of 2 distinctAscLists [Int] of lengths up to 1 million each
02:06:33 <pong> but my memory is limited to 1024m and stack is limited to 8m
02:06:49 <pong> how do I avoid a stack overflow in this case?
02:10:25 <edmundnoble> Investigate algorithms which use very little memory
02:10:39 <c50a326> does concurrency use less memory (sorry im a noob, interesting question tho)
02:10:46 <edmundnoble> Bloom filters, hyperloglog
02:11:09 <jle`> pong: consider if lists are the best data structure for what you are doing
02:11:24 <jle`> if you have a list of 1 million items, where did they come from?
02:15:23 <pong> read from stdin
02:16:38 <pong> first it's m guys in strictly increasing order then n more, also strictly increasing
02:17:24 <jle`> hm
02:17:32 <jle`> if i'm just using basic haskell, i'd probably use an IntSet
02:17:49 <jle`> oh, but the memory limit
02:18:18 <jle`> i feel like there shouldn't be too much problem
02:18:29 <jle`> % :set +t
02:18:30 <yahb> jle`:
02:18:42 <jle`> % IS.fromList [1..1000000]
02:18:48 <yahb> jle`: fromList [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,12
02:18:54 <jle`> oh no i'm sorry
02:19:10 <jle`> % IS.size (IS.fromList [1..1000000])
02:19:11 <yahb> jle`: 1000000
02:19:21 <jle`> oh, it's +s
02:19:26 <jle`> % :set +s
02:19:26 <yahb> jle`:
02:19:28 <jle`> % IS.size (IS.fromList [1..1000000])
02:19:28 <yahb> jle`: 1000000; (0.12 secs, 379,554,776 bytes)
02:19:58 <jle`> you're good :)
02:33:27 <pong> cd: Stack space overflow: current size 33624 bytes.
02:33:41 <pong> my limits are kinda conservative and I can't relax them
02:33:55 <pong> how would you read 2mil integers?
02:37:42 <cocreature> the question is not how do you read them. the question is how do you process them
02:38:00 <cocreature> if you’re short on memory, you need to find a way to never keep all of them in memory at the same time
02:38:08 <cocreature> how exactly that works depends on what you want to do with them
02:38:46 <pong> at a very minimum I need to keep the first 1mil
02:38:54 <pong> maybe read the next 1mil line by line then?
02:39:55 <cocreature> why do you need to have all of them in memory?
02:43:58 <haskeller125> Hey, I’m working through haskellbook, and have a beginner’s question:
02:44:19 <haskeller125> Why won’t this short snippet of code compile?
02:44:21 <haskeller125> https://lpaste.net/6362839610589970432
02:44:34 <haskeller125> I get “parse error in pattern” from ghci
02:45:00 <haskeller125> It doesn’t like my `(Wrap (f a))` pattern matching syntax
02:45:04 <haskeller125> Can anyone help?
02:45:13 <cocreature> haskeller125: can you compile the file using ghc?
02:45:39 <cocreature> ah no, I see the problem
02:45:44 <cocreature> you can’t pattern match on "f a"
02:45:58 <cocreature> imagine if f = []
02:46:08 <cocreature> (where f is the type parameter)
02:46:16 <cocreature> what would pattern matching on "f a" then bind to f and a?
02:47:59 * hackage vector-sized 1.0.3.0 - Size tagged vectors  http://hackage.haskell.org/package/vector-sized-1.0.3.0 (jophish)
02:48:17 <haskeller125> cocreature: I’m still not seeing the point…
02:49:06 <cocreature> haskeller125: what you want to do here is to pattern match on a _value_ of _type_ "f a"
02:49:32 <cocreature> you can fix the code by using something like "fmap func (Wrap x) = Wrap (func x)
02:49:34 <cocreature> "
02:49:54 <cocreature> values of type "f a" can’t be deconstructed into two values "x y"
02:50:20 <cocreature> haskeller125: it might also help if you use different names for type variables, value-level variables and different names for type constructors and data constructor
02:51:09 <haskeller125> right
02:52:17 <haskeller125> But, what I’m not seeing is why this is legal:
02:52:18 <haskeller125> https://lpaste.net/3813989683935838208
02:52:46 <haskeller125> On line 7, the pattern-matching seems identical/similar to what I was trying to do with the Wrap case...
02:53:00 <c50a326> are list comprehensions just syntactic sugar for map?
02:53:47 <cocreature> haskeller125: here you are deconstructing a value of type "Tuple a b" by pattern matching on the "Tuple" constructor and binding the value-level variables a and b to the two arguments to the constructor
02:53:49 <firc5e1e4308> c50a326: syntactic sugar for list monad
02:53:58 <cocreature> haskeller125: there is no constructor in your Wrap example
02:54:06 <c50a326> oh i didn't get to monad yet
02:54:12 <c50a326> I wonder if I'll get there today
02:54:18 <c50a326> I'm on higher order functions, lyah
02:54:45 <cocreature> zclod: if you just use them for a single list, then you can view them as syntactic sugar for map and filter
02:54:52 <cocreature> eh that was for c50a326
02:55:40 <haskeller125> cocreature: In the Wrap example, wouldn’t the type constructor just be f?
02:56:38 <pavonia> haskeller125: You match on data constructors in patterns
02:57:31 <firc5e1e4308> c50a326: https://lpaste.net/2540371845895421952
02:58:07 <haskeller125> Oh, I think I need to review my types 101
02:58:26 <haskeller125> so when you do data Maybe a = Just a | Nothing
02:58:39 <haskeller125> Why can’t you do data Maybe a = Just b | Nothing?
03:01:13 <pavonia> You can with an explicit forall, I think, but that type would be pretty useless
03:02:37 <haskeller125> Sorry pavonia; I’m not too familiar with forall
03:03:36 <haskeller125> Can you explain why you can’t do that without using a forall, ie. why it does not obey types 101?
03:03:49 <cocreature> haskeller125: that’s why I recommended using different names: the "f" you are pattern matching on needs to be a _data constructor_ not a _type constructor_
03:04:28 <cocreature> haskeller125: because all values that you use on the rhs of a data declaration must be bound on the lhs
03:05:06 <cocreature> haskeller125: let’s say you could define "data Maybe a = Just b | Nothing". now I give you a value of type "Maybe ()" and you pattern match on "Just x". what would the type of "x" be here?
03:06:06 <haskeller125> Wouldn’t it also be ()?
03:06:24 <haskeller125> Or…rather you can’t determine
03:06:34 <haskeller125> Because b doesn’t necessarily have to be the same as a
03:06:37 <cocreature> exactly
03:08:00 <haskeller125> cocreature: in Wrap (f a) (if you still remember), is Wrap the only data constructor?
03:09:22 <cocreature> haskeller125: if you define "data Wrap f a = Wrap (f a)" you are defining a type constructor "Wrap" that accepts two arguments f and a and a data constructor "Wrap" that accepts a single argument of type "f a"
03:11:43 <haskeller125> OK
03:11:46 <haskeller125> I understand that
03:12:06 <haskeller125> But then why aren’t you allowed to pattern-match using “Wrap (f a)”
03:12:15 <haskeller125> Since wouldn’t f also be a data constructor?
03:12:54 <cocreature> let’s rename this to "Wrap (c x)" to avoid confusion
03:13:26 <cocreature> your code is polymorphic in the type variable "f" so in particular you don’t know which constructors a value of type "f a" has
03:13:42 <cocreature> so all you can do is bind the argument of type "f a" to the Wrap constructor to some name
03:13:57 <cocreature> e.g. Wrap valueOfTypefa = …
03:14:48 <cocreature> think about my example from earlier where f = []
03:15:07 <cocreature> which values do you expect "c" and "x" to refer to in the pattern match?
03:16:24 <haskeller125> Hmm..wouldn’t c refer to “Cons” since [] is the type constructor for a list?
03:16:45 <haskeller125> And x can be any type that has kind * ?
03:18:25 <cocreature> but what if the list is empty, what should "x" refer to then?
03:19:13 <cocreature> and "x" can’t be a type, you are pattern matching on values
03:19:20 <cocreature> so "x" needs to refer to some value
03:19:26 <haskeller125> OK
03:19:36 <haskeller125> Yeah, sorry. I meant x is a value whose type is *
03:19:43 <cocreature> * is not a type
03:19:45 <haskeller125> whose kind*
03:19:59 <cocreature> values don’t have kinds, values have types that have kinds
03:20:00 <haskeller125> :( I’m getting my tongue tied lol
03:20:41 <cocreature> that’s the point here, there is no reasonable answer to what pattern matching on "Wrap (f a)" is supposed to do :)
03:20:45 <cocreature> which is why it’s not possible
03:20:49 <pavonia> The same for t = Maybe: c x could match on e.g. Just 123, but not on Nothing
03:21:44 <haskeller125> Oh
03:21:52 <haskeller125> This makes more sense now
03:22:42 <cocreature> if you set f = Proxy there is not even the option of extracting some x here
03:24:40 <haskeller125> So the point is that “f a” could be something like “Nothing”
03:24:49 <haskeller125> Or it could be “Just a”
03:25:09 <haskeller125> But since you don’t know, you can only pattern-match on “Wrap something"
03:25:18 <cocreature> the point is that a value of type "f a" can’t be deconstructed into two values "c" and "x"
03:25:44 <cocreature> because the type "f a" might have multiple constructor, no constructors, a single constructor with more than one argument, …
03:26:55 <haskeller125> Right
03:26:56 <haskeller125> OK
03:26:59 <haskeller125> That makes sense now
03:27:06 <haskeller125> Thanks cocreature, and pavonia
03:27:22 <haskeller125> Sorry if I was a pain :|
03:29:08 <cocreature> not at all, answering questions and clearing up confusion is what this channel is for :)
03:30:02 <haskeller125> cheers
03:45:32 <parenthetical> Why is GHC trying to deduce that i ~ () in the compile function here? https://lpaste.net/4787206320904208384
03:49:07 <cocreature> parenthetical: without looking too closely at it, I would guess that ExtendedDefaultRules is the culprit here
03:53:46 <malorie> do where-clauses not work across multiple pattern matches, in a function definition?
03:56:19 <maerwald> how do you pattern match?
03:57:35 <Taneb> malorie: they should work
03:58:56 <parenthetical> cocreature: without it I get https://lpaste.net/5749782580123664384 where the problem seems to be "Couldn't match expected type ‘t0’ with actual type ‘i’, ‘t0’ is untouchable"
03:59:32 <maerwald> malorie: https://lpaste.net/5423079875504242688
03:59:35 <maerwald> this indeed does not work
03:59:50 <maerwald> just use case-of expression instead
04:00:21 <malorie> fair enough
04:00:38 <Taneb> Oh, I was thinking having multiple patterns in the thing defined in the where
04:00:46 <iron_houzi> In Eric Meijer's paper on monadic parser combinators, the ++ operator is "instantiated" for MonadPlus, I cannot seem to confirm this by searching hoogle. In stead I've made instance of the current MonadPlus (mzero & mplus) and was therefore forced to make instance of Alternative with the <|> operator. Is <|> then the same as ++ in Eric's paper?
04:01:26 <iron_houzi> ++ For instances of Parser ..
04:01:37 <Taneb> iron_houzi: yes
04:01:42 <iron_houzi> ah, Thanks!
04:15:27 <cocreature> parenthetical: as a first step, add an explicit type signature to "compile x". in partiuclar figure out what you want "i" to be here
04:18:53 <parenthetical> cocreature: if I instantiate 'i' as e.g. Int it works. I'd really like it to be generic wrt 'i' though
04:20:56 <cocreature> parenthetical: I don’t mean the "i" in the type signature of "compile". I mean the "i" in the type of "compile x" which has to be "C i o v" for some choice of i o and v. GHC is rightfully complaining that "i" is ambiguous since it can’t infer "i" from the type of "x"
04:21:14 <cocreature> if you want that "i" to be the same as the one in the type signature of "compile" you can say so using ScopedTypeVariables
04:21:38 <cocreature> if you want it to be different and polymorphic, then add a type signature that specifies that
04:22:38 <parenthetical> cocreature: oh, sorry! I'll give that a go thanks
04:22:58 <cocreature> parenthetical: also as a general rule, I wouldn’t recommend ever using ExtendedDefaultRules outside of ghci
04:23:15 <parenthetical> okay
04:23:18 <cocreature> in fact, I would mostly recommend to not rely even on the regular defaulting
04:23:31 <cocreature> and the fact that -Wall warns about this shows that I’m not alone with this opinion :)
04:26:59 * hackage network-conduit-tls 1.3.1 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-1.3.1 (MichaelSnoyman)
04:32:30 <k0ral> how do you guys deal with the MonadIO/MonadBase IO redundancy ? MonadIO comes from base, so many lifted libraries use it, but MonadBase IO is a requirement from monad-control which is also used by many libraries, and I certainly do NOT want to clutter my signatures with both (MonadIO m, MonadBase IO m)
04:49:44 <juri_> so, if my haskell program parses a DSL, what is the best way to place documentation about the DSL into my code, and how do i export that into language documentation?
04:51:43 <c50a326> why doesn't the haskell subreddit have a sidebar
04:53:44 <lyxia> k0ral: make a class synonym?
04:54:45 <lyxia> c50a326: I see a sidebar
04:55:44 <c50a326> maybe it's to do with reddit's new ui
04:57:12 <c50a326> yeah this is the sidebar for me https://i.imgur.com/ZyHMAzl.png
04:57:18 <c50a326> it's empty
04:57:46 <lyxia> juri_: Are the users expected to be Haskell programmers? You could start with the basics in the README
04:58:21 <juri_> lyxia: nope!
05:03:15 <lyxia> juri_: then it's probably better to document your dsl outside the code
05:27:01 <iron_houzi> > concat ["0x", "0f40"]
05:27:04 <lambdabot>  "0x0f40"
05:27:21 <iron_houzi> > concat ("0x", "0f40")
05:27:23 <lambdabot>  "0f40"
05:27:56 <iron_houzi> Why does concat on tuples not behave like it does for lists?
05:29:25 <iron_houzi> ..or to avoid XY: I am trying to have show represent unicode characters as hex values instead of ints .. I'm fiddling with using showHex ..
05:30:00 * hackage greskell 0.2.0.2, greskell-core 0.1.2.1 (debugito): https://qbin.io/facts-corpus-b71j
05:31:46 <iron_houzi> showHex doesn't do zero padding or prepends "0x", so I'm doing: `zip (repeat "0x") map (\x -> showHex (Data.Char.ord x) "") "\3942\3984\4017"`
05:31:50 <pavonia> > concat (True, ["0x", "0f40"])
05:31:52 <lambdabot>  ["0x","0f40"]
05:32:55 <iron_houzi> is there a better way to do xy, or perhaps a zip that gives lists instead of tuples?
05:33:19 <pavonia> You probably want `zipWith (++)`
05:34:41 <iron_houzi> pavonia: Thanks!
05:54:05 <maerwald> mh, scotty documentation seems to be poor
05:55:54 <maerwald> no info on the main types and their API
06:13:43 <[exa]> maerwald: anything specific?
06:14:15 <maerwald> ScottyM and ActionM
06:14:39 <maerwald> they are all over the API, but it seems no one bothered to document them
06:18:27 <[exa]> well, actionT is just except/reader/state combo; scottyT is just a collector of routes and middleware...
06:18:53 <maerwald> yeah and nothing of that is explained
06:18:56 <maerwald> compare with https://hackage.haskell.org/package/snap-core-1.0.3.2/docs/Snap-Core.html#g:1
06:19:02 <c50a326> let mod3829is0 = flip mod 3829 == 0   -- what's wrong with this
06:19:20 <c50a326> I guess I don't understand precedence
06:20:37 <ski>   divides3829 = (0 ==) . (`mod` 3829)
06:20:39 <c50a326> and what about this:  let isDivBy3829 = `mod` 3829 == 0 in filter isDivBy3829 [1..100000]
06:20:54 <c50a326> ah I didn't cover . or $ yet :(
06:21:16 <ski> er, right, s/divides/divisibleBy/
06:21:42 <ski> @src (.)
06:21:43 <lambdabot> (f . g) x = f (g x)
06:22:24 <ski>   divisibleBy3829 n = n `mod` 3829 == 0
06:22:40 <ski>                     = (n `mod` 3829) == 0
06:22:51 <ski>                     = (== 0) (n `mod` 3829)
06:22:56 <zfnmxt> I've been loading my test suite into ghci by doing `stack ghci compiler:compiler-test`, but when I do this, ghci doesn't load my standard `src` directory as well (as if I just typed stack ghci). Is it possible to load both at the same time?
06:22:58 <ski>                     = (== 0) ((`mod` 3829) n)
06:23:10 <ski>                     = ((== 0) . (`mod` 3829)) n
06:23:37 <ski> so
06:23:38 <ski>   divisibleBy3829 n = ((== 0) . (`mod` 3829)) n
06:23:42 <c50a326> oh yeah I forgot to define the function as taking an argument lol
06:23:44 <ski>   divisibleBy3829 = (== 0) . (`mod` 3829)
06:23:50 <c50a326> I guess I was trying to use partial/curry stuff :\
06:24:59 <ski> the final step here is known as "function extensionality" (if two functions give the same output for every input (here `n'), then they are the same function. functions are "extensional", defined by their output "behaviour" for every possible input)
06:25:51 <ski> there's no currying going on here. currying is one convention/style/encoding/representation for simulating multiple arguments in Haskell
06:26:08 <ski> (simulating, because in Haskell, every function takes exactly one argument)
06:26:39 <c50a326> cool, ty
06:27:21 <ski> (the other common convention is sometimes known as tupling, where you pass your "several arguments" together in a compound structure (a single argument), typically a tuple or a record, but could also be a list or somethinhg else)
06:28:23 <ski> so if we say `curriedFoo x y = ..x..y..', then `curriedFoo' is expressing the "multiple argument function from `x' and `y' to `..x..y..' in a curried fashion
06:29:02 <ski> while with `tupledFoo (x,y) =..x..y..' we're expressing "the same multiple argument function" in a tupled fashion
06:29:23 <ski> to "curry" a function is to change from the latter representation to the former
06:30:11 <ski> "partial application" means to provide some, but not all, of the arguments to a "multiple argument function" (no such thing in Haskell, strictly speaking, as I already said)
06:31:46 <ski> so if we want the function that maps a ("late") input `x' to `..x..v..' (where `y' has been replaced with the value (the "early input") `v', then that's partial application of our function here
06:32:44 <ski> and of course, you could instead partially apply in the other argument, getting as result a function from the (late) input `y' to `..u..y..' (assuming that we have already provided the value `u' as early input for the `x' parameter)
06:35:09 <ski> in terms of the `tupledFoo' representation in Haskell, we could define `fooWithV x = tupledFoo (x,v)' .. this is the same as the definition `fooWithV = (\x -> tupledFoo (x,v))'. `\x -> tupledFoo (x,v)' is the partially applied function itself, which decide to refer to with the name `fooWithV'
06:36:53 <ski> (and the other partial application is then the function `\y -> tupledFoo (u,y)', which we can give the name `fooWithU' by the definition `fooWithU = \y -> tupledFoo (u,y)', or, equivalently `fooWithU y = tupledFoo (u,y)')
06:37:48 <ski> if we instead want to partially apply the curried representation, then we'd say `fooWithV x = foo x v' (or `fooWithV = \x -> foo x v')
06:38:33 <ski> er, `foo' there should be `curriedFoo', for consistency with what i said before
06:39:05 <maerwald> is this a monologue?
06:39:38 <ski> and, for the other partial application, `fooWithU y = curriedFoo u y' (or `fooWithU = \y -> curriedFoo u y') -- *however*, in this case (only), we can simplify this to `fooWithU = curriedFoo u'
06:39:50 <ski> maerwald : atm, yes
06:41:19 <ski> c50a326 : typically, when one talks about "partial application" in Haskell, one means this last case of partially applying a multiple-argument function represented in the curried fashion (iow, a function accepting one input, then returning a new function that ...  eventually giving the "final result")
06:41:40 <ski> c50a326 : hth
06:49:42 <c50a326> hey sorry I was changing locations
06:49:51 <maerwald> https://hackage.haskell.org/package/wai-extra-3.0.22.1/docs/src/Network-Wai-Middleware-RequestLogger.html#logStdout
06:49:52 <hodapp> story of my life
06:50:05 <maerwald> unsafePerformIO
06:50:13 <maerwald> great logging implementation
06:50:29 <c50a326> are you also travelling lol... internet isn't the best in india
07:00:41 <c50a326> > sum [x^2 | x <- [1..10000], odd (x^2)]
07:00:44 <lambdabot>  166666665000
07:00:49 <c50a326> > sum (takeWhile (<10000) [x^2 | x <- [1..], odd (x^2)])
07:00:51 <lambdabot>  166650
07:00:59 <c50a326> what's going on here? :( why the difference in result?
07:01:30 <mniip> in the former you're taking x that are less than 10000
07:01:39 <mniip> in the latter you're taking x^2 that are less than 10000
07:02:03 <c50a326> oic
07:02:20 <c50a326> yes its pretty obvious now that you mention it
07:03:47 <dmwit> ?quickCheck \max -> sum [x^2 | x <- [1..max], odd (x^2)] == sum (takeWhile (<max) [x^2 | x <- [1..], odd (x^2)])
07:03:47 <lambdabot> Unknown command, try @list
07:03:52 <dmwit> ?check \max -> sum [x^2 | x <- [1..max], odd (x^2)] == sum (takeWhile (<max) [x^2 | x <- [1..], odd (x^2)])
07:03:55 <lambdabot>  *** Failed! Falsifiable (after 5 tests):
07:03:55 <lambdabot>  3
07:04:26 <dmwit> > ([x^2 | x <- [1..3]], takeWhile (<3) [x^2 | x <- [1..], odd (x^2)])
07:04:28 <lambdabot>  ([1,4,9],[1])
07:05:52 <dmwit> c50a326: This demonstrates two debugging techniques that I've found useful. First one is to look at subexpressions of the thing you care about to try to find one that differs. In the case above, you call `sum` on two different lists, and the sum differs, so my first thought is to check how the lists differ.
07:06:32 <dmwit> c50a326: Second technique is to use QuickCheck to generate an input small enough that I can look at inputs and outputs by hand. 10000 elements is way to big for my puny human brain, but I can handle 3 elements no problem.
07:07:05 <dmwit> > ([x^2 | x <- [1..3], {- whoops, forgot this -} odd (x^2)], takeWhile (<3) [x^2 | x <- [1..], odd (x^2)])
07:07:07 <lambdabot>  ([1,9],[1])
07:13:00 * hackage tuple-sop 0.3.1.0 - functions on n-ary tuples using generics-sop  http://hackage.haskell.org/package/tuple-sop-0.3.1.0 (ferdinandvw)
07:19:25 <zfnmxt> What's the recommended library for spawning a process and getting the result?
07:20:14 <cocreature> zfnmxt: process or if you want a slightly more modern (and in some sense simpler) version typed-process
07:22:06 <zfnmxt> cocreature: Thanks :)
07:32:59 * hackage derulo 1.0.2 - Parse and render JSON simply.  http://hackage.haskell.org/package/derulo-1.0.2 (fozworth)
07:34:30 <veverak> hmm
07:34:42 <veverak> seems like cabal ignores --buildir when I "cabal install" into a sandbox
07:42:30 * hackage salve 1.0.3 - Semantic version numbers and constraints.  http://hackage.haskell.org/package/salve-1.0.3 (fozworth)
07:48:07 <veverak> well, --snapshot on add-source solved my problems
07:53:53 <dganti> I have a pr and i need some help improving it. https://github.com/kubernetes-client/haskell/pull/19. I would appreciate any input. Thank you.
07:59:37 <cocreature> dganti: anything specific that you would like help with? a > 600 line diff makes it somewhat hard to spot the places that you want to improve
08:00:09 <dganti> cocreature thanks..yeah..sure. There are a couple of issues that seem to bug me. Let me paste them.
08:02:11 <dganti> cocreature https://lpaste.net/600514476126502912 this really seemed odd.
08:04:45 <cocreature> dganti: waitAny [] will never return
08:06:55 <cocreature> dganti: it looks like you never use the result of waitForThreads
08:07:12 <cocreature> dganti: so one option would be to change the return type to IO ()
08:07:14 <dganti> cocreature: thanks for catching that :). I am going to fix that. Let me do that.
08:07:56 <cocreature> then you should be able to do something like "waitForThreads maybeR sender = traverse_ (\r -> waitAny [r, sender]) maybeR
08:07:58 <dganti> cocreature to change to type IO() but that resulted in one of the threads not getting created correctly or I forget but my client returned a deadlock.
08:08:25 <dganti> let me try that cocreature. I would rather have a traverse than the way i have lined them up.
08:08:41 <cocreature> but there is also nothing wrong with an explicit pattern match tbh
08:09:02 <cocreature> there is no need to codegolf everything and you can definitely take it too far and make an unreadable mess out of your code
08:09:09 <dganti> cocreature, then my fix would be to just match for Nothing and handle that correctly. Let me fix that and paste it.
08:10:16 <dganti> cocreature i agree.
08:27:13 <dganti> cocreature ; https://lpaste.net/8406646463211241472 i believe this should fix it. thanks.
08:27:52 <cocreature> yeah although that looks different, now you always wait for the sender rather than immediately returning if the first argument is Nothing
08:28:27 <cocreature> you could write this as "waitForThreads mayR sender = waitAny (sender : toList mayR)" (whether that’s an improvement is up for debate :))
08:36:45 <dganti> cocreature. Let me think about this. I think if there is a thread, I would like to wait for it complete. At least that how i am interpreting the incoming client's exec call (a bit more detail).
08:42:28 <shafox> How do I inherit all the properties of a data type from another module ?
08:43:01 <Solonarv> you don't
08:43:10 <Solonarv> there is no inheritance in haskell
08:45:50 <shafox> So if I want to expose for example a lib, and then how the end user can leverage the data type to create new data type inheriting all the properties so that not to duplicate.
08:47:36 <darkJedi> Hi! I was learning do blocks and sequencing actions inside them. https://lpaste.net/7969986385291509760a
08:48:14 <__monty__> darkJedi: "Not Found"
08:48:53 <darkJedi> I wanted to read a string and split it space to create a list.
08:49:59 <darkJedi> I looked up in hackage. And using splitOn I can split a string by a delimiter.
08:50:14 <__monty__> darkJedi: And what exactly is the problem? There's a function for splitting on whitespace: `words`
08:50:24 <__monty__> splitOn would be fine too.
08:51:54 <darkJedi> monty: I'm getting this error. Couldn't match expected type ‘IO [Char]’ with actual type ‘[[Char]]’ In a stmt of a 'do' block: nums <- splitOn " " name In the expression: do { name <- getLine; nums <- splitOn " " name; putStrLn ("Hi, " ++ nums ++ ".") }
08:52:27 <darkJedi> So If I do a getLine then the value will be an IO Monad ?
08:54:08 <__monty__> :t getLine
08:54:10 <lambdabot> IO String
08:54:21 <__monty__> :t splitOn
08:54:23 <lambdabot> Eq a => [a] -> [a] -> [[a]]
08:55:11 <__monty__> splitOn is not an IO action so you want `let nums = splitOn ...`
09:02:00 <dminuoso> darkJedi: You don't "do" a getLine =)
09:02:28 <dminuoso> darkJedi: You may be interested to know that do-notation is merely syntax sugar around >> and >>=
09:02:58 <darkJedi> dminuoso: I had learnt that few days back.
09:03:53 <Solonarv> @undo do name <- getLine; putStrlLn ("Hello " ++ name)
09:03:53 <lambdabot> getLine >>= \ name -> putStrlLn ("Hello " ++ name)
09:05:15 <dminuoso> :t (>>)
09:05:15 <dminuoso> :t (>>=)
09:05:16 <lambdabot> Monad m => m a -> m b -> m b
09:05:16 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:05:54 <dminuoso> darkJedi: <- is basically just a visually flipped (>>=)
09:06:16 <__monty__> darkJedi: Your only mistakes are using <- for splitOn and using a [String] to concatenate to a String afaics. That means the desugaring uses the list monad's >>=, which you don't want.
09:07:10 <dminuoso> darkJedi: Can you see how the `m` remains the same?
09:07:28 <dminuoso> If we fix m to be IO, then the type signature becomes: IO a -> (a -> IO b) -> IO b
09:07:57 <dminuoso> Does (splitOn " " name) give you some `IO b` (for some particular choice of b)?
09:08:45 <darkJedi> dminuoso: I looked at it's type signature. It doesn't give me back an `IO b`
09:10:40 <darkJedi> __monty__: dminuoso: Thanks
09:17:11 <malorie> is there a way, in haskell's type system, to deal with values that can only inhibit a subset of the product of two sum types? if that makes sense
09:17:47 <cocreature> malorie: can you give some example? I’m not sure I understand you correctly
09:18:17 <Solonarv> yes, but you need to write your sum type in a specific way
09:19:00 <Solonarv> @let data FooBar hasfoo hasbar = Foo hasfoo {- other fields -} | Bar hasbar {- other fields -}
09:19:02 <lambdabot>  Defined.
09:19:39 <Solonarv> @let data FooBar hasfoo hasbar = Foo !hasfoo {- other fields -} | Bar !hasbar {- other fields -}
09:19:40 <lambdabot>  .L.hs:183:1: error:
09:19:40 <lambdabot>      Multiple declarations of ‘FooBar’
09:19:40 <lambdabot>      Declared at: .L.hs:180:1
09:19:52 <Solonarv> @let data FooBar2 hasfoo hasbar = Foo2 !hasfoo {- other fields -} | Bar2 !hasbar {- other fields -}
09:19:53 <lambdabot>  Defined.
09:20:28 <Solonarv> you can set `hasfoo` to `()` to enable the Foo2 constructor, or `Void` to disable it, or leave it polymorphic if it doesn't matter
09:21:30 <hexagoxel> that looks like a sum of two products
09:24:08 <hexagoxel> for a product of two sums, perhaps make both sums GADTs with some tag, so that the product can specify those tags?
09:25:53 <hexagoxel> data A (k :: Bool) where A1 :: A False, A2 :: A True, A3 :: A True
09:25:58 <hexagoxel> same for some B
09:26:26 <Solonarv> that's still a sum-of-products
09:26:27 <hexagoxel> then: data MyProduct = MyProduct (A 'True) (B 'True)
09:26:42 <Solonarv> oh wait I see now
09:26:45 <Solonarv> yeah you can do that
09:27:11 <Solonarv> point is use a type parameter to control whether a constructor is enabled
09:27:19 <malorie> I see
09:28:19 <hexagoxel> if you use bool, that bool encodes a specific subset. so if you want a different subset for a different, separate product, you'd need another argument.
09:28:35 <malorie> but that'd require me to e.g. prefix the identifiers for the second sum-type, no?
09:29:28 <Solonarv> there's actually a paper about this
09:29:29 <Solonarv> https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/trees-that-grow.pdf
09:29:37 <Solonarv> this technique is used by GHC
09:30:55 <malorie> thanks, I'll have a look
09:33:24 <hexagoxel> malorie: i don't see what would need prefixing. the constructors? but i thought we started with two separate sum types with distinct constructors already?
09:36:42 <dminuoso> darkJedi: https://gist.github.com/dminuoso/2c580dfa39395aaef51943e9f26c587c here you can see the desugaring. :)
09:38:48 <c50a326> do you guys use fonts that display actual lambda when you type them in haskell?
09:39:47 <c50a326> or editor settings/plugin or something
09:41:03 <malorie> hexagoxel: well, iiuc, for each construct in the first sum type, I'd have a data-type that lists all the constructors of the second sum type, plus the on-off switches, right?
09:41:16 <malorie> s/construct/constructor
09:41:29 <dminuoso> c50a326: No but I know some folks like to use fonts with special ligatures for things like >>=
09:42:04 <dminuoso> Was it jle`? I cant remember.
09:42:59 <Solonarv> I wanted to use Hasklig but VSCode didn't seem to like it
09:42:59 <c50a326> I wouldn't mind seeing real lambdas in my editor, it'd make me feel special
09:43:25 <Solonarv> you can turn on unicode syntax and just use λ
09:43:49 <cocreature> Solonarv: actually you can’t for lambdas :)
09:43:50 <c50a326> oh sweet
09:44:00 <Solonarv> oh really? that's odd
09:44:04 <geekosaur> Solonarv, lambda is Unicode letter syntax
09:44:17 <geekosaur> just because it's not a letter in the alphabet you normally use doesn;t mean it's not a letter
09:44:18 <c50a326> tbh I really like the shape of the lambda character anyway, it's just a very nice letter
09:44:30 <Solonarv> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unicode-syntax btw
09:44:31 <dminuoso> cocreature: Sure you can *see* them. A sufficiently smart editor could render a lambda when it knows its a lambda \
09:44:51 <cocreature> dminuoso: ofc you can see them, my point is that UnicodeSyntax doesn’t help here
09:46:49 <hexagoxel> malorie: https://lpaste.net/184858845573545984
09:49:39 <malorie> hexagoxel: ok, I see now. my case is a bit different, though. basically, all the constructors in my first sum-type are on, and for each of those constructors, a different set of the constructors of the second sum-type is on
09:56:23 <dminuoso> cocreature: Ah somehow I thought you were responding to the other guy. :)
09:56:27 <dminuoso> Or person.
09:58:02 <hexagoxel> malorie: https://lpaste.net/6502751816684404736
09:58:51 <hexagoxel> malorie: the duplication around the sum types is unfortunate, but i don't know a way around it.
10:01:22 <malorie> hexagoxel: no problem. this is still very educational :-)
10:02:08 <hexagoxel> it is a full-on dive into datakinds + type families i guess :p
10:02:16 <hexagoxel> and constraintkinds
10:03:45 <__monty__> c50a326: I do use conceals in vim.
10:04:29 <__monty__> c50a326: This to be more precise: https://github.com/enomsg/vim-haskellConcealPlus
10:04:45 <__monty__> Note that some conceals do interfere with alignment.
10:05:05 <malorie> hexagoxel: it sure is. I wonder, if it could be done easier, with dependent types, though
10:09:42 <mikelui> I'm using Megaparsec, and it seems like this parser: `sepBy (many digitChar) (return comma)` causes an infinite parse. Is there something obvious I'm missing?
10:09:51 <hexagoxel> yeah, we are emulating dependent types in a mildly verbose fashion. With proper dependent-type support i suppose you would at least not have to define those GADTs.
10:10:00 * hackage nvim-hs 1.0.0.2 - Haskell plugin backend for neovim  http://hackage.haskell.org/package/nvim-hs-1.0.0.2 (saep)
10:10:19 <hexagoxel> many1?
10:10:53 <mikelui> hexagoxel: I thought about that but didn't test it because the current version of Megaparsec (at least in stack) doesn't have many1
10:11:21 <mikelui> sepBy and many are reexported from Control.Monad.Combinators (hence (return comma))
10:11:35 <dminuoso> Oh interesting. So megaparsec uses many/many1 instead of many/some?
10:12:26 <dminuoso> mikelui: You can use `some` from Control.Applicative
10:12:33 <Solonarv> they should be identical; the different names are mostly a historical accident
10:12:33 <hexagoxel> no, i meant `some`
10:12:41 <int-e> dminuoso: pretty sure it's always been many/many1 in Parsec
10:12:45 <Solonarv> because parser combinator libraries actually predate Alternative
10:12:55 <int-e> dminuoso: and hence, most of its derivatives
10:13:02 <dminuoso> int-e: Ah that makes sense.
10:14:09 <monochrom> What does "return comma" mean?!
10:14:23 <int-e> > comma
10:14:25 <lambdabot>  ,
10:14:28 <int-e> :t comma
10:14:29 <lambdabot> Doc
10:14:58 <monochrom> I very much doubt it's the same "comma" in "sepBy (many digitChar) (return comma)"
10:15:05 <mikelui> Yea `some` looks to fix it. I'll have to look at the sepBy implementation to see why `many` casued that issue :/
10:15:45 <mikelui> I actually had to define my own comma as `44 : Word8` to get it to play nice with Megaparsec's bytestring implementation
10:16:05 <monochrom> At any rate, this parser is saying "separated by the empty string".  This can only cause trouble.
10:16:27 <dminuoso> Because it doesn't consume any input?
10:16:38 <int-e> :t oneOf
10:16:39 <lambdabot> Eq a => [a] -> Splitter a
10:16:40 <dminuoso> The comma parser I mean
10:16:41 <int-e> hmm
10:16:55 <int-e> there are too many libraries
10:17:11 <monochrom> Yes. More than that. It always succeeds and it doesn't consume any input and it doesn't even care.  It's a return.
10:17:23 <monochrom> No one really uses "return blah" for delimiters.
10:17:40 <int-e> maybe you want: char 44
10:17:55 <mikelui> hmmm, because sepBy came from Control.Monad.Combinators, it needed a Megaparsec wrapped value, so I thought return would do that (Megaparsec defined combinators just would need the Word8)
10:18:03 <hexagoxel> monochrom is correct, and many/some is a red herring. my bad.
10:18:21 <mikelui> It complained about type mismatches otherwise
10:19:01 <mikelui> a ParsecT wrapped value, to be more specific
10:19:03 <int-e> actually the Word8 confuses me now... how is that working together with digitChar?
10:19:21 <hexagoxel> (although you might want `some` in that instance)
10:19:31 <cocreature> mikelui: you probably want something like "char ','"
10:19:49 <mikelui> There's a Text.Megaparsec.Byte that defines everything for Word8's. I'm using it because my input is a ByteString
10:20:01 <mikelui> Otherwise normally one would use Text.Megaparsec.Char
10:20:14 <dminuoso> mikelui: `return` creates a pure parser that doesnt consume input but readily produces a value.
10:20:15 <int-e> ah, my bad, looking at the wrong module
10:20:39 <mikelui> Should've stuck with Parsec ha
10:21:31 <cocreature> huh? this has nothing to do with parsec vs megaparsec
10:22:05 <mikelui> I just assumed the cross library confusion would be less
10:22:19 <int-e> mikelui: so  comma = char 44  should parse a single comma
10:22:59 <rotaerk> is ghc-mod not used all that much?  it's way behind in terms of GHC version support
10:23:13 <rotaerk> just kind of surprised it's so behind without getting a lot of attention
10:23:15 <int-e> (with type  comma :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)  )
10:24:43 <mikelui> int-e: Thanks, that works. Oof, brain fart
10:25:05 <Solonarv> I can't speak for other people, but I use intero (with vs code's haskero plugin as the frontend)
10:25:47 <Solonarv> I don't use ghc-mod partly because it lags so far behind
10:30:44 <rotaerk> hmm k
10:32:17 <rotaerk> I'm just looking into using the Kakoune editor, and thinking about how haskell tooling would be integrated
10:32:28 <rotaerk> tired of trying to get emacs to work
10:32:36 <__monty__> I've resorted to just ghcid.
10:32:53 <rotaerk> yeah I *just* discovered that
10:33:43 <__monty__> Oh, and fast-tags.
10:33:44 <cocreature> __monty__++
10:34:18 <sternmull> i use "stack build --file-watch", it builds as soon as i safe a file and gives me immediate feedback. But yes... tooling is sad.
10:35:22 <cocreature> sternmull: that sounds like a worse version of ghcid :)
10:35:50 <sternmull> what does ghcid does better?
10:35:53 <__monty__> Probably not that much of a difference practically though.
10:36:04 <cocreature> it’s significantly faster for one
10:36:09 <rotaerk> I don't use stack, so ghcid looks like what I'll use too; Kakoune heavily favors integration with commandline tools
10:36:39 <__monty__> cocreature: Is it? You can probably pass -fno-code or -fobject-code to stack too.
10:37:00 <rotaerk> such as selecting something in the buffer, piping it to a commandline tool, and then putting the output of that tool back into the buffer
10:37:03 <sternmull> i actually do "stack build --file-watch --fast" which does pretty quick incremental builds, can't complain much about that (as long as i don't change everything or add a dependency)
10:37:36 <__monty__> Maybe ghcid has more features though, can stack run tests upon succesful build?
10:37:38 <cocreature> __monty__: -fobject-code doesn’t make sense since when you’re compiling outside of ghci you are always compiling to object code
10:38:02 <cocreature> not sure about the performance of -fno-code but without that just linking will take up a significant amount of time
10:38:25 <cocreature> whereas ghci reloads seem to do much better in that regard/avoid the problem
10:39:13 <sternmull> i stuck with --file-watch after trying some "ide integration" in atom and elsewhere. Everything was slow and eating CPU and RAM... seriously, my 16GB where not enough when opening pandoc for fun.
10:39:21 <rotaerk> hmm just ran across Haskell IDE Engine (HIE) ... wonder how that is
10:39:57 <__monty__> sternmull: Check out ghcid though, it's pretty nice and it can use stack.
10:40:09 <monochrom> Haskell IDE Engine is a backend. And even then it's still under construction.
10:40:28 <sternmull> __monty__: Maybe next time i do haskell stuff.
10:42:31 <monochrom> But read https://www.parsonsmatt.org/2018/05/19/ghcid_for_the_win.html for a refreshing perspective of why you can actually do away with IDE.
10:43:52 <sternmull> I always wonder why the haskell IDE tools need so many RAM/CPU. At least resolving identifiers should be pretty easy. There is no overloading. Just follow the damn imports and implement the scoping to figure out where a symbol comes from. Ok, types are more difficult. But they can be queried on demand, no need to kill my system for that while i just navigate my source files.
10:43:53 <nicknight> hey all
10:44:01 <rotaerk> monochrom, oo, thanks
10:45:13 <__monty__> monochrom: The advantage of IDEs is in the I, as in you install one and it has everything: editing, compiling, running tests, browsing documentation, VCS, refactoring, etc.
10:45:28 <hexagoxel> i need at least jump-to-error functionality, but i just taught my editor to read+parse the ghcid output.
10:45:40 <monochrom> The disadvantage is someone has to write it.
10:46:24 <dminuoso> And someone has to maintain it against unstable GHC APIs.
10:46:29 <monochrom> How much money did IBM throw at merely Eclipse?  Microsoft at VS?  Whoever at IntelliJ?
10:46:38 <__monty__> monochrom: Yeah, just saying that no one part can really replace an IDE, the motivation isn't how useful it is but how easy it is.
10:46:40 <dminuoso> So while it may work one day, it may break once you update things..
10:47:46 <__monty__> I'm not an IDE sort of person, I'd much rather mix and match. I just understand where people who want one are coming from.
10:49:33 <monochrom> I always need to remind leftist FOSS programmers of the following Aesop tale because they have lived in the free-lunch illusion for too long.  A group of mice convene and vote that they "just" need to tie a bell under the cat's neck to gain early warning.  But they can't figure out who should go do it.
10:50:09 <maerwald> rotaerk: HIE is nice, but some language clients don't support everything
10:50:28 <rotaerk> ah
10:50:31 <maerwald> especially https://github.com/autozimu/LanguageClient-neovim/issues/471
10:50:49 <maerwald> I use it in conjunction with raw ghc-mod
10:51:05 <maerwald> because for some things, directly using ghc-mod is still more powerful
10:51:33 <rotaerk> I was looking into ghc-mod, but it doesn't support GHC 8.2, at least the version I have easy access to
10:51:43 <maerwald> yeah, HIE is better on that end
10:51:56 <monochrom> On the bright side, I saw some of my students using Visual Studio Code.  It looked OK.  And on I think 4-8GB laptops.
10:52:46 <rotaerk> I'm really liking the philosophy and design of the Kakoune editor, and it looks like ghcid is the most appropriate option for spicing it up
10:53:00 <rotaerk> I wonder how I'm only just now discovering ghcid...
10:53:13 <maerwald> I don't know, intero and all that ghci stuff is so boring I am not sure why I would want to use it
10:53:18 <maerwald> doesn't even support code completion
10:53:49 <rotaerk> kakoune has built-in code completion, though the completion options are based on your open buffers, rather than some sort of index of all libraries
10:54:05 <maerwald> you can use HIE for code completion
10:54:15 <maerwald> then you need a code completer that can talk to a language server, like deoplete
10:54:40 <rotaerk> I do see that there's a LSP-support plugin for kakoune, which could help with integration with HIE
10:58:11 <rotaerk> for the most part, I don't actually want that many features ... I want dumb indentation logic (i.e. sustain indentation of previous line, let me manually apply changes in indentation), and I don't really care about code completion.  but quickly being able to determine the type of an expression, or maybe to be able to auto-generate the type annotation for a top level binding, or to go-to-definition or find-all-references, or to quickly hoogle
10:58:11 <rotaerk> something... those things would be nice
10:59:02 <__monty__> You can get OK completion from tags files.
10:59:11 <sternmull> i totally agree, that and highlighting of build/linter messages and i am happy
10:59:30 <sternmull> (not the tag files)
11:00:00 <sternmull> i mean i was replying to rotarek
11:00:13 <__monty__> monochrom: I hope you're not accusing me of wanting a free lunch? Working with 2Gs of RAM here.
11:00:19 <rotaerk> heh
11:07:33 <parsnip> isn't that almost the bare minimum RAM to even use haskell?
11:07:52 <maerwald> building HTTP usually takes 4gb of ram
11:07:55 <c_wraith> unless you're compiling a few especially painful libraries, 512M will work.
11:08:06 <c_wraith> ...  ok, that's one of the especially painful libraries
11:08:17 <maerwald> it also crashed my laptop before
11:08:41 <__monty__> I manage to get by, only work on my own small projects though.
11:09:33 <__monty__> Also use nix and updating my ghc environment is pretty brutal, takes hours, probably because it needs most of my 4G swap.
11:10:21 <parsnip> isn't swap >> RAM a diminishing returns thing?
11:11:02 <__monty__> Diminishing or not I actually need it.
11:11:03 <parsnip> i forgot if the swap trick for VPS fixes the small RAM thing.
11:25:00 * hackage extensible-effects 2.6.3.0 - An Alternative to Monad Transformers  http://hackage.haskell.org/package/extensible-effects-2.6.3.0 (shergill)
11:26:00 * hackage protocol-buffers 2.4.11, protocol-buffers-descriptor 2.4.11, hprotoc 2.4.11 (TvH): https://qbin.io/soc-helped-klin
11:29:59 * hackage egyptian-fractions 0.1.0.0 - Egyptian fractions in Haskell  http://hackage.haskell.org/package/egyptian-fractions-0.1.0.0 (vmchale)
11:36:29 * hackage haskeline 0.7.4.3 - A command-line interface for user input, written in Haskell.  http://hackage.haskell.org/package/haskeline-0.7.4.3 (JudahJacobson)
11:41:30 * hackage darcs 2.14.1 - a distributed, interactive, smart revision control system  http://hackage.haskell.org/package/darcs-2.14.1 (GaneshSittampalam)
12:04:26 <infinisil> Hey, is there a regex package that allows me to supply a regex AST instead of a string?
12:05:18 <infinisil> E.g. so that I can give it [Char 'a', Many (Char 'b'), Char 'c']
12:05:57 <dminuoso> infinisil: parser combinators?
12:06:05 <Solonarv> regex-tdfa has this https://www.stackage.org/haddock/lts-11.15/regex-tdfa-1.2.3.1/Text-Regex-TDFA-Pattern.html
12:06:20 <infinisil> dminuoso: Hmm.. good point
12:06:35 <infinisil> Solonarv: Nice!
12:06:45 <infinisil> Now I wonder, what's the difference between using regex for this or a parser?
12:06:55 <infinisil> Hold on, I'll explain what I'll use it for
12:08:28 <ammar2> fun fact: the language we write regexs in is not a regular language, its a context free language
12:08:35 <ammar2> so you can't parse regexs with regex
12:09:03 <infinisil> I have a datatype ~ [Maybe Text], where Nothing represents anything, and Just represents exactly the given string. Now I need to match such a value with a Text, and fill out the Nothing values with the corresponding parts in the Text
12:09:10 <Solonarv> I mean most "regexes" out in the wild aren't actually regular
12:09:26 <ammar2> true, you can blame (perl) for that?
12:09:36 <dminuoso> Perl regex are turing complete, are they not?
12:09:42 <infinisil> Or simpler: I need to find out the .* parts when I match "foo.*bar.*baz" with "fooabarbbaz"
12:09:48 <infinisil> (but it's a datatype)
12:12:58 <infinisil> Now my idea is to map [Maybe Text] to a regex pattern, Just text -> list of PChars, Nothing -> PStar True PDot
12:12:59 * hackage fficxx 0.4 - automatic C++ binding generation  http://hackage.haskell.org/package/fficxx-0.4 (IanWooKim)
12:13:11 <infinisil> Should work well, I hope
12:18:16 <hexagoxel> parser combinators would be tricky for this if you want to accept "foobarbazbaz"
12:18:52 <dminuoso> Depending on possible inputs stringsearch might be sufficient
12:23:19 <infinisil> Possibly any char, well not really, but a lot of stuff will pass thru, and I really don't know what will come
12:27:18 <phadej> @package regex-applicative
12:27:18 <lambdabot> http://hackage.haskell.org/package/regex-applicative
12:38:54 <jared-w> Honestly, I feel like a regex library is never going to take off in haskell unless I can do some weird compileRegex PCRE ("s/<ascii giberish here>/g") and have it work as expected
12:39:19 <jared-w> If I have to put as much effort into writing the regex as I would to write the parser, why not just write the parser?
12:40:47 <cocreature> what we really need is an inline-perl package
12:45:04 <jared-w> ^^^
12:45:40 <cocreature> jared-w: we’re all waiting for you to implement it!
12:45:43 <jared-w> It'll fit right in with lenses; nobody would even notice
12:54:30 <__monty__> I guess people'd still use regexes if they're actually more performant for regular languages.
13:01:43 <geekosaur> people will use regexes because they're what they're familiar with. even when they don't actually understand them and need help building anythng beyond simple ones
13:02:29 <Cale> jared-w: The main reason I would pick a regex library over some other sort of parser is if I needed the performance that could be obtained by compiling to a state machine and my language happened to be regular.
13:02:51 <Cale> I'd still prefer to write the parser in a syntax similar to parser combinators in that case though :)
13:03:46 <Cale> The weird stringy regex syntax sucks for readability. I suppose it'd be nice to have support for in case people need to provide regex-based features to users.
13:04:48 <tdammers> maerwald: nobody has written a world class editor in lisp either; that point goes to C.
13:05:28 <__monty__> So the regex library would have to depend on another parser library? Given how common regex languages aren't regular ; )
13:05:46 <__monty__> tdammers: Oh, snap!
13:07:41 <feuerbach> __monty__: they already do. E.g. regex-tdfa depends on parsec
13:08:38 <feuerbach> which is one of the reasons I try to avoid it
13:08:50 <__monty__> feuerbach: Ah, good to know. Nothing wrong with it really but it does kinda look like cheating, i.e. you're just translating a regex to a parser combinator.
13:09:02 <jared-w> Cale: that's a fair point. I do tend to use regexes a lot if I'm writing shell stuff or other one off quick things
13:09:10 <__monty__> Not saying that's what regex-tdfa does, just what it can look like.
13:10:11 <jared-w> Which, haskell tends to kinda have a weak spot in the area of "just whip up and get it working and then never need to edit the code again"
13:10:28 <tdammers> it's not cheating - it's arguably overkill, but then again, a regex implementation written in parrsec tends to be more readable than your average C implementation
13:12:08 <__monty__> tdammers: I'd consider it cheating because regex -> parsec can't be as performant as regex -> state machine, can it?
13:12:29 <feuerbach> translating a regex to a parsec parser is in general far from trivial
13:12:37 <feuerbach> just from the semantic POV, disregarding performance
13:13:21 <feuerbach> consider the regex .*a
13:13:37 <feuerbach> you might naively write many anyChar >> char 'a', but that won't work
13:15:19 <tdammers> yeah, because of the greedy default
13:16:08 <tdammers> matching /.*a/ on "blaaaaaa" has to match on the entire string, not just "bla"
13:21:10 <infinisil> match :: Text -> Str -> Maybe MatchedUrl      match url str = return Nothing
13:21:18 <infinisil> "Couldn't match type ‘Maybe a0’ with ‘MatchedUrl’"
13:21:23 <infinisil> Why ^^ ??
13:21:56 <infinisil> Oh, I'm stupid, nevermind
13:22:13 <infinisil> s/return Nothing/Nothing
13:25:35 <dminuoso> 22:04        tdammers | maerwald: nobody has written a world class editor in lisp either; that point goes to C.  <- isn't most non-core code of emacs written in Emacs Lisp?
13:25:44 <infinisil> I'm gonna use a parser for this after all, seems simpler
13:26:19 <__monty__> dminuoso: I think the dig was vim rulez, emacs droolz ; )
13:26:29 <DigitalKiwi> dminuoso emacs isn't word class *hides*
13:26:38 <DigitalKiwi> world
13:27:09 <dminuoso> Oh boy. I bit that bait, didn't I.
13:27:29 <feuerbach> infinisil: try https://hackage.haskell.org/package/regex-applicative ?
13:27:58 <infinisil> I already have megaparsec in my project
13:28:17 <infinisil> And I already know more or less how to use it
13:28:20 <dganti> is there a good reference to understand the fix point operator (something simpler)?
13:28:23 <feuerbach> fair enough!
13:28:50 <c_wraith> dganti: for the most part, it's really not necessary.
13:29:14 <dminuoso> dganti: the fix point is just a simple utility to do recursion
13:29:20 <dminuoso> *fix combinator
13:29:36 <c_wraith> dganti: if you're interested in how it works, look at explanations of the Y combinator.  That's not what it is, but it's equivalent in power.
13:29:37 <dganti> than whats on wikipedia or am I on my own here: just work through the notes. c_wraith : i realize that. i am in a project where i need to deal with types and lambda engines and in scala..so I kinda need to underestand this stuff its so mind numbing.
13:29:38 <dminuoso> dganti: Can you write a simple naive recursive fib implementation?
13:30:24 <dganti> dminuoso yeah. i think so. is that what I should use as an example to implement with fix
13:30:24 <dganti> ?
13:30:49 <maerwald> dminuoso: yes https://github.com/emacs-mirror/emacs
13:31:38 <dminuoso> dganti: Or well, rather factorial I guess. Simpler.
13:32:08 <dminuoso> dganti: You can think of `fix` as giving you "anonymous recursion"
13:32:27 <dminuoso> You dont need to create a binding to do recursion with.
13:32:42 <dganti> dminuoso, i see. thanks so i guess i m on my own :). Thank you. Let me get back to the fact example and see if i understand this stuff.
13:33:37 <ammar2> dganti: I think what really helped it clear it up for me was this explanation by example http://kestas.kuliukas.com/YCombinatorExplained/
13:33:42 <ammar2> you can try that if you get lost
13:34:04 <ammar2> its also built on factorial
13:34:04 <dganti> thank you all.I m going to follow all the links.
13:34:12 <tdammers> dminuoso: yes. that's the joke.
13:34:20 <dminuoso> tdammers: =|
13:42:05 <dganti> i found this one : https://www.cs.cornell.edu/courses/cs3110/2013sp/supplemental/lectures/lec29-fixpoints/lec29.html (but i think this is a heavy topic..i need a couple of hours at least to get this)
13:45:04 <infinisil> Damnit, maybe I can't do it with a parser after all
13:46:01 <infinisil> I now wrote a function foo :: Maybe Text -> Parser (Maybe Text)
13:46:18 <infinisil> Input Nothing means .* in regex terms, input Just means that exact text
13:47:21 <infinisil> Output should be Nothing for when Just text matches, output should be Just result for when the argument is Nothing (the text that matches)
13:48:12 <infinisil> Now I create a list [Just "foo", Nothing], map this over foo to get a list of parsers which should succeed in order
13:48:34 <infinisil> sequence this to get a single parser for these in sequence
13:48:44 <infinisil> But then it doesn't work:
13:49:23 <geekosaur> you can do it, but you can't do it by "mechanically" translating a regex. you really want to rethink how you're matching in terms of a recursive descent parser.
13:49:27 <infinisil> runParser (mapM foo [Just "hi", Nothing]) "" "hi there"  ->  Right [Nothing, Just "hello"]
13:49:50 <infinisil> Hmm.. alright but how do I do that? With try?
13:49:58 <infinisil> To get backtracking?
13:51:21 <geekosaur> yes, unless you can come up with a way to do it in terms of "tokens" (which might be e.g. words, if that's how your input reliably breaks down)
13:51:45 <infinisil> Not the case here
13:52:02 <jared-w> It's really all about the art of figuring out how to take some potentially gibberish bit of input and break it apart into its internal structure
13:52:10 <geekosaur> yes, that
13:52:25 <[exa]> are we parsing a regex to a parser?
13:52:58 <infinisil> Alright so I guess it's just mapM (try . foo) instead
13:53:15 <infinisil> (Will try when I'm back at the machine)
13:54:03 <jared-w> [exa]: someone mentioned how one of the regex libraries relied on parsec to do some of the heavy lifting and how it was cheating
13:54:13 <[exa]> I like how even regular languages can get super complicated :]
13:54:34 <jared-w> Regular languages are pretty simple. what people pretend are regular languages... Now that's hairy :p
13:55:24 <infinisil> Doesn't seem to work either
13:55:40 <infinisil> Oh wait it does
13:55:46 <[exa]> regex is complicated in a sense that you can produce a regex that either 1] takes exponential time to match 2] makes an exponential-sized DFA to match 3] optimization that would remove the culprit is in NP
13:55:57 <[exa]> even on regular languages
13:56:24 <[exa]> quite educative. :]
13:56:30 <infinisil> Nah it doesn't work
13:56:30 <jared-w> What's the exponential match time pathological example, again?
13:56:47 <jared-w> It's on the tip of my tongue but the only thing that comes to mind is the pumping lemma lol
13:56:48 <[exa]> matching end of strings
13:57:08 <jared-w> ahh right
13:57:22 <phadej> it's not exponential. Trivial implementation is, we can do better
13:57:47 <[exa]> phadej: thats the 3] case
13:58:09 <[exa]> but I don't have the ugly examples handy, sorry :]
13:58:13 <__monty__> jared-w: I said it could look like cheating, implementing a parser in a strictly more powerful formalism.
13:58:18 <jared-w> And you can't reason and say "well it's only a tiny bit and well behaved NP, so it's fine..."; once you go NP, you can't go back :p
13:58:34 <jared-w> __monty__: ah gotcha, sorry for misremembering :)
13:58:59 <__monty__> I probably just haven't quite gotten my point across.
13:59:14 <phadej> Earley mathces in O(n^3)
14:02:27 <feuerbach> [exa]: NFA is linear in the input text, no NP optimizations needed
14:02:27 <[exa]> phadej: sounds like I should refresh my knowledge on where I got the NP from
14:03:05 <phadej> equivelence of regexps is exponential
14:03:35 <__monty__> feuerbach: Isn't evaluation of NFA's inefficient, suspect it's exponential?
14:03:55 <[exa]> yeah, because redictons only work on DFAs...
14:04:23 <[exa]> *reductions
14:04:38 <[exa]> __monty__: well if you take automaton size as constant... :]
14:05:51 <feuerbach> __monty__: why is it exponential?
14:06:32 <feuerbach> you have a fixed number of states, and at each step (character) you update them from one subset to another. That's O(1)
14:06:40 <infinisil> ,paste infinisil
14:06:53 <[exa]> feuerbach: you either need to guess all the nondeterminism correctly to get it right
14:06:55 <infinisil> ah it's lpaste
14:07:07 <crestfallen> hi is the function passed to foldr / foldl always a binary operator, including Bool values? I don't understand how a lambda as the operator takes arguments in differing orders in foldr and foldl, i.e. ... :
14:07:08 <infinisil> Alright I give up on lpaste
14:07:14 <infinisil> "Not found" https://lpaste.net/new/haskell
14:07:16 <crestfallen> https://ptpb.pw/ZdKi   ^
14:07:17 <[exa]> feuerbach: in a much common case, you need to backtrack many times
14:07:23 <feuerbach> infinisil: I'm not following your issue, but if you need full backtracking with parser combinators, see the link I pasted above (regex-applicative)
14:07:47 <[exa]> wow that's nice
14:07:51 <infinisil> feuerbach: But it should be possible with megaparsec too, right?
14:08:06 <phadej> nope
14:08:13 <infinisil> Huuuh
14:08:15 <phadej> it won't work on "many (many anyChar)"
14:08:40 <crestfallen> ...since the seed value is in the same place, the first parameter after the operator
14:08:40 <feuerbach> [exa]: no backtracking is needed if you evaluate them all simultaneously
14:08:46 <infinisil> I was just about to gist my attempt: https://gist.github.com/Infinisil/b9ad963f485d13660298a05c5e300182
14:09:09 <crestfallen> and the list comes last in both functions
14:09:16 <feuerbach> [exa], __monty__: see https://swtch.com/~rsc/regexp/regexp1.html
14:10:03 <[exa]> yeah that's right
14:10:16 <infinisil> phadej: feuerbach: Does some modification on my gist not work to get it?
14:11:10 <[exa]> feuerbach: I never quite realized that it's just O(#states*len(input)), thanks for reminding. :]
14:11:52 <crestfallen> the only difference I see is that foldr starts at the end of the list, but why would that affect the position of seed there? (\seed -> \_ -> seed + 1)     versus     (\_ seed -> seed + 1)
14:12:15 <infinisil> Alright I'll just use regex-applicative then i guess
14:13:54 <crestfallen> https://ptpb.pw/ZdKi   ^
14:16:09 <monochrom> foldr does not start at the end of the list.
14:16:59 <__monty__> Kind of the opposite really, foldl recurses to the end before returning.
14:17:41 <dyl> It starts at the coend, clearly.
14:17:42 <monochrom> And where it starts has no relevance to the parameter order of the binary operator you are required to give it, apart from maybe convenient convention.
14:17:48 <dyl> Or costarts at the end rather.
14:18:13 <crestfallen> costarts?
14:18:22 <geekosaur> that was a joke
14:18:52 <hodapp> 9_9
14:19:15 <__monty__> monochrom: It's conceptually nicer too imo.
14:19:45 <crestfallen> but whatever is passed in from the list, it's a single value, so the seed and the list are in the same parameter order, right?
14:20:43 <crestfallen> once again, I'm missing a fundamental idea I guess
14:20:50 <dyl> If costars support the star of a movie, then it follows that stars cosupport costars.
14:21:02 <dyl> “Best actor” should really be “best cosupporting role”
14:21:11 <phadej> :D
14:22:19 <crestfallen> in an i dyl lic world
14:22:39 <__monty__> crestfallen: foldr basically passes newElement accumulator, while foldl passes accumulator newElement, so you fold into the right/left-side respectively.
14:23:08 <__monty__> dyl: What would coworst supporting role be equivalent to?
14:23:34 <dyl> Tommy Wiseau
14:23:54 <dyl> Or the category of Wiseaus to be precise but it’s a monoid with only one object.
14:24:13 <DigitalKiwi> i did not mutate i did not oh hi mark
14:24:20 <EvanR> crestfallen: all algorithms must start at the beginning of a list, if only for the purpose of shuffling through it to obtain the last element
14:24:31 <rotaerk> I love ghcid, btw; trying it now
14:24:33 <EvanR> which foldl does
14:24:54 <fooza> hello! i'm looking for some help extracting a symbol value via a typeclass .. https://lpaste.net/8049900071514275840
14:25:10 <fooza> it seems that typeclasses want .. types not symbols
14:26:37 <geekosaur> "expected a type" means it's looking for kind * (or Type), not kind Symbol. at value level, you can only talk about things of kind * directly
14:27:20 <crestfallen> > scanl (\seed -> \_ -> seed + 1) 0 [2,3,4]
14:27:22 <lambdabot>  [0,1,2,3]
14:27:23 <geekosaur> "*" is not a wildcard
14:27:58 <rotaerk> the codiscussions in here make me want to learn category theory
14:28:04 <crestfallen> r (\_ seed -> seed + 1) 0 [2,3,4]
14:28:18 <crestfallen> > foldr (\_ seed -> seed + 1) 0 [2,3,4]
14:28:20 <lambdabot>  3
14:28:27 <crestfallen> sorry
14:28:42 <crestfallen> > scanr (\_ seed -> seed + 1) 0 [2,3,4]
14:28:44 <lambdabot>  [3,2,1,0]
14:29:58 <fooza> geekosaur: so i can't make an instance for (a :: Symbol) only (a :: *) ?
14:31:11 <fooza> this seems to work https://lpaste.net/9110791989019803648 (because i'm packing the symbol up in a proxy first..)
14:31:42 <fooza> is that the only way to accomplish this?
14:31:57 <fooza> (by wrapping the symbol in a type)
14:32:19 <geekosaur> I'm not sure. You can remove some restrictions, but value level still depends on kind *
14:33:14 <fooza> remove some restrictions?
14:34:30 <monochrom> Clearly, the kind of Proxy s is *, no matter what kind s is.  So it kind-checks.  But what does it accomplish anyway?
14:35:30 <monochrom> At this point it is not intelligent design, it is evolution looking for a piece of code that survives static checks for no purpose.
14:36:28 <crestfallen> do when 0 ends up in the return value [3,2,1,0] using foldr , that's recursive, so it's the first element added to the list?  __monty__ EvanR
14:36:34 <monochrom> Just several hours ago we saw a similar phenomenon at the more elementary level of using megaparsec to write a parser.
14:36:36 <crestfallen> *so when
14:36:37 <nshepperd> fooza: the problem isn't the typeclass, it's your foo function
14:36:59 <nshepperd> 'foo :: a -> String' needs an input value of type a
14:37:30 <nshepperd> then clearly a can't be a Symbol such as "hello", because there aren't any values of type "hello"
14:38:21 <monochrom> The victim wrote "sepby (many foo) (return ',')".  It didn't do what the victim wanted.  When asked why the "return ','" there, the answer was "because it type-checks".  No thought was given on whether it even made sense to use the empty string (which "return ','" accepts) as a delimiter in real grammars.
14:38:49 <drbrule> Any chance anyone is willing to give me less than an hour of 1-on-1 peer programming help now? I am willing to pay. Would do Google Hangout session and pay via Venmo.
14:39:23 <drbrule> I am stuck trying to write some tests and I need hand holding.
14:39:32 <drbrule> Hspec and QuickChecl
14:39:54 <fooza> nshepperd: i mean `undefined :: "hello"` is a value of type "hello"
14:40:17 <monochrom> But undefined's type has the wrong kind.
14:40:26 <fooza> monochrom: i'm trying to do the same trick as https://hackage.haskell.org/package/servant-server-0.14/docs/src/Servant-Server-Internal.html#line-624
14:40:27 <nshepperd> fooza: nope, undefined doesn't fit there
14:40:55 <monochrom> undefined only promises: "I can be any type t you want, but t's kind has to be *"
14:41:02 <nshepperd> :t undefined :: "hello"
14:41:03 <lambdabot> error:
14:41:03 <lambdabot>     • Expected a type, but ‘"hello"’ has kind ‘Symbol’
14:41:04 <lambdabot>     • In an expression type signature: "hello"
14:41:08 <fooza> :info undefined
14:41:22 <fooza> blah blah `a :: TYPE r` ...
14:42:03 <monochrom> OK, but Symbol does not match TYPE r.
14:43:14 <crestfallen> sorry, is this correct then?   do when 0 ends up in the return value [3,2,1,0] using foldr , that's recursive, so it's the first element added to the list?
14:43:22 <crestfallen> *so
14:43:37 <crestfallen> its confusing
14:43:49 <monochrom> OK, but when you write "class Foo a" it is implicitly "class Foo (a :: *)"
14:44:12 <monochrom> So suddenly every other kinds are ineligible for your class.
14:44:22 <dminuoso> crestfallen: https://wiki.haskell.org/wikiupload/5/5a/Left-fold-transformation.png https://wiki.haskell.org/wikiupload/3/3e/Right-fold-transformation.png
14:44:26 <fooza> monochrom: oo.. i didn't know that
14:44:42 <fooza> makes sense i guess because it's a "type class"
14:44:49 <monochrom> Well actually I'm wrong about that.
14:44:59 <fooza> i'm on a rollercoaster
14:45:19 <crestfallen> dminuoso: thanks, this is review but I am missing something while using the lambdas there..
14:45:24 <monochrom> The kind of a is determined by kind inference by looking at a method "a -> String"
14:46:39 <monochrom> If instead you accept to change it to "p a -> String" then you have a lot more room.
14:46:51 <crestfallen> dminuoso: that's cool I can run with that. thanks kindly
14:49:57 <glguy> fooza: I don't know if this was covered, but one of the primary benefits of Proxy is that you don't have to use undefined
14:50:07 <glguy> so rather than: undefined :: Proxy a; Proxy :: Proxy a
14:50:24 <infinisil> :t foldr (liftA2 (:)) (pure [])
14:50:25 <lambdabot> (Applicative f, Foldable t) => t (f a) -> f [a]
14:50:43 <infinisil> This is almost a sequence function for Applicative instead of Monad ^^
14:51:00 <infinisil> Is Monad really needed to implement t (f a) -> f (t a)?
14:51:18 <infinisil> :t sequence
14:51:18 <monochrom> No. Today's sequence uses Applicative instead.
14:51:19 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
14:51:33 <monochrom> Err, the name is sequenceA now.
14:51:51 <monochrom> I guess sequence is unchanged for historical reasons.
14:51:51 <dyl> monochrom: do you even need all of Applicative to get sequenceA?
14:51:55 <Solonarv> :t sequenceA
14:51:57 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
14:52:02 <Solonarv> yes, you do
14:52:02 <__monty__> crestfallen: Granted it's kinda confusion when the scans look flipped but it gets clearer when you try to fold over an infinite list.
14:52:02 <dyl> Or is there some weaker version of applicative that would suffice?
14:52:07 <infinisil> Goddamnit, I just spent 30 minutes implementing sequenceA then
14:52:11 <__monty__> *confusing
14:52:12 <monochrom> I think yes. Base case needs pure, induction step needs ap.
14:52:46 <Solonarv> for lists, sequenceA is defines as follows: sequenceA [] = pure []; sequenceA (x : xs) = (:) <$> x <*> xs
14:53:01 <infinisil> And then hlint says that `sequencA . map foo` -> `traverse foo`
14:53:10 <infinisil> A single goddamn function..
14:53:47 <Solonarv> note: if you see mapM somewhere, it's the same thing as traverse
14:53:55 <Solonarv> :t mapM
14:53:57 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
14:54:00 <Solonarv> :t traverse
14:54:02 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
14:54:06 <infinisil> Fancy
14:54:29 <Solonarv> more like "historical accident"
14:55:35 <fooza> monochrom: so could i define the function as `(a :: k) -> String` ?
14:55:49 <monochrom> -> won't allow it.
14:55:54 <fooza> ah
14:56:05 <Solonarv> Monad and related functions have been around longer than Applicative, and class Applicative m => Monad m didn't always have the Applicative constraint
14:56:09 <fooza> glguy: why is it better to use `Proxy :: _` over `undefined :: _` ? Because `undefined` is bottom?
14:56:28 <glguy> You should avoid using undefined whenever possible
14:56:47 <glguy> It's too easy to force that value later and introduce a runtime failure
14:57:38 <monochrom> You look at Storable and you see it should have used a proxy, even though the only kind involved is *
14:58:43 <monochrom> If you start saying "my method has type Storable a => a -> Int" people just assume that a different parameter gets a different Int, unless they look at the doc.
14:59:17 <dminuoso> Solonarv: That doesn't sound right regarding the implementation of sequenceA.
15:00:42 <monochrom> But if you say "Storable a => Proxy a -> Int" or even "Storable a => p a -> Int" then people know the point is the type not the value, since there is no choice anyway.
15:01:34 <monochrom> You choose your types to send the right message, not the wrong message.
15:02:13 <Solonarv> well, instance Traversable [] actually just implements traverse, not sequenceA
15:02:13 <dminuoso> :t foldr (pure []) (liftA2 (:))
15:02:14 <lambdabot> error:
15:02:15 <lambdabot>     • Couldn't match type ‘[a0]’
15:02:15 <lambdabot>                      with ‘(f a1 -> f [a1] -> f [a1]) -> f a1 -> f [a1] -> f [a1]’
15:02:26 <dminuoso> :t foldr (liftA2 (:)) (pure [])
15:02:27 <lambdabot> (Applicative f, Foldable t) => t (f a) -> f [a]
15:02:37 <dminuoso> Solonarv: No your implementation would still be wrong.
15:02:51 <dminuoso> Solonarv: sequence has to collect *all* effects
15:03:03 <dminuoso> Not just the first.
15:03:35 <Solonarv> oh my implementation actually doesn't even typecheck, I made a typo
15:03:54 <Solonarv> sequenceA [] = pure []; sequenceA (x : xs) = (:) <$> x <*> sequenceA xs
15:04:02 <Solonarv> forgot the recursive call to sequenceA
15:04:19 <dminuoso> Solonarv: Yeah and thats just foldr (liftA2 (:)) (pure []
15:04:22 <dminuoso> :)
15:04:31 <Solonarv> indeed
15:04:48 <Solonarv> anyway, the point I'm making is that traverse / sequenceA need exactly Applicative
15:04:54 <Solonarv> not Monad, not Functor
15:07:16 <fooza> monochrom: glguy: thanks for explaining- it's about communicating the api better through the types
15:13:59 * hackage flux-monoid 0.1.0.0 - A monoid for tracking changes  http://hackage.haskell.org/package/flux-monoid-0.1.0.0 (ChrisPenner)
15:15:59 <dyl> Still can’t believe my PhD program is starting so soon. If anyone has any advice or suggestions, I would be most appreciative.
15:16:22 <tAyyy> Howdy, just looking for some advice.
15:16:36 <dyl> Don’t ask to ask, just ask :)!
15:17:35 <glguy> An even more direct way to communicate that the argument is unused is not to involve functions directly at all: newtype Tagged (s :: k) b = Tagged {unTagged :: b}
15:17:59 <tAyyy> I have a data type I'm trying to write an Eq instance for, its defined as OutRot = Or Pack Integer, and Pack is defined as Pack = p1 | p2 | p3 etc etc
15:18:01 <glguy> so instead of the old fashioned: sizeOf :: a -> Int, you have: sizeOf :: Tagged a Int
15:18:28 <tAyyy> I have show defined for all of them, but Eq I can't figure out a better way of doing than just comparing the shows (I want to ignore the integer in the comparison)
15:18:37 <monochrom> Ah, that's the best.
15:19:01 * monochrom begins to abuse it.
15:19:11 <monochrom> maxBound :: Bounded a => Tagged a a  >:)
15:19:18 <glguy> tAyyy: You don't need to define Eq or Show, you can derive both
15:20:23 <tAyyy> My thought was that since my comparison isn't a straight is the same as, because I'm ignoring part of the type, I had to write my own?
15:20:33 <glguy> Using custom implementations of either can lead to breakage and surprises later
15:20:53 <monochrom> You can at least use deriving Eq on Pack, no?
15:21:02 <tAyyy> Oh damn that'll be it
15:21:04 <__monty__> Why do the scanXs behave flipped wrt the foldXs?
15:21:05 <glguy> but for writing your own equality function, what about: equalVal (Or _ x) (Or _ y) = x == y ?
15:21:07 <tAyyy> Haha thanks, feel dumb now
15:21:21 <tAyyy> Yeah thats what I had for OutRot, but I completely forgot to add one to pack -_-
15:21:24 <tAyyy> Thanks heaps
15:22:00 <glguy> __monty__: Maybe you don't understand what one of the two is doing?
15:22:34 <tAyyy> Nah I got it now, just a bit of a brainfart
15:22:58 <__monty__> glguy: Entirely plausible.
15:23:44 <__monty__> glguy: Wiki led me to catamorphisms, which while interesting aren't really teaching me anything about why the scans seem flipped : )
15:23:58 <drbrule> Having trouble figuring out how to filter an array inside a state monad.
15:23:59 <drbrule> https://privatebin.net/?38b86ea5574d0797#PJSGkm2WhAA5T6mR2SQWJi5Q+veOwAjjmEebpqTy2CY=
15:24:10 <drbrule> password: ticket
15:24:27 <glguy> The password is ****** ?
15:25:10 <__monty__> It's "ticket", is your client hiding it? How courteous.
15:25:15 <jle`> hint: copy and paste the stars
15:25:32 <monochrom> Where is the array?
15:25:38 <DigitalKiwi> glguy http://www.reactiongifs.com/r/sick-reference.gif
15:25:41 <glguy> drbrule: Change the type to :  [TicketInfo] -> [TicketInfo]
15:25:54 <drbrule> I don't think I can
15:25:58 <glguy> and then don't pass in an App [TicketInfo] here, but wherever you had that type somewhere use
15:26:03 <drbrule> Because App is required for getTicketComments
15:26:12 <glguy> Then you can use do-notation to get access to the list
15:26:36 <monochrom> What is the type of getTicketComments?
15:26:54 <drbrule> App TicketInfo -> [Comment]
15:27:17 <monochrom> Seriously?  Not the other way round?  TicketInfo -> App [Comments]?
15:27:23 <drbrule> nope.
15:27:33 <monochrom> Is this App a comonad?
15:27:40 <drbrule> uhhhhh.....
15:27:55 <monochrom> Such that it's always "App X -> Y" never "X -> App Y"?
15:28:06 <glguy> drbrule: You haven't given us enough information to help you well. We don't know where anything of the things you've used are defined or what their types are
15:28:20 <drbrule> Not sure if it is a comonad or not
15:28:33 <drbrule> Not sure how to verify
15:28:56 <v0d1ch_> is there a way to have clickable links in irssi ? probably there is a script...
15:29:22 <drbrule> v0d1ch: I use terminator, which does hyperlinking automatically.
15:29:26 <glguy> v0d1ch_: There's probably a good channel to ask that in
15:29:32 <DigitalKiwi> I just want to point out the futility of password protecting something and then sharing it in a publicly logged channel with 1700 users
15:29:46 <drbrule> it's really not futile
15:30:10 <drbrule> It has a 6 day timer on it, so yes some bot could scrape it but it's better than nothing.
15:30:30 <monochrom> DigitalKiwi: No, instead I think it's the futility of using a pastebin that insists on passwords when the user really just want to make it public.
15:30:36 <v0d1ch_> glguy: Yeah probably, but I spend all my time here so ¯\_(ツ)_/¯ :)
15:30:47 <glguy> drbrule: Yeah, you don't want your enemies getting these sweet type errors and monetizing them before you can
15:30:55 <DigitalKiwi> chortle
15:31:11 <drbrule> I mean, I literally asked which pastebin people use in this chatroom a few days ago and was told privatebin
15:31:14 * glguy is already turning the error into the bitcoins
15:31:14 <drbrule> so yeah
15:31:44 <DigitalKiwi> lpaste.net is in the topic :)
15:31:52 <glguy> Some people and clinging to lpaste.net and then there's gist.github.com
15:31:57 <glguy> people are*
15:32:00 <drbrule> ah nice Haskell highlighting
15:32:44 <drbrule> So what info do you need?
15:33:23 <glguy> Enough information to reproduce the problem is best
15:52:44 <__monty__> Does the r in foldr come from associating the function to the right?
15:53:54 <glguy> yup
15:56:18 <monochrom> In the beginning people simplistically looked at "a - (b - (c - (d - z)))" and saw right-association and defined foldr for that pattern.
15:57:00 * hackage extensible-effects-concurrent 0.2.0.3 - Message passing concurrency as extensible-effect  http://hackage.haskell.org/package/extensible-effects-concurrent-0.2.0.3 (SvenHeyll)
15:57:02 <monochrom> But since then we have discovered deeper properties of foldr such that it is no longer about right-association.
15:57:55 <DigitalKiwi> isn't it called something else in scheme
15:58:47 <__monty__> monochrom: Could you give me another crumb so I can see the path?
15:58:48 <monochrom> Scheme says fold-right, Racket says foldr, but you can import a Scheme compatibility library to regain fold-right.
15:59:02 <DigitalKiwi> I might be thinking of a different language or function hm
15:59:15 <__monty__> DigitalKiwi: reduce?
15:59:18 <monochrom> foldr is also the catamorphism of cons lists.
15:59:37 <monochrom> reduce is very likely a foldl instead.
15:59:38 <DigitalKiwi> reduce rings a bell
16:00:22 <dmwit> Python calls foldl' reduce.
16:00:22 <DigitalKiwi> (define fold foldl)
16:00:22 <DigitalKiwi> (define reduce foldr)
16:01:42 <DigitalKiwi> I don't know if that's right but that's where I remembered that from then heh
16:15:19 <dminuoso> If I have some, [(1,'a'), (2, 'b'), (3, 'c')], how can I recover "abc" using lens?
16:15:22 <__monty__> Hmm, still don't have the intuition for scanr/l, where do the names come from there?
16:16:02 <__monty__> dminuoso: Does it have to be lens? map snd seems simple enough.
16:16:12 <glguy> > scanlr f z [a,b,c]
16:16:14 <lambdabot>  error:
16:16:14 <lambdabot>      • Variable not in scope: scanlr :: t0 -> Expr -> [Expr] -> t
16:16:14 <lambdabot>      • Perhaps you meant one of these:
16:16:22 <glguy> > scanr f z [a,b,c]
16:16:24 <lambdabot>  [f a (f b (f c z)),f b (f c z),f c z,z]
16:16:25 <dminuoso> __monty__: Yes.
16:16:33 <glguy> > foldr f z [a,b,c]
16:16:34 <lambdabot>  f a (f b (f c z))
16:16:45 <glguy> see how it has the same right-associated uses of f ?
16:17:28 <__monty__> Yes but I don't see why it has the order it has.
16:18:22 <glguy> what other order could it have?
16:19:13 <dyl> concat $ [(1,'a'), (2, 'b'), (3, 'c')] & each *~ snd
16:19:17 <__monty__> [z, f c z, f b (f c z)...]
16:19:18 <dyl> Or something like that I think?
16:19:30 <dyl> I don’t see the benefit to using lenses except polymorphism over tuples, lists, etc
16:19:46 <dyl> And I don’t think lenses will handle polymorphism over some form of “concatenation”
16:19:47 <glguy> __monty__: Keep in mind that foldr doesn't "start from the end"
16:19:51 <dyl> Or consing
16:20:14 <dyl> concat $ map snd seems simpler.
16:20:23 <dyl> :t concat
16:20:24 <lambdabot> Foldable t => t [a] -> [a]
16:20:27 <dyl> wait not that one
16:20:32 <dyl> Anyhow.
16:20:47 <dminuoso> dyl: The point is to understand how this would be done with lens. So.. :)
16:22:08 <__monty__> dyl: Don't need the concat do you? Since [Char] ~ String.
16:22:26 <dyl> You’re right, I was imagining double quotes for some reason.
16:22:36 <geekosaur> was just wondering about that
16:22:46 <dyl> But to do these things with Lens you need functor anyways
16:22:55 <dyl> So I would just use the functor instance you have.
16:23:10 <dyl> You could generalize the appending to monoid too.
16:25:14 <Gurkenglas> > [(1,'a'), (2, 'b'), (3, 'c')] ^.. each . _2 -- dminuoso
16:25:16 <lambdabot>  "abc"
16:25:51 <__monty__> glguy: I know it doesn't but it still feels weird that foldr can work on an infinite list but scanr can't and vice versa for foldl/scanl.
16:26:23 <Gurkenglas> I would guess he might have asked because he wanted that knowledge for some other application that can't be addressed just with fmap
16:26:23 <glguy> > scanr const 0 (repeat 1)
16:26:25 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
16:26:36 <glguy> __monty__: scanr works on infinite lists as does foldr
16:26:55 <glguy> with appropriately lazy functions
16:27:03 <dminuoso> :t each
16:27:04 <lambdabot> (Applicative f, Each s t a b) => (a -> f b) -> s -> f t
16:27:28 <Gurkenglas> > [(1,'a'), (2, 'b'), (3, 'c')] ^.. traverse . _2
16:27:30 <lambdabot>  "abc"
16:27:32 <__monty__> > take 5 $ scanl (flip (:)) [] [1..]
16:27:35 <lambdabot>  [[],[1],[2,1],[3,2,1],[4,3,2,1]]
16:27:37 <Gurkenglas> > [(1,'a'), (2, 'b'), (3, 'c')] ^.. folded . _2
16:27:39 <lambdabot>  "abc"
16:27:44 <__monty__> > take 5 $ scanr (:) [] [1..]
16:27:46 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
16:27:50 <glguy> > scanr (\x xs -> take 4 (x+1:xs)) [] [1..]
16:27:53 <lambdabot>  [[2,3,4,5],[3,4,5,6],[4,5,6,7],[5,6,7,8],[6,7,8,9],[7,8,9,10],[8,9,10,11],[9...
16:28:21 <dminuoso> Gurkenglas: I take it that `each = traverse` generally?
16:28:46 <Gurkenglas> > (1, 2) ^.. each
16:28:48 <lambdabot>  [1,2]
16:28:52 <Gurkenglas> > (1, 2) ^.. traverse
16:28:54 <lambdabot>  [2]
16:29:20 <__monty__> > scanl (\xs x -> take 4 (x+1:xs)) [] [1..]
16:29:22 <lambdabot>  [[],[2],[3,2],[4,3,2],[5,4,3,2],[6,5,4,3],[7,6,5,4],[8,7,6,5],[9,8,7,6],[10,...
16:29:50 <Gurkenglas> > S.fromList [1,2,3] ^.. folded
16:29:51 <lambdabot>  [1,2,3]
16:29:58 <Gurkenglas> > S.fromList [1,2,3] ^.. traverse -- error intended
16:30:00 <lambdabot>  error:
16:30:00 <lambdabot>      • Could not deduce (Traversable S.Set)
16:30:00 <lambdabot>          arising from a use of ‘traverse’
16:30:42 <__monty__> glguy: Running your scanr in ghci looks like an infinite computation.
16:30:56 <phadej> > S.fromList [1,2,3] ^.. each
16:30:58 <lambdabot>  error:
16:30:58 <lambdabot>      • Could not deduce (Each (S.Set a0) (S.Set a0) b b)
16:30:58 <lambdabot>        from the context: (Each (S.Set a) (S.Set a) b b, Num a, Ord a)
16:30:59 <glguy> __monty__: yeah, you get an infinite list of finite lists
16:31:17 <phadej> that could work...
16:31:27 <phadej> (almost)
16:31:28 <Gurkenglas> phadej, set hasn't each for the same reason as traverse
16:31:41 <__monty__> glguy: Not a usable infinite list though. It's bottom because you won't ever get to use the list, no?
16:31:45 <phadej> Gurkenglas: you can write Each instance, it's hard to make it lawful
16:31:49 <glguy> __monty__: nope
16:31:57 <glguy> and you can see that from how lambdabot was able to print the beginning of the list
16:31:59 <Gurkenglas> phadej, same for traverse
16:32:15 <phadej> Gurkenglas: you cannot, you don't have Ord b in Traversable available for you
16:32:22 <dminuoso> Gurkenglas: Okay this all doesnt make much sense to me, so magical. :-)
16:32:29 <dminuoso> But thanks, Ill try to understand it.
16:34:02 <Gurkenglas> phadej, http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Set.html#v:mapMonotonic exists, surely you can thread an Applicative action through its source
16:34:26 <__monty__> glguy: Thank you, you've succeeded in confusing me further : s Still lost on why scanr/l seem so backwards.
16:34:37 <phadej> Gurkenglas: true
16:34:44 <glguy> __monty__: Maybe you're thinking of foldr as "starting from the end of the list"?
16:34:55 <Gurkenglas> phadej, ah your point is that Each lets us specify Ord but Traversable doesn't
16:36:34 <Gurkenglas> Then why wouldn't the Each instance be lawful?
16:36:40 <__monty__> glguy: No, I'm not. I'm very much thinking of foldr as "Let me just lazily replace this cons with this infix function, nothing to see here, move along."
16:37:16 <glguy> OK, then I guess you'll have to stare at it a little while, or try writing down your explanation for why scanr would behave any differently and we can see where that goes wrong
16:38:53 <__monty__> glguy: My problem is just why is scanr not called scanl and vice versa.
16:39:06 <glguy> Because foldr and scanr associate the function the same way
16:39:08 <Gurkenglas> __monty__, but scanr f is just foldr (\x qs@(q:_) -> f x q : qs)
16:39:11 <glguy> and same for scanl and foldl
16:42:35 <Gurkenglas> (with a little wrappity at the nil, just looked at http://hackage.haskell.org/package/base-4.11.1.0/docs/src/GHC.List.html#scanr , maybe it'll be more instructive for you to try putting scanr in terms of foldr)
16:42:54 <glguy> scanr has all the intermediate values that foldr might produce. scanl has all the intermediate values that foldl could produce
16:44:23 <Gurkenglas> :t [scanr ?f, foldr (\x qs@(q:_) -> ?f x q : qs) . (:[])]
16:44:25 <lambdabot> (?f::a -> b -> b) => [b -> [a] -> [b]]
16:53:07 <__monty__> So difficult to wrap my head around. Especially scanr (||) False (True:repeat False). You can take 1 but not take 2 or more. Which is really weird because it's as if you can get the result but no intermediate results o.O
16:59:09 <glguy> > take 10 $ scanr (||) False (cycle [True, False])
16:59:12 <lambdabot>  [True,True,True,True,True,True,True,True,True,True]
17:00:38 <__monty__> glguy: Yeah but the cycle will prevent the infinite loop on intermediate results.
17:01:12 <glguy> It's no surprise that folding an infinite list of Falses with || won't terminate
17:01:22 <Solonarv> > scanr (:) [] (True : repeat False)
17:01:24 <lambdabot>  [[True,False,False,False,False,False,False,False,False,False,False,False,Fal...
17:01:26 <glguy> it keeps evaluating hoping to find a True or []
17:01:46 <Solonarv> > take 5 <$> scanr (:) [] (True : repeat False)
17:01:48 <lambdabot>  [[True,False,False,False,False],[False,False,False,False,False],[False,False...
17:01:59 <glguy> so only the first element in __monty__'s example with || finishes evaluating to True
17:02:08 <glguy> all the remaining elements in the list will never see a True
17:04:24 <__monty__> I understand what happens, it's just weird that foldr can cope with this, foldl can't and scanr can't but scanl can.
17:06:11 <glguy> foldr and scanr both can and do cope with that, as we saw
17:06:16 <glguy> so you're still missing something
17:06:50 <__monty__> scanr doesn't imo, only in the first element which is exactly the result of foldr.
17:09:25 <glguy> well, only the first element is the one that had access to the first element of the input list
17:09:35 <glguy> the second element behaves as though the first element is missing
17:11:24 <glguy> Just like how while 'foldr (||) False (True : repeat False)' can finish evaluating but 'foldr (||) False (repeat False)' can't
17:15:11 <__monty__> Yeah, that's entirely obvious to me. It just "feels" wrong.
17:16:04 <glguy> Well, then it seems like you have all the pieces you need to understand the connection, you just need to spend some time stepping through things or letting your brain crunch on it in your dreams :)
17:17:38 <__monty__> Yeah, it's just not clicking rn. Will sleep on it. Thanks for the guidance : )
17:20:58 <hastuur_> is haskell the best?
17:21:20 <rom1504> hastuur_: yes, it can make you coffee
17:21:38 <hastuur_> how hard to learn?
17:21:49 <hastuur_> not compsci major
17:21:51 <rom1504> as hard as building a coffee machine
17:21:52 <hastuur_> <
17:22:00 <hastuur_> hm
17:23:32 <nitrix> In my experience, everything ends up being more complicated than I anticipated.
17:26:19 <nitrix> hastuur_: It makes sense that you want the best instead of the worse, but you forgot to mention best at what.
17:26:42 <Solonarv> I wouldn't say haskell is particularly hard to learn, although you might have to unlearn some things from other languages
17:27:40 <JuanDaugherty> compared to what?
17:28:10 <JuanDaugherty> an american monoglot learning mandarin?
17:28:47 <JuanDaugherty> and don't say brainfuck
17:28:49 <monochrom> Oh, if it comes down to that, two can play this game.
17:29:18 <monochrom> "American monoglot" isn't a particularly informative, predictive classification either.
17:29:45 <JuanDaugherty> trumpista
18:02:11 <nitrix> Assuming a fancy DSL monad, could this give a hint to what I'm up to?   every Second >>= epoch >>= print
18:06:45 <nitrix> epoch :: Source () -> Fancy (Sink UInt)
18:07:17 <nitrix> I'd imagine this is already done, but it's the first time the power of monads really strikes me.
18:07:45 <JuanDaugherty> they compel u
18:08:59 <JuanDaugherty> https://www.youtube.com/watch?v=tDNCkcC47eQ
18:09:39 <nitrix> every :: Interval -> Fancy (Sink ())
18:09:55 <nitrix> every :: Source Interval -> Fancy (Sink ())
18:10:09 <nitrix> I'm seeing two things here. One, I guess I'll need a way to lift things to become constant sources.
18:10:47 <nitrix> And the other... I kind of wish these didn't look like kleili arrows :/
18:12:52 <nitrix> Myup. Now I'm actually curious what choices pipes and FRP made :P
18:14:29 <syniseth> Howdy
18:14:35 <nitrix> Hello!
18:27:17 <Zer000> In elm there is an event loop where you specify an initial model (just some data), a function where you take some messages and based on that modify your model and return commands (comand results come back as messages). You also specify a function that takes your model and returns a list of subscriptions to things like mouse events. I wanted to write a similar loop for my server side network program in haskell, but I don't get it - elm subscriptions don't
18:27:17 <Zer000> give you any handlers! The subscription is executed every loop or whatever, and you keep returning subscriptions - so do they unbind and rebind the events every loop? I don't get how to write this for, say a network socket that I'm listening to.
18:30:43 <JuanDaugherty> why do you "keep" returning subscriptions? isn't one per thing enough?
18:31:32 <Zer000> Just so you can look at your model and add new subscriptions based on your state.
18:35:13 <`Guest00000> application operator is $ because applying something results in dollars?
18:38:52 <monochrom> No, it's an arbitrary choice.
18:40:28 <dmwit> Zer000: That question is probably more on-topic in #elm.
18:41:21 <ammar2> `Guest00000: someone dug up some history in it here https://www.reddit.com/r/haskell/comments/4jk276/why_dollar_sign_was_chosen_for_function/d37dufj
18:41:26 <ammar2> but yeah its pretty arbitrary
18:49:36 <enterprisey> In Megaparsec, does manyTill consume the parser "end"? (i.e. will manyTill (char 'a') (char 'b') eat all of "aab"?)
18:57:52 <lyxia> enterprisey: yes
18:58:00 <enterprisey> thanks
19:03:56 <nitrix> `Guest00000: The result of function application depends on the type of that function. Dollars are irrelevant.
19:04:38 <`Guest00000> dollars are always relevant
19:04:48 <nitrix> `Guest00000: Haskell's use of ($) is as a syntactic construction.
19:04:55 <nitrix> :t ($)
19:04:56 <lambdabot> (a -> b) -> a -> b
19:05:47 <monochrom> Next time maybe we can second-guess-overthink on why lists are written [a,b,c] not [a;b;c;].
19:08:19 <ammar2> probably because Miranda had [a,b,c] https://en.wikipedia.org/wiki/Miranda_(programming_language)
19:09:16 <ammar2> so does ML, right?
19:10:50 <monochrom> I think ML used [a;b;c] a long time ago, actually.
19:11:22 <monochrom> Or maybe HOL did.  (And HOL was implemented in ML, so sometimes I mixed up the two.)
19:11:23 <DigitalKiwi> because everyone hates semi-colons
19:11:42 <mjrosenb> I feel like the number of languages that use semicolons to separate parts of an expresssion as opposed to separating expressions is very small.
19:11:48 <`Guest00000> [a, b and c]
19:12:25 <ammar2> nah, they'd have had an oxford comma
19:12:29 <ammar2> a, b, and c
19:12:39 <`Guest00000> cool
19:12:55 <monochrom> I like oxford comma actually.  Although I didn't know this name.
19:13:18 <`Guest00000> empty list is denoted as [(empty)
19:13:25 <`Guest00000> empty list is denoted as [(empty)], singleton - as [just a]
19:13:59 <`Guest00000> just and and being reserved words
19:14:04 <`Guest00000> and empty
19:14:36 <monochrom> `Guest00000: Why are you so worked up over this?
19:28:41 <DigitalKiwi> dola dolla bill y'all
19:28:55 <nitrix> What does that mean?
19:29:27 <DigitalKiwi> other than I can't type I have no idea
19:29:54 <monochrom> Please refrain from making noise.
19:30:00 <DigitalKiwi> :(
19:36:08 <nitrix> If (=>) wasn't specially supported by the language' syntax, could it be a normal operator at the type level?
19:37:18 <nitrix> (=>) :: Constraint -> (a :: *) -> (a :: *)
19:37:46 <nitrix> With possibly (,) :: Constraint -> Constraint -> Constraint as well?
19:39:58 <monochrom> It seems no in Haskell2010.  But the TypeOperator extension allows it.
19:42:26 <glguy> You couldn't quite give => a type, it works more as syntax than as a type former
19:42:40 <glguy> err, a kind
19:42:49 <glguy> You couldn't quite give => a kind, it works more as syntax than as a type former
19:43:48 <glguy> or maybe it would work out as (=>) :: Constraint -> * -> *, not sure now
19:44:01 <edmundnoble> I believe that's how it would work out, if it was possible.
19:44:21 <edmundnoble> `(c => a) :: *`, `c :: Constraint`, `a :: *`
19:44:45 <edmundnoble> nitrix: There is absolutely `(,) :: Constraint -> Constraint -> Constraint`, assuming it doesn't have special support.
19:44:45 <glguy> It's not quite right, though, because you can't use (_ => _) anywhere you can use a type with kind *
19:45:01 <nitrix> Currently Constraint is a type of kind * ?
19:45:08 <edmundnoble> `Constraint` is a type?
19:45:13 <glguy> Constraint is a kind
19:45:19 <glguy> if you turn on ConstraintKinds
19:45:50 <edmundnoble> You can't use `_ => _` anywhere you can use a type with kind `*`?
19:45:58 <edmundnoble> Does that have to do with predicativity or inference?
19:46:01 <nitrix> edmundnoble: I think so.
19:46:04 <nitrix> :k Constraint
19:46:05 <lambdabot> *
19:46:11 <glguy> edmundnoble: Impredicativity
19:46:21 <edmundnoble> nitrix: That's really odd. `Constraint` is a kind.
19:46:22 <edmundnoble> Oh yes.
19:46:24 <edmundnoble> That makes sense.
19:46:28 <edmundnoble> We must have `TypeInType` enabled.
19:46:41 <edmundnoble> `* :: *` as well.
19:46:46 <Solonarv> :k *
19:46:47 <lambdabot> error: Operator applied to too few arguments: *
19:46:54 <edmundnoble> :k Type
19:46:55 <lambdabot> error:
19:46:55 <lambdabot>     Not in scope: type constructor or class ‘Type’
19:47:00 <edmundnoble> :/
19:47:08 <Solonarv> % :k *
19:47:09 <yahb> Solonarv: * :: *
19:47:56 <nitrix> Okay, so Constraint should be a kind.
19:48:09 <nitrix> Kind that also has kind * due to TypeInType?
19:48:30 <glguy> With TypeInType you stop having "kinds"
19:48:39 <glguy> the type layer just collapses in on itself
19:48:46 <nitrix> Ah yeah.
19:48:59 <edmundnoble> Right.
19:49:02 <edmundnoble> :k (Num Int)
19:49:02 <nitrix> What did I have earlier?
19:49:04 <lambdabot> Constraint
19:49:10 <nitrix> (=>) :: Constraint -> (a :: *) -> (a :: *)
19:49:25 <edmundnoble> That'd just be `(=>) :: Constraint -> * -> *`
19:50:49 <nitrix> Ah? But doesn't that kind signature need to somehow say the input type will be the same as the output type?
19:51:22 <glguy> No, not any more than: Int -> Int   says the input int will be the same as the output
19:52:01 <nitrix> I'm tired and I haven't touched Haskell in many months, sorry for struggle / low quality questions.
19:52:43 <Solonarv> the input type and output type are *not* the same! one is more specific than the other
19:53:58 <nitrix> So, with a lot of work, I guess the implications would lead to a simpler type system, formally... but require a much more powerful implementation on the GHC end (since the dictionary is handled differently perhaps). This would shift a lot of responsability towards some user-defined library.
19:54:52 <nitrix> Haha, anyway. Just very curious. I'm probably venturing in non-sense.
20:02:54 <mniip> 6/25/2018 [05:44:22] <edmundnoble> nitrix: There is absolutely `(,) :: Constraint -> Constraint -> Constraint`, assuming it doesn't have special support.
20:02:56 <mniip> it kind of does
20:03:29 <glguy> Like (=>), (,) doesn't exist on its own in an unapplied form
20:04:04 <mniip> % :k ((,) :: Constraint -> Constraint -> Constraint)
20:04:04 <yahb> mniip: ; <interactive>:1:2: error:; * Expected kind `Constraint -> Constraint -> Constraint', but `(,)' has kind `* -> * -> *'; * In the type `((,) :: Constraint -> Constraint -> Constraint)'
20:04:32 <mniip> % :k (Int ~ Int, Int ~ Int)
20:04:32 <yahb> mniip: (Int ~ Int, Int ~ Int) :: Constraint
20:06:05 <mniip> you can do a little bit of this though
20:06:08 <mniip> % type ConstraintPair (c :: Constraint) d = (c, d)
20:06:08 <yahb> mniip:
20:06:12 <mniip> % :k ConstraintPair
20:06:12 <yahb> mniip: ConstraintPair :: Constraint -> Constraint -> Constraint
20:06:15 <nitrix> % :k (~)
20:06:15 <yahb> nitrix: (~) :: k -> k -> Constraint
20:06:32 <nitrix> Notice how it does `k -> k`, I was expecting (=>) to be similar.
20:06:44 <mniip> that's not k -> k
20:06:51 <nitrix> o.o
20:06:53 <mniip> k -> (k -> Constraint)
20:07:31 <glguy> nitrix: Do you see why it's not, though?
20:08:00 <mniip> anyway, t and c => t have a bit of different roles
20:08:14 <nitrix> Ah, nevermind, it just clicked. Yeah the newer type is more constrained.
20:08:19 <mniip> (->) is special in that it allows quantified types in either its lhs or rhs
20:08:19 <nitrix> They aren't the same.
20:08:29 <Solonarv> % type Constrained c t = c => t -- does this even work?
20:08:29 <yahb> Solonarv:
20:08:40 <mniip> expecting an ambiguity error
20:08:49 <Solonarv> % :k Constrained
20:08:49 <yahb> Solonarv: Constrained :: Constraint -> * -> *
20:08:57 <nitrix> :D !
20:09:15 <Solonarv> % :kind! Constrained (Eq a) a
20:09:15 <yahb> Solonarv: ; <interactive>:1:17: error: Not in scope: type variable `a'; <interactive>:1:20: error: Not in scope: type variable `a'
20:09:22 <Solonarv> D:
20:09:24 <mniip> % :t show :: Constrained (Show a) (a -> String)
20:09:24 <yahb> mniip: Show a => a -> String
20:09:32 <mniip> grumble
20:09:59 <nitrix> Isn't that good? Looks sound to me ._.
20:10:20 <mniip> considering type synonyms have to always appear fully applied I suspect it's no different
20:10:25 <glguy> You still have a type synonym, you can't use it in any new ways than you could before
20:10:30 <mniip> in that it doesn't *really* have a function kind
20:10:49 <Solonarv> yeah type synonyms aren't much more than macros / #define's
20:11:28 <mniip> % instance Functor (Constrained c)
20:11:28 <yahb> mniip: ; <interactive>:8:10: error:; * The type synonym `Constrained' should have 2 arguments, but has been given 1; * In the instance declaration for `Functor (Constrained c)'
20:12:10 <Solonarv> that wouldn't be a legal instance even if it did work
20:12:12 <mniip> that would've actually made a limited amount of sense. (a -> b) -> (c => a) -> (c => b)
20:12:44 <Solonarv> actually I guess it could be
20:12:52 <nitrix> :)
20:13:00 <mniip> you could definitely go for  data C c t where C :: c => t -> C c t
20:14:12 <Solonarv> => can be desugared to / encoded as -> so that makes sense
20:14:17 <mniip> nitrix, anyway, in order for the typesystem to make sense, the only places quantified types can appear are inside the lhs/rhs of (->)
20:15:36 <mniip> type systems where TyCon (forall a. ty) is a valid type intrinsically don't have principal types
20:15:44 <glguy> even when they aren't quantified in that position it would be a little weird
20:15:57 <glguy> forall a. Maybe (Ord a => Bool) -> Whatever
20:16:22 <mniip> any fancy typechecking and/or inference you can do with such types will immediately explode in your face
20:16:26 <nitrix> Yeah it'd be pratically unmanageable, but I was wondering if that would lead to fun stuff.
20:17:03 <mniip> % :set -XImpredicativeTypes
20:17:03 <yahb> mniip:
20:17:04 <Solonarv> or data constructors, no? data Coyo a = forall s. Coyo s (s -> a) is valid
20:17:18 <glguy> -XBeBroken
20:17:21 <mniip> % x :: [forall a. a]; x = [(), 'c', "foo"]
20:17:21 <yahb> mniip: ; <interactive>:10:26: error:; * Couldn't match expected type `a' with actual type `()'; `a' is a rigid type variable bound by; a type expected by the context:; forall a. a; at <interactive>:10:25-40; * In the expression: (); In the expression: [(), 'c', "foo"]; In an equation for `x': x = [(), 'c', "foo"]; <interactive>:10:30: error:; * Couldn't match
20:17:35 <mniip> oh err
20:17:40 <mniip> the other way around is it
20:17:44 <nitrix> Like make-shift alternative type inference strategies on top of the hypothetical new more powerful type system...
20:18:21 <nitrix> Ignore my madness, I see it's already contagious :P
20:18:33 <mniip> % x :: [forall a. (a -> Bool)]; x = [(> (3 :: Int)), (== 'c')]
20:18:34 <yahb> mniip: ; <interactive>:11:40: error:; * Couldn't match expected type `a' with actual type `Int'; `a' is a rigid type variable bound by; a type expected by the context:; forall a. a -> Bool; at <interactive>:11:35-60; * In the second argument of `(>)', namely `(3 :: Int)'; In the expression: (> (3 :: Int)); In the expression: [(> (3 :: Int)), (== 'c')]; <interact
20:18:54 <Solonarv> let { x :: [forall a. (a -> Bool)]; x = [(> (3 :: Int)), (== 'c')] }
20:18:54 <mniip> it's 6 am and I forgot how all of this works
20:19:15 <mniip> Solonarv, no that should pick up as one declaration as is
20:19:19 <Solonarv> % let { x :: [forall a. (a -> Bool)]; x = [(> (3 :: Int)), (== 'c')] }
20:19:19 <yahb> Solonarv: ; <interactive>:12:46: error:; * Couldn't match expected type `a' with actual type `Int'; `a' is a rigid type variable bound by; a type expected by the context:; forall a. a -> Bool; at <interactive>:12:41-66; * In the second argument of `(>)', namely `(3 :: Int)'; In the expression: (> (3 :: Int)); In the expression: [(> (3 :: Int)), (== 'c')]; <interact
20:19:27 <Solonarv> yep you're right, that didn't help
20:20:10 <mniip> yeah the forall actually means the elements of the list should be able to be used in any context
20:20:25 <mniip> % let x :: [forall a. a]; x = [error "hi", fix id]
20:20:25 <yahb> mniip:
20:20:36 <Solonarv> "fix id" my sides
20:21:02 <mniip> now watch it explode (probably)
20:21:06 <mniip> % :t head x
20:21:06 <yahb> mniip: ; <interactive>:1:1: error:; Ambiguous occurrence `head'; It could refer to either `Prelude.head', imported from `Prelude' (and originally defined in `GHC.List'); or `Data.Functor.Base.head', imported from `Data.Functor.Base'
20:21:15 <Solonarv> % show <$> x
20:21:15 <mniip> % :t Prelude.head x
20:21:15 <yahb> mniip: a
20:21:15 <yahb> Solonarv: ; <interactive>:16:1: error:; * No instance for (Show (forall a. a)) arising from a use of `show'; * In the first argument of `(<$>)', namely `show'; In the expression: show <$> x; In an equation for `it': it = show <$> x
20:21:20 <mniip> I should fix that...
20:26:11 <mniip> it's working better than expected
20:27:52 <mniip> there
20:28:04 <mniip> % let x :: [forall a. [a]]; x = [[], []]
20:28:05 <yahb> mniip:
20:28:21 <mniip> % :t \z -> foldr const z x
20:28:21 <yahb> mniip: (forall a. [a]) -> forall a. [a]
20:28:42 <mniip> % :t (\z -> foldr const z x) []
20:28:42 <yahb> mniip: ; <interactive>:1:25: error:; * Couldn't match expected type `forall a. [a]' with actual type `[a0]'; * In the first argument of `\ z -> foldr const z x', namely `[]'; In the expression: (\ z -> foldr const z x) []
20:28:52 <mniip> asplode it goes
20:29:53 <mniip> (\z -> foldr const z x) has a good type outside of impredicativity so a good question is what goes wrong here exactly
20:30:16 <mniip> my guess is that the extra constraint forall a. [a] ~ forall b. [b] blows up the typechecker
20:30:38 <mniip> on second thought
20:30:46 <mniip> % :set -dppr-debug
20:30:46 <yahb> mniip:
20:30:52 <mniip> % :t \z -> foldr const z x
20:30:52 <yahb> mniip: (forall a. [a]) -> forall a. [a]
20:31:05 <mniip> I want my tyvar ids :(
20:31:26 <mniip> % f = \z -> foldr const z x
20:31:26 <yahb> mniip:
20:31:28 <mniip> % :i f
20:31:28 <yahb> mniip: Ghci7.f{v} :: (forall a. [a]) -> forall a. [a] -- Defined at <interactive>:31:1
20:31:56 <mniip> I guess I'll stop now before it's too late
20:32:07 <Solonarv> % :r
20:32:07 <yahb> Solonarv: Ok, no modules loaded.
20:32:48 <Zer000> how do I handle exceptions that might happen in bindSocket? Like if I'm trying to bind to an already-used port.
20:33:13 <mniip> Solonarv, already killed it before you could
20:33:22 <mniip> also :r doesn't reset DynFlags
20:33:53 <Solonarv> you want `catch` or some variant thereof Zer000
20:33:56 <mniip> a nice misfeature is that there's no way to unset -dppr-debug
20:35:21 <mniip> Solonarv, FYI there's :q or %kill if something goes very wrong :p
20:35:51 <Solonarv> ah, good to know
20:36:18 <Zer000> Solonarv, well in the documentation it has nothing about error handling, but since it's not a pure operation, I'm not even sure at this point what happens when things fail.
20:36:45 <Solonarv> it throws an exception
20:36:54 <Zer000> then I do want to catch it!
20:36:54 <Solonarv> which can catch using the catch function
20:36:59 <Solonarv> % :i catch
20:36:59 <yahb> Solonarv: catch :: Exception e => IO a -> (e -> IO a) -> IO a -- Defined in `GHC.IO'
20:39:12 <Zer000> I'll need to read about that, or look at examples
20:42:05 <mniip> % catch (Right <$> Network.Socket.socket Network.Socket.AF_INET Network.Socket.Stream 0) (\(e :: SomeException) -> return $ Left e)
20:42:06 <yahb> mniip: Left Network.Socket.socket: permission denied (Operation not permitted)
20:42:41 <Solonarv> don't catch SomeException grrr
20:42:56 <mniip> yeah, IOException it is
20:47:14 <Zer000> miip I think in your example you can get rid of the lambda by using try?
20:47:40 <Zer000> if you're going to return a Left anyway
20:48:15 <Solonarv> yeah, try act === (Right <$> act) `catch` Left
20:48:36 <Solonarv> er, pure . Left
20:50:30 <mniip> that would require I quantified the return type anyway
20:50:45 <mniip> specified, I mean
20:50:53 <mniip> too many quantifiers tonight
21:23:11 <enterprisey> any ideas for parsing a string of one, two, or three octal digits with Megaparsec?
21:23:25 <enterprisey> of course I could use <|> with one parser for each length, but that sounds silly
21:23:48 <enterprisey> ideally, I would use a version of takeWhileP with a "maximum number of tokens to consume" argument, but I don't think that exists
21:53:10 <dminuoso> enterprisey: Control.Monad.Combinators.count'
21:53:14 <enterprisey> !
21:53:16 <enterprisey> thank yoU!
21:54:27 <cocreature> enterprisey: if you care about the additional efficiency provided by takeWhileP you could write your own combinator for that now that megaparsec exposes its internals
21:54:46 <enterprisey> cocreature: definitely a possibility
21:55:03 <enterprisey> another level of yak-shaving wouldn't be too bad
21:58:43 <dminuoso> > [(1,a), (2, b), (3, c)] & partsOf (each . _2) .~ [x,y,z]
21:58:46 <lambdabot>  [(1,x),(2,y),(3,z)]
22:31:53 <dminuoso> @let newtype Pretext s a = Pretext { runPretext :: forall f. Functor f => (s -> f s) -> f a } deriving Functor
22:31:55 <lambdabot>  Defined.
22:32:55 <dminuoso> Oh I just realized my mistake, nevermind!
22:32:55 <dminuoso> @undef
22:32:55 <lambdabot> Undefined.
22:51:59 <wchresta> I'm looking for a library for working with (mathematical) finite fields/galois fields for prime powers p^k where k>=1. There are loads for k=1; found none for k>1.
22:53:00 * hackage influxdb 1.6.0.5 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-1.6.0.5 (MitsutoshiAoe)
22:57:04 <jle`> is there a name for functions like all :: (a -> Bool) -> ([a] -> Bool), any :: (a -> Bool) -> ([a] -> Bool) that "lift" predicates over sets or other things?
22:57:12 <jle`> i guess they are all lmaps or contramaps of predicates
22:57:56 <jle`> i was thinking of writing a small library of functions like these at the type level but i'm not sure what I would call it
22:58:10 <jle`> data All :: (k -> Type) -> ([k] -> Type)
22:58:19 <jle`> data Any :: (k -> Type) -> ([k] -> Type)
22:59:07 <jle`> and i'm not sure what other examples there might be
22:59:24 <jle`> maybe i just am talking about existential vs universal quantification
23:01:14 <gentauro> any stack experts? :)
23:01:36 <cocreature> gentauro: just ask your actual question
23:01:42 <gentauro> I'm looking for a flag to point to a "package.yaml"
23:02:41 <gentauro> but I don't seem to find it (I'm guessing that package.yaml is "hardcoded" in stack)
23:04:44 <cocreature> yeah, afaik you can’t change that
23:07:04 <gentauro> makes it a bit harder to test ... (package_test.yaml / package_prod.yaml)
23:07:05 <gentauro> :(
23:07:27 <gentauro> I can go with some copy/pasta (bash script) but it just seem a bit ... meh
23:07:29 <cocreature> that sounds like the wrong way to approach this. make a single package.yaml file that has a flag instead
23:08:02 <gentauro> a flag?
23:08:37 <wchresta> To answer my own question; it seems HaskellForMaths provides galois fields for k>1
23:09:00 <cocreature> gentauro: you can have flags in cabal files (and therefore also in package.yaml files)
23:09:24 <cocreature> and then test for those flags and set options conditionally or whatever you are trying to do differently for tests and prod
23:11:05 <gentauro> cocreature: roger that
23:11:06 <gentauro> thx
23:42:00 * hackage algolia 0.1.0.0 - A client implementing the Algolia search API  http://hackage.haskell.org/package/algolia-0.1.0.0 (IanDuncan)
