00:02:44 <initiumdoeslinux> Hello, yesterday me and a lad tried to figure out why I can't compile a program of mine,
00:03:07 <initiumdoeslinux> I get a transformers error, it is not a direct dependency of mine
00:03:23 <initiumdoeslinux> this is the error: https://gist.github.com/eHammarstrom/75b56c82af7e6dad58a42ffffd1ac162
00:03:46 <initiumdoeslinux> And this is the code where it is produced, https://gist.github.com/eHammarstrom/a997d9a1dacd8bb97f7ae99907c4ed20
00:04:19 <initiumdoeslinux> And here is the program, https://gist.github.com/eHammarstrom/92d34355170ee7c846888c387bc8d7d7
00:04:58 <initiumdoeslinux> Does anyone have any ideas of what I might try to do to figure out the cause of this?
00:05:32 <initiumdoeslinux> We had someone else make a minimal project using only mtl as a dependency, still getting the same error
00:08:23 <initiumdoeslinux> I can provide the full project if you want to try something out, I am clueless
00:16:29 * hackage vado 0.0.10 - Runs commands on remote machines using ssh  http://hackage.haskell.org/package/vado-0.0.10 (HamishMackenzie)
00:16:48 <jle`> initiumdoeslinux: it comes from throwError
00:17:01 <jle`> er wait sorry
00:17:56 <initiumdoeslinux> I believe that is the MonadError throwError from mtl
00:18:05 <Taneb> Is there anything anywhere of type KnownNat n => p n -> Either (n ~ 0) (exists m. n ~ m + 1)
00:18:46 <Taneb> Except a type that actually is valid GHC-Haskell
00:19:11 <jle`> Taneb: none built in but there are some libraries which can make it
00:19:24 <jle`> (~) as a data type is (:~:)
00:20:41 <jle`> initiumdoeslinux: have you tried using a more recent version of the libraries
00:20:58 <jle`> initiumdoeslinux: what version of mtl are you using?
00:21:29 <jle`> transformers-0.5.2 is over two years old, so you might be using an old mtl as well
00:22:29 <initiumdoeslinux> jle`: I see, I am on stack lts-11.9. Let me try bumping it up
00:22:37 <jle`> initiumdoeslinux: oh nevermind that's pretty recent
00:23:00 <jle`> Taneb: you can implement it yourself using someNatVal
00:23:24 <jle`> and you might need unsafeCoerce
00:23:27 <Taneb> jle`: yeah, I'm giving this a go now
00:23:31 <Taneb> Thanks :)
00:23:35 <jle`> np :)
00:23:47 <jle`> Taneb: the source of my typelits-witnesses library might help
00:24:43 <jle`> Taneb: but fair warning, you're using the built in Nat type in a way that it's not really meant to be used
00:24:51 <jle`> so you're going to encounter some friction no matter what
00:25:06 <khilan> Hello! I'm trying to implement some code. Am getting an error "Could not deduce (Fractional Word8) arising from a use of ‘/’ " on line write arr (i,j) ((rank * 255) / 900.0). Can someone please help me out?
00:25:13 <jle`> also note that depending on your end goal, using typechecker plugins might be an easier way to get around to what it is you really are trying to do
00:25:37 <jle`> khilan: what do you want / to do?
00:25:39 <jle`> integer division?
00:25:44 <khilan> yes
00:26:17 <jle`> then use `div`
00:26:25 <jle`> (/) is for fractional division :)
00:27:23 <jle`> initiumdoeslinux: try putting type signatures on all of your top level declarations in Spec.hs
00:27:43 <khilan> Yes, sorry . Tried that. It gives "Could not deduce (Integral (Pixel Y Word8)) arising from a use of ‘div’ "
00:28:18 <khilan> I know I'm messing somewhere with the types but am unable to debug it exactly
00:28:37 <jle`> what is the type of 'rank' ?
00:29:10 <khilan> I've declared rank as a mutable reference : rank <- readSTRef rankRef
00:29:21 <jle`> so what is its type?
00:29:31 <jle`> Bool?
00:29:33 <jle`> String?
00:29:50 <khilan> Int
00:30:21 <jle`> if it is Int, then "(rank * 255) `div` 900" should give no problem
00:30:32 <jle`> can you paste your code?
00:30:51 <jle`> what is the type of 'arr'?
00:31:00 <jle`> @where lpaste
00:31:00 <lambdabot> http://lpaste.net/
00:31:44 <initiumdoeslinux> jle`: That did not affect the error
00:31:57 <jle`> initiumdoeslinux: i mean, label them so i can see what types they are :)
00:32:06 <initiumdoeslinux> Oh!
00:33:19 <jle`> khilan: what is the type of I.write, arr, etc?
00:33:33 <jle`> khilan: actually, can you paste the error?
00:33:48 <khilan> yes sure
00:33:51 <khilan> 1 min
00:34:36 <initiumdoeslinux> jle`: https://gist.github.com/eHammarstrom/a997d9a1dacd8bb97f7ae99907c4ed20
00:35:07 <jle`> khilan: are you sure rank is an Int?
00:35:15 <jle`> maybe try adding a type annotation to check
00:35:47 <khilan> yes sir, I'll check
00:37:06 <khilan> And write :: (Functor m, PrimMonad m) => MImage (PrimState m) arr cs e -> (Int, Int) -> Pixel cs e -> m ()
00:39:17 <jle`> khilan: yeah or just newSTRef (0 :: Int)
00:39:22 <jle`> initiumdoeslinux: yes this is indeed really puzzling
00:39:42 <jle`> the only time Error should show up as a cosntraint is if you're using ErrorT
00:39:54 <jle`> but there isn't any mention of ErrorT in all the code you pasted
00:40:03 <khilan> yes sir exactly
00:40:21 <jle`> initiumdoeslinux: oh i see
00:40:27 <jle`> initiumdoeslinux: found it
00:40:34 <jle`> initiumdoeslinux: yes this is really annoying
00:40:51 <jle`> initiumdoeslinux: there's an orphan instance of Alternative for (Either e) in transformers that requires Error e
00:41:08 <khilan> I'm sorry I didn't exactly understand sir
00:41:11 <jle`> it really has no business doing there heh, it's really a very awful design decision that dooms the entire ecosystem
00:41:23 <jle`> khilan: when you write newSTRef 0, write newSTRef (0 :: Int) instead
00:41:37 <khilan> oh ok, 1 min I'll try
00:42:16 <jle`> initiumdoeslinux: so there is no way to get Alternative to work properly on your `Parser a` unless you write an Error instance for ParseError
00:42:32 <khilan> Oh ok, getting it now sir
00:42:41 <khilan> Yes, that errors gone!
00:43:04 <jle`> initiumdoeslinux: see the bottom of this page http://hackage.haskell.org/package/transformers-0.5.2.0/docs/Control-Monad-Trans-Error.html
00:43:27 <khilan> But actually, it is expecting Pixel Y Word8 and I'm giving it int
00:43:37 <khilan> yes sir, I'll go through it
00:44:04 <jle`> khilan: yes, it should help clarify your thought
00:44:21 <khilan> yes sir, I missed that part. Thank u!
00:48:21 <initiumdoeslinux> jle`: What does it mean to be/have an orphan instance?
00:48:56 <jle`> initiumdoeslinux: an orphan instance is a typeclass instance that is defined in a model different than where the the typeclass or the type was defined
00:50:47 <initiumdoeslinux> jle`: do you mean module? if not, what do you mean by model?
00:50:55 <jle`> ah yes, module :)
00:52:53 <initiumdoeslinux> jle`: iirc I think this was actually documented in the mtl lib for MonadError
00:53:30 <jle`> yeah, if you write an instance of Error for your type then you should be ok
00:53:43 <jle`> the problem is that it doesn't know what error should be used for 'empty'
00:54:50 <jle`> so the orphan instance uses an empty made from the 'Error' typeclass
00:56:36 <initiumdoeslinux> so is it the `noMsg` function on the Error typeclass that is producing this?
00:56:56 <jle`> initiumdoeslinux: it's the Alternative instance for StateT s m
00:57:04 <jle`> which uses the Alternative instance for 'm'
00:57:21 <jle`> and the error is caused because the Alterantive instance for Either e is instance Error e => Alternative (Either e)
00:57:49 <jle`> and so you only have an Alternative instance for (Either X) if X has an instance of Error
00:57:58 <jle`> that's what is causing the error you see
00:59:07 <jle`> it's sort of like, `instance Eq a => Eq [a]`
00:59:16 <jle`> [X] only has an Eq instance of X has an Eq instance
01:00:30 <initiumdoeslinux> How do I find `:i Error` in ghci? Is not available after importing `Control.Monad.Trans`
01:02:32 <jle`> if you're just using mtl, you just need Control.Monad.Error.Class
01:03:13 <jle`> that's probably what you are using any since you use MonadError
01:12:31 <initiumdoeslinux> jle`: `noMsg` and `strMsg` are not 'visible' methods of `Error`, what am I supposed to implement?
01:28:25 <initiumdoeslinux> Nevermind, it was inferring another typeclass
01:48:13 <initiumdoeslinux> jle`: Thanks a lot, I would've never figured it out
04:18:59 * hackage blaze-html 0.9.1.0 - A blazingly fast HTML combinator library for Haskell  http://hackage.haskell.org/package/blaze-html-0.9.1.0 (JasperVanDerJeugt)
04:30:33 <Gurkenglas> Is reverse . reverse optimized away even if the left one was written because the right one was inaccessibly behind wrappers in some library?
04:33:00 <lyxia> it doesn't seem optimized away in any case
04:33:12 <dminuoso> Why is that? Because there's no RULES for reverse?
04:33:49 <lyxia> that, and it's not id on infinite lists or partially defined ones.
04:37:37 <lyxia> You can check that it is not rewritten by looking at the optimized Core of "main = (reverse . reverse) [1,2,3] `seq` return ()"
04:45:35 * hackage aeson 1.4.0.0 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-1.4.0.0 (AdamBergmark)
04:54:16 <rszibele[m]> Any stack maintainers here? Would be nice if someone could review my pull request: https://github.com/commercialhaskell/stack/pull/3952
04:55:05 <rszibele[m]> It basically adds the command 'run' to stack which builds and executes an executable or falls back to the first available executable if no executable is specified.
04:55:29 <rszibele[m]> Similar to cabal run
05:16:29 * hackage LambdaHack 0.8.1.2 - A game engine library for tactical squad ASCII roguelike dungeon crawlers  http://hackage.haskell.org/package/LambdaHack-0.8.1.2 (MikolajKonarski)
05:17:59 * hackage Allure 0.8.1.2 - Near-future Sci-Fi roguelike and tactical squad game  http://hackage.haskell.org/package/Allure-0.8.1.2 (MikolajKonarski)
05:37:11 <reactormonk> Can I resolve type families somehow in TH? Similar to :kind! in ghci. From what I see, I'd have to do the resultion manually and can't ask GHC to do it for me.
05:41:00 <lyxia> I don't think so.
05:48:27 <reactormonk> aye, so manual resolution it is.
05:49:36 <reactormonk> Is there a way to grab information of a Generic instance on the TH function?
05:50:40 <haskell_noob1> i am having an ffi call fail. I need some help with the FFI call: https://lpaste.net/3475865200987471872 whats the right way to convert from an int to cuint ?
05:53:34 <AndreasK> haskell_noob1: What exactly is failing?
05:53:51 <haskell_noob1> andreask : the call to the library complains that the flags are invalid.
05:53:54 <lyxia> reactormonk: That also seems unlikely. TH knows very little about the meaning of the things it manipulates.
05:53:57 <AndreasK> fromIntegral seems ok, although it better matches Word32
05:54:01 <lyxia> reactormonk: what are you trying to do BTW
05:54:13 <haskell_noob1> oddly (i guess because i dont understand) the repl works as expected.
05:54:35 <reactormonk> lyxia, replicate a bunch of typelevel magic with TH, because the use of extensible records makes GHC round in circles
05:54:37 <haskell_noob1> when i run it through tasty , the types dont seem to be getting resolved to CUInt, i believe.
05:54:55 <reactormonk> lyxia, here's the story: https://github.com/reactormonk/modules
05:55:43 <cocreature> haskell_noob1: what exactly do you mean by “the call to the library complains”?
05:55:56 <haskell_noob1> let me paste the error real quick.
05:56:37 <haskell_noob1> https://lpaste.net/3923253213859414016
05:56:56 <haskell_noob1> and when i run the function from repl, it seems to resolve the types correctly to create the file.
05:58:17 <haskell_noob1> https://lpaste.net/3001649039973285888
05:58:45 <AndreasK> haskell_noob1: Maybe something about file access rights/relative paths is causing it
05:58:49 <haskell_noob1> so repl is able to magically do something that my tasty unit test is not able to or most likely the function implementation has a bug.
05:59:03 * hackage first-class-patterns 0.3.2.4 - First class patterns and pattern matching, using type families  http://hackage.haskell.org/package/first-class-patterns-0.3.2.4 (shersh)
05:59:05 <haskell_noob1> hmm?
05:59:17 <AndreasK> Not familiar with the library but the error seems like something that would happen if it can't find/open/write to the path
05:59:22 <haskell_noob1> let me try with a fully qualified path.
05:59:36 <haskell_noob1> its likely..and when in repl the cwd is probably set sanely.
06:03:28 <haskell_noob1> andreask when i try with repl, the call works all the time. I am not sure why tasty is giving this error.
06:03:48 <haskell_noob1> https://lpaste.net/3001649039973285888
06:04:01 <AndreasK> well did it work with absolute paths?
06:04:38 <haskell_noob1> i tried with absolute path..it doesnt work.
06:04:53 <haskell_noob1> and it works in the repl as expected.
06:04:53 <AndreasK> in neither test nor repl?
06:05:08 <haskell_noob1> repl works all the time. which is why i am a bit confused.
06:05:48 <haskell_noob1> https://lpaste.net/2890028135644921856
06:06:04 <AndreasK> Does it work when you compile it as a simple program without tasty? I'Ve neither used tasty nur the hdf stuff so can only give generic advice :/
06:07:01 <haskell_noob1> thats going to be my next step. I was hoping to get my repl tests in a tasty file. Now i will try to use the executable and test it that way and see if that works. Thank you. this was helpful.
06:12:44 <ZeuPiark> hello
06:56:20 <pzp> Which web framework would you recommend? Yesod sounds like it is pretty popular but I'm looking for something with a little less "magic" (read TH?).
06:56:52 <Clint> what do you want instead of "magic"?
06:59:09 <pzp> I would prefer doing more of the work myself than relying on code generation.
06:59:50 <pzp> I like to be able to see what is happening in the code so that I can reason better about it.
07:00:28 <pzp> I think I saw somewhere that it's possible to use Yesod without relying on the TH stuff. Is there a good tutorial/guide for that?
07:05:11 <pzp> happstack-lite looks pretty good. Anything like that that I should consider?
07:08:30 * hackage tpdb 2.1.0 - Data Type for Rewriting Systems  http://hackage.haskell.org/package/tpdb-2.1.0 (JohannesWaldmann)
07:24:15 <philippD> Are there any interesting relationships between Foldable, Traversable and Applicative, Monad? Like getting definitions for classes for free if you provide other ones (besides the Monad, Applicative relation)
07:31:08 <Tuplanolla> At least there are `sequenceA = traverse id` and `foldMap f = getConst . traverse (Const . f)`, philippD.
07:33:24 <philippD> Tuplanolla: Makes sense. If there were more you wouldn't need classes for these functions.
07:33:26 <alamut> hello
07:33:37 <philippD> hey
07:34:03 <alamut> does anyone mind telling me what is the type for a even.length function?
07:35:39 <hexagoxel> :t even . length
07:35:41 <lambdabot> Foldable t => t a -> Bool
07:36:58 <alamut> even tho i dont know why it worked it did, thanks
07:42:53 <dmwit> pzp: I've heard good things about scotty and warp, and my understanding is that they go for minimal magic.
07:43:25 <dmwit> I've also personally used snap without any of its magic (it has a lot) and it's quite usable without it.
07:45:38 <philippD> why does `error` have such a strange signature? https://hackage.haskell.org/package/base-4.11.1.0/docs/Prelude.html#v:error
07:46:35 <philippD> I get the `HasCallStack` constraint, but why the `TYPE` and `RuntimeRep` stuff?
07:47:22 <dmwit> For most uses, you can ignore all that. If you want the full details, the thing to google is "levity polymorphism".
07:48:26 <dmwit> In short: so that `error` can be used both for lifted types (that can have a bottom) and primitive, magic, unlifted types like Int# (that don't have a bottom).
07:48:28 <hexagoxel> alamut: specialized on lists would be  [a] -> Bool
07:48:41 <dmwit> :t even . length @[]
07:48:43 <lambdabot> error:
07:48:43 <lambdabot>     Pattern syntax in expression context: length@[]
07:48:43 <lambdabot>     Did you mean to enable TypeApplications?
07:48:59 <philippD> :t even . (length :: [a] -> Int)
07:49:00 <lambdabot> [a] -> Bool
07:49:09 <dmwit> % :t even . length @[]
07:49:09 <yahb> dmwit: [a] -> Bool
07:50:12 <dmwit> (...I'll admit I find it a bit weird that `error` can be used for unlifted types.)
07:50:13 <hexagoxel> wait, what does "error" do if not creating bottom?
07:50:17 <dmwit> ...yeah
07:51:50 <philippD> hexagoxel: undefined actually does the same magic
07:53:53 <dmwit> philippD, hexagoxel: https://stackoverflow.com/q/49986342/791604 looks relevant
07:54:31 <dmwit> Looks like the `HasCallstack` constraint is part of the magic; that makes it a function (which is lifted) under the hood.
07:56:13 <hexagoxel> interesting, thanks
07:56:26 <philippD> how about `errorWithoutStackTrace` then? https://hackage.haskell.org/package/base-4.11.1.0/docs/Prelude.html#v:errorWithoutStackTrace
07:57:42 <dmwit> yeeesh
07:59:32 <hexagoxel> still a function, because of the [Char] ? i'd guess the one thing you can not write is `undefinedWithoutStackTrace`.
07:59:35 <dmwit> Actually, I believe Richard's answer on SO does more or less cover this, too.
08:00:21 <dmwit> "x is unlifted" just means "no code that looks at x has to worry that x might be undefined", because in case the thing you bound to x is bottom that code never runs.
08:00:37 <philippD> hexagoxel: since `undefined = error "Prelude.undefined"` you could: https://hackage.haskell.org/package/base-4.11.1.0/docs/src/GHC.Err.html#undefined
08:01:45 <philippD> dmwit: but isn't that true for * as well?
08:03:13 <philippD> hexagoxel: you seem to be right. errorWithoutStackTrace just fakes an empty StackTrace
08:05:15 <dmwit> philippD: No, it is not true for * as well. For example, in `let x = undefined in False && x`, the `(&&)` really does run. If `x` were an unlifted type, it would not.
08:06:12 <philippD> ahh, of course. Thanks
08:06:34 <hexagoxel> does (&&) "look at x" in that case?
08:06:54 <dmwit> Maybe not. But my statement is true for `let x = undefined in True && x`, too.
08:07:37 <philippD> are all functions on unlifed types automatically strict?
08:08:04 <dmwit> I *think* the question doesn't make sense, because the function can't be called with bottom as an argument.
08:08:38 <dmwit> But, like... basically yes.
08:08:43 <hexagoxel> % :t let u = errorWithoutStackTrace "undefined" in I# u
08:08:43 <yahb> hexagoxel: ; <interactive>:1:50: error:; * Couldn't match a lifted type with an unlifted type; When matching types; a0 :: *; Int# :: TYPE 'GHC.Exts.IntRep; * In the first argument of `I#', namely `u'; In the expression: I# u; In the expression: let u = errorWithoutStackTrace "undefined" in I# u
08:09:33 <dmwit> % :t I# (errorWithoutStackTrace "undefined")
08:09:33 <yahb> dmwit: Int
08:10:05 <dmwit> % const (I# (errorWithoutStackTrace "undefined")) 3
08:10:05 <yahb> dmwit: *** Exception: undefined
08:10:36 <dmwit> I# never gets called here. (nor const)
08:10:56 <hexagoxel> wait, there is defaulting to lifted?
08:11:06 <stondo> hi all
08:11:33 * dmwit waves at stondo
08:12:46 <philippD> hi stondo
08:13:34 <philippD> hexagoxel, what do you mean by that? Unless specified otherwise any typevariable has kind *
08:14:23 <hexagoxel> let-bound entities are always lifted?
08:15:12 <dmwit> No, but let behaves differently for lifted and unlifted types.
08:15:34 <hexagoxel> why exactly is my let u = .. a type error?
08:16:14 <dmwit> % :t let u :: Int#; u = errorWithoutStackTrace "undefined" in I# u
08:16:14 <yahb> dmwit: Int
08:16:33 <dmwit> I suspect philippD has the right of it.
08:17:12 <dmwit> You start with `u :: a`, which, because it's not specified otherwise, is given kind *, then unification tries to set `a ~ Int#` and fails because `Int#` does not have kind *.
08:17:44 <hexagoxel> "kind defaulting" ?
08:17:55 <hexagoxel> but yeah, that makes sense.
08:18:38 <dmwit> But this is a guess, not actually knowledge. It is backwards science, magical explanation.
08:18:50 <dmwit> All the same problems as phlogiston. Doesn't actually predict anything.
08:19:07 <Tuplanolla> % :seti -XMonoLocalBinds
08:19:07 <yahb> Tuplanolla:
08:19:08 <stondo> I'm reading Programming in Haskell and I'm a bit confused about how to pass a function to another function
08:19:18 <Tuplanolla> % :t let u = errorWithoutStackTrace "undefined" in I# u
08:19:18 <yahb> Tuplanolla: ; <interactive>:1:50: error:; * Couldn't match a lifted type with an unlifted type; When matching types; a0 :: *; Int# :: TYPE 'GHC.Exts.IntRep; * In the first argument of `I#', namely `u'; In the expression: I# u; In the expression: let u = errorWithoutStackTrace "undefined" in I# u
08:19:21 <stondo> all' :: (a -> Bool) -> [Bool] -> Bool
08:19:23 <stondo> all' f xs = and [True | x <- xs, f x]
08:19:28 <hexagoxel> (of course type defaulting machinery is a bit more complex and customizable, while there seems to be one static rule for kinds here.)
08:20:00 <dmwit> stondo: You know how to pass non-functions to other functions? It's just like that, except instead of putting something that isn't a function there, you put a function there. ;-)
08:20:12 <stondo> why isn't this valid? I don't understand the compiler's error message
08:20:34 <philippD> stondo: what's the error message
08:20:54 <stondo> Couldn't match expected type ‘a’ with actual type ‘Bool’ etc, etc
08:21:07 <philippD> in what code?
08:21:28 <dmwit> stondo: Because `xs` is a `[Bool]`, so `x` is a `Bool`, but you said `f` takes an `a`, not a `Bool`.
08:21:29 <stondo> I just pasted 2 lines..
08:21:46 <dmwit> stondo: So `f x` doesn't work.
08:22:11 <dmwit> stondo: You can fix it by either changing the `(a -> Bool)` argument to `(Bool -> Bool)`, or by changing the `[Bool]` argument to `[a]`.
08:22:17 <stondo> I thought f was just a placeholder for something, in this case a function that will take an a and returns a Bool
08:22:18 <dmwit> (I know which I would prefer!)
08:22:31 <dmwit> stondo: It is indeed. What makes you now think it is not?
08:22:48 <stondo> dwit: that's not what the exercise is asking though
08:22:58 <dmwit> stondo: The problem is that you have given `f` something that isn't an `a`!
08:23:12 <stondo> I even tried with pattern matching and guards, but I must be not getting something
08:23:18 <dmwit> stondo: Perhaps you had better show us the exercise, as well, then.
08:23:43 <stondo> thought a was of type of the element in my list?
08:24:44 <dmwit> stondo: Why did you think that?
08:24:45 <stondo> the exercise says: Without looking at the definitions in the standard prelude, write those functions: all, any, and some others
08:24:56 <stondo> using map and filter
08:25:03 <stondo> let me show what I wrote at first
08:25:20 <Tuplanolla> Your declared type is wrong, stondo.
08:25:34 <Tuplanolla> Read it out loud to yourself.
08:25:36 <dmwit> I don't understand why you think the exercise you have just said is incompatible with the advice I gave.
08:26:37 <stondo> I just copied it from the book
08:27:03 <stondo> all :: (a -> Bool) -> [Bool] -> Bool
08:27:10 <Tuplanolla> :t all
08:27:11 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
08:27:14 <stondo> I just added ' not to hide original all
08:27:26 <dmwit> Are you sure you copied that from the book accurately?
08:27:37 <dmwit> If so, there is an error in the book.
08:27:49 <stondo> pretty damn sure, yes, I have the book here just in fron of me
08:28:03 <stondo> I can show a piacture
08:28:09 <dmwit> Okay. Then there is an error in the book.
08:28:19 <stondo> damn, really_
08:28:27 <philippD> :t \ f xs -> and [True | x <- xs, f x]
08:28:29 <stondo> one sec, uploading the pic
08:28:29 <lambdabot> (t -> Bool) -> [t] -> Bool
08:29:37 <stondo> where can I upload a pic and share the link plz?
08:29:55 <dmwit> With all the love in the world: nobody cares.
08:30:03 <dmwit> Just fix your type signature and move on with learning.
08:31:08 <stondo> I just want to make sure there's really an error in the book and not something else I'm not understading correctly
08:32:11 <stondo> https://ibb.co/nCsOq8
08:32:22 <stondo> here the photo of a portion of that page
08:32:37 <dmwit> The book is in error.
08:33:24 <stondo> dwit that was driving me crazy
08:33:48 <stondo> but I didn't want to look at the type definition of the all version in the the standard prelude
08:34:27 <stondo> so the types definition of all the functions on that page are wrong?
08:34:58 <stondo> http://www.cs.nott.ac.uk/~pszgmh/pih-errata.html
08:35:14 <stondo> yup, there's definetly an error. Thanks everyone
08:36:14 <philippD> stondo: whenever you have a function that takes a function like `f :: (a -> b) ...` there has to be a source for an `a` somewhere
08:36:42 <dmwit> :t let nuhUH :: (a -> b) -> (); nuhUH f = () in nuhUH
08:36:44 <lambdabot> (a -> b) -> ()
08:37:27 <dmwit> ...but it's a good rule of thumb anyway. I should maybe have just stayed quiet.
08:37:48 <philippD> dmwit: yep :-p
08:38:48 <stondo> philippD: I thought that a could be as well be a Bool, so I woudln't have noticed the error in the definition :(
08:39:16 <stondo> *could as well be a Bool
08:41:09 <dmwit> stondo: Yeah, that is a common tripping point of polymorphic types.
08:41:12 <philippD> stondo: it can but the function has to work for any type `a`. If you want to restrict what types `a` can be you have to use classes
08:41:36 <dmwit> The protocol in Haskell is that the person using a value of a given type gets to choose what types go in the variables; the person implementing the type isn't allowed to at all.
08:45:57 <Math22232> how do I get the hwid in haskell as a string?
08:46:44 <dmwit> What's an hwid?
08:47:00 <Math22232> Hardware Identification
08:47:07 <Math22232> https://www.webopedia.com/TERM/H/HWID.html
08:47:53 <dmwit> I don't know for sure but I would guess you'd have to bind to some external function for that with the FFI.
08:48:15 <dmwit> You could look through the Win32 package but I don't think it's been updated in a long time.
08:50:36 * hackage mltool 0.2.0.1 - Machine Learning Toolbox  http://hackage.haskell.org/package/mltool-0.2.0.1 (aignatyev17)
08:55:10 * hackage convert 1.5 - Safe and unsafe data conversion utilities with strong type-level operation. checking.  http://hackage.haskell.org/package/convert-1.5 (danilo2)
08:57:30 <heath> https://github.com/hedgehogqa/hallofbugs/blob/master/index.md
09:01:04 <dmwit> :t traverse
09:01:05 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
09:03:20 <dmwit> :t runState
09:03:21 <lambdabot> State s a -> s -> (a, s)
09:21:56 <dmwit> heath: Neat. You might want to be more clear that you mean "bugs found by using hedgehog" and not "bugs found in hedgehog". ;-)
09:23:46 <ahri> can someone explain to me how, in http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html in the final example putting everything together, I thought at the top level of the `do` block I could get the current score after each action with `s <- score` so that I could then `lift $ putStrLn ("Score: " <> show s)` -- as this is not the case, how can I achieve this?
09:26:16 <dmwit> `s <- use score`
09:30:15 <ahri> dmwit: huh, ok, thanks, I hadn't come across `use` yet. that's awesome :)
09:30:57 <dmwit> By the way, I don't know lens very well. I discovered this by checking the type of `\f -> gets (^.f)` and then Hoogling that type. =P
09:31:00 <Sevior_> Hello, what would the type of a function like "function1 g = g . length " and "function2 f = f 2 True" ?
09:31:15 <dmwit> Sevior_: Why not ask the machine?
09:31:45 <Sevior_> what do you mean?
09:31:54 <dmwit> :t let function1 g = g . length in function1
09:31:55 <lambdabot> Foldable t => (Int -> c) -> t a -> c
09:32:11 <monochrom> Or do it in ghci
09:32:36 <dmwit> :t \g -> g . length -- if you don't mind not having a name for it
09:32:37 <lambdabot> Foldable t => (Int -> c) -> t a -> c
09:34:36 <Sevior_> im not using ghci, im doing some sort of course whic has a platform of its own
09:34:54 <infinisil> Get yourself ghci then
09:35:07 <Sevior_> and im asked to define the type of certain functions
09:35:51 <Sevior_> its kind of a "begginers guide to Haskell"
09:35:52 <zincy_> Is this the correct way to derive the generic typeclass for Text after you have imported GHC.generics and set the extensions?    instance Generic Text
09:36:42 <dmwit> No. Also I doubt you can derive Generic for Text.
09:36:47 <dmwit> Let's talk about why you want to do that.
09:37:21 <monochrom> You are asking total strangers who do not know your course and will not want to know, and who use ghci to answer you anyway. May as well cut out the middleman.
09:37:28 <zincy_> I want to use quickcheck to test some properties about a function
09:38:07 <zincy_> In order to generate random values of a custom ADT I need to make the type an instance of Arbritrary as well Generic for deriving
09:38:40 <lyxia> don't derive Generic for Text
09:38:41 <dmwit> What happens when you try to derive Generic for your ADT?
09:39:03 <zincy_> It works fine
09:39:08 <dmwit> So... problem solved?
09:39:14 <zincy_> sorry
09:39:26 <zincy_> deriving generic works for other typeclasses derivation
09:39:37 <zincy_> but for some reason quickcheck isnt happy
09:40:14 <dmwit> Yes, Arbitrary does not have defaults that use Generic.
09:41:48 <zincy_> ok if i remove the generic derivation for Text
09:41:53 <zincy_> and run quickcheck test i get
09:41:53 <zincy_>    • Unrecognized Rep: Rep Text       Possible cause: missing Generic instance     • In the expression: genericArbitraryU       In an equation for ‘arbitrary’: arbitrary = genericArbitraryU       In the instance declaration for ‘Arbitrary Text’    | 65 |     arbitrary = genericArbitraryU
09:43:08 <paidnode> Surely there is a standrad way of doing this, right? https://lpaste.net/1787816846045478912
09:43:28 <ahri> dmwit: thanks for the extra hoogle tip, I'll try to apply that thinking in future
09:43:35 <dmwit> zincy_: Sounds like GArbitrary is missing some instances for non-Generic leaves in your tree of types.
09:44:04 <dmwit> paidnode: That looks pretty standard to me.
09:44:35 <zincy_> thanks!
09:45:00 <dmwit> There was a question about another library similar to this the other day.
09:45:07 <dmwit> Let me see if I can dig it up to see how that other library solves this problem.
09:46:23 <dmwit> Man, Hackage is super slow for me today.
09:46:39 <nshepperd> does Text even have an Arbitrary instance?
09:46:42 * hackage threepenny-gui 0.8.2.4 - GUI framework that uses the web browser as a display.  http://hackage.haskell.org/package/threepenny-gui-0.8.2.4 (sjakobi)
09:46:53 <dmwit> nshepperd: Dunno. But even if not it's easy to write.
09:47:59 <dmwit> zincy_: Ah, the previous question was about the cereal package. You might draw some inspiration from the way it's done in that package; here's a direct link to the Generic-related class. I think its K1 instance is how it bottoms out at non-Generic types that instantiate Serialize.
09:48:04 <dmwit> https://hackage.haskell.org/package/cereal-0.5.5.0/docs/Data-Serialize.html#t:GSerializePut
09:48:05 <nshepperd> surely you want some equivalent of the String newtypes ASCIIString, PrintableString etc anyway
09:48:10 <paidnode> dmwit seems like. What I think I remembered is interact, similar in spirit (i.e. a small helper to void boilerplate) but it does something different. So I guess I just have to write this for every project where I interact with the user...
09:48:32 <keegans> what is a better way for me to do, `sequence $ take 4 $ cycle [getLine]`
09:48:41 <dmwit> replicateM 4 getLine
09:49:11 <keegans> dmwit: thank you
09:49:15 <dmwit> `cycle [foo]` is `repeat foo`. `take n (repeat foo)` is `replicate n foo`. `sequence (replicate n foo)` is `replicateM n foo`.
09:49:37 <keegans> :D
09:50:21 <lyxia> zincy: Text isn't a generic type so don't use generic-random to implement Arbitrary Text.
09:51:41 <vilu> Hi, having some newbie issues with haskell. So I'm poking around in a Scotty example application. https://github.com/eckyputrady/haskell-scotty-realworld-example-app. I'm having some issues trying to "log in" and use the JWT token generated by the login step. I can easily find the place in "my" code where it breaks. It's a call to the library which returns a Left with a "BadCrypto" value. What are some steps
09:51:42 <vilu> that I can take to figure out where exactly in the library things break and how to fix that?
09:51:51 <keegans> so, I can do `read "[4, 4, 4, 4]" :: [Integer]`, but i would like to be able to `read "4 4 4 4" :: [Integer]`. i can do `words "4 4 4 4"
09:51:53 <keegans> ["4","4","4","4"]`, but then what is the best way to convert each of those word into an integer list?
09:52:17 <vilu> My next steps now would be to check out the source code of the library
09:52:29 <vilu> And try to call this method with the same parameters I'm calling it now?
09:52:37 <lyxia> zincy: you could lift code from this package https://hackage.haskell.org/package/quickcheck-instances-0.3.18/docs/src/Test-QuickCheck-Instances-Text.html#line-18
09:52:50 <vilu> But ideally I would love to just be able to step into the source code like I would if I was i.e. on the jvm?
09:53:23 <vilu> Any tips on what I could do?
09:55:01 <lyxia> keegans: map read
09:57:22 <keegans> lyxia:     r xs = map (read :: String -> Integer) xs
09:57:43 <keegans> goign to have to map twice i believe because this a 2d thing
09:57:58 <dmwit> vilu: As sad as it sounds, my current go-to debugging technique is printf debugging. =(
09:58:19 <keegans> `    r xs = map (read :: String -> Integer) $ words xs` is what i meant
09:58:34 <vilu> dmwit: so is mine, I'm also quite ok with that.
09:58:54 <vilu> My problem is as soon as I need to debug something outside my own source code.
09:59:00 <vilu> Because I'm having issues in a libr.
09:59:26 <vilu> The way I tend to do it is to find the source code, run that and try to see if I can figure out what's going on.
09:59:33 <vilu> However it's a bit cumbersome.
09:59:34 <dmwit> Yes, me too.
09:59:58 <geekosaur> vilu, it's a bit more complicated than that in Haskell, because of laziness.
10:00:32 <vilu> geekosaur: Ok, in what sense do you mean that the laziness is an issue in the case of debugging here?
10:00:35 <geekosaur> you find yourself in code you didn;t expect because an expression gets forced when it's needed, not where it's written.
10:00:47 <vilu> Ah that's what you mean
10:00:53 <dmwit> I think the actual complaint here is about the arbitrary divide between library code/own code, not the bad debugging tooling (though that is also a problem, for sure).
10:01:13 <geekosaur> there's aalso issues with debug information in compiled object code, but if you have ghc 8,4 you have at least a partial solution to that that said, line-level debugging isn;t there yet
10:01:25 <dmwit> Like, there is a ghci debugger, which is bad for all the reasons geekosaur is saying. But it is also bad because it won't debug into library code.
10:01:47 <geekosaur> interactive / bytecode-compiled code can do it
10:01:49 <vilu> Exactly, the laziness part I tend to be able to overcome or at least I have been able to so far with the ghci debugger.
10:02:03 <vilu> You can force evaluation when in the debugger right?
10:02:21 <vilu> I remember this being confusing at first but it hasn't been a blocker.
10:02:33 <vilu> What is hard for me though is what dmwit clarified.
10:02:34 <geekosaur> there's been some discussion of getting line debugging into object code at some point
10:03:56 <vilu> For example, looking at the source code now this is using a JWT library. I'm not very familiar with this technique and I see it very possible that either I use the client the wrong way or I haven't set up the server in the correct way (maybe I'm not reading the right certs or whatever).
10:04:42 <vilu> However, I see that the issue will be either in the JWT library or an issue in the attoparsec library that the jwt library uses.
10:04:55 <vilu> So now I'm looking at what I expect to be 2 - 3 hours of debugging.
10:05:07 <vilu> For something that most likely is just me not knowing how to use the library.
10:05:17 <vilu> Or jwt in general.
10:05:38 <geekosaur> ideally that should be documentation, not debugging…
10:05:43 <vilu> I was hoping for someone to just tell me, point ghc to whatever and you can see where in the library code things go wrong.
10:05:51 <geekosaur> reverse engineering an api through a debugger is painful no matter what language
10:10:31 <vilu> Fair enough
10:13:07 <vilu> Btw dmwit when you say printf, are you referring to Debug.Trace.trace or is there something else?
10:14:45 <geekosaur> it's usually easier to debug in IO, at which point you can use any IO mechanism (and there is indeed a printf: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.11.1.0/Text-Printf.html#v:printf)
10:15:28 <geekosaur> that said, if you're debugging a laziness issue, you really want to use Debug.Trace because it'll be as lazy as the expression you're trying to figure out.
10:15:59 * hackage versions 3.4.0.1 - Types and parsers for software version numbers.  http://hackage.haskell.org/package/versions-3.4.0.1 (fosskers)
10:24:26 * hackage pandoc-types 1.17.5 - Types for representing a structured document  http://hackage.haskell.org/package/pandoc-types-1.17.5 (JohnMacFarlane)
10:28:04 <Cale> Adding something like:
10:28:25 <Cale> foo x y z | trace (show (x,y,z)) False = undefined
10:28:32 <Cale> to the top of your function declaration
10:29:37 <Cale> is a good way to extract arguments that it's applied to, and then you can hopefully find some where it's not doing the correct thing, and from there break the problem down by looking at what the definition would give for those arguments
10:30:30 <chindy> what is the most straight forward way/library to check if a string matches a regex in haskell ?
10:30:59 * hackage lines-of-action 0.0.0 - Lines of Action, 2-player strategy board game  http://hackage.haskell.org/package/lines-of-action-0.0.0 (jxv)
10:33:30 <python476> guys, how much do you owe your understanding of FP to books ?
10:33:43 <python476> I mean did it bend your mind or was it just 'well duh'
10:34:02 <johnw> it certainly wasn't 'well duh' for me
10:34:18 <python476> johnw, now that's a name I haven't heard in a looong time
10:34:34 * python476 makes gnu gang sign
10:34:50 <johnw> don't call it a comeback
10:34:57 <Cale> python476: When I started learning Haskell, it took me about 2 months before I felt like I could do anything useful with it, and about a year to get some level of comfort. I'm not sure exactly how much of that was books.
10:35:11 <Cale> But it was some combination of books and just trying things.
10:35:13 <python476> Cale: how much exposure to FP prior haskell ?
10:35:47 <python476> I'm reading some 80s book on FP, and the way of things in that community, which I'm quite fond of, is super foreign in a way
10:35:49 <Cale> I'd done a bit of scheme, and a little mathematica if that counts, but all the other languages I knew were mostly imperative
10:35:56 <python476> aight
10:36:09 <python476> (peter henderson book)
10:36:20 <Cale> Actually one of the most helpful experiences was writing an IRC bot as a single long shell pipeline
10:36:22 <python476> notable the recursive rules for semantics
10:36:37 <python476> Cale: you mean shell like or actual bash shell ?
10:36:39 <Cale> yeah
10:36:43 <Cale> bash
10:36:47 <python476> funky
10:37:02 <Cale> It had netcat on one end, and a fifo on the other to tie the knot
10:37:03 <python476> reminds me that as a kid, I started being enamoured with geeky things because of the * and pipe operators
10:37:27 <python476> in MSDOS that is
10:37:28 <Cale> and basically filtered all its input, and passed some of it through to mathematica for evaluation
10:37:40 <python476> quite neat
10:39:20 <Cale> chindy: We *mostly* try to avoid regex... if your goal is matching a bunch of text, consider libraries like attoparsec or megaparsec. There are a bunch of regex libraries though. None of the ones I can actually point you at are things I'm particularly happy with.
10:39:39 <Cale> Gabriel Gonzalez is/was working on something new though...
10:40:28 <johnw> regex-applicative isn't terrible
10:40:36 <johnw> basically makes working with regexs feel like parsec
10:40:38 <Cale> https://github.com/Gabriel439/slides/blob/master/regex/regex.md -- there's some code here along with some really cool info, but I don't know if he's packaged it
10:41:29 <johnw> ah, slow
10:43:11 <monochrom> I just disagree with using Num for this.
10:43:21 <johnw> me too
10:43:22 <johnw> too cute
10:44:26 <Cale> Num isn't that far off tbh, but negate is a problem.
10:44:56 <nshepperd> it's Num's fault for not being Semiring
10:45:06 <int-e> :t abs
10:45:07 <lambdabot> Num a => a -> a
10:45:09 <haska> hey all. i've install ghc and have ghc-pck. How do I use it to install protobuf?
10:45:14 <philippD> :t signum
10:45:15 <lambdabot> Num a => a -> a
10:45:32 <Cale> abs too, I suppose, though abs/signum can always be implemented in a trivial way
10:45:48 <philippD> but do they make sense in this case?
10:46:18 <Cale> I mean, if you just consider everything "positive", so that abs = id and signum = const 1
10:50:55 <haska> any suggestions for what plugins to use to get a good Haskell environment in Visual Studio Code?
10:52:00 <philippD> haska: Haskero is nice
10:52:37 <haska> philippD: i noticed that. seems like Haskelly has more downloads, but dunno
10:52:39 * hackage astro 0.4.2.1 - Amateur astronomical computations  http://hackage.haskell.org/package/astro-0.4.2.1 (aignatyev17)
10:54:15 <philippD> I didn't like Haskelly. Haskero forces you to use stack though. There is also GHC-mod which also works most of the time. It has the tendency to lock up and be killed externally sometimes though. All my experiences are on linux though
10:55:33 <philippD> I went back to a more basic setup with only hlint and running ghcid in an external terminal. Much more productive since you don't have to deal with the plugins not picking up your projects correctly and stuff.
11:00:52 <[exa]> Is there a parser that would be usable for getting rfc822-like message bytestrings to Network.Mail.Mime format?
11:03:37 <[exa]> there seems to be Network.Parser.Mime but there doesn't seem to be any simple documentation
11:07:14 <hpc> parseMimeHeaders might read the whole message, as weird as it sounds
11:07:47 <hpc> mvContent is what you would typically think of as the message
11:07:59 <hpc> and the Multi constructor for it is multipart mime content-type bodies
11:09:07 * hackage relational-query-HDBC 0.6.4.5 - HDBC instance of relational-query and typed query interface for HDBC  http://hackage.haskell.org/package/relational-query-HDBC-0.6.4.5 (KeiHibino)
11:12:29 * hackage relational-query-HDBC 0.6.7.1 - HDBC instance of relational-query and typed query interface for HDBC  http://hackage.haskell.org/package/relational-query-HDBC-0.6.7.1 (KeiHibino)
11:15:15 <haska> philippD: forcing to use stack you say. Not familiar with it, what's bad about stack?
11:16:46 <[exa]> hpc: oh so, thanks!
11:18:30 * hackage hmatrix-morpheus 0.1.1.2 - Low-level machine learning auxiliary functions.  http://hackage.haskell.org/package/hmatrix-morpheus-0.1.1.2 (aignatyev17)
11:18:46 <philippD> haska: stack is a buildtool that takes some pain away from using cabal but is relatively oppinionated. https://docs.haskellstack.org/en/stable/README/
11:21:48 <hpc> haska: specifically it's a reproducible build tool - it controls the build environment entirely, down to installing its own ghc
11:23:13 <veverak> and does not allow local package storage :/
11:23:32 <liste> haska: https://marketplace.visualstudio.com/items?itemName=alanz.vscode-hie-server seems promising, especially if you're on Linux/Mac. I'm currently trying to get it work on Windows properly, but that requires some assembly
11:25:16 <hpc> veverak: it doesn't have a "user" database, if that's what you mean
11:25:31 <hpc> er wait, ignore that
11:25:49 <hpc> 2:30 in the afternoon and i am still waking up lol
11:25:53 <veverak> hpc: :)
11:26:08 <veverak> hpc: I mean: 'look here /my/local/packages' for the stuff listed in extra-deps
11:26:15 <veverak> not on hackage
11:26:16 <hpc> yeah
11:26:21 * veverak went for cabal because of that
11:26:31 <hpc> "local hackage" instead of "things i already installed"
11:26:55 <veverak> point is: got a big ass ecosystem that has custom package system
11:27:02 <veverak> want to integrate haskell into that
11:27:14 <hpc> i think you can do some stuff with httpd to host a local package database, but i have never had to try
11:27:20 <veverak> "custom package system" -> "custom build tools" (cmake overlay)
11:27:35 <hpc> ouch
11:27:35 <veverak> so, I need that feature...
11:27:41 <veverak> otherwise I won't integrate
11:27:50 <haska> as a new comer, Haskell is a fucking mess, only slightly better than all the web stacks
11:28:01 <veverak> (the entire problem is more complex ofc...)
11:28:10 <veverak> haska: anyway, cabal happily provides what I need, so i am happy
11:28:15 <veverak> sorry, bad nick
11:28:18 <veverak> hpc: ^^
11:30:45 <philippD> haska: yeah, especially when coming from java or c# land. If you're starting out stack is great at hiding some of the worst parts of cabal from you. But don't be afraid of ditching it in favor of something else like Nix if you see the need.
11:32:22 <philippD> I hope I didn't piss of any stack maintainers here with that statement :D
11:33:10 <dmwit> Well, I learned a valuable lesson today, thank you haska.
11:33:43 <dmwit> I, too, have started learning a thing and had that reaction.
11:34:45 <dmwit> And until just now I never pondered how absurd "I have only been using this for 60 seconds and I already know all the technical decisions that went into it were decided wrongly" really sounds.
11:36:39 <sclv> veverak: there's a few ways to do that
11:36:46 <sclv> you can set up a local packagedb in the file system for one
11:37:09 <sclv> and also you can set up and run your own hackage instance
11:37:32 <hpc> dmwit: it helps to try to separate the model of something from its implementation
11:39:11 <sclv> veverak: cf https://github.com/haskell/cabal/issues/5060
11:39:33 <hpc> like say for rust, knowing the difference between the borrow checker not being perfect yet, and when you're just not writing very good code
11:40:00 <hpc> (or for haskell, knowing when you're using IO inappropriately and such)
11:42:06 <veverak> sclv: I know that cabal can
11:42:30 <veverak> sclv: will read that link, thanks
12:00:01 <chindy> is there a function [a] -> [a] -> bool that checks whether the first list ends with the second list
12:00:11 <chindy> so that [1,2,3] [2,3] is true
12:00:13 <hpc> :t isSuffixOf
12:00:15 <lambdabot> Eq a => [a] -> [a] -> Bool
12:00:21 <chindy> ahh
12:00:41 <hpc> > "bacon" `isSuffixOf` "yummy bacon"
12:00:43 <lambdabot>  True
12:00:50 <hpc> > "bacon" `isSuffixOf` "icky broccoli"
12:00:52 <lambdabot>  False
12:26:09 <RedNifre> Hi. I decided to learn stack, would you recommend the official haskellstack.org documentation or is there an even better tutorial somewhere?
12:31:33 * hackage reactive-banana-gi-gtk 0.3.0.0 - Simple reactive programming with GTK GObject Introspection  http://hackage.haskell.org/package/reactive-banana-gi-gtk-0.3.0.0 (miscyb)
13:17:36 <sms> r
13:18:03 <sms> Woops
13:19:07 <haskell_noob1> when implementing ffi, should i consider breaking a given header file into corresponding modules? The reason i ask is that multiple files will have a reference to the same header file. Is that ok? I am looking at that design as an oo developer (or perhaps just plain modules and file sizes)?
13:23:17 <srk> hmm
13:23:31 <dmwit> I don't understand the question at all.
13:23:31 <srk> how can I convert an odering into a -> b -> Bool
13:23:41 <srk> dmwit: this channel has magic properties
13:23:54 <srk> just switching to it sometimes resolves the issues
13:24:26 <dmwit> How do you represent the ordering?
13:24:45 <paidnode> you know your sunday evening gets frustrating when you need something between fold and a map that can take a function a -> b -> c instead of a -> b
13:24:46 <srk> pPrint $ L.groupBy ( comparing $ head . (filter ((== periph) . SVD.periphName)) . SVD.devicePeripherals . snd ) svds
13:24:49 <sm> RedNifre: the official doc is not well organised, but it's got the info; nothing much better
13:24:55 <srk> but then I've realized groupBy is not like sortBy
13:25:15 <RedNifre> sm Thanks, I'm reading it right now and it seems okayish.
13:25:44 <sm> RedNifre: and for most people, what you need to learn to use it is not much
13:25:47 <srk> paidnode: :D pretty much
13:25:54 <dmwit> Just in case the IRC messages have arrived in a different order for other folks than they did for me: when I said "I don't understand the question at all." I was talking about haskell_noob1's question, not srk's.
13:26:06 <srk> ok :)
13:26:20 <philippD> haskell_noob1: I tend to keep all my ffi bindings in one file since they only contain binding boilerplate.
13:26:48 <RedNifre> sm I already got a project set up, what I'm currently looking for is how to do ... local dependencies? As in, I want to have three separate projects where A uses B and B uses C.
13:27:13 <philippD> paidnode: traverse over a State monad?
13:27:17 <haskell_noob1> hmmm philippD,  interesting. I find that for a largish library,  i want to break down lib init calls, from lib module calls much as the library is structured? is that too much org overhead?
13:28:15 <dmwit> paidnode: `map` can take an `a -> b -> c` function no problem. ;-)
13:28:20 <dmwit> :t map (undefined :: a -> b -> c)
13:28:21 <lambdabot> [a] -> [b -> c]
13:28:31 <dmwit> how deceptive
13:28:45 <sm> RedNifre: all projects sharing one stack.yaml, or.. ?
13:28:47 <paidnode> :)
13:28:55 <haskell_noob1> the reason i dont like my approach is precisely that, there is boiler plate and i am not gaining much except for smaller file sizes (which may reduce some conflicts, though thats not a consideration).
13:30:29 <philippD> haskell_noob1: you wont be calling the ffi functions directly in most cases but rather write wrapper functions that hide the procedural nature. The bindings than are a 1-1 representation of the headers, the wrapper code can than be organized nicely in logical modules
13:30:33 <RedNifre> sm no, like, my projects tend to fall apart into specialized libraries all by myself, so I'd like to actually split them into totally independent projects, but not upload them to hackage/stackage... last time I used Haskell was years ago, but there was a way to put a local project into the cabal file of another local project, I think.
13:31:19 <sclv> RedNifre: the common way with cabal these days is new-build with .project files
13:31:20 <sm> RedNifre: for local testing, I'll sometimes put one project directory (or a symlink) inside other, since I think stack.yaml packages list doesn't allow ..
13:31:45 <sclv> things in the same project can depend on one another
13:31:56 <dmwit> Internal libraries are a thing with the newest cabals, but I don't know much about how they work. Googling should get you some docs.
13:32:06 <haskell_noob1> philippD, quite. In fact i am seeing that with my approach, I am creating a parallel structure : logical and internal. I went this path because there were some attributes that were being overloaded in the library and i was seeing name issues.
13:32:07 <sclv> this is different than internal libs
13:32:15 <RedNifre> hmmmmm
13:32:18 <paidnode> OK ,I give up, I'll post this on lpaste. It's just... it is a simple problem in an imperative language, and I aspire to be a professional Haskeller one day maybe, so not being able to proceed just feels like I don't have the intelligence for it. It also feels pretty hypocritical at times like this to think about times when I preach about how FP is better
13:32:22 <RedNifre> Not sure I understand this.
13:32:27 <dmwit> But yes, I would recommend making a project with several packages, one per library. That codepath is well-tested, and easy to get other people's experience on.
13:32:46 <sclv> http://cabal.readthedocs.io/en/latest/nix-local-build.html#configuring-builds-with-cabal-project
13:32:52 <dmwit> sclv: Yes, I know, I was offering an alternative not a clarification. =)
13:32:56 <sclv> sure
13:33:23 <haskell_noob1> though, i think i get the general principle behind the ffi design that you are proposing, philippD and this approach lends itself to the tools that generate most bindings. the library i am working on uses macro functions so i still have to deal with things by hands.
13:33:40 <RedNifre> Yeah, but what if I want to share code between projects? If I write library code, do I HAVE to publish it on stackage, or is there a cleaner way?
13:33:54 <RedNifre> (I have to look up how I did that with cabal years ago...)
13:34:17 <sm> RedNifre: you just list the project directories in stack.yaml packages list
13:34:29 <paidnode> https://lpaste.net/6897021095673593856, was at the point where I apply the runPhase function so that it encrypt my matrix, that's the gibberish that's the current state of encrypt
13:34:30 <sm> and reference the packages in your cabal files
13:34:57 <paidnode> it's from here: https://www.reddit.com/r/dailyprogrammer/comments/8n8tog/20180530_challenge_362_intermediate_route/
13:35:47 <dmwit> RedNifre: No. We have lots of libraries at work that are not published on Hackage for legal reasons. We share them between projects by just having a git repo for them.
13:36:27 <dmwit> (Then use whatever technique you want to make sure each project has pulled the repo down before you build. Submodules are popular at work, but there are other ways.)
13:36:29 <RedNifre> dmwit okay, but how exactly do you use those libraries in projects?
13:36:35 <RedNifre> oh
13:37:04 <philippD> paidnode: could you reduce the code to your specific problem please?
13:37:30 <RedNifre> Well, submodules would work, but I personally think that telling stack "for this project, also look over there in this local directory when resolving the dependencies, one of the dependencies is in there and not on stackage".
13:37:53 <dmwit> RedNifre: Yes, cabal new-build can do that. I'm not expert enough to say how to do it with stack, but I'm confident that's possible there, too.
13:38:30 <RedNifre> dmwit that sounds encouraging, I'll look into it some more.
13:38:31 <dmwit> RedNifre: With new-build, you'd just toss `packages: path/to/other/directory` in your `cabal.project` (or `cabal.project.local`).
13:39:57 <paidnode> phillipD is this better? https://lpaste.net/7671594374215499776
13:41:02 <paidnode> as I said, that encrypt function isn't the way I definitely want to do it, it was just a try to proceed with this, other approaches are welcome
13:42:23 <paidnode> so I have to apply runPhase to what remains from the matrix until it is empty, collecting and concatenating the lists returned as the second element of the tupes
13:42:43 <paidnode> or at least that's how I think about it
13:43:07 <paidnode> it does sort of sound like fold
13:44:52 <philippD> paidnode: So if I get you what you want to do could be expressed in an imperative language by storing the phase in a variable and looping over the matrix in some way and push elements into a list?
13:46:50 <paidnode> yes,  i guess, reading the elements of the matrix in a specific way (forming a "spiral")
13:46:57 <paidnode> so state monad?
13:48:31 <paidnode> (as you said?)
13:48:45 <philippD> If you want to keep some kind of state between steps it is useful. Looking at the challenge though I think it can be done without keeping the state this way
13:53:06 <paidnode> kinda planned to keep state using recursion, explicit or hidden behind a fold/map/etc. Do I not really need that either? How should  Iapproach this then?
14:04:26 <[exa]> paidnode: if you don't need the thing to be very fast, a common way to make a spiral is to rotate the matrix and strip off first row after each rotation
14:08:12 <hasky> hi, trying to use proto-lens: Could not find module ‘Proto.Google.Protobuf.Wrappers’
14:08:15 <hasky> ideas?
14:09:23 <abetaev> hi! i am complete newbie in haskell, and it looks like i'm getting to stupid question (sorry for that). i have a `data Problem {capacity :: Int, items :: [Item]}` and another type `data Solution {volume :: Int, items :: [Item]}`. could please somebody help me to understand why compiler says that `items` is declared twice?
14:09:38 <paidnode> [exa] that sounds like another cool approach, thx
14:11:01 <paidnode> although it seems like just another implementation of runPhase, I think I solved that part now (modulo not yet discovered bugs :) )
14:15:27 <philippD> paidnode: this is what I came up for the encrypt function https://hastebin.com/uxolutasil.hs
14:16:11 <electrocat> abetaev: it's a limitation of haskell record syntax
14:16:24 <electrocat> abetaev: you defined two types with fields with the same name
14:16:45 <electrocat> these fields are compiled to functions to extract this value
14:17:07 <electrocat> and you would have two functions with the same name
14:18:08 <electrocat> does that make sense?
14:21:45 <abetaev> yes, sure, it does
14:24:34 <[exa]> abetaev: there's IIRC some pragma that allows the field names to be overloadable, but that adds another level of complexity and a source of confusion, so just renaming one 'items' is usually the best way
14:25:26 <abetaev> [exa] okay, that's the way i'll go :)
14:25:35 <paidnode> philipD wow, that matrix function is just so not how I think... I guess you can only get so far without interacting with people who know more than you.
14:26:00 * hackage rattletrap 4.1.1 - Parse and generate Rocket League replays.  http://hackage.haskell.org/package/rattletrap-4.1.1 (fozworth)
14:28:59 <philippD> paidnode: Don't think in terms of mutating state but rather in terms of pipelines. Also the code leverage the fact that you can have lists of infinite length in haskell. First I create a matrix of infinite size that is padded with 'X' in every direction and than trim it to size.
14:29:04 <heath> dmwit: good point :) i'll mention that to Tim who's doing the asking
14:32:51 <paidnode> philippD the funny thing is I chose matrix to make my life easier. Well apparently I made it quite a bit harder by loosing the ability to patternmatch on it in a x:sx way... have to trust in lists more!
14:34:20 <philippD> paidnode: Matrix is nice if you want to perform common matrix operations in an efficient manner. For stuff like this Lists rule
14:35:20 <[exa]> paidnode: just an interesting side note -- there's an almost-mathematical mapping between spiral indices and final list indices
14:36:59 * hackage json-feed 1.0.2 - JSON Feed  http://hackage.haskell.org/package/json-feed-1.0.2 (fozworth)
14:40:49 <paidnode> [exa] can you expand on that?
14:41:35 <[exa]> matrix coords and index in the "spiral" list can be converted in O(1)
14:43:38 <mjoldfield> I've been messing around with some code which uses -XFlexibleInstances. So I have x which can either have type a or b i.e, x :: a and x :: b return the right thing at the ghci prompt. If I define fn x = (x,x), then fn x :: (a,a) and fn x :: (b,b) work too. Is there a way, presumably by way of an extension, to make fn x :: (a,b) work ?
14:43:48 <[exa]> way matrix->list: find min(distance from border), see how many indexes are in more-outer layers (just by subtracting rectangle areas), and solve for 4 cases of which side the coordinates belong to
14:45:08 <paidnode> do you mean the index of an element in a list representing the spiral and the coordinates of the same element in a matrix that's been unrolled injto that list? That's neat.
14:45:54 <paidnode> I'm thinking about whether that could in some way be leveraged to construct a more performant solution
14:45:59 * hackage smoothie 0.4.2.9 - Smooth curves via several interpolation modes  http://hackage.haskell.org/package/smoothie-0.4.2.9 (DimitriSabadie)
14:46:07 <[exa]> way back involves solving a quadratic equation to quickly see what level from the _middle_ of the matrix the index is inside, but after you have the level you're basically done
14:48:49 <phz_> damn, I have post-party blues (ZuriHac) :(
14:49:03 <[exa]> aaand the performant and cool solution: what about you run the same thing with rotating the matrix and making it smaller, just don't actually rotate it but use a different coordinate system for the movement
14:49:09 <[exa]> paidnode: ^
14:49:09 <sm> phz_: quick, organize a conf in your town
14:49:32 <c_wraith> mjoldfield: If I understand what you're asking correctly, -XRankNTypes will do the job, if you give fn a properly polymorphic type.
14:50:07 <phz_> sm: hehe, yeah
14:50:15 <sm> non-stop haskell party!
14:50:20 <phz_> sm: I haven’t found a way to hack around the segfault issue of mine
14:50:25 <phz_> so I decided to make a system call to file…
14:50:26 <phz_> I hate it
14:50:33 <phz_> but at least, it’s an ISO-like change
14:50:34 <sm> heh
14:50:35 <mjoldfield> c_wraith: Thanks, I shall go and read up on this. The code comes from http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WordNumbers2/ and is somewhat higher level than I know
14:50:43 <[exa]> paidnode: so the state is initially something like: dirLeft = (1,0), dirDown=(0,1), itemsOnLeft=0, itemsOnRight=10, itemsAbove=0, itemsBelow=5
14:51:01 <[exa]> (and ofc mtxPosition=(0,0))
14:51:03 <RedNifre> Hang on, maybe I got this all wrong... so with cabal I created separate packages that I used as local dependencies for other packages... but a stack "project" can contain multiple cabal packages, which solves the same problem? Can one package be in multiple stack projects at the same time? Would I do that with links in the file system or better, git submodules?
14:51:29 <c_wraith> mjoldfield: the type would be something like `(forall a. Foo x => x) -> (A, B)' , where Foo is the class involved, and A and B are concrete types
14:52:35 <[exa]> paidnode: btw the direction should be dirRight ofcourse, it's getting late here :D
14:52:41 <sm> RedNifre: "yes", I think..
14:53:25 <RedNifre> So if I want to create a local "library" that I don't want to publish, it would be a classic cabal project and my stack projects would have it as a submodule?
14:53:28 <mjoldfield> c_wraith: Gosh, it works!
14:53:45 <c_wraith> mjoldfield: now do the reading on it. :)
14:54:09 <RedNifre> ...but it's also possible to create libraries with stack, right? Can stack projects contain other stack projects, or only packages?
14:54:16 <mjoldfield> c_wraith: Do you have a good reference ?
14:54:24 <sm> stack projects consist of cabal packages.
14:54:44 <electrocat> *usually
14:55:05 <ZeuPiark> bye
14:55:08 <RedNifre> sm so if I want to reuse code across projects I have to either publish a stack project and add it as a dependency or put it in a package and use that one across stack projects?
14:55:12 <c_wraith> mjoldfield: https://ocharles.org.uk/blog/guest-posts/2014-12-18-rank-n-types.html is a good starting point
14:55:36 <electrocat> RedNifre: i don't follow
14:55:52 <RedNifre> Well, what's the recommended way to do code reuse when using stack?
14:56:19 <RedNifre> (I'm new to stack)
14:56:35 <electrocat> well in stack.yaml you can specify "packages"
14:56:38 <sm> RedNifre: I'm not sure where the complexity is coming from.. did you peruse the stack user guide ?
14:56:49 <electrocat> and point to several cabal packages
14:57:11 <paidnode> [exa] I think I kinda get it on first read, if you dont rotate the matrix but "the world around it" you get the same state as rotating the matrix, only the former is much less recource needy
14:58:05 <[exa]> paidnode: yeah. anyway dirDown isn't needed as well if you're sure about left/right-handedness of the coordinate system
14:58:52 <RedNifre> Well, I have this simpleSQLite library I made that's just a very thin layer on top of HDBC, which I want to use in my first stack project. It's actually a cabal package so I guess it'll work perfectly as-is, but I was wondering if that's the best approach.
14:59:27 <electrocat> well just add that library as a dependency in your other cabal project
14:59:32 <RedNifre> I would have expected some way to create a local "repository" so that my stack projects can list stuff from the local repository as dependencies, instead of linking them in.
14:59:41 <electrocat> en point the stack file to the location
14:59:50 <electrocat> and*
15:00:00 <sm> I see that it's confusing from the outside and maybe we're explaining it badly, but if you try it, following the user guide, I think it's pretty simple
15:00:00 <RedNifre> electrocat how exactly?
15:00:04 <[exa]> paidnode: have to go afk, you might also use this: turnDirRight (x,y) = (y,-x)
15:00:12 <sm> packages list in stack.yaml
15:00:20 <paidnode> [exa] yeaah, I should go too
15:00:25 <RedNifre> okay, I'll try and see if I can get it to work.
15:00:50 <paidnode> thanks both to you and philippD for the insights
15:00:56 <sm> (as we've mentioned several times :)
15:00:58 <electrocat> RedNifre: see that usually every stack.yaml file has a "packages" field? just add the location of your home-made dependencies there
15:01:16 <electrocat> so stack knows where to find them
15:01:27 <RedNifre> Yeah, what I find odd is that I don't turn that library package into a stack project, but maybe I'm thinking about it the wrong way.
15:02:04 <sclv> the stack project scopes over the cabal packages
15:02:09 <RedNifre> I thought that stack "replaces" cabal, but it seems to be something that you build around your cabal packages.
15:02:14 <sclv> right
15:02:30 <sclv> stack-executable can be used instead of cabal-install-the-executable
15:02:34 <electrocat> right with stack you can make 1 single project for multiple cabal packages
15:02:36 <sclv> but it isn't a different package-management-system
15:02:47 <sclv> electrocat: you can do that with cabal new-install btw
15:02:59 <RedNifre> I think it's getting clearer now.
15:03:02 <electrocat> sclv: oh right, have to try that out sometime
15:04:18 <electrocat> RedNifre: look at it this way, cabal is used as a build system for your packages, stack manages your dependencies
15:04:43 <RedNifre> ...but doesn't cabal also deal with dependencies?
15:04:53 <electrocat> well
15:04:55 <electrocat> it can
15:05:01 <electrocat> the cabal tool can
15:05:29 <sm> maybe https://docs.haskellstack.org/en/stable/stack_yaml_vs_cabal_package_file/ helps ?
15:05:31 <electrocat> it's complicated :p
15:05:31 <sclv> its  two alternative ways of managing them
15:05:42 <sclv> that's all
15:05:47 <electrocat> i guess yeah
15:09:06 <sm> stack is a layer on top of cabal, adding features like projects built from multiple local packages. Separately, cabal has been adding similar features, which some people prefer over stack. It's complicated enough that you really do have to read the docs.
15:10:05 <RedNifre> sm thank you, that clarified it some more.
15:11:32 <RedNifre> If I understand it correctly, the idea of having the cabal files say "I need some version of X" and the stack file say "If you need X, use version 0.3" is that you no longer run into the problem of two packages in your dependencies depending on two different versions of X, right?
15:12:17 <electrocat> right
15:12:35 <electrocat> that's one of the problems it solves
15:12:55 <RedNifre> I'm now starting to feel that stack might be a good ;)
15:13:29 <glguy> That problem was already solved, the problem it solves is that sometimes it was hard for cabal-install to determine what versions of packages to use, it's solved now by you manually specifying which versions to use in stack.yaml
15:14:20 <RedNifre> Would I ever use stack if I only have one package?
15:14:29 <sm> sure
15:14:33 <RedNifre> ...or does stack only make sense when dealing with at least two packages?
15:14:35 <RedNifre> Why?
15:14:59 <electrocat> so you don't have conflicts between dependencies
15:15:18 <glguy> You don't need stack to ensure you only get one version of each package
15:15:37 <sclv> stack is fundamentally about making use of stackage snapshots
15:15:44 <sclv> which fix versions of a universe of dependencies
15:15:49 <sclv> and its just a tool optimized for that workflow
15:16:02 <sclv> of pinning your entire universe to snapshots managed by the stackage curator team
15:16:17 <sclv> the cabal-way is to specify version bounds for depts individually
15:16:22 <sclv> and let the solver solve for them
15:16:28 <sclv> rather than pinning everything to a single fixed universe
15:16:32 <glguy> You still need to specify you versions for the stack way when making libraries
15:16:55 <glguy> since the stack workflow only pins down a particular build environment, it doesn't capture dependencies as needed for mixing libraries together
15:16:57 <sclv> glguy: right, when you're publishing you generate them for use by others
15:17:12 <glguy> even if you're using multiple libraries for yourself
15:17:13 <sclv> but if you're just writing your own app or project you just pin to a single snapshot
15:17:31 <phz_>         The following packages are broken because other packages they depend on are missing. These broken packages must be rebuilt before they can be used.
15:17:34 <phz_>     installed package haddock-library-1.4.5 is broken due to missing package haddock-library-1.4.5-JMywL3gQR7h8vuSGU4Yu5w-attoparsec
15:17:37 <phz_> argh, any idea how to solve that?
15:17:46 <phz_> I thought a stack clean + rm -r .stack-work would solve it
15:17:58 <sclv> phz_: oh ugh this is the internal libraries bug in stack
15:18:05 <phz_> lovely :D
15:18:30 <sclv> phz_: https://github.com/commercialhaskell/stack/issues/4071
15:18:34 <sclv> is the latest i know about it
15:18:49 <RedNifre> Alright, so since my unpublished library is only one cabal package using it in multiple stack projects should be simple... but what would I do if I have an unpublished library that is a stack project?
15:19:01 <RedNifre> (I'm kinda getting ahead of myself here, since I don't actually have that problem yet)
15:19:08 <glguy> with a single unpublished library you probably don't need the extra complexity of stack
15:19:23 <sclv> agreed
15:19:23 <haskell_noob1> if i would like a specific function to be always called before any function gets called inside a monad, whats the pattern i am looking for?
15:19:53 <sclv> haskell_noob1: that's not necessarily a well-formed question
15:19:55 <haskell_noob1> for example, always initialize a library,before calling open.
15:19:59 <jle`> haskell_noob1: what do you mean by 'function gets called inside a monad'?
15:20:06 <RedNifre> haskell-noob1 sounds like aspect oriented programming
15:20:20 <sclv> ok so in haskell one way to do this is with "regions"
15:20:38 <haskell_noob1> i see.
15:20:39 <sclv> a general approach would be that e.g. you use a reader monad
15:20:47 <sclv> and the reader is over a handle to the library
15:21:05 <sclv> so you can only invoke the monad by calling initialize on the library to get the handle
15:21:15 <sclv> (then you wrap it up in newtypes or something to enforce abstraction)
15:21:33 <sclv> that enforces that a function gets called before you execute the monadic code
15:22:20 <haskell_noob1> that makes sense. I can use a reader. Let me outline the problem a bit further: the library i am calling is doing a couple of side effects : initialize the library, and check the version and then the actual call. Now I am not sure if calling init on the library again is undefined behaviour. Lets assume it is. Should i be having 2 readers stacked?
15:22:47 <sclv> if 2 readers are stacked you get double initialization, right?
15:22:58 <sclv> so instead you use the single reader to thread through the sequencing
15:23:19 <sclv> another pattern is often to just do this in IO at the top level, and not thread the handle through, but its a bug if the init doesn't get called
15:23:20 <haskell_noob1> can you please elaborate "thread through" part.
15:23:21 <sclv> its less type-safe
15:23:34 <sclv> haskell_noob1: that's what reader does, it passes the argument to each successive thing
15:23:38 <sclv> that's how the bind of the monad works
15:24:44 <sclv> for the less type-safe version see e.g. `withSocketsDo`: http://hackage.haskell.org/package/network-2.7.0.0/docs/Network-Socket-Internal.html#v:withSocketsDo
15:25:00 <haskell_noob1> i see. sclv. I can prevent double initialization by carrying a state (not RWS) but say ReaderT A (StateT  B) IO C..
15:25:04 <sclv> you can also "cheat" and use a top level mutable var to store the initialized state to prevent accidental double initialization
15:25:08 <sclv> that's really hacky
15:25:12 <sclv> but also an idiomm people use
15:25:27 <sclv> haskell_noob1: no i'm describing something slightly different
15:25:37 <sclv> just have ReaderT LibHandle IO
15:25:50 <sclv> but the only way to create a LibHandle is to call invoke on the lib
15:26:22 <haskell_noob1> the inner functions need to call CheckVersion before the actual call (at least that what the macro is doing). How do i model this?
15:26:23 <jle`> haskell_noob1: note that 'monad' here is a red herring.  this has nothing to do with monads, and the handling of opening things is unrelated to any monadic aspect here
15:26:31 <sclv> so you have a runLib :: ReaderT LibHandle IO a -> IO a that calls invoke then passes that libhandle to the runreader function
15:27:02 <sclv> haskell_noob1: your bound inner functions can just call checkversion now
15:27:12 <sclv> maybe you can actually pack the version into your libhandle
15:28:19 <haskell_noob1> i like that. I think thats more idiomatic. because in the c library, this call is copied in each macro. Though i think version and and handle being part of the reader is a bit more elegant.
15:28:35 <aarvar> jle`: "this has nothing to do with monads". I suspect that's true the majority of the time when people say "monad" :)
15:28:43 <jle`> indeed :)
15:29:05 <jle`> trying to think of a solution in terms of 'a monad' is going to usually lead you down a lot of dead ends
15:29:14 <haskell_noob1> well the monad part was part of the library..these calls are within the IO monad. And I wanted to ensure that a function gets called before the actual work is done.
15:29:23 <jle`> haskell_noob1: these calls aren't within the IO monad
15:29:27 <jle`> haskell_noob1: these calls are within IO
15:29:36 <haskell_noob1> whats the difference?
15:29:58 <jle`> haskell_noob1: they have nothing to do with the monadic interface of IO
15:29:59 <aarvar> Monad is an abstraction. IO is one thing which that abstraction happens to apply to
15:30:01 <haskell_noob1> jle` i thought that IO was all part of the IO monad either at the top or the bottom of a stack?
15:30:04 <jle`> they're just ... IO actions
15:30:12 <jle`> haskell_noob1: `IO a` represents an IO action
15:30:14 <haskell_noob1> i see.
15:30:22 <aarvar> Strings have an Order, but you don't say "the String Ord" every time you talk about strings
15:30:34 <jle`> `IO a` has a pretty expressive API that allows you to do a lot of interesting and useful things with them
15:30:41 <jle`> monad is just one aspect of that API
15:30:48 <jle`> but in this case it's an aspect that you aren't utilizing or i relevant at all
15:31:24 <jle`> so it's kind of like saying "i want to write a function to find the sum of two numbers...but I'm only allowed to use `sqrt`"
15:31:41 <jle`> or trying to find a solution to sum two numbers...but being fixated on the irrelevant function 'sqrt'
15:32:46 <haskell_noob1> hmm. so, if i had restated the problem as : i need to ensure that a function gets invoked before anything else happens in computation? is that a better way to put it?
15:33:15 <jle`> yeah, that might be a better way to start your search :)
15:33:22 <aarvar> or you need to ensure that an action gets executed before any other actions happen?
15:34:10 <haskell_noob1> now that the question is there: is Reader still the approach to take, because it does seem to take care of a couple of my requirements.
15:35:16 <jle`> ReaderT is a commonly used pattern for situations like this
15:35:18 <haskell_noob1> the fact that the functions need to be inside the IO monad, are the choices limited to ReaderT atop IO () ?
15:35:44 <jle`> another option you have is just having it be a function, `LibHandle -> IO a`, and requiring that your user provides a valid lib handle somehow
15:35:44 <haskell_noob1> (this is because i need to pass a CString to the library).
15:36:06 <jle`> but this might not be the best because users might think they ar eexpected to re-make a LibHandle multiple times
15:36:21 <jle`> ReaderT LibHandle sort of gives a "suggestion" that you're only supposed to make one once, and use it for your entire computation
15:37:27 <haskell_noob1> Nice. I like this model. I will wrap the handle inside a ReaderT.
15:39:26 <shaylew> is there an ordered map data structure that supports efficient splitting?
15:43:17 <shaylew> (that is to say, where you can split by a key k and get back two maps, one for things inserted before k was and one for things inserted after k was)
15:44:12 <shaylew> Data.Map.Ordered exists but doesn't have that operation, and I'm not sure it's efficiently implementable with its representation
15:45:06 <haskell_noob1> shaylew : partition :: (a -> Bool) -> Map k a -> (Map k a, Map k a)? will this work?
15:50:18 <jle`> shaylew: do you mean a map that remembers the order in which items were added?
15:51:56 <shaylew> yeah. or (equivalently, i hope) a sequence of key-value pairs with an efficient "find the pair for this key" operation
15:53:17 <jle`> maybe you want a priority search queue, which is like an ordered map with two different "keys"
15:53:25 <jle`> two different lookup methods
15:53:57 <jle`> so you basically have (key1,key2,value) with optimized lookup for both keys
15:54:07 <jle`> er, usually one of the keys just have optimal min/max lookups
15:58:18 <jle`> it's a [(p,k,v)] where (1) k's are unique and you can look them up easily (2) p's are non-unique and you can get the min/max easily
16:04:18 <shaylew> i'm not sure that quite works for what i'm doing. the idea of being able to split/append them is so you can drop a suffix (ie split and keep only the things before) or insert things right before a specific item (split there, add the things to the 'before' map, merge that the 'after' map)
16:04:29 <nshepperd> I haven't fully worked it out, but you can sorta add efficient lookups to an unordered sequence by putting it to the leaves of a tree with some representation of the set of keys in the inner nodes
16:06:09 <nshepperd> data Tree k v = Leaf k v | Inner Int (Set k) v
16:06:39 <nshepperd> er
16:07:02 <nshepperd> 'Inner Int (Set k) (Tree k v) (Tree k v)' obv
16:07:55 <nshepperd> the Int counts the number of leaves or similar, so that you can split by index in O(log n)
16:08:20 <nshepperd> while you can recursively search for key k by set membership searches in O(log n^2)
16:09:13 <nshepperd> the constant factors are probably terribad though
16:10:07 <shaylew> nshepperd: oh yeah, that would work. basically finger tree sequence decorated with the set of elements
16:11:36 <nshepperd> yep
16:13:53 <shaylew>  this is for a for-fun implementation of type checker with ordered contexts, so i may just stick to the metathory (... with lists and slow lookup...) until it's working and worry about it later
16:14:02 <shaylew> but i thought i'd ask in case there was something off the shelf
16:19:29 * hackage ftp-client-conduit 0.5.0.1 - Transfer file with FTP and FTPS with Conduit  http://hackage.haskell.org/package/ftp-client-conduit-0.5.0.1 (miscyb)
17:05:22 <zfnmxt> Why is foldl' written with seq instead of deepseq? Can't you still get massive thunks with reduction to only WHNF?
17:06:20 <zfnmxt> I suppose it must be the NFData constraint on deepseq.
17:09:05 <mud> zfnmxt: You don't always want deepseq either
17:09:15 <jmcarthur> deepseq isn't always the fastest or the most appropriate
17:09:56 <zfnmxt> Hm. Can you guys give me an example of something that wouldn't have an NFData instance?
17:09:58 <jmcarthur> deepseq would force a traversal of the whole accumulator every time
17:10:27 <jmcarthur> (except for specific types that I guess could avoid it with a specialized instance)
17:10:36 <zfnmxt> Ah, right. So if the accumulator is made from some complex series of constructors it could get bad, right?
17:10:46 <jmcarthur> yup
17:10:56 <jmcarthur> Also, maybe I actually don't want the whole thing to be strictly evaluated anyway.
17:11:09 <zfnmxt> And re: the specialized instance: maybe you could have a flag that indicates it's in normal form already, preventing the need for traversal?
17:11:56 <jmcarthur> I was thinking that if the entire data structure is known to be strictly evaluated anyway then you can just define it as seq
17:12:25 <zfnmxt> Ah, true!
17:12:35 <zfnmxt> Or, const :P
17:12:45 <zfnmxt> I think?
17:14:20 <jmcarthur> :t seq
17:14:21 <lambdabot> a -> b -> b
17:14:22 <jmcarthur> :t const
17:14:23 <lambdabot> a -> b -> a
17:14:40 <jmcarthur> And it's not just argument order that matters. They have different strictness properties, too.
17:15:10 <zfnmxt> :t flip . seq
17:15:11 <lambdabot> a -> b -> (b -> c) -> c
17:15:13 <jmcarthur> You would need it to be seq, at least, because it can only be in NF if it is in at least WHNF
17:15:23 <zfnmxt> Uhh...ignore that.
17:15:45 <zfnmxt> Right, but don't we "know" that is fully evaluated?
17:15:50 <zfnmxt> If it's fully evaluated seq won't evaluate it any further
17:15:58 <jmcarthur> Not if it has never been evaluated at all.
17:16:21 <jmcarthur> Nothing in Haskell is evaluated by construction. It's evaluated by evaluation.
17:16:33 <zfnmxt> But if something has never been evaluated at all it's not in NF
17:16:35 <jmcarthur> Even strict data types.
17:17:16 <jmcarthur> I mean even an Int isn't evaluated just because it's an Int.
17:17:33 <Welkin> is there a way to configure the colors in haskell-mode?
17:17:37 <jmcarthur> You still have to evaluate it, but once it's evaluated you know it's actually in normal form.
17:17:52 <jmcarthur> Even if you only "tried" to evaluated it to WHNF.
17:18:28 <Welkin> it only uses less than half of my themes colors
17:18:33 <Welkin> and chooses subpar ones ta that
17:18:38 <zfnmxt> let x = 5 :: Int ; :sprint x returns x = 5
17:18:42 <Welkin> and I would like more to be highlighted in distinct colors
17:18:47 <zfnmxt> But maybe that's my confusion
17:19:10 <zfnmxt> Doesn't Haskell not thunk things that consist of a constructor applied to expressions in NF?
17:19:12 <zfnmxt> Or something like that....?
17:19:29 <zfnmxt> x = [1,2,3] :: Int wouldn'
17:19:33 <zfnmxt> Wouldn't be thunked, right**
17:19:44 <jmcarthur> zfnmxt: Try 5+5 or something. A raw constructor is going to be already evaluated, as an optimization, and maybe numeric literals for primitive types are the same way.
17:19:46 <zfnmxt> ::[Int]**
17:20:00 <geekosaur> Welkin, probably with normal customize-faces commands
17:20:11 <Welkin> geekosaur: how does that work?
17:20:12 <geekosaur> which dont interact well with themes in my experience
17:20:22 <zfnmxt> I see.
17:20:30 <Welkin> I've been looking through the haskell-mode source and can't find any place where colors are set
17:20:32 <zfnmxt> So the raw constructor bit is just GHCi optimizations.
17:20:53 <zfnmxt> What exactly is there rule there that GHCi applies?
17:21:03 <jmcarthur> It may not even be an optimization as much as it is "just the way it works", because constructors are primitive.
17:21:03 <zfnmxt> When does it go ahead and just fully evaluate something?
17:21:36 <jmcarthur> What I said earlier about not being evaluated on construction was imprecise.
17:21:39 <geekosaur> actually it doesn;t seem to have its own colors, just the standard font-lock colors
17:22:39 <jmcarthur> Something which is constructed directly may happen to already be evaluated. Something which is computed will not be, without optimizations.
17:23:01 <zfnmxt> Right
17:23:03 <Welkin> geekosaur: so is there a way to customize it in my .emacs?
17:23:11 <Welkin> hook anywhere?
17:23:28 <geekosaur> I use the standard customize-face stuff, which will save to .emacs
17:23:54 <geekosaur> M-x customize-face RET RET
17:25:25 <jmcarthur> It's only *allowed* to evaluate eagerly if doing so doesn't prevent a normally-terminating program from terminating, but it's even less frequently a good idea, and even less frequently than that will the compiler decide to do it. And I don't have a good notion of how the strictness analyzer actually works.
17:26:31 <zfnmxt> That makes sense
17:26:33 <Welkin> geekosaur: this looks promising. Thanks. Will this work without causing any issues with the mode?
17:26:35 <zfnmxt> Eagerly evaluating undefined would surely be bad
17:26:37 <zfnmxt> :)
17:26:39 <jmcarthur> I guess theoretically sometimes the compiler could decide to eagerly evaluate something that makes the program slower, but I haven't really run into that as far as I can remember.
17:27:06 <jmcarthur> Usually it's because the program was written with unnecessary strictness using seq.
17:27:17 <zfnmxt> I think I read in HFFP that GHCi evaluates all expressions consisting exclusively of data constructors
17:27:27 <Welkin> I actually see a lot of "haskell-*-face-*" faces in the display list
17:27:46 <jmcarthur> I think that is true, or perhaps more accurately, inherent to how constructors work in GHC.
17:27:56 <geekosaur> Welkin, I don''t know what you're uing, so can;t say. I have changed several of the font lock faces locally, to make them more visible on my monitor especially when f.lux is active
17:28:08 <jmcarthur> *more precisely
17:28:28 <geekosaur> hm, I may noit actually have haskell mode loaded in the session I checked; it's mostly text files
17:28:54 <zfnmxt> Cool.
17:28:58 <zfnmxt> Thanks for the discussion, jmcarthur  :)
17:33:44 <Welkin> geekosaur: is there a way to set them to the colors supplied by my theme instead of setting the colors directly?
17:34:05 <geekosaur> I have no idea; I don;t use any theme stuff
18:10:07 <kasrasadeghi> hello
18:20:07 <kasra> can anyone help me with an import issue?
18:25:11 <lyxia> kasra: just ask your question
18:26:03 <kasra> lyxia: I'm trying to import another file in a stack project. They're both located in the same directory. There's a module declaration in the file I'm trying to include.
18:26:47 <kasra> https://github.com/kasrasadeghi/cornerstone-haskell/blob/master/test/Test.hs
18:27:01 <kasra> here's the link to the file i'm trying to import in
18:27:13 <kasra> it complains about "import TestUtil" on line 15
18:28:48 <mud> kasra: What's the error? The hs-source-dirs on line 34 in the .cabal file looks odd to me. I don't know what that does, having multiple, especially overlapping with the other component
18:29:38 <kasra> https://paste.gnome.org/pttoqw5bi
18:30:41 <kasra> mud: that part was working in the previous version of the project, so I think it's fine
18:30:56 <kasra> mud: I think it just tells it to look in multiple subdirectories
18:34:01 <mud> Ah
18:34:37 <mud> kasra: Usually one just depends on the library in the test-suite component (and the executable component)
18:34:44 <mud> I'm not really sure how that works
18:35:53 <kasra> how would I make it depend on the test-suite library?
18:37:47 <mud> I don't think I understand the question. I meant the test-suite depends on the library. The library is named cornerstone-haskell, which would go in the build-depends on line 38 in the .cabal file, if that's what you meant
18:39:07 <kasra> do I still say "other-modules" in that case?
18:41:01 <mud> Only the stuff that's in test/ for the test-suite part
18:41:16 <mud> Note that I have no idea if this is going to fix your issue. It's just the only thing I see different than I expect.
18:45:06 <kasra> mud: doing that made it work, so thank you!
18:45:24 <mud> Ah, cool. You're welcome, glad it worked
18:46:54 <kasra> god bless I don't even know what happened
18:47:01 <kasra> I've been trying to fix that for hours
18:49:39 <mud> Building errors suck :-/
20:08:55 <jared-w> building errors are pretty useful; haskell's are unfortunately decently useless unless you're trained in the art of deciphering idiosyncratic incantations
20:09:24 <rotaerk> using haskell trains you in the art of deciphering idiosyncratic incantations
20:09:35 <jared-w> pffh
20:09:53 <jared-w> `foldl (flip (:)) []` is a perfectly cromulent and readable expression /s
20:10:10 <rotaerk> I just completed implementing the Vulkan up through the last step before actually rendering a triangle
20:10:18 <rotaerk> it's almost 1000 lines of code, and still no triangle
20:10:24 <rotaerk> the Vulkan tutorial *
20:10:26 <jared-w> nice!
20:10:34 * jared-w wonders if it needs more cowbell
20:10:42 <LiaoTao> If only we had some sort of nice high-level API for that stuff
20:11:00 <rotaerk> do we?
20:11:10 <jared-w> We have great high level APIs for drawing stuff inefficiently; we have zero for making vulkan things ;)
20:11:28 <jared-w> (unless someone sneakily wrote a package I'm completely unaware of...)
20:12:11 <rotaerk> only thing I'm aware of is lambdacube, but I don't have any idea how good it is
20:12:34 <LiaoTao> I was referring to OpenGL and the irony of doing a 180 on the abstraction stuff after 20 years of moving the other direction
20:12:52 <rotaerk> oh, I see
20:13:04 <LiaoTao> s/moving/moving in/
20:13:08 * boj looks up "cromulent"
20:13:11 <jared-w> eh, I've always thought of the 20 years of "higher abstraction" as really being the wrong kind of abstraction and moving towards "ghost paths in the GPU and magical fast-fast happy paths"
20:14:07 <jared-w> like the fact that no modern 3D AAA game runs well on any GPU until it's shipped over to specialized GPU experts (from what I've heard) should tell volumes of how easy and user-friendly making fast code with our current APIs is...
20:14:10 <rotaerk> as I understand it, one of the problems with the level of abstraction that GL and D3D11- have is that game-specific optimizations end up having to be done at the driver level
20:14:11 <LiaoTao> To be sure, OpenGL wasn't the best solution. I was just being glib.
20:14:43 <rotaerk> whereas vulkan exposes those details so you can do it in your own code
20:14:56 <rotaerk> and really, that seems appropriate; abstractions can be built on top of vulkan
20:15:06 <LiaoTao> The hardware underneath OpenGL has evolved in such a way that it is impossible to keep going
20:15:15 <jared-w> rotaerk: iirc it was that driver optimizations end up working around shitty code in the AAA games because the difference between shitty code and code that hits the GPU fast path is almost nothing with most modern library APIs that are "high level and nice to work with"
20:16:00 <jared-w> Essentially a case of "x can't see y's closed source code and y can't see x's closed source code so neither can get to the root of each other's problem", among other issues
20:16:21 <rotaerk> yeah that might be a more accurate description of the problem
20:16:22 <jared-w> But I could be misremembering the talks I listened to a while ago; it /was/ a while ago and I am deaf... :p
20:16:47 <justaguest> what's the best way to work with 3D in haskell, now that OpenGL is being deprecated on Macs? Does haskell have bindings to the more modern stuff?
20:16:48 <jared-w> (deaf-ish, rather; meh)
20:17:11 <rotaerk> GL is only deprecated on macs; it's still relevant elsewhere
20:17:20 <rotaerk> and if you want to target macs, I think you need to use metal?
20:17:35 <rotaerk> but vulkan has bindings in haskell if you want to use that
20:18:05 <rotaerk> I like: https://hackage.haskell.org/package/vulkan-api
20:18:15 <justaguest> are the vulkan bindings as good as the OpenGL binding? eg. "gl" or "OpenGLRaw"
20:18:23 <LiaoTao> justaguest: After a lot of searching, I found only the raw bindings work sufficiently well
20:18:32 <LiaoTao> All other abstractions are missing tons of stuff
20:18:38 <rotaerk> I don't have a lot of experience with gl, but these bindings seem good and low-level
20:19:13 <rotaerk> https://github.com/Rotaerk/vulkanTest/blob/master/main/src/Main.hs
20:19:48 <rotaerk> my vulkan-tutorial.com -based code so far
20:20:28 <justaguest> awesome, I might skip OpenGL and learn Vulkan instead
20:20:47 <rotaerk> (definitely some abstractable code duplication in there, but not worried about that just now)
20:21:08 <rotaerk> justaguest, bear in mind, that's 1000 lines and I still don't have a triangle :P vulkan is verbose, at least the setup is
20:21:21 <rotaerk> really close to the triangle step though
20:21:37 <justaguest> oh wow...
20:23:17 <rotaerk> also these bindings do a bunch of low-level things I'm not familiar with; reading the implementation is informative
20:23:27 <rotaerk> s/informative/educational/
20:24:32 <LiaoTao> "The Vulkan API is designed around the idea of minimal driver overhead and one of the manifestations of that goal is that there is very limited error checking in the API by default. Even mistakes as simple as setting enumerations to incorrect values or passing null pointers to required parameters are generally not explicitly handled and will simply result in crashes or undefined behavior. "
20:24:35 <LiaoTao> Just like back in the old days
20:25:12 <rotaerk> that's handled by validation layers
20:25:12 <jared-w> LiaoTao: although to be fair, the fact that the GPU hasn't had a 'sane' and standardized "unsafe but fast AF" API to target has been a bit of an annoyance to say the least
20:25:30 <rotaerk> which only run when you're debugging, ideally
20:25:47 <LiaoTao> Indeed
20:25:50 <jared-w> CUDA is ridiculous since it's very specialized, locked down to NVIDIA, etc., openGL isn't nearly fast enough and it's horrible to program in, and every other graphics API is either worse or broken in other ways
20:26:31 <jared-w> I'm excited to see what higher level medium targeted IRs come out for Vulkan if it takes off
20:26:50 <LiaoTao> Yes, those are what makes the switch worth it
20:27:01 <rotaerk> IR?
20:28:10 <jared-w> intermediate representation
20:28:14 <rotaerk> oh
20:28:16 <jared-w> think LLVM vs x86 assembly
20:28:37 <jared-w> LLVM is much nicer to work in and is an IR to x86 (and other assemblies). Hopefully Vulkan becomes the "LLVM of the GPU"
20:29:09 <rotaerk> oh, I guess that's what the shader language that vulkan takes refers to
20:29:11 <rotaerk> SPIR-V
20:29:20 <LiaoTao> rotaerk: Actually, I like this validation layer stuff more than the OpenGL error handling API
20:29:34 <LiaoTao> Which is a horrendous mess that's plain painful to use
20:29:58 <rotaerk> I wonder if it'd be useful to make a haskell, statically typed, eDSL shader language that compile to SPIR-V
20:34:03 <rotaerk> compiles *
20:35:10 <juri_> rotaerk: yes. accelerate could use help.
20:35:49 <juri_> rotaerk: I've been familiarizing myself with accelerate so i can add spir-v nouveau support to it.
20:36:44 <jared-w> either accelerate or repa, whichever one is the one that does the compiling an AST method of generating code
20:37:16 <jared-w> but yeah I'd probably just extend accelerate to generate Vulkan woohoo instead of making you rown eDSL, rotaerk; you get to piggy back off of their optimizations that way :)
20:57:43 <haskell_noob1> a question about ffi that initializes static variables. if i need threadsafety, should these calls be inside something like stm?
21:00:43 <rotaerk> jared-w, oh, I hadn't heard of accelerate
21:00:53 <jared-w> It's pretty badass :)
21:01:09 <jared-w> most of the data haskell work is pretty badass, actually; that's where we got our vector library from
21:01:19 <jared-w> and a lot of our research into stream fusion iirc
21:01:56 <rotaerk> interesting
21:03:05 <rotaerk> oh juri_ was the one who initially mentioned it; thanks
21:05:09 <rotaerk> i'll need to dig into this; so far I don't really see how it's usable as a shader language
21:08:33 <rotaerk> looks like a monster, too
21:17:36 <jared-w> It's an eDSL for compiling to efficient code; think of it more as an eDSL for generating low level and efficient numeric code
21:18:32 <jared-w> It should be decently easy to extend it to generate shader code by extending the eDSL and then allowing it to target Vulkan, I think? It does emphasize numerics and number crunching atm though
21:19:40 <rotaerk> yeah, what I don't get is ... well, I don't really know shader languages very well, but I thought they had all these idiosyncratic aspects to them, like uniforms and positioned input/output variables, and distinctions between types of shaders (fragment, vertex, geometry, etc)
21:20:05 <rotaerk> and I don't see how all of that would be accounted for in an abstract ... array-computation library
21:20:28 <rotaerk> but I'm sure it'll make sense once I get more familiar with both accelerate and shaders
21:21:32 <jared-w> I've always thought of shaders as specialized linear algebra calculations that are all essentially matrices and stencils eventually... I could be wrong? If I am, accelerate might not be the best fit, but its ideas and how it uses designs its eDSL would still be quite fruitful to study for making your own if you want to go down that route
21:22:14 <jared-w> edwardk: do you know anything about shaders for 3D graphics engines? Am I wrong in thinking they're basically just applied matrices and stencils?
21:23:44 <rotaerk> as I understand it, shaders do involve linear algebra computations, but they also involve channeling the data in and out through the right variables, with restrictions on what data is allowed in/out based on the type of the shader
21:27:26 <jared-w> isn't that the stencil bit? :p
21:27:44 <rotaerk> no idea
21:28:00 <rotaerk> not sure what those even are
21:28:31 <jared-w> https://en.wikipedia.org/wiki/Stencil_(numerical_analysis)
21:28:49 <jared-w> (I've only learned the term by osmosis so this'll be a better reference than I)
21:28:54 <rotaerk> k
21:30:08 <jared-w> https://research.ncl.ac.uk/game/mastersdegree/graphicsforgames/scissorsandstencils/Tutorial%205%20-%20Scissors%20and%20Stencils.pdf more about scissors and stencils :)
21:30:37 <rotaerk> so this "stencil buffer" and the numerical analysis "stencil" refer to the same thing?
21:30:48 <rotaerk> or, at least, are rooted in the same thing
21:32:06 <rotaerk> I'm inclined to think not, that a stencil buffer is actually more like a literal physical stencil
21:32:57 <rotaerk> though the numerical analysis stuff is way over my head
21:33:13 <rotaerk> I've never studied the subject
21:35:23 <taumuon> it's my understanding that a shader is a subroutine in a specialized language that uses the limited instruction set on a shader unit (the small CPU's in your GPU)
21:35:48 <rotaerk> basically, yeah
21:57:44 <jared-w> rotaerk: yeah, stencil buffer and "stencils" should be the same thing iirc
21:57:58 <jared-w> Also, never made the connection that there's an actual shader unit for some reason lol
21:58:21 <jared-w> yeah you'd want to extend the code genreation of accelerate to target the shader units if it doesn't already if you're going to use that for shaders then :)
21:58:47 <jared-w> But you should be able to incorporate the rest of accelerate for "free" if you merely extend it to generate shader code as well, if I'm understanding everything else right
21:59:26 <rotaerk> haskell is a rabbit hole of nested rabbit holes...
22:00:24 <tdammers> nah... it's just a convenient system for assembling your own domain-specific rabbit holes
22:03:21 <rotaerk> hehe
22:29:20 <kvothe> I'm trying to write a simple client server architecture using sockets. To test it out, I was trying to send a file from the client and receive it on the server side. This works for files of size around 1mb
22:29:48 <kvothe> If I try increasing the size of the file to send, I am not receiving the full file on the receiver
22:29:57 <kvothe> https://lpaste.net/359415000906858496
22:30:04 <kvothe> How can I do better?
22:37:24 <tdammers> Data.ByteString.Lazy.readFile is, as the name suggests, lazy
22:38:29 <tdammers> unfortunately that means the IO it does is also lazy - by the time it "returns", only the first buffer has been read from the file, and under "normal" circumstances the handle is kept open to read the rest of the file as the bytestring is evaluated
22:39:22 <tdammers> but "normal" circumstances are easily broken; the typical situation is passing the file contents into a context in which the file handle doesn't exist or is closed
22:39:28 <tdammers> like another thread
22:39:43 <glguy> No, passing a Handle to another thread doesn't create an issue with lazy readFile
22:39:59 <tdammers> hmm
22:40:08 <tdammers> I've run into that though
22:40:18 <glguy> That would have been something else then
22:40:18 <tdammers> although the thread itself may not have been the problem
22:42:55 <kvothe> should it work fine if I do all the operations in strict bytestrings?
22:43:06 <glguy> It would work just the same
22:43:29 <tdammers> oh, or maybe the explanation is much simpler
22:43:52 <pavonia> What would be a proper solution to keep the handle open?
22:45:23 <tdammers> pavonia: use strict IO, explicitly read chunks, and explicitly manage the file handle
22:45:32 <glguy> kvothe: it looks like you're assuming that recv returns as many bytes as you asked for
22:46:00 <glguy> The Handle will stay open just fine, using manual open and reads is not necessary
22:47:02 <glguy> kvothe: But that's not the behavior of recv, the number you provide is the maximum number of bytes you'll get back
22:47:07 <kvothe> glguy: Yes I am. I am preappending the length of the msg with every msg I'm sending
22:47:30 <glguy> kvothe: OK, so you'll need to check the result of recv and then call it repeatedly until you get all the bytes you wanted
22:49:32 <tdammers> or maybe it's even simpler than that
22:49:33 <tdammers> https://lpaste.net/8096286658908913664
22:49:59 <tdammers> this is a simplified version of the structure of your program
22:49:59 * hackage sensu-run 0.5.0.2 - A tool to send command execution results to Sensu  http://hackage.haskell.org/package/sensu-run-0.5.0.2 (MitsutoshiAoe)
22:50:02 <glguy> I'd also recommend explicitly closing the socket so that it ensures that the data finishes transmitting
22:50:25 <dminuoso> Is there some general form to lift some `(R -> IO a) -> IO a` into a monad transformer stack?
22:50:42 <glguy> Yes, you should *also* ensure that main doesn't exist before you're done. The program will terminate when main finishes
22:50:50 <kvothe> glguy: Is there a better way? The first 2 bytes of every msg is the length of the the message I sent. I consequently want to read the full length of the msg
22:51:20 <glguy> kvothe: You need to implement logic to repeatedly call recv until you get all the bytes for that frame
22:51:46 <glguy> You probably won't notice the different when going through the loopback device
22:52:29 * hackage influxdb 1.6.0.3 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-1.6.0.3 (MitsutoshiAoe)
22:52:36 <glguy> https://hackage.haskell.org/package/network-2.7.0.0/docs/Network-Socket-ByteString.html#v:recv
22:52:42 <glguy> "This function may return fewer bytes than specified."
22:52:57 <jared-w> glguy: would the untilM function be nice for that? (from the monad loops package)
22:53:37 <glguy> I think that'd make a mess. I'd recommend just writing the recursive function instead of using an IORef with untilM to accumulate all the chunks
22:53:57 <jared-w> ah right, forgot untilM woul dneed the IORef and all that extra stuff
22:54:18 <jared-w> Also, it probably would be worth it extracting all the usage of recv into a function that does the logic of "figure out how large the message is, then call recv repeatedly until I get the entire message"
22:54:28 <jared-w> then your actual logic of the rest of the program would stay the same
22:54:51 <glguy> I agree; naming a "recvAll" would be a good idea
22:55:45 <jared-w> honestly, I'm not sure why there isn't a recvN or something in that library. "Given a size of n bytes, keep calling recv until that much data is returned" seems like it'd be generally useful
22:56:25 <mac10688> lol damn jared you still going strong
22:56:32 <mac10688> I haven't been on here for a few months
22:57:11 <jared-w> oh hey mac10688 what's up; yeah I don't hate haskell yet if that's what you're asking :p
23:18:06 * pdxleif wishes there was a "recursive" option  for "ghc-pkg unregister"
23:33:17 <tdammers> pdxleif: there is: rm ~/.ghc :X
23:37:27 <dminuoso> TIL. This is allowed: a,b,c::Int
23:37:45 <Myrl-saki> I defined factorial as
23:37:47 <Myrl-saki> fac 0 = 1; fac n = n * fac (n - 1)
23:37:50 <Myrl-saki> ... I regressed.
23:38:16 <tdammers> dminuoso: the GHC codebase itself has quite a few of those, which I find somewhat annoying
23:39:54 <dminuoso> tdammers: I suppose it threw me off my rhythm because I wasn't used to it heh.
23:40:18 <MarcelineVQ> dminuoso: you can even do it in records
23:40:45 <MarcelineVQ> er gadts I mean, including records
23:41:03 <dminuoso> MarcelineVQ: How would that look in GADTs? :o
23:41:15 <Myrl-saki> I mean, some people write \forall x, y \in S.
23:42:08 <pdxleif> In Idris you can define function args with (x, y, z : Int) -> ..., instead of Int -> Int -> Int -> ...
23:43:52 <liste> pdxleif: does that result in a curried or uncurried function?
23:44:19 <Myrl-saki> pdxleif: That looks like a consequence of dependent types.
23:44:24 <Myrl-saki> Idk.
23:44:37 <MarcelineVQ> dminuoso:   data T a where    T1,T2 :: b -> T b
23:45:26 <MarcelineVQ> some examples stashed away in https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#declaring-data-types-with-explicit-constructor-signatures
23:46:25 <pdxleif> liste: uncurried. It's just short for (x : Int) -> (y : Int) -> (z : Int) -> ...
23:46:27 <MarcelineVQ> Myrl-saki: it's just a different notation
23:46:56 <pdxleif> which has no effect unless the names are used somehow to the right; otherwise it's just the same as Int -> Int -> Int -> ...
23:47:01 <Myrl-saki> MarcelineVQ: It's specifically syntactic sugar, or?
23:48:05 <pdxleif> That the arguments can have names at the type level is a DT thing, but the thing with commas isn't particularly DT - just syntax sugar.
23:48:42 <Myrl-saki> pdxleif: Right. If I have another type ... -> Foo x y z, then the 3 arguments can be implied, right?
23:49:15 <Myrl-saki> Or is there a special notation for implied arguments? Forgot, been a year or two since I touched it. :/
23:50:30 <pdxleif> There's implicit arguements - unbound lowercase variables in a type sig become implicit "foralls" sort of - and they have to be implicitly resolvable
23:50:46 <Myrl-saki> pdxleif: Oh, I think I was thinking of {}
23:50:50 <Myrl-saki> index : {a:Type} -> {n:Nat} -> Fin n -> Vect n a -> a
23:50:55 <Myrl-saki> pdxleif:
23:51:04 <Myrl-saki> According to this. http://docs.idris-lang.org/en/latest/tutorial/miscellany.html
23:51:58 <dminuoso> Myrl-saki: Does {} turn them into implicit arguments in the same way that forall introduces them into (usually) inferrable argumens?
23:52:23 <Myrl-saki> dminuoso: I honestly have no idea. Installing Idris was a bit difficult back when I wanted to try it out.
23:54:46 <pdxleif> Myrl-saki: Yeah, "Fin len -> Vect len elem -> elem" is equivalent to "{elem : Type} -> {len : Nat} -> Fin len -> Vet len elem -> elem" thanks to that "Auto implicit rule" on that page.
23:55:23 <pdxleif> Just you you can write type sigs that look like Haskell, e.g. "a -> a", and not force you to write e.g. "{a : Type} -> (x : a) -> a"
23:55:36 <pdxleif> err, "{a : Type} -> a -> a"
23:55:49 <Myrl-saki> Write.
23:55:51 <Myrl-saki> Right*
23:56:11 <Myrl-saki> Ugh. And I thought sleeping would help me with my typos.
23:57:16 <Myrl-saki> Oh cool, Idris has uniqueness types.
23:57:25 <pdxleif> dminuoso: I think of "{a : Type} ->" similar to "forall a." in Haskell
23:57:41 <MarcelineVQ> it also has linear types, though they're somewhat limited currently iirc
23:58:03 <pdxleif> But in Idris it's Pi, not a forall - not limited to types, so a little different wrt parametricity
23:58:42 <dminuoso> pdxleif: So I guess the equivalent of a Rank2Type would be something like `Thing -> ( { a : Type } -> F a -> G ) -> G` ?
23:58:54 <pdxleif> MarcelineVQ: This? http://docs.idris-lang.org/en/latest/reference/uniqueness-types.html
23:59:00 <MarcelineVQ> no
23:59:39 <MarcelineVQ> there's an extention you enable called LinearTypes
23:59:59 <MarcelineVQ> some examples here https://github.com/clayrat/idris-linear  I've not seen these before so ymmv
