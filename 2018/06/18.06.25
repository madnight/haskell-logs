00:45:08 <c50a326> filter (\xs -> length xs > n) (map chain' [1..100])  -- why do I have to use a lambda here instead of partial application
00:45:20 <c50a326> is there not a way to partially apply > and length to build a predicate?
00:45:44 <Ariakenom> @pl  (\xs -> length xs > n)
00:45:44 <lambdabot> (> n) . length
00:46:01 <c50a326> any way without using . ?
00:46:46 <Ariakenom> Interestingly, there is always a way to remove all lambdas.
00:47:17 <cocreature> it might be worth pointing out that there is nothing wrong with using a lambda
00:48:11 <epta> c50a326: let f xs = length xs > n in filter f (map chain' [1..100])
00:49:24 <Ariakenom> c50a326: I don't think there is a simpler expression without (.)
00:49:25 <Axman6> c50a326: length xs > n is an antipattern which can be dangerous if you don't know where the list came from - if that list is infinite your code will never terminate
00:49:55 <Axman6> it's annoying we don't really need to have a good save function for doing that though
00:50:28 <Axman6> > genericLength [1..] > (0 :: Nat)
00:50:31 <lambdabot>  error:
00:50:31 <lambdabot>      Not in scope: type constructor or class ‘Nat’
00:50:36 <Axman6> > genericLength [1..] > (0 :: Natural)
00:50:39 <lambdabot>  True
00:51:45 <Axman6> > length [1..] > 0
00:51:51 <lambdabot>  mueval-core: Time limit exceeded
00:52:31 <cocreature> huh is that the Natural from GHC.Natural?
00:53:14 <fendor_> good morning, i want to use the cereal binary serialization library which lets you derive an serialization if the datatype derives Generic. However, i want to send Text, which does not derive Generic
00:53:26 <fendor_> should i derive it myself or do I have to change the protocol?
00:53:34 <Ariakenom> > length (take 10 [1..]) <= 10
00:53:36 <lambdabot>  True
00:53:49 <Ariakenom> > length (take 10 [1..]) < 10
00:53:51 <lambdabot>  False
01:01:06 <c50a326> oh a fold is like what they call a reduce/reducer in softer fp's??
01:01:23 <Ariakenom> yes c50a326
01:02:29 <Ariakenom> Not sure about the term softer fp though :p
01:03:09 <tdammers> Ariakenom: "soft fp" - "we program with procedures, call them functions, and make a bit of an effort to avoid unnecessary mutable state"
01:06:35 <Axman6> soft fp = "We have map and reduce, see, we're an FP language too!"
01:08:03 <dminuoso> real soft fp = "We have some highly unergonomic lambdas to shut up all the hipster FP boys, but dont use it because callstack"
01:08:41 <Axman6> fendor_: IMO, using Generic for serialisation is generally a bad idea unless you are really careful, and you're only ever going to deserialise that data in exactly that version of your app
01:09:08 <Axman6> cocreature: I don't believe so
01:09:15 <Axman6> @src Naturtal
01:09:15 <lambdabot> Source not found. I've seen penguins that can type better than that.
01:09:20 <Axman6> @src Natural
01:09:20 <lambdabot> Source not found. :(
01:09:22 <Axman6> :(
01:10:05 <cocreature> Axman6: ah ok, I was just confused because afaik Natural is a gmp binding rather than peano naturals so I was confused how your example works
01:10:13 <Axman6> yeah
01:16:36 <dminuoso> Okay.. so Im slowly getting a feeling for lens. It seems like raw lenses are not that interesting..
01:16:41 <dminuoso> partsOf is really cool =)
01:19:03 <fendor_> Axman6, why is it a bad idea? is it better to write always the same boilerplate? 0.o
01:20:41 <kuribas> dminuoso: the interesting part of a lens is that traverseOf == id
01:24:37 <dminuoso> kuribas: Im currently trying to wrap my head around Bazaar and similar things, this is starting to get really crazy. =)
01:26:21 <dminuoso> kuribas: But it makes sense since a lens is just a traversal in disguise.
01:26:21 <kuribas> dminuoso: so advanced stuff :)
01:32:43 <c50a326> is there a way to make pattern matching go from the right? I mean like (x:xs) is there a way to have (xs:x)
01:33:01 <cocreature> c50a326: no
01:33:12 <cocreature> c50a326: also that seems like a really weird request. do you have some underlying goal here?
01:33:15 <c50a326> I know about x:y:[] and things like that
01:33:21 <cocreature> you can write a pattern synonym but that will have a different name
01:33:26 <c50a326> cocreature: nah was just curious, I am seeing these foldl foldr functions
01:33:42 <c50a326> so seems like it would make sense to have as much functionality be able to go from both directions as possible
01:34:05 <cocreature> I have no idea how that would help with foldl and foldr
01:34:16 <c50a326> does (x:xs) have an underlying implementation?
01:34:24 <c50a326> I can implement pattern matching myself?
01:34:38 <c50a326> is it a function? :S it's not is it?
01:34:49 <cocreature> by default you can’t. if you enable PatternSynonyms you can write custom patterns
01:34:59 <c50a326> oic
01:34:59 * hackage gauge 0.2.2 - small framework for performance measurement and analysis  http://hackage.haskell.org/package/gauge-0.2.2 (VincentHanquez)
01:35:20 <c50a326> hackage: what?
01:35:23 <cocreature> (:) is a constructor. it can be used in pattern matches to deconstruct values and it can be used as a function to constuct functions
01:39:40 <zincy> How do I wrap a function call in a timeout which awaits a websocket msg?
01:40:04 <cocreature> :t System.Timeout.timeout
01:40:05 <lambdabot> Int -> IO a -> IO (Maybe a)
01:40:36 <zincy> Thanks Ill try that
02:06:12 <dminuoso> c50a326: data [] a = [] | a : [a]
02:06:34 <jle`> c50a326: yeah, pattern synonyms are basically a way to get "abstract patterns", and matching on the init-and-last is a common example of a pattern synonym
02:07:16 <dminuoso> c50a326: You could alternative just define it as: `data List a = Nil | Cons a (List a)`, and then you pattern match against (Cons x xs). Lists are not really special here. :)
02:07:30 <jle`> c50a326: are you familiar with how to define your own data types?
02:08:17 <c50a326> no I'm still on HOF of LYAH
02:08:25 <c50a326> and now I have a different question about type signatures, sorry: https://lpaste.net/6342432292526358528
02:08:42 <c50a326> my type sig gives some error, ghci's type sig works of course
02:09:06 <cocreature> what do you expect the "Foldable a" constraint in your type signature to do?
02:09:43 <zincy> Its not just lists that are foldable remember that
02:09:46 <Ariakenom> About timeout. It would make sense to have a Time type of some opaque resolution and implementation, right? But then you shouldn't really do operations on it, so no class really fits. Maybe it should just accept Rational instead
02:09:52 <c50a326> just to make it so that I can use foldl foldr etc on a
02:10:01 <dminuoso> c50a326: `Foldable t` constrains *t*. Basically you either pick a monomorphized version: `[a] -> [a]` or you pick `Foldable t => t a -> [a]`. The second form admits more types than just lists.
02:10:32 <jle`> c50a326: yeah, be careful, LYAH is like 8 years out of date
02:10:44 <jle`> the type of foldr, foldl, etc. are now different than they were when LYAH was written
02:11:00 <Ariakenom> An example of t is: t=[] and t a = [a]
02:11:02 <jle`> a lot has changed in the language since it was written
02:11:31 <c50a326> why dont you guys update it
02:11:35 <c50a326> it's pretty awesome otherwise
02:11:38 <dminuoso> c50a326: reverse' :: Foldable t => t a -> [a]  reads: For any choice of types `t` and `a`, for which `t` has an instance Foldable`, reverse has the type t a -> [a]`
02:11:43 <jle`> c50a326: the author has been unreachable
02:11:49 <jle`> after they published it, they disappeared
02:11:53 <jle`> it's kind of infamous actually
02:11:59 <jle`> they just...vanished into the wind
02:12:01 <c50a326> also it would be nice if there was spoilers-like html on some of the examples so that users can practice without seeing the answers without having to scroll very slowly and carefully
02:12:05 <jle`> and now we're stuck with LYAH
02:12:27 <jle`> or well, we have better options than LYAH now.  i mean that, we are stuck with people asking questions about LYAH, not knowing it is out of date and no longer the best option :)
02:12:38 <jle`> it is still like #1 in google searches i think for 'learn haskell'
02:13:05 <jle`> and it will probably be so until we find a way to take over the domain from the missing author and leave notes that it is out of date :'(
02:13:20 <zincy> On the timeout front I am not sure how to to approach the problem. Which IO computation should I be wrapping if I am setting a timeout for a websocket msg to arrive.
02:13:41 <dminuoso> jle`: https://blog.cofound.it/getting-started-with-ethereum-development-a30b19313bc8 looks like they do live!
02:13:52 <jle`> :O
02:14:14 <cocreature> at least someone with the same name :)
02:14:35 <[exa]> btw is there no way to send a pull request to LYAH authors?
02:14:48 <Ariakenom> zincy: The receive?
02:14:51 <halogenandtoast> The answer is probably that this doesn't exist, but if I want to use a different lts aside from the latest for stack, is there a way to use an lts version appropriate stack template, or do I need to manually find the right template
02:14:54 <jle`> [exa]: it's a single author, and we have repeatedly tried contacting them for many years but with no response
02:15:02 <[exa]> :'(
02:15:15 <[exa]> but... the pictures... :D
02:15:18 <jle`> at least that's how the legends go
02:15:40 <jle`> such is life in the world of FOSS
02:15:54 <dminuoso> Decades from now stories will be told from the brave men at #haskell who tried to find the lost druids of LYAH..
02:16:06 <dminuoso> With singing and dancing.
02:16:13 * [exa] doing whois
02:16:15 <[exa]> Admin Name: GDPR Masked
02:16:24 <[exa]> OK nice.
02:16:27 <jle`> it's okay though, i don't really feel like it's too much of a loss, because in eight years we now have alternatives that are as good or better
02:16:35 <ammar2> but LYAH has all the cute pictures
02:16:40 <jle`> but that doesn't stop LYAH from being so high in google search
02:16:42 <ammar2> (still)
02:16:44 <dminuoso> jle`: says you. What if LYAH will still be top #1 in 8 years?
02:17:00 <jle`> i mean, in the past eight years we have had time to write better things
02:17:04 <jle`> but LYAH still stays #1
02:17:06 <systemfault> It's "free".
02:17:08 <jle`> it must be the pictures
02:17:12 <dminuoso> We could bribe or kidnap someone from google and force them to change the page rankings..
02:17:14 <systemfault> That's why it's still on top.
02:17:26 <jle`> there are a lot of free alternatives as well! :O
02:17:30 <ammar2> the picture bit was a joke but LYAH is very very approachable as far as programming books go
02:17:31 <halogenandtoast> Oh we're talking about LYAH again. The answer is to write something that has curb side appeal to non-Haskellers
02:17:44 <halogenandtoast> Most Haskellers write for other Haskellers
02:17:47 <c50a326> jle`: what's better? the only free/open things I found are cis194 which seems very very good actually, but this also recommends LYAH and real world haskell.
02:17:56 <jle`> @where learnhaskell
02:17:57 <lambdabot> https://github.com/bitemyapp/learnhaskell
02:18:03 <c50a326> yeah I saw that
02:18:08 <c50a326> that's where I got cis194 from
02:18:13 <jle`> i don't mean that LYAH is all bad. LYAH was my first exposure to haskell
02:18:17 <c50a326> but looking at those things, I came back to LYAH
02:18:25 <jle`> but i'm not sure if it really helped me learn how to write haskell at all
02:18:27 <c50a326> I don't think it's that outdated, everything I've done so far has worked
02:18:41 <dminuoso> c50a326: What programming background do you have?
02:18:52 <zincy> jle': Agreed
02:18:52 <quicksilver> this is probably BONUS : https://blog.cofound.it/@miran.lipovaca
02:18:56 <halogenandtoast> LYAH made it impossible for me to learn Haskell because all of the examples are random nonsense.
02:18:57 <c50a326> practical amateur
02:18:58 <quicksilver> and he posted somethign this year
02:19:00 <jle`> c50a326: well, you just reached chapter 6, and there's something there :)
02:19:00 <quicksilver> but who knows.
02:19:05 <c50a326> like basic c, java, python, perl
02:19:17 <jle`> it was good at like, showing me cool things that people can do in haskell
02:19:18 <c50a326> but i was also mostly sysadmin/devops kind of dude
02:19:23 <c50a326> I think lyah is great for people like me
02:19:29 <jle`> but as for writing haskell, i didn't really learn how to write haskell until i started writing my own projects
02:19:43 <jle`> the book did nothing to help me learn how to write haskell, i had to learn on my own after i finished reading it
02:19:45 <systemfault> LYAH shows you features of Haskell... but at the end of the book, you still don't know how to write anything with it because the book doesn't show how to use those features in a coherent way
02:19:48 <jle`> armed with "this is so cool"
02:19:52 <dminuoso> jle`: Books dont teach programming. Practice does. =P
02:19:58 <c50a326> jle`: that's the same with any language tho isn't it
02:20:12 <jle`> c50a326: a good course will teach you how to write the language over the process of the course
02:20:14 <halogenandtoast> As an aside, I'm still starting up my HaskellCasts website, which I hope will be a good launching ground for aspiring Haskellers
02:20:16 <c50a326> I did check out clojure and a lot of brave clojure before
02:20:22 <c50a326> I much prefer LYAH to brave clojure
02:20:27 <cocreature> lyah is really good at getting people exited about Haskell
02:20:30 <halogenandtoast> I'm still working on the first episode but hope to have it recorded by the end of the month
02:20:32 <jle`> c50a326: imagine taking an Intro to CS class that doesn't teach you how to write any code, until after the final
02:20:39 <c50a326> I like re-implementing all the main fp functions, I find that really powerful
02:20:40 <ammar2> did you just read LYAH or were you actually following and writing the examples by hand?
02:20:53 <c50a326> whereas in brave clojure it was silly things like stuff to do with zombies and stuff, trying to make it "fun"
02:20:59 <ammar2> if you do the latter you definitely learn to write code a little
02:21:00 <c50a326> where really just re-implementing reduce or whatever is better
02:21:08 <ammar2> but obviously the book doesn't say to do that or anything
02:21:26 <jle`> the exercises you can get out of the book are very slim
02:21:32 <zincy> Ariakenom: Im just confused at the present moment as I don't want my msg handler to know the details of game state which it would have to if it was to know when the timeout was applicable.
02:21:35 <jle`> you'll have to dig into other places and find good exercises
02:21:39 <jle`> and that's what i mean
02:21:44 <dminuoso> c50a326: what is really interesting is to see how base implementations frequently differe because of subtleties - strictness, RULES or other GHC quirks.
02:21:50 <jle`> LYAH is good at showing you cool things, but to actually learn how to write the code, you have to look elsewhere
02:21:50 <halogenandtoast> Hutton's Programming in Haskell has much better excercises
02:22:00 <halogenandtoast> *exercise
02:22:01 <jle`> a good course will teach you how to write over the course of the course
02:22:14 <jle`> not just show you cool things and expect you to learn how to write on your own
02:22:17 <zincy> If I did it again I would skim read Hutton and then start coding.
02:22:43 <jle`> LYAH is definitely a fun book, and it does a lot to show you the joy and instill excitement
02:22:49 <jle`> as c50a326 and cocreature have pointed out
02:23:02 <halogenandtoast> I actually have two copies of LYAH on my shelf
02:23:14 <halogenandtoast> one in English and one in Japanese
02:23:20 <zincy> Doing a project and asking on here when you get stuck is a great way to progress.
02:23:35 <c50a326> yeah once I'm done with LYAH I plan to do all the homeworks for cis194
02:23:53 <c50a326> though actually as soon as I've covered monads/io I might just try doing the actual project I want to do
02:24:02 <jle`> hm, we should at least find a way to update this http://learnyouahaskell.com/errata
02:24:10 <merijn> c50a326: What project is that? :)
02:24:26 <merijn> jle`: BONUS has mostly disappeared from the web, afaik, so that might be hard
02:24:39 <zincy> I would personally recommend you use monads quickly without worrying if you understand them.
02:24:47 <c50a326> merijn: basically just like, maybe you heard of sites like tinychat.com - I just want to make a free/open "federable" version that people can easily deploy
02:24:54 <zincy> This weird monad anxiety has been perpetuated across the internet.
02:24:56 <c50a326> merijn: so like mastodon, but for video chatrooms with strangers
02:25:51 <jle`> i actually think Real World Haskell shouldn't be too bad a source of exercises for learning Haskell
02:25:55 <jle`> and at least they have these https://stackoverflow.com/questions/23727768/which-parts-of-real-world-haskell-are-now-obsolete-or-considered-bad-practice/23733494#23733494
02:25:57 <c50a326> so I decided to try elm and started writing a front end for basic text chat, and then realized I needed to think about backend, so was like why not just use haskell
02:26:05 <jle`> so you know exactly what is out of date
02:26:16 <zincy> Elm the gateway drug
02:26:22 <halogenandtoast> c50a326: I've actually had a hard time hooking up backends to Haskell apps for some reason
02:26:35 <halogenandtoast> Haskell-like frontends to backends
02:26:43 <halogenandtoast> mainly because there's no hand holding
02:27:00 * hackage vfr-waypoints 0.1.0.0 - VFR waypoints, as published in the AIP (ERSA)  http://hackage.haskell.org/package/vfr-waypoints-0.1.0.0 (qfpl)
02:27:11 <Ariakenom> As a first project just make a distributed consensus algorithm where you encode the invariants of the protocol and network connections in the types
02:27:34 <halogenandtoast> Ariakenom: Why not make a flux capicitor?
02:27:47 <zincy> How do you encode invariants in types?
02:27:56 <jle`> zincy: that's where the fun begins :)
02:27:57 <Ariakenom> Also good, hardware descriptive language ... at type level
02:28:10 <jle`> or well, where the fun intensifies
02:28:44 <zincy> Is that type level programming?
02:28:59 <jle`> not necessarily
02:29:08 <zincy> So how do I find out about it
02:29:19 <jle`> at the simplest level it's just constructing your types to make illegal states and transitions unrepresentable
02:29:22 <merijn> Ariakenom: Are you familiar with Clash?
02:29:30 <merijn> Ariakenom: Granted, that's not at the type level
02:29:31 <Ariakenom> merijn: no
02:29:41 <jle`> for example, let's say you had a list of items, but you want to express that your list can only ever hold 0 or 1 items
02:30:05 <jle`> instead of just using a list, make a new data type that works the same, but only can represent lists with 0 or 1 items
02:30:08 <merijn> Ariakenom: Clash is a project to compile Haskell to hardware (i.e., VHDL and verilog)
02:30:10 <jle`> data Maybe a = Nothing | Just a
02:30:20 <jle`> and use that new type, instead of list
02:30:29 <merijn> Ariakenom: http://www.clash-lang.org/
02:30:32 <Ariakenom> merijn: I've heard of such a project. Is the name new?
02:30:45 <jle`> a `Maybe a` is a [a] with an invariant that it will hold, at maximum, 1 item
02:31:13 <zincy> So we need to wrap all our types in Maybe?
02:31:14 <merijn> Ariakenom: Naah, it's a couple of years old :)
02:31:24 <jle`> zincy: this is a specific example
02:31:31 <zincy> ah ok
02:31:33 <jle`> zincy: of encoding the property "zero or one" in your list
02:31:37 <jle`> zincy: there are other properties you can encode
02:31:56 <jle`> using `Maybe a` is a way to encode "zero or one item [a]"
02:32:09 <jle`> so if you do need a list where you want to enforce an invariant that the list will contain, at maximum, 1 item
02:32:13 <jle`> then use Maybe a, instead of [a] :)
02:32:17 <zincy> :)
02:32:33 <jle`> a good example of this in practice is the implementation of parser combinators
02:32:48 <jle`> most people start out using [a] to represent possibilities of parses
02:32:58 <jle`> but then they realize that in the end, they only care about at most one possibility
02:33:00 <jle`> so they use 'Maybe a' instead
02:33:13 <jle`> here we pick our type to encode invariants that we want to express
02:33:26 <zincy> What if I have a game type data Game = Game { started :: Bool, board :: [Card] }
02:33:50 <jle`> the type-level programming happens when we want to treat our invariants as first-class values
02:33:50 <zincy> How would I encode the invariant that when started is false length of board should be 0
02:34:20 <ammar2> you could have a game = StartedGame | NotStartedGame
02:34:23 <halogenandtoast> ^^
02:34:32 <ammar2> and implicitly encode that boolean you have with the two different constructors
02:34:56 <c50a326> what's the pattern for operating on "every nth element"? let i = 0 ... if i % n == 0 ...? that seems super imperative...
02:35:06 <jle`> zincy: can you have a board of length 0 if the game has started?
02:35:13 <c50a326> oh I'd also need i++ lol
02:35:16 <zincy> those data constructors dont take any arguments?
02:35:20 <c50a326> do I need to reach for indexOf
02:35:23 <jle`> c50a326: you can zipWith and [1..]
02:35:34 <halogenandtoast> zincy: one of them does, but it was left out for brevity
02:35:35 <ammar2> nah you gotta fill those out
02:35:42 <zincy> jle: lets say no :)
02:36:03 <jle`> > zipWith (\i x -> if i % 3 == 0 then 100 else x) [1..] [6,2,3,4,7,12,3,4,1,2,3,5,3]
02:36:06 <lambdabot>  [6,2,3,4,7,12,3,4,1,2,3,5,3]
02:36:06 <zincy> thanks
02:36:12 <jle`> oops, used %
02:36:17 <jle`> > zipWith (\i x -> if i `mod` 3 == 0 then 100 else x) [1..] [6,2,3,4,7,12,3,4,1,2,3,5,3]
02:36:19 <lambdabot>  [6,2,100,4,7,100,3,4,100,2,3,100,3]
02:36:38 <c50a326> what's wrong with %
02:36:45 <zincy> So is ammar2's example a case where invariants are first class values?
02:36:46 <jle`> zincy: then you can just have data Game = Game { board :: [Card] }
02:36:54 <halogenandtoast> :t (%)
02:36:55 <lambdabot> Integral a => a -> a -> Ratio a
02:36:59 <halogenandtoast> :t mod
02:37:00 <Ariakenom> jle`: Did you just 1-index that list!?
02:37:00 <jle`> c50a326: remember that operators in Haskell are all user-defined
02:37:00 <lambdabot> Integral a => a -> a -> a
02:37:01 <zincy> ah ok
02:37:20 <jle`> zincy: and "started (Game x) = not (null x)" ?
02:37:36 <jle`> c50a326: so the user-defined operator (%) doesn't do mod-ing
02:37:36 <zincy> So is it best practise to encode all useful invariants within types?
02:37:48 <c50a326> oh yeah the results were different
02:38:01 <jle`> c50a326: (%) is a user-defined operator and it doesn't do mod
02:38:10 <jle`> it's a little unconventional, but remember, Haskell is an old language, heh
02:38:14 <c50a326> what do you mean "user-defined" ?
02:38:16 <jle`> it is older than many conventions
02:38:19 <c50a326> I sure didn't define it
02:38:26 <jle`> c50a326: operators are defined in libraries, within the language
02:38:26 <merijn> user-defined is an odd choice
02:38:29 <jle`> they aren't built-into the language
02:38:39 <jle`> that might have been a bad word choice :)
02:38:43 <zincy> As In if I just went about my life only using a simple Game type with no expression of invariants although they were significant would that be less maintainable?
02:38:48 <merijn> All operators are defined in libraries
02:38:50 <jle`> zincy: the general principle is that you should construct your types so that illegal states are not representable
02:39:03 <zincy> :)
02:39:05 <jle`> c50a326: yes, my point is that there are no built-in operators in Haskell
02:39:13 <merijn> c50a326: He's trying to say that (%) as defined in Prelude is *not* modulo
02:39:29 <jle`> zincy: sometimes this can make things too complicated, so it's not a hard and fast rule.  but it's a good general principle to start out with
02:39:54 <jle`> zincy: the goal is that if you ever have a value of type 'Game', it should be a legal value
02:40:17 <Ariakenom> files or example. You can encode that you only read from opened files, but it is usually not done.
02:40:39 <Ariakenom> as an example of where you don't encode invariants
02:41:16 <jle`> the alternative is to make your data type an abstract one, where the allowed API is verified by the author of the API to always respect the invariants
02:41:42 <jle`> this can be more manageable, but in that case, you have to trust the author of the API.  or, you have to trust yourself, if you are writing your own data type
02:41:55 <jle`> the advantage of having your types encode your invariants is that you don't have to trust anyone
02:42:00 <jle`> the compiler enforces the invariants automatically
02:44:14 <Ariakenom> But we do still build some tools to help with correct usage of files. like the with* functions
02:44:35 <jle`> yeah, in practice we work with a blend of both strategies
02:44:41 <Ariakenom> :t withFile
02:44:42 <zincy> cool :)
02:44:42 <lambdabot> error:
02:44:42 <lambdabot>     • Variable not in scope: withFile
02:44:42 <lambdabot>     • Perhaps you meant one of these:
02:45:03 <Ariakenom> :t System.IO.withFile
02:45:04 <lambdabot> FilePath -> GHC.IO.IOMode.IOMode -> (GHC.IO.Handle.Types.Handle -> IO r) -> IO r
02:45:44 <jle`> and I think Haskell is really good at facilitating the most of the reasonable range of "safety"
02:46:11 <Ariakenom> jle`: I feel like everyone feels that about their langauge :p
02:46:45 <jle`> that's fair :p
02:46:58 <jle`> although you do have some people who think that your compiler should not help you at all in ensuring safety
02:47:18 <zincy> So here is a snippet of the code where I am trying to run a timeout that awaits a user's socket msg  https://lpaste.net/265146159591325696
02:47:31 <c50a326> ah what's the opposite of the read function
02:47:38 <c50a326> [Int] -> String
02:47:43 <zincy> If the timeout occurs then we should run a specific action depending on the current state of the game
02:47:47 <c50a326> oh, show maybe
02:47:55 <Ariakenom> c50a326: ding ding ding
02:48:23 <c50a326> hm it's not doing what I want, it's showing "[52,53,54,55,53,54,55,56,60,58,62,60,64,65,66,67]"
02:48:53 <liste> c50a326: what do you want to output instead?
02:48:59 <zincy> Would I put the timeout in gameMoveHandler as the timeout should only be initiated by a particular game transition.
02:48:59 <Ariakenom> > read "[52,53]" :: [Int]
02:49:02 <lambdabot>  [52,53]
02:49:10 <ziman> do you want "map chr" instead?
02:49:23 <c50a326> yeah the chars
02:49:30 <Ariakenom> :t chr
02:49:31 <liste> > map chr "[52,53,54,55,53,54,55,56,60,58,62,60,64,65,66,67]
02:49:31 <lambdabot> Int -> Char
02:49:33 <lambdabot>  <hint>:1:59: error:
02:49:33 <lambdabot>      lexical error in string/character literal at end of input
02:49:40 <liste> > map chr [52,53,54,55,53,54,55,56,60,58,62,60,64,65,66,67]
02:49:42 <lambdabot>  "45675678<:><@ABC"
02:50:13 <c50a326> Variable not in scope: chr :: Integer -> b
02:51:57 <ammar2> c50a326: now is probably a good time to introduce yourself to hoogle https://www.haskell.org/hoogle/
02:52:12 <ammar2> you can search for functions (even with their types!) to find out where you can get them from
02:52:59 <infinisil> Or similarly https://hayoo.fh-wedel.de/ which usually finds more stuff for me
02:53:19 <AWizzArd> Python has a syntactic operator `in` which takes an item and a sequence and returns true or false, stating if the item was in the seq/map.
02:53:43 <AWizzArd> Is there something for Haskell too? An `in` method from a typeclass maybe?
02:53:47 <infinisil> :t elem
02:53:49 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
02:53:55 <infinisil> AWizzArd: ^^
02:53:56 <AWizzArd> Ah okay yes.
02:55:02 <Ariakenom> > toEnum 63 :: Char
02:55:04 <AWizzArd> Having elem work on a Foldable makes it more generic than Traversable. Good idea.
02:55:04 <lambdabot>  '?'
02:57:20 <AWizzArd> For a Data.Map.Strict as M – why is  elem 5 (M.fromList [(1, 100), (5, 500)]) => False  ?
02:58:00 <lavalike> because 5 is not an element, it's a key, I'd wager
02:58:23 <infinisil> Map k v
02:58:29 <infinisil> And Foldable (Map k)
02:58:34 <infinisil> So it's foldable over the values
02:59:00 <lavalike> there is this https://www.stackage.org/haddock/lts-11.15/containers-0.5.10.2/Data-Map-Strict.html#v:member
02:59:25 <kuribas> is there a library for creating digital filters?
03:02:10 <c50a326> > takeWhile (<1000) (sum (map sqrt [1..]))
03:02:13 <lambdabot>  error:
03:02:13 <lambdabot>      • No instance for (Enum [Integer]) arising from a use of ‘e_110001’
03:02:13 <lambdabot>      • In the expression: e_110001
03:02:24 <c50a326> in ghci I get Non type-variable argument in the constraint: Floating [a]
03:02:45 <liste> c50a326: you're mixing up lists and numbers
03:02:58 <quicksilver> I think you want to foldl that sum
03:02:58 <lavalike> @t sum
03:02:59 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
03:03:03 <lavalike> :t sum
03:03:04 <lambdabot> (Num a, Foldable t) => t a -> a
03:03:06 <quicksilver> perhaps
03:03:18 <lavalike> quicksilver: maybe scanl
03:03:23 <c50a326> > sum [1, 2, 3]
03:03:25 <lambdabot>  6
03:03:27 <quicksilver> that's what I meant, thanks lavalike
03:03:31 <liste> c50a326: you're trying to takeWhile a sum (which is a number)
03:03:35 <c50a326> map sqrt [1..] produces a list doesn't it?
03:03:37 <liste> you need to sum after takeWhile
03:03:37 <c50a326> oh
03:03:59 <liste> > sum (takeWhile (<1000) (map sqrt [1..]))
03:04:02 <lambdabot>  6.666661664588418e8
03:04:28 <liste> > sum . takeWhile (<1000) . map sqrt $ [1..]
03:04:32 <lambdabot>  6.666661664588418e8
03:04:55 <liste> that way it reads like a "pipeline"
03:08:33 <lavalike> I guess we were thinking:
03:08:36 <lavalike> > last . takeWhile (<1000) . map sum . inits . map sqrt $ [1..]
03:08:39 <lambdabot>  993.6486803921487
03:08:41 <lavalike> along those lines, with the sum in there
03:11:56 <kuribas> I found this: http://hackage.haskell.org/package/dsp-0.2.4/docs/DSP-Filter-IIR-Design.html
03:12:01 <kuribas> but it's not well documented
03:13:02 <c50a326> are there more "while-like" functions except for takeWhile?
03:13:09 <kuribas> as in not documented at all
03:13:20 <kuribas> c50a326: dropWhile?
03:13:30 <liste> c50a326: plenty
03:13:35 <liste> @hackage monad-loops
03:13:35 <lambdabot> http://hackage.haskell.org/package/monad-loops
03:14:18 <c50a326> is there one that takes an int instead of a list?
03:14:33 <liste> c50a326: what do you want it to do?
03:14:39 <c50a326> do while x < n
03:16:33 <liste> do "what" while x < n? that looks suspiciously imperative to me
03:18:25 <liste> is it something takeWhile/dropWhile can't do?
03:20:34 <c50a326> ah I don't know, nevermind. I was just trying to make something work that I was trying to do that was wrong, just for the sake of it. Moved on now.
03:21:01 <c50a326> do you guys keep a haskell built in functions cheat sheet or something?
03:21:23 * liste uses Hoogle type search
03:21:39 <liste> @hoogle Int -> [a] -> [a]
03:21:39 <lambdabot> Prelude take :: Int -> [a] -> [a]
03:21:40 <lambdabot> Prelude drop :: Int -> [a] -> [a]
03:21:40 <lambdabot> Data.List take :: Int -> [a] -> [a]
03:22:25 <liste> it's like I need a puzzle piece of specific shape, and hoogle finds it
03:23:11 <Guest80193> hii
03:26:09 <c50a326> OH THAT'S USEFUL
03:26:11 <c50a326> oops caps sorry
03:29:41 <c50a326> > map ((*2) . (-10)) [1..20]
03:29:44 <lambdabot>  error:
03:29:44 <lambdabot>      • Could not deduce (Enum a0)
03:29:44 <lambdabot>        from the context: (Enum a, Num (a -> b), Num a, Num b)
03:29:48 <c50a326> why doesn't this work
03:30:59 <dminuoso> c50a326: Because prefix minus is a bit weird.
03:31:10 <dminuoso> c50a326: (-10) does not create a section, but it creates a negative 10.
03:31:11 <c50a326> oh yeah
03:31:14 <c50a326> I need to use subtract
03:33:24 <dminuoso> c50a326: In order to understand *why* something fails to type check, it might be useful to dissect the parts you have, and check each individuals type (perhaps use explicit type annotations)
03:33:37 <dminuoso> :t (*2) . (-10)
03:33:38 <lambdabot> (Num (a -> c), Num c) => a -> c
03:38:57 <dminuoso> The interesting bit is that `-10 :: Num a => a`, so it is polymorphic. That means `a` can be any type (as long as it has an instance Num). But it cant find an appropriate instance, so it complains.
03:58:06 <infinisil> Hey, can I use lens to write some function that should work on any type a that has a way to get a value of type b?
03:58:43 <infinisil> So it should work for a = b, a = (b, String), etc.
03:59:18 <cocreature> infinisil: have the function accept a Lens’ a b
03:59:47 <cocreature> although I wonder if you aren’t better off making a function that works on "b" and leave it to users to apply the lens to whatever they have
04:00:16 <infinisil> Oh that seems simple
04:00:27 <infinisil> But doesn't lens also require a setter?
04:01:02 <cocreature> it depends on what exactly you want to do. if you accept a Lens' a b, you will be able to view the "b" and to set it
04:01:15 <liste> infinisil: make it work on type a, convert b to a when using it
04:01:29 <cocreature> if you need less, you can accept a more general type and if you need more, you want something more specific
04:01:48 <infinisil> I see, that should be fine
04:01:58 <infinisil> liste: It needs to work on multiple a's
04:02:37 <infinisil> I could just accept a (a -> b) argument too I guess
04:03:04 <cocreature> if you only want to get the "b" value rather than set it, then that’s probably the best option
04:03:54 <infinisil> Yeah probably, although another part of my code desperately needs some lensification, but I've never used
04:04:02 <infinisil> it
04:04:13 <infinisil> Oh well
04:04:56 <Taneb> Lenses for the sake of lenses is rarely a good idea for code you want to look at again in two weeks
04:05:15 <liste> infinisil: so if you have "foo :: a -> (a -> b) -> whatever", where you just use the a -> b to get the b from a, why not just take a "b" argument in the first place, and then convert on site?
04:05:58 <liste> eg. foo (fst a), foo (fromJust a), etc...
04:06:22 <infinisil> liste: Hmm good point
04:06:32 <liste> you lose no generality but have simpler code
04:06:42 <infinisil> Taneb: My code needs to do some nested record updates, which is really ugly right now
04:07:12 <[exa]> infinisil: is there any reason why the lens identifier could not be overloaded?
04:07:20 <Taneb> infinisil: I'm not against lenses for where they're useful
04:07:48 <Taneb> (in fact I am extremely pro-lens almost wherever you have records)
04:07:52 <infinisil> [exa]: Not sure what you mean, but I'll get back to coding now :)
04:09:40 <[exa]> infinisil: like,  class HasSomeBInside a where getB :: Lens' a b
04:09:48 <[exa]> (probably naive)
04:10:16 <infinisil> Doesn't lens have this functionality already for free though?
04:10:38 <Taneb> There's makeClassy which makes this stuff with TH
04:11:22 <[exa]> oh cool
04:52:59 * hackage diagrams-haddock 0.4.0.2 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.4.0.2 (BrentYorgey)
05:00:47 <c50a326> what's the difference between [Char] and String
05:01:08 <dminuoso> c50a326: type String = [Char]
05:01:15 <dminuoso> c50a326: You can use the interchangably.
05:01:34 <liste> also note: String is very bad for real-world usage
05:01:50 <phadej> or than it's not. It really depends on what that use is
05:02:00 <phadej> if you process string values as opaque objects, than yes
05:02:22 <phadej> some more memory-efficient representation is better
05:02:34 <dminuoso> Can you ever observe the difference between a type alias and its value in Haskell?
05:02:46 <dminuoso> Or is `String ~ [Char]` in every sense (modulo diagnostics)
05:02:53 <phadej> it is
05:03:18 <dminuoso> phadej: Even with { LANGUAGE EnableEverything } ?
05:03:27 <dminuoso> {-# LANGUAGE EnableEverything #-}
05:03:36 <phadej> no
05:03:44 <phadej> you cannot, that's the idea
05:03:50 <cocreature> TH? :)
05:04:01 <phadej> good point
05:04:19 <phadej> I think there you can, as you see the source code
05:04:22 <phadej> 'see"
05:04:28 <cocreature> it’s fair to call that cheating :)
05:04:32 <dminuoso> Right, for the purpose of this question Im going to exclude that.
05:05:18 <phadej> (and in fact, i remember an issue where one had to unfold type alises in TH)
05:08:08 <phadej> data Tree a = Node a (Forest a)  -- doesn't look recursive at first, but type Forest a = [Tree a]
05:51:23 <infinisil> Is there a neat way to replace a line in a file?
05:51:43 <infinisil> E.g. replace line 10 with "foobar"
05:52:13 <dminuoso> infinisil: You describe a new list with that semantics.
05:52:36 <dminuoso> e.g.: take 10 ls ++ ["foobar"] ++ drop 11 ls
05:52:46 <infinisil> I'd like it to be somewhat efficient, I'm using Text everywhere and the files could be big
05:53:10 <infinisil> (Also I need to transform the old line into the new one)
05:53:24 <dmwit> Do you plan to write to the same file as you read from?
05:53:30 <infinisil> Yeah
05:53:54 <dminuoso> infinisil: You *could* use lens for that, its a bit more expressive.
05:53:54 <dmwit> Okay. My plan would be to read one line at a time, write the modified version to a temporary file, then rename the temporary file over top of the real file at the end.
05:54:27 <infinisil> dmwit: Hmm that would certainly be simple
05:54:31 <infinisil> I'm thinking more of something like
05:55:13 <infinisil> Seek to the line you want to replace, read it and transform it, write the new line to the file, rewrite the rest of the lines
05:55:39 <dmwit> That is possible, but significantly more tricky if the new line is longer than the old one.
05:55:40 <infinisil> But there's the whole problem of the file just being a [Char] really
05:55:44 <infinisil> Yeah
05:56:05 <dmwit> Which is (part of) why it would not be my plan.
05:56:17 <infinisil> Hmm alright, I'll just use a temp file
05:58:02 <dminuoso> > words "foo bar quux baz magic unicorn" & element 3 %~ fmap toUpper
05:58:04 <lambdabot>  ["foo","bar","quux","BAZ","magic","unicorn"]
05:58:28 <infinisil> Magical
05:58:49 <__monty__> Couldn't you replace the block the line's in with two blocks one of which is practically empty, dmwit?
05:59:05 <dmwit> No idea what that even means.
05:59:14 <dminuoso> > let ws = words "foo bar quux baz magic unicorn" in over (element 3) (fmap toUpper) ws
05:59:16 <lambdabot>  ["foo","bar","quux","BAZ","magic","unicorn"]
05:59:36 <dminuoso> infinisil: ^- thats the non-operator version, maybe a bit easier to read for you
06:00:00 <cocreature> loading the whole file in memory just so you can use lens for this is kind of silly
06:00:10 <infinisil> Lens sure is nice, I should eventually use it too
06:00:22 <__monty__> dmwit: The on-disk blocks of the file. Just asking because you said it'd be hard if the new line's longer. I assume you meant because it would no longer fit in the original block.
06:00:57 <dmwit> It had nothing to do with blocks. The problem is that if you naively write the new line, you will be overwriting some of the data you intended to move to later in the file.
06:01:17 <dmwit> The idea is fixable, but with great difficulty and only small benefit.
06:01:50 <dmwit> (Namely, because you don't need a temporary file, you only need extra storage around as big as the difference between the length of the new line and the length of the old line rather than extra storage around the size of the entire file.)
06:02:15 <infinisil> Yeah, not worth it probably
06:02:26 <infinisil> And this feels like premature optimization
06:02:30 * hackage network-conduit-tls 1.3.2 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-1.3.2 (MichaelSnoyman)
06:02:36 <dminuoso> cocreature: Can you elaborate on the "loading file in memory" bit?
06:03:59 <cocreature> dminuoso: infinisil asked how you replace the 10th line in a file. you showed how to replace the 10th item in a list. applying that to infinisil’s problem requires that you turn the file into a list of strings and if you don’t want to use lazy IO that means loading the whole file in memory
06:04:03 <dmwit> dminuoso: As far as I know, `text` does not offer a way to get a lazy list of lines of a file.
06:04:24 <dmwit> dminuoso: (And infinisil did say he's using `Text` everywhere.)
06:04:57 <__monty__> dmwit: I don't know much about files, hence my question. If a file is a linked list of blocks though it would be easy, find the right block, change the block, possibly overflowing so you have two blocks now, insert the two blocks in place of the original block.
06:05:46 <dmwit> __monty__: I do not believe it is that easy, because it is very unlikely that you would change from 1 block to 2. Much more likely that you would change from 1 block to 1.01. Then you need to rewrite the entire rest of the file, moving it 0.99 blocks to the left.
06:06:16 <__monty__> dmwit: So blocks can't be half-empty?
06:06:26 <dminuoso> cocreature: Ah I see.
06:06:33 <dmwit> I suppose it depends on the filesystem. There are certainly filesystems that don't do that.
06:09:06 <dmwit> (How certain? I actually don't know enough about filesystems to name one. I put a 95% probability on the event that at least one existing, popular filesystem does not support partial blocks in the middle of a file.)
06:14:10 <quicksilver> I believe no common file system supports quick insertion in the middle of a file like that
06:14:21 <quicksilver> probably because everybody has got used to not writing applications that do that
06:14:27 <quicksilver> so now there is no point offering it as a functionality.
06:14:48 <quicksilver> various modern non-filesystem data storage solutions which work at a different level of abstraction do, I'm sure.
06:17:06 <merijn> quicksilver: There's a couple that support it with some hacky tricks
06:17:30 <dmwit> My probability estimate has gone up significantly.
06:20:47 <pong> aren't most modern filesystems CoW?
06:21:10 <merijn> https://en.wikipedia.org/wiki/Sparse_file
06:21:17 <merijn> pong: Eh, no?
06:21:29 <pong> as in the really new ones, like zfs, btrfs and apple's thing
06:21:31 <merijn> ZFS is, maybe btrfs too, but those are far from the biggest mainstream filesystems
06:21:51 <merijn> ext4, NTFS, and the old Apple filesystem are definitely not
06:22:16 <quicksilver> CoW doesn't imply smart behaviour when you try to do a mid-file insert
06:22:33 <quicksilver> POSIX file semantics doesn't have a way of saying "insert bytes in the middle of a file and push the tail down"
06:22:36 <quicksilver> (does it?)
06:22:49 <quicksilver> I know POSIX isn't everythign but it is an important common denomiator
06:23:05 <merijn> "POSIX file semantics doesn't have a way" /= "you can't do it in common filesystems"
06:23:12 <quicksilver> agreed.
06:23:16 <merijn> That just means you can't do it via POSIX portable code
06:23:29 * hackage cpsa 3.6.0 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-3.6.0 (mliskov)
06:24:12 <quicksilver> but call it what you like, all(?) OSes and most(?) common file APIs have standardised around something isomorphic to seek() semantics.
06:34:33 <zincy> Hey would someone here be able to talk me through using system.timeout in my websocket app via voice chat?
06:35:00 <zincy> As in off IRC - I feel like screen sharing would be a better way of working through it.
06:38:29 * hackage haxl 2.0.1.0 - A Haskell library for efficient, concurrent,and concise data access.  http://hackage.haskell.org/package/haxl-2.0.1.0 (SimonMarlow)
06:38:57 <stondo> hi all
06:39:18 <saml> hi stondo
06:40:29 <stondo> I'm getting <interactive>:2:1: error: Data constructor not in scope: Posiz :: (Integer, Integer) -> t in ghci (stack ghci) after entering type Pos = (Int, Int) and Pos (1,2). What am I doing wrong?
06:40:40 <stondo> sorry for the typo
06:40:55 <stondo> Pos, not Posiz
06:41:21 <mniip> Pos is a type synonym
06:41:33 <stondo> that's not the error, the name is Pos and is correct everywhere
06:41:49 <mniip> with that declaration 'Pos' doesn't become a data constructor. It's not something you can use in a value
06:42:01 <p0lyph3m> type synonyms don have constructors
06:42:02 <dmwit> `type` just declares a new name for an existing type. When you write `Pos (1,2)`, this is not sensible, because `Pos` is a type, not a computation.
06:42:06 <stondo> ah I think I get it now
06:42:10 <dmwit> (You don't write `Int 1`, do you?)
06:42:23 <Ariakenom> "type Pos = (Int, Int)" vs "data Pos = Pos (Int, Int)"
06:42:27 <stondo> I can use that in a function declaration I guess
06:42:30 <p0lyph3m> newtype Pos = Pos (Int,Int)
06:42:35 <dmwit> stondo: Right.
06:43:04 <stondo> thanks guys, u're always effective and very helpful ;-)
07:06:55 <zincy> If I have a msg callback function where the msg callback will call runStateT and update some state with the new msg and get the new state. What would I be wrapping with a timeout if I wanted to enforce a time limit to receive a new msg where if the timeout occurs runStateT is called with some default msg?
07:10:03 <fr33domlover> zincy, I suppose the function that waits for a new message
07:10:42 <fr33domlover> zincy, either it gets one and runs the callback or time runs out and runs the callback with a default message?
07:12:16 <zincy> https://lpaste.net/265146159591325696
07:13:31 <zincy> hmm then you would need to change the functionality of the function awaiting the msg on every new state transition?
07:17:18 <halogenandtoast> Random Yesod question, is there a method TypedContent -> Html?
07:17:56 <halogenandtoast> TypedContent doesn't have an instance of ToMarkup so can't use toHtml
07:18:40 <fr33domlover> halogenandtoast, you can't convert TypedContent back to Html
07:19:07 <fr33domlover> halogenandtoast, you should grab the Html before it gets serialized
07:19:09 <halogenandtoast> okay fair enough
07:19:21 <halogenandtoast> I was using setCredsRedirect, but maybe I just want to call setCreds
07:20:25 <halogenandtoast> seems to compile
07:20:31 <halogenandtoast> thanks fr33domlover
07:20:59 * hackage flexible-defaults 0.0.2 - Generate default function implementations for complex type classes.  http://hackage.haskell.org/package/flexible-defaults-0.0.2 (PeterSimons)
07:33:25 <cocreature> sgraf: Hey, do you have some example for your datafix lib that’s somewhere in between the simple examples and strictness analysis?
07:34:23 <cocreature> sgraf: I’m having trouble figuring out how to use it on actual ASTs. I feel like I want the value of all nodes (i.e. all locations in my AST for which I want the result of the analysis) in that case but the API only gives me the result of one node.
07:45:29 * hackage shake-ext 3.0.1.0 - Helper functions for linting with shake  http://hackage.haskell.org/package/shake-ext-3.0.1.0 (vmchale)
08:12:03 <drets> Hi, I use persistent and persistent-postgresql and want to store the small text files and their sha256 hashes. What the proper way of doing it? What the types better to use in persistent model file? Text for sha256 hash and Text for file content or?
08:19:30 * hackage rhine 0.4.0.1, rhine-gloss 0.4.0.1 (turion): https://qbin.io/farmer-rock-7o3h
08:21:59 * hackage microformats2-parser 1.0.1.8 - A Microformats 2 parser.  http://hackage.haskell.org/package/microformats2-parser-1.0.1.8 (myfreeweb)
08:35:00 * hackage egyptian-fractions 0.1.0.2 - Egyptian fractions in Haskell  http://hackage.haskell.org/package/egyptian-fractions-0.1.0.2 (vmchale)
08:35:56 <imalsogreg> drets: That sounds fine to me.
08:42:19 <c50a326> does 1:[] desugar to 1:[]:[]
08:43:42 <pavonia> No
08:44:22 <pavonia> 1:[] already is desugared, I'd think
08:45:52 <dmwit> c50a326: The question as asked can really only have a yes-or-no answer. If pavonia's (correct) answer is helpful to you, great. If not, you could consider sharing a bit about what motivated the question, and then we can say more than just yes or no.
08:48:04 <dmwit> ?tell drets I'd probably use a ByteString (or a newtype around it, e.g. https://hackage.haskell.org/package/cryptohash-0.11.9/docs/Crypto-Hash.html#t:Digest) for the hash, not Text. Storing file contents as Text also seems a bit odd unless the file is, indeed, intended to represent text.
08:48:04 <lambdabot> Consider it noted.
08:55:37 <quicksilver> > 1:[]:[]
08:55:39 <lambdabot>  error:
08:55:39 <lambdabot>      • No instance for (Num [()]) arising from a use of ‘e_11’
08:55:39 <lambdabot>      • In the expression: e_11
08:55:56 <quicksilver> 1:[]:[] *probably* doesn't make sense as you can see.
08:56:15 <quicksilver> it is the same thing as [1,[]]
08:56:29 <quicksilver> which only works if you have a Num instance for some list type.
09:00:29 <c50a326> lyah says that [4,5] desugars to 4:(5:[]) so if whenever you use a list in haskell it is like this then I was wondering if you actually type like [4,5]:[] does that desguar to 4:(5:[]:([]:[])) or something lol
09:00:39 <c50a326> a dumb enough thought
09:01:11 <c50a326> oh of course you can't do [4,5]:[] lol
09:01:14 <glguy> (:) and [] are the primitive things, it's only non-empty lists with [...] that get desugared
09:01:27 <glguy> [4,5]:[] is the same as   [[4,5]]
09:01:39 <glguy> is the same as  (4:5:[]):[]
09:01:53 <c50a326> yeah that was silly of me to type
09:02:01 <c50a326> I meant if you do 4:[]
09:15:37 <Rembane> > 4:[]:[]:[]
09:15:40 <lambdabot>  error:
09:15:40 <lambdabot>      • No instance for (Num [()]) arising from a use of ‘e_14’
09:15:40 <lambdabot>      • In the expression: e_14
09:16:04 <Rembane> Aha.
09:16:06 <Rembane> Good.
09:20:15 <dminuoso> @let bender = (:8:[])
09:20:16 <lambdabot>  Defined.
09:21:00 <dminuoso> c50a326: Like I said earlier. `data [] a = [] | a : [a]`
09:22:14 <dminuoso> c50a326: A fully equivalent way is `data List a = Nil | Cons a (List a)` - Haskell will represent them exactly like that. It might become obvious why String might be a horrible fit for processing any non-trivial amount of text data.
09:46:23 <dmwit> c50a326: Ah, I think I see where your confusion lies.
09:47:27 <dmwit> c50a326: In the list literal syntax, when you have, e.g., `[a,b,c,d,e]`, each element of the list is associated with a call to `(:)`. But `[]` doesn't have any elements, so when "desugaring" this "list literal", you get zero calls to `(:)`.
09:48:39 <dmwit> c50a326: The pattern is like this: `[a,b,c]` -> `a:b:c:[]`; `[a,b]` -> `a:b:[]`; `[a]` -> `a:[]`; `[]` -> `[]`.
09:50:03 <c50a326> ah okay haha thanks
09:54:30 <quicksilver> dminuoso: FWIW I don't that's remotely *obvious* without a pretty deep inspection into haskell's evaluation semantics and the nature of _|_, or alternatively specific knowledge of one particular implementation.
09:54:51 <quicksilver> purely as a semantic specification of a data type you can imagine it might be implemented quiet efficiently.
09:59:59 <Squarism> is there any bare bones parser in base?
10:00:29 <Solonarv> Text.Read and submodules
10:03:23 <Solonarv> Squarism: https://hackage.haskell.org/package/base-4.11.1.0/docs/Text-Read.html#g:3
10:10:17 <dmwit> Neat. I knew about ReadS and ReadP, but ReadPrec is new to me.
10:11:15 <tdammers> s/neat/what a mess/ :x
10:12:45 <glguy> Seems like a confused response to learning that there's a module for helping deal with precdences when parsing with ReadP
10:17:24 <Solonarv> I've never used it tbh, when I need parsing I reach for something from the parsec family instead
10:22:58 <tdammers> Solonarv: most sane people would; but when you're working on the GHC codebase, that simply isn't an option
10:23:07 <Solonarv> yeah fair enough
10:24:02 <mniip> why need parsec when you can use... yoctoparsec!
10:26:19 <Ariakenom> hektoparsec!
10:26:44 <Ariakenom> (I hope that's made up)
10:29:33 <nshepperd> i normally use the `parsers` api then run the parser with parsec
10:33:47 <dmwit> I am skeptical of APIs that claim to unify parser combinator libraries.
10:35:20 <dmwit> Often the meaning of a grammar depends intimately on the details of the combinator library.
10:43:44 <mniip> hey vaibhavsagar
10:44:00 <mniip> I just noticed a blog post on your website referencing yoctoparsec!
10:44:50 <mniip> though it looks like it's misleadingly suggesting that the type in yoctoparsec is any similar to the StateT that you're discussing :p
10:45:11 <mniip> also the 't' is not the stream type: it's the token type
10:54:38 <dminuoso> quicksilver: Dunno, unsafeCoercing between the two on my machine was a pretty enlightening thing to do - though I am aware that this is unstable and not guaranteed to work.
10:57:19 <davean> quicksilver: No, those semantics make it pretty clear it can't be optimized sadly
10:58:27 <davean> Even if you don't want to observe the seperation, any variable length structure like that will inherantly have bad coefficients
10:58:36 <davean> Never mind you can't not observe the seperation
10:59:50 <davean> Sadly I don't need to know much of anything about Haskell for that
11:01:52 <mngrm3a> if i don't specify any version boundaries for my dependencies in my package.yaml, will stack always pull the most recent versions (depending on the configured snapshot) ?
11:02:08 <dminuoso> quicksilver: I mean I feel it's a bit the other way around actually. The optimizations you do get is things like prewritten RULES and things like bytestring stealing unpackCString# - but that's pretty well hidden, superficially you just get some visually pleasant form of `data List a = Nil | Cons a (List a)`
11:02:15 <cocreature> mngrm3a: there is only one version of each package in a snapshot
11:02:19 <cocreature> and stack will use that
11:02:35 <mngrm3a> @cocreature thanks
11:02:35 <lambdabot> Unknown command, try @list
11:03:28 <dminuoso> quicksilver: Oh after reading it again I just realized what you are on about.
11:49:27 <Ariakenom> > [0.5, 1.5 .. 2]
11:49:30 <lambdabot>  [0.5,1.5,2.5]
11:52:12 <infinisil> Haha
11:52:17 <infinisil> @package acme-everything
11:52:17 <lambdabot> http://hackage.haskell.org/package/acme-everything
11:52:27 <infinisil> "This package requires the entirety of Hackage to be built."
11:52:29 <dmwit> > [1.0,3 .. 4]
11:52:31 <lambdabot>  [1.0,3.0,5.0]
11:53:43 <ZeuPiark> hello
11:56:50 <Ariakenom> dmwit: that is indeed "better" thanks!
11:56:52 <infinisil> Oh my god all these acme-packages are hilarious
11:57:38 <infinisil> safeFromJust :: Maybe a -> Maybe a
11:57:41 <infinisil> "Safely extract a value from a Just"
11:59:19 <mniip> hmm
11:59:31 <mniip> funky idea
12:00:29 * hackage cfenv 0.1.0.0 - A library getting the environment when running on Cloud Foundry  http://hackage.haskell.org/package/cfenv-0.1.0.0 (tomoram)
12:02:06 <Ariakenom> "Since beginning his investigations, the author of this package has discovered that this pattern is at least as commonly used as Functor." https://hackage.haskell.org/package/acme-cofunctor
12:03:43 <Rembane> :D
12:03:53 <lukelau> Is it possible to have an array of SomeClass a => Lens’ Foo a ?
12:04:14 <lukelau> And more importantly operate on them
12:04:19 <Ariakenom> with at least in italics
12:04:29 * hackage mbug 1.3 - download bugs mailboxes  http://hackage.haskell.org/package/mbug-1.3 (DmitryBogatov)
12:05:56 <infinisil> I am proud to say that I know what a cofunctor is
12:06:36 <electrocat> infinisil: read the article about contravariance? :p
12:07:13 <infinisil> Not sure which one you mean, I think I learned it from Arrows, or some other hackage docs
12:07:25 <electrocat> infinisil: ah ok, nvm
12:07:25 <Ariakenom> An Monad is just a monoid in the category of endo-X. Solve for X.
12:19:28 <mniip> !
12:20:45 <infinisil> :t (!)
12:20:46 <lambdabot> Ix i => Array i e -> i -> e
12:28:21 <mniip> % imply @Int @Char (++ "bar") (given @Int "foo" (consider @Char))
12:28:21 <yahb> mniip: "foobar"
12:28:50 <mniip> doing exference in the GHC constraint solver
12:39:54 <mniip> now a good question is
12:40:07 <mniip> how to represent quantified constraints
12:40:12 <Welkin> are we alone in the universe?
12:40:33 <mniip> explicit functor ends over profunctor constructions
12:43:31 <mniip> Welkin, at the moment or in general?
12:44:02 <mniip> (is "at the moment" even vaguelly well-defined on universal scales even)
12:44:38 <Welkin> for all reasonable hope of contacting another civilization
12:44:50 <Welkin> or, just finding microbial life in our solar system
12:49:53 <lavalike> mniip: what are those? (imply, given, consider)
12:53:00 * hackage zip-archive 0.3.3 - Library for creating and modifying zip archives.  http://hackage.haskell.org/package/zip-archive-0.3.3 (JohnMacFarlane)
12:58:34 <Ariakenom> > [1, 3 .. 4] :: Rational
12:58:37 <lambdabot>  error:
12:58:37 <lambdabot>      • Couldn't match type ‘[Integer]’ with ‘Ratio Integer’
12:58:37 <lambdabot>        Expected type: Rational
12:58:59 <Ariakenom> > [1.0, 3 .. 4] :: Rational
12:59:01 <lambdabot>  error:
12:59:02 <lambdabot>      • Couldn't match type ‘[Double]’ with ‘Ratio Integer’
12:59:02 <lambdabot>        Expected type: Rational
12:59:19 <Ariakenom> > [1 :: Rational, 3 .. 4]
12:59:22 <lambdabot>  [1 % 1,3 % 1,5 % 1]
12:59:30 * hackage cql-io 1.0.1 - Cassandra CQL client.  http://hackage.haskell.org/package/cql-io-1.0.1 (romanb)
12:59:40 <Ariakenom> That's aggressive defaulting?
13:00:02 <lyxia> what is?
13:01:14 <infinisil> :t (:)
13:01:16 <lambdabot> a -> [a] -> [a]
13:01:23 <infinisil> a == Rational
13:01:37 <infinisil> and all other elements need to be Rational too
13:02:13 <geekosaur> > [1, 3 .. 4] :: [Rational]
13:02:15 <lambdabot>  [1 % 1,3 % 1,5 % 1]
13:02:48 <Ariakenom> ha yes, that's supposed to be a list :p
13:03:48 <Ariakenom> I thought I had [Rational] and it complained about not ~[Integer]
13:13:10 <electrocat> what does the tilde do in `let ~(a,b) = e1 in e2`?
13:13:17 <Welkin> lazy pattern matching
13:14:48 <electrocat> the haskell report calls it irrefutable pattern matching i think
13:14:59 <Welkin> https://wiki.haskell.org/Lazy_pattern_match
13:15:36 <electrocat> Welkin: tnx
13:16:11 <Welkin> I have never used them
13:16:18 <Welkin> the advice is to not use them
13:16:27 <Welkin> if you need it, you'd know
13:18:56 <electrocat> Welkin: right, i asked because i encountered them somewhere
13:25:18 <lyxia> it seems especially pointless in a let
13:27:35 <Ariakenom> let a = fst pair; b = snd pair in f a b
13:30:19 <oisdk> It's useful in a fold
13:30:38 <lyxia> how so?
13:32:16 <oisdk> @let partitionStrict p = foldr (\x (tr,fl) -> if p x then (x:tr,fl) else (tr,x:fl) ) ([],[])
13:32:17 <lambdabot>  Defined.
13:32:26 <oisdk> > partitionStrict even [1..10]
13:32:29 <lambdabot>  ([2,4,6,8,10],[1,3,5,7,9])
13:32:34 <oisdk> > paritionStrict even [1..]
13:32:37 <lambdabot>  error:
13:32:37 <lambdabot>      • Variable not in scope:
13:32:37 <lambdabot>          paritionStrict :: (Integer -> Bool) -> [Integer] -> t
13:32:53 <oisdk> > partitionStrict even [1..]
13:33:00 <lambdabot>  mueval-core: Time limit exceeded
13:33:09 <oisdk> @let partitionLazy p = foldr (\x ~(tr,fl) -> if p x then (x:tr,fl) else (tr,x:fl) ) ([],[])
13:33:10 <lambdabot>  Defined.
13:33:20 <oisdk> partitionLazy even [1..]
13:33:25 <oisdk> > partitionLazy even [1..]
13:33:28 <lambdabot>  ([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
13:55:20 <dstolfa> suppose i was writing a thing in haskell which had to interact with a kernel interface which is god awful and dumps a C structure that has a bunch of pointers that have to be followed in userspace. what would you prefer, a wrapper in haskell with fugly C things in it or just a small C interface that i can call into from haskell and translate to the thing i actually care about
13:58:55 <infinisil> dstolfa: Considering that the former will be a nightmare to create, I'd go for the latter if your C skills are decent. Note that I have never done either of those, so this is just a feeling.
13:59:32 <lyxia> yeah do the pointer-chasing in C
13:59:49 <pdxleif> Should a module re-export all the types that are in its public type signatures?
14:01:48 <shapr> pdxleif: I've seen 'smart constructors' used where you could only get one by using code to create it
14:02:27 <dstolfa> infinisil: lyxia alright, thanks for the thoughts :). i'll do that part in C
14:05:50 <Welkin> do it in C minor
14:09:20 <pdxleif> shapr: I mean like, in my module I import Network.AWS.Data.Crypto (Digest, SHA256), and then expose "Digest SHA256" in my exported type sigs - should I add those to my export list, or make consumers import them themselves if they want to have those things in their type sigs?
14:10:49 <pdxleif> Network.AWS.Data.Crypto is itself just re-exports of stuff from cryptonite
14:15:06 <cgoldammer> Is there a standard pattern for validating data using business logic? For example, I have data in the format (String, [String]), and if this data passes tests (e.g. all the strings have the same length) then I return ValidatedData String [String]
14:16:01 <cgoldammer> My default approach would be to pipe this through a number of Either statements so I keep track of possible errors
14:16:18 <infinisil> cgoldammer: validating data constructors
14:16:35 <dminuoso> cgoldammer: Use `Validation` ?
14:16:35 <infinisil> Make a data or newtype, and don't export any constructors
14:16:56 <infinisil> Only export a function `makeFoo :: String -> [String] -> Maybe Foo`
14:17:05 <dminuoso> cgoldammer: https://hackage.haskell.org/package/validation-1/docs/Data-Validation.html
14:17:47 <cgoldammer> dminuoso: Thanks, that looks like it hits the spot
14:17:59 <infinisil> Ah, what I said were smart constructors: https://wiki.haskell.org/Smart_constructors
14:18:15 <infinisil> But I guess it's not what you need
14:18:35 <cgoldammer> infinisil, not sure but it sounds interesting either way, will read!
14:26:32 <dmwit> % :t imply
14:26:32 <yahb> dmwit: (String -> String) -> ((C a => C b) => r) -> r
14:27:22 <dmwit> % imply @Int @Char (++ "bar") (given @Int "foo" (consider @Char))
14:27:22 <yahb> dmwit: "foobar"
14:27:23 <dmwit> % imply @Int @Char (++ "bar") (given @Int "foo" (consider @Char))
14:27:23 <yahb> dmwit: "foobar"
14:27:24 <dmwit> % imply @Int @Char (++ "bar") (given @Int "foo" (consider @Char))
14:27:24 <yahb> dmwit: "foobar"
14:27:30 <dmwit>  % imply @Int @Char (++ "bar") (given @Int "foo" (consider @Char))
14:27:35 <Welkin> % hello
14:27:35 <yahb> Welkin: ; <interactive>:60:1: error: Variable not in scope: hello
14:27:38 <dmwit> Oh, god, I'm sorry.
14:27:40 <Welkin> damn robots
14:27:51 <Welkin> % why are you such a dumb robot?
14:27:51 <yahb> Welkin: ; <interactive>:61:31: error: parse error (possibly incorrect indentation or mismatched brackets)
14:28:47 <dmwit> I was scrolled up, and kept hitting paste wondering why nothing was happening. Turns out, something was happening.
14:29:15 <Welkin> does anyone use text-to-speech on their compiler?
14:29:26 <infinisil> % are = 0; you = 0; such = 0; a = 0; dumb = 0; robot = 0; why _ _ _ _ _ _ = "Sorry!"
14:29:26 <yahb> infinisil:
14:29:28 <Ariakenom> I use eye tracking
14:29:32 <dmwit> Interesting. Compare:
14:29:34 <infinisil> % why are you such a dumb robot
14:29:34 <yahb> infinisil: "Sorry!"
14:29:36 <dmwit> % :t consider
14:29:36 <yahb> dmwit: ; <interactive>:1:1: error: No instance for (C a0) arising from a use of `consider'
14:29:38 <dmwit> % :i consider
14:29:38 <yahb> dmwit: consider :: C a => String -- Defined at <interactive>:21:38
14:31:05 <AndreasK> Anyone know if there is a easy way in prettyprinter to prepend something at the start of a line without changing the intent for the rest? Eg for something like adding line numbers to code
14:32:26 <dmwit> mniip: Tricky. Lots of reflection behind the scenes?
14:32:47 <infinisil> AndreasK: Print it, then prepend to each line, no need to complicate prettyprinter for such simple functionality
14:34:07 <dmwit> AndreasK: If you go with infinisil's suggestion, you might like the boxes package.
14:34:49 <dmwit> To be honest, I'm not super sure I understand the question or infinisil's answer, though, so take that package suggestion with a grain of salt.
14:35:41 <Welkin> what comes after super sure? mega sure? ultra sure? uber sure?
14:35:54 <dmwit> Specifically: most pretty-printers take on line breaking as a task. How is that supposed to interact with line numbering?
14:36:41 <infinisil> dmwit: Yeah, so I'm suggesting to not involve the pretty-printer at all, just let it do its thing, and after that prepend something to each output line
14:37:30 <dmwit> Maybe that's what's wanted and maybe it ain't. Which is why I asked the question.
14:37:45 <dmwit> Maybe reflowed lines are intended to be treated as a single line for the purposes of line numbering. I don't know.
14:38:01 <infinisil> Oh good point
14:38:47 <AndreasK> I want to pretty print an AST to fortran, but want to have both indent and statment labels, where statements get indented but labels need to stay at the front.
14:40:49 <AndreasK> For now i'm ok with it to crash and burn if lines get too long, it's not production software.
15:08:29 <gentauro> can anybody explain why this doesn't work? https://gitlab.com/snippets/1728104
15:10:16 <gentauro> what I'm trying to achieve is that my "p" function is bound to "MonadPlus" and not "MonadPlusPlus"
15:10:33 <pavonia> That link seems to require a login
15:12:00 <gentauro> pavonia: you are right -> https://gitlab.com/snippets/1728104
15:12:02 <gentauro> try again
15:12:13 <gentauro> (gitlab defaults snippets to private)
15:14:05 <fishythefish> gentauro: `p` must have a `MonadPlusPlus` constraint
15:14:06 <pavonia> pp requires m to be MonadPlusPlus, so p = pp requires them from p to have the same class
15:14:24 <pavonia> them --> the m
15:16:33 <geekosaur> suspect they're expecting the class declaration to do that. but if you have asked for MonadPlus, you have only proof of MonadPlus on hand; it's not enough to just have a class constraint, you need a proof / witness of it on hand at the point of use
15:17:33 <gentauro> ok
15:17:34 <fishythefish> gentauro: `p :: (MonadPlus m) => m ()` means that if you give me `p`, then I can choose any `m` with a `MonadPlus` instance and use `p` as an `m ()`. However, `p = pp` should only allow me to choose an `m` with a `MonadPlusPlus` instance
15:18:36 <geekosaur> as ghc implements it, there are dictionaries of functions per type; by declaring a MonadPlus constraint you are passed a MonadPlus dictionary for the actual type, but you can't go from that to a MonadPlusPlus dictionary for that type
15:18:42 <geekosaur> you could go the other way
15:18:55 <gentauro> geekosaur: I just noticed that ;)
15:19:16 <gentauro> Prelude> p  :: (MonadPlus      m) => m (); p  = plus ()
15:19:25 <gentauro> Prelude> pp :: (MonadPlusPlus  m) => m (); pp = p
15:19:27 <gentauro> :)
15:20:59 * hackage hbf 0.1.0.0 - An optimizing Brainfuck compiler and evaluator  http://hackage.haskell.org/package/hbf-0.1.0.0 (paraseba)
15:39:38 <gentauro> hhhmmmm
15:39:48 <gentauro> I don't really get it
15:45:03 <emmanuel_erc> If you were to use a "Map" as a PriorityQueue (by using maxView or its compatriots), do you get the wrong semantics?
15:45:30 * hackage hbf 0.1.0.1 - An optimizing Brainfuck compiler and evaluator  http://hackage.haskell.org/package/hbf-0.1.0.1 (paraseba)
15:46:35 <Squarism> I run persistent with mysql. I wonder what a good choice to embedded database for unit tests could be?
15:47:22 <fishythefish> @let myIntegral :: (Integral a) => a; myIntegral = 1
15:47:24 <lambdabot>  .L.hs:164:1: error:
15:47:24 <lambdabot>      Duplicate type signatures for ‘myIntegral’
15:47:24 <lambdabot>      at .L.hs:161:1-10
15:47:27 <fishythefish> @undefine
15:47:27 <lambdabot> Undefined.
15:47:28 <fishythefish> @let myIntegral :: (Integral a) => a; myIntegral = 1
15:47:30 <lambdabot>  Defined.
15:47:38 <fishythefish> @let myNum :: (Num a) => a; myNum = myIntegral -- gentauro
15:47:39 <lambdabot>  .L.hs:162:9: error:
15:47:39 <lambdabot>      • Could not deduce (Integral a) arising from a use of ‘myIntegral’
15:47:39 <lambdabot>        from the context: Num a
15:48:07 <fishythefish> here's perhaps an easier example to think about
15:49:35 <fishythefish> I should be able to use `myNum` wherever any type with a `Num` instance is expected
15:50:22 <fishythefish> for instance, I should be able to use it as a Float
15:51:40 <fishythefish> however, I'm trying to define it as myIntegral, which has the more specific `Integral` constraint
16:00:01 <pdxleif> Squarism: Maybe sqlite, or some in-memory DB?
16:01:23 <Squarism> pdxleif, most links point that way. Persistent doesnt seem to like sqlite pools with inmemory databases though. All my code is using pools
16:09:30 <blonkhart> this is just to share an interesting use of view patterns https://github.com/Erdwolf/prolog/blob/master/src/Syntax.hs lines 39-61
16:42:19 <newhoggy> Looks like this the rebase has worked.  Also managed to get stage-2 only compile to work today too.  (Not sure why my first attempt a last week didn't work)
16:42:49 <newhoggy> Oops.  Wrong channel.  Sry
17:16:38 <enterprisey> Any way to get a Unicode character by name? (so foo "latin capital letter a" == "A")
17:17:09 <lyxia> blonkhart: that's a funny trick
17:26:14 <geekosaur> enterprisey, not built in. there's a binding to ICU though
17:26:21 <dreamer_> yo
17:26:25 <enterprisey> I have looked it up
17:26:26 <dreamer_> found that the SFML lib
17:26:28 <enterprisey> http://hackage.haskell.org/package/unicode-names-3.2.0.0 exists
17:26:34 <dreamer_> is actually really good and works on windows
17:26:45 <enterprisey> but sadly it's Unicode 3.2.0 - in the middle of emailing the maintainer to see if I can put up the 11.0.0 data
17:26:54 <enterprisey> ICU is a little heavyweight for this :p
19:00:00 * hackage vfr-waypoints 0.1.0.1 - VFR waypoints, as published in the AIP (ERSA)  http://hackage.haskell.org/package/vfr-waypoints-0.1.0.1 (qfpl)
19:19:53 <dreamer_> oh boy
19:20:13 <dreamer_> I have a stack setup with a local package
19:20:16 <dreamer_> stack repl works fine
19:20:19 <dreamer_> stack build does not
19:47:51 <Denommus> hi
19:55:43 <Denommus> what would be a good SDL binding for Haskell?
19:55:56 <Denommus> or should I use some other library?
20:00:31 <Solonarv> @hackage sdl2
20:00:31 <lambdabot> http://hackage.haskell.org/package/sdl2
20:00:40 <Solonarv> Denommus see above
20:02:41 <Denommus> cool, thanks
20:04:19 <Solonarv> there are also bindings for the "extra" sdl2 libraries (sdl2-ttf, -image, etc)
20:10:30 <Denommus> the author of reactive-banana made another FRP library, didn't he?
20:10:44 <Denommus> what was the name of the library, again? I don't remember
20:11:36 <Solonarv> neither do I, I know very little about anything FRP related
20:18:38 <Denommus> it was the 1.0.0.0 version of the library that introduced the changes, I thought it was a new library
20:44:19 <mjrosenb> is there a way to implement the knuth/fischer/yates shuffle in better than O(N log N) in haskell?
20:49:44 <glguy> Sure, just use an array like in the original
20:54:23 <mjrosenb> which array? I assume I don't want an immutable array.
20:56:12 <glguy> right
20:57:13 <mjrosenb> IIRC, there's an IOArray, but I'd prefer this not to be in IO.
20:57:31 <glguy> Then you can use ST and pass in a random number generator
21:00:31 <dmwit> mjrosenb: random-shuffle, vector-shuffling on Hackage
21:02:07 <mjrosenb> dmwit: random-shuffle looks like it uses a tree internally.  I haven't done a thorogh analysis, but trees are usually O(n log n).
21:02:31 <dmwit> Yes, random-shuffle is O(n log n).
21:02:41 <dmwit> But it is O(1) implementation time.
21:03:14 <dmwit> (vector-shuffling is really O(n), and still cheap on implementation time.)
21:03:58 <johnw> gonz_: nothing that's current; I don't mirror Hackage anymore
21:04:42 <dmwit> Then again, if you *really* care about speed you're gonna want to avoid StdGen and friends, so maybe you get to do it yourself anyway.
21:06:09 <mjrosenb> huh, stdgen is slow?
21:06:40 <dmwit> v. slow
21:06:48 <mjrosenb> exciting.
21:07:37 <mjrosenb> I'm likely going to end up shuffling several billion lists of 3-20 elements :-/
21:08:01 <mjrosenb> the previous implementation created a new StdGen per list :-D
21:08:06 <pdxleif> There's bytearray things that use unsafePerformIO for their actions.
21:08:32 <dmwit> Well, that's certainly going to be slow, never mind probably badly distributed.
21:08:34 <mjrosenb> I ripped out that code before I managed to get the profiler working, unfortunately.
21:09:19 <nshepperd> if stdgen is slow what should we use instead
21:09:36 <mjrosenb> dmwit: I suspect the distribution wasn't all that bad.
21:09:45 <dmwit> mwc-random is the most popular alternative.
21:09:55 <dmwit> mjrosenb: How did you create a new StdGen per list?
21:11:18 <dmwit> There's also mersenne-random-pure64, pcg-random, mersenne-random, and various implementations of cryptographic random generators.
21:11:30 <mjrosenb> dmwit: each list has a unique key.  I made sure the keys were decently well distributed over the INT range, seeded the generator with the key, and I thought of dropping the first few elements, but I ultimately decided that it probably wouldn't be worth it.
21:12:00 <dmwit> That's certainly better than some ways of doing it.
21:14:31 <glguy> mjrosenb: This doesn't use the advice about better random generators, but here's what a mutable shuffle would look like: https://gist.github.com/glguy/c067a2cd4b9e08bd51215393fcb3b315
21:16:57 <mjrosenb> so, fun puzzle... the thing that I want to shuffle doesn't begin life as a list, it begins life as a bitset...  I'm somewhat convinced that there should be a fast way to select a random bit from a bitset given a random number, but I haven't foud it yet.
21:18:15 <mjrosenb> glguy: danke.
21:19:46 <dmwit> glguy: If you decrease hi instead of increasing lo you only need one index.
21:20:07 <glguy> that probably save some math in the random number generation, too
21:20:13 <glguy> all around a good suggestion :)
21:21:14 <dmwit> I'd be kind of impressed if `randomR (0, b)` did less arithmetic than `randomR (a, b)`.
21:21:16 <nshepperd> mjrosenb: if your bitset is dense, you can just generate a random index, check if that bit is set, if so return it, else repeat
21:22:30 <mjrosenb> nshepperd: it'll start out dense, but as I remove things, the chances of hitting something will get lower.
21:22:38 <nshepperd> which completes in O(1/a) steps, where a is the fraction of slots in the set that are full
21:22:50 <nshepperd> ah, then better not do that
21:23:05 <mjrosenb> I suppose I can mitigate by switching to a different method, but there's probably a better way
21:23:49 <mjrosenb> the best I've thought of is to do a rotate right by my seed mod 32, then take the lowest bit, and shift back to get the original position
21:24:03 <dmwit> What's a bitset?
21:24:20 <nshepperd> a set represented by Vector Bool
21:24:22 <mjrosenb> but the distribution on that is pretty awful if the whole bitset is 0x0003
21:24:50 <nshepperd> usually packed into a Word64 or something
21:26:40 <dmwit> So you are looking for a way to get a randomly shuffled list of indices into the 1 bits in a Word64-ish thing?
21:27:35 <mjrosenb> ja.
21:29:06 <glguy> so... shuffle a list of indicies?
21:29:16 <halogena1dtoast> Any suggestions for refactoring this Yesod handler: https://gist.github.com/halogenandtoast/ad55babf6549364feec1ebebe829f299
21:29:32 <halogena1dtoast> It might be fine as is, just wondering if there are any practices or patterns I could be applying
21:30:55 <mjrosenb> glguy: right. my question was if there is a better way to extract the bits one at a time randomly than doing that.
21:31:40 <dmwit> Yeah, shuffle a list of indices is probably going to be the best. You might be able to get away with never generating the unshuffled list using something like  https://graphics.stanford.edu/~seander/bithacks.html##SelectPosFromMSBRank but it's not clear to me whether the extra cost of repeatedly selecting will pay for itself in the reduced allocations.
21:37:15 <glguy> if you have significantly more 0s or 1s you can randomly pick that many indexes from a list
21:37:21 <glguy> and then set those indexes
21:37:27 <glguy> so that'd be a little faster
21:39:23 <glguy> and then set or clear those bits in the bitset
21:42:26 <mjrosenb> glguy: huh, that is neat... probably not actually fast, but definitely neat.
21:43:07 <glguy> just definitely faster than shuffling all the indexes and then recreating the bitset
21:43:46 <mjrosenb> err, dmwit sent that link... I can remember names.
21:51:48 <pdxleif> Hrmph. Found myself writing 'join <$> traverse (const foo) bar', when I could've been writing 'bar *> foo'
21:52:14 <pdxleif> In my defense, that started off as 'traverse foo bar', but then I made 'foo' return a 'Maybe'
21:57:17 <pdxleif> err, n/m. I suppose I was wishing for a sort of traverse + *>
22:00:39 <dminuoso> I have a tree and want to do a kind of structure preserving "filter" of sorts. Some kind of `homomorphicFilter :: (a -> Bool) -> Tree a -> Tree a` where the preserved structure is ancestory.
22:00:51 <dminuoso> Without spoonfeeding me a full blown solution, can someone nudge me in the right direction here?
22:01:19 <mjrosenb> dminuoso: binary tree or N-ary tree?
22:01:22 <dminuoso> N-ary
22:02:19 <cocreature> dminuoso: what kind of tree is this? are the "a" values only in the leaves or also in inner nodes?
22:02:35 <dminuoso> The leaves are also in inner nodes
22:02:58 <dminuoso> A multi-way tree, in which every node has values
22:03:03 <cocreature> you probably will have to go for something like (a -> Bool) -> Tree a -> [Tree a]
22:03:18 <cocreature> otherwise you are going to have trouble handling the case where I remove your root node
22:04:51 <byorgey> (a -> Bool) -> Tree a -> [Tree a]  will also make the recursion work out nicely, since if you filter out a node you need to splice in all its (filtered) children into the list of siblings
22:04:57 <cocreature> you should then be able to mapConcat that over the children
22:05:03 <cocreature> eh concatMap
22:06:18 <pdxleif> @hoogle IO (Maybe b) -> Maybe a -> IO (Maybe b)
22:06:18 <lambdabot> Control.Concurrent.Async race :: IO a -> IO b -> IO (Either a b)
22:06:19 <lambdabot> Control.Concurrent.Async concurrently :: IO a -> IO b -> IO (a, b)
22:06:19 <lambdabot> Network.AWS.Prelude (.!
22:06:42 <dminuoso> byorgey, cocreature: Ah thanks, that helped a lot. That seems to be the way to go indeed, thanks. =)
22:06:42 <cocreature> pdxleif: what is that supposed to do?
22:08:37 <cocreature> it’s of nice how changing type signatures to be able to handle edge cases often also simplifies everything else
22:08:56 <pdxleif> cocreature: Basically like *> on the two Maybe's - the "a" is usless to me. Only, I only want to run the IO action if "Maybe  a" is "Just".
22:09:10 <pdxleif> The "IO (Maybe b)" action, that is.
22:10:02 <cocreature> :t \a b -> if isJust b then a else pure Nothing
22:10:04 <lambdabot> Applicative f => f (Maybe a1) -> Maybe a2 -> f (Maybe a1)
22:10:09 <cocreature> I wouldn’t try to codegolf this
22:11:22 <pdxleif> what I have now is "join <$> traverse (const fb) fa"
22:11:36 <cocreature> that looks way harder to read than what I just showed you
22:11:38 <pdxleif> that if statement looks more understandable
22:11:42 <pdxleif> yeah
22:11:42 <cocreature> and it’s not even significantly shorter
22:12:14 <pdxleif> I started off with "traverse (const fb) fa", but then I made fb into a Maybe so I needed to add the join...
22:12:23 <pdxleif> thanks
22:12:31 <cocreature> np
22:14:23 <pdxleif> I guess I thought, since I end up with a Maybe, fa should be a Maybe somehow, so I can leverage / chain that... But I guess it gets ridiculous-looking
22:17:34 <rotaerk> :t guardM
22:17:35 <lambdabot> error:
22:17:35 <lambdabot>     • Variable not in scope: guardM
22:17:35 <lambdabot>     • Perhaps you meant ‘guard’ (imported from Control.Monad.Writer)
22:18:37 <cocreature> :t \a b -> runMaybeT (guard b *> MaybeT a)
22:18:38 <lambdabot> error:
22:18:38 <lambdabot>     Variable not in scope: runMaybeT :: f0 b0 -> t1
22:18:38 <lambdabot> error:
22:18:46 <cocreature> @let import Control.Monad.Trans.Maybe
22:18:47 <lambdabot>  Defined.
22:18:48 <cocreature> :t \a b -> runMaybeT (guard b *> MaybeT a)
22:18:49 <lambdabot> Monad m => m (Maybe a) -> Bool -> m (Maybe a)
22:19:14 <cocreature> not particularly useful for this small example but if you have some larger context that you can lift in MaybeT, then it might make sense
22:19:36 <rotaerk> yeah
22:21:07 <cocreature> also I still get pissed off everytime I use guard and have to import Control.Monad instead of Control.Applicative :/
22:21:15 <rotaerk> heh
22:21:37 <pdxleif> There was a tween with a different version of "when" that might be useful: https://twitter.com/ndm_haskell/status/1009172520816308226
22:23:26 <pdxleif> forever and void and stuff are still defined in Control.Monad though neither use Monad.
22:23:56 <cocreature> yeah we should at least reexport them from Control.Applicative
22:25:26 <pdxleif> how do I tell ghc to import a tweet? maybe there's a cabal option for that...
22:25:55 <dminuoso> Import a tweet?
22:25:56 <rotaerk> >.>
22:26:28 <dminuoso> pdxleif: Surely {-# LANGUAGE Twitter #-} will work for you.
22:28:16 <rotaerk> :t arr
22:28:17 <lambdabot> Arrow a => (b -> c) -> a b c
22:34:06 <anohigisavay> hi. i'm still struggling in understanding "A monad is a monoid in the category of endofunctors"
22:34:22 <anohigisavay> what's the identity element in a monad?
22:34:33 <anohigisavay> in Haskell?
22:36:47 <dminuoso> anohigisavay: The monoidal structure lies in functor composition.
22:37:03 <dminuoso> anohigisavay: Do you know :.:?
22:37:19 <dminuoso> IO (IO a) = (IO :.: IO) a
22:38:15 <dminuoso> `join` smashes these together
22:40:23 <dminuoso> anohigisavay: So the monoidal category is equipped with functor composition as its tensor
22:40:32 <dminuoso> whereas Identity takes the role of identity in the monoidal category
22:40:56 <dminuoso> a monoid in a monoidal category is some object `m` equipped with two morphisms μ and η
22:41:05 <pdxleif> pure?
22:41:11 <dminuoso> μ : m x m -> m
22:41:11 <anohigisavay> _(:з」∠)_
22:41:29 <dminuoso> η : I -> m, where I is the identity of the monoidal category
22:41:39 <dminuoso> does this look monoidish to you?
22:41:55 <anohigisavay> yes i think so
22:43:07 <anohigisavay> dminuoso, by tensor do you mean the binary operation between two elements?
22:49:16 <nshepperd> i think tensor is the × in 'µ : m × m -> m'
22:51:01 <nshepperd> in the normal algebra definition of a monoid, the tensor is (,) cartesian product, so that you have 'µ : (m, m) -> m' which means it's a binary operator on m
22:51:29 * hackage persistable-types-HDBC-pg 0.0.3.4 - HDBC and Relational-Record instances of PostgreSQL extended types  http://hackage.haskell.org/package/persistable-types-HDBC-pg-0.0.3.4 (KeiHibino)
22:51:33 <dminuoso> anohigisavay: The joke you cited is a bit badly phrased frequently.
22:51:47 <dminuoso> anohigisavay: A more correct way of stating it is: A monad is a monoid in a monoidal category of endofunctors.
22:51:58 <dminuoso> anohigisavay: monoids in monoidal categories are a certain construct.
22:52:59 <dminuoso> So in our case the monoidal category of endofunctors is a category where every object is an endofunctor, and morphisms between them are natural transformations.
22:53:30 <dminuoso> Because its demanded to be a monoidal it needs a bifunctor/tensor. There's a couple of choices here. One choice, the functor composition, will give rise to monads.
22:53:43 <dminuoso> So you have (Endo, :.:, Identity) as the monoidal category
22:56:32 <anohigisavay> that's way beyond my knowledge. i may need to learn more about category theory before i ask _(:з」∠)_
22:56:56 <dminuoso> anohigisavay: Do you have some rudimentary category theory knowledge?
23:00:28 <anohigisavay> dminuoso, categories, morphisms, functors, natural transformations
23:00:30 <anohigisavay> that's all i know
23:41:18 <halogena1dtoast> I asked earlier, but perhaps the channel wasn't as lively, if you saw my previous request then apologies for the repeat. I was wondering if anyone had any refactoring suggestions for this Yesod Handler: https://gist.github.com/halogenandtoast/ad55babf6549364feec1ebebe829f299
23:41:30 <halogena1dtoast> It might be fine as it is, but wondering if there are any best practices I might be missing here.
23:41:41 <halogena1dtoast> Either Yesod best practices or general Haskell ones.
23:43:49 <cocreature> looks like you could throw in a MaybeT and a guard but whether that’s a significant improvement is debatable
23:48:39 <halogena1dtoast> I considered the MaybeT, but I think the fact that I "want" a Nothing value in the last conditional seemed counterintuitive
23:48:49 <halogena1dtoast> :t guard
23:48:50 <lambdabot> Alternative f => Bool -> f ()
23:48:57 <cocreature> right for that you would use guard and isNothing
23:49:38 <tdammers> there's also the debatable approach of (ab)using exceptions for validation failures
23:50:10 <halogena1dtoast> tdammers: I had that originally but didn't like it in this case because I didn't have much more information than SqlError
23:50:28 <dminuoso> halogena1dtoast: You could throw a more specific exception.
23:51:18 <halogena1dtoast> dminuoso: the error is thrown by insert in this case.
23:51:48 <tdammers> so catch it and rethrow something more specific
23:55:09 <dminuoso> halogena1dtoast: what does `registrationToUser` do?
23:57:17 <halogena1dtoast> converts a Registration to a User
23:57:39 <halogena1dtoast> basically changes the type and creates a password digest
23:57:46 <halogena1dtoast> from a plaintext password in the registration
23:58:51 <halogena1dtoast> My response time might be delayed, having a platform issue at the moment
