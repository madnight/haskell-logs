00:05:00 * hackage potoki-hasql 1.6 - Integration of "potoki" and "hasql".  http://hackage.haskell.org/package/potoki-hasql-1.6 (IrinaArtemeva)
00:14:11 <dminuoso> Would "composition of Kleisli arrows" be a better fit?
00:27:04 <osa1> anyone know what's going wrong here with cabal https://lpaste.net/2220164879879241728 ?
00:27:43 <osa1> ohh I need --enable-tests in the second command
00:32:03 <capJKirk> OverloadedStrings doesn't seem to work properly... https://lpaste.net/8970223116785549312
00:32:29 <capJKirk> I'm getting an error in the last line with mconcat
00:33:08 <capJKirk> https://lpaste.net/1334972433706254336
00:33:19 <capJKirk> ^^^ the error
00:34:43 <osa1> capJKirk: use <> instead of ++
00:35:07 <capJKirk> osa1: hmm let me check
00:35:37 <Ariakenom> Hm it maeks sense to classify bottom as a side effect, right?
00:36:02 <capJKirk> osa1: man it worked... what was the problem?
00:36:19 <dminuoso> Ariakenom: What effect does it have?
00:37:06 <dminuoso> Ariakenom: Or perhaps more importantly how do you define "effects"?
00:37:08 <capJKirk> osa1: oh wait...
00:37:10 <osa1> capJKirk: see types of <> and ++. ++ is for concatenating lists (remember that String is [Char]) but you're concatenting Texts
00:37:51 <capJKirk> osa1: Ok, thanks :)
00:37:59 <osa1> yw
00:38:15 <Ariakenom> dminuoso: Well what is an effect is definitely part of my question :)
00:39:11 <Ariakenom> But putStrLn (x :: String) not working for x=undefined seems like an effect
00:40:27 <Ariakenom> Partiality being an effect seem intuitive
00:47:36 <dminuoso> Well the term "effect" is so frequently being used with a lot of hand waving.
00:47:43 <simon> if I want an integral type bounded to 32 bytes, how do I define that?
00:48:02 <dminuoso> simon: Data.Int.Int32
00:48:08 <simon> dminuoso, bytes, not bits.
00:48:37 <dminuoso> simon: Do you need to use this in arithmetic?
00:49:33 <simon> dminuoso, in practice I would probably only need to do that on smaller numbers.
00:50:04 <Ariakenom> You can newtype Integer and truncate on operations. A bit of typing though
00:50:31 <mniip> data Word256 = W256# Word64# Word64# Word64# Word64#
00:51:12 <simon> mniip, funny, I was just looking at finite-typelits. :)
00:51:17 <simon> (for something related)
00:52:06 <mniip> for finite vectors?
00:52:07 <simon> mniip, can I make that Word256 an instance of Integral?
00:52:11 <simon> yes.
00:52:38 <mniip> vector-sized?
00:52:55 <simon> I have an AST definition with a PUSHN Integer, but really only N in [1,32] is supported.
00:53:08 <mniip> sure you can make that an instance of Integral if you implement the arithmetic yourself
00:53:38 <Ariakenom> Word256 is more typing than going via Integer. Word256 probably uses less memory but will likely have slower ops.
00:54:20 <simon> and an auxiliary push :: Integral i => i -> Opcode with a boundary check built in.
00:56:11 <mniip> Ariakenom, questionable
00:56:21 <simon> someone on #haskell-beginners (I forgot who, unfortunately) suggested that my Integer was suspect.
00:56:44 <Ariakenom> which part? runtime speculation yes very
00:57:03 <mniip> if you implement it with Word# using primitive operations it might be faster than FFI to libgmp
00:57:11 <mniip> with its variable limb size arithmetic
00:57:32 <mniip> not saying it will be but it has potential to be
00:57:49 <ZeuPiark> hello
00:58:22 <Ariakenom> mniip: Are there primitives for carry-handling? That will somehow use the flag
00:59:29 <Ariakenom> (on x86)
01:00:37 <simon> mniip, so there are no shortcuts to making this Word256 an instance of Integral?
01:01:21 <mniip> no
01:01:26 <mniip> Ariakenom, there are
01:01:58 <mniip> % :t plusWord2#
01:01:59 <yahb> mniip: Word# -> Word# -> (# Word#, Word# #)
01:02:13 <mniip> % :t timesWord2#
01:02:14 <yahb> mniip: Word# -> Word# -> (# Word#, Word# #)
01:03:15 <simon> mniip, do you by chance do any Haskell stuff on Ethereum?
01:04:03 <mniip> no
01:04:40 <simon> okay, just checking. :)
01:37:19 <quicksilver> if you implement Word256 with hardware level vector ops it would be way faster than libgmp
01:37:23 <quicksilver> not saying that's easy to do, mind you.
01:38:03 <quicksilver> fortunately if you just want it to work, someone else has done the work for you
01:38:04 <quicksilver> http://hackage.haskell.org/package/largeword-1.2.5/docs/Data-LargeWord.html
01:42:45 <Ariakenom> quicksilver: does it have benchmarks?
01:46:25 <Ariakenom> relevant https://gmplib.org/manual/Assembly-SIMD-Instructions.html
01:47:20 <quicksilver> the package I linked above is pure haskell. No SIMD.
01:48:19 <quicksilver> that's an interesting link but given than SSE2 is now 17 years old I wonder if that is a fully current assessment of the vector ops on modern CPUs? :)
01:49:25 <quicksilver> I really know nothing about this so I'm just guessing. But given the important of integer math in encryption algorithm and the existence of hardware acclerated AES256, I am guessing that integer support is a bit better now.
01:50:02 <pacak> "type Foo a = Bool -> a" can be written as "type Foo = (->) Bool" so type signature "x :: Foo Int" is valid, how do I get rid of a in "type Pred a = a -> Bool"?
01:51:12 <Ariakenom> Indeed. But it's worth noting that gmp does aim at being fast at all sizes, not just huge. It's not impossible to beat in this case ofc. But probably not easy.
01:51:38 <quicksilver> pacak: you can't
01:51:39 <dminuoso> pacak: You cant in general.
01:51:53 <pacak> Thought so :(
01:52:20 <dminuoso> quicksilver: Is there a reason for that? It would be kind of cool to be able to write `type Predicate = (-> Bool)` (type sections would be nice)
01:53:06 <cocreature> would be kind of confusing once you start trying to make instances for those
01:53:57 <quicksilver> there is an incoherence problem with arbitrarily partially applied types and instances
01:54:03 <quicksilver> but I can't remember how to show the example
01:54:33 <quicksilver> newtypes keep us sane because they provide a syntactic cue the type inference algorithm can use to pick the right instance
01:54:43 <cocreature> even if incoherence wasn’t a problem (no idea if it is) type inference would be shitty
01:54:57 <dminuoso> Ah right, I forgot about type inference
01:55:29 <dminuoso> pacak: you could take the Op route
01:55:38 <dminuoso> @let type Predicate = Op Bool
01:55:38 <lambdabot>  .L.hs:158:18: error: Not in scope: type constructor or class ‘Op’
01:55:39 <lambdabot>      |
01:55:39 <lambdabot>  158 | type Predicate = Op Bool
01:55:57 <dminuoso> @let import Data.Functor.Contravariant
01:55:58 <lambdabot>  Defined.
01:55:59 <dminuoso> @let type Predicate = Op Bool
01:56:00 <lambdabot>  Defined.
01:56:49 <dminuoso> Although I suppose at that point you already have Predicate.. heh
01:57:18 <pacak> dminuoso: That's what I did, just with my own data type.
02:13:18 <jollygood2> hi. is there a pdf reading library from haskell? I just need to extract plain text out of a pdf, don't need formatting, etc
02:13:26 <jollygood2> s/from/for
02:15:03 <dminuoso> "I just need to extract plain text out of a pdf"
02:15:12 * dminuoso smiles regarding the choice of the word "just"
02:16:57 <pavonia> Yes, that's a highly non-trivial task
02:17:29 <lieven> a simple matter of programming
02:19:33 <dminuoso> We've had scenarios where the simplest course of action was rasterizing the image, and shoving it into OCR.
02:19:45 <dminuoso> That's how we had to "just extract plain text ouf of a pdf"
02:20:08 <lieven> yeah. these days, I would probably use calibre's ebook-convert foo.pdf foo.txt as a first stab
02:21:03 <jollygood2> dminuoso, PDF contains text, not a scanned image, so I think you may be exaggerating the complexity of the problem. but regardless of complexity, is there a haskell lib that does it?
02:22:02 <dminuoso> jollygood2: PDF has the notion of text streams yes. But without knowing more about your PDF its impossible to give a generalized solution.
02:22:55 <dminuoso> jollygood2: I've had to deal with PDFs using bogus charsets/font faces, overlapping text streams and so much nonsense. the most reliable general way is OCR.
02:24:38 <dminuoso> PDF was not designed with extraction in mind.
02:25:03 <jollygood2> select-all/copy in adobe reader does good enough job extracting the text that i can further parse with regular text parser. is there a haskell library that can approximate that?
02:25:15 <cocreature> there are various pdf to text tools that might or might not work for your usecase. I would just shell out to one of those
02:25:20 <lieven> about the best that can be said about it is that it is not Turing complete like PostScript
02:25:44 <jollygood2> let me rephrase my question, is there *any* haskell library that can extract any type of text from pdf?
02:26:01 <__monty__> lieven: Are you sure about that?
02:26:25 <Ariakenom> lieven: https://www.adobe.com/content/dam/acom/en/devnet/acrobat/pdfs/js_api_reference.pdf
02:26:56 <cocreature> jollygood2: just pick your favorite command line tool that extracts text from pdf and call that from your Haskell app
02:27:21 <quicksilver> jollygood2: you can take a look at http://hackage.haskell.org/package/pdf2line and https://hackage.haskell.org/package/pdf-toolbox-core
02:27:25 <lieven> Ariakenom: yeah before they added a whole fucking language to it
02:27:26 <quicksilver> but I have no experience of either
02:27:52 <cocreature> pdf2line doesn’t have an API either afaict so it’s not different from shelling out to some other tool
02:28:50 <dminuoso> pdf-toolbox might work, but you have to figure out how to piece text together
02:37:30 * hackage servant 0.14, servant-server 0.14, servant-client-core 0.14 (phadej): https://qbin.io/diff-diet-5kln
02:39:00 * hackage servant-client 0.14 - automatical derivation of querying functions for servant webservices  http://hackage.haskell.org/package/servant-client-0.14 (phadej)
02:39:30 <Boreeas> Hi, how do I express infinite iteration over monads? More specifically, I want to draw random numbers until I find a suitable candidate
02:40:09 <Boreeas> I thought maybe `forever $ randomRIO (lo, hi)` is what I want, but apparently this can't be evaluated lazily?
02:42:47 <Ariakenom> :t \x -> sequence . cycle [x]
02:42:48 <lambdabot> error:
02:42:48 <lambdabot>     • Couldn't match expected type ‘a1 -> t (m a2)’
02:42:48 <lambdabot>                   with actual type ‘[a]’
02:43:39 <Ariakenom> :t \x -> sequence $ cycle [x]
02:43:41 <lambdabot> Monad m => m a -> m [a]
02:44:14 <dminuoso> Boreeas: Mmm something like untilM' from monad-loops?
02:44:48 <dminuoso> oh wait no more like iterateUntil
02:45:04 <dminuoso> @import Control.Monad.Loops
02:45:04 <lambdabot> Unknown command, try @list
02:45:06 <dminuoso> @let import Control.Monad.Loops
02:45:07 <lambdabot>  Defined.
02:45:14 <dminuoso> :t iterateUntil
02:45:16 <lambdabot> Monad m => (a -> Bool) -> m a -> m a
02:46:34 <Boomerang> Boreeas: How about using `randomRs` instead? `do gen <- getStdGen; return (randomRs (lo, hi) gen)`
02:48:04 <Boreeas> Does that help me? I don't mind using the global rng.
02:48:45 <Boreeas> dminuoso: Thanks, that looks good
02:48:52 <Ariakenom> :t forever -- this doesnt return anything
02:48:53 <lambdabot> Applicative f => f a -> f b
02:49:44 <dminuoso> Boreeas: You could trivially write this yourself though iterateUntil p m = do { a <- m; if p a then pure a else iterateUntil p m }
02:51:02 <Boomerang> I think it helps because `randomRs` already gives you an infinite list, so then it's just a matter of filtering it :)
02:51:54 <Boreeas> Oh, true, didn't think of that
02:53:05 <pally> @let cities = ["Hong Kong", "Tokyo", "Hamburg", "Munchen"]
02:53:07 <lambdabot>  Defined.
02:53:29 <pally> > delete "Hamburg" cities
02:53:31 <lambdabot>  ["Hong Kong","Tokyo","Munchen"]
02:53:41 <pally> > cities
02:53:43 <lambdabot>  ["Hong Kong","Tokyo","Hamburg","Munchen"]
02:54:03 * quicksilver <3 immutability
03:01:16 <pally> quicksilver, I need to maintain a graph using something like [(String, [String])]  -- or something like that b/c I am only interested in out-going flights
03:02:00 * hackage expressions 0.1.8 - Expressions and Formulae a la carte  http://hackage.haskell.org/package/expressions-0.1.8 (jakubdaniel)
03:02:04 <pally> quicksilver, how can I reasonably maintain it if it is immutable?
03:07:17 <pally> anyone else have a suggestion?
03:12:07 <pavonia> Perhaps you are looking for mutables variables like MVar or IORef?
03:12:24 <Boomerang> The simplest way without getting into state monads, or IO refs, is to just retun the graph everytime you want to modify it
03:12:55 <pally> Boomerang, yes, I don't want into state monads.
03:13:32 <pally> *don't want to get into...
03:13:47 <Boomerang> If your logic is already heavy on IO, an IORef/MVar is not the worst thing. But in general it's better if you can separate the pure logic of your application from the IO you need to do
03:15:25 <Boomerang> The same way `delete` returns "updated" version of the list. All your logic function can do the same. `filterByPopulation :: Int -> CityGraph -> CityGraph`
03:16:12 <quicksilver> pally: I would answer it at a different level
03:16:32 <quicksilver> pally: your functions calculate new versions of data structures from old ones
03:16:39 <pally> Boomerang, for what I want to do, is maintaining a graph of cities (and out-bound flights) a hairy matter?
03:16:46 <quicksilver> just get used to storing the new versions that get returned from your functions
03:16:51 <quicksilver> it's a clearer way to think about data flow
03:17:03 <quicksilver> once you're comfortable about the approach, then the state monad is just a different syntax for that
03:17:22 <quicksilver> which reduces the syntactical burden sometimes and makes some useful combinators available.
03:17:42 <quicksilver> "I don't want to get into state monads" is an interesting assertion. Why not?
03:17:52 <Boomerang> pally: Not at all, immutability is just something you have to get used to. :) Once you get used to it, you'll see it can "compose" pretty well
03:18:16 <quicksilver> I would step one is get used to the idea that functions (s -> s) or (a,s -> s) or (a,s -> b,s) are really natural composable ways to work
03:18:18 <pally> Boomerang, gets a lot of newcomers churning, me included ^^;
03:18:40 <quicksilver> step two is seeing that the state monad is just a set of combinators to make it easy to combine functions of those forms
03:20:10 <Boomerang> @let removeMunchenAndStartingByH = filter ((/= 'H') . head) .  delete "Munchen"
03:20:12 <lambdabot>  Defined.
03:20:23 <Boomerang> > removeMunchenAndStartingByH cities
03:20:26 <lambdabot>  ["Tokyo"]
03:21:37 <Boomerang> @let addCity = (:)
03:21:39 <lambdabot>  Defined.
03:22:47 <Boomerang> > foldr ($) cities [delete "Munchen", addCity "Brussels", addCity "London", delete "Brussels"]
03:22:49 <lambdabot>  ["Brussels","London","Hong Kong","Tokyo","Hamburg"]
03:23:01 <Boomerang> hehe
03:23:17 <Boomerang> foldl would be better for this example
03:23:20 <pally> what is /= ?
03:23:32 <Boomerang> The Haskell version of !=
03:23:36 <jollygood2> quicksilver thanks! it was pretty simple to extract text from pdf with pdf-toolbox. output isn't very pretty as far as human readability goes, but it is good enough to run through a parsec
03:23:51 <jollygood2> s/a//
03:23:58 <__monty__> Anyone know if there's a way to get the closure of all dhall files needed to evaluate an expression?
03:23:58 <quicksilver> jollygood2: yay :)
03:24:30 <dminuoso> jollygood2: glad it worked for you:)
03:24:51 <Boomerang> __monty__ strace and grep? :D
03:25:48 <pally> Boomerang, If I am not mistaken, your "removeMunchenAndStartingByH" is in what's called eta reduced form, right?
03:25:53 <__monty__> Boomerang: Ideally without having to evaluate the expression >.<
03:26:30 * hackage haskell-src-meta 0.8.0.3 - Parse source to template-haskell abstract syntax.  http://hackage.haskell.org/package/haskell-src-meta-0.8.0.3 (JonasDuregard)
03:28:39 <Boomerang> __monty__: I think dhall has a resolve command line option to resolve the imports without evaluating the expression. I don't think it would be too difficult to modify it so that it prints out all the imports
03:31:23 <__monty__> Boomerang: Thank you, all I get from the dhall-to-text --help is --explain.
03:31:27 <Boomerang> pally: Yes this is eta reduction, it is pretty common in Haskell. I do often forget it's not the most straight forward thing for newcomers :/
03:32:10 <pally> Boomerang, `filter` expects a boolean-valued function as its first argument.
03:32:22 <pally> ((/= 'H') . head) .  delete "Munchen"
03:32:23 <Boomerang> :t filter
03:32:24 <lambdabot> (a -> Bool) -> [a] -> [a]
03:32:41 <pally> : ((/= 'H') . head) .  delete "Munchen"
03:32:42 <Boomerang> It acts as a selecting function
03:32:46 <pally> :t ((/= 'H') . head) .  delete "Munchen"
03:32:47 <lambdabot> error:
03:32:47 <lambdabot>     • Couldn't match type ‘[Char]’ with ‘Char’
03:32:47 <lambdabot>       Expected type: [[Char]] -> [Char]
03:33:28 <Boomerang> :t ((/= 'H') . head) -- sorry I didn't mean to give you a confusing example
03:33:29 <lambdabot> [Char] -> Bool
03:34:19 <Boomerang> @let doesntStartWithH = (/= 'H') . head
03:34:20 <lambdabot>  Defined.
03:34:31 <pally> Haskell is really a whole different beast
03:34:32 <Boomerang> > doesntStartWithH "Tokio"
03:34:35 <lambdabot>  True
03:34:41 <Boomerang> > doesntStartWithH "Hamburg"
03:34:43 <lambdabot>  False
03:36:00 * hackage composition-prelude 1.5.0.5 - Higher-order function combinators  http://hackage.haskell.org/package/composition-prelude-1.5.0.5 (vmchale)
03:38:08 <pally> Boomerang, maybe it has to do with me not knowing what the `.` (dot) does.  I need that doesntStartWithH accepts a String as argument
03:38:25 <pally> and `head` will return the first letter
03:38:32 <Boomerang> :t (.)
03:38:33 <dminuoso> @src (.)
03:38:33 <lambdabot> (f . g) x = f (g x)
03:38:33 <lambdabot> (b -> c) -> (a -> b) -> a -> c
03:38:47 <pally> s/need/see/
03:39:51 <Boomerang> @let f str = head str /= 'H' -- This is probably a simpler version of the same function :-)
03:39:52 <lambdabot>  Defined.
03:39:58 <Boomerang> > f "Hello"
03:40:00 <lambdabot>  error:
03:40:00 <lambdabot>      Ambiguous occurrence ‘f’
03:40:00 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f’,
03:42:16 <jollygood2> :t not . isPrefixOf "h"
03:42:17 <lambdabot> [Char] -> Bool
03:42:43 <jollygood2> let f = not . isPrefixOf "H" in f "Hamburg"
03:42:48 <jollygood2> > let f = not . isPrefixOf "H" in f "Hamburg"
03:42:50 <lambdabot>  False
03:46:30 * hackage hasbolt-extras 0.0.0.11 - Extras for hasbolt library  http://hackage.haskell.org/package/hasbolt-extras-0.0.0.11 (ozzzzz)
03:48:11 <Boomerang> > isPrefixOf "h" "" -- Is this function total? Just curious
03:48:14 <lambdabot>  False
03:49:02 <jollygood2> > isPrefixOf "" ""
03:49:05 <lambdabot>  True
03:50:39 <quicksilver> > zipWith isPrefixOf ["H","S","M"] ["High","School","Musical"]
03:50:41 <lambdabot>  [True,True,True]
03:50:42 <jollygood2> I guess it kind of makes sense for that to return true
03:51:01 <jollygood2> empty string being prefix of any string, including an empty one
03:56:30 * hackage require 0.3.1 - Scrap your qualified import clutter  http://hackage.haskell.org/package/require-0.3.1 (NickSeagull)
04:13:28 <simon> quicksilver, thanks for pointing to Data.LargeWord!
04:16:25 <alexad> What's a nice simple clean way to define multiple entry points to a program in haskell, as type safely as possible? I was thinking of simply defining multiple main functions, but that seems obnoxious.
04:16:52 <pally> can someone write the eta expanded version of `let f = not . isPrefixOf "H" in f "Hamburg"`?
04:17:11 <pally> > let f x = not . isPrefixOf "H"  x in f "Hamburg"
04:17:14 <lambdabot>  error:
04:17:14 <lambdabot>      • Couldn't match expected type ‘a1 -> Bool’ with actual type ‘Bool’
04:17:14 <lambdabot>      • Possible cause: ‘isPrefixOf’ is applied to too many arguments
04:17:22 <isovector> i have a type family `Component a b` and my usage of it completely ignores `b`. however GHC complains that due to noninjectivity, it can't solve what `b` at the use-site. is there some way i can mark it as "who cares?"
04:17:26 <cocreature> pally: f x = not (isPrefixOf "H" x)
04:17:26 <alexad> I suppose I'm likely stuck with command line args though? What I want is to be able to run the application in "Prod, Dev, or Staging" 'mode' for which I have an ADT
04:17:26 <philippD> alexad: you can have the core of the project as a library and create multiple executable entries in your cabal file
04:17:41 <alexad> philippD, aaah, right of course
04:17:58 <alexad> sort of an app/ dir and a src/ dir defined both in the cabal file right?
04:18:14 <cocreature> for things like switching between prod,dev and staging a cli arg seems like a better solution tbh
04:18:25 <cocreature> is there a specific reason why you are trying to avoid that?
04:18:26 <isovector> like the instantiation of `b` doesn't change anything, so it seems like i should be able to mark it as incoherent or something?
04:19:16 <pally> this leads me to ask: why do you use '.' and when can you stick to just parenthesis?
04:19:52 <cocreature> pally: it’s a matter of taste. you can always stick to parenthesis. (.) just happens to be more convenient/readable in some cases
04:21:22 <dminuoso> pally: (.) focuses more about what your program is, whereas applying things by hand is more focused about data shuffling.
04:22:15 <alexad> cocreature, REAFY ALL THE TYPES
04:22:55 <cocreature> alexad: just make an ADT "data Environment = Dev | Prod | …" and then you have your type safety
04:23:00 * hackage servant-lucid 0.8.1 - Servant support for lucid  http://hackage.haskell.org/package/servant-lucid-0.8.1 (phadej)
04:23:07 <dminuoso> `(f . g . h) x` tells you something about a processing pipeline you put `x` into, where as f (g (h (x))) requires extra mental effort to see whats going on. You have to track parens, see what argument is being applied to what..
04:23:07 <alexad> cocreature, this is exactly what I have
04:23:31 <cocreature> alexad: ofc you need to deal with parsing the string into that but a) optparse-applicative helps a lot with that and b) mistyping the cli arg is not that different from mistyping the executable name imho
04:23:43 <cocreature> alexad: then I’m not sure what exactly you dislike about this approach?
04:23:45 <alexad> cocreature, I concede the second point.
04:24:14 <alexad> cocreature, nothing really, I just like trying to think about things in new ways. Hackathon at work, best time to experiment with things I haven't done
04:24:16 <cocreature> in fact you could get a better error message from a misspelled cli arg than from a missing executable
04:30:05 <quicksilver> alexad: launch the right but based on the value of $0
04:30:08 <quicksilver> and use symlinks
04:30:14 <quicksilver> that's the unix way :)
04:30:22 <MRd1> Hello
04:30:30 <quicksilver> simon: glad it was useful
04:31:11 <isovector> can i refine a `forall s. SomeTypeFamily s` so that it is `s of [S1, S2]. SomeTypeFamily s`?
04:33:00 <dmwit> isovector: not really
04:34:18 <dmwit> isovector: You can write `data SRepr a where S1 :: SRepr S1; S2 :: SRepr S2` and then use `(SRepr s, SomeTypeFamily s)`.
04:35:42 <MRd1> ....
04:35:42 <dmwit> (That's for positive position. For negative position you can use `(SomeTypeFamily S1, SomeTypeFamily S2)`.)
04:36:30 <isovector> dmwit: hmmmm. the real problem is i have a noninjective parameter in my type family that GHC is trying to instantiate, but it doesn't actually have any effect
04:38:20 <dmwit> Can you leave it out?
04:38:30 <alexad> cocreature, quicksilver thanks guys, I changed my mind anyway cause I don't want to complicate the docker shit later anyway XD
04:39:33 <isovector> nope. i haev a type family `TF s t`, and when `s in [S1, S2]`, `t` is unused, but used for `S3`. i am trying to write a function that keeps `s` polymorphic but only instantiates it at `S1` and `S2`
04:39:59 <isovector> "keeps `s` polymorphic -> uses `s` as rank 2"
04:46:16 <veverak> hi folks
04:46:24 <veverak> any tips for haskell bug that focuses on practice coding?
04:46:26 <veverak> ;)
04:47:06 <cocreature> veverak: do you mean a Haskell _book_ rather than a _bug_? otherwise I don’t understand the question :)
04:49:55 <alexad> is there a safe Read somewhere?
04:50:02 <cocreature> :t readMay
04:50:03 <lambdabot> error: Variable not in scope: readMay
04:50:12 <cocreature> :t readMaybe
04:50:13 <lambdabot> error: Variable not in scope: readMaybe
04:50:18 <cocreature> :t Text.Read.readMaybe
04:50:20 <lambdabot> Read a => String -> Maybe a
04:50:22 <cocreature> there we go :)
04:50:41 <alexad> ty
04:50:47 <alexad> I really need to use the new hoogle, god damn
04:51:38 <veverak> cocreature: book
04:52:03 <cocreature> veverak: haskell programming from first principles has a lot of exercises afaik
04:52:26 <cocreature> I think hutton’s book also has exercises
04:55:42 <veverak>  cool
04:56:01 <bahamas> anyone know why I'm seeing this https://lpaste.net/6695940141443186688?
04:59:03 <hpc> because you're looking at it :P
04:59:22 <cocreature> bahamas: I would guess that the warnings in gcc or clang or whatever is trying to include that header might have changed since GHC 7.10 was released
04:59:34 <cocreature> you might also want to consider using a more recent version of GHC. 7.10 is quite old by now
04:59:45 <hpc> ah, yeah
04:59:49 <__monty__> Can you used a method from an instance of a typeclass that's not exported in an importing module?
04:59:54 <hpc> you're on mac, i think ghc has had issues with clang in the past?
05:02:33 <bahamas> cocreature: this project is a template from the haskell book https://github.com/haskellbook/hello
05:02:49 <cocreature> bahamas: that doesn’t really change my recommendation :)
05:04:44 <hpc> bahamas: since you're using stack, it should be really easy to upgrade your ghc
05:05:39 <bahamas> ok, I changed stack.yaml to use lts-11.13
05:06:23 <hpc> btw 11.14 came out yesterday :P
05:07:13 <bahamas> I'm just learning how to build projects in Haskell, so I don't think I'm missing anything important
05:07:20 <hpc> yeah
05:08:36 <DigitalKiwi> I thought stack was supposed to just work and solve all problems
05:08:59 <hpc> stack is a reproducible build system
05:09:12 <cocreature> for some definition of reproducible :)
05:09:30 <hpc> if your problem is you can't make a build environment, stack definitely helps
05:09:38 <DigitalKiwi> it seems to reproducibly cause inconvenience
05:09:39 <hpc> but if your build environment has an issue, it'll be wrong all day long :D
05:10:04 <hpc> fixing most things is just a few lines of config though, instead of doing a bunch of environment-modifying cabal installs
05:13:00 <alexad> aah, my brain just broke. I cannot for the life of me think of what the following is...
05:13:09 <alexad> f a -> f b -> f (a, b)
05:13:24 <cocreature> :t liftA2 (,)
05:13:26 <lambdabot> Applicative f => f a -> f b -> f (a, b)
05:13:31 <alexad> cocreature, <3
05:16:03 <rzmt> i cant figure out how to get this to work lazily. I think i need to replace "sequence" with something else but i'm not sure what. https://lpaste.net/230380392195031040
05:17:32 <cocreature> rzmt: what do you mean by “making it work lazily”. do you want to start returning list elements from "main" before all requests have been performed?
05:18:39 <rzmt> yes
05:18:56 <cocreature> you probably want to look at some streaming library for that, e.g. "streaming", "conduit" or "pipes"
05:18:58 <rzmt> i'm using rate-limit module for the requests but i left it out from the example
05:40:13 <alexad> is there an already defined style for what is essentially "flip <$>"
05:40:14 <alexad> ?
05:40:23 <cocreature> :t (<&>)
05:40:25 <lambdabot> Functor f => f a -> (a -> b) -> f b
05:40:48 <alexad> perfect thanks
05:41:44 <cocreature> also the typesearch in the new hoogle is apparently shittier than I thought. even for an exact match lik "Functor f => f a -> (a -> b) -> f b" the first result is fmap and not (<&>)
05:42:15 <bahamas> for some reason running stack exec -- hello. anyone know what's wrong and how I can fix it?
05:42:43 <bahamas> I forgot one word: running the above command hangs
05:43:14 <cocreature> bahamas: maybe it’s just your "hello" executable that hangs?
05:43:22 <pally> >  let removeMunchenAndStartingByH = filter ((/= 'H') . head) .  delete "Munchen"
05:43:24 <lambdabot>  <no location info>: error:
05:43:25 <lambdabot>      not an expression: ‘let removeMunchenAndStartingByH = filter ((/= 'H') ....
05:43:48 <pally> > @let removeMunchenAndStartingByH = filter ((/= 'H') . head) .  delete "Munchen"
05:43:50 <lambdabot>  <hint>:1:1: error: parse error on input ‘@’
05:43:52 <bahamas> cocreature: doh.
05:44:34 <Boomerang> @let x = 2 -- pally :-)
05:44:35 <lambdabot>  Defined.
05:44:45 <pally> @let removeMunchenAndStartingByH = filter ((/= 'H') . head) .  delete "Munchen"
05:44:47 <lambdabot>  .L.hs:167:1: error:
05:44:47 <lambdabot>      Multiple declarations of ‘removeMunchenAndStartingByH’
05:44:47 <lambdabot>      Declared at: .L.hs:162:1
05:44:52 <paolino> hi, does it make sense to {#- INLINE c #-} where c = 16 , or the compiler does it already ?
05:45:37 <pally> vs.
05:45:46 <pally> @let removeMunchenAndStartingByH x = filter ((/= 'H') . head)  (delete "Munchen" x)
05:45:47 <lambdabot>  .L.hs:173:1: error:
05:45:47 <lambdabot>      Multiple declarations of ‘removeMunchenAndStartingByH’
05:45:47 <lambdabot>      Declared at: .L.hs:162:1
05:45:55 <paolino> @unlet
05:45:55 <lambdabot>  Define what?
05:46:10 <Hjulle> Is there any way to put type signatures on binds in do notation? e.g. something like "do { x :: Int; x <- return 5; return x}"
05:46:31 <pally> anyway, I wanted to say the second version is much more natural for me, and that I am still having trouble reading definitions of the first form
05:46:35 <Boomerang> Hjulle: ScopedTypeVariables I think :)
05:46:40 <paolino> Hjulle: x :: Int <- ...
05:46:46 <Hjulle> Thx
05:46:50 <Boomerang> But you might need parenthesis
05:46:55 <paolino> with ScopedType...
05:46:59 <Boomerang> (x :: Int) <- ...
05:47:26 <dminuoso> Hjulle: I certainly hope you're not going to do `x <- return 5` anywhere in your code.
05:48:03 <Hjulle> dminuoso: Of course not. It was just the simplest example I could come up with. :)
05:48:13 <dminuoso> Okay :)
05:48:25 <paolino> yeah 5 is wrong, return 42
05:49:19 <dminuoso> Hjulle: Additional things you can keep in your bag of tools are: TypeApplications and inline annotations: do { x <- return (5 :: Int); return x }
05:49:41 <dminuoso> Not explicitly recommending them, just making you aware of their existence. :)
05:50:26 <rzmt> cocreature: you think this would work without library? Those look nice but a bit complicated for my use
05:50:33 <Hjulle> paolino: You see, it's a slightly more obscure Hitchhiker reference: http://refspace.com/quotes/Douglas_Adams/Q927
05:50:55 <pally> Boomerang, and I'll explain why.   When you specify `((/= 'H') . head) .  delete "Munchen"` it almost seems like you are saying this whole thing is predicate.  I get this impression from the `. delete "Munchen"` being drag into it.  In the second (more explicit) version, the reader can clearly the two pieces.
05:51:21 <pally> Boomerang, not really, complaining, but I am having trouble reading it.
05:51:59 <dminuoso> pally: you just dropped the filter function there.
05:52:17 <Hjulle> paolino: But you are still correct that 5 is wrong. :)
05:52:26 <pally> dminuoso, what do you mean?
05:52:40 <nowhere_man> Hey all
05:52:45 <Boomerang> pally: I think what might help is understanding how the precendence of different infix functions work. How would you understand `f x + y` ? `(f x) + y` or `f (x + y)`?
05:52:52 <cocreature> rzmt: not really or at least not without reimplementing parts of the library. IO is not lazy (technically there is lazy IO but it’s a can of worms) so you can’t just rely on lazyness
05:52:58 <pally> dminuoso, oh... I am just highlighting the part that got me confused.
05:53:31 <dminuoso> pally: The fact that you dropped it shows where the problem is. :-)
05:53:42 <nowhere_man> I don't understand something with $
05:53:46 <dminuoso> pally: rule #1 in Haskell: function application has highest precedence.
05:54:01 <Boomerang> pally: In my example the first one is correct `(f x) + y`, it's the same thing for the `.` infix operator :)
05:54:06 <nowhere_man> Shouldn't    map ((+) 1) $ take 5 [1..1000]     be the same as     map $ (+) 1 $ take 5 [1..1000]
05:55:14 <dminuoso> nowhere_man: No
05:55:26 <dstolfa> nowhere_man: definitely not
05:55:35 <dminuoso> nowhere_man: You can, roughly, think that $ acts as an opening paren with a closing paren to as far right as possible.
05:55:46 <nowhere_man> OK
05:56:05 <dminuoso> nowhere_man: so the last can be rewritten as: map ((+1) (take 5 [1..1000]))
05:56:20 <dstolfa> which doesn't typecheck
05:56:25 <paolino> Hjulle: I think x <- return 5 is not so bad and iirc you might use it taking apart existentials where let will fail
05:57:08 <jollygood2> > map ((+1) (take 5 [1..1000]))
05:57:10 <lambdabot>  error:
05:57:10 <lambdabot>      • Couldn't match expected type ‘a -> b’
05:57:10 <lambdabot>                    with actual type ‘[Integer]’
05:57:26 <jollygood2> you mean t(map (+1)) (take 5 [1..1000]) ?
05:57:40 <Hjulle> paolino: I was referring to the quote I linked. ;)
05:58:01 <dminuoso> pally: lets pretend for a moment this was written simpler:   filter predicate . delete "München"
05:58:32 <dminuoso> this associates as: (filter predicate) . (delete "München")
05:58:58 <pally> dminuoso, that helps :-)
05:59:24 <pally> I think it has to do with me working with parens all my life
05:59:38 <dminuoso> LISP developer?
05:59:48 <pally> w/o them I have a hard time parsing.
06:00:00 <Hjulle> paolino: But yes, there are cases where x <- return y might be useful.
06:00:20 <pally> dminuoso, yes, Racket/Scheme was the immediate section before Haskell
06:00:51 <pally> in my course I am doing, that is
06:00:55 <dminuoso> Yeah Haskell folks have the opposite mentality - we prefer less parens not more. :)
06:01:55 <paolino> dminuoso: that's what I thought for a long time but it's not so
06:03:03 <paolino> my coworker is confused by ($) and prefer parens, in the end.
06:03:27 <dminuoso> pally: things get a bit quirker when you use multiple operators and rely on their fixity. For example this might be a common idiom to some: f . g . h . i $ x
06:03:56 <dminuoso> paolino: At the very least I recommend getting used to ($) so you can read other peoples code.
06:04:42 <dminuoso> pally: while others might rather write that as `(f . g . h . i) x`, or perhaps just refactor it into a seperate binding
06:05:44 <paolino> I agree completely, I was referring to the evidence of the non-parens syntax being the best for everyone
06:06:00 * hackage wild-bind 0.1.2.1, wild-bind-x11 0.2.0.4 (debugito): https://qbin.io/gun-locked-q0m3
06:06:28 <dminuoso> Oh I didn't suggest it was a good idea - just implied it was a common mentality. :)
06:07:01 <Hjulle> paolino: It's mostly a question of how used you are with it. In my exprerience $ and "." becomes intuitive fairly quickly.
06:07:18 <paolino> well I cannot stand lines with unbalanced parens
06:07:51 <quicksilver> all mixing of infix operators is a burden - you have to have a mental model of how the precedence works. On the other hand if you have a good mental model it can be faster to read than balancing parens in your head
06:07:55 <pally> So I am not a lonely newbie, it seems like this is a common area where ppl have trouble with.
06:07:56 <quicksilver> therefore it's a tradeoff
06:08:53 <dminuoso> pally: that topic could be expanded to: how to write code that is easy to read
06:09:09 <dminuoso> And that's always going to be a tradeoff
06:10:56 <nowhere_man> Hjulle: I concur, as a Lisper fond of parens, I still quickly got used to reading and writing with $ and .
06:11:25 <alexad> I'm slowly going mad, can anyone spot my idiocy in here? https://pastebin.com/LMJR6qj4
06:12:37 <cocreature> alexad: what’s the type of slKeyText?
06:13:00 * hackage funflow 1.0.1 - Workflows with arrows  http://hackage.haskell.org/package/funflow-1.0.1 (nclarke)
06:13:09 <DigitalKiwi> alexad that you posted it as haskell but it is actually an error message
06:13:44 <alexad> cocreature, ByteString
06:14:04 <cocreature> alexad: you sure about that? the error message strongly suggests that it is of type Jwk
06:15:19 <alexad> slKeyText     <- C.lookup conf "IdentityKeys.Speedledger" :: IO (Maybe ByteString)
06:15:40 <dminuoso> alexad: Are you building with intero?
06:15:41 <cocreature> can you just show us the full code or at least a bit more context?
06:15:52 <alexad> cocreature, sure
06:16:18 <pzp> Why do we need for and forM and traverse and mapM?
06:16:54 <cocreature> pzp: we don’t, we only have them for historic reasons
06:17:08 <alexad> huh, I deleted some test stuff further up and the error disappeared
06:17:23 <pzp> cocreature: because applicative came after monad?
06:17:29 <dminuoso> alexad: You're not using intero, are you? =)
06:17:38 <cocreature> pzp: yeah
06:17:53 <alexad> dminuoso, sorry, went to respond to that... I believe intero requires stack? This is a plain cabal project.-
06:18:42 <nowhere_man> cocreature: what are they replaced with in Applicative?
06:19:42 <cocreature> nowhere_man: traverse is the Applicative version of mapM and for is the applicative version of forM
06:20:13 <Hjulle> Is there any proposal yet for introducing total pattern matching binds for do-notation in Haskell similar to that in Agda or Idris? http://docs.idris-lang.org/en/latest/tutorial/interfaces.html#pattern-matching-bind
06:20:13 <dminuoso> pzp: also the flipped versions exist just for convenience. Sometimes `for` looks a bit nicer than `traverse`
06:20:31 <dminuoso> pzp: especially when using with a lambda. e.g.:  for [1,2,3,4] $ \n -> ...
06:22:29 <vks_> I am a beginner in Haskell and reading "http://learnyouahaskell.com/syntax-in-functions". In the first example given for pattern matching, I get error on GHCI console. Has functional declaration changed in 8.4?
06:22:30 <vks_> Prelude> lucky :: (Integral a) => a -> String  <interactive>:1:1: error:     Variable not in scope: lucky :: a1 -> String Prelude>
06:23:06 <dminuoso> vks_: Use :{ ... :}  for multiline definitions in GHCi.
06:23:20 <dminuoso> vks_: Alternatively you can use a semicolon and put everything on a single line.
06:23:37 <Taneb> vks_: if you wrote what you were going to write in a file and then loaded it in, that would have worked fine.
06:23:53 <vks_> Let me try in a min
06:24:01 <Taneb> vks_: this is because GHCi likes things to be inputted all at once, which in GHCi normally means on one line
06:24:25 <Taneb> So it gets upset that you've given a type signature for something that doesn't exist
06:24:43 <Taneb> And if you did it the other way round it would get upset that you've given a type signature for something that already has a type, I think
06:25:03 <jollygood2> was 'x = 10' always legal in ghci? I think I was getting error in earlier versions
06:25:27 <cocreature> jollygood2: I think it was added in 8.0?
06:25:37 <cocreature> it definitely wasn’t always supported
06:25:56 <edwardk> jollygood2: they figured out how to make it parse more common-looking definitions like that a few releases ago
06:26:12 <vks_> Taneb_: Thank You. I loaded it in file and ghci did not complain.
06:26:36 <Taneb> vks_: :)
06:26:42 <Taneb> vks_: hope you enjoy Haskell!
06:28:15 <rzmt> cocreature: any tips how to fix this? I get compile error "Couldn't match type ‘ConduitT i0 String m0’ with ‘IO’" at 11:3 https://lpaste.net/3435208602476871680
06:28:49 <cocreature> rzmt: you can use liftIO to get from IO a to ConduitT i o IO r
06:29:00 <cocreature> *ConduitT i o IO a
06:37:17 <vks_> Integral, Int and Integer - What is the difference between these type classes ? I wanted to use a factorial function and wanted to restrict to Int but compiler did not allow. Code : https://lpaste.net/8964721401118326784
06:38:01 <dminuoso> vks_: two of them are not typeclasses but types.
06:38:10 <rzmt> cocreature: nice, it works now. How about getting requestSource to work recursively? `yieldMany requestSource` isn't enough
06:38:15 <dminuoso> vks_: Int is machine sized and bounded, Integer is unbounded but boxed and slower.
06:38:48 <dminuoso> vks_: You tried to use `Int` as a typeclass which doesn't work.
06:39:18 <p0lyph3m>  factorial :: Int -> Int || factorial :: Num x => x -> x
06:39:40 <vks_> dminuosa_: Got it. Is this hierarichal relationship documented in haskell docs?
06:40:01 <dminuoso> vks_: You can use tab completion to save yourself some typing and mistyping names. dmin<TAB> or something along those lines. :)
06:40:30 <vks_> dminuoso: New to IRC. Thanks !
06:44:53 <dminuoso> vks__: http://academic.udayton.edu/saverioperugini/courses/cps343/lecture_notes/images/typeclass.png
06:45:18 <dminuoso> The typo in Integral aside that appears to show the hierarchy of some of the haskell typeclasses
06:47:33 <vks__> dminuoso: Thank You. This is helpful.
06:56:30 * hackage tar-conduit 0.2.3.1 - Extract and create tar files using conduit for streaming  http://hackage.haskell.org/package/tar-conduit-0.2.3.1 (MichaelSnoyman)
06:56:45 <pally> +
07:04:02 <alexad> cocreature, what are the chances you can instantly tell me the name of this: (b -> b -> c) -> Either a b -> Either a b -> Either a c
07:05:04 <nowhere_man> I can't find it in the doc: how can I debug in GHCi a program working on its standard input?
07:05:14 <Taneb> :t liftA2
07:05:15 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
07:05:29 <Taneb> :t liftA2 :: (b -> b -> c) -> Either a b -> Either a b -> Either a c
07:05:30 * hackage servant-generic 0.1.0.2 - Specify Servant APIs with records.  http://hackage.haskell.org/package/servant-generic-0.1.0.2 (PatrickChilton)
07:05:30 <lambdabot> (b -> b -> c) -> Either a b -> Either a b -> Either a c
07:05:34 <Taneb> alexad: ^
07:05:50 <alexad> oh right it's a special case of liftA2
07:05:53 <alexad> ty
07:07:21 <alexad> <3
07:08:55 <cocreature> rzmt: just have requestSource call itself?
07:10:51 <alexad> Spend an hour trying to fix my types to all use Either with aeson so I can figure out where the parse is failing...
07:10:58 <alexad> Keyring could not be loaded, reason: Error in $: Failed reading: satisfy
07:11:01 <alexad> ... -_-
07:12:37 <butterthebuddha> "Yeah, I know, I know: the function returns a value representing an IO effect, which inverts the control: now the caller has explicit control over the effect (in imperative programming, it’s the callee that has control, which makes reasoning harder)."
07:12:54 <butterthebuddha> I don't really understand that statement
07:13:49 <nowhere_man> butterthebuddha: I would guess that when something returns an IO value, you as a caller can choose to execute it or not
07:14:16 <nowhere_man> in typical imperative programming, you call a function and it doesn't return an effectful function you might call, it does something
07:15:36 <butterthebuddha> nowhere_man: Uhh, you can choose to not execute a IO effect? Can you give me an example?
07:15:55 <mnoonan> @let butter = print "HI!"
07:15:56 <lambdabot>  Defined.
07:16:06 <mnoonan> ^ I didn't see "HI!" printed :)
07:16:22 <Ariakenom> > length [butter, butter, print "bye"]
07:16:22 <Taneb> > length [print 1, print 2, print 3]
07:16:25 <lambdabot>  3
07:16:25 <lambdabot>  3
07:16:26 <dminuoso> butterthebuddha: Haskell has no effects in the evaluation. That's kind of the point of IO.
07:16:39 <Ariakenom> :p
07:16:40 <dminuoso> butterthebuddha: `IO Int` is a *description* of an effect that, when executed, would produce an Int.
07:16:47 <nowhere_man> blew my mind when I got that, BTW
07:17:22 <butterthebuddha> mnoonan: but that's due to laziness right?
07:17:26 <dminuoso> butterthebuddha: And the trick to Haskell is, that something like `execute :: IO a -> a` does not exist. (Well it does, but we should not talking about that)
07:17:28 <butterthebuddha> You didn't call the function butter
07:17:28 <dminuoso> butterthebuddha: No.
07:17:37 <butterthebuddha> So Haskell didn't evaluate the definition
07:17:44 <dminuoso> You can evaluate it just fine.
07:18:00 <dminuoso> > let (!a) = print "1" in ()
07:18:02 <lambdabot>  ()
07:18:12 <mnoonan> butterthebuddha: yeah, Ariakenom and Taneb's examples are better
07:18:44 <dminuoso> mnoonan: in all fairness length doesn't need to evaluate the content of the list, just the spine.
07:18:50 <dminuoso> so lazyness could explain it.
07:19:32 <mnoonan> true
07:19:56 <dminuoso> butterthebuddha: You can experiment with the `pseq` primitive to force evaluation in GHCi.
07:20:11 <nowhere_man> in GHCi, I changed stdin to be a handle to a file, but getLine still reads from the terminal…
07:20:22 <dminuoso> butterthebuddha: `putStrLn "foo"` is an object that describes the effect of printing something. Evaluating that description does nothing.
07:20:46 <butterthebuddha> Right, you'd have to put it in the context of main
07:20:56 <Ariakenom> :t many getLine
07:20:57 <lambdabot> IO [String]
07:21:07 <butterthebuddha> But isn't that the same as calling printf from a function in C that doesn't get called by main?
07:21:32 <nowhere_man> butterthebuddha: main is just another IO
07:21:35 <dminuoso> butterthebuddha: No it's more analogous to passing the "name of the function" around.
07:22:07 <nowhere_man> Haskell's *runtime* takes the IO description in main and executes it
07:22:12 <butterthebuddha> nowhere_man: but with special compiler magic that actually causes the effects to happen?
07:22:31 <dminuoso> butterthebuddha: not compiler magic, its just the rts.
07:22:34 <butterthebuddha> dminuoso: I'm sorry, I'm confused :(
07:23:09 <nowhere_man> You can think of the core of your program's binary as an interpreter for IO
07:23:18 <dminuoso> butterthebuddha: getLine is not a function. It's a piece of paper that reads "Note to the RTS: When you see me, please get some input from stdin"
07:23:29 <dstolfa> butterthebuddha: IO is really just a "recipe" that is implemented using unboxed types in GHC and exposed as a monad to the programmer. somewhere deeper in the compiler (as is usually the case with programming languages), you implement a runtime that actually has effects
07:23:40 <dminuoso> butterthebuddha: Obviously you can duplicate that thing many times - but when that piece of paper ends up being thrown in the garbage can the RTS will be none the wiser.
07:24:45 <butterthebuddha> I understand all of this; here's where I'm getting confused - this might have been misinterpretation on my part but it seems you're implying that I can make a call to a function that returns an IO because of a call to some effectful computation
07:24:58 <mnoonan> there is some blog post that builds up a kind of mini-IO by hand that might help understand what is going on
07:24:58 <dstolfa> butterthebuddha: if you're familiar with erlang's BIFs, that's basically what you end up doing in the end, but in a bit of a different way
07:24:58 <butterthebuddha> and choose to have that effectful computation not produce any effects?
07:25:02 <mnoonan> can't find it right now :|
07:25:23 <dminuoso> The SPJ paper should be great
07:25:51 <dstolfa> butterthebuddha: haskell is CBN, so yes, you might end up with just a bunch of IOs that haven't been executed yet and are dispatched to the RTS all at once
07:26:17 <dstolfa> just as you might end up with a bunch of functions being composed, and if none of them is strict w.r.t. their arguments, you'll just do CBN all the way through
07:26:17 <butterthebuddha> dstolfa: but in what sense as the programmer do I have control over the effects?
07:26:33 <dminuoso> butterthebuddha: You can choose to throw the effects away, sequence them with other things..
07:26:54 <butterthebuddha> Also, what does CBN stand for?
07:26:59 <dstolfa> butterthebuddha: call by name, lazy eval
07:27:24 <butterthebuddha> dminuoso: Can you be more explicit about what "throw the effects away" means? Sorry, I'm just trying to make sure I don't misunderstand anythign
07:27:42 <pally> > applyArg :: a -> (a -> b) -> b
07:27:45 <lambdabot>  error:
07:27:45 <lambdabot>      Variable not in scope: applyArg :: a1 -> (a1 -> b1) -> b1
07:27:51 <hexagoxel> but if you have an IO Int, and you want to get at that Int, you don't have much of a choice really. There is no way to get that Int without executing whatever the IO part does.
07:27:55 <dminuoso> butterthebuddha: So let's say you have a function: f :: Int -> (IO (), Char)
07:28:06 <pally> oops. (nvm this one)
07:28:11 <dstolfa> > f :: Int -> (IO (), Char)
07:28:13 <dminuoso> butterthebuddha: You can apply that to an integer, use pattern matching to get the Char out - and disregard the IO () effect.
07:28:14 <lambdabot>  error:
07:28:14 <lambdabot>      Ambiguous occurrence ‘f’
07:28:14 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f’,
07:28:17 <dstolfa> argh
07:28:18 <dstolfa> what was it again
07:28:21 <dstolfa> not this again
07:28:29 <dstolfa> > foo :: Int -> (IO (), Char)
07:28:31 <lambdabot>  error:
07:28:31 <lambdabot>      • Variable not in scope: foo :: Int -> (IO (), Char)
07:28:31 <lambdabot>      • Perhaps you meant ‘for’ (imported from Data.Traversable)
07:28:45 <dstolfa> i give up
07:28:47 <dstolfa> i suck at lambdabot
07:28:50 <butterthebuddha> dminuoso: but if the IO () was due to a call to putStrLn for example, that will still print something right?
07:29:09 <dminuoso> butterthebuddha: No because the `IO ()` is the *description* of that printing action
07:29:17 <dminuoso> butterthebuddha: putStrLn is not a function you call and it prints things.
07:29:31 <jollygood2> butterthebuddha, here's an example of a difference. int x = puts("hi"); <- at the moment you called puts side effect of printing to stdout has been made. not so in haskell. let x = putStrLn "hello, world". x contains the action that prints to the screen. the act of calling putStrLn "hello, world" did not print to the screen, it just returned instructions in the form of IO () to do so. and this is not related to laziness, which 
07:29:49 <dmwit> > let f :: Int -> (IO (), Char); f n = (print n, toEnum n) in snd (f 32) -- does not print 32
07:29:51 <lambdabot>  ' '
07:30:51 <butterthebuddha> Oh. So given an IO, what must I explicitly do to it to execute it?
07:31:00 <dminuoso> butterthebuddha: fiddle it into `main`
07:31:09 <dmwit> butterthebuddha: Only `main` is ever executed. Any other `IO` actions you construct, but which do not figure into the chain of binds that makes up `main`, are not executed.
07:31:18 <pally> actually I do need help with this
07:31:29 <pally> @let applyArg :: a -> (a -> b) -> b
07:31:31 <lambdabot>  .L.hs:169:1: error:
07:31:31 <lambdabot>      The type signature for ‘applyArg’ lacks an accompanying binding
07:31:31 <lambdabot>      |
07:31:38 <pally> > applyArg :: a -> (a -> b) -> b
07:31:39 <lambdabot>  error:
07:31:40 <lambdabot>      Variable not in scope: applyArg :: a1 -> (a1 -> b1) -> b1
07:31:51 <dmwit> pally: You have to give an implementation, not just a type.
07:32:04 <dmwit> pally: Do you know how to implement it? (Do you want spoilers?)
07:32:27 <dmwit> ?let example :: Int -> Int; example x = 3*x + 5
07:32:28 <lambdabot>  Defined.
07:32:33 <dmwit> > example 70
07:32:35 <lambdabot>  215
07:32:35 <pally> yes it's `applyArg :: a -> (a -> b) -> b`
07:32:35 <pally> applyArg x = ($ x)
07:32:49 <pally> from https://stackoverflow.com/questions/19521246/what-does-mean-do-in-haskell
07:32:54 <dmwit> pally: See above for the syntax to use.
07:33:50 <dminuoso> butterthebuddha: so let's say your program was: `main = getLine` when you run that program the RTS will execute the getLine action and carry out the actual effect.
07:35:25 <dminuoso> butterthebuddha: Next up you might have: `main :: IO (); main = getLine >>= putStrLn` -- first we build a single IO () effect by taking the `getLine :: IO String` and plumbing it into `putStrLn :: String -> IO ()` - the result being a larger effect. If this program is ran, it execute the first action, place the result into the next function, determine that effect and run it too.
07:41:59 <alexad> butterthebuddha, I can recommend if you want a collection of programming exercises that really help one to grok various FP concepts
07:42:06 <pally> example taken from the above SOF answer
07:42:31 <pally> ?let applyArg :: a -> (a -> b) -> b ; applyArg x = ($ x)
07:42:33 <lambdabot>  Defined.
07:42:51 <pally> > applyArg 3
07:42:53 <lambdabot>  error:
07:42:53 <lambdabot>      • No instance for (Typeable b0)
07:42:53 <lambdabot>          arising from a use of ‘show_M688882654012430906026151’
07:43:15 <shapr> alexad: ooh, which collection?
07:47:33 <maerwald> how do you evaluate IO to NF? :>
07:51:44 <Boomerang> > applyArg 3 even
07:51:46 <lambdabot>  False
07:52:09 <Boomerang> > applyArg 3 odd
07:52:12 <lambdabot>  True
07:53:55 <pally> Boomerang, by now, i understand type signature, but since the body it's trying to match pattern `applyArg x` and that's why I invoke it as such
07:54:02 <pally> > applyArg 3
07:54:04 <lambdabot>  error:
07:54:05 <lambdabot>      • No instance for (Typeable b0)
07:54:05 <lambdabot>          arising from a use of ‘show_M559030206662384635026217’
07:54:39 <Boomerang> The issue is you can't show a function :)
07:54:44 <Boomerang> :t applyArg 3
07:54:46 <lambdabot> Num a => (a -> b) -> b
07:55:47 <pally> Boomerang, the next example in that SOF answer is also interesting
07:55:51 <pally> > map ($ 10) [(+1), (+2), (+3)]
07:55:54 <lambdabot>  [11,12,13]
07:56:00 <pally> :t map
07:56:02 <lambdabot> (a -> b) -> [a] -> [b]
07:56:19 <pally> my friend, `10` is not a function
07:56:42 <Boomerang> :t ($ 10)
07:56:43 <lambdabot> Num a => (a -> b) -> b
07:56:44 <alexad> shapr, Tony's https://github.com/data61/fp-course
07:56:45 <abs-zero[m]> :t fold
07:56:46 <lambdabot> (Monoid m, Foldable t) => t m -> m
07:57:13 <dmwit> pally: `10` is also not the argument given to `map`.
07:57:15 <shapr> alexad: oh that's cool
07:57:31 <pally> dmwit, it's not?
07:57:35 <dmwit> pally: no
07:57:40 <dmwit> `($10)` is
07:58:17 <dmwit> > map (applyArg 10) [(+1), (+2), (+3)] -- in your notation from above
07:58:19 <lambdabot>  [11,12,13]
08:03:25 <marvin2> butterthebuddha this might help with your undertanding. it builds a mini IO-like datatype on top of haskell's IO. http://web.archive.org/web/20171213122129/http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/
08:12:47 <vks__> alexad: Thank you for sharing fp-course
08:12:56 <alexad> vks__, no worries
08:13:20 <dminuoso> butterthebuddha: Incidentally this is what makes debugging Haskell code somewhat tricky. Luckily there are primitives that can do `IO a -> a`, but they are unsafe to use and generally exist for debugging and a few other things.
08:20:39 <marvin2> dminuoso in what way is Debug.Trace unsafe?
08:21:10 <pally> :t $
08:21:11 <marvin2> I know it uses unsafePerofrmIO under the hood, but I'm not sure how their use is unsafe in practice
08:21:11 <lambdabot> error:
08:21:11 <lambdabot>     parse error on input ‘$’
08:21:11 <lambdabot>     Perhaps you intended to use TemplateHaskell
08:21:14 <pally> :t ($)
08:21:16 <lambdabot> (a -> b) -> a -> b
08:21:29 <dminuoso> marvin2: well `trace` itself is not a big issue, but unsafePerformIO is as it allows you to circumvent the type syste
08:21:36 <marvin2> sure
08:22:29 <pally> Is it true to say even those parens are for better  readibility?
08:23:06 <philippD> pally which ones?
08:23:16 <pally> :t ($)
08:23:17 <lambdabot> (a -> b) -> a -> b
08:23:19 <marvin2> btw I wish there was a native support for something like Debug.Trace in ghci, that doesn't require adding temporary Show contrains everywhere
08:23:42 <philippD> pally: the ones arount ($) or the ones in the type (a -> b) -> a -> b
08:23:58 <philippD> pally: the answer would be no for both though :D
08:24:05 <pally> the ones in the type
08:24:31 <pally> I'll explain why I am asking this
08:24:55 <philippD> a -> b -> a -> b is the same as a -> b -> (a -> b) but not the same as (a -> b) -> a -> b
08:28:08 <dminuoso> marvin2: we have :print at least which is pretty cxool =)
08:28:50 <pally> okay let's try this again. so this is what `:t ($)` tells us
08:28:56 <pally> :t ($)
08:28:57 <lambdabot> (a -> b) -> a -> b
08:29:03 <pally> and I do:
08:29:17 <pally> > $ abs 3
08:29:19 <lambdabot>  <hint>:1:1: error:
08:29:19 <lambdabot>      parse error on input ‘$’
08:29:19 <lambdabot>      Perhaps you intended to use TemplateHaskell
08:29:27 <pally> > ($ abs 3)
08:29:29 <lambdabot>  error:
08:29:29 <lambdabot>      • No instance for (Typeable b0)
08:29:29 <lambdabot>          arising from a use of ‘show_M385346935543881866226393’
08:29:39 <dminuoso> pally: to use operators in prefix position you have to wrap them in ()
08:29:46 <dminuoso> > ($) abs 3
08:29:48 <lambdabot>  3
08:30:24 <philippD> yeah but what you just did is apply abs to ($)
08:30:30 <philippD> :t (($) abs)
08:30:31 <lambdabot> Num b => b -> b
08:30:40 <dminuoso> philippD: wrong way around.
08:30:44 <dminuoso> philippD: I applied ($) to abs
08:31:01 <nshepperd> it would be cool if ghc had some kind of debug compilation mode which makes everything printable
08:31:01 <dminuoso> `f x` means f is applied to x
08:31:03 <shapr> my abs are rich
08:31:18 * shapr does more Haskell exercise
08:31:24 <philippD> dminuoso yeah you're right
08:31:47 <nshepperd> propagating Show constraints everywhere out of some polymorphic function i'm trying to debug, then removing them again when done, gets really tedious
08:31:48 <philippD> the brackets in the type still matter
08:32:00 * hackage rio-orphans 0.1.1.0 - Orphan instances for the RIO type in the rio package  http://hackage.haskell.org/package/rio-orphans-0.1.1.0 (MichaelSnoyman)
08:33:14 <philippD> :t ($ 3)
08:33:15 <lambdabot> Num a => (a -> b) -> b
08:34:30 * hackage rio 0.1.3.0 - A standard library for Haskell  http://hackage.haskell.org/package/rio-0.1.3.0 (MichaelSnoyman)
08:34:53 <quicksilver> nshepperd: yes, it would.
08:36:24 <nowhere_man> is it OK to post a StackOverflow question here?
08:37:36 <mitchellsalad__> yeah
08:37:46 <dminuoso> nowhere_man: Probably yes. Though some people are not happy if you immediately repost questions all over the place, so its better to wait a bit until you are convinced you are not getting a response. =)
08:38:23 <pally> let's see the difference,
08:38:35 <pally> :t ($) 3
08:38:36 <lambdabot> Num (a -> b) => a -> b
08:39:34 <dminuoso> pally: the difference is basically: (\x -> x $ 3) vs (\x -> 3 $ x)
08:43:00 * hackage servant-multipart 0.11.2 - multipart/form-data (e.g file upload) support for servant  http://hackage.haskell.org/package/servant-multipart-0.11.2 (phadej)
08:46:06 <quicksilver> nowhere_man: it's fine IMO
08:46:15 <quicksilver> we like having interesting discussions about haskell and we like helping people
08:47:29 * hackage servant-swagger-ui-core 0.3.1 - Servant swagger ui core components  http://hackage.haskell.org/package/servant-swagger-ui-core-0.3.1 (phadej)
08:53:00 * hackage butter 0.1.0.4 - Monad Transformer for Asyncronous Message Passing  http://hackage.haskell.org/package/butter-0.1.0.4 (mpahrens)
08:54:30 * hackage forkable-monad 0.2.0.3 - An implementation of forkIO for monad stacks.  http://hackage.haskell.org/package/forkable-monad-0.2.0.3 (mpahrens)
08:59:50 <pally> I actually don't understand the second one.
08:59:55 <pally> :t ($) 3
08:59:57 <lambdabot> Num (a -> b) => a -> b
09:00:10 <pally> perhaps an usage example will help
09:01:17 <pally> the type parameter (a->b) is for which entity?
09:01:17 <nowhere_man> https://stackoverflow.com/questions/50931355/how-can-i-test-a-program-reading-from-stdin-in-ghci/50932360
09:02:35 <geekosaur> you told it to apply 3 as a function, so now it wants a Num instance for a function so it knows how to apply 3
09:03:32 <pally> geekosaur, but 3 is not a function, 3 is just 3 (a numeric literal).
09:03:45 <geekosaur> numeric literals are polymorphic
09:04:13 <geekosaur> internally it's (fromInteger (3# :: Integer)), where (3#) represents an internal representation
09:04:46 <geekosaur> ghc does not know that "numbers are just numbers". it knows that
09:04:48 <geekosaur> :t 3
09:04:49 <lambdabot> Num p => p
09:04:57 <geekosaur> so it looks for a Num instance for functions
09:06:00 <geekosaur> and being able to create that instance is sometimes even useful
09:07:19 <pally> geekosaur, as it stands, simply put, `$) 3` is really not what a person want
09:07:27 <pally> wants*
09:08:15 <geekosaur> it's not what you want
09:08:45 * [exa] thinking about Num (-> a) instance and matiyasevich theorem
09:09:06 <geekosaur> partial application is "not what a person wants". lazy evaluation is "not what a person wants". functional programming is "not what someone who knows OOP wants". etc.
09:12:15 <Cale> If we had an instance of Num for functions, then it would be possible to make sense of ($) 3
09:12:25 <Cale> and that's what the type is telling you
09:13:05 <nowhere_man> geekosaur: reminds me of an interesting talk, "From Dependency injection to Dependency Rejection", where Mark Seemann shows how just partial application in an impure fonctional language is a way of doing OOP dependency injection
09:13:09 <[exa]> gödel numbers yay
09:13:13 <Cale> 3 needs to be a function in order for that to make sense -- and it could be, were an appropriate instance of Num to exist
09:13:22 <pally> Cale, yes, and that concept is really foreign to me.
09:13:30 <Cale> Well, here let's make one
09:13:32 <geekosaur> which is the poont of what I said
09:13:41 <geekosaur> it's foreign to you. it's not nonsense.
09:13:44 <geekosaur> it has its uses
09:14:05 <geekosaur> (granted, not many. so you just don't define that instance)
09:15:06 <Cale> @let instance Num b => Num (a -> b) where { (f + g) x = f x + g x; (f * g) x = f x * g x; negate f x = negate (f x); fromInteger n x = fromInteger n; signum f x = signum (f x); abs f x = abs (f x) }
09:15:07 <lambdabot>  Defined.
09:15:37 <Cale> > (sin^2 + cos^2) 4.6
09:15:39 <lambdabot>  1.0
09:16:03 <[exa]> <3
09:16:11 <Cale> > (sin + 1) 1
09:16:13 <lambdabot>  1.8414709848078965
09:20:19 <[exa]> > (negate negate) 5
09:20:21 <lambdabot>  5
09:20:36 <[exa]> ok this is cool.
09:21:50 <electrocat> :O
09:21:58 <electrocat> cool :D
09:22:01 <Cale> > ($) 3 7
09:22:03 <lambdabot>  3
09:23:02 <wz1000> @let x = id
09:23:03 <lambdabot>  .L.hs:183:1: error:
09:23:03 <lambdabot>      Multiple declarations of ‘x’
09:23:03 <lambdabot>      Declared at: .L.hs:166:1
09:23:13 <maerwald> is there a haskell alternative to lambda-paste?
09:23:41 <geekosaur> wz1000, all the single-letter names are taken by simple-reflect
09:23:46 <geekosaur> :t x
09:23:47 <wz1000> > let x = id in (x^3 + 3*x^2 + 3) 10
09:23:48 <lambdabot> error:
09:23:48 <lambdabot>     Ambiguous occurrence ‘x’
09:23:48 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.x’,
09:23:49 <lambdabot>  1303
09:27:40 <pally> > (abs + abs) - 3
09:27:43 <lambdabot>  <Integer -> Integer>
09:27:45 <pally> > (abs + abs) -3
09:27:48 <lambdabot>  <Integer -> Integer>
09:31:04 <pally> Cale, can you briefly explain which entity the type parameter (a->b) constrains in your definition above?
09:31:49 <Cale> pally: hm?
09:31:55 <Cale> I don't understand your question
09:32:08 <Cale> I wrote an instance of Num for functions of type (a -> b)
09:32:39 <Cale> on the basis that we have an instance of Num for the type b
09:33:00 * hackage steeloverseer 2.0.2.0 - A file watcher and development tool.  http://hackage.haskell.org/package/steeloverseer-2.0.2.0 (SchellScivally)
09:33:03 <Cale> So, this allows us to do a few things: it defines the arithmetic operations like (+) and (*) for functions
09:33:23 <Cale> and it gives us the ability to interpret integer literals such as 3 as functions
09:33:34 <Cale> (in particular, they get interpreted as constant functions)
09:34:36 <pally> > (abs + abs) -3
09:34:39 <lambdabot>  <Integer -> Integer>
09:34:45 <Solonarv> there's actually a more general version of that instance: you can do the same thing for any Applicative, not just (->) a
09:36:07 <__monty__> Could someone take a look at this bit of the implementation of dhall? I don't understand how `zoom stack State.get` results in all of the imports recursively for an expression? (If that's even what happens.) https://github.com/dhall-lang/dhall-haskell/blob/master/src/Dhall/Import.hs#L657
09:36:36 <c_wraith> __monty__: are you familiar with zoom ?
09:37:39 <Solonarv> Cale: https://lpaste.net/4069994667062591488
09:38:24 <__monty__> c_wraith: No, and not with State or monad transformers either. As I understand it the get gets the `Status` and the zoom stack extracts a list of Imports from that Status.
09:39:33 <c_wraith> __monty__: zoom is part of the lens library.  It works with MonadState to "focus" the state on a smaller part of the total state within an expression
09:40:07 <c_wraith> :t zoom
09:40:09 <lambdabot> Zoom m n s t => LensLike' (Zoomed m c) t s -> m c -> n c
09:40:15 <__monty__> c_wraith: So it projects out the `_stack`?
09:40:30 <c_wraith> __monty__: within the context of MonadState, yes
09:40:46 <Cale> Solonarv: That instance is schematically okay, but won't be very useful in practice, due to overlapping with other instances.
09:41:04 <c_wraith> __monty__: of course, the only thing it's doing in the subcomputation is just returning the current state.
09:41:19 <c_wraith> __monty__: so the end result is yes, it's projecting out the stack component of the current state.
09:42:07 <Solonarv> yeah, that instance should probably be for a newtype. I was just pointing out that your (->) instance is a specialization of this one.
09:42:41 <__monty__> c_wraith: And how come that has all the imports? I figured the evalStateT in loadWithContext would pass in an emptyStatus and therefor imports would be empty?
09:44:56 <c_wraith> __monty__: note that that's only the first pattern for loadStaticWith
09:45:00 <c_wraith> __monty__: there's also https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf
09:45:11 <c_wraith> __monty__: err, sorry, C&P error
09:45:20 <c_wraith> __monty__: there's also https://github.com/dhall-lang/dhall-haskell/blob/master/src/Dhall/Import.hs#L721
09:45:35 <mreh> could I make this type more generic with typeclasses?=? :: [a] -> RandT StdGen [] a
09:45:57 <alexad> does ! denote something as being strict?
09:45:58 <mreh> There's MonadRand, but nothing for list
09:46:27 <c_wraith> __monty__: I would expect that case will alter the list of imports in the current state.
09:46:37 <glguy> alexad: It can in some contexts if you're using bang patterns extension
09:46:44 <c_wraith> alexad: in some cases, to WHNF only
09:46:53 <c_wraith> glguy: you don't need an extension to use it in data types
09:46:57 <alexad> data JwtContent = Unsecured !ByteString | Jws !Jws | Jwe !Jwe deriving (Show, Eq)
09:47:00 <alexad> is what I'm looking at
09:47:23 <c_wraith> Yeah, that indicates the field is evaluated to WHNF when the constructor is.
09:47:58 <c_wraith> (It's a very operational view, but strictness is mostly an operational concern anyway)
09:49:08 <pally> With Cale's Num instance for functions created, I thought (abs + abs) -7 would yield 14
09:49:42 <c_wraith> pally: you need parens around (-7), otherwise it will parse it as subtraction
09:57:51 <geekosaur> that's a known wart in the language (negative literals)
10:01:32 <mreh> subtract 7
10:01:41 <mreh> oh
10:02:14 <domenkozar> need a bit of help with optparse-applicative. I have a subparser with commands that consume a sum type. I'd also like to add --version handling to result into Version term for the sum type. I've tried using alternative, but I can't use switch and probably need to just fail on case of no flag?
10:02:29 <reactormonk> I'm debugging some typelevel programming with nested instances. From what I understand, there's no way besides digging through dump-tc-trace to figure out why a typeclass is required?
10:05:30 * hackage language-lua 0.11.0 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.11.0 (EricMertens)
10:06:48 <maerwald> what is typelevel programming?
10:07:15 <johnw> I usually think of it as meta programming
10:07:55 <maerwald> except meta programming is a widely used term
10:08:02 <johnw> yep
10:08:42 <__monty__> But you're not programmatically creating a program are you? You're just doing some calculations at typecheck time instead of at run time.
10:09:04 <__monty__> Not sure my use of just is justified ; )
10:09:09 <johnw> what is the result of those calculations?
10:09:25 <__monty__> Ah type.
10:09:29 <__monty__> *a
10:09:40 <johnw> yeah, at compile time, your writing code that produces a value needed by the compiler
10:09:41 <__monty__> Hmm, I see what you did there.
10:10:10 <glguy> I think "type-level programming" is just a more specific term than meta-programming, which could encompass something like Template Haskell
10:10:28 <johnw> yes, agreed glguy
10:10:34 <maerwald> yeah, any macro sytem is meta programming
10:10:46 <johnw> i'd even further specialize this case to "type class meta programming"
10:10:55 <johnw> where you game the instance resolution mechanism to do some work for you
10:11:30 <glguy> For me "type-level programming" suggests you're making a mess of things with type families
10:11:39 <johnw> instance lookup can be a cheap way to reflect on nested type structures
10:12:05 <dstolfa> maerwald: i don't think that's a very precise way to describe anything. if by type-level programming you meant the fact that types can depend on terms, types and are polymorphic, we may be talking about the calculus of constructions for example
10:12:50 <maerwald> I didn't mean anything
10:13:09 <johnw> we're just being pedantic because it's early somewhere and not everyone has had their coffee?
10:13:21 <dstolfa> maerwald: oh i see, i missed the part above
10:13:23 <dstolfa> maerwald: sorry :)
10:14:20 <dstolfa> johnw: i'm not being pedantic because i want to be a pain in the arse, i'm being pedantic because i want to understand the question fully before i can start answering it
10:14:30 <maerwald> I was just wondering if "type level programming" is just a fancy way of saying "I do haskell"
10:14:45 <johnw> dstolfa: admirable
10:17:51 <domenkozar> ah I was looking for flag' :)
10:18:07 <__monty__> maerwald: No, haskell's not even the most suitable language for type-level programming.
10:24:12 <c_wraith> maerwald: type-level programming is broad.  It means any case where type resolution is used to do computation.  Sometimes it's useless.  Sometimes it's a cute toy.  Sometimes it improves type-safety.  Sometimes it improves usability.
10:25:01 <maerwald> https://github.com/seliopou/typo
10:25:09 <dstolfa> c_wraith: sometimes it proves theorems, sometimes it finds isomorphisms :)
10:27:32 <reactormonk> Yeah, I'm using a mix of typeclasses and type families to improve usability (I hope)
10:29:28 <quicksilver> some people, when seeing a problem, select typeclasses... now they have Problem n => n problems.
10:30:12 <c_wraith> > show (1, [(True, "hello", ()), (False, "goodbye", ())]) -- Haskell98 type-level programming.  Instance resolution is used to generate the code for show.
10:30:14 <lambdabot>  "(1,[(True,\"hello\",()),(False,\"goodbye\",())])"
10:30:53 <c_wraith> Haskell98 is very limited at the type level.  That's about as interesting as it gets.
10:31:10 <c_wraith> But there are very many more things that fit the definition.
10:31:27 <quicksilver> haskell98 does typeclass-polymorphic recursion, I think?
10:31:41 <quicksilver> that's a powerful tool in the wrong hands.
10:31:48 <c_wraith> That's true.  It's a bit more complex
10:32:52 <c_wraith> > let f :: (Show a) => Int -> a -> String ; f 0 x = show x ; f n x = show (x, x) in f 3 ()
10:32:54 <lambdabot>  "((),())"
10:33:01 <maerwald> has anyone deployed lambda-paste? There appears to be zero documentation
10:33:24 <c_wraith> err, wow, I messed that up
10:33:36 <c_wraith> > let f :: (Show a) => Int -> a -> String ; f 0 x = show x ; f n x = show (f (n - 1)x, f (n - 1) x) in f 3 ()
10:33:39 <lambdabot>  "(\"(\\\"(\\\\\\\"()\\\\\\\",\\\\\\\"()\\\\\\\")\\\",\\\"(\\\\\\\"()\\\\\\\"...
10:33:50 <c_wraith> yeah, that looks right/wrong. :)
10:35:21 <dmwit> > let f :: Show a => Int -> a -> String; f 0 x = show x; f n x = f (n-1) (x,x) in f 3 ()
10:35:23 <lambdabot>  "((((),()),((),())),(((),()),((),())))"
10:35:44 <dmwit> Yours only ever uses `Show ()` and `Show (String, String)`.
10:35:51 <c_wraith> Ah, right
10:36:23 <dfeuer> quicksilver: wrong hands?
10:37:00 * hackage butter 0.1.0.6 - Monad Transformer for Asyncronous Message Passing  http://hackage.haskell.org/package/butter-0.1.0.6 (mpahrens)
10:37:27 <quicksilver> exercise for the reader: f :: (Show a) => Int -> a -> String to show (^)N copies of a in the sense of knuth up-arrow notation
10:53:30 * hackage streamly 0.3.0 - Beautiful Streaming, Concurrent and Reactive Composition  http://hackage.haskell.org/package/streamly-0.3.0 (harendra)
10:54:32 <Gurkenglas> quicksilver, but up-arrow notation, besides the number N of arrows which you seem to have provided, requires two values.
10:55:46 <quicksilver> a very good point
10:55:52 <quicksilver> still, it wasn't my most serious suggestion :)
10:56:09 <suzu> hmm
10:56:15 <suzu> so i can't do this
10:57:26 <suzu> class Foo s a where
10:57:38 <suzu>   foo :: s -> a
10:57:42 <suzu> err
10:57:55 <suzu>   foo :: a -> x
10:58:00 <suzu> for some concrete x
10:58:15 <suzu> because ghc can't tell what the s would be from just using `foo` somewhere
10:58:27 <suzu> is there any way "around" this? i want s to be "anything" like the forall used in ST
10:58:27 <Tuplanolla> @let class Foo s a | a -> s where foo :: a -> ()
10:58:29 <lambdabot>  Defined.
10:58:53 <cocreature> having a functional dependency for an unused type parameter seems weird
10:58:59 <cocreature> why not just remove the type parameter in that case
10:59:16 <suzu> i need to instantiate it to the value of a different type parameter which is not allowed to leak
10:59:39 <suzu> to prevent values of this typeclass from leaking
10:59:51 <cocreature> you can add a Proxy argument to foo
11:00:00 <suzu> y..eah but that's gross :(
11:00:12 <cocreature> or probably AllowAmbigousTypes + type applications work as well
11:00:14 <glguy> Maybe make it work the gross way first
11:00:30 <suzu> i'm afraid of AllowAmbiguousTypes
11:00:31 <glguy> and then we'll be able to see what you're doing and help from there
11:00:42 <glguy> This doesn't sound like a job for typeclasses
11:00:46 <suzu> i have an example put together that i can paste
11:02:00 <cocreature> yeah you seem to be trying to create multiple typeclass instances for a single type but your solution is not to just give up on trying to use a typeclass for this but instead you add another type parameter
11:02:45 <quicksilver> the ST trick requires you to tag each value you want to keep safe/consistent with the s
11:02:58 <suzu> https://pastebin.com/XHFNPZwT
11:03:00 <quicksilver> note that every value calculated "inside" the ST monad has a type like 'ST s a'
11:03:06 <quicksilver> you need that s in the type to do the safety.
11:03:13 <suzu> i am trying to use the ST trick in a monad where it will accept varidaic-arity actions and execute them
11:03:31 <pally> >  map ($ 10) [(+1), (+2), (+3)]
11:03:33 <lambdabot>  [11,12,13]
11:03:49 <pally> :t ($ 10)
11:03:50 <lambdabot> Num a => (a -> b) -> b
11:04:16 <glguy> suzu: The "ST trick" comes from the run function having a rank-2 type
11:04:19 <pally> are `(+1)`, `(+2)` functions?
11:04:35 <glguy> :t (+1)
11:04:37 <lambdabot> Num a => a -> a
11:04:46 <glguy> yup, it has the shape: _ -> _, so it's a function
11:04:52 <suzu> so how do i get 'runAction' here to have a rank2 type
11:05:17 <suzu> runAction :: (forall s. IsAction s a) => a -> Env s a
11:05:43 <suzu> this doesn't work
11:05:52 <suzu> nor does moving the a inside or moving both s and a outside
11:06:05 <cocreature> how is that supposed to work? IsAction constrains the thing to some kind of function but then you try to convert it to Env which is a wrapper around IO?
11:06:11 <cocreature> where do the funciton arguments come from?
11:06:32 <glguy> suzu: I don't know how to fix that class because I don't see what it's supposed to do
11:06:32 <suzu> they're passed in by runAction but that stuff isn't important here
11:07:00 <cocreature> I feel like you are mixing up the runST trick with a printf like trick for no good reason
11:07:52 <cocreature> but I agree with glguy. too much of this code is just stubs so it’s hard to tell what it’s actually supposed to do
11:08:40 <suzu> so, what i want to do is be able to transform a function that takes any number of Unleakable arguments or numeric arguments and wrap it and execute it in this environment
11:09:03 <suzu> so i have a printf-like typeclass to capture functions like that, and it is encoded in the IsAction typeclass
11:09:33 <suzu> the problem is that these functions return an action at the very end in IO
11:09:48 <cocreature> how about you write the ugly implementation with a Proxy and then we look at how we can improve upon that?
11:11:04 <suzu> and so they can take those unleakable values and write them to an ioref living outside the env and use them elsewhere
11:12:13 <suzu> ok, let me work on this example a bit more and then present it again
11:19:45 <orion> I'm trying to explain to a co-worker the difference between evaluation and execution. Does anyone know of a good article detailing the difference?
11:21:01 <dstolfa> orion: how do you define evaluation and how do you define execution?
11:22:42 <orion> dstolfa: My understanding is that when a program is compiled, it is evaluated to be single value of type IO () (named "main"). That value is pure.
11:22:59 <orion> Execution is a separate step that takes place.
11:24:38 <dstolfa> orion: ah, in that sense. sure, you could evaluate something without ever executing it if your separation is between compile time and run time. i don't think it's a very good separation to think of it as "evaluation" and "execution", but instead should be thought of at what happens at compile-time and what happens at run-time
11:24:44 <[exa]> orion: that's a good semantic explanation, yes
11:25:14 <cocreature> dstolfa: evaluation still happens at runtime
11:25:23 <dstolfa> cocreature: not necessarily.
11:25:35 <dstolfa> cocreature: compilers can evaluate things at compile-time, especially when they use powerful enough of a type theory
11:25:59 <cocreature> sure but evaluation can be dependent on user input and then the best compiler is not going to be able to evaluate it at compile-time
11:26:15 <cocreature> so labeling evaluation as “compile-time” doesn’t describe it particularly well
11:26:35 <dstolfa> cocreature: yeah, but that doesn't mean it always happens there. that's why i said it's a bad way to think about it and instead thinking of it as compile-time vs run-time is easier to understand
11:26:58 <cocreature> what? my whole point here is that compile-time vs run-time is wrong
11:27:53 <cocreature> thinking about it as compile-time vs run-time when the things that fall into the “compile-time” category very often _have_ to happen at run-time is just confusing
11:28:11 <dstolfa> cocreature: i think you're misunderstanding what i'm trying to say (possibly through my fault as well). i'm saying that thinking of evaluation and execution isn't as easy to understand as it is to understand as to what happens at runtime and what happens at compile time in a particular program (i'm not making an analogy to the former, i'm saying the former is probably not the best way to think about it)
11:28:38 <cocreature> ah, sry then I completely misunderstood you. I think we then actually agree :)
11:29:00 <dstolfa> cocreature: yeah, i didn't point out the thing i was trying to say as clearly as i should have :)
11:30:16 <glguy> A common way to distinguish "evaluation" from "execution" when explaining how IO works in Haskell is that evaluation is what happens to determine what Haskell value an expression has through reducing function applications, performing pattern matches, branching on conditionals, etc
11:30:38 <glguy> execution is the process of running the various effects of IO: writing and reading files, updating references
11:32:39 <glguy> these processes interleave
11:33:08 <EvanR> or happen in parallel?
11:33:31 <p0lyph3m> orion: think like this : you evaluate expressions to a value ;  a common type of expression is your haskell program. it evaluates to a value main :: IO that when run in a RTS gets executed.
11:35:48 <maerwald> how do you evaluate IO to NF?
11:36:03 <EvanR> :t rnf
11:36:04 <lambdabot> error: Variable not in scope: rnf
11:36:36 <maerwald> EvanR: IO is not of NFData
11:36:44 <EvanR> i see that now
11:37:05 <maerwald> maybe we need to execute it :>
11:37:12 <glguy> IO itself is abstract, so the process of evaluating it to figure out what primitives to run are the RTS's problem
11:38:09 <maerwald> can we say that "main" forces NF evaluation of "dependent" IO and as such execution?
11:38:47 <dfeuer> maerwald: does what?
11:38:58 <maerwald> does what?
11:39:28 <u__> so i realize this is a pretty lazy and shortsighted thing i want to do but: is there any way to un-escape strings within Show output?
11:39:30 <dfeuer> What do you mean by "forces NF evaluation of 'dependent' IO and as such execution?"
11:39:47 <p0lyph3m> maerwald: main :: IO yields a value that is an action when its ever performed by the RTS
11:40:05 <maerwald> p0lyph3m: I am aware
11:40:06 <dfeuer> u__: like you said, this is a pretty lazy and shortsighted thing to do. So ... don't.
11:40:21 <maerwald> but that is very fuzzy terminology
11:41:03 <cocreature> u__: newtype and write the Show instance you want?
11:41:08 <maerwald> so isn't the actual thing just that 1. IO is not of NFData and there is no function to evaluate to NF and 2. this is basically done by execution of main?
11:41:10 <EvanR> > read (show "wahahaha\\")
11:41:13 <lambdabot>  *Exception: Prelude.read: no parse
11:41:14 <u__> cocreature: oh duh
11:41:14 <dfeuer> It's best to imagine IO as an operational monad, or if you prefer as the AST for a limited imperative language.
11:41:16 <u__> thanks
11:41:24 <u__> well
11:41:45 <maerwald> I'm not talking about imagination currently
11:41:50 <cocreature> u__: ofc that comes with problems if you have some weird characters in your Show instance
11:42:23 <maerwald> EvanR: what do you think of that proposal?
11:42:35 <glguy> maerwald: Yes, evaluation of IO actions is driven by execution by the runtime
11:42:46 <u__> dfeuer: i just need to make this output legible before lunch, i know its a hack
11:43:20 <EvanR> maerwald: having trouble following. dependent IO ?
11:43:35 <maerwald> evaluation chain
11:44:01 <EvanR> whats the proposal
11:44:10 <dfeuer> u__: well, you can drop 1 to remove the leading paren.  To remove the trailing paren,  dropEnd n xs = zipWith const xs (drop n xs).
11:44:36 <maerwald> EvanR: to say that there is no function to evaluate IO to NF (because it's not an instance of NFData) and that this evaluation happens by main
11:44:53 <maerwald> so execution, like glguy said
11:45:21 <maerwald> maybe that's not useful for beginners
11:45:35 <dmwit> maerwald: No, evaluating an IO action to NF does not execute the IO.
11:45:50 <maerwald> dmwit: but how do you evaluate it to NF?
11:45:56 <dmwit> maerwald: No, execution of main does not force it to NF.
11:46:04 <dmwit> maerwald: You don't. Why do you ask?
11:46:30 <EvanR> since you cant see IO actions, like, as expression primitives, not sure what NF would mean
11:46:44 <maerwald> mh
11:47:02 <EvanR> the question of what main "does" is valid, but i would think the answer involves the literal effects exhibited in the code
11:47:10 <EvanR> rather than evaluation
11:47:17 <dmwit> > read "\"\SOH\"" -- u__
11:47:19 <lambdabot>  *Exception: Prelude.read: no parse
11:47:25 <dmwit> > read "\"\SOH\"" :: String -- u__
11:47:27 <lambdabot>  "\SOH"
11:47:41 <dmwit> Oh, that didn't even show what I wanted it to show.
11:47:46 <dmwit> Yikes, my Haskell isn't so hot today.
11:47:49 <u__> lol
11:47:52 <dmwit> > read "\"\\SOH\"" :: String -- u__
11:47:53 <u__> fun with escaping
11:47:54 <lambdabot>  "\SOH"
11:48:02 <dmwit> There. That did show what I want.
11:48:22 <glguy> That works for top-level strings being shown
11:48:34 <glguy> but it won't work for strings nested in some larger show output
11:48:43 <EvanR> escaping is funny because every "just understands it", but not really. when it comes to reverse it rather than comprehend it, gotta rewrire your brain
11:49:03 <EvanR> language games
11:49:28 <dmwit> > reads "\"\\SOH\"foo" :: [(String, String)] -- glguy
11:49:30 <lambdabot>  [("\SOH","foo")]
11:49:37 <u__> speaking of dumb Show hacks, groom is pretty convenient
11:50:03 <glguy> > show ("an","example")
11:50:05 <lambdabot>  "(\"an\",\"example\")"
11:50:08 <dmwit> In case of empty lists, `dropWhile (/='"')`.
11:50:41 <glguy> anyway, lunch!
11:52:32 <dmwit> > let unescapeLol [] = []; unescapeLol s = case (reads s, break (=='"') s) of ([(here, later)], _) -> here ++ unescapeLol later; (_, (earlier, here)) -> earlier ++ unescapeLol here in unescapeLol (show ("an","example")) -- glguy
11:52:34 <lambdabot>  "(an,example)"
11:54:33 <suzu> glguy cocreature https://pastebin.com/76ujHWFw
11:54:45 <suzu> i've implemented most of the stubs and added some more detail
11:55:02 <u__> dmwit: thanks
11:55:15 <u__> i will actually use this for a few hours, because the newtyping idea doesn't give me the right indentation when combined with groom
11:55:16 <u__> lol
11:56:15 <suzu> this sample doesn't compile. i don't know why the types won't unify
11:57:01 <suzu> any help is appreciated
11:57:47 <cocreature> suzu: you haven’t enabled ScopedTypeVariables
11:57:56 <suzu> oh i am an idiot lol.
11:58:15 <suzu> thought i thought ranktypes enables that
11:58:18 <suzu> though *
11:58:30 <suzu> ok i enabled that and it changed nothing
11:58:46 <cocreature> it should help with the instance
11:58:55 <cocreature> you need an explicit forall for it to take effect in "runAction"
11:58:56 <suzu> i spoke too soon, you are correct
11:59:19 <cocreature> but in the instance you also don’t need it, you can just pass on the proxy instead of trying to construct a new one
11:59:54 <suzu> ok yup that works
12:00:02 <suzu> 79-81 have errors though
12:00:11 <electrocat> oh, split sections is nice, much better results than split objs :)
12:00:12 <suzu> 80-81 should be illegal. 79 should work
12:00:19 <cocreature> it looks like you are missing a do block?
12:00:48 <suzu> >.< yes
12:01:15 <suzu> ok. last issue now is that first `runAction` invocation doesn't unify
12:02:11 <suzu> no instance for IsAction s0 (Unleakable s1 -> Unleakable s1 -> IO ())
12:02:24 <cocreature> it seems like you are trying to rely on typeclass resolution to force unification and that’s just not how typeclass resolution works
12:04:24 <cocreature> I’m not sure I get what the arguments that are being passed to the function are supposed to be.
12:04:39 <suzu> it's just going to be a series of `MkUnleakable 0`
12:04:54 <cocreature> right but what’s the point of this? what’s the underlying goal here?
12:05:15 <suzu> i want to execute functions with variadic arguments, inside the environment
12:05:49 <cocreature> but what’s the point of having a function that accepts a variadic number of identical constants?
12:06:10 <suzu> the underlying reason is i'm working on bindings for a javascript vm. i wish to take "regular" hs functions and transform them into functions that i can pass to C to expose them to the javascript vm
12:06:27 <suzu> a variadic number of identical constants is used just as an example
12:06:52 <cocreature> so where would the arguments come from if they are not all identical constants?
12:07:55 <suzu> they come from some external source of data
12:08:44 <cocreature> how are you going to access the external source of data from your typeclass instance?
12:08:44 <suzu> the environment will source data from someplace and pass it to these functions
12:09:10 <cocreature> I am not trying to troll you here, I honestly don’t understand what you are hoping to gain from these variadic functions
12:09:18 <suzu> yes, i understand
12:09:50 <suzu> so suppose i wrote a function `Int -> Int -> IO Int`, which has the implementation `liftM (+)`
12:10:30 <cocreature> that doesn’t typecheck
12:10:33 <cocreature> :t liftM (+)
12:10:34 <lambdabot> (Num a, Monad m) => m a -> m (a -> a)
12:10:42 <suzu> uh whoops
12:11:04 <suzu> `\a b -> return $ a + b`
12:12:04 <suzu> so i then need to take this hs function and create a C function to expose to the bindings
12:12:33 <suzu> there are rules ot this: each type must have a js analog
12:12:54 <suzu> so i have this implemented under a typeclass
12:13:20 <suzu> and this works. but now i want them to also be able to take some special values that i would like to be unleakable
12:23:05 <cocreature> it feels like you want something more like this https://gist.github.com/cocreature/1acd71b309d83bc9b5b07777fdb719b1
12:23:36 <cocreature> however, that doesn’t work because you can’t use a polymorphic type in the instance
12:25:10 <suzu> you mean the `forall s.` in the type?
12:25:16 <suzu> hmm i see
12:25:17 <cocreature> yep
12:25:47 <cocreature> so you probably need to manage to move the forall in the signature of runAction somehow
12:26:13 <cocreature> so something like "runAction :: (forall s. f s) -> Env" (which is fairly close to runST
12:26:15 <cocreature> )
12:26:24 <cocreature> but then you can’t make it work when f is a function
12:28:10 <suzu> okay i got it to compile
12:28:17 <suzu> except the illegal functions compile too
12:28:31 <suzu> by rewriting my typeclass instance: instance (IsAction s tail, s ~ s1) => IsAction s (Unleakable s1 -> tail) where
12:29:30 <cocreature> nothing forces the "s" to be polymorphic
12:33:40 <suzu> ok i got this to work just the way i want
12:36:10 <suzu> so i changed the typeclass instance as above
12:36:36 <suzu> and then rewrote runEnv's signature to runEnv :: (forall s. Env s a) -> IO a
12:36:42 <suzu> otherwise it is not rank2
12:40:01 <suzu> cocreature
12:40:38 <zachk> has anyone worked with websocket servers in haskell here? my connections aren't properly dying after an abnormal client disconnect
12:41:00 <cocreature> suzu: nice!
12:42:34 <Ariakenom> I haven't been paying attention. Is it different people asking about websockets every other day? Is it popular and|or full of issues?
12:47:42 <geekosaur> same person in this case. and from what I've seen, most questions about websockets are people who don't understand websockets
12:48:29 <geekosaur> (this one… websockets are faked on top of normal http. what exactly is supposed to tell the server the client went away?)
12:54:49 <zachk> Ariakenom, I asked yesterday, I have them working these days for the most part, I have asked how to get them working on and off over the past year or so, now I just have "hang up" problems with them
12:55:45 <zachk> geekosaur, I am relying on an exception to kill an execution thread and relying on the thread dying to finish cleanup, I looked at the websocket code and it seems to throw an exception most of the time, for the parts I could understand/follow
12:56:06 <geekosaur> the problem is deeper than that
12:56:33 <geekosaur> websockets are not actual sockets. they're tagged data on HTTP connections, which may not be persistent
12:56:58 <geekosaur> which means the only way to find out something went away *unexpectedly* is a timeout, which may need to be long because it might otherwise trigger on a slow network link
12:57:09 <zachk> isn't there an underlying persistent socket, that should raise a read/send error when it's closed ?
12:57:23 <geekosaur> "HTTP connections, which may not be persistent"
12:57:38 <zachk> yea I just got the bright idea to modify forkPingThread, lets see if it works
12:57:44 <zachk> oh
12:57:51 <geekosaur> IOW no, there is no underlying persistent anything except in the browser. if the browser dies unexpectedly, no state anywhere
12:58:46 <rihards> hey, anyone here familiar with Streamly? i was wondering whether there is an easy way to generalise my existing functions which work on lists to also work on Streamly streams. as an example - for stuff that depends on using `map` i think i should be able to switch my type signatures like :: Num a => [a] -> [a] to :: (Functor f, Num a) => f a -> f a (Streamly streams have functor instances). but how about stuff that depends on `take`, `siz
12:58:48 <rihards> e`, `minimum` and others?
12:59:42 <zachk> i thought they upgraded the http connection to a "permanent" tcp connection that used a messaging protocol
12:59:54 <zachk> well thats what I thought websockets did
13:01:31 <rihards> i started thinking something like this could be possible after reading the awesome "Functor design patter" blog post on haskellforall http://www.haskellforall.com/2012/09/the-functor-design-pattern.html there at the end the author mentions monad morphisms which seemed to do something similar that i'm trying to do but i'm not sure that they apply here
13:02:48 <rihards> or should i just better forget about supporting plain lists and convert everything straight to Streamly streams and to use functions from Streamly.Prelude?
13:04:19 <geekosaur> there's a bunch of things websockets was supposed to do… and then there's what actually happens, which as usual for web stuff isn't quite the same thing
13:04:29 <jared-w> "quite"
13:04:37 <jared-w> Pretty sure websockets were gonna cure cancer at one point?
13:06:32 <Rembane> Sounds good. Did they?
13:07:10 <cocreature> rihards: once you step outside of what Functor and Monoid provide (those are probably the only two relevant instances that [] and streamly’s types have in common), you can’t really do anything to support both short of coming up with your own typeclass that provides the operations you use (or try to make the types in Streamly an instance of some other class that provides these functions)
13:07:57 <DigitalKiwi> I still don't have cancer so it must have worked
13:11:54 <rihards> concreature: that's what i was beginning to suspect when looking at Streamly instances. thanks. any idea why Streamly doesn't have an instance for Foldable? this wouldn't quite be enough for what i want but still..
13:12:52 <cocreature> rihards: probably because you can’t make one. Foldable requires you (among other things) to provide a pure toList function. however, for streamly you probably only get something that gives you an m [a] where m can be something like IO
13:13:41 <cocreature> also why are people suddenly misspelling my nick half of the time … this didn’t use to happen :)
13:14:01 <rihards> oh, sorry about that :)
13:14:52 <rihards> but on the other side of things - is there something that generalises `take`? or is it realy list-specific?
13:16:33 <rihards> looking at what hoogle gives me, i guess it's the later
13:17:07 <EvanR> the word take is used in several sequential-like APIs
13:17:12 <geekosaur> suppose you could say the generalization is lens :p
13:17:41 <EvanR> but since none of these data structures are really interchangable, they dont have a common type
13:27:34 <jared-w> This is something that I've struggled with in general. I see a lot of shortcomings in the way we currently write and think about languages and libbraries in genera; but unfortunately, I'm not sure if a solution is even really possible
13:29:03 <jared-w> There seem to be two conflicting ways to think about types and functions that are really common. One is that you'd want a function that's the most general possible, overloaded, polymorphic, etc. Those functions are all about highly generalized building blocks of manipulating data structures (idk if I'd even call them data structures). 'take', 'head', 'zip', 'map', etc., are all great examples. I can think of
13:29:05 <jared-w> sane ways to do those on just about any data structure imaginable
13:29:36 <EvanR> there are many sane ways to "take" a tree from a tree
13:29:48 <EvanR> or a matrix from a matrix
13:29:56 <jared-w> Right, there definitely are, which is a lot of the problem
13:29:56 <Tuplanolla> Usable first-class Futamura projections, when?
13:30:15 <jared-w> But even if we restricted take to 'linear data structures' there's still a lot of those
13:30:47 <jared-w> It'd be nice to have a "take" that worked on vectors, sequences, lists, every type of stream, etc., without throwing type inference out the window or making it super fucking ugly to write it
13:31:03 <EvanR> you want 1 way to implement take on all of them?
13:31:25 <jared-w> It's one idea "take the first n items from a linear data structure"
13:31:41 <EvanR> we can already make a type class to make the operation polymorphic, it just has no laws so its not standard
13:31:55 <jared-w> it'd be nice if I could use one function for that. I'd even be willing to go down the typeclass route for some of those things
13:32:22 <EvanR> for an experiment where they thought every "linear" structure should have the same interface, see clojure
13:32:57 <jared-w> (although a part of me wonders if we're abusing type classes for this sort of thing and if there's a better way to split typeclasses-with-laws and typeclasses-for-polymorphic-convenience out into two things where each can explore their strengths. I'm not sure the polymorphic convenience needs global coherence, for example, but ytpeclasses sure as hell do)
13:33:18 <EvanR> unfortunately, the actual intersection of all these APIs is pretty small in comparison to the full APIs, and the full APIs are what you need to exploit the performance differences
13:33:41 <EvanR> and avoid issues with semantic differences
13:34:00 <EvanR> its like "there should really be a class for things which can lookup by key"
13:34:10 <jared-w> like snoc being useless on streams and head being partial on some data structures and total on others?
13:34:15 <EvanR> since all these wildly different structures happen to have a lookup by key function in common
13:34:22 <EvanR> but almost nothing else
13:34:24 <Ariakenom> fromList . take 5 . toList -- add some rewrite rules
13:34:42 <EvanR> yes like snoc
13:35:24 <Ariakenom> jared-w: That split sounds like Idris' ad-hoc overloading
13:35:49 <jared-w> I'm not convinced the tolist-> f -> fromlist is a super great solution, honestly. Rewrite rules are hilariously fragile and you end up shoving exponential complexity on the maintainers for very little benefit on the author side of things
13:36:22 <jared-w> But yeah, there's this general feeling of "I feel like I can write _far_ more general code that really gets to the heart of what I'm doing at a foundational level, if only there was... something..."
13:36:32 <EvanR> before solving this i want to know that there is a well defined problem to solve
13:36:52 <EvanR> all these data structures are actually similar? in what way
13:37:16 <EvanR> or do they just happen to have a couple of the same operations, not necessarily efficient
13:37:24 <jared-w> Lenses give me that feeling too, like they're closer to the 'perfect' than accessor functions and feel like a really nice to think about data in a more abstract and uniform manner... But I can't help but feel there's just one level higher where everything clicks perfectly
13:37:41 <maerwald> lol
13:37:56 <jared-w> nice way to think about**
13:38:12 <EvanR> mapping to and from a list is one nice way
13:38:20 <EvanR> then you really are sure this is a list in disguise
13:38:27 <EvanR> but its not efficient
13:39:10 <jared-w> EvanR: unfortunately, I don't know the answer to that one. I feel like it's potentially possible that a language of the future might not really have any other data structures; merely data representations that are transiently created by an intermediate language representation in order to make an operation you want more efficient.
13:39:29 <jared-w> Of course, that doesn't seem really right to me, given that a lot of data structures are inescapable in their differences (eg non linear structures vs linear ones)
13:39:33 <Ariakenom> It's not exponential a rewrite rule per type and function. Like the typeclass approach. It's not a good idea but for it's the straightforward list-like thing to do
13:39:37 <EvanR> one true data structure? one true number type?
13:39:57 <jared-w> Right? It feels like, poetically, it might be possible, but I'm not sure the reality is so rosy :)
13:40:08 <maerwald> meanwhile, other people write actual code :D
13:40:23 * jared-w philosophizes grumpily in maerwald's general direction
13:40:54 <EvanR> i dont see fox, frog, gator anymore just tetrapods
13:41:08 <EvanR> dont worry about hexapods, out of scope
13:41:48 <jared-w> lol
13:41:48 <dmwit> am i a tetrapod
13:42:14 <jared-w> But yeah, the other side of things is that often it's very useful to have things which are very very domain specific, so that the types help make sure you don't do anything wrong
13:42:55 <jared-w> I might want 6 different newtypes of the same thing, for example, but do I want all of those super general functions to work on those newtypes? Maybe? Maybe not? Maybe only sometimes?
13:43:46 <EvanR> "hello " + "world" + 2
13:43:48 <Ariakenom> Why do you call them the same thing?
13:44:27 <Ariakenom> If they're new types they should """"ideally"""" not be. If we're philosophizing
13:44:35 <crestfallen> hello why is the seed value set to True using foldr in this case? :  https://ptpb.pw/ngsq
13:44:56 <dmwit> What do you think it should be set to?
13:44:59 <dmwit> (And why?)
13:45:19 <mitchellsalad__> and [True] should return what? ;)
13:45:34 <EvanR> newtypes that act exactly the same but arent compatible with each other can be useful to avoid mixing up argument order
13:45:36 <jared-w> Ariakenom: right, but for another example, I might want to have a linear structure in a program where, in one section, it's very important to make sure the length of items is correct
13:45:52 <EvanR> but theys kind of a strech because no one does that
13:46:17 <jared-w> EvanR: I end up doing that sort of thing quite frequently in one off things like homework assignments
13:46:34 <jared-w> If I have like 3 matrices I'm passing in and things get fucked up, you best believe I don't want to do that book keeping by hand lol
13:46:43 <dmwit> If you were a mathematician, my answer would be "because True is the unit of (&&)" and be done with it. (You might also ponder what it has in common with the base cases for `product = foldr (*) 1` and `sum = foldr (+) 0`.)
13:47:18 <jared-w> and in another section, I don't care about the length, but I do care about some other property, so I'd probably want to convert that type to one that tracks that property and throws away the length
13:47:55 <ZeuPiark> bye
13:48:01 <crestfallen> dmwit: thanks, working on that
13:48:15 <jared-w> but in all cases, being able to use a general `length` function on the list would probably be pretty useful and taking the head of a non-empty list should always be fine, even if that list is embued with additional (yet locally temporary) structure
13:48:29 <EvanR> philosophizing about these things is a lot easier than dealing with the code after putting mass quantities of types in hehe
13:48:40 <jared-w> Basically :p
13:48:56 <jared-w> It'd be great if there /wasn't/ a cost to putting all those types in, though
13:49:06 <crestfallen> dmwit: pls elaborate on 'the unit'
13:49:14 <EvanR> just install the AI java IDE plugin
13:49:31 <EvanR> equipped to not only detect mistakes but pass moral judgment on your ideas
13:49:43 <Ariakenom> We also have liquid haskell types. Which fit into these issues
13:51:02 <glguy> It's nice to be able to think about:  and (xs ++ ys) === and xs && and ys, and similarly:    or (xs ++ ys)  === or xs || or ys
13:51:23 <crestfallen> do you mean unit in a way similar to identity dmwit ?
13:51:50 * Ariakenom disappears into the clouds
13:52:14 <glguy> xs == [] ++ xs   or xs == or ([] ++ xs) == or [] || or xs == False || or xs == or xs
13:52:33 <wchresta> crestfallen: Yes, unit in the sense of identity. In the sense of "the element that when applied to another one does nothing; i.e. 0+2==2, 1*5==5, True&&a==a
13:52:56 <jared-w> The unit for lists and concatenation is [], the unit for addition is 0, the unit for multiplication is 1, the unit for... etc :)
13:54:08 <jared-w> (can't think of any number types that doesn't hold for, tbh, but usually people use the Integers as the number type of choice when talking about units)
13:54:30 <crestfallen> wait a cotton pickin' minute  :)
13:56:01 * jared-w suddenly realizes how weird that phrase sounds outside of the southern US
13:56:34 <crestfallen> I know sorry its a bit backwater
13:56:57 <jared-w> hah it's fine, I just read it in a southern accent and got confused why my brain picked that one
13:57:04 <DigitalKiwi> how long is a cotton pickin' minute compared to regular minutes
13:57:28 <dysfun> not sure, but it's twice as long as a corn pickin' minute
13:58:01 <crestfallen> some colloquialisms, even those related to bad times, should be remembered perhaps.
13:58:24 <suzu> hmmmm
13:58:34 <suzu> why won't these instances overlap?
13:58:45 <suzu> instance (JsTypeable s b, s1 ~ s) => JsTypeable s (JsCallback s1 -> b) where
13:58:50 <DigitalKiwi> mhr so if I wait a cotton pickin' minute and you wait a corn pickin' minute, who will be done waiting first?
13:58:50 <suzu> instance (FromJSValue a, JsTypeable s b, s ~ s1) => JsTypeable s1 (a -> b) where
13:59:18 <suzu> they did overlap before i added this `s` parameter to JsTypeable
13:59:25 <EvanR> (but then why is monadplus's unit called zero, which acts like multiplicative zero)
14:00:29 <glguy> mzero is the unit for mplus, not >>
14:00:30 <fishythefish> EvanR: at the risk of missing the joke, because zero is the identity for plus?
14:01:05 <EvanR> oh
14:01:07 <EvanR> right
14:01:18 <glguy> MonadPlus's interaction with >> is optimistically documented but not necessarily satisfied by its instances
14:01:36 <crestfallen> so it returns the seed value regardless, but you are saying that the empty list has a logical value with (||) and (&&)   ?
14:01:55 <glguy> and the more modern Alternative class doesn't mention that interaction at all
14:03:03 <crestfallen> each empty list has a bool value based on the logical operator? now I'm not sure I get the (||) case either....
14:05:54 <geekosaur> every monoid comes with two things: an associative operator, and an identity specific to that operator
14:06:12 <crestfallen> foldr (#) v [] = v
14:06:25 <glguy> > foldr (Debug.SimpleReflect.op Debug.SimpleReflect.InfixR 2 " || ") (var "False") [a,b,c]
14:06:28 <lambdabot>  a || b || c || False
14:07:37 <crestfallen> geekosaur: ok in straight logic (&&) has the identity of True
14:08:39 <crestfallen> so this leads me to ask a difficult-to-form question...
14:08:51 <glguy> > foldr (⊕) z [a,b,c]
14:08:53 <lambdabot>  a ⊕ (b ⊕ (c ⊕ z))
14:09:34 <shapr> silly question, any good ways to golf [n | n <- (2^) <$> [1..], not . or $ elem <$> "1248" <*> [show n]] ?
14:09:46 <dmwit> I also like glguy's "because we want `and (xs ++ ys) = and xs && and ys`" answer. It is another way of talking about the same points.
14:10:02 <shapr> The question on work slack was, what's the shortest way to find all powers of two that do not contain numbers 1,2,4,8 powers of two
14:10:20 <shapr> I feel like my first attempt at golfing that was subpar
14:11:09 <crestfallen> pondering that: and (xs ++ ys) = and xs && and ys
14:11:18 <dmwit> > [n | n <- iterate (2*) 1, all (`elem`"356790") (show n)]
14:11:24 <lambdabot>  mueval-core: Time limit exceeded
14:11:48 <shapr> dmwit: oooh
14:12:06 <shapr> > take 1 [n | n <- iterate (2*) 1, all (`elem`"356790") (show n)]
14:12:08 <lambdabot>  [65536]
14:12:12 <shapr> niice
14:12:41 <dmwit> Optimized for beauty, not golfed.
14:13:34 <crestfallen> so in other words the empty list takes on the logical implications of the operators (&&), (||)
14:14:06 <dmwit> I don't know what the logical implications of (&&) are.
14:14:11 <dmwit> What do you mean by that?
14:15:28 <crestfallen> because we are folding over an empty list with operators that have identity values, I guess
14:17:03 <suzu> nvm got my thing to work ^ grr polykinds were on
14:20:52 <maerwald> so stack doesn't have a 'run' command, great
14:21:38 <maerwald> how do you run the project
14:21:51 <exio4> stack exec <project_name>
14:21:58 <exio4> executable name actually :p
14:22:02 <maerwald> exactly
14:22:10 <maerwald> stack-run exists, but the stack resolver fails
14:22:16 <maerwald> so I cannot build it
15:25:49 <mjoldfield> Suppose I have: data Foo = FA | FB deriving (Bounded, Enum), data Bar = BA | BB deriving (Bounded, Enum), data Baz = Baz Foo Bar. I can get all the Bazs with Baz <$> [minBound..maxBount] <*> [minBound..maxBound], but is there a way to derive the Enum instance ?
15:25:53 <pie_> emoji as haskell operators
15:27:21 <geekosaur> mjoldfield, it won't derive Enum for constructors with parameters. You can make one yourself, but consider e.g. how it interacts with Ord.
15:28:12 <geekosaur> (more to the point, does succ or prev make sense on a boundary of one of the components?)
15:29:10 <mjoldfield> geekosaur: Thanks. I think you could define an Ord couldn't you ? Just treat it as a multi-digit number.
15:29:45 <jared-w> does data Baz = Baz Foo Bar deriving (Bounded, Enum) not do what you want?
15:29:48 <geekosaur> you can derive Ord, I meant that doing an Enum that behaves differently from the Ord instance may confuse you or users of the type
15:30:07 <geekosaur> also the issue that it has to be something Ord makes sense on: consider why Complex Double has no Ord instance
15:30:25 <zachk> so it seems my server problem with websockets, isn't related to websockets at all, its multithread web telnet client server, and the problem seems to be a "race" condition with closing a regular socket whilee another thread is waiting a read form that socket, and it just hangs sometimes
15:30:30 <geekosaur> (quick, is 3+4i greater or less than 4+3i?)
15:30:47 <mjoldfield> geekosaur: True.
15:32:02 <mjoldfield> geekosaur: Though I think I'd say you can't put an ordering on the real complex numbers, but could put a silly ordering on Complex Doubles
15:32:36 <jared-w> You can just start pulling numbers out of a hat, but that doesn't make it a total ordering :)
15:32:40 <geekosaur> You can create something, yes, just not a proper ordering because Enum and Ord both assume you can meaningfully flatten a type onto the integers
15:33:05 <geekosaur> (or reals, as the case may be)
15:33:23 <jared-w> (1,2,3,... ... 0, -1, -2, -3, -4 ...) isn't a valid ordering for integers, for example, in the mathematical sense of the word
15:34:48 <jared-w> Its useful to think of 'ordering', in a loose handwavy way, as "a way of arranging numbers to assure that you can get to any single number in a finite amount of steps"
15:35:23 <jared-w> which immediately shows why 3+4i and 4+3i is so confounding. How do you "arrange" things so that you can hit both without having to count to infinity first?
15:35:25 <mjoldfield> jared-w: But I could do that with your odd ordering of the integers. It's just that Succ wouldn't be the same as +1
15:35:50 <mjoldfield> jared-w: Quite, which is why I think you could order Complex Double which only has a finite number of them
15:36:22 <jared-w> you can't get to -1 in a finite amount of time with my odd ordering of the integers is the problem. You'd have to run out of naturals and then start at zero and walk down
15:37:04 <mjoldfield> Oh I see, you mean the infinite set of integers, not some bounded thing. I agree then.
15:37:35 <jared-w> Right, should've clarified I meant the proper math integers ;)
15:38:26 <mjoldfield> jared-w: Isn't it hard to write a Bounded instance for those ?
15:38:57 <jared-w> For the real integers?
15:39:05 <mjoldfield> Yes
15:39:34 <geekosaur> indeed
15:39:49 <jared-w> All bounded is is minBound and maxBound. If I had to define bounded for the "real integers", I'd be a bit cheaky and define negative and positive infinity ad use those :) but the real answer is that I probably wouldn't define it at all
15:40:13 <geekosaur> and in Haskell Integer doesn't have an instance of Bounded; technically it is bounded, by available memory, but you can't encode that usefully
15:40:35 <lamdev> hello! i'm trying to do basic IO (reading lines from a file) and somehow i can't find any safe IO function that wouldn't raise exceptions in case something wrong happens. is there a module using Maybe or Either instead to implement error handling?
15:40:36 <mjoldfield> Quite, which is why I wondered if I could derive the Enum type given that my Foo and Bar were Bounded
15:41:03 <geekosaur> per spec it wont even try since the constructor takes 2 parameters
15:41:12 <zachk> lamdev, you can wrap the function in a catch to handle exceptions
15:41:16 <mjoldfield> geekosaur: Fair enough :)
15:41:40 <geekosaur> you can write one yourself, but the compiler isnt going to force meaning on you by assuming how they should fit together to make an Enum instance.
15:41:59 <jared-w> I'm not sure if you can automatically derive it, but you can certainly write an enum that does "the right thing"
15:42:07 <geekosaur> also because I suspect it's harder for the deriving machinery to determine which types are finite and which aren't
15:42:21 <jared-w> That being said, this does sound suspiciously like subtyping of some sort
15:42:28 <lamdev> zachk: well maybe i'll eventually have to do that yes but i would have hoped it already existed. i don't know anything about catching exceptions in haskell, so i'd hoped i wouldn't need to do so myself.
15:42:37 <jared-w> geekosaur: I'd imagine it's harder still because all* types are lifted in Haskell :)
15:43:53 <zachk> lamdev, usually I just want my program/current thread of execution to die , somewhat gracefully, on errors from IO functions
15:44:15 <mjoldfield> Anyway, thanks for your help.
15:44:20 <geekosaur> well. the real problem is Enum already has some special behavior with respect to Bounded; but they wanted to avoid too much, and I just told a slight lie because Bounded is a reasonable proxy for "finite" here (since Enum requires that things map to Integer)
15:47:49 <crestfallen> glguy: I'm almost with you: xs == [] ++ xs   or xs == or ([] ++ xs) == or [] || or xs == False || or xs == or xs
16:46:13 <maerwald> https://github.com/yesodweb/yesod/wiki/Setting-up-PostgreSQL
16:46:20 <maerwald> are there instructions that are not 20 years old?
16:49:45 <philippD> everything besides the last two steps seem to be not yesode specific. So you could use any other postresql tutorial
16:49:59 <philippD> or am I reading this wrong
16:50:34 <maerwald> it doesn't say anything about how I tell yesod how to use postgres
16:51:47 <dysoco> Hello, I'm trying to determine if there are repeated elements on an infinite list, I have the following code: https://lpaste.net/4100693315177938944 which worked fine because in my test cases I had the 1st element repeating... but if that's not the one that repeats then the function never returns
16:52:01 <dysoco> because it can never check if the head is on repeated in the tail or not
16:52:18 <philippD> maerwald I guess it uses the default port and localhost
16:52:36 <hpc> dysoco: you're trying to detect infinite lists?
16:52:45 <glguy> dysoco: You'll never be able to confirm that an infinite list doesn't have a repeated element like this
16:52:45 <hpc> oh, i see
16:52:47 <hpc> yeah
16:53:00 <dysoco> hpc, I know it's probably infinite, I know that sounds like the Halting Problem
16:53:36 <glguy> It's not the halting problem, it's just that Haskell doesn't give you the tools to observe if a list is infinite or not
16:54:03 <hpc> it's not possible to observe if a list is infinite
16:54:14 <dysoco> yeah it makes sense
16:54:18 <hpc> consider collatz :: Int -> [Int] showing all the steps until it reaches 1
16:54:20 <glguy> You can handle more cases if you accumulate a set of all the elements you've seen so far adding to it as you go while checking for membership along the way
16:55:14 <fishythefish> dysoco: also, what is the expected behavior if I call your function on an infinite list with no repeated elements?
16:55:32 <dysoco> fishythefish, if there are no repeated elements then the list is finite
16:55:43 <dysoco> it's infinite iff there is at least one repeated element
16:55:44 <fishythefish> dysoco: why?
16:55:47 <hpc> another way is to sort the list, group it, then see if any groups are larger than 1
16:56:08 <fishythefish> dysoco: consider [1..] :: [Integer]
16:56:09 <glguy> "iff" means if and only if, so that's not right, either
16:56:24 <hpc> dysoco: are you only using this on lists generated from some particular other function?
16:56:29 <dysoco> yes
16:56:32 <philippD> dysoco: `repeat undefined`
16:56:50 <hpc> hmm, sorting won't work then
16:56:59 <maerwald> philippD: well, guessing doesn't help here, since I need to configure.
16:57:31 <hpc> dysoco: do you know the length of the longest terminating list?
16:57:42 <dysoco> glguy, In my code, the only way a list can be infinite is that if any two elements are the same at least once
16:58:03 <hpc> you can use a similar trick to solving the halting problem with BB()
16:58:04 <fishythefish> dysoco: you say it's infinite iff there's a repeated element, but then why is determining if an infinite list has a repeated element even a problem?
16:58:17 <dysoco> hpc, no, it can be pretty large, I can assume it's not going to be exaggeratedly large like >50 but then my code wouldn't be correct because someone might come with a counterexample
16:58:44 <dysoco> OK let me explain a bit better
16:58:45 <hpc> i think you're stuck then
16:59:15 <dysoco> each element on the list is a position, so a list is a list of positions, if I step on the same position twice then I'm stuck in a loop
16:59:21 <glguy> dysoco: If you're trying to solve a much narrower problem than the original question it would help to see that instead
17:00:01 <hpc> dysoco: you need an upper limit to force your function to terminate, or you need to use some other property of the generated lists
17:00:11 <dysoco> yeah that's what I thought
17:00:31 <glguy> You can do something like: foldr (\x next seen -> if Set.member x seen then True else next (Set.insert x seen)) (\_ -> False) xs Set.empty
17:00:32 <hpc> how are the lists generated?
17:00:40 <dysoco> alright there must be some other way not involving repeated elements or something, I'll keep thinking, I just wanted to know if this was a dead end
17:01:05 <hpc> dysoco: one last thing because it's pretty neat
17:01:17 <hpc> dysoco: if you know the busy beaver number that your program lives in
17:01:35 <hpc> dysoco: you can determine if it halts in finite time by running it for BB(n) steps
17:01:42 <hpc> dysoco: and if it hasn't terminated, it's never going to
17:01:55 <hpc> because busy beaver "computes" that upper bound
17:02:23 <hpc> (it also grows faster than any computable function though, so good luck actually using it)
17:02:23 <dysoco> hm I'm not familiar with busy beaver but I'll read a bit on that see if it helps, thanks
17:02:33 <hpc> it won't help you, but it's a funny bit of trivia for later
17:02:34 <glguy> dysoco: The code I pasted does what you're asking for
17:02:56 <hpc> glguy: what if the list is infinite and never repeats?
17:03:08 <glguy> hpc: then it's not a list dysoco cares about
17:03:08 <dysoco> glguy, I'll analize it a bit but this is for a code I'm writing for class and we aren't allowed anything we haven't seen in class. Should've thought of something simpler.
17:03:11 <hpc> oh right
17:03:27 <hpc> oh!
17:03:28 * hpc is stupid
17:04:03 <glguy> dysoco: The other thing to do is zip the list with the list where you drop every other element
17:04:14 <hpc> dysoco: glguy is right, i keep forgetting to exclude non-repeating infinite lists when thinking about the problem
17:04:18 <glguy> then you just need to compare each pair of elements for uniqueness
17:04:21 <hpc> it's like the opposite of happy path blindness
17:05:12 <dysoco> glguy, can you drop on an infinite list though? how do you know the element is going to be there or not at position 1 million or something?
17:05:44 <glguy> if the list has an infinite loop you'll eventually get a pair that match
17:05:52 <dysoco> yes
17:06:09 <glguy> and that happens relatively quickly in the length it takes to get to the repeat
17:06:28 <dysoco> yeah it's probably going to be in the first 10 elements but I never know for sure
17:06:51 <mniip> is this by chance at all related to decimal expansions of rationals?
17:07:23 <dysoco> I don't get "the list where I drop every other element"
17:07:24 <glguy> ?let hasLoop xs = go xs (drop 1 xs) where go (y:ys) (z:_:zs) = y == z || go ys zs; go _ _ = False
17:07:26 <lambdabot>  Defined.
17:07:41 <glguy> > hasLoop (1 : 2 : 3 : cycle [10..20])
17:07:44 <lambdabot>  True
17:08:11 <dysoco> humm ok let me analyze it for a while
17:09:00 <glguy> we can knock out the drop part with: hasLoop xs = go xs xs where go (y:ys) (_:z:zs) = y == z || go ys zs; go _ _ = False
17:09:12 <dysoco> oh snap
17:09:25 <dysoco> I think I know the boundary where the element must repeat
17:11:59 <mniip> dysoco, is this by chance at all related to decimal expansions of rationals?
17:12:36 <hpc> glguy: can't you just use tail instead of drop 1, too?
17:12:43 <dysoco> mniip, No it's not
17:13:07 <hpc> i guess that makes it error on short lists
17:13:23 <mniip> ok
17:23:25 <dysoco> ok I think I solved but just because I found a boundary M such that if there is any repetition it should happen before the Ms element in the list
17:23:30 <dysoco> so I just check in take M list
17:23:47 <dysoco> though I'm not entirely sure of that boundary but let's hope it works
17:28:19 <orion> https://gist.github.com/centromere/6d914917f0fe38a796b4f885dddeb509 <-- The error says, "Non type-variable argument in the constraint", but there clearly is a type variable in the constraint ("m"). What does this error mean?
17:33:47 <jackdk> orion: It means the `FooLog`, not the `m`
17:34:00 <jackdk> Just set `FlexibleContexts`, it's a pretty safe extension
17:34:37 <jackdk> http://dev.stephendiehl.com/hask/#the-benign
17:35:01 <orion> Thanks
17:57:00 <contiver> If I wanted help with an exercise from Lawvere's conceptual mathematics, would it be appropriate to ask here?
18:04:00 * hackage ztar 0.0.3 - Creating and extracting arbitrary archives  http://hackage.haskell.org/package/ztar-0.0.3 (brandonchinn178)
18:11:23 <nowhere_man> I just want to test something using Control.Lens, but I don't understand how to use a cabal package for just a test file
18:12:30 <nowhere_man> or with Stack, I don't care
18:14:23 <lyxia> nowhere_man: stack install lens; stack ghc -- MyTestFile.hs -my-ghc-option1 -my-ghc-option2
18:18:44 <byorgey> contiver: ##categorytheory might be a better place
18:20:02 <dmwit> nowhere_man: For old-style cabal, `cabal install lens` will make it available to GHC. For new-style cabal, you can `cabal unpack lens` to get a copy, then run `cabal new-build` in the directory it creates. Afterwards ghc and ghci executed from within that directory will have access to it (but not from outside).
18:20:15 <dmwit> The latter needs a newish GHC. 8.2 and greater, I think.
18:27:40 <monochrom> Oh w00t, Haskell Platform caught up to GHC 8.4.3 last week (I was too busy to check)
18:43:30 * hackage backprop 0.2.5.0 - Heterogeneous automatic differentation  http://hackage.haskell.org/package/backprop-0.2.5.0 (jle)
18:45:22 <glguy> hvr's cabal-env script has been handy for getting one-off new-build based ghci sessions with particular packages loaded
20:23:07 <nowhere_man> lyxia: stack is perfect, thanks
20:26:00 * hackage status-notifier-item 0.2.2.1 - A wrapper over the StatusNotifierItem/libappindicator dbus specification  http://hackage.haskell.org/package/status-notifier-item-0.2.2.1 (eyevanmalicesun)
20:30:00 * hackage gtk-sni-tray 0.1.3.2 - A standalone StatusNotifierItem/AppIndicator tray  http://hackage.haskell.org/package/gtk-sni-tray-0.1.3.2 (eyevanmalicesun)
21:00:06 <dminuoso> Stephen Diehl considers AllowAmbigiousTypes a dangerous extension. For what reason? Does it make the type system unsound?
21:03:20 <reactormonk> dminuoso, I don't think you can get to unsound, because it still has to typecheck in the end.
21:06:15 <geekosaur> it might permit the compiler to go into an infinite loop in pathological cases?
21:07:52 <glguy> dminuoso: You told *us* that he considers it as such. Next you're supposed to tell us why.
21:08:04 <glguy> or ask him..
21:10:09 <glguy> Left to guess what he means I think its that more often than not when GHC is telling you that you'd need that extension that you made a mistake, one once you fix the mistake you won't need that any more
21:10:23 <glguy> But if you're intentionally designing something to be used with TypeApplications then you're fine
21:34:06 <cocreature> I feel like AllowAmbiguousTypes should also be something that you turn on for a specific definition rather than a whole module
21:47:27 <dminuoso> glguy: Does Stephen Diehl come here often?
21:47:55 <cocreature> dminuoso: I don’t think I’ve ever seen him here?
21:47:57 <glguy> I don't know
21:49:36 <dminuoso> Ah fair enough, Ill ask him via mail
22:02:31 <simon> what are people's preferences towards tasty and hspec? I've used hspec and quite like it.
22:07:44 <cocreature> simon: I’ve used hspec in the past and mostly switched to tasty these days because I’ve found it to be sightly more flexible and I don’t use a lot of the features that hspec provides
22:07:53 <cocreature> but I don’t really have strong feelings either way. use whatever works for you
22:18:09 <simon> cocreature, I think I like the output format of tasty better.
22:20:28 <cocreature> then go for tasty :)
22:39:31 <pranaysashank> I have a library with it's own stack.yaml, inside another folder, with multiple libraries, with it's own stack.yaml. stack build in inside folders isn't picking up changes in the libraries that are outside.
23:09:14 <ManDay[m]> Morning, I'm having trouble understanding what makes monads semantically different from any other function. For example, given things like IO, I'd expect it to be done by just another polymorphic function readFromStdIn :: ([Char] -> Anything) -> Anything  - to my understand that is exactly what monads do, but I don't understand what makes them special, semantically.
23:12:03 <c_wraith> ManDay[m]: there is nothing special.  It's like asking what makes Iterator in java so special.  It's a simple pattern that has a bit of compiler support.
23:13:52 <ManDay[m]> c_wraith: Ah, okay. I misunderstood that then. I thought it essentially implied that IO (etc.) couldn't possibly be done in a functional-compatibly way without the definition of monads. Thanks.
23:14:08 <Axman6> monads are a very simple abstraction that turn out to exist everywhere in programming, and provide a very powerful interface for things which look like imperative programming (though it's more general than that)
23:14:29 <c_wraith> ManDay[m]: Nope.  The special part is that IO is a real type.  IO values represent reified effects.
23:14:50 <geekosaur> ManDay[m], the only thing monads do here is provide sequencing, by making outputs depend on inputs so they can't be reordered.
23:14:54 <dminuoso> ManDay[m]: Monad is just an interface supporting 2 functions following some laws. =)
23:15:19 <ManDay[m]> c_wraith: i'm afraid that statement shoots above my head, I've just started looking at Haskell (coming from Scheme)
23:15:27 <c_wraith> ManDay[m]: as opposed to effects being something that's just in the environment all the time in most languages.
23:15:49 <geekosaur> What makes IO work is that a value of type IO a represents a sequence of actions, not the result of those actions. In effect, we build a pure value which consists of "instructions" to the runtime, and produce that sequence of instructions as the "result" of main.
23:15:57 <geekosaur> And then an impure runtime evaluates them
23:17:25 <jackdk> the IO type is what the command pattern in OOP wishes it could be
23:17:29 <ManDay[m]> Let me try to (based upon my purely intuitive understanding of what you just said) rephrase that: The catch with, say, the IO monad is that it guarantees an order of the side-effects w.r.t. the code from which they resulted?
23:17:38 <dminuoso> ManDay[m]: Yes.
23:17:46 <ManDay[m]> Is that what you mean, in essence?
23:17:51 <cocreature> ManDay[m]: remove the word "monad" and replace it by "type"
23:17:54 <c_wraith> ManDay[m]: but being a monad is not an important part of IO
23:18:11 <dminuoso> ManDay[m]: Monad is just an abstract interface, it has no meaning of its own. We dont *need* it for anything.
23:18:13 <geekosaur> the monad itself, yes. the monad has nothing to do with IO as such, though, all it does is enforce sequencing. You could do that yourself, it's just annoying
23:18:13 <c_wraith> ManDay[m]: IO could do everything it does without the concept of a monad existing in the language
23:18:17 <dminuoso> It just happens to be a useful interface.
23:18:35 <ManDay[m]> Aha! Okay, I kind of get it! :)
23:18:43 <geekosaur> basiucally take something as a parameter and return it tupled with the actual result
23:18:53 <dminuoso> ManDay[m]: In fact Haskell didnt have Monad until a while ago.. so clearly we dont need Monad to do IO. :-)
23:19:09 <geekosaur> so now the output depends on the input, so it can't be reordered so it (say) reads before prompting.
23:19:18 <c_wraith> ManDay[m]: from another point of view:  IO is *not* a flag of some sort.  IO is a real type with real values.  Types like (IO (IO Int)) or (IO Int -> IO Bool) exist and make perfect sense.
23:19:18 <Axman6> being a monad means you get to reuse a lot of already written code - replicateM :: Monad m => Int -> m a -> m [a] only needs to be written once but I can use the same function to read 100 lines from stdin as I use to parse 100 instances of some parser combinator
23:19:53 <dminuoso> And being a monad means you get to develop intuition regarding laws without knowing their concrete implementations.
23:20:11 <ManDay[m]> Yes, these are apparently two separate issues: The purpose of a monad (and nessecity of it) on one hand, and the constraints on side-effects on the other
23:20:14 <geekosaur> meanwhile you can think of IO as being a collection of primitive constructors GetChar, PutChar, etc. --- which don;t actually do those operations, they just add an instruction to a sequence. and a Haskell program generates this sequence of instructions as the result of main
23:20:30 <dminuoso> ManDay[m]: There's no necessity for monad. Its just darn useful. :)
23:21:04 <c_wraith> geekosaur: a haskell program *is* the sequence of instructions.  :)  (main :: IO ())
23:21:18 <geekosaur> yes
23:21:32 <Axman6> (that definition gets a little murky once you add concurrency imo)
23:22:12 <Axman6> though, that also somewhat depends on the interpreter you use, the GHC RTS isn't the only possible interpreter for IO
23:22:13 <geekosaur> lots of things become murky when you add concurrency. this is no worse, arguably.
23:22:23 <Axman6> agreed
23:22:35 <jackdk> this is why I say it's what OOP's command pattern wishes it was
23:23:01 <jackdk> because it's a representation of commands-as-values, with an awesome toolkit for composing them (Functor,Applicative,Monad)
23:24:55 <cocreature> depending on how you build your OOP command pattern it does allow you inspecting the commands so you can’t always substitute it with IO in Haskell
23:25:32 <c_wraith> ManDay[m]: anyway, you are definitely correct.  Monad is one thing that's new to most new Haskell programmers and more abstract than they're used to.  IO is another thing that's new to most new Haskell programmers and more abstract than they're used to.  They're distinct, but you often run into them at the same time, and that adds complexity.
23:29:42 <ManDay[m]> Well, what I take away from this discussion is that a monad is just syntactic sugar for a very elegant (I take your word for it) concept, which could equally well be realized without explicitly specifying it as part of Haskell
23:30:09 <ManDay[m]> The real thing here (semantically) that I was missing was about IO being a "real type"
23:30:29 <ManDay[m]> (though I still have to understand what that means quantitatively)
23:31:21 <cocreature> sounds like you got the gist!
23:31:43 <c_wraith> what I meant by that is really just "It's treated the exact same way as any other type constructor with the same kind - there's no special meaning for it in the type system at all"
23:32:28 <mniip> and while you may not have access to its actual definition, you can still operate on IO values using its Monad instance
23:33:16 <c_wraith> or its many other instances, or any number of pre-existing library functions that manipulate them, and so on. :)
23:33:55 <Axman6> ManDay[m]: IO being a type whose implementation is hidden and is only accessible by a certain interface means you can't lie about the existance of effects. the fact that part of that interface is using the Monad class isn't particularly interesting to IO  being a useful thing
23:34:38 <mniip> iirc back when the idea of a monadic IO interface was conceived haskell didn't even support instances
23:34:55 <ManDay[m]> This question might be asked around here a million times (sorry), but is there a good online start-up ressource for learning Haskell (preferably for someone coming from functional programming) which explains things like that notation you use (the "=>" and the "->" and the "::" and "a (b)" and so on)?
23:35:07 <ManDay[m]> (explains that among other things)
23:36:09 <mniip> ManDay[m], what sort of functional programming experience do you have?
23:36:32 <ManDay[m]> Axman6: Ok, good point. So Monads being part of the language allows for IO to be provided as a "black box" in the first place
23:37:01 <ManDay[m]> mniip: I come from Scheme. So basically Haskell without the sugar and with a sometimes unreadable (and unwritable) syntax
23:37:06 <cocreature> ManDay[m]: no, you could just provide the functions that the Monad typeclass gives you as ordinary functions specialized to IO
23:37:08 <mniip> ManDay[m], Monad isn't "part of the language" either, it's an ordinary class defined in a standard library
23:37:27 <mniip> ManDay[m], sounds like you might need to learn much more than just notation then
23:37:48 <ManDay[m]> cocreature: right, i let my mind slip there for a second ;-/
23:38:08 <cocreature> what the Monad typeclass allows you to abstract over different Monad instances but if all you care about is IO then that is mostly useless
23:38:14 <Axman6> ManDay[m]: I wouldn't necessarilly say monads are provided as part of the language - we have syntax sugar (which is desugared before any type checking happens, it's a very early process) which makes working with them easier, because they are amazingly, generally useful
23:38:29 <ManDay[m]> mniip: Yes, sure. But notation should be among it ;)
23:39:23 <mniip> Axman6, uhhh desugaring is very late in the pipeline
23:40:28 <mniip> unless do blocks are handled during renaming?
23:41:57 <Axman6> my understanding it was very early, which is why things like do {True} typecheck, becaus ethat desugars to True, and happens before there's any type checking for whether the contents of a do block are actually monadic
23:42:07 <Axman6> > do {True;}
23:42:09 <lambdabot>  True
23:42:18 <mniip> yes but
23:42:27 <mniip> > do (); ()
23:42:30 <lambdabot>  error:
23:42:30 <lambdabot>      • Couldn't match expected type ‘m a0’ with actual type ‘()’
23:42:30 <lambdabot>      • In a stmt of a 'do' block: ()
23:42:37 <cocreature> I’m not sure that has something to do with desugaring. that’s just how typechecking for do blocks is defined
23:42:45 <mniip> the error message mentions the do block, suggesting that the typechecker sees it
23:42:55 <cocreature> afaik all typechecking happens before desugaring to produce good error messages
23:43:00 <mniip> yes
23:43:18 <mniip> cocreature, the problem with "typechecking for do blocks" is rebindable syntax
23:45:20 <cocreature> I guess it kind of depends on what you mean by “desugaring”. you haven’t eliminated do notation from the AST when typechecking but in some sense typechecking desugars the do syntax on the fly
23:45:49 <mniip> how
23:46:21 <mniip> 'do x; y' -> 'x >> y'
23:46:29 <mniip> GHC.Base.>> might be wired-in,
23:46:44 <mniip> but if RebindableSyntax is enabled, this warrands an identifier lookup
23:47:00 <cocreature> sure but what’s the problem with doing an identifier lookup?
23:47:17 <mniip> that's renamer's job
23:48:19 <cocreature> ah that’s where you going
23:49:16 <cocreature> no idea how GHC handles this, I guess you could always have the renamer perform a single lookup for (>>) for each do block and attach that to the do block
23:50:15 <mniip> but what if none is in scope
23:50:37 <mniip> I guess the renamer will have to check which operations are used in a given do block
23:51:14 <dreamer_> how do I generate a function body from a string in template haskell ?
23:52:04 <dysfun> parse it?
23:52:20 <cocreature> dreamer_: take a look at the haskell-src-meta package
23:52:28 <c_wraith> yeah, there's no magic for that in template haskell.
23:54:58 <mniip> doesn't look like HsExpr stores anything other than a list of statements
23:57:05 <dreamer_> think there's a better way to do what I want I think
23:57:14 <dreamer_> ye
23:58:25 <dreamer_> seriously that monadic  onion maze
23:58:36 <dreamer_>  how do I convert Clause into ClauseQ
23:58:50 <cocreature> probably using "pure"?
