00:00:03 <AfC> That's sensible advice, I think. I really get screwed up in the newtype wrappers used to declare monad transformers and such. The implicit `runBlahT` takes a BlahT and gives you the thing inside and/or you give me the thing and we'll wrap it into a BlahT just doesn't come out from looking at the way it is in Haddocks. I squint all the time.
00:00:43 <glguy> When you're using gadt syntax it's nice to use kind signatures, easy to see the kind of the type you're making and less misleading since the type variables don't actually scope over the data constructors being defined
00:01:15 <cocreature> the fact that we often use the same name for types and constructors can also be quite confusing to beginners
00:03:13 <glguy> data Maybe :: * -> * where...
00:04:57 <dminuoso> glguy: Wouldn't that bring the confusion back since you have :: meaning both `has kind` and `has type`?
00:09:48 <quicksilver> well it avoids the confusion glguy was discussing.
00:10:10 <quicksilver> consider data Either a b where Left :: b -> Either b a ...
00:10:58 <dminuoso> Ah I suppose yeah
00:12:17 <quicksilver> however, my gut says that kind signatures are also confusing. But maybe they are less confusing if you actually teach them explicityly rather than sweeping them under the carpet
00:12:48 * quicksilver sweeps the sorts under the carpet
00:13:01 <dminuoso> Just teach TypeInType straight away!
00:15:46 <dminuoso> quicksilver: In my learning steps kind signatures were one of the most helpful concepts to learn - but it wasnt until Monad transformers that I could get a handle on them well. :)
00:20:14 <zincy> Whats the Haskell alternative to the observer pattern?
00:22:13 <liste> zincy: depends. what's the use case? GUI? messaging between objects?
00:22:22 <quicksilver> I think the observer pattern is quite applicable in haskel
00:22:29 <liste> you can implement the observer pattern just fine
00:22:47 <liste> listeners :: [String -> IO ()]
00:23:05 <zincy> Thanks
00:23:12 <quicksilver> you can possibly use threads and Chans as well (or TChans)
00:23:17 <quicksilver> depends what you need
00:24:08 <liste> for GUI, FRP is a really nice solution
00:24:27 <liste> as implemented by eg. reactive-banana
00:24:32 <liste> @hackage reactive-banana
00:24:32 <lambdabot> http://hackage.haskell.org/package/reactive-banana
00:25:10 <zincy> I have a game in a StateT Game IO and a separate Map of clients to websocket connections. I am not sure where I should push the game to the next state if no further player action is possible.
00:25:21 <zincy> Oh cool
00:26:12 <zincy> So there is a map of clients to connections , another map of games to clients subscribed
00:27:12 <zincy> The Game is basically an automaton which is progressed to the next state on player actions or should progress along  states when no player action is possible (end of hand in card game)
00:28:10 <zincy> Im confused about whether it is clean to just call a "progressGame" function whilst no player action is possible or whether this logic should be contained inside the game stateT
00:36:00 * hackage multipool-persistent-postgresql 0.1.0.1, multipool-persistent 0.1.0.1, multipool 0.1.0.1 (IanDuncan): https://qbin.io/memo-ru-lgb5
00:37:00 * hackage fastly 0.1.0.0 - A highly experimental Fastly API client.  http://hackage.haskell.org/package/fastly-0.1.0.0 (IanDuncan)
00:49:46 <dminuoso> Do PureScript folks have a category similar to Hask?
00:50:20 <dminuoso> Or do category orgigamists just not use PureScript?
00:50:29 * hackage dfinity-radix-tree 0.0.0 - A Merkleized key–value data store.  http://hackage.haskell.org/package/dfinity-radix-tree-0.0.0 (EnzoHaussecker)
00:51:26 <ventonegro> dminuoso: What about the caterogy of Purescript types with functions as morphisms?
00:51:32 <ventonegro> category*
00:51:42 <dminuoso> ventonegro: well I meant does it have a name?
00:51:47 <dminuoso> "Pure"?
00:52:00 <ventonegro> dminuoso: Ah, sorry
00:52:16 <ventonegro> Purr, maybe? :)
00:57:49 <khilan> Hello! I'm a beginner in haskell and trying to implement some functions. Plz forgive me for a silly question. What's the correct syntax for using 'let' in if ? <https://lpaste.net/3568612112051732480> (This part of code is in a 'do' block). Can someone plz hep me?
00:58:32 <thblt> khilan: you're trying to mutate a variable, right?
00:58:44 <khilan> Right sir, at a later stage
00:58:51 <cocreature> you can’t mutable variables in Haskell
00:59:08 <cocreature> (or at least not in the way you’re used to)
00:59:12 <thblt> khilan: well, you can't.  Your code looks a lot like you're trying to port a C nested for in Haskell.
00:59:18 <cocreature> make a recursive function that takes the rank as an argument
00:59:24 <khilan> But I've declared at as a mutable reference. Something like `rankRef <- newSTRef (0 :: Int)`
00:59:28 <cocreature> then you can call it with (rank + 1) as the new argument
00:59:37 <cocreature> I wouldn’t recommend using an STRef for this
00:59:41 <dminuoso> khilan: `let` just introduces a binding inside an arbitrary expression
00:59:43 <liste> khilan: then you need to use the STRef functions for mutation
00:59:50 <liste> mutation is not assignment
01:00:00 <cocreature> you can modify the value of an STRef using writeSTRef
01:00:04 <cocreature> or modifySTRef
01:00:04 <khilan> Plz Wait, I'll paste the code
01:00:30 <ventonegro> khilan: I suggest that, given you said yourself are a beginner, you stay away from ST
01:01:13 <dminuoso> khilan: Unrelatedly, the idiom `if ... then ... else return ()` is better written with `when`
01:01:18 <thblt> This really needs a step back.  The code khilan linked to is really a line-for-line port of some imperative code.  IMO it would be better to start over, thinking how to solve the problem in Haskell
01:01:40 <khilan> https://lpaste.net/5825943169304363008
01:01:47 <khilan> Plz have a look at it
01:02:09 <khilan> I know it is a bit confusing
01:02:13 <drdo> holy crap
01:02:50 <cocreature> let rank = length (filter (\(m,n) -> I.Index kernel (k,l) > I.index kernel (m,n)) (liftA2 (,) [0..29] [0..29]))
01:03:03 <cocreature> no need for any ST for calculating rank
01:03:04 <drdo> khilan: Are you trying to learn haskell?
01:03:32 <khilan> Yes actually but I also need to implement a code soon
01:04:08 <khilan> `let rank = length (filter (\(m,n) -> I.Index kernel (k,l) > I.index kernel (m,n)) (liftA2 (,) [0..29] [0..29]))` Ok, I'll try this out
01:05:06 <cocreature> don’t just try it out blindly. make sure you understand what it’s doing or ask questions if you don’t understand something
01:05:40 <khilan> yes sir
01:06:32 <khilan> Sorry but I didn't get the last part of the expression, liftA2...
01:06:45 <cocreature> your code also seems weird. you write to the same index 30*30 times
01:06:54 <cocreature> > liftA2 (,) [1,2,3] [4,5,6]
01:06:56 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
01:07:02 <cocreature> it’s equivalent to a list comprehension
01:07:12 <cocreature> > [(x,y) | x <- [1,2,3], y <- [4,5,6]]
01:07:14 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
01:07:19 <khilan> Oh ok, I see
01:07:33 <stilgart_> > (,) <$> [1,2,3] <*> [4,5,6]
01:07:36 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
01:07:54 <khilan> yes sir, actually I'm getting a runtime error. Trying to figure that out
01:08:12 <cocreature> khilan: why are you updating the same index (i,j) in line 69 30*30 times? it seems like you are just overwriting the pixel so only the last write matters
01:08:46 <cocreature> afaict you also don’t need to use any array manipulation here and you can instead create the array using makeImage
01:09:27 <khilan> Oh ok, now I understand. In the last part I.write arr...,right?
01:09:39 <cocreature> yes
01:10:06 <khilan> Oh yes, I seem to have missed one assignment in the loop
01:10:08 <cocreature> and this line is called with the same (i,j) for all (k,l) i.e. 30*30 times
01:10:51 <cocreature> I would recommend that you start by pulling parts of accBin out into separate definitions (either in a where clause) or as separate top-level definitions
01:11:50 <khilan> Ok sir, u mean small functions?
01:12:05 <cocreature> yes
01:12:21 <cocreature> your code basically consists of 6 nested loops, that’s pretty hard to read :)
01:13:07 <khilan> yes sir, that's true 😅 But I need to break the image into some contextual regions and then perform some kind of manipulation
01:13:34 <khilan> So, I was unable to think of some other way
01:14:39 <cocreature> it’s somewhat hard to say what a better way is since the current code seems to be contain a mix of logical errors (i.e. writing to the same index multiple times) and misconceptions about the way Haskell works (trying to reassign variables using let).
01:15:02 <cocreature> so I would recommend that you isolate smaller parts of that code for which it is clear what the result is supposed to be.
01:15:07 <cocreature> then people can help you express these in Haskell
01:15:56 <ManDay[m]> looking at that code I'd rather recommend reading a good tutorial on how to think and program functionally
01:16:08 <khilan> yes sir, I understand ur point. The psudocode I'm trying looks something like this <https://lpaste.net/5990068983674437632>
01:16:56 <khilan> yes sir. Actually, I've been working with python and all since long so the transition is a bit difficult for me 😅
01:16:58 <drdo> khilan: You're trying to write C in haskell
01:17:04 <ManDay[m]> khilan: that's imperative pseudo code
01:17:13 <ManDay[m]> you'd better use a imperative language to implement that as-is
01:17:15 <drdo> It's possible, but that defeats the purpose of learning haskell in the first place
01:18:04 <khilan> yes sir, I understand. But, I need to implement this algo in haskell 😅
01:18:10 <cocreature> khilan: alright, a good small part here seems to be a function that takes the contextual region as its input and outputs the rank
01:18:23 <cocreature> so start by writing that function as a new top-level definition
01:18:26 <khilan> I'll try to work in a dfferent manner
01:18:29 <khilan> yes sir
01:18:42 <cocreature> hint: I’ve already given you most of the code for this
01:19:02 <khilan> yes sir 😅 . Thank u soo much!
01:20:21 <khilan> I'll try writing this differently and ping you if I've any doubts. Thank u everyone for helping me out!
01:20:30 <thblt> Talking about learning Haskell, is there an ETA on the final version of the Haskell Book? (and hopefully dead tree version as well)
01:21:03 <ManDay[m]> khilan: For the record, you're not supposed to use "loops" or "do" in Haskell. It might sound weird, but that's the core of functional programming. The rest is just convenience and exceptions.
01:21:51 <khilan> yes sir, I'll try to avoid it. Thanks!
01:22:48 <ManDay[m]> If you want to learn functional programming, try Scheme - it will not give you the facilities to be mislead into doing such things in the first place. Once you understand the principle, Haskell may become your language of choice.
01:23:13 <ventonegro> It's fine to start with Haskell...
01:23:25 <thblt> Or read a book on Haskell, and don't try to import what you know into the language.
01:24:09 <ManDay[m]> ventonegro: khilan just gave the best example that it is more likely to mislead you (of course a good learning resource will prevent that, but still)
01:24:21 <quicksilver> I disagree quiet strongly wiht "you're not supposed to use `do` in Haskell". Do notation was added to the language for excellent reasons.
01:24:35 <quicksilver> but, I agree with the spirit of the advice you're being given. Learn to program functionally.
01:24:44 <ventonegro> ManDay[m]: Scheme has `do` and `set!`, so I fail to see your point
01:24:47 <khilan> yes sir, I'll :-)
01:25:58 <ManDay[m]> ventonegro: It has do? In which version?
01:26:25 <ManDay[m]> That wouldn't make any sense in Scheme's world.
01:26:40 <ventonegro> ManDay[m]: http://www.schemers.org/Documents/Standards/R5RS/HTML/
01:26:55 <ventonegro> ManDay[m]: It's not Haskell's `do`, obviously
01:27:48 <ventonegro> A better link: http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.2.4
01:28:24 <ManDay[m]> I can't find it in r6rs though
01:28:40 <cocreature> http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-6.html lists it
01:28:55 <ManDay[m]> Ah there, in the std lib
01:28:55 <ManDay[m]> Yes, ok
01:33:55 <Ariakenom> Haskell is the best imperative language
01:33:57 * Ariakenom has hit and now runs
01:37:03 <c50a326> hey I think I'm going to write a websockets/leveldb backend using haskell just for fun etc... what's the best way to find out which are the best libs to use for such things
01:37:13 <c50a326> e.g. npm for node.js has a site that shows how many weekly downloads and so on
01:37:18 <c50a326> and github has stars
01:37:42 <c50a326> I know that there is stack and cabal cli tools right? maybe I can use them or maybe there is some site I should use?
01:38:11 <c50a326> a search here https://www.stackage.org/lts-11.14/hoogle?q=websocket doesn't give you these kinds of insights, not sure how it's ordering results
01:48:52 <Darwin226> Hey guys. Could I get some assistance with writing rewrite rules? I get a warning that my rule may not fire "because rule "Class op >>=" for ‘>>=’ might fire first". It suggests adding a phase annotation, but after adding one I still get the warning
01:49:10 <Darwin226> and my rule indeed does not fire (but that's perhaps because I wrote it wrong)
01:49:28 <ManDay[m]> I understand "do" being of non-functional origin. In the original purpose (I'm speculating here based upon what I've read about the use of monads), it serves as syntactic sugar to make a call of nested functions, where each is being passed a result from the parent, into a more readable syntax. The origin for which is that the parent function has a side-effect and the nesting imposes an order. Without side-effects,
01:49:29 <ManDay[m]> therefore, no "do" notation should exist.
01:49:29 <Darwin226> How can I make sure my rule goes before the "Class op >>=" one?
01:50:37 <ManDay[m]> In Scheme, the lack of "do" is compensated for by the fact that stuff is ordered and I can use side-effects and adjoin multiple calls.
01:50:55 <ManDay[m]> In both cases, the origin/motivation for that particular feature is side-effects (non-functional behaviour)
01:51:58 <ManDay[m]> In that sense, I think using "do" should be an exception, and in that mostly tied to parts which have side-effects
01:52:40 <ManDay[m]> (cause otherwise, the chaining of functions in that manner should be rare)
01:53:14 <iron_houzi> Hi. I'm trying to learn monadic parser combinators while writing my own parser for Tibetan represented in latin alphabet. In Tibetan script you write in both horizontal (L2R) and vertical (T2B). Figuring out how to stack letters vertically is the main challenge. You have a root letter that can have a letter ontop of it: superscribe, and a letter below it: subscribe. I've written parsers for each of these.
01:53:14 <ventonegro> ManDay[m]: The chaining of functions is not rare in functional programming
01:53:16 <iron_houzi> I've combined them to work like an XOR, but I need true OR combination as well, where a root letter has both a superscribed and subscribed letter. The problem is that if my superscribe parser matches, it consumes the root letter, so the subscribe parser cannot be used. Is there a way to combine simple parsers to achieve my goal, or do I need a "big" parser that handles all the cases in one parsing step?
01:53:18 <iron_houzi> Here's my code so far: https://github.com/ironhouzi/hstib/blob/tib_monad/src/Main.hs
01:55:33 <ManDay[m]> ventonegro: We're talking about a particular kind of chaining f(...,g(...)) where f passes things to a higher order g(...), as opposed to passing things to just g. I think that's not so very usual.
01:56:03 <ManDay[m]> (maybe I'm wrong, I'm not experienced)
01:57:51 <encodes> is there some way to turn a function which returns a value with the type of a class defining function into a function which provides an instance of the class so that it can be used to satisfy a constraint?
01:58:02 <ManDay[m]> iron_houzi: How is root+above+below interpreted? Is it a single token so that it only makes sense together or does the "root+above"-part and the "root+below"-part of the complete thing make sense by themself?
01:58:02 <ventonegro> ManDay[m]: A non-trivial portion of my code is just a lot of calls to `traverse`
01:58:36 <ventonegro> ManDay[m]: So I think you'll soon realise that monadic bind is actually very common
01:58:37 <iron_houzi> ManDay[m]: Yes, they do make sense on their own
01:59:06 <ManDay[m]> ventonegro: Traverse as in adjoining multiple calls (such as Scheme would do with (lambda (x) (something) (something_else))) ?
01:59:45 <merijn> ManDay[m]: traverse as in
01:59:48 <merijn> :t traverse
01:59:49 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
02:00:04 <ventonegro> ManDay[m]: `traverse` applies an effectul function to a list of arguments, sequencing the effects
02:00:07 <ManDay[m]> iron_houzi: In that case, since it's a question about consumption of a common piece, you need to retain the piece, because neither of the two parser-parts "owns" it. Meaning, your parse will have to hand it back, after it's done parsing it.
02:00:08 <ManDay[m]> (i.e. return the root from the parsers)
02:00:19 <merijn> ventonegro: Which, btw doesn't use monadic bind at all :p
02:00:32 <iron_houzi> ManDay[m]: That is the question though .. it can be tokenized as a single token if all three matches .. but only two might match as well .. you get the permutation: (super+root+sub,super+root,root+sub)
02:00:46 <ManDay[m]> ventonegro: So we *are* talking about side-effects?
02:00:57 <ManDay[m]> In that case, of course, the "do" is reasonable.
02:00:58 <ManDay[m]> (in my opinion)
02:01:04 <ventonegro> merijn: true, it's for Applicative
02:01:22 <iron_houzi> ManDay[m]: Oh .. parser combinators doesn't need to consume all letters it has analyzed?
02:01:42 <ManDay[m]> iron_houzi: What is the question? My answer is: Since no one can claim ownership, they have to return (reproduce) it.
02:01:53 <ventonegro> I was trying to argue that non-trivial function composition, such as `<*>` or `>>=` are very common
02:01:56 <ManDay[m]> iron_houzi: It does consume them, but it also returns them!
02:02:18 <ManDay[m]> Of course, there is a certain arbitrariness in choosing the precedence of the parsers (top-root vs bottom-root)
02:02:22 <ventonegro> ManDay[m]: Moreover, have you seen arrows? https://www.haskell.org/arrows/
02:03:00 <iron_houzi> ManDay[m]: Thank you. I'll look into it.
02:03:18 <c50a326> guys how do you search for packages
02:03:20 <ManDay[m]> ventonegro: No, thanks for posting!
02:03:33 <c50a326> I'm finding hoogle bad, it doesn't give insights on packages like amount of downloads or stars or something?
02:03:45 <dminuoso> iron_houzi: note that a parser *combinator* is just something that takes one or more parsers and gives you a parser back =)
02:03:51 <c50a326> I need to find the best websockets lib
02:04:11 <encodes> such as a function of type 'Encodes i (Show a) => i -> (a -> String)'
02:04:23 <dminuoso> iron_houzi: `many` for example can be seen as a parser combinator. :)
02:04:45 <iron_houzi> dminuoso: Sure .. I just thought there was a basic pattern that would need to be followed in order to not break the combinatoric properties of the parsers ..
02:05:19 <dminuoso> iron_houzi: Oh that was just regarding your comment "parser combinators [dont] need to consume..."
02:05:28 <dminuoso> its parsers that can consume things, not parser combinators. :)
02:05:56 <encodes> where show is the function returned
02:06:20 <dminuoso> c50a326: You can use hackage to search for packages.
02:07:12 <iron_houzi> dminuoso: OK .. do you see how I can have a parser consume a character from the input string but also put it back into the output string and be able to combine it with other parsers when using monadic parser combinators?
02:08:12 <ManDay[m]> iron_houzi: You're not putting things back in functional programming. You're returning things.
02:08:20 <c50a326> cool thanks
02:08:20 <ManDay[m]> putting things back = "set!"
02:08:54 <dminuoso> merijn: Hey btw, I took the first cabal things to fix.. what a weird codebase :o
02:11:37 <__monty__> c50a326: Only useful place with download statistics I know is hackage but the stats aren't all that useful unless there's orders of magnitude difference. Best way I've found is to find out all the packages that do something and then look for discussions on those packages.
02:11:44 <ManDay[m]> iron_houzi: I don't know your architecture, but if your parser returns another parser for continuing, then it's simply that your returned parser must be of higher order and is reduced by one order from the first parser by getting passed the "root"
02:13:39 <encodes> with class Encodes a b where decode :: a -> Dict b
02:16:09 <__monty__> iron_houzi: Sounds like you might want the superscript parser to do a lookahead parse with the subscript parser?
02:17:04 <iron_houzi> __monty__: Yeah .. is that easily done when using monadic parser combinators?
02:17:37 <__monty__> iron_houzi: I know megaparsec has lookahead.
02:17:50 <__monty__> Not sure about other packages.
02:17:58 <encodes> perhaps its the wrong approach, its confusing
02:19:01 <iron_houzi> __monty__: OK, but I'm kindof writing it all myself .. as I'm also learning Haskell and advanced FP .. I have a feeling lookahead might be very involved at this stage ..
02:19:29 <encodes> it could have something to do with reify... possibly :-/
02:19:42 <iron_houzi> .. getting used to Monads while also learning about monadic parser combinators ..
02:21:44 <ManDay[m]> it's not about lookahead, it's about currying correctly or returning correctly. it's purely conceptual and shouldn't be related at all to language specifics like monads.
02:22:25 <ManDay[m]> parsers consume things in a specific order (necessarily so). You don't want it to consume, so you must retain it.
02:22:51 <__monty__> A non-consuming parser is the same as lookahead.
02:23:15 <ManDay[m]> i guess, if you want to call it that ;-)
02:23:55 <dminuoso> iron_houzi: Like I said, you might have an easier time learning State before Parser. :-)
02:24:42 <c50a326> is there a more appropriate embedded database for using with haskell? the leveldb libs don't seem very popular/active
02:25:23 <dminuoso> c50a326: what kind of requirements do you have?
02:26:05 <c50a326> dminuoso: very basic at the moment, some KV kinda stuff
02:26:26 <dminuoso> c50a326: Persistable?
02:26:32 <c50a326> dminuoso: yes
02:27:09 <c50a326> dminuoso: ultimately to manage identity and a directory service for chat rooms
02:27:46 <c50a326> which in the first instance is just users/messages that can be requested/streamed (websockets) for a given room
02:28:08 <__monty__> Only haskell native db I know of is project-m36.
02:28:18 <dminuoso> c50a326: You could look at haskey
02:29:54 <liste> c50a326: check out acid-state
02:29:57 <liste> @hackage acid-state
02:29:57 <lambdabot> http://hackage.haskell.org/package/acid-state
02:30:25 <dminuoso> Oh thats neat :)
02:31:48 <liste> c50a326: https://ocharles.org.uk/blog/posts/2013-12-14-24-days-of-hackage-acid-state.html is a nice introduction
02:32:15 <dminuoso> liste: That thing might be just what I need :)
02:32:47 <liste> the biggest disadvantage is that the whole dataset must fit in memory
02:33:16 <liste> though ofc you can keep just file references in it
02:34:26 <dminuoso> liste: I suppose most good key-value stores have that property (since very often top performance is demanded by them)
02:34:32 <dminuoso> Redis has that requirement too, doesnt it?
02:34:40 <liste> I think so
02:35:43 <nshepper1> the combinator for a non-consuming parser in the `parsers` package is in fact just called lookAhead
02:36:52 <ManDay[m]> iron_houzi: I think that was for you ^
02:41:43 <iron_houzi> nshepper1: Interesting, thanks
03:11:13 <c50a326> wow haskell has no love, even the haskell/network project on github has less than 200 stars
03:11:31 <Rembane> It's a ninja project.
03:11:37 <Rembane> We're trying to go under the radar.
03:11:56 <ManDay[m]> The channel seems to have 1.5k+ users, I'd call that love...
03:12:06 <dminuoso> We're just busy writing code instead of putting stars on github.
03:12:28 <dysfun> we tend not to put much stake in github stars
03:13:01 <dminuoso> How do you quantify the quality of a project?
03:13:09 <dysfun> read the code?
03:13:21 <ManDay[m]> the cool kids have all gone over to gitlab anyway
03:13:30 <dminuoso> No I mean.. is there actually a way to meaningfully deterine the quality of some code?
03:13:40 <dysfun> yes, reading it
03:13:40 <dminuoso> ManDay[m]: I've prefered gitlab for a while.
03:14:11 <dysfun> i moved by last client but one from gitlab to github because gitlab couldn't keep a tent up
03:14:23 <ManDay[m]> you've been cool before everyone else ways! I just found gitlab by accident, but I like it. esp. that you can keep a repo priv if you see fit
03:14:48 <ManDay[m]> back when i started on gitorious, THAT was the place to be...
03:15:05 <dysfun> there are still people using cgit
03:15:11 <ManDay[m]> i give gitlab 4 years until... git... gitsource comes along as the new cool
03:15:20 <ManDay[m]> cgit, ugh
03:15:34 <dysfun> i think the ultimate answer is proper bidirectional mirroring, and i don't just mean of repositories - issues, PRs etc.
03:15:59 <dysfun> then people can use what they like and we dont' have to fear any of the third party providers going away
03:16:09 <ManDay[m]> well... that's the point of git, kinda... but you have to choose your upstream eventually
03:16:36 <dysfun> well yes, you can make your own endpoint the upstream and for convenience, mirror with github, gitlab etc.
03:16:41 <ManDay[m]> not sure whether a git(lab|hub|*) repo can have an upstream set? but i suppose so?
03:17:00 <dysfun> does a fork not have an upstream set?
03:17:09 <dminuoso> ManDay[m]: For us gitlab has better integrated services, especially CI. :)
03:17:15 <locallycompact> gitlab gets CI right, I have no idea how to find how to do anything on github
03:17:18 <dysfun> dminuoso: their CI is the worst tho :?
03:17:27 <dminuoso> dysfun: It's fine for ours purposes.
03:17:31 <dminuoso> dysfun: What dont you like about it?
03:17:38 <dysfun> we had major difficulties with it just stopping working randomly
03:17:41 <dysfun> we moved to circle
03:17:58 <dysfun> and i got annoyed with that so i'm building my own at present as a commercial project
03:18:00 <dminuoso> Fair enough
03:18:14 <dminuoso> dysfun: What kind things are you building in there?
03:18:41 <dysfun> dminuoso: i'm focusing on making the basics work more than anything, seems like most CIs don't
03:18:57 <dysfun> in particular, debugging. when you fuck up a circleci configuration it spits back s-expressions
03:20:18 <dysfun> also you can bring your own docker/aws/whatever cloud for running on as standard
03:21:02 * dysfun isn't mad keen on docker generally, but i have to admit, it's very good for running tests on
03:21:15 <encodes> right now its throwing a type error; https://lpaste.net/8349289481370599424
03:22:03 <dminuoso> dysfun: Yeah fair enough. So far we haven't had too many issues with gitlab-ci but most of our things are not complex and rather trivial.
03:22:15 <dminuoso> Or maybe we were just lucky.
03:22:30 * hackage clifm 0.5.2.1 - Command Line Interface File Manager  http://hackage.haskell.org/package/clifm-0.5.2.1 (pasqu4le)
03:23:32 <dysfun> dminuoso: yeah, our needs grew and tbh none of the CIs out there today are really very good at the advanced stuff
03:23:56 <dysfun> i've been planning this for years, putting it off and off because "surely someone will fix this properly any day now!"
03:24:11 * dysfun gave up waiting
03:25:19 <dminuoso> dysfun: I guess gitlab in the end is tailored for the masses who usually have simple things.
03:25:30 <dminuoso> And for them gitlab I'd say is a great match.
03:25:48 <dysfun> right, i suppose it's fine for the basics
03:26:05 <encodes> this error seems to suggest proxy, and then reify. can anyone help?
03:26:08 <dysfun> the thing is though, i think a lot of what i do is basic, just not well supported
03:26:25 <dysfun> and i cannot for the life of me imagine that literally everything i do is so strange nothing can handle it well
03:27:21 <c50a326> what is commercialhaskell and why is it called that
03:27:34 <c50a326> I don't like this word "commercial", I spend a lot of time moaning about how things are "commercial"
03:27:47 <dysfun> c50a326: it's a group of people using haskell commercially, to promote keeping haskell useful in production
03:27:47 <dminuoso> c50a326: https://github.com/commercialhaskell/commercialhaskell#readme
03:28:32 <dysfun> the people behind it are good people with reasonable intentions
03:28:43 <dminuoso> dysfun: In a way it reminds me of this "docker" vs "nixos" battle I had. Somewhat frequently people in here tell me "this would be easy with nixos" or "just use nixos"
03:29:00 * hackage potoki-zlib 0.3 - Streaming ZLib decompression  http://hackage.haskell.org/package/potoki-zlib-0.3 (IrinaArtemeva)
03:29:08 <tdammers> everything is easy with nixos, once you have mastered the hard parts
03:29:18 <dminuoso> But nixos feels like this huge mountain of knowledge I need to absorb before I can use it. It doesnt appear to be simple.
03:29:19 <cronokirby> so nix is the haskell of build tools?
03:29:25 <cronokirby> 8^)
03:29:30 <dminuoso> tdammers: Right, and that's a bit frustrating. :(
03:29:55 <dysfun> dminuoso: nixos is horrible though
03:30:08 <c50a326> nix is a container engine?
03:30:13 <dysfun> nix is a package manager
03:30:14 <c50a326> I thought it was a package manager
03:30:27 <dysfun> it can do containers and stuff
03:30:29 <dminuoso> dysfun: why is nixos horrible?
03:30:49 <dysfun> dminuoso: well nix for starters, plus systemd
03:30:52 <c50a326> so how can "nixos vs docker" err... what does it mean
03:31:08 <dysfun> c50a326: if you are using nix already, it can handle making docker containers
03:31:15 <c50a326> I've been after something to use instead of docker since I don't like having to make sense of what docker has become these days
03:31:32 <dysfun> well i can't make sense of nix, so good luck with that
03:31:57 <c50a326> yeah but at least it's less of a load of business nonsense I think
03:32:03 <cronokirby> the only contact I've had with nix so far is people telling me how much better it is than stack
03:32:17 <dysfun> i'm not gonna argue docker isn't horrible tbh, it is. especially now i've spent ages with the docker engine api
03:32:25 <dysfun> however, nixos' docker support still uses docker
03:32:33 <c50a326> docker is all concerned with marketing, I don't like all that, not a nice direction
03:32:43 <dysfun> docker is concerned with making themselves profitable
03:33:04 <dysfun> the docker engine api gets literally everything about good api design wrong
03:33:09 <dysfun> it is a masterpiece of wrong
03:33:20 <dminuoso> dysfun: Heh I recently had this situation where I ended up with a complex docker setup, intermediate images, pushing and pulling images for caching purposes.
03:33:30 <dysfun> it's only "good" in the sense that even people doing this shit for years want to have the money to buy support
03:33:31 <dminuoso> And at the end I ended up with a container containing.. exactly one file...
03:34:02 <dysfun> dminuoso: hey, wait for my CI, building docker images will be *awesome*
03:34:44 <dminuoso> dysfun: Great. Let me tell my boss that we have to stop shipping releases for.. a while...
03:35:11 <dysfun> dminuoso: it's more like "hey, i can make this pain go away in a while, have fun for now" :D
03:35:32 <encodes> HA! good boss
03:35:33 <dminuoso> dysfun: Realistically most of our concerns are not as much the building process
03:35:44 <dminuoso> It's that we want an elegant way to deploy with networking done *just right*
03:36:41 <dysfun> i don't know quite what that means in practice, but sure
03:38:07 <encodes> did anyone check; https://lpaste.net/8349289481370599424
03:38:09 <dysfun> dminuoso: also, i'll be happy to make you a beta tester if you like
03:41:54 <tdammers> "nix vs docker" is valid once you take a step back and think about the problem you were trying to solve in the first place
03:42:24 <dysfun> ooh, is it "how can we be more hip?"
03:42:35 <dysfun> or "why isnt this webscale enough?"
03:42:39 <tdammers> the problem isn't "set up containerized infrastructure", the problem is "I have an application that needs to run on a server, and I need to make sure the server matches the application's expectations as far as the runtime environment is concerned"
03:43:36 <tdammers> the traditional way of doing that is to run the same OS on all your servers, and then script all your provisioning and deployments
03:44:03 <tdammers> following down that route, you get stuff like puppet, chef, ansible, etc.
03:44:12 * dysfun took out a kubernetes early this year to replace it with the old way
03:44:29 <dysfun> their HA wasn't actually increasing availability
03:45:12 <tdammers> then you have the brute force method of just running everything in a VM, and instead of scripting your provisioning and deployment, you just package up your tested VM images wholesale, and push those to the VM host
03:45:20 <tdammers> just tear everything down and restart the entire VM
03:46:16 <quicksilver> docker got a whole lot of people doing immutable infrastructure, and immutable infrastructure is way better.
03:46:22 <quicksilver> but I think we might be off topic?
03:46:40 <c50a326> what's the best site/resource to see the haskell built-in types and functions?
03:46:48 <c50a326> I should probably download the haskell docs on zeal actually
03:46:48 <dysfun> the documentation
03:47:30 <encodes> c50a326: http://www.cse.chalmers.se/edu/year/2017/course/TDA555/tourofprelude.html
03:48:21 <quicksilver> your haskell installation probably comes with local HTML docs (?)
03:48:28 <quicksilver> point your browser at the index.html
03:49:39 <merijn> dminuoso: I think I saw you mention my cabal changes, but then I went for lunch and my machine rebooted, so I missed what you actually said?
03:56:51 <tdammers> quicksilver: if you squint a lot, it's somewhat related to cabal vs. stack, but I really don't feel like opening that particular can of worms right now
03:57:22 <freyr> How could I define a custom list-like constructor in Haskell?
03:57:37 <cocreature> freyr: data List a = Cons a (List a) | Nil
03:58:04 <rzmt> can i search hackage docs for 3rd party package somehow?
03:58:05 <freyr> Something like datatype {a} = {a} | a:>{a}
03:58:17 <merijn> rzmt: Define "3rd party package"?
03:58:32 <cocreature> freyr: data X a = Singleton a | Cons a :> (X a)
03:58:40 <merijn> rzmt: Hoogle indexes *part* of Hackage, there's also the index which groups them by category
03:58:41 <rzmt> merijn: currently id like to search for `takeC` function
03:58:46 <rzmt> from conduit package
03:58:53 <cocreature> eh remove the Cons part
03:59:34 <merijn> Ah, sadly conduit didn't start using new haddock yet. The latest Haddock lets package docs include a package specific search function
04:00:02 <cocreature> rzmt: https://hoogle.haskell.org/?hoogle=takeC
04:01:59 <rzmt> cocreature: perfect, thanks. Got the lazy IO mostly working now, still need few changes...
04:02:17 <cocreature> friends don’t make friends use lazy IO :)
04:04:23 <merijn> Friends don't *let* friends use lazy IO :p
04:04:44 <cocreature> heh :)
04:08:04 <__monty__> With nix you can get a local hoogle that indexes all your installed packages.
04:08:10 <Yuuri> Are there any good tutorials for applicative parsers (especially with writing them from scratch)?
04:09:00 * hackage alarmclock 0.5.0.1 - Wake up and perform an action at a certain time.  http://hackage.haskell.org/package/alarmclock-0.5.0.1 (dcturner)
04:09:07 <cocreature> Yuuri: not sure but you should be able to search for a monadic parser tutorial and just remove the Monad instance if you only care about the Applicative part?
04:09:29 <merijn> Yuuri: Writing a parser from scratch using a parser combinator library or writing a parser combinator library?
04:09:55 <merijn> Yuuri: Also, is there any specific reason you're restricted to applicative parsers, rather than monadic parsers?
04:11:35 <Yuuri> merijn: freferably both: using parsers and demonstrating how they can be made
04:12:47 <Yuuri> merijn: I need that for a couple of students who haven't studied monads yet
04:13:05 <merijn> The only case I can think of right now where strictly applicative parsing makes sense is in cases like optparse-applicative
04:13:24 <merijn> Since the restriction makes sense there compared to how commandlines are historically interpreted
04:13:49 <tdammers> or you could just write all the parsers and combinators without implementing any of Monad or Applicative
04:14:28 <tdammers> you'll end up writing specialized versions of fmap, pure, >>=, etc., but IMO that's OK for the learning experience
04:15:12 <Yuuri> tdammers: like https://www.codewars.com/kata/54f1fdb7f29358dd1f00015d , I suppose?
04:17:14 <tdammers> Yuuri: I have no idea, that thing won't load without JS, and I'm too lazy to enable it, but from the title I would guess "yes"
04:25:29 <Yuuri> Also found this: https://stackoverflow.com/a/20662831/3350784 , looks like what I need
04:25:32 <rzmt> cocreature: any tips how to detect if the stream has ended, and stop the recursion? https://lpaste.net/4919451117022085120
04:26:22 <c50a326> howcome Int has a minBound but Integer doesn't
04:26:37 <dminuoso> merijn: Ah no. I just started hacking on some cabal bits and parts.
04:26:43 <dminuoso> It's a weird codebase. :o
04:26:57 <merijn> dminuoso: Well, yes :p
04:27:00 <quicksilver> c50a326: Integer is supposed to be arbitrary sized integers (positive and negative)
04:27:01 <Yuuri> merijn: could you please elaborate on strictly applicative making less sense than monadic?
04:27:14 <c50a326> oh right
04:27:16 <Taneb> > minBound :: Int
04:27:18 <lambdabot>  -9223372036854775808
04:27:23 <Yuuri> I also wonder what kinds of grammars they can parse
04:27:26 <Taneb> > toInteger (minBound :: Int) - 1
04:27:26 <c50a326> so Integer isn't bounded, okay
04:27:28 <lambdabot>  -9223372036854775809
04:27:34 <c50a326> ah nice
04:27:42 <merijn> c50a326: Integer basically is only bounded by the size of your RAM :p
04:27:47 <quicksilver> well it kind of is, because your computer can only store so much
04:27:50 <c50a326> sounds dangerous
04:27:59 <merijn> How so?
04:28:10 <c50a326> then you can crash can't you :o
04:28:10 <quicksilver> merijn: or maybe the bounds of your virtual memory system and libgmp's allocation algorithm
04:28:16 <Taneb> If you've got an integer bigger than your computer can store, you've got bigger problems
04:28:18 <JuanDaugherty> it's a frontend for GMP?
04:28:28 <merijn> JuanDaugherty: Basically, yes.
04:28:42 <Yuuri> Probably applicative ones are context-free and monadic ones are context-sensitive, but I'm not sure if full or not
04:28:58 <encodes> ok, so having worked around the type error, am now stuck with the following; https://lpaste.net/5889345669801443328
04:29:18 <cocreature> Yuuri: it’s more a case of unless you actually extract any benefit from limiting yourself to Applicative you are just arbitrarily putting restrictions on yourself
04:29:19 <encodes> in does not "encode" properly.
04:29:22 <merijn> JuanDaugherty: One of the fastest GMP bindings around, even: http://www.wilfred.me.uk/blog/2014/10/20/the-fastest-bigint-in-the-west/
04:29:29 * hackage twitter-conduit 0.3.0 - Twitter API package with conduit interface and Streaming API support.  http://hackage.haskell.org/package/twitter-conduit-0.3.0 (TakahiroHimura)
04:30:10 <JuanDaugherty> merijn, ack
04:31:28 <JuanDaugherty> i guess on that chart c/c++ would be zero
04:31:37 <JuanDaugherty> as a direct binding
04:32:05 <merijn> JuanDaugherty: Not necessarily, because it depends how good you'd personally be at managing the GMP API
04:32:05 <cocreature> rzmt: I don’t think you need to do anything special here. .| should terminate downstream if it requests a value and upstream does not produce one iirc
04:32:29 <JuanDaugherty> merijn, true
04:32:36 <JuanDaugherty> especially for c++
04:32:55 <encodes> eg has the same error, its supposed to encode (+), but how can a Dict be returned which captures an instance which is defined within the body of the function?
04:33:11 <Yuuri> cocreature: I've seen another opinion that more specific code means less reasoning about it
04:33:12 <quicksilver> interesting merijn
04:33:15 <quicksilver> "! For example, check out the docs for addition. This adds huge overhead"
04:33:19 <quicksilver> sorry wrong paste
04:33:24 <quicksilver> "PHP ... arbitrary size numerical functions take and return strings ... as the numbers get larger, because an increasing amount of time is spent serialising and deserialising strings representing numbers"
04:33:38 <merijn> JuanDaugherty: Also GHC can do some tricks you might not do as easily (i.e. it falls back to regular int64 when values are small enough)
04:33:49 <quicksilver> ^^ that's bonkers. if PHP is storing large numbers as strings - which is fine - why would it serialise and deserialise?
04:33:50 <merijn> quicksilver: There's some pretty dumbass choices in PHP wrt that
04:33:58 <quicksilver> you'd just write a direct ASCII addition library in C
04:34:04 <quicksilver> which would be reasonably performant.
04:34:10 <quicksilver> I meant it wouldn't be GMP quality but it would be ok.
04:34:16 <cocreature> Yuuri: I’d agree for that if you are working with a polymorphic type but if you have a concrete type (e.g. the Parser type) then I don’t think there is much to be gained by limiting the interface exposed to users to an Applicative one
04:34:22 <quicksilver> no deserialisation required.
04:34:36 <cocreature> Yuuri: the _users_ of your parser library can ofc still limit themselves to Applicative operations if they find that easier to work with
04:34:39 <merijn> quicksilver: Admire this beauty of an issue and it's comments: https://bugs.php.net/bug.php?id=54547
04:34:57 <merijn> quicksilver: Note how the "fix" to the problem introduces a MASSIVE regression :)
04:35:05 <encodes> is it even possible to do?
04:35:20 <quicksilver> :)
04:35:24 <Yuuri> cocreature: as for applicative vs monadic parsers, I've also read this: https://stackoverflow.com/questions/7861903/what-are-the-benefits-of-applicative-parsing-over-monadic-parsing
04:36:12 <cocreature> Yuuri: right, the “static analysis” part is what I meant by “extracting a benefit from limiting yourself to Applicative”
04:36:29 <cocreature> Yuuri: e.g. for optparse-applicative it is crucial that it can inspect your parser to produce things like the --help output
04:36:58 <c50a326> do you guys use vim or what
04:37:01 <cocreature> Yuuri: but for a general-purpose parser library, I think providing a monadic interface is usually the better choice
04:37:04 <dminuoso> @Jeff: You have to understand in PHP 1, 1.0 and "1.0" all are equivalent (in most situations). That's by design.
04:37:04 <lambdabot> Unknown command, try @list
04:37:07 <dminuoso> "in most situations"
04:37:09 <dminuoso> Not bad.
04:37:12 <Yuuri> cocreature: that's right what I wanted to know, thank you :)
04:37:19 <dminuoso> merijn: The comments are a hilarious read =)
04:37:31 <cocreature> encodes: what do you mean by “instance which is defined within the body of the function”. you can’t define instances in the body of a function
04:37:41 <Yuuri> (s/right/just, probably)
04:38:16 <dminuoso> Especially the md5 bit is quite hilarious
04:38:55 <merijn> c50a326: I'd say approximately 1/3rd of this channel uses vim, 1/3rd uses emacs, the remaining 1/3rd uses a mix of whatever the flavour du joure is for editors (sublime, textmate, VS Code, Atom, etc.)
04:39:00 <Ariakenom> quicksilver: Why are you sure that would be faster?
04:39:47 <merijn> cocreature: Not just for generating help, I'm pretty sure that might be doable anyway with a slightly different API
04:39:52 <c50a326> all the results on google's first page for "haskell vim" are mostly stuff to do with neovim rather than vim, that's strange
04:39:58 <quicksilver> Ariakenom: well mostly I'm saying that I don't understand the comment. If they are indeed storing bignums in ASCII then the obvious things to do is do your math in ASCII. If they are serialising/deserialising then what are they deserialising *to*?
04:40:02 <dminuoso> merijn: what if you use emacs with evil mode, does that make you an emacs or a vim user?
04:40:07 <merijn> cocreature: optparse-applicative is mostly applicative because, historically, commandline flags/options are order independent
04:40:42 <merijn> quicksilver: Some other comments suggest PHP uses bc for big math
04:40:53 <merijn> quicksilver: So they'd have to send it to a subprocess
04:41:17 <cocreature> merijn: I’d be interested to see a Monadic parser that can provide the level of inspection needed for --help. ime that level of introspection is often the main reason why I opt for an applicative interface
04:41:19 <quicksilver> ah fun
04:41:28 <encodes> cocreature: in https://lpaste.net/5889345669801443328 an attempt it shown... the instance is defined as usual, and referenced using Dict as the return type of "encodes", the idea would be to use the argument to this function as a parameter to define another instance.
04:41:43 <merijn> cocreature: Just have the API build a data structure for the parser, then generate the actual monadic parser from that?
04:42:04 <cocreature> merijn: sure but then you are not providing a monadic API to your user are you?
04:42:22 <merijn> I think it can be done
04:42:29 <cocreature> ofc you can use a monadic parser library for the actual parsing. my point is that the API that users have access to needs to be limited in some way
04:42:29 <merijn> But I'm not 100% certain
04:42:52 <merijn> I'm sure you can solve it if you throw enough type-level voodoo at it
04:45:00 <cocreature> you can probably pull some tricks ala “simple and compositional reification of monadic embedded languages” but it does at least get trickier to do this if you provide a Monadic interface
04:50:22 <encodes> cocreature: the instance on line 30 should be replaced by some definition on line 34; https://lpaste.net/5889345669801443328
04:51:39 <cocreature> encodes: I’m not sure I’m following, the instance in line 30 and 33 have different instance heads? how do you expect to replace one by the other?
04:51:51 <cocreature> encodes: also what’s the actual problem? do you get a compile error, a runtime error, …?
04:52:13 <encodes> where the value '1' would then be able to take the value 'i' which is not used in the returned Dict
04:52:57 <encodes> the problem is that both eg and eg2 return Just 3 instead of 4 when computing 2+2
04:53:53 <kreetx> hi! are there any cotchas with declareFields? I have one field that is not generated and am not sure why.. Both Has* classes are declared elsewhere
04:53:56 <cocreature> encodes: what do you mean by “computing 2+2"? which argument do you pass to "eg" to produce Just 3?
04:54:05 <encodes> 2 and 2...
04:54:11 <cocreature> alright
04:56:21 <encodes> ah, so its not clear that the instance on line 30 gives rise to a 'Next Int' instance via the synonym which defines it on line 25
04:57:53 <lyxia> you have two "2", instance line 30 adds 1 to one of them, instance line 33 throws away the other, so you somehow get 3.
04:59:16 <encodes> the idea is to delete lines 30-31, and somehow return Dict without this instance being defined at top-level.
04:59:40 <encodes> on line 34, which uses 'i' instead of the offending 1
05:02:19 <rzmt> cocreature: `takeC 5 .| sumC` seems to produce 0 even when takeC gets zero elements from upstream
05:02:35 <cocreature> encodes: I can’t help but feel like you are trying to solve a problem with typeclasses that is much better solved without them
05:08:40 <encodes> some classes have a single defining function, in which case they can be defined using 'Is', which is the requirement that they have a function of this type. The machinery being developed it to provide a way to extend these classes in a systematic way to support an additional parameter. This is useful for defining Shaped Containers where the additional parameter `encodes` a constructor. it is a very general abstraction to extend class
05:09:03 <Ariakenom> default (Rational, Integer) good?
05:10:21 <encodes> all other classes can be defined using compositions of such one-function classes, such as this approach to defining Lens, which should be extended in this way; https://lpaste.net/153315244247089152
05:13:24 <encodes> essentially its a common and powerful pattern and this just an example.
05:15:54 <Ariakenom> :t (1,,)
05:15:56 <lambdabot> Num t1 => t2 -> t3 -> (t1, t2, t3)
05:16:44 <cocreature> rzmt: how about split the problem into two parts: 1. chunk the stream into lists of 5 elements (take a look at https://stackoverflow.com/a/25429797 for how you can do this) and 2. sum the elements in these lists
05:20:16 <kreetx> alright, figured out the cotcha with declareFields: when the type of the field is a type alias, then the rhs of the type alias needs to be in scope
05:28:11 <encodes> so anyway, the idea is to return a Dict without having the ability to satisfy the constraint it captures. Wasn't there something about a $ sign to define local instances?
05:28:52 <cocreature> no, you can’t define local instances
05:29:44 <cocreature> you can play some dirty tricks like the "reflection" package does which may or may not help
05:30:52 <encodes> oh, it was a '?' and its called "implicit paramenters", perhaps that can help?
05:31:47 <encodes> reflection seems to rely on Proxy types, which seems to indicate they are not exactly whats happening here.
05:32:00 * hackage conduit 1.3.0.3 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.3.0.3 (MichaelSnoyman)
05:32:30 <lyxia> Proxy is only a sign that it doesn't use TypeApplications.
05:33:00 <lyxia> that says very little about the library itself
05:38:36 <Encodes_> searching "Dict using implicit parameters" doesnt give anything helpful.
05:40:26 <lyxia> % let ?x = 3 in Dict :: Dict (?x :: Int)
05:40:27 <yahb> lyxia: Dict
05:49:39 <Encodes_> what would this look like with entails to infer the Is instance?
05:50:50 <caryoscelus> hmm, can someone explain why `fmap _` and `let fungus = _ in fmap fungus` (or analogue with `where`) give different hole messages (the second one is useless)?
05:50:55 <caryoscelus> i.e. why doesn't ghc consider the whole context around hole when it is placed in subexpression?
05:58:02 <Encodes_> it should be possible?
05:58:56 <guessWHo> can we do this m a -> IO a ??
05:59:09 <merijn> ugh...why do I always get many non-issue traces for exceptions when running with -xc?
05:59:14 <merijn> guessWHo: Only for some monads
05:59:30 <guessWHo> merijn : how ?
05:59:46 <Taneb> guessWHo: depends on what m is
05:59:46 <merijn> guessWHo: Depends on the specific type, there's no general way
06:00:26 <guessWHo> merijn : m is another monad which has instance of MonadIO and MonadBaseControl IO
06:00:30 * hackage greskell-core 0.1.2.0, greskell 0.2.0.0, greskell-websocket 0.1.0.0 (debugito): https://qbin.io/label-sum-tp0s
06:01:00 <quicksilver> you can't
06:01:04 <merijn> guessWHo: I never could get the hang of MonadBaseControl
06:01:07 <quicksilver> you can't even do it in most concrete cases
06:01:16 <byorgey> guessWHo: MonadIO doesn't help, that only lets you go in the opporite direction, IO a -> m a
06:01:16 <quicksilver> let alone the general case
06:01:16 <merijn> And MonadIO is for the opposite of "IO a -> m a"
06:01:30 <quicksilver> consider (State s a) -> IO a
06:01:42 <quicksilver> (or indeed StateT s IO a -> IO a, it's no easier)
06:02:33 <merijn> Is there some way to only report stack traces for exceptions that reach all the way back to main/the root of the forkIO thread?
06:02:41 <liste> MonadBaseControl feels harder for the brain than Cont :)
06:03:25 <merijn> liste: Yeah, MonadUnliftIO looks much more promising, tbh
06:03:37 <caryoscelus> for completeness sake, there is a general way: `const (pure undefined) :: m a -> IO a`
06:04:51 <liste> how about just "undefined :: m a -> IO a"
06:06:21 <quicksilver> there is a vague general sense in which many common monads can be embedded in IO
06:06:30 <quicksilver> ilke you can implement State with IORefs etc.
06:06:43 <quicksilver> but it doesn't lead to a function of that type.
06:08:41 <merijn> So, does anyone know how to make "+RTS -xc" suck less?
06:08:46 <Encodes_> cant seem to place an implicit parameter in the constraint of an instance of Is...
06:10:37 <ph88> anyone know how i can handle left recursion in megaparsec ? my parser is stuck in an infinitive loop
06:10:47 <cocreature> ph88: refactor your grammar
06:11:54 <lyxia> Encodes_: you can't
06:12:20 <lyxia> that breaks coherence
06:13:47 <Encodes_> seems reasonable that given ?x :: a to be able to return Dict (Is a)
06:14:07 <Encodes_> (recall class Is a where is :: a)
06:15:08 <ph88> cocreature, i don't prefer refactoring my grammar (i will do it if it's the best solution though) because it's more difficult to read and i'm also worried about changing semantics and/or parse tree. By the way i saw parsec has this function but i couldn't find it for megaparsec https://hackage.haskell.org/package/parsec-3.1.13.0/docs/Text-Parsec-Combinator.html#v:chainl1
06:16:22 <cocreature> ph88: maybe you’re looking for makeExprParser?
06:16:57 <lyxia> Encodes_: we generally assume instances are unique, and an instance that depends on an implicit param breaks that assumption.
06:17:26 <ph88> cocreature, maybe .. i will read the docs now
06:17:49 <cocreature> ph88: but in general you can’t use left-recursion with ll parsers like megaparsec
06:19:48 <Encodes_> feeling like it could be possible to use (:-) to do something similar...
06:22:40 <ph88> cocreature, is there no function or TH that rewrite left recursion for me ?
06:22:59 <cocreature> ph88: at least I don’t know of one
06:23:46 <quicksilver> left recursion is easy to mechanically rewrite
06:24:01 <quicksilver> but, it does require you to choose names for the new non-terminals
06:24:11 <quicksilver> which is one reason not to do it automatically
06:24:33 <quicksilver> I have once written a grammar pre-processor which refactored the left-recursion out of a recursive descent parser
06:27:28 <Encodes_> instance (?x :: a) => Is a where is = x would allow capture :: a -> Dict (Is a); capture a = let ?x = a in Dict :: Is a
06:27:59 <Encodes_> its missing a Sub somewhere maybe...
06:30:22 <Labbekak> Hi, does anyone here know how to define nil and cons if you have Mu and ListF
06:30:41 <Labbekak> with Mu I mean (forall f t. (f t -> t) -> t)
06:31:24 <Labbekak> nil = Mu (\a -> a NilF)
06:31:27 <Labbekak> but cons?
06:33:08 <Saizan> cons x (Mu xs) = Mu (\a -> a (ConsF x (xs a)))
06:39:12 <Labbekak> Thanks @Saizan!
06:39:17 <Labbekak> I was so close
06:39:20 <Labbekak> :)
06:43:17 <Encodes_> cant seem to find a way round this...
06:46:40 <dmwit> I'm a bit late, but... `[1..] :: [Int]` is not an infinite list.
06:47:38 <dmwit> Even in the abstracted-away-from-machine-limits semantics.
06:48:59 <cocreature> dmwit: can I abstract away from the machine-limit “finite integer bitwidths” :)
06:49:23 <dmwit> cocreature: You can, but the Report still demands `instance Bounded Int`. =)
06:49:29 <thebnq> > [(maxBound::Int)-1 .. ] --nice
06:49:32 <lambdabot>  [9223372036854775806,9223372036854775807]
06:49:38 <cocreature> dmwit: hah, you got me there!
06:49:44 <kuribas> > [1..]
06:49:46 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
06:50:05 <kuribas> > last ([1..] :: [Int])
06:50:12 <lambdabot>  mueval-core: Time limit exceeded
06:51:44 <kuribas> > length ([1..] :: [Int])
06:51:50 <lambdabot>  mueval-core: Time limit exceeded
06:52:43 <kuribas> how does haskell know there is a maximum value?
06:52:51 <thebnq> > maxBound :: Int
06:52:54 <lambdabot>  9223372036854775807
06:53:00 <kuribas> > maxBound :: Integer
06:53:02 <lambdabot>  error:
06:53:02 <lambdabot>      • No instance for (Bounded Integer)
06:53:02 <lambdabot>          arising from a use of ‘maxBound’
06:53:03 <thebnq> Theres a Bounded class
06:53:25 <kuribas> :t enumFrom
06:53:26 <lambdabot> Enum a => a -> [a]
06:53:48 <kuribas> There's no Bounded in Enum.
06:54:26 <merijn> kuribas: The semantics of enum just say to stop after each element has been done
06:54:47 <kuribas> merijn: are they defined separately for each datatype?
06:54:54 <dmwit> yes
06:55:06 <merijn> kuribas: "enumFrom and enumFromThen should be defined with an implicit bound, thus:"
06:55:31 <merijn> kuribas: [1..] notation is just sugar for various calls to Enum, so yes
06:56:02 <dmwit> Compare:
06:56:06 <dmwit> > succ maxBound :: Int
06:56:08 <lambdabot>  *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
06:56:10 <dmwit> > enumFrom maxBound :: [Int]
06:56:13 <lambdabot>  [9223372036854775807]
06:56:50 <quicksilver> it's just a shame about the name (Enum)
06:56:51 <merijn> Specifically "[x..]" -> "enumFrom x", "[x..y]" -> "enumFromTo x y", "[x,y..]" -> "enumFromThen x y", and "[x,y..z]" -> "enumFromThenTo x y z"
06:56:52 <dmwit> So yes, the Enum instance itself knows about the bounds on Int.
06:56:54 <kuribas> ah, they use a helper function boundedEnumFrom
06:57:14 <quicksilver> since it's about bounded arithmetic sequences
06:57:18 <quicksilver> and not about enumeration
06:57:54 <Ariakenom> Also the implementation of is bonkers for Real
06:58:00 <Encodes_> lyxia: Dict provides a way to restrict the scope of instances, or to pass them around in a restricted scope at least, so the idea of generating instances can be prevented from causing undecidability...
06:58:08 <thebnq> quicksilver: but you can have an unbounded Enum, like Integer
06:58:11 <kuribas> Ariakenom: yeah
06:58:30 <quicksilver> thebnq: sure, but the class is still partly about bounded sequences
06:58:54 <Ariakenom> Real shouldn't be a sequence
06:58:57 <Ariakenom> nor bounded
06:59:05 <merijn> Double is also awful
06:59:24 <Ariakenom> in general yes. Enum Double also yes
06:59:59 <Ariakenom> So I don't think the goal was an enumerable sequence
07:00:23 <Boomerang> > [0, 0.1 .. 0.3] -- Will it go above 0.3?
07:00:26 <lambdabot>  [0.0,0.1,0.2,0.30000000000000004]
07:01:39 <stilgart_> > 0.30000000000000004 == 0.3
07:01:41 <lambdabot>  False
07:01:47 <Ariakenom> ha
07:01:56 <Ariakenom> You call that an error?
07:02:01 <Ariakenom> > [0.5,1.5..2]
07:02:03 <lambdabot>  [0.5,1.5,2.5]
07:02:05 <stilgart_> above, indeed
07:02:18 <Ariakenom> > [0.5,1.5..2] :: Rational
07:02:20 <lambdabot>  error:
07:02:21 <lambdabot>      • Couldn't match type ‘[Double]’ with ‘Ratio Integer’
07:02:21 <lambdabot>        Expected type: Rational
07:02:28 <Boomerang> Oh wow that one is even worst :p
07:02:29 <Ariakenom> > [0.5,1.5..2] :: [Rational]
07:02:32 <lambdabot>  [1 % 2,3 % 2,5 % 2]
07:02:37 <Boomerang> *worse
07:03:12 <thebnq> > 0.300000000000000004 == 0.3
07:03:14 <lambdabot>  True
07:03:24 <Boomerang> Did you add a 0?
07:03:27 <thebnq> was 0 off from the truth :)
07:03:31 <lyxia> Encodes_: if you can generate different instances, then you can break containers. Dict does not restrict the scope of instances in a way that prevents that.
07:05:06 <dmwit> "bonkers" is too strong. The Enum Double instance makes a difficult tradeoff between many evils.
07:05:14 <Encodes_> it might not prevent it, but it at least means they can be kept from existing in the same scope by the user.
07:06:04 <Ariakenom> > [0.5,1.5..2] :: [Rational] -- dmwit: The bonkers is because it's not Enum Double
07:06:07 <lambdabot>  [1 % 2,3 % 2,5 % 2]
07:06:20 <Ariakenom> > 5 / 2
07:06:22 <lambdabot>  2.5
07:06:25 <mnoonan> lyxia: I think you can get around this by introducing names. I was just talking to iceland_jack about something similar the other day.
07:06:27 <mnoonan> https://lpaste.net/2658425112289607680
07:06:42 <dminuoso> dmwit: what does Enum Double do? increment in the least representable steps?
07:06:42 <Ariakenom> It's for Real. Which is bonkers.
07:06:50 <dminuoso> *smallest representable
07:07:03 <Ariakenom> dminuoso: No 1
07:07:09 <dminuoso> o_o
07:07:47 <mnoonan> lyxia: the idea is to make the constructed instance an instance for `Ala name a` instead of just `a`, and make `name` existentially-quantified to restrict the scope.
07:08:04 <humanoyd> Does anyone know about the status of a Fedora build of ghc 8.4.3? (https://www.haskell.org/ghc/download_ghc_8_4_3.html#linux_x86_64)
07:08:05 <Ariakenom> (Might not be Real, I don't know the number classes)
07:08:08 <mnoonan> but it also means that other instances you build will get different names, so they don't collide
07:08:23 <Encodes_> so that an error would not be thrown until two conflicting instances appeared together in a single constraint, to be handled by the inference of this constraint from those constraints which entail it.
07:09:10 <electrocat> i wonder..
07:09:12 <electrocat> > f = let f0 x = (x, x) in let f1 x = f0 (f0 x) in let f2 x = f1 (f1 x) in let f3 x = f2 (f2 x) in let f4 x = f3 (f3 x) in let f5 x = f4 (f4 x) in let f6 x = f5 (f5 x) in f6 (\x -> x)
07:09:14 <lambdabot>  <hint>:1:3: error:
07:09:14 <lambdabot>      parse error on input ‘=’
07:09:14 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
07:09:27 <electrocat> @let f = let f0 x = (x, x) in let f1 x = f0 (f0 x) in let f2 x = f1 (f1 x) in let f3 x = f2 (f2 x) in let f4 x = f3 (f3 x) in let f5 x = f4 (f4 x) in let f6 x = f5 (f5 x) in f6 (\x -> x)
07:09:43 <lambdabot> Plugin `eval' failed with: <<timeout>>
07:09:50 <electrocat> heh, ok
07:10:45 <Encodes_> type Encodes a b = Is (a -> (Dict (Is b))) allows these instances to be distinguished via equality over 'a'.
07:11:16 <dmwit> dminuoso: It increments by one if you don't specify a step (just like Int and friends); otherwise it increments by the step you designate. The thing moste people consider "bonkers" is how it determines when to stop, not how it determines the step size.
07:11:26 <mniip> electrocat, you are like a little baby, watch this
07:11:30 <dmwit> dminuoso: Namely: it stops when the value is more than half a step away from the end value you give.
07:11:50 <mniip> :t let f=(,);g=f.f;h=g.g;i=h.h;j=i.i;k=j.j in k
07:11:52 <lambdabot> a -> b1 -> (b2 -> (b3 -> (b4 -> (b5 -> (b6 -> (b7 -> (b8 -> (b9 -> (b10 -> (b11 -> (b12 -> (b13 -> (b14 -> (b15 -> (b16 -> (b17 -> (b18 -> (b19 -> (b20 -> (b21 -> (b22 -> (b23 -> (b24 -> (b25 -> (
07:11:52 <lambdabot> b26 -> (b27 -> (b28 -> (b29 -> (b30 -> (b31 -> (b32 -> (a, b32), b31), b30), b29), b28), b27), b26), b25), b24), b23), b22), b21), b20), b19), b18), b17), b16), b15), b14), b13), b12), b11), b10),
07:11:52 <lambdabot> b9), b8), b7), b6), b5), b4), b3), b2), b1)
07:11:58 <mniip> no wai
07:12:02 <mniip> :t let f=join(,);g=f.f;h=g.g;i=h.h;j=i.i;k=j.j in k
07:12:20 <dmwit> dminuoso: This is a nice way to accommodate rounding problems -- e.g. `[0, 0.1 .. 0.3]` gives pretty good results even though repeatedly adding `0.1` to itself leads to not hitting `0.3` exactly -- but it does look odd when the end value isn't chosen to be close to a multiple of the step size.
07:12:44 <Ariakenom> dmwit: But Rational doesn't have rounding errors.
07:12:58 <electrocat> mniip: lol
07:13:26 <mniip> I think it silently crashed
07:13:28 <nitrix> lambdabot: I'll bring you lemonade. Don't give up.
07:13:33 <Ariakenom> It's also not a nice way. It may be that there are no nice ways, but that isn't one
07:13:40 <mniip> % :t let f=join(,);g=f.f;h=g.g;i=h.h;j=i.i;k=j.j in k
07:13:44 <yahb> mniip: *** Exception: heap overflow
07:14:11 <mniip> fun
07:14:52 <mniip> ah yes, that's 64 nested (,) applications
07:15:09 <mniip> would've worked if the type were a graph but it's tree-ified for many applications
07:15:37 <thebnq> wow type checking bombed
07:15:55 <Ariakenom> This is the Fractional (Double, Rational) logic for Enum https://hackage.haskell.org/package/base-4.11.1.0/docs/src/GHC.Real.html#numericEnumFromThenTo
07:16:15 <lyxia> mnoonan: that's an interesting solution, it's some kind of scoped newtype.
07:16:33 <nitrix> Try with -XIQ250
07:16:36 <nitrix> (:
07:17:10 <electrocat> thebnq: well, the type checker has an exponential time complexity, that's what happens in worst cases
07:17:16 <mniip> superexponential
07:17:25 <electrocat> right
07:17:43 <mnoonan> lyxia: yeah, that seems like a nice way to think about it
07:22:04 <mniip> on a second thought running out of single letters will give you exp(exp(n/W(n)))
07:22:10 <mniip> not sure if that's still superexponential
07:23:04 <mniip> seems to be omega(c^x) but o(c^(d^x))
07:32:05 <fendor> what is the perferred way to define configurable values? e.g. a ip adress
07:32:33 <fendor> *address
07:33:01 <[exa]> depends on the context
07:33:19 <fendor> [exa], we start a server and a client shall connect to it.
07:33:24 <merijn> fendor: Parse them from the commandline or from a config file
07:33:32 * hackage gitlab-api 0.0.0.1 - Gitlab Web API  http://hackage.haskell.org/package/gitlab-api-0.0.0.1 (locallycompact)
07:33:33 <[exa]> if you're doing it for an app, you can parse a config file on the beginning and put the result in ReaderT so that everyone can ask for it
07:34:35 <fendor> thats sounds reasonable, however, some time ago I read that environment variables are sometimes recommended, when are the recommended? and if I want to use a config file, what kind of config file? INI?
07:34:50 <fendor> [exa], it is for a small app, yes
07:35:07 <[exa]> there are packages that can do both transparently
07:35:42 <[exa]> http://hackage.haskell.org/package/etc-0.4.0.3 <- one example
07:35:49 <fendor> so, it does not matter, I just have to make some decision or are there any recommendations?
07:36:12 <fendor> that looks cool
07:37:15 <[exa]> environment variables are a form of interprocess communication, spawning process sets data, executed process receives them... if that fits your scheme better than "admin sets data, worker reads them", you might want environment vars
07:37:41 <merijn> fendor: I'd personally go with config file over environment variables, because environment variables get messy and confusing fast.
07:38:05 <Cale> Environment variables are more useful if there's more than one program that can interpret the same variable
07:38:27 <Encodes_> hmm, this means that GADTs with implicit parameters as constraits cant be used either...
07:38:30 <[exa]> also, env can be changed rapidly, different for each new process
07:38:36 <fendor> thanks for the help, i will look into the etc package, it seems promisable. merijn, i agree with you, what file format would you recommend?
07:38:51 <merijn> [exa]: If you want that, just use commandline args
07:39:07 <fendor> Cale, not the use case, it is a server client architecture where server and client should probably not be on the same host machine
07:39:21 <merijn> [exa]: I don't have any strong opinion on that, tbh. The simplest thing that will work. INI should be fine if you only need simple "name -> value" mappings
07:39:44 <Encodes_> they cannot have instances defined over them. trying to avoid this undecidability problem using a newtype as normal cant work then?
07:41:09 <merijn> fendor: If you want to implement commandline config too I'd recommend optparse-applicative for that part
07:42:12 <fendor> merijn, i dont think that i want to use command line configs, but the library is great, used it a couple of times now ;D. So INI file it is
07:42:49 <[exa]> ini parser library is called just ini, iirc
07:43:48 <fendor> yep, already found it, it looks simple enough for my use case
07:51:03 --- mode: ChanServ set +o monochrom
07:51:48 <WhatisRT> Hi! I'm trying to specify type classes during runtime - I've tried the reflection library, but it seems that it is not sufficiently general for my needs. For example, I'm trying to define a function f :: forall a x y. (a -> a -> Ordering) -> (forall b. Ord b => x b -> y b) -> x a -> y a
07:53:02 <merijn> WhatisRT: Why are you trying to do that?
07:53:12 <merijn> WhatisRT: Usually you can just get by with a record of functions
07:53:27 <WhatisRT> If functor instances of x and y are required, that would also be fine, but ideally it would be possible without
07:53:28 --- mode: monochrom set +q-bo *!*@182.1.0.0/16 *!~MRd@182.1.* monochrom
07:54:23 <WhatisRT> The reason I'm doing that is that I want to call such functions over an ffi
07:55:34 <WhatisRT> I would plug in some serialized values for the a's, but at compile time I really have no information about them available
07:56:00 * hackage nonemptymap 0.0.1.0 - A NonEmptyMap Implementation  http://hackage.haskell.org/package/nonemptymap-0.0.1.0 (ChristopherDavenport)
07:56:10 <WhatisRT> So I want the foreign code to specify the function at runtime
07:57:30 * hackage gitlab-api 0.0.0.2 - Gitlab Web API  http://hackage.haskell.org/package/gitlab-api-0.0.0.2 (locallycompact)
08:01:10 <Cale> WhatisRT: It might be easier just to produce variations for each of the FFI types you want to be able to handle, since there are usually not so many of those.
08:03:27 <WhatisRT> Cale: I really do need this general construction - I need the user to allow to plug in arbitrary types for a
08:04:11 <Encodes_> is the point to make a bijection between instances and types supporting an Eq constraint?
08:04:32 <ongy> Is it possible to check for pointer-equivalence (even without Eq instance) as dirty optimisation in some cases?
08:05:10 <mnoonan> ongy: unfortunately, sort of yes
08:05:17 <merijn> ongy: As long as you don't care about sanity and correctness :p
08:05:24 <merijn> ongy: See reallyUnsafePtrEquality#
08:05:27 <ongy> not sanity, correctness would be nice :)
08:05:40 <Cale> WhatisRT: Why is this a requirement?
08:05:52 <merijn> ongy: afaik it can give you both false positives and false negatives unless you are VERY careful how you use it
08:06:16 <WhatisRT> Cale: I want to make arbitrary haskell functions available from foreign code
08:06:28 <ongy> false negative wouldn't be too bad. false positive could be bad =.=
08:06:30 <mnoonan> ongy: there is a risk of a gc moving your value around in between checking the lhs address and the rhs address
08:06:46 <glguy> There's also the StableName stuff http://hackage.haskell.org/package/base-4.11.1.0/docs/System-Mem-StableName.html
08:06:50 <glguy> Stable names are a way of performing fast (O(1)), not-quite-exact comparison between objects.
08:06:51 <Encodes_> or to encode the notion of an inverse by adding the index of one constraint to the return type of another?
08:06:54 <mnoonan> or similarly, moving something else to where your lhs was :)
08:06:55 <WhatisRT> I can handle higher order functions and type variables, but type classes have been difficult so far
08:07:33 <ongy> System.Mem.STable sounds good I guess
08:08:08 <ongy> glguy: thx. Yea, just found it googling the reallyUnsafePtrEquality thingy
08:08:34 <Peaker> hey, nix "reproducible builds" means it should hard-code the ghc version used to build the package, inside the package spec itself, right?
08:08:38 <merijn> It's in ghc-prim, obviously :)
08:09:15 <electrocat> Peaker: that specific GHC build even, yes
08:09:43 <Cale> WhatisRT: Well, Haskell's FFI doesn't really support that at all. There isn't a clear specification of the memory layout of instances, though I'm sure if you wanted to hack on GHC, something could be done about that in principle. You need something like Storable, but for type class dictionaries.
08:09:59 <electrocat> Peaker: oh nvm, i misunderstood
08:10:34 <Peaker> how do I tell nix to use ghc 8.4.3 ?
08:10:51 <electrocat> repreducible build only holds the rest of the universe (nixpkgs) doesn't change
08:10:54 <Cale> I don't think anything like that is implementable with straightforward Haskell code, since the representation of type class dictionaries isn't explicit, even though under the covers, they're similar to other record types (... though I'm not sure about what happens to associated types)
08:11:08 <WhatisRT> Cale: I don't really need FFI support for that - I use custom serialization and deserialization schemes, so I don't need memory level hacking
08:11:48 <electrocat> Peaker: use 'haskell.packages.ghc843', you should really be asking these questions in #nixos though
08:12:30 <Peaker> if you don't use that you get a random version that builds in one computer and breaks in another?
08:13:02 <electrocat> if you don't, and use haskellPackages, you get the default
08:13:24 <electrocat> it won't break at another computer, but maybe at another version of <nixpkgs>
08:13:26 <cocreature> make sure to pin nixpkgs if you care about reproducible builds
08:13:47 <electrocat> which indeed can be resolved by specifying your nixpkgs version
08:13:56 <WhatisRT> Cale: Do you have any pointers for me where to look at? Some documentation about how type classes are implemented perhaps?
08:14:01 <Cale> WhatisRT: You need something lower level than what Haskell itself is going to provide, since even if you had a type class dictionary handy in the form of a record, there's no way to provide it as the instance to be used.
08:14:29 <Cale> (This is normally important, because it would spoil the coherence of instance selection)
08:15:10 <Encodes_> unless it was stored alongside an equatable value
08:15:33 <Cale> Ordinarily, if you have any type class C and any type T, and you know that there's an instance C T, you also know that the instance C T is globally unique to the program. There's only one instance of a type class in use for any given type.
08:15:33 <Encodes_> or *as* one
08:16:52 <Peaker> electrocat, stack forces you to fully freeze all versions, actually guaranteeing reproducible builds as much as possible. I thought nix was about reproducible builds too
08:17:13 <cocreature> Peaker: if you pin nixpkgs your builds are perfectly reproducible
08:17:36 <Peaker> cocreature, So reproducible builds are opt-in? How do I pin nixpkgs to get reproducible builds?
08:17:57 <electrocat> Peaker: indeed, nix does this under the assumption that you pin the version, the same holds with staack, you pin an LTS version
08:18:15 <Peaker> electrocat, stack requires you to pin a version, you can't avoid it
08:18:18 <Encodes_> though, you can define a modification of the class where the defining function takes an additional argument, and then so long as there is a definition of how to recover a value of the type of the original function, then this value can be used. Its not so easy to make this extension process systematic...
08:18:36 <cocreature> https://nixos.wiki/wiki/How_to_fetch_Nixpkgs_with_an_empty_NIX_PATH (note that if you have nix 2.0 you don’t need the large "else" block)
08:18:41 <cocreature> but really this is not a Haskell question
08:20:13 <WhatisRT> Cale: Maybe that can be hacked with an additional type parameter? If I do something like `instance C (T a) ...`, where I use this `a` to look up the function that I want to use. The problem would then be that I'd need to write some sort of global variables...
08:20:13 <cocreature> WhatisRT: https://gist.github.com/cocreature/d366b1e20021d1da07842fced5a6af24
08:20:37 <cocreature> WhatisRT: you can replace the Functor constraint by a Coercible constraint or use unsafeCoerce (with the usual caveats)
08:21:17 <Cale> WhatisRT: This is true even in cases where there seems to be multiple ways that you could have obtained the instance. For example, you might have an instance Ord a, and obtain an instance Eq [a] from somewhere, and it might have come via using the instance Ord a => Ord [a], followed by using the fact that Eq is a superclass of Ord, or it might have come from using the fact that Eq is a superclass of Ord right away to go from Ord a to
08:21:17 <Cale> Eq a, and then using the instance Eq a => Eq [a]
08:21:36 <Cale> These necessarily are the same thing
08:23:54 <WhatisRT> cocreature: That's amazing! I've tried that for a few hours!
08:24:12 <cocreature> WhatisRT: reflection can certainly take a while to get used to :)
08:24:35 <Cale> http://hackage.haskell.org/package/reflection-2.1.3/docs/Data-Reflection.html -- there is this, but your type classes have to be set up to use it.
08:24:38 <cocreature> huh I really shouldn’t have called both the parameter and the function f
08:24:47 <cocreature> Cale: no they don’t, see my example :)
08:25:15 <cocreature> you need a special instance but no modifications to the typeclass
08:25:27 <Cale> Oh, right
08:25:33 <Cale> You can do that :)
08:26:11 <Cale> Of course, that still required special knowledge of Ord itself
08:26:46 <WhatisRT> cocreature: How would you do that with a coercible constraint?
08:28:13 <glguy> (Coercible (x a) (x (Ordable a)), Corcible (y a) (y (Ordable a))) =>
08:28:36 <glguy> with the extra s, perhaps. That I'm less sure of :)
08:28:40 <cocreature> the problem is that you need Coercible (x a) (x (Ordable s a)) and "s" is not in scope at that point
08:28:53 <cocreature> so I think I might have been wrong about being able to do this with Coercible
08:29:13 <cocreature> "unsafeCoerce" your way to glory and have fun debugging segfaults :P
08:30:13 <glguy> A bad idea might be to insist on a Coercible (x Int) (x (Sum Int)) or something like that since x will only have that instance if it's ever coercible
08:30:20 <glguy> and then using that assurance use unsafeCoerce later
08:30:20 <WhatisRT> cocreature: Thanks, I'll try that
08:30:47 <WhatisRT> The specific nature of the knowledge of the Type class is no problem, this is something I have
08:32:34 <cocreature> WhatisRT: unsafeCoerce should be safe here in the sense that it produces a valid Haskell value but you might break internal invariants in the datatype. e.g. if x = Set and you change the Ord instance, the internal invariants of Data.Set are violated
08:34:11 <glguy> another constraint is that x or y aren't GADTs with interesting equality constraints on their type parameters
08:34:53 <cocreature> good point, didn’t think of GADTs in this context
08:35:49 <WhatisRT> cocreature: I see, but I luckily don't want to actually change the instance at runtime
08:36:07 <glguy> WhatisRT: changing the instance at runtime wasn't the concern
08:38:07 <WhatisRT> I assumed the problem would be that for example internally there would be a sorted list, but if you change the Ord instance, the list wouldn't be sorted anymore
08:38:47 <WhatisRT> This at least wouldn't be a problem in my case
08:40:25 <WhatisRT> glguy: Ah, you talked about the GADTs - currently I don't want to support GADTs, but that might be an issue at a later point
08:40:36 <WhatisRT> I'll tackle eventual problems then
08:43:29 * hackage baserock-schema 0.0.3.4 - Baserock Definitions Schema  http://hackage.haskell.org/package/baserock-schema-0.0.3.4 (locallycompact)
08:45:18 <mniip> hmm should I add recursion-schemes to yahb
08:46:51 <lyxia> that sounds like a good idea
08:47:35 <glguy> WhatisRT, cocreature: https://gist.github.com/cocreature/d366b1e20021d1da07842fced5a6af24#gistcomment-2626349
08:48:30 <cocreature> glguy: I’ll just wait for QuantifiedConstraints ;)
08:49:45 <electrocat> who knows how long that will take :p
08:49:58 <cocreature> electrocat: not too long, it’s already merged :)
08:50:22 <electrocat> i'm quite sceptical :p
08:50:44 <mniip> glguy, is that a generalized sort->sortBy generalization?
08:51:03 <electrocat> i first want to see how well it works
08:51:03 <glguy_> cocreature: this has the advantage of working on types that aren't functors whether they're contravariant or invariant ones
08:51:38 <ongy> ok, it's waaaay to easy to get false negative with StableName, or I'm stupid. I guess without deepseq it's barely useable
08:52:08 <glguy_> mniip: yeah, I suppose so
08:52:30 <glguy_> ongy: deepseq doesn't help in any of the cases
08:52:49 <cocreature> glguy_: you mean compared to my version or QuantifiedConstraints?
08:52:55 <glguy_> Not with stablenames nor with unsafe pointer equality
08:53:03 <glguy_> cocreature: the original functor one
08:53:08 <cocreature> ah yeah definitely
08:53:51 <ongy> hm, I thought I get different stablenames becuase it's still in some \x -> x state. And the trace that should print in the function applied to the object is printed *after* the stable name gets created
08:55:29 <glguy_> ongy: these tools don't help you find if two values are similar, it helps you determine if two values are actually the exact same as in pointers to the same place in memory
08:55:38 <mniip> and done
08:55:40 <mniip> % :t zygoHistoPrepro
08:55:40 <yahb> mniip: (Corecursive t, Recursive t) => (Base t b -> b) -> (forall c. Base t c -> Base t c) -> (Base t (Control.Comonad.Trans.Env.EnvT b (Control.Comonad.Cofree.Cofree (Base t)) a) -> a) -> t -> a
08:56:17 <glguy_> using deepseq isn't going to help two pointers that didn't already point to the same place in memory do so
08:57:08 <ongy> glguy_: It helps when it's ptr and ((\x -> x) $ ptr) (the function is a bit more complex, but that should be the result)
08:57:47 <glguy_> OK, I can see that one working
08:59:05 <WhatisRT> Thank you so much guys, you made my day!
09:01:06 <WhatisRT> I'm working on something really really cool, I hope I can show it off in a month or two
09:09:34 <encodes> its a shame that the desire to make instances globally decidable forces reifies to encode information typically held in values at type level. Perhaps there is a workaround available by promoting an argument to type level.
09:14:13 <encodes> e.g. paramatrising a list constructor by an Int using splitAt, using reifies would demand the Int be promoted.
09:28:46 <ph88> hey guys, when i looked at some videos of eliminating left recursion they mention epsilon. How am i suppose to code that epsilon in haskell ?
09:31:18 <byorgey> ph88: I'm guessing that epsilon represents the empty string, i.e. it would correspond to a parser which consumes no input and successfully returns a unit value
09:31:33 <Solonarv> that parses is `pure ()`
09:31:46 <byorgey> right
09:31:57 <byorgey> but without more context it's hard to know for sure what the videos you watched meant.
09:32:01 <ph88> so i get unit values in my AST ?
09:32:08 <ph88> what's that suppose to represent ?
09:32:33 <ph88> the top 5 results here https://www.youtube.com/results?search_query=left+recursion
09:33:12 <geekosaur> generally would represent no value, just as `putStrln` produces IO () because we don't care about a return value
09:33:22 <geekosaur> (it either succeeds or throws and exception)
09:34:15 <geekosaur> so it's the do-nothing parser
09:35:24 <ph88> i still find it a bit strange
09:36:18 <geekosaur> why? it's more or less `id`
09:36:38 <geekosaur> if you're figuring out how parsers work, you start from the simplest parser, which is this
09:45:49 <nitrix> I think I'm in the same shoes as ph88. For me, the parser would either fail, or succeed, in which case you have one of the known tokens for the language you're parsing.
09:46:18 <nitrix> I can't understand the purpose of ().
09:47:22 <glguy> If the parser is parameterized over the type of the result value given upon a successful parse you need some type use as the result even when the result is uninteresting
09:47:51 <glguy> so an "epsilon" parser is likely to be a parser that consumes no tokens and has no intersting result. () is the standard uninteresting result
09:49:53 <nitrix> Ah, right.
09:54:50 <ongy> ok, this is really hacky. I probably shouldn't do this^^
10:00:10 <mpickering> What does the error "Dependency on unbuildable library from graphmod" mean?
10:00:56 <mpickering> Ah, it means that the dependency is not a library
10:03:08 <mightybyte> Is there something in Haskell that abstracts over processes and threads?
10:03:30 * hackage midi-util 0.2.0.1 - Utility functions for processing MIDI files  http://hackage.haskell.org/package/midi-util-0.2.0.1 (mtolly)
10:03:44 <mightybyte> I have some things that are being created with createProcess and others that I want to create with forkIO/forkOS or similar.
10:04:23 <geekosaur> abstraction there seems painful at best
10:05:16 <mightybyte> Well, in my immediate case I want to abstract over killing them.
10:06:21 <dmwit> ph88, nitrix: If a caller doesn't want a (), they can always overwrite it with another value with `(<$)` or similar. Or discard it entirely when combining with another parser with `(<*)` or `(*>)` or similar.
10:08:52 <ongy> mightybyte: if you only ever need to destroy them, store an IO ()
10:09:01 <encodes_> is it more difficult to reify kind * -> * types!?
10:09:28 <mightybyte> ongy: Oh, nice!
10:09:35 <mightybyte> That's perfect.
10:09:57 <dmwit> encodes_: `[| Maybe |]` works just fine for me.
10:10:04 <dmwit> Why do you ask?
10:10:12 <encodes_> good god
10:10:30 <encodes_> what is it!?
10:10:55 <dmwit> E_TOOVAGUE
10:11:44 <encodes_> dmwit: progress so far; https://lpaste.net/4486597844710457344
10:12:13 <dmwit> Oh, that kind of reification.
10:14:36 <encodes_> yes, not using Template Haskell
10:18:13 <encodes_> with code borrowed from; https://gist.github.com/cocreature/d366b1e20021d1da07842fced5a6af24
10:19:15 <glguy> encodes_: You "reify" *values* to the type-level. What does it mean to reify kind * -> * types?
10:22:16 <c50a326> why does `stack install --dependencies-only` start downloading a 120MB ghc-tinfo6 package?
10:22:29 <c50a326> I'm in the third world
10:22:56 <glguy> GHC doesn't get smaller when you're in the third world, and apparently GHC is a dependency of whatever you're building
10:23:06 <encodes_> saying that "instance Reifies s (a -> a -> Ordering) => Eq (Ordable s a)" acts to reify the type (a->a->Ordering), then to reify e.g. Functor...
10:23:21 <geekosaur> stack strongly prefers to use its own ghc, not a separate one.
10:23:44 <c50a326> geekosaur: does it do that for every single project? :s
10:23:55 <c50a326> or just the first time I run it?
10:24:02 <glguy> encodes_: it reifies values that have the type (a -> a -> Ordering)
10:24:05 <geekosaur> if it already has an appropriate verison installed, it'll reuse it
10:24:19 <geekosaur> but if the thing you're building uses a resolver that needs a different ghc version, it'll install a new one
10:24:32 <glguy> encodes_: which values do you have in mind with "e.g. Functor..." You trailed off too early for me to know what you were doing
10:24:43 <mjrosenb> blerg.  I'm trying to install a bunch of packages with profiling turned on, and one of them is failing to build.  When I installed it in the past, I used cabal to download the sources, editied them, then installed that into my sandbox.
10:24:59 <Solonarv> stack can do that
10:25:02 <glguy> mjrosenb: Now you can add them to your new-build's cabal.project file
10:25:06 <mjrosenb> Is there a way to do that, but get it to propagate my build flags to this project?
10:25:27 <mjrosenb> glguy: just add in ghc-options?
10:26:24 <glguy> mjrosenb: Maybe this is what you're trying to do? https://www.haskell.org/cabal/users-guide/nix-local-build.html#package-configuration-options
10:27:39 <encodes_> the example in the paste attempts to reify values of type (a -> f a -> f a) but where this has been phrased using something like (/\a -> (a -> f a -> f a)) as type 'a' is not visible to the constraint on line 47
10:28:16 <encodes_> which is the instance of a class of kind * -> * types.#
10:28:28 <glguy> encodes_: You can use a newtype wrapper in that case: newtype T = T (forall a. a -> a -> Whatever)
10:28:37 <glguy> encodes_: You can use a newtype wrapper in that case: newtype T f = T (forall a. f a -> f a -> Whatever)
10:28:49 <glguy> In order to hide the quantifier
10:29:44 <encodes_> where?
10:30:49 <mniip> curious
10:30:51 <mniip> % :i Type
10:30:52 <yahb> mniip: type Type = * -- Defined in `GHC.Types'
10:31:05 <mniip> % :set -XNoStarIsType
10:31:05 <yahb> mniip:
10:31:07 <mniip> % :i Type
10:31:07 <yahb> mniip: type Type = Type -- Defined in `GHC.Types'
10:36:21 * hackage nonemptymap 0.0.2.0 - A NonEmptyMap Implementation  http://hackage.haskell.org/package/nonemptymap-0.0.2.0 (ChristopherDavenport)
10:44:17 <encodes_> newtype T f = T (forall a. f a -> f a -> f a)
10:44:26 <encodes_> data Test i f a where Test :: Reifies i (T f) => i -> f -> a -> Test i f a
10:44:48 <encodes_> Expecting one more argument to `f1'       Expected a type, but `f1' has kind `* -> *'     * In the type `f'
10:48:36 <cocreature> encodes_: please show us the full error message
10:49:57 <encodes_> the rest is; In the definition of data constructor `Test'       In the data declaration for `Test'
10:52:04 <cocreature> you are using f in T as a type constructor that accepts one parameter. in Test you are trying to use it if it didn’t accept a parameter
10:52:16 <cocreature> one of those two things needs to change
10:52:53 <encodes_> doh!
11:02:27 <encodes_> ok, that gives a slightly better paste; https://lpaste.net/5183824749435813888
11:03:10 <encodes_> but now with an UndecidableInstances  error :-(
11:09:35 <Solonarv> you can try just turning on UndecidableInstances, it should be fine
11:09:48 <Solonarv> the checker is very conservative
11:12:47 <encodes_> no need... https://lpaste.net/5163845437748150272
11:14:40 <encodes_> so at this point can it is possible to discuss how to use Int' in the instance and somehow generate this from an Int on line 50.
11:17:17 <sras> When doing type level arithmetic, why do is get this error "• Couldn't match type ‘h’ with ‘(1 + h) - 1’" ?
11:17:43 <mjrosenb> Setup: internal error when calculating transitive package dependencies.
11:17:48 <mjrosenb> that sounds bad.
11:18:20 <Solonarv> type level arithmetic is a bit funky if you're not working with concrete numbers
11:18:46 <nitrix> mjrosenb: Using haddock?
11:19:26 <rzmt> i feel like the aggregate function is very unnecessary here, am i missing something which does the same much easier? https://lpaste.net/1896872508141862912
11:19:40 <geekosaur> sras, there are plugins that do that. type level arithmetic is very simple-minded
11:20:26 <mjrosenb> nitrix: no, I'm trying out cabal2nix, and apparently, it is building docs for everything.
11:20:50 <nitrix> mjrosenb: I see. Looks like that made you run into this: https://github.com/haskell/cabal/issues/1919
11:22:39 <mjrosenb> looks like it.
11:22:53 <mjrosenb> now I guess I just need to figure out how to disable documentation.
11:24:32 <encodes_> the idea would be to use the definition of construct for lists on line 33
11:24:37 <gonz_> mjrosenb:  I'm not a nix user really, but I've seen people specify `nohaddock` in their overrides.
11:25:44 <mjrosenb> gonz_: which overrides?
11:27:44 <gonz_> mjrosenb:  I would suggest having a look at this repo: https://github.com/Gabriel439/haskell-nix
11:28:42 <gonz_> jwiegley also has a repo with his setup that isn't project specific, but deals with having different GHC
11:28:47 <gonz_> GHCs installed
11:29:13 <johnw> https://github.com/jwiegley/nix-config/blob/master/overlays/10-haskell.nix
11:29:27 <mjrosenb> I've actually been mostlu using Gabriel439's github forlearning this :-)
11:29:34 <boyedaea> u have a code  for all: how I write for all in haskell where no for loop
11:29:35 <johnw> I can't recommend my repo for learning
11:30:35 <AWizzArd> Will GHC optimize uncalled functions away, so that they won’t end up in a resulting binary?
11:31:01 <johnw> AWizzArd: if they're not marked as INLINABLE, I think yes
11:31:08 <mjrosenb> the flag -p requires the program to be built with -prof
11:31:15 <mjrosenb> YOU DON'T SAY.
11:36:19 <boyedaea> how o write programming without loops?
11:36:30 <quicksilver> use recursion instead, boyedaea
11:36:55 <boyedaea> quicksilver:  can you give example what it means? for all how do we right
11:37:43 <quicksilver> > let ntimes 0 c = ""; ntimes n c = c : ntimes (n-1) c in ntimes 7 '*'
11:37:45 <lambdabot>  "*******"
11:37:58 <quicksilver> boyedaea: ^^ for example. print a character n times without a for loop
11:38:08 <quicksilver> but recursion can be very much like a for loop really.
11:38:34 <boyedaea> quicksilver:  ok difficult to me
11:38:46 <quicksilver> difficult at first glance
11:38:48 <quicksilver> if you're not used to it
11:38:55 <quicksilver> quite enlightening with practice
11:39:05 <boyedaea> thanks
11:39:07 <quicksilver> you should pick up a fun beginner's haskell tutorial and work through it
11:39:25 <boyedaea> quicksilver: which one
11:41:42 <encodes_> so is the type of the first argument to Reify supposed to determine the value of its second argument, or does it use a value of the first type? i.e. its the wrong idea of using Int' rather than Int to return a constructor?
11:46:47 <encodes_> the use of Proxy seems to indicate otherwise.... so the example of an Int parametrised constructor where this Int is expressed at type level is actually a rare example, so that the (families of?) types which can be used to "encode" class functions are limited?
11:52:53 <lukelau> If I have a stack of monad transformers like type MyMonad = StateT s (ReaderT r (IO)), how can I reach withReaderT to get into the middle ReaderT?
11:53:14 <exarkun> Any library for QuickCheck-like stateful testing?
11:53:38 <cocreature> exarkun: hedgehog supports statemachine testing which pretty good ime
11:53:49 <cocreature> iirc there is also something for quickcheck but I think it might be in a separate library
11:54:06 <cocreature> encodes_: by “first argument to Reify” do you mean the “s” argument in “Reifies”?
11:54:17 <lukelau> I've tried withMyMonad f = lift (withReaderT id f) but then I need to "unlift" f from StateTs (ReaderT r (IO)) to just ReaderT r (IO)
11:54:31 <zachk> lukelau, have you tried composing lifts with the the monad action you want to run?
11:54:48 <lukelau> exarkun: checkout quickcheck-state-machine
11:54:50 <exarkun> Great, thanks, I'll check out Hedgehog.
11:55:12 <johnw> Hedgehog has been working very well for me so far
11:55:15 <jb55> hedgehog types are quite complicated, I had a hard time using it :(
11:55:22 <johnw> what are hedgehog types?
11:55:29 <jb55> hedgehog's
11:55:35 <johnw> you just write generators, that's it
11:55:39 <johnw> I'm not aware of any special types
11:55:42 <lukelau> zachk: I'm not sure what parts I need to lift
11:55:48 <exarkun> quickcheck-state-machine, cool, thanks.
11:55:52 <zachk> :t ask
11:55:54 <lambdabot> MonadReader r m => m r
11:56:05 <zachk> :t lift ask
11:56:06 <lambdabot> (MonadReader a m, MonadTrans t) => t m a
11:56:25 <zachk> :t lift . lift $ ask
11:56:26 <lambdabot> (MonadReader a m, Monad (t2 m), MonadTrans t2, MonadTrans t1) => t1 (t2 m) a
11:56:34 <zachk> not sure
11:56:44 <superguest> > map putStrLn ["Hello", "World"]
11:56:46 <lambdabot>  [<IO ()>,<IO ()>]
11:57:18 <cocreature> jb55: you mean the ones specifically for state machine testing?
11:57:25 <jb55> cocreature: yes
11:57:36 <cocreature> jb55: there are some examples in the repository that I found quite helpful
11:57:43 <superguest> > putStrLn "Hello"
11:57:46 <lambdabot>  <IO ()>
11:57:51 <lukelau> :t withReaderT
11:57:52 <lambdabot> forall k r' r (m :: k -> *) (a :: k). (r' -> r) -> ReaderT r m a -> ReaderT r' m a
11:58:06 <geekosaur> superguest, no IO in lambdabot
11:58:38 <superguest> geekosaur, nor does it work in ghci
11:58:44 <lukelau> :t lift . withReaderT
11:58:45 <lambdabot> forall k (t :: (* -> *) -> * -> *) r' r (m :: k -> *) (a :: k). MonadTrans t => (r' -> r) -> t ((->) (ReaderT r m a)) (ReaderT r' m a)
11:58:49 <cocreature> wow, I’m stupid. I changed my boxed array to an unboxed array and wondered for 20 minutes why I’m now getting an error when I write undefined to it
11:59:33 <geekosaur> superguest, huh?
11:59:33 <jb55> cocreature: I found the Var/Concrete and type level stuff confusing. I think I spent a day just looking at the types and trying to figure it out. I eventually just started to write my own lib
12:00:22 <geekosaur> superguest, if you mean the map putStrLn, that's because map just maps the IO action, it doesn;t *do* the IO action
12:00:33 <geekosaur> you want traverse, or you want to apply sequence to the resulting list
12:03:10 <cocreature> jb55: if you have some concrete question, I might be able to help but if all you tell is that you found it confusing there is little anyone can do to help you :)
12:03:48 <geekosaur> superguest, an IO action buried in a list does nothing, it has to be added to the chain of IO actions reachable from main to do anything. (think about it, if they did things "by themselves" then you couldn't put one in a conditional. or a loop.)
12:03:53 <jb55> cocreature: it's ok I'm not looking for help, just someone mentioned hedgehog and I was voicing my experience :D
12:04:46 <cocreature> fair enough :)
12:08:06 <superguest> geekosaur, I confused IO for Show there.
12:16:31 <encodes_> cocreature: yes
12:17:32 <mjrosenb> ok, silly question, what section of my .cabal file do I add profiling: True to?
12:18:22 <cocreature> encodes_: the universally quantified "s" type parameter exists so that the instance can’t “escape” the scope of reify. and because s is universally quantified here you also won’t be able to unify s with anything else and thereby you still get the coherence property, i.e., there is at most one instance for a given type
12:19:24 <mjrosenb> also, is something seriously wrong with the haskell ecosystem right now? I feel like 'enable profiling on a project' should not be a multi-day ordeal.
12:20:02 <cocreature> mjrosenb: do you use new-build?
12:20:35 <nitrix> mjrosenb: Random guess with the limited information I have, probably the `ghc-options:` line, you can add -fprof-auto.
12:20:41 <mjrosenb> no, not yet.
12:20:55 <cocreature> then you probably have to do something like "cabal configure --enable-profiling"
12:21:11 <cocreature> you don’t configure this via your cabal file
12:21:11 <mjrosenb> nitrix: I have that.  When I run my program, it says that it needs to be built with profiling.
12:21:20 <cocreature> you can configure it using new-build’s cabal.project file
12:21:38 <cocreature> new-build will also automatically rebuild all your deps with profiling which the old build will not do iirc
12:22:02 <mjrosenb> cocreature: is there a getting started guide on that? I've seen pages of documentation on it, but not 'how do I get my currrent setup to the new format'.
12:22:35 <cocreature> mjrosenb: https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
12:23:17 <dmwit> mjrosenb: If it's just one package, you can `cabal new-build` with no extra effort. If you need multiple packages, then yeah, check the quickstart document cocreature linked.
12:23:20 <cocreature> mjrosenb: but unless you have some complex setup, just switching "cabal build" to "cabal new-build" might already get you halfway :)
12:23:30 <cocreature> ah dmwit beat me to it :)
12:23:54 <mjrosenb> the question still remains: what section does profiling: True go into?
12:23:58 <dmwit> Your own link beat you harder. "You can configure and build it using Nix-style local builds with this command (configuring is not necessary): cabal new-build"
12:24:10 <cocreature> mjrosenb: as I already said, it doesn’t go in the cabal file at all
12:24:15 <cocreature> you can put it in the cabal.project file
12:24:23 <dmwit> mjrosenb: `cabal new-build --enable-profiling`
12:24:26 <cocreature> but that’s new-build stuff
12:25:02 <mjrosenb> so, cabal.project is just another file in the directory alongside foo.cabal?
12:25:11 <cocreature> or in a parent directory
12:25:21 <cocreature> (if you have multiple packages)
12:25:52 <cocreature> cabal.project is similar to stack’s stack.yaml file if you have seen that
12:27:11 <encodes_> cocreature: so even using e.g. a Dict or any other attempt to embed more information into the type will fail? so that only type level ints could be used to reify e.g. an Int parametrised list constructor
12:27:45 <cocreature> encodes_: I’m not following. how does a Dict embed more information into the type?
12:28:09 <cocreature> I still have the very strong feeling that you are trying to solve a problem with typeclasses that goes completely against how typeclasses work in Haskell
12:28:37 <cocreature> but the code you showed us so far was too complex for me to understand it at a quick glance so I might be missing something
12:29:55 <sclv> mjrosenb: you just need to cabal configure with --enable-profiling and then cabal build afaik?
12:30:02 <sclv> like all the new stuff is great
12:30:15 <cocreature> sclv: that won’t rebuild deps, right?
12:30:18 <sclv> but just for the "classic" way, assuming you have profiling libs installed as well, that should be fine
12:30:34 <sclv> cocreature: yeah, if you haven't gotten your libs built with profiling you have to build them again, which is a pain
12:31:11 <sclv> but if you're doing everything all sandboxed its not awful iirc
12:31:34 <sclv> also in general I just set  `library-profiling: True` in my ~/.cabal/config
12:31:36 <cocreature> I’m so glad I mostly don’t have to deal with non-new-build cabal these days :)
12:32:02 <exarkun> What's going on when I do `x <- newIORef ()`, `modifyIORef x $ \x' -> throw Foo` in ghci?
12:32:12 <sclv> (then i never have to worry about having libs built with profiling, because thy always get built that way as well as the standard way)
12:33:35 <mjrosenb> cocreature: I have never used stack :-/
12:33:57 <mjrosenb> cabal: Failed to build documentation for fail-4.9.0.0 (which is required by
12:33:59 <mjrosenb> bah.
12:34:15 <mjrosenb> and that is with cabal new-build --enable-profiling --disable-documentation
12:34:16 <cocreature> that should only be a warning, not an error iirc?
12:34:34 <sclv> yeah, its a bug in current new-build
12:34:51 <exarkun> Laziness I guess
12:34:56 <sclv> not laziness, bug
12:34:56 <mjrosenb> well, the command returned 1.
12:35:05 <sclv> you can set documentation to False in your cabal config
12:35:20 <cocreature> exarkun: right, you are storing the exception in the IORef but you are never forcing the value
12:35:32 <cocreature> exarkun: that’s why you should generally only use exceptions with throwIO
12:35:36 <sclv> (oh, sorry, i misread what the laziness comment was in regards to :-))
12:36:42 <cocreature> although I would have expected --disable-documentation to work? does this not affect deps?
12:36:47 <exarkun> sclv: np, sorry for confusion
12:36:48 <exarkun> cocreature: oof
12:36:59 <mjrosenb> sclv: which cabal config is that?
12:37:20 <cocreature> mjrosenb: ~/.cabal/config
12:39:10 <superguest> ?let fruits = ["Apple", "Banana", "Cherry"] in "Apricot" : (tail fruits)
12:39:10 <lambdabot>  Parse failed: Parse error: in
12:39:17 <exarkun> Backing up, then.  What's a good pattern for modifying an IO ref except maybe not if the referenced value satisfies some condition?  I thought throwing an exception from the modify function would be better than checking the value first and then only calling modifyIORef sometimes.
12:39:20 <superguest> ?let fruits = ["Apple", "Banana", "Cherry"]
12:39:22 <lambdabot>  Defined.
12:39:28 <superguest> > "Apricot" : (tail fruits)
12:39:31 <lambdabot>  ["Apricot","Banana","Cherry"]
12:39:33 <exarkun> I don't think I can throwIO in the function I pass to modifyIORef though
12:40:21 <superguest> In your opinion, is it unusual to have  parens around `tail fruits` in Haskell code
12:40:22 <superguest> ?
12:40:30 * hackage parsix 0.1.0.0 - Parser combinators with slicing, error recovery, and syntax highlighting  http://hackage.haskell.org/package/parsix-0.1.0.0 (OlleFredriksson)
12:40:40 <cocreature> superguest: yeah I’d say it’s a bit unusual
12:41:52 <encodes_> cocreature: that if the type used was a constraint that all of the functions defined in the classes it demands are implmented would be brought into scope and then could be used.
12:43:17 <cocreature> exarkun: readIORef + throwIO + writeIORef?
12:44:10 <cocreature> exarkun: oh wait I didn’t read your question properly, no need for throwIO here. wrap the call to writeIORef in something like "when" or "unless"
12:45:02 <cocreature> :t \p f r -> x <- readIORef r; when (p x) (writeIORef (f x))
12:45:03 <lambdabot> error:
12:45:03 <lambdabot>     Parse error in pattern: \ p f r -> x
12:45:03 <lambdabot>     Possibly caused by a missing 'do'?
12:45:10 <cocreature> :t \p f r -> do x <- readIORef r; when (p x) (writeIORef (f x))
12:45:11 <lambdabot> error:
12:45:11 <lambdabot>     • Variable not in scope: readIORef :: t2 -> m t
12:45:11 <lambdabot>     • Perhaps you meant ‘readSTRef’ (imported from Data.STRef)
12:45:19 <cocreature> % :t \p f r -> do x <- readIORef r; when (p x) (writeIORef (f x))
12:45:19 <yahb> cocreature: ; <interactive>:1:44: error:; * Couldn't match expected type `IO ()' with actual type `a -> IO ()'; * Probable cause: `writeIORef' is applied to too few arguments; In the second argument of `when', namely `(writeIORef (f x))'; In a stmt of a 'do' block: when (p x) (writeIORef (f x)); In the expression:; do x <- readIORef r; when (p x) (writeIORef (f x)); * R
12:45:29 <cocreature> % :t \p f r -> do x <- readIORef r; when (p x) (writeIORef r (f x))
12:45:30 <yahb> cocreature: (t -> Bool) -> (t -> t) -> IORef t -> IO ()
12:45:38 <cocreature> ^ exarkun
12:46:04 <cocreature> encodes_: what is the “type used”. which type do you want to use where? can you provide some example?
12:46:25 <exarkun> I had some vague concerns about concurrency but I'm still not really clear on how that works in Haskell
12:46:45 <cocreature> encodes_: I’m sorry if I’m sounding stupid here but I’m really having a very hard time parsing your questions
12:46:57 <encodes_> this seems contradictory to the idea that the first type of reifies should uniquely determine the second, in that it provides access to functions which return different values depending on the implementation of the class of the constraint.
12:47:03 <mjrosenb> ok, has anyone had issues with doctest. Should I just install an older version of it, and hope that my problems go away?
12:47:09 <cocreature> exarkun: if you care about concurrency then you need to use atomicModifyIORef
12:47:14 <mjrosenb> and by doctest, I mean cabal-doctest
12:48:04 <cocreature> :t \p f r -> atomicModifyIORef (\x -> if p x then f x else x) r
12:48:05 <lambdabot> error:
12:48:05 <lambdabot>     Variable not in scope: atomicModifyIORef :: (p -> p) -> t -> t1
12:48:07 <cocreature> % :t \p f r -> atomicModifyIORef (\x -> if p x then f x else x) r
12:48:07 <yahb> cocreature: ; <interactive>:1:30: error:; * Couldn't match expected type `IORef a' with actual type `p -> p'; * The lambda expression `\ x -> ...' has one argument,; but its type `IORef a' has none; In the first argument of `atomicModifyIORef', namely `(\ x -> if p x then f x else x)'; In the expression: atomicModifyIORef (\ x -> if p x then f x else x) r; * Relevant bindings include;
12:48:18 <encodes_> e.g. Reifies (Dict Monoid) x =>
12:48:20 <cocreature> % :t \p f r -> atomicModifyIORef r (\x -> if p x then f x else x)
12:48:20 <yahb> cocreature: ; <interactive>:1:59: error:; * Occurs check: cannot construct the infinite type: t ~ (t, b); * In the expression: x; In the expression: if p x then f x else x; In the second argument of `atomicModifyIORef', namely `(\ x -> if p x then f x else x)'; * Relevant bindings include; x :: t (bound at <interactive>:1:33); r :: IORef t (bound at <interactive>:1:6); f
12:48:21 <fresheyeball> anyone out there know about zlib deflate?
12:48:34 <mjrosenb> https://paste.pound-python.org/show/oU37noaYeeng3QlTM8yW/ is the error that I've been seeing all week with cabal-doctest.
12:48:39 <fresheyeball> I am trapped in some kind of encoding hell
12:48:40 <cocreature> % :t \p f r -> atomicModifyIORef r (\x -> (if p x then f x else x, ()))
12:48:40 <yahb> cocreature: (t -> Bool) -> (t -> t) -> IORef t -> IO ()
12:48:48 <cocreature> ^ exarkun
12:49:25 <cocreature> encodes_: you can’t choose the "s" parameter. you need to write an instance that works for any "s" and then you can use it with the "s" that you get from "reify"
12:49:46 <cocreature> exarkun: although if you care about concurrency an MVar or a TVar might be a better choice
12:50:08 <cocreature> exarkun: and if you’re not sure about how this works in Haskell, I can highly recommend simon marlow’s book (in particular, the second part)
12:51:14 <encodes_> which assumes that there exists instance (Monoid a) x ...
12:51:27 <encodes_> instance reifies*
12:51:42 <exarkun> cocreature: I thought I probably wouldn't stick with IORef but it seemed like a simple place to start learning about this stuff.  If I use `atomicModifyIORef` then I'm back to wanting to throw?  Or rather, I also want to observe which choice is made.  But maybe that's what `b` is for in `atomicModifyIORef`?
12:51:53 <cocreature> encodes_: you need some instance similar to the one that I used in the gist you found a while back
12:52:17 <cocreature> exarkun: exactly, use the b!
12:52:32 <cocreature> % :t \p f r -> atomicModifyIORef r (\x -> let b = p x in (if b then f x else x, b))
12:52:32 <yahb> cocreature: (t -> Bool) -> (t -> t) -> IORef t -> IO Bool
12:52:37 <encodes_> such as; instance Reifies s (a -> a -> Ordering) => Eq (Ordable s a)  ?
12:52:52 <cocreature> yep
12:52:57 <encodes_> with newtype Ordable s a = Ordable { unordable :: a }
12:53:09 <exarkun> cool, thanks
12:54:35 <encodes_> Its not obvious how to use this to obtain various different functions of type (a -> a -> Ordering)
12:55:24 <cocreature> why do you want to use a typeclass to obtain various different functions of type (a -> a -> Ordering)? just pass the functions of type a -> a -> Ordering around directly?
12:57:53 <encodes_> its an attempt to use (referring to https://lpaste.net/5163845437748150272) reify to obtain something like the class construct from SetT
12:59:33 <encodes_> in that there exists a way to determine various constructors from an Int argument such as that defined on line 50.
13:00:39 <mjrosenb> so, what files are supposed to be installed for cabal-doctest?
13:00:47 <mjrosenb> since it seems to think mine are incorrect
13:01:00 * hackage linux-namespaces 0.1.3.0 - Work with linux namespaces: create new or enter existing ones  http://hackage.haskell.org/package/linux-namespaces-0.1.3.0 (MariosTitas)
13:01:12 <mjrosenb> and having just installed 1.0.5, and it still complaining, I am beginning to wonder what is actually wrong.
13:01:18 <cocreature> encodes_: are you looking for the typelevel natural numbers defined in GHC.TypeLits?
13:01:35 <cocreature> mjrosenb: what exactly is the error?
13:02:12 <mjrosenb> cocreature: https://paste.pound-python.org/show/oU37noaYeeng3QlTM8yW/
13:02:29 * hackage expressions-z3 0.1.6 - Encode and Decode expressions from Z3 ASTs  http://hackage.haskell.org/package/expressions-z3-0.1.6 (jakubdaniel)
13:02:55 <philippD> encodes_: what is the i in Constructable for?
13:04:22 <cocreature> mjrosenb: ouch that looks bad, which version of cabal and ghc are you using?
13:04:26 <encodes_> the problem then is that values of type Int is a rare example of values which can be promoted to Type level, and so using something which could bundle arbitrary types which could then be used to parametrise class functions in this way.
13:05:00 <mjrosenb> cabal-install version 2.2.0.0
13:05:00 <mjrosenb> compiled using version 2.2.0.1 of the Cabal library
13:05:01 <philippD> encodes_: with DataKinds you can promote any datatype
13:05:07 <mjrosenb> The Glorious Glasgow Haskell Compilation System, version 8.2.2
13:05:14 <encodes_> - such as Dict, which would bring value level functions into scope.
13:05:22 <mjrosenb> and it has been installed into a sandbox.
13:05:37 <cocreature> mjrosenb: new-build doesn’t use sandboxes
13:05:53 <mjrosenb> well, I also get the same error without new-build, in a sandbox.
13:05:55 <cocreature> mjrosenb: maybe try finding cabal-doctest in ~/.cabal/store and delete it
13:06:08 <cocreature> mjrosenb: what’s the output of ghc-pkg list?
13:06:18 <sclv> hrm
13:06:23 <sclv> don't mess with the store directly!
13:06:26 <sclv> that'll cause trouble
13:06:53 <cocreature> sclv: well what else do you do if something breaks? getting ghc-pkg unregister to work seems to be rather tricky ime
13:07:01 <sclv> right
13:07:07 <sclv> but deleting from the store doesn't work either
13:07:09 <encodes_> philippD: meaning that reifies could effectively be used in the way described?
13:07:11 <sclv> it just screws up the whole store
13:07:31 <cocreature> huh, I seem to recall that it just rebuild the package. I guess I’m misremembering
13:07:36 <mjrosenb> https://paste.pound-python.org/show/6d0goAkJXazcr7PBJ0C5/
13:08:12 <sclv> cocreature: you might be right
13:08:18 <sclv> i could be overly anxious here
13:08:20 <philippD> encodes_: I'm a little late to the party here. Could you summarize what exaclty you want to do?
13:08:46 <cocreature> mjrosenb: huh that’s weird, not sure what’s going on there. maybe sclv has an idea?
13:09:10 <cocreature> the fact that both new-build and old build are broken in the same way made me thought it might be a globally installed package but that doesn’t seem to be the case
13:09:30 * hackage parsix 0.1.0.1 - Parser combinators with slicing, error recovery, and syntax highlighting  http://hackage.haskell.org/package/parsix-0.1.0.1 (OlleFredriksson)
13:09:53 <mjrosenb> so, I started using nix's ghc because arch's is dumb, and did something weird, where they disabled static linking.
13:10:19 <sclv> mjrosenb: is it this issue? https://github.com/haskell/cabal/issues/4812
13:10:20 <mjrosenb> I had a ~/.cabal/config that attempted to mitigate that, but I don't think that ever worked.
13:10:27 <sclv> like if you're building only profiling and not vanilla
13:10:30 <sclv> or the like
13:11:14 <mjrosenb> I can try building it without --enable-profiling
13:11:17 <encodes_> return class functions from a type, which would then be referred to as "encoding" that class (assuming it consists of classes of one function, admitting definition by type synonym such as  found on line 42 of the paste)
13:12:26 <sclv> you should check if your cabal config has dynamic linking or static linking set
13:12:39 <sclv> the linked bug sorta explains the issue. https://github.com/haskell/cabal/issues/1720
13:13:10 <mjrosenb> it has executable-dynamic: True
13:13:16 <sclv> what you mention about arch and a custom config makes me more suspicious yeah
13:13:18 <sclv> ok, so that's the issue
13:13:26 <mjrosenb> and disabling profiling did not fix anything.
13:13:28 <sclv> you're halfway between a standard setup
13:13:32 <sclv> and a totally screwy arch setup
13:13:39 <mjrosenb> should I set executable-dynamic: False?
13:13:59 * hackage self-extract 0.3.1 - A Haskell library to make self-extracting executables  http://hackage.haskell.org/package/self-extract-0.3.1 (brandonchinn178)
13:14:00 <sclv> mm... probably?
13:14:21 <sclv> but then you might not have any static libs installed that you need
13:14:30 <sclv> otoh new-buld should be able to figure that out and handle it
13:14:48 <sclv> idk how to fix a setup that's been partially dynamic, but that's a good approach
13:15:06 <sclv> the other option is to power through and as suggested in the last comment add `ghc-options: -dynamic` to your cabal config file
13:15:16 <sclv> the issue is you only have dynamic and not static libs
13:15:23 <sclv> but it tries to build the custom setup dynamically
13:15:29 <sclv> erm i mean statically
13:15:33 <sclv> and can't find any libs
13:15:40 <cocreature> iirc new-build doesn’t properly handle the case where you only have dynamic libs. that’s what caused all the arch problems
13:15:46 <sclv> so adding that option forces the custom setup to be built dynamically as well
13:16:01 <philippD> encodes_: have to taken a look at the singletons library?
13:16:03 <sclv> otoh i suspect if you stick to new-build and just strip out the dynamic options from your config
13:16:16 <sclv> then maybe new-build will just happily build all the static stuff for you without freaking out
13:16:17 <sclv> :-/
13:16:27 <mjrosenb> can I blow away my .cabal/ everything except config, and let it re-populate it all?
13:16:34 <sclv> don't do that
13:16:39 <sclv> just change the option
13:16:44 <sclv> blowing stuff away is a last resort
13:16:55 <mjrosenb> hrmm
13:16:56 <mjrosenb> Warning: /home/mjrosenb/.cabal/config: Unrecognized field ghc-options on line
13:16:57 <mjrosenb> 148
13:17:23 <mjrosenb> that's my bad.
13:17:45 <sclv> even when you change options you shouldn't need to blow stuff away, 99% of the time
13:18:36 <sclv> (note that if you do decide to do that you can't just wipe out ~/.cabal but also need to wipe out /home/mjrosenb/.ghc/x86_64-linux-8.2.2/)
13:18:50 <sclv> (since the latter packagedb points to stuff installed in the former location
13:19:08 <mjrosenb> that also did not work.
13:19:29 * hackage pusher-http-haskell 1.5.1.5 - Haskell client library for the Pusher HTTP API  http://hackage.haskell.org/package/pusher-http-haskell-1.5.1.5 (willsewell)
13:19:46 <encodes_> Not sure about that library, its quite deep into GHC? here is an earlier attempt which might help explain the approach; https://lpaste.net/5889345669801443328
13:20:55 <sclv> mjrosenb: ok what about turning off that option and also setting executable-dynamic: False ?
13:21:05 <encodes_> but attempts made to return a Dict which incorperated the argument on line 34 were not a success..
13:24:36 <mjrosenb> sclv: I already tried with executable-dynamic: False.  That was with both executable-dynamic: False and ghc-options: -dynamic
13:24:37 <glguy> encodes_: What was the expected outcome?
13:24:44 <mjrosenb> which probably wasn't the best combination.
13:24:56 <sclv> yeah that's not the right mix
13:25:09 <sclv> you either set everything dynamic or nothing dynamic
13:25:13 <sclv> you don't want to be in th emiddle
13:25:24 <sclv> also you can't just say what you did and it didn't work
13:25:38 <sclv> if there's a particular error then you need to give both the command and the error
13:25:45 <sclv> its hard enough trying to give advice over irc as is
13:25:50 <sclv> without having all the context :-)
13:26:18 <encodes_> glguy: with that approach it was hoped to return Dicts which provided different instances to the same class, which if used together in the same Context would cause terrible Undecidability, but only at that point, without each instance being available in wider scope.
13:26:24 <cocreature> just let sclv take over your brain for a while
13:26:40 <mjrosenb> I can pastebin the output of cabal new-build -v if you want :-)
13:26:55 <sclv> i mean, if you can interpret the tickets i linked, they explain what's going on fully
13:27:54 <encodes_> which eventually failed due to the inability to write (?x :: a) => Dict (Is a) or to infer anything similar using entails...
13:28:09 <cheshircat> is there a NonEmpty-equivalent set datastructure apart fron NonNull Set (NonNull is from mono-traversable)
13:28:19 <glguy> encodes_: what you pasted behaved exactly as I would have expected. I'm wondering what specific behavior you'd expected
13:28:43 <mjrosenb> it mostly makes sense, but I don't know what the mismatch between cabal-doctest and distributive is in order to fix it :-(
13:28:56 <sclv> there's no mismatch between the two
13:29:03 <glguy> You can't have different instances for the same type. Dict wouldn't help you achieve that
13:29:06 <sclv> the problem is that doctest works by creating a custom setup
13:29:11 <sclv> and the custom setup is linked statically
13:29:15 <glguy> Dict uses the normal instance resolution process when constructing Dict _ values
13:29:18 <sclv> but you have everything else configured to only build dynamic
13:29:33 <sclv> so then it can't find the static lib for doctest (since it isn't built) and the custom setup goes boom
13:29:44 <sclv> so you _either_ set your config to _all_ static or _all_ dynamic
13:29:55 <sclv> and that eliminates the mismatch
13:30:03 <philippD> encodes_: Why do you need the Is class and Dict? couldn't Dict hold the value itself instead of capturing the Is instance?
13:30:15 <sclv> basically your current config still bears traces of being the weird one that arch suggested you put together
13:30:18 <sclv> instead of a bog-standard one
13:30:37 <mjrosenb> yeah, I am not happy with arch right now.
13:30:53 <sclv> mjrosenb: yeah everyone is mad at them and they refuse to change :-)
13:31:05 <sclv> they claim it works well for userland apps and development doesn't matter :-/
13:31:23 <sclv> one thing you can do is run `cabal user-config diff` and that shows the diff between your cabal config and the "default" one
13:31:38 <mjrosenb> oohhh, that sounds nice.
13:31:46 <sclv> so you can use that to see what's "nonstandard" in your setup
13:31:48 <sclv> and just turn that stuff off
13:32:29 <mjrosenb> it looks like the issue was that I'd set library-vanilla to false.
13:33:05 <mjrosenb> presumably because arch had changed the definition of library-vanilla? and my shiny new cabal from nix had not.
13:33:27 <sclv> well the shiny new cabal from nix doesn't overwrite the config file
13:33:31 <sclv> and arch gave you a funny config file
13:33:50 <mjrosenb> well, I gave myself a funny config file on arch's recommendation
13:33:56 <mjrosenb> not sure if that's better or worse...
13:33:58 <sclv> either way :-)
13:35:54 <encodes_> The 'Is' class was a way to represent classes of one function as a type synonym, the type Encodes (on line 11 of https://lpaste.net/5889345669801443328) then retrives the type of the class defining function ('b') and provides a new class which "extends" the one provided to one whoes defining function has the additional parameter 'a', which is then said to "encode" the class 'Is b'
13:38:47 <mjrosenb> sclv: sweet, that worked!
13:38:54 <sclv> whew!
13:39:05 <sclv> i was getting frustrated, i can imagine how you felt too :-)
13:39:33 <sclv> i always love/hate to learn about new weird corner case issues with builds and linking
13:39:54 <mjrosenb> ok, now for the fun part: to try to enable profiling.
13:40:07 <encodes_> philippD: 'Is' is a way to access the type of the class defining function, Dict was an attempt to hide Undecidable instances from each other which does not work.
13:41:02 <philippD> encodes_: I can see that, but what is this supposed to achieve.
13:45:03 <encodes_> a way to automatically extend a class defining function by one parameter
13:45:18 <encodes_> to "encode" a class by a value.
13:48:11 <encodes_> it would allow e.g. functions to return a value encoding thier inverse, such as would be for traversing Shaped Containers whoes constructor has a governing parameter. the discussion of which should be deferred.
13:50:08 <encodes_> but hopefully not for too much longer
13:52:00 <superguest> Is the quickest way to append an element into a list is to first convert the element-to-be-added into a list and `++` ?
13:52:34 <superguest> ?let mylist = ["a", "b", "c"]
13:52:35 <lambdabot>  Defined.
13:52:43 <superguest> mylist + ["d"]
13:52:49 <superguest> > mylist ++ ["d"]
13:52:51 <lambdabot>  ["a","b","c","d"]
13:53:21 <Solonarv> yeah, can't do it any quicker than that
13:53:33 <Solonarv> actually
13:53:41 <Solonarv> @hoogle [a] -> a -> [a]
13:53:43 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
13:53:43 <lambdabot> GHC.OldList intersperse :: a -> [a] -> [a]
13:53:43 <lambdabot> Data.Text.Internal.Functions intersperse :: a -> [a] -> [a]
13:59:41 <encodes_> the attempts using reify seemed more promising since they seem not to conflict so badly with the typechecker... but the need to encode the functions of the desired type using values promoted to type level is frustrating. This motivated the question about if Dict could be used instead to bring functions defined in class instances into scope, which would essentially allow superclass inheritance to serve in place of promoting complex d
14:03:59 * hackage hlrdb-core 0.1.2.0 - High-level Redis Database Core API  http://hackage.haskell.org/package/hlrdb-core-0.1.2.0 (identicalsnowflake)
14:05:11 <fresheyeball> hey out there, anyone know about zlib?
14:05:20 <fresheyeball> I can't get a thing to decompress
14:05:29 <fresheyeball> Codec.Compression.Zlib: compressed data stream format error (invalid distance too far back)
14:05:44 <fresheyeball> that is with Codec.Compression.Zlib.Raw.decompress
14:05:51 <fresheyeball> which seems right api wise
14:08:36 <superguest> someFunction param1 param2 = [...............................]
14:08:36 <superguest> 	| <condition>
14:09:04 <glguy> syntax error and uses tabs
14:09:07 <superguest> How far in should the indentation go for the `| <condition`
14:09:10 <superguest> ?
14:09:16 <Solonarv> doesn't matter
14:09:21 <monochrom> at least one space.
14:09:24 <glguy> Up to the author. I like 2 spaces
14:09:40 <superguest> This is a question on style.
14:09:42 <monochrom> In fact, it doesn't even need to be on the 2nd line.
14:10:04 <monochrom> Then 4 spaces.  So that a later "where" can be at 2 spaces.
14:10:48 <monochrom> The average programmer indents for 3.7493 spaces.
14:10:55 <Solonarv> actually I'm pretty sure `where` can be indented at the same level as guards
14:11:27 <monochrom> It can. And like I said, the guards don't even have to be on separate lines.
14:12:03 <encodes_> not knowing how to work with Proxy Dicts, the closest version to working is; https://lpaste.net/7665210734258683904
14:12:48 <RobertUDEM> \x -> \y -> ?x :: Am I right to assume that ? would be a function that takes an X as argument? (so : x=a, y=b :: a->c)?
14:13:25 <monochrom> But when it comes to using spaces to remind humans of scoping, rather than to show off what you know about fine prints, having the "where" a little bit to the left is helpful.
14:13:35 <glguy> That's either a syntax error, or it is using ImplicitParams, which is something other than what you've described
14:13:39 <glguy> RobertUDEM: ^
14:14:02 <Cale> glguy: Yeah, this must be from an assignment because other people were asking the same thing
14:14:18 <Cale> The goal is to determine the type of thing which would go in the place of the question mark
14:14:24 <RobertUDEM> it's actually a mock exam
14:14:28 <RobertUDEM> we got our final tomorrow :(
14:14:39 <encodes_> I guess the problem is the hole on line 59
14:14:50 <jollygood2> hi. in parsec is there a parsing combinator that accepts a parser and tries to parse with it but without consuming any input, returning True if parsing would succeed, and False otherwise
14:15:12 <glguy> jollygood2: lookAhead
14:15:23 <jollygood2> thanks!
14:15:59 <glguy> encodes_: In order to make a value with type (Dict (Is Int)), you'll need an: instance Is Int   declaration in your source file
14:16:20 <Cale> RobertUDEM: So yeah, if x :: a, then ? must be a function whose type is of the form a -> t for some type t
14:17:02 <RobertUDEM> Yeah. Some other students are saying that t is b (y :: b)
14:17:15 <RobertUDEM> but we don't actually know what the function do right?
14:17:20 <RobertUDEM> so it's better to use another type
14:17:28 <glguy> There's no reason that it would have to have the same type as y
14:17:51 <encodes_> glguy, then coerce a Int could be used, and this would be equivalent to type level Ints, but is more extensible
14:17:54 <glguy> :t \f x y -> f x -- you can just type this stuff into GHCi
14:17:55 <lambdabot> (t1 -> t2) -> t1 -> p -> t2
14:18:48 <Cale> It might also be nice to use the ImplicitParams extension for questions like this:
14:18:57 <Cale> :t \x y -> ?f x
14:18:57 <monochrom> You can also use typed hole and ask GHCi of "\x y -> _ x"
14:18:58 <lambdabot> (?f::t1 -> t2) => t1 -> p -> t2
14:19:20 <encodes_> oh no it couldnt...
14:19:52 <encodes_> :r
14:21:59 <glguy> encodes_: The unsafeCoerce business that reflection is doing is only marginally safe because of the Rank-2 type used in reify to ensure that the fabricated typeclass can't collide with any other type
14:22:53 <glguy> Once you've got more than one of these Dict (Is Int) around you won't be able to control which instance is being used
14:23:55 <soupladler> Hey, are there any general principles to thinking about functional programming? I'm feeling like I'm lacking some kind of fundamental intuition. I just look at problems that would take me a second to solve in imperative style and draw a complete blank.
14:23:57 <encodes_> this seems to imply the only way is to use promoted types?
14:24:20 <fresheyeball> Oh I actually made progress!
14:24:41 <fresheyeball> The string decodes base64 just fine, so it needed to be base64 decoded before it can be inflated
14:24:42 <Rembane> soupladler: Break the problem into smaller parts. Try to solve them in terms of map, filter and fold.
14:24:51 <Rembane> soupladler: Do you have any concrete example?
14:25:15 <encodes_> or support (?x :: a) => Dict (Is a)
14:26:19 <ggVGc> everything ends up being a fold if you look hard enough
14:26:28 <encodes_> forcing the Constraint tupling process to detect locally Undecidability conflicts.
14:28:49 <encodes_> at the moment I cant see how this would happen if all is available is Dict
14:32:34 <soupladler> Rembane: that's amazing actually. Just read some stuff about map, filter, and fold. I think I was getting hung up on basically every introduction to functional programming using tons of recursion
14:32:35 <mreh> hmm http://hackage.mobilehaskell.org/ is down
14:34:27 <Rembane> soupladler: Tons of recursion sounds scary. Have you got your head around recursion?
14:35:07 <soupladler> Technically, I understand the concept. In practice, I have very shaky instincts about it. It's not the kind of thing I naturally reach for, to be honest.
14:36:13 <byorgey> soupladler: recursion is fundamental to functional programming, but actually comes up surprisingly little in practice.  Typically one works in terms of higher-level functions like map, filter, fold, etc., and those functions do all the recursion for you.
14:37:06 <soupladler> Hmm. So good practice for my foundational knowledge would be to do stuff with recursion until it feels natural to me?
14:37:27 <mreh> For more information about recursion, please read this sentence.
14:37:36 <Rembane> mreh: What's the base case?
14:38:09 <mreh> I'm too lazy to read the whole thing
14:38:10 <Rembane> soupladler: Or you use map, filter and fold until you need recursion.
14:38:26 <byorgey> soupladler: if it's foundational knowledge you're after, then sure.  If you're just after an ability to get stuff done with FP, then not necessarily.
14:38:47 <soupladler> I'm learning FP basically to broaden my horizons
14:38:56 <soupladler> get a more varied idea of what programming entails
14:39:11 <soupladler> I don't need to get anything done.
14:39:27 <byorgey> Got it. Then practice recursion, for sure.
14:40:01 <soupladler> Cool :)
14:40:12 <soupladler> anything I can read?
14:40:18 <soupladler> Like good general theory books?
14:41:10 <[exa]> (I kindof wish there was a good newcomer-friendly book on that)
14:42:31 <Tuplanolla> I always recommend Software Foundations.
14:42:48 <[exa]> that's a bit too general maybe, but yes
14:43:09 <pdxleif> I guess I got used to recursion in XSLT.
14:43:11 <Tuplanolla> It's a good choice if you have three weeks of no pressure to get anything done.
14:43:12 <Rembane> Tuplanolla: These ones? https://softwarefoundations.cis.upenn.edu/current/index.html
14:43:22 <Tuplanolla> Yes, Rembane.
14:43:26 <[exa]> I like the memory on the background
14:44:13 <[exa]> soupladler: anyway, this is not haskell-specific but I learn functional-style programming from t-y-scheme
14:44:21 <Rembane> Tuplanolla: Sweet!
14:44:30 <[exa]> soupladler: https://ds26gte.github.io/tyscheme/
14:44:41 <Rembane> What about the SICP? Is that book useful in this case?
14:44:42 <soupladler> That looks really good, actually. Not sure I qualify for 'mathematical maturity' - but I'm working on that.
14:45:07 <Rembane> soupladler: You can come back here and ask questions if you get stuck.
14:45:22 <soupladler> Cool, thanks!
14:53:48 <Helom> https://tinyurl.com/ya79dnx5
14:54:25 --- mode: ChanServ set +o glguy
14:54:25 --- mode: glguy set +b *!*@62.170.224.64
14:56:10 <superguest> Is the `where` clause permitted inside list comphrensions?
14:56:20 <superguest> > [ x * 2 | x <- g where g = map abs [-1,-2, -3]]
14:56:22 <lambdabot>  <hint>:1:18: error: parse error on input ‘where’
14:56:27 <glguy> superguest: No, where isn't part of the syntax of expressions, but you can use let there
14:56:35 <glguy> let g = stuff, x <- g
14:57:47 <superguest> thank you
15:07:06 <butterthebuddha> I'm writing an interpreter and I have a "global environment" (represented as a Map) that stores variable bindings. Is it a good idea to use the State monad to pass it around the program? I've never used it before so I'm not sure
15:07:33 <lyxia> sure it is
15:10:30 <nowhereman_> hey guys, I'm baffled by an endless loop in my code: https://lpaste.net/2672206249298231296
15:10:45 <mreh> I wonder if I could compile Haskell to a C library and build it into an android stuido project
15:11:12 <nowhereman_> when I set a breakpoint on line 8, I get that at the second invocation, previous is a thunk
15:11:18 <nowhereman_> and forcing it never terminates
15:11:34 <nowhereman_> also s
15:12:02 <nowhereman_> (the Cell type is a node in a graph whose third argument is of type [Cell]
15:13:51 <Cale> nowhereman_: Could d become negative?
15:15:00 <nowhereman_> Cale: possibly but in my case, I tried with distance=2
15:15:14 <nowhereman_> so the problem appears with d=1
15:15:21 <Cale> Yeah, seems unlikely :)
15:16:33 <nowhereman_> also, there's pattern-matching on the first argument being 0
15:18:24 <mjrosenb> nowhereman_: so...
15:18:28 <mjrosenb> elem uses an equality check
15:18:44 <mjrosenb> if you've built a recursive data structure that has references to itself
15:19:02 <mjrosenb> I don't think (==) will ever be able to return true
15:19:09 <mjrosenb> since it will recurse infinitely.
15:19:20 <Cale> That's certainly correct
15:19:41 <Cale> Cyclic datastructures are indistinguishable from infinite ones
15:23:49 <jollygood2> hi. can someone help me with this code?  I tried various combinations of try and lookAhead but I could not escape infinite loop and out of memory error if parser can't parse anything. https://lpaste.net/5911249320111243264
15:27:11 <jollygood2> added imports to make the code runnable through ghci. https://lpaste.net/111357536933773312
15:28:24 <nowhereman_> mjrosenb: OK, is there a way to test for equality in a recursive data structure?
15:29:00 <nowhereman_> in this case, I can get by with comparing coordinates, I guess
15:30:49 <butterthebuddha> I hate that everyone is so focused on explaining how "thing x" is implemented and how it works, but few people actually show non-trivial examples of how that thing works
15:30:59 <butterthebuddha> which is much more helpful :
16:23:57 <butterthebuddha> What is the purpose of MonadState and MonadError etc?
16:24:22 <dmwit> jollygood2: Can you just consume the `"three"` and tell your next parser about it?
16:24:45 <dmwit> butterthebuddha: To reduce the amount of `lift` needed to write code in a transformer stack.
16:25:27 <Solonarv> also, to let you write functions that don't need to know exactly which concrete transformer stack they'll end up running in
16:27:20 <Solonarv> e.g. I can write statefulThingy :: MonadState Thing m => Foo -> m Bar; barToOtherThing :: MonadError SomeError m => Bar -> m OtherThing
16:27:58 <Solonarv> and then `statefulThingy foo >>= barToOtherThing` Just Works (tm)
16:32:41 <jollygood2> dmwit I think could make that work. so just ditch lookAhead I guess?
16:42:00 <jollygood2> dmwit, still can't get it to work. changed definition to this: skipLinesUntil p = try p <|> (line >> skipLinesUntil p). it infinite loops when p fails to parse all the lines
16:56:01 <jollygood2> I don't understand why it infinite loops. I expeted line parser to fail when eof is reached instead of continuing recursive calls
17:16:33 <jollygood2> I figured out my problem. my line parser never failed, since '\n' was optional
17:20:00 * hackage mbug 1.2 - download bugs mailboxes  http://hackage.haskell.org/package/mbug-1.2 (DmitryBogatov)
17:21:02 <butterthebuddha> I'm trying to compose an Either and State monad using transformers but I'm very confused; can someone demonstrate this with an example? Apparently I can use Either with Except?
17:26:22 <lyxia> ExceptT e (State s) a
17:26:42 <lyxia> @mtl s -> (Either e a, s)
17:26:42 <lambdabot> Maybe you meant: url unmtl pl msg
17:27:01 <lyxia> @unmtl ExceptT e (State s) a
17:27:01 <lambdabot> ExceptT e (State s) a
17:27:05 <lyxia> pf
17:32:14 <Solonarv> :i ExceptT
17:33:30 <Solonarv> alright, I'll do it myself!
17:34:13 <Solonarv> ExceptT e (State s) a ~ State s (Either e a) ~ s -> (s, Either e a)
17:40:39 <butterthebuddha> ExceptT gives me a monad with Either?
17:40:42 <butterthebuddha> I thought it gave me a monad with Except?
17:43:58 <geekosaur> ExceptT is a newtype over Either, adding behavior
17:44:15 <Solonarv> `ExceptT m` is a monad whenever `m` is a monad
17:46:39 <butterthebuddha> Does ExceptT compose nicely with functions that return Either?
17:47:40 <Solonarv> sure
17:47:43 <Solonarv> @hoogle liftEither
17:47:43 <lambdabot> Control.Eff.Exception liftEither :: (Typeable e, Member (Exc e) r) => Either e a -> Eff r a
17:47:43 <lambdabot> Data.Aeson.BetterErrors.Internal liftEither :: (Functor m, Monad m) => Either err a -> ParseT err m a
17:47:43 <lambdabot> Control.Eff.Exception liftEitherM :: (Typeable m, Typeable e, Member (Exc e) r, SetMember Lift (Lift m) r) => m (Either e a) -> Eff r a
17:47:57 <Solonarv> ack, useless lambdabot
17:48:01 <Solonarv> https://www.stackage.org/haddock/lts-11.14/mtl-2.2.2/Control-Monad-Except.html#v:liftEither
17:48:50 <geekosaur> @hoogle liftEither package:mtl
17:48:50 <lambdabot> No results found
17:48:52 <geekosaur> bah
17:48:58 <butterthebuddha> Argh, I'm really confused right now. I think I'm gonna read a little bit more about transformers
17:50:06 <jollygood2> was about to ask if there is a manyN equivalent of many1, but then I figured out I could just use replicateM. :-)
18:06:05 <mjrosenb> ok, now that I have cabal new-build working, does anyone happen to know how to get haskell-mode in emacs to use that for compilation?
18:11:51 <mjrosenb> ahh, think I figured that one out.
18:12:08 <mjrosenb> possibly not the correct way to do it, but it works.
18:18:49 <wazdee> q/quit
18:21:42 <jollygood2> is there a parsec combinator like this? (Just <$> try parser <|> return Nothing). it is similar to optionMaybe, but it does not throw error if parser partially consumed input
18:24:00 <tAy> Howdy, I've got a function signature that I think is correct, but GHC keeps telling me its wrong. I can't figure out why
18:25:10 <tAy> StrictApplyN :: Integer -> (a -> a) -> a -> a
18:25:30 <tAy> StrictApplyN n f x = StrictApplyN (n - 1) f $! (f x)
18:25:58 <tAy> I have the break case too, so its not that
18:26:24 <tAy> Its saying the signature needs to be in the form <variable> :: <type>
18:26:56 <fakenullie> looks like there's wrong syntax somewhere else
18:27:23 <jollygood2> tAy functions should start with lower case letter
18:27:24 <Clint> tAy: why is the S capital
18:27:40 <tAy> Does that make a difference?
18:27:44 <fishythefish> tAy: yes
18:27:45 <tAy> Not sure why now that you mention it
18:28:14 <tAy> Welp that was it, thanks haha
19:00:30 <spear2> how to install haskell platform for a multi-user system?
19:00:42 <spear2> *latest
19:07:06 <mjrosenb> it is so strange, whenever I look at maybe and fromMaybe, I always think of fromMaybe as being more useful, but invariably, I find myself using maybe instead.
19:13:06 <spear2> hmm i guess i can create symlinks to primary user ~/.cabal and ~/.ghc and at least xmonad seems to work for my other users
19:15:16 <fresheyeball> so I am trying to convert this thing into Haskell
19:15:18 <fresheyeball> https://lpaste.net/7611431009204043767
19:15:26 <fresheyeball> Its C#
19:15:28 <fresheyeball> but so far not much is working
19:15:30 <fresheyeball> `Data.ByteString.Base64.decode` succeeds just fine
19:15:32 <fresheyeball> but I can't get it to *inflate*
19:15:34 <fresheyeball> I know its supposed to be a headerless deflate algorithm thing (edited)
19:15:36 <fresheyeball> `Codec.Compression.Zlib.Raw.decompress` which is semantic I think, fails with
19:15:38 <fresheyeball> ```*** Exception: Codec.Compression.Zlib: compressed data stream format error (invalid code lengths set)```
19:15:50 <Cale> mjrosenb: Oddly, I find myself replacing occurrences of maybe with case expressions often enough that I rarely even bother with it.
19:16:14 <Cale> (though it's nice in code that you expect will never change)
19:16:29 <Solonarv> my current project (a game) has 7 occurences of maybe and 8 fromMaybe; only 3.8kloc though
19:16:43 <Solonarv> I'm amused by how even they are
19:18:15 <jollygood2> my function is handling multiple incompatible error types. what should it return? I am tempted to return Either String ActualData, converting both error types to error message
19:18:39 <fresheyeball> jollygood2: I think String is fine for that case
19:19:01 <fresheyeball> if excessive percision is getting in your way, you can always be less percise
19:19:55 <Solonarv> if all you're going to do with an error is print it to stderr and exit, you might as well use String, yeah
19:20:19 <jollygood2> I am, can't do much more than report error and quit at that point
19:34:48 <butterthebuddha> Why was the "fail" function a mistake?
19:35:19 <Cale> butterthebuddha: It doesn't belong in the Monad class
19:35:26 <Cale> Most monads can't implement it well
19:36:20 <geekosaur> ^ in many cases your only option is to throw an exception, which is often an overreaction at best
19:36:52 <Cale> also, before it was introduced, the type of do-blocks would tell you that the monad should support failure, via a MonadZero constraint
19:37:15 <Cale> Really it was part of a whole snowball of somewhat-questionable decisions that happened in Haskell 98
19:37:31 <geekosaur> and, well, mostly it's there to handle pattern match failures in (pat <- expr), which is a fairly bad reason
19:37:57 <fresheyeball> Well, I am about ready to give up on my inflation problem
19:38:10 <fresheyeball> anyone think they got this and want like $150?
19:38:25 <Cale> Monad-generalised list comprehensions were removed, and then because a major reason for the introduction of MonadZero was to support those, MonadZero got merged into MonadPlus, but then people later realised that it was also being used in the translation of the do-notation when pattern matches fail
19:38:58 <fresheyeball> I think it's a half hour of work for anyone how knows this kind of byteString stuff
19:39:02 <Cale> fresheyeball: btw, your lpaste doesn't seem to work
19:39:16 <fresheyeball> https://lpaste.net/7611431009204043776
19:39:29 <fresheyeball> Cale: I try again, does that also not work?
19:39:35 <Cale> that one worked
19:39:41 <fresheyeball> sweet
19:40:11 <fresheyeball> Cale: here an a sample input "c8zR8+K36eMwezksQ6ZBWeTdTZqy8bBkhh+Sf2XQtKXeAL42ob/2Ab+Mpy5m+WXWEKwsuabUJlb2NmYLw9yJ8ZGyyEJWxF9u4TFoGyKN9WEI84hZA3/tlcInk88E+cMQWeiW5g=="
19:43:09 <butterthebuddha> Huh
19:43:23 <butterthebuddha> Haskell 2010 is the current standard right?
19:43:39 <fresheyeball> butterthebuddha: I love your handle
19:44:08 <Cale> butterthebuddha: Yes, though it is only trivially different from Haskell 98 + the FFI addendum to that
19:44:30 <butterthebuddha> fresheyeball: thanks
19:44:38 <Cale> The process of recording what Haskell is hasn't gone so well in recent years. There's an effort to get something out for 2020 :)
19:44:50 <Solonarv> the de-facto standard is haskell2010 + -XKitchenSink :P
19:46:17 <geekosaur> only if your name is Edward :p
19:46:52 <Cale> fresheyeball: Oddly enough, I get a different error
19:46:59 <Cale> > decompress (BSL.fromStrict x)
19:47:00 <Cale> "Al.J\SI<\142\b6\233*** Exception: Codec.Compression.Zlib: compressed data stream format error (invalid distance too far back)
19:47:02 <lambdabot>  error:
19:47:02 <lambdabot>      Variable not in scope: decompress :: BSLC.ByteString -> terror:
19:47:02 <lambdabot>      • Couldn't match expected type ‘BSC.ByteString’
19:47:05 <Cale> oops :)
19:47:09 <fresheyeball> Cale: I get that one too
19:47:27 <Cale> Is there anything documenting what the zlib parameters should be?
19:47:46 <fresheyeball> I have thrown noodles all over my ceiling, nothing has stuck, but hey got many different errors
19:48:22 <fresheyeball> Cale: not that I can find, the only other doc I know of just says "uses deflate algorithm, no headers"
19:49:13 <fresheyeball> oh ok, so the (invalid block type) error was from a different version I was playing with where I Base16.encode before decompressing
19:49:26 <fresheyeball> so thats not right, sorry to send the wrong error
19:49:48 <hastuur> woo
19:49:54 <hastuur> so hows haskell?
19:50:05 <hastuur> hask is fast right?
19:50:11 <fresheyeball> hastuur: Haskell is fast, and lovely
19:50:46 <Solonarv> hey my name isn't edward... https://gitlab.com/Solonarv/perfect-flow/blob/master/package.yaml#L69-89
19:50:47 <Cale> Haskell is a language, so it wouldn't really be right to say that it's fast or slow :)
19:51:05 <Cale> Haskell programs compiled with GHC are often times fast, if they're well-written.
19:51:19 <fresheyeball> Cale: you are the best kind of correct
19:51:44 <Solonarv> GHC is pretty good at taking nice high-level functional code and turning it into a fast binary
19:52:03 <Solonarv> I can't speak for anyone else, but that's one of the things that drew me to Haskell
19:52:18 <Cale> (but it's also easy to write Haskell code which performs poorly if you don't know what you're doing or aren't careful)
19:52:34 <Cale> It's the same with almost anything of course
19:53:01 <Cale> fresheyeball: Any chance you could check that the base64 decode result is the same?
19:53:52 <fresheyeball> Right "s\204\209\243\226\183\233\227\&0{9,C\166AY\228\221M\154\178\241\176d\134\US\146\DELe\208\180\165\222\NUL\190\&6\161\191\246\SOH\191\140\167.f\249e\214\DLE\172,\185\166\212&V\246\&6f\v\195\220\137\241\145\178\200BV\196_n\225\&1h\ESC\"\141\245a\b\243\136Y\ETX\DEL\237\149\194'\147\207\EOT\249\195\DLEY\232\150\230"
19:53:57 <fresheyeball> Cale: that is what I get
19:54:26 <Cale> Sorry, I mean with the C# code
19:54:38 <Cale> Do we know that's what C#'s base64 decoder would also give?
19:54:44 <fresheyeball> Cale: I don't have any C# things to test with
19:54:50 <Cale> ah, hmm
19:55:09 <fresheyeball> I did stare blankly at the offical C# docs for those methods
19:55:15 <fresheyeball> for quite some time
19:56:29 <fresheyeball> https://msdn.microsoft.com/en-us/library/system.io.compression.deflatestream(v=vs.110).aspx
19:59:30 <Cale> okay, I tried some online C# implementation, and it seems to get the same sequence of bytes after the base64 decode, so it's not that
19:59:48 <fresheyeball> Cale: oh nice, I was still trying to get that going
19:59:54 <fresheyeball> What did you use?
20:00:49 <Cale> http://rextester.com/
20:01:37 <Cale> https://lpaste.net/1835439052581502976
20:02:00 <fresheyeball> Cale: nice!
20:04:37 <fresheyeball> Cale: wait, how is that the same output? I ran the C# you wrote, and it looks quite different from what I got in ghci
20:04:59 <Cale> oh, weird, those are the same bytes as I get after doing the base64 decode
20:05:17 <Cale> I just did a BS.unpack to get a list of Word8's to compare
20:05:27 <fresheyeball> Cale: oh!
20:06:20 <fresheyeball> ok yes, they are the same
20:07:37 <Cale> fresheyeball: Oddly, the C# code you gave seems to decompress the thing to a 0 byte string
20:07:51 <fresheyeball> Cale: wtf
20:07:56 <fresheyeball> let me try and find another input
20:08:26 <Cale> It may be silently failing
20:08:27 <Cale> hah
20:09:01 <fresheyeball> Cale: there is also a chance it's a very encoded empty string
20:09:17 <fresheyeball> or more likely a very encoded version of this specific string -> "{}"
20:12:53 <Cale> Well, that's really odd. If I do Console.WriteLine(deflateStream.ReadByte()); it prints -1 (as in, it's at the end of the stream), but then instead of getting a 0 length copy, somehow the streamReader reads 970 bytes...
20:13:19 <fresheyeball> Cale: here is another input
20:13:30 <fresheyeball> oo too big for irc
20:13:33 <fresheyeball> sec
20:14:09 <Cale> oh, weird
20:14:18 <fresheyeball> https://lpaste.net/841875695243100160
20:14:27 <fresheyeball> Cale: ^^ another sample
20:14:28 <Cale> those 970 bytes look an awful lot like the gibberish that I'm getting from GHCi
20:14:36 <Cale> at least the first few of them
20:15:05 <Cale> It starts off with "Al.J", and then is gibberish
20:15:40 <Cale> but it doesn't error out
20:15:59 <fresheyeball> what is the gibberish
20:16:03 <fresheyeball> it might be cryptic success
20:16:45 <Cale> https://lpaste.net/3635222699715854336
20:16:52 <butterthebuddha> https://lpaste.net/433475875065823232
20:17:04 <Cale> uh, that's not quite right (that paste)
20:17:09 <butterthebuddha> Can I make the Either play nice with the ExceptT?
20:17:14 <butterthebuddha> (in eval)
20:17:18 <Cale> seems like lpaste ate a bunch of it
20:17:58 <fresheyeball> butterthebuddha: there is hoistEither
20:18:17 <Cale> butterthebuddha: I'm not sure what you mean, but you're using both head ys and tail ys -- you should probably pattern match :)
20:18:20 <fresheyeball> that or you can do like `x <- ExceptT $ return x`
20:18:41 <Solonarv> you might also be looking for liftEither
20:19:10 <Solonarv> all those functions can be found in Control.Monad.Except in the mtl package
20:19:19 <fresheyeball> essentially you need `Either x y -> ExceptT x m y`
20:19:37 <fresheyeball> > :t ExceptT . return
20:19:40 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
20:19:46 <fresheyeball> > :t (ExceptT . return)
20:19:48 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
20:19:53 <fresheyeball> > @t (ExceptT . return)
20:19:55 <lambdabot>  <hint>:1:1: error: parse error on input ‘@’
20:19:58 <fresheyeball> grr
20:20:00 <Solonarv> :t ExceptT . return
20:20:01 <lambdabot> Monad m => Either e a -> ExceptT e m a
20:20:20 <fresheyeball> Solonarv: :)
20:20:50 <Solonarv> :t liftEither
20:20:51 <lambdabot> error: Variable not in scope: liftEither
20:20:55 <Solonarv> grr
20:20:59 <Solonarv> :t hoistEither
20:21:01 <lambdabot> error: Variable not in scope: hoistEither
20:21:12 <Solonarv> :t Control.Monad.Except.liftEither
20:21:13 <lambdabot> error:
20:21:13 <lambdabot>     Not in scope: ‘Control.Monad.Except.liftEither’
20:21:14 <lambdabot>     Perhaps you meant one of these:
20:22:14 <butterthebuddha> liftEither is not available on my computer either though I'm pretty sure I have mtl installed :/
20:22:15 <fresheyeball> liftEither :: MonadError e m => Either e a -> m a
20:22:32 <Solonarv> https://www.stackage.org/haddock/lts-11.14/mtl-2.2.2/Control-Monad-Except.html#v:liftEither
20:22:34 <Cale> tbh, I think the existing code looks fine with respect to using case
20:22:38 <fresheyeball> hoistEither :: Monad m => Either e a -> EitherT e m a
20:22:47 <Solonarv> yeah, case is fine
20:22:48 <Cale> except that I would use do-notation
20:22:59 <fresheyeball> https://hackage.haskell.org/package/either-4.4.1/docs/src/Control-Monad-Trans-Either.html#hoistEither
20:22:59 <Cale> and I would pattern match the ys differently
20:22:59 <butterthebuddha> I find do notation harder to read :/
20:23:05 <Cale> case ys of
20:23:25 <Cale>   Func (f, _) : ys' -> ...
20:23:28 <fresheyeball> Cale: any luck with the new input?
20:23:48 <Solonarv> I'm a big fan of -XLambdaCase and `getSomething >>= \case ...`
20:25:25 <fresheyeball> Cale: do you have a hint as to what `invalid distance too far back` means?
20:29:07 <Cale> With the new data:
20:29:10 <Cale> > BSL.unpack (decompress (BSL.fromStrict x))
20:29:11 <Cale> [135,61,87,94,248,61,87,94,248,61,87,94,9,152*** Exception: Codec.Compression.Zlib: compressed data stream format error (invalid distance too far back)
20:29:13 <lambdabot>  error:
20:29:13 <lambdabot>      Variable not in scope:
20:29:13 <lambdabot>        decompress :: BSLC.ByteString -> BSLC.ByteStringerror:
20:29:22 <Cale> grr, I should change my prompt :)
20:29:59 <Cale> and the same initial sequence of bytes seem to be the result of the C# decompression
20:30:29 <fresheyeball> Cale: have you matched the C# version?
20:30:33 <fresheyeball> how did you do that?
20:30:35 <Cale> they're immediately followed by 20 zeroes
20:30:59 <Cale> I copy pasted the code over and imported the System.IO and System.IO.Compression modules
20:31:00 <fresheyeball> oh no, you are getting the same invalid distance error
20:31:10 <Cale> I am, in ghci
20:31:16 <fresheyeball> me too
20:31:18 <fresheyeball> ok
20:31:55 <Cale> https://lpaste.net/7059374493004726272 -- try this in rextester
20:32:40 <Cale> It would be helpful if you knew what this was supposed to decode to...
20:32:42 <Cale> :)
20:32:51 <Cale> But this doesn't look like text
20:33:12 <Cale> and the 0's are suspiciously right where the Haskell version stops decoding with an error
20:33:40 <Cale> It might be that C#'s decoder is more lenient to errors in the input
20:35:21 <fresheyeball> Cale: https://bittrex.github.io/#response-handling
20:35:48 <fresheyeball> Thank you for all the help, I am really at a loss
20:40:33 <Cale> Just to be sure, I dug up the same code you did, and tried copy-pasting the lot of it over as a complete method. Calling that method produces the same garbage results.
20:40:49 <Cale> Is it possible that the documentation is simply incorrect?
20:41:00 <fresheyeball> Cale: That is always possible
20:41:06 <Cale> (along with this sample code)
20:41:06 <fresheyeball> sigh...
20:41:16 <Cale> It might be that they changed how they were encoding stuff
20:41:19 <fresheyeball> I mean, its been "out of beta" for 2 months
20:41:33 <fresheyeball> and virtually all messages are encoded this way
20:42:07 <Cale> Is the non-beta source code available?
20:42:18 <Cale> I can only find beta code
20:42:40 <fresheyeball> Its not an open source project
20:43:12 <fresheyeball> I had it working with the beta version, it was not encoded this way
20:43:21 <fresheyeball> but they are going to remove it, so... I dont want that
20:43:53 <Cale> Oh well, it's something which uses a blockchain, so it's almost certainly got to be useless anyway.
20:44:06 <Cale> ;)
20:44:09 <fresheyeball> Cale: haha
20:44:12 <fresheyeball> its not Lampix
20:44:31 <fresheyeball> But then again, only Lampix could be dumb enough to be Lampix
20:44:40 <Cale> I've become very jaded about any and all blockchain-related projects
20:45:07 <fresheyeball> Me too, but I have good reason to bind to this thing, I just can't get a damn thing to work post beta
20:45:09 <johnw> Cale: any particular reason?
20:46:02 <fresheyeball> While jaddes are valid, its a new space, and whenever there is a new space, we should expect a high degree of bad behavior
20:46:20 <Cale> johnw: Just that there don't seem to be any practical applications in which the fact that a blockchain is being used is at all relevant.
20:46:45 <fresheyeball> Cale: not yet anyway
20:46:48 <Cale> It doesn't provide the guarantees that most applications seem to want it to provide
20:47:06 <Cale> and instead it provides guarantees that nobody really cares about
20:48:27 <fresheyeball> Cale: can you send me your final C# repl thing?
20:48:36 <fresheyeball> I am going to try and contact them
20:49:04 <Cale> https://lpaste.net/548941376419528704
20:51:54 <fresheyeball> Cale: thanks for the help. I feel like if you didn't get it (as a senior Haskell person), and the C# example also doesn't work. Thats as far as we can reasonably go.
20:56:42 <Cale> fresheyeball: It seems likely that they changed the compression.
20:56:57 <Cale> We could randomly try other stuff, but that's annoying :)
20:57:51 <fresheyeball> Cale: psssh I did
20:58:25 <dmwit> Cale: The use of branded cryptocurrency to create a "rewards card" where the reward can be transferred from customer to customer is... well, at least, not something that companies have offered before.
20:58:27 <DigitalKiwi> make quickcheck find the solution
20:58:38 <dmwit> Doesn't really seem like a killer app. But it's out there.
20:59:02 <dmwit> Very unclear whether it's something anybody wants, even the corporations that have rolled it out...
20:59:18 <DigitalKiwi> cryptocurrency is cancer
20:59:22 <mniip> every haskell list is a blockchain :p
21:00:14 <DigitalKiwi> https://twitter.com/smdiehl/status/1008688660152225793
21:00:30 <Cale> dmwit: It's unclear to me what advantage the blockchain aspect has there over a straightforward centralised database.
21:01:02 <Cale> All the value of those "rewards card" tokens comes from trust in the company in question anyway
21:04:28 <DigitalKiwi> cryptocurrency isn't even useful as currency because it's too volatile :|
21:13:20 <dmwit> Cale: Right.
21:23:18 <krokodil> Hey all! Can someone recommend me a tutorial into AD library? I can't find anything for AD specifically, only description fo audomatic differentiation in general
21:48:27 <c50a326> what's indentation like this called https://i.imgur.com/xxcV2Mh.png and how do I do it in vim
21:54:00 * hackage o-clock 1.0.0 - Type-safe time library.  http://hackage.haskell.org/package/o-clock-1.0.0 (shersh)
22:25:12 <rotaerk> cocreature, my initial draft of that scope mechanism (which I'll be using instead of resourcet):  https://gist.github.com/Rotaerk/68a88c0456bb4286bdd137a2446200ec
22:26:33 <rotaerk> haven't actually tested yet... but it compiles
22:28:02 <cocreature> rotaerk: stupid question because I’m too lazy to throw GHC at this, shouldn’t “finalizer” inline 21 be of type “m () -> IO ()”? how can you add that to the list of type [m ()]?
22:29:16 <rotaerk> hmm sec; addFinalizer used to have a result of m () instead of IO (); may be a mistake
22:29:19 <rotaerk> thinking through it...
22:29:33 <cocreature> if it compiles I’m definitely missing something :)
22:29:55 <rotaerk> oh, yeah it's fine
22:30:06 <rotaerk> the IO () is just adding the m () to the IORef [m ()]
22:30:35 <cocreature> oh right, I’m stupid
22:30:42 <cocreature> too early :)
22:30:50 <rotaerk> I initially had addFinalizer produce m (), but that ended up being a problem for line 27
22:31:08 <cocreature> rotaerk: looks neat! one thing that is slightly problematic is that if any of the finalizers fails you end up leaking resources
22:31:29 <rotaerk> yeah, I'm not sure how I want to handle that
22:31:35 <rotaerk> definitely needs polish
22:32:06 <cocreature> gotta start somewhere :)
22:32:36 <rotaerk> I could swallow finalizer exceptions, or I could catch and collect them all, then rethrow an aggregate exception when all the resources that *can* be released are released
22:32:56 <cocreature> the latter sounds like the better option
22:33:20 <rotaerk> yeah
22:33:33 <cocreature> and matches the behavior of "bracket" for allocating a single resource
22:33:46 <rotaerk> ah
22:37:09 <rotaerk> one thing ResourceT is better at is
22:37:22 <rotaerk> I'm depending on MonadMask, and continuation-based monads are not valid instances of it
22:37:39 <rotaerk> but ResourceT was invented to help implement Conduits
22:37:53 <rotaerk> which are, as I understand it, continuation-based
23:03:47 <johnw> rotaerk: as, indeed, they are
23:34:30 * hackage winery 0.1.1 - Sustainable serialisation library  http://hackage.haskell.org/package/winery-0.1.1 (FumiakiKinoshita)
23:55:30 * hackage menoh 0.1.1 - Haskell binding for Menoh DNN inference library  http://hackage.haskell.org/package/menoh-0.1.1 (MasahiroSakai)
