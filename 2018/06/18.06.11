00:01:17 <MarcelineVQ> it's this notation  (1 x : elem)
00:01:29 <MarcelineVQ> which is you constraining that type binding to be used exactly once, iirc
00:02:29 <guessWho> how can i extract hash table from this newtype MyHt k v = MyHt (H.CuckooHashTable k v )
00:03:10 <pdxleif> dminuoso: Yeah I guess so - it didn't used to support implicits in nested scopes like that: https://stackoverflow.com/questions/22880309/doing-rank-n-quantification-in-idris
00:03:25 <liste> guessWho: myFunc (MyHt table) = .. do stuff with table ..
00:03:59 <liste> guessWho: or (\(MyHt table) -> ... do stuff with table ...) myHt
00:17:22 <kvothe> what happens if multiple threads are calling sendAll function from http://hackage.haskell.org/package/network-2.7.0.0/docs/Network-Socket-ByteString.html
00:18:11 <kvothe> Does sendAll block till the entire message has been sent?
00:22:16 <pavonia> The Haskell wrapper doesn't seem to add any additional thread safety
00:27:55 <[exa]> kvothe: why would it block?
00:32:53 <guessWho> how do i extract hashtable from this newtype MyHt k v = MyHt (H.CuckooHashTable k v )
00:33:13 <kvothe> <[exa]>: To ensure thread safety
00:34:57 <[exa]> kvothe: like that no one accesses the socket before writing is finished?
00:35:03 <[exa]> hmm good point
00:35:49 <kvothe> <[exa]>: correct
00:36:43 <kvothe> If I have multiple threads calling sendAll simaltaneously, the message is sent in mangled order
00:36:53 <kvothe> https://github.com/lpeterse/haskell-socket/issues/51
00:38:27 <[exa]> OTOH I can't imagine a reasonable piece of code that would share the socket this way
00:39:18 <[exa]> (I know I'm coming from the dangerous C++ world, but a socket is a byte stream, not a magical transactional delimited-data transport)
00:50:36 <cjay-> is there a monadic.party channel? ^^
00:53:05 <Ariakenom> [exa]: It's a magically continuous reliable byte stream?
00:58:18 <shiona_>  cjay- sure. Every /join is a monadic operation
00:59:12 <gentauro> Does the usage of "bind" remove the "streamable" part of a list? Example -> https://gitlab.com/gentauro/gists/snippets/1723434
00:59:25 <bwe> Hi, I want to understand type parameters. Would someone mind to show me how I would consider `data TrafficLight a` in the instance definition?
00:59:31 <bwe> https://bpaste.net/show/59f030455bc9
01:00:50 <pavonia> bwe: What would that parameter denote?
01:01:30 <dminuoso> bwe: You can write an instance declaration: `instance YesNo (TrafficLight a) ...`
01:01:39 <dminuoso> which means it's valid for every choice of some type `a`
01:03:14 <dminuoso> Alternatively you can constrain it further if you need some other information about the type parameter: instance Eq a => YesNo (TrafficLight a)
01:04:42 <gentauro> dim1tri: TrafficLight doesn't have a type param "a" ...
01:04:55 <gentauro> ups
01:05:05 <gentauro> dminuoso: the msg was for you :)
01:09:24 <gentauro> btw, update the link for my example -> https://gitlab.com/gentauro/snippets/snippets/1723434
01:11:11 <zincy_> How would I manually define an instance of Arbitrary for my Game type such that randomly generated games can be made with some constraints for quickcheck tests. Hitting some beginner compiler issues https://lpaste.net/3153234232738840576
01:12:21 <kuribas> how portable is reflex?  I read that it doesn't work on older android devices?
01:12:26 <kuribas> Also, doesn't the arm-only output restrict it even more?
01:15:14 <pavonia> zincy_: You never use maxPlayers, so it doesn't know what instance the corresponding arbitrary use should resolve to
01:16:50 <ZeuPiark> hello
01:17:05 <phz_> hi
01:17:07 <zincy_> ah yes and same for board
01:17:18 <zincy_> which is now changed to the correct variable name however     _deck <- arbitrary gves me
01:17:32 <zincy_> • Ambiguous type variable ‘a0’ arising from a use of ‘arbitrary’       prevents the constraint ‘(Arbitrary a0)’ from being solved.       Probable fix: use a type annotation to specify what ‘a0’ should be.       These potential instances exist:         instance (Arbitrary a, Arbitrary b) => Arbitrary (Either a b)           -- Defined in ‘Test.QuickCheck.Arbitrary’         instance forall k a (b :: k). Arbitrary a
01:18:30 <kuribas> ZeuPiark: bonjour
01:19:10 <pavonia> zincy_: Are you sure this line produces the error?
01:19:40 <zincy_> the line I updated to     _deck <- arbitrary produces that err
01:19:52 <phz_> edwardk: it was nice meeting you at Zurihac, a bit a pity not having taken that coffee because of my flight… I hope we can catch up later :)
01:20:01 <kuribas> is reflex suitable for a commercial app?
01:20:13 <kuribas> is it more than a toy?
01:20:17 <zincy_> oh
01:20:18 <pavonia> zincy_: Could you repaste your current version with full error message?
01:20:23 <zincy_> it works now thanks
01:21:38 <zincy_> one more question tho
01:24:12 <edwardk> phz_: hopefully next time you’ll have more time :)
01:24:17 <phz_> yeah, I hope so
01:24:41 <phz_> I’d be very pleased to have a talk with you about runtime performance in graphics applications in Haskell
01:25:04 <phz_> whe I was still writing luminance in Haskell, the performance were great and the GC not used that much, but still, I decided to migrate it to Rust because of the overhead
01:25:10 <phz_> I still struggle with that kind of concepts :)
01:26:12 <zincy_> edwardk: Do you do paid one to one tutoring sessions?
01:27:11 <edwardk> zincy_: my consulting rate would be a bit prohibitive :) I’m generally happy to answer questions and point to resources though
01:28:12 <zincy_> Go on you can tell me :P
01:28:20 <zincy_> my email is tomw08@gmail.com
01:28:23 <bwe> dminuoso: Then, how would I access in Car's instance definition its records? https://bpaste.net/show/6ef29432e4a9
01:28:31 <edwardk> I am doing one on er.. 150 twitch streaming lately though. I’ve been trying to so so on Sundays but my travel schedule hasnt been conducive the 3-4 weeks
01:28:52 <zincy_> edwardk: oh cool
01:29:28 <edwardk> currently those are mostly focused on writing libraries and giving folks insight into how i work
01:31:01 <ventonegro> phz_: What's luminance?
01:31:08 <zincy_> edwardk: I see there are Q and As they look like fun
01:31:22 <phz_> ventonegro: a type-safe and type-level graphics API over OpenGL
01:31:25 <phz_> I migrated it to Rust
01:31:35 <phz_> so the current Haskell implementation is a bit messy
01:31:48 <phz_> but I’m still struggling with “should I just get back to Haskell?”
01:32:03 <ventonegro> phz_: Ah, interesting! Could you give me a link or is it private?
01:32:06 <phz_> Rust has the advantage of not having a GC, so performance and memory consumption is easy to predict
01:32:26 <phz_> ventonegro: https://github.com/phaazon/luminance
01:32:30 <phz_> ventonegro: https://github.com/phaazon/luminance-rs
01:32:39 <ventonegro> phz_: Thanks!
01:33:21 <phz_> the dilemna problem I’m facing is that Haskell comes in with a little bit of overhead, and there are some things that I really don’t like to express in Rust
01:33:27 <phz_> dammit! :P
01:34:02 <ventonegro> phz_: Did you consider the EDSL route?
01:34:11 <phz_> yep
01:34:13 <phz_> I have a few EDSL around
01:34:23 <phz_> I even have a DSL in Rust
01:34:32 <phz_> called Cheddar, that is a functional programming version of GLSL
01:34:41 <edwardk> zincy_: the q&a session was because so many people asked for one during the first session
01:34:43 <phz_> (though it’s not ready to be released in public :D)
01:34:59 <phz_> edwardk: you seemed overwhelmed at the openspace :D
01:35:07 <phz_> so many people around you
01:35:31 <edwardk> the hallway track is what i come to these events for
01:35:31 <ventonegro> phz_: Sadly OpenGL seems to be on its way out, though
01:35:58 <phz_> ventonegro: are you talking about the macOSX bullshit thing?
01:36:03 <simba_> what's wrong with this simple type declaration ? https://lpaste.net/5708692988780085248
01:36:06 <ventonegro> phz_: yep
01:36:12 <phz_> ventonegro: they’re going to lose money on this
01:36:22 <edwardk> it was a lot of fun fielding questions over such a wide array of topics though
01:36:33 <phz_> simba_: s/newtype/data
01:36:37 <phz_> oh wait no
01:36:38 <phz_> hm
01:37:44 <ventonegro> phz_: So a DSL could generate either Metal or Vulkan and bypass this bullshit
01:37:59 <zincy_> What problem do Arrows solve?
01:38:05 <ventonegro> simba_: What's the error?
01:38:14 <merijn> zincy_: Arguably not that many :p
01:38:22 <edwardk> it is fairly typical post jobs apple. it is the sort of thing that sounds like a “bold” move that just alienates more developers
01:38:27 <zincy_> oh nevermind :)
01:38:28 <merijn> zincy_: Arrows never took off as much as people seem to expect it
01:38:56 <edwardk> zincy_: they mostly exist because people didnt know about applicatives :)
01:38:59 <merijn> phz_, edwardk: otoh, stuff like Rosetta was deprecated nearly a decade before dying
01:39:14 <zincy_> That brings me onto my next question
01:39:21 <zincy_> It has kind of escaped me how to succinctly describe in plain english why applicatives are useful, anyone care to help?
01:39:21 <merijn> So, the fact that they deprecate OpenGL doesn't really mean it's gone anytime soon
01:39:34 <merijn> As for not updating OpenGL, they weren't really doing that anyway
01:39:48 <phz_> well
01:40:02 <phz_> they’ve been doing it for a while
01:40:04 <edwardk> i think it is more laughable to think that what they’d been doing constituted “support” for opengl for the last few years ;)
01:40:06 <phz_> lagging behind for years
01:40:30 <phz_> moving to vulkan is going to make people bleed
01:40:39 <phz_> vulkan + molten vk for macOSX
01:41:03 <edwardk> moving to vulkan finally gives me a crossplatform way to do compute shading
01:41:22 <phz_> yeah, it’s a good thing
01:41:27 <phz_> though it’s not trivial
01:41:39 <simba_> ventonegro :  when i do this let a = Dummy 10 20; i get this https://lpaste.net/781405338854227968
01:41:53 <edwardk> sadly. moltenvk setup is a bit involved
01:42:20 <ventonegro> simba_: let a = Dummy (10, 20)
01:42:41 <phz_> zincy_: applicative functors give you function application inside functors
01:42:48 <fishythefish> zincy_: there are probably a number of ways to approach this, but my initial intuition is that applicatives are useful because fmap isn't sufficient to lift functions with more than one argument
01:42:56 <phz_> so that you can compose them more naturally
01:43:07 <ventonegro> simba_: The thing next to "newtype" is the type constructor, the thing on the right side of the (=) is the data constructor
01:44:01 <fishythefish> simba_: if you ignore the record syntax, you have `newtype Dummy n p = Dummy (n, p)`
01:44:05 <zincy_> good answers
01:44:27 <phz_> lambdabot: newtype Dummy n p = Dummy { getDummy :: (n, p) }
01:44:42 <fishythefish> @let newtype Dummy n p = Dummy { getDummy :: (n, p) }
01:44:44 <lambdabot>  Defined.
01:44:50 <phz_> lambdabot: Dummy (1, "hello")
01:44:53 <phz_> fishythefish: thanks :D
01:44:54 <simba_> fishythefish : i wan't to avoid record syntax but then in this case how do i extract value newtype Dummy n p = Dummy (n, p)
01:44:56 <fishythefish> > let a = Dummy (10, 20) in a
01:44:58 <lambdabot>  error:
01:44:58 <lambdabot>      • No instance for (Show (Dummy Integer Integer))
01:44:58 <lambdabot>          arising from a use of ‘show_M738454854852482755917908’
01:45:07 <fishythefish> @undefine
01:45:07 <lambdabot> Undefined.
01:45:10 <fishythefish> @let newtype Dummy n p = Dummy { getDummy :: (n, p) } deriving (Show)
01:45:11 <lambdabot>  Defined.
01:45:13 <fishythefish> > let a = Dummy (10, 20) in a
01:45:15 <lambdabot>  Dummy {getDummy = (10,20)}
01:45:22 <phz_> do you really need the let binding here?
01:45:30 <phz_> > Dummy (3, 2)
01:45:32 <Ariakenom> kuribas: Have you tried #reflex-frp ?
01:45:33 <lambdabot>  Dummy {getDummy = (3,2)}
01:45:52 <fishythefish> simba_: you can manually define `getDummy (Dummy d) = d`
01:46:18 <fishythefish> phz_: no, but I was trying to preserve the spirit of the original let binding
01:46:35 <phz_> :)
01:47:25 <kuribas> Ariakenom: ok, thanks
01:47:35 <zincy_> :t join
01:47:36 <lambdabot> Monad m => m (m a) -> m a
01:52:23 <zincy_> How does the continuation monad work?
01:55:30 <fishythefish> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
01:55:42 <fishythefish> IMO the best place to start is with `return` - what should its implementation be?
01:56:53 <edwardk> I believe it was forged from the souls of thousands of innocent lisp users. Alas, its secrets are forever lost to antiquity.
01:57:29 <fishythefish> surely you're not an antique just yet, edwardk
01:58:38 <pavonia> zincy_: https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
01:58:54 * edwardk disappears into Zurich in search of pants.
02:00:28 <dminuoso> gentauro: The question was asked how an instance would need to be written if the data type was `data TrafficLight a`
02:02:19 <bwe> dminuoso: Then, how would I access in Car's instance definition its records? https://bpaste.net/show/6ef29432e4a9
02:02:25 <dminuoso> fishythefish: I was kind of stunned to see that Cont was just isomorphic to (Yoneda Identity) :)
02:03:15 <pavonia> bwe: It's not different from the usual record usage
02:05:08 <merijn> bwe: That typeclass looks like it combines two classic bad design choices into one :)
02:05:09 <fishythefish> dminuoso: heh, Yoneda is everywhere
02:05:24 <dminuoso> fishythefish: Yeah. I could even see resemblences of it in LogicT
02:06:08 <merijn> bwe: CarType looks like it's trying to do OO style-classing for which typeclasses are a bad fit, and it's only function right now is a poster child for boolean blindness
02:06:14 <fishythefish> dminuoso: basically, anytime I see a "concrete value" being represented as a function, I expect there to be a yoneda (or at least a right kan extension?) lurking somewhere
02:06:19 <edwardk> dminuoso: its close. there is an extra quantifier
02:06:44 <edwardk> that quantifier matters as with the yoneda bit you cant callCC
02:08:04 <edwardk> fishythefish: every such beast in lens has been an application of yoneda in the functor category, on prof, etc. almost always spotted after the fact, so i think that is a pretty safe bet.
02:08:14 <bwe> merijn: You are right. I lack a good example to understand it. That's the real thing here. By which example would you explain to me the use of type parameters in instance definitions to me?
02:08:59 * hackage nix-diff 1.0.3 - Explain why two Nix derivations differ  http://hackage.haskell.org/package/nix-diff-1.0.3 (GabrielGonzalez)
02:09:54 <merijn> bwe: Usage of typeclasses tends to go as follows: "I don't know typeclasses" -> "Typeclass all the things!" -> "Rarely implement your own typeclass"
02:10:37 <fishythefish> edwardk: yeah, I should probably try to rigorously convince myself of that sometime, but my initial motivation was that CPS, Church encodings, and Yoneda all smelled the same
02:10:50 <fishythefish> Codensity, too, I guess
02:11:01 <merijn> bwe: Typeclasses make the most sense when they contan some completely abstract operations with laws (consider Monoid, Functor, Applicative, Monad, etc.) because then it becomes possible to write general code
02:11:31 <bwe> merijn: What did I try? I tried to abstract the instance definition with type parameter from https://bpaste.net/show/307fbb91671c. Yay! No typeclass.
02:11:34 <merijn> bwe: For basically every other scenario you're better off with either 1) just an algebraic datatype or 2) what I call "OO Haskell"
02:12:49 <merijn> bwe: That code is saying that "Train a" for *any* can return a location of "EncodedLocation 100 200", which is obviously nonsense
02:13:02 <merijn> Because that's an EncodedLocation, not, say, Int
02:13:18 <merijn> bwe: So you have to options to make it sensible
02:13:21 <dminuoso> edwardk: Mmm, what is the relationship between Cont and Yoneda?
02:13:52 <merijn> bwe: 1) "instance FromJSON (Train EncodedLocation) where" (i.e. only allow decoding Trains with an EncodedLocation location)
02:14:33 <merijn> bwe: 2) "instance FromJSON a => FromJSON (Train a) where" (i.e. allow decoding trains whose location is some decodable type)
02:15:09 <fishythefish> dminuoso: you said it yourself - CPS is what you get from applying yoneda to the identity functor
02:15:28 <edwardk> diminuoso: Yoneda f = Ran Identity f; but you seem to be talking about Yoneda Identity. Cont r = Codensity (Const r) = Ran (Const r) (Const r)
02:16:32 <bwe> merijn: Sounds reasonable to me. Here is what my ghci complains for both paths: https://bpaste.net/show/797f290abe26
02:16:56 <edwardk> Yoneda Identity and Cont r are both (a -> r) -> r, but Yoneda sticks a forall r in front as evidenced by it not showing up in the type
02:17:16 <edwardk> this is just enough to rule out callCC
02:18:46 <[exa]> what's the best way to read a line from a socket (e.g. for implementing something similar to SMTP)
02:19:19 <[exa]> (using the System.Socket library)
02:21:19 <merijn> bwe: Ah, for the first just enable "{-# LANGUAGE FlexibleInstances #-}"
02:21:43 <merijn> bwe: The report is overly conservative when it comes to instance definitions
02:22:08 <merijn> bwe: The 2nd is obviously wrong since it's still using EncodedLocation as return, rather then decoding the returned location from the JSON
02:22:15 <merijn> [exa]: You can turn a Socket into a Handle
02:22:27 <merijn> [exa]: Then you can just use hGetLine
02:23:16 <arianvp2> yo, is there a way to let GHC show you the discovered constraints when you have a typed hole inside a GADT pattern match?
02:25:10 <bwe> merijn: 1.) the first compiles: https://bpaste.net/show/be794d00f831
02:26:20 <Ariakenom> :t Network.Socket.socketToHandle
02:26:21 <lambdabot> network-2.6.3.2:Network.Socket.Types.Socket -> GHC.IO.IOMode.IOMode -> IO GHC.IO.Handle.Types.Handle
02:26:24 <bwe> merijn: 2.) I would need to parametrize the location assignment. Instead of EncodedLocation I would use a. But I feel `a 100 200` would be wrong here. What's the right way here?
02:27:34 <butterthebuddha> https://hackage.haskell.org/package/ListZipper
02:27:44 <butterthebuddha> What should I be importing to use the package above after installing it?
02:27:52 <butterthebuddha> import Data.List.Zipper isn't doing the tric
02:27:54 <butterthebuddha> trick*
02:28:58 <[exa]> merijn: oh nice, thanks
02:30:41 <fishythefish> butterthebuddha: how have you installed it and how are you loading that package?
02:31:11 <butterthebuddha> Added "- ListZipper-1.2.0.2" to my extra-deps in package.yaml and then ran stack build
02:34:13 <fishythefish> butterthebuddha: what error do you get?
02:36:05 <butterthebuddha> "Could not find module ‘Data.List.Zipper’"
02:36:22 <butterthebuddha> fishythefish: it does seem like ListZipper was not installed correctly, but i"m not sure what I'm doing wrong
02:36:33 <butterthebuddha> I could probably run stack instal ..., but that would install it globally right?
02:36:45 <fishythefish> butterthebuddha: do you have it *only* under extra-deps? You still need to list it as a dependency
02:38:29 <dminuoso> arianvp2: What constraints do you refer to?
02:39:57 <fishythefish> butterthebuddha: you can `stack build` it
02:46:55 <[exa]> merijn: oh that only seems to work for the second socket library (Network.Socket). Guess I should switch to that one
02:59:59 * hackage tintin 1.9.0 - A softer alternative to Haddock  http://hackage.haskell.org/package/tintin-1.9.0 (NickSeagull)
03:26:48 <mreh> Is it possible to transform a value :: Rand StdGen [Integer] into :: RandT StdGen [] Integer?
03:26:58 <mreh> I'm trying to do some recursive backtracking with random choices
03:27:51 <dminuoso> mreh: Mmm, I wonder whether you can rig RandT with LogicT
03:29:05 <mreh> dminuoso: Maybe
03:32:38 <mreh> dminuoso: do you know how it works conceptually?
03:32:40 <dmwit> mreh: Sure, should be possible with enough mucking with liftRandT/runRandT.
03:33:35 <dmwit> \base -> liftRandT (\g -> runIdentity (runRandT base g)) -- perhaps
03:34:53 <dminuoso> mreh: LogicT is a church encoded ListT of sorts.
03:36:10 <dmwit> Now checked with an actual type-checker instead of my brain: `\m -> liftRandT (\g -> let (vs, g') = runIdentity (runRandT m g) in map (flip (,) g') vs)`
03:36:11 <philippD> dminuoso: I have never used Logic or LogicT but have seen it pop up now and then. How useful is it?
03:36:14 <dmwit> mreh: ^
03:39:41 <mreh> :t \m -> liftRandT (\g -> let (vs, g') = runIdentity (runRandT m g) in map (flip (,) g') vs)
03:39:42 <lambdabot> error:
03:39:43 <lambdabot>     Variable not in scope: liftRandT :: (t0 -> [(a0, b0)]) -> t1
03:39:43 <lambdabot> error:
03:41:11 <mreh> dmwit: it works :)
03:44:43 <dmwit> mreh: Well, it type-checks. Whether it does what you want is another question. =)
03:45:05 <dmwit> mreh: You might want to `split` once for each cons cell in `vs` so that you have different generators for the continuations.
03:45:46 <mreh> dmwit: I was just thinking that, it has the same g' for each
03:46:02 <mreh> dmwit: I wish I had more transformer exerperience
03:46:14 <mreh> pretty impressive
03:47:19 <dmwit> :t split
03:47:20 <lambdabot> Splitter a -> [a] -> [[a]]
03:47:24 <dmwit> oh =P
03:47:30 <dmwit> Anyway it's not hard to code up.
03:48:03 <mreh> dmwit: this is it shuffling numbers [[1,2],[1,3],[1,1],[3,2],[3,3],[3,1],[2,2],[2,3],[2,1]]
03:48:47 <mreh> it picks a number from [1..3] then another from [1..3] and pairs them up
03:48:54 <mreh> you can see the second choices are all the same
03:49:04 <mreh> so yes, I'll split g'
03:52:11 <mreh> any recommendations for a better education on transformers?
03:52:18 <dmwit> I liked "All About Monads".
03:52:23 <dmwit> ?where aam
03:52:23 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
03:52:30 <mreh> dmwit: thanks
03:58:38 <simon> mreh, doesn't shuffling usually imply that the same element can't be picked twice?
04:01:10 <mreh> simon: yeah
04:01:56 <mreh> simon: I'm generating complete sudokus so eventually I'll have to have a StateT transformer in there to remember what I've used already
04:02:05 <mreh> dmwit: zipWith (,) vs . unfoldr (Just . split) $ g'
04:02:08 <mreh> wasn't hard :)
04:04:12 <mreh> there are probably better ways of generating them, like transforming an existing one
04:04:56 <mreh> but I understand the brute force method better
04:05:16 <mreh> s/better//
04:05:32 <tdammers> it's not immediately obvious whether a given set of transformation rules could generate all possible sudoku
04:05:53 <tdammers> a properly randomized brute force algorithm trivially can
04:06:56 <mreh> tdammers: yes, doesn't need to be randomized either, but I wan't to generate seemingly unique sudoku quickly :)
04:07:56 <simon> mreh, have you looked at sudoku generator algorithms?
04:08:37 <mreh> simon: just browser the wikipedia page, there's not much there for generating complete sudoku
04:09:18 <mreh> well, you could see the problem as a sudoku with zero clues
04:10:20 <mreh> dancing links is recommended
04:13:17 <simon> mreh, that rings a bell.
04:16:29 * hackage HNumeric 0.3.1.0 - Haskell Numeric Library with pure functionality, R & MATLAB Syntax.  http://hackage.haskell.org/package/HNumeric-0.3.1.0 (edeftg)
04:19:39 <tdammers> mreh: but depending on the solver algorithm, this would always produce the same "solution"
04:20:14 <tdammers> then again, if the solver uses nondeterminism, you'll just get the set of all possible sudoku as the solution
04:23:21 <simon> mreh, https://hackage.haskell.org/package/exact-cover-0.1.0.0/docs/Math-ExactCover.html
04:25:50 <lostman> hi folks. anyone here with experience with bindings-dsl? I'm trying to figure out how to use the standalone_deriving feature
04:26:54 <simon> mreh, it looks like https://hackage.haskell.org/package/set-cover is downloaded more, but not by a huge margin.
04:30:30 <simon> mreh, strategies for generating sudoku puzzles from scratch seem to involve, at some point, the addition or removal of a cell value and subsequent check if there's still any/exactly one solution, in which case you'd need a fast solver, which you wouldn't have to write from scratch.
04:32:40 <siraben> simon: So backtracking?
04:33:01 <siraben> If you want to get fancy, encode the sudoku as a boolean satisfiability problem and write a SAT solver
04:36:47 <merijn> simon: You could also check the constraints on each cell and ensure that every time you remove a cell at least 1 cell with only 1 possible option remains
04:37:03 <merijn> simon: That might not be able to generate ALL possible sudoku's, but will at least only generate valid ones
04:41:21 <simon> siraben, the library I most recently linked to advertises that you can encode various set-cover problems and use their solver.
04:43:53 <simon> merijn, yeah, that seems pretty neat. I suppose that if you start by creating a fully-fitted sudoku board and then remove cell values, you can shift the responsibility of reaching more puzzles on the way the board is initially filled. I don't know.
04:53:49 <nruebwbae> Hi! I'm trying to implement a compiler for the System F language. First of all, I've searched like mad, if there are any tutorials on System F which you know, please let me know! But for my true question: In the Simon Peyton Jones talk Into the Core (https://youtu.be/uR_VzYxvbxg) he shows the Core type declaration for Expression in the Core language. I'm wondering, where in the Git repo one can find this? In which file
04:53:49 <nruebwbae> this defnition available? Thanks for reading my question!
04:54:36 <nruebwbae> This slide is the one I'm thinking about https://youtu.be/uR_VzYxvbxg
04:54:46 <nruebwbae> sorry: https://youtu.be/uR_VzYxvbxg?t=17m49s
04:55:30 <lyxia> nruebwbae: https://github.com/ghc/ghc/blob/master/compiler/coreSyn/CoreSyn.hs#L270
04:55:55 <nruebwbae> lyxia: beautiful. Thank you very much
04:55:56 <lyxia> you might also find this interesting https://github.com/ghc/ghc/blob/master/docs/core-spec/core-spec.pdf
04:57:39 <butterthebuddha> Is 0 a function from Int -> Int?
04:58:11 <butterthebuddha> Because ghc is inferring [0]'s type to be [Int -> Int]
04:58:15 <philippD> :t 0
04:58:16 <lambdabot> Num p => p
04:59:10 <butterthebuddha> Nvm, there was another type error
04:59:16 <dmwit> butterthebuddha: It can be, if you work hard.
05:00:07 <philippD> butterthebuddha, dmwit: only if you provide a Num instance for `Int -> Int` ... Don't do that
05:01:17 <dmwit> ?let instance Num b => Num (a -> b) where (+) = liftA2 (+); (-) = liftA2 (-); (*) = liftA2 (*); negate = fmap negate; abs = fmap abs; signum = fmap signum; fromInteger = pure . fromInteger -- TRY TO STOP ME
05:01:19 <lambdabot>  Defined.
05:01:28 <dmwit> > (0 :: Int -> Int) 3
05:01:31 <lambdabot>  0
05:01:56 <merijn> dmwit: In case no one answered you friday after I left: The flag filtering stuff is about making new-build less paranoid about whether it should rebuild the entire freaking world just because you decided to add "--ghc-option=-j2" :)
05:02:08 <dmwit> merijn: Thanks, that sounds nice!
05:02:28 <merijn> dmwit: That stuff's already in HEAD atm, now I'm just fixing the local/in-place packages
05:02:29 <dmwit> I look forward to it landing -- and I hope that the current niggling details about how it's done get resolved to everybody's satisfaction. =)
05:03:01 <merijn> dmwit: For non-local dependencies it's already landed :)
05:03:21 <Ariakenom> > (const 1 + (+1)) 2
05:03:23 <lambdabot>  4
05:03:28 <dmwit> Yeesh, you cabal developers think `master` is the only version of cabal to exist. =D
05:03:35 <Ariakenom> great
05:03:36 <merijn> dmwit: Yes!
05:03:45 <dmwit> > (sin + cos) 2
05:03:47 <lambdabot>  0.4931505902785393
05:03:57 <dmwit> > (sin^2 + cos^2) 2
05:04:00 <lambdabot>  1.0
05:04:23 <tdammers> oy vey
05:04:24 <hpc> > (sin^2 + cos^2) <$> [0..]
05:04:26 <lambdabot>  [1.0,1.0,1.0,0.9999999999999999,1.0,0.9999999999999999,0.9999999999999999,0....
05:04:48 <dmwit> tdammers: I've got my Tylenol handy, come visit my desk.
05:05:56 <tdammers> dmwit: it's fine, I've slept maybe 10 hours since thursday, at this point I'm not even 100% sure anymore whether I'm on IRC or typing into a pink unicorn that jumped out of my left ear
05:06:50 <merijn> ugh...
05:07:20 <hpc> that's perfectly normal, it's probably in lens
05:08:45 <dmwit> tdammers: Yikes. I hope whatever's keeping you up gets resolved soon one way or another and you can return to taking care of yourself.
05:09:39 <cocreature> zurihac has sadly been resolved :(
05:10:14 <Ariakenom> :k Word8
05:10:15 <lambdabot> *
05:10:22 <dmwit> cocreature: Did you do any fun hacks during?
05:10:28 <Ariakenom> > let eqfn f g = all (\x-> f x ==g x) [minBound..maxBound] in eqfn (sin^2 + cos^2) (1::Word8->Word8)
05:10:30 <lambdabot>  error:
05:10:30 <lambdabot>      • No instance for (Floating Word8) arising from a use of ‘sin’
05:10:30 <lambdabot>      • In the first argument of ‘(^)’, namely ‘sin’
05:10:37 <cocreature> dmwit: yeah did some work on llvm-hs
05:10:38 * dmwit . o O ( Word :: Nat -> * )
05:10:52 <dmwit> cocreature: Cool, what new feature does it have?
05:11:10 <hpc> > minBound :: FLoat
05:11:12 <lambdabot>  error:
05:11:12 <lambdabot>      Not in scope: type constructor or class ‘FLoat’
05:11:13 <lambdabot>      Perhaps you meant ‘Float’ (imported from Prelude)
05:11:13 <cocreature> it’s now harder to accidentally execute null pointers \o/ :)
05:11:13 <hpc> > minBound :: Float
05:11:15 <lambdabot>  error:
05:11:15 <lambdabot>      • No instance for (Bounded Float) arising from a use of ‘minBound’
05:11:15 <lambdabot>      • In the expression: minBound :: Float
05:11:17 <merijn> Whoo! I broke everything while rebasing >.>
05:11:24 * merijn kicks git
05:11:32 <Boomerang> ZuriHac was awesome! Thanks everyone who was there for making it so great :D
05:11:37 <hpc> Ariakenom: i don't think there's a data type that makes that work
05:11:41 <dmwit> cocreature: Whoa, rad!
05:12:36 <dmwit> > let eqfn f g = all (\x -> f x == g x) [minBound..maxBound]; fi = fromIntegral in eqfn ((sin.fi)^2 + (cos.fi)^2) (1 :: Word8 -> Double)
05:12:38 <lambdabot>  False
05:13:02 <dmwit> > let fi=fromIntegral in ((sin.fi)^2 + (cos.fi)^2) (3 :: Word8)
05:13:03 <lambdabot>  0.9999999999999999
05:13:11 <hpc> dmwit: try giving eqfn some epsilon bounds
05:13:21 <dmwit> no =(
05:13:29 <hpc> haha, fair enough
05:14:03 <Ariakenom> hpc: no because sin is in Floating. Ratio Word8 should work
05:14:05 <dmwit> % :!cabal install universe
05:14:06 <yahb> dmwit: /bin/sh: 1: cabal: not found
05:14:09 <dmwit> aww =D
05:14:24 <dmwit> I guess I'd have to restart ghci for it to pick up the new package anyway, and at that point it would be wiped out.
05:14:36 <cocreature> Boomerang: see you again at munihac hopefully! :)
05:14:48 <dmwit> Ariakenom: I don't think there's a Floating instance for Ratios.
05:14:52 <Boomerang> cocreature: Yeah I'll try to come! :D
05:14:58 <dmwit> I *hope* there's no Floating instance for Ratios.
05:15:07 <Ariakenom> There isn't
05:15:11 <tdammers> you can make one like the one for String in Acme.PHP
05:16:06 <Ariakenom> dmwit: But sin doesn't have to be for Floating. Too narrow really
05:18:49 <phz_> is there anyone willing to explain me as quickly as possible what hom-sets are?
05:19:09 <phz_> I think I get what an adjoint functor is, though I don’t get what a Hom functor is
05:19:25 <phz_> (seems like a mapping between a category and a set, though I don’t get why it’s bicovariant)
05:20:38 <lieven> a hom-set for objects a and b is the set of morphism between a and b
05:20:42 <phz_> I guess edwardk must have some kind of doc simple somewhere
05:20:45 <phz_> well, “simple” :P
05:21:00 <phz_> lieven: why two then?
05:21:08 <phz_> why do you write it hom(–, –)  ?
05:21:25 <lieven> hom(a,b)
05:21:42 <lieven> hom(from, to) if you want
05:21:50 <lieven> so a different set for every pair of objects
05:22:15 <phz_> oh
05:22:35 <phz_> so Hom(A, B) is the set of morphisms that go from A to B?
05:22:40 <lieven> yeah
05:22:51 <phz_> it’s pretty simple then
05:22:53 <phz_> thanks!
05:33:18 <drets> Hi, I use : -fwarn-incomplete-patterns -fwarn-incomplete-uni-patterns but it doesn't war when I do       [Only xmlPath] <- query conn qstr (Only jobid) inside IO monad. What will happen if query returns empty array?
05:33:33 <drets> warn*
05:34:49 <dmwit> It will call `fail` with a suitable `String`. For `IO`, this throws an exception.
05:34:53 <dmwit> (catchable)
05:35:03 <dmwit> I'm a bit surprised it doesn't warn, though.
05:36:35 <dmwit> Further discussion here: https://ghc.haskell.org/trac/ghc/ticket/5813
05:39:25 <drets> dmwit, thank you.
05:39:57 <Cale> Yeah, due to the desugaring, it's debatable whether that actually counts as an incomplete pattern match.
05:40:13 <Cale> -fwarn-incomplete-uni-patterns affects lambdas and pattern bindings
05:42:22 <Boomerang> If it was in the list monad as opposed to IO, a `[x] <- ...` pattern would be a valid way to fail. So the incomplete pattern warning needs to know what monad it's in. Might be doable :)
05:42:24 <dmwit> I think all are agreed it would be sensible to have a flag for this. Debatable whether it should be implied by -Wall, but I would be very surprised to see a patch to add the flag get rejected.
05:43:02 <dmwit> Just... nobody's written the patch.
05:43:06 <Boomerang> Oh wait nevermind what I said
05:43:30 <Boomerang> If the checks are done after desugaring it should be good enough :)
05:43:33 <cocreature> I don’t see it getting rejected outright, but I could certainly see it dying in a see of bikeshedding
05:44:23 <dminuoso> Is there a particular reason Predicate exists? Is it any more useful than (Op Bool)?
05:45:33 <cocreature> it takes less time figuring out what a type called Predicate is supposed to do than Op Bool :)
05:45:43 <dminuoso> Oh well. I guess there's that =)
05:48:04 <merijn> cocreature: I think I might actually be done with cabal \o/
05:48:51 <drets> What the proper way to refactor [Only xmlPath] <- query conn qstr (Only jobid) so I can through the error in case of []?
05:49:30 <merijn> drets: "paths <- query ...; case paths of {- handle cases here -}"
05:49:41 <drets> Danke.
05:49:58 <merijn> Might be better ways depending on the details, but that'd work
05:50:09 <Boomerang> Or "query connqstr (Only jobid) >>= \case [x] -> ...; _ -> error ..."
05:50:24 <merijn> Boomerang: LambdaCase requires an extension, though
05:50:31 <Boomerang> It does
05:50:39 <merijn> Also, using "error" is no better than the partial match already there
05:50:53 <merijn> Worse, actually
05:51:12 <merijn> Because adding an explicit error adds all the verbosity of doing it properly, but without improving anything
05:52:00 <drets> kk, so the proper way is wrap everything in error monad and do throwError MyTypedError?
05:52:17 <drets> and have a handler at the top of the program.
05:54:04 <merijn> drets: throwIO + Control.Exception also works
05:54:09 <AWizzArd> Do existential types in a data declaration only make sense in combination with a class constraint? So that a user can at least do _something_ with a value of type `a`?
05:54:26 <merijn> drets: The problem with error is that it raises an exception *lazily*, so the exception throw can escape any handlers you install
05:54:44 <merijn> drets: If you use throwIO the exception is guaranteed to not escape surrounding handlers from Control.Exception
05:54:58 <drets> Interesting, thanks.
05:55:11 <merijn> drets: Alternatively depending on the exact "error" you might of course not throw an error at all and just provide a "default" instead
05:55:48 <merijn> AWizzArd: Mostly, yes. An existential without constraints is fairly useless, with one exception
05:56:02 <merijn> AWizzArd: You could have a function using the existential type inside your datatype
05:56:04 <Ariakenom> crashing can be correct though.
05:56:24 <merijn> AWizzArd: "data Foo = forall a . Foo a (a -> a -> Bool)" might make sense
05:56:59 <merijn> Actually that one is still kinda useless
05:57:16 <merijn> "data Foo r = forall a . Foo a (a -> r -> Bool)" would be slightly less so
05:57:30 <merijn> But then, you might as well use "data Foo r = Foo (r -> Bool)"
05:58:14 <AWizzArd> merijn: yes, we could give that function access to the `a` value via a closure.
06:00:44 <zincy_> What are existential types?
06:01:22 <dminuoso> zincy_: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#existentially-quantified-data-constructors
06:03:22 <maerwald> I'm confused of the fact that the documentation is understandable and not esoteric :>
06:04:02 <cocreature> AWizzArd: there is one other option where existentials are fine (and in fact that’s pretty much the only case where I actually recommend using them) and that’s GADTs
06:04:07 <merijn> Time for my montly poll of: Who's using new-build and willing to help test shit? ;)
06:04:09 <cocreature> since you can recover the type parameter in that case
06:04:14 <veverak> can I reasonably execute "cabal build" outside of the folder of the project?
06:04:24 <dminuoso> merijn: I was unwillingly forced to the other day.
06:04:25 <veverak> like I have folder with a project (.cabal in the root of the folder)
06:04:37 <merijn> cocreature: You can't recover the type parameter from existential with GADTs...
06:04:38 <veverak> and I would like to create a cabal sandbox, and build project there, outside of the source folder
06:05:11 <merijn> cocreature: If the type parameter is in the GADT type it's not an existential. And if it isn't in the GADT type you can't recover it (at least not in ways that don't work for regular ADTs)
06:05:25 <merijn> dminuoso: How so? :)
06:05:26 <cocreature> merijn: I’m talking about the SomeX existentials that wrap GADTs
06:05:52 <dminuoso> merijn: Well there was this non-stack project I wanted to fix.. but they didn't use stack, and I didn't like the idea of *not* having a sandbox..
06:06:26 <merijn> veverak: Not really, but you can specify a different build dir to "cabal build"
06:06:52 <merijn> dminuoso: I don't understand the concept of "unwillingly" using new-build ;)
06:07:47 <dminuoso> merijn: How's the tooling with new-build? How do you spacemacs?
06:07:58 <veverak> merijn: hmmm, I am using "cabal install" now, however that seems hackish
06:08:30 <merijn> veverak: cabal install is...probably not the way to go :)
06:08:34 <veverak> merijn: (I create new sandbox, add-source my original project, and install it)
06:08:56 <veverak> thing is
06:08:59 <veverak> for some reason
06:09:02 <merijn> dminuoso: Tooling, sadly is not great yet. My recent cabal patches mostly exist because I'm working on making tooling less shit :p
06:09:07 <veverak> the install command is much more customizable and has much more options
06:09:10 <veverak> than the build one
06:09:12 <veverak> :)
06:09:31 <merijn> dminuoso: I have a prototype ghcid based checker for doing error/warning highlighting in vim. Which I'll work on a bit again in the near future
06:09:44 <merijn> dminuoso: That should be easy enough to adapt to emacs
06:10:00 <veverak> it's a cmake script more or less
06:10:11 <merijn> dminuoso: But new-build itself is so nice that I'm using it despite the tooling still sucking :p
06:10:16 <veverak> truth to be told, I am thinking about simply copying the source project, and executing build on the copy
06:10:30 <cocreature> haskell tooling sucks regardless of whether you use new-buildu or not
06:10:47 <merijn> cocreature: It worked great before new-build for me, because I only want simple things
06:11:01 <merijn> cocreature: i.e. highlighting errors/warnings, querying types of an expression
06:11:09 <dminuoso> Those are the two only things I care about =)
06:11:17 <merijn> cocreature: And with a bit of luck I should have all that working in a few weeks
06:11:38 <cocreature> I’m sure I’ll manage to break it :)
06:11:56 <merijn> Actually I already have the error/warning highlighting working. I'm just making it faster/nicer. Type querying and jump to definition should work too without too much work
06:12:08 <merijn> veverak: Which version of cabal-install do you have?
06:12:27 <veverak> I have 2.2
06:12:29 <veverak> (archlinux)
06:13:09 <veverak> to the point: I have bigass project (ROS - ros.org) that has custom package system and build system (cmake overlay), ROS tries to be "multiple language friendly"
06:13:12 <merijn> veverak: You might wanna try new-build instead of sandboxes :)
06:13:14 <veverak> I am trying to get haskell into that
06:13:19 <cocreature> merijn: are you using new-repl for that or do you actually have something that’s useful with multi-package projects?
06:13:20 <veverak> merijn: hmm, how stable it is?
06:13:43 <drets> After enabling incomplete-patterns and unit-patterns I used "error" everywhere as a quick fix. Next, I'd like to refactor the whole app to run inside ExceptT. Sounds reasonable? Or I made the situation really worse by using “
06:13:50 <merijn> cocreature: new-repl, but with logic that makes it actually work with multiple packages/components
06:14:00 <drets> “error”.
06:14:02 <cocreature> merijn: oh nice!
06:14:10 <merijn> cocreature: I use cabal-plan to discover the local packages/components and store mappings between components and files
06:14:16 <cocreature> I’ve basically stopped using new-repl because it’s mostly just useless without that
06:14:33 <merijn> cocreature: So if you have *a* component that contains said file it should manage to repl it
06:14:50 <butterthebuddha> Is it possible to specify a file input directory with stack?
06:15:06 <merijn> cocreature: Of course if you're daft and have multiple components using the same file you don't get a deterministic result for loaded component, but that's someone else's problem
06:15:22 <veverak> merijn: actual goal is to: copy source of each package, create cabal sandbox, add 'project specific' dependencies as add-source, cabal build, next();
06:15:56 <merijn> cocreature: I already have it working for "single invocation" so what I'm working on now is a daemon setup that keeps file-component mappings in memory so it spends less time reloading components
06:16:16 <zincy_> dminuoso: thanks :)
06:16:16 <merijn> veverak: new-build is plenty stable, although some new-X commands aren't completely finished/polished
06:16:19 <cocreature> merijn: I don’t care about that part. what I need is the ability to reload each file in a multi-package project. instead of being limited to a single component
06:16:39 <merijn> cocreature: For what?
06:16:51 <merijn> veverak: Yeah, new-build will probably drastically simplify your life
06:16:56 <cocreature> because restarting the repl is really fucking annoying?
06:17:11 <merijn> cocreature: Right, but in my case my code takes care of that
06:17:34 <veverak> merijn: will look into that than
06:17:34 <merijn> cocreature: So in vim if you hit ":w" on a file it will just reload the component for that file and check for any errors/warnings and highlight
06:17:37 <cocreature> does it take care of restarting the repl or do a fast reload?
06:17:51 <merijn> cocreature: reload if the repl already has the right component, restart if not
06:18:10 <cocreature> that sounds slow if you’re switching between components often
06:18:21 <merijn> veverak: Basically, you can define a cabal.project file with directories to local packages to use
06:18:36 <merijn> cocreature: Maybe, depends how slow the components are to compile
06:18:36 <veverak> merijn: https://www.haskell.org/cabal/users-guide/nix-local-build-overview.html is proper doc?
06:18:42 <merijn> veverak: yeah
06:18:54 <veverak> merijn: cool, will look into that, thanks
06:18:56 <veverak> :)
06:18:57 <cocreature> I just use raw ghci and a .ghci file so I can get proper reloads across components
06:19:07 <Math22232> How do I fix this? : foreign export ccall keyGenerator :: String -> Int
06:19:07 <Math22232> keyGenerator :: String -> Int https://puu.sh/ADaJb/80978402db.png
06:19:19 <merijn> veverak: See here for an example: https://github.com/merijn/broadcast-chan/blob/master/cabal.project
06:20:34 <cocreature> Math22232: use CString in the ffi declaration and then use something like withCString to marshall the String
06:20:40 <Math22232> how do I fix this error? : https://pastebin.com/bZFGvfP0
06:20:55 <Math22232> k
06:21:03 <merijn> cocreature: I could actually cache the loading by loading object-code, but that means you'd lose any warnings from the last time you build the code...
06:21:43 <merijn> veverak: Basically, you replace all the sandbox init/add-source/etc. commands with a static project file and then just use "new-build" and it "Just Works (TM)"
06:21:59 <merijn> veverak: So then you'd only have to copy/checkout the individual dependencies and run a single command
06:23:17 <veverak> and generate the file :)
06:23:23 <veverak> but that's detaily, will look into that, thanks
06:23:36 <merijn> veverak: Well, generally you'd keep a static copy of the file somewhere
06:23:46 <Math22232> cocreature, I don't get it how I can convert a CString -> String
06:24:02 <merijn> veverak: i.e. if this inside some repo you'd generally commit the cabal.project as part of your repo/build system
06:24:15 <veverak> hmm, I see
06:24:26 <cocreature> Math22232: why do you want to convert from a CString to a String? you’re code is using the string as an argument not as a return value so you need to convert from a String to a CString
06:24:29 <veverak> merijn: I have to think about that
06:24:31 <merijn> cocreature: If you have an example of your .ghci script and a bit of explanation how it works I can see what I can do with that
06:25:26 <merijn> I'd love to make it as fast as possible, but this was the most robust way I've found
06:25:43 <cocreature> merijn: there is not much to it, it’s just a few ":set -iXXX", sets default extensions and flags according to what I have in my cabal file and then ":l Main.hs"
06:25:57 <cocreature> it sucks that I have to duplicate this info but it’s worth it for me
06:26:37 <merijn> cocreature: ah, right, but duplicating that stuff is exactly what I didn't/don't want to do
06:27:01 <merijn> As I don't think that's remotely automatable
06:27:21 <cocreature> new-repl should really just stop insisting that loading multiple components is always impossible because it can cause problems in a few cases
06:27:43 <Math22232> cocreature, Sorry, but I stills don't get it, I get an CString as an Input Value so I wanna pass the CString into the keyGenerator function which takes a String as an Input but CString != String so I can't call the keyGenerator function, that's why I wanna convert the CString -> String so I can pass it to the function
06:27:56 <merijn> cocreature: That would be nice, yes, but I'm not going to fight that battle
06:28:18 <cocreature> but I looked at how one could implement this (and hide it behind some --i-know-what-im-doing" flag to avoid the fight) but the current state is baked very deeply into cabal
06:28:26 <cocreature> Math22232: where do you get the CString from?
06:28:38 <zincy_> How does one get the ordinal position of a data constructor as a number?
06:29:05 <dysfun> an Enum instance?
06:29:09 <Math22232> cocreature, I wanna call that function from a C++ project
06:29:34 <merijn> zincy_: That...doesn't necessarily make sense?
06:30:01 <cocreature> Math22232: it might be helpful if you show us more context. your code has a single function called keyGenerator. I’m proposing changing the FFI declaration of that to CString -> Int, and then have a wrapper of type String -> Int that uses withCString
06:30:32 <zincy_> data Foo = One | Two | Three
06:30:59 <cocreature> > constrRep (toConstr Nothing)
06:31:00 <merijn> cocreature: Alternatively I could launch one repl per component, but that might eat through your RAM *quick* :)
06:31:01 <lambdabot>  error:
06:31:01 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘toConstr’
06:31:02 <lambdabot>        prevents the constraint ‘(Data a0)’ from being solved.
06:31:05 <zincy_> I want a function such that when I pass the One it will return the integer 1
06:31:19 <merijn> zincy_: So, why not just write that?
06:31:36 <cocreature> merijn: that also doesn’t help with reloading if component B depends on component A and you change A
06:32:05 <merijn> cocreature: Why not?
06:32:25 <merijn> cocreature: Ah, you mean because reloading won't be affected by the A changes?
06:32:29 <cocreature> exactly
06:32:37 <cocreature> that’s the main reason why I’m doing this .ghci crap :)
06:32:41 <merijn> cocreature: Luckily, I have logic to detect whether a dependency that's changed :)
06:32:45 <zincy_> merijn: hehe
06:32:53 <merijn> cocreature: And I restart the repl in that scenario
06:32:55 <cocreature> merijn: right but then you’re back to having to restart
06:33:00 <merijn> True
06:33:07 <Math22232> cocreature, yeah how do I create a wrapper?
06:33:34 <merijn> cocreature: But I'll take "robust, working, but slow" tooling over "no tooling" any day :)
06:33:34 <cocreature> merijn: if new-repl takes a minute to start, you’ll get a lot more conscious about these things :)
06:34:10 <merijn> cocreature: That could be fixed with -fobject-code if you're willing to miss some warnings
06:35:07 <merijn> cocreature: I've played with that and -fobject-code is super fast when restarting the REPL. It's just that you only get warnings once, so starting the REPL after manually running "new-build" might cause you to miss/lose some warnings
06:35:39 <merijn> I could definitely add an option for using -fobject-code, though
06:35:55 <cocreature> Math22232: \s -> withCString s keyGenerator should be of type String -> IO Int. you can then use unsafePerformIO (FFI calls are pretty much the only place where unsafePerformIO is fine) to get to String -> Int
06:36:24 <cocreature> merijn: good point, I’m already using that for some other projects but I seem to recall that for that one project I ran into problems but I forgot what they were
06:36:27 <cocreature> I’ll have to try it again
06:37:43 <merijn> cocreature: Anyway, I need to get back to writing, but I'll ping you once I get a bit further and you can play around a bit
06:37:56 <cocreature> merijn: sounds good, have fun writing :)
06:38:04 <merijn> cocreature: Writing is never fun >.>
06:38:17 <cocreature> merijn: tell me about it, I should be working on my master’s thesis
06:38:42 <cocreature> but I just got back from zurihac so my brain is kind of fried and my motivation is even lower than usual :)
06:51:01 <whenamI> any ceo or cto here ?
06:51:12 <shapr> whenamI: why so?
06:51:18 <shapr> whenamI: do you want to learn Haskell?
06:51:39 <whenamI> shapr:  I wonder if any programmer can be a ceo or cto
06:51:50 <juri_> CEO here. hacking haskell for great justice.
06:52:04 <whenamI> juri_:  which company ?
06:52:10 <juri_> give up your preconceptions. ;)
06:52:26 <juri_> my own. only up to three people. ;)
06:52:55 <shapr> juri_: I'm still sad I didn't get to meet you
06:53:13 <juri_> shapr: miss me at the CCC? :)
06:53:19 <whenamI> juri_:  I work for very big company and I see daily lot of emails on promotions to VPs and all I feel so bad When and how can I become cto/ceo atleast some VP
06:53:20 <merijn> I'm sad everyone comes to Zurich, but skips NL-FP :p
06:53:26 <shapr> juri_: when I visited HacDC recently
06:53:37 <juri_> shapr: ah! how'd i miss you?
06:54:27 <juri_> whenamI: to lead, get some practice leading. go join your local hackerspace. :)
06:54:28 <shapr> juri_: I visited the day before the basement cleaning
06:54:43 <shapr> whenamI: why do you want to be a cto/ceo ?
06:54:45 <juri_> oh! goodness. that was a lot of work.
06:55:11 <ventonegro> merijn: Have you seen the photos of the lake? :)
06:55:12 <whenamI> juri_:  but politics around I am still at carrer begining position..I applied many big position and no one selects me :(
06:55:32 <philippD> juri_ where you at the CCC haskell table last year?
06:55:40 <juri_> whenamI: seriously, go volunteer to teach some classes.
06:55:57 <juri_> philippD: i started haskell table two.
06:56:00 <whenamI> juri_:  how does it help ?
06:56:35 <juri_> whenamI: learning to build others builds yourself. leadership skills come from that. :)
06:56:47 <shapr> whenamI: cto/ceo needs people organization skills, teaching and organizing helps much.
06:57:10 <whenamI> I am a teacher yes but who gives me opportunity
06:57:14 <whenamI> how can I get into it
06:57:19 <shapr> start teaching!
06:57:22 <whenamI> I am very young just 26
06:57:24 <shapr> I teach lunchtime classes at my workplace
06:57:30 <shapr> you don't have to be old to teach!
06:57:32 <juri_> use that platform to run for office in the hackerspace.
06:57:40 <whenamI> shapr:  I do teach
06:57:47 <juri_> i took over a space at 30. :)
06:57:58 <shapr> figure out how to get more people and teach more things
06:58:01 <whenamI> I say I want to to become V atleast but they ask 14/15 years experience
06:58:13 <whenamI> I feel  frustrated what to do
06:58:28 <whenamI> shapr:  you teach for free?
06:58:31 <shapr> I do, yes
06:58:40 <shapr> I also have a day job
06:58:46 <juri_> shapr: i'm sad we missed each other, too. ;)
06:59:15 <whenamI> shapr:  are you atleast VP/EVP in your company ?
06:59:16 <juri_> you dropping by town, or by the CCC anytime soon? i'm in baltimore this weekend...
07:00:51 <whenamI> shapr:  there ? I am asking because programmers just become architects in my place
07:01:06 <whenamI> and then noting that too take 10/12 years
07:01:20 <whenamI> with heavy politics in pleasing the manager
07:01:21 <shapr> whenamI: no, I don't want to be management. I prefer to write code and build things.
07:01:37 <shapr> whenamI: this channel is really for learning Haskell, do you want to move this discussion to #haskell-offtopic ?
07:01:44 <shapr> or, do you want to learn Haskell?
07:01:46 <whenamI> sure
07:01:52 <whenamI> I wnt to learn haskell
07:02:04 <dmwit> ?where tutorials
07:02:04 <lambdabot> http://haskell.org/haskellwiki/Tutorials
07:02:11 <shapr> ooh, such reflexes
07:02:13 <shapr> many link
07:02:24 <dmwit> Too many, I think.
07:02:40 <juri_> heck, i should probably go through all of those again.
07:02:49 <dmwit> Picking 3-4 of the best (and writing a paragraph or two about what makes them stand out) from that enormous list would be a huge community service.
07:03:13 <whenamI> most of them outdated
07:03:35 <ysangkok> just buy Haskell From First Principles
07:03:58 <ysangkok> it's current, and exhaustive, and not hard
07:04:26 <whenamI> ysangkok:  finished long back
07:04:45 <whenamI> anyway thanks everyone
07:05:32 <dminuoso> whenamI: CIS194 is also a frequently mentioned resource. It's in depth and high quality.
07:05:58 <whenamI> dminuoso:  thank you I finished 2013 and 16 fall both
07:06:27 <whenamI> I am thankful to haskell community though
07:06:45 <shapr> whenamI: I suggest http://www.cis.upenn.edu/~cis194/spring13/
07:06:53 <shapr> oh, same thing dminuoso said
07:08:00 <whenamI> Yup
07:10:10 <juri_> shapr: sadly, i am the only haskeller at hacdc.
07:10:43 <shapr> :-(
07:11:34 <whenamI> I love haskell and no one uses haskell :(
07:11:44 <shapr> I know lots of people who use Haskell
07:11:58 <shapr> It's not (yet) as popular as Python or C
07:12:11 <shapr> but if you look around, you'll find people who do use it
07:12:14 <whenamI> c is not popular anymore too
07:12:44 <whenamI> python is only popular along with java
07:12:48 <Rembane> It depends on where you look
07:13:15 <whenamI> I even wonder why even clojure have more jobs than haskell
07:13:23 <shapr> whenamI: someone in my city offered me Haskell contract work last week
07:13:35 <shapr> it's not rare if you can use it and people know that
07:13:44 <veverak> it get's more popular
07:13:52 <shapr> whenamI: so, go through cis194, put things on github, join the community, you will get Haskell work!
07:14:02 <veverak> and I believe that a lot of codes really like it, it's just that don't find a job with haskell
07:14:03 <whenamI> shapr:
07:14:07 <whenamI> no more github
07:14:16 <whenamI> though icrosoft funded haskell
07:14:21 <veverak> seems like we are only waiting for managers to pick that up ;)
07:14:24 <juri_> i use my own kallithea instance.
07:14:29 <alp> _microsoft research_, to be precise :)
07:15:11 <whenamI> I dotn like the way github getting sold to microsoft
07:17:14 <shapr> whenamI: there's a mustard watch in cis194
07:17:18 <shapr> tell me when you find it...
07:18:12 <zincy_> When using quickcheck how do we impose extra constraints on the random generation of data types on top of the constraints defined in our Arbitrary instance for the ADT?
07:20:32 <philippD> zincy_ with newtypes with specific Aribitrary instances
07:20:40 <philippD> take a look at Positive https://hackage.haskell.org/package/QuickCheck-2.11.3/docs/Test-QuickCheck.html#t:Positive
07:21:43 <shapr> zincy_: if you want to use a small range of values for the type, hedgehog is popular.
07:25:29 <zincy_> thanks
07:25:35 <dmj`> zincy_: there’s also (==>) which can filter values further
07:25:39 <zincy_> property based testing is verry different to unit tests
07:26:28 <zincy_> Whats tricky is even getting all random instances of a nested record ADT representing a game to be valid games
07:27:48 <zincy_> dmj` - cant find the documentation for that operator?
07:28:56 <philippD> @hoogle (==>)
07:28:56 <lambdabot> Test.QuickCheck (==>) :: Testable prop => Bool -> prop -> Property
07:28:56 <lambdabot> Test.QuickCheck.Property (==>) :: Testable prop => Bool -> prop -> Property
07:28:56 <lambdabot> Test.SmallCheck (==>) :: (Testable m c, Testable m a) => c -> a -> Property m
07:30:04 <zincy_> has anyone here used property based testing for production systems and did they find it useful for real world code?
07:30:21 <shapr> I've used it to test work code here, found piles of problems.
07:30:47 <philippD> yep and yep. I even use it for java code at work.
07:30:48 <zincy_> ah cool
07:31:05 <shapr> stuff as simple as "we never thought about unicode in this form submisson" and "floating point numbers have infinity and NaN?"
07:31:23 <shapr> yeah, I've used QuickCheck to test java/python/C++
07:31:34 <shapr> and rails websites
07:32:06 <shapr> zincy_: I like to bet the authors a single beverage that I can find a pile of problems.
07:32:18 <shapr> I only make bets I know I will win :-P
07:32:56 <dmwit> shapr: minBound is another fun pain point for a lot of code (even more than maxBound).
07:33:06 <dmwit> e.g. abs minBound is not positive, etc.
07:33:55 <shapr> My favorite starting property is x == (load . save) x
07:34:26 <dmwit> oh, very good one
07:34:26 <shapr> whether that's a database, textfile, or whatever you're using to get data from memory to disk.
07:34:29 * hackage hapistrano 0.3.5.7 - A deployment library for Haskell applications  http://hackage.haskell.org/package/hapistrano-0.3.5.7 (juanpaucar)
07:34:31 <philippD> zincy_ property based testing also forces you to think more about the contracts of your components which is in itself a huge win.
07:35:07 <AWizzArd> cocreature: do you have a link to some tutorial that demonstrates what you mean by „you can recover the type parameter”?
07:35:15 <AWizzArd> (gadts, existentials)
07:35:34 <shapr> zincy_: if you want to see some incomplete code: https://github.com/shapr/schrabble/blob/master/test/Spec.hs
07:35:55 <shapr> line 33 has the load . save test
07:37:25 <jchia_> Does breaking up a big project into multiple packages improve build time?
07:38:06 <shapr> last I heard, stack can build multiple packages at the same time, but will only use one core per package
07:38:22 <shapr> I also heard that cabal new-build will use one core per module
07:38:48 <shapr> I haven't tested that, but I do know cabal new-build compiles take less time and more battery on my quad Xeon laptop.
07:38:59 <shapr> that is, compared to using stack to build the same project
07:39:00 <jchia_> shapr: Do you mean that stack can't build multiple modules in the same package at the same time so that breaking them up into multiple packages helps?
07:40:07 <shapr> I heard that a year ago, it may not still be true
07:40:15 <shapr> jchia_: try it out?
07:40:29 * hackage versioning 0.1.0.0 - Type-safe data versioning.  http://hackage.haskell.org/package/versioning-0.1.0.0 (lortabac)
07:40:35 <zincy_> shapr: thanks
07:40:50 <shapr> I'm thinking of upgrading to the six core Xeon ThinkPad when that's released this month.
07:41:12 <zincy_> shapr: Do you find the quickcheck is much easier to use with simpler types rather than record types?
07:41:22 <shapr> zincy_: once you get familiar with property based testing there's a pile of cool tricks
07:41:46 <shapr> zincy_: doesn't matter, just call arbitrary
07:42:02 <jchia_> I organized my big project (12k LOC) into multiple packages and find that I have to rebuild packages a lot when I make a small change in a small module in a package that the other packages depend on. I'm thinking if I don't use multiple packages, the dependency can be more granular.
07:42:05 <shapr> or liftMx arbitrary for a sum type
07:42:20 <shapr> jchia_: wow, what does it do?
07:42:29 <shapr> 12k lines is nice
07:42:34 <jchia_> basically the codebase for the whole company
07:42:45 <jchia_> for the haskell part
07:43:04 <shapr> are you using stack or cabal new-build?
07:43:07 <zincy_> https://lpaste.net/5851988336318611456
07:43:17 <zincy_> Does that look like sane use of quickcheck?
07:43:26 <jchia_> Using stack right now, haven't really learnt cabal
07:43:40 <jchia_> got scared by the term 'cabal hell'
07:43:44 <dmwit> lortabac: Neat, this looks very nice. I've used essentially this idea (without the fancy type parameter and class-upgrading mechanism) in a couple projects; I'm glad to see it mechanized.
07:43:52 <shapr> jchia_: it's not a problem if you use cabal new-* commands
07:44:27 <zincy_> btw with that pastebin ignore the fact the two tests cases  do essentially the same thing :)
07:44:30 <shapr> jchia_: "cabal hell" came from globally installed packages, and cabal new-build and friends don't do that
07:44:46 <jchia_> shapr: What are those, in a nutshell? How do they determine package versions to use?
07:45:17 <shapr> same old search, but without being limited to a curated slice of the versions
07:45:39 <dmwit> It uses the solver, as usual, to decide which package versions to use. The difference is that it now tracks dependency trees more carefully, and allows you to have multiple copies of the same version of the same library (but with different dependency trees) installed at once, and automates selecting the right one.
07:45:52 <shapr> stack is a wrapper around cabal, where each 'release' is a subset of the full hackage, tested to ensure they all work together
07:45:53 <cocreature> AWizzArd: sry, don’t really have a link handy but the basic idea is that if you have something like "data X a where IntX :: X Int; BoolX :: X Bool" and "data SomeX = forall a. SomeX (X a)" pattern matching on SomeX IntX tells you that the type parameter must have been Int
07:46:28 <shapr> jchia_: so, if your package bounds are polite, you can run "cabal new-build" in the same dir where you'd normally call stack build or whatever
07:46:53 <shapr> The downside to stack is that library authors who only use stack can end up with package bounds that don't work outside of tsack
07:47:14 <dmwit> (cabal hell came from demanding that a given package-version pair determined the full dependency tree of that pair)
07:47:14 <robstr> jchia_: stack has a flat file with version / lts, check https://www.stackage.org/lts-10.10/cabal.config for example
07:47:16 <shapr> mind you, I use stack when I'm teaching newbies, because cabal doesn't download GHC for you
07:47:50 <shapr> both stack and cabal have their own good points
07:48:38 <[exa]> I like how every packaging system has its own version of hell but all are basically isomorphic
07:48:56 <dmwit> Turns out: package management is a hard problem.
07:48:58 <dmwit> Who knew?
07:49:21 <zincy_> What do you guys consider a medium sized project in terms of LoC?
07:50:00 <dmj`> zincy_: 5-10k ?
07:50:10 <lortabac> dmwit: thanks! it is still largely untested, but I think this solution should help me cut hundred of lines in a project I'm working on. And also fix a subtle bug on the passage
07:50:33 <jchia_> robstr: I suppose I could use the cabal.config from stackage and use it with cabal new-build?
07:51:07 <zincy_> dmj` wow thats low compared to other langs
07:51:18 <[exa]> zincy_: depends on the language. The effort needed for implementation is usually a better measure. Small-sized is something you can reimplement in a week when coding in the afternoon freetime
07:51:19 <robstr> jchia_: i would suggest using nix with cabal new-*, gabriel has a great series about it, https://github.com/Gabriel439/haskell-nix
07:51:21 <shapr> zincy_: you can do big things in Haskell
07:51:23 <zincy_> whats javascript 20k?
07:51:31 <dmj`> zincy_: there’s been stories of 5M LOC java project turning into 1M LOC haskell
07:51:38 <shapr> I can read 20 pages of Python in hour, but 20 pages of Haskell could take me all day.
07:52:38 <zincy_> haskell is great for people with poor working memory
07:53:20 <shapr> zincy_: I agree
07:53:42 <shapr> zincy_: purity lets me reduce the amount of stuff I have to keep in my head when writing code
07:54:37 <jchia_> I find the hardest Haskell code to write is code that needs to interface with things written in other languages, like Python. If everything is Haskell, it's quite nice.
07:54:53 <merijn> jchia_: Even that can be quite easy if you use process
07:55:08 <cocreature> interfacing with other languages is great. now you can have segfaults in two languages
07:55:18 <jchia_> You have to mess with FFI, libraries that bind to those languages, specific config file formats, etc
07:55:20 <robstr> cocreature: haha
07:55:24 <[exa]> interfacing is hard in almost all languages if you don't some unixy abstraction
07:55:44 <jchia_> merijn: Running the process is not the hardest part.
07:55:46 <cocreature> related: https://twitter.com/cocreature/status/708347812082278401 :)
07:55:57 <dmj`> jchia_: that’s why you get someone to implement the dirty bits and expose it to you as a clean type-safe API. newtyping FFI types is powerful, and cheap af.
07:56:43 <dmj`> then parameterize your newtypes by some poly-kinded type and use closed type familes w/ TypeError to make it even safer / more user-friendly.
07:57:36 <jchia_> dmj`: I mean cases where the Python project already has some config file format and intermediate files and I'm trying to migrate to Haskell and have to write stuff to process those and sharing the work with the Python code that hasn't been migrated.
07:58:43 <dmj`> jchia_: yea probably fastest to use process as a stop gap until you rebuild the logic in Haskell.
08:00:34 <jchia_> For example, previously, we used Python as config files, literally .py files. Now, to use those config files, I need a python script to convert the config into a format that the Haskell can read, so I wrote a script to convert the .py config to .json.
08:00:38 <jchia_> That was tedious.
08:01:14 <zincy_> dumb quickcheck question - how do I enforce that y is greater than x
08:01:14 <zincy_>   property $ \(Positive x) (Positive y) -> y < x || (x `modInc` y) < y
08:01:39 <dmj`> jchia_: you could parse the python, traverse the AST
08:01:47 <dmj`> @package language-python
08:01:47 <lambdabot> http://hackage.haskell.org/package/language-python
08:02:10 <lyxia> zincy_: y > x ==> (x `modInc` y) < y
08:02:41 <lyxia> or you could generate x and the positive difference between x and y
08:03:08 <zincy_> lyxia: awesome thanks
08:03:21 <jchia_> dmj: I'd have to interpret the python also to get the config value.
08:04:00 <shapr> jchia_: which company?
08:04:11 <jchia_> dmj`: The use of python for config file makes config files flexible but basically unusable by Haskell.
08:04:16 <jchia_> shapr: Small company you haven't heard of.
08:04:22 <shapr> aw, ok
08:04:29 * hackage bdcs-api 0.1.1 - BDCS API Server  http://hackage.haskell.org/package/bdcs-api-0.1.1 (clumens)
08:04:33 <shapr> I'm just curious what your 12k of Haskell actually does
08:04:50 <dmwit> zincy_: property $ \(Positive x) (Positive dx) -> let y = x+dx in y < x || (x `modInc` y) < y
08:04:56 <jchia_> not public libraries, just our private code for the business
08:05:28 <shapr> yeah, but .. CRUD web apps? modbus or scada automation? any vague hand wavy thing?
08:05:36 <jchia_> basically trying to automate as much as possible in our line of work where another business might hire more people
08:06:50 <shapr> There are at least two companies in the Atlanta area that do a bunch of web app stuff with Haskell
08:07:14 <dmj`> shapr: layer 3 is one of them
08:07:18 <shapr> yup
08:07:19 <jchia_> not web stuff, roughly finance-related
08:07:26 <shapr> dmj`: and seller labs is the other
08:07:28 <zincy_> Are there any cases of a one man band running a business on haskell?
08:07:36 <zincy_> or one woman :)
08:07:39 <shapr> sure, several
08:07:52 <shapr> you get a bunch of amplification writing Haskell
08:07:53 <zincy_> which ones
08:08:05 <shapr> um, I think bitemyapp was doing that for awhile
08:08:19 <shapr> I know some of the russian devs are doing that
08:08:45 <shapr> zincy_: I spent seven years doing mostly Python and some Haskell self-employed
08:09:33 <shapr> Lots of people want work done, and they do not care at all how you do it. They give you the inputs, and they want particular outputs.
08:10:06 <jchia_> We have a hard time hiring competent developers, especially Haskellers.
08:10:14 <zincy_> shapr: what kind of self-employed work?
08:10:24 <zincy_> jchia: why?
08:10:33 <shapr> I've written Haskell code to convert ms.doc files to custom xml formats, rip off a pile of NNTP newsgroups and do collation, generate web pages, etc
08:10:51 <zincy_> jchia: specifically towards hiring competent haskellers
08:10:59 * hackage iso8601-time 0.1.5 - Convert to/from the ISO 8601 time format  http://hackage.haskell.org/package/iso8601-time-0.1.5 (NiklasHambuechen)
08:11:04 <dmwit> lortabac: Oh, beware: aeson doesn't handle nested `Maybe`'s well. I see your `type NA = Maybe`. So an `NA (Maybe Foo)` might not work the way you want it to.
08:11:07 <shapr> jchia_: I'd also like to hear your definition of competent :-)
08:11:14 <maerwald> I don't believe it's hard to hire competent haskell devs. People are just too picky and don't want to provide an environment for employees to grow
08:11:20 <jchia_> zincy_: Maybe because we're a small company and people like to work in big ones. Also because there are not that many Haskellers locally to start with.
08:11:43 <dmwit> lortabac: You might want to consider making `NA` a new type that is more careful with its `FromJSON`/`ToJSON` instances.
08:11:47 <shapr> if I knew the name of your company, I could at least stalk your location :-)
08:11:59 <maerwald> haskellers are amongst the most learning-willing people, so if you have a hard time hiring them, you are doing something wrong
08:12:05 <lortabac> dmwit: unfortunately this is impossible at the moment
08:12:28 <lortabac> dmwit: I hope it will work with -XDerivingVia
08:12:30 <dmwit> lortabac: Oh, and now I see I misread because `type NA = Maybe Bare`, and so there should be no problem.
08:12:45 <zincy_> maerwald: yes I don't think the beginner stage lasts very long in haskell. Its a brick wall
08:12:48 <jchia_> shapr: Competent enough to work on one of our medium projects independently without close supervision, able to design a solution and think of most of the important details.
08:12:57 <lortabac> dmwit: Bare = Void + aeson instances
08:13:17 <dmwit> lortabac: Errr... you should definitely test this.
08:13:32 <shapr> jchia_: do you have enough Haskellers to do pairing? That's how I learn fastest, not sure about others.
08:13:38 <dmwit> lortabac: `Maybe`'s aeson instances use null for `Nothing` and the bare value for `Just`.
08:13:42 <shapr> like, train up your own devs?
08:13:44 <maerwald> the people I've met would give up all sorts of well-paid jobs just to get to work with haskell
08:14:20 <maerwald> because in the end, you're also losing your sanity when you do mainstream languages
08:14:27 <dmwit> lortabac: Ugh, I keep waffling. I don't know whether I expect this to work as-is or not. =P
08:14:40 <lortabac> dmwit: it works
08:14:51 <lortabac> dmwit: but unfortunately it's a hack
08:14:59 <jchia_> shapr: There are at most 2 Haskellers here, including myself, so maybe we can do pairing. I haven't done pairing before. So, what happens during pairing? Somebody writes code and the other watches and ask questions if he doesn't understand or disagrees or have other thoughts?
08:15:05 <shapr> I'd take a pay cut to write Haskell full time, but I don't know if I have the necessary skills
08:15:32 <shapr> jchia_: yeah, best approach is for the learner to 'drive' most of the time, but you do have to switch out
08:15:42 <shapr> I've learned much watching how someone navigates a codebase
08:15:48 <shapr> or what they assume and what they have to check
08:15:59 <shapr> different companies have different ... cultural codebase assumptions
08:16:07 <lortabac> dmwit: Maybe is the only type that can be parsed generically when a field is missing
08:16:32 <lortabac> dmwit: since it is hard-coded in the Generic instances, this behavior cannot be extended to other type
08:16:45 <lortabac> s
08:17:58 <dmwit> bummer
08:18:10 <lortabac> dmwit: if you write the instances manually, you have to use .:? otherwise it will not work
08:20:43 <dmj`> lortabac: what are you trying to do?
08:21:47 <benzrf> edwardk: yo, i was thinking about mtl's issues again today (quadratic growth of instances, orphan instances) and thinking that a lot of it is *obviously* automatically inferrable even if that's not possible to express directly in typical ghc haskell
08:22:03 <lortabac> dmj`: https://github.com/lortabac/versioning Look at the NA type in the Base module
08:22:10 <benzrf> is there any experimental stuff that i havent heard of that tries to fix that problem or anything?
08:22:59 <dmwit> benzrf: Lightweight Monadic Programming in Haskell proposes an alternate type system that infers returns, binds, and (crucially to your question) lifts.
08:23:10 <dmwit> ugh
08:23:13 <edwardk> no
08:23:14 <dmwit> s/Haskell/OCaml/
08:23:24 <dmwit> My wishful thinking fired up there. =(
08:24:16 <benzrf> lol
08:24:18 <dmwit> Anyway that would cut out the need for `MonadWriter` and friends entirely.
08:24:19 <benzrf> edwardk: aww :(
08:24:25 <benzrf> looking at this just makes me sad https://i.imgur.com/ZSPfmFA.png
08:24:27 <edwardk> in theory you could switch 90% of the code to default signatures instead of the current (better) defaults and “help” a bit for some definition of help
08:25:04 <benzrf> yeah i feel like the primary issue isnt even having to copy/paste definitions but just the necessity of adding instances
08:25:11 <lortabac> dmj`: basically I have a type that is isomorphic to (). I would like to be able to decode this type with generics when this field is missing
08:25:13 <dmj`> lortabac: Ah, yea I remember when aeson changed its default behavior so attempting to parse into a Maybe a when a field is missing causes an error to be thrown instead of returning a Nothing. Is that the issue
08:25:21 <benzrf> i guess avoiding that would require significant extensions/modifications to the entire notion of typeclasses...
08:25:23 <benzrf> :{
08:25:34 <edwardk> e.g default get = lift get; put = lift . put
08:25:41 <edwardk> no
08:25:44 <benzrf> cant there be a coherent way to write "instance (MonadState s m, MonadTrans t) => MonadState s (t m)"
08:25:46 <benzrf> :(
08:25:49 <benzrf> oh?
08:25:51 <dmwit> Yes indeed. The paper I proposed adds a whole new class of constraint with a new solver.
08:25:55 <lortabac> dmj`: ideally I would use data NA = NA
08:26:01 <edwardk> just way shittier code for the interesting instances
08:26:14 <lortabac> dmj`: but I cannot extend the behavior of Maybe to other types
08:26:27 <edwardk> dmwit: paper?
08:26:44 <dmwit> edwardk: Lightweight Monadic Programin in OCaml. I'd love to see an analog for Haskell worked out in detail.
08:26:55 <dmwit> Programming. typing is hard
08:27:21 <edwardk> walking and typing on my phone in the rain. i feel ya
08:27:50 <cjay-> carter: what was that name again that you told us to google about linear types?
08:27:59 <dmj`> lortabac: You mean using generics? Why not unwrap and call the parseJSON instance on the underlying Maybe type, or am I missing something
08:28:11 <[exa]> MLs are strict by default, that simplifies the situation quite a lot
08:28:26 <lortabac> dmj`: I tried, it doesn't work
08:28:52 <dmwit> Doesn't really make a difference. It's easy enough to say "inside this block where we infer all the binds and stuff for you, argument order is left-to-right for monadic actions".
08:28:54 <dmj`> lortabac: can you show me what you tried, or better yet, can we repro a tiny example
08:28:54 <edwardk> fortunately as a haskeller i was able to infer what you didnt type
08:29:10 <carter> cjay-: the mike shulman linear logic thing?
08:29:16 <lortabac> dmj`: oh wait, I am not sure I understood what you told me :)
08:29:24 <carter> Ask me more tomorrow.  Or any time this week.
08:29:27 <dmwit> And I don't really think anybody would complain about that. You can always let-bind something if you want it to happen in a non-default order.
08:29:53 <lortabac> dmj`: my goal is to avoid using Maybe
08:30:09 <edwardk> dmwit: ml is damaging your brain ;)
08:30:13 <dmj`> lortabac: you want to avoid Maybe, but in the case a field is missing you’d like to return a default value ?
08:30:22 <cjay-> carter: yep thanks I think that was what I meant
08:30:25 <lortabac> dmj`: yes, exactly
08:30:44 <dmj`> `o .: “could-be-missing-field” .!= someDefaultValue`
08:30:48 <lortabac> dmj`: I think the only way to achieve that is to wait for -XDerivingVia
08:31:21 <lortabac> dmj`: it works with manual instances, but not with Generic
08:31:27 <carter> cjay-: honestly only the first few pages and or maybe some of the examples are needed.
08:31:49 <carter> I’ll have some better notes tomorrow after I’ve rested
08:32:03 <lortabac> dmj`: that's why I had to define that weird type-synonym
08:32:33 <lortabac> dmj`: which is basically Maybe Void
08:33:42 <benzrf> after reading a few posts by bob harper im starting to become slightly more uncertain about ML vs haskell :>
08:33:48 <benzrf> i should probably try ml at some point
08:33:50 <dmj`> lortabac: afaik DerivingVia seems to be taking instances as long as you can `coerce` into a representationally equalivalent type. This means some other newtype would have the behavior you’re looking for, and I’m not sure that exists.
08:33:51 <benzrf> well, probably ocaml
08:34:44 <lortabac> dmj`: so I guess I have to keep the hack :(
08:36:11 <butterthebuddha> Is there a function in the library that maps a list like [1,2,1,2,1] to ([1,1,1], [2,2])
08:36:19 <butterthebuddha> I splits the list by alternating elements
08:36:20 <dmj`> lortabac: nah, I got you
08:36:23 <dmj`> lortabac: https://gist.github.com/a81a4a838e2c3654498da89fe487dc89
08:39:11 <lortabac> dmj`: ok, it works for manually written instances
08:39:56 <lortabac> dmj`: but I want the same behavior for all records with fields of a given type
08:41:28 <lortabac> dmj`: I mean, whenever there is a field of type NA, and you derive a FromJSON instance generically, if that field is missing it should be decoded with a default value
08:42:03 <dmwit> edwardk: I dunno. I do think it's kind of dumb that all monadic actions in Haskell have to be essentially hand-compiled to A-normal form.
08:42:09 <veryuniqkname> Hello everyone. I have a C function that fills array with some data. I allocate array with mallocBytes. Then i have to send this data over a socket, so i need to convert the array to ByteString. How can i do this?
08:42:40 <dmwit> edwardk: The vast majority of the time *for monadic things*, top-to-bottom lets and left-to-right argument order is what you want/expect to happen anyway.
08:44:31 <dmj`> lortabac: afaik, there’s no way to provide a default value for generic instances in the case a field is missing. Let me try an idea though real quick...
08:46:22 <edwardk> dmwit: my dig probably read as way more adversarial than intended. i was mostly just trying to tease about evaluating your arguments before calling your functions, etc.
08:47:04 <dmwit> yeah =)
08:47:15 <dmwit> v. unhaskelly
08:47:58 <edwardk> i pretty much think the whole idea is a non-starter in an inference heavy world though, especially one like haskell where we tend to like to pass monadic actions to monadic combinators for things like pass/listen etc. where they _aren't_ being sequenced
08:50:41 <dmwit> I'm not sure I see why that would be a problem. You're probably assuming that it would see `listen m` and turn that into `m >>= listen`, but that isn't how it works; if `m` is already the right type it would actually desugar to something like `return m >>= listen`.
08:51:11 <dmwit> Which is less than ideal, obviously (there's an extra `return` and `bind`), but they discuss optimizations that rewrite away that kind of thing according to the monad laws.
08:54:05 <[exa]> dmwit: btw there's lazy lifting as well
08:55:27 <nruebwbae> Does anyone know some good resources for learning to understand System F? Book, video, tutorial, anything. Searching the web gives a lot of music and ford cars stuff...
08:56:32 <dmwit> ?where TaPL
08:56:32 <lambdabot> "Types and Programming Languages" by Benjamin C. Pierce in 2002-02-01 at <https://www.cis.upenn.edu/~bcpierce/tapl/>
08:58:02 <nruebwbae> holy shit that's a great bot feature
08:58:14 <dmj`> lortabac: The issue is that a field can’t know the name of its selector without the meta data of the parent object present (SelName from GHC.Generics). Unless you rewrote GFromParseJSON to account for that. You’d want some kind of default type class (Def) that would provide a value during GParseJSON in the event a field is missing.
09:03:00 <nshepperd> dmwit: special syntax for do blocks that rewrites 'func ~arg1 ~arg2' to 'a <- arg1; b <- arg2; func a b'?
09:03:29 <lortabac> dmj`: I talked to phadej yesterday about this. The idea in the last comment could provide a solution: https://github.com/bos/aeson/issues/614
09:04:25 <lortabac> dmj`: basically the idea is to have a FromJSONField class to describe this kind of behavior
09:04:30 <dmj`> lortabac: yea, alternatively, we could provide a helper function that would allow us to configure custom generics instances for aeson, that would be great imo
09:04:32 <benzrf> nshepperd: i'm pretty sure ?where only retrieves things that people have taught the bot, unfortunately
09:04:35 <dmj`> lortabac: brb lunch
09:04:58 <lortabac> dmj`: I have to go too, I'll be back tomorrow
09:05:29 <edwardk> dmwit: "already the right type" in a world where so much stuff is tucked behind typeclasses is pretty nebulous.
09:05:51 <edwardk> :t get
09:05:52 <lambdabot> MonadState s m => m s
09:06:30 <edwardk> did i want that in the current monad i'm working in? is it an action i'm passing around to do something else? who knows.
09:07:04 <benzrf> er
09:07:05 <benzrf> sorry, not nshepperd
09:07:09 <benzrf> nruebwbae: i'm pretty sure ?where only retrieves things that people have taught the bot, unfortunately
09:11:46 <nruebwbae> benzrf: still, I now have 600 pages of type theory to read all thanks to the bot :-)
09:12:37 <benzrf> ^_^
09:14:08 <Zemyla> I wonder if there's a way to make it so IntSet has a complement function.
09:15:15 <butterthebuddha> Is lpaste down or is it just me?
09:15:23 <infinisil> Zemyla: A flag that signals the complement should work
09:15:58 <Welkin> butterthebuddha: it's been messed up recently
09:16:06 <cocreature> butterthebuddha: which url are you trying to use?
09:16:10 <Zemyla> I was actually thinking more like a sequence of intervals.
09:16:12 <butterthebuddha> lpaste.net
09:16:31 <cocreature> are you sure you’re not trying lpaste.net/new/haskell?
09:16:42 <butterthebuddha> Yep
09:16:48 <infinisil> Zemyla: You mean a multi-interval?
09:16:48 <cocreature> lpaste.net is working for me but the codebase got rewritten and the /new/haskell links no longer work
09:17:01 <Welkin> what happened to the code anyway?
09:17:16 <Welkin> it worked fine before, and now it looks like files are missing
09:17:31 <butterthebuddha> https://i.imgur.com/U5bik45.png
09:17:49 <Welkin> why rewrite something that works
09:17:58 <cocreature> butterthebuddha: try without the www maybe?
09:18:20 <butterthebuddha> no dice :(
09:18:44 <butterthebuddha> Regardless, can someone help me debug the code for part 2 here -> https://pastebin.com/raw/qH6EfWQX
09:18:46 <cocreature> hm no idea then, sry
09:18:52 <butterthebuddha> https://adventofcode.com/2015/day/3 <- for this challenge
09:19:05 <butterthebuddha> The correct answer is 2360, but the code is giving me 2333
09:20:51 <butterthebuddha> I'm getting the right answer for part 1, so I can't imagine visited is incorrect
09:23:01 <glguy> butterthebuddha: Your visited processes the list in the wrong order
09:23:22 <butterthebuddha> Do I need to fold left?
09:23:54 <butterthebuddha> That doesn't sound right :/
09:24:19 <glguy> spend some time pondering that function then until it starts to make more sense
09:25:10 <butterthebuddha> If I fold left, won't I be processing the directions from the end?
09:25:51 <cocreature> no, that’s what foldr does
09:25:53 <glguy> foldr and foldl both process the list from left to right. It's the only way you can process a list
09:26:53 <glguy> where it "starts from" isn't the right way to think about those two functions
09:31:34 <glguy> butterthebuddha: Once you fix your implementation of visited, you might find this use of scanl neat: https://github.com/glguy/advent2015/blob/master/Day3.hs
09:32:54 <osa1> does stack install have a parameter to specify where to install the binary? I think there was a parameter for this but I can't see it in --help
09:35:07 <butterthebuddha> glguy: that's _very_ nice
09:39:32 <jared-w> reddit's down as I'm trying to procrastinate on studying for finals. Hmmph
09:40:24 <cocreature> osa1: iirc it’s --local-bin-path
09:40:33 <matsurago> jared-w: is redit that great for procrastination?
09:40:50 <jared-w> matsurago: It's basically where I spend 80% of my internet time, for better or worse
09:41:03 <osa1> cocreature: that's it, thanks
09:41:14 <osa1> it's not in --help for some reason
09:41:54 <matsurago> jared-w: sounds good, need to try that too ._.
09:42:13 <jared-w> I don't recommend it; wasting time is far less useful than doing useful stuff with your time :p
09:42:29 * hackage HNumeric 0.3.2.0 - Haskell Numeric Library with pure functionality, R & MATLAB Syntax.  http://hackage.haskell.org/package/HNumeric-0.3.2.0 (edeftg)
09:42:40 <cocreature> jared-w: doing useful stuff is useful? that’s absurd!
09:42:46 * cocreature goes back to wasting his time
09:42:48 <jared-w> cocreature: absolutely mad
09:42:53 * jared-w goes back to not studying
09:45:03 <infinisil> jared-w: Hah! I still have about 50 tabs of reddit open when it was up
09:45:05 <sm> osa1: it's in stack -h, not stack install -h
09:45:35 <osa1> oh, OK
09:46:28 <jared-w> no fair :(
09:46:58 <jared-w> it's a good thing, though. I restricted myself to basically only lurking r/haskell now and it's helped me waste less time. Need to stop going to reddit entirely and just read taylor's weekly haskell digests instead; far more efficient :)
09:57:34 <mbwgh> Does the `directory` package and functions like `listDirectory :: FilePath -> IO [FilePath]` rely on lazy-io?
09:58:26 <cocreature> mbwgh: iirc it doesn’t. it will only return once it has fetched all directories
09:59:16 <maerwald> https://hackage.haskell.org/package/directory-1.3.3.0/docs/src/System.Directory.Internal.Posix.html#getDirectoryContentsInternal
10:02:49 <bwe> Currently I perform 23 HTTP GET requests with https://github.com/mrkkrp/req sequentially (by mapping over the expressions). How can I save time by executing more than one at a time?
10:05:47 <[exa]> bwe: forkIO and collect the results using MVars? (wild guess)
10:05:57 <cocreature> bwe: use async’s mapConcurrently
10:06:32 <cocreature> if you want to limit the number of concurrent requestsr, either wrap the requests in a semaphore or take a look at async-pool
10:07:04 <dmwit> edwardk: In this world, MonadState does not exist. There is only `get :: StateT s m s`, and inference takes care of lifting it to the appropriate monad if necessary.
10:08:03 <edwardk> mempty then. anything that might happen to be instantiated by a thing that happens to be a monad rather than is definitely some concrete monad.
10:08:23 <dminuoso> Regarding async - when I have an infinite loop acting as a dispatcher between TQueues inside an `Async Void`, is it fine to pass this `dispatcher :: Async Void` around to wherever I implicitly use this dispatcher for the sole purpose of propagating exceptions correctly with waitAny?
10:08:38 * dmwit nods
10:08:49 <dmwit> edwardk: It's a tradeoff I'd be interested in having the ability to make.
10:10:13 <edwardk> fair. feels clunky to me, but ymmv. i look forward to our new haskml overlords.
10:16:23 <bwe> cocreature: mapConcurrently just works out of the box! limiting it to four simultaneous threads would be wrapping it into `withTaskGroup 4 $ \g -> do ...` (untested yet) from async-pool. Thanks for your advice.
10:16:32 * shapr dances cheerfully
10:19:57 <khilan> Hello! I need to convert an `int` to  `Pixel`. Something along the lines of the type : `toNew :: ToY cs e => Int -> Pixel Y Word16`. I know it is a bit silly but I'm unable to so. Can someone plz help me out?
10:20:55 <cocreature> khilan: which Pixel type are you referring to?
10:21:12 <khilan> Pixel as in for images
10:21:40 <cocreature> I’m asking about the package that it comes from, there are probably quite a few packages that define a type called Pixel
10:22:06 <khilan> Oh sorry. I'm working with HIP (Haskell Image Processing) Package
10:22:56 <khilan> http://hackage.haskell.org/package/hip-1.5.3.0
10:23:52 <cocreature> looks like PixelY (fromIntegral i) should typecheck. whether it does what you want it to, I don’t know. you’ll have to provide more information for that :)
10:27:48 <khilan> Well, actually I'm trying some basic operations. In an array defined with `Image arr Y Word16` , I want to write some expression like `write arr (i,j) px` where px is `(rank * 255) / 900`
10:28:13 <khilan> But, I'm getting some type errors which I unable to resolve :-)
10:28:55 <khilan> And rank is a mutable reference, int
10:30:13 <khilan> https://lpaste.net/988494338151415808
10:31:28 <cocreature> khilan: can you also show us the full type error?
10:31:48 <khilan> yes sure, 1 min
10:33:12 <khilan> https://lpaste.net/5676380034256863232
10:35:29 * hackage bdcs-api 0.1.2 - BDCS API Server  http://hackage.haskell.org/package/bdcs-api-0.1.2 (clumens)
10:36:50 <cocreature> khilan: alright, so have you tried using PixelY (fromIntegral px) as I suggested?
10:37:23 <khilan> No sir, 1 min plz
10:38:36 <[exa]> any favorite method to parse really simple stuff, like SMTP commands? ( "RCPT TO:<some.mail@domain>" )
10:39:12 <[exa]> I'd patternmatch it, but there's some ambiguity on whether there are the <angle brackets> around, whitespace, and possibly some ignored stuff
10:39:17 <cocreature> [exa]: I’d still use some parser combinator lib (e.g. megaparsec). ime they don’t get in the way even for simple stuff so there is not really a reason to avoid them
10:40:24 <Psybur> is there a more concise way of doing: f <$> a <*> b <|> a <|> b ?
10:40:49 <khilan> Yes, It worked! Thank u so much! I was trying some stupid things earlier...Getting some more type errors. Will try to resolve them. Thank  u!
10:40:59 * hackage digestive-functors-aeson 1.1.25 - Run digestive-functors forms against JSON  http://hackage.haskell.org/package/digestive-functors-aeson-1.1.25 (OliverCharles)
10:44:37 <[exa]> cocreature: I didn't want to pull the dependency because of something as simple, but yeah it will probably be easiest
10:47:04 <cocreature> [exa]: with the exception of trifecta, the parser combinator libs that we have in Haskell are fairly light on dependencies so I wouldn’t really worry about that
10:47:19 <glguy> Psybur: probably not, but another possibility to consider is: \f a b -> (\x -> maybe x (f x)) <$> a <*> optional b <|> b
10:47:59 * hackage ekg-bosun 1.0.14 - Send ekg metrics to a Bosun instance  http://hackage.haskell.org/package/ekg-bosun-1.0.14 (OliverCharles)
10:48:29 <glguy> Psybur: just depending on what types you're working with that could avoid some "effects" of a being duplicated
10:48:39 <[exa]> cocreature: that's the megaparsec problem, it sounds too mega
10:49:03 <[exa]> btw isn't there SMTP server-side protocol implementation somewhere?
10:50:00 <[exa]> oh wow ofc it is. </problem>
10:51:59 * hackage json-assertions 1.0.12 - Test that your (Aeson) JSON encoding matches your expectations  http://hackage.haskell.org/package/json-assertions-1.0.12 (OliverCharles)
10:55:44 <Psybur> glguy: thanks
11:02:32 <SomeGuy> hi all, recently did a migration to stack lts-11.12 and I now having an issue compiling test where it finds a data type defined twice. It seems to me that stack is compiling a lib twice and then having a resolution issue. Has anyone seen this?
11:03:48 <kritzefitz> Writing string literals over multiple lines doesn't seem to work when compiling with stack build, while stack ghci is able to load the file without problems. Can anyone enlighten me what I'm doing wrong?
11:04:53 <[exa]> kritzefitz: does it produce an error message or something?
11:05:03 <Psybur> glguy I get an infinite type error with that
11:05:15 <glguy> I can't see your screen
11:05:25 <kritzefitz> [exa]: I get this error: lexical error in string/character literal at character 'P'
11:05:38 <kritzefitz> 'P' is the first character on the second line of the continued string.
11:06:07 <Psybur> I'm on IRC on my phone and ghci in my laptop :(
11:06:14 <kritzefitz> s/first/first after the initial backslash/
11:06:35 <glguy> Psybur: OK, you'll have to fuss with it then and see where your error is. I don't have a good guess about what you did
11:06:36 <[exa]> kritzefitz: can you pastebin a tiny bit of that? we've seen this error when C preprocessor was enabled
11:06:44 <Psybur> ops forgot f
11:07:09 <cocreature> Psybur: an infinite type error? that sounds interesting …
11:07:27 <kritzefitz> [exa]: Sure, give me a moment to prepare something minimal that still fails.
11:07:42 <[exa]> kritzefitz: but I don't think that running inside/outside of ghci should affect the outcome
11:08:22 <Psybur> nvm glguy I rigged up the params
11:08:33 <dmwit> kritzefitz: Is stack using CPP?
11:08:44 <dmwit> kritzefitz: We discovered a few days ago that CPP eats Haskell-style string gaps.
11:09:09 <kritzefitz> dmwit: I haven't told it to. I don't know if it does use CPP by itself.
11:09:20 <infinisil> OHhhhh
11:09:37 <shapr> zincy_: if you want more property test adventure, there's hedgehog, smallcheck, fitspec, speculate, and more!
11:09:40 <glguy> dmwit: Is that something that can be fixed by adding a trailing space to the first \ (so that it's not the last character on the line)
11:09:42 <glguy> ?
11:09:45 <infinisil> I finally get why CPP is talked so much about with Haskell
11:09:51 <dmwit> glguy: Hey, good idea!
11:09:58 <[exa]> dmwit: do you remember if it ate the terminating backslash or misinterpreted the backslash on the next line?
11:10:08 <dmwit> glguy: I don't know the answer, but I bet it's "yes".
11:10:29 <cocreature> the annoying part about that is that I have my editor configured to delete trailing spaces :)
11:10:32 <infinisil> CPP = C Pre-processor, it's run on Haskell code to enable you to add these #if things for conditional compilation! Right?
11:10:37 <dmwit> [exa]: It ate the backslash at the end of the line, causing GHC to have trouble with the backslash on the next line.
11:10:41 <[exa]> infinisil: yes
11:10:44 <dmwit> infinisil: right
11:10:51 <infinisil> It all makes sense now
11:11:07 <glguy> cocreature: time to fix your editor :)
11:11:16 <zincy_> shapr: Which one is the most convenient and easiest to use?
11:11:23 <cocreature> glguy: well usually I’m quite happy that it does that :)
11:11:30 <zincy_> Also do they all rely on the Arbitrary typeclass?
11:11:30 <glguy> Delete all trailing spaces except those that are important
11:11:33 <dmwit> cocreature: Don't worry, after you fix your editor you can still add a macro that does it on purpose when you ask for it.
11:12:36 <cocreature> I’ll just be lazy and keep using unlines or mconcat in those cases :)
11:12:50 <cocreature> luckily I don’t have that many cases where I need multiline strings and CPP in the same file
11:13:14 <shapr> zincy_: I'm not sure which is easiest, but QuickCheck is the most popular, and hedgehog is gaining popularity: https://teh.id.au/posts/2017/04/23/property-testing-with-hedgehog/index.html
11:14:40 <orion> Hi. I am interacting with a the Gmail API. Some calls are paginated with a "page token" appended to the result. I have three different designs to handle this: https://gist.github.com/centromere/4da0ef7b209fcccfb3797b99a6c4b713
11:15:01 <orion> I am having trouble evaluating which design is best.
11:16:38 <orion> Designs A and B are very similar, and they *seem* elegant to me. However, I am unsure whether or not it'll have long term negative consequences in terms of complexity.
11:19:10 <dmwit> orion: I like B the best.
11:19:38 <shapr> zincy_: we have a whole ruby library at work for generating packets and pcaps for testing, it's pretty hacky. Then there's people using wireshark: http://www.petecorey.com/blog/2018/06/11/generating-test-fixtures-with-wireshark/
11:19:51 <orion> dmwit: Why?
11:20:03 <shapr> I'd like to yell "PROPERTY BASED TESTING" at them all, but I usually get "old man yells at cloud" emojis when I do that.
11:21:42 <[exa]> there's an emoji of that now?
11:21:45 <maerwald> property testing isn't that amazing
11:22:33 <shapr> maerwald: it's better than static unit tests
11:22:43 <maerwald> there is no "better" here
11:22:49 <shapr> why so?
11:22:54 <maerwald> unit tests have a different use case
11:23:06 <maerwald> it makes no sense to say they are worse than a different approach, which has a different use case
11:23:16 <cocreature> I should probably yell more at people while I’m sufficiently young for the “old man yells at cloud” to be inappropriate
11:23:18 <shapr> why not both?
11:23:36 <orion> cocreature: How old are you?
11:23:44 <shapr> maerwald: I had a prototype quickcheck that saved failing test inputs
11:23:47 <cocreature> orion: 23
11:23:52 <orion> Oh, nice.
11:23:55 <shapr> ooh, I'm exactly twice that!
11:23:57 <orion> dmwit: Why do you perfer design B over A and C?
11:24:01 <johnw> shapr: same!
11:24:07 <shapr> johnw: september?
11:24:10 * cocreature high-fives johnw and shapr
11:24:11 <johnw> feb
11:24:14 <shapr> whew
11:24:28 <shapr> If the birthday paradox showed up, I'm be entertained.
11:25:11 <dmwit> orion: Because 1. it hides the particular implementation but 2. it still gives the programmer control over exactly when requests to gmail's site happen.
11:25:42 <shapr> maerwald: but srsly, what do you think about property based testing that saves failing inputs?
11:25:53 <shapr> does that cover the unit test use case?
11:27:14 <dmwit> The birthday paradox: in which two humans will talk inanely at each other until they find something in common, at which point they will declare "wow! what a small world".
11:29:25 <[exa]> concurrency question: I have a program that does 2 things at once using forkIO, and both need some initialization/deinitialization, done by bracket
11:29:36 <orion> dmwit: All the designs listed give you full control over when the requests to gmail happen.
11:29:44 <[exa]> ...so it's basically forkIO (bracket .....) >> bracket .....
11:29:55 <kritzefitz> [exa]: I think I found the problem myself, while trying to make an uploadable example.
11:30:11 <[exa]> Q: when the program is interrupted, only the main-thread bracket is "released", the forked one does not. Why is that so?
11:30:11 <kritzefitz> I'm using a nonstandard Setup.hs that seems to enable CPP.
11:30:16 <orion> dmwit: Point #1 is a good one.
11:30:27 <orion> dmwit: Why is Design B superior to design A?
11:30:40 <orion> Both A and B hide the implementation detail.
11:31:10 <[exa]> kritzefitz: well at least you didn't find any new weird thing. Does the fix that glguy suggested work?
11:31:30 <cocreature> [exa]: when the main thread is dead all other threads are killed immediately without running finalizers
11:32:03 <[exa]> cocreature: so I should kill them manually in the main thread's finalizer?
11:32:19 <cocreature> [exa]: I would use something like async’s waitAnyCatchCancel for that
11:33:05 <kritzefitz> [exa]: Huh, the fix doesn't work. But that the Setup.hs uses CPP was just a guess. I will try to find out what it actually does.
11:34:54 <[exa]> cocreature: seems exactly like what I needed, thanks! :]
11:36:26 <kritzefitz> It actually is CPP that is breaking the syntax for me, it just seems to have become “smarter“ and warns about spaces between backslashes and line breaks before ignoring them completely.
11:37:47 <geekosaur> CPP knows C, not Haskell. there' a fair number of Haskellisms that will confuse it
11:37:58 <geekosaur> it actually is the C preprocessor, not a Haskell speciifc one
11:38:37 <kritzefitz> Yeah. I will probably have to fix the library that provides my Setup.hs to not use CPP.
11:38:41 <[exa]> I'm kindof wondering why there's no Haskell-specific preprocessor (#commands aren't that hard to implement, right?)
11:38:44 <geekosaur> unmatched single quotes, # with MagicHash in effect, etc. and more problems if the cpp in question came form clang, because you can;t fully turn off its knowledge of ANSI C
11:39:08 <geekosaur> there's cpphs, but it's gpl and various folks won;t touch it as a result. (corporate lawyers really distrust gpl3)
11:39:42 <[exa]> corporate lawyers should burn
11:39:56 <[exa]> nevermind. :]
11:40:59 <[exa]> so if I #define a parametrized macro and have parentheses in the code after the macro name, I guess it gets expanded as well?
11:41:27 <[exa]> ...ok now this makes an interesting language combo
11:46:39 <geekosaur> yes. its not a smart macro processor
11:47:17 <jared-w> edwardk: what felt clunky to you?
11:50:59 * hackage diagrams-lib 1.4.2.3 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-1.4.2.3 (BrentYorgey)
11:53:32 <butterthebuddha> What's the best way to filter a list based on predicates that rely on adjacent elements?
11:53:49 <butterthebuddha> Can I filter a list two elements at a time?
11:53:50 <cocreature> butterthebuddha: zip the list with the tail of the list
11:54:22 <butterthebuddha> Ah
11:54:29 <ski> > (zip `ap` tail) [0,1,2,3]
11:54:31 <lambdabot>  [(0,1),(1,2),(2,3)]
11:54:41 <johnw> then filter, then map fst
11:55:24 <shapr> @tell maerwald I want to hear about the different use cases for unit testing vs property testing!
11:55:24 <lambdabot> Consider it noted.
12:02:46 <jared-w> shapr: for me, unit testing is almost always about preventing specific bug regressions
12:03:05 <jared-w> Every bug report in the repo should have a fix and then ideally a unit test making sure that particular regression doesn't happen again
12:03:22 <jared-w> property testing doesn't do that and it's particularly bad at testing pathological cases
12:03:40 <shapr> what about failing prop inputs being saved as unit tests?
12:04:17 <jared-w> You can do that too and it's probably a good idea for a lot of things (depending on the use case)
12:04:37 <jared-w> failing prop units are, in my mind, just a special case of a bug report
12:05:41 <shapr> I read a neat blog post recently, someone was reducing the crashes afl was finding, and while all the reduced values also failed, many of them were unique bugs
12:06:09 <exarkun> Hypothesis (for Python) has a case database where it will remember failing cases and an API for selecting specific cases (same idea in each case, one data driven and the other code driven).
12:06:35 <jared-w> something like that would be pretty easy to extend over quickcheck or hedgehog actually
12:06:49 <shapr> I think test-framework can do that, but I'm not sure
12:07:24 <shapr> I know one of the meta-testing libs could grab the failing (seed,size) from quickcheck and use that to regenerate the failing input
12:08:29 * hackage hslua-aeson 0.3.0.2 - Allow aeson data types to be used with lua.  http://hackage.haskell.org/package/hslua-aeson-0.3.0.2 (tarleb)
12:12:36 <dmwit> orion: My read of design A is that it would do an extra request to gmail to decide whether there was a next page or not. So creating the pager actually causes two requests to gmail.
12:12:59 <dmwit> orion: Whereas with design B you only do one request up front, and then the user can decide whether they care if there's another page to look at and whether to incur the cost of a second request.
12:13:10 <dmwit> orion: So point #2 is my distinguisher between A and B.
12:13:19 <Welkin> doesn't gmail makes thousands of requests?
12:13:42 <Welkin> it's an example of a bloated, poorly designed app
12:14:26 <jared-w> No reason to pile shit on top of shit if you can help it, though :)
12:18:06 <dmwit> orion: (By the way, there's no need to ask twice, and doing so won't change my probability of answering you or my timing.)
12:18:08 <exarkun> world would be a better place if google engineers were restricted to hardware and networks 5 years out of date
12:19:25 <jared-w> world would be a better place if modern hardware, networks, and protocols weren't so expensive and monopolized in much of the first world and outright unaccessable in a lot of the rest of the world :)
12:21:44 <monochrom> The web would be more efficient if web "designers" were restricted to the OLPC laptop.
12:22:22 <hc> haha, true
12:23:00 <dminuoso> jared-w: It's quite amazing. If you look at post-QC crypto, some of the most promising contenders to make the better place have been... patented.
12:24:18 <monochrom> I mean, the only reason I block ads is because some ads are pointless Flash/gif that take 100% CPU time. This is hostile to even the most classy laptops if you're one of the most classy take-laptop-to-Starbucks people.
12:24:38 <Welkin> also, no one wants to see ads
12:25:04 <MarcelineVQ> the only reason I block ads is that time is all you have
12:25:11 <dminuoso> monochrom: You could also look at it differently: Why do you visit garbage websites in the first place? It's almost as if you download shitty software and then complain about all the poor algorithms and solutions the developers employed. :P
12:25:22 <johnw> is this still relevant to Haskell?
12:25:28 <monochrom> Oops.
12:25:35 <Welkin> yes
12:25:37 <Welkin> haskell against ads
12:25:42 <johnw> I don't have non-Haskell-chatter blocking enabled
12:43:49 <butterthebuddha> I can't actually quite map using fst after zipping though :/
12:44:02 <butterthebuddha> I will lose the last element of the list in the case I don't filter anything
12:44:33 <butterthebuddha> (johnw)
12:44:50 <butterthebuddha> Unless I'm being daft
12:45:03 <Welkin> or a punk?
12:45:28 <butterthebuddha> Or both?
12:45:38 <cocreature> butterthebuddha: how would you like to filter the last element? should it just always be included?
12:45:58 <butterthebuddha> I suppose I could just always include it
12:46:00 <monochrom> butterthebuddha: Show a concrete example of what you mean?
12:46:42 <cocreature> if you’re filtering based on the neighbor than dropping either the last or the first element doesn’t seem unreasonable but the right way to handle this depends on your application
12:48:15 <butterthebuddha> monochrom: I'm taking a string, transforming it to a list of all adjacent pairs (i.e. "xyz" -> ["xy", "yz"] for eg.)
12:48:40 <butterthebuddha> but I want to get rid of adjacent pairs like "xx", "xy"
12:49:02 <dmwit> What makes "xx" and "xy" similar?
12:49:05 <butterthebuddha> Or, the first element in such a pair
12:49:19 <butterthebuddha> where the first pair has the same characters, and the first character of the second pair is also that character
12:50:17 <monochrom> How does adjacent pair happen? By starting with "xxyz"?
12:50:34 <butterthebuddha> Well, "xxxyz"
12:50:58 <dmwit> I'm hecking confused.
12:51:13 <dmwit> Your input/output pairs don't some coherent to me.
12:51:20 <dminuoso> butterthebuddha: Didn't ski give you the answer already?
12:51:27 <monochrom> I think you need to explain like you're doing TDD.  List 5 interesting pairs of inputs and correct answers.
12:52:01 <dminuoso> > (zip `ap` tail) "xxyz"
12:52:03 <lambdabot>  [('x','x'),('x','y'),('y','z')]
12:57:35 <dmwit> Specifically: I can't reconcile ("xyz" -> ["xy","yz"]) with ("xxyz" does not result in a list that has "xx", "xy" in it).
12:58:07 <dmwit> I mean I can, but every reconciliation has higher Kolmogorov complexity than I believe is intended.
13:17:43 <jle`> butterthebuddha: you want to take a string, transform it to a list of all adjacent pairs, and then get rid of all adjacent pairs?
13:17:56 <jle`> sounds like just makeAdjacentPairsAndGetRidOfThem _ = []
13:18:18 <dmwit> Pfft, slowpoke. I was confused way before you were.
13:20:02 <jle`> sounds to me like "i want to decompose an integer into all its factors, and then get rid of all the factors in the list", heh
13:20:17 <jle`> maybe there was a typo
13:45:49 <dminuoso> Mmmm. ... `catchIO` (\_ -> die' verbosity notFound)
13:46:11 <dminuoso> Or rather some: ... `catchIO` (\_ -> return [])
13:46:19 <dminuoso> This looks like a bad idea
14:08:29 * hackage alex-tools 0.3.1 - A set of functions for a common use case of Alex.  http://hackage.haskell.org/package/alex-tools-0.3.1 (IavorDiatchki)
14:13:01 <Nitroghez> https://tinyurl.com/ya79dnx5
14:16:29 * hackage primitive-indexed 0.1.0.0 -   http://hackage.haskell.org/package/primitive-indexed-0.1.0.0 (andrewthad)
14:24:27 <soupladler> Hey, does anybody know of an offline reference for haskell? Something that I can feed into vim?
14:24:42 <soupladler> I'm used to being about to press K over a symbol
14:24:56 <soupladler> then getting the reference directly
14:28:46 <amx> I found something that queries Hoogle when you press K
14:29:47 <philippD> plus you can host hoogle locally and have it index your own stuff
14:29:50 <amx> https://github.com/Twinside/vim-hoogle    not sure if that helps
14:30:23 <soupladler> That's probably great, actually
14:30:37 <amx> (from: https://sillybytes.net/2016/08/vim-haskell_11.html )
14:31:50 <philippD> I found this episode of haskell cast pretty informative on this topic http://www.haskellcast.com/episode/012-neil-mitchell-on-development-tools
14:33:01 <soupladler> Also, is there any special trick to using cabal?
14:33:09 <soupladler> I've been typing 'cabal install x'
14:33:13 <soupladler> and usually it fails
14:36:44 <aweinstock> is there a way to get (runFunPtr :: forall a. GHC.Ptr.FunPtr a -> a) with the correct semantics, or is the monomorphization enforced by `foreign import ccall "dynamic"` inevitable?
14:38:29 <philippD> soupladler: tl;dr: try using stack instead of installing stuff globaly through cabal https://docs.haskellstack.org/en/stable/README/
14:39:05 <sclv> Or use a cabal sandbox
14:39:11 <sclv> Or use new-build
14:39:40 <sclv> And some things just fail because they’re not maintained
14:40:19 <sclv> https://www.haskell.org/cabal/users-guide/nix-local-build-overview.html
14:40:25 <philippD> sclv: In my opinion stack is the most intuitive way for beginners. I haven't looked at new-build though
14:40:38 <amx> soupladler: FWIW, new-build works really well if you just try to build your own project.
14:40:49 <mitchellsalad__> is there a way of telling cabal new-build to use the global package database? (for example when dependencies are provided by nix)
14:41:11 <sclv> The advantage of new-build is that you don’t have to learn a new tool
14:41:17 <sclv> Just a modified workflow
14:41:22 <soupladler> Hmm, OK. Cabal is the vanilla tool, right?
14:41:30 <sclv> mitchellsalad__:  not really
14:41:45 <soupladler> I kinda prefer to learn the most mainstream thing if possible.
14:42:09 <mitchellsalad__> sclv: How's nix+cabal meant to work once cabal old-build goes away, then?
14:42:15 <sclv> For actual integration with nix the standard build is still the typical workflow
14:42:37 <mitchellsalad__> That's unfortunate as old-build has no backpack support
14:42:48 <sclv> A bunch of people like elvish are looking to fix things for new-build with nix
14:43:00 <sclv> Its just not there yet
14:43:16 <sclv> soupladler: yes, cabal is “vanilla”
14:43:22 <mitchellsalad__> Gotcha :)
14:43:31 <sclv> although both tools are widely used
14:43:46 <sclv> So neither is “exotic” either
14:44:02 <EvanR> the tool being cabal-install right
14:44:09 <sclv> yes
14:44:16 <EvanR> that and stack both use cabal the build system
14:44:25 <sclv> yes.
14:44:51 <sclv> I just thought i’d explain it as simply as possible
14:45:09 <sclv> Omitting details to not overwhelm beginners
14:45:16 * EvanR ruins everything
14:45:21 <sclv> Lol
14:45:24 <soupladler> :)
14:45:45 <monochrom> stack is intuitive if you phrase everything as a "project".
14:46:29 <monochrom> It becomes an unintuitive just-memorize-it magic spell if you don't have a "project" and therefore you have to fake it by a "global project".
14:47:45 <monochrom> Oh it is also unintuitive when and when not it suddenly downloads one more copy of GHC.
14:49:31 <soupladler> To be honest I'm at the level where I feel like I'm fumbling my way through fog when I'm doing Haskell. I've done a bunch of C and C-derrived languages, so I'm kinda used to imagining what the machine is doing
14:49:58 <soupladler> So I'm trying to keep everything else as simple as possible
14:50:02 <monochrom> Yes, with Haskell you have to imagine what the math is doing instead.
14:50:05 <jle`> yeah, it's good to detach yourself from the idea of a machine when working with haskell
14:50:10 <jle`> it'll only confuse you more
14:50:37 <soupladler> Yeah, that's what interested me. I'm not much of a mathematician, so I thought it would be nice to learn a mathsy language while I'm learning maths
14:50:38 <EvanR> you still have the same surface as in C, there is an executable, statically linked, and a runtime is linked
14:50:41 <dminuoso> In a funny way its what programming languages were designed to do in the first place. Folks write C or C++ because they dont want to think what the machine does.
14:51:17 <EvanR> yes in some sense C isnt about the real machine
14:52:01 <monochrom> I am teaching my students to come up with recursive code by attempting the induction proof first.
14:52:27 <monochrom> That's right, you write the proof even before you have code.  The proof will help you discover the code.
14:53:07 <koala_man> which other languages cause experienced programmers to struggle to do simple things? Prolog is even less C-like than Haskell, and I had a lot of fun trying to wrap my brain around it
14:53:35 <soupladler> I think hardware description languages are interesting for this
14:53:47 <sm> APL
14:53:48 <EvanR> brainfuck
14:53:49 <ystael> koala_man: J
14:53:51 <soupladler> I mean, I'm not sure if they're exactly programming language
14:53:58 <dminuoso> EvanR: I found brainfuck surprisingly easy.
14:54:03 <ystael> (a descendant of APL cited by sm)
14:54:03 <EvanR> malbolge
14:54:11 <dminuoso> And malbolge is not turing complete :<
14:54:24 <monochrom> Because the biggest hurdle is you don't trust the induction hypothesis, therefore you micromanage instead of just letting the recursive call do the job for you.  With the proof, you write down the induction hypothesis carefully, so you trust the recursive call now.
14:54:28 <EvanR> good
14:54:42 <srk> koala_man: this, but then I've realized the importance of tail recursion and accumulators :)
14:56:40 <koala_man> I should try J or APL then. Brainfuck is mostly just tedious
15:02:23 <ZeuPiark> bye
15:18:15 <phz_> argh, damn you stack
15:23:49 <typo_> I wonder if ConstraintKinds can be used to define a datatype such as (,) which can be used to pair Constraints together.
15:24:05 <phz_> typo_: sure
15:24:29 <phz_> you can go with data Pair (a :: *) (b :: *)
15:24:43 <phz_> a :: k / b :: q
15:24:54 <phz_> but that’d be PolyKinds though
15:27:29 <glguy> typo_: Like: type Both (a :: Constraint) (b :: Constraint) = (a,b) ?
15:31:58 <typo_> ok, so if (,) has Kind * -> * -> * then its a datatype rather than a type, as required, but it needs its arguments to have Kind Constraint rather than * to be used as a Constraint. Maybe there is a way to make it work using Dict?
15:32:39 <jle`> yeah you can just write a Dict c -> Dict d -> Dict (c, d)
15:32:41 <jle`> as a function
15:32:51 <jle`> no need for a data type really
15:33:43 <jle`> you could make an "curred" dict type i suppose
15:33:51 <jle`> data Dict2 c d = (c, d) => Dict2 c d
15:33:56 <jle`> *curried
15:34:11 <jle`> * data Dict2 c d = (c, d) => Dict2
15:38:31 <glguy> typo_: I don't know what different you have in mind between type and datatype, but with the ConstraintKinds extension (,) gets magic overloading so you can use it at kind * -> * -> *, or Constraint -> Constraint -> Constraint
15:38:38 <glguy> difference*
15:39:42 <typo_> the idea was to apply this "magic" to a synonym
15:39:44 <glguy> (I suppose it has the magic overloading even without the extension)
15:40:38 <glguy> What was the idea?
15:42:43 <jle`> and with DataKinds you can even use it as a kind k -> k -> (k, k)
15:42:55 <jle`> er, k -> j -> (k, j)   :)
15:43:51 <glguy> Though to get that to work you have to use the similarly named type '(,)
15:44:32 <typo_> to make a datatype to use as a Constraint which could distribute an argument over its values, so that Constraints for values of kind * -> * could be combined
15:44:35 <jle`> oh hm, i guess you can't use it without that?
15:45:21 <jle`> typo_: what do you mean to use a datatype as a constraint?
15:45:27 <glguy> values don't have kinds
15:46:16 <glguy> Do you just mean something like: type C f = (Read1 f, Show1 f) ?
15:46:18 <typo_> as in a Functor Constraint as opposed to e.g. Ord
15:47:07 <glguy> type C f = (Functor f, Applicative f)
15:47:09 <jle`> hm, that doesn't quite explain what you mean by 'using a datatype as a constraint'
15:47:38 <glguy> typo_: Can you show an example of what you'd want to be able to write. I don't understand how you're using some of these terms
15:56:08 <typo_> well using (a::Constraint,b::Constraint) to the left of => is ok, but ((PairF Ord Eq) a) =>  does not work
15:57:51 <jle`> ah yes that does not sound like a data type
15:58:08 <jle`> there are a couple of ways to do something similar
15:58:21 <jle`> one is using a type family, and the other is using a dummy typeclass
15:58:26 <glguy> type PairF c1 c2 a = (c1 a, c2 a)
15:58:38 <jle`> *type synonym :)
15:58:43 <glguy> but with the right kind signature
15:59:59 <glguy> With ConstraintKinds, PolyKinds, and KindSignatures you can write:  type PairF (c1 :: k -> Constraint) (c2 :: k -> Constraint) (a :: k) = (c1 a, c2 a)
16:00:15 <glguy> If you just want it to work for types with kind (* -> *), you don't need poly kinds
16:00:28 <typo_> yes, c1 :: * -> Constraint not * -> *
16:01:48 <glguy> f :: PairF Ord Eq a => a -> Bool; f x = x < x
16:04:53 <typo_> ok, so a datatype is completely out, it must be the type synonym of (,)
16:06:54 <typo_> fine. thanks
16:15:15 <crestfallen> people keep telling me to take a break from textbooks and start a project (my programmer friends) . What do you think about this idea ?  .... :
16:15:57 <fishythefish> sounds like a good idea
16:16:13 <Tuplanolla> The only thing I know about you is that message, so I'm going with "definitely", crestfallen.
16:17:12 <crestfallen> Tuplanolla: thanks, I was aka crucify_me and received your kind assitance . thanks fishythefish so its this:
16:17:41 <crestfallen> preface: I'm sick of textbooks. they suck
16:18:36 <fishythefish> textbooks can be good and useful, but if you only read them and never do exercises or play with code, it's easy to convince yourself you know the fundamentals and then suddenly find yourself in over your head in something way too advanced
16:20:26 <crestfallen> I was thinking of doing various math exercises in haskell, and figuring out a way to relate some "exemplary" math problems to how category theory ties them together. Part of the goal would be to have it as an educational device, to teach myself and others basic category theory and haskell.
16:20:59 <crestfallen> Like for example:
16:21:14 <fishythefish> category theory in the context of haskell's type system is not the same as doing value-level computations
16:21:43 <crestfallen> please rephrase
16:22:29 <fishythefish> e.g. a math exercise might be to solve a quadratic, but just because it's math doesn't mean it has anything to do with category theory as we usually discuss it in the context of haskell
16:23:07 <Tuplanolla> If you would enjoy number theory with a bit of Haskell on the side, try Project Euler, crestfallen.
16:23:19 <fishythefish> +1, was gonna recommend project euler
16:23:48 <glguy> Though very quickly with Project Euler you'll be spending more time on the number theory than on the Haskell
16:24:26 <crestfallen> right, yes it wouldn't necessarily need to be math, but anything exemplary that could illustrate how cat theory works. project euler is tough I tried some in ruby way back. but..
16:24:42 <fishythefish> crestfallen: why are you so keen to do category theory?
16:24:58 <glguy> It's probably best to forget about category theory and just learn how to write programs in Haskell, if you want to learn Haskell
16:25:03 <fishythefish> with all due respect, the last time we talked, you seemed confused about the euclidean algorithm, so I'm not sure CT is the right thing to study for you
16:25:14 <crestfallen> idk it keeps coming up. I realize it doesn't map to haskell seamlessly
16:25:41 <fishythefish> it keeps coming up because this channel has plenty of nerds with the right background for it
16:25:47 <fishythefish> you don't need it to write haskell
16:25:56 <crestfallen> extended euclidean algorithm. well, I know what it does, and I really enjoyed that process when we did the evaluations
16:26:04 <geekosaur> haskell is a nice place to play with ct concepts
16:26:13 <geekosaur> that doesn;t mean you need to know ct to use haskell
16:26:26 <crestfallen> word
16:26:47 <crestfallen> I don't know, I'm just having a hell of a time getting through books. I stopped enjoying it.
16:26:48 <fishythefish> moreover, if you don't have a strong background in either subject, trying to learn both of them together is just gonna be extra painful
16:27:02 <fishythefish> crestfallen: don't make your goal to get through a book as quickly as possible
16:27:06 <geekosaur> in fact I;d argue the opposite because you need pretty good ct chops and pretty good haskell chops, because ct doesn't map *that* seamlessly
16:27:06 <fishythefish> make your goal to understand what was in it
16:29:13 <crestfallen> geekosaur: I wrote above that it doesn't map seamlessly. that is just what a friend told me.
16:31:24 <crestfallen> I watched a cool video on how relations between objects become geometric . It was on entitlement of white males, non-white males , non-male non-whites etc. the geometry of the relations keep changing with various implications, etc. I really like the idea there.
16:32:31 <Tuplanolla> She has a full lecture series on YouTube, crestfallen.
16:32:50 <crestfallen> so if I could understand that and write something basic for educational purposes. yeah Tuplanolla she is cool
16:32:54 <Tuplanolla> Just watching it won't do much, though. You need to work it to understand it.
16:34:16 <crestfallen> so if you have a function, if you add variety to the functionality of it, you are going to change its position in a spatial sense as it relates to other functions.
16:35:29 <crestfallen> you add subtle functionality to it, say by changing the type of numerics it can use, that can be expressed in a category or switch to a different cat.
16:37:06 <crestfallen> is that a load of crap or is that partially true?
16:38:08 <Tuplanolla> If by spatial you mean metric structure, then no, category theory has very little of that.
16:38:21 <c_wraith> jle`, typo in your lens article.. you talk about split and join being inverses at one point, but I think you meant split and unsplit.
16:40:11 <fishythefish> you can probably represent a metric space as a category by enriching over the reals or something
16:40:12 <crestfallen> reading about metric structure...music...astrology...
16:40:29 <jle`> c_wraith: ah, thanks :)
16:40:51 <jle`> yeah i actually originally used join but switched to unsplit because of possible confusion with Control.Monad.join
16:41:03 <crestfallen> but as I understand it , it would be relational like in an abstract algebra sense.
16:41:08 <c_wraith> jle`, quite enjoying the article. nice work, again. :)
16:41:45 <Tuplanolla> Sure, you can put almost anything into a category, but that doesn't mean category theory is about that thing.
16:41:54 <fishythefish> certainly
16:42:17 <jle`> c_wraith: thanks! really appreciate it :)
16:42:33 <fishythefish> I understood the question not as "is CT a useful tool for studying this?" but rather "can we express these relations in a category if I really want?"
16:43:12 <jle`> good to know that it's also enjoyable for people who already understand lenses too, haha :)
16:44:37 <c_wraith> jle`, yeah. I never saw the connection with the existential representation before. It's fun to think about.
16:45:37 <crestfallen> but that thing goes in and out of focus based on what is being emphasized at the moment ; is that correct?
16:46:14 <fishythefish> crestfallen: er, if you're studying that thing, it should probably remain in focus
16:46:49 <fishythefish> this is all getting pretty hand-wavey though
16:47:31 <crestfallen> well, I just thought it would be a cool project to think about.
16:49:07 <crestfallen> back to earth, I get caught up with writing out the evaluation order, because frankly I can't imagine understanding haskell without two things: understanding evaluation order and type unification.
16:54:30 <fishythefish> crestfallen: a good way to get started on those two things is to write haskell
16:54:55 <crestfallen> but to form a question, obviously fishythe*fish and company gets the eval order stuff, but my sense is that some people consider this overly theoretical
16:55:38 <crestfallen> correct? :)
16:55:50 <fishythefish> I think you might be overestimating how much anyone here understands the evaluation order of actual code without looking at the results of compilation
16:56:13 <typo_> the problem is in trying to use -> as the product rather than (,)
17:00:37 <crestfallen> hmm, but in (our basic) recursive functions, there is a concise way to write out the order that is instructive, say the eval_extendEu example. I feel its equivalent to understanding what the function does. fishythefish
17:01:03 <crestfallen> in value anyway
17:02:13 <crestfallen> but your comment re: overestimation is actually encouraging ! :)
17:02:19 <fishythefish> crestfallen: okay, so you're potentially asking about two different things. Are you simply trying to understand what output a function produces for a given input, or are you trying to understand how the compiler chooses an evaluation order?
17:03:00 <fishythefish> the former tends to be easier than the latter
17:03:43 <typo_> at least, PairF requires 3 parameters, so using it with Kind * -> Constraint wont work
17:04:27 <fishythefish> crestfallen: I'd also posit that trying to understand recursion by evaluating all the way down to the base case and then going back up is somewhat self-defeating
17:04:43 <crestfallen> hmm
17:05:20 <fishythefish> recursion should feel like an inductive proof - the base case(s) must work, and then in the recursive/inductive step(s), you trust that your recursive call/inductive hypothesis worked and proceed from there
17:08:06 <crestfallen> but in light of pattern matching, the exEuclid problem is something that makes a lot of sense to me, to see it in its entirety the way you wrote it out last week. because the improves the instinct for pattern matching.
17:08:23 <crestfallen> it*
17:09:18 <fishythefish> crestfallen: pattern matching is orthogonal to recursion, though
17:09:41 <fishythefish> you can study pattern matching just as well in a non-recursive context, and even in the recursive case, you only need to look at one level of the recursion at a time
17:10:20 <fishythefish> most of the levels of the recursion were exactly the same thing but with different numbers
17:10:25 <crestfallen> right, in fact you can only see it in a single level.
17:11:08 <crestfallen> orthogonal to recursion ....
17:11:55 <fishythefish> crestfallen: in the programmer jargon sense, meaning unrelated/independent essentially
17:12:29 <fishythefish> (well, the independent/orthogonal connection comes from linear algebra, I guess)
17:16:26 <crestfallen> I see, that is helpful.. still, my understanding is the patt. matching comes in handy, because in recursion you are relying on substitution, I guess
17:17:06 <crestfallen> so if its not just a number but a longer expression, you have to keep track
17:18:04 <fishythefish> pattern matching is useful because you want to do case analysis on a value, recursion or no recursion
17:18:17 <fishythefish> e.g. implement the `head` function
17:19:14 <fishythefish> (well, perhaps `listToMaybe` is better, so we can stay total)
17:22:29 <crestfallen> > f = head . (filter fst)
17:22:30 <lambdabot>  <hint>:1:3: error:
17:22:30 <lambdabot>      parse error on input ‘=’
17:22:30 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
17:22:59 <crestfallen> @let f = head . (filter fst)
17:23:00 <lambdabot>  Defined.
17:23:07 <crestfallen> :t f
17:23:08 <lambdabot> error:
17:23:08 <lambdabot>     Ambiguous occurrence ‘f’
17:23:08 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.f’,
17:23:19 <crestfallen> @let ff = head . (filter fst)
17:23:20 <lambdabot>  Defined.
17:23:23 <crestfallen> :t ff
17:23:24 <lambdabot> [(Bool, b)] -> (Bool, b)
17:23:25 <fishythefish> crestfallen: you can message lambdabot directly
17:23:34 <fishythefish> or use a ghci session
17:24:44 <typo_> seems to work ok with distributing arguments over -> synonyms using a datatype. now getting an error trying to instantiate the class synonym..
17:25:38 <typo_> https://lpaste.net/4682752059135492096
17:26:15 <crestfallen> sorry I did . I only wanted to say I went through the unification and saw how it is resolved. and to ask if it is a valuable exercise.
17:26:36 <jle`> typo_: do you mean that you want a version of PairF2 that can be partially applied?
17:26:59 <fishythefish> crestfallen: I don't think it's particularly valuable for you, no
17:27:25 <typo_> yes
17:27:28 <crestfallen> ok thanks kindly fishythefish
17:27:45 <typo_> though the paste makes do without
17:27:54 <fishythefish> crestfallen: type unification generally is not something you need to understand right now, nor is it something you should devote time to at this stage
17:28:09 <fishythefish> ghci will happily tell you the type of something, so there's no need to work out every type by hand
17:28:25 <fishythefish> moreover, it's easy enough to work out the type of your function without going through a formal unification procedure, and that intuition is much more valuable
17:30:50 <crestfallen> thanks , a member told me there's no learning path, only a terrain. I liked that, so I just sample things when I tire of the book...
17:31:56 <fishythefish> there's no single path, but whatever path you take should probably be continuous
17:32:59 <crestfallen> thanks for the help
17:34:33 <fishythefish> crestfallen: seriously, just write some code. Start a personal project, do project Euler, do exercises from your book, whatever, but just try writing some Haskell
17:35:59 <fishythefish> if you only read theory, then you're probably (a) gonna get bored because you don't do anything with it and (b) fail to understand it, so you won't have the prerequisite knowledge for moving onto more interesting things
17:37:48 <crestfallen> thanks, I have some ocd re: what's under the hood. I look at functions as machines that are in motion. "first this happens here, then this happens over here." I try to visualize what is happening to my disservice. will do!
17:40:23 <fishythefish> crestfallen: it'll take some getting used to, but I recommend weaning yourself off that mentality. Operational semantics have their uses, but you'll frequently want to think in terms of denotation semantics
17:40:39 <fishythefish> denotational*
17:42:13 <crestfallen> homework for tonight. many thanks
17:47:59 <fishythefish> jle`: maybe someone already pointed this out, but the implementation of the prism API in terms of match/inject just seems to be preview twice
17:48:07 <pounce> Ok, so I am just trying haskell out for the first time so please bear with me. I want to make a function `reduceList` that turns [1,2,3] into 123. and I think I could do it like this: `reduceList xs = foldr (func) 0 reverse xs` where `func a b = (b * 10) + a`. Is there anyway I can write func inside reducelist instead of binding it?
17:48:33 <fishythefish> pounce: you could use a lambda if you really don't want to give it a name
17:48:39 <fishythefish> but i'm curious why you don't want to give it a binding
17:48:54 <pounce> I want to learn stuff like lambdas ^W^
17:49:06 <fishythefish> foldr (\a b -> (b * 10) + a) ...
17:49:19 <jle`> fishythefish: ah, thanks :) no, hasn't been pointed out yet
17:50:04 <pounce> thank you :)
17:51:51 <typo_> ok, this works; https://lpaste.net/153315244247089152
17:52:00 <pounce> oh, could I use `where` to?
17:52:43 <fishythefish> pounce: yup, or `let/in`
17:53:23 <typo_> Ended up not using the partially applied pair function, still not sure how it could be written
17:54:58 <typo_> any comment on this Lens definition?
17:57:13 <jle`> typo_: do you just want a version of PairF2 that can be partially applied?
17:58:05 <typo_> that would be good
17:58:30 <typo_> its not clear the advantage of replacing classes with tuples of Empty instances, but its something to do with '$> ()'
17:59:04 <typo_> otherwise the approach has no motivation
17:59:19 <jle`> some people have done something similar using dummy typeclasses
17:59:47 <jle`> class (c a, d a) => PairF2 c d a
17:59:59 <dmwit> This is an awful lot of indirection. Do I want to know what it's all about?
18:00:02 <jle`> instance (c a, d a) => PairF2 c d a       -- -XUndecidableInstances
18:00:45 <jle`> that's a version of type PairF2 c d a = (c a, d a) that can be partially applied
18:00:56 <jle`> *where c and d give constraints
18:02:44 <typo_> thats a different kind of empty instance...
18:03:22 <typo_> thanks though.
18:07:19 <typo_> dmwit: the idea was to parametrise functions. e.g. for Get, (f a -> (a,f a)), this becomes (f a -> (a,a->f a->f a)) and then (f a -> (a,i,f a)) along with the constraint Empty (\a -> (f a -> (i -> a -> f a -> f a))) and all the trouble is with these kinds of lambda types...
18:08:36 <typo_> and then supposing that all classes could have their functions given extra parameters in this way
18:10:02 <typo_> recovering the original version as instances where i = () and noting that Empty (x -> ()) is trivial to define.
18:13:56 <typo_> well, various versions of Empty with different numbers of parameters, and associated partially applied tuples and such
18:19:08 <typo_> containers with shape can be built up from cons over parametrised empty containers, and parametrised lenses can be used to give default comonadic traversal. because this notion of extending functions of common classes with an additional argument occurs repeatedly, the abstract approach for "extending" classes in this way is motivated.
18:19:53 <typo_> the paste gives an example of what this looks like
18:22:32 <typo_> * Empty (\f a -> (f a -> (i -> a -> f a -> f a)))
18:23:11 <typo_> ... no thats just wrong
18:23:12 <typo_> sorry
18:23:29 <typo_> maybe some other time
18:29:27 <dmwit> I feel like #haskell inhabitants are confusing me more these last few days than usual.
18:29:47 <dmwit> Perhaps my brain is getting old and less nimble.
18:30:47 <Clint> o_o
18:38:28 <Welkin> this is odd
18:38:33 <Welkin> `clang: error: unknown argument: '-no-pie'`
18:38:46 <Welkin> I get this when installing dependencies for an old servant project I am upgrading
18:38:51 <Welkin> using cabal new-build
18:54:51 <glguy> Welkin: on mac?
18:54:52 <pounce> Welkin: give clang some of your pie
18:55:53 <glguy> $ fgrep pie ~/Tools/ghc-8.4.3/lib/ghc-8.4.3/settings
18:55:53 <glguy>  ("C compiler supports -no-pie", "NO"),
18:56:00 <glguy> You might need to update that file
18:58:00 <Welkin> yeah I just changed that setting
18:58:04 <Welkin> but it seems wrong
18:58:08 <Welkin> I have never had to do that before
18:58:52 <glguy> Welkin: something changed in a recent xcode update
18:59:17 <Welkin> I don't even have xcode, only the command-line tools
18:59:21 <Welkin> which I have not updated in a long time
19:04:22 <enterprisey> Why would I want to use the \& escape character?
19:05:28 <glguy> enterprisey: To disambiguate some escapes
19:05:48 <glguy> > "\x60\&b"
19:05:48 <pavonia> > "\1234" == "\123\&4"
19:05:50 <lambdabot>  "`b"
19:05:50 <lambdabot>  False
19:05:56 <glguy> > "\x60b"
19:05:58 <lambdabot>  "\1547"
19:06:10 <enterprisey> oh that's interesting, thanks!
19:06:17 <xcmw> Is there something like arrow that works for k -> k -> * instead of just * -> * -> *?
19:07:15 <Cale> xcmw: with what methods?
19:07:49 <Cale> :k Category
19:07:50 <lambdabot> (k -> k -> *) -> Constraint
19:08:37 <Cale> You might be looking for some subclass of Category, of course, it can't include 'arr'
19:08:40 <Cale> :t arr
19:08:41 <lambdabot> Arrow a => (b -> c) -> a b c
19:10:08 <xcmw> Cale: What I'm working with is a category. It is arrowish but not really an arrow.
19:11:28 <Cale> https://hackage.haskell.org/package/categories-1.0.7/docs/Control-Category-Monoidal.html
19:11:38 <Cale> This is pretty close
19:13:22 <Cale> (you have to go up the superclass hierarchy a bit to really find everything you probably expect...)
19:13:40 <xcmw> I don't think it is a bifunctor it is profunctorish
19:17:56 <Cale> xcmw: hmm, yeah, I'm not sure what to suggest
19:18:33 <Cale> It would be possible to define a generalised profunctor class of course... that might be hanging around somewhere
19:18:37 <xcmw> Cale: https://lpaste.net/3934615584200720384
19:19:17 <Welkin> what the heck is `Control.Monad.IO.Unlift.MonadUnliftIO`?
19:20:01 <Cale> xcmw: The p there looks like a bifunctor
19:20:25 <xcmw> The p is a bifunctor
19:21:57 <xcmw> Well bifunctorish
19:22:05 <Cale> https://hackage.haskell.org/package/categories-1.0.7/docs/Control-Categorical-Bifunctor.html#t:Bifunctor -- so if you look at this, and you pick all the categories (r,s,t) to be the same one (what you're calling arr)
19:22:10 <Welkin> damn it, more wacky typeclasses from snoyberg
19:22:13 <Cale> and you pick p = q
19:22:22 <Welkin> now what do I need to update
19:22:56 <Cale> Welkin: It's basically another version of the same thing as MonadBaseControl / MonadTransControl
19:23:30 <Cale> (and has similar reasons to be avoided, imo)
19:24:29 <xcmw> Cale: I will look at those. Thank you.
19:25:18 <Welkin> Cale: well this is a 2 year old codebase that is using persistent
19:25:24 <Welkin> I should switch it over to postgresql simple
19:25:27 <Welkin> but for now...
19:25:32 <glguy> Welkin: were you using conduit on that one?
19:25:40 <Welkin> yes, for file uploads
19:25:55 <glguy> then your upper bound might not be tight enough on that library
19:26:06 <glguy> that's the place that's pulling in this new unliftio stuff
19:26:08 <Welkin> I had no upper bounds
19:26:12 <glguy> there you go :)
19:26:13 <Welkin> I was previously using stack
19:26:17 <Welkin> my cabal file has no versions
19:26:20 <glguy> oops
19:26:28 <Welkin> so I just ran cabal new-build and let it figure it out
19:27:17 <enterprisey> Is there a way to search for the first occurrence of either of two characters without regex? Or is regex the way to go
19:27:26 <MarcelineVQ> Welkin: if needed you can tell stack to generate a versioned cabal file using   stack sdist --pvp-bounds both
19:27:43 <Welkin> well, I wanted to update the coebase
19:27:47 <Welkin> since it has not been for 2 years
19:28:25 <rotaerk> enterprisey, what's the context? what are you doing?
19:28:35 <enterprisey> rotaerk: parsing Python's line endings
19:28:35 <Cale> enterprisey: In what type of thing? A list?
19:28:42 <Cale> A Text?
19:28:43 <enterprisey> Python allows \n, \r\n, or \r
19:28:45 <enterprisey> in any order
19:28:52 <enterprisey> I have a ByteString, because I haven't decoded it yet
19:29:08 <rotaerk> are you using a parser combinator library to do this?
19:29:10 <enterprisey> however, I'm allowed to decode it to UTF-8 only until the second linebreak
19:29:12 <enterprisey> I am, in fact
19:29:25 <enterprisey> actually yeah I should probably just use that
19:29:34 <enterprisey> I'm not sure how to make it sufficiently lazy, though
19:29:39 <xcmw> Cale: ISimpleFunc and IComplexFunc are the types that are arrowish. https://lpaste.net/650475146326310912
19:29:47 <xcmw> It is in idris
19:30:07 <Cale> break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)  will split a ByteString at the first point which satisfies the condition
19:30:12 <enterprisey> for example, if I'm looking for a regex that can appear in the first two lines only, how can I make the library avoid going through the whole thing
19:30:25 <enterprisey> I guess that's the root problem
19:30:27 <Cale> So you can just test if the Word8 is one of the two bytes you're looking for
19:30:50 <enterprisey> Cale: yeah, that would work, but I would have to do at worst four successive calls of that
19:31:03 <enterprisey> and wrapped in control flow, which would be messy
19:31:24 <Welkin> okay it looks like conduit < 1.3 doesn't have MonadUnliftIO
19:31:34 <Cale> I'd probably want to decode the thing to Text first...
19:31:53 <enterprisey> well, I have no idea how to decode it
19:32:04 <enterprisey> because the end goal of this part of the program is the decoding of the file
19:32:23 <enterprisey> so, if I had something like "decode only the first two lines", I'd use that
19:32:42 <enterprisey> "the decoding of the file" <- I meant "encoding", sorry
19:33:37 <enterprisey> I could probably use takeWhile a bunch
19:37:35 <Cale> enterprisey: Does it require the line endings to be consistent at least?
19:37:41 <enterprisey> sadly, no
19:37:44 <Cale> haha
19:37:50 <enterprisey> one line can end with \r, and the next with \r\n
19:37:54 <enterprisey> ain't Python something
19:38:01 <enterprisey> (at least, that's how CPython rolls)
19:38:09 <Cale> It's almost at the point where I'd prefer just using Attoparsec or something
19:38:23 <enterprisey> yeah
19:38:39 <enterprisey> my current solution is use break interleaved with running my megaparsec parser
19:38:52 <enterprisey> this is how newline translation happens in CPython, for reference
19:38:53 <enterprisey> https://github.com/python/cpython/blob/master/Parser/tokenizer.c#L701-L740
19:39:11 <Cale> glorious
19:39:16 <enterprisey> indeed
19:39:46 <enterprisey> the famous "no encodings differ from ASCII on how they map newline"
19:40:14 <enterprisey> which I suppose *is* true, if only because they say in the spec "we only allow encodings that map newline the same way ascii does"
19:44:53 <Welkin> this never seems to end
19:44:57 <dmwit> enterprisey: I would bet they also need another property (though perhaps they don't realize it): only encodings that do *not* produce newline-like bytes in the encodings of other characters.
19:45:15 <enterprisey> hahaha, true
19:45:16 <Welkin> no matter how many packages I restrict under a certain version, this unliftIO stuff seems to come up again
19:45:47 <glguy> Welkin: How about setting "--constraint=whateverpackage<0"
19:45:59 <glguy> and then you'll see which packages fail to install given your exclusion of that package
19:46:02 <Welkin> and my application fails to build because there is no instance ofr MonadUnliftIO for MaybeT
19:46:03 <glguy> and you can narrow things down?
19:47:02 <Welkin> oh
19:47:18 <Welkin> I wonder if I can explicitly tell it to not use the unlift-io-core package
19:47:28 <Welkin> can I do that?
19:47:34 <glguy> You can set impossible constraints on it
19:47:36 <Welkin> unliftio-core < 0
19:47:38 <glguy> like <0 and >0
19:47:41 <Welkin> lol
19:47:44 <Welkin> let me try
19:48:23 <Welkin> nope :(
19:48:46 * hackage summoner 1.0.3 - Tool for creating completely configured production Haskell projects.  http://hackage.haskell.org/package/summoner-1.0.3 (shersh)
19:49:48 <Welkin> all these persistent packages are probably messing it up
19:50:56 <Welkin> oh my god
19:51:04 <Welkin> wtf snoyberg?
19:51:12 <Welkin> this stupid package is like a disease
19:51:19 <rotaerk> what package
19:51:21 <Welkin> it's infected tons of the dependencies
19:51:24 <Welkin> liftio-core
19:51:47 <Welkin> anything from snoyberg has it now, it seems
19:51:57 <Welkin> and it's breaking my build
19:52:09 <enterprisey> you mean unliftio-core?
19:52:32 <Welkin> yes
19:54:11 <rotaerk> Welkin, why is it demanding that there be an instance of MonadUnliftIO for MaybeT?
19:54:22 <rotaerk> why are you using a MaybeT as a MonadUnliftIO
19:54:24 <Welkin> because of the way I have some code written that uses MaybteT
19:54:31 <Welkin> I am not
19:54:41 <Welkin> I wrote this code 2 years ago before monadUnliftIO existed
19:54:53 <Welkin> and I don't want to deal with this dumb typeclass
19:56:21 <Welkin> compiling again
19:57:17 <Welkin> finally, success
19:58:00 <Welkin> also, it was MaybeT IO, specifically
20:02:02 <EvanR> MonadUnliftIO
20:03:27 <EvanR> the transformer saga continues
20:04:00 <Welkin> no, it ends here
20:11:06 <jle`> Welkin: the fpcomplete ecosystem has basically moved from MonadBaseControl to MonadUnliftIO
20:11:15 <jle`> honestly i don't really miss MonadBaseControl
20:11:35 <jle`> it's probably an overall benefit...but it does break almost all code, heh
20:11:43 <Welkin> jle`: I don't care about either of them
20:13:24 <jle`> yes, was just explaining the story about why all of the code starting breaking
20:14:15 <jle`> MonadBaseControl has been effectively deprecated
20:14:28 <Welkin> I don't even know the purpose of either
20:18:01 <jle`> the basic problem they both solve is generalizing functions like forkIO :: IO a -> IO ThreadId, to other things beside IO
20:18:22 <jle`> a more generic forkIO, catch/handle, etc.
20:19:50 <jle`> it's overall understandably a very silly/minor thing to wreck the entire ecosystem over
20:20:49 <enterprisey> what's the best way to express the regex .* in a parser combinator?
20:20:56 <Cale> many anyChar
20:21:05 <enterprisey> any way to do it with primitives?
20:21:21 <Cale> hm?
20:21:36 <enterprisey> like tokens, takeWhileP, takeWhile1P, takeP
20:21:44 <Cale> which parsing library, sorry
20:21:48 <enterprisey> ie the Megaparsec "fast" parsers
20:22:58 <enterprisey> context: I want to parse #.*coding, where # and "coding" are terminal
20:23:09 <enterprisey> I could use notFollowedBy I guess
20:23:38 <Cale> takeWhileP (const True)
20:24:09 <Cale> takeWhileP Nothing (const True)
20:24:15 <Cale> this might already have a name
20:25:08 <Cale> Though I'm not sure takeWhileP is actually nondeterministic, in which case that doesn't really do what you want, because it just consumes everything with no potential for backtracking
20:25:12 <enterprisey> yeah
20:25:23 <enterprisey> I think backtracking automatically makes something slow, so many anyChar is the way to go here
20:25:39 <enterprisey> or if I were being extra semantic, skipManyTill anyChar actualParser
20:26:54 * dmwit cooks up a file real quick that reads `#codincodincodincodincodincodincodin...`
20:28:46 * byorgey imagines recursive fish
20:29:04 <pavonia> enterprisey: Are you sure you actually want .* there? Perhaps with a more specific parser you could avoid unnecessary backtracking
20:29:37 <enterprisey> in the original regex, it's .*?
20:29:58 <enterprisey> and I guess no newlines, which are matched by anyChar so I shouldn't be using it anyway
20:30:27 <pavonia> Do you have a link to the original grammar?
20:30:49 <enterprisey> ^[ \t\v]*#.*?coding[:=][ \t]*([-_.a-zA-Z0-9]+)
20:30:54 <enterprisey> ^ full regex
20:33:45 <jle`> it's probably better to not try to translate a regex literally to parser combinators
20:34:06 <dmwit> `.*?`?
20:34:26 <geekosaur> non-greedy
20:34:42 <geekosaur> .* matches the longest possible string, .*? the shortest
20:35:09 <dmwit> How could it possibly matter? The `[:=]` is a synchronization point.
20:35:20 <geekosaur> (perl / pcre)
20:35:38 <geekosaur> no, if there are two, .* will sync to the last, .*? to the first
20:35:54 <dmwit> But the rest of the regex can't match a colon or an equals sign.
20:36:04 <geekosaur> but the .* can match both
20:36:22 <geekosaur> it will sync eventually, yes, but .* will cause much more backtracking
20:36:24 <dmwit> Right. But if it matches an early one, the rest of the regex will not match the rest of the string.
20:36:29 <dmwit> oh
20:36:55 <dmwit> Ick. This is what you get for using non-regular expressions. =P
20:37:59 <enterprisey> jle`: I realized that too late, lol
20:38:06 <geekosaur> although, actually, if thre are two, .*? will cause more backtracking here. because it'll hit the second and realize it has to backtrack over the .*?
20:38:23 <geekosaur> so the longest munch is more correct in this case.
20:38:54 <geekosaur> althoguh arguably you want a more precise grammar anyway. this is not something regex handles well, really
20:42:08 <enterprisey> I've implemented it with skipManyTill (Megaparsec), using satisfy excluding newlines as the first arg and the rest of the regex as the second
21:08:35 * hackage warp-tls-uid 0.2.0.4 - set group and user id before running server  http://hackage.haskell.org/package/warp-tls-uid-0.2.0.4 (YoshikuniJujo)
22:03:13 <pounce> I'm really new to haskell. How do I get functions (like from Data.List) in scope?
22:04:13 <cocreature> pounce: import Data.List
22:05:05 <pounce> ty
22:12:03 <pounce> If I take the "primes" example from the front page, and put it in a file, it doesn't compile
22:12:12 <pounce> do I need to do something so multi-line statements like it do?
22:12:29 <cocreature> can you show us the error?
22:12:50 <pounce> `error: parse error on input ‘where'`
22:12:57 <pounce> on the second line of it
22:13:20 <cocreature> please show us the full error message and the code producing it in some pastebin
22:13:30 <pally> Hey guys.  there is something I can't seem to wrap my head around the following function definition that is different than the others I have seen.
22:13:51 <pally> abs2 :: [[Integer]] -> [[Integer]]
22:14:02 <pally> abs :: map (map abs)
22:14:10 <pally> oops
22:14:15 <pally> abs = map (map abs)
22:15:10 <pounce> https://gist.github.com/4e554c4c/0cd49789eb89c54e88f5c7d3229a6b28
22:15:49 <geekosaur> pally, it's the same as: abs x = map (map abs) x
22:15:50 <cocreature> pounce: remove the "let". let is not for defining top-level expressions
22:16:07 <cocreature> (ghci is a bit weird in this regard)
22:16:20 <geekosaur> only older versions, 8.0+ don;t need the let
22:16:50 <cocreature> right but "let" still works in newer versions so it’s still different from “regular” Haskell
22:17:04 <pounce> ah, also there seem to be some indentation rules I have to use. Can I read about these somewhere?
22:17:07 <pally> Hi geekosaur, I was just about to get to the part where it really got me confused, and your version is the one I am more familiar with
22:17:23 <pally> and what exactly is it that I am confused about with the first version? The missing parameter
22:17:49 <geekosaur> the precise meaning is:  abs = \x -> map (map abs) x
22:17:52 <pounce> for example, if I keep the expression as is, I get the error " parse error (possibly incorrect indentation or mismatched brackets)" on the definition of `filterPrime`, unless I move it onto one line
22:18:22 <jle`> pounce: can you show what you are typing?
22:18:47 <pally> geekosaur, your 'x', which matches the list of lists (i.e., [[Integer]]) parameter makes me more comfortable for me to read, as it makes more sense to me.
22:18:48 <jle`> ah, is it the gist?
22:18:53 <Welkin> look up eta reduction
22:18:57 <geekosaur> pally, basically it's a partial application. and since it agrees as such with the type signature, there's no problems
22:18:59 <cocreature> pounce: I don’t have a link ready to the formal definition but as a rule of thumb, indentation should increase for things that belong to a definition
22:19:11 <geekosaur> :t map (map abs)
22:19:12 <lambdabot> Num b => [[b]] -> [[b]]
22:19:23 <cocreature> pounce: so the rhs of filterPrime should be indented more than the lhs
22:19:44 <pounce> yep, it was done that way
22:19:46 <jle`> pally: yeah, the problem is that because you start a new line at the same indentnation as 'primes', the language thinks you are done with primes, and starting to define a new function or value
22:19:52 <jle`> * pounce
22:20:02 <Welkin> ponce?
22:20:09 <jle`> pounce: it's because you can provide more than one definition within the same 'let' block
22:20:11 <pally> geekosaur, you kinda knew what was I gonna ask you. :-)
22:20:50 <jle`> let def1 = 1234
22:20:53 <jle`>     def2 = 58345
22:20:59 <jle`>     def3 = "hello"
22:21:07 <jle`> "returning to the same level" is how you indicate that you're making a new definition
22:21:20 <jle`> and that you're done with your previous one
22:21:54 <jle`> so in the gist, the only modification you need to do is move the "where" a little bit to the right
22:22:11 <Welkin> > let a = 1 in let b = 2 in let c = 3 in [a, b, c]
22:22:13 <lambdabot>  [1,2,3]
22:22:18 <Welkin> it's basically that
22:22:19 <pounce> ok, but it was at a higher indentation level. (let me update the gist)
22:22:21 <jle`> oh and also you shouldn't be using the 'let' if it's a haskell file, and not a ghci session
22:22:42 <jle`> pounce: yes please :) it's pretty difficult to help without seeing what you are actually writing
22:22:55 <Welkin> `let ... in` is the expression
22:23:06 <Welkin> I see how that is ocnfusing for anyone not familiar with haskell
22:23:21 <Welkin> since let is used in many other languages to define variables
22:23:42 <pounce> https://gist.github.com/4e554c4c/0cd49789eb89c54e88f5c7d3229a6b28 :)
22:23:55 <jle`> pounce: same deal there
22:23:59 <cocreature> pounce: line 3 is still indented less than the lhs of filterPrime
22:24:07 <jle`> with the 'filterPrime' in line 2
22:24:10 <pounce> ooh, I see
22:24:17 <jle`> you return back to the level befor efilterPrime
22:24:22 <jle`> so you're signaling that you're done defining filterPrime
22:24:29 <Welkin> install an editor mode for haskell and let it take care of the indentation for you
22:24:40 <pounce> Is there one I can install for vim?
22:24:50 <Welkin> yes
22:25:25 <jle`> it's definitely confusing at first yes.  at this point i just basically imagine a vertical wall after my let's and where's and make sure not to return to that level until i'm done with a definition
22:25:45 <jle`> i think this guide is good? http://www.stephendiehl.com/posts/vim_2016.html
22:26:04 <jle`> i put together my setup before this guide was made so i didn't follow it myself, but i've heard good things about it
22:26:41 <Welkin> or use haskell-mode in emacs
22:26:49 <Welkin> you can use vim bindings in emacs if you wish
22:27:57 <pounce> D:
22:29:04 <pounce> I don't think my computer is powerful enough for emacs
22:29:29 <pally> geekosaur, When you say "the precise meaning is: abs = \x -> map (map abs) x" , do you you mean abs = map (map abs) is in fact a shorthand, or does Haskell need to deduce from the type signature?
22:29:50 <Welkin> pally: eta reduction. They have the same type
22:30:13 <Welkin> if you have a variable on the left and right side of an equal sign, you can remove them (if they are at the end of the expression)
22:31:26 <geekosaur> pally, one secret is that all functions mean that: "foo x = x + 1" is internally "foo = \x -> x + 1"
22:32:09 <pally> Hi Welkin, is eta reduction the same as eta conversion?  because I found the haskell wiki for eta conversion.
22:32:10 <Welkin> and functions are values
22:32:11 <dminuoso> Not bad, I managed to new-break cabal.
22:32:15 <Welkin> and all functions only have one input
22:32:20 <geekosaur> here, it knows the type of (map (map abs)); that partial application is the same as "\x -> map (map abs))". But it doesn't actually do that, because partial application is natural in Haskell
22:32:38 <Welkin> because there is no partial application in haskell
22:32:41 <dminuoso> pally: eta reduction is that direction specifically
22:32:44 <geekosaur> "foo x y = ..." is "foo = \x -> \y -> ..."
22:33:02 <dminuoso> pally: you can also eta extend by turning: `f = ...` into `f = \x -> ... x`
22:35:48 <cocreature> dminuoso: but can you also manage to new-unbreak it? :)
22:36:31 <pally> thanks guys.   These concepts will take some time to get used to.
22:36:41 <dminuoso> cocreature: Possibly, I kept the dist-newstyle/ directory.
22:43:27 <cocreature> dminuoso: keeping around dist-newstyle should be fine for the most part. ime you need to nuke it about as often as you need to use .stack-work
22:48:13 <saurabhn_> hello good folks, has anyone been kind enough to push a ghcjs + stack build for 8.2.x branch?
23:13:13 <pounce> Since lists are linked in haskell, there wouldn't be an efficient way to find an item in a sorted list, right?
23:14:44 <dminuoso> pounce: Correct.
23:15:32 <cocreature> it might be worth pointing out that we do have vectors as well, so while you can’t really do an efficient binary search on a list, you can totally use a vector and search that
23:16:40 <pounce> tbh I need an efficient primality test, not list searching.
23:18:34 <pounce> right now I'm doing `isPrime a = (takeWhile (<= a) (filter (>= a) primes)) /= []` which is disgusting any way you look at it
23:20:02 <dminuoso> pounce: You could use AKS?
23:20:31 <jle`> pounce: note that you shouldn't really be commparing to [] with lists
23:20:53 <jle`> but pattern matching instead :)
23:21:05 <jle`> or you can use a function that pattern matches for you, like 'null :: [a] -> Bool'
23:21:30 <cocreature> pounce: what’s your usecase for this? e.g. if you’re using this for crypto, most implementations go for a probabilistic test afaik
23:22:02 <pounce> cocreature: just solving a little programming puzzle and trying to make it less computationally terrible
23:22:23 <jle`> what is the scale of primes you are looking at?
23:22:28 <jle`> tens or thousands of digits?
23:22:59 <pounce> all under 1mil right now, so in other langs I'd use a sieve
23:23:12 <pounce> but I'm not quite sure how to do that in Haskell
23:23:44 <jle`> if 'primes' is your seive, then searching until you find a number higher than your number should be optimal
23:23:51 <jle`> if you're only doing it once
23:24:18 <pounce> nope, doing it ~n times ;(
23:24:28 <jle`> where n is...?
23:24:53 <pounce> I have to do it for 300 numbers rn, not sure if more
23:24:58 <jle`> yeah, if you're doing it once, a list is an optimal data structure because lists in haskell pretty much corresponds to how you'd use for loops and stuff in imperative languages
23:25:21 <jle`> pounce: ah, just n as in, some number. not n as in, a number related to largest prime or something
23:27:06 <jle`> real world use, you can probably use an efficient prime number checking library like http://hackage.haskell.org/package/arithmoi
23:27:40 <jle`> but if you want to do it from scratch using a seive, we have some nice data structures that are optimized for storing items and checking for membership
23:28:02 <pounce> I might have some other bottleneck too, lemme look
23:28:05 <jle`> like IntSet, which is optimized for ints
23:28:28 <jle`> if you know a maximum prime you will be needing to find, you can generate them using a list and store them in an IntSet for optimized membership testing
23:29:39 <pounce> huh, looks like I was confused about my bottleneck after all
23:30:11 <pounce> So the problem is I have to find a bunch of primes from a to b whose digits reversed were also prime
23:30:59 <pounce> and right now finding digits from a to b (which I do `takewhile (<=b) (filter (>=a) primes)`) is what's taking forever
23:31:45 <pounce> is IntSet in the standard library?
23:32:00 <cocreature>   it’s in the containers package
23:34:11 <jle`> IntSet won't help with the generation of the primes; it'll just help with the primality testing of multiple trials
23:34:20 <jle`> but it looks like you don't really want membership tests?
23:35:02 <jle`> if you want all the primes in a range then something similar to what you've done would make sense
23:35:29 <jle`> are you sure it's the prime generating that is the bottleneck, and not the checking of palindromeness?
23:36:23 <pounce> yeah, int reversal is p quick. It's mostly finding all of the primes up to that int that's the problem
23:39:27 <pounce> how would I call an IntSet method like `insert` without importing all the methods into the namespace?
23:39:57 <cocreature> "import qualified Data.IntSet as X" will make all identifiers from Data.Intset available under a X. prefix
23:40:36 <pounce> thanks ♥
23:42:02 <jle`> if all you need is to find all primes between an interval, then using Set here won't really do anything to help
23:42:14 <jle`> unless you rewrite your whole sieve algorithm in terms of Set
23:43:08 <jle`> also, be careful when making conclusions about what parts take up what time in your code; things work a bit backwards in haskell than they do in other languages
23:43:36 <pounce> jle`: well annoyingly I can't find an interval for the primes, because, if I have primes ranging from 7000-8000, I still have to check all primes from 1007-9997 because they can be reversed
23:44:04 <pounce> jle`: yeah, I've just been plugging stuff into ghci to see what takes up time
23:44:19 <jle`> oh ah i see, you need fast membership checking for primes outside the interval.
23:44:38 <pounce> yeah, that's one of the main issues
23:45:23 <pounce> I tried to speed it up by doing something like `let range = sectionSorted start end in ...` before my function to speed things up, but it gave me the wrong answer (albeit fast!)
23:46:10 <jle`> hm, okay, if you want to pre-cache your primality test
23:46:17 <jle`> once you define your list of primes, primes :: [Int]
23:46:43 <jle`> you can use primeSet = S.fromList (takeWhile (<=9999) primes)
23:47:12 <jle`> IntSet also has efficient partitioning between ranges
23:47:39 <jle`> at that point though, if you're working interactively, you'll want to force primeSet to actually be made and computed, instead of just "declared"
23:47:59 <jle`> so printing something like `S.size primeSet` and getting a number out of it will force ghci to actually compute primeSet and populate it with the primes you need
23:48:59 <jle`> this isn't a huge problem if you aren't doing things interactively, but if you're working interactively, it can be helpful to ensure nothing unexpected happens
23:50:02 <jle`> also you'll know exactly for sure what the cause of slowdown is :)
23:50:53 <jle`> once you have your primeSet, you can use the efficient "partition on an interval" function 'split', to make a new set `candidates` that only has primes from 7000 to 8000
23:51:03 <jle`> and then you can use S.filter to filter that candidates set based on your test :)
23:51:55 <pounce> jle`: when I'm doing the first part (IntSet.fromAscList) I'm getting ` Couldn't match type ‘Integer’ with ‘Int’` `Expected [IntSet.key] Actual type [Integer]`
23:52:23 <jle`> ah it looks like `primes` was inadvertently defined to be `[Integer]` instead of `[Int]`
23:52:44 <pounce> What's the difference?
23:52:50 <jle`> different types
23:52:54 <jle`> so they won't typecheck
23:53:05 <jle`> Integer is an unbounded integer ("bigint"), Int is just machine integer
23:53:33 <jle`> you can map the list with `fromIntegral` (which is Integer -> Int) to get the types to match
23:54:46 <pounce> ah, gotcha
23:55:00 <jle`> @let primes = filterPrime [2..] where filterPrime (p:xs) = p : filterPrime [x | x <- xs, x `mod` p /= 0]
23:55:01 <lambdabot>  Defined.
23:55:08 <jle`> although i'm not really sure how efficient that version is, or if it's optimal
23:55:39 <pounce> lol if you hover over it on the main page it says it isn't efficient
23:55:40 <jle`> @let primeSet = IS.fromAscList . takeWhile (<= 9999) . map fromIntegral $ primes
23:55:42 <lambdabot>  Defined.
23:55:49 <jle`> > IS.size primeSet
23:55:52 <lambdabot>  1229
23:55:59 <jle`> huh, i guess it's not that bad :)
23:56:06 <pounce> oh til of .
23:56:13 <pounce> what is the `$` for?
23:56:29 <jle`> it's (IS.fromAscList . takeWhile (<= 9999) . map fromIntegral) primes
23:56:43 <jle`> the $ is just a dummy user-defined operator with super low precedence
23:56:56 <jle`> it's useful as a hack for avoiding parentheses, heh
23:57:08 <pounce> lol
23:58:08 <pounce> oof yep it's taking a long time to generate
23:58:16 <jle`> what is your max bound?
23:58:24 <pounce> 1mil
23:58:37 <jle`> @let primeSet' = IS.fromAscList . takeWhile (<= 1000000) . map fromIntegral $ primes
23:58:38 <lambdabot>  Defined.
23:58:45 <jle`> > IS.size primeSet'
23:58:51 <lambdabot>  mueval-core: Time limit exceeded
23:58:56 <pounce> I chopped off a zero and it's good
