00:01:30 * hackage hw-dsv 0.2.1 - Unbelievably fast streaming DSV file parser  http://hackage.haskell.org/package/hw-dsv-0.2.1 (GeorgeWilson)
00:09:24 <kadal> test
00:09:55 <kadal> just wondered wether this channel still alive :D
00:12:45 <Ariakenom> acc
00:15:03 <dminuoso> Ariakenom: Can you elaborate on what you were trying to say regarding the kind variable?
00:15:47 <Ariakenom> I think $ has more general kinds than .
00:16:09 <dminuoso> Huh?
00:16:57 <dminuoso> Ariakenom: oh this is about levity polymorphism?
00:17:21 <Ariakenom> yes
00:17:48 <dminuoso> :t ($)
00:17:49 <lambdabot> (a -> b) -> a -> b
00:17:51 <dminuoso> Bargh what is this magic
00:17:58 <dminuoso> Shouldnt this be: ($) :: forall (r :: RuntimeRep) (a :: *) (b :: TYPE r). (a -> b) -> a -> b
00:18:37 <Ariakenom> I think there's some kind of hiding shenanigans
00:18:54 <dminuoso> GHC lying to me :(
00:19:06 <dminuoso> https://ghc.haskell.org/trac/ghc/ticket/11549
00:19:11 <dminuoso> So I guess I have to wait a year :(
00:23:38 <Ariakenom> dminuoso: for what? what's the problem?
00:41:17 <mniip> dminuoso, lambdabot is too old
00:42:07 <mniip> % :i ($)
00:42:08 <yahb> mniip: ($) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b -- Defined in `GHC.Base'; infixr 0 $
00:45:48 <tysonzero> Does anyone how to make backend specific filters in persistent that are prefix and not infix, e.g postgis `ST_Intersects(a, b)`?
00:50:04 <dminuoso> mniip: Ah actually that's because it uses :i rather than :t I guess?
00:50:16 <mniip> true
00:50:25 <mniip> can't seem to make ghc output the runtimereps in :t
00:53:35 <dminuoso> mniip: yeah check the issue I just linked :s
01:02:14 <mniip> hmm
01:02:21 <mniip> I guess type families aren't so introspective
01:03:57 <mniip> you can't have an (f x) pattern match in a type family without knowing the kind of x beforehand
01:04:39 <mniip> or maybe you can
01:10:02 <halogenandtoast> Howdy #haskell, have a question. Considering making a series of HaskellCasts to help beginners get started with Haskell. Trying to come up with a good list of starter videos to make and I was wondering if anyone here had any insight on which topics might be good to cover first.
01:11:04 <halogenandtoast> I feel like the target audience is people with little to no Haskell experience so as to make the community more acessible
01:11:19 <halogenandtoast> s/acessible/accessible/
01:13:54 <halogenandtoast> In no particular order, here are some ideas I had: https://gist.github.com/halogenandtoast/1d0c716d751504bd47f9d5cd4813f3cc
01:15:16 <Cale> Find stuff where you feel that what exists doesn't do a great job of introducing it.
01:15:24 <Cale> There's probably a lot of that
01:16:52 <halogenandtoast> Yeah, I feel like that's most things, but I haven't put my finger on exactly why. My learning style might be different than others though
01:17:25 <halogenandtoast> I frequently see the comments that we need beginner friendly introductions to many things
01:18:27 <[exa]> halogenandtoast: gloss and/or juicypixels
01:18:55 <[exa]> not that it would be very advanced but beginners love visualizations
01:19:26 <halogenandtoast> Yeah I think things like that, at the very least are fun and show different areas of what can be done
01:19:34 <halogenandtoast> I'm adding those to the list, thanks [exa]
01:19:41 <kuribas> there's Ihaskell, a IJupiter notebook for haskell.
01:20:10 <kuribas> I believe it supports diagrams as well.
01:20:32 <Ariakenom> halogenandtoast: That's a long enough list to include STM
01:21:10 <[exa]> halogenandtoast: I also kindof believe that fixpoints should have much more coverage/practice (esp. given there's mdo in every other FRP tutorial)
01:21:15 <halogenandtoast> Ariakenom: yeah, that means I'll have to learn STM as well.
01:21:38 <Cale> There's very little which could be said about monads which hasn't already been said elsewhere, and regardless, the best introduction to monads is just lots of introductions to other things anyway.
01:22:00 <[exa]> halogenandtoast: ContT might be interesting (it goes in similar direction)
01:22:33 <halogenandtoast> Cale: that list is just a high level overview of some thoughts, Monads might just be many videos covering different monads
01:24:45 <halogenandtoast> Thanks for the insight everyone, now to actually make some content.
01:25:05 <u-ou> what are you going to start with?
01:26:08 <halogenandtoast> u-ou: to be honest I'm still not sure, I was going to stare and think about my list for the next hour or so until I decided what was best
01:26:23 <halogenandtoast> to be honest I always felt like a good introduction to Haskell would start with type classes
01:27:04 <[exa]> halogenandtoast: good introduction to typeclasses should start with prolog
01:27:10 <Cale> halogenandtoast: Are you trying to be comprehensive, or cover things that people might not have seen elsewhere?
01:27:13 * [exa] hides
01:27:14 <quicksilver> different things work for different audiences.
01:27:25 <quicksilver> a good presentation starts with something which hooks your audience in
01:27:28 <u-ou> what have typeclasses to do with prolog?
01:27:36 <quicksilver> identify your audience and then decide how to grab their attention
01:27:58 <halogenandtoast> Cale: my goal is really to cover a wide range of topics so people could pick and choose, but at least let the first 10 or so videos maybe be more of a flow than the following ones.
01:28:22 <quicksilver> one audience might be hooked in by the promise of a programming language which has category theory underpinnings (that is a small group); another audience might be hooked in by the promise of a language which lets you produce complex graphics with only a few lines of code, ... etc
01:28:51 <dminuoso> u-ou: you can think of typeclasses with constraints as a simplified version of prolog
01:30:35 <halogenandtoast> quicksilver: the audience will probably have to go through the great filter (aka me) and since I don't know too much category theory, that filter is going to be present in the content I make.
01:31:00 <halogenandtoast> I've read the first chapter in a few books and that's about it.
01:31:14 <u-ou> what I would like is guides on writing larger programs, what to use when and why,
01:31:18 <halogenandtoast> category arrow isomorphism, these are words
01:33:32 <dstolfa> halogenandtoast: if you're going to teach some more advanced cat theory, please do consider including HoTT as well, as types can be interpreted as infinity-groupoids so it might help make a connection for other people
01:35:19 <halogenandtoast> dstolfa: I'll add it to my personal reading list. Category theory is probably a long ways out if ever.
01:35:44 <halogenandtoast> I haven't considered Category theory pivotal in my general usage of Haskell
01:36:01 <halogenandtoast> Parts of it make things more interesting and sometimes help unravel the underlying reasons for things.
01:36:10 <halogenandtoast> But I often don't need to understand them to make things work.
01:36:36 <dminuoso> u-ou: A classic example might be, where if you have `instance (Eq a) => Eq [a]` that's pretty much the equivalent of prolog `Eq([A]) :- Eq(A)`
01:36:45 <halogenandtoast> So my abilities to explain them are rather limited.
01:37:02 <dminuoso> Heck I wonder whether Edward even named (:-) as a hint to prolog
01:37:41 <halogenandtoast> dminuoso: whcih ekmett thing has (:-)
01:37:47 <dminuoso> halogenandtoast: https://hackage.haskell.org/package/constraints-0.10/docs/Data-Constraint.html
01:38:22 <dstolfa> halogenandtoast: i tend to agree with you that you don't have to know category theory in order to work with haskell
01:39:03 <dstolfa> halogenandtoast: i wonder, if this is for the beginner, if it might make sense to just present them as "effects" rather than monads and try to make a point that they can be thought of as an interface for effects
01:41:22 <dstolfa> dminuoso: (:-) looks like a smiley to be honest
01:41:44 <dminuoso> dstolfa: Haha, well without the parens of course. :)
01:41:49 <halogenandtoast> dstolfa: I'm sure I'd include some of those words to be honest my simplest perception of monad is to first just think of it as a typeclass with one important method (>>=) and then explain what the intent of the method is
01:42:05 <halogenandtoast> then show how that intent works with many different monads
01:42:12 <halogenandtoast> then work back to the monadic laws
01:42:19 <dstolfa> halogenandtoast: hmm, that might be good too yeah
01:42:26 <dminuoso> halogenandtoast: the "intent of the method"?
01:42:37 <halogenandtoast> to sequence operations with side effects
01:42:42 <dminuoso> halogenandtoast: Im curious, what is the "intent" of (>>=) other than its type and laws?
01:42:44 <dstolfa> halogenandtoast: the problem is that the more of category theory you know, the "simplest" explanation of a monad is with, well, primitives of category theory
01:42:51 <dstolfa> that you've built up, that is
01:43:18 <halogenandtoast> I mean a monad is just a monoid in the category of endofunctors
01:43:26 <dstolfa> halogenandtoast: monoidal category
01:43:28 <halogenandtoast> I forget if that phrase is forbidden here
01:43:29 * dstolfa flies away
01:43:55 <dminuoso> halogenandtoast: A monad is just an abstract lawful interface.
01:44:07 <dminuoso> That's the perspective Ive burned into my mind.
01:44:08 <dstolfa> dminuoso: it's just an adjunction with 2 natural transformations
01:44:14 <halogenandtoast> dminuoso: yes, but that definition is too abstract for beginners
01:44:20 <halogenandtoast> abstraction is often the enemy of understanding
01:44:34 <dminuoso> halogenandtoast: and sequencing side-effects is just a weird of telling a beginner "look you can do imperative things"
01:44:46 <dstolfa> halogenandtoast: i disagree. if you want to distill the essence of something and understand what its properties are in the general sense, you have to think in the abstract
01:45:01 <halogenandtoast> dstolfa: I think you have to works towards the abstract
01:45:09 <halogenandtoast> once you get there you understand
01:45:14 <dminuoso> halogenandtoast: any attempt to explain monad in concrete terms is bound to fail because people will cling to examples instead of zooming out and seeing the pattern
01:45:25 <halogenandtoast> but often starting with the abstract makes things too translucent
01:45:32 <dminuoso> basically you have to bombard them with 4 wildly different instances and show what they have in common
01:45:35 <dstolfa> halogenandtoast: sure, but sometimes you have no good intuition for what the "abstract" is, you just have to take it with the perspective of definitions that were given
01:46:39 <dstolfa> does it make sense to implement a monad in C++ and show them that first?
01:46:47 <halogenandtoast> dstolfa: no
01:46:49 <dstolfa> just to show the programming pattern
01:46:50 <dminuoso> halogenandtoast: I believe one of the cleaner routes of talk about Monad is to talk about some simpler abstract patterns first like Monoid
01:46:57 <halogenandtoast> to be honest, and I'm probably going to get flack for this
01:47:06 <halogenandtoast> but I don't see the utility of monads without the do syntax
01:47:17 <halogenandtoast> I mean I'll still use them without it
01:47:17 <dminuoso> halogenandtoast: and therein lies the problem already.
01:47:30 <halogenandtoast> but having a construct in the language helps a lot
01:47:38 <dminuoso> To me its things like >=> that truly capture the notion of monads :)
01:48:06 <dminuoso> just like how (.) can be seen as the most fundamental thing about functions
01:48:38 * dstolfa learned monads purely from mathematics, not haskell and therefore sees the do syntax as just syntactic sugar for a more concrete version of a join
01:48:58 * dysfun just reads do notation as 'and then'
01:49:40 <halogenandtoast> So for some back history here dminuoso and dstolfa I'm a recovering Ruby developer and before that PHP with some C, Java, and QBasic mixed in their somewhere.
01:49:49 <halogenandtoast> *there
01:50:58 <halogenandtoast> And along the way I found discussions of Category theory and Monads to be impenetrable, making Haskell hard for me to learn
01:51:02 <dminuoso> halogenandtoast: Monad is an abstract interface, dicated by `return` and `>>=`. These functions have no real meaning other than given by the monad laws.
01:51:04 <dminuoso> halogenandtoast: Monoid is an abstract interface, dicated by `mempty` and `<>`. These functions have no real meaning other than given by the monoid laws
01:51:15 <halogenandtoast> At some point I decided not to care that I didn't know what a Monad was and just started writing stuff
01:51:26 <dminuoso> Functor is an abstract interface, dicated by `fmap`. That function has no real meaning other than given by the functor laws.
01:51:29 <dminuoso> And so forth
01:51:29 <dysfun> halogenandtoast: best way
01:51:40 <dstolfa> dminuoso: remind me, is "mempty" the identity case for the operator <>?
01:51:49 * dstolfa always forgets the order in haskell
01:51:51 <cocreature> ah another day of people debating monad tutorials, I was starting to miss it
01:51:52 <dysfun> obviously once you learn monads, you will become incapable of explaining them in a way that can be understood
01:51:58 <earthy> dstolfa: it is.
01:52:08 <dstolfa> earthy: thanks
01:52:18 <earthy> dstolfa: a <> mempty == a
01:52:19 <dysfun> cocreature: what is the comonad instance of burrito, anyway?
01:52:23 <dstolfa> earthy: righto, thanks
01:52:27 <halogenandtoast> cocreature: in all fairness, I haven't actually said I'd touch Monads :p it was just on my list of topics to make a HaskellCast about
01:52:38 <halogenandtoast> but that's a possible list, not a definite list
01:53:08 <dstolfa> dysfun: there are many comonads of burritos!
01:53:17 <dysfun> of course there are
01:53:23 <halogenandtoast> but it's one of those painful things that if you want to make content to help people learn Haskell, asking them to go somewhere else for some of the content feels weird
01:53:38 * dysfun will be back later, seems to be buried under a stack of burritos
01:53:44 <cocreature> halogenandtoast: you might want to choose a different name, given that there is already a (not super active but also not dead afaik) podcast called Haskell Cast
01:54:00 * hackage HsYAML 0.1.1.1 - Pure Haskell YAML 1.2 parser  http://hackage.haskell.org/package/HsYAML-0.1.1.1 (HerbertValerioRiedel)
01:54:06 <halogenandtoast> cocreature: too late, I bought the haskellcasts.com domain
01:54:12 <dminuoso> halogenandtoast: I dont know about that. A lot of hooks have phrases like "Should the reader not be comfortable with subject X I highly recommend reading ABC"
01:54:22 <cocreature> you can still buy another domain :)
01:54:41 <halogenandtoast> dstolfa: I read a whitepaper that actually talked about whether or not burritos were truly monadic
01:54:44 <dstolfa> dminuoso: i think the problem stems from the fact that people don't want to read, as other languages don't require them to read books or papers on the background maths
01:54:57 <dstolfa> halogenandtoast: what does something being "monadic" mean?
01:55:07 <halogenandtoast> do burritos follow the monadic laws
01:55:12 <halogenandtoast> I'll see if I can find it
01:55:13 <dysfun> it means they're not understandable
01:55:27 <dstolfa> as in
01:55:29 <dstolfa> burrito as the monad?
01:55:32 <halogenandtoast> http://emorehouse.web.wesleyan.edu/silliness/burrito_monads.pdf
01:55:34 <dminuoso> dstolfa: I firmly believe that the refusal to actually *read* (whether its books or documentation) on things they use is one of the reasons webdev is so filled with shitty software.
01:55:38 <dysfun> and i certainly didn't understand monads after reading about how they were burritos
01:55:51 <dstolfa> a burrito of a burrito of a burrito can be reduced to a burrito of a burrito by removing the inner or the outer burrito, which can be reduced to a burrito by removing the final one?
01:56:11 <dstolfa> and a burrito can be made a burrito of a burrito by wrapping the inside or the outside into a burrito of a burrito and then reduced back to a burrito?
01:56:16 <halogenandtoast> for reference this paper doesn't aim to state that monads are like burritos, but whether or not burritos are monads
01:56:22 <dminuoso> tortilla endofunctor.
01:56:26 <dstolfa> i mean, assuming you can insert a tortilla under a tortilla, sure
01:56:29 <dstolfa> they do follow monadic laws
01:56:51 <dysfun> they have you unwrapping the first tortilla to put it in another
01:56:59 <halogenandtoast> The burrito monad is in fact strong.
01:57:35 <dstolfa> dysfun: but then it's not monadic
01:57:52 <dstolfa> dysfun: the universal property says that you don't get to unwrap first and then wrap twice, it says that you get to wrap the inner-most part
01:57:58 <dysfun> dstolfa: you don't have to tell me, it's almost like analogies break apart
01:57:59 <dstolfa> which assumes the ability to insert a tortilla under a tortilla
01:58:10 <dminuoso> When people say `X is strong with respect to XYZ` do they mean that X is a monad on a monoidal category equipped with a bifunctor XYZ, which has the required natural transformation?
01:58:13 <halogenandtoast> You might not have read the part that says
01:58:14 <halogenandtoast> Note that the tortilla endofunctor is, in general, not monoidal.
01:58:52 <dstolfa> dminuoso: in my experience, "strong" means different things to different people
01:59:25 <dysfun> "strong" immediately makes me think of strong profunctors
01:59:30 <dstolfa> dminuoso: the only modified i can think of in category theory that means the same to everyone is small and locally small
01:59:30 <dminuoso> dysfun: dont they all talk about tensorial strength?
01:59:33 <dstolfa> modifier*
01:59:52 <dysfun> dminuoso: ?
01:59:53 <dstolfa> and "co"
01:59:59 <dstolfa> as in, cocone, coalgebra, comonad, ...
02:00:24 <dminuoso> Oh wait. *functors* can have tensorial strength
02:00:25 <halogenandtoast> cocaine?
02:01:03 <dysfun> first you must implement caine
02:01:18 <halogenandtoast> Already done data Caine = MichaelCaine
02:01:34 <dstolfa> hang on, if a burrito is a monad of category food, what is its dual?
02:01:45 <dminuoso> A coburrito?
02:01:48 <dstolfa> surely we'd have to talk about food wrapping tortillas
02:02:01 <dminuoso> @let import Control.Comonad
02:02:03 <lambdabot>  Defined.
02:02:22 <dstolfa> we need an opposite category of food
02:02:23 <dstolfa> how does that work
02:02:28 <dysfun> it's easy, tortillas just cause localised disturbances at the quantum level and the new tortilla teleports through the outer one
02:02:51 <halogenandtoast> dstolfa: you have to watch the Taco Town skit
02:02:54 <halogenandtoast> to see the dual
02:02:55 <dminuoso> dysfun: well we need an opposite category Stf^Op
02:03:14 <dminuoso> Is that a category of stuff you throw up9?
02:03:17 <halogenandtoast> I believe it's either a pizza, crepe, or blueberry pancake
02:03:17 <dstolfa> can we think about it in the subcategory of mexican food?
02:03:25 <dysfun> dminuoso: hey if i can make you buy cquantum disturbances, i think we can do the opposite category
02:04:38 <halogenandtoast> Okay, need to stop computering so I can plan some videos no one is going to watch, thanks all for the feedback/insight.
02:05:01 <dysfun> halogenandtoast: you can use the quantum teleportation bit if you want ;)
02:05:14 * dysfun looks forward to seeing that animation
02:05:57 <dstolfa> halogenandtoast: can you please explain monads with burritos
02:06:31 <dysfun> dstolfa: phil freeman explained profunctors with burritos
02:06:38 <dstolfa> dysfun: link please
02:07:14 <dstolfa> can we please explain everything in category theory with burritos?
02:07:16 <dysfun> dstolfa: it's a long one i'm afraid https://www.youtube.com/watch?v=OJtGECfksds
02:08:24 <jesyspa> Has a Haskell+cooking combined workshop on monads and burritos been done yet?
02:08:58 <dminuoso> Okay thats it.. hunger preventing me from working.
02:09:13 <u-ou> what happens when you cook a monad?
02:09:42 <dminuoso> There is no natural transformation cook
02:09:46 <dstolfa> jesyspa: we should be able to explain much of the HoTT with burritos as well, in terms of different ways to wrap a tortilla around food and still form a burrito
02:09:49 <dminuoso> Although wait..
02:10:05 <dminuoso> Inside the category Stf there should be an endofunctor `cook`
02:10:33 <dminuoso> At the very least it should be able to act on Füd
02:10:37 <bahamas> hello. I'm seeing this error when running `stack build` https://lpaste.net/8878672555976687616 even though I have a "library" section in my cabal file. the section contains the stanza "exposed-modules: Hello"
02:10:51 <bahamas> s/error/warning/
02:11:30 <dminuoso> bahamas: can you show your cabal file?
02:12:08 <dysfun> u-ou: phil used cooking to explain profunctors
02:12:47 <u-ou> can you use functors to explain profunctors?
02:13:02 <bahamas> dminuoso: here it is https://lpaste.net/2207975560829730816
02:13:05 <u-ou> I know what the former is, but not the latter
02:13:28 <cocreature> bahamas: you forgot to depend on your library in your executable
02:13:33 <dysfun> u-ou: a profunctor is an extension of functor
02:13:37 <dstolfa> jesyspa: and in fact, if we think of universes and burrito fillings, where each universe adds something else, we can describe the pi type as a function of a burrito B depending on some filling x, so we can have PI (x : A) . B(x)
02:13:37 <jesyspa> u-ou: I got the feeling profunctors are "Things that are like Hom, but more general".
02:13:39 <cocreature> bahamas: also I would recommend to use different src dirs for the library and the executable
02:14:18 <dstolfa> s/universes and/universes as/
02:14:26 <jesyspa> dstolfa: Personally, I prefer my burritos to be sum types; having all fillings at once is just a little too much :)
02:14:36 <bahamas> cocreature: I'm following the haskell book and it didn't mention depending on the library. at least not yet
02:14:40 <bahamas> maybe that was intentional
02:14:47 <dysfun> u-ou: it's essentially a mashup between functors and contravariant functors
02:15:01 <dstolfa> jesyspa: see, we can keep going
02:15:14 <dstolfa> jesyspa: in fact, i think we can get as far as to make the analogy from HoTT to category theory with burritos alone
02:15:19 <cocreature> bahamas: I don’t know about the haskell book but if you are using things in your library (which you are apparently since you are probably importing Hello in your executable) then you need the dependency
02:15:21 <dysfun> u-ou: if you have a couple of hours, the link i pasted a few mins ago is very good
02:15:32 <cocreature> if you don’t use things in your library you don’t need the dependency
02:15:33 <u-ou> ahh
02:15:42 <bahamas> cocreature: that makes sense. thanks!
02:15:43 <dminuoso> bahamas: Also dont be afraid if for some reason you are straying off the book a bit. :)
02:15:59 <dstolfa> someone should make a subconference of lambdaconf or something where the entire purpose is to prepare talks that explain various abstract topics in maths with burritos
02:16:04 <cocreature> bahamas: if you had different src-dirs you would get an error about a missing module rather than the warning you are seeing right now
02:18:01 <jesyspa> dstolfa: The link to HoTT is obvious!  If you have two burritos and they are observably the same, you don't *want* to know what the difference in filling is.
02:18:45 <dstolfa> jesyspa: nor do you care how they're wrapped as long as it doesn't fall apart!
02:19:13 <dminuoso> Neat, Weirich has been announced for the Haskell eXchange in October :)
02:20:27 <jesyspa> dstolfa: And since they're all wrapped up, if you don't explicitly track which burrito is whose, you can't tell!
02:20:46 <dysfun> dminuoso: i predict talk about dependent types
02:20:55 <dminuoso> dysfun: I hope so. :)
02:21:58 <dstolfa> jesyspa: and similarly, if we have different ways to fold a burrito, you can think of the "thinkinf of how to fold a burrito" in the same sense, and you can think about thinking about folding a burrito, think about thinking about thinking about...., in fact, it forms an infinity-groupoid
02:22:23 <dstolfa> and you can talk about equivalence there
02:22:24 <dstolfa> in each one
02:24:23 <jesyspa> dstolfa: Hmm, yes, I think that would be the infinity-groupoid of Burrito-origami?
02:25:00 <dstolfa> jesyspa: it does sound so
03:06:00 * hackage jvm-binary 0.1.0 - A library for reading Java class-files  http://hackage.haskell.org/package/jvm-binary-0.1.0 (kalhauge)
03:20:03 <pally> > data PairOfThings a = Pair a a deriving (Show)
03:20:05 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
03:22:44 <quicksilver> @let data PairOfThings a = Pair a a deriving (Show)
03:22:45 <lambdabot>  Defined.
03:27:51 <pally> hi quicksilver
03:28:09 <mreh> is a sort that will produce results before all values have been compared?
03:28:20 <mreh> I suppose I could just filter for the minimum
03:29:04 <pally> > somePair = Pair 1 "a"
03:29:06 <lambdabot>  <hint>:1:10: error:
03:29:06 <lambdabot>      parse error on input ‘=’
03:29:06 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
03:29:36 <pally> > @let somePair = Pair 1 "a"
03:29:38 <lambdabot>  <hint>:1:1: error: parse error on input ‘@’
03:29:50 <pally> > let somePair = Pair 1 "a"
03:29:52 <lambdabot>  <no location info>: error:
03:29:52 <lambdabot>      not an expression: ‘let somePair = Pair 1 "a"’
03:30:08 <reactormonk> @let somePair = Pair 1 "a"
03:30:09 <lambdabot>  .L.hs:175:17: error:
03:30:09 <lambdabot>      • No instance for (Num [Char]) arising from the literal ‘1’
03:30:09 <lambdabot>      • In the first argument of ‘Pair’, namely ‘1’
03:30:57 <pally> reactormonk, yes, I specifically want to discuss this emiited error msg from the intention type parameter mismatch
03:31:10 <pally> type* mismatch
03:31:26 <pally> errr... intentional mismatch, I mean.
03:32:26 <cocreature> mreh: the sort function in Data.List will produce results lazily but if you just care about the minimum, using "minimum" directly will probably be more performant
03:32:27 <reactormonk> pally, your question?
03:33:16 <pally> reactormonk why did the compiling say "No instance for (Num [Char]) arising from the literal ?1?" instead of saying something about the type mismatch?
03:33:30 <reactormonk> > 1
03:33:30 <pally> compiler*
03:33:32 <lambdabot>  1
03:33:37 <mreh> cocreature, I think what I need is not really a strict sort
03:33:50 <reactormonk> pally, ghci does a few weird things along the way.
03:33:51 <cocreature> mreh: what do you need then?
03:33:52 <reactormonk> > :t 1
03:33:54 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
03:33:59 <reactormonk> @t 1
03:33:59 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
03:34:08 <reactormonk> @type 1
03:34:09 <lambdabot> Num p => p
03:34:29 <reactormonk> @let somePair = Pair (1 :: Int) "a"
03:34:30 <lambdabot>  .L.hs:175:28: error:
03:34:30 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘[Char]’
03:34:30 <lambdabot>      • In the second argument of ‘Pair’, namely ‘"a"’
03:34:33 <mreh> cocreature, minimum
03:34:38 <reactormonk> pally, that's what you were looking for?
03:34:54 <cocreature> mreh: then just use the "minimum" function :)
03:35:29 <mreh> cocreature, if I know what the absolute minimum could be, I could write my own that will terminate early
03:35:39 <pally> reactormonk, yea that's something I'd expect the compiler would say when there is a type mismatch
03:35:55 <mreh> rather than compare every element
03:36:26 <reactormonk> pally, well, there wasn't. The first one was Num p => p, not Int. So it expected the second one also to have a Num instance, which it didn't. So it told you there was no Num instance.
03:36:42 <reactormonk> @let somePair = Pair "a" 1
03:36:43 <lambdabot>  .L.hs:175:21: error:
03:36:43 <lambdabot>      • No instance for (Num [Char]) arising from the literal ‘1’
03:36:43 <lambdabot>      • In the second argument of ‘Pair’, namely ‘1’
03:37:35 <reactormonk> Because it would be a valid solution for the problem you gave the typechecker. Putting in `String` for `a` would not be a valid solution in any way. However, Num a => a is a vaild solution - except `String` doesn't have a Num instance.
03:39:26 <cocreature> mreh: sure if that’s something that applies to your application, go for it!
03:48:21 <pally> reactormonk is it true to say that from ghci's pov the literal 1 in `Pair 1 "a"` doesn't have a recognized type, and that all it knows is that it is a Num instance?
03:50:23 <Ariakenom> :t 1
03:50:25 <lambdabot> Num p => p
03:51:34 <pally> ah... nvm. I see
03:52:27 <pally> actually, p at this point is still polymorphic ("generic") right?
03:52:37 <Ariakenom> pally: yup. your statement sounds ok
03:52:55 <Ariakenom> The 1 has type p. And that type p has a Num isntance.
03:54:15 <pally> thanks my #haskell friends.
03:54:35 <quicksilver> "the 1 can take *any* type p, but will require that type p to have a Num instance"
04:02:14 <pally> in Haskell parlance I hear "<something> to have a Blah instance" alot.  vs in OOP parlance, we'd instead hear something "<something> to be an instance of a class"
04:02:22 <pally> just wanted to throw that  out there as well.
04:04:18 <reactormonk> pally, yeah, there's a reason for that distinction. The main difference is where the function code is stored - inside the object, or besides it.
04:08:13 <cocreature> pally: haskell’s type classes are more like interfaces in oop languages
04:09:23 <Ariakenom> Can you have maxBound as an interface constant in oop-lang?
04:10:30 * hackage derive 2.6.4 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.6.4 (ip1981)
04:11:31 <pally> Ariakenom, not that I know (at least not in Java)
04:11:59 <Ariakenom> > maxBound :: Int
04:12:01 <lambdabot>  9223372036854775807
04:13:24 <Ariakenom> :t \f g -> all (\x -> f x == g x) [minBound..maxBound]
04:13:25 <lambdabot> (Enum t, Bounded t, Eq a) => (t -> a) -> (t -> a) -> Bool
04:15:16 <Ariakenom> equality for functions from "bounded, enumerable arguments" to "results that have equality".
04:15:49 <pally> You knew I needed that explanation hah
04:15:56 <pally> Ariakenom, is 'all' a keyword?
04:16:07 <Ariakenom> :t all
04:16:08 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
04:16:09 <Ariakenom> no
04:16:39 <Ariakenom> eh, consider t=[]. (a -> Bool) -> [a] -> Bool
04:17:01 <Ariakenom> predicate -> list -> bool
04:18:20 <Ariakenom> all p xs = does all elements of xs satisfy p
04:31:03 <Tops2> What might be wrong if the html created by criterion shows blank space where the charts should be?
04:31:04 <pally> That is a very concise and cool way to determine predicate satisfiability for a domain of discourse (in this case, [minBound..maxBound])
04:33:50 <cocreature> Tops2: I’m just guessing here but maybe the js is being blocked?
04:34:06 <Ariakenom> > all even [2,4..99]
04:34:08 <lambdabot>  True
04:35:21 <pally> even 5
04:35:26 <pally> > even 5
04:35:28 <lambdabot>  False
04:36:02 <pally> Ariakenom, 'True'? wth happened there?
04:36:26 <Ariakenom> > [2,4..9]
04:36:28 <lambdabot>  [2,4,6,8]
04:37:11 <Ariakenom> > [2,4..19]
04:37:13 <lambdabot>  [2,4,6,8,10,12,14,16,18]
04:37:34 <pally> > [1, 1..10]
04:37:36 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:37:40 <maerwald> anyone using brittany? how annoying is it
04:38:06 <pally> okay, I guess I don't know how it works.
04:38:17 <quicksilver> I think it is a poor intuition to think of haskell classes as being like OOP interfaces either.
04:38:27 <quicksilver> they are, obviously "structurally" like them
04:38:32 <quicksilver> but it's still a bad intuition.
04:38:40 <reactormonk> ... but inherently more powerful
04:38:50 <maerwald> why? Java people seem to like haskell classes and use them for similar puproses
04:38:58 <maerwald> with success
04:39:01 <dminuoso> maerwald: because of contexts
04:39:06 <dminuoso> and you can have typeclasses without methods
04:39:16 <maerwald> I don't see the problem
04:39:55 <Ariakenom> pally: [first,second..last]. second-first becomes the step length. so 1-1=0 doesn't move
04:40:02 <maerwald> intuition is intuition, it's fuzzy and artistic, not a precise reflection of technical properties
04:40:04 <quicksilver> haskell typeclasses are fundamentlly a tool for overloading
04:40:10 <quicksilver> not for describing an abstract interface.
04:40:23 <quicksilver> in haskell it's more idiomatic to use a data type to describe an abstract interface.
04:40:30 <dminuoso> quicksilver: you could say that an interface *is* a tool for overloading too
04:40:34 <quicksilver> sure
04:40:37 <pally> Ariakenom, lol...I am such a fool :-(
04:40:42 <quicksilver> I didn't say otherwise :)
04:41:03 <Ariakenom> pally: haha. why so harsh?
04:41:12 <quicksilver> I just say that, insofar as OOP interface are often used as an abstraction tool, that is often not the right way to use a haskell typeclass.
04:41:29 <quicksilver> people do use haskell typeclasses in this way, which is fair enough
04:41:34 <quicksilver> but it's often not the best way in my view.
04:41:48 <maerwald> disagreeing on design patterns...
04:42:09 <pally> Ariakenom, b/c I just demonstrated it by mis-interpreting the list construct.
04:42:35 <cocreature> quicksilver: I agree that it’s not a great intuition but I think it’s a useful one for nudging people that confuse oop classes and haskell typeclasses in the right direction
04:43:51 <quicksilver> maerwald: many aspects of many programming languages are technically equivalent.
04:43:59 <quicksilver> perl regexps and C++ templates are turing complete
04:44:00 <Ariakenom> not really a fan of it myself. prefer start step and exclusive stop
04:44:18 <quicksilver> but it is not idiomatic (or wise, in my view) to write entire programs within the regexp or template systems.
04:44:30 <quicksilver> at some point, you have to talk about idiom or good design.
04:44:33 <maerwald> maerwald: what is idiomatic and what is not is not defined anywhere, it's opinion too
04:44:43 <quicksilver> absolutely
04:44:47 <quicksilver> everything I saw is my opinion.
04:44:49 <quicksilver> say.
04:45:18 <Ariakenom> went philosophical there for a moment quicksilver
04:45:28 <quicksilver> I think sharing opinions about how to write haskell programs is a valuable endeavour in this channel.
04:46:07 <maerwald> it's valid, but not really valuable imo
04:46:10 <hodapp> a lot of things are "not defined anywhere", yet still have tendencies beyond mere preference
04:46:12 <maerwald> it rarely leads to any conclusion
04:46:29 <maerwald> I don't like transformers, yet people still use them, so what
04:46:40 <dminuoso> A discussion need not end in a conclusion to be useful.
04:46:43 <maerwald> is it idiomatic or not? In don't know
04:46:57 <maerwald> dminuoso: yes and it's still not valuable
04:47:09 <dminuoso> maerwald: If you do not find it valuable, don't participate then.
04:47:24 <maerwald> don't tell me what to do :>
04:48:04 <dibblego> it is valuable though
04:48:30 <maerwald> dibblego: it's merely exchanging personal preferences, much like "I'm a vim user"
04:48:46 <dibblego> no
04:48:54 <dminuoso> It's about exchaging personal experiences, not preferences.
04:49:08 <dminuoso> About view points that can be argued.
04:49:10 <maerwald> if there is actual technical impact, then that can be exchanged
04:49:19 <maerwald> and that will be valuable
04:49:42 <maerwald> these discussions however are rarely connected to significant project experience
04:49:59 <dibblego> have better discussions then
04:50:02 <dibblego> Try it.
04:50:04 <hodapp> maerwald: what is significant project experience and what is not is not defined anywhere, it's opinion too
04:50:16 <maerwald> dibblego: sorry?
04:50:30 <dibblego> Better discussions, try having them, such that they are valuable.
04:50:39 <maerwald> I have no idea what that is supposed to mean
04:51:25 <maerwald> but we are approaching ad hominem land
04:51:50 <hodapp> also, try acknowledging that you need not approve of, understand, or be able to rigidly classify communications for them to have value
04:52:03 <maerwald> try not to tell me what to do
04:52:16 <hodapp> try not to act like a surly 15-year-old
04:52:32 <maerwald> thanks for ad hominem
04:53:22 <dibblego> that's not ad hominem
04:53:27 <dibblego> this is
04:53:33 <dibblego> since you are a surly 15 year old, you are not making any sense
04:54:06 <maerwald> can someone stop the aggressive tone here?
04:54:19 <dibblego> similarly, since you are a surly 15 year old, you are making a lot of sense
04:54:24 <dibblego> both of these are ad hominem arguments
04:55:00 * hackage docker-build-cacher 2.0.0 - Builds a services with docker and caches all of its intermediate stages  http://hackage.haskell.org/package/docker-build-cacher-2.0.0 (lorenzo)
04:55:02 <jchia_> Is there documentation on the changes from conduit-1.2 to conduit-1.3, e.g. some blog post? A lot seems to have changed.
04:55:08 <hodapp> "aggressive tone", like an aggressive insistence that communication you don't understand must be without value?
04:55:36 <maerwald> hodapp: you haven't read any of what I said carefully, sorry
04:55:44 <maerwald> and at this point, the discussion is over
04:55:56 <hodapp> maerwald: and that's an *actual* ad hominem
04:55:59 <hodapp> since now we're counting apparently
04:56:03 <maerwald> no, it isn't :)
04:56:11 <gonz_> maerwald:  None of the things said about you were particularly wrong, tbh
04:56:49 <reactormonk> jchia_, mostly deprecated things have finally been removed IIRC
04:57:15 <hodapp> maerwald: I accept your apology.
04:57:30 * hackage valor 0.0.0.1 - Simple general structured validation library  http://hackage.haskell.org/package/valor-0.0.0.1 (LukaHadziegric)
04:57:36 <maerwald> hodapp: there was none
04:57:45 <jchia_> reactormonk: Theres the move to use the new resourcet, with the attendant changes related to MonadUnliftIO. The MFunctor is gone, but I don't think that has to do with deprecation. I'm not sure what else. I'm trying to update my code to the new version.
04:58:24 <cocreature> jchia_: have you looked at the changelog?
04:58:51 <jchia_> cocreature: Where is it?
04:59:06 <cocreature> jchia_: it’s listed on the hackage page
04:59:12 <cocreature> or find it in the git repo
04:59:57 <jchia_> cocreature OK, I see it. I'll take a look
05:01:07 <maerwald> gonz_: if calling out people 15 year olds in case you disagree with them is what you consider a "better discussion", then ok :)
05:01:50 <gonz_> I'm pretty sure people who didn't even disagree with you thought you were acting like a child
05:02:23 <gonz_> I didn't even care about what you were discussing and still found almost everything you wrote annoying. Not because of the points you made, but how you made them.
05:02:49 <gonz_> Even starting with "14:39:54 <maerwald> disagreeing on design patterns..."
05:03:47 <maerwald> no idea what you read into that
05:04:24 <adjofun> Hello everyone! Can someone tell me, is affine lambda calculus stricter than typed lambda calculus?
05:06:34 <dstolfa> adjofun: could you clarify that question a little bit? what do you mean by "affine" here and what do you mean by "typed", do you mean simply typed, as in terms depending on types without any polymorphism?
05:07:28 <dstolfa> do you mean second order lambda calculus?
05:07:39 <adjofun> dstolfa: I guess, my question can be clarified like this: Is Rust type system stricter than Haskell's? =:)
05:08:22 <electrocat> what do you mean by 'stricter'
05:08:41 <adjofun> I am aware about the proposal to add linear (or affine) types to haskell, so I am curious
05:09:19 <dstolfa> rust's type system has affine types in the sense that you can use it at most once (but you don't HAVE to use them once). its type system also implements a kind of separation logic that asserts ownership and prevents aliasing + mutability
05:11:16 <Ariakenom> dstolfa: Does GHC technically have those capabilities?
05:11:17 <adjofun> electrocat: I think, "stricter" in current context means "has more definitions"
05:11:30 <dstolfa> Ariakenom: what capabilities?
05:11:58 <Ariakenom> linear types, separation logic
05:12:07 <Cale> adjofun: It's hard to compare, they both have infinitely many definitions, and they have different non-overlapping features...
05:12:16 <dstolfa> Ariakenom: i'm not aware of haskell having separation logic in its type system
05:12:22 <dstolfa> but definitely not linear types
05:12:30 <dstolfa> linear types means you HAVE to use it once. this is not the case in haskell
05:13:15 <adjofun> http://staff.mmcs.sfedu.ru/~ulysses/Talks/2018-linear-haskell/#1
05:14:56 <quicksilver> Ariakenom: the current/traditional GHC type system does not, no
05:15:00 <quicksilver> the proposal is a way to add some of it
05:15:30 * quicksilver studied separation logic many years ago, can't quite believe some of it might finally arrive in haskell
05:15:44 <Cale> adjofun: Yeah, there's a lot of work left to do to say how it might interact with everything else in Haskell
05:16:18 <Ariakenom> dstolfa: But I've heard you can encode linear types. Maybe here? http://functorial.com/Embedding-a-Full-Linear-Lambda-Calculus-in-Haskell/linearlam.pdf
05:16:20 <drets_> Is there a way to have default record, override the record field but apply some function to record field inside default record? :crazy: https://lpaste.net/2354377737386328064
05:16:22 <hpc> at some point once all this is implemented, i hope someone makes a fully automatic rust ffi
05:16:58 <hpc> once haskell has rust's type system, the types of rust values can be imported wholesale without having to have the programmer translate things (like the C ffi currently does)
05:17:32 <hpc> and things that don't use sufficiently advanced haskell features can be exported the same way
05:17:32 <dstolfa> hpc: that's not as easy as you might think. having similar properties in your type system doesn't mean that you can just get the FFI for free
05:17:46 <reactormonk> hpc, then rust is to haskell what java is to scala ^^
05:17:47 <hpc> yeah, there's still a lot more to it like rust getting an abi
05:18:12 <dstolfa> reactormonk: i wouldn't make that analogy. haskell is much nicer than rust
05:18:14 <cocreature> it’s also not sufficient to have a somewhat similar type system, you need to have exactly the same type system at the edge between the two languages
05:18:33 <adjofun> Cale: I advertised Haskell to my c++ colleague on the grounds of STM, and now I told him about linear types. He thinks that GCs are evil, but likes Haskel, so he is excited =:)
05:18:45 <dstolfa> adjofun: GCs are pretty evil
05:18:46 <hpc> dstolfa: rust is surprisingly similar to haskell
05:18:46 <reactormonk> dstolfa, rust offers different guarantees, and you pay a price for it.
05:19:02 <hpc> dstolfa: even down to how {;} works, it's basically do-notation
05:19:21 <hpc> with the caveat that a trailing ; means (>> return ())
05:19:30 <hpc> and the last expression is implicitly returned
05:19:35 <dstolfa> hpc: it is, and the optional type is similar to the maybe monad, but i still argue it's much dirtier because it doesn't expose async and the likes through a monadic interface :)
05:19:42 <Ariakenom> (linear types wont get rid of gc, in particular they dont guarantee usage in the presence of exceptions)
05:19:44 <hpc> that's true
05:20:14 <iron_houzi> Are there any tools for stepping through code evaluation as a visual aid for learning?
05:20:28 <maerwald> dstolfa: rust and haskell don't solve the same problem, it's not fair to compare them that way imo
05:20:36 <dstolfa> maerwald: i agree
05:20:44 <adjofun> so, what should I say to my colleague? Is Haskell more expressible than Rust, but still doesn't have linear types because reasons?
05:20:47 <dstolfa> maerwald: but then again, people compare languages all the time :P
05:20:54 <adjofun> Or is the question il-defined?
05:20:56 <adjofun> ill*
05:20:58 <Cale> I'm not sure I've ever had whatever problem it is that rust is aimed at solving.
05:20:59 <dstolfa> adjofun: it's ill defined IMO
05:21:21 <maerwald> Cale: sytems programming :> but then again their stdlib s*cks hard
05:21:28 <dstolfa> Cale: rust aims at solving the problem that thinking about aliasing and mutability at the same time is hard
05:21:31 <dstolfa> that's it
05:21:33 <dstolfa> and they use separation logic to back it up
05:21:47 <maerwald> I really prefer writing GTK guis in rust over haskell
05:21:48 <maerwald> a lot
05:22:09 <maerwald> C APIs are bad anyway, but mapping them to haskell often is really awful
05:22:12 <dstolfa> maerwald: i think my biggest gripe with rust is the use of "lifetimes" as a name
05:22:43 <cocreature> dstolfa: if that’s your biggest gripe then you must like rust a lot :)
05:22:49 <dstolfa> cocreature: i do like rust :)
05:22:58 <maerwald> the biggest problem is probably futures ;)
05:23:04 <maerwald> and how hard they are
05:23:48 <dstolfa> maerwald: i'm just going to say: polymorphic polyadic pi calculus for concurrency is love and life.
05:24:33 * dstolfa likes milner's and david turner's work on pi calculus due to it being concise and providing the ability to get rid of garbage collection and typecheck that no partial deadlocks exist
05:24:43 <reactormonk> iron_houzi, a few basic ones on lambda calculus, but because of the laziness, stepping isn't as simple as you think it would be.
05:25:08 <adjofun> dstolfa: most programmers still aren't sure that they need math, what are you talking about =:)
05:25:43 <hodapp> adjofun: shhhhh just don't call it math, you can sneak it past them
05:25:48 <dstolfa> ^
05:25:56 <dstolfa> i often call it "properties" and "guarantees"
05:26:07 <dstolfa> and when talking about category theory, i talk about galois connections
05:26:10 <dstolfa> and sets
05:26:13 <hodapp> like how my dad still thinks he can't program, but only if you call it "programming" because that gives him flashbacks of COBOL and punch cards from college
05:26:16 <iron_houzi> reactormonk: I understand then that stepping can be difficult to do during runtime like that .. it's just that my head hurts so bad from unnesting complex expressions ..
05:26:23 <adjofun> oh, THAT is what i am doing wrong then
05:26:51 <Cale> iron_houzi: what are you trying to understand?
05:27:31 <dstolfa> if you mention: "maths" to everyday programmers, you lose half of your audience right away. if you talk about group theory and algebra, maybe 1/10th of the room understands you, if you bring up category theory, you've got maybe 2 people in the room following you kind of. the moment you bring up HoTT you've lost everyone (probably)
05:27:36 <dstolfa> that's my experience anyway
05:28:01 <Cale> dstolfa: If you mention them all together, you end up with exactly the population of this IRC channel.
05:28:04 <dstolfa> the way to talk to programmers and systems people about maths is to give them an example problem and show how you can solve it on a very specific example and talk about it in terms of compiler magic
05:28:55 <dstolfa> Cale: :')
05:29:07 <iron_houzi> Cale: 2.3 parser combinators in http://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf .. how seq on p.6 combines item and result
05:29:41 <iron_houzi> Cale: sorry, bind and result I mean
05:30:24 <Cale> iron_houzi: Okay, so the best way to do that is not to inline the definition of bind (though you can do that, it's just going to make a mess that you'll have to carefully tidy up)
05:30:48 <iron_houzi> Cale: inline as in infix?
05:31:01 <Cale> As in replace bind with its definition
05:31:34 <iron_houzi> Cale: Ah, OK. This is the typical replacement evaluation technique I'm used to. Do you have a better suggestion?
05:31:38 <Cale> It's better to understand bind in isolation, and then use that understanding to understand what this parser means
05:34:18 <iron_houzi> Cale: Not sure exactly what you mean. I can parse the bind function I think. It just combines a normal Parser function (Parser a) with a function I call a "terminator" parser (a -> Parser b) .. is there more to it than that?
05:35:38 <Cale> i.e. this will be the parser which parses the initial portion of the input with p, getting some result x, and then parses whatever remains with q, getting some result y, and then produces (x,y) as its result
05:36:04 <Cale> and it does this in all possible ways (since p and q may produce many pairs of result and depleted input string)
05:36:48 <Cale> and of course, in each case, the depleted input from the combined parser is what's left over by q
05:37:31 <iron_houzi> Cale: Perhaps the devil is in the details here .. one thing that strikes me as odd is, why the type of bind isn't `Parser a -> (a -> Parser a) -> Parser a`. Also, something else I don't understand: Does `Parser (a, b)` mean a parser where the type value is a tuple of type a and type b?
05:37:58 <Cale> Well, because it's more general
05:38:06 <Cale> yes
05:38:20 <Cale> So, in this case, for example, we might have
05:38:25 <Cale> p :: Parser Integer
05:38:38 <Cale> q :: Parser Employee
05:38:43 <iron_houzi> OK
05:38:52 <Cale> and then  p `seq` q :: Parser (Integer, Employee)
05:39:44 <Cale> (it's sort of unfortunate that they happened to call this operation seq, since that's already something in Haskell, though I'm not sure about in 1996 when this was written)
05:40:06 <iron_houzi> Yeah, I just called it myseq in my code..
05:40:32 <dminuoso> Cale: Mild pedantry, its something in *GHC
05:40:51 <Cale> dminuoso: seq is specified in the Report
05:40:57 <dminuoso> Oh it is? Where?
05:41:27 <quicksilver> dminuoso: https://www.haskell.org/onlinereport/basic.html 6.2
05:41:31 <Cale> It's part of the Prelude
05:41:42 <dminuoso> Wow I apologize.
05:41:44 <quicksilver> or search for "force the evaluation of a value"
05:42:16 <quicksilver> some pre-98 versions of Haskell had it typeclass-bounded
05:42:36 <maerwald> anyone uses transformer-eff? The blog post introducing it looks interesting, but
05:42:58 <dminuoso> That's interesting, I remember Simon Marlow talking how carefully they avoided talking about execution order.
05:43:05 <dminuoso> So this is why `seq` is in the report but `pseq` is not
05:43:23 <Cale> I think it might have been Haskell 98 that introduced seq actually
05:43:50 <Cale> Yeah, it's not in the 1.4 prelude
05:44:02 <dminuoso> Cale: I guess its time to read the report beginning to end now.
05:44:07 <quicksilver> the subtleties of the difference between seq and pseq have occupied a lot of minds :(
05:44:08 <dminuoso> So this doesnt happen again =)
05:44:08 <Cale> oh, right, it is, but it's not quite the same thing
05:44:23 <Cale> class  Eval a  where
05:44:23 <Cale>     seq              :: a -> b -> b
05:44:23 <Cale>     strict           :: (a -> b) -> a -> b
05:44:23 <Cale>     strict f x       =  x `seq` f x
05:44:28 <Cale> :)
05:45:06 <Cale> It's just an ordinary type class method in 1.4, with no magic
05:45:16 <dminuoso> Its interesting to see `seq` in the Haskell report. What might the justification be?
05:45:28 <Cale> Well, it's something to be specified...
05:45:30 <dminuoso> Is it to guarantee that Haskell implementations give a way to control strictness?
05:45:50 <Cale> The Haskell report ought to report on what Haskell is
05:46:17 <quicksilver> dminuoso: yes, some times you get really terrible behaviour without the ability to control evaluation
05:46:20 <Cale> It's just unfortunate that it's way out of date and doesn't actually cover a lot of stuff any longer
05:46:21 <quicksilver> unfortunately(?)
05:47:36 <Cale> Really, most of the programmer-facing language features in GHC, it would be nice to have some sort of description of in the Report.
05:47:55 <Cale> Perhaps compartmentalised in the same way into language extensions
05:48:25 <Cale> (since Haskell 2010 introduced the LANGUAGE pragma, but didn't get a whole lot of use out of it on its own)
05:49:32 <Cale> The problem is that it's tricky to actually find a nice readable way to write down what's there and how everything ought to work
05:50:16 <Cale> https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf does a bunch of stuff...
05:51:34 <Cale> But it's almost a book in its own right and doesn't actually cover anything beyond a limited (though broad) fragment of the type system.
05:52:08 <maerwald> lol, ICS AG
05:52:12 <maerwald> I worked there once
05:52:23 <Cale> But then, it's also much more detailed than what you might want in the Report as well..
05:52:47 <maerwald> didn't know Martin Schulzmann was there
05:52:51 <Cale> (and in other ways more general)
06:11:53 <hodapp> anyone have a favorite library for generating triangle meshes?
06:15:42 <hodapp> saw ImplicitCAD, and I want to mess with it a bit (but for other reasons), but wanted to find something that just handles some of the simple mesh formats
06:17:47 <fakenullie> does implicitcad uses better csg engine than openscad?
06:19:48 <iron_houzi> Cale: Is the purpose of bind to have a data "transformer" from one type of parser to another type of parser? bind takes the first parser and a function that converts the output of the first parser into the resultant parser....??
06:20:10 <iron_houzi> in effect binding two parsers of potentially different types ..
06:20:14 <Cale> iron_houzi: for parsing the remainder of the input, yes
06:20:27 <Cale> It's this last bit which is really important
06:21:09 <Cale> For example, the first parser might read a number, and then the function might build a parser which will expect that many lines of input to be consumed thereafter
06:21:13 <iron_houzi> what "bit"? What you just said about managing the remainder of the first parser?
06:21:20 <Cale> yeah
06:21:44 <Cale> So it's like what the paper calls seq in that regard
06:22:01 <Cale> But rather than just ignoring the result of the first parser and continuing with the second
06:22:19 <Cale> the second parser is allowed to depend on the result of the first parser
06:23:51 <iron_houzi> A function for binding two parsers, where you need one parser and a function that takes the result of this one parser and produces a second parser .. chaining the consumption of the input ..
06:24:19 <quicksilver> hodapp: the number of people who have done 3D mesh handling in haskell is sufficiently small that there probably aren't people online in the channel right now with an answer to your question.
06:24:33 <iron_houzi> It's more clear, but I still think this needs some more marinating. Thanks Cale!
06:24:36 <quicksilver> I did some but I did it by hand because I was only doing it for fun, not to achieve anything efficient
06:24:36 <hodapp> fakenullie: they're different sorts of engines. OpenSCAD is based on CGAL, which all explicit/parametric shapes and CSG to combine them, whereas ImplicitCAD behaves like Curv/libfive/Ruckus in which you work with implicit surfaces (like SDFs) in which your shape is defined by F(x,y,z) where F > 0 outside the surface, F < 0 inside the surface, F = 0 on the surface
06:24:53 <dminuoso> iron_houzi: Have you written/used the State monad before?
06:25:06 <quicksilver> hodapp: I did a partial marching cubes algorithm, but I didn't handle some of the fiddly cases.
06:25:32 <Cale> Or if you've used IO or any other monad, it might help to know that bind is (>>=)
06:25:39 <Cale> but for parsers :)
06:25:47 <hodapp> fakenullie: implicit surfaces, aka F-Reps, are a lovely "functional" representation in which all sorts of things are possible and elegant through function compositions and domain transformations, including shapes that are infinite in extent or in detail
06:25:55 <hodapp> but they're sort of harder to render and work with
06:26:26 <hodapp> quicksilver: yeah, I was looking less at the 3D mesh handling side and more just at handling a common file format
06:26:41 <hodapp> if I can make it kick out a mesh, I can clean the mesh up in other tools made for it
06:28:46 <hodapp> but hmmm. OBJ and STL aren't that complicated formats. I could probably just write my own exporter if need be
06:29:09 <quicksilver> actually I was partly doing it because I'd read the marching cubes paper and I didn't believe it was that complex
06:29:17 <quicksilver> so I tried to write an implementation myeslf to understand
06:29:41 <hodapp> were you turning isosurfaces to a mesh?
06:30:17 <hodapp> yeah, I had thought that marching cubes (or whatever the non-IP encumbered variant thereof is called) was a very simple algorithm, but then, I've never implemented it
06:30:50 <hodapp> I was more focusing on using SDFs to render directly via raymarching (sphere tracing, particularly)
06:31:08 <hodapp> at one point I was going to write a sphere tracer in Haskell via Hylogen. can't recall why I stopped
06:31:43 <Rembane> Did life happen?
06:31:57 <hodapp> lol, maybe
06:32:10 * Rembane hands hodapp a life delayer
06:32:21 <quicksilver> hodapp: yes, turning various kinds of implicitly defined surfaces into meshes
06:32:21 <hodapp> but it might have been technical reasons too, e.g. me running into some sort of technical barrier that just wasn't worth trying to get past
06:32:28 <cocreature> life considered harmful
06:32:29 <quicksilver> partly to understand the algorithm
06:32:35 <quicksilver> partly to experiment with visualising the algorithm
06:32:43 <hodapp> quicksilver: did you run into things that made it much less simple than you thought?
06:32:51 <quicksilver> I had some poorly constructed thoughts about how it's a pain to visualise haskell algorithms
06:32:56 <hodapp> huh
06:33:02 <quicksilver> so I wanted to be able to animate the marching cubes
06:33:12 <quicksilver> hodapp: there are more irreducible cases than you'd expect
06:34:38 <Cale> btw, if you happen to make a raytracer with spheres, my favourite scene is to arrange 4 spheres in a tetrahedron, tangent to one another, arrange some different coloured lights or something interesting around it, and then point the camera inward. The reflections form a fractal.
06:35:11 <hodapp> Cale: I've seen that before but never tried it
06:36:12 <hodapp> but it still knocks my socks off that it's possible to raymarch things like the Julia and the Mandelbulb directly because it's possible to define a signed distance function, thus an isosurface, for the (infinitely complex) surface
06:37:21 <hodapp> I read the syntopia articles on how to do that, but even with the level of details those articles went into they just sort of punted to an even longer paper to explain how you turn Julia, Mandelbrot, Mandelbulb, and so on into a distance estimate function over R^2 or R^3
06:37:58 <hodapp> buuuut... my Haskell-mesh-generation-needs are luckily much simpler
06:38:33 <hodapp> I have a system I built, vaguely IFS or L-system like, that right now works in 2D and I want to make it 3D, like Structure Synth, because it works almost identically there
06:38:37 <Cale> If you google image search for "Wada basin" you'll find a bunch of nice examples, some from real life :)
06:38:39 <quicksilver> hodapp: http://roobarb.jellybean.co.uk/~jules/Picture%20145.png
06:38:51 <quicksilver> screenshot turns 10 years old in a couple of weeks!
06:39:08 <quicksilver> trying to visualise the points the cubes cut through the surface
06:39:38 <iron_houzi> dminuoso: Not yet, no. I believe I have heard of it though. Why?
06:39:49 <dminuoso> iron_houzi: State is the simpler form of Parser.
06:40:07 <dminuoso> Rembane: Parser a ~ StateT String [] a
06:40:14 <dminuoso> Woah. What in the heck was that.
06:40:29 <dminuoso> I typed iro<tab> and weechat gave me your nickname. This is so weird..
06:40:29 <iron_houzi> dminuoso: Do you think I'm wasting my time in terms of learning the concepts of cominatoric monadic parsers?
06:40:38 <hodapp> quicksilver: hah, neat. looks like marching cubes to me.
06:40:41 <dminuoso> iron_houzi: Absolutely not. :)
06:41:19 <iron_houzi> dminuoso: OK, thanks for informing me. I'll probably be using the State monad once I have a thorough understanding of combinatoric monadic parsers
06:42:52 <hodapp> Cale: speaking of chaos theory, my pet project as of late has been to try to produce something that is vastly simpler than the Mandelbrot in terms of computation, but has as lot of the same sort of 'infinite detail and self-affinity' properties
06:43:03 <Cale> iron_houzi: It may be simpler to start with State though.
06:43:24 <hodapp> I started from binary cyclic tag systems, which are among the simplest Turing-complete systems, but have run into some snags getting interesting visualizations out of them
06:43:34 <Cale> iron_houzi: It has a lot of similarity with the Parser you're trying to understand, but is a bit simpler (though perhaps less useful)
06:43:58 <iron_houzi> Cale: Do you know a similar resource to the PDF I've referred to that utilizes the State monad for creating parsers?
06:44:10 <Cale> hmm
06:44:33 <dminuoso> iron_houzi: I would say just learn State in the general form, parsers will become obvious. :)
06:45:04 <Cale> iron_houzi: Well, that could be done once you get to StateT (the monad transformer corresponding to State)
06:45:06 <dminuoso> But YMMV
06:45:18 <Cale> Parser = StateT String []
06:45:38 <Cale> but yeah, I wasn't even suggesting to do that :)
06:45:41 <dminuoso> plus an implied contract that each parser will only consume.
06:46:11 <electrocat> this might be useful: http://dev.stephendiehl.com/fun/002_parsers.html
06:46:30 <dminuoso> Are there legit reasons to put things into the stream in a parser?
06:46:59 <iron_houzi> Cale: The thing is, the document makes a lot of sense on the high level .. it makes the basic concepts very easy to understand .. it just becomes a bit black box when it comes to understanding the fine details .. I hit a wall on page 9 when the authors switch to using actual monads and the type alias stops working. I'm unable to convert the type alias to a data type .. which is why I'm trying to understand
06:47:02 <iron_houzi> the fine details .. any help on this would be greatly appreciated
06:47:25 <Rembane> dminuoso: ^^ it's the quantum effects.
06:47:32 <hodapp> quantum... effects?
06:47:58 <iron_houzi> dminuoso: I'll most certainly get to State monad at some point. I'll have a look today and see if it helps with what I'm doing now.
06:48:05 <Cale> iron_houzi: ah, you'll want to make it into a newtype
06:48:18 <Cale> iron_houzi: and then insert the newtype's data constructor as appropriate
06:48:46 <Cale> i.e.  newtype Parser a = P (String -> [(a, String)])
06:49:12 <Cale> runParser :: Parser a -> String -> [(a,String)]
06:49:15 <dminuoso> @let data State s a = State { runState :: s -> (a, s) }
06:49:16 <lambdabot>  Defined.
06:49:23 <Cale> runParser (P f) s = f s
06:49:35 <iron_houzi> Cale: This is as far as I've managed to get .. but it must be a dead end: https://github.com/ironhouzi/hstib/blob/tib_monad/src/Main.hs#L279-L290
06:49:37 <Cale> and indeed, you could use record syntax to do that automatically
06:49:58 <iron_houzi> Cale: Oh, this is very interesting! Thank you!
06:50:06 <Cale> iron_houzi: Oh, you're already getting there
06:50:20 <Cale> iron_houzi: (the difference between data and newtype is minor here)
06:50:39 <Cale> iron_houzi: Mainly, you just need to remember to use your data constructor when you want to build a value of type Parser
06:50:49 <Cale> I called it P, you called it Parser
06:51:03 <iron_houzi> right, .. thank you so much!
06:51:33 <Cale> iron_houzi: I actually find that explicitly using runParser in these definitions makes them more readable
06:51:42 <Cale> rather than pattern matching
06:53:22 <WhatisRT> Hi! Is there any (non horribly complicated) way of turning typeclass restrictions of functions into parameters?
06:53:56 <WhatisRT> For example I want to turn sort into sort' :: (a -> a -> Bool) -> [a] -> [a]
06:54:12 <alexad> Recommendation for a decent jose lib with full-ish JWE support?
06:54:13 <Cale> Well, not automatically, really
06:55:35 <dminuoso> WhatisRT: What are you trying to do?
06:56:50 <WhatisRT> dminuoso: I want to offer such functions over a FFI
06:56:54 <tdammers> is fpcomplete's hackage mirror flaky for anyone else, or is it just me?
06:57:39 <ventonegro> WhatisRT: You can manually rewrite interfaces as records
06:59:30 * hackage composition-prelude 1.5.0.4 - Higher-order function combinators  http://hackage.haskell.org/package/composition-prelude-1.5.0.4 (vmchale)
06:59:39 <WhatisRT> ventonegro: I'm not sure what you mean - I can of course use a helper data type, but I have difficulty in getting it general enough
07:00:10 <dminuoso> :t Comparison
07:00:12 <lambdabot> error: Data constructor not in scope: Comparison
07:00:14 <ventonegro> WhatisRT: You would need one for each typeclass you want to pass to the FFI
07:00:28 <dminuoso> @let import Data.Functor.Contravariant
07:00:30 <lambdabot>  Defined.
07:00:30 <[exa]> WhatisRT: did you see how the typeclass members are mangled after just typechecking?
07:00:35 <dminuoso> :t Comparison
07:00:36 <lambdabot> (a -> a -> Ordering) -> Comparison a
07:00:43 <nshepperd_> You can rewrite the function that uses a typeclass to use plain functions instead
07:01:29 * hackage influxdb 1.6.0.4 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-1.6.0.4 (MitsutoshiAoe)
07:01:36 <nshepperd_> If it's not your function, reflection package is the way to run it with a "dynamic" typeclass instance
07:02:40 <dmwit> WhatisRT: Are source-to-source transformations "horribly complicated"?
07:03:11 <WhatisRT> dmwit: I may not have access to the source
07:03:27 <WhatisRT> So I cannot rely on these
07:04:00 <dmwit> Then reflection is likely your best bet.
07:07:27 <WhatisRT> Seems like I have to spend an hour or so getting this library :)
07:07:34 <WhatisRT> Thanks!
07:07:47 <shapr> @quote Cale
07:07:47 <lambdabot> Cale says: I even go through google blog search and pick up random bloggers saying "I tried Haskell last weekend" and so on, and leave a remark for them to come here. :)
07:08:05 <shapr> yay!
07:08:51 <jchia_> many is defined in both GHC.Base and Control.Monad.Combinators (from package parser-combinators). So I get duplicate definitions when I use both Control.Applicative and Text.Megaparsec. Why does parser-combinators define its own many?
07:09:14 <fakenullie> hodapp: but implicitcad doesn't seem to allow arbitrary functions
07:09:17 <Ariakenom> :t many readLine
07:09:18 <lambdabot> error:
07:09:19 <lambdabot>     • Variable not in scope: readLine :: f a
07:09:19 <lambdabot>     • Perhaps you meant one of these:
07:09:22 <hodapp> fakenullie: what do you mean?
07:09:33 <Ariakenom> :t many getLine
07:09:34 <lambdabot> IO [String]
07:09:35 <jchia_> It's quite messy because now I can't import Control.Applicative and Text.Megaparsec unqualifiied.
07:09:48 <fakenullie> hodapp: write my own F(x, y, z) instead of composing provided functions
07:10:02 <Ariakenom> jchia_: you can use hiding in your import
07:10:02 <hodapp> fakenullie: it doesn't allow that? I haven't looked in detail but I swore it did
07:10:11 <jchia_> Ariakenom: I know. It's just messy.
07:10:15 <hodapp> so far it is only libfive and Curv that I have worked with directly, though
07:10:37 <jchia_> I don't understand why parser-combinators has to define its own. Is it different than the one from base?
07:12:09 <UnkDevE> is anyone there?
07:12:30 <Cale> plenty of people are here
07:12:34 <dmwit> No people, just us crickets.
07:13:08 <Cale> shapr: It's been quite a while :)
07:13:37 <shapr> Cale: yeah, I've noticed the quotes are getting old
07:13:50 <dmwit> jchia_: Historical accident, most likely. Parsec had it because parsec predated Alternative, and I suspect parser-combinators has it because parsec had it.
07:14:03 <shapr> I'm tempted to add in date added and weight the random choice for newer quotes.
07:14:07 <Cale> WhatisRT: I would recommend just reframing your problem somehow so that you're not faced with turning typeclass instances into data.
07:14:22 <jchia_> dmwit: To be clear: Control.Monad.Combinators.many (from parser-combinators) vs Control.Applicative.many (from base)
07:14:38 <dmwit> jchia_: I don't think that clarification changes my answer.
07:14:48 <jchia_> One is for MonadPlus and one for Alternative
07:14:57 <jchia_> I think I wasn't very clear before.
07:16:10 <WhatisRT> Cale: I can't. My problem requires that the instances of type classes have to be created at runtime.
07:16:38 <WhatisRT> Or at least that they can be created at runtime
07:16:50 <dmwit> WhatisRT: prove it
07:17:00 <shapr> there's very likely a different approach
07:17:02 <jchia_> dmwit: I don't understand why in parser-combinators they didn't remove the definition of when compiling with recent versions of base. They could use a CPP version check.
07:17:28 <dmwit> jchia_: Okay. Do you believe understanding would change your behavior?
07:17:34 <jchia_> Because MonadPlus implies Alternative, so there's already a many from Control.Applicative.
07:17:40 <WhatisRT> I want to turn haskell functions into c++ functions of the same type
07:17:56 <WhatisRT> At least as far as it makes sense
07:18:03 <hodapp> fakenullie: hmm, you might be right. that surprises me about ImplicitCAD, since the other 'similar' frameworks let you do arbitrary functions and it's half the point of them
07:18:33 <Cale> WhatisRT: Since Haskell's type system has types in it that have no corresponding type in C++, that doesn't make sense for all Haskell functions.
07:18:41 <jchia_> dmwit: There are two possibilities. There is a good reason for the Control.Monad.Combinators.many to exist or there isn't. If there is, I'll import hiding many. If not then maybe I'll post an issue for parser-combinators.
07:18:56 <dmwit> jchia_: There isn't.
07:19:15 <WhatisRT> Cale: yes, but in most cases it will work
07:19:18 <Cale> In particular, C++ doesn't have type classes, so you can safely ignore anything which is type class polymorphic.
07:20:09 <jchia_> dmwit: OK, I'm making a github issue
07:20:12 <WhatisRT> Well, or I can add another argument to remove the typeclass restriction
07:20:28 <WhatisRT> That's precisely why I want to do that
07:24:16 <alexad> fuuuck
07:25:07 <alexad> I can't find a JOSE lib for haskell with RSA_OAEP_256 support
07:25:52 <dmwit> Hey, grats, you get to write more Haskell now!
07:26:04 <ventonegro> Lucky bastard
07:27:53 <alexad> dmwit, looks like
07:28:06 <alexad> my hackathon is becoming a forking effort
07:33:06 <jchia_> dmwit: I think actually there's a special reason. The documentation fro Control.Monad.Combinators says "The module provides more efficient versions of the combinators from Control.Applicative.Combinators". Newer versions of megaparsec reexport from Control.Monad.Combinators instead of Control.Alternative.Combinators.
07:58:11 <cocreature> I still don’t quite know what this statement is supposed to refer to
08:05:27 <hodapp> story of my life
08:15:30 * hackage servant-auth 0.3.2.0 - Authentication combinators for servant  http://hackage.haskell.org/package/servant-auth-0.3.2.0 (domenkozar)
08:21:30 * hackage typenums 0.1.1.1 - Type level numbers using existing Nat functionality  http://hackage.haskell.org/package/typenums-0.1.1.1 (AdituV)
08:23:10 <alexad> BAM done it, implemented RSA-OAEP-256 for jose-jwt :D
08:28:24 <quicksilver> alexad++
08:28:35 <alexad> so, cabal stuff question... I have a local fork of a project that hasn't accepted a change I need yet... Is there a nice way I can simply use my local fork as my dependency for now as I build?
08:28:45 <alexad> or a github point or something?
08:28:57 <cocreature> alexad: do you use cabal new-build?
08:28:58 <electrocat> alexad: purely using cabal?
08:29:10 <alexad> cocreature, nothing prevents me from doing so.
08:29:28 <alexad> electrocat, or anything not too head-screwsy
08:29:35 <cocreature> alexad: with "cabal new-build" you can just add the path to your local fork in the "packages" section in "cabal.project"
08:29:53 <glguy> https://www.haskell.org/cabal/users-guide/nix-local-build.html#specifying-the-local-packages
08:30:08 <cocreature> also if you haven’t used new-build yet, you might be pleasantly surprised. it’s a lot more convenient than working with sandboxes :)
08:30:08 <alexad> cocreature, I suppose combined with git submodules I could use a relative path and be fine for now?
08:30:12 <cocreature> yep
08:32:00 <maerwald> note that cabal new-install is semi-broken
08:32:21 --- mode: glguy set -q Mrd1!*@*
08:32:42 <electrocat> or non-existant depending on your version :p
08:32:52 <electrocat> non-existent*
08:33:07 <glguy> If you're not using the latest release it's time to upgrade
08:34:52 --- mode: glguy set -o glguy
08:34:54 <electrocat> does anyone know if split-objs/sections work decently on newer versions?
08:35:18 <electrocat> it works for the package you're currently building but it seems to be ignored for the dependencies
08:37:23 <cocreature> electrocat: how are you trying to pass the option?
08:38:43 <electrocat> `cabal new-configure --enable-split-objs`
08:38:58 <maerwald> is there a more java-like doc frontend of haskell packages?
08:39:10 <maerwald> navigating is kinda annoying
08:40:13 <alexad> cocreature, so this packages definition is only for the new-build system?
08:41:22 <cocreature> electrocat: I’m not quite sure about the cli flags. maybe try putting "package *\n split-sections: True" in your cabal.project file instead
08:41:26 <cocreature> alexad: yep
08:41:44 <cocreature> alexad: in a hopefully not too distant future new-build will replace the existing build command
08:41:47 <electrocat> cocreature: ah, i'll try that later today, tnx
08:42:12 <cocreature> electrocat: also you really want to be using split-sections instead of split-objs if you’re GHC supports the former afaik
08:43:19 <asheshambasta> Hi guys, has anyone tried to write an SSL passthrough proxy using Haskell?
08:43:32 <[exa]> maerwald: what do you mean by java-like?
08:43:54 <alexad> cocreature, do these co-exist with or replace *.cabal files?
08:44:06 <maerwald> [exa]: https://docs.oracle.com/javase/7/docs/api/
08:44:15 <electrocat> cocreature: yeah, i'm aware, haven't looked into yet, build systems don't seem to have an options for it though
08:44:27 <electrocat> option*
08:44:29 <[exa]> asheshambasta: y u no haproxy/nginx? not sure if Haskell is a good implementation language for that kind of stuff
08:44:53 <cocreature> alexad: coexist, you still have cabal packages that are configured using .cabal files. but now you also have a cabal.project that can be composed of multiple cabal packages and is configured using cabal.project
08:45:02 <cocreature> electrocat: afaik "split-sections" is a cabal option
08:45:15 <asheshambasta> [exa]: good question, but we want to automate certificate issuance for the domains we serve (we serve hundreds) via LetsEncrypt.
08:45:36 <asheshambasta> There are prebuild nginx based projects that do that, but our experience with that has been mixed.
08:46:00 * hackage hadolint 1.7.5 - Dockerfile Linter JavaScript API  http://hackage.haskell.org/package/hadolint-1.7.5 (lorenzo)
08:46:12 <cocreature> I think michael snoyman experimented with integrating lets-encrypt certificate issuance into warp at some point. not sure what the current state of that is
08:46:14 <electrocat> cocreature: ah indeed, seems to be new
08:46:23 <electrocat> i don't have it yet
08:46:27 <cocreature> electrocat: upgrade! :)
08:46:33 <[exa]> asheshambasta: I'd strongly advice from writing the proxy yourself in any language, it's error-prone from so much different vectors that you don't want to know about :]
08:46:35 <electrocat> :D
08:47:05 <cocreature> electrocat: I’m not kidding here, if you use the new-* stuff you really want to make sure you are using the latest version of cabal
08:47:18 <[exa]> asheshambasta: but, anyway -- writing modules for nginx isn't complicated and you can easily make simple haskell bindings from that thing using FFI
08:47:29 <asheshambasta> cocreature: wow: https://github.com/snoyberg/warp-letsencrypt
08:47:57 <electrocat> i've noticed, currently i'm just using the version that stack lts or nix gives me
08:48:00 * hackage servant-auth-client 0.3.3.0, servant-auth-server 0.4.0.0, servant-auth-swagger 0.2.10.0, servant-auth-docs 0.2.10.0 (domenkozar)
08:48:12 <cocreature> asheshambasta: I have absolutely no experience with that so don’t blame me if it doesn’t work :)
08:48:13 <alexad> cocreature, I don't suppose you can point me at a real example of this?
08:48:29 <cocreature> alexad: an example of what exactly?
08:48:32 <asheshambasta> [exa]: point taken
08:49:14 <glguy> alexad: Here's a cabal.project files: https://github.com/glguy/irc-core/blob/v2/cabal.project
08:49:35 <alexad> ooh, I need to explicitly build "all"
08:49:41 <[exa]> asheshambasta: you don't want to shovel the raw data through haskell, but I imagine that writing some not-timing-critical certificate event-handling stuff can be easily offloaded
08:50:20 <cocreature> alexad: or the package that you are interested in
08:50:29 <asheshambasta> [exa]: yeah – I guess interfacing nginx with Haskell via the FFI isn't a bad idea at all
08:51:46 <[exa]> maerwald: if you mean 'list of modules by module name, not package name'...I'd like that very much as well :]
08:52:21 <[exa]> (I guess that there may be problems with overlapping module names though, we've got like at least ten different Preludes right?)
08:52:38 <maerwald> no, I mean generally more structure when looking at a module
08:53:00 <maerwald> not hit back and forth all the time
08:53:33 <[exa]> asheshambasta: well wish you luck. anyway, any reason why would you need the certificate handling logic this close to the data streams?
08:54:00 <[exa]> maerwald: oh so, I kindof dislike that one on java docs :D
08:54:41 <glguy> The newer "quickjump" stuff helps for moving around when you know about what you're looking for
08:54:48 <asheshambasta> [exa]: because we handle 100's of domain names, and the most efficient way imho, is to perform certificate requests and installations on the fly -- per request.
08:55:32 <asheshambasta> for example, if domain xyz.com was issued a certificate at some point and then stops receiving requests for a while, we don't really need to renew its cert. until the next request
08:56:11 <[exa]> asheshambasta: sounds more like "millions of domains"
08:56:43 <asheshambasta> and while its certificate is expired, the client may be still upgraded to an SSL connection on the fly as the certificates are issued
08:57:08 <asheshambasta> [exa]: Soon :-)
08:57:12 <[exa]> do you realize that first requests usually contain passwords?
08:58:04 <[exa]> (even if this is something like CDN -- first requests usually contain images that contain passwords :D)
08:58:13 <asheshambasta> not in our case (where we're trying to solve this problem), its for simple websites like these: Y
08:58:20 <alexad> cocreature, figured it out from another example someone had posted on SO XD
08:58:28 <asheshambasta> https://bonbol.be (sorry)
08:58:39 <alexad> glguy, thanks
09:00:49 <[exa]> asheshambasta: I'd still go with a solution at least partially external to nginx. Having something inside will force you to be extremely efficient and try not to interfere with the lowlevel network event processing. If you can wait a little with the SSL upgrade, how about logging non-ssl queries in nginx, issuing the cert in another process, and reconfiguring that later on-the-fly?
09:02:04 <[exa]> asheshambasta: that's 1 process for handling nginx website configurations/reloads and 1 process that checks the logs each minute and spawns renewals whenever needed
09:02:35 <[exa]> asheshambasta: similar problem: of someone has a https:// link saved, he'll see the certificate expired page and you won't be able to see which domain he wanted
09:02:42 <[exa]> ok </offtopic>
09:03:18 <asheshambasta> [exa]: yeah, correct, the clients will eventually distribute their links etc. so we cannot afford to have SSL certificates expire.
09:03:54 <asheshambasta> what can alernatively be done is this haskell service keeps a record of all issued certs and the time of issue
09:04:36 <asheshambasta> and checks every minute for a minimum validity threshold; renews the certificates necessary (or queues the jobs)
09:05:05 <[exa]> yeah, just a renewal daemon that sometimes reloads nginx (I guess nginx can reload without pausing any traffic)
09:05:44 <asheshambasta> yeah, there's also something in the openresty project that allows you to make dynamic SSL certificates
09:06:03 <[exa]> anyway the warp-letsencrypt seems cool, if you don't have much traffic in terms of raw data, I'd love to go with that
09:07:23 <asheshambasta> yeah
09:08:25 <reactormonk> Can I have named fields in a GADT?
09:08:52 <asheshambasta> [exa]: the thing is, we have a decent bit of traffic, so I'm not really sure at many levels, maybe I need a good night's sleep (I just started working on this today)
09:08:56 <glguy> Yes, GADTs have a record syntax
09:09:21 <asheshambasta> and by working I just mean thinking about the architecture and the direction to take for the solution; its an interesting problem nonetheless.
09:09:34 <glguy> reactormonk: There are examples in the GHC users's guide
09:10:05 <reactormonk> glguy, kk
09:10:26 <asheshambasta> [exa]: in case you're interested: https://github.com/GUI/lua-resty-auto-ssl
09:14:04 <asheshambasta> question: when to use `return` and when to use `pure`?
09:14:19 <electrocat> asheshambasta: imo, doesn't really matter
09:14:37 <asheshambasta> electrocat: I prefer `pure` since its shorter.
09:14:43 <electrocat> unless you need backwards compat
09:15:47 <electrocat> i personally use pure when using applicative stuff, and return in do notation
09:16:09 <[exa]> in some cases you might want to force the type system to derive Monad constraint instead of Applicative....but I'm not aware of such cases.
09:16:40 <[exa]> yeah return looks just better in do-blocks
09:17:01 <electrocat> well in the future they'll be exactly the same iirc
09:17:07 <electrocat> just aliases
09:17:29 <Taneb> I prefer "pure" in all cases other than when I want to support GHC versions before Applicative was added to Prelude
09:17:30 * hackage diffmap 0.1.0.0 - diff on maps  http://hackage.haskell.org/package/diffmap-0.1.0.0 (chessai)
09:18:05 <asheshambasta> I see
09:37:32 <Cale> asheshambasta: fwiw, I only ever use Applicative when I'm convinced that there would be some benefit to the extra abstraction
09:37:46 <Cale> (and tend to use return rather than pure in most places)
09:38:32 <asheshambasta> Cale: okay
09:38:52 <asheshambasta> I was confused because I see both return and pure
09:38:57 <asheshambasta> (in the wild)
09:39:49 <Cale> Well, return is part of the definition of Monad and pure is part of the definition of Applicative, it just wasn't always the case that Applicative was a superclass
09:48:17 <saml> is haskell production ready like for web microservices
09:48:46 <dysfun> plenty of people use haskell in production for many years
09:50:24 <vilu> Hi, I'm trying to implement a Zipper using a graph for a Maze like game.
09:50:35 <vilu> I'm having some trouble with the implementation.
09:51:06 <vilu> I see very little documentation of Zippers in any other context than lists/trees
09:51:19 <vilu> Am I having troubles because it's not possible or because I can't see it? :)
09:54:12 <humanoyd> saml: https://github.com/Gabriel439/post-rfc/blob/master/sotu.md might be of interest to you
09:54:33 <saml> thanks humanoyd
09:55:03 <dmwit> vilu: Creating efficient zippers for structures where there is more than one path from the "root object" to any other given object are an open research question.
09:55:44 <vilu> dmwit: Ok, can you point me to any papers?
09:56:15 <vilu> Either way I think that means I'm in over my head.
09:56:16 <dmwit> You want papers on an open research question? "Open research question" means nobody knows how to do it. So no. I can't point you to any papers telling how to do something nobody knows how to do.
09:56:41 <vilu> Misunderstood what you meant.
09:56:45 <vilu> Thanks either way.
09:58:03 <alexad> anyone used scotty much know if there's a nice way to separate and namespace out groupings of actions?
10:13:38 <[exa]> vilu: zippers don't work very easily for structures that you can't easily cut in _disconnected_ pieces
10:19:39 <doomrobo> is there a way to export something with a different identifier? For example, I would like to re-export Criterion.bgroup as benchGroup
10:20:05 <geekosaur> rebind it in your module, export that.
10:20:05 <cocreature> doomrobo: no or at least not short of defining "benchGroup = bgroup"
10:20:32 <doomrobo> yeah, I wanted to avoid rebinding, just for the sake of consistency. Everything else is re-exported
10:20:40 <doomrobo> I'll just use bgroup instead. Thanks!
10:34:23 <dmwit> [exa]: I dunno. Disconnected seems easy enough, since the zipper can just have one "position" per piece.
10:36:54 <quicksilver> I think [exa] means that if your zipper is at a 3-fork but there aren't data types already for the data in those 3 pieces, you're doing to need to write those data types too
10:37:26 <quicksilver> certainly the time I wrote a zipper for a custom mutually recursive group of ADTs I had a lot of "part types" to write
10:40:22 <[exa]> there could be something like makeLenses that automatically does the term differentiation for zippers
10:42:11 <dmwit> I'd be shocked if one of the existing zipper libraries doesn't have that already.
10:42:37 <dmwit> But it doesn't help if your data type also has invariants not expressed by Haskell's concept of algebraic types -- as e.g. `Map` or `Graph` do.
10:45:21 <maerwald> I thought stack builds shouldn't fail
10:45:46 <maerwald> first I get resolver errors, then build failures :>
10:45:55 <quicksilver> [exa]: I'm sure I saw an implementation of that, yes.
10:46:03 <quicksilver> but it felt clumsy
10:46:21 <quicksilver> I guess partly because when you can re-use existing data types you'd like to
10:46:27 <quicksilver> (like re-using lists in the list zipper)
10:53:18 <[exa]> quicksilver: wow, cool, thanks. I'll try to find it
11:00:01 <quicksilver> [exa]: there is also edwardk's implementation which I don't understand https://github.com/ekmett/zippers
11:00:04 <quicksilver> check out the examples.
11:06:00 <[exa]> quicksilver: ok that one is extremely cool   ◔.◔
11:07:22 <shapr> I got much more comfortable doing webdev in Haskell this past weekend
11:07:34 <johnw> yay!
11:07:36 <shapr> I should write a blog post about going from html page mockup to all the things
11:07:37 <johnw> what did you write?
11:08:02 <shapr> cocreature found html-to-lucid, so I used that for some html page mockups
11:08:23 <shapr> and persistent for datatypes, I switched to scotty from Spock, looks like uploaded files is broken for Spock
11:08:28 <shapr> it was fun
11:08:59 <[exa]> OTOH if you imagine zipper as a container for the real structure or for the finger element, lenses and traversals make quite a lot of sense
11:17:20 <pally> > :t "Hello"
11:17:22 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
11:17:42 <monochrom> Omit the leading "> " when using :t
11:17:47 <pally> :t "Hello"
11:17:48 <lambdabot> [Char]
11:20:05 <pally> Then how is [Char] different to [String] ?
11:20:28 <monochrom> String = [Char], therefore [String] = [[Char]]
11:20:42 <monochrom> Therefore [Char] ≠ [[Char]]
11:21:06 <pally> ah... icic. Thanks
11:22:07 <monochrom> The power of doing algebra and logic and be liberated from mushy intution.
11:22:47 <dstolfa> monochrom: intuition is often wrong :>
11:23:00 <johnw> hence him calling it mushy :)
11:23:52 <monochrom> The homework I gave to my students rewards those who use algebra and logic, and punishes those who use intuition.
11:24:38 <dstolfa> monochrom: ah yes, i love that kind of homework
11:25:01 <dstolfa> monochrom: i did it a few times as well in hoare logic, where i asked them if {X = x & Y = y & x = y} C {x != y} can ever be true
11:25:09 <dstolfa> some said yes :)
11:25:14 <dstolfa> others were wrong and said no
11:25:26 <dstolfa> the former used the definitions, the latter used intuition
11:25:46 <monochrom> I put this on homework: Express scanr as a foldr.  I began the question by the very misleading "for example scanr (-) z [a,b,c,d] = [foldr (-) z [a,b,c], foldr (-) z [b,c], foldr (-) z [c], foldr (-) z []]
11:26:39 <monochrom> So those who use intuition would stare at that example and get very stuck.  This looks like multiple foldr's, not just one.
11:27:45 <dstolfa> monochrom: i take it that this is a FP course?
11:27:46 <monochrom> The correct thing to do is what I taught them: Start at the code of scanr (I gave it to them) and recognize or calculate that it fits the foldr pattern.
11:27:51 <monochrom> @src scanr
11:27:51 <lambdabot> scanr _ q0 []     = [q0]
11:27:51 <lambdabot> scanr f q0 (x:xs) = f x q : qs
11:27:51 <lambdabot>     where qs@(q:_) = scanr f q0 xs
11:28:15 <monochrom> Kind of.  It's one of those "principles of programming languages" course and I'm doing FP at this point.
11:28:34 <dstolfa> monochrom: aah right, we have one of those too in the first year but it's in ML, not haskell
11:28:37 <dstolfa> i don't know why
11:29:05 <dstolfa> this is not bashing on ML, i just legitimately don't know why ML was chosen
11:29:22 <monochrom> Sometimes it's better to begin with eager evaluation.  I did Racket before Haskell because of that.
11:29:44 <monochrom> And some other times ML simply has a real module system worth knowing.
11:29:48 <dstolfa> monochrom: i agree, but it isn't really a course that focuses on strictness, it just kind of looks at some foundations of compsci and exemplifies with ML
11:30:00 <dstolfa> though it does have "lazy lists" as an example
11:30:29 <monochrom> And some other times it could be just because the instructor worships Bob Harper :)
11:30:33 <dstolfa> monochrom: it might just be a personal preference, it's not like there's a big difference in terms of that course
11:31:03 <geekosaur> monochrom, except for those of us whose intuition notices a pattern, and that that pattern can be abstracted
11:31:05 <dstolfa> monochrom: well, his PhD advisor was rod burstall along with robin milner, that may have something to do with it ;)
11:31:25 <monochrom> I am beginning to think maybe next time I'll use OCaml.  Because then I could also talk about OOP done right.
11:32:29 <monochrom> Also next time I may introduce Backpack.  (I might not have time to prepare for it this term.)
11:33:04 <monochrom> Whereas ML has a real module system, Backpack has a real package system :D
11:33:19 <dstolfa> monochrom: OCaml is nice though its standard lib is a bit questionable. i know lots of people who speak very fondly of OCaml though
11:33:34 <monochrom> (So I guess "real" = paramtrizable composable etc etc!)
11:34:15 <monochrom> OCaml exposes what classes and objects really mean.
11:34:37 <monochrom> Well, I guess Python does a bit of that too.  Basically making the "self" explicit.
11:36:59 <glguy> monochrom: Did you take off points if they got the strictness wrong?
11:37:22 <monochrom> No.
11:37:38 <monochrom> Actually I haven't even starting the marking :D
11:38:39 <monochrom> But no, not planning to pick on strictness because I hadn't taught them that at the time (but I did recently) and all I wanted is for them to look at what @src said above and saw the foldr inside it.
11:40:10 <monochrom> But I do think "foldr (\x r -> f x (head r) : r) [q0]" has the exact same strictness/non-strictness as the direct recursion version.
11:40:48 <glguy> yeah, if they use head, but if they use the pattern match found in @src 's where clause in their lambda it's different
11:41:16 <monochrom> Oh! Right, yeah, I won't pick on that.
11:41:44 <monochrom> Yeah I now recall I saw some student doing that.  It'll be OK.
11:42:47 <dstolfa> monochrom: yeah being picky about strictness is probably out of scope here if you didn't explicitly teach them that or mention to be careful about it
11:42:52 <monochrom> I hadn't brought up lazy evaluation when the homework was given.  They were still assuming eager evaluation in Haskell!  And they hadn't thought of testing it.
11:43:31 <glguy> I wasn't serious about picking on strictness, but I figured that in the translation some of the solutions would change it
11:43:39 <glguy> Haskell makes stuff like that quite tricky
11:43:52 <monochrom> So one day when I showed them "doITermniate = take 2 (foo 0) where foo n = n : foo (n+1)" it broke their minds. :)
11:44:46 <dstolfa> monochrom: it's one of those fun moments when students realise something they've been told all their life is not always true :)
11:45:21 <dstolfa> monochrom: kind of like using isomorphisms instead of equality :)
11:46:20 <maerwald> most of what students are told is not true, but the current academic narrative
11:46:52 <dstolfa> maerwald: ah but see, i always emphasise that it's the model we're working with now and that coming up with different models is perfectly acceptable and in fact encouraged if justified :)
11:47:02 <dstolfa> teaching things as "facts" is very silly IMO
11:47:08 <maerwald> teaching is silly
11:47:13 <monochrom> maerwald it is not just academia.  What dstolfa said.  What is "truth" anyway?  Do you have it?
11:47:13 <maerwald> learning is better
11:47:57 <dstolfa> maerwald: learning is good, but having someone to guide you in learning is always helpful. this is where you can leverage people with experience to make your learning experience better and possibly get feedback on your ideas
11:48:14 <maerwald> dstolfa: exactly, but I consider that guidance, not teaching :)
11:48:26 <dstolfa> maerwald: fair enough, s/teaching/guidance/ in the above :)
11:48:37 <monochrom> learn = self-teach  so if teaching is silly then learning is self-silly.
11:49:09 <rotaerk> ...
11:49:52 <shapr> maerwald: 'lies for teaching' are useful, and I'm always explicit about that.
11:49:52 <monochrom> But OK I get paid for teaching so you could argue that I'm just defending a self-interest.
11:50:17 <maerwald> sounds sad
11:50:26 <maerwald> I also did that once and I realized it doesn't work
11:50:39 <maerwald> teaching people is very frustrating too
11:50:41 <dstolfa> monochrom: when i "teach" i basically get paid to ask students tricky questions and guide their discussion when they wander off
11:50:50 <shapr> I'm always explicit about 'lies for teaching' being a derivative of the reality underneath.
11:50:53 <maerwald> so it's better to not teach at all
11:50:59 <shapr> I disagree
11:51:19 <dstolfa> maerwald: i think it heavily depends on the way people are being taught (or guided if you will)
11:51:23 <maerwald> shapr: I might also be wrong, what do I know about other people :>
11:51:27 <shapr> My mother specifically requests the simpler glossier version, nowadays she says "Why did my internet break? and don't start with the sabertooth tiger this time!"
11:51:31 <shapr> maerwald: I don't know
11:51:33 <maerwald> everyone just projects anyway
11:51:37 <maerwald> (or not)
11:51:41 <shapr> heh
11:51:52 <monochrom> Yeah I think if you haven't been to one of my classes you shouldn't claim across-the-board that my teaching doesn't work.
11:52:30 <glguy> monochrom: Where do we sign up?
11:52:42 <monochrom> You have to come to Toronto!
11:52:44 <dstolfa> the way i see it, teaching people existing material in such a way that they gain insight from it is crucial. teaching things as "facts" and expecting them to accept the current world order is silly and frankly misleading
11:52:58 <maerwald> monochrom: that's not a compelling argument
11:53:16 <maerwald> but I wasn't that specific anyway
11:53:17 <pdxleif> @hoogle Applicative f =>
11:53:18 <lambdabot> Protolude pass :: Applicative f => f ()
11:53:18 <lambdabot> Control.Invertible.Monoidal unitDefault :: Applicative f => f ()
11:53:18 <lambdabot> Control.Monad.Extra obvious :: Applicative f => f ()
11:53:45 <pdxleif> @hoogle Applicative f => (a -> f (Maybe ab)) -> Maybe a -> f (Maybe b)
11:53:45 <lambdabot> Network.AWS.Prelude may :: Applicative f => ([a] -> f b) -> [a] -> f (Maybe b)
11:53:45 <lambdabot> Data.List.Index ifor :: Applicative m => [a] -> (Int -> a -> m b) -> m [b]
11:53:46 <lambdabot> Data.List.Index itraverse :: Applicative m => (Int -> a -> m b) -> [a] -> m [b]
11:53:47 <dstolfa> for example, teaching someone a topic that's the current world order and emphasising the ideas it captures, but pointing out its flaws is good. teaching it as a fact is bad
11:54:31 <maerwald> talking about teaching/learning is probably similarly difficult like talking about what the right political system is. People have pre-set ideas about it and it's hard to get to a really open discussion
11:55:10 <monochrom> Yeah so why don't you drop it and never start it again?
11:55:30 <maerwald> what do you mean? Avoiding hard discussions?
11:55:34 <monochrom> It's like the 10th time you teach us how and why teaching is silly.
11:55:41 <maerwald> not really
11:55:52 <monochrom> Avoid pointless discussions.
11:55:59 <monochrom> @quote monochrom pointless.de
11:55:59 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
11:56:03 <maerwald> I don't think it's pointless at all
11:56:42 <dminuoso> monochrom: self quoting should be punished by requiring you to bake and send us all cookies.
11:56:50 <shapr> browser cookies?
11:56:58 <dstolfa> i like cookies
11:57:01 <dstolfa> i agree with dminuoso
11:57:03 <dstolfa> monochrom: make cookies!
11:57:22 <monochrom> Darn...
11:57:25 <shapr> I like programming, and I really like programming in Haskell
11:57:35 <maerwald> people with high ego tend to quote themselves :P
11:57:50 <shapr> what's wrong with high ego?
11:57:53 <maerwald> nothing
11:58:05 <shapr> oh ok,
11:58:18 <monochrom> (Last off-topic remark)  High ego is how I overcome stage fright.
11:59:37 <dstolfa> monochrom: of teaching? :))
11:59:54 <monochrom> Yeah!  How else could I survive?
11:59:59 <dstolfa> monochrom: do you teach them how to overcome stage fright in order to teach?
12:00:11 <dstolfa> monochrom: or do you teach them how to teach on how to overcome stage fright in order to teach?
12:00:14 <dstolfa> monochrom: or ...
12:00:25 <maerwald> ...just don't teach at all :>
12:00:28 <dstolfa> monochrom: it's an infinity groupoid that may or may not be isomorphic to burrito origami
12:01:43 <monochrom> I talked myself into become an egomaniac so that I overcame stage fright for all public-speech occasions including teaching but that's really a side-effect my main goal was the PhD oral exam I had to go through!
12:02:03 <maerwald> great
12:02:06 <maerwald> I really don't know how I made stack fail both resolution and build
12:02:15 <maerwald> I thought it's supposed to be the opposite
12:02:17 <monochrom> But maerwald is going to chastise us too on how the whole PhD thing is silly too.
12:02:30 <electrocat> monochrom: lol
12:02:31 <maerwald> monochrom: I have literally never said such a thing
12:02:33 <dstolfa> maerwald: it's because it's written in this weird unsafe language called haskell
12:02:42 <monochrom> Anyway obTopic I have recently worked out how to teach type inference.
12:02:53 <dstolfa> monochrom: make them write a type checker in agda
12:03:07 <maerwald> but by now I'm used to people putting words into my mouth ;)
12:03:11 <monochrom> Oh type-checking Adga is actually easier.
12:03:34 <dstolfa> monochrom: not if you don't teach them agda and don't specify what you mean by "type checking" :)
12:04:13 <maerwald> https://github.com/neovimhaskell/nvim-hs/issues/65 just wanted to configure my vim in haskell :/
12:04:53 <__monty__> Had a project writing a typechecker for dependent lambda calculus in scala, did not enjoy it. Spent 90% of the time struggling with scala.
12:04:54 <electrocat> monochrom: now i'm curious
12:05:21 <monochrom> But what I figured out is not new.  More accurately, I figured out that I should follow "algorithm I" in the Milner paper, i.e., allow unification to update and use a mutable table of substitutions.
12:06:15 <monochrom> Because the alternative would be to always rewriting your type environment every other second and it becomes a chore.
12:06:44 <__monty__> maerwald: Just moving .stack out of the way for a few minutes wouldn't hurt, would it?
12:07:01 <maerwald> it's global state, other parts of my editor might be using it
12:07:01 <dstolfa> monochrom: are you aware of fitch notation?
12:07:37 <maerwald> also, that sounds very much like a "windows" solution
12:07:51 <monochrom> __monty__: Take consolence in knowing that https://www.umsu.de/logik/trees/ is written in javascript. >:)
12:07:51 <__monty__> maerwald: Afaics saep is asking you this to debug the problem. Not as a solution.
12:08:13 <monochrom> dstolfa: No.
12:08:45 <monochrom> Oh that's kind of neat.
12:08:46 <dstolfa> monochrom: you should look it up, it makes type inference much easier to read
12:11:05 <monochrom> OTOH I know of something even better: structured derivation of Ralph Back.  https://en.wikipedia.org/wiki/Structured_derivations
12:11:47 <maerwald> it also makes me kinda nervous downloading my compiler binary from a random website (not even shown from where). Also feels "windows" like
12:11:57 <monochrom> If you say "it seems to generalize Fitch to cover equational reasoning too" that's about right.
12:12:19 <__monty__> maerwald: Well you chose to use stack...
12:12:33 <maerwald> __monty__: no, the project says to
12:12:45 <maerwald> and some projects are already kinda broken without stack
12:13:23 <monochrom> What I have now is http://www.cs.utoronto.ca/~trebla/CSCC24-2018-Summer/type-inference.txt  which is indented like Fitch's and SD, I just don't have the vertical lines etc.
12:13:25 <maerwald> I still don't use it for development, only for installing tools
12:19:54 <shapr> maerwald: how would you improve it?
12:20:12 <maerwald> shapr: improve what?
12:20:34 <shapr> stack and the ecosystem?
12:21:09 <maerwald> remove stack, make hackage not a randomly rolling release platform, but have a system to test reverse dependencies automatically and remove that PvP madness
12:21:13 <__monty__> By using nix ; >
12:21:14 <maerwald> but that's not my call
12:21:36 <shapr> maerwald: have you tried nix?
12:21:36 <maerwald> also, fix GHC ABI breakage, but that's beyond my knowledge :>
12:21:41 <maerwald> yes, awful
12:21:48 <shapr> hm, I like it so far
12:21:59 <maerwald> second worst distro I've tried so far
12:22:05 <rotaerk> nix is the best option available, I think, but it's complicated
12:22:13 <__monty__> You don't have to run nixos to use nix.
12:22:19 <yushyin> maerwald: that would be great
12:22:35 <maerwald> __monty__: that's a common misconception. You do run nixpkgs, which are part of NixOS
12:22:42 <maerwald> whether you "boot" it or not
12:23:08 <rotaerk> NixOS uses nixpkgs but nixpkgs isn't tied to NixOS
12:23:17 <rotaerk> I love NixOS though
12:23:20 <maerwald> that's wrong
12:23:30 <__monty__> And you don't *have* to use nixpkgs.
12:23:45 <shapr> maerwald: what's wrong?
12:23:46 <__monty__> Don't see why you wouldn't though.
12:23:54 <maerwald> shapr: that nixpkgs is not tied to NixOS
12:24:08 <rotaerk> why do you say that it is?
12:24:14 <maerwald> https://github.com/NixOS/nixpkgs
12:24:15 <shapr> er, but I can use nix the package manager without installing nixos
12:24:19 <maerwald> shapr: no
12:24:22 <shapr> er, yes?
12:24:27 <maerwald> shapr: you don't *boot* it
12:24:31 <maerwald> but you use parts of NixOS
12:24:35 <shapr> yeah?
12:24:39 <maerwald> yes
12:24:43 <shapr> but part is not all
12:24:47 <maerwald> yes
12:24:50 <__monty__> Sounds pedantic.
12:24:51 <shapr> that's what I said
12:25:05 <maerwald> __monty__: not at all. The configuration complexity is a distro decision and is what makes nixpkgs so bad
12:25:06 <rotaerk> you can use nixpkgs in non-NixOS distros
12:25:12 <maerwald> I am aware
12:25:22 <maerwald> you can also create random chroots on any distro for any other distro :>
12:25:35 <shapr> uhh
12:25:36 <maerwald> doesn't mean the distro you run in a chroot is not said distro
12:25:56 <shapr> I think there's a vocabulary problem here.
12:26:08 <maerwald> not at all
12:26:13 <shapr> sure man, if you say so
12:26:51 <maerwald> nixpkgs need to be configured, they are not standalone, they are part of a release and design process
12:27:07 <maerwald> it's not like throwing .debs out there (and even they have a configuration context)
12:27:22 <maerwald> that is what the distro does
12:27:23 <shapr> so I did a bunch of Haskell webdev this past week, it's been great fun
12:27:32 <shapr> I learned about html-to-blaze and html-to-lucid
12:27:37 <shapr> they're pretty cool
12:27:48 <shapr> I used to do a bunch of html mockup -> 'real' website
12:27:59 <shapr> but this is the first time I've done it in Haskell
12:28:43 <shapr> learned how to put unique constraints on a persistent db
12:30:06 <shapr> now that I've done stuff with persistent, what are other good type <-> db libraries to try?
12:30:28 <monochrom> GHC ABI breakage is not going to be fixed because no one wants to turn off optimizations.
12:31:20 <monochrom> Hugs doesn't have these problems in the first place.  The bliss of using an interpreter.
12:31:20 <maerwald> Yeah, and it's probably not easy either way. But it's the reason dynamic linking sucks, which is another reason people come up with PvP or semantic versioning, which is the reason people stop caring about breaking *API*, which is the reason of an overly complicated dependency graph, which is the reason...
12:31:24 <maerwald> ...of the tool mess :>
12:32:06 <shapr> I like building websites in Haskell
12:32:12 <dstolfa> maerwald: dynamic linking sucks for many reasons. this is just one reason :>
12:32:18 <maerwald> yeah
12:33:05 <maerwald> what I find interesting is... in ecosystem/languages where the build tools are fundamentally broken, people tend to be very careful about API breakage :>
12:33:17 <maerwald> because otherwise everything is broken
12:33:35 <maerwald> now that we have stack, we can just keep breaking API and not care!
12:34:06 <dstolfa> maerwald: except when stack doesn't want to work because lib A depends on lib B version 1.0 and lib C depends on lib B verison 1.1
12:34:07 <maerwald> I'm a bit sarcastic, but only a bit...
12:34:09 <dstolfa> version*
12:34:20 <__monty__> shapr: Most type heavy db interface is probably opaleye-sot (sugar on top) which I think was renamed to "Tisch"?
12:34:31 <monochrom> Use the waterfall model to eliminate API breakage altogether, right at the root cause.
12:34:38 <maerwald> lol
12:34:53 <ystael> shapr: We moved from Persistent/Esqueleto to Opaleye over the past year because we were unhappy with the limits Persistent/Esqueleto imposed on the queries we could phrase. We wrote a Template Haskell library to control some of the boilerplate, which I think we're going to open source when we have cycles to do so.
12:35:22 <maerwald> ystael: cool, is there a blog post about that?
12:35:34 <maerwald> (consider that also advertisement for your company!)
12:35:51 <ystael> not yet :| (and yes, we know we need to get it out there for that as well as public service reasons)
12:36:07 <__monty__> ystael: My understanding was esqueleto got in the way less not more could you give some examples?
12:36:56 <ystael> __monty__: I don't have a detailed example easily accessible of what pushed us in that direction, sorry. We wanted to write some icky joins and they were worse in Esqueleto than in Opaleye.
12:37:54 <__monty__> Hmm, isn't joins a common critique of opaleye? (Something about subselects?)
12:38:18 <ystael> Dan Fithian, the developer who did most of the work on this feature, gave a talk on some related work at LambdaConf a couple weeks ago, but Opaleye wasn't the primary focus.
12:41:20 <ubvnoxn> Is there a way to avoid a [-Wmissing-methods] warning when I know its ok not having a method implementation, without disabling the warning?
12:41:56 <geekosaur>   method = undefined?
12:42:02 <ubvnoxn> (I'm coding a A TypeError instance)
12:42:12 <geekosaur> (or = error "don't do that", etc.)
12:42:13 <byorgey> ubvnoxn: method = error "This method is unpossible" ?
12:42:48 <byorgey> I do stuff like that sometimes, e.g. when making a Num instance for which stuff like abs and signum don't make sense
12:43:06 <ubvnoxn> yep, and with an indexed type?
12:43:57 <ubvnoxn> That was actually my problem, my bad for the sloppy question. My code is something like
12:44:05 <ubvnoxn> > class HasFieldRec (l::k) (r :: [(k,Type)]) where
12:44:05 <ubvnoxn> >   type LookupByLabelRec l r :: Type
12:44:05 <ubvnoxn> >   hLookupByLabelRec:: Label l -> Record r -> LookupByLabelRec l r
12:44:09 <lambdabot>  error:
12:44:09 <lambdabot>      Not in scope: type constructor or class ‘Label’error:
12:44:09 <lambdabot>      Not in scope: type constructor or class ‘Record’error:
12:44:09 <lambdabot>  <hint>:1:1: error: parse error on input ‘class’
12:44:09 <lambdabot>  <hint>:1:1: error: parse error on input ‘type’
12:45:15 <ubvnoxn> So in the typeerror instance I can put bottom in the function, but in the type?
12:45:23 <cocreature> ubvnoxn: TypeError?
12:45:39 <ubvnoxn> from GHC.TypeLits
12:45:41 <cocreature> eh ErrorMessage, sry mixed up the types
12:45:47 <cocreature> no I mean use that as the type
12:46:17 <cocreature> type LookupByLabelRec l r = TypeError (Text "impossible")
12:48:10 <ubvnoxn> Nice
12:48:37 <ubvnoxn> I was putting a nonsense value, but I knew there must be a better way
12:52:46 <shapr> ystael, __monty__ : thanks, I'll try opaleye next
12:57:02 <ubvnoxn> thank you!
12:57:32 <__monty__> shapr: Just to be clear Tisch, formerly known as opaleye-sot, is something that builds on top of opaleye, taking its design further.
13:04:00 * hackage ztar 0.0.1 - Creating and extracting compressed tar archives  http://hackage.haskell.org/package/ztar-0.0.1 (brandonchinn178)
13:22:45 <Zemyla> What do p_o files do?
13:23:34 <electrocat> Zemyla: i believe they are compiled .hs files instrumented with profiling stuff
13:27:27 <Ariakenom> newLock = do {t <- new TChan; forkIO (forever . join . atomically . getTChan $ t); return t}
13:27:28 <geekosaur> right, it's a .o file from a build with profiling enabled. which requires profiling support to be linked in, so itss distinct from normal .o
13:28:09 <Ariakenom> withLock t io = putTChan t io
13:29:56 <shapr> __monty__: sounds good to me, I'll try both
13:30:27 <hodapp> o hai shapr!
13:30:54 <shapr> hi hodapp !
13:30:59 <hodapp> how's it going?
13:32:11 <int-e> Ariakenom: that's not nice... withLock is asynchronous; execution happens in the wrong Haskell thread; results are not returned... and why do you hate MVars?
13:32:23 <shapr> hodapp: pretty good, wrote a bunch of Haskell this past week
13:34:00 * hackage ztar 0.0.2 - Creating and extracting compressed tar archives  http://hackage.haskell.org/package/ztar-0.0.2 (brandonchinn178)
13:35:28 <hodapp> shapr: what sorta Haskell?
13:36:05 <shapr> webdev stuff
13:36:08 <hodapp> I need to revive https://github.com/hodapp87/contextual and add some 3D support to it
13:36:11 <hodapp> and maybe get it in Hackage
13:36:22 <shapr> I think files uploaded from a webform is broken in Spock, so I switched to scotty
13:36:27 <hodapp> huh
13:36:38 <shapr> had some web page mockups, and use html-from-lucid to convert those
13:36:50 <shapr> and persistent-sqlite with persistent-th
13:37:08 <Ariakenom> int-e: :) Just came to think of how to do MVars with STM. Not even sure I've ever wondered. :p
13:37:12 <hodapp> all my webdev stuff has been in Go & Bootstrap lately
13:37:38 <hodapp> but at least I can translate some of the Bootstrap know-how to Hakyll
13:38:33 <Ariakenom> int-e: withMVar (a,b) io = atomically (put a io) >> atomically (get TChan b io)
13:41:06 <pally> I want to represent a graph using a list of pairs (city, [city, dest]) but [ ("New York", ["Kansas", "Dallas", "Toronto"]), ("Montreal", ["Calgary", "Detroit"])] is not allowed
13:41:07 <Ariakenom> take (a,b) = atomically $ get a; drop (a,b) = atomically $ put b ();
13:41:58 <pally> suggestions?
13:42:23 <hodapp> pally: err, why's it now allowed?
13:42:42 <rotaerk> pally, your syntax is backwards
13:42:52 <rotaerk> or just wrong, rather
13:43:04 <rotaerk> :t [ ("New York", ["Kansas", "Dallas", "Toronto"]), ("Montreal", ["Calgary", "Detroit"])]
13:43:05 <lambdabot> [([Char], [[Char]])]
13:43:06 <pally> hodapp, it's allowed?  I'll try again
13:43:20 <hodapp> sorry, meant "not", not "now"
13:44:05 <rotaerk> so your list's type is [(String, [String])]
13:45:05 <int-e> > [("New York", ["Kansas", "Dallas", "Toronto"]),("Montreal", ["Calgary", "Detroit"])] >>= sequenceA -- intuitive?
13:45:08 <lambdabot>  [("New York","Kansas"),("New York","Dallas"),("New York","Toronto"),("Montre...
13:46:51 <int-e> :t foldMap sequenceA
13:46:53 <lambdabot> (Foldable t2, Applicative f, Traversable t1, Monoid (f (t1 a))) => t2 (t1 (f a)) -> f (t1 a)
13:47:26 <pally> > head [ ("New York", ["Kansas", "Dallas", "Toronto"]), ("Montreal", ["Calgary", "Detroit"])]
13:47:28 <lambdabot>  ("New York",["Kansas","Dallas","Toronto"])
13:47:50 <pally> >head  head [ ("New York", ["Kansas", "Dallas", "Toronto"]), ("Montreal", ["Calgary", "Detroit"])]
13:48:04 <pally> > head  head [ ("New York", ["Kansas", "Dallas", "Toronto"]), ("Montreal", ["Calgary", "Detroit"])]
13:48:06 <lambdabot>  error:
13:48:07 <lambdabot>      • Couldn't match expected type ‘[[([Char], [[Char]])] -> t]’
13:48:07 <lambdabot>                    with actual type ‘[a0] -> a0’
13:48:47 <geekosaur> you need parens
13:48:48 <pally> I want the grab the adjacency list of vertex "New York"
13:49:08 <pally> > last  (head [ ("New York", ["Kansas", "Dallas", "Toronto"]), ("Montreal", ["Calgary", "Detroit"])])
13:49:10 <geekosaur> 'head head' means applying the function head to the function head, not applying it twoce
13:49:11 <lambdabot>  error:
13:49:11 <lambdabot>      • Couldn't match expected type ‘[a]’
13:49:11 <lambdabot>                    with actual type ‘([Char], [[Char]])’
13:49:34 <geekosaur> it's a tuple; snd, not last
13:53:14 <pally> geekosaur, what if I have an n-tuple?  how do I get i-th?
13:55:27 <geekosaur> tuples aren't iterables; you define your own
13:55:43 <__monty__> pally: Prelude doesn't go past septuples I think.
13:55:44 <geekosaur> (there are ways to do it, mostly ugly or painful in one way or another. if you intend a list, use a list)
13:56:01 <geekosaur> __monty__, 15 for some things, 6 for others
13:56:20 <geekosaur> 63 is the max if you don't need typeclass instances for them
13:58:56 <__monty__> geekosaur: Hmm, good to know, doubt I'll ever need the knowledge though : )
13:59:32 <geekosaur> it could in theory be higher but the runtime used to dump core on larger tuples. don't think anyone has tested recently though
14:02:39 <pally> I am looking through http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-List.html but can't find a function that allows me to grab the i-th element of a list
14:03:32 <ddellacosta> pally: (!!) is what you want although it's not efficient
14:03:33 <ddellacosta> http://hackage.haskell.org/package/base-4.11.1.0/docs/Prelude.html#v:-33--33-
14:03:54 <ddellacosta> > [1,2,3] !! 2
14:03:57 <lambdabot>  3
14:04:28 <rotaerk> > [1,2,3] !! (-1)
14:04:30 <lambdabot>  *Exception: Prelude.!!: negative index
14:04:41 <ddellacosta> ...and yeah, it's partial
14:05:09 <dmwit> pally: Generally: don't want that. =P
14:05:31 <infinisil> It can't really be efficient can't it
14:05:40 <ddellacosta> yeah, if you find yourself doing that a lot you probably want Vector or something
14:05:41 <rotaerk> I use it when I'm feeling too lazy to switch to arrays, until I have reason to optimize it
14:05:43 <geekosaur> Lists are best thought of as loops encoded as data; if you want positional indexing, consider Vector
14:07:26 <pally> geekosaur, thanks :-)
14:08:07 <pally> rotaerk, Data.Array is immutable, I need to add and remove items to/from the collection
14:08:19 <monochrom> Or you should still use list but you rethink your algorithm, e.g., [f (xs !! i) | i <- [0.. length xs]] is some people's first instinct but [f x | x<-xs] and (map f xs) are simpler and more direct and less XY problem.
14:09:14 <ddellacosta> pally: you can certainly add/remove items from an immutable collection depending on how you structure your algorithm. If you really need something mutable though, there are mutable Vectors
14:09:34 <ddellacosta> https://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector.html#g:38
14:11:53 <pally> how is [f x | x<-xs]  gonna get me the ith item from xs?
14:12:08 <pally> that's list comprehension, right?
14:13:27 <monochrom> I didn't say it would.
14:14:31 <monochrom> I said the other way round: some people thought that getting the ith item from xs was necessary to compute map f xs.
14:19:30 * hackage containers-verified 0.6.0.1 - Formally verified drop-in replacement of containers  http://hackage.haskell.org/package/containers-verified-0.6.0.1 (JoachimBreitner)
14:21:14 <monochrom> w00t formally verified
14:21:36 <johnw> monochrom: and a paper to go with it too :)
14:21:42 <monochrom> yikes
14:22:06 <hodapp> oooh...
14:23:08 <__monty__> Any super impressive side benefits, like it's twice as space efficient now?
14:23:34 <monochrom> No, I think it's just twice as correct. :)
14:23:41 <Tuplanolla> The proofs probably don't concern time or space.
14:27:58 <XorSwap> :t \h e y m 4 t -> undefined
14:28:00 <lambdabot> (Num a1, Eq a1) => p1 -> p2 -> p3 -> p4 -> a1 -> p5 -> a2
14:29:58 <__monty__> Tuplanolla: I was just hoping the tedious process of formalization had uncovered some opportunities for optimization.
14:30:19 <Tuplanolla> I guess that's still possible.
14:31:30 <dstolfa> __monty__: the point is to just show that the thing you've specified holds certain desirable properties and then to prove that the haskell code actually refines the abstract specification
14:32:32 <__monty__> dstolfa: I know. That requires understanding what the haskell code does afaiu, which might lead to finding some spots that could be improved.
14:32:42 <dstolfa> __monty__: yep
14:32:59 <dmwit> I don't know of any formally verified software which is faster than its unverified counterpart.
14:33:25 <__monty__> I thought I'd heard about performance improvements in containers-verified before it was finished.
14:34:10 <phadej> __monty__: the changelog does say so http://hackage.haskell.org/package/containers-0.6.0.1/changelog
14:34:16 <phadej> Speed up Data.Set.union. (Thanks, Joachim Breitner.)
14:34:51 <__monty__> Aha, it wasn't merely a figment of my imagination.
14:35:02 <phadej> also the paper says that they didn't found any errors in containers, it's too well tested already
14:35:42 <dstolfa> dmwit: to be fair, that's mostly because there is a lack of formal semantics for the refined version, so you can only perform the transformations that you can show are correct. if we had formal models of the ISA that were verified by proofs in the uarch, we could build formally verified compilers that are potentially faster than current ones because we could see what we actually do in the uarch, and
14:35:48 <dstolfa> therefore could transform it to another valid state that satisfies these properties but maybe has better cache coherence
14:36:03 <phadej> ... and – since we found no bugs – attest to the superb quality of well-tested
14:36:07 <phadej> functional code
14:36:39 <dmwit> https://github.com/haskell/containers/commit/b1a05c3a26408b1af71e86cb450d41c3fed6884b looks like the commit in question. 3-4% speed increase is pretty small.
14:37:27 <dmwit> But I agree it's not nothing.
14:40:11 <__monty__> Small improvement from a small change seems reasonable.
14:57:53 <rotaerk> > show "aoeu"
14:57:56 <lambdabot>  "\"aoeu\""
14:58:10 <rotaerk> > show "aoeu\n"
14:58:12 <lambdabot>  "\"aoeu\\n\""
14:58:17 <__monty__> dv buddies! : )
14:58:23 <rotaerk> :P
15:04:55 <geekosaur> @v
15:04:55 <lambdabot> "\"#$%&'()*+,\""
15:24:25 <drbrule> where is the preferred pastebin to drop code for questions?
15:29:08 <electrocat> @where lpaste
15:29:08 <lambdabot> http://lpaste.net/
15:29:15 <maerwald> drdo: https://privatebin.net/
15:29:19 <maerwald> drbrule: ^
15:32:11 <drbrule> thank you
15:58:23 <UnkDevE> hey, is it possible for anyone to help me with some code?
15:58:53 <glguy> UnkDevE: Just ask your actual question and if someone's available to help with it they will.
15:59:02 <UnkDevE> thanks
15:59:07 <glguy> Depending on the question that can happen quickly or it can take some time
16:10:39 <UnkDevE> I have a recursive function which counter doesn't seem to increment
16:11:14 <fishythefish> UnkDevE: what is `counter`? can you just link to some code?
16:11:16 <fishythefish> @where lpaste
16:11:16 <lambdabot> http://lpaste.net/
16:11:33 <UnkDevE> cool https://github.com/UnkDevE/LMCEmulatorHaskell/blob/master/LMCEmulator.hs#L279
16:12:03 <Mrd1> SeleQ
16:12:03 <UnkDevE> pc doesn't increment
16:14:13 <fishythefish> UnkDevE: runRam on its own doesn't increment the pc; you're doing that in inp/outp, looks like
16:14:27 <UnkDevE> yup
16:14:55 <fishythefish> why only those two instructions?
16:15:23 <fishythefish> I'd probably expect runLine to be responsible for that
16:15:36 <glguy> line 279 probably should apply runRam to the result of runLine, and not the other way around
16:16:02 <UnkDevE> good point thank you
16:16:59 <electrocat> UnkDevE: unrelated to your issue, you should pattern match on constructors instead of testing equality using `==`
16:17:35 <electrocat> and don't use unsafePerformIO this way
16:17:37 <fishythefish> the unsafePerformIO is also a code smell
16:19:26 <UnkDevE> yeah unsafePerformIO is code smell, is there any other way of doing it?
16:20:44 <electrocat> UnkDevE: how familiar are you with monads?
16:20:45 <fishythefish> one way is to just add `IO` everywhere and don't try to get back out of it, but a better approach might be to separate the act of outputting to console from the evaluation of the LMC
16:21:32 <UnkDevE> not very on the monads side
16:21:44 <fishythefish> you don't have to be familiar with monads, just with manipulating IO expressions
16:23:13 <electrocat> i could do 'StateT Environment IO' to keep it simple, you would need to make everything monadic anyway
16:24:29 <electrocat> UnkDevE: you'll learn how to do that in a more clean way eventually :p
16:24:56 <electrocat> you might want to read up about state monads
16:25:04 <UnkDevE> okay
16:26:30 * hackage ua-parser 0.7.5.0 - A library for parsing User-Agent strings, official Haskell port of ua-parser  http://hackage.haskell.org/package/ua-parser-0.7.5.0 (MichaelXavier)
16:45:43 <fdjikqw> Can anyone think of a 1 line solution to output all the primes less than some input, and append "T" to all twin primes?
16:47:04 <hpc> some people can't think of it, so no :P
16:47:04 <hodapp> something smells like homework...
16:47:31 <fdjikqw> No, a contest problem
16:50:59 <infinisil> fdjikqw: How far have you gotten
16:52:26 <DigitalKiwi> to the /join #haskell and ask them part
16:53:06 <hpc> does it have to be one line?
16:57:12 <dmwit> fdjikqw: Step 1 is do it on many lines.
16:57:16 <dmwit> Step 2 is insert semicolons.
16:58:44 <dmwit> (Step 0 is don't expect somebody else to do your work for you.)
17:09:12 <dramforever> Random announcement: vscode-ghc-simple: Simple GHC integration for VSCode, using only GHCi (experimental) https://github.com/dramforever/vscode-ghc-simple
17:10:17 <suzu> instance (FromJSValue a, JsTypeable s b) => JsTypeable s (a -> b) where
17:10:36 <suzu> does this have GHC match the `s`-es on both sides of the `=>`?
17:10:51 <dramforever> ( PS: Please don't tell me to join haskell-ide-engine here. Come over to https://www.reddit.com/r/haskell/comments/8ryjan/_/e0vbh2u/ )
17:11:30 <dramforever> suzu: yes. It's like instance forall s a b. (FromJSValue a, JSTypeable s b) => JSTypeable s (a -> b)
17:11:56 <suzu> i'm trying to use a function underneath `JsTypeable s b` in the body of `JsTypeable s (a -> b)` here and it's claiming it can't deduce (JsTypeable s1 b)
17:12:07 <zachk> how do I get websockets to error out on abnormal client disconnection, use the haskell websocket library for the server and warp/scotty, the connections aren't dying correctly when I shutoff the webbrowser, (sometimes)
17:12:42 <dramforever> suzu: Does it say anything about ambiguous types?
17:12:53 <suzu> yes. 's1' is ambiguous
17:13:10 <dramforever> Also code paste would be great, but now that lpaste is down... What do you use now?
17:13:35 <geekosaur> suzu, that's the application/use that is failing to typecheck, not the signature
17:13:50 <suzu> how do i annotate it to tell it what i mean?
17:13:54 * geekosaur would reocmmend gist.github.com tbh
17:15:29 <geekosaur> that depends. asTypeOf (which iirc is not in base but is easy to make from const) works if you already have something of the right type
17:15:50 <suzu> a typeapplication seemed to have made it go away!
17:15:53 <suzu> "@s"
17:16:10 <suzu> failing that i was going to annotate the full type of the expression
17:16:21 <suzu> failing THAT i was gonna add a proxy i guess :/
17:16:51 <dramforever> I don't think in cases like that, -XTypeApplication can really fail...
17:19:32 <suzu> it can't?
17:20:33 <dramforever> I mean, you're *literally* directly telling GHC which 's' to use
17:20:45 <suzu> lol i suppose so
17:21:02 <suzu> i didn't get the effect i wanted though :(
17:21:13 <dramforever> :(
17:21:20 <suzu> i'm trying to make an environment similar to runST, with the ranktype preventing you from leaking some things
17:21:31 <suzu> but you can also lift IO actions into this environment
17:21:44 <suzu> and it is possible to write the unleakable thing to a ioref and use it in an invalid place
17:21:49 <dramforever> Ah
17:22:14 <suzu> is this unpreventable?
17:22:37 <dramforever> wait
17:22:41 <dramforever> isn't it prevented already?
17:22:47 <suzu> no?
17:22:57 <dramforever> I mean
17:23:19 <dramforever> maybe you can wrap the unleakable thing in a existential type and try to use it later on
17:23:37 <dramforever> but when you try, the type variable s would be different (or rather, not known to be the same)
17:23:56 <dramforever> like, you can't return a STRef from runST
17:24:20 <suzu> right. but i have an IORef here
17:24:28 <suzu> so you can write the value there and read it later
17:24:38 <dramforever> but the types won't match up
17:24:58 * dramforever is still pretty sure
17:25:40 <suzu> they do :(
17:25:44 <suzu> well, perhaps i'm doing something wrong
17:25:57 <dramforever> suzu: wait, do your unleakable things have 's' in the types?
17:26:03 <dramforever> Remember 'STRef s a'
17:26:17 <suzu> yes
17:26:19 <suzu> they do
17:26:23 <dramforever> That's weird
17:26:46 <dramforever> Care to share the code?
17:26:53 <suzu> well, if you are writing the body of `Unleakable s a -> IO ()`
17:27:09 <suzu> you can write it to an ioref
17:27:25 <suzu> and then in a different environment you can read it out
17:27:49 <dramforever> 'different environment' shouldn't that have a different 's'?
17:28:14 <suzu> it's be a type of `Env s a)
17:28:17 <suzu> (Env s a)
17:28:23 <suzu> and yes the s would be different
17:28:30 * hackage alex-tools 0.4 - A set of functions for a common use case of Alex.  http://hackage.haskell.org/package/alex-tools-0.4 (IavorDiatchki)
17:28:30 <suzu> or at least, no guarantee they are the same
17:28:42 <dramforever> And so you aren't supposed to be use them
17:28:48 <dramforever> Did I get that right?
17:28:56 <suzu> i thought so too but that's false
17:29:32 <dramforever> That's like, really, really weird...
17:30:05 <dramforever> Like, how could you even have the IORef in the first place?
17:30:09 <dramforever> What's its type?
17:30:10 * hackage panic 0.4.0.1 - A convenient way to panic.  http://hackage.haskell.org/package/panic-0.4.0.1 (IavorDiatchki)
17:30:16 <suzu> lemme put together a small example
17:30:25 <suzu> maybe i'm misunderstanding something
17:30:40 <dramforever> Ah, ues
17:30:45 <dramforever> *yes, panic
17:32:26 * AfC waves
17:34:42 * dramforever waves back
17:34:54 <dramforever> welcome :)
17:42:52 <suzu> ok i wrote it and it appears you are correct
17:42:54 <suzu> lol
17:43:05 <suzu> so i must have made a mistake somewhere
17:44:51 <suzu> i must be using s in some place where it shouldnt be visible
17:44:58 <suzu> dramforever
17:46:45 <dramforever> yay
17:50:58 <w1n5t0n> hi, I have a function "t :: Reader Double Double" which simply returns the context, how can I make it an instance of num so I can do something like "aFunc :: Reader Double Double; aFunc = 2 + t" which will return a reader that adds 2 to the context?
17:51:58 <w1n5t0n> sorry, not sure if "function" is the proper term for t
17:53:22 <suzu> you can use `ask` which is `Reader a a`
17:53:33 <suzu> so it will give you whatever you put in the reader, out
17:53:54 <dramforever> 1. You probably want to wrap your Reader into a newtype. In fact, (->) is basically the same but easier to use.
17:54:08 <dramforever> From now on I assume you have newtype Fn a = Fn (Double -> a) with Functor, Applicative, Monad instances.
17:54:24 <suzu> you cannot make a reader that adds to the context. you aren't allowed to modify the context
17:54:35 <dramforever> 2. Then just do it :) instance Num a => Num (Fn a) where ...
17:54:37 <suzu> but you can instead run a different reader with a new context that is the old context, plus two
17:55:04 <dramforever> Oh hey
17:55:32 <zachk> w1n5t0n, you probably want State instead of Reader
17:55:43 <dramforever> w1n5t0n: wait, t is (Reader id), and you want (2 + t) to be (Reader (\x -> 2 + x)), right?
17:56:06 <dramforever> I'm pretty sure w1n5t0n is talking about my thing
17:56:17 <dramforever> considering that t probably means a parameter
17:57:00 <dramforever> 'independent variable'. Is that what it's called?
17:57:14 <w1n5t0n> dramforever: I think that's what I mean, what I want is to be able to map a single-argument function over a domain, and for "t" to return each input from that domain
17:57:22 <dramforever> yay
17:57:33 <dramforever> then what's stopping you? Just write your instance
17:58:29 <dramforever> like, you need to define fromInteger :: Integer -> Fn a, and you have (Num a), so you can use fromInteger :: Integer -> a, so fromInteger = pure . fromInteger
17:58:58 <dramforever> and (+) :: Fn a -> Fn a -> Fn a from (+) :: a -> a -> a, which is from (Num a), so (+) = liftA2 (+)
17:59:27 * dramforever regrets throwing like millions of combinators there... but that's literally what it's for
18:03:37 <w1n5t0n> dramforever: ok that makes more sense but it'll take some time to work through it, thanks!
18:04:21 <dramforever> I mean
18:04:29 <dramforever> you *can* write it out more explicitly...
18:04:38 <dramforever> w1n5t0n: do you actually know liftA2?
18:06:40 <suzu> ok dramforever i found an example where it fails
18:07:18 <w1n5t0n> dramforever: yes I understand its concept, I'm just having some trouble piecing it all together in my head
18:10:16 <suzu> dramforever: https://lpaste.net/6170621948440084480
18:11:06 <dramforever> how were you able to post to lpaste??? It's completely not working for me
18:11:10 <Axman6> w1n5t0n: instance Num a => Num (Reader a a) where fromIntegral x = pure (fromIntegral x); (+) = liftA2 (+); (*) = liftA2 (*); etc.
18:11:27 <suzu> i don't know? it is working here
18:12:03 <suzu> try the ip directly dramforever ? 46.101.213.195
18:12:57 <dramforever> suzu: same, try https://gist.github.com maybe?
18:13:45 <w1n5t0n> Axman6: I get an "Illegal instance declaration... (All instance types must be of the form (T t1 ... tn), where T is not a synonym)" when I try that
18:14:31 <geekosaur> right, it's duplicating a type variable, needs FlexibleContexts iirc
18:14:51 <dramforever> Put {-# LANGUAGE FlexibleInstances #-} (or FlexibleContexts, whatever the compiler said) at the beginning of the file
18:16:06 <suzu> dramforever: https://pastebin.com/4fK02Fbw
18:16:08 <dramforever> w1n5t0n: Or listen to me and newtype Fn a = Fn { runFn :: a -> a }
18:17:20 <dramforever> suzu: uhh, ever considered this? runEnv :: (forall s. Env s a) -> IO a
18:17:22 <dramforever> I mean,
18:17:25 <dramforever> :t runST
18:17:27 <lambdabot> (forall s. ST s a) -> a
18:21:16 <suzu> dramforever: this example, as it is, does not compile (which is correct)
18:22:00 <dramforever> uhh
18:22:03 <suzu> but if i comment that one impl of runAction and uncomment the other one
18:22:09 <dramforever> wat
18:22:13 <suzu> it will compile, and i don't want it to
18:22:47 <suzu> dramforever: this doesn't compile. uncomment 38-43 and comment 30-35 and it will compile
18:22:50 <dramforever> Do you have to use the commented out one...?
18:22:55 <suzu> yes
18:23:02 <suzu> that's how my program works
18:23:11 <suzu> it'll accept functions that match a typeclass like this
18:25:15 <dramforever> So!
18:25:25 <dramforever> have you considered runEnv :: (forall s. Env s a) -> IO a
18:25:42 <suzu> yes. i tried that ,it doesn't change anything
18:25:50 <suzu> you can compile the code
18:26:40 <dramforever> Ah, I see, it's the problem with 's'
18:26:57 <dramforever> runAction is polymorphic in 's'...
18:27:27 <suzu> well, both are
18:27:36 <suzu> so that isn't it
18:29:10 <hololeap> i read a lot about how haskell (ghc) isn't very good for running a 3d game engine on because of the hiccups related to the GC. how would it fare as a realtime (as much as possible anyway, some latency is ok) audio synthesis engine?
18:29:39 <dramforever> So my idea is that you need something like (forall s. Unleakable s -> Env s a) -> IO a
18:29:47 <dramforever> That's really unleakable (I hope!)
18:30:02 <ammar2> hololeap: sounds like the same problem, GC doesn't add latency, it adds intermittent pauses
18:30:15 <ammar2> so the same problem of game engines would apply
18:30:58 <suzu> dramforever: that works but i can't do that
18:30:59 <dramforever> This gets weird
18:31:05 <dramforever> like, really weird
18:31:05 <suzu> i need this typeclass
18:31:15 <monochrom> Haskell (generally GC) would be OK for 3D game engines for turn-based strategy games such as Civ 6. >:)
18:31:29 <dramforever> suzu: and really do you know anything about a?
18:31:35 <dramforever> In line 32
18:32:00 <suzu> i know that it is an instance of a different typeclass, in practice
18:32:03 <suzu> but that doesnt help
18:32:18 <monochrom> As for real-time strategy games, you know what, AoE2 had noticeable pauses too every time the computer player planned an attack against me.  And I was actually thankful!
18:32:37 <dramforever> suzu: You probably want to add s to the other typeclass...
18:32:49 <dramforever> Oh wait
18:33:07 <dramforever> IsAction (IO ()) is like not helping
18:33:21 <dramforever> You need something like IsAction (Action s ())
18:33:31 <dramforever> Like, IsAction s (Action s ())
18:33:53 <dramforever> and instance (IsAction s tail, SomeOtherThing s a) => IsAction s (a -> tail)
18:33:57 <suzu> sure, i can newtype wrap IO with a new type Action but that doesn't help
18:34:08 <dramforever> Perhaps with a fundep class IsAction s a | s -> a
18:34:08 <suzu> and adding s to IsAction doesn't help
18:34:19 <dramforever> You need to add s to the other typeclass
18:34:20 <suzu> ohh a fundep
18:34:33 <dramforever> otherwise this isn't even a implementable typeclass
18:34:40 <dramforever> (how are you supposed to give any a)
18:34:52 <suzu> suppose that a must always be numeric
18:35:09 <dramforever> I know what confused me now. You literally pulled an Unleakable s out of nowhere
18:35:14 <suzu> so it is a variadic function that takes any number of Num-s and then returns IO ()
18:35:22 <dramforever> and it's bad
18:35:28 <suzu> i dont understand
18:35:35 <dramforever> because it needs to return Action s ()
18:35:48 <dramforever> ah
18:35:49 <dramforever> wait
18:35:53 <dramforever> wait wait wait
18:36:00 <dramforever> runAction is the 'super liftIO' part
18:36:05 <suzu> yes
18:36:08 <dramforever> ah
18:36:58 <suzu> so i still don't know how to get the compiling version to fail
18:37:01 <dramforever> suzu: 'any number of Num-s and then returns IO ()' but 'write' isn't that
18:37:13 <suzu> this is an example
18:37:19 <dramforever> you need to pass the 's' down to Unleakable somehow
18:37:22 <dramforever> This is necessary
18:37:49 <suzu> oh ok let me implement that
18:39:16 <suzu> dramforever: https://lpaste.net/6830822786215182336
18:39:33 <dramforever> well, lpaste, nope :p
18:39:43 <suzu> functions may be variadic in numeric values, or can take an unleakable value
18:39:46 <suzu> argh one sec
18:39:55 <dramforever> I mean, someone really need to look into this...
18:40:18 <suzu> https://pastebin.com/jJmjZULi
18:40:38 <suzu> dramforever ^
18:41:05 <dramforever> Ok
18:41:09 * dramforever rolls up sleeves
18:41:23 <suzu> ty for your help btw :)
18:49:06 <dmwit> suzu: For that to work, `newIORef Nothing` would have to give you an `IORef (Maybe (forall s. Unleakable s))`, but it doesn't, it gives you an `forall s. IORef (Maybe (Unleakable s))`.
18:49:09 <dramforever> https://pastebin.com/LNr2qPQx
18:49:14 <dramforever> suzu ^
18:49:40 <dramforever> I can't put in the fundep because Integer -> IO a isn't going to be related to s in any way...
18:50:11 <dmwit> Hm. I should maybe leave this one alone, since it seems I'm missing a bunch of context.
18:50:51 <dramforever> This is like
18:50:58 <dramforever> three problems mixed together
18:51:10 <dramforever> I think I mixed it well
18:54:05 <suzu> ahmm i tried this before
18:54:09 <suzu> and it would work when it shouldn't
18:55:02 <dramforever> did you have the 'forall' here? runEnv :: (forall s. Env s a) -> IO a
18:55:36 <suzu> no. that doesn't do anything afaict
18:57:14 <suzu> i feel like this doenst work for a.. different reason
18:58:31 <suzu> ok nope that's legit
18:59:11 <suzu> it can't infer that there's an (IsAction s (Unleakable s -> x)) given just the s in the Unleakable
19:01:34 <dramforever> I mean, not even infer
19:01:40 <dramforever> s1 is fundamentally different from s
19:16:30 * hackage pandoc-crossref 0.3.2.1 - Pandoc filter for cross-references  http://hackage.haskell.org/package/pandoc-crossref-0.3.2.1 (lierdakil)
19:36:34 <suzu> yeah
19:36:36 <suzu> ok
19:36:38 <suzu> hmm
19:36:44 <suzu> this error message makes this very unclear though
19:37:01 <suzu> if i wanted to be abl eto create iorefs to store this value -- but restrict them only to work inside Env, how woudld i do it?
19:38:00 * hackage apecs 0.4.0.0 - A fast ECS for game engine programming  http://hackage.haskell.org/package/apecs-0.4.0.0 (jonascarpay)
19:43:38 <hololeap> just a question on people's opinion: can using a Reader monad be easier to read at times compared to nested clauses like `where`, `let`, `case`?
19:44:59 <hololeap> or `do`
19:45:09 <geekosaur> I would not usually use one in place of any of those
19:45:18 <glguy> I don't know what those all have to do with each other
19:46:50 <mniip> I don't think I can conceive a case where I'd use a Reader monad do-block outside of a larger monadic transformer stack
19:47:08 <mniip> provided, I do use the Reader monad operations themselves often (bind, ap, join)
19:55:01 <hololeap> it seems like even ReaderT can be replaced with an extra parameter in the function. `func r = action >>= (\a -> actionF r)` vs. `func = action >>= (\a -> (ask >>= (\r -> actionF r))`
19:56:05 <lukelau> Is it possible to get a more detailed version from System.Info’s compilerVersion?
19:56:12 <glguy> hololeap: That's all the Reader is
19:56:20 <lukelau> It’s just returning 8.4 for me, I’d like to get the .3 as well
19:56:26 <geekosaur> hololeap, that's what Reader / ReaderT *is*
19:57:12 <mniip> hololeap, sure, all monad operations can be inlined because they are defined using haskell code
19:57:54 <hololeap> right, it's just a newtype of (r -> a) or (r -> m a). but my question is, when does it make sense to use Reader/ReaderT instead of doing the whole nested parameters thing.
19:58:05 <geekosaur> lukelau, no. I think you can use CPP to get it. https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/phases.html#standard-cpp-macros
19:58:09 <mniip> when you have other transformers already
19:58:15 <mniip> so a ReaderT on top adds no additional cost
19:58:42 <mniip> notably when you are passing some sort of environment
19:59:00 <mniip> that you may wish to "locally override" in some bounded block
19:59:06 <mniip> cf 'local'
20:00:02 <hololeap> ok, i could see how that would come in handy sometimes
20:00:38 <mniip> last time I properly used Reader when I was writing a (to-) brainfuck compiler
20:01:01 <mniip> the environment would contain the assignments of the tape to variables that are local to blocks
20:01:09 <lukelau> geekosaur: thanks!
20:01:37 <hololeap> uh
20:02:03 <mniip> well, local variables are syntactically local, right?
20:02:19 <hololeap> first of all, what are "blocks"?
20:02:38 <mniip> well consider this
20:03:01 <mniip> do local f $ foo; bar
20:03:03 <mniip> versus
20:03:03 <geekosaur> regions with lexical scopes attached
20:03:07 <mniip> do modify f; foo; bar
20:03:17 <mniip> the former "reverts" the environment for 'bar'
20:03:19 <geekosaur> which probably doesn't help, but this may not make sense at all in that case :)
20:03:22 <mniip> the latter (StateT) doesn't
20:05:24 <hololeap> ok, i'm mostly with you
20:05:46 <hololeap> i would need an example of a block to understand that part
20:06:21 <hololeap> but you can have nested environments that "disappear" when the inner action is completed
20:07:30 <mniip> yes
20:07:40 <mniip> it's a neat thing
20:08:24 <hololeap> that helps me understand its purpose other than an educational tool. thanks
20:08:55 <mniip> GHC uses ReaderT all over the place
20:11:11 <hololeap> :t local
20:11:12 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
20:13:08 <mniip> on a second thought, HscEnv is a StateT-type variable
20:13:24 <mniip> the Session you see in reifyGhc/reflectGhc is just an IORef...
20:14:14 <mniip> so I suppose GHC really just emulates StateT with ReaderT IORef
20:14:28 <mniip> I wonder if there's a good reason
20:14:47 <hololeap> some performance tweak?
20:14:54 <mniip> probably because StateT s IO a ~ s -> IO (s, a)
20:15:02 <mniip> in case the IO throws the s is not retained in any way whatsoever
20:15:24 <hololeap> oh, sure... IO is a tricky one
20:28:27 <dmwit> :t maybe (:) id
20:28:28 <lambdabot> Maybe (a -> [a] -> [a]) -> a -> [a] -> [a]
20:28:54 <dmwit> :t maybe id (:)
20:28:56 <lambdabot> Maybe a -> [a] -> [a]
20:30:29 <mniip> :t mappend . maybeToList
20:30:30 <lambdabot> Maybe a -> [a] -> [a]
20:30:44 <dmwit> :t (++) . toList
20:30:45 <lambdabot> error:
20:30:45 <lambdabot>     Ambiguous occurrence ‘toList’
20:30:45 <lambdabot>     It could refer to either ‘F.toList’,
20:30:56 <dmwit> There's another toList?
20:31:26 <mniip> @more
20:31:26 <lambdabot> Plugin `more' failed with: Prelude.init: empty list
20:31:53 <dmwit> :t Lambdabot.Plugin.Haskell.Eval.Trusted.toList
20:31:55 <lambdabot> IsList l => l -> [Item l]
20:32:40 <dmwit> :t (++) . F.toList
20:32:41 <lambdabot> Foldable t => t a -> [a] -> [a]
20:32:50 <mniip> hmm check this out
20:33:10 <mniip> :t (F.toList .) . (:*:)
20:33:11 <lambdabot> error:
20:33:11 <lambdabot>     Data constructor not in scope: (:*:) :: a -> a1 -> [a2]
20:33:18 <mniip> :t (F.toList .) . (GHC.Generics.:*:)
20:33:19 <lambdabot> (Foldable g, Foldable f) => f a -> g a -> [a]
20:33:41 <dmwit> neat
20:34:44 <dmwit> `maybe id (:)` requires less magic from both reader and compiler. I'm going to stick with it.
20:36:29 <mniip> :t \x -> lift x >>= tell
20:36:30 <lambdabot> (MonadWriter w (t m), Monad m, MonadTrans t) => m w -> t m ()
20:37:15 <mniip> no wait that goes on the other end
20:38:48 <pally> "zipWith is right-lazy"
20:38:54 <pally> What does right-lazy mean?
20:39:50 <mniip> > zipWith (error "f") (error "l") []
20:39:52 <lambdabot>  *Exception: l
20:39:58 <mniip> > zipWith (error "f") [] (error "r")
20:40:00 <lambdabot>  []
20:40:03 <mniip> basically this
20:42:16 <dmwit> Exercise: use `unamb` to create a `zipWith` which is both left-lazy and right-lazy.
20:45:17 <mniip> unsafeIsEvaluated = const False
20:45:21 <mniip> sounds fully functional
20:46:30 <dmwit> :t flip . zipWith . flip
20:46:32 <lambdabot> (b -> a -> c) -> [b] -> [a] -> [c]
20:48:19 <pally> > const (3+4) (div 1 0)
20:48:21 <lambdabot>  7
20:48:49 <pally> also right-lazy
20:49:22 <dmwit> It's harder to make that one left-lazy, though. =)
20:50:52 <mniip> flip seq
20:53:13 <dmwit> ...is also not left-lazy.
20:55:17 <mniip> right-strict though :p
20:55:22 <dmwit> yes =)
20:59:02 <pally> "right-strict though :p" I wish I knew what the amusement is about. lol
20:59:28 <dmwit> I asked him to make it lazier in the first argument. Instead he made it stricter in the second argument.
20:59:35 <dmwit> It's... I don't know. Perverse. =)
21:01:52 <mniip> strictness is relative
21:03:23 <mniip> bottoms requiring infinite time to evaluate is a result of time dilation :p
21:28:36 <jared-w> lol
21:28:51 <jared-w> "bottoms are merely finite values traveling at lightspeed"
21:30:15 <rotaerk> my bottom is pretty stationary
21:31:52 <geekosaur> jared-w, or with infinite mass. >.>
21:32:04 <jared-w> is that just because it hasn't been observed yet, rotaerk? /s
21:33:22 <rotaerk> lol
21:47:29 * hackage boolector 0.0.0.1 - Haskell bindings for the Boolector SMT solver  http://hackage.haskell.org/package/boolector-0.0.0.1 (DeianStefan)
22:11:39 <Orbstheorem> Hi, so I'm studing actors (notabbly akka), I'm wondering if there's an “actor” monad: I guess it's signature would be something like `Msg a, Actor b => a -> ([a], [b])` where `become` would be returning multiple a and sending messages would be returning multiple b
22:16:54 <Ariakenom> Orbstheorem: I believe there's cloud haskell and their Process monad
22:20:49 <Mrd1> Hei.....
22:21:30 <Ariakenom> Orbstheorem: I don't know if you're interested but for running on one machine I'd guess the Async and STM libraries is a good bet.
22:23:37 <Orbstheorem> I'm looking at Cloud haskell, and process looks very close to what I had in mind!
22:23:39 <Orbstheorem> Thanks!
22:39:32 <simon> I'm modelling an AST for an assembler language with instructions DUP1-DUP32, but having all those as constructors seems tedious.
22:40:54 <simon> it also has PUSH1-PUSH32, but those are identified by a constant the size of that number of bytes, so I made one single PUSHN [Word8] constructor. for DUPN I can't because it doesn't have an argument of size N.
22:41:30 <simon> (ideally I'd want at most 32 bytes, but [Word8] is perhaps sufficient.)
22:42:42 <simon> I'll just go with 'DUP Int'.
23:29:00 * hackage elf 0.29 - An Elf parser  http://hackage.haskell.org/package/elf-0.29 (wangbj)
23:32:43 <jle`> acme-elf should just be quotes from the movie
23:37:58 <mupf> Hello guys, for some reason I can't see my input in ghci anymore
23:38:08 <mupf> any idea why this might be?
23:38:31 <mupf> I can enter expressions etc but I simply can't see them
23:38:56 <dminuoso> mupf: Perhaps your tty is messed up?
23:39:31 <mupf> I use urxvt_unicode
23:40:00 * hackage potoki 2.0.1 - Simple streaming in IO  http://hackage.haskell.org/package/potoki-2.0.1 (IrinaArtemeva)
23:40:06 <mupf> I try something
23:40:34 <mupf> Okay, it works when I delete my .ghci configuration
23:40:43 <infty> Does one ever get used to the prefix notation of function composition?
23:41:14 <cocreature> infty: sure, I find it quite intuitive at this point
23:41:29 <dminuoso> infty: what's that? Do you mean `(.) f g`?
23:41:36 <cocreature> if you think about the fact that (f . g) x = f (g x) the order makes a lot more sense
23:41:41 <mupf> okay, it was misconfiguration. fixed it
23:41:47 <cocreature> oh I think I might have misunderstood the question
23:42:56 <infty> When writing a composite function, I tend to imagine a process starting from the innermost argument (e.g.
23:43:08 <infty> "take a string, then reverse it, then truncate it"
23:44:00 <Ariakenom> :t (&)
23:44:02 <lambdabot> a -> (a -> b) -> b
23:44:04 <infty> ) but the syntax starts with the outermost process
23:44:24 <dminuoso> infty: What exactly do you mean by "prefix notation of function composition"
23:44:38 <Ariakenom> > let (%) = flip (.) in "Hello" & reverse % take 2
23:44:41 <lambdabot>  "ol"
23:45:14 <cocreature> dminuoso: I think they mean the fact that f . g first applies g and then f to the result of that instead of the other way around
23:45:18 <infty> dminuoso: I mean that f followed by g is written g.f, and not f.g
23:45:35 <dminuoso> cocreature: So curious.. how the heck did you understood him right based on that!
23:45:45 <Ariakenom> dminuoso: I dunno. it's wrong!
23:45:45 <dminuoso> :D
23:45:47 <cocreature> dminuoso: because it’s a common complaint :)
23:45:55 <dminuoso> Ah I suppose.
23:46:17 <infty> Sorry I was imprecise
23:46:39 <cocreature> infty: fwiw if you prefer the other style there are libraries that make that easy, e.g., https://hackage.haskell.org/package/flow-1.0.12/docs/Flow.html
23:46:47 <cocreature> there is also (&) for flipped function application in "base"
23:47:17 <Ariakenom> prefix is as dminuoso said (.) f g
23:47:53 <monochrom> Consider f >>> g
23:48:14 <infty> cocreature: Thanks, I was not aware of those
23:48:53 <cocreature> infty: but if you want to write Haskell you should at least be able to read code that uses (.) easily as well. otherwise you’ll have a hard time given that this is what most of the ecosystem uses
23:49:40 <infty> Ariakenom: I borrowed the terminology from https://en.wikipedia.org/wiki/Function_composition#Alternative_notations but perhaps I mistakenly took "prefix" to mean the reverse of "postfix"
23:51:23 <monochrom> Unfortunately "g . f" is postfix in "f" but infix in "." so it's infix too.
23:51:59 <infty> cocreature: That's a valid concern. I'm mostly wondering how people write their code: do you actually think of the outermost process first? The alternative seems to require a lot of cursor movement and parenthesis insertion.
23:52:45 <cocreature> infty: it depends™. (.) encourages a top-down approach where you start with what you want to return and then construct step-by-step how you get there
23:53:11 <cocreature> flip (.) encourages a more bottom-up approach where you start with your inputs and then move towards the output
23:53:22 <cocreature> which approach is preferable depends on preference and the problem at hand
23:53:34 <dminuoso> Is it possible that (>=>) is far more common than (<=<) though?
23:53:40 <Ariakenom> that use of postfix refers to f x instead being x f there. And technically not composition
23:53:58 <dminuoso> If that was the case I'd expcet it to be because of >>=
23:54:10 <monochrom> Oh! Maybe I meant prefix.
23:54:11 <cocreature> yeah it’s kind of weird that for Monad we default to composing the other way around
23:54:19 <cocreature> although personally I use =<< and <=< more often
23:55:07 <cocreature> infty: often I introduce (.) when refactoring code that previously wasn’t point free, e.g., refactoring f (g x) into f . g and then the order is quite convenient
23:55:54 <dminuoso> Quick bikeshedding: https://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Monad.html#v:-62--61--62- does anyone else think it's bad to call (>=>) "composition of monads"?
23:56:05 <dminuoso> It's composition of kleisli arrows. The monad itself is *certainly not composed*
23:56:17 <dminuoso> Or is my pedantry setting too high?
23:56:27 <infty> cocreature: Thanks for providing some context, I'll try to get used to both.
23:57:33 <dminuoso> Or does "composition of monads"
23:57:38 <dminuoso> mean "composition in the world of monads"
23:57:46 <cocreature> infty: also just to be clear, there is nothing wrong with taking a bottom-up approach and therefore using a flipped version of (.). all I’m saying is that (.) is quite common so you should familiarize yourself with that as well
23:58:13 <jesyspa> dminuoso: I agree, "composition of monads" has a pretty clear meaning that's taken.  "composition of monadic actions" or something would be okay-ish.
23:59:17 <cocreature> it does say “Kleisli composition of monads” rather than just “composition of monads” but yeah that’s still somewhat confusing
23:59:25 <cocreature> on the other hand I can’t be bothered to care :)
23:59:54 <dminuoso> cocreature: Oh was just asking for feedback to see if there's any traction. Might make it a small doc fix pr.
